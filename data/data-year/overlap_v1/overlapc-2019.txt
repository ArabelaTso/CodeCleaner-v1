--- 0 --
Question ID: e956b4438ff4b676e61242c13dba23140014991a_42
Original Code:
```
int
sdp_put_off_hold (sdp_t * sdp)
{
  int pos;
  int pos_media = -1;
  char *rcvsnd;

  pos = 0;
  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
  while (rcvsnd != NULL)
    {
      if (rcvsnd != NULL && (0 == strcmp (rcvsnd, "sendonly")
			     || 0 == strcmp (rcvsnd, "recvonly")))
	{
	  sprintf (rcvsnd, "sendrecv");
	}
      pos++;
      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
    }

  pos_media = 0;
  while (!sdp_endof_media (sdp, pos_media))
    {
      pos = 0;
      rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
      while (rcvsnd != NULL)
	{
	  if (rcvsnd != NULL && (0 == strcmp (rcvsnd, "sendonly")
				 || 0 == strcmp (rcvsnd, "recvonly")))
	    {
	      sprintf (rcvsnd, "sendrecv");
	    }
	  pos++;
	  rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
	}
      pos_media++;
    }

  return 0;
}
```


Overlapping Code:
```
 (sdp_t * sdp)
{
int pos;
int pos_media = -1;
char *rcvsnd;
pos = 0;
rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
while (rcvsnd != NULL)
{
if (rcvsnd != NULL && (0 == strcmp (rcvsnd, "sendonly")
|| 0 == strcmp (rcvsnd, "recvonly")))
{
sprintf (rcvsnd, "sendrecv");
}
pos++;
rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
}
pos_media = 0;
while (!sdp_endof_media (sdp, pos_media))
{
pos = 0;
rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
while (rcvsnd != NULL)
{
if (rcvsnd != NULL && (0 == strcmp (rcvsnd, "sendonly")
|| 0 == strcmp (rcvsnd, "recvonly")))
{
sprintf (rcvsnd, "sendrecv");
}
pos++;
rcvsnd = sdp_a_att_field_get (sdp, pos_media, pos);
}
pos_media++;
}
re
```
<Overlap Ratio: 0.9594405594405594>

---

--- 1 --
Question ID: 2ce3df37a07bfd7340b9da043b48bf833502c7c1_5
Original Code:
```
NATIVE int IInPlcMult(hplc, cp) /* WINIGNORE - unused in WIN */
struct PLC **hplc;
CP cp;
{
	struct PLC *pplc = *hplc;
			CP far *lprgcp = LprgcpForPlc(pplc);
			CP far *lpcp;
			int icp;
			long lcp;

			if (lprgcp[0] + DcpAdjust(pplc, 0) >= cp)
			return 0;
			icp = IInPlc(hplc, cp);
			lcp = icp;

			for (lpcp = (char far *)lprgcp + sizeof(CP) * lcp;
			icp > 0 && *(lpcp - 1) + DcpAdjust(pplc, icp - 1)== *lpcp + DcpAdjust(pplc, icp);
			icp--, lpcp--)
			;
			return(icp);
}
```


Overlapping Code:
```
- unused in WIN */
struct PLC **hplc;
CP cp;
{
struct PLC *pplc = *hplc;
CP far *lprgcp = LprgcpForPlc(pplc);
CP far *lpcp;
int icp;
long lcp;
if (lprgcp[0] + DcpAdjust(pplc, 0) >= cp)
return 0;
icp = IInPlc(hplc, cp);
lcp = icp;
for (lpcp = (char far *)lprgcp + sizeof(CP) * lcp;
icp > 0 && *(lpcp - 1) + DcpAdjust(pplc, icp - 1)== *lpcp + DcpAdjust
```
<Overlap Ratio: 0.7972665148063781>

---

--- 2 --
Question ID: d0a71d599ac944a2689248ec5fac64ad05769501_4
Original Code:
```
static inline __opal_attribute_always_inline__ int mca_coll_ml_task_completion_processing(
        mca_coll_ml_task_status_t **task_status_g, opal_list_t *list)
{
    /* local variables */
    int ret = OMPI_SUCCESS;
    mca_coll_ml_task_status_t *task_status = *task_status_g;

    mca_coll_ml_collective_operation_progress_t *coll_op =
        task_status->ml_coll_operation;

    /* Pasha: Since all our collectives so far use the root
       flag, I replacing the call for custom call back function
       with setting root_flag.
       If we will see that we need some custom functionality,
       we will enable it later.
     */

    task_status->ml_coll_operation->variable_fn_params.root_flag = true;

#if 0
    /* process task completion function,
       if any was defined  */
    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {
        ret = task_status->task_comp_fn(task_status);
        if (ret != OMPI_SUCCESS) {
            return ret;
        }
    }
#endif

    /* update dependencies */
    ret = coll_ml_task_dependency_processing(task_status);
    if (ret != OMPI_SUCCESS) {
        ML_VERBOSE(3,("Failed to coll_ml_task_dependency_processing"));
        return ret;
    }

    /* process task completion function,
       if any was defined  */
    if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {
        ret = task_status->task_comp_fn(task_status);
        if (ret != OMPI_SUCCESS) {
            ML_VERBOSE(3,("Failed to task_comp_fn"));
            return ret;
        }
    }

    /* remove the descriptor from the incomplete list
       (Pasha: if the list was provided) */
    /* No need to put this an any new list - it is associcated
     * with the mca_coll_ml_collective_operation_progress_t
     * descriptor already
     */

    if (NULL != list) {
        (*task_status_g) = (mca_coll_ml_task_status_t *)
            opal_list_remove_item(list, (opal_list_item_t *)(task_status));
    }

    /* update completion counter */
    coll_op->dag_description.num_tasks_completed++;

    if(coll_op->dag_description.num_tasks_completed ==
            coll_op->coll_schedule->n_fns)
    {
        /* the actual fragment descriptor is not on any list, as
         * we can get at it from the task descriptors
         */
        ret = coll_ml_fragment_completion_processing(coll_op);
        if (OMPI_SUCCESS != ret) {
            ML_VERBOSE(3,("Failed to coll_ml_fragment_completion_processing"));
            return ret;
        }
    }

    /* return */
    return ret;
}
```


Overlapping Code:
```
int mca_coll_ml_task_completion_processing(
mca_coll_ml_task_status_t **task_status_g, opal_list_t *list)
{
/* local variables */
int ret = OMPI_SUCCESS;
mca_coll_ml_task_status_t *task_status = *task_status_g;
mca_coll_ml_collective_operation_progress_t *coll_op =
task_status->ml_coll_operation;
/* Pasha: Since all our collectives so far use the root
flag, I replacing the call for custom call back function
with setting root_flag.
If we will see that we need some custom functionality,
we will enable it later.
*/
task_status->ml_coll_operation->variable_fn_params.root_flag = true;
#if 0
/* process task completion function,
if any was defined */
if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {
ret = task_status->task_comp_fn(task_status);
if (ret != OMPI_SUCCESS) {
return ret;
}
}
#endif
/* update dependencies */
ret = coll_ml_task_dependency_processing(task_status);
if (ret != OMPI_SUCCESS) {
ML_VERBOSE(3,("Failed to coll_ml_task_dependency_processing"));
return ret;
}
/* process task completion function,
if any was defined */
if (OPAL_LIKELY(NULL != task_status->task_comp_fn)) {
ret = task_status->task_comp_fn(task_status);
if (ret != OMPI_SUCCESS) {
ML_VERBOSE(3,("Failed to task_comp_fn"));
return ret;
}
}
/* remove the descriptor from the incomplete list
(Pasha: if the list was provided) */
/* No need to put this an any new list - it is associcated
* with the mca_coll_ml_collective_operation_progress_t
* descriptor already
*/
if (NULL != list) {
(*task_status_g) = (mca_coll_ml_task_status_t *)
opal_list_remove_item(list, (opal_list_item_t *)(task_status));
}
/* update completion counter */
coll_op->dag_description.num_tasks_completed++;
if(coll_op->dag_description.num_tasks_completed ==
coll_op->coll_schedule->n_fns)
{
/* the actual fragment descriptor is not on any list, as
* we can get at it from the task descriptors
*/
ret = coll_ml_fragment_completion_processing(coll_op);
if (OMPI_SUCCESS != ret) {
ML_VERBOSE(3,("Failed to coll_ml_fragment_completion_proc
```
<Overlap Ratio: 0.9587727708533078>

---

--- 3 --
Question ID: 9f2de810643b3dd6a5a40f58dba33c6ca570be49_1
Original Code:
```
static void
betty_out(hpcio_chip_t hc, int port, int onoff)
{
	struct ucbio_softc *sc = hc->hc_sc;
	tx_chipset_tag_t tc = sc->sc_tc;	
	txreg_t reg, pos;

	pos = 1 << port;
	reg = txsibsf0_reg_read(tc, UCB1200_IO_DATA_REG);
	if (onoff)
		reg |= pos;
	else
		reg &= ~pos;
	txsibsf0_reg_write(tc, UCB1200_IO_DATA_REG, reg);
}
```


Overlapping Code:
```
rt, int onoff)
{
struct ucbio_softc *sc = hc->hc_sc;
tx_chipset_tag_t tc = sc->sc_tc; 
txreg_t reg, pos;
pos = 1 << port;
reg = txsibsf0_reg_read(tc, UCB1200_IO_DATA_REG);
if (onoff)
reg |= pos;
else
reg &= ~pos;
txsibsf0_reg_write(tc, UCB1200_IO_DAT
```
<Overlap Ratio: 0.8090614886731392>

---

--- 4 --
Question ID: 2f21f3fba3e2d961d06efd82af2dc80f2fdbc1f5_0
Original Code:
```
struct topic *topic_new(const char *name) {
    struct topic *t = sol_malloc(sizeof(*t));
    topic_init(t, name);
    return t;
}
```


Overlapping Code:
```
) {
struct topic *t = sol_malloc(sizeof(*t));
topi
```
<Overlap Ratio: 0.423728813559322>

---

--- 5 --
Question ID: f6e31f9bf4cb3d9505c19c675541b276aedd46dc_3
Original Code:
```
ANSC_STATUS
Bmc2ReqcoInitialize
    (
        ANSC_HANDLE                 hThisObject
    )
{
    PBMC2_REQ_CONTROLLER_OBJECT     pMyObject    = (PBMC2_REQ_CONTROLLER_OBJECT)hThisObject;
    ULONG                           i            = 0;

    /*
     * Until you have to simulate C++ object-oriented programming style with standard C, you don't
     * appreciate all the nice little things come with C++ language and all the dirty works that
     * have been done by the C++ compilers. Member initialization is one of these things. While in
     * C++ you don't have to initialize all the member fields inherited from the base class since
     * the compiler will do it for you, such is not the case with C.
     */
    AnscCoInitialize((ANSC_HANDLE)pMyObject);

    /*
     * Although we have initialized some of the member fields in the "create" member function, we
     * repeat the work here for completeness. While this simulation approach is pretty stupid from
     * a C++/Java programmer perspective, it's the best we can get for universal embedded network
     * programming. Before we develop our own operating system (don't expect that to happen any
     * time soon), this is the way things gonna be.
     */
    pMyObject->Oid                  = BMC2_REQ_CONTROLLER_OID;
    pMyObject->Create               = Bmc2ReqcoCreate;
    pMyObject->Remove               = Bmc2ReqcoRemove;
    pMyObject->EnrollObjects        = Bmc2ReqcoEnrollObjects;
    pMyObject->Initialize           = Bmc2ReqcoInitialize;

    pMyObject->hBmc2ComDomain       = (ANSC_HANDLE)NULL;
    pMyObject->hBmc2EnvController   = (ANSC_HANDLE)NULL;
    pMyObject->hCommandRequest      = (ANSC_HANDLE)NULL;
    pMyObject->hCommandReply        = (ANSC_HANDLE)NULL;
    pMyObject->hCommandProperty     = (ANSC_HANDLE)NULL;
    pMyObject->CliArgumentCount     = 0;
    pMyObject->bAborted             = FALSE;
    pMyObject->bActive              = FALSE;

    pMyObject->hSlapContainerReq    = (ANSC_HANDLE)NULL;
    pMyObject->hSlapBmc2Command     = (ANSC_HANDLE)NULL;
    pMyObject->hSlapBmc2Input       = (ANSC_HANDLE)NULL;
    pMyObject->hSlapBmc2Output      = (ANSC_HANDLE)NULL;

    pMyObject->GetBmc2PecIf         = Bmc2ReqcoGetBmc2PecIf;
    pMyObject->GetBmc2ComDomain     = Bmc2ReqcoGetBmc2ComDomain;
    pMyObject->SetBmc2ComDomain     = Bmc2ReqcoSetBmc2ComDomain;
    pMyObject->GetBmc2EnvController = Bmc2ReqcoGetBmc2EnvController;
    pMyObject->SetBmc2EnvController = Bmc2ReqcoSetBmc2EnvController;
    pMyObject->GetCommandRequest    = Bmc2ReqcoGetCommandRequest;
    pMyObject->SetCommandRequest    = Bmc2ReqcoSetCommandRequest;
    pMyObject->GetCommandReply      = Bmc2ReqcoGetCommandReply;
    pMyObject->SetCommandReply      = Bmc2ReqcoSetCommandReply;
    pMyObject->GetCommandProperty   = Bmc2ReqcoGetCommandProperty;
    pMyObject->SetCommandProperty   = Bmc2ReqcoSetCommandProperty;
    pMyObject->GetCliArgumentCount  = Bmc2ReqcoGetCliArgumentCount;
    pMyObject->GetCliArgument       = Bmc2ReqcoGetCliArgument;
    pMyObject->AddCliArgument       = Bmc2ReqcoAddCliArgument;
    pMyObject->RemoveCliArguments   = Bmc2ReqcoRemoveCliArguments;
    pMyObject->Abort                = Bmc2ReqcoAbort;
    pMyObject->Reset                = Bmc2ReqcoReset;

    pMyObject->Engage               = Bmc2ReqcoEngage;
    pMyObject->Cancel               = Bmc2ReqcoCancel;
    pMyObject->SetupEnv             = Bmc2ReqcoSetupEnv;
    pMyObject->CloseEnv             = Bmc2ReqcoCloseEnv;
    pMyObject->AsyncJobTask         = Bmc2ReqcoAsyncJobTask;

    pMyObject->AddControlCommand    = Bmc2ReqcoAddControlCommand;
    pMyObject->AddControlCommand2   = Bmc2ReqcoAddControlCommand2;
    pMyObject->PopControlCommand    = Bmc2ReqcoPopControlCommand;
    pMyObject->ClearCcoQueue        = Bmc2ReqcoClearCcoQueue;
    pMyObject->GetObjReference      = Bmc2ReqcoGetObjReference;
    pMyObject->AddObjReference      = Bmc2ReqcoAddObjReference;
    pMyObject->AddObjReference2     = Bmc2ReqcoAddObjReference2;
    pMyObject->DelObjReference      = Bmc2ReqcoDelObjReference;
    pMyObject->ClearOroTable        = Bmc2ReqcoClearOroTable;

    pMyObject->DispatchCommands     = Bmc2ReqcoDispatchCommands;
    pMyObject->DoReturn             = Bmc2ReqcoDoReturn;
    pMyObject->DoTransfer           = Bmc2ReqcoDoTransfer;
    pMyObject->DoExecute            = Bmc2ReqcoDoExecute;

    pMyObject->PecGetCommand        = Bmc2ReqcoPecGetCommand;
    pMyObject->PecGetInput          = Bmc2ReqcoPecGetInput;
    pMyObject->PecGetOutput         = Bmc2ReqcoPecGetOutput;
    pMyObject->PecGetDomain         = Bmc2ReqcoPecGetDomain;
    pMyObject->PecGetTerminal       = Bmc2ReqcoPecGetTerminal;
    pMyObject->PecGetApplication    = Bmc2ReqcoPecGetApplication;
    pMyObject->PecGetServer         = Bmc2ReqcoPecGetServer;

    pMyObject->PecGetBmc2Object     = Bmc2ReqcoPecGetBmc2Object;
    pMyObject->PecGetCookedPage     = Bmc2ReqcoPecGetCookedPage;
    pMyObject->PecRetCookedPage     = Bmc2ReqcoPecRetCookedPage;
    pMyObject->PecInvokeObject      = Bmc2ReqcoPecInvokeObject;

    for ( i = 0; i < BMC2_REQCO_MAX_ARGUMENT_NUMBER; i++ )
    {
        pMyObject->CliArgumentArray[i] = NULL;
    }

    AnscQueueInitializeHeader(&pMyObject->CcoQueue    );
    AnscInitializeLock       (&pMyObject->CcoQueueLock);

    for ( i = 0; i < BMC2_REQCO_ORO_TABLE_SIZE; i++ )
    {
        AnscQueueInitializeHeader(&pMyObject->OroTable[i]);
    }
    AnscInitializeLock(&pMyObject->OroTableLock);

    return  ANSC_STATUS_SUCCESS;
}
```


Overlapping Code:
```
(
ANSC_HANDLE hThisObject
)
{
PBMC2_REQ_CONTROLLER_OBJECT pMyObject = (PBMC2_REQ_CONTROLLER_OBJECT)hThisObject;
ULONG i = 0;
/*
* Until you have to simulate C++ object-oriented programming style with standard C, you don't
* appreciate all the nice little things come with C++ language and all the dirty works that
* have been done by the C++ compilers. Member initialization is one of these things. While in
* C++ you don't have to initialize all the member fields inherited from the base class since
* the compiler will do it for you, such is not the case with C.
*/
AnscCoInitialize((ANSC_HANDLE)pMyObject);
/*
* Although we have initialized some of the member fields in the "create" member function, we
* repeat the work here for completeness. While this simulation approach is pretty stupid from
* a C++/Java programmer perspective, it's the best we can get for universal embedded network
* programming. Before we develop our own operating system (don't expect that to happen any
* time soon), this is the way things gonna be.
*/
pMyObject->Oid = BMC2_REQ_CONTROLLER_OID;
pMyObject->Create = Bmc2ReqcoCreate;
pMyObject->Remove = Bmc2ReqcoRemove;
pMyObject->EnrollObjects = Bmc2ReqcoEnrollObjects;
pMyObject->Initialize = Bmc2ReqcoInitialize;
pMyObject->hBmc2ComDomain = (ANSC_HANDLE)NULL;
pMyObject->hBmc2EnvController = (ANSC_HANDLE)NULL;
pMyObject->hCommandRequest = (ANSC_HANDLE)NULL;
pMyObject->hCommandReply = (ANSC_HANDLE)NULL;
pMyObject->hCommandProperty = (ANSC_HANDLE)NULL;
pMyObject->CliArgumentCount = 0;
pMyObject->bAborted = FALSE;
pMyObject->bActive = FALSE;
pMyObject->hSlapContainerReq = (ANSC_HANDLE)NULL;
pMyObject->hSlapBmc2Command = (ANSC_HANDLE)NULL;
pMyObject->hSlapBmc2Input = (ANSC_HANDLE)NULL;
pMyObject->hSlapBmc2Output = (ANSC_HANDLE)NULL;
pMyObject->GetBmc2PecIf = Bmc2ReqcoGetBmc2PecIf;
pMyObject->GetBmc2ComDomain = Bmc2ReqcoGetBmc2ComDomain;
pMyObject->SetBmc2ComDomain = Bmc2ReqcoSetBmc2ComDomain;
pMyObject->GetBmc2EnvController = Bmc2ReqcoGetBmc2EnvController;
pMyObject->SetBmc2EnvController = Bmc2ReqcoSetBmc2EnvContro
```
<Overlap Ratio: 0.9814020028612304>

---

--- 6 --
Question ID: 79dbafce5ddd40e746a554cef78213dccbf94672_1
Original Code:
```
static void
handle_prepare (int insn, int insn2, CORE_ADDR * current_pc_ptr,
		struct prologue_info *pi, struct pifsr **pifsr_ptr)
{
  CORE_ADDR current_pc = *current_pc_ptr;
  struct pifsr *pifsr = *pifsr_ptr;
  long next = insn2 & 0xffff;
  long list12 = ((insn & 1) << 16) + (next & 0xffe0);
  long offset = (insn & 0x3e) << 1;
  static struct reg_list reg_table[] =
  {
    {0x00800, 20},		/* r20 */
    {0x00400, 21},		/* r21 */
    {0x00200, 22},		/* r22 */
    {0x00100, 23},		/* r23 */
    {0x08000, 24},		/* r24 */
    {0x04000, 25},		/* r25 */
    {0x02000, 26},		/* r26 */
    {0x01000, 27},		/* r27 */
    {0x00080, 28},		/* r28 */
    {0x00040, 29},		/* r29 */
    {0x10000, 30},		/* ep */
    {0x00020, 31},		/* lp */
    {0, 0}			/* end of table */
  };
  int i;

  if ((next & 0x1f) == 0x0b)	/* skip imm16 argument */
    current_pc += 2;
  else if ((next & 0x1f) == 0x13)	/* skip imm16 argument */
    current_pc += 2;
  else if ((next & 0x1f) == 0x1b)	/* skip imm32 argument */
    current_pc += 4;

  /* Calculate the total size of the saved registers, and add it
     it to the immediate value used to adjust SP. */
  for (i = 0; reg_table[i].mask != 0; i++)
    if (list12 & reg_table[i].mask)
      offset += v850_register_raw_size (reg_table[i].regno);
  pi->frameoffset -= offset;

  /* Calculate the offsets of the registers relative to the value
     the SP will have after the registers have been pushed and the
     imm5 value has been subtracted from it. */
  if (pifsr)
    {
      for (i = 0; reg_table[i].mask != 0; i++)
	{
	  if (list12 & reg_table[i].mask)
	    {
	      int reg = reg_table[i].regno;
	      offset -= v850_register_raw_size (reg);
	      pifsr->reg = reg;
	      pifsr->offset = offset;
	      pifsr->cur_frameoffset = pi->frameoffset;
#ifdef DEBUG
	      printf_filtered ("\tSaved register r%d, offset %d", reg, pifsr->offset);
#endif
	      pifsr++;
	    }
	}
    }
#ifdef DEBUG
  printf_filtered ("\tfound ctret after regsave func");
#endif

  /* Set result parameters. */
  *current_pc_ptr = current_pc;
  *pifsr_ptr = pifsr;
}
```


Overlapping Code:
```
_prepare (int insn, int insn2, CORE_ADDR * current_pc_ptr,
struct prologue_info *pi, struct pifsr **pifsr_ptr)
{
CORE_ADDR current_pc = *current_pc_ptr;
struct pifsr *pifsr = *pifsr_ptr;
long next = insn2 & 0xffff;
long list12 = ((insn & 1) << 16) + (next & 0xffe0);
long offset = (insn & 0x3e) << 1;
static struct reg_list reg_table[] =
{
{0x00800, 20}, /* r20 */
{0x00400, 21}, /* r21 */
{0x00200, 22}, /* r22 */
{0x00100, 23}, /* r23 */
{0x08000, 24}, /* r24 */
{0x04000, 25}, /* r25 */
{0x02000, 26}, /* r26 */
{0x01000, 27}, /* r27 */
{0x00080, 28}, /* r28 */
{0x00040, 29}, /* r29 */
{0x10000, 30}, /* ep */
{0x00020, 31}, /* lp */
{0, 0} /* end of table */
};
int i;
if ((next & 0x1f) == 0x0b) /* skip imm16 argument */
current_pc += 2;
else if ((next & 0x1f) == 0x13) /* skip imm16 argument */
current_pc += 2;
else if ((next & 0x1f) == 0x1b) /* skip imm32 argument */
current_pc += 4;
/* Calculate the total size of the saved registers, and add it
it to the immediate value used to adjust SP. */
for (i = 0; reg_table[i].mask != 0; i++)
if (list12 & reg_table[i].mask)
offset += v850_register_raw_size (reg_table[i].regno);
pi->frameoffset -= offset;
/* Calculate the offsets of the registers relative to the value
the SP will have after the registers have been pushed and the
imm5 value has been subtracted from it. */
if (pifsr)
{
for (i = 0; reg_table[i].mask != 0; i++)
{
if (list12 & reg_table[i].mask)
{
int reg = reg_table[i].regno;
offset -= v850_register_raw_size (reg);
pifsr->reg = reg;
pifsr->offset = offset;
pifsr->cur_frameoffset = pi->frameoffset;
#ifdef DEBUG
printf_filtered ("\tSaved register r%d, offset %d", reg, pifsr->offset);
#endif
pifsr++;
}
}
}
#ifdef DEBUG
printf_filtered ("\tfound ctret after regsave func");
#endif
/* Set result parameters. */
*current_pc_ptr = current_pc;
*p
```
<Overlap Ratio: 0.9800323799244468>

---

--- 7 --
Question ID: 2d76f86d1254b861af7d45410586ecf3bb82a365_77
Original Code:
```
void playSample(uint8_t chNum, uint8_t insNum, uint8_t smpNum, uint8_t note, uint16_t midiVibDepth, uint16_t midiPitch)
{
	if (instr[insNum] == NULL)
		return;

	// for sampling playback line in Smp. Ed.
	lastChInstr[chNum].instrNum = 255;
	lastChInstr[chNum].smpNum = 255;
	editor.curPlayInstr = 255;
	editor.curPlaySmp = 255;

	assert(chNum < MAX_CHANNELS && insNum <= MAX_INST && smpNum < MAX_SMP_PER_INST && note <= NOTE_OFF);
	channel_t *ch = &channel[chNum];

	memcpy(&instr[130]->smp[0], &instr[insNum]->smp[smpNum], sizeof (sample_t));

	uint8_t vol = instr[insNum]->smp[smpNum].volume;
	
	lockAudio();

	ch->instrNum = 130;
	ch->noteData = (ch->instrNum << 8) | note;
	ch->efx = 0;

	startTone(note, 0, 0, ch);

	if (note != NOTE_OFF)
	{
		retrigVolume(ch);
		retrigEnvelopeVibrato(ch);

		ch->realVol = vol;
		ch->outVol = vol;
		ch->oldVol = vol;
	}

	ch->midiVibDepth = midiVibDepth;
	ch->midiPitch = midiPitch;

	updateChannel(ch);

	unlockAudio();

	while (ch->status & IS_Trigger); // wait for sample to latch in mixer

	// for sampling playback line in Smp. Ed.
	editor.curPlayInstr = editor.curInstr;
	editor.curPlaySmp = editor.curSmp;
}
```


Overlapping Code:
```
(uint8_t chNum, uint8_t insNum, uint8_t smpNum, uint8_t note, uint16_t midiVibDepth, uint16_t midiPitch)
{
if (instr[insNum] == NULL)
return;
// for sampling playback line in Smp. Ed.
lastChInstr[chNum].instrNum = 255;
lastChInstr[chNum].smpNum = 255;
editor.curPlayInstr = 255;
editor.curPlaySmp = 255;
assert(chNum < MAX_CHANNELS && insNum <= MAX_INST && smpNum < MAX_SMP_PER_INST && note <= NOTE_OFF);
channel_t *ch = &channel[chNum];
memcpy(&instr[130]->smp[0], &instr[insNum]->smp[smpNum], sizeof (sample_t));
uint8_t vol = instr[insNum]->smp[smpNum].volume;

lockAudio();
ch->instrNum = 130;
ch->noteData = (ch->instrNum << 8) | note;
ch->efx = 0;
startTone(note, 0, 0, ch);
if (note != NOTE_OFF)
{
retrigVolume(ch);
retrigEnvelopeVibrato(ch);
ch->realVol = vol;
ch->outVol = vol;
ch->oldVol = vol;
}
ch->midiVibDepth = midiVibDepth;
ch->midiPitch = midiPitch;
updateChannel(ch);
unlockAudio();
while (ch->status & IS_Trigger); // wait for sample to latch in mixer
// for sampling playback line in Smp. Ed.
editor.curPlayInstr = editor.curInstr;
editor.curPlaySmp = editor.c
```
<Overlap Ratio: 0.9791477787851315>

---

--- 8 --
Question ID: 9f3ced7329fdcf0b1d93fcaa8ab6ff0b924f4479_112
Original Code:
```
OpCase(i_new_small_map_lit_dtq):
{
  Eterm tmp_packed1 = BeamExtraData(I[0]);
  Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);
  Eterm* dst_ptr = REG_TARGET_PTR(dst);
  Eterm res;
  Uint n;
  Eterm keys = I[1];

  HEAVY_SWAPOUT;
  res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I+2);
  HEAVY_SWAPIN;
  dst_ptr = REG_TARGET_PTR(dst);
  *dst_ptr = res;
  n = arityval(*tuple_val(keys));
  SET_I((BeamInstr *) I+2+n);
  Goto(*I);;
}
```


Overlapping Code:
```
):
{
Eterm tmp_packed1 = BeamExtraData(I[0]);
Eterm dst = db(tmp_packed1&BEAM_TIGHT_MASK);
Eterm* dst_ptr = REG_TARGET_PTR(dst);
Eterm res;
Uint n;
Eterm keys = I[1];
HEAVY_SWAPOUT;
res = erts_gc_new_small_map_lit(c_p, reg, keys, tb((tmp_packed1>>BEAM_TIGHT_SHIFT)), I+2);
HEAVY_SWAPIN;
dst_ptr = REG_TARGET_PTR(dst);
*dst_ptr = res;
n = arityval(*tuple_val(keys));
SET_I((BeamInstr *) I+2+n);
Goto(*
```
<Overlap Ratio: 0.9174311926605505>

---

--- 9 --
Question ID: 1e31f753c20b3dfdf1ea0d9a79eb5b271665faef_30
Original Code:
```
static int
process_server_set_pointer_ex(struct mod *mod, struct stream *s)
{
    int rv;
    int x;
    int y;
    int bpp;
    int Bpp;
    char cur_data[32 * (32 * 4)];
    char cur_mask[32 * (32 / 8)];

    in_sint16_le(s, x);
    in_sint16_le(s, y);
    in_uint16_le(s, bpp);
    Bpp = (bpp == 0) ? 3 : (bpp + 7) / 8;
    in_uint8a(s, cur_data, 32 * (32 * Bpp));
    in_uint8a(s, cur_mask, 32 * (32 / 8));
    rv = mod->server_set_cursor_ex(mod, x, y, cur_data, cur_mask, bpp);
    return rv;
}
```


Overlapping Code:
```
server_set_pointer_ex(struct mod *mod, struct stream *s)
{
int rv;
int x;
int y;
int bpp;
int Bpp;
char cur_data[32 * (32 * 4)];
char cur_mask[32 * (32 / 8)];
in_sint16_le(s, x);
in_sint16_le(s, y);
in_uint16_le(s, bpp);
Bpp = (bpp == 0) ? 3 : (bpp + 7) / 8;
in_uint8a(s, cur_data, 32 * (32 * Bpp));
in_uint8a(s, cur_mask, 32 * (32 / 8));
rv = mod->server_set_cursor_ex(mod, x, y, cur_data, cur_mask, bpp);
return rv;
}
```
<Overlap Ratio: 0.95662100456621>

---

--- 10 --
Question ID: da8f2d18c21364800b6e64261af4b8c437f3d1d9_17
Original Code:
```
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
```


Overlapping Code:
```
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
const GV *const gv = CvGV(cv);
PERL_ARGS_ASSERT_CROAK_XS_USAGE;
if (gv) {
const char *const gvname = GvNAME(gv);
const HV *const stash = GvSTASH(gv);
const char *const hvname = stash ? HvNAME(stash) : NULL;
if (hvname)
Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
else
Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
} else {
/* Pants. I don't think that it should be possible to get here. */
Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
}
```
<Overlap Ratio: 0.9965277777777778>

---

--- 11 --
Question ID: cbf45589f1f66fa5629e814a706f49abbb169e9c_1
Original Code:
```
void doAWheelPID(SetPointInfo *p)
{
  long Perror = 0;
  long output = 0;
  int input   = 0;

  p->Encoder = readEncoder(A_WHEEL);
  input  = p->Encoder - p->PrevEnc;
  Perror = p->TargetTicksPerFrame - input;

  /*
    Avoid derivative kick and allow tuning changes,
    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
    see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
  */
  output = (AWheel_Kp * Perror - AWheel_Kd * (input - p->PrevInput) + p->ITerm) / AWheel_Ko;
  p->PrevEnc = p->Encoder;  //save current encoder value to preEncoder

  output += p->output;
  // Accumulate Integral error *or* Limit output.
  // Stop accumulating when output saturates
  if (output >= MAX_PWM)
  {
    output = MAX_PWM;
  }
  else if (output <= -MAX_PWM)
  {
    output = -MAX_PWM;
  }
  else
  {
    /*
      allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
    */
    p->ITerm += AWheel_Ki * Perror;
  }

  p->output    = output;  //save current pid output for next pid
  p->PrevInput = input;
}
```


Overlapping Code:
```
(SetPointInfo *p)
{
long Perror = 0;
long output = 0;
int input = 0;
p->Encoder = readEncoder(A_WHEEL);
input = p->Encoder - p->PrevEnc;
Perror = p->TargetTicksPerFrame - input;
/*
Avoid derivative kick and allow tuning changes,
see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-derivative-kick/
see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
*/
output = (AWheel_Kp * Perror - AWheel_Kd * (input - p->PrevInput) + p->ITerm) / AWheel_Ko;
p->PrevEnc = p->Encoder; //save current encoder value to preEncoder
output += p->output;
// Accumulate Integral error *or* Limit output.
// Stop accumulating when output saturates
if (output >= MAX_PWM)
{
output = MAX_PWM;
}
else if (output <= -MAX_PWM)
{
output = -MAX_PWM;
}
else
{
/*
allow turning changes, see http://brettbeauregard.com/blog/2011/04/improving-the-beginner%E2%80%99s-pid-tuning-changes/
*/
p->ITerm += AWheel_Ki * Perror;
}
p->output = output; //save current pid
```
<Overlap Ratio: 0.9433962264150944>

---

--- 12 --
Question ID: 818a5b3b0965306e0b12919aa589b5656c4850d7_10
Original Code:
```
int
hme_intr(v)
	void *v;
{
	struct hme_softc *sc = (struct hme_softc *)v;
	bus_space_tag_t t = sc->sc_bustag;
	bus_space_handle_t seb = sc->sc_seb;
	u_int32_t status;
	int r = 0;

	status = bus_space_read_4(t, seb, HME_SEBI_STAT);

	if ((status & HME_SEB_STAT_ALL_ERRORS) != 0)
		r |= hme_eint(sc, status);

	if ((status & (HME_SEB_STAT_TXALL | HME_SEB_STAT_HOSTTOTX)) != 0)
		r |= hme_tint(sc);

	if ((status & HME_SEB_STAT_RXTOHOST) != 0)
		r |= hme_rint(sc);

	return (r);
}
```


Overlapping Code:
```

hme_intr(v)
void *v;
{
struct hme_softc *sc = (struct hme_softc *)v;
bus_space_tag_t t = sc->sc_bustag;
bus_space_handle_t seb = sc->sc_seb;
u_int32_t status;
int r = 0;
status = bus_space_read_4(t, seb, HME_SEBI_STAT);
if ((status & HME_SEB_STAT_ALL_ERRORS) != 0)
r |= hme_eint(sc, status);
if ((status & (HME_SEB_STAT_TXALL | HME_SEB_STAT_HOSTTOTX)) != 0)
r |= hme_tint(sc);
if ((status & HME_SEB_STAT_RXTOHOST)
```
<Overlap Ratio: 0.9078947368421053>

---

--- 13 --
Question ID: 37d2e19c5d7d5f4e1e8d3f79b1b7f346b5bfc130_1
Original Code:
```
void print_byte_sh(short s) {
    int i;
    unsigned char *p;
    p = (unsigned char*)&s;
    for (i=0; i<sizeof(short); i++) {
        printf("%02x", *p);
        p++;
    }
    printf("\n");
}
```


Overlapping Code:
```

unsigned char *p;
p = (unsigned char*)&s;
for (i=0; i<sizeof(short); i++) {
printf("%02x", *p);
p++;
}
p
```
<Overlap Ratio: 0.6774193548387096>

---

--- 14 --
Question ID: 3da3f62fa9020c0fd3b637aebc8d5b60876041e4_26
Original Code:
```
static inline void
mprq_buf_replace(struct mlx5_rxq_data *rxq, uint16_t rq_idx)
{
	struct mlx5_mprq_buf *rep = rxq->mprq_repl;
	volatile struct mlx5_wqe_data_seg *wqe =
		&((volatile struct mlx5_wqe_mprq *)rxq->wqes)[rq_idx].dseg;
	void *addr;

	assert(rep != NULL);
	/* Replace MPRQ buf. */
	(*rxq->mprq_bufs)[rq_idx] = rep;
	/* Replace WQE. */
	addr = mlx5_mprq_buf_addr(rep);
	wqe->addr = rte_cpu_to_be_64((uintptr_t)addr);
	/* If there's only one MR, no need to replace LKey in WQE. */
	if (unlikely(mlx5_mr_btree_len(&rxq->mr_ctrl.cache_bh) > 1))
		wqe->lkey = mlx5_rx_addr2mr(rxq, (uintptr_t)addr);
	/* Stash a mbuf for next replacement. */
	if (likely(!rte_mempool_get(rxq->mprq_mp, (void **)&rep)))
		rxq->mprq_repl = rep;
	else
		rxq->mprq_repl = NULL;
}
```


Overlapping Code:
```
mlx5_rxq_data *rxq, uint16_t rq_idx)
{
struct mlx5_mprq_buf *rep = rxq->mprq_repl;
volatile struct mlx5_wqe_data_seg *wqe =
&((volatile struct mlx5_wqe_mprq *)rxq->wqes)[rq_idx].dseg;
void *addr;
assert(rep != NULL);
/* Replace MPRQ buf. */
(*rxq->mprq_bufs)[rq_idx] = rep;
/* Replace WQE. */
addr = mlx5_mprq_buf_addr(rep);
wqe->addr = rte_cpu_to_be_64((uintptr_t)addr);
/* If there's only one MR, no need to replace LKey in WQE. */
if (unlikely(mlx5_mr_btree_len(&rxq->mr_ctrl.cache_bh) > 1))
wqe->lkey = mlx5_rx_addr2mr(rxq, (uintptr_t)addr);
/* Stash a mbuf for next replacement. */
if (likely(!rte_mempool_get(rxq->mprq_mp, (void **)&rep)))
rxq->mprq_repl = rep;
```
<Overlap Ratio: 0.9013513513513514>

---

--- 15 --
Question ID: a27cd784ab01ffb5fea45300fe9957933503af15_188
Original Code:
```
JNICALL Java_org_lwjgl_system_JNI_callPPPP__JJ_3IJ(JNIEnv *__env, jclass clazz, jlong param0, jlong param1, jintArray param2, jlong __functionAddress) {
    UNUSED_PARAMS(__env, clazz)
    void *paramArray2 = param2 == NULL ? NULL : (*__env)->GetIntArrayElements(__env, param2, NULL);
    jlong __result = (jlong)((intptr_t (APIENTRY *) (intptr_t, intptr_t, intptr_t))(intptr_t)__functionAddress)((intptr_t)param0, (intptr_t)param1, (intptr_t)paramArray2);
    if (param2 != NULL) { (*__env)->ReleaseIntArrayElements(__env, param2, paramArray2, 0); }
    return __result;
}
```


Overlapping Code:
```
a_org_lwjgl_system_JNI_callPPPP__JJ_3IJ(JNIEnv *__env, jclass clazz, jlong param0, jlong param1, jintArray param2, jlong __functionAddress) {
UNUSED_PARAMS(__env, clazz)
void *paramArray2 = param2 == NULL ? NULL : (*__env)->GetIntArrayElements(__env, param2, NULL);
jlong __result = (jlong)((intptr_t (APIENTRY *) (intptr_t, intptr_t, intptr_t))(intptr_t)__functionAddress)((intptr_t)param0, (intptr_t)param1, (intptr_t)paramArray2);
if (param2 != NULL) { (*__env)->ReleaseIntArrayElements(__env, param2, paramArray2, 0); }
return __result;
}
```
<Overlap Ratio: 0.9801084990958409>

---

--- 16 --
Question ID: df25e0e2a8ba617fb4a9506e49e137bd6fb744aa_6
Original Code:
```
void do_check1()
{
        object cart;
        object ob = this_object();

        if( living(ob) && query("qi", ob)>0 )
        {
                remove_call_out("do_check1");
                call_out("do_check1",B_TIME);
        }
        else
        {
                message_vision(HIR"$N在昏迷中突然急促地呻吟了一聲，然後就再沒有聲音了。\n"NOR,ob);
             if (objectp(cart = present("cart", environment(ob)))) destruct(cart);

             ob -> receive_damage("qi",1000);
        }
}
```


Overlapping Code:
```
{
object cart;
object ob = this_object();
if( living(ob) && query("qi", ob)>0 )
{
remove_call_out("do_check1");
call_out("do_check1",B_TIME);
}
else
{
message_vision(HIR"$N在昏迷中突然急促地呻吟了一聲，然後就再沒有聲音了。\n"NOR,ob);
if (objectp(cart = present("cart", environment(ob)))) destruct(cart);
ob -> receive_damage(
```
<Overlap Ratio: 0.9036144578313253>

---

--- 17 --
Question ID: 332fdd0f185a36d560111b1220358f5823fa09b8_0
Original Code:
```
Node Pop()
	{
		std::unique_lock lock(mutex);
		if (queue.empty())
			condition_variable.wait(lock,[this] {return !queue.empty(); });
		auto temp = std::move(queue.front());
		queue.pop_front();
		return temp;
	}
```


Overlapping Code:
```
()
{
std::unique_lock lock(mutex);
if (queue.empty())
condition_variable.wait(lock,[this] {return !queue.empty(); });
auto temp = std::move(queue.front());
queue.pop_front();
return temp;
```
<Overlap Ratio: 0.949238578680203>

---

--- 18 --
Question ID: 1e73e68c0798fa3b523b939f2dc3bd8ab551d6b8_18
Original Code:
```
static void port_event(LV2UI_Handle handle, uint32_t port_index,
                        uint32_t buffer_size, uint32_t format,
                        const void * buffer) {
    X11_UI* ui = (X11_UI*)handle;
    float value = *(float*)buffer;
    if (port_index == GAIN) {
        check_value_changed(ui->widget->adj, &value);
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    } else if (port_index == VOWEL) {
        check_value_changed(ui->win->adj_x, &value);
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    } else if (port_index == NOTE) {
        check_value_changed(ui->win->adj_y, &value);
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    } else if (port_index == GATE) {
        adj_changed(ui->win, GATE, value);
    }  else if (port_index == MIDIVOWEL) {
        if (ui->ignore_midi_vowel) {
            ui->ignore_midi_vowel = false;
            return;
        }
        if (ui->midi_vowel != value) {
            if(value>-0.1 && value<4.1) {
                check_value_changed(ui->win->adj_x, &value);
                // prevent event loop between host and plugin
                ui->block_event = VOWEL;
                ui->midi_vowel = value;
            }
        }
    } else if (port_index == MIDINOTE) {
        if (ui->ignore_midi_note) {
            ui->ignore_midi_note = false;
            return;
        }
        if (ui->midi_note != value) {
            if(value >-1.0 && value<127.0) {
                check_value_changed(ui->win->adj_y, &value);
                // prevent event loop between host and plugin
                ui->block_event = NOTE;
                ui->midi_note = value;
            }
        }
    } else if (port_index == MIDIGATE) {
        if (ui->ignore_midi_gate) {
            ui->ignore_midi_gate = false;
            return;
        }
        if (ui->midi_gate != value) {
            if(value>-0.1 && value<1.1) {
                adj_changed(ui->win, GATE, value);
                ui->midi_gate = value;
            }
        }
    } else if (port_index == SCALE) {
        check_value_changed(ui->button->adj, &value);
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    } else if (port_index == SUSTAIN) {
        check_value_changed(ui->sustain_slider->adj, &value);
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    } else if (port_index == PANIC) {
        ui->panic = value;
        // prevent event loop between host and plugin
        ui->block_event = (int)port_index;
    }
}
```


Overlapping Code:
```
tic void port_event(LV2UI_Handle handle, uint32_t port_index,
uint32_t buffer_size, uint32_t format,
const void * buffer) {
X11_UI* ui = (X11_UI*)handle;
float value = *(float*)buffer;
if (port_index == GAIN) {
check_value_changed(ui->widget->adj, &value);
// prevent event loop between host and plugin
ui->block_event = (int)port_index;
} else if (port_index == VOWEL) {
check_value_changed(ui->win->adj_x, &value);
// prevent event loop between host and plugin
ui->block_event = (int)port_index;
} else if (port_index == NOTE) {
check_value_changed(ui->win->adj_y, &value);
// prevent event loop between host and plugin
ui->block_event = (int)port_index;
} else if (port_index == GATE) {
adj_changed(ui->win, GATE, value);
} else if (port_index == MIDIVOWEL) {
if (ui->ignore_midi_vowel) {
ui->ignore_midi_vowel = false;
return;
}
if (ui->midi_vowel != value) {
if(value>-0.1 && value<4.1) {
check_value_changed(ui->win->adj_x, &value);
// prevent event loop between host and plugin
ui->block_event = VOWEL;
ui->midi_vowel = value;
}
}
} else if (port_index == MIDINOTE) {
if (ui->ignore_midi_note) {
ui->ignore_midi_note = false;
return;
}
if (ui->midi_note != value) {
if(value >-1.0 && value<127.0) {
check_value_changed(ui->win->adj_y, &value);
// prevent event loop between host and plugin
ui->block_event = NOTE;
ui->midi_note = value;
}
}
} else if (port_index == MIDIGATE) {
if (ui->ignore_midi_gate) {
ui->ignore_midi_gate = false;
return;
}
if (ui->midi_gate != value) {
if(value>-0.1 && value<1.1) {
adj_changed(ui->win, GATE, value);
ui->midi_gate = value;
}
}
} else if (port_index == SCALE) {
check_value_changed(ui->button->adj, &value);
// prevent event loop between host and plugin
ui->block_event = (int)port_index;
} else if (port_index == SUSTAIN) {
check_value_changed(ui->sustain_slider->adj, &value);
// prevent event loop between host and plugin
ui-
```
<Overlap Ratio: 0.9984025559105432>

---

--- 19 --
Question ID: ae791bf2d05771b88cb364dbc9e9f4e43436642b_0
Original Code:
```
LIBSBML_EXTERN SBMLIdConverter : public SBMLConverter
{
public:

  /** @cond doxygenLibsbmlInternal */
  /**
   * Register with the ConversionRegistry.
   */
  static void init();

  /** @endcond */


  /**
   * Creates a new SBMLIdConverter object.
   */
  SBMLIdConverter();


  /**
   * Copy constructor; creates a copy of an SBMLIdConverter
   * object.
   *
   * @param obj the SBMLIdConverter object to copy.
   */
  SBMLIdConverter(const SBMLIdConverter& obj);


  /**
   * Creates and returns a deep copy of this SBMLIdConverter
   * object.
   *
   * @return a (deep) copy of this converter.
   */
  virtual SBMLIdConverter* clone() const;


  /**
   * Destroy this SBMLIdConverter object.
   */
  virtual ~SBMLIdConverter ();


  /**
   * Returns @c true if this converter object's properties match the given
   * properties.
   *
   * A typical use of this method involves creating a ConversionProperties
   * object, setting the options desired, and then calling this method on
   * an SBMLIdConverter object to find out if the object's
   * property values match the given ones.  This method is also used by
   * SBMLConverterRegistry::getConverterFor(@if java ConversionProperties@endif)
   * to search across all registered converters for one matching particular
   * properties.
   *
   * @param props the properties to match.
   *
   * @return @c true if this converter's properties match, @c false
   * otherwise.
   */
  virtual bool matchesProperties(const ConversionProperties &props) const;


  /**
   * Perform the conversion.
   *
   * This method causes the converter to do the actual conversion work,
   * that is, to convert the SBMLDocument object set by
   * SBMLConverter::setDocument(@if java SBMLDocument@endif) and
   * with the configuration options set by
   * SBMLConverter::setProperties(@if java ConversionProperties@endif).
   *
   * @copydetails doc_returns_success_code
   * @li @sbmlconstant{LIBSBML_OPERATION_SUCCESS, OperationReturnValues_t}
   * @li @sbmlconstant{LIBSBML_OPERATION_FAILED, OperationReturnValues_t}
   * @li @sbmlconstant{LIBSBML_INVALID_OBJECT, OperationReturnValues_t}
   * @li @sbmlconstant{LIBSBML_UNEXPECTED_ATTRIBUTE, OperationReturnValues_t}
   * @li @sbmlconstant{LIBSBML_INVALID_ATTRIBUTE_VALUE, OperationReturnValues_t}
   */
  virtual int convert();


  /**
   * Returns the default properties of this converter.
   *
   * A given converter exposes one or more properties that can be adjusted
   * in order to influence the behavior of the converter.  This method
   * returns the @em default property settings for this converter.  It is
   * meant to be called in order to discover all the settings for the
   * converter object.
   *
   * @return the ConversionProperties object describing the default properties
   * for this converter.
   */
  virtual ConversionProperties getDefaultProperties() const;

}
```


Overlapping Code:
```
L_EXTERN SBMLIdConverter : public SBMLConverter
{
public:
/** @cond doxygenLibsbmlInternal */
/**
* Register with the ConversionRegistry.
*/
static void init();
/** @endcond */
/**
* Creates a new SBMLIdConverter object.
*/
SBMLIdConverter();
/**
* Copy constructor; creates a copy of an SBMLIdConverter
* object.
*
* @param obj the SBMLIdConverter object to copy.
*/
SBMLIdConverter(const SBMLIdConverter& obj);
/**
* Creates and returns a deep copy of this SBMLIdConverter
* object.
*
* @return a (deep) copy of this converter.
*/
virtual SBMLIdConverter* clone() const;
/**
* Destroy this SBMLIdConverter object.
*/
virtual ~SBMLIdConverter ();
/**
* Returns @c true if this converter object's properties match the given
* properties.
*
* A typical use of this method involves creating a ConversionProperties
* object, setting the options desired, and then calling this method on
* an SBMLIdConverter object to find out if the object's
* property values match the given ones. This method is also used by
* SBMLConverterRegistry::getConverterFor(@if java ConversionProperties@endif)
* to search across all registered converters for one matching particular
* properties.
*
* @param props the properties to match.
*
* @return @c true if this converter's properties match, @c false
* otherwise.
*/
virtual bool matchesProperties(const ConversionProperties &props) const;
/**
* Perform the conversion.
*
* This method causes the converter to do the actual conversion work,
* that is, to convert the SBMLDocument object set by
* SBMLConverter::setDocument(@if java SBMLDocument@endif) and
* with the configuration options set by
* SBMLConverter::setProperties(@if java ConversionProperties@endif).
*
* @copydetails doc_returns_success_code
* @li @sbmlconstant{LIBSBML_OPERATION_SUCCESS, OperationReturnValues_t}
* @li @sbmlconstant{LIBSBML_OPERATION_FAILED, OperationReturnValues_t}
* @li @sbmlconstant{LIBSBML_INVALID_OBJECT, OperationReturnValues_t}
* @li @sbmlconstant{LIBSBML_UNEXPECTED_ATTRIBUTE, OperationReturnValues_t}
* @li @sbmlconstant{LIBSBML_INVALID_ATTRIBUTE_VALUE, OperationReturnValues_t}
*/
virtual int convert();
/**
* Returns the default properties of this converter.
*
* A given converter exposes one or more properties that can be adjusted
* in order to influence the b
```
<Overlap Ratio: 0.9965141612200435>

---

--- 20 --
Question ID: 79ec8a0f4e234203ffa359f6f822b8e348cc2afb_1
Original Code:
```
ret_t rtl8370_setAsicIpMulticastPortIsoLeaky( uint32 port, uint32 enabled )
{
    if(port > RTL8370_PORTIDMAX)
        return RT_ERR_PORT_ID;

    if(enabled > 1)
        return RT_ERR_ENABLE;
    
    return rtl8370_setAsicRegBit(RTL8370_REG_IPMCAST_PORTISO_LEAKY, port, enabled);
}
```


Overlapping Code:
```
_t rtl8370_setAsicIpMulticastPortIsoLeaky( uint32 port, uint32 enabled )
{
if(port > RTL8370_PORTIDMAX)
return RT_ERR_PORT_ID;
if(enabled > 1)
return RT_ERR_ENABLE;

return rtl8370_setAsicRegBit(RTL83
```
<Overlap Ratio: 0.8>

---

--- 21 --
Question ID: 3d125b7fccfa256d5fc0acdd2ee71f38b7d6de89_18
Original Code:
```
void OvsSendControlPacketWithAutoSplit(OPENVPN_CHANNEL *c, UCHAR opcode, UCHAR *data, UINT data_size)
{
	BUF *b;
	// Validate arguments
	if (c == NULL || (data_size != 0 && data == NULL))
	{
		return;
	}

	b = NewBuf();
	WriteBuf(b, data, data_size);
	SeekBuf(b, 0, 0);

	while (true)
	{
		UCHAR tmp[OPENVPN_CONTROL_PACKET_MAX_DATASIZE];
		UINT size = ReadBuf(b, tmp, sizeof(tmp));

		if (size == 0)
		{
			break;
		}

		OvsSendControlPacket(c, opcode, tmp, size);
		//Debug(" *** CNT SEND %u\n", size);
	}

	FreeBuf(b);
}
```


Overlapping Code:
```
oid OvsSendControlPacketWithAutoSplit(OPENVPN_CHANNEL *c, UCHAR opcode, UCHAR *data, UINT data_size)
{
BUF *b;
// Validate arguments
if (c == NULL || (data_size != 0 && data == NULL))
{
return;
}
b = NewBuf();
WriteBuf(b, data, data_size);
SeekBuf(b, 0, 0);
while (true)
{
UCHAR tmp[OPENVPN_CONTROL_PACKET_MAX_DATASIZE];
UINT size = ReadBuf(b, tmp, sizeof(tmp));
if (size == 0)
{
break;
}
OvsSendControlPacket(c, opcode, tmp, size);
//Debug(" *** CNT 
```
<Overlap Ratio: 0.9279835390946503>

---

--- 22 --
Question ID: 03ee5857587a392b2677e355fdec9ab950f578e5_18
Original Code:
```
DWORD
VmAfdPrintCACertificates(
    PVMAFD_CA_CERT_ARRAY pCertArray
    )
{
    DWORD   dwError = 0;
    PSTR    pszCN = NULL;
    int     i = 0;
    PVMAFD_CA_CERT  pCert = NULL;

    if (!pCertArray || pCertArray->dwCount == 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_VMAFD_ERROR(dwError);
    }

    fprintf(stdout,
            "Number of certificates:\t%d\n",
            pCertArray->dwCount
            );

    for (; i < pCertArray->dwCount; ++i)
    {
        fprintf(stdout, "#%d:\n", i + 1);

        pCert = &pCertArray->pCACerts[i];

        dwError = VmAfdExtractCNFromDN((PSTR)pCert->pCN, &pszCN);
        BAIL_ON_VMAFD_ERROR(dwError);

        fprintf(stdout, "CN(id):\t\t%s\n", pszCN);
        fprintf(stdout, "Subject DN:\t%s\n", (PSTR)pCert->pSubjectDN);
        fprintf(stdout, "CRL present:\t%s\n", (PSTR)pCert->pCrl ? "yes" : "no");

        VMAFD_SAFE_FREE_MEMORY(pszCN);
    }

cleanup:
    VMAFD_SAFE_FREE_MEMORY(pszCN);
    return dwError;

error :
    goto cleanup;
}
```


Overlapping Code:
```
tCACertificates(
PVMAFD_CA_CERT_ARRAY pCertArray
)
{
DWORD dwError = 0;
PSTR pszCN = NULL;
int i = 0;
PVMAFD_CA_CERT pCert = NULL;
if (!pCertArray || pCertArray->dwCount == 0)
{
dwError = ERROR_INVALID_PARAMETER;
BAIL_ON_VMAFD_ERROR(dwError);
}
fprintf(stdout,
"Number of certificates:\t%d\n",
pCertArray->dwCount
);
for (; i < pCertArray->dwCount; ++i)
{
fprintf(stdout, "#%d:\n", i + 1);
pCert = &pCertArray->pCACerts[i];
dwError = VmAfdExtractCNFromDN((PSTR)pCert->pCN, &pszCN);
BAIL_ON_VMAFD_ERROR(dwError);
fprintf(stdout, "CN(id):\t\t%s\n", pszCN);
fprintf(stdout, "Subject DN:\t%s\n", (PSTR)pCert->pSubjectDN);
fprintf(stdout, "CRL present:\t%s\n", (PSTR)pCert->pCrl ? "yes" : "no");
VMAFD_SAFE_FREE_MEMORY(pszCN);
}
cleanup:
VMAFD_SAFE_FREE_MEMORY(pszCN);
return dwError;
error :
goto cleanup
```
<Overlap Ratio: 0.9779951100244498>

---

--- 23 --
Question ID: 9b3a0403751119b51f3d6dd8940b316229054d56_3
Original Code:
```
static int availablePages_add(stasis_allocation_policy_t *ap, pageid_t pageid, size_t freespace) {
  int ret = availablePages_remove(ap, pageid);
  availablePages_pageid_freespace* tup= malloc(sizeof(*tup));
  tup->pageid = pageid;
  tup->freespace = freespace;
  void_double_add(tup, ap->availablePages_key_pageid, ap->availablePages_key_freespace_pageid);
  return ret;
}
```


Overlapping Code:
```
_policy_t *ap, pageid_t pageid, size_t freespace) {
int ret = availablePages_remove(ap, pageid);
availablePages_pageid_freespace* tup= malloc(sizeof(*tup));
tup->pageid = pageid;
tup->freespace = freespace;
void_double_add(tup, ap->availablePages_key_pageid, ap->availablePages_key_freespace_pageid);
r
```
<Overlap Ratio: 0.8365650969529086>

---

--- 24 --
Question ID: dc83a9d979b5285bb5e9704a9d32cef199a5c129_1
Original Code:
```
static int nodeid_to_addr(int nodeid, struct sockaddr *retaddr)
{
	struct sockaddr_storage addr;
	int error;

	if (!dlm_local_count)
		return -1;

	error = dlm_nodeid_to_addr(nodeid, &addr);
	if (error)
		return error;

	if (dlm_local_addr[0]->ss_family == AF_INET) {
		struct sockaddr_in *in4  = (struct sockaddr_in *) &addr;
		struct sockaddr_in *ret4 = (struct sockaddr_in *) retaddr;
		ret4->sin_addr.s_addr = in4->sin_addr.s_addr;
	} else {
		struct sockaddr_in6 *in6  = (struct sockaddr_in6 *) &addr;
		struct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) retaddr;
		memcpy(&ret6->sin6_addr, &in6->sin6_addr,
		       sizeof(in6->sin6_addr));
	}

	return 0;
}
```


Overlapping Code:
```
tic int nodeid_to_addr(int nodeid, struct sockaddr *retaddr)
{
struct sockaddr_storage addr;
int error;
if (!dlm_local_count)
return -1;
error = dlm_nodeid_to_addr(nodeid, &addr);
if (error)
return error;
if (dlm_local_addr[0]->ss_family == AF_INET) {
struct sockaddr_in *in4 = (struct sockaddr_in *) &addr;
struct sockaddr_in *ret4 = (struct sockaddr_in *) retaddr;
ret4->sin_addr.s_addr = in4->sin_addr.s_addr;
} else {
struct sockaddr_in6 *in6 = (struct sockaddr_in6 *) &addr;
struct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) retaddr;
memcpy(&ret6->sin6_addr, &in6->sin6_addr,
sizeof(in6->sin6_addr));
}
return 0
```
<Overlap Ratio: 0.9903846153846154>

---

--- 25 --
Question ID: 29e080eea7b8731f5776c60bd5104a9744e2b051_45
Original Code:
```
XS_EUPXS(XS_threads__shared_cond_wait)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "ref_cond, ref_lock= 0");
    {
#line 1542 "shared.xs"
        SV *ssv;
        perl_cond* user_condition;
        int locks;
        user_lock *ul;
#line 1838 "shared.c"
	SV *	ref_cond = ST(0)
;
	SV *	ref_lock;

	if (items < 2)
	    ref_lock = 0;
	else {
	    ref_lock = ST(1)
;
	}
#line 1547 "shared.xs"
        if (!SvROK(ref_cond))
            Perl_croak(aTHX_ "Argument to cond_wait needs to be passed as ref");
        ref_cond = SvRV(ref_cond);
        if (SvROK(ref_cond))
            ref_cond = SvRV(ref_cond);
        ssv = Perl_sharedsv_find(aTHX_ ref_cond);
        if (! ssv)
            Perl_croak(aTHX_ "cond_wait can only be used on shared values");
        ul = S_get_userlock(aTHX_ ssv, 1);

        user_condition = &ul->user_cond;
        if (ref_lock && (ref_cond != ref_lock)) {
            if (!SvROK(ref_lock))
                Perl_croak(aTHX_ "cond_wait lock needs to be passed as ref");
            ref_lock = SvRV(ref_lock);
            if (SvROK(ref_lock)) ref_lock = SvRV(ref_lock);
            ssv = Perl_sharedsv_find(aTHX_ ref_lock);
            if (! ssv)
                Perl_croak(aTHX_ "cond_wait lock must be a shared value");
            ul = S_get_userlock(aTHX_ ssv, 1);
        }
        if (ul->lock.owner != aTHX)
            croak("You need a lock before you can cond_wait");

        /* Stealing the members of the lock object worries me - NI-S */
        MUTEX_LOCK(&ul->lock.mutex);
        ul->lock.owner = NULL;
        locks = ul->lock.locks;
        ul->lock.locks = 0;

        /* Since we are releasing the lock here, we need to tell other
         * people that it is ok to go ahead and use it */
        COND_SIGNAL(&ul->lock.cond);
        COND_WAIT(user_condition, &ul->lock.mutex);
        while (ul->lock.owner != NULL) {
            /* OK -- must reacquire the lock */
            COND_WAIT(&ul->lock.cond, &ul->lock.mutex);
        }
        ul->lock.owner = aTHX;
        ul->lock.locks = locks;
        MUTEX_UNLOCK(&ul->lock.mutex);
#line 1891 "shared.c"
    }
    XSRETURN_EMPTY;
}
```


Overlapping Code:
```
wait)
{
dVAR; dXSARGS;
if (items < 1 || items > 2)
croak_xs_usage(cv, "ref_cond, ref_lock= 0");
{
#line 1542 "shared.xs"
SV *ssv;
perl_cond* user_condition;
int locks;
user_lock *ul;
#line 1838 "shared.c"
SV * ref_cond = ST(0)
;
SV * ref_lock;
if (items < 2)
ref_lock = 0;
else {
ref_lock = ST(1)
;
}
#line 1547 "shared.xs"
if (!SvROK(ref_cond))
Perl_croak(aTHX_ "Argument to cond_wait needs to be passed as ref");
ref_cond = SvRV(ref_cond);
if (SvROK(ref_cond))
ref_cond = SvRV(ref_cond);
ssv = Perl_sharedsv_find(aTHX_ ref_cond);
if (! ssv)
Perl_croak(aTHX_ "cond_wait can only be used on shared values");
ul = S_get_userlock(aTHX_ ssv, 1);
user_condition = &ul->user_cond;
if (ref_lock && (ref_cond != ref_lock)) {
if (!SvROK(ref_lock))
Perl_croak(aTHX_ "cond_wait lock needs to be passed as ref");
ref_lock = SvRV(ref_lock);
if (SvROK(ref_lock)) ref_lock = SvRV(ref_lock);
ssv = Perl_sharedsv_find(aTHX_ ref_lock);
if (! ssv)
Perl_croak(aTHX_ "cond_wait lock must be a shared value");
ul = S_get_userlock(aTHX_ ssv, 1);
}
if (ul->lock.owner != aTHX)
croak("You need a lock before you can cond_wait");
/* Stealing the members of the lock object worries me - NI-S */
MUTEX_LOCK(&ul->lock.mutex);
ul->lock.owner = NULL;
locks = ul->lock.locks;
ul->lock.locks = 0;
/* Since we are releasing the lock here, we need to tell other
* people that it is ok to go ahead and use it */
COND_SIGNAL(&ul->lock.cond);
COND_WAIT(user_condition, &ul->lock.mutex);
while (ul->lock.owner != NULL) {
/* OK -- must reacquire the lock */
COND_WAIT(&ul->lock.cond, &ul->lock.mutex);
}
ul->lock.owner = aTHX;
ul->lock.locks = locks;
MUTEX_UNLOCK(&ul->lock.mutex);
#line 1
```
<Overlap Ratio: 0.9609784507862551>

---

--- 26 --
Question ID: 52dd05ac3bf782f97010df86c93b90482d7ba029_16
Original Code:
```
uint32_t nb_tessellator2D_delete_internal_input_segments(nb_tessellator2D_t *const restrict mesh)
{
	uint32_t removed = 0;
	for (uint32_t i = 0; i < mesh->N_input_sgm; i++) {
		msh_edge_t* restrict sgm = mesh->input_sgm[i];
		if (NULL != sgm) {
			if (NULL != sgm->t1 && NULL != sgm->t2) {
				mesh->input_sgm[i] = NULL;      
				while (NULL != sgm) {
					msh_edge_t* prev_sgm = sgm;
					sgm = medge_subsgm_next(sgm);
					medge_destroy_subsgm_attribute(prev_sgm);
					removed += 1;
				}
			}
		}
	}
	return removed;
}
```


Overlapping Code:
```
sellator2D_delete_internal_input_segments(nb_tessellator2D_t *const restrict mesh)
{
uint32_t removed = 0;
for (uint32_t i = 0; i < mesh->N_input_sgm; i++) {
msh_edge_t* restrict sgm = mesh->input_sgm[i];
if (NULL != sgm) {
if (NULL != sgm->t1 && NULL != sgm->t2) {
mesh->input_sgm[i] = NULL; 
while (NULL != sgm) {
msh_edge_t* prev_sgm = sgm;
sgm = medge_subsgm_next(sgm);
medge_destroy_subsgm_attribute(prev_sgm);
removed += 1;
}
}
}
}
return remov
```
<Overlap Ratio: 0.9574468085106383>

---

--- 27 --
Question ID: ee34998d0f0af6a9dcf37da553c21af3a6f3094b_0
Original Code:
```
interface MSResizeSheet : CHSheetController
{
    BOOL _hasDoneFirstScale;
    double _scale;
    NSDictionary *_selectedObjectsBackup;
    NSTimer *_refreshTimer;
    NSTextField *_scalingField;
    NSTextField *_widthField;
    NSTextField *_heightField;
    NSTextField *_labelField;
    long long _scalingOriginCorner;
    NSView *_originButtonsContainer;
    NSTextField *_originLabel;
    struct CGRect _originalRect;
}
```


Overlapping Code:
```
{
BOOL _hasDoneFirstScale;
double _scale;
NSDictionary *_selectedObjectsBackup;
NSTimer *_refreshTimer;
NSTextField *_scalingField;
NSTextField *_widthField;
NSTextField *_heightField;
NSTextField *_labelField;
long long _scalingOriginCorner;
NSView *_originButtonsContainer;
NSTextField *_originLabe
```
<Overlap Ratio: 0.7957559681697612>

---

--- 28 --
Question ID: ef2e117259d0ee31c1292af9c844a612aefa40b8_4
Original Code:
```
void
__txn_remlock(env, txn, lock, locker)
	ENV *env;
	DB_TXN *txn;
	DB_LOCK *lock;
	DB_LOCKER *locker;
{
	TXN_EVENT *e, *next_e;

	for (e = TAILQ_FIRST(&txn->events); e != NULL; e = next_e) {
		next_e = TAILQ_NEXT(e, links);
		if ((e->op != TXN_TRADE && e->op != TXN_TRADED) ||
		    (e->u.t.lock.off != lock->off && e->u.t.locker != locker))
			continue;
		TAILQ_REMOVE(&txn->events, e, links);
		__os_free(env, e);
	}

	return;
}
```


Overlapping Code:
```
, locker)
ENV *env;
DB_TXN *txn;
DB_LOCK *lock;
DB_LOCKER *locker;
{
TXN_EVENT *e, *next_e;
for (e = TAILQ_FIRST(&txn->events); e != NULL; e = next_e) {
next_e = TAILQ_NEXT(e, links);
if ((e->op != TXN_TRADE && e->op != TXN_TRADED) ||
(e->u.t.lock.off != lock->off && e->u.t.locker != locker))
continue;
TAILQ_REMOVE(&txn->events, e, links);
__os_fre
```
<Overlap Ratio: 0.8641975308641975>

---

--- 29 --
Question ID: 6801118186ac462869a62cbd51992e030c001343_2
Original Code:
```
int main(int argc, char *argv[]) {
  int e = hpx_init(&argc, &argv);
  if (e) {
    fprintf(stderr, "HPX: failed to initialize.\n");
    return e;
  }

  // run the main action
  e = hpx_run(&thread_create, &e, sizeof(e));
  hpx_finalize();
  return e;
}
```


Overlapping Code:
```
main(int argc, char *argv[]) {
int e = hpx_init(&argc, &argv);
if (e) {
fprintf(stderr, "HPX: failed to initialize.\n");
return e;
}
// run the main action
e = hpx_run(&thread_create, &e, sizeof(e));
hpx_finalize(
```
<Overlap Ratio: 0.922077922077922>

---

--- 30 --
Question ID: 668c67bd198143148b1c901a2bf13d036d624151_1
Original Code:
```
void init_serial(uint16_t base, uint16_t divisor)
{
  outb(SERIAL_DATA_PORT(base) + 1, 0x00);
  serial_conf_baud_rate(base, divisor);
  serial_conf_line(base);
  serial_conf_buff(base);
  serial_conf_modem(base);
}
```


Overlapping Code:
```
_serial(uint16_t base, uint16_t divisor)
{
outb(SERIAL_DATA_PORT(base) + 1, 0x00);
serial_conf_baud_rate(base, divisor);
serial_conf_line(base);
seria
```
<Overlap Ratio: 0.7352941176470589>

---

--- 31 --
Question ID: cf82a789934b2885f87f9a8bd2027d908347b40a_30
Original Code:
```
static int rp_encode_process_query_response(unsigned int mask,
        const rp_thread_ref *ref,
        const rp_thread_info *info,
        char *out,
        size_t out_size)
{
    size_t len;
    unsigned int tag;
    int i;

    assert(ref != NULL);
    assert(info != NULL);
    assert(out != NULL);
    assert(out_size > 0);

    /* In all cases we will have at least mask and reference thread */
    if (out_size <= 26)
        return 0;

    /* Encode header */
    *out++ = 'q';
    *out++ = 'Q';
    out_size -= 2;

    /* Encode mask */
    sprintf(out, "%08x", mask);
    out += 8;
    out_size -= 8;

    /* Encode reference thread */
    sprintf(out, "%016"PRIu64"x", ref->val);

    out += 16;
    out_size -= 16;

    for (i = 0, tag = 0;  i < 32;  i++, tag <<= 1)
    {
        if ((mask & tag) == 0)
            continue;

        if (out_size <= 10)
        {
            /* We have no place to put even tag and length */
            return 0;
        }

        /* Encode tag */
        sprintf(out, "%08x", tag);
        out += 8;
        out_size -= 8;

        switch (tag)
        {
            case RP_BIT_PROCQMASK_THREADID:
                if (out_size <= 18)
                    return 0;

                /* Encode length - it is 16 */
                rp_encode_byte(16, out);
                out += 2;
                out_size -= 2;

                /* Encode value */
                sprintf(out, "%016"PRIu64"x", info->thread_id.val);

                out += 16;
                out_size -= 16;
                break;
            case RP_BIT_PROCQMASK_EXISTS:
                /* One nibble is enough */
                if (out_size <= 3)
                    return 0;

                /* Encode Length */
                rp_encode_byte(1, out);
                out += 2;
                out_size -= 2;

                /* Encode value */
                *out++    = (info->exists) ? '1' : '0';
                out_size-- ;
                *out      = 0;
                break;
            case RP_BIT_PROCQMASK_DISPLAY:
                /* Encode length */
                len = strlen(info->display);
                assert(len <= 255);

                if (out_size <= (len + 2))
                    return 0;

                rp_encode_byte(len, out);
                out += 2;
                out_size -= 2;

                /* Encode value */
                strcpy(out, info->display);
                out      += len;
                out_size -= len;
                break;
            case RP_BIT_PROCQMASK_THREADNAME:
                /* Encode length */
                len = strlen(info->thread_name);
                assert(len <= 255);

                if (out_size <= (len + 2))
                    return 0;

                rp_encode_byte(len, out);
                out += 2;
                out_size -= 2;

                /* Encode value */
                strcpy(out, info->thread_name);
                out      += len;
                out_size -= len;
                break;
            case RP_BIT_PROCQMASK_MOREDISPLAY:
                /* Encode length */
                len = strlen(info->more_display);
                assert(len <= 255);

                if (out_size <= (len + 2))
                    return 0;

                rp_encode_byte(len, out);
                out += 2;
                out_size -= 2;

                /* Encode value */
                strcpy(out, info->more_display);
                out += len;
                out_size -= len;
                break;
            default:
                /* Unexpected tag value */
                assert(0);
                return 0;
        }
    }

    return 1;
}
```


Overlapping Code:
```
ess_query_response(unsigned int mask,
const rp_thread_ref *ref,
const rp_thread_info *info,
char *out,
size_t out_size)
{
size_t len;
unsigned int tag;
int i;
assert(ref != NULL);
assert(info != NULL);
assert(out != NULL);
assert(out_size > 0);
/* In all cases we will have at least mask and reference thread */
if (out_size <= 26)
return 0;
/* Encode header */
*out++ = 'q';
*out++ = 'Q';
out_size -= 2;
/* Encode mask */
sprintf(out, "%08x", mask);
out += 8;
out_size -= 8;
/* Encode reference thread */
sprintf(out, "%016"PRIu64"x", ref->val);
out += 16;
out_size -= 16;
for (i = 0, tag = 0; i < 32; i++, tag <<= 1)
{
if ((mask & tag) == 0)
continue;
if (out_size <= 10)
{
/* We have no place to put even tag and length */
return 0;
}
/* Encode tag */
sprintf(out, "%08x", tag);
out += 8;
out_size -= 8;
switch (tag)
{
case RP_BIT_PROCQMASK_THREADID:
if (out_size <= 18)
return 0;
/* Encode length - it is 16 */
rp_encode_byte(16, out);
out += 2;
out_size -= 2;
/* Encode value */
sprintf(out, "%016"PRIu64"x", info->thread_id.val);
out += 16;
out_size -= 16;
break;
case RP_BIT_PROCQMASK_EXISTS:
/* One nibble is enough */
if (out_size <= 3)
return 0;
/* Encode Length */
rp_encode_byte(1, out);
out += 2;
out_size -= 2;
/* Encode value */
*out++ = (info->exists) ? '1' : '0';
out_size-- ;
*out = 0;
break;
case RP_BIT_PROCQMASK_DISPLAY:
/* Encode length */
len = strlen(info->display);
assert(len <= 255);
if (out_size <= (len + 2))
return 0;
rp_encode_byte(len, out);
out += 2;
out_size -= 2;
/* Encode value */
strcpy(out, info->display);
out 
```
<Overlap Ratio: 0.9693558474046279>

---

--- 32 --
Question ID: 96a29c05bbf6f742f44e6fe1f926d75decb3c5d7_37
Original Code:
```
unsigned long LTimeCur()
{
	extern long LDaysFrom1900Dttm();
	long lTime;
	struct DTTM dttm;
	struct TIM tim;

	OsTime(&tim);
	dttm = DttmCur();
	lTime = tim.sec + 60L * 
			((long)dttm.hr * 60L /* hours in min */ +
			(long) dttm.mint + 1440L * (LDaysFrom1900Dttm(dttm)-1));

	return lTime;
}
```


Overlapping Code:
```
d long LTimeCur()
{
extern long LDaysFrom1900Dttm();
long lTime;
struct DTTM dttm;
struct TIM tim;
OsTime(&tim);
dttm = DttmCur();
lTime = tim.sec + 60L * 
((long)dttm.hr * 60L /* hours in min */ +
(long) dttm.mint + 1440L * (LDaysFrom1900Dttm(dttm)-
```
<Overlap Ratio: 0.9025270758122743>

---

--- 33 --
Question ID: 382c7db25b9f346680ed2a8d235e5423f0a83160_4
Original Code:
```
weather_values    weather_seven_values(n_int px, n_int py)
{
    n_byte    ret_val;
    n_int    val;
    n_int   map_x = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(px));
    n_int   map_y = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(py));
    
    if(IS_DAWNDUSK(m_land.time))
    {
        return WEATHER_SEVEN_DAWN_DUSK;
    }
    if(IS_NIGHT(m_land.time))
    {
        ret_val = WEATHER_SEVEN_CLEAR_NIGHT;
    }
    else
    {
        ret_val = WEATHER_SEVEN_SUNNY_DAY;
    }
    
    val = weather_pressure(map_x, map_y);
    
    if ( val == -1)
    {
        return WEATHER_SEVEN_ERROR; /* Error has already been shown */
    }
    
    if(val > WEATHER_RAIN)
    {
        return ret_val+2;
    }
    if(val > WEATHER_CLOUD)
    {
        return ret_val+1;
    }
    
    return ret_val;
}
```


Overlapping Code:
```
ather_values weather_seven_values(n_int px, n_int py)
{
n_byte ret_val;
n_int val;
n_int map_x = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(px));
n_int map_y = POSITIVE_LAND_COORD(APESPACE_TO_MAPSPACE(py));

if(IS_DAWNDUSK(m_land.time))
{
return WEATHER_SEVEN_DAWN_DUSK;
}
if(IS_NIGHT(m_land.time))
{
ret_val = WEATHER_SEVEN_CLEAR_NIGHT;
}
else
{
ret_val = WEATHER_SEVEN_SUNNY_DAY;
}

val = weather_pressure(map_x, map_y);

if ( val == -1)
{
return WEATHER_SEVEN_ERROR; /* Error has already been shown */
}

if(val > WEATHER_RAIN)
{
return ret_val+2;
}
if(val > WEATHER_CLOUD)
{
return ret_val+1;
}

re
```
<Overlap Ratio: 0.9724473257698542>

---

--- 34 --
Question ID: a1671a1f7045fb2dbf8b721380b1a8f08c4c5069_1
Original Code:
```
void HandleInput()
{
    SceCtrlData pad;
    sceCtrlPeekBufferPositive(&pad, 1);

    uint8_t controls_state = 0;
    if (pad.Buttons & PSP_CTRL_RIGHT ) controls_state |= 0x01;
    if (pad.Buttons & PSP_CTRL_LEFT  ) controls_state |= 0x02;
    if (pad.Buttons & PSP_CTRL_DOWN  ) controls_state |= 0x04;
    if (pad.Buttons & PSP_CTRL_UP    ) controls_state |= 0x08;
    if (pad.Buttons & PSP_CTRL_CROSS ) controls_state |= 0x10;
    if (pad.Buttons & PSP_CTRL_SQUARE) controls_state |= 0x20;
    if (pad.Buttons & PSP_CTRL_SELECT) controls_state |= 0x40;
    if (pad.Buttons & PSP_CTRL_START ) controls_state |= 0x80;

    supervision_set_input(controls_state);
}
```


Overlapping Code:
```
CtrlData pad;
sceCtrlPeekBufferPositive(&pad, 1);
uint8_t controls_state = 0;
if (pad.Buttons & PSP_CTRL_RIGHT ) controls_state |= 0x01;
if (pad.Buttons & PSP_CTRL_LEFT ) controls_state |= 0x02;
if (pad.Buttons & PSP_CTRL_DOWN ) controls_state |= 0x04;
if (pad.Buttons & PSP_CTRL_UP ) controls_state |= 0x08;
if (pad.Buttons & PSP_CTRL_CROSS ) controls_state |= 0x10;
if (pad.Buttons & PSP_CTRL_SQUARE) controls_state |= 0x20;
if (pad.Buttons & PSP_CTRL_SELECT) controls_state |= 0x40;
if (pad.Buttons & PSP_CTRL_START ) controls_state |= 0x80;
supervision_set_input(controls
```
<Overlap Ratio: 0.9441707717569786>

---

--- 35 --
Question ID: 4b80bf69ffdadf7c94a08c7e40e36a122d117c18_0
Original Code:
```
void bli_gemm3m2_cntl_init()
{
	// Create blocksize objects for each dimension.
	// NOTE: the complex blocksizes for 3m2 are generally equal to their
	// corresponding real domain counterparts. However, we want to promote
	// similar cache footprints for the micro-panels of A and B (when
	// compared to executing in the real domain), and since the complex
	// micro-panels are three times as "fat" (due to storing real, imaginary
	// and real+imaginary parts), we reduce KC by a factor of 2 to
	// compensate. Ideally, we would reduce by a factor of 3, but that
	// could get messy vis-a-vis keeping KC a multiple of the register
	// blocksizes.
	gemm3m2_mc
	=
	bli_blksz_obj_create( 0,                   0,
	                      0,                   0,
	                      BLIS_DEFAULT_MC_S/3, BLIS_MAXIMUM_MC_S/3,
	                      BLIS_DEFAULT_MC_D/3, BLIS_MAXIMUM_MC_D/3 );
	gemm3m2_nc
	=
	bli_blksz_obj_create( 0,                   0,
	                      0,                   0,
	                      BLIS_DEFAULT_NC_S/3, BLIS_MAXIMUM_NC_S/3,
	                      BLIS_DEFAULT_NC_D/3, BLIS_MAXIMUM_NC_D/3 );
	gemm3m2_kc
	=
	bli_blksz_obj_create( 0,                 0,
	                      0,                 0,
	                      BLIS_DEFAULT_KC_S, BLIS_MAXIMUM_KC_S,
	                      BLIS_DEFAULT_KC_D, BLIS_MAXIMUM_KC_D );
	gemm3m2_mr
	=
	bli_blksz_obj_create( 0,                 0,
	                      0,                 0,
	                      BLIS_DEFAULT_MR_S, BLIS_PACKDIM_MR_S,
	                      BLIS_DEFAULT_MR_D, BLIS_PACKDIM_MR_D );
	gemm3m2_nr
	=
	bli_blksz_obj_create( 0,                 0,
	                      0,                 0,
	                      BLIS_DEFAULT_NR_S, BLIS_PACKDIM_NR_S,
	                      BLIS_DEFAULT_NR_D, BLIS_PACKDIM_NR_D );
	gemm3m2_kr
	=
	bli_blksz_obj_create( 0,                 0,
	                      0,                 0,
	                      BLIS_DEFAULT_KR_S, BLIS_PACKDIM_KR_S,
	                      BLIS_DEFAULT_KR_D, BLIS_PACKDIM_KR_D );


	// Attach the register blksz_t objects as blocksize multiples to the cache
	// blksz_t objects.
	bli_blksz_obj_attach_mult_to( gemm3m2_mr, gemm3m2_mc );
	bli_blksz_obj_attach_mult_to( gemm3m2_nr, gemm3m2_nc );
	bli_blksz_obj_attach_mult_to( gemm3m2_kr, gemm3m2_kc );


	// The cache blocksizes that were scaled above need to be rounded down
	// to their respective nearest register blocksize multiples. Note that
	// this can only happen after the appropriate register blocksize is
	// actually attached as a multiple.
	bli_blksz_reduce_to_mult( gemm3m2_mc );
	bli_blksz_reduce_to_mult( gemm3m2_nc );


	// Attach the mr and nr blksz_t objects to each cache blksz_t object.
	// The primary example of why this is needed relates to nudging kc.
	// In hemm, symm, trmm, or trmm3, we need to know both mr and nr,
	// since the multiple we target in nudging depends on whether the
	// structured matrix is on the left or the right.
	bli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_mc );
	bli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_nc );
	bli_blksz_obj_attach_mr_nr_to( gemm3m2_mr, gemm3m2_nr, gemm3m2_kc );


	// Create function pointer object for each datatype-specific gemm
	// micro-kernel.
	gemm3m2_ukrs
	=
	bli_func_obj_create(
	    NULL,                  FALSE,
	    NULL,                  FALSE,
	    BLIS_CGEMM3M2_UKERNEL, BLIS_CGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS,
	    BLIS_ZGEMM3M2_UKERNEL, BLIS_ZGEMM3M2_UKERNEL_PREFERS_CONTIG_ROWS );


	// Create control tree objects for packm operations.
	gemm3m2_packa_cntl
	=
	bli_packm_cntl_obj_create( BLIS_BLOCKED,
	                           BLIS_VARIANT2,
	                           gemm3m2_mr,
	                           gemm3m2_kr,
	                           FALSE, // do NOT invert diagonal
	                           FALSE, // reverse iteration if upper?
	                           FALSE, // reverse iteration if lower?
	                           BLIS_PACKED_ROW_PANELS_3MS,
	                           BLIS_BUFFER_FOR_A_BLOCK );

	gemm3m2_packb_cntl
	=
	bli_packm_cntl_obj_create( BLIS_BLOCKED,
	                           BLIS_VARIANT2,
	                           gemm3m2_kr,
	                           gemm3m2_nr,
	                           FALSE, // do NOT invert diagonal
	                           FALSE, // reverse iteration if upper?
	                           FALSE, // reverse iteration if lower?
	                           BLIS_PACKED_COL_PANELS_3MI,
	                           BLIS_BUFFER_FOR_B_PANEL );


	//
	// Create a control tree for packing A and B, and streaming C.
	//

	// Create control tree object for lowest-level block-panel kernel.
	gemm3m2_cntl_bp_ke
	=
	bli_gemm_cntl_obj_create( BLIS_UNB_OPT,
	                          BLIS_VARIANT4,
	                          NULL,
	                          gemm3m2_ukrs,
	                          NULL, NULL, NULL,
	                          NULL, NULL, NULL );

	// Create control tree object for outer panel (to block-panel)
	// problem.
	gemm3m2_cntl_op_bp
	=
	bli_gemm_cntl_obj_create( BLIS_BLOCKED,
	                          BLIS_VARIANT1,
	                          gemm3m2_mc,
	                          NULL,
	                          NULL,
	                          gemm3m2_packa_cntl,
	                          gemm3m2_packb_cntl,
	                          NULL,
	                          gemm3m2_cntl_bp_ke,
	                          NULL );

	// Create control tree object for general problem via multiple
	// rank-k (outer panel) updates.
	gemm3m2_cntl_mm_op
	=
	bli_gemm_cntl_obj_create( BLIS_BLOCKED,
	                          BLIS_VARIANT3,
	                          gemm3m2_kc,
	                          NULL,
	                          NULL,
	                          NULL,
	                          NULL,
	                          NULL,
	                          gemm3m2_cntl_op_bp,
	                          NULL );

	// Create control tree object for very large problem via multiple
	// general problems.
	gemm3m2_cntl_vl_mm
	=
	bli_gemm_cntl_obj_create( BLIS_BLOCKED,
	                          BLIS_VARIANT2,
	                          gemm3m2_nc,
	                          NULL,
	                          NULL,
	                          NULL,
	                          NULL,
	                          NULL,
	                          gemm3m2_cntl_mm_op,
	                          NULL );

	// Alias the "master" gemm control tree to a shorter name.
	gemm3m2_cntl = gemm3m2_cntl_vl_mm;

}
```


Overlapping Code:
```
_cntl_init()
{
// Create blocksize objects for each dimension.
// NOTE: the complex blocksizes for 3m2 are generally equal to their
// corresponding real domain counterparts. However, we want to promote
// similar cache footprints for the micro-panels of A and B (when
// compared to executing in the real domain), and since the complex
// micro-panels are three times as "fat" (due to storing real, imaginary
// and real+imaginary parts), we reduce KC by a factor of 2 to
// compensate. Ideally, we would reduce by a factor of 3, but that
// could get messy vis-a-vis keeping KC a multiple of the register
// blocksizes.
gemm3m2_mc
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_MC_S/3, BLIS_MAXIMUM_MC_S/3,
BLIS_DEFAULT_MC_D/3, BLIS_MAXIMUM_MC_D/3 );
gemm3m2_nc
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_NC_S/3, BLIS_MAXIMUM_NC_S/3,
BLIS_DEFAULT_NC_D/3, BLIS_MAXIMUM_NC_D/3 );
gemm3m2_kc
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_KC_S, BLIS_MAXIMUM_KC_S,
BLIS_DEFAULT_KC_D, BLIS_MAXIMUM_KC_D );
gemm3m2_mr
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_MR_S, BLIS_PACKDIM_MR_S,
BLIS_DEFAULT_MR_D, BLIS_PACKDIM_MR_D );
gemm3m2_nr
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_NR_S, BLIS_PACKDIM_NR_S,
BLIS_DEFAULT_NR_D, BLIS_PACKDIM_NR_D );
gemm3m2_kr
=
bli_blksz_obj_create( 0, 0,
0, 0,
BLIS_DEFAULT_KR_S, BLIS_PACKDIM_KR_S,
BLIS_DEFAULT_KR_D, BLIS_PACKDIM_KR_D );
// Attach the register blksz_t objects as blocksize multiples to the cache
// blksz_t objects.
bli_blksz_obj_attach_mult_to( gemm3m2_mr, gemm3m2_mc );
bli_blksz_obj_attach_mult_to( gemm3m2_nr, gemm3m2_nc );
bli_blksz_obj_attach_mult_to( gemm3m2_kr, gemm3m2_kc );
// The cache blocksizes that were scaled above need to be rounded down
// to their respective nearest register blocksize multiples. Note that
// this can only happen after the a
```
<Overlap Ratio: 0.9907859078590786>

---

--- 36 --
Question ID: d76f5378066d01d133baead66e76e740bdf15776_3
Original Code:
```
static
CMR_ERROR updateHashtable(
  CMR* cmr,                         /**< \ref CMR environment. */
  DenseBinaryMatrix* dense,         /**< Matrix. */
  ElementData* majorData,           /**< Major index data. */
  size_t* processedMajors,          /**< Array of processed major indices. */
  size_t numProcessedMajors,        /**< Number of processed major indices. */
  CMR_LISTHASHTABLE* majorHashtable /**< Major index hashtable. */
)
{
  assert(cmr);
  assert(dense);
  assert(majorData);
  assert(processedMajors);
  assert(majorHashtable);

  CMRdbgMsg(8, "Updating row/column hashtable.\n");

  /* Add missing hashtable entries. */
  for (size_t i = 0; i < numProcessedMajors; i++)
  {
    size_t major = processedMajors[i];
    if (majorData[major].hashEntry == SIZE_MAX)
    {
      CMR_CALL( CMRlisthashtableInsert(cmr, majorHashtable, majorData[major].hashValue, major,
        &majorData[major].hashEntry) );
    }
  }

  return CMR_OKAY;
}
```


Overlapping Code:
```
tic
CMR_ERROR updateHashtable(
CMR* cmr, /**< \ref CMR environment. */
DenseBinaryMatrix* dense, /**< Matrix. */
ElementData* majorData, /**< Major index data. */
size_t* processedMajors, /**< Array of processed major indices. */
size_t numProcessedMajors, /**< Number of processed major indices. */
CMR_LISTHASHTABLE* majorHashtable /**< Major index hashtable. */
)
{
assert(cmr);
assert(dense);
assert(majorData);
assert(processedMajors);
assert(majorHashtable);
CMRdbgMsg(8, "Updating row/column hashtable.\n");
/* Add missing hashtable entries. */
for (size_t i = 0; i < numProcessedMajors; i++)
{
size_t major = processedMajors[i];
if (majorData[major].hashEntry == SIZE_MAX)
{
CMR_CALL( CMRlisthashtableInsert(cmr, majorHashtable, majorData[major].hashValue, major,
&majorData[major].hashEntry)
```
<Overlap Ratio: 0.9650180940892642>

---

--- 37 --
Question ID: 31570b9a6e9aa72cca60d1953c14e47938547ebe_18
Original Code:
```
static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
{
	struct tcmsg *tcm = NLMSG_DATA(n);
	struct rtattr **tca = arg;
	struct net_device *dev;
	struct Qdisc *q = NULL;
	struct Qdisc_class_ops *cops;
	unsigned long cl = 0;
	unsigned long new_cl;
	u32 pid = tcm->tcm_parent;
	u32 clid = tcm->tcm_handle;
	u32 qid = TC_H_MAJ(clid);
	int err;

	if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
		return -ENODEV;

	/*
	   parent == TC_H_UNSPEC - unspecified parent.
	   parent == TC_H_ROOT   - class is root, which has no parent.
	   parent == X:0	 - parent is root class.
	   parent == X:Y	 - parent is a node in hierarchy.
	   parent == 0:Y	 - parent is X:Y, where X:0 is qdisc.

	   handle == 0:0	 - generate handle from kernel pool.
	   handle == 0:Y	 - class is X:Y, where X:0 is qdisc.
	   handle == X:Y	 - clear.
	   handle == X:0	 - root class.
	 */

	/* Step 1. Determine qdisc handle X:0 */

	if (pid != TC_H_ROOT) {
		u32 qid1 = TC_H_MAJ(pid);

		if (qid && qid1) {
			/* If both majors are known, they must be identical. */
			if (qid != qid1)
				return -EINVAL;
		} else if (qid1) {
			qid = qid1;
		} else if (qid == 0)
			qid = dev->qdisc_sleeping->handle;

		/* Now qid is genuine qdisc handle consistent
		   both with parent and child.

		   TC_H_MAJ(pid) still may be unspecified, complete it now.
		 */
		if (pid)
			pid = TC_H_MAKE(qid, pid);
	} else {
		if (qid == 0)
			qid = dev->qdisc_sleeping->handle;
	}

	/* OK. Locate qdisc */
	if ((q = qdisc_lookup(dev, qid)) == NULL) 
		return -ENOENT;

	/* An check that it supports classes */
	cops = q->ops->cl_ops;
	if (cops == NULL)
		return -EINVAL;

	/* Now try to get class */
	if (clid == 0) {
		if (pid == TC_H_ROOT)
			clid = qid;
	} else
		clid = TC_H_MAKE(qid, clid);

	if (clid)
		cl = cops->get(q, clid);

	if (cl == 0) {
		err = -ENOENT;
		if (n->nlmsg_type != RTM_NEWTCLASS || !(n->nlmsg_flags&NLM_F_CREATE))
			goto out;
	} else {
		switch (n->nlmsg_type) {
		case RTM_NEWTCLASS:	
			err = -EEXIST;
			if (n->nlmsg_flags&NLM_F_EXCL)
				goto out;
			break;
		case RTM_DELTCLASS:
			err = cops->delete(q, cl);
			if (err == 0)
				tclass_notify(skb, n, q, cl, RTM_DELTCLASS);
			goto out;
		case RTM_GETTCLASS:
			err = tclass_notify(skb, n, q, cl, RTM_NEWTCLASS);
			goto out;
		default:
			err = -EINVAL;
			goto out;
		}
	}

	new_cl = cl;
	err = cops->change(q, clid, pid, tca, &new_cl);
	if (err == 0)
		tclass_notify(skb, n, q, new_cl, RTM_NEWTCLASS);

out:
	if (cl)
		cops->put(q, cl);

	return err;
}
```


Overlapping Code:
```
c_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n, void *arg)
{
struct tcmsg *tcm = NLMSG_DATA(n);
struct rtattr **tca = arg;
struct net_device *dev;
struct Qdisc *q = NULL;
struct Qdisc_class_ops *cops;
unsigned long cl = 0;
unsigned long new_cl;
u32 pid = tcm->tcm_parent;
u32 clid = tcm->tcm_handle;
u32 qid = TC_H_MAJ(clid);
int err;
if ((dev = __dev_get_by_index(tcm->tcm_ifindex)) == NULL)
return -ENODEV;
/*
parent == TC_H_UNSPEC - unspecified parent.
parent == TC_H_ROOT - class is root, which has no parent.
parent == X:0 - parent is root class.
parent == X:Y - parent is a node in hierarchy.
parent == 0:Y - parent is X:Y, where X:0 is qdisc.
handle == 0:0 - generate handle from kernel pool.
handle == 0:Y - class is X:Y, where X:0 is qdisc.
handle == X:Y - clear.
handle == X:0 - root class.
*/
/* Step 1. Determine qdisc handle X:0 */
if (pid != TC_H_ROOT) {
u32 qid1 = TC_H_MAJ(pid);
if (qid && qid1) {
/* If both majors are known, they must be identical. */
if (qid != qid1)
return -EINVAL;
} else if (qid1) {
qid = qid1;
} else if (qid == 0)
qid = dev->qdisc_sleeping->handle;
/* Now qid is genuine qdisc handle consistent
both with parent and child.
TC_H_MAJ(pid) still may be unspecified, complete it now.
*/
if (pid)
pid = TC_H_MAKE(qid, pid);
} else {
if (qid == 0)
qid = dev->qdisc_sleeping->handle;
}
/* OK. Locate qdisc */
if ((q = qdisc_lookup(dev, qid)) == NULL) 
return -ENOENT;
/* An check that it supports classes */
cops = q->ops->cl_ops;
if (cops == NULL)
return -EINVAL;
/* Now try to get class */
if (clid == 0) {
if (pid == TC_H_ROOT)
clid = qid;
} else
clid = TC_H_MAKE(qid, clid);
if (clid)
cl = cops->get(q, clid);
if (cl == 0) {
err = -ENOENT;
if (n->nlmsg_type != RTM_NEWTCLASS || !(n->nlmsg_flags&NLM_F_CREATE))
goto out;
} else {
switch (n->nlmsg_type) {
case RTM_NEWTCLASS: 
err = -EEXIST;
if (n->nlmsg_flags&NLM_F_EXCL)
goto out;
break;
case RTM_DELTCLASS:
err = cops->delete(q, cl);
if (err == 0)
tclass_notify(skb, n, q, cl, RTM_DELTCLASS);
goto out;
case RTM_GETTCLASS:
err = tclass_notify(skb, n, q, cl, RTM_NEWTCLASS);
goto out;
default:
err = -EINVAL;
goto out;
}
}
new_cl = cl;
err = cops->change(q, clid, pid, tca, &new_cl);
if (err == 0)
tclass_notify(skb, n, q, new_cl, RTM_NE
```
<Overlap Ratio: 0.979367866549605>

---

--- 38 --
Question ID: 8236759bd6d271082df7875f3e37018ff108c156_25
Original Code:
```
LIST_ITEM* 
LQListFindFromHead( 
	IN LOCKED_QUICK_LIST* const pLQuickList,
	IN QLIST_FIND_FUNC pfnFunc OPTIONAL,
	IN void* const Context )
{
	LIST_ITEM	*pListItem;

	ASSERT( pLQuickList );
	SpinLockAcquire(&pLQuickList->m_Lock);
	pListItem = QListFindFromHead(&pLQuickList->m_List, pfnFunc, Context);
	SpinLockRelease(&pLQuickList->m_Lock);

	return pListItem;
}
```


Overlapping Code:
```
LIST_ITEM* 
LQListFindFromHead( 
IN LOCKED_QUICK_LIST* const pLQuickList,
IN QLIST_FIND_FUNC pfnFunc OPTIONAL,
IN void* const Context )
{
LIST_ITEM *pListItem;
ASSERT( pLQuickList );
SpinLockAcquire(&pLQuickList->m_Lock);
pListItem = QListFindFromHead(&pLQuickList->m_List, pfnFunc, Context);
SpinLockRelease(&pLQuickList->m_Lock)
```
<Overlap Ratio: 0.9401709401709402>

---

--- 39 --
Question ID: d24fef90a48febf7bfc4924d3747882bf9c337ea_20
Original Code:
```
char *
ipx_phost(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
	struct sockaddr_ipx work;
	static union ipx_net ipx_zeronet;
	char *p;
	struct ipx_addr in;

	work = *sipx;
	in = work.sipx_addr;

	work.sipx_addr.x_port = 0;
	work.sipx_addr.x_net = ipx_zeronet;
	p = ipx_print((struct sockaddr *)&work);
	if (strncmp("*.", p, 2) == 0) p += 2;

	return(p);
}
```


Overlapping Code:
```
 *
ipx_phost(struct sockaddr *sa)
{
struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
struct sockaddr_ipx work;
static union ipx_net ipx_zeronet;
char *p;
struct ipx_addr in;
work = *sipx;
in = work.sipx_addr;
work.sipx_addr.x_port = 0;
work.sipx_addr.x_net = ipx_zeronet;
p = ipx_print((struct sockaddr *)&work);
if (strncmp("*.", p, 2) == 0) p +=
```
<Overlap Ratio: 0.9463806970509383>

---

--- 40 --
Question ID: c8a2463d1187dcf0a04b313a80a449c070a3d457_1
Original Code:
```
static int dpt_cmp_lsn_and_page(const void *ap, const void * bp, const void * ignored) {
  const dpt_entry * a = ap;
  const dpt_entry * b = bp;

  return (a->lsn < b->lsn) ? -1 : ((a->lsn == b->lsn) ? dpt_cmp_page(ap, bp, 0) : 1);
}
```


Overlapping Code:
```
c int dpt_cmp_lsn_and_page(const void *ap, const void * bp, const void * ignored) {
const dpt_entry * a = ap;
const dpt_entry * b = bp;
return (a->lsn < b->lsn) ? -1 : ((a->lsn == b->lsn) ? dpt_cmp_pa
```
<Overlap Ratio: 0.8849557522123894>

---

--- 41 --
Question ID: 36d0c83b3cf9fa5e3fb4329e1569fb4c11296685_5
Original Code:
```
void test_dataLength(void)
{
	int v, l;
	int bits;
	int err = 0;

	testStart("Test dataLength");
	for(v=0; v<4; v++) {
		for(l=0; l<3; l++) {
			bits = MQRspec_getDataLengthBit(v+1, (QRecLevel)l);
			if(bits != datalen[v][l]) {
				printf("Error in version %d, level %d.\n", v, l);
				err++;
			}
		}
	}
	testEnd(err);
}
```


Overlapping Code:
```
its;
int err = 0;
testStart("Test dataLength");
for(v=0; v<4; v++) {
for(l=0; l<3; l++) {
bits = MQRspec_getDataLengthBit(v+1, (QRecLevel)l);
if(bits != datalen[v][l]) {
printf("Error in version %d, l
```
<Overlap Ratio: 0.684931506849315>

---

--- 42 --
Question ID: 8d311837ca8482ecb955ef32ca01157cff00c0f4_5
Original Code:
```
char * clear_number(char *str) {
  int curr_pos = 0;
  int curr_pos_ans = 0;

  char *answer = malloc(strlen(str) * sizeof(char));

  while(str[curr_pos] != '\0') {
    if (isdigit(str[curr_pos])) {
      answer[curr_pos_ans] = str[curr_pos];
      curr_pos_ans++;
    }
    curr_pos++;
  }
  answer[curr_pos_ans] = '\0';
  
  return answer;
}
```


Overlapping Code:
```
 * clear_number(char *str) {
int curr_pos = 0;
int curr_pos_ans = 0;
char *answer = malloc(strlen(str) * sizeof(char));
while(str[curr_pos] != '\0') {
if (isdigit(str[curr_pos])) {
answer[curr_pos_ans] = str[curr_pos];
curr_pos_ans++;
}
curr_pos++;
}
```
<Overlap Ratio: 0.8305647840531561>

---

--- 43 --
Question ID: e154941c52f2cfa148d2ab9e0b4c60bcb4166df3_0
Original Code:
```
interface TFNPagingScrollView : UIScrollView <UIGestureRecognizerDelegate>
{
    _Bool _panBeyondLeftExtentShouldFailRecognizer;
    _Bool _panBeyondRightExtentShouldFailRecognizer;
    TFNPagingViewController *_pagingViewController;
}
```


Overlapping Code:
```
crollView : UIScrollView <UIGestureRecognizerDelegate>
{
_Bool _panBeyondLeftExtentShouldFailRecognizer;
_Bool _panBeyondRightExtentShouldFailRecognizer;
TFNPagingViewController
```
<Overlap Ratio: 0.7937219730941704>

---

--- 44 --
Question ID: 65d65bb6562484eb28e69a0c8ad34735d8ae15f6_4
Original Code:
```
static int
cmd_decode(tlist, cmd, sp)
	struct tablelist *tlist;
	char *cmd;
	char **sp;
{
	register struct tablelist *t;
	register int action = A_INVALID;

	/*
	 * Search thru all the command tables.
	 * Stop when we find an action which is not A_INVALID.
	 */
	for (t = tlist;  t != NULL;  t = t->t_next)
	{
		action = cmd_search(cmd, t->t_start, t->t_end, sp);
		if (action != A_INVALID)
			break;
	}
	if (action == A_UINVALID)
		action = A_INVALID;
	return (action);
}
```


Overlapping Code:
```
 int
cmd_decode(tlist, cmd, sp)
struct tablelist *tlist;
char *cmd;
char **sp;
{
register struct tablelist *t;
register int action = A_INVALID;
/*
* Search thru all the command tables.
* Stop when we find an action which is not A_INVALID.
*/
for (t = tlist; t != NULL; t = t->t_next)
{
action = cmd_search(cmd, t->t_start, t->t_end, sp);
if (action != A_INVALID)
break;
}
if (action == A_UINVALID)
ac
```
<Overlap Ratio: 0.9049773755656109>

---

--- 45 --
Question ID: ec1e02f200f56545ff66dbbc1fe0a7d9566f0ded_8
Original Code:
```
void
uslcom_break(void *vsc, int portno, int onoff)
{
	struct uslcom_softc *sc = vsc;
	usb_device_request_t req;
	int brk = onoff ? USLCOM_BREAK_ON : USLCOM_BREAK_OFF;	

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_BREAK;
	USETW(req.wValue, brk);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	usbd_do_request(sc->sc_udev, &req, NULL);
}
```


Overlapping Code:
```
k(void *vsc, int portno, int onoff)
{
struct uslcom_softc *sc = vsc;
usb_device_request_t req;
int brk = onoff ? USLCOM_BREAK_ON : USLCOM_BREAK_OFF; 
req.bmRequestType = USLCOM_WRITE;
req.bRequest = USLCOM_BREAK;
USETW(req.wValue, brk);
USETW(req.wIndex, portno);
USETW(req.wLength, 0);
usbd_do_request(sc->sc_ude
```
<Overlap Ratio: 0.9046242774566474>

---

--- 46 --
Question ID: 13793ba0ce172714355abee0ddd3291622370461_1
Original Code:
```
static inline size_t
filemap_copy_from_user_iovec(struct page *page, unsigned long offset,
			const struct iovec *iov, size_t base, size_t bytes)
{
	char *kaddr;
	size_t copied;

	kaddr = kmap_atomic(page, KM_USER0);
	copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
						base, bytes);
	kunmap_atomic(kaddr, KM_USER0);
	if (copied != bytes) {
		kaddr = kmap(page);
		copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
							base, bytes);
		kunmap(page);
	}
	return copied;
}
```


Overlapping Code:
```
c inline size_t
filemap_copy_from_user_iovec(struct page *page, unsigned long offset,
const struct iovec *iov, size_t base, size_t bytes)
{
char *kaddr;
size_t copied;
kaddr = kmap_atomic(page, KM_USER0);
copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
base, bytes);
kunmap_atomic(kaddr, KM_USER0);
if (copied != bytes) {
kaddr = kmap(page);
copied = __filemap_copy_from_user_iovec(kaddr + offset, iov,
base, bytes);
kunmap(page);
}
return copied;
```
<Overlap Ratio: 0.9850107066381156>

---

--- 47 --
Question ID: 384c823281800c1ef9228abd2ff6cb9e95177a83_5
Original Code:
```
int gleswIsSupported(int major, int minor)
{
	if (major < 2)
		return 0;
	if (version.major == major)
		return version.minor >= minor;
	return version.major >= major;
}
```


Overlapping Code:
```
sSupported(int major, int minor)
{
if (major < 2)
return 0;
if (version.major == major)
return version.minor >= minor;
return version.major >= major;

```
<Overlap Ratio: 0.9316770186335404>

---

--- 48 --
Question ID: 6c2eedd7fa27b9f27318868be83200fa5632e18b_13
Original Code:
```
void donotification(char *msg, int length) {
  unsigned char ec = *(unsigned char *)(msg + 0);
  unsigned char esc = *(unsigned char *)(msg + 1);
  fprintf(stderr, "BGP Notification: error code = %d, error subcode = %d\n", ec, esc);
}
```


Overlapping Code:
```
d donotification(char *msg, int length) {
unsigned char ec = *(unsigned char *)(msg + 0);
unsigned char esc = *(unsigned char *)(msg + 1);
fprintf(stderr, "BGP Notification: error code = %d, error sub
```
<Overlap Ratio: 0.8771929824561403>

---

--- 49 --
Question ID: 5d1269d95ff9017dd7f2207131cab4f20e8d143c_0
Original Code:
```
static VALUE
pgconn_s_quote_connstr(VALUE string)
{
	char *str,*ptr;
	int i,j=0,len;
	VALUE result;

	Check_Type(string, T_STRING);

	ptr = RSTRING_PTR(string);
	len = RSTRING_LEN(string);
	str = ALLOC_N(char, len * 2 + 2 + 1);
	str[j++] = '\'';
	for(i = 0; i < len; i++) {
		if(ptr[i] == '\'' || ptr[i] == '\\')
			str[j++] = '\\';
		str[j++] = ptr[i];	
	}
	str[j++] = '\'';
	result = rb_str_new(str, j);
	xfree(str);
	return result;
}
```


Overlapping Code:
```
gconn_s_quote_connstr(VALUE string)
{
char *str,*ptr;
int i,j=0,len;
VALUE result;
Check_Type(string, T_STRING);
ptr = RSTRING_PTR(string);
len = RSTRING_LEN(string);
str = ALLOC_N(char, len * 2 + 2 + 1);
str[j++] = '\'';
for(i = 0; i < len; i++) {
if(ptr[i] == '\'' || ptr[i] == '\\')
str[j++] = '\\';
str[j++] = ptr[i]; 
}
str[j++] = '\'';
result =
```
<Overlap Ratio: 0.847457627118644>

---

--- 50 --
Question ID: 829d178d47fe7a86885e63a83f1a808837c417d3_3
Original Code:
```
static void on_read(uv_stream_t* handle,
                    ssize_t nread,
                    const uv_buf_t* buf) {
  int r;
  uv_pipe_t* pipe;
  uv_handle_type pending;
  uv_buf_t outbuf;

  pipe = (uv_pipe_t*) handle;

  if (nread == 0) {
    /* Everything OK, but nothing read. */
    free(buf->base);
    return;
  }

  if (nread < 0) {
    if (nread == UV_EOF) {
      free(buf->base);
      return;
    }

    printf("error recving on channel: %s\n", uv_strerror(nread));
    abort();
  }

  fprintf(stderr, "got %d bytes\n", (int)nread);

  pending = uv_pipe_pending_type(pipe);
  if (!tcp_server_listening) {
    ASSERT(1 == uv_pipe_pending_count(pipe));
    ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);
    read_cb_called++;

    /* Accept the pending TCP server, and start listening on it. */
    ASSERT(pending == UV_TCP);
    r = uv_tcp_init(uv_default_loop(), &tcp_server);
    ASSERT(r == 0);

    r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);
    ASSERT(r == 0);

    r = uv_listen((uv_stream_t*)&tcp_server, BACKLOG, on_connection);
    ASSERT(r == 0);

    tcp_server_listening = 1;

    /* Make sure that the expected data is correctly multiplexed. */
    ASSERT(memcmp("hello\n", buf->base, nread) == 0);

    outbuf = uv_buf_init("world\n", 6);
    r = uv_write(&write_req, (uv_stream_t*)pipe, &outbuf, 1, NULL);
    ASSERT(r == 0);

    /* Create a bunch of connections to get both servers to accept. */
    make_many_connections();
  } else if (memcmp("accepted_connection\n", buf->base, nread) == 0) {
    /* Remote server has accepted a connection.  Close the channel. */
    ASSERT(0 == uv_pipe_pending_count(pipe));
    ASSERT(pending == UV_UNKNOWN_HANDLE);
    remote_conn_accepted = 1;
    uv_close((uv_handle_t*)&channel, NULL);
  }

  free(buf->base);
}
```


Overlapping Code:
```
uv_stream_t* handle,
ssize_t nread,
const uv_buf_t* buf) {
int r;
uv_pipe_t* pipe;
uv_handle_type pending;
uv_buf_t outbuf;
pipe = (uv_pipe_t*) handle;
if (nread == 0) {
/* Everything OK, but nothing read. */
free(buf->base);
return;
}
if (nread < 0) {
if (nread == UV_EOF) {
free(buf->base);
return;
}
printf("error recving on channel: %s\n", uv_strerror(nread));
abort();
}
fprintf(stderr, "got %d bytes\n", (int)nread);
pending = uv_pipe_pending_type(pipe);
if (!tcp_server_listening) {
ASSERT(1 == uv_pipe_pending_count(pipe));
ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);
read_cb_called++;
/* Accept the pending TCP server, and start listening on it. */
ASSERT(pending == UV_TCP);
r = uv_tcp_init(uv_default_loop(), &tcp_server);
ASSERT(r == 0);
r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_server);
ASSERT(r == 0);
r = uv_listen((uv_stream_t*)&tcp_server, BACKLOG, on_connection);
ASSERT(r == 0);
tcp_server_listening = 1;
/* Make sure that the expected data is correctly multiplexed. */
ASSERT(memcmp("hello\n", buf->base, nread) == 0);
outbuf = uv_buf_init("world\n", 6);
r = uv_write(&write_req, (uv_stream_t*)pipe, &outbuf, 1, NULL);
ASSERT(r == 0);
/* Create a bunch of connections to get both servers to accept. */
make_many_connections();
} else if (memcmp("accepted_connection\n", buf->base, nread) == 0) {
/* Remote server has accepted a connection. Close the channel. */
ASSERT(0 == uv_pipe_pending_count(pipe));
ASSERT(pending == UV_UNKNOWN_HANDLE);
remote_conn_accepted = 1;
uv_close((uv_handle_t*)&channel, NULL)
```
<Overlap Ratio: 0.97375>

---

--- 51 --
Question ID: 486b6eb57add9900d0f9d1cdb21ea13ef0fda5e4_79
Original Code:
```
unsigned int v__cb_ctxp_dismissed(short parameter_2)
{
	unsigned int unsigned_int_1 = 1;
	unsigned int unsigned_int_2 = 1;
	int int_1 = 1;
	short short_1 = 1;
	short short_2 = 1;
	double double_1 = 1;
	double double_2 = 1;
	double double_3 = 1;
	unsigned_int_2 = unsigned_int_1 * unsigned_int_1;
	int_1 = int_1 + int_1;
	short_1 = short_1 + short_2;
	double_3 = double_1 + double_2;
	return unsigned_int_1;
}
```


Overlapping Code:
```
short parameter_2)
{
unsigned int unsigned_int_1 = 1;
unsigned int unsigned_int_2 = 1;
int int_1 = 1;
short short_1 = 1;
short short_2 = 1;
double double_1 = 1;
double double_2 = 1;
double double_3 = 1;
unsigned_int_2 = unsigned_int_1 * unsigned_int_1;
int_1 = int_1 + int_1;
short_1 = short_1 + short_2;
double_3 = double_1 + double_2;
return unsigned_i
```
<Overlap Ratio: 0.8962025316455696>

---

--- 52 --
Question ID: cc1859d7d2c560080a181593e8db8fbd5be89b94_1
Original Code:
```
void
db_set_ddb_regs(int type, mips_reg_t *tfp)
{
	struct frame *f = (struct frame *)&ddb_regs;
	
	/* Should switch to kdb`s own stack here. */

	if (type & T_USER)
		*f = *(struct frame *)curproc->p_md.md_regs;
	else {
		/* Synthetic full scale register context when trap happens */
		f->f_regs[AST] = tfp[0];
		f->f_regs[V0] = tfp[1];
		f->f_regs[V1] = tfp[2];
		f->f_regs[A0] = tfp[3];
		f->f_regs[A1] = tfp[4];
		f->f_regs[A2] = tfp[5];
		f->f_regs[A3] = tfp[6];
		f->f_regs[T0] = tfp[7];
		f->f_regs[T1] = tfp[8];
		f->f_regs[T2] = tfp[9];
		f->f_regs[T3] = tfp[10];
		f->f_regs[T4] = tfp[11];
		f->f_regs[T5] = tfp[12];
		f->f_regs[T6] = tfp[13];
		f->f_regs[T7] = tfp[14];
		f->f_regs[T8] = tfp[15];
		f->f_regs[T9] = tfp[16];
		f->f_regs[RA] = tfp[17];
		f->f_regs[SR] = tfp[18];
		f->f_regs[MULLO] = tfp[19];
		f->f_regs[MULHI] = tfp[20];
		f->f_regs[PC] = tfp[21];
		f->f_regs[S0] = kdbaux[0];
		f->f_regs[S1] = kdbaux[1];
		f->f_regs[S2] = kdbaux[2];
		f->f_regs[S3] = kdbaux[3];
		f->f_regs[S4] = kdbaux[4];
		f->f_regs[S5] = kdbaux[5];
		f->f_regs[S6] = kdbaux[6];
		f->f_regs[S7] = kdbaux[7];
		f->f_regs[SP] = kdbaux[8];
		f->f_regs[S8] = kdbaux[9];
		f->f_regs[GP] = kdbaux[10];
	}
}
```


Overlapping Code:
```
 type, mips_reg_t *tfp)
{
struct frame *f = (struct frame *)&ddb_regs;

/* Should switch to kdb`s own stack here. */
if (type & T_USER)
*f = *(struct frame *)curproc->p_md.md_regs;
else {
/* Synthetic full scale register context when trap happens */
f->f_regs[AST] = tfp[0];
f->f_regs[V0] = tfp[1];
f->f_regs[V1] = tfp[2];
f->f_regs[A0] = tfp[3];
f->f_regs[A1] = tfp[4];
f->f_regs[A2] = tfp[5];
f->f_regs[A3] = tfp[6];
f->f_regs[T0] = tfp[7];
f->f_regs[T1] = tfp[8];
f->f_regs[T2] = tfp[9];
f->f_regs[T3] = tfp[10];
f->f_regs[T4] = tfp[11];
f->f_regs[T5] = tfp[12];
f->f_regs[T6] = tfp[13];
f->f_regs[T7] = tfp[14];
f->f_regs[T8] = tfp[15];
f->f_regs[T9] = tfp[16];
f->f_regs[RA] = tfp[17];
f->f_regs[SR] = tfp[18];
f->f_regs[MULLO] = tfp[19];
f->f_regs[MULHI] = tfp[20];
f->f_regs[PC] = tfp[21];
f->f_regs[S0] = kdbaux[0];
f->f_regs[S1] = kdbaux[1];
f->f_regs[S2] = kdbaux[2];
f->f_regs[S3] = kdbaux[3];
f->f_regs[S4] = kdbaux[4];
f->f_regs[S5] = kdbaux[5];
f->f_regs[S6] = kdbaux[6];
f->f_regs[S7] = kdbaux[7];
f->f_regs[SP] = kdbaux[8];
f->f_regs[
```
<Overlap Ratio: 0.9358288770053476>

---

--- 53 --
Question ID: bf1574e84e13ae3c65c733690732db91eec21954_5
Original Code:
```
int v4l2_subdev_get_frame_interval(struct media_entity *entity,
				   struct v4l2_fract *interval)
{
	struct v4l2_subdev_frame_interval ival;
	int ret;

	ret = v4l2_subdev_open(entity);
	if (ret < 0)
		return ret;

	memset(&ival, 0, sizeof(ival));

	ret = ioctl(entity->fd, VIDIOC_SUBDEV_G_FRAME_INTERVAL, &ival);
	if (ret < 0)
		return -errno;

	*interval = ival.interval;
	return 0;
}
```


Overlapping Code:
```
nt v4l2_subdev_get_frame_interval(struct media_entity *entity,
struct v4l2_fract *interval)
{
struct v4l2_subdev_frame_interval ival;
int ret;
ret = v4l2_subdev_open(entity);
if (ret < 0)
return ret;
memset(&ival, 0, sizeof(ival));
ret = ioctl(entity->fd, VIDIOC_SUBDEV_G_FRAME_INTERVAL, &ival);
if (ret < 0)
return -errno;
*interval = ival.interval;
return 0;

```
<Overlap Ratio: 0.9944903581267218>

---

--- 54 --
Question ID: 79eddc387aa98a040dbabdb3879e516c5f6481d6_0
Original Code:
```
void sg_strsubpool__alloc(
        SG_context* pCtx,
        SG_uint32 space,
        sg_strsubpool* pNext,
        sg_strsubpool** ppNew
        )
{
	sg_strsubpool* pThis = NULL;

	SG_ERR_CHECK_RETURN(  SG_alloc1(pCtx, pThis)  );

	pThis->space = space;

	SG_ERR_CHECK(  SG_allocN(pCtx, space,pThis->pBytes)  );

	pThis->pNext = pNext;
	pThis->count = 0;

	*ppNew = pThis;
	return;

fail:
	SG_ERR_IGNORE(  sg_strsubpool__free(pCtx, pThis)  );
}
```


Overlapping Code:
```
subpool__alloc(
SG_context* pCtx,
SG_uint32 space,
sg_strsubpool* pNext,
sg_strsubpool** ppNew
)
{
sg_strsubpool* pThis = NULL;
SG_ERR_CHECK_RETURN( SG_alloc1(pCtx, pThis) );
pThis->space = space;
SG_ERR_CHECK( SG_allocN(pCtx, space,pThis->pBytes) );
pThis->pNext = pNext;
pThis->count = 0;
*ppNew = pThis;
return;
fail:
SG_ERR_IGNORE( sg_strsubpool__free(pCtx, pThi
```
<Overlap Ratio: 0.953125>

---

--- 55 --
Question ID: bd4f83e1ee07cf83d5ac4f119c406f06347e23cc_4
Original Code:
```
int 
unlock_file_win(void *pHandle) {
	BOOL bSuccess;

	if (pHandle != INVALID_HANDLE_VALUE) {
		bSuccess = UnlockFile(
			(HANDLE)pHandle,
			0,
			0,
			0,
			0);
		if (bSuccess) {
			return 0;
		}
	}
	return -1;
}
```


Overlapping Code:
```
 *pHandle) {
BOOL bSuccess;
if (pHandle != INVALID_HANDLE_VALUE) {
bSuccess = UnlockFile(
(HANDLE)pHandle,
0,
0,
0,
0);
if (bSuccess) {
return 0;
}
}

```
<Overlap Ratio: 0.8021390374331551>

---

--- 56 --
Question ID: 12bdd39a86b99486e4ef8704b5e252b56a533e92_188
Original Code:
```
static inline hri_gmac_rpq_reg_t hri_gmac_get_RPQ_reg(const void *const hw, hri_gmac_rpq_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Gmac *)hw)->RPQ.reg;
	tmp &= mask;
	return tmp;
}
```


Overlapping Code:
```
_gmac_rpq_reg_t hri_gmac_get_RPQ_reg(const void *const hw, hri_gmac_rpq_reg_t mask)
{
uint32_t tmp;
tmp = ((Gmac *)hw)->RPQ.reg;
tmp &= mask;
return t
```
<Overlap Ratio: 0.872093023255814>

---

--- 57 --
Question ID: 9a4ed7474e1e4b8fd22ff12127f6b367b87e1a94_38
Original Code:
```
static int acpi_video_switch_output(struct acpi_video_bus *video, int event)
{
	struct list_head *node, *next;
	struct acpi_video_device *dev = NULL;
	struct acpi_video_device *dev_next = NULL;
	struct acpi_video_device *dev_prev = NULL;
	unsigned long state;
	int status = 0;


	list_for_each_safe(node, next, &video->video_device_list) {
		dev = container_of(node, struct acpi_video_device, entry);
		status = acpi_video_device_get_state(dev, &state);
		if (state & 0x2) {
			dev_next =
			    container_of(node->next, struct acpi_video_device,
					 entry);
			dev_prev =
			    container_of(node->prev, struct acpi_video_device,
					 entry);
			goto out;
		}
	}
	dev_next = container_of(node->next, struct acpi_video_device, entry);
	dev_prev = container_of(node->prev, struct acpi_video_device, entry);
      out:
	switch (event) {
	case ACPI_VIDEO_NOTIFY_CYCLE:
	case ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:
		acpi_video_device_set_state(dev, 0);
		acpi_video_device_set_state(dev_next, 0x80000001);
		break;
	case ACPI_VIDEO_NOTIFY_PREV_OUTPUT:
		acpi_video_device_set_state(dev, 0);
		acpi_video_device_set_state(dev_prev, 0x80000001);
	default:
		break;
	}

	return status;
}
```


Overlapping Code:
```
acpi_video_switch_output(struct acpi_video_bus *video, int event)
{
struct list_head *node, *next;
struct acpi_video_device *dev = NULL;
struct acpi_video_device *dev_next = NULL;
struct acpi_video_device *dev_prev = NULL;
unsigned long state;
int status = 0;
list_for_each_safe(node, next, &video->video_device_list) {
dev = container_of(node, struct acpi_video_device, entry);
status = acpi_video_device_get_state(dev, &state);
if (state & 0x2) {
dev_next =
container_of(node->next, struct acpi_video_device,
entry);
dev_prev =
container_of(node->prev, struct acpi_video_device,
entry);
goto out;
}
}
dev_next = container_of(node->next, struct acpi_video_device, entry);
dev_prev = container_of(node->prev, struct acpi_video_device, entry);
out:
switch (event) {
case ACPI_VIDEO_NOTIFY_CYCLE:
case ACPI_VIDEO_NOTIFY_NEXT_OUTPUT:
acpi_video_device_set_state(dev, 0);
acpi_video_device_set_state(dev_next, 0x80000001);
break;
case ACPI_VIDEO_NOTIFY_PREV_OUTPUT:
acpi_video_device_set_state(dev, 0);
acpi_video_device_set_state(dev_prev, 0x80000001);
default:
break;
}
return 
```
<Overlap Ratio: 0.9817351598173516>

---

--- 58 --
Question ID: 1f0b48be66012af9fff9fdbaa12b403030758b02_54
Original Code:
```
JNICALL Java_org_lwjgl_util_yoga_Yoga_nYGNodeStyleGetOverflow(JNIEnv *__env, jclass clazz, jlong nodeAddress) {
    YGNodeRef const node = (YGNodeRef const)(intptr_t)nodeAddress;
    UNUSED_PARAMS(__env, clazz)
    return (jint)YGNodeStyleGetOverflow(node);
}
```


Overlapping Code:
```
JNICALL Java_org_lwjgl_util_yoga_Yoga_nYGNodeStyleGetOverflow(JNIEnv *__env, jclass clazz, jlong nodeAddress) {
YGNodeRef const node = (YGNodeRef const)(intptr_t)nodeAddress;
UNUSED_PARAMS(__env, clazz)
return (jint)YGNodeStyleGetOverflow(node
```
<Overlap Ratio: 0.9838056680161943>

---

--- 59 --
Question ID: ec4d362d17be863c53da0db077d07c814c90561d_0
Original Code:
```
static void ADIO_FileSysType_parentdir(char *filename, char **dirnamep)
{
    int err;
    char *dir, *slash;
    struct stat statbuf;
    
    err = lstat(filename, &statbuf);

    if (err || (!S_ISLNK(statbuf.st_mode))) {
	/* no such file, or file is not a link; these are the "normal"
	 * cases where we can just return the parent directory.
	 */
	dir = strdup(filename);
    }
    else {
	/* filename is a symlink.  we've presumably already tried
	 * to stat it and found it to be missing (dangling link),
	 * but this code doesn't care if the target is really there
	 * or not.
	 */
	char *linkbuf;

	linkbuf = ADIOI_Malloc(PATH_MAX+1);
	err = readlink(filename, linkbuf, PATH_MAX+1);
	if (err) {
	    /* something strange has happened between the time that
	     * we determined that this was a link and the time that
	     * we attempted to read it; punt and use the old name.
	     */
	    dir = strdup(filename);
	}
	else {
	    /* successfully read the link */
	    dir = strdup(linkbuf);
	    ADIOI_Free(linkbuf);
	}
    }

    slash = strrchr(dir, '/');
    if (!slash) strcpy(dir, ".");
    else {
	if (slash == dir) *(dir + 1) = 0;
	else *slash = '\0';
    }

    *dirnamep = dir;
    return;
}
```


Overlapping Code:
```
tic void ADIO_FileSysType_parentdir(char *filename, char **dirnamep)
{
int err;
char *dir, *slash;
struct stat statbuf;

err = lstat(filename, &statbuf);
if (err || (!S_ISLNK(statbuf.st_mode))) {
/* no such file, or file is not a link; these are the "normal"
* cases where we can just return the parent directory.
*/
dir = strdup(filename);
}
else {
/* filename is a symlink. we've presumably already tried
* to stat it and found it to be missing (dangling link),
* but this code doesn't care if the target is really there
* or not.
*/
char *linkbuf;
linkbuf = ADIOI_Malloc(PATH_MAX+1);
err = readlink(filename, linkbuf, PATH_MAX+1);
if (err) {
/* something strange has happened between the time that
* we determined that this was a link and the time that
* we attempted to read it; punt and use the old name.
*/
dir = strdup(filename);
}
else {
/* successfully read the link */
dir = strdup(linkbuf);
ADIOI_Free(linkbuf);
}
}
slash = strrchr(dir, '/');
if (!slash) strcpy(dir, ".");
else {
if (slash == dir) *(dir + 1) = 0;
else *slash =
```
<Overlap Ratio: 0.9646840148698885>

---

--- 60 --
Question ID: eb03a1b4f363c722f1ea275ac1d3a66d2f594156_1
Original Code:
```
RDB_MATRIX_T* rdbize_matrix
  (char*          corner_string,
   STRING_LIST_T* row_names,
   STRING_LIST_T* col_names,
   MATRIX_T*      matrix)
{
  RDB_MATRIX_T* new_matrix;
  assert(get_num_rows(matrix) == get_num_strings(row_names));
  assert(get_num_cols(matrix) == get_num_strings(col_names));

  new_matrix = allocate_rdb_matrix(get_num_rows(matrix),
				   get_num_cols(matrix),
				   matrix);

  set_corner_string(corner_string, new_matrix);
  set_row_names(row_names, new_matrix);
  set_col_names(col_names, new_matrix);
  
  return(new_matrix);
}
```


Overlapping Code:
```
tring,
STRING_LIST_T* row_names,
STRING_LIST_T* col_names,
MATRIX_T* matrix)
{
RDB_MATRIX_T* new_matrix;
assert(get_num_rows(matrix) == get_num_strings(row_names));
assert(get_num_cols(matrix) == get_num_strings(col_names));
new_matrix = allocate_rdb_matrix(get_num_rows(matrix),
get_num_cols(matrix),
matrix);
set_corner_string(corner_string, new_matrix);
set_row_names(row_names, new_matrix);
set_col_names(col_names, new_matrix);

return(new_matrix);
```
<Overlap Ratio: 0.9096385542168675>

---

--- 61 --
Question ID: 917abe9355957d55c98cdb924842b74ee749c534_43
Original Code:
```
SQLRETURN WINAPI SQLNumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnCount)
{
        TRACE("\n");

        CHECK_dmHandle();

        assert (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func);
        return (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func)
            (StatementHandle, ColumnCount);
}
```


Overlapping Code:
```
NumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnCount)
{
TRACE("\n");
CHECK_dmHandle();
assert (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func);
return (gProxyHandle.functions[SQLAPI_INDEX_SQLNUMRESULTCOLS].func)
(StatementHand
```
<Overlap Ratio: 0.8650519031141869>

---

--- 62 --
Question ID: 5ca10e75df169c4d015e2cbb646c6343cd75149d_859
Original Code:
```
static inline void hri_tcc_clear_PATT_PGE6_bit(const void *const hw)
{
	TCC_CRITICAL_SECTION_ENTER();
	hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_MASK);
	((Tcc *)hw)->PATT.reg &= ~TCC_PATT_PGE6;
	TCC_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
PATT_PGE6_bit(const void *const hw)
{
TCC_CRITICAL_SECTION_ENTER();
hri_tcc_wait_for_sync(hw, TCC_SYNCBUSY_MASK);
((Tcc *)hw)->PATT.reg &= ~TCC_PATT_PGE6;
TCC_C
```
<Overlap Ratio: 0.730593607305936>

---

--- 63 --
Question ID: 45d98a686e1c0709d41512880be3b1c7c539327e_53
Original Code:
```
void
on_checkbutton21_toggled               (GtkToggleButton *togglebutton,
                                        gpointer         user_data)
{
        GtkWidget *en1;
        en1 = lookup_widget(GTK_WIDGET(togglebutton), "entry29");
	if (GTK_TOGGLE_BUTTON(togglebutton)->active) {
                gtk_widget_set_sensitive(en1, FALSE);
		gtk_entry_set_text(GTK_ENTRY(en1), "");
        }
        else 
                gtk_widget_set_sensitive(en1, TRUE);
}
```


Overlapping Code:
```
_toggled (GtkToggleButton *togglebutton,
gpointer user_data)
{
GtkWidget *en1;
en1 = lookup_widget(GTK_WIDGET(togglebutton), "entry29");
if (GTK_TOGGLE_BUTTON(togglebutton)->active) {
gtk_widget_set_sensitive(en1, FALSE);
gtk_entry_set_text(GTK_ENTRY(en1), "");
}
else 
gtk_widget_set_sensitive(en1, TRUE)
```
<Overlap Ratio: 0.9270516717325228>

---

--- 64 --
Question ID: 3139287b0debfd0adaa6d446b5fe5e650396f138_1
Original Code:
```
int     
dec_kn20aa_intr_map(pa, ihp)
	struct pci_attach_args *pa;
        pci_intr_handle_t *ihp;
{
	pcitag_t bustag = pa->pa_intrtag;
	int buspin = pa->pa_intrpin;
	pci_chipset_tag_t pc = pa->pa_pc;
	int device;
	int kn20aa_irq;

	if (buspin == 0) {
		/* No IRQ used. */
		return 1;
	}
	if (buspin > 4) {
		printf("dec_kn20aa_intr_map: bad interrupt pin %d\n", buspin);
		return 1;
	}

	/*
	 * Slot->interrupt translation.  Appears to work, though it
	 * may not hold up forever.
	 *
	 * The DEC engineers who did this hardware obviously engaged
	 * in random drug testing.
	 */
	pci_decompose_tag(pc, bustag, NULL, &device, NULL);
	switch (device) {
	case 11:
	case 12:
		kn20aa_irq = ((device - 11) + 0) * 4;
		break;

	case 7:
		kn20aa_irq = 8;
		break;

	case 9:
		kn20aa_irq = 12;
		break;

	case 6:					/* 21040 on AlphaStation 500 */
		kn20aa_irq = 13;
		break;

	case 8:
		kn20aa_irq = 16;
		break;

	default:
                printf("dec_kn20aa_intr_map: weird device number %d\n",
		    device);
                return 1;
	}

	kn20aa_irq += buspin - 1;
	if (kn20aa_irq > KN20AA_MAX_IRQ)
		panic("dec_kn20aa_intr_map: kn20aa_irq too large (%d)\n",
		    kn20aa_irq);

	*ihp = kn20aa_irq;
	return (0);
}
```


Overlapping Code:
```
n20aa_intr_map(pa, ihp)
struct pci_attach_args *pa;
pci_intr_handle_t *ihp;
{
pcitag_t bustag = pa->pa_intrtag;
int buspin = pa->pa_intrpin;
pci_chipset_tag_t pc = pa->pa_pc;
int device;
int kn20aa_irq;
if (buspin == 0) {
/* No IRQ used. */
return 1;
}
if (buspin > 4) {
printf("dec_kn20aa_intr_map: bad interrupt pin %d\n", buspin);
return 1;
}
/*
* Slot->interrupt translation. Appears to work, though it
* may not hold up forever.
*
* The DEC engineers who did this hardware obviously engaged
* in random drug testing.
*/
pci_decompose_tag(pc, bustag, NULL, &device, NULL);
switch (device) {
case 11:
case 12:
kn20aa_irq = ((device - 11) + 0) * 4;
break;
case 7:
kn20aa_irq = 8;
break;
case 9:
kn20aa_irq = 12;
break;
case 6: /* 21040 on AlphaStation 500 */
kn20aa_irq = 13;
break;
case 8:
kn20aa_irq = 16;
break;
default:
printf("dec_kn20aa_intr_map: weird device number %d\n",
device);
return 1;
}
kn20aa_irq += buspin - 1;
if (kn20aa_irq > KN20AA_MAX_IRQ)
panic("dec_kn20aa_intr_map: kn20aa_irq too large (%d)\n",
kn20aa_irq);
*ihp = kn20aa_irq
```
<Overlap Ratio: 0.9767441860465116>

---

--- 65 --
Question ID: 36b9a1ca8cbf2286a24ed7c5760ec03d05fb0d05_3
Original Code:
```
Oid
ts_extension_schema_oid(void)
{
	Datum result;
	Relation rel;
	SysScanDesc scandesc;
	HeapTuple tuple;
	ScanKeyData entry[1];
	bool is_null = true;
	Oid schema = InvalidOid;

	rel = table_open(ExtensionRelationId, AccessShareLock);

	ScanKeyInit(&entry[0],
				Anum_pg_extension_extname,
				BTEqualStrategyNumber,
				F_NAMEEQ,
				DirectFunctionCall1(namein, CStringGetDatum(EXTENSION_NAME)));

	scandesc = systable_beginscan(rel, ExtensionNameIndexId, true, NULL, 1, entry);

	tuple = systable_getnext(scandesc);

	/* We assume that there can be at most one matching tuple */
	if (HeapTupleIsValid(tuple))
	{
		result =
			heap_getattr(tuple, Anum_pg_extension_extnamespace, RelationGetDescr(rel), &is_null);

		if (!is_null)
			schema = DatumGetObjectId(result);
	}

	systable_endscan(scandesc);
	table_close(rel, AccessShareLock);

	if (schema == InvalidOid)
		elog(ERROR, "extension schema not found");
	return schema;
}
```


Overlapping Code:
```
extension_schema_oid(void)
{
Datum result;
Relation rel;
SysScanDesc scandesc;
HeapTuple tuple;
ScanKeyData entry[1];
bool is_null = true;
Oid schema = InvalidOid;
rel = table_open(ExtensionRelationId, AccessShareLock);
ScanKeyInit(&entry[0],
Anum_pg_extension_extname,
BTEqualStrategyNumber,
F_NAMEEQ,
DirectFunctionCall1(namein, CStringGetDatum(EXTENSION_NAME)));
scandesc = systable_beginscan(rel, ExtensionNameIndexId, true, NULL, 1, entry);
tuple = systable_getnext(scandesc);
/* We assume that there can be at most one matching tuple */
if (HeapTupleIsValid(tuple))
{
result =
heap_getattr(tuple, Anum_pg_extension_extnamespace, RelationGetDescr(rel), &is_null);
if (!is_null)
schema = DatumGetObjectId(result);
}
systable_endscan(scandesc);
table_close(rel, AccessShareLock);
if (schema == InvalidOid)
elog(ERROR, "extension sc
```
<Overlap Ratio: 0.9531428571428572>

---

--- 66 --
Question ID: 90b1e5be289ed2d61d0ad5813fc1342e6e89c1c7_0
Original Code:
```
void rendering_resource_init_empty(rendering_resource* res) {
    res->device = VK_NULL_HANDLE;
    res->command_pool = VK_NULL_HANDLE;
    res->command_buffer = VK_NULL_HANDLE;
    res->finished_render_semaphore = VK_NULL_HANDLE;
    res->image_available_semaphore = VK_NULL_HANDLE;
    res->fence = VK_NULL_HANDLE;

    vk_framebuffer_init_empty(&res->framebuffer);
}
```


Overlapping Code:
```
esource_init_empty(rendering_resource* res) {
res->device = VK_NULL_HANDLE;
res->command_pool = VK_NULL_HANDLE;
res->command_buffer = VK_NULL_HANDLE;
res->finished_render_semaphore = VK_NULL_HANDLE;
res->image_available_semaphore = VK_NULL_HANDLE;
res->fence = VK_NULL_HANDLE;
vk_framebuffer_init_emp
```
<Overlap Ratio: 0.8823529411764706>

---

--- 67 --
Question ID: f8de45ca4fd5e1609733bdb3cb7522c564fdf6b0_0
Original Code:
```
void *myprocess(void *arg) {
    printf("threadid is 0x%x, working on task %d\n", pthread_self(),
           *(int *)arg);
    /*休息一秒，延长任务的执行时间*/
    sleep(1);
    return NULL;
}
```


Overlapping Code:
```
d *arg) {
printf("threadid is 0x%x, working on task %d\n", pthread_self(),
*(int *)arg);
/*休息一秒，延长任务
```
<Overlap Ratio: 0.6622516556291391>

---

--- 68 --
Question ID: a9e3f9e83ada8037345117c59ce712257ef64c7b_4
Original Code:
```
int BTCLUI_TextArea_HandleInput2(int ox, int oy,
	BTCLUI_InputState *state, BTCLUI_Form *form, BTCLUI_Widget *obj)
{
	int cx, cy;
	int i, j, k;
	unsigned short *ks;
	char *s, *s2, *b, *t;
	void *p;
	int ch;

//	if(BTCLUI_KeyDown(K_SHIFT))printf("shift a1\n");

	ch=0;
	ks=state->keys;
	while(*ks)
	{
		if((*ks=='x') && BTCLUI_KeyDown(state, K_CTRL))
		{
			ch=1;
			b=BTCLUI_TextArea_FlattenSelection(obj);
			BTCLUI_TextArea_DeleteSelection(obj);
//			BTCLUI_ClipBoard_Export(b);
		}
		if((*ks=='c') && BTCLUI_KeyDown(state, K_CTRL))
		{
			b=BTCLUI_TextArea_FlattenSelection(obj);
//			BTCLUI_ClipBoard_Export(b);
		}
		if(((*ks=='v') && BTCLUI_KeyDown(state, K_CTRL)) ||
			((*ks==K_INS) && BTCLUI_KeyDown(state, K_SHIFT)))
		{
			ch=1;
//			b=BTCLUI_ClipBoard_Import("string_t");
			if(b)BTCLUI_TextArea_Insert(obj, &obj->cxpos,
				&obj->cypos, b);
			if(obj->cxpos<0)obj->cxpos=0;
			if(obj->cypos<0)obj->cypos=0;
		}

		if(BTCLUI_KeyDown(state, K_CTRL) || BTCLUI_KeyDown(state, K_ALT))
		{
			if(obj->cxpos<obj->wxpos)
				obj->wxpos=obj->cxpos;
			while(obj->cxpos>=(obj->wxpos+obj->cols))
				obj->wxpos++;
			if(obj->cypos<obj->wypos)
				obj->wypos=obj->cypos;
			while(obj->cypos>=(obj->wypos+obj->rows))
				obj->wypos++;

			ks++;
			continue;
		}


		if((*ks<127) && (*ks>=' '))
		{
			ch=1;
			if(obj->sxpos>=0)
				BTCLUI_TextArea_DeleteSelection(obj);
			s=obj->bufptrs[obj->cypos];
			if(!s)
			{
				s=gcalloc(512);
				obj->bufptrs[obj->cypos]=s;
			}
			if(obj->cxpos>strlen(s))
				obj->cxpos=strlen(s);
			s+=obj->cxpos;
			b=gcralloc(512);
			strcpy(b, s);
			*s++=*ks;
			strcpy(s, b);

			obj->cxpos++;
		}
		if((*ks=='\b') && (obj->sxpos<0))
		{
			ch=1;
			s=obj->bufptrs[obj->cypos];
			if(!s)
			{
				s=gcalloc(512);
				obj->bufptrs[obj->cypos]=s;
			}
			if(obj->cxpos>strlen(s))
				obj->cxpos=strlen(s);
			if(obj->cxpos>0)
			{
				s+=obj->cxpos;
				b=gcralloc(512);
				strcpy(b, s);
				s--;
				strcpy(s, b);
				obj->cxpos--;
			}else if(obj->cypos>0)
			{
				s2=obj->bufptrs[obj->cypos-1];
				if(!s2)
				{
					s2=gcalloc(512);
					obj->bufptrs[obj->cypos-1]=s2;
				}

				obj->cxpos=strlen(s2);
				obj->cypos--;
				strcat(s2, s);

				for(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)
					obj->bufptrs[i]=obj->bufptrs[i+1];
			}
		}
		if((*ks==K_DEL) && (obj->sxpos<0))
		{
			ch=1;
			s=obj->bufptrs[obj->cypos];
			if(!s)
			{
				s=gcalloc(512);
				obj->bufptrs[obj->cypos]=s;
			}
			if(obj->cxpos>strlen(s))
				obj->cxpos=strlen(s);
			if(obj->cxpos<strlen(s))
			{
				s+=obj->cxpos;
				b=gcralloc(512);
				strcpy(b, s+1);
				strcpy(s, b);
			}else
			{
				s2=obj->bufptrs[obj->cypos+1];
				if(!s2)
				{
					s2=gcalloc(512);
					obj->bufptrs[obj->cypos+1]=s2;
				}

				strcat(s, s2);

				for(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)
					obj->bufptrs[i]=obj->bufptrs[i+1];
			}
		}
		if(((*ks=='\b') || (*ks==K_DEL)) && (obj->sxpos>=0))
		{
			ch=1;
			BTCLUI_TextArea_DeleteSelection(obj);
		}
		if(*ks=='\r')
		{
			ch=1;
			if(obj->sxpos>=0)
				BTCLUI_TextArea_DeleteSelection(obj);
			s=obj->bufptrs[obj->cypos];
			if(!s)
			{
				s=gcalloc(512);
				obj->bufptrs[obj->cypos]=s;
			}
			if(obj->cxpos>strlen(s))
				obj->cxpos=strlen(s);
			s+=obj->cxpos;
			b=gcralloc(512);
			strcpy(b, s);
			*s=0;

			for(i=(obj->nbufptrs-1); i>(obj->cypos+1); i--)
				obj->bufptrs[i]=obj->bufptrs[i-1];

			s2=gcalloc(512);
			obj->bufptrs[obj->cypos+1]=s2;
			strcpy(s2, b);

			obj->cxpos=0;
			obj->cypos++;
		}
		if(*ks=='\t')
		{
			ch=1;
			if(obj->sxpos>=0)
				BTCLUI_TextArea_DeleteSelection(obj);
			s=obj->bufptrs[obj->cypos];
			if(!s)
			{
				s=gcalloc(512);
				obj->bufptrs[obj->cypos]=s;
			}
			if(obj->cxpos>strlen(s))
				obj->cxpos=strlen(s);
			s+=obj->cxpos;
			b=gcralloc(512);
			strcpy(b, s);
			*s++='\t';
			strcpy(s, b);

			obj->cxpos++;
		}
		if(*ks==K_HOME)
		{
//			BTCLUI_TextArea_HandleSelect(obj);
			obj->cxpos=0;
			obj->wxpos=0;
		}
		if(*ks==K_END)
		{
//			BTCLUI_TextArea_HandleSelect(obj);
			s=obj->bufptrs[obj->cypos];
			obj->cxpos=0;
			if(s)obj->cxpos=strlen(s);
		}
		if(*ks==K_UPARROW)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			obj->cypos--;
			if(obj->cypos<0)obj->cypos=0;

			s=obj->bufptrs[obj->cypos];
			if(s)
			{
				if(obj->cxpos>strlen(s))
					obj->cxpos=strlen(s);
			}else obj->cxpos=0;
		}
		if(*ks==K_DOWNARROW)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			obj->cypos++;

			s=obj->bufptrs[obj->cypos];
			if(s)
			{
				if(obj->cxpos>strlen(s))
					obj->cxpos=strlen(s);
			}else obj->cxpos=0;
		}
		if(*ks==K_LEFTARROW)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			obj->cxpos--;
			if(obj->cxpos<0)
			{
				obj->cypos--;
				obj->cxpos=0;
				if(obj->cypos>=0)
				{
					s=obj->bufptrs[obj->cypos];
					if(s)obj->cxpos=strlen(s);
				}else
				{
					obj->cypos=0;
					obj->cxpos=0;
				}
			}
		}
		if(*ks==K_RIGHTARROW)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			s=obj->bufptrs[obj->cypos];
			obj->cxpos++;
			if(s)
			{
				if(obj->cxpos>strlen(s))
				{
					obj->cypos++;
					obj->cxpos=0;
				}
			}else
			{
				obj->cypos++;
				obj->cxpos=0;
			}
		}
		if(*ks==K_PGUP)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			obj->cypos-=obj->rows;
			if(obj->cypos<0)obj->cypos=0;
		}
		if(*ks==K_PGDN)
		{
			BTCLUI_TextArea_HandleSelect(obj, state);
			obj->cypos+=obj->rows;
		}

		if(obj->cxpos<obj->wxpos)
			obj->wxpos=obj->cxpos;
		while(obj->cxpos>=(obj->wxpos+obj->cols))
			obj->wxpos++;
		if(obj->cypos<obj->wypos)
			obj->wypos=obj->cypos;
		while(obj->cypos>=(obj->wypos+obj->rows))
			obj->wypos++;

		ks++;
	}

//	p=NULL;
//	if(ch)BTCLUI_Forms_Message(obj->form, obj->id, "changed", 0, &p);

	if(ch)BTCLUI_Widget_AddEvent(obj, "changed");
	return(0);
}
```


Overlapping Code:
```
_TextArea_HandleInput2(int ox, int oy,
BTCLUI_InputState *state, BTCLUI_Form *form, BTCLUI_Widget *obj)
{
int cx, cy;
int i, j, k;
unsigned short *ks;
char *s, *s2, *b, *t;
void *p;
int ch;
// if(BTCLUI_KeyDown(K_SHIFT))printf("shift a1\n");
ch=0;
ks=state->keys;
while(*ks)
{
if((*ks=='x') && BTCLUI_KeyDown(state, K_CTRL))
{
ch=1;
b=BTCLUI_TextArea_FlattenSelection(obj);
BTCLUI_TextArea_DeleteSelection(obj);
// BTCLUI_ClipBoard_Export(b);
}
if((*ks=='c') && BTCLUI_KeyDown(state, K_CTRL))
{
b=BTCLUI_TextArea_FlattenSelection(obj);
// BTCLUI_ClipBoard_Export(b);
}
if(((*ks=='v') && BTCLUI_KeyDown(state, K_CTRL)) ||
((*ks==K_INS) && BTCLUI_KeyDown(state, K_SHIFT)))
{
ch=1;
// b=BTCLUI_ClipBoard_Import("string_t");
if(b)BTCLUI_TextArea_Insert(obj, &obj->cxpos,
&obj->cypos, b);
if(obj->cxpos<0)obj->cxpos=0;
if(obj->cypos<0)obj->cypos=0;
}
if(BTCLUI_KeyDown(state, K_CTRL) || BTCLUI_KeyDown(state, K_ALT))
{
if(obj->cxpos<obj->wxpos)
obj->wxpos=obj->cxpos;
while(obj->cxpos>=(obj->wxpos+obj->cols))
obj->wxpos++;
if(obj->cypos<obj->wypos)
obj->wypos=obj->cypos;
while(obj->cypos>=(obj->wypos+obj->rows))
obj->wypos++;
ks++;
continue;
}
if((*ks<127) && (*ks>=' '))
{
ch=1;
if(obj->sxpos>=0)
BTCLUI_TextArea_DeleteSelection(obj);
s=obj->bufptrs[obj->cypos];
if(!s)
{
s=gcalloc(512);
obj->bufptrs[obj->cypos]=s;
}
if(obj->cxpos>strlen(s))
obj->cxpos=strlen(s);
s+=obj->cxpos;
b=gcralloc(512);
strcpy(b, s);
*s++=*ks;
strcpy(s, b);
obj->cxpos++;
}
if((*ks=='\b') && (obj->sxpos<0))
{
ch=1;
s=obj->bufptrs[obj->cypos];
if(!s)
{
s=gcalloc(512);
obj->bufptrs[obj->cypos]=s;
}
if(obj->cxpos>strlen(s))
obj->cxpos=strlen(s);
if(obj->cxpos>0)
{
s+=obj->cxpos;
b=gcralloc(512);
strcpy(b, s);
s--;
strcpy(s, b);
obj->cxpos--;
}else if(obj->cypos>0)
{
s2=obj->bufptrs[obj->cypos-1];
if(!s2)
{
s2=gcalloc(512);
obj->bufptrs[obj->cypos-1]=s2;
}
obj->cxpos=strlen(s2);
obj->cypos--;
strcat(s2, s);
for(i=obj->cypos+1; i<(obj->nbufptrs-1); i++)
obj->bufptrs[i]=obj->bufptrs[i+1];
}
}
if((*ks==K_DEL) && (obj->sxpos<0))
{
ch=1;
s=obj->bufptrs[obj->cypos];
if(!s)
{
s=gcalloc(512);
obj->bufptrs[obj->cypos]=s;
}
if(obj->cxpos>strlen(s))
obj->cxpos=strlen(s);
if(o
```
<Overlap Ratio: 0.9935304990757856>

---

--- 69 --
Question ID: 5280cb67ecaf2ca53cadb8ccf97b88dabb2001d1_2
Original Code:
```
static enum cb_err fetch_mac_string_vpd(u8 *macstrbuf, const u8 device_index)
{
	struct region_device rdev;
	void *search_address;
	size_t search_length;
	size_t offset;
	char key[] = "ethernet_mac "; /* Leave a space at tail to stuff an index */

	/*
	 * The device_index 0 is treated as an special case matching to
	 * "ethernet_mac" with single NIC on DUT. When there are mulitple
	 * NICs on DUT, they are mapping to "ethernet_macN", where
	 * N is [0-9].
	 */
	if (device_index == 0)
		key[DEVICE_INDEX_BYTE] = '\0';
	else
		/* Translate index number from integer to ascii */
		key[DEVICE_INDEX_BYTE] = (device_index - 1) + '0';

	if (fmap_locate_area_as_rdev("RO_VPD", &rdev)) {
		printk(BIOS_ERR, "Error: Couldn't find RO_VPD region.");
		return CB_ERR;
	}
	search_address = rdev_mmap_full(&rdev);
	if (search_address == NULL) {
		printk(BIOS_ERR, "LAN: VPD not found.\n");
		return CB_ERR;
	}

	search_length = region_device_sz(&rdev);
	offset = search(key, search_address, strlen(key),
			search_length);

	if (offset == search_length) {
		printk(BIOS_ERR,
		       "Error: Could not locate '%s' in VPD\n", key);
		return CB_ERR;
	}
	printk(BIOS_DEBUG, "Located '%s' in VPD\n", key);

	offset += strlen(key) + 1;	/* move to next character */

	if (offset + MACLEN > search_length) {
		printk(BIOS_ERR, "Search result too small!\n");
		return CB_ERR;
	}
	memcpy(macstrbuf, search_address + offset, MACLEN);
	return CB_SUCCESS;
}
```


Overlapping Code:
```
_vpd(u8 *macstrbuf, const u8 device_index)
{
struct region_device rdev;
void *search_address;
size_t search_length;
size_t offset;
char key[] = "ethernet_mac "; /* Leave a space at tail to stuff an index */
/*
* The device_index 0 is treated as an special case matching to
* "ethernet_mac" with single NIC on DUT. When there are mulitple
* NICs on DUT, they are mapping to "ethernet_macN", where
* N is [0-9].
*/
if (device_index == 0)
key[DEVICE_INDEX_BYTE] = '\0';
else
/* Translate index number from integer to ascii */
key[DEVICE_INDEX_BYTE] = (device_index - 1) + '0';
if (fmap_locate_area_as_rdev("RO_VPD", &rdev)) {
printk(BIOS_ERR, "Error: Couldn't find RO_VPD region.");
return CB_ERR;
}
search_address = rdev_mmap_full(&rdev);
if (search_address == NULL) {
printk(BIOS_ERR, "LAN: VPD not found.\n");
return CB_ERR;
}
search_length = region_device_sz(&rdev);
offset = search(key, search_address, strlen(key),
search_length);
if (offset == search_length) {
printk(BIOS_ERR,
"Error: Could not locate '%s' in VPD\n", key);
return CB_ERR;
}
printk(BIOS_DEBUG, "Located '%s' in VPD\n", key);
offset += strlen(key) + 1; /* move to next character */
if (offset + MACLEN > search_length) {
printk(BIOS_ERR, "Search result too small!\n");
return CB_ERR;
}
memcpy(macstrbuf, search_address + offset, M
```
<Overlap Ratio: 0.9537784299339692>

---

--- 70 --
Question ID: 230d374b70ea8695a0bf9f05e3b53f4bca0396ac_2
Original Code:
```
static ALWAYS_INLINE uint64_t arm_arch_timer_count(void)
{
	uint64_t cntvct_el0;

	__asm__ volatile("mrs %0, cntvct_el0\n\t"
			 : "=r" (cntvct_el0) : : "memory");

	return cntvct_el0;
}
```


Overlapping Code:
```
ic ALWAYS_INLINE uint64_t arm_arch_timer_count(void)
{
uint64_t cntvct_el0;
__asm__ volatile("mrs %0, cntvct_el0\n\t"
: "=r" (cntvct_el0) : : "memory");
return cntv
```
<Overlap Ratio: 0.9265536723163842>

---

--- 71 --
Question ID: 831d986fea48baebe3d854f1df7410eed319eb28_12
Original Code:
```
static const SObject *GetFeature(const SSyllabification *self, const char *key,
								 s_erc *error)
{
	const SObject *feature;


	S_CLR_ERR(error);
	if (key == NULL)
	{
		S_CTX_ERR(error, S_ARGERROR,
				  "GetFeature",
				  "Argument \"key\" is NULL");
		return NULL;
	}

	if (self->features == NULL)
		return NULL;

	feature = SMapGetObjectDef(self->features, key, NULL, error);
	if (S_CHK_ERR(error, S_CONTERR,
				  "GetFeature",
				  "Call to \"SMapGetObjectDef\" failed"))
		return NULL;

	return feature;
}
```


Overlapping Code:
```
nst SObject *GetFeature(const SSyllabification *self, const char *key,
s_erc *error)
{
const SObject *feature;
S_CLR_ERR(error);
if (key == NULL)
{
S_CTX_ERR(error, S_ARGERROR,
"GetFeature",
"Argument \"key\" is NULL");
return NULL;
}
if (self->features == NULL)
return NULL;
feature = SMapGetObjectDef(self->features, key, NULL, error);
if (S_CHK_ERR(error, S_CONTERR,
"GetFeature",
"Call to \"SMapGetObjectDef\" failed"))
return NULL;
return feature;
}
```
<Overlap Ratio: 0.980561555075594>

---

--- 72 --
Question ID: 270b425dd08678164b32823f7eda1813bedd212a_11
Original Code:
```
int
OF_milliseconds(void)
{
	struct {
		cell_t name;
		cell_t nargs;
		cell_t nreturns;
		cell_t ms;
	} args;

	args.name = ADR2CELL("milliseconds");
	args.nargs = 0;
	args.nreturns = 1;
	openfirmware(&args);
	return args.ms;
}
```


Overlapping Code:
```
oid)
{
struct {
cell_t name;
cell_t nargs;
cell_t nreturns;
cell_t ms;
} args;
args.name = ADR2CELL("milliseconds");
args.nargs = 0;
args.nreturns = 1;
openfirmware(&args);
return a
```
<Overlap Ratio: 0.8578199052132701>

---

--- 73 --
Question ID: 45f71467c52c44cc66ec47b84bc6c32ffcb7d2ba_333
Original Code:
```
double v_rasqal_sparql_xml_start( float parameter_1)
{
	int int_1 = 1;
	int int_2 = 1;
	char char_1 = 1;
	char char_2 = 1;
	long long_1 = 1;
	double double_1 = 1;
	int_2 = int_1 * int_1;
	char_2 = char_1 + char_1;
	long_1 = long_1 * long_1;
	int_2 = int_2 * int_2;
	return double_1;
}
```


Overlapping Code:
```
( float parameter_1)
{
int int_1 = 1;
int int_2 = 1;
char char_1 = 1;
char char_2 = 1;
long long_1 = 1;
double double_1 = 1;
int_2 = int_1 * int_1;
char_2 = char_1 + char_1;
long_1 = long_1 * long_1;
int_
```
<Overlap Ratio: 0.7472527472527473>

---

--- 74 --
Question ID: 370e1a8df4f2f5155b9143133a753afa4c322b08_10
Original Code:
```
void avc_style_luma_interpolation_filter_posq_c(EbByte ref_pic, uint32_t src_stride, EbByte dst,
                                                uint32_t dst_stride, uint32_t pu_width,
                                                uint32_t pu_height, EbByte temp_buf,
                                                uint32_t frac_pos) {
    uint32_t temp_buf_size = pu_width * pu_height;
    (void)frac_pos;
    avc_style_luma_interpolation_filter_horizontal_c(
        ref_pic + src_stride, src_stride, temp_buf, pu_width, pu_width, pu_height, 0, 2);
    avc_style_luma_interpolation_filter_posj_c(ref_pic,
                                               src_stride,
                                               temp_buf + temp_buf_size,
                                               pu_width,
                                               pu_width,
                                               pu_height,
                                               temp_buf + 2 * temp_buf_size,
                                               2);
    picture_average_kernel_c(temp_buf,
                             pu_width,
                             temp_buf + temp_buf_size,
                             pu_width,
                             dst,
                             dst_stride,
                             pu_width,
                             pu_height);
}
```


Overlapping Code:
```
oid avc_style_luma_interpolation_filter_posq_c(EbByte ref_pic, uint32_t src_stride, EbByte dst,
uint32_t dst_stride, uint32_t pu_width,
uint32_t pu_height, EbByte temp_buf,
uint32_t frac_pos) {
uint32_t temp_buf_size = pu_width * pu_height;
(void)frac_pos;
avc_style_luma_interpolation_filter_horizontal_c(
ref_pic + src_stride, src_stride, temp_buf, pu_width, pu_width, pu_height, 0, 2);
avc_style_luma_interpolation_filter_posj_c(ref_pic,
src_stride,
temp_buf + temp_buf_size,
pu_width,
pu_width,
pu_height,
temp_buf + 2 * temp_buf_size,
2);
picture_average_kernel_c(temp_buf,
pu_width,
temp_buf + temp_buf_size,
pu_width,
dst,
dst_stride,
pu_width,
pu_heigh
```
<Overlap Ratio: 0.990990990990991>

---

--- 75 --
Question ID: f37abd94c43d3b49a5b9fd9fcae65bb1df404f44_0
Original Code:
```
int main()
{
    FILE *fp;
    int i,n;
    char c;
    fp=fopen("file_C(i).dat","ab");
    if (fp==NULL)
    {
        perror("Can't open file.");
        exit(EXIT_FAILURE);
    }
    do
    {
        do
        {
            printf("Enter the EMPLOYEE CODE of the employee [6 DIGITS]: ");
            scanf("%d",&data.empcode);
            n=data.empcode;
            for (i=0;n!=0;i++)
                n/=10;
        }while(i!=6);
        printf("Enter the NAME of the employee [MAX 19 CHARACTERS]: ");
        fflush(stdin);
        gets(data.empname);
        printf("Enter the JOIN DATE of the employee [DD/MM/YYYY] [SEPARATED BY A TAB]: ");
        scanf("%d%d%d",&data.join_date.d,&data.join_date.m,&data.join_date.y);
        printf("Enter the SALARY of the employee: ");
        scanf("%f",&data.salary);
        fwrite(&data,sizeof(struct employee),1,fp);
        printf("\nEnter another data [Y/N]: ");
        fflush(stdin);
        c=getchar();
        printf("\n");
    }while (c=='y' || c=='Y');
    fclose(fp);
    return 0;
}
```


Overlapping Code:
```
nt main()
{
FILE *fp;
int i,n;
char c;
fp=fopen("file_C(i).dat","ab");
if (fp==NULL)
{
perror("Can't open file.");
exit(EXIT_FAILURE);
}
do
{
do
{
printf("Enter the EMPLOYEE CODE of the employee [6 DIGITS]: ");
scanf("%d",&data.empcode);
n=data.empcode;
for (i=0;n!=0;i++)
n/=10;
}while(i!=6);
printf("Enter the NAME of the employee [MAX 19 CHARACTERS]: ");
fflush(stdin);
gets(data.empname);
printf("Enter the JOIN DATE of the employee [DD/MM/YYYY] [SEPARATED BY A TAB]: ");
scanf("%d%d%d",&data.join_date.d,&data.join_date.m,&data.join_date.y);
printf("Enter the SALARY of the employee: ");
scanf("%f",&data.salary);
fwrite(&data,sizeof(struct employee),1,fp);
printf("\nEnter another data [Y/N]: ");
fflush(stdin);
c=getchar();
printf("\n");
}while (c=='y' || c=='Y');
```
<Overlap Ratio: 0.9685929648241206>

---

--- 76 --
Question ID: 9dc9330bcf19f23e13c7d9db0e4b416fc2aa28e1_3
Original Code:
```
static void
ng_rewind(struct irs_ng *this, const char *netgroup) {
	UNUSED(this);
	UNUSED(netgroup);
	/* NOOP */
}
```


Overlapping Code:
```
is, const char *netgroup) {
UNUSED(this);
UNUSED(n
```
<Overlap Ratio: 0.45045045045045046>

---

--- 77 --
Question ID: a2aaca986c469fa11034717b3b094e8a6d7fc97a_1
Original Code:
```
namespace content {

// Update |event|'s windowsKeyCode and keyIdentifer properties using the
// provided |windows_key_code|.
CONTENT_EXPORT void UpdateWindowsKeyCodeAndKeyIdentifier(
    blink::WebKeyboardEvent* event,
    ui::KeyboardCode windows_key_code);

CONTENT_EXPORT blink::WebTouchEvent CreateWebTouchEventFromMotionEvent(
    const ui::MotionEvent& event, bool may_cause_scrolling);

CONTENT_EXPORT blink::WebGestureEvent CreateWebGestureEvent(
    const ui::GestureEventDetails& details,
    base::TimeDelta timestamp,
    const gfx::PointF& location,
    const gfx::PointF& raw_location,
    int flags);

// Convenience wrapper for |CreateWebGestureEvent| using the supplied |data|.
CONTENT_EXPORT blink::WebGestureEvent
CreateWebGestureEventFromGestureEventData(const ui::GestureEventData& data);

int EventFlagsToWebEventModifiers(int flags);

int WebEventModifiersToEventFlags(int modifiers);

}
```


Overlapping Code:
```
nt {
// Update |event|'s windowsKeyCode and keyIdentifer properties using the
// provided |windows_key_code|.
CONTENT_EXPORT void UpdateWindowsKeyCodeAndKeyIdentifier(
blink::WebKeyboardEvent* event,
ui::KeyboardCode windows_key_code);
CONTENT_EXPORT blink::WebTouchEvent CreateWebTouchEventFromMotionEvent(
const ui::MotionEvent& event, bool may_cause_scrolling);
CONTENT_EXPORT blink::WebGestureEvent CreateWebGestureEvent(
const ui::GestureEventDetails& details,
base::TimeDelta timestamp,
const gfx::PointF& location,
const gfx::PointF& raw_location,
int flags);
// Convenience wrapper for |CreateWebGestureEvent| using the supplied |data|.
CONTENT_EXPORT blink::WebGestureEvent
CreateWebGestureEventFromGestureEventData(const ui::GestureEventData& data);
int EventFlagsToWebEventModifiers(int flags);
int WebEventModifiersToEventFlags(int modifie
```
<Overlap Ratio: 0.9759174311926605>

---

--- 78 --
Question ID: 648b39386988bc8b5400045912c1345e5f91f359_23
Original Code:
```
int
gem_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct gem_softc *sc = ifp->if_softc;
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splimp();

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			gem_init(ifp);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)LLADDR(ifp->if_sadl);
			else {
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, sizeof(sc->sc_enaddr));
			}	
			/* Set new address. */
			gem_init(ifp);
			break;
		    }
#endif
		default:
			gem_init(ifp);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			gem_stop(ifp, 1);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			gem_init(ifp);
		} else if ((ifp->if_flags & IFF_UP) != 0) {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			/*gem_stop(sc);*/
			gem_init(ifp);
		}
#ifdef HMEDEBUG
		sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			gem_init(ifp);
			error = 0;
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
		break;

	default:
		error = EINVAL;
		break;
	}

	splx(s);
	return (error);
}
```


Overlapping Code:
```

gem_ioctl(ifp, cmd, data)
struct ifnet *ifp;
u_long cmd;
caddr_t data;
{
struct gem_softc *sc = ifp->if_softc;
struct ifaddr *ifa = (struct ifaddr *)data;
struct ifreq *ifr = (struct ifreq *)data;
int s, error = 0;
s = splimp();
if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
splx(s);
return (error);
}
switch (cmd) {
case SIOCSIFADDR:
ifp->if_flags |= IFF_UP;
switch (ifa->ifa_addr->sa_family) {
#ifdef INET
case AF_INET:
gem_init(ifp);
arp_ifinit(&sc->sc_arpcom, ifa);
break;
#endif
#ifdef NS
case AF_NS:
{
struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;
if (ns_nullhost(*ina))
ina->x_host =
*(union ns_host *)LLADDR(ifp->if_sadl);
else {
memcpy(LLADDR(ifp->if_sadl),
ina->x_host.c_host, sizeof(sc->sc_enaddr));
} 
/* Set new address. */
gem_init(ifp);
break;
}
#endif
default:
gem_init(ifp);
break;
}
break;
case SIOCSIFFLAGS:
if ((ifp->if_flags & IFF_UP) == 0 &&
(ifp->if_flags & IFF_RUNNING) != 0) {
/*
* If interface is marked down and it is running, then
* stop it.
*/
gem_stop(ifp, 1);
ifp->if_flags &= ~IFF_RUNNING;
} else if ((ifp->if_flags & IFF_UP) != 0 &&
(ifp->if_flags & IFF_RUNNING) == 0) {
/*
* If interface is marked up and it is stopped, then
* start it.
*/
gem_init(ifp);
} else if ((ifp->if_flags & IFF_UP) != 0) {
/*
* Reset the interface to pick up changes in any other
* flags that affect hardware registers.
*/
/*gem_stop(sc);*/
gem_init(ifp);
}
#ifdef HMEDEBUG
sc->sc_debug = (ifp->if_flags & IFF_DEBUG) != 0 ? 1 : 0;
#endif
break;
case SIOCADDMULTI:
case SIOCDELMULTI:
error = (cmd == SIOCADDMULTI) ?
ether_addmulti(ifr, &sc->sc_arpcom) :
ether_delmulti(ifr, &sc->sc_arpcom);
if (error == ENETRESET) {
/*
* Multicast list has changed; set the hardware filter
* accordingly.
*/
gem_init(ifp);
error = 0;
}
break;
case SIOCGIFMEDIA:
case SIOCSIFMEDIA:
error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
break;
default:
error = EINVAL;
break;
}
splx(s);
return (error);
}
```
<Overlap Ratio: 0.9984350547730829>

---

--- 79 --
Question ID: 0d5a4a866ee30ea0d48c28899c54d00ba8e2cd62_7
Original Code:
```
static void signal_retirement(const char* source, const char* buf) {
  sexp* call = KEEP(r_parse(source));
  sexp* msg = KEEP(r_chr(buf));

  r_eval_with_x(call, r_ns_env("rlang"), msg);

  FREE(2);
}
```


Overlapping Code:
```
signal_retirement(const char* source, const char* buf) {
sexp* call = KEEP(r_parse(source));
sexp* msg = KEEP(r_chr(buf));
r_eval_with_x(call, r_ns_env("rlang"), msg);

```
<Overlap Ratio: 0.8842105263157894>

---

--- 80 --
Question ID: 0248175301b3662c026aefc3ba7a66bf004ec545_5
Original Code:
```
void
vtc_log(struct vtclog *vl, unsigned lvl, const char *fmt, ...)
{

	CHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);
	AZ(pthread_mutex_lock(&vl->mtx));
	assert(lvl < NLEAD);
	vsb_clear(vl->vsb);
	vsb_printf(vl->vsb, "%s %-4s ", lead[lvl], vl->id);
	va_list ap;
	va_start(ap, fmt);
	(void)vsb_vprintf(vl->vsb, fmt, ap);
	va_end(ap);
	vsb_putc(vl->vsb, '\n');
	vsb_finish(vl->vsb);
	AZ(vsb_overflowed(vl->vsb));

	vtc_log_emit(vl, lvl);

	vsb_clear(vl->vsb);
	AZ(pthread_mutex_unlock(&vl->mtx));
	if (lvl == 0) {
		vtc_error = 1;
		if (pthread_self() != vtc_thread)
			pthread_exit(NULL);
	}
}
```


Overlapping Code:
```
og(struct vtclog *vl, unsigned lvl, const char *fmt, ...)
{
CHECK_OBJ_NOTNULL(vl, VTCLOG_MAGIC);
AZ(pthread_mutex_lock(&vl->mtx));
assert(lvl < NLEAD);
vsb_clear(vl->vsb);
vsb_printf(vl->vsb, "%s %-4s ", lead[lvl], vl->id);
va_list ap;
va_start(ap, fmt);
(void)vsb_vprintf(vl->vsb, fmt, ap);
va_end(ap);
vsb_putc(vl->vsb, '\n');
vsb_finish(vl->vsb);
AZ(vsb_overflowed(vl->vsb));
vtc_log_emit(vl, lvl);
vsb_clear(vl->vsb);
AZ(pthread_mutex_unlock(&vl->mtx));
if (lvl == 0) {
vtc_error = 1;
if (pthread_self() != vtc_thread)
pthread_exit(NULL
```
<Overlap Ratio: 0.9712230215827338>

---

--- 81 --
Question ID: 8a7cb69dce5c6f914f3f443afe876e92d6669d0d_5
Original Code:
```
void decompress(uint8_t* source, uint8_t* decomp, int32_t decompSize)
{
    uint32_t srcPlace = 0, dstPlace = 0;
    uint32_t i, dist, copyPlace, numBytes;
    uint8_t codeByte, byte1, byte2;
    uint8_t bitCount = 0;

    source += 0x10;
    while(dstPlace < decompSize)
    {
        /* If there are no more bits to test, get a new byte */
        if(!bitCount)
        {
            codeByte = source[srcPlace++];
            bitCount = 8;
        }

        /* If bit 7 is a 1, just copy 1 byte from source to destination */
        /* Else do some decoding */
        if(codeByte & 0x80)
        {
            decomp[dstPlace++] = source[srcPlace++];
        }
        else
        {
            /* Get 2 bytes from source */
            byte1 = source[srcPlace++];
            byte2 = source[srcPlace++];

            /* Calculate distance to move in destination */
            /* And the number of bytes to copy */
            dist = ((byte1 & 0xF) << 8) | byte2;
            copyPlace = dstPlace - (dist + 1);
            numBytes = byte1 >> 4;

            /* Do more calculations on the number of bytes to copy */
            if(!numBytes)
                numBytes = source[srcPlace++] + 0x12;
            else
                numBytes += 2;

            /* Copy data from a previous point in destination */
            /* to current point in destination */
            for(i = 0; i < numBytes; i++)
                decomp[dstPlace++] = decomp[copyPlace++];
        }

        /* Set up for the next read cycle */
        codeByte = codeByte << 1;
        bitCount--;
    }
}
```


Overlapping Code:
```
t8_t* source, uint8_t* decomp, int32_t decompSize)
{
uint32_t srcPlace = 0, dstPlace = 0;
uint32_t i, dist, copyPlace, numBytes;
uint8_t codeByte, byte1, byte2;
uint8_t bitCount = 0;
source += 0x10;
while(dstPlace < decompSize)
{
/* If there are no more bits to test, get a new byte */
if(!bitCount)
{
codeByte = source[srcPlace++];
bitCount = 8;
}
/* If bit 7 is a 1, just copy 1 byte from source to destination */
/* Else do some decoding */
if(codeByte & 0x80)
{
decomp[dstPlace++] = source[srcPlace++];
}
else
{
/* Get 2 bytes from source */
byte1 = source[srcPlace++];
byte2 = source[srcPlace++];
/* Calculate distance to move in destination */
/* And the number of bytes to copy */
dist = ((byte1 & 0xF) << 8) | byte2;
copyPlace = dstPlace - (dist + 1);
numBytes = byte1 >> 4;
/* Do more calculations on the number of bytes to copy */
if(!numBytes)
numBytes = source[srcPlace++] + 0x12;
else
numBytes += 2;
/* Copy data from a previous point in destination */
/* to current point in destination */
for(i = 0; i < numBytes; i++)
decomp[dstPlace++] = decomp[copyPlace++];
}
/* Set up for the next read cycle */
codeByte = codeByte << 1;
bitCount-
```
<Overlap Ratio: 0.9787234042553191>

---

--- 82 --
Question ID: 6ca848b6ed36ed23374562afddbd2c2d216c5484_0
Original Code:
```
int uart_open(char* device, int baudrate)
{
    int uart_fd;
    struct termios uart_term;

    uart_fd = open(device, O_RDWR | O_NOCTTY);

    if (uart_fd <= 0)
        return -1;

    memset(&uart_term, 0, sizeof(uart_term));
    uart_term.c_cflag = parse_baudrate(baudrate) | CS8 | CLOCAL | CREAD;
    uart_term.c_iflag = IGNPAR;
    uart_term.c_oflag = 0;

    /* set noncanonical mode */
    uart_term.c_lflag = 0;
    uart_term.c_cc[VTIME] = 30;
    uart_term.c_cc[VMIN] = 1;
    tcflush(uart_fd, TCIFLUSH);

    if (tcsetattr(uart_fd, TCSANOW, &uart_term) != 0) {
        close(uart_fd);
        return -1;
    }

    /* Put the fd in non-blocking mode */
    if (fcntl(uart_fd, F_SETFL, fcntl(uart_fd, F_GETFL) | O_NONBLOCK) < 0) {
        close(uart_fd);
        return -1;
    }

    return uart_fd;
}
```


Overlapping Code:
```
 baudrate)
{
int uart_fd;
struct termios uart_term;
uart_fd = open(device, O_RDWR | O_NOCTTY);
if (uart_fd <= 0)
return -1;
memset(&uart_term, 0, sizeof(uart_term));
uart_term.c_cflag = parse_baudrate(baudrate) | CS8 | CLOCAL | CREAD;
uart_term.c_iflag = IGNPAR;
uart_term.c_oflag = 0;
/* set noncanonical mode */
uart_term.c_lflag = 0;
uart_term.c_cc[VTIME] = 30;
uart_term.c_cc[VMIN] = 1;
tcflush(uart_fd, TCIFLUSH);
if (tcsetattr(uart_fd, TCSANOW, &uart_term) != 0) {
close(uart_fd);
return -1;
}
/* Put the fd in non-blocking mode */
if (fcntl(uart_fd, F_SETFL, fcntl(uart_fd, F_GETFL) | O_NONBLOCK) < 0) {
close(uart_fd);
return -1;
}
return uar
```
<Overlap Ratio: 0.9447674418604651>

---

--- 83 --
Question ID: 5b70f723654af68b80ff894d866a2c33f8b66bec_2
Original Code:
```
void
getCmdOpts (
	int argc,
	char *argv[]
	)
{
	int i;

	while ((i = ntp_getopt(argc, argv, "c:dfg:hlnt")) != EOF)
		switch (i) {
		    case 'c':
			config_file = ntp_optarg;
#ifdef HAVE_NETINFO
			check_netinfo = 0;
#endif
			break;
		    case 'd':
			++debug;
			break;
		    case 'f':
			++force;
			break;
		    case 'g':
			while (*ntp_optarg) {
				switch (*ntp_optarg) {
				    case 'd':
					++make_dh;
					break;
				    case 'm':
					++make_md5;
					break;
				    case 'r':
					++make_rsa;
					break;
				    default:
					++errflag;
					break;
				}
				++ntp_optarg;
			}
			break;
		    case 'h':
			++here;
			++nosymlinks;
			break;
		    case 'l':
			++nosymlinks;
			break;
		    case 'n':
			++memorex;
			break;
		    case 't':
			++trash;
			break;
		    case '?':
			++errflag;
			break;
		}

	if (errflag)
		usage();

	/* If no file type was specified, make them all. */
	if (!(make_dh | make_md5 | make_rsa)) {
		++make_dh;
		++make_md5;
		++make_rsa;
	}
}
```


Overlapping Code:
```
gv[]
)
{
int i;
while ((i = ntp_getopt(argc, argv, "c:dfg:hlnt")) != EOF)
switch (i) {
case 'c':
config_file = ntp_optarg;
#ifdef HAVE_NETINFO
check_netinfo = 0;
#endif
break;
case 'd':
++debug;
break;
case 'f':
++force;
break;
case 'g':
while (*ntp_optarg) {
switch (*ntp_optarg) {
case 'd':
++make_dh;
break;
case 'm':
++make_md5;
break;
case 'r':
++make_rsa;
break;
default:
++errflag;
break;
}
++ntp_optarg;
}
break;
case 'h':
++here;
++nosymlinks;
break;
case 'l':
++nosymlinks;
break;
case 'n':
++memorex;
break;
case 't':
++trash;
break;
case '?':
++errflag;
break;
}
if (errflag)
usage();
/* If no file type was specified, make them all. */
if (!(make_dh | make_md5 | make_rsa)) {
++make_dh;

```
<Overlap Ratio: 0.9174311926605505>

---

--- 84 --
Question ID: d376225825501701f74ac7f36772240a97c23a3d_3
Original Code:
```
int client_disconnect(client_t *client) {
	assert(client);
	assert(client->socket >= 0);

	/* Interrupt any ongoing read, then close the socket */
	client->running = 0;
	pthread_kill(client->net_thread, SIGUSR1);
	pthread_join(client->net_thread, NULL);
	close(client->socket);

	vector_free(&client->users);
	vector_free(&client->chats);
	vector_free(&client->names);

	return 0;
}
```


Overlapping Code:
```
lient) {
assert(client);
assert(client->socket >= 0);
/* Interrupt any ongoing read, then close the socket */
client->running = 0;
pthread_kill(client->net_thread, SIGUSR1);
pthread_join(client->net_thread, NULL);
close(client->socket);
vector_free(&client->users);
vector_free(&client->chats);
vecto
```
<Overlap Ratio: 0.8152173913043478>

---

--- 85 --
Question ID: f4ecd080224d2aa212b2b449e56260852753ac4d_23
Original Code:
```
static slist_t*
_splice_after_r(slist_t* self, slist_ref_t pos,
    slist_t* other, slist_ref_t first, slist_ref_t last)
{
  assert(self);
  assert(other);

  if(pos == first || first == last || pos == NULL ||
      first == NULL || first->next == NULL)
    return self;

  if( pos->next != NULL ){
    slist_ref_t b_last = first;
    while( b_last->next != NULL )  b_last = b_last ->next;
    __link_nodes(b_last, pos->next);
  }
  __link_nodes(pos, first->next);
  __link_nodes(first, last);
  return self;
}
```


Overlapping Code:
```
slist_t*
_splice_after_r(slist_t* self, slist_ref_t pos,
slist_t* other, slist_ref_t first, slist_ref_t last)
{
assert(self);
assert(other);
if(pos == first || first == last || pos == NULL ||
first == NULL || first->next == NULL)
return self;
if( pos->next != NULL ){
slist_ref_t b_last = first;
while( b_last->next != NULL ) b_last = b_last ->next;
__link_nodes(b_last, pos->next);
}
__link_nodes(pos, first->next);
__link_nodes(first, last);
return
```
<Overlap Ratio: 0.967741935483871>

---

--- 86 --
Question ID: 33177571d03d16ea93eaf58ac9719c2e84824e55_22
Original Code:
```
int proxyfs_remount(mount_handle_t* in_mount_handle)
{
    // Get context and set the method
    jsonrpc_context_t* ctx = jsonrpc_open(in_mount_handle->rpc_handle, "RpcMountByVolumeName");

    // Set the params based on what was passed in
    jsonrpc_set_req_param_str(   ctx, ptable[VOL_NAME],      in_mount_handle->volume_name);
    jsonrpc_set_req_param_int(   ctx, ptable[MOUNT_OPTS],    in_mount_handle->mount_options);
    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_USER_ID],  in_mount_handle->auth_user_id);
    jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_GROUP_ID], in_mount_handle->auth_group_id);

    // Call RPC
    int rsp_status = jsonrpc_exec_request_blocking(ctx);
    if (rsp_status == 0) {
        // Success; Set the return values (assuming .mount_id_as_str decodes)
        in_mount_handle->mount_id_as_str    = strdup(jsonrpc_get_resp_str(ctx, ptable[MOUNT_ID]));
        in_mount_handle->root_dir_inode_num = jsonrpc_get_resp_uint64(ctx, ptable[ROOT_DIR_INODE_NUM]);

        rsp_status = proxyfs_decode_mount_id(in_mount_handle);
        if (rsp_status != 0) {
            handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);
        }
    } else {
        handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);
    }

    // Clean up jsonrpc context and return
    jsonrpc_close(ctx);
    return rsp_status;
}
```


Overlapping Code:
```
andle_t* in_mount_handle)
{
// Get context and set the method
jsonrpc_context_t* ctx = jsonrpc_open(in_mount_handle->rpc_handle, "RpcMountByVolumeName");
// Set the params based on what was passed in
jsonrpc_set_req_param_str( ctx, ptable[VOL_NAME], in_mount_handle->volume_name);
jsonrpc_set_req_param_int( ctx, ptable[MOUNT_OPTS], in_mount_handle->mount_options);
jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_USER_ID], in_mount_handle->auth_user_id);
jsonrpc_set_req_param_uint64(ctx, ptable[AUTH_GROUP_ID], in_mount_handle->auth_group_id);
// Call RPC
int rsp_status = jsonrpc_exec_request_blocking(ctx);
if (rsp_status == 0) {
// Success; Set the return values (assuming .mount_id_as_str decodes)
in_mount_handle->mount_id_as_str = strdup(jsonrpc_get_resp_str(ctx, ptable[MOUNT_ID]));
in_mount_handle->root_dir_inode_num = jsonrpc_get_resp_uint64(ctx, ptable[ROOT_DIR_INODE_NUM]);
rsp_status = proxyfs_decode_mount_id(in_mount_handle);
if (rsp_status != 0) {
handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);
}
} else {
handle_rsp_error(__FUNCTION__, &rsp_status, in_mount_handle);
}
// Clean up jsonrpc context and return
jsonrpc_close(ctx);
return rsp_status;
}
```
<Overlap Ratio: 0.9776304888152444>

---

--- 87 --
Question ID: e4d5d5ccd1f6480761d544c87ba701234d57725b_14
Original Code:
```
MX_EXPORT void
mx_numbered_breakpoint( unsigned long breakpoint_number )
{
	static const char fname[] = "mx_numbered_breakpoint()";

	if ( breakpoint_number >= MXU_MAX_NUMBERED_BREAKPOINTS ) {
		(void) mx_error( MXE_WOULD_EXCEED_LIMIT, fname,
		"The requested breakpoint number %lu is outside the "
		"allowed range of values from 0 to %d",
			breakpoint_number,
			MXU_MAX_NUMBERED_BREAKPOINTS-1 );
		return;
	}

	if ( mxp_numbered_breakpoint_array[breakpoint_number] ) {
		mx_breakpoint();
	}
	return;
}
```


Overlapping Code:
```
 void
mx_numbered_breakpoint( unsigned long breakpoint_number )
{
static const char fname[] = "mx_numbered_breakpoint()";
if ( breakpoint_number >= MXU_MAX_NUMBERED_BREAKPOINTS ) {
(void) mx_error( MXE_WOULD_EXCEED_LIMIT, fname,
"The requested breakpoint number %lu is outside the "
"allowed range of values from 0 to %d",
breakpoint_number,
MXU_MAX_NUMBERED_BREAKPOINTS-1 );
return;
}
if ( mxp_numbered_breakpoint_array[breakpoint_number] ) {
mx_bre
```
<Overlap Ratio: 0.9355509355509356>

---

--- 88 --
Question ID: e64e26fa7057d645cd3b531a435793a448ab7d1d_69
Original Code:
```
static int rpmnssGenerateRSA(pgpDig dig)
{
    rpmnss nss = dig->impl;
    int rc = 0;		/* assume failure */

    {	CK_MECHANISM_TYPE _type = CKM_RSA_PKCS_KEY_PAIR_GEN;
	PK11SlotInfo * _slot = PK11_GetBestSlot(_type, NULL);
	int _isPerm = PR_FALSE;
	int _isSensitive = PR_FALSE;
	void * _cx = NULL;

assert(nss->nbits);

	if (_slot) {
	    static unsigned _pe = 0x10001;	/* XXX FIXME: pass in e */
	    PK11RSAGenParams rsaparams =
		{ .keySizeInBits = nss->nbits, .pe = _pe };
	    void * params = &rsaparams;

#ifdef	DYING
rpmnssDumpSLOTINFO("\tGetBestSlot", _slot, _type);
#endif

	    nss->sec_key = PK11_GenerateKeyPair(_slot, _type, params,
			&nss->pub_key, _isPerm, _isSensitive, _cx);

#ifdef	DYING
fprintf(stderr, "<-- %p = PK11_GenerateKeyPair(%p, 0x%04X, %p, %p, %s,%s,%p)\n",
nss->sec_key, _slot, (unsigned)_type, params,
&nss->pub_key,
(_isPerm ? "TRUE" : "FALSE"),
(_isSensitive ? "TRUE" : "FALSE"),
_cx);
#endif

	    PK11_FreeSlot(_slot);
	}
    }

    rc = (nss->sec_key && nss->pub_key);

if (1 || _pgp_debug) {
rpmnssDumpPRVKEY(" sec", nss->sec_key);
rpmnssDumpPUBKEY(" pub", nss->pub_key);
}

SPEW(!rc, rc, dig);

    return rc;
}
```


Overlapping Code:
```
int rpmnssGenerateRSA(pgpDig dig)
{
rpmnss nss = dig->impl;
int rc = 0; /* assume failure */
{ CK_MECHANISM_TYPE _type = CKM_RSA_PKCS_KEY_PAIR_GEN;
PK11SlotInfo * _slot = PK11_GetBestSlot(_type, NULL);
int _isPerm = PR_FALSE;
int _isSensitive = PR_FALSE;
void * _cx = NULL;
assert(nss->nbits);
if (_slot) {
static unsigned _pe = 0x10001; /* XXX FIXME: pass in e */
PK11RSAGenParams rsaparams =
{ .keySizeInBits = nss->nbits, .pe = _pe };
void * params = &rsaparams;
#ifdef DYING
rpmnssDumpSLOTINFO("\tGetBestSlot", _slot, _type);
#endif
nss->sec_key = PK11_GenerateKeyPair(_slot, _type, params,
&nss->pub_key, _isPerm, _isSensitive, _cx);
#ifdef DYING
fprintf(stderr, "<-- %p = PK11_GenerateKeyPair(%p, 0x%04X, %p, %p, %s,%s,%p)\n",
nss->sec_key, _slot, (unsigned)_type, params,
&nss->pub_key,
(_isPerm ? "TRUE" : "FALSE"),
(_isSensitive ? "TRUE" : "FALSE"),
_cx);
#endif
PK11_FreeSlot(_slot);
}
}
rc = (nss->sec_key && nss->pub_key);
if (1 || _pgp_debug) {
rpmnssDumpPRVKEY(" sec", nss->sec_key);
rpmnssDumpPUBKEY(" pub", nss->pub_key);
```
<Overlap Ratio: 0.9610750695088045>

---

--- 89 --
Question ID: 65cff6a97d62bf0339eef634bf79d19540abfe38_1
Original Code:
```
void *
execute_forever(void *notused)
{
	struct sockaddr_in sin;
	socklen_t slen;
	int nsd;
	while(1) {
		slen = sizeof(sin);
		nsd = accept(sd, (struct sockaddr *)&sin, &slen);
		process_a_child(nsd, &sin, use_sctp);
	}
}
```


Overlapping Code:
```
 *
execute_forever(void *notused)
{
struct sockaddr_in sin;
socklen_t slen;
int nsd;
while(1) {
slen = sizeof(sin);
nsd = accept(sd, (struct sockaddr *)&sin, &slen);
process_a_child(nsd, &sin, use_sct
```
<Overlap Ratio: 0.9478672985781991>

---

--- 90 --
Question ID: 2774efe85065980b9f2089563fafc1695caa9389_0
Original Code:
```
SEXP attribute_hidden do_allnames(SEXP call, SEXP op, SEXP args, SEXP env)
{
    SEXP expr;
    int i, savecount;
    NameWalkData data = {NULL, 0, 0, 0, 0, 0};

    checkArity(op, args);

    expr = CAR(args);
    args = CDR(args);

    data.IncludeFunctions = asLogical(CAR(args));
    if(data.IncludeFunctions == NA_LOGICAL)
	data.IncludeFunctions = 0;
    args = CDR(args);

    data.MaxCount = asInteger(CAR(args));
    if(data.MaxCount == -1) data.MaxCount = INT_MAX;
    if(data.MaxCount < 0 || data.MaxCount == NA_INTEGER)
	data.MaxCount = 0;
    args = CDR(args);

    data.UniqueNames = asLogical(CAR(args));
    if(data.UniqueNames == NA_LOGICAL)
	data.UniqueNames = 1;

    namewalk(expr, &data);
    savecount = data.ItemCounts;

    data.ans = allocVector(STRSXP, data.ItemCounts);

    data.StoreValues = 1;
    data.ItemCounts = 0;
    namewalk(expr, &data);

    if(data.ItemCounts != savecount) {
	PROTECT(expr = data.ans);
	data.ans = allocVector(STRSXP, data.ItemCounts);
	for(i = 0 ; i < data.ItemCounts ; i++)
	    SET_STRING_ELT(data.ans, i, STRING_ELT(expr, i));
	UNPROTECT(1);
    }

    return data.ans;
}
```


Overlapping Code:
```
ibute_hidden do_allnames(SEXP call, SEXP op, SEXP args, SEXP env)
{
SEXP expr;
int i, savecount;
NameWalkData data = {NULL, 0, 0, 0, 0, 0};
checkArity(op, args);
expr = CAR(args);
args = CDR(args);
data.IncludeFunctions = asLogical(CAR(args));
if(data.IncludeFunctions == NA_LOGICAL)
data.IncludeFunctions = 0;
args = CDR(args);
data.MaxCount = asInteger(CAR(args));
if(data.MaxCount == -1) data.MaxCount = INT_MAX;
if(data.MaxCount < 0 || data.MaxCount == NA_INTEGER)
data.MaxCount = 0;
args = CDR(args);
data.UniqueNames = asLogical(CAR(args));
if(data.UniqueNames == NA_LOGICAL)
data.UniqueNames = 1;
namewalk(expr, &data);
savecount = data.ItemCounts;
data.ans = allocVector(STRSXP, data.ItemCounts);
data.StoreValues = 1;
data.ItemCounts = 0;
namewalk(expr, &data);
if(data.ItemCounts != savecount) {
PROTECT(expr = data.ans);
data.ans = allocVector(STRSXP, data.ItemCounts);
for(i = 0 ; i < data.ItemCounts ; i++)
SET_STRING_ELT(data.ans, i, STRING_ELT(expr, i));
UNPROTECT(1);
}
return data.an
```
<Overlap Ratio: 0.9871668311944719>

---

--- 91 --
Question ID: 4d39fcc91a8189fc399a1624fd3984591d20e86f_1
Original Code:
```
int
enc_clone_create(struct if_clone *ifc, int unit)
{
	struct enc_softc	*sc;
	struct ifnet		*ifp;
	struct ifnet		**new;
	size_t			 newlen;
	int			 error;

	if (unit > ENC_MAX_UNITS)
		return (EINVAL);

	if ((sc = malloc(sizeof(struct enc_softc),
	    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (ENOBUFS);

	sc->sc_unit = unit;

	ifp = &sc->sc_if;
	ifp->if_softc = sc;
	ifp->if_type = IFT_ENC;
	ifp->if_start = enc_start;
	ifp->if_output = enc_output;
	ifp->if_ioctl = enc_ioctl;
	ifp->if_hdrlen = ENC_HDRLEN;

	snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
	    ifc->ifc_name, unit);

	if_attach(ifp);
	if (unit == 0)
		if_addgroup(ifp, ifc->ifc_name);
	/*
	 * enc(4) does not have a link-layer address but rtrequest()
	 * wants an ifa for every route entry.  So let's setup a fake
	 * and empty ifa of type AF_LINK for this purpose.
	 */
	if_alloc_sadl(ifp);
	sc->sc_ifa.ifa_ifp = ifp;
	sc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);
	sc->sc_ifa.ifa_netmask = NULL;

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_ENC, ENC_HDRLEN);
#endif

	if ((error = enc_setif(ifp, 0)) != 0) {
		if_detach(ifp);
		free(sc, M_DEVBUF, 0);
		return (error);
	}

	if (unit == 0 || unit > enc_max_unit) {
		if ((new = mallocarray(unit + 1, sizeof(struct ifnet *),
		    M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
			return (ENOBUFS);
		newlen = sizeof(struct ifnet *) * (unit + 1);

		if (enc_allifps != NULL) {
			memcpy(new, enc_allifps,
			    sizeof(struct ifnet *) * (enc_max_unit + 1));
			free(enc_allifps, M_DEVBUF, 0);
		}
		enc_allifps = new;
		enc_max_unit = unit;
	}
	enc_allifps[unit] = ifp;

	return (0);
}
```


Overlapping Code:
```
_clone_create(struct if_clone *ifc, int unit)
{
struct enc_softc *sc;
struct ifnet *ifp;
struct ifnet **new;
size_t newlen;
int error;
if (unit > ENC_MAX_UNITS)
return (EINVAL);
if ((sc = malloc(sizeof(struct enc_softc),
M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
return (ENOBUFS);
sc->sc_unit = unit;
ifp = &sc->sc_if;
ifp->if_softc = sc;
ifp->if_type = IFT_ENC;
ifp->if_start = enc_start;
ifp->if_output = enc_output;
ifp->if_ioctl = enc_ioctl;
ifp->if_hdrlen = ENC_HDRLEN;
snprintf(ifp->if_xname, sizeof(ifp->if_xname), "%s%d",
ifc->ifc_name, unit);
if_attach(ifp);
if (unit == 0)
if_addgroup(ifp, ifc->ifc_name);
/*
* enc(4) does not have a link-layer address but rtrequest()
* wants an ifa for every route entry. So let's setup a fake
* and empty ifa of type AF_LINK for this purpose.
*/
if_alloc_sadl(ifp);
sc->sc_ifa.ifa_ifp = ifp;
sc->sc_ifa.ifa_addr = sdltosa(ifp->if_sadl);
sc->sc_ifa.ifa_netmask = NULL;
#if NBPFILTER > 0
bpfattach(&ifp->if_bpf, ifp, DLT_ENC, ENC_HDRLEN);
#endif
if ((error = enc_setif(ifp, 0)) != 0) {
if_detach(ifp);
free(sc, M_DEVBUF, 0);
return (error);
}
if (unit == 0 || unit > enc_max_unit) {
if ((new = mallocarray(unit + 1, sizeof(struct ifnet *),
M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
return (ENOBUFS);
newlen = sizeof(struct ifnet *) * (unit + 1);
if (enc_allifps != NULL) {
memcpy(new, enc_allifps,
sizeof(struct ifnet *) * (enc_max_unit + 1));
free(enc_allifps, M_DEVBUF, 0);
}
enc_allifps = new;
enc_max_unit = unit;
}
enc_allifps
```
<Overlap Ratio: 0.9773182121414277>

---

--- 92 --
Question ID: c759ea85bbf6abbe596ab60aceccc48c68b09d8e_4
Original Code:
```
static void restoreCallerRegs(void) {
    Temp_tempList regs = F_callerSaveRegs();
    int offset = -4;
    for (; regs; regs = regs->tail) {
        Temp_temp reg = regs->head;
        char buf[64];
        sprintf(buf, "movl %d(`s0), `d0", offset);
        emit(AS_Oper(buf, Temp_TempList(reg, NULL), Temp_TempList(F_FP(), NULL), NULL));
        offset -= F_wordSize;
    }
}
```


Overlapping Code:
```
estoreCallerRegs(void) {
Temp_tempList regs = F_callerSaveRegs();
int offset = -4;
for (; regs; regs = regs->tail) {
Temp_temp reg = regs->head;
char buf[64];
sprintf(buf, "movl %d(`s0), `d0", offset);
emit(AS_Oper(buf, Temp_TempList(reg, NULL), Temp_TempList(F_FP(), NULL), NULL));
offset -= F_wordS
```
<Overlap Ratio: 0.9345794392523364>

---

--- 93 --
Question ID: a8ab68169256adae97c52858acb68079f5488c31_6
Original Code:
```
static int ofi_restore_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,
				const char *phname, int16_t phnum, int phent,
				struct ofi_intercept *intercept)
{
	struct ofi_dl_intercept *dl_entry;
	long page_size = ofi_get_page_size();
	void **func_addr, *page;
	int ret;

	FI_DBG(&core_prov, FI_LOG_MR,
	       "releasing symbol %s from dl\n", intercept->symbol);
	func_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);
	if (!func_addr)
		return FI_SUCCESS;

	page = (void *) ((intptr_t) func_addr & ~(page_size - 1));
	ret = mprotect(page, page_size, PROT_READ | PROT_WRITE);
	if (ret < 0)
		return -FI_ENOSYS;

	dlist_foreach_container_reverse(&intercept->dl_intercept_list,
		struct ofi_dl_intercept, dl_entry, entry) {

		if (dl_entry->dl_func_addr != func_addr)
			continue;

		assert(*func_addr == intercept->our_func);
		*func_addr = dl_entry->dl_func;
		dlist_remove(&dl_entry->entry);
		free(dl_entry);
		FI_DBG(&core_prov, FI_LOG_MR,
		       "dl symbol %s restored\n", intercept->symbol);
		break;
	}

	return FI_SUCCESS;
}
```


Overlapping Code:
```
fW(Addr) base, const ElfW(Phdr) *phdr,
const char *phname, int16_t phnum, int phent,
struct ofi_intercept *intercept)
{
struct ofi_dl_intercept *dl_entry;
long page_size = ofi_get_page_size();
void **func_addr, *page;
int ret;
FI_DBG(&core_prov, FI_LOG_MR,
"releasing symbol %s from dl\n", intercept->symbol);
func_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);
if (!func_addr)
return FI_SUCCESS;
page = (void *) ((intptr_t) func_addr & ~(page_size - 1));
ret = mprotect(page, page_size, PROT_READ | PROT_WRITE);
if (ret < 0)
return -FI_ENOSYS;
dlist_foreach_container_reverse(&intercept->dl_intercept_list,
struct ofi_dl_intercept, dl_entry, entry) {
if (dl_entry->dl_func_addr != func_addr)
continue;
assert(*func_addr == intercept->our_func);
*func_addr = dl_entry->dl_func;
dlist_remove(&dl_entry->entry);
free(dl_entry);
FI_DBG(&core_prov, FI_LOG_MR,
"dl symbol %s restored\n", intercept->symbol);
break;
}
return FI_SUCCE
```
<Overlap Ratio: 0.9605662285136501>

---

--- 94 --
Question ID: cb6d1d6c7033204296f890d2a1eef48f245c1efc_78
Original Code:
```
void
updateWindowAttributes(CompWindow *w,
                       CompStackingUpdateMode stackingMode)
{
   XWindowChanges xwc;
   int mask = 0;

   if (w->attrib.override_redirect || !w->managed)
     return;

   if (w->state & CompWindowStateShadedMask)
     {
        hideWindow(w);
     }
   else if (w->shaded)
     {
        showWindow(w);
     }

   if (stackingMode != CompStackingUpdateModeNone)
     {
        Bool aboveFs;
        CompWindow *sibling;

        aboveFs = (stackingMode == CompStackingUpdateModeAboveFullscreen);
        if (w->type & CompWindowTypeFullscreenMask)
          {
             /* put active or soon-to-be-active fullscreen windows over
                all others in their layer */
             if (w->id == w->screen->display->activeWindow)
               {
                  aboveFs = TRUE;
               }
          }

        /* put windows that are just mapped, over fullscreen windows */
        if (stackingMode == CompStackingUpdateModeInitialMap)
          aboveFs = TRUE;

        sibling = findSiblingBelow(w, aboveFs);

        if (sibling &&
            (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))
          {
             CompWindow *p;

             for (p = sibling; p; p = p->prev)
               if (p->id == w->screen->display->activeWindow)
                 break;

             /* window is above active window so we should lower it, assuming that
              * is allowed (if, for example, our window has the "above" state,
              * then lowering beneath the active window may not be allowed.)
              */
             if (p && validSiblingBelow(p, w))
               {
                  p = findValidStackSiblingBelow(sibling, p);

                  /* if we found a valid sibling under the active window, it's
                     our new sibling we want to stack above */
                  if (p)
                    sibling = p;
               }
          }

        mask |= addWindowStackChanges(w, &xwc, sibling);
     }

   if ((stackingMode == CompStackingUpdateModeInitialMap) ||
       (stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))
     {
        /* If we are called from the MapRequest handler, we have to
           immediately update the internal stack. If we don't do that,
           the internal stacking order is invalid until the ConfigureNotify
           arrives because we put the window at the top of the stack when
           it was created */
        if (mask & CWStackMode)
          {
             Window above = (mask & CWSibling) ? xwc.sibling : 0;
             restackWindow(w, above);
          }
     }

   mask |= addWindowSizeChanges(w, &xwc,
                                w->serverX, w->serverY,
                                w->serverWidth, w->serverHeight,
                                w->serverBorderWidth);

   if (w->mapNum && (mask & (CWWidth | CWHeight)))
     sendSyncRequest(w);

   if (mask)
     configureXWindow(w, mask, &xwc);
}
```


Overlapping Code:
```
pStackingUpdateMode stackingMode)
{
XWindowChanges xwc;
int mask = 0;
if (w->attrib.override_redirect || !w->managed)
return;
if (w->state & CompWindowStateShadedMask)
{
hideWindow(w);
}
else if (w->shaded)
{
showWindow(w);
}
if (stackingMode != CompStackingUpdateModeNone)
{
Bool aboveFs;
CompWindow *sibling;
aboveFs = (stackingMode == CompStackingUpdateModeAboveFullscreen);
if (w->type & CompWindowTypeFullscreenMask)
{
/* put active or soon-to-be-active fullscreen windows over
all others in their layer */
if (w->id == w->screen->display->activeWindow)
{
aboveFs = TRUE;
}
}
/* put windows that are just mapped, over fullscreen windows */
if (stackingMode == CompStackingUpdateModeInitialMap)
aboveFs = TRUE;
sibling = findSiblingBelow(w, aboveFs);
if (sibling &&
(stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))
{
CompWindow *p;
for (p = sibling; p; p = p->prev)
if (p->id == w->screen->display->activeWindow)
break;
/* window is above active window so we should lower it, assuming that
* is allowed (if, for example, our window has the "above" state,
* then lowering beneath the active window may not be allowed.)
*/
if (p && validSiblingBelow(p, w))
{
p = findValidStackSiblingBelow(sibling, p);
/* if we found a valid sibling under the active window, it's
our new sibling we want to stack above */
if (p)
sibling = p;
}
}
mask |= addWindowStackChanges(w, &xwc, sibling);
}
if ((stackingMode == CompStackingUpdateModeInitialMap) ||
(stackingMode == CompStackingUpdateModeInitialMapDeniedFocus))
{
/* If we are called from the MapRequest handler, we have to
immediately update the internal stack. If we don't do that,
the internal stacking order is invalid until the ConfigureNotify
arrives because we put the window at the top 
```
<Overlap Ratio: 0.948509485094851>

---

--- 95 --
Question ID: a00be21688dd01a5ad8ddcfe80930cfa4d79bf57_216
Original Code:
```
int handle_fwPath0(netsnmp_mib_handler *handler,

						  netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)

{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

			FILE *in;
			extern FILE *popen();
			char fwPath0[512];
			char contextName[32];
			char command[512];

			if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
			    		         printf("ERROR: too long contextName");
			    		         exit(1);

			}

			memset(contextName, 0, 32);
			memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
			memset(command, 0, 512);
			snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath0", contextName);

			if(!(in = popen(command, "r"))){

			exit(1);
			   }

			while(fgets(fwPath0, sizeof(fwPath0), in)!=NULL){
			       printf("%s", fwPath0);
			}
			pclose(in);

	switch(reqinfo->mode) {

        case MODE_GET:
//            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
				    (u_char *) &fwPath0,
			            sizeof( fwPath0 ) );
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath0\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
```


Overlapping Code:
```
wPath0(netsnmp_mib_handler *handler,
netsnmp_handler_registration *reginfo,
netsnmp_agent_request_info *reqinfo,
netsnmp_request_info *requests)
{
/* We are never called for a GETNEXT if it's registered as a
"instance", as it's "magically" handled for us. */
/* a instance handler also only hands us one request at a time, so
we don't need to loop over a list of requests; we'll only get one. */
FILE *in;
extern FILE *popen();
char fwPath0[512];
char contextName[32];
char command[512];
if (reqinfo->asp->orig_pdu->contextNameLen > 31) {
printf("ERROR: too long contextName");
exit(1);
}
memset(contextName, 0, 32);
memcpy(contextName, reqinfo->asp->orig_pdu->contextName, reqinfo->asp->orig_pdu->contextNameLen);
memset(command, 0, 512);
snprintf(command, 512, "ccnmanager -c 1 ccnx:/%s/ccndStatus/forwarding/fwPath0", contextName);
if(!(in = popen(command, "r"))){
exit(1);
}
while(fgets(fwPath0, sizeof(fwPath0), in)!=NULL){
printf("%s", fwPath0);
}
pclose(in);
switch(reqinfo->mode) {
case MODE_GET:
// snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
(u_char *) &fwPath0,
sizeof( fwPath0 ) );
break;
default:
/* we should never get here, so this is a really bad error */
snmp_log(LOG_ERR, "unknown mode (%d) in handle_fwPath0\n", reqinfo->mode );
return SNMP_ERR_GENERR;
}
return SNMP_ERR_NOERROR;
}
```
<Overlap Ratio: 0.9913544668587896>

---

--- 96 --
Question ID: 9fd18d8a38868c29af78a64547f4778536c67e87_4
Original Code:
```
int seek(int pos)
{
	fseek(fp, pos + firstFrame, SEEK_SET);
	dataLeft = 0;

	int ret = fread(readBuf, 1, READ_BUF_SIZE, fp);
	dataLeft += ret;
	readOff = readBuf;

	findValidSync(&readOff, &dataLeft);
	return 1;
}
```


Overlapping Code:
```
s)
{
fseek(fp, pos + firstFrame, SEEK_SET);
dataLeft = 0;
int ret = fread(readBuf, 1, READ_BUF_SIZE, fp);
dataLeft += ret;
readOff = readBuf;
findVali
```
<Overlap Ratio: 0.7352941176470589>

---

--- 97 --
Question ID: 556c859d997160ae76cfb1aa82987689e08a029d_1
Original Code:
```
void
HourlyWorker::NewWeek()
{
    float hours;

    hours = 44; // ( float(rand()) / float(RAND_MAX) ) * 80.0;

    SetThisWeekHours(hours);
}
```


Overlapping Code:
```
NewWeek()
{
float hours;
hours = 44; // ( float(rand()) / float(RAND_MAX) ) * 80.0;
SetThisWeekHours
```
<Overlap Ratio: 0.7751937984496124>

---

--- 98 --
Question ID: 04f4f43dd5ddf58b5afd7a38aaf92c720ab94b2b_2
Original Code:
```
pwr_status_t tim5_one_shot_start
(
    uint64_t  planUs      /* IN */
)
{
    uint64_t cnt;

    krhino_spin_lock_irq_save(&tim5_spin);

    /*
     * convert microsecond into count value according
     * current frequency.
     */

    cnt = planUs * freq_of_internal_count / 1000000;
#ifdef TIM5_DBG
    printf("planUs = %lld, cnt = %lld, tim5_irq_count = %d\n",
           planUs, cnt, tim5_irq_count);
#endif

    /*
     * if request plan time is longer than the time support,
     * just return ERORR, it is responsibility of caller to
     * to handle this PWR_ERR.
     */
    if (cnt > (uint64_t)TIMER_32BIT_MAX_COUNT) {
        krhino_spin_unlock_irq_restore (&tim5_spin);
        return (PWR_ERR);
    }

    /*set counter to 0, it will increase from 0 */
    __HAL_TIM_SET_COUNTER(&Tim5Handle, 0);

    /* update hardware with new one autoload value */
    __HAL_TIM_SET_AUTORELOAD(&Tim5Handle, cnt);

    one_shot_planed_cnt = cnt;
    one_shot_enabled    = 1;

    /*
    Bit 2 URS: Update request source
    This bit is set and cleared by software to select the UEV event sources.
    0:  Any of the following events generate an update interrupt or DMA request
        if enabled.
        These events can be:
        – Counter overflow/underflow
        – Setting the UG bit
        – Update generation through the slave mode controller
    1:  Only counter overflow/underflow generates an update interrupt or DMA
        request if enabled.
    */
    __HAL_TIM_URS_ENABLE(&Tim5Handle);

    /* clear any pending interrupt of update interrupt */
    __HAL_TIM_CLEAR_IT(&Tim5Handle, TIM_IT_UPDATE);

    /* enable update interrupt */
    (void)HAL_TIM_Base_Start_IT(&Tim5Handle);

    krhino_spin_unlock_irq_restore (&tim5_spin);

    return PWR_OK;

}
```


Overlapping Code:
```
one_shot_start
(
uint64_t planUs /* IN */
)
{
uint64_t cnt;
krhino_spin_lock_irq_save(&tim5_spin);
/*
* convert microsecond into count value according
* current frequency.
*/
cnt = planUs * freq_of_internal_count / 1000000;
#ifdef TIM5_DBG
printf("planUs = %lld, cnt = %lld, tim5_irq_count = %d\n",
planUs, cnt, tim5_irq_count);
#endif
/*
* if request plan time is longer than the time support,
* just return ERORR, it is responsibility of caller to
* to handle this PWR_ERR.
*/
if (cnt > (uint64_t)TIMER_32BIT_MAX_COUNT) {
krhino_spin_unlock_irq_restore (&tim5_spin);
return (PWR_ERR);
}
/*set counter to 0, it will increase from 0 */
__HAL_TIM_SET_COUNTER(&Tim5Handle, 0);
/* update hardware with new one autoload value */
__HAL_TIM_SET_AUTORELOAD(&Tim5Handle, cnt);
one_shot_planed_cnt = cnt;
one_shot_enabled = 1;
/*
Bit 2 URS: Update request source
This bit is set and cleared by software to select the UEV event sources.
0: Any of the following events generate an update interrupt or DMA request
if enabled.
These events can be:
– Counter overflow/underflow
– Setting the UG bit
– Update generation through the slave mode controller
1: Only counter overflow/underflow generates an update interrupt or DMA
request if enabled.
*/
__HAL_TIM_URS_ENABLE(&Tim5Handle);
/* clear any pending interrupt of update interrupt */
__HAL_TIM_CLEAR_IT(&Tim5Handle, TIM_IT_UPDATE);
/* enable update interrupt */
(void)HAL_TIM_Base_Start_IT(&Tim5Handle);
krhino_spin_unlock
```
<Overlap Ratio: 0.9599211563731932>

---

--- 99 --
Question ID: e8cfec07614cf63f38dc520ba908a25fc4ddab37_1
Original Code:
```
bool ApplyRelocation(uint8_t * base, VpuRelocation * relocation)
	{
		uint32_t * loc = (uint32_t *)(base + relocation->m_fixupOffset);

		if (relocation->m_type == kIMAGE_REL_I386_REL32 || relocation->m_type == kIMAGE_REL_AMD64_REL32)
			*loc = (uint32_t) (relocation->m_referenceOffset - relocation->m_fixupOffset - 4);
#ifdef _M_IX86
		else if (relocation.m_type == kIMAGE_REL_I386_DIR32)
			*loc = relocation.m_referenceOffset + (uint32_t)base;
#endif
		else
			return false;
		return true;
	}
```


Overlapping Code:
```
ation * relocation)
{
uint32_t * loc = (uint32_t *)(base + relocation->m_fixupOffset);
if (relocation->m_type == kIMAGE_REL_I386_REL32 || relocation->m_type == kIMAGE_REL_AMD64_REL32)
*loc = (uint32_t) (relocation->m_referenceOffset - relocation->m_fixupOffset - 4);
#ifdef _M_IX86
else if (relocation.m_type == kIMAGE_REL_I386_DIR32)
*loc = relocation.m_referenceOffset + (uint32_t)base;
#endif
else
```
<Overlap Ratio: 0.8438818565400844>

---

--- 100 --
Question ID: 4b486bcbffedb056942363d77ea84d9cdcbea95a_4
Original Code:
```
int
stge_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct stge_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			stge_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				stge_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				stge_stop(ifp, 1);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			stge_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}
```


Overlapping Code:
```
e_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
struct stge_softc *sc = ifp->if_softc;
struct ifreq *ifr = (struct ifreq *)data;
int s, error = 0;
s = splnet();
switch (cmd) {
case SIOCSIFADDR:
ifp->if_flags |= IFF_UP;
if (!(ifp->if_flags & IFF_RUNNING))
stge_init(ifp);
break;
case SIOCSIFFLAGS:
if (ifp->if_flags & IFF_UP) {
if (ifp->if_flags & IFF_RUNNING)
error = ENETRESET;
else
stge_init(ifp);
} else {
if (ifp->if_flags & IFF_RUNNING)
stge_stop(ifp, 1);
}
break;
case SIOCSIFMEDIA:
case SIOCGIFMEDIA:
error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
break;
default:
error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
}
if (error == ENETRESET) {
if (ifp->if_flags & IFF_RUNNING)
stge_iff(sc);
error = 0
```
<Overlap Ratio: 0.9516971279373369>

---

--- 101 --
Question ID: 855b99ce87c0ca0245f2043bba86c355dc76de5b_19
Original Code:
```
void test_decline_timeout(void **state)
{
    (void)state;

    kaa_log_collector_t *log_collector = NULL;
    kaa_error_t error_code = kaa_log_collector_create(&log_collector, status, channel_manager, logger);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    kaa_user_log_record_t *test_log_record = kaa_test_log_record_create();
    test_log_record->data = kaa_string_copy_create(TEST_LOG_BUFFER);
    size_t test_log_record_size = test_log_record->get_size(test_log_record);

    mock_strategy_context_t strategy;
    memset(&strategy, 0, sizeof(mock_strategy_context_t));
    strategy.timeout = TEST_TIMEOUT;
    strategy.decision = NOOP;
    strategy.max_parallel_uploads = UINT32_MAX;

    mock_storage_context_t *storage = create_mock_storage();
    ASSERT_NOT_NULL(storage);

    kaa_log_bucket_constraints_t constraints = {
        .max_bucket_size = 2 * test_log_record_size,
        .max_bucket_log_count = UINT32_MAX,
    };

    error_code = kaa_logging_init(log_collector, storage, &strategy, &constraints);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    size_t request_buffer_size = 256;
    uint8_t request_buffer[request_buffer_size];
    kaa_platform_message_writer_t *writer = NULL;
    error_code = kaa_platform_message_writer_create(&writer, request_buffer, request_buffer_size);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    error_code = kaa_logging_request_serialize(log_collector, writer);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    sleep(TEST_TIMEOUT + 1);

    uint16_t bucket_id = *((uint16_t *)(request_buffer + KAA_EXTENSION_HEADER_SIZE));
    bucket_id = KAA_NTOHS(bucket_id);

    uint32_t response_count = 1;
    size_t response_buffer_size = sizeof(uint32_t) + sizeof(uint32_t) * response_count;
    uint8_t response_buffer[response_buffer_size];

    uint8_t *response = response_buffer;
    *((uint32_t *)response) = KAA_HTONL(response_count);
    response += sizeof(uint32_t);

    /* First response */
    *((uint16_t *)response) = KAA_HTONS(bucket_id);
    response += sizeof(uint16_t);
    *((uint8_t *)response) = 0x0; // SUCCESS
    response += sizeof(uint8_t);
    *((uint8_t *)response) = 0;
    response += sizeof(uint8_t);

    kaa_platform_message_reader_t *reader = NULL;
    error_code = kaa_platform_message_reader_create(&reader, response_buffer, response_buffer_size);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);
    ASSERT_NOT_NULL(reader);

    error_code = kaa_logging_handle_server_sync(log_collector, reader, 0, response_buffer_size);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);
    ASSERT_TRUE(storage->on_remove_by_id_count);

    error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);
    ASSERT_EQUAL(error_code, KAA_ERR_NONE);

    ASSERT_FALSE(strategy.on_timeout_count);

    test_log_record->destroy(test_log_record);
    kaa_platform_message_writer_destroy(writer);
    kaa_platform_message_reader_destroy(reader);
    kaa_log_collector_destroy(log_collector);
}
```


Overlapping Code:
```
_timeout(void **state)
{
(void)state;
kaa_log_collector_t *log_collector = NULL;
kaa_error_t error_code = kaa_log_collector_create(&log_collector, status, channel_manager, logger);
ASSERT_EQUAL(error_code, KAA_ERR_NONE);
kaa_user_log_record_t *test_log_record = kaa_test_log_record_create();
test_log_record->data = kaa_string_copy_create(TEST_LOG_BUFFER);
size_t test_log_record_size = test_log_record->get_size(test_log_record);
mock_strategy_context_t strategy;
memset(&strategy, 0, sizeof(mock_strategy_context_t));
strategy.timeout = TEST_TIMEOUT;
strategy.decision = NOOP;
strategy.max_parallel_uploads = UINT32_MAX;
mock_storage_context_t *storage = create_mock_storage();
ASSERT_NOT_NULL(storage);
kaa_log_bucket_constraints_t constraints = {
.max_bucket_size = 2 * test_log_record_size,
.max_bucket_log_count = UINT32_MAX,
};
error_code = kaa_logging_init(log_collector, storage, &strategy, &constraints);
ASSERT_EQUAL(error_code, KAA_ERR_NONE);
error_code = kaa_logging_add_record(log_collector, test_log_record, NULL);
ASSERT_EQUAL(error_code, KAA_ERR_NONE);
size_t request_buffer_size = 256;
uint8_t request_buffer[request_buffer_size];
kaa_platform_message_writer_t *writer = NULL;
error_code = kaa_platform_message_writer_create(&writer, request_buffer, request_buffer_size);
ASSERT_EQUAL(error_code, KAA_ERR_NONE);
error_code = kaa_logging_request_serialize(log_collector, writer);
ASSERT_EQUAL(error_code, KAA_ERR_NONE);
sleep(TEST_TIMEOUT + 1);
uint16_t bucket_id = *((uint16_t *)(request_buffer + KAA_EXTENSION_HEADER_SIZE));
bucket_id = KAA_NTOHS(bucket_id);
uint32_t response_count = 1;
size_t response_buffer_size = sizeof(uint32_t) + sizeof(uint32_t) * response_count;
uint8_t response_buffer[response_buffer_size];
uint8_t *response = response_buffer;
*((uint32_t *)response) = KAA_HTONL(response_count);
response += sizeof(uint32_t);
/* First response */
*((uint16_t *)response) = KAA_HTONS(bucket_id);
response += sizeof(uint16_t);
*((uint8_t *)response) = 0x0; // SUCCESS
response += sizeof(uint8_t);
*((uint8_t *)response) = 0;
response += sizeof(uint8_t);
kaa_platform_message_reader_t *reader = NULL;
error_code = kaa_platform_message_reader_create(&reader, response_buffer, response_buffer_size);
ASSERT_EQUAL(error_code, K
```
<Overlap Ratio: 0.9868593955321945>

---

--- 102 --
Question ID: e7a20c0771bbd7b3014d634488c98259fe27a836_471
Original Code:
```
SOAP_FMAC4 soap_out__turb1__GetMagneticHessianResponse(struct soap *soap, const char *tag, int id, const struct _turb1__GetMagneticHessianResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__turb1__GetMagneticHessianResponse), type))
		return soap->error;
	if (a->GetMagneticHessianResult)
		soap_element_result(soap, "turb1:GetMagneticHessianResult");
	if (soap_out_PointerToturb1__ArrayOfVelocityHessian(soap, "turb1:GetMagneticHessianResult", -1, &a->GetMagneticHessianResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}
```


Overlapping Code:
```
t__turb1__GetMagneticHessianResponse(struct soap *soap, const char *tag, int id, const struct _turb1__GetMagneticHessianResponse *a, const char *type)
{
(void)soap; (void)tag; (void)id; (void)type;
if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__turb1__GetMagneticHessianResponse), type))
return soap->error;
if (a->GetMagneticHessianResult)
soap_element_result(soap, "turb1:GetMagneticHessianResult");
if (soap_out_PointerToturb1__ArrayOfVelocityHessian(soap, "turb1:GetMagneticHessianResult", -1, &a->GetMagneticHessianResult, ""))
return soap->error;
return soap_element_end_out(soap, tag);
}
```
<Overlap Ratio: 0.9720496894409938>

---

--- 103 --
Question ID: bd30014fc20e124985265e70130a5c61c3250db0_69
Original Code:
```
static inline void hri_eic_write_EVCTRL_EXTINTEO7_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	EIC_CRITICAL_SECTION_ENTER();
	tmp = ((Eic *)hw)->EVCTRL.reg;
	tmp &= ~EIC_EVCTRL_EXTINTEO7;
	tmp |= value << EIC_EVCTRL_EXTINTEO7_Pos;
	((Eic *)hw)->EVCTRL.reg = tmp;
	EIC_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
e void hri_eic_write_EVCTRL_EXTINTEO7_bit(const void *const hw, bool value)
{
uint32_t tmp;
EIC_CRITICAL_SECTION_ENTER();
tmp = ((Eic *)hw)->EVCTRL.reg;
tmp &= ~EIC_EVCTRL_EXTINTEO7;
tmp |= value << EIC_EVCTRL_EXTINTEO7_Pos;
((Eic *)hw)->EVCTRL.reg = tmp;
EIC_CRITICAL_SECTION_LEAVE
```
<Overlap Ratio: 0.9431438127090301>

---

--- 104 --
Question ID: c2e27179d979b36a02bd012b405eb5d9e011dcaf_8
Original Code:
```
int handle_message_dt_connection_ht_destroy() {
  struct connection_node *cur_connection_node;
  unsigned short header_errno;

  memcpy(&header_errno, message->data, sizeof(short));
  header_errno = ntohs(header_errno);
  if ((cur_connection_node =
           connection_node_find(message->header_origin, message->header_id))) {
    if (verbose && header_errno) {
      fprintf(stderr,
              "\rhandle_message_dt_connection_ht_destroy(): Connection %s "
              "closed: %s\n",
              cur_connection_node->rhost_rport, strerror(header_errno));
    }

    connection_node_delete(cur_connection_node);
  }

  return (0);
}
```


Overlapping Code:
```
handle_message_dt_connection_ht_destroy() {
struct connection_node *cur_connection_node;
unsigned short header_errno;
memcpy(&header_errno, message->data, sizeof(short));
header_errno = ntohs(header_errno);
if ((cur_connection_node =
connection_node_find(message->header_origin, message->header_id))) {
if (verbose && header_errno) {
fprintf(stderr,
"\rhandle_message_dt_connection_ht_destroy(): Connection %s "
"closed: %s\n",
cur_connection_node->rhost_rport, strerror(header_errno));
}
connection_node_de
```
<Overlap Ratio: 0.9168173598553345>

---

--- 105 --
Question ID: 45c988159d60b2b9990c59e950e9841fb93e0aba_7
Original Code:
```
void
isc_stop_receiver(isc_session_t *sp)
{
     debug_called(8);
     debug(3, "sp=%p sp->sid=%d sp->soc=%p", sp, sp ? sp->sid : 0,
	  sp ? sp->soc : NULL);
     iscsi_lock_ex(&sp->io_mtx);
     sp->flags &= ~ISC_LINK_UP;
     if (sp->flags & ISC_CON_RUNNING) {
	     issleep(&sp->soc, &sp->io_mtx, 0, "iscstpc", 5*hz);
     }
     iscsi_unlock_ex(&sp->io_mtx);

     if (sp->soc)
	  soshutdown(sp->soc, SHUT_RD);

     iscsi_lock_ex(&sp->io_mtx);
     sdebug(3, "soshutdown");
     sp->flags &= ~ISC_CON_RUN;
     while(sp->flags & ISC_CON_RUNNING) {
	  sdebug(3, "waiting flags=%x", sp->flags);
	  issleep(&sp->soc, &sp->io_mtx, 0, "iscstpc", hz);
     }
     iscsi_unlock_ex(&sp->io_mtx);

     if (sp->fp != NULL) {
	  fdrop(sp->fp);
	  sp->fp = NULL;
     }
     /* sofree(sp->soc); fp deals with socket termination */
     sp->soc = NULL;

     sdebug(3, "done");
}
```


Overlapping Code:
```
debug_called(8);
debug(3, "sp=%p sp->sid=%d sp->soc=%p", sp, sp ? sp->sid : 0,
sp ? sp->soc : NULL);
iscsi_lock_ex(&sp->io_mtx);
sp->flags &= ~ISC_LINK_UP;
if (sp->flags & ISC_CON_RUNNING) {
issleep(&sp->soc, &sp->io_mtx, 0, "iscstpc", 5*hz);
}
iscsi_unlock_ex(&sp->io_mtx);
if (sp->soc)
soshutdown(sp->soc, SHUT_RD);
iscsi_lock_ex(&sp->io_mtx);
sdebug(3, "soshutdown");
sp->flags &= ~ISC_CON_RUN;
while(sp->flags & ISC_CON_RUNNING) {
sdebug(3, "waiting flags=%x", sp->flags);
issleep(&sp->soc, &sp->io_mtx, 0, "iscstpc", hz);
}
iscsi_unlock_ex(&sp->io_mtx);
if (sp->fp != NULL) {
fdrop(sp->fp);
sp->fp = NULL;
}
/* sofree(sp->soc); fp deals with socket termination */
sp->soc = NULL;
sdebug(3, "done
```
<Overlap Ratio: 0.9345794392523364>

---

--- 106 --
Question ID: 24f046d254a77c2d95c4febfa35c175cf44161a8_10
Original Code:
```
void   pb__unsubscribe_request__free_unpacked
                     (Pb__UnsubscribeRequest *message,
                      ProtobufCAllocator *allocator)
{
  if(!message)
    return;
  assert(message->base.descriptor == &pb__unsubscribe_request__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
```


Overlapping Code:
```
ribe_request__free_unpacked
(Pb__UnsubscribeRequest *message,
ProtobufCAllocator *allocator)
{
if(!message)
return;
assert(message->base.descriptor == &pb__unsubscribe_request__descriptor);
protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
```
<Overlap Ratio: 0.9430604982206405>

---

--- 107 --
Question ID: e7456de35114938f97b600c390cf3a714492e28d_357
Original Code:
```
static void
HALF_to_CFLOAT(void *input, void *output, npy_intp n,
        void *NPY_UNUSED(aip), void *NPY_UNUSED(aop))
{
    const npy_half *ip = input;
    npy_uint32 *op = output;

    while (n--) {
        *op++ = npy_halfbits_to_floatbits(*ip++);
#if 1
        *op++ = 0;
#endif
    }
}
```


Overlapping Code:
```
c void
HALF_to_CFLOAT(void *input, void *output, npy_intp n,
void *NPY_UNUSED(aip), void *NPY_UNUSED(aop))
{
const npy_half *ip = input;
npy_uint32 *op = output;
while (n--) {
*op++ = npy_halfbits_to_floatbits(*ip++);
#if 
```
<Overlap Ratio: 0.888>

---

--- 108 --
Question ID: 39f119040c3592cb629848f414f30ab4d3b2624e_3
Original Code:
```
static int
create(void)
{
  frame802154_t f;
  int len;
  struct ieee802154_ies ies;
  int ies_len;

  prepare_outgoing_frame(&f);
  len = frame802154_hdrlen(&f);

  /* add padding bytes if necessary */
  if((len + packetbuf_datalen() + LLSEC_OVERHEAD + CRC16_FRAMER_CHECKSUM_LEN) >= CONTIKIMAC_MIN_FRAME_LENGTH) {
    ies_len = 0;
  } else {
    f.fcf.ie_list_present = 1;
    ies.padding_bytes = MAX(CONTIKIMAC_MIN_FRAME_LENGTH
        - len
        - packetbuf_datalen()
        - LLSEC_OVERHEAD
        - CRC16_FRAMER_CHECKSUM_LEN
        - 2 /* padding IE */
        - 2 /* HT2 IE */, 0);

    /* HT2 IE */
    if(!packetbuf_hdralloc(2)) {
      LOG_ERR("packetbuf_hdralloc failed\n");
      return FRAMER_FAILED;
    }
    if(frame80215e_create_ie_header_list_termination_2(packetbuf_hdrptr(), 2, &ies) == FRAMER_FAILED) {
      LOG_ERR("frame80215e_create_ie_header_list_termination_2 failed\n");
      return FRAMER_FAILED;
    }

    /* padding IE */
    if(!packetbuf_hdralloc(2 + ies.padding_bytes)) {
      LOG_ERR("packetbuf_hdralloc failed\n");
      return FRAMER_FAILED;
    }
    if(frame802154e_create_ie_padding(packetbuf_hdrptr(), 2 + ies.padding_bytes, &ies) == FRAMER_FAILED) {
      LOG_ERR("frame802154e_create_ie_padding failed\n");
      return FRAMER_FAILED;
    }

    ies_len = 2 + ies.padding_bytes + 2;
  }

  if(!packetbuf_hdralloc(len)) {
    LOG_ERR("packetbuf_hdralloc failed\n");
    return FRAMER_FAILED;
  }
  frame802154_create(&f, packetbuf_hdrptr());

  return len + ies_len;
}
```


Overlapping Code:
```
nt
create(void)
{
frame802154_t f;
int len;
struct ieee802154_ies ies;
int ies_len;
prepare_outgoing_frame(&f);
len = frame802154_hdrlen(&f);
/* add padding bytes if necessary */
if((len + packetbuf_datalen() + LLSEC_OVERHEAD + CRC16_FRAMER_CHECKSUM_LEN) >= CONTIKIMAC_MIN_FRAME_LENGTH) {
ies_len = 0;
} else {
f.fcf.ie_list_present = 1;
ies.padding_bytes = MAX(CONTIKIMAC_MIN_FRAME_LENGTH
- len
- packetbuf_datalen()
- LLSEC_OVERHEAD
- CRC16_FRAMER_CHECKSUM_LEN
- 2 /* padding IE */
- 2 /* HT2 IE */, 0);
/* HT2 IE */
if(!packetbuf_hdralloc(2)) {
LOG_ERR("packetbuf_hdralloc failed\n");
return FRAMER_FAILED;
}
if(frame80215e_create_ie_header_list_termination_2(packetbuf_hdrptr(), 2, &ies) == FRAMER_FAILED) {
LOG_ERR("frame80215e_create_ie_header_list_termination_2 failed\n");
return FRAMER_FAILED;
}
/* padding IE */
if(!packetbuf_hdralloc(2 + ies.padding_bytes)) {
LOG_ERR("packetbuf_hdralloc failed\n");
return FRAMER_FAILED;
}
if(frame802154e_create_ie_padding(packetbuf_hdrptr(), 2 + ies.padding_bytes, &ies) == FRAMER_FAILED) {
LOG_ERR("frame802154e_create_ie_padding failed\n");
return FRAMER_FAILED;
}
ies_len = 2 + ies.padding_bytes + 2;
}
if(!packetbuf_hdralloc(len)) {
LOG_ERR("packetbuf_hdralloc failed\n");
return FRAMER_FAILED;
}
frame802154_create(&f, packetbuf_hdrptr());
return l
```
<Overlap Ratio: 0.982615268329554>

---

--- 109 --
Question ID: 03eae78a4081a6194255f9c35c63ed3ca836423a_20
Original Code:
```
int DYNDNS_check_info(void)
{
  char buf[BUFSIZ+1];

  if((host == NULL) || (*host == '\0'))
  {
    if(options & OPT_DAEMON)
    {
      return(-1);
    }
    if(host) { free(host); }
    get_input("host", buf, sizeof(buf));
    host = strdup(buf);
  }

  if(address != NULL && !is_dotted_quad(address))
  {
    show_message("the IP address \"%s\" is invalid\n", address);
    return(-1);
  }

  if(interface == NULL && address == NULL)
  {
    if(options & OPT_DAEMON)
    {
      show_message("you must provide either an interface or an address\n");
      return(-1);
    }
    if(interface) { free(interface); }
    get_input("interface", buf, sizeof(buf));
    option_handler(CMD_interface, buf);
  }

  warn_fields(service->fields_used);

  return 0;
}
```


Overlapping Code:
```
_info(void)
{
char buf[BUFSIZ+1];
if((host == NULL) || (*host == '\0'))
{
if(options & OPT_DAEMON)
{
return(-1);
}
if(host) { free(host); }
get_input("host", buf, sizeof(buf));
host = strdup(buf);
}
if(address != NULL && !is_dotted_quad(address))
{
show_message("the IP address \"%s\" is invalid\n", address);
return(-1);
}
if(interface == NULL && address == NULL)
{
if(options & OPT_DAEMON)
{
show_message("you must provide either an interface or an address\n");
return(-1);
}
if(interface) { free(interface); }
get_input("interface", buf, sizeof(buf));
option_handler(CMD_interface, buf);
}
warn_fields(service->fields_used);
r
```
<Overlap Ratio: 0.9603053435114504>

---

--- 110 --
Question ID: 090b61fbd26c16ef7f87504170a2d3a8dc910238_1
Original Code:
```
static int list_length(struct item *head) {
	struct item *current;
	int count=0;
	for(current=head; current!=NULL; current=current->next) {
		count++;
	}
	return count;
}
```


Overlapping Code:
```
 list_length(struct item *head) {
struct item *current;
int count=0;
for(current=head; current!=NULL; current=current->next) {
count++;
}
return count
```
<Overlap Ratio: 0.9202453987730062>

---

--- 111 --
Question ID: 082f006ace0e3484e9f844f9d2a8d2b2b80de743_2
Original Code:
```
class AtlasScientificDO_DOpct : public Variable
{
public:
    AtlasScientificDO_DOpct(Sensor *parentSense,
                            const char *uuid = "",
                            const char *varCode = "AtlasDOpct")
      : Variable(parentSense,
                 (const uint8_t)ATLAS_DOPCT_VAR_NUM,
                 (uint8_t)ATLAS_DOPCT_RESOLUTION,
                 "oxygenDissolvedPercentOfSaturation", "percent",
                 varCode, uuid)
    {}
    AtlasScientificDO_DOpct()
      : Variable((const uint8_t)ATLAS_DOPCT_VAR_NUM,
                 (uint8_t)ATLAS_DOPCT_RESOLUTION,
                 "oxygenDissolvedPercentOfSaturation", "percent", "AtlasDOpct")
    {}
    ~AtlasScientificDO_DOpct(){}
}
```


Overlapping Code:
```

public:
AtlasScientificDO_DOpct(Sensor *parentSense,
const char *uuid = "",
const char *varCode = "AtlasDOpct")
: Variable(parentSense,
(const uint8_t)ATLAS_DOPCT_VAR_NUM,
(uint8_t)ATLAS_DOPCT_RESOLUTION,
"oxygenDissolvedPercentOfSaturation", "percent",
varCode, uuid)
{}
AtlasScientificDO_DOpct()
: Variable((const uint8_t)ATLAS_DOPCT_VAR_NUM,
(uint8_t)ATLAS_DOPCT_RESOLUTION,
"oxygenDissolvedPercentOfSaturation", "percent", "AtlasDOpct")
{}
~Atla
```
<Overlap Ratio: 0.8587786259541985>

---

--- 112 --
Question ID: 4e04a180f12951520e38c97f3d8109f286c3e421_0
Original Code:
```
class CDSManager : public IOCP
{
public:
	CDSManager(void);
	~CDSManager(void);
	// ----
	void OnError(const char * szMessage, ...);
	void OnMessage(const char * szMessage, ...);
	void OnRecv(int aIndex, BYTE HeadCode, LPBYTE aRecv, int iSize);
	void OnSearch(int aIndex);
	void OnConnect(int aIndex);
	void OnDisconnect(int aIndex);
	// ----
}
```


Overlapping Code:
```
DSManager(void);
~CDSManager(void);
// ----
void OnError(const char * szMessage, ...);
void OnMessage(const char * szMessage, ...);
void OnRecv(int aIndex, BYTE HeadCode, LPBYTE aRecv, int iSize);
void OnSearch(int aIndex);
void OnConnect(int aIndex);
void OnDisconnect
```
<Overlap Ratio: 0.8053892215568862>

---

--- 113 --
Question ID: 78b5304f7135f1e9f890f1c7017d19b7526d4834_3
Original Code:
```
int
wxread(int fd, void *buf, size_t len, int timeout)
{
    time_t expire;
    ssize_t remaining;
    ssize_t rc;
    char *bufp;

    if (timeout <= 0 || timeout > MAX_TIMEOUT) {
        fprintf(stderr, "wxread - timeout %d out of range\n", timeout);
        return -1;
    }

    if (len == 0 || len > MAX_READ) {
        fprintf(stderr, "wxread - length %zu out of range\n", len);
        return -1;
    }

    expire = time((time_t *)NULL) + timeout;

    remaining = len;
    bufp = (char *)buf;

    while (remaining > 0 && timeout > 0) {
        if (wxsettimeout(fd, timeout) == -1) {
            fprintf(stderr, "wxread - failed to set timeout\n");
            return -1;
        }
        if ((rc = read(fd, bufp, remaining)) != remaining) {
            if (rc == -1) {
                perror("wxread - read");
                return -1;
            }
#ifdef DEBUG_WXREAD
            fprintf(stderr, "wxread - read got %zd expected %zd\n",
                    rc, remaining);
#endif /*DEBUG_WXREAD*/
        }
        remaining -= rc;
        bufp += rc;
        timeout = expire - time((time_t *)NULL);
    }
#ifdef DEBUG_WXREAD
    dumpbuf(stderr, buf, len - remaining);
#endif /*DEBUG_WXREAD*/

    return (len - remaining);
}
```


Overlapping Code:
```
, int timeout)
{
time_t expire;
ssize_t remaining;
ssize_t rc;
char *bufp;
if (timeout <= 0 || timeout > MAX_TIMEOUT) {
fprintf(stderr, "wxread - timeout %d out of range\n", timeout);
return -1;
}
if (len == 0 || len > MAX_READ) {
fprintf(stderr, "wxread - length %zu out of range\n", len);
return -1;
}
expire = time((time_t *)NULL) + timeout;
remaining = len;
bufp = (char *)buf;
while (remaining > 0 && timeout > 0) {
if (wxsettimeout(fd, timeout) == -1) {
fprintf(stderr, "wxread - failed to set timeout\n");
return -1;
}
if ((rc = read(fd, bufp, remaining)) != remaining) {
if (rc == -1) {
perror("wxread - read");
return -1;
}
#ifdef DEBUG_WXREAD
fprintf(stderr, "wxread - read got %zd expected %zd\n",
rc, remaining);
#endif /*DEBUG_WXREAD*/
}
remaining -= rc;
bufp += rc;
timeout = expire - time((time_t *)NULL);
}
#ifdef DEBUG_WXREAD
dumpbuf(stderr, buf, len - remaining);
#endif /*DEBUG_WXR
```
<Overlap Ratio: 0.9249743062692704>

---

--- 114 --
Question ID: 9e993387986126111779b28c2f0d3633cb69d591_24
Original Code:
```
static HRESULT WINAPI xmlwriter_WriteCData(IXmlWriter *iface, LPCWSTR data)
{
    xmlwriter *This = impl_from_IXmlWriter(iface);
    int len;

    TRACE("%p %s\n", This, debugstr_w(data));

    switch (This->state)
    {
    case XmlWriterState_Initial:
        return E_UNEXPECTED;
    case XmlWriterState_ElemStarted:
        writer_close_starttag(This);
        break;
    case XmlWriterState_Ready:
    case XmlWriterState_DocClosed:
        This->state = XmlWriterState_DocClosed;
        return WR_E_INVALIDACTION;
    default:
        ;
    }

    len = data ? strlenW(data) : 0;

    write_node_indent(This);
    if (!len)
        write_cdata_section(This->output, NULL, 0);
    else {
        static const WCHAR cdatacloseW[] = {']',']','>',0};
        while (len) {
            const WCHAR *str = strstrW(data, cdatacloseW);
            if (str) {
                str += 2;
                write_cdata_section(This->output, data, str - data);
                len -= str - data;
                data = str;
            }
            else {
                write_cdata_section(This->output, data, len);
                break;
            }
        }
    }

    return S_OK;
}
```


Overlapping Code:
```
ULT WINAPI xmlwriter_WriteCData(IXmlWriter *iface, LPCWSTR data)
{
xmlwriter *This = impl_from_IXmlWriter(iface);
int len;
TRACE("%p %s\n", This, debugstr_w(data));
switch (This->state)
{
case XmlWriterState_Initial:
return E_UNEXPECTED;
case XmlWriterState_ElemStarted:
writer_close_starttag(This);
break;
case XmlWriterState_Ready:
case XmlWriterState_DocClosed:
This->state = XmlWriterState_DocClosed;
return WR_E_INVALIDACTION;
default:
;
}
len = data ? strlenW(data) : 0;
write_node_indent(This);
if (!len)
write_cdata_section(This->output, NULL, 0);
else {
static const WCHAR cdatacloseW[] = {']',']','>',0};
while (len) {
const WCHAR *str = strstrW(data, cdatacloseW);
if (str) {
str += 2;
write_cdata_section(This->output, data, str - data);
len -= str - data;
data = str;
}
else {
write_cdata_section(This->output, data, len);
break;
}
}
}
r
```
<Overlap Ratio: 0.9725400457665904>

---

--- 115 --
Question ID: 7f60d00612ab48803cc9de6f9961d3e4ee45aeff_40
Original Code:
```
static void Xbr2X(const Image *source,const Quantum *pixels,Quantum *result,
  const size_t channels)
{
#define WeightVar(M,N) const int w_##M##_##N = \
  PixelsEqual(pixels,M,pixels,N,channels) ? 0 : 1;

  WeightVar(12,11)
  WeightVar(12,7)
  WeightVar(12,13)
  WeightVar(12,17)
  WeightVar(12,16)
  WeightVar(12,8)
  WeightVar(6,10)
  WeightVar(6,2)
  WeightVar(11,7)
  WeightVar(11,17)
  WeightVar(11,5)
  WeightVar(7,13)
  WeightVar(7,1)
  WeightVar(12,6)
  WeightVar(12,18)
  WeightVar(8,14)
  WeightVar(8,2)
  WeightVar(13,17)
  WeightVar(13,9)
  WeightVar(7,3)
  WeightVar(16,10)
  WeightVar(16,22)
  WeightVar(17,21)
  WeightVar(11,15)
  WeightVar(18,14)
  WeightVar(18,22)
  WeightVar(17,23)
  WeightVar(17,19)
#undef WeightVar

  if (
    w_12_16 + w_12_8 + w_6_10 + w_6_2 + (4 * w_11_7) <
    w_11_17 + w_11_5 + w_7_13 + w_7_1 + (4 * w_12_6)
  )
    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_7 ? 11 : 7),12,result,0,
      channels);
  else
    CopyPixels(pixels,12,result,0,channels);
  if (
    w_12_18 + w_12_6 + w_8_14 + w_8_2 + (4 * w_7_13) <
    w_13_17 + w_13_9 + w_11_7 + w_7_3 + (4 * w_12_8)
  )
    Mix2Pixels(pixels,(ssize_t) (w_12_7 <= w_12_13 ? 7 : 13),12,result,1,
      channels);
  else
    CopyPixels(pixels,12,result,1,channels);
  if (
    w_12_6 + w_12_18 + w_16_10 + w_16_22 + (4 * w_11_17) <
    w_11_7 + w_11_15 + w_13_17 + w_17_21 + (4 * w_12_16)
  )
    Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_17 ? 11 : 17),12,result,2,
      channels);
  else
    CopyPixels(pixels,12,result,2,channels);
  if (
    w_12_8 + w_12_16 + w_18_14 + w_18_22 + (4 * w_13_17) <
    w_11_17 + w_17_23 + w_17_19 + w_7_13 + (4 * w_12_18)
  )
    Mix2Pixels(pixels,(ssize_t) (w_12_13 <= w_12_17 ? 13 : 17),12,result,3,
      channels);
  else
    CopyPixels(pixels,12,result,3,channels);
}
```


Overlapping Code:
```
nst Quantum *pixels,Quantum *result,
const size_t channels)
{
#define WeightVar(M,N) const int w_##M##_##N = \
PixelsEqual(pixels,M,pixels,N,channels) ? 0 : 1;
WeightVar(12,11)
WeightVar(12,7)
WeightVar(12,13)
WeightVar(12,17)
WeightVar(12,16)
WeightVar(12,8)
WeightVar(6,10)
WeightVar(6,2)
WeightVar(11,7)
WeightVar(11,17)
WeightVar(11,5)
WeightVar(7,13)
WeightVar(7,1)
WeightVar(12,6)
WeightVar(12,18)
WeightVar(8,14)
WeightVar(8,2)
WeightVar(13,17)
WeightVar(13,9)
WeightVar(7,3)
WeightVar(16,10)
WeightVar(16,22)
WeightVar(17,21)
WeightVar(11,15)
WeightVar(18,14)
WeightVar(18,22)
WeightVar(17,23)
WeightVar(17,19)
#undef WeightVar
if (
w_12_16 + w_12_8 + w_6_10 + w_6_2 + (4 * w_11_7) <
w_11_17 + w_11_5 + w_7_13 + w_7_1 + (4 * w_12_6)
)
Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_7 ? 11 : 7),12,result,0,
channels);
else
CopyPixels(pixels,12,result,0,channels);
if (
w_12_18 + w_12_6 + w_8_14 + w_8_2 + (4 * w_7_13) <
w_13_17 + w_13_9 + w_11_7 + w_7_3 + (4 * w_12_8)
)
Mix2Pixels(pixels,(ssize_t) (w_12_7 <= w_12_13 ? 7 : 13),12,result,1,
channels);
else
CopyPixels(pixels,12,result,1,channels);
if (
w_12_6 + w_12_18 + w_16_10 + w_16_22 + (4 * w_11_17) <
w_11_7 + w_11_15 + w_13_17 + w_17_21 + (4 * w_12_16)
)
Mix2Pixels(pixels,(ssize_t) (w_12_11 <= w_12_17 ? 11 : 17),12,result,2,
channels);
else
CopyPixels(pixels,12,result,2,channels);
if (
w_12_8 + w_12_16 + w_18_14 + w_18_22 + (4 * w_13_17) <
w_11_17 + w_17_23 + w_17_19 + w_7_13 + (4 * w_12_18)
)
Mix2Pixels(pixels,(ssize_t) (w_12_13 <= w_12_17 ? 13 : 17),12,result,3,
channels);
else
```
<Overlap Ratio: 0.9491733006736068>

---

--- 116 --
Question ID: d493ac01cfb68faa62c158f3b4f1c23ae1e3991f_8
Original Code:
```
Skipkey skiplistminimumkey(Skiplist* skiplist)
{
  Skipnode *minelem;

  /* check input parameters */
  if(skiplist == NULL)
  {
    ERROR0("Could not return min key from skiplist. List handle is NULL.\n");
    return NULL;
  }
  if(skiplist->headpointers == NULL)
  {
    ERROR0("Could not return min key from skiplist. Headpointer is NULL.\n");
    return NULL;
  }

  minelem = skiplist->headpointers[0];
  if(minelem != NULL) {
    skiplist->currentelement = minelem;
    return minelem->key;
  } else
  {
    skiplist->currentelement = NULL;
    return NULL;
  }
}
```


Overlapping Code:
```
umkey(Skiplist* skiplist)
{
Skipnode *minelem;
/* check input parameters */
if(skiplist == NULL)
{
ERROR0("Could not return min key from skiplist. List handle is NULL.\n");
return NULL;
}
if(skiplist->headpointers == NULL)
{
ERROR0("Could not return min key from skiplist. Headpointer is NULL.\n");
return NULL;
}
minelem = skiplist->headpointers[0];
if(minelem != NULL) {
skiplist->currentelement = minelem;
return minelem->key;
} else
{
skiplist->c
```
<Overlap Ratio: 0.8840864440078585>

---

--- 117 --
Question ID: 2772fee93881f1fc85d5e8a56b7a31fa3e1c5cca_26
Original Code:
```
int
svc_recv(struct svc_rqst *rqstp, long timeout)
{
	struct svc_sock		*svsk = NULL;
	struct svc_serv		*serv = rqstp->rq_server;
	struct svc_pool		*pool = rqstp->rq_pool;
	int			len, i;
	int 			pages;
	struct xdr_buf		*arg;
	DECLARE_WAITQUEUE(wait, current);

	dprintk("svc: server %p waiting for data (to = %ld)\n",
		rqstp, timeout);

	if (rqstp->rq_sock)
		printk(KERN_ERR
			"svc_recv: service %p, socket not NULL!\n",
			 rqstp);
	if (waitqueue_active(&rqstp->rq_wait))
		printk(KERN_ERR
			"svc_recv: service %p, wait queue active!\n",
			 rqstp);


	/* now allocate needed pages.  If we get a failure, sleep briefly */
	pages = (serv->sv_max_mesg + PAGE_SIZE) / PAGE_SIZE;
	for (i=0; i < pages ; i++)
		while (rqstp->rq_pages[i] == NULL) {
			struct page *p = alloc_page(GFP_KERNEL);
			if (!p)
				schedule_timeout_uninterruptible(msecs_to_jiffies(500));
			rqstp->rq_pages[i] = p;
		}
	rqstp->rq_pages[i++] = NULL; /* this might be seen in nfs_read_actor */
	BUG_ON(pages >= RPCSVC_MAXPAGES);

	/* Make arg->head point to first page and arg->pages point to rest */
	arg = &rqstp->rq_arg;
	arg->head[0].iov_base = page_address(rqstp->rq_pages[0]);
	arg->head[0].iov_len = PAGE_SIZE;
	arg->pages = rqstp->rq_pages + 1;
	arg->page_base = 0;
	/* save at least one page for response */
	arg->page_len = (pages-2)*PAGE_SIZE;
	arg->len = (pages-1)*PAGE_SIZE;
	arg->tail[0].iov_len = 0;

	try_to_freeze();
	cond_resched();
	if (signalled())
		return -EINTR;

	spin_lock_bh(&pool->sp_lock);
	if ((svsk = svc_sock_dequeue(pool)) != NULL) {
		rqstp->rq_sock = svsk;
		atomic_inc(&svsk->sk_inuse);
		rqstp->rq_reserved = serv->sv_max_mesg;
		atomic_add(rqstp->rq_reserved, &svsk->sk_reserved);
	} else {
		/* No data pending. Go to sleep */
		svc_thread_enqueue(pool, rqstp);

		/*
		 * We have to be able to interrupt this wait
		 * to bring down the daemons ...
		 */
		set_current_state(TASK_INTERRUPTIBLE);
		add_wait_queue(&rqstp->rq_wait, &wait);
		spin_unlock_bh(&pool->sp_lock);

		schedule_timeout(timeout);

		try_to_freeze();

		spin_lock_bh(&pool->sp_lock);
		remove_wait_queue(&rqstp->rq_wait, &wait);

		if (!(svsk = rqstp->rq_sock)) {
			svc_thread_dequeue(pool, rqstp);
			spin_unlock_bh(&pool->sp_lock);
			dprintk("svc: server %p, no data yet\n", rqstp);
			return signalled()? -EINTR : -EAGAIN;
		}
	}
	spin_unlock_bh(&pool->sp_lock);

	dprintk("svc: server %p, pool %u, socket %p, inuse=%d\n",
		 rqstp, pool->sp_id, svsk, atomic_read(&svsk->sk_inuse));
	len = svsk->sk_recvfrom(rqstp);
	dprintk("svc: got len=%d\n", len);

	/* No data, incomplete (TCP) read, or accept() */
	if (len == 0 || len == -EAGAIN) {
		rqstp->rq_res.len = 0;
		svc_sock_release(rqstp);
		return -EAGAIN;
	}
	svsk->sk_lastrecv = get_seconds();
	clear_bit(SK_OLD, &svsk->sk_flags);

	rqstp->rq_secure = svc_port_is_privileged(svc_addr(rqstp));
	rqstp->rq_chandle.defer = svc_defer;

	if (serv->sv_stats)
		serv->sv_stats->netcnt++;
	return len;
}
```


Overlapping Code:
```
int
svc_recv(struct svc_rqst *rqstp, long timeout)
{
struct svc_sock *svsk = NULL;
struct svc_serv *serv = rqstp->rq_server;
struct svc_pool *pool = rqstp->rq_pool;
int len, i;
int pages;
struct xdr_buf *arg;
DECLARE_WAITQUEUE(wait, current);
dprintk("svc: server %p waiting for data (to = %ld)\n",
rqstp, timeout);
if (rqstp->rq_sock)
printk(KERN_ERR
"svc_recv: service %p, socket not NULL!\n",
rqstp);
if (waitqueue_active(&rqstp->rq_wait))
printk(KERN_ERR
"svc_recv: service %p, wait queue active!\n",
rqstp);
/* now allocate needed pages. If we get a failure, sleep briefly */
pages = (serv->sv_max_mesg + PAGE_SIZE) / PAGE_SIZE;
for (i=0; i < pages ; i++)
while (rqstp->rq_pages[i] == NULL) {
struct page *p = alloc_page(GFP_KERNEL);
if (!p)
schedule_timeout_uninterruptible(msecs_to_jiffies(500));
rqstp->rq_pages[i] = p;
}
rqstp->rq_pages[i++] = NULL; /* this might be seen in nfs_read_actor */
BUG_ON(pages >= RPCSVC_MAXPAGES);
/* Make arg->head point to first page and arg->pages point to rest */
arg = &rqstp->rq_arg;
arg->head[0].iov_base = page_address(rqstp->rq_pages[0]);
arg->head[0].iov_len = PAGE_SIZE;
arg->pages = rqstp->rq_pages + 1;
arg->page_base = 0;
/* save at least one page for response */
arg->page_len = (pages-2)*PAGE_SIZE;
arg->len = (pages-1)*PAGE_SIZE;
arg->tail[0].iov_len = 0;
try_to_freeze();
cond_resched();
if (signalled())
return -EINTR;
spin_lock_bh(&pool->sp_lock);
if ((svsk = svc_sock_dequeue(pool)) != NULL) {
rqstp->rq_sock = svsk;
atomic_inc(&svsk->sk_inuse);
rqstp->rq_reserved = serv->sv_max_mesg;
atomic_add(rqstp->rq_reserved, &svsk->sk_reserved);
} else {
/* No data pending. Go to sleep */
svc_thread_enqueue(pool, rqstp);
/*
* We have to be able to interrupt this wait
* to bring down the daemons ...
*/
set_current_state(TASK_INTERRUPTIBLE);
add_wait_queue(&rqstp->rq_wait, &wait);
spin_unlock_bh(&pool->sp_lock);
schedule_timeout(timeout);
try_to_freeze();
spin_lock_bh(&pool->sp_lock);
remove_wait_queue(&rqstp->rq_wait, &wait);
if (!(svsk = rqstp->rq_sock)) {
svc_thread_dequeue(pool, rqstp);
spin_unlock_bh(&pool->sp_lock);
dprintk("svc: server %p, no data yet\n", rqstp);
return signalled()? -EINTR : -EAGAIN;
}
}
spin_unlock_bh(&pool->sp_lock);
dprintk("svc: server %p, pool %u, socket %p, inuse=%d\n",
rqstp, pool->sp_id, svsk, atomic_read(&svsk->sk_inuse));
len = svsk->sk
```
<Overlap Ratio: 0.994458653026428>

---

--- 118 --
Question ID: 8d78c26567d19d4bb954e8235f54bea150eb0aa3_6
Original Code:
```
static void box_project(texture_t* tex, float* u, float* v, float x, float y, float z, float nx, float ny, float nz)
{
    enum {X, Y, Z} major_axis = X;
    float ax = fabs(nx);
    float ay = fabs(ny);
    float az = fabs(nz);
    if (ax > ay) {
        if (ax > az) major_axis = X; else major_axis = Z;
    } else {
        if (ay > az) major_axis = Y; else major_axis = Z;
    }

    switch (major_axis) {
    case X:
        if (nx > 0) {
            *u = -z;
            *v = -y;
        } else {
            *u = z;
            *v = -y;
        }
        break;
    case Y:
        if (ny > 0) {
            *u = x;
            *v = z;
        } else {
            *u = x;
            *v = -z;
        }
        break;
    case Z:
        if (nz > 0) {
            *u = x;
            *v = -y;
        } else {
            *u = -x;
            *v = -y;
        }
        break;
    }

    *u /= (float)(tex?tex->w:1);
    *v /= (float)(tex?tex->h:1);
}
```


Overlapping Code:
```
id box_project(texture_t* tex, float* u, float* v, float x, float y, float z, float nx, float ny, float nz)
{
enum {X, Y, Z} major_axis = X;
float ax = fabs(nx);
float ay = fabs(ny);
float az = fabs(nz);
if (ax > ay) {
if (ax > az) major_axis = X; else major_axis = Z;
} else {
if (ay > az) major_axis = Y; else major_axis = Z;
}
switch (major_axis) {
case X:
if (nx > 0) {
*u = -z;
*v = -y;
} else {
*u = z;
*v = -y;
}
break;
case Y:
if (ny > 0) {
*u = x;
*v = z;
} else {
*u = x;
*v = -z;
}
break;
case Z:
if (nz > 0) {
*u = x;
*v = -y;
} else {
*u = -x;
*v = -y;
}
break;
}
*u /= (float)(tex?tex->
```
<Overlap Ratio: 0.9302325581395349>

---

--- 119 --
Question ID: 803f65fbef099f538cbdd0e4ad7dad75427487fc_3
Original Code:
```
static struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
{
	struct jffs2_node_frag *newfrag;

	newfrag = jffs2_alloc_node_frag();
	if (likely(newfrag)) {
		newfrag->ofs = ofs;
		newfrag->size = size;
		newfrag->node = fn;
	} else {
		JFFS2_ERROR("cannot allocate a jffs2_node_frag object\n");
	}

	return newfrag;
}
```


Overlapping Code:
```
s2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)
{
struct jffs2_node_frag *newfrag;
newfrag = jffs2_alloc_node_frag();
if (likely(newfrag)) {
newfrag->ofs = ofs;
newfrag->size = size;
newfrag->node = fn;
} else {
JFFS2_ERROR("cannot allocate a jffs2_node_frag object\n");
}
ret
```
<Overlap Ratio: 0.9101449275362319>

---

--- 120 --
Question ID: 77c93458f825316a89b82a2b34f6d9fa68ee7964_0
Original Code:
```
void create()
{
        set("short", HIR "【鬼門關】" NOR);
        set("long", HIR @LONG

                    鬼         門         關

    這裏就是著名的陰間入口「鬼門關」，在你面前矗立著一座高大的
黑色城樓，許多亡魂正哭哭啼啼地列隊前進，因為一進鬼門關就無法再
回陽間了。


LONG NOR );
        set("exits", ([
                "north" : __DIR__"gateway",
        ]) );
        set("objects", ([
                __DIR__"npc/bai":1,
                __DIR__"npc/ghost":1,
        ]) );

        set("no_fight", 1);
        set("no_magic", 1);
        set("no_sleep_room", 1);

        setup();
        replace_program(ROOM);
}
```


Overlapping Code:
```
t("short", HIR "【鬼門關】" NOR);
set("long", HIR @LONG
鬼 門 關
這裏就是著名的陰間入口「鬼門關」，在你面前矗立著一座高大的
黑色城樓，許多亡魂正哭哭啼啼地列隊前進，因為一進鬼門關就無法再
回陽間了。
LONG NOR );
set("exits", ([
"north" : __DIR__"gateway",
]) );
set("objects", ([
__DIR__"npc/bai":1,
__DIR__"npc/ghost":1,
]) );
set("no_fight", 1);
set("no_magic", 1);
set("no_sleep_room", 1);
setup();
replace_program(ROOM);

```
<Overlap Ratio: 0.948509485094851>

---

--- 121 --
Question ID: 59ec57f9ba4301d864a9205b70ac8bc77ffbe637_8
Original Code:
```
struct sunxi_drm_gem_obj *sunxi_drm_gem_init(struct drm_device *dev,
						      unsigned long size)
{
	struct sunxi_drm_gem_obj *sunxi_gem_obj;
	struct drm_gem_object *obj;
	int ret;

	sunxi_gem_obj = kzalloc(sizeof(*sunxi_gem_obj), GFP_KERNEL);
	if (!sunxi_gem_obj) {
		DRM_ERROR("failed to allocate sunxi gem object\n");
		return NULL;
	}

	sunxi_gem_obj->size = size;
	obj = &sunxi_gem_obj->base;

	ret = drm_gem_object_init(dev, obj, size);
	if (ret < 0) {
		DRM_ERROR("failed to initialize gem object\n");
		kfree(sunxi_gem_obj);
		return NULL;
	}

	DRM_DEBUG_KMS("created file object = 0x%x\n", (unsigned int)obj->filp);

	return sunxi_gem_obj;
}
```


Overlapping Code:
```
drm_gem_init(struct drm_device *dev,
unsigned long size)
{
struct sunxi_drm_gem_obj *sunxi_gem_obj;
struct drm_gem_object *obj;
int ret;
sunxi_gem_obj = kzalloc(sizeof(*sunxi_gem_obj), GFP_KERNEL);
if (!sunxi_gem_obj) {
DRM_ERROR("failed to allocate sunxi gem object\n");
return NULL;
}
sunxi_gem_obj->size = size;
obj = &sunxi_gem_obj->base;
ret = drm_gem_object_init(dev, obj, size);
if (ret < 0) {
DRM_ERROR("failed to initialize gem object\n");
kfree(sunxi_gem_obj);
return NULL;
}
DRM_DEBUG_KMS("created file object = 0x%x\n", (unsigned int)obj-
```
<Overlap Ratio: 0.8972267536704731>

---

--- 122 --
Question ID: b398c39441be79a9fc2a20131dbb7451e738a1f6_0
Original Code:
```
void create()
{
        set_name("山猴",({"monkey", "houzi", "hou"}) );
        set("race", "野獸");
        set("gender", "雄性" );
        set("age", 15);
        set("long", "這是一隻兇悍的山猴。\n");
        set("combat_exp", 20000);
        set("str", 25);
        set("dex", 25);
        set("con", 25);
        set("int", 25);
        set("attitude", "heroism");

        set("max_qi",800);
        set("qi",800);
        set("max_jingli",800);
        set("jingli",800);
        
        set("limbs", ({ "頭部", "身體", "前腳", "後腳", "尾巴" }) );
        set("verbs", ({ "knock", "hoof" }) );

        set_temp("apply/damage", 20);
        set_temp("apply/armor", 20);

        setup();
}
```


Overlapping Code:
```
", "houzi", "hou"}) );
set("race", "野獸");
set("gender", "雄性" );
set("age", 15);
set("long", "這是一隻兇悍的山猴。\n");
set("combat_exp", 20000);
set("str", 25);
set("dex", 25);
set("con", 25);
set("int", 25);
set("attitude", "heroism");
set("max_qi",800);
set("qi",800);
set("max_jingli",800);
set("jingli",800);

set("limbs", ({ "頭部", "身體", "前腳", "後腳", "尾巴" }) );
set("verbs", ({ "knock", "hoof" }) );
set_temp("apply/damage", 20);
set_temp("apply/armor", 20)
```
<Overlap Ratio: 0.8982035928143712>

---

--- 123 --
Question ID: 9a3ec11223e8ac07eb335974f0a375d4c58640ed_10
Original Code:
```
HRESULT WINAPI IDirectMusicBandTrack_IDirectMusicTrack_AddNotificationType (LPDIRECTMUSICTRACK8 iface, REFGUID rguidNotificationType) {
	ICOM_THIS_MULTI(IDirectMusicBandTrack, TrackVtbl, iface);
	FIXME("(%p, %s): stub\n", This, debugstr_dmguid(rguidNotificationType));
	return S_OK;
}
```


Overlapping Code:
```
RESULT WINAPI IDirectMusicBandTrack_IDirectMusicTrack_AddNotificationType (LPDIRECTMUSICTRACK8 iface, REFGUID rguidNotificationType) {
ICOM_THIS_MULTI(IDirectMusicBandTrack, TrackVtbl, iface);
FIXME("(%p, %s): stub\n", This, debugstr_dmguid(rguidNotificationType));
return S_OK;
}
```
<Overlap Ratio: 0.99644128113879>

---

--- 124 --
Question ID: 6376fdd708f58ce6a60d5d629b43f15f96e64ae6_12
Original Code:
```
void oTDF1_3_init(oTDF1_3 * filter,double * A, double * B){

	int i;
	//A[0] should always equal 1.0
	//https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html
	// negate A because that link says so.
	for (i=0;i<3;i++) {
		filter->B[i] =  B[i];
		if (A != NULL)
			filter->A[i] = -A[i];
	}
	if (A != NULL)
		filter->A[0] = 1;

}
```


Overlapping Code:
```
DF1_3_init(oTDF1_3 * filter,double * A, double * B){
int i;
//A[0] should always equal 1.0
//https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html
// negate A because that link says so.
for (i=0;i<3;i++) {
filter->B[i] = B[i];
if (A != NULL)
filter->A[i] = -A[i];
}
if (A != NULL)
filter->A[0] = 
```
<Overlap Ratio: 0.9652996845425867>

---

--- 125 --
Question ID: 2322e2298f9d357963d212a8e293745a0c4020b0_2
Original Code:
```
always_inline void
parse_ip6_packet(ip6_header_t * ip6, uword * is_reverse, struct ip6_sig * ip6_sig)
{
    ip6_sig->proto = ip6->protocol;

    if (ip6_address_compare(&ip6->src_address, &ip6->dst_address) < 0)
    {
        ip6_sig->src = ip6->src_address;
        ip6_sig->dst = ip6->dst_address;
        *is_reverse = 1;
    } else {
        ip6_sig->src = ip6->dst_address;
        ip6_sig->dst = ip6->src_address;
    }

    if (ip6_sig->proto == IP_PROTOCOL_UDP || ip6_sig->proto == IP_PROTOCOL_TCP)
    {
        /* tcp and udp ports have the same offset */
        udp_header_t * udp0 = (udp_header_t *) ip6_next_header(ip6);
        if (*is_reverse)
        {
            ip6_sig->port_src = udp0->src_port;
            ip6_sig->port_dst = udp0->dst_port;
        } else {
            ip6_sig->port_src = udp0->dst_port;
            ip6_sig->port_dst = udp0->src_port;
        }
    } else {
        ip6_sig->port_src = 0;
        ip6_sig->port_dst = 0;
    }
}
```


Overlapping Code:
```
void
parse_ip6_packet(ip6_header_t * ip6, uword * is_reverse, struct ip6_sig * ip6_sig)
{
ip6_sig->proto = ip6->protocol;
if (ip6_address_compare(&ip6->src_address, &ip6->dst_address) < 0)
{
ip6_sig->src = ip6->src_address;
ip6_sig->dst = ip6->dst_address;
*is_reverse = 1;
} else {
ip6_sig->src = ip6->dst_address;
ip6_sig->dst = ip6->src_address;
}
if (ip6_sig->proto == IP_PROTOCOL_UDP || ip6_sig->proto == IP_PROTOCOL_TCP)
{
/* tcp and udp ports have the same offset */
udp_header_t * udp0 = (udp_header_t *) ip6_next_header(ip6);
if (*is_reverse)
{
ip6_sig->port_src = udp0->src_port;
ip6_sig->port_dst = udp0->dst_port;
} else {
ip6_sig->port_src = udp0->dst_port;
ip6_sig->port_dst = udp0->src_port;
}
} else {
ip6_sig->port_src = 0;
ip6_sig->
```
<Overlap Ratio: 0.9603072983354674>

---

--- 126 --
Question ID: 1f54462067cfd67ae26fcacee7de6447d4428814_7
Original Code:
```
static zx_status_t mbr_bind(void* ctx, zx_device_t* parent) {
    // Make sure the MBR structs are the right size.
    static_assert(sizeof(mbr_t) == MBR_SIZE, "mbr_t is the wrong size");
    static_assert(sizeof(mbr_partition_entry_t) == MBR_PARTITION_ENTRY_SIZE,
                  "mbr_partition_entry_t is the wrong size");

    // create an invisible device, which will be used for the first partition
    mbrpart_device_t* device = calloc(1, sizeof(mbrpart_device_t));
    if (!device) {
        return ZX_ERR_NO_MEMORY;
    }
    device->parent = parent;
    device->bind_completed = SYNC_COMPLETION_INIT;

    if (device_get_protocol(parent, ZX_PROTOCOL_BLOCK, &device->bp) != ZX_OK) {
        zxlogf(ERROR, "mbr: ERROR: block device '%s': does not support block protocol\n",
               device_get_name(parent));
        free(device);
        return ZX_ERR_NOT_SUPPORTED;
    }

    char name[128];
    snprintf(name, sizeof(name), "part-%03u", 0);

    device_add_args_t args = {
        .version = DEVICE_ADD_ARGS_VERSION,
        .name = name,
        .ctx = device,
        .ops = &mbr_proto,
        .proto_id = ZX_PROTOCOL_BLOCK_IMPL,
        .proto_ops = &block_ops,
        .flags = DEVICE_ADD_INVISIBLE,
    };

    zx_status_t status = device_add(parent, &args, &device->zxdev);
    if (status != ZX_OK) {
        free(device);
        return status;
    }

    // Read the partition table asynchronously.
    thrd_t t;
    int thrd_rc = thrd_create_with_name(&t, mbr_bind_thread, device, "mbr-init");
    if (thrd_rc != thrd_success) {
        return thrd_status_to_zx_status(thrd_rc);
    }
    return ZX_OK;
}
```


Overlapping Code:
```
_t mbr_bind(void* ctx, zx_device_t* parent) {
// Make sure the MBR structs are the right size.
static_assert(sizeof(mbr_t) == MBR_SIZE, "mbr_t is the wrong size");
static_assert(sizeof(mbr_partition_entry_t) == MBR_PARTITION_ENTRY_SIZE,
"mbr_partition_entry_t is the wrong size");
// create an invisible device, which will be used for the first partition
mbrpart_device_t* device = calloc(1, sizeof(mbrpart_device_t));
if (!device) {
return ZX_ERR_NO_MEMORY;
}
device->parent = parent;
device->bind_completed = SYNC_COMPLETION_INIT;
if (device_get_protocol(parent, ZX_PROTOCOL_BLOCK, &device->bp) != ZX_OK) {
zxlogf(ERROR, "mbr: ERROR: block device '%s': does not support block protocol\n",
device_get_name(parent));
free(device);
return ZX_ERR_NOT_SUPPORTED;
}
char name[128];
snprintf(name, sizeof(name), "part-%03u", 0);
device_add_args_t args = {
.version = DEVICE_ADD_ARGS_VERSION,
.name = name,
.ctx = device,
.ops = &mbr_proto,
.proto_id = ZX_PROTOCOL_BLOCK_IMPL,
.proto_ops = &block_ops,
.flags = DEVICE_ADD_INVISIBLE,
};
zx_status_t status = device_add(parent, &args, &device->zxdev);
if (status != ZX_OK) {
free(device);
return status;
}
// Read the partition table asynchronously.
thrd_t t;
int thrd_rc = thrd_create_with_name(&t, mbr_bind_thread, device, "mbr-init");
if (thrd_rc != thrd_success) {
return thrd_status_to_zx_status(thrd_rc
```
<Overlap Ratio: 0.974025974025974>

---

--- 127 --
Question ID: fb42b21ad6454defdd361fad36d3237fa498d9a1_21
Original Code:
```
bool
isUsedInOrderBy (Query *query, TargetEntry *te)
{
	GroupClause *groupClause;
		ListCell *lc;

		foreach(lc, query->sortClause)
		{
			groupClause = (GroupClause *) lfirst(lc);

			if (groupClause->tleSortGroupRef == te->ressortgroupref)
				return true;
		}
		return false;
}
```


Overlapping Code:
```
getEntry *te)
{
GroupClause *groupClause;
ListCell *lc;
foreach(lc, query->sortClause)
{
groupClause = (GroupClause *) lfirst(lc);
if (groupClause->tleSortGroupRef == te->ressortgroupref)
return true;
}
r
```
<Overlap Ratio: 0.7937743190661478>

---

--- 128 --
Question ID: 1e2a3b8f9454db31500fbc415138cbf114558f59_6
Original Code:
```
static long si544_round_rate(struct clk_hw *hw, unsigned long rate,
		unsigned long *parent_rate)
{
	struct clk_si544 *data = to_clk_si544(hw);
	struct clk_si544_muldiv settings;
	int err;

	if (!is_valid_frequency(data, rate))
		return -EINVAL;

	err = si544_calc_muldiv(&settings, rate);
	if (err)
		return err;

	return si544_calc_rate(&settings);
}
```


Overlapping Code:
```
544_round_rate(struct clk_hw *hw, unsigned long rate,
unsigned long *parent_rate)
{
struct clk_si544 *data = to_clk_si544(hw);
struct clk_si544_muldiv settings;
int err;
if (!is_valid_frequency(data, rate))
return -EINVAL;
err = si544_calc_muldiv(&settings, rate);
if (err)
return err;
return si544_c
```
<Overlap Ratio: 0.8928571428571429>

---

--- 129 --
Question ID: fe27fa351d1dac78c11e1993eecf6673b8793223_0
Original Code:
```
struct usp_pwm_t *
usp_pwm_new(struct udev_device *device, const char *name,
            enum usp_pwm_type_e type)
{
  struct usp_pwm_t *pwm = NULL;

  pwm = calloc(sizeof(struct usp_pwm_t), 1);
  assert(pwm != NULL);

  udev_device_ref(pwm->uspwm_device);
  pwm->uspwm_device = device;
  pwm->uspwm_type = type;
  pwm->uspwm_name = name;
  usp_ref_init(pwm, usp_pwm_delete);

  return pwm;
}
```


Overlapping Code:
```
p_pwm_t *
usp_pwm_new(struct udev_device *device, const char *name,
enum usp_pwm_type_e type)
{
struct usp_pwm_t *pwm = NULL;
pwm = calloc(sizeof(struct usp_pwm_t), 1);
assert(pwm != NULL);
udev_device_ref(pwm->uspwm_device);
pwm->uspwm_device = device;
pwm->uspwm_type = type;
pwm->uspwm_name = name;
usp_ref_init(pwm, usp_pwm_delete);
return pwm;
}
```
<Overlap Ratio: 0.9749303621169917>

---

--- 130 --
Question ID: da53bc3a2f1845277cde5cf9b9eabcd55a18af69_0
Original Code:
```
class NxRevoluteJointDesc : public NxJointDesc
	{
	public:
	/**
	\brief Optional limits for the angular motion of the joint. 

	<b>Range:</b> See #NxJointLimitPairDesc<br>
	<b>Default:</b> See #NxJointLimitPairDesc

	@see NxJointLimitPairDesc NxJointLimitDesc NxRevoluteJointFlag
	*/
	NxJointLimitPairDesc limit;

	/**
	\brief Optional motor.

	<b>Range:</b> See #NxMotorDesc<br>
	<b>Default:</b> See #NxMotorDesc

	@see NxMotorDesc NxRevoluteJointFlag
	*/
	NxMotorDesc			 motor; 

	/**
	\brief Optional spring.

	<b>Range:</b> See #NxSpringDesc<br>
	<b>Default:</b> See #NxSpringDesc

	@see NxSpringDesc NxRevoluteJointFlag
	*/
	NxSpringDesc		 spring;

	/**
	\brief The distance beyond which the joint is projected.
	
	projectionMode is NX_JPM_POINT_MINDIST, the joint gets artificially projected together when it drifts more than this distance. Sometimes it is not possible to project (for example when the joints form a cycle)
	Should be nonnegative. However, it may be a bad idea to always project to a very small or zero distance because the solver *needs* some error in order to produce correct motion.

	<b>Range:</b> [0,inf)<br>
	<b>Default:</b> 1.0

	@see projectionMode projectionAngle
    */
	NxReal projectionDistance;	

	/**
	\brief The angle beyond which the joint is projected.
	
	This similar to #projectionDistance, except this is an angle (in radians) to which angular drift is 
	projected.

	<b>Unit:</b> Radians
	<b>Range:</b> (0.2,PI)<br>
	<b>Default:</b> 0.0872 (about 5 degrees in radians)

	@see projectionDistance projectionMode
	*/
	NxReal projectionAngle;

	/**
	\brief This is a combination of the bits defined by ::NxRevoluteJointFlag.

	<b>Default:</b> 0

	@see NxRevoluteJointFlag
	*/
	NxU32 flags;

	/**
	\brief use this to enable joint projection

	<b>Default:</b> NX_JPM_NONE

	@see NxJointProjectionMode projectionDistance projectionAngle NxRevoluteJoint.setProjectionMode()
	*/
	NxJointProjectionMode projectionMode;

	/**
	\brief constructor sets to default.
	*/

	NX_INLINE NxRevoluteJointDesc();	
	/**
	\brief (re)sets the structure to the default.	

	\param[in] fromCtor Avoid redundant work if called from constructor.
	*/
	NX_INLINE void setToDefault(bool fromCtor = false);
	
	/**
	\brief Returns true if the descriptor is valid.
	
	\return true if the current settings are valid
	*/
	NX_INLINE bool isValid() const;

	}
```


Overlapping Code:
```
public NxJointDesc
{
public:
/**
\brief Optional limits for the angular motion of the joint. 
<b>Range:</b> See #NxJointLimitPairDesc<br>
<b>Default:</b> See #NxJointLimitPairDesc
@see NxJointLimitPairDesc NxJointLimitDesc NxRevoluteJointFlag
*/
NxJointLimitPairDesc limit;
/**
\brief Optional motor.
<b>Range:</b> See #NxMotorDesc<br>
<b>Default:</b> See #NxMotorDesc
@see NxMotorDesc NxRevoluteJointFlag
*/
NxMotorDesc motor; 
/**
\brief Optional spring.
<b>Range:</b> See #NxSpringDesc<br>
<b>Default:</b> See #NxSpringDesc
@see NxSpringDesc NxRevoluteJointFlag
*/
NxSpringDesc spring;
/**
\brief The distance beyond which the joint is projected.

projectionMode is NX_JPM_POINT_MINDIST, the joint gets artificially projected together when it drifts more than this distance. Sometimes it is not possible to project (for example when the joints form a cycle)
Should be nonnegative. However, it may be a bad idea to always project to a very small or zero distance because the solver *needs* some error in order to produce correct motion.
<b>Range:</b> [0,inf)<br>
<b>Default:</b> 1.0
@see projectionMode projectionAngle
*/
NxReal projectionDistance; 
/**
\brief The angle beyond which the joint is projected.

This similar to #projectionDistance, except this is an angle (in radians) to which angular drift is 
projected.
<b>Unit:</b> Radians
<b>Range:</b> (0.2,PI)<br>
<b>Default:</b> 0.0872 (about 5 degrees in radians)
@see projectionDistance projectionMode
*/
NxReal projectionAngle;
/**
\brief This is a combination of the bits defined by ::NxRevoluteJointFlag.
<b>Default:</b> 0
@see NxRevoluteJointFlag
*/
NxU32 flags;
/**
\brief use this to enable joint projection
<b>Default:</b> NX_JPM_NONE
@see NxJointProjectionMode projectionDistance projectionAngle NxRevoluteJoint.setProjectionMode()
*/
NxJointProjectionMode projectionMode;
/**
\brief constructor sets to default.
*/
NX_INLINE NxRevoluteJointDesc(); 
/**
\brief (re)sets the structure to the default. 
\param[in] fromCtor Avoid redundant work if called from constructor.
*/
NX_INLINE void setToDefault(bool fromCtor = false);

/**
\brief Returns true if the descriptor is valid.

\return true if the current settings are valid
*/
NX_INLINE bool isValid() const;

```
<Overlap Ratio: 0.9871567759078831>

---

--- 131 --
Question ID: 3177db2380bfca5943a38670efaaf8a3cf546e4a_25
Original Code:
```
void dwc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes)
{
	u32 __iomem *fifo = hsotg->regs + HCFIFO(0);
	u32 *data_buf = (u32 *)dest;
	int word_count = (bytes + 3) / 4;
	int i;

	/*
	 * Todo: Account for the case where dest is not dword aligned. This
	 * requires reading data from the FIFO into a u32 temp buffer, then
	 * moving it into the data buffer.
	 */

	dev_vdbg(hsotg->dev, "%s(%p,%p,%d)\n", __func__, hsotg, dest, bytes);

	for (i = 0; i < word_count; i++, data_buf++)
		*data_buf = readl(fifo);
}
```


Overlapping Code:
```
wc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes)
{
u32 __iomem *fifo = hsotg->regs + HCFIFO(0);
u32 *data_buf = (u32 *)dest;
int word_count = (bytes + 3) / 4;
int i;
/*
* Todo: Account for the case where dest is not dword aligned. This
* requires reading data from the FIFO into a u32 temp buffer, then
* moving it into the data buffer.
*/
dev_vdbg(hsotg->dev, "%s(%p,%p,%d)\n", __func__, hsotg, dest, bytes);
for (i = 0; i < word_count; i++, data_buf++)
*
```
<Overlap Ratio: 0.93812375249501>

---

--- 132 --
Question ID: 064637f213f29f9973154dac29c19c0f46d1a8e4_4
Original Code:
```
void SND_startPlay_2ADPCM(const u8 *sample, const u32 len, const u16 channel, const u8 loop)
{
    vu8 *pb;
    u8 status;
    u16 ch;
    u32 addr;

    // disable ints when requesting Z80 bus
    SYS_disableInts();

    // load the appropriate driver if not already done
    Z80_loadDriver(Z80_DRIVER_2ADPCM, TRUE);

    Z80_requestBus(TRUE);

    // point to Z80 status
    pb = (u8 *) Z80_DRV_STATUS;
    // get status
    status = *pb;

    // auto channel ?
    if (channel == SOUND_PCM_CH_AUTO)
    {
        // scan for first free channel
        ch = 0;

        while ((ch < 2) && (status & (Z80_DRV_STAT_PLAYING << ch))) ch++;

        // if all channel busy we use the first
        if (ch == 2) ch = 0;
    }
    // we use specified channel
    else ch = channel;

    // point to Z80 base parameters
    pb = (u8 *) (Z80_DRV_PARAMS + (ch * 4));

    addr = (u32) sample;
    // sample address (128 bytes aligned)
    pb[0] = addr >> 7;
    pb[1] = addr >> 15;
    // sample length (128 bytes aligned)
    pb[2] = len >> 7;
    pb[3] = len >> 15;

    // point to Z80 command
    pb = (u8 *) Z80_DRV_COMMAND;
    // play command
    *pb |= (Z80_DRV_COM_PLAY << ch);

    // point to Z80 status
    pb = (u8 *) Z80_DRV_STATUS;

    // loop flag in status
    if (loop) pb[1] |= (Z80_DRV_STAT_PLAYING << ch);
    else pb[1] &= ~(Z80_DRV_STAT_PLAYING << ch);

    Z80_releaseBus();

    // re-enable ints
    SYS_enableInts();
}
```


Overlapping Code:
```
tPlay_2ADPCM(const u8 *sample, const u32 len, const u16 channel, const u8 loop)
{
vu8 *pb;
u8 status;
u16 ch;
u32 addr;
// disable ints when requesting Z80 bus
SYS_disableInts();
// load the appropriate driver if not already done
Z80_loadDriver(Z80_DRIVER_2ADPCM, TRUE);
Z80_requestBus(TRUE);
// point to Z80 status
pb = (u8 *) Z80_DRV_STATUS;
// get status
status = *pb;
// auto channel ?
if (channel == SOUND_PCM_CH_AUTO)
{
// scan for first free channel
ch = 0;
while ((ch < 2) && (status & (Z80_DRV_STAT_PLAYING << ch))) ch++;
// if all channel busy we use the first
if (ch == 2) ch = 0;
}
// we use specified channel
else ch = channel;
// point to Z80 base parameters
pb = (u8 *) (Z80_DRV_PARAMS + (ch * 4));
addr = (u32) sample;
// sample address (128 bytes aligned)
pb[0] = addr >> 7;
pb[1] = addr >> 15;
// sample length (128 bytes aligned)
pb[2] = len >> 7;
pb[3] = len >> 15;
// point to Z80 command
pb = (u8 *) Z80_DRV_COMMAND;
// play command
*pb |= (Z80_DRV_COM_PLAY << ch);
// point to Z80 status
pb = (u8 *) Z80_DRV_STATUS;
// loop flag in status
if (loop) pb[1] |= (Z80_DRV_STAT_PLAYING << ch);
else pb[1] &= ~(Z80_DRV_STAT_PLAYING << ch);
Z80_releaseBus();
// re-enable ints
SYS_enableInts();
}
```
<Overlap Ratio: 0.9893790849673203>

---

--- 133 --
Question ID: 8bf7806f55dbbb31e772af2f59d20027f440e235_0
Original Code:
```
int
main()
{
	int i;
	sigset_t set, oset, saveset;

	signal(SIGINT, handler);

	sigemptyset(&set);
	sigaddset(&set, SIGINT);

	sigprocmask(SIG_UNBLOCK, &set, &oset);

	sigprocmask(SIG_BLOCK, &set, &saveset);

	while (1) {
/*
		sigset_t tmpset;
		sigprocmask(SIG_SETMASK, &saveset, &tmpset);
		pause();
		sigprocmask(SIG_SETMASK, &tmpset, NULL);

		ATOMIC:
*/
		sigsuspend(&saveset);
		for (i=0;i<5;++i) {
			write(1, "x", 1);
			sleep(1);
		}
		write(1, "\n", 1);
		fflush(stdout);
	}

	sigprocmask(SIG_SETMASK, &oset, NULL);

	return 0;
}
```


Overlapping Code:
```
set;
signal(SIGINT, handler);
sigemptyset(&set);
sigaddset(&set, SIGINT);
sigprocmask(SIG_UNBLOCK, &set, &oset);
sigprocmask(SIG_BLOCK, &set, &saveset);
while (1) {
/*
sigset_t tmpset;
sigprocmask(SIG_SETMASK, &saveset, &tmpset);
pause();
sigprocmask(SIG_SETMASK, &tmpset, NULL);
ATOMIC:
*/
sigsuspend(&saveset);
for (i=0;i<5;++i) {
write(1, "x", 1);
sleep(1);
}
write(1, "\n", 1);
fflush(stdout);
}
sigprocmask(SIG_SETMASK, &oset, NULL);
return 0;
}
```
<Overlap Ratio: 0.9109311740890689>

---

--- 134 --
Question ID: 274676231fb81d16cf84d6e2c5deb24c9fef248b_484
Original Code:
```
static PyObject *unpack_py_lsa_QueryInfoPolicy2_args_out(struct lsa_QueryInfoPolicy2 *r)
{
	PyObject *result;
	PyObject *py_info;
	if (*r->out.info == NULL) {
		py_info = Py_None;
		Py_INCREF(py_info);
	} else {
		py_info = py_import_lsa_PolicyInformation(*r->out.info, r->in.level, *r->out.info);
		if (py_info == NULL) {
			return NULL;
		}
	}
	result = py_info;
	if (NT_STATUS_IS_ERR(r->out.result)) {
		PyErr_SetNTSTATUS(r->out.result);
		return NULL;
	}

	return result;
}
```


Overlapping Code:
```
npack_py_lsa_QueryInfoPolicy2_args_out(struct lsa_QueryInfoPolicy2 *r)
{
PyObject *result;
PyObject *py_info;
if (*r->out.info == NULL) {
py_info = Py_None;
Py_INCREF(py_info);
} else {
py_info = py_import_lsa_PolicyInformation(*r->out.info, r->in.level, *r->out.info);
if (py_info == NULL) {
return NULL;
}
}
result = py_info;
if (NT_STATUS_IS_ERR(r->out.result)) {
PyErr_SetNTSTATUS(r->out.result);
return NULL;
}
return result;
}
```
<Overlap Ratio: 0.96>

---

--- 135 --
Question ID: c5a2bd637231fbe5e0eee81526f7a45f4c6d506b_3
Original Code:
```
void fsof_zk_remove_listener(const char *path,watcher_fn watcher) {
    struct provider_callback *cb = NULL;
    struct map_object *object_val = NULL;

    if (sm_exists(g_provider_map,path)) { //exist
        sm_get(g_provider_map,path,&object_val);
        if (object_val != NULL) {
            cb = (struct provider_callback*)object_val->ptr;
            if (cb != NULL && cb->watcher_cb == watcher) {
                object_val->status = 0;
            }
        }
    }
}
```


Overlapping Code:
```
listener(const char *path,watcher_fn watcher) {
struct provider_callback *cb = NULL;
struct map_object *object_val = NULL;
if (sm_exists(g_provider_map,path)) { //exist
sm_get(g_provider_map,path,&object_val);
if (object_val != NULL) {
cb = (struct provider_callback*)object_val->ptr;
if (cb != NULL && cb->watcher_cb == watcher) {
object_val->status
```
<Overlap Ratio: 0.9138381201044387>

---

--- 136 --
Question ID: b0b2e2d53b216c9b895a61bb1bc55b9235cbdd9c_19
Original Code:
```
static int
fd_attach(device_t dev)
{
	struct	fd_data *fd;

	fd = device_get_softc(dev);
#ifdef GONE_IN_5
	fd->clonetag = EVENTHANDLER_REGISTER(dev_clone, fd_clone, fd, 1000);
#endif
	fd->masterdev = make_dev(&fd_cdevsw, fd->fdu << 6,
				 UID_ROOT, GID_OPERATOR, 0640, "fd%d", fd->fdu);
	fd->masterdev->si_drv1 = fd;
#ifdef GONE_IN_5
	{
	int i;
	for (i = 0; i < NUMDENS - 1; i++)
		fd->clonedevs[i] = NODEV;
	}
#endif
	fd->device_stats = devstat_new_entry(device_get_name(dev), 
			  device_get_unit(dev), 0, DEVSTAT_NO_ORDERED_TAGS,
			  DEVSTAT_TYPE_FLOPPY | DEVSTAT_TYPE_IF_OTHER,
			  DEVSTAT_PRIORITY_FD);
	return (0);
}
```


Overlapping Code:
```
e_t dev)
{
struct fd_data *fd;
fd = device_get_softc(dev);
#ifdef GONE_IN_5
fd->clonetag = EVENTHANDLER_REGISTER(dev_clone, fd_clone, fd, 1000);
#endif
fd->masterdev = make_dev(&fd_cdevsw, fd->fdu << 6,
UID_ROOT, GID_OPERATOR, 0640, "fd%d", fd->fdu);
fd->masterdev->si_drv1 = fd;
#ifdef GONE_IN_5
{
int i;
for (i = 0; i < NUMDENS - 1; i++)
fd->clonedevs[i] = NODEV;
}
#endif
fd->device_stats = devstat_new_entry(device_get_name(dev), 
device_get_unit(dev), 0, DEVSTAT_NO_ORDERED_TAGS,
DEVSTAT_TYPE_FLOPPY | DEVSTAT_TYPE_IF_OTHER,
DEVSTAT_PRIORITY_FD)
```
<Overlap Ratio: 0.9306260575296108>

---

--- 137 --
Question ID: 8dd031bc69b641cb3c7c7c94759b5f595a5acb1a_21
Original Code:
```
static int
bsd_wireless_event_init(void *priv)
{
	struct bsd_driver_data *drv = priv;
	int s;

	drv->wext_sock = -1;

	s = socket(PF_ROUTE, SOCK_RAW, 0);
	if (s < 0) {
		perror("socket(PF_ROUTE,SOCK_RAW)");
		return -1;
	}
	eloop_register_read_sock(s, bsd_wireless_event_receive, drv, NULL);
	drv->wext_sock = s;

	return 0;
}
```


Overlapping Code:
```
t
bsd_wireless_event_init(void *priv)
{
struct bsd_driver_data *drv = priv;
int s;
drv->wext_sock = -1;
s = socket(PF_ROUTE, SOCK_RAW, 0);
if (s < 0) {
perror("socket(PF_ROUTE,SOCK_RAW)");
return -1;
}
eloop_register_read_sock(s, bsd_wireless_event_receive, drv, NULL);
drv->wext_sock = s;
return 0;

```
<Overlap Ratio: 0.967741935483871>

---

--- 138 --
Question ID: c5d9e9ac3fffa8b9aa43f6807169bcdbcd970e11_74
Original Code:
```
int
SetCharTableEsc (unsigned char *table, const char * map, char * escapes)
/* [HGM] moved here from winboard.c because of its general usefulness */
/*       Basically a safe strcpy that uses the last character as King */
{
    int result = FALSE; int NrPieces;
    unsigned char partner[EmptySquare];

    if( map != NULL && (NrPieces=ptclen(map, escapes)) <= (int) EmptySquare
                    && NrPieces >= 12 && !(NrPieces&1)) {
        int i, ii, offs, j = 0; /* [HGM] Accept even length from 12 to 88 */

        for( i=0; i<(int) EmptySquare; i++ ) table[i] = '.';
        for( i=offs=0; i<NrPieces/2-1; i++ ) {
            char *p, c=0;
            if(map[j] == '/') offs = WhitePBishop - i, j++;
            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];
            table[i+offs] = map[j++];
            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);
            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;
            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;
        }
        table[(int) WhiteKing]  = map[j++];
        for( ii=offs=0; ii<NrPieces/2-1; ii++ ) {
            char *p, c=0;
            if(map[j] == '/') offs = WhitePBishop - ii, j++;
            i = WHITE_TO_BLACK ii;
            if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];
            table[i+offs] = map[j++];
            if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);
            if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;
            if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;
        }
        table[(int) BlackKing]  = map[j++];


        if(*escapes) { // set up promotion pairing
            for( i=0; i<(int) EmptySquare; i++ ) promoPartner[i] = (i%BlackPawn < 11 ? i + 11 : i%BlackPawn < 22 ? i - 11 : i); // default
            // pieceToChar entirely filled, so we can look up specified partners
            for(i=0; i<EmptySquare; i++) { // adjust promotion pairing
                int c = table[i];
                if(c == '^' || c == '-') { // has specified partner
                    int p;
                    for(p=0; p<EmptySquare; p++) if(table[p] == partner[i]) break;
                    if(c == '^') table[i] = '+';
                    if(p < EmptySquare) {
                        if(promoPartner[promoPartner[p]] == p) promoPartner[promoPartner[p]] = promoPartner[p]; // divorce old partners
                        if(promoPartner[promoPartner[i]] == i) promoPartner[promoPartner[i]] = promoPartner[i];
                        promoPartner[p] = i, promoPartner[i] = p; // and marry this couple
                    }
                } else if(c == '*') {
                    table[i] = partner[i];
                    promoPartner[i] = (i < BlackPawn ? WhiteTokin : BlackTokin); // promotes to Tokin
                }
            }
        }

        result = TRUE;
    }

    return result;
}
```


Overlapping Code:
```
st char * map, char * escapes)
/* [HGM] moved here from winboard.c because of its general usefulness */
/* Basically a safe strcpy that uses the last character as King */
{
int result = FALSE; int NrPieces;
unsigned char partner[EmptySquare];
if( map != NULL && (NrPieces=ptclen(map, escapes)) <= (int) EmptySquare
&& NrPieces >= 12 && !(NrPieces&1)) {
int i, ii, offs, j = 0; /* [HGM] Accept even length from 12 to 88 */
for( i=0; i<(int) EmptySquare; i++ ) table[i] = '.';
for( i=offs=0; i<NrPieces/2-1; i++ ) {
char *p, c=0;
if(map[j] == '/') offs = WhitePBishop - i, j++;
if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];
table[i+offs] = map[j++];
if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);
if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;
if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;
}
table[(int) WhiteKing] = map[j++];
for( ii=offs=0; ii<NrPieces/2-1; ii++ ) {
char *p, c=0;
if(map[j] == '/') offs = WhitePBishop - ii, j++;
i = WHITE_TO_BLACK ii;
if(*escapes && (map[j] == '*' || map[j] == '-' || map[j] == '^')) c = map[j++];
table[i+offs] = map[j++];
if(p = strchr(escapes, map[j])) j++, table[i+offs] += 64*(p - escapes + 1);
if(c) partner[i+offs] = table[i+offs], table[i+offs] = c;
if(*escapes && map[j] == '=') pieceNickName[i+offs] = map[++j], j++;
}
table[(int) BlackKing] = map[j++];
if(*escapes) { // set up promotion pairing
for( i=0; i<(int) EmptySquare; i++ ) promoPartner[i] = (i%BlackPawn < 11 ? i + 11 : i%BlackPawn < 22 ? i - 11 : i); // default
// pieceToChar entirely filled, so we can look up specified partners
for(i=0; i<EmptySquare; i++) { // adjust promotion pairing
int c = table[i];
if(c == '^' || c == '-') { // has specified partner
int p;
for(p=0; p<EmptySquare; p++) if(table[p] == partner[i]) break;
if(c == '^') table[i] = '+';
if(p < EmptySquare) {
if(promoPartner[promoPartner[p]] == p) promoPartner[promoPartner[
```
<Overlap Ratio: 0.9601181683899557>

---

--- 139 --
Question ID: bb9a32ab07be613c9f989408086e26d9d235e0f5_1
Original Code:
```
static float DistSqr(Vec2 lhs, Vec2 rhs)
	{
		float offsetX = lhs.x-rhs.x;
		float offsetY = lhs.y-rhs.y;
		return offsetX*offsetX + offsetY*offsetY;
	}
```


Overlapping Code:
```
 offsetX = lhs.x-rhs.x;
float offsetY = lhs.y-rhs.
```
<Overlap Ratio: 0.3472222222222222>

---

--- 140 --
Question ID: 68a3e9ea7b63fb29c55c822ea658d8d0c6725f7d_0
Original Code:
```
interface QRViewController : UIViewController 
{
	//passwordmatrixAppDelegate *appDelegate;

	//IBOutlet UIBarButtonItem *doneButton;
	IBOutlet UIButton *doneButton;
    IBOutlet UITextView *textView;
    IBOutlet UIImageView *imageViewQR;
	//IBOutlet UIWebView *webView;
	id appDelegate;
    IBOutlet UITextView *appTextView;
    IBOutlet UIButton *appImageButton;
    IBOutlet UIButton *appTextButton;
}
```


Overlapping Code:
```
: UIViewController 
{
//passwordmatrixAppDelegate *appDelegate;
//IBOutlet UIBarButtonItem *doneButton;
IBOutlet UIButton *doneButton;
IBOutlet UITextView *textView;
IBOutlet UIImageView *imageViewQR;
//IBOutlet UIWebView *webView;
id appDelegate;
IBOutlet UITextView *appTextView;
IBOutlet UIButton *appImageButton;
IBOutlet UIButton *appTextButton;
```
<Overlap Ratio: 0.9234828496042217>

---

--- 141 --
Question ID: 6560d8ac7fded798ad942b02b89a1da387353a3b_189
Original Code:
```
int pcrs_execute_list(pcrs_job *joblist , char *subject ,
                      size_t subject_length , char **result ,
                      size_t *result_length ) 
{ pcrs_job *job ;
  char *old ;
  char *new ;
  int hits ;
  int total_hits ;

  {
  {
# 750
  old = subject;
# 751
  (*result_length) = subject_length;
# 752
  total_hits = 0;
# 752
  hits = total_hits;
# 754
  job = joblist;
  }
# 754
  while ((unsigned int )job != (unsigned int )((void *)0)) {
    {
# 756
    hits = pcrs_execute(job, old, (*result_length), & new, result_length);
    }
# 758
    if ((unsigned int )old != (unsigned int )subject) {
      {
# 758
      free((void *)old);
      }
    }
# 760
    if (hits < 0) {
# 762
      return (hits);
    } else {
      {
# 766
      total_hits += hits;
# 767
      old = new;
      }
    }
    {
# 754
    job = job->next;
    }
  }
  {
# 771
  (*result) = new;
  }
# 772
  return (total_hits);
}
}
```


Overlapping Code:
```
 char *subject ,
size_t subject_length , char **result ,
size_t *result_length ) 
{ pcrs_job *job ;
char *old ;
char *new ;
int hits ;
int total_hits ;
{
{
# 750
old = subject;
# 751
(*result_length) = subject_length;
# 752
total_hits = 0;
# 752
hits = total_hits;
# 754
job = joblist;
}
# 754
while ((unsigned int )job != (unsigned int )((void *)0)) {
{
# 756
hits = pcrs_execute(job, old, (*result_length), & new, result_length);
}
# 758
if ((unsigned int )old != (unsigned int )subject) {
{
# 758
free((void *)old);
}
}
# 760
if (hits < 0) {
# 762
return (hits);
} else {
{
# 766
total_hits += hits;
# 767
old = new;
}
}
{
# 754
job = job->next;
}
}
{
# 771
(*result) = new;
}
# 772
return (total_
```
<Overlap Ratio: 0.9320905459387483>

---

--- 142 --
Question ID: 3204f412cad8c32cca0fdc81ad10696218062f5d_11
Original Code:
```
int amiga_serial_console_wait_key(struct console *co)
{
    int ch;

    while (!(amiga_custom.intreqr & IF_RBF))
	barrier();
    ch = amiga_custom.serdatr & 0xff;
    /* clear the interrupt, so that another character can be read */
    amiga_custom.intreq = IF_RBF;
    return ch;
}
```


Overlapping Code:
```
amiga_serial_console_wait_key(struct console *co)
{
int ch;
while (!(amiga_custom.intreqr & IF_RBF))
barrier();
ch = amiga_custom.serdatr & 0xff;
/* clear the interrupt, so that another character can be read */
amiga_custom.intreq = IF_RBF;
return ch
```
<Overlap Ratio: 0.9727626459143969>

---

--- 143 --
Question ID: b1dd632eddc6c6ff8b487a9e8e30e47ab5d645c5_1094
Original Code:
```
static inline void hri_sdhc_write_MC1R_RSTN_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	SDHC_CRITICAL_SECTION_ENTER();
	tmp = ((Sdhc *)hw)->MC1R.reg;
	tmp &= ~SDHC_MC1R_RSTN;
	tmp |= value << SDHC_MC1R_RSTN_Pos;
	((Sdhc *)hw)->MC1R.reg = tmp;
	SDHC_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
e void hri_sdhc_write_MC1R_RSTN_bit(const void *const hw, bool value)
{
uint8_t tmp;
SDHC_CRITICAL_SECTION_ENTER();
tmp = ((Sdhc *)hw)->MC1R.reg;
tmp &= ~SDHC_MC1R_RSTN;
tmp |= value << SDHC_MC1R_RSTN_Pos;
((Sdhc *)hw)->MC1R.reg = tmp;
SDHC_CRITICAL_SECTION_LEAVE();
}
```
<Overlap Ratio: 0.9571428571428572>

---

--- 144 --
Question ID: d0d5c4dbe09739450255955c46046a86d4433ac4_32
Original Code:
```
static ssize_t altr_edac_a10_device_trig(struct file *file,
					 const char __user *user_buf,
					 size_t count, loff_t *ppos)
{
	struct edac_device_ctl_info *edac_dci = file->private_data;
	struct altr_edac_device_dev *drvdata = edac_dci->pvt_info;
	const struct edac_device_prv_data *priv = drvdata->data;
	void __iomem *set_addr = (drvdata->base + priv->set_err_ofst);
	unsigned long flags;
	u8 trig_type;

	if (!user_buf || get_user(trig_type, user_buf))
		return -EFAULT;

	local_irq_save(flags);
	if (trig_type == ALTR_UE_TRIGGER_CHAR)
		writel(priv->ue_set_mask, set_addr);
	else
		writel(priv->ce_set_mask, set_addr);
	/* Ensure the interrupt test bits are set */
	wmb();
	local_irq_restore(flags);

	return count;
}
```


Overlapping Code:
```
c ssize_t altr_edac_a10_device_trig(struct file *file,
const char __user *user_buf,
size_t count, loff_t *ppos)
{
struct edac_device_ctl_info *edac_dci = file->private_data;
struct altr_edac_device_dev *drvdata = edac_dci->pvt_info;
const struct edac_device_prv_data *priv = drvdata->data;
void __iomem *set_addr = (drvdata->base + priv->set_err_ofst);
unsigned long flags;
u8 trig_type;
if (!user_buf || get_user(trig_type, user_buf))
return -EFAULT;
local_irq_save(flags);
if (trig_type == ALTR_UE_TRIGGER_CHAR)
writel(priv->ue_set_mask, set_addr);
else
writel(priv->ce_set_mask, set_addr);
/* Ensure the interrupt test bits are set */
wmb();
local_irq_re
```
<Overlap Ratio: 0.9507959479015919>

---

--- 145 --
Question ID: 8bc1483f94c5cd85b01f91f0f65028b682d2fd42_10
Original Code:
```
void CheckWaterJump (void)
{
	vec3_t	spot;
	int		cont;
	vec3_t	flatforward;

	if (pmove.waterjumptime)
		return;

	// ZOID, don't hop out if we just jumped in
	if (pmove.velocity[2] < -180)
		return; // only hop out if we are moving up

	// see if near an edge
	flatforward[0] = forward[0];
	flatforward[1] = forward[1];
	flatforward[2] = 0;
	VectorNormalize (flatforward);

	VectorMA (pmove.origin, 24, flatforward, spot);
	spot[2] += 8;
	cont = PM_PointContents (spot);
	if (cont != CONTENTS_SOLID)
		return;
	spot[2] += 24;
	cont = PM_PointContents (spot);
	if (cont != CONTENTS_EMPTY)
		return;
	// jump out of water
	VectorScale (flatforward, 50, pmove.velocity);
	pmove.velocity[2] = 310;
	pmove.waterjumptime = 2;	// safety net
	pmove.oldbuttons |= BUTTON_JUMP;	// don't jump again until released
}
```


Overlapping Code:
```
 CheckWaterJump (void)
{
vec3_t spot;
int cont;
vec3_t flatforward;
if (pmove.waterjumptime)
return;
// ZOID, don't hop out if we just jumped in
if (pmove.velocity[2] < -180)
return; // only hop out if we are moving up
// see if near an edge
flatforward[0] = forward[0];
flatforward[1] = forward[1];
flatforward[2] = 0;
VectorNormalize (flatforward);
VectorMA (pmove.origin, 24, flatforward, spot);
spot[2] += 8;
cont = PM_PointContents (spot);
if (cont != CONTENTS_SOLID)
return;
spot[2] += 24;
cont = PM_PointContents (spot);
if (cont != CONTENTS_EMPTY)
return;
// jump out of water
VectorScale (flatforward, 50, pmove.velocity);
pmove.velocity[2] = 310;
pmove.waterjumptime = 2; // safety net
pmove.oldbuttons |= BUTTON_JUMP; // don't jump again until released

```
<Overlap Ratio: 0.9934980494148244>

---

--- 146 --
Question ID: 9584c6ae447c423f30992d5b21ce46db674c182e_5
Original Code:
```
static bool _table_Iridium(mavlink_message_t * msg)
{
	if (NULL == iridium_task_handle || NULL == iridium_queue_handle)
		return false;

	_ir_divider_t * const entry = _ir_divider_find_entry(msg->msgid);

	if (NULL == entry)
		return false;

	if (0 == entry->divider)
		return false;

	if (entry->counter + 1 >= entry->divider)
	{
		entry->counter = 0;
		return true;
	}
	else
	{
		entry->counter++;
		return false;
	}

	/*
	 * 0+1 = 1 >= 1 => true
	 * 0+1 = 1 >= 1 => true
	 *
	 * 0+1 = 1 >= 2 => false
	 * 1+1 = 2 >= 2 => true
	 * 0+1 = 1 >= 2 => false
	 *
	 * 0+1 = 1 >= 3 => false
	 * 1+1 = 2 >= 3 => false
	 * 2+1 = 3 >= 3 => true
	 * 0+1 = 1 >= 3 => false
	 */
}
```


Overlapping Code:
```
table_Iridium(mavlink_message_t * msg)
{
if (NULL == iridium_task_handle || NULL == iridium_queue_handle)
return false;
_ir_divider_t * const entry = _ir_divider_find_entry(msg->msgid);
if (NULL == entry)
return false;
if (0 == entry->divider)
return false;
if (entry->counter + 1 >= entry->divider)
{
entry->counter = 0;
return true;
}
else
{
entry->counter++;
return false;
}
/*
* 0+1 = 1 >= 1 => true
* 0+1 = 1 >= 1 => true
*
* 0+1 = 1 >= 2 => false
* 1+1 = 2 >= 2 => true
* 0+1 = 1 >= 2 => false
*
* 0+1 = 1 >= 3 => false
* 1+1 = 2 >= 3 => false
* 2+1 = 3 >= 3 => true
* 0+1 = 1 >= 3 => false
*/

```
<Overlap Ratio: 0.9771986970684039>

---

--- 147 --
Question ID: d6464492451203d116118e70df3ddfa4c7451027_44
Original Code:
```
void WM_recover_last_session(bContext *C, ReportList *reports)
{
  char filepath[FILE_MAX];

  BLI_make_file_string("/", filepath, BKE_tempdir_base(), BLENDER_QUIT_FILE);
  /* if reports==NULL, it's called directly without operator, we add a quick check here */
  if (reports || BLI_exists(filepath)) {
    G.fileflags |= G_FILE_RECOVER;

    wm_file_read_opwrap(C, filepath, reports, true);

    G.fileflags &= ~G_FILE_RECOVER;

    /* XXX bad global... fixme */
    Main *bmain = CTX_data_main(C);
    if (BKE_main_blendfile_path(bmain)[0] != '\0') {
      G.file_loaded = 1; /* prevents splash to show */
    }
    else {
      G.relbase_valid = 0;
      G.save_over = 0; /* start with save preference untitled.blend */
    }
  }
}
```


Overlapping Code:
```
ssion(bContext *C, ReportList *reports)
{
char filepath[FILE_MAX];
BLI_make_file_string("/", filepath, BKE_tempdir_base(), BLENDER_QUIT_FILE);
/* if reports==NULL, it's called directly without operator, we add a quick check here */
if (reports || BLI_exists(filepath)) {
G.fileflags |= G_FILE_RECOVER;
wm_file_read_opwrap(C, filepath, reports, true);
G.fileflags &= ~G_FILE_RECOVER;
/* XXX bad global... fixme */
Main *bmain = CTX_data_main(C);
if (BKE_main_blendfile_path(bmain)[0] != '\0') {
G.file_loaded = 1; /* prevents splash to show */
}
else {
G.relbase_valid = 0;
G.save_over = 0; /* start with save preference 
```
<Overlap Ratio: 0.9309309309309309>

---

--- 148 --
Question ID: 82d533fd827037098d78ec478ad72bc07bcf3654_14
Original Code:
```
int ReadEEProm(unsigned char Line, USHORT Add)
{
  ULONG SendID ;
  ULONG RecID ;
  char SendLen ;
  char SendData[8] ;
  char RecLen ;
  char RecData[8] ;
  int i,j ;
  
  SendID = BuildCANId(0,0,0,1,Line,Add,0) ;
  
  for (i=0;i<512;i++) {
    /* Request senden */
    if (i%32==0) {
      printf (".") ;
      fflush(stdout);
    } ;
    SendLen = 4 ;
    SendData[0] = READ_VAR ;
    SendData[1] = (unsigned char)(i&0xFF) ;
    SendData[2] = (unsigned char)(i>>8) ;
    SendCANMessage (SendID,SendLen,SendData) ;
    /* Daten empfangen */
    for (j=0;j<10;j++) {
      ReceiveCANMessage (&RecID,&RecLen,RecData) ;
      if ((MatchAddress(RecID,0,1))&&(MatchSrcAddress(RecID,Line,Add))&&(RecData[0]==READ_VAR|SUCCESS)) break ;
    } ;
    if (j>=10) { 
      printf ("Did not receive answer from %d %d\n",Line,Add) ;
      return (-1);
    } ;
    FileBuffer[i] = RecData[3] ;
  }
  FileSize = 512 ;
  return (0) ;
}
```


Overlapping Code:
```
om(unsigned char Line, USHORT Add)
{
ULONG SendID ;
ULONG RecID ;
char SendLen ;
char SendData[8] ;
char RecLen ;
char RecData[8] ;
int i,j ;

SendID = BuildCANId(0,0,0,1,Line,Add,0) ;

for (i=0;i<512;i++) {
/* Request senden */
if (i%32==0) {
printf (".") ;
fflush(stdout);
} ;
SendLen = 4 ;
SendData[0] = READ_VAR ;
SendData[1] = (unsigned char)(i&0xFF) ;
SendData[2] = (unsigned char)(i>>8) ;
SendCANMessage (SendID,SendLen,SendData) ;
/* Daten empfangen */
for (j=0;j<10;j++) {
ReceiveCANMessage (&RecID,&RecLen,RecData) ;
if ((MatchAddress(RecID,0,1))&&(MatchSrcAddress(RecID,Line,Add))&&(RecData[0]==READ_VAR|SUCCESS)) break ;
} ;
if (j>=10) { 
printf ("Did not receive answer from %d %d\n",Line,Add) ;
return (-1);
} ;
FileBuffer[i] = RecData[
```
<Overlap Ratio: 0.9375>

---

--- 149 --
Question ID: 40c893488931ccacb1d9056fb6e45fa75aab5224_3
Original Code:
```
void mouse_cursor_get_rel(int *x, int *y, int *z)
{
	mouse_cursor_poll();

	if (x) {
		*x = mouse_rel_x / 256;
		mouse_rel_x = 0;
	}
	if (y) {
		*y = mouse_rel_y / 256;
		mouse_rel_y = 0;
	}
	if (z) {
		*z = mouse_rel_z / 256;
		mouse_rel_z = 0;
	}
}
```


Overlapping Code:
```
t_rel(int *x, int *y, int *z)
{
mouse_cursor_poll();
if (x) {
*x = mouse_rel_x / 256;
mouse_rel_x = 0;
}
if (y) {
*y = mouse_rel_y / 256;
mouse_rel_y = 0;
}
if (z) {
*z = mouse_rel_z / 256;
mouse_rel_
```
<Overlap Ratio: 0.8695652173913043>

---

--- 150 --
Question ID: 3055e07590dfce27df1a4f2023212eece937e7e7_10
Original Code:
```
void printBucket(pkBucket* bucket){
	fprintf(stderr, "------------------------------------------------------------\n");
	fprintf(stderr, "local_depth(%"PRIu32"), current_subBuckets(%"PRIu32")\n", bucket->local_depth, bucket->current_subBuckets);
	uint64_t i;
	uint32_t j;
	for (i = 0 ; i < bucket->current_subBuckets ; i++) { //
		Key key = bucket->key_buckets[i]->key;
		uint64_t current_entries = bucket->key_buckets[i]->current_entries;
		fprintf(stderr, "\tSubBucket(%zd): key: %zd, current_entries: %zd\n", i, key, current_entries);
		for (j = 0 ; j < current_entries ; j++) {
			uint64_t tid = bucket->key_buckets[i]->transaction_range[j].transaction_id;
			uint64_t rec_offset = bucket->key_buckets[i]->transaction_range[j].rec_offset;
			fprintf(stderr, "\t\ttid: %zd, offset :%zd\n", tid, rec_offset);
		}
	}
	fprintf(stderr, "------------------------------------------------------------\n");
}
```


Overlapping Code:
```
ucket(pkBucket* bucket){
fprintf(stderr, "------------------------------------------------------------\n");
fprintf(stderr, "local_depth(%"PRIu32"), current_subBuckets(%"PRIu32")\n", bucket->local_depth, bucket->current_subBuckets);
uint64_t i;
uint32_t j;
for (i = 0 ; i < bucket->current_subBuckets ; i++) { //
Key key = bucket->key_buckets[i]->key;
uint64_t current_entries = bucket->key_buckets[i]->current_entries;
fprintf(stderr, "\tSubBucket(%zd): key: %zd, current_entries: %zd\n", i, key, current_entries);
for (j = 0 ; j < current_entries ; j++) {
uint64_t tid = bucket->key_buckets[i]->transaction_range[j].transaction_id;
uint64_t rec_offset = bucket->key_buckets[i]->transaction_range[j].rec_offset;
fprintf(stderr, "\t\ttid: %zd, offset :%zd\n", tid, rec_offset);
}
}
fprintf(stderr, "------------------------------------------------------------\n");
}
```
<Overlap Ratio: 0.9874572405929305>

---

--- 151 --
Question ID: 16c292bda69912c2d8516b46bcb05fc9b750065d_0
Original Code:
```
Node Node_new(NodeFn f, void* arg) {
  Node node = mem_malloc(sizeof(struct NodeSt));
  node->run = f;
  node->arg = arg;
  return node;
}
```


Overlapping Code:
```
 = mem_malloc(sizeof(struct NodeSt));
node->run = 
```
<Overlap Ratio: 0.38461538461538464>

---

--- 152 --
Question ID: 4e2eeb4a272324779364b6b14a3d1fc27aa9b2a4_5
Original Code:
```
void irq_dis(int nr)
{
	unsigned int addr;
	unsigned char m;
	
	if (nr < 8)
		addr = A8259A_M + 1;
	else
	{
		addr = A8259A_S + 1;
		nr -= 8;
		if (nr > 7)
			panic("irq_dis: invalid irq number");
	}
	
	intr_disable();
	m  = inb(addr);
	m |= (1 << nr);
	outb(addr, m);
	intr_enable();
}
```


Overlapping Code:
```
 int addr;
unsigned char m;

if (nr < 8)
addr = A8259A_M + 1;
else
{
addr = A8259A_S + 1;
nr -= 8;
if (nr > 7)
panic("irq_dis: invalid irq number");
}

intr_disable();
m = inb(addr);
m |= (1 << nr);
o
```
<Overlap Ratio: 0.7662835249042146>

---

--- 153 --
Question ID: 32565320a2cd42784023fb271c6d7cbfeb520307_7
Original Code:
```
static void AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{ 
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = pdev->pClassData;
  
  if (req->wLength)
  {
    /* Prepare the reception of the buffer over EP0 */
    USBD_CtlPrepareRx (pdev,
                       haudio->control.data,                                  
                       req->wLength);    
    
    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
    haudio->control.len = req->wLength;          /* Set the request data length */
    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
  }
}
```


Overlapping Code:
```
AUDIO_REQ_SetCurrent(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{ 
USBD_AUDIO_HandleTypeDef *haudio;
haudio = pdev->pClassData;

if (req->wLength)
{
/* Prepare the reception of the buffer over EP0 */
USBD_CtlPrepareRx (pdev,
haudio->control.data, 
req->wLength); 

haudio->control.cmd = AUDIO_REQ_SET_CUR; /* Set the request value */
haudio->control.len = req->wLength; /* Set the request data length */
haudio->control.unit = HIBYTE(req->wIndex); /* Set the request target unit */

```
<Overlap Ratio: 0.9704142011834319>

---

--- 154 --
Question ID: f429cbe01b0e9a3c60177a077af85c7307667ca7_5
Original Code:
```
MI_CALL R_IndicationC1_Set_id(
    R_IndicationC1* self,
    MI_Uint32 x)
{
    ((MI_Uint32Field*)&self->id)->value = x;
    ((MI_Uint32Field*)&self->id)->exists = 1;
    return MI_RESULT_OK;
}
```


Overlapping Code:
```
ationC1* self,
MI_Uint32 x)
{
((MI_Uint32Field*)&self->id)->value = x;
((MI_Uint32Field*)&self->id)->exists = 1;
return MI_RESULT_OK;
}
```
<Overlap Ratio: 0.7803468208092486>

---

--- 155 --
Question ID: 3bdecabe855cffca5eb62cf0f97105260e1d24d9_73
Original Code:
```
static void expand(char *as ) 
{ register char *cs ;
  register char *sgpathp ;
  register char *oldcs ;
  struct stat stb ;
  char *tmp ;
  int tmp_0__ ;
  int tmp_1__ ;
  int tmp_2__ ;
  int tmp_3__ ;
  char *tmp_4__ ;
  int tmp_5__ ;

  {
// # 201
  if (globerr) {
// # 202
    return;
  }
  {
// # 203
  sgpathp = gpathp;
// # 204
  cs = as;
  }
// # 205
  if ((int )(*cs) == 126) {
// # 205
    if ((unsigned int )gpathp == (unsigned int )gpath) {
      {
// # 206
      addpath('~');
// # 207
      cs ++;
      }
// # 207
      while (1) {
        {
// # 207
        tmp_0__ = letter((*cs));
        }
// # 207
        if (! tmp_0__) {
          {
// # 207
          tmp_1__ = digit((*cs));
          }
// # 207
          if (! tmp_1__) {
// # 207
            if (! ((int )(*cs) == 45)) {
// # 207
              break;
            }
          }
        }
        {
// # 208
        tmp = cs;
// # 208
        cs ++;
// # 208
        addpath((*tmp));
        }
      }
// # 209
      if ((*cs)) {
// # 209
        if ((int )(*cs) == 47) {
          _L: 
// # 210
          if ((unsigned int )gpathp != (unsigned int )(gpath + 1)) {
            {
// # 211
            (*gpathp) = (char )0;
// # 212
            tmp_2__ = gethdir(gpath + 1);
            }
// # 212
            if (tmp_2__) {
              {
// # 213
              globerr = "Unknown user name after ~";
              }
            }
            {
// # 214
            strcpy((char */*   */)gpath,
                   (char/*const*/  */*   */)((char/*const*/  *)(gpath + 1)));
            }
          } else {
            {
// # 217
            strcpy((char */*   */)gpath,
                   (char/*const*/  */*   */)((char/*const*/  *)home));
            }
          }
          {
// # 218
          gpathp = strend(gpath);
          }
        }
      } else {
        goto _L;
      }
    }
  }
// # 221
  while (1) {
    {
// # 221
    tmp_5__ = any((int )(*cs), globchars);
    }
// # 221
    if (tmp_5__) {
// # 221
      break;
    }
// # 222
    if ((int )(*cs) == 0) {
// # 223
      if (globbed) {
        {
// # 225
        tmp_3__ = statext__inline((char/*const*/  *)gpath, & stb);
        }
// # 225
        if (tmp_3__ >= 0) {
          {
// # 226
          Gcat(gpath, "");
// # 227
          globcnt ++;
          }
        }
      } else {
        {
// # 224
        Gcat(gpath, "");
        }
      }
      goto endit;
    }
    {
// # 231
    tmp_4__ = cs;
// # 231
    cs ++;
// # 231
    addpath((*tmp_4__));
    }
  }
  {
// # 233
  oldcs = cs;
  }
// # 234
  while (1) {
// # 234
    if ((unsigned int )cs > (unsigned int )as) {
// # 234
      if (! ((int )(*cs) != 47)) {
// # 234
        break;
      }
    } else {
// # 234
      break;
    }
    {
// # 235
    cs --;
// # 235
    gpathp --;
    }
  }
// # 236
  if ((int )(*cs) == 47) {
    {
// # 237
    cs ++;
// # 237
    gpathp ++;
    }
  }
  {
// # 238
  (*gpathp) = (char )0;
  }
// # 239
  if ((int )(*oldcs) == 123) {
    {
// # 240
    execbrc(cs, (char *)0);
    }
// # 241
    return;
  }
  {
// # 243
  matchdir(cs);
  }
  endit: 
  {
// # 245
  gpathp = sgpathp;
// # 246
  (*gpathp) = (char )0;
  }
// # 247
  return;
}
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 156 --
Question ID: a5bddae798c536591ff5e3a6312b5122b8e1a99c_4
Original Code:
```
static void
sc_mcch_ModificationPeriod_r13_14_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
	td->free_struct    = asn_DEF_NativeEnumerated.free_struct;
	td->print_struct   = asn_DEF_NativeEnumerated.print_struct;
	td->ber_decoder    = asn_DEF_NativeEnumerated.ber_decoder;
	td->der_encoder    = asn_DEF_NativeEnumerated.der_encoder;
	td->xer_decoder    = asn_DEF_NativeEnumerated.xer_decoder;
	td->xer_encoder    = asn_DEF_NativeEnumerated.xer_encoder;
	td->uper_decoder   = asn_DEF_NativeEnumerated.uper_decoder;
	td->uper_encoder   = asn_DEF_NativeEnumerated.uper_encoder;
	td->aper_decoder   = asn_DEF_NativeEnumerated.aper_decoder;
	td->aper_encoder   = asn_DEF_NativeEnumerated.aper_encoder;
	td->compare        = asn_DEF_NativeEnumerated.compare;
	if(!td->per_constraints)
		td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
	td->elements       = asn_DEF_NativeEnumerated.elements;
	td->elements_count = asn_DEF_NativeEnumerated.elements_count;
     /* td->specifics      = asn_DEF_NativeEnumerated.specifics;	// Defined explicitly */
}
```


Overlapping Code:
```
oid
sc_mcch_ModificationPeriod_r13_14_inherit_TYPE_descriptor(asn_TYPE_descriptor_t *td) {
td->free_struct = asn_DEF_NativeEnumerated.free_struct;
td->print_struct = asn_DEF_NativeEnumerated.print_struct;
td->ber_decoder = asn_DEF_NativeEnumerated.ber_decoder;
td->der_encoder = asn_DEF_NativeEnumerated.der_encoder;
td->xer_decoder = asn_DEF_NativeEnumerated.xer_decoder;
td->xer_encoder = asn_DEF_NativeEnumerated.xer_encoder;
td->uper_decoder = asn_DEF_NativeEnumerated.uper_decoder;
td->uper_encoder = asn_DEF_NativeEnumerated.uper_encoder;
td->aper_decoder = asn_DEF_NativeEnumerated.aper_decoder;
td->aper_encoder = asn_DEF_NativeEnumerated.aper_encoder;
td->compare = asn_DEF_NativeEnumerated.compare;
if(!td->per_constraints)
td->per_constraints = asn_DEF_NativeEnumerated.per_constraints;
td->elements = asn_DEF_NativeEnumerated.elements;
td->elements_count = asn_DEF_NativeEnumerated.elements_count;
/* td->specifics = asn_DEF_NativeEnumerated.specifics; // Defined explicitly */
}
```
<Overlap Ratio: 0.991991991991992>

---

--- 157 --
Question ID: 7a0ea0473659e6113efcc4f9833ad5488d2c8a7a_4
Original Code:
```
static int udata_gyro_service_ioctl_cb(udata_type_e type, sensor_tag_e tag)
{
    (void)type;
    (void)tag;

    return 0;
}
```


Overlapping Code:
```
yro_service_ioctl_cb(udata_type_e type, sensor_tag_e tag)
{
(void)type;
(void)tag;
return 0
```
<Overlap Ratio: 0.8125>

---

--- 158 --
Question ID: 9acb263511e009facaffe836fa87a52cc6f866db_2
Original Code:
```
static int r_perfective_gerund(struct SN_env * z) { /* backwardmode */
    int among_var;
    z->ket = z->c; /* [, line 74 */
    if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((25166336 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; /* substring, line 74 */
    among_var = find_among_b(z, a_0, 9);
    if (!(among_var)) return 0;
    z->bra = z->c; /* ], line 74 */
    switch (among_var) { /* among, line 74 */
        case 1:
            {   int m1 = z->l - z->c; (void)m1; /* or, line 78 */
                if (z->c <= z->lb || z->p[z->c - 1] != 0xC1) goto lab1; /* literal, line 78 */
                z->c--;
                goto lab0;
            lab1:
                z->c = z->l - m1;
                if (z->c <= z->lb || z->p[z->c - 1] != 0xD1) return 0; /* literal, line 78 */
                z->c--;
            }
        lab0:
            {   int ret = slice_del(z); /* delete, line 78 */
                if (ret < 0) return ret;
            }
            break;
        case 2:
            {   int ret = slice_del(z); /* delete, line 85 */
                if (ret < 0) return ret;
            }
            break;
    }
    return 1;
}
```


Overlapping Code:
```
tatic int r_perfective_gerund(struct SN_env * z) { /* backwardmode */
int among_var;
z->ket = z->c; /* [, line 74 */
if (z->c <= z->lb || z->p[z->c - 1] >> 5 != 6 || !((25166336 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; /* substring, line 74 */
among_var = find_among_b(z, a_0, 9);
if (!(among_var)) return 0;
z->bra = z->c; /* ], line 74 */
switch (among_var) { /* among, line 74 */
case 1:
{ int m1 = z->l - z->c; (void)m1; /* or, line 78 */
if (z->c <= z->lb || z->p[z->c - 1] != 0xC1) goto lab1; /* literal, line 78 */
z->c--;
goto lab0;
lab1:
z->c = z->l - m1;
if (z->c <= z->lb || z->p[z->c - 1] != 0xD1) return 0; /* literal, line 78 */
z->c--;
}
lab0:
{ int ret = slice_del(z); /* delete, line 78 */
if (ret < 0) return ret;
}
break;
case 2:
{ int ret = slice_del(z); /* delete, line 85 */
if (ret < 0) return ret;
}
break;
}
return 1;
}
```
<Overlap Ratio: 0.9988207547169812>

---

--- 159 --
Question ID: 0952521785d1af0f4bedae9b78929238ad2d9ce5_26
Original Code:
```
static void
make_worst_score(DYNMODEL_T *m)
{
    int i;
    int *scores = m->score;
    int *sbp = m->sbp;
    int *pbp = m->pbp;
    int *wbp = m->wbp;

    for (i = 0; i < NODE_CNT; i++) {
	scores[i] = WORST_SCORE;
	wbp[i] = pbp[i] = sbp[i] = NO_BP;
    }
}
```


Overlapping Code:
```
e_worst_score(DYNMODEL_T *m)
{
int i;
int *scores = m->score;
int *sbp = m->sbp;
int *pbp = m->pbp;
int *wbp = m->wbp;
for (i = 0; i < NODE_CNT; i++) {
scores[i] = WORST_SCORE;
wbp[i] = pbp[i] = sbp[i
```
<Overlap Ratio: 0.8733624454148472>

---

--- 160 --
Question ID: 0a3f29fa308f8847bd89f9b4879598e5e829d744_3
Original Code:
```
void 
gen_backing_up()
{
	if (reject || num_backing_up == 0)
		return;

	if (fullspd)
		indent_puts("if ( yy_current_state[-1].yy_nxt )");
	else
		indent_puts("if ( yy_accept[yy_current_state] )");

	indent_up();
	indent_puts("{");
	indent_puts("YY_G(yy_last_accepting_state) = yy_current_state;");
	indent_puts("YY_G(yy_last_accepting_cpos) = yy_cp;");
	indent_puts("}");
	indent_down();
}
```


Overlapping Code:
```
king_up()
{
if (reject || num_backing_up == 0)
return;
if (fullspd)
indent_puts("if ( yy_current_state[-1].yy_nxt )");
else
indent_puts("if ( yy_accept[yy_current_state] )");
indent_up();
indent_puts("{");
indent_puts("YY_G(yy_last_accepting_state) = yy_current_state;");
indent_puts("YY_G(yy_last_accepting_cpos) = yy_cp;");
indent_puts("}");
indent
```
<Overlap Ratio: 0.938337801608579>

---

--- 161 --
Question ID: 2ce0570749352574a99b73583808a6f40bedd30f_10
Original Code:
```
static void bcread_bytecode(LexState *ls, GCproto *pt, MSize sizebc)
{
  BCIns *bc = proto_bc(pt);
  bc[0] = BCINS_AD((pt->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,
		   pt->framesize, 0);
  bcread_block(ls, bc+1, (sizebc-1)*(MSize)sizeof(BCIns));
  /* Swap bytecode instructions if the endianess differs. */
  if (bcread_swap(ls)) {
    MSize i;
    for (i = 1; i < sizebc; i++) bc[i] = lj_bswap(bc[i]);
  }
}
```


Overlapping Code:
```
tate *ls, GCproto *pt, MSize sizebc)
{
BCIns *bc = proto_bc(pt);
bc[0] = BCINS_AD((pt->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,
pt->framesize, 0);
bcread_block(ls, bc+1, (sizebc-1)*(MSize)sizeof(BCIns));
/* Swap bytecode instructions if the endianess differs. */
if (bcread_swap(ls)) {
MSize i;
for (i = 1; i < sizebc; i++) bc[i] = lj_bswap(bc[i]
```
<Overlap Ratio: 0.9020618556701031>

---

--- 162 --
Question ID: f7c6009053533897291195fef04dadfa06a5f34d_0
Original Code:
```
void inline_bzero(void *p, size_t l)
{
	BYTE *q = (BYTE *)p;
	size_t x = 0;
	for (x = 0; x < l; x++)
		*(q++) = 0x00;
}
```


Overlapping Code:
```
e_bzero(void *p, size_t l)
{
BYTE *q = (BYTE *)p;
size_t x = 0;
for (x = 0; x < l; x++)
*(q++) = 0x0
```
<Overlap Ratio: 0.8771929824561403>

---

--- 163 --
Question ID: 796733335da986d21206f5eb101e10d413b1db99_0
Original Code:
```
namespace sco {

template<typename F>
inline auto start_impl(const F& f, std::false_type&&) {
    auto ch = std::make_shared<channel<decltype(f())>>();
    routine::func_t func = [f, ch](){
        auto r = f();
        ch->send(r);
    };
    global_queue::inst()->push_routine(func);
    return ch;
}
```


Overlapping Code:
```
>
inline auto start_impl(const F& f, std::false_type&&) {
auto ch = std::make_shared<channel<decltype(f())>>();
routine::func_t func = [f, ch](){
auto r = f();
ch->send(r);
};
global_queue::inst()->pu
```
<Overlap Ratio: 0.7547169811320755>

---

--- 164 --
Question ID: 270bd0b3b22efefacf1648027749a69111f5fcff_39
Original Code:
```
static void
drmmode_output_dpms(xf86OutputPtr output, int mode)
{
    drmmode_output_private_ptr drmmode_output = output->driver_private;
    xf86CrtcPtr crtc = output->crtc;
    drmModeConnectorPtr koutput = drmmode_output->mode_output;
    drmmode_ptr drmmode = drmmode_output->drmmode;

    if (!koutput)
        return;

    drmModeConnectorSetProperty(drmmode->fd, koutput->connector_id,
                                drmmode_output->dpms_enum_id, mode);

    if (crtc) {
        drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;

        if (mode == DPMSModeOn) {
            if (drmmode_crtc->need_modeset)
                drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation,
                                       crtc->x, crtc->y);

            if (drmmode_crtc->enable_flipping)
                drmmode_InitSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);
        } else {
            if (drmmode_crtc->enable_flipping)
                drmmode_FiniSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);
        }
    }

    return;
}
```


Overlapping Code:
```
c void
drmmode_output_dpms(xf86OutputPtr output, int mode)
{
drmmode_output_private_ptr drmmode_output = output->driver_private;
xf86CrtcPtr crtc = output->crtc;
drmModeConnectorPtr koutput = drmmode_output->mode_output;
drmmode_ptr drmmode = drmmode_output->drmmode;
if (!koutput)
return;
drmModeConnectorSetProperty(drmmode->fd, koutput->connector_id,
drmmode_output->dpms_enum_id, mode);
if (crtc) {
drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
if (mode == DPMSModeOn) {
if (drmmode_crtc->need_modeset)
drmmode_set_mode_major(crtc, &crtc->mode, crtc->rotation,
crtc->x, crtc->y);
if (drmmode_crtc->enable_flipping)
drmmode_InitSharedPixmapFlipping(crtc, drmmode_crtc->drmmode);
} else {
if (drmmode_crtc->enable_flipping)
drmmode_FiniSharedPixmapFlippin
```
<Overlap Ratio: 0.9392466585662211>

---

--- 165 --
Question ID: 04feb8ac5934e100a28d48d46f6c106b5450daf4_0
Original Code:
```
bool compare_lists(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {
    struct SinglyLinkedListNode *p1,*p2;
    p1 = head1;
    p2 = head2;
    int ct1=0,ct2=0;
    while(p1!=NULL){
        ct1++;
        p1=p1->next;

    }
    while(p2!=NULL){
        ct2++;
        p2 = p2->next;
    }
    if(ct1==ct2){
        p1=head1;
        p2=head2;
        while(p1!=NULL){
            if(p1->data == p2->data)
            {
                p1 = p1->next;
                p2=p2->next;
            }
            else
                return 0;
        }
        if(p1==NULL)
            return 1;
    }

    
        return 0;


}
```


Overlapping Code:
```
bool compare_lists(SinglyLinkedListNode* head1, SinglyLinkedListNode* head2) {
struct SinglyLinkedListNode *p1,*p2;
p1 = head1;
p2 = head2;
int ct1=0,ct2=0;
while(p1!=NULL){
ct1++;
p1=p1->next;
}
while(p2!=NULL){
ct2++;
p2 = p2->next;
}
if(ct1==ct2){
p1=head1;
p2=head2;
while(p1!=NULL){
if(p1->data == p2->data)
{
p1 = p1->next;
p2=p2->next;
}
else

```
<Overlap Ratio: 0.8771929824561403>

---

--- 166 --
Question ID: aa97930c13056e7e125fa6663c952dc3e2f4d020_28
Original Code:
```
int
ikev2_validate_cp(struct iked_message *msg, size_t offset, size_t left,
    struct ikev2_payload *pld, struct ikev2_cp *cp)
{
	uint8_t		*msgbuf = ibuf_data(msg->msg_data);
	size_t		 pld_length;

	pld_length = betoh16(pld->pld_length);
	if (pld_length < sizeof(*pld) + sizeof(*cp)) {
		log_debug("%s: malformed payload: specified length smaller "
		    "than minimum size (%zu < %zu)", __func__, pld_length,
		    sizeof(*pld) + sizeof(*cp));
		return (-1);
	}

	/* This will actually be caught by earlier checks. */
	if (left < sizeof(*cp)) {
		log_debug("%s: malformed payload: too short for header "
		    "(%zu < %zu)", __func__, left, sizeof(*cp));
		return (-1);
	}
	memcpy(cp, msgbuf + offset, sizeof(*cp));

	return (0);
}
```


Overlapping Code:
```
kev2_validate_cp(struct iked_message *msg, size_t offset, size_t left,
struct ikev2_payload *pld, struct ikev2_cp *cp)
{
uint8_t *msgbuf = ibuf_data(msg->msg_data);
size_t pld_length;
pld_length = betoh16(pld->pld_length);
if (pld_length < sizeof(*pld) + sizeof(*cp)) {
log_debug("%s: malformed payload: specified length smaller "
"than minimum size (%zu < %zu)", __func__, pld_length,
sizeof(*pld) + sizeof(*cp));
return (-1);
}
/* This will actually be caught by earlier checks. */
if (left < sizeof(*cp)) {
log_debug("%s: malformed payload: too short for header "
"(%zu < %zu)", __func__, left, sizeof(*cp));
return (-1);
}
memcpy(cp, msgbuf + off
```
<Overlap Ratio: 0.9461426491994177>

---

--- 167 --
Question ID: aa11e25e262e6a0f0c8ebc8d41e10508c79a9306_0
Original Code:
```
void initState(void) {
	state.substate[SUBSTATE_POSITION].internalState = MOVEMENT_STATE_STATIONARY;
	state.substate[SUBSTATE_POSITION].hysteresisCounter = 0;
	state.substate[SUBSTATE_POSITION].hysteresisCounterToStationary = getHysteresisCountToStationary();
	state.substate[SUBSTATE_POSITION].hysteresisCounterToMoving = getHysteresisCountToMoving();
	state.substate[SUBSTATE_POSITION].externalState = MOVEMENT_STATE_STATIONARY;
	state.substate[SUBSTATE_GATEWAY].internalState = MOVEMENT_STATE_MOVING;
	state.substate[SUBSTATE_GATEWAY].hysteresisCounter = 0;
	state.substate[SUBSTATE_GATEWAY].hysteresisCounterToStationary = getGatewayHysteresisCountToStationary();
	state.substate[SUBSTATE_GATEWAY].hysteresisCounterToMoving = getGatewayHysteresisCountToMoving();
	state.substate[SUBSTATE_GATEWAY].externalState = MOVEMENT_STATE_MOVING;
	state.externalState = MOVEMENT_STATE_MOVING; /* must comply to AND/OR conditions of sub-states */
}
```


Overlapping Code:
```
d) {
state.substate[SUBSTATE_POSITION].internalState = MOVEMENT_STATE_STATIONARY;
state.substate[SUBSTATE_POSITION].hysteresisCounter = 0;
state.substate[SUBSTATE_POSITION].hysteresisCounterToStationary = getHysteresisCountToStationary();
state.substate[SUBSTATE_POSITION].hysteresisCounterToMoving = getHysteresisCountToMoving();
state.substate[SUBSTATE_POSITION].externalState = MOVEMENT_STATE_STATIONARY;
state.substate[SUBSTATE_GATEWAY].internalState = MOVEMENT_STATE_MOVING;
state.substate[SUBSTATE_GATEWAY].hysteresisCounter = 0;
state.substate[SUBSTATE_GATEWAY].hysteresisCounterToStationary = getGatewayHysteresisCountToStationary();
state.substate[SUBSTATE_GATEWAY].hysteresisCounterToMoving = getGatewayHysteresisCountToMoving();
state.substate[SUBSTATE_GATEWAY].externalState = MOVEMENT_STATE_MOVING;
state.externalState = MOVEMENT_STATE_MOVING; /* must comply to AND/OR conditions of sub-
```
<Overlap Ratio: 0.9687836383207751>

---

--- 168 --
Question ID: 69e269675d6766ae4fe4f41cb547caedf2a43141_29
Original Code:
```
static void itc_systemio_gpio_get_edge_mode_n_after_close(void)
{
	int ret;
	g_gpio_h = NULL;
	iotbus_gpio_edge_e set_edge = IOTBUS_GPIO_EDGE_NONE;
	iotbus_gpio_edge_e get_edge;

	g_gpio_h = iotbus_gpio_open(GPIO_PIN);
	TC_ASSERT_NEQ("iotbus_gpio_open", g_gpio_h, NULL);

	ret = iotbus_gpio_set_edge_mode(g_gpio_h, set_edge);
	TC_ASSERT_EQ_CLEANUP("iotbus_gpio_set_edge_mode", ret, 0, iotbus_gpio_close(g_gpio_h));

	ret = iotbus_gpio_close(g_gpio_h);
	TC_ASSERT_EQ("iotbus_gpio_close", ret, 0);

	ret = iotbus_gpio_get_edge_mode(g_gpio_h, &get_edge);
	TC_ASSERT_LT("iotbus_gpio_get_edge_mode", ret, 0);

	TC_SUCCESS_RESULT();
}
```


Overlapping Code:
```
ic void itc_systemio_gpio_get_edge_mode_n_after_close(void)
{
int ret;
g_gpio_h = NULL;
iotbus_gpio_edge_e set_edge = IOTBUS_GPIO_EDGE_NONE;
iotbus_gpio_edge_e get_edge;
g_gpio_h = iotbus_gpio_open(GPIO_PIN);
TC_ASSERT_NEQ("iotbus_gpio_open", g_gpio_h, NULL);
ret = iotbus_gpio_set_edge_mode(g_gpio_h, set_edge);
TC_ASSERT_EQ_CLEANUP("iotbus_gpio_set_edge_mode", ret, 0, iotbus_gpio_close(g_gpio_h));
ret = iotbus_gpio_close(g_gpio_h);
TC_ASSERT_EQ("iotbus_gpio_close", ret, 0);
ret = iotbus_gpio_get_edge_mode(g_gpio_h, &get_edge);
TC_ASSERT_LT("iotbus_gpio_get_edge_mode", ret, 0);
TC_SUCCESS_RESUL
```
<Overlap Ratio: 0.9836065573770492>

---

--- 169 --
Question ID: 88b81c8fec68caeb54430ee1950e9941248d99a1_2
Original Code:
```
Item_Set
newItem_Set(relevant) Relevant relevant;
{
	Item_Set ts;
	
	if (fptr) {
		ts = fptr;
		fptr = 0;
		memset(ts->virgin, 0, max_nonterminal * sizeof(struct item));
		if (ts->closed) {
			zfree(ts->closed);
			ts->closed = 0;
		}
		ts->num = 0;
		ts->op = 0;
	} else {
		ts = (Item_Set) zalloc(sizeof(struct item_set));
		ts->virgin = newItemArray();
	}
	ts->relevant = relevant;
	return ts;
}
```


Overlapping Code:
```
levant relevant;
{
Item_Set ts;

if (fptr) {
ts = fptr;
fptr = 0;
memset(ts->virgin, 0, max_nonterminal * sizeof(struct item));
if (ts->closed) {
zfree(ts->closed);
ts->closed = 0;
}
ts->num = 0;
ts->op = 0;
} else {
ts = (Item_Set) zalloc(sizeof(struct item_set));
ts->virgin = newItemArray();
}
ts-
```
<Overlap Ratio: 0.8174386920980926>

---

--- 170 --
Question ID: e93cd0ef341eea0bd8549e196f180921e3cdc6e6_12
Original Code:
```
static uint16_t WriteMultipleHoldingRegisters(const uint8_t *pucQuery, uint8_t *pucResponse)
{
    uint16_t usDataStartAddress = 0;
    uint16_t usNumOfData        = 0;
    uint16_t usMbapLength       = 0;
    uint16_t usStartAddress     = 0;
    uint16_t usResponseLen      = 0;
    uint8_t  ucByteCount        = 0;

    usDataStartAddress  = (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET] << 8);
    usDataStartAddress |= (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET + 1]);
    usNumOfData         = (uint16_t)(pucQuery[NO_OF_DATA_OFFSET] << 8);
    usNumOfData        |= (uint16_t)(pucQuery[NO_OF_DATA_OFFSET + 1]);
    ucByteCount         = pucQuery[WRITE_BYTE_COUNT_OFFSET];

    if (ucByteCount != (usNumOfData * 2) )
    {
        usResponseLen = 0;
        return usResponseLen;
    }

    usStartAddress = (usDataStartAddress - m_ModbusData->usHoldingRegisterStartAddress);
    usMbapLength   = MBAP_LEN_WRITE_HOLDING_REGISTERS;

    //Copy MBAP Header and function code into response
    memcpy(pucResponse, pucQuery, (MBAP_HEADER_LEN + 1));

    //Modify Information in MBAP Header for response
    pucResponse[MBAP_LEN_OFFSET]         = (uint8_t)(usMbapLength << 8);
    pucResponse[MBAP_LEN_OFFSET + 1]     = (uint8_t)(usMbapLength & 0xFF);
    pucResponse[WRITE_START_ADDRESS]     = (uint8_t)(usDataStartAddress << 8);
    pucResponse[WRITE_START_ADDRESS + 1] = (uint8_t)(usDataStartAddress & 0xFF);
    pucResponse[WRITE_NUM_OF_DATA ]      = (uint8_t)(usNumOfData << 8);
    pucResponse[WRITE_NUM_OF_DATA + 1]   = (uint8_t)(usNumOfData & 0xFF);

    usResponseLen = WRITE_HOLDING_REGISTERS_RESPONSE_LEN;

    uint8_t ucCount = 0;

    while (usNumOfData > 0)
    {
        uint16_t usValue;

        usValue  = (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount] << 8);
        ucCount++;
        usValue |= (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount]);
        m_ModbusData->psHoldingRegisters[usStartAddress] = usValue;
        ucCount++;
        usStartAddress++;
        usNumOfData--;
    }

    return (usResponseLen);
}
```


Overlapping Code:
```
sters(const uint8_t *pucQuery, uint8_t *pucResponse)
{
uint16_t usDataStartAddress = 0;
uint16_t usNumOfData = 0;
uint16_t usMbapLength = 0;
uint16_t usStartAddress = 0;
uint16_t usResponseLen = 0;
uint8_t ucByteCount = 0;
usDataStartAddress = (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET] << 8);
usDataStartAddress |= (uint16_t)(pucQuery[DATA_START_ADDRESS_OFFSET + 1]);
usNumOfData = (uint16_t)(pucQuery[NO_OF_DATA_OFFSET] << 8);
usNumOfData |= (uint16_t)(pucQuery[NO_OF_DATA_OFFSET + 1]);
ucByteCount = pucQuery[WRITE_BYTE_COUNT_OFFSET];
if (ucByteCount != (usNumOfData * 2) )
{
usResponseLen = 0;
return usResponseLen;
}
usStartAddress = (usDataStartAddress - m_ModbusData->usHoldingRegisterStartAddress);
usMbapLength = MBAP_LEN_WRITE_HOLDING_REGISTERS;
//Copy MBAP Header and function code into response
memcpy(pucResponse, pucQuery, (MBAP_HEADER_LEN + 1));
//Modify Information in MBAP Header for response
pucResponse[MBAP_LEN_OFFSET] = (uint8_t)(usMbapLength << 8);
pucResponse[MBAP_LEN_OFFSET + 1] = (uint8_t)(usMbapLength & 0xFF);
pucResponse[WRITE_START_ADDRESS] = (uint8_t)(usDataStartAddress << 8);
pucResponse[WRITE_START_ADDRESS + 1] = (uint8_t)(usDataStartAddress & 0xFF);
pucResponse[WRITE_NUM_OF_DATA ] = (uint8_t)(usNumOfData << 8);
pucResponse[WRITE_NUM_OF_DATA + 1] = (uint8_t)(usNumOfData & 0xFF);
usResponseLen = WRITE_HOLDING_REGISTERS_RESPONSE_LEN;
uint8_t ucCount = 0;
while (usNumOfData > 0)
{
uint16_t usValue;
usValue = (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount] << 8);
ucCount++;
usValue |= (uint16_t)(pucQuery[WRITE_VALUE_OFFSET + ucCount]);
m_ModbusData->psHoldingRegisters[usStartAddress] = usValue;
ucCount++;
usStartAddress++;
usNumOfData--;
}
return (usResp
```
<Overlap Ratio: 0.9708904109589042>

---

--- 171 --
Question ID: 721d73ab26417b834f4b3b265642c71def6834c0_13
Original Code:
```
char *fnc(char *s)
{
	char *p,*q;
	unsigned int i=0;
	static char s8[13];
	if(!s)return NULL;
	if(!(p=strrchr(s,'/')))p=s; else s=p;
	while(*p&&*p!='.'&&i<8) {
		if(dosallowin83(*p))s8[i++]=tolower(*p);
		p++;
	}
	s8[i]=0;
	if(strstr(s,".tar.gz"))xstrcat(s8,".tgz",14);
	else if(strstr(s,".tar.bz2"))xstrcat(s8,".tb2",14);
	else if(strstr(s,".html"))xstrcat (s8,".htm",14);
	else if(strstr(s,".jpeg"))xstrcat (s8,".jpg",14);
	else if(strstr(s,".desc"))xstrcat (s8,".dsc",14);
	    else {
		if((p=strrchr(s,'.'))) {
			xstrcat(s8,".",14);
			q=p+4;i=strlen(s8);
			while(*p&&q>p) {
				if(dosallowin83(*p))s8[i++]=tolower(*p);
				p++;
			}
			s8[i]=0;
		}
	}
	return s8;
}
```


Overlapping Code:
```
r *s)
{
char *p,*q;
unsigned int i=0;
static char s8[13];
if(!s)return NULL;
if(!(p=strrchr(s,'/')))p=s; else s=p;
while(*p&&*p!='.'&&i<8) {
if(dosallowin83(*p))s8[i++]=tolower(*p);
p++;
}
s8[i]=0;
if(strstr(s,".tar.gz"))xstrcat(s8,".tgz",14);
else if(strstr(s,".tar.bz2"))xstrcat(s8,".tb2",14);
else if(strstr(s,".html"))xstrcat (s8,".htm",14);
else if(strstr(s,".jpeg"))xstrcat (s8,".jpg",14);
else if(strstr(s,".desc"))xstrcat (s8,".dsc",14);
else {
if((p=strrchr(s,'.'))) {
xstrcat(s8,".",14);
q=p+4;i=strlen(s8);
while(*p&&q>p) {
if(dosallowin83(*p))s8[i++]=tolower(*p);
p++;
}
s8[i]=0;
}
}
retu
```
<Overlap Ratio: 0.966183574879227>

---

--- 172 --
Question ID: 2d18b4f4f5712ed7ccc8ba89525934e8ef7d3510_3
Original Code:
```
static GFraMe_ret ps_init(playstateCmd cmd) {
    GFraMe_ret rv;
    int map, plX, plY, time;
    
    // Read the desired fps (for update and drawing)
    _maxUfps = read_slot(BLK_CONFIG, sv_ufps);
    if (_maxUfps == -1)
        _maxUfps = GAME_UFPS;
    _maxDfps = read_slot(BLK_CONFIG, sv_dfps);
    if (_maxDfps == -1)
        _maxDfps = GAME_DFPS;
    _ps_isSpeedrun = read_slot(BLK_CONFIG, sv_speedrun);
    if (_ps_isSpeedrun == -1)
        _ps_isSpeedrun = 0;
    
    if (cmd != CONTINUE) {
        gv_init();
        
        plX = 16;
        plY = 184;
        if (cmd == MT_VERSION) {
            map = 21;
        }
        else /* if (cmd == NEWGAME) */ {
            map = 0;
        }
        gv_setValue(DOOR_X, 16 / 8);
        gv_setValue(DOOR_Y, 184 / 8);
        gv_setValue(MAP, map);
    }
    else {
        rv = gv_load(SAVEFILE);
        GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to load state", __ret);
        
        plX = gv_getValue(DOOR_X) * 8;
        plY = gv_getValue(DOOR_Y) * 8;
        map = gv_getValue(MAP);
    }
    time = gv_getValue(GAME_TIME);
    timer_init(time);
    
    if ((map % 21) >= 20) {
        audio_playBoss();
    }
    else if ((map % 21) >= 15) {
        audio_playTensionGoesUp();
    }
    else if ((map % 21) >= 4) {
        audio_playMovingOn();
    }
    else {
        audio_playIntro();
    }

    rv = ui_init();
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init ui", __ret);
    
    rv = rg_init();
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to registry ui", __ret);
    
    rv = map_init(&m);
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init map", __ret);
    
    rv = player_init(&p1, ID_PL1, 224, plX, plY);
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init player", __ret);
    
    rv = player_init(&p2, ID_PL2, 240, plX, plY);
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init player", __ret);
    
    rv = map_loadi(m, map);
    GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init map", __ret);

    signal_init();
    
    _timerTilCredits = 0;
    _ps_onOptions = 0;
    _ps_text = 0;
    switchState = 0;
    transition_initFadeOut();
    
#ifdef DEBUG
    _updCalls = 0;
    _drwCalls = 0;
    _time = 0;
    _ltime = 0;
#endif
    
    rv = GFraMe_ret_ok;
__ret:
    return rv;
}
```


Overlapping Code:
```
{
GFraMe_ret rv;
int map, plX, plY, time;

// Read the desired fps (for update and drawing)
_maxUfps = read_slot(BLK_CONFIG, sv_ufps);
if (_maxUfps == -1)
_maxUfps = GAME_UFPS;
_maxDfps = read_slot(BLK_CONFIG, sv_dfps);
if (_maxDfps == -1)
_maxDfps = GAME_DFPS;
_ps_isSpeedrun = read_slot(BLK_CONFIG, sv_speedrun);
if (_ps_isSpeedrun == -1)
_ps_isSpeedrun = 0;

if (cmd != CONTINUE) {
gv_init();

plX = 16;
plY = 184;
if (cmd == MT_VERSION) {
map = 21;
}
else /* if (cmd == NEWGAME) */ {
map = 0;
}
gv_setValue(DOOR_X, 16 / 8);
gv_setValue(DOOR_Y, 184 / 8);
gv_setValue(MAP, map);
}
else {
rv = gv_load(SAVEFILE);
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to load state", __ret);

plX = gv_getValue(DOOR_X) * 8;
plY = gv_getValue(DOOR_Y) * 8;
map = gv_getValue(MAP);
}
time = gv_getValue(GAME_TIME);
timer_init(time);

if ((map % 21) >= 20) {
audio_playBoss();
}
else if ((map % 21) >= 15) {
audio_playTensionGoesUp();
}
else if ((map % 21) >= 4) {
audio_playMovingOn();
}
else {
audio_playIntro();
}
rv = ui_init();
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init ui", __ret);

rv = rg_init();
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to registry ui", __ret);

rv = map_init(&m);
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init map", __ret);

rv = player_init(&p1, ID_PL1, 224, plX, plY);
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init player", __ret);

rv = player_init(&p2, ID_PL2, 240, plX, plY);
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init player", __ret);

rv = map_loadi(m, map);
GFraMe_assertRet(rv == GFraMe_ret_ok, "Failed to init map", __ret);
signal_init();

_timerTilCredits = 0;
_ps_onOptions = 0;
_ps_text = 0;
switchState = 0;
transition_initFadeOut();

#ifdef DEBUG
_updCalls = 0;
_drwCalls = 0;
_time = 0;
_ltime = 0;
#endif

rv = GFraMe_ret_ok
```
<Overlap Ratio: 0.9651474530831099>

---

--- 173 --
Question ID: c4f710d0265e20da931bb3a353e1a0839d1d5804_3
Original Code:
```
int
VX_COLBYUCD (handle_t *parent, XCHAR *name, XCHAR *alt)
{
    char *_name = spp2c (name, spplen (name));
    char *_alt = spp2c (alt, spplen (alt));

    int col = vot_colByUCD (*parent, _name, _alt);

    free ((char *) _name);
    free ((char *) _alt);

    return ( col );
}
```


Overlapping Code:
```
le_t *parent, XCHAR *name, XCHAR *alt)
{
char *_name = spp2c (name, spplen (name));
char *_alt = spp2c (alt, spplen (alt));
int col = vot_colByUCD (*parent, _name, _alt);
free ((char *) _name);
free ((char *) _alt);
return
```
<Overlap Ratio: 0.8740157480314961>

---

--- 174 --
Question ID: a9042f4faabb01e14c77bf3c8c1fe2728d1c4b44_1
Original Code:
```
static device_t
agp_find_display(void)
{
	devclass_t pci = devclass_find("pci");
	device_t bus, dev = 0;
	device_t *kids;
	int busnum, numkids, i;

	for (busnum = 0; busnum < devclass_get_maxunit(pci); busnum++) {
		bus = devclass_get_device(pci, busnum);
		if (!bus)
			continue;
		device_get_children(bus, &kids, &numkids);
		for (i = 0; i < numkids; i++) {
			dev = kids[i];
			if (pci_get_class(dev) == PCIC_DISPLAY
			    && pci_get_subclass(dev) == PCIS_DISPLAY_VGA)
				if (agp_find_caps(dev)) {
					free(kids, M_TEMP);
					return dev;
				}
					
		}
		free(kids, M_TEMP);
	}

	return 0;
}
```


Overlapping Code:
```

devclass_t pci = devclass_find("pci");
device_t bus, dev = 0;
device_t *kids;
int busnum, numkids, i;
for (busnum = 0; busnum < devclass_get_maxunit(pci); busnum++) {
bus = devclass_get_device(pci, busnum);
if (!bus)
continue;
device_get_children(bus, &kids, &numkids);
for (i = 0; i < numkids; i++) {
dev = kids[i];
if (pci_get_class(dev) == PCIC_DISPLAY
&& pci_get_subclass(dev) == PCIS_DISPLAY_VGA)
if (agp_find_caps(dev)) {
free(kids, M_TEMP);
r
```
<Overlap Ratio: 0.8348794063079777>

---

--- 175 --
Question ID: 8c510c347e0dd02d71dc20bfb727fa4ea676406c_5
Original Code:
```
int
set_snaplen(int snap)
{
	if (priv_set_snaplen(snap))
		return (1);

	if (cur_snaplen > snap)
		purge_buffer();

	cur_snaplen = snap;

	return (0);
}
```


Overlapping Code:
```
naplen(int snap)
{
if (priv_set_snaplen(snap))
return (1);
if (cur_snaplen > snap)
purge_buffer();
c
```
<Overlap Ratio: 0.7092198581560284>

---

--- 176 --
Question ID: dad63623be6a93672974fb43ee50b518fff59ab5_4
Original Code:
```
static int aq_ndev_set_features(struct net_device *ndev,
				netdev_features_t features)
{
	struct aq_nic_s *aq_nic = netdev_priv(ndev);
	struct aq_nic_cfg_s *aq_cfg = aq_nic_get_cfg(aq_nic);
	bool is_lro = false;

	if (aq_cfg->hw_features & NETIF_F_LRO) {
		is_lro = features & NETIF_F_LRO;

		if (aq_cfg->is_lro != is_lro) {
			aq_cfg->is_lro = is_lro;

			if (netif_running(ndev)) {
				aq_ndev_close(ndev);
				aq_ndev_open(ndev);
			}
		}
	}

	return 0;
}
```


Overlapping Code:
```
_ndev_set_features(struct net_device *ndev,
netdev_features_t features)
{
struct aq_nic_s *aq_nic = netdev_priv(ndev);
struct aq_nic_cfg_s *aq_cfg = aq_nic_get_cfg(aq_nic);
bool is_lro = false;
if (aq_cfg->hw_features & NETIF_F_LRO) {
is_lro = features & NETIF_F_LRO;
if (aq_cfg->is_lro != is_lro) {
aq_cfg->is_lro = is_lro;
if (netif_running(ndev)) {
aq_ndev_close(ndev);
aq_ndev_open(ndev);
}
}
}
return 0;
}
```
<Overlap Ratio: 0.9692671394799054>

---

--- 177 --
Question ID: 2755bab7718f7c9024e97160ae500b37fa3e3360_20
Original Code:
```
void
bio_patrol(char *arg)
{
	struct bioc_patrol	bp;
	struct timing		timing;
	const char		*errstr;

	memset(&bp, 0, sizeof(bp));
	bp.bp_bio.bio_cookie = bio_cookie;

	switch (arg[0]) {
	case 'a':
		bp.bp_opcode = BIOC_SPAUTO;
		break;

	case 'm':
		bp.bp_opcode = BIOC_SPMANUAL;
		break;

	case 'd':
		bp.bp_opcode = BIOC_SPDISABLE;
		break;

	case 'g': /* get patrol state */
		bp.bp_opcode = BIOC_GPSTATUS;
		break;

	case 's': /* start/stop patrol */
		if (strncmp("sta", arg, 3) == 0)
			bp.bp_opcode = BIOC_SPSTART;
		else
			bp.bp_opcode = BIOC_SPSTOP;
		break;

	default:
		errx(1, "invalid patrol function: %s", arg);
	}

	switch (arg[0]) {
	case 'a':
		errstr = str2patrol(arg, &timing);
		if (errstr)
			errx(1, "Patrol %s: %s", arg, errstr);
		bp.bp_autoival = timing.interval;
		bp.bp_autonext = timing.start;
		break;
	}

	if (ioctl(devh, BIOCPATROL, &bp))
		err(1, "BIOCPATROL");

	bio_status(&bp.bp_bio.bio_status);

	if (arg[0] == 'g') {
		const char *mode, *status;
		char interval[40];

		interval[0] = '\0';

		switch (bp.bp_mode) {
		case BIOC_SPMAUTO:
			mode = "auto";
			snprintf(interval, sizeof interval,
			    " interval=%d next=%d", bp.bp_autoival,
			    bp.bp_autonext - bp.bp_autonow);
			break;
		case BIOC_SPMMANUAL:
			mode = "manual";
			break;
		case BIOC_SPMDISABLED:
			mode = "disabled";
			break;
		default:
			mode = "unknown";
			break;
		}
		switch (bp.bp_status) {
		case BIOC_SPSSTOPPED:
			status = "stopped";
			break;
		case BIOC_SPSREADY:
			status = "ready";
			break;
		case BIOC_SPSACTIVE:
			status = "active";
			break;
		case BIOC_SPSABORTED:
			status = "aborted";
			break;
		default:
			status = "unknown";
			break;
		}
		printf("patrol mode: %s%s\n", mode, interval);
		printf("patrol status: %s\n", status);
	}
}
```


Overlapping Code:
```
truct bioc_patrol bp;
struct timing timing;
const char *errstr;
memset(&bp, 0, sizeof(bp));
bp.bp_bio.bio_cookie = bio_cookie;
switch (arg[0]) {
case 'a':
bp.bp_opcode = BIOC_SPAUTO;
break;
case 'm':
bp.bp_opcode = BIOC_SPMANUAL;
break;
case 'd':
bp.bp_opcode = BIOC_SPDISABLE;
break;
case 'g': /* get patrol state */
bp.bp_opcode = BIOC_GPSTATUS;
break;
case 's': /* start/stop patrol */
if (strncmp("sta", arg, 3) == 0)
bp.bp_opcode = BIOC_SPSTART;
else
bp.bp_opcode = BIOC_SPSTOP;
break;
default:
errx(1, "invalid patrol function: %s", arg);
}
switch (arg[0]) {
case 'a':
errstr = str2patrol(arg, &timing);
if (errstr)
errx(1, "Patrol %s: %s", arg, errstr);
bp.bp_autoival = timing.interval;
bp.bp_autonext = timing.start;
break;
}
if (ioctl(devh, BIOCPATROL, &bp))
err(1, "BIOCPATROL");
bio_status(&bp.bp_bio.bio_status);
if (arg[0] == 'g') {
const char *mode, *status;
char interval[40];
interval[0] = '\0';
switch (bp.bp_mode) {
case BIOC_SPMAUTO:
mode = "auto";
snprintf(interval, sizeof interval,
" interval=%d next=%d", bp.bp_autoival,
bp.bp_autonext - bp.bp_autonow);
break;
case BIOC_SPMMANUAL:
mode = "manual";
break;
case BIOC_SPMDISABLED:
mode = "disabled";
break;
default:
mode = "unknown";
break;
}
switch (bp.bp_status) {
case BIOC_SPSSTOPPED:
status = "stopped";
break;
case BIOC_SPSREADY:
status = "ready";
break;
case BIOC_SPSACTIVE:
status = "active";
break;
case BIOC_SPSABORTED:
status = "aborted";
break;
default:
status = "unknown";
break;
}
printf("patrol mode: %s%s\n", mode, interval);
printf("patrol status: %s\n", status
```
<Overlap Ratio: 0.9773013871374527>

---

--- 178 --
Question ID: 9f5e3f509aaf78d8dae2726fa333e21032201e92_3
Original Code:
```
static void test_generation_rate (void)
{
    int dimension, length, max_block_length;
    struct block_frequency bf_x, bf_y;
    int **x, **y;
    double gen_rate;

    dimension = 4;
    length = 1024;
    max_block_length = 5;

    MALLOC2(x, length, dimension);
    MALLOC2(y, length, dimension);

    int *tmp;
    MALLOC(tmp, length);
    gen_Morse_sequence(tmp, length);
    for (int n = 0; n < length; n++) {
        for (int i = 0; i < dimension; i++) {
            x[n][i] = tmp[(n+i) % length];
            y[n][i] = tmp[(n+i+300) % length];
        }
    }
    FREE(tmp);
    for (int n = 1; n < max_block_length; n++) {
        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);
        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);
        gen_rate = generation_rate(&bf_x, &bf_y);
        assert_equal_double(1, gen_rate, 1e-3);
        free_block_frequency(&bf_x);
        free_block_frequency(&bf_y);
    }
    for (int n = 0; n < length; n++) {
        for (int i = 0; i < dimension; i++) {
            x[n][i] = i;
            y[n][i] = i + 1;
        }
    }
    for (int n = 1; n < max_block_length; n++) {
        init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);
        init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);
        gen_rate = generation_rate(&bf_x, &bf_y);
        assert_equal_double(0, gen_rate, 1e-3);
        free_block_frequency(&bf_x);
        free_block_frequency(&bf_y);
    }
    FREE2(x);
    FREE2(y);
}
```


Overlapping Code:
```
imension, length, max_block_length;
struct block_frequency bf_x, bf_y;
int **x, **y;
double gen_rate;
dimension = 4;
length = 1024;
max_block_length = 5;
MALLOC2(x, length, dimension);
MALLOC2(y, length, dimension);
int *tmp;
MALLOC(tmp, length);
gen_Morse_sequence(tmp, length);
for (int n = 0; n < length; n++) {
for (int i = 0; i < dimension; i++) {
x[n][i] = tmp[(n+i) % length];
y[n][i] = tmp[(n+i+300) % length];
}
}
FREE(tmp);
for (int n = 1; n < max_block_length; n++) {
init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);
init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);
gen_rate = generation_rate(&bf_x, &bf_y);
assert_equal_double(1, gen_rate, 1e-3);
free_block_frequency(&bf_x);
free_block_frequency(&bf_y);
}
for (int n = 0; n < length; n++) {
for (int i = 0; i < dimension; i++) {
x[n][i] = i;
y[n][i] = i + 1;
}
}
for (int n = 1; n < max_block_length; n++) {
init_block_frequency(&bf_x, (const int* const*)x, dimension, length, n);
init_block_frequency(&bf_y, (const int* const*)y, dimension, length, n);
gen_rate = generation_rate(&bf_x, &bf_y);
assert_equal_double(0, gen_rate, 1e-3);
free_block_frequency(&bf_x);
free_block_frequency(&bf_y);
}
FREE2(x);
FREE2(y);
```
<Overlap Ratio: 0.9615686274509804>

---

--- 179 --
Question ID: c83d81cdafe427bbab9834da9ba5e565a4df326d_3
Original Code:
```
char *
nextstr (char **pbuf, FILE *fp)
{
	char	*p, *nxtchr();
	static	char	tbuf[SZ_LINE];
	char	quote;
	int	cnt;

	p = *pbuf;

	/* Skip white space. */
	while ( *p == ' '  ||  *p == '\t'  ||  *p =='\n')
	    p = nxtchr(p, fp);

	/* Reached end?	*/
	if (*p == '\0') {
	    *pbuf = p;
	    return (NULL);
	}

	quote = '\0';
	cnt = 0;

	/* Quoted string. */
	if (*p == '\''  ||  *p == '"') {
	    quote = *p;
	    p = nxtchr (p, fp);

	    while (*p != quote) {

		if (p == '\0'  ||  cnt >= SZ_LINE)
		    return ( (char *) ERR);

		else {
		    tbuf[cnt++] = *p;
		    p = nxtchr(p, fp);
		}
	    }
	    /* Skip quote. */
	    p = nxtchr (p, fp);

	} else {
	    /* Unquoted string. */
	    while (*p != ' '   &&  *p != '\t'   &&  *p != '\n'  &&
	      *p != '\0'  &&  *p != ',') {

		if (cnt >= SZ_LINE)
		    return ( (char *) ERR );

		tbuf[cnt++] = *p;
		p = nxtchr (p, fp);
	    }
	}
	tbuf[cnt] = '\0';

	/* Skip any white-space following. */
	while (*p == ' '  ||  *p == '\t'  ||  *p == '\n')
	    p = nxtchr(p, fp);

	if (*p != ','   &&  *p != '\0')
	    return ( (char *) ERR);

	/* Skip delimiter. */
	if (*p == ',')
	   p = nxtchr(p, fp);

	*pbuf = p;
	if (cnt == 0) {
	    /* Return a quoted null string, otherwise the field was skipped. */
	    if (quote != '\0')
		return (tbuf);
	    else
		return (undefval);
	} else
	    return (tbuf);
}
```


Overlapping Code:
```
fp)
{
char *p, *nxtchr();
static char tbuf[SZ_LINE];
char quote;
int cnt;
p = *pbuf;
/* Skip white space. */
while ( *p == ' ' || *p == '\t' || *p =='\n')
p = nxtchr(p, fp);
/* Reached end? */
if (*p == '\0') {
*pbuf = p;
return (NULL);
}
quote = '\0';
cnt = 0;
/* Quoted string. */
if (*p == '\'' || *p == '"') {
quote = *p;
p = nxtchr (p, fp);
while (*p != quote) {
if (p == '\0' || cnt >= SZ_LINE)
return ( (char *) ERR);
else {
tbuf[cnt++] = *p;
p = nxtchr(p, fp);
}
}
/* Skip quote. */
p = nxtchr (p, fp);
} else {
/* Unquoted string. */
while (*p != ' ' && *p != '\t' && *p != '\n' &&
*p != '\0' && *p != ',') {
if (cnt >= SZ_LINE)
return ( (char *) ERR );
tbuf[cnt++] = *p;
p = nxtchr (p, fp);
}
}
tbuf[cnt] = '\0';
/* Skip any white-space following. */
while (*p == ' ' || *p == '\t' || *p == '\n')
p = nxtchr(p, fp);
if (*p != ',' && *p != '\0')
return ( (char *) ERR);
/* Skip delimiter. */
if (*p == ',')
p = nxtchr(p, fp);
*pbuf = p;
if (cnt == 0) {
/* Return a quoted null string, otherwise the field was skipped. */
if (quote != '\0')
return (tbuf);
else
return (undefval);
} else
retur
```
<Overlap Ratio: 0.9598603839441536>

---

--- 180 --
Question ID: 9ee58d4ebb6db1406ca3e66f1203b928db0f3ee0_5
Original Code:
```
struct texture_list* construct_texture_list() {
	struct texture_list* result = (struct texture_list*)malloc(sizeof(struct texture_list));

	result->head = NULL;

	result->num_floor_ceils = 0;
	result->num_walls = 0;

	return result;
}
```


Overlapping Code:
```
ture_list() {
struct texture_list* result = (struct texture_list*)malloc(sizeof(struct texture_list));
result->head = NULL;
result->num_floor_ceils = 
```
<Overlap Ratio: 0.6637168141592921>

---

--- 181 --
Question ID: 9c46c13fb622f41a797447b836e8a6e64e4ab9fb_3
Original Code:
```
unsigned int leon_smp_getbroadcast(void ) 
{
    unsigned int mask;
    mask = LEON_BYPASS_LOAD_PA(&(LEON3_IrqCtrl_Regs->mpbroadcast));
    return mask;
}
```


Overlapping Code:
```
 leon_smp_getbroadcast(void ) 
{
unsigned int mask;
mask = LEON_BYPASS_LOAD_PA(&(LEON3_IrqCtrl_Regs-
```
<Overlap Ratio: 0.704225352112676>

---

--- 182 --
Question ID: 9ac1e5d407beb686653279c903d1827d44fcbe86_34
Original Code:
```
static void
ia64_libunwind_frame_prev_register (struct frame_info *next_frame,
				    void **this_cache,
				    int regnum, int *optimizedp,
				    enum lval_type *lvalp, CORE_ADDR *addrp,
				    int *realnump, void *valuep)
{
  int reg = regnum;

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    reg = IA64_PR_REGNUM;
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    reg = IA64_UNAT_REGNUM;

  /* Let libunwind do most of the work.  */
  libunwind_frame_prev_register (next_frame, this_cache, reg,
				 optimizedp, lvalp, addrp, realnump, valuep);

  if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
    {
      ULONGEST prN_val;

      if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
	{
	  int rrb_pr = 0;
	  ULONGEST cfm;
	  unsigned char buf[MAX_REGISTER_SIZE];

	  /* Fetch predicate register rename base from current frame
	     marker for this frame.  */
	  frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
	  cfm = extract_unsigned_integer (buf, 8); 
	  rrb_pr = (cfm >> 32) & 0x3f;
	  
	  /* Adjust the register number to account for register rotation.  */
	  regnum = VP16_REGNUM 
	    + ((regnum - VP16_REGNUM) + rrb_pr) % 48;
	}
      prN_val = extract_bit_field ((unsigned char *) valuep,
				   regnum - VP0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
    }
  else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
    {
      ULONGEST unatN_val;

      unatN_val = extract_bit_field ((unsigned char *) valuep,
                                   regnum - IA64_NAT0_REGNUM, 1);
      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
                              unatN_val);
    }
  else if (regnum == IA64_BSP_REGNUM)
    {
      char cfm_valuep[MAX_REGISTER_SIZE];
      int  cfm_optim;
      int  cfm_realnum;
      enum lval_type cfm_lval;
      CORE_ADDR cfm_addr;
      CORE_ADDR bsp, prev_cfm, prev_bsp;

      /* We want to calculate the previous bsp as the end of the previous register stack frame.
	 This corresponds to what the hardware bsp register will be if we pop the frame
	 back which is why we might have been called.  We know that libunwind will pass us back
	 the beginning of the current frame so we should just add sof to it. */
      prev_bsp = extract_unsigned_integer (valuep, 8);
      libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
				     &cfm_optim, &cfm_lval, &cfm_addr, &cfm_realnum, cfm_valuep);
      prev_cfm = extract_unsigned_integer (cfm_valuep, 8);
      prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));

      store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
			      prev_bsp);
    }

  if (gdbarch_debug >= 1)
    fprintf_unfiltered (gdb_stdlog,
			"libunwind prev register <%s> is 0x%s\n",
			(((unsigned) regnum <= IA64_NAT127_REGNUM)
			 ? ia64_register_names[regnum] : "r??"), 
			paddr_nz (extract_unsigned_integer (valuep, 8)));
}
```


Overlapping Code:
```
libunwind_frame_prev_register (struct frame_info *next_frame,
void **this_cache,
int regnum, int *optimizedp,
enum lval_type *lvalp, CORE_ADDR *addrp,
int *realnump, void *valuep)
{
int reg = regnum;
if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
reg = IA64_PR_REGNUM;
else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
reg = IA64_UNAT_REGNUM;
/* Let libunwind do most of the work. */
libunwind_frame_prev_register (next_frame, this_cache, reg,
optimizedp, lvalp, addrp, realnump, valuep);
if (VP0_REGNUM <= regnum && regnum <= VP63_REGNUM)
{
ULONGEST prN_val;
if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)
{
int rrb_pr = 0;
ULONGEST cfm;
unsigned char buf[MAX_REGISTER_SIZE];
/* Fetch predicate register rename base from current frame
marker for this frame. */
frame_unwind_register (next_frame, IA64_CFM_REGNUM, buf);
cfm = extract_unsigned_integer (buf, 8); 
rrb_pr = (cfm >> 32) & 0x3f;

/* Adjust the register number to account for register rotation. */
regnum = VP16_REGNUM 
+ ((regnum - VP16_REGNUM) + rrb_pr) % 48;
}
prN_val = extract_bit_field ((unsigned char *) valuep,
regnum - VP0_REGNUM, 1);
store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), prN_val);
}
else if (IA64_NAT0_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)
{
ULONGEST unatN_val;
unatN_val = extract_bit_field ((unsigned char *) valuep,
regnum - IA64_NAT0_REGNUM, 1);
store_unsigned_integer (valuep, register_size (current_gdbarch, regnum), 
unatN_val);
}
else if (regnum == IA64_BSP_REGNUM)
{
char cfm_valuep[MAX_REGISTER_SIZE];
int cfm_optim;
int cfm_realnum;
enum lval_type cfm_lval;
CORE_ADDR cfm_addr;
CORE_ADDR bsp, prev_cfm, prev_bsp;
/* We want to calculate the previous bsp as the end of the previous register stack frame.
This corresponds to what the hardware bsp register will be if we pop the frame
back which is why we might have been called. We know that libunwind will pass us back
the beginning of the current frame so we should just add sof to it. */
prev_bsp = extract_unsigned_integer (valuep, 8);
libunwind_frame_prev_register (next_frame, this_cache, IA64_CFM_REGNUM,
&cfm_optim, &cfm
```
<Overlap Ratio: 0.9793483249196879>

---

--- 183 --
Question ID: c8e3a31875ce057b7270ef653aca542cf61eca2d_1
Original Code:
```
JNICALL
Java_com_intel_realsense_librealsense_FrameQueue_nPollForFrame(JNIEnv *env, jclass type,
                                                               jlong handle) {
    rs2_frame *output_frame = NULL;
    rs2_error *e = NULL;
    int rv = rs2_poll_for_frame((rs2_frame_queue *) handle, &output_frame, &e);
    handle_error(env, e);
    return (jlong) (rv ? output_frame : 0);
}
```


Overlapping Code:
```
NICALL
Java_com_intel_realsense_librealsense_FrameQueue_nPollForFrame(JNIEnv *env, jclass type,
jlong handle) {
rs2_frame *output_frame = NULL;
rs2_error *e = NULL;
int rv = rs2_poll_for_frame((rs2_frame_queue *) handle, &output_frame, &e);
handle_error(env, e);
return (jlong) (rv ? ou
```
<Overlap Ratio: 0.9377049180327869>

---

--- 184 --
Question ID: b865b19cc2945d501b3ee6ca87a635df6ece0f50_41
Original Code:
```
int
main(int argc, char **argv)
{
  const unsigned OneMil = 1 * 1000 * 1000;
  uint64_t start = rdtsc();
  Functor_t f = functor_init(test);
  f.param[0].i = 35;
  f.param[2].i = 13;

  // asm review
  api_call(f);
  manual_call(f);

  // Tests
  for (int i = 0; i < OneMil; ++i) {
    functor_invoke(f);
  }
  uint64_t end1 = rdtsc();
  for (int i = 0; i < OneMil; ++i) {
    test(35, 0, 13);
  }
  uint64_t end2 = rdtsc();
  for (int i = 0; i < OneMil; ++i) {
    getenv("USERFOO");
  }
  uint64_t end3 = rdtsc();

  puts("Performance timing");
  printf("%lu functor %lu indirect %lu direct\n", end1 - start, end2 - end1,
         end3 - end2);

  FuncPointer call_address[] = {
      test_d,   test_i,   test_p,   test_dd,  test_di,  test_dp,  test_id,
      test_ii,  test_ip,  test_pd,  test_pi,  test_pp,  test_ddd, test_ddi,
      test_ddp, test_did, test_dii, test_dip, test_dpd, test_dpi, test_dpp,
      test_idd, test_idi, test_idp, test_iid, test_iii, test_iip, test_ipd,
      test_ipi, test_ipp, test_pdd, test_pdi, test_pdp, test_pid, test_pii,
      test_pip, test_ppd, test_ppi, test_ppp,
  };
  const char *call_name[] = {
      "test_d",   "test_i",   "test_p",   "test_dd",  "test_di",  "test_dp",
      "test_id",  "test_ii",  "test_ip",  "test_pd",  "test_pi",  "test_pp",
      "test_ddd", "test_ddi", "test_ddp", "test_did", "test_dii", "test_dip",
      "test_dpd", "test_dpi", "test_dpp", "test_idd", "test_idi", "test_idp",
      "test_iid", "test_iii", "test_iip", "test_ipd", "test_ipi", "test_ipp",
      "test_pdd", "test_pdi", "test_pdp", "test_pid", "test_pii", "test_pip",
      "test_ppd", "test_ppi", "test_ppp",
  };
  clear_result();
  for (int j = 0; j < ARRAY_LENGTH(call_address); ++j) {
    gf = (Functor_t){.call = call_address[j]};
    printf("\n\nTesting call %s\n", call_name[j]);
    for (int i = 0; i <= PARAM_COUNT; ++i) {
      param_choose_n("dip", i, global_result);
    }
  }

  return 0;
}
```


Overlapping Code:
```
rgv)
{
const unsigned OneMil = 1 * 1000 * 1000;
uint64_t start = rdtsc();
Functor_t f = functor_init(test);
f.param[0].i = 35;
f.param[2].i = 13;
// asm review
api_call(f);
manual_call(f);
// Tests
for (int i = 0; i < OneMil; ++i) {
functor_invoke(f);
}
uint64_t end1 = rdtsc();
for (int i = 0; i < OneMil; ++i) {
test(35, 0, 13);
}
uint64_t end2 = rdtsc();
for (int i = 0; i < OneMil; ++i) {
getenv("USERFOO");
}
uint64_t end3 = rdtsc();
puts("Performance timing");
printf("%lu functor %lu indirect %lu direct\n", end1 - start, end2 - end1,
end3 - end2);
FuncPointer call_address[] = {
test_d, test_i, test_p, test_dd, test_di, test_dp, test_id,
test_ii, test_ip, test_pd, test_pi, test_pp, test_ddd, test_ddi,
test_ddp, test_did, test_dii, test_dip, test_dpd, test_dpi, test_dpp,
test_idd, test_idi, test_idp, test_iid, test_iii, test_iip, test_ipd,
test_ipi, test_ipp, test_pdd, test_pdi, test_pdp, test_pid, test_pii,
test_pip, test_ppd, test_ppi, test_ppp,
};
const char *call_name[] = {
"test_d", "test_i", "test_p", "test_dd", "test_di", "test_dp",
"test_id", "test_ii", "test_ip", "test_pd", "test_pi", "test_pp",
"test_ddd", "test_ddi", "test_ddp", "test_did", "test_dii", "test_dip",
"test_dpd", "test_dpi", "test_dpp", "test_idd", "test_idi", "test_idp",
"test_iid", "test_iii", "test_iip", "test_ipd", "test_ipi", "test_ipp",
"test_pdd", "test_pdi", "test_pdp", "test_pid", "test_pii", "test_pip",
"test_ppd", "test_ppi", "test_ppp",
};
clear_result();
for (int j = 0; j < ARRAY_LENGTH(call_address); ++j) {
gf = (Functor_t){.call = call_address[j]};
printf("\n\nTesting call %s\n", call_name[j]);
for (int i = 0; i <= PARAM_COUNT; ++i) {
param_choose_n("dip", i, global_result);
}
}
retu
```
<Overlap Ratio: 0.9803921568627451>

---

--- 185 --
Question ID: 77951134434f3c4af357f2346a826eaf0e731d40_10
Original Code:
```
int add_watcher_by_pid(JobList* jobs, int pid, int fd){
  JobNode *node = jobs->first;
  while (node != NULL){
    if (node->pid == pid){
      WatcherList *lst = &(node->watcher_list);
      return add_watcher(lst, fd);
    }
    node = node->next;
  }
  return 1;
}
```


Overlapping Code:
```
pid(JobList* jobs, int pid, int fd){
JobNode *node = jobs->first;
while (node != NULL){
if (node->pid == pid){
WatcherList *lst = &(node->watcher_list);
return add_watcher(lst, fd);
}
node = node->nex
```
<Overlap Ratio: 0.851063829787234>

---

--- 186 --
Question ID: d9794c4664cdbf804d2d4421f93172abb61ac15d_2
Original Code:
```
static int luacef_CommandLine_Copy(lua_State *L)
{
	luacef_CommandLine *p = luacef_toudata(L, 1);

	luacef_CommandLine *cpy = p->copy(p);

	luacef_pushudata(L, cpy, __CefCommandLine);
	return 1;
}
```


Overlapping Code:
```
ommandLine_Copy(lua_State *L)
{
luacef_CommandLine *p = luacef_toudata(L, 1);
luacef_CommandLine *cpy = p->copy(p);
luacef_pushudata(L, cpy, __CefComm
```
<Overlap Ratio: 0.7894736842105263>

---

--- 187 --
Question ID: dc3cae8b43d0df9079d0d86f1c458cfafc3a3bd3_1
Original Code:
```
static void sun3_trap_write(sun3 *vm)
{
	sun3_memory_address sp = sun3_address_regs_read_unsigned_long(&vm->address_regs, 7);
	sun3_memory_address sink_addr = sp+sizeof(sun3_unsigned_long);
	sun3_unsigned_long sink = sun3_memory_read_unsigned_long(&vm->memory, sink_addr);
	sun3_memory_address str_addr = sink_addr+sizeof(sun3_unsigned_long);
	sun3_unsigned_long str = sun3_memory_read_unsigned_long(&vm->memory, str_addr);
	sun3_memory_address len_addr = str_addr+sizeof(sun3_unsigned_long);
	sun3_unsigned_long len = sun3_memory_read_unsigned_long(&vm->memory, len_addr);
	int nwritten = sun3_memory_io_write(sink, &vm->memory, str, len);

	nwritten -= len;
	if (nwritten) {
		sun3_sr_set_c(vm->sr, 0);
	} else {
		sun3_sr_set_c(vm->sr, 1);
	}
	sun3_data_regs_write_signed_long(&vm->data_regs, 0, nwritten);
}
```


Overlapping Code:
```
te(sun3 *vm)
{
sun3_memory_address sp = sun3_address_regs_read_unsigned_long(&vm->address_regs, 7);
sun3_memory_address sink_addr = sp+sizeof(sun3_unsigned_long);
sun3_unsigned_long sink = sun3_memory_read_unsigned_long(&vm->memory, sink_addr);
sun3_memory_address str_addr = sink_addr+sizeof(sun3_unsigned_long);
sun3_unsigned_long str = sun3_memory_read_unsigned_long(&vm->memory, str_addr);
sun3_memory_address len_addr = str_addr+sizeof(sun3_unsigned_long);
sun3_unsigned_long len = sun3_memory_read_unsigned_long(&vm->memory, len_addr);
int nwritten = sun3_memory_io_write(sink, &vm->memory, str, len);
nwritten -= len;
if (nwritten) {
sun3_sr_set_c(vm->sr, 0);
} else {
sun3_sr_set_c(vm->sr, 1);
}
sun3_data_regs_write_signed_long(&vm->data_reg
```
<Overlap Ratio: 0.9457755359394704>

---

--- 188 --
Question ID: 50410f384ad99deded8ac286f626c15c3357af6f_0
Original Code:
```
int getSizeOfHT(const HT** ht) {
	int retVal;
	retVal = HASH_COUNT(*ht);
	return retVal;
}
```


Overlapping Code:
```
 retVal;
retVal = HASH_COUNT(*ht);
return retVal;

```
<Overlap Ratio: 0.5747126436781609>

---

--- 189 --
Question ID: 0cc24b4d4cbea9ef763acae849f45fd8b82a0aa4_9
Original Code:
```
void setGraphicsLcdTextPosition(uint8_t x, uint8_t page)
{
    txtIndex = (page << 7) + x;
    setGraphicsLcdPage(page);
    setGraphicsLcdColumn(x);
}
```


Overlapping Code:
```
xtPosition(uint8_t x, uint8_t page)
{
txtIndex = (page << 7) + x;
setGraphicsLcdPage(page);
setGraphicsLcdColumn(x);

```
<Overlap Ratio: 0.841726618705036>

---

--- 190 --
Question ID: 962d14ec0ed84d647e7be19511b7999551b235e5_4
Original Code:
```
static void peci_xec_bus_recovery(const struct device *dev, bool full_reset)
{
	PECI_Type *base = peci_xec_config.base;

	LOG_WRN("%s full_reset:%d", __func__, full_reset);
	if (full_reset) {
		base->CONTROL = MCHP_PECI_CTRL_PD | MCHP_PECI_CTRL_RST;

		if (k_is_in_isr()) {
			k_busy_wait(PECI_RESET_DELAY_MS);
		} else {
			k_msleep(PECI_RESET_DELAY);
		}

		base->CONTROL &= ~MCHP_PECI_CTRL_RST;

		peci_xec_configure(dev, peci_data.bitrate);
	} else {
		/* Only reset internal FIFOs */
		base->CONTROL |= MCHP_PECI_CTRL_FRST;
	}
}
```


Overlapping Code:
```
const struct device *dev, bool full_reset)
{
PECI_Type *base = peci_xec_config.base;
LOG_WRN("%s full_reset:%d", __func__, full_reset);
if (full_reset) {
base->CONTROL = MCHP_PECI_CTRL_PD | MCHP_PECI_CTRL_RST;
if (k_is_in_isr()) {
k_busy_wait(PECI_RESET_DELAY_MS);
} else {
k_msleep(PECI_RESET_DELAY);
}
base->CONTROL &= ~MCHP_PECI_CTRL_RST;
peci_xec_configure(dev, peci_data.bitrate);
} else {
/* Only reset internal FIFOs */
base->CONTROL |= MCHP_P
```
<Overlap Ratio: 0.896414342629482>

---

--- 191 --
Question ID: aa4710dda7712b9b3bc0b2cfe7ecc7f8f4757f70_4
Original Code:
```
static void
adhoc_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,
	int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)
{
	struct ieee80211vap *vap = ni->ni_vap;
	struct ieee80211com *ic = ni->ni_ic;
	struct ieee80211_channel *rxchan = ic->ic_curchan;
	struct ieee80211_frame *wh;
	uint8_t *frm, *efrm;
	uint8_t *ssid, *rates, *xrates;
#if 0
	int ht_state_change = 0;
#endif

	wh = mtod(m0, struct ieee80211_frame *);
	frm = (uint8_t *)&wh[1];
	efrm = mtod(m0, uint8_t *) + m0->m_len;
	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
	case IEEE80211_FC0_SUBTYPE_BEACON: {
		struct ieee80211_scanparams scan;
		struct ieee80211_channel *c;
		/*
		 * We process beacon/probe response
		 * frames to discover neighbors.
		 */ 
		if (rxs != NULL) {
			c = ieee80211_lookup_channel_rxstatus(vap, rxs);
			if (c != NULL)
				rxchan = c;
		}
		if (ieee80211_parse_beacon(ni, m0, rxchan, &scan) != 0)
			return;
		/*
		 * Count frame now that we know it's to be processed.
		 */
		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {
			vap->iv_stats.is_rx_beacon++;		/* XXX remove */
			IEEE80211_NODE_STAT(ni, rx_beacons);
		} else
			IEEE80211_NODE_STAT(ni, rx_proberesp);
		/*
		 * If scanning, just pass information to the scan module.
		 */
		if (ic->ic_flags & IEEE80211_F_SCAN) {
			if (ic->ic_flags_ext & IEEE80211_FEXT_PROBECHAN) {
				/*
				 * Actively scanning a channel marked passive;
				 * send a probe request now that we know there
				 * is 802.11 traffic present.
				 *
				 * XXX check if the beacon we recv'd gives
				 * us what we need and suppress the probe req
				 */
				ieee80211_probe_curchan(vap, 1);
				ic->ic_flags_ext &= ~IEEE80211_FEXT_PROBECHAN;
			}
			ieee80211_add_scan(vap, rxchan, &scan, wh,
			    subtype, rssi, nf);
			return;
		}
		if (scan.capinfo & IEEE80211_CAPINFO_IBSS) {
			if (!IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {
				/*
				 * Create a new entry in the neighbor table.
				 */
				ni = ieee80211_add_neighbor(vap, wh, &scan);
			} else if (ni->ni_capinfo == 0) {
				/*
				 * Update faked node created on transmit.
				 * Note this also updates the tsf.
				 */
				ieee80211_init_neighbor(ni, wh, &scan);
			} else {
				/*
				 * Record tsf for potential resync.
				 */
				memcpy(ni->ni_tstamp.data, scan.tstamp,
					sizeof(ni->ni_tstamp));
			}
			/*
			 * This isn't enabled yet - otherwise it would
			 * update the HT parameters and channel width
			 * from any node, which could lead to lots of
			 * strange behaviour if the 11n nodes aren't
			 * exactly configured to match.
			 */
#if 0
			if (scan.htcap != NULL && scan.htinfo != NULL &&
			    (vap->iv_flags_ht & IEEE80211_FHT_HT)) {
				if (ieee80211_ht_updateparams(ni,
				    scan.htcap, scan.htinfo))
					ht_state_change = 1;
			}
#endif
			if (ni != NULL) {
				IEEE80211_RSSI_LPF(ni->ni_avgrssi, rssi);
				ni->ni_noise = nf;
			}
			/*
			 * Same here - the channel width change should
			 * be applied to the specific peer node, not
			 * to the ic.  Ie, the interface configuration
			 * should stay in its current channel width;
			 * but it should change the rate control and
			 * any queued frames for the given node only.
			 *
			 * Since there's no (current) way to inform
			 * the driver that a channel width change has
			 * occurred for a single node, just stub this
			 * out.
			 */
#if 0
			if (ht_state_change)
				ieee80211_update_chw(ic);
#endif
		}
		break;
	}

	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		if (vap->iv_state != IEEE80211_S_RUN) {
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL, "wrong state %s",
			    ieee80211_state_name[vap->iv_state]);
			vap->iv_stats.is_rx_mgtdiscard++;
			return;
		}
		if (IEEE80211_IS_MULTICAST(wh->i_addr2)) {
			/* frame must be directed */
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL, "%s", "not unicast");
			vap->iv_stats.is_rx_mgtdiscard++;	/* XXX stat */
			return;
		}

		/*
		 * prreq frame format
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 */
		ssid = rates = xrates = NULL;
		while (efrm - frm > 1) {
			IEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);
			switch (*frm) {
			case IEEE80211_ELEMID_SSID:
				ssid = frm;
				break;
			case IEEE80211_ELEMID_RATES:
				rates = frm;
				break;
			case IEEE80211_ELEMID_XRATES:
				xrates = frm;
				break;
			}
			frm += frm[1] + 2;
		}
		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);
		if (xrates != NULL)
			IEEE80211_VERIFY_ELEMENT(xrates,
				IEEE80211_RATE_MAXSIZE - rates[1], return);
		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);
		IEEE80211_VERIFY_SSID(vap->iv_bss, ssid, return);
		if ((vap->iv_flags & IEEE80211_F_HIDESSID) && ssid[1] == 0) {
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL,
			    "%s", "no ssid with ssid suppression enabled");
			vap->iv_stats.is_rx_ssidmismatch++; /*XXX*/
			return;
		}

		/* XXX find a better class or define it's own */
		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_INPUT, wh->i_addr2,
		    "%s", "recv probe req");
		/*
		 * Some legacy 11b clients cannot hack a complete
		 * probe response frame.  When the request includes
		 * only a bare-bones rate set, communicate this to
		 * the transmit side.
		 */
		ieee80211_send_proberesp(vap, wh->i_addr2,
		    is11bclient(rates, xrates) ? IEEE80211_SEND_LEGACY_11B : 0);
		break;

	case IEEE80211_FC0_SUBTYPE_ACTION:
	case IEEE80211_FC0_SUBTYPE_ACTION_NOACK:
		if ((ni == vap->iv_bss) &&
		    !IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL, "%s", "unknown node");
			vap->iv_stats.is_rx_mgtdiscard++;
		} else if (!IEEE80211_ADDR_EQ(vap->iv_myaddr, wh->i_addr1) &&
		    !IEEE80211_IS_MULTICAST(wh->i_addr1)) {
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL, "%s", "not for us");
			vap->iv_stats.is_rx_mgtdiscard++;
		} else if (vap->iv_state != IEEE80211_S_RUN) {
			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
			    wh, NULL, "wrong state %s",
			    ieee80211_state_name[vap->iv_state]);
			vap->iv_stats.is_rx_mgtdiscard++;
		} else {
			if (ieee80211_parse_action(ni, m0) == 0)
				(void)ic->ic_recv_action(ni, wh, frm, efrm);
		}
		break;

	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
	case IEEE80211_FC0_SUBTYPE_TIMING_ADV:
	case IEEE80211_FC0_SUBTYPE_ATIM:
	case IEEE80211_FC0_SUBTYPE_DISASSOC:
	case IEEE80211_FC0_SUBTYPE_AUTH:
	case IEEE80211_FC0_SUBTYPE_DEAUTH:
		IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,
		    wh, NULL, "%s", "not handled");
		vap->iv_stats.is_rx_mgtdiscard++;
		break;

	default:
		IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,
		    wh, "mgt", "subtype 0x%x not handled", subtype);
		vap->iv_stats.is_rx_badsubtype++;
		break;
	}
}
```


Overlapping Code:
```
hoc_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,
int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)
{
struct ieee80211vap *vap = ni->ni_vap;
struct ieee80211com *ic = ni->ni_ic;
struct ieee80211_channel *rxchan = ic->ic_curchan;
struct ieee80211_frame *wh;
uint8_t *frm, *efrm;
uint8_t *ssid, *rates, *xrates;
#if 0
int ht_state_change = 0;
#endif
wh = mtod(m0, struct ieee80211_frame *);
frm = (uint8_t *)&wh[1];
efrm = mtod(m0, uint8_t *) + m0->m_len;
switch (subtype) {
case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
case IEEE80211_FC0_SUBTYPE_BEACON: {
struct ieee80211_scanparams scan;
struct ieee80211_channel *c;
/*
* We process beacon/probe response
* frames to discover neighbors.
*/ 
if (rxs != NULL) {
c = ieee80211_lookup_channel_rxstatus(vap, rxs);
if (c != NULL)
rxchan = c;
}
if (ieee80211_parse_beacon(ni, m0, rxchan, &scan) != 0)
return;
/*
* Count frame now that we know it's to be processed.
*/
if (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {
vap->iv_stats.is_rx_beacon++; /* XXX remove */
IEEE80211_NODE_STAT(ni, rx_beacons);
} else
IEEE80211_NODE_STAT(ni, rx_proberesp);
/*
* If scanning, just pass information to the scan module.
*/
if (ic->ic_flags & IEEE80211_F_SCAN) {
if (ic->ic_flags_ext & IEEE80211_FEXT_PROBECHAN) {
/*
* Actively scanning a channel marked passive;
* send a probe request now that we know there
* is 802.11 traffic present.
*
* XXX check if the beacon we recv'd gives
* us what we need and suppress the probe req
*/
ieee80211_probe_curchan(vap, 1);
ic->ic_flags_ext &= ~IEEE80211_FEXT_PROBECHAN;
}
ieee80211_add_scan(vap, rxchan, &scan, wh,
subtype, rssi, nf);
return;
}
if (scan.capinfo & IEEE80211_CAPINFO_IBSS) {
if (!IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_macaddr)) {
/*
* Create a new entry in the neighbor table.
*/
ni = ieee80211_add_neighbor(vap, wh, &scan);
} else if (ni->ni_capinfo == 0) {
/*
* Update faked node created on transmit.
* Note this also updates the tsf.
*/
ieee80211_init_neighbor(ni, wh, &scan);
} else {
/*
* Record tsf for potential resync.
*/
memcpy(ni->ni_tstamp.data, scan.tstamp,
sizeof(ni->ni_tstamp));
}
/*
* This isn't enabled yet - otherwise it would
* update the HT parameters and channel width
* from
```
<Overlap Ratio: 0.9769094138543517>

---

--- 192 --
Question ID: daa57062031a5c79bb2b842ccb6a86febd5757ba_2
Original Code:
```
int aliyun_log_env_init(const char *json, void **context)
{
	if (log_producer_env_init() != LOG_PRODUCER_OK)
		return -1;

	aliyun_env_t *aliyun_env =
	    (aliyun_env_t *) malloc(sizeof(aliyun_env_t));
	if (!aliyun_env)
		return -2;
	memset(aliyun_env, 0, sizeof(aliyun_env));

	struct json_object *root_obj = json_tokener_parse(json);
	if (!root_obj)
		return -3;

	struct json_object *config_obj;
	json_bool ret =
	    json_object_object_get_ex(root_obj, "logstore_config", &config_obj);
	if (ret == false) {
		json_object_put(root_obj);
		return -4;
	}

	const char *config = json_object_get_string(config_obj);
	memcpy(aliyun_env->config, config, strlen(config) + 1);

	json_object_put(root_obj);

	aliyun_env->producer =
	    create_log_producer_by_config_file(aliyun_env->config, NULL);
	if (!aliyun_env->producer)
		return -5;

	*context = (void *)aliyun_env;

	return 0;
}
```


Overlapping Code:
```
init(const char *json, void **context)
{
if (log_producer_env_init() != LOG_PRODUCER_OK)
return -1;
aliyun_env_t *aliyun_env =
(aliyun_env_t *) malloc(sizeof(aliyun_env_t));
if (!aliyun_env)
return -2;
memset(aliyun_env, 0, sizeof(aliyun_env));
struct json_object *root_obj = json_tokener_parse(json);
if (!root_obj)
return -3;
struct json_object *config_obj;
json_bool ret =
json_object_object_get_ex(root_obj, "logstore_config", &config_obj);
if (ret == false) {
json_object_put(root_obj);
return -4;
}
const char *config = json_object_get_string(config_obj);
memcpy(aliyun_env->config, config, strlen(config) + 1);
json_object_put(root_obj);
aliyun_env->producer =
create_log_producer_by_config_file(aliyun_env->config, NULL);
if (!aliyun_env->producer)
return -5;
*context = (void *)aliyun_env;
r
```
<Overlap Ratio: 0.9650180940892642>

---

--- 193 --
Question ID: 36e6694d5ea4aca25df136abb8f93fe79b469770_0
Original Code:
```
class JSON {
    public:
        JSON();
        void jsonToDocument(string json);

        string serializeNewPlay();
        string serializeNextIteration();
        string serializeGraphic();
        string serializereorder();

        int getRequest();
        List<string> getObstacles();
        List<string> getRoute();
        List<string> getTowers();
        string obs1();
        string rute();
        int getId();
        int getAge();
        float getSurvivalProb();
        int getExpectedGen();
        int getEmocionalIntelligent();
        int getUperStrenght();
        int getLowerStrenght();
        int getResistance();
        int getPhysicalCondition();
        int getTime();
        int getIteration();

        List<int> getGraphicResistance();
        List<int> getGraphicUperStrenght();
        List<int> getGraphicLowerStrenght();
        List<int> getGraphicEmotionalInt();
        List<int> getGraphicPhysicalCond();
        List<int> getGraphicAge();
        List<float> getGraphicSurvivalProb();
        List<int> getGraphicExpectedGen();
        List<int> getGraphicFitness();
        List<int> getGraphicId();
}
```


Overlapping Code:
```

JSON();
void jsonToDocument(string json);
string serializeNewPlay();
string serializeNextIteration();
string serializeGraphic();
string serializereorder();
int getRequest();
List<string> getObstacles();
List<string> getRoute();
List<string> getTowers();
string obs1();
string rute();
int getId();
int getAge();
float getSurvivalProb();
int getExpectedGen();
int getEmocionalIntelligent();
int getUperStrenght();
int getLowerStrenght();
int getResistance();
int getPhysicalCondition();
int getTime();
int getIteration();
List<int> getGraphicResistance();
List<int> getGraphicUperStrenght();
List<int> getGraphicLowerStrenght();
List<int> getGraphicEmotionalInt();
List<int> getGraphicPhysicalCond();
List<int> getGraphicAge();
List<float> getGraphicSurvivalProb();
List<int> getGraphicExpectedGen();
List<int> getGraphicFi
```
<Overlap Ratio: 0.9362186788154897>

---

--- 194 --
Question ID: c655c85926feaff8a0723b4f369c9e6324c4601c_11
Original Code:
```
SEXP attribute_hidden do_D2POSIXlt(SEXP call, SEXP op, SEXP args, SEXP env)
{
    SEXP x, ans, ansnames, klass;
    R_xlen_t n;
    int valid, day, y, tmp, mon;
    stm tm;

    checkArity(op, args);
    PROTECT(x = coerceVector(CAR(args), REALSXP));
    n = XLENGTH(x);
    PROTECT(ans = allocVector(VECSXP, 9));
    for(int i = 0; i < 9; i++)
	SET_VECTOR_ELT(ans, i, allocVector(i > 0 ? INTSXP : REALSXP, n));

    PROTECT(ansnames = allocVector(STRSXP, 9));
    for(int i = 0; i < 9; i++)
	SET_STRING_ELT(ansnames, i, mkChar(ltnames[i]));

    for(R_xlen_t i = 0; i < n; i++) {
	if(R_FINITE(REAL(x)[i])) {
	    day = (int) floor(REAL(x)[i]);
	    tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
	    /* weekday: 1970-01-01 was a Thursday */
	    if ((tm.tm_wday = ((4 + day) % 7)) < 0) tm.tm_wday += 7;

	    /* year & day within year */
	    y = 1970;
	    if (day >= 0)
		for ( ; day >= (tmp = days_in_year(y)); day -= tmp, y++);
	    else
		for ( ; day < 0; --y, day += days_in_year(y) );

	    y = tm.tm_year = y - 1900;
	    tm.tm_yday = day;

	    /* month within year */
	    for (mon = 0;
		 day >= (tmp = (days_in_month[mon]) +
			 ((mon==1 && isleap(y+1900))?1:0));
		 day -= tmp, mon++);
	    tm.tm_mon = mon;
	    tm.tm_mday = day + 1;
	    tm.tm_isdst = 0; /* no dst in GMT */

	    valid = 1;
	} else valid = 0;
	makelt(&tm, ans, i, valid, 0.0);
    }
    setAttrib(ans, R_NamesSymbol, ansnames);
    PROTECT(klass = allocVector(STRSXP, 2));
    SET_STRING_ELT(klass, 0, mkChar("POSIXlt"));
    SET_STRING_ELT(klass, 1, mkChar("POSIXt"));
    classgets(ans, klass);
    SEXP s_tzone = install("tzone");
    setAttrib(ans, s_tzone, mkString("UTC"));
    SEXP nm = getAttrib(x, R_NamesSymbol);
    if(nm != R_NilValue) setAttrib(VECTOR_ELT(ans, 5), R_NamesSymbol, nm);
    UNPROTECT(4);

    return ans;
}
```


Overlapping Code:
```
bute_hidden do_D2POSIXlt(SEXP call, SEXP op, SEXP args, SEXP env)
{
SEXP x, ans, ansnames, klass;
R_xlen_t n;
int valid, day, y, tmp, mon;
stm tm;
checkArity(op, args);
PROTECT(x = coerceVector(CAR(args), REALSXP));
n = XLENGTH(x);
PROTECT(ans = allocVector(VECSXP, 9));
for(int i = 0; i < 9; i++)
SET_VECTOR_ELT(ans, i, allocVector(i > 0 ? INTSXP : REALSXP, n));
PROTECT(ansnames = allocVector(STRSXP, 9));
for(int i = 0; i < 9; i++)
SET_STRING_ELT(ansnames, i, mkChar(ltnames[i]));
for(R_xlen_t i = 0; i < n; i++) {
if(R_FINITE(REAL(x)[i])) {
day = (int) floor(REAL(x)[i]);
tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
/* weekday: 1970-01-01 was a Thursday */
if ((tm.tm_wday = ((4 + day) % 7)) < 0) tm.tm_wday += 7;
/* year & day within year */
y = 1970;
if (day >= 0)
for ( ; day >= (tmp = days_in_year(y)); day -= tmp, y++);
else
for ( ; day < 0; --y, day += days_in_year(y) );
y = tm.tm_year = y - 1900;
tm.tm_yday = day;
/* month within year */
for (mon = 0;
day >= (tmp = (days_in_month[mon]) +
((mon==1 && isleap(y+1900))?1:0));
day -= tmp, mon++);
tm.tm_mon = mon;
tm.tm_mday = day + 1;
tm.tm_isdst = 0; /* no dst in GMT */
valid = 1;
} else valid = 0;
makelt(&tm, ans, i, valid, 0.0);
}
setAttrib(ans, R_NamesSymbol, ansnames);
PROTECT(klass = allocVector(STRSXP, 2));
SET_STRING_ELT(klass, 0, mkChar("POSIXlt"));
SET_STRING_ELT(klass, 1, mkChar("POSIXt"));
classgets(ans, klass);
SEXP s_tzone = install("tzone");
setAttrib(ans, s_tzone, mkString("UTC"));
SEXP nm = getAttrib(x, R_NamesSymbol);
if(nm != R_NilValue) setAttrib(VECTOR_ELT(ans, 5)
```
<Overlap Ratio: 0.9633312616532007>

---

--- 195 --
Question ID: a5ac2ec90a5b0c885446d7e390e91e92f341f267_220
Original Code:
```
static tree
fold_constant_for_init (node, context)
     tree node;
     tree context;
{
  tree op0, op1, val;
  enum tree_code code = TREE_CODE (node);

  switch (code)
    {
    case INTEGER_CST:
      if (node == null_pointer_node)
	return NULL_TREE;
    case STRING_CST:
    case REAL_CST:
      return node;

    case PLUS_EXPR:
    case MINUS_EXPR:
    case MULT_EXPR:
    case TRUNC_MOD_EXPR:
    case RDIV_EXPR:
    case LSHIFT_EXPR:
    case RSHIFT_EXPR:
    case URSHIFT_EXPR:
    case BIT_AND_EXPR:
    case BIT_XOR_EXPR:
    case BIT_IOR_EXPR:
    case TRUTH_ANDIF_EXPR:
    case TRUTH_ORIF_EXPR:
    case EQ_EXPR:
    case NE_EXPR:
    case GT_EXPR:
    case GE_EXPR:
    case LT_EXPR:
    case LE_EXPR:
      op0 = TREE_OPERAND (node, 0);
      op1 = TREE_OPERAND (node, 1);
      val = fold_constant_for_init (op0, context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 0) = val;
      val = fold_constant_for_init (op1, context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 1) = val;
      return patch_binop (node, op0, op1);

    case UNARY_PLUS_EXPR:
    case NEGATE_EXPR:
    case TRUTH_NOT_EXPR:
    case BIT_NOT_EXPR:
    case CONVERT_EXPR:
      op0 = TREE_OPERAND (node, 0);
      val = fold_constant_for_init (op0, context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 0) = val;
      return patch_unaryop (node, op0);
      break;

    case COND_EXPR:
      val = fold_constant_for_init (TREE_OPERAND (node, 0), context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 0) = val;
      val = fold_constant_for_init (TREE_OPERAND (node, 1), context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 1) = val;
      val = fold_constant_for_init (TREE_OPERAND (node, 2), context);
      if (val == NULL_TREE || ! TREE_CONSTANT (val))
	return NULL_TREE;
      TREE_OPERAND (node, 2) = val;
      return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)
	: TREE_OPERAND (node, 2);

    case VAR_DECL:
    case FIELD_DECL:
      if (! FIELD_FINAL (node)
	  || DECL_INITIAL (node) == NULL_TREE)
	return NULL_TREE;
      val = DECL_INITIAL (node);
      /* Guard against infinite recursion. */
      DECL_INITIAL (node) = NULL_TREE;
      val = fold_constant_for_init (val, node);
      if (val != NULL_TREE && TREE_CODE (val) != STRING_CST)
	val = try_builtin_assignconv (NULL_TREE, TREE_TYPE (node), val);
      DECL_INITIAL (node) = val;
      return val;

    case EXPR_WITH_FILE_LOCATION:
      /* Compare java_complete_tree and resolve_expression_name. */
      if (!EXPR_WFL_NODE (node) /* Or a PRIMARY flag ? */
	  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)
	{
	  tree name = EXPR_WFL_NODE (node);
	  tree decl;
	  if (PRIMARY_P (node))
	    return NULL_TREE;
	  else if (! QUALIFIED_P (name))
	    {
	      decl = lookup_field_wrapper (DECL_CONTEXT (context), name);
	      if (decl == NULL_TREE
		  || (! FIELD_STATIC (decl) && ! FIELD_FINAL (decl)))
		return NULL_TREE;
	      return fold_constant_for_init (decl, decl);
	    }
	  else
	    {
	      /* Install the proper context for the field resolution.
		 The prior context is restored once the name is
		 properly qualified. */
	      tree saved_current_class = current_class;
	      /* Wait until the USE_COMPONENT_REF re-write.  FIXME. */
	      current_class = DECL_CONTEXT (context);
	      qualify_ambiguous_name (node);
	      current_class = saved_current_class;
	      if (resolve_field_access (node, &decl, NULL)
		  && decl != NULL_TREE)
		return fold_constant_for_init (decl, decl);
	      return NULL_TREE;
	    }
	}
      else
	{
	  op0 = TREE_OPERAND (node, 0);
	  val = fold_constant_for_init (op0, context);
	  if (val == NULL_TREE || ! TREE_CONSTANT (val))
	    return NULL_TREE;
	  TREE_OPERAND (node, 0) = val;
	  return val;
	}

#ifdef USE_COMPONENT_REF
    case IDENTIFIER:
    case COMPONENT_REF:
      ?;
#endif

    default:
      return NULL_TREE;
    }
}
```


Overlapping Code:
```
ode, context)
tree node;
tree context;
{
tree op0, op1, val;
enum tree_code code = TREE_CODE (node);
switch (code)
{
case INTEGER_CST:
if (node == null_pointer_node)
return NULL_TREE;
case STRING_CST:
case REAL_CST:
return node;
case PLUS_EXPR:
case MINUS_EXPR:
case MULT_EXPR:
case TRUNC_MOD_EXPR:
case RDIV_EXPR:
case LSHIFT_EXPR:
case RSHIFT_EXPR:
case URSHIFT_EXPR:
case BIT_AND_EXPR:
case BIT_XOR_EXPR:
case BIT_IOR_EXPR:
case TRUTH_ANDIF_EXPR:
case TRUTH_ORIF_EXPR:
case EQ_EXPR:
case NE_EXPR:
case GT_EXPR:
case GE_EXPR:
case LT_EXPR:
case LE_EXPR:
op0 = TREE_OPERAND (node, 0);
op1 = TREE_OPERAND (node, 1);
val = fold_constant_for_init (op0, context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 0) = val;
val = fold_constant_for_init (op1, context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 1) = val;
return patch_binop (node, op0, op1);
case UNARY_PLUS_EXPR:
case NEGATE_EXPR:
case TRUTH_NOT_EXPR:
case BIT_NOT_EXPR:
case CONVERT_EXPR:
op0 = TREE_OPERAND (node, 0);
val = fold_constant_for_init (op0, context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 0) = val;
return patch_unaryop (node, op0);
break;
case COND_EXPR:
val = fold_constant_for_init (TREE_OPERAND (node, 0), context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 0) = val;
val = fold_constant_for_init (TREE_OPERAND (node, 1), context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 1) = val;
val = fold_constant_for_init (TREE_OPERAND (node, 2), context);
if (val == NULL_TREE || ! TREE_CONSTANT (val))
return NULL_TREE;
TREE_OPERAND (node, 2) = val;
return integer_zerop (TREE_OPERAND (node, 0)) ? TREE_OPERAND (node, 1)
: TREE_OPERAND (node, 2);
case VAR_DECL:
case FIELD_DECL:
if (! FIELD_FINAL (node)
|| DECL_INITIAL (node) == NULL_TREE)
return NULL_TREE;
val = DECL_INITIAL (node);
/* Guard against infinite recursion. */
DECL_INITIAL (node) = NULL_TREE;
val = fold_constant_for_init (val, node);
if (val != NULL_TRE
```
<Overlap Ratio: 0.9822761194029851>

---

--- 196 --
Question ID: 9e14d82287a166db7579bac1d29811bdecc77083_3
Original Code:
```
static int pasemi_msi_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
{
	unsigned int virq;
	struct msi_desc *entry;
	struct msi_msg msg;
	int hwirq;

	pr_debug("pasemi_msi_setup_msi_irqs, pdev %p nvec %d type %d\n",
		 pdev, nvec, type);

	msg.address_hi = 0;
	msg.address_lo = PASEMI_MSI_ADDR;

	list_for_each_entry(entry, &pdev->msi_list, list) {
		/* Allocate 16 interrupts for now, since that's the grouping for
		 * affinity. This can be changed later if it turns out 32 is too
		 * few MSIs for someone, but restrictions will apply to how the
		 * sources can be changed independently.
		 */
		hwirq = msi_bitmap_alloc_hwirqs(&msi_mpic->msi_bitmap,
						ALLOC_CHUNK);
		if (hwirq < 0) {
			pr_debug("pasemi_msi: failed allocating hwirq\n");
			return hwirq;
		}

		virq = irq_create_mapping(msi_mpic->irqhost, hwirq);
		if (virq == NO_IRQ) {
			pr_debug("pasemi_msi: failed mapping hwirq 0x%x\n",
				  hwirq);
			msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq,
					       ALLOC_CHUNK);
			return -ENOSPC;
		}

		/* Vector on MSI is really an offset, the hardware adds
		 * it to the value written at the magic address. So set
		 * it to 0 to remain sane.
		 */
		mpic_set_vector(virq, 0);

		irq_set_msi_desc(virq, entry);
		irq_set_chip(virq, &mpic_pasemi_msi_chip);
		irq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);

		pr_debug("pasemi_msi: allocated virq 0x%x (hw 0x%x) " \
			 "addr 0x%x\n", virq, hwirq, msg.address_lo);

		/* Likewise, the device writes [0...511] into the target
		 * register to generate MSI [512...1023]
		 */
		msg.data = hwirq-0x200;
		write_msi_msg(virq, &msg);
	}

	return 0;
}
```


Overlapping Code:
```
tup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
{
unsigned int virq;
struct msi_desc *entry;
struct msi_msg msg;
int hwirq;
pr_debug("pasemi_msi_setup_msi_irqs, pdev %p nvec %d type %d\n",
pdev, nvec, type);
msg.address_hi = 0;
msg.address_lo = PASEMI_MSI_ADDR;
list_for_each_entry(entry, &pdev->msi_list, list) {
/* Allocate 16 interrupts for now, since that's the grouping for
* affinity. This can be changed later if it turns out 32 is too
* few MSIs for someone, but restrictions will apply to how the
* sources can be changed independently.
*/
hwirq = msi_bitmap_alloc_hwirqs(&msi_mpic->msi_bitmap,
ALLOC_CHUNK);
if (hwirq < 0) {
pr_debug("pasemi_msi: failed allocating hwirq\n");
return hwirq;
}
virq = irq_create_mapping(msi_mpic->irqhost, hwirq);
if (virq == NO_IRQ) {
pr_debug("pasemi_msi: failed mapping hwirq 0x%x\n",
hwirq);
msi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq,
ALLOC_CHUNK);
return -ENOSPC;
}
/* Vector on MSI is really an offset, the hardware adds
* it to the value written at the magic address. So set
* it to 0 to remain sane.
*/
mpic_set_vector(virq, 0);
irq_set_msi_desc(virq, entry);
irq_set_chip(virq, &mpic_pasemi_msi_chip);
irq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);
pr_debug("pasemi_msi: allocated virq 0x%x (hw 0x%x) " \
"addr 0x%x\n", virq, hwirq, msg.address_lo);
/* Likewise, the device writes [0...511] into the target
* register to generate MSI [512...1023]
*/
msg.data = hwirq-0x200;
write_msi_msg(virq, &msg);

```
<Overlap Ratio: 0.9753989361702128>

---

--- 197 --
Question ID: 31867e4b891b1e582e2490638cc417894337e736_15
Original Code:
```
static int stir_net_close(struct net_device *netdev)
{
	struct stir_cb *stir = netdev_priv(netdev);

	/* Stop transmit processing */
	netif_stop_queue(netdev);

	/* Kill transmit thread */
	kill_proc(stir->thr_pid, SIGTERM, 1);
	wait_for_completion(&stir->thr_exited);
	kfree(stir->fifo_status);

	/* Mop up receive urb's */
	usb_kill_urb(stir->rx_urb);
	
	kfree(stir->io_buf);
	usb_free_urb(stir->rx_urb);
	kfree_skb(stir->rx_buff.skb);

	/* Stop and remove instance of IrLAP */
	if (stir->irlap)
		irlap_close(stir->irlap);

	stir->irlap = NULL;

	return 0;
}
```


Overlapping Code:
```
ir_net_close(struct net_device *netdev)
{
struct stir_cb *stir = netdev_priv(netdev);
/* Stop transmit processing */
netif_stop_queue(netdev);
/* Kill transmit thread */
kill_proc(stir->thr_pid, SIGTERM, 1);
wait_for_completion(&stir->thr_exited);
kfree(stir->fifo_status);
/* Mop up receive urb's */
usb_kill_urb(stir->rx_urb);

kfree(stir->io_buf);
usb_free_urb(stir->rx_urb);
kfree_skb(stir->rx_buff.skb);
/* Stop and remove instance of IrLAP */
if (stir->irlap)
irlap_close(stir->irlap);
stir->irlap = NULL
```
<Overlap Ratio: 0.9514925373134329>

---

--- 198 --
Question ID: 9e8502f324fe0a29e291b5d632be968a310e638e_25
Original Code:
```
static uint8_t pyb_usbdd_EP0_TxSent(USBD_HandleTypeDef *pdev) {
    pyb_usbdd_obj_t *self = (pyb_usbdd_obj_t*)pdev->pClassData;
    self->tx_pending = false;
    #if !USE_USB_POLLING
    // Process now that we have sent a response
    dfu_process();
    #endif
    return USBD_OK;
}
```


Overlapping Code:
```
c uint8_t pyb_usbdd_EP0_TxSent(USBD_HandleTypeDef *pdev) {
pyb_usbdd_obj_t *self = (pyb_usbdd_obj_t*)pdev->pClassData;
self->tx_pending = false;
#if !USE_USB_POLLING
// Process now that we have sent a response
dfu_process();
#endif

```
<Overlap Ratio: 0.9133858267716536>

---

--- 199 --
Question ID: f042e192d2feadd4f32c0188154920771d225fae_0
Original Code:
```
static int
xen_assign_irq_vector(int irq)
{
	struct physdev_irq irq_op;

	irq_op.irq = irq;
	if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))
		return -ENOSPC;

	return irq_op.vector;
}
```


Overlapping Code:
```
_assign_irq_vector(int irq)
{
struct physdev_irq irq_op;
irq_op.irq = irq;
if (HYPERVISOR_physdev_op(PHYSDEVOP_alloc_irq_vector, &irq_op))
return -ENOSPC;
return irq_op.
```
<Overlap Ratio: 0.8802083333333334>

---

--- 200 --
Question ID: 379cb489f75b65e12996b48b6d93bc6b3f40a561_7
Original Code:
```
static void aha1740_getconfig(unsigned int base, unsigned int *irq_level,
			      unsigned int *irq_type,
			      unsigned int *translation)
{
	static int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };

	*irq_level = intab[inb(INTDEF(base)) & 0x7];
	*irq_type  = (inb(INTDEF(base)) & 0x8) >> 3;
	*translation = inb(RESV1(base)) & 0x1;
	outb(inb(INTDEF(base)) | 0x10, INTDEF(base));
}
```


Overlapping Code:
```
tconfig(unsigned int base, unsigned int *irq_level,
unsigned int *irq_type,
unsigned int *translation)
{
static int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };
*irq_level = intab[inb(INTDEF(base)) & 0x7];
*irq_type = (inb(INTDEF(base)) & 0x8) >> 3;
*translation = inb(RESV1(base)) & 0x1;
outb(inb(INTDEF(base)) | 0x10, 
```
<Overlap Ratio: 0.8932584269662921>

---

--- 201 --
Question ID: 71d832f0b5cd9d95837f4850b56004ffa31ae883_1
Original Code:
```
void pinta_test_format(wchar *format_string, wchar *format_argument, wchar *expected)
{
    PintaException exception = PINTA_OK;
    wchar *actual_data;
    i32 test;
    struct
    {
        PintaReference format;
        PintaReference arguments;
        PintaReference item;
        PintaReference actual;
    } gc;
    pinta_assert(format_string != NULL);
    pinta_assert(format_argument != NULL);
    pinta_assert(expected != NULL);

    PINTA_GC_ENTER(core, gc);

    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_string, wcslen(format_string), &gc.format));
    PINTA_CHECK(pinta_lib_array_alloc(core, 1, &gc.arguments));
    PINTA_CHECK(pinta_lib_string_alloc_value(core, format_argument, wcslen(format_argument), &gc.item));
    PINTA_CHECK(pinta_lib_array_set_item(core, &gc.arguments, 0, &gc.item));

    PINTA_CHECK(pinta_lib_format(core, NULL, &gc.format, &gc.arguments, 0, &gc.actual));
    PINTA_CHECK(pinta_lib_string_to_string(core, &gc.actual, &gc.actual));

    actual_data = pinta_string_ref_get_data(&gc.actual);
    test = wcscmp(expected, actual_data);
    sput_fail_if(test != 0, pinta_tests_message(L"failed format (%ls, %ls): expected - %ls, actual - %ls", format_string, format_argument, expected, actual_data));
    if (test != 0)
        test++;

PINTA_EXIT:
    PINTA_GC_EXIT(core);
    if (exception != PINTA_OK)
        sput_fail_if(exception != PINTA_OK, "No exception");
}
```


Overlapping Code:
```
r *format_string, wchar *format_argument, wchar *expected)
{
PintaException exception = PINTA_OK;
wchar *actual_data;
i32 test;
struct
{
PintaReference format;
PintaReference arguments;
PintaReference item;
PintaReference actual;
} gc;
pinta_assert(format_string != NULL);
pinta_assert(format_argument != NULL);
pinta_assert(expected != NULL);
PINTA_GC_ENTER(core, gc);
PINTA_CHECK(pinta_lib_string_alloc_value(core, format_string, wcslen(format_string), &gc.format));
PINTA_CHECK(pinta_lib_array_alloc(core, 1, &gc.arguments));
PINTA_CHECK(pinta_lib_string_alloc_value(core, format_argument, wcslen(format_argument), &gc.item));
PINTA_CHECK(pinta_lib_array_set_item(core, &gc.arguments, 0, &gc.item));
PINTA_CHECK(pinta_lib_format(core, NULL, &gc.format, &gc.arguments, 0, &gc.actual));
PINTA_CHECK(pinta_lib_string_to_string(core, &gc.actual, &gc.actual));
actual_data = pinta_string_ref_get_data(&gc.actual);
test = wcscmp(expected, actual_data);
sput_fail_if(test != 0, pinta_tests_message(L"failed format (%ls, %ls): expected - %ls, actual - %ls", format_string, format_argument, expected, actual_data));
if (test != 0)
test++;
PINTA_EXIT:
PINTA_GC_EXIT(core);
if (exception != PINTA_OK)
sput_fail_if(exception != PINTA_
```
<Overlap Ratio: 0.9615384615384616>

---

--- 202 --
Question ID: 066a48673a3003ceadac8f638984e30da91b6568_5
Original Code:
```
void Mix4bytes(uint8_t *a, uint8_t *b, uint8_t *c, uint8_t *d) 
{
	/* Mix four bytes in a linear way */
	uint8_t aa, bb, cc, dd;

	aa = mul(2,*a)^mul(3,*b)^(*c)^(*d);
	bb = mul(2,*b)^mul(3,*c)^(*d)^(*a);
	cc = mul(2,*c)^mul(3,*d)^(*a)^(*b);
	dd = mul(2,*d)^mul(3,*a)^(*b)^(*c);
	*a = aa;
	*b = bb;
	*c = cc;
	*d = dd;
}
```


Overlapping Code:
```
x4bytes(uint8_t *a, uint8_t *b, uint8_t *c, uint8_t *d) 
{
/* Mix four bytes in a linear way */
uint8_t aa, bb, cc, dd;
aa = mul(2,*a)^mul(3,*b)^(*c)^(*d);
bb = mul(2,*b)^mul(3,*c)^(*d)^(*a);
cc = mul(2,*c)^mul(3,*d)^(*a)^(*b);
dd = mul(2,*d)^mul(3,*a)^(*b)^(*c);
*a = aa;
*b = bb;
*c =
```
<Overlap Ratio: 0.9285714285714286>

---

--- 203 --
Question ID: 4bb6740ddbe2534a1b61f1f0de202d9e45d444cd_3
Original Code:
```
static void print_pkt_binary(odp_packet_t pkt)
{
	uint32_t i;
	uint8_t *pnt = odp_packet_data(pkt);

	OFP_LOG_NO_CTX_NO_LEVEL("PACKET:\n");
	for (i = 0; i < odp_packet_len(pkt); i++)
		OFP_LOG_NO_CTX_NO_LEVEL("%02hhx ", pnt[i]);
	OFP_LOG_NO_CTX_NO_LEVEL("\n");
}
```


Overlapping Code:
```
ary(odp_packet_t pkt)
{
uint32_t i;
uint8_t *pnt = odp_packet_data(pkt);
OFP_LOG_NO_CTX_NO_LEVEL("PACKET:\n");
for (i = 0; i < odp_packet_len(pkt); i++)
OFP_LOG_NO_CTX_NO_LEVEL("%02hhx ", pnt[i]);
OFP
```
<Overlap Ratio: 0.7874015748031497>

---

--- 204 --
Question ID: 5e41487d57aa5ab28fd6afb85df508d0f3db582a_4
Original Code:
```
int
request_looks_dynamic(INKMBuffer bufp, INKMLoc hdr_loc)
{
  INKMLoc url_loc, cookie_loc;
  const char *path;
  const char *query;
  int len;

  INKDebug(MED, "In request_looks_dynamic");

  url_loc = INKHttpHdrUrlGet(bufp, hdr_loc);
  if (url_loc == NULL) {
    INKError("Could not retrieve Url");
    return -1;
  }

  path = INKUrlPathGet(bufp, url_loc, &len);
  if ((path != NULL) && (len > 0)) {
    char *str = INKmalloc(len + 1);
    strncpy(str, path, len);
    str[len] = '\0';

    if ((strstr(str, ASP_EXTENSION) != NULL) || (strstr(str, JSP_EXTENSION) != NULL) || (strstr(str, CGI_BIN) != NULL)) {
      INKHandleStringRelease(bufp, url_loc, path);
      INKHandleMLocRelease(bufp, hdr_loc, url_loc);
      return 1;
    }
    INKHandleStringRelease(bufp, url_loc, path);
  }

  query = INKUrlHttpQueryGet(bufp, url_loc, &len);
  if ((query != NULL) && (len > 0)) {
    INKHandleStringRelease(bufp, url_loc, query);
    INKHandleMLocRelease(bufp, hdr_loc, url_loc);
    return 1;
  }

  cookie_loc = INKMimeHdrFieldRetrieve(bufp, hdr_loc, INK_MIME_FIELD_COOKIE);
  if (cookie_loc != NULL) {
    INKHandleMLocRelease(bufp, hdr_loc, cookie_loc);
    INKHandleMLocRelease(bufp, hdr_loc, url_loc);
    return 1;
  }

  INKHandleMLocRelease(bufp, hdr_loc, url_loc);
  return 0;
}
```


Overlapping Code:
```
ynamic(INKMBuffer bufp, INKMLoc hdr_loc)
{
INKMLoc url_loc, cookie_loc;
const char *path;
const char *query;
int len;
INKDebug(MED, "In request_looks_dynamic");
url_loc = INKHttpHdrUrlGet(bufp, hdr_loc);
if (url_loc == NULL) {
INKError("Could not retrieve Url");
return -1;
}
path = INKUrlPathGet(bufp, url_loc, &len);
if ((path != NULL) && (len > 0)) {
char *str = INKmalloc(len + 1);
strncpy(str, path, len);
str[len] = '\0';
if ((strstr(str, ASP_EXTENSION) != NULL) || (strstr(str, JSP_EXTENSION) != NULL) || (strstr(str, CGI_BIN) != NULL)) {
INKHandleStringRelease(bufp, url_loc, path);
INKHandleMLocRelease(bufp, hdr_loc, url_loc);
return 1;
}
INKHandleStringRelease(bufp, url_loc, path);
}
query = INKUrlHttpQueryGet(bufp, url_loc, &len);
if ((query != NULL) && (len > 0)) {
INKHandleStringRelease(bufp, url_loc, query);
INKHandleMLocRelease(bufp, hdr_loc, url_loc);
return 1;
}
cookie_loc = INKMimeHdrFieldRetrieve(bufp, hdr_loc, INK_MIME_FIELD_COOKIE);
if (cookie_loc != NULL) {
INKHandleMLocRelease(bufp, hdr_loc, cookie_loc);
INKHandleMLocRelease(bufp, hdr_loc, url_loc);
return 1;
}
INKHandleMLocRelease(bufp, hdr_loc, url_loc);
return 0;

```
<Overlap Ratio: 0.9829059829059829>

---

--- 205 --
Question ID: a88826d6263aef0e881de66e56a052018fbd6e56_5
Original Code:
```
void combuf_clearwr2rd(struct combuf*cb){
  if(combuf_state(cb)!=CBWRITE)app_message(FATAL,"attempt to clear a CBREAD combuf to a CBWRITE combuf in combuf_clearwr2rd()");
  cb->state_=CBREAD;
  cb->tmo_=NULL;
  cb->eof_=0;
  buf_reset(cb->buf_,RDBUF);
}
```


Overlapping Code:
```
oid combuf_clearwr2rd(struct combuf*cb){
if(combuf_state(cb)!=CBWRITE)app_message(FATAL,"attempt to clear a CBREAD combuf to a CBWRITE combuf in combuf_clearwr2rd()");
cb->state_=CBREAD;
cb->tmo_=NULL
```
<Overlap Ratio: 0.823045267489712>

---

--- 206 --
Question ID: c40a90d02be4a2f1802ceb5064e298a6fb0e0ee3_0
Original Code:
```
static void
get_rw_operations(float      rw_ratio,
                  int        id,
                  uint64_t * ops)
{
    int i, nr_read = 0, nr_write = 0, start_idx;
    float idx, write_inc;

    *ops = 0;

    nr_write = (int)(64. * (1. - rw_ratio));
    write_inc = (float)(64. / nr_write);

    /* seed with local instance's id */
    srand(VB_BASE_SEED + id);
    start_idx = rand() % 64;

    for (i = 0; i < nr_write; i++) {
        idx = (start_idx + (int)(i * write_inc)) % 64;
        *ops |= (1ULL << (int)idx);
    }
}
```


Overlapping Code:
```
oid
get_rw_operations(float rw_ratio,
int id,
uint64_t * ops)
{
int i, nr_read = 0, nr_write = 0, start_idx;
float idx, write_inc;
*ops = 0;
nr_write = (int)(64. * (1. - rw_ratio));
write_inc = (float)(64. / nr_write);
/* seed with local instance's id */
srand(VB_BASE_SEED + id);
start_idx = rand() % 64;
for (i = 0; i < nr_write; i++) {
idx = (start_idx + (int)(i * write_inc)) % 64;
*ops |= (1ULL 
```
<Overlap Ratio: 0.9411764705882353>

---

--- 207 --
Question ID: d02a1300d8fb957d58f96a0df4fc3f5b3404aab1_7
Original Code:
```
void histogram_imager_load_image_file(HistogramImager *self, const gchar *filename) {
  /* Try to open the given PNG file and load parameters from it */
  const gchar *params;
  GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
  params = gdk_pixbuf_get_option(pixbuf, "tEXt::de_jong_params");
  if (params)
    parameter_holder_load_string(PARAMETER_HOLDER(self), params);
  else
    printf("No parameters chunk found\n");
  gdk_pixbuf_unref(pixbuf);
}
```


Overlapping Code:
```
file(HistogramImager *self, const gchar *filename) {
/* Try to open the given PNG file and load parameters from it */
const gchar *params;
GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
params = gdk_pixbuf_get_option(pixbuf, "tEXt::de_jong_params");
if (params)
parameter_holder_load_string(PARAMETER_HOLDER(self), params);
else
printf("No parameters chunk found\n");
gdk_pixbuf_unref(
```
<Overlap Ratio: 0.9029345372460497>

---

--- 208 --
Question ID: 648b39386988bc8b5400045912c1345e5f91f359_13
Original Code:
```
int
gem_add_rxbuf(struct gem_softc *sc, int idx)
{
	struct gem_rxsoft *rxs = &sc->sc_rxsoft[idx];
	struct mbuf *m;
	int error;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}

#ifdef GEM_DEBUG
/* bzero the packet to check dma */
	memset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);
#endif

	if (rxs->rxs_mbuf != NULL)
		bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);

	rxs->rxs_mbuf = m;

	error = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't load rx DMA map %d, error = %d\n",
		    sc->sc_dev.dv_xname, idx, error);
		panic("gem_add_rxbuf");	/* XXX */
	}

	bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
	    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	GEM_INIT_RXDESC(sc, idx);

	return (0);
}
```


Overlapping Code:
```
d_rxbuf(struct gem_softc *sc, int idx)
{
struct gem_rxsoft *rxs = &sc->sc_rxsoft[idx];
struct mbuf *m;
int error;
MGETHDR(m, M_DONTWAIT, MT_DATA);
if (m == NULL)
return (ENOBUFS);
MCLGET(m, M_DONTWAIT);
if ((m->m_flags & M_EXT) == 0) {
m_freem(m);
return (ENOBUFS);
}
#ifdef GEM_DEBUG
/* bzero the packet to check dma */
memset(m->m_ext.ext_buf, 0, m->m_ext.ext_size);
#endif
if (rxs->rxs_mbuf != NULL)
bus_dmamap_unload(sc->sc_dmatag, rxs->rxs_dmamap);
rxs->rxs_mbuf = m;
error = bus_dmamap_load(sc->sc_dmatag, rxs->rxs_dmamap,
m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
BUS_DMA_READ|BUS_DMA_NOWAIT);
if (error) {
printf("%s: can't load rx DMA map %d, error = %d\n",
sc->sc_dev.dv_xname, idx, error);
panic("gem_add_rxbuf"); /* XXX */
}
bus_dmamap_sync(sc->sc_dmatag, rxs->rxs_dmamap, 0,
rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
GEM_INIT_RXDESC(sc, idx);
```
<Overlap Ratio: 0.9730033745781778>

---

--- 209 --
Question ID: dc4251de71d74257793f4750d858d66e9c78decb_8
Original Code:
```
JNICALL
Java_com_microsoft_sqlserver_jdbc_AuthenticationJNI_SNIIsEqualToCurrentSID(
    JNIEnv *env,
    jclass klass,
    jbyteArray SID,
    jobject logger)
{
    logger_log(env, logger, ENTERING, "SNIIsEqualToCurrentSID");

    /* Do nothing */
    
    logger_log(env, logger, EXITING, "SNIIsEqualToCurrentSID");
    
    return 1;
}
```


Overlapping Code:
```
ava_com_microsoft_sqlserver_jdbc_AuthenticationJNI_SNIIsEqualToCurrentSID(
JNIEnv *env,
jclass klass,
jbyteArray SID,
jobject logger)
{
logger_log(env, logger, ENTERING, "SNIIsEqualToCurrentSID");
/* Do nothing */

logger_log(env, logger, EXITING, "SNIIsEqual
```
<Overlap Ratio: 0.875>

---

--- 210 --
Question ID: c836c718b3bd006619ec6c0aa38ee849157a3c66_1
Original Code:
```
void * auth_simple_init_data() {
    auth_simple_global_data *global = (auth_simple_global_data*)malloc(sizeof(auth_simple_global_data));
    rand_bytes(global->local_client_id, 8);
    rand_bytes((uint8_t*)&global->connection_id, 4);
    global->connection_id &= 0xFFFFFF;
    return global;
}
```


Overlapping Code:
```
 auth_simple_init_data() {
auth_simple_global_data *global = (auth_simple_global_data*)malloc(sizeof(auth_simple_global_data));
rand_bytes(global->local_client_id, 8);
rand_bytes((uint8_t*)&global->connection_id, 4);
global->connection_id &= 0xFFFFFF
```
<Overlap Ratio: 0.9124087591240876>

---

--- 211 --
Question ID: e6959c708e1cfd2b03e3b7013a34bbe15b334338_0
Original Code:
```
int main() {
	float nota1, nota2, nota3, nota4;
	float media;

	scanf("%f %f %f %f", &nota1, &nota2, &nota3, &nota4);
	media = (nota1*2) + (nota2*3) + (nota3*4) + nota4;
	media /= 10;
	printf("Media: %.1f\n", media);

	if (media >= 7.0f) {
		
		printf("Aluno aprovado.\n");

	} else if (media >= 5.0f) {
		
		printf("Aluno em exame.\n");
		scanf("%f",&nota1);
		printf("Nota do exame: %.1f\n", nota1);
		media = (media + nota1) / 2;

		if (media >= 5.0)
			printf("Aluno aprovado.\n");
		else
			printf("Aluno reprovado.\n");

		printf("Media final: %.1f\n", media);
	} else {
		printf("Aluno reprovado.\n");		
	}

	return 0;
}
```


Overlapping Code:
```
{
float nota1, nota2, nota3, nota4;
float media;
scanf("%f %f %f %f", &nota1, &nota2, &nota3, &nota4);
media = (nota1*2) + (nota2*3) + (nota3*4) + nota4;
media /= 10;
printf("Media: %.1f\n", media);
if (media >= 7.0f) {

printf("Aluno aprovado.\n");
} else if (media >= 5.0f) {

printf("Aluno em exame.\n");
scanf("%f",&nota1);
printf("Nota do exame: %.1f\n", nota1);
media = (media + nota1) / 2;
if (media >= 5.0)
printf("Aluno aprovado.\n");
else
printf("Aluno reprovado.\n");
printf("Media final: %.1f\n", media);
} else {
printf("Aluno reprovado.
```
<Overlap Ratio: 0.9466437177280551>

---

--- 212 --
Question ID: 1d40528d2e773253459933cc0d1535cba194632b_71
Original Code:
```
mems_status_t LSM6DS3_ACC_GYRO_W_DRDY_TEMP_on_INT2(
    void *handle, LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_t newValue) {
  u8_t value;

  if (!LSM6DS3_ACC_GYRO_ReadReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))
    return MEMS_ERROR;

  value &= ~LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_MASK;
  value |= newValue;

  if (!LSM6DS3_ACC_GYRO_WriteReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))
    return MEMS_ERROR;

  return MEMS_SUCCESS;
}
```


Overlapping Code:
```
us_t LSM6DS3_ACC_GYRO_W_DRDY_TEMP_on_INT2(
void *handle, LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_t newValue) {
u8_t value;
if (!LSM6DS3_ACC_GYRO_ReadReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))
return MEMS_ERROR;
value &= ~LSM6DS3_ACC_GYRO_INT2_DRDY_TEMP_MASK;
value |= newValue;
if (!LSM6DS3_ACC_GYRO_WriteReg(handle, LSM6DS3_ACC_GYRO_INT2_CTRL, &value, 1))
return MEMS_ERROR;
return MEMS_SUCCESS;
}
```
<Overlap Ratio: 0.9779411764705882>

---

--- 213 --
Question ID: 2485fbfb2d0d07331bf69a6b33f14852704aafc2_382
Original Code:
```
STATIC mp_obj_t mp_lv_roller_get_selected(size_t n_args, const mp_obj_t *args)
{
    const lv_obj_t *roller = mp_to_lv(args[0]);
    uint16_t res = lv_roller_get_selected(roller);
    return mp_obj_new_int_from_uint(res);
}
```


Overlapping Code:
```
et_selected(size_t n_args, const mp_obj_t *args)
{
const lv_obj_t *roller = mp_to_lv(args[0]);
uint16_t res = lv_roller_get_selected(roller);
return mp_o
```
<Overlap Ratio: 0.7251184834123223>

---

--- 214 --
Question ID: bdc19d54efd53cc0d7d231bd776f856f437aef63_8
Original Code:
```
void gfx_triangle( int x1, int y1, int x2, int y2, int x3, int y3 )
{
	gfx_line(x1,y1,x2,y2);
	gfx_line(x2,y2,x3,y3);
	gfx_line(x3,y3,x1,y1);
}
```


Overlapping Code:
```
x_triangle( int x1, int y1, int x2, int y2, int x3, int y3 )
{
gfx_line(x1,y1,x2,y2);
gfx_line(x2,y2,x3,y3);
gfx_line(x
```
<Overlap Ratio: 0.85>

---

--- 215 --
Question ID: 0076b4403713243b0b428778ce3918b7aa34a70f_0
Original Code:
```
any plisp_adc_maxval(any ex) {
  unsigned id;
  u32 res;
  any x, y;

  x = cdr(ex);
  NeedNum(ex, y = EVAL(car(x)));
  id = unBox(y); // get id.
  MOD_CHECK_ID(ex, adc, id);

  res = platform_adc_get_maxval(id);
  return box(res);
}
```


Overlapping Code:
```

u32 res;
any x, y;
x = cdr(ex);
NeedNum(ex, y = EVAL(car(x)));
id = unBox(y); // get id.
MOD_CHECK_ID(ex, adc, id);
res = platform_adc_get_maxval(id);
```
<Overlap Ratio: 0.7089201877934272>

---

--- 216 --
Question ID: eaff4be9909a28a47faa7bd433af9e20c0b40c40_7
Original Code:
```
void cg_propagator( double **propagator, double **source )
{
  double **tmp = alloc_vector();
  vec_zero(tmp);

  fM_transpose( tmp, source );
  cg_MdM( propagator, tmp );
  //fM( tmp, propagator ); //To test cg
  //vec_dmul_add( tmp, tmp, source, -1 );
  free_vector(tmp);
}
```


Overlapping Code:
```
*source )
{
double **tmp = alloc_vector();
vec_zero(tmp);
fM_transpose( tmp, source );
cg_MdM( propagator, tmp );
//fM( tmp, propagator ); //To test cg
//vec_dmul_add( tmp, tmp, source, -1 );
free_vec
```
<Overlap Ratio: 0.7692307692307693>

---

--- 217 --
Question ID: df49518d57b38e42955f608c22e269c56472325b_0
Original Code:
```
int main()
{
    int i,n,x=1,temp,sum=0;

    printf("Enter number of digit:\n");
    scanf("%d",&n);
    int arr[n];
    printf(" Enter digit:");
    for( i=0; i<n; i++)
    {
        scanf("%d",&arr[i]);
    }
    for( i=n-1; i>=n/2; i--)
    {
        temp=arr[i];
        arr[i]=arr[n-i-1];
        arr[n-i-1]=temp;
    }
    for( i=0; i<n; i++)
    {
        sum+=arr[i]*x;
        x=x*10;
    }
    printf("%d",sum);




    return 0;
}
```


Overlapping Code:
```
m=0;
printf("Enter number of digit:\n");
scanf("%d",&n);
int arr[n];
printf(" Enter digit:");
for( i=0; i<n; i++)
{
scanf("%d",&arr[i]);
}
for( i=n-1; i>=n/2; i--)
{
temp=arr[i];
arr[i]=arr[n-i-1];
arr[n-i-1]=temp;
}
for( i=0; i<n; i++)
{
sum+=arr[i]
```
<Overlap Ratio: 0.7692307692307693>

---

--- 218 --
Question ID: 00485776840c5879550f1bc5b83dd4ba1546c048_0
Original Code:
```
namespace onut
{
    unsigned int hash(const std::string &s, unsigned int seed = 0);
    std::string sha1(const std::string& str);
    bool validateEmail(const std::string& email);
    std::string base64_encode(uint8_t const* buf, unsigned int bufLen);
    std::vector<uint8_t> base64_decode(std::string const&);
}
```


Overlapping Code:
```
hash(const std::string &s, unsigned int seed = 0);
std::string sha1(const std::string& str);
bool validateEmail(const std::string& email);
std::string base64_encode(uint8_t const* buf, unsigned int bufLen);
std::vector<uint8_t> base64_decode(std::string 
```
<Overlap Ratio: 0.8639455782312925>

---

--- 219 --
Question ID: 147a3c3336ab9a45f50a007dbbb75f1b4ca2fa64_2
Original Code:
```
static void xdcc_del(char *name)
{
	GSList *list;
	fileoffer *offer;

	list = file_list;
	while(list)
	{
		offer = (fileoffer *) list->data;
		if(strcasecmp(name, offer->file) == 0)
		{
			file_list = g_slist_remove(file_list, offer);
			xchat_printf(ph, "%s [%s] removed.\n", offer->file, offer->fullpath);
			free(offer->file);
			free(offer->desc);
			free(offer->fullpath);
			free(offer);
			return;
		}
		list = list->next;
	}
}
```


Overlapping Code:
```
c_del(char *name)
{
GSList *list;
fileoffer *offer;
list = file_list;
while(list)
{
offer = (fileoffer *) list->data;
if(strcasecmp(name, offer->file) == 0)
{
file_list = g_slist_remove(file_list, offer);
xchat_printf(ph, "%s [%s] removed.\n", offer->file, offer->fullpath);
free(offer->file);
free(offer->desc);
free(offer->fullpath);
free(offer);
r
```
<Overlap Ratio: 0.8838383838383839>

---

--- 220 --
Question ID: b10baacb51c990a47baf396fc606b4f922273a0e_7
Original Code:
```
int mwifiex_set_mgmt_ies(struct mwifiex_private *priv,
			 struct cfg80211_beacon_data *info)
{
	int ret;

	ret = mwifiex_uap_parse_tail_ies(priv, info);

	if (ret)
		return ret;

	return mwifiex_set_mgmt_beacon_data_ies(priv, info);
}
```


Overlapping Code:
```
_set_mgmt_ies(struct mwifiex_private *priv,
struct cfg80211_beacon_data *info)
{
int ret;
ret = mwifiex_uap_parse_tail_ies(priv, info);
if (ret)
return ret;
return mw
```
<Overlap Ratio: 0.7477477477477478>

---

--- 221 --
Question ID: b21106c017ba3453412e360cb8b4f3f47f13a5ee_24
Original Code:
```
CLAUSE dfg_CreateClauseFromTerm(TERM Clause, BOOL IsAxiom, FLAGSTORE Flags,
				PRECEDENCE Precedence)
/**************************************************************
  INPUT:   A clause term, a boolean value, a flag store and a precedence.
  RETURNS: The clause term converted to a CLAUSE.
  EFFECT:  This function converts a clause stored as term into an
           EARL clause structure.
	   If 'IsAxiom' is TRUE the clause is treated as axiom
	   clause else as conjecture clause.
           The function deletes the literals "false" and "not(true)"
           if they occur in <Clause>.
	   The contents of the flag store and the precedence are changed
	   because the parser read flag and precedence settings from
  MEMORY:  The clause term is deleted.
***************************************************************/
{
  LIST   literals, scan;
  TERM   literal;
  CLAUSE result;
  
  if (term_TopSymbol(Clause) == fol_All()) {
    /* Remove and free the quantifier and the OR term */
    literals = term_ArgumentList(term_SecondArgument(Clause));
    term_RplacArgumentList(term_SecondArgument(Clause), list_Nil());
  } else {
    /* Remove and free the OR term */
    literals = term_ArgumentList(Clause);
    term_RplacArgumentList(Clause, list_Nil());
  }
  term_Delete(Clause);

  for (scan = literals; !list_Empty(scan); scan = list_Cdr(scan)) {
    literal = (TERM) list_Car(scan);
    if (symbol_IsPredicate(term_TopSymbol(literal))) {  /* Positive literal */
      if (fol_IsFalse(literal)) {
	/* Ignore this literal */
	term_Delete(literal);
	list_Rplaca(scan, NULL); /* Mark the actual list element */
      }
    } else {
      /* Found a negative literal */
      TERM atom;
      atom = term_FirstArgument(literal);
      if (fol_IsTrue(atom)) {
	/* Ignore this literal */
	term_Delete(literal);
	list_Rplaca(literals, NULL); /* Mark the actual list element */
      }
    }
  }
  

  literals = list_PointerDeleteElement(literals, NULL);
  /* Remove the special literals treated above from the list */
  result = clause_CreateFromLiterals(literals, FALSE, !IsAxiom, FALSE, Flags, Precedence);
  /* Don't create sorts! */
  list_Delete(literals);

  return result;
}
```


Overlapping Code:
```
AUSE dfg_CreateClauseFromTerm(TERM Clause, BOOL IsAxiom, FLAGSTORE Flags,
PRECEDENCE Precedence)
/**************************************************************
INPUT: A clause term, a boolean value, a flag store and a precedence.
RETURNS: The clause term converted to a CLAUSE.
EFFECT: This function converts a clause stored as term into an
EARL clause structure.
If 'IsAxiom' is TRUE the clause is treated as axiom
clause else as conjecture clause.
The function deletes the literals "false" and "not(true)"
if they occur in <Clause>.
The contents of the flag store and the precedence are changed
because the parser read flag and precedence settings from
MEMORY: The clause term is deleted.
***************************************************************/
{
LIST literals, scan;
TERM literal;
CLAUSE result;

if (term_TopSymbol(Clause) == fol_All()) {
/* Remove and free the quantifier and the OR term */
literals = term_ArgumentList(term_SecondArgument(Clause));
term_RplacArgumentList(term_SecondArgument(Clause), list_Nil());
} else {
/* Remove and free the OR term */
literals = term_ArgumentList(Clause);
term_RplacArgumentList(Clause, list_Nil());
}
term_Delete(Clause);
for (scan = literals; !list_Empty(scan); scan = list_Cdr(scan)) {
literal = (TERM) list_Car(scan);
if (symbol_IsPredicate(term_TopSymbol(literal))) { /* Positive literal */
if (fol_IsFalse(literal)) {
/* Ignore this literal */
term_Delete(literal);
list_Rplaca(scan, NULL); /* Mark the actual list element */
}
} else {
/* Found a negative literal */
TERM atom;
atom = term_FirstArgument(literal);
if (fol_IsTrue(atom)) {
/* Ignore this literal */
term_Delete(literal);
list_Rplaca(literals, NULL); /* Mark the actual list element */
}
}
}

literals = list_PointerDeleteElement(literals, NULL);
/* Remove the special literals treated above from the list */
result = clause_CreateFromLiterals(literals, FALSE, !IsAxiom, FALSE, Flags, Precedence);
/* Don't create sorts! */
list_Delete(lite
```
<Overlap Ratio: 0.9874434957307886>

---

--- 222 --
Question ID: e8023ba0cee61cfeab6782ac6c287e3d0a2000eb_1
Original Code:
```
void soc_display_silicon_init_params(const SILICON_INIT_UPD *original,
	SILICON_INIT_UPD *params)
{
	/* Display the parameters for SiliconInit */
	printk(BIOS_SPEW, "UPD values for SiliconInit:\n");
	fsp_display_upd_value("LogoPtr", 4,
			(uint32_t)original->LogoPtr,
			(uint32_t)params->LogoPtr);
	fsp_display_upd_value("LogoSize", 4,
		(uint32_t)original->LogoSize,
		(uint32_t)params->LogoSize);
	fsp_display_upd_value("GraphicsConfigPtr", 4,
		(uint32_t)original->GraphicsConfigPtr,
		(uint32_t)params->GraphicsConfigPtr);
	fsp_display_upd_value("MicrocodeRegionBase", 4,
		(uint32_t)original->MicrocodeRegionBase,
		(uint32_t)params->MicrocodeRegionBase);
	fsp_display_upd_value("MicrocodeRegionSize", 4,
		(uint32_t)original->MicrocodeRegionSize,
		(uint32_t)params->MicrocodeRegionSize);
	fsp_display_upd_value("TurboMode", 1,
		(uint32_t)original->TurboMode,
		(uint32_t)params->TurboMode);
	fsp_display_upd_value("Device4Enable", 1,
		original->Device4Enable,
		params->Device4Enable);
	fsp_display_upd_value("PcieRpEnable[0]", 1, original->PcieRpEnable[0],
		params->PcieRpEnable[0]);
	fsp_display_upd_value("PcieRpEnable[1]", 1, original->PcieRpEnable[1],
		params->PcieRpEnable[1]);
	fsp_display_upd_value("PcieRpEnable[2]", 1, original->PcieRpEnable[2],
		params->PcieRpEnable[2]);
	fsp_display_upd_value("PcieRpEnable[3]", 1, original->PcieRpEnable[3],
		params->PcieRpEnable[3]);
	fsp_display_upd_value("PcieRpEnable[4]", 1, original->PcieRpEnable[4],
		params->PcieRpEnable[4]);
	fsp_display_upd_value("PcieRpEnable[5]", 1, original->PcieRpEnable[5],
		params->PcieRpEnable[5]);
	fsp_display_upd_value("PcieRpEnable[6]", 1, original->PcieRpEnable[6],
		params->PcieRpEnable[6]);
	fsp_display_upd_value("PcieRpEnable[7]", 1, original->PcieRpEnable[7],
		params->PcieRpEnable[7]);
	fsp_display_upd_value("PcieRpEnable[8]", 1, original->PcieRpEnable[8],
		params->PcieRpEnable[8]);
	fsp_display_upd_value("PcieRpEnable[9]", 1, original->PcieRpEnable[9],
		params->PcieRpEnable[9]);
	fsp_display_upd_value("PcieRpEnable[10]", 1, original->PcieRpEnable[10],
		params->PcieRpEnable[10]);
	fsp_display_upd_value("PcieRpEnable[11]", 1, original->PcieRpEnable[11],
		params->PcieRpEnable[11]);
	fsp_display_upd_value("PcieRpEnable[12]", 1, original->PcieRpEnable[12],
		params->PcieRpEnable[12]);
	fsp_display_upd_value("PcieRpEnable[13]", 1, original->PcieRpEnable[13],
		params->PcieRpEnable[13]);
	fsp_display_upd_value("PcieRpEnable[14]", 1, original->PcieRpEnable[14],
		params->PcieRpEnable[14]);
	fsp_display_upd_value("PcieRpEnable[15]", 1, original->PcieRpEnable[15],
		params->PcieRpEnable[15]);
	fsp_display_upd_value("PcieRpEnable[16]", 1, original->PcieRpEnable[16],
		params->PcieRpEnable[16]);
	fsp_display_upd_value("PcieRpEnable[17]", 1, original->PcieRpEnable[17],
		params->PcieRpEnable[17]);
	fsp_display_upd_value("PcieRpEnable[18]", 1, original->PcieRpEnable[18],
		params->PcieRpEnable[18]);
	fsp_display_upd_value("PcieRpEnable[19]", 1, original->PcieRpEnable[19],
		params->PcieRpEnable[19]);
	fsp_display_upd_value("PcieRpClkReqSupport[0]", 1,
		original->PcieRpClkReqSupport[0],
		params->PcieRpClkReqSupport[0]);
	fsp_display_upd_value("PcieRpClkReqSupport[1]", 1,
		original->PcieRpClkReqSupport[1],
		params->PcieRpClkReqSupport[1]);
	fsp_display_upd_value("PcieRpClkReqSupport[2]", 1,
		original->PcieRpClkReqSupport[2],
		params->PcieRpClkReqSupport[2]);
	fsp_display_upd_value("PcieRpClkReqSupport[3]", 1,
		original->PcieRpClkReqSupport[3],
		params->PcieRpClkReqSupport[3]);
	fsp_display_upd_value("PcieRpClkReqSupport[4]", 1,
		original->PcieRpClkReqSupport[4],
		params->PcieRpClkReqSupport[4]);
	fsp_display_upd_value("PcieRpClkReqSupport[5]", 1,
		original->PcieRpClkReqSupport[5],
		params->PcieRpClkReqSupport[5]);
	fsp_display_upd_value("PcieRpClkReqSupport[6]", 1,
		original->PcieRpClkReqSupport[6],
		params->PcieRpClkReqSupport[6]);
	fsp_display_upd_value("PcieRpClkReqSupport[7]", 1,
		original->PcieRpClkReqSupport[7],
		params->PcieRpClkReqSupport[7]);
	fsp_display_upd_value("PcieRpClkReqSupport[8]", 1,
		original->PcieRpClkReqSupport[8],
		params->PcieRpClkReqSupport[8]);
	fsp_display_upd_value("PcieRpClkReqSupport[9]", 1,
		original->PcieRpClkReqSupport[9],
		params->PcieRpClkReqSupport[9]);
	fsp_display_upd_value("PcieRpClkReqSupport[10]", 1,
		original->PcieRpClkReqSupport[10],
		params->PcieRpClkReqSupport[10]);
	fsp_display_upd_value("PcieRpClkReqSupport[11]", 1,
		original->PcieRpClkReqSupport[11],
		params->PcieRpClkReqSupport[11]);
	fsp_display_upd_value("PcieRpClkReqSupport[12]", 1,
		original->PcieRpClkReqSupport[12],
		params->PcieRpClkReqSupport[12]);
	fsp_display_upd_value("PcieRpClkReqSupport[13]", 1,
		original->PcieRpClkReqSupport[13],
		params->PcieRpClkReqSupport[13]);
	fsp_display_upd_value("PcieRpClkReqSupport[14]", 1,
		original->PcieRpClkReqSupport[14],
		params->PcieRpClkReqSupport[14]);
	fsp_display_upd_value("PcieRpClkReqSupport[15]", 1,
		original->PcieRpClkReqSupport[15],
		params->PcieRpClkReqSupport[15]);
	fsp_display_upd_value("PcieRpClkReqSupport[16]", 1,
		original->PcieRpClkReqSupport[16],
		params->PcieRpClkReqSupport[16]);
	fsp_display_upd_value("PcieRpClkReqSupport[17]", 1,
		original->PcieRpClkReqSupport[17],
		params->PcieRpClkReqSupport[17]);
	fsp_display_upd_value("PcieRpClkReqSupport[18]", 1,
		original->PcieRpClkReqSupport[18],
		params->PcieRpClkReqSupport[18]);
	fsp_display_upd_value("PcieRpClkReqSupport[19]", 1,
		original->PcieRpClkReqSupport[19],
		params->PcieRpClkReqSupport[19]);
	fsp_display_upd_value("PcieRpClkReqNumber[0]", 1,
		original->PcieRpClkReqNumber[0],
		params->PcieRpClkReqNumber[0]);
	fsp_display_upd_value("PcieRpClkReqNumber[1]", 1,
		original->PcieRpClkReqNumber[1],
		params->PcieRpClkReqNumber[1]);
	fsp_display_upd_value("PcieRpClkReqNumber[2]", 1,
		original->PcieRpClkReqNumber[2],
		params->PcieRpClkReqNumber[2]);
	fsp_display_upd_value("PcieRpClkReqNumber[3]", 1,
		original->PcieRpClkReqNumber[3],
		params->PcieRpClkReqNumber[3]);
	fsp_display_upd_value("PcieRpClkReqNumber[4]", 1,
		original->PcieRpClkReqNumber[4],
		params->PcieRpClkReqNumber[4]);
	fsp_display_upd_value("PcieRpClkReqNumber[5]", 1,
		original->PcieRpClkReqNumber[5],
		params->PcieRpClkReqNumber[5]);
	fsp_display_upd_value("PcieRpClkReqNumber[6]", 1,
		original->PcieRpClkReqNumber[6],
		params->PcieRpClkReqNumber[6]);
	fsp_display_upd_value("PcieRpClkReqNumber[7]", 1,
		original->PcieRpClkReqNumber[7],
		params->PcieRpClkReqNumber[7]);
	fsp_display_upd_value("PcieRpClkReqNumber[8]", 1,
		original->PcieRpClkReqNumber[8],
		params->PcieRpClkReqNumber[8]);
	fsp_display_upd_value("PcieRpClkReqNumber[9]", 1,
		original->PcieRpClkReqNumber[9],
		params->PcieRpClkReqNumber[9]);
	fsp_display_upd_value("PcieRpClkReqNumber[10]", 1,
		original->PcieRpClkReqNumber[10],
		params->PcieRpClkReqNumber[10]);
	fsp_display_upd_value("PcieRpClkReqNumber[11]", 1,
		original->PcieRpClkReqNumber[11],
		params->PcieRpClkReqNumber[11]);
	fsp_display_upd_value("PcieRpClkReqNumber[12]", 1,
		original->PcieRpClkReqNumber[12],
		params->PcieRpClkReqNumber[12]);
	fsp_display_upd_value("PcieRpClkReqNumber[13]", 1,
		original->PcieRpClkReqNumber[13],
		params->PcieRpClkReqNumber[13]);
	fsp_display_upd_value("PcieRpClkReqNumber[14]", 1,
		original->PcieRpClkReqNumber[14],
		params->PcieRpClkReqNumber[14]);
	fsp_display_upd_value("PcieRpClkReqNumber[15]", 1,
		original->PcieRpClkReqNumber[15],
		params->PcieRpClkReqNumber[15]);
	fsp_display_upd_value("PcieRpClkReqNumber[16]", 1,
		original->PcieRpClkReqNumber[16],
		params->PcieRpClkReqNumber[16]);
	fsp_display_upd_value("PcieRpClkReqNumber[17]", 1,
		original->PcieRpClkReqNumber[17],
		params->PcieRpClkReqNumber[17]);
	fsp_display_upd_value("PcieRpClkReqNumber[18]", 1,
		original->PcieRpClkReqNumber[18],
		params->PcieRpClkReqNumber[18]);
	fsp_display_upd_value("PcieRpClkReqNumber[19]", 1,
		original->PcieRpClkReqNumber[19],
		params->PcieRpClkReqNumber[19]);
	fsp_display_upd_value("EnableLan", 1, original->EnableLan,
		params->EnableLan);
	fsp_display_upd_value("Cio2Enable", 1, original->Cio2Enable,
		params->Cio2Enable);
	fsp_display_upd_value("SataSalpSupport", 1, original->SataSalpSupport,
		params->SataSalpSupport);
	fsp_display_upd_value("SataPortsEnable[0]", 1,
		original->SataPortsEnable[0], params->SataPortsEnable[0]);
	fsp_display_upd_value("SataPortsEnable[1]", 1,
		original->SataPortsEnable[1], params->SataPortsEnable[1]);
	fsp_display_upd_value("SataPortsEnable[2]", 1,
		original->SataPortsEnable[2], params->SataPortsEnable[2]);
	fsp_display_upd_value("SataPortsEnable[3]", 1,
		original->SataPortsEnable[3], params->SataPortsEnable[3]);
	fsp_display_upd_value("SataPortsEnable[4]", 1,
		original->SataPortsEnable[4], params->SataPortsEnable[4]);
	fsp_display_upd_value("SataPortsEnable[5]", 1,
		original->SataPortsEnable[5], params->SataPortsEnable[5]);
	fsp_display_upd_value("SataPortsEnable[6]", 1,
		original->SataPortsEnable[6], params->SataPortsEnable[6]);
	fsp_display_upd_value("SataPortsEnable[7]", 1,
		original->SataPortsEnable[7], params->SataPortsEnable[7]);
	fsp_display_upd_value("SataPortsDevSlp[0]", 1,
		original->SataPortsDevSlp[0], params->SataPortsDevSlp[0]);
	fsp_display_upd_value("SataPortsDevSlp[1]", 1,
		original->SataPortsDevSlp[1], params->SataPortsDevSlp[1]);
	fsp_display_upd_value("SataPortsDevSlp[2]", 1,
		original->SataPortsDevSlp[2], params->SataPortsDevSlp[2]);
	fsp_display_upd_value("SataPortsDevSlp[3]", 1,
		original->SataPortsDevSlp[3], params->SataPortsDevSlp[3]);
	fsp_display_upd_value("SataPortsDevSlp[4]", 1,
		original->SataPortsDevSlp[4], params->SataPortsDevSlp[4]);
	fsp_display_upd_value("SataPortsDevSlp[5]", 1,
		original->SataPortsDevSlp[5], params->SataPortsDevSlp[5]);
	fsp_display_upd_value("SataPortsDevSlp[6]", 1,
		original->SataPortsDevSlp[6], params->SataPortsDevSlp[6]);
	fsp_display_upd_value("SataPortsDevSlp[7]", 1,
		original->SataPortsDevSlp[7], params->SataPortsDevSlp[7]);
	fsp_display_upd_value("EnableAzalia", 1,
		original->EnableAzalia,	params->EnableAzalia);
	fsp_display_upd_value("DspEnable", 1, original->DspEnable,
		params->DspEnable);
	fsp_display_upd_value("IoBufferOwnership", 1,
		original->IoBufferOwnership, params->IoBufferOwnership);
	fsp_display_upd_value("PortUsb20Enable[0]", 1,
		original->PortUsb20Enable[0], params->PortUsb20Enable[0]);
	fsp_display_upd_value("PortUsb20Enable[1]", 1,
		original->PortUsb20Enable[1], params->PortUsb20Enable[1]);
	fsp_display_upd_value("PortUsb20Enable[2]", 1,
		original->PortUsb20Enable[2], params->PortUsb20Enable[2]);
	fsp_display_upd_value("PortUsb20Enable[3]", 1,
		original->PortUsb20Enable[3], params->PortUsb20Enable[3]);
	fsp_display_upd_value("PortUsb20Enable[4]", 1,
		original->PortUsb20Enable[4], params->PortUsb20Enable[4]);
	fsp_display_upd_value("PortUsb20Enable[5]", 1,
		original->PortUsb20Enable[5], params->PortUsb20Enable[5]);
	fsp_display_upd_value("PortUsb20Enable[6]", 1,
		original->PortUsb20Enable[6], params->PortUsb20Enable[6]);
	fsp_display_upd_value("PortUsb20Enable[7]", 1,
		original->PortUsb20Enable[7], params->PortUsb20Enable[7]);
	fsp_display_upd_value("PortUsb20Enable[8]", 1,
		original->PortUsb20Enable[8], params->PortUsb20Enable[8]);
	fsp_display_upd_value("PortUsb20Enable[9]", 1,
		original->PortUsb20Enable[9], params->PortUsb20Enable[9]);
	fsp_display_upd_value("PortUsb20Enable[10]", 1,
		original->PortUsb20Enable[10], params->PortUsb20Enable[10]);
	fsp_display_upd_value("PortUsb20Enable[11]", 1,
		original->PortUsb20Enable[11], params->PortUsb20Enable[11]);
	fsp_display_upd_value("PortUsb20Enable[12]", 1,
		original->PortUsb20Enable[12], params->PortUsb20Enable[12]);
	fsp_display_upd_value("PortUsb20Enable[13]", 1,
		original->PortUsb20Enable[13], params->PortUsb20Enable[13]);
	fsp_display_upd_value("PortUsb20Enable[14]", 1,
		original->PortUsb20Enable[14], params->PortUsb20Enable[14]);
	fsp_display_upd_value("PortUsb20Enable[15]", 1,
		original->PortUsb20Enable[15], params->PortUsb20Enable[15]);
	fsp_display_upd_value("PortUsb30Enable[0]", 1,
		original->PortUsb30Enable[0], params->PortUsb30Enable[0]);
	fsp_display_upd_value("PortUsb30Enable[1]", 1,
		original->PortUsb30Enable[1], params->PortUsb30Enable[1]);
	fsp_display_upd_value("PortUsb30Enable[2]", 1,
		original->PortUsb30Enable[2], params->PortUsb30Enable[2]);
	fsp_display_upd_value("PortUsb30Enable[3]", 1,
		original->PortUsb30Enable[3], params->PortUsb30Enable[3]);
	fsp_display_upd_value("PortUsb30Enable[4]", 1,
		original->PortUsb30Enable[4], params->PortUsb30Enable[4]);
	fsp_display_upd_value("PortUsb30Enable[5]", 1,
		original->PortUsb30Enable[5], params->PortUsb30Enable[5]);
	fsp_display_upd_value("PortUsb30Enable[6]", 1,
		original->PortUsb30Enable[6], params->PortUsb30Enable[6]);
	fsp_display_upd_value("PortUsb30Enable[7]", 1,
		original->PortUsb30Enable[7], params->PortUsb30Enable[7]);
	fsp_display_upd_value("PortUsb30Enable[8]", 1,
		original->PortUsb30Enable[8], params->PortUsb30Enable[8]);
	fsp_display_upd_value("PortUsb30Enable[9]", 1,
		original->PortUsb30Enable[9], params->PortUsb30Enable[9]);
	fsp_display_upd_value("XdciEnable", 1, original->XdciEnable,
		params->XdciEnable);
	fsp_display_upd_value("SsicPortEnable", 1, original->SsicPortEnable,
		params->SsicPortEnable);
	fsp_display_upd_value("SmbusEnable", 1, original->SmbusEnable,
		params->SmbusEnable);
	fsp_display_upd_value("SerialIoDevMode[0]", 1,
		original->SerialIoDevMode[0], params->SerialIoDevMode[0]);
	fsp_display_upd_value("SerialIoDevMode[1]", 1,
		original->SerialIoDevMode[1], params->SerialIoDevMode[1]);
	fsp_display_upd_value("SerialIoDevMode[2]", 1,
		original->SerialIoDevMode[2], params->SerialIoDevMode[2]);
	fsp_display_upd_value("SerialIoDevMode[3]", 1,
		original->SerialIoDevMode[3], params->SerialIoDevMode[3]);
	fsp_display_upd_value("SerialIoDevMode[4]", 1,
		original->SerialIoDevMode[4], params->SerialIoDevMode[4]);
	fsp_display_upd_value("SerialIoDevMode[5]", 1,
		original->SerialIoDevMode[5], params->SerialIoDevMode[5]);
	fsp_display_upd_value("SerialIoDevMode[6]", 1,
		original->SerialIoDevMode[6], params->SerialIoDevMode[6]);
	fsp_display_upd_value("SerialIoDevMode[7]", 1,
		original->SerialIoDevMode[7], params->SerialIoDevMode[7]);
	fsp_display_upd_value("SerialIoDevMode[8]", 1,
		original->SerialIoDevMode[8], params->SerialIoDevMode[8]);
	fsp_display_upd_value("SerialIoDevMode[9]", 1,
		original->SerialIoDevMode[9], params->SerialIoDevMode[9]);
	fsp_display_upd_value("SerialIoDevMode[10]", 1,
		original->SerialIoDevMode[10], params->SerialIoDevMode[10]);
	fsp_display_upd_value("ScsEmmcEnabled", 1, original->ScsEmmcEnabled,
		params->ScsEmmcEnabled);
	fsp_display_upd_value("ScsEmmcHs400Enabled", 1,
		original->ScsEmmcHs400Enabled, params->ScsEmmcHs400Enabled);
	fsp_display_upd_value("ScsSdCardEnabled", 1, original->ScsSdCardEnabled,
		params->ScsSdCardEnabled);
	fsp_display_upd_value("IshEnable", 1, original->IshEnable,
		params->IshEnable);
	fsp_display_upd_value("ShowSpiController", 1,
		original->ShowSpiController, params->ShowSpiController);
	fsp_display_upd_value("HsioMessaging", 1, original->HsioMessaging,
		params->HsioMessaging);
	fsp_display_upd_value("Heci3Enabled", 1, original->Heci3Enabled,
		params->Heci3Enabled);
	fsp_display_upd_value("EnableSata", 1, original->EnableSata,
		params->EnableSata);
	fsp_display_upd_value("SataMode", 1, original->SataMode,
		params->SataMode);
	fsp_display_upd_value("NumOfDevIntConfig", 1,
		original->NumOfDevIntConfig,
		params->NumOfDevIntConfig);
	fsp_display_upd_value("PxRcConfig[PARC]", 1,
		original->PxRcConfig[PCH_PARC],
		params->PxRcConfig[PCH_PARC]);
	fsp_display_upd_value("PxRcConfig[PBRC]", 1,
		original->PxRcConfig[PCH_PBRC],
		params->PxRcConfig[PCH_PBRC]);
	fsp_display_upd_value("PxRcConfig[PCRC]", 1,
		original->PxRcConfig[PCH_PCRC],
		params->PxRcConfig[PCH_PCRC]);
	fsp_display_upd_value("PxRcConfig[PDRC]", 1,
		original->PxRcConfig[PCH_PDRC],
		params->PxRcConfig[PCH_PDRC]);
	fsp_display_upd_value("PxRcConfig[PERC]", 1,
		original->PxRcConfig[PCH_PERC],
		params->PxRcConfig[PCH_PERC]);
	fsp_display_upd_value("PxRcConfig[PFRC]", 1,
		original->PxRcConfig[PCH_PFRC],
		params->PxRcConfig[PCH_PFRC]);
	fsp_display_upd_value("PxRcConfig[PGRC]", 1,
		original->PxRcConfig[PCH_PGRC],
		params->PxRcConfig[PCH_PGRC]);
	fsp_display_upd_value("PxRcConfig[PHRC]", 1,
		original->PxRcConfig[PCH_PHRC],
		params->PxRcConfig[PCH_PHRC]);
	fsp_display_upd_value("GpioIrqRoute", 1,
		original->GpioIrqRoute,
		params->GpioIrqRoute);
	fsp_display_upd_value("SciIrqSelect", 1,
		original->SciIrqSelect,
		params->SciIrqSelect);
	fsp_display_upd_value("TcoIrqSelect", 1,
		original->TcoIrqSelect,
		params->TcoIrqSelect);
	fsp_display_upd_value("TcoIrqEnable", 1,
		original->TcoIrqEnable,
		params->TcoIrqEnable);
	fsp_display_upd_value("LockDownConfigGlobalSmi", 1,
		original->LockDownConfigGlobalSmi,
		params->LockDownConfigGlobalSmi);
	fsp_display_upd_value("LockDownConfigBiosInterface", 1,
		original->LockDownConfigBiosInterface,
		params->LockDownConfigBiosInterface);
	fsp_display_upd_value("LockDownConfigRtcLock", 1,
		original->LockDownConfigRtcLock,
		params->LockDownConfigRtcLock);
	fsp_display_upd_value("LockDownConfigBiosLock", 1,
		original->LockDownConfigBiosLock,
		params->LockDownConfigBiosLock);
	fsp_display_upd_value("LockDownConfigSpiEiss", 1,
		original->LockDownConfigSpiEiss,
		params->LockDownConfigSpiEiss);
	fsp_display_upd_value("PchConfigSubSystemVendorId", 1,
		original->PchConfigSubSystemVendorId,
		params->PchConfigSubSystemVendorId);
	fsp_display_upd_value("PchConfigSubSystemId", 1,
		original->PchConfigSubSystemId,
		params->PchConfigSubSystemId);
	fsp_display_upd_value("WakeConfigWolEnableOverride", 1,
		original->WakeConfigWolEnableOverride,
		params->WakeConfigWolEnableOverride);
	fsp_display_upd_value("WakeConfigPcieWakeFromDeepSx", 1,
		original->WakeConfigPcieWakeFromDeepSx,
		params->WakeConfigPcieWakeFromDeepSx);
	fsp_display_upd_value("PmConfigDeepSxPol", 1,
		original->PmConfigDeepSxPol,
		params->PmConfigDeepSxPol);
	fsp_display_upd_value("PmConfigSlpS3MinAssert", 1,
		original->PmConfigSlpS3MinAssert,
		params->PmConfigSlpS3MinAssert);
	fsp_display_upd_value("PmConfigSlpS4MinAssert", 1,
		original->PmConfigSlpS4MinAssert,
		params->PmConfigSlpS4MinAssert);
	fsp_display_upd_value("PmConfigSlpSusMinAssert", 1,
		original->PmConfigSlpSusMinAssert,
		params->PmConfigSlpSusMinAssert);
	fsp_display_upd_value("PmConfigSlpAMinAssert", 1,
		original->PmConfigSlpAMinAssert,
		params->PmConfigSlpAMinAssert);
	fsp_display_upd_value("PmConfigPciClockRun", 1,
		original->PmConfigPciClockRun,
		params->PmConfigPciClockRun);
	fsp_display_upd_value("PmConfigSlpStrchSusUp", 1,
		original->PmConfigSlpStrchSusUp,
		params->PmConfigSlpStrchSusUp);
	fsp_display_upd_value("PmConfigPwrBtnOverridePeriod", 1,
		original->PmConfigPwrBtnOverridePeriod,
		params->PmConfigPwrBtnOverridePeriod);
	fsp_display_upd_value("PmConfigPwrCycDur", 1,
		original->PmConfigPwrCycDur,
		params->PmConfigPwrCycDur);
	fsp_display_upd_value("SerialIrqConfigSirqEnable", 1,
		original->SerialIrqConfigSirqEnable,
		params->SerialIrqConfigSirqEnable);
	fsp_display_upd_value("SerialIrqConfigSirqMode", 1,
		original->SerialIrqConfigSirqMode,
		params->SerialIrqConfigSirqMode);
	fsp_display_upd_value("SerialIrqConfigStartFramePulse", 1,
		original->SerialIrqConfigStartFramePulse,
		params->SerialIrqConfigStartFramePulse);

	fsp_display_upd_value("Psi1Threshold[0]", 1,
		original->Psi1Threshold[0],
		params->Psi1Threshold[0]);
	fsp_display_upd_value("Psi1Threshold[1]", 1,
		original->Psi1Threshold[1],
		params->Psi1Threshold[1]);
	fsp_display_upd_value("Psi1Threshold[2]", 1,
		original->Psi1Threshold[2],
		params->Psi1Threshold[2]);
	fsp_display_upd_value("Psi1Threshold[3]", 1,
		original->Psi1Threshold[3],
		params->Psi1Threshold[3]);
	fsp_display_upd_value("Psi1Threshold[4]", 1,
		original->Psi1Threshold[4],
		params->Psi1Threshold[4]);
	fsp_display_upd_value("Psi2Threshold[0]", 1,
		original->Psi2Threshold[0],
		params->Psi2Threshold[0]);
	fsp_display_upd_value("Psi2Threshold[1]", 1,
		original->Psi2Threshold[1],
		params->Psi2Threshold[1]);
	fsp_display_upd_value("Psi2Threshold[2]", 1,
		original->Psi2Threshold[2],
		params->Psi2Threshold[2]);
	fsp_display_upd_value("Psi2Threshold[3]", 1,
		original->Psi2Threshold[3],
		params->Psi2Threshold[3]);
	fsp_display_upd_value("Psi2Threshold[4]", 1,
		original->Psi2Threshold[4],
		params->Psi2Threshold[4]);
	fsp_display_upd_value("Psi3Threshold[0]", 1,
		original->Psi3Threshold[0],
		params->Psi3Threshold[0]);
	fsp_display_upd_value("Psi3Threshold[1]", 1,
		original->Psi3Threshold[1],
		params->Psi3Threshold[1]);
	fsp_display_upd_value("Psi3Threshold[2]", 1,
		original->Psi3Threshold[2],
		params->Psi3Threshold[2]);
	fsp_display_upd_value("Psi3Threshold[3]", 1,
		original->Psi3Threshold[3],
		params->Psi3Threshold[3]);
	fsp_display_upd_value("Psi3Threshold[4]", 1,
		original->Psi3Threshold[4],
		params->Psi3Threshold[4]);
	fsp_display_upd_value("Psi3Enable[0]", 1,
		original->Psi3Enable[0],
		params->Psi3Enable[0]);
	fsp_display_upd_value("Psi3Enable[1]", 1,
		original->Psi3Enable[1],
		params->Psi3Enable[1]);
	fsp_display_upd_value("Psi3Enable[2]", 1,
		original->Psi3Enable[2],
		params->Psi3Enable[2]);
	fsp_display_upd_value("Psi3Enable[3]", 1,
		original->Psi3Enable[3],
		params->Psi3Enable[3]);
	fsp_display_upd_value("Psi3Enable[4]", 1,
		original->Psi3Enable[4],
		params->Psi3Enable[4]);
	fsp_display_upd_value("Psi4Enable[0]", 1,
		original->Psi4Enable[0],
		params->Psi4Enable[0]);
	fsp_display_upd_value("Psi4Enable[1]", 1,
		original->Psi4Enable[1],
		params->Psi4Enable[1]);
	fsp_display_upd_value("Psi4Enable[2]", 1,
		original->Psi4Enable[2],
		params->Psi4Enable[2]);
	fsp_display_upd_value("Psi4Enable[3]", 1,
		original->Psi4Enable[3],
		params->Psi4Enable[3]);
	fsp_display_upd_value("Psi4Enable[4]", 1,
		original->Psi4Enable[4],
		params->Psi4Enable[4]);
	fsp_display_upd_value("ImonSlope[0]", 1,
		original->ImonSlope[0],
		params->ImonSlope[0]);
	fsp_display_upd_value("ImonSlope[1]", 1,
		original->ImonSlope[1],
		params->ImonSlope[1]);
	fsp_display_upd_value("ImonSlope[2]", 1,
		original->ImonSlope[2],
		params->ImonSlope[2]);
	fsp_display_upd_value("ImonSlope[3]", 1,
		original->ImonSlope[3],
		params->ImonSlope[3]);
	fsp_display_upd_value("ImonSlope[4]", 1,
		original->ImonSlope[4],
		params->ImonSlope[4]);
	fsp_display_upd_value("ImonOffse[0]t", 1,
		original->ImonOffset[0],
		params->ImonOffset[0]);
	fsp_display_upd_value("ImonOffse[1]t", 1,
		original->ImonOffset[1],
		params->ImonOffset[1]);
	fsp_display_upd_value("ImonOffse[2]t", 1,
		original->ImonOffset[2],
		params->ImonOffset[2]);
	fsp_display_upd_value("ImonOffse[3]t", 1,
		original->ImonOffset[3],
		params->ImonOffset[3]);
	fsp_display_upd_value("ImonOffse[4]t", 1,
		original->ImonOffset[4],
		params->ImonOffset[4]);
	fsp_display_upd_value("IccMax[0]", 1,
		original->IccMax[0],
		params->IccMax[0]);
	fsp_display_upd_value("IccMax[1]", 1,
		original->IccMax[1],
		params->IccMax[1]);
	fsp_display_upd_value("IccMax[2]", 1,
		original->IccMax[2],
		params->IccMax[2]);
	fsp_display_upd_value("IccMax[3]", 1,
		original->IccMax[3],
		params->IccMax[3]);
	fsp_display_upd_value("IccMax[4]", 1,
		original->IccMax[4],
		params->IccMax[4]);
	fsp_display_upd_value("VrVoltageLimit[0]", 1,
		original->VrVoltageLimit[0],
		params->VrVoltageLimit[0]);
	fsp_display_upd_value("VrVoltageLimit[1]", 1,
		original->VrVoltageLimit[1],
		params->VrVoltageLimit[1]);
	fsp_display_upd_value("VrVoltageLimit[2]", 1,
		original->VrVoltageLimit[2],
		params->VrVoltageLimit[2]);
	fsp_display_upd_value("VrVoltageLimit[3]", 1,
		original->VrVoltageLimit[3],
		params->VrVoltageLimit[3]);
	fsp_display_upd_value("VrVoltageLimit[4]", 1,
		original->VrVoltageLimit[4],
		params->VrVoltageLimit[4]);
	fsp_display_upd_value("VrConfigEnable[0]", 1,
		original->VrConfigEnable[0],
		params->VrConfigEnable[0]);
	fsp_display_upd_value("VrConfigEnable[1]", 1,
		original->VrConfigEnable[1],
		params->VrConfigEnable[1]);
	fsp_display_upd_value("VrConfigEnable[2]", 1,
		original->VrConfigEnable[2],
		params->VrConfigEnable[2]);
	fsp_display_upd_value("VrConfigEnable[3]", 1,
		original->VrConfigEnable[3],
		params->VrConfigEnable[3]);
	fsp_display_upd_value("VrConfigEnable[4]", 1,
		original->VrConfigEnable[4],
		params->VrConfigEnable[4]);
	fsp_display_upd_value("SerialIoI2cVoltage[0]", 1,
		original->SerialIoI2cVoltage[0],
		params->SerialIoI2cVoltage[0]);
	fsp_display_upd_value("SerialIoI2cVoltage[1]", 1,
		original->SerialIoI2cVoltage[1],
		params->SerialIoI2cVoltage[1]);
	fsp_display_upd_value("SerialIoI2cVoltage[2]", 1,
		original->SerialIoI2cVoltage[2],
		params->SerialIoI2cVoltage[2]);
	fsp_display_upd_value("SerialIoI2cVoltage[3]", 1,
		original->SerialIoI2cVoltage[3],
		params->SerialIoI2cVoltage[3]);
	fsp_display_upd_value("SerialIoI2cVoltage[4]", 1,
		original->SerialIoI2cVoltage[4],
		params->SerialIoI2cVoltage[4]);
	fsp_display_upd_value("SerialIoI2cVoltage[5]", 1,
		original->SerialIoI2cVoltage[5],
		params->SerialIoI2cVoltage[5]);
	fsp_display_upd_value("SendVrMbxCmd", 1,
		original->SendVrMbxCmd,
		params->SendVrMbxCmd);
	fsp_display_upd_value("AcousticNoiseMitigation", 1,
		original->AcousticNoiseMitigation,
		params->AcousticNoiseMitigation);
	fsp_display_upd_value("SlowSlewRateForIa", 1,
		original->SlowSlewRateForIa,
		params->SlowSlewRateForIa);
	fsp_display_upd_value("SlowSlewRateForGt", 1,
		original->SlowSlewRateForGt,
		params->SlowSlewRateForGt);
	fsp_display_upd_value("SlowSlewRateForSa", 1,
		original->SlowSlewRateForSa,
		params->SlowSlewRateForSa);
	fsp_display_upd_value("FastPkgCRampDisable", 1,
		original->FastPkgCRampDisable,
		params->FastPkgCRampDisable);
}
```


Overlapping Code:
```
void soc_display_silicon_init_params(const SILICON_INIT_UPD *original,
SILICON_INIT_UPD *params)
{
/* Display the parameters for SiliconInit */
printk(BIOS_SPEW, "UPD values for SiliconInit:\n");
fsp_display_upd_value("LogoPtr", 4,
(uint32_t)original->LogoPtr,
(uint32_t)params->LogoPtr);
fsp_display_upd_value("LogoSize", 4,
(uint32_t)original->LogoSize,
(uint32_t)params->LogoSize);
fsp_display_upd_value("GraphicsConfigPtr", 4,
(uint32_t)original->GraphicsConfigPtr,
(uint32_t)params->GraphicsConfigPtr);
fsp_display_upd_value("MicrocodeRegionBase", 4,
(uint32_t)original->MicrocodeRegionBase,
(uint32_t)params->MicrocodeRegionBase);
fsp_display_upd_value("MicrocodeRegionSize", 4,
(uint32_t)original->MicrocodeRegionSize,
(uint32_t)params->MicrocodeRegionSize);
fsp_display_upd_value("TurboMode", 1,
(uint32_t)original->TurboMode,
(uint32_t)params->TurboMode);
fsp_display_upd_value("Device4Enable", 1,
original->Device4Enable,
params->Device4Enable);
fsp_display_upd_value("PcieRpEnable[0]", 1, original->PcieRpEnable[0],
params->PcieRpEnable[0]);
fsp_display_upd_value("PcieRpEnable[1]", 1, original->PcieRpEnable[1],
params->PcieRpEnable[1]);
fsp_display_upd_value("PcieRpEnable[2]", 1, original->PcieRpEnable[2],
params->PcieRpEnable[2]);
fsp_display_upd_value("PcieRpEnable[3]", 1, original->PcieRpEnable[3],
params->PcieRpEnable[3]);
fsp_display_upd_value("PcieRpEnable[4]", 1, original->PcieRpEnable[4],
params->PcieRpEnable[4]);
fsp_display_upd_value("PcieRpEnable[5]", 1, original->PcieRpEnable[5],
params->PcieRpEnable[5]);
fsp_display_upd_value("PcieRpEnable[6]", 1, original->PcieRpEnable[6],
params->PcieRpEnable[6]);
fsp_display_upd_value("PcieRpEnable[7]", 1, original->PcieRpEnable[7],
params->PcieRpEnable[7]);
fsp_display_upd_value("PcieRpEnable[8]", 1, original->PcieRpEnable[8],
params->PcieRpEnable[8]);
fsp_display_upd_value("PcieRpEnable[9]", 1, original->PcieRpEnable[9],
params->PcieRpEnable[9]);
fsp_display_upd_value("PcieRpEnable[10]", 1, original->PcieRpEnable[10],
params->PcieRpEnable[10]);
fsp_display_upd_value("PcieRpEnable[11]", 1, original->PcieRpEnable[11],
params->PcieRpEnable[11]);
fsp_display_upd_value("PcieRpEnable[12]", 1, original->PcieRpEnable[12],
params->PcieRpEnable[12]);
fsp_display_upd_value("PcieRpEnable[13]", 1, original->PcieRpEnable[13],
params->PcieRpEnable[13]);
fsp_display_upd_value("PcieRpEnable[14]", 1, or
```
<Overlap Ratio: 0.9830157415078707>

---

--- 223 --
Question ID: 314d250524b5691759b14f7e7b3aa3ab5a940c5f_4
Original Code:
```
X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)
	{
	X509_NAME_ENTRY *ret;
	int i,n,set_prev,set_next;
	STACK_OF(X509_NAME_ENTRY) *sk;

	if (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc
	    || loc < 0)
		return(NULL);
	sk=name->entries;
	ret=sk_X509_NAME_ENTRY_delete(sk,loc);
	n=sk_X509_NAME_ENTRY_num(sk);
	name->modified=1;
	if (loc == n) return(ret);

	/* else we need to fixup the set field */
	if (loc != 0)
		set_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;
	else
		set_prev=ret->set-1;
	set_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;

	/* set_prev is the previous set
	 * set is the current set
	 * set_next is the following
	 * prev  1 1	1 1	1 1	1 1
	 * set   1	1	2	2
	 * next  1 1	2 2	2 2	3 2
	 * so basically only if prev and next differ by 2, then
	 * re-number down by 1 */
	if (set_prev+1 < set_next)
		for (i=loc; i<n; i++)
			sk_X509_NAME_ENTRY_value(sk,i)->set--;
	return(ret);
	}
```


Overlapping Code:
```
X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc)
{
X509_NAME_ENTRY *ret;
int i,n,set_prev,set_next;
STACK_OF(X509_NAME_ENTRY) *sk;
if (name == NULL || sk_X509_NAME_ENTRY_num(name->entries) <= loc
|| loc < 0)
return(NULL);
sk=name->entries;
ret=sk_X509_NAME_ENTRY_delete(sk,loc);
n=sk_X509_NAME_ENTRY_num(sk);
name->modified=1;
if (loc == n) return(ret);
/* else we need to fixup the set field */
if (loc != 0)
set_prev=(sk_X509_NAME_ENTRY_value(sk,loc-1))->set;
else
set_prev=ret->set-1;
set_next=sk_X509_NAME_ENTRY_value(sk,loc)->set;
/* set_prev is the previous set
* set is the current set
* set_next is the following
* prev 1 1 1 1 1 1 1 1
* set 1 1 2 2
* next 1 1 2 2 2 2 3 2
* so basically only if prev and next differ by 2, then
* re-number down by 1 */
if (set_prev+1 < set_next)
for (i=loc; i<n; i++)
sk_X509_NAME_ENTRY_value(sk,i)->set--;
return(
```
<Overlap Ratio: 0.9920454545454546>

---

--- 224 --
Question ID: c5b721df647b0c5d4a4223b39b040736c0039ab8_2
Original Code:
```
int mod_build_attribute_element_map(CONF_SECTION *conf, void *instance)
{
	rlm_couchbase_t *inst = instance;   /* our module instance */
	CONF_SECTION *cs;                   /* module config section */
	CONF_ITEM *ci;                      /* config item */
	CONF_PAIR *cp;                      /* conig pair */
	const char *attribute, *element;    /* attribute and element names */

	/* find update section */
	cs = cf_section_sub_find(conf, "update");

	/* backwards compatibility */
	if (!cs) {
		cs = cf_section_sub_find(conf, "map");
		WARN("rlm_couchbase: found deprecated 'map' section - please change to 'update'");
	}

	/* check section */
	if (!cs) {
		ERROR("rlm_couchbase: failed to find 'update' section in config");
		/* fail */
		return -1;
	}

	/* create attribute map object */
	inst->map = json_object_new_object();

	/* parse update section */
	for (ci = cf_item_find_next(cs, NULL); ci != NULL; ci = cf_item_find_next(cs, ci)) {
		/* validate item */
		if (!cf_item_is_pair(ci)) {
			ERROR("rlm_couchbase: failed to parse invalid item in 'update' section");
			/* free map */
			if (inst->map) {
				json_object_put(inst->map);
			}
			/* fail */
			return -1;
		}

		/* get value pair from item */
		cp = cf_item_to_pair(ci);

		/* get pair name (attribute name) */
		attribute = cf_pair_attr(cp);

		/* get pair value (element name) */
		element = cf_pair_value(cp);

		/* add pair name and value */
		json_object_object_add(inst->map, attribute, json_object_new_string(element));

		/* debugging */
		DEBUG3("rlm_couchbase: added attribute '%s' to element '%s' mapping", attribute, element);
	}

	/* debugging */
	DEBUG3("rlm_couchbase: built attribute to element mapping %s", json_object_to_json_string(inst->map));

	/* return */
	return 0;
}
```


Overlapping Code:
```
te_element_map(CONF_SECTION *conf, void *instance)
{
rlm_couchbase_t *inst = instance; /* our module instance */
CONF_SECTION *cs; /* module config section */
CONF_ITEM *ci; /* config item */
CONF_PAIR *cp; /* conig pair */
const char *attribute, *element; /* attribute and element names */
/* find update section */
cs = cf_section_sub_find(conf, "update");
/* backwards compatibility */
if (!cs) {
cs = cf_section_sub_find(conf, "map");
WARN("rlm_couchbase: found deprecated 'map' section - please change to 'update'");
}
/* check section */
if (!cs) {
ERROR("rlm_couchbase: failed to find 'update' section in config");
/* fail */
return -1;
}
/* create attribute map object */
inst->map = json_object_new_object();
/* parse update section */
for (ci = cf_item_find_next(cs, NULL); ci != NULL; ci = cf_item_find_next(cs, ci)) {
/* validate item */
if (!cf_item_is_pair(ci)) {
ERROR("rlm_couchbase: failed to parse invalid item in 'update' section");
/* free map */
if (inst->map) {
json_object_put(inst->map);
}
/* fail */
return -1;
}
/* get value pair from item */
cp = cf_item_to_pair(ci);
/* get pair name (attribute name) */
attribute = cf_pair_attr(cp);
/* get pair value (element name) */
element = cf_pair_value(cp);
/* add pair name and value */
json_object_object_add(inst->map, attribute, json_object_new_string(element));
/* debugging */
DEBUG3("rlm_couchbase: added attribute '%s' to element '%s' mapping", attribute, element);
}
/* debugging */
DEBUG3("rlm_couchbase: built attribute to element mapping %s", json_object_to_json_string(inst->map));
/* return */

```
<Overlap Ratio: 0.9801118707271598>

---

--- 225 --
Question ID: 901544a023df04690d80ab7db62eea66490519f5_7
Original Code:
```
static int
re_newbuf_std(struct re_softc *sc, int idx, int init)
{
	bus_dma_segment_t seg;
	bus_dmamap_t map;
	struct mbuf *m;
	int error, nsegs;

	m = m_getcl(init ? M_WAITOK : M_NOWAIT, MT_DATA, M_PKTHDR);
	if (m == NULL) {
		error = ENOBUFS;

		if (init) {
			if_printf(&sc->arpcom.ac_if, "m_getcl failed\n");
			return error;
		} else {
			goto back;
		}
	}
	m->m_len = m->m_pkthdr.len = MCLBYTES;

	/*
	 * NOTE:
	 * re(4) chips need address of the receive buffer to be 8-byte
	 * aligned, so don't call m_adj(m, ETHER_ALIGN) here.
	 */

	error = bus_dmamap_load_mbuf_segment(sc->re_ldata.re_rx_mtag,
			sc->re_ldata.re_rx_spare, m,
			&seg, 1, &nsegs, BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		if (init) {
			if_printf(&sc->arpcom.ac_if, "can't load RX mbuf\n");
			return error;
		} else {
			goto back;
		}
	}

	if (!init) {
		bus_dmamap_sync(sc->re_ldata.re_rx_mtag,
				sc->re_ldata.re_rx_dmamap[idx],
				BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->re_ldata.re_rx_mtag,
				  sc->re_ldata.re_rx_dmamap[idx]);
	}
	sc->re_ldata.re_rx_mbuf[idx] = m;
	sc->re_ldata.re_rx_paddr[idx] = seg.ds_addr;

	map = sc->re_ldata.re_rx_dmamap[idx];
	sc->re_ldata.re_rx_dmamap[idx] = sc->re_ldata.re_rx_spare;
	sc->re_ldata.re_rx_spare = map;
back:
	re_setup_rxdesc(sc, idx);
	return error;
}
```


Overlapping Code:
```
std(struct re_softc *sc, int idx, int init)
{
bus_dma_segment_t seg;
bus_dmamap_t map;
struct mbuf *m;
int error, nsegs;
m = m_getcl(init ? M_WAITOK : M_NOWAIT, MT_DATA, M_PKTHDR);
if (m == NULL) {
error = ENOBUFS;
if (init) {
if_printf(&sc->arpcom.ac_if, "m_getcl failed\n");
return error;
} else {
goto back;
}
}
m->m_len = m->m_pkthdr.len = MCLBYTES;
/*
* NOTE:
* re(4) chips need address of the receive buffer to be 8-byte
* aligned, so don't call m_adj(m, ETHER_ALIGN) here.
*/
error = bus_dmamap_load_mbuf_segment(sc->re_ldata.re_rx_mtag,
sc->re_ldata.re_rx_spare, m,
&seg, 1, &nsegs, BUS_DMA_NOWAIT);
if (error) {
m_freem(m);
if (init) {
if_printf(&sc->arpcom.ac_if, "can't load RX mbuf\n");
return error;
} else {
goto back;
}
}
if (!init) {
bus_dmamap_sync(sc->re_ldata.re_rx_mtag,
sc->re_ldata.re_rx_dmamap[idx],
BUS_DMASYNC_POSTREAD);
bus_dmamap_unload(sc->re_ldata.re_rx_mtag,
sc->re_ldata.re_rx_dmamap[idx]);
}
sc->re_ldata.re_rx_mbuf[idx] = m;
sc->re_ldata.re_rx_paddr[idx] = seg.ds_addr;
map = sc->re_ldata.re_rx_dmamap[idx];
sc->re_ldata.re_rx_dmamap[idx] = sc->re_ldata.re_rx_spare;
sc->re_ldata.re_rx_spare = map;
back:
re_setup_rxdesc(sc, idx);
return er
```
<Overlap Ratio: 0.9775>

---

--- 226 --
Question ID: 1fe860084db624f1b6ace61076b3d0c1ea0e92d8_4
Original Code:
```
void open_bit_stream_r(bs, bs_filenam, size)
bitstream_t *bs;   /* bit stream structure */
char *bs_filenam;       /* name of the bit stream file */
int size;               /* size of the buffer */
{
   register unsigned long n;
   register unsigned char flag = 1;
   unsigned char val;
	
   if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
      printf("Could not find \"%s\".\n", bs_filenam);
      exit(1);
   }

   do {
     n = fread(&val, sizeof(unsigned char), 1, bs->pt);
     switch (val) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0xa:  /* \n */
      case 0xd:  /* cr */
      case 0x1a:  /* sub */
          break;

      default: /* detection of an binary character */
          flag--;
          break;
     }

   } while (flag & n);

   if (flag) {
      printf ("the bit stream file %s is an ASCII file\n", bs_filenam);
      bs->format = ASCII;
   }
   else {
      bs->format = BINARY;
      printf ("the bit stream file %s is a BINARY file\n", bs_filenam);
   }

   fclose(bs->pt);

   if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
      printf("Could not find \"%s\".\n", bs_filenam);
      exit(1);
   }

   alloc_buffer(bs, size);
   bs->buf_byte_idx=0;
   bs->buf_bit_idx=0;
   bs->totbit=0;
   bs->mode = READ_MODE;
   bs->eob = FALSE;
   bs->eobs = FALSE;
}
```


Overlapping Code:
```
id open_bit_stream_r(bs, bs_filenam, size)
bitstream_t *bs; /* bit stream structure */
char *bs_filenam; /* name of the bit stream file */
int size; /* size of the buffer */
{
register unsigned long n;
register unsigned char flag = 1;
unsigned char val;

if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
printf("Could not find \"%s\".\n", bs_filenam);
exit(1);
}
do {
n = fread(&val, sizeof(unsigned char), 1, bs->pt);
switch (val) {
case 0x30:
case 0x31:
case 0x32:
case 0x33:
case 0x34:
case 0x35:
case 0x36:
case 0x37:
case 0x38:
case 0x39:
case 0x41:
case 0x42:
case 0x43:
case 0x44:
case 0x45:
case 0x46:
case 0xa: /* \n */
case 0xd: /* cr */
case 0x1a: /* sub */
break;
default: /* detection of an binary character */
flag--;
break;
}
} while (flag & n);
if (flag) {
printf ("the bit stream file %s is an ASCII file\n", bs_filenam);
bs->format = ASCII;
}
else {
bs->format = BINARY;
printf ("the bit stream file %s is a BINARY file\n", bs_filenam);
}
fclose(bs->pt);
if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
printf("Could not find \"%s\".\n", bs_filenam);
exit(1);
}
alloc_buffer(bs, size);
bs->buf_byte_idx=0;
bs->buf_bit_idx=0;
bs->totbit=0;
bs->mode = READ_MODE;
bs->eob = FALSE;
bs->e
```
<Overlap Ratio: 0.9868852459016394>

---

--- 227 --
Question ID: 10ebc3316cedbe14c8e132478528cf10b4da9ec3_0
Original Code:
```
void Do_Movement()
	{
		// CameraViewModel controls
		if (keys[GLFW_KEY_W])
			camera.ProcessKeyboard(FORWARD, deltaTime);
		if (keys[GLFW_KEY_S])
			camera.ProcessKeyboard(BACKWARD, deltaTime);
		if (keys[GLFW_KEY_A])
			camera.ProcessKeyboard(LEFT, deltaTime);
		if (keys[GLFW_KEY_D])
			camera.ProcessKeyboard(RIGHT, deltaTime);
	}
```


Overlapping Code:
```
oid Do_Movement()
{
// CameraViewModel controls
if (keys[GLFW_KEY_W])
camera.ProcessKeyboard(FORWARD, deltaTime);
if (keys[GLFW_KEY_S])
camera.ProcessKeyboard(BACKWARD, deltaTime);
if (keys[GLFW_KEY_A])
camera.ProcessKeyboard(LEFT, deltaTime);
if (keys[GLFW_KEY_D])
camera.ProcessKeyboard(RIGHT, deltaTime);
```
<Overlap Ratio: 0.9903225806451613>

---

--- 228 --
Question ID: f0107fc6aa1f8cfe99c144a85e3ecc156e12dff9_2
Original Code:
```
SEC_BOOL SecMutex_TryLock(pthread_mutex_t *mutex)
{
    int ret;

    SEC_TRACE(SEC_TRACE_MUTEX, "TRYLOCK %p", mutex);
    ret = pthread_mutex_trylock(mutex);

#ifdef SEC_USE_ROBUST_MUTEX
    if (ret == EOWNERDEAD) {
        SEC_LOG_ERROR("Dead mutex owner detected.  Attempting to recover.");

        ret = pthread_mutex_consistent(mutex);
        if (0 != ret)
        {
            SEC_LOG_ERROR("pthread_mutex_consistent failed with error code %d", ret);
            goto done;
        }

        SEC_LOG_ERROR("mutex recovered.");
    }
#endif

    if (ret == 0) {
        SEC_TRACE(SEC_TRACE_MUTEX, "LOCKED %p", mutex);
    }

#ifdef SEC_USE_ROBUST_MUTEX
done:
#endif
    return ret == 0;
}
```


Overlapping Code:
```
OL SecMutex_TryLock(pthread_mutex_t *mutex)
{
int ret;
SEC_TRACE(SEC_TRACE_MUTEX, "TRYLOCK %p", mutex);
ret = pthread_mutex_trylock(mutex);
#ifdef SEC_USE_ROBUST_MUTEX
if (ret == EOWNERDEAD) {
SEC_LOG_ERROR("Dead mutex owner detected. Attempting to recover.");
ret = pthread_mutex_consistent(mutex);
if (0 != ret)
{
SEC_LOG_ERROR("pthread_mutex_consistent failed with error code %d", ret);
goto done;
}
SEC_LOG_ERROR("mutex recovered.");
}
#endif
if (ret == 0) {
SEC_TRACE(SEC_TRACE_MUTEX, "LOCKED %p", mutex);
}
#ifdef SEC_USE_ROBUST_MUTEX
done:
#en
```
<Overlap Ratio: 0.9515570934256056>

---

--- 229 --
Question ID: babde3776eae777d104d8f4ca2b7cf6f236a36fe_0
Original Code:
```
void test_ioexp_led_input(void)
{
    /* Test a couple of different arbitrary input values */
    uint8_t input_val = 0xff;

    SX1509_regs[0x11] = 0xF2;
    TEST_ASSERT_EQUAL(
        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_A, &input_val));
    TEST_ASSERT_EQUAL_HEX8(0xF2, input_val);

    SX1509_regs[0x10] = 0x04;
    TEST_ASSERT_EQUAL(
        RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_B, &input_val));
    TEST_ASSERT_EQUAL_HEX8(0x04, input_val);
}
```


Overlapping Code:
```
d test_ioexp_led_input(void)
{
/* Test a couple of different arbitrary input values */
uint8_t input_val = 0xff;
SX1509_regs[0x11] = 0xF2;
TEST_ASSERT_EQUAL(
RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_A, &input_val));
TEST_ASSERT_EQUAL_HEX8(0xF2, input_val);
SX1509_regs[0x10] = 0x04;
TEST_ASSERT_EQUAL(
RETURN_OK, ioexp_led_get_data(&s_sx1509_dev, SX1509_REG_B, &input_val));
TEST_ASSER
```
<Overlap Ratio: 0.9195402298850575>

---

--- 230 --
Question ID: 9af5102736dc3e8731f378c8bf99d53c05b4cc13_11
Original Code:
```
static void rehashtab(lua_State *L, GCtab *t, cTValue *ek)
{
  uint32_t bins[LJ_MAX_ABITS];
  uint32_t total, asize, na, i;
  for (i = 0; i < LJ_MAX_ABITS; i++) bins[i] = 0;
  asize = countarray(t, bins);
  total = 1 + asize + counthash(t, bins, &asize);
  asize += countint(ek, bins);
  na = bestasize(bins, &asize);
  total -= na;
  resizetab(L, t, asize, hsize2hbits(total));
}
```


Overlapping Code:
```
 GCtab *t, cTValue *ek)
{
uint32_t bins[LJ_MAX_ABITS];
uint32_t total, asize, na, i;
for (i = 0; i < LJ_MAX_ABITS; i++) bins[i] = 0;
asize = countarray(t, bins);
total = 1 + asize + counthash(t, bins, &asize);
asize += countint(ek, bins);
na = bestasize(bins, &asize);
total -= na;
resizetab(L, t, as
```
<Overlap Ratio: 0.8287292817679558>

---

--- 231 --
Question ID: cf74a9b7f92d9a6c1e681da5e38982d8f08fb104_13
Original Code:
```
ZEND_API int zend_parse_method_parameters_ex(int flags, int num_args TSRMLS_DC, zval *this_ptr, char *type_spec, ...) /* {{{ */
{
	va_list va;
	int retval;
	char *p = type_spec;
	zval **object;
	zend_class_entry *ce;
	int quiet = flags & ZEND_PARSE_PARAMS_QUIET;

	if (!this_ptr) {
		RETURN_IF_ZERO_ARGS(num_args, p, quiet);

		va_start(va, type_spec);
		retval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);
		va_end(va);
	} else {
		p++;
		RETURN_IF_ZERO_ARGS(num_args-1, p, quiet);

		va_start(va, type_spec);

		object = va_arg(va, zval **);
		ce = va_arg(va, zend_class_entry *);
		*object = this_ptr;

		if (ce && !instanceof_function(Z_OBJCE_P(this_ptr), ce TSRMLS_CC)) {
			if (!quiet) {
				zend_error(E_CORE_ERROR, "%s::%s() must be derived from %s::%s",
					ce->name, get_active_function_name(TSRMLS_C), Z_OBJCE_P(this_ptr)->name, get_active_function_name(TSRMLS_C));
			}
			return FAILURE;
		}

		retval = zend_parse_va_args(num_args, p, &va, flags TSRMLS_CC);
		va_end(va);
	}
	return retval;
}
```


Overlapping Code:
```
END_API int zend_parse_method_parameters_ex(int flags, int num_args TSRMLS_DC, zval *this_ptr, char *type_spec, ...) /* {{{ */
{
va_list va;
int retval;
char *p = type_spec;
zval **object;
zend_class_entry *ce;
int quiet = flags & ZEND_PARSE_PARAMS_QUIET;
if (!this_ptr) {
RETURN_IF_ZERO_ARGS(num_args, p, quiet);
va_start(va, type_spec);
retval = zend_parse_va_args(num_args, type_spec, &va, flags TSRMLS_CC);
va_end(va);
} else {
p++;
RETURN_IF_ZERO_ARGS(num_args-1, p, quiet);
va_start(va, type_spec);
object = va_arg(va, zval **);
ce = va_arg(va, zend_class_entry *);
*object = this_ptr;
if (ce && !instanceof_function(Z_OBJCE_P(this_ptr), ce TSRMLS_CC)) {
if (!quiet) {
zend_error(E_CORE_ERROR, "%s::%s() must be derived from %s::%s",
ce->name, get_active_function_name(TSRMLS_C), Z_OBJCE_P(this_ptr)->name, get_active_function_name(TSRMLS_C));
}
return FAILURE;
}
retval = zend_parse_va_args(num_args, p, &va, flags TSRMLS_CC);
va_end(va);
}
return
```
<Overlap Ratio: 0.9886010362694301>

---

--- 232 --
Question ID: d5d0fa98867aa7f61eed68d2a867cb18648f7bb9_0
Original Code:
```
class DevToolsBridgeClientBrowserTest : public WebUIBrowserTest {
 public:
  DevToolsBridgeClientBrowserTest();
  ~DevToolsBridgeClientBrowserTest() override;

  // InProcessBrowserTest overrides.
  void SetUpOnMainThread() override;
  void TearDownOnMainThread() override;
  content::WebUIMessageHandler* GetMockMessageHandler() override;

 private:
  class DevToolsBridgeClientMock;
  class GCDApiFlowMock;
  class MessageHandler;

  scoped_ptr<FakeSigninManagerForTesting> fake_signin_manager_;
  scoped_ptr<ProfileOAuth2TokenService> fake_token_service_;
  base::WeakPtr<DevToolsBridgeClientMock> client_mock_;
  scoped_ptr<MessageHandler> handler_;
  std::map<int, GCDApiFlowMock*> flows_;
  int last_flow_id_;
}
```


Overlapping Code:
```
serTest : public WebUIBrowserTest {
public:
DevToolsBridgeClientBrowserTest();
~DevToolsBridgeClientBrowserTest() override;
// InProcessBrowserTest overrides.
void SetUpOnMainThread() override;
void TearDownOnMainThread() override;
content::WebUIMessageHandler* GetMockMessageHandler() override;
private:
class DevToolsBridgeClientMock;
class GCDApiFlowMock;
class MessageHandler;
scoped_ptr<FakeSigninManagerForTesting> fake_signin_manager_;
scoped_ptr<ProfileOAuth2TokenService> fake_token_service_;
base::WeakPtr<DevToolsBridgeClientMock> client_mock_;
scoped_ptr<MessageHandler> handler_;
std::map<int, GCDApiFlowMock*> flows_;
int last_flow_id_;
```
<Overlap Ratio: 0.9530791788856305>

---

--- 233 --
Question ID: 06fa456587a770cb16116fb3b937d47747efbc58_0
Original Code:
```
namespace DispSvr
{
	class CIntelFastCompositingMixer :
		public virtual BASE_VIDEO_MIXER,
		public virtual CD3D9VideoPresenter
	{
	public:
		CIntelFastCompositingMixer();
		virtual ~CIntelFastCompositingMixer();

		// IUnkonwn
		STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
		STDMETHOD_(ULONG, AddRef)() { return CD3D9PluginBase::AddRef();	}
		STDMETHOD_(ULONG, Release)() { return CD3D9PluginBase::Release(); }

		// IDispSvrPlugin
		STDMETHOD(ProcessMessage)(RESOURCE_MESSAGE_TYPE msg, LPVOID ulParam);

		// CD3D9VideoPresenterBase
		STDMETHOD(SetDisplayRect)(const RECT *rcDst, const RECT *rcSrc);
		STDMETHOD(Present)(const PresentHints *pHints);
		STDMETHOD(SetScreenCaptureDefense)(BOOL bEnable);
		STDMETHOD(SetBackgroundColor)(COLORREF Color);
		STDMETHOD(SetGamutMetadata)(const DWORD dwFormat, void *pGamutMetadata);

	private:
		// CD3D9VideoMixerBase
		STDMETHOD(_QueryPlaneCaps)(PLANE_ID PlaneID, PLANE_FORMAT Format, PlaneCaps *pCap);
		STDMETHOD(_CreatePlane)(DispSvr::PlaneInit *pInit);
		STDMETHOD(_Execute)(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
		STDMETHOD(_SetDevice)(IUnknown *pDevice);
		STDMETHOD(_ReleaseDevice)();
		STDMETHOD(_QueryCaps)(PresenterCaps* pCaps);

		HRESULT ExecuteFastCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
		HRESULT ExecuteD3DCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
		HRESULT QueryCaps(FASTCOMP_CAPS **ppCaps);
		HRESULT QueryFormats(FASTCOMP_SAMPLE_FORMATS **ppFormats);

		HRESULT FastCompositingBlt(const FASTCOMP_BLT_PARAMS &blt);
		HRESULT PlaneToSample(PLANE_ID id, FASTCOMP_VideoSample &sample, const RECT &rcDst, const RECT &rcDstClip);
		HRESULT CheckAndUpdateClearRects(const RECT &rcDst, const RECT &rcDstClip);
		HRESULT UnscrambleSurface(IDirect3DSurface9 *pRT, IDirect3DSurface9 *pSurface, ContentProtection &protection);

	protected:
		FASTCOMP_ClearRect *m_pClearRect;
		UINT m_uClearRect;
		RECT m_rcClip;
		DXVA2_AYUVSample16 m_ayuv16BackgroundColor;

		CIntelSCDService *m_pSCDService;
		CIntelFastCompositingService *m_pFastCompService;
		CIntelRegistrationDevice *m_pRegistrationDevice;
		IDriverExtensionAdapter *m_pDeviceCap;
	}
```


Overlapping Code:
```
xer :
public virtual BASE_VIDEO_MIXER,
public virtual CD3D9VideoPresenter
{
public:
CIntelFastCompositingMixer();
virtual ~CIntelFastCompositingMixer();
// IUnkonwn
STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
STDMETHOD_(ULONG, AddRef)() { return CD3D9PluginBase::AddRef(); }
STDMETHOD_(ULONG, Release)() { return CD3D9PluginBase::Release(); }
// IDispSvrPlugin
STDMETHOD(ProcessMessage)(RESOURCE_MESSAGE_TYPE msg, LPVOID ulParam);
// CD3D9VideoPresenterBase
STDMETHOD(SetDisplayRect)(const RECT *rcDst, const RECT *rcSrc);
STDMETHOD(Present)(const PresentHints *pHints);
STDMETHOD(SetScreenCaptureDefense)(BOOL bEnable);
STDMETHOD(SetBackgroundColor)(COLORREF Color);
STDMETHOD(SetGamutMetadata)(const DWORD dwFormat, void *pGamutMetadata);
private:
// CD3D9VideoMixerBase
STDMETHOD(_QueryPlaneCaps)(PLANE_ID PlaneID, PLANE_FORMAT Format, PlaneCaps *pCap);
STDMETHOD(_CreatePlane)(DispSvr::PlaneInit *pInit);
STDMETHOD(_Execute)(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
STDMETHOD(_SetDevice)(IUnknown *pDevice);
STDMETHOD(_ReleaseDevice)();
STDMETHOD(_QueryCaps)(PresenterCaps* pCaps);
HRESULT ExecuteFastCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
HRESULT ExecuteD3DCompositing(IDirect3DSurface9 *pDestSurface, const RECT &rcDst, const RECT &rcDstClip);
HRESULT QueryCaps(FASTCOMP_CAPS **ppCaps);
HRESULT QueryFormats(FASTCOMP_SAMPLE_FORMATS **ppFormats);
HRESULT FastCompositingBlt(const FASTCOMP_BLT_PARAMS &blt);
HRESULT PlaneToSample(PLANE_ID id, FASTCOMP_VideoSample &sample, const RECT &rcDst, const RECT &rcDstClip);
HRESULT CheckAndUpdateClearRects(const RECT &rcDst, const RECT &rcDstClip);
HRESULT UnscrambleSurface(IDirect3DSurface9 *pRT, IDirect3DSurface9 *pSurface, ContentProtection &protection);
protected:
FASTCOMP_ClearRect *m_pClearRect;
UINT m_uClearRect;
RECT m_rcClip;
DXVA2_AYUVSample16 m_ayuv16BackgroundColor;
CIntelSCDService *m_pSCDService;
CIntelFastCompositingService *m_pFastCompService;
CIntelRegistrationDevice *m_pRegistrationDevi
```
<Overlap Ratio: 0.9566028931404573>

---

--- 234 --
Question ID: 2c7a4de0cf58465a442a01ff7d570911fddf57f5_5
Original Code:
```
void led_on_set(homekit_value_t value)
{
   if(value.format != homekit_format_bool)
   {
      // printf("Invalid on-value format: %d\n", value.format);
      return;
   }

   led_on = value.bool_value;
   led_string_set();
}
```


Overlapping Code:
```
 led_on_set(homekit_value_t value)
{
if(value.format != homekit_format_bool)
{
// printf("Invalid on-value format: %d\n", value.format);
return;
}
led_on = value.bool_value;
led_string_se
```
<Overlap Ratio: 0.949238578680203>

---

--- 235 --
Question ID: 288d170629d01cb26e375a7d80be0198ff4862f6_0
Original Code:
```
static int alltoall_handler(boot_t *boot) {
  printf("Entering alltoall_handler at %d\n", HPX_LOCALITY_ID);
  const int NLOC = HPX_LOCALITIES;
  int src[NLOC][2];
  int dst[NLOC][2];

  int base = here->rank * here->ranks;
  for (int i = 0; i < NLOC; ++i) {
    src[i][0] = base + i;
    src[i][1] = here->rank;
    dst[i][0] = here->rank;
    dst[i][1] = here->rank;
  }

  boot_barrier(boot);
  static tatas_lock_t lock = SYNC_TATAS_LOCK_INIT;
  sync_tatas_acquire(&lock);
  {
    printf("src@%d { ", here->rank);
    for (int i = 0; i < NLOC; ++i) {
      printf("{%d,%d} ", src[i][0], src[i][1]);
    }
    printf("}\n");
    fflush(stdout);
  }
  sync_tatas_release(&lock);

  boot_barrier(boot);
  int e = boot_alltoall(boot, dst, src, 1*sizeof(int), 2*sizeof(int));
  if (e) {
    FAIL(dst, "boot_alltoall returned failure code\n");
  }

  sync_tatas_acquire(&lock);
  {
    printf("dst@%d { ", here->rank);
    for (int i = 0; i < NLOC; ++i) {
      printf("{%d,%d} ", dst[i][0], dst[i][1]);
    }
    printf("}\n");
    fflush(stdout);
  }
  sync_tatas_release(&lock);
  boot_barrier(boot);

  for (int i = 0; i < NLOC; ++i) {
    if (dst[i][0] != i * NLOC + here->rank) {
      FAIL(dst, "%d:dst[%d][0]=%d, expected %d\n", here->rank, i, dst[i][0], i * NLOC + here->rank);
    }
    if (dst[i][1] != here->rank) {
      FAIL(dst, "%d:dst[%d][1]=%d, expected %d\n", here->rank, i, dst[i][1], here->rank);
    }
  }

  return 0;
}
```


Overlapping Code:
```
oot_t *boot) {
printf("Entering alltoall_handler at %d\n", HPX_LOCALITY_ID);
const int NLOC = HPX_LOCALITIES;
int src[NLOC][2];
int dst[NLOC][2];
int base = here->rank * here->ranks;
for (int i = 0; i < NLOC; ++i) {
src[i][0] = base + i;
src[i][1] = here->rank;
dst[i][0] = here->rank;
dst[i][1] = here->rank;
}
boot_barrier(boot);
static tatas_lock_t lock = SYNC_TATAS_LOCK_INIT;
sync_tatas_acquire(&lock);
{
printf("src@%d { ", here->rank);
for (int i = 0; i < NLOC; ++i) {
printf("{%d,%d} ", src[i][0], src[i][1]);
}
printf("}\n");
fflush(stdout);
}
sync_tatas_release(&lock);
boot_barrier(boot);
int e = boot_alltoall(boot, dst, src, 1*sizeof(int), 2*sizeof(int));
if (e) {
FAIL(dst, "boot_alltoall returned failure code\n");
}
sync_tatas_acquire(&lock);
{
printf("dst@%d { ", here->rank);
for (int i = 0; i < NLOC; ++i) {
printf("{%d,%d} ", dst[i][0], dst[i][1]);
}
printf("}\n");
fflush(stdout);
}
sync_tatas_release(&lock);
boot_barrier(boot);
for (int i = 0; i < NLOC; ++i) {
if (dst[i][0] != i * NLOC + here->rank) {
FAIL(dst, "%d:dst[%d][0]=%d, expected %d\n", here->rank, i, dst[i][0], i * NLOC + here->rank);
}
if (dst[i][1] != here->rank) {
FAIL(dst, "%d:dst[%d][1]=%d, expected %d\n", here->rank, i, dst[i][1], here->rank);
}
}
return 0;
```
<Overlap Ratio: 0.9758190327613104>

---

--- 236 --
Question ID: 0c4a4167c182b4a4c19bd262ba972bb093bb98c0_4
Original Code:
```
void drawStatusBar(struct abuf *ab) {
	//Invert colors (Select Graphic Rendition)
	abAppend(ab, "\x1b[7m", 4);
	char status[80], rstatus[80];
	
	int len = snprintf(status, sizeof(status), "%s %.20s - %d line%s", E.modified ? "(modified)" : "", E.filename ? E.filename : "[No Name]", E.numrows, E.numrows == 1 ? "" : "s");
	int rlen = snprintf(rstatus, sizeof(rstatus), "(%s) %d/%d - %d", E.syntax ? E.syntax->filetype : "Plain Text", E.cy + 1 > E.numrows ? E.cy : E.cy + 1, E.numrows, E.cx + 1);
	
	if (len > E.screencols) {
		len = E.screencols;
	}
	
	abAppend(ab, status, len);
	
	while (len < E.screencols) {
		if (E.screencols - len == rlen) {
			abAppend(ab, rstatus, rlen);
			break;
		} else {
			abAppend(ab, " ", 1);
			len++;
		}
	}
	//Clear all attributes (Select Graphic Rendition)
	abAppend(ab, "\x1b[m", 3);
	abAppend(ab, "\r\n", 2);
}
```


Overlapping Code:
```
vert colors (Select Graphic Rendition)
abAppend(ab, "\x1b[7m", 4);
char status[80], rstatus[80];

int len = snprintf(status, sizeof(status), "%s %.20s - %d line%s", E.modified ? "(modified)" : "", E.filename ? E.filename : "[No Name]", E.numrows, E.numrows == 1 ? "" : "s");
int rlen = snprintf(rstatus, sizeof(rstatus), "(%s) %d/%d - %d", E.syntax ? E.syntax->filetype : "Plain Text", E.cy + 1 > E.numrows ? E.cy : E.cy + 1, E.numrows, E.cx + 1);

if (len > E.screencols) {
len = E.screencols;
}

abAppend(ab, status, len);

while (len < E.screencols) {
if (E.screencols - len == rlen) {
abAppend(ab, rstatus, rlen);
break;
} else {
abAppend(ab, " ", 1);
len++;
}
}
//Clear all attributes (Select Graphic Rendition)
abAppend(ab, "\x1b[m", 3);
abAppend(ab, "\r\n", 2);
}
```
<Overlap Ratio: 0.9482758620689655>

---

--- 237 --
Question ID: 141a8b65ee598b6655e46524c3a51c2024f1ee9f_5
Original Code:
```
list* objectFileGetUnused(objectFile* src)
{
	list* res = newList();
	
	listStart(src->sects);
	while (listNext(src->sects))
	{
		char* name = (char*) listGet(src->sects);
		graph* curr = (graph*) hashmapGet(sectionMap, name);
		
		if (!graphGetColorNode(curr))
			listAdd(res, graphGetNameNode(curr));
	}
	
	return res;
}
```


Overlapping Code:
```
tFileGetUnused(objectFile* src)
{
list* res = newList();

listStart(src->sects);
while (listNext(src->sects))
{
char* name = (char*) listGet(src->sects);
graph* curr = (graph*) hashmapGet(sectionMap, name);

if (!graphGetColorNode(curr))
listAdd(res,
```
<Overlap Ratio: 0.8250825082508251>

---

--- 238 --
Question ID: 59487d51b44b3603cb3a2e43ba44b6c756aaca76_0
Original Code:
```
void test_repo_message__cleanup(void)
{
        cl_git_sandbox_cleanup();
	git_buf_free(&_path);
	git__free(_actual);
	_actual = NULL;
}
```


Overlapping Code:
```
oid test_repo_message__cleanup(void)
{
cl_git_sandbox_cleanup();
git_buf_free(&_path);
git__free(_actual
```
<Overlap Ratio: 0.832>

---

--- 239 --
Question ID: 8cca39ab8308063739921cad55dc77c9c9d3e989_0
Original Code:
```
static int queue_create(void)
{
	ASSERT(queue_init(NULL, buffer, 16, sizeof(char)) == -1);
	ASSERT(queue_init(&queue, NULL, 16, sizeof(char)) == -1);
	ASSERT(queue_init(&queue, buffer, 0, sizeof(char)) == -1);
	ASSERT(queue_init(&queue, buffer, 16, 0) == -1);

	ASSERT(queue_init(&queue, buffer, 16, sizeof(char)) == 0);

	ASSERT(queue.buf == buffer);
	ASSERT(queue.capacity == 16);
	ASSERT(queue.item_size == sizeof(char));
	ASSERT(queue.count == 0);
	ASSERT(queue.get == NULL);
	ASSERT(queue.put == NULL);

	return 0;
}
```


Overlapping Code:
```
e_create(void)
{
ASSERT(queue_init(NULL, buffer, 16, sizeof(char)) == -1);
ASSERT(queue_init(&queue, NULL, 16, sizeof(char)) == -1);
ASSERT(queue_init(&queue, buffer, 0, sizeof(char)) == -1);
ASSERT(queue_init(&queue, buffer, 16, 0) == -1);
ASSERT(queue_init(&queue, buffer, 16, sizeof(char)) == 0);
ASSERT(queue.buf == buffer);
ASSERT(queue.capacity == 16);
ASSERT(queue.item_size == sizeof(char));
ASSERT(queue.count == 0);
ASSERT(queue.get == NULL
```
<Overlap Ratio: 0.8893280632411067>

---

--- 240 --
Question ID: 884198c0eceb02740e4560694fdd1ac870263d08_0
Original Code:
```
public Loggable
{
public:

  SESystem(Logger* logger);
  virtual ~SESystem();

  virtual void Clear();// Deletes all members
  
  /** @name GetScalar
  *   @brief - A reflextion type call that will return the Scalar associated
  *            with the string. ex. GetScalar("Hematocrit") will return the
  *            SEScalarPercent object associated with Hematocrit
  *   @details - Note this is an expensive call as it will string compare many times
  *              This is best used, and intended for, you to dynamically prepopulate
  *              a mapping data structure that will help access what you need
  */
  virtual const SEScalar* GetScalar(const std::string& name) = 0; 

  /** @name GetScalar
  *   @brief - Look for the Scalar property in the systems contained in the provided vector
  */
  static const SEScalar* GetScalar(const std::string& name, std::vector<SESystem*>* systems);

protected:
  std::stringstream m_ss;
}
```


Overlapping Code:
```
ESystem(Logger* logger);
virtual ~SESystem();
virtual void Clear();// Deletes all members

/** @name GetScalar
* @brief - A reflextion type call that will return the Scalar associated
* with the string. ex. GetScalar("Hematocrit") will return the
* SEScalarPercent object associated with Hematocrit
* @details - Note this is an expensive call as it will string compare many times
* This is best used, and intended for, you to dynamically prepopulate
* a mapping data structure that will help access what you need
*/
virtual const SEScalar* GetScalar(const std::string& name) = 0; 
/** @name GetScalar
* @brief - Look for the Scalar property in the systems contained in the provided vector
*/
static const SEScalar* GetScalar(const std::string& name, std::vector<SESystem*>* systems);
protected:
std::str
```
<Overlap Ratio: 0.948051948051948>

---

--- 241 --
Question ID: 929062123b09360aae400e50ca4623c999bc1418_21
Original Code:
```
void
ffs_clusteracct(ump, fs, cgp, blkno, cnt)
	struct ufsmount *ump;
	struct fs *fs;
	struct cg *cgp;
	ufs1_daddr_t blkno;
	int cnt;
{
	int32_t *sump;
	int32_t *lp;
	u_char *freemapp, *mapp;
	int i, start, end, forw, back, map, bit;

	mtx_assert(UFS_MTX(ump), MA_OWNED);

	if (fs->fs_contigsumsize <= 0)
		return;
	freemapp = cg_clustersfree(cgp);
	sump = cg_clustersum(cgp);
	/*
	 * Allocate or clear the actual block.
	 */
	if (cnt > 0)
		setbit(freemapp, blkno);
	else
		clrbit(freemapp, blkno);
	/*
	 * Find the size of the cluster going forward.
	 */
	start = blkno + 1;
	end = start + fs->fs_contigsumsize;
	if (end >= cgp->cg_nclusterblks)
		end = cgp->cg_nclusterblks;
	mapp = &freemapp[start / NBBY];
	map = *mapp++;
	bit = 1 << (start % NBBY);
	for (i = start; i < end; i++) {
		if ((map & bit) == 0)
			break;
		if ((i & (NBBY - 1)) != (NBBY - 1)) {
			bit <<= 1;
		} else {
			map = *mapp++;
			bit = 1;
		}
	}
	forw = i - start;
	/*
	 * Find the size of the cluster going backward.
	 */
	start = blkno - 1;
	end = start - fs->fs_contigsumsize;
	if (end < 0)
		end = -1;
	mapp = &freemapp[start / NBBY];
	map = *mapp--;
	bit = 1 << (start % NBBY);
	for (i = start; i > end; i--) {
		if ((map & bit) == 0)
			break;
		if ((i & (NBBY - 1)) != 0) {
			bit >>= 1;
		} else {
			map = *mapp--;
			bit = 1 << (NBBY - 1);
		}
	}
	back = start - i;
	/*
	 * Account for old cluster and the possibly new forward and
	 * back clusters.
	 */
	i = back + forw + 1;
	if (i > fs->fs_contigsumsize)
		i = fs->fs_contigsumsize;
	sump[i] += cnt;
	if (back > 0)
		sump[back] -= cnt;
	if (forw > 0)
		sump[forw] -= cnt;
	/*
	 * Update cluster summary information.
	 */
	lp = &sump[fs->fs_contigsumsize];
	for (i = fs->fs_contigsumsize; i > 0; i--)
		if (*lp-- > 0)
			break;
	fs->fs_maxcluster[cgp->cg_cgx] = i;
}
```


Overlapping Code:
```
t)
struct ufsmount *ump;
struct fs *fs;
struct cg *cgp;
ufs1_daddr_t blkno;
int cnt;
{
int32_t *sump;
int32_t *lp;
u_char *freemapp, *mapp;
int i, start, end, forw, back, map, bit;
mtx_assert(UFS_MTX(ump), MA_OWNED);
if (fs->fs_contigsumsize <= 0)
return;
freemapp = cg_clustersfree(cgp);
sump = cg_clustersum(cgp);
/*
* Allocate or clear the actual block.
*/
if (cnt > 0)
setbit(freemapp, blkno);
else
clrbit(freemapp, blkno);
/*
* Find the size of the cluster going forward.
*/
start = blkno + 1;
end = start + fs->fs_contigsumsize;
if (end >= cgp->cg_nclusterblks)
end = cgp->cg_nclusterblks;
mapp = &freemapp[start / NBBY];
map = *mapp++;
bit = 1 << (start % NBBY);
for (i = start; i < end; i++) {
if ((map & bit) == 0)
break;
if ((i & (NBBY - 1)) != (NBBY - 1)) {
bit <<= 1;
} else {
map = *mapp++;
bit = 1;
}
}
forw = i - start;
/*
* Find the size of the cluster going backward.
*/
start = blkno - 1;
end = start - fs->fs_contigsumsize;
if (end < 0)
end = -1;
mapp = &freemapp[start / NBBY];
map = *mapp--;
bit = 1 << (start % NBBY);
for (i = start; i > end; i--) {
if ((map & bit) == 0)
break;
if ((i & (NBBY - 1)) != 0) {
bit >>= 1;
} else {
map = *mapp--;
bit = 1 << (NBBY - 1);
}
}
back = start - i;
/*
* Account for old cluster and the possibly new forward and
* back clusters.
*/
i = back + forw + 1;
if (i > fs->fs_contigsumsize)
i = fs->fs_contigsumsize;
sump[i] += cnt;
if (back > 0)
sump[back] -= cnt;
if (forw > 0)
sump[forw] -= cnt;
/*
* Update cluster summary information.
*/
lp = &sump[fs->fs_contigsumsize];
for (i = fs->fs_contigsumsize; i > 0; i--)
if (*lp-- > 0)
break;
fs->fs_maxcluster[
```
<Overlap Ratio: 0.9623880597014925>

---

--- 242 --
Question ID: cacd6d78d79e85ae06d191f55fcd03fe990f3a3b_5
Original Code:
```
static inline void _do_nano_timeout_add(struct tcs *tcs,
					 struct _nano_timeout *t,
				     struct _nano_queue *wait_q,
				     int32_t timeout)
{
	sys_dlist_t *timeout_q = &_nanokernel.timeout_q;

	t->tcs = tcs;
	t->delta_ticks_from_prev = timeout;
	t->wait_q = wait_q;
	sys_dlist_insert_at(timeout_q, (void *)t,
						_nano_timeout_insert_point_test,
						&t->delta_ticks_from_prev);
}
```


Overlapping Code:
```
out_add(struct tcs *tcs,
struct _nano_timeout *t,
struct _nano_queue *wait_q,
int32_t timeout)
{
sys_dlist_t *timeout_q = &_nanokernel.timeout_q;
t->tcs = tcs;
t->delta_ticks_from_prev = timeout;
t->wait_q = wait_q;
sys_dlist_insert_at(timeout_q, (void *)t,
_nano_timeout_insert_point_test,
&t->delta
```
<Overlap Ratio: 0.8522727272727273>

---

--- 243 --
Question ID: 3128c9ecdd0b7c704bb37e328345279aed836b63_16
Original Code:
```
static void rebrick_tcpsocket_asclient_memory(void **start)
{

    unused(start);
    const char *port = "80";
    rebrick_tcpsocket_t *client;
    rebrick_sockaddr_t addr;
    rebrick_util_ip_port_to_addr("127.0.0.1", port, &addr);
    struct callbackdata data;

    fill_zero(&data, sizeof(struct callbackdata));

    char *head = "GET / HTTP/1.0\r\n\
Host: nodejs.org\r\n\
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\r\n\
Accept: text/html\r\n\
\r\n";
#define COUNTER 100

    new2(rebrick_tcpsocket_callbacks_t, callbacks);
    callbacks.callback_data = &data;
    callbacks.on_connection_accepted = on_connection_accepted_memorytest;
    callbacks.on_connection_closed = on_connection_closed_memorytest;
    callbacks.on_data_received = on_datarecevied_memorytest;
    callbacks.on_data_sended = on_datasend_memorytest;
    callbacks.on_error_occured = on_error_occured_memorytest;

    for (int i = 0; i < COUNTER; ++i)
    {

        int32_t result = rebrick_tcpsocket_new(&client, addr, 0, &callbacks);
        assert_int_equal(result, REBRICK_SUCCESS);

        //check a little
        int counter = 1000;
        while (--counter && !connected_to_memorytest)
        {
            uv_run(uv_default_loop(), UV_RUN_NOWAIT);
            usleep(1000);
        }

        datasended_memorytest = 0;
        datareceived_ok_memorytest = 0;
        connection_closed_memorytest = 0;
        rebrick_clean_func_t cleanfunc = {};
        result = rebrick_tcpsocket_send(client, cast(head, uint8_t *), strlen(head) + 1, cleanfunc);

        counter = 1000;
        while (--counter && !datasended_memorytest)
        {
            uv_run(uv_default_loop(), UV_RUN_NOWAIT);
            usleep(1000);
        }
        assert_int_equal(datasended_memorytest, 10); //this value is used above

        counter = 1000;
        while (--counter && !datareceived_ok_memorytest)
        {
            uv_run(uv_default_loop(), UV_RUN_NOWAIT);
            usleep(1000);
        }
        assert_true(datareceived_ok_memorytest > 0);

        rebrick_tcpsocket_destroy(client);
        counter = 1000;
        while (--counter && !connection_closed_memorytest)
        {
            uv_run(uv_default_loop(), UV_RUN_NOWAIT);
            usleep(1000);
        }
        assert_true(connection_closed_memorytest != 0);
    }
}
```


Overlapping Code:
```
psocket_asclient_memory(void **start)
{
unused(start);
const char *port = "80";
rebrick_tcpsocket_t *client;
rebrick_sockaddr_t addr;
rebrick_util_ip_port_to_addr("127.0.0.1", port, &addr);
struct callbackdata data;
fill_zero(&data, sizeof(struct callbackdata));
char *head = "GET / HTTP/1.0\r\n\
Host: nodejs.org\r\n\
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36\r\n\
Accept: text/html\r\n\
\r\n";
#define COUNTER 100
new2(rebrick_tcpsocket_callbacks_t, callbacks);
callbacks.callback_data = &data;
callbacks.on_connection_accepted = on_connection_accepted_memorytest;
callbacks.on_connection_closed = on_connection_closed_memorytest;
callbacks.on_data_received = on_datarecevied_memorytest;
callbacks.on_data_sended = on_datasend_memorytest;
callbacks.on_error_occured = on_error_occured_memorytest;
for (int i = 0; i < COUNTER; ++i)
{
int32_t result = rebrick_tcpsocket_new(&client, addr, 0, &callbacks);
assert_int_equal(result, REBRICK_SUCCESS);
//check a little
int counter = 1000;
while (--counter && !connected_to_memorytest)
{
uv_run(uv_default_loop(), UV_RUN_NOWAIT);
usleep(1000);
}
datasended_memorytest = 0;
datareceived_ok_memorytest = 0;
connection_closed_memorytest = 0;
rebrick_clean_func_t cleanfunc = {};
result = rebrick_tcpsocket_send(client, cast(head, uint8_t *), strlen(head) + 1, cleanfunc);
counter = 1000;
while (--counter && !datasended_memorytest)
{
uv_run(uv_default_loop(), UV_RUN_NOWAIT);
usleep(1000);
}
assert_int_equal(datasended_memorytest, 10); //this value is used above
counter = 1000;
while (--counter && !datareceived_ok_memorytest)
{
uv_run(uv_default_loop(), UV_RUN_NOWAIT);
usleep(1000);
}
assert_true(datareceived_ok_memorytest > 0);
rebrick_tcpsocket_destroy(client);
counter = 1000;
while (--counter && !connection_closed_memorytest)
{
uv_run(uv_default_loop(), UV_RUN_NOWAIT);
usleep(1000);
}
assert_true(connection_closed_memory
```
<Overlap Ratio: 0.9813789632611978>

---

--- 244 --
Question ID: dc4f3fcd52d5e56f78c83d694d2dd59ac93c44ab_0
Original Code:
```
int update_condition(object me, int duration)
{
  if (me->is_ghost()) return 1;
        if( !living(me) || query_temp("noliving", me) )
        {
                message("vision", me->name()+"喘着粗氣，中掌處黑絲如墨。\n", environment(me), me);
        }
        else
        {
                tell_object(me, HIB"你只覺渾身冰冷刺骨，甚為難受！\n" NOR );
                message("vision", HIB+me->name()+"突然面色鐵青，全身上下黑絲隱約可辨，看來是中了黑砂掌後掌毒發作了。\n"NOR, environment(me), me);
        }
        me->receive_damage("qi", 25,"黑砂掌毒發作");
        me->receive_wound("jing", 20,"黑砂掌毒發作");
        if( query("eff_jing", me)<0 || query("eff_qi", me)<0)return 0;
        me->apply_condition("black_poison", duration - 1);
        if( duration < 1 ) return 0;
        return CND_CONTINUE;
}
```


Overlapping Code:
```
int update_condition(object me, int duration)
{
if (me->is_ghost()) return 1;
if( !living(me) || query_temp("noliving", me) )
{
message("vision", me->name()+"喘着粗氣，中掌處黑絲如墨。\n", environment(me), me);
}
else
{
tell_object(me, HIB"你只覺渾身冰冷刺骨，甚為難受！\n" NOR );
message("vision", HIB+me->name()+"突然面色鐵青，全身上下黑絲隱約可辨，看來是中了黑砂掌後掌毒發作了。\n"NOR, environment(me), me);
}
me->receive_damage("qi", 25,"黑砂掌毒發作");
me->receive_wound("jing", 20,"黑砂掌毒發作");
if( query("eff_jing", me)<0 || query("eff_qi", me)<0)return 0;
me->apply_condition("black_poison", duration - 1);
if( duration < 1 ) return 0;
return CND_CONTINUE;
}
```
<Overlap Ratio: 1.0>

---

--- 245 --
Question ID: 49f64a430c90a2d7d1bd0239529719c4ac0a5e4b_0
Original Code:
```
double image_influence(double *potential,
		       struct image_Landscape_param *image_paras,
		       miColor *color)
{
  double value;

  value = 0;

  if ((image_paras->on) && (image_paras->influence))
    {
      if (image_paras->alpha)
	value += (2.0 * color->a - 1.0);

      if (image_paras->red)
	value += (2.0 * color->r - 1.0);

      if (image_paras->green)
	value += (2.0 * color->g - 1.0);

      if (image_paras->blue)
	value += (2.0 * color->b - 1.0);

      value *= image_paras->influence;

      *potential += image_paras->influence;

      return value;
    }

  else
    return 0;
}
```


Overlapping Code:
```
uct image_Landscape_param *image_paras,
miColor *color)
{
double value;
value = 0;
if ((image_paras->on) && (image_paras->influence))
{
if (image_paras->alpha)
value += (2.0 * color->a - 1.0);
if (image_paras->red)
value += (2.0 * color->r - 1.0);
if (image_paras->green)
value += (2.0 * color->g - 1.0);
if (image_paras->blue)
value += (2.0 * color->b - 1.0);
value *= image_paras->influence;
*potential += image_paras->influence;
return value;
}
el
```
<Overlap Ratio: 0.8840864440078585>

---

--- 246 --
Question ID: c0345fcb8569c363946f6d60a55b48b065a37720_8
Original Code:
```
static void
get_active_cb(DBusPendingCall *pending, void *data)
{
	struct launcher_ck2 *wl = data;
	DBusMessageIter iter;
	DBusMessage *m;
	int type;

	dbus_pending_call_unref(wl->pending_active);
	wl->pending_active = NULL;

	m = dbus_pending_call_steal_reply(pending);
	if (!m)
		return;

	type = dbus_message_get_type(m);
	if (type == DBUS_MESSAGE_TYPE_METHOD_RETURN &&
			dbus_message_iter_init(m, &iter))
		parse_active(wl, m, &iter);

	dbus_message_unref(m);
}
```


Overlapping Code:
```
tic void
get_active_cb(DBusPendingCall *pending, void *data)
{
struct launcher_ck2 *wl = data;
DBusMessageIter iter;
DBusMessage *m;
int type;
dbus_pending_call_unref(wl->pending_active);
wl->pending_active = NULL;
m = dbus_pending_call_steal_reply(pending);
if (!m)
return;
type = dbus_message_get_type(m);
if (type == DBUS_MESSAGE_TYPE_METHOD_RETURN &&
dbus_message_iter_init(m, &iter))
parse_active(wl, m, &iter);
dbus_message_unre
```
<Overlap Ratio: 0.9774774774774775>

---

--- 247 --
Question ID: e3dd8a6fbb9e36cc7fd6d7fc7891b8f522ea1ab6_4
Original Code:
```
void printUndefinedMotionHeader(OutputStream* outputStream, PidMotionDefinition* pidMotionDefinition) {
    printMotionInstructionStateHeader(outputStream, pidMotionDefinition);
    appendStringHeader(outputStream, "Idx", PID_DEBUG_INDEX_COLUMN_LENGTH);
    appendStringHeader(outputStream, "Undefined", PID_DEBUG_INSTRUCTION_TYPE_COLUMN_LENGTH);
    appendEndOfTableColumn(outputStream, PID_DEBUG_LAST_COLUMN_LENGTH);
    appendTableHeaderSeparatorLine(outputStream);
}
```


Overlapping Code:
```
oid printUndefinedMotionHeader(OutputStream* outputStream, PidMotionDefinition* pidMotionDefinition) {
printMotionInstructionStateHeader(outputStream, pidMotionDefinition);
appendStringHeader(outputStream, "Idx", PID_DEBUG_INDEX_COLUMN_LENGTH);
appendStringHeader(outputStream, "Undefined", PID_DEBUG_INSTRUCTION_TYPE_COLUMN_LENGTH);
appendEndOfTableColumn(outputStream, PID_DEBUG_LAST_COLUMN_LENGTH);
appendTableHeaderSeparatorLine(outputStream);
}
```
<Overlap Ratio: 0.9977777777777778>

---

--- 248 --
Question ID: 48c4ce847634b1716c7c83e612bbda61716c4995_20
Original Code:
```
int ExWAD_GetDirEnt(ExWAD_Context *ctx, char *name)
{
	char tb[256];
	ExWAD_DirEnt *de;
	char *s, *name1;
	int i, j, b, n, n1, fl, pfx;
	
	i=ExWAD_LookupDirEnt(ctx, name);
	if(i>=0)return(i);

#if 1
	if(strlen(name)>EXWAD_NAMESZ)
	{
		strcpy(tb, name);
		s=tb+strlen(tb);
//		while((s>tb) && (*s!='/'))s--;
		while(s>tb)
		{
			if((*s=='/') && s[1])
				break;
			s--;
		}
		if((s>tb) && (*s=='/') && s[1])
		{
			s[1]=0;
			pfx=ExWAD_GetDirEnt(ctx, tb);

			s=name+strlen(name);
//			while((s>name) && (*s!='/'))s--;
			while(s>tb)
			{
				if((*s=='/') && s[1])
					break;
				s--;
			}
			name1=s+1;
		}else
		{
			pfx=-1;
			name1=name;
		}
	}else
	{
		pfx=-1;
		name1=name;
	}
#endif

	b=exwad_getu32(ctx->head->rva_dirents);
	n=exwad_getu32(ctx->head->num_dirents);
	for(i=0; i<n; i++)
	{
		de=&(ctx->dir[i]);
//		fl=exwad_getxu16(de->flags);
		j=exwad_getu32(de->name);
		if(!j)
		{
			if((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))
			{
//				de->name[14]=pfx&0xFF;
//				de->name[15]=(pfx>>8)&0xFF;
				strcpy(de->name, name1);
//				exwad_setu16(de->name+14, pfx);
				exwad_setu32(de->dir, pfx);
				exwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);
			}else if(strlen(name)<=EXWAD_NAMESZ)
			{
				strcpy(de->name, name);
				exwad_setu16(de->flags, 0);
			}else
			{
				if((pfx>=0) && (pfx<65536))
				{
					j=ExWAD_GetStringRVA(ctx, name1);
					exwad_setu32(de->name, j);
//					exwad_setu32(de->name+12, pfx);
					exwad_setu32(de->dir, pfx);
					exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|
						EXWAD_DIRFL_DIRPFX);
				}else
				{
					j=ExWAD_GetStringRVA(ctx, name);
					exwad_setu32(de->name, j);
					exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);
				}
			}
		
			return(i);
		}
	}
	
	ExWAD_CheckExpandDir(ctx, n+EXWAD_CELLSZ);
	i=n+1;

	de=&(ctx->dir[i]);
	if((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))
	{
//		de->name[14]=pfx&0xFF;
//		de->name[15]=(pfx>>8)&0xFF;
		strcpy(de->name, name1);
//		exwad_setu16(de->name+14, pfx);
		exwad_setu32(de->dir, pfx);
		exwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);
	}else if(strlen(name)<=EXWAD_NAMESZ)
	{
		strcpy(de->name, name);
		exwad_setu16(de->flags, 0);
	}else
	{
		if((pfx>=0) && (pfx<65536))
		{
			j=ExWAD_GetStringRVA(ctx, name1);
			exwad_setu32(de->name, j);
//			exwad_setu32(de->name+12, pfx);
			exwad_setu32(de->dir, pfx);
			exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|
				EXWAD_DIRFL_DIRPFX);
		}else
		{
			j=ExWAD_GetStringRVA(ctx, name);
			exwad_setu32(de->name, j);
			exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);
		}
	}

	return(i);
}
```


Overlapping Code:
```
_GetDirEnt(ExWAD_Context *ctx, char *name)
{
char tb[256];
ExWAD_DirEnt *de;
char *s, *name1;
int i, j, b, n, n1, fl, pfx;

i=ExWAD_LookupDirEnt(ctx, name);
if(i>=0)return(i);
#if 1
if(strlen(name)>EXWAD_NAMESZ)
{
strcpy(tb, name);
s=tb+strlen(tb);
// while((s>tb) && (*s!='/'))s--;
while(s>tb)
{
if((*s=='/') && s[1])
break;
s--;
}
if((s>tb) && (*s=='/') && s[1])
{
s[1]=0;
pfx=ExWAD_GetDirEnt(ctx, tb);
s=name+strlen(name);
// while((s>name) && (*s!='/'))s--;
while(s>tb)
{
if((*s=='/') && s[1])
break;
s--;
}
name1=s+1;
}else
{
pfx=-1;
name1=name;
}
}else
{
pfx=-1;
name1=name;
}
#endif
b=exwad_getu32(ctx->head->rva_dirents);
n=exwad_getu32(ctx->head->num_dirents);
for(i=0; i<n; i++)
{
de=&(ctx->dir[i]);
// fl=exwad_getxu16(de->flags);
j=exwad_getu32(de->name);
if(!j)
{
if((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))
{
// de->name[14]=pfx&0xFF;
// de->name[15]=(pfx>>8)&0xFF;
strcpy(de->name, name1);
// exwad_setu16(de->name+14, pfx);
exwad_setu32(de->dir, pfx);
exwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);
}else if(strlen(name)<=EXWAD_NAMESZ)
{
strcpy(de->name, name);
exwad_setu16(de->flags, 0);
}else
{
if((pfx>=0) && (pfx<65536))
{
j=ExWAD_GetStringRVA(ctx, name1);
exwad_setu32(de->name, j);
// exwad_setu32(de->name+12, pfx);
exwad_setu32(de->dir, pfx);
exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|
EXWAD_DIRFL_DIRPFX);
}else
{
j=ExWAD_GetStringRVA(ctx, name);
exwad_setu32(de->name, j);
exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME);
}
}

return(i);
}
}

ExWAD_CheckExpandDir(ctx, n+EXWAD_CELLSZ);
i=n+1;
de=&(ctx->dir[i]);
if((pfx>=0) && (pfx<65536) && (strlen(name1)<=EXWAD_NAMESZ))
{
// de->name[14]=pfx&0xFF;
// de->name[15]=(pfx>>8)&0xFF;
strcpy(de->name, name1);
// exwad_setu16(de->name+14, pfx);
exwad_setu32(de->dir, pfx);
exwad_setu16(de->flags, EXWAD_DIRFL_DIRPFX);
}else if(strlen(name)<=EXWAD_NAMESZ)
{
strcpy(de->name, name);
exwad_setu16(de->flags, 0);
}else
{
if((pfx>=0) && (pfx<65536))
{
j=ExWAD_GetStringRVA(ctx, name1);
exwad_setu32(de->name, j);
// exwad_setu32(de->name+12, pfx);
exwad_setu32(de->dir, pfx);
exwad_setu16(de->flags, EXWAD_DIRFL_RVANAME|
EXWAD_DIRFL_DIRPFX);
}else
{
j=ExWAD_GetStringRVA(ctx, name);
exwad_setu32(de->name, j);
exwad_s
```
<Overlap Ratio: 0.9945750452079566>

---

--- 249 --
Question ID: fd065fc6183a6a03884c3aa30a9a69b364ca802a_132
Original Code:
```
static bool torture_rpc_spoolss_printerwkn_setup(struct torture_context *tctx, void **data)
{
	struct torture_printer_context *t;

	*data = t = talloc_zero(tctx, struct torture_printer_context);

	t->ex			= false;
	t->wellknown		= true;
	t->info2.printername	= TORTURE_WELLKNOWN_PRINTER;
	t->devmode		= NULL;

	/* FIXME */
	if (t->wellknown) {
		torture_skip(tctx, "skipping AddPrinter level 1");
	}

	return torture_rpc_spoolss_printer_setup_common(tctx, t);
}
```


Overlapping Code:
```
kn_setup(struct torture_context *tctx, void **data)
{
struct torture_printer_context *t;
*data = t = talloc_zero(tctx, struct torture_printer_context);
t->ex = false;
t->wellknown = true;
t->info2.printername = TORTURE_WELLKNOWN_PRINTER;
t->devmode = NULL;
/* FIXME */
if (t->wellknown) {
torture_skip(tctx, "skipping AddPrinter level 1");
}
return torture_rpc_spoolss_printer_setup_common(tctx, t);

```
<Overlap Ratio: 0.9070294784580499>

---

--- 250 --
Question ID: 3890ef039bade14c9cfa725ec8574f56b69e6d7e_1
Original Code:
```
void SocketClose(int* fd)
{
    int tempFd = *fd;
    if ( tempFd < 0 )
      return;
    *fd = -1;
    close(tempFd);
}
```


Overlapping Code:
```
d;
if ( tempFd < 0 )
return;
*fd = -1;
close(tempF
```
<Overlap Ratio: 0.5102040816326531>

---

--- 251 --
Question ID: ee064d7f71abd7cebbe5206046272c5b62790685_2
Original Code:
```
esk8_err_t esk8_auth_auth(

    esk8_auth_hndl_t* hndl,
    esk8_auth_key_t   key

)
{
    esk8_auth_key_t   hash;
    esk8_auth_cntx_t* cntx = *hndl;

    if (mbedtls_md_starts(&cntx->mbtls_cntx))
        return ESK8_AUTH_ERR_HASH;

    if (mbedtls_md_update(&cntx->mbtls_cntx, key, sizeof(esk8_auth_key_t)))
        return ESK8_AUTH_ERR_HASH;

    if (mbedtls_md_finish(&cntx->mbtls_cntx, hash))
        return ESK8_AUTH_ERR_HASH;

    if (memcmp(cntx->hash, hash, sizeof(esk8_auth_key_t)) == 0)
        return ESK8_OK;

    return ESK8_AUTH_ERR_AUTH;
}
```


Overlapping Code:
```
* hndl,
esk8_auth_key_t key
)
{
esk8_auth_key_t hash;
esk8_auth_cntx_t* cntx = *hndl;
if (mbedtls_md_starts(&cntx->mbtls_cntx))
return ESK8_AUTH_ERR_HASH;
if (mbedtls_md_update(&cntx->mbtls_cntx, key, sizeof(esk8_auth_key_t)))
return ESK8_AUTH_ERR_HASH;
if (mbedtls_md_finish(&cntx->mbtls_cntx, hash))
return ESK8_AUTH_ERR_HASH;
if (memcmp(cntx->hash, hash, sizeof(esk8_auth_key_t)) == 0)
return ESK8
```
<Overlap Ratio: 0.8403361344537815>

---

--- 252 --
Question ID: 3d072fd063ef6452ab2c9ae6d0059e556b57a87a_3
Original Code:
```
void *_lf_dynarray_value(LF_DYNARRAY *array, uint idx)
{
  void * ptr, * volatile * ptr_ptr= 0;
  int i;

  for (i= LF_DYNARRAY_LEVELS-1; idx < dynarray_idxes_in_prev_levels[i]; i--)
    /* no-op */;
  ptr_ptr= &array->level[i];
  idx-= dynarray_idxes_in_prev_levels[i];
  for (; i > 0; i--)
  {
    if (!(ptr= *ptr_ptr))
      return(NULL);
    ptr_ptr= ((void **)ptr) + idx / dynarray_idxes_in_prev_level[i];
    idx %= dynarray_idxes_in_prev_level[i];
  }
  if (!(ptr= *ptr_ptr))
    return(NULL);
  return ((uchar*)ptr) + array->size_of_element * idx;
}
```


Overlapping Code:
```
id *_lf_dynarray_value(LF_DYNARRAY *array, uint idx)
{
void * ptr, * volatile * ptr_ptr= 0;
int i;
for (i= LF_DYNARRAY_LEVELS-1; idx < dynarray_idxes_in_prev_levels[i]; i--)
/* no-op */;
ptr_ptr= &array->level[i];
idx-= dynarray_idxes_in_prev_levels[i];
for (; i > 0; i--)
{
if (!(ptr= *ptr_ptr))
return(NULL);
ptr_ptr= ((void **)ptr) + idx / dynarray_idxes_in_prev_level[i];
idx %= dynarray_idxes_in_prev_level[i];
}
if (!(ptr= *ptr_ptr))
return(NULL);
return ((uchar*)ptr) + array->size_of_element * idx;
```
<Overlap Ratio: 0.9921568627450981>

---

--- 253 --
Question ID: 31cffd779e687a9f4dc8ece64b89776ab066cea0_4
Original Code:
```
bool
http_send_advs(const adv_report_table_t *const p_reports, const uint32_t nonce, const bool flag_use_timestamps)
{
    const ruuvi_gw_cfg_coordinates_t coordinates       = gw_cfg_get_coordinates();
    http_async_info_t *              p_http_async_info = &g_http_async_info;

    p_http_async_info->flag_sending_advs = true;
    p_http_async_info->cjson_str         = cjson_wrap_str_null();
    if (!http_json_create_records_str(
            p_reports,
            flag_use_timestamps,
            time(NULL),
            gw_cfg_get_nrf52_mac_addr(),
            coordinates.buf,
            true,
            nonce,
            &p_http_async_info->cjson_str))
    {
        LOG_ERR("Not enough memory to generate json");
        return false;
    }

    http_init_client_config_for_http_record(&p_http_async_info->http_client_config);

    p_http_async_info->p_http_client_handle = esp_http_client_init(
        &p_http_async_info->http_client_config.esp_http_client_config);
    if (NULL == p_http_async_info->p_http_client_handle)
    {
        LOG_ERR("HTTP POST to URL=%s: Can't init http client", p_http_async_info->http_client_config.http_url.buf);
        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);
        return false;
    }

    if (!http_send_async(p_http_async_info))
    {
        esp_http_client_cleanup(p_http_async_info->p_http_client_handle);
        p_http_async_info->p_http_client_handle = NULL;
        cjson_wrap_free_json_str(&p_http_async_info->cjson_str);
        return false;
    }
    return true;
}
```


Overlapping Code:
```
p_send_advs(const adv_report_table_t *const p_reports, const uint32_t nonce, const bool flag_use_timestamps)
{
const ruuvi_gw_cfg_coordinates_t coordinates = gw_cfg_get_coordinates();
http_async_info_t * p_http_async_info = &g_http_async_info;
p_http_async_info->flag_sending_advs = true;
p_http_async_info->cjson_str = cjson_wrap_str_null();
if (!http_json_create_records_str(
p_reports,
flag_use_timestamps,
time(NULL),
gw_cfg_get_nrf52_mac_addr(),
coordinates.buf,
true,
nonce,
&p_http_async_info->cjson_str))
{
LOG_ERR("Not enough memory to generate json");
return false;
}
http_init_client_config_for_http_record(&p_http_async_info->http_client_config);
p_http_async_info->p_http_client_handle = esp_http_client_init(
&p_http_async_info->http_client_config.esp_http_client_config);
if (NULL == p_http_async_info->p_http_client_handle)
{
LOG_ERR("HTTP POST to URL=%s: Can't init http client", p_http_async_info->http_client_config.http_url.buf);
cjson_wrap_free_json_str(&p_http_async_info->cjson_str);
return false;
}
if (!http_send_async(p_http_async_info))
{
esp_http_client_cleanup(p_http_async_info->p_http_client_handle);
p_http_async_info->p_http_client_handle = NULL;
cjson_wrap_free_json_str(&p_http_async_info->cjson_str);
return false
```
<Overlap Ratio: 0.9796078431372549>

---

--- 254 --
Question ID: 62bb98288f8eaf361ad4c30dda716b6283da079c_4
Original Code:
```
namespace UIHelper{

void setRowItems(int row, const QString & name, const QString & classname, const QString & bind, const QString & value, const QString & tip1, const QString & tip2, TableWidget *table);
void setBinding(int index, int row, int column, const QString & variableName, const QString & path, hkVariableType type, bool isProperty, TableWidget *table, HkDynamicObject *bsData);
void loadBinding(int row, int column, hkbVariableBindingSet *varBind, const QString &path, TableWidget *table, HkxObject *bsData);
void setGenerator(int index, const QString &name, DataIconManager *dynobj, hkbGenerator *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);
void setModifier(int index, const QString &name, DataIconManager *dynobj, hkbModifier *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);

}
```


Overlapping Code:
```
oid setRowItems(int row, const QString & name, const QString & classname, const QString & bind, const QString & value, const QString & tip1, const QString & tip2, TableWidget *table);
void setBinding(int index, int row, int column, const QString & variableName, const QString & path, hkVariableType type, bool isProperty, TableWidget *table, HkDynamicObject *bsData);
void loadBinding(int row, int column, hkbVariableBindingSet *varBind, const QString &path, TableWidget *table, HkxObject *bsData);
void setGenerator(int index, const QString &name, DataIconManager *dynobj, hkbGenerator *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int row, int column);
void setModifier(int index, const QString &name, DataIconManager *dynobj, hkbModifier *child, HkxSignature sig, HkxObject::HkxType type, TableWidget *table, BehaviorGraphView *behaviorView, int
```
<Overlap Ratio: 0.9567053854276664>

---

--- 255 --
Question ID: d7af7d649b4629e65d6959061a4fba7a7ac14489_3
Original Code:
```
static int save_freemap(struct super *sb)
{
	struct blk_buffer *b;
	int i = sb - super;
	blk_t cnt;
	blk_t bn;
	char *p;
	int err;
	
	if (sb->ro)
		return 0;
	
	p = freemap[i];
	if (!p)
		panic("no freemap");
	
	cnt = (sb->nblocks + 4095) / 4096;
	
	for (bn = 0; bn < cnt; bn++, p += 512)
	{
		if (!freedirt[i][bn])
			continue;
		
		err = blk_get(sb->dev, bn + sb->bitmap, &b);
		if (err)
			return err;
		memcpy(b->data, p, 512);
		b->valid = 1;
		b->dirty = 1;
		blk_put(b);
		
		freedirt[i][bn] = 0;
	}
	return 0;
}
```


Overlapping Code:
```
tic int save_freemap(struct super *sb)
{
struct blk_buffer *b;
int i = sb - super;
blk_t cnt;
blk_t bn;
char *p;
int err;

if (sb->ro)
return 0;

p = freemap[i];
if (!p)
panic("no freemap");

cnt = (sb->nblocks + 4095) / 4096;

for (bn = 0; bn < cnt; bn++, p += 512)
{
if (!freedirt[i][bn])
continue;

err = blk_get(sb->dev, bn + sb->bitmap, &b);
if (err)
return err;
memcpy(b->data, p, 512);
b->valid = 1;
b->dirty = 1;
blk_put(b);

freedirt[i][bn] 
```
<Overlap Ratio: 0.9554140127388535>

---

--- 256 --
Question ID: c8273645b2c24f29f02b4752da474284e112221d_0
Original Code:
```
void ports_init(Ports *ports)
{
    ports->ctl = 0xff;
    ports->TRA = TRI_HIGHZ;
    ports->THA = TRI_HIGHZ;
    ports->TRB = TRI_HIGHZ;
    ports->THB = TRI_HIGHZ;
}
```


Overlapping Code:
```
nit(Ports *ports)
{
ports->ctl = 0xff;
ports->TRA = TRI_HIGHZ;
ports->THA = TRI_HIGHZ;
ports->TRB = 
```
<Overlap Ratio: 0.6756756756756757>

---

--- 257 --
Question ID: 9446960ac742914f3c912eb15a2870bb4dc42432_12
Original Code:
```
static void bpa10x_disconnect(struct usb_interface *intf)
{
	struct bpa10x_data *data = usb_get_intfdata(intf);
	struct hci_dev *hdev = data->hdev;

	BT_DBG("intf %p", intf);

	if (!hdev)
		return;

	usb_set_intfdata(intf, NULL);

	if (hci_unregister_dev(hdev) < 0)
		BT_ERR("Can't unregister HCI device %s", hdev->name);

	hci_free_dev(hdev);
}
```


Overlapping Code:
```
ic void bpa10x_disconnect(struct usb_interface *intf)
{
struct bpa10x_data *data = usb_get_intfdata(intf);
struct hci_dev *hdev = data->hdev;
BT_DBG("intf %p", intf);
if (!hdev)
return;
usb_set_intfdata(intf, NULL);
if (hci_unregister_dev(hdev) < 0)
BT_ERR("Can't unregister HCI device %s", hdev->name);
hci_free_dev(hdev);
}
```
<Overlap Ratio: 0.9878419452887538>

---

--- 258 --
Question ID: 9e7e22d485764f0e62c8866b235081e6c8f7e152_2
Original Code:
```
int freeImageGD(imageObj *img)
{
  gdImagePtr ip;

  if(img) {
    ip = MS_IMAGE_GET_GDIMAGEPTR(img);
    if(ip) gdImageDestroy(ip);
  }

  return MS_SUCCESS;
}
```


Overlapping Code:
```
dImagePtr ip;
if(img) {
ip = MS_IMAGE_GET_GDIMAGEPTR(img);
if(ip) gdImageDestroy(ip);
}
return MS_SU
```
<Overlap Ratio: 0.704225352112676>

---

--- 259 --
Question ID: d665242e82072ab525b82ff385ab0ebed09c487f_21
Original Code:
```
static int test_platform_param(struct pxa_camera_dev *pcdev,
			       unsigned char buswidth, unsigned long *flags)
{
	/*
	 * Platform specified synchronization and pixel clock polarities are
	 * only a recommendation and are only used during probing. The PXA270
	 * quick capture interface supports both.
	 */
	*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?
		  V4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |
		V4L2_MBUS_HSYNC_ACTIVE_HIGH |
		V4L2_MBUS_HSYNC_ACTIVE_LOW |
		V4L2_MBUS_VSYNC_ACTIVE_HIGH |
		V4L2_MBUS_VSYNC_ACTIVE_LOW |
		V4L2_MBUS_DATA_ACTIVE_HIGH |
		V4L2_MBUS_PCLK_SAMPLE_RISING |
		V4L2_MBUS_PCLK_SAMPLE_FALLING;

	/* If requested data width is supported by the platform, use it */
	if ((1 << (buswidth - 1)) & pcdev->width_flags)
		return 0;

	return -EINVAL;
}
```


Overlapping Code:
```
ram(struct pxa_camera_dev *pcdev,
unsigned char buswidth, unsigned long *flags)
{
/*
* Platform specified synchronization and pixel clock polarities are
* only a recommendation and are only used during probing. The PXA270
* quick capture interface supports both.
*/
*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?
V4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |
V4L2_MBUS_HSYNC_ACTIVE_HIGH |
V4L2_MBUS_HSYNC_ACTIVE_LOW |
V4L2_MBUS_VSYNC_ACTIVE_HIGH |
V4L2_MBUS_VSYNC_ACTIVE_LOW |
V4L2_MBUS_DATA_ACTIVE_HIGH |
V4L2_MBUS_PCLK_SAMPLE_RISING |
V4L2_MBUS_PCLK_SAMPLE_FALLING;
/* If requested data width is supported by the platform, use it */
if ((1 << (buswidth - 1)) & pcdev->width_flags)
return 0;
return -EINVAL;

```
<Overlap Ratio: 0.9619565217391305>

---

--- 260 --
Question ID: 6becac4e83c1579765b25ffcd49243daa78f87bb_5
Original Code:
```
int hwdb_delete(sqldelete *delete) {
    debugf("HWDB: Executing DELETE:\n");
    /* Check table exists */
    if (!itab_table_exists(itab, delete->tablename)) {
        errorf("HWDB: %s no such table\n", delete->tablename);
        return 0;
    }
    if (itab_delete_rows(itab, delete)) {
        return 1;
    }
    return 0;
}
```


Overlapping Code:
```

debugf("HWDB: Executing DELETE:\n");
/* Check table exists */
if (!itab_table_exists(itab, delete->tablename)) {
errorf("HWDB: %s no such table\n", delete->tablename);
return 0;
}
if (itab_delete_row
```
<Overlap Ratio: 0.7194244604316546>

---

--- 261 --
Question ID: eac64358d5b743672d9c4a2b4a095ff8d51370fa_0
Original Code:
```
static int i2ctool_dump(FAR struct i2ctool_s *i2ctool, int fd,
                        uint8_t regaddr, FAR uint8_t *buf, int nbytes)
{
  struct i2c_msg_s msg[2];
  int ret;

  /* Set up data structures */

  if (i2ctool->hasregindx)
    {
      msg[0].frequency = i2ctool->freq;
      msg[0].addr      = i2ctool->addr;
      msg[0].flags     = I2C_M_NOSTOP;
      msg[0].buffer    = &regaddr;
      msg[0].length    = 1;

      msg[1].frequency = i2ctool->freq;
      msg[1].addr      = i2ctool->addr;
      msg[1].flags     = I2C_M_READ;

      msg[1].buffer = buf;
      msg[1].length = nbytes;

      if (i2ctool->start)
        {
          ret = i2cdev_transfer(fd, &msg[0], 1);
          if (ret == OK)
            {
              ret = i2cdev_transfer(fd, &msg[1], 1);
            }
        }
      else
        {
          ret = i2cdev_transfer(fd, msg, 2);
        }
    }
  else
    {
      /* no register index "-r" has been specified so
       * we do a pure read (no write of index)
       */

      msg[0].frequency = i2ctool->freq;
      msg[0].addr      = i2ctool->addr;
      msg[0].flags     = I2C_M_READ;

      msg[0].buffer = buf;
      msg[0].length = nbytes;

      ret = i2cdev_transfer(fd, msg, 1);
    }

  return ret;
}
```


Overlapping Code:
```
(FAR struct i2ctool_s *i2ctool, int fd,
uint8_t regaddr, FAR uint8_t *buf, int nbytes)
{
struct i2c_msg_s msg[2];
int ret;
/* Set up data structures */
if (i2ctool->hasregindx)
{
msg[0].frequency = i2ctool->freq;
msg[0].addr = i2ctool->addr;
msg[0].flags = I2C_M_NOSTOP;
msg[0].buffer = &regaddr;
msg[0].length = 1;
msg[1].frequency = i2ctool->freq;
msg[1].addr = i2ctool->addr;
msg[1].flags = I2C_M_READ;
msg[1].buffer = buf;
msg[1].length = nbytes;
if (i2ctool->start)
{
ret = i2cdev_transfer(fd, &msg[0], 1);
if (ret == OK)
{
ret = i2cdev_transfer(fd, &msg[1], 1);
}
}
else
{
ret = i2cdev_transfer(fd, msg, 2);
}
}
else
{
/* no register index "-r" has been specified so
* we do a pure read (no write of index)
*/
msg[0].frequency = i2ctool->freq;
msg[0].addr = i2ctool->addr;
msg[0].flags = I2C_M_READ;
msg[0].buffer = buf;
msg[0].length = nbytes;
ret = i2cdev_transfer(fd, msg, 1);
}
return ret;

```
<Overlap Ratio: 0.974025974025974>

---

--- 262 --
Question ID: 96627d0ce30ec31ab646f8c050d47752d478ec44_386
Original Code:
```
NK_API int
nk_window_is_any_hovered(struct nk_context *ctx)
{
    struct nk_window *iter;
    NK_ASSERT(ctx);
    if (!ctx) return 0;
    iter = ctx->begin;
    while (iter) {
        /* check if window is being hovered */
        if (iter->flags & NK_WINDOW_MINIMIZED) {
            struct nk_rect header = iter->bounds;
            header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;
            if (nk_input_is_mouse_hovering_rect(&ctx->input, header))
                return 1;
        } else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {
            return 1;
        }
        /* check if window popup is being hovered */
        if (iter->popup.active && iter->popup.win && nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))
            return 1;
        iter = iter->next;
    }
    return 0;
}
```


Overlapping Code:
```
w_is_any_hovered(struct nk_context *ctx)
{
struct nk_window *iter;
NK_ASSERT(ctx);
if (!ctx) return 0;
iter = ctx->begin;
while (iter) {
/* check if window is being hovered */
if (iter->flags & NK_WINDOW_MINIMIZED) {
struct nk_rect header = iter->bounds;
header.h = ctx->style.font->height + 2 * ctx->style.window.header.padding.y;
if (nk_input_is_mouse_hovering_rect(&ctx->input, header))
return 1;
} else if (nk_input_is_mouse_hovering_rect(&ctx->input, iter->bounds)) {
return 1;
}
/* check if window popup is being hovered */
if (iter->popup.active && iter->popup.win && nk_input_is_mouse_hovering_rect(&ctx->input, iter->popup.win->bounds))
return 1;
iter = iter-
```
<Overlap Ratio: 0.9448373408769448>

---

--- 263 --
Question ID: 1ee67b942e59d80360180037d3823ca30b5d6130_2
Original Code:
```
static int
_conversation(int num_msg,
              const struct pam_message **msg,
              struct pam_response **rp,
              void *appdata_ptr)
{
   int i = 0;

   Pam_Config *c = appdata_ptr;

   *rp = (struct pam_response *)calloc(num_msg, sizeof(struct pam_response));
   for (i = 0; i < num_msg; i++) {
      rp[i]->resp_retcode = 0;
      switch (msg[i]->msg_style) {
         case PAM_PROMPT_ECHO_ON:
            if (!c->user)
               c->user = _prompt(msg[i]->msg, true);
            rp[i]->resp = strdup(c->user);
            break;
         case PAM_PROMPT_ECHO_OFF:
            if (c->autologin) {
               printf("Password requested in autologin-mode!\n");
               abort();
            }
            if (!c->password)
               c->password = _prompt(msg[i]->msg, false);
            rp[i]->resp = strdup(c->password);
            break;
         case PAM_TEXT_INFO:
         case PAM_ERROR_MSG:
            printf("%s\n", msg[i]->msg);
            break;
         default:

            break;
      }
   }
   return PAM_SUCCESS;
}
```


Overlapping Code:
```
nt num_msg,
const struct pam_message **msg,
struct pam_response **rp,
void *appdata_ptr)
{
int i = 0;
Pam_Config *c = appdata_ptr;
*rp = (struct pam_response *)calloc(num_msg, sizeof(struct pam_response));
for (i = 0; i < num_msg; i++) {
rp[i]->resp_retcode = 0;
switch (msg[i]->msg_style) {
case PAM_PROMPT_ECHO_ON:
if (!c->user)
c->user = _prompt(msg[i]->msg, true);
rp[i]->resp = strdup(c->user);
break;
case PAM_PROMPT_ECHO_OFF:
if (c->autologin) {
printf("Password requested in autologin-mode!\n");
abort();
}
if (!c->password)
c->password = _prompt(msg[i]->msg, false);
rp[i]->resp = strdup(c->password);
break;
case PAM_TEXT_INFO:
case PAM_ERROR_MSG:
printf("%s\n", msg[i]->msg);
break;
default:
break;
}
}
ret
```
<Overlap Ratio: 0.9421813403416557>

---

--- 264 --
Question ID: 519d9a0d712e0649e71765f6d6589195e27141bf_13
Original Code:
```
void VID_MenuDraw (void)
{
	qpic_t		*p;
	char		*ptr;
	int			nummodes, i, j, column, row, dup;
	char		temp[100];

	vid_wmodes = 0;
	nummodes = VID_NumModes ();
	
	p = Draw_CachePic ("gfx/vidmodes.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	for (i=0 ; i<nummodes ; i++)
	{
		if (vid_wmodes < MAX_MODEDESCS)
		{
			if (i != 1)
			{
				ptr = VID_GetModeDescription (i);

				if (ptr)
				{
					dup = 0;

					for (j=0 ; j<vid_wmodes ; j++)
					{
						if (!strcmp (modedescs[j].desc, ptr))
						{
							if (modedescs[j].modenum != 0)
							{
								modedescs[j].modenum = i;
								dup = 1;

								if (i == vid_modenum)
									modedescs[j].iscur = 1;
							}
							else
							{
								dup = 1;
							}

							break;
						}
					}

					if (!dup)
					{
						modedescs[vid_wmodes].modenum = i;
						modedescs[vid_wmodes].desc = ptr;
						modedescs[vid_wmodes].iscur = 0;

						if (i == vid_modenum)
							modedescs[vid_wmodes].iscur = 1;

						vid_wmodes++;
					}
				}
			}
		}
	}

	vid_column_size = (vid_wmodes + 2) / 3;

	column = 16;
	row = 36;

	for (i=0 ; i<vid_wmodes ; i++)
	{
		if (modedescs[i].iscur)
			M_PrintWhite (column, row, modedescs[i].desc);
		else
			M_Print (column, row, modedescs[i].desc);

		row += 8;

		if ((i % vid_column_size) == (vid_column_size - 1))
		{
			column += 13*8;
			row = 36;
		}
	}

// line cursor
	if (vid_testingmode)
	{
		sprintf (temp, "TESTING %s",
				modedescs[vid_line].desc);
		M_Print (13*8, 36 + MAX_COLUMN_SIZE * 8 + 8*4, temp);
		M_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6,
				"Please wait 5 seconds...");
	}
	else
	{
		M_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8,
				"Press Enter to set mode");
		M_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*3,
				"T to test mode for 5 seconds");
		ptr = VID_GetModeDescription (vid_modenum);
		sprintf (temp, "D to make %s the default", ptr);
		M_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*5, temp);
		ptr = VID_GetModeDescription ((int)_vid_default_mode.value);

		if (ptr)
		{
			sprintf (temp, "Current default is %s", ptr);
			M_Print (7*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6, temp);
		}

		M_Print (15*8, 36 + MAX_COLUMN_SIZE * 8 + 8*8,
				"Esc to exit");

		row = 36 + (vid_line % vid_column_size) * 8;
		column = 8 + (vid_line / vid_column_size) * 13*8;

		M_DrawCharacter (column, row, 12+((int)(realtime*4)&1));
	}
}
```


Overlapping Code:
```
r *ptr;
int nummodes, i, j, column, row, dup;
char temp[100];
vid_wmodes = 0;
nummodes = VID_NumModes ();

p = Draw_CachePic ("gfx/vidmodes.lmp");
M_DrawPic ( (320-p->width)/2, 4, p);
for (i=0 ; i<nummodes ; i++)
{
if (vid_wmodes < MAX_MODEDESCS)
{
if (i != 1)
{
ptr = VID_GetModeDescription (i);
if (ptr)
{
dup = 0;
for (j=0 ; j<vid_wmodes ; j++)
{
if (!strcmp (modedescs[j].desc, ptr))
{
if (modedescs[j].modenum != 0)
{
modedescs[j].modenum = i;
dup = 1;
if (i == vid_modenum)
modedescs[j].iscur = 1;
}
else
{
dup = 1;
}
break;
}
}
if (!dup)
{
modedescs[vid_wmodes].modenum = i;
modedescs[vid_wmodes].desc = ptr;
modedescs[vid_wmodes].iscur = 0;
if (i == vid_modenum)
modedescs[vid_wmodes].iscur = 1;
vid_wmodes++;
}
}
}
}
}
vid_column_size = (vid_wmodes + 2) / 3;
column = 16;
row = 36;
for (i=0 ; i<vid_wmodes ; i++)
{
if (modedescs[i].iscur)
M_PrintWhite (column, row, modedescs[i].desc);
else
M_Print (column, row, modedescs[i].desc);
row += 8;
if ((i % vid_column_size) == (vid_column_size - 1))
{
column += 13*8;
row = 36;
}
}
// line cursor
if (vid_testingmode)
{
sprintf (temp, "TESTING %s",
modedescs[vid_line].desc);
M_Print (13*8, 36 + MAX_COLUMN_SIZE * 8 + 8*4, temp);
M_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6,
"Please wait 5 seconds...");
}
else
{
M_Print (9*8, 36 + MAX_COLUMN_SIZE * 8 + 8,
"Press Enter to set mode");
M_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*3,
"T to test mode for 5 seconds");
ptr = VID_GetModeDescription (vid_modenum);
sprintf (temp, "D to make %s the default", ptr);
M_Print (6*8, 36 + MAX_COLUMN_SIZE * 8 + 8*5, temp);
ptr = VID_GetModeDescription ((int)_vid_default_mode.value);
if (ptr)
{
sprintf (temp, "Current default is %s", ptr);
M_Print (7*8, 36 + MAX_COLUMN_SIZE * 8 + 8*6, temp);
}
M_Print (15*8, 36 + MAX_COLUMN_SIZE * 8 + 8*8,
"Esc to exit");
row = 36 + (vid_line % vid_column_size) * 8;
column = 8 + (vid_line / vid_column_size) * 13*8;
M_DrawCharacter (column, row, 12+((int)(realtime*4)&1)
```
<Overlap Ratio: 0.9764646970455684>

---

--- 265 --
Question ID: c5ed8c2de859210af8c50709c67dcd35009c5cb6_82
Original Code:
```
static inline void hri_i2s_write_CLKCTRL_SLOTSIZE_bf(const void *const hw, uint8_t index, hri_i2s_clkctrl_reg_t data)
{
	uint32_t tmp;
	I2S_CRITICAL_SECTION_ENTER();
	tmp = ((I2s *)hw)->CLKCTRL[index].reg;
	tmp &= ~I2S_CLKCTRL_SLOTSIZE_Msk;
	tmp |= I2S_CLKCTRL_SLOTSIZE(data);
	((I2s *)hw)->CLKCTRL[index].reg = tmp;
	I2S_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
 inline void hri_i2s_write_CLKCTRL_SLOTSIZE_bf(const void *const hw, uint8_t index, hri_i2s_clkctrl_reg_t data)
{
uint32_t tmp;
I2S_CRITICAL_SECTION_ENTER();
tmp = ((I2s *)hw)->CLKCTRL[index].reg;
tmp &= ~I2S_CLKCTRL_SLOTSIZE_Msk;
tmp |= I2S_CLKCTRL_SLOTSIZE(data);
((I2s *)hw)->CLKCTRL[index].reg = tmp;
I2S_CRITICAL_SECTION_LEAVE();
}
```
<Overlap Ratio: 0.9824561403508771>

---

--- 266 --
Question ID: 9af7f15e29011807e50843116b8acac09484c18e_6
Original Code:
```
METHODDEF(void)
h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
			JSAMPARRAY input_data, JSAMPARRAY output_data)
{
  int inrow, outrow;
  JDIMENSION colctr;
  JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
  INT32 membersum, neighsum, memberscale, neighscale;

  /* Expand input data enough to let all the output samples be generated
   * by the standard loop.  Special-casing padded output would be more
   * efficient.
   */
  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
		    cinfo->image_width, output_cols * 2);

  /* We don't bother to form the individual "smoothed" input pixel values;
   * we can directly compute the output which is the average of the four
   * smoothed values.  Each of the four member pixels contributes a fraction
   * (1-8*SF) to its own smoothed image and a fraction SF to each of the three
   * other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
   * output.  The four corner-adjacent neighbor pixels contribute a fraction
   * SF to just one smoothed pixel, or SF/4 to the final output; while the
   * eight edge-adjacent neighbors contribute SF to each of two smoothed
   * pixels, or SF/2 overall.  In order to use integer arithmetic, these
   * factors are scaled by 2^16 = 65536.
   * Also recall that SF = smoothing_factor / 1024.
   */

  memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
  neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */

  inrow = 0;
  for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
    outptr = output_data[outrow];
    inptr0 = input_data[inrow];
    inptr1 = input_data[inrow+1];
    above_ptr = input_data[inrow-1];
    below_ptr = input_data[inrow+2];

    /* Special case for first column: pretend column -1 is same as column 0 */
    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
	       GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +
	       GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);
    neighsum += neighsum;
    neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +
		GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
    inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;

    for (colctr = output_cols - 2; colctr > 0; colctr--) {
      /* sum of pixels directly mapped to this output element */
      membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		  GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
      /* sum of edge-neighbor pixels */
      neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
		 GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
		 GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[2]) +
		 GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[2]);
      /* The edge-neighbors count twice as much as corner-neighbors */
      neighsum += neighsum;
      /* Add in the corner-neighbors */
      neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[2]) +
		  GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[2]);
      /* form final output scaled up by 2^16 */
      membersum = membersum * memberscale + neighsum * neighscale;
      /* round, descale and output it */
      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
      inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
    }

    /* Special case for last column */
    membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
		GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
    neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
	       GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
	       GETJSAMPLE(inptr0[-1]) + GETJSAMPLE(inptr0[1]) +
	       GETJSAMPLE(inptr1[-1]) + GETJSAMPLE(inptr1[1]);
    neighsum += neighsum;
    neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
    membersum = membersum * memberscale + neighsum * neighscale;
    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);

    inrow += 2;
  }
}
```


Overlapping Code:
```
_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
JSAMPARRAY input_data, JSAMPARRAY output_data)
{
int inrow, outrow;
JDIMENSION colctr;
JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
INT32 membersum, neighsum, memberscale, neighscale;
/* Expand input data enough to let all the output samples be generated
* by the standard loop. Special-casing padded output would be more
* efficient.
*/
expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
cinfo->image_width, output_cols * 2);
/* We don't bother to form the individual "smoothed" input pixel values;
* we can directly compute the output which is the average of the four
* smoothed values. Each of the four member pixels contributes a fraction
* (1-8*SF) to its own smoothed image and a fraction SF to each of the three
* other smoothed pixels, therefore a total fraction (1-5*SF)/4 to the final
* output. The four corner-adjacent neighbor pixels contribute a fraction
* SF to just one smoothed pixel, or SF/4 to the final output; while the
* eight edge-adjacent neighbors contribute SF to each of two smoothed
* pixels, or SF/2 overall. In order to use integer arithmetic, these
* factors are scaled by 2^16 = 65536.
* Also recall that SF = smoothing_factor / 1024.
*/
memberscale = 16384 - cinfo->smoothing_factor * 80; /* scaled (1-5*SF)/4 */
neighscale = cinfo->smoothing_factor * 16; /* scaled SF/4 */
inrow = 0;
for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
outptr = output_data[outrow];
inptr0 = input_data[inrow];
inptr1 = input_data[inrow+1];
above_ptr = input_data[inrow-1];
below_ptr = input_data[inrow+2];
/* Special case for first column: pretend column -1 is same as column 0 */
membersum = GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1]);
neighsum = GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[1]) +
GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[1]) +
GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[2]) +
GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[2]);
neighsum += neighsum;
neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +
GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);
membersum = membersum * memberscale + neighsum * neighscale;
*outptr++ = (JSAMPLE) ((membersum +
```
<Overlap Ratio: 0.990166737922189>

---

--- 267 --
Question ID: f95ea6063246954da5f484aab781b57da03b7720_0
Original Code:
```
_Use_decl_annotations_
void StrArrCat(CharPtrPtr * self_, ConstCharPtr str)
{
    size_t len;
    CharPtrPtr self = *self_;

    len = StrArrLen(self);
    self = (CharPtrPtr)PAL_Realloc(self, sizeof(char*) * (len + 2));

    if (self)
    {
        CharPtr s = PAL_Strdup(str);
        self[len] = s;
        self[len+1] = NULL;
    }

#ifdef _PREFAST_
#pragma prefast (push)
#pragma prefast (disable: 26036)
#endif
    /* 
        OACR does not like NULL-ing buffers by using length above, instead it wants us to walk the entire array manually.
        This isn't necessary here. The logic is correct. 
    */
    *self_ = self;
#ifdef _PREFAST_
#pragma prefast (pop)
#endif
}
```


Overlapping Code:
```
rrCat(CharPtrPtr * self_, ConstCharPtr str)
{
size_t len;
CharPtrPtr self = *self_;
len = StrArrLen(self);
self = (CharPtrPtr)PAL_Realloc(self, sizeof(char*) * (len + 2));
if (self)
{
CharPtr s = PAL_Strdup(str);
self[len] = s;
self[len+1] = NULL;
}
#ifdef _PREFAST_
#pragma prefast (push)
#pragma prefast (disable: 26036)
#endif
/* 
OACR does not like NULL-ing buffers by using length above, instead it wants us to walk the entire array manually.
This isn't necessary here. The logic is correct. 
*/
*self_ = self;
#ifdef _PREFAST_
#pragma prefast (
```
<Overlap Ratio: 0.9243697478991597>

---

--- 268 --
Question ID: 8589f1fd337e3a2b645f9adf308c8d5c6482b62c_27
Original Code:
```
void XVphy_SetPllLayoutErrorCallback(XVphy *InstancePtr,
		void *CallbackFunc, void *CallbackRef)
{
	/* Verify arguments. */
	Xil_AssertVoid(InstancePtr != NULL);
	Xil_AssertVoid(CallbackFunc != NULL);
	Xil_AssertVoid(CallbackRef != NULL);

	InstancePtr->PllLayoutErrorCallback = (XVphy_ErrorCallback)CallbackFunc;
	InstancePtr->PllLayoutErrorRef = CallbackRef;
}
```


Overlapping Code:
```
tErrorCallback(XVphy *InstancePtr,
void *CallbackFunc, void *CallbackRef)
{
/* Verify arguments. */
Xil_AssertVoid(InstancePtr != NULL);
Xil_AssertVoid(CallbackFunc != NULL);
Xil_AssertVoid(CallbackRef != NULL);
InstancePtr->PllLayoutErrorCallback = (XVphy_ErrorCallback)CallbackFunc;
InstancePtr->PllLayoutErrorRe
```
<Overlap Ratio: 0.8870056497175142>

---

--- 269 --
Question ID: d206af568628fe6102209af84f0b5b12b8fb734c_12
Original Code:
```
static readstat_error_t xport_read_labels_v9(xport_ctx_t *ctx, int label_count) {
    readstat_error_t retval = READSTAT_OK;
    uint16_t labeldef[5];
    int i;
    for (i=0; i<label_count; i++) {
        int index, name_len, format_len, informat_len, label_len;
        if (read_bytes(ctx, labeldef, sizeof(labeldef)) != sizeof(labeldef)) {
            retval = READSTAT_ERROR_READ;
            goto cleanup;
        }

        if (machine_is_little_endian()) {
            index = byteswap2(labeldef[0]);
            name_len = byteswap2(labeldef[1]);
            format_len = byteswap2(labeldef[2]);
            informat_len = byteswap2(labeldef[3]);
            label_len = byteswap2(labeldef[4]);
        } else {
            index = labeldef[0];
            name_len = labeldef[1];
            format_len = labeldef[2];
            informat_len = labeldef[3];
            label_len = labeldef[4];
        }

        if (index >= ctx->var_count) {
            retval = READSTAT_ERROR_PARSE;
            goto cleanup;
        }

#if !defined _MSC_VER
        char name[name_len+1];
        char format[format_len+1];
        char informat[informat_len+1];
        char label[label_len+1];
#else
        char * name = malloc((sizeof(char))*(name_len + 1 + 1));
        char * format = malloc((sizeof(char))*(format_len + 1 + 1));
        char * informat = malloc((sizeof(char))*(informat_len + 1 + 1));
        char * label = malloc((sizeof(char))*(label_len + 1 + 1));
#endif

        readstat_variable_t *variable = ctx->variables[index];

        if (read_bytes(ctx, name, name_len) != name_len ||
                read_bytes(ctx, format, format_len) != format_len ||
                read_bytes(ctx, informat, informat_len) != informat_len ||
                read_bytes(ctx, label, label_len) != label_len) {
            retval = READSTAT_ERROR_READ;
#if defined _MSC_VER
            free(name);
            free(format);
            free(informat);
            free(label);
#endif
            goto cleanup;
        }

        retval = readstat_convert(variable->name, sizeof(variable->name),
                name, name_len,  NULL);
#if defined _MSC_VER
        free(name);
#endif
        if (retval != READSTAT_OK) {
#if defined _MSC_VER
            free(format);
            free(informat);
            free(label);
#endif
            goto cleanup;
        }

        retval = readstat_convert(variable->label, sizeof(variable->label),
                label, label_len,  NULL);
#if defined _MSC_VER
        free(label);
#endif
        if (retval != READSTAT_OK) {
#if defined _MSC_VER
            free(format);
            free(informat);
#endif
            goto cleanup;
        }

        retval = xport_construct_format(variable->format, sizeof(variable->format),
                format, format_len, variable->display_width, variable->decimals);
#if defined _MSC_VER
        free(format);
        free(informat);
#endif
        if (retval != READSTAT_OK)
            goto cleanup;
    }

    retval = xport_skip_rest_of_record(ctx);
    if (retval != READSTAT_OK)
        goto cleanup;

    retval = xport_read_obs_header_record(ctx);
    if (retval != READSTAT_OK)
        goto cleanup;

cleanup:
    return retval;
}
```


Overlapping Code:
```
t xport_read_labels_v9(xport_ctx_t *ctx, int label_count) {
readstat_error_t retval = READSTAT_OK;
uint16_t labeldef[5];
int i;
for (i=0; i<label_count; i++) {
int index, name_len, format_len, informat_len, label_len;
if (read_bytes(ctx, labeldef, sizeof(labeldef)) != sizeof(labeldef)) {
retval = READSTAT_ERROR_READ;
goto cleanup;
}
if (machine_is_little_endian()) {
index = byteswap2(labeldef[0]);
name_len = byteswap2(labeldef[1]);
format_len = byteswap2(labeldef[2]);
informat_len = byteswap2(labeldef[3]);
label_len = byteswap2(labeldef[4]);
} else {
index = labeldef[0];
name_len = labeldef[1];
format_len = labeldef[2];
informat_len = labeldef[3];
label_len = labeldef[4];
}
if (index >= ctx->var_count) {
retval = READSTAT_ERROR_PARSE;
goto cleanup;
}
#if !defined _MSC_VER
char name[name_len+1];
char format[format_len+1];
char informat[informat_len+1];
char label[label_len+1];
#else
char * name = malloc((sizeof(char))*(name_len + 1 + 1));
char * format = malloc((sizeof(char))*(format_len + 1 + 1));
char * informat = malloc((sizeof(char))*(informat_len + 1 + 1));
char * label = malloc((sizeof(char))*(label_len + 1 + 1));
#endif
readstat_variable_t *variable = ctx->variables[index];
if (read_bytes(ctx, name, name_len) != name_len ||
read_bytes(ctx, format, format_len) != format_len ||
read_bytes(ctx, informat, informat_len) != informat_len ||
read_bytes(ctx, label, label_len) != label_len) {
retval = READSTAT_ERROR_READ;
#if defined _MSC_VER
free(name);
free(format);
free(informat);
free(label);
#endif
goto cleanup;
}
retval = readstat_convert(variable->name, sizeof(variable->name),
name, name_len, NULL);
#if defined _MSC_VER
free(name);
#endif
if (retval != READSTAT_OK) {
#if defined _MSC_VER
free(format);
free(informat);
free(label);
#endif
goto cleanup;
}
retval = readstat_convert(variable->label, sizeof(variable->label),
label, label_len, NULL);
```
<Overlap Ratio: 0.9811912225705329>

---

--- 270 --
Question ID: 639b38d643e6d7418c94b78c8e242a8797178d51_79
Original Code:
```
static enum sess_status
cnt_http_pipe_end(struct sess *sp)
{

	vca_close_session(sp, "pipe");
	VBE_CloseFd(sp, &sp->vc, 0);

	AZ(sp->wrkvar.wfd);
	sp->wrkvar.bereq = NULL;
	if ((sp->flags & SESS_F_ERROR) != 0) {
		AN(sp->err_code);
		AN(sp->err_reason);
		assert((sp->flags & SESS_F_ERROR) != 0);
		sp->step = STP_HTTP_ERROR;
	} else
		sp->step = STP_DONE;
	return (SESS_CONTINUE);
}
```


Overlapping Code:
```
pipe_end(struct sess *sp)
{
vca_close_session(sp, "pipe");
VBE_CloseFd(sp, &sp->vc, 0);
AZ(sp->wrkvar.wfd);
sp->wrkvar.bereq = NULL;
if ((sp->flags & SESS_F_ERROR) != 0) {
AN(sp->err_code);
AN(sp->err_reason);
assert((sp->flags & SESS_F_ERROR) != 0);
sp->step = STP_HTTP_ERROR;
} else
sp->step = STP_
```
<Overlap Ratio: 0.8241758241758241>

---

--- 271 --
Question ID: 0aeb8a62bff4532737de9b9d265112bbf4e5fc6a_0
Original Code:
```
void spi_init(void)
{
  SPI_PORT(DIR) |= (MOSI_PIN + SCK_PIN + W_PIN + CS_PIN);
  SPI_PORT(DIR) &= ~(MISO_PIN);
  SPI_PORT(REN) &= ~(MISO_PIN);
  
  TSL_HIGH;
  CS_HIGH;
  SCK_LOW;
}
```


Overlapping Code:
```
pi_init(void)
{
SPI_PORT(DIR) |= (MOSI_PIN + SCK_PIN + W_PIN + CS_PIN);
SPI_PORT(DIR) &= ~(MISO_PIN);
SPI_PORT(REN) &= ~(MISO_PIN);

TSL_HIGH;
CS_HIGH
```
<Overlap Ratio: 0.8928571428571429>

---

--- 272 --
Question ID: 39666398b7b6f3903618980f42251f099eca5d67_16
Original Code:
```
char* path_to_string(unsigned short* path, int length){
    int i;
    char* path_string = calloc((length+1),sizeof(char));
    for(i=0; i<length; i++){
        strncat(path_string, (path[i] == 0?"0":"1"), 1);
    }
    path_string[length] = '\0';
    return path_string;
}
```


Overlapping Code:
```
h, int length){
int i;
char* path_string = calloc((length+1),sizeof(char));
for(i=0; i<length; i++){
strncat(path_string, (path[i] == 0?"0":"1"), 1);
}
path_string[length] = '\0';
return path_string;

```
<Overlap Ratio: 0.8298755186721992>

---

--- 273 --
Question ID: 803277d15c6727a1e6fe7a613dd3598d51c56c5d_0
Original Code:
```
int MPI_Type_create_subarray(int ndims, int *array_of_sizes, 
                             int *array_of_subsizes, int *array_of_starts,
                             int order, MPI_Datatype oldtype, 
                             MPI_Datatype *newtype)
{
    MPI_Aint extent, disps[3], size, size_with_aint;
    int i, blklens[3];
    MPI_Datatype tmp1, tmp2, types[3];
    MPI_Offset size_with_offset;

    if (ndims <= 0) {
	FPRINTF(stderr, "MPI_Type_create_subarray: Invalid ndims argument\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }
    if (array_of_sizes <= (int *) 0) {
	FPRINTF(stderr, "MPI_Type_create_subarray: array_of_sizes is an invalid address\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }
    if (array_of_subsizes <= (int *) 0) {
	FPRINTF(stderr, "MPI_Type_create_subarray: array_of_subsizes is an invalid address\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }
    if (array_of_starts <= (int *) 0) {
	FPRINTF(stderr, "MPI_Type_create_subarray: array_of_starts is an invalid address\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }

    for (i=0; i<ndims; i++) {
        if (array_of_sizes[i] <= 0) {
            FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_sizes\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        if (array_of_subsizes[i] <= 0) {
            FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_subsizes\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        if (array_of_starts[i] < 0) {
            FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_starts\n");
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        if (array_of_subsizes[i] > array_of_sizes[i]) {
            FPRINTF(stderr, "MPI_Type_create_subarray: Error! array_of_subsizes[%d] > array_of_sizes[%d]\n", i, i);
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
        if (array_of_starts[i] > (array_of_sizes[i] - array_of_subsizes[i])) {
            FPRINTF(stderr, "MPI_Type_create_subarray: Error! array_of_starts[%d] > (array_of_sizes[%d] - array_of_subsizes[%d])\n", i, i, i);
            MPI_Abort(MPI_COMM_WORLD, 1);
        }
    }

    /* order argument checked below */

    if (oldtype == MPI_DATATYPE_NULL) {
        FPRINTF(stderr, "MPI_Type_create_subarray: oldtype is an invalid datatype\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    MPI_Type_extent(oldtype, &extent);

/* check if MPI_Aint is large enough for size of global array. 
   if not, complain. */

    size_with_aint = extent;
    for (i=0; i<ndims; i++) size_with_aint *= array_of_sizes[i];
    size_with_offset = extent;
    for (i=0; i<ndims; i++) size_with_offset *= array_of_sizes[i];
    if (size_with_aint != size_with_offset) {
	FPRINTF(stderr, "MPI_Type_create_subarray: Can't use an array of this size unless the MPI implementation defines a 64-bit MPI_Aint\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }

    if (order == MPI_ORDER_FORTRAN) {
      /* dimension 0 changes fastest */
	if (ndims == 1)
	    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);
	else {
	    MPI_Type_vector(array_of_subsizes[1], array_of_subsizes[0],
			    array_of_sizes[0], oldtype, &tmp1);
	    
	    size = array_of_sizes[0]*extent;
	    for (i=2; i<ndims; i++) {
		size *= array_of_sizes[i-1];
		MPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);
		MPI_Type_free(&tmp1);
		tmp1 = tmp2;
	    }
	}
	
	/* add displacement and UB */
	
	disps[1] = array_of_starts[0];
	size = 1;
	for (i=1; i<ndims; i++) {
	    size *= array_of_sizes[i-1];
	    disps[1] += size*array_of_starts[i];
	}  
        /* rest done below for both Fortran and C order */
    }

    else if (order == MPI_ORDER_C) {
	/* dimension ndims-1 changes fastest */
	if (ndims == 1)
	    MPI_Type_contiguous(array_of_subsizes[0], oldtype, &tmp1);
	else {
	    MPI_Type_vector(array_of_subsizes[ndims-2],
			    array_of_subsizes[ndims-1],
			    array_of_sizes[ndims-1], oldtype, &tmp1);
	    
	    size = array_of_sizes[ndims-1]*extent;
	    for (i=ndims-3; i>=0; i--) {
		size *= array_of_sizes[i+1];
		MPI_Type_hvector(array_of_subsizes[i], 1, size, tmp1, &tmp2);
		MPI_Type_free(&tmp1);
		tmp1 = tmp2;
	    }
	}
	
	/* add displacement and UB */
	
	disps[1] = array_of_starts[ndims-1];
	size = 1;
	for (i=ndims-2; i>=0; i--) {
	    size *= array_of_sizes[i+1];
	    disps[1] += size*array_of_starts[i];
	}
    }
    else {
	FPRINTF(stderr, "MPI_Type_create_subarray: Invalid order argument\n");
	MPI_Abort(MPI_COMM_WORLD, 1);
    }
    
    disps[1] *= extent;
    
    disps[2] = extent;
    for (i=0; i<ndims; i++) disps[2] *= array_of_sizes[i];
    
    disps[0] = 0;
    blklens[0] = blklens[1] = blklens[2] = 1;
    types[0] = MPI_LB;
    types[1] = tmp1;
    types[2] = MPI_UB;
    
    MPI_Type_struct(3, blklens, disps, types, newtype);

    MPI_Type_free(&tmp1);

    return MPI_SUCCESS;
}
```


Overlapping Code:
```
y(int ndims, int *array_of_sizes, 
int *array_of_subsizes, int *array_of_starts,
int order, MPI_Datatype oldtype, 
MPI_Datatype *newtype)
{
MPI_Aint extent, disps[3], size, size_with_aint;
int i, blklens[3];
MPI_Datatype tmp1, tmp2, types[3];
MPI_Offset size_with_offset;
if (ndims <= 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: Invalid ndims argument\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_sizes <= (int *) 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: array_of_sizes is an invalid address\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_subsizes <= (int *) 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: array_of_subsizes is an invalid address\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_starts <= (int *) 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: array_of_starts is an invalid address\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
for (i=0; i<ndims; i++) {
if (array_of_sizes[i] <= 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_sizes\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_subsizes[i] <= 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_subsizes\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_starts[i] < 0) {
FPRINTF(stderr, "MPI_Type_create_subarray: Invalid value in array_of_starts\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_subsizes[i] > array_of_sizes[i]) {
FPRINTF(stderr, "MPI_Type_create_subarray: Error! array_of_subsizes[%d] > array_of_sizes[%d]\n", i, i);
MPI_Abort(MPI_COMM_WORLD, 1);
}
if (array_of_starts[i] > (array_of_sizes[i] - array_of_subsizes[i])) {
FPRINTF(stderr, "MPI_Type_create_subarray: Error! array_of_starts[%d] > (array_of_sizes[%d] - array_of_subsizes[%d])\n", i, i, i);
MPI_Abort(MPI_COMM_WORLD, 1);
}
}
/* order argument checked below */
if (oldtype == MPI_DATATYPE_NULL) {
FPRINTF(stderr, "MPI_Type_create_subarray: oldtype is an invalid datatype\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
MPI_Type_extent(oldtype, &extent);
/* check if MPI_Aint is large enough for size of global array. 
if not, complain. */
size_with_aint = extent;
for (i
```
<Overlap Ratio: 0.9861773117254529>

---

--- 274 --
Question ID: 55073c5c231e586507afbe15a6484f8f11b642c6_1
Original Code:
```
int airparse_add_packet( unsigned char *h80211, int caplen, int power )
{
    int i, n;

    struct pcap_pkthdr pkh;

    unsigned char *p;
    unsigned char bssid[6];

    ap_cur = NULL;

    pkh.caplen = pkh.len = caplen;

    /* skip packets smaller than a 802.11 header */

    if( pkh.caplen < 24 )
        goto write_packet;

    /* skip (uninteresting) control frames */

    if( ( h80211[0] & 0x0C ) == 0x04 )
        goto write_packet;

    /* skip management frames without an ESSID */

    if( ( h80211[0] & 0x0C ) == 0x00 )
        if( ( h80211[0] & 0xF0 ) != 0x00 &&
            ( h80211[0] & 0xF0 ) != 0x50 &&
            ( h80211[0] & 0xF0 ) != 0x80 )
            goto write_packet;

    /* locate the BSSID (AP's MAC) in the 802.11 header */

    switch( h80211[1] & 3 )
    {
        case  0: memcpy( bssid, h80211 + 16, 6 ); break;
        case  1: memcpy( bssid, h80211 +  4, 6 ); break;
        case  2: memcpy( bssid, h80211 + 10, 6 ); break;
        default: memcpy( bssid, h80211 +  4, 6 ); break;
    }

    /* update our chained list of access points */

    ap_cur = ap_1st;
    ap_prv = NULL;

    while( ap_cur != NULL )
    {
        if( ! memcmp( ap_cur->bssid, bssid, 6 ) )
            break;

        ap_prv = ap_cur;
        ap_cur = ap_cur->next;
    }

    /* if it's a new access point, add it */

    if( ap_cur == NULL )
    {
        if( ! ( ap_cur = (struct AP_info *) malloc(
                         sizeof( struct AP_info ) ) ) )
            return( 1 );

        memset( ap_cur, 0, sizeof( struct AP_info ) );

        if( ap_1st == NULL )
            ap_1st = ap_cur;
        else
            ap_prv->next  = ap_cur;

        memcpy( ap_cur->bssid, bssid, 6 );

        ap_cur->prev = ap_prv;

        ap_cur->tinit = time( NULL );
        ap_cur->tlast = time( NULL );
        ap_cur->power = power;
        ap_cur->chanl = -1;
        ap_cur->speed = -1;
        ap_cur->crypt = -1;

        ap_end = ap_cur;
    }

    /* every 1s, update the last time seen & receive power */

    if( time( NULL ) - ap_cur->tlast >= 1 )
    {
        ap_cur->tlast = time( NULL );
        ap_cur->power = power;
    }

    ap_cur->nb_pkt++;

    /* packet parsing: Beacon or Probe Response */

    if( h80211[0] == 0x80 ||
        h80211[0] == 0x50 )
    {
        ap_cur->crypt = ( h80211[34] & 0x10 ) >> 4;

        p = h80211 + 36;

        while( p < h80211 + pkh.caplen )
        {
            if( p + 2 + p[1] > h80211 + pkh.caplen )
                break;

            if( p[0] == 0x00 && p[2] != '\0' )
            {
                /* found a non-cloaked ESSID */

                n = ( p[1] > 32 ) ? 32 : p[1];

                memset( ap_cur->essid, 0, 33 );
                memcpy( ap_cur->essid, p + 2, n );

                for( i = 0; i < n; i++ )
                    if( ap_cur->essid[i] < ' ' )
                        ap_cur->essid[i] = '.';
            }

            if( p[0] == 0x03 )
                ap_cur->chanl = p[2];

            if( p[0] == 0x01 || p[0] == 0x32 )
                ap_cur->speed = ( p[1 + p[1]] & 0x7F ) / 2;

            if( p[0] == 0xDD )
                ap_cur->crypt++;

            p += 2 + p[1];
        }
    }

    /* packet parsing: Association Request */

    if( h80211[0] == 0x00 )
    {
        p = h80211 + 28;

        while( p < h80211 + pkh.caplen )
        {
            if( p + 2 + p[1] > h80211 + pkh.caplen )
                break;

            if( p[0] == 0x00 && p[2] != '\0' )
            {
                /* found a non-cloaked ESSID */

                n = ( p[1] > 32 ) ? 32 : p[1];

                memset( ap_cur->essid, 0, 33 );
                memcpy( ap_cur->essid, p + 2, n );

                for( i = 0; i < n; i++ )
                    if( ap_cur->essid[i] < ' ' )
                        ap_cur->essid[i] = '.';
            }

            p += 2 + p[1];
        }
    }

    /* packet parsing: non-encrypted data */

    if( ( h80211[0] & 0x0C ) == 0x08 &&
        ( h80211[1] & 0x40 ) == 0x00 )
    {
        if( memcmp( h80211 + 24, ARP_REQUEST_HEADER, 14 ) == 0 )
            memcpy( ap_cur->lanip, h80211 + 46, 4 );
    }

    /* packet parsing: WEP encrypted data */

    if( ( h80211[0] & 0x0C ) == 0x08 &&
        ( h80211[1] & 0x40 ) == 0x40 )
    {
        int z = ( ( h80211[1] & 3 ) != 3 ) ? 24 : 30;

        for( i = 0; i < 64; i++ )
            if( ! memcmp( ap_cur->seen_ivs[i], h80211 + z, 3 ) )
                return( 0 );

        n = ap_cur->s_index;
        memcpy( ap_cur->seen_ivs[n++], h80211 + z, 3 );

        ap_cur->s_index = n % 64;
        ap_cur->nb_ivs++;
    }

write_packet:

    if( mac_filter != NULL )
    {
        /* reject packets that do not contain the specified MAC */

        if( ( h80211[1] & 3 ) != 3 )
        {
            if( memcmp( h80211 +  4, mac_filter, 6 ) &&
                memcmp( h80211 + 10, mac_filter, 6 ) &&
                memcmp( h80211 + 16, mac_filter, 6 ) )
                return( 0 );
        }
        else
        {
            if( memcmp( h80211 +  4, mac_filter, 6 ) &&
                memcmp( h80211 + 10, mac_filter, 6 ) &&
                memcmp( h80211 + 16, mac_filter, 6 ) &&
                memcmp( h80211 + 24, mac_filter, 6 ) )
                return( 0 );
        }
    }

    /* finally append the packet to the pcap file */

#ifndef WIN32
    gettimeofday( &pkh.ts, NULL );
#else
    pkh.tv_sec  = time( NULL );
    pkh.tv_usec = 0;
#endif

    n = sizeof( pkh );

    if( fwrite( &pkh, 1, n, f_cap ) != (size_t) n )
    {
        fprintf( stderr, "fwrite(packet header) failed\n" );
        return( 1 );
    }

    n = pkh.caplen;

    if( fwrite( h80211, 1, n, f_cap ) != (size_t) n )
    {
        fprintf( stderr, "fwrite(packet data) failed\n" );
        return( 1 );
    }

    return( 0 );
}
```


Overlapping Code:
```
d char *h80211, int caplen, int power )
{
int i, n;
struct pcap_pkthdr pkh;
unsigned char *p;
unsigned char bssid[6];
ap_cur = NULL;
pkh.caplen = pkh.len = caplen;
/* skip packets smaller than a 802.11 header */
if( pkh.caplen < 24 )
goto write_packet;
/* skip (uninteresting) control frames */
if( ( h80211[0] & 0x0C ) == 0x04 )
goto write_packet;
/* skip management frames without an ESSID */
if( ( h80211[0] & 0x0C ) == 0x00 )
if( ( h80211[0] & 0xF0 ) != 0x00 &&
( h80211[0] & 0xF0 ) != 0x50 &&
( h80211[0] & 0xF0 ) != 0x80 )
goto write_packet;
/* locate the BSSID (AP's MAC) in the 802.11 header */
switch( h80211[1] & 3 )
{
case 0: memcpy( bssid, h80211 + 16, 6 ); break;
case 1: memcpy( bssid, h80211 + 4, 6 ); break;
case 2: memcpy( bssid, h80211 + 10, 6 ); break;
default: memcpy( bssid, h80211 + 4, 6 ); break;
}
/* update our chained list of access points */
ap_cur = ap_1st;
ap_prv = NULL;
while( ap_cur != NULL )
{
if( ! memcmp( ap_cur->bssid, bssid, 6 ) )
break;
ap_prv = ap_cur;
ap_cur = ap_cur->next;
}
/* if it's a new access point, add it */
if( ap_cur == NULL )
{
if( ! ( ap_cur = (struct AP_info *) malloc(
sizeof( struct AP_info ) ) ) )
return( 1 );
memset( ap_cur, 0, sizeof( struct AP_info ) );
if( ap_1st == NULL )
ap_1st = ap_cur;
else
ap_prv->next = ap_cur;
memcpy( ap_cur->bssid, bssid, 6 );
ap_cur->prev = ap_prv;
ap_cur->tinit = time( NULL );
ap_cur->tlast = time( NULL );
ap_cur->power = power;
ap_cur->chanl = -1;
ap_cur->speed = -1;
ap_cur->crypt = -1;
ap_end = ap_cur;
}
/* every 1s, update the last time seen & receive power */
if( time( NULL ) - ap_cur->tlast >= 1 )
{
ap_cur->tlast = time( NULL );
ap_cur->power = power;
}
ap_cur->nb_pkt++;
/* packet parsing: Beacon or Probe Response */
if( h80211[0] == 0x80 ||
h80211[0] == 0x50 )
{
ap_cur->crypt = ( h80211[34] & 0x10 ) >> 4;
p = h80211 + 36;
while( p < h80211 + pkh.caplen )
{
if( p + 2 + p[1] > h80211 + pkh.caplen )
break;
```
<Overlap Ratio: 0.983547557840617>

---

--- 275 --
Question ID: 65bdfdb56877ee0297d9e605384caedbcbed286c_39
Original Code:
```
int main(int argc, char **argv)
{
	struct module *mod;
	struct buffer buf = { };
	char fname[SZ];
	char *kernel_read = NULL, *module_read = NULL;
	char *dump_write = NULL;
	int opt;
	int err;

	while ((opt = getopt(argc, argv, "i:I:mo:aw")) != -1) {
		switch(opt) {
			case 'i':
				kernel_read = optarg;
				break;
			case 'I':
				module_read = optarg;
				external_module = 1;
				break;
			case 'm':
				modversions = 1;
				break;
			case 'o':
				dump_write = optarg;
				break;
			case 'a':
				all_versions = 1;
				break;
			case 'w':
				warn_unresolved = 1;
				break;
			default:
				exit(1);
		}
	}

	if (kernel_read)
		read_dump(kernel_read, 1);
	if (module_read)
		read_dump(module_read, 0);

	while (optind < argc) {
		read_symbols(argv[optind++]);
	}

	for (mod = modules; mod; mod = mod->next) {
		if (mod->skip)
			continue;
		check_exports(mod);
	}

	err = 0;

	for (mod = modules; mod; mod = mod->next) {
		if (mod->skip)
			continue;

		buf.pos = 0;

		add_header(&buf, mod);
		err |= add_versions(&buf, mod);
		add_depends(&buf, mod, modules);
		add_moddevtable(&buf, mod);
		add_srcversion(&buf, mod);

		sprintf(fname, "%s.mod.c", mod->name);
		write_if_changed(&buf, fname);
	}

	if (dump_write)
		write_dump(dump_write);

	return err;
}
```


Overlapping Code:
```
 argc, char **argv)
{
struct module *mod;
struct buffer buf = { };
char fname[SZ];
char *kernel_read = NULL, *module_read = NULL;
char *dump_write = NULL;
int opt;
int err;
while ((opt = getopt(argc, argv, "i:I:mo:aw")) != -1) {
switch(opt) {
case 'i':
kernel_read = optarg;
break;
case 'I':
module_read = optarg;
external_module = 1;
break;
case 'm':
modversions = 1;
break;
case 'o':
dump_write = optarg;
break;
case 'a':
all_versions = 1;
break;
case 'w':
warn_unresolved = 1;
break;
default:
exit(1);
}
}
if (kernel_read)
read_dump(kernel_read, 1);
if (module_read)
read_dump(module_read, 0);
while (optind < argc) {
read_symbols(argv[optind++]);
}
for (mod = modules; mod; mod = mod->next) {
if (mod->skip)
continue;
check_exports(mod);
}
err = 0;
for (mod = modules; mod; mod = mod->next) {
if (mod->skip)
continue;
buf.pos = 0;
add_header(&buf, mod);
err |= add_versions(&buf, mod);
add_depends(&buf, mod, modules);
add_moddevtable(&buf, mod);
add_srcversion(&buf, mod);
sprintf(fname, "%s.mod.c", mod->name);
write_if_changed(&buf, fname);
}
if (dump_write)
write_dump(dump_write);
return err
```
<Overlap Ratio: 0.9865470852017937>

---

--- 276 --
Question ID: fbb2755ac7cbe9db2b6c3c705b258971ff65a0ce_0
Original Code:
```
static bool CanExportFunction(const UClass* Class, const UFunction* Function)
	{		
		// Delegate function is not a real function.
		if ((Function->FunctionFlags & FUNC_Delegate))
		{
			return false;
		}

		// Skip unsupported type or delegate properties which are handled in dedicated code path.
		for (TFieldIterator<FProperty> ParamIt(Function); ParamIt; ++ParamIt)
		{
			FProperty* Param = *ParamIt;
			if (Param->ArrayDim > 1 ||
				Param->IsA(FDelegateProperty::StaticClass()) ||
				Param->IsA(FMulticastDelegateProperty::StaticClass()) ||
				Param->IsA(FInterfaceProperty::StaticClass()))
			{
				return false;
			}
		}

		return true;
	}
```


Overlapping Code:
```
atic bool CanExportFunction(const UClass* Class, const UFunction* Function)
{ 
// Delegate function is not a real function.
if ((Function->FunctionFlags & FUNC_Delegate))
{
return false;
}
// Skip unsupported type or delegate properties which are handled in dedicated code path.
for (TFieldIterator<FProperty> ParamIt(Function); ParamIt; ++ParamIt)
{
FProperty* Param = *ParamIt;
if (Param->ArrayDim > 1 ||
Param->IsA(FDelegateProperty::StaticClass()) ||
Param->IsA(FMulticastDelegateProperty::StaticClass()) ||
Param->IsA(FInterfaceProperty::StaticClass()))
{
return false;
}
}
return
```
<Overlap Ratio: 0.9831932773109243>

---

--- 277 --
Question ID: 325c05233878b4be79f49f99e632029c43ff3872_22
Original Code:
```
TEST_FUNCTION(AMQP_ProcessItem)
{
    // arrange
    TRANSPORT_PROVIDER* provider = (TRANSPORT_PROVIDER*)AMQP_Protocol();

    umock_c_reset_all_calls();
    STRICT_EXPECTED_CALL(IoTHubTransport_AMQP_Common_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE));

    // act
    IOTHUB_PROCESS_ITEM_RESULT result = provider->IoTHubTransport_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE);

    // assert
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
    ASSERT_ARE_EQUAL(int, result, IOTHUB_PROCESS_OK);

    // cleanup
}
```


Overlapping Code:
```
TEST_FUNCTION(AMQP_ProcessItem)
{
// arrange
TRANSPORT_PROVIDER* provider = (TRANSPORT_PROVIDER*)AMQP_Protocol();
umock_c_reset_all_calls();
STRICT_EXPECTED_CALL(IoTHubTransport_AMQP_Common_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE));
// act
IOTHUB_PROCESS_ITEM_RESULT result = provider->IoTHubTransport_ProcessItem(TEST_TRANSPORT_LL_HANDLE, TEST_IOTHUB_IDENTITY_TYPE, TEST_IOTHUB_IDENTITY_INFO_HANDLE);
// assert
ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
ASSERT_ARE_EQUAL(int, result, IOTH
```
<Overlap Ratio: 0.9546925566343042>

---

--- 278 --
Question ID: a0ab78a0a08505c1c50a9da2913a67009f5efd5d_0
Original Code:
```
void *
__inhibit_loop_to_libcall
memcpy(void *__restrict aa, const void *__restrict bb, size_t n)
{
  #define BODY(a, b, t) { \
    t tt = *b; \
    a++, b++; \
    *(a - 1) = tt; \
  }

  char *a = (char *)aa;
  const char *b = (const char *)bb;
  char *end = a + n;
  uintptr_t msk = sizeof (long) - 1;
  if (unlikely ((((uintptr_t)a & msk) != ((uintptr_t)b & msk))
	       || n < sizeof (long)))
    {
small:
      if (__builtin_expect (a < end, 1))
	while (a < end)
	  BODY (a, b, char);
      return aa;
    }

  if (unlikely (((uintptr_t)a & msk) != 0))
    while ((uintptr_t)a & msk)
      BODY (a, b, char);

  long *la = (long *)a;
  const long *lb = (const long *)b;
  long *lend = (long *)((uintptr_t)end & ~msk);

  if (unlikely (la < (lend - 8)))
    {
      while (la < (lend - 8))
	{
	  long b0 = *lb++;
	  long b1 = *lb++;
	  long b2 = *lb++;
	  long b3 = *lb++;
	  long b4 = *lb++;
	  long b5 = *lb++;
	  long b6 = *lb++;
	  long b7 = *lb++;
	  long b8 = *lb++;
	  *la++ = b0;
	  *la++ = b1;
	  *la++ = b2;
	  *la++ = b3;
	  *la++ = b4;
	  *la++ = b5;
	  *la++ = b6;
	  *la++ = b7;
	  *la++ = b8;
	}
    }

  while (la < lend)
    BODY (la, lb, long);

  a = (char *)la;
  b = (const char *)lb;
  if (unlikely (a < end))
    goto small;
  return aa;
}
```


Overlapping Code:
```
emcpy(void *__restrict aa, const void *__restrict bb, size_t n)
{
#define BODY(a, b, t) { \
t tt = *b; \
a++, b++; \
*(a - 1) = tt; \
}
char *a = (char *)aa;
const char *b = (const char *)bb;
char *end = a + n;
uintptr_t msk = sizeof (long) - 1;
if (unlikely ((((uintptr_t)a & msk) != ((uintptr_t)b & msk))
|| n < sizeof (long)))
{
small:
if (__builtin_expect (a < end, 1))
while (a < end)
BODY (a, b, char);
return aa;
}
if (unlikely (((uintptr_t)a & msk) != 0))
while ((uintptr_t)a & msk)
BODY (a, b, char);
long *la = (long *)a;
const long *lb = (const long *)b;
long *lend = (long *)((uintptr_t)end & ~msk);
if (unlikely (la < (lend - 8)))
{
while (la < (lend - 8))
{
long b0 = *lb++;
long b1 = *lb++;
long b2 = *lb++;
long b3 = *lb++;
long b4 = *lb++;
long b5 = *lb++;
long b6 = *lb++;
long b7 = *lb++;
long b8 = *lb++;
*la++ = b0;
*la++ = b1;
*la++ = b2;
*la++ = b3;
*la++ = b4;
*la++ = b5;
*la++ = b6;
*la++ = b7;
*la++ = b8;
}
}
while (la < lend)
BODY (la, lb, long);
a = (char *)la;
b = (const char *)lb;
if (unlikely (a < end))
goto small;

```
<Overlap Ratio: 0.958029197080292>

---

--- 279 --
Question ID: 9ad037cd40f589f3154f0c72f384ae28fc8bf1bf_10
Original Code:
```
static long fltoa(long number, char *buf)
{
    static char digits[] = "0123456789";
    long sign = number;
    char* tmp = buf;

    if (sign < 0) number = -number;
    do *tmp++ = digits[number % 10]; while (number /= 10);
    if (sign < 0) *tmp++ = '-';
    freverse(buf, tmp - 1);
    return tmp - buf;
}
```


Overlapping Code:
```
number, char *buf)
{
static char digits[] = "0123456789";
long sign = number;
char* tmp = buf;
if (sign < 0) number = -number;
do *tmp++ = digits[number % 10]; while (number /= 10);
if (sign < 0) *tmp++ = '-';
freverse(buf, tmp - 1);
return tmp - buf
```
<Overlap Ratio: 0.9057971014492754>

---

--- 280 --
Question ID: ef12aa5090e0f4ce4dfddf312fc5d8455c5c954d_0
Original Code:
```
void set_default_parameters(){
		PI=3.14159265f;
		n_planes=700;
		n_rot=5;
		n_phi=15;
		tol_angle_rad=0.79f;
		small_radius_factor=4;
		n_cubes=4;
		lower_neighbor_bound_neighbors=10;
		selection_type= CLUSTER;
	}
```


Overlapping Code:
```
ers(){
PI=3.14159265f;
n_planes=700;
n_rot=5;
n_phi=15;
tol_angle_rad=0.79f;
small_radius_factor=4;
n_cubes=4;
lower_neighbor_bound_neighbors=10;
selection_type= CLUSTER;

```
<Overlap Ratio: 0.8724489795918368>

---

--- 281 --
Question ID: 77ddf27b512a05c85c28792ad5e6a547aa14f762_16
Original Code:
```
MagickExport MagickBooleanType NegateImage(Image *image,
  const MagickBooleanType grayscale)
{
  MagickBooleanType
    status;

  status=NegateImageChannel(image,DefaultChannels,grayscale);
  return(status);
}
```


Overlapping Code:
```
gateImage(Image *image,
const MagickBooleanType grayscale)
{
MagickBooleanType
status;
status=NegateImageChannel(image,DefaultChannels,grayscale);
return(statu
```
<Overlap Ratio: 0.8071065989847716>

---

--- 282 --
Question ID: e6ce4d6b9eab3cdce79f531883847531ceb96d23_12
Original Code:
```
void initialize() {
	initialize_sensor();

	initialize_button();

	initialize_poll();
	
	initialize_timer();

	atexit(clean_up);
}
```


Overlapping Code:
```
ze_button();
initialize_poll();

initialize_timer(
```
<Overlap Ratio: 0.4132231404958678>

---

--- 283 --
Question ID: af380d7bd145590bd9825fa6291a99ba38386d6f_3
Original Code:
```
BOOL WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPVOID path)
{
	TRACE_(shell)("%p %p\n", pidl, path);
	if (SHELL_OsIsUnicode())
	  return ILGetDisplayNameExW(NULL, pidl, path, ILGDN_FORPARSING);
	return ILGetDisplayNameExA(NULL, pidl, path, ILGDN_FORPARSING);
}
```


Overlapping Code:
```
CITEMIDLIST pidl, LPVOID path)
{
TRACE_(shell)("%p %p\n", pidl, path);
if (SHELL_OsIsUnicode())
return ILGetDisplayNameExW(NULL, pidl, path, ILGDN_FORPARSING);
return ILGetDisplayNameExA(NULL, pidl, path, ILGDN_FO
```
<Overlap Ratio: 0.83203125>

---

--- 284 --
Question ID: 41b13391b8ebb5a18ff5dfe32360ed35354c432d_30
Original Code:
```
void receive_gwiz_msg(mapping info)
{
        string msg,id,mudname;
        int status;

        // 一定必須要有的欄位
        if( undefinedp(info["NAME"])
            ||  undefinedp(info["PORTUDP"])
            ||  undefinedp(info["WIZNAME"])
            ||  undefinedp(info["CHANNEL"])
            ||  undefinedp(msg = info["GWIZ"])
        )   return;
        // 去除最後一個 \n
        if(msg[<1..<0] == "\n") msg[<1..<0] = "";
        // 新來的站給我乖乖排隊回 ping :Q
        if( compare_mud_info(info)<1 ) return;

        // 設定 id
        id = info["WIZNAME"];
        //id = info["WIZNAME"] + "@" + info["NAME"];
        // 有無中文 name ?
        if( info["CNAME"] ) id = info["CNAME"] + "(" + id + ")";
        
        // 是否為 Emote ?
        if( !undefinedp(info["EMOTE"]) )
                set("channel_id", id);
        // GB 轉碼 ?
        mudname=get_mud_name(info);

        status = fetch_data(mudname)["STATUS"];

        if( !(status & ENCODE_CONFIRM) && strlen(msg) > 20 )
        {
                string mud_ip_port = info["HOSTADDRESS"]+":"+info["PORTUDP"];
                int con = LANGUAGE_D->encode_conjecture(msg);

                if( con >= 0 && con <= 15 ) mudlist[mud_ip_port]["STATUS"]|=GB_CODE;
                else if( con > 30 ) mudlist[mud_ip_port]["STATUS"]&=~GB_CODE;

                if( con != -1 ) mudlist[mud_ip_port]["STATUS"]|=ENCODE_CONFIRM;
        }

        /*
        if( status & IGNORED ) // 如果被列入隔絕信息站點，則屏蔽網際聊天頻道
        {
                if( info["EMOTE"] ) delete("channel_id");
                return;
        }
        */

        if( !(status & GB_CODE) && ((status & ENCODE_CONFIRM) || (!undefinedp(mudlist[mudname]["ENCODING"]) && lower_case(mudlist[mudname]["ENCODING"])=="big5")) )
        {
                // id = (string)LANGUAGE_D->toGB(id);
                msg = (string)LANGUAGE_D->toGB(msg);
        }
        
        // 作為其他非NTlib的mud，可直接用CHANNEL_D->do_channel(this_object(), info["CHANNEL"], msg, info["EMOTE"]);替換以下的內容
        if( status & ANTI_AD ) // 垃圾廣告站點
        {
                info["CHANNEL"]="ad"; // 把對方網絡頻道改成廣告頻道
                CHANNEL_D->channel_broadcast(info["CHANNEL"], info["EMOTE"]?("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+ msg):("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+ id+"："+msg));

                if( info["EMOTE"] ) delete("channel_id");
                return;
        }

        // 交付給 CHANNEL_D 處理
        CHANNEL_D->channel_broadcast("gwiz","["+info["CHANNEL"]+"] "+(info["EMOTE"]?("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+msg):("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+ id+"："+msg)));
        if( info["EMOTE"] ) delete("channel_id");

        //NCH_CHANNEL("收到 gwizmsg "+info["CHANNEL"]+" 訊息");
}
```


Overlapping Code:
```
gwiz_msg(mapping info)
{
string msg,id,mudname;
int status;
// 一定必須要有的欄位
if( undefinedp(info["NAME"])
|| undefinedp(info["PORTUDP"])
|| undefinedp(info["WIZNAME"])
|| undefinedp(info["CHANNEL"])
|| undefinedp(msg = info["GWIZ"])
) return;
// 去除最後一個 \n
if(msg[<1..<0] == "\n") msg[<1..<0] = "";
// 新來的站給我乖乖排隊回 ping :Q
if( compare_mud_info(info)<1 ) return;
// 設定 id
id = info["WIZNAME"];
//id = info["WIZNAME"] + "@" + info["NAME"];
// 有無中文 name ?
if( info["CNAME"] ) id = info["CNAME"] + "(" + id + ")";

// 是否為 Emote ?
if( !undefinedp(info["EMOTE"]) )
set("channel_id", id);
// GB 轉碼 ?
mudname=get_mud_name(info);
status = fetch_data(mudname)["STATUS"];
if( !(status & ENCODE_CONFIRM) && strlen(msg) > 20 )
{
string mud_ip_port = info["HOSTADDRESS"]+":"+info["PORTUDP"];
int con = LANGUAGE_D->encode_conjecture(msg);
if( con >= 0 && con <= 15 ) mudlist[mud_ip_port]["STATUS"]|=GB_CODE;
else if( con > 30 ) mudlist[mud_ip_port]["STATUS"]&=~GB_CODE;
if( con != -1 ) mudlist[mud_ip_port]["STATUS"]|=ENCODE_CONFIRM;
}
/*
if( status & IGNORED ) // 如果被列入隔絕信息站點，則屏蔽網際聊天頻道
{
if( info["EMOTE"] ) delete("channel_id");
return;
}
*/
if( !(status & GB_CODE) && ((status & ENCODE_CONFIRM) || (!undefinedp(mudlist[mudname]["ENCODING"]) && lower_case(mudlist[mudname]["ENCODING"])=="big5")) )
{
// id = (string)LANGUAGE_D->toGB(id);
msg = (string)LANGUAGE_D->toGB(msg);
}

// 作為其他非NTlib的mud，可直接用CHANNEL_D->do_channel(this_object(), info["CHANNEL"], msg, info["EMOTE"]);替換以下的內容
if( status & ANTI_AD ) // 垃圾廣告站點
{
info["CHANNEL"]="ad"; // 把對方網絡頻道改成廣告頻道
CHANNEL_D->channel_broadcast(info["CHANNEL"], info["EMOTE"]?("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+ msg):("{"+HBGRN+mudlist[mudname]["NAME"]+NOR+"} "+ id+"："+msg));
if( info["EMOTE"] ) delete("channel_id");
return;
}
// 交付給 CHANNEL_D 處理
CHANNEL_D->channel_broadcast("gwiz","["+info["CHANNEL"]+"] "+(info["EM
```
<Overlap Ratio: 0.9701101206082853>

---

--- 285 --
Question ID: 1d6a3ab85f9e9d254b4960ce51d5a249997afab2_1
Original Code:
```
class CSO2ErrorLog
{
public:
	DLL_CLASS_IMPORT CSO2ErrorLog();
	DLL_CLASS_IMPORT ~CSO2ErrorLog();

	DLL_CLASS_IMPORT void AddErrorID( unsigned int iErrorID );
	DLL_CLASS_IMPORT unsigned int GetErrorID();

	DLL_CLASS_IMPORT void AddMsg( const char* szFormat, ... );
	DLL_CLASS_IMPORT const char* GetMsg( unsigned int iMsgIndex );
	DLL_CLASS_IMPORT const wchar_t* GetWMsg( unsigned int iMsgIndex );

	DLL_CLASS_IMPORT CSO2ErrorLog& operator=( const CSO2ErrorLog& other );

private:
	unsigned int m_iErrorID;
	unsigned int m_iCurrentMsgIndex;
	char* m_szMessages[CSO2ERRORLOG_MAX_INDEX];	 	
}
```


Overlapping Code:
```
ASS_IMPORT CSO2ErrorLog();
DLL_CLASS_IMPORT ~CSO2ErrorLog();
DLL_CLASS_IMPORT void AddErrorID( unsigned int iErrorID );
DLL_CLASS_IMPORT unsigned int GetErrorID();
DLL_CLASS_IMPORT void AddMsg( const char* szFormat, ... );
DLL_CLASS_IMPORT const char* GetMsg( unsigned int iMsgIndex );
DLL_CLASS_IMPORT const wchar_t* GetWMsg( unsigned int iMsgIndex );
DLL_CLASS_IMPORT CSO2ErrorLog& operator=( const CSO2ErrorLog& other );
private:
unsigned int m_iErrorID;
unsigned int m_iCurrentMsgIndex;
char* m_s
```
<Overlap Ratio: 0.8741258741258742>

---

--- 286 --
Question ID: eb3ab216db77195be3d85bbf701383193b54b73e_18
Original Code:
```
static void asockReadUntil_Helper(asock *sock, struct asockReadUntilData *rud, u32 status, char *message)
{
  //UNBUSY()s :
  //  if readSome returns TO US, and WITHOUT ERROR, the socket will not be UNBUSY()d yet.
  //  if readSome returns TO US, and WITH ERROR, we'll alreday by UNBUSY()d (simply to avoid additional sock->complete checks in readSome)
  // so, UNBUSY() any completion exit from an incoming ASOCK_STATUS_OK

  // read until disconnect
  if((status == ASOCK_STATUS_DISCONN) && (rud->untilLen == 0))
  {
    if(rud->readPtr) *(rud->readPtr) = rud->read;
    *(rud->receiver) = realloc(rud->buff, rud->read);
    asockComplete complete = rud->complete;
    void *data = rud->data;
    free(rud);
    complete(sock, data, ASOCK_STATUS_OK, NULL);
    return;
  }

  // errors...
  if((status != ASOCK_STATUS_OKAY) && (status != ASOCK_STATUS_DISCONN))
  {
    asockComplete complete = rud->complete;
    void *data = rud->data;
    free(rud->buff);
    free(rud);
    complete((void *)sock, data, status, message);
    return;
  }
  if((status == ASOCK_STATUS_DISCONN) && (rud->partial == 0))
  {
    asockComplete complete = rud->complete;
    void *data = rud->data;
    free(rud->buff);
    free(rud);
    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup("didn't find ReadUntil token within expected length"));
    return;
  }

  // we have some data to process
  rud->read += rud->partial;

  // simple case : we're reading until disconnect
  if(rud->untilLen == 0)
  {
    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;
    rud->buff     = realloc(rud->buff, rud->buffSize);
    asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);
    return;
  }

  // simple-ish case : not enough data to compare
  if((rud->read - rud->matchOffset) < rud->untilLen)
  {
    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;
    rud->buff     = realloc(rud->buff, rud->buffSize);
    if(rud->read < rud->max)
      asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);
    else
    {
      if(rud->readPtr) *(rud->readPtr) = rud->read;
      *(rud->receiver) = realloc(rud->buff, rud->read);
      asockComplete complete = rud->complete;
      void *data = rud->data;
      free(rud);
      UNBUSY(sock);
      complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup("didn't find ReadUntil token within expected length"));
    }
    return;
  }

  // we have to scan for a match...
  u8 matched;
  for(u32 a,b,i=rud->matchOffset; i<rud->read; i++)
  {
    a=i; b=0; matched=0;
    while((a<rud->read) && (rud->buff[a] == ((u8 *)rud->until)[b]))
    {
      matched++;
      // we actually found the damn thing
      if(matched == rud->untilLen)
      {
        // store remaining data in our partial buffer
        if((a+1) < rud->read) //partial data
        {
          u32 partial = rud->read - (a+1);
          sock->readBuff = (u8 *)realloc(sock->readBuff, sock->readBuffLen + partial);
          memcpy(sock->readBuff + sock->readBuffLen, rud->buff+a+1, partial);
          sock->readBuffLen += partial;
        }
        // return up-to, and including, our "until" token
        if(rud->readPtr) *(rud->readPtr) = rud->read;
        *(rud->receiver) = realloc(rud->buff, rud->read);
        asockComplete complete = rud->complete;
        void *data = rud->data;
        free(rud);
        UNBUSY(sock);
        complete(sock, data, ASOCK_STATUS_OK, NULL);
        return;
      }
      a++; b++;
    }
    // store our matchOffset so we're not scanning the whole buffer every readSome()
    rud->matchOffset = i;
    if(a == rud->read)
    {
      // this check is important:
      // if we have a partial match running up until the end of our data,
      // bail early so we don't increment the matchOffset variable passed the beginning of the partial
      break;
    }
  }
  // we didn't find a match...

  // have we read as much as we can?
  if(rud->buffSize == rud->max)
  {
    rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;
    rud->buff     = realloc(rud->buff, rud->buffSize);
    if(rud->readPtr) *(rud->readPtr) = rud->read;
    *(rud->receiver) = realloc(rud->buff, rud->read);
    asockComplete complete = rud->complete;
    void *data = rud->data;
    free(rud);
    UNBUSY(sock);
    complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup("didn't find ReadUntil token within expected length"));
    return;
  }

  // more to read then
  u32 leftToRead = rud->max - rud->buffSize;
  if(leftToRead > ASOCK_READ_UNTIL_CHUNK_SIZE)
    leftToRead = ASOCK_READ_UNTIL_CHUNK_SIZE;
  rud->buffSize += leftToRead;
  rud->buff = (u8 *)realloc(rud->buff, rud->buffSize);
  asockReadSome_noBusy(sock, rud->buff + rud->read, leftToRead, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);
}
```


Overlapping Code:
```
il_Helper(asock *sock, struct asockReadUntilData *rud, u32 status, char *message)
{
//UNBUSY()s :
// if readSome returns TO US, and WITHOUT ERROR, the socket will not be UNBUSY()d yet.
// if readSome returns TO US, and WITH ERROR, we'll alreday by UNBUSY()d (simply to avoid additional sock->complete checks in readSome)
// so, UNBUSY() any completion exit from an incoming ASOCK_STATUS_OK
// read until disconnect
if((status == ASOCK_STATUS_DISCONN) && (rud->untilLen == 0))
{
if(rud->readPtr) *(rud->readPtr) = rud->read;
*(rud->receiver) = realloc(rud->buff, rud->read);
asockComplete complete = rud->complete;
void *data = rud->data;
free(rud);
complete(sock, data, ASOCK_STATUS_OK, NULL);
return;
}
// errors...
if((status != ASOCK_STATUS_OKAY) && (status != ASOCK_STATUS_DISCONN))
{
asockComplete complete = rud->complete;
void *data = rud->data;
free(rud->buff);
free(rud);
complete((void *)sock, data, status, message);
return;
}
if((status == ASOCK_STATUS_DISCONN) && (rud->partial == 0))
{
asockComplete complete = rud->complete;
void *data = rud->data;
free(rud->buff);
free(rud);
complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup("didn't find ReadUntil token within expected length"));
return;
}
// we have some data to process
rud->read += rud->partial;
// simple case : we're reading until disconnect
if(rud->untilLen == 0)
{
rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;
rud->buff = realloc(rud->buff, rud->buffSize);
asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);
return;
}
// simple-ish case : not enough data to compare
if((rud->read - rud->matchOffset) < rud->untilLen)
{
rud->buffSize = rud->read + ASOCK_READ_UNTIL_CHUNK_SIZE;
rud->buff = realloc(rud->buff, rud->buffSize);
if(rud->read < rud->max)
asockReadSome_noBusy(sock, rud->buff, ASOCK_READ_UNTIL_CHUNK_SIZE, &(rud->partial), (asockComplete)asockReadUntil_Helper, (void *)rud);
else
{
if(rud->readPtr) *(rud->readPtr) = rud->read;
*(rud->receiver) = realloc(rud->buff, rud->read);
asockComplete complete = rud->complete;
void *data = rud->data;
free(rud);
UNBUSY(sock);
complete(sock, data, ASOCK_STATUS_HITMAX, clstrdup("didn't find ReadUntil token within expected length
```
<Overlap Ratio: 0.9890158172231986>

---

--- 287 --
Question ID: 7f02ee14a5846a231d874b383f21fb789128f123_2
Original Code:
```
void initdnsserver(void)
{
	PyObject *m;
	PyObject *dep_samba_dcerpc_base;

	dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
	if (dep_samba_dcerpc_base == NULL)
		return;

	ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
	if (ClientConnection_Type == NULL)
		return;

	dnsserver_InterfaceType.tp_base = ClientConnection_Type;

	if (PyType_Ready(&dnsserver_InterfaceType) < 0)
		return;
	if (!PyInterface_AddNdrRpcMethods(&dnsserver_InterfaceType, py_ndr_dnsserver_methods))
		return;

#ifdef PY_DNSSERVER_PATCH
	PY_DNSSERVER_PATCH(&dnsserver_InterfaceType);
#endif

	m = Py_InitModule3("dnsserver", dnsserver_methods, "dnsserver DCE/RPC");
	if (m == NULL)
		return;

	Py_INCREF((PyObject *)(void *)&dnsserver_InterfaceType);
	PyModule_AddObject(m, "dnsserver", (PyObject *)(void *)&dnsserver_InterfaceType);
#ifdef PY_MOD_DNSSERVER_PATCH
	PY_MOD_DNSSERVER_PATCH(m);
#endif

}
```


Overlapping Code:
```
tdnsserver(void)
{
PyObject *m;
PyObject *dep_samba_dcerpc_base;
dep_samba_dcerpc_base = PyImport_ImportModule("samba.dcerpc.base");
if (dep_samba_dcerpc_base == NULL)
return;
ClientConnection_Type = (PyTypeObject *)PyObject_GetAttrString(dep_samba_dcerpc_base, "ClientConnection");
if (ClientConnection_Type == NULL)
return;
dnsserver_InterfaceType.tp_base = ClientConnection_Type;
if (PyType_Ready(&dnsserver_InterfaceType) < 0)
return;
if (!PyInterface_AddNdrRpcMethods(&dnsserver_InterfaceType, py_ndr_dnsserver_methods))
return;
#ifdef PY_DNSSERVER_PATCH
PY_DNSSERVER_PATCH(&dnsserver_InterfaceType);
#endif
m = Py_InitModule3("dnsserver", dnsserver_methods, "dnsserver DCE/RPC");
if (m == NULL)
return;
Py_INCREF((PyObject *)(void *)&dnsserver_InterfaceType);
PyModule_AddObject(m, "dnsserver", (PyObject *)(void *)&dnsserver_InterfaceType);
#ifdef PY_MOD_DNSSERVER_PATCH
PY_MOD_DNSSERVER_PATCH
```
<Overlap Ratio: 0.9771986970684039>

---

--- 288 --
Question ID: b48634e4e333214f2dc5941348a151a45796761c_0
Original Code:
```
int main(int argc, char *argv[])
{
    int i, err_no, rule_no, rc = 0;
    int wait_count = DEFAULT_WAIT_COUNT, skip_flag;
    char *kdblevel = NULL, *eeh_env = NULL, *ptr = NULL;
    struct ruleinfo *current_ruleptr;
    char msg[MAX_TEXT_MSG], script_path[64], cmd_str[128];
    struct thread_context *current_tctx;
    char file_name[128];

    struct sigaction sigvector, sigdata;
    static sigset_t  sigmask;

    /****************************************/
    /**     Register Signal handlers        */
    /****************************************/
    sigemptyset((&sigvector.sa_mask)); /* empty the mask */
    sigvector.sa_flags = 0;
    sigvector.sa_handler = (void (*)(int)) SIGTERM_hdl;
    sigaction(SIGTERM, &sigvector, (struct sigaction *) NULL); /* set signal handler for SIGTERM */


    sigprocmask(0, NULL, &sigmask); /* get current signal mask     */
    sigdata.sa_flags = SA_RESTART; /* restart on signal calls     */
    sigdata.sa_mask = sigmask;  /* set the signal mask */

    sigdata.sa_handler = (void(*)(int))sig_function;
    sigaction(SIGUSR1, &sigdata, NULL); /* call when recv sig 30 */

    sigdata.sa_handler = (void(*)(int))int_sig_function;
    sigaction(SIGINT, &sigdata, NULL); /* set signal handler for SIGINT */

    /*********************************************/
    /** Initialize thread attributes and mutex  **/
    /*********************************************/
    pthread_attr_init(&thread_attrs_detached);
    pthread_attr_setdetachstate(&thread_attrs_detached, PTHREAD_CREATE_DETACHED);

    pthread_mutex_init(&thread_create_mutex, DEFAULT_MUTEX_ATTR_PTR);
    pthread_mutex_init(&cache_mutex, DEFAULT_MUTEX_ATTR_PTR);
    pthread_mutex_init(&fencepost_mutex, DEFAULT_MUTEX_ATTR_PTR);
    pthread_mutex_init(&stats_mutex, DEFAULT_MUTEX_ATTR_PTR);
    pthread_mutex_init(&dump_mutex, DEFAULT_MUTEX_ATTR_PTR);
#ifndef __HTX_LINUX__
    pthread_mutex_init(&log_mutex, DEFAULT_MUTEX_ATTR_PTR);
#endif

    pthread_cond_init(&create_thread_cond_var, DEFAULT_COND_ATTR_PTR);
    pthread_cond_init(&do_oper_cond_var, DEFAULT_COND_ATTR_PTR);
    pthread_cond_init(&threads_finished_cond_var, DEFAULT_COND_ATTR_PTR);

    bzero(&dev_info, sizeof(dev_info));
    dev_info.cont_on_misc = UNINITIALIZED;

    /************************************************/
    /*******   Read command line arguments    *******/
    /************************************************/
    memset(&data, 0, sizeof(struct htx_data));
    strcpy(data.HE_name, argv[0]);
    strcpy(data.sdev_id, argv[1]);
    strcpy(dev_info.dev_name, argv[1]);
    strcpy(data.run_type, argv[2]);
    strcpy(dev_info.rules_file_name, argv[3]);

    hxfupdate(START, &data);
    sprintf(msg, "%s %s %s %s \n", data.HE_name, data.sdev_id, data.run_type, dev_info.rules_file_name);
    user_msg(&data, 0, 0, INFO, msg);

    /* globla_htx_d will be used by stats thread. So, this need to be updated
     * from data.
     */
     memcpy(&global_htx_d, &data, sizeof(struct htx_data));

    /*************************************************************************/
    /* Sanity check:                                                         */
    /* Before we open the device, check to see if it is a member of a volume */
    /* group which is currently defined in the ODM.  This check prevents     */
    /* accidentally clobbering a disk which was added to a volume group      */
    /* after logging on as htx.                                              */
    /* If check_disk returns < 0, then the device is OK to exercise.         */
    /*************************************************************************/

    ptr = getenv("HTXSCRIPTS");
    if (ptr != NULL) {
		strcpy(script_path, ptr);
    } else {
        sprintf(msg, "HTX env. is not set. Hence exiting.\nPlease setup the env. and re-run the test");
        user_msg(&data, 0, 0, INFO, msg);
        exit(1);
    }

#ifndef __HTX_LINUX__
    if ( (rc = check_disk(data.sdev_id, msg, sizeof(msg))) == 0) {
        user_msg(&data, 0, 0, HARD, msg);
        exit(126);
    } else if (rc > 0 ) {
        sprintf(msg, "ODM or LVM error in check_disk, rc = %d\n%s", rc, msg);
        user_msg(&data, 0, 0, HARD, msg);
        exit(1);
    }
#else
    sprintf(cmd_str, "%scheck_disk %s", script_path, data.sdev_id);
    rc = system(cmd_str);
    if (WIFEXITED(rc)) {
        if (WEXITSTATUS(rc) == 1) {
            sprintf(msg, "Disk either has partitions OR is used by the system. So, can not run exerciser on it. Hence exiting.");
            user_msg(&data, 0, 0, INFO, msg);
            exit(1);
        }
    } else {
        sprintf(msg, "command did not completed properly. Hence exiting.");
        user_msg(&data, 0, 0, INFO, msg);
        exit(1);
    }
#endif

    /****************************************************/
    /****** Get hostname for machine running code *******/
    /****************************************************/
    rc = gethostname(dev_info.hostname, 16);
    if ( rc != 0 ) {
        sprintf(msg, "Unable to get hostname for this run!, errno = %d \n", errno);
        user_msg(&data, 0, 0, INFO, msg);
    }

    /*****************************************************/
    /******* Get HTXKDBLEVEL and EEH env. variable *******/
    /*****************************************************/
    dev_info.crash_on_miscom = 1;
    kdblevel = getenv("HTXKDBLEVEL");
    if (kdblevel != NULL) {
        if (!(atoi(kdblevel))) {
            dev_info.crash_on_miscom = 0;
        }
    }
    eeh_env = getenv("HTXEEH");
    if (eeh_env != NULL) {
        if (atoi(eeh_env)) {
            ptr = getenv("HTXEEHRETRIES");
            if (ptr != NULL) {
                eeh_retries = atoi(getenv("HTXEEHRETRIES"));
			}
        } else if((strcmp(data.run_type, "REG") == 0) && data.p_shm_HE->cont_on_err) {
            /* If User specifies COE in mdt file, then need to make sure all
             * read/write call are successfull. If we see ocassional error, retry.
             */
            eeh_retries = DEFAULT_EEH_RETRIES;
        }
    }

    /* Create mmaped dump file */
    sprintf (file_name, "%s/IO_details_dump.log", data.htx_exer_log_dir);
    mmap_fd = open (file_name, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if (mmap_fd == -1) {
        sprintf(msg, "Could not open the dump file. errno: %d\n", errno);
        user_msg(&data, 0, 0, HARD, msg);
    }
    if (lseek (mmap_fd, MMAP_FILE_SIZE, SEEK_SET) == -1) {
        perror("lseek");
    }
    rc = write(mmap_fd, "", 1);
    close(mmap_fd);

    mmap_fd = open (file_name, O_RDWR);
    if (mmap_fd == -1) {
        sprintf(msg, "Could not open the dump file. errno: %d\n", errno);
        user_msg(&data, 0, 0, HARD, msg);
    }
    /* Do the mmap of the file */
    mmap_ptr = (char *) mmap( NULL, MMAP_FILE_SIZE, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, mmap_fd, 0);
    if (mmap_ptr == (void *) -1) {
        sprintf(msg, "mmap failed. errno: %d\n", errno);
        user_msg(&data, 0, 0, HARD, msg);
    }
    close(mmap_fd);

    if (strcmp(data.run_type, "REG") == 0){
        /* time_driven_htx read the time_interval_for_run from the shm header */
        time_interval_for_run = get_exec_time_value_from_shm_hdr(&data);
        sprintf(msg,"debug_msg6 from FPU, exec_time = %d \n",time_interval_for_run);
        hxfmsg (&data, 0, INFO, msg);
    }

    /****************************************************************************/
	/*   For CAPI flash, Device given as input is of format /dev/rhdisk[0-1]*.N */
    /*   on AIX and sd[a-z][a-z]*.N on Linux. Actual device would be            */
    /*   /dev/rhdisk[0-1] OR /dev/sd[a-z][a-z, 0-1]* and our invocation count   */
    /*   would be N. Extract device name from argv[1]                           */
	/****************************************************************************/

#ifdef __CAPI_FLASH__
	char file[128] = "/tmp/test_lun_mode";
    FILE * fp ;
	uint32_t num_instance = 0;
	char buf[128];

    char device[MAX_STR_SZ], intance[MAX_STR_SZ], input_dev[MAX_STR_SZ], temp[MAX_STR_SZ];
    int str_len, indx=0;
    strcpy(input_dev, basename(data.sdev_id));
    str_len = strlen(input_dev);

	rc = cblk_init(NULL, 0);
	if (rc != 0) {
       sprintf(msg, "cblk_init returned error. rc: %d.", rc);
       user_msg(&data, 0, 0, HARD, msg);
       exit(1);
    }

    for(i = 0; i <= str_len; i++ ) {
        temp[indx]=input_dev[i];
        if(input_dev[i] == '.' ) {
            strncpy(device, temp, indx);
            device[indx] = '\0';
            indx = 0;
            memset(temp, 0, MAX_STR_SZ);
        } else  if (input_dev[i] == '\0') {
            strcpy(intance, temp);
        } else {
            indx++;
        }
    }

	if(device[0] == 'r') {
    	strncpy(dev_info.diskname, &device[1], MAX_STR_SZ);
	} else {
		strncpy(dev_info.diskname, &device[0], MAX_STR_SZ);
	}
	sprintf(capi_device,"/dev/%s",&device[0]);
    printf("input_dev=%s, device=%s, intance=%s, capi_device=%s \n", input_dev, device, intance, capi_device);
    fflush(stdout);

	rc = access(file, F_OK);
    if(rc == -1 ) {
    #ifdef __HTX_LINUX__
        /* In case of Linux, if file does not exist, we run in VLUN mode.
         * Hence, setting the params for VLUN mode.
         */
        lun_type = CBLK_OPN_VIRT_LUN;
        dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;
        dev_info.blksize = (unsigned int)VLUN_BLKSIZE;
    #else
        /* In case of AIX, if file does not exist, means we are testing in Legacy mode.
         * hxestorage should run on this device instead of hxesurelock. Hence, exiting.
         */
		sprintf(msg, "File: %s, doesnot exists!! this exerciser should not have been envoked. \n", file);
		user_msg(&data, 0, 0, HARD, msg);
		return(rc);
    #endif
	} else {
        /************************************************/
	    /* Get content of file : "/tmp/test_lun_mode"   */
	    /************************************************/
	    sprintf(cmd_str, "cat %s", file);
        fp = popen(cmd_str, "r");
        if (fp == NULL) {
            sprintf(msg, "popen failed while reading file=%s with errno=%d. Setting Virtual LUN mode. \n", file, errno);
            user_msg(&data, 0, 0, INFO, msg);
	    	num_instance = 2;
        } else {
            if (fgets(buf, 128, fp) == NULL) {
                sprintf(msg, "fgets failed while reading from file = %s, errno=%d. Setting Virtual LUN mode. \n \n", file, errno);
                user_msg(&data, 0, 0, INFO, msg);
                pclose(fp);
	    		num_instance = 2;
            } else {
                pclose(fp);
                num_instance = atoi(buf);
            }
        }

	    if(num_instance == 1) {
	    	/***********************************************************/
            /* File exists with value=1, we are testing PLUNs. We can  */
            /* query IOCINFO on PLUNs for total blocks and block size. */
            /***********************************************************/
            lun_type            = CBLK_OPN_PHY_LUN;
        #ifndef __HTX_LINUX__
            rc = get_disk_info(&data, capi_device);
            if ( rc != 0) {
                exit(1);
            }
            /****************************************************/
            /* For PLUN chunk_size is same as num blocks on disk*/
            /****************************************************/
            chunk_size = dev_info.maxblk + 1;
        #else
            chunk_id_t chunk_id = NULL_CHUNK_ID;
        #ifdef __HTX_LINUX__
            chunk_attrs_t attr;
        #endif

            chunk_id = cblk_open(capi_device, MAX_THREADS, O_RDWR, 0, 0);
            if(chunk_id == NULL_CHUNK_ID) {
                sprintf(msg, "main : Cannot get a valid chunk_id, capi_device = %s, errno = %d \n", capi_device, errno);
                user_msg(&data, errno, 0, HARD, msg);
                exit(1);
	        }
            rc = cblk_get_lun_size(chunk_id, (unsigned long *)&dev_info.maxblk, 0);
            if(rc ) {
                sprintf(msg, "cblk_get_size failed with rc = %d, errno = %d \n", rc, errno);
                user_msg(&data, errno, 0, HARD, msg);
                return(1);
            }
        #ifdef __HTX_LINUX__
            rc = cblk_get_attrs (chunk_id, &attr, 0);
            if (rc) {
                sprintf(msg, "cblk_get_attrs failed with rc = %d, errno = %x \n", rc, errno);
                user_msg(&data, errno, 0, HARD, msg);
                exit(1);
            }

            if (attr.flags1 & CFLSH_ATTR_UNMAP) {
                discard_enabled = 1;
            }
        #endif
            rc = cblk_close(chunk_id, CBLK_SCRUB_DATA_FLG);
            if(rc) {
                sprintf(msg, "cblk_close failed with rc = %d, errno = %x \n", rc, errno);
                user_msg(&data, errno, 0, HARD, msg);
                exit(1);
            }
            chunk_id = NULL_CHUNK_ID;
            /****************************************************/
            /* For PLUN chunk_size is same as num blocks on disk*/
            /****************************************************/
            chunk_size = dev_info.maxblk;
            dev_info.blksize = (unsigned int)VLUN_BLKSIZE;
        #endif
	    } else {
            if (num_instance == 0) {
            #ifdef __HTX_LINUX__
                 /* in case of LInux, If value in file is 0, means we are testing VLUN */
                dev_info.maxblk = (unsigned long long)VLUN_TOTALBLOCKS;
                dev_info.blksize = (unsigned int)VLUN_BLKSIZE;
                lun_type = CBLK_OPN_VIRT_LUN;
            #else
                /* In case of AIX, value 0 means, we need to run in LEGACY mode. So error out */
                sprintf(msg, "File: %s, exists but value = %d, this exerciser should not have been envoked. \n", file, num_instance);
                user_msg(&data, 0, 0, HARD, msg);
                return(rc);
            #endif
            } else {
                /********************************************************/
	            /* File exists with value > 1, we are testing VLUNS.    */
	    	    /* VLUNs have capability to dynamically change size.    */
	    	    /* So user request for it through chunk_size rules parm.*/
	    	    /********************************************************/
	 	        dev_info.maxblk 	= (unsigned long long)VLUN_TOTALBLOCKS;
	            dev_info.blksize 	= (unsigned int)VLUN_BLKSIZE;
		        lun_type 			= CBLK_OPN_VIRT_LUN;
	        }
        }
    }
#else
    /***************************************************/
    /****   Get disk info using IOCINFO ioctl.      ****/
    /****   This will update maxblk and blksize.    ****/
    /***************************************************/
    rc = get_disk_info(&data, data.sdev_id);
    if ( rc != 0) {
        exit(1);
    }
#endif

    /***************************************************/
    /********           Read rule file          ********/
    /***************************************************/
    rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);
    if (rc != 0) {
        sprintf(msg, "Check HTXERR log for a listing of errors with rule file reading!\n");
        user_msg(&data, 0, 0, HARD, msg);
        exit(1);
    }
    segment_table_init();

    /* time_driven_htx */
    /* if we provide a value for time_interval_for_run along with cmdline as arg then only we need to populate these variables */
    if (time_interval_for_run > 0){
        /* provide total no. of stanzas present */
        total_no_of_stanzas_present = num_rules_defined;
        if (total_BWRC_threads > 0) {
            if (rule_list[1].oper[0][0] == 'S' || rule_list[1].oper[0][0] == 's') {
                time_interval_for_run -= (rule_list[1].sleep / 1000000);
            }
            time_interval_for_stanza_switch_tmp = time_interval_for_run / (total_no_of_stanzas_present - 2);
        } else {
            time_interval_for_stanza_switch_tmp = time_interval_for_run/total_no_of_stanzas_present;
        }
        /* provide the reference to exit_flag */
        time_diff_struct.exit_flag = &exit_flag;
    }

    /* if run_on_misc is set to YES and misc_run_cmd is null. {Populate the default script to run*/
    if (run_on_misc == 'Y' && strcmp(misc_run_cmd, "") == 0) {
        sprintf(misc_run_cmd, "%s/storage_miscom_pre_kdb_script", script_path);
    }

    time_mark = time(0); /* set time mark for comparison */
    if (enable_state_table == YES) {
        rc = initialize_state_table(&data, data.sdev_id);
        if (rc == -1) {
			exit(1);
	    }
    }

#ifdef __HTX_LINUX__
    /* Check if write cahce is enabled if sync_cache is set to yes in any
     * of the rule. This will set dev_info.write_cache to 1 if enabled,
     * otherwise 0.
     */
    dev_info.write_cache = 0;
    if (sync_cache_flag == 1) {
        dev_info.write_cache = check_write_cache (&data);
        /* Create a separate thread to issue CACHE_SYNC ioctl at regular interval */
        if (dev_info.write_cache == 1 && randomize_sync_cache == 1) {
            rc = pthread_create(&sync_cache_th, &thread_attrs_detached, (void *(*)(void *))sync_cache_thread, (void *)(&data));
            if (rc != 0) {
                sprintf(msg, "pthread_create failed for sync_cache threas. errno. set is: %d\n", rc);
                user_msg(&data, rc, 0, HARD, msg);
                exit(1);
		    }
        } else if (dev_info.write_cache == 0) {
            sprintf(msg, "Write cache is is not enabled. Will not run sync_cache thread.");
            user_msg(&data, 0, 0, INFO, msg);
        }
        sprintf(msg, "write cache is : %d\n", dev_info.write_cache);
        user_msg(&data, 0, 0, INFO, msg);
    }
#endif

    /*****************************************************************/
    /* Allocate memory for BWRC threads. Since lifetime of BWRC      */
    /* threads can span across multiple stanzas. So, we pre-allocate */
    /* memory for all BWRC threads defined in various stanzas in the */
    /* rulefile. Information of BWRC threads of various stanzas once */
    /* updated here will be maintained till end of the exerciser.    */
    /*****************************************************************/
    if (total_BWRC_threads != 0) {
        BWRC_threads_mem = (struct thread_context *) malloc(total_BWRC_threads * sizeof(struct thread_context));
        if (BWRC_threads_mem == NULL) {
            err_no = errno;
            sprintf(msg, "malloc failed(with errno: %d) while allocating memory for BWRC thread context.\n", errno);
            user_msg(&data, err_no, 0, HARD, msg);
            exit(1);
        }
        initialize_threads(BWRC_threads_mem, total_BWRC_threads);
        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {
            current_ruleptr = &rule_list[rule_no];
            if (current_ruleptr->num_BWRC_threads == 0) {
                continue;
            } else {
                populate_BWRC_thread_context(&data, current_ruleptr, BWRC_threads_mem);
            }
        }
    }

    /*********************************************************************/
    /****** run hang_monitor thread to keep a check of any HUNG IO  ******/
    /*********************************************************************/
    rc = pthread_create(&(hang_monitor_thread), &thread_attrs_detached, (void *(*)(void *))hang_monitor, (void *)(&data));
    if (rc != 0) {
        sprintf(msg, "pthread_create failed for hang_monitor thread. errno set is: %d\n", rc);
        user_msg(&data, rc, 0, HARD, msg);
        /* Free BWRC memory also if allocated */
        if (BWRC_threads_mem != NULL) {
            free (BWRC_threads_mem);
            BWRC_threads_mem = NULL;
        }
        exit(1);
    }

    /*******************************************************/
    /******     Create stats updation thread         *******/
    /*******************************************************/
    rc = pthread_create(&stats_update_th, &thread_attrs_detached, (void *(*)(void *))stats_update_thread, NULL);
    if (rc != 0) {
        sprintf(msg, "pthread_create failed for stats update thread. errno set is: %d\n", rc);
        user_msg(&data, rc, 0, HARD, msg);
        /* Free BWRC memory also if allocated */
        if (BWRC_threads_mem != NULL) {
            free (BWRC_threads_mem);
            BWRC_threads_mem = NULL;
        }
        exit(1);
    }

    /******************************************************/
    /*******    Start processing of stanza          *******/
    /******************************************************/
    read_rules_file_count = 1;
    do {
        current_ruleptr = &rule_list[0];
        for (rule_no = 0; rule_no < num_rules_defined; rule_no++) {
            /* DPRINT("%s:%d - Running stanza: %d\n", __FUNCTION__, __LINE__, rule_no + 1); */
            data.test_id = rule_no + 1;
            HTX_STATS_UPDATE (UPDATE , &data);

            skip_flag = 0;
            /******************************************************************/
            /***    Check rule parameter to see if need to skip this stanza ***/
            /******************************************************************/
            if ( current_ruleptr->repeat_pos > 0 ) {
                if ((read_rules_file_count == 1)                                ||
                    ((read_rules_file_count % current_ruleptr->repeat_pos) !=0) ||
                    ((current_ruleptr->repeat_pos == 1)                         &&
                    (!(read_rules_file_count & 1)))
                )  {
                    skip_flag = 1;
                }
            } else if ( current_ruleptr->repeat_neg > 0 ) {
                if (((read_rules_file_count != 1)                                   &&
                    ((read_rules_file_count % current_ruleptr->repeat_neg) != 0))   ||
                    ((current_ruleptr->repeat_neg == 1)                             &&
                    (!(read_rules_file_count & 1))                                  &&
                    (read_rules_file_count != 1))) {
                    skip_flag = 1;
                }
            }

            /****************************************************/
            /**  If not skipping the stanza, run the testcase  **/
            /****************************************************/
            if (skip_flag != 1) {
                if (current_ruleptr->oper[0][0] == 'S' || current_ruleptr->oper[0][0] == 's') {
                    usleep(current_ruleptr->sleep);
                } else if (strcasecmp(current_ruleptr->oper[0], "XCMD") == 0) {
                    rc = run_cmd(&data, current_ruleptr->cmd_list);
                } else {
                    /************************************************************************/
                    /****           Allocate memory for non BWRC threads context        *****/
                    /************************************************************************/
                    num_non_BWRC_threads = current_ruleptr->num_threads - current_ruleptr->num_BWRC_threads;
                    if (num_non_BWRC_threads) {
                        non_BWRC_threads_mem = (struct thread_context *) malloc (num_non_BWRC_threads * sizeof(struct thread_context));
                        if (non_BWRC_threads_mem == NULL) {
                            err_no = errno;
                            sprintf(msg, "malloc failed(with errno: %d) while allocating memory for thread context.\n", errno);
                            user_msg(&data, err_no, 0, HARD, msg);
                            /* Free BWRC memory also if allocated */
                            if (BWRC_threads_mem != NULL) {
                                free (BWRC_threads_mem);
                                BWRC_threads_mem = NULL;
                            }
                            exit(1);
                        }
                        initialize_threads(non_BWRC_threads_mem, num_non_BWRC_threads);

                        /**********************************************/
                        /* Populate thread context for all non BWRC   */
                        /* threads defined in current stanza.         */
                        /**********************************************/
                        rc = populate_thread_context(&data, current_ruleptr, BWRC_threads_mem, non_BWRC_threads_mem);
                    }

                    /**************************************************************/
                    /*** Spawn threads to execute testcase. First, BWRC threads ***/
                    /*** will be created for current stanza, if defined any.    ***/
                    /*** After that, non BWRC threads will be created.          ***/
                    /**************************************************************/
                    rc = pthread_mutex_lock(&thread_create_mutex);
                    if (rc) {
                        sprintf(msg, "Mutex lock failed in MAIN, rc = %d\n", rc);
                        user_msg(&data, rc, 0, HARD, msg);
                        exit(1);
                    }
                    for (i = 0; i < current_ruleptr->num_BWRC_threads; i++) {
                        current_tctx = &(BWRC_threads_mem[current_ruleptr->BWRC_th_mem_index + i]);

                        /* Need to check if current BWRC thread status is 'F' (i.e. Finished), then only
                         * need to create the thread. Otherwise, skip it.
                         */
                        if (lba_fencepost[current_tctx->fencepost_index].status == 'F') {
                            rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,
                                            (void *(*)(void *)) execute_thread_context, (void *) current_tctx);
                            if (rc) {
                                sprintf(msg, "rc %d, errno %d from main(): pthread_create for BWRC threads no: %d",
                                        rc, errno, i);
                                user_msg(&data, rc, 0, HARD, msg);
                                exit(rc);
                            }
                            rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);
                            if (rc) {
                                sprintf(msg, "Cond wait failed in MAIN for BWRC thread, rc = %d\n", rc);
                                user_msg(&data, rc, 0, HARD, msg);
                                exit(rc);
                            }
                            BWRC_threads_running++;
                        } else {
                            continue;
                        }
                    }
                    for (i=0; i < num_non_BWRC_threads; i++) {
                        current_tctx = &(non_BWRC_threads_mem[i]);
                        current_tctx->th_num = i;
                        rc = pthread_create(&(current_tctx->tid), &thread_attrs_detached,
                                    (void *(*)(void *)) execute_thread_context, (void *) current_tctx);
                        if (rc) {
                            sprintf(msg, "rc %d, errno %d from main(): pthread_create", rc,errno);
                            user_msg(&data, rc, 0, HARD, msg);
                            exit(rc);
                        }
                        rc = pthread_cond_wait(&create_thread_cond_var, &thread_create_mutex);
                        if (rc) {
                            sprintf(msg, "Cond wait failed in MAIN, rc = %d\n", rc);
                            user_msg(&data, rc, 0, HARD, msg);
                            exit(rc);
                        }
                        non_BWRC_threads_running++;
                    }

                    /**********************************************************************/
                    /******      Send broadcast to all threads to start executing   *******/
                    /**********************************************************************/
                    rc = pthread_cond_broadcast(&do_oper_cond_var);
                    if ( rc ) {
                        sprintf(msg,"pthread_cond_broadcast failed for do_oper_cond_var. rc = %d\n", rc);
                        user_msg(&data, rc, 0, HARD, msg);
                        exit(1);
                    }

                    /*************************************************************/
                    /****   wait for threads to finish if non BWRC stanza   ******/
                    /*************************************************************/
                    if (current_ruleptr->is_only_BWRC_stanza == 'N') {
                        rc = pthread_cond_wait(&threads_finished_cond_var, &thread_create_mutex);
                        if (rc) {
                            sprintf(msg, "Cond wait failed in MAIN for threads_finished condition variable.rc = %d\n", rc);
                            user_msg(&data, rc, 0, HARD, msg);
                            exit(rc);
                        }
                    }
                    rc = pthread_mutex_unlock(&thread_create_mutex);
                    if (rc) {
                        sprintf(msg, "Mutex unlock failed in MAIN, rc = %d\n", rc);
                        user_msg(&data, rc, 0, HARD, msg);
                        exit(rc);
                    }

                    /***********************************************************/
                    /********       Clean up thread context memory      ********/
                    /***********************************************************/
                    if (non_BWRC_threads_mem != NULL) {
                        free(non_BWRC_threads_mem);
                        non_BWRC_threads_mem = NULL;
                    }
                }
            } else {
                sprintf(msg, "Rule %s Has Been SKIPPED......\n", current_ruleptr->rule_id);
                user_msg(&data, 0, 0, INFO, msg);
            }
            current_ruleptr++;

            if (exit_flag == 1 || int_signal_flag == 'Y' || signal_flag == 'Y') {
                break;
            }
            /* DPRINT("%s:%d - Completed stanza: %d\n", __FUNCTION__, __LINE__, rule_no + 1); */

            /* time_driven_htx switches stanza with the given interval by setting time_out_flag as 0 */
            if (time_interval_for_run > 0) {
                rc = pthread_mutex_lock(&mutex_for_time_driven_exec);
                if (rc) {
                    sprintf(msg, "Mutex lock failed in MAIN for time_driven_exec, rc = %d\n", rc);
                    user_msg(&data, rc, 0, HARD, msg);
			    }
			    (time_diff_struct.time_out_flag) = 0;
                rc = pthread_mutex_unlock(&mutex_for_time_driven_exec);
                if (rc) {
                    sprintf(msg, "Mutex unlock failed in MAIN for time_driven_exec, rc = %d\n", rc);
                    user_msg(&data, rc, 0, HARD, msg);
			    }
		    }
        } /* End rule_no < num_rules_defined for loop */

        if (signal_flag == 'Y') {
			/*************************************************************************/
            /* Below code looks to see if it has received a signal 30 from the user. */
            /* This is to see if the user has made a change to the rules file. The   */
            /* program will reread the rules file and start processing again.        */
            /*************************************************************************/
            total_BWRC_threads = 0;
            free_BWRC_th_mem_index = 0;
            num_rules_defined = 0;
            signal_flag = 'N';
            rc = read_rf(&data, dev_info.rules_file_name, dev_info.maxblk, dev_info.blksize);
            if ( rc != 0 ) {
                sprintf(msg, "Check the HTXERR log for error information on rule file reading.\n");
                user_msg(&data, 0, 0, HARD, msg);
                return (-1);
            }
        }
        sprintf(msg, "Pass #%d, rule file %s completed.\nCollision count = %d.", read_rules_file_count,
                dev_info.rules_file_name, collisions);
        user_msg(&data, 0, 0, INFO, msg);
        HTX_STATS_UPDATE (FINISH, &data);
        read_rules_file_count++;
    } while ((strcmp(data.run_type, "REG") == 0) && (exit_flag == 0) && (int_signal_flag == 'N'));

    /****************************************************/
    /** Set the exit flag and wait for any BWRC thread **/
    /** if  running                                    **/
    /****************************************************/
    exit_flag = 1;
#ifdef __CAPI_FLASH__
    /* Wait for the thread (i.e. the thread for which open_flag was set) to close the LUN. */
    while (shared_lun_id != NULL_CHUNK_ID) {
        sleep(5);
    }
#endif
    while (BWRC_threads_running != 0 && wait_count > 0) {
        sleep(5);
        wait_count--;
    }

    /********************************************/
    /*****      Cleanup threads memory      *****/
    /********************************************/

    if (BWRC_threads_running != 0) {
        sprintf(msg, "Going to cleanup memory. Since some BWRC threads are still running, ignore if any core is generated.");
        user_msg(&data, 0, 0, INFO, msg);
    }
    cleanup_threads_mem();
    munmap(mmap_ptr, MMAP_FILE_SIZE);

    /* If enable_state_table flag is YES, SYNC the state table (i.e. update metadata on disk) */
    if (enable_state_table == YES) {
        rc = sync_state_table(&data, data.sdev_id);
        if (rc) {
			sprintf(msg, "Failed to update state table.\n");
            user_msg(&data, 0, 0, INFO, msg);
        }
    }

    pthread_attr_destroy(&thread_attrs_detached);
    return rc;
}
```


Overlapping Code:
```
ain(int argc, char *argv[])
{
int i, err_no, rule_no, rc = 0;
int wait_count = DEFAULT_WAIT_COUNT, skip_flag;
char *kdblevel = NULL, *eeh_env = NULL, *ptr = NULL;
struct ruleinfo *current_ruleptr;
char msg[MAX_TEXT_MSG], script_path[64], cmd_str[128];
struct thread_context *current_tctx;
char file_name[128];
struct sigaction sigvector, sigdata;
static sigset_t sigmask;
/****************************************/
/** Register Signal handlers */
/****************************************/
sigemptyset((&sigvector.sa_mask)); /* empty the mask */
sigvector.sa_flags = 0;
sigvector.sa_handler = (void (*)(int)) SIGTERM_hdl;
sigaction(SIGTERM, &sigvector, (struct sigaction *) NULL); /* set signal handler for SIGTERM */
sigprocmask(0, NULL, &sigmask); /* get current signal mask */
sigdata.sa_flags = SA_RESTART; /* restart on signal calls */
sigdata.sa_mask = sigmask; /* set the signal mask */
sigdata.sa_handler = (void(*)(int))sig_function;
sigaction(SIGUSR1, &sigdata, NULL); /* call when recv sig 30 */
sigdata.sa_handler = (void(*)(int))int_sig_function;
sigaction(SIGINT, &sigdata, NULL); /* set signal handler for SIGINT */
/*********************************************/
/** Initialize thread attributes and mutex **/
/*********************************************/
pthread_attr_init(&thread_attrs_detached);
pthread_attr_setdetachstate(&thread_attrs_detached, PTHREAD_CREATE_DETACHED);
pthread_mutex_init(&thread_create_mutex, DEFAULT_MUTEX_ATTR_PTR);
pthread_mutex_init(&cache_mutex, DEFAULT_MUTEX_ATTR_PTR);
pthread_mutex_init(&fencepost_mutex, DEFAULT_MUTEX_ATTR_PTR);
pthread_mutex_init(&stats_mutex, DEFAULT_MUTEX_ATTR_PTR);
pthread_mutex_init(&dump_mutex, DEFAULT_MUTEX_ATTR_PTR);
#ifndef __HTX_LINUX__
pthread_mutex_init(&log_mutex, DEFAULT_MUTEX_ATTR_PTR);
#endif
pthread_cond_init(&create_thread_cond_var, DEFAULT_COND_ATTR_PTR);
pthread_cond_init(&do_oper_cond_var, DEFAULT_COND_ATTR_PTR);
pthread_cond_init(&threads_finished_cond_var, DEFAULT_COND_ATTR_PTR);
bzero(&dev_info, sizeof(dev_info));
dev_info.cont_on_misc = UNINITIALIZED;
/************************************************/
/******* Read command line arguments *******/
/************************************************/
memset(&data, 0, sizeof(struct htx_data));
strcp
```
<Overlap Ratio: 0.9868421052631579>

---

--- 289 --
Question ID: cff9b445f2f101cf0533131ecaf7b57b8382f4bc_7
Original Code:
```
int
xheart_intr_establish(int (*func)(void *), void *arg, int intrbit,
    int level, const char *name, struct intrhand *ihstore)
{
	struct intrhand *ih;
	int s;
	u_long cpuid = cpu_number();

#ifdef DIAGNOSTIC
	if (intrbit < 0 || intrbit >= HEART_NINTS)
		return EINVAL;
#endif

	/*
	 * HEART interrupts are not supposed to be shared - the interrupt
	 * mask is large enough for all widgets.
	 */
	if (xheart_intrhand[intrbit] != NULL)
		return EEXIST;

	if (ihstore == NULL) {
		ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
		if (ih == NULL)
			return ENOMEM;
		ih->ih_flags = IH_ALLOCATED;
	} else {
		ih = ihstore;
		ih->ih_flags = 0;
	}

	ih->ih_next = NULL;
	ih->ih_fun = func;
	ih->ih_arg = arg;
	ih->ih_level = level;
	ih->ih_irq = intrbit;
	if (name != NULL)
		evcount_attach(&ih->ih_count, name, &ih->ih_level);

	s = splhigh();

	xheart_intrhand[intrbit] = ih;

	xheart_intem[cpuid] |= 1UL << intrbit;
	xheart_intr_makemasks();

	splx(s);	/* causes hw mask update */

	return 0;
}
```


Overlapping Code:
```
rt_intr_establish(int (*func)(void *), void *arg, int intrbit,
int level, const char *name, struct intrhand *ihstore)
{
struct intrhand *ih;
int s;
u_long cpuid = cpu_number();
#ifdef DIAGNOSTIC
if (intrbit < 0 || intrbit >= HEART_NINTS)
return EINVAL;
#endif
/*
* HEART interrupts are not supposed to be shared - the interrupt
* mask is large enough for all widgets.
*/
if (xheart_intrhand[intrbit] != NULL)
return EEXIST;
if (ihstore == NULL) {
ih = malloc(sizeof(*ih), M_DEVBUF, M_NOWAIT);
if (ih == NULL)
return ENOMEM;
ih->ih_flags = IH_ALLOCATED;
} else {
ih = ihstore;
ih->ih_flags = 0;
}
ih->ih_next = NULL;
ih->ih_fun = func;
ih->ih_arg = arg;
ih->ih_level = level;
ih->ih_irq = intrbit;
if (name != NULL)
evcount_attach(&ih->ih_count, name, &ih->ih_level);
s = splhigh();
xheart_intrhand[intrbit] = ih;
xheart_intem[cpuid] |= 1UL << intrbit;
xheart_intr_makemasks();
splx(s); /* causes hw mask update */
return 0;
```
<Overlap Ratio: 0.9892818863879957>

---

--- 290 --
Question ID: 7fadc564b7275dee9bfb054b3051db4a87ae3993_0
Original Code:
```
ssize_t
read_pos(int fd, fs_off_t _pos, void *data,  size_t nbytes)
{
    off_t  pos = (off_t)_pos;
    size_t ret;
    
    if (lseek(fd, pos, SEEK_SET) < 0) {
        perror("read lseek");
        return EINVAL;
    }
    
    ret = read(fd, data, nbytes);

    if (ret != nbytes) {
        printf("read_pos: wanted %d, got %d\n", nbytes, ret);
        return -1;
    }

    return ret;
}
```


Overlapping Code:
```
ze_t
read_pos(int fd, fs_off_t _pos, void *data, size_t nbytes)
{
off_t pos = (off_t)_pos;
size_t ret;

if (lseek(fd, pos, SEEK_SET) < 0) {
perror("read lseek");
return EINVAL;
}

ret = read(fd, data, nbytes);
if (ret != nbytes) {
printf("read_pos: wanted %d, got %d\n", nbytes, ret);
return -1;
}
retu
```
<Overlap Ratio: 0.9617834394904459>

---

--- 291 --
Question ID: 23dcb887f14a0cd6c6f819458d1247afd4ba1639_2
Original Code:
```
static void
STV_InitObj(struct sess *sp, struct object *o, unsigned wsl, unsigned lhttp,
    unsigned nhttp)
{

	memset(o, 0, sizeof *o);
	o->magic = OBJECT_MAGIC;

	assert(PAOK(wsl));
	assert(PAOK(lhttp));

	o->http = HTTP_create(o + 1, nhttp);
	WS_Init(o->ws_o, "obj", (char *)(o + 1) + lhttp, wsl);
	WS_Assert(o->ws_o);

	http_Setup(o->http, o->ws_o);
	o->http->magic = HTTP_MAGIC;
	o->grace = NAN;
	o->entered = NAN;
	VTAILQ_INIT(&o->store);
	sp->wrk->stats.n_object++;
}
```


Overlapping Code:
```
struct object *o, unsigned wsl, unsigned lhttp,
unsigned nhttp)
{
memset(o, 0, sizeof *o);
o->magic = OBJECT_MAGIC;
assert(PAOK(wsl));
assert(PAOK(lhttp));
o->http = HTTP_create(o + 1, nhttp);
WS_Init(o->ws_o, "obj", (char *)(o + 1) + lhttp, wsl);
WS_Assert(o->ws_o);
http_Setup(o->http, o->ws_o);
o->http->magic = HTTP_MAGIC;
o->grace = NAN;
o->entered = NAN;
VTAILQ_INIT(&o->store);
sp->wrk->stats.
```
<Overlap Ratio: 0.8810572687224669>

---

--- 292 --
Question ID: aa050ef7ede87deba9543024fa37bfb8756f121c_0
Original Code:
```
uint8_t readNetworkIdFromBip32path(uint32_t bip32Path[]) {
    uint8_t outNetworkId;
    switch(bip32Path[2]) {
        case 0x80000068: 
            outNetworkId = 104; //N
            break;
        case 0x80000098:
           outNetworkId = 152; //T
           break;
        case 0x80000060:
            outNetworkId = 96; //M
            break;
        case 0x80000090:
            outNetworkId = 144; //S
            break;
        default:
            THROW(0x6a80);
    }
    return outNetworkId;
}
```


Overlapping Code:
```
nt8_t readNetworkIdFromBip32path(uint32_t bip32Path[]) {
uint8_t outNetworkId;
switch(bip32Path[2]) {
case 0x80000068: 
outNetworkId = 104; //N
break;
case 0x80000098:
outNetworkId = 152; //T
break;
case 0x80000060:
outNetworkId = 96; //M
break;
case 0x80000090:
outNetworkId = 144; //S
break;
default:
THROW(0x6a80);
}
return outNetwo
```
<Overlap Ratio: 0.9738372093023255>

---

--- 293 --
Question ID: b5e9ba689664d80701625c617f59f3ee9eb82b65_0
Original Code:
```
int16_t testDM1 ( void )
{
  int32_t t[64],a;
  PW_Start_Address = PW_i;

  /* file size */
  if ( (PW_Start_Address + 104) > PW_in_size )
  {
    /*printf ( "#1 (start:%d) (size:%d)\n" , PW_Start_Address , PW_in_size-PW_Start_Address);*/
    return BAD;
  }

  /* get track sizes */
  for ( a=0; a<4; a++)
  {
    t[a] = (( in_data[PW_Start_Address+6+(a*4)]*256)+
              in_data[PW_Start_Address+7+(a*4)] );
    if (t[a] > 0x7fff) return BAD;
  }

  /* get note block size */
  t[4] = (( in_data[PW_Start_Address+22]*256) + in_data[PW_Start_Address+23] );


  /* get sounds sizes */
  for ( a=0; a<20; a++)
  {
    t[a+40] = (( in_data[PW_Start_Address+25+(a*4)]*256*256)+
               ( in_data[PW_Start_Address+26+(a*4)]*256)+
                 in_data[PW_Start_Address+27+(a*4)] );
    if (t[a+40] > 0xffff) return BAD;
  }

  /* file size */
  PW_l = t[0] + t[1] + t[2] + t[3] + t[4] + 104;
  if ( (PW_Start_Address + PW_l) > PW_in_size)
  {
    printf ( "#1,3 (start:%d) (t[0]:%x)(t[1]:%x)(t[2]:%x)(t[3]:%x)(t[4]:%x)\n" , PW_Start_Address , t[0],t[1],t[2],t[3],t[4]);
    return BAD;
  }

  for ( a=40; a<60; a++)PW_l += t[a];

  return GOOD;
}
```


Overlapping Code:
```
( void )
{
int32_t t[64],a;
PW_Start_Address = PW_i;
/* file size */
if ( (PW_Start_Address + 104) > PW_in_size )
{
/*printf ( "#1 (start:%d) (size:%d)\n" , PW_Start_Address , PW_in_size-PW_Start_Address);*/
return BAD;
}
/* get track sizes */
for ( a=0; a<4; a++)
{
t[a] = (( in_data[PW_Start_Address+6+(a*4)]*256)+
in_data[PW_Start_Address+7+(a*4)] );
if (t[a] > 0x7fff) return BAD;
}
/* get note block size */
t[4] = (( in_data[PW_Start_Address+22]*256) + in_data[PW_Start_Address+23] );
/* get sounds sizes */
for ( a=0; a<20; a++)
{
t[a+40] = (( in_data[PW_Start_Address+25+(a*4)]*256*256)+
( in_data[PW_Start_Address+26+(a*4)]*256)+
in_data[PW_Start_Address+27+(a*4)] );
if (t[a+40] > 0xffff) return BAD;
}
/* file size */
PW_l = t[0] + t[1] + t[2] + t[3] + t[4] + 104;
if ( (PW_Start_Address + PW_l) > PW_in_size)
{
printf ( "#1,3 (start:%d) (t[0]:%x)(t[1]:%x)(t[2]:%x)(t[3]:%x)(t[4]:%x)\n" , PW_Start_Address , t[0],t[1],t[2],t[3],t[4]);
return BAD;
}
for ( a=40; a<60; a++)PW_l += t[a];
retu
```
<Overlap Ratio: 0.9746588693957114>

---

--- 294 --
Question ID: 4a83d91e1f8642bfa81c35c5a94c9bc5068fea61_4
Original Code:
```
int heap_realloc(Heap *heap, va_t va, size_t size)
{
    if (heap->var_pool[va].occupied == false)
        return pvm_reporterror(HEAP_H, __FUNCTION__, "Target unallocated");

    PrimitiveData * tmp;

    heap->totalblocks -= heap->var_pool[va].framesize; // Minus previous size
    heap->totalblocks += heap->var_pool[va].framesize = size; // New size

    tmp = realloc(heap->var_pool[va].block, size);
    if (tmp == NULL)
        return pvm_reporterror(HEAP_H, __FUNCTION__, "Allocation Failed");

    heap->var_pool[va].block = tmp;
    return 0;
}
```


Overlapping Code:
```
Heap *heap, va_t va, size_t size)
{
if (heap->var_pool[va].occupied == false)
return pvm_reporterror(HEAP_H, __FUNCTION__, "Target unallocated");
PrimitiveData * tmp;
heap->totalblocks -= heap->var_pool[va].framesize; // Minus previous size
heap->totalblocks += heap->var_pool[va].framesize = size; // New size
tmp = realloc(heap->var_pool[va].block, size);
if (tmp == NULL)
return pvm_reporterror(HEAP_H, __FUNCTION__, "Allocation Failed");
heap->var_pool[va].blo
```
<Overlap Ratio: 0.9243027888446215>

---

--- 295 --
Question ID: 5b57636cc8ea797da3ace146e7bd731a30b2af16_14
Original Code:
```
void vithist_utt_reset (vithist_t *vh)
{
    int32 b;
    
    vithist_lmstate_reset (vh);
    
    for (b = VITHIST_ID2BLK(vh->n_entry-1); b >= 0; --b) {
	ckd_free ((void *) vh->entry[b]);
	vh->entry[b] = NULL;
    }
    vh->n_entry = 0;
    
    vh->bestscore[0] = MAX_NEG_INT32;
    vh->bestvh[0] = -1;
}
```


Overlapping Code:
```
vithist_utt_reset (vithist_t *vh)
{
int32 b;

vithist_lmstate_reset (vh);

for (b = VITHIST_ID2BLK(vh->n_entry-1); b >= 0; --b) {
ckd_free ((void *) vh->entry[b]);
vh->entry[b] = NULL;
}
vh->n_entry = 0;

vh->bestscore[0] = MAX_NEG_INT32;
vh->bestvh[0] = 
```
<Overlap Ratio: 0.9622641509433962>

---

--- 296 --
Question ID: 42ade8c7bc75585628862cf8f3de1653a53a1aed_4
Original Code:
```
void rl_index_remove(index_t* index, int object_id) {
	if(object_id < 0 || object_id >= index->num_elements) return;
	index_cell_t* cell = &index->cells[index->element_cell[object_id]];
	int remove_index = index->element_index_in_cell[object_id];
	if(remove_index < cell->num_elements - 1) {
		int moved_object_id = cell->elements[cell->num_elements - 1].object_id;
		cell->elements[remove_index] = cell->elements[cell->num_elements - 1];
		index->element_index_in_cell[moved_object_id] = remove_index;
	}
	cell->num_elements--;
}
```


Overlapping Code:
```
move(index_t* index, int object_id) {
if(object_id < 0 || object_id >= index->num_elements) return;
index_cell_t* cell = &index->cells[index->element_cell[object_id]];
int remove_index = index->element_index_in_cell[object_id];
if(remove_index < cell->num_elements - 1) {
int moved_object_id = cell->elements[cell->num_elements - 1].object_id;
cell->elements[remove_index] = cell->elements[cell->num_elements - 1];
index->element_index_in_cell[moved_object_id] = remove_index;
}
cell->num_elements--;
```
<Overlap Ratio: 0.9652509652509652>

---

--- 297 --
Question ID: afecc77e3127d2cc6643f625b12c27fbf8673e7a_4
Original Code:
```
static boolean
brw_layout_3d_cube( struct brw_texture *tex )
{
   GLuint width  = tex->b.b.width0;
   GLuint height = tex->b.b.height0;
   GLuint depth = tex->b.b.depth0;
   GLuint pack_x_pitch, pack_x_nr;
   GLuint pack_y_pitch;
   GLuint level;
   GLuint align_h = 2;
   GLuint align_w = 4;

   tex->total_height = 0;
   brw_tex_alignment_unit(tex->b.b.format, &align_w, &align_h);

   if (tex->compressed) {
      tex->pitch = align(width, align_w);
      pack_y_pitch = (height + 3) / 4;
   } else {
      tex->pitch = brw_tex_pitch_align(tex, tex->b.b.width0);
      pack_y_pitch = align(tex->b.b.height0, align_h);
   }

   pack_x_pitch = width;
   pack_x_nr = 1;

   for (level = 0 ; level <= tex->b.b.last_level ; level++) {
      GLuint nr_images = tex->b.b.target == PIPE_TEXTURE_3D ? depth : 6;
      GLint x = 0;
      GLint y = 0;
      GLint q, j;

      brw_tex_set_level_info(tex, level, nr_images,
				   0, tex->total_height,
				   width, height, depth);

      for (q = 0; q < nr_images;) {
	 for (j = 0; j < pack_x_nr && q < nr_images; j++, q++) {
	    brw_tex_set_image_offset(tex, level, q, x, y, 0);
	    x += pack_x_pitch;
	 }

	 x = 0;
	 y += pack_y_pitch;
      }


      tex->total_height += y;
      width  = u_minify(width, 1);
      height = u_minify(height, 1);
      depth  = u_minify(depth, 1);

      if (tex->compressed) {
	 pack_y_pitch = (height + 3) / 4;

	 if (pack_x_pitch > align(width, align_w)) {
	    pack_x_pitch = align(width, align_w);
	    pack_x_nr <<= 1;
	 }
      } else {
	 if (pack_x_pitch > 4) {
	    pack_x_pitch >>= 1;
	    pack_x_nr <<= 1;
	    assert(pack_x_pitch * pack_x_nr <= tex->pitch);
	 }

	 if (pack_y_pitch > 2) {
	    pack_y_pitch >>= 1;
	    pack_y_pitch = align(pack_y_pitch, align_h);
	 }
      }
   }

   /* The 965's sampler lays cachelines out according to how accesses
    * in the texture surfaces run, so they may be "vertical" through
    * memory.  As a result, the docs say in Surface Padding Requirements:
    * Sampling Engine Surfaces that two extra rows of padding are required.
    */
   if (tex->b.b.target == PIPE_TEXTURE_CUBE)
      tex->total_height += 2;

   return TRUE;
}
```


Overlapping Code:
```
ean
brw_layout_3d_cube( struct brw_texture *tex )
{
GLuint width = tex->b.b.width0;
GLuint height = tex->b.b.height0;
GLuint depth = tex->b.b.depth0;
GLuint pack_x_pitch, pack_x_nr;
GLuint pack_y_pitch;
GLuint level;
GLuint align_h = 2;
GLuint align_w = 4;
tex->total_height = 0;
brw_tex_alignment_unit(tex->b.b.format, &align_w, &align_h);
if (tex->compressed) {
tex->pitch = align(width, align_w);
pack_y_pitch = (height + 3) / 4;
} else {
tex->pitch = brw_tex_pitch_align(tex, tex->b.b.width0);
pack_y_pitch = align(tex->b.b.height0, align_h);
}
pack_x_pitch = width;
pack_x_nr = 1;
for (level = 0 ; level <= tex->b.b.last_level ; level++) {
GLuint nr_images = tex->b.b.target == PIPE_TEXTURE_3D ? depth : 6;
GLint x = 0;
GLint y = 0;
GLint q, j;
brw_tex_set_level_info(tex, level, nr_images,
0, tex->total_height,
width, height, depth);
for (q = 0; q < nr_images;) {
for (j = 0; j < pack_x_nr && q < nr_images; j++, q++) {
brw_tex_set_image_offset(tex, level, q, x, y, 0);
x += pack_x_pitch;
}
x = 0;
y += pack_y_pitch;
}
tex->total_height += y;
width = u_minify(width, 1);
height = u_minify(height, 1);
depth = u_minify(depth, 1);
if (tex->compressed) {
pack_y_pitch = (height + 3) / 4;
if (pack_x_pitch > align(width, align_w)) {
pack_x_pitch = align(width, align_w);
pack_x_nr <<= 1;
}
} else {
if (pack_x_pitch > 4) {
pack_x_pitch >>= 1;
pack_x_nr <<= 1;
assert(pack_x_pitch * pack_x_nr <= tex->pitch);
}
if (pack_y_pitch > 2) {
pack_y_pitch >>= 1;
pack_y_pitch = align(pack_y_pitch, align_h);
}
}
}
/* The 965's sampler lays cachelines out according to how accesses
* in the texture surfaces run, so they may be "vertical" through
* memory. As a result, the docs say in Surface Padding Requirements:
* Sampling Engine Surfaces that two extra rows of padding are required.
*/
if (tex->b.b.target == PIPE_TEXTURE_CUBE)
tex->total_height += 2;

```
<Overlap Ratio: 0.9866666666666667>

---

--- 298 --
Question ID: 264569a94880afbc2c5a62ff6d1e181bfc6232b0_6
Original Code:
```
static int next(int zone)
{
	if (!zone)
		zone = FIRSTZONE - 1;
	while (++zone < ZONES)
		if (zone_in_use(zone))
			return zone;
	return 0;
}
```


Overlapping Code:
```
!zone)
zone = FIRSTZONE - 1;
while (++zone < ZONES
```
<Overlap Ratio: 0.3816793893129771>

---

--- 299 --
Question ID: 54255194feb90b09a23b5a9043461f03b23abb7f_5
Original Code:
```
retval_t SH7x_measure_temperature(uint16_t* temp){
    retval_t rv;
    uint8_t aux[2];
    uint8_t checksum;

    SH7x_start_transmission();
    rv = SH7x_write_byte(SH7x_CMD_MEASURE_TEMPERATURE);
    if(RV_SUCCESS != rv){
        SH7x_hard_reset();
        return rv;
    }
    SH7x_data_as_input();
    // TODO: Add timeout here. This can hang out if chip never answer 
    while (IsBitSet(sensor_th_data_PIN, sensor_th_data_PIN_NUMBER)){}//wait until sensor has finished the measurement

    SH7x_read_byte(&aux[0], true);
    SH7x_read_byte(&aux[1], true);
    SH7x_read_byte(&checksum, false);
    rv = SH7x_checksum(aux, checksum);
    if(RV_SUCCESS == rv){
        *temp = (aux[0]<<8) | aux[1];
    }

    return rv;
}
```


Overlapping Code:
```
e(uint16_t* temp){
retval_t rv;
uint8_t aux[2];
uint8_t checksum;
SH7x_start_transmission();
rv = SH7x_write_byte(SH7x_CMD_MEASURE_TEMPERATURE);
if(RV_SUCCESS != rv){
SH7x_hard_reset();
return rv;
}
SH7x_data_as_input();
// TODO: Add timeout here. This can hang out if chip never answer 
while (IsBitSet(sensor_th_data_PIN, sensor_th_data_PIN_NUMBER)){}//wait until sensor has finished the measurement
SH7x_read_byte(&aux[0], true);
SH7x_read_byte(&aux[1], true);
SH7x_read_byte(&checksum, false);
rv = SH7x_checksum(aux, checksum);
if(RV_SUCCESS == 
```
<Overlap Ratio: 0.8716323296354992>

---

--- 300 --
Question ID: cbd8c253f0b8437c5d909c4a01fb0e612bf9cb58_8
Original Code:
```
static HRESULT WINAPI
ISF_MyComputer_fnCompareIDs (IShellFolder2 * iface, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ICOM_THIS (IGenericSFImpl, iface);

    int nReturn;

    TRACE ("(%p)->(0x%08lx,pidl1=%p,pidl2=%p)\n", This, lParam, pidl1, pidl2);
    nReturn = SHELL32_CompareIDs (_IShellFolder_ (This), lParam, pidl1, pidl2);
    TRACE ("-- %i\n", nReturn);
    return nReturn;
}
```


Overlapping Code:
```
WINAPI
ISF_MyComputer_fnCompareIDs (IShellFolder2 * iface, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
ICOM_THIS (IGenericSFImpl, iface);
int nReturn;
TRACE ("(%p)->(0x%08lx,pidl1=%p,pidl2=%p)\n", This, lParam, pidl1, pidl2);
nReturn = SHELL32_CompareIDs (_IShellFolder_ (This), lParam, pidl1, pidl2);
TRACE ("-- %i\n", nReturn);
retur
```
<Overlap Ratio: 0.9283819628647215>

---

--- 301 --
Question ID: 0af2fc52eff76578ae5c4d3cc3fd7ad67ba37d5f_13
Original Code:
```
int kvtree_util_get_int64(const kvtree* hash, const char* key, int64_t* val)
{
  int rc = KVTREE_FAILURE;

  /* check whether this key is even set */
  char* val_str = kvtree_get_val(hash, key);
  if (val_str != NULL) {
    /* convert the key string */
    *val = (int64_t) strtoll(val_str, NULL, 0);
    rc = KVTREE_SUCCESS;
  }

  return rc;
}
```


Overlapping Code:
```
t kvtree_util_get_int64(const kvtree* hash, const char* key, int64_t* val)
{
int rc = KVTREE_FAILURE;
/* check whether this key is even set */
char* val_str = kvtree_get_val(hash, key);
if (val_str != NULL) {
/* convert the key string */
*val = (int64_t) strtoll(val_str, NULL, 0);
rc = KVTREE_SUCCES
```
<Overlap Ratio: 0.9404388714733543>

---

--- 302 --
Question ID: 1e982e12cbb976f5cac8bb03a4d42f647223af4c_8
Original Code:
```
ALL_CINT1E(int1e_spnuc)
ALL_CINT1E_FORTRAN_(int1e_spnuc)
/* <k SIGMA DOT P i|R12 |j l> : i,j \in electron 1; k,l \in electron 2
 * = (SIGMA DOT P i j|R12 |k l) */
void CINTgout2e_int2e_spv1(double *gout,
double *g, FINT *idx, CINTEnvVars *envs, FINT gout_empty) {
FINT nf = envs->nf;
FINT nrys_roots = envs->nrys_roots;
FINT ix, iy, iz, i, n;
double *g0 = g;
double *g1 = g0 + envs->g_size * 3;
G2E_D_I(g1, g0, envs->i_l+0, envs->j_l, envs->k_l, envs->l_l);
double s[3];
for (n = 0; n < nf; n++) {
ix = idx[0+n*3];
iy = idx[1+n*3];
iz = idx[2+n*3];
switch (nrys_roots) {
case 1:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0];
break;
case 2:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1];
break;
case 3:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2];
break;
case 4:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2]+ g1[ix+3]*g0[iy+3]*g0[iz+3];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2]+ g0[ix+3]*g1[iy+3]*g0[iz+3];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2]+ g0[ix+3]*g0[iy+3]*g1[iz+3];
break;
default:
for (i = 0; i < 3; i++) { s[i] = 0; }
for (i = 0; i < nrys_roots; i++) {
s[0] += g1[ix+i] * g0[iy+i] * g0[iz+i];
s[1] += g0[ix+i] * g1[iy+i] * g0[iz+i];
s[2] += g0[ix+i] * g0[iy+i] * g1[iz+i];
} break;}
if (gout_empty) {
gout[n*4+0] = + s[0];
gout[n*4+1] = + s[1];
gout[n*4+2] = + s[2];
gout[n*4+3] = 0;
} else {
gout[n*4+0] += + s[0];
gout[n*4+1] += + s[1];
gout[n*4+2] += + s[2];
gout[n*4+3] += 0;
}}}
```


Overlapping Code:
```
LL_CINT1E(int1e_spnuc)
ALL_CINT1E_FORTRAN_(int1e_spnuc)
/* <k SIGMA DOT P i|R12 |j l> : i,j \in electron 1; k,l \in electron 2
* = (SIGMA DOT P i j|R12 |k l) */
void CINTgout2e_int2e_spv1(double *gout,
double *g, FINT *idx, CINTEnvVars *envs, FINT gout_empty) {
FINT nf = envs->nf;
FINT nrys_roots = envs->nrys_roots;
FINT ix, iy, iz, i, n;
double *g0 = g;
double *g1 = g0 + envs->g_size * 3;
G2E_D_I(g1, g0, envs->i_l+0, envs->j_l, envs->k_l, envs->l_l);
double s[3];
for (n = 0; n < nf; n++) {
ix = idx[0+n*3];
iy = idx[1+n*3];
iz = idx[2+n*3];
switch (nrys_roots) {
case 1:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0];
break;
case 2:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1];
break;
case 3:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2];
break;
case 4:
s[0] = + g1[ix+0]*g0[iy+0]*g0[iz+0]+ g1[ix+1]*g0[iy+1]*g0[iz+1]+ g1[ix+2]*g0[iy+2]*g0[iz+2]+ g1[ix+3]*g0[iy+3]*g0[iz+3];
s[1] = + g0[ix+0]*g1[iy+0]*g0[iz+0]+ g0[ix+1]*g1[iy+1]*g0[iz+1]+ g0[ix+2]*g1[iy+2]*g0[iz+2]+ g0[ix+3]*g1[iy+3]*g0[iz+3];
s[2] = + g0[ix+0]*g0[iy+0]*g1[iz+0]+ g0[ix+1]*g0[iy+1]*g1[iz+1]+ g0[ix+2]*g0[iy+2]*g1[iz+2]+ g0[ix+3]*g0[iy+3]*g1[iz+3];
break;
default:
for (i = 0; i < 3; i++) { s[i] = 0; }
for (i = 0; i < nrys_roots; i++) {
s[0] += g1[ix+i] * g0[iy+i] * g0[iz+i];
s[1] += g0[ix+i] * g1[iy+i] * g0[iz+i];
s[2] += g0[ix+i] * g0[iy+i] * g1[iz+i];
} break;}
if (gout_empty) {
gout[n*4+0] = + s[0];
gout[n*4+1] = + s[1];
gout[n*4+2] = + s[2];
gout[n*4+3] = 0;
} else {
gout[n*4+0] += + s[0];
gout[n*4+1] += + s[1];
gout[n*4+2] += + s[2];
gout[n*4+3
```
<Overlap Ratio: 0.9939698492462311>

---

--- 303 --
Question ID: 7b3c531bf922c3a151d57c033b7fbb4c54dd41f8_11
Original Code:
```
void TRI_DestroyCondition (TRI_condition_t* cond) {
  pthread_cond_destroy(&cond->_cond);
  pthread_mutex_destroy(cond->_mutex);
  TRI_Free(TRI_CORE_MEM_ZONE, cond->_mutex);
}
```


Overlapping Code:
```
 TRI_DestroyCondition (TRI_condition_t* cond) {
pthread_cond_destroy(&cond->_cond);
pthread_mutex_destroy(cond->_mutex);
TRI_Free(TRI_CORE_MEM_ZONE, cond->_mutex);
}
```
<Overlap Ratio: 0.9763313609467456>

---

--- 304 --
Question ID: 2cc10f9b057e6c67ea46cb6003f4b67f09ce90b8_12
Original Code:
```
u8 *
format_vnet_buffer_opaque2 (u8 * s, va_list * args)
{
  vlib_buffer_t *b = va_arg (*args, vlib_buffer_t *);
  vnet_buffer_opaque2_t *o = (vnet_buffer_opaque2_t *) b->opaque2;

  int i;

  s = format (s, "raw: ");

  for (i = 0; i < ARRAY_LEN (b->opaque2); i++)
    s = format (s, "%08x ", b->opaque2[i]);
  vec_add1 (s, '\n');

  s = format (s, "qos.bits: %x, qos.source: %x",
	      (u32) (o->qos.bits), (u32) (o->qos.source));
  vec_add1 (s, '\n');
  s = format (s, "loop_counter: %d", o->loop_counter);
  vec_add1 (s, '\n');

  s = format (s, "gbp.flags: %x, gbp.sclass: %d",
	      (u32) (o->gbp.flags), (u32) (o->gbp.sclass));
  vec_add1 (s, '\n');

  s = format (s, "pg_replay_timestamp: %llu", (u32) (o->pg_replay_timestamp));
  vec_add1 (s, '\n');
  return s;
}
```


Overlapping Code:
```

format_vnet_buffer_opaque2 (u8 * s, va_list * args)
{
vlib_buffer_t *b = va_arg (*args, vlib_buffer_t *);
vnet_buffer_opaque2_t *o = (vnet_buffer_opaque2_t *) b->opaque2;
int i;
s = format (s, "raw: ");
for (i = 0; i < ARRAY_LEN (b->opaque2); i++)
s = format (s, "%08x ", b->opaque2[i]);
vec_add1 (s, '\n');
s = format (s, "qos.bits: %x, qos.source: %x",
(u32) (o->qos.bits), (u32) (o->qos.source));
vec_add1 (s, '\n');
s = format (s, "loop_counter: %d", o->loop_counter);
vec_add1 (s, '\n');
s = format (s, "gbp.flags: %x, gbp.sclass: %d",
(u32) (o->gbp.flags), (u32) (o->gbp.sclass));
vec_add1 (s, '\n');
s = format (s, "pg_replay_timestamp: %llu", (u32) (o->pg_replay_timestamp));
vec_add1 (s, '\
```
<Overlap Ratio: 0.9722222222222222>

---

--- 305 --
Question ID: 0f99f6327b527ae6e12fffa6602de135952fd63a_0
Original Code:
```
static void flashRead(uint32_t addr, uint16_t len, uint8_t *pBuf)
{
   uint8_t  *flashPtr;
   uint16_t flashIndex;

   flashPtr = (uint8_t *)addr;

   for(flashIndex = 0; flashIndex <= len; flashIndex++)
   {
     /* data fit into buffer */
     pBuf[flashIndex] = *flashPtr++;
   }
}
```


Overlapping Code:
```
_t len, uint8_t *pBuf)
{
uint8_t *flashPtr;
uint16_t flashIndex;
flashPtr = (uint8_t *)addr;
for(flashIndex = 0; flashIndex <= len; flashIndex++)
{
/* data fit into buffer */
pBuf[flashIndex] = *flash
```
<Overlap Ratio: 0.7905138339920948>

---

--- 306 --
Question ID: 11f859dfb69af00d0256bec21679a0f7e5961433_37
Original Code:
```
Returncode integration_M_f_try_catch_raise(integration_M_TestStruct* t, Ref_Manager* t_Refman) {
    Returncode LUMI_err = OK;
    String aux_String_0_Var = {0};
    String* aux_String_0 = NULL;
    Ref_Manager* aux_String_0_Refman = NULL;
    LUMI_inc_ref(t_Refman);
    do {
        ++LUMI_trace_ignore_count;
#undef RETURN_ERROR
#define RETURN_ERROR break
        CHECK_REF(422, t, t_Refman)
        t->num = 1;

#undef RETURN_ERROR
#define RETURN_ERROR goto LUMI_cleanup
    } while (false);
    --LUMI_trace_ignore_count;
    if (LUMI_err != OK) {
        LUMI_err = OK;
        INIT_STRING_CONST(424, aux_String_0, "ignored message");
        USER_RAISE(424, aux_String_0, aux_String_0_Refman)
    }
LUMI_cleanup:
    LUMI_var_dec_ref(aux_String_0_Refman);
    LUMI_dec_ref(t_Refman);
    return LUMI_err;
}
```


Overlapping Code:
```
turncode integration_M_f_try_catch_raise(integration_M_TestStruct* t, Ref_Manager* t_Refman) {
Returncode LUMI_err = OK;
String aux_String_0_Var = {0};
String* aux_String_0 = NULL;
Ref_Manager* aux_String_0_Refman = NULL;
LUMI_inc_ref(t_Refman);
do {
++LUMI_trace_ignore_count;
#undef RETURN_ERROR
#define RETURN_ERROR break
CHECK_REF(422, t, t_Refman)
t->num = 1;
#undef RETURN_ERROR
#define RETURN_ERROR goto LUMI_cleanup
} while (false);
--LUMI_trace_ignore_count;
if (LUMI_err != OK) {
LUMI_err = OK;
INIT_STRING_CONST(424, aux_String_0, "ignored message");
USER_RAISE(424, aux_String_0, aux_String_0_Refman)
}
LUMI_cleanup:
LUMI_var_dec_ref(aux_String_0_Refman);
LUMI_dec_ref(t_Refman);
return LUMI_err
```
<Overlap Ratio: 0.9929775280898876>

---

--- 307 --
Question ID: d2365ac19071830b200c77b27a3827b375ded5db_2
Original Code:
```
static void
sighandler(int sig) {
	const char* signame = "UNKNOWN";
	switch (sig) {
		case SIGKILL:
			signame = "SIGKILL";
			break;
		case SIGTERM:
			signame = "SIGTERM";
			break;
		case SIGQUIT:
			signame = "SIGQUIT";
			break;
		case SIGINT:
			signame = "SIGINT";
			break;
		default:
			break;
	}
	log_infof(0, STRING_CONST("Caught signal: %s (%d)"), signame, sig);
	system_post_event(FOUNDATIONEVENT_TERMINATE);
}
```


Overlapping Code:
```
 void
sighandler(int sig) {
const char* signame = "UNKNOWN";
switch (sig) {
case SIGKILL:
signame = "SIGKILL";
break;
case SIGTERM:
signame = "SIGTERM";
break;
case SIGQUIT:
signame = "SIGQUIT";
break;
case SIGINT:
signame = "SIGINT";
break;
default:
break;
}
log_infof(0, STRING_CONST("Caught signal: %s (%d)"), signame, sig);
system_post_event(FOUN
```
<Overlap Ratio: 0.9186351706036745>

---

--- 308 --
Question ID: b43b42ae6e47e648f5126bb9c404d6d8efc4d973_1
Original Code:
```
void *
srp_swap_locked(struct srp *srp, void *nv)
{
	void *ov;

	/*
	 * this doesn't have to be as careful as the caller has already
	 * prevented concurrent updates, eg. by holding the kernel lock.
	 * can't be mixed with non-locked updates though.
	 */

	ov = srp->ref;
	srp->ref = nv;

	return (ov);
}
```


Overlapping Code:
```
swap_locked(struct srp *srp, void *nv)
{
void *ov;
/*
* this doesn't have to be as careful as the caller has already
* prevented concurrent updates, eg. by holding the kernel lock.
* can't be mixed with non-locked updates though.
*/
ov = srp->ref;
sr
```
<Overlap Ratio: 0.8680555555555556>

---

--- 309 --
Question ID: c9a5e613366ed59ce442191b358f3114cf0e3030_0
Original Code:
```
AUTH *
authunixint_create (const char *host, u_int32_t uid, u_int32_t gid,
		    u_int32_t ngroups, const u_int32_t *groups)
{
  char *h = (char *) host;
  authunix_gid_t *gids;
  size_t i;
  AUTH *ret;

  if (ngroups > 16)
    ngroups = 16;
  if (sizeof (gid_t) == 4) {
    authunix_gid_t *gids = (authunix_gid_t *) groups;
    return authunix_create (h, uid, gid, ngroups, gids);
  }

  gids = malloc (ngroups * sizeof (*gids));
  if (!gids)
    return NULL;
  for (i = 0; i < ngroups; i++)
    gids[i] = groups[i];
  ret = authunix_create (h, uid, gid, ngroups, gids);
  free (gids);
  return ret;
}
```


Overlapping Code:
```
authunixint_create (const char *host, u_int32_t uid, u_int32_t gid,
u_int32_t ngroups, const u_int32_t *groups)
{
char *h = (char *) host;
authunix_gid_t *gids;
size_t i;
AUTH *ret;
if (ngroups > 16)
ngroups = 16;
if (sizeof (gid_t) == 4) {
authunix_gid_t *gids = (authunix_gid_t *) groups;
return authunix_create (h, uid, gid, ngroups, gids);
}
gids = malloc (ngroups * sizeof (*gids));
if (!gids)
return NULL;
for (i = 0; i < ngroups; i++)
gids[i] = groups[i];
ret = authunix_create (h, uid, gid, ngroups, gids);
free
```
<Overlap Ratio: 0.9470802919708029>

---

--- 310 --
Question ID: 47807fc5914293bda72f99870b55df2c4dbb57a4_7
Original Code:
```
static void print_entropy(
  bool logo,          // true: prints the logo, false: otherwise 
  MODEL *model,       // the model 
  DATASET *dataset,   // the dataset 
  char *str_space,    // space for printing strand direction 
  FILE *outfile       // stream for output 
)
{
  int i, j;
  int w = model->w;                     // width of motif 
  THETA obs = model->obs;               // observed frequencies 
  double *rentropy = model->rentropy;   // RE of each column 
  double re = w *model->rel;            // motif relative entropy 
  ARRAY_T *back = dataset->back;        // background model 
  char restring[15];                    // print string for re 
  char *consensus;                      // consensus strings 
  double min_freq;                      // minimum background freq 
  double maxre;                         // maximum relative entropy 
  int nsteps;                           // number of steps histogram 

  // get minimum background frequency and maximum relative entropy 
  for (i = 0, min_freq = 1; i < alph_size_core(dataset->alph); i++) {
    if (get_array_item(i, back) < min_freq) min_freq = get_array_item(i, back);
  }
  maxre = -LOG2(min_freq);              // maximum relative entropy 

  // create string containing RE 
  sprintf(restring, "(%.1f bits)", re);

  // print the relative entropy of each column as a bar graph 
  nsteps = 10;
  for (i=0; i<nsteps; i++) {
    double level = maxre - (i * maxre/nsteps);
    fprintf(outfile, (i==0 ? "%*.*s %*.1f " : "%-*.*s %*.1f "), IND, IND,
      (i==0 ? "bits" : i==4 ? "Relative" : i==5 ? "Entropy" :
        i==6 ? restring : ""), IND2, level);
    for (j=0; j<w; j++) {
      if (NINT(nsteps * rentropy[j] / maxre) >= nsteps-i) {
        fputc('*', outfile);
      } else {
        fputc(' ', outfile);
      }
    }
    fputc('\n', outfile);
  }
  fprintf(outfile, "%-*.*s %*.1f ", IND, IND, "", IND2,0.0);
  for (i=0; i<w; i++) fputc('-', outfile);
  fprintf(outfile, "\n\n");
  // get and print the consensus sequences 
  consensus = get_consensus(obs, w, dataset, MAXDEPTH, MINCONS);
  for (i=0; i < MAXDEPTH && i < alph_size_core(dataset->alph); i++) { // print next levels of consensus 
    fprintf(outfile, "%-*.*s %*.0s %*.*s\n", IND, IND,
      (i==0 ? "Multilevel" : i == 1 ? "consensus" : i == 2 ? "sequence" : ""),
      IND2, "", w, w, consensus+(i*w));
  }
  // free up space 
  myfree(consensus);

  // Prints a logo in EPS and PNG format to two files in the output directory 
  if(logo) print_logo(model, dataset);

}
```


Overlapping Code:
```
logo, // true: prints the logo, false: otherwise 
MODEL *model, // the model 
DATASET *dataset, // the dataset 
char *str_space, // space for printing strand direction 
FILE *outfile // stream for output 
)
{
int i, j;
int w = model->w; // width of motif 
THETA obs = model->obs; // observed frequencies 
double *rentropy = model->rentropy; // RE of each column 
double re = w *model->rel; // motif relative entropy 
ARRAY_T *back = dataset->back; // background model 
char restring[15]; // print string for re 
char *consensus; // consensus strings 
double min_freq; // minimum background freq 
double maxre; // maximum relative entropy 
int nsteps; // number of steps histogram 
// get minimum background frequency and maximum relative entropy 
for (i = 0, min_freq = 1; i < alph_size_core(dataset->alph); i++) {
if (get_array_item(i, back) < min_freq) min_freq = get_array_item(i, back);
}
maxre = -LOG2(min_freq); // maximum relative entropy 
// create string containing RE 
sprintf(restring, "(%.1f bits)", re);
// print the relative entropy of each column as a bar graph 
nsteps = 10;
for (i=0; i<nsteps; i++) {
double level = maxre - (i * maxre/nsteps);
fprintf(outfile, (i==0 ? "%*.*s %*.1f " : "%-*.*s %*.1f "), IND, IND,
(i==0 ? "bits" : i==4 ? "Relative" : i==5 ? "Entropy" :
i==6 ? restring : ""), IND2, level);
for (j=0; j<w; j++) {
if (NINT(nsteps * rentropy[j] / maxre) >= nsteps-i) {
fputc('*', outfile);
} else {
fputc(' ', outfile);
}
}
fputc('\n', outfile);
}
fprintf(outfile, "%-*.*s %*.1f ", IND, IND, "", IND2,0.0);
for (i=0; i<w; i++) fputc('-', outfile);
fprintf(outfile, "\n\n");
// get and print the consensus sequences 
consensus = get_consensus(obs, w, dataset, MAXDEPTH, MINCONS);
for (i=0; i < MAXDEPTH && i < alph_size_core(dataset->alph); i++) { // print next levels of consensus 
fprintf(outfile, "%-*.*s %*.0s %*.*s\n", IND, IND,
(i==0 ? "Multilevel" : i == 1 ? "consensus" : i == 2 ? "sequence" : ""),
IND2, "", w, w, consensus+(i*w));
}
// free up space 
myfree(consensus);
// Prints a logo in EPS and PNG format t
```
<Overlap Ratio: 0.9628933771723814>

---

--- 311 --
Question ID: 65257ecbf9adae4994043ee1087a81276aed488d_6
Original Code:
```
double loggam(double x) {
  double x0, x2, xp, gl, gl0;
  RAND_INT_TYPE k, n;

  static double a[10] = {8.333333333333333e-02, -2.777777777777778e-03,
                         7.936507936507937e-04, -5.952380952380952e-04,
                         8.417508417508418e-04, -1.917526917526918e-03,
                         6.410256410256410e-03, -2.955065359477124e-02,
                         1.796443723688307e-01, -1.39243221690590e+00};
  x0 = x;
  n = 0;
  if ((x == 1.0) || (x == 2.0)) {
    return 0.0;
  } else if (x <= 7.0) {
    n = (RAND_INT_TYPE)(7 - x);
    x0 = x + n;
  }
  x2 = 1.0 / (x0 * x0);
  xp = 2 * M_PI;
  gl0 = a[9];
  for (k = 8; k >= 0; k--) {
    gl0 *= x2;
    gl0 += a[k];
  }
  gl = gl0 / x0 + 0.5 * log(xp) + (x0 - 0.5) * log(x0) - x0;
  if (x <= 7.0) {
    for (k = 1; k <= n; k++) {
      gl -= log(x0 - 1.0);
      x0 -= 1.0;
    }
  }
  return gl;
}
```


Overlapping Code:
```
x2, xp, gl, gl0;
RAND_INT_TYPE k, n;
static double a[10] = {8.333333333333333e-02, -2.777777777777778e-03,
7.936507936507937e-04, -5.952380952380952e-04,
8.417508417508418e-04, -1.917526917526918e-03,
6.410256410256410e-03, -2.955065359477124e-02,
1.796443723688307e-01, -1.39243221690590e+00};
x0 = x;
n = 0;
if ((x == 1.0) || (x == 2.0)) {
return 0.0;
} else if (x <= 7.0) {
n = (RAND_INT_TYPE)(7 - x);
x0 = x + n;
}
x2 = 1.0 / (x0 * x0);
xp = 2 * M_PI;
gl0 = a[9];
for (k = 8; k >= 0; k--) {
gl0 *= x2;
gl0 += a[k];
}
gl = gl0 / x0 + 0.5 * log(xp) + (x0 - 0.5) * log(x0) - x0;
if (x <= 7.0) {
for (k = 1; k <= n; k++) {
gl -= log(x0 - 1.0);
x0 -= 1.0;
}
}
return g
```
<Overlap Ratio: 0.942090395480226>

---

--- 312 --
Question ID: ac47a33f24310d56297a1e3a0715997d4d0ea8bf_0
Original Code:
```
S_LOCAL void window_residuals(SRelp *self, SArrayInt *residual,
							  STrackFloat *coefs, uint frame_number, s_erc *error)
{
	float prev_pm;
	float first_pos;
	uint32 j = 0;
	float current_pm = 0.0;
	float period = 0.0;
	uint32 pm_num_frames = coefs->data->row_count;
	sint32 centre_sample = 0;
	sint32 first_sample;
	sint32 last_sample;


	S_CLR_ERR(error);

	/*
	 * estimate first period as pitchmark time itself (i.e. assume a previous
	 * pitchmark at 0.0 time, waveform sample 0)
	 */
	prev_pm = 0.0;


	if (self->symmetric == TRUE)
	{
		if (pm_num_frames < 1)
		{
			S_CTX_ERR(error, S_FAILURE,
					  "window_residuals",
					  "Attempted to window around less than 1 pitchmark");
			return;
		}

		for (j = 0; j < pm_num_frames; j++, frame_number++ )
		{
			current_pm = coefs->time[j];
			period = current_pm - prev_pm;
			centre_sample = (sint32)(current_pm * (float)self->sample_rate + 0.5);
			first_pos = prev_pm - (period * (self->window_factor - 1.0));
			first_sample = (int)(first_pos * (float)self->sample_rate + 0.5);
			last_sample  = (2 * centre_sample) - first_sample;

			self->residuals[frame_number] = S_NEW(SArrayInt, error);
			if (S_CHK_ERR(error, S_CONTERR,
						  "window_residuals",
						  "Failed to create new 'SArrayInt' object"))
				return;

			window_this_residual(self->residuals[frame_number], residual,
								 first_sample, last_sample, self->window,
								 -1, error);
			if (S_CHK_ERR(error, S_CONTERR,
						  "window_residuals",
						  "Call to \"window_this_residual\" failed"))
				return;

			prev_pm = current_pm;
		}
	}
	else
	{
		if (self->pmIndx == NULL)
		{
			S_CTX_ERR(error, S_FAILURE,
					  "window_residuals",
					  "Required pitchmark indices is NULL");
			return;
		}

		if (pm_num_frames < 1)
		{
			S_CTX_ERR(error, S_FAILURE,
					  "window_residuals",
					  "Attempting to window around less than 1 pitchmark");
			return;
		}
		else
		{
			float next_pm;
			float last_pos;

			for (j = 0; j < pm_num_frames - 1; j++, frame_number++)
			{
				current_pm = coefs->time[j];
				period = current_pm - prev_pm;
				centre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);
				first_pos = prev_pm - (period * (self->window_factor - 1.0));
				first_sample = (int)(first_pos * (float)self->sample_rate + 0.5);
				next_pm = coefs->time[j + 1];
				last_pos = next_pm + ((next_pm - current_pm) * (self->window_factor - 1.0));
				last_sample = (int)(last_pos * (float)self->sample_rate + 0.5);

				window_this_residual(self->residuals[frame_number], residual,
									 first_sample, last_sample, self->window,
									 centre_sample, error);
				if (S_CHK_ERR(error, S_CONTERR,
							  "window_residuals",
							  "Call to \"window_this_residual\" failed"))
					return;

				self->pmIndx->i[frame_number] = centre_sample - first_sample;
				prev_pm = current_pm;
			}

			/*
			 * last frame window size is set according to coefs->time[end] and the number
			 * of samples in the waveform (it is presumed the waveform begins at the
			 * preceeding pitchmark and ends at the pitchmark following the current
			 * unit...)
			 */
			current_pm = coefs->time[j];
			centre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);
			first_pos = prev_pm - (period * (self->window_factor - 1.0));
			first_sample = (int)(first_pos * (float)self->sample_rate + 0.5);
			last_sample = residual->count - 1;

			window_this_residual(self->residuals[frame_number], residual,
								 first_sample, last_sample, self->window,
								 -1, error);
			if (S_CHK_ERR(error, S_CONTERR,
						  "window_residuals",
						  "Call to \"window_this_residual\" failed"))
				return;


			self->pmIndx->i[frame_number] = centre_sample - first_sample;
			frame_number++;
		}
	}
}
```


Overlapping Code:
```
OCAL void window_residuals(SRelp *self, SArrayInt *residual,
STrackFloat *coefs, uint frame_number, s_erc *error)
{
float prev_pm;
float first_pos;
uint32 j = 0;
float current_pm = 0.0;
float period = 0.0;
uint32 pm_num_frames = coefs->data->row_count;
sint32 centre_sample = 0;
sint32 first_sample;
sint32 last_sample;
S_CLR_ERR(error);
/*
* estimate first period as pitchmark time itself (i.e. assume a previous
* pitchmark at 0.0 time, waveform sample 0)
*/
prev_pm = 0.0;
if (self->symmetric == TRUE)
{
if (pm_num_frames < 1)
{
S_CTX_ERR(error, S_FAILURE,
"window_residuals",
"Attempted to window around less than 1 pitchmark");
return;
}
for (j = 0; j < pm_num_frames; j++, frame_number++ )
{
current_pm = coefs->time[j];
period = current_pm - prev_pm;
centre_sample = (sint32)(current_pm * (float)self->sample_rate + 0.5);
first_pos = prev_pm - (period * (self->window_factor - 1.0));
first_sample = (int)(first_pos * (float)self->sample_rate + 0.5);
last_sample = (2 * centre_sample) - first_sample;
self->residuals[frame_number] = S_NEW(SArrayInt, error);
if (S_CHK_ERR(error, S_CONTERR,
"window_residuals",
"Failed to create new 'SArrayInt' object"))
return;
window_this_residual(self->residuals[frame_number], residual,
first_sample, last_sample, self->window,
-1, error);
if (S_CHK_ERR(error, S_CONTERR,
"window_residuals",
"Call to \"window_this_residual\" failed"))
return;
prev_pm = current_pm;
}
}
else
{
if (self->pmIndx == NULL)
{
S_CTX_ERR(error, S_FAILURE,
"window_residuals",
"Required pitchmark indices is NULL");
return;
}
if (pm_num_frames < 1)
{
S_CTX_ERR(error, S_FAILURE,
"window_residuals",
"Attempting to window around less than 1 pitchmark");
return;
}
else
{
float next_pm;
float last_pos;
for (j = 0; j < pm_num_frames - 1; j++, frame_number++)
{
current_pm = coefs->time[j];
period = current_pm - prev_pm;
centre_sample = (int)(current_pm * (float)self->sample_rate + 0.5);
first_pos = prev_pm - (period * (self->window_factor - 1.0));
first_sample = (int)(first_pos * (float)self->sample_rate + 0.5);
next_pm = coefs->time[j + 1];
last_pos = next_pm + ((next_pm - current_pm) * (self->window_factor - 1.0));
last_sample = (int)(last_pos * (float)self->sample_rate + 0
```
<Overlap Ratio: 0.9878760664571172>

---

--- 313 --
Question ID: dcc6705495968010febb8e0c802630ce73347883_0
Original Code:
```
unsigned int iterative_ackermann(unsigned int m, unsigned int n) {
    calls++;
    while (m != 0) {
        if (n == 0) {
            n = 1;
        } else {
            n = iterative_ackermann(m, n - 1);
        }
        m--;
    }
    return n + 1;
}
```


Overlapping Code:
```
int m, unsigned int n) {
calls++;
while (m != 0) {
if (n == 0) {
n = 1;
} else {
n = iterative_acker
```
<Overlap Ratio: 0.5494505494505495>

---

--- 314 --
Question ID: da37623915e6c840c38b57c72d9c4d1930b1dfda_3
Original Code:
```
void CLS_CursorModeSet(PmodCLS *InstancePtr, uint8_t setCursor, uint8_t setBlink) {
	uint8_t cursorOff[]			  = {CLS_ESC, CLS_BRACKET, '0', CLS_CURSOR_MODE_CMD};
	uint8_t cursorOnBlinkOff[]    = {CLS_ESC, CLS_BRACKET, '1', CLS_CURSOR_MODE_CMD};
	uint8_t cursorBlinkOn[]       = {CLS_ESC, CLS_BRACKET, '2', CLS_CURSOR_MODE_CMD};
	if (setCursor==0)	{
		//send the command for both display and blink off
		CLS_WriteSpi(InstancePtr, cursorOff, 4);
	}
	else if ((setCursor==1)&&(setBlink==0)) {
		//send the command for display on and blink off
		CLS_WriteSpi(InstancePtr, cursorOnBlinkOff, 4);
	}
		else {
			//send the command for display and blink on
			CLS_WriteSpi(InstancePtr, cursorBlinkOn, 4);
		}
}
```


Overlapping Code:
```
void CLS_CursorModeSet(PmodCLS *InstancePtr, uint8_t setCursor, uint8_t setBlink) {
uint8_t cursorOff[] = {CLS_ESC, CLS_BRACKET, '0', CLS_CURSOR_MODE_CMD};
uint8_t cursorOnBlinkOff[] = {CLS_ESC, CLS_BRACKET, '1', CLS_CURSOR_MODE_CMD};
uint8_t cursorBlinkOn[] = {CLS_ESC, CLS_BRACKET, '2', CLS_CURSOR_MODE_CMD};
if (setCursor==0) {
//send the command for both display and blink off
CLS_WriteSpi(InstancePtr, cursorOff, 4);
}
else if ((setCursor==1)&&(setBlink==0)) {
//send the command for display on and blink off
CLS_WriteSpi(InstancePtr, cursorOnBlinkOff, 4);
}
else {
//send the command for display and blink on
CLS_WriteSpi(InstancePtr, cursorBli
```
<Overlap Ratio: 0.9803921568627451>

---

--- 315 --
Question ID: e5fde638931f6d8597865615d8cb58e356899a60_1
Original Code:
```
int main(int argc, char** argv)
{
    clock_t start = clock();
    int answer = run(argv[1]);
    printf("_duration:%f\n%d\n", (float)( clock () - start ) * 1000.0 /  CLOCKS_PER_SEC, answer);
    return 0;
}
```


Overlapping Code:
```
ain(int argc, char** argv)
{
clock_t start = clock();
int answer = run(argv[1]);
printf("_duration:%f\n%d\n", (float)( clock () - start ) * 1000.0 / CLOCKS_PER_SEC, answer);
return 0;
}
```
<Overlap Ratio: 0.9736842105263158>

---

--- 316 --
Question ID: b18b4bf16db1cfd73b04ed75ba7b2ebf8f24cdf1_2
Original Code:
```
class MaOpenSslConfig : public MaSslConfig {
  public:
	SSL_CTX			*context;
	RSA				*rsaKey512;
	RSA				*rsaKey1024;
	DH				*dhKey512;
	DH				*dhKey1024;

  public:
					MaOpenSslConfig(MaHost *host);
					~MaOpenSslConfig();

	MprSocket 		*newSocket();
	SSL_CTX			*getContext();
	int				start();
	void			stop();
}
```


Overlapping Code:
```
 {
public:
SSL_CTX *context;
RSA *rsaKey512;
RSA *rsaKey1024;
DH *dhKey512;
DH *dhKey1024;
public:
MaOpenSslConfig(MaHost *host);
~MaOpenSslConfig();
MprSocket *newSocket();
SSL_CTX *getContext();
int
```
<Overlap Ratio: 0.7518796992481203>

---

--- 317 --
Question ID: 150a7ce43260e5372adb8749ad4a06c04ca3e068_2
Original Code:
```
static void session_environ()
{
  char* path = strdup(getenv("PATH"));
  *environ = 0;
  setenv("HOME",pw.pw_dir,1);
  setenv("USER",pw.pw_name,1);
  setenv("LOGNAME",pw.pw_name,1);
  setenv("LOGIN",pw.pw_name,1); /*< Historical; only strictly needed on AIX */
  setenv("SHELL", pw.pw_shell[0] ? pw.pw_shell : "/bin/sh",1);
  setenv("PATH",path,1);
  free(path);

#if HAVE_PAM
  pam_export_environ();
#endif
  /* Authentication mechanism other than PAM can also have environment variables
   * to set too, pointing to cached credentials in /tmp, for example. */

#if HAVE_LOGIN_CAP
  /* Note we have already done LOGIN_SETRESOURCES, LOGIN_SETCPUMASK. We have
   * to do them again though after setuid() or the user's personal preferences
   * won't be read in. We had to do them the first time because the daemon
   * might be running under reduced limits and we would need to root to raise
   * the limits back up to the system defaults. */
  if (setusercontext(login_class, &pw, pw.pw_uid,
                     LOGIN_SETUMASK|LOGIN_SETPATH|LOGIN_SETENV|
                     LOGIN_SETRESOURCES|LOGIN_SETCPUMASK) < 0)
    perror("setusercontext(env) failed");
  login_close(login_class); login_class = 0;
#endif

  if (chdir(getenv("HOME")) < 0) perror("chdir($HOME)");
}
```


Overlapping Code:
```
rdup(getenv("PATH"));
*environ = 0;
setenv("HOME",pw.pw_dir,1);
setenv("USER",pw.pw_name,1);
setenv("LOGNAME",pw.pw_name,1);
setenv("LOGIN",pw.pw_name,1); /*< Historical; only strictly needed on AIX */
setenv("SHELL", pw.pw_shell[0] ? pw.pw_shell : "/bin/sh",1);
setenv("PATH",path,1);
free(path);
#if HAVE_PAM
pam_export_environ();
#endif
/* Authentication mechanism other than PAM can also have environment variables
* to set too, pointing to cached credentials in /tmp, for example. */
#if HAVE_LOGIN_CAP
/* Note we have already done LOGIN_SETRESOURCES, LOGIN_SETCPUMASK. We have
* to do them again though after setuid() or the user's personal preferences
* won't be read in. We had to do them the first time because the daemon
* might be running under reduced limits and we would need to root to raise
* the limits back up to the system defaults. */
if (setusercontext(login_class, &pw, pw.pw_uid,
LOGIN_SETUMASK|LOGIN_SETPATH|LOGIN_SETENV|
LOGIN_SETRESOURCES|LOGIN_SETCPUMASK) < 0)
perror("setusercontext(env) failed");
login_close(login_class); login_class = 0;
#endif
if (chdir(getenv("HOME"))
```
<Overlap Ratio: 0.933786078098472>

---

--- 318 --
Question ID: 13c50045383df42b3610780cb834d74d1e7eeb34_0
Original Code:
```
void* USG_allocate(size_t count, size_t size) {
    void* data = calloc(count, size);
    printf("Allocated pointer   @%p; ", data);
    ptrCounter++;
    __drawPtrCount();
    return data;
}
```


Overlapping Code:
```
USG_allocate(size_t count, size_t size) {
void* data = calloc(count, size);
printf("Allocated pointer @%p; ", data);
ptrCounter++;
__drawPtrCount();
r
```
<Overlap Ratio: 0.8875739644970414>

---

--- 319 --
Question ID: 2ea5899817d70ead86f04794d19e7fd67b990f0c_11
Original Code:
```
static void MMC_DecodeExtendedCsd(mmc_card_t *card, uint32_t *rawExtendedCsd)
{
    assert(card);
    assert(rawExtendedCsd);

    uint8_t *buffer = (uint8_t *)rawExtendedCsd;
    mmc_extended_csd_t *extendedCsd = &(card->extendedCsd);

    /* Extended CSD is transferred as a data block from least byte indexed 0. */
    extendedCsd->bootPartitionWP = buffer[173U];
    extendedCsd->bootWPStatus = buffer[174U];
    extendedCsd->highDensityEraseGroupDefinition = buffer[175U];
    extendedCsd->bootDataBusConditions = buffer[177U];
    extendedCsd->bootConfigProtect = buffer[178U];
    extendedCsd->partitionConfig = buffer[179U];
    extendedCsd->eraseMemoryContent = buffer[181U];
    extendedCsd->dataBusWidth = buffer[183U];
    extendedCsd->highSpeedTiming = buffer[185U];
    extendedCsd->powerClass = buffer[187U];
    extendedCsd->commandSetRevision = buffer[189U];
    extendedCsd->commandSet = buffer[191U];
    extendedCsd->extendecCsdVersion = buffer[192U];
    extendedCsd->csdStructureVersion = buffer[194U];
    extendedCsd->partitionAttribute = buffer[156U];
    extendedCsd->extPartitionSupport = buffer[494U];
    extendedCsd->cardType = buffer[196U];
    /* This field define the type of the card. The only currently valid values for this field are 0x01 and 0x03. */
    card->flags |= extendedCsd->cardType;

    extendedCsd->ioDriverStrength = buffer[197U];

    extendedCsd->powerClass52MHz195V = buffer[200U];
    extendedCsd->powerClass26MHz195V = buffer[201U];
    extendedCsd->powerClass52MHz360V = buffer[202U];
    extendedCsd->powerClass26MHz360V = buffer[203U];
    extendedCsd->powerClass200MHZVCCQ130VVCC360V = buffer[236U];
    extendedCsd->powerClass200MHZVCCQ195VVCC360V = buffer[237U];
    extendedCsd->powerClass52MHZDDR195V = buffer[238U];
    extendedCsd->powerClass52MHZDDR360V = buffer[239U];
    extendedCsd->powerClass200MHZDDR360V = buffer[253U];
    extendedCsd->minimumReadPerformance4Bit26MHz = buffer[205U];
    extendedCsd->minimumWritePerformance4Bit26MHz = buffer[206U];
    extendedCsd->minimumReadPerformance8Bit26MHz4Bit52MHz = buffer[207U];
    extendedCsd->minimumWritePerformance8Bit26MHz4Bit52MHz = buffer[208U];
    extendedCsd->minimumReadPerformance8Bit52MHz = buffer[209U];
    extendedCsd->minimumWritePerformance8Bit52MHz = buffer[210U];
    extendedCsd->minReadPerformance8bitAt52MHZDDR = buffer[234U];
    extendedCsd->minWritePerformance8bitAt52MHZDDR = buffer[235U];
    /* Get user partition size. */
    extendedCsd->sectorCount = ((((uint32_t)buffer[215U]) << 24U) + (((uint32_t)buffer[214U]) << 16U) +
                                (((uint32_t)buffer[213U]) << 8U) + (uint32_t)buffer[212U]);
    if (card->flags & kMMC_SupportHighCapacityFlag)
    {
        card->userPartitionBlocks = card->extendedCsd.sectorCount;
    }

    extendedCsd->sleepAwakeTimeout = buffer[217U];
    extendedCsd->sleepCurrentVCCQ = buffer[219U];
    extendedCsd->sleepCurrentVCC = buffer[220U];
    extendedCsd->highCapacityWriteProtectGroupSize = buffer[221U];
    extendedCsd->reliableWriteSectorCount = buffer[222U];
    extendedCsd->highCapacityEraseTimeout = buffer[223U];
    extendedCsd->highCapacityEraseUnitSize = buffer[224U];
    extendedCsd->accessSize = buffer[225U];

    /* Get boot partition size: 128KB * BOOT_SIZE_MULT*/
    card->bootPartitionBlocks = ((128U * 1024U * buffer[226U]) / FSL_SDMMC_DEFAULT_BLOCK_SIZE);

    /* Check if card support boot mode. */
    if (buffer[228U] & 0x1U)
    {
        card->flags |= kMMC_SupportAlternateBootFlag;
    }
    else if (buffer[228U] & 0x2U)
    {
        card->flags |= kMMC_SupportDDRBootFlag;
    }
    else if (buffer[228U] & 0x4U)
    {
        card->flags |= kMMC_SupportHighSpeedBootFlag;
    }
    else
    {
    }
    /* cache size unit 1kb */
    extendedCsd->cacheSize = (((uint32_t)buffer[252U]) << 24) | (((uint32_t)buffer[251U]) << 16) |
                             (((uint32_t)buffer[250U]) << 8) | (((uint32_t)buffer[249U]));

    extendedCsd->supportedCommandSet = buffer[504U];
}
```


Overlapping Code:
```
id MMC_DecodeExtendedCsd(mmc_card_t *card, uint32_t *rawExtendedCsd)
{
assert(card);
assert(rawExtendedCsd);
uint8_t *buffer = (uint8_t *)rawExtendedCsd;
mmc_extended_csd_t *extendedCsd = &(card->extendedCsd);
/* Extended CSD is transferred as a data block from least byte indexed 0. */
extendedCsd->bootPartitionWP = buffer[173U];
extendedCsd->bootWPStatus = buffer[174U];
extendedCsd->highDensityEraseGroupDefinition = buffer[175U];
extendedCsd->bootDataBusConditions = buffer[177U];
extendedCsd->bootConfigProtect = buffer[178U];
extendedCsd->partitionConfig = buffer[179U];
extendedCsd->eraseMemoryContent = buffer[181U];
extendedCsd->dataBusWidth = buffer[183U];
extendedCsd->highSpeedTiming = buffer[185U];
extendedCsd->powerClass = buffer[187U];
extendedCsd->commandSetRevision = buffer[189U];
extendedCsd->commandSet = buffer[191U];
extendedCsd->extendecCsdVersion = buffer[192U];
extendedCsd->csdStructureVersion = buffer[194U];
extendedCsd->partitionAttribute = buffer[156U];
extendedCsd->extPartitionSupport = buffer[494U];
extendedCsd->cardType = buffer[196U];
/* This field define the type of the card. The only currently valid values for this field are 0x01 and 0x03. */
card->flags |= extendedCsd->cardType;
extendedCsd->ioDriverStrength = buffer[197U];
extendedCsd->powerClass52MHz195V = buffer[200U];
extendedCsd->powerClass26MHz195V = buffer[201U];
extendedCsd->powerClass52MHz360V = buffer[202U];
extendedCsd->powerClass26MHz360V = buffer[203U];
extendedCsd->powerClass200MHZVCCQ130VVCC360V = buffer[236U];
extendedCsd->powerClass200MHZVCCQ195VVCC360V = buffer[237U];
extendedCsd->powerClass52MHZDDR195V = buffer[238U];
extendedCsd->powerClass52MHZDDR360V = buffer[239U];
extendedCsd->powerClass200MHZDDR360V = buffer[253U];
extendedCsd->minimumReadPerformance4Bit26MHz = buffer[205U];
extendedCsd->minimumWritePerformance4Bit26MHz = buffer[206U];
extendedCsd->minimumReadPerformance8Bit26MHz4Bit52MHz = buffer[207U];
extendedCsd->minimumWritePerformance8Bit26MHz4Bit52MHz = buffer[208U];
extendedCsd->minimumReadPerformance8Bit52MHz = buffer[209U];
extendedCsd->minimumWritePerformance8Bit52MHz = buffer[210U];
extendedCsd->minReadPerformance8bitAt52MHZDDR = buffer[234U];
extendedCsd->minWritePerformance8bitAt52MHZDDR = buffer[235U];
/* Get user partition size. */
extendedCsd->
```
<Overlap Ratio: 0.9918068132815869>

---

--- 320 --
Question ID: 969b126149b710c2a239ced0b77a191970eab637_0
Original Code:
```
int main(int argc, char **argv) {
  // initialise the Webots API
  wb_robot_init();

  // internal variables
  int i;
  int avoid_obstacle_counter = 0;

  // initialise distance sensors
  WbDeviceTag ds[2];
  char ds_names[2][10] = {"ds_left", "ds_right"};
  for (i = 0; i < 2; i++) {
    ds[i] = wb_robot_get_device(ds_names[i]);
    wb_distance_sensor_enable(ds[i], TIME_STEP);
  }

  // initialise motors
  WbDeviceTag wheels[4];
  char wheels_names[4][8] = {"wheel1", "wheel2", "wheel3", "wheel4"};
  for (i = 0; i < 4; i++) {
    wheels[i] = wb_robot_get_device(wheels_names[i]);
    wb_motor_set_position(wheels[i], INFINITY);
  }

  // feedback loop
  while (wb_robot_step(TIME_STEP) != -1) {
    // init speeds
    double left_speed = 1.0;
    double right_speed = 1.0;

    if (avoid_obstacle_counter > 0) {
      avoid_obstacle_counter--;
      left_speed = 1.0;
      right_speed = -1.0;
    } else {
      // read sensors outputs
      double ds_values[2];
      for (i = 0; i < 2; i++)
        ds_values[i] = wb_distance_sensor_get_value(ds[i]);

      // increase counter in case of obstacle
      if (ds_values[0] < 950.0 || ds_values[1] < 950.0)
        avoid_obstacle_counter = 100;
    }

    // write actuators inputs
    wb_motor_set_velocity(wheels[0], left_speed);
    wb_motor_set_velocity(wheels[1], right_speed);
    wb_motor_set_velocity(wheels[2], left_speed);
    wb_motor_set_velocity(wheels[3], right_speed);
  }

  // cleanup the Webots API
  wb_robot_cleanup();
  return 0;  // EXIT_SUCCESS
}
```


Overlapping Code:
```
nt argc, char **argv) {
// initialise the Webots API
wb_robot_init();
// internal variables
int i;
int avoid_obstacle_counter = 0;
// initialise distance sensors
WbDeviceTag ds[2];
char ds_names[2][10] = {"ds_left", "ds_right"};
for (i = 0; i < 2; i++) {
ds[i] = wb_robot_get_device(ds_names[i]);
wb_distance_sensor_enable(ds[i], TIME_STEP);
}
// initialise motors
WbDeviceTag wheels[4];
char wheels_names[4][8] = {"wheel1", "wheel2", "wheel3", "wheel4"};
for (i = 0; i < 4; i++) {
wheels[i] = wb_robot_get_device(wheels_names[i]);
wb_motor_set_position(wheels[i], INFINITY);
}
// feedback loop
while (wb_robot_step(TIME_STEP) != -1) {
// init speeds
double left_speed = 1.0;
double right_speed = 1.0;
if (avoid_obstacle_counter > 0) {
avoid_obstacle_counter--;
left_speed = 1.0;
right_speed = -1.0;
} else {
// read sensors outputs
double ds_values[2];
for (i = 0; i < 2; i++)
ds_values[i] = wb_distance_sensor_get_value(ds[i]);
// increase counter in case of obstacle
if (ds_values[0] < 950.0 || ds_values[1] < 950.0)
avoid_obstacle_counter = 100;
}
// write actuators inputs
wb_motor_set_velocity(wheels[0], left_speed);
wb_motor_set_velocity(wheels[1], right_speed);
wb_motor_set_velocity(wheels[2], left_speed);
wb_motor_set_velocity(wheels[3], right_speed);
}
// cleanup the Webots API
wb_robot_cleanup();
return 0; //
```
<Overlap Ratio: 0.9814677538917717>

---

--- 321 --
Question ID: af727fd160b612d22a4b7034bbfff3981cbde824_19
Original Code:
```
STREAM* fastpath_input_pdu_init(rdpFastPath* fastpath, BYTE eventFlags, BYTE eventCode)
{
	rdpRdp *rdp;
	STREAM* s;

	rdp = fastpath->rdp;

	s = transport_send_stream_init(rdp->transport, 256);
	stream_seek(s, 3); /* fpInputHeader, length1 and length2 */
	if (rdp->do_crypt) {
		rdp->sec_flags |= SEC_ENCRYPT;
		if (rdp->do_secure_checksum)
			rdp->sec_flags |= SEC_SECURE_CHECKSUM;
	}
	stream_seek(s, fastpath_get_sec_bytes(rdp));
	stream_write_BYTE(s, eventFlags | (eventCode << 5)); /* eventHeader (1 byte) */
	return s;
}
```


Overlapping Code:
```
h_input_pdu_init(rdpFastPath* fastpath, BYTE eventFlags, BYTE eventCode)
{
rdpRdp *rdp;
STREAM* s;
rdp = fastpath->rdp;
s = transport_send_stream_init(rdp->transport, 256);
stream_seek(s, 3); /* fpInputHeader, length1 and length2 */
if (rdp->do_crypt) {
rdp->sec_flags |= SEC_ENCRYPT;
if (rdp->do_secure_checksum)
rdp->sec_flags |= SEC_SECURE_CHECKSUM;
}
stream_seek(s, fastpath_get_sec_bytes(rdp));
stream_write_BYTE(s, eventFlags | (eventCode << 5)); /* eventHeader (1 byte) */
return s
```
<Overlap Ratio: 0.9644268774703557>

---

--- 322 --
Question ID: 275b9425d8984fb9f24b28d4e13c1d0b913511e9_0
Original Code:
```
class PKeySummary
{
public:
    PKeySummary(std::string addr);
    ~PKeySummary();
    
    std::string GetAddress();
    SKeyTransactionMap GetTransactions();
    SKeyTransactionMap GetUnspent();
    Value GetBalance(int min_confirm=0, bool using_retain = true);
    size_t GetMemoryUsage();
    bool CanBeRemoved();
    unsigned int LoadedBlocks();
    
protected:
    void Using();
    void ImportBlock(CBlock block, CBlockIndex *index);
    
    std::string strAddress;
    unsigned int used_time;
    unsigned int loaded_blocks;
    
    SKeyTransactionMap transactions;
    SKeyTransactionMap unspent;
    size_t cache_balance;
}
```


Overlapping Code:
```
Summary
{
public:
PKeySummary(std::string addr);
~PKeySummary();

std::string GetAddress();
SKeyTransactionMap GetTransactions();
SKeyTransactionMap GetUnspent();
Value GetBalance(int min_confirm=0, bool using_retain = true);
size_t GetMemoryUsage();
bool CanBeRemoved();
unsigned int LoadedBlocks();

protected:
void Using();
void ImportBlock(CBlock block, CBlockIndex *index);

std::string strAddress;
unsigned int used_time;
unsigned int loaded_blocks;

SKeyTransactionMap transactions;
SKeyTransa
```
<Overlap Ratio: 0.9074410163339383>

---

--- 323 --
Question ID: 527f8d14412d17bcc8f560cc68adc228808d38c4_4
Original Code:
```
static void obd_comm_thread_fn(
        const seL4_CPtr ep_cap)
{
    int err;
    seL4_Word badge;
    uint64_t timestamp;
    hobd_stats_s stats = {0};

    /* wait for system ready */
    system_module_wait_for_start();

    /* create a timeout id */
    time_server_alloc_id(&g_comm.timeout_id);

    /* initialize the HOBD parser */
    hobd_parser_init(
            &g_msg_rx_buffer[0],
            sizeof(g_msg_rx_buffer),
            &g_msg_parser);

    /* TODO - disable char dev ? */

    /* initialize UART TX GPIO */
    err = gpio_new(
            &g_comm.gpio_sys,
            GPIOID(UART_TX_PORT, UART_TX_PIN),
            GPIO_DIR_OUT,
            &g_comm.gpio_uart_tx);
    ZF_LOGF_IF(err != 0, "Failed to initialize GPIO port/pin");

    /* reconfigure the serial port if starting in listen-only mode */
    if(g_comm.listen_only != 0)
    {
        err = serial_configure(
                &g_comm.char_dev,
                HOBD_KLINE_BAUD,
                8,
                PARITY_NONE,
                1);
        ZF_LOGF_IF(err != 0, "Failed to configure serial port");
    }

    MODLOGD(HOBDMOD_THREAD_NAME " thread is running");

    g_comm.state = COMM_STATE_GPIO_INIT;

    while(1)
    {
        seL4_MessageInfo_t info = {0};

        if(g_comm.enabled != 0)
        {
            if(g_comm.listen_only == 0)
            {
                /* update comms and perform a non-blocking EP recv if enabled */
                comm_update_state(&stats);
            }
            else
            {
                /* log any messages seen on the k-line */
                const hobd_msg_s * const hobd_msg = comm_recv_msg(
                        1,
                        &g_msg_parser,
                        &g_comm);

                if(hobd_msg != NULL)
                {
                    time_server_get_time(&timestamp);
                    new_hobd_msg_callback(hobd_msg, &timestamp);
                }
            }

            info = seL4_NBRecv(
                    ep_cap,
                    &badge);
        }
        else
        {
            /* otherwise just wait on the EP since comms are disabled */
            info = seL4_Recv(
                    ep_cap,
                    &badge);
        }

        const seL4_Word msg_label = seL4_MessageInfo_get_label(info);

        if((badge != 0) && (msg_label != 0))
        {
            ZF_LOGF_IF(badge != ENDPOINT_BADGE, "Invalid IPC badge %u", badge);

            if(msg_label == IPC_MSG_TYPE_STATS_REQ)
            {
                time_server_get_time(&stats.timestamp);

                stats.valid_rx_count = g_msg_parser.valid_count;
                stats.invalid_rx_count = g_msg_parser.invalid_count;

                const uint32_t resp_size_words = sizeof(stats) / sizeof(seL4_Word);

                const seL4_MessageInfo_t resp_info =
                        seL4_MessageInfo_new(
                            IPC_MSG_TYPE_STATS_RESP,
                            0,
                            0,
                            resp_size_words);

                sel4_mr_send(resp_size_words, (uint32_t*) &stats, g_thread.ipc_buffer);

                seL4_Reply(resp_info);
            }
            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_REQ)
            {
                const seL4_MessageInfo_t resp_info =
                        seL4_MessageInfo_new(
                            IPC_MSG_TYPE_COMM_STATE_RESP,
                            0,
                            0,
                            1);

                seL4_SetMR(0, (seL4_Word) g_comm.enabled);
                seL4_Reply(resp_info);
            }
            else if(msg_label == IPC_MSG_TYPE_COMM_STATE_SET_REQ)
            {
                const seL4_MessageInfo_t resp_info =
                        seL4_MessageInfo_new(
                            IPC_MSG_TYPE_COMM_STATE_RESP,
                            0,
                            0,
                            1);

                const uint32_t desired_state = seL4_GetMR(0);

                if(desired_state == 0)
                {
                    g_comm.enabled = 0;
                }
                else
                {
                    g_comm.enabled = 1;
                }

                hobd_parser_reset(&g_msg_parser);
                g_comm.state = COMM_STATE_GPIO_INIT;

                seL4_SetMR(0, (seL4_Word) g_comm.enabled);
                seL4_Reply(resp_info);
            }
            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_REQ)
            {
                const seL4_MessageInfo_t resp_info =
                        seL4_MessageInfo_new(
                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,
                            0,
                            0,
                            1);

                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);
                seL4_Reply(resp_info);
            }
            else if(msg_label == IPC_MSG_TYPE_LISTEN_ONLY_SET_REQ)
            {
                const seL4_MessageInfo_t resp_info =
                        seL4_MessageInfo_new(
                            IPC_MSG_TYPE_LISTEN_ONLY_RESP,
                            0,
                            0,
                            1);

                const uint32_t desired_state = seL4_GetMR(0);

                if(desired_state == 0)
                {
                    g_comm.listen_only = 0;
                }
                else
                {
                    g_comm.listen_only = 1;
                }

                hobd_parser_reset(&g_msg_parser);
                g_comm.state = COMM_STATE_GPIO_INIT;

                seL4_SetMR(0, (seL4_Word) g_comm.listen_only);
                seL4_Reply(resp_info);
            }
            else
            {
                ZF_LOGF("Invalid message label");
            }
        }
    }

    /* should not get here, intentional halt */
    seL4_DebugHalt();
}
```


Overlapping Code:
```
void obd_comm_thread_fn(
const seL4_CPtr ep_cap)
{
int err;
seL4_Word badge;
uint64_t timestamp;
hobd_stats_s stats = {0};
/* wait for system ready */
system_module_wait_for_start();
/* create a timeout id */
time_server_alloc_id(&g_comm.timeout_id);
/* initialize the HOBD parser */
hobd_parser_init(
&g_msg_rx_buffer[0],
sizeof(g_msg_rx_buffer),
&g_msg_parser);
/* TODO - disable char dev ? */
/* initialize UART TX GPIO */
err = gpio_new(
&g_comm.gpio_sys,
GPIOID(UART_TX_PORT, UART_TX_PIN),
GPIO_DIR_OUT,
&g_comm.gpio_uart_tx);
ZF_LOGF_IF(err != 0, "Failed to initialize GPIO port/pin");
/* reconfigure the serial port if starting in listen-only mode */
if(g_comm.listen_only != 0)
{
err = serial_configure(
&g_comm.char_dev,
HOBD_KLINE_BAUD,
8,
PARITY_NONE,
1);
ZF_LOGF_IF(err != 0, "Failed to configure serial port");
}
MODLOGD(HOBDMOD_THREAD_NAME " thread is running");
g_comm.state = COMM_STATE_GPIO_INIT;
while(1)
{
seL4_MessageInfo_t info = {0};
if(g_comm.enabled != 0)
{
if(g_comm.listen_only == 0)
{
/* update comms and perform a non-blocking EP recv if enabled */
comm_update_state(&stats);
}
else
{
/* log any messages seen on the k-line */
const hobd_msg_s * const hobd_msg = comm_recv_msg(
1,
&g_msg_parser,
&g_comm);
if(hobd_msg != NULL)
{
time_server_get_time(&timestamp);
new_hobd_msg_callback(hobd_msg, &timestamp);
}
}
info = seL4_NBRecv(
ep_cap,
&badge);
}
else
{
/* otherwise just wait on the EP since comms are disabled */
info = seL4_Recv(
ep_cap,
&badge);
}
const seL4_Word msg_label = seL4_MessageInfo_get_label(info);
if((badge != 0) && (msg_label != 0))
{
ZF_LOGF_IF(badge != ENDPOINT_BADGE, "Invalid IPC badge %u", badge
```
<Overlap Ratio: 0.975177304964539>

---

--- 324 --
Question ID: cfa13b41f8e45e5401e221ba41f3b5a9aecbdca4_24
Original Code:
```
static void 
select_point(const limb idx, unsigned int size, const felem pre_comp[ /* size */ ][3],
    felem out[3])
{
	unsigned i, j;
	limb *outlimbs = &out[0][0];
	memset(outlimbs, 0, 3 * sizeof(felem));

	for (i = 0; i < size; i++) {
		const limb *inlimbs = &pre_comp[i][0][0];
		limb mask = i ^ idx;
		mask |= mask >> 4;
		mask |= mask >> 2;
		mask |= mask >> 1;
		mask &= 1;
		mask--;
		for (j = 0; j < NLIMBS * 3; j++)
			outlimbs[j] |= inlimbs[j] & mask;
	}
}
```


Overlapping Code:
```
ect_point(const limb idx, unsigned int size, const felem pre_comp[ /* size */ ][3],
felem out[3])
{
unsigned i, j;
limb *outlimbs = &out[0][0];
memset(outlimbs, 0, 3 * sizeof(felem));
for (i = 0; i < size; i++) {
const limb *inlimbs = &pre_comp[i][0][0];
limb mask = i ^ idx;
mask |= mask >> 4;
mask |= mask >> 2;
mask |= mask >> 1;
mask &= 1;
mask--;
for (j = 0; j < NLIMBS * 3; j++)
outlimbs[j] |= 
```
<Overlap Ratio: 0.91324200913242>

---

--- 325 --
Question ID: 2b01b8817817b7912ac39cbd76e17dbb7242e9af_87
Original Code:
```
static void __deepcopy_hostent_from_compat(struct hostent *fat , struct hostent *compat ) 
{ int num_addrs ;
  int i ;
  char **p ;

  {
  fat->h_name = __mkptr_string((char *)compat->h_name);
  fat->h_aliases = __deepcopy_stringarray_from_compat((char **)compat->h_aliases);
  p = (char **)compat->h_addr_list;
  num_addrs = 0;
  while ((unsigned int )(*p) != (unsigned int )((char *)0)) {
    p = (char **)__trusted_cast((void *)((unsigned long )p +
                                                                                                   (unsigned long )(1 *
                                                                                                                    sizeof((*p)))));
    num_addrs ++;
  }
  num_addrs ++;
  fat->h_addr_list = (char **)wrapperAlloc((unsigned int )num_addrs * sizeof((*(fat->h_addr_list +
                                                                                0))));
  i = 0;
  while (i < num_addrs) {
    p = (char **)__trusted_cast((void *)((unsigned long )compat->h_addr_list +
                                                                                                   (unsigned long )((unsigned int )i *
                                                                                                                    sizeof((*(compat->h_addr_list))))));
    (*(fat->h_addr_list + i)) = (char *)__mkptr_size((void *)(*p),
                                                     (unsigned int )compat->h_length);
    i ++;
  }
  return;
}
}
```


Overlapping Code:
```
ostent_from_compat(struct hostent *fat , struct hostent *compat ) 
{ int num_addrs ;
int i ;
char **p ;
{
fat->h_name = __mkptr_string((char *)compat->h_name);
fat->h_aliases = __deepcopy_stringarray_from_compat((char **)compat->h_aliases);
p = (char **)compat->h_addr_list;
num_addrs = 0;
while ((unsigned int )(*p) != (unsigned int )((char *)0)) {
p = (char **)__trusted_cast((void *)((unsigned long )p +
(unsigned long )(1 *
sizeof((*p)))));
num_addrs ++;
}
num_addrs ++;
fat->h_addr_list = (char **)wrapperAlloc((unsigned int )num_addrs * sizeof((*(fat->h_addr_list +
0))));
i = 0;
while (i < num_addrs) {
p = (char **)__trusted_cast((void *)((unsigned long )compat->h_addr_list +
(unsigned long )((unsigned int )i *
sizeof((*(compat->h_addr_list))))));
(*(fat->h_addr_list + i)) = (char *)__mkptr_size((void *)(*p),
(unsigned int )compat->h_leng
```
<Overlap Ratio: 0.9465478841870824>

---

--- 326 --
Question ID: a2cf3f76c677ee88c27ec9a88eb65f2f825cc0dc_35
Original Code:
```
static int do_if_print(struct interface *ife, void *cookie)
{
	int *opt_a = (int *) cookie;
	int res;

	res = do_if_fetch(ife);
	if (res >= 0) {
		if ((ife->flags & IFF_UP) || *opt_a)
			ife_print(ife);
	}
	return res;
}
```


Overlapping Code:
```
tatic int do_if_print(struct interface *ife, void *cookie)
{
int *opt_a = (int *) cookie;
int res;
res = do_if_fetch(ife);
if (res >= 0) {
if ((ife->flags & IFF_UP) || *opt_a)
ife_print(ife);
}
return
```
<Overlap Ratio: 0.9615384615384616>

---

--- 327 --
Question ID: 681cd3f21e53755bc963dddeeb27bfc97473439b_0
Original Code:
```
void HAL_MspInit (void)
{
  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority (PendSV_IRQn, 15, 0);
}
```


Overlapping Code:
```
L_MspInit (void)
{
__HAL_RCC_SYSCFG_CLK_ENABLE();
__HAL_RCC_PWR_CLK_ENABLE();
/* System interrupt init*/
/* PendSV_IRQn interrupt configuration */
HAL_NVIC_SetPriority
```
<Overlap Ratio: 0.8434343434343434>

---

--- 328 --
Question ID: 3206a0692bb9456db2df1dc5b5733dc52c3ac2fe_28
Original Code:
```
static int php_snmp_write_exceptions_enabled(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)
{
	zval ztmp;
	int ret = SUCCESS;
	if (Z_TYPE_P(newval) != IS_LONG) {
		ztmp = *newval;
		zval_copy_ctor(&ztmp);
		convert_to_long(&ztmp);
		newval = &ztmp;
	}

	snmp_object->exceptions_enabled = Z_LVAL_P(newval);	

	if (newval == &ztmp) {
		zval_dtor(newval);
	}
	return ret;
}
```


Overlapping Code:
```
_exceptions_enabled(php_snmp_object *snmp_object, zval *newval TSRMLS_DC)
{
zval ztmp;
int ret = SUCCESS;
if (Z_TYPE_P(newval) != IS_LONG) {
ztmp = *newval;
zval_copy_ctor(&ztmp);
convert_to_long(&ztmp);
newval = &ztmp;
}
snmp_object->exceptions_enabled = Z_LVAL_P(newval); 
if (newval == &ztmp) {
zval_dtor(newval);
}
return ret;
}
```
<Overlap Ratio: 0.9299719887955182>

---

--- 329 --
Question ID: 22128d928e028100b70449ebf5787f50148970eb_2
Original Code:
```
static void post_drive_status(const struct drive_status *stat)
{
	if (!shm)
		return;

	struct timespec now;
	clock_gettime(CLOCK_MONOTONIC, &now);
	limiter_tag = stat->velocityLimiterTag;

	pthread_mutex_lock(&shm->stat_lock);
	shm->stat_time = now;
	shm->stat = *stat;
	pthread_cond_signal(&shm->stat_cond);
	pthread_mutex_unlock(&shm->stat_lock);
}
```


Overlapping Code:
```
s(const struct drive_status *stat)
{
if (!shm)
return;
struct timespec now;
clock_gettime(CLOCK_MONOTONIC, &now);
limiter_tag = stat->velocityLimiterTag;
pthread_mutex_lock(&shm->stat_lock);
shm->stat_time = now;
shm->stat = *stat;
pthread_cond_signal(&shm->stat_cond);
pthread_mutex_unlock(&shm->sta
```
<Overlap Ratio: 0.8875739644970414>

---

--- 330 --
Question ID: c70847b21b86440e1c12f4aa8ee6c48596cf6145_3
Original Code:
```
static void
resizeDamageRectangle(CompScreen *s,
                      BoxPtr pBox)
{
   REGION reg;

   reg.rects = &reg.extents;
   reg.numRects = 1;

   reg.extents = *pBox;

   reg.extents.x1 -= 1;
   reg.extents.y1 -= 1;
   reg.extents.x2 += 1;
   reg.extents.y2 += 1;

   damageScreenRegion(s, &reg);
}
```


Overlapping Code:
```
 *s,
BoxPtr pBox)
{
REGION reg;
reg.rects = &reg.extents;
reg.numRects = 1;
reg.extents = *pBox;
reg.extents.x1 -= 1;
reg.extents.y1 -= 1;
reg.extents.x2 += 1;
reg.extents.y2 += 1;
damageScreenRegion(
```
<Overlap Ratio: 0.7843137254901961>

---

--- 331 --
Question ID: 796c3d77ce18291a13bc00e8da5f5fb41faa34cc_59
Original Code:
```
void
pms_proc_elantech_v4(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	struct device *sc_wsmousedev = sc->sc_wsmousedev;
	int id, weight, n, x, y, z;
	u_int buttons, slots;

	switch (sc->packet[3] & 0x1f) {
	case ELANTECH_V4_PKT_STATUS:
		slots = elantech->mt_slots;
		elantech->mt_slots = sc->packet[1] & 0x1f;
		slots &= ~elantech->mt_slots;
		for (id = 0; slots; id++, slots >>= 1) {
			if (slots & 1)
				wsmouse_mtstate(sc_wsmousedev, id, 0, 0, 0);
		}
		break;

	case ELANTECH_V4_PKT_HEAD:
		id = ((sc->packet[3] & 0xe0) >> 5) - 1;
		if (id > -1 && id < ELANTECH_MAX_FINGERS) {
			x = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];
			y = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];
			z = (sc->packet[1] & 0xf0)
			    | ((sc->packet[4] & 0xf0) >> 4);
			wsmouse_mtstate(sc_wsmousedev, id, x, y, z);
		}
		break;

	case ELANTECH_V4_PKT_MOTION:
		weight = (sc->packet[0] & 0x10) ? ELANTECH_V4_WEIGHT_VALUE : 1;
		for (n = 0; n < 6; n += 3) {
			id = ((sc->packet[n] & 0xe0) >> 5) - 1;
			if (id < 0 || id >= ELANTECH_MAX_FINGERS)
				continue;
			x = weight * (signed char)sc->packet[n + 1];
			y = weight * (signed char)sc->packet[n + 2];
			z = WSMOUSE_DEFAULT_PRESSURE;
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_X, x, id);
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_Y, y, id);
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_PRESSURE, z, id);
		}

		break;

	default:
		printf("%s: unknown packet type 0x%x\n", DEVNAME(sc),
		    sc->packet[3] & 0x1f);
		return;
	}

	buttons = 0;
	if (sc->packet[0] & 0x01)
		buttons |= WSMOUSE_BUTTON(1);
	if (sc->packet[0] & 0x02)
		buttons |= WSMOUSE_BUTTON(3);
	wsmouse_buttons(sc_wsmousedev, buttons);

	wsmouse_input_sync(sc_wsmousedev);
}
```


Overlapping Code:
```
(struct pms_softc *sc)
{
struct elantech_softc *elantech = sc->elantech;
struct device *sc_wsmousedev = sc->sc_wsmousedev;
int id, weight, n, x, y, z;
u_int buttons, slots;
switch (sc->packet[3] & 0x1f) {
case ELANTECH_V4_PKT_STATUS:
slots = elantech->mt_slots;
elantech->mt_slots = sc->packet[1] & 0x1f;
slots &= ~elantech->mt_slots;
for (id = 0; slots; id++, slots >>= 1) {
if (slots & 1)
wsmouse_mtstate(sc_wsmousedev, id, 0, 0, 0);
}
break;
case ELANTECH_V4_PKT_HEAD:
id = ((sc->packet[3] & 0xe0) >> 5) - 1;
if (id > -1 && id < ELANTECH_MAX_FINGERS) {
x = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];
y = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];
z = (sc->packet[1] & 0xf0)
| ((sc->packet[4] & 0xf0) >> 4);
wsmouse_mtstate(sc_wsmousedev, id, x, y, z);
}
break;
case ELANTECH_V4_PKT_MOTION:
weight = (sc->packet[0] & 0x10) ? ELANTECH_V4_WEIGHT_VALUE : 1;
for (n = 0; n < 6; n += 3) {
id = ((sc->packet[n] & 0xe0) >> 5) - 1;
if (id < 0 || id >= ELANTECH_MAX_FINGERS)
continue;
x = weight * (signed char)sc->packet[n + 1];
y = weight * (signed char)sc->packet[n + 2];
z = WSMOUSE_DEFAULT_PRESSURE;
wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_X, x, id);
wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_Y, y, id);
wsmouse_set(sc_wsmousedev, WSMOUSE_MT_PRESSURE, z, id);
}
break;
default:
printf("%s: unknown packet type 0x%x\n", DEVNAME(sc),
sc->packet[3] & 0x1f);
return;
}
buttons = 0;
if (sc->packet[0] & 0x01)
buttons |= WSMOUSE_BUTTON(1);
if (sc->packet[0] & 0x02)
buttons |= WSMOUSE_BUTTON(3);
wsmouse_buttons(sc_wsmousedev, buttons);
wsmouse_input_sync(sc_wsmous
```
<Overlap Ratio: 0.979375>

---

--- 332 --
Question ID: acf2df8bea9358e1c836abacb2d58910c72daab9_13
Original Code:
```
void vf_define(int code, FILE * vffile)
{
    int i, len, lenm;

    vffont.k = read_n(vffile, code - FNT_DEF_1 + 1);
    vffont.c = read_n(vffile,4);
    vffont.s = read_long(vffile);
    vffont.d = read_long(vffile);
    vffont.a = read_byte(vffile);
    vffont.l = read_byte(vffile);

    if (vffont.a == EOF || vffont.l == EOF) {
        fprintf(stderr, "Bad VF file\n");
        exit(252);
    }
    vffont.n = read_str(vffile, vffont.a + vffont.l);
}
```


Overlapping Code:
```
void vf_define(int code, FILE * vffile)
{
int i, len, lenm;
vffont.k = read_n(vffile, code - FNT_DEF_1 + 1);
vffont.c = read_n(vffile,4);
vffont.s = read_long(vffile);
vffont.d = read_long(vffile);
vffont.a = read_byte(vffile);
vffont.l = read_byte(vffile);
if (vffont.a == EOF || vffont.l == EOF) {
fprintf(stderr, "Bad VF file\n");
exit(252);
}
vff
```
<Overlap Ratio: 0.8793969849246231>

---

--- 333 --
Question ID: 816a9b75073572839f53473a55caeeb7274b7743_0
Original Code:
```
void create()
{
        set_name("水笙", ({ "shui sheng","shuisheng"}));
        set("long", "她輕粧淡抹，眉目之中深深的透露哀思。\n");
        set("gender", "女性");
        set("age", 22);
        set("attitude", "peaceful");
        set("shen_type", 1);
        set("per", 25);

        setup();
        carry_object("/clone/cloth/cloth.c")->wear();
}
```


Overlapping Code:
```
粧淡抹，眉目之中深深的透露哀思。\n");
set("gender", "女性");
set("age", 22);
set("attitude", "peaceful");
set("shen_type", 1);
set("per", 25);
setup();
carry_object("/clone/cloth/cloth.c")->wear(
```
<Overlap Ratio: 0.6833976833976834>

---

--- 334 --
Question ID: 72562686cc1134ca6fd4dc5037c01d3cb1c86533_5
Original Code:
```
int
isic_attach_itkix1(device_t dev)
{
	size_t unit = device_get_unit(dev);	/* get unit */
	struct l1_softc *sc = &l1_sc[unit];
	bus_space_tag_t    t = rman_get_bustag(sc->sc_resources.io_base[0]); 
	bus_space_handle_t h = rman_get_bushandle(sc->sc_resources.io_base[0]);

	/* setup access routines */
	sc->clearirq = NULL;
	sc->readreg = itkix1_read_reg;
	sc->writereg = itkix1_write_reg;
	sc->readfifo = itkix1_read_fifo;
	sc->writefifo = itkix1_write_fifo;

	/* setup card type */	
	sc->sc_cardtyp = CARD_TYPEP_ITKIX1;

	/* setup IOM bus type */
	sc->sc_bustyp = BUS_TYPE_IOM2;

	sc->sc_ipac = 0;
	sc->sc_bfifolen = HSCX_FIFO_LEN;

	bus_space_write_1(t, h, ITK_CONFIG, 1);
	DELAY(SEC_DELAY / 10);
	bus_space_write_1(t, h, ITK_CONFIG, 0);
	DELAY(SEC_DELAY / 10);

	return 0;
}
```


Overlapping Code:
```
 dev)
{
size_t unit = device_get_unit(dev); /* get unit */
struct l1_softc *sc = &l1_sc[unit];
bus_space_tag_t t = rman_get_bustag(sc->sc_resources.io_base[0]); 
bus_space_handle_t h = rman_get_bushandle(sc->sc_resources.io_base[0]);
/* setup access routines */
sc->clearirq = NULL;
sc->readreg = itkix1_read_reg;
sc->writereg = itkix1_write_reg;
sc->readfifo = itkix1_read_fifo;
sc->writefifo = itkix1_write_fifo;
/* setup card type */ 
sc->sc_cardtyp = CARD_TYPEP_ITKIX1;
/* setup IOM bus type */
sc->sc_bustyp = BUS_TYPE_IOM2;
sc->sc_ipac = 0;
sc->sc_bfifolen = HSCX_FIFO_LEN;
bus_space_write_1(t, h, ITK_CONFIG, 1);
DELAY(SEC_DELAY / 10);
bus_space_write_1(t, h, ITK_CONFIG, 0);
DELAY(SEC_DELAY / 
```
<Overlap Ratio: 0.9371657754010695>

---

--- 335 --
Question ID: ebdb49a6cffa0ebfe8908bf7815a1da35edab563_0
Original Code:
```
char* intToCharString(int num) {
    char* str = malloc(sizeof(char) * 3);
    // sprintf(str, "%d", num);
    // convert 123 to string [buf]
    itoa(num, str, 10);
    return str;
}
```


Overlapping Code:
```

char* str = malloc(sizeof(char) * 3);
// sprintf(str, "%d", num);
// convert 123 to string [buf]
it
```
<Overlap Ratio: 0.6134969325153374>

---

--- 336 --
Question ID: ab84b50b1c878dd3c0470f908412e7f30edf830a_21
Original Code:
```
static int irq_handler(void * private_data, uint32_t vec_index) {
    struct host_pci_state * state = (struct host_pci_state *)private_data;
    struct v3_irq vec;

    vec.irq = vec_index;
    vec.ack = irq_ack;
    vec.private_data = state;

    // For selective privilege, the interrupt is always delivered
    // identically to the regular case, regardless of the current
    // privilege level.  The idea here is that delivery of the
    // interrupt will result in a dispatch to the privileged guest code
    // and the entry to that code will enable privilege before any
    // mapped bar is read or written.

    PrintDebug(0, 0,"Host PCI / Selective Privilege: Delivering vec irq %d, state %d\n", vec.irq, (int)(state->pci_dev->irq_type));
    if (state->pci_dev->irq_type == IRQ_NONE) {
	return 0;
    } else if (state->pci_dev->irq_type == IRQ_INTX) {
	v3_pci_raise_acked_irq(state->pci_bus, state->pci_dev, vec);
    } else {
	v3_pci_raise_irq(state->pci_bus, state->pci_dev, vec_index);
    }

    return 0;
}
```


Overlapping Code:
```
void * private_data, uint32_t vec_index) {
struct host_pci_state * state = (struct host_pci_state *)private_data;
struct v3_irq vec;
vec.irq = vec_index;
vec.ack = irq_ack;
vec.private_data = state;
// For selective privilege, the interrupt is always delivered
// identically to the regular case, regardless of the current
// privilege level. The idea here is that delivery of the
// interrupt will result in a dispatch to the privileged guest code
// and the entry to that code will enable privilege before any
// mapped bar is read or written.
PrintDebug(0, 0,"Host PCI / Selective Privilege: Delivering vec irq %d, state %d\n", vec.irq, (int)(state->pci_dev->irq_type));
if (state->pci_dev->irq_type == IRQ_NONE) {
return 0;
} else if (state->pci_dev->irq_type == IRQ_INTX) {
v3_pci_raise_acked_irq(state->pci_bus, state->pci_dev, vec);
} else {
v3_pci_raise_irq(state->pci_bus, state->pci_dev, vec_index);
}
r
```
<Overlap Ratio: 0.9651162790697675>

---

--- 337 --
Question ID: 30f108ae45b893375ac26a2b4135a6b379c2aca2_10
Original Code:
```
void
filt_hotplugrdetach(struct knote *kn)
{
	int s;

	s = splbio();
	SLIST_REMOVE(&hotplug_sel.si_note, kn, knote, kn_selnext);
	splx(s);
}
```


Overlapping Code:
```
d
filt_hotplugrdetach(struct knote *kn)
{
int s;
s = splbio();
SLIST_REMOVE(&hotplug_sel.si_note, kn
```
<Overlap Ratio: 0.7407407407407407>

---

--- 338 --
Question ID: e8fadba2a92f6d8b97145ccaaaeda3cec7b9689b_2
Original Code:
```
int main(int argc, char **argv)
{
	blk_t	blocks;
	int	retval;
	
	if (argc < 2) {
		fprintf(stderr, "Usage: %s device\n", argv[0]);
		exit(1);
	}

	retval = ext2fs_get_device_size(argv[1], 1024, &blocks);
	if (retval) {
		com_err(argv[0], retval,
			"while calling ext2fs_get_device_size");
		exit(1);
	}
	printf("Device %s has %d 1k blocks.\n", argv[1], blocks);
	exit(0);
}
```


Overlapping Code:
```
har **argv)
{
blk_t blocks;
int retval;

if (argc < 2) {
fprintf(stderr, "Usage: %s device\n", argv[0]);
exit(1);
}
retval = ext2fs_get_device_size(argv[1], 1024, &blocks);
if (retval) {
com_err(argv[0], retval,
"while calling ext2fs_get_device_size");
exit(1);
}
printf("Device %s has %d 1k blocks.\
```
<Overlap Ratio: 0.8522727272727273>

---

--- 339 --
Question ID: 1676c296612ecbc19bdefcacfc35b010bf1542b7_90
Original Code:
```
NTSTATUS dcerpc_decode_trustAuthInOut_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
	struct dcerpc_decode_trustAuthInOut_r_state *state =
		tevent_req_data(req,
		struct dcerpc_decode_trustAuthInOut_r_state);
	NTSTATUS status;

	if (tevent_req_is_nterror(req, &status)) {
		tevent_req_received(req);
		return status;
	}

	talloc_steal(mem_ctx, state->out_mem_ctx);

	tevent_req_received(req);
	return NT_STATUS_OK;
}
```


Overlapping Code:
```
pc_decode_trustAuthInOut_r_recv(struct tevent_req *req, TALLOC_CTX *mem_ctx)
{
struct dcerpc_decode_trustAuthInOut_r_state *state =
tevent_req_data(req,
struct dcerpc_decode_trustAuthInOut_r_state);
NTSTATUS status;
if (tevent_req_is_nterror(req, &status)) {
tevent_req_received(req);
return status;
}
talloc_steal(mem_ctx, state->out_mem_ctx);
tevent_req_received(req);
return NT_STATUS_OK;
}
```
<Overlap Ratio: 0.9679802955665024>

---

--- 340 --
Question ID: 000121c48fb714241390896a883ca8cef9691445_10
Original Code:
```
static void dtDebugPrintTable(DTTable* t, int indent)
{
  int i;

  dtSpaces(indent);
  printf("table:\n");
  dtSpaces(indent+2);
  printf("default:\n");
  dtDebugPrintNode(t->defaultEntry, indent+4);
  for (i=0; i < t->numEntries; i++) {
    dtSpaces(indent+2);
    if (NULL == t->entries[i]) {
      printf("entry %d: (default)\n", i);
    } else {
      printf("entry %d:\n", i);
      dtDebugPrintNode(t->entries[i], indent+4);
    }
  };
}
```


Overlapping Code:
```
 dtDebugPrintTable(DTTable* t, int indent)
{
int i;
dtSpaces(indent);
printf("table:\n");
dtSpaces(indent+2);
printf("default:\n");
dtDebugPrintNode(t->defaultEntry, indent+4);
for (i=0; i < t->numEntries; i++) {
dtSpaces(indent+2);
if (NULL == t->entries[i]) {
printf("entry %d: (default)\n", i);
} else {
printf("entry %d:\n", i);
dtDebugPrintNode(
```
<Overlap Ratio: 0.8905852417302799>

---

--- 341 --
Question ID: 82931df32875feec44e737581c4ab1a57193f39b_7
Original Code:
```
__API__ int tos_chr_fifo_pop_stream(k_chr_fifo_t *chr_fifo, uint8_t *buffer, size_t size)
{
    TOS_CPU_CPSR_ALLOC();
    int i = 0;
    uint8_t data;

    TOS_PTR_SANITY_CHECK_RC(chr_fifo, 0);
    TOS_OBJ_VERIFY_RC(chr_fifo, KNL_OBJ_TYPE_CHAR_FIFO, 0);

    TOS_CPU_INT_DISABLE();

    while (i < size) {
        if (tos_ring_q_dequeue(&chr_fifo->ring_q, &data, K_NULL) != K_ERR_NONE) {
            TOS_CPU_INT_ENABLE();
            return i;
        }
        buffer[i++] = data;
    }

    TOS_CPU_INT_ENABLE();
    return i;
}
```


Overlapping Code:
```
hr_fifo_pop_stream(k_chr_fifo_t *chr_fifo, uint8_t *buffer, size_t size)
{
TOS_CPU_CPSR_ALLOC();
int i = 0;
uint8_t data;
TOS_PTR_SANITY_CHECK_RC(chr_fifo, 0);
TOS_OBJ_VERIFY_RC(chr_fifo, KNL_OBJ_TYPE_CHAR_FIFO, 0);
TOS_CPU_INT_DISABLE();
while (i < size) {
if (tos_ring_q_dequeue(&chr_fifo->ring_q, &data, K_NULL) != K_ERR_NONE) {
TOS_CPU_INT_ENABLE();
return i;
}
buffer[i++] = data;
}
TOS_CPU_INT_ENABLE();
return i;
```
<Overlap Ratio: 0.95662100456621>

---

--- 342 --
Question ID: 9ab3cb3477d6432ff0ae46a58a57e10a1c0b7787_1
Original Code:
```
void get_response(int sock, char *buf)
{
	/* This function gets a response from the
	   server in the form of a character string. */

	int n;

	n=read(sock,buf,625);

	if (n<0)
	{
		if (errno==EINTR)
			return;

		if (errno==ECONNREFUSED)
		{
			fprintf(stderr, "Connection refused - server not running\n");
			exit (1);
		}
	}

	buf[n]='\0';
}
```


Overlapping Code:
```
et_response(int sock, char *buf)
{
/* This function gets a response from the
server in the form of a character string. */
int n;
n=read(sock,buf,625);
if (n<0)
{
if (errno==EINTR)
return;
if (errno==ECONNREFUSED)
{
fprintf(stderr, "Connection refused - server not running\n");
exit (1);
}
}
buf[n]='\0'
```
<Overlap Ratio: 0.9710610932475884>

---

--- 343 --
Question ID: 3deea9d9fe231de0d6e8a124d9718a4dc9af1f5e_22
Original Code:
```
static int
sdhci_get_ro(device_t brdev, device_t reqdev)
{
	struct sdhci_slot *slot = device_get_ivars(reqdev);
	uint32_t val;

	SDHCI_LOCK(slot);
	val = RD4(slot, SDHCI_PRESENT_STATE);
	SDHCI_UNLOCK(slot);
	return (!(val & SDHCI_WRITE_PROTECT));
}
```


Overlapping Code:
```
_ro(device_t brdev, device_t reqdev)
{
struct sdhci_slot *slot = device_get_ivars(reqdev);
uint32_t val;
SDHCI_LOCK(slot);
val = RD4(slot, SDHCI_PRESENT_STATE);
SDHCI_UNLOCK(slot);
return (!(val & SDHCI_WRI
```
<Overlap Ratio: 0.8547717842323651>

---

--- 344 --
Question ID: 50c60e4ba0fa067b4c7bb219f3313615ecf20c03_169
Original Code:
```
int v_gethexa( short parameter_1)
{
	unsigned int unsigned_int_1 = 1;
	double double_1 = 1;
	int int_1 = 1;
	double double_2 = 1;
	unsigned int unsigned_int_2 = 1;
	unsigned int unsigned_int_3 = 1;
	unsigned_int_1 = v_esccheck(double_1,int_1,double_2);

	unsigned_int_1 = unsigned_int_1 + unsigned_int_2;
	unsigned_int_1 = unsigned_int_3 + unsigned_int_3;
	return int_1;
	int_1 = v_luaO_hexavalue(int_1);

}
```


Overlapping Code:
```
( short parameter_1)
{
unsigned int unsigned_int_1 = 1;
double double_1 = 1;
int int_1 = 1;
double double_2 = 1;
unsigned int unsigned_int_2 = 1;
unsigned int unsigned_int_3 = 1;
unsigned_int_1 = v_esccheck(double_1,int_1,double_2);
unsigned_int_1 = unsigned_int_1 + unsigned_int_2;
unsigned_int_1 = unsigned_int_3 + unsigned_int_3;
return int_1;
int_1 = v_luaO_hexavalue(
```
<Overlap Ratio: 0.9441624365482234>

---

--- 345 --
Question ID: 4108b1a357bc57f422033dfebecfc51c36b1fe92_0
Original Code:
```
UINT32
AnMapEtypeToBtype (
    UINT32              Etype)
{


    if (Etype == ACPI_TYPE_ANY)
    {
        return ACPI_BTYPE_OBJECTS_AND_REFS;
    }

    /* Try the standard ACPI data types */

    if (Etype <= ACPI_TYPE_EXTERNAL_MAX)
    {
        /*
         * This switch statement implements the allowed operand conversion
         * rules as per the "ASL Data Types" section of the ACPI
         * specification.
         */
        switch (Etype)
        {
        case ACPI_TYPE_INTEGER:
            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DDB_HANDLE);

        case ACPI_TYPE_STRING:
        case ACPI_TYPE_BUFFER:
            return (ACPI_BTYPE_COMPUTE_DATA);

        case ACPI_TYPE_PACKAGE:
            return (ACPI_BTYPE_PACKAGE);

        case ACPI_TYPE_FIELD_UNIT:
            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);

        case ACPI_TYPE_BUFFER_FIELD:
            return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_BUFFER_FIELD);

        case ACPI_TYPE_DDB_HANDLE:
            return (ACPI_BTYPE_INTEGER | ACPI_BTYPE_DDB_HANDLE);

        case ACPI_BTYPE_DEBUG_OBJECT:

            /* Cannot be used as a source operand */

            return (0);

        default:
            return (1 << (Etype - 1));
        }
    }

    /* Try the internal data types */

    switch (Etype)
    {
    case ACPI_TYPE_LOCAL_REGION_FIELD:
    case ACPI_TYPE_LOCAL_BANK_FIELD:
    case ACPI_TYPE_LOCAL_INDEX_FIELD:

        /* Named fields can be either Integer/Buffer/String */

        return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);

    case ACPI_TYPE_LOCAL_ALIAS:

        return (ACPI_BTYPE_INTEGER);


    case ACPI_TYPE_LOCAL_RESOURCE:
    case ACPI_TYPE_LOCAL_RESOURCE_FIELD:

        return (ACPI_BTYPE_REFERENCE);

    default:
        printf ("Unhandled encoded type: %X\n", Etype);
        return (0);
    }
}
```


Overlapping Code:
```
T32
AnMapEtypeToBtype (
UINT32 Etype)
{
if (Etype == ACPI_TYPE_ANY)
{
return ACPI_BTYPE_OBJECTS_AND_REFS;
}
/* Try the standard ACPI data types */
if (Etype <= ACPI_TYPE_EXTERNAL_MAX)
{
/*
* This switch statement implements the allowed operand conversion
* rules as per the "ASL Data Types" section of the ACPI
* specification.
*/
switch (Etype)
{
case ACPI_TYPE_INTEGER:
return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_DDB_HANDLE);
case ACPI_TYPE_STRING:
case ACPI_TYPE_BUFFER:
return (ACPI_BTYPE_COMPUTE_DATA);
case ACPI_TYPE_PACKAGE:
return (ACPI_BTYPE_PACKAGE);
case ACPI_TYPE_FIELD_UNIT:
return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);
case ACPI_TYPE_BUFFER_FIELD:
return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_BUFFER_FIELD);
case ACPI_TYPE_DDB_HANDLE:
return (ACPI_BTYPE_INTEGER | ACPI_BTYPE_DDB_HANDLE);
case ACPI_BTYPE_DEBUG_OBJECT:
/* Cannot be used as a source operand */
return (0);
default:
return (1 << (Etype - 1));
}
}
/* Try the internal data types */
switch (Etype)
{
case ACPI_TYPE_LOCAL_REGION_FIELD:
case ACPI_TYPE_LOCAL_BANK_FIELD:
case ACPI_TYPE_LOCAL_INDEX_FIELD:
/* Named fields can be either Integer/Buffer/String */
return (ACPI_BTYPE_COMPUTE_DATA | ACPI_BTYPE_FIELD_UNIT);
case ACPI_TYPE_LOCAL_ALIAS:
return (ACPI_BTYPE_INTEGER);
case ACPI_TYPE_LOCAL_RESOURCE:
case ACPI_TYPE_LOCAL_RESOURCE_FIELD:
return (ACPI_BTYPE_REFERENCE);
default:
printf ("Unhandled encoded type
```
<Overlap Ratio: 0.9756437021572721>

---

--- 346 --
Question ID: 3349269ed46107e1661ff44ee0ec66c1d83a7205_0
Original Code:
```
static void setWindowParams(STATE_T * state, int32_t x, int32_t y, VC_RECT_T * src_rect, VC_RECT_T * dst_rect) {
	uint32_t dx, dy, w, h, sx, sy;

	// Set source & destination rectangles so that the image is
	// clipped if it goes off screen (else dispman won't show it properly)
	if (x < (1 - (int)state->window_width)) {	   // Too far off left
		x = 1 - (int)state->window_width;
		dx = 0;
		sx = state->window_width - 1;
		w = 1;
	} else if (x < 0) {				   // Part of left is off
		dx = 0;
		sx = -x;
		w = state->window_width - sx;
	} else if (x < (int)(state->screen_width - state->window_width)) {	// On
		dx = x;
		sx = 0;
		w = state->window_width;
	} else if (x < (int)state->screen_width) {	   // Part of right is off
		dx = x;
		sx = 0;
		w = state->screen_width - x;
	} else {					   // Too far off right
		x = state->screen_width - 1;
		dx = state->screen_width - 1;
		sx = 0;
		w = 1;
	}

	if (y < (1 - (int)state->window_height)) {	   // Too far off top
		y = 1 - (int)state->window_height;
		dy = 0;
		sy = state->window_height - 1;
		h = 1;
	} else if (y < 0) {				   // Part of top is off
		dy = 0;
		sy = -y;
		h = state->window_height - sy;
	} else if (y < (int)(state->screen_height - state->window_height)) {	// On
		dy = y;
		sy = 0;
		h = state->window_height;
	} else if (y < (int)state->screen_height) {	   // Part of bottom is off
		dy = y;
		sy = 0;
		h = state->screen_height - y;
	} else {					   // Wholly off bottom
		y = state->screen_height - 1;
		dy = state->screen_height - 1;
		sy = 0;
		h = 1;
	}

	state->window_x = x;
	state->window_y = y;

	vc_dispmanx_rect_set(dst_rect, dx, dy, w, h);
	vc_dispmanx_rect_set(src_rect, sx << 16, sy << 16, w << 16, h << 16);
}
```


Overlapping Code:
```
2_t x, int32_t y, VC_RECT_T * src_rect, VC_RECT_T * dst_rect) {
uint32_t dx, dy, w, h, sx, sy;
// Set source & destination rectangles so that the image is
// clipped if it goes off screen (else dispman won't show it properly)
if (x < (1 - (int)state->window_width)) { // Too far off left
x = 1 - (int)state->window_width;
dx = 0;
sx = state->window_width - 1;
w = 1;
} else if (x < 0) { // Part of left is off
dx = 0;
sx = -x;
w = state->window_width - sx;
} else if (x < (int)(state->screen_width - state->window_width)) { // On
dx = x;
sx = 0;
w = state->window_width;
} else if (x < (int)state->screen_width) { // Part of right is off
dx = x;
sx = 0;
w = state->screen_width - x;
} else { // Too far off right
x = state->screen_width - 1;
dx = state->screen_width - 1;
sx = 0;
w = 1;
}
if (y < (1 - (int)state->window_height)) { // Too far off top
y = 1 - (int)state->window_height;
dy = 0;
sy = state->window_height - 1;
h = 1;
} else if (y < 0) { // Part of top is off
dy = 0;
sy = -y;
h = state->window_height - sy;
} else if (y < (int)(state->screen_height - state->window_height)) { // On
dy = y;
sy = 0;
h = state->window_height;
} else if (y < (int)state->screen_height) { // Part of bottom is off
dy = y;
sy = 0;
h = state->screen_height - y;
} else { // Wholly off bottom
y = state->screen_height - 1;
dy = state->screen_height - 1;
sy = 0;
h = 1;
}
state->window_x = x;
state->window_y = y;
vc_dispmanx_rect_set(dst_rect, dx, dy, w, h);
vc_dispmanx_rect_set(src_rect, sx << 16, sy << 16,
```
<Overlap Ratio: 0.9554140127388535>

---

--- 347 --
Question ID: cf00f7c8cbf050bf1ce1af828df40e380d1310a9_2
Original Code:
```
void list_remove(struct list_elem* pelem) {
    enum intr_status old_status = intr_disable();

    pelem->prev->next = pelem->next;
    pelem->next->prev = pelem->prev;
    intr_set_status(old_status);
}
```


Overlapping Code:
```
 {
enum intr_status old_status = intr_disable();
pelem->prev->next = pelem->next;
pelem->next->prev = pelem->
```
<Overlap Ratio: 0.5860215053763441>

---

--- 348 --
Question ID: 36dca0f1df8519659a97de30f63b9764a12734c4_33
Original Code:
```
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)
{
	void *file_addr;
	int fd;
	size_t ret;

	if (fd_get(out_fd, &fd) != fd_rsocket)
		return real.sendfile(fd, in_fd, offset, count);

	file_addr = mmap(NULL, count, PROT_READ, 0, in_fd, offset ? *offset : 0);
	if (file_addr == (void *) -1)
		return -1;

	ret = rwrite(fd, file_addr, count);
	if ((ret > 0) && offset)
		lseek(in_fd, ret, SEEK_CUR);
	munmap(file_addr, count);
	return ret;
}
```


Overlapping Code:
```
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count)
{
void *file_addr;
int fd;
size_t ret;
if (fd_get(out_fd, &fd) != fd_rsocket)
return real.sendfile(fd, in_fd, offset, count);
file_addr = mmap(NULL, count, PROT_READ, 0, in_fd, offset ? *offset : 0);
if (file_addr == (void *) -1)
return -1;
ret = rwrite(fd, file_addr, count);
if ((ret > 0) && offset)
lseek(in_fd, ret, SEEK_CUR);
munmap(file_addr, count);
retu
```
<Overlap Ratio: 0.979498861047836>

---

--- 349 --
Question ID: 1e68a1ebe33f372c5ba0ba38080fb195bb244e1a_2
Original Code:
```
static void
free_vbdev(struct spdk_bdev *bdev)
{
	CU_ASSERT(!TAILQ_EMPTY(&bdev->base_bdevs));
	spdk_bdev_unregister(bdev, NULL, NULL);
	free(bdev);
}
```


Overlapping Code:
```
e_vbdev(struct spdk_bdev *bdev)
{
CU_ASSERT(!TAILQ_EMPTY(&bdev->base_bdevs));
spdk_bdev_unregister(b
```
<Overlap Ratio: 0.684931506849315>

---

--- 350 --
Question ID: 1aa913fa09541a70d008e4fa9d917a39c4a4c231_0
Original Code:
```
class CloudToSpatial
{
    public:
        CloudToSpatial() : listener_(tfBuffer), nh_("~"){};
        ~CloudToSpatial();

        void callback(const PointCloud2ConstPtr& cloud_msg_ptr, const BinInfoPtr& target_bin_ptr);

        void onInit();

        void subsribe();

        
        ros::Publisher dist_pub;
        ros::Publisher height_pub;
        tf2_ros::Buffer tfBuffer;
        tf2_ros::TransformListener listener_;
        ros::NodeHandle nh_;

        Synchronizer<MySyncPolicy> * sync;


    private: 
        uint8_t dist(const float x, const float y, const float z, const jsk_recognition_msgs::BoundingBox & bbox);
        uint8_t height(const float z, const jsk_recognition_msgs::BoundingBox & bbox);

}
```


Overlapping Code:
```
loudToSpatial
{
public:
CloudToSpatial() : listener_(tfBuffer), nh_("~"){};
~CloudToSpatial();
void callback(const PointCloud2ConstPtr& cloud_msg_ptr, const BinInfoPtr& target_bin_ptr);
void onInit();
void subsribe();

ros::Publisher dist_pub;
ros::Publisher height_pub;
tf2_ros::Buffer tfBuffer;
tf2_ros::TransformListener listener_;
ros::NodeHandle nh_;
Synchronizer<MySyncPolicy> * sync;
private: 
uint8_t dist(const float x, const float y, const float z, const jsk_recognition_msgs::BoundingBox & bbox);
uint8_t height(const float z, const jsk_recognition_msgs::BoundingBox & bbox)
```
<Overlap Ratio: 0.9831932773109243>

---

--- 351 --
Question ID: 66d9f5ea111148d49b89b1aeac195b27a91c968c_0
Original Code:
```
struct BlockRequest *parseBlockRequestFromProtobufMsg(ac_protobuf_message_t *msg) {
  struct BlockRequest *ret = malloc(sizeof(struct BlockRequest));
  ac_protobuf_field_t *username_f = ac_find_protobuf_field_in_msg(msg, 1);
  ret->username.value = malloc(username_f->len + 1);
  memcpy(ret->username.value, username_f->value, username_f->len);
  ret->username.value[username_f->len] = 0;
  ret->username.len = username_f->len;
  return ret;
}
```


Overlapping Code:
```
est *parseBlockRequestFromProtobufMsg(ac_protobuf_message_t *msg) {
struct BlockRequest *ret = malloc(sizeof(struct BlockRequest));
ac_protobuf_field_t *username_f = ac_find_protobuf_field_in_msg(msg, 1);
ret->username.value = malloc(username_f->len + 1);
memcpy(ret->username.value, username_f->value, username_f->len);
ret->username.value[username_f->len] = 0;
ret->username.len = username_f->len;

```
<Overlap Ratio: 0.9324009324009324>

---

--- 352 --
Question ID: a520e08a117637c91eeb5067473ae537f1a67a94_4
Original Code:
```
static void apply_scale_keyframes(float *matrix, float time, struct SKEL_BONE_KEYFRAME **keyframes, int n_keyframes)
{
  if (n_keyframes == 0)
    return;
  
  if (n_keyframes == 1) {
    float scale[16];
    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);
    mat4_mul_left(matrix, scale);
    return;
  }
  
  if (n_keyframes == 2) {
    // TODO: interpolate keyframes[0] and keyframes[1]
    float scale[16];
    mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);
    mat4_mul_left(matrix, scale);
    return;
  }
}
```


Overlapping Code:
```
ix, float time, struct SKEL_BONE_KEYFRAME **keyframes, int n_keyframes)
{
if (n_keyframes == 0)
return;

if (n_keyframes == 1) {
float scale[16];
mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);
mat4_mul_left(matrix, scale);
return;
}

if (n_keyframes == 2) {
// TODO: interpolate keyframes[0] and keyframes[1]
float scale[16];
mat4_load_scale(scale, keyframes[0]->data[0], keyframes[0]->data[1], keyframes[0]->data[2]);
mat4_mul_left(matrix, scale);
retur
```
<Overlap Ratio: 0.9074410163339383>

---

--- 353 --
Question ID: 19556a6476a41e613535f6e16fb48f0169b72b69_6
Original Code:
```
int RecordPage(LinkedList *data, string title, string record(void *, uint8_t)) { 
  LinkedListNode *p, *re[100];//目标节点，分页数组
  int num = 0, count = 1, j = 0, y = 0;//序号，计数器，页码，选中行
  bool printed = false;
  char a, b;//读取按键ascii码
  int end;//最终记录条数+1
  p = data->top;
  re[0] = data->top;
  PrintString(title);
  while (1) {
    if ((count - 1) % hangshu == 0 && count != 1 || p == data->rear->next) {
      end = count;
      if (p == data->rear->next && (count - 1) % hangshu != 0) {
        count = (count + hangshu - 1) / hangshu * hangshu + 1;//进位取整+1：如39->41
      }

      if (!printed) {
        gotoxy(0, 11);
        PrintLITERAL("  修改记录: Enter  返回上一级: Backspace  左翻页: ←  右翻页: →\n");
        printed = true;
      }

      a = _getch();
      if (a < 0) {
        b = _getch();
        if (b == 75 && count > 1 + hangshu) {//左翻页
          count -= hangshu;
          if (j > 0) j--;
          p = re[j];
          UI_Clear();
          PrintString(title);
          printed = false;
        }
        else if (b == 77 && p != data->rear->next) {//右翻页
          j++;
          re[j] = p;
          UI_Clear();
          PrintString(title);
          printed = false;
        }
        else//锁定其他按键
          continue;
      }
      if (a == 8) {
        UI_Clear();
        return -1;
      }//Backspace
      if (a == 13)break;//回车退出
    }
    num++;
    PrintLITERAL("[ ]");
    PrintString(record(p->data, num));
    p = p->next;
    count++;
  }
  gotoxy(0, 11);
  PrintLITERAL("  向上移动: ↑  向下移动: ↓                                                     ");
  int count0 = end;//拷贝（真实记录行数+1）
  if ((count0 - 1) % hangshu == 0) {
    y = OptionBar(2, 2 + hangshu - 1);
  }
  else {
    if (count0 > hangshu) {
      count0 = count0 - (count0 / hangshu * hangshu) - 1;//记录末页行数：如记录38条，末页8行
    }
    y = OptionBar(2, 2 + count0 - 1);
  }
  return j * hangshu + y;
}
```


Overlapping Code:
```
rdPage(LinkedList *data, string title, string record(void *, uint8_t)) { 
LinkedListNode *p, *re[100];//目标节点，分页数组
int num = 0, count = 1, j = 0, y = 0;//序号，计数器，页码，选中行
bool printed = false;
char a, b;//读取按键ascii码
int end;//最终记录条数+1
p = data->top;
re[0] = data->top;
PrintString(title);
while (1) {
if ((count - 1) % hangshu == 0 && count != 1 || p == data->rear->next) {
end = count;
if (p == data->rear->next && (count - 1) % hangshu != 0) {
count = (count + hangshu - 1) / hangshu * hangshu + 1;//进位取整+1：如39->41
}
if (!printed) {
gotoxy(0, 11);
PrintLITERAL(" 修改记录: Enter 返回上一级: Backspace 左翻页: ← 右翻页: →\n");
printed = true;
}
a = _getch();
if (a < 0) {
b = _getch();
if (b == 75 && count > 1 + hangshu) {//左翻页
count -= hangshu;
if (j > 0) j--;
p = re[j];
UI_Clear();
PrintString(title);
printed = false;
}
else if (b == 77 && p != data->rear->next) {//右翻页
j++;
re[j] = p;
UI_Clear();
PrintString(title);
printed = false;
}
else//锁定其他按键
continue;
}
if (a == 8) {
UI_Clear();
return -1;
}//Backspace
if (a == 13)break;//回车退出
}
num++;
PrintLITERAL("[ ]");
PrintString(record(p->data, num));
p = p->next;
count++;
}
gotoxy(0, 11);
PrintLITERAL(" 向上移动: ↑ 向下移动: ↓ ");
int count0 = end;//拷贝（真实记录行数+1）
if ((count0 - 1) % hangshu == 0) {
y = OptionBar(2, 2 + hangshu - 1);
}
else {
if (count0 > hangshu) {
count0 = count0 - (count0 / hangshu * hangshu) - 1;//记录末页行数：如记录38条，末页8行
}
y = OptionBar(2, 2 + count0 - 1);
}
return 
```
<Overlap Ratio: 0.9819569743233866>

---

--- 354 --
Question ID: ccb49971ab0343636681da3da8fd6c9d1d8d7e1b_4
Original Code:
```
static int _ge_query_ion_debug(buffer_handle_t hnd, GEHND UNUSED(ge_hnd), void *out)
{
	int err;
	int ion_client;
	ion_user_handle_t ion_hnd;

	err = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_CLIENT, &ion_client);
	err_return(err, "get ion_client fail");
	err = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_HANDLE, &ion_hnd);
	err_return(err, "get ion_hnd fail");

	if (!err) err = _ge_get_ion_debug(ion_client, ion_hnd, out);

	return err;
}
```


Overlapping Code:
```
(buffer_handle_t hnd, GEHND UNUSED(ge_hnd), void *out)
{
int err;
int ion_client;
ion_user_handle_t ion_hnd;
err = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_CLIENT, &ion_client);
err_return(err, "get ion_client fail");
err = gralloc_extra_query(hnd, GRALLOC_EXTRA_GET_ION_HANDLE, &ion_hnd);
err_return(err, "get ion_hnd fail");
if (!err) err = _ge_get_ion_debug(ion_client, ion_hnd, out);
return 
```
<Overlap Ratio: 0.9176201372997712>

---

--- 355 --
Question ID: 450c46cf27b06a9a3c56c3060dc65b6d6c0bbc38_0
Original Code:
```
int run(void) {
    ringbuffer_t *low = rb_new((void*)low_output, sizeof(*low_output));
    if (low == NULL) {
        abort();
    }

    ringbuffer_t *high = rb_new((void*)high_output, sizeof(*high_output));
    if (high == NULL) {
        abort();
    }

    ringbuffer_t *input = rb_new((void*)char_in, sizeof(*char_in));
    if (input == NULL) {
        abort();
    }

    while (true) {
        char c = (char)rb_receive_byte(input);
//        printf("Switch received: %x\n", c);
        if (c == SWITCH_CHAR) {
//            printf("Switching!\n");
            /* Swap which output we see as active. */
            if (selected == LOW) {
                selected = HIGH;
            } else {
                selected = LOW;
            }
        } else {
            /* Send the character to the active output. */
            if (selected == LOW) {
                rb_transmit_byte(low, (unsigned char)c);
            } else {
                rb_transmit_byte(high, (unsigned char)c);
            }
        }
    }
    return 0;
}
```


Overlapping Code:
```
un(void) {
ringbuffer_t *low = rb_new((void*)low_output, sizeof(*low_output));
if (low == NULL) {
abort();
}
ringbuffer_t *high = rb_new((void*)high_output, sizeof(*high_output));
if (high == NULL) {
abort();
}
ringbuffer_t *input = rb_new((void*)char_in, sizeof(*char_in));
if (input == NULL) {
abort();
}
while (true) {
char c = (char)rb_receive_byte(input);
// printf("Switch received: %x\n", c);
if (c == SWITCH_CHAR) {
// printf("Switching!\n");
/* Swap which output we see as active. */
if (selected == LOW) {
selected = HIGH;
} else {
selected = LOW;
}
} else {
/* Send the character to the active output. */
if (selected == LOW) {
rb_transmit_byte(low, (unsigned char)c);
} else {
rb_transmit
```
<Overlap Ratio: 0.9296148738379814>

---

--- 356 --
Question ID: 8dea57adf6a1639529d5c347d88712d3ce896f0e_43
Original Code:
```
static int dyn_buf_resize(DynBuf *s, int size)
{
    int new_size;
    uint8_t *new_buf;

    if (size <= s->size)
        return 0;
    new_size = (s->size * 3) / 2;
    if (new_size < size)
        new_size = size;
    new_buf = realloc(s->buf, new_size);
    if (!new_buf) 
        return -1;
    s->buf = new_buf;
    s->size = new_size;
    return 0;
}
```


Overlapping Code:
```
f *s, int size)
{
int new_size;
uint8_t *new_buf;
if (size <= s->size)
return 0;
new_size = (s->size * 3) / 2;
if (new_size < size)
new_size = size;
new_buf = realloc(s->buf, new_size);
if (!new_buf) 
return -1;
s->buf = new_buf;
s->size = new_size;
return 
```
<Overlap Ratio: 0.8801369863013698>

---

--- 357 --
Question ID: 81b87fd3f98b6d69399aabbef827ce9c3a6bf5e0_17
Original Code:
```
static int decrypt_content_enc_key(s_recipient_info *p_recipient_info, ak_skey p_kek, ak_skey p_cek) {
    int error;
    struct buffer encrypted_cek;
    struct buffer encrypted_cek_mac;

    if (p_recipient_info->m_type != KEKRI)
        return ak_error_message(ak_error_invalid_value, __func__, "only kekri support");

    s_kekri *p_kekri = p_recipient_info->m_ri.mp_kekri;

    /* Создаем контекст ключа KEK */
    // Сравниваем идентификатор ключа из структуры KeyManagementInfo и KEKRI
    if (memcmp(p_kekri->m_key_identifire.mp_value, p_kek->number.data, p_kek->number.size) != 0)
        return ak_error_message(ak_error_invalid_value, __func__, "id from kekri doesn't match id from key management info");

    if ((error = pkcs_15_parse_enc_key_plus_mac_seq(p_kekri->m_encrypted_key, &encrypted_cek, &encrypted_cek_mac)) != ak_error_ok)
        return ak_error_message(error, __func__, "problem with parsing CEK");

    /*TODO: комментарий для Алексея Юрьевича: здесь необходимо вызвать
            фунцию расшифрования ключа CEK и сравнить имитовставку.
            Данные для расшифрования находятся в переменной encrypted_cek. */

    memcpy((ak_byte *) p_cek->key.data, (ak_byte *) encrypted_cek.data, encrypted_cek.size / 2);
    memcpy((ak_byte *) p_cek->mask.data, (ak_byte *) encrypted_cek.data + encrypted_cek.size / 2, encrypted_cek.size / 2);

    /* Устанавливаем флаги наличия ключа и маски */
    p_cek->flags |= skey_flag_set_key | skey_flag_set_mask;

    /* Перемаскируем ключ */
    if ((error = p_cek->set_mask(p_cek)) != ak_error_ok)
        return ak_error_message(error, __func__, "problem with key remasking");

    /* Вычисляем контрольную сумму ключа */
    if ((error = p_cek->set_icode(p_cek)) != ak_error_ok)
        return ak_error_message(error, __func__, "problem with setting icode");

    /* Устанавливаем флаг наличия контрольной суммы */
    p_cek->flags |= skey_flag_set_icode;

    return ak_error_ok;
}
```


Overlapping Code:
```
s_recipient_info *p_recipient_info, ak_skey p_kek, ak_skey p_cek) {
int error;
struct buffer encrypted_cek;
struct buffer encrypted_cek_mac;
if (p_recipient_info->m_type != KEKRI)
return ak_error_message(ak_error_invalid_value, __func__, "only kekri support");
s_kekri *p_kekri = p_recipient_info->m_ri.mp_kekri;
/* Создаем контекст ключа KEK */
// Сравниваем идентификатор ключа из структуры KeyManagementInfo и KEKRI
if (memcmp(p_kekri->m_key_identifire.mp_value, p_kek->number.data, p_kek->number.size) != 0)
return ak_error_message(ak_error_invalid_value, __func__, "id from kekri doesn't match id from key management info");
if ((error = pkcs_15_parse_enc_key_plus_mac_seq(p_kekri->m_encrypted_key, &encrypted_cek, &encrypted_cek_mac)) != ak_error_ok)
return ak_error_message(error, __func__, "problem with parsing CEK");
/*TODO: комментарий дляания ключа CEK и сравнить имитовставку.
Данные для расшифрования находятся в переменной encrypted_cek. */
memcpy((ak_byte *) p_cek->key.data, (ak_byte *) encrypted_cek.data, encrypted_cek.size / 2);
memcpy((ak_byte *) p_cek->mask.data, (ak_byte *) encrypted_cek.data + encrypted_cek.size / 2, encrypted_cek.size / 2);
/* Устанавливаем флаги наличия ключа и маски */
p_cek->flags |= skey_flag_set_key | skey_flag_set_mask;
/* Перемаскируем ключ */
if ((error = p_cek->set_mask(p_cek)) != ak_error_ok)
return ak_error_message(error, __func__, "problem with key remasking");
/* Вычисляем контрольную сумму ключа */
if ((error = p_cek->set_icode(p_cek)) != ak_error_ok)
return ak_error_message(error, __func__, "problem with setting icode");
/* Устанавливаем флаг наличия контрольной суммы */
p_cek->flag
```
<Overlap Ratio: 0.9207589285714286>

---

--- 358 --
Question ID: cb59a0bc1c36f41af05b98160f0953108a306291_58
Original Code:
```
intgo _wrap_airspy_close_spywrap_c67b9816208bfcb4(struct airspy_device *_swig_go_0) {
  struct airspy_device *arg1 = (struct airspy_device *) 0 ;
  int result;
  intgo _swig_go_result;
  
  arg1 = *(struct airspy_device **)&_swig_go_0; 
  
  result = (int)airspy_close(arg1);
  _swig_go_result = result; 
  return _swig_go_result;
}
```


Overlapping Code:
```
ywrap_c67b9816208bfcb4(struct airspy_device *_swig_go_0) {
struct airspy_device *arg1 = (struct airspy_device *) 0 ;
int result;
intgo _swig_go_result;

arg1 = *(struct airspy_device **)&_swig_go_0; 

result = (int)airspy_close(arg1);
_swig_go_result = result; 
return _swig_go_result;
}
```
<Overlap Ratio: 0.9140127388535032>

---

--- 359 --
Question ID: 057566832808670f43ce331d00c004e8c64d3bb3_5
Original Code:
```
static bool api_frsapi_GetDsPollingIntervalW(struct pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	struct frsapi_GetDsPollingIntervalW *r;

	call = &ndr_table_frsapi.calls[NDR_FRSAPI_GETDSPOLLINGINTERVALW];

	r = talloc(talloc_tos(), struct frsapi_GetDsPollingIntervalW);
	if (r == NULL) {
		return false;
	}

	pull = ndr_pull_init_blob(&p->in_data.data, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	if (p->endian) {
		pull->flags |= LIBNDR_FLAG_BIGENDIAN;
	}
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_IN, r);
	}

	ZERO_STRUCT(r->out);
	r->out.CurrentInterval = talloc_zero(r, uint32_t);
	if (r->out.CurrentInterval == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.DsPollingLongInterval = talloc_zero(r, uint32_t);
	if (r->out.DsPollingLongInterval == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.DsPollingShortInterval = talloc_zero(r, uint32_t);
	if (r->out.DsPollingShortInterval == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _frsapi_GetDsPollingIntervalW(p, r);

	if (p->fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_OUT | NDR_SET_VALUES, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	/*
	 * carry over the pointer count to the reply in case we are
	 * using full pointer. See NDR specification for full pointers
	 */
	push->ptr_count = pull->ptr_count;

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	p->out_data.rdata = ndr_push_blob(push);
	talloc_steal(p->mem_ctx, p->out_data.rdata.data);

	talloc_free(r);

	return true;
}
```


Overlapping Code:
```
ervalW(struct pipes_struct *p)
{
const struct ndr_interface_call *call;
struct ndr_pull *pull;
struct ndr_push *push;
enum ndr_err_code ndr_err;
struct frsapi_GetDsPollingIntervalW *r;
call = &ndr_table_frsapi.calls[NDR_FRSAPI_GETDSPOLLINGINTERVALW];
r = talloc(talloc_tos(), struct frsapi_GetDsPollingIntervalW);
if (r == NULL) {
return false;
}
pull = ndr_pull_init_blob(&p->in_data.data, r);
if (pull == NULL) {
talloc_free(r);
return false;
}
pull->flags |= LIBNDR_FLAG_REF_ALLOC;
if (p->endian) {
pull->flags |= LIBNDR_FLAG_BIGENDIAN;
}
ndr_err = call->ndr_pull(pull, NDR_IN, r);
if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
talloc_free(r);
return false;
}
if (DEBUGLEVEL >= 10) {
NDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_IN, r);
}
ZERO_STRUCT(r->out);
r->out.CurrentInterval = talloc_zero(r, uint32_t);
if (r->out.CurrentInterval == NULL) {
talloc_free(r);
return false;
}
r->out.DsPollingLongInterval = talloc_zero(r, uint32_t);
if (r->out.DsPollingLongInterval == NULL) {
talloc_free(r);
return false;
}
r->out.DsPollingShortInterval = talloc_zero(r, uint32_t);
if (r->out.DsPollingShortInterval == NULL) {
talloc_free(r);
return false;
}
r->out.result = _frsapi_GetDsPollingIntervalW(p, r);
if (p->fault_state) {
talloc_free(r);
/* Return true here, srv_pipe_hnd.c will take care */
return true;
}
if (DEBUGLEVEL >= 10) {
NDR_PRINT_FUNCTION_DEBUG(frsapi_GetDsPollingIntervalW, NDR_OUT | NDR_SET_VALUES, r);
}
push = ndr_push_init_ctx(r);
if (push == NULL) {
talloc_free(r);
return false;
}
/*
* carry over the pointer count to the reply in case we are
* using full pointer. See NDR specification for full pointers
*/
push->ptr_count = pull->ptr_count;
ndr_err = call->ndr_push(push, NDR_OUT, r);
if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
talloc_free(r);
return false;
}
p->out_data.rdata = ndr_push_blob(push);
talloc_steal(p->mem_ctx, p->out_data.rdata.data);
talloc_free(r);
return true;
}
```
<Overlap Ratio: 0.9805228088159919>

---

--- 360 --
Question ID: 2ec7b61f41330cf1975c6510fbda249126dec49a_7
Original Code:
```
noreturn void run_current(void)
{
    struct proc *proc;
    int launched;

    proc = get_proc(current);
    assert(proc->state == PROC_RUNNING, "current must be running");
    launched = proc->launched;
    proc->launched = 1;
    hvm_switch(get_page(proc->hvm), get_page(proc->stack) + PAGE_SIZE,
               kva2pa(get_page(proc->page_table_root)), ms_to_cycles(CONFIG_PREEMPT_TIMER),
               launched);
    __builtin_unreachable();
}
```


Overlapping Code:
```
urrent(void)
{
struct proc *proc;
int launched;
proc = get_proc(current);
assert(proc->state == PROC_RUNNING, "current must be running");
launched = proc->launched;
proc->launched = 1;
hvm_switch(get_page(proc->hvm), get_page(proc->stack) + PAGE_SIZE,
kva2pa(get_page(proc->page_table_root)), ms_to_cycles(CONFIG_PREEMPT_TIMER),
launched);
__builtin_
```
<Overlap Ratio: 0.9090909090909091>

---

--- 361 --
Question ID: 2b4cf099e5f2192244be97af7e5ee00f527448d5_0
Original Code:
```
int main(void)
{
    int status;
    pid_t pid;

    if((pid = vfork()) > 0) // vfork = chd를 생성하고 parent는 블록시킨다.
                            //일반적인 fork는 메모리 전체를 싹다 복사한다. 그렇게 진행한다면 페이징을 쓸데없이 많이해서
                        // 용량을 낭비한다.
                     // VFORK는 task_struct만 생성하고 복사작업은 하지않는다.
                     // exec는 가상메모리의 레이아웃만잡는다.


    {
        waitpid(-1, &status, WNOHANG);
        printf("ls -al test Success\n");
    }

    else if(!pid)
    {
        execlp("ls", "ls", "-a", "-l", 0);
    }

    return 0;
}
```


Overlapping Code:
```
main(void)
{
int status;
pid_t pid;
if((pid = vfork()) > 0) // vfork = chd를 생성하고 parent는 블록시킨다.
//일반적인 fork는 메모리 전체를 싹다 복사한다. 그렇게 진행한다면 페이징을 쓸데없이 많이해서
// 용량을 낭비한다.
// VFORK는 task_struct만 생성하고 복사작업은 하지않는다.
// exec는 가상메모리의 레이아웃만잡는다.
{
waitpid(-1, &status, WNOHANG);
printf("ls -al test Success\n");
}
else if(!pid)
{
execlp("ls", "ls", "-a", "-l", 0);

```
<Overlap Ratio: 0.9536784741144414>

---

--- 362 --
Question ID: 8c1c6cce98951e00aff375e53d0d92186c126440_39
Original Code:
```
void*
getBoundsnoio_i(MetaPoolTy* MP, unsigned char* src, void *dest) {
  void* S;
  unsigned len;
  int fs;
  __sva_rt_lock_t lock;

  if (!pchk_ready || !MP) return &found;
  ++stat_boundscheck;

  /* Try fail cache first */
  __sva_rt_lock(&lock);
#if 0
  int i = isInCache(MP, src);
  if (i) {
    mtfCache(MP, i);
    __sva_rt_unlock(&lock);
    return &found;
  }
#endif

#if 0
  {
    unsigned int index  = MP->cindex;
    unsigned int cindex = MP->cindex;
    do
    {
      if ((MP->start[index] <= src) &&
          (MP->start[index]+MP->length[index] >= src))
        return MP->cache[index];
      index = (index + 1) & 3;
    } while (index != cindex);
  }
#endif

  /*
   * Look in the object splay for the given pointer.
   */
  S = src;
  len = 0;
#if 0
  if (do_profile) tsc1 = llva_save_tsc();
  int fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);
  if (do_profile) tsc2 = llva_save_tsc();
  if (do_profile) pchk_profile(MP, __builtin_return_address(0), (long)(tsc2 - tsc1));
#else
  fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);
#endif

  if (fs) {
#if 1
    unsigned int index = MP->cindex;
    MP->start[index] = S;
    MP->length[index] = len;
    MP->cache[index] = MP->Objs;
    MP->cindex = (index+1) & 3u;
#endif
    __sva_rt_unlock(&lock);
    return MP->Objs;
  }

  /*
   * If the source pointer is within the first page of memory, return the zero
   * page.
   */
  if (src < (unsigned char*)4096)
    return &zero_page;

  return &found;
}
```


Overlapping Code:
```
d*
getBoundsnoio_i(MetaPoolTy* MP, unsigned char* src, void *dest) {
void* S;
unsigned len;
int fs;
__sva_rt_lock_t lock;
if (!pchk_ready || !MP) return &found;
++stat_boundscheck;
/* Try fail cache first */
__sva_rt_lock(&lock);
#if 0
int i = isInCache(MP, src);
if (i) {
mtfCache(MP, i);
__sva_rt_unlock(&lock);
return &found;
}
#endif
#if 0
{
unsigned int index = MP->cindex;
unsigned int cindex = MP->cindex;
do
{
if ((MP->start[index] <= src) &&
(MP->start[index]+MP->length[index] >= src))
return MP->cache[index];
index = (index + 1) & 3;
} while (index != cindex);
}
#endif
/*
* Look in the object splay for the given pointer.
*/
S = src;
len = 0;
#if 0
if (do_profile) tsc1 = llva_save_tsc();
int fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);
if (do_profile) tsc2 = llva_save_tsc();
if (do_profile) pchk_profile(MP, __builtin_return_address(0), (long)(tsc2 - tsc1));
#else
fs = adl_splay_retrieve(&MP->Objs, &S, &len, 0);
#endif
if (fs) {
#if 1
unsigned int index = MP->cindex;
MP->start[index] = S;
MP->length[index] = len;
MP->cache[index] = MP->Objs;
MP->cindex = (index+1) & 3u;
#endif
__sva_rt_unlock(&lock);
return MP->Objs;
}
/*
* If the source pointer is within the first page of memory, return the zero
* page.
*/
if (src < (unsigned char*)4096)
return &zero_page;
return &found;
```
<Overlap Ratio: 0.9961685823754789>

---

--- 363 --
Question ID: 0ba30253b44ed49c3cb8263906fc20d62785005c_2
Original Code:
```
void AdjustRectifyRect( const EPH_Vec2i &size, const EPH_Vec4 &K, const EPH_Mat3 &M, EPH_Vec2 &bmin, EPH_Vec2 &bmax ) {
	EPH_Vec2 corner[4];
	corner[0] = ReprojectRay( EPH_Vec2( 0,		0		), K, EPH_Vec4( 1, 1, 0, 0 ), M );
	corner[1] = ReprojectRay( EPH_Vec2( size.x, 0		), K, EPH_Vec4( 1, 1, 0, 0 ), M );
	corner[2] = ReprojectRay( EPH_Vec2( size.x, size.y	), K, EPH_Vec4( 1, 1, 0, 0 ), M );
	corner[3] = ReprojectRay( EPH_Vec2( 0,		size.y	), K, EPH_Vec4( 1, 1, 0, 0 ), M );
	bmin = corner[0].Min( corner[1] ).Min( corner[2].Min( corner[3] ) );
	bmax = corner[0].Max( corner[1] ).Max( corner[2].Max( corner[3] ) );
}
```


Overlapping Code:
```
nst EPH_Vec2i &size, const EPH_Vec4 &K, const EPH_Mat3 &M, EPH_Vec2 &bmin, EPH_Vec2 &bmax ) {
EPH_Vec2 corner[4];
corner[0] = ReprojectRay( EPH_Vec2( 0, 0 ), K, EPH_Vec4( 1, 1, 0, 0 ), M );
corner[1] = ReprojectRay( EPH_Vec2( size.x, 0 ), K, EPH_Vec4( 1, 1, 0, 0 ), M );
corner[2] = ReprojectRay( EPH_Vec2( size.x, size.y ), K, EPH_Vec4( 1, 1, 0, 0 ), M );
corner[3] = ReprojectRay( EPH_Vec2( 0, size.y ), K, EPH_Vec4( 1, 1, 0, 0 ), M );
bmin = corner[0].Min( corner[1] ).Min( corner[2].Min( corner[3] ) );
bmax = corner[0].Max( corner[1] ).Max( corn
```
<Overlap Ratio: 0.912106135986733>

---

--- 364 --
Question ID: b12348cc69d6fad4b0e0936c5b53d823bd7d0731_13
Original Code:
```
static void print_qconf_table(app_args_t *args)
{
	int i, j, k, qid, if_idx;
	char buf[32];
	struct thread_arg_s *thr_arg;

	printf("Rx Queue table\n"
	       "-----------------\n"
	       "%-32s%-16s%-16s\n",
	       "port/id", "rxq", "thread");

	for (i = 0; i < args->worker_count; i++) {
		thr_arg = &global.worker_args[i];
		for (j = 0; j < args->if_count; j++) {
			if (!thr_arg->pktio[j].nb_rxq)
				continue;

			if_idx = thr_arg->pktio[j].if_idx;
			snprintf(buf, 32, "%s/%d", args->if_names[if_idx],
				 if_idx);
			for (k = 0; k < MAX_NB_QUEUE; k++) {
				qid = thr_arg->pktio[j].rxq[k];
				if (qid != INVALID_ID)
					printf("%-32s%-16d%-16d\n", buf, qid,
					       thr_arg->thr_idx);
			}
		}
	}
	printf("\n");
	fflush(NULL);
}
```


Overlapping Code:
```
able(app_args_t *args)
{
int i, j, k, qid, if_idx;
char buf[32];
struct thread_arg_s *thr_arg;
printf("Rx Queue table\n"
"-----------------\n"
"%-32s%-16s%-16s\n",
"port/id", "rxq", "thread");
for (i = 0; i < args->worker_count; i++) {
thr_arg = &global.worker_args[i];
for (j = 0; j < args->if_count; j++) {
if (!thr_arg->pktio[j].nb_rxq)
continue;
if_idx = thr_arg->pktio[j].if_idx;
snprintf(buf, 32, "%s/%d", args->if_names[if_idx],
if_idx);
for (k = 0; k < MAX_NB_QUEUE; k++) {
qid = thr_arg->pktio[j].rxq[k];
if (qid != INVALID_ID)
printf("%-32s%-16d%-16d\n", buf, qid,
thr_arg->thr_idx);
}
}
}

```
<Overlap Ratio: 0.9174311926605505>

---

--- 365 --
Question ID: aaf74a0767311735502f9122d15872b54cc32bfe_3
Original Code:
```
MagickExport MagickBooleanType SetImageColorspace(Image *image,
  const ColorspaceType colorspace)
{
  MagickBooleanType
    status;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
  if (colorspace == UndefinedColorspace)
    {
      image->colorspace=UndefinedColorspace;
      return(MagickTrue);
    }
  if (image->colorspace == colorspace)
    return(MagickTrue);
  if ((colorspace == RGBColorspace) || (colorspace == TransparentColorspace))
    return(TransformRGBImage(image,image->colorspace));
  status=MagickTrue;
  if ((image->colorspace != RGBColorspace) &&
      (image->colorspace != TransparentColorspace) &&
      (image->colorspace != GRAYColorspace))
    status=TransformRGBImage(image,image->colorspace);
  if (RGBTransformImage(image,colorspace) == MagickFalse)
    status=MagickFalse;
  return(status);
}
```


Overlapping Code:
```
gickExport MagickBooleanType SetImageColorspace(Image *image,
const ColorspaceType colorspace)
{
MagickBooleanType
status;
assert(image != (Image *) NULL);
assert(image->signature == MagickSignature);
if (image->debug != MagickFalse)
(void) LogMagickEvent(TraceEvent,GetMagickModule(),"%s",image->filename);
if (colorspace == UndefinedColorspace)
{
image->colorspace=UndefinedColorspace;
return(MagickTrue);
}
if (image->colorspace == colorspace)
return(MagickTrue);
if ((colorspace == RGBColorspace) || (colorspace == TransparentColorspace))
return(TransformRGBImage(image,image->colorspace));
status=MagickTrue;
if ((image->colorspace != RGBColorspace) &&
(image->colorspace != TransparentColorspace) &&
(image->colorspace != GRAYColorspace))
status=TransformRGBImage(image,image->colorspace);
if (RGBTransformImage(image,colorspace) == MagickFalse)
status=MagickFalse;
r
```
<Overlap Ratio: 0.9797979797979798>

---

--- 366 --
Question ID: c5e5dc2b8f8524ed935f369c5a8c3d108a7af890_0
Original Code:
```
class SideAirbags: public Equipment {
public:
    SideAirbags(std::shared_ptr<IAutomobile> pIAuto): Equipment(pIAuto) { }

    int giveCosts() override;
    void showDetails() override;
}
```


Overlapping Code:
```
quipment {
public:
SideAirbags(std::shared_ptr<IAutomobile> pIAuto): Equipment(pIAuto) { }
int giveCosts() override;
void showDetails() ov
```
<Overlap Ratio: 0.7931034482758621>

---

--- 367 --
Question ID: b1236d76a3981d2d88b526cd96ca009b21fdb171_6
Original Code:
```
static void
sparc64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  tdep->gregset = regset_alloc (gdbarch, sparc64obsd_supply_gregset, NULL);
  tdep->sizeof_gregset = 288;

  tdep->fpregset = regset_alloc (gdbarch, sparc64obsd_supply_fpregset, NULL);
  tdep->sizeof_fpregset = 272;

  frame_unwind_append_sniffer (gdbarch, sparc64obsd_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, sparc64obsd_trapframe_sniffer);

  sparc64_init_abi (info, gdbarch);

  /* OpenBSD/sparc64 has SVR4-style shared libraries...  */
  set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
  set_solib_svr4_fetch_link_map_offsets
    (gdbarch, svr4_lp64_fetch_link_map_offsets);
  set_gdbarch_skip_solib_resolver (gdbarch, obsd_skip_solib_resolver);
}
```


Overlapping Code:
```
64obsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
tdep->gregset = regset_alloc (gdbarch, sparc64obsd_supply_gregset, NULL);
tdep->sizeof_gregset = 288;
tdep->fpregset = regset_alloc (gdbarch, sparc64obsd_supply_fpregset, NULL);
tdep->sizeof_fpregset = 272;
frame_unwind_append_sniffer (gdbarch, sparc64obsd_sigtramp_frame_sniffer);
frame_unwind_append_sniffer (gdbarch, sparc64obsd_trapframe_sniffer);
sparc64_init_abi (info, gdbarch);
/* OpenBSD/sparc64 has SVR4-style shared libraries... */
set_gdbarch_in_solib_call_trampoline (gdbarch, in_plt_section);
set_solib_svr4_fetch_link_map_offsets
(gdbarch, svr4_lp64_fetch_link_map_offsets);
set_gdbarch_skip_solib_resolver (gdbarch, obsd_skip_solib_resolver)
```
<Overlap Ratio: 0.9749687108886108>

---

--- 368 --
Question ID: b12058d21f82511055f0993858646d691e115fda_6
Original Code:
```
static void
emit_time (LogBuffer *logbuffer, uint64_t value)
{
	uint64_t tdiff = value - logbuffer->last_time;
	unsigned char *p;
	if (value < logbuffer->last_time)
		printf ("time went backwards\n");
	//if (tdiff > 1000000)
	//	printf ("large time offset: %llu\n", tdiff);
	p = logbuffer->data;
	encode_uleb128 (tdiff, logbuffer->data, &logbuffer->data);
	/*if (tdiff != decode_uleb128 (p, &p))
		printf ("incorrect encoding: %llu\n", tdiff);*/
	logbuffer->last_time = value;
	assert (logbuffer->data <= logbuffer->data_end);
}
```


Overlapping Code:
```
er *logbuffer, uint64_t value)
{
uint64_t tdiff = value - logbuffer->last_time;
unsigned char *p;
if (value < logbuffer->last_time)
printf ("time went backwards\n");
//if (tdiff > 1000000)
// printf ("large time offset: %llu\n", tdiff);
p = logbuffer->data;
encode_uleb128 (tdiff, logbuffer->data, &logbuffer->data);
/*if (tdiff != decode_uleb128 (p, &p))
printf ("incorrect encoding: %llu\n", tdiff);*/
logbuffer->last_time = value;
assert (logbuffer->data <= logbuffer->data_end);
}
```
<Overlap Ratio: 0.9416342412451362>

---

--- 369 --
Question ID: 6c3d6ae5f3149ee453405bddb6a2387bf0520225_10
Original Code:
```
const struct i915_gpu_controller_info *
intel_gma_get_controller_info(void)
{
	struct device *dev = dev_find_slot(0, PCI_DEVFN(0x2, 0));
	if (!dev)
		return NULL;
	struct northbridge_intel_i945_config *chip = dev->chip_info;
	if (!chip)
		return NULL;
	return &chip->gfx;
}
```


Overlapping Code:
```
st struct i915_gpu_controller_info *
intel_gma_get_controller_info(void)
{
struct device *dev = dev_find_slot(0, PCI_DEVFN(0x2, 0));
if (!dev)
return NULL;
struct northbridge_intel_i945_config *chip = dev->chip_info;
if (!chip)
return NUL
```
<Overlap Ratio: 0.9015151515151515>

---

--- 370 --
Question ID: f5e283d94ac8f9119b9c6a8af734385844207e91_1
Original Code:
```
static inline bool x86_feature_test(struct cpuid_bit bit)
{
    if(bit.word > 3 || bit.bit > 31) return false;

    const struct cpuid_leaf* leaf = x86_cpuid_leaf(bit.leaf);
    if(!leaf) return false;
    switch(bit.word)
    {
        case 0: return ((1u << bit.bit) & leaf -> a) != 0;
        case 1: return ((1u << bit.bit) & leaf -> b) != 0;
        case 2: return ((1u << bit.bit) & leaf -> c) != 0;
        case 3: return ((1u << bit.bit) & leaf -> d) != 0;
        default: return false;
    }
}
```


Overlapping Code:
```
nline bool x86_feature_test(struct cpuid_bit bit)
{
if(bit.word > 3 || bit.bit > 31) return false;
const struct cpuid_leaf* leaf = x86_cpuid_leaf(bit.leaf);
if(!leaf) return false;
switch(bit.word)
{
case 0: return ((1u << bit.bit) & leaf -> a) != 0;
case 1: return ((1u << bit.bit) & leaf -> b) != 0;
case 2: return ((1u << bit.bit) & leaf -> c) != 0;
case 3: return ((1u << bit.bit) & leaf -> d) !=
```
<Overlap Ratio: 0.91324200913242>

---

--- 371 --
Question ID: b1596a76f1b36cec25522acb44b4a5ce4ebadd83_0
Original Code:
```
namespace ui {

	class Rectangle : public sf::RectangleShape, public ui::UIObject
	{
	public:
		Rectangle(const std::string& id);

		void Draw(sf::RenderWindow& window) override;
	}
```


Overlapping Code:
```
pace ui {
class Rectangle : public sf::RectangleShape, public ui::UIObject
{
public:
Rectangle(const std::string& id);
void Draw(sf::RenderWindow& window)
```
<Overlap Ratio: 0.9005847953216374>

---

--- 372 --
Question ID: 53a54ee4023dc62eee6f836b42593bcafd5ddc92_1
Original Code:
```
uint8_t base64_decode(const unsigned char *src, size_t len, size_t *out_len, unsigned char *dst)
{
    unsigned char dtable[256], *pos, block[4], tmp;
    size_t i, count, olen;
    int pad = 0;

    memset(dtable, 0x80, 256);
    for (i = 0; i < sizeof(base64_table) - 1; i++)
        dtable[base64_table[i]] = (unsigned char) i;
    dtable['='] = 0;

    count = 0;
    for (i = 0; i < len; i++) {
        if (dtable[src[i]] != 0x80)
        count++;
    }

    if (count == 0 || count % 4) // Check padding
        return 0;

    olen = count / 4 * 3;
    unsigned char out[olen];
    pos = out;
    if (out == NULL)
        return 0;

    count = 0;
    for (i = 0; i < len; i++) {
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                    pos--;
                else if (pad == 2)
                    pos -= 2;
                else /* Invalid padding */
                    return 0;
            break;
            }
        }
    }

    *out_len = pos - out;
    memcpy(dst, out, *out_len+1);
    return 1;
}
```


Overlapping Code:
```
ase64_decode(const unsigned char *src, size_t len, size_t *out_len, unsigned char *dst)
{
unsigned char dtable[256], *pos, block[4], tmp;
size_t i, count, olen;
int pad = 0;
memset(dtable, 0x80, 256);
for (i = 0; i < sizeof(base64_table) - 1; i++)
dtable[base64_table[i]] = (unsigned char) i;
dtable['='] = 0;
count = 0;
for (i = 0; i < len; i++) {
if (dtable[src[i]] != 0x80)
count++;
}
if (count == 0 || count % 4) // Check padding
return 0;
olen = count / 4 * 3;
unsigned char out[olen];
pos = out;
if (out == NULL)
return 0;
count = 0;
for (i = 0; i < len; i++) {
tmp = dtable[src[i]];
if (tmp == 0x80)
continue;
if (src[i] == '=')
pad++;
block[count] = tmp;
count++;
if (count == 4) {
*pos++ = (block[0] << 2) | (block[1] >> 4);
*pos++ = (block[1] << 4) | (block[2] >> 2);
*pos++ = (block[2] << 6) | block[3];
count = 0;
if (pad) {
if (pad == 1)
pos--;
else if (pad == 2)
pos -= 2;
else /* Invalid padding */
return 0;
break;
}
}
}
*out_len = pos - out;
memcpy(dst, out, *out_len+1);
retur
```
<Overlap Ratio: 0.9851337958374629>

---

--- 373 --
Question ID: 8dcb2f12a278046542d112739d1cf6e13fa5a82a_2
Original Code:
```
int ARCONTROLLER_TESTBENCH_DeviceControllerAutoTest_initDiscoveryDevice (ARDISCOVERY_Device_t **device)
{
    int failed = 0;
    
    eARDISCOVERY_ERROR errorDiscovery = ARDISCOVERY_OK;
    
    ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "- init discovey device  ... ");
    
    *device = ARDISCOVERY_Device_New (&errorDiscovery);
    if ((errorDiscovery != ARDISCOVERY_OK) || (device == NULL))
    {
        failed += 1;
        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "device : %p", device);
        ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
    }
    
    if (errorDiscovery == ARDISCOVERY_OK)
    {
        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "    - ARDISCOVERY_Device_InitWifi ...");
#if DEVICE_TYPE == TEST_BEBOP
        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "ARDISCOVERY_PRODUCT_ARDRONE .....................");
        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_ARDRONE, "Bebop", FAKEDRONE_IP_ADDRESS, FAKEDRONE_DISCOVERY_PORT);
#elif DEVICE_TYPE == TEST_JS
        ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "ARDISCOVERY_PRODUCT_JS .....................");
        errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_JS, "Js", JS_IP_ADDRESS, JS_DISCOVERY_PORT);
#endif
        
        if (errorDiscovery != ARDISCOVERY_OK)
        {
            failed += 1;
            ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
        }
        else
        {
            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "    - (*device)->produitID = %d", (*device)->productID );
            
            ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "    - ARDISCOVERY_Device_InitWifi succeed");
        }
    }
    
    return failed;
}
```


Overlapping Code:
```
TESTBENCH_DeviceControllerAutoTest_initDiscoveryDevice (ARDISCOVERY_Device_t **device)
{
int failed = 0;

eARDISCOVERY_ERROR errorDiscovery = ARDISCOVERY_OK;

ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "- init discovey device ... ");

*device = ARDISCOVERY_Device_New (&errorDiscovery);
if ((errorDiscovery != ARDISCOVERY_OK) || (device == NULL))
{
failed += 1;
ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "device : %p", device);
ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
}

if (errorDiscovery == ARDISCOVERY_OK)
{
ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, " - ARDISCOVERY_Device_InitWifi ...");
#if DEVICE_TYPE == TEST_BEBOP
ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "ARDISCOVERY_PRODUCT_ARDRONE .....................");
errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_ARDRONE, "Bebop", FAKEDRONE_IP_ADDRESS, FAKEDRONE_DISCOVERY_PORT);
#elif DEVICE_TYPE == TEST_JS
ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, "ARDISCOVERY_PRODUCT_JS .....................");
errorDiscovery = ARDISCOVERY_Device_InitWifi ((*device), ARDISCOVERY_PRODUCT_JS, "Js", JS_IP_ADDRESS, JS_DISCOVERY_PORT);
#endif

if (errorDiscovery != ARDISCOVERY_OK)
{
failed += 1;
ARSAL_PRINT(ARSAL_PRINT_ERROR, TAG, "Discovery error :%s", ARDISCOVERY_Error_ToString(errorDiscovery));
}
else
{
ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, " - (*device)->produitID = %d", (*device)->productID );

ARSAL_PRINT(ARSAL_PRINT_INFO, TAG, " - ARDISCOVERY_Device_Ini
```
<Overlap Ratio: 0.9636963696369637>

---

--- 374 --
Question ID: 203cd4a39a43e7bfbc4953442719d1df730e3d98_23
Original Code:
```
bool necro_type_bind_var_to_type_if_instance_of_constraints(NecroPagedArena* arena, NecroType* type, NecroAstSymbol* type_symbol, NecroConstraintList* constraints)
{
    assert(type->type == NECRO_TYPE_VAR);
    assert(!type->var.is_rigid);
    while (constraints != NULL)
    {
        if (constraints->data->type != NECRO_CONSTRAINT_CLASS)
        {
            constraints = constraints->next;
            continue;
        }
        NecroInstanceList* instance_list = type_symbol->instance_list;
        while (instance_list != NULL)
        {
            if (instance_list->data->type_class_name == constraints->data->cls.type_class->type_class_name)
                break;
            instance_list = instance_list->next;
        }
        if (instance_list != NULL)
            constraints = constraints->next;
        else
            return false;
    }
    type->var.bound       = necro_type_con_create(arena, type_symbol, NULL);
    type->var.bound->kind = type_symbol->type->kind;
    return true;
}
```


Overlapping Code:
```
ol necro_type_bind_var_to_type_if_instance_of_constraints(NecroPagedArena* arena, NecroType* type, NecroAstSymbol* type_symbol, NecroConstraintList* constraints)
{
assert(type->type == NECRO_TYPE_VAR);
assert(!type->var.is_rigid);
while (constraints != NULL)
{
if (constraints->data->type != NECRO_CONSTRAINT_CLASS)
{
constraints = constraints->next;
continue;
}
NecroInstanceList* instance_list = type_symbol->instance_list;
while (instance_list != NULL)
{
if (instance_list->data->type_class_name == constraints->data->cls.type_class->type_class_name)
break;
instance_list = instance_list->next;
}
if (instance_list != NULL)
constraints = constraints->next;
else
return false;
}
type->var.bound = necro_type_con_create(arena, type_symbol, NULL);
type->var.bound->kind = type_symbol->type->kind;
ret
```
<Overlap Ratio: 0.984009840098401>

---

--- 375 --
Question ID: 324ab52e8e239c0b500de06d801a779153266470_18
Original Code:
```
Rconnection newWpipe(const char *description, int ienc, const char *mode)
{
    Rconnection new;
    char *command;
    int len;

    new = (Rconnection) malloc(sizeof(struct Rconn));
    if(!new) error(_("allocation of pipe connection failed"));
    new->class = (char *) malloc(strlen("pipe") + 1);
    if(!new->class) {
	free(new);
	error(_("allocation of pipe connection failed"));
    }
    strcpy(new->class, "pipe");

    len = strlen(getenv("COMSPEC")) + strlen(description) + 5;
    command = (char *) malloc(len);
    if (command)
	new->description = (char *) malloc(len);
    else
	new->description = NULL;

    if(!new->description) {
	free(command); free(new->class); free(new);
	error(_("allocation of pipe connection failed"));
    }

    /* We always use COMSPEC here, not R_SHELL or SHELL,
       for compatibility with Rterm.
       We also use /c for the same reason.
    */

    strcpy(command, getenv("COMSPEC"));
    strcat(command, " /c ");
    strcat(command, description);

    init_con(new, command, ienc, mode);
    free(command);

    new->open = &Wpipe_open;
    new->close = &Wpipe_close;
    new->destroy = &Wpipe_destroy;
    new->vfprintf = &Wpipe_vfprintf;
    new->fgetc = &Wpipe_fgetc;
    new->seek = &null_seek;
    new->truncate = &null_truncate;
    new->fflush = &Wpipe_fflush;
    new->read = &Wpipe_read;
    new->write = &Wpipe_write;
    new->private = (void *) malloc(sizeof(struct Wpipeconn));
    if(!new->private) {
	free(new->description); free(new->class); free(new);
	error(_("allocation of pipe connection failed"));
    }
    return new;
}
```


Overlapping Code:
```
t char *description, int ienc, const char *mode)
{
Rconnection new;
char *command;
int len;
new = (Rconnection) malloc(sizeof(struct Rconn));
if(!new) error(_("allocation of pipe connection failed"));
new->class = (char *) malloc(strlen("pipe") + 1);
if(!new->class) {
free(new);
error(_("allocation of pipe connection failed"));
}
strcpy(new->class, "pipe");
len = strlen(getenv("COMSPEC")) + strlen(description) + 5;
command = (char *) malloc(len);
if (command)
new->description = (char *) malloc(len);
else
new->description = NULL;
if(!new->description) {
free(command); free(new->class); free(new);
error(_("allocation of pipe connection failed"));
}
/* We always use COMSPEC here, not R_SHELL or SHELL,
for compatibility with Rterm.
We also use /c for the same reason.
*/
strcpy(command, getenv("COMSPEC"));
strcat(command, " /c ");
strcat(command, description);
init_con(new, command, ienc, mode);
free(command);
new->open = &Wpipe_open;
new->close = &Wpipe_close;
new->destroy = &Wpipe_destroy;
new->vfprintf = &Wpipe_vfprintf;
new->fgetc = &Wpipe_fgetc;
new->seek = &null_seek;
new->truncate = &null_truncate;
new->fflush = &Wpipe_fflush;
new->read = &Wpipe_read;
new->write = &Wpipe_write;
new->private = (void *) malloc(sizeof(struct Wpipeconn));
if(!new->private) {
free(new->description); free(new->class); free(new);
error(_("allocation of pipe connection failed")
```
<Overlap Ratio: 0.969718309859155>

---

--- 376 --
Question ID: e10af0bf03fb8b8639873253027eced624fc1944_11
Original Code:
```
static void actfcn_gauss3(double *data, int N, int d, double *centroid, int K, double beta, double *A) {
	int i, j, K1, j1, it1, ik1;
	double dist, t;
	K1 = K + 1;

	for (i = 0; i < N; ++i) {
		ik1 = i * K1;
		A[ik1] = 1.0;
		it1 = i * d;
		//printf("\n");
		for (j = 1; j < K1; ++j) {
			j1 = j - 1;
			dist = l2(data + it1, centroid + j1*d, d);
			//printf("%g ", dist);
			t = beta *dist;
			A[ik1 + j] = exp(-t*t);
		}
	}
}
```


Overlapping Code:
```
double *data, int N, int d, double *centroid, int K, double beta, double *A) {
int i, j, K1, j1, it1, ik1;
double dist, t;
K1 = K + 1;
for (i = 0; i < N; ++i) {
ik1 = i * K1;
A[ik1] = 1.0;
it1 = i * d;
//printf("\n");
for (j = 1; j < K1; ++j) {
j1 = j - 1;
dist = l2(data + it1, centroid + j1*d, d);
//printf("%g ", dist);
t = beta *dist;
A[ik1 + j] = exp(-t
```
<Overlap Ratio: 0.9086294416243654>

---

--- 377 --
Question ID: 100f2c174bcf5f02e1e83b9f427ce88cc618db58_2
Original Code:
```
int sucet_kladnych(int cisla[], int lenght){
    int posSum = 0, i = 0;
    while(i < lenght){
        if (cisla[i] > 0){
            posSum+= cisla[i];
        }
        i++;
    }

    return posSum;
}
```


Overlapping Code:
```
ch(int cisla[], int lenght){
int posSum = 0, i = 0;
while(i < lenght){
if (cisla[i] > 0){
posSum+= c
```
<Overlap Ratio: 0.6666666666666666>

---

--- 378 --
Question ID: 6220d96b4d72a4c00f134614f1c27d53d88f8623_11
Original Code:
```
static void kupyna512_2048()
{
    static const uint8_t expected[512/8] = {
        0x0D, 0xD0, 0x3D, 0x73, 0x50, 0xC4, 0x09, 0xCB, 0x3C, 0x29, 0xC2, 0x58, 0x93, 0xA0, 0x72, 0x4F,
        0x6B, 0x13, 0x3F, 0xA8, 0xB9, 0xEB, 0x90, 0xA6, 0x4D, 0x1A, 0x8F, 0xA9, 0x3B, 0x56, 0x55, 0x66,
        0x11, 0xEB, 0x18, 0x7D, 0x71, 0x5A, 0x95, 0x6B, 0x10, 0x7E, 0x3B, 0xFC, 0x76, 0x48, 0x22, 0x98,
        0x13, 0x3A, 0x9C, 0xE8, 0xCB, 0xC0, 0xBD, 0x5E, 0x14, 0x36, 0xA5, 0xB1, 0x97, 0x28, 0x4F, 0x7E
    };

    struct kupyna512_ctx_t ctx;
    kupyna512_init(&ctx);
    kupyna512_update(&ctx, test, 2048 / 8);
    kupyna512_final(&ctx, result);
    CU_ASSERT(!memcmp(result, expected, 64));

    kupyna512_init(&ctx);
    kupyna512_update_aligned(&ctx, test, 2048 / 8);
    kupyna512_final(&ctx, result);
    CU_ASSERT(!memcmp(result, expected, 64));
}
```


Overlapping Code:
```

static const uint8_t expected[512/8] = {
0x0D, 0xD0, 0x3D, 0x73, 0x50, 0xC4, 0x09, 0xCB, 0x3C, 0x29, 0xC2, 0x58, 0x93, 0xA0, 0x72, 0x4F,
0x6B, 0x13, 0x3F, 0xA8, 0xB9, 0xEB, 0x90, 0xA6, 0x4D, 0x1A, 0x8F, 0xA9, 0x3B, 0x56, 0x55, 0x66,
0x11, 0xEB, 0x18, 0x7D, 0x71, 0x5A, 0x95, 0x6B, 0x10, 0x7E, 0x3B, 0xFC, 0x76, 0x48, 0x22, 0x98,
0x13, 0x3A, 0x9C, 0xE8, 0xCB, 0xC0, 0xBD, 0x5E, 0x14, 0x36, 0xA5, 0xB1, 0x97, 0x28, 0x4F, 0x7E
};
struct kupyna512_ctx_t ctx;
kupyna512_init(&ctx);
kupyna512_update(&ctx, test, 2048 / 8);
kupyna512_final(&ctx, result);
CU_ASSERT(!memcmp(result, expected, 64));
kupyna512_init(&ctx);
kupyna512_update_aligned(&ctx, test, 2048 / 8);
kupyna512_final(&ctx, result);
CU_ASSERT(!memcmp(result, expected, 64))
```
<Overlap Ratio: 0.9568627450980393>

---

--- 379 --
Question ID: 2510435f34edfd5e10cc4252c6e7dcfa35e95e62_4
Original Code:
```
static int ksz9021_config_intr(struct phy_device *phydev)
{
	int temp, rc;

	/* set the interrupt pin active low */
	temp = phy_read(phydev, MII_KSZPHY_CTRL);
	temp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;
	phy_write(phydev, MII_KSZPHY_CTRL, temp);
	rc = kszphy_set_interrupt(phydev);
	return rc < 0 ? rc : 0;
}
```


Overlapping Code:
```
c int ksz9021_config_intr(struct phy_device *phydev)
{
int temp, rc;
/* set the interrupt pin active low */
temp = phy_read(phydev, MII_KSZPHY_CTRL);
temp &= ~KSZ9021_CTRL_INT_ACTIVE_HIGH;
phy_write(phydev, MII_KSZPHY_CTRL, temp);
rc = kszphy_set_interrupt(phydev);
return rc < 0 ? rc : 
```
<Overlap Ratio: 0.9695945945945946>

---

--- 380 --
Question ID: 2446b2391d762731620c4ba8d3b73a3110382ff3_58
Original Code:
```
float64_t f64_sub( float64_t a, float64_t b )
{
    union ui64_f64 uA;
    uint_fast64_t uiA;
    bool signA;
    union ui64_f64 uB;
    uint_fast64_t uiB;
    bool signB;
#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
    float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
#endif

    uA.f = a;
    uiA = uA.ui;
    signA = signF64UI( uiA );
    uB.f = b;
    uiB = uB.ui;
    signB = signF64UI( uiB );
#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
    if ( signA == signB ) {
        return softfloat_subMagsF64( uiA, uiB, signA );
    } else {
        return softfloat_addMagsF64( uiA, uiB, signA );
    }
#else
    magsFuncPtr =
        (signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;
    return (*magsFuncPtr)( uiA, uiB, signA );
#endif

}
```


Overlapping Code:
```
64_t f64_sub( float64_t a, float64_t b )
{
union ui64_f64 uA;
uint_fast64_t uiA;
bool signA;
union ui64_f64 uB;
uint_fast64_t uiB;
bool signB;
#if ! defined INLINE_LEVEL || (INLINE_LEVEL < 2)
float64_t (*magsFuncPtr)( uint_fast64_t, uint_fast64_t, bool );
#endif
uA.f = a;
uiA = uA.ui;
signA = signF64UI( uiA );
uB.f = b;
uiB = uB.ui;
signB = signF64UI( uiB );
#if defined INLINE_LEVEL && (2 <= INLINE_LEVEL)
if ( signA == signB ) {
return softfloat_subMagsF64( uiA, uiB, signA );
} else {
return softfloat_addMagsF64( uiA, uiB, signA );
}
#else
magsFuncPtr =
(signA == signB) ? softfloat_subMagsF64 : softfloat_addMagsF64;
return (*magsFuncPtr)( uiA, uiB, signA );
#endif

```
<Overlap Ratio: 0.9911634756995582>

---

--- 381 --
Question ID: a3a0958995a6278853e5bfad37034414115c8d1d_45
Original Code:
```
static npy_intp
gallop_left_ubyte(const npy_ubyte *arr, const npy_intp size, const npy_ubyte key)
{
    npy_intp last_ofs, ofs, l, m, r;

    if (UBYTE_LT(arr[size - 1], key)) {
        return size;
    }

    last_ofs = 0;
    ofs = 1;

    for (;;) {
        if (size <= ofs || ofs < 0) {
            ofs = size;
            break;
        }

        if (UBYTE_LT(arr[size - ofs - 1], key)) {
            break;
        } else {
            last_ofs = ofs;
            ofs = (ofs << 1) + 1;
        }
    }

    /* now that arr[size-ofs-1] < key <= arr[size-last_ofs-1] */
    l = size - ofs - 1;
    r = size - last_ofs - 1;

    while (l + 1 < r) {
        m = l + ((r - l) >> 1);

        if (UBYTE_LT(arr[m], key)) {
            l = m;
        } else {
            r = m;
        }
    }

    /* now that arr[r-1] < key <= arr[r] */
    return r;
}
```


Overlapping Code:
```
e(const npy_ubyte *arr, const npy_intp size, const npy_ubyte key)
{
npy_intp last_ofs, ofs, l, m, r;
if (UBYTE_LT(arr[size - 1], key)) {
return size;
}
last_ofs = 0;
ofs = 1;
for (;;) {
if (size <= ofs || ofs < 0) {
ofs = size;
break;
}
if (UBYTE_LT(arr[size - ofs - 1], key)) {
break;
} else {
last_ofs = ofs;
ofs = (ofs << 1) + 1;
}
}
/* now that arr[size-ofs-1] < key <= arr[size-last_ofs-1] */
l = size - ofs - 1;
r = size - last_ofs - 1;
while (l + 1 < r) {
m = l + ((r - l) >> 1);
if (UBYTE_LT(arr[m], key)) {
l = m;
} else {
r = m;
}
}
/* now that arr[r-1] < key <= arr[r] */
return r;

```
<Overlap Ratio: 0.9472843450479234>

---

--- 382 --
Question ID: b76d88a5ae35835cdc06dc1b5a481db684518e29_65
Original Code:
```
struct mcap_mdl *mcap_mdl_ref(struct mcap_mdl *mdl)
{
	mdl->ref++;

	DBG("mcap_mdl_ref(%p): ref=%d", mdl, mdl->ref);

	return mdl;
}
```


Overlapping Code:
```
 mcap_mdl *mdl)
{
mdl->ref++;
DBG("mcap_mdl_ref(%p
```
<Overlap Ratio: 0.3937007874015748>

---

--- 383 --
Question ID: e24c79949eca73d29063e6df033dd14ae4208fab_20
Original Code:
```
void print_msg(const char *fmt, ...)
{
	va_list ap;
	FILE *fp;
	char buf[1024] = {0};
	struct stat statbuff;

	char buffer[1024] = {0};
	
	//sprintf_s(buffer,"[%s,%d]",file_name,file_line);
	sprintf(buffer, "[%02d:%02d:%02d %s,%d]", (ptimes->tm_hour) + 8, ptimes->tm_min, ptimes->tm_sec, file_name, file_line);

	va_start(ap, fmt);
	vsprintf(buf, fmt, ap);
	fp = fopen(LOG_FILE_NAME, "a+");

	if(fp == NULL)
		return;

	int fd = fileno(fp);
	fstat(fd, &statbuff);
	
	if(statbuff.st_size > MAX_LOG_SIZE)
	{
		fclose(fp);
		system("rm -rf " LOG_FILE_NAME);
	}
	else
	{
		if(buffer != NULL)
		{
			strcat(buffer, buf);

			if(buffer[strnlen(buffer,1024) - 1] != '\n') //判断结尾是否换行，没有"\n"则自动补上
				strcat(buffer, "\n");

			fputs(buffer, stdout);
			fputs(buffer, fp);
		}

		//fsync(fd);
		fclose(fp);
	}

	va_end(ap);
	return;
}
```


Overlapping Code:
```
msg(const char *fmt, ...)
{
va_list ap;
FILE *fp;
char buf[1024] = {0};
struct stat statbuff;
char buffer[1024] = {0};

//sprintf_s(buffer,"[%s,%d]",file_name,file_line);
sprintf(buffer, "[%02d:%02d:%02d %s,%d]", (ptimes->tm_hour) + 8, ptimes->tm_min, ptimes->tm_sec, file_name, file_line);
va_start(ap, fmt);
vsprintf(buf, fmt, ap);
fp = fopen(LOG_FILE_NAME, "a+");
if(fp == NULL)
return;
int fd = fileno(fp);
fstat(fd, &statbuff);

if(statbuff.st_size > MAX_LOG_SIZE)
{
fclose(fp);
system("rm -rf " LOG_FILE_NAME);
}
else
{
if(buffer != NULL)
{
strcat(buffer, buf);
if(buffer[strnlen(buffer,1024) - 1] != '\n') //判断结尾是否换行，没有"\n"则自动补上
strcat(buffer, "\n");
fputs(buffer, stdout);
fputs(buffer, fp);
}
//fsync(fd);
fclose(fp);
}
va_end(ap);
return;
}
```
<Overlap Ratio: 0.985545335085414>

---

