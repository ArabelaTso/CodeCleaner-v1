--- 0 --
Question ID: d38394ef5faeccf27b5e0fdae94536904b045835_0
Original Code:
```
pub fn center(txt: &str, space: usize) -> Option<String> {
    // Determine the width of the characters when displayed
    let len = txt.width();
    // Return None if there is not enough space to fit the string
    if len > space {
        return None;
    }
    // Work out total space needed on each side
    let left_over = space - len;
    let each = left_over / 2;
    // Pad the left hand side
    let left_pad = " ".repeat(each);
    // Pad the right hand side
    let right_pad = " ".repeat(left_over - each);
    // Format and return
    Some(format!("{}{}{}", left_pad, txt, right_pad))
}
```


Overlapping Code:
```
space: usize) -> Option<String> {
// Determine the width of the characters when displayed
let len = txt.width();
// Return None if there is not enough space to fit the string
if len > space {
return None;
}
// Work out total space needed on each side
let left_over = space - len;
let each = left_over / 2;
// Pad the left hand side
let left_pad = " ".repeat(each);
// Pad the right hand side
let right_pad = " ".repeat(left_over - each);
// Format and return
Some(format!("{}{}{}", left_pad, txt, rig
```
<Overlap Ratio: 0.9345794392523364>

---

--- 1 --
Question ID: a8db0b5b31478f6f8c1bc9ced0437c56ea77da0e_1
Original Code:
```
pub fn create_theme(opt: &Opt) -> Theme {
    let locations = locations();
    let mut theme = Theme::default();
    if let Some(th) = &opt.theme {
        locations.iter().find(|d| {
            let path = d.join(&format!("{}.toml", th));
            if !path.exists() {
                return false;
            }

            match get_theme(&path) {
                Ok(t) => {
                    theme = t;
                    theme.set_randomization();
                    true
                }
                Err(e) => {
                    error::print_errors(e);
                    false
                }
            }
        });
    }

    theme
}
```


Overlapping Code:
```
t locations = locations();
let mut theme = Theme::default();
if let Some(th) = &opt.theme {
locations.iter().find(|d| {
let path = d.join(&format!("{}.toml", th));
if !path.exists() {
return false;
}
match get_theme(&path) {
Ok(t) => {
theme = t;
theme.set_randomization();
true
}
Err(e) => {
error::
```
<Overlap Ratio: 0.78125>

---

--- 2 --
Question ID: ab688fcf5573e69668dcb8598743abbfef680a36_48
Original Code:
```
fn allows_ints() {
            let mut node = ExpressionNode::from(RangeNode {
                l: Box::new(Some(ExpressionNode::Var(VarNode::new("foo")))),
                r: Box::new(Some(ExpressionNode::from(456))),
                span: None,
            });

            let mut scopes = ScopeTree::default();
            scopes.push_new();
            let sym = Symbol::new("foo", LpcType::Int(false));
            scopes.current_mut().unwrap().insert(sym);
            let context = CompilationContext {
                scopes,
                ..CompilationContext::default()
            };

            let mut walker = SemanticCheckWalker::new(context);
            let _ = node.visit(&mut walker);

            assert!(walker.context.errors.is_empty());
        }
```


Overlapping Code:
```
node = ExpressionNode::from(RangeNode {
l: Box::new(Some(ExpressionNode::Var(VarNode::new("foo")))),
r: Box::new(Some(ExpressionNode::from(456))),
span: None,
});
let mut scopes = ScopeTree::default();
scopes.push_new();
let sym = Symbol::new("foo", LpcType::Int(false));
scopes.current_mut().unwrap().insert(sym);
let context = CompilationContext {
scopes,
..CompilationContext::default()
};
let mut walker = SemanticCheckWalker::new(context);
let _ = node.visit(&mut walker);
assert!(walker.context.errors.is_empty());
}
```
<Overlap Ratio: 0.9508196721311475>

---

--- 3 --
Question ID: c70c78342b41a82ac5b009713c3ea05562899db1_0
Original Code:
```
fn dfs(
    graph: &Graph<Edge>,
    u: usize,
    l: &mut [usize],
    r: &mut [usize],
    p: &mut [usize],
    time: &mut usize,
) {
    *time += 1;
    l[u] = *time;

    for AdjTo{v, ..} in graph.adj_list(u) {
        if l[v] == 0 {
            p[v] = l[u];
            dfs(graph, v, l, r, p, time);
        }
    }

    r[u] = *time;
}
```


Overlapping Code:
```
ph: &Graph<Edge>,
u: usize,
l: &mut [usize],
r: &mut [usize],
p: &mut [usize],
time: &mut usize,
) {
*time += 1;
l[u] = *time;
for AdjTo{v, ..} in graph.adj_list(u) {
if l[v] == 0 {
p[v] = l[u];
dfs(graph, v, l, r, p, time);
```
<Overlap Ratio: 0.8784313725490196>

---

--- 4 --
Question ID: d9efe0ed2e393b8300ba82eb3f7e3f77313eef6c_3
Original Code:
```
fn bindgen_test_layout_UConverterFromUnicodeArgs () { assert_eq ! (:: std :: mem :: size_of :: < UConverterFromUnicodeArgs > () , 56usize , concat ! ("Size of: " , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (:: std :: mem :: align_of :: < UConverterFromUnicodeArgs > () , 8usize , concat ! ("Alignment of " , stringify ! (UConverterFromUnicodeArgs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . flush as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (flush))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . converter as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (converter))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . source as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (source))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . sourceLimit as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (sourceLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . target as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (target))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . targetLimit as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (targetLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UConverterFromUnicodeArgs > ())) . offsets as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (UConverterFromUnicodeArgs) , "::" , stringify ! (offsets))) ; }
```


Overlapping Code:
```
 > () , 8usize , concat ! ("Alignment of " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < ize as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: <  * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: <  const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < s usize } , 24usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: <  const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (deArgs) , "::" , stringify ! (targetLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < usize , concat ! ("Offset of field: " , stringify ! (
```
<Overlap Ratio: 0.4969538729329852>

---

--- 5 --
Question ID: 0ec2a7973349ca2a2a756953a02067d05d6bcb1c_1
Original Code:
```
pub fn decode_typedef_or_ref_token<T: Into<Token>>(token: T) -> DecodedToken {
    let Token(raw_token) = token.into();
    let tag = raw_token & 0b11;
    let idx = raw_token >> 2;
    DecodedToken(
        match tag {
            0 => TableKind::TypeDef.into(),
            1 => TableKind::TypeRef.into(),
            2 => TableKind::TypeSpec.into(),
            _ => unreachable!(),
        },
        idx,
    )
}
```


Overlapping Code:
```
or_ref_token<T: Into<Token>>(token: T) -> DecodedToken {
let Token(raw_token) = token.into();
let tag = raw_token & 0b11;
let idx = raw_token >> 2;
DecodedToken(
match tag {
0 => TableKind::TypeDef.into(),
1 => TableKind::TypeRef.into(),
2 => TableKind::TypeSpec.into(),
_ => unreachable!(),
},
idx,

```
<Overlap Ratio: 0.9230769230769231>

---

--- 6 --
Question ID: 756f72b7d8b65f496211cb0e6494d633662db033_0
Original Code:
```
fn tokenize_test(input: &str, expected: &str) {
    let (tokens, mut diagnostics) = tokenize(input);
    diagnostics.retain(|d| d != &Diagnostic::Valid);
    assert_eq!(diagnostics.as_slice(), []);

    let got = format!("{:#?}", tokens);
    assert_eq!(got.as_str(), expected);
}
```


Overlapping Code:
```
 {
let (tokens, mut diagnostics) = tokenize(input);
diagnostics.retain(|d| d != &Diagnostic::Valid);
assert_eq!(diagnostics.as_slice(), []);
let got = format!("{:#?}", tokens);
assert_eq!(got.as_str()
```
<Overlap Ratio: 0.7722007722007722>

---

--- 7 --
Question ID: 0f964ef47fe7df50a72fa11257c1413277cf8ab0_1
Original Code:
```
fn stop_search_in_tab<TFileSystem: Clone + Debug + Default + FileSystem>(
    tabs: Vec<TabState<TFileSystem>>,
    tab: TabIdx,
) -> Vec<TabState<TFileSystem>> {
    let mut result = Vec::<TabState<TFileSystem>>::new();

    for (idx, tab_state) in tabs.iter().enumerate() {
        if idx == tab {
            result.push(TabState {
                search_mode: false,
                phrase: String::from(""),
                ..tab_state.clone()
            });
        } else {
            result.push(tab_state.clone());
        }
    }

    result
}
```


Overlapping Code:
```
rch_in_tab<TFileSystem: Clone + Debug + Default + FileSystem>(
tabs: Vec<TabState<TFileSystem>>,
tab: TabIdx,
) -> Vec<TabState<TFileSystem>> {
let mut result = Vec::<TabState<TFileSystem>>::new();
for (idx, tab_state) in tabs.iter().enumerate() {
if idx == tab {
result.push(TabState {
search_mode: false,
phrase: String::from(""),
..tab_state.clone()
});
} else {
result.push(tab_state.clone());
}
}
result

```
<Overlap Ratio: 0.9714964370546318>

---

--- 8 --
Question ID: 8ad7974280f098044fedb63f95afe1b6be71ef86_5
Original Code:
```
async fn prune_date64() {
    // work around for not being able to cast Date32 to Date64 automatically
    let date = "2020-01-02"
        .parse::<chrono::NaiveDate>()
        .unwrap()
        .and_time(chrono::NaiveTime::from_hms(0, 0, 0));
    let date = ScalarValue::Date64(Some(date.timestamp_millis()));

    let output = ContextWithParquet::new(Scenario::Dates)
        .await
        .query_with_expr(col("date64").lt(lit(date)))
        // .query(
        //     "SELECT * FROM t where date64 < caste('2020-01-02' as date)",
        // query results in Plan("'Date64 < Date32' can't be evaluated because there isn't a common type to coerce the types to")
        // )
        .await;

    println!("{}", output.description());
    // This should prune out groups  without error
    assert_eq!(output.predicate_evaluation_errors(), Some(0));
    assert_eq!(output.row_groups_pruned(), Some(3));
    assert_eq!(output.result_rows, 1, "{}", output.description());
}
```


Overlapping Code:
```
rune_date64() {
// work around for not being able to cast Date32 to Date64 automatically
let date = "2020-01-02"
.parse::<chrono::NaiveDate>()
.unwrap()
.and_time(chrono::NaiveTime::from_hms(0, 0, 0));
let date = ScalarValue::Date64(Some(date.timestamp_millis()));
let output = ContextWithParquet::new(Scenario::Dates)
.await
.query_with_expr(col("date64").lt(lit(date)))
// .query(
// "SELECT * FROM t where date64 < caste('2020-01-02' as date)",
// query results in Plan("'Date64 < Date32' can't be evaluated because there isn't a common type to coerce the types to")
// )
.await;
println!("{}", output.description());
// This should prune out groups without error
assert_eq!(output.predicate_evaluation_errors(), Some(0));
assert_eq!(output.row_groups_pruned(), Some(3));
assert_eq!(output.result_rows, 1, "{}", 
```
<Overlap Ratio: 0.9599528857479388>

---

--- 9 --
Question ID: 2c041ebea8f5dc28e70bc26be459e8a058631baf_0
Original Code:
```
fn new_user(cred:Form<Credentials>
            ,sess:State<Session>
            ,mut cookies:Cookies
            )->Html<String>{
    let cred = cred.into_inner();
    let sess = sess.inner();
    match sess.ub.add_user(&cred.username, &cred.password) {
        Ok(_)=>{
            let n = sess.add_session(cred.username.clone());
            cookies.add(Cookie::new("session",n.to_string()));
            pages::home_page(&cred.username,0)
        },
        Err(e)=>pages::err_page(e,"/"),
    }
}
```


Overlapping Code:
```
user(cred:Form<Credentials>
,sess:State<Session>
,mut cookies:Cookies
)->Html<String>{
let cred = cred.into_inner();
let sess = sess.inner();
match sess.ub.add_user(&cred.username, &cred.password) {
Ok(_)=>{
let n = sess.add_session(cred.username.clone());
cookies.add(Cookie::new("session",n.to_string()));
pages::home_page(&cred.username,0)
},
Err(
```
<Overlap Ratio: 0.9020618556701031>

---

--- 10 --
Question ID: 12616c0908739002fe6187322e988e46314ee927_1406
Original Code:
```
fn test_P3_Cmp_N5() {
    type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
    type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;

    #[allow(non_camel_case_types)]
    type P3CmpN5 = <A as Cmp<B>>::Output;
    assert_eq!(<P3CmpN5 as Ord>::to_ordering(), Ordering::Greater);
}
```


Overlapping Code:
```
) {
type A = PInt<UInt<UInt<UTerm, B1>, B1>>;
type B = NInt<UInt<UInt<UInt<UTerm, B1>, B0>, B1>>;
#[allow(non_camel_case_types)]
type P3CmpN5 = <A as Cmp<B>>::Output;
assert_eq!(<P3CmpN5 as Ord>::to_or
```
<Overlap Ratio: 0.804>

---

--- 11 --
Question ID: fcea69fb39f98bf184fecd0f9c6a3e9e2e891b0a_1
Original Code:
```
pub fn get_replay_addresses(
    dwarf: &Dwarf<EndianSlice<RunTimeEndian>>,
) -> Result<ObjectLocationMap> {
    let mut objects: ObjectLocationMap = HashMap::new();
    // Iterate over the compilation units.
    let mut iter = dwarf.units();
    while let Some(header) = iter.next()? {
        let unit = dwarf.unit(header)?;
        let entries = parser::parse_variable_entries(&dwarf, &unit, &header)?;
        for entry in entries {
            objects.insert(entry.name, entry.address);
        }
    }
    Ok(objects)
}
```


Overlapping Code:
```
warf<EndianSlice<RunTimeEndian>>,
) -> Result<ObjectLocationMap> {
let mut objects: ObjectLocationMap = HashMap::new();
// Iterate over the compilation units.
let mut iter = dwarf.units();
while let Some(header) = iter.next()? {
let unit = dwarf.unit(header)?;
let entries = parser::parse_variable_entries(&dwarf, &unit, &header)?;
for entry in entries {
objects.insert(entry.name, entry.address);
}

```
<Overlap Ratio: 0.8830022075055187>

---

--- 12 --
Question ID: 0a5d50245436f77e3cb10a335d220ec877d28b1b_3
Original Code:
```
fn should_fail_if_insufficient_receivers() {
    let max_corrupt_receivers = NumberOfNodes::new(1);
    let receivers = set_of(&[node_id(NODE_1), node_id(NODE_2)]);
    let threshold = 2;
    let config_data = NiDkgConfigData {
        max_corrupt_receivers,
        receivers,
        threshold: NumberOfNodes::new(threshold),
        ..valid_dkg_config_data()
    };

    let result = NiDkgConfig::new(config_data);

    assert_eq!(
        result.unwrap_err(),
        NiDkgConfigValidationError::InsufficientReceivers {
            receiver_count: NumberOfNodes::new(2),
            max_corrupt_receivers,
            threshold: dkg_threshold(threshold),
        }
    );
}
```


Overlapping Code:
```
ent_receivers() {
let max_corrupt_receivers = NumberOfNodes::new(1);
let receivers = set_of(&[node_id(NODE_1), node_id(NODE_2)]);
let threshold = 2;
let config_data = NiDkgConfigData {
max_corrupt_receivers,
receivers,
threshold: NumberOfNodes::new(threshold),
..valid_dkg_config_data()
};
let result = NiDkgConfig::new(config_data);
assert_eq!(
result.unwrap_err(),
NiDkgConfigValidationError::InsufficientReceivers {
receiver_count: NumberOfNodes::new(2),
max_corrupt_receivers,
threshold: dkg_thre
```
<Overlap Ratio: 0.9074410163339383>

---

--- 13 --
Question ID: 94f0e35732ff5de7f6c6a9dfcd1b6346522b80cd_1
Original Code:
```
fn it_puts_the_query_params_on_the_uri() {
        let ep = All::default()
            .with_cursor("CURSOR")
            .with_limit(123)
            .with_order(Direction::Desc);
        let req = ep.into_request("https://www.google.com").unwrap();
        assert_eq!(req.uri().path(), "/effects");
        assert_eq!(
            req.uri().query(),
            Some("order=desc&cursor=CURSOR&limit=123")
        );
    }
```


Overlapping Code:
```
 it_puts_the_query_params_on_the_uri() {
let ep = All::default()
.with_cursor("CURSOR")
.with_limit(123)
.with_order(Direction::Desc);
let req = ep.into_request("https://www.google.com").unwrap();
assert_eq!(req.uri().path(), "/effects");
assert_eq!(
req.uri().query(),
Some("order=desc&cursor=CURSOR&limit=123")
);
}
```
<Overlap Ratio: 0.9937304075235109>

---

--- 14 --
Question ID: 5ba01e060b204adf10b9b18a3d1e4142b797623d_0
Original Code:
```
pub fn test_mode(enabled: bool) {
    use crate::pam::TEST_MODE;
    let getal = if enabled { 1 } else { 0 };
    TEST_MODE.store(getal, Ordering::SeqCst);
}
```


Overlapping Code:
```
ed: bool) {
use crate::pam::TEST_MODE;
let getal = if enabled { 1 } else { 0 };
TEST_MODE.store(geta
```
<Overlap Ratio: 0.6896551724137931>

---

--- 15 --
Question ID: 3291454d9441767fcf4857710a9b2dd15cb5e40a_0
Original Code:
```
fn main() {
    let s1 = String::from("Hello world");
    let s2 = s1;
    // s1 is not more valid

    println!("{}, bye", s2);
    let s3 = s2.clone();
    println!(" {} ----- {}", s2, s3);
    take_ownership(s2);
    let i = 0;
    make_copy(i);

    let s2 = give_ownership(s3);
    let il = calculate_len(&s2);
    println!(" {} ----- {}", s2, il);
}
```


Overlapping Code:
```
 main() {
let s1 = String::from("Hello world");
let s2 = s1;
// s1 is not more valid
println!("{}, bye", s2);
let s3 = s2.clone();
println!(" {} ----- {}", s2, s3);
take_ownership(s2);
let i = 0;
make_copy(i);
let s2 = give_ownership(s3);
let il = calculate_len(&s2);
println!(" {} ----- {}", s2, il)
```
<Overlap Ratio: 0.9836065573770492>

---

--- 16 --
Question ID: ac0a0d5709c4081b6449b6ab397e59c2f883da89_0
Original Code:
```
async fn main() {
    tracing_subscriber::fmt::init();

    eprintln!("connecting to localhost:5001...");

    let client = IpfsClient::default();

    match client.name_resolve(Some(IPFS_IPNS), true, false).await {
        Ok(resolved) => eprintln!("{} resolves to: {}", IPFS_IPNS, &resolved.path),
        Err(e) => {
            eprintln!("error resolving {}: {}", IPFS_IPNS, e);
            return;
        }
    }

    let publish = match client.name_publish(IPFS_IPNS, true, None, None, None).await {
        Ok(publish) => {
            eprintln!("published {} to: /ipns/{}", IPFS_IPNS, &publish.name);
            publish
        }
        Err(e) => {
            eprintln!("error publishing name: {}", e);
            return;
        }
    };

    match client.name_resolve(Some(&publish.name), true, false).await {
        Ok(resolved) => {
            eprintln!("/ipns/{} resolves to: {}", &publish.name, &resolved.path);
        }
        Err(e) => {
            eprintln!("error resolving name: {}", e);
        }
    }
}
```


Overlapping Code:
```
async fn main() {
tracing_subscriber::fmt::init();
eprintln!("connecting to localhost:5001...");
let client = IpfsClient::default();
match client.name_resolve(Some(IPFS_IPNS), true, false).await {
Ok(resolved) => eprintln!("{} resolves to: {}", IPFS_IPNS, &resolved.path),
Err(e) => {
eprintln!("error resolving {}: {}", IPFS_IPNS, e);
return;
}
}
let publish = match client.name_publish(IPFS_IPNS, true, None, None, None).await {
Ok(publish) => {
eprintln!("published {} to: /ipns/{}", IPFS_IPNS, &publish.name);
publish
}
Err(e) => {
eprintln!("error publishing name: {}", e);
return;
}
};
match client.name_resolve(Some(&publish.name), true, false).await {
Ok(resolved) => {
eprintln!("/ipns/{} resolves to: {}", &publish.name, &resolved.path);
}
Err(e) => {
eprintln!("error resolv
```
<Overlap Ratio: 0.9703337453646477>

---

--- 17 --
Question ID: 2be71527eb96a5f6fbf86f71d4934e65fcb7e381_26
Original Code:
```
fn test_Aac_Ab() {
    let A1 = array(vec![a(), c()]);
    let A2 = array(vec![b()]);
    let r = PredictionContext::merge(&A1, &A2, root_is_wildcard(), &mut None);
    let expecting = String::new()
        + "digraph G {\n"
        + "rankdir=LR;\n"
        + "  s0[shape=record, label=\"<p0>|<p1>|<p2>\"];\n"
        + "  s1[label=\"*\"];\n"
        + "  s0:p0->s1[label=\"1\"];\n"
        + "  s0:p1->s1[label=\"2\"];\n"
        + "  s0:p2->s1[label=\"3\"];\n"
        + "}\n";
    assert_eq!(expecting, to_dot_string(r, root_is_wildcard()))
}
```


Overlapping Code:
```
);
let A2 = array(vec![b()]);
let r = PredictionContext::merge(&A1, &A2, root_is_wildcard(), &mut None);
let expecting = String::new()
+ "digraph G {\n"
+ "rankdir=LR;\n"
+ " s0[shape=record, label=\"<p0>|<p1>|<p2>\"];\n"
+ " s1[label=\"*\"];\n"
+ " s0:p0->s1[label=\"1\"];\n"
+ " s0:p1->s1[label=\"2\"];\n"
+ " s0:p2->s1[label=\"3\"];\n"
+ "}\n";
assert_eq!(expecting, to_dot_string(r, root_is_wildcard()))
```
<Overlap Ratio: 0.8905908096280087>

---

--- 18 --
Question ID: b3bffd2d765dbc06616b7219943d68de1663a301_27
Original Code:
```
async fn document_symbol() {
            let (service, _) = LspService::new(|_| Mock::default());
            let mut service = Spawn::new(service);

            super::helper::initialize(&mut service).await;

            let params = lsp::DocumentSymbolParams {
                text_document: lsp::TextDocumentIdentifier {
                    uri: lsp::Url::parse("inmemory::///test").unwrap(),
                },
                work_done_progress_params: Default::default(),
                partial_result_params: Default::default(),
            };
            let request: Incoming = helper::request("textDocument/documentSymbol", params).unwrap();
            let response = Response::error(Some(Id::Number(1)), Error::method_not_found());
            assert_eq!(service.poll_ready(), Poll::Ready(Ok(())));
            assert_eq!(
                service.call(request.clone()).await,
                Ok(Some(Outgoing::Response(response)))
            );
        }
```


Overlapping Code:
```
() {
let (service, _) = LspService::new(|_| Mock::default());
let mut service = Spawn::new(service);
super::helper::initialize(&mut service).await;
let params = lsp::DocumentSymbolParams {
text_document: lsp::TextDocumentIdentifier {
uri: lsp::Url::parse("inmemory::///test").unwrap(),
},
work_done_progress_params: Default::default(),
partial_result_params: Default::default(),
};
let request: Incoming = helper::request("textDocument/documentSymbol", params).unwrap();
let response = Response::error(Some(Id::Number(1)), Error::method_not_found());
assert_eq!(service.poll_ready(), Poll::Ready(Ok(())));
assert_eq!(
service.call(request.clone()).await,
Ok(Some(Outgoing::Response(response)))
);
}
```
<Overlap Ratio: 0.9667590027700831>

---

--- 19 --
Question ID: ee27432789a626ce41445807e2d273279f356e2a_0
Original Code:
```
async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
    let configuration = read_config("config.toml");
    let logging = configuration.bot.logging.enabled;

    if logging {
        LogTracer::init()?;

        let base_level = configuration.bot.logging.level.as_str();

        let level = match base_level {
            "error" => Level::ERROR,
            "warn" => Level::WARN,
            "info" => Level::INFO,
            "debug" => Level::DEBUG,
            "trace" => Level::TRACE,
            _ => Level::TRACE
        };

        let subscriber = FmtSubscriber::builder()
            .with_target(false)
            .with_max_level(level)
            .with_env_filter(EnvFilter::from_default_env())
            .finish();

        tracing::subscriber::set_global_default(subscriber)?;

        info!("Tracing initialized with logging level set to {}.", level);
    }

    let appid = configuration.bot.discord.appid;
    let token = configuration.bot.discord.token;
    let prefix = configuration.bot.general.prefix.as_str();

    let http = Http::new_with_token(&token);
    let (owners, bot_id) = match http.get_current_application_info().await {
        Ok(info) => {
            let mut owners = HashSet::new();
            owners.insert(info.owner.id);
            (owners, info.id)
        }
        Err(why) => {
            error!("Unable to retrieve application info: {:?}", why);
            return Ok(());
        }
    };

    let framework = StandardFramework::new()
        .configure(|configuration| {
            configuration
                .on_mention(Some(bot_id))
                .prefix(prefix)
                .ignore_webhooks(false)
                .ignore_bots(true)
                .no_dm_prefix(true)
                .with_whitespace(true)
                .owners(owners)
                .case_insensitivity(true)
        })
        .after(after)
        .prefix_only(prefix_only)
        .on_dispatch_error(dispatch_error)
        .group(&EXTRA_GROUP)
        .group(&FUN_GROUP)
        .group(&INFO_GROUP)
        .group(&MODERATION_GROUP)
        .group(&MUSIC_GROUP)
        .group(&OWNER_GROUP)
        .group(&SEARCH_GROUP)
        .group(&SOCIAL_GROUP)
        .group(&UTILITIES_GROUP)
        .help(&HELP);

    let mut client = ClientBuilder::new(&token)
        .event_handler(Handler)
        .application_id(appid)
        .intents(GatewayIntents::all())
        .framework(framework)
        .await?;

    {
        let mut data = client.data.write().await;

        let url = configuration.bot.database.url;
        let pool = PgPoolOptions::new().max_connections(20).connect(&url).await?;
        let http_client = Client::builder().user_agent(REQWEST_USER_AGENT).redirect(Policy::none()).build()?;

        data.insert::<ConfigContainer>(read_config("config.toml"));
        data.insert::<DatabasePool>(pool);
        data.insert::<ShardManagerContainer>(Arc::clone(&client.shard_manager));
        data.insert::<ReqwestContainer>(http_client);

        {
            let id = configuration.api.music.spotify.client_id;
            let secret = configuration.api.music.spotify.client_secret;
            let credentials = aspotify::ClientCredentials { id, secret };
            let spotify_client = aspotify::Client::new(credentials);
            data.insert::<SpotifyContainer>(spotify_client);
        }
    }

    if let Err(why) = client.start_autosharded().await {
        eprintln!("An error occurred while running the client: {:?}", why);
    }

    Ok(())
}
```


Overlapping Code:
```
async fn main() -> Result<(), Box<dyn Error + Send + Sync>> {
let configuration = read_config("config.toml");
let logging = configuration.bot.logging.enabled;
if logging {
LogTracer::init()?;
let base_level = configuration.bot.logging.level.as_str();
let level = match base_level {
"error" => Level::ERROR,
"warn" => Level::WARN,
"info" => Level::INFO,
"debug" => Level::DEBUG,
"trace" => Level::TRACE,
_ => Level::TRACE
};
let subscriber = FmtSubscriber::builder()
.with_target(false)
.with_max_level(level)
.with_env_filter(EnvFilter::from_default_env())
.finish();
tracing::subscriber::set_global_default(subscriber)?;
info!("Tracing initialized with logging level set to {}.", level);
}
let appid = configuration.bot.discord.appid;
let token = configuration.bot.discord.token;
let prefix = configuration.bot.general.prefix.as_str();
let http = Http::new_with_token(&token);
let (owners, bot_id) = match http.get_current_application_info().await {
Ok(info) => {
let mut owners = HashSet::new();
owners.insert(info.owner.id);
(owners, info.id)
}
Err(why) => {
error!("Unable to retrieve application info: {:?}", why);
return Ok(());
}
};
let framework = StandardFramework::new()
.configure(|configuration| {
configuration
.on_mention(Some(bot_id))
.prefix(prefix)
.ignore_webhooks(false)
.ignore_bots(true)
.no_dm_prefix(true)
.with_whitespace(true)
.owners(owners)
.case_insensitivity(true)
})
.after(after)
.prefix_only(prefix_only)
.on_dispatch_error(dispatch_error)
.group(&EXTRA_GROUP)
.group(&FUN_GROUP)
.group(&INFO_GROUP)
.group(&MODERATION_GROUP)
.group(&MUSIC_GROUP)
.group(&OWNER_GROUP)
.group(&SEARCH_GROUP)
.group(&SOCIAL_GROUP)
.group(&UTILITIES_GROUP)
.help(&HELP);
let mut client = ClientBuilder::new(&token)
.event_handler(Handler)
.application_id(appid)
.intents(GatewayIntents::all())
.framework(framework)
.await?;
{
let mut 
```
<Overlap Ratio: 0.9930107526881721>

---

--- 20 --
Question ID: fea1e0d67b1baa2e1d8b4dc79ce2236954ca0498_1
Original Code:
```
pub async fn into_struct_from_slice<T>(resp: Response<Body>) -> Result<T>
where
    T: de::DeserializeOwned,
{
    // asynchronously concatenate the buffer from a body into bytes
    let bytes = hyper::body::to_bytes(resp).await?;

    // try to parse as json with serde_json
    Ok(serde_json::from_slice(&bytes)?)
}
```


Overlapping Code:
```
to_struct_from_slice<T>(resp: Response<Body>) -> Result<T>
where
T: de::DeserializeOwned,
{
// asynchronously concatenate the buffer from a body into bytes
let bytes = hyper::body::to_bytes(resp).await?;
// try to parse as json with serde_json
Ok(serde_json::from_sl
```
<Overlap Ratio: 0.8986486486486487>

---

--- 21 --
Question ID: ad6448553bad6a18e0be3c2fe80008aa9d54e53c_24
Original Code:
```
async fn do_not_read_network_from_legacy_storage_and_delete_file() {
        // Possible contents of a file generated from KnownEssStore, with networks foo and bar with
        // passwords foobar and password respecitively. Network foo should not be read into new
        // saved network manager because the password is too short for a valid network password.
        let contents = b"[{\"ssid\":[102,111,111],\"password\":[102,111,111,98,97,114]},
            {\"ssid\":[98,97,114],\"password\":[112, 97, 115, 115, 119, 111, 114, 100]}]";
        let temp_dir = TempDir::new().expect("failed to create temporary directory");
        let path = temp_dir.path().join("networks.json");
        let mut file = fs::File::create(&path).expect("failed to open file for writing");

        assert_eq!(file.write(contents).expect("Failed to write to file"), contents.len());
        file.flush().expect("failed to flush contents of file");

        let stash_id = "read_network_from_legacy_storage";
        let saved_networks = SavedNetworksManager::new_with_stash_or_paths(
            stash_id,
            &path,
            create_mock_cobalt_sender(),
        )
        .await
        .expect("failed to create saved networks store");

        // Network should not be read. The backing file should be deleted.
        assert_eq!(0, saved_networks.known_network_count().await);
        assert!(!path.exists());
    }
```


Overlapping Code:
```
y_storage_and_delete_file() {
// Possible contents of a file generated from KnownEssStore, with networks foo and bar with
// passwords foobar and password respecitively. Network foo should not be read into new
// saved network manager because the password is too short for a valid network password.
let contents = b"[{\"ssid\":[102,111,111],\"passworlet temp_dir = TempDir::new().expect("failed to create temporary directory");
let path = temp_dir.path().join("networks.json");
let mut file = fs::File::create(&path).expect("failed to open file for writing");
assert_eq!(file.write(contents).expect("Failed to write to file"), contents.len());
file.flush().expect("failed to flush contents of file");
let stash_id = "read_network_from_legacy_storage";
let saved_networks = SavedNetworksManager::new_with_stash_or_paths(
stash_id,
&path,
create_mock_cobalt_sender(),
)
.await
.expect("failed to create saved networks store");
// Network should not be read. The backing file should be deleted.
assert_eq!(0, saved_networks.known_network_count().await);
ass
```
<Overlap Ratio: 0.8604081632653061>

---

--- 22 --
Question ID: badce57a5d5d436ceb4dd7413877bfcfdf4c6ae6_4
Original Code:
```
fn check_vhost_file_access(host_file_location: &String) -> Result<()> {
    let contents = fs::read_to_string(host_file_location)
        .with_context(|| format!("Unable to open {}",  host_file_location))?;
    let mut file = OpenOptions::new().write(true).truncate(true).open(host_file_location)?;
    file.write(contents.as_bytes())
        .with_context(|| format!("Unable to write to file {}", host_file_location))?;
    file.sync_all()?;
    Ok(())
}
```


Overlapping Code:
```
(host_file_location: &String) -> Result<()> {
let contents = fs::read_to_string(host_file_location)
.with_context(|| format!("Unable to open {}", host_file_location))?;
let mut file = OpenOptions::new().write(true).truncate(true).open(host_file_location)?;
file.write(contents.as_bytes())
.with_context(|| format!("Unable to write to file {}", host_f
```
<Overlap Ratio: 0.8353221957040573>

---

--- 23 --
Question ID: 9cf96a415ee61e2a06b10e1d6062498c19a98764_3
Original Code:
```
fn buffer_length_is_correct_for_server_demand_active() {
    let data = SERVER_DEMAND_ACTIVE.clone();
    let expected_buffer_len = SERVER_DEMAND_ACTIVE_BUFFER.len();

    let len = data.buffer_length();

    assert_eq!(expected_buffer_len, len);
}
```


Overlapping Code:
```
h_is_correct_for_server_demand_active() {
let data = SERVER_DEMAND_ACTIVE.clone();
let expected_buffer_len = SERVER_DEMAND_ACTIVE_BUFFER.len();
let len = data.buffer_length();
assert_eq!(expected_buffer_len, len);

```
<Overlap Ratio: 0.9304347826086956>

---

--- 24 --
Question ID: 919fffee936f4bc984f9df49b0eb53e0d2b00a7e_0
Original Code:
```
fn size_hint() {
		let mut coord = Coordinates::new(Region::from(0, 0, 2, 2));

		assert_eq!(4, coord.size_hint().0);
		coord.next().unwrap();
		assert_eq!(3, coord.size_hint().0);
		coord.next().unwrap();
		assert_eq!(2, coord.size_hint().0);
		coord.next().unwrap();
		assert_eq!(1, coord.size_hint().0);
		coord.next().unwrap();
		assert_eq!(0, coord.size_hint().0);
	}
```


Overlapping Code:
```
oord = Coordinates::new(Region::from(0, 0, 2, 2));
assert_eq!(4, coord.size_hint().0);
coord.next().unwrap();
assert_eq!(3, coord.size_hint().0);
coord.next().unwrap();
assert_eq!(2, coord.size_hint().0);
coord.next().unwrap();
assert_eq!(1, coord.size_hint().0);
coord.next().unwrap();
assert_eq!(0,
```
<Overlap Ratio: 0.8571428571428571>

---

--- 25 --
Question ID: 2bc74d77633e7b155169b3cdb7c93955b7531403_0
Original Code:
```
pub fn start_watcher<TApi>(
    config_path: PathBuf,
    config_directory_path: PathBuf,
    api: std::sync::Arc<futures_util::lock::Mutex<TApi>>,
) where
    TApi: UpdateConfig + Send + 'static,
{
    // DEVNOTE: The channel created for file watcher receiver needs to address up to two messages,
    // since the message is resent to file change receiver using a blocking send.
    // When the number of messages is set to 1, then main thread appears to block.
    let (file_changed_tx, mut file_changed_rx) = tokio::sync::mpsc::channel(2);

    let config_path_clone = config_path.clone();
    let config_directory_path_clone = config_directory_path.clone();

    // Start file change listener that asynchronously reads and updates service config.
    tokio::spawn(async move {
        while let Some(()) = file_changed_rx.recv().await {
            let new_config =
                match crate::read_config(&config_path_clone, Some(&config_directory_path_clone)) {
                    Ok(config) => config,
                    Err(err) => {
                        log::warn!(
                        "Detected config file update, but new config failed to parse. Error: {}",
                        err
                    );
                        continue;
                    }
                };

            let mut api = api.lock().await;

            if let Err(err) = api.update_config(new_config).await {
                log::warn!("Config update failed. Error: {}", err);
            }
        }
    });

    // Start file watcher using blocking channel.
    std::thread::spawn({
        move || {
            let (file_watcher_tx, file_watcher_rx) = std::sync::mpsc::channel();

            // Create a watcher object, delivering debounced events.
            let mut file_watcher =
                notify::watcher(file_watcher_tx, std::time::Duration::from_secs(10)).unwrap();

            // Add configuration paths to be watched.
            if config_directory_path.exists() {
                file_watcher
                    .watch(config_directory_path, notify::RecursiveMode::NonRecursive)
                    .expect("Watching config directory path should not fail.");
            }

            if config_path.exists() {
                file_watcher
                    .watch(config_path, notify::RecursiveMode::NonRecursive)
                    .expect("Watching config file should not fail.");
            }

            loop {
                let event = file_watcher_rx.recv();
                log::debug!("Incoming file watcher event: {:?}", &event);

                if let Ok(event) = event {
                    match event {
                        notify::DebouncedEvent::NoticeWrite(_)
                        | notify::DebouncedEvent::NoticeRemove(_)
                        | notify::DebouncedEvent::Rescan
                        | notify::DebouncedEvent::Error(_, _) => {}

                        notify::DebouncedEvent::Create(_)
                        | notify::DebouncedEvent::Write(_)
                        | notify::DebouncedEvent::Chmod(_)
                        | notify::DebouncedEvent::Remove(_)
                        | notify::DebouncedEvent::Rename(_, _) => {
                            let _ = file_changed_tx.blocking_send(());
                        }
                    };
                }
            }
        }
    });
}
```


Overlapping Code:
```
<TApi>(
config_path: PathBuf,
config_directory_path: PathBuf,
api: std::sync::Arc<futures_util::lock::Mutex<TApi>>,
) where
TApi: UpdateConfig + Send + 'static,
{
// DEVNOTE: The channel created for file watcher receiver needs to address up to two messages,
// since the message is resent to file change receiver using a blocking send.
// When the number of messages is set to 1, then main thread appears to block.
let (file_changed_tx, mut file_changed_rx) = tokio::sync::mpsc::channel(2);
let config_path_clone = config_path.clone();
let config_directory_path_clone = config_directory_path.clone();
// Start file change listener that asynchronously reads and updates service config.
tokio::spawn(async move {
while let Some(()) = file_changed_rx.recv().await {
let new_config =
match crate::read_config(&config_path_clone, Some(&config_directory_path_clone)) {
Ok(config) => config,
Err(err) => {
log::warn!(
"Detected config file update, but new config failed to parse. Error: {}",
err
);
continue;
}
};
let mut api = api.lock().await;
if let Err(err) = api.update_config(new_config).await {
log::warn!("Config update failed. Error: {}", err);
}
}
});
// Start file watcher using blocking channel.
std::thread::spawn({
move || {
let (file_watcher_tx, file_watcher_rx) = std::sync::mpsc::channel();
// Create a watcher object, delivering debounced events.
let mut file_watcher =
notify::watcher(file_watcher_tx, std::time::Duration::from_secs(10)).unwrap();
// Add configuration paths to be watched.
if config_directory_path.exists() {
file_watcher
.watch(config_directory_path, notify::RecursiveMode::NonRecursive)
.expect("Watching config directory path should not fail.");
}
if config_path.exists() {
file_watcher
.watch(config_path, notify::RecursiveMode::NonRecursive)
.expect("Watching config file should not fail.");
}
loop {
let event = fil
```
<Overlap Ratio: 0.9829968119022316>

---

--- 26 --
Question ID: 436c8df3a12786557a9b473da80f4bf93dd92cdb_2
Original Code:
```
pub fn init<Traits: TimerInstance>() {
    let tcfg = &Traits::TICKLESS_CFG;

    // Safety: No context switching during boot
    let tstate = unsafe { &mut *Traits::tickless_state() };

    tstate.reset(tcfg, Traits::time_lo() as u32);
}
```


Overlapping Code:
```
 TimerInstance>() {
let tcfg = &Traits::TICKLESS_CFG;
// Safety: No context switching during boot
let tstate = unsafe { &mut *Traits::tickless_state() };
tstate.reset(tcfg, Traits::time_lo() as u32);

```
<Overlap Ratio: 0.9090909090909091>

---

--- 27 --
Question ID: 586d2ffbdf7dfe3e1a0cfcee430bc0202124cbf5_0
Original Code:
```
pub fn parse_block_size(s: &str) -> Result<usize> {
    let block_size_regex = Regex::new(r"^(?i)(\d+) *(([km])b?)?$").unwrap();
    let captures = block_size_regex.captures(s);

    match captures {
        Some(groups) => {
            let units = groups[1].parse::<usize>().context("Not a number.")?;
            let unit_size = match groups.get(3).map(|m| m.as_str().to_uppercase()) {
                Some(ref u) if u == "K" => 1024,
                Some(ref u) if u == "M" => 1024 * 1024,
                _ => 1,
            };

            let bytes_length = (units * unit_size) as usize;
            if bytes_length & (bytes_length - 1) == 0 {
                Ok((units * unit_size) as usize)
            } else {
                Err(anyhow!("Should be a power of two."))
            }
        }
        _ => Err(anyhow!(
            "Use a number of bytes with optional scale (e.g. 4096, 128k or 2M)."
        )),
    }
}
```


Overlapping Code:
```
> Result<usize> {
let block_size_regex = Regex::new(r"^(?i)(\d+) *(([km])b?)?$").unwrap();
let captures = block_size_regex.captures(s);
match captures {
Some(groups) => {
let units = groups[1].parse::<usize>().context("Not a number.")?;
let unit_size = match groups.get(3).map(|m| m.as_str().to_uppercase()) {
Some(ref u) if u == "K" => 1024,
Some(ref u) if u == "M" => 1024 * 1024,
_ => 1,
};
let bytes_length = (units * unit_size) as usize;
if bytes_length & (bytes_length - 1) == 0 {
Ok((units * unit_size) as usize)
} else {
Err(anyhow!("Should be a power of two."))
}
}
_ => Err(anyhow!(
"Use a number of bytes with optional scale (e.g. 4096, 12
```
<Overlap Ratio: 0.9246088193456614>

---

--- 28 --
Question ID: 04f0a8a0a6f6af3c07c0da8c6821d9c100eb1ad5_1
Original Code:
```
fn parse_coordinate(input: &[u8]) -> IResult<&[u8], Coords> {
    use nom::character::complete::char;
    use nom::character::complete::u16;

    separated_pair(u16, char(','), u16)(input)
}
```


Overlapping Code:
```
te(input: &[u8]) -> IResult<&[u8], Coords> {
use nom::character::complete::char;
use nom::character::complete::u16;
separated_pair(u16, char(','), u16
```
<Overlap Ratio: 0.847457627118644>

---

--- 29 --
Question ID: c6b197af804d779b6b66bba1817ff422da0f548b_3
Original Code:
```
fn has_target_feature(
    name: &str,
    mut has_target_feature: bool,
    version: &Version,
    stabilized: Option<u32>,
) -> bool {
    // HACK: Currently, it seems that the only way that works on the stable is
    // to parse the `-C target-feature` in RUSTFLAGS.
    //
    // - #[cfg(target_feature = "unstable_target_feature")] doesn't work on stable.
    // - CARGO_CFG_TARGET_FEATURE excludes unstable features on stable.
    //
    // As mentioned in the [RFC2045], unstable target features are also passed to LLVM
    // (e.g., https://godbolt.org/z/8Eh3z5Wzb), so this hack works properly on stable.
    //
    // [RFC2045]: https://rust-lang.github.io/rfcs/2045-target-feature.html#backend-compilation-options
    if version.nightly || stabilized.map_or(false, |stabilized| version.minor >= stabilized) {
        has_target_feature = env::var("CARGO_CFG_TARGET_FEATURE")
            .ok()
            .map_or(false, |s| s.split(',').any(|s| s == name));
    } else if let Some(rustflags) = env::var_os("CARGO_ENCODED_RUSTFLAGS") {
        for mut flag in rustflags.to_string_lossy().split('\x1f') {
            if flag.starts_with("-C") {
                flag = &flag["-C".len()..];
            }
            if flag.starts_with("target-feature=") {
                flag = &flag["target-feature=".len()..];
                for s in flag.split(',').filter(|s| !s.is_empty()) {
                    match (s.as_bytes()[0] as char, &s.as_bytes()[1..]) {
                        ('+', f) if f == name.as_bytes() => has_target_feature = true,
                        ('-', f) if f == name.as_bytes() => has_target_feature = false,
                        _ => {}
                    }
                }
            }
        }
    }
    has_target_feature
}
```


Overlapping Code:
```
s_target_feature: bool,
version: &Version,
stabilized: Option<u32>,
) -> bool {
// HACK: Currently, it seems that the only way that works on the stable is
// to parse the `-C target-feature` in RUSTFLAGS.
//
// - #[cfg(target_feature = "unstable_target_feature")] doesn't work on stable.
// - CARGO_CFG_TARGET_FEATURE excludes unstable features on stable.
//
// As mentioned in the [RFC2045], unstable target features are also passed to LLVM
// (e.g., https://godbolt.org/z/8Eh3z5Wzb), so this hack works properly on stable.
//
// [RFC2045]: https://rust-lang.github.io/rfcs/2045-target-feature.html#backend-compilation-options
if version.nightly || stabilized.map_or(false, |stabilized| version.minor >= stabilized) {
has_target_feature = env::var("CARGO_CFG_TARGET_FEATURE")
.ok()
.map_or(false, |s| s.split(',').any(|s| s == name));
} else if let Some(rustflags) = env::var_os("CARGO_ENCODED_RUSTFLAGS") {
for mut flag in rustflags.to_string_lossy().split('\x1f') {
if flag.starts_with("-C") {
flag = &flag["-C".len()..];
}
if flag.starts_with("target-feature=") {
flag = &flag["target-feature=".len()..];
for s in flag.split(',').filter(|s| !s.is_empty()) {
match (s.as_bytes()[0] as char, &s.as_bytes()[1..]) {
('+', f) if f == name.as_bytes() => has_target_feature = true,
('-', f) if f == name.as_bytes() => has_target_feature = false,
_ => {}
}
}
}
}
}
has_tar
```
<Overlap Ratio: 0.9620253164556962>

---

--- 30 --
Question ID: 0147b962adede16e0c5ac55fd62e2ebaf3ba4f6b_4
Original Code:
```
pub async fn download_json(
    client: &reqwest::Client,
    urls: Vec<String>,
) -> Result<Vec<serde_json::Value>, Box<dyn Error>> {
    let vers: Vec<Result<serde_json::Value, Box<dyn Error>>> =
        future::join_all(urls.into_iter().map(|url| async move {
            let json = client
                .get(url)
                .send()
                .await?
                .error_for_status()?
                .json()
                .await?;
            Ok(json)
        }))
        .await;

    let mut vers2: Vec<serde_json::Value> = vec![];

    for v in vers {
        match v {
            Ok(v) => vers2.push(v),
            Err(e) => bail!("Cannot download JSON: {}", e.to_string()),
        };
    }

    Ok(vers2)
}
```


Overlapping Code:
```
 &reqwest::Client,
urls: Vec<String>,
) -> Result<Vec<serde_json::Value>, Box<dyn Error>> {
let vers: Vec<Result<serde_json::Value, Box<dyn Error>>> =
future::join_all(urls.into_iter().map(|url| async move {
let json = client
.get(url)
.send()
.await?
.error_for_status()?
.json()
.await?;
Ok(json)
}))
.await;
let mut vers2: Vec<serde_json::Value> = vec![];
for v in vers {
match v {
Ok(v) => vers2.push(v),
Err(e) => bail!("Cannot download JSON: {}
```
<Overlap Ratio: 0.8653846153846154>

---

--- 31 --
Question ID: 318569367212c7ef19ef5847be4d26f72dbb01bf_7
Original Code:
```
fn test_split() {
        let token = "#".to_string();
        let c: HoardCommand = command_struct("test # test");
        let expected = vec!["test ".to_string(), " test".to_string()];
        assert_eq!(expected, c.split(&token));
    }
```


Overlapping Code:
```
token = "#".to_string();
let c: HoardCommand = command_struct("test # test");
let expected = vec!["test ".to_string(), " test".to_string()];
assert_eq!(expected, c.split(&token));
}
```
<Overlap Ratio: 0.8916256157635468>

---

--- 32 --
Question ID: 8af80106c8e9c874ac74ce54ebabea9db1974f58_2
Original Code:
```
fn test_nested_prefixed_expressions() {
    assert_eq!(
        parse("++42"),
        Ok(Expression(UnaryPrefixOperation(
            PlusSign,
            Box::new(UnaryPrefixOperation(PlusSign, Box::new(Number(42f64))),),
        )))
    );
    assert_eq!(
        parse("+-42"),
        Ok(Expression(UnaryPrefixOperation(
            PlusSign,
            Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),
        )))
    );

    assert_eq!(
        parse("-+-42"),
        Ok(Expression(UnaryPrefixOperation(
            MinusSign,
            Box::new(UnaryPrefixOperation(
                PlusSign,
                Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),
            )),
        )))
    );
}
```


Overlapping Code:
```
t_nested_prefixed_expressions() {
assert_eq!(
parse("++42"),
Ok(Expression(UnaryPrefixOperation(
PlusSign,
Box::new(UnaryPrefixOperation(PlusSign, Box::new(Number(42f64))),),
)))
);
assert_eq!(
parse("+-42"),
Ok(Expression(UnaryPrefixOperation(
PlusSign,
Box::new(UnaryPrefixOperation(MinusSign, Box::new(Number(42f64))),),
)))
);
assert_eq!(
parse("-+-42"),
Ok(Expression(UnaryPrefixOperation(
MinusSign,
Box::new(UnaryPrefixOperation(
PlusSign,
Box::new(UnaryPrefixOperation(MinusSign, Box::new(Num
```
<Overlap Ratio: 0.9363295880149812>

---

--- 33 --
Question ID: 7231263198f52eee4d269390002eab6c1ea91c43_5
Original Code:
```
fn fetch_stream(stream: String) -> Vec<String> {
        let query = format!("%7Btest_name%3D\"{}\"%7D", stream);
        let query = format!(
            "http://localhost:3100/loki/api/v1/query_range?query={}&direction=forward",
            query
        );
        let mut res = reqwest::get(&query).unwrap();

        assert_eq!(res.status(), 200);

        // The response type follows this api https://github.com/grafana/loki/blob/master/docs/api.md#get-lokiapiv1query_range
        // where the result type is `streams`.
        let data = res.json::<serde_json::Value>().unwrap();

        // TODO: clean this up or explain it via docs
        let results = data
            .get("data")
            .unwrap()
            .get("result")
            .unwrap()
            .as_array()
            .unwrap();

        let values = results[0].get("values").unwrap().as_array().unwrap();

        values
            .iter()
            // Lets check the message field of the array where
            // the array looks like: [ts, line].
            .map(|v| v[1].as_str().unwrap().to_string())
            .collect::<Vec<_>>()
    }
```


Overlapping Code:
```
 String) -> Vec<String> {
let query = format!("%7Btest_name%3D\"{}\"%7D", stream);
let query = format!(
"http://localhost:3100/loki/api/v1/query_range?query={}&direction=forward",
query
);
let mut res = reqwest::get(&query).unwrap();
assert_eq!(res.status(), 200);
// The response type follows this api https://github.com/grafana/loki/blob/master/docs/api.md#get-lokiapiv1query_range
// where the result type is `streams`.
let data = res.json::<serde_json::Value>().unwrap();
// TODO: clean this up or explain it via docs
let results = data
.get("data")
.unwrap()
.get("result")
.unwrap()
.as_array()
.unwrap();
let values = results[0].get("values").unwrap().as_array().unwrap();
values
.iter()
// Lets check the message field of the array where
// the array looks like: [ts, line].
.map(|v| v[1].as_str().unwrap().to_string())
.collect::<Vec<_>>()
}
```
<Overlap Ratio: 0.9736540664375716>

---

--- 34 --
Question ID: c42042139752649ce8a3fb1d87121eb546da2213_0
Original Code:
```
fn test_seq_emitting() {
    let vec = vec![vec![1u64, 2], vec![3, 4]];

    let mut driver = SerializeDriver::new(&vec);
    let mut events = Vec::new();
    while let Some((event, _, _)) = driver.next().unwrap() {
        events.push(event.to_static());
    }

    assert_eq!(
        events,
        vec![
            Event::SeqStart,
            Event::SeqStart,
            1u64.into(),
            2u64.into(),
            Event::SeqEnd,
            Event::SeqStart,
            3u64.into(),
            4u64.into(),
            Event::SeqEnd,
            Event::SeqEnd,
        ],
    );
}
```


Overlapping Code:
```
_seq_emitting() {
let vec = vec![vec![1u64, 2], vec![3, 4]];
let mut driver = SerializeDriver::new(&vec);
let mut events = Vec::new();
while let Some((event, _, _)) = driver.next().unwrap() {
events.push(event.to_static());
}
assert_eq!(
events,
vec![
Event::SeqStart,
Event::SeqStart,
1u64.into(),
2u64.into(),
Event::SeqEnd,
Event::SeqStart,
3u64.into(),
4u64.into(),
Event::SeqEnd,
Event::SeqEnd,

```
<Overlap Ratio: 0.966183574879227>

---

--- 35 --
Question ID: d0b5b7c8dd58bbba9369419690d50cafc247e18c_0
Original Code:
```
fn open_file_with(path: &str, opts: Vec<OpenOptions>) -> IO<GluonFile> {
    let mut open_with = fs::OpenOptions::new();

    for opt in opts {
        match opt {
            OpenOptions::Read => open_with.read(true),
            OpenOptions::Write => open_with.write(true),
            OpenOptions::Append => open_with.append(true),
            OpenOptions::Truncate => open_with.truncate(true),
            OpenOptions::Create => open_with.create(true),
            OpenOptions::CreateNew => open_with.create_new(true),
        };
    }

    open_with
        .open(path)
        .map(|file| GluonFile(Mutex::new(Some(file))))
        .into()
}
```


Overlapping Code:
```
tions>) -> IO<GluonFile> {
let mut open_with = fs::OpenOptions::new();
for opt in opts {
match opt {
OpenOptions::Read => open_with.read(true),
OpenOptions::Write => open_with.write(true),
OpenOptions::Append => open_with.append(true),
OpenOptions::Truncate => open_with.truncate(true),
OpenOptions::Create => open_with.create(true),
OpenOptions::CreateNew => open_with.create_new(true),
};
}
open_with
.open(path)
.map(|file| GluonFile(Mutex::new(So
```
<Overlap Ratio: 0.8704061895551257>

---

--- 36 --
Question ID: ead18f7810c59496ea57eb60be925abf8a067436_12
Original Code:
```
fn test_bitvec_set_raw_copy() {
    let v = vec![7];
    let buf = v.as_ptr();
    let mut bitvec = unsafe { BitVec::from_raw_copy(buf, 1, 64) };
    let ptr = bitvec.storage.as_mut_ptr();
    let buffer_len = bitvec.storage.len();
    let mut bitvec2 = BitVec::zeros(1);
    unsafe {
        bitvec2.set_raw_copy(ptr, buffer_len, bitvec.nbits);
    }
    assert_eq!(v.len(), 1); // ensure v lives long enough
    assert_eq!(bitvec2.get(0), Some(true));
    assert_eq!(bitvec2.get(1), Some(true));
    assert_eq!(bitvec2.get(2), Some(true));
    assert_eq!(bitvec2.get(3), Some(false));
    assert_eq!(bitvec2.get(63), Some(false));
    assert_eq!(bitvec2.get(64), None);
}
```


Overlapping Code:
```
 test_bitvec_set_raw_copy() {
let v = vec![7];
let buf = v.as_ptr();
let mut bitvec = unsafe { BitVec::from_raw_copy(buf, 1, 64) };
let ptr = bitvec.storage.as_mut_ptr();
let buffer_len = bitvec.storage.len();
let mut bitvec2 = BitVec::zeros(1);
unsafe {
bitvec2.set_raw_copy(ptr, buffer_len, bitvec.nbits);
}
assert_eq!(v.len(), 1); // ensure v lives long enough
assert_eq!(bitvec2.get(0), Some(true));
assert_eq!(bitvec2.get(1), Some(true));
assert_eq!(bitvec2.get(2), Some(true));
assert_eq!(bitvec2.get(3), Some(false));
assert_eq!(bitvec2.get(63), Some(false));
assert_eq!(bitvec2.get(64), None)
```
<Overlap Ratio: 0.9917355371900827>

---

--- 37 --
Question ID: f238826e4b4a7216f9dbdd3263e5275544b144b2_5
Original Code:
```
async fn deduplicates_bsses_from_multiple_networks() {
            let mut cache = RealBssCache::new();
            let result = cache
                .update(FakeScanResultIterator::new_single_step(vec![
                    ScanResult {
                        id: None,
                        entries: Some(vec![WlanPolicyBss {
                            bssid: Some([0, 1, 2, 3, 4, 5]),
                            rssi: Some(-1),
                            frequency: Some(2412),
                            timestamp_nanos: Some(1),
                            ..WlanPolicyBss::EMPTY
                        }]),
                        compatibility: None,
                        ..ScanResult::EMPTY
                    },
                    ScanResult {
                        id: None,
                        entries: Some(vec![WlanPolicyBss {
                            bssid: Some([0, 1, 2, 3, 4, 5]),
                            rssi: Some(-2),
                            frequency: Some(2432),
                            timestamp_nanos: Some(2),
                            ..WlanPolicyBss::EMPTY
                        }]),
                        compatibility: None,
                        ..ScanResult::EMPTY
                    },
                ]))
                .await;
            assert_eq!(result, Ok(()));

            let mut bsses = cache.iter();
            assert_matches!(bsses.next(), Some((&[0, 1, 2, 3, 4, 5], _)));
            assert_eq!(bsses.next(), None);
        }
```


Overlapping Code:
```
ple_networks() {
let mut cache = RealBssCache::new();
let result = cache
.update(FakeScanResultIterator::new_single_step(vec![
ScanResult {
id: None,
entries: Some(vec![WlanPolicyBss {
bssid: Some([0, 1, 2, 3, 4, 5]),
rssi: Some(-1),
frequency: Some(2412),
timestamp_nanos: Some(1),
..WlanPolicyBss::EMPTY
}]),
compatibility: None,
..ScanResult::EMPTY
},
ScanResult {
id: None,
entries: Some(vec![WlanPolicyBss {
bssid: Some([0, 1, 2, 3, 4, 5]),
rssi: Some(-2),
frequency: Some(2432),
timestamp_nanos: Some(2),
..WlanPolicyBss::EMPTY
}]),
compatibility: None,
..ScanResult::EMPTY
},
]))
.await;
assert_eq!(result, Ok(()));
let mut bsses = cache.iter();
assert_matches!(bsses.next(), Some((&[0, 1, 2, 3, 4, 5], _)));
assert_eq!(bsses.nex
```
<Overlap Ratio: 0.9351969504447268>

---

--- 38 --
Question ID: 606daf72d736c3733db174fdf1211797033d2d8d_0
Original Code:
```
fn webpage(name: String, visitor: State<VisitorCounter>) -> Template {
    let mut context = HashMap::new();
    context.insert("name", name);
    let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);
    context.insert("visitor_number", current.to_string());
    Template::render("webpage", &context)
}
```


Overlapping Code:
```
State<VisitorCounter>) -> Template {
let mut context = HashMap::new();
context.insert("name", name);
let current = visitor.visitor_number.fetch_add(1, Ordering::SeqCst);
context.insert("visitor_number", current.to_string());
Template::render("webpage
```
<Overlap Ratio: 0.8389261744966443>

---

--- 39 --
Question ID: b4aa6fd294238560ec0b536139b18353cf0107ac_0
Original Code:
```
fn main() {
    let ron_path = format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "ron");
    match ExampleConfig::load(&ron_path) {
        Ok(cfg) => {
            println!("RON Config Result:\n{:#?}", cfg);

            if let Err(e) = cfg.write_format(ConfigFormat::Ron, &ron_path) {
                println!("Error:\n{}", e);
            }
        }
        Err(e) => println!("{:?}", e),
    }

    #[cfg(feature = "json")]
    {
        let json_path = format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "json");
        match ExampleConfig::load(&json_path) {
            Ok(cfg) => {
                println!("JSON Config Result:\n{:#?}", cfg);

                if let Err(e) = cfg.write_format(ConfigFormat::Json, &json_path) {
                    println!("Error:\n{}", e);
                }
            }
            Err(e) => println!("{:?}", e),
        }
    }

    #[cfg(feature = "binary")]
    {
        let binary_path = format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "bin");
        match ExampleConfig::load(&binary_path) {
            Ok(cfg) => {
                println!("Binary Config Result:\n{:#?}", cfg);

                if let Err(e) = cfg.write_format(ConfigFormat::Binary, &binary_path) {
                    println!("Error:\n{}", e);
                }
            }
            Err(e) => println!("{:?}", e),
        }
    }
}
```


Overlapping Code:
```
 format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "ron");
match ExampleConfig::load(&ron_path) {
Ok(cfg) => {
println!("RON Config Result:\n{:#?}", cfg);
if let Err(e) = cfg.write_format(ConfigFormat::Ron, &ron_path) {
println!("Error:\n{}", e);
}
}
Err(e) => println!("{:?}", e),
}
#[cfg(feature = "json")]
{
let json_path = format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "json");
match ExampleConfig::load(&json_path) {
Ok(cfg) => {
println!("JSON Config Result:\n{:#?}", cfg);
if let Err(e) = cfg.write_format(ConfigFormat::Json, &json_path) {
println!("Error:\n{}", e);
}
}
Err(e) => println!("{:?}", e),
}
}
#[cfg(feature = "binary")]
{
let binary_path = format!("{}/examples/config.{}", env!("CARGO_MANIFEST_DIR"), "bin");
match ExampleConfig::load(&binary_path) {
Ok(cfg) => {
println!("Binary Config Result:\n{:#?}", cfg);
if let Err(e) = cfg.write_format(ConfigFormat::Binary, &binary_path) {
println!("Error:\n{}",
```
<Overlap Ratio: 0.930460333006856>

---

--- 40 --
Question ID: 35566c0b1d436852b987c6efff410545cd18a5fd_5
Original Code:
```
pub fn get_padded_node_len<'a>(reader: &Reader<'a>, node_name: &str) -> usize {
    let root = reader.struct_items();
    let (node, _) = root.path_struct_items(node_name).next().unwrap();

    let node_len = TOKEN_SIZE + node.node_name().unwrap().len();
    let padded_node_len = node_len + (node_len % 4);
    padded_node_len
}
```


Overlapping Code:
```
a>, node_name: &str) -> usize {
let root = reader.struct_items();
let (node, _) = root.path_struct_items(node_name).next().unwrap();
let node_len = TOKEN_SIZE + node.node_name().unwrap().len();
let padded_node_len = node_len + (node_len % 4);
padded_
```
<Overlap Ratio: 0.8116883116883117>

---

--- 41 --
Question ID: 10c37d13c9d7737d94a2336977e75af31c3fabea_1
Original Code:
```
fn _0002() {
  let scope = scope!();
  scope.set_entry(&"  \n  \n  \t  thing \n \t \t ".into(), value_null!());
  accept(
    &scope,
    StartTextualExpression,
    "thing",
    r#"
       Name
       └─ `thing`
    "#,
    false,
  );
}
```


Overlapping Code:
```
cope.set_entry(&" \n \n \t thing \n \t \t ".into(), value_null!());
accept(
&scope,
StartTextualExpression,
"thing",
r#"
Name
└─ `thing`
"#,
false,
);
```
<Overlap Ratio: 0.7978723404255319>

---

--- 42 --
Question ID: 7a907a172847881dbf26c6ede66f2c73522f7f89_1
Original Code:
```
fn test_initialize() {
    let (_, api) = create_testkit(InitParam {
        v_bit_len: vec![16],
        is_acc2: true,
        intra_index: true,
        skip_list_max_level: 2,
    });
    let param = api.get_param();
    assert_eq!(param.v_bit_len, vec![16]);
    assert_eq!(param.acc_type, acc::Type::ACC2);
    assert_eq!(param.use_sk, false);
    assert_eq!(param.intra_index, true);
    assert_eq!(param.skip_list_max_level, 2);
}
```


Overlapping Code:
```
) = create_testkit(InitParam {
v_bit_len: vec![16],
is_acc2: true,
intra_index: true,
skip_list_max_level: 2,
});
let param = api.get_param();
assert_eq!(param.v_bit_len, vec![16]);
assert_eq!(param.acc_type, acc::Type::ACC2);
assert_eq!(param.use_sk, false);
assert_eq!(param.intra_index, true);
ass
```
<Overlap Ratio: 0.8021390374331551>

---

--- 43 --
Question ID: 2d9442a0eeb0611cd72b50be9fa941550e358003_4
Original Code:
```
fn test_next_in_subdir() {
        let d = dir();
        let p = LogPath::new(&d, 123).next().unwrap();
        assert_eq!(p.seq_num(), 124);
        assert_eq!(p.path(), dir().join("000000124.devlog"));
    }
```


Overlapping Code:
```
est_next_in_subdir() {
let d = dir();
let p = LogPath::new(&d, 123).next().unwrap();
assert_eq!(p.seq_num(), 124);
assert_eq!(p.path(), dir().join("00
```
<Overlap Ratio: 0.8620689655172413>

---

--- 44 --
Question ID: 772e287872dbb47fac16dfc09bdd21146efdf8e3_0
Original Code:
```
pub fn parse_chart(g: &Grammar, input: &[&str]) -> Chart {
  let mut chart = Chart::new(input.len() + 1);

  for rule in g.rules.get(&g.start).expect("grammar missing start rules") {
    chart.add(0, State::new(LR0::new(&rule), 0));
  }

  for k in 0..chart.len() {
    // need to use while loop because the number of states at k can expand during the loop
    let mut idx = 0;
    while idx < chart.len_at(k) {
      let state = chart.get_state(k, idx);
      idx += 1;

      if let Some(production) = state.lr0.next_production() {
        if production.is_nonterminal() {
          predictor(g, &mut chart, k, &state);
        } else {
          scanner(&mut chart, k, &state, input);
        }
      } else {
        completer(&mut chart, k, &state);
      }
    }
  }

  chart
}
```


Overlapping Code:
```
nput: &[&str]) -> Chart {
let mut chart = Chart::new(input.len() + 1);
for rule in g.rules.get(&g.start).expect("grammar missing start rules") {
chart.add(0, State::new(LR0::new(&rule), 0));
}
for k in 0..chart.len() {
// need to use while loop because the number of states at k can expand during the loop
let mut idx = 0;
while idx < chart.len_at(k) {
let state = chart.get_state(k, idx);
idx += 1;
if let Some(production) = state.lr0.next_production() {
if production.is_nonterminal() {
predictor(g, &mut chart, k, &state);
} else {
scanner(&mut chart, k, &state, input);
}
} else {
completer(&mut 
```
<Overlap Ratio: 0.9022556390977443>

---

--- 45 --
Question ID: 976070c649d0db7bbc274371fdedab5a49d4603e_12
Original Code:
```
fn nontrivial_identity_syntactic() {
    // dnf (!a * !b * !c) + (!a * !b * c) + (!a * b * c) + (a * !b * c) + (a * b * !c)
    //                                    <=>
    // cnf            !(!a * b * !c) * !(a * !b * !c) * !(a * b * c)
    let variables = mk_5_variable_set();
    let a = variables.mk_var(v1());
    let b = variables.mk_var(v2());
    let c = variables.mk_var(v3());

    let d1 = bdd!(((!a) & (!b)) & (!c));
    let d2 = bdd!(((!a) & (!b)) & c);
    let d3 = bdd!(((!a) & b) & c);
    let d4 = bdd!((a & (!b)) & c);
    let d5 = bdd!((a & b) & (!c));

    let c1 = bdd!((a | (!b)) | c);
    let c2 = bdd!(((!a) | b) | c);
    let c3 = bdd!(((!a) | (!b)) | (!c));

    let cnf = bdd!(((c1 & c2) & c3));
    let dnf = bdd!(((((d1 | d2) | d3) | d4) | d5));

    assert_eq!(cnf, dnf);
    assert!(bdd!((cnf <=> dnf)).is_true());
    assert_eq!(20.0, cnf.cardinality());
}
```


Overlapping Code:
```
actic() {
// dnf (!a * !b * !c) + (!a * !b * c) + (!a * b * c) + (a * !b * c) + (a * b * !c)
// <=>
// cnf !(!a * b * !c) * !(a * !b * !c) * !(a * b * c)
let variables = mk_5_variable_set();
let a = variables.mk_var(v1());
let b = variables.mk_var(v2());
let c = variables.mk_var(v3());
let d1 = bdd!(((!a) & (!b)) & (!c));
let d2 = bdd!(((!a) & (!b)) & c);
let d3 = bdd!(((!a) & b) & c);
let d4 = bdd!((a & (!b)) & c);
let d5 = bdd!((a & b) & (!c));
let c1 = bdd!((a | (!b)) | c);
let c2 = bdd!(((!a) | b) | c);
let c3 = bdd!(((!a) | (!b)) | (!c));
let cnf = bdd!(((c1 & c2) & c3));
let dnf = bdd!(((((d1 | d2) | d3) | d4) | d5));
assert_eq!(cnf, dnf);
assert!(bdd!((cnf <=> dnf)).is_true());
assert
```
<Overlap Ratio: 0.922266139657444>

---

--- 46 --
Question ID: 2a7f1ec01831b9ec8306a324ede6d31050ecea54_7
Original Code:
```
fn test_from_config_date() {
        let mut c = Config::with_none();
        c.date = Some("date".into());

        assert_eq!(Some(DateFlag::Date), DateFlag::from_config(&c));
    }
```


Overlapping Code:
```
est_from_config_date() {
let mut c = Config::with_none();
c.date = Some("date".into());
assert_eq!(Some(DateFlag::Date), DateFlag::from_config(&c));
}
```
<Overlap Ratio: 0.974025974025974>

---

--- 47 --
Question ID: 37c4cb5bbcfed34b2a7de92da82bea807a2e2fe4_3
Original Code:
```
fn can_generate_simple_enum() {
    let mut lang = swift::Swift::new();
    let mut g = Generator::new(
        &mut lang,
        Params {
            use_marker: false,
            swift_prefix: "TypeShare".to_string(),
            java_package: "".to_string(),
        },
    );

    let source = r##"
/// This is a comment.
pub enum Colors {
	Red = 0,
	Blue = 1,
	Green = 2,
}
   
"##;

    let mut out: Vec<u8> = Vec::new();
    assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
    let result = String::from_utf8(out).unwrap();

    let expected = format!(
        "/*
 Generated by typeshare {}
*/

import Foundation

/// This is a comment.
public enum TypeShareColors: Int, Codable {{
	case Red = 0
	case Blue = 1
	case Green = 2
}}

",
        env!("CARGO_PKG_VERSION")
    );

    if expected != result {
        text_diff::print_diff(&expected, &result, " ");
    }
    assert_eq!(expected, result);
}
```


Overlapping Code:
```
 mut lang = swift::Swift::new();
let mut g = Generator::new(
&mut lang,
Params {
use_marker: false,
swift_prefix: "TypeShare".to_string(),
java_package: "".to_string(),
},
);
let source = r##"
/// This is a comment.
pub enum Colors {
Red = 0,
Blue = 1,
Green = 2,
}

"##;
let mut out: Vec<u8> = Vec::new();
assert!(g.process_source(source.to_string(), &mut out).is_ok(), "must be able to process the source");
let result = String::from_utf8(out).unwrap();
let expected = format!(
"/*
Generated by typeshare {}
*/
import Foundation
/// This is a comment.
public enum TypeShareColors: Int, Codable {{
case Red = 0
case Blue = 1
case Green = 2
}}
",
env!("CARGO_PKG_VERSION")
);
if expected != result {
text_diff::print_diff(&expected, &result, " ");
}
assert_eq!(expected, resu
```
<Overlap Ratio: 0.9497549019607843>

---

--- 48 --
Question ID: 378b0c384de771b6b3e18cc42ab0e276a648fb5b_1
Original Code:
```
fn test_n_triples_parse_literal() {
        let input = "\"a\"".as_bytes();

        let mut lexer = NTriplesLexer::new(input);

        assert_eq!(
            lexer.get_next_token().unwrap(),
            Token::Literal("a".to_string())
        );
    }
```


Overlapping Code:
```
et input = "\"a\"".as_bytes();
let mut lexer = NTriplesLexer::new(input);
assert_eq!(
lexer.get_next_token().unwrap(),
Token::Literal("a".to_string())
```
<Overlap Ratio: 0.78125>

---

--- 49 --
Question ID: bbc5f888886d49b631e2442b748df5b774b59179_1
Original Code:
```
async fn run_server(addr: SocketAddr, rx: watch::Receiver<Vec<u8>>) {
    println!("Listening on http://{}", addr);
    // Bind the Hyper HTTP server to addr and start serving requests.
    let serve_future = Server::bind(&addr)
        .serve(make_service_fn(|_| {
            // This function is invoked on every request.
            // We need to clone rx to avoid moving it to this request.
            let my_rx = rx.clone();
            async {
                // We need to clone my_rx because of the async block.
                Ok::<_, hyper::Error>(service_fn(move |_req| serve_req(_req, my_rx.clone() )))
            }
        }));

    if let Err(e) = serve_future.await {
        eprintln!("Server error: {}", e);
    }
}
```


Overlapping Code:
```
run_server(addr: SocketAddr, rx: watch::Receiver<Vec<u8>>) {
println!("Listening on http://{}", addr);
// Bind the Hyper HTTP server to addr and start serving requests.
let serve_future = Server::bind(&addr)
.serve(make_service_fn(|_| {
// This function is invoked on every request.
// We need to clone rx to avoid moving it to this request.
let my_rx = rx.clone();
async {
// We need to clone my_rx because of the async block.
Ok::<_, hyper::Error>(service_fn(move |_req| serve_req(_req, my_rx.clone() )))
}
}));
if let Err(e) = serve_future.await {
epr
```
<Overlap Ratio: 0.9279731993299832>

---

--- 50 --
Question ID: 977214e75800d0332ff5afeaa8695c47d93db661_13
Original Code:
```
fn get_server_response<D: DelayUs>(
    spi_drv: &mut SpiDrv,
    uart: &mut EnabledUart,
    delay: &mut D,
    socket: u8,
) -> Result<httparse::Status<usize>, String<STR_LEN>> {
    let response_length: u16 = 0;
    let mut avail_length: usize = 0;
    let n = 0;
    let response_buf: [u8; RESPONSE_BUF_LEN] = [0; RESPONSE_BUF_LEN];
    let mut timeout: u16 = 1000;

    while timeout > 0 {
        delay.delay_ms(50).ok().unwrap();
        avail_length = avail_data(spi_drv, uart, socket)?;
        if avail_length > 0 {
            break;
        }

        timeout -= 1;
    }

    write!(
        uart,
        "\tresponse_length: {:?} avail_length {:?}\r\n",
        response_length, avail_length
    )
    .ok()
    .unwrap();

    let response_buf = get_data_buf(spi_drv, uart, socket, avail_length as u16)?;
    let response_str = core::str::from_utf8(&response_buf).unwrap();

    writeln!(
        uart,
        "\tHTTP server response string: {:?}\r\n",
        response_str
    )
    .ok()
    .unwrap();

    let mut headers = [httparse::EMPTY_HEADER; 64];
    let mut response = httparse::Response::new(&mut headers);
    match response.parse(&response_buf) {
        Ok(parsed) => {
            write!(
                uart,
                "HTTP response version: {:?}\r\n",
                response.version.unwrap()
            )
            .ok()
            .unwrap();
            write!(uart, "HTTP response code: {:?}\r\n", response.code.unwrap())
                .ok()
                .unwrap();
            writeln!(
                uart,
                "HTTP response reason: {:?}\r\n",
                response.reason.unwrap()
            )
            .ok()
            .unwrap();

            if response.code.unwrap() == 200 {
                write!(uart, "Got successful response from HTTP server.\r\n")
                    .ok()
                    .unwrap();
            } else if response.code.unwrap() == 400 {
                write!(uart, "** Got error response from HTTP server.\r\n")
                    .ok()
                    .unwrap();
            }
            return Ok(parsed);
        }

        Err(e) => {
            write!(uart, "Failed to parse HTTP server response: {:?}\r\n", e)
                .ok()
                .unwrap();
            return Err(String::from("Failed to parse HTTP server response"));
        }
    }
}
```


Overlapping Code:
```
se<D: DelayUs>(
spi_drv: &mut SpiDrv,
uart: &mut EnabledUart,
delay: &mut D,
socket: u8,
) -> Result<httparse::Status<usize>, String<STR_LEN>> {
let response_length: u16 = 0;
let mut avail_length: usize = 0;
let n = 0;
let response_buf: [u8; RESPONSE_BUF_LEN] = [0; RESPONSE_BUF_LEN];
let mut timeout: u16 = 1000;
while timeout > 0 {
delay.delay_ms(50).ok().unwrap();
avail_length = avail_data(spi_drv, uart, socket)?;
if avail_length > 0 {
break;
}
timeout -= 1;
}
write!(
uart,
"\tresponse_length: {:?} avail_length {:?}\r\n",
response_length, avail_length
)
.ok()
.unwrap();
let response_buf = get_data_buf(spi_drv, uart, socket, avail_length as u16)?;
let response_str = core::str::from_utf8(&response_buf).unwrap();
writeln!(
uart,
"\tHTTP server response string: {:?}\r\n",
response_str
)
.ok()
.unwrap();
let mut headers = [httparse::EMPTY_HEADER; 64];
let mut response = httparse::Response::new(&mut headers);
match response.parse(&response_buf) {
Ok(parsed) => {
write!(
uart,
"HTTP response version: {:?}\r\n",
response.version.unwrap()
)
.ok()
.unwrap();
write!(uart, "HTTP response code: {:?}\r\n", response.code.unwrap())
.ok()
.unwrap();
writeln!(
uart,
"HTTP response reason: {:?}\r\n",
response.reason.unwrap()
)
.ok()
.unwrap();
if response.code.unwrap() == 200 {
write!(uart, "Got successful response from HTTP server.\r\n")
.ok()
.unwrap();
} else if response.code.unwrap() == 400 {
write!(uart, "** Got error response from HTTP server.\r\n")
.ok()
.unwrap();
}
return Ok(parsed);
}
Err(e) => {
write!(uart, "Failed to parse HTTP server response: {:?}\r\n", e)
.ok()
.unwrap();
return Err(String::from("Failed to parse HTTP server 
```
<Overlap Ratio: 0.9774881516587678>

---

--- 51 --
Question ID: 14650697c31b96dbd3fd6946ab01a9d8b60a3c69_1
Original Code:
```
async fn full_rewind() {
        let underlying = [104, 101, 108, 108, 111];

        let mock = tokio_test::io::Builder::new().read(&underlying).build();

        let mut stream = Rewind::new(mock);

        let mut buf = [0; 5];
        stream.read_exact(&mut buf).await.expect("read1");

        // Rewind the stream so that it is as if we never read in the first place.
        stream.rewind(Bytes::copy_from_slice(&buf[..]));

        let mut buf = [0; 5];
        stream.read_exact(&mut buf).await.expect("read1");
    }
```


Overlapping Code:
```
01, 108, 108, 111];
let mock = tokio_test::io::Builder::new().read(&underlying).build();
let mut stream = Rewind::new(mock);
let mut buf = [0; 5];
stream.read_exact(&mut buf).await.expect("read1");
// Rewind the stream so that it is as if we never read in the first place.
stream.rewind(Bytes::copy_from_slice(&buf[..]));
let mut buf = [0; 5];
stream.read_exact(&mut 
```
<Overlap Ratio: 0.8247191011235955>

---

--- 52 --
Question ID: 74e251808f8357c43b87e9238e44b8960592c1d4_9
Original Code:
```
fn test_from_string() {
    assert_eq!("0", FeelNumber::from_string("0").to_string());
    assert_eq!("-0", FeelNumber::from_string("-0").to_string());
    assert_eq!("1", FeelNumber::from_string("1").to_string());
    assert_eq!("-1", FeelNumber::from_string("-1").to_string());
    assert_eq!("1.23456789", FeelNumber::from_string("1.23456789").to_string());
    assert_eq!("-1.23456789", FeelNumber::from_string("-1.23456789").to_string());
  }
```


Overlapping Code:
```
rt_eq!("0", FeelNumber::from_string("0").to_string());
assert_eq!("-0", FeelNumber::from_string("-0").to_string());
assert_eq!("1", FeelNumber::from_string("1").to_string());
assert_eq!("-1", FeelNumber::from_string("-1").to_string());
assert_eq!("1.23456789", FeelNumber::from_string("1.23456789").to_string());
assert_eq!("-1.23456789", FeelNumber:
```
<Overlap Ratio: 0.831353919239905>

---

--- 53 --
Question ID: e0c0885fe3e34bd594657dc9b93874c7cb20d856_0
Original Code:
```
fn to_diagram(src: &str) -> (String, Vec<(&'static str, String)>) {
    let macro_rules = macro_railroad::parser::parse(&src).expect(src);
    let mut tree = macro_railroad::lowering::MacroRules::from(macro_rules);
    let name = tree.name.clone();
    let mut v = Vec::new();

    v.push((
        "vanilla",
        macro_railroad::diagram::into_diagram(tree.clone(), true).to_string(),
    ));

    let mut tree_ungrouped = tree.clone();
    tree_ungrouped.ungroup();
    v.push((
        "ungrouped",
        macro_railroad::diagram::into_diagram(tree_ungrouped, false).to_string(),
    ));

    tree.remove_internal();
    tree.foldcommontails();
    tree.normalize();
    v.push((
        "optimized",
        macro_railroad::diagram::into_diagram(tree, true).to_string(),
    ));

    (name, v)
}
```


Overlapping Code:
```
(src: &str) -> (String, Vec<(&'static str, String)>) {
let macro_rules = macro_railroad::parser::parse(&src).expect(src);
let mut tree = macro_railroad::lowering::MacroRules::from(macro_rules);
let name = tree.name.clone();
let mut v = Vec::new();
v.push((
"vanilla",
macro_railroad::diagram::into_diagram(tree.clone(), true).to_string(),
));
let mut tree_ungrouped = tree.clone();
tree_ungrouped.ungroup();
v.push((
"ungrouped",
macro_railroad::diagram::into_diagram(tree_ungrouped, false).to_string(),
));
tree.remove_internal();
tree.foldcommontails();
tree.normalize();
v.push((
"optimized",
macro_railroad::diagram::into_diagram(tree, true).to_s
```
<Overlap Ratio: 0.9461426491994177>

---

--- 54 --
Question ID: 5252b70b49975622f4c6f984caaee8c728d24b2a_0
Original Code:
```
fn test_user_data() {
        let user_data = Box::new(10u8);
        let mut inner: io_uring_sqe = unsafe { std::mem::zeroed() };
        inner.user_data = Box::into_raw(user_data) as u64;

        let sqe: Sqe = Sqe::new(inner);

        assert_eq!(unsafe { sqe.user_data::<u8>() }, 10);
    }
```


Overlapping Code:
```
:new(10u8);
let mut inner: io_uring_sqe = unsafe { std::mem::zeroed() };
inner.user_data = Box::into_raw(user_data) as u64;
let sqe: Sqe = Sqe::new(inner);
assert_eq!(unsafe { sqe.user_data::<u8>() },
```
<Overlap Ratio: 0.8032128514056225>

---

--- 55 --
Question ID: 87ac99b3c92bccdcc8f6f96496d0a9f062e80842_20
Original Code:
```
pub fn serialize_operation_crate_operation_describe_resource_policies(
    input: &crate::input::DescribeResourcePoliciesInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);
    crate::json_ser::serialize_structure_crate_input_describe_resource_policies_input(
        &mut object,
        input,
    )?;
    object.finish();
    Ok(aws_smithy_http::body::SdkBody::from(out))
}
```


Overlapping Code:
```
pub fn serialize_operation_crate_operation_describe_resource_policies(
input: &crate::input::DescribeResourcePoliciesInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
let mut out = String::new();
let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);
crate::json_ser::serialize_structure_crate_input_describe_resource_policies_input(
&mut object,
input,
)?;
object.finish();
Ok(aws_smithy_http::body::SdkBody::from(out))
}
```
<Overlap Ratio: 1.0>

---

--- 56 --
Question ID: 86498bf9e5c8fae2b68cf194a1ad32d2c946040f_6
Original Code:
```
pub fn i64_nullable_field(field_name: &str, data: &[Option<i64>], fields: &mut Vec<Field>, columns: &mut Vec<ArrayRef>) {
    let mut builder = Int64Builder::new(data.len());
    data.iter().for_each(|value| {
        match value {
            None => builder.append_null(),
            Some(value) => builder.append_value(*value),
        }
            .expect("append data into builder failed")
    });
    let array = builder.finish();
    if array.null_count() < array.len() {
        fields.push(Field::new(field_name, DataType::Int64, array.null_count() > 0));
        columns.push(Arc::new(array));
    }
}
```


Overlapping Code:
```
r, data: &[Option<i64>], fields: &mut Vec<Field>, columns: &mut Vec<ArrayRef>) {
let mut builder = Int64Builder::new(data.len());
data.iter().for_each(|value| {
match value {
None => builder.append_null(),
Some(value) => builder.append_value(*value),
}
.expect("append data into builder failed")
});
let array = builder.finish();
if array.null_count() < array.len() {
fields.push(Field::new(field_name, DataType::Int64, array.null_count() > 0));
columns.push(Arc::new(array));

```
<Overlap Ratio: 0.9155470249520153>

---

--- 57 --
Question ID: a1137d3c18bd5e6e9b9df5ad207c11ddf07af8a8_0
Original Code:
```
pub fn plugin_main<P: Plugin>(host_cb: HostCallbackProc, unique_id: &[u8; 4]) -> *mut AEffect {
    let mut flags = effect_flags::CAN_REPLACING | effect_flags::PROGRAM_CHUNKS;

    if WrappedPlugin::<P>::wants_midi_input() {
        flags |= effect_flags::IS_SYNTH;
    }

    if VST2Adapter::<P>::has_ui() {
        flags |= effect_flags::HAS_EDITOR;
    }

    let unique_id =
          (unique_id[0] as u32) << 24
        | (unique_id[1] as u32) << 16
        | (unique_id[2] as u32) << 8
        | (unique_id[3] as u32);
    
    let effect = AEffect {
        magic: MAGIC,

        dispatcher: dispatch::<P>,
        process: process_deprecated,
        set_parameter: set_parameter::<P>,
        get_parameter: get_parameter::<P>,

        num_programs: 0,
        num_params: <P::Model as Model<P>>::Smooth::PARAMS.len() as i32,
        num_inputs: P::INPUT_CHANNELS as i32,
        num_outputs: P::OUTPUT_CHANNELS as i32,

        flags,

        ptr_1: ptr::null_mut(),
        ptr_2: ptr::null_mut(),

        initial_delay: 0,

        empty_2: [0; 8],
        unknown_float: 0.0,

        object: ptr::null_mut(),
        user: ptr::null_mut(),

        unique_id: unique_id as i32,
        version: 0,

        process_replacing: process_replacing::<P>,
        process_double_replacing: process_replacing_f64,
    };
    
    let host_callback = VST2HostCallback {
        effect: std::ptr::null_mut() as *mut AEffect,
        host_cb,
    };

    let mut adapter = Box::new(VST2Adapter::<P> {
        effect,

        host_callback,

        editor_rect: Rect {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
        },

        wrapped: WrappedPlugin::new(),
        state: None,

        output_events_buffer: OutgoingEvents::new()
    });

    // Make sure we have the correct pointer to the effect.
    let host_callback = VST2HostCallback {
        effect: &mut adapter.effect as *mut AEffect,
        host_cb,
    };
    adapter.host_callback = host_callback;

    unsafe {
        &mut ((*Box::into_raw(adapter)).effect)
    }
}
```


Overlapping Code:
```
>(host_cb: HostCallbackProc, unique_id: &[u8; 4]) -> *mut AEffect {
let mut flags = effect_flags::CAN_REPLACING | effect_flags::PROGRAM_CHUNKS;
if WrappedPlugin::<P>::wants_midi_input() {
flags |= effect_flags::IS_SYNTH;
}
if VST2Adapter::<P>::has_ui() {
flags |= effect_flags::HAS_EDITOR;
}
let unique_id =
(unique_id[0] as u32) << 24
| (unique_id[1] as u32) << 16
| (unique_id[2] as u32) << 8
| (unique_id[3] as u32);

let effect = AEffect {
magic: MAGIC,
dispatcher: dispatch::<P>,
process: process_deprecated,
set_parameter: set_parameter::<P>,
get_parameter: get_parameter::<P>,
num_programs: 0,
num_params: <P::Model as Model<P>>::Smooth::PARAMS.len() as i32,
num_inputs: P::INPUT_CHANNELS as i32,
num_outputs: P::OUTPUT_CHANNELS as i32,
flags,
ptr_1: ptr::null_mut(),
ptr_2: ptr::null_mut(),
initial_delay: 0,
empty_2: [0; 8],
unknown_float: 0.0,
object: ptr::null_mut(),
user: ptr::null_mut(),
unique_id: unique_id as i32,
version: 0,
process_replacing: process_replacing::<P>,
process_double_replacing: process_replacing_f64,
};

let host_callback = VST2HostCallback {
effect: std::ptr::null_mut() as *mut AEffect,
host_cb,
};
let mut adapter = Box::new(VST2Adapter::<P> {
effect,
host_callback,
editor_rect: Rect {
top: 0,
bottom: 0,
left: 0,
right: 0,
},
wrapped: WrappedPlugin::new(),
state: None,
output_events_buffer: OutgoingEvents::new()
});
// Make sure we have the correct pointer to the effect.
let host_callback = VST2HostCallback {
effect: &mut adapter.effect as *mut AEffect,
host_cb,
};
adapter.host_callback = host_callback;
unsafe {
&mut ((*Box::into_raw(adapter)).effect)

```
<Overlap Ratio: 0.9809699201964396>

---

--- 58 --
Question ID: bc25520c5512d3a8495993761bffa37382061d77_65
Original Code:
```
fn bindgen_test_layout___darwin_mcontext64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64_full>(),
        744usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__fs)
        )
    );
}
```


Overlapping Code:
```
fn bindgen_test_layout___darwin_mcontext64_full() {
assert_eq!(
::std::mem::size_of::<__darwin_mcontext64_full>(),
744usize,
concat!("Size of: ", stringify!(__darwin_mcontext64_full))
);
assert_eq!(
::std::mem::align_of::<__darwin_mcontext64_full>(),
8usize,
concat!("Alignment of ", stringify!(__darwin_mcontext64_full))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext64_full),
"::",
stringify!(__es)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },
16usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext64_full),
"::",
stringify!(__ss)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },
216usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext64_full),
"::",
stringify!(__fs)
)
);
}
```
<Overlap Ratio: 1.0>

---

--- 59 --
Question ID: c7e9af65cf4203d61fc9d741d9f84684268734c5_5
Original Code:
```
fn test_includes() {
        assert_eq!(document(json!({})).includes(), Vec::<String>::new());
        assert_eq!(document(json!({ "include": []})).includes(), Vec::<String>::new());
        assert_eq!(
            document(json!({ "include": [ "foo.cml", "bar.cml" ]})).includes(),
            vec!["foo.cml", "bar.cml"]
        );
    }
```


Overlapping Code:
```
nt(json!({})).includes(), Vec::<String>::new());
assert_eq!(document(json!({ "include": []})).includes(), Vec::<String>::new());
assert_eq!(
document(json!({ "include": [ "foo.cml", "bar.cml" ]})).inc
```
<Overlap Ratio: 0.7194244604316546>

---

--- 60 --
Question ID: ff2f4883dac8a1c3022c30054dc47766f61f1f86_1
Original Code:
```
fn disable_devices() {
	wait_write();
	unsafe {
		io::outb(COMMAND_REGISTER, 0xad);
	}

	wait_write();
	unsafe {
		io::outb(COMMAND_REGISTER, 0xa7);
	}
}
```


Overlapping Code:
```

wait_write();
unsafe {
io::outb(COMMAND_REGISTER, 0xad);
}
wait_write();
unsafe {
io::outb(COMMAND_REGISTER, 0
```
<Overlap Ratio: 0.7816901408450704>

---

--- 61 --
Question ID: ef451145d11aad10740dd6887f5fb5c1af4124dc_0
Original Code:
```
fn set(args: &SetArguments) -> Result<()> {
    let mut config = crate::config::Config::load()?;
    config.set(&args.path, &args.value)?;
    config.dump()?;
    Ok(())
}
```


Overlapping Code:
```
t(args: &SetArguments) -> Result<()> {
let mut config = crate::config::Config::load()?;
config.set(&args.path, &args.value)?;
config.dump()?;
Ok(())
}
```
<Overlap Ratio: 0.967741935483871>

---

--- 62 --
Question ID: 7e2cb0923ee66343bab7e18ac18838de40478cf7_4
Original Code:
```
fn from_cursor_wrong() {
        let a = &[0, 1, 78];
        let mut wrong: Cursor<&[u8]> = Cursor::new(a);
        let _ = StatusChangeType::from_cursor(&mut wrong).unwrap();
    }
```


Overlapping Code:
```
 from_cursor_wrong() {
let a = &[0, 1, 78];
let mut wrong: Cursor<&[u8]> = Cursor::new(a);
let _ = StatusChangeType::from_cursor(&mut wrong).unwrap();
```
<Overlap Ratio: 0.974025974025974>

---

--- 63 --
Question ID: cf918a5c6c2be86db742e35664b0332b37fbfcda_10
Original Code:
```
fn sync_symlink< P >( path: P ) -> std::io::Result< () >
where
    P: AsRef< std::path::Path >,
{
    log::trace!( "Begin `sync_symlink`." );

    let path = path.as_ref();

    let metadata = path.symlink_metadata()?;
    if !metadata.file_type().is_symlink() {
        let error_msg = format!(
            "Invalid file type: not a symlink: \
                path: {:?}, \
                type: {:?}",
            path,
            metadata.file_type(),
        );

        log::error!( "{}", error_msg );

        let error = std::io::Error::new(
                std::io::ErrorKind::InvalidInput, error_msg );

        return Err( error );
    }

    let mut abs_path = std::env::current_dir()?;
    abs_path.push( path );
    let parent_path = abs_path.parent().unwrap();

    log::debug!( "Syncing symlink parent: {:?}", parent_path );

    std::fs::File::open( parent_path )?.sync_all()?;

    log::trace!( "End `sync_symlink`." );

    return Ok( () );
}
```


Overlapping Code:
```
) -> std::io::Result< () >
where
P: AsRef< std::path::Path >,
{
log::trace!( "Begin `sync_symlink`." );
let path = path.as_ref();
let metadata = path.symlink_metadata()?;
if !metadata.file_type().is_symlink() {
let error_msg = format!(
"Invalid file type: not a symlink: \
path: {:?}, \
type: {:?}",
path,
metadata.file_type(),
);
log::error!( "{}", error_msg );
let error = std::io::Error::new(
std::io::ErrorKind::InvalidInput, error_msg );
return Err( error );
}
let mut abs_path = std::env::current_dir()?;
abs_path.push( path );
let parent_path = abs_path.parent().unwrap();
log::debug!( "Syncing symlink parent: {:?}", parent_path );
std::fs::File::open( parent_path )?.sync_all()?;
log::trace!( "End `s
```
<Overlap Ratio: 0.9148387096774193>

---

--- 64 --
Question ID: d4c044b4464d1846dd4a853c231d2edd55e48d41_9
Original Code:
```
fn enc_dec_max_i8() {
        let val = core::i8::MAX.into();
        assert_eq!(encoded_len(val), 2);
        assert_eq!(encode(val).as_ref(), &[0xBE, 0x03]);
        assert_eq!(decode(encode(val).as_ref()).unwrap(), val);
    }
```


Overlapping Code:
```
8() {
let val = core::i8::MAX.into();
assert_eq!(encoded_len(val), 2);
assert_eq!(encode(val).as_ref(), &[0xBE, 0x03]);
assert_eq!(decode(encode(val).as_ref()).unwrap(), val);

```
<Overlap Ratio: 0.9119170984455959>

---

--- 65 --
Question ID: 84c23658828a7fca46ef7a8340541724fc5d3044_1
Original Code:
```
fn exec(attempts: i32, command: &mut Command) -> String {
    let command_line = format!("{:?}", command);

    for _attempt in 0..attempts {
        match command.output() {
            Ok(output) => return String::from_utf8(output.stdout).expect("parse UTF8 string"),
            Err(err) => {
                eprintln!(
                    "Godot command failed:\n  command: {}\n  error: {}",
                    command_line, err
                )
            }
        }
    }

    panic!("Could not execute Godot command (see above).")
}
```


Overlapping Code:
```
 command: &mut Command) -> String {
let command_line = format!("{:?}", command);
for _attempt in 0..attempts {
match command.output() {
Ok(output) => return String::from_utf8(output.stdout).expect("parse UTF8 string"),
Err(err) => {
eprintln!(
"Godot command failed:\n command: {}\n error: {}",
command_line, err
)
}
}
}
panic!("Could not execute God
```
<Overlap Ratio: 0.8771929824561403>

---

--- 66 --
Question ID: ba9177c4c780a99dd976f4d5e53230ffc5e40b89_8
Original Code:
```
fn match_invalid_id() {
        let doc = document();
        let parent = create_element(doc.clone().downgrade(), "h1");
        let child = create_element(doc.clone().downgrade(), "button");
        Node::append_child(parent.clone(), child.clone());

        let css = "h1#name > button { color: red; }";

        let tokenizer = Tokenizer::new(css.chars());
        let tokens = tokenizer.run();
        let mut parser = Parser::<Token>::new(tokens);
        let stylesheet = parser.parse_a_css_stylesheet();

        let rule = stylesheet.first().unwrap();

        match rule {
            CSSRule::Style(style) => {
                let selectors = &style.selectors;
                assert!(!is_match_selectors(&child, selectors));
            }
        }
    }
```


Overlapping Code:
```
_id() {
let doc = document();
let parent = create_element(doc.clone().downgrade(), "h1");
let child = create_element(doc.clone().downgrade(), "button");
Node::append_child(parent.clone(), child.clone());
let css = "h1#name > button { color: red; }";
let tokenizer = Tokenizer::new(css.chars());
let tokens = tokenizer.run();
let mut parser = Parser::<Token>::new(tokens);
let stylesheet = parser.parse_a_css_stylesheet();
let rule = stylesheet.first().unwrap();
match rule {
CSSRule::Style(style) => {
let selectors = &style.selectors;
assert!(!is_match_selectors(&
```
<Overlap Ratio: 0.9323432343234324>

---

--- 67 --
Question ID: 61ba86b714a91e7ff1570d03834ee26b4b252164_1
Original Code:
```
fn mandelbrot() -> Result<(), Box<dyn std::error::Error>> {
    let mut cmd = Command::cargo_bin("rocklang")?;

    cmd.arg("examples/mandelbrot.rc");
    cmd.assert().success().stdout(
        predicate::eq(
            "...............*..............
...............*..............
...............*..............
..............***.............
.............*****............
.............*****............
.............*****............
..............***.............
.............*****............
...........*********..........
.........*************........
..........***********.........
.........*************........
.......*****************......
.......*****************......
.....*...*************...*....
.........*************........
..........***********.........
..........*****.*****.........
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
",
        )
        .normalize(),
    );

    Ok(())
}
```


Overlapping Code:
```
rot() -> Result<(), Box<dyn std::error::Error>> {
let mut cmd = Command::cargo_bin("rocklang")?;
cmd.arg("examples/mandelbrot.rc");
cmd.assert().success().stdout(
predicate::eq(
"...............*..............
...............*..............
...............*..............
..............***.............
.............*****............
.............*****............
.............*****............
..............***.............
.............*****............
...........*********..........
.........*************........
..........***********.........
.........*************........
.......*****************......
.......*****************......
.....*...*************...*....
.........*************........
..........***********.........
..........*****.*****.........
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
",
)
.normalize(),

```
<Overlap Ratio: 0.9817232375979112>

---

--- 68 --
Question ID: c24144e0b86940dbe3c939b11504b3223ce1d429_1
Original Code:
```
pub fn setup(hull_opts: &Config) -> Result<(), io::Error> {
    let dir = &hull_opts.posts.output;
    let path = Path::new(dir);

    if path.exists() {
        fs::remove_dir_all(path).expect("Hull: failed to remove posts output");
        println!("Hull: removed {:#?}", path);
    }

    fs::create_dir(path).expect("Hull: failed to create posts output");
    println!("Hull: created {:#?}", path);

    Ok(())
}
```


Overlapping Code:
```
ll_opts: &Config) -> Result<(), io::Error> {
let dir = &hull_opts.posts.output;
let path = Path::new(dir);
if path.exists() {
fs::remove_dir_all(path).expect("Hull: failed to remove posts output");
println!("Hull: removed {:#?}", path);
}
fs::create_dir(path).expect("Hull: failed to create posts output");
println!("Hull: created {:#?}", path);
Ok((
```
<Overlap Ratio: 0.948509485094851>

---

--- 69 --
Question ID: 3971c9bbf521ff07b6bea659a9f3b5c159a09aae_7
Original Code:
```
fn sort_fskey() {
    let a = FSKey::compose(0, 0, 0);
    let b = FSKey::compose(0, 1, 0);
    let c = FSKey::compose(1, 0, 0);
    let d = FSKey::compose(0, 1, 1);
    let e = FSKey::compose(0, 2, 0);
    let f = FSKey::compose(0, 2, 1);
    let g = FSKey::compose(0, 2, 2);
    assert!(a < b && b < c);
    assert!(b < d && d < e);
    assert!(e < f && f < g);
}
```


Overlapping Code:
```
::compose(0, 0, 0);
let b = FSKey::compose(0, 1, 0);
let c = FSKey::compose(1, 0, 0);
let d = FSKey::compose(0, 1, 1);
let e = FSKey::compose(0, 2, 0);
let f = FSKey::compose(0, 2, 1);
let g = FSKey::compose(0, 2, 2);
assert!(a < b && b < c);
assert!(b < d && 
```
<Overlap Ratio: 0.8>

---

--- 70 --
Question ID: 4142b600f42a69de56f5807db7b1b36af0bb13c2_2
Original Code:
```
pub fn dominance_order<S>(a: &S, b: &S, objectives: &[Arc<dyn Objective<Solution = S> + Send + Sync>]) -> Ordering {
    let mut less_cnt = 0;
    let mut greater_cnt = 0;

    for objective in objectives.iter() {
        match objective.total_order(a, b) {
            Ordering::Less => {
                less_cnt += 1;
            }
            Ordering::Greater => {
                greater_cnt += 1;
            }
            Ordering::Equal => {}
        }
    }

    if less_cnt > 0 && greater_cnt == 0 {
        Ordering::Less
    } else if greater_cnt > 0 && less_cnt == 0 {
        Ordering::Greater
    } else {
        debug_assert!((less_cnt > 0 && greater_cnt > 0) || (less_cnt == 0 && greater_cnt == 0));
        Ordering::Equal
    }
}
```


Overlapping Code:
```
der<S>(a: &S, b: &S, objectives: &[Arc<dyn Objective<Solution = S> + Send + Sync>]) -> Ordering {
let mut less_cnt = 0;
let mut greater_cnt = 0;
for objective in objectives.iter() {
match objective.total_order(a, b) {
Ordering::Less => {
less_cnt += 1;
}
Ordering::Greater => {
greater_cnt += 1;
}
Ordering::Equal => {}
}
}
if less_cnt > 0 && greater_cnt == 0 {
Ordering::Less
} else if greater_cnt > 0 && less_cnt == 0 {
Ordering::Greater
} else {
debug_assert!((less_cnt > 0 && greater_cnt > 0) || (less_cnt == 0 && greater_cnt == 0));
Ordering::Eq
```
<Overlap Ratio: 0.9548611111111112>

---

--- 71 --
Question ID: 1eb3faad36d9c99107eeb632258a82f0135079a6_6
Original Code:
```
fn test_volume_changes() -> Result<(), Error> {
        let mut exec = fasync::Executor::new().expect("executor needed");
        let (mut settings_requests, avrcp_requests, _stop_sender, relay_fut) =
            setup_volume_relay()?;

        pin_mut!(relay_fut);

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        let (volume_client, watch_responder) =
            finish_relay_setup(&mut relay_fut, &mut exec, avrcp_requests, &mut settings_requests);

        let volume_get_fut = volume_client.get_current_volume();
        pin_mut!(volume_get_fut);

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        // Volume get should return immediately with the initial volume (0.8 -> 100)
        match exec.run_until_stalled(&mut volume_get_fut) {
            Poll::Ready(Ok(vol)) => {
                assert_eq!(INITIAL_AVRCP_VOLUME, vol);
            }
            x => panic!("Expected get_current_volume to be finished, but got {:?}", x),
        };

        let volume_hanging_fut = volume_client.on_volume_changed();
        pin_mut!(volume_hanging_fut);

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        // The OnVolumeChanged request should return immediately the first time.
        match exec.run_until_stalled(&mut volume_hanging_fut) {
            Poll::Ready(Ok(vol)) => {
                assert_eq!(INITIAL_AVRCP_VOLUME, vol);
            }
            x => {
                panic!("Expected on_volume_changed to be finished the first time, but got {:?}", x)
            }
        };

        let volume_hanging_fut = volume_client.on_volume_changed();
        pin_mut!(volume_hanging_fut);

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        // The next OnVolumeChanged request shouldn't resolve because the volume hasn't changed.
        match exec.run_until_stalled(&mut volume_hanging_fut) {
            Poll::Pending => {}
            x => {
                panic!("Expected on_volume_changed to be hanging the second time, but got {:?}", x)
            }
        };

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        // When a new volume happens as a result, it's returned.
        respond_to_audio_watch(watch_responder, NEW_MEDIA_VOLUME);

        let res = exec.run_until_stalled(&mut relay_fut);
        assert!(res.is_pending());

        match exec.run_until_stalled(&mut volume_hanging_fut) {
            Poll::Ready(Ok(vol)) => assert_eq!(vol, NEW_AVRCP_VOLUME),
            x => panic!(
                "Expected on_volume_changed to be responded to after change but got: {:?}",
                x
            ),
        };

        let _watch_responder = expect_audio_watch(&mut exec, &mut settings_requests);

        Ok(())
    }
```


Overlapping Code:
```
() -> Result<(), Error> {
let mut exec = fasync::Executor::new().expect("executor needed");
let (mut settings_requests, avrcp_requests, _stop_sender, relay_fut) =
setup_volume_relay()?;
pin_mut!(relay_fut);
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is_pending());
let (volume_client, watch_responder) =
finish_relay_setup(&mut relay_fut, &mut exec, avrcp_requests, &mut settings_requests);
let volume_get_fut = volume_client.get_current_volume();
pin_mut!(volume_get_fut);
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is_pending());
// Volume get should return immediately with the initial volume (0.8 -> 100)
match exec.run_until_stalled(&mut volume_get_fut) {
Poll::Ready(Ok(vol)) => {
assert_eq!(INITIAL_AVRCP_VOLUME, vol);
}
x => panic!("Expected get_current_volume to be finished, but got {:?}", x),
};
let volume_hanging_fut = volume_client.on_volume_changed();
pin_mut!(volume_hanging_fut);
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is_pending());
// The OnVolumeChanged request should return immediately the first time.
match exec.run_until_stalled(&mut volume_hanging_fut) {
Poll::Ready(Ok(vol)) => {
assert_eq!(INITIAL_AVRCP_VOLUME, vol);
}
x => {
panic!("Expected on_volume_changed to be finished the first time, but got {:?}", x)
}
};
let volume_hanging_fut = volume_client.on_volume_changed();
pin_mut!(volume_hanging_fut);
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is_pending());
// The next OnVolumeChanged request shouldn't resolve because the volume hasn't changed.
match exec.run_until_stalled(&mut volume_hanging_fut) {
Poll::Pending => {}
x => {
panic!("Expected on_volume_changed to be hanging the second time, but got {:?}", x)
}
};
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is_pending());
// When a new volume happens as a result, it's returned.
respond_to_audio_watch(watch_responder, NEW_MEDIA_VOLUME);
let res = exec.run_until_stalled(&mut relay_fut);
assert!(res.is
```
<Overlap Ratio: 0.9885685884691849>

---

--- 72 --
Question ID: 3a8f81119edd616c79cd978d6b2c44f01b72ce61_5
Original Code:
```
pub fn gen(options: Options) {
    fs::create_dir_all(options.out_dir.join("src/peripherals")).unwrap();
    fs::create_dir_all(options.out_dir.join("src/chips")).unwrap();

    let mut all_peripheral_versions: HashSet<(String, String)> = HashSet::new();
    let mut chip_core_names: Vec<String> = Vec::new();

    for chip_name in &options.chips {
        println!("Generating {}...", chip_name);

        let chip = load_chip(&options, chip_name);
        for (core_index, core) in chip.cores.iter().enumerate() {
            let chip_core_name = match chip.cores.len() {
                1 => chip_name.clone(),
                _ => format!("{}-{}", chip_name, core.name),
            };

            chip_core_names.push(chip_core_name.clone());
            gen_chip(
                &options,
                &chip_core_name,
                &chip,
                core,
                core_index,
                &mut all_peripheral_versions,
            )
        }
    }

    for (module, version) in all_peripheral_versions {
        println!("loading {} {}", module, version);

        let regs_path = Path::new(&options.data_dir)
            .join("registers")
            .join(&format!("{}_{}.yaml", module, version));

        let mut ir: ir::IR = serde_yaml::from_reader(File::open(regs_path).unwrap()).unwrap();

        transform::expand_extends::ExpandExtends {}
            .run(&mut ir)
            .unwrap();

        transform::map_names(&mut ir, |k, s| match k {
            transform::NameKind::Block => *s = format!("{}", s),
            transform::NameKind::Fieldset => *s = format!("regs::{}", s),
            transform::NameKind::Enum => *s = format!("vals::{}", s),
            _ => {}
        });

        transform::sort::Sort {}.run(&mut ir).unwrap();
        transform::Sanitize {}.run(&mut ir).unwrap();

        let items = generate::render(&ir, &gen_opts()).unwrap();
        let mut file = File::create(
            options
                .out_dir
                .join("src/peripherals")
                .join(format!("{}_{}.rs", module, version)),
        )
        .unwrap();
        let data = items.to_string().replace("] ", "]\n");

        // Remove inner attributes like #![no_std]
        let re = Regex::new("# *! *\\[.*\\]").unwrap();
        let data = re.replace_all(&data, "");
        file.write_all(data.as_bytes()).unwrap();
    }

    // Generate src/lib_inner.rs
    const PATHS_MARKER: &[u8] = b"// GEN PATHS HERE";
    let librs = include_bytes!("assets/lib_inner.rs");
    let i = bytes_find(librs, PATHS_MARKER).unwrap();
    let mut paths = String::new();

    for name in chip_core_names {
        let x = name.to_ascii_lowercase();
        write!(
            &mut paths,
            "#[cfg_attr(feature=\"{}\", path = \"chips/{}/mod.rs\")]",
            x, x
        )
        .unwrap();
    }
    let mut contents: Vec<u8> = Vec::new();
    contents.extend(&librs[..i]);
    contents.extend(paths.as_bytes());
    contents.extend(&librs[i + PATHS_MARKER.len()..]);
    fs::write(options.out_dir.join("src").join("lib_inner.rs"), &contents).unwrap();

    // Generate src/lib.rs
    const CUT_MARKER: &[u8] = b"// GEN CUT HERE";
    let librs = include_bytes!("../../stm32-metapac/src/lib.rs");
    let i = bytes_find(librs, CUT_MARKER).unwrap();
    let mut contents: Vec<u8> = Vec::new();
    contents.extend(&librs[..i]);
    contents.extend(b"include!(\"lib_inner.rs\");\n");
    fs::write(options.out_dir.join("src").join("lib.rs"), contents).unwrap();

    // Generate src/common.rs
    fs::write(
        options.out_dir.join("src").join("common.rs"),
        generate::COMMON_MODULE,
    )
    .unwrap();

    // Generate Cargo.toml
    const BUILDDEP_BEGIN: &[u8] = b"# BEGIN BUILD DEPENDENCIES";
    const BUILDDEP_END: &[u8] = b"# END BUILD DEPENDENCIES";

    let mut contents = include_bytes!("../../stm32-metapac/Cargo.toml").to_vec();
    let begin = bytes_find(&contents, BUILDDEP_BEGIN).unwrap();
    let end = bytes_find(&contents, BUILDDEP_END).unwrap() + BUILDDEP_END.len();
    contents.drain(begin..end);
    fs::write(options.out_dir.join("Cargo.toml"), contents).unwrap();

    // Generate build.rs
    fs::write(
        options.out_dir.join("build.rs"),
        include_bytes!("assets/build.rs"),
    )
    .unwrap();
}
```


Overlapping Code:
```
s::create_dir_all(options.out_dir.join("src/peripherals")).unwrap();
fs::create_dir_all(options.out_dir.join("src/chips")).unwrap();
let mut all_peripheral_versions: HashSet<(String, String)> = HashSet::new();
let mut chip_core_names: Vec<String> = Vec::new();
for chip_name in &options.chips {
println!("Generating {}...", chip_name);
let chip = load_chip(&options, chip_name);
for (core_index, core) in chip.cores.iter().enumerate() {
let chip_core_name = match chip.cores.len() {
1 => chip_name.clone(),
_ => format!("{}-{}", chip_name, core.name),
};
chip_core_names.push(chip_core_name.clone());
gen_chip(
&options,
&chip_core_name,
&chip,
core,
core_index,
&mut all_peripheral_versions,
)
}
}
for (module, version) in all_peripheral_versions {
println!("loading {} {}", module, version);
let regs_path = Path::new(&options.data_dir)
.join("registers")
.join(&format!("{}_{}.yaml", module, version));
let mut ir: ir::IR = serde_yaml::from_reader(File::open(regs_path).unwrap()).unwrap();
transform::expand_extends::ExpandExtends {}
.run(&mut ir)
.unwrap();
transform::map_names(&mut ir, |k, s| match k {
transform::NameKind::Block => *s = format!("{}", s),
transform::NameKind::Fieldset => *s = format!("regs::{}", s),
transform::NameKind::Enum => *s = format!("vals::{}", s),
_ => {}
});
transform::sort::Sort {}.run(&mut ir).unwrap();
transform::Sanitize {}.run(&mut ir).unwrap();
let items = generate::render(&ir, &gen_opts()).unwrap();
let mut file = File::create(
options
.out_dir
.join("src/peripherals")
.join(format!("{}_{}.rs", module, version)),
)
.unwrap();
let data = items.to_string().replace("] ", "]\n");
// Remove inner attributes like #![no_std]
let re = Regex::new("# *! *\\[.*\\]").unwrap();
let data = re.replace_all(&data, "");
file.write_all(data.as_bytes()).unwrap();
}
// Generate src/lib_inner.rs
const PATHS_MARKER: &[u8] = b"// 
```
<Overlap Ratio: 0.9637305699481865>

---

--- 73 --
Question ID: 4f8443be259d19e55b468b280badc18a5eca7b9d_0
Original Code:
```
fn test_matches_dft() {
        let n = 4;

        for len in 1..20 {
            let dft_instance = Dft::new(len, FftDirection::Forward);
            assert_eq!(
                dft_instance.len(),
                len,
                "Dft instance reported incorrect length"
            );

            let input = random_signal(len * n);
            let mut expected_output = input.clone();

            // Compute the control data using our simplified Dft definition
            for (input_chunk, output_chunk) in
                input.chunks(len).zip(expected_output.chunks_mut(len))
            {
                dft(input_chunk, output_chunk);
            }

            // test process()
            {
                let mut inplace_buffer = input.clone();

                dft_instance.process(&mut inplace_buffer);

                assert!(
                    compare_vectors(&expected_output, &inplace_buffer),
                    "process() failed, length = {}",
                    len
                );
            }

            // test process_with_scratch()
            {
                let mut inplace_with_scratch_buffer = input.clone();
                let mut inplace_scratch =
                    vec![Zero::zero(); dft_instance.get_inplace_scratch_len()];

                dft_instance
                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);

                assert!(
                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),
                    "process_inplace() failed, length = {}",
                    len
                );

                // one more thing: make sure that the Dft algorithm even works with dirty scratch space
                for item in inplace_scratch.iter_mut() {
                    *item = Complex::new(100.0, 100.0);
                }
                inplace_with_scratch_buffer.copy_from_slice(&input);

                dft_instance
                    .process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);

                assert!(
                    compare_vectors(&expected_output, &inplace_with_scratch_buffer),
                    "process_with_scratch() failed the 'dirty scratch' test for len = {}",
                    len
                );
            }

            // test process_outofplace_with_scratch
            {
                let mut outofplace_input = input.clone();
                let mut outofplace_output = expected_output.clone();

                dft_instance.process_outofplace_with_scratch(
                    &mut outofplace_input,
                    &mut outofplace_output,
                    &mut [],
                );

                assert!(
                    compare_vectors(&expected_output, &outofplace_output),
                    "process_outofplace_with_scratch() failed, length = {}",
                    len
                );
            }
        }

        //verify that it doesn't crash or infinite loop if we have a length of 0
        let zero_dft = Dft::new(0, FftDirection::Forward);
        let mut zero_input: Vec<Complex<f32>> = Vec::new();
        let mut zero_output: Vec<Complex<f32>> = Vec::new();
        let mut zero_scratch: Vec<Complex<f32>> = Vec::new();

        zero_dft.process(&mut zero_input);
        zero_dft.process_with_scratch(&mut zero_input, &mut zero_scratch);
        zero_dft.process_outofplace_with_scratch(
            &mut zero_input,
            &mut zero_output,
            &mut zero_scratch,
        );
    }
```


Overlapping Code:
```
 len in 1..20 {
let dft_instance = Dft::new(len, FftDirection::Forward);
assert_eq!(
dft_instance.len(),
len,
"Dft instance reported incorrect length"
);
let input = random_signal(len * n);
let mut expected_output = input.clone();
// Compute the control data using our simplified Dft definition
for (input_chunk, output_chunk) in
input.chunks(len).zip(expected_output.chunks_mut(len))
{
dft(input_chunk, output_chunk);
}
// test process()
{
let mut inplace_buffer = input.clone();
dft_instance.process(&mut inplace_buffer);
assert!(
compare_vectors(&expected_output, &inplace_buffer),
"process() failed, length = {}",
len
);
}
// test process_with_scratch()
{
let mut inplace_with_scratch_buffer = input.clone();
let mut inplace_scratch =
vec![Zero::zero(); dft_instance.get_inplace_scratch_len()];
dft_instance
.process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);
assert!(
compare_vectors(&expected_output, &inplace_with_scratch_buffer),
"process_inplace() failed, length = {}",
len
);
// one more thing: make sure that the Dft algorithm even works with dirty scratch space
for item in inplace_scratch.iter_mut() {
*item = Complex::new(100.0, 100.0);
}
inplace_with_scratch_buffer.copy_from_slice(&input);
dft_instance
.process_with_scratch(&mut inplace_with_scratch_buffer, &mut inplace_scratch);
assert!(
compare_vectors(&expected_output, &inplace_with_scratch_buffer),
"process_with_scratch() failed the 'dirty scratch' test for len = {}",
len
);
}
// test process_outofplace_with_scratch
{
let mut outofplace_input = input.clone();
let mut outofplace_output = expected_
```
<Overlap Ratio: 0.9768009768009768>

---

--- 74 --
Question ID: d2aab05ce06d795f75cb1111540483ce28b0f166_122
Original Code:
```
fn bindgen_test_layout_bdfprops() {
    assert_eq!(
        ::std::mem::size_of::<bdfprops>(),
        24usize,
        concat!("Size of: ", stringify!(bdfprops))
    );
    assert_eq!(
        ::std::mem::align_of::<bdfprops>(),
        8usize,
        concat!("Alignment of ", stringify!(bdfprops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bdfprops),
            "::",
            stringify!(u)
        )
    );
}
```


Overlapping Code:
```
ut_bdfprops() {
assert_eq!(
::std::mem::size_of::<bdfprops>(),
24usize,
concat!("Size of: ", stringify!(bdfprops))
);
assert_eq!(
::std::mem::align_of::<bdfprops>(),
8usize,
concat!("Alignment of ", stringify!(bdfprops))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<bdfprops>())).name as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(bdfprops),
"::",
stringify!(name)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<bdfprops>())).type_ as *const _ as usize },
8usize,
concat!(
"Offset of field: ",
stringify!(bdfprops),
"::",
stringify!(type_)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<bdfprops>())).u as *const _ as usize },
16usize,
concat!(
"Offset of field: ",
stringify!(bdfprops),
"::
```
<Overlap Ratio: 0.9439374185136897>

---

--- 75 --
Question ID: 856aebc5a75a496a9188c61e4f7a7d5a3c49b82e_0
Original Code:
```
pub fn from(path: &Path) -> Result<StorageSet<(Vec<PackStore<MmapPackReader>>, LooseStore)>, std::io::Error> {
    let packfiles = packfiles_from_path(path)?;
    let loose = loose_from_path(path)?;

    Ok(StorageSet::new((
        packfiles,
        loose
    )))
}
```


Overlapping Code:
```
rom(path: &Path) -> Result<StorageSet<(Vec<PackStore<MmapPackReader>>, LooseStore)>, std::io::Error> {
let packfiles = packfiles_from_path(path)?;
let loose = loose_from_path(path)?;
Ok(StorageSet::ne
```
<Overlap Ratio: 0.8547008547008547>

---

--- 76 --
Question ID: d9f5a19e461c4da51c8d8a53a1ec9b27f300edb9_5
Original Code:
```
fn suffix_comma() {
        let (parts, surname_index, generation) = parse("Doe, John III").unwrap();
        assert_eq!("John", parts[0].word);
        assert_eq!("Doe", parts[1].word);
        assert_eq!(1, surname_index);
        assert_eq!(Some(3), generation);
    }
```


Overlapping Code:
```
uffix_comma() {
let (parts, surname_index, generation) = parse(".unwrap();
assert_eq!("John", parts[0].word);
assert_eq!("Doe", parts[1].word);
assert_eq!(1, surname_index);
assert_eq!(Some(3)
```
<Overlap Ratio: 0.8458149779735683>

---

--- 77 --
Question ID: adc5d0a11384fb7c9040d8515a8a0a66e2136d47_0
Original Code:
```
fn bench_allocator(c: &mut Criterion<ProcessTime>) {
    let page = &[1u8; PAGE_SIZE];
    let mut group = c.benchmark_group("Allocate");
    for n in [1usize, 10, 100, 1_000].iter().cloned() {
        let pages: Vec<(PageIndex, &PageBytes)> = (0..n)
            .into_iter()
            .map(|i| (PageIndex::new(i as u64), page))
            .collect();
        let mut thread_pool = Cell::new(scoped_threadpool::Pool::new(NUM_THREADS));
        group.bench_function(BenchmarkId::new("HeapBasedPageAllocator", n), |b| {
            b.iter(|| {
                thread_pool.get_mut().scoped(|scope| {
                    for _ in 0..NUM_THREADS {
                        scope.execute(|| {
                            let allocator = Arc::new(HeapBasedPageAllocator::default());
                            for _ in 0..NUM_ALLOCATIONS {
                                let pages =
                                    HeapBasedPageAllocator::allocate(&allocator, &pages[..]);
                                black_box(pages);
                            }
                        });
                    }
                });
            })
        });
        // We don't use mmap-based allocator directly because it is only available on
        // Linux for now. To avoid platform specific code here, we compare the
        // heap-based allocator with the default allocator, which can be either
        // the mmap-based allocator or the heap-based allocator.
        group.bench_function(BenchmarkId::new("DefaultPageAllocatorImpl", n), |b| {
            b.iter(|| {
                thread_pool.get_mut().scoped(|scope| {
                    for _ in 0..NUM_THREADS {
                        scope.execute(|| {
                            let allocator = Arc::new(DefaultPageAllocatorImpl::default());
                            // Allocate multiple times to simulate multiple rounds per checkpoint.
                            for _ in 0..NUM_ALLOCATIONS {
                                let pages =
                                    DefaultPageAllocatorImpl::allocate(&allocator, &pages[..]);
                                black_box(pages);
                            }
                        });
                    }
                });
            })
        });
    }
    group.finish();
}
```


Overlapping Code:
```
locator(c: &mut Criterion<ProcessTime>) {
let page = &[1u8; PAGE_SIZE];
let mut group = c.benchmark_group("Allocate");
for n in [1usize, 10, 100, 1_000].iter().cloned() {
let pages: Vec<(PageIndex, &PageBytes)> = (0..n)
.into_iter()
.map(|i| (PageIndex::new(i as u64), page))
.collect();
let mut thread_pool = Cell::new(scoped_threadpool::Pool::new(NUM_THREADS));
group.bench_function(BenchmarkId::new("HeapBasedPageAllocator", n), |b| {
b.iter(|| {
thread_pool.get_mut().scoped(|scope| {
for _ in 0..NUM_THREADS {
scope.execute(|| {
let allocator = Arc::new(HeapBasedPageAllocator::default());
for _ in 0..NUM_ALLOCATIONS {
let pages =
HeapBasedPageAllocator::allocate(&allocator, &pages[..]);
black_box(pages);
}
});
}
});
})
});
// We don't use mmap-based allocator directly because it is only available on
// Linux for now. To avoid platform specific code here, we compare the
// heap-based allocator with the default allocator, which can be either
// the mmap-based allocator or the heap-based allocator.
group.bench_function(BenchmarkId::new("DefaultPageAllocatorImpl", n), |b| {
b.iter(|| {
thread_pool.get_mut().scoped(|scope| {
for _ in 0..NUM_THREADS {
scope.execute(|| {
let allocator = Arc::new(DefaultPageAllocatorImpl::default());
// Allocate multiple times to simulate multiple rounds per checkpoint.
for _ in 0..NUM_ALLOCATIONS {
let pages =
DefaultPageAllocatorImpl::allocate(&allocator, &pages[..]);
black_box(pages);
}
```
<Overlap Ratio: 0.9676767676767677>

---

--- 78 --
Question ID: 4f539f11575a3a4c50764185f950a5b2b7aeb8b0_0
Original Code:
```
fn flush_changes(&mut self) -> Result<bool> {
        let mut changes = self.take_changes();
        // Sort the changes by the order in which the columns are
        changes.sort_by_key(|a| a.get_column_index());

        let column_metas = self.static_meta().get_column_meta();

        let mut buffer_actions = Vec::with_capacity(self.dynamic_meta().buffers.len());
        let mut node_changes = vec![];

        let mut this_buffer_index = 0;
        let mut this_buffer_offset = 0;

        // Go over all of the pending changes, calculate target locations for those buffers
        // and neighbouring buffers if they need to be moved.
        changes.iter().for_each(|array_data| {
            let column_index = array_data.get_column_index();
            // `meta` contains the information about where to look in `self.dynamic_meta` for
            // current offset/node information
            let meta = &column_metas[column_index];

            let buffer_start = meta.buffer_start;
            // Depth-first is required, because this is the order in which
            // nodes are written into memory, see `write_static_array_data` in ./arrow/ipc.rs
            let array_datas = gather_array_datas_depth_first(array_data.get_data());

            // Iterate over buffers that are not modified, but might have to be moved,
            // because of preceding buffers which may have been moved/resized
            if this_buffer_index != buffer_start {
                this_buffer_offset = push_non_modify_actions(
                    &mut buffer_actions,
                    this_buffer_index,
                    buffer_start - 1,
                    this_buffer_offset,
                    self.dynamic_meta(),
                );
                this_buffer_index = buffer_start;
            }

            // A column can consist of more than one node. For example a field that is
            // List<u8> corresponds to a column with 2 nodes
            array_datas.iter().enumerate().for_each(|(i, array_data)| {
                let node_index = meta.node_start + i;
                // Update Node information
                node_changes.push((node_index, Node {
                    null_count: array_data._null_count(),
                    length: array_data._len(),
                }));

                // Null buffer calculation.
                // The null buffer is always the first buffer in a column,
                // it is found under `array_data.null_buffer()` and
                // NOT under `array_data.buffers()[0]`
                {
                    let num_bytes = arrow_bit_util::ceil(array_data._len(), 8);
                    let next_buffer_offset = self
                        .dynamic_meta()
                        .buffers
                        .get(this_buffer_index + 1)
                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);
                    let new_padding = padding::maybe_new_dynamic_pad(
                        this_buffer_offset,
                        num_bytes,
                        next_buffer_offset,
                    );
                    // Safety: A null buffer is always followed by another buffer
                    if let Some(b) = array_data._null_buffer() {
                        buffer_actions.push(BufferAction::Ref {
                            index: this_buffer_index,
                            offset: this_buffer_offset,
                            padding: new_padding,
                            buffer: b,
                        });
                    } else {
                        // We know all values must be valid.
                        // Hence we have to make a homogeneous
                        // null buffer corresponding to valid values
                        let buffer = vec![255_u8; num_bytes];

                        buffer_actions.push(BufferAction::Owned {
                            index: this_buffer_index,
                            offset: this_buffer_offset,
                            padding: new_padding,
                            buffer,
                        });
                    }

                    this_buffer_index += 1;
                    let total_buffer_length = num_bytes + new_padding;
                    this_buffer_offset += total_buffer_length;
                }

                // Go over offset/data buffers (these are not null buffers)
                // Have to do `meta.buffer_counts[i] - 1` because the null buffer is separate
                debug_assert_eq!(
                    meta.buffer_counts[i] - 1,
                    array_data._get_non_null_buffer_count()
                );
                // todo: when adding datatypes with no null buffer (the null datatype), then this
                //   convention does not work
                (0..meta.buffer_counts[i] - 1).for_each(|j| {
                    let buffer = array_data._get_buffer(j);
                    let new_len = buffer.len();
                    let next_buffer_offset = self
                        .dynamic_meta()
                        .buffers
                        .get(this_buffer_index + 1)
                        .map_or_else(|| self.dynamic_meta().data_length, |v| v.offset);
                    let new_padding = padding::maybe_new_dynamic_pad(
                        this_buffer_offset,
                        new_len,
                        next_buffer_offset,
                    );
                    buffer_actions.push(BufferAction::Ref {
                        index: this_buffer_index,
                        offset: this_buffer_offset,
                        padding: new_padding,
                        buffer,
                    });
                    this_buffer_offset += new_len + new_padding;
                    this_buffer_index += 1;
                });
            });
        });

        // There can be buffers at the end which have not been
        // attended to yet. Create actions for them too and use
        // the chance to update final data length
        let last_buffer_index = self.static_meta().get_padding_meta().len() - 1;
        self.mut_dynamic_meta().data_length = push_non_modify_actions(
            &mut buffer_actions,
            this_buffer_index,
            last_buffer_index,
            this_buffer_offset,
            self.dynamic_meta(),
        );
        let data_length = self.dynamic_meta().data_length;
        // Resize memory if needed
        let change = self.mut_memory().set_data_length(data_length)?;

        debug_assert!(self.dynamic_meta().data_length == self.memory().get_data_buffer()?.len());

        // Iterate backwards over every buffer action and perform them
        // Also update offset information in `self.dynamic_meta`
        buffer_actions
            .into_iter()
            .rev()
            .try_for_each(|action| match action {
                BufferAction::Move {
                    old_offset,
                    old_total_length,
                    new_offset,
                    first_index,
                    last_index,
                } => {
                    // We shouldn't be left-shifting buffers
                    debug_assert!(old_offset <= new_offset);
                    (first_index..=last_index).for_each(|j| {
                        // To avoid the modular nature of unsigned int subtraction:
                        self.mut_dynamic_meta().buffers[j].offset += new_offset;
                        self.mut_dynamic_meta().buffers[j].offset -= old_offset;
                    });

                    self.mut_memory().copy_in_data_buffer_unchecked(
                        old_offset,
                        new_offset,
                        old_total_length,
                    )
                }
                BufferAction::Owned {
                    index,
                    offset,
                    padding,
                    buffer,
                } => {
                    let dynamic_meta = self.mut_dynamic_meta();
                    dynamic_meta.buffers[index].offset = offset;
                    dynamic_meta.buffers[index].padding = padding;
                    dynamic_meta.buffers[index].length = buffer.len();
                    self.mut_memory()
                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, &buffer)
                }
                BufferAction::Ref {
                    index,
                    offset,
                    padding,
                    buffer,
                } => {
                    let dynamic_meta = self.mut_dynamic_meta();
                    dynamic_meta.buffers[index].offset = offset;
                    dynamic_meta.buffers[index].padding = padding;
                    dynamic_meta.buffers[index].length = buffer.len();
                    self.mut_memory()
                        .overwrite_in_data_buffer_unchecked_nonoverlapping(offset, buffer)
                }
            })?;

        // Update `FieldNode` data with null_count/element count values
        node_changes.into_iter().for_each(|(i, n)| {
            self.mut_dynamic_meta().nodes[i] = n;
        });

        // Write `self.dynamic_meta` in Arrow format into the `meta_buffer` in `self.memory`
        let dynamic_meta = self.dynamic_meta();
        let new_data_length =
            dynamic_meta.buffers[dynamic_meta.buffers.len() - 1].get_next_offset();
        debug_assert!(self.static_meta().validate_lengths(self.dynamic_meta()));
        self.mut_memory().set_data_length(new_data_length)?;
        let meta_buffer = get_dynamic_meta_flatbuffers(self.dynamic_meta())?;
        self.mut_memory().set_metadata(&meta_buffer)?;
        debug_assert!(self.memory().validate_markers());
        Ok(change.resized())
    }
```


Overlapping Code:
```
h_changes(&mut self) -> Result<bool> {
let mut changes = self.take_changes();
// Sort the changes by the order in which the columns are
changes.sort_by_key(|a| a.get_column_index());
let column_metas = self.static_meta().get_column_meta();
let mut buffer_actions = Vec::with_capacity(self.dynamic_meta().buffers.len());
let mut node_changes = vec![];
let mut this_buffer_index = 0;
let mut this_buffer_offset = 0;
// Go over all of the pending changes, calculate target locations for those buffers
// and neighbouring buffers if they need to be moved.
changes.iter().for_each(|array_data| {
let column_index = array_data.get_column_index();
// `meta` contains the information about where to look in `self.dynamic_meta` for
// current offset/node information
let meta = &column_metas[column_index];
let buffer_start = meta.buffer_start;
// Depth-first is required, because this is the order in which
// nodes are written into memory, see `write_static_array_data` in ./arrow/ipc.rs
let array_datas = gather_array_datas_depth_first(array_data.get_data());
// Iterate over buffers that are not modified, but might have to be moved,
// because of preceding buffers which may have been moved/resized
if this_buffer_index != buffer_start {
this_buffer_offset = push_non_modify_actions(
&mut buffer_actions,
this_buffer_index,
buffer_start - 1,
this_buffer_offset,
self.dynamic_meta(),
);
this_buffer_index = buffer_start;
}
// A column can consist of more than one node. For example a field that is
// List<u8> corresponds to a column with 2 nodes
array_datas.iter().enumerate().for_each(|(i, array_data)| {
let node_index = meta.node_start + i;
// Update Node information
node_changes.push((node_index, Node {
null_count: array_data._null_count(),
length: array_data._len(),
}));
// Null buffer calculation.
// The null buffer is always the first buffer in a column,
// it is found under `array_data.null_
```
<Overlap Ratio: 0.9895833333333334>

---

--- 79 --
Question ID: f419036840fdab102b9b8647ef28cba23a71a5c8_2
Original Code:
```
fn decode_message_valid_header_size() {
        let data = vec![0; SIGNED_MESSAGE_MIN_SIZE + 1];

        match get_decoded_message(&data) {
            Ok(Some(ref message)) if *message == &data[..] => {}
            _ => panic!("Wrong input"),
        };
    }
```


Overlapping Code:
```
ecode_message_valid_header_size() {
let data = vec![0; SIGNED_MESSAGE_MIN_SIZE + 1];
match get_decoded_message(&data) {
Ok(Some(ref message)) if *message == &data[..] => {}
_ => panic!("Wrong input"),
```
<Overlap Ratio: 0.9569377990430622>

---

--- 80 --
Question ID: 82296e5ab9043c8c71ccf066decbd60f54d4e606_2
Original Code:
```
pub(crate) fn lower(cp: u32) -> bool {
    // Derived Property: Lowercase
    //  Generated from: Ll + Other_Lowercase
    let cp = CodePoint::new(cp).unwrap();

    cp.gc() == Gc::Ll || cp.olower()
}
```


Overlapping Code:
```
crate) fn lower(cp: u32) -> bool {
// Derived Property: Lowercase
// Generated from: Ll + Other_Lowercase
let cp = CodePoint::new(cp).unwrap();
cp.gc(
```
<Overlap Ratio: 0.8241758241758241>

---

--- 81 --
Question ID: b632d76ef380755c4eeba82137bfa4cdca87282c_13
Original Code:
```
fn connect_initiation_uses_biased_codec_negotiation_by_peer() {
        let (mut exec, mut peers, _stream, sbc_codec, _aac_codec) = setup_negotiation_test();
        let id = PeerId(1);
        let (remote, channel) = Channel::create();

        // System biases towards the Source direction (called when the AudioMode FIDL changes).
        peers.set_preferred_direction(avdtp::EndpointType::Source);

        // New fake peer discovered with some descriptor - the peer's SDP entry shows Sink.
        let remote = avdtp::Peer::new(remote);
        let desc = ProfileDescriptor {
            profile_id: ServiceClassProfileIdentifier::AdvancedAudioDistribution,
            major_version: 1,
            minor_version: 2,
        };
        let preferred_direction = vec![avdtp::EndpointType::Sink];
        let delay = zx::Duration::from_seconds(1);
        peers.found(id, desc, HashSet::from_iter(preferred_direction.into_iter()));

        let _ = peers.connected(id, channel, Some(delay)).expect("connect control channel is ok");
        // run the start task until it's stalled.
        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());

        let mut remote_requests = remote.take_request_stream();

        // Should wait for the specified amount of time.
        assert!(exec.run_until_stalled(&mut remote_requests.next()).is_pending());

        exec.set_fake_time(fasync::Time::after(delay + zx::Duration::from_micros(1)));
        let _ = exec.wake_expired_timers();

        let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());
        // Even though the peer supports both SBC Sink and Source, we expect to negotiate and start
        // on the Sink endpoint since that is the peer's preferred one.
        let (peer_sbc_source_seid, peer_sbc_source_endpoint) = sbc_source_endpoint();
        let (peer_sbc_sink_seid, peer_sbc_sink_endpoint) = sbc_sink_endpoint();
        expect_peer_discovery(
            &mut exec,
            &mut remote_requests,
            vec![peer_sbc_source_endpoint, peer_sbc_sink_endpoint],
        );
        for _twice in 1..=2 {
            match exec.run_until_stalled(&mut remote_requests.next()) {
                Poll::Ready(Some(Ok(avdtp::Request::GetCapabilities { stream_id, responder }))) => {
                    let codec = match stream_id {
                        id if id == peer_sbc_source_seid => sbc_codec.clone(),
                        id if id == peer_sbc_sink_seid => sbc_codec.clone(),
                        x => panic!("Got unexpected get_capabilities seid {:?}", x),
                    };
                    responder
                        .send(&vec![avdtp::ServiceCapability::MediaTransport, codec])
                        .expect("respond succeeds");
                }
                x => panic!("Expected a ready get capabilities request, got {:?}", x),
            };
        }

        match exec.run_until_stalled(&mut remote_requests.next()) {
            Poll::Ready(Some(Ok(avdtp::Request::SetConfiguration {
                local_stream_id,
                remote_stream_id,
                capabilities: _,
                responder,
            }))) => {
                // We expect the set configuration to apply to the remote peer's Sink SEID and the
                // local Source SEID.
                assert_eq!(peer_sbc_sink_seid, local_stream_id);
                let local_sbc_source_seid: avdtp::StreamEndpointId =
                    SBC_SOURCE_SEID.try_into().unwrap();
                assert_eq!(local_sbc_source_seid, remote_stream_id);
                responder.send().expect("response sends");
            }
            x => panic!("Expected a ready set configuration request, got {:?}", x),
        };
    }
```


Overlapping Code:
```
n_uses_biased_codec_negotiation_by_peer() {
let (mut exec, mut peers, _stream, sbc_codec, _aac_codec) = setup_negotiation_test();
let id = PeerId(1);
let (remote, channel) = Channel::create();
// System biases towards the Source direction (called when the AudioMode FIDL changes).
peers.set_preferred_direction(avdtp::EndpointType::Source);
// New fake peer discovered with some descriptor - the peer's SDP entry shows Sink.
let remote = avdtp::Peer::new(remote);
let desc = ProfileDescriptor {
profile_id: ServiceClassProfileIdentifier::AdvancedAudioDistribution,
major_version: 1,
minor_version: 2,
};
let preferred_direction = vec![avdtp::EndpointType::Sink];
let delay = zx::Duration::from_seconds(1);
peers.found(id, desc, HashSet::from_iter(preferred_direction.into_iter()));
let _ = peers.connected(id, channel, Some(delay)).expect("connect control channel is ok");
// run the start task until it's stalled.
let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());
let mut remote_requests = remote.take_request_stream();
// Should wait for the specified amount of time.
assert!(exec.run_until_stalled(&mut remote_requests.next()).is_pending());
exec.set_fake_time(fasync::Time::after(delay + zx::Duration::from_micros(1)));
let _ = exec.wake_expired_timers();
let _ = exec.run_until_stalled(&mut futures::future::pending::<()>());
// Even though the peer supports both SBC Sink and Source, we expect to negotiate and start
// on the Sink endpoint since that is the peer's preferred one.
let (peer_sbc_source_seid, peer_sbc_source_endpoint) = sbc_source_endpoint();
let (peer_sbc_sink_seid, peer_sbc_sink_endpoint) = sbc_sink_endpoint();
expect_peer_discovery(
&mut exec,
&mut remote_requests,
vec![peer_sbc_source_endpoint, peer_sbc_sink_endpoint],
);
for _twice in 1..=2 {
match exec.run_until_stalled(&mut remote_requests.next()) {
Poll::Ready(Some(Ok(avdtp::Request::GetCapabilities { stream_id, responder }))) => {
let codec = match stream_id {
id if id == peer_sbc_source_seid => sbc_codec.clone(),
id if id == peer_sbc_sink
```
<Overlap Ratio: 0.977587029089175>

---

--- 82 --
Question ID: 7b85deecc9f4c6c1d046ff64481e6b1cc2059653_2
Original Code:
```
fn test_solve_dual64() {
        let a = arr2(&[
            [Dual64::new_scalar(4.0, 3.0), Dual64::new_scalar(3.0, 3.0)],
            [Dual64::new_scalar(6.0, 1.0), Dual64::new_scalar(3.0, 2.0)],
        ]);
        let b = arr1(&[
            Dual64::new_scalar(10.0, 20.0),
            Dual64::new_scalar(12.0, 20.0),
        ]);
        let lu = LU::new(a).unwrap();
        let det = lu.determinant();
        assert_eq!((det.re, det.eps[0]), (-6.0, -4.0));
        let x = lu.solve(&b);
        assert_eq!(
            (x[0].re, x[0].eps[0], x[1].re, x[1].eps[0]),
            (1.0, 2.0, 2.0, 1.0)
        );
    }
```


Overlapping Code:
```
rr2(&[
[Dual64::new_scalar(4.0, 3.0), Dual64::new_scalar(3.0, 3.0)],
[Dual64::new_scalar(6.0, 1.0), Dual64::new_scalar(3.0, 2.0)],
]);
let b = arr1(&[
Dual64::new_scalar(10.0, 20.0),
Dual64::new_scalar(12.0, 20.0),
]);
let lu = LU::new(a).unwrap();
let det = lu.determinant();
assert_eq!((det.re, det.eps[0]), (-6.0, -4.0));
let x = lu.solve(&b);
assert_eq!(
(x[0].re, x[0].eps[0], x[1].re, x[1].eps[0]),
(1.0, 2.0, 2.0
```
<Overlap Ratio: 0.9030172413793104>

---

--- 83 --
Question ID: d10d475b1655a45a2b954d59652a0646e298eae7_43
Original Code:
```
pub fn serialize_structure_crate_model_rule_definition(
    object: &mut aws_smithy_json::serialize::JsonObjectWriter,
    input: &crate::model::RuleDefinition,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    if let Some(var_244) = &input.match_attributes {
        let mut object_245 = object.key("MatchAttributes").start_object();
        crate::json_ser::serialize_structure_crate_model_match_attributes(
            &mut object_245,
            var_244,
        )?;
        object_245.finish();
    }
    if let Some(var_246) = &input.actions {
        let mut array_247 = object.key("Actions").start_array();
        for item_248 in var_246 {
            {
                array_247.value().string(item_248);
            }
        }
        array_247.finish();
    }
    Ok(())
}
```


Overlapping Code:
```
pub fn serialize_structure_crate_model_rule_definition(
object: &mut aws_smithy_json::serialize::JsonObjectWriter,
input: &crate::model::RuleDefinition,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
if let Some(var_244) = &input.match_attributes {
let mut object_245 = object.key("MatchAttributes").start_object();
crate::json_ser::serialize_structure_crate_model_match_attributes(
&mut object_245,
var_244,
)?;
object_245.finish();
}
if let Some(var_246) = &input.actions {
let mut array_247 = object.key("Actions").start_array();
for item_248 in var_246 {
{
array_247.value().string(item_248);
}
}
array_247.finish();
}

```
<Overlap Ratio: 0.9876923076923076>

---

--- 84 --
Question ID: c6faf0bdd224fd7459877121d9036d9de4becc0b_10
Original Code:
```
fn parse_function_native_method() -> anyhow::Result<()> {
        let class = load_code("public native void log(int x);")?;
        assert_eq!(class.methods.len(), 1 /* <init> */ + 1);
        assert_eq!(*class.methods[0].id.name, "<init>");

        // Check method signature
        let method = &class.methods[1];
        assert_eq!(format!("{}", method.id), "Test.log(I)V");
        assert_eq!(format!("{}", method.descriptor), "(I)V");
        assert_eq!(
            method.flags,
            MethodAccessFlags::PUBLIC | MethodAccessFlags::NATIVE
        );

        // Check no Java implementation as native
        assert_eq!(*method.code.lock().unwrap(), None);

        Ok(())
    }
```


Overlapping Code:
```
hod() -> anyhow::Result<()> {
let class = load_code("public native void log(int x);")?;
assert_eq!(class.methods.len(), 1 /* <init> */ + 1);
assert_eq!(*class.methods[0].id.name, "<init>");
// Check method signature
let method = &class.methods[1];
assert_eq!(format!("{}", method.id), "Test.log(I)V");
assert_eq!(format!("{}", method.descriptor), "(I)V");
assert_eq!(
method.flags,
MethodAccessFlags::PUBLIC | MethodAccessFlags::NATIVE
);
// Check no Java implementation as native
assert_eq!(*method.code.
```
<Overlap Ratio: 0.8938053097345132>

---

--- 85 --
Question ID: 8145eeaa6e65368de7c0488d377cd4186ba4bedc_3
Original Code:
```
pub fn get_property_values(
        conn: &SqliteConnection,
        root_values: Vec<MfgBatchPropertyValue>,
    ) -> Result<Vec<PropertyValue>, MfgBatchStoreError> {
        let mut definitions = Vec::new();

        for root_value in root_values {
            let children = mfg_batch_property_value::table
                .select(mfg_batch_property_value::all_columns)
                .filter(mfg_batch_property_value::parent_property.eq(&root_value.parent_property))
                .load(conn)?;

            if children.is_empty() {
                definitions.push(PropertyValue::from(root_value));
            } else {
                definitions.push(PropertyValue::from((
                    root_value,
                    get_property_values(conn, children)?,
                )));
            }
        }

        Ok(definitions)
    }
```


Overlapping Code:
```
t_property_values(
conn: &SqliteConnection,
root_values: Vec<MfgBatchPropertyValue>,
) -> Result<Vec<PropertyValue>, MfgBatchStoreError> {
let mut definitions = Vec::new();
for root_value in root_values {
let children = mfg_batch_property_value::table
.select(mfg_batch_property_value::all_columns)
.filter(mfg_batch_property_value::parent_property.eq(&root_value.parent_property))
.load(conn)?;
if children.is_empty() {
definitions.push(PropertyValue::from(root_value));
} else {
definitions.push(PropertyValue::from((
root_value,
get_property_values(conn, children)?,
)));
}
}
Ok(definitions)
```
<Overlap Ratio: 0.9818181818181818>

---

--- 86 --
Question ID: 288b05878c115cf8d8040303a66291955e35deae_1
Original Code:
```
fn get_block(&self, position: usize) -> Self::Block {
        assert!(position < self.block_len(),
                format!("Bits::get_block: out of bounds ({}/{})",
                        position, self.block_len()));

        let first_bit = Self::Block::mul_nbits(position);
        let bit_count = Self::Block::block_bits(self.bit_len(), position);

        let mut result = Self::Block::zero();
        let mut mask = Self::Block::one();

        for i in 0 .. bit_count as u64 {
            if self.get_bit(first_bit + i) {
                result = result | mask;
            }
            mask = mask << 1;
        }

        result
    }
```


Overlapping Code:
```
fn get_block(&self, position: usize) -> Self::Block {
assert!(position < self.block_len(),
format!("Bits::get_block: out of bounds ({}/{})",
position, self.block_len()));
let first_bit = Self::Block::mul_nbits(position);
let bit_count = Self::Block::block_bits(self.bit_len(), position);
let mut result = Self::Block::zero();
let mut mask = Self::Block::one();
for i in 0 .. bit_count as u64 {
if self.get_bit(first_bit + i) {
result = result | mask;
}
mask = mask << 1;
}
re
```
<Overlap Ratio: 0.9875259875259875>

---

--- 87 --
Question ID: 69cb13c991faa98f161e44d0088980ebb6f80b61_1
Original Code:
```
fn do_something(data: &[u8], s: &mut StateTracker) {
    //Do something. Like writing it to a file or to stdout...
    std::io::stdout().write_all(data).unwrap();
    s.bytes_used += data.len() as u64;
}
```


Overlapping Code:
```
_something(data: &[u8], s: &mut StateTracker) {
//Do something. Like writing it to a file or to stdout...
std::io::stdout().write_all(data).unwrap();

```
<Overlap Ratio: 0.7853403141361257>

---

--- 88 --
Question ID: 818f200fd90b770a503fb40d7dc82f16b8c56849_1
Original Code:
```
async fn set_and_reset_distinct_attribute_with_dedicated_route() {
    let server = Server::new().await;
    let index = server.index("test");

    let (_response, _code) = index.update_distinct_attribute(json!("test")).await;
    index.wait_update_id(0).await;

    let (response, _) = index.get_distinct_attribute().await;

    assert_eq!(response, "test");

    index.update_distinct_attribute(json!(null)).await;

    index.wait_update_id(1).await;

    let (response, _) = index.get_distinct_attribute().await;

    assert_eq!(response, json!(null));
}
```


Overlapping Code:
```
edicated_route() {
let server = Server::new().await;
let index = server.index("test");
let (_response, _code) = index.update_distinct_attribute(json!("test")).await;
index.wait_update_id(0).await;
let (response, _) = index.get_distinct_attribute().await;
assert_eq!(response, "test");
index.update_distinct_attribute(json!(null)).await;
index.wait_update_id(1).await;
let (response, _) = index.get_distinct_attribute().await;
assert_eq!(response, jso
```
<Overlap Ratio: 0.8823529411764706>

---

--- 89 --
Question ID: ab6e81d1ccbbe7f48bca5ffaf070d494000bd8ac_146
Original Code:
```
fn compare_num_attrs_layout() {
    let schema = StandardSchema::NumAttrs(3);

    let greater_schemas = vec![StandardSchema::Layout {
        items: vec![],
        exhaustive: false,
    }];
    let not_related_schemas = vec![
        StandardSchema::Layout {
            items: vec![],
            exhaustive: true,
        },
        StandardSchema::Layout {
            items: vec![(
                ItemSchema::Field(SlotSchema::new(
                    StandardSchema::OfKind(ValueKind::Text),
                    StandardSchema::OfKind(ValueKind::Text),
                )),
                false,
            )],
            exhaustive: false,
        },
        StandardSchema::Layout {
            items: vec![
                (
                    ItemSchema::Field(SlotSchema::new(
                        StandardSchema::OfKind(ValueKind::Text),
                        StandardSchema::OfKind(ValueKind::Text),
                    )),
                    true,
                ),
                (
                    ItemSchema::Field(SlotSchema::new(
                        StandardSchema::OfKind(ValueKind::Text),
                        StandardSchema::OfKind(ValueKind::Text),
                    )),
                    true,
                ),
            ],
            exhaustive: false,
        },
    ];

    assert_less_than(schema.clone(), greater_schemas);
    assert_not_related(schema, not_related_schemas);
}
```


Overlapping Code:
```
andardSchema::NumAttrs(3);
let greater_schemas = vec![StandardSchema::Layout {
items: vec![],
exhaustive: false,
}];
let not_related_schemas = vec![
StandardSchema::Layout {
items: vec![],
exhaustive: true,
},
StandardSchema::Layout {
items: vec![(
ItemSchema::Field(SlotSchema::new(
StandardSchema::OfKind(ValueKind::Text),
StandardSchema::OfKind(ValueKind::Text),
)),
false,
)],
exhaustive: false,
},
StandardSchema::Layout {
items: vec![
(
ItemSchema::Field(SlotSchema::new(
StandardSchema::OfKind(ValueKind::Text),
StandardSchema::OfKind(ValueKind::Text),
)),
true,
),
(
ItemSchema::Field(SlotSchema::new(
StandardSchema::OfKind(ValueKind::Text),
StandardSchema::OfKind(ValueKind::Text),
)),
true,
),
],
exhaustive: false,
},
];
assert_less_than(schema.clone(), greater_schemas);
assert_not_related(schema, not_related_schemas);

```
<Overlap Ratio: 0.945516458569807>

---

--- 90 --
Question ID: a0351f349b997fec95b9cb84de06206dddeada89_0
Original Code:
```
pub fn fix_syntax_and_write(out_path: &Path, contents: String) {
    // move(x) ~> move x
    let contents = replace!(contents, r"move\((\w+)\)", "move $1");
    // copy(x) ~> copy x
    let contents = replace!(contents, r"copy\((\w+)\)", "copy $1");
    // resource StructName ~> resource struct StructName
    let contents = replace!(contents, r"resource\s+(\w)", "resource struct $1");
    // copyable ~> copyable
    let contents = replace!(contents, r":\s*copyable", NoExpand(": copyable"));
    // import ~> use
    let contents = replace!(contents, r"import", NoExpand("use"));
    // Self. is unnecessary
    let contents = replace!(contents, r"Self\.", NoExpand(""));
    // Module|Address. ~> Module|Address::
    let contents = replace!(contents, r"(([A-Z]\w*)|(\}\})|(0x\d+))\.", "$1::");
    // add fun keyword to functions
    let contents = replace!(
        contents,
        r"(((public|native| )*))(\w+\(.*\).*\{)",
        |cap: &Captures| format!("{}fun {}", &cap[1], &cap[4])
    );
    fs::write(out_path, contents.as_bytes()).unwrap();
}
```


Overlapping Code:
```
yntax_and_write(out_path: &Path, contents: String) {
// move(x) ~> move x
let contents = replace!(contents, r"move\((\w+)\)", "move $1");
// copy(x) ~> copy x
let contents = replace!(contents, r"copy\((\w+)\)", "copy $1");
// resource StructName ~> resource struct StructName
let contents = replace!(contents, r"resource\s+(\w)", "resource struct $1");
// copyable ~> copyable
let contents = replace!(contents, r":\s*copyable", NoExpand(": copyable"));
// import ~> use
let contents = replace!(contents, r"import", NoExpand("use"));
// Self. is unnecessary
let contents = replace!(contents, r"Self\.", NoExpand(""));
// Module|Address. ~> Module|Address::
let contents = replace!(contents, r"(([A-Z]\w*)|(\}\})|(0x\d+))\.", "$1::");
// add fun keyword to functions
let contents = replace!(
contents,
r"(((public|native| )*))(\w+\(.*\).*\{)",
|cap: &Captures| format!("{}fun {}", &cap[1], &cap[4])
);
fs::write(out_path, contents.a
```
<Overlap Ratio: 0.9647302904564315>

---

--- 91 --
Question ID: 884bae434a424fe9c10f1165f1c91cef6c285d03_3
Original Code:
```
pub(crate) fn test_chunk_compression_rw(compression: compression::CompressionType) {
    let array_meta = ArrayMetadata::new(
        smallvec![10, 10, 10],
        smallvec![5, 5, 5],
        i32::ZARR_TYPE,
        compression,
    );
    let chunk_data: Vec<i32> = (0..125_i32).collect();
    let chunk_in = SliceDataChunk::new(smallvec![0, 0, 0], &chunk_data);

    let mut inner: Vec<u8> = Vec::new();

    <DefaultChunk as DefaultChunkWriter<i32, _, _>>::write_chunk(
        &mut inner,
        &array_meta,
        &chunk_in,
    )
    .expect("write_chunk failed");

    let chunk_out = <DefaultChunk as DefaultChunkReader<i32, _>>::read_chunk(
        &inner[..],
        &array_meta,
        smallvec![0, 0, 0],
    )
    .expect("read_chunk failed");

    assert_eq!(chunk_out.get_grid_position(), &[0, 0, 0]);
    assert_eq!(chunk_out.get_data(), &chunk_data[..]);
}
```


Overlapping Code:
```
ion: compression::CompressionType) {
let array_meta = ArrayMetadata::new(
smallvec![10, 10, 10],
smallvec![5, 5, 5],
i32::ZARR_TYPE,
compression,
);
let chunk_data: Vec<i32> = (0..125_i32).collect();
let chunk_in = SliceDataChunk::new(smallvec![0, 0, 0], &chunk_data);
let mut inner: Vec<u8> = Vec::new();
<DefaultChunk as DefaultChunkWriter<i32, _, _>>::write_chunk(
&mut inner,
&array_meta,
&chunk_in,
)
.expect("write_chunk failed");
let chunk_out = <DefaultChunk as DefaultChunkReader<i32, _>>::read_chunk(
&inner[..],
&array_meta,
smallvec![0, 0, 0],
)
.expect("read_chunk failed");
assert_eq!(chunk_out.get_grid_position(), &[0, 0, 0]);
assert_eq!(chunk_out.get_d
```
<Overlap Ratio: 0.9004037685060565>

---

--- 92 --
Question ID: 511a11219c3a9bfee342d25c620cc7c91c43683c_5
Original Code:
```
fn build_closure_expression(
    mut symbols: &mut Vec<Symbol>,
    mut syntax_tree: &mut SyntaxTree,
    symbol: Symbol,
) -> Result<ExpressionNode, Error> {
    match symbol {
        Symbol::ClosureParamsOpen => {}
        symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
    }

    let symbol = symbols.pop().expect("Unfinished closure!");

    let mut params = match symbol {
        Symbol::FunctionParamsParamName(_) => vec![build_closure_param_node(
            &mut symbols,
            &mut syntax_tree,
            symbol,
        )?],
        Symbol::ClosureParamsClose => vec![],
        symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
    };

    if params.len() > 0 {
        loop {
            let symbol = symbols.pop().expect("Unfinished closure!");

            match symbol {
                Symbol::ClosureParamsComma => {
                    let symbol = symbols.pop().expect("Unfinished closure!");

                    params.push(build_closure_param_node(
                        &mut symbols,
                        &mut syntax_tree,
                        symbol,
                    )?);
                }
                Symbol::ClosureParamsClose => {
                    break;
                }
                symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
            }
        }
    }

    let return_type = match symbols.last().expect("Unfinished closure!") {
        Symbol::FunctionReturnTypeColon => {
            symbols.pop();

            let symbol = symbols.pop().expect("Unfinished closure!");

            Some(build_type_node(&mut symbols, &mut syntax_tree, symbol)?)
        }
        _ => None,
    };

    let signature = ClosureSignatureNode {
        params,
        return_type,
    };

    match symbols.pop().expect("Unfinished closure!") {
        Symbol::ClosureArrow => {}
        symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
    }

    let mut statements = match symbols.last().expect("Unfinished closure!") {
        Symbol::FunctionExpressionsOpenBrace => {
            symbols.pop();
            vec![]
        }
        _ => {
            let symbol = symbols.pop().expect("Unfinished closure!");
            vec![StatementNode::Expression(build_expression_node(
                &mut symbols,
                &mut syntax_tree,
                symbol,
            )?)]
        }
    };

    if statements.len() == 0 {
        loop {
            let symbol = symbols.pop().expect("Unfinished function!");

            match symbol {
                Symbol::FunctionExpressionsCloseBrace => {
                    break;
                }
                symbol => statements.push(build_statement_node(
                    &mut symbols,
                    &mut syntax_tree,
                    symbol,
                )?),
            }
        }
    }

    let body = FunctionBodyNode { statements };

    return Ok(ExpressionNode::Closure(ClosureExpressionNode {
        signature,
        body,
    }));
}
```


Overlapping Code:
```
n(
mut symbols: &mut Vec<Symbol>,
mut syntax_tree: &mut SyntaxTree,
symbol: Symbol,
) -> Result<ExpressionNode, Error> {
match symbol {
Symbol::ClosureParamsOpen => {}
symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
}
let symbol = symbols.pop().expect("Unfinished closure!");
let mut params = match symbol {
Symbol::FunctionParamsParamName(_) => vec![build_closure_param_node(
&mut symbols,
&mut syntax_tree,
symbol,
)?],
Symbol::ClosureParamsClose => vec![],
symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
};
if params.len() > 0 {
loop {
let symbol = symbols.pop().expect("Unfinished closure!");
match symbol {
Symbol::ClosureParamsComma => {
let symbol = symbols.pop().expect("Unfinished closure!");
params.push(build_closure_param_node(
&mut symbols,
&mut syntax_tree,
symbol,
)?);
}
Symbol::ClosureParamsClose => {
break;
}
symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
}
}
}
let return_type = match symbols.last().expect("Unfinished closure!") {
Symbol::FunctionReturnTypeColon => {
symbols.pop();
let symbol = symbols.pop().expect("Unfinished closure!");
Some(build_type_node(&mut symbols, &mut syntax_tree, symbol)?)
}
_ => None,
};
let signature = ClosureSignatureNode {
params,
return_type,
};
match symbols.pop().expect("Unfinished closure!") {
Symbol::ClosureArrow => {}
symbol => todo!("Unexpected symbol: {:?}\n\n{:?}", symbol, syntax_tree),
}
let mut statements = match symbols.last().expect("Unfinished closure!") {
Symbol::FunctionExpressionsOpenBrace => {
symbols.pop();
vec![]
}
_ => {
let symbol = symbols.pop().expect("Unfinished closure!");
vec![StatementNode::Expression(build_expression_node(
&mut symbols,
&mut syntax_tree,
symbol,
)?)]
}
};
if sta
```
<Overlap Ratio: 0.9706045479755963>

---

--- 93 --
Question ID: 5128af75d30e943fd2c2d2ec6394af47bbbbfdbb_11
Original Code:
```
fn spawn_clone_with_ref_local()
{
	let (tx, mut rx) = mpsc::channel( 1 );
	let exec         = Bindgen::default();

	increment_clone_local( 4, &exec, tx );

	let fut = async move
	{
		let result = rx.next().await.expect( "Some" );

		assert_eq!( 5u8, result );
	};

	exec.spawn_local( fut ).expect( "spawn future" );
}
```


Overlapping Code:
```
awn_clone_with_ref_local()
{
let (tx, mut rx) = mpsc::channel( 1 );
let exec = Bindgen::default();
increment_clone_local( 4, &exec, tx );
let fut = async move
{
let result = rx.next().await.expect( "Some" );
assert_eq!( 5u8, result );
};
exec.spawn_local( fut ).expect( "spawn futur
```
<Overlap Ratio: 0.9591836734693877>

---

--- 94 --
Question ID: baf3f78ce9b4811ed2e529fe17ad489708b108bb_0
Original Code:
```
fn test_regex_lit() {
        assert_json_snapshot!(parse_literal("/abc/g".into()).unwrap().1);
        assert_json_snapshot!(parse_literal(r#"/abc\\/g"#.into()).unwrap().1);
        assert_json_snapshot!(parse_literal(r#"/\\\//g"#.into()).unwrap().1);
        assert_json_snapshot!(parse_literal(r#"/[^/]*$/"#.into()).unwrap().1);
    }
```


Overlapping Code:
```
t_json_snapshot!(parse_literal("/abc/g".into()).unwrap().1);
assert_json_snapshot!(parse_literal(r#"/abc\\/g"#.into()).unwrap().1);
assert_json_snapshot!(parse_literal(r#"/\\\//g"#.into()).unwrap().1);
assert_json_snapshot!(parse_literal(r#"/[^/]*$/"
```
<Overlap Ratio: 0.8305647840531561>

---

--- 95 --
Question ID: 24068e3b222ff3ad03e1e0e3566ae2cdfae4aeaf_1
Original Code:
```
fn copy(matches: getopts::Matches) {
    let sources: Vec<String> = if matches.free.is_empty() {
        show_error!("Missing SOURCE argument. Try --help.");
        panic!()
    } else {
        // All but the last argument:
        matches.free[..matches.free.len() - 1].iter().cloned().collect()
    };
    let dest = if matches.free.len() < 2 {
        show_error!("Missing DEST argument. Try --help.");
        panic!()
    } else {
        // Only the last argument:
        Path::new(&matches.free[matches.free.len() - 1])
    };

    assert!(sources.len() >= 1);

    if sources.len() == 1 {
        let source = Path::new(&sources[0]);
        let same_file = paths_refer_to_same_file(source, dest).unwrap_or_else(|err| {
            match err.kind() {
                ErrorKind::NotFound => false,
                _ => {
                    show_error!("{}", err);
                    panic!()
                }
            }
        });

        if same_file {
            show_error!("\"{}\" and \"{}\" are the same file",
                source.display(),
                dest.display());
            panic!();
        }

        if let Err(err) = fs::copy(source, dest) {
            show_error!("{}", err);
            panic!();
        }
    } else {
        if !dest.is_dir() {
            show_error!("TARGET must be a directory");
            panic!();
        }

        for src in &sources {
            let source = Path::new(&src);

            if !source.is_file() {
                show_error!("\"{}\" is not a file", source.display());
                continue;
            }

            let mut full_dest = dest.to_path_buf();

            full_dest.push(source.to_str().unwrap());

            println!("{}", full_dest.display());

            let io_result = fs::copy(source, full_dest);

            if let Err(err) = io_result {
                show_error!("{}", err);
                panic!()
            }
        }
    }
}
```


Overlapping Code:
```
opy(matches: getopts::Matches) {
let sources: Vec<String> = if matches.free.is_empty() {
show_error!("Missing SOURCE argument. Try --help.");
panic!()
} else {
// All but the last argument:
matches.free[..matches.free.len() - 1].iter().cloned().collect()
};
let dest = if matches.free.len() < 2 {
show_error!("Missing DEST argument. Try --help.");
panic!()
} else {
// Only the last argument:
Path::new(&matches.free[matches.free.len() - 1])
};
assert!(sources.len() >= 1);
if sources.len() == 1 {
let source = Path::new(&sources[0]);
let same_file = paths_refer_to_same_file(source, dest).unwrap_or_else(|err| {
match err.kind() {
ErrorKind::NotFound => false,
_ => {
show_error!("{}", err);
panic!()
}
}
});
if same_file {
show_error!("\"{}\" and \"{}\" are the same file",
source.display(),
dest.display());
panic!();
}
if let Err(err) = fs::copy(source, dest) {
show_error!("{}", err);
panic!();
}
} else {
if !dest.is_dir() {
show_error!("TARGET must be a directory");
panic!();
}
for src in &sources {
let source = Path::new(&src);
if !source.is_file() {
show_error!("\"{}\" is not a file", source.display());
continue;
}
let mut full_dest = dest.to_path_buf();
full_dest.push(source.to_str().unwrap());
println!("{}", full_dest.display());
let io_result = fs::copy(source, full_dest);
if let Err(err) = io_result {
show_
```
<Overlap Ratio: 0.9714494875549048>

---

--- 96 --
Question ID: 4c84db8b6b41fc6cd5d6f54ad130d3363987b677_251
Original Code:
```
pub fn serialize_structure_crate_model_auto_ml_security_config(
    object: &mut aws_smithy_json::serialize::JsonObjectWriter,
    input: &crate::model::AutoMlSecurityConfig,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    if let Some(var_2009) = &input.volume_kms_key_id {
        object.key("VolumeKmsKeyId").string(var_2009);
    }
    if input.enable_inter_container_traffic_encryption {
        object
            .key("EnableInterContainerTrafficEncryption")
            .boolean(input.enable_inter_container_traffic_encryption);
    }
    if let Some(var_2010) = &input.vpc_config {
        let mut object_2011 = object.key("VpcConfig").start_object();
        crate::json_ser::serialize_structure_crate_model_vpc_config(&mut object_2011, var_2010)?;
        object_2011.finish();
    }
    Ok(())
}
```


Overlapping Code:
```
 serialize_structure_crate_model_auto_ml_security_config(
object: &mut aws_smithy_json::serialize::JsonObjectWriter,
input: &crate::model::AutoMlSecurityConfig,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
if let Some(var_2009) = &input.volume_kms_key_id {
object.key("VolumeKmsKeyId").string(var_2009);
}
if input.enable_inter_container_traffic_encryption {
object
.key("EnableInterContainerTrafficEncryption")
.boolean(input.enable_inter_container_traffic_encryption);
}
if let Some(var_2010) = &input.vpc_config {
let mut object_2011 = object.key("VpcConfig").start_object();
crate::json_ser::serialize_structure_crate_model_vpc_config(&mut object_2011, var_20
```
<Overlap Ratio: 0.9395604395604396>

---

--- 97 --
Question ID: 7bf327281bbd0348593ce16bd9c8d59140cb577d_0
Original Code:
```
fn set_and_retrieve_cached_onionskin() {
    let anim = create_animation();

    anim.perform_edits(vec![AnimationEdit::AddNewLayer(24)]);

    let layer           = anim.get_layer_with_id(24).unwrap();
    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));

    cache.store(CacheType::OnionSkinLayer, Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill]));

    let cache           = layer.get_canvas_cache_at_time(Duration::from_millis(2000));
    let cached_drawing  = cache.retrieve(CacheType::OnionSkinLayer);

    assert!(cached_drawing == Some(Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill])));
}
```


Overlapping Code:
```
e_cached_onionskin() {
let anim = create_animation();
anim.perform_edits(vec![AnimationEdit::AddNewLayer(24)]);
let layer = anim.get_layer_with_id(24).unwrap();
let cache = layer.get_canvas_cache_at_time(Duration::from_millis(2000));
cache.store(CacheType::OnionSkinLayer, Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill]));
let cache = layer.get_canvas_cache_at_time(Duration::from_millis(2000));
let cached_drawing = cache.retrieve(CacheType::OnionSkinLayer);
assert!(cached_drawing == Some(Arc::new(vec![Draw::Path(PathOp::NewPath), Draw::Fill
```
<Overlap Ratio: 0.9566724436741768>

---

--- 98 --
Question ID: 276674de8f0bf6670a1a8b1aa87c6f32589ca474_3
Original Code:
```
unsafe fn column_butterfly4(rows: [Self; 4], rotation: Rotation90<Self>) -> [Self; 4] {
        // Algorithm: 2x2 mixed radix

        // Perform the first set of size-2 FFTs.
        let [mid0, mid2] = Self::column_butterfly2([rows[0], rows[2]]);
        let [mid1, mid3] = Self::column_butterfly2([rows[1], rows[3]]);

        // Apply twiddle factors (in this case just a rotation)
        let mid3_rotated = mid3.rotate90(rotation);

        // Transpose the data and do size-2 FFTs down the columns
        let [output0, output1] = Self::column_butterfly2([mid0, mid1]);
        let [output2, output3] = Self::column_butterfly2([mid2, mid3_rotated]);

        // Swap outputs 1 and 2 in the output to do a square transpose
        [output0, output2, output1, output3]
    }
```


Overlapping Code:
```
terfly4(rows: [Self; 4], rotation: Rotation90<Self>) -> [Self; 4] {
// Algorithm: 2x2 mixed radix
// Perform the first set of size-2 FFTs.
let [mid0, mid2] = Self::column_butterfly2([rows[0], rows[2]]);
let [mid1, mid3] = Self::column_butterfly2([rows[1], rows[3]]);
// Apply twiddle factors (in this case just a rotation)
let mid3_rotated = mid3.rotate90(rotation);
// Transpose the data and do size-2 FFTs down the columns
let [output0, output1] = Self::column_butterfly2([mid0, mid1]);
let [output2, output3] = Self::column_butterfly2([mid2, mid3_rotated]);
// Swap outputs 1 and 2 in the output to do a square transpose
[output0, output2, output1, out
```
<Overlap Ratio: 0.9604105571847508>

---

--- 99 --
Question ID: 3e0ce1e812879c263dd5be267ffee55661505718_0
Original Code:
```
pub fn send(socket: &std::net::UdpSocket, transmits: &[Transmit]) -> Result<usize> {
        let mut sent = 0;
        for transmit in transmits {
            match socket.send_to(&transmit.contents, &transmit.destination) {
                Ok(_) => {
                    sent += 1;
                }
                Err(_) if sent != 0 => {
                    // We need to report that some packets were sent in this case, so we rely on
                    // errors being either harmlessly transient (in the case of WouldBlock) or
                    // recurring on the next call.
                    return Ok(sent);
                }
                Err(e) => {
                    return Err(e);
                }
            }
        }
        Ok(sent)
    }
```


Overlapping Code:
```
nsmits: &[Transmit]) -> Result<usize> {
let mut sent = 0;
for transmit in transmits {
match socket.send_to(&transmit.contents, &transmit.destination) {
Ok(_) => {
sent += 1;
}
Err(_) if sent != 0 => {
// We need to report that some packets were sent in this case, so we rely on
// errors being either harmlessly transient (in the case of WouldBlock) or
// recurring on the next call.
return Ok(sent);
}
Err(e) => {
return Err(
```
<Overlap Ratio: 0.8676171079429735>

---

--- 100 --
Question ID: f9acdd1be3b820ad6f684d935997e95cb5640a75_5
Original Code:
```
fn read_req(p: &mut ServerProtocol, src: &[u8], read_size: usize) -> TestRequest {
        const READ_SIZE_MAX: usize = 1024;
        const LOOPS_MAX: u32 = 20;

        assert!(read_size <= READ_SIZE_MAX);

        assert_eq!(p.state(), ServerState::ReceivingRequest);

        let mut rbuf = io::Cursor::new(src);

        let mut result = TestRequest::new();

        assert_eq!(p.state(), ServerState::ReceivingRequest);

        let mut headers = [httparse::EMPTY_HEADER; HEADERS_MAX];

        let req = p.recv_request(&mut rbuf, &mut headers).unwrap().unwrap();

        result.method = String::from(req.method);
        result.uri = String::from(req.uri);

        for h in req.headers {
            let name = String::from(h.name);
            let value = Vec::from(h.value);
            result.headers.push((name, value));
        }

        for _ in 0..LOOPS_MAX {
            if p.state() != ServerState::ReceivingBody {
                break;
            }

            let mut buf = [0; READ_SIZE_MAX];

            let (size, trailing_headers) = p
                .recv_body(&mut rbuf, &mut buf[..read_size], &mut headers)
                .unwrap();

            result.body.extend_from_slice(&buf[..size]);

            if let Some(trailing_headers) = trailing_headers {
                for h in trailing_headers {
                    let name = String::from(h.name);
                    let value = Vec::from(h.value);
                    result.trailing_headers.push((name, value));
                }
            }
        }

        result.persistent = p.is_persistent();

        assert_eq!(p.state(), ServerState::AwaitingResponse);

        return result;
    }
```


Overlapping Code:
```
 src: &[u8], read_size: usize) -> TestRequest {
const READ_SIZE_MAX: usize = 1024;
const LOOPS_MAX: u32 = 20;
assert!(read_size <= READ_SIZE_MAX);
assert_eq!(p.state(), ServerState::ReceivingRequest);
let mut rbuf = io::Cursor::new(src);
let mut result = TestRequest::new();
assert_eq!(p.state(), ServerState::ReceivingRequest);
let mut headers = [httparse::EMPTY_HEADER; HEADERS_MAX];
let req = p.recv_request(&mut rbuf, &mut headers).unwrap().unwrap();
result.method = String::from(req.method);
result.uri = String::from(req.uri);
for h in req.headers {
let name = String::from(h.name);
let value = Vec::from(h.value);
result.headers.push((name, value));
}
for _ in 0..LOOPS_MAX {
if p.state() != ServerState::ReceivingBody {
break;
}
let mut buf = [0; READ_SIZE_MAX];
let (size, trailing_headers) = p
.recv_body(&mut rbuf, &mut buf[..read_size], &mut headers)
.unwrap();
result.body.extend_from_slice(&buf[..size]);
if let Some(trailing_headers) = trailing_headers {
for h in trailing_headers {
let name = String::from(h.name);
let value = Vec::from(h.value);
result.trailing_headers.push((name, value));
}
}
}
result.persistent = p.is_persistent();
assert_eq!(p.state(), ServerState::AwaitingResp
```
<Overlap Ratio: 0.9538950715421304>

---

--- 101 --
Question ID: c0ef355e1a4d368491e2928aecf91b843ab68c58_1
Original Code:
```
pub fn get_test_data() -> Vec<u8> {
    use std::env;
    let path = env::var("TEST_FILE").unwrap_or("tests/pg11.txt".to_string());
    get_test_file_data(&path)
}
```


Overlapping Code:
```
 get_test_data() -> Vec<u8> {
use std::env;
let path = env::var("TEST_FILE").unwrap_or("tests/pg11.txt".to_string());
get_test_fil
```
<Overlap Ratio: 0.8609271523178808>

---

--- 102 --
Question ID: a2d2f0976d20104c3aa34b53503e85381dd4aa5a_2
Original Code:
```
fn linspace(min: f64, max: f64, n: usize) -> Vec<f64> {
    if n == 1 {
        return vec![min];
    }

    let d = max - min;
    let l = n as f64 - 1.0;
    (0..n).map(|i| min + (i as f64 * d) / l).collect()
}
```


Overlapping Code:
```
) -> Vec<f64> {
if n == 1 {
return vec![min];
}
let d = max - min;
let l = n as f64 - 1.0;
(0..n).ma
```
<Overlap Ratio: 0.546448087431694>

---

--- 103 --
Question ID: 9e7bd9389b966dbd7dee5731f391c7dbf7ed5188_2
Original Code:
```
fn draw_border(settings: &Settings, cursor: &TerminalCursor) {
    let room = &settings.room;
    let chars = &settings.chars;

    let draw_horizontal = |y: u16| {
        let border_char = &chars.room.border_horizontal;
        let printable = printable_maybe_repeat(
            border_char,
            Some(settings.room.width as usize),
        );
        cursor.goto(0, y).unwrap();
        print!("{}", printable);
    };
    let draw_vertical = |x: u16| {
        let border_char = &chars.room.border_vertical;
        let printable = printable_maybe_repeat(border_char, None);
        for y in 0 .. room.height {
            cursor.goto(x, y).unwrap();
            print!("{}", printable);
        }
    };

    let right = room.width - 1;
    let bottom = room.height - 1;
    draw_horizontal(0);
    draw_horizontal(bottom);
    draw_vertical(0);
    draw_vertical(right);
    // Draw corners
    let corner_printable =
        printable_maybe_repeat(&chars.room.border_corner, None);
    cursor.goto(0, 0).unwrap();
    print!("{}", corner_printable);
    cursor.goto(right, 0).unwrap();
    print!("{}", corner_printable);
    cursor.goto(0, bottom).unwrap();
    print!("{}", corner_printable);
    cursor.goto(right, bottom).unwrap();
    print!("{}", corner_printable);
}
```


Overlapping Code:
```
settings: &Settings, cursor: &TerminalCursor) {
let room = &settings.room;
let chars = &settings.chars;
let draw_horizontal = |y: u16| {
let border_char = &chars.room.border_horizontal;
let printable = printable_maybe_repeat(
border_char,
Some(settings.room.width as usize),
);
cursor.goto(0, y).unwrap();
print!("{}", printable);
};
let draw_vertical = |x: u16| {
let border_char = &chars.room.border_vertical;
let printable = printable_maybe_repeat(border_char, None);
for y in 0 .. room.height {
cursor.goto(x, y).unwrap();
print!("{}", printable);
}
};
let right = room.width - 1;
let bottom = room.height - 1;
draw_horizontal(0);
draw_horizontal(bottom);
draw_vertical(0);
draw_vertical(right);
// Draw corners
let corner_printable =
printable_maybe_repeat(&chars.room.border_corner, None);
cursor.goto(0, 0).unwrap();
print!("{}", corner_printable);
cursor.goto(right, 0).unwrap();
print!("{}", corner_printable);
cursor.goto(0, bottom).unwrap();
print!("{}", corner_printable);
cursor.goto(right, bottom).unwrap();
print!("{}", corner_printabl
```
<Overlap Ratio: 0.9813084112149533>

---

--- 104 --
Question ID: dedc9bc7459e74b5a527e66e0bbc160bd46ad9a6_6
Original Code:
```
fn slow_on_write() {
        // this test is pretty similar to the above, except that it lags the on_write call instead.
        let exec = fasync::Executor::new().expect("Executor creation failed");

        let write_counter = Arc::new(AtomicUsize::new(0));
        let client_counter = Arc::new(AtomicUsize::new(0));
        let client_count = client_counter.clone();
        let (finish_future_sender, finish_future_receiver) = oneshot::channel::<()>();
        let finish_future_receiver = finish_future_receiver.shared();

        run_server_client_with_executor(
            OPEN_RIGHT_WRITABLE,
            exec,
            write_only(100, |content| {
                let write_counter = write_counter.clone();
                let finish_future_receiver = finish_future_receiver.clone();
                async move {
                    assert_eq!(*&content, b"content");
                    write_counter.fetch_add(1, Ordering::Relaxed);
                    await!(finish_future_receiver)
                        .expect("finish_future_sender was not called before been dropped.");
                    write_counter.fetch_add(1, Ordering::Relaxed);
                    Ok(())
                }
            }),
            async move |proxy| {
                client_count.fetch_add(1, Ordering::Relaxed);

                assert_write!(proxy, "content");
                assert_close!(proxy);

                client_count.fetch_add(1, Ordering::Relaxed);
            },
            |run_until_stalled_assert| {
                let check_write_client_counts = |expected_write, expected_client| {
                    assert_eq!(write_counter.load(Ordering::Relaxed), expected_write);
                    assert_eq!(client_counter.load(Ordering::Relaxed), expected_client);
                };

                run_until_stalled_assert(false);

                // The server and the client are waiting.
                check_write_client_counts(1, 1);

                finish_future_sender.send(()).unwrap();
                run_until_stalled_assert(true);

                // The server and the client are done.
                check_write_client_counts(2, 2);
            },
        );
    }
```


Overlapping Code:
```
rite() {
// this test is pretty similar to the above, except that it lags the on_write call instead.
let exec = fasync::Executor::new().expect("Executor creation failed");
let write_counter = Arc::new(AtomicUsize::new(0));
let client_counter = Arc::new(AtomicUsize::new(0));
let client_count = client_counter.clone();
let (finish_future_sender, finish_future_receiver) = oneshot::channel::<()>();
let finish_future_receiver = finish_future_receiver.shared();
run_server_client_with_executor(
OPEN_RIGHT_WRITABLE,
exec,
write_only(100, |content| {
let write_counter = write_counter.clone();
let finish_future_receiver = finish_future_receiver.clone();
async move {
assert_eq!(*&content, b"content");
write_counter.fetch_add(1, Ordering::Relaxed);
await!(finish_future_receiver)
.expect("finish_future_sender was not called before been dropped.");
write_counter.fetch_add(1, Ordering::Relaxed);
Ok(())
}
}),
async move |proxy| {
client_count.fetch_add(1, Ordering::Relaxed);
assert_write!(proxy, "content");
assert_close!(proxy);
client_count.fetch_add(1, Ordering::Relaxed);
},
|run_until_stalled_assert| {
let check_write_client_counts = |expected_write, expected_client| {
assert_eq!(write_counter.load(Ordering::Relaxed), expected_write);
assert_eq!(client_counter.load(Ordering::Relaxed), expected_client);
};
run_until_stalled_assert(false);
// The server and the client are waiting.
check_write_client_counts(1, 1);
finish_future_sender.send(()).unwrap();
run_until_stalled_assert(true);
// The server and the client are done.
check_write_client
```
<Overlap Ratio: 0.9785353535353535>

---

--- 105 --
Question ID: 1751a92244b9b42fd82dc86705f209fa7f258188_2
Original Code:
```
fn test_is_container() {
        let docker_cgroup = r#"
12:cpu,cpuacct:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1
11:perf_event:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1
10:rdma:/"#;
        assert!(is_container(docker_cgroup));
        let init_cgroup = r#"
12:cpu,cpuacct:/
11:perf_event:/
0::/init.scope"#;
        assert!(!is_container(init_cgroup));
        let k8s_cgroup = r#"
12:hugetlb:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1
11:cpuset:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1"#;
        assert!(is_container(k8s_cgroup));
    }
```


Overlapping Code:
```
tainer() {
let docker_cgroup = r#"
12:cpu,cpuacct:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1
11:perf_event:/docker/c6fa62a9938149f6098fd0cdaffc9cdf0f526f25d97b5f6e2a4cc1fccc7f7ce1
10:rdma:/"#;
assert!(is_container(docker_cgroup));
let init_cgroup = r#"
12:cpu,cpuacct:/
11:perf_event:/
0::/init.scope"#;
assert!(!is_container(init_cgroup));
let k8s_cgroup = r#"
12:hugetlb:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1
11:cpuset:/kubepods/besteffort/poda00e29fd-7bbd-11e9-8679-fa163ea7e3b8/c4b1403f3d9c7ce261be851df71d9a9773c53419075ccda39ae8fe6a39fd2eb1"#;
assert!(is_container(k8s_cgroup)
```
<Overlap Ratio: 0.9749303621169917>

---

--- 106 --
Question ID: 3bced46876805d59d4c7b63e4e102e39ced5ad13_4
Original Code:
```
fn bench_hadamard_larger(b: &mut Bencher) {
        let n = 8;
        let indices = (0..n).collect::<Vec<_>>();
        let mut state = FeynmanState::<f64>::new(n);

        let mult = (1.0 / 2.0f64).sqrt();
        let mat = from_reals(&[mult, mult, mult, -mult]);

        let ops: Vec<UnitaryOp> = (0..n).map(|i| Matrix(vec![i], mat.clone())).collect();
        ops.iter().for_each(|op| state.apply_op(op));

        b.iter(|| state.stochastic_measure(&indices, 0.0));
    }
```


Overlapping Code:
```
 bench_hadamard_larger(b: &mut Bencher) {
let n = 8;
let indices = (0..n).collect::<Vec<_>>();
let mut state = FeynmanState::<f64>::new(n);
let mult = (1.0 / 2.0f64).sqrt();
let mat = from_reals(&[mult, mult, mult, -mult]);
let ops: Vec<UnitaryOp> = (0..n).map(|i| Matrix(vec![i], mat.clone())).collect();
ops.iter().for_each(|op| state.apply_op(op));
b.iter(|| state.stochastic_measure(&indices, 0.0
```
<Overlap Ratio: 0.9828009828009828>

---

--- 107 --
Question ID: fcfe694812796a9074cc0d41097fd1d0c3044cc7_4
Original Code:
```
fn lp_3_mat_10_50(b: &mut Bencher) {
    let a = Matrix::new(10, 50, vec![2.0;500]);
    let lp = Lp::Integer(3);

    b.iter(|| {
    	let _ = black_box(MatrixNorm::norm(&lp, &a));
    });
}
```


Overlapping Code:
```
50(b: &mut Bencher) {
let a = Matrix::new(10, 50, vec![2.0;500]);
let lp = Lp::Integer(3);
b.iter(|| {
let _ = black_box(MatrixNorm::norm(&lp, &a));
});
```
<Overlap Ratio: 0.8994082840236687>

---

--- 108 --
Question ID: c95d9a131896a303b21d2e61f964bf127f8db7b1_0
Original Code:
```
fn split<'a>(r: &'a Regex, text: &'a str) -> Vec<&'a str> {
    let mut result = Vec::new();
    let mut last = 0;
    for (index, matched) in text.match_indices(r) {
        if last != index {
            result.push(&text[last..index]);
        }
        result.push(matched);

        last = index + matched.len();
    }
    if last < text.len() {
        result.push(&text[last..]);
    }
    result
}
```


Overlapping Code:
```
Regex, text: &'a str) -> Vec<&'a str> {
let mut result = Vec::new();
let mut last = 0;
for (index, matched) in text.match_indices(r) {
if last != index {
result.push(&text[last..index]);
}
result.push(matched);
last = index + matched.len();
}
if last < text.len() {
result.push(&text[last..]);
}
resu
```
<Overlap Ratio: 0.9259259259259259>

---

--- 109 --
Question ID: c2238439db5c8b40ea7325b23ef33ef0136d69ce_1
Original Code:
```
fn query() {
        let rs = RangedStates::from_slice(&[(1..4, 1u8), (5..7, 2)]);
        assert_eq!(rs.query(&(0..1), |v| *v), None);
        assert_eq!(rs.query(&(1..3), |v| *v), Some(Ok(1)));
        assert_eq!(rs.query(&(1..6), |v| *v), Some(Err(())));
    }
```


Overlapping Code:
```
gedStates::from_slice(&[(1..4, 1u8), (5..7, 2)]);
assert_eq!(rs.query(&(0..1), |v| *v), None);
assert_eq!(rs.query(&(1..3), |v| *v), Some(Ok(1)));
assert_eq!(rs.query(&(1..6), |v| *v), Some(Err(())));
```
<Overlap Ratio: 0.8810572687224669>

---

--- 110 --
Question ID: 07f4ae5c0e290177615b3c9cbe0ac358020bc5bb_1
Original Code:
```
fn make_request_with_document_id() {

        let doc_content = serde_json::builder::ObjectBuilder::new()
            .insert("field", 42)
            .build();

        let transport = MockTransport::new();

        let expected = transport
            .put(vec!["foo", "bar"])
            .with_accept_json()
            .with_json_content(&doc_content)
            .unwrap();

        let got = {
            let mut action = CreateDocument::new(&transport, "/foo", &doc_content).with_document_id("bar");
            action.make_request().unwrap()
        };

        assert_eq!(expected, got);
    }
```


Overlapping Code:
```
quest_with_document_id() {
let doc_content = serde_json::builder::ObjectBuilder::new()
.insert("field", 42)
.build();
let transport = MockTransport::new();
let expected = transport
.put(vec!["foo", "bar"])
.with_accept_json()
.with_json_content(&doc_content)
.unwrap();
let got = {
let mut action = CreateDocument::new(&transport, "/foo", &doc_content).with_document_id("bar");
action.make_request().unwrap()
};
assert_eq!(expected, got);
}
```
<Overlap Ratio: 0.9777777777777777>

---

--- 111 --
Question ID: ec8d4129821e19102a63373cd475b7cb03b04021_7
Original Code:
```
fn funding_created_test() {
        let msg_hex = "002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = FundingCreated {
            temporary_channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
            funding_txid: FundingTxid::from_hex("0000000000000000000000000000000000000000000000000000000005000000").unwrap(),
            output_index: OutputIndex::from_u16(2),
            signature: RawSignature::from_hex("3024021f05000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
        };
        let wrapped_msg_correct = Message::FundingCreated(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);


        // Now check serialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);

    }
```


Overlapping Code:
```
g_hex = "002202000000000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000200050000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
let msg_bytes = hex::decode(msg_hex).unwrap();
let msg_correct = FundingCreated {
temporary_channel_id: ChannelId::from_hex("0200000000000000000000000000000000000000000000000000000000000000").unwrap(),
funding_txid: FundingTxid::from_hex("0000000000000000000000000000000000000000000000000000000005000000").unwrap(),
output_index: OutputIndex::from_u16(2),
signature: RawSignature::from_hex("3024021f05000000000000000000000000000000000000000000000000000000000000020100").unwrap(),
};
let wrapped_msg_correct = Message::FundingCreated(msg_correct);
let mut cursor = Cursor::new(msg_bytes.clone());
let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
assert_eq!(&msg, &wrapped_msg_correct);
// Now checkserialization
let mut new_msg_bytes = vec![];
BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
assert_eq!(new_msg_bytes, msg_bytes);
}
```
<Overlap Ratio: 0.9704641350210971>

---

--- 112 --
Question ID: cfbe46cb9076cdae947716442ead1ecc815a6423_2
Original Code:
```
fn b42_ammonia_clean(b: &mut Bencher) {
    let mut frag = String::new();
    sample_file("github-dekellum-frag.html")
        .expect("sample_file")
        .read_to_string(&mut frag)
        .expect("read_to_string");
    let frag = frag.trim();
    let amm = ammonia::Builder::default();
    b.iter(|| {
        let doc = amm.clean(&frag);
        let out = doc.to_string();
        assert_eq!(out.len(), 52062, /*"[[[{}]]]", out*/);
    });
}
```


Overlapping Code:
```
: &mut Bencher) {
let mut frag = String::new();
sample_file("github-dekellum-frag.html")
.expect("sample_file")
.read_to_string(&mut frag)
.expect("read_to_string");
let frag = frag.trim();
let amm = ammonia::Builder::default();
b.iter(|| {
let doc = amm.clean(&frag);
let out = doc.to_string();
assert_eq!(out.len(), 52062, /*"[[[{}]]]", out*/);
});

```
<Overlap Ratio: 0.9385026737967914>

---

--- 113 --
Question ID: 54505e5beaa6a4e62e0c01348f1e97462aeb6b2a_34
Original Code:
```
unsafe extern "C" fn opj_dwt_init_sparse_array(
  mut tilec: *mut opj_tcd_tilecomp_t,
  mut numres: OPJ_UINT32,
) -> *mut opj_sparse_array_int32_t {
  let mut tr_max: *mut opj_tcd_resolution_t = &mut *(*tilec)
    .resolutions
    .offset(numres.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
    as *mut opj_tcd_resolution_t;
  let mut w = ((*tr_max).x1 - (*tr_max).x0) as OPJ_UINT32;
  let mut h = ((*tr_max).y1 - (*tr_max).y0) as OPJ_UINT32;
  let mut resno: OPJ_UINT32 = 0;
  let mut bandno: OPJ_UINT32 = 0;
  let mut precno: OPJ_UINT32 = 0;
  let mut cblkno: OPJ_UINT32 = 0;
  let mut sa = opj_sparse_array_int32_create(
    w,
    h,
    opj_uint_min(w, 64 as libc::c_int as OPJ_UINT32),
    opj_uint_min(h, 64 as libc::c_int as OPJ_UINT32),
  );
  if sa.is_null() {
    return 0 as *mut opj_sparse_array_int32_t;
  }
  resno = 0 as libc::c_int as OPJ_UINT32;
  while resno < numres {
    let mut res: *mut opj_tcd_resolution_t =
      &mut *(*tilec).resolutions.offset(resno as isize) as *mut opj_tcd_resolution_t;
    bandno = 0 as libc::c_int as OPJ_UINT32;
    while bandno < (*res).numbands {
      let mut band: *mut opj_tcd_band_t =
        &mut *(*res).bands.as_mut_ptr().offset(bandno as isize) as *mut opj_tcd_band_t;
      precno = 0 as libc::c_int as OPJ_UINT32;
      while precno < (*res).pw.wrapping_mul((*res).ph) {
        let mut precinct: *mut opj_tcd_precinct_t =
          &mut *(*band).precincts.offset(precno as isize) as *mut opj_tcd_precinct_t;
        cblkno = 0 as libc::c_int as OPJ_UINT32;
        while cblkno < (*precinct).cw.wrapping_mul((*precinct).ch) {
          let mut cblk: *mut opj_tcd_cblk_dec_t =
            &mut *(*precinct).cblks.dec.offset(cblkno as isize) as *mut opj_tcd_cblk_dec_t;
          if !(*cblk).decoded_data.is_null() {
            let mut x = ((*cblk).x0 - (*band).x0) as OPJ_UINT32;
            let mut y = ((*cblk).y0 - (*band).y0) as OPJ_UINT32;
            let mut cblk_w = ((*cblk).x1 - (*cblk).x0) as OPJ_UINT32;
            let mut cblk_h = ((*cblk).y1 - (*cblk).y0) as OPJ_UINT32;
            if (*band).bandno & 1 as libc::c_int as libc::c_uint != 0 {
              let mut pres: *mut opj_tcd_resolution_t = &mut *(*tilec)
                .resolutions
                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
                as *mut opj_tcd_resolution_t;
              x = (x as libc::c_uint).wrapping_add(((*pres).x1 - (*pres).x0) as OPJ_UINT32)
                as OPJ_UINT32 as OPJ_UINT32
            }
            if (*band).bandno & 2 as libc::c_int as libc::c_uint != 0 {
              let mut pres_0: *mut opj_tcd_resolution_t = &mut *(*tilec)
                .resolutions
                .offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
                as *mut opj_tcd_resolution_t;
              y = (y as libc::c_uint).wrapping_add(((*pres_0).y1 - (*pres_0).y0) as OPJ_UINT32)
                as OPJ_UINT32 as OPJ_UINT32
            }
            if opj_sparse_array_int32_write(
              sa,
              x,
              y,
              x.wrapping_add(cblk_w),
              y.wrapping_add(cblk_h),
              (*cblk).decoded_data,
              1 as libc::c_int as OPJ_UINT32,
              cblk_w,
              1 as libc::c_int,
            ) == 0
            {
              opj_sparse_array_int32_free(sa);
              return 0 as *mut opj_sparse_array_int32_t;
            }
          }
          cblkno = cblkno.wrapping_add(1)
        }
        precno = precno.wrapping_add(1)
      }
      bandno = bandno.wrapping_add(1)
    }
    resno = resno.wrapping_add(1)
  }
  return sa;
}
```


Overlapping Code:
```
(
mut tilec: *mut opj_tcd_tilecomp_t,
mut numres: OPJ_UINT32,
) -> *mut opj_sparse_array_int32_t {
let mut tr_max: *mut opj_tcd_resolution_t = &mut *(*tilec)
.resolutions
.offset(numres.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
as *mut opj_tcd_resolution_t;
let mut w = ((*tr_max).x1 - (*tr_max).x0) as OPJ_UINT32;
let mut h = ((*tr_max).y1 - (*tr_max).y0) as OPJ_UINT32;
let mut resno: OPJ_UINT32 = 0;
let mut bandno: OPJ_UINT32 = 0;
let mut precno: OPJ_UINT32 = 0;
let mut cblkno: OPJ_UINT32 = 0;
let mut sa = opj_sparse_array_int32_create(
w,
h,
opj_uint_min(w, 64 as libc::c_int as OPJ_UINT32),
opj_uint_min(h, 64 as libc::c_int as OPJ_UINT32),
);
if sa.is_null() {
return 0 as *mut opj_sparse_array_int32_t;
}
resno = 0 as libc::c_int as OPJ_UINT32;
while resno < numres {
let mut res: *mut opj_tcd_resolution_t =
&mut *(*tilec).resolutions.offset(resno as isize) as *mut opj_tcd_resolution_t;
bandno = 0 as libc::c_int as OPJ_UINT32;
while bandno < (*res).numbands {
let mut band: *mut opj_tcd_band_t =
&mut *(*res).bands.as_mut_ptr().offset(bandno as isize) as *mut opj_tcd_band_t;
precno = 0 as libc::c_int as OPJ_UINT32;
while precno < (*res).pw.wrapping_mul((*res).ph) {
let mut precinct: *mut opj_tcd_precinct_t =
&mut *(*band).precincts.offset(precno as isize) as *mut opj_tcd_precinct_t;
cblkno = 0 as libc::c_int as OPJ_UINT32;
while cblkno < (*precinct).cw.wrapping_mul((*precinct).ch) {
let mut cblk: *mut opj_tcd_cblk_dec_t =
&mut *(*precinct).cblks.dec.offset(cblkno as isize) as *mut opj_tcd_cblk_dec_t;
if !(*cblk).decoded_data.is_null() {
let mut x = ((*cblk).x0 - (*band).x0) as OPJ_UINT32;
let mut y = ((*cblk).y0 - (*band).y0) as OPJ_UINT32;
let mut cblk_w = ((*cblk).x1 - (*cblk).x0) as OPJ_UINT32;
let mut cblk_h = ((*cblk).y1 - (*cblk).y0) as OPJ_UINT32;
if (*band).bandno & 1 as libc::c_int as libc::c_uint != 0 {
let mut pres: *mut opj_tcd_resolution_t = &mut *(*tilec)
.resolutions
.offset(resno.wrapping_sub(1 as libc::c_int as libc::c_uint) as isize)
as *mut opj_tcd_resolution_t;
x = (x as libc::c_uint).wrapping_add(((*pres).x1 - (*pres).x0) as OPJ_UI
```
<Overlap Ratio: 0.9655172413793104>

---

--- 114 --
Question ID: dbd6eabc87f2d2be8b8b8bc7d2a69e80cc7ba8ad_4
Original Code:
```
pub fn unpack_sect4_body<R: Read>(f: &mut R, body_size: usize) -> Result<SectionBody, ParseError> {
    let mut buf = [0; 4]; // octet 6-9
    f.read_exact(&mut buf[..])?;

    let len_extra = body_size - buf.len();
    let mut templated = vec![0; len_extra];
    f.read_exact(&mut templated[..])?;

    let prod_tmpl_num = read_as!(u16, buf, 2);

    Ok(SectionBody::Section4(ProdDefinition {
        num_coordinates: read_as!(u16, buf, 0),
        prod_tmpl_num,
        templated: templated.into_boxed_slice(),
        template_supported: SUPPORTED_PROD_DEF_TEMPLATE_NUMBERS.contains(&prod_tmpl_num),
    }))
}
```


Overlapping Code:
```
y<R: Read>(f: &mut R, body_size: usize) -> Result<SectionBody, ParseError> {
let mut buf = [0; 4]; // octet 6-9
f.read_exact(&mut buf[..])?;
let len_extra = body_size - buf.len();
let mut templated = vec![0; len_extra];
f.read_exact(&mut templated[..])?;
let prod_tmpl_num = read_as!(u16, buf, 2);
Ok(SectionBody::Section4(ProdDefinition {
num_coordinates: read_as!(u16, buf, 0),
prod_tmpl_num,
templated: templated.into_boxed_slice(),
template_supported: SUPPORTED_PROD_DEF_TEMPLATE_NUMBERS.contains(&prod
```
<Overlap Ratio: 0.9267399267399268>

---

--- 115 --
Question ID: 3e2f6607d27280bcb38a973c0c7be105d5707329_0
Original Code:
```
fn get_local_contract(path: &Path) -> Result<String> {
    let path = if path.is_relative() {
        let absolute_path = path.canonicalize().with_context(|| {
            format!(
                "unable to canonicalize file from working dir {} with path {}",
                env::current_dir()
                    .map(|cwd| cwd.display().to_string())
                    .unwrap_or_else(|err| format!("??? ({})", err)),
                path.display(),
            )
        })?;
        Cow::Owned(absolute_path)
    } else {
        Cow::Borrowed(path)
    };

    let json = fs::read_to_string(&path).context(format!(
        "failed to read artifact JSON file with path {}",
        &path.display()
    ))?;
    Ok(json)
}
```


Overlapping Code:
```
l_contract(path: &Path) -> Result<String> {
let path = if path.is_relative() {
let absolute_path = path.canonicalize().with_context(|| {
format!(
"unable to canonicalize file from working dir {} with path {}",
env::current_dir()
.map(|cwd| cwd.display().to_string())
.unwrap_or_else(|err| format!("??? ({})", err)),
path.display(),
)
})?;
Cow::Owned(absolute_path)
} else {
Cow::Borrowed(path)
};
let json = fs::read_to_string(&path).context(format!(
"failed to read artifact JSON file with path {}",
&path.display()

```
<Overlap Ratio: 0.9521178637200737>

---

--- 116 --
Question ID: 4502905b1b7a3f7cbe3f42818ecf4e134856bbe4_0
Original Code:
```
fn bench_circuit1(b: &mut Bencher){
    let qiskit = QiskitPython::new().unwrap();
    let circuit = qiskit.get_qasm_circuit("example", "example/example.qasm").unwrap();
    let backend_circuit = qiskit.get_backend_circuit(circuit).unwrap();
    let mut us = UnitarySimulator::new(backend_circuit.to_string()).unwrap();
    b.iter(|| us.run());
}
```


Overlapping Code:
```
 qiskit = QiskitPython::new().unwrap();
let circuit = qiskit.get_qasm_circuit("example", "example/example.qasm").unwrap();
let backend_circuit = qiskit.get_backend_circuit(circuit).unwrap();
let mut us = UnitarySimulator::new(backend_circuit.to_string()).
```
<Overlap Ratio: 0.7822085889570553>

---

--- 117 --
Question ID: ce843a93a2fa4531761d1f94925bb14a23d9f72a_2
Original Code:
```
pub fn open_database(config: &DatabaseSettings, col_meta: Option<u32>, db_type: &str) -> client::error::Result<Arc<KeyValueDB>> {
	let mut db_config = DatabaseConfig::with_columns(Some(NUM_COLUMNS));
	db_config.memory_budget = config.cache_size;
	let path = config.path.to_str().ok_or_else(|| client::error::ErrorKind::Backend("Invalid database path".into()))?;
	let db = Database::open(&db_config, &path).map_err(db_err)?;

	// check database type
	match db.get(col_meta, meta_keys::TYPE).map_err(db_err)? {
		Some(stored_type) => {
			if db_type.as_bytes() != &*stored_type {
				return Err(client::error::ErrorKind::Backend(
					format!("Unexpected database type. Expected: {}", db_type)).into());
			}
		},
		None => {
			let mut transaction = DBTransaction::new();
			transaction.put(col_meta, meta_keys::TYPE, db_type.as_bytes());
			db.write(transaction).map_err(db_err)?;
		},
	}

	Ok(Arc::new(db))
}
```


Overlapping Code:
```
n_database(config: &DatabaseSettings, col_meta: Option<u32>, db_type: &str) -> client::error::Result<Arc<KeyValueDB>> {
let mut db_config = DatabaseConfig::with_columns(Some(NUM_COLUMNS));
db_config.memory_budget = config.cache_size;
let path = config.path.to_str().ok_or_else(|| client::error::ErrorKind::Backend("Invalid database path".into()))?;
let db = Database::open(&db_config, &path).map_err(db_err)?;
// check database type
match db.get(col_meta, meta_keys::TYPE).map_err(db_err)? {
Some(stored_type) => {
if db_type.as_bytes() != &*stored_type {
return Err(client::error::ErrorKind::Backend(
format!("Unexpected database type. Expected: {}", db_type)).into());
}
},
None => {
let mut transaction = DBTransaction::new();
transaction.put(col_meta, meta_keys::TYPE, db_type.as_bytes());
db.write(transaction).map_err(db_err)?;
},
}
Ok(Arc::new
```
<Overlap Ratio: 0.9803921568627451>

---

--- 118 --
Question ID: bc286fbae6a23f99a4466d8d65f2c7f38acc5939_9
Original Code:
```
async fn test_munmap_not_mapped() {
        let (_kernel, current_task) = create_kernel_and_task();

        let mapped_address = map_memory(&current_task, UserAddress::default(), *PAGE_SIZE);
        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));
        assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));
    }
```


Overlapping Code:
```
() {
let (_kernel, current_task) = create_kernel_and_task();
let mapped_address = map_memory(&current_task, UserAddress::default(), *PAGE_SIZE);
assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS));
assert_eq!(sys_munmap(&current_task, mapped_address, *PAGE_SIZE as usize), Ok(SUCCESS
```
<Overlap Ratio: 0.8985915492957747>

---

--- 119 --
Question ID: 2e3d354c774b7741c3776cd8d01c88f2eb41bb6b_8
Original Code:
```
fn update_consensus_evidence_params() {
        let mut deps = mock_deps_tgrade();
        let env = mock_env();
        proposals()
            .save(
                &mut deps.storage,
                1,
                &Proposal {
                    title: "UnpinCodes".to_owned(),
                    description: "UnpinCodes testing proposal".to_owned(),
                    created_by: "mock_person".to_owned(),
                    start_height: env.block.height,
                    expires: Expiration::at_timestamp(env.block.time.plus_seconds(66666)),
                    proposal: ValidatorProposal::UpdateConsensusEvidenceParams {
                        max_age_num_blocks: Some(10),
                        max_age_duration: Some(100),
                        max_bytes: Some(256),
                    },
                    status: Status::Passed,
                    rules: VotingRules {
                        voting_period: 1,
                        quorum: Decimal::percent(50),
                        threshold: Decimal::percent(40),
                        allow_end_early: true,
                    },
                    total_points: 20,
                    votes: Votes {
                        yes: 20,
                        no: 0,
                        abstain: 0,
                        veto: 0,
                    },
                },
            )
            .unwrap();

        let res = execute_execute(deps.as_mut(), env, mock_info("sender", &[]), 1).unwrap();
        assert_eq!(
            res.messages,
            vec![SubMsg::new(CosmosMsg::Custom(TgradeMsg::ConsensusParams(
                ConsensusParams {
                    block: None,
                    evidence: Some(EvidenceParams {
                        max_age_num_blocks: Some(10),
                        max_age_duration: Some(100),
                        max_bytes: Some(256),
                    }),
                }
            )))]
        );
    }
```


Overlapping Code:
```
let mut deps = mock_deps_tgrade();
let env = mock_env();
proposals()
.save(
&mut deps.storage,
1,
&Proposal {
title: "UnpinCodes".to_owned(),
description: "UnpinCodes testing proposal".to_owned(),
created_by: "mock_person".to_owned(),
start_height: env.block.height,
expires: Expiration::at_timestamp(env.block.time.plus_seconds(66666)),
proposal: ValidatorProposal::UpdateConsensusEvidenceParams {
max_age_num_blocks: Some(10),
max_age_duration: Some(100),
max_bytes: Some(256),
},
status: Status::Passed,
rules: VotingRules {
voting_period: 1,
quorum: Decimal::percent(50),
threshold: Decimal::percent(40),
allow_end_early: true,
},
total_points: 20,
votes: Votes {
yes: 20,
no: 0,
abstain: 0,
veto: 0,
},
},
)
.unwrap();
let res = execute_execute(deps.as_mut(), env, mock_info("sender", &[]), 1).unwrap();
assert_eq!(
res.messages,
vec![SubMsg::new(CosmosMsg::Custom(TgradeMsg::ConsensusParams(
ConsensusParams {
block: None,
evidence: Some(EvidenceParams {
max_age_num_blocks: Some(10),
max_age_duration: Some(100),
max_bytes: Some(256),
}),
}
))
```
<Overlap Ratio: 0.9571558796718322>

---

--- 120 --
Question ID: 30e511542e4aac60c54c4fe6514719129fa9ee2c_5
Original Code:
```
fn test_utsname() {
    init();

    let mut st = get_st("utsname");
    let mut iterator = st.iter_as_syscall().skip_while(compare).skip(1);

    let call = unwrap_syscall!(iterator, Uname);
    let uts_name = nix::sys::utsname::uname();
    assert_eq!(&call.utsname.sysname, uts_name.sysname());
    assert_eq!(&call.utsname.nodename, uts_name.nodename());
    assert_eq!(&call.utsname.release, uts_name.release());
    assert_eq!(&call.utsname.version, uts_name.version());
    assert_eq!(&call.utsname.machine, uts_name.machine());
}
```


Overlapping Code:
```
st = get_st("utsname");
let mut iterator = st.iter_as_syscall().skip_while(compare).skip(1);
let call = unwrap_syscall!(iterator, Uname);
let uts_name = nix::sys::utsname::uname();
assert_eq!(&call.utsname.sysname, uts_name.sysname());
assert_eq!(&call.utsname.nodename, uts_name.nodename());
assert_eq!(&call.utsname.release, uts_name.release());
assert_eq!(&call.utsname.version, uts_name.version());
assert_eq!(&call.utsname.machine, uts_name.mach
```
<Overlap Ratio: 0.9090909090909091>

---

--- 121 --
Question ID: 4240c517c9a992c92f452da8f5ff4a533bb41164_3
Original Code:
```
pub fn serialize_operation_crate_operation_get_group_configuration(
    input: &crate::input::GetGroupConfigurationInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);
    crate::json_ser::serialize_structure_crate_input_get_group_configuration_input(
        &mut object,
        input,
    )?;
    object.finish();
    Ok(aws_smithy_http::body::SdkBody::from(out))
}
```


Overlapping Code:
```
ize_operation_crate_operation_get_group_configuration(
input: &crate::input::GetGroupConfigurationInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
let mut out = String::new();
let mut object = aws_smithy_json::serialize::JsonObjectWriter::new(&mut out);
crate::json_ser::serialize_structure_crate_input_get_group_configuration_input(
&mut object,
input,
)?;
object.finish();
Ok(aws_smithy_http::body::SdkBody::from(out))
}
```
<Overlap Ratio: 0.973305954825462>

---

--- 122 --
Question ID: d63a3a3c21dfd4cedc1a7a2cab8c57ac018fb7b3_0
Original Code:
```
async fn single_singleton() {
    use crate::{DependencyContext, DependencyLifeCycle};
    use std::sync::Arc;
    use tokio::sync::RwLock;

    let root_context = DependencyContext::new_root();
    root_context.register_type::<RwLock<SingletonDependency>>(DependencyLifeCycle::Singleton).await.unwrap();

    let dependency = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();

    assert_eq!(dependency.read().await.str, "test".to_string());

    dependency.write().await.str = "test2".to_string(); // изменяем состояние singletone зависимости

    let dependency2 = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();

    assert_eq!(dependency2.read().await.str, "test2".to_string()); // видим измененное состояние в новом объекте
}
```


Overlapping Code:
```
() {
use crate::{DependencyContext, DependencyLifeCycle};
use std::sync::Arc;
use tokio::sync::RwLock;
let root_context = DependencyContext::new_root();
root_context.register_type::<RwLock<SingletonDependency>>(DependencyLifeCycle::Singleton).await.unwrap();
let dependency = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();
assert_eq!(dependency.read().await.str, "test".to_string());
dependency.write().await.str = "test2".to_string(); // изменяем состояние singletone зависимости
let dependency2 = root_context.resolve::<Arc<RwLock<SingletonDependency>>>().await.unwrap();
assert_eq!(dependency2.read().await.str, "test2".to_string()); // видим измененное состояние в новом объекте
}
```
<Overlap Ratio: 0.966078697421981>

---

--- 123 --
Question ID: f431383ef3c859d44cba61f9d2a0540d7ffd18f4_48
Original Code:
```
pub fn serialize_structure_crate_model_license_specification(
    object: &mut aws_smithy_json::serialize::JsonObjectWriter,
    input: &crate::model::LicenseSpecification,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    if let Some(var_333) = &input.license_configuration_arn {
        object.key("LicenseConfigurationArn").string(var_333);
    }
    if let Some(var_334) = &input.ami_association_scope {
        object.key("AmiAssociationScope").string(var_334);
    }
    Ok(())
}
```


Overlapping Code:
```
lize_structure_crate_model_license_specification(
object: &mut aws_smithy_json::serialize::JsonObjectWriter,
input: &crate::model::LicenseSpecification,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
if let Some(var_333) = &input.license_configuration_arn {
object.key("LicenseConfigurationArn").string(var_333);
}
if let Some(var_334) = &input.ami_association_scope {
object.key("AmiA
```
<Overlap Ratio: 0.8763557483731019>

---

--- 124 --
Question ID: 29a7f2b67b9000316d825f8935d2f7aa510c0392_4
Original Code:
```
async fn get_proxies_gets_proxies_with_toxics() {
        let _lock = MOCK_LOCK.lock().await;
        let (stop, _stopper) = Stop::new();
        let store = Store::new(stop, None);
        let init_ctx = MockNoopRunner::initialize_proxy_context();
        let run_ctx = MockNoopRunner::run_proxy_context();
        init_ctx.expect().returning(|config, _initial_toxics| {
            let listener = MockNoopListener::default();
            let proxy_info = SharedProxyInfo {
                state: Arc::new(ProxyState::new(Toxics {
                    upstream: vec![Toxic {
                        kind: ToxicKind::Latency {
                            latency: 500,
                            jitter: 42,
                        },
                        name: format!("{}tox1", config.name),
                        toxicity: 0.67,
                        direction: StreamDirection::Upstream,
                    }],
                    downstream: Vec::new(),
                })),
                config: Arc::new(config),
            };
            Ok((listener, proxy_info))
        });

        run_ctx.expect().returning(
            move |_listener: MockNoopListener, _info, _event_receiver, _stop, _closer| Ok(()),
        );

        populate_store(&store).await;

        let result = store.get_proxies().await.unwrap();
        assert_eq!(3, result.len());
        let p1 = result.iter().find(|el| el.proxy.name == "foo").unwrap();
        let p2 = result.iter().find(|el| el.proxy.name == "bar").unwrap();
        let p3 = result.iter().find(|el| el.proxy.name == "baz").unwrap();
        assert_eq!(1, p1.toxics.len());
        assert_eq!("footox1", p1.toxics[0].get_name());
        assert_eq!("bartox1", p2.toxics[0].get_name());
        assert_eq!("baztox1", p3.toxics[0].get_name());
    }
```


Overlapping Code:
```
xies_with_toxics() {
let _lock = MOCK_LOCK.lock().await;
let (stop, _stopper) = Stop::new();
let store = Store::new(stop, None);
let init_ctx = MockNoopRunner::initialize_proxy_context();
let run_ctx = MockNoopRunner::run_proxy_context();
init_ctx.expect().returning(|config, _initial_toxics| {
let listener = MockNoopListener::default();
let proxy_info = SharedProxyInfo {
state: Arc::new(ProxyState::new(Toxics {
upstream: vec![Toxic {
kind: ToxicKind::Latency {
latency: 500,
jitter: 42,
},
name: format!("{}tox1", config.name),
toxicity: 0.67,
direction: StreamDirection::Upstream,
}],
downstream: Vec::new(),
})),
config: Arc::new(config),
};
Ok((listener, proxy_info))
});
run_ctx.expect().returning(
move |_listener: MockNoopListener, _info, _event_receiver, _stop, _closer| Ok(()),
);
populate_store(&store).await;
let result = store.get_proxies().await.unwrap();
assert_eq!(3, result.len());
let p1 = result.iter().find(|el| el.proxy.name == "foo").unwrap();
let p2 = result.iter().find(|el| el.proxy.name == "bar").unwrap();
let p3 = result.iter().find(|el| el.proxy.name == "baz").unwrap();
assert_eq!(1, p1.toxics.len());
assert_eq!("footox1", p1.toxics[0].get_name());
assert_eq!("bartox1", p2.toxics[0].get_name());
assert_eq!("baztox1"
```
<Overlap Ratio: 0.9556574923547401>

---

--- 125 --
Question ID: fbfe62e6f8359fdafe557525d184a4fd33db6145_1
Original Code:
```
fn list_should_disable_register() {
        let a = app(&[]);
        assert!(!a.output.list);
        assert!(a.register);

        let a = app(&["--list"]);
        assert!(a.output.list);
        assert!(!a.register);

        let a = app(&["--list", "--register"]);
        assert!(a.output.list);
        assert!(a.register);
    }
```


Overlapping Code:
```
list_should_disable_register() {
let a = app(&[]);
assert!(!a.output.list);
assert!(a.register);
let a = app(&["--list"]);
assert!(a.output.list);
assert!(!a.register);
let a = app(&["--list", "--register"]);
assert!(a.output.list);
assert!(a.registe
```
<Overlap Ratio: 0.9689922480620154>

---

--- 126 --
Question ID: b427f5acc2095b74427d52bdb7f6e9c423048f00_0
Original Code:
```
pub fn derive_elm_json(input: TokenStream) -> TokenStream {
    let derive_input = parse_macro_input!(input as DeriveInput);
    let intermediate = match super::derive_input_to_intermediate(derive_input) {
        Ok(intermediate) => intermediate,
        Err(err) => return err.to_compile_error().into(),
    };
    let token_stream = match intermediate_to_token_stream(intermediate) {
        Ok(token_stream) => token_stream,
        Err(err) => return err.to_compile_error().into(),
    };
    TokenStream::from(token_stream)
}
```


Overlapping Code:
```
n(input: TokenStream) -> TokenStream {
let derive_input = parse_macro_input!(input as DeriveInput);
let intermediate = match super::derive_input_to_intermediate(derive_input) {
Ok(intermediate) => intermediate,
Err(err) => return err.to_compile_error().into(),
};
let token_stream = match intermediate_to_token_stream(intermediate) {
Ok(token_stream) => token_stream,
Err(err) => return err.to_compile_error().into(),
};
TokenStr
```
<Overlap Ratio: 0.9031578947368422>

---

--- 127 --
Question ID: fda6fb51772f6ea99e2e49db4275566c2d580a25_23
Original Code:
```
fn test_calculate_amounts_from_balances_virtual_balancing_transaction() {
        let mut transactions = parse_transactions(
            r#"
2018-10-01 Marek Ogarek
  TEST:ABC     $1.20
  TEST:DEF

2018-10-01 Marek Ogarek
  [TEST:ABC]         = $1.20
"#,
        );
        let expected_transactions = parse_transactions(
            r#"
2018-10-01 Marek Ogarek
  TEST:ABC     $1.20
  TEST:DEF    $-1.20

2018-10-01 Marek Ogarek
  [TEST:ABC]   $0.00
"#,
        );
        assert_eq!(
            calculate_amounts_from_balances(&mut transactions, &mut Vec::new()),
            Ok(())
        );
        assert_eq!(transactions, expected_transactions);
    }
```


Overlapping Code:
```
ounts_from_balances_virtual_balancing_transaction() {
let mut transactions = parse_transactions(
r#"
2018-10-01 
"#,
);
let expected_transactions = parse_transactions(
r#"
2018-10-01 
assert_eq!(
calculate_amounts_from_balances(&mut transactions, &mut Vec::new()),
Ok(())
);
assert_eq!(transactions, expected_transactions)
```
<Overlap Ratio: 0.625242718446602>

---

--- 128 --
Question ID: 03310e63246987c9fa32df9e5103e22c2c55f425_0
Original Code:
```
pub fn fetch(args: InputArgs, filter_list: Vec<Regex>) {
    let matches = args.get_matches();
    let filter_hidden = matches.is_present("traverse-hidden");

    let dir_tree_with_options = DirectoryTreeOptions {
        filter_list: filter_list,
        filter_hidden: filter_hidden,
    };

    let root_path = args.get_root_path("PATH");
    let root = root_path
        .to_str()
        .expect(format!("{}", "Error in converting directory to string".red()).as_str());

    let multi_bars = ProgressTracker::new(matches.value_of("jobs").and_then(|e| e.parse().ok()));
    dir_tree_with_options
        .process_directories(root)
        .flat_map(|dir| {
            dir.ok().and_then(|d| {
                if d.file_name().eq(".git") {
                    d.path().parent().map(|e| e.to_path_buf())
                } else {
                    None
                }
            })
        })
        .map(|dir| GitFetch {
            dir,
            remote: "origin".to_string(),
        })
        .for_each(|clone| multi_bars.start_task(clone));

    multi_bars.join().unwrap();
}
```


Overlapping Code:
```
ub fn fetch(args: InputArgs, filter_list: Vec<Regex>) {
let matches = args.get_matches();
let filter_hidden = matches.is_present("traverse-hidden");
let dir_tree_with_options = DirectoryTreeOptions {
filter_list: filter_list,
filter_hidden: filter_hidden,
};
let root_path = args.get_root_path("PATH");
let root = root_path
.to_str()
.expect(format!("{}", "Error in converting directory to string".red()).as_str());
let multi_bars = ProgressTracker::new(matches.value_of("jobs").and_then(|e| e.parse().ok()));
dir_tree_with_options
.process_directories(root)
.flat_map(|dir| {
dir.ok().and_then(|d| {
if d.file_name().eq(".git") {
d.path().parent().map(|e| e.to_path_buf())
} else {
None
}
})
})
.map(|dir| GitFetch {
dir,
remote: "origin".to_string(),
})
.for_each(|clone| multi_bars.start_task(clone));
```
<Overlap Ratio: 0.962874251497006>

---

--- 129 --
Question ID: 8ee46090be0a408028a1b29311cd8a419a713217_9
Original Code:
```
fn fake_pors_subset() -> [usize; PORS_K] {
        let seed = hash::tests::HASH_ELEMENT;
        let prng = prng::Prng::new(&seed);
        let address = address::Address::new(0, 0);

        let mut subset: [usize; PORS_K] = [0; PORS_K];
        let mut count = 0;
        let mut counter = 1;
        let mut block = Default::default();

        'outer: while count < PORS_K {
            prng.genblock(&mut block, &address, counter);
            'inner: for i in 0..8 {
                let x = BigEndian::read_u32(array_ref![block.h, 4 * i, 4]) as usize;
                let x = x % PORS_T;

                for i in 0..count {
                    if subset[i] == x {
                        continue 'inner;
                    }
                }

                subset[count] = x;
                count += 1;
                if count == PORS_K {
                    break 'outer;
                }
            }
            counter += 1;
        }

        subset.sort();
        subset
    }
```


Overlapping Code:
```
ubset() -> [usize; PORS_K] {
let seed = hash::tests::HASH_ELEMENT;
let prng = prng::Prng::new(&seed);
let address = address::Address::new(0, 0);
let mut subset: [usize; PORS_K] = [0; PORS_K];
let mut count = 0;
let mut counter = 1;
let mut block = Default::default();
'outer: while count < PORS_K {
prng.genblock(&mut block, &address, counter);
'inner: for i in 0..8 {
let x = BigEndian::read_u32(array_ref![block.h, 4 * i, 4]) as usize;
let x = x % PORS_T;
for i in 0..count {
if subset[i] == x {
continue 'inner;
}
}
subset[count] = x;
count += 1;
if count == PORS_K {
break 'outer;
}
}
counter += 1;
}
subset.
```
<Overlap Ratio: 0.9532710280373832>

---

--- 130 --
Question ID: 04c8c1f635c10d014cfbe889550fb77665f38a00_1
Original Code:
```
fn delete_run(m: &ArgMatches<'_>) -> Result<(), Error> {
    // The unwrap is ok, because NAME is a required argument.
    let name = m.value_of("NAME").unwrap();
    let mut repo = crate::open_repo()?;
    repo.delete_branch(name)?;
    repo.write()?;
    eprintln!("Deleted branch \"{}\"", name);
    Ok(())
}
```


Overlapping Code:
```
delete_run(m: &ArgMatches<'_>) -> Result<(), Error> {
// The unwrap is ok, because NAME is a required argument.
let name = m.value_of("NAME").unwrap();
let mut repo = crate::open_repo()?;
repo.delete_branch(name)?;
repo.write()?;
eprintln!("Deleted b
```
<Overlap Ratio: 0.8833922261484098>

---

--- 131 --
Question ID: 50fdc5ef6908110f35a85b94862f0e65496f4d9c_0
Original Code:
```
fn pop_last_span() {
        let mut stack = SpanStack::new();
        let id = Id::from_u64(1);
        stack.push(id.clone());

        assert_eq!(Some(id.clone()), stack.pop(&id));
    }
```


Overlapping Code:
```
et mut stack = SpanStack::new();
let id = Id::from_u64(1);
stack.push(id.clone());
assert_eq!(Some(i
```
<Overlap Ratio: 0.6578947368421053>

---

--- 132 --
Question ID: 2bf2666112a7aad2638c77fc88a6df78693e3161_7
Original Code:
```
fn test_stringifying_and_parsing_public_coefficients_should_produce_original(
    public_coefficients: PublicCoefficientsBytes,
) {
    let string = String::from(public_coefficients.clone());
    let parsed = PublicCoefficientsBytes::try_from(string.as_str());
    assert_eq!(
        Ok(public_coefficients),
        parsed,
        "String form does not parse to original: '{}'",
        string
    );
}
```


Overlapping Code:
```
st_stringifying_and_parsing_public_coefficients_should_produce_original(
public_coefficients: PublicCoefficientsBytes,
) {
let string = String::from(public_coefficients.clone());
let parsed = PublicCoefficientsBytes::try_from(string.as_str());
assert_eq!(
Ok(public_coefficients),
parsed,
"String form does not parse to original: '{}'",

```
<Overlap Ratio: 0.9546742209631728>

---

--- 133 --
Question ID: c037d3f6c1a8155a53172de89fcd272070a3b257_0
Original Code:
```
fn generate_mnt6_spec_params<FE: ElementRepr>(
    modulus: BigUint, 
    a: BigUint,
    b: BigUint,
    main_subgroup_order: BigUint,
    fp_non_residue: BigUint,
    generator_g1_x: BigUint,
    generator_g1_y: BigUint,
    generator_g2_x_0: BigUint,
    generator_g2_x_1: BigUint,
    generator_g2_x_2: BigUint,
    generator_g2_y_0: BigUint,
    generator_g2_y_1: BigUint,
    generator_g2_y_2: BigUint,
    ate_loop_scalar: BigUint,
    ate_loop_scalar_is_negative: bool,
    final_exp_scalar: BigUint,
    w0_exp_scalar: BigUint,
    w0_exp_scalar_is_negative: bool,
    w1_exp_scalar: BigUint,
) {
    let modulus_uint = MaxFieldUint::from_big_endian(&modulus.to_bytes_be());
    let field = field_from_modulus::<FE>(&modulus_uint).unwrap();
    let a_fp = Fp::from_be_bytes(&field, &a.to_bytes_be(), true).unwrap();
    let b_fp = Fp::from_be_bytes(&field, &b.to_bytes_be(), true).unwrap();
    let fp_non_residue = Fp::from_be_bytes(&field, &fp_non_residue.to_bytes_be(), true).unwrap();
    let extension_3 = Extension3::new(fp_non_residue.clone());

    let one = Fp::one(&field);

    let mut twist = Fp3::zero(&extension_3);
    twist.c1 = one.clone();

    let mut twist_squared = twist.clone();
    twist_squared.square();

    let mut twist_cubed = twist_squared.clone();
    twist_cubed.mul_assign(&twist);

    let mut a_fp3 = twist_squared.clone();
    a_fp3.mul_by_fp(&a_fp);

    let mut b_fp3 = twist_cubed.clone();
    b_fp3.mul_by_fp(&b_fp);


    let g1_generator_x = Fp::from_be_bytes(&field, &generator_g1_x.to_bytes_be(), true).unwrap();
    let g1_generator_y = Fp::from_be_bytes(&field, &generator_g1_y.to_bytes_be(), true).unwrap();

    let g1_generator_x_c0 = Fp::from_be_bytes(&field, &generator_g2_x_0.to_bytes_be(), true).unwrap();
    let g1_generator_x_c1 = Fp::from_be_bytes(&field, &generator_g2_x_1.to_bytes_be(), true).unwrap();
    let g1_generator_x_c2 = Fp::from_be_bytes(&field, &generator_g2_x_2.to_bytes_be(), true).unwrap();
    let g1_generator_y_c0 = Fp::from_be_bytes(&field, &generator_g2_y_0.to_bytes_be(), true).unwrap();
    let g1_generator_y_c1 = Fp::from_be_bytes(&field, &generator_g2_y_1.to_bytes_be(), true).unwrap();
    let g1_generator_y_c2 = Fp::from_be_bytes(&field, &generator_g2_y_2.to_bytes_be(), true).unwrap();
    println!("Weierstrass curve parameters with k=6");
    println!("Base field modulus = {}", field.modulus());
    println!("A coefficient = {}", a_fp);
    println!("B coefficient = {}", b_fp);
    println!("Main subgroup order = 0x{}", main_subgroup_order.to_str_radix(16));

    println!("Extension tower:");
    println!("Fp3 construction:");
    println!("Fp cubic non-residue = {}", fp_non_residue);

    println!("A coefficient for twist c0 = {}", a_fp3.c0);
    println!("A coefficient for twist c1 = {}", a_fp3.c1);
    println!("A coefficient for twist c2 = {}", a_fp3.c2);

    println!("B coefficient for twist c0 = {}", b_fp3.c0);
    println!("B coefficient for twist c1 = {}", b_fp3.c1);
    println!("B coefficient for twist c2 = {}", b_fp3.c2);

    println!("Generators:");
    println!("G1:");
    println!("X = {}", g1_generator_x);
    println!("Y = {}", g1_generator_y);

    println!("G2:");
    println!("X c0 = {}", g1_generator_x_c0);
    println!("X c1 = {}", g1_generator_x_c1);
    println!("X c2 = {}", g1_generator_x_c2);
    println!("Y c0 = {}", g1_generator_y_c0);
    println!("Y c1 = {}", g1_generator_y_c1);
    println!("Y c2 = {}", g1_generator_y_c2);

    println!("Pairing parameters:");
    println!("|ate_loop_scalar| (miller loop scalar) = 0x{}", ate_loop_scalar.to_str_radix(16));
    println!("ate_loop_scalar is negative = {}", ate_loop_scalar_is_negative);

    println!("final_exp_scalar (final exponentiation power) = 0x{}", final_exp_scalar.to_str_radix(16));

    println!("Breaking final exponentiation hard part into the two parts (usually labeled w0 and w1)");

    println!("|w0| = 0x{}", w0_exp_scalar.to_str_radix(16));
    println!("w0 is negative = {}", w0_exp_scalar_is_negative);

    println!("|w1| = 0x{}", w1_exp_scalar.to_str_radix(16));
}
```


Overlapping Code:
```
t,
main_subgroup_order: BigUint,
fp_non_residue: BgUint,
generator_g1_x: BigUint,
generator_g1_y: BigUint,
generator_g2_x_0: BigUint,
generator_g2_x_1: BigUint,: BigUint,
generator_g2_y_0: BigUint,
generator_g2_y_1: BigUint,
) {
let modulus_uint = MaxFieldUint::from_big_endian(&modulus.to_bytes_be());
let field = field_from_modulus::<FE>(&modulus_uint).unwrap();
letp();
let b_fp = Fp::from_be_bytes(&field, &b.to_bytes_be(), true).unwrap();
let fp_non_residue = Fp::from_be_bytes(&field, &fp_non_residue.to_bytes_be(), true). extension_3 = Extension3::new(fp_non_residue.clontwist = Fp3::zero(&extension_3);
twist.c1 = one.clone();
let mut twist_squared = twist.clone();
twist_squared.square();
let mut twist_cubed = twist_squared.clone();
twist_cubed.mul_assign(&twist);
let mut a_fp3 = twist_squared.clone();
a_fp3.mul_by_fp(&a_fp);
let mut b_fp3 = twist_cubed.clone();
b_fp3.mul_by_fp(&b_fp);
let g_generator_x = Fp::from_be_bytes(&field, &generator_g1_x.to_bytes_be(), true).unwrap();
let g1_generator_y = Fp::from_be_bytes(&field, &generator_g1_y.to_bytes_be(), true).unwrap();
let g1_generator_x_c0 = Fp::from_be_bytes(&field, &generator_g2_x_0.to_bytes_be(), true).unwrap();
let g1_generator_x_c1 = Fp::from_be_bytes(&field, &generator_g2_x_1.to_bytes_be(), true).unwrap();
let g1_generator_x_cto_bytes_be(), true).unwrap();
let g1_generator_y_c0 = Fp::from_be_bytes(&field, &generator_g2_y_0.to_bytes_be(), true).unwrap();
let g1_generator_y_c1 = Fp::from_be_bytes(&field, &generator_g2_y_1.to_bytes_be(), true).unwrap();
let g1_generator_y_c
```
<Overlap Ratio: 0.6769834350479512>

---

--- 134 --
Question ID: 6fe4c5300e59e2d27e2db3e5eaf76d4b37a8332d_33
Original Code:
```
fn built_in_fn_to_string() {
    let ast = src_to_ast(vec![
        r#"দেখাও _স্ট্রিং(১) == "১";"#,
        r#"দেখাও _স্ট্রিং(১.০) == "১";"#,
        r#"দেখাও _স্ট্রিং(-১.০) == "-১";"#,
        r#"দেখাও _স্ট্রিং(১৩.৩২) == "১৩.৩২";"#,
        r#"দেখাও _স্ট্রিং(-৪৩.৪৩) == "-৪৩.৪৩";"#,
        r#"দেখাও _স্ট্রিং(-০.৪৩) == "-০.৪৩";"#,
    ]);
    let mut mock_io: MockIO = MockIO::new();
    mock_io.expect_println("সত্য");
    mock_io.expect_println("সত্য");
    mock_io.expect_println("সত্য");
    mock_io.expect_println("সত্য");
    mock_io.expect_println("সত্য");
    mock_io.expect_println("সত্য");
    if let Err(err) = run_assert_all_true(ast, mock_io) {
        panic!("{:?}", err);
    }
}
```


Overlapping Code:
```
_ast(vec![
r#"দেখাও _স্ট্রিং(১) == "১";"#,
r#"দেখাও _স্ট্রিং(১.০) == "১";"#,
r#"দেখাও _স্ট্রিং(-১.০) == "-১";"#,
r#"দেখাও _স্ট্রিং(১৩.৩২) == "১৩.৩২";"#,
r#"দেখাও _স্ট্রিং(-৪৩.৪৩) == "-৪৩.৪৩";"#,
r#"দেখাও _স্ট্রিং(-০.৪৩) == "-০.৪৩";"#,
]);
let mut mock_io: MockIO = MockIO::new();
mock_io.expect_println("সত্য");
mock_io.expect_println("সত্য");
mock_io.expect_println("সত্য");
mock_io.expect_println("সত্য");
mock_io.expect_println("সত্য");
mock_io.expect_println("সত্য");
if let Err(err) = run_assert_all_true(ast, mock_io) {
panic!("{:?}", err);
}
}
```
<Overlap Ratio: 0.9243697478991597>

---

--- 135 --
Question ID: f43e6b4f3934ec1c6e5c25d3d52f0d34c0a345df_3
Original Code:
```
fn parse_import_named_clause(p: &mut Parser) -> ParsedSyntax<CompletedMarker> {
	if !p.at(T!['{']) {
		return Absent;
	}

	let m = p.start();

	parse_default_import_specifier(p).or_missing(p);
	parse_named_import(p).or_missing_with_error(p, expected_named_import);
	expect_keyword(p, "from", T![from]);
	parse_module_source(p).or_missing_with_error(p, expected_module_source);
	parse_import_assertion(p).or_missing(p);

	Present(m.complete(p, JS_IMPORT_NAMED_CLAUSE))
}
```


Overlapping Code:
```
_import_named_clause(p: &mut Parser) -> ParsedSyntax<CompletedMarker> {
if !p.at(T!['{']) {
return Absent;
}
let m = p.start();
parse_default_import_specifier(p).or_missing(p);
parse_named_import(p).or_missing_with_error(p, expected_named_import);
expect_keyword(p, "from", T![from]);
parse_module_source(p).or_missing_with_error(p, expected_module_source);
parse_import_assertion(p).or_missing(p);
Present(m.complete(p, JS_IMPORT_
```
<Overlap Ratio: 0.9472527472527472>

---

--- 136 --
Question ID: e7730aba85b226b2b7c71c4cc2d0dad0be71c85e_1
Original Code:
```
fn main() {
    let matches = App::new("rlox")
        .version("0.1.0")
        .about("lox language interpreter")
        .author("Thomas Peters")
        .arg(
            Arg::with_name(INPUT_STR)
                .help("sets input file to use")
                .required(false)
                .index(1),
        )
        .arg(
            Arg::with_name(SHOW_TOKENS_STR)
                .long("--show-tokens")
                .takes_value(false)
                .help("show the token stream"),
        )
        .arg(
            Arg::with_name(SHOW_AST_STR)
                .long("--show-ast")
                .takes_value(false)
                .help("show the AST"),
        )
        .arg(
            Arg::with_name(DISASSEMBLE_STR)
                .long("--disassemble")
                .takes_value(false)
                .help("show the bytecode"),
        )
        .arg(
            Arg::with_name(DEBUG_STR)
                .long("--debug")
                .takes_value(false)
                .help("run in the debugger"),
        )
        .arg(
            Arg::with_name(TREEWALK_STR)
                .long("--treewalk")
                .takes_value(false)
                .help("run the tree-walk interpreter instead of the bytecode interpreter"),
        )
        .arg(
            Arg::with_name(LITERAL_INPUT)
                .long("-c")
                .takes_value(true)
                .help("provide a literal string of Lox code"),
        )
        .arg(
            Arg::with_name(EXTENSION_LISTS)
                .long(&format!["--{}", EXTENSION_LISTS])
                .takes_value(false)
                .help("use the lists extension"),
        )
        .arg(
            Arg::with_name(EXTENSION_LAMBDAS)
                .long(&format!["--{}", EXTENSION_LAMBDAS])
                .takes_value(false)
                .help("use the lambdas extension"),
        )
        .get_matches();

    let extensions = extensions::Extensions {
        lists: matches.is_present(EXTENSION_LISTS),
        lambdas: matches.is_present(EXTENSION_LAMBDAS),
    };

    if let Some(input) = get_input(&matches) {
        if matches.is_present(SHOW_TOKENS_STR)
            || matches.is_present(SHOW_AST_STR)
            || matches.is_present(TREEWALK_STR)
        {
            match scanner::scan_tokens(input.content.clone()) {
                Ok(tokens) => {
                    if matches.is_present(SHOW_TOKENS_STR) {
                        println!("{:#?}", tokens);
                        std::process::exit(0);
                    }

                    let stmts_maybe = parser::parse(extensions, tokens);

                    match stmts_maybe {
                        Ok(stmts) => {
                            if matches.is_present(SHOW_AST_STR) {
                                println!("{:#?}", stmts);
                                std::process::exit(0);
                            }

                            let mut interpreter: treewalk_interpreter::Interpreter =
                                Default::default();
                            let interpret_result = interpreter.interpret(&stmts);

                            match interpret_result {
                                Ok(_) => {
                                    std::process::exit(0);
                                }
                                Err(err) => {
                                    println!(
                                        "Runtime Error: {}\n\n{}",
                                        err,
                                        interpreter.format_backtrace()
                                    );
                                    std::process::exit(-1);
                                }
                            }
                        }
                        Err(err) => {
                            error_formatting::format_parse_error(&err, &input);
                            std::process::exit(-1)
                        }
                    }
                }
                Err(err) => {
                    error_formatting::format_lexical_error(&err, &input);
                    std::process::exit(-1);
                }
            }
        }

        let func_or_err = compiler::Compiler::compile(input.content.clone(), extensions);

        match func_or_err {
            Ok(func) => {
                if matches.is_present(DISASSEMBLE_STR) {
                    println!(
                        "{}",
                        bytecode_interpreter::disassemble_chunk(&func.chunk, "")
                    );
                    std::process::exit(0);
                }
                if matches.is_present(DEBUG_STR) {
                    debugger::Debugger::new(func, input.content).debug();
                    std::process::exit(0);
                }
                let mut interpreter = bytecode_interpreter::Interpreter::default();
                let res = interpreter.interpret(func);
                match res {
                    Ok(()) => {
                        std::process::exit(0);
                    }
                    Err(bytecode_interpreter::InterpreterError::Runtime(err)) => {
                        println!(
                            "Runtime error: {}\n\n{}",
                            err,
                            interpreter.format_backtrace()
                        );

                        std::process::exit(1);
                    }
                }
            }
            Err(err) => {
                error_formatting::format_compiler_error(&err, &input);
                std::process::exit(1);
            }
        }
    } else {
        repl::run(extensions);
    }
}
```


Overlapping Code:
```
w("rlox")
.version("0.1.0")
.about("lox language interpreter")
.author("e(INPUT_STR)
.help("sets input file to use")
.required(false)
.index(1),
)
.arg(
Arg::with_name(SHOW_TOKENS_STR)
.long("--show-tokens")
.takes_value(false)
.help("show the token stream"),
)
.arg(
Arg::with_name(SHOW_AST_STR)
.long("--show-ast")
.takes_value(false)
.help("show the AST"),
)
.arg(
Arg::with_name(DISASSEMBLE_STR)
.long("--disassemble")
.takes_value(false)
.help("show the bytecode"),
)
.arg(
Arg::with_name(DEBUG_STR)
.long("--debug")
.takes_value(false)
.help("run in the debugger"),
)
.arg(
Arg::with_name(TREEWALK_STR)
.long("--treewalk")
.takes_value(false)
.help("run the tree-walk interpreter instead of the bytecode interpreter"),
)
.arg(
Arg::with_name(LITERAL_INPUT)
.long("-c")
.takes_value(true)
.help("provide a literal string of Lox code"),
)
.arg(
Arg::with_name(EXTENSION_LISTS)
.long(&format!["--{}", EXTENSION_LISTS])
.takes_value(false)
.help("use the lists extension"),
)
.arg(
Arg::with_name(EXTENSION_LAMBDAS)
.long(&format!["--{}", EXTENSION_LAMBDAS])
.takes_value(false)
.help("use the lambdas extension"),
)
.get_matches();
let extensions = extensions::Extensions {
lists: matches.is_present(EXTENSION_LISTS),
lambdas: matches.is_present(EXTENSION_LAMBDAS),
};
if let Some(input) = get_input(&matches) {
if matches.is_present(SHOW_TOKENS_STR)
|| matches.is_present(SHOW_AST_STR)
|| matches.is_present(TREEWALK_STR)
{
match scanner::scan_tokens(input.content.clone()) {
Ok(tokens) => {
if matches.is_present(SHOW
```
<Overlap Ratio: 0.9331698344573881>

---

--- 137 --
Question ID: 10889000a775094684cae75666e5e1555ae97dbb_8
Original Code:
```
pub unsafe extern "C" fn connection_settings_get_username(
    this: *const ConnectionSettings,
) -> *const c_char {
    if this.is_null() {
        return ptr::null();
    }
    let settings: &ConnectionSettings = { &*this };

    match CString::new(settings.username.as_bytes()) {
        Err(_) => std::ptr::null(),
        Ok(str_bytes) => str_bytes.into_raw(),
    }
}
```


Overlapping Code:
```
" fn connection_settings_get_username(
this: *const ConnectionSettings,
) -> *const c_char {
if this.is_null() {
return ptr::null();
}
let settings: &ConnectionSettings = { &*this };
match CString::new(settings.username.as_bytes()) {
Err(_) => std::ptr::null(),
Ok(str_bytes) => str_bytes.into_raw(),
```
<Overlap Ratio: 0.9259259259259259>

---

--- 138 --
Question ID: 5687c712cbdb9e849da153118e5b5a914d7a5178_0
Original Code:
```
pub fn spl_token_transfer(params: TokenTransferParams<'_, '_>) -> Result<()> {
    let TokenTransferParams {
        source,
        destination,
        authority,
        token_program,
        amount,
        authority_signer_seeds,
    } = params;

    let val = &[authority_signer_seeds];

    let result = invoke_signed(
        &spl_token::instruction::transfer(
            token_program.key,
            source.key,
            destination.key,
            authority.key,
            &[],
            amount,
        )?,
        &[source, destination, authority, token_program],
        if authority_signer_seeds.len() == 0 {
            &[]
        } else {
            val
        },
    );

    result.map_err(|_| error!(ErrorCode::TokenTransferFailed))
}
```


Overlapping Code:
```
b fn spl_token_transfer(params: TokenTransferParams<'_, '_>) -> Result<()> {
let TokenTransferParams {
source,
destination,
authority,
token_program,
amount,
authority_signer_seeds,
} = params;
let val = &[authority_signer_seeds];
let result = invoke_signed(
&spl_token::instruction::transfer(
token_program.key,
source.key,
destination.key,
authority.key,
&[],
amount,
)?,
&[source, destination, authority, token_program],
if authority_signer_seeds.len() == 0 {
&[]
} else {
val
},
);
result.map_err(|_| error!(ErrorCode::TokenTransferFaile
```
<Overlap Ratio: 0.9872262773722628>

---

--- 139 --
Question ID: 96505ebeaf5c96af46eb7c6ad159836fef5202f9_6
Original Code:
```
fn draw_field(draw: &Draw, model: &Model, win: &Rect) {
  let color = hsl(0.0, 0.0, 0.02);
  let source = OpenSimplex::new();
  let noisefn = Terrace::new(&source)
    .add_control_point(model.control_point1)
    .add_control_point(model.control_point2)
    .add_control_point(model.control_point3)
    .add_control_point(model.control_point4)
    .add_control_point(model.control_point5);

  for _i in 0..=model.n_lines {
    // circular placement
    // let init_angle = map_range(_i, 0, model.n_lines, 0.0, 2.0 * PI);
    // let mut x = init_angle.cos() * win.left().hypot(win.bottom()) * model.radius;
    // let mut y = init_angle.sin() * win.left().hypot(win.bottom()) * model.radius;

    // random rectangular placement
    let diag = win.left().hypot(win.bottom());
    let mut x = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);
    let mut y = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);

    let _init_x = x;
    let init_y = y;

    // Generate points for the line that do not intersect other lines
    let points = (0..model.n_steps)
      .map(|_n| {
        // let angle = field(model, x, y);
        // hmm, not quite sure why this is necessary
        let angle = noise_field(model.seed, model.noise_scale, x, y, &noisefn);
        if init_y < 0.0 {
          x -= angle.cos();
          y -= angle.sin();
        } else {
          x += angle.cos();
          y += angle.sin();
        };

        let point = pt2(x, y);
        Some(point)
      })
      // Skip any initial Nones
      // Take all the Somes until we hit a None.
      .skip_while(|&o| o.is_none())
      .take_while(|&o| o.is_some())
      .filter_map(|o| o);

    draw
      .polyline()
      .caps_round()
      .weight(model.stroke_weight)
      .color(color)
      .points(points);
  }
}
```


Overlapping Code:
```
draw_field(draw: &Draw, model: &Model, win: &Rect) {
let color = hsl(0.0, 0.0, 0.02);
let source = OpenSimplex::new();
let noisefn = Terrace::new(&source)
.add_control_point(model.control_point1)
.add_control_point(model.control_point2)
.add_control_point(model.control_point3)
.add_control_point(model.control_point4)
.add_control_point(model.control_point5);
for _i in 0..=model.n_lines {
// circular placement
// let init_angle = map_range(_i, 0, model.n_lines, 0.0, 2.0 * PI);
// let mut x = init_angle.cos() * win.left().hypot(win.bottom()) * model.radius;
// let mut y = init_angle.sin() * win.left().hypot(win.bottom()) * model.radius;
// random rectangular placement
let diag = win.left().hypot(win.bottom());
let mut x = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);
let mut y = random_range(diag * model.radius / 2.0, diag * -model.radius / 2.0);
let _init_x = x;
let init_y = y;
// Generate points for the line that do not intersect other lines
let points = (0..model.n_steps)
.map(|_n| {
// let angle = field(model, x, y);
// hmm, not quite sure why this is necessary
let angle = noise_field(model.seed, model.noise_scale, x, y, &noisefn);
if init_y < 0.0 {
x -= angle.cos();
y -= angle.sin();
} else {
x += angle.cos();
y += angle.sin();
};
let point = pt2(x, y);
Some(point)
})
// Skip any initial Nones
// Take all the Somes until we hit a None.
.skip_while(|&o| o.is_none())
.take_while(|&o| o.is_some())
.filter_map(|o| o);
draw
.polyline()
.caps_round()
.weight(model.stroke_weight)
.color(color)
.po
```
<Overlap Ratio: 0.9871877001921845>

---

--- 140 --
Question ID: e1cf57a1a62cadc5d181bfdf945465ab99f18ee1_6
Original Code:
```
fn bench_cidentity_giant(b: &mut Bencher) {
        let n = 16;

        let mat = from_reals(&[1.0, 0.0, 0.0, 1.0]);
        let c_indices = (0..n - 1).collect();
        let op = make_matrix_op(vec![n - 1], mat).unwrap();
        let op = make_control_op(c_indices, op).unwrap();

        let base_vector: Vec<f64> = (0..1 << n).map(|_| 0.0).collect();
        let input = from_reals(&base_vector);
        let mut output = from_reals(&base_vector);

        b.iter(|| apply_op(n, &op, &input, &mut output, 0, 0));
    }
```


Overlapping Code:
```
b: &mut Bencher) {
let n = 16;
let mat = from_reals(&[1.0, 0.0, 0.0, 1.0]);
let c_indices = (0..n - 1).collect();
let op = make_matrix_op(vec![n - 1], mat).unwrap();
let op = make_control_op(c_indices, op).unwrap();
let base_vector: Vec<f64> = (0..1 << n).map(|_| 0.0).collect();
let input = from_reals(&base_vector);
let mut output = from_reals(&base_vector);
b.iter(|| apply_op(n, &op, &input, &mut ou
```
<Overlap Ratio: 0.909706546275395>

---

--- 141 --
Question ID: ecbcc2862e0cba21d7359b869d7ebc01c05bf2a1_4
Original Code:
```
pub fn hello3() {
    env_setup();

    let mut contract: Contract = Contract::default();

    contract.hello3();

    assert_eq!(
        contract.get_phrase(),
        "Hello from yet_another_module",
    );
}
```


Overlapping Code:
```

env_setup();
let mut contract: Contract = Contract::default();
contract.hello3();
assert_eq!(
contract.get_phrase(),
"Hello from yet_another_module",
```
<Overlap Ratio: 0.872093023255814>

---

--- 142 --
Question ID: 5b624133894ec5a9d8631b19de5deaabd8a65bbf_10
Original Code:
```
async fn install_wallet(canister_id: &Principal, wasm_module: Vec<u8>) -> Result<(), String> {
        // Install Wasm
        #[derive(CandidType, Deserialize)]
        enum InstallMode {
            #[serde(rename = "install")]
            Install,
            #[serde(rename = "reinstall")]
            Reinstall,
            #[serde(rename = "upgrade")]
            Upgrade,
        }

        #[derive(CandidType, Deserialize)]
        struct CanisterInstall {
            mode: InstallMode,
            canister_id: Principal,
            #[serde(with = "serde_bytes")]
            wasm_module: Vec<u8>,
            arg: Vec<u8>,
        }

        let install_config = CanisterInstall {
            mode: InstallMode::Install,
            canister_id: *canister_id,
            wasm_module: wasm_module.clone(),
            arg: b" ".to_vec(),
        };

        match api::call::call(
            Principal::management_canister(),
            "install_code",
            (install_config,),
        )
        .await
        {
            Ok(x) => x,
            Err((code, msg)) => {
                return Err(format!(
                    "An error happened during the call: {}: {}",
                    code as u8, msg
                ))
            }
        };

        events::record(events::EventKind::WalletDeployed {
            canister: *canister_id,
        });

        // Store wallet wasm
        let store_args = WalletStoreWASMArgs { wasm_module };
        match api::call::call(*canister_id, "wallet_store_wallet_wasm", (store_args,)).await {
            Ok(x) => x,
            Err((code, msg)) => {
                return Err(format!(
                    "An error happened during the call: {}: {}",
                    code as u8, msg
                ))
            }
        };
        Ok(())
    }
```


Overlapping Code:
```
n install_wallet(canister_id: &Principal, wasm_module: Vec<u8>) -> Result<(), String> {
// Install Wasm
#[derive(CandidType, Deserialize)]
enum InstallMode {
#[serde(rename = "install")]
Install,
#[serde(rename = "reinstall")]
Reinstall,
#[serde(rename = "upgrade")]
Upgrade,
}
#[derive(CandidType, Deserialize)]
struct CanisterInstall {
mode: InstallMode,
canister_id: Principal,
#[serde(with = "serde_bytes")]
wasm_module: Vec<u8>,
arg: Vec<u8>,
}
let install_config = CanisterInstall {
mode: InstallMode::Install,
canister_id: *canister_id,
wasm_module: wasm_module.clone(),
arg: b" ".to_vec(),
};
match api::call::call(
Principal::management_canister(),
"install_code",
(install_config,),
)
.await
{
Ok(x) => x,
Err((code, msg)) => {
return Err(format!(
"An error happened during the call: {}: {}",
code as u8, msg
))
}
};
events::record(events::EventKind::WalletDeployed {
canister: *canister_id,
});
// Store wallet wasm
let store_args = WalletStoreWASMArgs { wasm_module };
match api::call::call(*canister_id, "wallet_store_wallet_wasm", (store_args,)).await {
Ok(x) => x,
Err((code, msg)) => {
return Err(format!(
"An error happened during the call: {}: {}",
code as u8, msg
))
}
};
O
```
<Overlap Ratio: 0.988391376451078>

---

--- 143 --
Question ID: 7e6af774643419db92e3ce46aea86f0dc494f050_17
Original Code:
```
fn test_small_bit_vec_tests() {
    let v = BitVec::from_slice(&[0]);
    assert!(!v.all());
    assert!(!v.any());
    assert!(v.none());

    let v = BitVec::from_slice(&[0b00010100]);
    assert!(!v.all());
    assert!(v.any());
    assert!(!v.none());

    let v = BitVec::from_slice(&[0xFF]);
    assert!(v.all());
    assert!(v.any());
    assert!(!v.none());
}
```


Overlapping Code:
```
all_bit_vec_tests() {
let v = BitVec::from_slice(&[0]);
assert!(!v.all());
assert!(!v.any());
assert!(v.none());
let v = BitVec::from_slice(&[0b00010100]);
assert!(!v.all());
assert!(v.any());
assert!(!v.none());
let v = BitVec::from_slice(&[0xFF]);
assert!(v.all());
assert!(v.any());
assert!(!v.none());

```
<Overlap Ratio: 0.9652996845425867>

---

--- 144 --
Question ID: dedc3653184eef876ff815ddb0d57675ad5cc4cd_2
Original Code:
```
pub fn perform_highpass(
    data: &mut [f64],
    sampling_rate: usize,
    cutoff: f64,
    order: usize,
    filter_type: FilterTypes,
    ripple: f64,
) -> Result<()> {
    let res = unsafe {
        data_handler::perform_highpass(
            data.as_mut_ptr() as *mut c_double,
            data.len() as c_int,
            sampling_rate as c_int,
            cutoff as c_double,
            order as c_int,
            filter_type as c_int,
            ripple as c_double,
        )
    };
    check_brainflow_exit_code(res)?;
    Ok(())
}
```


Overlapping Code:
```
perform_highpass(
data: &mut [f64],
sampling_rate: usize,
cutoff: f64,
order: usize,
filter_type: FilterTypes,
ripple: f64,
) -> Result<()> {
let res = unsafe {
data_handler::perform_highpass(
data.as_mut_ptr() as *mut c_double,
data.len() as c_int,
sampling_rate as c_int,
cutoff as c_double,
order as c_int,
filter_type as c_int,
ripple as c_double,
)
};
check_brainflow_exit_code(res)?;
Ok(())
}
```
<Overlap Ratio: 0.9827160493827161>

---

--- 145 --
Question ID: 7d0a4f66f48b8514bd9fb03b9e855d16dd4adb01_4
Original Code:
```
pub fn to_signed_transaction(state: &MinerState, transaction: RPCTransaction, stateful: &MemoryStateful) -> Result<Transaction, Error> {
    let address = match transaction.from {
        Some(val) => val.0,
        None => Address::default(),
    };
    let secret_key = {
        let mut secret_key = None;
        for key in state.accounts() {
            if Address::from_secret_key(&key)? == address {
                secret_key = Some(key);
            }
        }
        match secret_key {
            Some(val) => val,
            None => return Err(Error::NotFound),
        }
    };
    let block = state.get_block_by_number(state.block_height());
    let trie = stateful.state_of(block.header.state_root);

    let account: Option<Account> = trie.get(&address);

    let unsigned = UnsignedTransaction {
        nonce: match transaction.nonce {
            Some(val) => val.0,
            None => {
                account.as_ref().map(|account| account.nonce).unwrap_or(U256::zero())
            }
        },
        gas_price: match transaction.gas_price {
            Some(val) => val.0,
            None => Gas::zero(),
        },
        gas_limit: match transaction.gas {
            Some(val) => val.0,
            None => Gas::from(90000u64),
        },
        action: match transaction.to {
            Some(val) => TransactionAction::Call(val.0),
            None => TransactionAction::Create,
        },
        value: match transaction.value {
            Some(val) => val.0,
            None => U256::zero(),
        },
        input: match transaction.data {
            Some(val) => val.0,
            None => Vec::new(),
        },
    };
    let transaction = unsigned.sign::<GlobalSignaturePatch>(&secret_key);

    Ok(transaction)
}
```


Overlapping Code:
```
 to_signed_transaction(state: &MinerState, transaction: RPCTransaction, stateful: &MemoryStateful) -> Result<Transaction, Error> {
let address = match transaction.from {
Some(val) => val.0,
None => Address::default(),
};
let secret_key = {
let mut secret_key = None;
for key in state.accounts() {
if Address::from_secret_key(&key)? == address {
secret_key = Some(key);
}
}
match secret_key {
Some(val) => val,
None => return Err(Error::NotFound),
}
};
let block = state.get_block_by_number(state.block_height());
let trie = stateful.state_of(block.header.state_root);
let account: Option<Account> = trie.get(&address);
let unsigned = UnsignedTransaction {
nonce: match transaction.nonce {
Some(val) => val.0,
None => {
account.as_ref().map(|account| account.nonce).unwrap_or(U256::zero())
}
},
gas_price: match transaction.gas_price {
Some(val) => val.0,
None => Gas::zero(),
},
gas_limit: match transaction.gas {
Some(val) => val.0,
None => Gas::from(90000u64),
},
action: match transaction.to {
Some(val) => TransactionAction::Call(val.0),
None => TransactionAction::Create,
},
value: match transaction.value {
Some(val) => val.0,
None => U256::zero(),
},
input: match transaction.data {
Some(val) => val.0,
None => Vec::new(),
},
};
let transaction = unsigned.sign::<GlobalSignaturePatch>(&secret_
```
<Overlap Ratio: 0.9781790820165538>

---

--- 146 --
Question ID: 17f72486ca10ac010214ad07b7dbe96fa067c1f9_2
Original Code:
```
fn hit_vector(c: &mut Criterion) {
    let mut s = Sphere {
        center: V3D {
            x: 0.,
            y: 0.,
            z: 10.,
        },
        radius: 1.,
    };
    let mut r = RayxN {
        origin: V3DxN {
            x: f32xN::splat(0.),
            y: f32xN::splat(0.),
            z: f32xN::splat(0.),
        },
        dir: V3DxN {
            x: f32xN::splat(0.),
            y: f32xN::splat(0.),
            z: f32xN::splat(1.),
        },
    };

    c.bench(
        "vector",
        Benchmark::new("isec_sphere_hit", move |b| {
            b.iter(|| {
                let mut isect = IsectxN::default();
                let isect = black_box(&mut isect);
                let s = black_box(&mut s);
                let r = black_box(&mut r);
                let mut v = r.intersect(s, *isect);
                black_box(&mut v);
                assert_eq!(v.hit.all(), true);
            })
        })
        .throughput(Throughput::Elements(f32xN::lanes() as u64)),
    );
}
```


Overlapping Code:
```
t Criterion) {
let mut s = Sphere {
center: V3D {
x: 0.,
y: 0.,
z: 10.,
},
radius: 1.,
};
let mut r = RayxN {
origin: V3DxN {
x: f32xN::splat(0.),
y: f32xN::splat(0.),
z: f32xN::splat(0.),
},
dir: V3DxN {
x: f32xN::splat(0.),
y: f32xN::splat(0.),
z: f32xN::splat(1.),
},
};
c.bench(
"vector",
Benchmark::new("isec_sphere_hit", move |b| {
b.iter(|| {
let mut isect = IsectxN::default();
let isect = black_box(&mut isect);
let s = black_box(&mut s);
let r = black_box(&mut r);
let mut v = r.intersect(s, *isect);
black_box(&mut v);
assert_eq!(v.hit.all(), true);
})
})
.throughput(Throughput::Elements(f32xN::lanes() 
```
<Overlap Ratio: 0.9476117103235747>

---

--- 147 --
Question ID: 0953cf2ae6dc86f53baca42a655a6165a3597861_0
Original Code:
```
pub fn search<E: SearchEnv>(env: &mut E, name: &str) -> Option<Target> {
    if name.contains('/') {
        return if let Ok(path) = CString::new(name) {
            Some(Target::External { path })
        } else {
            None
        };
    }

    let builtin = env.builtins().get(name).copied();
    if let Some(builtin) = builtin {
        if builtin.r#type == Special {
            return Some(builtin.into());
        }
    }

    if let Some(function) = env.functions().get(name) {
        return Some(function.0.clone().into());
    }

    if let Some(builtin) = builtin {
        if builtin.r#type == Intrinsic {
            return Some(builtin.into());
        }
    }

    if let Some(path) = search_path(env, name) {
        if let Some(builtin) = builtin {
            assert_eq!(builtin.r#type, NonIntrinsic);
            return Some(builtin.into());
        }
        return Some(Target::External { path });
    }

    None
}
```


Overlapping Code:
```
arch<E: SearchEnv>(env: &mut E, name: &str) -> Option<Target> {
if name.contains('/') {
return if let Ok(path) = CString::new(name) {
Some(Target::External { path })
} else {
None
};
}
let builtin = env.builtins().get(name).copied();
if let Some(builtin) = builtin {
if builtin.r#type == Special {
return Some(builtin.into());
}
}
if let Some(function) = env.functions().get(name) {
return Some(function.0.clone().into());
}
if let Some(builtin) = builtin {
if builtin.r#type == Intrinsic {
return Some(builtin.into());
}
}
if let Some(path) = search_path(env, name) {
if let Some(builtin) = builtin {
assert_eq!(builtin.r#type, NonIntrinsic);
return Some(builtin.into());
}
return Some(Target::Exter
```
<Overlap Ratio: 0.9562841530054644>

---

--- 148 --
Question ID: e4ce04d58e035599f2e904b41e1e7fe2e4e2ef23_8
Original Code:
```
async fn submit_tx_when_service_is_frozen() {
    let (mut testkit, api) = init_testkit();
    let keys = testkit.us().service_keypair();

    let tx = keys.freeze_service(SUPERVISOR_INSTANCE_ID, SERVICE_ID);
    let block = testkit.create_block_with_transaction(tx);
    block[0].status().expect("Cannot freeze service");

    let ping = PingQuery { value: 64 };
    let err = api
        .public(ApiKind::Service("api-service"))
        .query(&ping)
        .post::<()>("submit-tx")
        .await
        .expect_err("Request to the valid endpoint should fail");
    assert_eq!(err.http_code, api::HttpStatusCode::SERVICE_UNAVAILABLE);
    assert_eq!(err.body.title, "Service is not active");

    let block = testkit.create_block();
    assert!(block.is_empty());
}
```


Overlapping Code:
```
ice_is_frozen() {
let (mut testkit, api) = init_testkit();
let keys = testkit.us().service_keypair();
let tx = keys.freeze_service(SUPERVISOR_INSTANCE_ID, SERVICE_ID);
let block = testkit.create_block_with_transaction(tx);
block[0].status().expect("Cannot freeze service");
let ping = PingQuery { value: 64 };
let err = api
.public(ApiKind::Service("api-service"))
.query(&ping)
.post::<()>("submit-tx")
.await
.expect_err("Request to the valid endpoint should fail");
assert_eq!(err.http_code, api::HttpStatusCode::SERVICE_UNAVAILABLE);
assert_eq!(err.body.title, "Service is not active");
let block = testkit.create_block();
assert!(block.is_empty(
```
<Overlap Ratio: 0.9516837481698389>

---

--- 149 --
Question ID: 767350991ac08cc681344bf1063ed059726417c0_13
Original Code:
```
fn test_loop_else_trim12() {
    let t = LoopElseTrim12 { values: &[1] };
    assert_eq!(t.render().unwrap(), "a \t1 b");

    let t = LoopElseTrim12 { values: &[] };
    assert_eq!(t.render().unwrap(), "a X\n b");
}
```


Overlapping Code:
```
else_trim12() {
let t = LoopElseTrim12 { values: &[1] };
assert_eq!(t.render().unwrap(), "a \t1 b");
let t = LoopElseTrim12 { values: &[] };
assert_eq!(t.render().unwrap(), "a 
```
<Overlap Ratio: 0.8844221105527639>

---

--- 150 --
Question ID: bfc489018883d968955a4b6a7de8c6ce38abbb90_0
Original Code:
```
fn main() {
    // Tell cargo to tell rustc to link the system bzip2
    // shared library.
    println!("cargo:rustc-link-lib=static=honey_analyzer");
    println!("cargo:rustc-link-search=./Honeybee/build");

    Command::new("make")
        .args(&["-C", "./Honeybee/build"])
        .output()
        .expect("could not run make");

    // Tell cargo to invalidate the built crate whenever the wrapper changes
    println!("cargo:rerun-if-changed=wrapper.h");
    println!("cargo:rerun-if-changed=./Honeybee/build/libhoney_analyzer.a");

    // The bindgen::Builder is the main entry point
    // to bindgen, and lets you build up options for
    // the resulting bindings.
    let bindings = bindgen::Builder::default()
        // The input header we would like to generate
        // bindings for.
        .header("wrapper.h")
        // Tell cargo to invalidate the built crate whenever any of the
        // included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        // Finish the builder and generate the bindings.
        .generate()
        // Unwrap the Result and panic on failure.
        .expect("Unable to generate bindings");

    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("bindings.rs"))
        .expect("Couldn't write bindings!");
}
```


Overlapping Code:
```
fn main() {
// Tell cargo to tell rustc to link the system bzip2
// shared library.
println!("cargo:rustc-link-lib=static=honey_analyzer");
println!("cargo:rustc-link-search=./Honeybee/build");
Command::new("make")
.args(&["-C", "./Honeybee/build"])
.output()
.expect("could not run make");
// Tell cargo to invalidate the built crate whenever the wrapper changes
println!("cargo:rerun-if-changed=wrapper.h");
println!("cargo:rerun-if-changed=./Honeybee/build/libhoney_analyzer.a");
// The bindgen::Builder is the main entry point
// to bindgen, and lets you build up options for
// the resulting bindings.
let bindings = bindgen::Builder::default()
// The input header we would like to generate
// bindings for.
.header("wrapper.h")
// Tell cargo to invalidate the built crate whenever any of the
// included header files changed.
.parse_callbacks(Box::new(bindgen::CargoCallbacks))
// Finish the builder and generate the bindings.
.generate()
// Unwrap the Result and panic on failure.
.expect("Unable to generate bindings");
// Write the bindings to the $OUT_DIR/bindings.rs file.
let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
bindings
.write_to_file(out_path.join("bindings.rs"))
.expect("Couldn't write bindings!");
}
```
<Overlap Ratio: 1.0>

---

--- 151 --
Question ID: 8a15579b1ca5073c0fed58e1bfa0cbaca93c9167_1
Original Code:
```
fn panicIfProcessNotSuccessful(programName: &'static str, absoluteHomeFolderPath: &str, mut command: Command) -> String
{
	let output = command.output().unwrap_or_else(|error|
	{
		panic!("Failed to execute '{}' in '{}' error was '{}'", programName, absoluteHomeFolderPath, error);
	});
	
	let code = output.status.code().unwrap_or_else(||
	{
		panic!("Failed to retrieve exit status from command - was it killed by a signal?");
	});

	let standardOut = String::from_utf8_lossy(&output.stdout);
	if code == 0
	{
		return standardOut.into_owned();
	}
	
	let standardError = String::from_utf8_lossy(&output.stderr);
	panic!("Command '{}' failed with exit code '{}' (standard out was '{}'; standard error was '{}')", programName, code, standardOut.into_owned(), standardError.into_owned());
}
```


Overlapping Code:
```
cessNotSuccessful(programName: &'static str, absoluteHomeFolderPath: &str, mut command: Command) -> String
{
let output = command.output().unwrap_or_else(|error|
{
panic!("Failed to execute '{}' in '{}' error was '{}'", programName, absoluteHomeFolderPath, error);
});

let code = output.status.code().unwrap_or_else(||
{
panic!("Failed to retrieve exit status from command - was it killed by a signal?");
});
let standardOut = String::from_utf8_lossy(&output.stdout);
if code == 0
{
return standardOut.into_owned();
}

let standardError = String::from_utf8_lossy(&output.stderr);
panic!("Command '{}' failed with exit code '{}' (standard out was '{}'; standard error was '{}')", programName, code, standardOut.into_owned(), standardError.into_owned(
```
<Overlap Ratio: 0.9765625>

---

--- 152 --
Question ID: d9996dac95a8685c5b10471c5e631791509a6bd3_2
Original Code:
```
pub fn delete(conn: DatabaseConnection, user: User, id: i32) -> Result<JsonValue> {
	let log_type_model = LogType::new(&conn, id)?.as_model();

	if log_type_model.user_id != user.get_id() {
		return Err(ErrorKind::AccessDenied.into());
	}

	diesel::delete(log_type_dsl::log_type)
		.filter(log_type_dsl::id.eq(id))
		.execute(&*conn)?;

	Ok(json!({
		"status": true
	}))
}
```


Overlapping Code:
```
 DatabaseConnection, user: User, id: i32) -> Result<JsonValue> {
let log_type_model = LogType::new(&conn, id)?.as_model();
if log_type_model.user_id != user.get_id() {
return Err(ErrorKind::AccessDenied.into());
}
diesel::delete(log_type_dsl::log_type)
.filter(log_type_dsl::id.eq(id))
.execute(&*con
```
<Overlap Ratio: 0.8450704225352113>

---

--- 153 --
Question ID: 0f3e077d1de342c44a9cdb4f271ed7f73f727538_0
Original Code:
```
fn main() {
    assert_eq!(
        <() as Foo<u32>>::Out::default().to_string(),
        "0");
    assert_eq!(
        <() as Foo<u64>>::Out::default().to_string(),
        "false");

    assert_eq!(
        <LocalDefault as Foo<u32>>::Out::default().to_string(),
        "0");
    assert_eq!(
        <LocalOverride as Foo<u64>>::Out::default().to_string(),
        "false");
}
```


Overlapping Code:
```
main() {
assert_eq!(
<() as Foo<u32>>::Out::default().to_string(),
"0");
assert_eq!(
<() as Foo<u64>>::Out::default().to_string(),
"false");
assert_eq!(
<LocalDefault as Foo<u32>>::Out::default().to_string(),
"0");
assert_eq!(
<LocalOverride as Foo<u
```
<Overlap Ratio: 0.8389261744966443>

---

--- 154 --
Question ID: 33af33f042063cb938a7e5f8f2845e3f68908304_0
Original Code:
```
fn run_benchmarks< F: FnOnce( &mut Bencher ) >( callback: F ) {
    if !*IS_NODEJS {
        let body = document().query_selector( "body" ).unwrap().unwrap();
        let start = document().create_element( "button" ).unwrap();
        start.set_text_content( "Start" );
        body.append_child( &start );
        let pre = document().create_element( "pre" ).unwrap();
        pre.set_attribute( "id", "console" ).unwrap();
        body.append_child( &pre );
    }

    if cfg!( nightly ) {
        js! {
            console.log( "Compiled with the `nightly` feature!" );
        }
    }

    let mut bencher = Bencher::new();
    callback( &mut bencher );

    if !*IS_NODEJS {
        let body = document().query_selector( "body" ).unwrap().unwrap();
        body.add_event_listener( move |_: ClickEvent| {
            bencher.run();
        });
    } else {
        bencher.run();
    }
}
```


Overlapping Code:
```
s< F: FnOnce( &mut Bencher ) >( callback: F ) {
if !*IS_NODEJS {
let body = document().query_selector( "body" ).unwrap().unwrap();
let start = document().create_element( "button" ).unwrap();
start.set_text_content( "Start" );
body.append_child( &start );
let pre = document().create_element( "pre" ).unwrap();
pre.set_attribute( "id", "console" ).unwrap();
body.append_child( &pre );
}
if cfg!( nightly ) {
js! {
console.log( "Compiled with the `nightly` feature!" );
}
}
let mut bencher = Bencher::new();
callback( &mut bencher );
if !*IS_NODEJS {
let body = document().query_selector( "body" ).unwrap().unwrap();
body.add_event_listener( move |_: ClickEvent| {
bencher.run();
});
} else {
bencher.r
```
<Overlap Ratio: 0.9655172413793104>

---

--- 155 --
Question ID: 5b24f4e259b056a71984f4199a617730ab78616c_1
Original Code:
```
fn key_inception_test() {
    let mut wallet = UnlockedWallet::new("test");
    incept_keys(&mut wallet).unwrap();
    // check next
    let next = wallet.get_content_by_controller(NEXT);
    assert!(next.is_some());
    match next.unwrap() {
        Content::KeyPair(_) => (),
        _ => panic!("next is not a KeyPair!")
    }

    // check current
    let current = wallet.get_content_by_controller(CURRENT);
    assert!(current.is_some());
    match current.unwrap() {
        Content::KeyPair(_) => (),
        _ => panic!("current is not a KeyPair!")
    }

    // check crypto
    let crypto = wallet.get_content_by_controller(CRYPTO);
    assert!(crypto.is_some());
    match crypto.unwrap() {
        Content::KeyPair(_) => (),
        _ => panic!("crypto is not a KeyPair!")
    }
}
```


Overlapping Code:
```
eption_test() {
let mut wallet = UnlockedWallet::new("test");
incept_keys(&mut wallet).unwrap();
// check next
let next = wallet.get_content_by_controller(NEXT);
assert!(next.is_some());
match next.unwrap() {
Content::KeyPair(_) => (),
_ => panic!("next is not a KeyPair!")
}
// check current
let current = wallet.get_content_by_controller(CURRENT);
assert!(current.is_some());
match current.unwrap() {
Content::KeyPair(_) => (),
_ => panic!("current is not a KeyPair!")
}
// check crypto
let crypto = wallet.get_content_by_controller(CRYPTO);
assert!(crypto.is_some());
match crypto.unwrap() {
Content::KeyPair(_) => (),
_ => panic!("crypto is not a
```
<Overlap Ratio: 0.9629629629629629>

---

--- 156 --
Question ID: 6909681d7022d2c0050eef2a8fd33f1497608030_0
Original Code:
```
pub fn expand_groups(path: &str) -> Vec<String> {
    lazy_static! {
        static ref GROUPS_MATCHER: Regex = Regex::new(r"\{[^\{]+?\}").unwrap();
    }

    let mut offset = 0;
    let mut chunks: Vec<Vec<&str>> = vec![];

    for m in GROUPS_MATCHER.find_iter(path) {
        chunks.push(vec![&path[offset..m.start()]]);
        chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());
        offset = m.end();
    }
    chunks.push(vec![&path[offset..]]);

    join_chunks(chunks)
}
```


Overlapping Code:
```
 fn expand_groups(path: &str) -> Vec<String> {
lazy_static! {
static ref GROUPS_MATCHER: Regex = Regex::new(r"\{[^\{]+?\}").unwrap();
}
let mut offset = 0;
let mut chunks: Vec<Vec<&str>> = vec![];
for m in GROUPS_MATCHER.find_iter(path) {
chunks.push(vec![&path[offset..m.start()]]);
chunks.push(path[m.start() + 1..m.end() - 1].split(',').collect());
offset = m.end();
}
chunks.push(vec![&path[offse
```
<Overlap Ratio: 0.9259259259259259>

---

--- 157 --
Question ID: e880f876f91a94a74444433184a987b176ed7ce9_16
Original Code:
```
fn main() {
    copy_after_move();
    move_after_move();
    borrow_after_move();

    move_after_borrow();

    copy_after_mut_borrow();
    move_after_mut_borrow();
    borrow_after_mut_borrow();
    mut_borrow_after_borrow();

    copy_after_move_nested();
    move_after_move_nested();
    borrow_after_move_nested();

    move_after_borrow_nested();

    copy_after_mut_borrow_nested();
    move_after_mut_borrow_nested();
    borrow_after_mut_borrow_nested();
    mut_borrow_after_borrow_nested();
}
```


Overlapping Code:
```
move();
move_after_move();
borrow_after_move();
move_after_borrow();
copy_after_mut_borrow();
move_after_mut_borrow();
borrow_after_mut_borrow();
mut_borrow_after_borrow();
copy_after_move_nested();
move_after_move_nested();
borrow_after_move_nested();
move_after_borrow_nested();
copy_after_mut_borrow_nested();
move_after_mut_borrow_nested();
borrow_after_mut_borrow_nested();
mut_borrow_after_borrow_n
```
<Overlap Ratio: 0.9244851258581236>

---

--- 158 --
Question ID: 87138225c889272ff48408c3c09661d09fda2894_0
Original Code:
```
fn main() {
    #[derive(Form)]
    #[form(newtype)]
    struct A{}
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 159 --
Question ID: 86375a58b94c0bd087ab91e8ffed242f68308f74_9
Original Code:
```
pub fn deser_operation_crate_operation_get_device_methods(
    value: &[u8],
    mut builder: crate::output::get_device_methods_output::Builder,
) -> Result<crate::output::get_device_methods_output::Builder, aws_smithy_json::deserialize::Error>
{
    let mut tokens_owned =
        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))
            .peekable();
    let tokens = &mut tokens_owned;
    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;
    loop {
        match tokens.next().transpose()? {
            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,
            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {
                match key.to_unescaped()?.as_ref() {
                    "deviceMethods" => {
                        builder = builder.set_device_methods(
                            crate::json_deser::deser_list_com_amazonaws_iot1clickdevicesservice___list_of_device_method(tokens)?
                        );
                    }
                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,
                }
            }
            other => {
                return Err(aws_smithy_json::deserialize::Error::custom(format!(
                    "expected object key or end object, found: {:?}",
                    other
                )))
            }
        }
    }
    if tokens.next().is_some() {
        return Err(aws_smithy_json::deserialize::Error::custom(
            "found more JSON tokens after completing parsing",
        ));
    }
    Ok(builder)
}
```


Overlapping Code:
```
operation_get_device_methods(
value: &[u8],
mut builder: crate::output::get_device_methods_output::Builder,
) -> Result<crate::output::get_device_methods_output::Builder, aws_smithy_json::deserialize::Error>
{
let mut tokens_owned =
aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))
.peekable();
let tokens = &mut tokens_owned;
aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;
loop {
match tokens.next().transpose()? {
Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,
Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {
match key.to_unescaped()?.as_ref() {
"deviceMethods" => {
builder = builder.set_device_methods(
crate::json_deser::deser_list_com_amazonaws_iot1clickdevicesservice___list_of_device_method(tokens)?
);
}
_ => aws_smithy_json::deserialize::token::skip_value(tokens)?,
}
}
other => {
return Err(aws_smithy_json::deserialize::Error::custom(format!(
"expected object key or end object, found: {:?}",
other
)))
}
}
}
if tokens.next().is_some() {
return Err(aws_smithy_json::deserialize::Error::custom(
"found more JSON tokens after completing parsing",
));
}
Ok(builder)
}
```
<Overlap Ratio: 0.9761120263591433>

---

--- 160 --
Question ID: 65567f1625990beb275e3bfe29ed6bb0c8b1c9e2_2
Original Code:
```
fn test_deserialize_serialize_signed_response() {
        let response_xml = include_str!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/test_vectors/response_signed.xml",
        ));
        let expected_response: Response = response_xml
            .parse()
            .expect("failed to parse response_signed.xml");
        let serialized_response =
            yaserde::ser::to_string(&expected_response).expect("failed to convert response to xml");
        std::fs::write("/tmp/foo.xml", &serialized_response).unwrap();
        let actual_response: Response = serialized_response
            .parse()
            .expect("failed to re-parse response");

        assert_eq!(expected_response, actual_response);
    }
```


Overlapping Code:
```
deserialize_serialize_signed_response() {
let response_xml = include_str!(concat!(
env!("CARGO_MANIFEST_DIR"),
"/test_vectors/response_signed.xml",
));
let expected_response: Response = response_xml
.parse()
.expect("failed to parse response_signed.xml");
let serialized_response =
yaserde::ser::to_string(&expected_response).expect("failed to convert response to xml");
std::fs::write("/tmp/foo.xml", &serialized_response).unwrap();
let actual_response: Response = serialized_response
.parse()
.expect("failed to re-parse response");
assert_eq!(expected_response, actual_response);
}
```
<Overlap Ratio: 0.9864864864864865>

---

--- 161 --
Question ID: 9cdfdc3dae4dc5096084630cd33cfe44e2e66635_53
Original Code:
```
pub fn serialize_operation_crate_operation_modify_replication_group(
    input: &crate::input::ModifyReplicationGroupInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer =
        aws_smithy_query::QueryWriter::new(&mut out, "ModifyReplicationGroup", "2015-02-02");
    #[allow(unused_mut)]
    let mut scope_667 = writer.prefix("ReplicationGroupId");
    if let Some(var_668) = &input.replication_group_id {
        scope_667.string(var_668);
    }
    #[allow(unused_mut)]
    let mut scope_669 = writer.prefix("ReplicationGroupDescription");
    if let Some(var_670) = &input.replication_group_description {
        scope_669.string(var_670);
    }
    #[allow(unused_mut)]
    let mut scope_671 = writer.prefix("PrimaryClusterId");
    if let Some(var_672) = &input.primary_cluster_id {
        scope_671.string(var_672);
    }
    #[allow(unused_mut)]
    let mut scope_673 = writer.prefix("SnapshottingClusterId");
    if let Some(var_674) = &input.snapshotting_cluster_id {
        scope_673.string(var_674);
    }
    #[allow(unused_mut)]
    let mut scope_675 = writer.prefix("AutomaticFailoverEnabled");
    if let Some(var_676) = &input.automatic_failover_enabled {
        scope_675.boolean(*var_676);
    }
    #[allow(unused_mut)]
    let mut scope_677 = writer.prefix("MultiAZEnabled");
    if let Some(var_678) = &input.multi_az_enabled {
        scope_677.boolean(*var_678);
    }
    #[allow(unused_mut)]
    let mut scope_679 = writer.prefix("NodeGroupId");
    if let Some(var_680) = &input.node_group_id {
        scope_679.string(var_680);
    }
    #[allow(unused_mut)]
    let mut scope_681 = writer.prefix("CacheSecurityGroupNames");
    if let Some(var_682) = &input.cache_security_group_names {
        let mut list_684 = scope_681.start_list(false, Some("CacheSecurityGroupName"));
        for item_683 in var_682 {
            #[allow(unused_mut)]
            let mut entry_685 = list_684.entry();
            entry_685.string(item_683);
        }
        list_684.finish();
    }
    #[allow(unused_mut)]
    let mut scope_686 = writer.prefix("SecurityGroupIds");
    if let Some(var_687) = &input.security_group_ids {
        let mut list_689 = scope_686.start_list(false, Some("SecurityGroupId"));
        for item_688 in var_687 {
            #[allow(unused_mut)]
            let mut entry_690 = list_689.entry();
            entry_690.string(item_688);
        }
        list_689.finish();
    }
    #[allow(unused_mut)]
    let mut scope_691 = writer.prefix("PreferredMaintenanceWindow");
    if let Some(var_692) = &input.preferred_maintenance_window {
        scope_691.string(var_692);
    }
    #[allow(unused_mut)]
    let mut scope_693 = writer.prefix("NotificationTopicArn");
    if let Some(var_694) = &input.notification_topic_arn {
        scope_693.string(var_694);
    }
    #[allow(unused_mut)]
    let mut scope_695 = writer.prefix("CacheParameterGroupName");
    if let Some(var_696) = &input.cache_parameter_group_name {
        scope_695.string(var_696);
    }
    #[allow(unused_mut)]
    let mut scope_697 = writer.prefix("NotificationTopicStatus");
    if let Some(var_698) = &input.notification_topic_status {
        scope_697.string(var_698);
    }
    #[allow(unused_mut)]
    let mut scope_699 = writer.prefix("ApplyImmediately");
    if input.apply_immediately {
        scope_699.boolean(input.apply_immediately);
    }
    #[allow(unused_mut)]
    let mut scope_700 = writer.prefix("EngineVersion");
    if let Some(var_701) = &input.engine_version {
        scope_700.string(var_701);
    }
    #[allow(unused_mut)]
    let mut scope_702 = writer.prefix("AutoMinorVersionUpgrade");
    if let Some(var_703) = &input.auto_minor_version_upgrade {
        scope_702.boolean(*var_703);
    }
    #[allow(unused_mut)]
    let mut scope_704 = writer.prefix("SnapshotRetentionLimit");
    if let Some(var_705) = &input.snapshot_retention_limit {
        scope_704.number(
            #[allow(clippy::useless_conversion)]
            aws_smithy_types::Number::NegInt((*var_705).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_706 = writer.prefix("SnapshotWindow");
    if let Some(var_707) = &input.snapshot_window {
        scope_706.string(var_707);
    }
    #[allow(unused_mut)]
    let mut scope_708 = writer.prefix("CacheNodeType");
    if let Some(var_709) = &input.cache_node_type {
        scope_708.string(var_709);
    }
    #[allow(unused_mut)]
    let mut scope_710 = writer.prefix("AuthToken");
    if let Some(var_711) = &input.auth_token {
        scope_710.string(var_711);
    }
    #[allow(unused_mut)]
    let mut scope_712 = writer.prefix("AuthTokenUpdateStrategy");
    if let Some(var_713) = &input.auth_token_update_strategy {
        scope_712.string(var_713.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_714 = writer.prefix("UserGroupIdsToAdd");
    if let Some(var_715) = &input.user_group_ids_to_add {
        let mut list_717 = scope_714.start_list(false, None);
        for item_716 in var_715 {
            #[allow(unused_mut)]
            let mut entry_718 = list_717.entry();
            entry_718.string(item_716);
        }
        list_717.finish();
    }
    #[allow(unused_mut)]
    let mut scope_719 = writer.prefix("UserGroupIdsToRemove");
    if let Some(var_720) = &input.user_group_ids_to_remove {
        let mut list_722 = scope_719.start_list(false, None);
        for item_721 in var_720 {
            #[allow(unused_mut)]
            let mut entry_723 = list_722.entry();
            entry_723.string(item_721);
        }
        list_722.finish();
    }
    #[allow(unused_mut)]
    let mut scope_724 = writer.prefix("RemoveUserGroups");
    if let Some(var_725) = &input.remove_user_groups {
        scope_724.boolean(*var_725);
    }
    #[allow(unused_mut)]
    let mut scope_726 = writer.prefix("LogDeliveryConfigurations");
    if let Some(var_727) = &input.log_delivery_configurations {
        let mut list_729 = scope_726.start_list(false, Some("LogDeliveryConfigurationRequest"));
        for item_728 in var_727 {
            #[allow(unused_mut)]
            let mut entry_730 = list_729.entry();
            crate::query_ser::serialize_structure_crate_model_log_delivery_configuration_request(
                entry_730, item_728,
            )?;
        }
        list_729.finish();
    }
    writer.finish();
    Ok(aws_smithy_http::body::SdkBody::from(out))
}
```


Overlapping Code:
```
pub fn serialize_operation_crate_operation_modify_replication_group(
input: &crate::input::ModifyReplicationGroupInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
let mut out = String::new();
#[allow(unused_mut)]
let mut writer =
aws_smithy_query::QueryWriter::new(&mut out, "ModifyReplicationGroup", "2015-02-02");
#[allow(unused_mut)]
let mut scope_667 = writer.prefix("ReplicationGroupId");
if let Some(var_668) = &input.replication_group_id {
scope_667.string(var_668);
}
#[allow(unused_mut)]
let mut scope_669 = writer.prefix("ReplicationGroupDescription");
if let Some(var_670) = &input.replication_group_description {
scope_669.string(var_670);
}
#[allow(unused_mut)]
let mut scope_671 = writer.prefix("PrimaryClusterId");
if let Some(var_672) = &input.primary_cluster_id {
scope_671.string(var_672);
}
#[allow(unused_mut)]
let mut scope_673 = writer.prefix("SnapshottingClusterId");
if let Some(var_674) = &input.snapshotting_cluster_id {
scope_673.string(var_674);
}
#[allow(unused_mut)]
let mut scope_675 = writer.prefix("AutomaticFailoverEnabled");
if let Some(var_676) = &input.automatic_failover_enabled {
scope_675.boolean(*var_676);
}
#[allow(unused_mut)]
let mut scope_677 = writer.prefix("MultiAZEnabled");
if let Some(var_678) = &input.multi_az_enabled {
scope_677.boolean(*var_678);
}
#[allow(unused_mut)]
let mut scope_679 = writer.prefix("NodeGroupId");
if let Some(var_680) = &input.node_group_id {
scope_679.string(var_680);
}
#[allow(unused_mut)]
let mut scope_681 = writer.prefix("CacheSecurityGroupNames");
if let Some(var_682) = &input.cache_security_group_names {
let mut list_684 = scope_681.start_list(false, Some("CacheSecurityGroupName"));
for item_683 in var_682 {
#[allow(unused_mut)]
let mut entry_685 = list_684.entry();
entry_685.string(item_683);
}
list_684.finish();
}
#[allow(unused_mut)]
let mut scope_686 = writer.prefix("SecurityGroupIds");
if let Some(var_687) = &input.security_group_ids {
let mut list_689 = scope_686.start_list(false, Some("SecurityGroupId"));
for item_688 in var_687 {
#[allow(unused_mut)]
let mut entry_690 = list
```
<Overlap Ratio: 0.9865678554886521>

---

--- 162 --
Question ID: 7f4f4a85523e169edbd101e27da6c913897bbc70_8
Original Code:
```
fn test_sub_self() {
        let a;
        let mut b;

        let (ap, asz) = make_limbs!(const a, 0, 2);
        let bp = make_limbs!(out b, 2);
        let bsz = 2;
        b[0] = Limb(2);
        b[1] = Limb(1);

        unsafe {
            assert_eq!(sub(bp, ap, asz, bp.as_const(), bsz), 0);
        }
        assert_eq!(b, [!1, 0]);
    }
```


Overlapping Code:
```
elf() {
let a;
let mut b;
let (ap, asz) = make_limbs!(const a, 0, 2);
let bp = make_limbs!(out b, 2);
let bsz = 2;
b[0] = Limb(2);
b[1] = Limb(1);
unsafe {
assert_eq!(sub(bp, ap, asz, bp.as_const(), bsz), 0);
}
```
<Overlap Ratio: 0.8433734939759037>

---

--- 163 --
Question ID: ccf5cfcfbb628b2aace6b7ce9bba1d5b1502d0ce_0
Original Code:
```
pub fn combination_save(
    storage: &mut dyn Storage,
    lottery_id: u64,
    address: CanonicalAddr,
    combination: Vec<String>,
) -> StdResult<()> {
    let mut exist = true;
    // Save combination by senders
    PREFIXED_USER_COMBINATION.update(
        storage,
        (&lottery_id.to_be_bytes(), address.as_slice()),
        |exists| -> StdResult<Vec<String>> {
            match exists {
                Some(combinations) => {
                    let mut modified = combinations;
                    modified.extend(combination.clone());
                    Ok(modified)
                }
                None => {
                    exist = false;
                    Ok(combination.clone())
                }
            }
        },
    )?;
    if !exist {
        ALL_USER_COMBINATION.update(
            storage,
            &lottery_id.to_be_bytes(),
            |exist| -> StdResult<Vec<CanonicalAddr>> {
                match exist {
                    None => Ok(vec![address]),
                    Some(players) => {
                        let mut data = players;
                        data.push(address);
                        Ok(data)
                    }
                }
            },
        )?;
        COUNT_PLAYERS
            .update(
                storage,
                &lottery_id.to_be_bytes(),
                |exists| -> StdResult<Uint128> {
                    match exists {
                        None => Ok(Uint128(1)),
                        Some(p) => Ok(p.add(Uint128(1))),
                    }
                },
            )
            .map(|_| ())?
    }
    COUNT_TICKETS
        .update(
            storage,
            &lottery_id.to_be_bytes(),
            |exists| -> StdResult<Uint128> {
                match exists {
                    None => Ok(Uint128(combination.len() as u128)),
                    Some(p) => Ok(p.add(Uint128(combination.len() as u128))),
                }
            },
        )
        .map(|_| ())
}
```


Overlapping Code:
```
n_save(
storage: &mut dyn Storage,
lottery_id: u64,
address: CanonicalAddr,
combination: Vec<String>,
) -> StdResult<()> {
let mut exist = true;
// Save combination by senders
PREFIXED_USER_COMBINATION.update(
storage,
(&lottery_id.to_be_bytes(), address.as_slice()),
|exists| -> StdResult<Vec<String>> {
match exists {
Some(combinations) => {
let mut modified = combinations;
modified.extend(combination.clone());
Ok(modified)
}
None => {
exist = false;
Ok(combination.clone())
}
}
},
)?;
if !exist {
ALL_USER_COMBINATION.update(
storage,
&lottery_id.to_be_bytes(),
|exist| -> StdResult<Vec<CanonicalAddr>> {
match exist {
None => Ok(vec![address]),
Some(players) => {
let mut data = players;
data.push(address);
Ok(data)
}
}
},
)?;
COUNT_PLAYERS
.update(
storage,
&lottery_id.to_be_bytes(),
|exists| -> StdResult<Uint128> {
match exists {
None => Ok(Uint128(1)),
Some(p) => Ok(p.add(Uint128(1))),
}
},
)
.map(|_| ())?
}
COUNT_TICKETS
.update(
storage,
&lottery_id.to_be_bytes(),
|exists| -> StdResult<Uint128> {
match exists {
None => Ok(Uint128(combination.len() as u128)),
Some(p) => Ok(p.add(Uint128(combination.len() as u128))),
}
},
)
.map(|_|
```
<Overlap Ratio: 0.9803921568627451>

---

--- 164 --
Question ID: 812215e67b0cf0df02f68a8b186ce073b0925908_122
Original Code:
```
fn test_commutator_scalar_e2() {
        let scalar = EuclideanMultivector2::from_scalar(6_f64);
        let e2 = EuclideanMultivector2::unit_e2();
        let expected = EuclideanMultivector2::zero();
        let result = scalar.commutator(&e2);

        assert_eq!(result, expected);
    }
```


Overlapping Code:
```
_e2() {
let scalar = EuclideanMultivector2::from_scalar(6_f64);
let e2 = EuclideanMultivector2::unit_e2();
let expected = EuclideanMultivector2::zero();
let result = scalar.commutator(&e2);
assert_eq!(result, expected);
}
```
<Overlap Ratio: 0.8983739837398373>

---

--- 165 --
Question ID: 1f1c81f7ac1a0489cb978eaa361e1509557cc9c8_4
Original Code:
```
fn test_ec_aes_siv_test_vectors() {
    tink_hybrid::init();
    // These are the same test vectors used to test the c++ implementation in
    // tink/cc/hybrid/ecies_aead_hkdf_hybrid_decrypt_test.cc.
    struct TestCase {
        name: &'static str,
        key: &'static str,
        ciphertext: &'static str,
        context: &'static str,
        plaintext: &'static str,
    }
    let test_vectors = vec![
        TestCase {
            name:       "Empty plaintext",
            key:        "32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02",
            ciphertext: "0401b11f8c9bafe30ae13f8bd15528714e752631a4328bf146009068e99489c8e9fae1ec39e3fe9994723711417fcab2af4b3c9b60117d47d33d35175c87b483b8935a73312940d1fbf8da3944a89b5e8b",
            context:    "some context info",
            plaintext:  "",
        },
        TestCase{
            name:       "Small plaintext",
            key:        "32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02",
            ciphertext: "040230023d1547b55af5a735a7f460722612126d7539d7cd0f677d308b29c6f52a964e66e7b0cb44cff1673df9e2c793f1477ca755807bfbeadcae1ab20b45ecb1501ca5e3f5b0626d3ca40aa5d010443d506e4df90b",
            context:    "some context info",
            plaintext:  "hello",
        },
        TestCase{
            name:       "Large plaintext",
            key:        "32588172ed65830571bb83748f7fddd383323208a7825c80a71bef846333eb02",
            ciphertext: "0441ddd246cea0825bd68bddff05cec54a4ee678da35b2f5cfbbb32e5350bdd817214bfb7b5ed5528131bde56916062cfbd8b9952d9e0907a6e87e1de54db5df3aaccddd328efcf7771ce061e647488f66b8c11a9fca171dcff813e90b44b2739573f9f23b60202491870c7ff8aaf0ae46838e48f17f8dc1ad55b67809699dd31eb6ca50dfa9beeee32d30bdc00a1eb1d8b0cbcedbe50b1e24619cc5e79042f25f49e2c2d5a35c79e833c0d68e31a93da4173aacd0428b367594ed4636763d16c23e4f8c115d44bddc83bcefcaea13587238ce8b7a5d5fad53beeb59aaa1d7483eb4bac93ed50ed4d3e9fd5af760283fd38080b58744b73212a36039179ce6f96ef1ecaa05b5186967d81c06b9cd91140dfbd54084ddcfd941527719848a2eecb84278f6a0fe9357a3964f87222fcd16a12a353e1f64fd45dc227a4a2112da6f61269f22f16b41e68eadf0b6b3a48c67b9e7e3ec1c66eecce50dda8ecbce99d3778299aa28741b7247fbc46a1b8a908dc23943c2dd17210a270bb12b096c2c6a00400a95c62894a15b9fc44e709d27348f2f2644a786cd9e96caf42ea9b949f76e85e6f7365e15fa2902e851222c025f6c208269d799fcfc4c0b37aba8979ed9e6ccf543c217ee0b6ad05f0e3ffb92943d308c801b25efedab5bf93a733bdae611132d774d4b9ee4fb5e88ae63014315ae9571039a8c8c7020e2b3a1bbd4235b65af94771c8417c87fd6cab423b82a557f60a99ae7402dba205e05136dd34f0026fce87899d4b9819cc2b2ba686512d62c41a1e3a667a705ea45404aafa489cd7f53f42455fff3f9b22f960d12a2587efd6ed0fa3e00dd4645face1b2f1268e6019be70999eab00f0aeff3cb0e77b7c4a1ab1fdf15d00c4eedd7b75e8cf5c90119346894089ee0299d58f1d7ebac9b592da2325a5a738ea2baecc1468670f5aec880bce32efecfb2a7c5ad3ae4096b0a07aa9bfe6cbaf53da6757377bb692e55ec8caf5f0af28dafdc42e1d6e5893140945a853f56652c575b99d64399aad2d042948575134c8fe638fb0b80ac3a0f08a60f3aa817fe0a24c1fffee6933bd72ea460e0b241d3f5d98b2321ee25d8c0302353fcfd41bce964d73ff670422864506cc56f3470362c90144586ccbfc8e5e6fefbb70429b0a517e4b1badb449cd11092790aba6e19b914899872f4fb481c8dc47a33422fc05072ac99c958e40dae53d96ebd87cfbde67a0f050203a89e487da5e03364951830e43771d36abfbe8f5a7da8e7aa891f36a68dbe9a3b0e3dfbd1afd6327a3ced4a5cd8a5b256fef46d200df4af2e2da4dbb786ea0404bb968b6d961e4fc76f89e70ad7c9e11d6aee6526b75b399811f73c053a29582ba9295ea4d5a8fffb5a8ccbac008d291dd60e2041371acfc4c432a0ae0fcd8fa25c9551123c95da64caa134edaee5893e19c3c76075bef419c09681a67f4ede6f28d747b53afd61ddc937d7de96a22c7db10ad8700cade888de5d6f450c15d796978ddb5e6a52e5044e90247c988686d992105c85f6d198e2de859330f973ded4d7e5d90de57051dbaf0db0febd4cf9d44da155e55293b0930f89c1d21cc227eba9615ca47cce41d16eaddb5bf5dc9bc8477df5cf21f460b83241e7d0fa3707f9d2b322b9aaa42747d0653168b095ca0a83f38426688f6f10143cbd1b84c08583b09ed6192c7366ecc23af528fc2e8c585560f9bd0fcc255b82fc70723a92506bb475ebc1f5ae34a902bf2aa75997ed90a54762c8e83720833b2fd607eee1beb347a75d3bd0f174ed450a72cce79f1be426de9d6f1a6feff052674af141b3cea89f8e749118392e9533c62ddad870e60d509fd7abfa0bc33c2774b29a0170089b30d82047d6e130c49f6965f9871d1928b7f13e3e40ad8e3dc85195f4b312f9f6d8e4158aca23a611f6c6c798983555139942536f6ac59bbd6cc88b9933f22e81429e835bfd4fec27c67520d64a0ad8fd7feb6a3fbe52dc56cbbf59644b0fad0c462ed02ffbf7258e4b94bdedefb187fbdb729a0d56a36e876ac76de766eed416f39ab4e8b1982b8d0a87cd33182ae81ecf1d1d5202cc3e82c5762646d15db5f13cde3e81c83715195f9af9f27e01e1829ce529fa0f715db1f5d227bb201c7c127ea8d0e9c21739c7e9c6a0d8d5a1aaea5216c549f3715f889e583555ac1bfd77339f3eff1bee75ee2fc45457f5c3ffe9401b8b67f5bb3f305f3269fe6153ba34de3fa90016c76811cd54b4b49b17b244b1a4f6edfa2eaf46e2819aded26005b4ed712e8b700ae7b6123fa2c179640ee523f864360d116ee243f13c66d2cd61d422709648d905ab17edf0d0075d2fed443889e15344069b69b2d3d8273f197f8468baf167074bf6dfdeea5871f0c0652ab2801f394ef6fbf841e8072c8bf65026d85d441ca61e78785a2e7ca1e743640fecd6dfad8b77adcbb8bcb8ce8532ad0cd8b3e51269c26ad037545273f756c1a5511925408a5045af469ca947f9a3f5457bcc325d05291a192abe75b4da7c97a61adc2fa247984edb5a03285f1c3b99f13f6a22f007029faffdd38b62f7bf909ce602e4e06ab1ec4543013d354d0dd86d8933a53c17ead02faf0cc740d7191fe475be2f7940c234f8c73420774a7213fd2a477847527172c02a54928de5fde5f15616760e6f7ff3c03a233aec880a939d9f1ca68be7f474fd13184fe8f6deb0c4ea01617ea207d5d765d067fddba58b94f3b59d5996e9f5434f483e2f0079c48050f3ba941b589294c41a0f350451d566fe58a9c9688cc3a75da314ff4b3473eeac58664c5922ae4efae850fe0f7f11dcc089bc0b4df9a64547a35b2559f4a4a3e7d3782d850997baa589534921becde8dc3f76380ae36bd9730956aae9f59b121d8ae4dbbc586c6b45ad9d5c17cf6821b746177bc9fcb727db3f4aa190688c48826421de5ebcd429e0d9b479e66e676e8f9a3b4bd92621f47357a7b1b27942121f5a6e0087e4192a5f8cf4da942cc9d86eac5e",
            context:    "some context info",
            plaintext:  "08b8b2b733424243760fe426a4b54908632110a66c2f6591eabd3345e3e4eb98fa6e264bf09efe12ee50f8f54e9f77b1e355f6c50544e23fb1433ddf73be84d879de7c0046dc4996d9e773f4bc9efe5738829adb26c81b37c93a1b270b20329d658675fc6ea534e0810a4432826bf58c941efb65d57a338bbd2e26640f89ffbc1a858efcb8550ee3a5e1998bd177e93a7363c344fe6b199ee5d02e82d522c4feba15452f80288a821a579116ec6dad2b3b310da903401aa62100ab5d1a36553e06203b33890cc9b832f79ef80560ccb9a39ce767967ed628c6ad573cb116dbefefd75499da96bd68a8a97b928a8bbc103b6621fcde2beca1231d206be6cd9ec7aff6f6c94fcd7204ed3455c68c83f4a41da4af2b74ef5c53f1d8ac70bdcb7ed185ce81bd84359d44254d95629e9855a94a7c1958d1f8ada5d0532ed8a5aa3fb2d17ba70eb6248e594e1a2297acbbb39d502f1a8c6eb6f1ce22b3de1a1f40cc24554119a831a9aad6079cad88425de6bde1a9187ebb6092cf67bf2b13fd65f27088d78b7e883c8759d2c4f5c65adb7553878ad575f9fad878e80a0c9ba63bcbcc2732e69485bbc9c90bfbd62481d9089beccf80cfe2df16a2cf65bd92dd597b0707e0917af48bbb75fed413d238f5555a7a569d80c3414a8d0859dc65a46128bab27af87a71314f318c782b23ebfe808b82b0ce26401d2e22f04d83d1255dc51addd3b75a2b1ae0784504df543af8969be3ea7082ff7fc9888c144da2af58429ec96031dbcad3dad9af0dcbaaaf268cb8fcffead94f3c7ca495e056a9b47acdb751fb73e666c6c655ade8297297d07ad1ba5e43f1bca32301651339e22904cc8c42f58c30c04aafdb038dda0847dd988dcda6f3bfd15c4b4c4525004aa06eeff8ca61783aacec57fb3d1f92b0fe2fd1a85f6724517b65e614ad6808d6f6ee34dff7310fdc82aebfd904b01e1dc54b2927094b2db68d6f903b68401adebf5a7e08d78ff4ef5d63653a65040cf9bfd4aca7984a74d37145986780fc0b16ac451649de6188a7dbdf191f64b5fc5e2ab47b57f7f7276cd419c17a3ca8e1b939ae49e488acba6b965610b5480109c8b17b80e1b7b750dfc7598d5d5011fd2dcc5600a32ef5b52a1ecc820e308aa342721aac0943bf6686b64b2579376504ccc493d97e6aed3fb0f9cd71a43dd497f01f17c0e2cb3797aa2a2f256656168e6c496afc5fb93246f6b1116398a346f1a641f3b041e989f7914f90cc2c7fff357876e506b50d334ba77c225bc307ba537152f3f1610e4eafe595f6d9d90d11faa933a15ef1369546868a7f3a45a96768d40fd9d03412c091c6315cf4fde7cb68606937380db2eaaa707b4c4185c32eddcdd306705e4dc1ffc872eeee475a64dfac86aba41c0618983f8741c5ef68d3a101e8a3b8cac60c905c15fc910840b94c00a0b9d0",
        },
    ];
    for tv in test_vectors {
        let key = hex::decode(&tv.key).unwrap();
        let ct = hex::decode(&tv.ciphertext).unwrap();
        let ctx = tv.context.as_bytes();
        let pt = tv.plaintext.as_bytes();

        let curve = EllipticCurveType::NistP256;
        let pvt = tink_hybrid::subtle::EcPrivateKey::new(curve, &key).unwrap();
        let salt = Vec::new();
        let helper = tink_hybrid::EciesAeadHkdfDemHelper::new(&tink_daead::aes_siv_key_template())
            .expect("error generating a DEM helper");
        let d = tink_hybrid::subtle::EciesAeadHkdfHybridDecrypt::new(
            pvt,
            &salt,
            HashType::Sha256,
            EcPointFormat::Uncompressed,
            helper,
        )
        .expect("error generating an decryption construct");
        let dt = d.decrypt(&ct, ctx).expect("decryption error");
        assert_eq!(
            dt, pt,
            "{}: Decryption did not match test vector's plaintext",
            tv.name
        );
    }
}
```


Overlapping Code:
```
1b11f8c9bafe30ae13f8bd15528714e752631a4328bf1460092a964e66e7b0cb44cff1673df9e2c793f1477ca755807bfbea0dfa9beeee32d30bdc00a1eb1d8b0cbcedbe50b1e24619cc5ec93ed50ed4d3e9fd5af760283fd38080b58744b73212a36039f22f16b41e68eadf0b6b3a48c67b9e7e3ec1c66eecce50dda8543c217ee0b6ad05f0e3ffb92943d308c801b25efedab5bf93
```
<Overlap Ratio: 0.13686131386861314>

---

--- 166 --
Question ID: 2add226a65dc233e101f8feeabc98631aa02828b_2
Original Code:
```
fn test_bert_tokenizer_no_lower_casing() {
        //        Given
        let vocab = generate_test_vocab();
        let bert_tokenizer: BertTokenizer = BertTokenizer::from_existing_vocab(vocab, false, false);
        let test_tuples = [
            ("Hello [MASK] world!", vec!["[UNK]", "[MASK]", "world", "!"]),
            (
                "Hello, unaffable world!",
                vec!["[UNK]", "[UNK]", "una", "##ffa", "##ble", "world", "!"],
            ),
            (
                "[UNK]中华人民共和国 [PAD] asdf",
                vec![
                    "[UNK]", "中", "华", "人", "[UNK]", "[UNK]", "[UNK]", "[UNK]", "[PAD]", "[UNK]",
                ],
            ),
        ];
        let source_texts: Vec<&str> = test_tuples.iter().map(|v| v.0).collect();
        let expected_results: Vec<Vec<&str>> = test_tuples.iter().map(|v| v.1.clone()).collect();

        //        When & Then
        for (source_text, expected_result) in test_tuples.iter() {
            assert_eq!(bert_tokenizer.tokenize(*source_text), *expected_result);
        }

        assert_eq!(
            Tokenizer::tokenize_list(&bert_tokenizer, &source_texts),
            expected_results
        );
        assert_eq!(
            MultiThreadedTokenizer::tokenize_list(&bert_tokenizer, &source_texts),
            expected_results
        );
    }
```


Overlapping Code:
```
() {
// Given
let vocab = generate_test_vocab();
let bert_tokenizer: BertTokenizer = BertTokenizer::from_existing_vocab(vocab, false, false);
let test_tuples = [
("Hello [MASK] world!", vec!["[UNK]", "[MASK]", "world", "!"]),
(
"Hello, unaffable world!",
vec!["[UNK]", "[UNK]", "una", "##ffa", "##ble", "world", "!"],
),
(
"[UNK]中华人民共和国 [PAD] asdf",
vec![
"[UNK]", "中", "华", "人", "[UNK]", "[UNK]", "[UNK]", "[UNK]", "[PAD]", "[UNK]",
],
),
];
let source_texts: Vec<&str> = test_tuples.iter().map(|v| v.0).collect();
let expected_results: Vec<Vec<&str>> = test_tuples.iter().map(|v| v.1.clone()).collect();
// When & Then
for (source_text, expected_result) in test_tuples.iter() {
assert_eq!(bert_tokenizer.tokenize(*source_text), *expected_result);
}
assert_eq!(
Tokenizer::tokenize_list(&bert_tokenizer, &source_texts),
expected_results
);
assert_eq!(
MultiThreadedTokenizer::tokenize_list(&bert_tokenizer, &so
```
<Overlap Ratio: 0.9267548321464903>

---

--- 167 --
Question ID: 39f80b5501609cc74772384959a1c94bee60e925_0
Original Code:
```
pub fn lower_cfg(
    bump: &Bump,
    b: &mut FunctionBuilder,
    pat: &PatternContainer,
    provider: &ErlangPatternProvider,
    cfg: &PatternCfg<ErlangPatternProvider>,
    clauses: &[PatternClause],
    destinations: &DecisionTreeDestinations,
) -> Block {
    assert!(destinations.guards.len() == destinations.bodies.len());

    let entry_kind = &cfg.graph[cfg.entry];
    assert!(*entry_kind == CfgNodeKind::Root);

    let mut ctx = LowerCtx {
        provider,
        mapping: BFnvHashMap::with_hasher_in(Default::default(), &bump),
        destinations,
    };

    let entry_block = b.block_insert();
    let entry_arg = b.block_arg_insert(entry_block);

    let mut block = entry_block;

    // First node is a dummy root node
    let value_list_node = {
        let mut edges = cfg.graph.edges(cfg.entry);
        let edge = edges.next().unwrap();
        assert!(edges.next().is_none());

        let edge_weight = edge.weight();
        assert!(edge_weight.kind == Some(NodeKind::Wildcard));
        assert!(edge_weight.variable_binds.len() == 1);

        ctx.bind(edge_weight.variable_binds[0], entry_arg);

        edge.target()
    };

    let outgoing: Vec<_> = cfg.graph.edges(value_list_node).collect();
    if outgoing.len() == 2 {
        // This will always be a ValueList and a Wildcard
        let val_list_target = outgoing
            .iter()
            .find(|o| o.weight().kind == Some(NodeKind::ValueList))
            .unwrap();
        assert!(outgoing
            .iter()
            .find(|o| o.weight().kind == Some(NodeKind::Wildcard))
            .is_some());

        if let CfgNodeKind::Match(var) = cfg.graph[value_list_node] {
            let var_list_len = val_list_target.weight().variable_binds.len();
            block = b.op_unpack_value_list(block, ctx.get_var_value(var), var_list_len);
        } else {
            unreachable!()
        }

        // Insert variable binds for all value list elements
        for (idx, var) in val_list_target.weight().variable_binds.iter().enumerate() {
            let val = b.fun().block_args(block)[idx];
            ctx.bind(*var, val);
        }

        lower_cfg_rec(
            bump,
            b,
            pat,
            &mut ctx,
            cfg,
            clauses,
            block,
            val_list_target.target(),
        );
    } else if outgoing.len() == 0 {
        // Fail immediately
        b.op_call_flow(block, destinations.fail, &[]);
    } else {
        unreachable!();
    }

    entry_block
}
```


Overlapping Code:
```
p,
b: &mut FunctionBuilder,
pat: &PatternContainer,
provider: &ErlangPatternProvider,
cfg: &PatternCfg<ErlangPatternProvider>,
clauses: &[PatternClause],
destinations: &DecisionTreeDestinations,
) -> Block {
assert!(destinations.guards.len() == destinations.bodies.len());
let entry_kind = &cfg.graph[cfg.entry];
assert!(*entry_kind == CfgNodeKind::Root);
let mut ctx = LowerCtx {
provider,
mapping: BFnvHashMap::with_hasher_in(Default::default(), &bump),
destinations,
};
let entry_block = b.block_insert();
let entry_arg = b.block_arg_insert(entry_block);
let mut block = entry_block;
// First node is a dummy root node
let value_list_node = {
let mut edges = cfg.graph.edges(cfg.entry);
let edge = edges.next().unwrap();
assert!(edges.next().is_none());
let edge_weight = edge.weight();
assert!(edge_weight.kind == Some(NodeKind::Wildcard));
assert!(edge_weight.variable_binds.len() == 1);
ctx.bind(edge_weight.variable_binds[0], entry_arg);
edge.target()
};
let outgoing: Vec<_> = cfg.graph.edges(value_list_node).collect();
if outgoing.len() == 2 {
// This will always be a ValueList and a Wildcard
let val_list_target = outgoing
.iter()
.find(|o| o.weight().kind == Some(NodeKind::ValueList))
.unwrap();
assert!(outgoing
.iter()
.find(|o| o.weight().kind == Some(NodeKind::Wildcard))
.is_some());
if let CfgNodeKind::Match(var) = cfg.graph[value_list_node] {
let var_list_len = val_list_target.weight().variable_binds.len();
block = b.op_unpack_value_list(block, ctx.get_var_value(var), var_list_len);
} else {
unreachable!()
}
// Insert variable binds for all value list elements
for (idx, var) in val_list_target.weight().variable_binds.iter().enumerate() {
let val = b.fun().block_args(block)[idx];
ctx.bind(*var, val);
}
lower_cfg_rec(
bump,
b,
pat,
&mut ctx,
cfg,
clauses,
block,
val_list_target.target(),
);
} else if outgoing.len() == 0 {
// Fail immediately
b.op_call_flow(block, destin
```
<Overlap Ratio: 0.9639776763064434>

---

--- 168 --
Question ID: 50e37a221451a6e4926acb115f4082c5afea99b0_4
Original Code:
```
fn test_add_offset() {
        let q1 = UnitQuaternion::from_quaternion(Quaternion::new(
            4.329780281177467e-17,
            0.7071067811865476,
            4.329780281177466e-17,
            0.7071067811865475,
        ));
        let t = Translation3::new(0.2, 1.4, 2.);
        let mut position = Isometry3::from_parts(t, q1);
        apply_grip_offset(&mut position);

        let expected_rotation = Quaternion::new(
            -0.5493369162990798,
            -0.4188107240790279,
            0.6209124327141259,
            -0.3705324286596844,
        );
        let expected_translation = Translation3::new(0.2, 1.328827, 2.066082);

        approx::assert_relative_eq!(position.rotation.quaternion(), &expected_rotation);
        approx::assert_relative_eq!(position.translation, &expected_translation);
    }
```


Overlapping Code:
```
) {
let q1 = UnitQuaternion::from_quaternion(Quaternion::new(
4.329780281177467e-17,
0.7071067811865476,
4.329780281177466e-17,
0.7071067811865475,
));
let t = Translation3::new(0.2, 1.4, 2.);
let mut position = Isometry3::from_parts(t, q1);
apply_grip_offset(&mut position);
let expected_rotation = Quaternion::new(
-0.5493369162990798,
-0.4188107240790279,
0.6209124327141259,
-0.3705324286596844,
);
let expected_translation = Translation3::new(0.2, 1.328827, 2.066082);
approx::assert_relative_eq!(position.rotation.quaternion(), &expected_rotation);
approx::assert_relative_eq!(position.translation, &exp
```
<Overlap Ratio: 0.938366718027735>

---

--- 169 --
Question ID: 215c9a8a58f67f74eb17900120110f25c10d05a7_0
Original Code:
```
pub fn trimesh_area_and_center_of_mass(
    vertices: &[Point<Real>],
    indices: &[[u32; 3]],
) -> (Real, Point<Real>) {
    let mut res = Point::origin();
    let mut areasum = 0.0;

    for idx in indices {
        let triangle = Triangle::new(
            vertices[idx[0] as usize],
            vertices[idx[1] as usize],
            vertices[idx[2] as usize],
        );
        let area = triangle.area();
        let center = triangle.center();

        res += center.coords * area;
        areasum += area;
    }

    if areasum == 0.0 {
        (areasum, res)
    } else {
        (areasum, res / areasum)
    }
}
```


Overlapping Code:
```
trimesh_area_and_center_of_mass(
vertices: &[Point<Real>],
indices: &[[u32; 3]],
) -> (Real, Point<Real>) {
let mut res = Point::origin();
let mut areasum = 0.0;
for idx in indices {
let triangle = Triangle::new(
vertices[idx[0] as usize],
vertices[idx[1] as usize],
vertices[idx[2] as usize],
);
let area = triangle.area();
let center = triangle.center();
res += center.coords * area;
areasum += area;
}
if areasum == 0.0 {
(areasum, res)
} else {
(
```
<Overlap Ratio: 0.9297520661157025>

---

--- 170 --
Question ID: 4a9b1cafa156bde7c7ec9cf6f72803c89a3744b4_0
Original Code:
```
fn main() {

	// variable of circle datatype
	let mut circle1 = Circle {
		r : 10.0
	};
	println!("Area of circle {}", circle1.area() );
	
	// variable of rectangle datatype
	let mut rect = Rectangle {
		h:10.0,b : 10.0
	};
	println!("Area of rectangle {}", rect.area() );
}
```


Overlapping Code:
```
t mut circle1 = Circle {
r : 10.0
};
println!("Area of circle {}", circle1.area() );

// variable of rectangle datatype
let mut rect = Rectangle {
h:10.0,b : 10.0
};
println!("Area of rectangle {}", r
```
<Overlap Ratio: 0.7692307692307693>

---

--- 171 --
Question ID: 31562cb189e7b55343443e0c48d47187ea7d4bf2_2
Original Code:
```
fn get_thread_with_perms() -> impl thorn::AnyQuery {
    use schema::*;
    use thorn::*;

    tables! {
        struct AggPerm {
            Perms: AggRoomPerms::Perms,
        }
    }

    const READ_MESSAGES: i64 = Permission::PACKED_READ_MESSAGE_HISTORY as i64;

    let user_id_var = Var::at(Users::Id, 1);
    let room_id_var = Var::at(Rooms::Id, 2);
    let thread_id_var = Var::at(Threads::Id, 3);

    let permissions = AggPerm::as_query(
        Query::select()
            .expr(AggRoomPerms::Perms.alias_to(AggPerm::Perms))
            .from_table::<AggRoomPerms>()
            .and_where(AggRoomPerms::UserId.equals(user_id_var.clone()))
            .and_where(AggRoomPerms::RoomId.equals(room_id_var.clone())),
    );

    Query::with()
        .with(permissions)
        .select()
        .from(Threads::inner_join_table::<AggMessages>().on(AggMessages::MsgId.equals(Threads::ParentId)))
        .and_where(Threads::Id.equals(thread_id_var))
        .and_where(
            AggPerm::Perms
                .bit_and(READ_MESSAGES.lit())
                .equals(READ_MESSAGES.lit()),
        )
        .cols(Columns::default())
        .cols(ThreadColumns::default())
}
```


Overlapping Code:
```
 impl thorn::AnyQuery {
use schema::*;
use thorn::*;
tables! {
struct AggPerm {
Perms: AggRoomPerms::Perms,
}
}
const READ_MESSAGES: i64 = Permission::PACKED_READ_MESSAGE_HISTORY as i64;
let user_id_var = Var::at(Users::Id, 1);
let room_id_var = Var::at(Rooms::Id, 2);
let thread_id_var = Var::at(Threads::Id, 3);
let permissions = AggPerm::as_query(
Query::select()
.expr(AggRoomPerms::Perms.alias_to(AggPerm::Perms))
.from_table::<AggRoomPerms>()
.and_where(AggRoomPerms::UserId.equals(user_id_var.clone()))
.and_where(AggRoomPerms::RoomId.equals(room_id_var.clone())),
);
Query::with()
.with(permissions)
.select()
.from(Threads::inner_join_table::<AggMessages>().on(AggMessages::MsgId.equals(Threads::ParentId)))
.and_where(Threads::Id.equals(thread_id_var))
.and_where(
AggPerm::Perms
.bit_and(READ_MESSAGES.lit())
.equals(READ_MESSAGES.lit()),
)
.cols(Columns::default())
.cols(ThreadColumns::default())
}
```
<Overlap Ratio: 0.9691489361702128>

---

--- 172 --
Question ID: e670de2d08f3b83fd72dff6f44c4be4280c285b4_3
Original Code:
```
async fn get_contracts() -> (
    AuthContract,
    ContractId,
    AuthCallerContract,
    ContractId,
    Wallet,
) {
    let salt = Salt::from([0u8; 32]);
    let (provider, wallet) = setup_test_provider_and_wallet().await;
    let compiled_1 = Contract::load_sway_contract(
        "test_artifacts/auth_testing_contract/out/debug/auth_testing_contract.bin",
        salt,
    )
    .unwrap();
    let compiled_2 = Contract::load_sway_contract(
        "test_artifacts/auth_caller_contract/out/debug/auth_caller_contract.bin",
        salt,
    )
    .unwrap();

    let id_1 = Contract::deploy(&compiled_1, &provider, &wallet, TxParameters::default())
        .await
        .unwrap();
    let id_2 = Contract::deploy(&compiled_2, &provider, &wallet, TxParameters::default())
        .await
        .unwrap();

    let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());
    let instance_2 = AuthCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());

    (instance_1, id_1, instance_2, id_2, wallet)
}
```


Overlapping Code:
```
-> (
AuthContract,
ContractId,
AuthCallerContract,
ContractId,
Wallet,
) {
let salt = Salt::from([0u8; 32]);
let (provider, wallet) = setup_test_provider_and_wallet().await;
let compiled_1 = Contract::load_sway_contract(
"test_artifacts/auth_testing_contract/out/debug/auth_testing_contract.bin",
salt,
)
.unwrap();
let compiled_2 = Contract::load_sway_contract(
"test_artifacts/auth_caller_contract/out/debug/auth_caller_contract.bin",
salt,
)
.unwrap();
let id_1 = Contract::deploy(&compiled_1, &provider, &wallet, TxParameters::default())
.await
.unwrap();
let id_2 = Contract::deploy(&compiled_2, &provider, &wallet, TxParameters::default())
.await
.unwrap();
let instance_1 = AuthContract::new(id_1.to_string(), provider.clone(), wallet.clone());
let instance_2 = AuthCallerContract::new(id_2.to_string(), provider.clone(), wallet.clone());
(instance_1, id_1, instan
```
<Overlap Ratio: 0.9498364231188658>

---

--- 173 --
Question ID: d4c044b4464d1846dd4a853c231d2edd55e48d41_0
Original Code:
```
fn encode_bit_pattern_examples() {
        assert_eq!(encode(0x0f0f).as_ref(), &[0x9E, 0x78]);
        assert_eq!(
            encode(0x0f0f_f0f0).as_ref(),
            &[0xF0, 0x3C, 0xFC, 0xC3, 0x03]
        );
        assert_eq!(
            encode(0x0f0f_f0f0_0f0f).as_ref(),
            &[0xFC, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]
        );
        assert_eq!(
            encode(0x0f0f_f0f0_0f0f_f0f0).as_ref(),
            &[0xFF, 0xE0, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]
        );
        //
        assert_eq!(encode(-0x0f0f).as_ref(), &[0x9D, 0x78]);
        assert_eq!(
            encode(-0x0f0f_f0f0).as_ref(),
            &[0xF7, 0x3B, 0xFC, 0xC3, 0x03]
        );
        assert_eq!(
            encode(-0x0f0f_f0f0_0f0f).as_ref(),
            &[0xFD, 0x0E, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]
        );
        assert_eq!(
            encode(-0x0f0f_f0f0_0f0f_f0f0).as_ref(),
            &[0xFF, 0xDF, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]
        );
    }
```


Overlapping Code:
```
ssert_eq!(encode(0x0f0f).as_ref(), &[0x9E, 0x78]);
assert_eq!(
encode(0x0f0f_f0f0).as_ref(),
&[0xF0, 0x3C, 0xFC, 0xC3, 0x03]
);
assert_eq!(
encode(0x0f0f_f0f0_0f0f).as_ref(),
&[0xFC, 0x0F, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]
);
assert_eq!(
encode(0x0f0f_f0f0_0f0f_f0f0).as_ref(),
&[0xFF, 0xE0, 0xE1, 0x1F, 0x1E, 0xE0, 0xE1, 0x1F, 0x1E]
);
//
assert_eq!(encode(-0x0f0f).as_ref(), &[0x9D, 0x78]);
assert_eq!(
encode(-0x0f0f_f0f0).as_ref(),
&[0xF7, 0x3B, 0xFC, 0xC3, 0x03]
);
assert_eq!(
encode(-0x0f0f_f0f0_0f0f).as_ref(),
&[0xFD, 0x0E, 0x0F, 0xF0, 0xF0, 0x0F, 0x0F]
);
assert_eq!(
encode(-0x0f0f_f0f0_0f0f_f0f0).as_ref(),
&[0xFF, 0xDF, 0xE1, 0x1F, 0x1E, 0xE
```
<Overlap Ratio: 0.9142053445850914>

---

--- 174 --
Question ID: 42999a743bbd29d266cf2f0faadc5ca8c4cb64c3_31
Original Code:
```
async fn csv_query_array_agg() -> Result<()> {
    let ctx = SessionContext::new();
    register_aggregate_csv(&ctx).await?;
    let sql =
        "SELECT array_agg(c13) FROM (SELECT * FROM aggregate_test_100 ORDER BY c13 LIMIT 2) test";
    let actual = execute_to_batches(&ctx, sql).await;
    let expected = vec![
        "+------------------------------------------------------------------+",
        "| ARRAYAGG(test.c13)                                               |",
        "+------------------------------------------------------------------+",
        "| [0VVIHzxWtNOFLtnhjHEKjXaJOSLJfm, 0keZ5G8BffGwgF2RwQD59TFzMStxCB] |",
        "+------------------------------------------------------------------+",
    ];
    assert_batches_eq!(expected, &actual);
    Ok(())
}
```


Overlapping Code:
```
() -> Result<()> {
let ctx = SessionContext::new();
register_aggregate_csv(&ctx).await?;
let sql =
"SELECT array_agg(c13) FROM (SELECT * FROM aggregate_test_100 ORDER BY c13 LIMIT 2) test";
let actual = execute_to_batches(&ctx, sql).await;
let expected = vec![
"+------------------------------------------------------------------+",
"| ARRAYAGG(test.c13) |",
"+------------------------------------------------------------------+",
"| [0VVIHzxWtNOFLtnhjHEKjXaJOSLJfm, 0keZ5G8BffGwgF2RwQD59TFzMStxCB] |",
"+------------------------------------------------------------------+",
];
assert_batches_eq!(expected, &actual);
Ok(())
}
```
<Overlap Ratio: 0.9571209800918836>

---

--- 175 --
Question ID: 64943b3932802d1853e022c982a43a407ff22fd4_0
Original Code:
```
pub fn verify_authorization(pub_key: String, sign: String, message: String) -> bool {
    let public_key = hex::decode(pub_key);
    if public_key.is_err() {
        error!("err -> Err: public_key_decode");
        return false;
    }
    let hex_signature = hex::decode(sign);
    if hex_signature.is_err() {
        error!("err -> Err: hex_signature");
        return false;
    }
    let public_key = PublicKey::from_bytes(&public_key.unwrap().clone());
    if public_key.is_err() {
        error!("err -> Err: public_key");
        return false;
    }
    let signature = ed25519_dalek::Signature::from_bytes(&hex_signature.unwrap());
    if signature.is_err() {
        // eprintln!("err -> Err: signature");
        return false;
    }
    let ok = public_key
        .unwrap()
        .verify(message.as_bytes(), &signature.unwrap());
    if ok.is_err() {
        return false;
    }
    return true;
}
```


Overlapping Code:
```
 sign: String, message: String) -> bool {
let public_key = hex::decode(pub_key);
if public_key.is_err() {
error!("err -> Err: public_key_decode");
return false;
}
let hex_signature = hex::decode(sign);
if hex_signature.is_err() {
error!("err -> Err: hex_signature");
return false;
}
let public_key = PublicKey::from_bytes(&public_key.unwrap().clone());
if public_key.is_err() {
error!("err -> Err: public_key");
return false;
}
let signature = ed25519_dalek::Signature::from_bytes(&hex_signature.unwrap());
if signature.is_err() {
// eprintln!("err -> Err: signature");
return false;
}
let ok = public_key
.unwrap()
.verify(message.as_bytes(), &signature.unwrap());
if ok.is_err() {
return false;
}
r
```
<Overlap Ratio: 0.9247027741083224>

---

--- 176 --
Question ID: 9858de99ea2d9db0765d2e755fc1a81a5935c68e_0
Original Code:
```
fn get_containers(pod: &KubernetesPod) -> Vec<Container> {
  let mut ret = Vec::new();

  let pod_name = pod.metadata.name.clone();
  let siblings = pod.spec.containers.len();
  for container in &pod.spec.containers {
    ret.push(Container::new(
      pod_name.clone(), container.name.clone(),
      siblings
    ));
  }

  ret
}
```


Overlapping Code:
```
ers(pod: &KubernetesPod) -> Vec<Container> {
let mut ret = Vec::new();
let pod_name = pod.metadata.name.clone();
let siblings = pod.spec.containers.len();
for container in &pod.spec.containers {
ret.push(Container::new(
pod_name.clone(), container.na
```
<Overlap Ratio: 0.8445945945945946>

---

--- 177 --
Question ID: 58855566eae511b01b128211127672883dd1eba8_1
Original Code:
```
fn huffman_decode<R: Read>(
    reader: &mut BitReader<R, BigEndian>,
    huffman_table: &HuffmanTable,
    state: &mut HuffmanState,
) -> Result<usize, Error> {
    let mut point = 0;
    let mut bits_left = 32;
    let mut bits_read = 0;
    if !huffman_table.data.is_empty() {
        loop {
            if huffman_table.data[point] & 0xff00 == 0 {
                state.x = ((huffman_table.data[point] >> 4) & 0xf).into();
                state.y = (huffman_table.data[point] & 0xf).into();
                break;
            }

            bits_read += 1;
            if reader.read_bit()? {
                while (huffman_table.data[point] & 0xff) >= 250 {
                    point += (huffman_table.data[point] & 0xff) as usize;
                }
                point += (huffman_table.data[point] & 0xff) as usize;
            } else {
                while (huffman_table.data[point] >> 8) >= 250 {
                    point += (huffman_table.data[point] >> 8) as usize;
                }
                point += (huffman_table.data[point] >> 8) as usize;
            }

            bits_left -= 1;
            if bits_left <= 0 || point >= huffman_table.data.len() {
                break;
            }
        }

        if huffman_table.quads {
            state.v = (state.y >> 3) & 1;
            state.w = (state.y >> 2) & 1;
            state.x = (state.y >> 1) & 1;
            state.y &= 1;

            if state.v > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.v = -state.v;
                }
            }
            if state.w > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.w = -state.w;
                }
            }
            if state.x > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.x = -state.x;
                }
            }
            if state.y > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.y = -state.y;
                }
            }
        } else {
            if huffman_table.linbits > 0 && state.x == 15 {
                bits_read += huffman_table.linbits;
                // TODO(Herschel): u32?
                state.x += reader.read::<u32>(huffman_table.linbits as u32)? as i32;
            }

            if state.x > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.x = -state.x;
                }
            }

            if huffman_table.linbits > 0 && state.y == 15 {
                bits_read += huffman_table.linbits;
                state.y += reader.read::<u32>(huffman_table.linbits as u32)? as i32;
            }

            if state.y > 0 {
                bits_read += 1;
                if reader.read_bit()? {
                    state.y = -state.y;
                }
            }
        }
    } else {
        *state = Default::default();
    }
    Ok(bits_read)
}
```


Overlapping Code:
```
 BitReader<R, BigEndian>,
huffman_table: &HuffmanTable,
state: &mut HuffmanState,
) -> Result<usize, Error> {
let mut point = 0;
let mut bits_left = 32;
let mut bits_read = 0;
if !huffman_table.data.is_empty() {
loop {
if huffman_table.data[point] & 0xff00 == 0 {
state.x = ((huffman_table.data[point] >> 4) & 0xf).into();
state.y = (huffman_table.data[point] & 0xf).into();
break;
}
bits_read += 1;
if reader.read_bit()? {
while (huffman_table.data[point] & 0xff) >= 250 {
point += (huffman_table.data[point] & 0xff) as usize;
}
point += (huffman_table.data[point] & 0xff) as usize;
} else {
while (huffman_table.data[point] >> 8) >= 250 {
point += (huffman_table.data[point] >> 8) as usize;
}
point += (huffman_table.data[point] >> 8) as usize;
}
bits_left -= 1;
if bits_left <= 0 || point >= huffman_table.data.len() {
break;
}
}
if huffman_table.quads {
state.v = (state.y >> 3) & 1;
state.w = (state.y >> 2) & 1;
state.x = (state.y >> 1) & 1;
state.y &= 1;
if state.v > 0 {
bits_read += 1;
if reader.read_bit()? {
state.v = -state.v;
}
}
if state.w > 0 {
bits_read += 1;
if reader.read_bit()? {
state.w = -state.w;
}
}
if state.x > 0 {
bits_read += 1;
if reader.read_bit()? {
state.x = -state.x;
}
}
if state.y > 0 {
bits_read += 1;
if reader.read_bit()? {
state.y = -state.y;
}
}
} else {
if huffman_table.linbits > 0 && state.x == 15 {
bits_read += huffman_table.linbits;
// TODO(Herschel): u32?
state.x += reader.read::<u32>(huffman_table.linbits as u32)? 
```
<Overlap Ratio: 0.9525048796356539>

---

--- 178 --
Question ID: 7b46989e8a44f46047cfa334ef8813c929d3a6e8_3
Original Code:
```
fn call_fetch_sidechain_blocks_from_peer(
		last_known_block_hash: H256,
		shard_identifier: H256,
		buffer: &mut Vec<u8>,
		sidechain_bridge: Arc<dyn SidechainBridge>,
	) -> sgx_status_t {
		let last_known_block_hash_encoded = last_known_block_hash.encode();
		let shard_identifier_encoded = shard_identifier.encode();

		fetch_sidechain_blocks_from_peer(
			last_known_block_hash_encoded.as_ptr(),
			last_known_block_hash_encoded.len() as u32,
			shard_identifier_encoded.as_ptr(),
			shard_identifier_encoded.len() as u32,
			buffer.as_mut_ptr(),
			buffer.len() as u32,
			sidechain_bridge,
		)
	}
```


Overlapping Code:
```
h_sidechain_blocks_from_peer(
last_known_block_hash: H256,
shard_identifier: H256,
buffer: &mut Vec<u8>,
sidechain_bridge: Arc<dyn SidechainBridge>,
) -> sgx_status_t {
let last_known_block_hash_encoded = last_known_block_hash.encode();
let shard_identifier_encoded = shard_identifier.encode();
fetch_sidechain_blocks_from_peer(
last_known_block_hash_encoded.as_ptr(),
last_known_block_hash_encoded.len() as u32,
shard_identifier_encoded.as_ptr(),
shard_identifier_encoded.len() as u32,
buffer.as_mut_ptr(),
buffer.len() as u32,
sidechain_bridge,
)
}
```
<Overlap Ratio: 0.9786476868327402>

---

--- 179 --
Question ID: 16cd6e2a6a15bffe3842c885e8f90ad2f1fe9a96_1
Original Code:
```
fn abort(
    env: &Env,
    message: AsmScriptStringPtr,
    filename: AsmScriptStringPtr,
    line: i32,
    col: i32,
) {
    let memory = env.memory.get_ref().expect("initialized memory");
    let message = message.read(memory).unwrap();
    let filename = filename.read(memory).unwrap();
    eprintln!("Error: {} at {}:{} col: {}", message, filename, line, col);
}
```


Overlapping Code:
```
Env,
message: AsmScriptStringPtr,
filename: AsmScriptStringPtr,
line: i32,
col: i32,
) {
let memory = env.memory.get_ref().expect("initialized memory");
let message = message.read(memory).unwrap();
let filename = filename.read(memory).unwrap();
eprintln!("Error: {} at {}:{} col: {}", message, filename, line, co
```
<Overlap Ratio: 0.9369369369369369>

---

--- 180 --
Question ID: bad08a39a07f57fab14230c4b1270c20a16a6a3e_1
Original Code:
```
pub async fn update(client: &Client, id: String, peer_urls: Vec<String>) -> EtcdMembersResult {
    let peer_urls = PeerUrls { peer_urls };
    let body = serde_json::to_string(&peer_urls).map_err(|e| vec![e.into()])?;

    client
        .first_ok(|client, endpoint| {
            let url = build_url(endpoint, &format!("/{}", id));
            let body = body.clone();
            async move {
                let response = client.http_client().put(url).body(body).send().await?;
                parse_empty_response(response).await
            }
        })
        .await
}
```


Overlapping Code:
```
ring, peer_urls: Vec<String>) -> EtcdMembersResult {
let peer_urls = PeerUrls { peer_urls };
let body = serde_json::to_string(&peer_urls).map_err(|e| vec![e.into()])?;
client
.first_ok(|client, endpoint| {
let url = build_url(endpoint, &format!("/{}", id));
let body = body.clone();
async move {
let response = client.http_client().put(url).body(body).send().await?;
parse_empty_response(response).await
}

```
<Overlap Ratio: 0.8826086956521739>

---

--- 181 --
Question ID: 021e43bdd08646fffd7fd93c4ef845129e3d9d32_10
Original Code:
```
fn take_boolean() -> Result<()> {
        use super::take_boolean;
        let mut bytes: &[u8] = &[0x01, 0xaf];
        assert_eq!(take_boolean(&mut bytes)?, true);
        assert_eq!(bytes, &[0xaf]);
        Ok(())
    }
```


Overlapping Code:
```
r::take_boolean;
let mut bytes: &[u8] = &[0x01, 0xaf];
assert_eq!(take_boolean(&mut bytes)?, true);

```
<Overlap Ratio: 0.5617977528089888>

---

--- 182 --
Question ID: 300db69bf5f13042adb173fa2905733b51d4a5f0_3
Original Code:
```
pub(crate) fn input_value_definition(p: &mut Parser, is_input: bool) {
    if let Some(TokenKind::Name | TokenKind::StringValue) = p.peek() {
        let guard = p.start_node(SyntaxKind::INPUT_VALUE_DEFINITION);

        if let Some(TokenKind::StringValue) = p.peek() {
            description::description(p);
        }

        name::name(p);

        if let Some(T![:]) = p.peek() {
            p.bump(S![:]);
            match p.peek() {
                Some(TokenKind::Name) | Some(T!['[']) => {
                    ty::ty(p);
                    if let Some(T![=]) = p.peek() {
                        value::default_value(p);
                    }

                    if let Some(T![@]) = p.peek() {
                        directive::directives(p);
                    }

                    if p.peek().is_some() {
                        guard.finish_node();
                        return input_value_definition(p, true);
                    }
                }
                _ => p.err("expected a Type"),
            }
        } else {
            p.err("expected a Name");
        }
    }
    // TODO @lrlna: this can be simplified a little bit, and follow the pattern of FieldDefinition
    if !is_input {
        p.err("expected an Input Value Definition");
    }
}
```


Overlapping Code:
```
fn input_value_definition(p: &mut Parser, is_input: bool) {
if let Some(TokenKind::Name | TokenKind::StringValue) = p.peek() {
let guard = p.start_node(SyntaxKind::INPUT_VALUE_DEFINITION);
if let Some(TokenKind::StringValue) = p.peek() {
description::description(p);
}
name::name(p);
if let Some(T![:]) = p.peek() {
p.bump(S![:]);
match p.peek() {
Some(TokenKind::Name) | Some(T!['[']) => {
ty::ty(p);
if let Some(T![=]) = p.peek() {
value::default_value(p);
}
if let Some(T![@]) = p.peek() {
directive::directives(p);
}
if p.peek().is_some() {
guard.finish_node();
return input_value_definition(p, true);
}
}
_ => p.err("expected a Type"),
}
} else {
p.err("expected a Name");
}
}
// TODO @lrlna: this can be simplified a little bit, and follow the pattern of FieldDefinition
if !is_input {
p.err("e
```
<Overlap Ratio: 0.9400705052878966>

---

--- 183 --
Question ID: 638731c51c5f41e412237e6d63ffc746ec7369a1_0
Original Code:
```
pub fn wlroots_dehandle(_args: TokenStream, input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as ItemFn);
    let output = Args.fold_item_fn(input);
    TokenStream::from(quote!(#output))
}
```


Overlapping Code:
```
e(_args: TokenStream, input: TokenStream) -> TokenStream {
let input = parse_macro_input!(input as ItemFn);
let output = Args.fold_item_fn(input);
TokenStream::from(quote!(#outp
```
<Overlap Ratio: 0.8634146341463415>

---

--- 184 --
Question ID: d862c6a9a02786c55e48e2a6a6f45f9c1c80b65d_1
Original Code:
```
pub fn inline_metas(mut tcs: TCS, val: ValInfo) -> ValTCM {
    use Neutral::*;
    let info = val.loc;
    let val = val.ast.try_map_neutral(&mut |neut| match neut {
        Meta(mi) => tcs
            .meta_context
            .take_meta(mi)
            .ok_or_else(|| TCE::MetaUnsolved(mi)),
        e => Ok(Val::Neut(e)),
    })?;
    Ok((val.into_info(info), tcs))
}
```


Overlapping Code:
```
ValInfo) -> ValTCM {
use Neutral::*;
let info = val.loc;
let val = val.ast.try_map_neutral(&mut |neut| match neut {
Meta(mi) => tcs
.meta_context
.take_meta(mi)
.ok_or_else(|| TCE::MetaUnsolved(mi)),
e => Ok(Val::Neut(e)),
})?;
Ok((val.into_info(info
```
<Overlap Ratio: 0.8361204013377926>

---

--- 185 --
Question ID: 75feeb57a15caec75223b753a9d57495a352e3ad_32
Original Code:
```
fn get_ddn_status_not_found_works() {
    let contract = make_contract();
    let p2p_id = String::from("test_p2p_id");

    // Should return an error if not found
    assert_eq!(contract.get_ddn_status(p2p_id), Err(Error::DDNNotFound));
}
```


Overlapping Code:
```
d_works() {
let contract = make_contract();
let p2p_id = String::from("test_p2p_id");
// Should return an error if not found
assert_eq!(contract.get_d
```
<Overlap Ratio: 0.6756756756756757>

---

--- 186 --
Question ID: 28c52a8cb860091ec0522e9d56f08e35df2004ec_0
Original Code:
```
pub fn request(endpoint : &str) -> Result<bytes::Bytes, Error> {
    
    let resp = reqwest::blocking::get(format!("https://api.dhravya.me/{}", endpoint)).unwrap();

    let status : u16 = resp.status().as_u16();

    if status == 200 {
        let bytes : bytes::Bytes = resp.bytes().unwrap();
        return Ok(bytes);
    } else {
        if status == 500 {
            return Err(Error::HTTPException("Internal Server Error".to_string()));
        } else {
            return Err(Error::HTTPException("Unknown Error".to_string()));
        }
    }
}
```


Overlapping Code:
```
 : &str) -> Result<bytes::Bytes, Error> {

let resp = reqwest::blocking::get(format!("https://api.dhravya.me/{}", endpoint)).unwrap();
let status : u16 = resp.status().as_u16();
if status == 200 {
let bytes : bytes::Bytes = resp.bytes().unwrap();
return Ok(bytes);
} else {
if status == 500 {
return Err(Error::HTTPException("Internal Server Error".to_string()));
} else {
return Err(Error::HTTPExcep
```
<Overlap Ratio: 0.8620689655172413>

---

--- 187 --
Question ID: dbfb6f95a5a3c09d2aa1f8d7c6669ef2bd25601e_7
Original Code:
```
fn read_document_nok_not_found() {

    let (_server, client) = make_server_and_client();
    client.create_database("/baseball").run().unwrap();

    match client.read_document("/baseball/babe_ruth").run() {
        Err(chill::Error::NotFound(..)) => (),
        x @ _ => unexpected_result!(x),
    }
}
```


Overlapping Code:
```
nok_not_found() {
let (_server, client) = make_server_and_client();
client.create_database("/baseball").run().unwrap();
match client.read_document("/baseball/babe_ruth").run() {
Err(chill::Error::NotFound(..)) => (),
x @ _ => unexpected_result!(x),
}
```
<Overlap Ratio: 0.929368029739777>

---

--- 188 --
Question ID: cbce4a9da80294ed41bcf44d246e24c09d0b59de_0
Original Code:
```
pub async fn load_home(client: &Client) -> Result<(Vec<Video>, Vec<Video>), reqwest::Error> {
    let trending_fut = invidious_videos(vec![], client, TRENDING_URL);
    let popular_fut = invidious_videos(vec![], client, POPULAR_URL);
    //let top_fut = home_videos(client, TOP_URL);

    futures::try_join!(trending_fut, popular_fut)//, top_fut)
}
```


Overlapping Code:
```
ult<(Vec<Video>, Vec<Video>), reqwest::Error> {
let trending_fut = invidious_videos(vec![], client, TRENDING_URL);
let popular_fut = invidious_videos(vec![], client, POPULAR_URL);
//let top_fut = home_videos(client, TOP_URL);
futures::try_join!(trend
```
<Overlap Ratio: 0.7552870090634441>

---

--- 189 --
Question ID: 54c30d3a87d97116fad54f93ec46b12a13be9dde_5
Original Code:
```
async fn integration_test_is_ready_ok_no_such_bucket() {
        // test that is_ready returns Ok even if the bucket doesn't exist
        let mut client = init_client().await;
        client
            .delete_bucket(&S3BucketsSettings::default().global_models)
            .await
            .unwrap();

        let res = client.is_ready().await;
        assert!(res.is_ok())
    }
```


Overlapping Code:
```
 fn integration_test_is_ready_ok_no_such_bucket() {
// test that is_ready returns Ok even if the bucket doesn't exist
let mut client = init_client().await;
client
.delete_bucket(&S3BucketsSettings::default().global_models)
.await
.unwrap();
let res = client.is_ready().await;
assert!(res.i
```
<Overlap Ratio: 0.9537953795379538>

---

--- 190 --
Question ID: a64e26f13048d3dae7059431e5afa22048c83b5a_1
Original Code:
```
fn it_works() {
        asdf
//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name
//      ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name
//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) cannot find value
//      ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) not found in this scope
    }
```


Overlapping Code:
```
^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name
// ^^^^ERR(<1.16.0,rust_syntax_checking_include_tests=True) unresolved name
// ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) cannot find value
// ^^^^ERR(>=1.23.0,rust_syntax_checking_include_tests=True) not found in this sc
```
<Overlap Ratio: 0.9053254437869822>

---

--- 191 --
Question ID: 5f2264d1e7609ce7a37d36c3bc1a5e67065895e5_3
Original Code:
```
pub fn rdtsc() -> u64 {
    let val_lo: u32;
    let val_hi: u32;

    unsafe {
        llvm_asm!("rdtsc" : "={edx}"(val_hi), "={eax}"(val_lo) ::
             "memory" : "volatile", "intel");
    }

    ((val_hi as u64) << 32) | val_lo as u64
}
```


Overlapping Code:
```
et val_lo: u32;
let val_hi: u32;
unsafe {
llvm_asm!("rdtsc" : "={edx}"(val_hi), "={eax}"(val_lo) ::
"memory" : "volatile", "intel");
}
((val_hi as u64) << 32) | val
```
<Overlap Ratio: 0.8159203980099502>

---

--- 192 --
Question ID: 9134b645ee85923bd63ade17cbdbd39ba6accc92_2
Original Code:
```
fn test_gaussian_filter_2d() {
    let a: Array1<f32> = (0..70).step_by(2).map(|v| v as f32).collect();
    let mut a = a.into_shape((5, 7)).unwrap();
    a[(0, 0)] = 17.0;
    assert_relative_eq!(
        gaussian_filter(&a, 1.0, 4.0),
        arr2(&[
            [13.815777, 11.339161, 10.62479, 12.028319, 13.970364, 15.842661, 17.12449],
            [19.028267, 18.574514, 19.253122, 20.97248, 22.940516, 24.813597, 26.095427],
            [29.490631, 30.42986, 32.06769, 34.004536, 35.990467, 37.864086, 39.14592],
            [41.95432, 43.209373, 45.064693, 47.050846, 49.040836, 50.914577, 52.196407],
            [50.876965, 52.158012, 54.031227, 56.02144, 58.01176, 59.885513, 61.167343],
        ]),
        epsilon = 1e-4
    );
    let a: Array1<f32> = (0..84).step_by(2).map(|v| v as f32).collect();
    let mut a = a.into_shape((6, 7)).unwrap();
    a[(0, 0)] = 8.5;
    assert_relative_eq!(
        gaussian_filter(&a, 1.0, 2.0),
        arr2(&[
            [10.078889, 9.458512, 10.006921, 11.707343, 13.707343, 15.598366, 16.892008],
            [17.220367, 17.630152, 18.90118, 20.76284, 22.76284, 24.653864, 25.947506],
            [29.114912, 30.247316, 32.025234, 34.000000, 36.000000, 37.89102, 39.184666],
            [42.815334, 44.10898, 46.000000, 48.000000, 50.000000, 51.89102, 53.184666],
            [56.052494, 57.346134, 59.23716, 61.23716, 63.23716, 65.12818, 66.42182],
            [65.107994, 66.401634, 68.292656, 70.292656, 72.292656, 74.18368, 75.47732],
        ]),
        epsilon = 1e-4
    );

    let a: Array1<f32> = (0..112).step_by(2).map(|v| v as f32).collect();
    let mut a = a.into_shape((8, 7)).unwrap();
    a[(0, 0)] = 18.2;
    assert_relative_eq!(
        gaussian_filter(&a, 1.5, 3.5),
        arr2(&[
            [16.712738, 16.30507, 16.362633, 17.34964, 18.918924, 20.453388, 21.402458],
            [22.053278, 22.092232, 22.654442, 23.931578, 25.60057, 27.156698, 28.1087],
            [31.7295, 32.2731, 33.405533, 35.01049, 36.79215, 38.372753, 39.328068],
            [44.08236, 44.91609, 46.376343, 48.169773, 50.0162, 51.61088, 52.5681],
            [57.50711, 58.440548, 60.013466, 61.87167, 63.740356, 65.339874, 66.297745],
            [70.68089, 71.636, 73.2334, 75.10567, 76.979195, 78.579765, 79.53778],
            [81.8913, 82.849335, 84.45004, 86.32423, 88.1984, 89.79911, 90.75715],
            [88.59754, 89.55557, 91.15629, 93.030464, 94.90464, 96.505356, 97.46339],
        ]),
        epsilon = 1e-4
    );
}
```


Overlapping Code:
```
f32> = (0..70).step_by(2).map(|v| v as f32).collect();
let mut a = a.into_shape((5, 7)).unwrap();
a[(0, 0)] = 17.0;
assert_relative_eq!(
gaussian_filter(&a, 1.0, 4.0),
arr2(&[
[13.815777, 11.339161, 10.62479, 12.028319, 13.970364, 15.842661, 17.12449],
[19.028267, 18.574514, 19.253122, 20.97248, 22.940516, 24.813597, 26.095427],
[29.490631, 30.42986, 32.06769, 34.004536, 35.990467, 37.864086, 39.14592],
[41.95432, 43.209373, 45.064693, 47.050846, 49.040836, 50.914577, 52.196407],
[50.876965, 52.158012, 54.031227, 56.02144, 58.01176, 59.885513, 61.167343],
]),
epsilon = 1e-4
);
let a: Array1<f32> = (0..84).step_by(2).map(|v| v as f32).collect();
let mut a = a.into_shape((6, 7)).unwrap();
a[(0, 0)] = 8.5;
assert_relative_eq!(
gaussian_filter(&a, 1.0, 2.0),
arr2(&[
[10.078889, 9.458512, 10.006921, 11.707343, 13.707343, 15.598366, 16.892008],
[17.220367, 17.630152, 18.90118, 20.76284, 22.76284, 24.653864, 25.947506],
[29.114912, 30.247316, 32.025234, 34.000000, 36.000000, 37.89102, 39.184666],
[42.815334, 44.10898, 46.000000, 48.000000, 50.000000, 51.89102, 53.184666],
[56.052494, 57.346134, 59.23716, 61.23716, 63.23716, 65.12818, 66.42182],
[65.107994, 66.401634, 68.292656, 70.292656, 72.292656, 74.18368, 75.47732],
]),
epsilon = 1e-4
);
let a: Array1<f32> = (0..112).step_by(2).map(|v| v as f32).collect();
let mut a = a.into_shape((8, 7)).unwrap();
a[(0, 0)] = 18.2;
assert_relative_eq!(
gaussian_filter(&a, 1.5, 3.5),
arr2(&[
[16.712738, 16.30507, 16.362633, 17.34964, 18.918924, 20.453388, 21.402458],
[22.053278, 22.092232, 22.654442, 23.931578, 25.60057, 27.156698, 28.1087],
[31.7295, 32.2731, 33.405533, 35.01049, 36.79215, 38.372753, 39.328068],
[44.08236, 44.91609, 46.376343, 48.169773, 50.0162, 51.61088, 52.5681],
[57.50711, 58.440548, 60.013466, 61.87167, 63.740356, 65.339874, 66.297745],
[70.68089, 71.636, 73.2334, 75.10567, 76.979195, 78.579765, 79.53778],
[81.8913, 82.849335, 84.45004, 86.32423, 88.1984, 89.79911, 90.75715],
[88.59754, 89.55557, 91.15629, 93.030464, 94.90464, 96.505356, 97.46339],
]),
epsilon =
```
<Overlap Ratio: 0.9738717339667459>

---

--- 193 --
Question ID: b81ef9dc4252d344f33a898fa7fb1991639ccc4e_0
Original Code:
```
fn data_set() -> Vec<Vec<u8>> {
	use rand::SeedableRng;
	use rand::Rng;

	let rnd: [u8; 32] = rand::rngs::StdRng::seed_from_u64(12).gen();
	let mut rnd = rnd.iter().cycle();
	let mut res = Vec::new();
	for size in 1..=MAX_KEY_SIZE {
		for _ in 0..1_000 {
			let value = (0..size)
				.map(|_| rnd.next().unwrap().clone())
				.collect();
			res.push(value);
		}
	}
	res
}
```


Overlapping Code:
```
{
use rand::SeedableRng;
use rand::Rng;
let rnd: [u8; 32] = rand::rngs::StdRng::seed_from_u64(12).gen();
let mut rnd = rnd.iter().cycle();
let mut res = Vec::new();
for size in 1..=MAX_KEY_SIZE {
for _ in 0..1_000 {
let value = (0..size)
.map(|_| rnd.next().unwrap().clone())
.collect();
res.push(val
```
<Overlap Ratio: 0.872093023255814>

---

--- 194 --
Question ID: 9fd8aaaaeba21fd589ff27e97e9560be85a6b6ff_3
Original Code:
```
fn test_is_empty() {
        let mut stack: Stack = Stack::new();
        assert!(stack.is_empty());

        stack.push(Value::new("Hello!".to_string()));
        stack.push(Value::new(42));
        assert!(!stack.is_empty());

        stack.pop().ok();
        assert!(!stack.is_empty());

        stack.initialize();
        assert!(stack.is_empty());
    }
```


Overlapping Code:
```
y() {
let mut stack: Stack = Stack::new();
assert!(stack.is_empty());
stack.push(Value::new("Hello!".to_string()));
stack.push(Value::new(42));
assert!(!stack.is_empty());
stack.pop().ok();
assert!(!stack.is_empty());
stack.initialize();
assert!(stac
```
<Overlap Ratio: 0.8896797153024911>

---

--- 195 --
Question ID: 8fd191f26a659e3244490ff32be4dc8e5ee85260_1
Original Code:
```
fn test_extract_col(){
        let m :  MatrixI64 = from_range_rw_i64(20, 20, -100, 400);
        let v1   = m.view(2, 2, 6, 6);
        println!("v1 : {}", v1);
        let c1 = v1.col(0);
        let v2 = m.view(2,2, 6, 1);
        assert_eq!(v2.to_matrix(), c1);
    }
```


Overlapping Code:
```
 MatrixI64 = from_range_rw_i64(20, 20, -100, 400);
let v1 = m.view(2, 2, 6, 6);
println!("v1 : {}", v1);
let c1 = v1.col(0);
let v2 = m.view(2,2, 6, 1
```
<Overlap Ratio: 0.6944444444444444>

---

--- 196 --
Question ID: ad6fd265ade99544a2062b47ed15f1479d7e21b3_1
Original Code:
```
fn test_lex_multi_char() {
        let code = "<<=<>>>=::=".as_bytes();
        let mut lexer = Lexer::new(code).unwrap();
        assert_eq!(Lt, lexer.next_token().unwrap().kind);
        assert_eq!(Le, lexer.next_token().unwrap().kind);
        assert_eq!(Ne, lexer.next_token().unwrap().kind);
        assert_eq!(Gt, lexer.next_token().unwrap().kind);
        assert_eq!(Ge, lexer.next_token().unwrap().kind);
        assert_eq!(Colon, lexer.next_token().unwrap().kind);
        assert_eq!(ColonEq, lexer.next_token().unwrap().kind);
        assert_eq!(Eof, lexer.next_token().unwrap().kind);
    }
```


Overlapping Code:
```
est_lex_multi_char() {
let code = "<<=<>>>=::=".as_bytes();
let mut lexer = Lexer::new(code).unwrap();
assert_eq!(Lt, lexer.next_token().unwrap().kind);
assert_eq!(Le, lexer.next_token().unwrap().kind);
assert_eq!(Ne, lexer.next_token().unwrap().kind);
assert_eq!(Gt, lexer.next_token().unwrap().kind);
assert_eq!(Ge, lexer.next_token().unwrap().kind);
assert_eq!(Colon, lexer.next_token().unwrap().kind);
assert_eq!(ColonEq, lexer.next_token().unwrap().kind);
assert_eq!(Eof, lexer.next_token().unwrap(
```
<Overlap Ratio: 0.9729206963249516>

---

--- 197 --
Question ID: 42d03f5a24edfe8dd99160f7ef0e293d55dcc02a_0
Original Code:
```
pub async fn list<C>(client: &Client<C>) -> Result<Vec<Zone>, Error>
where
    C: Connect + Clone + Debug + Send + Sync + 'static,
{
    let path = format!("{}/v4/products/zones", client.endpoint);

    #[cfg(feature = "logging")]
    if log_enabled!(Level::Debug) {
        debug!("execute a request to list zones, path: '{}'", &path);
    }

    client.get(&path).await.map_err(Error::List)
}
```


Overlapping Code:
```
b async fn list<C>(client: &Client<C>) -> Result<Vec<Zone>, Error>
where
C: Connect + Clone + Debug + Send + Sync + 'static,
{
let path = format!("{}/v4/products/zones", client.endpoint);
#[cfg(feature = "logging")]
if log_enabled!(Level::Debug) {
debug!("execute a request to list zones, path: '{}'", &path);
}
client.get(&path).await.map_err(Error:
```
<Overlap Ratio: 0.9722222222222222>

---

--- 198 --
Question ID: cd801b2196455ebd88e17bde021a3420c7750ef0_8
Original Code:
```
fn random_single_units_to_times() {
    assert_eq!(time!(16:51:49) - (-13).minutes(), time!(17:4:49));
    assert_eq!(time!(13:20:48) - (-4).minutes(), time!(13:24:48));
    assert_eq!(time!(6:51:52) - 44.minutes(), time!(6:7:52));
    assert_eq!(time!(20:19:13) - 41.minutes(), time!(19:38:13));
    assert_eq!(time!(1:4:31) - 0.hours(), time!(1:4:31));
    assert_eq!(time!(19:11:31) - 32.seconds(), time!(19:10:59));
    assert_eq!(time!(7:31:3) + 2.hours(), time!(9:31:3));
    assert_eq!(time!(7:5:30) - (-20).hours(), time!(3:5:30));
    assert_eq!(time!(11:56:1) - (-18).minutes(), time!(12:14:1));
    assert_eq!(time!(18:51:17) - (-51).seconds(), time!(18:52:8));
    assert_eq!(time!(21:13:48) - 36.seconds(), time!(21:13:12));
    assert_eq!(time!(19:42:49) - 99.minutes(), time!(18:3:49));
    assert_eq!(time!(0:54:29) + (-70).seconds(), time!(0:53:19));
    assert_eq!(time!(14:20:2) - (-49).minutes(), time!(15:9:2));
    assert_eq!(time!(8:51:55) - 58.seconds(), time!(8:50:57));
    assert_eq!(time!(9:21:3) + 87.seconds(), time!(9:22:30));
    assert_eq!(time!(2:40:56) + (-2).seconds(), time!(2:40:54));
    assert_eq!(time!(15:24:1) + 47.hours(), time!(14:24:1));
    assert_eq!(time!(7:38:1) + (-21).hours(), time!(10:38:1));
    assert_eq!(time!(11:26:23) - 65.minutes(), time!(10:21:23));
}
```


Overlapping Code:
```
 random_single_units_to_times() {
assert_eq!(time!(16:51:49) - (-13).minutes(), time!(17:4:49));
assert_eq!(time!(13:20:48) - (-4).minutes(), time!(13:24:48));
assert_eq!(time!(6:51:52) - 44.minutes(), time!(6:7:52));
assert_eq!(time!(20:19:13) - 41.minutes(), time!(19:38:13));
assert_eq!(time!(1:4:31) - 0.hours(), time!(1:4:31));
assert_eq!(time!(19:11:31) - 32.seconds(), time!(19:10:59));
assert_eq!(time!(7:31:3) + 2.hours(), time!(9:31:3));
assert_eq!(time!(7:5:30) - (-20).hours(), time!(3:5:30));
assert_eq!(time!(11:56:1) - (-18).minutes(), time!(12:14:1));
assert_eq!(time!(18:51:17) - (-51).seconds(), time!(18:52:8));
assert_eq!(time!(21:13:48) - 36.seconds(), time!(21:13:12));
assert_eq!(time!(19:42:49) - 99.minutes(), time!(18:3:49));
assert_eq!(time!(0:54:29) + (-70).seconds(), time!(0:53:19));
assert_eq!(time!(14:20:2) - (-49).minutes(), time!(15:9:2));
assert_eq!(time!(8:51:55) - 58.seconds(), time!(8:50:57));
assert_eq!(time!(9:21:3) + 87.seconds(), time!(9:22:30));
assert_eq!(time!(2:40:56) + (-2).seconds(), time!(2:40:54));
assert_eq!(time!(15:24:1) + 47.hours(), time!(14:24:1));
assert_eq!(time!(7:38:1) + (-21).hours(), time!(10:38:1));
assert_eq!(time!(11:26:23) - 65
```
<Overlap Ratio: 0.9732360097323601>

---

--- 199 --
Question ID: b3c4fe615e1f5f4606357e6bd3cec096a407e78d_7
Original Code:
```
async fn test_mute_combinations() {
    let (service_registry, fake_services) = create_services().await;
    let (env, _) = create_environment(service_registry).await;
    let input_proxy = env.connect_to_service::<InputMarker>().unwrap();

    // Hardware muted, software unmuted.
    switch_hardware_mic_mute(&fake_services, true).await;
    set_mic_mute(&input_proxy, false).await;
    get_and_check_mic_mute(&input_proxy, true).await;

    // Hardware muted, software muted.
    set_mic_mute(&input_proxy, true).await;
    get_and_check_mic_mute(&input_proxy, true).await;

    // Hardware unmuted, software muted.
    switch_hardware_mic_mute(&fake_services, false).await;
    get_and_check_mic_mute(&input_proxy, true).await;

    // Hardware unmuted, software unmuted.
    switch_hardware_mic_mute(&fake_services, false).await;
    set_mic_mute(&input_proxy, false).await;
    get_and_check_mic_mute(&input_proxy, false).await;
}
```


Overlapping Code:
```
s() {
let (service_registry, fake_services) = create_services().await;
let (env, _) = create_environment(service_registry).await;
let input_proxy = env.connect_to_service::<InputMarker>().unwrap();
// Hardware muted, software unmuted.
switch_hardware_mic_mute(&fake_services, true).await;
set_mic_mute(&input_proxy, false).await;
get_and_check_mic_mute(&input_proxy, true).await;
// Hardware muted, software muted.
set_mic_mute(&input_proxy, true).await;
get_and_check_mic_mute(&input_proxy, true).await;
// Hardware unmuted, software muted.
switch_hardware_mic_mute(&fake_services, false).await;
get_and_check_mic_mute(&input_proxy, true).await;
// Hardware unmuted, software unmuted.
switch_hardware_mic_mute(&fake_services, false).await;
set_mic_mute(&input_proxy, false).await;
get_and_check_mic_mute(&input_proxy, false).await
```
<Overlap Ratio: 0.9618055555555556>

---

--- 200 --
Question ID: 85260655dd0d5a7f12fcbff8f77b1a01315ba1f1_4
Original Code:
```
fn insert() {
    //normal
    let t = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];
    let mut heap = max_heap::BinaryHeap::new(t);
    // data layout:
    //   vec![16, 14, 10, 8, 7, 9, 3, 2, 4, 1];
    heap.insert(100);
    let data = heap.keys_slice();
    assert_eq!(data, vec![100, 16, 10, 8, 14, 9, 3, 2, 4, 1, 7])
}
```


Overlapping Code:
```
rmal
let t = vec![4, 1, 3, 2, 16, 9, 10, 14, 8, 7];
let mut heap = max_heap::BinaryHeap::new(t);
// data layout:
// vec![16, 14, 10, 8, 7, 9, 3, 2, 4, 1];
heap.insert(100);
let data = heap.keys_slice();
assert_eq!(data, vec![100, 16, 10, 8, 14, 9, 3,
```
<Overlap Ratio: 0.8833922261484098>

---

--- 201 --
Question ID: a25a42c6f86834a28e4f969ee28452aa8842621d_1
Original Code:
```
fn spawn_random(player: &Character, distance: &location::Distance) -> (Class, i32) {
    // the weights for each group of enemies are different depending on the distance
    // the further from home, the bigger the chance to find difficult enemies
    let (w_common, w_rare, w_legendary) = match distance {
        location::Distance::Near(_) => (10, 2, 0),
        location::Distance::Mid(_) => (8, 10, 1),
        location::Distance::Far(_) => (0, 8, 2),
    };

    let mut rng = rand::thread_rng();

    // assign weights to each group and select one
    let weights = vec![
        (Category::Common, w_common),
        (Category::Rare, w_rare),
        (Category::Legendary, w_legendary),
    ];

    let category = weights
        .as_slice()
        .choose_weighted(&mut rng, |(_c, weight)| *weight)
        .unwrap()
        .0
        .clone();

    let level = std::cmp::max(player.level / 10 + distance.len() - 1, 1);
    (Class::random(category).clone(), level)
}
```


Overlapping Code:
```
ndom(player: &Character, distance: &location::Distance) -> (Class, i32) {
// the weights for each group of enemies are different depending on the distance
// the further from home, the bigger the chance to find difficult enemies
let (w_common, w_rare, w_legendary) = match distance {
location::Distance::Near(_) => (10, 2, 0),
location::Distance::Mid(_) => (8, 10, 1),
location::Distance::Far(_) => (0, 8, 2),
};
let mut rng = rand::thread_rng();
// assign weights to each group and select one
let weights = vec![
(Category::Common, w_common),
(Category::Rare, w_rare),
(Category::Legendary, w_legendary),
];
let category = weights
.as_slice()
.choose_weighted(&mut rng, |(_c, weight)| *weight)
.unwrap()
.0
.clone();
let level = std::cmp::max(player.level / 10 + distance.len() - 1, 1);
(Class::rand
```
<Overlap Ratio: 0.9512485136741974>

---

--- 202 --
Question ID: 9da3e13f17677b46f040f1db0b526ffa66f7b31b_254
Original Code:
```
pub fn serialize_structure_crate_model_port_range_from_to(
    object: &mut aws_smithy_json::serialize::JsonObjectWriter,
    input: &crate::model::PortRangeFromTo,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    if input.from != 0 {
        object.key("From").number(
            #[allow(clippy::useless_conversion)]
            aws_smithy_types::Number::NegInt((input.from).into()),
        );
    }
    if input.to != 0 {
        object.key("To").number(
            #[allow(clippy::useless_conversion)]
            aws_smithy_types::Number::NegInt((input.to).into()),
        );
    }
    Ok(())
}
```


Overlapping Code:
```
ize_structure_crate_model_port_range_from_to(
object: &mut aws_smithy_json::serialize::JsonObjectWriter,
input: &crate::model::PortRangeFromTo,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
if input.from != 0 {
object.key("From").number(
#[allow(clippy::useless_conversion)]
aws_smithy_types::Number::NegInt((input.from).into()),
);
}
if input.to != 0 {
object.key("To").number(
#[allow(clippy::useless_conversion)]
aws_smithy_types::Number::NegInt((input.to).into()),
);
}
Ok(())
```
<Overlap Ratio: 0.970873786407767>

---

--- 203 --
Question ID: a3889528db5bb779621f9bea8c6f6249ccc93496_1
Original Code:
```
pub(crate) fn eval(p: &[u8], x: u8) -> u8 {
    let mut result = 0;

    for i in (0..p.len()).rev() {
        result = add(mul(result, x), p[i])
    }
    result
}
```


Overlapping Code:
```

let mut result = 0;
for i in (0..p.len()).rev() {
```
<Overlap Ratio: 0.3597122302158273>

---

--- 204 --
Question ID: b70fa1910b06cdcf267c9c777989a969c5ab8cb2_0
Original Code:
```
fn main() -> io::Result<()> {
    let mut buffer = String::new();
    io::stdin().read_to_string(&mut buffer)?;

    let ans: usize = buffer
        .trim()
        .split('\n')
        .map(|line| {

            let (_, raw_digits) = line.split_once(" | ").unwrap();
            let digits: Vec<_> = raw_digits.trim().split_whitespace().collect();

            return digits
                .iter()
                .filter(|digit| digit.len() == 2 || digit.len() == 3 || digit.len() == 4 || digit.len() == 7)
                .count();
        })
        .sum();

    println!("{}", ans);

    return Ok(());
}
```


Overlapping Code:
```
fn main() -> io::Result<()> {
let mut buffer = String::new();
io::stdin().read_to_string(&mut buffer)?;
let ans: usize = buffer
.trim()
.split('\n')
.map(|line| {
let (_, raw_digits) = line.split_once(" | ").unwrap();
let digits: Vec<_> = raw_digits.trim().split_whitespace().collect();
return digits
.iter()
.filter(|digit| digit.len() == 2 || digit.len() == 3 || digit.len() == 4 || digit.len() == 7)
.count();
```
<Overlap Ratio: 0.8937093275488069>

---

--- 205 --
Question ID: a2fc683c9d42063130f072835cbea917bad8fc4d_8
Original Code:
```
fn adc_can_add_basic_numbers() {
            let code = vec![0xA9, 0x05, 0x69, 0x03];
            let mut cpu = Cpu::new();
            cpu.load(&code[..], None);
            cpu.reset();

            cpu.step_n(2);

            assert_eq!(8, cpu.registers.A);
        }
```


Overlapping Code:
```
add_basic_numbers() {
let code = vec![0xA9, 0x05, 0x69, 0x03];
let mut cpu = Cpu::new();
cpu.load(&code[..], None);
cpu.reset();
cpu.step_n(2);
assert
```
<Overlap Ratio: 0.7978723404255319>

---

--- 206 --
Question ID: 422c2630057f5e3b37c74adb2284892b77a510a1_4
Original Code:
```
unsafe extern "C" fn media_unsuspend<T: RTSPMediaImpl>(
    ptr: *mut ffi::GstRTSPMedia,
) -> glib::ffi::gboolean {
    let instance = &*(ptr as *mut T::Instance);
    let imp = instance.impl_();
    let wrap: Borrowed<RTSPMedia> = from_glib_borrow(ptr);

    match imp.unsuspend(wrap.unsafe_cast_ref()) {
        Ok(()) => glib::ffi::GTRUE,
        Err(err) => {
            err.log_with_object(&*wrap);
            glib::ffi::GFALSE
        }
    }
}
```


Overlapping Code:
```
tern "C" fn media_unsuspend<T: RTSPMediaImpl>(
ptr: *mut ffi::GstRTSPMedia,
) -> glib::ffi::gboolean {
let instance = &*(ptr as *mut T::Instance);
let imp = instance.impl_();
let wrap: Borrowed<RTSPMedia> = from_glib_borrow(ptr);
match imp.unsuspend(wrap.unsafe_cast_ref()) {
Ok(()) => glib::ffi::GTRUE,
Err(err) => {
err.log_with_object(&*wrap);
glib::ffi::GF
```
<Overlap Ratio: 0.9498680738786279>

---

--- 207 --
Question ID: f4c80467512e38daec9973a973da8fe1787ff711_1
Original Code:
```
pub fn build_collection(
    collection_path: &Path,
    wal_config: &WalConfig,               // from config
    collection_params: &CollectionParams, //  from user
    optimizers_config: &OptimizersConfig,
    hnsw_config: &HnswConfig,
) -> CollectionResult<Collection> {
    let wal_path = collection_path.join("wal");

    create_dir_all(&wal_path).map_err(|err| CollectionError::ServiceError {
        error: format!("Can't create collection directory. Error: {}", err),
    })?;

    let segments_path = collection_path.join("segments");

    create_dir_all(&segments_path).map_err(|err| CollectionError::ServiceError {
        error: format!("Can't create collection directory. Error: {}", err),
    })?;

    let mut segment_holder = SegmentHolder::default();

    let schema_storage = Arc::new(SchemaStorage::new());

    for _sid in 0..optimizers_config.default_segment_number {
        let segment = build_simple_segment(
            &segments_path,
            collection_params.vector_size,
            collection_params.distance,
            schema_storage.clone(),
        )?;
        segment_holder.add(segment);
    }

    let wal: SerdeWal<CollectionUpdateOperations> =
        SerdeWal::new(wal_path.to_str().unwrap(), &wal_config.into())?;

    let collection_config = CollectionConfig {
        params: collection_params.clone(),
        hnsw_config: *hnsw_config,
        optimizer_config: optimizers_config.clone(),
        wal_config: wal_config.clone(),
    };

    collection_config.save(collection_path)?;

    let optimizers = build_optimizers(
        collection_path,
        collection_params,
        optimizers_config,
        &collection_config.hnsw_config,
        schema_storage.clone(),
    );

    let collection = construct_collection(
        segment_holder,
        collection_config,
        wal,
        optimizers,
        collection_path,
        schema_storage,
    );

    Ok(collection)
}
```


Overlapping Code:
```
ollection_path: &Path,
wal_config: &WalConfig, // from config
collection_params: &CollectionParams, // from user
optimizers_config: &OptimizersConfig,
hnsw_config: &HnswConfig,
) -> CollectionResult<Collection> {
let wal_path = collection_path.join("wal");
create_dir_all(&wal_path).map_err(|err| CollectionError::ServiceError {
error: format!("Can't create collection directory. Error: {}", err),
})?;
let segments_path = collection_path.join("segments");
create_dir_all(&segments_path).map_err(|err| CollectionError::ServiceError {
error: format!("Can't create collection directory. Error: {}", err),
})?;
let mut segment_holder = SegmentHolder::default();
let schema_storage = Arc::new(SchemaStorage::new());
for _sid in 0..optimizers_config.default_segment_number {
let segment = build_simple_segment(
&segments_path,
collection_params.vector_size,
collection_params.distance,
schema_storage.clone(),
)?;
segment_holder.add(segment);
}
let wal: SerdeWal<CollectionUpdateOperations> =
SerdeWal::new(wal_path.to_str().unwrap(), &wal_config.into())?;
let collection_config = CollectionConfig {
params: collection_params.clone(),
hnsw_config: *hnsw_config,
optimizer_config: optimizers_config.clone(),
wal_config: wal_config.clone(),
};
collection_config.save(collection_path)?;
let optimizers = build_optimizers(
collection_path,
collection_params,
optimizers_config,
&collection_config.hnsw_config,
schema_storage.clone(),
);
let collection = construct_collection(
segment_holder,
collection_config,
wal,
optimizers,
collection_path,
schema_storage
```
<Overlap Ratio: 0.9705698184095178>

---

--- 208 --
Question ID: 2bd0b28762cbb562aef54469fa61edf0c4070892_2
Original Code:
```
pub(crate) fn prepare_effects(
    mut commands: Commands,
    sim_params: Res<SimParams>,
    render_device: Res<RenderDevice>,
    render_queue: Res<RenderQueue>,
    //update_pipeline: Res<ParticlesUpdatePipeline>, // TODO move update_pipeline.pipeline to EffectsMeta
    mut effects_meta: ResMut<EffectsMeta>,
    mut extracted_effects: ResMut<ExtractedEffects>,
) {
    trace!("prepare_effects");

    // Allocate simulation uniform if needed
    if effects_meta.sim_params_uniforms.is_empty() {
        effects_meta
            .sim_params_uniforms
            .push(SimParamsUniform::default());
    }

    // Update simulation parameters
    {
        let sim_params_uni = effects_meta.sim_params_uniforms.get_mut(0);
        let sim_params = *sim_params;
        *sim_params_uni = sim_params.into();
    }
    trace!(
        "Simulation parameters: time={} dt={}",
        sim_params.time,
        sim_params.dt
    );
    effects_meta
        .sim_params_uniforms
        .write_buffer(&render_device, &render_queue);

    // Allocate spawner buffer if needed
    //if effects_meta.spawner_buffer.is_empty() {
    //    effects_meta.spawner_buffer.push(SpawnerParams::default());
    //}

    // Write vertices (TODO - lazily once only)
    effects_meta
        .vertices
        .write_buffer(&render_device, &render_queue);

    // Allocate GPU data for newly created effect instances. Do this first to ensure a group is not left
    // unused and dropped due to the last effect being removed but a new compatible one added not being
    // inserted yet. By inserting first, we ensure the group is not dropped in this case.
    for added_effect in extracted_effects.added_effects.drain(..) {
        let entity = added_effect.entity;
        let id = effects_meta.effect_cache.insert(
            added_effect.handle,
            added_effect.capacity,
            added_effect.item_size,
            //update_pipeline.pipeline.clone(),
            &render_queue,
        );
        let slice = effects_meta.effect_cache.get_slice(id);
        effects_meta.entity_map.insert(entity, slice);
    }

    // Deallocate GPU data for destroyed effect instances. This will automatically drop any group where
    // there is no more effect slice.
    for _entity in extracted_effects.removed_effect_entities.iter() {
        unimplemented!("Remove particle effect.");
        //effects_meta.remove(&*entity);
    }

    // // sort first by z and then by handle. this ensures that, when possible, batches span multiple z layers
    // // batches won't span z-layers if there is another batch between them
    // extracted_effects.effects.sort_by(|a, b| {
    //     match FloatOrd(a.transform.w_axis[2]).cmp(&FloatOrd(b.transform.w_axis[2])) {
    //         Ordering::Equal => a.handle.cmp(&b.handle),
    //         other => other,
    //     }
    // });

    // Get the effect-entity mapping
    let mut effect_entity_list = extracted_effects
        .effects
        .iter()
        .map(|(entity, extracted_effect)| {
            let slice = effects_meta.entity_map.get(entity).unwrap().clone();
            (slice, extracted_effect)
        })
        .collect::<Vec<_>>();
    trace!("Collected {} extracted effects", effect_entity_list.len());

    // Sort first by effect buffer, then by slice range (see EffectSlice)
    effect_entity_list.sort_by(|a, b| a.0.cmp(&b.0));

    // Loop on all extracted effects in order
    effects_meta.spawner_buffer.clear();
    let mut spawner_base = 0;
    let mut item_size = 0;
    let mut current_buffer_index = u32::MAX;
    let mut asset: Handle<EffectAsset> = Default::default();
    let mut layout_flags = LayoutFlags::NONE;
    let mut image_handle_id: HandleId = HandleId::default::<Image>();
    let mut shader: Handle<Shader> = Default::default();
    let mut start = 0;
    let mut end = 0;
    let mut num_emitted = 0;
    let mut position_code = String::default();
    let mut force_field_code = String::default();
    let mut lifetime_code = String::default();

    for (slice, extracted_effect) in effect_entity_list {
        let buffer_index = slice.group_index;
        let range = slice.slice;
        layout_flags = if extracted_effect.has_image {
            LayoutFlags::PARTICLE_TEXTURE
        } else {
            LayoutFlags::NONE
        };
        image_handle_id = extracted_effect.image_handle_id;
        trace!("Effect: buffer #{} | range {:?}", buffer_index, range);

        // Check the buffer the effect is in
        assert!(buffer_index >= current_buffer_index || current_buffer_index == u32::MAX);
        if current_buffer_index != buffer_index {
            trace!(
                "+ New buffer! ({} -> {})",
                current_buffer_index,
                buffer_index
            );
            // Commit previous buffer if any
            if current_buffer_index != u32::MAX {
                // Record open batch if any
                trace!("+ Prev: {} - {}", start, end);
                if end > start {
                    assert_ne!(asset, Handle::<EffectAsset>::default());
                    assert!(item_size > 0);
                    trace!(
                        "Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}",
                        current_buffer_index,
                        spawner_base,
                        start..end,
                        item_size,
                        shader
                    );
                    commands.spawn_bundle((EffectBatch {
                        buffer_index: current_buffer_index,
                        spawner_base: spawner_base as u32,
                        slice: start..end,
                        item_size,
                        handle: asset.clone_weak(),
                        layout_flags,
                        image_handle_id,
                        shader: shader.clone(),
                        position_code: position_code.clone(),
                        force_field_code: force_field_code.clone(),
                        lifetime_code: lifetime_code.clone(),
                        compute_pipeline: None,
                    },));
                    num_emitted += 1;
                }
            }

            // Move to next buffer
            current_buffer_index = buffer_index;
            start = 0;
            end = 0;
            spawner_base = effects_meta.spawner_buffer.len();
            trace!("+ New spawner_base = {}", spawner_base);
            // Each effect buffer contains effect instances with a compatible layout
            // FIXME - Currently this means same effect asset, so things are easier...
            asset = extracted_effect.handle.clone_weak();
            item_size = slice.item_size;
        }

        assert_ne!(asset, Handle::<EffectAsset>::default());

        shader = extracted_effect.shader.clone();
        trace!("shader = {:?}", shader);

        trace!("item_size = {}B", slice.item_size);

        position_code = extracted_effect.position_code.clone();
        trace!("position_code = {}", position_code);

        force_field_code = extracted_effect.force_field_code.clone();
        trace!("force_field_code = {}", force_field_code);

        lifetime_code = extracted_effect.lifetime_code.clone();
        trace!("lifetime_code = {}", lifetime_code);

        // extract the force field and turn it into a struct that is compliant with Std430,
        // namely ForceFieldStd430
        let mut extracted_force_field = [ForceFieldStd430::default(); FFNUM];
        for (i, ff) in extracted_effect.force_field.iter().enumerate() {
            extracted_force_field[i] = (*ff).into();
        }

        // Prepare the spawner block for the current slice
        // FIXME - This is once per EFFECT/SLICE, not once per BATCH, so indeed this is spawner_BASE, and need an array of them in the compute shader!!!!!!!!!!!!!!
        let spawner_params = SpawnerParams {
            spawn: extracted_effect.spawn_count as i32,
            count: 0,
            origin: extracted_effect.transform.col(3).truncate(),
            accel: extracted_effect.accel,
            force_field: extracted_force_field, // extracted_effect.force_field,
            seed: random::<u32>(),
            ..Default::default()
        };
        trace!("spawner_params = {:?}", spawner_params);
        effects_meta.spawner_buffer.push(spawner_params);

        trace!("slice = {}-{} | prev end = {}", range.start, range.end, end);
        if (range.start > end) || (item_size != slice.item_size) {
            // Discontinuous slices; create a new batch
            if end > start {
                // Record the previous batch
                assert_ne!(asset, Handle::<EffectAsset>::default());
                assert!(item_size > 0);
                trace!(
                    "Emit batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}",
                    buffer_index,
                    spawner_base,
                    start..end,
                    item_size,
                    shader
                );
                commands.spawn_bundle((EffectBatch {
                    buffer_index,
                    spawner_base: spawner_base as u32,
                    slice: start..end,
                    item_size,
                    handle: asset.clone_weak(),
                    layout_flags,
                    image_handle_id,
                    shader: shader.clone(),
                    position_code: position_code.clone(),
                    force_field_code: force_field_code.clone(),
                    lifetime_code: lifetime_code.clone(),
                    compute_pipeline: None,
                },));
                num_emitted += 1;
            }
            start = range.start;
            item_size = slice.item_size;
        }
        end = range.end;
    }

    // Record last open batch if any
    if end > start {
        assert_ne!(asset, Handle::<EffectAsset>::default());
        assert!(item_size > 0);
        trace!(
            "Emit LAST batch: buffer #{} | spawner_base {} | slice {:?} | item_size {} | shader {:?}",
            current_buffer_index,
            spawner_base,
            start..end,
            item_size,
            shader
        );
        commands.spawn_bundle((EffectBatch {
            buffer_index: current_buffer_index,
            spawner_base: spawner_base as u32,
            slice: start..end,
            item_size,
            handle: asset.clone_weak(),
            layout_flags,
            image_handle_id,
            shader,
            position_code,
            force_field_code,
            lifetime_code,
            compute_pipeline: None,
        },));
        num_emitted += 1;
    }
    trace!(
        "Emitted {} buffers, spawner_buffer len = {}",
        num_emitted,
        effects_meta.spawner_buffer.len()
    );

    // Write the entire spawner buffer for this frame, for all effects combined
    effects_meta
        .spawner_buffer
        .write_buffer(&render_device, &render_queue);
}
```


Overlapping Code:
```
s: Commands,
sim_params: Res<SimParams>,
render_device: Res<RenderDevice>,
render_queue: Res<RenderQueue>,
//update_pipeline: Res<ParticlesUpdatePipeline>, // TODO move update_pipeline.pipeline to EffectsMeta
mut effects_meta: ResMut<EffectsMeta>,
mut extracted_effects: ResMut<ExtractedEffects>,
) {
trace!("prepare_effects");
// Allocate simulation uniform if needed
if effects_meta.sim_params_uniforms.is_empty() {
effects_meta
.sim_params_uniforms
.push(SimParamsUniform::default());
}
// Update simulation parameters
{
let sim_params_uni = effects_meta.sim_params_uniforms.get_mut(0);
let sim_params = *sim_params;
*sim_params_uni = sim_params.into();
}
trace!(
"Simulation parameters: time={} dt={}",
sim_params.time,
sim_params.dt
);
effects_meta
.sim_params_uniforms
.write_buffer(&render_device, &render_queue);
// Allocate spawner buffer if needed
//if effects_meta.spawner_buffer.is_empty() {
// effects_meta.spawner_buffer.push(SpawnerParams::default());
//}
// Write vertices (TODO - lazily once only)
effects_meta
.vertices
.write_buffer(&render_device, &render_queue);
// Allocate GPU data for newly created effect instances. Do this first to ensure a group is not left
// unused and dropped due to the last effect being removed but a new compatible one added not being
// inserted yet. By inserting first, we ensure the group is not dropped in this case.
for added_effect in extracted_effects.added_effects.drain(..) {
let entity = added_effect.entity;
let id = effects_meta.effect_cache.insert(
added_effect.handle,
added_effect.capacity,
added_effect.item_size,
//update_pipeline.pipeline.clone(),
&render_queue,
);
let slice = effects_meta.effect_cache.get_slice(id);
effects_meta.entity_map.insert(entity, slice);
}
// Deallocate GPU data for destroyed effect instances. This will automatically drop any group where
// there is no more effect slice.
for _entity in extracted_effects.removed_effect_entities.iter() {
unimplemented!("Remove particle effect.");
//effects_meta.remove(&*entity);
}
// // sort first by z and then by handle. this ensures th
```
<Overlap Ratio: 0.972757162987318>

---

--- 209 --
Question ID: 51adc990642f5fe3d7380e0c350b6e8335eb5923_4
Original Code:
```
fn range() {
        let reader = DataReaderBuilder::default()
            .range(-1.0..1.0)
            .build()
            .unwrap();
        let mut file = NamedTempFile::new().unwrap();
        writeln!(file, "1.3").unwrap();
        writeln!(file, "2").unwrap();
        writeln!(file, "-0.5").unwrap();
        writeln!(file, "0.5").unwrap();
        let vec = reader.read(file.path().to_str().unwrap());
        assert_eq!(vec, [-0.5, 0.5]);
    }
```


Overlapping Code:
```
ataReaderBuilder::default()
.range(-1.0..1.0)
.build()
.unwrap();
let mut file = NamedTempFile::new().unwrap();
writeln!(file, "1.3").unwrap();
writeln!(file, "2").unwrap();
writeln!(file, "-0.5").unwrap();
writeln!(file, "0.5").unwrap();
let vec = reader.read(file.path().to_str().unwrap());
assert_eq!
```
<Overlap Ratio: 0.8632478632478633>

---

--- 210 --
Question ID: 4693cf30bac359276617be3ce520aa50f3f6d85a_10
Original Code:
```
fn exclusion_rule_must_have_different_families_for_conditions_and_exclusions() {
        let blue = Item::from("shirts:blue");
        let red = Item::from("shirts:red");

        let jeans = Item::from("pants:jeans");
        let slacks = Item::from("pants:slacks");

        let shirts = Family::from("shirts");
        let pants = Family::from("pants");

        let error = build_catalog(CatalogAssembly {
            families: btreemap! {
                shirts.clone() => vec![red.clone(), blue.clone()],
                pants.clone() => vec![jeans.clone(), slacks.clone()],
            },
            exclusions: vec![
                CatalogExclusionRule { conditions: vec![jeans.clone()], exclusions: vec![slacks.clone()] },
                CatalogExclusionRule { conditions: vec![slacks.clone()], exclusions: vec![jeans.clone()] },
            ],
            inclusions: vec![],
        })
            .expect_err("expected build to return Error");

        assert_eq!(
            CatalogBuilderError::ExclusionFamilyConflict { family: pants, items: vec![jeans, slacks] },
            error
        );
    }
```


Overlapping Code:
```
milies_for_conditions_and_exclusions() {
let blue = Item::from("shirts:blue");
let red = Item::from("shirts:red");
let jeans = Item::from("pants:jeans");
let slacks = Item::from("pants:slacks");
let shirts = Family::from("shirts");
let pants = Family::from("pants");
let error = build_catalog(CatalogAssembly {
families: btreemap! {
shirts.clone() => vec![red.clone(), blue.clone()],
pants.clone() => vec![jeans.clone(), slacks.clone()],
},
exclusions: vec![
CatalogExclusionRule { conditions: vec![jeans.clone()], exclusions: vec![slacks.clone()] },
CatalogExclusionRule { conditions: vec![slacks.clone()], exclusions: vec![jeans.clone()] },
],
inclusions: vec![],
})
.expect_err("expected build to return Error");
assert_eq!(
CatalogBuilderError::ExclusionFamilyConflict { family: pants, items: vec![jea
```
<Overlap Ratio: 0.9252873563218391>

---

--- 211 --
Question ID: 51ad805afa4fe2a89e9386dbe4e9973843109ec0_2
Original Code:
```
fn gas_add_fixed_range() {
        assert_eq!(
            Gas::Range { min: 1, max: 3 },
            Gas::Fixed(3) + Gas::Range { min: 1, max: 2 }
        );

        assert_eq!(
            Gas::Range { min: 1, max: 5 },
            Gas::Fixed(3) + Gas::Range { min: 1, max: 5 }
        );

        let mut gas = Gas::Fixed(3);
        gas += Gas::Range { min: 1, max: 2 };
        assert_eq!(Gas::Range { min: 1, max: 3 }, gas);

        let mut gas = Gas::Fixed(3);
        gas += Gas::Range { min: 1, max: 5 };
        assert_eq!(Gas::Range { min: 1, max: 5 }, gas);
    }
```


Overlapping Code:
```
 {
assert_eq!(
Gas::Range { min: 1, max: 3 },
Gas::Fixed(3) + Gas::Range { min: 1, max: 2 }
);
assert_eq!(
Gas::Range { min: 1, max: 5 },
Gas::Fixed(3) + Gas::Range { min: 1, max: 5 }
);
let mut gas = Gas::Fixed(3);
gas += Gas::Range { min: 1, max: 2 };
assert_eq!(Gas::Range { min: 1, max: 3 }, gas);
let mut gas = Gas::Fixed(3);
gas += Gas::Range { min: 1, max: 5 };
assert_eq!(Gas::Range { min: 1,
```
<Overlap Ratio: 0.9049773755656109>

---

--- 212 --
Question ID: 3fce34367ae5040132e5bad3ed34924faf7178ad_0
Original Code:
```
fn main() {
    let mut vec = vec![1, 2, 3, 4];
    let vec2 = vec![1, 2, 3, 4];
    for i in 0..vec.len() {
        println!("{}", vec[i]);
    }

    for i in 0..vec.len() {
        let i = 42; // make a different `i`
        println!("{}", vec[i]); // ok, not the `i` of the for-loop
    }

    for i in 0..vec.len() {
        let _ = vec[i];
    }

    // ICE #746
    for j in 0..4 {
        println!("{:?}", STATIC[j]);
    }

    for j in 0..4 {
        println!("{:?}", CONST[j]);
    }

    for i in 0..vec.len() {
        println!("{} {}", vec[i], i);
    }
    for i in 0..vec.len() {
        // not an error, indexing more than one variable
        println!("{} {}", vec[i], vec2[i]);
    }

    for i in 0..vec.len() {
        println!("{}", vec2[i]);
    }

    for i in 5..vec.len() {
        println!("{}", vec[i]);
    }

    for i in 0..MAX_LEN {
        println!("{}", vec[i]);
    }

    for i in 0..=MAX_LEN {
        println!("{}", vec[i]);
    }

    for i in 5..10 {
        println!("{}", vec[i]);
    }

    for i in 5..=10 {
        println!("{}", vec[i]);
    }

    for i in 5..vec.len() {
        println!("{} {}", vec[i], i);
    }

    for i in 5..10 {
        println!("{} {}", vec[i], i);
    }

    // #2542
    for i in 0..vec.len() {
        vec[i] = Some(1).unwrap_or_else(|| panic!("error on {}", i));
    }

    // #3788
    let test = Test {
        inner: vec![1, 2, 3, 4],
    };
    for i in 0..2 {
        println!("{}", test[i]);
    }
}
```


Overlapping Code:
```
vec = vec![1, 2, 3, 4];
let vec2 = vec![1, 2, 3, 4];
for i in 0..vec.len() {
println!("{}", vec[i]);
}
for i in 0..vec.len() {
let i = 42; // make a different `i`
println!("{}", vec[i]); // ok, not the `i` of the for-loop
}
for i in 0..vec.len() {
let _ = vec[i];
}
// ICE #746
for j in 0..4 {
println!("{:?}", STATIC[j]);
}
for j in 0..4 {
println!("{:?}", CONST[j]);
}
for i in 0..vec.len() {
println!("{} {}", vec[i], i);
}
for i in 0..vec.len() {
// not an error, indexing more than one variable
println!("{} {}", vec[i], vec2[i]);
}
for i in 0..vec.len() {
println!("{}", vec2[i]);
}
for i in 5..vec.len() {
println!("{}", vec[i]);
}
for i in 0..MAX_LEN {
println!("{}", vec[i]);
}
for i in 0..=MAX_LEN {
println!("{}", vec[i]);
}
for i in 5..10 {
println!("{}", vec[i]);
}
for i in 5..=10 {
println!("{}", vec[i]);
}
for i in 5..vec.len() {
println!("{} {}", vec[i], i);
}
for i in 5..10 {
println!("{} {}", vec[i], i);
}
// #2542
for i in 0..vec.len() {
vec[i] = Some(1).unwrap_or_else(|| panic!("error on {}", i));
}
// #3788
let test = Test {
inner: vec![1, 2, 3, 4],
};
for i in 0..2 {
println!("{}", t
```
<Overlap Ratio: 0.972027972027972>

---

--- 213 --
Question ID: d3bb7c75edf3e7c8839c415f4ea783450b47429b_2
Original Code:
```
fn rpc_parity_set_min_gas_price() {
	let miner = miner_service();
	let client = client_service();
	let network = network_service();
	let updater = updater_service();

	let mut io = IoHandler::new();
	io.extend_with(parity_set_client(&client, &miner, &updater, &network).to_delegate());

	let request = r#"{"jsonrpc": "2.0", "method": "parity_setMinGasPrice", "params":["0xcd1722f3947def4cf144679da39c4c32bdc35681"], "id": 1}"#;
	let response = r#"{"jsonrpc":"2.0","result":true,"id":1}"#;

	assert_eq!(io.handle_request_sync(request), Some(response.to_owned()));
}
```


Overlapping Code:
```
ity_set_min_gas_price() {
let miner = miner_service();
let client = client_service();
let network = network_service();
let updater = updater_service();
let mut io = IoHandler::new();
io.extend_with(parity_set_client(&client, &miner, &updater, &network).to_delegate());
let request = r#"{"jsonrpc": "2.0", "method": "parity_setMinGasPrice", "params":["0xcd1722f3947def4cf144679da39c4c32bdc35681"], "id": 1}"#;
let response = r#"{"jsonrpc":"2.0","result":true,"id":1}"#;
assert_eq!(io.handle_request_sync(request), Some(response.to_owned()));

```
<Overlap Ratio: 0.980072463768116>

---

--- 214 --
Question ID: cbcf5eccfb6cbebf5ac428959796b460a16c2acd_7
Original Code:
```
fn test_from_into_diff() {
    let service: Service = service();

    let diff: DiffService = service.clone().into_diff().unwrap();
    let new: Service = Service::from_diff(diff.clone()).unwrap();
    assert_eq!(new, service);

    let ser: String = diff.to_json().unwrap();
    let de: DiffService = DiffService::from_json(&ser).unwrap();
    assert_eq!(diff, de);
    let from: Service = Service::from_diff(de).unwrap();
    assert_eq!(from, service);
  }
```


Overlapping Code:
```
_into_diff() {
let service: Service = service();
let diff: DiffService = service.clone().into_diff().unwrap();
let new: Service = Service::from_diff(diff.clone()).unwrap();
assert_eq!(new, service);
let ser: String = diff.to_json().unwrap();
let de: DiffService = DiffService::from_json(&ser).unwrap();
assert_eq!(diff, de);
let from: Service = Service::from_diff(de).unwrap();
assert_eq!(from, servi
```
<Overlap Ratio: 0.9569377990430622>

---

--- 215 --
Question ID: 8ed9f34a8638853e7c2b0b1a1b19ce381ebf7f15_0
Original Code:
```
pub fn write_initializer(tmd: &mut TableMetaData) {
    write_default_initializer(tmd.line_writer, &tmd.swift_properties.iter().collect());
    write_row_initializer_with_starting_index(tmd);
    write_row_initializer_protocol(tmd);
}
```


Overlapping Code:
```
Data) {
write_default_initializer(tmd.line_writer, &tmd.swift_properties.iter().collect());
write_row_initializer_with_starting_index(tmd);
write_row_
```
<Overlap Ratio: 0.6756756756756757>

---

--- 216 --
Question ID: 6fa48d308487319188cbc34cfdba4d8f1c8076c0_5
Original Code:
```
fn test_backup_mode_long_with_args() {
        let short_opt_present = false;
        let long_opt_present = true;
        let long_opt_value = Some("simple");
        let _dummy = TEST_MUTEX.lock().unwrap();

        let result =
            determine_backup_mode(short_opt_present, long_opt_present, long_opt_value).unwrap();

        assert_eq!(result, BackupMode::SimpleBackup);
    }
```


Overlapping Code:
```
_backup_mode_long_with_args() {
let short_opt_present = false;
let long_opt_present = true;
let long_opt_value = Some("simple");
let _dummy = TEST_MUTEX.lock().unwrap();
let result =
determine_backup_mode(short_opt_present, long_opt_present, long_opt_value).unwrap();
assert_eq!(result, BackupMode::SimpleBackup
```
<Overlap Ratio: 0.9658385093167702>

---

--- 217 --
Question ID: ae15adb105436aefdc02c8b355e0821f34c5cbdf_0
Original Code:
```
pub fn routes(cfg: &config::Config) -> distringo::Result<BoxedFilter<(impl Reply,)>> {
	let slash = warp::get()
		.and(path::end())
		.and(fs::file("./dist/index.html"));

	let static_files = warp::get().and(fs::dir("./dist/")).and(path::end());

	let file_routes = slash.or(static_files);

	let api_routes = api::api(cfg)?;

	let root = api_routes
		.or(file_routes)
		.with(warp::log("distringo"))
		.recover(super::handle_rejection)
		.boxed();

	Ok(root)
}
```


Overlapping Code:
```
Config) -> distringo::Result<BoxedFilter<(impl Reply,)>> {
let slash = warp::get()
.and(path::end())
.and(fs::file("./dist/index.html"));
let static_files = warp::get().and(fs::dir("./dist/")).and(path::end());
let file_routes = slash.or(static_files);
let api_routes = api::api(cfg)?;
let root = api_routes
.or(file_routes)
.with(warp::log("distringo"))
.recover(super::handle_rejection)
.boxed();
O
```
<Overlap Ratio: 0.9153318077803204>

---

--- 218 --
Question ID: a0c355822fec8705456df948932560c923e6f7df_3
Original Code:
```
fn test_format_unification() {
    use Format::*;

    let mut x = Format::unknown();
    assert!(x.unify(U8).is_ok());
    x.reduce();
    assert_eq!(x, U8);
    assert_eq!(
        x.unify(U16).unwrap_err(),
        Error::Incompatible("U8".into(), "U16".into())
    );

    let mut x = Tuple(vec![Format::unknown(), U32]);
    x.unify(Tuple(vec![U16, Format::unknown()])).unwrap();
    x.reduce();
    assert_eq!(x, Tuple(vec![U16, U32]));

    for x in vec![
        Unit,
        Bool,
        I8,
        I16,
        I32,
        I64,
        I128,
        U8,
        U16,
        U32,
        U64,
        U128,
        F32,
        F64,
        Char,
        Str,
        Bytes,
        TypeName("foo".into()),
        Option(Box::new(Unit)),
        Seq(Box::new(Unit)),
        Map {
            key: Box::new(Unit),
            value: Box::new(Unit),
        },
        Tuple(vec![Format::unknown()]),
    ]
    .iter_mut()
    {
        assert!(x.unify(TypeName("bar".into())).is_err());
        assert!(x.unify(Option(Box::new(U32))).is_err());
        assert!(x.unify(Seq(Box::new(U32))).is_err());
        assert!(x.unify(Tuple(vec![])).is_err());
    }
}
```


Overlapping Code:
```
() {
use Format::*;
let mut x = Format::unknown();
assert!(x.unify(U8).is_ok());
x.reduce();
assert_eq!(x, U8);
assert_eq!(
x.unify(U16).unwrap_err(),
Error::Incompatible("U8".into(), "U16".into())
);
let mut x = Tuple(vec![Format::unknown(), U32]);
x.unify(Tuple(vec![U16, Format::unknown()])).unwrap();
x.reduce();
assert_eq!(x, Tuple(vec![U16, U32]));
for x in vec![
Unit,
Bool,
I8,
I16,
I32,
I64,
I128,
U8,
U16,
U32,
U64,
U128,
F32,
F64,
Char,
Str,
Bytes,
TypeName("foo".into()),
Option(Box::new(Unit)),
Seq(Box::new(Unit)),
Map {
key: Box::new(Unit),
value: Box::new(Unit),
},
Tuple(vec![Format::unknown()]),
]
.iter_mut()
{
assert!(x.unify(TypeName("bar".into())).is_err());
assert!(x.unify(Option(Box::new(U32))).is_err());
assert!(x.unify(Seq(Box::new(U32))).is_err());
assert!(x.unify(Tuple(
```
<Overlap Ratio: 0.9422850412249706>

---

--- 219 --
Question ID: c16d223f5de9cba222b18b557bfe0e78720b7d75_1
Original Code:
```
fn variables_invalid() {
    let input = include_str!("inline_data_fragment/fixtures/variables.invalid.graphql");
    let expected = include_str!("inline_data_fragment/fixtures/variables.invalid.expected");
    test_fixture(transform_fixture, "variables.invalid.graphql", "inline_data_fragment/fixtures/variables.invalid.expected", input, expected);
}
```


Overlapping Code:
```
lid() {
let input = include_str!("inline_data_fragment/fixtures/variables.invalid.graphql");
let expected = include_str!("inline_data_fragment/fixtures/variables.invalid.expected");
test_fixture(transform_fixture, "variables.invalid.graphql", "inline_data_fragment/fixtures/variables.invalid.expected", input, expect
```
<Overlap Ratio: 0.9321533923303835>

---

--- 220 --
Question ID: 0cbf3fa7da9775e62d2210a96cfe1b2bfa3a5381_12
Original Code:
```
fn bindgen_test_layout_ThreadExceptionFrameA64 ( ) { assert_eq ! ( :: core :: mem :: size_of :: < ThreadExceptionFrameA64 > ( ) , 120usize , concat ! ( "Size of: " , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( :: core :: mem :: align_of :: < ThreadExceptionFrameA64 > ( ) , 8usize , concat ! ( "Alignment of " , stringify ! ( ThreadExceptionFrameA64 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . cpu_gprs as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( cpu_gprs ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . lr as * const _ as usize } , 72usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( lr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . sp as * const _ as usize } , 80usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( sp ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . elr_el1 as * const _ as usize } , 88usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( elr_el1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . pstate as * const _ as usize } , 96usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( pstate ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr0 as * const _ as usize } , 100usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( afsr0 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . afsr1 as * const _ as usize } , 104usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( afsr1 ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . esr as * const _ as usize } , 108usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( esr ) ) ) ; assert_eq ! ( unsafe { & ( * ( :: core :: ptr :: null :: < ThreadExceptionFrameA64 > ( ) ) ) . far as * const _ as usize } , 112usize , concat ! ( "Offset of field: " , stringify ! ( ThreadExceptionFrameA64 ) , "::" , stringify ! ( far ) ) ) ; }
```


Overlapping Code:
```
> ( ) , 8usize , concat ! ( "Alignment of " , stringify ! (as * const _ as usize } , 0usize , concat ! ( "Offset of field: " , stringify ! ( 2usize , concat ! ( "Offset of field: " , stringify ! ( 0usize , concat ! ( "Offset of field: " , stringify ! ( usize , concat ! ( "Offset of field: " , stringify ! ( usize , concat ! ( "Offset of field: " , stringify ! ( 0usize , concat ! ( "Offset of field: " , stringify ! ( usize , concat ! ( "Offset of field: " , stringify ! ( usize , concat ! ( "Offset of field: " , stringify ! ( 
```
<Overlap Ratio: 0.2116846738695478>

---

--- 221 --
Question ID: 06656cd35a4c28ccebc2eb1592d6fcfa2194d46c_49
Original Code:
```
fn bindgen_test_layout_MonoReflectionMethodAux() {
    assert_eq!(
        ::std::mem::size_of::<MonoReflectionMethodAux>(),
        56usize,
        concat!("Size of: ", stringify!(MonoReflectionMethodAux))
    );
    assert_eq!(
        ::std::mem::align_of::<MonoReflectionMethodAux>(),
        8usize,
        concat!("Alignment of ", stringify!(MonoReflectionMethodAux))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_names as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(param_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_marshall as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(param_marshall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_cattr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(param_cattr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_defaults as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(param_defaults)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_default_types as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(param_default_types)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dllentry as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(dllentry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MonoReflectionMethodAux>())).dll as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MonoReflectionMethodAux),
            "::",
            stringify!(dll)
        )
    );
}
```


Overlapping Code:
```
_layout_MonoReflectionMethodAux() {
assert_eq!(
::std::mem::size_of::<MonoReflectionMethodAux>(),
56usize,
concat!("Size of: ", stringify!(MonoReflectionMethodAux))
);
assert_eq!(
::std::mem::align_of::<MonoReflectionMethodAux>(),
8usize,
concat!("Alignment of ", stringify!(MonoReflectionMethodAux))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_names as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(param_names)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_marshall as *const _ as usize
},
8usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(param_marshall)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_cattr as *const _ as usize
},
16usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(param_cattr)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_defaults as *const _ as usize
},
24usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(param_defaults)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).param_default_types as *const _
as usize
},
32usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(param_default_types)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<MonoReflectionMethodAux>())).dllentry as *const _ as usize
},
40usize,
concat!(
"Offset of field: ",
stringify!(MonoReflectionMethodAux),
"::",
stringify!(dllentry)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<MonoReflectionMethodAux>()
```
<Overlap Ratio: 0.9744172825469016>

---

--- 222 --
Question ID: bc201e4de741dfe810e53f5de7188f5170e41779_10
Original Code:
```
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
```


Overlapping Code:
```
fn bindgen_test_layout__opaque_pthread_t() {
assert_eq!(
::std::mem::size_of::<_opaque_pthread_t>(),
8192usize,
concat!("Size of: ", stringify!(_opaque_pthread_t))
);
assert_eq!(
::std::mem::align_of::<_opaque_pthread_t>(),
8usize,
concat!("Alignment of ", stringify!(_opaque_pthread_t))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(_opaque_pthread_t),
"::",
stringify!(__sig)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
},
8usize,
concat!(
"Offset of field: ",
stringify!(_opaque_pthread_t),
"::",
stringify!(__cleanup_stack)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
16usize,
concat!(
"Offset of field: ",
stringify!(_opaque_pthread_t),
"::",
stringify!(__opaque)
)
);

```
<Overlap Ratio: 0.9988938053097345>

---

--- 223 --
Question ID: 8fd6b208ec84f00e8121ce9174d335326a9c9d90_2
Original Code:
```
fn read_records<R>(reader: R) -> csv::Result<()>
where
    R: Read,
{
    let mut rdr = csv::Reader::from_reader(reader);
    println!("Comparing planets in the solar system with the earth");
    println!("where a value of '1' means 'equal to earth'");
    for result in rdr.records() {
        println!("-------");
        let record = result?;
        if let Some(name) = record.get(0) {
            println!("Name: {}", name);
        }
        if let Some(radius) = record.get(1) {
            println!("Radius: {}", radius);
        }
        if let Some(distance) = record.get(2) {
            println!("Distance from sun: {}", distance);
        }
        if let Some(gravity) = record.get(3) {
            println!("Surface gravity: {}", gravity);
        }
    }
    Ok(())
}
```


Overlapping Code:
```
reader: R) -> csv::Result<()>
where
R: Read,
{
let mut rdr = csv::Reader::from_reader(reader);
println!("Comparing planets in the solar system with the earth");
println!("where a value of '1' means 'equal to earth'");
for result in rdr.records() {
println!("-------");
let record = result?;
if let Some(name) = record.get(0) {
println!("Name: {}", name);
}
if let Some(radius) = record.get(1) {
println!("Radius: {}", radius);
}
if let Some(distance) = record.get(2) {
println!("Distance from sun: {}", distance);
}
if let Some(gravity) = record.get(3) {
println!("Surface gravity: {}", gravity);
}
}
Ok((
```
<Overlap Ratio: 0.9633757961783439>

---

--- 224 --
Question ID: 3863099a09f96fdd1c286caad2c5672a87791b1b_0
Original Code:
```
fn insert_header_with_configuration_change(
		backend: &Backend<Block>,
		number: u64,
		parent_hash: H256,
		changes: Option<Vec<(Vec<u8>, Vec<u8>)>>,
		new_configuration: Option<ChangesTrieConfiguration>,
	) -> H256 {
		let mut digest = Digest::default();
		let mut changes_trie_update = Default::default();
		if let Some(changes) = changes {
			let (root, update) = prepare_changes(changes);
			digest.push(DigestItem::ChangesTrieRoot(root));
			changes_trie_update = update;
		}
		digest.push(DigestItem::ChangesTrieSignal(ChangesTrieSignal::NewConfiguration(new_configuration)));

		let header = Header {
			number,
			parent_hash,
			state_root: BlakeTwo256::trie_root(Vec::new()),
			digest,
			extrinsics_root: Default::default(),
		};
		let header_hash = header.hash();

		let block_id = if number == 0 {
			BlockId::Hash(Default::default())
		} else {
			BlockId::Number(number - 1)
		};
		let mut op = backend.begin_operation().unwrap();
		backend.begin_state_operation(&mut op, block_id).unwrap();
		op.set_block_data(header, None, None, None, NewBlockState::Best).unwrap();
		op.update_changes_trie((changes_trie_update, ChangesTrieCacheAction::Clear)).unwrap();
		backend.commit_operation(op).unwrap();

		header_hash
	}
```


Overlapping Code:
```
der_with_configuration_change(
backend: &Backend<Block>,
number: u64,
parent_hash: H256,
changes: Option<Vec<(Vec<u8>, Vec<u8>)>>,
new_configuration: Option<ChangesTrieConfiguration>,
) -> H256 {
let mut digest = Digest::default();
let mut changes_trie_update = Default::default();
if let Some(changes) = changes {
let (root, update) = prepare_changes(changes);
digest.push(DigestItem::ChangesTrieRoot(root));
changes_trie_update = update;
}
digest.push(DigestItem::ChangesTrieSignal(ChangesTrieSignal::NewConfiguration(new_configuration)));
let header = Header {
number,
parent_hash,
state_root: BlakeTwo256::trie_root(Vec::new()),
digest,
extrinsics_root: Default::default(),
};
let header_hash = header.hash();
let block_id = if number == 0 {
BlockId::Hash(Default::default())
} else {
BlockId::Number(number - 1)
};
let mut op = backend.begin_operation().unwrap();
backend.begin_state_operation(&mut op, block_id).unwrap();
op.set_block_data(header, None, None, None, NewBlockState::Best).unwrap();
op.update_changes_trie((changes_trie_update, ChangesTrieCacheAction::Clear)).unwrap();
backend.commit_operation(op).unwrap();
header_hash
```
<Overlap Ratio: 0.987012987012987>

---

--- 225 --
Question ID: ceaf60f189248fa5fd48952aede09a7a325d9f39_33
Original Code:
```
pub fn deser_operation_crate_operation_create_load_balancer(
    inp: &[u8],
    mut builder: crate::output::create_load_balancer_output::Builder,
) -> Result<crate::output::create_load_balancer_output::Builder, aws_smithy_xml::decode::XmlError> {
    use std::convert::TryFrom;
    let mut doc = aws_smithy_xml::decode::Document::try_from(inp)?;

    #[allow(unused_mut)]
    let mut decoder = doc.root_element()?;
    let start_el = decoder.start_el();
    if !(start_el.matches("CreateLoadBalancerResponse")) {
        return Err(aws_smithy_xml::decode::XmlError::custom(format!(
            "invalid root, expected CreateLoadBalancerResponse got {:?}",
            start_el
        )));
    }
    if let Some(mut result_tag) = decoder.next_tag() {
        let start_el = result_tag.start_el();
        if !(start_el.matches("CreateLoadBalancerResult")) {
            return Err(aws_smithy_xml::decode::XmlError::custom(format!(
                "invalid result, expected CreateLoadBalancerResult got {:?}",
                start_el
            )));
        }
        while let Some(mut tag) = result_tag.next_tag() {
            match tag.start_el() {
            s if s.matches("LoadBalancers") /* LoadBalancers com.amazonaws.elasticloadbalancingv2.synthetic#CreateLoadBalancerOutput$LoadBalancers */ =>  {
                let var_34 =
                    Some(
                        crate::xml_deser::deser_list_com_amazonaws_elasticloadbalancingv2_load_balancers(&mut tag)
                        ?
                    )
                ;
                builder = builder.set_load_balancers(var_34);
            }
            ,
            _ => {}
        }
        }
    } else {
        return Err(aws_smithy_xml::decode::XmlError::custom(
            "expected CreateLoadBalancerResult tag",
        ));
    };
    Ok(builder)
}
```


Overlapping Code:
```
pub fn deser_operation_crate_operation_create_load_balancer(
inp: &[u8],
mut builder: crate::output::create_load_balancer_output::Builder,
) -> Result<crate::output::create_load_balancer_output::Builder, aws_smithy_xml::decode::XmlError> {
use std::convert::TryFrom;
let mut doc = aws_smithy_xml::decode::Document::try_from(inp)?;
#[allow(unused_mut)]
let mut decoder = doc.root_element()?;
let start_el = decoder.start_el();
if !(start_el.matches("CreateLoadBalancerResponse")) {
return Err(aws_smithy_xml::decode::XmlError::custom(format!(
"invalid root, expected CreateLoadBalancerResponse got {:?}",
start_el
)));
}
if let Some(mut result_tag) = decoder.next_tag() {
let start_el = result_tag.start_el();
if !(start_el.matches("CreateLoadBalancerResult")) {
return Err(aws_smithy_xml::decode::XmlError::custom(format!(
"invalid result, expected CreateLoadBalancerResult got {:?}",
start_el
)));
}
while let Some(mut tag) = result_tag.next_tag() {
match tag.start_el() {
s if s.matches("LoadBalancers") /* LoadBalancers com.amazonaws.elasticloadbalancingv2.synthetic#CreateLoadBalancerOutput$LoadBalancers */ => {
let var_34 =
Some(
crate::xml_deser::deser_list_com_amazonaws_elasticloadbalancingv2_load_balancers(&mut tag)
?
)
;
builder = builder.set_load_balancers(var_34);
}
,
_ => {}
}
}
} else {
return Err(aws_smithy_xml::decode::XmlError::custom(
"expected CreateLoadBalancerResult tag",
));
};
Ok(build
```
<Overlap Ratio: 0.9964739069111425>

---

--- 226 --
Question ID: 7b2ec5c14c6162741e31364c08f77bad4b609af4_53
Original Code:
```
fn is_possible_for_an_already_delegated_node() {
            let mut deps = helpers::init_contract();
            let gateway_owner = "bob";
            let identity = add_gateway(gateway_owner, good_gateway_bond(), &mut deps);
            let delegation_owner = Addr::unchecked("sender");

            let delegation1 = coin(100, DENOM);
            let delegation2 = coin(50, DENOM);

            try_delegate_to_gateway(
                deps.as_mut(),
                mock_env(),
                mock_info(delegation_owner.as_str(), &vec![delegation1.clone()]),
                identity.clone(),
            )
            .unwrap();

            try_delegate_to_gateway(
                deps.as_mut(),
                mock_env(),
                mock_info(delegation_owner.as_str(), &vec![delegation2.clone()]),
                identity.clone(),
            )
            .unwrap();

            assert_eq!(
                RawDelegationData::new(
                    delegation1.amount + delegation2.amount,
                    mock_env().block.height
                ),
                gateway_delegations_read(&deps.storage, &identity)
                    .load(delegation_owner.as_bytes())
                    .unwrap()
            );
            assert!(
                reverse_gateway_delegations_read(&deps.storage, &delegation_owner)
                    .load(identity.as_bytes())
                    .is_ok()
            );

            // node's "total_delegation" is sum of both
            assert_eq!(
                delegation1.amount + delegation2.amount,
                gateways_read(&deps.storage)
                    .load(identity.as_bytes())
                    .unwrap()
                    .total_delegation
                    .amount
            )
        }
```


Overlapping Code:
```
sible_for_an_already_delegated_node() {
let mut deps = helpers::init_contract();
let gateway_owner = "bob";
let identity = add_gateway(gateway_owner, good_gateway_bond(), &mut deps);
let delegation_owner = Addr::unchecked("sender");
let delegation1 = coin(100, DENOM);
let delegation2 = coin(50, DENOM);
try_delegate_to_gateway(
deps.as_mut(),
mock_env(),
mock_info(delegation_owner.as_str(), &vec![delegation1.clone()]),
identity.clone(),
)
.unwrap();
try_delegate_to_gateway(
deps.as_mut(),
mock_env(),
mock_info(delegation_owner.as_str(), &vec![delegation2.clone()]),
identity.clone(),
)
.unwrap();
assert_eq!(
RawDelegationData::new(
delegation1.amount + delegation2.amount,
mock_env().block.height
),
gateway_delegations_read(&deps.storage, &identity)
.load(delegation_owner.as_bytes())
.unwrap()
);
assert!(
reverse_gateway_delegations_read(&deps.storage, &delegation_owner)
.load(identity.as_bytes())
.is_ok()
);
// node's "total_delegation" is sum of both
assert_eq!(
delegation1.amount + delegation2.amount,
gateways_read(&deps.storage)
.load(identity.as_bytes())
.unwrap()
.total_delegatio
```
<Overlap Ratio: 0.9803746654772525>

---

--- 227 --
Question ID: ab995d2c452535936ef07503967df939967f3aaa_0
Original Code:
```
async fn it_test_prometheus_metrics() {
        let mut mock_service = MockRouterService::new();
        mock_service
            .expect_call()
            .times(1)
            .returning(move |req: RouterRequest| {
                Ok(RouterResponse::fake_builder()
                    .context(req.context)
                    .build()
                    .unwrap()
                    .boxed())
            });

        let mut dyn_plugin: Box<dyn DynPlugin> = crate::plugin::plugins()
            .get("apollo.telemetry")
            .expect("Plugin not found")
            .create_instance(
                &Value::from_str(
                    r#"{
                "apollo": {
                    "client_name_header": "name_header",
                    "client_version_header": "version_header",
                    "schema_id": "schema_sha"
                },
                "metrics": {
                    "common": {
                        "attributes": {
                            "from_headers": [
                                {
                                    "named": "test",
                                    "default": "default_value",
                                    "rename": "renamed_value"
                                },
                                {
                                    "named": "another_test",
                                    "default": "my_default_value"
                                }
                            ],
                            "static": [
                                {
                                    "name": "myname",
                                    "value": "label_value"
                                }
                            ]
                        }
                    },
                    "prometheus": {
                        "enabled": true
                    }
                }
            }"#,
                )
                .unwrap(),
            )
            .await
            .unwrap();
        let mut router_service = dyn_plugin.router_service(BoxService::new(mock_service.build()));
        let router_req = RouterRequest::fake_builder().header("test", "my_value_set");

        let _router_response = router_service
            .ready()
            .await
            .unwrap()
            .call(router_req.build().unwrap())
            .await
            .unwrap()
            .next_response()
            .await
            .unwrap();

        let handler = dyn_plugin.custom_endpoint().unwrap();
        let http_req_prom = http_compat::Request::fake_builder()
            .uri(Uri::from_static(
                "http://localhost:4000/BADPATH/apollo.telemetry/prometheus",
            ))
            .method(Method::GET)
            .body(Bytes::new())
            .build()
            .unwrap();
        let resp = handler.clone().oneshot(http_req_prom).await.unwrap();
        assert_eq!(resp.status(), StatusCode::NOT_FOUND);

        let http_req_prom = http_compat::Request::fake_builder()
            .uri(Uri::from_static(
                "http://localhost:4000/plugins/apollo.telemetry/prometheus",
            ))
            .method(Method::GET)
            .body(Bytes::new())
            .build()
            .unwrap();
        let resp = handler.oneshot(http_req_prom).await.unwrap();
        assert_eq!(resp.status(), StatusCode::OK);
        match resp.body() {
            crate::ResponseBody::Text(prom_metrics) => {
                assert!(prom_metrics.contains(r#"http_requests_total{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200"} 1"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_count{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.001"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.005"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.015"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.05"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.3"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.4"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="0.5"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="1"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="5"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="10"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_bucket{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200",le="+Inf"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_count{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200"}"#));
                assert!(prom_metrics.contains(r#"http_request_duration_seconds_sum{another_test="my_default_value",myname="label_value",renamed_value="my_value_set",status="200"}"#));
            }
            _ => panic!("body does not have the right format"),
        }
    }
```


Overlapping Code:
```
{
let mut mock_service = MockRouterService::new();
mock_service
.expect_call()
.times(1)
.returning(move |req: RouterRequest| {
Ok(RouterResponse::fake_builder()
.context(req.context)
.build()
.unwrap()
.boxed())
});
let mut dyn_plugin: Box<dyn DynPlugin> = crate::plugin::plugins()
.get("apollo.telemetry")
.expect("Plugin not found")
.create_instance(
&Value::from_str(
r#"{
"apollo": {
"client_name_header": "name_header",
"client_version_header": "version_header",
"schema_id": "schema_sha"
},
"metrics": {
"common": {
"attributes": {
"from_headers": [
{
"named": "test",
"default": "default_value",
"rename": "renamed_value"
},
{
"named": "another_test",
"default": "my_default_value"
}
],
"static": [
{
"name": "myname",
"value": "label_value"
}
]
}
},
"prometheus": {
"enabled": true
}
}
}"#,
)
.unwrap(),
)
.await
.unwrap();
let mut router_service = dyn_plugin.router_service(BoxService::new(mock_service.build()));
let router_req = RouterRequest::fake_builder().header("test", "my_value_set");
let _router_response = router_service
.ready()
.await
.unwrap()
.call(router_req.build().unwrap())
.await
.unwrap()
.next_response()
.await
.unwrap();
```
<Overlap Ratio: 0.9584372402327515>

---

--- 228 --
Question ID: 40a4099c379c46d3ff5f65c2b90445fe38fe5822_3
Original Code:
```
fn subr(&mut self) -> Result<Ipv4Addr, Self::Error> {
        let mut subr = Ipv4Addr::UNSPECIFIED;
        self.read(reg::SUBR, COMMON_BLOCK_OFFSET, &mut subr.octets)?;
        Ok(subr)
    }
```


Overlapping Code:
```
ror> {
let mut subr = Ipv4Addr::UNSPECIFIED;
self.read(reg::SUBR, COMMON_BLOCK_OFFSET, &mut subr.oct
```
<Overlap Ratio: 0.6097560975609756>

---

--- 229 --
Question ID: 5fb6127847771f22d3c822eae64d7f4a54547e02_10
Original Code:
```
fn lore() -> String {
    let mut ret = String::from("Barkeep:");
    ret = format!("{} Angry Karen says that the Rusty Dragon killed her children.\nWe all know that's a lie...", ret);
    ret
}
```


Overlapping Code:
```
om("Barkeep:");
ret = format!("{} Angry Karen says that the Rusty Dragon killed her children.\nWe al
```
<Overlap Ratio: 0.5494505494505495>

---

--- 230 --
Question ID: d91ed3814ba30744bf9d2196311636223d81b5d7_8
Original Code:
```
pub extern "C" fn all_generated_locations_for(
    mappings: *mut Mappings<Observer>,
    source: u32,
    original_line: u32,
    has_original_column: bool,
    original_column: u32,
) {
    let this_scope = ();
    let mappings = unsafe { mappings_mut(&this_scope, mappings) };

    let original_column = if has_original_column {
        Some(original_column)
    } else {
        None
    };

    for m in mappings.all_generated_locations_for(source, original_line, original_column) {
        unsafe {
            invoke_mapping_callback(m);
        }
    }
}
```


Overlapping Code:
```
n all_generated_locations_for(
mappings: *mut Mappings<Observer>,
source: u32,
original_line: u32,
has_original_column: bool,
original_column: u32,
) {
let this_scope = ();
let mappings = unsafe { mappings_mut(&this_scope, mappings) };
let original_column = if has_original_column {
Some(original_column)
} else {
None
};
for m in mappings.all_generated_locations_for(source, original_line, original_column) {
unsafe {
invoke_mapping_callback(m);
}
}
```
<Overlap Ratio: 0.9615384615384616>

---

--- 231 --
Question ID: 8166c572bfaef0679b0b7305c6ec91d4344aeac1_2
Original Code:
```
fn run_handler_no_request<Resp, F>(f: F) -> Result<Resp>
where
    F: FnOnce(Sandbox) -> Result<Resp>,
{
    let sandbox = Sandbox::new().context(SandboxCreation)?;
    let resp = f(sandbox)?;
    Ok(resp)
}
```


Overlapping Code:
```
run_handler_no_request<Resp, F>(f: F) -> Result<Resp>
where
F: FnOnce(Sandbox) -> Result<Resp>,
{
let sandbox = Sandbox::new().context(SandboxCreation)?;
let resp = f(sandbox)
```
<Overlap Ratio: 0.9162303664921466>

---

--- 232 --
Question ID: 145a76c705315bebea22d96a3d1a877ff5f4ba5b_0
Original Code:
```
fn test_init() {
        let dst = Path::new("dst_test_init_writer");
        std::fs::create_dir(dst).unwrap();
        let _ = WriterDoc::new(dst, "en", Some(1_000_000));
        std::fs::remove_dir_all(dst).unwrap();
    }
```


Overlapping Code:
```
t_init() {
let dst = Path::new("dst_test_init_writer");
std::fs::create_dir(dst).unwrap();
let _ = WriterDoc::new(dst, "en", Some(1_000_000));
std::fs::remove_di
```
<Overlap Ratio: 0.8518518518518519>

---

--- 233 --
Question ID: cca810b0a2c1dd3ee2d3aa3a33344cfbf67bbbb8_1
Original Code:
```
fn _cmp_bytes_16(a_ptr: *const u8, b_ptr: *const u8) -> Ordering {
    let aa_ptr = a_ptr as *const u128;
    let bb_ptr = b_ptr as *const u128;
    let aac = unsafe { *aa_ptr };
    let bbc = unsafe { *bb_ptr };
    let bits = aac ^ bbc;
    if bits != 0 {
        let pos = (bits.trailing_zeros() / 8) as usize;
        let aa_ptr = unsafe { a_ptr.add(pos) };
        let bb_ptr = unsafe { b_ptr.add(pos) };
        let aac = unsafe { *aa_ptr };
        let bbc = unsafe { *bb_ptr };
        aac.cmp(&bbc)
    } else {
        Ordering::Equal
    }
}
```


Overlapping Code:
```
es_16(a_ptr: *const u8, b_ptr: *const u8) -> Ordering {
let aa_ptr = a_ptr as *const u128;
let bb_ptr = b_ptr as *const u128;
let aac = unsafe { *aa_ptr };
let bbc = unsafe { *bb_ptr };
let bits = aac ^ bbc;
if bits != 0 {
let pos = (bits.trailing_zeros() / 8) as usize;
let aa_ptr = unsafe { a_ptr.add(pos) };
let bb_ptr = unsafe { b_ptr.add(pos) };
let aac = unsafe { *aa_ptr };
let bbc = unsafe { *bb_ptr };
aac.cmp(&bbc)
} else {
Ordering::Equal

```
<Overlap Ratio: 0.9698275862068966>

---

--- 234 --
Question ID: 3d2f9b7c606e02ad5e3851c7dc9d48cc8915be9e_0
Original Code:
```
fn print_usage(to: PrintDestination) {
    let prog_name = PathBuf::from(env::args_os().next().unwrap())
        .file_name()
        .unwrap()
        .to_string_lossy()
        .to_string();
    let usage = format!(
        "{N} [-{h}|{V}] [-{x}] [-{P} PUBLIC_KEY]\n\
         {w:width$} [-{E} SIG_PATH] [-{e} SHA256]\n\
         {w:width$} [-{S} SIG_PATH] [-{s} SHA256]\n\
         {w:width$} <EXECUTABLE_PATH> [<SCRIPT_PATH>] [..ARGS]\n\n\
         [-{h}] * Print help and exit\n\
         [-{V}] * Print version and exit\n\
         [-{x}] * Use execve()\n\
         [-{P}] * Minisign base64 public key\n\
         [-{E}] * Executable signature path\n\
         [-{e}] * Executable hash\n\
         [-{S}] * Script signature path\n\
         [-{s}] * Script hash",
        N = prog_name,
        h = flag::HELP,
        V = flag::VERSION,
        x = flag::EXEC,
        P = flag::PUBLIC_KEY,
        E = flag::EXECUTABLE_SIG_PATH,
        e = flag::EXECUTABLE_HASH,
        S = flag::SCRIPT_SIG_PATH,
        s = flag::SCRIPT_HASH,
        w = "",
        width = prog_name.chars().count(),
    );
    match to {
        PrintDestination::Stdout => println!("{}", usage),
        PrintDestination::Stderr => eprintln!("{}", usage),
    }
}
```


Overlapping Code:
```
tDestination) {
let prog_name = PathBuf::from(env::args_os().next().unwrap())
.file_name()
.unwrap()
.to_string_lossy()
.to_string();
let usage = format!(
"{N} [-{h}|{V}] [-{x}] [-{P} PUBLIC_KEY]\n\
{w:width$} [-{E} SIG_PATH] [-{e} SHA256]\n\
{w:width$} [-{S} SIG_PATH] [-{s} SHA256]\n\
{w:width$} <EXECUTABLE_PATH> [<SCRIPT_PATH>] [..ARGS]\n\n\
[-{h}] * Print help and exit\n\
[-{V}] * Print version and exit\n\
[-{x}] * Use execve()\n\
[-{P}] * Minisign base64 public key\n\
[-{E}] * Executable signature path\n\
[-{e}] * Executable hash\n\
[-{S}] * Script signature path\n\
[-{s}] * Script hash",
N = prog_name,
h = flag::HELP,
V = flag::VERSION,
x = flag::EXEC,
P = flag::PUBLIC_KEY,
E = flag::EXECUTABLE_SIG_PATH,
e = flag::EXECUTABLE_HASH,
S = flag::SCRIPT_SIG_PATH,
s = flag::SCRIPT_HASH,
w = "",
width = prog_name.chars().count(),
);
match to {
PrintDestination::Stdout => println!("{}", usage),
PrintDestination::Stderr => eprintln!("{}", us
```
<Overlap Ratio: 0.9674134419551935>

---

--- 235 --
Question ID: 83fb55ac55ad311397f4a8d72e4bfbae1bff2476_1
Original Code:
```
fn port_midi_can_get_max_event_size() {
        // open clients and ports
        let c = open_test_client("port_midi_cglc");
        let mut out_p = c.register_port("op", MidiOut::default()).unwrap();

        // set callback routine
        let process_callback = move |_: &Client, ps: &ProcessScope| -> Control {
            let out_p = out_p.writer(ps);
            PMCGMES_MAX_EVENT_SIZE.fetch_add(out_p.max_event_size(), Ordering::Relaxed);
            Control::Continue
        };

        // activate
        let ac = c
            .activate_async((), ClosureProcessHandler::new(process_callback))
            .unwrap();

        // check correctness
        assert!(PMCGMES_MAX_EVENT_SIZE.load(Ordering::Relaxed) > 0);
        ac.deactivate().unwrap();
    }
```


Overlapping Code:
```
_midi_can_get_max_event_size() {
// open clients and ports
let c = open_test_client("port_midi_cglc");
let mut out_p = c.register_port("op", MidiOut::default()).unwrap();
// set callback routine
let process_callback = move |_: &Client, ps: &ProcessScope| -> Control {
let out_p = out_p.writer(ps);
PMCGMES_MAX_EVENT_SIZE.fetch_add(out_p.max_event_size(), Ordering::Relaxed);
Control::Continue
};
// activate
let ac = c
.activate_async((), ClosureProcessHandler::new(process_callback))
.unwrap();
// check correctness
assert!(PMCGMES_MAX_EVENT_SIZE.load(Ordering::Relaxed) > 0);
ac.deactivate().unwrap
```
<Overlap Ratio: 0.9803921568627451>

---

--- 236 --
Question ID: cfb3a96a647bb99322d2148319a8c351b42fe18a_2
Original Code:
```
fn block_invalidated() {
    let data = vec![Node::new("Camper")];
    let mut fix_node_state = fix(data);
    fix_node_state.transactions[0].event = Events::BlockInvalidated;
    let (chain, _) = mine(fix_node_state).expect("result to be chain");
    assert_eq!(chain.get_last_block().unwrap().data[0].racks, 0);
    assert_eq!(chain.get_last_block().unwrap().data[0].tokens, 19);
    assert_eq!(chain.get_last_block().unwrap().data[0].reputation, 0);
}
```


Overlapping Code:
```
 data = vec![Node::new("Camper")];
let mut fix_node_state = fix(data);
fix_node_state.transactions[0].event = Events::BlockInvalidated;
let (chain, _) = mine(fix_node_state).expect("result to be chain");
assert_eq!(chain.get_last_block().unwrap().data[0].racks, 0);
assert_eq!(chain.get_last_block().unwrap().data[0].tokens, 19);
assert_eq!(chain.get
```
<Overlap Ratio: 0.8215962441314554>

---

--- 237 --
Question ID: 07a534096d670567b68a8c0a91fabca805b06e05_1
Original Code:
```
fn view_macroblock_history(model: &Model) -> Vec<Node<GMsg>> {
    let is_visible = !model.frames.is_empty() && model.selected_macroblock.is_some();
    let is_hint_visible = !model.frames.is_empty() && model.selected_macroblock.is_none();
    let canvas_attrs = attrs! {
        At::Width => 128,
        At::Height => 128,
    };
    let macroblock_info = model
        .selected_macroblock
        .map(|i| &model.frames[model.selected_frame].stats.macroblock_info[i]);
    let kind = macroblock_info.map(|x| &x.kind);
    let previous_reference_text = match kind {
        Some(MacroblockInfoKind::Intra) => "intra",
        Some(MacroblockInfoKind::Moved { .. } | MacroblockInfoKind::Interpolated { .. }) => {
            "direction"
        }
        _ => "",
    };

    nodes![
        div![
            C!["macroblock-history"],
            C![IF!(!is_visible => "-hidden")],
            h3!["Macroblock history"],
            p![
                "Macroblock type: ",
                kind.map(|x| strong![format_macroblock_kind(x).to_string()])
            ],
            div![
                C!["history-container"],
                IF!(matches!(kind, Some(MacroblockInfoKind::Skipped)) => C!["-skipped"]),
                IF!(matches!(kind, Some(MacroblockInfoKind::Intra)) => C!["-intra"]),
                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: true, ..  })) => C!["-forward"]),
                IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: false, ..  })) => C!["-backward"]),
                IF!(matches!(kind, Some(MacroblockInfoKind::Interpolated { ..  })) => C!["-interpolated"]),
                div![
                    C!["image previous-reference"],
                    canvas![
                        &canvas_attrs,
                        el_ref(&model.canvas_history_previous_reference)
                    ],
                    "Previous reference"
                ],
                div![
                    C!["arrow -right from-previous-reference"],
                    attrs! {At::from("data-text") => previous_reference_text},
                ],
                div![
                    C!["image previous-before-diff"],
                    canvas![
                        &canvas_attrs,
                        el_ref(&model.canvas_history_previous_before_diff)
                    ],
                    "Moved macroblock"
                ],
                div![
                    C!["arrow -right from-previous-before-diff"],
                    attrs! {At::from("data-text") => "difference"},
                ],
                div![
                    C!["vertical-container"],
                    div![
                        C!["image interpolated"],
                        canvas![&canvas_attrs, el_ref(&model.canvas_history_interpolated)],
                        "Interpolation result"
                    ],
                    div![
                        C!["arrow -down from-interpolated"],
                        attrs! {At::from("data-text") => "difference"},
                    ],
                    div![
                        C!["image result"],
                        canvas![&canvas_attrs, el_ref(&model.canvas_history_result)],
                        "Result"
                    ],
                ],
                div![
                    C!["arrow -left from-next-before-diff"],
                    attrs! {At::from("data-text") => "difference"},
                ],
                div![
                    C!["image next-before-diff"],
                    canvas![
                        &canvas_attrs,
                        el_ref(&model.canvas_history_next_before_diff)
                    ],
                    "Moved macroblock"
                ],
                div![
                    C!["arrow -left from-next-reference"],
                    attrs! {At::from("data-text") => "direction"},
                ],
                div![
                    C!["image next-reference"],
                    canvas![&canvas_attrs, el_ref(&model.canvas_history_next_reference)],
                    "Next reference"
                ],
            ]
        ]
        div![
            C!["macroblock-selection-hint"],
            C![IF!(!is_hint_visible => "-hidden")],
            strong!["Hint: "],
            "Click on the frame above to show information about corresponding macroblock"
        ]
    ]
}
```


Overlapping Code:
```
k_history(model: &Model) -> Vec<Node<GMsg>> {
let is_visible = !model.frames.is_empty() && model.selected_macroblock.is_some();
let is_hint_visible = !model.frames.is_empty() && model.selected_macroblock.is_none();
let canvas_attrs = attrs! {
At::Width => 128,
At::Height => 128,
};
let macroblock_info = model
.selected_macroblock
.map(|i| &model.frames[model.selected_frame].stats.macroblock_info[i]);
let kind = macroblock_info.map(|x| &x.kind);
let previous_reference_text = match kind {
Some(MacroblockInfoKind::Intra) => "intra",
Some(MacroblockInfoKind::Moved { .. } | MacroblockInfoKind::Interpolated { .. }) => {
"direction"
}
_ => "",
};
nodes![
div![
C!["macroblock-history"],
C![IF!(!is_visible => "-hidden")],
h3!["Macroblock history"],
p![
"Macroblock type: ",
kind.map(|x| strong![format_macroblock_kind(x).to_string()])
],
div![
C!["history-container"],
IF!(matches!(kind, Some(MacroblockInfoKind::Skipped)) => C!["-skipped"]),
IF!(matches!(kind, Some(MacroblockInfoKind::Intra)) => C!["-intra"]),
IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: true, .. })) => C!["-forward"]),
IF!(matches!(kind, Some(MacroblockInfoKind::Moved { is_forward: false, .. })) => C!["-backward"]),
IF!(matches!(kind, Some(MacroblockInfoKind::Interpolated { .. })) => C!["-interpolated"]),
div![
C!["image previous-reference"],
canvas![
&canvas_attrs,
el_ref(&model.canvas_history_previous_reference)
],
"Previous reference"
],
div![
C!["arrow -right from-previous-reference"],
attrs! {At::from("data-text") => previous_reference_text},
],
div![
C!["image previous-before-diff"],
canvas![
&canvas_attrs,
el_ref(&model.canvas_history_previous_before_diff)
],
"Moved macroblock"
],
div![
C![
```
<Overlap Ratio: 0.9730967372638809>

---

--- 238 --
Question ID: 0a8fc331e7e14b48c185d68d0b0f4a8a317aa9f6_2
Original Code:
```
fn test_file_writer_empty_file() {
        let file = tempfile::tempfile().unwrap();

        let schema = Arc::new(
            types::Type::group_type_builder("schema")
                .with_fields(&mut vec![Arc::new(
                    types::Type::primitive_type_builder("col1", Type::INT32)
                        .build()
                        .unwrap(),
                )])
                .build()
                .unwrap(),
        );
        let props = Arc::new(WriterProperties::builder().build());
        let writer =
            SerializedFileWriter::new(file.try_clone().unwrap(), schema, props).unwrap();
        writer.close().unwrap();

        let reader = SerializedFileReader::new(file).unwrap();
        assert_eq!(reader.get_row_iter(None).unwrap().count(), 0);
    }
```


Overlapping Code:
```
le_writer_empty_file() {
let file = tempfile::tempfile().unwrap();
let schema = Arc::new(
types::Type::group_type_builder("schema")
.with_fields(&mut vec![Arc::new(
types::Type::primitive_type_builder("col1", Type::INT32)
.build()
.unwrap(),
)])
.build()
.unwrap(),
);
let props = Arc::new(WriterProperties::builder().build());
let writer =
SerializedFileWriter::new(file.try_clone().unwrap(), schema, props).unwrap();
writer.close().unwrap();
let reader = SerializedFileReader::new(file).unwrap();
assert_eq!(reader.get_row_iter(None).unwrap().count
```
<Overlap Ratio: 0.9666080843585237>

---

--- 239 --
Question ID: 95bc49a8b217eb1c78014d3e8bd43e9a68bd51a4_0
Original Code:
```
pub fn search(
	pid: &Pid,
	region: &(usize, usize),
	pattern: &Pattern,
) -> Result<(usize, Vec<u8>), MemError> {
	let end = region.1;
	let find = pattern.len();
	let mut chunk_size = CHUNK_SIZE;
	let mut pointer = region.0;
	let mut criteria = pattern.iter();
	let mut found = vec![];
	let mut at = 0;

	loop {
		// Avoid overreach
		if pointer + chunk_size > end {
			chunk_size = end - pointer;
		}

		// Read memory region one chunk at a time
		let chunk = read(pid, pointer, chunk_size)?;

		// Try to find pattern
		for (idx, mbyte) in chunk.iter().enumerate() {
			if let Some(byte) = criteria.next().unwrap() {
				// Found one
				if byte == mbyte {
					found.push(*mbyte);

					// Set "at" on first discovery
					if found.len() == 1 {
						at = pointer + idx;
					}
				} else {
					// Doesn't match, reset
					found.clear();
					criteria = pattern.iter();
				}
			} else {
				// Skip (None) is still considered found
				found.push(*mbyte);
			}

			// Found what there is to find
			if found.len() == find {
				return Ok((at, found));
			}
		}

		// Set next chunk
		pointer += chunk.len();

		// End of region, never found it sadly
		if pointer == end {
			break;
		}
	}

	Err(MemError::Read("Could not find pattern '{pattern}'".into()))?
}
```


Overlapping Code:
```
gion: &(usize, usize),
pattern: &Pattern,
) -> Result<(usize, Vec<u8>), MemError> {
let end = region.1;
let find = pattern.len();
let mut chunk_size = CHUNK_SIZE;
let mut pointer = region.0;
let mut criteria = pattern.iter();
let mut found = vec![];
let mut at = 0;
loop {
// Avoid overreach
if pointer + chunk_size > end {
chunk_size = end - pointer;
}
// Read memory region one chunk at a time
let chunk = read(pid, pointer, chunk_size)?;
// Try to find pattern
for (idx, mbyte) in chunk.iter().enumerate() {
if let Some(byte) = criteria.next().unwrap() {
// Found one
if byte == mbyte {
found.push(*mbyte);
// Set "at" on first discovery
if found.len() == 1 {
at = pointer + idx;
}
} else {
// Doesn't match, reset
found.clear();
criteria = pattern.iter();
}
} else {
// Skip (None) is still considered found
found.push(*mbyte);
}
// Found what there is to find
if found.len() == find {
return Ok((at, found));
}
}
// Set next chunk
pointer += chunk.len();
// End of region, never found it sadly
if pointer == end {
break;
}
}
Err(MemError::Read("
```
<Overlap Ratio: 0.9333333333333333>

---

--- 240 --
Question ID: bcc092c580a9eb1ce5fc7439659eb198af30bef5_3
Original Code:
```
fn single_many_guard() {
    assert_eq!(SingleManyGuard::check::<()>(&[]), Ok(()));
    assert_eq!(SingleManyGuard::check::<()>(&[0]), Ok(()));
    assert_eq!(SingleManyGuard::check::<()>(&[0, 1]), Ok(()));
    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2]), Ok(()));
    assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2, 3]), Ok(()));
}
```


Overlapping Code:
```
 single_many_guard() {
assert_eq!(SingleManyGuard::check::<()>(&[]), Ok(()));
assert_eq!(SingleManyGuard::check::<()>(&[0]), Ok(()));
assert_eq!(SingleManyGuard::check::<()>(&[0, 1]), Ok(()));
assert_eq!(SingleManyGuard::check::<()>(&[0, 1, 2]), Ok(()));
assert_eq!(SingleManyGuard::check::<()>(&[0, 
```
<Overlap Ratio: 0.9287925696594427>

---

--- 241 --
Question ID: 3039187fc8301af3e6678fad9c3dedec7f2aa613_82
Original Code:
```
pub fn deser_operation_crate_operation_update_ip_set(
    value: &[u8],
    mut builder: crate::output::update_ip_set_output::Builder,
) -> Result<crate::output::update_ip_set_output::Builder, aws_smithy_json::deserialize::Error> {
    let mut tokens_owned =
        aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))
            .peekable();
    let tokens = &mut tokens_owned;
    aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;
    loop {
        match tokens.next().transpose()? {
            Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,
            Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {
                match key.to_unescaped()?.as_ref() {
                    "ChangeToken" => {
                        builder = builder.set_change_token(
                            aws_smithy_json::deserialize::token::expect_string_or_null(
                                tokens.next(),
                            )?
                            .map(|s| s.to_unescaped().map(|u| u.into_owned()))
                            .transpose()?,
                        );
                    }
                    _ => aws_smithy_json::deserialize::token::skip_value(tokens)?,
                }
            }
            other => {
                return Err(aws_smithy_json::deserialize::Error::custom(format!(
                    "expected object key or end object, found: {:?}",
                    other
                )))
            }
        }
    }
    if tokens.next().is_some() {
        return Err(aws_smithy_json::deserialize::Error::custom(
            "found more JSON tokens after completing parsing",
        ));
    }
    Ok(builder)
}
```


Overlapping Code:
```
peration_crate_operation_update_ip_set(
value: &[u8],
mut builder: crate::output::update_ip_set_output::Builder,
) -> Result<crate::output::update_ip_set_output::Builder, aws_smithy_json::deserialize::Error> {
let mut tokens_owned =
aws_smithy_json::deserialize::json_token_iter(crate::json_deser::or_empty_doc(value))
.peekable();
let tokens = &mut tokens_owned;
aws_smithy_json::deserialize::token::expect_start_object(tokens.next())?;
loop {
match tokens.next().transpose()? {
Some(aws_smithy_json::deserialize::Token::EndObject { .. }) => break,
Some(aws_smithy_json::deserialize::Token::ObjectKey { key, .. }) => {
match key.to_unescaped()?.as_ref() {
"ChangeToken" => {
builder = builder.set_change_token(
aws_smithy_json::deserialize::token::expect_string_or_null(
tokens.next(),
)?
.map(|s| s.to_unescaped().map(|u| u.into_owned()))
.transpose()?,
);
}
_ => aws_smithy_json::deserialize::token::skip_value(tokens)?,
}
}
other => {
return Err(aws_smithy_json::deserialize::Error::custom(format!(
"expected object key or end object, found: {:?}",
other
)))
}
}
}
if tokens.next().is_some() {
return Err(aws_smithy_json::deserialize::Error::custom(
"found more JSON tokens after completing parsing",
));
}
Ok(builder)
}
```
<Overlap Ratio: 0.9886914378029079>

---

--- 242 --
Question ID: ac096c0c3ed3e5b617cbc97791f86f7d40c63540_0
Original Code:
```
fn commit_should_work() {
		let mut ext = TestExternalities::<Blake2Hasher>::default();
		ext.set_storage(b"doe".to_vec(), b"reindeer".to_vec());
		ext.set_storage(b"dog".to_vec(), b"puppy".to_vec());
		ext.set_storage(b"dogglesworth".to_vec(), b"cat".to_vec());
		const ROOT: [u8; 32] = hex!("0b33ed94e74e0f8e92a55923bece1ed02d16cf424e124613ddebc53ac3eeeabe");
		assert_eq!(ext.storage_root(), H256::from(ROOT));
	}
```


Overlapping Code:
```
_should_work() {
let mut ext = TestExternalities::<Blake2Hasher>::default();
ext.set_storage(b"doe".to_vec(), b"reindeer".to_vec());
ext.set_storage(b"dog".to_vec(), b"puppy".to_vec());
ext.set_storage(b"dogglesworth".to_vec(), b"cat".to_vec());
const ROOT: [u8; 32] = hex!("0b33ed94e74e0f8e92a55923bece1ed02d16cf424e124613ddebc53ac3eeeabe");
assert_
```
<Overlap Ratio: 0.8684863523573201>

---

--- 243 --
Question ID: 3d1bc20cca49ecd0870bab4346977e0260b370b0_15
Original Code:
```
fn test_hash() {
      let mut x = Flags::empty();
      let mut y = Flags::empty();
      assert!(hash::hash(&x) == hash::hash(&y));
      x = Flags::all();
      y = FlagABC;
      assert!(hash::hash(&x) == hash::hash(&y));
    }
```


Overlapping Code:
```
n test_hash() {
let mut x = Flags::empty();
let mut y = Flags::empty();
assert!(hash::hash(&x) == hash::hash(&y));
x = Flags::all();
y = FlagABC;
assert!(hash::hash(&x) == h
```
<Overlap Ratio: 0.9057591623036649>

---

--- 244 --
Question ID: 81fe1b970d24becea38ddd9b06ae49db5bcded3e_2
Original Code:
```
fn bench_disjoint_set_forest(b: &mut test::Bencher) {
        let num_nodes = 500;
        let num_edges = 20 * num_nodes;

        let mut rng: StdRng = SeedableRng::seed_from_u64(1);
        let uniform = Uniform::new(0, num_nodes);

        let mut forest = DisjointSetForest::new(num_nodes);
        b.iter(|| {
            let mut count = 0;
            while count < num_edges {
                let u = uniform.sample(&mut rng);
                let v = uniform.sample(&mut rng);
                forest.union(u, v);
                count += 1;
            }
            test::black_box(forest.num_trees());
        });
    }
```


Overlapping Code:
```
et_forest(b: &mut test::Bencher) {
let num_nodes = 500;
let num_edges = 20 * num_nodes;
let mut rng: StdRng = SeedableRng::seed_from_u64(1);
let uniform = Uniform::new(0, num_nodes);
let mut forest = DisjointSetForest::new(num_nodes);
b.iter(|| {
let mut count = 0;
while count < num_edges {
let u = uniform.sample(&mut rng);
let v = uniform.sample(&mut rng);
forest.union(u, v);
count += 1;
}
test::
```
<Overlap Ratio: 0.8791208791208791>

---

--- 245 --
Question ID: 3e809b385f9b56e557955c72322fdf9b13b17b3e_0
Original Code:
```
fn lexer_text_unit_literal_accepted() {
        let mut lexer = Lexer::from_memory("X", Source::Unknown);
        let mut lexer = WordLexer {
            lexer: &mut lexer,
            context: WordContext::Word,
        };
        let mut called = false;
        let result = block_on(lexer.text_unit(
            |c| {
                called = true;
                assert_eq!(c, 'X');
                false
            },
            |c| panic!("unexpected call to is_escapable({:?})", c),
        ))
        .unwrap()
        .unwrap();
        assert!(called);
        if let Literal(c) = result {
            assert_eq!(c, 'X');
        } else {
            panic!("unexpected result {:?}", result);
        }

        assert_eq!(block_on(lexer.peek_char()), Ok(None));
    }
```


Overlapping Code:
```
nit_literal_accepted() {
let mut lexer = Lexer::from_memory("X", Source::Unknown);
let mut lexer = WordLexer {
lexer: &mut lexer,
context: WordContext::Word,
};
let mut called = false;
let result = block_on(lexer.text_unit(
|c| {
called = true;
assert_eq!(c, 'X');
false
},
|c| panic!("unexpected call to is_escapable({:?})", c),
))
.unwrap()
.unwrap();
assert!(called);
if let Literal(c) = result {
assert_eq!(c, 'X');
} else {
panic!("unexpected result {:?}", result);
}
assert_eq!(block_on(lexer.peek_char()), Ok(None));

```
<Overlap Ratio: 0.9703703703703703>

---

--- 246 --
Question ID: 81d186e99e97da9364fdc65e09e7c264db315a8f_0
Original Code:
```
fn build<'s>(nodes: BTreeMap<&'s str, MergeNode<'s>>, num_frames: i64) -> Vec<MergeScope<'s>> {
    let mut scopes: Vec<_> = nodes
        .into_values()
        .map(|node| node.build(num_frames))
        .collect();

    // Earliest first:
    scopes.sort_by_key(|scope| scope.relative_start_ns);

    // Make sure sibling scopes do not overlap:
    let mut relative_ns = 0;
    for scope in &mut scopes {
        scope.relative_start_ns = scope.relative_start_ns.max(relative_ns);
        relative_ns = scope.relative_start_ns + scope.duration_per_frame_ns;
    }

    scopes
}
```


Overlapping Code:
```
 BTreeMap<&'s str, MergeNode<'s>>, num_frames: i64) -> Vec<MergeScope<'s>> {
let mut scopes: Vec<_> = nodes
.into_values()
.map(|node| node.build(num_frames))
.collect();
// Earliest first:
scopes.sort_by_key(|scope| scope.relative_start_ns);
// Make sure sibling scopes do not overlap:
let mut relative_ns = 0;
for scope in &mut scopes {
scope.relative_start_ns = scope.relative_start_ns.max(relative_ns);
relative_ns = scope.relative_start_ns + sco
```
<Overlap Ratio: 0.8910891089108911>

---

--- 247 --
Question ID: 8c7adf3814a9f170972790ce9c0b24cf68116e4c_2
Original Code:
```
fn correct_coordinates_origin() {
        let cell = HexagonCell2d {
            coords: IVec3::new(0, 0, 0),
        };
        let neighbors = cell.neighbor_coordinates();
        assert_eq!(
            neighbors,
            vec![
                IVec3::new(0, 1, -1),
                IVec3::new(1, 0, -1),
                IVec3::new(1, -1, 0),
                IVec3::new(0, -1, 1),
                IVec3::new(-1, 0, 1),
                IVec3::new(-1, 1, 0),
            ]
        );
    }
```


Overlapping Code:
```
exagonCell2d {
coords: IVec3::new(0, 0, 0),
};
let neighbors = cell.neighbor_coordinates();
assert_eq!(
neighbors,
vec![
IVec3::new(0, 1, -1),
IVec3::new(1, 0, -1),
IVec3::new(1, -1, 0),
IVec3::new(0, -1, 1),
IVec3::new(-1, 0, 1),
IVec3::new(-1, 1, 0
```
<Overlap Ratio: 0.819672131147541>

---

--- 248 --
Question ID: f48cc0114fdd889f94a6dc5ec25f0093359096c9_0
Original Code:
```
fn main() {
    let firebase = Firebase::new("https://shining-torch-7752.firebaseio.com").ok().unwrap();
    let messages = firebase.at("/api/messages").ok().unwrap();

    let res = messages.push(serde_json::json!({"name":"David","message":"Hello from Rust"})).ok().unwrap();

    println!("Response body: {:?}", res.body);
    println!("Response code: {:?}", res.code);
    println!("Response success: {:?}", res.is_success());
}
```


Overlapping Code:
```
et firebase = Firebase::new("https://shining-torch-7752.firebaseio.com").ok().unwrap();
let messages = firebase.at("/api/messages").ok().unwrap();
let res = messages.push(serde_json::json!({"name":"David","message":"Hello from Rust"})).ok().unwrap();
println!("Response body: {:?}", res.body);
println!("Response code: {:?}", res.code);
println!("Response success: {:?}", res.is
```
<Overlap Ratio: 0.9333333333333333>

---

--- 249 --
Question ID: 04323b01537ade9c60e944be1605964e78b88da0_0
Original Code:
```
pub(crate) fn is_running(process_name: &str, print_pid: bool) -> bool {
    let mut cmdline: Command = Command::new(String::from("pidof"));

    // return one PID only
    cmdline.arg("--single-shot");
    if !print_pid {
        // quiet mode, only set the exit code
        cmdline.arg("-q");
    }

    cmdline
        .arg(process_name)
        .status()
        .expect("Could not execute `pidof` command.")
        .success()
}
```


Overlapping Code:
```
b(crate) fn is_running(process_name: &str, print_pid: bool) -> bool {
let mut cmdline: Command = Command::new(String::from("pidof"));
// return one PID only
cmdline.arg("--single-shot");
if !print_pid {
// quiet mode, only set the exit code
cmdline.arg("-q");
}
cmdline
.arg(process_name)
.status()
.expect("Could not execute `pidof` command.")
.succ
```
<Overlap Ratio: 0.9749303621169917>

---

--- 250 --
Question ID: e112cbf8f2863098273dd72f928af9f8a27fff8d_5
Original Code:
```
fn if_else() {
        /*
        if abc == 1 {
            xyz == 1;
        } else if abc == 2{
            xyz == 2;
        } else {
            xyz == 3;
        }
        */

        let condition1 = Condition {
            span: Span::new(),
            lhs: make_identifier!("abc"),
            op: ConditionOp::Equals,
            rhs: Value::NumericLiteral(1),
        };
        let condition2 = Condition {
            span: Span::new(),
            lhs: make_identifier!("abc"),
            op: ConditionOp::Equals,
            rhs: Value::NumericLiteral(2),
        };
        let statement1 = Statement::ConditionStatement {
            span: Span::new(),
            condition: Condition {
                span: Span::new(),
                lhs: make_identifier!("xyz"),
                op: ConditionOp::Equals,
                rhs: Value::NumericLiteral(1),
            },
        };
        let statement2 = Statement::ConditionStatement {
            span: Span::new(),
            condition: Condition {
                span: Span::new(),
                lhs: make_identifier!("xyz"),
                op: ConditionOp::Equals,
                rhs: Value::NumericLiteral(2),
            },
        };
        let statement3 = Statement::ConditionStatement {
            span: Span::new(),
            condition: Condition {
                span: Span::new(),
                lhs: make_identifier!("xyz"),
                op: ConditionOp::Equals,
                rhs: Value::NumericLiteral(3),
            },
        };

        let statements = vec![Statement::If {
            span: Span::new(),
            blocks: vec![
                (condition1.clone(), vec![statement1.clone()]),
                (condition2.clone(), vec![statement2.clone()]),
            ],
            else_block: vec![statement3.clone()],
        }];
        let mut symbol_table = HashMap::new();
        symbol_table.insert(
            make_identifier!("abc"),
            Symbol::Key("abc".to_string(), bind_library::ValueType::Number),
        );
        symbol_table.insert(
            make_identifier!("xyz"),
            Symbol::Key("xyz".to_string(), bind_library::ValueType::Number),
        );

        let instructions = compiler::compile_statements(statements, &symbol_table, false).unwrap();

        // Binds when the if clause is satisfied.
        let properties = vec![
            Property { key: make_identifier!("abc"), value: Value::NumericLiteral(1) },
            Property { key: make_identifier!("xyz"), value: Value::NumericLiteral(1) },
        ];
        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();
        assert!(debugger.evaluate_bind_rules().unwrap());
        assert_eq!(
            debugger.output,
            vec![
                DebuggerOutput::IfCondition { condition: &condition1, success: true },
                DebuggerOutput::ConditionStatement { statement: &statement1, success: true }
            ]
        );

        // Binds when the if else clause is satisfied.
        let properties = vec![
            Property { key: make_identifier!("abc"), value: Value::NumericLiteral(2) },
            Property { key: make_identifier!("xyz"), value: Value::NumericLiteral(2) },
        ];
        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();
        assert!(debugger.evaluate_bind_rules().unwrap());
        assert_eq!(
            debugger.output,
            vec![
                DebuggerOutput::IfCondition { condition: &condition1, success: false },
                DebuggerOutput::IfCondition { condition: &condition2, success: true },
                DebuggerOutput::ConditionStatement { statement: &statement2, success: true }
            ]
        );

        // Binds when the else clause is satisfied.
        let properties =
            vec![Property { key: make_identifier!("xyz"), value: Value::NumericLiteral(3) }];
        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();
        assert!(debugger.evaluate_bind_rules().unwrap());
        assert_eq!(
            debugger.output,
            vec![
                DebuggerOutput::IfCondition { condition: &condition1, success: false },
                DebuggerOutput::IfCondition { condition: &condition2, success: false },
                DebuggerOutput::ConditionStatement { statement: &statement3, success: true }
            ]
        );

        // Doesn't bind when the device has incorrect values for the properties.
        let properties = vec![
            Property { key: make_identifier!("abc"), value: Value::NumericLiteral(42) },
            Property { key: make_identifier!("xyz"), value: Value::NumericLiteral(42) },
        ];
        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();
        assert!(!debugger.evaluate_bind_rules().unwrap());
        assert_eq!(
            debugger.output,
            vec![
                DebuggerOutput::IfCondition { condition: &condition1, success: false },
                DebuggerOutput::IfCondition { condition: &condition2, success: false },
                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }
            ]
        );

        // Doesn't bind when the properties are missing in the device.
        let properties = Vec::new();
        let mut debugger = Debugger::new(&properties, &symbol_table, &instructions).unwrap();
        assert!(!debugger.evaluate_bind_rules().unwrap());
        assert_eq!(
            debugger.output,
            vec![
                DebuggerOutput::IfCondition { condition: &condition1, success: false },
                DebuggerOutput::IfCondition { condition: &condition2, success: false },
                DebuggerOutput::ConditionStatement { statement: &statement3, success: false }
            ]
        );
    }
```


Overlapping Code:
```
{
/*
if abc == 1 {
xyz == 1;
} else if abc == 2{
xyz == 2;
} else {
xyz == 3;
}
*/
let condition1 = Condition {
span: Span::new(),
lhs: make_identifier!("abc"),
op: ConditionOp::Equals,
rhs: Value::NumericLiteral(1),
};
let condition2 = Condition {
span: Span::new(),
lhs: make_identifier!("abc"),
op: ConditionOp::Equals,
rhs: Value::NumericLiteral(2),
};
let statement1 = Statement::ConditionStatement {
span: Span::new(),
condition: Condition {
span: Span::new(),
lhs: make_identifier!("xyz"),
op: ConditionOp::Equals,
rhs: Value::NumericLiteral(1),
},
};
let statement2 = Statement::ConditionStatement {
span: Span::new(),
condition: Condition {
span: Span::new(),
lhs: make_identifier!("xyz"),
op: ConditionOp::Equals,
rhs: Value::NumericLiteral(2),
},
};
let statement3 = Statement::ConditionStatement {
span: Span::new(),
condition: Condition {
span: Span::new(),
lhs: make_identifier!("xyz"),
op: ConditionOp::Equals,
rhs: Value::NumericLiteral(3),
},
};
let statements = vec![Statement::If {
span: Span::new(),
blocks: vec![
(condition1.clone(), vec![statement1.clone()]),
(condition2.clone(), vec![statement2.clone()]),
],
else_block: vec![statement3.clone()],
}];
let mut symbol_table = HashMap::new();
symbol_table.insert(
make_identifier!("abc"),
Symbol::Key("abc".to_string(), bind_library::ValueType::Number),
);
symbol_table.insert(
make_identifier!("xyz"),
Symbol::Key("xyz".to_string(), bind_library::ValueType::Number),
);
let instructions = compiler::compile_statements(statements, &symbol_table, false).unwrap();
// Binds when the if clause is satisfied.
let properties = vec![
Property { key: make_identifier!("abc"), value: Value::NumericLiteral(1) },
Propert
```
<Overlap Ratio: 0.9876688197298884>

---

--- 251 --
Question ID: 376d280fed48ebbede1b0b917d74cf57c426dee0_3
Original Code:
```
pub fn daa(cpu: &mut crate::cpu::Cpu) {
    if cpu.registers.a & 0xf > 0x09 || cpu.registers.f.h {
        cpu.registers.a = cpu.registers.a.wrapping_add(0x06);
    }

    if cpu.registers.a & 0xf0 > 0x90 || cpu.registers.f.c {
        cpu.registers.a = cpu.registers.a.wrapping_add(0x60);
        cpu.registers.f.c = true;
    } else {
        cpu.registers.f.c = false;
    }

    cpu.registers.f.z = cpu.registers.a == 0;
    cpu.registers.f.h = false;
}
```


Overlapping Code:
```
: &mut crate::cpu::Cpu) {
if cpu.registers.a & 0xf > 0x09 || cpu.registers.f.h {
cpu.registers.a = cpu.registers.a.wrapping_add(0x06);
}
if cpu.registers.a & 0xf0 > 0x90 || cpu.registers.f.c {
cpu.registers.a = cpu.registers.a.wrapping_add(0x60);
cpu.registers.f.c = true;
} else {
cpu.registers.f.c = false;
}
cpu.registers.f.z = cpu.registers.a == 
```
<Overlap Ratio: 0.8860759493670886>

---

--- 252 --
Question ID: 562159a5c0c10143023a752d9d16ca66d256582b_2
Original Code:
```
async fn test_bad_raw_query_syntax() -> ReturnUnit {
        let cat = create_test_catalog("test_index");
        let body = r#"{ "query" : { "raw": "asd*(@sq__" } }"#;
        let err = doc_search(Arc::clone(&cat), Body::from(body), "test_index").await?;
        let body: ErrorResponse = wait_json::<ErrorResponse>(err).await;
        assert_eq!(body.message, "Error in Index: \'Syntax Error\'");
        Ok(())
    }
```


Overlapping Code:
```
test_bad_raw_query_syntax() -> ReturnUnit {
let cat = create_test_catalog("test_index");
let body = r#"{ "query" : { "raw": "asd*(@sq__" } }"#;
let err = doc_search(Arc::clone(&cat), Body::from(body), "test_index").await?;
let body: ErrorResponse = wait_json::<ErrorResponse>(err).await;
assert_eq!(body.message, "Error
```
<Overlap Ratio: 0.8692098092643051>

---

--- 253 --
Question ID: af3157c216065e2b895e47c3b7579a5743310777_0
Original Code:
```
pub fn get_engine() -> Handlebars<'static> {
    let mut h = Handlebars::new();
    let _ = h.register_partial("compiled_from", PART_COMPILED_FROM);
    let _ = h.register_partial("sys_info", PART_SYS_INFO);
    let _ = h.register_partial("fields", PART_FIELDS);
    let _ = h.register_partial("methods", PART_METHODS);
    let _ = h.register_partial("constant_pool", PART_CP);
    // let _ = h.register_partial("stack_map_table", PART_STACK_MAP_TABLE);
    h.register_escape_fn(handlebars::no_escape);

    h
}
```


Overlapping Code:
```
 Handlebars<'static> {
let mut h = Handlebars::new();
let _ = h.register_partial("compiled_from", PART_COMPILED_FROM);
let _ = h.register_partial("sys_info", PART_SYS_INFO);
let _ = h.register_partial("fields", PART_FIELDS);
let _ = h.register_partial("methods", PART_METHODS);
let _ = h.register_partial("constant_pool", PART_CP);
// let _ = h.register_partial("stack_map_table", PART_STACK_MAP_TABLE);
h
```
<Overlap Ratio: 0.8544303797468354>

---

--- 254 --
Question ID: c30a04583fd48d49e401243784c51970de5a05bc_2
Original Code:
```
fn unwatch_dir(path: &std::path::Path) {
    let mut config = Config::load();
    let path = path
        .to_str()
        .expect("The provided path is not valid unicode")
        .to_string();

    config.set_unwatch(path);
    config.save();
}
```


Overlapping Code:
```
watch_dir(path: &std::path::Path) {
let mut config = Config::load();
let path = path
.to_str()
.expect("The provided path is not valid unicode")
.to_string();
config.set_unwatch(path);
config.save();

```
<Overlap Ratio: 0.970873786407767>

---

--- 255 --
Question ID: 250b75194e84bf3cafbc90f683d3599c9949052b_7
Original Code:
```
fn test_new_with_default_error_rate() {
        let mut b = BloomFilter::new_with_default_error_rate(20000, true);
        assert_eq!(b.add("Test".as_bytes()).unwrap(), true);
        assert!(b.contains("Test".as_bytes()));
    }
```


Overlapping Code:
```
ith_default_error_rate() {
let mut b = BloomFilter::new_with_default_error_rate(20000, true);
assert_eq!(b.add("Test".as_bytes()).unwrap(), true);
assert!(b.contains("
```
<Overlap Ratio: 0.8308457711442786>

---

--- 256 --
Question ID: 2bb86ce178202df66c7ed4d9d7dd56bb2335408b_50
Original Code:
```
pub fn parse_start_simulation_job_batch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::StartSimulationJobBatchOutput,
    crate::error::StartSimulationJobBatchError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::StartSimulationJobBatchError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "IdempotentParameterMismatchException" => crate::error::StartSimulationJobBatchError {
            meta: generic,
            kind:
                crate::error::StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InternalServerException" => crate::error::StartSimulationJobBatchError {
            meta: generic,
            kind: crate::error::StartSimulationJobBatchErrorKind::InternalServerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::internal_server_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParameterException" => crate::error::StartSimulationJobBatchError {
            meta: generic,
            kind: crate::error::StartSimulationJobBatchErrorKind::InvalidParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "LimitExceededException" => crate::error::StartSimulationJobBatchError {
            meta: generic,
            kind: crate::error::StartSimulationJobBatchErrorKind::LimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ThrottlingException" => crate::error::StartSimulationJobBatchError {
            meta: generic,
            kind: crate::error::StartSimulationJobBatchErrorKind::ThrottlingException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::throttling_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_throttling_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::StartSimulationJobBatchError::generic(generic),
    })
}
```


Overlapping Code:
```
job_batch_error(
response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
crate::output::StartSimulationJobBatchOutput,
crate::error::StartSimulationJobBatchError,
> {
let generic = crate::json_deser::parse_http_generic_error(response)
.map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
let error_code = match generic.code() {
Some(code) => code,
None => {
return Err(crate::error::StartSimulationJobBatchError::unhandled(
generic,
))
}
};
let _error_message = generic.message().map(|msg| msg.to_owned());
Err(match error_code {
"IdempotentParameterMismatchException" => crate::error::StartSimulationJobBatchError {
meta: generic,
kind:
crate::error::StartSimulationJobBatchErrorKind::IdempotentParameterMismatchException(
{
#[allow(unused_mut)]
let mut tmp = {
#[allow(unused_mut)]let mut output = crate::error::idempotent_parameter_mismatch_exception::Builder::default();
let _ = response;
output = crate::json_deser::deser_structure_crate_error_idempotent_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
output.build()
};
if (&tmp.message).is_none() {
tmp.message = _error_message;
}
tmp
},
),
},
"InternalServerException" => crate::error::StartSimulationJobBatchError {
meta: generic,
kind: crate::error::StartSimulationJobBatchErrorKind::InternalServerException({
#[allow(unused_mut)]
let mut tmp = {
#[allow(unused_mut)]
let mut output = crate::error::internal_server_exception::Builder::default();
let _ = response;
output = crate::json_deser::deser_structure_crate_error_internal_server_exception_json_err(response.body().as_ref(), output).map_err(crate::error::StartSimulationJobBatchError::unhandled)?;
output.build()
};
if (&tmp.message).is_none()
```
<Overlap Ratio: 0.9833518312985572>

---

--- 257 --
Question ID: 476d6c1b2aa538eb3a9eb43d026985481306dedf_0
Original Code:
```
pub fn parse(source_file: impl Into<SourceFile>) -> Result<Block, ParseError> {
    let source_file = source_file.into();

    let mut ctx = ParsingContext {
        source_file: source_file.clone(),
        regex_parser: regex_syntax::Parser::new(),
    };

    let mut pair = match grammar::parse(source_file.source_text(), Rule::program) {
        Ok(pair) => pair,
        Err(e) => {
            let span = match e.location {
                pest::error::InputLocation::Pos(offset) => source_file.slice(offset, offset).unwrap(),
                pest::error::InputLocation::Span((start, end)) => source_file.slice(start, end).unwrap(),
            };

            return Err(ParseError::from_pest(span, e));
        }
    };

    from_pair(pair.next().unwrap(), &mut ctx)
}
```


Overlapping Code:
```
arse(source_file: impl Into<SourceFile>) -> Result<Block, ParseError> {
let source_file = source_file.into();
let mut ctx = ParsingContext {
source_file: source_file.clone(),
regex_parser: regex_syntax::Parser::new(),
};
let mut pair = match grammar::parse(source_file.source_text(), Rule::program) {
Ok(pair) => pair,
Err(e) => {
let span = match e.location {
pest::error::InputLocation::Pos(offset) => source_file.slice(offset, offset).unwrap(),
pest::error::InputLocation::Span((start, end)) => source_file.slice(start, end).unwrap(),
};
return Err(ParseError::from_pest(span, e));
}
};
from_pair(
```
<Overlap Ratio: 0.9360374414976599>

---

--- 258 --
Question ID: 36215d036542a38140c6b47e5e448ef5f5fce98a_0
Original Code:
```
pub fn register_all_ops(reg: &mut OnnxOpRegister) {
    reg.insert("GRU", gru::gru);
    reg.insert("LSTM", lstm::lstm);
    reg.insert("RNN", rnn::rnn);
    reg.insert("Scan", scan::scan);
}
```


Overlapping Code:
```
 fn register_all_ops(reg: &mut OnnxOpRegister) {
reg.insert("GRU", gru::gru);
reg.insert("LSTM", lstm::lstm);
reg.insert("RNN", rnn::rnn);
reg.insert("Scan", s
```
<Overlap Ratio: 0.9085714285714286>

---

--- 259 --
Question ID: c9b4e7f9f9ec1954c6b89b4e71ac9099f3b5a134_6
Original Code:
```
fn create_builder_struct_code(parameters: &FunctionParamsCode, in_group: bool) -> Result<TokenStream, Error> {
    let mut params: Vec<TokenStream> = Vec::new();
    if in_group {
        params.push(quote! { pub(crate) client: super::super::Client });
    } else {
        params.push(quote! { pub(crate) client: super::Client });
    }
    for param in parameters.required_params() {
        let FunctionParam {
            variable_name, type_name, ..
        } = param;
        params.push(quote! { pub(crate) #variable_name: #type_name });
    }
    for param in parameters.optional_params() {
        let FunctionParam {
            variable_name, type_name, ..
        } = param;
        let mut type_name = type_name.clone();
        if type_name.is_vec() {
            type_name = type_name.optional(false);
        }
        params.push(quote! { pub(crate) #variable_name: #type_name });
    }
    Ok(quote! {
        #[derive(Clone)]
        pub struct Builder {
            #(#params),*
        }
    })
}
```


Overlapping Code:
```
create_builder_struct_code(parameters: &FunctionParamsCode, in_group: bool) -> Result<TokenStream, Error> {
let mut params: Vec<TokenStream> = Vec::new();
if in_group {
params.push(quote! { pub(crate) client: super::super::Client });
} else {
params.push(quote! { pub(crate) client: super::Client });
}
for param in parameters.required_params() {
let FunctionParam {
variable_name, type_name, ..
} = param;
params.push(quote! { pub(crate) #variable_name: #type_name });
}
for param in parameters.optional_params() {
let FunctionParam {
variable_name, type_name, ..
} = param;
let mut type_name = type_name.clone();
if type_name.is_vec() {
type_name = type_name.optional(false);
}
params.push(quote! { pub(crate) #variable_name: #type_name });
}
Ok(quote! {
#[derive(Clone)]
pub struct Builder {
#(#pa
```
<Overlap Ratio: 0.9791921664626683>

---

--- 260 --
Question ID: c18cae37cdc78ab843bee1bf7527e5e78439239c_0
Original Code:
```
fn test_parser() {
        assert_eq!(MediaType::Audio, "AUDIO".parse().unwrap());
        assert_eq!(MediaType::Video, "VIDEO".parse().unwrap());
        assert_eq!(MediaType::Subtitles, "SUBTITLES".parse().unwrap());
        assert_eq!(
            MediaType::ClosedCaptions,
            "CLOSED-CAPTIONS".parse().unwrap()
        );
    }
```


Overlapping Code:
```
er() {
assert_eq!(MediaType::Audio, "AUDIO".parse().unwrap());
assert_eq!(MediaType::Video, "VIDEO".parse().unwrap());
assert_eq!(MediaType::Subtitles, "SUBTITLES".parse().unwrap());
assert_eq!(
MediaType::ClosedCaptions,
"CLOSED-CAPTIONS".parse().un
```
<Overlap Ratio: 0.9157509157509157>

---

--- 261 --
Question ID: db9dbc74b12bdbaa442c66982b7ad32de4420b40_0
Original Code:
```
pub fn consume(channel: Channel, basic_consume: BasicConsume) -> MethodResponse {
    let BasicConsume {
        queue: queue_name,
        consumer_tag,
        no_local,
        no_ack,
        exclusive,
        no_wait,
        ..
    } = basic_consume;

    if no_local || exclusive || no_ack {
        amqp_todo!();
    }

    let global_data = channel.global_data.clone();

    let consumer_tag = if consumer_tag.is_empty() {
        haesli_core::random_uuid().to_string()
    } else {
        consumer_tag
    };

    let mut global_data = global_data.lock();

    let queue = global_data
        .queues
        .get_mut(queue_name.as_str())
        .ok_or(ChannelException::NotFound)?;

    let consumer = Consumer {
        id: ConsumerId::random(),
        tag: consumer_tag.clone(),
        channel: Arc::clone(&channel),
        queue: Arc::clone(queue),
    };

    queue.consumers.lock().insert(consumer.id, consumer.clone());

    channel.connection.consuming.lock().push(consumer);

    info!(%queue_name, %consumer_tag, "Consumer started consuming");

    Ok(no_wait
        .not()
        .then(|| Method::BasicConsumeOk(BasicConsumeOk { consumer_tag })))
}
```


Overlapping Code:
```
Channel, basic_consume: BasicConsume) -> MethodResponse {
let BasicConsume {
queue: queue_name,
consumer_tag,
no_local,
no_ack,
exclusive,
no_wait,
..
} = basic_consume;
if no_local || exclusive || no_ack {
amqp_todo!();
}
let global_data = channel.global_data.clone();
let consumer_tag = if consumer_tag.is_empty() {
haesli_core::random_uuid().to_string()
} else {
consumer_tag
};
let mut global_data = global_data.lock();
let queue = global_data
.queues
.get_mut(queue_name.as_str())
.ok_or(ChannelException::NotFound)?;
let consumer = Consumer {
id: ConsumerId::random(),
tag: consumer_tag.clone(),
channel: Arc::clone(&channel),
queue: Arc::clone(queue),
};
queue.consumers.lock().insert(consumer.id, consumer.clone());
channel.connection.consuming.lock().push(consumer);
info!(%queue_name, %consumer_tag, "Consumer started consuming");
Ok(no_wait
.not()
.then(|| Method::BasicConsumeOk(BasicCons
```
<Overlap Ratio: 0.9463722397476341>

---

--- 262 --
Question ID: 823d01796f1ad4950edc5cc8e24cb927b4afcbd8_44
Original Code:
```
pub fn serialize_operation_crate_operation_copy_image(
    input: &crate::input::CopyImageInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
    let mut out = String::new();
    #[allow(unused_mut)]
    let mut writer = aws_smithy_query::QueryWriter::new(&mut out, "CopyImage", "2016-11-15");
    #[allow(unused_mut)]
    let mut scope_407 = writer.prefix("ClientToken");
    if let Some(var_408) = &input.client_token {
        scope_407.string(var_408);
    }
    #[allow(unused_mut)]
    let mut scope_409 = writer.prefix("Description");
    if let Some(var_410) = &input.description {
        scope_409.string(var_410);
    }
    #[allow(unused_mut)]
    let mut scope_411 = writer.prefix("Encrypted");
    if let Some(var_412) = &input.encrypted {
        scope_411.boolean(*var_412);
    }
    #[allow(unused_mut)]
    let mut scope_413 = writer.prefix("KmsKeyId");
    if let Some(var_414) = &input.kms_key_id {
        scope_413.string(var_414);
    }
    #[allow(unused_mut)]
    let mut scope_415 = writer.prefix("Name");
    if let Some(var_416) = &input.name {
        scope_415.string(var_416);
    }
    #[allow(unused_mut)]
    let mut scope_417 = writer.prefix("SourceImageId");
    if let Some(var_418) = &input.source_image_id {
        scope_417.string(var_418);
    }
    #[allow(unused_mut)]
    let mut scope_419 = writer.prefix("SourceRegion");
    if let Some(var_420) = &input.source_region {
        scope_419.string(var_420);
    }
    #[allow(unused_mut)]
    let mut scope_421 = writer.prefix("DestinationOutpostArn");
    if let Some(var_422) = &input.destination_outpost_arn {
        scope_421.string(var_422);
    }
    #[allow(unused_mut)]
    let mut scope_423 = writer.prefix("DryRun");
    if let Some(var_424) = &input.dry_run {
        scope_423.boolean(*var_424);
    }
    writer.finish();
    Ok(aws_smithy_http::body::SdkBody::from(out))
}
```


Overlapping Code:
```
rate_operation_copy_image(
input: &crate::input::CopyImageInput,
) -> Result<aws_smithy_http::body::SdkBody, aws_smithy_http::operation::SerializationError> {
let mut out = String::new();
#[allow(unused_mut)]
let mut writer = aws_smithy_query::QueryWriter::new(&mut out, "CopyImage", "2016-11-15");
#[allow(unused_mut)]
let mut scope_407 = writer.prefix("ClientToken");
if let Some(var_408) = &input.client_token {
scope_407.string(var_408);
}
#[allow(unused_mut)]
let mut scope_409 = writer.prefix("Description");
if let Some(var_410) = &input.description {
scope_409.string(var_410);
}
#[allow(unused_mut)]
let mut scope_411 = writer.prefix("Encrypted");
if let Some(var_412) = &input.encrypted {
scope_411.boolean(*var_412);
}
#[allow(unused_mut)]
let mut scope_413 = writer.prefix("KmsKeyId");
if let Some(var_414) = &input.kms_key_id {
scope_413.string(var_414);
}
#[allow(unused_mut)]
let mut scope_415 = writer.prefix("Name");
if let Some(var_416) = &input.name {
scope_415.string(var_416);
}
#[allow(unused_mut)]
let mut scope_417 = writer.prefix("SourceImageId");
if let Some(var_418) = &input.source_image_id {
scope_417.string(var_418);
}
#[allow(unused_mut)]
let mut scope_419 = writer.prefix("SourceRegion");
if let Some(var_420) = &input.source_region {
scope_419.string(var_420);
}
#[allow(unused_mut)]
let mut scope_421 = writer.prefix("DestinationOutpostArn");
if let Some(var_422) = &input.destination_outpost_arn {
scope_421.string(var_422);
}
#[allow(unused_mut)]
let mut scope_423 = writer.prefix("DryRun");
if let Some(var_424) = &input.dry_run {
scope_423.boolean(*var_424);
}
writer.finish();
Ok(aws_smithy_http::body::SdkBody::from(out))
}
```
<Overlap Ratio: 0.983451536643026>

---

--- 263 --
Question ID: d635e87385b4d008770525871764a7b0d3034375_0
Original Code:
```
pub fn wait<F>(fd: RawFd, cond: F, timeout: Option<Duration>) -> bool
where
    F: Fn() -> bool,
{
    if cond() {
        return true;
    }

    let start = Instant::now();

    let mut t = timeout;

    loop {
        let wait_timeout = match t {
            Some(duration) => duration.as_millis() as i32,
            None => -1,
        };
        wait_file_changes(fd, wait_timeout);

        if let Some(duration) = timeout {
            let elapsed = start.elapsed();
            if elapsed >= duration {
                return false;
            }
            t = Some(duration - elapsed);
        }

        if cond() {
            return true;
        }
    }
}
```


Overlapping Code:
```
d: F, timeout: Option<Duration>) -> bool
where
F: Fn() -> bool,
{
if cond() {
return true;
}
let start = Instant::now();
let mut t = timeout;
loop {
let wait_timeout = match t {
Some(duration) => duration.as_millis() as i32,
None => -1,
};
wait_file_changes(fd, wait_timeout);
if let Some(duration) = timeout {
let elapsed = start.elapsed();
if elapsed >= duration {
return false;
}
t = Some(duration
```
<Overlap Ratio: 0.8438818565400844>

---

--- 264 --
Question ID: 20b41bbe0060e4b74d291a9329ed6b1180dbb5ce_1
Original Code:
```
pub async fn test_ibc_transfer(
    contact: &Contact,                     // Src chain's deep_space client
    dst_bank_qc: BankQueryClient<Channel>, // Dst chain's GRPC x/bank query client
    dst_ibc_transfer_qc: IbcTransferQueryClient<Channel>, // Dst chain's GRPC ibc-transfer query client
    sender: CosmosPrivateKey,                             // The Src chain's funds sender
    receiver: CosmosAddress,                              // The Dst chain's funds receiver
    channel_id: String,       // The Src chain's ibc channel connecting to Dst
    packet_timeout: Duration, // Used to create ibc-transfer timeout-timestamp
) {
    let sender_address = sender.to_address(&*ADDRESS_PREFIX).unwrap().to_string();
    let pre_bal = get_ibc_balance(
        receiver,
        (*STAKING_TOKEN).to_string(),
        None,
        dst_bank_qc.clone(),
        dst_ibc_transfer_qc.clone(),
        None,
    )
    .await;

    let timeout_timestamp = SystemTime::now()
        .add(packet_timeout)
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64;
    info!("Calculated 150 minutes from now: {:?}", timeout_timestamp);
    let amount: Uint256 = one_atom();
    let msg_transfer = MsgTransfer {
        source_port: "transfer".to_string(),
        source_channel: channel_id,
        token: Some(Coin {
            amount: amount.clone().to_string(),
            denom: STAKING_TOKEN.as_str().to_string(),
        }),
        sender: sender_address,
        receiver: receiver.to_string(),
        timeout_height: None,
        timeout_timestamp, // 150 minutes from now
    };
    info!("Submitting MsgTransfer {:?}", msg_transfer);
    let msg_transfer = Msg::new(MSG_TRANSFER_TYPE_URL, msg_transfer);
    let send_res = contact
        .send_message(
            &[msg_transfer],
            Some("Test Relaying".to_string()),
            &[DSCoin {
                amount: 100u16.into(),
                denom: (*STAKING_TOKEN).to_string(),
            }],
            Some(OPERATION_TIMEOUT),
            sender,
        )
        .await;
    info!("Sent MsgTransfer with response {:?}", send_res);

    // Give the ibc-relayer a bit of time to work in the event of multiple runs
    delay_for(Duration::from_secs(10)).await;

    let start_bal = Some(match pre_bal.clone() {
        Some(coin) => Uint256::from_str(&coin.amount).unwrap(),
        None => 0u8.into(),
    });

    let post_bal = get_ibc_balance(
        receiver,
        (*STAKING_TOKEN).to_string(),
        start_bal,
        dst_bank_qc,
        dst_ibc_transfer_qc,
        None,
    )
    .await;
    match (pre_bal, post_bal) {
        (None, None) => {
            panic!("Failed to transfer stake to ibc-test-1 user {}!", receiver,);
        }
        (None, Some(post)) => {
            if Uint256::from_str(&post.amount).unwrap() != amount {
                panic!(
                    "Incorrect ibc stake balance for user {}: actual {} != expected {}",
                    receiver, post.amount, amount,
                );
            }
            info!(
                "Successfully transfered {} stake (aka {}) to ibc-test-1!",
                amount, post.denom
            );
        }
        (Some(pre), Some(post)) => {
            let pre_amt = Uint256::from_str(&pre.amount).unwrap();
            let post_amt = Uint256::from_str(&post.amount).unwrap();
            if post_amt < pre_amt || post_amt - pre_amt.clone() != amount.clone() {
                panic!(
                    "Incorrect ibc stake balance for user {}: actual {} != expected {}",
                    receiver,
                    post.amount,
                    (pre_amt + amount),
                );
            }
            info!(
                "Successfully transfered {} stake (aka {}) to ibc-test-1!",
                amount, post.denom
            );
        }
        (Some(_), None) => {
            panic!(
                "User wound up with no balance after ibc transfer? {}",
                receiver,
            );
        }
    }
}
```


Overlapping Code:
```
c fn test_ibc_transfer(
contact: &Contact, // Src chain's deep_space client
dst_bank_qc: BankQueryClient<Channel>, // Dst chain's GRPC x/bank query client
dst_ibc_transfer_qc: IbcTransferQueryClient<Channel>, // Dst chain's GRPC ibc-transfer query client
sender: CosmosPrivateKey, // The Src chain's funds sender
receiver: CosmosAddress, // The Dst chain's funds receiver
channel_id: String, // The Src chain's ibc channel connecting to Dst
packet_timeout: Duration, // Used to create ibc-transfer timeout-timestamp
) {
let sender_address = sender.to_address(&*ADDRESS_PREFIX).unwrap().to_string();
let pre_bal = get_ibc_balance(
receiver,
(*STAKING_TOKEN).to_string(),
None,
dst_bank_qc.clone(),
dst_ibc_transfer_qc.clone(),
None,
)
.await;
let timeout_timestamp = SystemTime::now()
.add(packet_timeout)
.duration_since(SystemTime::UNIX_EPOCH)
.unwrap()
.as_nanos() as u64;
info!("Calculated 150 minutes from now: {:?}", timeout_timestamp);
let amount: Uint256 = one_atom();
let msg_transfer = MsgTransfer {
source_port: "transfer".to_string(),
source_channel: channel_id,
token: Some(Coin {
amount: amount.clone().to_string(),
denom: STAKING_TOKEN.as_str().to_string(),
}),
sender: sender_address,
receiver: receiver.to_string(),
timeout_height: None,
timeout_timestamp, // 150 minutes from now
};
info!("Submitting MsgTransfer {:?}", msg_transfer);
let msg_transfer = Msg::new(MSG_TRANSFER_TYPE_URL, msg_transfer);
let send_res = contact
.send_message(
&[msg_transfer],
Some("Test Relaying".to_string()),
&[DSCoin {
amount: 100u16.into(),
denom: (*STAKING_TOKEN).to_string(),
}],
Some(OPERATION_TIMEOUT),
sender,
)
.await;
info!("Sent MsgTransfer with response {:?}", send_res);
// Give the ibc-relayer a bit of time to work in the event of multiple runs
delay_for(Duration::from_secs(10)).await;
let start_bal = Some(match pre_bal.clone() {
Some(coin) => Uint256::from_str(&coin.amount).unwrap(),
None => 0u8.into(),
});
let post_bal = get_ibc_ba
```
<Overlap Ratio: 0.9828629032258065>

---

--- 265 --
Question ID: a5697097b716f587bfe10a7d599e122f2aa6d0c6_36
Original Code:
```
pub fn serialize_structure_crate_model_transit_gateway_request_options(
    mut writer: aws_smithy_query::QueryValueWriter,
    input: &crate::model::TransitGatewayRequestOptions,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    #[allow(unused_mut)]
    let mut scope_318 = writer.prefix("AmazonSideAsn");
    if let Some(var_319) = &input.amazon_side_asn {
        scope_318.number(
            #[allow(clippy::useless_conversion)]
            aws_smithy_types::Number::NegInt((*var_319).into()),
        );
    }
    #[allow(unused_mut)]
    let mut scope_320 = writer.prefix("AutoAcceptSharedAttachments");
    if let Some(var_321) = &input.auto_accept_shared_attachments {
        scope_320.string(var_321.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_322 = writer.prefix("DefaultRouteTableAssociation");
    if let Some(var_323) = &input.default_route_table_association {
        scope_322.string(var_323.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_324 = writer.prefix("DefaultRouteTablePropagation");
    if let Some(var_325) = &input.default_route_table_propagation {
        scope_324.string(var_325.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_326 = writer.prefix("VpnEcmpSupport");
    if let Some(var_327) = &input.vpn_ecmp_support {
        scope_326.string(var_327.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_328 = writer.prefix("DnsSupport");
    if let Some(var_329) = &input.dns_support {
        scope_328.string(var_329.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_330 = writer.prefix("MulticastSupport");
    if let Some(var_331) = &input.multicast_support {
        scope_330.string(var_331.as_str());
    }
    #[allow(unused_mut)]
    let mut scope_332 = writer.prefix("TransitGatewayCidrBlocks");
    if let Some(var_333) = &input.transit_gateway_cidr_blocks {
        let mut list_335 = scope_332.start_list(true, Some("item"));
        for item_334 in var_333 {
            #[allow(unused_mut)]
            let mut entry_336 = list_335.entry();
            entry_336.string(item_334);
        }
        list_335.finish();
    }
    Ok(())
}
```


Overlapping Code:
```
b fn serialize_structure_crate_model_transit_gateway_request_options(
mut writer: aws_smithy_query::QueryValueWriter,
input: &crate::model::TransitGatewayRequestOptions,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
#[allow(unused_mut)]
let mut scope_318 = writer.prefix("AmazonSideAsn");
if let Some(var_319) = &input.amazon_side_asn {
scope_318.number(
#[allow(clippy::useless_conversion)]
aws_smithy_types::Number::NegInt((*var_319).into()),
);
}
#[allow(unused_mut)]
let mut scope_320 = writer.prefix("AutoAcceptSharedAttachments");
if let Some(var_321) = &input.auto_accept_shared_attachments {
scope_320.string(var_321.as_str());
}
#[allow(unused_mut)]
let mut scope_322 = writer.prefix("DefaultRouteTableAssociation");
if let Some(var_323) = &input.default_route_table_association {
scope_322.string(var_323.as_str());
}
#[allow(unused_mut)]
let mut scope_324 = writer.prefix("DefaultRouteTablePropagation");
if let Some(var_325) = &input.default_route_table_propagation {
scope_324.string(var_325.as_str());
}
#[allow(unused_mut)]
let mut scope_326 = writer.prefix("VpnEcmpSupport");
if let Some(var_327) = &input.vpn_ecmp_support {
scope_326.string(var_327.as_str());
}
#[allow(unused_mut)]
let mut scope_328 = writer.prefix("DnsSupport");
if let Some(var_329) = &input.dns_support {
scope_328.string(var_329.as_str());
}
#[allow(unused_mut)]
let mut scope_330 = writer.prefix("MulticastSupport");
if let Some(var_331) = &input.multicast_support {
scope_330.string(var_331.as_str());
}
#[allow(unused_mut)]
let mut scope_332 = writer.prefix("TransitGatewayCidrBlocks");
if let Some(var_333) = &input.transit_gateway_cidr_blocks {
let mut list_335 = scope_332.start_list(true, Some("item"));
for item_334 in var_333 {
#[allow(unused_mut)]
let mut entry_336 = list_335.entry();
entry_336.string(item_334);
}
lis
```
<Overlap Ratio: 0.984994640943194>

---

--- 266 --
Question ID: ed55cd606c815fe8b36c6528988c6e1f75011288_2
Original Code:
```
fn clk_fro_hf_96mhz() {
        let dp = unsafe { pac::Peripherals::steal() };
        let syscon = dp.SYSCON.freeze(Config::frohf_96mhz());
        assert_eq!(unwrap!(syscon.get_main_clock_freq()), 96_000_000.Hz());
    }
```


Overlapping Code:
```
() {
let dp = unsafe { pac::Peripherals::steal() };
let syscon = dp.SYSCON.freeze(Config::frohf_96mhz());
assert_eq!(unwrap!(sys
```
<Overlap Ratio: 0.6597938144329897>

---

--- 267 --
Question ID: 94eeb0179269e48b811d7d886afceb3c9ad4c445_5
Original Code:
```
fn do_inserts(s: Arc<Storage>, tid: u32, n_records: u32) -> Result<()> {
    let tid_bytes = tid.to_be_bytes();
    for id in 0..n_records {
        let mut key: Vec<u8> = Vec::new();
        key.extend_from_slice(&id.to_be_bytes());
        key.extend_from_slice(&tid_bytes);
        s.put(key, tid_bytes.to_vec())?;
    }
    Ok(())
}
```


Overlapping Code:
```
do_inserts(s: Arc<Storage>, tid: u32, n_records: u32) -> Result<()> {
let tid_bytes = tid.to_be_bytes();
for id in 0..n_records {
let mut key: Vec<u8> = Vec::new();
key.extend_from_slice(&id.to_be_bytes());
key.extend_from_slice(&tid_bytes);
s.put(ke
```
<Overlap Ratio: 0.8680555555555556>

---

--- 268 --
Question ID: c42b742997a8fbeb7cdfa9bc997e9747509a91df_0
Original Code:
```
async fn main() -> Result<(), Error> {
    let address = "localhost:27015";
    let mut conn = Connection::builder()
        .connect(address, "test").await?;

    demo(&mut conn, "status").await?;
    demo(&mut conn, "users").await?;
    demo(&mut conn, "echo \"Rust lang rocks! ;P\"").await?;
    println!("commands finished");

    Ok(())
}
```


Overlapping Code:
```
async fn main() -> Result<(), Error> {
let address = "localhost:27015";
let mut conn = Connection::builder()
.connect(address, "test").await?;
demo(&mut conn, "status").await?;
demo(&mut conn, "users").await?;
demo(&mut conn, "echo \"Rust lang rocks! ;P\"").await?;
println!("commands finished");
Ok(
```
<Overlap Ratio: 0.9836065573770492>

---

--- 269 --
Question ID: 46d192f462c52cc588e61632f92ee4effa4bbd01_1
Original Code:
```
pub fn verify_fuchsia_pkg_cm_url(url: &str) -> Result<String> {
    let url = match PkgUrl::parse(url) {
        Ok(url) => url,
        Err(e) => ffx_bail!("URL parsing error: {:?}", e),
    };

    let resource = url.resource().ok_or(ffx_error!("URL does not contain a path to a manifest"))?;
    let manifest = resource
        .split('/')
        .last()
        .ok_or(ffx_error!("Could not extract manifest filename from URL"))?;

    if let Some(name) = manifest.strip_suffix(".cm") {
        Ok(name.to_string())
    } else if manifest.ends_with(".cmx") {
        ffx_bail!(
            "{} is a legacy component manifest. Run it using `ffx component run-legacy`",
            manifest
        )
    } else {
        ffx_bail!(
            "{} is not a component manifest! Component manifests must end in the `cm` extension.",
            manifest
        )
    }
}
```


Overlapping Code:
```
m_url(url: &str) -> Result<String> {
let url = match PkgUrl::parse(url) {
Ok(url) => url,
Err(e) => ffx_bail!("URL parsing error: {:?}", e),
};
let resource = url.resource().ok_or(ffx_error!("URL does not contain a path to a manifest"))?;
let manifest = resource
.split('/')
.last()
.ok_or(ffx_error!("Could not extract manifest filename from URL"))?;
if let Some(name) = manifest.strip_suffix(".cm") {
Ok(name.to_string())
} else if manifest.ends_with(".cmx") {
ffx_bail!(
"{} is a legacy component manifest. Run it using `ffx component run-legacy`",
manifest
)
} else {
ffx_bail!(
"{} is not a component manifest! Component manifests must end in th
```
<Overlap Ratio: 0.9142053445850914>

---

--- 270 --
Question ID: 1311f5f7ac6f38b5de162388caa8ef01656946cd_0
Original Code:
```
fn init(env: NapiEnv, mut exports: JsObject) -> NapiResult<()> {
    let obj = env.object()?;

    obj.define_properties(&[DescriptorValueBuilder::new()
        .with_utf8name("myvalue")
        .with_value(env.string("myvalue")?)
        .build()?])?;

    obj.define_properties(&[DescriptorMethodBuilder::new()
        .with_utf8name("mymethod")
        .with_method(move |this, ()| this.env().double(200.))
        .build()?])?;

    let value = Arc::new(Mutex::new(0.));
    let value2 = value.clone();

    obj.define_properties(&[DescriptorAccessorBuilder::new()
        .with_utf8name("myaccessor")
        .with_getter(move |this| this.env().double(*value.lock().unwrap()))
        .with_setter(move |_this: JsObject, n: JsNumber| {
            let mut value = value2.lock().unwrap();
            *value = n.get_value_double()?;
            Ok(())
        })
        .build()?])?;

    exports.set("obj", obj)?;

    Ok(())
}
```


Overlapping Code:
```
fn init(env: NapiEnv, mut exports: JsObject) -> NapiResult<()> {
let obj = env.object()?;
obj.define_properties(&[DescriptorValueBuilder::new()
.with_utf8name("myvalue")
.with_value(env.string("myvalue")?)
.build()?])?;
obj.define_properties(&[DescriptorMethodBuilder::new()
.with_utf8name("mymethod")
.with_method(move |this, ()| this.env().double(200.))
.build()?])?;
let value = Arc::new(Mutex::new(0.));
let value2 = value.clone();
obj.define_properties(&[DescriptorAccessorBuilder::new()
.with_utf8name("myaccessor")
.with_getter(move |this| this.env().double(*value.lock().unwrap()))
.with_setter(move |_this: JsObject, n: JsNumber| {
let mut value = value2.lock().unwrap();
*value = n.get_value_double()?;
Ok(())
})
.build()?])?;
exports.set("obj", obj)?;
Ok(())
}
```
<Overlap Ratio: 1.0>

---

--- 271 --
Question ID: 9ba37a921a2a4ece1f5deed1b92d20efe3b78a04_2
Original Code:
```
fn values_del() {
        let mut values = Values::new();
        values.set_value("key", Some("value".to_string()));
        values.add_value("key", None);
        values.del_value("key");
        assert_eq!(values.len(), 0);

        let mut values2 = Values::new();
        values2.set_value("key", Some("value".to_string()));
        values2.add_value("key", None);
        values2.set_value("key2", Some("value".to_string()));
        values2.add_value("key2", None);

        values2.del_value("key");
        assert_eq!(values2.len(), 1);
    }
```


Overlapping Code:
```
let mut values = Values::new();
values.set_value("key", Some("value".to_string()));
values.add_value("key", None);
values.del_value("key");
assert_eq!(values.len(), 0);
let mut values2 = Values::new();
values2.set_value("key", Some("value".to_string()));
values2.add_value("key", None);
values2.set_value("key2", Some("value".to_string()));
values2.add_value("key2", None);
values2.del_value("key");

```
<Overlap Ratio: 0.89086859688196>

---

--- 272 --
Question ID: 3c06427b84abab716aeb10bdc7f00708bba08807_0
Original Code:
```
fn main() {
    // Bug from https://github.com/bluss/indexing/issues/12
    let array = [0, 1, 2, 3, 4, 5];
    let ix = scope(&array[..], |arr| {
        let left = arr.vet_range(0..2).unwrap();
        let left = left.nonempty().unwrap();
        let (_, right) = arr.range().frontiers();

        let joined = right.join_cover(left);
        let ix = joined.first();
        arr[ix]; //~ ERROR: cannot be indexed by
        ix.integer()
    });
    dbg!(array[ix]);
}
```


Overlapping Code:
```
n() {
// Bug from https://github.com/bluss/indexing/issues/12
let array = [0, 1, 2, 3, 4, 5];
let ix = scope(&array[..], |arr| {
let left = arr.vet_range(0..2).unwrap();
let left = left.nonempty().unwrap();
let (_, right) = arr.range().frontiers();
let joined = right.join_cover(left);
let ix = joined.first();
arr[ix]; //~ ERROR: cannot be indexed b
```
<Overlap Ratio: 0.8905852417302799>

---

--- 273 --
Question ID: ec997430e31b86f8a9c22418c5c30c6b4fd32db1_3
Original Code:
```
pub fn set_sampling_mode<'a>(
    mut ctx: partial!(Context<'a>, mut ProofP<'a>, mut SolverStateP, mut VariablesP),
    global: Var,
    mode: SamplingMode,
) -> Option<Var> {
    let variables = ctx.part_mut(VariablesP);

    let var_data = &mut variables.var_data[global.index()];

    assert!(!var_data.deleted);

    if var_data.assumed {
        panic!("cannot change sampling mode of assumption variable")
    }

    let previous_mode = var_data.sampling_mode;

    if previous_mode == mode {
        return None;
    }

    var_data.sampling_mode = mode;

    let mut result = None;

    if mode != SamplingMode::Hide {
        proof::add_step(
            ctx.borrow(),
            false,
            &ProofStep::ChangeSamplingMode {
                var: global,
                sample: mode == SamplingMode::Sample,
            },
        );
    }
    let variables = ctx.part_mut(VariablesP);

    if previous_mode == SamplingMode::Hide {
        let user = variables.next_unmapped_user();
        variables.user_from_global_mut().insert(user, global);
        variables.user_freelist.remove(&user);

        proof::add_step(
            ctx.borrow(),
            false,
            &ProofStep::UserVarName {
                global,
                user: Some(user),
            },
        );

        result = Some(user);
    } else if mode == SamplingMode::Hide {
        if let Some(user) = variables.user_from_global_mut().remove(global) {
            variables.user_freelist.insert(user);
        }

        proof::add_step(
            ctx.borrow(),
            false,
            &ProofStep::UserVarName { global, user: None },
        );

        delete_global_if_unused(ctx.borrow(), global);
    }

    result
}
```


Overlapping Code:
```
'a>(
mut ctx: partial!(Context<'a>, mut ProofP<'a>, mut SolverStateP, mut VariablesP),
global: Var,
mode: SamplingMode,
) -> Option<Var> {
let variables = ctx.part_mut(VariablesP);
let var_data = &mut variables.var_data[global.index()];
assert!(!var_data.deleted);
if var_data.assumed {
panic!("cannot change sampling mode of assumption variable")
}
let previous_mode = var_data.sampling_mode;
if previous_mode == mode {
return None;
}
var_data.sampling_mode = mode;
let mut result = None;
if mode != SamplingMode::Hide {
proof::add_step(
ctx.borrow(),
false,
&ProofStep::ChangeSamplingMode {
var: global,
sample: mode == SamplingMode::Sample,
},
);
}
let variables = ctx.part_mut(VariablesP);
if previous_mode == SamplingMode::Hide {
let user = variables.next_unmapped_user();
variables.user_from_global_mut().insert(user, global);
variables.user_freelist.remove(&user);
proof::add_step(
ctx.borrow(),
false,
&ProofStep::UserVarName {
global,
user: Some(user),
},
);
result = Some(user);
} else if mode == SamplingMode::Hide {
if let Some(user) = variables.user_from_global_mut().remove(global) {
variables.user_freelist.insert(user);
}
proof::add_step(
ctx.borrow(),
false,
&ProofStep::UserVarName { global, user: None },
);
delete_global_if_unused(ctx.bor
```
<Overlap Ratio: 0.961038961038961>

---

--- 274 --
Question ID: b6b401423a70f0bbafd364b550f89737fbc86a43_0
Original Code:
```
pub(crate) fn open_impl(
    start: &fs::File,
    path: &Path,
    options: &OpenOptions,
) -> io::Result<fs::File> {
    // Windows reserves several special device paths. Disallow opening any
    // of them.
    if let Some(stem) = path.file_stem() {
        if let Some(stemstr) = stem.to_str() {
            match stemstr.to_uppercase().as_str() {
                "CON" | "PRN" | "AUX" | "NUL" | "COM0" | "COM1" | "COM2" | "COM3" | "COM4"
                | "COM5" | "COM6" | "COM7" | "COM8" | "COM9" | "LPT0" | "LPT1" | "LPT2"
                | "LPT3" | "LPT4" | "LPT5" | "LPT6" | "LPT7" | "LPT8" | "LPT9" => {
                    return Err(io::Error::from_raw_os_error(ERROR_FILE_NOT_FOUND as i32));
                }
                _ => {}
            }
        }
    }

    manually::open(start, path, options)
}
```


Overlapping Code:
```
te) fn open_impl(
start: &fs::File,
path: &Path,
options: &OpenOptions,
) -> io::Result<fs::File> {
// Windows reserves several special device paths. Disallow opening any
// of them.
if let Some(stem) = path.file_stem() {
if let Some(stemstr) = stem.to_str() {
match stemstr.to_uppercase().as_str() {
"CON" | "PRN" | "AUX" | "NUL" | "COM0" | "COM1" | "COM2" | "COM3" | "COM4"
| "COM5" | "COM6" | "COM7" | "COM8" | "COM9" | "LPT0" | "LPT1" | "LPT2"
| "LPT3" | "LPT4" | "LPT5" | "LPT6" | "LPT7" | "LPT8" | "LPT9" => {
return Err(io::Error::from_raw_os_error(ERROR_FILE_NOT_FOUND as i32));
}
_ =
```
<Overlap Ratio: 0.9135802469135802>

---

--- 275 --
Question ID: a47954f1c09485973a72f04c9a710db160c3d28d_2
Original Code:
```
fn get_data(status: (u8, u16, u8), payload: Vec<u8>) -> Vec<u8> {
    let statindex = if status.0 == CTAPHID_MSG { 0 } else { 1 };

    // data size
    let datasize = if status.0 == CTAPHID_MSG {
        // remove SW1 , SW2
        status.1 - 2
    } else {
        status.1
    };

    // get CBOR
    let mut data: Vec<u8> = vec![];
    for n in statindex..datasize {
        let index: usize = n.into();
        let dat = payload[index];
        data.push(dat);
    }
    data
}
```


Overlapping Code:
```
tatus: (u8, u16, u8), payload: Vec<u8>) -> Vec<u8> {
let statindex = if status.0 == CTAPHID_MSG { 0 } else { 1 };
// data size
let datasize = if status.0 == CTAPHID_MSG {
// remove SW1 , SW2
status.1 - 2
} else {
status.1
};
// get CBOR
let mut data: Vec<u8> = vec![];
for n in statindex..datasize {
let index: usize = n.into();
let dat = payload[ind
```
<Overlap Ratio: 0.8928571428571429>

---

--- 276 --
Question ID: 848a493f75eb7f91fc8451bf7c2a53f425c531a8_19
Original Code:
```
pub fn line_spacing() -> Result<(), DocxError> {
    let path = std::path::Path::new("./tests/output/line_spacing.docx");
    let file = std::fs::File::create(&path).unwrap();
    Docx::new()
        .add_paragraph(
            Paragraph::new()
                .add_run(Run::new().add_text(DUMMY))
                .line_spacing(Some(300), None, Some(300), Some(LineSpacingType::Auto)),
        )
        .add_paragraph(
            Paragraph::new()
                .add_run(Run::new().add_text(DUMMY))
                .line_spacing(None, None, Some(300), Some(LineSpacingType::AtLeast)),
        )
        .add_paragraph(
            Paragraph::new()
                .add_run(Run::new().add_text(DUMMY).character_spacing(100))
                .line_spacing(None, Some(300), Some(300), Some(LineSpacingType::Exact)),
        )
        .build()
        .pack(file)?;
    Ok(())
}
```


Overlapping Code:
```
g() -> Result<(), DocxError> {
let path = std::path::Path::new("./tests/output/line_spacing.docx");
let file = std::fs::File::create(&path).unwrap();
Docx::new()
.add_paragraph(
Paragraph::new()
.add_run(Run::new().add_text(DUMMY))
.line_spacing(Some(300), None, Some(300), Some(LineSpacingType::Auto)),
)
.add_paragraph(
Paragraph::new()
.add_run(Run::new().add_text(DUMMY))
.line_spacing(None, None, Some(300), Some(LineSpacingType::AtLeast)),
)
.add_paragraph(
Paragraph::new()
.add_run(Run::new().add_text(DUMMY).character_spacing(100))
.line_spacing(None, Some(300), Some(300), Some(LineSpacingType::E
```
<Overlap Ratio: 0.9112781954887218>

---

--- 277 --
Question ID: 016b434a6124a83ecd1cad9fda874a0aa5689aa9_0
Original Code:
```
fn main() -> Result<(), std::io::Error> {
    vec! { 1, 2, 3 }.len();
    write! { vec![], "" }?;
    println!{""}
    [0]; // separate statement, not indexing into the result of println.
    Ok(())
}
```


Overlapping Code:
```
n main() -> Result<(), std::io::Error> {
vec! { 1, 2, 3 }.len();
write! { vec![], "" }?;
println!{""}
[0]; // separate statement, not indexing into the result of pri
```
<Overlap Ratio: 0.9166666666666666>

---

--- 278 --
Question ID: 63077605e2c62999dd0f25e69279265cbec3a23c_3
Original Code:
```
fn secure_passphrase_identity() {
        let dir = TempDir::new("identity").unwrap();
        let keychain = keychain::CreateOptions::new()
            .password("password")
            .create(dir.path().join("identity.keychain"))
            .unwrap();

        let data = include_bytes!("../../../test/server.p12");
        let mut items = SecItems::default();
        ImportOptions::new()
            .filename("server.p12")
            .secure_passphrase(true)
            .alert_title("alert title")
            .alert_prompt("alert prompt")
            .items(&mut items)
            .keychain(&keychain)
            .import(data)
            .unwrap();
        assert_eq!(1, items.identities.len());
        assert_eq!(0, items.certificates.len());
        assert_eq!(0, items.keys.len());
    }
```


Overlapping Code:
```
phrase_identity() {
let dir = TempDir::new("identity").unwrap();
let keychain = keychain::CreateOptions::new()
.password("password")
.create(dir.path().join("identity.keychain"))
.unwrap();
let data = include_bytes!("../../../test/server.p12");
let mut items = SecItems::default();
ImportOptions::new()
.filename("server.p12")
.secure_passphrase(true)
.alert_title("alert title")
.alert_prompt("alert prompt")
.items(&mut items)
.keychain(&keychain)
.import(data)
.unwrap();
assert_eq!(1, items.identities.len());
assert_eq!(0, items.certificates.len());
assert_e
```
<Overlap Ratio: 0.9336650082918739>

---

--- 279 --
Question ID: 1ca6459842c951bfd8ac8e495b26964a4ca66989_0
Original Code:
```
fn find_instruction_starts(fct: &BytecodeFunction) -> Vec<usize> {
    let code = fct.code();
    let mut pos = 0;
    let mut intruction_start_offsets = Vec::new();

    while pos < fct.code().len() {
        intruction_start_offsets.push(pos);
        let (opcode, width) = read_opcode_and_width(code, pos);
        pos += opcode.size(width) as usize;
    }

    intruction_start_offsets
}
```


Overlapping Code:
```
on) -> Vec<usize> {
let code = fct.code();
let mut pos = 0;
let mut intruction_start_offsets = Vec::new();
while pos < fct.code().len() {
intruction_start_offsets.push(pos);
let (opcode, width) = read_opcode_and_width(code, pos);
pos += opcode.size(w
```
<Overlap Ratio: 0.7331378299120235>

---

--- 280 --
Question ID: 2b978d2c632b3c1d0402d90c490b370ec45c7979_2
Original Code:
```
fn successfully_forwards_an_image_from_rocketchat_to_matrix_when_the_user_is_not_registered_on_matrix() {
    let test = Test::new();
    let (message_forwarder, receiver) = MessageForwarder::new();
    let uploaded_files = Arc::new(Mutex::new(Vec::new()));
    let (create_content_forwarder, create_content_receiver) =
        handlers::MatrixCreateContentHandler::with_forwarder(Arc::clone(&uploaded_files));
    let mut matrix_router = test.default_matrix_routes();
    matrix_router.put(SendMessageEventEndpoint::router_path(), message_forwarder, "send_message_event");
    matrix_router.post(CreateContentEndpoint::router_path(), create_content_forwarder, "create_content");

    let attachments = vec![Attachment {
        description: "Spec image".to_string(),
        image_size: Some(100),
        image_type: Some("image/png".to_string()),
        image_url: Some("/file-upload/image.png".to_string()),
        mimetype: "image/png".to_string(),
        title: "Spec titel".to_string(),
        title_link: "/file-upload/image.png".to_string(),
    }];
    let rocketchat_message = Arc::new(Mutex::new(Some(Message {
        id: "spec_id".to_string(),
        rid: "spec_rid".to_string(),
        msg: "".to_string(),
        ts: "2017-12-12 11:11".to_string(),
        attachments: Some(attachments),
        file: Some(File { mimetype: "image/png".to_string() }),
        u: UserInfo { id: "spec_user_id".to_string(), username: "spec_sender".to_string(), name: "spec sender".to_string() },
        mentions: Vec::new(),
        channels: Vec::new(),
        updated_at: "2017-12-12 11:11".to_string(),
    })));
    let rocketchat_message_responder = handlers::RocketchatMessageResponder { message: rocketchat_message };
    let mut rocketchat_router = test.default_rocketchat_routes();
    rocketchat_router.get(CHAT_GET_MESSAGE_PATH, rocketchat_message_responder, "get_chat_message");
    let mut files = HashMap::new();
    files.insert("image.png".to_string(), b"image".to_vec());
    rocketchat_router.get("/file-upload/:filename", handlers::RocketchatFileResponder { files: files }, "get_file");

    let test = test
        .with_matrix_routes(matrix_router)
        .with_rocketchat_mock()
        .with_custom_rocketchat_routes(rocketchat_router)
        .with_connected_admin_room()
        .with_logged_in_user()
        .with_bridged_room(("spec_channel", vec!["spec_user"]))
        .run();

    // discard welcome message
    receiver.recv_timeout(default_timeout()).unwrap();
    // discard connect message
    receiver.recv_timeout(default_timeout()).unwrap();
    // discard login message
    receiver.recv_timeout(default_timeout()).unwrap();
    // discard room bridged message
    receiver.recv_timeout(default_timeout()).unwrap();

    let message = WebhookMessage {
        message_id: "spec_id".to_string(),
        token: Some(RS_TOKEN.to_string()),
        channel_id: "spec_channel_id".to_string(),
        channel_name: Some("spec_channel".to_string()),
        user_id: "new_user_id".to_string(),
        user_name: "new_spec_user".to_string(),
        text: "Uploaded an image".to_string(),
    };
    let payload = to_string(&message).unwrap();

    helpers::simulate_message_from_rocketchat(&test.config.as_url, &payload);

    let file = create_content_receiver.recv_timeout(default_timeout()).unwrap();
    // this would contain the image data, but for the test this was just a string converted to bytes.
    assert_eq!(file, "image");

    let message = receiver.recv_timeout(default_timeout()).unwrap();
    assert!(message.contains("Spec titel"));
    assert!(message.contains("m.image"));
    let files = uploaded_files.lock().unwrap();
    let file_id = files.first().unwrap();
    assert!(message.contains(&format!("mxc://localhost/{}", file_id)));
}
```


Overlapping Code:
```
ards_an_image_from_rocketchat_to_matrix_when_the_user_is_not_registered_on_matrix() {
let test = Test::new();
let (message_forwarder, receiver) = MessageForwarder::new();
let uploaded_files = Arc::new(Mutex::new(Vec::new()));
let (create_content_forwarder, create_content_receiver) =
handlers::MatrixCreateContentHandler::with_forwarder(Arc::clone(&uploaded_files));
let mut matrix_router = test.default_matrix_routes();
matrix_router.put(SendMessageEventEndpoint::router_path(), message_forwarder, "send_message_event");
matrix_router.post(CreateContentEndpoint::router_path(), create_content_forwarder, "create_content");
let attachments = vec![Attachment {
description: "Spec image".to_string(),
image_size: Some(100),
image_type: Some("image/png".to_string()),
image_url: Some("/file-upload/image.png".to_string()),
mimetype: "image/png".to_string(),
title: "Spec titel".to_string(),
title_link: "/file-upload/image.png".to_string(),
}];
let rocketchat_message = Arc::new(Mutex::new(Some(Message {
id: "spec_id".to_string(),
rid: "spec_rid".to_string(),
msg: "".to_string(),
ts: "2017-12-12 11:11".to_string(),
attachments: Some(attachments),
file: Some(File { mimetype: "image/png".to_string() }),
u: UserInfo { id: "spec_user_id".to_string(), username: "spec_sender".to_string(), name: "spec sender".to_string() },
mentions: Vec::new(),
channels: Vec::new(),
updated_at: "2017-12-12 11:11".to_string(),
})));
let rocketchat_message_responder = handlers::RocketchatMessageResponder { message: rocketchat_message };
let mut rocketchat_router = test.default_rocketchat_routes();
rocketchat_router.get(CHAT_GET_MESSAGE_PATH, rocketchat_message_responder, "get_chat_message");
let mut files = HashMap::new();
files.insert("image.png".to_string(), b"image".to_vec());
rocketchat_router.get("/file-upload/:filename", handlers::RocketchatFileResponder { files: files }, "get_file");
let test = test
.with_matrix_routes(matrix_router)
.with_rocketchat_mock()
.with_custom_rocketchat_routes(rocketchat_router)
.with_connected_admin_room()
.with_logged_in_user()
.with_bridged_room(("spec_channel", vec!["spec_user"]))
.run();
// discard welcome message
receiver.recv_timeout(default_timeout()).unwrap
```
<Overlap Ratio: 0.9909747292418772>

---

--- 281 --
Question ID: 5b32d1e6c1940d90f8cbee20a89569b9377e63cb_9
Original Code:
```
fn get_node(ctx: &Context, args: Vec<String>) -> RedisResult {
    ctx.auto_memory();

    let mut parsed = GET_NODE_CMD.with(|cmd| cmd.parse_args(args))?;

    let index_suffix = parsed.remove("index").unwrap().as_string()?;
    let node_suffix = parsed.remove("node").unwrap().as_string()?;

    let node_name = format!("{}.{}.{}", PREFIX, index_suffix, node_suffix);

    ctx.log_debug(format!("get key: {}", node_name).as_str());

    let key = ctx.open_key(&node_name);

    let value = key
        .get_value::<NodeRedis>(&HNSW_NODE_REDIS_TYPE)?
        .ok_or_else(|| format!("Node: {} does not exist", &node_name))?;

    Ok(value.into())
}
```


Overlapping Code:
```
ode(ctx: &Context, args: Vec<String>) -> RedisResult {
ctx.auto_memory();
let mut parsed = GET_NODE_CMD.with(|cmd| cmd.parse_args(args))?;
let index_suffix = parsed.remove("index").unwrap().as_string()?;
let node_suffix = parsed.remove("node").unwrap().as_string()?;
let node_name = format!("{}.{}.{}", PREFIX, index_suffix, node_suffix);
ctx.log_debug(format!("get key: {}", node_name).as_str());
let key = ctx.open_key(&node_name);
let value = key
.get_value::<NodeRedis>(&HNSW_NODE_REDIS_TYPE)?
.ok_or_else(|| format!("Node: {} does n
```
<Overlap Ratio: 0.9117147707979627>

---

--- 282 --
Question ID: a02fceded9209aad274883d3388c8126df7649ac_0
Original Code:
```
pub fn indoc(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let source = TokenStream::from(input);

    let len = source.clone().into_iter().count();
    if len != 1 {
        panic!(
            "argument must be a single string literal, but got {} tokens",
            len
        );
    }

    let lit = match syn::parse2::<Lit>(source) {
        Ok(lit) => lit,
        Err(_) => {
            panic!("argument must be a single string literal");
        }
    };

    let lit = match lit {
        Lit::Str(lit) => {
            let v = unindent(&lit.value());
            Lit::Str(LitStr::new(&v, lit.span()))
        }
        Lit::ByteStr(lit) => {
            let v = unindent_bytes(&lit.value());
            Lit::ByteStr(LitByteStr::new(&v, lit.span()))
        }
        _ => {
            panic!("argument must be a single string literal");
        }
    };

    proc_macro::TokenStream::from(quote!(#lit))
}
```


Overlapping Code:
```
(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
let source = TokenStream::from(input);
let len = source.clone().into_iter().count();
if len != 1 {
panic!(
"argument must be a single string literal, but got {} tokens",
len
);
}
let lit = match syn::parse2::<Lit>(source) {
Ok(lit) => lit,
Err(_) => {
panic!("argument must be a single string literal");
}
};
let lit = match lit {
Lit::Str(lit) => {
let v = unindent(&lit.value());
Lit::Str(LitStr::new(&v, lit.span()))
}
Lit::ByteStr(lit) => {
let v = unindent_bytes(&lit.value());
Lit::ByteStr(LitByteStr::new(&v, lit.span()))
}
_ => {
panic!("argument must be a single string literal");
}
};
proc_macro::TokenStream:
```
<Overlap Ratio: 0.9537815126050421>

---

--- 283 --
Question ID: 0b0affba01c6539766f8537df100100d0621917c_23
Original Code:
```
fn test_gt_insensitive() {
        let test = r#"gT 5"#;
        let want = Token::Gt;
        match scan(test).get(0) {
            Some(t) => assert_eq!(*t, want),
            _ => panic!("no token"),
        }
    }
```


Overlapping Code:
```
est_gt_insensitive() {
let test = r#"gT 5"#;
let want = Token::Gt;
match scan(test).get(0) {
Some(t) => assert_eq!(*t, want),
_ => panic!("no token"),
```
<Overlap Ratio: 0.9493670886075949>

---

--- 284 --
Question ID: 11ce203089b093a0fe111d1b15cd09e8bfe5ad3e_0
Original Code:
```
pub fn init(header: &'static mut VirtIOHeader) {
    let event_buf = Box::leak(Box::new([0u64; 32]));
    let input = VirtIOInput::new(header, event_buf).expect("failed to create input driver");

    let driver = Arc::new(VirtIOInputDriver(Mutex::new(input)));
    IRQ_MANAGER.write().register_all(driver.clone());
    DRIVERS.write().push(driver);
}
```


Overlapping Code:
```
OHeader) {
let event_buf = Box::leak(Box::new([0u64; 32]));
let input = VirtIOInput::new(header, event_buf).expect("failed to create input driver");
let driver = Arc::new(VirtIOInputDriver(Mutex::new(input)));
IRQ_MANAGER.write().register_all(driver.clone());
DRI
```
<Overlap Ratio: 0.7993920972644377>

---

--- 285 --
Question ID: 390d2b21871e5247833a2f064d36859858c84b89_1
Original Code:
```
fn handles_empty_paths() {
        let actual = main(
            &model::Configuration {
                paths: String::new(),
                ..model::stubs::configuration()
            },
            path::Path::new("."),
        );

        let actual = actual.unwrap();
        assert!(actual.is_empty());
    }
```


Overlapping Code:
```
{
let actual = main(
&model::Configuration {
paths: String::new(),
..model::stubs::configuration()
},
path::Path::new("."),
);
let actual = actual.unwrap();
assert!(actua
```
<Overlap Ratio: 0.8056872037914692>

---

--- 286 --
Question ID: 705b144edcd33a7acc3d6c5ba52f74b29b11babf_3
Original Code:
```
fn save_follower_relation<S: Storage>(
    storage: &mut S,
    owner: &CanonicalAddr,
    followed_addr: &CanonicalAddr,
) -> StdResult<()> {
    // save follower relation
    let mut vec_storage = PrefixedStorage::multilevel(
        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],
        storage,
    );
    let vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;
    let vec_storage_len = vec_storage.len();

    let link_storage = ReadonlyPrefixedStorage::multilevel(
        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],
        storage,
    );

    let idx: u32 =
        get_bin_data(&link_storage, owner.as_slice()).unwrap_or_else(|_| vec_storage_len);
    let follower = Follower {
        who: owner.clone(),
        active: true,
    };

    let mut vec_storage = PrefixedStorage::multilevel(
        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],
        storage,
    );
    let mut vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;
    if idx == vec_storage_len {
        vec_storage.push(&follower)?;
    } else {
        vec_storage.set_at(idx, &follower)?;
    }

    let mut link_storage = PrefixedStorage::multilevel(
        &[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],
        storage,
    );
    if idx == vec_storage_len {
        set_bin_data(&mut link_storage, owner.as_slice(), &idx)?;
    }

    Ok(())
}
```


Overlapping Code:
```
 save_follower_relation<S: Storage>(
storage: &mut S,
owner: &CanonicalAddr,
followed_addr: &CanonicalAddr,
) -> StdResult<()> {
// save follower relation
let mut vec_storage = PrefixedStorage::multilevel(
&[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],
storage,
);
let vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;
let vec_storage_len = vec_storage.len();
let link_storage = ReadonlyPrefixedStorage::multilevel(
&[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],
storage,
);
let idx: u32 =
get_bin_data(&link_storage, owner.as_slice()).unwrap_or_else(|_| vec_storage_len);
let follower = Follower {
who: owner.clone(),
active: true,
};
let mut vec_storage = PrefixedStorage::multilevel(
&[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_VEC],
storage,
);
let mut vec_storage = AppendStoreMut::<Follower, _>::attach_or_create(&mut vec_storage)?;
if idx == vec_storage_len {
vec_storage.push(&follower)?;
} else {
vec_storage.set_at(idx, &follower)?;
}
let mut link_storage = PrefixedStorage::multilevel(
&[PREFIX_FOLLOWERS, &followed_addr.as_slice(), PREFIX_LINK],
storage,
);
if idx == vec_storage_len {
set_bin_data(&mut link_storage, o
```
<Overlap Ratio: 0.9700889248181084>

---

--- 287 --
Question ID: 618d60fa67d4afe25f183f31ec8cd5308ae7c79d_3
Original Code:
```
fn build_context(program: &Bytes) -> Result<DebugContext, String> {
    use addr2line::object::{Object, ObjectSection};

    // Adapted from https://github.com/gimli-rs/addr2line/blob/fc2de9f47ae513f5a54448167b476ff50f07dca6/src/lib.rs#L87-L148
    // for working with gimli::EndianArcSlice type
    let file = addr2line::object::File::parse(program.as_ref())
        .map_err(|e| format!("object parsing error: {}", e))?;

    let dwarf = gimli::Dwarf::load(|id| {
        let data = file
            .section_by_name(id.name())
            .and_then(|section| section.uncompressed_data().ok())
            .unwrap_or(Cow::Borrowed(&[]));
        Ok(gimli::EndianArcSlice::new(
            Arc::from(&*data),
            gimli::RunTimeEndian::Little,
        ))
    })
    .map_err(|e: gimli::Error| format!("dwarf load error: {}", e))?;

    let addr_context = Addr2LineContext::from_dwarf(dwarf)
        .map_err(|e| format!("context creation error: {}", e))?;

    let debug_frame_section = file
        .section_by_name(gimli::SectionId::DebugFrame.name())
        .and_then(|s| s.uncompressed_data().ok())
        .ok_or_else(|| "Provided binary is missing .debug_frame section!".to_string())?;
    let debug_frame_reader = Addr2LineEndianReader::new(
        Arc::from(&*debug_frame_section),
        gimli::RunTimeEndian::Little,
    );

    Ok(DebugContext {
        addr_context,
        debug_frame: debug_frame_reader.into(),
    })
}
```


Overlapping Code:
```
Context, String> {
use addr2line::object::{Object, ObjectSection};
// Adapted from https://github.com/gimli-rs/addr2line/blob/fc2de9f47ae513f5a54448167b476ff50f07dca6/src/lib.rs#L87-L148
// for working with gimli::EndianArcSlice type
let file = addr2line::object::File::parse(program.as_ref())
.map_err(|e| format!("object parsing error: {}", e))?;
let dwarf = gimli::Dwarf::load(|id| {
let data = file
.section_by_name(id.name())
.and_then(|section| section.uncompressed_data().ok())
.unwrap_or(Cow::Borrowed(&[]));
Ok(gimli::EndianArcSlice::new(
Arc::from(&*data),
gimli::RunTimeEndian::Little,
))
})
.map_err(|e: gimli::Error| format!("dwarf load error: {}", e))?;
let addr_context = Addr2LineContext::from_dwarf(dwarf)
.map_err(|e| format!("context creation error: {}", e))?;
let debug_frame_section = file
.section_by_name(gimli::SectionId::DebugFrame.name())
.and_then(|s| s.uncompressed_data().ok())
.ok_or_else(|| "Provided binary is missing .debug_frame section!".to_string())?;
let debug_frame_reader = Addr2LineEndianReader::new(
Arc::from(&*debug_frame_section),
gimli::RunTimeEndian::Little,
);
Ok(DebugContext {
addr_context,
debug_fram
```
<Overlap Ratio: 0.9326845093268451>

---

--- 288 --
Question ID: 7a35cd8f8ca91a6b6aaf419a68a0563c8d688a9a_3
Original Code:
```
fn test_databases_books_annotated() {
        let app = app_from_test_db("books-annotated");

        assert_eq!(app.stor().count_books(), 3);
        assert_eq!(app.stor().count_annotations(), 10);
    }
```


Overlapping Code:
```
ks_annotated() {
let app = app_from_test_db("books-annotated");
assert_eq!(app.stor().count_books(), 3);
assert_eq!(app.stor().count_annotations(), 10
```
<Overlap Ratio: 0.8571428571428571>

---

--- 289 --
Question ID: 34498ed0c9dd848a3ba9a31a646eb0ec5ab5028b_1
Original Code:
```
fn return_popped_empty() {
        const MAX_IN_FLY: usize = 3;
        const COMMIT_MARK: u8 = 0;

        let mut queue = TxQueueBuilder::new(MAX_IN_FLY).build();

        queue
            .return_popped(get_tx_data(
                AggregatedActionType::CommitBlocks,
                BlockNumber(1),
                vec![COMMIT_MARK, 0],
            ))
            .unwrap();
    }
```


Overlapping Code:
```
n_popped_empty() {
const MAX_IN_FLY: usize = 3;
const COMMIT_MARK: u8 = 0;
let mut queue = TxQueueBuilder::new(MAX_IN_FLY).build();
queue
.return_popped(get_tx_data(
AggregatedActionType::CommitBlocks,
BlockNumber(1),
vec![COMMIT_MARK, 0],
))
.unwrap
```
<Overlap Ratio: 0.9505703422053232>

---

--- 290 --
Question ID: bcf073018c381b64faf9337df7e306a087c8a090_7
Original Code:
```
fn insert_8_char_string(b: &mut Bencher) {
    let mut strings: Vec<_> = Vec::new();
    for i in 1..1001 {
        strings.push(format!("{:x}", -i));
    }

    let mut m = new_map();
    b.iter(|| {
        for key in &strings {
            m.insert(key, key);
        }
    })
}
```


Overlapping Code:
```
ut Bencher) {
let mut strings: Vec<_> = Vec::new();
for i in 1..1001 {
strings.push(format!("{:x}", -i));
}
let mut m = new_map();
b.iter(|| {
for key
```
<Overlap Ratio: 0.6818181818181818>

---

--- 291 --
Question ID: 14d51673a1e7dae1cbaac81bfd544f62dd8e1c53_30
Original Code:
```
fn dec_by_inclusive_type_dependent_overflow() {
  let mut r11 = (255u8..=248u8).dec_by::<50>();
  assert_eq!(r11.next(), Some(255));
  assert_eq!(r11.next(), None);
  let mut r12 = (255u32..=248u32).dec_by::<{ usize::MAX }>();
  assert_eq!(r12.next(), Some(255));
  assert_eq!(r12.next(), None);
  let mut r13 = (255i32..=248i32).dec_by::<{ u32::MAX as usize }>();
  assert_eq!(r13.next(), Some(255));
  assert_eq!(r13.next(), None);
  let mut r14 = (i16::MAX..=i16::MAX).dec_by::<1>();
  assert_eq!(r14.next(), Some(32767));
  assert_eq!(r14.next(), None);
}
```


Overlapping Code:
```
ec_by_inclusive_type_dependent_overflow() {
let mut r11 = (255u8..=248u8).dec_by::<50>();
assert_eq!(r11.next(), Some(255));
assert_eq!(r11.next(), None);
let mut r12 = (255u32..=248u32).dec_by::<{ usize::MAX }>();
assert_eq!(r12.next(), Some(255));
assert_eq!(r12.next(), None);
let mut r13 = (255i32..=248i32).dec_by::<{ u32::MAX as usize }>();
assert_eq!(r13.next(), Some(255));
assert_eq!(r13.next(), None);
let mut r14 = (i16::MAX..=i16::MAX).dec_by::<1>();
assert_eq!(r14.next(), Some(32767));

```
<Overlap Ratio: 0.9345794392523364>

---

--- 292 --
Question ID: 7d188a17adbe857399b198225f6e002b1072dbd4_2
Original Code:
```
fn audio(synth: &mut Synth, buffer: &mut Buffer) {
    let midi_messages: Vec<Vec<u8>> = synth.midi_receiver.try_iter().collect();
    for message in midi_messages {
        if message.len() == 3 {
            let step = message[1] as f32;
            if message[0] == 144 {
                synth
                    .midi
                    .midi_pitch
                    .set_step(&mut synth.controls, step.into());
                synth.karplus.on(&mut synth.controls, &mut synth.state);
            } else if message[0] == 128 {
                synth.karplus.off(&mut synth.controls);
            }
        }
    }

    let sample_rate = buffer.sample_rate() as f32;
    for frame in buffer.frames_mut() {
        let amp = synth.rack.mono(
            &synth.controls,
            &mut synth.state,
            &mut synth.outputs,
            &mut synth.buffers,
            sample_rate,
        );

        for channel in frame {
            *channel = amp;
        }
        synth.sender.send(amp).unwrap();
    }
}
```


Overlapping Code:
```
n audio(synth: &mut Synth, buffer: &mut Buffer) {
let midi_messages: Vec<Vec<u8>> = synth.midi_receiver.try_iter().collect();
for message in midi_messages {
if message.len() == 3 {
let step = message[1] as f32;
if message[0] == 144 {
synth
.midi
.midi_pitch
.set_step(&mut synth.controls, step.into());
synth.karplus.on(&mut synth.controls, &mut synth.state);
} else if message[0] == 128 {
synth.karplus.off(&mut synth.controls);
}
}
}
let sample_rate = buffer.sample_rate() as f32;
for frame in buffer.frames_mut() {
let amp = synth.rack.mono(
&synth.controls,
&mut synth.state,
&mut synth.outputs,
&mut synth.buffers,
sample_rate,
);
for channel in frame {
*channel = amp;
}
synth.sender.send(amp).unwra
```
<Overlap Ratio: 0.9873949579831933>

---

--- 293 --
Question ID: 1abc65f64eec87163d57f09aaf6b5b24fae16bb6_5
Original Code:
```
fn parse2() {
    use crate::Pane;
    use crate::PANE_ALL;

    let origin = Pane {
        #[cfg(feature = "tmux_1_6")]
        active: Some(true),
        #[cfg(feature = "tmux_2_6")]
        at_bottom: Some(true),
        #[cfg(feature = "tmux_2_6")]
        at_left: Some(true),
        #[cfg(feature = "tmux_2_6")]
        at_right: Some(true),
        #[cfg(feature = "tmux_2_6")]
        at_top: Some(true),
        #[cfg(feature = "tmux_2_0")]
        bottom: Some(63),
        #[cfg(feature = "tmux_1_8")]
        current_command: Some("bash".to_string()),
        #[cfg(feature = "tmux_1_7")]
        current_path: Some("/home/user".to_string()),
        #[cfg(feature = "tmux_1_6")]
        dead: Some(false),
        #[cfg(feature = "tmux_2_0")]
        dead_status: None,
        #[cfg(feature = "tmux_2_6")]
        format: Some(true),
        #[cfg(feature = "tmux_1_6")]
        height: Some(64),
        #[cfg(feature = "tmux_1_6")]
        id: Some(0),
        #[cfg(feature = "tmux_1_8")]
        in_mode: Some(false),
        #[cfg(feature = "tmux_1_7")]
        index: Some(0),
        #[cfg(feature = "tmux_2_0")]
        input_off: Some(false),
        #[cfg(feature = "tmux_2_0")]
        left: Some(0),
        #[cfg(feature = "tmux_3_0")]
        marked: Some(false),
        #[cfg(feature = "tmux_3_0")]
        marked_set: Some(false),
        #[cfg(feature = "tmux_2_5")]
        mode: None,
        #[cfg(feature = "tmux_3_1")]
        path: None,
        #[cfg(feature = "tmux_1_6")]
        pid: Some(1945),
        #[cfg(feature = "tmux_2_6")]
        pipe: Some(false),
        #[cfg(feature = "tmux_2_0")]
        right: Some(176),
        #[cfg(feature = "tmux_2_5")]
        search_string: None,
        #[cfg(feature = "tmux_1_6")]
        start_command: None,
        #[cfg(all(feature = "tmux_1_6", not(feature = "tmux_2_0")))]
        start_path: None,
        #[cfg(feature = "tmux_1_9")]
        synchronized: Some(false),
        #[cfg(feature = "tmux_1_8")]
        tabs: None,
        #[cfg(feature = "tmux_1_6")]
        title: Some("title".to_string()),
        #[cfg(feature = "tmux_2_0")]
        top: Some(0),
        #[cfg(feature = "tmux_1_6")]
        tty: Some("/dev/pts/2".to_string()),
        #[cfg(feature = "tmux_1_6")]
        width: Some(177),
    };

    let pane_vec = vec![
        // pane_active
        #[cfg(feature = "tmux_1_6")]
        "1",
        // pane_at_bottom
        #[cfg(feature = "tmux_2_6")]
        "1",
        // pane_at_left
        #[cfg(feature = "tmux_2_6")]
        "1",
        // pane_at_right
        #[cfg(feature = "tmux_2_6")]
        "1",
        // pane_at_top
        #[cfg(feature = "tmux_2_6")]
        "1",
        // pane_bottom
        #[cfg(feature = "tmux_2_0")]
        "63",
        // pane_current_command
        #[cfg(feature = "tmux_1_8")]
        "bash",
        // pane_current_path
        #[cfg(feature = "tmux_1_7")]
        "/home/user",
        // pane_dead
        #[cfg(feature = "tmux_1_6")]
        "0",
        // pane_dead_status
        #[cfg(feature = "tmux_2_0")]
        "",
        // pane_format
        #[cfg(feature = "tmux_2_6")]
        "1",
        // pane_height
        #[cfg(feature = "tmux_1_6")]
        "64",
        // pane_id
        #[cfg(feature = "tmux_1_6")]
        "%0",
        // pane_in_mode
        #[cfg(feature = "tmux_1_8")]
        "0",
        // pane_index
        #[cfg(feature = "tmux_1_7")]
        "0",
        // pane_input_off
        #[cfg(feature = "tmux_2_0")]
        "0",
        // pane_left
        #[cfg(feature = "tmux_2_0")]
        "0",
        // pane_marked
        #[cfg(feature = "tmux_3_0")]
        "0",
        // pane_marked_set
        #[cfg(feature = "tmux_3_0")]
        "0",
        // pane_mode
        #[cfg(feature = "tmux_2_5")]
        "",
        // pane_path
        #[cfg(feature = "tmux_3_1")]
        "",
        // pane_pid
        #[cfg(feature = "tmux_1_6")]
        "1945",
        // pane_pipe
        #[cfg(feature = "tmux_2_6")]
        "0",
        // pane_right
        #[cfg(feature = "tmux_2_0")]
        "176",
        // pane_search_string
        #[cfg(feature = "tmux_2_5")]
        "",
        // pane_start_command
        #[cfg(feature = "tmux_1_6")]
        "",
        // pane_start_path
        #[cfg(all(feature = "tmux_1_6", not(feature = "tmux_2_0")))]
        "",
        // pane_synchronized
        #[cfg(feature = "tmux_1_9")]
        "0",
        // pane_tabs
        #[cfg(feature = "tmux_1_8")]
        "",
        // pane_title
        #[cfg(feature = "tmux_1_6")]
        "title",
        // pane_top
        #[cfg(feature = "tmux_2_0")]
        "0",
        // pane_tty
        #[cfg(feature = "tmux_1_6")]
        "/dev/pts/2",
        // pane_width
        #[cfg(feature = "tmux_1_6")]
        "177",
    ];
    //let pane_str = "1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0''asus'0'/dev/pts/2'177";
    //let pane_str = "1'1'1'1'1'63'bash'/home/user'0''1'64'%0'0'0'0'0'0'0''1945'0'176'''0'8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176'asus'0'/dev/pts/2'177";
    let pane_str = pane_vec.join("'");
    let pane = Pane::from_str(&pane_str, PANE_ALL).unwrap();
    //assert_eq!(pane.current_path, Some("/home/user".to_string()));
    //assert_eq!(pane.tty, Some("/dev/pts/2".to_string()));
    assert_eq!(origin, pane);
}
```


Overlapping Code:
```
 crate::Pane;
use crate::PANE_ALL;
let origin = Pane {
#[cfg(feature = "tmux_1_6")]
active: Some(true),
#[cfg(feature = "tmux_2_6")]
at_bottom: Some(true),
#[cfg(feature = "tmux_2_6")]
at_left: Some(true),
#[cfg(feature = "tmux_2_6")]
at_right: Some(true),
#[cfg(feature = "tmux_2_6")]
at_top: Some(true),
#[cfg(feature = "tmux_2_0")]
bottom: Some(63),
#[cfg(feature = "tmux_1_8")]
current_command: Some("bash".to_string()),
#[cfg(feature = "tmux_1_7")]
current_path: Some("/home/user".to_string()),
#[cfg(feature = "tmux_1_6")]
dead: Some(false),
#[cfg(feature = "tmux_2_0")]
dead_status: None,
#[cfg(feature = "tmux_2_6")]
format: Some(true),
#[cfg(feature = "tmux_1_6")]
height: Some(64),
#[cfg(feature = "tmux_1_6")]
id: Some(0),
#[cfg(feature = "tmux_1_8")]
in_mode: Some(false),
#[cfg(feature = "tmux_1_7")]
index: Some(0),
#[cfg(feature = "tmux_2_0")]
input_off: Some(false),
#[cfg(feature = "tmux_2_0")]
left: Some(0),
#[cfg(feature = "tmux_3_0")]
marked: Some(false),
#[cfg(feature = "tmux_3_0")]
marked_set: Some(false),
#[cfg(feature = "tmux_2_5")]
mode: None,
#[cfg(feature = "tmux_3_1")]
path: None,
#[cfg(feature = "tmux_1_6")]
pid: Some(1945),
#[cfg(feature = "tmux_2_6")]
pipe: Some(false),
#[cfg(feature = "tmux_2_0")]
right: Some(176),
#[cfg(feature = "tmux_2_5")]
search_string: None,
#[cfg(feature = "tmux_1_6")]
start_command: None,
#[cfg(all(feature = "tmux_1_6", not(feature = "tmux_2_0")))]
start_path: None,
#[cfg(feature = "tmux_1_9")]
synchronized: Some(false),
#[cfg(feature = "tmux_1_8")]
tabs: None,
#[cfg(feature = "tmux_1_6")]
title: Some("title".to_string()),
#[cfg(feature = "tmux_2_0")]
top: Some(0),
#[cfg(feature = "tmux_1_6")]
tty: Some("/dev/pts/2".to_string()),
#[cfg(feature = "tmux_1_6")]
width: Some(177),
};
let pane_vec = vec![
// pane_active
#[cfg(feature = "tmux_1_6")]
"1",
// pane_at_bottom
#[cfg(feature = "tmux_2_6")]

```
<Overlap Ratio: 0.9873217115689382>

---

--- 294 --
Question ID: d298a20f78a7cd8b9fd933bc3d999cb4a2f685ba_0
Original Code:
```
fn make_column(
    py: Python,
    children: &PyAny,
    spacing: Option<u16>,
    padding: Option<u16>,
    width: Option<&WrappedLength>,
    height: Option<&WrappedLength>,
    max_width: Option<u32>,
    max_height: Option<u32>,
    align_items: Option<&WrappedAlign>,
) -> PyResult<WrappedWidgetBuilder> {
    let children = children
        .iter()?
        .filter_map(|child| match child {
            Ok(child) => match child.is_none() {
                false => match child.extract() {
                    Ok(WrappedWidgetBuilder(widget)) => Some(widget),
                    Err(err) => {
                        err.print(py);
                        None
                    },
                },
                true => None,
            },
            Err(err) => {
                err.print(py);
                None
            },
        })
        .collect();
    let el = ColumnBuilder {
        children,
        spacing,
        padding,
        width: width.map(|o| o.0),
        height: height.map(|o| o.0),
        max_width,
        max_height,
        align_items: align_items.map(|o| o.0),
    };
    Ok(el.into())
}
```


Overlapping Code:
```
umn(
py: Python,
children: &PyAny,
spacing: Option<u16>,
padding: Option<u16>,
width: Option<&WrappedLength>,
height: Option<&WrappedLength>,
max_width: Option<u32>,
max_height: Option<u32>,
align_items: Option<&WrappedAlign>,
) -> PyResult<WrappedWidgetBuilder> {
let children = children
.iter()?
.filter_map(|child| match child {
Ok(child) => match child.is_none() {
false => match child.extract() {
Ok(WrappedWidgetBuilder(widget)) => Some(widget),
Err(err) => {
err.print(py);
None
},
},
true => None,
},
Err(err) => {
err.print(py);
None
},
})
.collect();
let el = ColumnBuilder {
children,
spacing,
padding,
width: width.map(|o| o.0),
height: height.map(|o| o.0),
max_width,
max_height,
align_items: align_items.map(|o| o.0),
};
Ok(el.into())
}
```
<Overlap Ratio: 0.985545335085414>

---

--- 295 --
Question ID: 2d258eff0d2cd59939147908da5d87f11534bc63_3
Original Code:
```
fn reestablish_channel_test() {
        let msg_hex = "\
            00880100000000000000000000000000000000000000000000000000000000000000000000000000\
            000b0000000000000002000200000000000000000000000000000000000000000000000000000000\
            0000031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6";
        let msg_bytes = hex::decode(msg_hex).unwrap();

        let msg_correct = ReestablishChannel {
            channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
            next_local_commitment_number: 11,
            next_remote_revocation_number: 2,
            last_remote_commit_secret: u8_32_from_hex("0002000000000000000000000000000000000000000000000000000000000000").unwrap(),
            local_unrevoked_commit_point: RawPublicKey::from_hex("031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6").unwrap(),
        };
        let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);

        let mut cursor = Cursor::new(msg_bytes.clone());
        let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
        assert_eq!(&msg, &wrapped_msg_correct);

        // Now check deserialization
        let mut new_msg_bytes = vec![];
        BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
        assert_eq!(new_msg_bytes, msg_bytes);
    }
```


Overlapping Code:
```
\
00880100000000000000000000000000000000000000000000000000000000000000000000000000\
000b0000000000000002000200000000000000000000000000000000000000000000000000000000\
0000031de8e2207c6ad1d81f5458c40b9cb1b519448ad67b00983e411ef522cbb187b6";
let msg_bytes = hex::decode(msg_hex).unwrap();
let msg_correct = ReestablishChannel {
channel_id: ChannelId::from_hex("0100000000000000000000000000000000000000000000000000000000000000").unwrap(),
next_local_commitment_number: 11,
next_remote_revocation_number: 2,
last_remote_commit_secret: u8_32_from_hex("0002000000000000000000000000000000000000000000000000000000000000").unwrap(),
local_unrevoked_commit_poin").unwrap(),
};
let wrapped_msg_correct = Message::ReestablishChannel(msg_correct);
let mut cursor = Cursor::new(msg_bytes.clone());
let msg = BinarySD::deserialize::<Message, _>(&mut cursor).unwrap();
assert_eq!(&msg, &wrapped_msg_correct);
// Now check deserialization
let mut new_msg_bytes = vec![];
BinarySD::serialize(&mut new_msg_bytes, &wrapped_msg_correct).unwrap();
assert_eq!(new_msg_bytes, msg_bytes);
}
```
<Overlap Ratio: 0.8837209302325582>

---

--- 296 --
Question ID: 513c01a10ce557423b902e4c7d2acbb446f4d2b2_4
Original Code:
```
pub fn represent_into_bits(x: u64) -> Vec<u8> {
        let mut result = Vec::with_capacity(64);
        let mut x = x;
        for _ in 0..64 {
            let bit = x & 1;
            let bit = bit as u8;
            result.push(bit);
            x >>= 1;
        }
        assert_eq!(result.len(), 64);
        result
    }
```


Overlapping Code:
```
) -> Vec<u8> {
let mut result = Vec::with_capacity(64);
let mut x = x;
for _ in 0..64 {
let bit = x & 1;
let bit = bit as u8;
result.push(bit);
x >>= 1;
}
```
<Overlap Ratio: 0.6814159292035398>

---

--- 297 --
Question ID: fa66a4903760d0893eca7c35bd266573e901b2b5_14
Original Code:
```
fn dropped_update_action() {
    let mut state = (DownlinkState::Synced, SharedValue::new(Value::from(13)));

    let machine = unvalidated(Value::from(0));
    let (action, _) = make_update();

    let result = machine.handle_action_request(&mut state, action);

    let (dl_state, data_state) = state;

    assert!(result.is_ok());
    let response = result.unwrap();

    assert!(
        matches!(response, Response{ event: Some(ev), command: Some(Command::Action(cmd)) } if *ev == *data_state && *cmd == *data_state)
    );

    assert_eq!(dl_state, DownlinkState::Synced);
    assert_eq!(*data_state, Value::from(26));
}
```


Overlapping Code:
```
te_action() {
let mut state = (DownlinkState::Synced, SharedValue::new(Value::from(13)));
let machine = unvalidated(Value::from(0));
let (action, _) = make_update();
let result = machine.handle_action_request(&mut state, action);
let (dl_state, data_state) = state;
assert!(result.is_ok());
let response = result.unwrap();
assert!(
matches!(response, Response{ event: Some(ev), command: Some(Command::Action(cmd)) } if *ev == *data_state && *cmd == *data_state)
);
assert_eq!(dl_state, DownlinkState::Synced);
assert_eq!(*data_state, Value::from(26))
```
<Overlap Ratio: 0.9683098591549296>

---

--- 298 --
Question ID: 2d21e3d23b05466323d410b8d353bafba83dd045_2
Original Code:
```
fn set_limited_discoverable_bad_adv_type() {
    let mut sink = RecordingSink::new();
    {
        let mut fixture = Fixture::new(&mut sink);
        let err = fixture
            .act(|controller| {
                controller.set_limited_discoverable(&DiscoverableParameters {
                    advertising_type: AdvertisingType::ConnectableDirectedHighDutyCycle,
                    advertising_interval: Some((
                        Duration::from_millis(1280),
                        Duration::from_millis(2560),
                    )),
                    address_type: OwnAddressType::Public,
                    filter_policy: AdvertisingFilterPolicy::AllowConnectionAndScan,
                    local_name: Some(LocalName::Shortened(b"testdev")),
                    advertising_data: &[0x01, 0x02, 0x03, 0x04],
                    conn_interval: (Some(Duration::from_millis(5000)), None),
                })
            })
            .err()
            .unwrap();
        assert_eq!(
            err,
            nb::Error::Other(Error::BadAdvertisingType(
                AdvertisingType::ConnectableDirectedHighDutyCycle
            ))
        );
    }

    assert!(!sink.wrote_header());
}
```


Overlapping Code:
```
_bad_adv_type() {
let mut sink = RecordingSink::new();
{
let mut fixture = Fixture::new(&mut sink);
let err = fixture
.act(|controller| {
controller.set_limited_discoverable(&DiscoverableParameters {
advertising_type: AdvertisingType::ConnectableDirectedHighDutyCycle,
advertising_interval: Some((
Duration::from_millis(1280),
Duration::from_millis(2560),
)),
address_type: OwnAddressType::Public,
filter_policy: AdvertisingFilterPolicy::AllowConnectionAndScan,
local_name: Some(LocalName::Shortened(b"testdev")),
advertising_data: &[0x01, 0x02, 0x03, 0x04],
conn_interval: (Some(Duration::from_millis(5000)), None),
})
})
.err()
.unwrap();
assert_eq!(
err,
nb::Error::Other(Error::BadAdvertisingType(
AdvertisingType::ConnectableDirectedHighDutyCycle
))
);
}
assert!(!sink.wrote
```
<Overlap Ratio: 0.9511599511599511>

---

--- 299 --
Question ID: 7f05c250eb491a42bf847b1c2b9e52d9f45b49d7_45
Original Code:
```
fn non_empty_array_set_slice_begin_non_empty_drain_0() {
        let mut ary = SmallArray::from([1, 2, 3, 4, 5]);
        let drained = ary.set_slice(0, 0, &[7, 8, 9]);
        assert_eq!(drained, 0);
        assert_eq!(ary, [7, 8, 9, 1, 2, 3, 4, 5]);
    }
```


Overlapping Code:
```
 non_empty_array_set_slice_begin_non_empty_drain_0() {
let mut ary = SmallArray::from([1, 2, 3, 4, 5]);
let drained = ary.set_slice(0, 0, &[7, 8, 9]);
assert_eq!(drained, 0);
assert_eq!(ary, [7, 8, 9,
```
<Overlap Ratio: 0.9049773755656109>

---

--- 300 --
Question ID: 81dd805358ffce9d8cee14099785d2615d8df9bd_1
Original Code:
```
pub fn DCONST_1(code_reader: CodeReader, thread: Thread) -> (ExecuteResult, CodeReader) {
    println!("DCONST_1");
    let (frame, thread) = thread.pop_frame();

    let Frame {
        operand_stack,
        local_vars,
        method,
        class,
    } = frame;
    let operand_stack = operand_stack.push_double(1f64);
    let local_vars = local_vars;
    let frame = Frame {
        class,
        operand_stack,
        local_vars,
        method,
    };
    let thread = thread.push_frame(frame);
    let execute_result = ExecuteResult { thread, offset: 0 };
    (execute_result, code_reader)
}
```


Overlapping Code:
```
code_reader: CodeReader, thread: Thread) -> (ExecuteResult, CodeReader) {
println!("DCONST_1");
let (frame, thread) = thread.pop_frame();
let Frame {
operand_stack,
local_vars,
method,
class,
} = frame;
let operand_stack = operand_stack.push_double(1f64);
let local_vars = local_vars;
let frame = Frame {
class,
operand_stack,
local_vars,
method,
};
let thread = thread.push_frame(frame);
let execute_result = ExecuteResult { thread, offset: 0 };
(execute_result, code_reader)
}
```
<Overlap Ratio: 0.9676113360323887>

---

--- 301 --
Question ID: cebf25bba760a73d8e3a6086e7f79edc52e1d037_5
Original Code:
```
async fn test_pow() {
        let pow_cfg = Config::load_test()
            .and_then(|cfg| cfg.get::<PoWConfig>("pow"))
            .unwrap_or_default();
        pow_cfg.install_as_global().ok();

        let mut blk = Block::genesis_block();
        blk.header.tx_list = std::iter::repeat_with(H256::zero).take(100).collect();

        for _ in 0..30 {
            let mut header = blk.header.clone();
            header.height = header.height.next_height();
            header.set_ts(Utc::now());
            let new_blk = create_new_block(header, &blk).await.unwrap();
            println!("diff = {}", new_blk.diff);
            println!("time = {}", new_blk.time_stamp() - blk.time_stamp());
            println!("nonce = {}", new_blk.nonce);
            println!("target = {}", U256::MAX / U256::from(new_blk.diff));
            println!("---------------------");
            blk = new_blk;
        }
    }
```


Overlapping Code:
```
let pow_cfg = Config::load_test()
.and_then(|cfg| cfg.get::<PoWConfig>("pow"))
.unwrap_or_default();
pow_cfg.install_as_global().ok();
let mut blk = Block::genesis_block();
blk.header.tx_list = std::iter::repeat_with(H256::zero).take(100).collect();
for _ in 0..30 {
let mut header = blk.header.clone();
header.height = header.height.next_height();
header.set_ts(Utc::now());
let new_blk = create_new_block(header, &blk).await.unwrap();
println!("diff = {}", new_blk.diff);
println!("time = {}", new_blk.time_stamp() - blk.time_stamp());
println!("nonce = {}", new_blk.nonce);
println!("target = {}", U256::MAX / U256::from(new_blk.diff));
println!("
```
<Overlap Ratio: 0.9090909090909091>

---

--- 302 --
Question ID: 79dd1c39a87551e854f1ed5a8f74f505095d4a98_2
Original Code:
```
pub fn adjacent_find(it: Vec<(i64, Array2R)>) -> Vec<usize> {
    let mut v = Vec::new();
    for (idx, i) in it.iter().enumerate() {
        if (idx + 1) >= it.len() {
            break;
        }
        if i.1 == it[idx + 1].1 {
            v.push(idx);
        }
    }
    v
}
```


Overlapping Code:
```
(it: Vec<(i64, Array2R)>) -> Vec<usize> {
let mut v = Vec::new();
for (idx, i) in it.iter().enumerate() {
if (idx + 1) >= it.len() {
break;
}
if i.1 =
```
<Overlap Ratio: 0.7211538461538461>

---

--- 303 --
Question ID: 67280002b1c8875187ee19e0a8fd68d549cdb015_21
Original Code:
```
fn encrypt_cli(encrypt_args: &ArgMatches, verbose: bool) {
    let mut file_supplied = false;
    let mut string_to_encrypt = match encrypt_args.value_of("string") {
        Some(words) => words,
        None => "Hello World!",
    };
    let public_key_path = match encrypt_args.value_of("public-key-path") {
        Some(words) => words,
        None => "keys/public_key.pkcs7.pem",
    };

    let file_to_encrypt: String = match encrypt_args.value_of("file") {
        Some(file) => {
            file_supplied = true;
            match read_to_string(&file) {
                Ok(file_contents) => file_contents.to_owned(),
                Err(_) => String::from("Hello world!"),
            }
        }
        None => String::from("Hello World!"),
    };
    if file_supplied {
        string_to_encrypt = file_to_encrypt.as_ref();
    }
    let ciphertext_pkcs7 = encrypt_str(public_key_path, &string_to_encrypt.as_bytes(), &verbose);
    if verbose.clone() {
        print! {"New ciphertext: "}
    }
    println!(
        "{:#}",
        from_utf8(&ciphertext_pkcs7.as_ref().to_pem().unwrap()).unwrap()
    );
    let mut output_file: String = "".into();
    // todo: verify this in-place doesn't need a different method
    if encrypt_args.is_present("in-place") {
        // this has to check the file that was fed in
        if verbose.clone() {
            println!("Going to try and use input file as the output file (encrypt in place)")
        }
        output_file = encrypt_args.value_of("file").unwrap().into();
    } else {
        match encrypt_args.value_of("output-file") {
            Some(ofile) => {
                if verbose.clone() {
                    println!("Using output-file argas output file")
                }
                output_file = ofile.into()
            }
            None => {}
        };
    }
    if output_file != "" {
        if verbose.clone() {
            println!("Going to write ciphertext to {}", &output_file)
        }
        match write_file(&output_file, &ciphertext_pkcs7.as_ref().to_pem().unwrap()) {
            Ok(_) => {}
            Err(_) => println!("There was an error writing the ciphertext to file!"),
        }
    } else {
        if verbose.clone() {
            println!("output_file variable was never assigned to anything");
        }
    }
}
```


Overlapping Code:
```
encrypt_args: &ArgMatches, verbose: bool) {
let mut file_supplied = false;
let mut string_to_encrypt = match encrypt_args.value_of("string") {
Some(words) => words,
None => "Hello World!",
};
let public_key_path = match encrypt_args.value_of("public-key-path") {
Some(words) => words,
None => "keys/public_key.pkcs7.pem",
};
let file_to_encrypt: String = match encrypt_args.value_of("file") {
Some(file) => {
file_supplied = true;
match read_to_string(&file) {
Ok(file_contents) => file_contents.to_owned(),
Err(_) => String::from("Hello world!"),
}
}
None => String::from("Hello World!"),
};
if file_supplied {
string_to_encrypt = file_to_encrypt.as_ref();
}
let ciphertext_pkcs7 = encrypt_str(public_key_path, &string_to_encrypt.as_bytes(), &verbose);
if verbose.clone() {
print! {"New ciphertext: "}
}
println!(
"{:#}",
from_utf8(&ciphertext_pkcs7.as_ref().to_pem().unwrap()).unwrap()
);
let mut output_file: String = "".into();
// todo: verify this in-place doesn't need a different method
if encrypt_args.is_present("in-place") {
// this has to check the file that was fed in
if verbose.clone() {
println!("Going to try and use input file as the output file (encrypt in place)")
}
output_file = encrypt_args.value_of("file").unwrap().into();
} else {
match encrypt_args.value_of("output-file") {
Some(ofile) => {
if verbose.clone() {
println!("Using output-file argas output file")
}
output_file = ofile.into()
}
None => {}
};
}
if output_file != "" {
if verbose.clone() {
println!("Going to write ciphertext to {}", &output_file)
}
match write_file(&output_file, &ciphertext_pkcs7.as_ref().to_pem().unwrap()) {
Ok(_) => {}
Err(_) => println!("There was an error writing the ciphertext to file!"),
}
} else {
if verbose.clone() {
println!("output_file variable was never assigned to anything");

```
<Overlap Ratio: 0.989010989010989>

---

--- 304 --
Question ID: d76cdd6a4fcc687a5ef8aeade4fa2f9699dc40ff_3
Original Code:
```
fn compare_to_reference() {
        let reference_input = to_f32(include_bytes!("../test_data/testing.raw"));
        let reference_output = to_i16(include_bytes!("../test_data/reference_output.raw"));
        let mut output = Vec::new();
        let mut out_buf = [0.0; FRAME_SIZE];
        let mut state = DenoiseState::new();
        let mut first = true;
        for chunk in reference_input.chunks_exact(FRAME_SIZE) {
            state.process_frame(&mut out_buf[..], chunk);
            if !first {
                output.extend_from_slice(&out_buf[..]);
            }
            first = false;
        }

        assert_eq!(output.len(), reference_output.len());
        let output = output.into_iter().map(|x| x as i16).collect::<Vec<_>>();
        let xx: f64 = output.iter().map(|&x| (x as f64).powi(2)).sum();
        let diff: f64 = reference_output
            .into_iter()
            .zip(output)
            .map(|(x, y)| (x as f64 - y as f64).powi(2))
            .sum();
        assert!(diff / xx < 1e-4);
    }
```


Overlapping Code:
```
() {
let reference_input = to_f32(include_bytes!("../test_data/testing.raw"));
let reference_output = to_i16(include_bytes!("../test_data/reference_output.raw"));
let mut output = Vec::new();
let mut out_buf = [0.0; FRAME_SIZE];
let mut state = DenoiseState::new();
let mut first = true;
for chunk in reference_input.chunks_exact(FRAME_SIZE) {
state.process_frame(&mut out_buf[..], chunk);
if !first {
output.extend_from_slice(&out_buf[..]);
}
first = false;
}
assert_eq!(output.len(), reference_output.len());
let output = output.into_iter().map(|x| x as i16).collect::<Vec<_>>();
let xx: f64 = output.iter().map(|&x| (x as f64).powi(2)).sum();
let diff: f64 = reference_output
.into_iter()
.zip(output)
.map(|(x, y)| (x as f64 - y as f64).powi(2))

```
<Overlap Ratio: 0.927070457354759>

---

--- 305 --
Question ID: 0cde25078991b22a0a3f923899068105690d4d21_1
Original Code:
```
fn html_writer_basic_colors() -> anyhow::Result<()> {
        let mut buffer = String::new();
        let mut writer = HtmlWriter::new(&mut buffer, None);
        write!(writer, "Hello, ")?;
        writer.set_color(
            ColorSpec::new()
                .set_bold(true)
                .set_underline(true)
                .set_fg(Some(Color::Green))
                .set_bg(Some(Color::White)),
        )?;
        write!(writer, "world")?;
        writer.reset()?;
        write!(writer, "!")?;

        assert_eq!(
            buffer,
            r#"Hello, <span class="bold underline fg2 bg7">world</span>!"#
        );

        Ok(())
    }
```


Overlapping Code:
```
anyhow::Result<()> {
let mut buffer = String::new();
let mut writer = HtmlWriter::new(&mut buffer, None);
write!(writer, "Hello, ")?;
writer.set_color(
ColorSpec::new()
.set_bold(true)
.set_underline(true)
.set_fg(Some(Color::Green))
.set_bg(Some(Color::White)),
)?;
write!(writer, "world")?;
writer.reset()?;
write!(writer, "!")?;
assert_eq!(
buffer,
r#"Hello, <span class="bold underline fg2 bg7">world<
```
<Overlap Ratio: 0.8823529411764706>

---

--- 306 --
Question ID: 8bde40cec4cf22d7a4be6d75793d9f2ca1eef708_0
Original Code:
```
pub fn crawl_directory_for_repos(directory: &Path) -> IoResult<Vec<Repository>> {
	// Contains paths to explore
	let paths = SegQueue::new();
	paths.push(directory.to_path_buf());

	// Contains found repositories
	let repositories = SegQueue::new();

	// Set the number of threads to use for crawling
	let thread_count = max(8, num_cpus::get() * 2);

	thread::scope(|scope| {
		for _ in 0..thread_count {
			scope.spawn(|_| {
				while let Some(path) = paths.pop() {
					crawl(path, &paths, &repositories).unwrap();
				}
			});
		}
	})
	.unwrap_or_else(|_| error!("Could not spawn threads"));

	// Return the repositories in a `Vec`
	Ok(repositories.into_iter().collect::<Vec<_>>())
}
```


Overlapping Code:
```
: &Path) -> IoResult<Vec<Repository>> {
// Contains paths to explore
let paths = SegQueue::new();
paths.push(directory.to_path_buf());
// Contains found repositories
let repositories = SegQueue::new();
// Set the number of threads to use for crawling
let thread_count = max(8, num_cpus::get() * 2);
thread::scope(|scope| {
for _ in 0..thread_count {
scope.spawn(|_| {
while let Some(path) = paths.pop() {
crawl(path, &paths, &repositories).unwrap();
}
});
}
})
.unwrap_or_else(|_| error!("Could not spawn threads"));
// Return the repositories in a `Vec`
Ok(repositories.into_iter().collect::<Vec<_>>
```
<Overlap Ratio: 0.9273570324574961>

---

--- 307 --
Question ID: 228cdc96b428d6bd27e009d21edbf646dc913494_62
Original Code:
```
fn comment_with_single_quotes_one_pass() {
        let mut scanner = Scanner::new();
        let bytes = r#"<!-- goodbye a='val-->'-->Content"#.as_bytes();
        assert_eq!(scanner.scan(bytes), Some(State::ScannedComment(22)));
        assert_eq!(scanner.state, InternalState::Reset);
    }
```


Overlapping Code:
```
ith_single_quotes_one_pass() {
let mut scanner = Scanner::new();
let bytes = r#"<!-- goodbye a='val-->'-->Content"#.as_bytes();
assert_eq!(scanner.scan(bytes), Some(State::ScannedComment(22)));
assert_eq!(scanner.state, InternalState::Reset);
}
```
<Overlap Ratio: 0.953125>

---

--- 308 --
Question ID: 6c7cf2611001c13b04b5b9ee7237f07c08d40a20_0
Original Code:
```
fn empty_git_commit<'r>(
    git_repo: &'r git2::Repository,
    ref_name: &str,
    parents: &[&git2::Commit],
) -> git2::Commit<'r> {
    let signature = git2::Signature::now("Someone", "someone@example.com").unwrap();
    let empty_tree_id = Oid::from_str("4b825dc642cb6eb9a060e54bf8d69288fbee4904").unwrap();
    let empty_tree = git_repo.find_tree(empty_tree_id).unwrap();
    let oid = git_repo
        .commit(
            Some(ref_name),
            &signature,
            &signature,
            &format!("random commit {}", rand::random::<u32>()),
            &empty_tree,
            parents,
        )
        .unwrap();
    git_repo.find_commit(oid).unwrap()
}
```


Overlapping Code:
```
r>(
git_repo: &'r git2::Repository,
ref_name: &str,
parents: &[&git2::Commit],
) -> git2::Commit<'r> {
let signature = git2::Signature::now("Someone",rap();
let empty_tree_id = Oid::from_str("4b825dc642cb6eb9a060e54bf8d69288fbee4904").unwrap();
let empty_tree = git_repo.find_tree(empty_tree_id).unwrap();
let oid = git_repo
.commit(
Some(ref_name),
&signature,
&signature,
&format!("random commit {}", rand::random::<u32>()),
&empty_tree,
parents,
)
```
<Overlap Ratio: 0.8241758241758241>

---

--- 309 --
Question ID: 8b41703798c5f45d2dc4ef7b63d343671e6f8dd8_0
Original Code:
```
pub fn test_033_clobs() -> HdbResult<()> {
    let mut log_handle = test_utils::init_logger();
    let start = std::time::Instant::now();
    let mut connection = test_utils::get_authenticated_connection()?;

    if !prepare_test(&mut connection)? {
        info!("TEST ABANDONED since database does not support CLOB columns");
        return Ok(());
    }

    let (blabla, fingerprint) = get_blabla();
    test_clobs(&mut log_handle, &mut connection, &blabla, &fingerprint)?;
    test_streaming(&mut log_handle, &mut connection, blabla, &fingerprint)?;
    test_zero_length(&mut log_handle, &mut connection)?;

    test_utils::closing_info(connection, start)
}
```


Overlapping Code:
```
s() -> HdbResult<()> {
let mut log_handle = test_utils::init_logger();
let start = std::time::Instant::now();
let mut connection = test_utils::get_authenticated_connection()?;
if !prepare_test(&mut connection)? {
info!("TEST ABANDONED since database does not support CLOB columns");
return Ok(());
}
let (blabla, fingerprint) = get_blabla();
test_clobs(&mut log_handle, &mut connection, &blabla, &fingerprint)?;
test_streaming(&mut log_handle, &mut connection, blabla, &fingerprint)?;
test_zero_length(&mut log_handle, &mut connection)?;
test_utils::closing_info(connection, sta
```
<Overlap Ratio: 0.9585406301824212>

---

--- 310 --
Question ID: e442c968e23f01371625ee2c451f1818ce9837d7_3
Original Code:
```
fn add_article(conn_pg: ConnPg, conn_dsl: ConnDsl, user: UserOr, user_id: UserId, data_article: Form<DataArticle>)  -> Template {
    let data = data_article.get();
    let uid = user_id.0;
    let category = &data.category;
    let title = &data.title;
    let raw = &data.raw;
    add_article_by_uid(&conn_dsl, uid, &category, &title, &raw);
    let datas = article_list(&conn_pg);
    let context = TemplateArticle {
        datas: datas,
        username: user.0,
        user_id: user_id.0,
    };
    Template::render("index", &context)
}
```


Overlapping Code:
```
_pg: ConnPg, conn_dsl: ConnDsl, user: UserOr, user_id: UserId, data_article: Form<DataArticle>) -> Template {
let data = data_article.get();
let uid = user_id.0;
let category = &data.category;
let title = &data.title;
let raw = &data.raw;
add_article_by_uid(&conn_dsl, uid, &category, &title, &raw);
let datas = article_list(&conn_pg);
let context = TemplateArticle {
datas: datas,
username: user.0,
user_id: user_id.0,
};
Template::render("i
```
<Overlap Ratio: 0.9227557411273486>

---

--- 311 --
Question ID: 46625b08d80d6af6416b86a3ba8d1ac961426211_5
Original Code:
```
fn transition_callback() {
        let mut sm = TransitionSm::new();
        let transits = Arc::new(Mutex::new(Vec::new()));
        let transits_cb = transits.clone();
        sm.event_monitor_mut()
            .add_transition_callback(Callback::new(
                "test",
                move |t: &Transition<TransitionSm>| {
                    transits_cb.lock().unwrap().push(t.to_string());
                },
            ));
        sm.transit();
        assert_eq!(*transits.lock().unwrap(), vec!["S0->S1"]);
        transits.lock().unwrap().clear();
        sm.transit();
        assert_eq!(*transits.lock().unwrap(), vec!["S1->S2", "S2->S3"]);
    }
```


Overlapping Code:
```
nsition_callback() {
let mut sm = TransitionSm::new();
let transits = Arc::new(Mutex::new(Vec::new()));
let transits_cb = transits.clone();
sm.event_monitor_mut()
.add_transition_callback(Callback::new(
"test",
move |t: &Transition<TransitionSm>| {
transits_cb.lock().unwrap().push(t.to_string());
},
));
sm.transit();
assert_eq!(*transits.lock().unwrap(), vec!["S0->S1"]);
transits.lock().unwrap().clear();
sm.transit();
assert_eq!(*transits.lock().unwrap
```
<Overlap Ratio: 0.9230769230769231>

---

--- 312 --
Question ID: 48d8b037e6638eba17cd8992e9e253afcb6f5160_0
Original Code:
```
fn num_squares(n: i32) -> i32 {
    let mut dp = vec![0; n as usize];

    let mut queue = VecDeque::from(vec![(0, 0)]);

    while !queue.is_empty() {
        let (val, step) = queue.pop_front().unwrap();

        for i in 1..100 {
            let target = val + i * i;

            match target.cmp(&n) {
                Ordering::Less => {
                    if dp[target as usize] == 0 {
                        dp[target as usize] = step + 1;
                        queue.push_back((target, step + 1));
                    }
                },
                Ordering::Equal => {
                    return step + 1;
                },
                Ordering::Greater => {
                    break;
                },
            }
        }
    }

    -1
}
```


Overlapping Code:
```
n num_squares(n: i32) -> i32 {
let mut dp = vec![0; n as usize];
let mut queue = VecDeque::from(vec![(0, 0)]);
while !queue.is_empty() {
let (val, step) = queue.pop_front().unwrap();
for i in 1..100 {
let target = val + i * i;
match target.cmp(&n) {
Ordering::Less => {
if dp[target as usize] == 0 {
dp[target as usize] = step + 1;
queue.push_back((target, step + 1));
}
},
Ordering::Equal => {
return step + 1;
},
Ordering::Greater => {
break;
},
}

```
<Overlap Ratio: 0.9803921568627451>

---

--- 313 --
Question ID: c116c1124eddbe1d1b2a05542c894884a2d8ca99_1
Original Code:
```
async fn handle_socks(mut stream: TcpStream, server: String,uuid: [u8; 16]) -> Result<()> {
    let mut buf = [0; 1024];

    let len = stream.read(&mut buf).await?;

    // socks5: first handshake begin
    if 1 + 1 + (buf[1] as usize) != len || buf[0] != b'\x05' {
        warn!("invalid header");
        return Ok(());
    }
    stream.write_all(b"\x05\x00").await?; // version 5, method 0

    // socks5: first handshake begin
    let len = stream.read(&mut buf).await?;
    if len <= 4 {
        warn!("invalid proto");
        return Ok(());
    }

    let ver = buf[0]; // version
    let cmd = buf[1]; // command code 1-connect 2-bind 3-udp forward
    let atyp = buf[3]; // type of the dist server 1-ipv4 3-domain 4-ipv6

    if ver != b'\x05' {
        warn!("invalid proto");
        return Ok(());
    }

    if cmd != 1 {
        warn!("Command not supported");
        stream
            .write_all(b"\x05\x07\x00\x01\x00\x00\x00\x00\x00\x00")
            .await?;
        return Ok(());
    }

    let (addr, ipbuf, portbuf) = decode_atyp(atyp, len, &buf).unwrap();

    vmess_proxy(stream, &server, (addr, ipbuf, portbuf),uuid).await?;

    Ok(())
}
```


Overlapping Code:
```
andle_socks(mut stream: TcpStream, server: String,uuid: [u8; 16]) -> Result<()> {
let mut buf = [0; 1024];
let len = stream.read(&mut buf).await?;
// socks5: first handshake begin
if 1 + 1 + (buf[1] as usize) != len || buf[0] != b'\x05' {
warn!("invalid header");
return Ok(());
}
stream.write_all(b"\x05\x00").await?; // version 5, method 0
// socks5: first handshake begin
let len = stream.read(&mut buf).await?;
if len <= 4 {
warn!("invalid proto");
return Ok(());
}
let ver = buf[0]; // version
let cmd = buf[1]; // command code 1-connect 2-bind 3-udp forward
let atyp = buf[3]; // type of the dist server 1-ipv4 3-domain 4-ipv6
if ver != b'\x05' {
warn!("invalid proto");
return Ok(());
}
if cmd != 1 {
warn!("Command not supported");
stream
.write_all(b"\x05\x07\x00\x01\x00\x00\x00\x00\x00\x00")
.await?;
return Ok(());
}
let (addr, ipbuf, portbuf) = decode_atyp(atyp, len, &buf).unwrap();
vmess_proxy(stream, &server, (addr, ipbuf, portbuf),u
```
<Overlap Ratio: 0.9683995922528033>

---

--- 314 --
Question ID: 7396a47a37791c0e23bfdc96eb93b85c0b853f6f_5
Original Code:
```
pub extern "C" fn ipassignment_free(ip_assignment: *mut IpAssignment<u32>) {
        assert!(!ip_assignment.is_null());
        unsafe { Box::from_raw(ip_assignment) };
    }
```


Overlapping Code:
```
nt_free(ip_assignment: *mut IpAssignment<u32>) {
assert!(!ip_assignment.is_null());
unsafe { Box::fr
```
<Overlap Ratio: 0.6493506493506493>

---

--- 315 --
Question ID: 489ad77a50a1f9d245b0af344d944074e4afeff2_10
Original Code:
```
async fn atomic_update_reader() {
        let inspector = Inspector::new();

        // Spawn a read thread that holds a duplicate handle to the VMO that will be written.
        let vmo = inspector.duplicate_vmo().expect("duplicate vmo handle");
        let (p1, p2) = zx::EventPair::create().unwrap();

        macro_rules! notify_and_wait_reader {
            () => {
                p1.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();
                p1.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();
                p1.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();
            };
        }

        macro_rules! wait_and_notify_writer {
            ($code:block) => {
              p2.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();
              p2.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();
              $code
              p2.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();
            }
        }

        let thread = std::thread::spawn(move || {
            // Before running the atomic update.
            wait_and_notify_writer! {{
                let hierarchy: DiagnosticsHierarchy<String> =
                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();
                assert_eq!(hierarchy, DiagnosticsHierarchy::new_root());
            }};
            // After: create_child("child"): Assert that the VMO is in use (locked) and we can't
            // read.
            wait_and_notify_writer! {{
                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
            }};
            // After: record_int("a"): Assert that the VMO is in use (locked) and we can't
            // read.
            wait_and_notify_writer! {{
                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
            }};
            // After: record_int("b"): Assert that the VMO is in use (locked) and we can't
            // read.
            wait_and_notify_writer! {{
                assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
            }};
            // After atomic update
            wait_and_notify_writer! {{
                let hierarchy: DiagnosticsHierarchy<String> =
                    reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();
                assert_data_tree!(hierarchy, root: {
                   value: 2i64,
                   child: {
                       a: 1i64,
                       b: 2i64,
                   }
                });
            }};
        });

        // Perform the atomic update
        let mut child = Node::default();
        notify_and_wait_reader!();
        let int_val = inspector.root().create_int("value", 1);
        inspector
            .root()
            .atomic_update(|node| {
                // Intentionally make this slow to assert an atomic update in the reader.
                child = node.create_child("child");
                notify_and_wait_reader!();
                child.record_int("a", 1);
                notify_and_wait_reader!();
                child.record_int("b", 2);
                notify_and_wait_reader!();
                int_val.add(1);
                Ok::<(), Error>(())
            })
            .expect("successful atomic update");
        notify_and_wait_reader!();

        // Wait for the reader thread to successfully finish.
        let _ = thread.join();

        // Ensure that the variable that we mutated internally can be used.
        child.record_int("c", 3);
        assert_data_tree!(inspector, root: {
            value: 2i64,
            child: {
                a: 1i64,
                b: 2i64,
                c: 3i64,
            }
        });
    }
```


Overlapping Code:
```
() {
let inspector = Inspector::new();
// Spawn a read thread that holds a duplicate handle to the VMO that will be written.
let vmo = inspector.duplicate_vmo().expect("duplicate vmo handle");
let (p1, p2) = zx::EventPair::create().unwrap();
macro_rules! notify_and_wait_reader {
() => {
p1.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();
p1.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();
p1.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();
};
}
macro_rules! wait_and_notify_writer {
($code:block) => {
p2.wait_handle(zx::Signals::USER_0, zx::Time::INFINITE).unwrap();
p2.signal_handle(zx::Signals::USER_0, zx::Signals::NONE).unwrap();
$code
p2.signal_peer(zx::Signals::NONE, zx::Signals::USER_0).unwrap();
}
}
let thread = std::thread::spawn(move || {
// Before running the atomic update.
wait_and_notify_writer! {{
let hierarchy: DiagnosticsHierarchy<String> =
reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();
assert_eq!(hierarchy, DiagnosticsHierarchy::new_root());
}};
// After: create_child("child"): Assert that the VMO is in use (locked) and we can't
// read.
wait_and_notify_writer! {{
assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
}};
// After: record_int("a"): Assert that the VMO is in use (locked) and we can't
// read.
wait_and_notify_writer! {{
assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
}};
// After: record_int("b"): Assert that the VMO is in use (locked) and we can't
// read.
wait_and_notify_writer! {{
assert!(reader::PartialNodeHierarchy::try_from(&vmo).is_err());
}};
// After atomic update
wait_and_notify_writer! {{
let hierarchy: DiagnosticsHierarchy<String> =
reader::PartialNodeHierarchy::try_from(&vmo).unwrap().into();
assert_data_tree!(hierarchy, root: {
value: 2i64,
child:
```
<Overlap Ratio: 0.9782608695652174>

---

--- 316 --
Question ID: 0112ea4a8241ff775de3a099a311c1a0995367f0_2
Original Code:
```
pub fn test() -> Html {
    let (label, set_label) = use_state(|| "Hello".to_owned());

    let on_click = {
        let label = Rc::clone(&label);
        Callback::from(move |_| set_label(format!("{} world", label)))
    };

    let default_string = use_trans("default");

    let switch_on_click = Callback::from(move |_| ());

    let slider_on_change = Callback::from(move |_| ());

    let on_select = Callback::from(move |_| ());

    let text_field_on_focus_lost = Callback::from(move |_| ());

    let up_down_on_step = Callback::from(move |_| ());

    html! {
        <div class="px-4 py-3">
            <div class="flex flex-col space-y-2 items-start">
                <Button on_click=on_click.clone() button_type=ButtonType::None>
                    {label.clone()}
                </Button>
                <Button on_click=on_click.clone() button_type=ButtonType::Primary>
                    {label.clone()}
                </Button>
                <Button on_click=on_click.clone() button_type=ButtonType::Secondary>
                    {label.clone()}
                </Button>
                <Button on_click=on_click button_type=ButtonType::Danger>
                    {label}
                </Button>
            </div>
            <Switch on_click=switch_on_click checked=true/>
            <Slider value="0" default="30" min="-1" max="40" step="0.5" on_change=slider_on_change/>
            <ButtonGroup
                options=vec!["hello1".into(), "hello2".into()]
                selected="hello1"
                on_select=on_select.clone()
            />
            <Select
                options=vec!["hello1".into(), "hello2".into()]
                selected="hello1"
                on_select=on_select
            />
            <div class="space-y-2">
                <TextField
                    value=default_string.clone()
                    on_focus_lost=text_field_on_focus_lost.clone()
                />
                <TextField
                    label="Hi there"
                    value=default_string
                    on_focus_lost=text_field_on_focus_lost.clone()
                />
            </div>
            <div class="py-2 space-y-2">
                <UpDown
                    label="Bitrate"
                    value="123"
                    on_focus_lost=text_field_on_focus_lost.clone()
                    on_step_down=up_down_on_step.clone()
                    on_step_up=up_down_on_step.clone()
                />
                <UpDown
                    value="123"
                    on_focus_lost=text_field_on_focus_lost
                    on_step_down=up_down_on_step.clone()
                    on_step_up=up_down_on_step
                />
            </div>
        </div>
    }
}
```


Overlapping Code:
```
let (label, set_label) = use_state(|| "Hello".to_owned());
let on_click = {
let label = Rc::clone(&label);
Callback::from(move |_| set_label(format!("{} world", label)))
};
let default_string = use_trans("default");
let switch_on_click = Callback::from(move |_| ());
let slider_on_change = Callback::from(move |_| ());
let on_select = Callback::from(move |_| ());
let text_field_on_focus_lost = Callback::from(move |_| ());
let up_down_on_step = Callback::from(move |_| ());
html! {
<div class="px-4 py-3">
<div class="flex flex-col space-y-2 items-start">
<Button on_click=on_click.clone() button_type=ButtonType::None>
{label.clone()}
</Button>
<Button on_click=on_click.clone() button_type=ButtonType::Primary>
{label.clone()}
</Button>
<Button on_click=on_click.clone() button_type=ButtonType::Secondary>
{label.clone()}
</Button>
<Button on_click=on_click button_type=ButtonType::Danger>
{label}
</Button>
</div>
<Switch on_click=switch_on_click checked=true/>
<Slider value="0" default="30" min="-1" max="40" step="0.5" on_change=slider_on_change/>
<ButtonGroup
options=vec!["hello1".into(), "hello2".into()]
selected="hello1"
on_select=on_select.clone()
/>
<Select
options=vec!["hello1".into(), "hello2".into()]
selected="hello1"
on_select=on_select
/>
<div class="space-y-2">
<TextField
value=default_string.clone()
on_focus_lost=text_field_on_focus_lost.clone()
/>
<TextField
label="Hi there"
value=default_string
on_focus_lost=text_field_on_focus_lost.clone()
/>
</div>
<div class="py-2 space-y-2">
<UpDown
label="Bitrate"
value="123"
on_focus_lost=text_field_on_focus_lost.clone()
on_step_down=up_down_on_step.clone()
on_step_up=up_down_on
```
<Overlap Ratio: 0.9763313609467456>

---

--- 317 --
Question ID: 77126f80e354ba337c44351fb14bf3807ae902a2_18
Original Code:
```
fn reading_hashmap_set_from_lua_works() {
        let mut lua = Lua::new();

        lua.execute::<()>(r#"v = { [1] = 2, [2] = 3, [3] = 4 }"#).unwrap();

        let read: HashMap<_, _> = lua.get("v").unwrap();
        assert_eq!(
            read,
            [2., 3., 4.].iter().enumerate()
                .map(|(k, v)| (AnyHashableLuaValue::LuaNumber((k + 1) as i32), AnyLuaValue::LuaNumber(*v))).collect::<HashMap<_, _>>());
    }
```


Overlapping Code:
```
set_from_lua_works() {
let mut lua = Lua::new();
lua.execute::<()>(r#"v = { [1] = 2, [2] = 3, [3] = 4 }"#).unwrap();
let read: HashMap<_, _> = lua.get("v").unwrap();
assert_eq!(
read,
[2., 3., 4.].iter().enumerate()
.map(|(k, v)| (AnyHashableLuaValue::LuaNumber((k + 1) as i32), AnyLuaValue::LuaNumber(*v))).collect::<HashMap<_, 
```
<Overlap Ratio: 0.9215686274509803>

---

--- 318 --
Question ID: 3c67406a5d63db2d4a8143cc65e8de185ef05aa1_0
Original Code:
```
pub fn load_cell_textures(world: &mut World) -> CellTextures {
    let loader = world.read_resource::<Loader>();
    let mut counts = vec![];
    for i in 0..=8 {
        counts.push(loader.load(
            format!("cell-{}.png", i),
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ));
    }
    CellTextures {
        counts,
        normal: loader.load(
            "cell.png",
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ),
        blood: loader.load(
            "cell-blood.png",
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ),
        error: loader.load(
            "cell-error.png",
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ),
        mine: loader.load(
            "cell-mine.png",
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ),
        flag: loader.load(
            "cell-flag.png",
            ImageFormat::default(),
            (),
            &world.read_resource::<AssetStorage<Texture>>(),
        ),
    }
}
```


Overlapping Code:
```
 -> CellTextures {
let loader = world.read_resource::<Loader>();
let mut counts = vec![];
for i in 0..=8 {
counts.push(loader.load(
format!("cell-{}.png", i),
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),
));
}
CellTextures {
counts,
normal: loader.load(
"cell.png",
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),
),
blood: loader.load(
"cell-blood.png",
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),
),
error: loader.load(
"cell-error.png",
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),
),
mine: loader.load(
"cell-mine.png",
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),
),
flag: loader.load(
"cell-flag.png",
ImageFormat::default(),
(),
&world.read_resource::<AssetStorage<Texture>>(),

```
<Overlap Ratio: 0.9440089585666294>

---

--- 319 --
Question ID: 4a10a39040b92a5447417c7ebb202e228a2ff783_6
Original Code:
```
unsafe fn alloc(size: usize) -> (*mut u8, u64, usize) {
        let (p, off, len, z) = Self::pre_alloc(size);
        Self::drop_on_failure(off, len, z);
        Self::perform(z);
        (p, off, len)
    }
```


Overlapping Code:
```
4, usize) {
let (p, off, len, z) = Self::pre_alloc(size);
Self::drop_on_failure(off, len, z);
Self::
```
<Overlap Ratio: 0.5847953216374269>

---

--- 320 --
Question ID: 4a7c0b0d3d3bd17552f59a07db83ad636a06bd3e_1
Original Code:
```
fn basics_with_schema_projection() -> Result<()> {
    let (data, schema, columns) = case_basics_schema();

    let mut reader = ReaderBuilder::new()
        .with_schema(Arc::new(schema.clone()))
        .build(Cursor::new(data))?;
    let batch = reader.next()?.unwrap();

    assert_eq!(&schema, batch.schema().as_ref());

    columns
        .iter()
        .zip(batch.columns())
        .for_each(|(expected, result)| assert_eq!(expected.as_ref(), result.as_ref()));
    Ok(())
}
```


Overlapping Code:
```
) -> Result<()> {
let (data, schema, columns) = case_basics_schema();
let mut reader = ReaderBuilder::new()
.with_schema(Arc::new(schema.clone()))
.build(Cursor::new(data))?;
let batch = reader.next()?.unwrap();
assert_eq!(&schema, batch.schema().as_ref());
columns
.iter()
.zip(batch.columns())
.for_each(|(expected, result)| assert_eq!(expected.as_ref(), result.as_ref()));

```
<Overlap Ratio: 0.9016786570743405>

---

--- 321 --
Question ID: 7bbe64ec6f80d16efee4802c6f5d0ca610eb8674_0
Original Code:
```
fn helmholtz_energy() {
        let disp = Dispersion {
            parameters: propane_parameters(),
        };
        let t = 250.0;
        let v = 1000.0;
        let n = 1.0;
        let s = StateHD::new(t, v, arr1(&[n]));
        let a_rust = disp.helmholtz_energy(&s);
        assert_relative_eq!(a_rust, -1.0622531100351962, epsilon = 1e-10);
    }
```


Overlapping Code:
```
z_energy() {
let disp = Dispersion {
parameters: propane_parameters(),
};
let t = 250.0;
let v = 1000.0;
let n = 1.0;
let s = StateHD::new(t, v, arr1(&[n]));
let a_rust = disp.helmholtz_energy(&s);
assert_relative_eq!(a_rust, -1.0622531100351962, eps
```
<Overlap Ratio: 0.9025270758122743>

---

--- 322 --
Question ID: 7664dfc683b5b5061964a63f04c08ed6b07d34d9_2
Original Code:
```
fn serialize_currency() {
    use stripe::Currency;
    assert_eq!(serde_json::to_string(&Currency::AED).unwrap(), "\"aed\"");
    assert_eq!(serde_json::to_string(&Currency::USD).unwrap(), "\"usd\"");
    assert_eq!(serde_json::to_string(&Currency::ZMW).unwrap(), "\"zmw\"");
}
```


Overlapping Code:
```
ize_currency() {
use stripe::Currency;
assert_eq!(serde_json::to_string(&Currency::AED).unwrap(), "\"aed\"");
assert_eq!(serde_json::to_string(&Currency::USD).unwrap(), "\"usd\"");
assert_eq!(serde_json::to_string(&Currency
```
<Overlap Ratio: 0.851145038167939>

---

--- 323 --
Question ID: 74b1f304d6518fee8db1a5be89de4a5213f4cba9_0
Original Code:
```
pub fn chmod(path: impl AsRef<Path>, mode: u32) -> Result<()> {
    let path = CString::new(path.as_ref().to_string_lossy().to_string())?;
    let res = unsafe { nix::libc::chmod(path.as_ptr(), mode) };
    nix::errno::Errno::result(res).map(drop)?;

    Ok(())
}
```


Overlapping Code:
```
ath>, mode: u32) -> Result<()> {
let path = CString::new(path.as_ref().to_string_lossy().to_string())?;
let res = unsafe { nix::libc::chmod(path.as_ptr(), mode) };
nix::errno::Errno::result(res).map(d
```
<Overlap Ratio: 0.8130081300813008>

---

--- 324 --
Question ID: 800be99bdf5cb24a7bfccb5526fb18e550299c3c_0
Original Code:
```
fn main() -> Result<(), u32> {
    // - initialize allocator -------------------------------------------------

    allocator::init();


    // - configure board ------------------------------------------------------

    let board = unsafe { bsp::Board::steal() };
    let cp = cortex_m::Peripherals::take().unwrap();
    let dp = pac::Peripherals::take().unwrap();
    let ccdr = boards::freeze_clocks_with_config(
        dp.PWR.constrain(), dp.RCC.constrain(), &dp.SYSCFG,
        |pwrcfg, rcc, syscfg| {
            rcc.sys_ck(96.mhz())                // system clock @ 96 MHz
            // pll1 drives system clock
                .pll1_strategy(hal::rcc::PllConfigStrategy::Iterative)
                .pll1_r_ck(96.mhz())             // TRACECLK
                .pll1_q_ck(48.mhz())             // spi clock
                .pll3_p_ck((48_000 * 256).hz())  // sai clock @ 12.288 MHz
                .freeze(pwrcfg, syscfg)
        }
    );

    println!("Hello ockam_transport_ble!");

    let pins = board.split_gpios(dp.GPIOA.split(ccdr.peripheral.GPIOA),
                                 dp.GPIOB.split(ccdr.peripheral.GPIOB),
                                 dp.GPIOC.split(ccdr.peripheral.GPIOC),
                                 dp.GPIOD.split(ccdr.peripheral.GPIOD),
                                 dp.GPIOE.split(ccdr.peripheral.GPIOE),
                                 dp.GPIOF.split(ccdr.peripheral.GPIOF),
                                 dp.GPIOG.split(ccdr.peripheral.GPIOG));

    let mut user_leds = bsp::led::UserLeds::new(pins.user_leds);


    // - configure spi --------------------------------------------------------

    let mut timer = dp.TIM7.timer(1.hz(), ccdr.peripheral.TIM7, &ccdr.clocks);
    let mut delay = Delay::new(cp.SYST, ccdr.clocks);

    let spi3_irq  = pins.d43.into_pull_down_input();
    let spi3_rst  = pins.d44.into_push_pull_output();
    let spi3_sck  = pins.d45.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);
    let spi3_miso = pins.d46.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);
    let spi3_mosi = pins.d47.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);

    use nucleo_h7xx::embedded_hal::digital::v2::OutputPin;
    let mut spi3_nss  = pins.d20.into_push_pull_output();
    spi3_nss.set_high().ok();

    let config = hal::spi::Config::new(
        spi::Mode {
            polarity: spi::Polarity::IdleLow,
            phase: spi::Phase::CaptureOnFirstTransition,
        }
    );

    let mut spi3 = dp.SPI3.spi(
        (spi3_sck, spi3_miso, spi3_mosi),
        config,
        3.mhz(),
        ccdr.peripheral.SPI3,
        &ccdr.clocks,
    );


    // - bluenrg --------------------------------------------------------------

    use ockam_transport_ble::driver::CHARACTERISTIC_VALUE_LENGTH;
    let ble_addr = ockam_transport_ble::parse_ble_addr("ockam_ble_1").unwrap();

    let mut rx_buffer: [u8; CHARACTERISTIC_VALUE_LENGTH] = [0; CHARACTERISTIC_VALUE_LENGTH];
    let mut bluetooth = bluenrg::BlueNRG::new(
        &mut rx_buffer,
        spi3_nss,
        spi3_irq,
        spi3_rst
    );

    // hardware reset
    println!("\n\treset bluenrg-ms device");
    bluetooth.reset(&mut timer, 2.hz()).ok();
    match bluetooth.with_spi(&mut spi3, |controller| block!(controller.read())) {
        Ok(packet) => {
            let bluetooth_hci::host::uart::Packet::Event(event) = packet;
            ble_uart::dispatch_event(&event);
        }
        Err(e) => println!("reset error: {:?}", e),
    }

    // test device comms
    ble::read_local_version_information(&mut spi3, &mut bluetooth)
        .expect("ble::read_local_version_information failed");


    // - configure ble uart ---------------------------------------------------

    ble_uart::setup(&mut spi3, &mut bluetooth)
        .expect("ble_uart::setup failed");
    delay.delay_ms(500u16);
    let mut context = ble_uart::initialize_gatt_and_gap(&mut spi3, &mut bluetooth, &ble_addr)
        .expect("ble_uart::initialize_gatt_and_gap failed");
    delay.delay_ms(500u16);
    ble_uart::initialize_uart(&mut spi3, &mut bluetooth, &mut context)
        .expect("ble_uart::initialize_uart failed");
    delay.delay_ms(500u16);


    // - main loop ------------------------------------------------------------

    let mut counter: usize = 0;

    println!("\nentering main loop");

    #[derive(Debug, PartialEq)]
    enum State {
        Disconnected,
        Advertising,
        Connected,
        Error,
    }

    use ockam_transport_ble::driver::bluetooth_hci::Event;

    //use bluetooth_hci::event::command::ReturnParameters::Vendor as Vendor;
    //use bluetooth_hci::Vendor;

    use bluenrg::event::BlueNRGEvent;

    let mut state = State::Disconnected;
    loop {
        match state {
            State::Disconnected => {
                ble_uart::start_advertising(&mut spi3, &mut bluetooth, &mut context, &ble_addr)
                    .expect("ble_uart::make_connection failed");
                state = State::Advertising;
                println!("\nstate = {:?}", state);
            }
            State::Advertising => {
            }
            State::Connected => {
            }
            State::Error => {
            }
        }

        ble_uart::poll(&mut spi3, &mut bluetooth, |event| {
            match event {
                Event::LeConnectionComplete(event) => {
                    println!("\t=> LeConnectionComplete -> {:?}", event);
                    state = State::Connected;
                    println!("\nstate = {:?}", state);
                }
                Event::Vendor(BlueNRGEvent::GattAttributeModified(event)) => {
                    if event.attr_handle == context.uart_rx_attribute_handle
                        .expect("rx attribute handle is not set")
                    {
                        if let Ok(data) = core::str::from_utf8(event.data()) {
                            println!("\t=> Rx: -> {:?}", data);
                        } else {
                            println!("\t=> Rx: -> {:?}", event.data());
                        }
                    } else {
                        println!("\t=> Rx unknown: -> {:?}", event);
                    }
                }
                Event::DisconnectionComplete(event) => {
                    println!("\t=> DisconnectionComplete -> {:?}", event);
                    state = State::Disconnected;
                    println!("\nstate = {:?}", state);
                }
                _ => {
                    println!("\t=> unknown event: {:?}", event);
                }
            }
            Some(State::Error)
        });

        if counter % 1000_000 == 0 && state == State::Connected {
            //led.toggle().ok();

            // create message buffer
            let mut tx_buffer = [0 as u8; CHARACTERISTIC_VALUE_LENGTH];
            let mut tx_cursor = Cursor::new(&mut tx_buffer[..]);
            match write!(&mut tx_cursor, "server counter: {}", counter / 100_000) {
            //match write!(&mut tx_cursor, "0123456789012345678 server: {}", counter / 100_000) {
                Ok(()) => (),
                Err(e) => {
                    println!("failed write: {:?}", e);
                    continue
                }
            }
            let position: usize = tx_cursor.position() as usize;
            let tx_buffer = &tx_cursor.into_inner()[0..position];

            // send message buffer
            block!(bluetooth.with_spi(&mut spi3, |controller| {
                controller.update_characteristic_value(&bluenrg::gatt::UpdateCharacteristicValueParameters {
                    service_handle: context.uart_service_handle.expect("uart service handle has not been set"),
                    characteristic_handle: context.uart_tx_handle.expect("uart tx handle has not been set"),
                    offset: 0x00,
                    value: tx_buffer,
                })
            })).unwrap();
            ble_uart::controller_read(&mut spi3, &mut bluetooth);
        }

        if counter >= 0xffff_fffe {
            break;
        } else {
            counter += 1;
        }
    }

    Ok(())
}
```


Overlapping Code:
```
{
// - initialize allocator -------------------------------------------------
allocator::init();
// - configure board ------------------------------------------------------
let board = unsafe { bsp::Board::steal() };
let cp = cortex_m::Peripherals::take().unwrap();
let dp = pac::Peripherals::take().unwrap();
let ccdr = boards::freeze_clocks_with_config(
dp.PWR.constrain(), dp.RCC.constrain(), &dp.SYSCFG,
|pwrcfg, rcc, syscfg| {
rcc.sys_ck(96.mhz()) // system clock @ 96 MHz
// pll1 drives system clock
.pll1_strategy(hal::rcc::PllConfigStrategy::Iterative)
.pll1_r_ck(96.mhz()) // TRACECLK
.pll1_q_ck(48.mhz()) // spi clock
.pll3_p_ck((48_000 * 256).hz()) // sai clock @ 12.288 MHz
.freeze(pwrcfg, syscfg)
}
);
println!("Hello ockam_transport_ble!");
let pins = board.split_gpios(dp.GPIOA.split(ccdr.peripheral.GPIOA),
dp.GPIOB.split(ccdr.peripheral.GPIOB),
dp.GPIOC.split(ccdr.peripheral.GPIOC),
dp.GPIOD.split(ccdr.peripheral.GPIOD),
dp.GPIOE.split(ccdr.peripheral.GPIOE),
dp.GPIOF.split(ccdr.peripheral.GPIOF),
dp.GPIOG.split(ccdr.peripheral.GPIOG));
let mut user_leds = bsp::led::UserLeds::new(pins.user_leds);
// - configure spi --------------------------------------------------------
let mut timer = dp.TIM7.timer(1.hz(), ccdr.peripheral.TIM7, &ccdr.clocks);
let mut delay = Delay::new(cp.SYST, ccdr.clocks);
let spi3_irq = pins.d43.into_pull_down_input();
let spi3_rst = pins.d44.into_push_pull_output();
let spi3_sck = pins.d45.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);
let spi3_miso = pins.d46.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);
let spi3_mosi = pins.d47.into_alternate_af6().set_speed(hal::gpio::Speed::VeryHigh);
use nucleo_h7xx::embedded_hal::digital::v2::OutputPin;
let mut spi3_nss = pins.d20.into_push_pull_output();
spi3_nss.set_high().ok();
let config = hal::spi::Config::new(
spi::Mode {
polarity: spi::Polarity::IdleLow,
phase: spi::Phase::CaptureOnFirstTransition,
}
);
let
```
<Overlap Ratio: 0.9822784810126582>

---

--- 325 --
Question ID: b6a707da54aee506c9801a816a90ebc2dbfa374b_26
Original Code:
```
fn destroy_iface_failure() {
        let mut exec = fasync::TestExecutor::new().expect("Failed to create an executor");
        let test_values = test_setup();
        let mut phy_stream = fake_destroy_iface_env(&test_values.phys, &test_values.ifaces);

        let destroy_fut = super::destroy_iface(&test_values.phys, &test_values.ifaces, 42);
        pin_mut!(destroy_fut);
        assert_eq!(Poll::Pending, exec.run_until_stalled(&mut destroy_fut));

        let (req, responder) = assert_variant!(exec.run_until_stalled(&mut phy_stream.next()),
            Poll::Ready(Some(Ok(fidl_dev::PhyRequest::DestroyIface { req, responder }))) => (req, responder)
        );

        // Verify the destroy iface request to the corresponding PHY is correct.
        assert_eq!(0, req.id);

        responder
            .send(&mut fidl_dev::DestroyIfaceResponse { status: zx::sys::ZX_ERR_INTERNAL })
            .expect("failed to send DestroyIfaceResponse");
        assert_eq!(
            Poll::Ready(Err(zx::Status::INTERNAL)),
            exec.run_until_stalled(&mut destroy_fut)
        );

        // Verify iface was not removed from available ifaces.
        assert!(test_values.ifaces.get(&42u16).is_some(), "iface expected to not be deleted");
    }
```


Overlapping Code:
```
() {
let mut exec = fasync::TestExecutor::new().expect("Failed to create an executor");
let test_values = test_setup();
let mut phy_stream = fake_destroy_iface_env(&test_values.phys, &test_values.ifaces);
let destroy_fut = super::destroy_iface(&test_values.phys, &test_values.ifaces, 42);
pin_mut!(destroy_fut);
assert_eq!(Poll::Pending, exec.run_until_stalled(&mut destroy_fut));
let (req, responder) = assert_variant!(exec.run_until_stalled(&mut phy_stream.next()),
Poll::Ready(Some(Ok(fidl_dev::PhyRequest::DestroyIface { req, responder }))) => (req, responder)
);
// Verify the destroy iface request to the corresponding PHY is correct.
assert_eq!(0, req.id);
responder
.send(&mut fidl_dev::DestroyIfaceResponse { status: zx::sys::ZX_ERR_INTERNAL })
.expect("failed to send DestroyIfaceResponse");
assert_eq!(
Poll::Ready(Err(zx::Status::INTERNAL)),
exec.run_until_stalled(&mut destroy_fut)
);
// Verify iface was not removed from available ifaces.
assert!(test_values.ifaces.get(&42u16).is_some(
```
<Overlap Ratio: 0.9389671361502347>

---

--- 326 --
Question ID: 83ebff57f44faa45ab77fe0782451ab5c4d3f2ca_6
Original Code:
```
fn test_nested_refs_for_let_shadowing() {
        let values = vec![1, 2, 3, 4];
        let vs = &values;
        check_match(vec![5, 5, 5, 5,
                         6, 6, 6, 6,
                         7, 7, 7, 7,
                         8, 8, 8, 8].into_iter(),
                    iterate![for x in vs.iter();
                             let a = *x + 3;
                             for y in vs.iter();
                             let y = 1;
                             yield y + a]);
    }
```


Overlapping Code:
```
_for_let_shadowing() {
let values = vec![1, 2, 3, 4];
let vs = &values;
check_match(vec![5, 5, 5, 5,
6, 6, 6, 6,
7, 7, 7, 7,
8, 8, 8, 8].into_iter(),
iterate![for x in vs.iter();
let a = *x + 3;
for y
```
<Overlap Ratio: 0.7662835249042146>

---

--- 327 --
Question ID: 78af2ad1e00582d2a1c0a2534ddc830b95eec458_1
Original Code:
```
fn from_date() {
    let date: Date<Utc> = Date::from_utc(NaiveDate::from_ymd(2018, 6, 19), Utc);

    let solar_date = SolarDate::from_date(date).unwrap();

    assert_eq!(SolarYear::from_u16(2018), solar_date.get_solar_year());
    assert_eq!(SolarMonth::from_u8(6).unwrap(), solar_date.get_solar_month());
    assert_eq!(SolarDay::from_u8(19).unwrap(), solar_date.get_solar_day());
}
```


Overlapping Code:
```
e: Date<Utc> = Date::from_utc(NaiveDate::from_ymd(2018, 6, 19), Utc);
let solar_date = SolarDate::from_date(date).unwrap();
assert_eq!(SolarYear::from_u16(2018), solar_date.get_solar_year());
assert_eq!(SolarMonth::from_u8(6).unwrap(), solar_date.get_solar_month());
assert_eq!(SolarDay::from_u8(19).unwrap(), solar_date.get_solar_day());
}
```
<Overlap Ratio: 0.9340659340659341>

---

--- 328 --
Question ID: cc85375e5830f2356c9bb120240414a1336967f5_1
Original Code:
```
pub fn decode(input: &str) -> String {
    // convert encoded characters to indices from the b64 string
    let mut indices = vec![];
    for chara in input.chars() {
        indices.push(get_b64_index(chara));
    }

    // convert the decimal indices to binary representation
    let mut indices_bytes = vec![];
    for index in indices {
        indices_bytes.push(dec_to_bin(index as u8));
    }

    // pad the binary values if necessary
    let mut bits_str = String::new();
    for mut byte in indices_bytes {
        if byte.len() < 6 {
            let padding_amount = 6 - byte.len();
            let mut padding = String::new();
            for _i in 0..padding_amount {
                padding += "0";
            }
            byte = format!("{}{}", padding, byte);
        }
        bits_str += &byte;
    }

    // divide the binary string into bytes
    let mut bytes = vec![];
    while !bits_str.is_empty() {
        if (bits_str.len()) >= 8 {
            bytes.push(bits_str[0..8].to_string());
            bits_str = (&bits_str[8..]).to_string();
        } else {
            bytes.push(bits_str.to_string());
            String::clear(&mut bits_str);
        }
    }

    // decode ascii bytes to characters in str
    let mut decoded = String::new();
    for byte in bytes {
        decoded.push((binary_to_dec(&byte)) as char);
    }

    // return decoded String
    decoded
}
```


Overlapping Code:
```
 &str) -> String {
// convert encoded characters to indices from the b64 string
let mut indices = vec![];
for chara in input.chars() {
indices.push(get_b64_index(chara));
}
// convert the decimal indices to binary representation
let mut indices_bytes = vec![];
for index in indices {
indices_bytes.push(dec_to_bin(index as u8));
}
// pad the binary values if necessary
let mut bits_str = String::new();
for mut byte in indices_bytes {
if byte.len() < 6 {
let padding_amount = 6 - byte.len();
let mut padding = String::new();
for _i in 0..padding_amount {
padding += "0";
}
byte = format!("{}{}", padding, byte);
}
bits_str += &byte;
}
// divide the binary string into bytes
let mut bytes = vec![];
while !bits_str.is_empty() {
if (bits_str.len()) >= 8 {
bytes.push(bits_str[0..8].to_string());
bits_str = (&bits_str[8..]).to_string();
} else {
bytes.push(bits_str.to_string());
String::clear(&mut bits_str);
}
}
// decode ascii bytes to characters in str
let mut decoded = String::new();
for byte in bytes {
decoded.push((binary_to_dec(&byte)) as cha
```
<Overlap Ratio: 0.9459459459459459>

---

--- 329 --
Question ID: c4a96cf9191285bd7e65aac700530f7a4ec11eca_0
Original Code:
```
fn private_corpus() {
    let _ = env_logger::init();

    let options = glob::MatchOptions {
        case_sensitive: true,
        require_literal_separator: true,
        require_literal_leading_dot: true,
    };
    for entry in glob::glob_with("../private/**/*.idx", &options).unwrap() {
        let entry = entry.unwrap();
        process_file(&entry);
    }
}
```


Overlapping Code:
```
private_corpus() {
let _ = env_logger::init();
let options = glob::MatchOptions {
case_sensitive: true,
require_literal_separator: true,
require_literal_leading_dot: true,
};
for entry in glob::glob_with("../private/**/*.idx", &options).unwrap() {
let entry = e
```
<Overlap Ratio: 0.8585526315789473>

---

--- 330 --
Question ID: 45d755071fd38bd417786aa87f53f00b64a9a613_1
Original Code:
```
fn get_settings_interactively() -> Settings {
    let mut input = String::new();

    print!("Enter the C/C++ file to be converted to Rust : ");
    io::stdout().flush().expect("FATAL : Buffer flush failed");
    io::stdin().read_line(&mut input).expect("Unable to read");

    let mut strict = String::new();

    print!("Enter the translation mode [(S/s)trict/(L/l)oose] : ");
    io::stdout().flush().expect("FATAL : Buffer flush failed");
    io::stdin().read_line(&mut strict).expect("Unable to read");
    let strict = strict.trim();
    let strict = matches!(strict, "S" | "Strict" | "s");

    let mut cargo = String::new();
    print!("Do you want to create a cargo project :[Y/N]");
    io::stdout().flush().expect("FATAL : Buffer flush failed.");
    io::stdin()
        .read_line(&mut cargo)
        .expect("Unable to read input");
    let cargo = cargo.trim();
    let cargo: bool = matches!(cargo, "Y" | "y");

    let mut project_name = None;
    if cargo {
        let mut project = String::new();
        print!("Enter cargo project name : ");
        io::stdout().flush().expect("FATAL : Buffer flush failed");
        io::stdin()
            .read_line(&mut project)
            .expect("Unable to read input");
        project_name = Some(String::from(project.trim()));
    }

    Settings {
        strict,
        project_name,
        files: vec![input.trim().to_owned()],
    }
}
```


Overlapping Code:
```
_settings_interactively() -> Settings {
let mut input = String::new();
print!("Enter the C/C++ file to be converted to Rust : ");
io::stdout().flush().expect("FATAL : Buffer flush failed");
io::stdin().read_line(&mut input).expect("Unable to read");
let mut strict = String::new();
print!("Enter the translation mode [(S/s)trict/(L/l)oose] : ");
io::stdout().flush().expect("FATAL : Buffer flush failed");
io::stdin().read_line(&mut strict).expect("Unable to read");
let strict = strict.trim();
let strict = matches!(strict, "S" | "Strict" | "s");
let mut cargo = String::new();
print!("Do you want to create a cargo project :[Y/N]");
io::stdout().flush().expect("FATAL : Buffer flush failed.");
io::stdin()
.read_line(&mut cargo)
.expect("Unable to read input");
let cargo = cargo.trim();
let cargo: bool = matches!(cargo, "Y" | "y");
let mut project_name = None;
if cargo {
let mut project = String::new();
print!("Enter cargo project name : ");
io::stdout().flush().expect("FATAL : Buffer flush failed");
io::stdin()
.read_line(&mut project)
.expect("Unable to read input");
project_name = Some(String::from(project.trim()));
}
Settings {
strict,
project_name,
files: vec![input.trim().to_owned()]
```
<Overlap Ratio: 0.990916597853014>

---

--- 331 --
Question ID: 964e7adc38a85ccc5250e28810827bb190b96dcb_2
Original Code:
```
pub fn read(file: &Option<PathBuf>) -> Result<String, io::Error> {
    // TODO: stream instead of reading everything into string
    let mut contents = String::new();

    if let Some(path) = file {
        File::open(&path)?.read_to_string(&mut contents)?;
    } else {
        stdin().read_to_string(&mut contents)?;
    };

    Ok(contents)
}
```


Overlapping Code:
```
uf>) -> Result<String, io::Error> {
// TODO: stream instead of reading everything into string
let mut contents = String::new();
if let Some(path) = file {
File::open(&path)?.read_to_string(&mut contents)?;
} else {
stdin().read_to_string(&mut content
```
<Overlap Ratio: 0.8250825082508251>

---

--- 332 --
Question ID: 6350c5fb113a1102b491ea5d2d9f622932f2b5a8_10
Original Code:
```
fn list_with_text() {
    // root (Document)
    // └── html
    //     └── head
    //     └── body
    //         └── ul
    //             └── li
    //                 └── list 1
    //             └── li
    //                 └── list 2
    let root = create_base_dom_tree();
    let mut body = root
        .borrow_mut()
        .first_child()
        .unwrap()
        .borrow_mut()
        .first_child()
        .unwrap()
        .borrow_mut()
        .next_sibling()
        .unwrap();
    add_child_ul_to(&mut body);

    let mut li1 = body
        .borrow_mut()
        .first_child()
        .unwrap()
        .borrow_mut()
        .first_child()
        .unwrap();
    add_text_node_to(&mut li1, "list 1");

    let mut l12 = li1.borrow_mut().next_sibling().unwrap();
    add_text_node_to(&mut l12, "list 2");

    run_test!(
        "<html><head></head><body><ul><li>list 1</li><li>list 2</li></ul></body></html>",
        Some(root)
    );
}
```


Overlapping Code:
```

// root (Document)
// └── html
// └── head
// └── body
// └── ul
// └── li
// └── list 1
// └── li
// └── list 2
let root = create_base_dom_tree();
let mut body = root
.borrow_mut()
.first_child()
.unwrap()
.borrow_mut()
.first_child()
.unwrap()
.borrow_mut()
.next_sibling()
.unwrap();
add_child_ul_to(&mut body);
let mut li1 = body
.borrow_mut()
.first_child()
.unwrap()
.borrow_mut()
.first_child()
.unwrap();
add_text_node_to(&mut li1, "list 1");
let mut l12 = li1.borrow_mut().next_sibling().unwrap();
add_text_node_to(&mut l12, "list 2");
run_test!(
"<html><head></head><body><ul><li>list 1</li><li>list 2</li></ul></body></html>",
Some(root)

```
<Overlap Ratio: 0.9629629629629629>

---

--- 333 --
Question ID: 2cecf69f696d8608c50dbf9dd4a7e2c2d038c650_12
Original Code:
```
fn test_basic_expansion() {
        let case = MacroCase {
            args: vec![
                MacroPattern::Syntax("test".to_string()),
                MacroPattern::Single("a".to_string()),
                MacroPattern::Single("b".to_string()),
                MacroPattern::Single("c".to_string()),
            ],
            body: List::new(vec![
                atom_identifier("fun-call"),
                atom_identifier("inserted-variable"),
                atom_identifier("a"),
                atom_identifier("b"),
                atom_identifier("c"),
            ])
            .into(),
        };

        let input = List::new(vec![
            atom_identifier("test"),
            atom_int(1),
            atom_identifier("apple"),
            atom_int(2),
        ]);

        let expected: ExprKind = List::new(vec![
            atom_identifier("fun-call"),
            atom_identifier("inserted-variable"),
            atom_int(1),
            atom_identifier("apple"),
            atom_int(2),
        ])
        .into();

        let output = case.expand(input, Span::new(0, 0)).unwrap();

        assert_eq!(output, expected);
    }
```


Overlapping Code:
```
MacroCase {
args: vec![
MacroPattern::Syntax("test".to_string()),
MacroPattern::Single("a".to_string()),
MacroPattern::Single("b".to_string()),
MacroPattern::Single("c".to_string()),
],
body: List::new(vec![
atom_identifier("fun-call"),
atom_identifier("inserted-variable"),
atom_identifier("a"),
atom_identifier("b"),
atom_identifier("c"),
])
.into(),
};
let input = List::new(vec![
atom_identifier("test"),
atom_int(1),
atom_identifier("apple"),
atom_int(2),
]);
let expected: ExprKind = List::new(vec![
atom_identifier("fun-call"),
atom_identifier("inserted-variable"),
atom_int(1),
atom_identifier("apple"),
atom_int(2),
])
.into();
let output = case.expand(input, Span::new(0, 0)).unwrap();
asse
```
<Overlap Ratio: 0.9138381201044387>

---

--- 334 --
Question ID: 1aefff91b0ee55dee2c7d76bb55022029d6a197f_0
Original Code:
```
pub fn main(username: String) {
    let icon_bytes = include_bytes!("../assets/icon.ico");
    let icon = Icon::from_buffer(icon_bytes, None, None).unwrap();
    let (s, r) = std::sync::mpsc::channel::<Events>();

    let _tray_icon = TrayIconBuilder::new()
        .icon(icon)
        .sender(s)
        .tooltip("Bitwarden Autotype")
        .menu(
            MenuBuilder::new()
                .with(info_item("Bitwarden Autotype is running"))
                .separator()
                .with(info_item(&format!("Logged in as {}", username)))
                .with(info_item("Hotkey: Ctrl-Alt-A"))
                .separator()
                .item("Sync Vault", Events::SyncNow)
                .separator()
                .item("Exit", Events::Exit),
        )
        .build()
        .unwrap();

    std::thread::spawn(move || {
        r.iter().for_each(|m| match m {
            Events::Exit => {
                info!("Shutting down");
                exit(0);
            }
            Events::SyncNow => {
                info!("Sync requested");
                crate::bw_cli::sync()
            }
            e => {
                println!("{:?}", e);
            }
        })
    });

    loop {
        unsafe {
            let mut msg = MaybeUninit::uninit();
            let bret = winuser::GetMessageW(msg.as_mut_ptr(), 0 as _, 0, 0);
            if bret > 0 {
                winuser::TranslateMessage(msg.as_ptr());
                winuser::DispatchMessageW(msg.as_ptr());
            } else {
                warn!("Failed to receive message");
            }
        }
    }
}
```


Overlapping Code:
```
main(username: String) {
let icon_bytes = include_bytes!("../assets/icon.ico");
let icon = Icon::from_buffer(icon_bytes, None, None).unwrap();
let (s, r) = std::sync::mpsc::channel::<Events>();
let _tray_icon = TrayIconBuilder::new()
.icon(icon)
.sender(s)
.tooltip("Bitwarden Autotype")
.menu(
MenuBuilder::new()
.with(info_item("Bitwarden Autotype is running"))
.separator()
.with(info_item(&format!("Logged in as {}", username)))
.with(info_item("Hotkey: Ctrl-Alt-A"))
.separator()
.item("Sync Vault", Events::SyncNow)
.separator()
.item("Exit", Events::Exit),
)
.build()
.unwrap();
std::thread::spawn(move || {
r.iter().for_each(|m| match m {
Events::Exit => {
info!("Shutting down");
exit(0);
}
Events::SyncNow => {
info!("Sync requested");
crate::bw_cli::sync()
}
e => {
println!("{:?}", e);
}
})
});
loop {
unsafe {
let mut msg = MaybeUninit::uninit();
let bret = winuser::GetMessageW(msg.as_mut_ptr(), 0 as _, 0, 0);
if bret > 0 {
winuser::TranslateMessage(msg.as_ptr());
winuser::DispatchMessageW(msg.as_ptr());
} else {
warn!("Failed to rec
```
<Overlap Ratio: 0.9722222222222222>

---

--- 335 --
Question ID: ed945dd1c6e72f8d7d2818723f8771328de00955_0
Original Code:
```
fn state_control() {
    let store = MemoryBlockstore::new();
    let v = VM::new(&store);
    let addr1 = Address::new_id(1000);
    let addr2 = Address::new_id(2222);

    // set actor
    let a1 = actor(*ACCOUNT_ACTOR_CODE_ID, make_builtin(b"a1-head"), 42, TokenAmount::from(10u8));
    v.set_actor(addr1, a1.clone());
    let out = v.get_actor(addr1).unwrap();
    assert_eq!(out, a1);
    let check = v.checkpoint();

    let a2 = actor(*PAYCH_ACTOR_CODE_ID, make_builtin(b"a2-head"), 88, TokenAmount::from(1u8));
    v.set_actor(addr2, a2.clone());
    assert_eq!(v.get_actor(addr2).unwrap(), a2);
    // rollback removes a2 but not a1
    v.rollback(check);

    // a2 is gone
    assert_eq!(None, v.get_actor(addr2));
    assert_eq!(v.get_actor(addr1).unwrap(), a1);
}
```


Overlapping Code:
```
ore = MemoryBlockstore::new();
let v = VM::new(&store);
let addr1 = Address::new_id(1000);
let addr2 = Address::new_id(2222);
// set actor
let a1 = actor(*ACCOUNT_ACTOR_CODE_ID, make_builtin(b"a1-head"), 42, TokenAmount::from(10u8));
v.set_actor(addr1, a1.clone());
let out = v.get_actor(addr1).unwrap();
assert_eq!(out, a1);
let check = v.checkpoint();
let a2 = actor(*PAYCH_ACTOR_CODE_ID, make_builtin(b"a2-head"), 88, TokenAmount::from(1u8));
v.set_actor(addr2, a2.clone());
assert_eq!(v.get_actor(addr2).unwrap(), a2);
// rollback removes a2 but not a1
v.rollback(check);
// a2 is gone
assert_eq!(None, v.get_actor(addr2));
assert_eq!(v.get_actor
```
<Overlap Ratio: 0.927246790299572>

---

--- 336 --
Question ID: 222008ce52047888e82d647ed7477ef3b14a48e7_0
Original Code:
```
fn normalize(val: f64, max: f64) -> f64 {
  if val < ALL_MIN {
    return ALL_MIN;
  }
  if val > max {
    return max;
  }
  val
}
```


Overlapping Code:
```
rmalize(val: f64, max: f64) -> f64 {
if val < ALL_MIN {
return ALL_MIN;
}
if val > max {
return max;
}
val

```
<Overlap Ratio: 0.9469026548672567>

---

--- 337 --
Question ID: c9b11a0633a5a45923854be3614c69ebbf16afb9_2
Original Code:
```
pub async fn get_entries(client: &Client, id: Uuid) -> Result<Vec<Entry>, Error> {
    let mut url = Url::parse("https://splits.io/api/v4/races").unwrap();
    url.path_segments_mut().unwrap().extend(&[
        id.to_hyphenated().encode_lower(&mut Uuid::encode_buffer()),
        "entries",
    ]);

    let ContainsEntries { entries } = get_json(
        client,
        Request::get(url.as_str()).body(Body::empty()).unwrap(),
    )
    .await?;

    Ok(entries)
}
```


Overlapping Code:
```
s(client: &Client, id: Uuid) -> Result<Vec<Entry>, Error> {
let mut url = Url::parse("https://splits.io/api/v4/races").unwrap();
url.path_segments_mut().unwrap().extend(&[
id.to_hyphenated().encode_lower(&mut Uuid::encode_buffer()),
"entries",
]);
let ContainsEntries { entries } = get_json(
client,
Request::get(url.as_str()).body(Body::empty()).unwrap(),
)
.aw
```
<Overlap Ratio: 0.8960396039603961>

---

--- 338 --
Question ID: 7f4da6f279dddfd14822d3ff27b2543722279870_0
Original Code:
```
async fn test_create_lookup_table() {
    let mut context = setup_test_context().await;

    let test_recent_slot = 123;
    overwrite_slot_hashes_with_slots(&mut context, &[test_recent_slot]);

    let client = &mut context.banks_client;
    let payer = &context.payer;
    let recent_blockhash = context.last_blockhash;
    let authority_keypair = Keypair::new();
    let authority_address = authority_keypair.pubkey();
    let (create_lookup_table_ix, lookup_table_address) =
        create_lookup_table(authority_address, payer.pubkey(), test_recent_slot);

    // First create should succeed
    {
        let transaction = Transaction::new_signed_with_payer(
            &[create_lookup_table_ix.clone()],
            Some(&payer.pubkey()),
            &[payer, &authority_keypair],
            recent_blockhash,
        );

        assert_matches!(client.process_transaction(transaction).await, Ok(()));
        let lookup_table_account = client
            .get_account(lookup_table_address)
            .await
            .unwrap()
            .unwrap();
        assert_eq!(lookup_table_account.owner, crate::id());
        assert_eq!(lookup_table_account.data.len(), LOOKUP_TABLE_META_SIZE);
        assert_eq!(
            lookup_table_account.lamports,
            Rent::default().minimum_balance(LOOKUP_TABLE_META_SIZE)
        );
        let lookup_table = AddressLookupTable::deserialize(&lookup_table_account.data).unwrap();
        assert_eq!(lookup_table.meta.derivation_slot, test_recent_slot);
        assert_eq!(lookup_table.meta.authority, Some(authority_address));
        assert_eq!(lookup_table.meta.last_extended_slot, 0);
        assert_eq!(lookup_table.meta.last_extended_slot_start_index, 0);
        assert_eq!(lookup_table.addresses.len(), 0);
    }

    // Second create should fail
    {
        context.last_blockhash = client
            .get_new_latest_blockhash(&recent_blockhash)
            .await
            .unwrap();
        assert_ix_error(
            &mut context,
            create_lookup_table_ix,
            Some(&authority_keypair),
            InstructionError::AccountAlreadyInitialized,
        )
        .await;
    }
}
```


Overlapping Code:
```
fn test_create_lookup_table() {
let mut context = setup_test_context().await;
let test_recent_slot = 123;
overwrite_slot_hashes_with_slots(&mut context, &[test_recent_slot]);
let client = &mut context.banks_client;
let payer = &context.payer;
let recent_blockhash = context.last_blockhash;
let authority_keypair = Keypair::new();
let authority_address = authority_keypair.pubkey();
let (create_lookup_table_ix, lookup_table_address) =
create_lookup_table(authority_address, payer.pubkey(), test_recent_slot);
// First create should succeed
{
let transaction = Transaction::new_signed_with_payer(
&[create_lookup_table_ix.clone()],
Some(&payer.pubkey()),
&[payer, &authority_keypair],
recent_blockhash,
);
assert_matches!(client.process_transaction(transaction).await, Ok(()));
let lookup_table_account = client
.get_account(lookup_table_address)
.await
.unwrap()
.unwrap();
assert_eq!(lookup_table_account.owner, crate::id());
assert_eq!(lookup_table_account.data.len(), LOOKUP_TABLE_META_SIZE);
assert_eq!(
lookup_table_account.lamports,
Rent::default().minimum_balance(LOOKUP_TABLE_META_SIZE)
);
let lookup_table = AddressLookupTable::deserialize(&lookup_table_account.data).unwrap();
assert_eq!(lookup_table.meta.derivation_slot, test_recent_slot);
assert_eq!(lookup_table.meta.authority, Some(authority_address));
assert_eq!(lookup_table.meta.last_extended_slot, 0);
assert_eq!(lookup_table.meta.last_extended_slot_start_index, 0);
assert_eq!(lookup_table.addresses.len(), 0);
}
// Second create should fail
{
context.last_blockhash = client
.get_new_latest_blockhash(&recent_blockhash)
.await
.unwrap();
assert_ix_error(
&mut context,
create_lookup_table_ix,
Some(&authority_keypair),
Instructio
```
<Overlap Ratio: 0.9692132269099202>

---

--- 339 --
Question ID: 27f1158840e2f4f0bfff5cf11627ec83120e8c20_0
Original Code:
```
fn test_vec_binary_tree_basic() {
        let mut tree = VecBinaryTree::new();
        let mut cursor = tree.cursor_mut();
        cursor.insert_as_root(0);
        cursor.insert_as_left(1);
        cursor.insert_as_right(2);
        cursor.move_right();
        cursor.insert_as_left(3);
        cursor.move_left();
        cursor.insert_as_left(4);
        cursor.insert_as_right(5);
        assert_eq!(
            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
            [0, 1, 2, 3, 4, 5]
        );
        let mut cursor = tree.cursor_mut();
        let right = cursor.take_right().unwrap();
        assert_eq!(
            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
            [0, 1]
        );
        assert_eq!(
            right.cursor().in_order_iter().copied().collect::<Vec<_>>(),
            [2, 3, 4, 5]
        );
        let mut cursor = tree.cursor_mut();
        cursor.move_left();
        cursor.append_left(right);
        assert_eq!(
            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
            [0, 1, 2, 3, 4, 5]
        );
        let mut cursor = tree.cursor_mut();
        cursor.insert_as_right(6);
        assert_eq!(
            tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
            [0, 1, 6, 2, 3, 4, 5]
        );
        assert_eq!(
            tree.cursor().pre_order_iter().copied().collect::<Vec<_>>(),
            [0, 1, 2, 3, 4, 5, 6]
        );
        assert_eq!(
            tree.cursor().mid_order_iter().copied().collect::<Vec<_>>(),
            [4, 3, 5, 2, 1, 0, 6]
        );
        assert_eq!(
            tree.cursor().post_order_iter().copied().collect::<Vec<_>>(),
            [4, 5, 3, 2, 1, 6, 0]
        );
        let mut cursor = tree.cursor_mut();
        cursor.move_right();
        assert_eq!(
            cursor
                .cursor()
                .post_order_iter()
                .copied()
                .collect::<Vec<_>>(),
            [6]
        );
    }
```


Overlapping Code:
```
nary_tree_basic() {
let mut tree = VecBinaryTree::new();
let mut cursor = tree.cursor_mut();
cursor.insert_as_root(0);
cursor.insert_as_left(1);
cursor.insert_as_right(2);
cursor.move_right();
cursor.insert_as_left(3);
cursor.move_left();
cursor.insert_as_left(4);
cursor.insert_as_right(5);
assert_eq!(
tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
[0, 1, 2, 3, 4, 5]
);
let mut cursor = tree.cursor_mut();
let right = cursor.take_right().unwrap();
assert_eq!(
tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
[0, 1]
);
assert_eq!(
right.cursor().in_order_iter().copied().collect::<Vec<_>>(),
[2, 3, 4, 5]
);
let mut cursor = tree.cursor_mut();
cursor.move_left();
cursor.append_left(right);
assert_eq!(
tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
[0, 1, 2, 3, 4, 5]
);
let mut cursor = tree.cursor_mut();
cursor.insert_as_right(6);
assert_eq!(
tree.cursor().in_order_iter().copied().collect::<Vec<_>>(),
[0, 1, 6, 2, 3, 4, 5]
);
assert_eq!(
tree.cursor().pre_order_iter().copied().collect::<Vec<_>>(),
[0, 1, 2, 3, 4, 5, 6]
);
assert_eq!(
tree.cursor().mid_order_iter().copied().collect::<Vec<_>>(),
[4, 3, 5, 2, 1, 0, 6]
);
assert_eq!(
tree.cursor().post_order_iter().copied().collect::<Vec<_>>(),
[4, 5, 3, 2, 1, 6, 0]
);
let mut cursor = tree.cursor_mut();
cursor.move_right();
assert_eq!(
cursor
.cursor()
.post_order_iter()
.copied()
.collect::<Vec<_>>
```
<Overlap Ratio: 0.9817671809256662>

---

--- 340 --
Question ID: b0be92bd7e809e3d31232bf0af30c108e80f5a91_1
Original Code:
```
fn to_bytes(fs: &[Fraction]) -> Vec<u8> {
        let mut res = Vec::new();
        for f in fs {
            res.extend_from_slice(&f.0);
        }
        res
    }
```


Overlapping Code:
```
) -> Vec<u8> {
let mut res = Vec::new();
for f in 
```
<Overlap Ratio: 0.423728813559322>

---

--- 341 --
Question ID: 908e270555dc1efde907e4e021368817b4d04fbc_3
Original Code:
```
fn const_test(term: Term) {
        init();
        let mut cs = Computation::new(true);
        cs.assert(term.clone());
        cs.assert(leaf_term(Op::Const(Value::Bool(true))));
        let ilp = to_ilp(cs);
        let r = ilp.solve(default_solver);
        if r.is_err() {
            panic!("Error: {:?} on {}", r, term)
        }
    }
```


Overlapping Code:
```
 {
init();
let mut cs = Computation::new(true);
cs.assert(term.clone());
cs.assert(leaf_term(Op::Const(Value::Bool(true))));
let ilp = to_ilp(cs);
let r = ilp.solve(default_solver);
if r.is_err() {
pa
```
<Overlap Ratio: 0.7604562737642585>

---

--- 342 --
Question ID: d574411007b66f532420634a3d0cc4ba2b332053_4
Original Code:
```
async fn handle_after_timeout<T: Node + Debug>(state: &mut RaftElectionState<T>) {
    //don't start election there isn't enough nodes.
    if state.peers.len() < state.min_node {
        trace!("[node: {}] not enough node", &state.self_id);
        return;
    }

    if state.has_leader || (state.node_state == NodeState::Leader) {
        // let's reset has_leader to false.
        // some external process(or message) should set the flag to true on heartbeat message.
        // has_leader after timeout means no heartbeat was received from the leader
        // during timout
        state.has_leader = false | (state.node_state == NodeState::Leader);
        return;
    }

    //has no leader or initializing the raft system
    //promote to Candidate
    // if candidate, just restart the voting process.
    if matches!(state.node_state, NodeState::Follower | NodeState::Candidate) {
        debug!(
            "[node: {}] updating node state to NodeState::Candidate",
            &state.self_id
        );
        trace!(
            "[node: {}] updating term from {} to {}",
            &state.self_id,
            &state.term,
            state.term + 1
        );
        state.term += 1;
        state.node_state = NodeState::Candidate;
        //self vote
        state.votes = 1;
        //ask peers to vote
        for peer in state.peers.iter() {
            let msg = Message::RequestVote {
                node_id: state.self_id.clone(),
                term: state.term,
            };
            trace!(
                "[node: {}] sending vote request for term {} to: {:?}",
                &state.self_id,
                &state.term,
                peer
            );
            peer.send_message(msg).await;
        }
    }
    if state.votes > (state.peers.len() + 1) / 2 {
        state.node_state = NodeState::Leader;
        // for peer in state.peers.iter() {
        //     peer.send_message(Message::LeaderAnnouncement(state.self_id.clone()))
        //         .await;
        // }
        let result = state
            .tx
            .send_timeout(
                Message::ControlLeaderChanged(state.self_id.clone()),
                Duration::from_millis(state.message_timeout),
            )
            .await;
        log_error!(result);
    }
}
```


Overlapping Code:
```
ate: &mut RaftElectionState<T>) {
//don't start election there isn't enough nodes.
if state.peers.len() < state.min_node {
trace!("[node: {}] not enough node", &state.self_id);
return;
}
if state.has_leader || (state.node_state == NodeState::Leader) {
// let's reset has_leader to false.
// some external process(or message) should set the flag to true on heartbeat message.
// has_leader after timeout means no heartbeat was received from the leader
// during timout
state.has_leader = false | (state.node_state == NodeState::Leader);
return;
}
//has no leader or initializing the raft system
//promote to Candidate
// if candidate, just restart the voting process.
if matches!(state.node_state, NodeState::Follower | NodeState::Candidate) {
debug!(
"[node: {}] updating node state to NodeState::Candidate",
&state.self_id
);
trace!(
"[node: {}] updating term from {} to {}",
&state.self_id,
&state.term,
state.term + 1
);
state.term += 1;
state.node_state = NodeState::Candidate;
//self vote
state.votes = 1;
//ask peers to vote
for peer in state.peers.iter() {
let msg = Message::RequestVote {
node_id: state.self_id.clone(),
term: state.term,
};
trace!(
"[node: {}] sending vote request for term {} to: {:?}",
&state.self_id,
&state.term,
peer
);
peer.send_message(msg).await;
}
}
if state.votes > (state.peers.len() + 1) / 2 {
state.node_state = NodeState::Leader;
// for peer in state.peers.iter() {
// peer.send_message(Message::LeaderAnnouncement(state.self_id.clone()))
// .await;
// }
let result = state
.tx
.send_timeout(
Message::ControlLeaderChanged(state.self_id.clone()),
Duration::from_millis(state.message_timeout),
)
.await;
log_err
```
<Overlap Ratio: 0.9620991253644315>

---

--- 343 --
Question ID: cafe015af5e186644b3fbfbd475077a46394c335_5
Original Code:
```
fn test_public_xor() {
    let seq1 = PublicByteSeq::from_hex("3544de28f9d7d48ee7b318f6c541ff35");
    let seq2 = PublicByteSeq::from_hex("a4b13aa347b72f6c22870170fcb0cda3");

    let xor_output = seq1 ^ seq2; // output of XOR to be checked for correctness
    let expected = PublicByteSeq::from_hex("91f5e48bbe60fbe2c534198639f13296");

    assert_eq!(expected, xor_output);
}
```


Overlapping Code:
```
= PublicByteSeq::from_hex("3544de28f9d7d48ee7b318f6c541ff35");
let seq2 = PublicByteSeq::from_hex("a4b13aa347b72f6c22870170fcb0cda3");
let xor_output = seq1 ^ seq2; // output of XOR to be checked for correctness
let expected = PublicByteSeq::from_hex("91f5e48bbe60fbe2c534198639f13296");
assert_eq!(e
```
<Overlap Ratio: 0.8450704225352113>

---

--- 344 --
Question ID: d8edfa906c932a5dfccb45fe938d24ebd281099e_162
Original Code:
```
fn bindgen_test_layout___darwin_mcontext_avx64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),
        1064usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__fs)
        )
    );
}
```


Overlapping Code:
```
fn bindgen_test_layout___darwin_mcontext_avx64_full() {
assert_eq!(
::std::mem::size_of::<__darwin_mcontext_avx64_full>(),
1064usize,
concat!("Size of: ", stringify!(__darwin_mcontext_avx64_full))
);
assert_eq!(
::std::mem::align_of::<__darwin_mcontext_avx64_full>(),
8usize,
concat!("Alignment of ", stringify!(__darwin_mcontext_avx64_full))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx64_full),
"::",
stringify!(__es)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize
},
16usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx64_full),
"::",
stringify!(__ss)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize
},
216usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx64_full),
"::",
stringify!(__fs)
)
)
```
<Overlap Ratio: 0.9969849246231156>

---

--- 345 --
Question ID: 7fafcb91c0aebb5ae266fe08ef07059384fcfa34_0
Original Code:
```
fn main() -> Result<(), Error> {
    syslog::init_with_tags(&["setui-service"]).expect("Can't init logger");
    fx_log_info!("Starting setui-service...");

    let mut executor = fasync::Executor::new()?;

    let (action_tx, action_rx) = futures::channel::mpsc::unbounded::<SettingAction>();

    // Creates switchboard, handed to interface implementations to send messages
    // to handlers.
    let (_switchboard_handle, event_tx) = SwitchboardImpl::create(action_tx);

    // Creates registry, used to register handlers for setting types.
    let _registry_handle = RegistryImpl::create(event_tx, action_rx);

    let mut fs = ServiceFs::new();
    let handler = Arc::new(SetUIHandler::new());
    let system_handler = Arc::new(SystemStreamHandler::new(handler.clone()));

    // TODO(SU-210): Remove once other adapters are ready.
    handler.register_adapter(Box::new(SettingAdapter::new(
        SettingType::Unknown,
        Box::new(DefaultStore::new("/data/unknown.dat".to_string(), Box::new(JsonCodec::new()))),
        MutationHandler { process: &process_string_mutation, check_sync: None },
        None,
    )));

    handler.register_adapter(Box::new(SettingAdapter::new(
        SettingType::Account,
        Box::new(DefaultStore::new("/data/account.dat".to_string(), Box::new(JsonCodec::new()))),
        MutationHandler {
            process: &process_account_mutation,
            check_sync: Some(&should_sync_account_mutation),
        },
        Some(SettingData::Account(AccountSettings { mode: None })),
    )));

    let handler_clone = handler.clone();
    fs.dir("svc").add_fidl_service(move |stream: SetUiServiceRequestStream| {
        let handler_clone = handler_clone.clone();

        fx_log_info!("Connecting to setui_service");
        fasync::spawn(async move {
            await!(handler_clone.handle_stream(stream))
                .unwrap_or_else(|e| error!("Failed to spawn {:?}", e))
        });
    });

    // Register for the new settings APIs as well.
    fs.dir("svc").add_fidl_service(move |stream: SystemRequestStream| {
        let system_handler_clone = system_handler.clone();
        fx_log_info!("Connecting to System");
        fasync::spawn(async move {
            await!(system_handler_clone.handle_system_stream(stream))
                .unwrap_or_else(|e| error!("Failed to spawn {:?}", e))
        });
    });

    fs.take_and_serve_directory_handle()?;
    let () = executor.run_singlethreaded(fs.collect());
    Ok(())
}
```


Overlapping Code:
```
fn main() -> Result<(), Error> {
syslog::init_with_tags(&["setui-service"]).expect("Can't init logger");
fx_log_info!("Starting setui-service...");
let mut executor = fasync::Executor::new()?;
let (action_tx, action_rx) = futures::channel::mpsc::unbounded::<SettingAction>();
// Creates switchboard, handed to interface implementations to send messages
// to handlers.
let (_switchboard_handle, event_tx) = SwitchboardImpl::create(action_tx);
// Creates registry, used to register handlers for setting types.
let _registry_handle = RegistryImpl::create(event_tx, action_rx);
let mut fs = ServiceFs::new();
let handler = Arc::new(SetUIHandler::new());
let system_handler = Arc::new(SystemStreamHandler::new(handler.clone()));
// TODO(SU-210): Remove once other adapters are ready.
handler.register_adapter(Box::new(SettingAdapter::new(
SettingType::Unknown,
Box::new(DefaultStore::new("/data/unknown.dat".to_string(), Box::new(JsonCodec::new()))),
MutationHandler { process: &process_string_mutation, check_sync: None },
None,
)));
handler.register_adapter(Box::new(SettingAdapter::new(
SettingType::Account,
Box::new(DefaultStore::new("/data/account.dat".to_string(), Box::new(JsonCodec::new()))),
MutationHandler {
process: &process_account_mutation,
check_sync: Some(&should_sync_account_mutation),
},
Some(SettingData::Account(AccountSettings { mode: None })),
)));
let handler_clone = handler.clone();
fs.dir("svc").add_fidl_service(move |stream: SetUiServiceRequestStream| {
let handler_clone = handler_clone.clone();
fx_log_info!("Connecting to setui_service");
fasync::spawn(async move {
await!(handler_clone.handle_stream(stream))
.unwrap_or_else(|e| error!("Failed to spawn {:?}", e))
});
});
// Register for the new settings APIs as well.
fs.dir("svc").add_fidl_service(move |stream: SystemRequestStream| {
let system_handler_clone = system_handler.clone();
fx_log_info!("Connecting to System");
fasync::spawn(async move {
await!(system_handler_clone.handle_system_stream(stream))
.unwrap_or_else(|e| error!("Failed to spawn {:?}", e))
});
});
fs.take_and_serve_directory_handle()?;
let () = executor.run_singlethreaded(fs.collect());
Ok(())
}
```
<Overlap Ratio: 1.0>

---

--- 346 --
Question ID: d9b012ea4f09039f57924ced0af1f028e5bed835_10
Original Code:
```
fn test_seq0255_bool() {
            let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();

            let expected = Test { a: s };

            #[cfg(not(feature = "with_serde"))]
            let mut bytes = to_bytes(expected.clone()).unwrap();
            #[cfg(feature = "with_serde")]
            let mut bytes = to_bytes(&expected.clone()).unwrap();

            let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();

            assert_eq!(deserialized, expected);
        }
```


Overlapping Code:
```
 test_seq0255_bool() {
let s: Seq0255<bool> = Seq0255::new(vec![true, false, true]).unwrap();
let expected = Test { a: s };
#[cfg(not(feature = "with_serde"))]
let mut bytes = to_bytes(expected.clone()).unwrap();
#[cfg(feature = "with_serde")]
let mut bytes = to_bytes(&expected.clone()).unwrap();
let deserialized: Test = from_bytes(&mut bytes[..]).unwrap();
assert_eq!(deserialized, expected);

```
<Overlap Ratio: 0.9924812030075187>

---

--- 347 --
Question ID: a97ff0572deb752b85f5b36725a641def5d4bf8b_1
Original Code:
```
fn ouster_pcd_converter() -> Result<()> {
    // Load config
    let config = Config::from_path("test_files/ouster_example.json")?;
    let pcd_converter = PointCloudConverter::from_config(config);

    // Load pcap file
    let mut cap = Capture::from_file("test_files/ouster_example.pcap")?;
    cap.filter("udp")?;

    while let Ok(packet) = cap.next() {
        let lidar_packet = OusterPacket::from_pcap(&packet)?;
        let points = pcd_converter.convert(lidar_packet)?;
        assert!(points.len() as u16 == pcd_converter.columns_per_revolution());
    }

    Ok(())
}
```


Overlapping Code:
```
fn ouster_pcd_converter() -> Result<()> {
// Load config
let config = Config::from_path("test_files/ouster_example.json")?;
let pcd_converter = PointCloudConverter::from_config(config);
// Load pcap file
let mut cap = Capture::from_file("test_files/ouster_example.pcap")?;
cap.filter("udp")?;
while let Ok(packet) = cap.next() {
let lidar_packet = OusterPacket::from_pcap(&packet)?;
let points = pcd_converter.convert(lidar_packet)?;
assert!(points.len() as u16 == pcd_converter.columns_per_revolution()
```
<Overlap Ratio: 0.9748062015503876>

---

--- 348 --
Question ID: f14aa880f7ac22f7552d8600fbe09ad19f07f6f1_4
Original Code:
```
fn quartic_bspline() {
        let expect: Vec<(f32, f32)> = vec![(0.0, 0.0), (0.4, 0.0010666668), (1.0, 0.041666668),
                          (1.5, 0.19791667), (2.0, 0.4583333), (2.5, 0.5989583),
                          (3.0, 0.4583333), (3.2, 0.35206667), (4.1, 0.02733751),
                          (4.5, 0.002604167), (5.0, 0.0)];
        let points: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];
        let knots: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 5.0, 5.0, 5.0];
        let degree = 4;
        let spline = BSpline::new(degree, points, knots);
        assert!(check_bspline(&spline, &expect));
    }
```


Overlapping Code:
```
 {
let expect: Vec<(f32, f32)> = vec![(0.0, 0.0), (0.4, 0.0010666668), (1.0, 0.041666668),
(1.5, 0.19791667), (2.0, 0.4583333), (2.5, 0.5989583),
(3.0, 0.4583333), (3.2, 0.35206667), (4.1, 0.02733751),
(4.5, 0.002604167), (5.0, 0.0)];
let points: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0];
let knots: Vec<f32> = vec![0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 5.0, 5.0, 5.0, 5.0];
let degree = 4;
let spline = BSpline::new(degree, points, knots);
assert!(check_bspline(&spline, &expe
```
<Overlap Ratio: 0.9496268656716418>

---

--- 349 --
Question ID: 3ec8df72db047df9c7e3e30aeb87c436f2170203_33
Original Code:
```
fn alloc_and_free() {
        let mut vm = VM::default();
        let mut system = helper::generate_system();

        let program = helper::program_builder()
            .instructions(vec![
                Instruction::Alloc(10),
                Instruction::Alloc(30),
                Instruction::Free,
                Instruction::Free,
                Instruction::Alloc(20),
                Instruction::Free,
            ])
            .gen();

        vm.exec(&program, &mut system).unwrap();

        assert_eq!(vm.bp, 0);
    }
```


Overlapping Code:
```
) {
let mut vm = VM::default();
let mut system = helper::generate_system();
let program = helper::program_builder()
.instructions(vec![
Instruction::Alloc(10),
Instruction::Alloc(30),
Instruction::Free,
Instruction::Free,
Instruction::Alloc(20),
Instruction::Free,
])
.gen();
vm.exec(&program, &mut system).unwrap();
assert_eq!(vm
```
<Overlap Ratio: 0.9217877094972067>

---

--- 350 --
Question ID: 36730aed9dfe5926038aaf7427051082fb9a2994_1
Original Code:
```
fn get_expected_value_for_string_append_with_original_update_object(
    original_update_object: &serde_json::value::Map<String, serde_json::Value>,
    field: &'static Field<String>,
    string: &str
) -> Result<serde_json::value::Value, Box<dyn std::error::Error>> {
    let original_bytes_option = original_update_object.get(&field.name);
    let original_bytes = get_original_bytes(&original_bytes_option)?;

    return Ok(
        serde_json::json!(
            original_bytes
                .iter()
                .chain(string.as_bytes())
                .cloned()
                .collect::<Vec<u8>>()
        )
    );
}
```


Overlapping Code:
```
ue_for_string_append_with_original_update_object(
original_update_object: &serde_json::value::Map<String, serde_json::Value>,
field: &'static Field<String>,
string: &str
) -> Result<serde_json::value::Value, Box<dyn std::error::Error>> {
let original_bytes_option = original_update_object.get(&field.name);
let original_bytes = get_original_bytes(&original_bytes_option)?;
return Ok(
serde_json::json!(
original_bytes
.iter()
.chain(string.as_bytes())
.cloned()
.collect::<Vec<u8>
```
<Overlap Ratio: 0.9430255402750491>

---

--- 351 --
Question ID: d95402363cd8ad4150d80467195470ad710b702c_0
Original Code:
```
fn simple_message() {
    let test_name = random_name("simple_message");
    libsystemd::logging::journal_send(
        Priority::Info,
        "Hello World",
        vec![
            ("TEST_NAME", test_name.as_str()),
            ("FOO", "another piece of data"),
        ]
        .into_iter(),
    )
    .unwrap();

    let messages = read_from_journal(&test_name);
    assert_eq!(messages.len(), 1);

    let message = &messages[0];
    assert_eq!(message["MESSAGE"], "Hello World");
    assert_eq!(message["TEST_NAME"], test_name);
    assert_eq!(message["PRIORITY"], "6");
    assert_eq!(message["FOO"], "another piece of data");
}
```


Overlapping Code:
```
message() {
let test_name = random_name("simple_message");
libsystemd::logging::journal_send(
Priority::Info,
"Hello World",
vec![
("TEST_NAME", test_name.as_str()),
("FOO", "another piece of data"),
]
.into_iter(),
)
.unwrap();
let messages = read_from_journal(&test_name);
assert_eq!(messages.len(), 1);
let message = &messages[0];
assert_eq!(message["MESSAGE"], "Hello World");
assert_eq!(message["TEST_NAME"], test_name);
assert_eq!(message["PRIORITY"], "6");
assert_eq!(message["FOO"], "another 
```
<Overlap Ratio: 0.946969696969697>

---

--- 352 --
Question ID: 8d58f045f65e095a023d1fcdcb3ebdfbf4eea32d_42
Original Code:
```
pub fn serialize_structure_crate_model_webhook_definition(
    object: &mut aws_smithy_json::serialize::JsonObjectWriter,
    input: &crate::model::WebhookDefinition,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
    if let Some(var_189) = &input.name {
        object.key("name").string(var_189);
    }
    if let Some(var_190) = &input.target_pipeline {
        object.key("targetPipeline").string(var_190);
    }
    if let Some(var_191) = &input.target_action {
        object.key("targetAction").string(var_191);
    }
    if let Some(var_192) = &input.filters {
        let mut array_193 = object.key("filters").start_array();
        for item_194 in var_192 {
            {
                let mut object_195 = array_193.value().start_object();
                crate::json_ser::serialize_structure_crate_model_webhook_filter_rule(
                    &mut object_195,
                    item_194,
                )?;
                object_195.finish();
            }
        }
        array_193.finish();
    }
    if let Some(var_196) = &input.authentication {
        object.key("authentication").string(var_196.as_str());
    }
    if let Some(var_197) = &input.authentication_configuration {
        let mut object_198 = object.key("authenticationConfiguration").start_object();
        crate::json_ser::serialize_structure_crate_model_webhook_auth_configuration(
            &mut object_198,
            var_197,
        )?;
        object_198.finish();
    }
    Ok(())
}
```


Overlapping Code:
```
ebhook_definition(
object: &mut aws_smithy_json::serialize::JsonObjectWriter,
input: &crate::model::WebhookDefinition,
) -> Result<(), aws_smithy_http::operation::SerializationError> {
if let Some(var_189) = &input.name {
object.key("name").string(var_189);
}
if let Some(var_190) = &input.target_pipeline {
object.key("targetPipeline").string(var_190);
}
if let Some(var_191) = &input.target_action {
object.key("targetAction").string(var_191);
}
if let Some(var_192) = &input.filters {
let mut array_193 = object.key("filters").start_array();
for item_194 in var_192 {
{
let mut object_195 = array_193.value().start_object();
crate::json_ser::serialize_structure_crate_model_webhook_filter_rule(
&mut object_195,
item_194,
)?;
object_195.finish();
}
}
array_193.finish();
}
if let Some(var_196) = &input.authentication {
object.key("authentication").string(var_196.as_str());
}
if let Some(var_197) = &input.authentication_configuration {
let mut object_198 = object.key("authenticationConfiguration").start_object();
crate::json_ser::serialize_structure_crate_model_webhook_auth_configuration(
&mut object_198,
var_197,
)?;
object_198.finish();
}

```
<Overlap Ratio: 0.9599332220367279>

---

--- 353 --
Question ID: 2c4ed5a22570842ff78d205527b9c2dad01eecf6_0
Original Code:
```
fn main() {
    let mut input_a = String::new();
    let mut input_b = String::new();

    if let Err(_e) = io::stdin().read_line(&mut input_a){}
    if let Err(_e) = io::stdin().read_line(&mut input_b){}

    let a: f64 = input_a.trim().parse().unwrap();
    let b: f64 = input_b.trim().parse().unwrap();

    println!("MEDIA = {:.5}", (a * 3.5 + b * 7.5) / 11.0);
}
```


Overlapping Code:
```
ain() {
let mut input_a = String::new();
let mut input_b = String::new();
if let Err(_e) = io::stdin().read_line(&mut input_a){}
if let Err(_e) = io::stdin().read_line(&mut input_b){}
let a: f64 = input_a.trim().parse().unwrap();
let b: f64 = input_b.trim().parse().unwrap();
println!("MEDIA = {:.5}", (a * 3.5 + b *
```
<Overlap Ratio: 0.9404761904761905>

---

--- 354 --
Question ID: 8dcf8e6347f1b9f6a3759594c30ed42aaafaabb2_1
Original Code:
```
fn test_decimal_round_result_zero() {
        let x = Decimal::new_raw(12345, 2);
        let y = x.round(-3);
        assert_eq!(y.coefficient(), 0);
        assert_eq!(y.n_frac_digits(), 0);
        let y = x.round(-37);
        assert_eq!(y.coefficient(), 0);
        assert_eq!(y.n_frac_digits(), 0);
        let y = x.checked_round(-9).unwrap();
        assert_eq!(y.coefficient(), 0);
        assert_eq!(y.n_frac_digits(), 0);
        let y = x.checked_round(-42).unwrap();
        assert_eq!(y.coefficient(), 0);
        assert_eq!(y.n_frac_digits(), 0);
    }
```


Overlapping Code:
```
_round_result_zero() {
let x = Decimal::new_raw(12345, 2);
let y = x.round(-3);
assert_eq!(y.coefficient(), 0);
assert_eq!(y.n_frac_digits(), 0);
let y = x.round(-37);
assert_eq!(y.coefficient(), 0);
assert_eq!(y.n_frac_digits(), 0);
let y = x.checked_round(-9).unwrap();
assert_eq!(y.coefficient(), 0);
assert_eq!(y.n_frac_digits(), 0);
let y = x.checked_round(-42).unwrap();
assert_eq!(y.coefficient(), 0);
assert_eq!(y.n_frac_digits(), 0);

```
<Overlap Ratio: 0.9651416122004357>

---

--- 355 --
Question ID: 56b1907de8e056b7b6eab055838b71af6c927f97_10
Original Code:
```
fn test_get_preferred_horizontal_position4() {
        // Case 4: X is moved to left and width is truncated
        let area = gdk::Rectangle {
            x: 0,
            y: 0,
            height: 0,
            width: 20,
        };

        let pos = gdk::Rectangle {
            x: 15,
            y: 0,
            width: 0,
            height: 0,
        };

        let width = 150;
        let (x, w) = get_preferred_horizontal_position(&area, &pos, width);
        assert_eq!(x, 0);
        assert_eq!(w, 20);
    }
```


Overlapping Code:
```
ferred_horizontal_position4() {
// Case 4: X is moved to left and width is truncated
let area = gdk::Rectangle {
x: 0,
y: 0,
height: 0,
width: 20,
};
let pos = gdk::Rectangle {
x: 15,
y: 0,
width: 0,
height: 0,
};
let width = 150;
let (x, w) = get_preferred_horizontal_position(&area, &pos, width);
assert_eq!(x
```
<Overlap Ratio: 0.8835227272727273>

---

--- 356 --
Question ID: 8abbbca823e7bcb5fde0e048d55209945d99b1a9_31
Original Code:
```
fn _0032(b: &mut Bencher) {
  let ctx = context(r#"{}"#);
  let invocable_name = "feel-date-function_ErrorCase_032_fc66cc2fec";
  assert_decision(&MODEL_EVALUATOR, invocable_name, &ctx, r#"null([core::date] invalid date string '')"#);
  b.iter(|| MODEL_EVALUATOR.evaluate_invocable(invocable_name, &ctx));
}
```


Overlapping Code:
```
2(b: &mut Bencher) {
let ctx = context(r#"{}"#);
let invocable_name = "feel-date-function_ErrorCase_032_fc66cc2fec";
assert_decision(&MODEL_EVALUATOR, invocable_name, &ctx, r#"null([core::date] invalid date string '')"#);
b.iter(|| MODEL_EVALUATOR.evaluate_invocable(invocable_name, &ctx));
}
```
<Overlap Ratio: 0.9765886287625418>

---

--- 357 --
Question ID: 005643a0c40d69864a931e4b81517ee53d84e2cd_1
Original Code:
```
pub(crate) fn compact<TI1, TI2, O1, O2, E1, E2>(
    old: &ModelImpl<TI1, O1>,
) -> TractResult<ModelImpl<TI2, O2>>
where
    TractError: From<E1> + From<E2>,
    TI1: Fact + Clone + 'static,
    TI2: Fact + TryFrom<TI1, Error = E1> + Clone + 'static,
    O1: Display + Debug + Clone + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,
    O2: Display + TryFrom<O1, Error = E2> + Debug + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,
{
    let mut model = ModelImpl::default();
    let mut map = HashMap::new();
    for old_id in old.eval_order()? {
        let old_node = &old.nodes()[old_id];
        let facts = old_node
            .outputs
            .iter()
            .map(|of| Ok(TI2::try_from(of.fact.clone())?))
            .collect::<TractResult<TVec<_>>>()
            .map_err(|e| format!("While translating {}: {:?}", old_node, e))?;
        let new_op = O2::try_from(old_node.op.clone())?;
        let new_id = model.add_node(old_node.name.clone(), new_op, facts)?;
        map.insert(old_id, new_id);
        for ix in 0..old_node.outputs.len() {
            if let Some(label) = old.outlet_label(OutletId::new(old_id, ix)) {
                model.set_outlet_label(OutletId::new(new_id, ix), label.to_string());
            }
        }
        if old.input_outlets()?.contains(&OutletId::new(old_node.id, 0)) {
            continue;
        }
        for (ix, input) in old_node.inputs.iter().enumerate() {
            model
                .add_edge(OutletId::new(map[&input.node], input.slot), InletId::new(new_id, ix))?;
        }
        for input in old_node.control_inputs.iter() {
            model.node_mut(new_id).control_inputs.push(map[input]);
        }
    }
    for i in old.input_outlets()? {
        if !map.contains_key(&i.node) {
            let node = old.node(i.node);
            debug!("Translate useless source {}", node);
            let new_id = model.add_node(
                &*node.name,
                O2::try_from(node.op.clone())?,
                tvec!(TI2::try_from(node.outputs[0].fact.clone())?),
            )?;
            map.insert(i.node, new_id);
        }
    }
    // maintaining order of i/o interface
    model.inputs = old.input_outlets()?.iter().map(|i| OutletId::new(map[&i.node], 0)).collect();
    model.outputs =
        old.output_outlets()?.iter().map(|o| OutletId::new(map[&o.node], o.slot)).collect();
    Ok(model)
}
```


Overlapping Code:
```
, O1, O2, E1, E2>(
old: &ModelImpl<TI1, O1>,
) -> TractResult<ModelImpl<TI2, O2>>
where
TractError: From<E1> + From<E2>,
TI1: Fact + Clone + 'static,
TI2: Fact + TryFrom<TI1, Error = E1> + Clone + 'static,
O1: Display + Debug + Clone + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,
O2: Display + TryFrom<O1, Error = E2> + Debug + AsRef<dyn Op> + AsMut<dyn Op> + Clone + 'static,
{
let mut model = ModelImpl::default();
let mut map = HashMap::new();
for old_id in old.eval_order()? {
let old_node = &old.nodes()[old_id];
let facts = old_node
.outputs
.iter()
.map(|of| Ok(TI2::try_from(of.fact.clone())?))
.collect::<TractResult<TVec<_>>>()
.map_err(|e| format!("While translating {}: {:?}", old_node, e))?;
let new_op = O2::try_from(old_node.op.clone())?;
let new_id = model.add_node(old_node.name.clone(), new_op, facts)?;
map.insert(old_id, new_id);
for ix in 0..old_node.outputs.len() {
if let Some(label) = old.outlet_label(OutletId::new(old_id, ix)) {
model.set_outlet_label(OutletId::new(new_id, ix), label.to_string());
}
}
if old.input_outlets()?.contains(&OutletId::new(old_node.id, 0)) {
continue;
}
for (ix, input) in old_node.inputs.iter().enumerate() {
model
.add_edge(OutletId::new(map[&input.node], input.slot), InletId::new(new_id, ix))?;
}
for input in old_node.control_inputs.iter() {
model.node_mut(new_id).control_inputs.push(map[input]);
}
}
for i in old.input_outlets()? {
if !map.contains_key(&i.node) {
let node = old.node(i.node);
debug!("Translate useless source {}", node);
let new_id = model.add_node(
&*node.name,
O2::try_from(node.op.clone())?,
tvec!(TI2::try_from(node.outputs[0].fact.clone())?),
)?;
map.insert(i.node, new_id);
}
}
// maintaining order of i/o interface
model.inputs = old.input_outlets()?.iter().map(|i| OutletId::new(map[&i.node], 0)).collect();
model.outputs =
old.output_outlets()?.iter().map(|o| OutletId::new(map[&o.node], o.slot)).collect();

```
<Overlap Ratio: 0.9788768675940237>

---

--- 358 --
Question ID: 4f3d9f22f5d4f4f98d5b2b0083560fc60382ddd2_0
Original Code:
```
fn test_maximal_independent_set_wikipedia() {
    let g = graph_wikipedia();
    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![0, 1, 2, 3, 4, 5]));
    assert_eq!(vec![1, 3], maximal_independent_set(&g, &vec![1, 0, 2, 3, 4, 5]));
    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![2, 0, 1, 3, 4, 5]));
    assert_eq!(vec![0, 3], maximal_independent_set(&g, &vec![3, 0, 1, 2, 4, 5]));
    assert_eq!(vec![2, 4, 5], maximal_independent_set(&g, &vec![4, 0, 1, 2, 3, 5]));
    assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![5, 0, 1, 2, 3, 4]));
}
```


Overlapping Code:
```
fn test_maximal_independent_set_wikipedia() {
let g = graph_wikipedia();
assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![0, 1, 2, 3, 4, 5]));
assert_eq!(vec![1, 3], maximal_independent_set(&g, &vec![1, 0, 2, 3, 4, 5]));
assert_eq!(vec![0, 2, 5], maximal_independent_set(&g, &vec![2, 0, 1, 3, 4, 5]));
assert_eq!(vec![0, 3], maximal_independent_set(&g, &vec![3, 0, 1, 2, 4, 5]));
assert_eq!(vec![2, 4, 5], maximal_independent_set(&g, &vec![4, 0, 1, 2, 3, 5]));
assert_eq!(vec![0, 2, 5], maximal_in
```
<Overlap Ratio: 0.9169675090252708>

---

--- 359 --
Question ID: c7b6c06a91c2d640e2a5eafd6be8cec2a3cef26e_0
Original Code:
```
fn test_get_text() {
        let width = 3;
        let key_config = KeyConfig::default();
        let mut component = HelpComponent::new(key_config.clone());
        component.set_cmds(vec![
            CommandInfo::new(crate::components::command::scroll(&key_config)),
            CommandInfo::new(crate::components::command::filter(&key_config)),
        ]);
        assert_eq!(
            component.get_text(width),
            vec![
                Spans::from(Span::styled(
                    "-- General --",
                    Style::default().add_modifier(Modifier::REVERSED)
                )),
                Spans::from(Span::styled(
                    " Scroll up/down/left/right [k,j,h,l]  3",
                    Style::default().bg(Color::Rgb(0xea, 0x59, 0x0b))
                )),
                Spans::from(Span::styled(" Filter [/]  3", Style::default()))
            ]
        );
    }
```


Overlapping Code:
```
nfig = KeyConfig::default();
let mut component = HelpComponent::new(key_config.clone());
component.set_cmds(vec![
CommandInfo::new(crate::components::command::scroll(&key_config)),
CommandInfo::new(crate::components::command::filter(&key_config)),
]);
assert_eq!(
component.get_text(width),
vec![
Spans::from(Span::styled(
"-- General --",
Style::default().add_modifier(Modifier::REVERSED)
)),
Spans::from(Span::styled(
" Scroll up/down/left/right [k,j,h,l] 3",
Style::default().bg(Color::Rgb(0xea, 0x59, 0x0b))
)),
Spans::from(Span::styled(" Filter 
```
<Overlap Ratio: 0.8744038155802861>

---

--- 360 --
Question ID: 0d52db0b3e25e49604bd1717bb5bcfcb64e5db30_51
Original Code:
```
fn safe_integral_is_pos_policy_for_t<T>()
    where
        T: Integer + std::panic::RefUnwindSafe,
    {
        let val = SafeIntegral::<T>::magic_1();
        assert_eq!(val.is_pos(), true);

        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();
        assert_eq!(val.checked().is_pos(), true);

        let val = SafeIntegral::<T>::failure();
        assert_panics!(val.is_pos());

        let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();
        assert_panics!(val.is_pos());
    }
```


Overlapping Code:
```
policy_for_t<T>()
where
T: Integer + std::panic::RefUnwindSafe,
{
let val = SafeIntegral::<T>::magic_1();
assert_eq!(val.is_pos(), true);
let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();
assert_eq!(val.checked().is_pos(), true);
let val = SafeIntegral::<T>::failure();
assert_panics!(val.is_pos());
let val = SafeIntegral::<T>::magic_1() + SafeIntegral::<T>::magic_1();
assert_panics
```
<Overlap Ratio: 0.9060402684563759>

---

--- 361 --
Question ID: 008e114c66c0517e2af7501e3ada08ad0af373c7_0
Original Code:
```
fn try_main() -> Result<()> {
    let args = env::args_os()
        .skip(1)
        .map(PathBuf::from)
        .collect::<Vec<_>>();

    let (crate_path, bin_path, target_path) = match args[..] {
        [ref c, ref b, ref t] => (c, b, t),
        _ => bail!("Incorrect usage"),
    };

    Bundler::new_with_dir(bin_path, target_path.parent().unwrap(), crate_path)?
        .bundle(Path::new(target_path.file_name().unwrap()))?;

    Ok(())
}
```


Overlapping Code:
```
n try_main() -> Result<()> {
let args = env::args_os()
.skip(1)
.map(PathBuf::from)
.collect::<Vec<_>>();
let (crate_path, bin_path, target_path) = match args[..] {
[ref c, ref b, ref t] => (c, b, t),
_ => bail!("Incorrect usage"),
};
Bundler::new_with_dir(bin_path, target_path.parent().unwrap(), crate_path)?
.bundle(Path::new(target_path.file_name
```
<Overlap Ratio: 0.9333333333333333>

---

--- 362 --
Question ID: e6707d103a019faf494dc745d0c33600adf1b0d3_1
Original Code:
```
fn write_dummy_executable(executable_data_len: usize) -> Vec<u8> {
        let mut written_data = Vec::new();
        let executable_data = vec![0u8; executable_data_len];
        write_executable(
            &mut written_data,
            SegmentOffsetPtr::new(0, 0),
            &[],
            &executable_data,
        )
        .unwrap();
        written_data
    }
```


Overlapping Code:
```
e_dummy_executable(executable_data_len: usize) -> Vec<u8> {
let mut written_data = Vec::new();
let executable_data = vec![0u8; executable_data_len];
write_executable(
&mut written_data,
SegmentOffsetPtr::new(0, 0),
&[],
&executable_data,
)
.unwrap();
```
<Overlap Ratio: 0.9191176470588235>

---

--- 363 --
Question ID: 2d49d06763f3ae287a674af43441b543bcbfa1e2_77
Original Code:
```
fn bindgen_test_layout_lysp_node_choice__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<lysp_node_choice__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(lysp_node_choice__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<lysp_node_choice__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(lysp_node_choice__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<lysp_node_choice__bindgen_ty_1>())).node
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lysp_node_choice__bindgen_ty_1),
            "::",
            stringify!(node)
        )
    );
}
```


Overlapping Code:
```
sp_node_choice__bindgen_ty_1() {
assert_eq!(
::std::mem::size_of::<lysp_node_choice__bindgen_ty_1>(),
64usize,
concat!("Size of: ", stringify!(lysp_node_choice__bindgen_ty_1))
);
assert_eq!(
::std::mem::align_of::<lysp_node_choice__bindgen_ty_1>(),
8usize,
concat!("Alignment of ", stringify!(lysp_node_choice__bindgen_ty_1))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<lysp_node_choice__bindgen_ty_1>())).node
as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(lysp_node_choice__bind
```
<Overlap Ratio: 0.8867595818815331>

---

--- 364 --
Question ID: b57933639403c3b508e1442d15180d63b4b76bcf_223
Original Code:
```
fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_ClockRateAdjust_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_ClockRateAdjust_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! ( otherData )
                ));
}
```


Overlapping Code:
```
fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {
assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,
concat ! (
"Size of: " , stringify ! ( TPM20_ClockRateAdjust_Out ) ));
assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,
concat ! (
"Alignment of " , stringify ! ( TPM20_ClockRateAdjust_Out )
));
assert_eq! (unsafe {
& ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *
const _ as usize } , 0usize , concat ! (
"Alignment of field: " , stringify ! (
TPM20_ClockRateAdjust_Out ) , "::" , stringify ! ( tag ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
responseSize as * const _ as usize } , 4usize , concat ! (
"Alignment of field: " , stringify ! (
TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
responseSize ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
responseCode as * const _ as usize } , 8usize , concat ! (
"Alignment of field: " , stringify ! (
TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
responseCode ) ));
assert_eq! (unsafe {
& ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData
as * const _ as usize } , 12usize , concat ! (
"Alignment of field: " , stringify ! (
TPM20_ClockRateAdjust_Out ) , "::" , st
```
<Overlap Ratio: 0.9775888717156105>

---

--- 365 --
Question ID: a1fbd456fd2ee1579a62e2f316832dec00221fbc_6
Original Code:
```
async fn glob_leading_double_star() {
	let filterer = filt(&["**/possum"], &[], &[]).await;

	filterer.file_does_pass("possum");
	filterer.file_does_pass("foo/bar/possum");
	filterer.file_does_pass("/foo/bar/possum");
	filterer.dir_does_pass("possum");
	filterer.dir_does_pass("foo/bar/possum");
	filterer.dir_does_pass("/foo/bar/possum");
	filterer.file_doesnt_pass("rat");
	filterer.file_doesnt_pass("foo/bar/rat");
	filterer.file_doesnt_pass("/foo/bar/rat");
}
```


Overlapping Code:
```
ync fn glob_leading_double_star() {
let filterer = filt(&["**/possum"], &[], &[]).await;
filterer.file_does_pass("possum");
filterer.file_does_pass("foo/bar/possum");
filterer.file_does_pass("/foo/bar/possum");
filterer.dir_does_pass("possum");
filterer.dir_does_pass("foo/bar/possum");
filterer.dir_does_pass("/foo/bar/possum");
filterer.file_doesnt_pass("rat");
filterer.file_doesnt_pass("foo/bar/rat");
filterer.file_doesnt_pass("/foo/bar/rat");
}
```
<Overlap Ratio: 0.995575221238938>

---

--- 366 --
Question ID: 147ae9c3d24b2452deeee3ae7cfb094b5179fbd3_0
Original Code:
```
fn test_bit_field() {
        let mut gene = Gene::new(false, 16, false, 25, 1);
        assert_eq!(gene.get_source_type(), false);
        assert_eq!(gene.get_source_num(), 16);
        assert_eq!(gene.get_sink_type(), false);
        assert_eq!(gene.get_sink_num(), 25);

        gene.set_sink_num(99);
        gene.set_source_num(35);
        gene.set_sink_type(false);
        gene.set_source_type(true);
        assert_eq!(gene.get_source_type(), true);
        assert_eq!(gene.get_source_num(), 35);
        assert_eq!(gene.get_sink_type(), false);
        assert_eq!(gene.get_sink_num(), 99);
    }
```


Overlapping Code:
```
 {
let mut gene = Gene::new(false, 16, false, 25, 1);
assert_eq!(gene.get_source_type(), false);
assert_eq!(gene.get_source_num(), 16);
assert_eq!(gene.get_sink_type(), false);
assert_eq!(gene.get_sink_num(), 25);
gene.set_sink_num(99);
gene.set_source_num(35);
gene.set_sink_type(false);
gene.set_source_type(true);
assert_eq!(gene.get_source_type(), true);
assert_eq!(gene.get_source_num(), 35);
assert_eq!(gene.get_sink_type(), false);
assert_eq!(gene.get_sin
```
<Overlap Ratio: 0.9314516129032258>

---

--- 367 --
Question ID: 35328c4632ef130aef9ae4b25454f12a1bb664ff_0
Original Code:
```
async fn main() -> Result<()> {
    tracing_subscriber::fmt().with_env_filter("debug").init();

    let opts = Opts::parse();

    let id = Keypair::generate_ed25519();

    let endpoint_addr = Endpoint::new(TokioTcpConfig::new(), id, Duration::from_secs(20), [])
        .create(None)
        .spawn_global();

    let dialer_constructor = {
        let connect_addr = opts.multiaddr.clone();
        let endpoint_addr = endpoint_addr.clone();
        move || dialer::Actor::new(endpoint_addr.clone(), connect_addr.clone())
    };

    let (supervisor, _dialer_actor) = supervisor::Actor::with_policy(
        dialer_constructor,
        |_: &dialer::Error| true, // always restart dialer actor
    );
    let _dialer_supervisor = supervisor.create(None).spawn_global();

    sleep(Duration::from_secs(1)).await;

    let stream = endpoint_addr
        .send(OpenSubstream::single_protocol(
            PeerId::try_from_multiaddr(&opts.multiaddr).unwrap(),
            "/hello-world/1.0.0",
        ))
        .await
        .unwrap()
        .unwrap();

    let message = hello_world_dialer(stream, opts.name).await.unwrap();

    tracing::info!("{message}");

    Ok(())
}
```


Overlapping Code:
```
async fn main() -> Result<()> {
tracing_subscriber::fmt().with_env_filter("debug").init();
let opts = Opts::parse();
let id = Keypair::generate_ed25519();
let endpoint_addr = Endpoint::new(TokioTcpConfig::new(), id, Duration::from_secs(20), [])
.create(None)
.spawn_global();
let dialer_constructor = {
let connect_addr = opts.multiaddr.clone();
let endpoint_addr = endpoint_addr.clone();
move || dialer::Actor::new(endpoint_addr.clone(), connect_addr.clone())
};
let (supervisor, _dialer_actor) = supervisor::Actor::with_policy(
dialer_constructor,
|_: &dialer::Error| true, // always restart dialer actor
);
let _dialer_supervisor = supervisor.create(None).spawn_global();
sleep(Duration::from_secs(1)).await;
let stream = endpoint_addr
.send(OpenSubstream::single_protocol(
PeerId::try_from_multiaddr(&opts.multiaddr).unwrap(),
"/hello-world/1.0.0",
))
.await
.unwrap()
.unwrap();
let message = hello_world_dialer(stream, opts.name).await.unwrap();
```
<Overlap Ratio: 0.961577350859454>

---

--- 368 --
Question ID: f7a484fab27a88addb8effa8e14cecb648ba5243_2
Original Code:
```
fn todo_show_should_return_json() {
        let client = Client::tracked(quake_rocket()).expect("valid rocket instance");
        let mut response = client.get("/action/query?input=todo.show").dispatch();

        let mut res = "".to_string();
        let _ = response.read_to_string(&mut res);

        assert_eq!(response.status(), Status::Ok);
        assert_eq!(
            "{\"entry\":\"todo\",\"action\":\"show\",\"text\":\"\",\"parameters\":[]}",
            res
        );
    }
```


Overlapping Code:
```
ld_return_json() {
let client = Client::tracked(quake_rocket()).expect("valid rocket instance");
let mut response = client.get("/action/query?input=todo.show").dispatch();
let mut res = "".to_string();
let _ = response.read_to_string(&mut res);
assert_eq!(response.status(), Status::Ok);
assert_eq!(
"{\"entry\":\"todo\",\"action\":\"show\",\"text\":\"\",\"parameter
```
<Overlap Ratio: 0.912718204488778>

---

--- 369 --
Question ID: 39d5191dc6f2291cc6ce204de3f3872aac335526_17
Original Code:
```
pub async fn redrive_webhook_result(configuration: &configuration::Configuration, params: RedriveWebhookResultParams) -> Result<crate::models::WebhookRedriveResult, Error<RedriveWebhookResultError>> {
    // unbox the parameters
    let webhook_result_id = params.webhook_result_id;


    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/webhooks/results/{webhookResultId}/redrive", configuration.base_path, webhookResultId=webhook_result_id);
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_apikey) = configuration.api_key {
        let local_var_key = local_var_apikey.key.clone();
        let local_var_value = match local_var_apikey.prefix {
            Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
            None => local_var_key,
        };
        local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RedriveWebhookResultError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}
```


Overlapping Code:
```
webhook_result(configuration: &configuration::Configuration, params: RedriveWebhookResultParams) -> Result<crate::models::WebhookRedriveResult, Error<RedriveWebhookResultError>> {
// unbox the parameters
let webhook_result_id = params.webhook_result_id;
let local_var_client = &configuration.client;
let local_var_uri_str = format!("{}/webhooks/results/{webhookResultId}/redrive", configuration.base_path, webhookResultId=webhook_result_id);
let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());
if let Some(ref local_var_user_agent) = configuration.user_agent {
local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
}
if let Some(ref local_var_apikey) = configuration.api_key {
let local_var_key = local_var_apikey.key.clone();
let local_var_value = match local_var_apikey.prefix {
Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
None => local_var_key,
};
local_var_req_builder = local_var_req_builder.header("x-api-key", local_var_value);
};
let local_var_req = local_var_req_builder.build()?;
let local_var_resp = local_var_client.execute(local_var_req).await?;
let local_var_status = local_var_resp.status();
let local_var_content = local_var_resp.text().await?;
if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
serde_json::from_str(&local_var_content).map_err(Error::from)
} else {
let local_var_entity: Option<RedriveWebhookResultError> = serde_json::from_str(&local_var_content).ok();
let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
Err(Error::ResponseError(local_var_error))
}
}
```
<Overlap Ratio: 0.9878822850548182>

---

--- 370 --
Question ID: 8e3c03372106afa1014015c54d342a22614f5c76_1
Original Code:
```
fn special_whitespace() {
    let strings = ["\n", "\t", "foo\tbar", "baz\n"];

    for &s in &strings {
        let input = format!(r#"b"{}""#, s);
        let input_raw = format!(r#"br"{}""#, s);
        for (input, num_hashes) in vec![(input, None), (input_raw, Some(0))] {
            let expected = ByteStringLit {
                raw: &*input,
                value: None,
                num_hashes,
            };
            assert_parse_ok_eq(
                &input, ByteStringLit::parse(&*input), expected.clone(), "ByteStringLit::parse");
            assert_parse_ok_eq(
                &input, Literal::parse(&*input), Literal::ByteString(expected), "Literal::parse");
            assert_eq!(ByteStringLit::parse(&*input).unwrap().value(), s.as_bytes());
            assert_eq!(ByteStringLit::parse(&*input).unwrap().into_value(), s.as_bytes());
        }
    }

    let res = ByteStringLit::parse("br\"\r\"").expect("failed to parse");
    assert_eq!(res.value(), b"\r");
}
```


Overlapping Code:
```
fn special_whitespace() {
let strings = ["\n", "\t", "foo\tbar", "baz\n"];
for &s in &strings {
let input = format!(r#"b"{}""#, s);
let input_raw = format!(r#"br"{}""#, s);
for (input, num_hashes) in vec![(input, None), (input_raw, Some(0))] {
let expected = ByteStringLit {
raw: &*input,
value: None,
num_hashes,
};
assert_parse_ok_eq(
&input, ByteStringLit::parse(&*input), expected.clone(), "ByteStringLit::parse");
assert_parse_ok_eq(
&input, Literal::parse(&*input), Literal::ByteString(expected), "Literal::parse");
assert_eq!(ByteStringLit::parse(&*input).unwrap().value(), s.as_bytes());
assert_eq!(ByteStringLit::parse(&*input).unwrap().into_value(), s.as_bytes());
}
}
let res = ByteStringLit::parse("br\"\r\"").expect("failed to parse");
a
```
<Overlap Ratio: 0.959079283887468>

---

--- 371 --
Question ID: 2f38966370425f82e5df53f513685abc4f2a8e89_3
Original Code:
```
pub fn perform_transition_protection_in() {
    // Hack: In an actual implementation, this if condition is bad. You would want to do this unconditionally or with cmovs
    // But that's just engineering work
    if get_should_lfence_in() {
        unsafe {
            invoke_lfence();
        }
    }

    if get_should_flush_in() {
        unsafe {
            btb_flush();
        }
    }

    if get_should_switch_mpk_in() {
        // yes, this is mpk_allow_ALL_mem not "mpk_allow_SBX_mem"
        // sbx is restricted to access only sbx memory through software sandboxing
        // mpk is only to make sure the app doesn't get tricked to accessing sbx memory at an incorrect time
        mpk_allow_all_mem();
    }
}
```


Overlapping Code:
```
ition_protection_in() {
// Hack: In an actual implementation, this if condition is bad. You would want to do this unconditionally or with cmovs
// But that's just engineering work
if get_should_lfence_in() {
unsafe {
invoke_lfence();
}
}
if get_should_flush_in() {
unsafe {
btb_flush();
}
}
if get_should_switch_mpk_in() {
// yes, this is mpk_allow_ALL_mem not "mpk_allow_SBX_mem"
// sbx is restricted to access only sbx memory through software sandboxing
// mpk is only to make sure the app doesn't get tricked to accessing sbx memory at an incorrect time
mpk_a
```
<Overlap Ratio: 0.9351081530782029>

---

--- 372 --
Question ID: 4d5ced4fc1cad419ec89bdb5f0d025f006e6f814_0
Original Code:
```
pub fn build_program(instructions: Vec<String>) -> String {
    let mut out = String::from(
r###".syntax unified

.global main
.type main, %function
main:
"###);

    for line in instructions {
        out.push_str(&line);
        out.push('\n');
    }

    out.push_str(
r###"ldr lr, =0x444F4E45 @ "DONE"
.size main, . - main

.section .isr_vector, "a", %progbits
g_pfnVectors:
.word _stack_end
.word main

"###);

    return out;
}
```


Overlapping Code:
```
> String {
let mut out = String::from(
r###".syntax unified
.global main
.type main, %function
main:
"###);
for line in instructions {
out.push_str(&line);
out.push('\n');
}
out.push_str(
r###"ldr lr, =0x444F4E45 @ "DONE"
.size main, . - main
.section .isr_vector, "a", %progbits
g_pfnVectors:
.word 
```
<Overlap Ratio: 0.7672634271099744>

---

--- 373 --
Question ID: 366b24c4937caaf5198dfb7c4b26bbe44abf2ba0_6
Original Code:
```
fn leading_dot() {
    const LEADING_DOT: &str = ".111";

    lexer_test(LEADING_DOT, Single(Err(LexerError::LeadingDot(0, 0))));

    const LEADING_DOT_AFTER_SIGN: &str = "+.1111";

    lexer_test(
        LEADING_DOT_AFTER_SIGN,
        Single(Err(LexerError::LeadingDot(1, 1))),
    );
}
```


Overlapping Code:
```
: &str = ".111";
lexer_test(LEADING_DOT, Single(Err(LexerError::LeadingDot(0, 0))));
const LEADING_DOT_AFTER_SIGN: &str = "+.1111";
lexer_test(
LEADING_DOT_AFTER_SIGN,
Single(Err(LexerError::LeadingDot(1, 1))),
)
```
<Overlap Ratio: 0.8446215139442231>

---

--- 374 --
Question ID: a41e7912c8c8749475376f5140e743c9fc01b9e8_40
Original Code:
```
fn bindgen_test_layout_FriendsGetFollowerCount_t() {
	assert_eq!(
		::std::mem::size_of::<FriendsGetFollowerCount_t>(),
		16usize,
		concat!("Size of: ", stringify!(FriendsGetFollowerCount_t))
	);
	assert_eq!(
		::std::mem::align_of::<FriendsGetFollowerCount_t>(),
		4usize,
		concat!("Alignment of ", stringify!(FriendsGetFollowerCount_t))
	);
	assert_eq!(
		unsafe {
			&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_eResult as *const _ as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(FriendsGetFollowerCount_t),
			"::",
			stringify!(m_eResult)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_steamID as *const _ as usize
		},
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(FriendsGetFollowerCount_t),
			"::",
			stringify!(m_steamID)
		)
	);
	assert_eq!(
		unsafe {
			&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_nCount as *const _ as usize
		},
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(FriendsGetFollowerCount_t),
			"::",
			stringify!(m_nCount)
		)
	);
}
```


Overlapping Code:
```
FollowerCount_t() {
assert_eq!(
::std::mem::size_of::<FriendsGetFollowerCount_t>(),
16usize,
concat!("Size of: ", stringify!(FriendsGetFollowerCount_t))
);
assert_eq!(
::std::mem::align_of::<FriendsGetFollowerCount_t>(),
4usize,
concat!("Alignment of ", stringify!(FriendsGetFollowerCount_t))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_eResult as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(FriendsGetFollowerCount_t),
"::",
stringify!(m_eResult)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_steamID as *const _ as usize
},
4usize,
concat!(
"Offset of field: ",
stringify!(FriendsGetFollowerCount_t),
"::",
stringify!(m_steamID)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<FriendsGetFollowerCount_t>())).m_nCount as *const _ as usize
},
12usize,
concat!(
"Offset of field: ",
stringify!(FriendsGetFollowerCount_t),
"::",
stringify!(m_nCount)
)
)
```
<Overlap Ratio: 0.9634888438133874>

---

--- 375 --
Question ID: f92b6391027f0df4b8d36a70e78db5fd285ad730_10
Original Code:
```
async fn query_outside_projection_area_of_use_produces_empty_tiles() {
        let mut exe_ctx = MockExecutionContext::default();
        let query_ctx = MockQueryContext::default();

        let m = GdalMetaDataStatic {
            time: Some(TimeInterval::default()),
            params: GdalDatasetParameters {
                file_path: PathBuf::new(),
                rasterband_channel: 1,
                geo_transform: GdalDatasetGeoTransform {
                    origin_coordinate: (166_021.44, 9_329_005.188).into(),
                    x_pixel_size: (534_994.66 - 166_021.444) / 100.,
                    y_pixel_size: -9_329_005.18 / 100.,
                },
                width: 100,
                height: 100,
                file_not_found_handling: FileNotFoundHandling::NoData,
                no_data_value: Some(0.),
                properties_mapping: None,
                gdal_open_options: None,
                gdal_config_options: None,
            },
            result_descriptor: RasterResultDescriptor {
                data_type: RasterDataType::U8,
                spatial_reference: SpatialReference::new(SpatialReferenceAuthority::Epsg, 32636)
                    .into(),
                measurement: Measurement::Unitless,
                no_data_value: Some(0.),
            },
        };

        let id: DatasetId = InternalDatasetId::new().into();
        exe_ctx.add_meta_data(id.clone(), Box::new(m));

        exe_ctx.tiling_specification =
            TilingSpecification::new((0.0, 0.0).into(), [600, 600].into());

        let output_shape: GridShape2D = [1000, 1000].into();
        let output_bounds =
            SpatialPartition2D::new_unchecked((-180., 0.).into(), (180., -90.).into());
        let time_interval = TimeInterval::new_instant(1_388_534_400_000).unwrap(); // 2014-01-01

        let gdal_op = GdalSource {
            params: GdalSourceParameters {
                dataset: id.clone(),
            },
        }
        .boxed();

        let initialized_operator = RasterOperator::boxed(Reprojection {
            params: ReprojectionParams {
                target_spatial_reference: SpatialReference::epsg_4326(),
            },
            sources: SingleRasterOrVectorSource {
                source: gdal_op.into(),
            },
        })
        .initialize(&exe_ctx)
        .await
        .unwrap();

        let x_query_resolution = output_bounds.size_x() / output_shape.axis_size_x() as f64;
        let y_query_resolution = output_bounds.size_y() / (output_shape.axis_size_y()) as f64;
        let spatial_resolution =
            SpatialResolution::new_unchecked(x_query_resolution, y_query_resolution);

        let qp = initialized_operator
            .query_processor()
            .unwrap()
            .get_u8()
            .unwrap();

        let result = qp
            .raster_query(
                QueryRectangle {
                    spatial_bounds: output_bounds,
                    time_interval,
                    spatial_resolution,
                },
                &query_ctx,
            )
            .await
            .unwrap()
            .map(Result::unwrap)
            .collect::<Vec<_>>()
            .await;

        assert_eq!(result.len(), 4);

        for r in result {
            assert!(r.is_empty());
        }
    }
```


Overlapping Code:
```
ync fn query_outside_projection_area_of_use_produces_empty_tiles() {
let mut exe_ctx = MockExecutionContext::default();
let query_ctx = MockQueryContext::default();
let m = GdalMetaDataStatic {
time: Some(TimeInterval::default()),
params: GdalDatasetParameters {
file_path: PathBuf::new(),
rasterband_channel: 1,
geo_transform: GdalDatasetGeoTransform {
origin_coordinate: (166_021.44, 9_329_005.188).into(),
x_pixel_size: (534_994.66 - 166_021.444) / 100.,
y_pixel_size: -9_329_005.18 / 100.,
},
width: 100,
height: 100,
file_not_found_handling: FileNotFoundHandling::NoData,
no_data_value: Some(0.),
properties_mapping: None,
gdal_open_options: None,
gdal_config_options: None,
},
result_descriptor: RasterResultDescriptor {
data_type: RasterDataType::U8,
spatial_reference: SpatialReference::new(SpatialReferenceAuthority::Epsg, 32636)
.into(),
measurement: Measurement::Unitless,
no_data_value: Some(0.),
},
};
let id: DatasetId = InternalDatasetId::new().into();
exe_ctx.add_meta_data(id.clone(), Box::new(m));
exe_ctx.tiling_specification =
TilingSpecification::new((0.0, 0.0).into(), [600, 600].into());
let output_shape: GridShape2D = [1000, 1000].into();
let output_bounds =
SpatialPartition2D::new_unchecked((-180., 0.).into(), (180., -90.).into());
let time_interval = TimeInterval::new_instant(1_388_534_400_000).unwrap(); // 2014-01-01
let gdal_op = GdalSource {
params: GdalSourceParameters {
dataset: id.clone(),
},
}
.boxed();
let initialized_operator = RasterOperator::boxed(Reprojection {
params: ReprojectionParams {
target_spatial_reference: SpatialReference::epsg_4326(),
},
sources: SingleRasterOrVectorSource {
source: gdal_op.into(),
},
})
.initialize(&exe_ctx)
.await
.unwrap();
let x_query_resolution = output_bounds.size_x() / output_shape.axis_size_x() as f64;
let y_query
```
<Overlap Ratio: 0.995575221238938>

---

--- 376 --
Question ID: c39f066f8958f23479aabe6f8d70e6bab13226e2_0
Original Code:
```
fn test_etag() {
    use headers::test_utils::{assert_conversion_correct, assert_interpretation_correct,
                              assert_invalid};
    assert_conversion_correct("\"\"", strong_etag(""));
    assert_conversion_correct("\"fO0\"", strong_etag("fO0"));
    assert_conversion_correct("\"fO0 bar\"", strong_etag("fO0 bar"));
    assert_conversion_correct("\"fO0 \\\"bar\"", strong_etag("fO0 \"bar"));
    assert_conversion_correct("\"fO0 \\\"bar\\\"\"", strong_etag("fO0 \"bar\""));

    assert_conversion_correct("W/\"\"", weak_etag(""));
    assert_conversion_correct("W/\"fO0\"", weak_etag("fO0"));
    assert_conversion_correct("W/\"fO0 bar\"", weak_etag("fO0 bar"));
    assert_conversion_correct("W/\"fO0 \\\"bar\"", weak_etag("fO0 \"bar"));
    assert_conversion_correct("W/\"fO0 \\\"bar\\\"\"", weak_etag("fO0 \"bar\""));
    assert_interpretation_correct("w/\"fO0\"", weak_etag("fO0"));

    assert_invalid::<EntityTag>("");
    assert_invalid::<EntityTag>("fO0");
    assert_invalid::<EntityTag>("\"\\\"");
    assert_invalid::<EntityTag>("\"\"\"\"");
}
```


Overlapping Code:
```
etag() {
use headers::test_utils::{assert_conversion_correct, assert_interpretation_correct,
assert_invalid};
assert_conversion_correct("\"\"", strong_etag(""));
assert_conversion_correct("\"fO0\"", strong_etag("fO0"));
assert_conversion_correct("\"fO0 bar\"", strong_etag("fO0 bar"));
assert_conversion_correct("\"fO0 \\\"bar\"", strong_etag("fO0 \"bar"));
assert_conversion_correct("\"fO0 \\\"bar\\\"\"", strong_etag("fO0 \"bar\""));
assert_conversion_correct("W/\"\"", weak_etag(""));
assert_conversion_correct("W/\"fO0\"", weak_etag("fO0"));
assert_conversion_correct("W/\"fO0 bar\"", weak_etag("fO0 bar"));
assert_conversion_correct("W/\"fO0 \\\"bar\"", weak_etag("fO0 \"bar"));
assert_conversion_correct("W/\"fO0 \\\"bar\\\"\"", weak_etag("fO0 \"bar\""));
assert_interpretation_correct("w/\"fO0\"", weak_etag("fO0"));
assert_invalid::<EntityTag>("");
assert_invalid::<EntityTag>("fO0");
assert_invalid::<EntityTag>("\"\\\"");
assert_invalid::<E
```
<Overlap Ratio: 0.9674134419551935>

---

--- 377 --
Question ID: f8edc3625e0ab079ee306a10a74bde260643695c_1
Original Code:
```
fn number_of_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {
    #[rustfmt::skip]
    const TABLE: [u16; 65] = [
        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,
        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,
        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,
        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,
        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,
        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,
    ];
    #[rustfmt::skip]
    const TABLE_POW5: [u8; 0x051C] = [
        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,
        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,
        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,
        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,
        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,
        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,
        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,
        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,
        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,
        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,
        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,
        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,
        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,
        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,
        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,
        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,
        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,
        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,
        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,
        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,
        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,
        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,
        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,
        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,
        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,
        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,
        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,
        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,
        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,
        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,
        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,
        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,
        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,
        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,
        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,
        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,
        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,
        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,
        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,
        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,
        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,
        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,
        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,
        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,
    ];

    shift &= 63;
    let x_a = TABLE[shift];
    let x_b = TABLE[shift + 1];
    let num_new_digits = (x_a >> 11) as _;
    let pow5_a = (0x7FF & x_a) as usize;
    let pow5_b = (0x7FF & x_b) as usize;
    let pow5 = &TABLE_POW5[pow5_a..];
    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {
        if i >= d.num_digits {
            return num_new_digits - 1;
        } else if d.digits[i] == p5 {
            continue;
        } else if d.digits[i] < p5 {
            return num_new_digits - 1;
        } else {
            return num_new_digits;
        }
    }
    num_new_digits
}
```


Overlapping Code:
```
f_digits_decimal_left_shift(d: &Decimal, mut shift: usize) -> usize {
#[rustfmt::skip]
const TABLE: [u16; 65] = [
0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,
0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,
0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,
0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,
0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,
0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,
];
#[rustfmt::skip]
const TABLE_POW5: [u8; 0x051C] = [
5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,
9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,
1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,
5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,
9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,
6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,
1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,
4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,
4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,
3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,
2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,
4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,
5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,
3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,
6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,
1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,
6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,
6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5,
```
<Overlap Ratio: 0.9925634295713036>

---

--- 378 --
Question ID: 89eedd9db8eec7a8c9a9770825d0b041b0616466_0
Original Code:
```
fn derive_field(seed_hex: &[u8; 64], suffix: &[u8]) -> Field {
    let mut hasher = Sha256::new();
    hasher.update(seed_hex);
    hasher.update(suffix);
    Field::from_be_bytes_mod_order(hasher.finalize().as_ref())
}
```


Overlapping Code:
```
ive_field(seed_hex: &[u8; 64], suffix: &[u8]) -> Field {
let mut hasher = Sha256::new();
hasher.update(seed_hex);
hasher.update(suffix);
Field::from_b
```
<Overlap Ratio: 0.7389162561576355>

---

--- 379 --
Question ID: c314c25f00a350d2358a769a61cb28fe5d3be57f_0
Original Code:
```
async fn should_get_service_graph() {
    let client = XRayClient::new(Region::UsEast1);

    let time = (OffsetDateTime::now_utc().unix_timestamp() - 30) as f64; // 30 seconds in the past
    println!("{:?}", time);

    let request = GetServiceGraphRequest {
        start_time: time - 600.0,
        end_time: time,
        ..Default::default()
    };

    let result = client.get_service_graph(request).await;
    println!("{:#?}", result);
    result.unwrap();
}
```


Overlapping Code:
```
 fn should_get_service_graph() {
let client = XRayClient::new(Region::UsEast1);
let time = (OffsetDateTime::now_utc().unix_timestamp() - 30) as f64; // 30 seconds in the past
println!("{:?}", time);
let request = GetServiceGraphRequest {
start_time: time - 600.0,
end_time: time,
..Default::default()
};
let result = client.get_service_graph(request).await;
println!("{:#?}", result);
result.unwrap()
```
<Overlap Ratio: 0.9803921568627451>

---

--- 380 --
Question ID: a20411a6bb3d23bb6b558c1a248eb567801b08d1_0
Original Code:
```
fn fetch_markets_raw() -> Vec<FtxMarket> {
    let txt = http_get("https://ftx.com/api/markets").unwrap();
    let resp = serde_json::from_str::<Response>(&txt).unwrap();
    assert!(resp.success);
    resp.result
}
```


Overlapping Code:
```
rket> {
let txt = http_get("https://ftx.com/api/markets").unwrap();
let resp = serde_json::from_str::<Response>(&txt).unwrap();
assert!(resp.success);
```
<Overlap Ratio: 0.7537688442211056>

---

--- 381 --
Question ID: fc93fb4e66d6b5b349a44ebf4b801f4fa091f217_7
Original Code:
```
fn unexpected_directive_invalid() {
    let input = include_str!("relay_resolvers/fixtures/unexpected-directive.invalid.graphql");
    let expected = include_str!("relay_resolvers/fixtures/unexpected-directive.invalid.expected");
    test_fixture(transform_fixture, "unexpected-directive.invalid.graphql", "relay_resolvers/fixtures/unexpected-directive.invalid.expected", input, expected);
}
```


Overlapping Code:
```
invalid() {
let input = include_str!("relay_resolvers/fixtures/unexpected-directive.invalid.graphql");
let expected = include_str!("relay_resolvers/fixtures/unexpected-directive.invalid.expected");
test_fixture(transform_fixture, "unexpected-directive.invalid.graphql", "relay_resolvers/fixtures/unexpected-directive.invalid.
```
<Overlap Ratio: 0.8575197889182058>

---

--- 382 --
Question ID: 53f29da9eca021b6f01792987ac8a7ae218489dd_4
Original Code:
```
async fn test_ttl_index() {
    test_setup();
    let collection_name = "test_collection";
    let index_name = "idx_ttl_test";
    let conn = connection().await;

    let database = conn.db("test_db").await.unwrap();

    let index = Index::builder()
        .name(index_name)
        .fields(vec!["password".to_string()])
        .settings(IndexSettings::Ttl { expire_after: 500 })
        .build();

    let index = database
        .create_index(collection_name, &index)
        .await
        .unwrap();

    let delete_result = database.delete_index(&index.id).await.unwrap();

    assert!(index.id.len() > 0);
    assert_eq!(index.name, index_name.to_string());
    assert_eq!(delete_result.id, index.id);

    if let IndexSettings::Ttl { expire_after } = index.settings {
        assert_eq!(expire_after, 500);
    }
}
```


Overlapping Code:
```
st_ttl_index() {
test_setup();
let collection_name = "test_collection";
let index_name = "idx_ttl_test";
let conn = connection().await;
let database = conn.db("test_db").await.unwrap();
let index = Index::builder()
.name(index_name)
.fields(vec!["password".to_string()])
.settings(IndexSettings::Ttl { expire_after: 500 })
.build();
let index = database
.create_index(collection_name, &index)
.await
.unwrap();
let delete_result = database.delete_index(&index.id).await.unwrap();
assert!(index.id.len() > 0);
assert_eq!(index.name, index_name.to_string());
assert_eq!(delete_result.id, index.id);
if let IndexSettings::Ttl { expire_after } = index.se
```
<Overlap Ratio: 0.9232954545454546>

---

--- 383 --
Question ID: a1d42519f4c63b218250cf7687a8c47f28ca2ec4_1
Original Code:
```
unsafe fn find_unused_key_code(
    display: *mut ffi::Display,
    min_keycode: ffi::KeyCode,
    max_keycode: ffi::KeyCode,
) -> Result<ffi::KeyCode, Error> {

    // Get the full mapping from keycodes to keysyms. There may be
    // multiple keysyms for each keycode depending on which modifiers
    // are pressed. We need this for finding an unused keycode, that is
    // a keycode without any associated keysyms.
    let keycode_count = (max_keycode - min_keycode) + 1;
    let mut keysyms_per_keycode = 0;
    let keysyms = ffi::XGetKeyboardMapping(
        display,
        min_keycode,
        keycode_count as std::os::raw::c_int,
        &mut keysyms_per_keycode,
    );
    if keysyms.is_null() {
        return Err(Error::Platform(PlatformError::XGetKeyboardMapping));
    }
    let keysyms_per_keycode = keysyms_per_keycode as usize;

    // Find a keycode that has no keysyms associated with it. This keycode will
    // be used for remapping for the purpose of producing characters that aren't
    // on the default keyboard layout.
    for code_idx in 0..keycode_count {
        let sym_idx = code_idx as usize * keysyms_per_keycode;
        let slice = std::slice::from_raw_parts(
            keysyms.add(sym_idx), keysyms_per_keycode
        );
        if slice.iter().all(|keysym| *keysym == ffi::NoSymbol) {
            ffi::XFree(keysyms);
            return Ok(code_idx + min_keycode);
        }
    }

    ffi::XFree(keysyms);
    Err(Error::Platform(PlatformError::NoUnusedKeyCode))
}
```


Overlapping Code:
```
y_code(
display: *mut ffi::Display,
min_keycode: ffi::KeyCode,
max_keycode: ffi::KeyCode,
) -> Result<ffi::KeyCode, Error> {
// Get the full mapping from keycodes to keysyms. There may be
// multiple keysyms for each keycode depending on which modifiers
// are pressed. We need this for finding an unused keycode, that is
// a keycode without any associated keysyms.
let keycode_count = (max_keycode - min_keycode) + 1;
let mut keysyms_per_keycode = 0;
let keysyms = ffi::XGetKeyboardMapping(
display,
min_keycode,
keycode_count as std::os::raw::c_int,
&mut keysyms_per_keycode,
);
if keysyms.is_null() {
return Err(Error::Platform(PlatformError::XGetKeyboardMapping));
}
let keysyms_per_keycode = keysyms_per_keycode as usize;
// Find a keycode that has no keysyms associated with it. This keycode will
// be used for remapping for the purpose of producing characters that aren't
// on the default keyboard layout.
for code_idx in 0..keycode_count {
let sym_idx = code_idx as usize * keysyms_per_keycode;
let slice = std::slice::from_raw_parts(
keysyms.add(sym_idx), keysyms_per_keycode
);
if slice.iter().all(|keysym| *keysym == ffi::NoSymbol) {
ffi::XFree(keysyms);
return Ok(code_idx + min_keycode);
}
}
ffi::XFree(keysyms);
Err(Error::Platform(P
```
<Overlap Ratio: 0.9563886763580719>

---

