--- 0 --
Question ID: 7e83519156b98ea9cffe6fd01cbd116d45fc3197
Original Code:
```
public class SecretsManagerSample {

    public static void getSecret(String secretName, String region) {
        String endpoint =("secretsmanager." + region + ".amazonaws.com");
        AwsClientBuilder.EndpointConfiguration config = new AwsClientBuilder.EndpointConfiguration(endpoint, region);
        AWSSecretsManagerClientBuilder clientBuilder = AWSSecretsManagerClientBuilder.standard();
        clientBuilder.setEndpointConfiguration(config);
        AWSSecretsManager client = clientBuilder.build();
        String secret = null;
        ByteBuffer binarySecretData;
        GetSecretValueRequest getSecretValueRequest = new GetSecretValueRequest().withSecretId(secretName);
        GetSecretValueResult getSecretValueResponse = null;
        try {
            getSecretValueResponse = client.getSecretValue(getSecretValueRequest);

        } catch(ResourceNotFoundException e) {
            System.out.println("The requested secret " + secretName + " was not found");
        } catch (InvalidRequestException e) {
            System.out.println("The request was invalid due to: " + e.getMessage());
        } catch (InvalidParameterException e) {
            System.out.println("The request had invalid params: " + e.getMessage());
        }

        if(getSecretValueResponse == null) {
            return;
        }

        // Decrypted secret using the associated KMS CMK
        // Depending on whether the secret was a string or binary, one of these fields will be populated
        if(getSecretValueResponse.getSecretString() != null) {
            secret = getSecretValueResponse.getSecretString();
        }
        else {
            binarySecretData = getSecretValueResponse.getSecretBinary();
        }

        // Your code goes here.
        System.out.println("Secret Name : " + secretName + "\t Secret Value : " + secret + "\n");
    }
    public static void main(String[] args) throws IOException {
        // Call the program with maven as mvn clean compile exec:java -Dexec.mainClass=com.amazonaws.samples.KMSEncryptionSample -Dexec.args="arg1 arg2"
        try {
            System.out.println("Retreiving Secrets based on the secret id and region entered as command line arguements: \n");
            SecretsManagerSample.getSecret(args[0], args[1]);
        } catch (AmazonServiceException ase) {
            System.out.println("Caught an AmazonServiceException, which means your request made it "
                    + "to Amazon AWS, but was rejected with an error response for some reason.");
            System.out.println("Error Message:    " + ase.getMessage());
            System.out.println("HTTP Status Code: " + ase.getStatusCode());
            System.out.println("AWS Error Code:   " + ase.getErrorCode());
            System.out.println("Error Type:       " + ase.getErrorType());
            System.out.println("Request ID:       " + ase.getRequestId());
        } catch (AmazonClientException ace) {
            System.out.println("Caught an AmazonClientException, which means the client encountered "
                    + "a serious internal problem while trying to communicate with AWS, "
                    + "such as not being able to access the network.");
            System.out.println("Error Message: " + ace.getMessage());
        }
    }
}
```


Overlapping Code:
```
etsManagerSample {
public static void getSecret(String secretName, String region) {
String endpoint =("secretsmanager." + region + ".amazonaws.com");
AwsClientBuilder.EndpointConfiguration config = new AwsClientBuilder.EndpointConfiguration(endpoint, region);
AWSSecretsManagerClientBuilder clientBuilder = AWSSecretsManagerClientBuilder.standard();
clientBuilder.setEndpointConfiguration(config);
AWSSecretsManager client = clientBuilder.build();
String secret = null;
ByteBuffer binarySecretData;
GetSecretValueRequest getSecretValueRequest = new GetSecretValueRequest().withSecretId(secretName);
GetSecretValueResult getSecretValueResponse = null;
try {
getSecretValueResponse = client.getSecretValue(getSecretValueRequest);
} catch(ResourceNotFoundException e) {
System.out.println("The requested secret " + secretName + " was not found");
} catch (InvalidRequestException e) {
System.out.println("The request was invalid due to: " + e.getMessage());
} catch (InvalidParameterException e) {
System.out.println("The request had invalid params: " + e.getMessage());
}
if(getSecretValueResponse == null) {
return;
}
// Decrypted secret using the associated KMS CMK
// Depending on whether the secret was a string or binary, one of these fields will be populated
if(getSecretValueResponse.getSecretString() != null) {
secret = getSecretValueResponse.getSecretString();
}
else {
binarySecretData = getSecretValueResponse.getSecretBinary();
}
// Your code goes here.
System.out.println("Secret Name : " + secretName + "\t Secret Value : " + secret + "\n");
}
public static void main(String[] args) throws IOException {
// Call the program with maven as mvn clean compile exec:java -Dexec.mainClass=com.amazonaws.samples.KMSEncryptionSample -Dexec.args="arg1 arg2"
try {
System.out.println("Retreiving Secrets based on the secret id and region entered as command line arguements: \n");
SecretsManagerSample.getSecret(args[0], args[1]);
} catch (AmazonServiceException ase) {
System.out.println("Caught an AmazonServiceException, which means your request made it "
+ "to Amazon AWS, but was rejected with
```
<Overlap Ratio: 0.9877704609595485>

---

--- 1 --
Question ID: 1a239330996bab460acc01363c394b0c03d796e4
Original Code:
```
public class PutTransformAction extends ActionType<AcknowledgedResponse> {

    public static final PutTransformAction INSTANCE = new PutTransformAction();
    public static final String NAME = "cluster:admin/transform/put";

    private static final TimeValue MIN_FREQUENCY = TimeValue.timeValueSeconds(1);
    private static final TimeValue MAX_FREQUENCY = TimeValue.timeValueHours(1);

    private PutTransformAction() {
        super(NAME, AcknowledgedResponse::new);
    }

    public static class Request extends AcknowledgedRequest<Request> {

        private final TransformConfig config;
        private final boolean deferValidation;

        public Request(TransformConfig config, boolean deferValidation) {
            this.config = config;
            this.deferValidation = deferValidation;
        }

        public Request(StreamInput in) throws IOException {
            super(in);
            this.config = new TransformConfig(in);
            if (in.getVersion().onOrAfter(Version.V_7_4_0)) {
                this.deferValidation = in.readBoolean();
            } else {
                this.deferValidation = false;
            }
        }

        public static Request fromXContent(final XContentParser parser, final String id, final boolean deferValidation) {
            return new Request(TransformConfig.fromXContent(parser, id, false), deferValidation);
        }

        /**
         * More complex validations with how {@link TransformConfig#getDestination()} and
         * {@link TransformConfig#getSource()} relate are done in the transport handler.
         */
        @Override
        public ActionRequestValidationException validate() {
            ActionRequestValidationException validationException = null;

            validationException = config.validate(validationException);
            validationException = SourceDestValidator.validateRequest(validationException, config.getDestination().getIndex());

            if (TransformStrings.isValidId(config.getId()) == false) {
                validationException = addValidationError(
                    TransformMessages.getMessage(TransformMessages.INVALID_ID, TransformField.ID.getPreferredName(), config.getId()),
                    validationException
                );
            }
            if (TransformStrings.hasValidLengthForId(config.getId()) == false) {
                validationException = addValidationError(
                    TransformMessages.getMessage(TransformMessages.ID_TOO_LONG, TransformStrings.ID_LENGTH_LIMIT),
                    validationException
                );
            }
            TimeValue frequency = config.getFrequency();
            if (frequency != null) {
                if (frequency.compareTo(MIN_FREQUENCY) < 0) {
                    validationException = addValidationError(
                        "minimum permitted [" + TransformField.FREQUENCY + "] is [" + MIN_FREQUENCY.getStringRep() + "]",
                        validationException
                    );
                } else if (frequency.compareTo(MAX_FREQUENCY) > 0) {
                    validationException = addValidationError(
                        "highest permitted [" + TransformField.FREQUENCY + "] is [" + MAX_FREQUENCY.getStringRep() + "]",
                        validationException
                    );
                }
            }

            return validationException;
        }

        public TransformConfig getConfig() {
            return config;
        }

        public boolean isDeferValidation() {
            return deferValidation;
        }

        @Override
        public void writeTo(StreamOutput out) throws IOException {
            super.writeTo(out);
            this.config.writeTo(out);
            if (out.getVersion().onOrAfter(Version.V_7_4_0)) {
                out.writeBoolean(this.deferValidation);
            }
        }

        @Override
        public int hashCode() {
            return Objects.hash(config, deferValidation);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            Request other = (Request) obj;
            return Objects.equals(config, other.config) && this.deferValidation == other.deferValidation;
        }
    }

}
```


Overlapping Code:
```
nsformAction extends ActionType<AcknowledgedResponse> {
public static final PutTransformAction INSTANCE = new PutTransformAction();
public static final String NAME = "cluster:admin/transform/put";
private static final TimeValue MIN_FREQUENCY = TimeValue.timeValueSeconds(1);
private static final TimeValue MAX_FREQUENCY = TimeValue.timeValueHours(1);
private PutTransformAction() {
super(NAME, AcknowledgedResponse::new);
}
public static class Request extends AcknowledgedRequest<Request> {
private final TransformConfig config;
private final boolean deferValidation;
public Request(TransformConfig config, boolean deferValidation) {
this.config = config;
this.deferValidation = deferValidation;
}
public Request(StreamInput in) throws IOException {
super(in);
this.config = new TransformConfig(in);
if (in.getVersion().onOrAfter(Version.V_7_4_0)) {
this.deferValidation = in.readBoolean();
} else {
this.deferValidation = false;
}
}
public static Request fromXContent(final XContentParser parser, final String id, final boolean deferValidation) {
return new Request(TransformConfig.fromXContent(parser, id, false), deferValidation);
}
/**
* More complex validations with how {@link TransformConfig#getDestination()} and
* {@link TransformConfig#getSource()} relate are done in the transport handler.
*/
@Override
public ActionRequestValidationException validate() {
ActionRequestValidationException validationException = null;
validationException = config.validate(validationException);
validationException = SourceDestValidator.validateRequest(validationException, config.getDestination().getIndex());
if (TransformStrings.isValidId(config.getId()) == false) {
validationException = addValidationError(
TransformMessages.getMessage(TransformMessages.INVALID_ID, TransformField.ID.getPreferredName(), config.getId()),
validationException
);
}
if (TransformStrings.hasValidLengthForId(config.getId()) == false) {
validationException = addValidationError(
TransformMe
```
<Overlap Ratio: 0.9689502217841302>

---

--- 2 --
Question ID: 8759ef0f0dd054f4346589ace19221ee48f69f33
Original Code:
```
public class DwpItemContextMenuHandler extends AbstractItemContextMenuHandler
{
    // Initialization flag.
    boolean m_isInitialized = false;

	/**
     * The default constructor.
     */
    public DwpItemContextMenuHandler()
    {
        super();
    }

	/**
	 * Initialize the handler.
	 * <p>
	 * This must be called prior to getting the context menu.
	 * </p>
	 * 
	 * @param viewer The <code>AttributeTreeViewer</code> that will use the
	 * context menu.
	 */
	public void init(AttributeTreeViewer viewer)
	{
	    super.init(viewer);
		super.createContextMenu();
		m_isInitialized = true;
	}

	/**
	 * Get a context <code>Menu</code> for the specified <code>IAttribute</code>.
	 * 
	 * @param attribute The <code>IAttribute</code> to create a context menu for.
	 * 
	 * @return A reference to a <code>Menu</code> is returned.
	 * 
     * @see com.wizzer.mle.studio.framework.ui.IAttributeContextMenuHandler#getContextMenu(com.wizzer.mle.studio.framework.attribute.IAttribute, com.wizzer.mle.studio.framework.ui.AttributeTreeViewer)
     */
    public Menu getContextMenu(IAttribute attribute, AttributeTreeViewer viewer)
    {
        // Initialize the menu, if necessary.
        if (! m_isInitialized)
            init(viewer);
        
        // Return the context menu.
        return m_popupMenu;
    }

}
```


Overlapping Code:
```
mContextMenuHandler extends AbstractItemContextMenuHandler
{
// Initialization flag.
boolean m_isInitialized = false;
/**
* The default constructor.
*/
public DwpItemContextMenuHandler()
{
super();
}
/**
* Initialize the handler.
* <p>
* This must be called prior to getting the context menu.
* </p>
* 
* @param viewer The <code>AttributeTreeViewer</code> that will use the
* context menu.
*/
public void init(AttributeTreeViewer viewer)
{
super.init(viewer);
super.createContextMenu();
m_isInitialized = true;
}
/**
* Get a context <code>Menu</code> for the specified <code>IAttribute</code>.
* 
* @param attribute The <code>IAttribute</code> to create a context menu for.
* 
* @return A reference to a <code>Menu</code> is returned.
* 
* @see com.wizzer.mle.studio.framework.ui.IAttributeContextMenuHandler#getContextMenu(com.wizzer.mle.studio.framework.attribute.IAttribute, com.wizzer.mle.studio.framework.ui.AttributeTreeViewer)
*/
public Menu getContextMenu(IAttribute attribute, AttributeTreeViewer viewer)
{
// Initialize the menu, if necessary.
if (! m_isInitialized)
init(viewer);

// Retur
```
<Overlap Ratio: 0.9466437177280551>

---

--- 3 --
Question ID: 88393beba770a5b7c52d1c075589065f964bc5c6
Original Code:
```
class JSSESupport implements SSLSupport, SSLSessionManager {

    private static final org.apache.juli.logging.Log log =
        org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);

    private static final StringManager sm =
        StringManager.getManager("org.apache.tomcat.util.net.jsse.res");

    private static final Map<SSLSession,Integer> keySizeCache =
            new WeakHashMap<>();

    protected SSLSocket ssl;
    protected SSLSession session;

    Listener listener = new Listener();

    JSSESupport(SSLSocket sock){
        ssl=sock;
        session = sock.getSession();
        sock.addHandshakeCompletedListener(listener);
    }

    JSSESupport(SSLSession session) {
        this.session = session;
    }

    @Override
    public String getCipherSuite() throws IOException {
        // Look up the current SSLSession
        if (session == null)
            return null;
        return session.getCipherSuite();
    }

    @Override
    public Object[] getPeerCertificateChain()
        throws IOException {
        return getPeerCertificateChain(false);
    }

    protected java.security.cert.X509Certificate [] getX509Certificates(
            SSLSession session) {
        Certificate [] certs=null;
        try {
            certs = session.getPeerCertificates();
        } catch( Throwable t ) {
            log.debug(sm.getString("jsseSupport.clientCertError"), t);
            return null;
        }
        if( certs==null ) return null;

        java.security.cert.X509Certificate [] x509Certs =
            new java.security.cert.X509Certificate[certs.length];
        for(int i=0; i < certs.length; i++) {
            if (certs[i] instanceof java.security.cert.X509Certificate ) {
                // always currently true with the JSSE 1.1.x
                x509Certs[i] = (java.security.cert.X509Certificate) certs[i];
            } else {
                try {
                    byte [] buffer = certs[i].getEncoded();
                    CertificateFactory cf =
                        CertificateFactory.getInstance("X.509");
                    ByteArrayInputStream stream =
                        new ByteArrayInputStream(buffer);
                    x509Certs[i] = (java.security.cert.X509Certificate)
                            cf.generateCertificate(stream);
                } catch(Exception ex) {
                    log.info(sm.getString(
                            "jseeSupport.certTranslationError", certs[i]), ex);
                    return null;
                }
            }
            if(log.isTraceEnabled())
                log.trace("Cert #" + i + " = " + x509Certs[i]);
        }
        if(x509Certs.length < 1)
            return null;
        return x509Certs;
    }

    @Override
    public Object[] getPeerCertificateChain(boolean force)
        throws IOException {
        // Look up the current SSLSession
        if (session == null)
            return null;

        // Convert JSSE's certificate format to the ones we need
        X509Certificate [] jsseCerts = null;
        try {
            jsseCerts = session.getPeerCertificateChain();
        } catch(Exception bex) {
            // ignore.
        }
        if (jsseCerts == null)
            jsseCerts = new X509Certificate[0];
        if(jsseCerts.length <= 0 && force && ssl != null) {
            session.invalidate();
            handShake();
            session = ssl.getSession();
        }
        return getX509Certificates(session);
    }

    protected void handShake() throws IOException {
        if( ssl.getWantClientAuth() ) {
            log.debug(sm.getString("jsseSupport.noCertWant"));
        } else {
            ssl.setNeedClientAuth(true);
        }

        if (ssl.getEnabledCipherSuites().length == 0) {
            // Handshake is never going to be successful.
            // Assume this is because handshakes are disabled
            log.warn(sm.getString("jsseSupport.serverRenegDisabled"));
            session.invalidate();
            ssl.close();
            return;
        }

        InputStream in = ssl.getInputStream();
        int oldTimeout = ssl.getSoTimeout();
        ssl.setSoTimeout(1000);
        byte[] b = new byte[1];
        listener.reset();
        ssl.startHandshake();
        int maxTries = 60; // 60 * 1000 = example 1 minute time out
        for (int i = 0; i < maxTries; i++) {
            if (log.isTraceEnabled())
                log.trace("Reading for try #" + i);
            try {
                int read = in.read(b);
                if (read > 0) {
                    // Shouldn't happen as all input should have been swallowed
                    // before trying to do the handshake. If it does, something
                    // went wrong so lets bomb out now.
                    throw new SSLException(
                            sm.getString("jsseSupport.unexpectedData"));
                }
            } catch(SSLException sslex) {
                log.info(sm.getString("jsseSupport.clientCertError"), sslex);
                throw sslex;
            } catch (IOException e) {
                // ignore - presumably the timeout
            }
            if (listener.completed) {
                break;
            }
        }
        ssl.setSoTimeout(oldTimeout);
        if (listener.completed == false) {
            throw new SocketException("SSL Cert handshake timeout");
        }

    }

    /**
     * Copied from <code>org.apache.catalina.valves.CertificateValve</code>
     */
    @Override
    public Integer getKeySize()
        throws IOException {
        // Look up the current SSLSession
        SSLSupport.CipherData c_aux[]=ciphers;
        if (session == null)
            return null;

        Integer keySize = null;
        synchronized(keySizeCache) {
            keySize = keySizeCache.get(session);
        }

        if (keySize == null) {
            int size = 0;
            String cipherSuite = session.getCipherSuite();
            for (int i = 0; i < c_aux.length; i++) {
                if (cipherSuite.indexOf(c_aux[i].phrase) >= 0) {
                    size = c_aux[i].keySize;
                    break;
                }
            }
            keySize = Integer.valueOf(size);
            synchronized(keySizeCache) {
                keySizeCache.put(session, keySize);
            }
        }
        return keySize;
    }

    @Override
    public String getSessionId()
        throws IOException {
        // Look up the current SSLSession
        if (session == null)
            return null;
        // Expose ssl_session (getId)
        byte [] ssl_session = session.getId();
        if ( ssl_session == null)
            return null;
        StringBuilder buf=new StringBuilder();
        for(int x=0; x<ssl_session.length; x++) {
            String digit=Integer.toHexString(ssl_session[x]);
            if (digit.length()<2) buf.append('0');
            if (digit.length()>2) digit=digit.substring(digit.length()-2);
            buf.append(digit);
        }
        return buf.toString();
    }


    private static class Listener implements HandshakeCompletedListener {
        volatile boolean completed = false;
        @Override
        public void handshakeCompleted(HandshakeCompletedEvent event) {
            completed = true;
        }
        void reset() {
            completed = false;
        }
    }

    /**
     * Invalidate the session this support object is associated with.
     */
    @Override
    public void invalidateSession() {
        session.invalidate();
    }
}
```


Overlapping Code:
```
ass JSSESupport implements SSLSupport, SSLSessionManager {
private static final org.apache.juli.logging.Log log =
org.apache.juli.logging.LogFactory.getLog(JSSESupport.class);
private static final StringManager sm =
StringManager.getManager("org.apache.tomcat.util.net.jsse.res");
private static final Map<SSLSession,Integer> keySizeCache =
new WeakHashMap<>();
protected SSLSocket ssl;
protected SSLSession session;
Listener listener = new Listener();
JSSESupport(SSLSocket sock){
ssl=sock;
session = sock.getSession();
sock.addHandshakeCompletedListener(listener);
}
JSSESupport(SSLSession session) {
this.session = session;
}
@Override
public String getCipherSuite() throws IOException {
// Look up the current SSLSession
if (session == null)
return null;
return session.getCipherSuite();
}
@Override
public Object[] getPeerCertificateChain()
throws IOException {
return getPeerCertificateChain(false);
}
protected java.security.cert.X509Certificate [] getX509Certificates(
SSLSession session) {
Certificate [] certs=null;
try {
certs = session.getPeerCertificates();
} catch( Throwable t ) {
log.debug(sm.getString("jsseSupport.clientCertError"), t);
return null;
}
if( certs==null ) return null;
java.security.cert.X509Certificate [] x509Certs =
new java.security.cert.X509Certificate[certs.length];
for(int i=0; i < certs.length; i++) {
if (certs[i] instanceof java.security.cert.X509Certificate ) {
// always currently true with the JSSE 1.1.x
x509Certs[i] = (java.security.cert.X509Certificate) certs[i];
} else {
try {
byte [] buffer = certs[i].getEncoded();
CertificateFactory cf =
CertificateFactory.getInstance("X.509");
ByteArrayInputStream stream =
new ByteArrayInputStream(buffer);
x509Certs[i] = (java.security.cert.X509Certificate)
cf.generateCertificate(stream);
} catch(Exception ex) {
log.info(sm.getString(
"jseeSupport.certTranslationError",
```
<Overlap Ratio: 0.9904306220095693>

---

--- 4 --
Question ID: 60ba1d51cf918d5d71aa9d1d4bff3bbdd47025fc
Original Code:
```
public class PaymentSessionTest {
    private static final NetworkParameters PARAMS = TestNet3Params.get();
    private static final String simplePaymentUrl = "http://a.simple.url.com/";
    private static final String paymentRequestMemo = "send coinz noa plz kthx";
    private static final String paymentMemo = "take ze coinz";
    private static final ByteString merchantData = ByteString.copyFromUtf8("merchant data");
    private static final long time = System.currentTimeMillis() / 1000L;
    private ECKey serverKey;
    private Transaction tx;
    private TransactionOutput outputToMe;
    private Coin coin = COIN;

    @Before
    public void setUp() throws Exception {
        serverKey = new ECKey();
        tx = new Transaction(PARAMS);
        outputToMe = new TransactionOutput(PARAMS, tx, coin, serverKey);
        tx.addOutput(outputToMe);
    }

    @Test
    public void testSimplePayment() throws Exception {
        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.
        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest("test"));
        assertEquals(paymentRequestMemo, paymentSession.getMemo());
        assertEquals(coin, paymentSession.getValue());
        assertEquals(simplePaymentUrl, paymentSession.getPaymentUrl());
        assertTrue(new Date(time * 1000L).equals(paymentSession.getDate()));
        assertTrue(paymentSession.getSendRequest().tx.equals(tx));
        assertFalse(paymentSession.isExpired());

        // Send the payment and verify that the correct information is sent.
        // Add a dummy input to tx so it is considered valid.
        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));
        ArrayList<Transaction> txns = new ArrayList<>();
        txns.add(tx);
        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());
        paymentSession.sendPayment(txns, refundAddr, paymentMemo);
        assertEquals(1, paymentSession.getPaymentLog().size());
        assertEquals(simplePaymentUrl, paymentSession.getPaymentLog().get(0).getUrl().toString());
        Protos.Payment payment = paymentSession.getPaymentLog().get(0).getPayment();
        assertEquals(paymentMemo, payment.getMemo());
        assertEquals(merchantData, payment.getMerchantData());
        assertEquals(1, payment.getRefundToCount());
        assertEquals(coin.value, payment.getRefundTo(0).getAmount());
        TransactionOutput refundOutput = new TransactionOutput(PARAMS, null, coin, refundAddr);
        ByteString refundScript = ByteString.copyFrom(refundOutput.getScriptBytes());
        assertTrue(refundScript.equals(payment.getRefundTo(0).getScript()));
    }

    @Test
    public void testDefaults() throws Exception {
        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()
                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));
        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()
                .setTime(time)
                .addOutputs(outputBuilder)
                .build();
        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder()
                .setSerializedPaymentDetails(paymentDetails.toByteString())
                .build();
        MockPaymentSession paymentSession = new MockPaymentSession(paymentRequest);
        assertEquals(Coin.ZERO, paymentSession.getValue());
        assertNull(paymentSession.getPaymentUrl());
        assertNull(paymentSession.getMemo());
    }

    @Test
    public void testExpiredPaymentRequest() throws Exception {
        MockPaymentSession paymentSession = new MockPaymentSession(newExpiredPaymentRequest());
        assertTrue(paymentSession.isExpired());
        // Send the payment and verify that an exception is thrown.
        // Add a dummy input to tx so it is considered valid.
        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));
        ArrayList<Transaction> txns = new ArrayList<>();
        txns.add(tx);
        try {
            paymentSession.sendPayment(txns, null, null);
        } catch(PaymentProtocolException.Expired e) {
            assertEquals(0, paymentSession.getPaymentLog().size());
            assertEquals(e.getMessage(), "PaymentRequest is expired");
            return;
        }
        fail("Expected exception due to expired PaymentRequest");
    }

    @Test
    public void testPkiVerification() throws Exception {
        InputStream in = getClass().getResourceAsStream("pki_test.bitcoinpaymentrequest");
        Protos.PaymentRequest paymentRequest = Protos.PaymentRequest.newBuilder().mergeFrom(in).build();
        PaymentProtocol.PkiVerificationData pkiData = PaymentProtocol.verifyPaymentRequestPki(paymentRequest,
                new TrustStoreLoader.DefaultTrustStoreLoader().getKeyStore());
        assertEquals("www.bitcoincore.org", pkiData.displayName);
        assertEquals("The USERTRUST Network, Salt Lake City, US", pkiData.rootAuthorityName);
    }

    @Test(expected = PaymentProtocolException.InvalidNetwork.class)
    public void testWrongNetwork() throws Exception {
        // Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.
        MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest("main"));
        assertEquals(MainNetParams.get(), paymentSession.getNetworkParameters());

        // Send the payment and verify that the correct information is sent.
        // Add a dummy input to tx so it is considered valid.
        tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));
        ArrayList<Transaction> txns = new ArrayList<>();
        txns.add(tx);
        Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());
        paymentSession.sendPayment(txns, refundAddr, paymentMemo);
        assertEquals(1, paymentSession.getPaymentLog().size());
    }

    private Protos.PaymentRequest newSimplePaymentRequest(String netID) {
        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()
                .setAmount(coin.value)
                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));
        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()
                .setNetwork(netID)
                .setTime(time)
                .setPaymentUrl(simplePaymentUrl)
                .addOutputs(outputBuilder)
                .setMemo(paymentRequestMemo)
                .setMerchantData(merchantData)
                .build();
        return Protos.PaymentRequest.newBuilder()
                .setPaymentDetailsVersion(1)
                .setPkiType("none")
                .setSerializedPaymentDetails(paymentDetails.toByteString())
                .build();
    }

    private Protos.PaymentRequest newExpiredPaymentRequest() {
        Protos.Output.Builder outputBuilder = Protos.Output.newBuilder()
                .setAmount(coin.value)
                .setScript(ByteString.copyFrom(outputToMe.getScriptBytes()));
        Protos.PaymentDetails paymentDetails = Protos.PaymentDetails.newBuilder()
                .setNetwork("test")
                .setTime(time - 10)
                .setExpires(time - 1)
                .setPaymentUrl(simplePaymentUrl)
                .addOutputs(outputBuilder)
                .setMemo(paymentRequestMemo)
                .setMerchantData(merchantData)
                .build();
        return Protos.PaymentRequest.newBuilder()
                .setPaymentDetailsVersion(1)
                .setPkiType("none")
                .setSerializedPaymentDetails(paymentDetails.toByteString())
                .build();
    }

    private class MockPaymentSession extends PaymentSession {
        private ArrayList<PaymentLogItem> paymentLog = new ArrayList<>();

        public MockPaymentSession(Protos.PaymentRequest request) throws PaymentProtocolException {
            super(request);
        }

        public ArrayList<PaymentLogItem> getPaymentLog() {
            return paymentLog;
        }

        @Override
        protected ListenableFuture<PaymentProtocol.Ack> sendPayment(final URL url, final Protos.Payment payment) {
            paymentLog.add(new PaymentLogItem(url, payment));
            return null;
        }

        public class PaymentLogItem {
            private final URL url;
            private final Protos.Payment payment;

            PaymentLogItem(final URL url, final Protos.Payment payment) {
                this.url = url;
                this.payment = payment;
            }

            public URL getUrl() {
                return url;
            }

            public Protos.Payment getPayment() {
                return payment;
            }
        }
    }
}
```


Overlapping Code:
```
ss PaymentSessionTest {
private static final NetworkParameters PARAMS = TestNet3Params.get();
private static final String simplePaymentUrl = "http://a.simple.url.com/";
private static final String paymentRequestMemo = "send coinz noa plz kthx";
private static final String paymentMemo = "take ze coinz";
private static final ByteString merchantData = ByteString.copyFromUtf8("merchant data");
private static final long time = System.currentTimeMillis() / 1000L;
private ECKey serverKey;
private Transaction tx;
private TransactionOutput outputToMe;
private Coin coin = COIN;
@Before
public void setUp() throws Exception {
serverKey = new ECKey();
tx = new Transaction(PARAMS);
outputToMe = new TransactionOutput(PARAMS, tx, coin, serverKey);
tx.addOutput(outputToMe);
}
@Test
public void testSimplePayment() throws Exception {
// Create a PaymentRequest and make sure the correct values are parsed by the PaymentSession.
MockPaymentSession paymentSession = new MockPaymentSession(newSimplePaymentRequest("test"));
assertEquals(paymentRequestMemo, paymentSession.getMemo());
assertEquals(coin, paymentSession.getValue());
assertEquals(simplePaymentUrl, paymentSession.getPaymentUrl());
assertTrue(new Date(time * 1000L).equals(paymentSession.getDate()));
assertTrue(paymentSession.getSendRequest().tx.equals(tx));
assertFalse(paymentSession.isExpired());
// Send the payment and verify that the correct information is sent.
// Add a dummy input to tx so it is considered valid.
tx.addInput(new TransactionInput(PARAMS, tx, outputToMe.getScriptBytes()));
ArrayList<Transaction> txns = new ArrayList<>();
txns.add(tx);
Address refundAddr = new Address(PARAMS, serverKey.getPubKeyHash());
paymentSession.sendPayment(txns, refundAddr, paymentMemo);
assertEquals(1, paymentSession.getPaymentLog().size());
assertEquals(simplePaymentUrl, paymentSession.getPaymentLog().get(0).getUrl().toString());
Protos.Payment payment = paymentSession.getPaymentLog().get(0).getPayment();
assertEquals(paymentMemo, payment.getMemo());
assertEquals(merchantData, payment.getMerchantData());
assertEquals(1, payment.getRefundToCount());
assertEquals(coin.value, payment.getRefundTo(0).getAmount());
TransactionOutput refund
```
<Overlap Ratio: 0.990990990990991>

---

--- 5 --
Question ID: b6959d90635d8f83441a52883f47993e723e69d6
Original Code:
```
public class CrashHandler implements UncaughtExceptionHandler {

    public static final String INTENT_ACTION_RESTART_ACTIVITY = "com.dudu.crash";

    public static final String TAG = "CrashHandler";

    private static CrashHandler mInstance;

    private Context mContext;

    private UncaughtExceptionHandler mDefaultHandler;

    private CrashHandler() {

    }

    public static CrashHandler getInstance() {
        if (mInstance == null) {
            mInstance = new CrashHandler();
        }

        return mInstance;
    }

    private static void killCurrentProcess() {
        android.os.Process.killProcess(android.os.Process.myPid());
        System.exit(10);
    }

    public static Class<? extends Activity> getLauncherActivity(Context context) {
        Intent intent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
        if (intent != null) {
            try {
                return (Class<? extends Activity>) Class.forName(intent.getComponent().getClassName());
            } catch (ClassNotFoundException e) {
            }
        }
        return null;
    }

    private static Class<? extends Activity> getRestartActivityClassWithIntentFilter(Context context) {
        List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentActivities(
                new Intent().setAction(INTENT_ACTION_RESTART_ACTIVITY),
                PackageManager.GET_RESOLVED_FILTER);

        for (ResolveInfo info : resolveInfos) {
            if (info.activityInfo.packageName.equalsIgnoreCase(context.getPackageName())) {
                try {
                    return (Class<? extends Activity>) Class.forName(info.activityInfo.name);
                } catch (ClassNotFoundException e) {
                    //Should not happen, print it to the log!
                    Log.e("TAG", "Failed when resolving the restart activity class via intent filter, stack trace follows!", e);
                }
            }
        }

        return null;
    }

    public void restartApplicationWithIntent(Intent intent) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        mContext.startActivity(intent);
        killCurrentProcess();
    }

    private void restartApp() {
        restartApplicationWithIntent(new Intent(mContext, CrashHandler.getLauncherActivity(mContext)));
    }

    public void init(Context context) {
        mContext = context.getApplicationContext();
        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
    }

    @Override
    public void uncaughtException(Thread thread, Throwable ex) {
//        try {
//            Class<? extends Activity> restartClass = getRestartActivityClassWithIntentFilter(mContext);
//            if (restartClass != null) {
//                Intent intent = new Intent(mContext, restartClass);
//                intent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);//去掉动画效果
//                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
//                intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
//                Bundle args = new Bundle();
//                args.putString("msg", getMsgFromThrowable(ex));
//                intent.putExtras(args);
//                mContext.startActivity(intent);
//            }
//        } catch (Exception e) {
//            e.printStackTrace();
//        }


//        getRestartActivityClassWithIntentFilter(mContext);

        ex.printStackTrace();
        restartApp();

        if (mDefaultHandler != null) {
            mDefaultHandler.uncaughtException(thread, ex);
        } else {
            android.os.Process.killProcess(android.os.Process.myPid());
            System.exit(10);
        }
    }

    private String getMsgFromThrowable(Throwable ex) {
        StringWriter stringWriter = new StringWriter();
        ex.printStackTrace(new PrintWriter(stringWriter));
        return stringWriter.toString();
    }
}
```


Overlapping Code:
```
public class CrashHandler implements UncaughtExceptionHandler {
public static final String INTENT_ACTION_RESTART_ACTIVITY = "com.dudu.crash";
public static final String TAG = "CrashHandler";
private static CrashHandler mInstance;
private Context mContext;
private UncaughtExceptionHandler mDefaultHandler;
private CrashHandler() {
}
public static CrashHandler getInstance() {
if (mInstance == null) {
mInstance = new CrashHandler();
}
return mInstance;
}
private static void killCurrentProcess() {
android.os.Process.killProcess(android.os.Process.myPid());
System.exit(10);
}
public static Class<? extends Activity> getLauncherActivity(Context context) {
Intent intent = context.getPackageManager().getLaunchIntentForPackage(context.getPackageName());
if (intent != null) {
try {
return (Class<? extends Activity>) Class.forName(intent.getComponent().getClassName());
} catch (ClassNotFoundException e) {
}
}
return null;
}
private static Class<? extends Activity> getRestartActivityClassWithIntentFilter(Context context) {
List<ResolveInfo> resolveInfos = context.getPackageManager().queryIntentActivities(
new Intent().setAction(INTENT_ACTION_RESTART_ACTIVITY),
PackageManager.GET_RESOLVED_FILTER);
for (ResolveInfo info : resolveInfos) {
if (info.activityInfo.packageName.equalsIgnoreCase(context.getPackageName())) {
try {
return (Class<? extends Activity>) Class.forName(info.activityInfo.name);
} catch (ClassNotFoundException e) {
//Should not happen, print it to the log!
Log.e("TAG", "Failed when resolving the restart activity class via intent filter, stack trace follows!", e);
}
}
}
return null;
}
public void restartApplicationWithIntent(Intent intent) {
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
mContext.startActivity(intent);
killCurrentProcess();
}
private void restartApp() {
restartApplicationWithIntent(new Intent(mContext, CrashHandler.getLauncherActivity(mContext)));
}
public void init(Context context) {
mContext = context.getApplicationContext();
mD
```
<Overlap Ratio: 0.996538081107814>

---

--- 6 --
Question ID: d01fdb3aa61245224feb43a765679aa1bfab1368
Original Code:
```
public class ThreadSeq extends Thread{
	int n;
	
	public ThreadSeq(int n) {
		this.n = n;
	}
	
	@Override
	public void run() {
		calcSeq();
	}
	
	public void calcSeq() {
		float resultado = 0;
		boolean signal = true;
		double calcParcial = 0;
		
		if(n%2 == 0) {
			n--;
		}
		
		for(int i = 1; i <= n; i = i + 2) {
			if(signal) {
				calcParcial = 1.0 / i;
			}else {
				calcParcial = - 1.0 / i;
			}
			resultado += calcParcial;
			signal = !signal;
		}
		resultado = 4 * resultado;
		System.out.println("N = " + n + " - Resultado = " + resultado);
	}
}
```


Overlapping Code:
```
readSeq extends Thread{
int n;

public ThreadSeq(int n) {
this.n = n;
}

@Override
public void run() {
calcSeq();
}

public void calcSeq() {
float resultado = 0;
boolean signal = true;
double calcParcial = 0;

if(n%2 == 0) {
n--;
}

for(int i = 1; i <= n; i = i + 2) {
if(signal) {
calcParcial = 1.0 / i;
}else {
calcParcial = - 1.0 / i;
}
resultado += calcParcial;
signal = !signal;
}
resultado = 4 * resultado;
System.out.println("N = " + n + " - R
```
<Overlap Ratio: 0.9090909090909091>

---

--- 7 --
Question ID: dbc1f1360d07506bd7e7b44ef86461cf34cc1bd6
Original Code:
```
public class BostonHouseRegression {
    public static List<DataSet> loadHousePrice(File file) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader(file));
        String line = null;
        List<DataSet> totalDataSetList = new LinkedList<DataSet>();
        while( (line = br.readLine()) != null ){
            String[] token = line.split(",");
            double[] featureArray = new double[token.length - 1];
            double[] labelArray = new double[1];
            for( int i = 0; i < token.length - 1; ++i ){
                featureArray[i] = Double.parseDouble(token[i]);
            }
            labelArray[0] = Double.parseDouble(token[token.length - 1]);
            //
            INDArray featureNDArray = Nd4j.create(featureArray);
            INDArray labelNDArray = Nd4j.create(labelArray);
            totalDataSetList.add(new DataSet(featureNDArray, labelNDArray));
        }
        br.close();
        return totalDataSetList;
}
    
    public static MultiLayerNetwork model(){
        MultiLayerConfiguration.Builder builder = new NeuralNetConfiguration.Builder()
                        .seed(12345L)
                        .updater(new Adam(0.01))
                        .weightInit(WeightInit.XAVIER)
                        .optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)
                        .list()
                        .layer(0, new DenseLayer.Builder().activation(Activation.LEAKYRELU)
                                        .nIn(13).nOut(10).build())
                        .layer(1, new OutputLayer.Builder(LossFunctions.LossFunction.MEAN_SQUARED_LOGARITHMIC_ERROR)
                                        .activation(Activation.IDENTITY)
                                        .nIn(10).nOut(1).build());
        MultiLayerConfiguration conf = builder.build();
        MultiLayerNetwork model = new MultiLayerNetwork(conf);
        model.init();
        return model;      
}
    
    
    public static void main(String[] args) throws IOException {
        final int batchSize = 4;
        final long SEED = 1234L;
        final int trainSize = 400;
        List<DataSet> housePriceList = loadHousePrice(new File("house_price.csv"));
        //获取全部数据并且打乱顺序
        DataSet allData = DataSet.merge(housePriceList);
        allData.shuffle(SEED);
        //划分训练集和验证集
        SplitTestAndTrain split = allData.splitTestAndTrain(trainSize);
        DataSet dsTrain = split.getTrain();
        DataSet dsTest = split.getTest();
        DataSetIterator trainIter = new ListDataSetIterator(dsTrain.asList() , batchSize);
        DataSetIterator testIter = new ListDataSetIterator(dsTest.asList() , batchSize);
        //归一化处理
        DataNormalization scaler = new NormalizerMinMaxScaler(0,1);
        scaler.fit(trainIter);
        scaler.fit(testIter);
        trainIter.setPreProcessor(scaler);
        testIter.setPreProcessor(scaler);
        //声明多层感知机
        MultiLayerNetwork mlp = model();
        mlp.setListeners(new ScoreIterationListener(1));
        //训练 200 个 Epoch
        for( int i = 0; i < 200; ++i ){
            mlp.fit(trainIter);
            trainIter.reset();
        }
        //利用 Deeplearning4j 内置的回归模型分析器进行模型评估
        RegressionEvaluation eval = mlp.evaluateRegression(testIter);
        System.out.println(eval.stats());
        testIter.reset();
        //输出验证集的真实值和预测值
        while( testIter.hasNext() ){
            System.out.println(testIter.next().getLabels());
        }
        System.out.println();
        testIter.reset();
        System.out.println(mlp.output(testIter));
    }

}
```


Overlapping Code:
```
ouseRegression {
public static List<DataSet> loadHousePrice(File file) throws IOException {
BufferedReader br = new BufferedReader(new FileReader(file));
String line = null;
List<DataSet> totalDataSetList = new LinkedList<DataSet>();
while( (line = br.readLine()) != null ){
String[] token = line.split(",");
double[] featureArray = new double[token.length - 1];
double[] labelArray = new double[1];
for( int i = 0; i < token.length - 1; ++i ){
featureArray[i] = Double.parseDouble(token[i]);
}
labelArray[0] = Double.parseDouble(token[token.length - 1]);
//
INDArray featureNDArray = Nd4j.create(featureArray);
INDArray labelNDArray = Nd4j.create(labelArray);
totalDataSetList.add(new DataSet(featureNDArray, labelNDArray));
}
br.close();
return totalDataSetList;
}

public static MultiLayerNetwork model(){
MultiLayerConfiguration.Builder builder = new NeuralNetConfiguration.Builder()
.seed(12345L)
.updater(new Adam(0.01))
.weightInit(WeightInit.XAVIER)
.optimizationAlgo(OptimizationAlgorithm.STOCHASTIC_GRADIENT_DESCENT)
.list()
.layer(0, new DenseLayer.Builder().activation(Activation.LEAKYRELU)
.nIn(13).nOut(10).build())
.layer(1, new OutputLayer.Builder(LossFunctions.LossFunction.MEAN_SQUARED_LOGARITHMIC_ERROR)
.activation(Activation.IDENTITY)
.nIn(10).nOut(1).build());
MultiLayerConfiguration conf = builder.build();
MultiLayerNetwork model = new MultiLayerNetwork(conf);
model.init();
return model; 
}


public static void main(String[] args) throws IOException {
final int batchSize = 4;
final long SEED = 1234L;
final int trainSize = 400;
List<DataSet> housePriceList = loadHousePrice(new File("house_price.csv"));
//获取全部数据并且打乱顺序
DataSet allData = DataSet.merge(housePriceList);
allData.shuffle(SEED);
//划分训练集和验证集
SplitTestAndTrain split = allData.splitTestAndTrain(trainSize);
DataSet ds
```
<Overlap Ratio: 0.9693877551020408>

---

--- 8 --
Question ID: a114174307d2ddf33baf5de48afc2b247d3eefab
Original Code:
```
public class BubbleSort {
	
	public static void sort(int[]arrayToSort){
		if(arrayToSort == null || arrayToSort.length == 0){
			return;
		}
		int n = arrayToSort.length;
		int it = 0;
		boolean swapped = true;
		while(it < n - 1 && swapped){
			swapped = false;
			for(int j = 0; j < n - 1 - it; j++){
				if(arrayToSort[j] > arrayToSort[j + 1]){
					SortUtils.swap(arrayToSort, j, j+1);
					swapped = true;
				}
			}
			it++;
		}
	}
}
```


Overlapping Code:
```
lic class BubbleSort {

public static void sort(int[]arrayToSort){
if(arrayToSort == null || arrayToSort.length == 0){
return;
}
int n = arrayToSort.length;
int it = 0;
boolean swapped = true;
while(it < n - 1 && swapped){
swapped = false;
for(int j = 0; j < n - 1 - it; j++){
if(arrayToSort[j] > arrayToSort[j + 1]){
SortUtils.swap(arrayToSort, j, j+1);
swapped = true;
}
}
it++;
}
}
}
```
<Overlap Ratio: 0.9922879177377892>

---

--- 9 --
Question ID: ba6bd19862484398fb77a257adb873a9f8ee25c3
Original Code:
```
public class MediaManager {
	
	public MediaManager()
	{
		mMediaItemList = new ArrayList<MediaItem>();
	}

	private String[] getFilesOfDirectory(String folder) {
		File file = new File(Environment.getExternalStorageDirectory(), folder);
		if (file.exists()) {
			if (file.isDirectory()) {
				return file.list();
			}
		}
		return null;
	}
	
	private String getBitmapFileAddr(String addr)
	{
		File file = new File(Environment.getExternalStorageDirectory(), addr);
		if(file.exists())
		{
			return file.getAbsolutePath();
		}
		else
		{
			return "";
		}
	}
	
	public enum MediaType
	{
		Movie,
		Audio
	}
	
	public void LoadMedia(MediaType mediaType)
	{
		mMediaItemList.clear();
		String[] files = getFilesOfDirectory(mediaType.toString());
		for(int i =0; i<files.length; i++)
		{
			if(files[i].contains(".3gp"))
			{
				MediaItem item = new MediaItem();
				String name = files[i].substring(0, files[i].length()-4);
				item.setName(name);
				item.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + ".png"));
				item.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);
				item.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());
				item.setTransform(new ESTransform());
				mMediaItemList.add(item);
			}
			
			if(files[i].contains(".mp3"))
			{
				MediaItem item = new MediaItem();
				String name = files[i].substring(0, files[i].length()-4);
				item.setName(name);
				item.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + ".png"));
				item.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);
				item.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());
				item.setTransform(new ESTransform());
				mMediaItemList.add(item);
			}
		}
	}
	public static Bitmap LoadBitmapFile(String path) throws Exception{
		FileInputStream in;
		BufferedInputStream buf;
		try {
			//in = new FileInputStream("/sdcard/test2.png");
			in = new FileInputStream(path);
			buf = new BufferedInputStream(in);
			byte[] bMapArray = new byte[buf.available()];
			buf.read(bMapArray);
			BitmapFactory.Options bmOption = new BitmapFactory.Options();
	        bmOption.inPreferredConfig = Config.ARGB_8888;
	        bmOption.inSampleSize = 2;
			Bitmap bMap = BitmapFactory.decodeByteArray(bMapArray, 0,
					bMapArray.length,bmOption);
			if (in != null) {
				in.close();
			}
			if (buf != null) {
				buf.close();
			}
			return bMap;
		} catch (Exception e) {
			Log.e("Error reading file", e.toString());
		}
		return null;
	}
	
	/**
	 * 
	 * @param ids
	 * @return
	 */
	static int[] genTextureIds(int[] ids) {
		GLES20.glGenTextures(ids.length, ids, 0);
		return ids;
	}
	
	public static int[] combine(int[] a, int[] b)
	{
		int alen = a.length;
		int blen = b.length;
		int clen = alen+blen;
	
		int[] c = new int[clen];
		System.arraycopy(a,0,c,0,alen);
		System.arraycopy(b,0,c,alen,blen);
	
		return c;
	}
	
	///
    //  Load texture from resource
    //
    public static int loadTexture ( Bitmap bitmap )
    {
    	//long time1 = System.currentTimeMillis();
        int[] textureId = new int[1];
            
        GLES20.glGenTextures ( 1, textureId, 0 );
        GLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId[0] );
    
        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );
        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );
        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );
        GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );
        
        GLES20.glEnable(GLES20.GL_BLEND);
        GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);
        
        try{
        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0);
        }
        catch(Exception ex)
        {
        	ex.printStackTrace();
        }
        
       // Log.d("bitmap", "load bitmap:" + bitmap + " return :" + textureId[0]);
//        long timediff = System.currentTimeMillis() - time1;
//        
//        Log.d("performance", "load texture:" + timediff);
        
        return textureId[0];
    }
    
    /**
     * bind texture with a general texture id, and draw the texture
     * @author aaronli
     * @since Mar 12,2013
     * @param textureId
     * @param b
     */
    public static void loadSingleTexImage(int textureId, Bitmap b) {
    	//long time1 = System.currentTimeMillis();
    	GLES20.glBindTexture ( GLES20.GL_TEXTURE_2D, textureId );
    	GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR );
		GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR );
		GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE );
		GLES20.glTexParameteri ( GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE );
		
		GLES20.glEnable(GLES20.GL_BLEND);
		GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);
		
		try{
			GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, b, 0);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		//long timediff = System.currentTimeMillis() - time1;
//     //  
       //Log.d("performance", "load texture: " + textureId + "     " + timediff);
    	
    }
    
    public static Bitmap loadProperImage(String path, int reqWidth, int reqHeight)
    {
    	 // First decode with inJustDecodeBounds=true to check dimensions
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeFile(path, options);

        // Calculate inSampleSize
        options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

        // Decode bitmap with inSampleSize set
        options.inJustDecodeBounds = false;
        return BitmapFactory.decodeFile(path, options);
    }

	public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
		// Raw height and width of image
		final int height = options.outHeight;
		final int width = options.outWidth;
		int inSampleSize = 1;

		if (height > reqHeight || width > reqWidth) {
			if (width > height) {
				inSampleSize = Math.round((float) height / (float) reqHeight);
			} else {
				inSampleSize = Math.round((float) width / (float) reqWidth);
			}
		}
		return inSampleSize;
	}
    
    
    public static void releaseTexture(int id)
    {
    	 GLES20.glDeleteTextures(1, IntBuffer.wrap(new int[] {id}));
    }
    public static int getTitleTextureId(String text, int fontSize, int color, Align align)
    {
    	return getTextureIdByText(text, fontSize, color, 550, 50,0,35, align);
    }
    
    public static int getTitleTextureId(String text, int fontSize, int color)
    {
    	return getTextureIdByText(text, fontSize, color, 550, 50,0,35);
    }
    
    public static int getIconTextureId(String text, int fontSize, int color)
    {
    	return getTextureIdByText(text, fontSize, color, 128, 128, 10,115);
    }
    
    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y,Align align )
    {
    	//long time1 = System.currentTimeMillis();
    	
    	// Create an empty, mutable bitmap
    	Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
    	// get a canvas to paint over the bitmap
    	Canvas canvas = new Canvas(bitmap);
    	bitmap.eraseColor(0);

    	// Draw the text
    	Paint textPaint = new Paint();
    	textPaint.setTextSize(fontSize);
    	textPaint.setAntiAlias(true);
    	textPaint.setTextAlign(align);
    	textPaint.setFakeBoldText(true);
    	//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);
    	textPaint.setColor(color);
    	// deleted by aaronli Jul8 2013/ removed the shadow of titles
    	//textPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));
    	
    	// draw the text centered
		canvas.drawText(text, x, y, textPaint);

		int[] textureId = new int[1];
		GLES20.glGenTextures(1, textureId, 0);
		GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);

		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,
				GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,
				GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,
				GLES20.GL_CLAMP_TO_EDGE);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,
				GLES20.GL_CLAMP_TO_EDGE);

		GLES20.glEnable(GLES20.GL_BLEND);
		GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);

		// Use the Android GLUtils to specify a two-dimensional texture image
		// from our bitmap
		GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
		MediaManager.saveImageToExternal(bitmap, "/mnt/sdcard/5.png");
		Log.d("getTextTextureId", "save img");

    	//Clean up
    	bitmap.recycle();
    	
    	 //long timediff = System.currentTimeMillis() - time1;
         
        // Log.d("performance", "load texture(draw text):" + timediff);
    	
    	return textureId[0];
    }
    
    private static int getTextureIdByText(String text, int fontSize, int color, int w, int h, int x, int y)
    {
    	//long time1 = System.currentTimeMillis();
    	
    	// Create an empty, mutable bitmap
    	Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
    	// get a canvas to paint over the bitmap
    	Canvas canvas = new Canvas(bitmap);
    	bitmap.eraseColor(0);

    	// Draw the text
    	Paint textPaint = new Paint();
    	textPaint.setTextSize(fontSize);
    	textPaint.setAntiAlias(true);
    	textPaint.setTextAlign(Align.CENTER);
    	textPaint.setFakeBoldText(true);
    	//textPaint.setARGB(0xff, 0xff, 0x00, 0x00);
    	textPaint.setColor(color);
    	textPaint.setShadowLayer(5f, 2f, 2f, Color.argb(180, 0, 0, 0));
    	
    	// draw the text centered
		canvas.drawText(text, x, y, textPaint);

		int[] textureId = new int[1];
		GLES20.glGenTextures(1, textureId, 0);
		GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId[0]);

		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,
				GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D,
				GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S,
				GLES20.GL_CLAMP_TO_EDGE);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T,
				GLES20.GL_CLAMP_TO_EDGE);

		GLES20.glEnable(GLES20.GL_BLEND);
		GLES20.glBlendFunc(GLES20.GL_ONE, GLES20.GL_ONE_MINUS_SRC_ALPHA);

		// Use the Android GLUtils to specify a two-dimensional texture image
		// from our bitmap
		GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bitmap, 0);
		MediaManager.saveImageToExternal(bitmap, "/mnt/sdcard/5.png");
		Log.d("getTextTextureId", "save img");

    	//Clean up
    	bitmap.recycle();
    	
    	 //long timediff = System.currentTimeMillis() - time1;
         
        // Log.d("performance", "load texture(draw text):" + timediff);
    	
    	return textureId[0];
    }
    
    public static Bitmap getDimImage(Bitmap bitmap)
	{
    	long timea = System.currentTimeMillis();
    	int opacity = 64;

        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

        //draw the bitmap into a canvas
        Canvas canvas = new Canvas(mutableBitmap);

        //create a color with the specified opacity
        int colour = (opacity & 0xFF) << 24;

        //draw the colour over the bitmap using PorterDuff mode DST_IN
        canvas.drawColor(colour, PorterDuff.Mode.DST_IN);
        
        long diff = System.currentTimeMillis() - timea;
        Log.d("bitmapspeed", "bitmapspeed for dim1: " + diff);
        //now return the adjusted bitmap
        return mutableBitmap;
	}
    
    public static Bitmap getDimImage2(Bitmap bitmap)
	{
    	long timea = System.currentTimeMillis();
    	 //make sure bitmap is mutable (copy of needed)
        Bitmap mutableBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

        int h = bitmap.getHeight();
        int w = bitmap.getWidth();
        int[] pixels = new  int[w*h];
        
        bitmap.getPixels(pixels, 0, w, 0, 0, w,h);
        
        for(int i=0; i< pixels.length; i++)
        {
        	int pixel = pixels[i];
        	int a = (pixel & 0xFF000000) >> 24;
        	int r = ((pixel & 0x00FF0000) >> 16)/2;
        	int g = ((pixel & 0x0000FF00) >> 8)/2;
        	int b = (pixel & 0x000000FF)/2;
        	pixels[i] = Color.argb(a, r, g, b);
        }
        mutableBitmap.setPixels(pixels, 0, w, 0, 0, w, h);
        
        long diff = System.currentTimeMillis() - timea;
        Log.d("bitmapspeed", "bitmapspeed for dim2: " + diff);
        
        //now return the adjusted bitmap
        return mutableBitmap;
	}
    
	public static Bitmap getDimImage3(Bitmap oriImage)
	{
		long timea = System.currentTimeMillis();
		
		int width = oriImage.getWidth();
		int height = oriImage.getHeight();
		int argb = 0;
		Bitmap bmapCoverDim = Bitmap.createBitmap(width,height, Config.ARGB_8888);
		for (int i = 0; i < width; i++) {
			for (int j = 0; j < height; j++) {
				argb = oriImage.getPixel(i, j);
				int alpha = argb >> 24;
				int red = (argb & 0x00FF0000) >> 16;
				int green = (argb & 0x0000FF00) >> 8;
				int blue = (argb & 0x000000FF); 
				red = (int) (red * 0.5f);
				green = (int) (green * 0.5f);
				blue = (int) (blue * 0.5f);
				bmapCoverDim.setPixel(i, j, Color.argb(alpha, red, green, blue));
			}
		}
		
        long diff = System.currentTimeMillis() - timea;
        Log.d("bitmapspeed", "bitmapspeed for dim3: " + diff);
        
		return bmapCoverDim;
	}
	
	public static void saveImageToExternalWithFullQuality(Bitmap bmp, String path) {
		OutputStream os = null;
		try {
			os = new FileOutputStream(path);
			bmp.compress(CompressFormat.PNG, 100, os);
			Log.w("mediaManager", "saveImage to :" + path);
			os.flush();
			os.close();
		} catch (Exception e) {
			Log.w("mediaManager", "saveImage fail:" + e.toString());
		}
	}
  
    public static void saveImageToExternal(Bitmap bmp, String path)
	{
		OutputStream os = null;
		try {
			os = new FileOutputStream(path);
			bmp.compress(CompressFormat.PNG, 80, os);
			Log.w("mediaManager","saveImage to :" + path);
			os.flush();
			os.close();
		} catch (Exception e) {
			Log.w("mediaManager","saveImage fail:" + e.toString());
		}
	}
    
    public static void saveImageToInternal(Context context, Bitmap bmp, String fileName){
    	FileOutputStream fos;
		try {
			fos = context.openFileOutput(fileName, Context.MODE_PRIVATE);
			bmp.compress(CompressFormat.PNG, 80, fos);
			
	    	try {
	    		fos.flush();
				fos.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
    public static void saveImageToInternal(Bitmap bmp, String fullFilePath){
    	FileOutputStream fos;
		try {
			File file = new File(fullFilePath);
			fos = new FileOutputStream(file);
			bmp.compress(CompressFormat.PNG, 80, fos);
	    	try {
	    		fos.flush();
				fos.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    }
    
    
    
    public static boolean deleteInternalFile(Context context, String mPath)
    {
    	File file = context.getFilesDir();
    	return file.delete();
    }
    
	public static File getDataDir(Context context) {
		return context.getDir("data", Context.MODE_PRIVATE);
	}
    
    public static File getLargeIconDir(Context context)
    {
    	File file = context.getDir("icon_l", Context.MODE_PRIVATE);
    	return file;
    }
    public static File getDimIconDir(Context context)
    {
    	File file = context.getDir("icon_ld", Context.MODE_PRIVATE);
    	return file;
    }
    
    public static File getMirrorIconDir(Context context)
    {
    	File file = context.getDir("icon_lm", Context.MODE_PRIVATE);
    	return file;
    }
    
    public static File getSmallIconDir(Context context)
    {
    	File file = context.getDir("icon_s", Context.MODE_PRIVATE);
    	return file;
    }
    
	public static Bitmap loadInternalImage(Context context, String fileName) {
		String path = Environment.getDataDirectory().toString() + File.separator + "data" + File.separator + context.getPackageName() + File.separator + "files" + File.separator +fileName;
		Log.d("mediaMgr", "loadInternalImage path:" + path);
		return BitmapFactory.decodeFile(path);
	}
	
	public static File getDir(Context context, String name)
	{
		return context.getDir(name, Context.MODE_PRIVATE);
	}
	
	
	public static String getInternalFilePath(Context context, String fileName) {
		return Environment.getDataDirectory().toString() + File.separator + "data" + File.separator + context.getPackageName() + File.separator + "files" + File.separator +fileName;
	}


    public static Bitmap getReflectionImage(Bitmap bmap) {
    	long timea = System.currentTimeMillis();

		// change image color to dim
    	int pixelCount =0;
		int width = bmap.getWidth();
		int oriHeight = bmap.getHeight();
		int height = (int) (bmap.getHeight() * 1.5f);
		int MAX_PIXEL_COUNT = width * height -1;
		//Bitmap copyBmp = bmap.copy(Config.ARGB_8888, true);
		
		Bitmap bmapMirror = Bitmap.createBitmap(width, height, Config.ARGB_8888);
		int[] pixels = new int[width * height];
		bmap.getPixels(pixels, 0, width, 0, 0, width, oriHeight);
		pixelCount = width* oriHeight -1;

		int half = (int) (bmap.getHeight() / 2);
		//int[] mirrorPixel = new int[width * (height-oriHeight)];

		for(int i=oriHeight-1; i>=height - oriHeight; i--)
		{
			int alpha = 0;
			if (oriHeight - 1 > 128) {
				alpha = (int) (128 * ((i - 128) * 1.0f / half));
			}
			else
			{
				alpha = (int) (128 * ((i - half) * 1.0f / half));
			}
			//Log.d("performance", "load pixel row:" + i + " alpha:" + alpha);
			int[] row = new int[width];
			bmap.getPixels(row, 0, width, 0, i, width, 1);
			for (int j = 0; j < row.length; j++) {
				int argb = row[j];
				int a = (argb & 0xFF000000) >> 24;
				int red = (argb & 0x00FF0000) >> 16;
				int green = (argb & 0x0000FF00) >> 8;
				int blue = (argb & 0x000000FF);
				//Log.d("performance", "load pixel row:" + i + " alpha:" + alpha + "  a:" + a);
				int pixel = Color.argb(alpha, red, green, blue);
				
				if (a == 0) {
					pixels[pixelCount] = row[j];
				} else {
					
					pixels[pixelCount] = pixel;
				}
				pixelCount++;
				if(pixelCount>MAX_PIXEL_COUNT)
				{
					Log.w("getReflectionImage", "the pixel count larger than max count");
					break;
				}
			}
		
		}

		Log.d("mirror test", "mirror test");
		bmapMirror.setPixels(pixels,0,width,0,0,width, height);		
		
        long diff = System.currentTimeMillis() - timea;
        Log.d("bitmapspeed", "bitmapspeed for dim2: " + diff);
        
		return bmapMirror;
	}
    
    //covert to list view icon
	public static Bitmap getIconForListView(Bitmap largeImg)
	{
		float scaleFactor = 80f/largeImg.getHeight();
		Matrix m = new Matrix();
		m.postScale(scaleFactor, scaleFactor);
		return Bitmap.createBitmap(largeImg, 0, 0, largeImg.getWidth(), largeImg.getHeight(), m, false);
	}
	
	
	public static Bitmap generateMovieThumbnail(String path)
	{
		return ThumbnailUtils.createVideoThumbnail(path, Thumbnails.MINI_KIND);	
	}
	
	public static List<File> getAllImagesFiles()
	{
		String cameraImagePath = "/mnt/sdcard/DCIM/Camera/";
		String photoPath =  Global.PATH_PHOTO_DATA;
		String externalPath = "/mnt/extsd/";
		List<File> fileList = new ArrayList<File>();
		File cameraDir = new File(cameraImagePath);
		traverseDirForPhoto(cameraDir, fileList);
		File photoDir = new File(photoPath);
		traverseDirForPhoto(photoDir, fileList);
		File externalDir = new File(externalPath);
		traverseDirForPhoto(externalDir, fileList); 
		Log.d("getAllImagesFiles", "count:" + fileList.size());
		return fileList;
	}
	
	private static void traverseDirForPhoto(File dir, List<File> theList) {
		File[] files = dir.listFiles();
		if (files != null) {
			for (int i = 0; i < files.length; i++) {
			    // skip all files or folders starting with a dot
			    if (files[i].getName().startsWith(".")) {
			        continue;
			    }
			    
				if (files[i].isDirectory()) {
					traverseDirForPhoto(files[i], theList);
				} else {
					if (!files[i].isHidden() && (files[i].getName().contains(Global.FILE_TYPE_PNG) || files[i].getName().contains(Global.FILE_TYPE_JPG))) {
						theList.add(files[i]);
					}
				}
			}
		}
	}
	
	public static Bitmap bitmapResizeToLargePreviewIcon(Bitmap bmp) {
		final float MAX_W  = 256;
		final float MAX_H = 256;
		int h = bmp.getHeight();
		int w = bmp.getWidth();
		double scale = 1;
		if (h > w) {
			if (h < MAX_H) {
				return bmp;
			}
			scale = MAX_H / h;

		} else {
			if (w < MAX_W) {
				return bmp;
			}
			scale = MAX_W / w;
		}
		h = (int) (h * scale);
		w = (int) (w * scale);
		return Bitmap.createScaledBitmap(bmp, w, h, false);
	}
	
	public static Bitmap bitmapResizeToUserIcon(Bitmap bmp)
	{
		Bitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(mutable);
		Paint paint = new Paint();
		paint.setFilterBitmap(false);

		int oriH = bmp.getHeight();
		int oriW = bmp.getWidth();
		int h = 0;
		int w = 0;
		int x = 0;
		int y = 0;
		Bitmap resizeBmp = null;
		Bitmap cropedBmp = null;
		if (oriH > 80) {
			//for pixel > 80;
			if (oriH > oriW) {
				w = 80;
				h = (int) ((80f / oriW) * oriH);
				Log.d("usericon", "1 w:" + w + " h:" + h + " ow:" + oriW + " oh:" + oriH);
				resizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);
				cropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 80) / 2), 80, 80);
			} else {
				h = 80;
				w = (int) ((80f / oriH) * oriW);
				Log.d("usericon", "2 w:" + w + " h:" + h + " ow:" + oriW + " oh:" + oriH);
				resizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);
				cropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 80) / 2), 0, 80, 80);
			}
		}
		else
		{
			//for pixel < 80;
			y = (int)((80 - oriH)/2);
			if(oriW >80)
			{
				cropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 80) / 2), 0, 80, oriH);
			}
			else
			{
				cropedBmp = bmp;
				x = (int)((80 - oriW)/2);
			}
		}
		//Log.d("usericon", "3 w:" + cropedBmp.getWidth() + " h:" + cropedBmp.getHeight() + " ow:" + mask.getWidth() + " oh:" + mask.getHeight());
		// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,
		// filter)

		canvas.drawBitmap(cropedBmp,x, y, paint);
		return mutable;
	}
	
	public static Bitmap bitmapResizeToUserIcon300(Bitmap bmp)
	{
		Bitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(mutable);
		Paint paint = new Paint();
		paint.setFilterBitmap(false);

		int oriH = bmp.getHeight();
		int oriW = bmp.getWidth();
		int h = 0;
		int w = 0;
		int x = 0;
		int y = 0;
		Bitmap resizeBmp = null;
		Bitmap cropedBmp = null;
		if (oriH > 30) {
			//for pixel > 300;
			if (oriH > oriW) {
				w = 300;
				h = (int) ((300f / oriW) * oriH);
				Log.d("usericon", "1 w:" + w + " h:" + h + " ow:" + oriW + " oh:" + oriH);
				resizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);
				cropedBmp = Bitmap.createBitmap(resizeBmp, 0, (int) ((h - 300) / 2), 300, 300);
			} else {
				h = 300;
				w = (int) ((300f / oriH) * oriW);
				Log.d("usericon", "2 w:" + w + " h:" + h + " ow:" + oriW + " oh:" + oriH);
				resizeBmp = Bitmap.createScaledBitmap(bmp, w, h, true);
				cropedBmp = Bitmap.createBitmap(resizeBmp, (int) ((w - 300) / 2), 0, 300, 300);
			}
		}
		else
		{
			//for pixel < 300;
			y = (int)((300 - oriH)/2);
			if(oriW >300)
			{
				cropedBmp = Bitmap.createBitmap(bmp, (int) ((oriW - 300) / 2), 0, 300, oriH);
			}
			else
			{
				cropedBmp = bmp;
				x = (int)((300 - oriW)/2);
			}
		}
		//Log.d("usericon", "3 w:" + cropedBmp.getWidth() + " h:" + cropedBmp.getHeight() + " ow:" + mask.getWidth() + " oh:" + mask.getHeight());
		// Bitmap resizeBmp = bmp.createScaledBitmap(bmp, dstWidth, dstHeight,
		// filter)

		canvas.drawBitmap(cropedBmp,x, y, paint);
		return mutable;
	}
	
	
	public static Bitmap generateUserIcon(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {

		if (bmp != null && bg != null && mask != null && cover != null) {
			Bitmap mutable = Bitmap.createBitmap(80, 80, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(mutable);
			Paint paint = new Paint();
			paint.setFilterBitmap(false);
			canvas.drawBitmap(bmp, 0, 0, paint);
			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
			canvas.drawBitmap(mask, 0, 0, paint);
			paint.setXfermode(null);
			canvas.drawBitmap(cover, 0, 0, paint);

			return mutable;
		}
		return null;

	}
	
	public static Bitmap generateUserIcon300(Bitmap bmp, Bitmap bg, Bitmap mask, Bitmap cover) {

		if (bmp != null && bg != null && mask != null && cover != null) {
			Bitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(mutable);
			Paint paint = new Paint();
			paint.setFilterBitmap(false);
			canvas.drawBitmap(bmp, 0, 0, paint);
			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
			canvas.drawBitmap(mask, 0, 0, paint);
			paint.setXfermode(null);
			canvas.drawBitmap(cover, 0, 0, paint);

			return mutable;
		}
		return null;

	}
	
	private List<MediaItem> mMediaItemList;
	
	public List<MediaItem> getMediaItemList() {
		return mMediaItemList;
	}

	public void setmMediaItemList(List<MediaItem> mediaItemList) {
		this.mMediaItemList = mediaItemList;
	}
	
	public boolean changeFilePermission(File file) {

		try {
			if (file.exists()) {
				String command = "chmod 777 " + file.getAbsolutePath();
				Log.i("zyl", "command = " + command);
				Runtime runtime = Runtime.getRuntime();
				Process proc = runtime.exec(command);
				proc.getOutputStream();
				return true;
			}
		} catch (IOException e) {
			Log.i("zyl", "chmod fail!!!!");
			e.printStackTrace();
		}

		return false;
	}

	private final float INIT_ANGLE = -75;
	private final float SEP_ANGLE = 15;
	
	
	public static Bitmap getMovieLargeIcon(Bitmap oriBmp, Bitmap bmpBg, Bitmap bmpTop) {
		try {
			if (oriBmp != null && bmpBg != null) {
				Bitmap bmp = oriBmp;
				float scale = 296f / bmp.getWidth();
				Matrix matrix = new Matrix();
				matrix.postScale(scale, scale);

				Bitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);
				int cuty = (int) (resizedBitmap.getHeight() / 2 - 89);
				Bitmap cropBitmap = null;
				if (resizedBitmap.getHeight() > 178) {
					cropBitmap = Bitmap.createBitmap(resizedBitmap, 0, cuty, resizedBitmap.getWidth(), 178);
				} else {
					cropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());
				}

				Bitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);
				Canvas canvas = new Canvas(mutableBm);
				canvas.drawBitmap(cropBitmap, 0, 60, null);

				return mutableBm;
			}
		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return null;

	}
	
	public static Bitmap getMusicLargeIcon(Bitmap bmp, Bitmap bmpBg, Bitmap bmpTop)
	{
		if (bmp == null || bmpBg == null || bmpTop == null) {
			return null;
		}	
		
		try {
			float scale = 300f / bmp.getHeight();
			Matrix matrix = new Matrix();
			matrix.postScale(scale, scale);

			Bitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);
			int cutx = (int) (resizedBitmap.getWidth() / 2 - 150);
			Bitmap cropBitmap = null;
			int moveX = 0;
			if (resizedBitmap.getWidth() > 300) {
				cropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, 300, resizedBitmap.getHeight());
			} else {
				moveX = (int)((300 - resizedBitmap.getWidth())/2);
				cropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());
			}
			resizedBitmap.recycle();

			Bitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);
			Canvas canvas = new Canvas(mutableBm);
			
			canvas.drawBitmap(cropBitmap, 40 + moveX, 10, null);
			canvas.drawBitmap(bmpTop, 0, 0, null);
			
			cropBitmap.recycle();
			bmpBg.recycle();
			bmpTop.recycle();
			
			return mutableBm;

		} catch (Exception ex) {
			ex.printStackTrace();
		}
		return null;
	}
	
	public static Bitmap getPhotoLargeIcon(Bitmap orgImage, Bitmap bottom, Bitmap top, int w, int h, int leftMargin, int topMargin)
	{
		Bitmap bmpBg = bottom;
		Bitmap bmpTop = top;
		Bitmap bmp = orgImage;
		float scale = (float)h / bmp.getHeight();
		Matrix matrix = new Matrix();
		matrix.postScale(scale, scale);

		Bitmap resizedBitmap = Bitmap.createBitmap(bmp, 0, 0, bmp.getWidth(), bmp.getHeight(), matrix, true);
		int cutx = (int) (resizedBitmap.getWidth() / 2 - w/2);
		Bitmap cropBitmap = null;
		int moveX = 0;
		if (resizedBitmap.getWidth() > w) {
			cropBitmap = Bitmap.createBitmap(resizedBitmap, cutx, 0, w, resizedBitmap.getHeight());
		} else {
			moveX = (int)((w - resizedBitmap.getWidth())/2);
			cropBitmap = Bitmap.createBitmap(resizedBitmap, 0, 0, resizedBitmap.getWidth(), resizedBitmap.getHeight());
		}

		Bitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);
		Canvas canvas = new Canvas(mutableBm);
		
		canvas.drawBitmap(cropBitmap, leftMargin + moveX, topMargin, null);
		canvas.drawBitmap(bmpTop, 0, 0, null);
		
		return mutableBm;
	}
	
	public static Bitmap getEbookLargeIcon(Bitmap bitmap, Bitmap iconBg)
	{
		Bitmap bmpBg = iconBg;
		//Bitmap bmp = bitmap;
		int h = 278;
		int w = 191;
		
		Bitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, w, h);

		Bitmap mutableBm = bmpBg.copy(Bitmap.Config.ARGB_8888, true);
		Canvas canvas = new Canvas(mutableBm);
		
		canvas.drawBitmap(cropBitmap, 55, 17, null);
		
		return mutableBm;
	}
	
	public static Bitmap getGameLargeIcon(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)
	{
		Bitmap cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);

			Bitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(mutable);
			Paint paint = new Paint();
			paint.setFilterBitmap(false);
			canvas.drawBitmap(cropBitmap, 0, 0, paint);
			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
			canvas.drawBitmap(iconBg, 0, 0, paint);
			paint.setXfermode(null);
			canvas.drawBitmap(iconTop, 0, 0, paint);

			return mutable;
	}
	
	public static Bitmap getGameLargeIcon2(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop)
	{
		Bitmap cropBitmap = null;
		if (bitmap.getHeight() >= 300 || bitmap.getWidth() >= 300) {
			cropBitmap = ThumbnailUtils.extractThumbnail(bitmap, 300, 300);
		}else{
			Log.d("gameLargeIconSize", "w:" + bitmap.getWidth() + " h:" + bitmap.getHeight());
			cropBitmap = bitmap;
		}

			Bitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(mutable);
			Paint paint = new Paint();
			paint.setFilterBitmap(false);
			canvas.drawBitmap(cropBitmap, 0, 0, paint);
			paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
			canvas.drawBitmap(iconBg, 0, 0, paint);
			paint.setXfermode(null);
			canvas.drawBitmap(iconTop, 0, 0, paint);

			return mutable;
	}
	
	public static Bitmap getIconForGooglePlayItem(Bitmap bitmap, Bitmap iconBg, Bitmap iconTop) {
		if (bitmap.getWidth() < 300) {
			bitmap = Bitmap.createScaledBitmap(bitmap, 96, 96, false);
		}
		
		Bitmap mutable = Bitmap.createBitmap(300, 300, Bitmap.Config.ARGB_8888);
		Canvas canvas = new Canvas(mutable);
		Paint paint = new Paint();
		canvas.drawBitmap(iconBg, 0, 0, paint);
		canvas.drawBitmap(bitmap, 98, 52, paint);
		
//		if (iconTop != null) {
//			canvas.drawBitmap(iconTop, 0, 0, paint);
//		}
		
		return mutable;
	}

}
```


Overlapping Code:
```
)
{
mMediaItemList = new ArrayList<MediaItem>();
}
private String[] getFilesOfDirectory(String folder) {
File file = new File(Environment.getExternalStorageDirectory(), folder);
if (file.exists()) {
if (file.isDirectory()) {
return file.list();
}
}
return null;
}

private String getBitmapFileAddr(String addr)
{
File file = new File(Environment.getExternalStorageDirectory(), addr);
if(file.exists())
{
return file.getAbsolutePath();
}
else
{
return "";
}
}

public enum MediaType
{
Movie,
Audio
}

public void LoadMedia(MediaType mediaType)
{
mMediaItemList.clear();
String[] files = getFilesOfDirectory(mediaType.toString());
for(int i =0; i<files.length; i++)
{
if(files[i].contains(".3gp"))
{
MediaItem item = new MediaItem();
String name = files[i].substring(0, files[i].length()-4);
item.setName(name);
item.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + ".png"));
item.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);
item.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());
item.setTransform(new ESTransform());
mMediaItemList.add(item);
}

if(files[i].contains(".mp3"))
{
MediaItem item = new MediaItem();
String name = files[i].substring(0, files[i].length()-4);
item.setName(name);
item.setImageAddr(getBitmapFileAddr(mediaType.toString() + File.separator + name + ".png"));
item.setPath(Environment.getExternalStorageDirectory() +File.separator+ mediaType.toString() + File.separator+files[i]);
item.setAngle(INIT_ANGLE + SEP_ANGLE * mMediaItemList.size());
item.setTransform(new ESTransform());
mMediaItemList.add(item);
}
}
}
public static Bitmap LoadBitmapFile(String path) throws Exception{
FileInputStream in;
BufferedInputStream buf;
try {
//in = new FileInputStream("/sdcard/test2.png");
in = new FileInputStream(path);
buf = new BufferedInputStream(in);
byte[] bMapArray = new byte[buf.available()];
buf.read(bMapArray);
BitmapFactory.Options bmOption = new BitmapFactory.Options();
bmOption.inPreferredConfig = Config.ARGB_8888;
bmOption.inSampleSize = 2;
Bitmap bMap = BitmapFactory.decodeByteArray(bMapArray, 0,
bMapArray.length,bmOption);
if (in != null) {
in.close();
}

```
<Overlap Ratio: 0.9678838539375275>

---

--- 10 --
Question ID: 29c4c5eba17d7a15997d4615015aa5837cf0563e
Original Code:
```
public class MainScreen extends Screen {
	
	///private boolean choosingMultiplayer = false;
	
	private Room room;
	
	//private String ip = null; //ip you're trying to connect to. when null, you're not trying to connect to a server, when initialized, this means you're trying to connect to a server.
	private int selectedMario;
	
	private final BufferedImage[] MARIO_COLORS = {
		null,
		null,
		null,
		null,
		null,
		null
	};
	
	private TextButton	editorButton,
						newGame,
						loadGame,
						singleButton,
						//multiButton,
						title,
						couldntLoad,
						quit;
	
	private static final int SPACE_FROM_TOP = 150, SPACE_BETWEEN = 2;
	
	private static final Font FONT_TITLE = new Font("Courier", Font.PLAIN, 100);
	
	private boolean editorSelected, loadFailed;
	
	public MainScreen(){
		editorSelected = false;
		loadFailed = false;
		for(int i = 0; i < MARIO_COLORS.length; i++){
			Hero h = new Hero();
			h.setSpriteColor(i);
			MARIO_COLORS[i] = (h.IMAGE[0]).getBuffer();
		}
		selectedMario = (int)(Math.random()*6);
		boolean underground = Math.random() > 0.5;
		room = new Room(underground, -1);
		room.add(new TGoomba(500,0,32,32));
		TKoopa koopa = new TKoopa(3000,0);
		room.add(koopa);
		koopa.makeShell(true);
		koopa.vel.x = -TKoopa.SHELL_SPEED;
		room.add(new TBlock(32*5,32*4, TBlock.QUESTION_BLOCK));
		room.add(new TBlock(32*4,32*2, TBlock.BRICK));
		room.add(new TBlock(32*3,32*2, TBlock.BRICK));
		room.add(new TBlock(32*5,32*2, TBlock.BRICK));
		room.add(new TBlock(32*6,32*2, TBlock.QUESTION_BLOCK_DEACTIVATED));
		room.add(new TBlock(32*7,32*2, TBlock.BRICK));
		TPipe pipe = new TPipe();
		pipe.setPos(-32*7, 32*5);
		TPirhana pirhana = new TPirhana();
		room.add(pipe);
		room.add(pirhana);
		pipe.addPirhana(pirhana);
		room.add(new TBlock(-32*5, 0, TBlock.BRICK, null, true));
		
		newGame = new TextButton("NEW", Wuigi.FONT_BIG);
		loadGame = new TextButton("LOAD", Wuigi.FONT_BIG);
		editorButton = new TextButton("LEVEL EDITOR", Wuigi.FONT_BIG);
		singleButton = new TextButton("SINGLEPLAYER", Wuigi.FONT_BIG);
		couldntLoad = new TextButton("LOAD FAILED", Wuigi.FONT_BIG, TextButton.TITLE);
		//multiButton = new TextRect("ONLINE", Wuigi.FONT_BIG);
		title = new TextButton("WUIGI", FONT_TITLE, Color.WHITE);
		quit = new TextButton("QUIT", Wuigi.FONT_BIG);
		int height = editorButton.getHeight();
		
		title.setPos(0, SPACE_FROM_TOP - title.getHeight() - 50);
		editorButton.setPos(0, SPACE_FROM_TOP);
		newGame.setPos(0, SPACE_FROM_TOP);
		loadGame.setPos(newGame.getWidth() + SPACE_BETWEEN*20, SPACE_FROM_TOP);
		singleButton.setPos(0, SPACE_FROM_TOP + height + SPACE_BETWEEN);
		//multiButton.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*2);
		couldntLoad.setPos(0,SPACE_FROM_TOP + (height + SPACE_BETWEEN) * 2);
		quit.setPos(0, SPACE_FROM_TOP + (height + SPACE_BETWEEN)*4);
	}
	
	public void loadFailed(){
		loadFailed = true;
		editorSelected = false;
	}
	
	public void draw(Graphics g) {
		room.draw(g,null,null);
    	
    	title.draw(g);
    	
		if(!editorSelected){
	    	editorButton.draw(g);
		}else{
			loadGame.draw(g);
			newGame.draw(g);
		}
		if(loadFailed){
			couldntLoad.draw(g);
		}
	    singleButton.draw(g);
	    //multiButton.draw(g);
	    quit.draw(g);
	    
	    //unused multiplayer code
	    /*g.setColor(Color.WHITE);
		g.setFont(Wuigi.FONT_BIG);
		if(connection != null && connection.disconnect){
				g.setColor(Color.RED);
				g.setFont(Wuigi.FONT_PLAIN);
				g.drawString("Lost connection", 5,360);
			}
		}else if(ip != null){ //you chose client
			g.setFont(Wuigi.FONT_BIG);
			g.setColor(Color.RED);
			g.drawString("Type the IP:", 5,340);
			g.setColor(Color.WHITE);
			g.drawString(ip, 5,380);
		}else{
			g.setFont(Wuigi.FONT_BIG);
			if(ScreenPanel.mouse.y > 300 && ScreenPanel.mouse.y < 340)
				g.setColor(Color.GREEN);
			g.drawString("Make a Call", 5,340);
			if(ScreenPanel.mouse.y > 340 && ScreenPanel.mouse.y < 380)
				g.setColor(Color.GREEN);
			else
				g.setColor(Color.WHITE);
			g.drawString("Wait for Call", 5,380);
		}
		g.setFont(Wuigi.FONT_BIG);
		if(connection != null && connection.waitingForConnect){
			g.setColor(Color.RED);
			g.drawString("Waiting for connection", 5,Wuigi.H-10);
		}*/
		((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));
		for(int i = 0; i < 6; i++){
			//figure out coordinates of mario
			int x = i, y= 0;
			if(i > 2){
				x -= 3;
				y = 1;
			}

			if(i == selectedMario)
				((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));
			//draw the mario itself
			g.drawImage(
				MARIO_COLORS[i],
				428 + x*128,
				100 + y*80,
				80,
				80,
				null//(java.awt.image.ImageObserver)this
			);

			if(i == selectedMario)
				((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.25f));
		}
		((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));

	}

	public void key(KeyEvent e, boolean down) {
		int code = e.getKeyCode();
		//char c = e.getKeyChar();
		
		if(!down) return; //continue only if you're pressing the key down
		
		
		
		
		//if(ip == null){
		if(code == KeyEvent.VK_ENTER || code == KeyEvent.VK_SPACE || code == KeyEvent.VK_ESCAPE){
			controller.levelEditor(selectedMario);
		}
		return; //continue only if you're typing the IP of the server to connect to
		//}
		
		/*if(code == KeyEvent.VK_ENTER ){
			Connector connection = ScreenPanel.connection;
			connection = new Client(ip, 3456);
			connection.waitingForConnect = true;
			connection.start();
			return;
		}
		if(code == KeyEvent.VK_BACK_SPACE ){
			if(ip.length() > 0)
				ip = (new StringBuffer(ip).deleteCharAt(ip.length()-1)).toString();
			return;
		}
		if(c != KeyEvent.CHAR_UNDEFINED){
			ip += c;
			return;
		}*/

	}

	public void mouse(MouseEvent e, boolean down) {
		if(down)return;
		int x = e.getX(), y = e.getY();
		if(quit.contains(x,y)){
			System.exit(0);
		}
		if(!editorSelected){
			if(editorButton.contains(x,y)){
				//controller.loadGame(selectedMario);
				editorSelected = true;
			}
		}else{
			if(loadGame.contains(x,y)){
				loadFailed = false;
				controller.loadLevelEditor(selectedMario);
			}else if(newGame.contains(x,y)){
				controller.levelEditor(selectedMario);
			}
		}
		if(singleButton.contains(x,y)){
			loadFailed = false;
			controller.singlePlayer(selectedMario);
		}
		/*Connector connection = ScreenPanel.connection;
		if(multiButton.contains(x,y) && !choosingMultiplayer){
			choosingMultiplayer = true;
		}else if(choosingMultiplayer && connection == null && ip == null){
			if(y > 300 && y < 340){
				ip = ""; //this means that we chose client
			}else if(y > 340 && y < 380){
				connection = new Server(3456);
				connection.waitingForConnect = true;
				connection.start();
			}
		}*/
		
		for(int i = 0; i < 6; i++){
			int xpos = i, ypos= 0;
			if(i > 2){
				xpos -= 3;
				ypos = 1;
			}
			if(x > 428 + xpos*128 && x < 508 + xpos*128 &&
				y > 100 + ypos*80 && y < 180 + ypos*80){
				selectedMario = i;
				break;
			}
		}

	}

	public void think() {
		/*Connector connection = ScreenPanel.connection;
		if(connection != null && connection.waitingForConnect && !connection.connected){
			String m = connection.getLastMessage();
			if(m != null){
				if(m.equals("connect")){
					connection.connected = true;
					connection.waitingForConnect = false;
					controller.levelEditor(selectedMario);
				}else if(m.equals("disconnect")){
					connection.disconnect();
				}else{
					connection.message(m); //throw the message back in
				}
			}
		}*/
		room.think(null,true);

	}

}
```


Overlapping Code:
```
nds Screen {

///private boolean choosingMultiplayer = false;

private Room room;

//private String ip = null; //ip you're trying to connect to. when null, you're not trying to connect to a server, when initialized, this means you're trying to connect to a server.
private int selectedMario;

private final BufferedImage[] MARIO_COLORS = {
null,
null,
null,
null,
null,
null
};

private TextButton editorButton,
newGame,
loadGame,
singleButton,
//multiButton,
title,
couldntLoad,
quit;

private static final int SPACE_FROM_TOP = 150, SPACE_BETWEEN = 2;

private static final Font FONT_TITLE = new Font("Courier", Font.PLAIN, 100);

private boolean editorSelected, loadFailed;

public MainScreen(){
editorSelected = false;
loadFailed = false;
for(int i = 0; i < MARIO_COLORS.length; i++){
Hero h = new Hero();
h.setSpriteColor(i);
MARIO_COLORS[i] = (h.IMAGE[0]).getBuffer();
}
selectedMario = (int)(Math.random()*6);
boolean underground = Math.random() > 0.5;
room = new Room(underground, -1);
room.add(new TGoomba(500,0,32,32));
TKoopa koopa = new TKoopa(3000,0);
room.add(koopa);
koopa.makeShell(true);
koopa.vel.x = -TKoopa.SHELL_SPEED;
room.add(new TBlock(32*5,32*4, TBlock.QUESTION_BLOCK));
room.add(new TBlock(32*4,32*2, TBlock.BRICK));
room.add(new TBlock(32*3,32*2, TBlock.BRICK));
room.add(new TBlock(32*5,32*2, TBlock.BRICK));
room.add(new TBlock(32*6,32*2, TBlock.QUESTION_BLOCK_DEACTIVATED));
room.add(new TBlock(32*7,32*2, TBlock.BRICK));
TPipe pipe = new TPipe();
pipe.setPos(-32*7, 32*5);
TPirhana pirhana = new TPirhana();
room.add(pipe);
room.add(pirhana);
pipe.addPirhana(pirhana);
room.add(new TBlock(-32*5, 0, TBlock.BRICK, null, true));

newGame = new TextButton("NEW", Wuigi.FONT_BIG);
loadGame = new TextButton("LOAD", Wuigi.FONT_BIG);
editorButton = new TextButton("LEVEL EDITOR", Wuigi.FONT_BIG);
singleButton = new TextButton("SINGLEPLAYER", Wuigi.FONT_BIG);
couldntLoad = new TextButton("LOAD FAILED", Wuigi.FONT_BIG, TextButton.TITLE);
//multiButton = new TextRect("ONLINE", Wuigi.FONT_BIG);
title = new TextButton("WUIGI", FONT_TITLE, Color.WHITE);
quit = new TextButton("QUIT", Wuigi.FONT_BIG);
int height = editorButton.getHeight();

title.setPos(0, SPACE_FROM_TOP - title.getHeight() - 50);
editorButton.setPos(0, SPACE_FROM_TOP);
newGame.setPos(0, SPACE_FROM_TOP);
loa
```
<Overlap Ratio: 0.9845890410958904>

---

--- 11 --
Question ID: 2b23716c547598eb58965675e1c8839afd8bc526
Original Code:
```
public class QueryLinkefabricFabricCiconfigsResponseUnmarshaller {

	public static QueryLinkefabricFabricCiconfigsResponse unmarshall(QueryLinkefabricFabricCiconfigsResponse queryLinkefabricFabricCiconfigsResponse, UnmarshallerContext _ctx) {
		
		queryLinkefabricFabricCiconfigsResponse.setRequestId(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.RequestId"));
		queryLinkefabricFabricCiconfigsResponse.setResultCode(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.ResultCode"));
		queryLinkefabricFabricCiconfigsResponse.setResultMessage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.ResultMessage"));
		queryLinkefabricFabricCiconfigsResponse.setMessage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Message"));
		queryLinkefabricFabricCiconfigsResponse.setResponseStatusCode(_ctx.longValue("QueryLinkefabricFabricCiconfigsResponse.ResponseStatusCode"));
		queryLinkefabricFabricCiconfigsResponse.setSuccess(_ctx.booleanValue("QueryLinkefabricFabricCiconfigsResponse.Success"));

		Data data = new Data();
		data.setDevStage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.DevStage"));
		data.setEnv(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.Env"));
		data.setExtraParams(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.ExtraParams"));

		List<String> configs = new ArrayList<String>();
		for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.Configs.Length"); i++) {
			configs.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.Configs["+ i +"]"));
		}
		data.setConfigs(configs);

		List<String> projectConfigs = new ArrayList<String>();
		for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs.Length"); i++) {
			projectConfigs.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs["+ i +"]"));
		}
		data.setProjectConfigs(projectConfigs);

		List<String> sameRepoAppList = new ArrayList<String>();
		for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList.Length"); i++) {
			sameRepoAppList.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList["+ i +"]"));
		}
		data.setSameRepoAppList(sameRepoAppList);
		queryLinkefabricFabricCiconfigsResponse.setData(data);
	 
	 	return queryLinkefabricFabricCiconfigsResponse;
	}
}
```


Overlapping Code:
```
iconfigsResponseUnmarshaller {
public static QueryLinkefabricFabricCiconfigsResponse unmarshall(QueryLinkefabricFabricCiconfigsResponse queryLinkefabricFabricCiconfigsResponse, UnmarshallerContext _ctx) {

queryLinkefabricFabricCiconfigsResponse.setRequestId(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.RequestId"));
queryLinkefabricFabricCiconfigsResponse.setResultCode(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.ResultCode"));
queryLinkefabricFabricCiconfigsResponse.setResultMessage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.ResultMessage"));
queryLinkefabricFabricCiconfigsResponse.setMessage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Message"));
queryLinkefabricFabricCiconfigsResponse.setResponseStatusCode(_ctx.longValue("QueryLinkefabricFabricCiconfigsResponse.ResponseStatusCode"));
queryLinkefabricFabricCiconfigsResponse.setSuccess(_ctx.booleanValue("QueryLinkefabricFabricCiconfigsResponse.Success"));
Data data = new Data();
data.setDevStage(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.DevStage"));
data.setEnv(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.Env"));
data.setExtraParams(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.ExtraParams"));
List<String> configs = new ArrayList<String>();
for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.Configs.Length"); i++) {
configs.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.Configs["+ i +"]"));
}
data.setConfigs(configs);
List<String> projectConfigs = new ArrayList<String>();
for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs.Length"); i++) {
projectConfigs.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.ProjectConfigs["+ i +"]"));
}
data.setProjectConfigs(projectConfigs);
List<String> sameRepoAppList = new ArrayList<String>();
for (int i = 0; i < _ctx.lengthValue("QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList.Length"); i++) {
sameRepoAppList.add(_ctx.stringValue("QueryLinkefabricFabricCiconfigsResponse.Data.SameRepoAppList["+ i +"]"));
}
data.setSameRepoAppList(sameRepoAppList);
queryLinkefabricFabricCiconfigsResponse.setData(data);

return queryLinkefabricFabricCiconfigsRe
```
<Overlap Ratio: 0.97997443544951>

---

--- 12 --
Question ID: 789caa9d57380aa5b19155abaa7eb53645d02aaf
Original Code:
```
public class VideoViewController extends FrameLayout {

    private VideoView mVideoView;
    private ImageView mCoverImageView;
    private ImageButton mPlayImageButton;

    public VideoViewController(@NonNull Context context) {
        this(context, null);
    }

    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs) {
        this(context, attrs, -1);
    }

    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        this(context, attrs, defStyleAttr, -1);
    }

    public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
        mVideoView = new VideoView(context);
        addView(mVideoView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));

        mCoverImageView = new ImageView(context);
        mCoverImageView.setBackgroundColor(Color.BLACK);
        addView(mCoverImageView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));

        mPlayImageButton = new ImageButton(context);
        mPlayImageButton.setBackgroundResource(android.R.color.transparent);
        mPlayImageButton.setImageResource(R.drawable.ic_play);
        LayoutParams playParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        playParams.gravity = Gravity.CENTER;
        addView(mPlayImageButton, playParams);
    }


    private void resetState() {
        this.setVisibility(VISIBLE);
        mVideoView.setVisibility(INVISIBLE);
        mCoverImageView.setVisibility(VISIBLE);
        mPlayImageButton.setVisibility(VISIBLE);
    }

    public void show(Bitmap coverBitmap, String videoPath) {
        resetState();
        mCoverImageView.setImageBitmap(coverBitmap);
        mVideoView.setOnCompletionListener(mp -> {
           resetState();
           mp.release();
        });
        mPlayImageButton.setOnClickListener(v -> {
            mVideoView.setVisibility(VISIBLE);
            mCoverImageView.setVisibility(INVISIBLE);
            mPlayImageButton.setVisibility(INVISIBLE);
            mVideoView.setVideoPath(videoPath);
            mVideoView.start();
        });
    }

    public void hide() {
        if(mVideoView.isPlaying()){
            mVideoView.stopPlayback();
        }
        this.setVisibility(INVISIBLE);
        mVideoView.setVisibility(INVISIBLE);
        mCoverImageView.setVisibility(INVISIBLE);
        mPlayImageButton.setVisibility(INVISIBLE);
    }
}
```


Overlapping Code:
```
ideoViewController extends FrameLayout {
private VideoView mVideoView;
private ImageView mCoverImageView;
private ImageButton mPlayImageButton;
public VideoViewController(@NonNull Context context) {
this(context, null);
}
public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs) {
this(context, attrs, -1);
}
public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
this(context, attrs, defStyleAttr, -1);
}
public VideoViewController(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {
super(context, attrs, defStyleAttr, defStyleRes);
mVideoView = new VideoView(context);
addView(mVideoView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
mCoverImageView = new ImageView(context);
mCoverImageView.setBackgroundColor(Color.BLACK);
addView(mCoverImageView, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
mPlayImageButton = new ImageButton(context);
mPlayImageButton.setBackgroundResource(android.R.color.transparent);
mPlayImageButton.setImageResource(R.drawable.ic_play);
LayoutParams playParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
playParams.gravity = Gravity.CENTER;
addView(mPlayImageButton, playParams);
}
private void resetState() {
this.setVisibility(VISIBLE);
mVideoView.setVisibility(INVISIBLE);
mCoverImageView.setVisibility(VISIBLE);
mPlayImageButton.setVisibility(VISIBLE);
}
public void show(Bitmap coverBitmap, String videoPath) {
resetState();
mCoverImageView.setImageBitmap(coverBitmap);
mVideoView.setOnCompletionListener(mp -> {
resetState();
mp.release();
});
mPlayImageButton.setOnClickListener(v -> {
mVideoView.setVisibility(VISIBLE);
mCoverImageView.setVisibility(INVISIBLE);
mPlayImageButton.setVisibility(INVISIBLE);
mVideoView.setVideoPath(videoPath);
mVideoView.start();
});
}
public void hide() {
if(mVideoView.isPlaying()){
mVideoView.stopPlayback();
}
this.setVisibility(INVISIBLE);
mVideoView.setVisibility(INVISIBLE
```
<Overlap Ratio: 0.9808612440191388>

---

--- 13 --
Question ID: 164c168bf1b651e868786061cf603a2c0cf599ff
Original Code:
```
public class PreviewWindow {
  @FXML private TextField accessToken;
  @FXML private Button clipboard;
  @FXML private Button exit;
  @FXML private Button refresh;
  @FXML private Label title;

  private SpotifyUser user;

  @FXML public void initialize() {
    Platform.runLater(this::loadDetails);

    clipboard.setOnMouseClicked(e -> copyToClipboard());
    exit.setOnMouseClicked(e -> {
      final int selection = JOptionPane.showConfirmDialog(null, "Are you sure you wish to exit?");
      if (selection == JOptionPane.YES_OPTION) exitGenerator();
    });
  }

  private void exitGenerator() {
    user.disableTimer();
    Stage stage = (Stage) clipboard.getScene().getWindow();
    stage.close();
  }

  private void copyToClipboard() {
    copyText();
    editLabel("Copied to clipboard", 3);
  }

  private void editLabel(String addOn, int duration) {
    title.setText(String.format("Access Token (%s):", addOn));
    final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(duration), e -> title.setText("Access Token:")));
    timeline.play();
  }

  private void copyText() {
    final Clipboard clipboard = Clipboard.getSystemClipboard();
    final ClipboardContent content = new ClipboardContent();
    content.putString(accessToken.getText());
    clipboard.setContent(content);
  }

  private void loadDetails() {
    accessToken.setText(user.getAccessToken());
    if (user.getExpiryDuration() == null) {
      System.out.println("Unable to refresh tokens due to some unknown error with the expiry duration");
      return;
    }
    final Timeline timeline = new Timeline(
      new KeyFrame(Duration.seconds(user.getExpiryDuration() + 1),
        e -> {
          JOptionPane.showMessageDialog(null, "Access Token was refreshed");
          editLabel("Refreshed", 5);
          accessToken.setText(user.getAccessToken());
        }));
    timeline.setCycleCount(Animation.INDEFINITE);
    timeline.play();
  }

  void setUser(SpotifyUser user) {
    this.user = user;
  }
}
```


Overlapping Code:
```
vate TextField accessToken;
@FXML private Button clipboard;
@FXML private Button exit;
@FXML private Button refresh;
@FXML private Label title;
private SpotifyUser user;
@FXML public void initialize() {
Platform.runLater(this::loadDetails);
clipboard.setOnMouseClicked(e -> copyToClipboard());
exit.setOnMouseClicked(e -> {
final int selection = JOptionPane.showConfirmDialog(null, "Are you sure you wish to exit?");
if (selection == JOptionPane.YES_OPTION) exitGenerator();
});
}
private void exitGenerator() {
user.disableTimer();
Stage stage = (Stage) clipboard.getScene().getWindow();
stage.close();
}
private void copyToClipboard() {
copyText();
editLabel("Copied to clipboard", 3);
}
private void editLabel(String addOn, int duration) {
title.setText(String.format("Access Token (%s):", addOn));
final Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(duration), e -> title.setText("Access Token:")));
timeline.play();
}
private void copyText() {
final Clipboard clipboard = Clipboard.getSystemClipboard();
final ClipboardContent content = new ClipboardContent();
content.putString(accessToken.getText());
clipboard.setContent(content);
}
private void loadDetails() {
accessToken.setText(user.getAccessToken());
if (user.getExpiryDuration() == null) {
System.out.println("Unable to refresh tokens due to some unknown error with the expiry duration");
return;
}
final Timeline timeline = new Timeline(
new KeyFrame(Duration.seconds(user.getExpiryDuration() + 1),
e -> {
JOptionPane.showMessageDialog(null, "Access Token was refreshed");
editLabel("Refreshed", 5);
accessToken.setText(user.getAccessToken());
}));
timeline.setCycleCount(Animation.INDEFINITE);
timeline.play();
}
void setUser(SpotifyUser user) {
this.user = user;
}
}
```
<Overlap Ratio: 0.9787472035794184>

---

--- 14 --
Question ID: c34048d3ef33b1d47e48ab44358459f8ecbcd2f0
Original Code:
```
@ApiModel(description = "```JSON \"details\": {   \"first_name\": \"First\",   \"last_name\": \"Last\",   \"bank_name\": \"Deutsche Bank\",   \"iban\": \"DE89370400440532013000\",   \"bic\": \"DEUTDEBBXXX\" // Optional } ```")

public class PayoutMethodDetailsIBAN {
  public static final String SERIALIZED_NAME_FIRST_NAME = "first_name";
  @SerializedName(SERIALIZED_NAME_FIRST_NAME)
  private String firstName;

  public static final String SERIALIZED_NAME_LAST_NAME = "last_name";
  @SerializedName(SERIALIZED_NAME_LAST_NAME)
  private String lastName;

  public static final String SERIALIZED_NAME_BANK_NAME = "bank_name";
  @SerializedName(SERIALIZED_NAME_BANK_NAME)
  private String bankName;

  public static final String SERIALIZED_NAME_IBAN = "iban";
  @SerializedName(SERIALIZED_NAME_IBAN)
  private String iban;

  public static final String SERIALIZED_NAME_BIC = "bic";
  @SerializedName(SERIALIZED_NAME_BIC)
  private String bic;

  public PayoutMethodDetailsIBAN firstName(String firstName) {
    this.firstName = firstName;
    return this;
  }

   /**
   * Get firstName
   * @return firstName
  **/
  @ApiModelProperty(required = true, value = "")
  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public PayoutMethodDetailsIBAN lastName(String lastName) {
    this.lastName = lastName;
    return this;
  }

   /**
   * Get lastName
   * @return lastName
  **/
  @ApiModelProperty(required = true, value = "")
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  public PayoutMethodDetailsIBAN bankName(String bankName) {
    this.bankName = bankName;
    return this;
  }

   /**
   * Get bankName
   * @return bankName
  **/
  @ApiModelProperty(value = "")
  public String getBankName() {
    return bankName;
  }

  public void setBankName(String bankName) {
    this.bankName = bankName;
  }

  public PayoutMethodDetailsIBAN iban(String iban) {
    this.iban = iban;
    return this;
  }

   /**
   * Get iban
   * @return iban
  **/
  @ApiModelProperty(required = true, value = "")
  public String getIban() {
    return iban;
  }

  public void setIban(String iban) {
    this.iban = iban;
  }

  public PayoutMethodDetailsIBAN bic(String bic) {
    this.bic = bic;
    return this;
  }

   /**
   * Get bic
   * @return bic
  **/
  @ApiModelProperty(value = "")
  public String getBic() {
    return bic;
  }

  public void setBic(String bic) {
    this.bic = bic;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PayoutMethodDetailsIBAN payoutMethodDetailsIBAN = (PayoutMethodDetailsIBAN) o;
    return Objects.equals(this.firstName, payoutMethodDetailsIBAN.firstName) &&
        Objects.equals(this.lastName, payoutMethodDetailsIBAN.lastName) &&
        Objects.equals(this.bankName, payoutMethodDetailsIBAN.bankName) &&
        Objects.equals(this.iban, payoutMethodDetailsIBAN.iban) &&
        Objects.equals(this.bic, payoutMethodDetailsIBAN.bic);
  }

  @Override
  public int hashCode() {
    return Objects.hash(firstName, lastName, bankName, iban, bic);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PayoutMethodDetailsIBAN {\n");
    sb.append("    firstName: ").append(toIndentedString(firstName)).append("\n");
    sb.append("    lastName: ").append(toIndentedString(lastName)).append("\n");
    sb.append("    bankName: ").append(toIndentedString(bankName)).append("\n");
    sb.append("    iban: ").append(toIndentedString(iban)).append("\n");
    sb.append("    bic: ").append(toIndentedString(bic)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
```


Overlapping Code:
```
@ApiModel(description = "```JSON \"details\": { \"first_name\": \"First\", \"last_name\": \"Last\", \"bank_name\": \"Deutsche Bank\", \"iban\": \"DE89370400440532013000\", \"bic\": \"DEUTDEBBXXX\" // Optional } ```")
public class PayoutMethodDetailsIBAN {
public static final String SERIALIZED_NAME_FIRST_NAME = "first_name";
@SerializedName(SERIALIZED_NAME_FIRST_NAME)
private String firstName;
public static final String SERIALIZED_NAME_LAST_NAME = "last_name";
@SerializedName(SERIALIZED_NAME_LAST_NAME)
private String lastName;
public static final String SERIALIZED_NAME_BANK_NAME = "bank_name";
@SerializedName(SERIALIZED_NAME_BANK_NAME)
private String bankName;
public static final String SERIALIZED_NAME_IBAN = "iban";
@SerializedName(SERIALIZED_NAME_IBAN)
private String iban;
public static final String SERIALIZED_NAME_BIC = "bic";
@SerializedName(SERIALIZED_NAME_BIC)
private String bic;
public PayoutMethodDetailsIBAN firstName(String firstName) {
this.firstName = firstName;
return this;
}
/**
* Get firstName
* @return firstName
**/
@ApiModelProperty(required = true, value = "")
public String getFirstName() {
return firstName;
}
public void setFirstName(String firstName) {
this.firstName = firstName;
}
public PayoutMethodDetailsIBAN lastName(String lastName) {
this.lastName = lastName;
return this;
}
/**
* Get lastName
* @return lastName
**/
@ApiModelProperty(required = true, value = "")
public String getLastName() {
return lastName;
}
public void setLastName(String lastName) {
this.lastName = lastName;
}
public PayoutMethodDetailsIBAN bankName(String bankName) {
this.bankName = bankName;
return this;
}
/**
* Get bankName
* @return bankName
**/
@ApiModelProperty(value = "")
public String getBankName() {
return bankName;
}
public void setBankName(String bankName) {
this.bankName = bankName;
}
public PayoutMethodDetailsIBAN iban(String iban) {
this.iban = iban;
return this;
}
/**
* Get iban
* @return iban
**/
@ApiModelProperty(required = true, value = "")
public String getIban() {
return iban;
}
public void setIban(String iban) {
this.iban = iban;
}
public PayoutMethodDetailsIBAN bic(String bic) {
this.bic = bic;
return this;
}
/**
* Get bic
* @return bic
**/
@ApiModelProperty(value = "")
public String getBi
```
<Overlap Ratio: 0.9977748108589231>

---

--- 15 --
Question ID: 05fa1547b47408246c078969b839aa65476648b3
Original Code:
```
public class ClipUri extends ClipContent {

    @NonNull
    public Uri uri;

    public ClipUri(@NonNull String mimeType, @NonNull Uri uri) {
        super(mimeType);
        this.uri = uri;
    }

    public ClipUri(@NonNull Uri uri) {
        super(ClipDescription.MIMETYPE_TEXT_URILIST);
        this.uri = uri;
    }

    public ClipUri(@NonNull ContentResolver resolver, @NonNull Uri uri) {
        super(getMimeTypes(resolver, uri)[0]);
        this.uri = uri;
    }

    /**
     * Finds all applicable MIME types for a given URI.
     *
     * @param resolver ContentResolver used to get information about the URI.
     * @param uri      The URI.
     * @return Returns an array of MIME types.
     */
    public static String[] getMimeTypes(ContentResolver resolver, Uri uri) {
        String[] mimeTypes = null;
        if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
            String realType = resolver.getType(uri);
            mimeTypes = resolver.getStreamTypes(uri, "*/*");
            if (realType != null) {
                if (mimeTypes == null) {
                    mimeTypes = new String[]{realType};
                } else if (!Arrays.asList(mimeTypes).contains(realType)) {
                    String[] tmp = new String[mimeTypes.length + 1];
                    tmp[0] = realType;
                    System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
                    mimeTypes = tmp;
                }
            }
        }
        if (mimeTypes == null) {
            mimeTypes = new String[]{ClipDescription.MIMETYPE_TEXT_URILIST};
        }
        return mimeTypes;
    }

    @Override
    public ClipData.Item toItem() {
        return new ClipData.Item(uri);
    }
}
```


Overlapping Code:
```
lass ClipUri extends ClipContent {
@NonNull
public Uri uri;
public ClipUri(@NonNull String mimeType, @NonNull Uri uri) {
super(mimeType);
this.uri = uri;
}
public ClipUri(@NonNull Uri uri) {
super(ClipDescription.MIMETYPE_TEXT_URILIST);
this.uri = uri;
}
public ClipUri(@NonNull ContentResolver resolver, @NonNull Uri uri) {
super(getMimeTypes(resolver, uri)[0]);
this.uri = uri;
}
/**
* Finds all applicable MIME types for a given URI.
*
* @param resolver ContentResolver used to get information about the URI.
* @param uri The URI.
* @return Returns an array of MIME types.
*/
public static String[] getMimeTypes(ContentResolver resolver, Uri uri) {
String[] mimeTypes = null;
if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
String realType = resolver.getType(uri);
mimeTypes = resolver.getStreamTypes(uri, "*/*");
if (realType != null) {
if (mimeTypes == null) {
mimeTypes = new String[]{realType};
} else if (!Arrays.asList(mimeTypes).contains(realType)) {
String[] tmp = new String[mimeTypes.length + 1];
tmp[0] = realType;
System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
mimeTypes = tmp;
}
}
}
if (mimeTypes == null) {
mimeTypes = new String[]{ClipDescription.MIMETYPE_TEXT_URILIST};
}
return mimeTypes;
}
@Override
public ClipData.Item toItem() {
return new ClipData.It
```
<Overlap Ratio: 0.9848484848484849>

---

--- 16 --
Question ID: 8f7acd1c6716ff45fc7a9e90f82f69b91976813b
Original Code:
```
public class ValueCollectionTest
{

	private static final double DOUBLE_VALUE_1 = 0.15625d;
	private static final double DOUBLE_VALUE_2 = 5.0E2;

	@Test
	public void testConversionToReal() throws Exception
	{
		Asn1Factory factory = new DefaultAsn1Factory();
		Module module = factory.types().dummyModule();

		ValueCollection collection = factory.values().collection( true );
		collection.addNamed( "mantissa", factory.values().integer( 5 ) );
		collection.addNamed( "base", factory.values().integer( 2 ) );
		collection.addNamed( "exponent", factory.values().integer( -5 ) );

		DefinedValue value = factory.types().define( "a-real", UniversalType.REAL.ref(), collection, null );

		module.validate();

		Assert.assertEquals( "Is not 0.15625", 0, factory.values().real( DOUBLE_VALUE_1 ).compareTo( value.getValue() ) );
	}

	@Test
	public void testConversionToReal2() throws Exception
	{
		Asn1Factory factory = new DefaultAsn1Factory();
		Module module = factory.types().dummyModule();

		ValueCollection collection = factory.values().collection( true );
		collection.addNamed( "mantissa", factory.values().integer( 5 ) );
		collection.addNamed( "base", factory.values().integer( 10 ) );
		collection.addNamed( "exponent", factory.values().integer( 2 ) );

		DefinedValue value = factory.types().define( "a-real", UniversalType.REAL.ref(), collection, null );

		module.validate();

		Assert.assertEquals( "Is not 5E2", 0, factory.values().real( DOUBLE_VALUE_2 ).compareTo( value.getValue() ) );
	}
}
```


Overlapping Code:
```
lass ValueCollectionTest
{
private static final double DOUBLE_VALUE_1 = 0.15625d;
private static final double DOUBLE_VALUE_2 = 5.0E2;
@Test
public void testConversionToReal() throws Exception
{
Asn1Factory factory = new DefaultAsn1Factory();
Module module = factory.types().dummyModule();
ValueCollection collection = factory.values().collection( true );
collection.addNamed( "mantissa", factory.values().integer( 5 ) );
collection.addNamed( "base", factory.values().integer( 2 ) );
collection.addNamed( "exponent", factory.values().integer( -5 ) );
DefinedValue value = factory.types().define( "a-real", UniversalType.REAL.ref(), collection, null );
module.validate();
Assert.assertEquals( "Is not 0.15625", 0, factory.values().real( DOUBLE_VALUE_1 ).compareTo( value.getValue() ) );
}
@Test
public void testConversionToReal2() throws Exception
{
Asn1Factory factory = new DefaultAsn1Factory();
Module module = factory.types().dummyModule();
ValueCollection collection = factory.values().collection( true );
collection.addNamed( "mantissa", factory.values().integer( 5 ) );
collection.addNamed( "base", factory.values().integer( 10 ) );
collection.addNamed( "exponent", factory.values().integer( 2 ) );
DefinedValue value = factory.types().define( "a-real", UniversalType.REAL.ref(), collection, null );
module.validate();
Assert.assertEquals( "Is not 5E2", 0, factory.values().real( DOUBLE_VALUE_2 
```
<Overlap Ratio: 0.9681881051175657>

---

--- 17 --
Question ID: 57867d7d465f26966deaba0e545a23f9d9edfd30
Original Code:
```
public class SolutionTest {

    @Test
    public void intToRoman() {
        Solution s =  new Solution();
        assertEquals("III", s.intToRoman(3));
        assertEquals("IV", s.intToRoman(4));
        assertEquals("IX", s.intToRoman(9));
        assertEquals("LVIII", s.intToRoman(58));
        assertEquals("MCMXCIV", s.intToRoman(1994));
    }
}
```


Overlapping Code:
```
blic class SolutionTest {
@Test
public void intToRoman() {
Solution s = new Solution();
assertEquals("III", s.intToRoman(3));
assertEquals("IV", s.intToRoman(4));
assertEquals("IX", s.intToRoman(9));
assertEquals("LVIII", s.intToRoman(58));
assertEqu
```
<Overlap Ratio: 0.8591065292096219>

---

--- 18 --
Question ID: ed3525f8f3bb66c3f83adfa5c52acc8b6fe5a527
Original Code:
```
public class EquivalenceSetGraphAnalyser {

	private static Logger logger = LoggerFactory.getLogger(EquivalenceSetGraphBuilderImpl.class);

	public static void countBlankNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {

		logger.info("Counting number of BlankNodes");
		int processed = 0;

		int numberOfBlankNodes = 0;
		int toProcess = esg.ID.keySet().size();

		Set<Long> es_with_bn = new HashSet<>();

		Iterator<Entry<String, Long>> iterator = esg.ID.iterator();
		while (iterator.hasNext()) {
			if (processed % 10000 == 0) {
				logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
			}
			processed++;
			Entry<String, Long> entry = (Entry<String, Long>) iterator.next();
			if (isBlankNode(entry.getKey())) {
				numberOfBlankNodes++;
				es_with_bn.add(entry.getValue());
			}
		}
		esg.getStats().bns = numberOfBlankNodes;
		esg.getStats().es_with_bns = es_with_bn.size();

	}

	public static void countObservedEntitiesWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg) {
		logger.info("Counting Number of Observed Entities With Empty Extension");
		long result = 0;
		long result_without_bn = 0;
		Iterator<Entry<String, Long>> it = esg.oe_size.iterator();
		while (it.hasNext()) {
			Entry<String, Long> e = it.next();
			if (e.getValue() == 0) {
				result++;
				if (!isBlankNode(e.getKey())) {
					result_without_bn++;
				}
			}

		}
		esg.getStats().oe0 = result;
		esg.getStats().oe0_bns = result_without_bn;
	}

	public static void computeDistributionOfExtensionalSizeOfEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) {

		logger.info("Computing Statistics on Extensional Size of Equivalence Sets");
		Map<Long, Long> result = new HashMap<>();
		Map<Long, Long> resultPerThreshold = new HashMap<>();
		Set<Long> sizeThresholds = Sets.newHashSet(1L, 10L, 100L, 1000L, 1000000L, 1000000000L);
		for (Long l : sizeThresholds) {
			resultPerThreshold.put(l, 0L);
		}
		Iterator<Entry<Long, Long>> it = esg.IES.iterator();
		while (it.hasNext()) {
			Entry<Long, Long> e = it.next();
			Long s = result.get(e.getValue());
			if (s == null) {
				result.put(e.getValue(), 1L);
			} else {
				result.put(e.getValue(), result.get(e.getValue()) + 1);
			}

			for (Long l : sizeThresholds) {
				if (e.getValue() > l) {
					resultPerThreshold.put(l, resultPerThreshold.get(l) + 1);
				}
			}
		}
		esg.getStats().indirectExtensionalSizeDistribution = result;
		esg.getStats().iesPerThreshold = resultPerThreshold;

	}

	public static void countEquivalenceSetsWithEmptyExtension(RocksDBBackedEquivalenceSetGraph esg) {

		logger.info("Count Equivalence Sets With Empty Extension");
		long result = 0;
		long result_without_bn = 0;
		Iterator<Entry<Long, Long>> it = esg.IES.iterator();
		while (it.hasNext()) {
			Entry<Long, Long> e = it.next();
			if (e.getValue() == 0) {
				result++;
				Collection<String> ES = esg.IS.get(e.getKey());
				if (ES.size() == 1 && isBlankNode(ES.iterator().next())) {
					result_without_bn++;
				}
			}
		}

		esg.getStats().es0 = result;
		esg.getStats().es0bns = result - result_without_bn;

	}

	public static void exportIESDistributionAsTSV(RocksDBBackedEquivalenceSetGraph esg, String filepathTSV, double untilPercentage)
			throws IOException {
		logger.info("Exporting IES distribution as TSV {}", filepathTSV);

		Map<Long, Long> result = new HashMap<>();
		Iterator<Entry<Long, Long>> it = esg.IES.iterator();
		while (it.hasNext()) {
			Entry<Long, Long> e = it.next();
			Long s = result.get(e.getValue());
			if (s == null) {
				result.put(e.getValue(), 1L);
			} else {
				result.put(e.getValue(), result.get(e.getValue()) + 1);
			}

		}

		long max = Collections.max(result.keySet());
		logger.info("IES(0): {}", result.get(0L));
		logger.info("Max IES: {} IES({}):{}", max, max, result.get(max));
		long totalNumberOfES = esg.IS.keySet().size();
		long numberOfESsWithSmallerThanCurrentSize = 0;

		FileOutputStream fos = new FileOutputStream(new File(filepathTSV));
		for (long s = 0; s <= max; s++) {
			Long n = result.get(s);
			if (n != null) {
				fos.write((s + "\t" + n + "\n").getBytes());
				numberOfESsWithSmallerThanCurrentSize += n;
				if (((double) numberOfESsWithSmallerThanCurrentSize / (double) totalNumberOfES) > untilPercentage) {
					logger.info("Size at {}:{}", untilPercentage, s);
					break;
				}
			} else {
				fos.write((s + "\t0\n").getBytes());
			}
		}
		fos.close();
		logger.info("IES distribution exported");
	}

	public static void countEdges(RocksDBBackedEquivalenceSetGraph esg) throws IOException {

		logger.info("Counting number of edges");

		long numberOfEdges = 0L;
		Iterator<Entry<Long, Collection<Long>>> it = esg.H.iterator();
		while (it.hasNext()) {
			Entry<Long, Collection<Long>> entry = it.next();
			numberOfEdges += entry.getValue().size();
		}
		esg.getStats().e = numberOfEdges;

	}

	public static void computeHeight(RocksDBBackedEquivalenceSetGraph esg) throws IOException {
		logger.info("Computing maximum height");

		int processed = 0;
		long maxHeigh = 0;
		int cycleNumber = 0;

		int toProcess = esg.IS.keySet().size();

		Map<Long, Long> heightMap = new HashMap<>();

		boolean stop = false;
		long lastDiff = 0;
		while (!stop) {
			long heightMapKeySize = heightMap.keySet().size();
			long currentDiff = toProcess - heightMapKeySize;

			logger.info("Cycle number :: {} max height :: {} :: {} ::{}/{} ", cycleNumber++, maxHeigh,
					(lastDiff - currentDiff), heightMapKeySize, toProcess);

			if (!stop && (lastDiff - currentDiff) == 0) {
				break;
			}

			lastDiff = currentDiff;

			stop = true;
			processed = 0;

			Iterator<Long> iterator = Sets.difference(esg.IS.keySet(), heightMap.keySet()).iterator();
			while (iterator.hasNext()) {
				if (processed % 10000 == 0) {
					logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
				}
				processed++;
				Long key = iterator.next();

				if (!heightMap.containsKey(key) || !checkHeightMap(heightMap, esg.H_inverse)) {
					stop = false;

					Collection<Long> subIS = esg.H_inverse.get(key);
					if (subIS == null || subIS.isEmpty()) {
						// the current node is a leaf
						heightMap.put(key, 0L);
					} else {
						Long max = 0L;
						boolean stopped = false;
						for (Long sub : subIS) {

							if (sub.equals(key)) {
								// continue for self-loops
								continue;
							}

							if (!heightMap.containsKey(sub)) {
								stopped = true;
								break;
							} else {
								long currentSubHeight = heightMap.get(sub);
								if (currentSubHeight > max) {
									max = currentSubHeight;
								}
							}
						}
						if (!stopped) {
							heightMap.put(key, max + 1);

							if (maxHeigh < max + 1) {
								maxHeigh = max + 1;
							}
						}
					}
				}
			}
		}

		processed = 0;

		Set<Long> d = Sets.difference(esg.IS.keySet(), heightMap.keySet());
		Iterator<Long> iterator = d.iterator();
		while (iterator.hasNext()) {
			if (processed % 10000 == 0) {
				logger.info("Processed {}/{}:{}", processed, d.size(), ((double) processed / (double) toProcess));
			}
			processed++;
			long key = iterator.next();

			Collection<Long> subs = esg.H_inverse.get(key);
			long max = 0L;
			long without = 0;
			for (long sub : subs) {
				if (heightMap.containsKey(sub)) {
					long subHeight = heightMap.get(sub);
					if (subHeight > max) {
						max = subHeight;
					}
				} else {
					without++;
				}
			}
			long keyHeight = max + without;
			heightMap.put(key, max + without);
			if (keyHeight > maxHeigh) {
				maxHeigh = keyHeight;
			}
		}

		Iterator<Map.Entry<Long, Long>> hm_it = heightMap.entrySet().iterator();
		long max = 0;
		Map<Long, Long> height_distribution = new HashMap<>();
		while (hm_it.hasNext()) {
			Map.Entry<java.lang.Long, java.lang.Long> entry = (Map.Entry<java.lang.Long, java.lang.Long>) hm_it.next();
			if (entry.getValue() > max) {
				max = entry.getValue();
			}
			if (height_distribution.containsKey(entry.getValue())) {
				height_distribution.put(entry.getValue(), height_distribution.get(entry.getValue()) + 1);
			} else {
				height_distribution.put(entry.getValue(), 1L);
			}
		}

		esg.getStats().h_max = max;
		esg.getStats().heightDistribution = height_distribution;

	}

	private static boolean checkHeightMap(Map<Long, Long> m, RocksMultiMap<Long, Long> H_inverse) {
		for (Long l : H_inverse.keySet()) {

			if (m.get(l) == null)
				return false;

			Collection<Long> subs = H_inverse.get(l);
			long max = 0;
			for (Long ll : subs) {
				if (ll == null) {
					return false;
				} else {
					max = Math.max(max, m.get(ll));
				}
			}

			if (m.get(l) == max + 1) {
				continue;
			}
		}
		return true;
	}

	public static void countIsoltatedEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) throws IOException {
		logger.info("Counting isolated Equivalence Sets");

		int processed = 0;
		int isolatedIS = 0;
		int toProcess = esg.IS.keySet().size();

		Iterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();

		while (iterator.hasNext()) {
			if (processed % 10000 == 0) {
				logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
			}
			processed++;
			Entry<Long, Collection<String>> entry = iterator.next();

			Collection<Long> subSup = Sets.newHashSet();
			if (esg.H.containsKey(entry.getKey())) {
				subSup.addAll(esg.H.get(entry.getKey()));
			}
			if (esg.H_inverse.containsKey(entry.getKey())) {
				subSup.addAll(esg.H_inverse.get(entry.getKey()));
			}

			subSup.remove(entry.getKey());

			if (subSup.isEmpty()) {
				isolatedIS++;
			}

		}
		esg.getStats().in = isolatedIS;

	}

	public static void countTopLevelEquivalenceSetsAndAssessEmptyNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {
		logger.info("Counting Top Level Equivalence Sets And Assess Empty Nodes");

		int processed = 0;
		long tl = 0;
		long tlWithBN = 0;
		long oeInTL = 0;
		long bnInTL = 0;
		long tl0 = 0;
		long tl0WithBNs = 0L;
		long oeInTL0 = 0;
		long oeInTL0WithoutBNs = 0;
		int toProcess = esg.IS.keySet().size();

		Iterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();

		while (iterator.hasNext()) {
			if (processed % 10000 == 0) {
				logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
			}
			processed++;
			Entry<Long, Collection<String>> entry = iterator.next();

			Collection<Long> superES = esg.H.get(entry.getKey());

			if (superES != null)
				superES.remove(entry.getKey());

			if (superES == null || superES.isEmpty()) {

				tl++;

				if (esg.IES.containsKey(entry.getKey()) && esg.IES.get(entry.getKey()) == 0) {
					tl0++;

					for (String uri : entry.getValue()) {
						if (isBlankNode(uri)) {
							tl0WithBNs++;
							break;
						}
					}

				}

				oeInTL += entry.getValue().size();

				for (String uri : entry.getValue()) {
					if (isBlankNode(uri)) {
						tlWithBN++;
						break;
					}
				}
				for (String uri : entry.getValue()) {
					if (isBlankNode(uri)) {
						bnInTL++;
					}

					if (esg.oe_size.containsKey(uri) && esg.oe_size.get(uri) == 0) {
						oeInTL0++;
						if (!isBlankNode(uri)) {
							oeInTL0WithoutBNs++;
						}
					}
				}
			}

		}
		esg.getStats().tl = tl;
		esg.getStats().tlWithoutBNs = tl - tlWithBN;
		esg.getStats().oeInTL = oeInTL;
		esg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;
		esg.getStats().tl0 = tl0;
		esg.getStats().tl0WithoutBNs = tl0 - tl0WithBNs;
		esg.getStats().oeInTL0 = oeInTL0;
		esg.getStats().oeInTl0WithoutBN = oeInTL0WithoutBNs;

	}

	public static void countObservedEntitiesInTopLevelEquivalenceSetsWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg)
			throws IOException {

		logger.info("Counting Observed Entities In Top Level Equivalence Sets With Empty Extesion");

		int processed = 0;
		long tl = 0;
		long tlWithBN = 0;
		long oeInTL = 0;
		long bnInTL = 0;
		int toProcess = esg.IS.keySet().size();

		Iterator<Entry<Long, Collection<String>>> iterator = esg.IS.iterator();

		while (iterator.hasNext()) {
			if (processed % 10000 == 0) {
				logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
			}
			processed++;
			Entry<Long, Collection<String>> entry = iterator.next();

			if (!esg.H.containsKey(entry.getValue())) {
				tl++;
			}

			for (String uri : entry.getValue()) {
				if (isBlankNode(uri)) {
					tlWithBN++;
					break;
				}
			}

			oeInTL += entry.getValue().size();

			for (String uri : entry.getValue()) {
				if (isBlankNode(uri)) {
					bnInTL++;
				}
			}
		}
		esg.getStats().tl = tl;
		esg.getStats().tlWithoutBNs = tl - tlWithBN;
		esg.getStats().oeInTL = oeInTL;
		esg.getStats().oeInTLWithoutBNs = oeInTL - bnInTL;

	}

	private static boolean isBlankNode(String uri) {
		// Exploit skolemization of the blank nodes carried out by LOD Laundromat
		return uri.startsWith("http://lodlaundromat.org/.well-known/genid/");
	}

}
```


Overlapping Code:
```
aphAnalyser {
private static Logger logger = LoggerFactory.getLogger(EquivalenceSetGraphBuilderImpl.class);
public static void countBlankNodes(RocksDBBackedEquivalenceSetGraph esg) throws IOException {
logger.info("Counting number of BlankNodes");
int processed = 0;
int numberOfBlankNodes = 0;
int toProcess = esg.ID.keySet().size();
Set<Long> es_with_bn = new HashSet<>();
Iterator<Entry<String, Long>> iterator = esg.ID.iterator();
while (iterator.hasNext()) {
if (processed % 10000 == 0) {
logger.info("Processed {}/{}:{}", processed, toProcess, ((double) processed / (double) toProcess));
}
processed++;
Entry<String, Long> entry = (Entry<String, Long>) iterator.next();
if (isBlankNode(entry.getKey())) {
numberOfBlankNodes++;
es_with_bn.add(entry.getValue());
}
}
esg.getStats().bns = numberOfBlankNodes;
esg.getStats().es_with_bns = es_with_bn.size();
}
public static void countObservedEntitiesWithEmptyExtesion(RocksDBBackedEquivalenceSetGraph esg) {
logger.info("Counting Number of Observed Entities With Empty Extension");
long result = 0;
long result_without_bn = 0;
Iterator<Entry<String, Long>> it = esg.oe_size.iterator();
while (it.hasNext()) {
Entry<String, Long> e = it.next();
if (e.getValue() == 0) {
result++;
if (!isBlankNode(e.getKey())) {
result_without_bn++;
}
}
}
esg.getStats().oe0 = result;
esg.getStats().oe0_bns = result_without_bn;
}
public static void computeDistributionOfExtensionalSizeOfEquivalenceSets(RocksDBBackedEquivalenceSetGraph esg) {
logger.info("Computing Statistics on Extensional Size of Equivalence Sets");
Map<Long, Long> result = new HashMap<>();
Map<Long, Long> resultPerThreshold = new HashMap<>();
Set<Long> sizeThresholds = Sets.newHashSet(1L, 10L, 100L, 1000L, 1000000L, 1000000000L);
for (Long l : sizeThresholds) {
resultPerThreshold.put(l, 0L);
}
Iterator<Entry<Long, Long>> it = esg.IES.iterator();
while (it.hasNext()) {
Entry<Long, Long> e = it.next();
Long s = result.get(e.getValue());
if (s == null) {
result.put(e.getValue(), 1L);
} else {
result.put(e.getValue(), result.get(e.getValue()) + 1);
}
for (Long l : sizeThresholds) {
if (e.getValue() > l) {
resultPerThreshold.put(l, resultPerThreshold.get(l) + 1);
}
}
}
esg.getStats().indirectExtensionalSizeDistribution = result;
esg.ge
```
<Overlap Ratio: 0.9689922480620154>

---

--- 19 --
Question ID: aee52a7e776d5b80b99cec6deff00aaf4dbdae38
Original Code:
```
public class Or
extends Predicate
{
    private static final String OR001 = "JSONValidator/Or/001: All or rules failed for value '%s' in rule '%s'.";
    private List<Validator> rules = new LinkedList<Validator>();

    public Or(String aName, JSONObject aRule, HashMap<String,Validator> aRuleset)
    throws ValidationException
    {
        super(aName);
        ValidatorUtil.requiresAttribute(aRule, ValidatorUtil.PARAM_RULES, JSONArray.class);

        List<JSONValue> lRules = ((JSONArray) aRule.get(ValidatorUtil.PARAM_RULES)).getValue();
        for (JSONValue lRule : lRules)
        {
            Validator lValidator = ValidatorUtil.buildValidator(lRule, aRuleset);
            rules.add(lValidator);
        }
    }

    public Or(String aName, Validator ... validators) {
        super(aName);
        rules.addAll(Arrays.asList(validators));
    }

    public void validate(JSONValue aValue)
    throws ValidationException
    {
        for (Validator rule1 : rules)
        {
            try
            {
                rule1.validate(aValue);
                // If we get here, the current validator succeeded.
                // We only need a single success!
                return;
            }
            catch (ValidationException e)
            {
                // This rule failed. Ignore for the time being.
                // Try the other ones first.
            }
        }
        // If we get here, then all rules failed.
        // If all rules fail, we fail as well.
        throw new ValidationException(String.format(OR001, aValue.toString(), this.getName()));
    }
}
```


Overlapping Code:
```
ic class Or
extends Predicate
{
private static final String OR001 = "JSONValidator/Or/001: All or rules failed for value '%s' in rule '%s'.";
private List<Validator> rules = new LinkedList<Validator>();
public Or(String aName, JSONObject aRule, HashMap<String,Validator> aRuleset)
throws ValidationException
{
super(aName);
ValidatorUtil.requiresAttribute(aRule, ValidatorUtil.PARAM_RULES, JSONArray.class);
List<JSONValue> lRules = ((JSONArray) aRule.get(ValidatorUtil.PARAM_RULES)).getValue();
for (JSONValue lRule : lRules)
{
Validator lValidator = ValidatorUtil.buildValidator(lRule, aRuleset);
rules.add(lValidator);
}
}
public Or(String aName, Validator ... validators) {
super(aName);
rules.addAll(Arrays.asList(validators));
}
public void validate(JSONValue aValue)
throws ValidationException
{
for (Validator rule1 : rules)
{
try
{
rule1.validate(aValue);
// If we get here, the current validator succeeded.
// We only need a single success!
return;
}
catch (ValidationException e)
{
// This rule failed. Ignore for the time being.
// Try the other ones first.
}
}
// If we get here, then all rules failed.
// If all rules fail, we fail as well.
throw new ValidationException(String.format(O
```
<Overlap Ratio: 0.96>

---

--- 20 --
Question ID: 59ec5aac2939187bfdce37408bda681df066ab53
Original Code:
```
public class FeatureFactory<E extends Tag>
{

    public MultiMap<E, Marker> planSteps = new MultiMap();
    public Map<Double, FactoryEvent> events = new LinkedHashMap();
//    private MultiMap<Bar, Edge> planEdgeToBar;
    public PlanSkeleton plan;
    // map between forced-step-added-plan-edges and their features
    public Map<Edge, Set<Tag>> newEdgeFeatures = new LinkedHashMap();

    protected E feature;

    public FeatureFactory(E feature)
    {
        this.feature = feature;
    }

    /**
     * If using this function to announce the creation of new profiles edgeToBar should
     * be updated in PlanSkeleton.
     */
    public void add( Collection<Profile> newProfiles, Iterable<Bar> planBars, double heightOffset )
    {
        for ( Bar b : planBars )
            for ( Marker m : b.mould.markersOn( b ) )
                if ( m.feature.getClass() == feature.getClass() )
                    planSteps.put( (E) m.feature, m );

        for ( Global global : plan.plan.globals )
            for ( Profile profile : newProfiles ) // add each profile once
            {
                List<Loop<Bar>> chainStarts = profile.globalProfiles.get(global).chainStarts;
                // here we only loop over profiles defined by a global. Other profiles (from forced steps) aren't processed.

                for ( int valency = 0; valency < chainStarts.size(); valency++ )
                    for ( Bar bar : chainStarts.get( valency ) )
                        for ( Marker m : bar.mould.markersOn( bar ) )
                            // if the profile marker has the correct class
                            if ( feature.getClass().isInstance(m.feature) )//was class == class
                            {
                                double height = -m.y + heightOffset;
                                FactoryEvent evt = events.get( height );
                                if ( evt == null )
                                {
                                    evt = createFactoryEvent( height, global, chainStarts.size() == 1 ? 0 : valency ); // was 1-valency...
                                    events.put( height, evt );
                                }

                                // for plan markers with the same feature
                                for ( Marker planMarker : planSteps.get( (E) m.feature ) )
                                    // if the plan marker is on a bar with the correct profile
                                    if ( plan.plan.profiles.get( planMarker.bar ) == profile )
                                        // schedule an plan marker at this height, along with the profile feature
                                        evt.changesToMake.add( new Anchor( (E) m.feature, planMarker ) );
                            }
            }
    }

    public void add( PlanSkeleton plan )
    {
        this.plan = plan;
        add( new LinkedHashSet<Profile>( plan.plan.profiles.values() ), plan.plan.points.eIterator(), 0 ); // add each profile once
    }

    public FactoryEvent createFactoryEvent( double height, Global g, int valency )
    {
        return new FactoryEvent( height, g, valency );
    }

    /**
     * An anchor that hasn't yet been resolved to
     */
    public class Anchor
    {
        public E profileFeature;
        public Marker planMarker;

        private Anchor( E step, Marker planMarker )
        {
            this.profileFeature = step;
            this.planMarker = planMarker;
        }
    }

    public void addToSkeleton( Skeleton skel )
    {
        for (HeightEvent he : events.values())
            skel.qu.add( he );

        // we add more events mid-sequence, so best to keep this clear
        events.clear();
    }

    /**
     * a map from each plan marker, to the points it generated
     * @param points
     */
    public void addPoints ( MultiMap<Marker, Matrix4d> points )
    {
        // override me!
    }

    public class FactoryEvent implements HeightEvent
    {
        Global global;
        int valency;
        double height;
        public Set<Anchor> changesToMake = new LinkedHashSet();
        public Map<Loop<Bar>, Machine> profiles = new LinkedHashMap();

        public FactoryEvent( double height, Global global, int valency )
        {
            this.height = height;
            this.global = global;
            this.valency = valency;
        }

        public double getHeight()
        {
            return height;
        }

        public boolean process( Skeleton skel_ )
        {
            PlanSkeleton skel = (PlanSkeleton)skel_;
//            List<Matrix4d> pts = new ArrayList();
            MultiMap<Marker, Matrix4d> pts = new MultiMap();

            for ( Anchor anchor : changesToMake )
            {
                
                final Marker planM = anchor.planMarker;

                Set<Corner> edges = plan.findLiveEdgesFrom( planM.bar );

                // the plan is valid for these corners, but is the edge's profile valid?
                Iterator<Corner> eit = edges.iterator();
                while ( eit.hasNext() )
                {
                    Corner c = eit.next();
                    if ( skel.getGlobalForEdge( c.nextL ) != global )
                    {
                        eit.remove();
                        continue;
                    }
                    if ( skel.getValencyForEdge( c.nextL ) != valency )
                        eit.remove();
                }

                LinearForm3D ceiling = new LinearForm3D( 0, 0, 1, -height );

                edges:
                for ( Corner c : edges )
                {
                    Tuple3d start = c.nextL.linearForm.collide( c.prevL.linearForm, ceiling);
                    Tuple3d end = c.nextL.linearForm.collide( c.nextC.nextL.linearForm, ceiling);

                    // translation component of the
                    Vector3d tran = null;
                    switch ( (Marker.Type) planM.properties.get( Marker.TYPE ) )
                    {
                        case AbsEnd:
                        case AbsStart:
                            // do a straight projection (this isn't rotated to the current frame of the bar - eg: won't work with nested features)
                            Vector3d delta = new Vector3d(end); delta.sub(start);
                            Ray3d atSPlane = new Ray3d( start, delta );
                            Point3d res = atSPlane.projectSegment( new Point3d (planM.x, planM.y, 0 ) );
                            tran = res == null ? null : new Vector3d ( res );
                            break;
                        case Rel:
                            // relative to line length
                            Line reference = new Line( planM.bar.start, planM.bar.end );
                            double p = reference.findPPram( planM );
                            tran = new Vector3d (end);
                            tran.sub( start );
                            tran.scale( p );
                            tran.add( start ); // dir is now the translation component
                            break;
                    }

                    // point didn't project onto polygon at current height, move onto nextl
                    if (tran == null)
                        continue edges;

                    // we only compensate for rotation around the vertical line :(
                    Matrix3d orientation = new Matrix3d();
                    Vector3d eDir = c.nextL.direction();
                    eDir.normalize();

                    // fixme: rotation conversion to jme space occurs here. it shouldn't. hack!
                    AxisAngle4d aa = new AxisAngle4d( new Vector3d (0,1,0), -Math.atan2( eDir.y, eDir.x) );
                    orientation.set( aa );
                    pts.put( planM, new Matrix4d(orientation, tran, 1) );
                }
            }

            FeatureFactory.this.addPoints( pts );

           
            return false; // not doing anything :)
        }
    }
}
```


Overlapping Code:
```
{
public MultiMap<E, Marker> planSteps = new MultiMap();
public Map<Double, FactoryEvent> events = new LinkedHashMap();
// private MultiMap<Bar, Edge> planEdgeToBar;
public PlanSkeleton plan;
// map between forced-step-added-plan-edges and their features
public Map<Edge, Set<Tag>> newEdgeFeatures = new LinkedHashMap();
protected E feature;
public FeatureFactory(E feature)
{
this.feature = feature;
}
/**
* If using this function to announce the creation of new profiles edgeToBar should
* be updated in PlanSkeleton.
*/
public void add( Collection<Profile> newProfiles, Iterable<Bar> planBars, double heightOffset )
{
for ( Bar b : planBars )
for ( Marker m : b.mould.markersOn( b ) )
if ( m.feature.getClass() == feature.getClass() )
planSteps.put( (E) m.feature, m );
for ( Global global : plan.plan.globals )
for ( Profile profile : newProfiles ) // add each profile once
{
List<Loop<Bar>> chainStarts = profile.globalProfiles.get(global).chainStarts;
// here we only loop over profiles defined by a global. Other profiles (from forced steps) aren't processed.
for ( int valency = 0; valency < chainStarts.size(); valency++ )
for ( Bar bar : chainStarts.get( valency ) )
for ( Marker m : bar.mould.markersOn( bar ) )
// if the profile marker has the correct class
if ( feature.getClass().isInstance(m.feature) )//was class == class
{
double height = -m.y + heightOffset;
FactoryEvent evt = events.get( height );
if ( evt == null )
{
evt = createFactoryEvent( height, global, chainStarts.size() == 1 ? 0 : valency ); // was 1-valency...
events.put( height, evt );
}
// for plan markers with the same feature
for ( Marker planMarker : planSteps.get( (E) m.feature ) )
// if the plan marker is on 
```
<Overlap Ratio: 0.9518477043673013>

---

--- 21 --
Question ID: e04cfa39f69e8a248a0f05b7a63558725899d1d0
Original Code:
```
public class TradingBalanceRestClient {

    private static final String RESOURCE_PATH = "/trading/balance";
    private static final String REQUEST_URI = HitBtcAPI.BASE_URL + RESOURCE_PATH;
    private static final Log LOG = LogFactory.getLog(HistoricalOrderRestClient.class);

    public static List<Balance> getBalances(HitBtcAPI hitBtcAPI) {
        ApiAuthRequest<Balance> apiAuthRequest = new ApiAuthRequest<>(hitBtcAPI);
        List<Balance> balances = apiAuthRequest.getListRequest(REQUEST_URI, Balance[].class);

        if (balances.isEmpty())
            LOG.error("There was an Error in retrieving Balances");

        return balances;
    }

    public static Optional<Balance> getBalance(HitBtcAPI hitBtcAPI, String currency) {
        List<Balance> balances = getBalances(hitBtcAPI);

        for (Balance singleBalance : balances)
            if (singleBalance.getCurrency().equals(currency))
                return Optional.of(singleBalance);

        return Optional.empty();
    }
}
```


Overlapping Code:
```
public class TradingBalanceRestClient {
private static final String RESOURCE_PATH = "/trading/balance";
private static final String REQUEST_URI = HitBtcAPI.BASE_URL + RESOURCE_PATH;
private static final Log LOG = LogFactory.getLog(HistoricalOrderRestClient.class);
public static List<Balance> getBalances(HitBtcAPI hitBtcAPI) {
ApiAuthRequest<Balance> apiAuthRequest = new ApiAuthRequest<>(hitBtcAPI);
List<Balance> balances = apiAuthRequest.getListRequest(REQUEST_URI, Balance[].class);
if (balances.isEmpty())
LOG.error("There was an Error in retrieving Balances");
return balances;
}
public static Optional<Balance> getBalance(HitBtcAPI hitBtcAPI, String currency) {
List<Balance> balances = getBalances(hitBtcAPI);
for (Balance singleBalance : balances)
if (singleBalance.getCurrency().equals(currency))
return Optional.of(singleBalance);
return 
```
<Overlap Ratio: 0.9758897818599311>

---

--- 22 --
Question ID: dd3622f796fcad1346fb98b41c0e76621ebca8ff
Original Code:
```
public class MockResponseTest {

    @Test
    public void testJson() throws Exception {
        Observable<String> jsonObservable = MockResponse.generateJson(736L, 1, 1000, 5);
        String json = jsonObservable.toBlockingObservable().single();
        System.out.println(json);
        assertTrue(json.startsWith("{\"responseKey\":" + MockResponse.getResponseKey(736L) + ",\"delay\":1,\"itemSize\":1000,\"numItems\":5,\"items\""));
        System.out.println("json: " + json);
    }

}
```


Overlapping Code:
```
esponseTest {
@Test
public void testJson() throws Exception {
Observable<String> jsonObservable = MockResponse.generateJson(736L, 1, 1000, 5);
String json = jsonObservable.toBlockingObservable().single();
System.out.println(json);
assertTrue(json.startsWith("{\"responseKey\":" + MockResponse.getResponseKey(736L) + ",\"delay\":1,\"itemSize\":1000,\"numItems\":5,\"items\""));
System.out.println("jso
```
<Overlap Ratio: 0.9195402298850575>

---

--- 23 --
Question ID: 4dae79b946ac622ea052f19661d159d8186a03e6
Original Code:
```
public class RegrasNegocioItemInspecao {

    public static void validarItemInspecao(ItemInspecaoVO i, Boolean isInclusao, Connection conn) throws Exception {

//        5.5. Regras de negócio
//        5.5.1. [RN01] Nomes de itens de pontuação devem conter no máximo 30 caracteres;
        if (i.getNome().length() > 30) {
            throw new Exception("Nome deve conter no máximo 30 caracteres");
        }



        if (isInclusao) {

            ItemInspecaoDAO daoItemInspecao;
            daoItemInspecao= new ItemInspecaoDAO(conn);

//        5.5.2. [RN02] Não é permitido duplicar nomes de Itens de pontuação;
            if (daoItemInspecao.existeItemInspecao(i.getNome())) {
                throw new Exception("Nome de item já existente");
            }
        }


//        5.5.3. [RN03] Não é permitido duplicar nomes de Áreas;
        //OK


//        5.5.4. [RN04] A pontuação mínima deve ser maior ou igual a zero;
        if(i.getPontuacaoMinima().doubleValue() < new BigDecimal(0).doubleValue()){
            throw new Exception("A pontuação mínima deve ser maior ou igual a zero");
        }

//        5.5.5. [RN05] A pontuação máxima não deve ultrapassar o valor de “999,99”;
        if(i.getPontuacaoMaxima().doubleValue() > new BigDecimal(999.99).doubleValue()){
            throw new Exception("A pontuação máxima não deve ultrapassar o valor de 999,99");
        }

//        5.5.6. [RN06] Os campos Valor Mínimo e Valor Máximo devem conter cinco dígitos, sendo dois após a virgula;
//        5.5.7. [RN07] Caso não sejam respeitadas as regras [RN01] até [RN06], avisar o usuário via mensagem na tela.
//        5.5.8. O conteúdo das comboBox deve estar classificado em ordem crescente;
//        5.5.9. As comboBox devem ser apresentadas preenchidas, com o primeiro registro encontrado após a ordenação.









    }
}
```


Overlapping Code:
```
gocioItemInspecao {
public static void validarItemInspecao(ItemInspecaoVO i, Boolean isInclusao, Connection conn) throws Exception {
// 5.5. Regras de negócio
// 5.5.1. [RN01] Nomes de itens de pontuação devem conter no máximo 30 caracteres;
if (i.getNome().length() > 30) {
throw new Exception("Nome deve conter no máximo 30 caracteres");
}
if (isInclusao) {
ItemInspecaoDAO daoItemInspecao;
daoItemInspecao= new ItemInspecaoDAO(conn);
// 5.5.2. [RN02] Não é permitido duplicar nomes de Itens de pontuação;
if (daoItemInspecao.existeItemInspecao(i.getNome())) {
throw new Exception("Nome de item já existente");
}
}
// 5.5.3. [RN03] Não é permitido duplicar nomes de Áreas;
//OK
// 5.5.4. [RN04] A pontuação mínima deve ser maior ou igual a zero;
if(i.getPontuacaoMinima().doubleValue() < new BigDecimal(0).doubleValue()){
throw new Exception("A pontuação mínima deve ser maior ou igual a zero");
}
// 5.5.5. [RN05] A pontuação máxima não deve ultrapassar o valor de “999,99”;
if(i.getPontuacaoMaxima().doubleValue() > new BigDecimal(999.99).doubleValue()){
throw new Exception("A pontuação máxima não deve ultrapassar o valor de 999,99");
}
// 5.5.6. [RN06] Os campos Valor Mínimo e Valor Máximo devem conter cinco dígitos, sendo dois após a virgula;
// 5.5.7. [RN07] Caso não sejam respeitadas as regras [RN01] até [RN06], avisar o usuário via mensagem na tela.
// 5.5.8. O conteúdo das comboBox deve estar classificado em ordem crescente;
// 5.5.9. As comboBox devem ser apresentadas preenchidas, com o primeiro registro encontrado após a ordenaç
```
<Overlap Ratio: 0.982256020278834>

---

--- 24 --
Question ID: a3a26c5cab8bf4fa3d1459a05160e3090acda6aa
Original Code:
```
public class BukkitRepository<T> {

    private final Plugin plugin;

    private boolean async;
    private Function<Player, T> loadAction, findAction;
    private BiConsumer<Player, T> saveAction, onLoaded, onSaved;

    public BukkitRepository(Plugin plugin) {
        this.plugin = plugin;
        this.async = ImanityCommon.CORE_CONFIG.ASYNCHRONOUS_DATA_STORING;
    }

    public BukkitRepository<T> async() {
        this.async = true;
        return this;
    }

    public BukkitRepository<T> load(Function<Player, T> loadAction) {
        this.loadAction = loadAction;
        return this;
    }

    public BukkitRepository<T> find(Function<Player, T> findAction) {
        this.findAction = findAction;
        return this;
    }

    public BukkitRepository<T> save(BiConsumer<Player, T> saveAction) {
        this.saveAction = saveAction;
        return this;
    }

    public BukkitRepository<T> onLoaded(BiConsumer<Player, T> consumer) {
        this.onLoaded = consumer;
        return this;
    }

    public BukkitRepository<T> onSaved(BiConsumer<Player, T> consumer) {
        this.onSaved = consumer;
        return this;
    }

    public void init() {
        Preconditions.checkNotNull(this.loadAction, "The loadAction is not being set!");

        Events.subscribe(PlayerJoinEvent.class)
                .listen((subscription, event) -> {
                    Player player = event.getPlayer();

                    Runnable runnable = () -> {
                        T t = this.loadAction.apply(player);
                        if (this.onLoaded != null) {
                            this.onLoaded.accept(player, t);
                        }
                    };

                    if (this.async) {
                        TaskUtil.runAsync(runnable);
                    } else {
                        runnable.run();
                    }
                })
        .build(plugin);

        if (this.saveAction != null) {
            Events.subscribe(PlayerQuitEvent.class)
                    .listen((subscription, event) -> {
                        Player player = event.getPlayer();

                        Runnable runnable = () -> {
                            T t = findAction != null ? findAction.apply(player) : loadAction.apply(player);
                            this.saveAction.accept(player, t);
                            if (this.onSaved != null) {
                                this.onSaved.accept(player, t);
                            }
                        };

                        if (this.async) {
                            TaskUtil.runAsync(runnable);
                        } else {
                            runnable.run();
                        }
                    })
                    .build(plugin);
        }
    }

}
```


Overlapping Code:
```
tRepository<T> {
private final Plugin plugin;
private boolean async;
private Function<Player, T> loadAction, findAction;
private BiConsumer<Player, T> saveAction, onLoaded, onSaved;
public BukkitRepository(Plugin plugin) {
this.plugin = plugin;
this.async = ImanityCommon.CORE_CONFIG.ASYNCHRONOUS_DATA_STORING;
}
public BukkitRepository<T> async() {
this.async = true;
return this;
}
public BukkitRepository<T> load(Function<Player, T> loadAction) {
this.loadAction = loadAction;
return this;
}
public BukkitRepository<T> find(Function<Player, T> findAction) {
this.findAction = findAction;
return this;
}
public BukkitRepository<T> save(BiConsumer<Player, T> saveAction) {
this.saveAction = saveAction;
return this;
}
public BukkitRepository<T> onLoaded(BiConsumer<Player, T> consumer) {
this.onLoaded = consumer;
return this;
}
public BukkitRepository<T> onSaved(BiConsumer<Player, T> consumer) {
this.onSaved = consumer;
return this;
}
public void init() {
Preconditions.checkNotNull(this.loadAction, "The loadAction is not being set!");
Events.subscribe(PlayerJoinEvent.class)
.listen((subscription, event) -> {
Player player = event.getPlayer();
Runnable runnable = () -> {
T t = this.loadAction.apply(player);
if (this.onLoaded != null) {
this.onLoaded.accept(player, t);
}
};
if (this.async) {
TaskUtil.runAsync(runnable);
} else {
runnable.run();
}
})
.build(plugin);
if (this.saveAction != null) {
Events.subscribe(PlayerQuitEvent.class)
.listen((subscription, event) -> {
Player player = event.getPlayer();
Runnable runnable = () -> {
T t = findAction != null ? findAction.apply(player) : loadAction.apply(player);
this.saveAction.accept(player, t);
if (this.onSaved != null) {
this.onSaved
```
<Overlap Ratio: 0.9775733179988499>

---

--- 25 --
Question ID: 4693e9363bd9c4520301c9fd7a76759876723f1c
Original Code:
```
@Path(IndexClient.SERVICE_PATH)
@Produces({"application/xml"})
@Consumes({"application/xml"})
public class IndexResource extends NuxeoBasedResource {

    @Override
    public String getServiceName(){
        return IndexClient.SERVICE_NAME;
    }

    @Override
    protected String getVersionString() {
    	final String lastChangeRevision = "$LastChangedRevision: 2108 $";
    	return lastChangeRevision;
    }

    @Override
    //public Class<ObjectexitCommon> getCommonPartClass() {
    public Class<?> getCommonPartClass() {
    	try {
            return Class.forName("org.collectionspace.services.objectexit.IndexCommon");//.class;
        } catch (ClassNotFoundException e){
            return null;
        }
    }
    
	/*
	 * HTTP Methods
	 */
    
	@Override
	@POST
	public Response create(@Context ResourceMap resourceMap, @Context UriInfo ui, String xmlPayload) {
		Response response = Response.status(Response.Status.BAD_REQUEST)
				.entity(ServiceMessages.POST_UNSUPPORTED).type("text/plain").build();
		return response;
	}
	
    @Override
	@DELETE
    @Path("{csid}")
    public Response delete(@PathParam("csid") String csid) {
		Response response = Response.status(Response.Status.BAD_REQUEST)
				.entity(ServiceMessages.DELETE_UNSUPPORTED).type("text/plain")
				.build();
		return response;
    }
    
	@POST
    @Path("{indexid}")
	public Response reindex(
            @Context Request request,
            @Context UriInfo uriInfo,
            @PathParam("indexid") String indexid) {
    	uriInfo = new UriInfoWrapper(uriInfo);
       	Response result = Response.ok().build();
       	boolean success = false;
       	String docType = null;
       	
        try {
            RemoteServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = (RemoteServiceContext<PoxPayloadIn, PoxPayloadOut>) createServiceContext(uriInfo);
            docType = ctx.getTenantQualifiedDoctype(); // this will used in the error message if an error occurs
            DocumentHandler handler = createDocumentHandler(ctx);
            success = getRepositoryClient(ctx).reindex(handler, indexid);
        } catch (Exception e) {
            throw bigReThrow(e, ServiceMessages.REINDEX_FAILED);
        }
        
        if (success == false) {
            Response response = Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(
                    ServiceMessages.REINDEX_FAILED + ServiceMessages.indexResourceNotFoundMsg(indexid)).type("text/plain").build();
            throw new CSWebApplicationException(response);
        }
       	
       	return result;
    }
    
	/* (non-Javadoc)
	 * @see org.collectionspace.services.common.ResourceBase#getList(javax.ws.rs.core.UriInfo, java.lang.String)
	 * 
	 * The index sub-resource does not support a getList operation.
	 */
	@Override
	@GET
	public AbstractCommonList getList(@Context UriInfo ui) {
		Response response = Response.status(Response.Status.BAD_REQUEST)
				.entity(ServiceMessages.GET_LIST_UNSUPPORTED).type("text/plain")
				.build();
		throw new CSWebApplicationException(response);
	}

	@Override
	public AbstractCommonList getList(ServiceContext<PoxPayloadIn, PoxPayloadOut> parentCtx, UriInfo uriInfo) {
		throw new UnsupportedOperationException();
	}
}
```


Overlapping Code:
```
t.SERVICE_PATH)
@Produces({"application/xml"})
@Consumes({"application/xml"})
public class IndexResource extends NuxeoBasedResource {
@Override
public String getServiceName(){
return IndexClient.SERVICE_NAME;
}
@Override
protected String getVersionString() {
final String lastChangeRevision = "$LastChangedRevision: 2108 $";
return lastChangeRevision;
}
@Override
//public Class<ObjectexitCommon> getCommonPartClass() {
public Class<?> getCommonPartClass() {
try {
return Class.forName("org.collectionspace.services.objectexit.IndexCommon");//.class;
} catch (ClassNotFoundException e){
return null;
}
}

/*
* HTTP Methods
*/

@Override
@POST
public Response create(@Context ResourceMap resourceMap, @Context UriInfo ui, String xmlPayload) {
Response response = Response.status(Response.Status.BAD_REQUEST)
.entity(ServiceMessages.POST_UNSUPPORTED).type("text/plain").build();
return response;
}

@Override
@DELETE
@Path("{csid}")
public Response delete(@PathParam("csid") String csid) {
Response response = Response.status(Response.Status.BAD_REQUEST)
.entity(ServiceMessages.DELETE_UNSUPPORTED).type("text/plain")
.build();
return response;
}

@POST
@Path("{indexid}")
public Response reindex(
@Context Request request,
@Context UriInfo uriInfo,
@PathParam("indexid") String indexid) {
uriInfo = new UriInfoWrapper(uriInfo);
Response result = Response.ok().build();
boolean success = false;
String docType = null;

try {
RemoteServiceContext<PoxPayloadIn, PoxPayloadOut> ctx = (RemoteServiceContext<PoxPayloadIn, PoxPayloadOut>) createServiceContext(uriInfo);
docType = ctx.getTenantQualifiedDoctype(); // this will used in the error message if an error occurs
DocumentHandler handler = createDocumentHandler(ctx);
success = getRepositoryClient(ctx).reindex(handler, indexid);
} catch (Exception e) {
throw bigReThrow(e, ServiceMessages.REINDEX_FAILED);
}

if (success == false) {
Response response = Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(
ServiceMessages.REINDEX_FAILED + ServiceMessages.indexResourceNotFoundMsg(indexid)).type("text/plain").build
```
<Overlap Ratio: 0.9824727617243013>

---

--- 26 --
Question ID: 1a1be5d60cc2bf79fef5aa7cd007b6bf125a990f
Original Code:
```
public class TestXAActiveMQProducer {

    public static void main(String[] args) throws JMSException, XAException {
        XAConnectionFactory xaFactory = new ActiveMQXAConnectionFactory("tcp://localhost:61616");
        XAConnection xaCon = xaFactory.createXAConnection();
        xaCon.start();

        Xid xId = createXid(1); // Global transaction ID
        XASession xaSession = xaCon.createXASession();
        // XAResource is not in sql/jms package, it is in javax.transaction because it is common for all resource types
        XAResource xaResource = xaSession.getXAResource();

        // Mark work as started
        xaResource.start(xId, XAResource.TMNOFLAGS);

        // Work like with regular JMS core
        Session session = xaSession.getSession();
        Destination queue = session.createQueue("JMS.XA.QUEUE1");
        Destination queue2 = session.createQueue("JMS.XA.QUEUE2");

        MessageProducer producer1 = session.createProducer(queue);
        producer1.send(session.createTextMessage("message"));

        MessageProducer producer2 = session.createProducer(queue2);
        producer2.send(session.createTextMessage("message2"));

        xaResource.end(xId, XAResource.TMSUCCESS);

        int vote = xaResource.prepare(xId);

        xaResource.rollback(xId);

        if (vote == XAResource.XA_OK) {
            System.out.println("Commit XA transaction");
            xaResource.commit(xId, false); // Message goes to both queues
        } else {
            System.out.println("Rollback XA transaction");
            xaResource.rollback(xId); // Message doens't go to any queue
        }

        session.close();

        xaSession.close();
        xaCon.close();
    }

    public static Xid createXid(int bids) {
        byte[] gid = new byte[1];
        gid[0] = (byte) 9;
        byte[] bid = new byte[1];
        bid[0] = (byte) bids;
        byte[] gtrid = new byte[64];
        byte[] bqual = new byte[64];
        System.arraycopy(gid, 0, gtrid, 0, 1);
        System.arraycopy(bid, 0, bqual, 0, 1);
        // TODO can we use any Xid implementation when we do transaction across MySQL and ActiveMQ?
        return new MysqlXid(gtrid, bqual, 0x1234);
    }
}
```


Overlapping Code:
```
eMQProducer {
public static void main(String[] args) throws JMSException, XAException {
XAConnectionFactory xaFactory = new ActiveMQXAConnectionFactory("tcp://localhost:61616");
XAConnection xaCon = xaFactory.createXAConnection();
xaCon.start();
Xid xId = createXid(1); // Global transaction ID
XASession xaSession = xaCon.createXASession();
// XAResource is not in sql/jms package, it is in javax.transaction because it is common for all resource types
XAResource xaResource = xaSession.getXAResource();
// Mark work as started
xaResource.start(xId, XAResource.TMNOFLAGS);
// Work like with regular JMS core
Session session = xaSession.getSession();
Destination queue = session.createQueue("JMS.XA.QUEUE1");
Destination queue2 = session.createQueue("JMS.XA.QUEUE2");
MessageProducer producer1 = session.createProducer(queue);
producer1.send(session.createTextMessage("message"));
MessageProducer producer2 = session.createProducer(queue2);
producer2.send(session.createTextMessage("message2"));
xaResource.end(xId, XAResource.TMSUCCESS);
int vote = xaResource.prepare(xId);
xaResource.rollback(xId);
if (vote == XAResource.XA_OK) {
System.out.println("Commit XA transaction");
xaResource.commit(xId, false); // Message goes to both queues
} else {
System.out.println("Rollback XA transaction");
xaResource.rollback(xId); // Message doens't go to any queue
}
session.close();
xaSession.close();
xaCon.close();
}
public static Xid createXid(int bids) {
byte[] gid = new byte[1];
gid[0] = (byte) 9;
byte[] bid = new byte[1];
bid[0] = (byte) bids;
byte[] gtrid = new byte[64];
byte[] bqual = new byte[64];
System.arraycopy(gid, 0, gtrid, 0, 1);
System.arraycopy(bid, 0, bqual, 0, 1);
// TODO can we use any Xid implementation when we do transaction across MySQL and ActiveMQ?
```
<Overlap Ratio: 0.9614758545849159>

---

--- 27 --
Question ID: 4dc6e4dcb47ccb81335c3ad3a0a35509ef12b238
Original Code:
```
public class ChunkSnapshot
{
	private final int x;
	private final int z;
	private final boolean worldHasNoSky;
	private final ExtendedBlockStorage[] ebsArr;
	private final byte[] biomeArray;

	private ChunkSnapshot(int x, int z, boolean worldHasNoSky, ExtendedBlockStorage[] ebsArr, byte[] biomeArray)
	{
		this.x = x;
		this.z = z;
		this.worldHasNoSky = worldHasNoSky;
		this.ebsArr = ebsArr;
		this.biomeArray = biomeArray;
	}

	public static ChunkSnapshot of(Chunk chunk)
	{
		ExtendedBlockStorage[] ebsOld = chunk.getBlockStorageArray();
		ExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];
		for(int i = 0; i < ebsOld.length; i++)
			ebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();
		byte[] biomeArray = chunk.getBiomeArray();
		return new ChunkSnapshot(chunk.xPosition, chunk.zPosition, chunk.worldObj.provider.hasNoSky, ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));
	}

	public int getX()
	{
		return x;
	}

	public int getZ()
	{
		return z;
	}

	public boolean isWorldHasNoSky()
	{
		return worldHasNoSky;
	}

	public ExtendedBlockStorage[] getEbsArr()
	{
		return ebsArr;
	}

	public byte[] getBiomeArray()
	{
		return biomeArray;
	}

	public void release()
	{
		for(ExtendedBlockStorage ebs : ebsArr)
			if(ebs != null)
				ebs.release();
	}

	public ChunkSnapshot copy()
	{
		ExtendedBlockStorage[] ebsOld = ebsArr;
		ExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];
		for(int i = 0; i < ebsOld.length; i++)
			ebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();
		byte[] biomeArray = this.biomeArray;
		return new ChunkSnapshot(getX(), getZ(), isWorldHasNoSky(), ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));
	}

	private static void rangeCheck(int x, int z)
	{
		if((x & 0xFFFFFFF0) != 0 || (z & 0xFFFFFFF0) != 0)
			throw new IllegalArgumentException();
	}

	public Block getBlock(int x, int y, int z)
	{
		rangeCheck(x, z);
		ExtendedBlockStorage ebs = ebsArr[y >> 4];
		if(ebs != null)
			return ebs.getBlockByExtId(x, y & 15, z);
		return Blocks.air;
	}

	public int getBlockId(int x, int y, int z)
	{
		rangeCheck(x, z);
		ExtendedBlockStorage ebs = ebsArr[y >> 4];
		if(ebs != null)
			return ebs.getSlot().getBlockId(x, y & 15, z);
		return 0;
	}

	public int getBlockMeta(int x, int y, int z)
	{
		rangeCheck(x, z);
		ExtendedBlockStorage ebs = ebsArr[y >> 4];
		if(ebs != null)
			return ebs.getExtBlockMetadata(x, y & 15, z);
		return 0;
	}

	public int getBlockIdAndMeta(int x, int y, int z)
	{
		rangeCheck(x, z);
		ExtendedBlockStorage ebs = ebsArr[y >> 4];
		if(ebs != null)
			return ebs.getSlot().getBlockIdAndMeta(x, y & 15, z);
		return 0;
	}

	public void setBlock(int x, int y, int z, int blockId, int meta)
	{
		rangeCheck(x, z);
		ExtendedBlockStorage ebs = ebsArr[y >> 4];
		if(ebs == null)
			ebs = ebsArr[y >> 4] = new ExtendedBlockStorage(y >> 4 << 4, true);
		ebs.getSlot().setBlockIdAndMeta(x, y & 15, z, blockId, meta);
		if(ebs.isEmpty())
			ebs.incBlockRefCount();
	}

	public void setBlock(int x, int y, int z, Block block, int meta)
	{
		setBlock(x, y, z, Block.getIdFromBlock(block), meta);
	}

	public int getTopFilledSegment()
	{
		for (int i = ebsArr.length - 1; i >= 0; --i)
			if(ebsArr[i] != null)
				return ebsArr[i].getYLocation();

		return 0;
	}
}
```


Overlapping Code:
```
Snapshot
{
private final int x;
private final int z;
private final boolean worldHasNoSky;
private final ExtendedBlockStorage[] ebsArr;
private final byte[] biomeArray;
private ChunkSnapshot(int x, int z, boolean worldHasNoSky, ExtendedBlockStorage[] ebsArr, byte[] biomeArray)
{
this.x = x;
this.z = z;
this.worldHasNoSky = worldHasNoSky;
this.ebsArr = ebsArr;
this.biomeArray = biomeArray;
}
public static ChunkSnapshot of(Chunk chunk)
{
ExtendedBlockStorage[] ebsOld = chunk.getBlockStorageArray();
ExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];
for(int i = 0; i < ebsOld.length; i++)
ebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();
byte[] biomeArray = chunk.getBiomeArray();
return new ChunkSnapshot(chunk.xPosition, chunk.zPosition, chunk.worldObj.provider.hasNoSky, ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));
}
public int getX()
{
return x;
}
public int getZ()
{
return z;
}
public boolean isWorldHasNoSky()
{
return worldHasNoSky;
}
public ExtendedBlockStorage[] getEbsArr()
{
return ebsArr;
}
public byte[] getBiomeArray()
{
return biomeArray;
}
public void release()
{
for(ExtendedBlockStorage ebs : ebsArr)
if(ebs != null)
ebs.release();
}
public ChunkSnapshot copy()
{
ExtendedBlockStorage[] ebsOld = ebsArr;
ExtendedBlockStorage[] ebsNew = new ExtendedBlockStorage[ebsOld.length];
for(int i = 0; i < ebsOld.length; i++)
ebsNew[i] = ebsOld[i] == null ? null : ebsOld[i].copy();
byte[] biomeArray = this.biomeArray;
return new ChunkSnapshot(getX(), getZ(), isWorldHasNoSky(), ebsNew, Arrays.copyOf(biomeArray, biomeArray.length));
}
private static void rangeCheck(int x, int z)
{
if((x & 0xFFFFFFF0) != 0 || (z & 0xFFFFFFF0) != 0)
throw new IllegalArgumentException();
}
public Block getBlock(int x, int y, int z)
{
rangeCheck(x, z);
ExtendedBlockStorage ebs = ebsArr[y >> 4];
if(ebs != null)
return ebs.getBlockByExtId(x, y & 15, z);
return Blocks.air;
}
public int getBlockId(int x, int y, int z)
{
rangeCheck(x, z);
ExtendedBlockStorage ebs = ebsArr[y >> 4];
if(ebs != null)
return ebs.getSlot().getBlockId(x, y & 15, z);
return 0;
}
public int getBlockMeta(int x, int y, int z)
{
rangeCheck(x, z);
ExtendedBlockStorage ebs = ebsArr[y >> 4];
if(ebs != null)
return ebs.getExtBlockMetadata(x, y & 15, z);
return 0;
}
public int getBlockIdAndMeta(int x, int y, int z)

```
<Overlap Ratio: 0.9918941979522184>

---

--- 28 --
Question ID: 65a90a74dc2873fd6ce97f9e755aa2eaee8aa4cb
Original Code:
```
@Command(name = "Simple kubectl plugin", mixinStandardHelpOptions = true, version = "1",
    description = "Gets Pods names and other stuff")
class PluginTest implements Callable<Integer> {

  @CommandLine.Option(names = { "-n", "--namespace" }, description = "The @|bold namespace|@",
      paramLabel = "NAMESPACE")
  String namespace = null;

  @Parameters(index = "0", description = "Regex pattern", paramLabel = "NAMEPATTERN",
      arity = "0..1")
  Pattern namePattern = null;

  public static void main(String... args) {
    System.setProperty("org.slf4j.simpleLogger.logFile", "System.out");
    int exitCode = new CommandLine(new PluginTest()).execute(args);
    System.exit(exitCode);
  }

  private void printlnAnsi(String msg) {
    System.out.println(CommandLine.Help.Ansi.AUTO.string(msg));
  }

  @Override
  public Integer call() {
    try {
      ApiClient client = Config.defaultClient();
      Configuration.setDefaultApiClient(client);

      CoreV1Api api = new CoreV1Api();
      V1PodList list = namespace == null
          ? api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null)
          : api.listNamespacedPod(namespace, null, null, null, null, null, null, null, null, null);
      list.getItems()
          .stream()
          .filter(namePattern != null
            ? pod -> namePattern.asMatchPredicate().test(pod.getMetadata().getName())
            : pod -> true)
          .forEach(pod -> printlnAnsi("@|green Name:|@ "
            + pod.getMetadata().getName()
            + "\t@|green SelfLink:|@ "
            + pod.getMetadata().getSelfLink()));
      return 0;
    } catch (Exception ex) {
      ex.printStackTrace();
      return 1;
    }
  }
}
```


Overlapping Code:
```
e kubectl plugin", mixinStandardHelpOptions = true, version = "1",
description = "Gets Pods names and other stuff")
class PluginTest implements Callable<Integer> {
@CommandLine.Option(names = { "-n", "--namespace" }, description = "The @|bold namespace|@",
paramLabel = "NAMESPACE")
String namespace = null;
@Parameters(index = "0", description = "Regex pattern", paramLabel = "NAMEPATTERN",
arity = "0..1")
Pattern namePattern = null;
public static void main(String... args) {
System.setProperty("org.slf4j.simpleLogger.logFile", "System.out");
int exitCode = new CommandLine(new PluginTest()).execute(args);
System.exit(exitCode);
}
private void printlnAnsi(String msg) {
System.out.println(CommandLine.Help.Ansi.AUTO.string(msg));
}
@Override
public Integer call() {
try {
ApiClient client = Config.defaultClient();
Configuration.setDefaultApiClient(client);
CoreV1Api api = new CoreV1Api();
V1PodList list = namespace == null
? api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null)
: api.listNamespacedPod(namespace, null, null, null, null, null, null, null, null, null);
list.getItems()
.stream()
.filter(namePattern != null
? pod -> namePattern.asMatchPredicate().test(pod.getMetadata().getName())
: pod -> true)
.forEach(pod -> printlnAnsi("@|green Name:|@ "
+ pod.getMetadata().getName()
+ "\t@|green SelfLink:|@ "
+ pod.getMetadata().getSelfLink()));
return 0;
} catch (Exception ex) {
ex.printStackTrace();
return 1;
}
}

```
<Overlap Ratio: 0.9844804318488529>

---

--- 29 --
Question ID: c70a6a0392da80e3977ef762971c0ba2fff39f9f
Original Code:
```
public class TimeCommand {
   public static void register(CommandDispatcher<CommandSource> dispatcher) {
      dispatcher.register(Commands.literal("time").requires((p_198828_0_) -> {
         return p_198828_0_.hasPermissionLevel(2);
      }).then(Commands.literal("set").then(Commands.literal("day").executes((p_198832_0_) -> {
         return setTime(p_198832_0_.getSource(), 1000);
      })).then(Commands.literal("noon").executes((p_198825_0_) -> {
         return setTime(p_198825_0_.getSource(), 6000);
      })).then(Commands.literal("night").executes((p_198822_0_) -> {
         return setTime(p_198822_0_.getSource(), 13000);
      })).then(Commands.literal("midnight").executes((p_200563_0_) -> {
         return setTime(p_200563_0_.getSource(), 18000);
      })).then(Commands.argument("time", TimeArgument.func_218091_a()).executes((p_200564_0_) -> {
         return setTime(p_200564_0_.getSource(), IntegerArgumentType.getInteger(p_200564_0_, "time"));
      }))).then(Commands.literal("add").then(Commands.argument("time", TimeArgument.func_218091_a()).executes((p_198830_0_) -> {
         return addTime(p_198830_0_.getSource(), IntegerArgumentType.getInteger(p_198830_0_, "time"));
      }))).then(Commands.literal("query").then(Commands.literal("daytime").executes((p_198827_0_) -> {
         return sendQueryResults(p_198827_0_.getSource(), getDayTime(p_198827_0_.getSource().getWorld()));
      })).then(Commands.literal("gametime").executes((p_198821_0_) -> {
         return sendQueryResults(p_198821_0_.getSource(), (int)(p_198821_0_.getSource().getWorld().getGameTime() % 2147483647L));
      })).then(Commands.literal("day").executes((p_198831_0_) -> {
         return sendQueryResults(p_198831_0_.getSource(), (int)(p_198831_0_.getSource().getWorld().getDayTime() / 24000L % 2147483647L));
      }))));
   }

   /**
    * Returns the day time (time wrapped within a day)
    */
   private static int getDayTime(ServerWorld worldIn) {
      return (int)(worldIn.getDayTime() % 24000L);
   }

   private static int sendQueryResults(CommandSource source, int time) {
      source.sendFeedback(new TranslationTextComponent("commands.time.query", time), false);
      return time;
   }

   public static int setTime(CommandSource source, int time) {
      for(ServerWorld serverworld : source.getServer().getWorlds()) {
         serverworld.setDayTime((long)time);
      }

      source.sendFeedback(new TranslationTextComponent("commands.time.set", time), true);
      return getDayTime(source.getWorld());
   }

   public static int addTime(CommandSource source, int amount) {
      for(ServerWorld serverworld : source.getServer().getWorlds()) {
         serverworld.setDayTime(serverworld.getDayTime() + (long)amount);
      }

      int i = getDayTime(source.getWorld());
      source.sendFeedback(new TranslationTextComponent("commands.time.set", i), true);
      return i;
   }
}
```


Overlapping Code:
```
s TimeCommand {
public static void register(CommandDispatcher<CommandSource> dispatcher) {
dispatcher.register(Commands.literal("time").requires((p_198828_0_) -> {
return p_198828_0_.hasPermissionLevel(2);
}).then(Commands.literal("set").then(Commands.literal("day").executes((p_198832_0_) -> {
return setTime(p_198832_0_.getSource(), 1000);
})).then(Commands.literal("noon").executes((p_198825_0_) -> {
return setTime(p_198825_0_.getSource(), 6000);
})).then(Commands.literal("night").executes((p_198822_0_) -> {
return setTime(p_198822_0_.getSource(), 13000);
})).then(Commands.literal("midnight").executes((p_200563_0_) -> {
return setTime(p_200563_0_.getSource(), 18000);
})).then(Commands.argument("time", TimeArgument.func_218091_a()).executes((p_200564_0_) -> {
return setTime(p_200564_0_.getSource(), IntegerArgumentType.getInteger(p_200564_0_, "time"));
}))).then(Commands.literal("add").then(Commands.argument("time", TimeArgument.func_218091_a()).executes((p_198830_0_) -> {
return addTime(p_198830_0_.getSource(), IntegerArgumentType.getInteger(p_198830_0_, "time"));
}))).then(Commands.literal("query").then(Commands.literal("daytime").executes((p_198827_0_) -> {
return sendQueryResults(p_198827_0_.getSource(), getDayTime(p_198827_0_.getSource().getWorld()));
})).then(Commands.literal("gametime").executes((p_198821_0_) -> {
return sendQueryResults(p_198821_0_.getSource(), (int)(p_198821_0_.getSource().getWorld().getGameTime() % 2147483647L));
})).then(Commands.literal("day").executes((p_198831_0_) -> {
return sendQueryResults(p_198831_0_.getSource(), (int)(p_198831_0_.getSource().getWorld().getDayTime() / 24000L % 2147483647L));
}))));
}
/**
* Returns the day time (time wrapped within a day)
*/
private static int getDayTime(ServerWorld worldIn) {
return (int)(worldIn.getDayTime() % 24000L);
}
private static int sendQueryResults(CommandSource source, int time) {
source.sendFeedback(new TranslationTextComponent("commands.time.query", time), false);
return time;
}
public static int setTime(CommandSource source, int time) {
for(ServerWorld serverworld : source.getServer().getWorlds()) {
serverworld.setDayTime((long)time);
}
source.sendFeedback(new TranslationTextComponent("commands.t
```
<Overlap Ratio: 0.9809397163120568>

---

--- 30 --
Question ID: 6d9d9dd13b76e576fbb2c42bdbb8a9bf2eb6cff8
Original Code:
```
public class SmsReceiver extends BroadcastReceiver {
	

	public static final String SMS_EXTRA_NAME = "pdus";
	private CallbackContext callback_receive;
	private boolean isReceiving = true;
	
	// This broadcast boolean is used to continue or not the message broadcast
	// to the other BroadcastReceivers waiting for an incoming SMS (like the native SMS app)
	private boolean broadcast = false;
	
	@Override
	public void onReceive(Context ctx, Intent intent) {
		
		// Get the SMS map from Intent
	    Bundle extras = intent.getExtras();
	    if (extras != null)
	    {
		   // Get received SMS Array
			Object[] smsExtra = (Object[]) extras.get(SMS_EXTRA_NAME);

			for (int i=0; i < smsExtra.length; i++)
			{
				SmsMessage sms = SmsMessage.createFromPdu((byte[]) smsExtra[i]);
				if(this.isReceiving && this.callback_receive != null) {
                    String formattedMsg = sms.getOriginatingAddress() + ">" + sms.getMessageBody();
		        	PluginResult result = new PluginResult(PluginResult.Status.OK, formattedMsg);
		           	result.setKeepCallback(true);
		            callback_receive.sendPluginResult(result);
				}
			}

			// If the plugin is active and we don't want to broadcast to other receivers
			if (this.isReceiving && !broadcast) {
				this.abortBroadcast();
			}
	     }
	}
	
	public void broadcast(boolean v) {
		this.broadcast = v;
	}
	
	public void startReceiving(CallbackContext ctx) {
		this.callback_receive = ctx;
		this.isReceiving = true;
	}

	public void stopReceiving() {
		this.callback_receive = null;
		this.isReceiving = false;
	}
}
```


Overlapping Code:
```
public class SmsReceiver extends BroadcastReceiver {

public static final String SMS_EXTRA_NAME = "pdus";
private CallbackContext callback_receive;
private boolean isReceiving = true;

// This broadcast boolean is used to continue or not the message broadcast
// to the other BroadcastReceivers waiting for an incoming SMS (like the native SMS app)
private boolean broadcast = false;

@Override
public void onReceive(Context ctx, Intent intent) {

// Get the SMS map from Intent
Bundle extras = intent.getExtras();
if (extras != null)
{
// Get received SMS Array
Object[] smsExtra = (Object[]) extras.get(SMS_EXTRA_NAME);
for (int i=0; i < smsExtra.length; i++)
{
SmsMessage sms = SmsMessage.createFromPdu((byte[]) smsExtra[i]);
if(this.isReceiving && this.callback_receive != null) {
String formattedMsg = sms.getOriginatingAddress() + ">" + sms.getMessageBody();
PluginResult result = new PluginResult(PluginResult.Status.OK, formattedMsg);
result.setKeepCallback(true);
callback_receive.sendPluginResult(result);
}
}
// If the plugin is active and we don't want to broadcast to other receivers
if (this.isReceiving && !broadcast) {
this.abortBroadcast();
}
}
}

public void broadcast(boolean v) {
this.broadcast = v;
}

public void startReceiving(CallbackContext ctx) {
this.callback_receive = ctx;
this.isReceiving = true;
}
public void stopReceiving() {
this.callback_receive = null;
this.isReceivi
```
<Overlap Ratio: 0.9894217207334274>

---

--- 31 --
Question ID: efd9da203f471c3da15bb7565eaf8e1de5d1eb19
Original Code:
```
public class VitaminManager extends Functions
{
	private static final int PetCoupon = 13273;
	private static final int SpecialPetCoupon = 14065;

	private static final int WeaselNeck = 13017;
	private static final int PrincNeck = 13018;
	private static final int BeastNeck = 13019;
	private static final int FoxNeck = 13020;

	private static final int KnightNeck = 13548;
	private static final int SpiritNeck = 13549;
	private static final int OwlNeck = 13550;
	private static final int TurtleNeck = 13551;

	public void giveWeasel()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, PetCoupon) > 0)
		{
			removeItem(player, PetCoupon, 1, "VitaminManager");
			addItem(player, WeaselNeck, 1, "VitaminManager");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void givePrinc()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, PetCoupon) > 0)
		{
			removeItem(player, PetCoupon, 1, "givePrinc");
			addItem(player, PrincNeck, 1, "givePrinc");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveBeast()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, PetCoupon) > 0)
		{
			removeItem(player, PetCoupon, 1, "giveBeast");
			addItem(player, BeastNeck, 1, "giveBeast");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveFox()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, PetCoupon) > 0)
		{
			removeItem(player, PetCoupon, 1, "giveFox");
			addItem(player, FoxNeck, 1, "giveFox");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveKnight()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, SpecialPetCoupon) > 0)
		{
			removeItem(player, SpecialPetCoupon, 1, "giveKnight");
			addItem(player, KnightNeck, 1, "giveKnight");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveSpirit()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, SpecialPetCoupon) > 0)
		{
			removeItem(player, SpecialPetCoupon, 1, "giveSpirit");
			addItem(player, SpiritNeck, 1, "giveSpirit");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveOwl()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, SpecialPetCoupon) > 0)
		{
			removeItem(player, SpecialPetCoupon, 1, "giveOwl");
			addItem(player, OwlNeck, 1, "giveOwl");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}

	public void giveTurtle()
	{
		Player player = getSelf();
		NpcInstance npc = getNpc();

		String htmltext;
		if (getItemCount(player, SpecialPetCoupon) > 0)
		{
			removeItem(player, SpecialPetCoupon, 1, "giveTurtle");
			addItem(player, TurtleNeck, 1, "giveTurtle");
			htmltext = npc.getNpcId() + "-ok.htm";
		}
		else
			htmltext = npc.getNpcId() + "-no.htm";

		npc.showChatWindow(player, "default/" + htmltext);
	}
}
```


Overlapping Code:
```
nager extends Functions
{
private static final int PetCoupon = 13273;
private static final int SpecialPetCoupon = 14065;
private static final int WeaselNeck = 13017;
private static final int PrincNeck = 13018;
private static final int BeastNeck = 13019;
private static final int FoxNeck = 13020;
private static final int KnightNeck = 13548;
private static final int SpiritNeck = 13549;
private static final int OwlNeck = 13550;
private static final int TurtleNeck = 13551;
public void giveWeasel()
{
Player player = getSelf();
NpcInstance npc = getNpc();
String htmltext;
if (getItemCount(player, PetCoupon) > 0)
{
removeItem(player, PetCoupon, 1, "VitaminManager");
addItem(player, WeaselNeck, 1, "VitaminManager");
htmltext = npc.getNpcId() + "-ok.htm";
}
else
htmltext = npc.getNpcId() + "-no.htm";
npc.showChatWindow(player, "default/" + htmltext);
}
public void givePrinc()
{
Player player = getSelf();
NpcInstance npc = getNpc();
String htmltext;
if (getItemCount(player, PetCoupon) > 0)
{
removeItem(player, PetCoupon, 1, "givePrinc");
addItem(player, PrincNeck, 1, "givePrinc");
htmltext = npc.getNpcId() + "-ok.htm";
}
else
htmltext = npc.getNpcId() + "-no.htm";
npc.showChatWindow(player, "default/" + htmltext);
}
public void giveBeast()
{
Player player = getSelf();
NpcInstance npc = getNpc();
String htmltext;
if (getItemCount(player, PetCoupon) > 0)
{
removeItem(player, PetCoupon, 1, "giveBeast");
addItem(player, BeastNeck, 1, "giveBeast");
htmltext = npc.getNpcId() + "-ok.htm";
}
else
htmltext = npc.getNpcId() + "-no.htm";
npc.showChatWindow(player, "default/" + htmltext);
}
public void giveFox()
{
Player player = getSelf();
NpcInstance npc = getNpc();
String htmltext;
if (getItemCount(player, PetCoupon) > 0)
{
removeItem(player, PetCoupon, 1, "giveFox");
addItem(player, FoxNeck, 1, "giveFox");
htmltext = npc.getNpcId() + "-ok.htm";
}
else
htmltext = npc.getNpcId() + "-no.htm";
npc.showChatWindow(player, "default/" + htmltext);
}
public void giveKnight()
{
Player player = getSelf();
NpcInstance npc = getNpc();
String htmltext;
if (getItemCount(player, SpecialPetCoupon) > 0)
{
removeItem(player, SpecialPetCoupon, 1, "giveKnight");
addItem(player, KnightNeck, 1, "giveKnight");
htmltext = npc.getNpcId() + "-ok.htm";
}
else
htmltext = npc.getNpcId() + "-no.htm";

```
<Overlap Ratio: 0.9887834339948232>

---

--- 32 --
Question ID: 61a8c9102b7f3de805ed0ec7a46314d109d6702d
Original Code:
```
@Slf4j
@Component
@AllArgsConstructor
public class DatabaseInitializer {

    private final FlywayProperties flywayProperties;
    private final DataSourceProperties dataSourceProperties;

    /**
     * 先创建数据库，再利用 flyway 执行脚本
     * @throws SQLException
     */
    @PostConstruct
    public void init() throws SQLException {
        log.info("DatabaseInitializer uses flyway init-sqls to initiate database");
        String url = dataSourceProperties.getUrl();
        // jdbc url最后一个 '/' 用于分割具体 schema?参数
        int lastSplitIndex = url.lastIndexOf('/');
        // 获取spring.datasource.url具体数据库schema前的jdbc url
        String addressUrl = url.substring(0, lastSplitIndex);
        // 直连数据库地址:jdbc:mysql://yourIp:port
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(addressUrl);
        dataSource.setUsername(dataSourceProperties.getUsername());
        dataSource.setPassword(dataSourceProperties.getPassword());
        Connection connection = dataSource.getConnection();
        Statement statement = connection.createStatement();
        for (String sql : flywayProperties.getInitSqls()) {
            // 通过flyway的init-sqls配置进行建库与数据库配置
            // executeUpdate:执行给定的SQL语句，该语句可以是INSERT，UPDATE或DELETE语句或不返回任何内容的SQL语句，例如SQL DDL语句。
            statement.executeUpdate(sql);
        }
        statement.close();
        connection.close();
        dataSource.close();
        log.info("DatabaseInitializer initialize completed");
    }
}
```


Overlapping Code:
```
@Slf4j
@Component
@AllArgsConstructor
public class DatabaseInitializer {
private final FlywayProperties flywayProperties;
private final DataSourceProperties dataSourceProperties;
/**
* 先创建数据库，再利用 flyway 执行脚本
* @throws SQLException
*/
@PostConstruct
public void init() throws SQLException {
log.info("DatabaseInitializer uses flyway init-sqls to initiate database");
String url = dataSourceProperties.getUrl();
// jdbc url最后一个 '/' 用于分割具体 schema?参数
int lastSplitIndex = url.lastIndexOf('/');
// 获取spring.datasource.url具体数据库schema前的jdbc url
String addressUrl = url.substring(0, lastSplitIndex);
// 直连数据库地址:jdbc:mysql://yourIp:port
HikariDataSource dataSource = new HikariDataSource();
dataSource.setJdbcUrl(addressUrl);
dataSource.setUsername(dataSourceProperties.getUsername());
dataSource.setPassword(dataSourceProperties.getPassword());
Connection connection = dataSource.getConnection();
Statement statement = connection.createStatement();
for (String sql : flywayProperties.getInitSqls()) {
// 通过flyway的init-sqls配置进行建库与数据库配置
// executeUpdate:执行给定的SQL语句，该语句可以是INSERT，UPDATE或DELETE语句或不返回任何内容的SQL语句，例如SQL DDL语句。
statement.executeUpdate(sql);
}
statement.close();
connection.close();
dataSource.close();
log.info("DatabaseIn
```
<Overlap Ratio: 0.9706115965051628>

---

--- 33 --
Question ID: 435276314285ceb5c55928c9c65410123c18524b
Original Code:
```
public class GameWorld extends World
{
	public GameWorld(Game game)
	{
		this.game = game;
		
		addEntity(new EntityGrayEnemy(this, new Vector2D(0, 0)));
	}
	
	@Override
	public void update(InputHandler handler)
	{
		// update players
		for(int i = 0; i < Game.MaxPlayer; i++)
		{
			if(players[i] == null)
				continue;
			
			if(i == game.localID) // local player
			{
				players[i].lastMouseX = players[i].mouseX;
				players[i].lastMouseY = players[i].mouseY;
				players[i].lastLeftDown = players[i].leftDown;
				
				players[i].lastLeft = players[i].left;
				players[i].lastRight = players[i].right;
				players[i].lastJump = players[i].jump;
				players[i].lastSprint = players[i].sprint;
				players[i].lastSneak = players[i].sneak;
				
				players[i].mouseX = handler.mouseX;
				players[i].mouseY = handler.mouseY;
				players[i].leftDown = Controls.punch.isPressed(handler);
				
				players[i].left = Controls.left.isPressed(handler);
				players[i].right = Controls.right.isPressed(handler);
				players[i].jump = Controls.jump.isPressed(handler);
				players[i].sprint = Controls.sprint.isPressed(handler);
				players[i].sneak = Controls.sneak.isPressed(handler);
			}
			
			players[i].update(this);
		}
		
		super.update(handler);
	}
	
// Player stuff
	public Player getLocalPlayer()
	{
		return players[game.localID];
	}
	
/**
 * Only creates a 'Player, not an 'EntityPlayer'
 * @param playerID
 */
	public void createPlayer(int playerID)
	{
		if(players[playerID] == null)
			players[playerID] = new Player(playerID);
	}
	
/**
 * Creates a 'Player' and 'EntityPlayer'
 * @param playerID
 */
	public void createPlayerEntity(int playerID)
	{
		if(players[playerID] == null)
			createPlayer(playerID);
		else
			removePlayerEntity(playerID);
		
		players[playerID].entity = new EntityPlayer(this, players[playerID]);
		addEntity(players[playerID].entity);
	}
	
	public void removePlayer(int playerID)
	{
		if(players[playerID] == null)
			return;
		
		removePlayerEntity(playerID);
		players[playerID] = null;
	}
	
	public void removePlayerEntity(int playerID)
	{
		if(players[playerID] == null || players[playerID].entity == null)
			return;
		
		removeEntity(players[playerID].entity);
		players[playerID].entity = null;
	}
	
	public void swapPlayer(int id1, int id2)
	{
		Player player = players[id1];
		players[id1] = players[id2];
		players[id2] = player;
		
		if(players[id1] != null)
			players[id1].id = id1;
		if(players[id2] != null)
			players[id2].id = id2;
	}
	
//
	@Override
	public void onEntityAdded(Entity entity)
	{
//		if(game.gameState == Game.STATE_MULTIPLAYER_SERVER)
//		{
//			if(entity instanceof EntityPlayer)
//			{
//				EntityPlayer player = (EntityPlayer)entity;
//				game.server.send("player_a:" +player.id);
//			}
//		}
	}
	
	@Override
	public void onEntityRemoved(Entity entity)
	{
		if(entity instanceof EntityPlayer || !(entity instanceof EntityLiving))
			return;
		
		game.addCoins(10);
	}
	
// draw
	@Override
	public int playerInsideHidden(EntityPlayer player)
	{
		int l = (int)player.pos.x;
		if(player.pos.x < 0.0D)
			l--;
		int r = (int)(player.pos.x + EntityPlayer.WorldSize);
		if(player.pos.x + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.x + EntityPlayer.WorldSize == r)
			r--;
		int t = (int)player.pos.y;
		if(player.pos.y < 0.0D)
			t--;
		int b = (int)(player.pos.y + EntityPlayer.WorldSize);
		if(player.pos.y + EntityPlayer.WorldSize < 0.0D || getLocalPlayer().entity.pos.y + EntityPlayer.WorldSize == b)
			b--;
		
		// update block data
		for(int y = t; y <= b; y++)
		{
			for(int x = l; x <= r; x++)
			{
				BlockData data = getBlockData(Block.hidden.getLayer(), x, y);
				if(data != null && data instanceof BlockDataHidden)
				{
					DataValue dataValue = (DataValue)data.get(0);
					return dataValue.value;
				}
			}
		}
		
		return -1;
	}
	
	@Override
	public void drawPlayer(Graphics g, int xOffset, int yOffset)
	{
		for(int i = 0; i < Game.MaxPlayer; i++)
		{
			if(players[i] != null && players[i].entity != null && !players[i].entity.dead)
			{
				players[i].entity.draw(g, xOffset, yOffset);
			}
		}
	}
	
	public final Game game;
	public Player players[] = new Player[Game.MaxPlayer];
}
```


Overlapping Code:
```
public class GameWorld extends World
{
public GameWorld(Game game)
{
this.game = game;

addEntity(new EntityGrayEnemy(this, new Vector2D(0, 0)));
}

@Override
public void update(InputHandler handler)
{
// update players
for(int i = 0; i < Game.MaxPlayer; i++)
{
if(players[i] == null)
continue;

if(i == game.localID) // local player
{
players[i].lastMouseX = players[i].mouseX;
players[i].lastMouseY = players[i].mouseY;
players[i].lastLeftDown = players[i].leftDown;

players[i].lastLeft = players[i].left;
players[i].lastRight = players[i].right;
players[i].lastJump = players[i].jump;
players[i].lastSprint = players[i].sprint;
players[i].lastSneak = players[i].sneak;

players[i].mouseX = handler.mouseX;
players[i].mouseY = handler.mouseY;
players[i].leftDown = Controls.punch.isPressed(handler);

players[i].left = Controls.left.isPressed(handler);
players[i].right = Controls.right.isPressed(handler);
players[i].jump = Controls.jump.isPressed(handler);
players[i].sprint = Controls.sprint.isPressed(handler);
players[i].sneak = Controls.sneak.isPressed(handler);
}

players[i].update(this);
}

super.update(handler);
}

// Player stuff
public Player getLocalPlayer()
{
return players[game.localID];
}

/**
* Only creates a 'Player, not an 'EntityPlayer'
* @param playerID
*/
public void createPlayer(int playerID)
{
if(players[playerID] == null)
players[playerID] = new Player(playerID);
}

/**
* Creates a 'Player' and 'EntityPlayer'
* @param playerID
*/
public void createPlayerEntity(int playerID)
{
if(players[playerID] == null)
createPlayer(playerID);
else
removePlayerEntity(playerID);

players[playerID].entity = new EntityPlayer(this, players[playerID]);
addEntity(players[playerID].entity);
}

public void removePlayer(int playerID)
{
if(players[playerID] == null)
return;

removePlayerEntity(playerID);
players[playerID] = null;
}

public void removePlayerEntity(int playerID)
{
if(players[playerID] == null || players[playerID].entity == null)
return;

removeEntity(players[playerID].entity);
players[playerID].entity = null;
}

public void swapPlayer(int id1, int id2)
{
Player player = players[id1];
players[id1] = players[id2];
players[id2] = player;

if(players[id1] != null)
players[id1].id = id1;
if(players[id2] != null)
pl
```
<Overlap Ratio: 0.9885764499121266>

---

--- 34 --
Question ID: 57db1192d2446002c9cfe621d32debd52bbb6de8
Original Code:
```
public class LocationService extends Service {
    private static final String TAG = "LocationService";
    public static final String PREFS_NAME = "LocationServicePrefs";
    public static final String PREF_IS_STARTED = "isStarted";

    private static final int NOTIFICATION_ID = 1001;
    private static final String NOTIFICATION_CHANNEL_ID = "PrivateKitChannel";
    private static final String NOTIFICATION_CHANNEL_NAME = "Notification channel for PrivateKit";

    private static final int LOCATION_INTERVAL = 1000;
    private static final float LOCATION_DISTANCE = 0f;

    public static boolean IS_RUNNING = false;

    private LocationManager locationManager = null;
    private LocationListener locationListenerFine = new LocationListener();
    private LocationListener locationListenerCoarse = new LocationListener();
    private LocationWriter locationWriter = new LocationWriter();

    public static void start(@NonNull Context context) {
        Intent intent = new Intent(context, LocationService.class);
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            context.startForegroundService(intent);
        } else {
            context.startService(intent);
        }
    }

    public static void stop(@NonNull Context context) {
        Intent intent = new Intent(context, LocationService.class);
        context.stopService(intent);
    }

    private class LocationListener implements android.location.LocationListener {
        @Override
        public void onLocationChanged(Location location) {
            Log.d(TAG, "onLocationChanged: " + location);
            try {
                locationWriter.addPoint(LocationService.this, location, new Date());
            } catch (Exception e) {
                e.printStackTrace();
                Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();
            }
        }

        @Override
        public void onProviderDisabled(String provider) {
            Log.d(TAG, "onProviderDisabled: " + provider);
        }

        @Override
        public void onProviderEnabled(String provider) {
            Log.d(TAG, "onProviderEnabled: " + provider);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
            Log.d(TAG, "onStatusChanged: " + provider);
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "onStartCommand");
        super.onStartCommand(intent, flags, startId);
        return START_STICKY;
    }

    @Override
    public void onCreate() {
        Log.d(TAG, "onCreate");

        if (locationManager == null) {
            locationManager = (LocationManager) getApplicationContext().getSystemService(Context.LOCATION_SERVICE);
        }

        startForeground(NOTIFICATION_ID, createNotification());

        try {
            locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER,
                    LOCATION_INTERVAL, LOCATION_DISTANCE, locationListenerFine);
        } catch (SecurityException | IllegalArgumentException e) {
            e.printStackTrace();
            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();
        }

        try {
            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER,
                    LOCATION_INTERVAL * 2, LOCATION_DISTANCE, locationListenerCoarse);
        } catch (SecurityException | IllegalArgumentException e) {
            e.printStackTrace();
            Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();
        }

        persistStartedState(true);
    }

    @Override
    public void onDestroy() {
        persistStartedState(false);
        Log.d(TAG, "onDestroy");
        super.onDestroy();
        if (locationManager != null) {
            try {
                locationManager.removeUpdates(locationListenerFine);
            } catch (Exception e) {
                // ignore
            }
            try {
                locationManager.removeUpdates(locationListenerCoarse);
            } catch (Exception e) {
                // ignore
            }
        }
        if (locationWriter != null) {
            locationWriter.close();
        }
    }

    private Notification createNotification() {
        NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);

        if (notificationManager != null
                && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            NotificationChannel notificationChannel = notificationManager.getNotificationChannel(NOTIFICATION_CHANNEL_ID);
            if (notificationChannel == null) {
                notificationChannel = new NotificationChannel(NOTIFICATION_CHANNEL_ID, NOTIFICATION_CHANNEL_NAME, NotificationManager.IMPORTANCE_DEFAULT);
                notificationManager.createNotificationChannel(notificationChannel);
            }
        }

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_my_location_black_24dp)
                .setContentIntent(PendingIntent.getActivity(this, 0, new Intent(this, MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT))
                .setContentTitle(getString(R.string.notification_title))
                .setContentText(getString(R.string.notification_text))
                .setAutoCancel(false);
        return builder.build();
    }

    private void persistStartedState(boolean started) {
        IS_RUNNING = started;
        SharedPreferences prefs = getApplicationContext().getSharedPreferences(PREFS_NAME, 0);
        SharedPreferences.Editor editor = prefs.edit();
        editor.putBoolean(PREF_IS_STARTED, started);
        editor.apply();
    }
}
```


Overlapping Code:
```
public class LocationService extends Service {
private static final String TAG = "LocationService";
public static final String PREFS_NAME = "LocationServicePrefs";
public static final String PREF_IS_STARTED = "isStarted";
private static final int NOTIFICATION_ID = 1001;
private static final String NOTIFICATION_CHANNEL_ID = "PrivateKitChannel";
private static final String NOTIFICATION_CHANNEL_NAME = "Notification channel for PrivateKit";
private static final int LOCATION_INTERVAL = 1000;
private static final float LOCATION_DISTANCE = 0f;
public static boolean IS_RUNNING = false;
private LocationManager locationManager = null;
private LocationListener locationListenerFine = new LocationListener();
private LocationListener locationListenerCoarse = new LocationListener();
private LocationWriter locationWriter = new LocationWriter();
public static void start(@NonNull Context context) {
Intent intent = new Intent(context, LocationService.class);
if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
context.startForegroundService(intent);
} else {
context.startService(intent);
}
}
public static void stop(@NonNull Context context) {
Intent intent = new Intent(context, LocationService.class);
context.stopService(intent);
}
private class LocationListener implements android.location.LocationListener {
@Override
public void onLocationChanged(Location location) {
Log.d(TAG, "onLocationChanged: " + location);
try {
locationWriter.addPoint(LocationService.this, location, new Date());
} catch (Exception e) {
e.printStackTrace();
Toast.makeText(LocationService.this, getString(R.string.error_file_write, e.getLocalizedMessage()), Toast.LENGTH_LONG).show();
}
}
@Override
public void onProviderDisabled(String provider) {
Log.d(TAG, "onProviderDisabled: " + provider);
}
@Override
public void onProviderEnabled(String provider) {
Log.d(TAG, "onProviderEnabled: " + provider);
}
@Override
public void onStatusChanged(String provider, int status, Bundle extras) {
Log.d(TAG, "onStatusChanged: " + provider);
}
}
@Override
public IBinder onBind(Intent intent) {
return
```
<Overlap Ratio: 1.0>

---

--- 35 --
Question ID: c24a581418b82478480459a9e205cf5ceec35746
Original Code:
```
public class ShakeService extends Service {

    private SensorManager mSensorManager;
    private float mAccel;
    private float mAccelCurrent;
    private float mAccelLast;
    private final SensorEventListener mSensorListener = new SensorEventListener() {
        @Override
        public void onSensorChanged(SensorEvent event) {

            float x = event.values[0];
            float y = event.values[1];
            float z = event.values[2];
            mAccelLast = mAccelCurrent;
            mAccelCurrent = (float) Math.sqrt((double) (x * x + y * y + z * z));
            float delta = mAccelCurrent - mAccelLast;
            mAccel = mAccel * 0.9f + delta;

            if (mAccel > 12) {
                Intent intent = new Intent(getApplicationContext(), FullscreenActivity.class)
                        .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |
                                Intent.FLAG_ACTIVITY_SINGLE_TOP |
                                Intent.FLAG_ACTIVITY_NEW_TASK);

                // only if not already started, should test first !

                startActivity(intent);
            }
        }

        @Override
        public void onAccuracyChanged(Sensor sensor, int accuracy) {
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        throw new UnsupportedOperationException("Not yet implemented");
//        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.i("SensorEventListener#onCreate", "bimbim");
        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
        Objects.requireNonNull(mSensorManager).registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),
                SensorManager.SENSOR_DELAY_NORMAL);
        mAccel = 10f;
        mAccelCurrent = SensorManager.GRAVITY_EARTH;
        mAccelLast = SensorManager.GRAVITY_EARTH;


    }
}
```


Overlapping Code:
```
extends Service {
private SensorManager mSensorManager;
private float mAccel;
private float mAccelCurrent;
private float mAccelLast;
private final SensorEventListener mSensorListener = new SensorEventListener() {
@Override
public void onSensorChanged(SensorEvent event) {
float x = event.values[0];
float y = event.values[1];
float z = event.values[2];
mAccelLast = mAccelCurrent;
mAccelCurrent = (float) Math.sqrt((double) (x * x + y * y + z * z));
float delta = mAccelCurrent - mAccelLast;
mAccel = mAccel * 0.9f + delta;
if (mAccel > 12) {
Intent intent = new Intent(getApplicationContext(), FullscreenActivity.class)
.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP |
Intent.FLAG_ACTIVITY_SINGLE_TOP |
Intent.FLAG_ACTIVITY_NEW_TASK);
// only if not already started, should test first !
startActivity(intent);
}
}
@Override
public void onAccuracyChanged(Sensor sensor, int accuracy) {
}
};
@Override
public IBinder onBind(Intent intent) {
throw new UnsupportedOperationException("Not yet implemented");
// return null;
}
@Override
public void onCreate() {
super.onCreate();
Log.i("SensorEventListener#onCreate", "bimbim");
mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
Objects.requireNonNull(mSensorManager).registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),
SensorManager.SENSOR_DELAY_NORMAL);
mAccel = 10f;
mAccelCurrent = SensorManager.GRAVITY_EARTH;
mAccelLast = SensorManager.GRAVITY_EARTH;
}

```
<Overlap Ratio: 0.9819034852546917>

---

--- 36 --
Question ID: 0a2abf81286e00f7aff363659a8bd9713c74d06f
Original Code:
```
public class MatrixMetaManager {
  private static final Log LOG = LogFactory.getLog(MatrixMetaManager.class);
  /** matrix inited flag, worker/ps can get matrix info. only when matrix is initialized after am received matrixinfo from client */
  //private boolean matrixInited;

  /**matrix id to matrix meta proto map*/
  private final Int2ObjectOpenHashMap<MatrixProto> matrixProtoMap;

  /** inverted index, psId--->Map( matrixId---->List<PartitionKey>), used for PS */
  private final Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>> matrixPartitionOnPS;
  
  /** ps id to matrices on this ps map */
  private final Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet> psIdToMatrixIdsMap;
  
  /**matrix id generator*/
  private int maxMatrixId = -1;
  
  /**matrix name to id map*/
  private final Object2IntOpenHashMap<String> matrixNameToIdMap;
  
  /**matrix id to psId which has build partitions of this matrix map, use to add matrix */
  private final Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>> matrixIdToPSSetMap;
  
  private final Lock readLock;
  private final Lock writeLock;

  public MatrixMetaManager() {
    matrixPartitionOnPS = new Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>>();
    matrixIdToPSSetMap = new Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>>();
    psIdToMatrixIdsMap = new Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet>();
    matrixProtoMap = new Int2ObjectOpenHashMap<MatrixProto>();
   
    matrixNameToIdMap = new Object2IntOpenHashMap<String>();

    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    readLock = readWriteLock.readLock();
    writeLock = readWriteLock.writeLock();
  }

  /**
   * get all matrices meta proto. 
   * @return List<MatrixProto> all matrices meta proto list
   */
  public final List<MatrixProto> getMatrixProtos() {
    try {
      readLock.lock();
      List<MatrixProto> matrixes = new ArrayList<MatrixProto>();
      for (Entry<Integer, MatrixProto> entry : matrixProtoMap.entrySet()) {
        matrixes.add(entry.getValue());
      }
      return matrixes;
    } finally {
      readLock.unlock();
    }
  }
  
  /**
   * get matrix meta proto use matrix name
   * @param matrixName matrix name
   * @return MatrixProto matrix meta proto of the matrix, if not found, just return null
   */
  public MatrixProto getMatrix(String matrixName) {
    try {
      readLock.lock();
      for (MatrixProto m : matrixProtoMap.values()) {
        if (m.getName().equals(matrixName)) {
          return m;
        }
      }
      return null;
    } finally {
      readLock.unlock();
    }
  }

  /**
   * get matrix meta proto use matrix id
   * @param id matrix id
   * @return MatrixProto matrix meta proto of the matrix
   */
  public MatrixProto getMatrix(int id) {
    try {
      readLock.lock();
      return matrixProtoMap.get(id);
    } finally {
      readLock.unlock();
    }
  }

  /**
   * get partitions of a specific parameter server hold
   * @param psId, parameter server id
   * @return List<MatrixPartition> the partitions of the parameter server hold
   */

  public final List<MatrixPartition> getMatrixPartitions(ParameterServerId psId) {
    try {
      readLock.lock();

      Map<Integer, MatrixPartition> mpMap = matrixPartitionOnPS.get(psId);
      if (mpMap == null) {
        LOG.info("psId: " + psId + ", mpMap null ");
        return null;
      }

      List<MatrixPartition> mpList = new ArrayList<MatrixPartition>(mpMap.size());
      for (Map.Entry<Integer, MatrixPartition> entry : mpMap.entrySet()) {
        LOG.info("MatrixPartition is " + entry.getValue());
        mpList.add(entry.getValue());
      }
      return mpList;
    } finally {
      readLock.unlock();
    }
  }

  /**
   * add matrices meta to matrix meta manager and dispatch the partitions to parameter servers  
   * @param matrixProtos matrices meta 
   * @throws InvalidParameterException 
   */
  public void addMatrices(List<MatrixProto> matrixProtos) throws InvalidParameterException {
    try {
      writeLock.lock();
      int size = matrixProtos.size();
      for (int i = 0; i < size; i++) {
        //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only
        if(matrixNameToIdMap.containsKey(matrixProtos.get(i).getName())) {
          String errorMsg = "build matrix failed. matrix name " + matrixProtos.get(i).getName() + " has exist, you must choose a new one";
          LOG.error(errorMsg);
          throw new InvalidParameterException(errorMsg);
        } else {
          matrixNameToIdMap.put(matrixProtos.get(i).getName(), matrixProtos.get(i).getId());
        }

        LOG.info("start building MatrixPartition info. matrix id " + matrixProtos.get(i).getId());
        matrixProtoMap.put(matrixProtos.get(i).getId(), matrixProtos.get(i));
        
        //dispatch matrix partitions to parameter servers
        buildPSMatrixInvertInfo(matrixProtos.get(i));
        
        //update matrix id generator
        updateMaxMatrixId(matrixProtos.get(i).getId());
      }
    } finally {
      writeLock.unlock();
    }
  }
  
  @SuppressWarnings("unused")
  private void waitForMatricesCreateOnPS(List<MatrixProto> matrixProtos) {
    boolean inited = true;
    while (true) {
      try {
        readLock.lock();
        int size = matrixProtos.size();
        inited = true;
        for (int i = 0; i < size; i++) {
          ObjectOpenHashSet<ParameterServerId> psIdSet =
              matrixIdToPSSetMap.get(matrixProtos.get(i).getId());

          if (psIdSet == null || psIdSet.isEmpty()) {
            continue;
          }

          for (ParameterServerId psId : psIdSet) {
            if (!psIdToMatrixIdsMap.containsKey(psId)
                || !psIdToMatrixIdsMap.get(psId).contains(matrixProtos.get(i).getId())) {
              inited = false;
              break;
            }
          }
        }
      } finally {
        readLock.unlock();
      }

      if (inited) {
        return;
      }

      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        LOG.warn("waitForMatrixOnPS is interruptted.");
      }
    }
  }
  
  public boolean isCreated(String matrixName) {
    boolean inited = true;

    try {
      readLock.lock();
      if(!matrixNameToIdMap.containsKey(matrixName)) {
        return true;
      }
      
      int matrixId = matrixNameToIdMap.getInt(matrixName);
      ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);

      if (psIdSet == null || psIdSet.isEmpty()) {
        return true;
      }

      inited = true;
      for (ParameterServerId psId : psIdSet) {
        if (!psIdToMatrixIdsMap.containsKey(psId)
            || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {
          inited = false;
          break;
        }
      }
    } finally {
      readLock.unlock();
    }

    return inited;
  }

  @SuppressWarnings("unused")
  private void waitForMatrixCreateOnPS(MatrixProto matrixProto) {
    boolean inited = true;
    int matrixId = matrixProto.getId();
    while (true) {
      try {
        readLock.lock();
        ObjectOpenHashSet<ParameterServerId> psIdSet =
            matrixIdToPSSetMap.get(matrixId);

        if (psIdSet == null || psIdSet.isEmpty()) {
          return;
        }
        
        inited = true;
        for (ParameterServerId psId : psIdSet) {
          if (!psIdToMatrixIdsMap.containsKey(psId)
              || !psIdToMatrixIdsMap.get(psId).contains(matrixId)) {
            LOG.info("ps " + psId + " does not contain matrix " + matrixId);
            inited = false;
            break;
          }
        }
      } finally {
        readLock.unlock();
      }

      if (inited) {
        LOG.info("all ps create matrix " + matrixId + " successfully.");
        return;
      }

      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        LOG.warn("waitForMatrixOnPS is interruptted.");
      }
    }
  }

  @SuppressWarnings("unused")
  private void waitForMatrixReleaseOnPS(int matrixId) {
    boolean released = true;
    while (true) {
      try {
        readLock.lock();
        ObjectOpenHashSet<ParameterServerId> psIdSet = matrixIdToPSSetMap.get(matrixId);

        if (psIdSet == null || psIdSet.isEmpty()) {
          return;
        }

        released = true;
        for (ParameterServerId psId : psIdSet) {
          if (psIdToMatrixIdsMap.containsKey(psId)
              && psIdToMatrixIdsMap.get(psId).contains(matrixId)) {
            released = false;
            break;
          }
        }
      } finally {
        readLock.unlock();
      }

      if (released) {
        return;
      }

      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        LOG.warn("waitForMatrixOnPS is interruptted.");
      }
    }
  }
  
  
  /**
   * Create a new matrix
   * @param matrixProto matrix meta proto
   * @return int matrix id
   * @throws InvalidParameterException 
   */
  public int addMatrix(MatrixProto matrixProto) throws InvalidParameterException {
    int matrixId = -1;
    try {
      writeLock.lock();

      matrixId = assignMatrixId();
      LOG.info("start building MatrixPartition info, matrix id " + matrixId);

      //check whether the matrix name conflicts with the existing matrix names, the matrix name must be only
      if(matrixNameToIdMap.containsKey(matrixProto.getName())) {
        String errorMsg = "build matrix failed. matrix name " + matrixProto.getName() + " has exist, you must choose a new one";
        LOG.error(errorMsg);
        throw new InvalidParameterException(errorMsg);
      } else {
        matrixNameToIdMap.put(matrixProto.getName(), matrixId);
      }
      
      matrixProtoMap.put(matrixProto.getId(), matrixProto);
      
      //dispatch matrix partitions to parameter servers
      buildPSMatrixInvertInfo(matrixProto);
      
    } finally {
      writeLock.unlock();
    }

    return matrixId;
  }

  /**
   * dispatch matrix partitions to parameter servers 
   * @param matrixProto  matrix meta proto
   */
  private void buildPSMatrixInvertInfo(MatrixProto matrixProto) {
    LOG.debug("matrixName: " + matrixProto.getName() + ", matrixParititionsNum: "
        + matrixProto.getMatrixPartLocationCount());
    List<MatrixPartitionLocation> matrixPartProtoList = matrixProto.getMatrixPartLocationList();

    int matrixId = matrixProto.getId();
    IntOpenHashSet psIdSet = new IntOpenHashSet();

    Int2ObjectOpenHashMap<MatrixPartition.Builder> builders =
        new Int2ObjectOpenHashMap<MatrixPartition.Builder>();

    List<MLProtos.Pair> pairs = matrixProto.getAttributeList();

    for (MatrixPartitionLocation matrixPartLocProto : matrixPartProtoList) {
      Partition part = matrixPartLocProto.getPart();
      int psId = matrixPartLocProto.getPsId().getPsIndex();
      psIdSet.add(psId);

      MatrixPartition.Builder mpBuilder = builders.get(psId);
      if (mpBuilder == null) {
        mpBuilder = MatrixPartition.newBuilder();
        builders.put(psId, mpBuilder);
        mpBuilder.setMatrixId(matrixId);
        mpBuilder.setMatrixName(matrixProto.getName());
        mpBuilder.setRowNum(matrixProto.getRowNum());
        mpBuilder.setColNum(matrixProto.getColNum());
        mpBuilder.setRowType(matrixProto.getRowType());
        for (MLProtos.Pair pair : pairs) {
          mpBuilder.addConfigurations(pair);
        }
      }

      mpBuilder.addPartitions(part);
    }

    for (Entry<Integer, MatrixPartition.Builder> builderEntry : builders.entrySet()) {
      Int2ObjectOpenHashMap<MatrixPartition> matrixPartMap =
          matrixPartitionOnPS.get(new ParameterServerId(builderEntry.getKey()));
      if (matrixPartMap == null) {
        matrixPartMap = new Int2ObjectOpenHashMap<MatrixPartition>();
        matrixPartitionOnPS.put(new ParameterServerId(builderEntry.getKey()), matrixPartMap);
      }
      
      matrixPartMap.put(builderEntry.getValue().getMatrixId(), builderEntry.getValue().build());
      
      ObjectOpenHashSet<ParameterServerId> psSet = matrixIdToPSSetMap.get(builderEntry.getValue().getMatrixId());
      if(psSet == null) {
        psSet = new ObjectOpenHashSet<ParameterServerId>();
        matrixIdToPSSetMap.put(builderEntry.getValue().getMatrixId(), psSet);
      }
      psSet.add(new ParameterServerId(builderEntry.getKey()));
      
      LOG.info("ps index: " + builderEntry.getKey() + ", matrixPartition info(matrixId: " + matrixId
          + ")");
    }
  }

  private void updateMaxMatrixId(int id) {
    if (maxMatrixId < id) {
      maxMatrixId = id;
    }
    LOG.debug("update maxMatrixId  to " + maxMatrixId);
  }

  private int assignMatrixId() {
    return ++maxMatrixId;
  }

  /**
   * compare the matrix meta on the master and the matrix meta on ps to find the matrix this parameter server needs to create and delete
   * @param matrixReports parameter server matrix report, include the matrix ids this parameter server hold.
   * @param needCreateMatrixes use to return the matrix partitions this parameter server need to build
   * @param needReleaseMatrixes use to return the matrix ids this parameter server need to remove
   * @param psId parameter server id
  */
  public void syncMatrixInfos(List<MatrixReport> matrixReports,
      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {
    //get matrix ids in the parameter server report
    IntOpenHashSet matrixInPS = new IntOpenHashSet();
    int size = matrixReports.size();
    for (int i = 0; i < size; i++) {
      matrixInPS.add(matrixReports.get(i).getMatrixId());
    }
    
    //get the matrices parameter server need to create and delete
    getPSNeedUpdateMatrix(matrixInPS, needCreateMatrixes, needReleaseMatrixes, psId);
  }

  private void getPSNeedUpdateMatrix(IntOpenHashSet matrixInPS,
      List<MatrixPartition> needCreateMatrixes, List<Integer> needReleaseMatrixes, ParameterServerId psId) {
    try {
      readLock.lock();
      Map<Integer, MatrixPartition> matrixIdToPartition = matrixPartitionOnPS.get(psId);

      if (matrixIdToPartition == null) {
        return;
      }

      //if a matrix exists on parameter server but not exist on master, we should notify the parameter server to remove this matrix
      for (int matrixId : matrixInPS) {
        LOG.debug("matrix in ps " + matrixId);
        if (!matrixIdToPartition.containsKey(matrixId)) {
          LOG.debug("matrix " + matrixId + " need release");
          needReleaseMatrixes.add(matrixId);
        }
      }

      //if a matrix exists on master but not exist on parameter server, this parameter server need build it.
      for (Entry<Integer, MatrixPartition> matrixPartEntry : matrixIdToPartition.entrySet()) {
        LOG.debug("matrix in master " + matrixPartEntry.getKey() + ", "
            + matrixPartEntry.getValue().getMatrixName());
        if (!matrixInPS.contains(matrixPartEntry.getKey())) {
          needCreateMatrixes.add(matrixPartEntry.getValue());
        }
      }
    } finally {
      readLock.unlock();
    }
  }
  
  /**
   * Update the matrices on the PS
   * @param psId
   * @param matrixReports
   */
  public void psMatricesUpdate(ParameterServerId psId, List<MatrixReport> matrixReports) {
    try {
      writeLock.lock();
      IntOpenHashSet matrixIdSet = psIdToMatrixIdsMap.get(psId);
      if(matrixIdSet == null) {
        matrixIdSet = new IntOpenHashSet();
        psIdToMatrixIdsMap.put(psId, matrixIdSet);
      }
      
      int size = matrixReports.size();
      for(int i = 0; i < size; i++) {
        matrixIdSet.add(matrixReports.get(i).getMatrixId());
      }
    } finally {
      writeLock.unlock();
    }
  }

  /**
   * release a matrix. just release matrix meta on master
   * TODO:maybe we need a method that can wait all parameter servers release this matrix
   * @param matrixId the matrix need release
   */
  public void releaseMatrix(int matrixId) {
    try {
      writeLock.lock();
      LOG.info("matrix id=" + matrixId);
      matrixProtoMap.remove(matrixId);
      matrixIdToPSSetMap.remove(matrixId);
      
      for (Int2ObjectOpenHashMap<MatrixPartition> entry : matrixPartitionOnPS.values()) {
        entry.remove(matrixId);
      }

      ObjectIterator<Entry<String, Integer>> iter = matrixNameToIdMap.entrySet().iterator();
      while (iter.hasNext()) {
        if (iter.next().getValue() == matrixId) {
          iter.remove();
          break;
        }
      }
    } finally {
      writeLock.unlock();
    }
    
    //waitForMatrixReleaseOnPS(matrixId);
  }

  /**
   * write matrix meta protos to output stream
   * @param output output stream
   * @throws IOException
   */
  public void serialize(FSDataOutputStream output) throws IOException {
    try {
      readLock.lock();
      if(matrixProtoMap == null) {
        return;
      }
      
      for(it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<MatrixProto> entry:matrixProtoMap.int2ObjectEntrySet()) {
        entry.getValue().writeDelimitedTo(output);
      }
    } finally {
      readLock.unlock();
    }
  }
  
  /**
   * read matrix meta protos from input stream
   * @param input input stream
   * @throws IOException, InvalidParameterException
   */
  public void deserialize(FSDataInputStream input) throws IOException, InvalidParameterException {
    List<MatrixProto> matrixProtos = new ArrayList<MatrixProto>();
    while(input.available() > 0) {
      MatrixProto matrixProto = MatrixProto.parseDelimitedFrom(input);
      LOG.info("deserilize from file matrixProto=" + matrixProto);
      matrixProtos.add(matrixProto);
    }
    addMatrices(matrixProtos);
  }

  /**
   * Get ps ids which contains the matrix
   * @param matrixId matrix id
   * @return ps id set
   */
  public Set<ParameterServerId> getPsIds(int matrixId) {
    return matrixIdToPSSetMap.get(matrixId);
  }
}
```


Overlapping Code:
```
etaManager {
private static final Log LOG = LogFactory.getLog(MatrixMetaManager.class);
/** matrix inited flag, worker/ps can get matrix info. only when matrix is initialized after am received matrixinfo from client */
//private boolean matrixInited;
/**matrix id to matrix meta proto map*/
private final Int2ObjectOpenHashMap<MatrixProto> matrixProtoMap;
/** inverted index, psId--->Map( matrixId---->List<PartitionKey>), used for PS */
private final Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>> matrixPartitionOnPS;

/** ps id to matrices on this ps map */
private final Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet> psIdToMatrixIdsMap;

/**matrix id generator*/
private int maxMatrixId = -1;

/**matrix name to id map*/
private final Object2IntOpenHashMap<String> matrixNameToIdMap;

/**matrix id to psId which has build partitions of this matrix map, use to add matrix */
private final Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>> matrixIdToPSSetMap;

private final Lock readLock;
private final Lock writeLock;
public MatrixMetaManager() {
matrixPartitionOnPS = new Object2ObjectOpenHashMap<ParameterServerId, Int2ObjectOpenHashMap<MatrixPartition>>();
matrixIdToPSSetMap = new Int2ObjectOpenHashMap<ObjectOpenHashSet<ParameterServerId>>();
psIdToMatrixIdsMap = new Object2ObjectOpenHashMap<ParameterServerId, IntOpenHashSet>();
matrixProtoMap = new Int2ObjectOpenHashMap<MatrixProto>();

matrixNameToIdMap = new Object2IntOpenHashMap<String>();
ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
readLock = readWriteLock.readLock();
writeLock = readWriteLock.writeLock();
}
/**
* get all matrices meta proto. 
* @return List<MatrixProto> all matrices meta proto list
*/
public final List<MatrixProto> getMatrixProtos() {
try {
readLock.lock();
List<MatrixProto> matrixes = new ArrayList<MatrixProto>();
for (Entry<Integer, MatrixProto> entry : matrixProtoMap.entrySet()) {
matrixes.add(entry.getValue());
}
return matrixes;
} finally {
readLock.unlock();
}
}

/**
* get matrix meta proto use matrix name
* @param matrixName matrix name
* @return MatrixProto matrix meta proto of the matrix, if not found, just return null
*/
public MatrixProto getMatrix(String matrixName) {
try {
read
```
<Overlap Ratio: 0.9830875975715525>

---

--- 37 --
Question ID: 631198c554366e4c829dbfbb04518fac1765181d
Original Code:
```
class ViewUtils {

	  public static int getWidth(View v) { 
		  return v.getLayoutParams().width; 
	  }
	  
	  public static int getHeight(View v) {
	    return v.getLayoutParams().height;
	  }
	  
	  public static int getLeft(View v){
		  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
	    return lp.left;
	  }
	  
	  public static int getTop(View v){
		RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
	    return lp.top;
	  }

	  public static void setWidth(View v,int width){
		    ViewGroup.LayoutParams lp = v.getLayoutParams();
		    lp.width = width;
		    requestLayout(v);
	   }
	  
	  public static void setHeight(View v,int height) {
	    ViewGroup.LayoutParams lp = v.getLayoutParams();
	    lp.height = height;
	    requestLayout(v);
	  }
	  
	  public static void setLeft(View v,int left) {
		  RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
	    lp.left = left;
	    requestLayout(v);
	  }
	  
	  public static void setTop(View v,int top) {
	    RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
	    lp.top = top;
	    requestLayout(v);
	  }
	  
	  private static void requestLayout(View v) { 
		  ViewParent parent = v.getParent();
	    if (parent != null) {
	      parent.requestLayout();
	    }
	  }
	  
	  public static int getTextWidth (TextView v) {
		return (int) MeasureStringWidth(new Paint(),v.getText().toString(),v.getTypeface(),v.getTextSize());
	  }
	  
	  private static float MeasureStringWidth(Paint paint,String Text, Typeface Typeface, float TextSize)
	  {
	    paint.setTextSize(TextSize);
	    paint.setTypeface(Typeface);
	    paint.setStrokeWidth(0.0F);
	    paint.setStyle(Paint.Style.STROKE);
	    paint.setTextAlign(Paint.Align.LEFT);
	    return paint.measureText(Text);
	  }
	  
	  public static void setClipToOutline(ViewGroup v) {
		  if (Build.VERSION.SDK_INT >= 21) {
			v.setClipToOutline(true);
		  }
	  }

	  public static void setClickEffect(View View, boolean Borderless) {
	    int[] attrs;	    
	    if (Borderless) {
	      attrs = new int[] { android.R.attr.selectableItemBackgroundBorderless };
	    } else {
	      attrs = new int[] { android.R.attr.selectableItemBackground };
	    }
	    TypedArray typedArray = View.getContext().obtainStyledAttributes(attrs);
	    int backgroundResource = typedArray.getResourceId(0, 0);
	    View.setBackgroundResource(backgroundResource);
	  }
	  	
	  public static void RemoveView(View view) {
	    if (view.getParent() instanceof ViewGroup) {
	      ViewGroup vg = (ViewGroup)view.getParent();
	      vg.removeView(view);
	    }
	  }
	  
	  public static void setElevation (View v,float e) {
		  if (Build.VERSION.SDK_INT >= 21) {
			  v.setElevation(e);
		  }
	  }
}
```


Overlapping Code:
```
tWidth(View v) { 
return v.getLayoutParams().width; 
}

public static int getHeight(View v) {
return v.getLayoutParams().height;
}

public static int getLeft(View v){
RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
return lp.left;
}

public static int getTop(View v){
RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
return lp.top;
}
public static void setWidth(View v,int width){
ViewGroup.LayoutParams lp = v.getLayoutParams();
lp.width = width;
requestLayout(v);
}

public static void setHeight(View v,int height) {
ViewGroup.LayoutParams lp = v.getLayoutParams();
lp.height = height;
requestLayout(v);
}

public static void setLeft(View v,int left) {
RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
lp.left = left;
requestLayout(v);
}

public static void setTop(View v,int top) {
RateDialogLayout.LayoutParams lp = (RateDialogLayout.LayoutParams)v.getLayoutParams();
lp.top = top;
requestLayout(v);
}

private static void requestLayout(View v) { 
ViewParent parent = v.getParent();
if (parent != null) {
parent.requestLayout();
}
}

public static int getTextWidth (TextView v) {
return (int) MeasureStringWidth(new Paint(),v.getText().toString(),v.getTypeface(),v.getTextSize());
}

private static float MeasureStringWidth(Paint paint,String Text, Typeface Typeface, float TextSize)
{
paint.setTextSize(TextSize);
paint.setTypeface(Typeface);
paint.setStrokeWidth(0.0F);
paint.setStyle(Paint.Style.STROKE);
paint.setTextAlign(Paint.Align.LEFT);
return paint.measureText(Text);
}

public static void setClipToOutline(ViewGroup v) {
if (Build.VERSION.SDK_INT >= 21) {
v.setClipToOutline(true);
}
}
public static void setClickEffect(View View, boolean Borderless) {
int[] attrs; 
if (Borderless) {
attrs = new int[] { android.R.attr.selectableItemBackgroundBorderless };
} else {
attrs = new int[] { android.R.attr.selectableItemBackground };
}
TypedArray typedArray = View.getContext().obtainStyledAttributes(attrs);
int backgroundResource = typedArray.getResourceId(0, 0);
View.setBackgroundResource(backgroundResource);
```
<Overlap Ratio: 0.981642955484167>

---

--- 38 --
Question ID: 7c787218d14b5fd3d476665b129cf5b56607ca47
Original Code:
```
public class Geometry {

    private final int cylinders;
    private final int heads;
    private final int sectors;

    /**
     * Create a new instance
     *
     * @param c The number of cylinders
     * @param h The number of heads
     * @param s The number of sectors/cylinder
     */
    public Geometry(int c, int h, int s) {
        this.cylinders = c;
        this.heads = h;
        this.sectors = s;
    }

    /**
     * @return int
     */
    public int getCylinders() {
        return cylinders;
    }

    /**
     * @return int
     */
    public int getHeads() {
        return heads;
    }

    /**
     * @return int
     */
    public int getSectors() {
        return sectors;
    }

    /**
     * Gets the total number of sectors
     *
     * @return int
     */
    public long getTotalSectors() {
        long v = cylinders;
        v *= heads;
        v *= sectors;
        return v;
    }

    /**
     * Gets the logical sector number for a given CHS.
     *
     * @param chs
     * @return long
     */
    public long getLogicalSector(CHS chs) {
        //ls = c*H*S + h*S + s - 1
        long v = chs.getCylinder() * heads * sectors;
        v += chs.getHead() * sectors;
        v += chs.getSector();
        return v - 1;
    }

    /**
     * Gets a CHS from a given logical sector number
     *
     * @param logicalSector
     * @return CHS
     * @throws GeometryException
     */
    public CHS getCHS(long logicalSector) throws GeometryException {
        // ls = (c*H + h) * S + s - 1

        long v = logicalSector;
        int s = (int) ((v % sectors) + 1);
        v = v / sectors;
        int h = (int) (v % heads);
        v = v / heads;
        int c = (int) v;

        try {
            return new CHS(c, h, s);
        } catch (IllegalArgumentException iae) {
            throw new GeometryException("can't get CHS for logical sector " + logicalSector, iae);
        }
    }

    /**
     * increments the given sector and returns the next logical sector as CHS-value
     *
     * @param chsToIncrement
     * @return the CHS value of next sector
     * @throws GeometryException
     */
    public CHS nextSector(CHS chsToIncrement) throws GeometryException {

        int s = chsToIncrement.getSector();
        int h = chsToIncrement.getHead();
        int c = chsToIncrement.getCylinder();

        s++;

        if (s > sectors) {
            s = 1;
            h++;
            if (h >= heads) {
                h = 0;
                c++;
                if (c >= cylinders) {
                    throw new GeometryException("this geometry doesn't support cyclinder" + c);
                }
            }
        }
        return new CHS(c, h, s);
    }
}
```


Overlapping Code:
```
eometry {
private final int cylinders;
private final int heads;
private final int sectors;
/**
* Create a new instance
*
* @param c The number of cylinders
* @param h The number of heads
* @param s The number of sectors/cylinder
*/
public Geometry(int c, int h, int s) {
this.cylinders = c;
this.heads = h;
this.sectors = s;
}
/**
* @return int
*/
public int getCylinders() {
return cylinders;
}
/**
* @return int
*/
public int getHeads() {
return heads;
}
/**
* @return int
*/
public int getSectors() {
return sectors;
}
/**
* Gets the total number of sectors
*
* @return int
*/
public long getTotalSectors() {
long v = cylinders;
v *= heads;
v *= sectors;
return v;
}
/**
* Gets the logical sector number for a given CHS.
*
* @param chs
* @return long
*/
public long getLogicalSector(CHS chs) {
//ls = c*H*S + h*S + s - 1
long v = chs.getCylinder() * heads * sectors;
v += chs.getHead() * sectors;
v += chs.getSector();
return v - 1;
}
/**
* Gets a CHS from a given logical sector number
*
* @param logicalSector
* @return CHS
* @throws GeometryException
*/
public CHS getCHS(long logicalSector) throws GeometryException {
// ls = (c*H + h) * S + s - 1
long v = logicalSector;
int s = (int) ((v % sectors) + 1);
v = v / sectors;
int h = (int) (v % heads);
v = v / heads;
int c = (int) v;
try {
return new CHS(c, h, s);
} catch (IllegalArgumentException iae) {
throw new GeometryException("can't get CHS for logical sector " + logicalSector, iae);
}
}
/**
* increments the given sector and returns the next logical sector as CHS-value
*
* @param chsToIncrement
* @return the CHS value of next sector
* @throws GeometryException
*/
public CHS nextSector(CHS chsToIncrement) throws GeometryException {
int s = chsToIncrement.getSector();
int h = chsToIncrement.getHead();
int c = chsToIncrement.getCylinder();
s++;
if (s > sectors) {
s = 1;
h++;
if (h
```
<Overlap Ratio: 0.9824747742963357>

---

--- 39 --
Question ID: 1095f883169fe8e73414faba2c65ad8c7b569ea6
Original Code:
```
public class FloatType extends NumericType {

  private static FloatType instance = null;

  public static FloatType getType() {
    if (instance != null) {
      return instance;
    }
    instance = new FloatType();
    return instance;
  }

  @Override
  public boolean isFloatType() {
    return true;
  }

  @Override
  public String getName() {
    return "float";
  }

  @Override
  public String getCName() {
    return "double";
  }

  @Override
  public Type combine(Type that) {
    // Combining two equal types always works
    if (that.equals(this)) {
      return this;
    }

    if (that.equals(Type.getIntegerType())) {
      return Type.getFloatType();
    }

    // Every remaining type will throw a RuntimeException
    throw new RuntimeException("Type missmatch: cannot combine " + this.getName() + " and " + that.getName());
  }

}
```


Overlapping Code:
```
ass FloatType extends NumericType {
private static FloatType instance = null;
public static FloatType getType() {
if (instance != null) {
return instance;
}
instance = new FloatType();
return instance;
}
@Override
public boolean isFloatType() {
return true;
}
@Override
public String getName() {
return "float";
}
@Override
public String getCName() {
return "double";
}
@Override
public Type combine(Type that) {
// Combining two equal types always works
if (that.equals(this)) {
return this;
}
if (that.equals(Type.getIntegerType())) {
return Type.getFloatType();
}
// Every remaining type will throw a RuntimeException
throw new RuntimeException("Type missmatch: cannot combine " + this.getName() + " and " + that.ge
```
<Overlap Ratio: 0.9702702702702702>

---

--- 40 --
Question ID: 56689567a1d20b80e690d0936b6065cb15190778
Original Code:
```
class EqualityFieldKeySelector implements KeySelector<RowData, Integer> {

  private final Schema schema;
  private final RowType flinkSchema;
  private final Schema deleteSchema;

  private transient RowDataWrapper rowDataWrapper;
  private transient StructProjection structProjection;
  private transient StructLikeWrapper structLikeWrapper;

  EqualityFieldKeySelector(Schema schema, RowType flinkSchema, List<Integer> equalityFieldIds) {
    this.schema = schema;
    this.flinkSchema = flinkSchema;
    this.deleteSchema = TypeUtil.select(schema, Sets.newHashSet(equalityFieldIds));
  }

  /**
   * Construct the {@link RowDataWrapper} lazily here because few members in it are not serializable. In this way, we
   * don't have to serialize them with forcing.
   */
  protected RowDataWrapper lazyRowDataWrapper() {
    if (rowDataWrapper == null) {
      rowDataWrapper = new RowDataWrapper(flinkSchema, schema.asStruct());
    }
    return rowDataWrapper;
  }

  /**
   * Construct the {@link StructProjection} lazily because it is not serializable.
   */
  protected StructProjection lazyStructProjection() {
    if (structProjection == null) {
      structProjection = StructProjection.create(schema, deleteSchema);
    }
    return structProjection;
  }

  /**
   * Construct the {@link StructLikeWrapper} lazily because it is not serializable.
   */
  protected StructLikeWrapper lazyStructLikeWrapper() {
    if (structLikeWrapper == null) {
      structLikeWrapper = StructLikeWrapper.forType(deleteSchema.asStruct());
    }
    return structLikeWrapper;
  }

  @Override
  public Integer getKey(RowData row) {
    RowDataWrapper wrappedRowData = lazyRowDataWrapper().wrap(row);
    StructProjection projectedRowData = lazyStructProjection().wrap(wrappedRowData);
    StructLikeWrapper wrapper = lazyStructLikeWrapper().set(projectedRowData);
    return wrapper.hashCode();
  }
}
```


Overlapping Code:
```
alityFieldKeySelector implements KeySelector<RowData, Integer> {
private final Schema schema;
private final RowType flinkSchema;
private final Schema deleteSchema;
private transient RowDataWrapper rowDataWrapper;
private transient StructProjection structProjection;
private transient StructLikeWrapper structLikeWrapper;
EqualityFieldKeySelector(Schema schema, RowType flinkSchema, List<Integer> equalityFieldIds) {
this.schema = schema;
this.flinkSchema = flinkSchema;
this.deleteSchema = TypeUtil.select(schema, Sets.newHashSet(equalityFieldIds));
}
/**
* Construct the {@link RowDataWrapper} lazily here because few members in it are not serializable. In this way, we
* don't have to serialize them with forcing.
*/
protected RowDataWrapper lazyRowDataWrapper() {
if (rowDataWrapper == null) {
rowDataWrapper = new RowDataWrapper(flinkSchema, schema.asStruct());
}
return rowDataWrapper;
}
/**
* Construct the {@link StructProjection} lazily because it is not serializable.
*/
protected StructProjection lazyStructProjection() {
if (structProjection == null) {
structProjection = StructProjection.create(schema, deleteSchema);
}
return structProjection;
}
/**
* Construct the {@link StructLikeWrapper} lazily because it is not serializable.
*/
protected StructLikeWrapper lazyStructLikeWrapper() {
if (structLikeWrapper == null) {
structLikeWrapper = StructLikeWrapper.forType(deleteSchema.asStruct());
}
return structLikeWrapper;
}
@Override
public Integer getKey(RowData row) {
RowDataWrapper wrappedRowData = lazyRowDataWrapper().wrap(row);
StructProjection projectedRowData = lazyStructProjection().wrap(wrappedRowData);
StructLikeWrapper wrapper = lazyStructLikeWrapper().set(projectedRowData
```
<Overlap Ratio: 0.9758897818599311>

---

--- 41 --
Question ID: fc23781727c40a92464bbeb45243c7bcfc8fbac7
Original Code:
```
@Service
public class SignUpServiceImpl implements SignUpService {
	
	private SignUpClient signUpClient;
	private String headerPrefix;
	private TextEncryptor textEncryptor;

	@Override
	public void signUp(TopicUser user) {
		String token = null;
		String encryptedPassword = textEncryptor.encrypt(user.getPassword());
		user.setPassword(encryptedPassword);
		ResponseEntity<Object> entity = signUpClient.signUp(user);
		if(entity.getStatusCode() == CREATED){
			String username = user.getUsername();
			token = entity.getHeaders().getFirst(headerPrefix);
			TopicWebUtils.bindUserSession(username, token);
		}
	}
	
	@Autowired
	public void setSignUpClient(SignUpClient signUpClient) {
		this.signUpClient = signUpClient;
	}
	
	@Autowired
	public void setTextEncryptor(TextEncryptor textEncryptor) {
		this.textEncryptor = textEncryptor;
	}

	@Value(Constants.HEADER_STRING)
	public void setHeaderPrefix(String headerPrefix) {
		this.headerPrefix = headerPrefix;
	}
	
	

}
```


Overlapping Code:
```
rvice
public class SignUpServiceImpl implements SignUpService {

private SignUpClient signUpClient;
private String headerPrefix;
private TextEncryptor textEncryptor;
@Override
public void signUp(TopicUser user) {
String token = null;
String encryptedPassword = textEncryptor.encrypt(user.getPassword());
user.setPassword(encryptedPassword);
ResponseEntity<Object> entity = signUpClient.signUp(user);
if(entity.getStatusCode() == CREATED){
String username = user.getUsername();
token = entity.getHeaders().getFirst(headerPrefix);
TopicWebUtils.bindUserSession(username, token);
}
}

@Autowired
public void setSignUpClient(SignUpClient signUpClient) {
this.signUpClient = signUpClient;
}

@Autowired
public void setTextEncryptor(TextEncryptor textEncryptor) {
this.textEncryptor = textEncryptor;
}
@Value(Constants.HEADER_STRING)
public void setHeaderPrefix(String headerPrefix) {
this.headerPrefix = headerP
```
<Overlap Ratio: 0.9837133550488599>

---

--- 42 --
Question ID: dd9c20dfd25add4d214e93e3a7976446cb8d5899
Original Code:
```
public class PrettyMessageBuilder extends TestEnvironment {

    public static String getXmlSuiteName(ITestContext iTestContext) {
        return iTestContext.getCurrentXmlTest().getSuite().getName();
    }

    public static String getXmlTestName(ITestContext iTestContext) {
        return iTestContext.getName();
    }

    public static String getTestDescription(ITestResult iTestResult) {
        return iTestResult.getMethod().getDescription().toUpperCase();
    }

    public static void messageStartSuite(ITestContext iTestContext) {
        logger.info(StringUtils.repeat("#", 110));
        logger.info(StringUtils.repeat("=", 31) + "STARTING TEST SUITE " + iTestContext.getStartDate() + StringUtils.repeat("=", 30));
        logger.info(StringUtils.repeat("#", 110));
    }

    public static void messageEndSuite(ITestContext iTestContext) {
        logger.info(StringUtils.repeat("#", 110));
        logger.info(StringUtils.repeat("=", 32) + "END OF TEST SUITE " + iTestContext.getEndDate() + StringUtils.repeat("=", 31));
        logger.info(StringUtils.repeat("#", 110));
    }

    public static void messageStartTest(ITestResult iTestResult) {
        logger.info(StringUtils.repeat("=", 48) + " TEST STARTED " + StringUtils.repeat("=", 48));
        logger.info(ANSI_BLUE + "TEST NAME: " + getTestDescription(iTestResult) + ANSI_RESET);
        logger.info(String.format("Chosen executor: \"%S\"", DriverFactory.getHost()));
    }

    public static void messageSuccessTest() {
        logger.info(StringUtils.repeat("=", 37) + " TEST FINISHED WITH " + ANSI_GREEN + "SUCCESS STATUS " + ANSI_RESET + StringUtils.repeat("=", 38));
    }

    public static void messageFailTest() {
        logger.info(StringUtils.repeat("=", 38) + " TEST FINISHED WITH " + ANSI_RED + "FAILED STATUS " + ANSI_RESET + StringUtils.repeat("=", 38));
    }

    public static void messageStartScenario(Scenario scenario) {
        logger.info(StringUtils.repeat("#", 110));
        logger.info(StringUtils.repeat("=", 46) + " BEFORE SCENARIO " + StringUtils.repeat("=", 47));
        logger.info(StringUtils.repeat("#", 110));
        logger.info(ANSI_BLUE + "SCENARIO NAME: " + scenario.getName().toUpperCase() + ANSI_RESET);
        logger.info(String.format("Chosen executor: \"%S\"", DriverFactory.getHost()));
    }

    public static void messageFinishScenario(Scenario scenario) {
        String status = (scenario.isFailed() ? ANSI_RED + "FAILED STATUS " + ANSI_RESET : ANSI_GREEN + "SUCCESS STATUS " + ANSI_RESET);
        logger.info(StringUtils.repeat("#", 110));
        logger.info(StringUtils.repeat("=", 36) + " SCENARIO FINISHED WITH " + status + StringUtils.repeat("=", 35));
        logger.info(StringUtils.repeat("#", 110));
        System.out.println();
    }
}
```


Overlapping Code:
```
lass PrettyMessageBuilder extends TestEnvironment {
public static String getXmlSuiteName(ITestContext iTestContext) {
return iTestContext.getCurrentXmlTest().getSuite().getName();
}
public static String getXmlTestName(ITestContext iTestContext) {
return iTestContext.getName();
}
public static String getTestDescription(ITestResult iTestResult) {
return iTestResult.getMethod().getDescription().toUpperCase();
}
public static void messageStartSuite(ITestContext iTestContext) {
logger.info(StringUtils.repeat("#", 110));
logger.info(StringUtils.repeat("=", 31) + "STARTING TEST SUITE " + iTestContext.getStartDate() + StringUtils.repeat("=", 30));
logger.info(StringUtils.repeat("#", 110));
}
public static void messageEndSuite(ITestContext iTestContext) {
logger.info(StringUtils.repeat("#", 110));
logger.info(StringUtils.repeat("=", 32) + "END OF TEST SUITE " + iTestContext.getEndDate() + StringUtils.repeat("=", 31));
logger.info(StringUtils.repeat("#", 110));
}
public static void messageStartTest(ITestResult iTestResult) {
logger.info(StringUtils.repeat("=", 48) + " TEST STARTED " + StringUtils.repeat("=", 48));
logger.info(ANSI_BLUE + "TEST NAME: " + getTestDescription(iTestResult) + ANSI_RESET);
logger.info(String.format("Chosen executor: \"%S\"", DriverFactory.getHost()));
}
public static void messageSuccessTest() {
logger.info(StringUtils.repeat("=", 37) + " TEST FINISHED WITH " + ANSI_GREEN + "SUCCESS STATUS " + ANSI_RESET + StringUtils.repeat("=", 38));
}
public static void messageFailTest() {
logger.info(StringUtils.repeat("=", 38) + " TEST FINISHED WITH " + ANSI_RED + "FAILED STATUS " + ANSI_RESET + StringUtils.repeat("=", 38));
}
public static void messageStartScenario(Scenario scenario) {
logger.info(StringUtils.repeat("#", 110));
logger.info(StringUtils.repeat("=", 46) + " BEFORE SCENARIO " + StringUtils.repeat("=", 47));
logger.info(StringUtils.repeat("#", 110));
logger.info(ANSI_BLUE + "SCENARIO NAME: " + scenario.getName().toUpperCase() + ANSI_RESET);
logger.info(String.format("Chosen executor: \"%S\"", DriverFactory.getHost()));
}
public static void messageFinishScenario(Scenario scenario) {
String status = (scenario.isFailed() ? ANSI_RED + "FAILED STATUS
```
<Overlap Ratio: 0.9764758100310696>

---

--- 43 --
Question ID: 6a5919bb5a1a6e3ceda0a214dc0fefe2dec4fd93
Original Code:
```
@InjectionContainerContext(value = ModuleContainerForTests.class, disableRequiresNewTransaction = true)
@RunWith(InjectionJUnitTestRunner.class)
@TransactionAttribute
public class JPANewTransactionScopeDisabledUnitT {

    @Inject
    private TransactedApplication application;

    @Inject
    private TransactionManager transactionManager;

    @BeforeClass
    public static void initClass() {
        TransactionLogging.enableLogging = true;
    }

    @AfterClass
    public static void destroy() {
        TransactionLogging.enableLogging = false;

        /*

        TODO: REDO this as the static context and the "thread aware" container will
        always fail in strange ways

        InjectContainer container = ModuleContainerForTests.container;
        TransactedApplication application = container.get(TransactedApplication.class);
        Collection<Person> persons = application.findAllPersons();

        assertEquals(0, persons.size());
        */

    }


    @Test
    public void testSingleTransactionWithOpenMainTx2() {

        Person person = StubUtil.createPerson();
        application.createPersonNewTx(person);
        // Rollback the transaction, will not rollback the req new (as it should be committed)
        transactionManager.rollback();


        Person foundPerson = application.findPerson(person.getId());
        assertNull(foundPerson);


        assertFalse(transactionManager.isActive());

    }

    @Test
    public void testSingleTransaction2() {

        Person person = StubUtil.createPerson();
        Person foundPerson = application.depthyTransactionsNewTx(person);

        assertEquals(foundPerson.getName(), person.getName());

        assertTrue(transactionManager.isActive());

    }

    @Test
    public void testSingleTransactionWithErrorAndLogging2() {

        Person person = StubUtil.createPerson();
        Logging log = StubUtil.createLogg("A log message");
        // This code can not work without REQUIRES_NEW and is just a proof of how the restrictions must be handled.

        try {
            Person foundPerson = application.complexTransactionsNewTx(person, log);
            assertEquals("Expected error", foundPerson.getName());
        } catch (Exception e) {
            assertEquals("Transaction is marked for rollback only", e.getMessage());
            assertFalse(transactionManager.isActive());
        }
    }

}
```


Overlapping Code:
```
ContainerContext(value = ModuleContainerForTests.class, disableRequiresNewTransaction = true)
@RunWith(InjectionJUnitTestRunner.class)
@TransactionAttribute
public class JPANewTransactionScopeDisabledUnitT {
@Inject
private TransactedApplication application;
@Inject
private TransactionManager transactionManager;
@BeforeClass
public static void initClass() {
TransactionLogging.enableLogging = true;
}
@AfterClass
public static void destroy() {
TransactionLogging.enableLogging = false;
/*
TODO: REDO this as the static context and the "thread aware" container will
always fail in strange ways
InjectContainer container = ModuleContainerForTests.container;
TransactedApplication application = container.get(TransactedApplication.class);
Collection<Person> persons = application.findAllPersons();
assertEquals(0, persons.size());
*/
}
@Test
public void testSingleTransactionWithOpenMainTx2() {
Person person = StubUtil.createPerson();
application.createPersonNewTx(person);
// Rollback the transaction, will not rollback the req new (as it should be committed)
transactionManager.rollback();
Person foundPerson = application.findPerson(person.getId());
assertNull(foundPerson);
assertFalse(transactionManager.isActive());
}
@Test
public void testSingleTransaction2() {
Person person = StubUtil.createPerson();
Person foundPerson = application.depthyTransactionsNewTx(person);
assertEquals(foundPerson.getName(), person.getName());
assertTrue(transactionManager.isActive());
}
@Test
public void testSingleTransactionWithErrorAndLogging2() {
Person person = StubUtil.createPerson();
Logging log = StubUtil.createLogg("A log message");
// This code can not work without REQUIRES_NEW and is just a proof of how the restrictions must be handled.
try {
Person foundPerson = application.complexTransactionsNewTx(person, log);
assertEquals("Expected error", foundPerson.getName());
} catch (Exception e) {
assertEquals("Transaction is marked for rollback only", e.getMessage());
assertFalse(transactionManager.isActive());
}
```
<Overlap Ratio: 0.993103448275862>

---

--- 44 --
Question ID: 7143d367ebe41f7fb07abe10fac5c371b57a7275
Original Code:
```
public final class SearchPanelRenderer {
  private final static int MAX_AVATARS = 3;

  /** Profile provider, for avatars. */
  private final ProfileManager profiles;

  public SearchPanelRenderer(ProfileManager profiles) {
    this.profiles = profiles;
  }

  /**
   * Renders a digest model into a digest view.
   */
  public void render(Digest digest, DigestView digestUi) {
    Collection<Profile> avatars = CollectionUtils.createQueue();
    if (digest.getAuthor() != null) {
      avatars.add(profiles.getProfile(digest.getAuthor()));
    }
    for (ParticipantId other : digest.getParticipantsSnippet()) {
      if (avatars.size() < MAX_AVATARS) {
        avatars.add(profiles.getProfile(other));
      } else {
        break;
      }
    }

    digestUi.setAvatars(avatars);
    digestUi.setTitleText(digest.getTitle());
    digestUi.setSnippet(digest.getSnippet());
    digestUi.setMessageCounts(digest.getUnreadCount(), digest.getBlipCount());
    digestUi.setTimestamp(
        DateUtils.getInstance().formatPastDate((long) digest.getLastModifiedTime()));
  }
}
```


Overlapping Code:
```
ic final class SearchPanelRenderer {
private final static int MAX_AVATARS = 3;
/** Profile provider, for avatars. */
private final ProfileManager profiles;
public SearchPanelRenderer(ProfileManager profiles) {
this.profiles = profiles;
}
/**
* Renders a digest model into a digest view.
*/
public void render(Digest digest, DigestView digestUi) {
Collection<Profile> avatars = CollectionUtils.createQueue();
if (digest.getAuthor() != null) {
avatars.add(profiles.getProfile(digest.getAuthor()));
}
for (ParticipantId other : digest.getParticipantsSnippet()) {
if (avatars.size() < MAX_AVATARS) {
avatars.add(profiles.getProfile(other));
} else {
break;
}
}
digestUi.setAvatars(avatars);
digestUi.setTitleText(digest.getTitle());
digestUi.setSnippet(digest.getSnippet());
digestUi.setMessageCounts(digest.getUnreadCount(), digest.getBlipCount());
digestUi.setTimestamp(
DateUtils.getInstance().formatPastDate((long) digest.getLastModifiedTime()));
}
}
```
<Overlap Ratio: 0.9958071278825996>

---

--- 45 --
Question ID: 8b7c1370f4e3490d080d8f8bb611a8ce21de42a9
Original Code:
```
public class SpringDemo8 {

	@Test
	public void demo1() {
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext8.xml");
		ProductService productService = (ProductService) context.getBean("productService");
		productService.save();

		((ClassPathXmlApplicationContext) context).close();
	}

	@Test
	public void demo2() {
		ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext8.xml");
		OrderService service = (OrderService) context.getBean("orderService");
		service.save();

		((ClassPathXmlApplicationContext) context).close();
	}
}
```


Overlapping Code:
```
emo8 {
@Test
public void demo1() {
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext8.xml");
ProductService productService = (ProductService) context.getBean("productService");
productService.save();
((ClassPathXmlApplicationContext) context).close();
}
@Test
public void demo2() {
ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext8.xml");
OrderService service = (OrderService) context.getBean("orderService");
service.save();
((ClassPathXmlApplicationContext) context).close();
}
}
```
<Overlap Ratio: 0.9649122807017544>

---

--- 46 --
Question ID: 8006237289788fd6b0a041805561ee24f746645b
Original Code:
```
public class DnaSequence {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String seq = sc.next(), maxStr = "";
        int minSubstrLen = sc.nextInt(), count;
        sc.close();
        double maxRatio = 0.0;
        for (int i = 0; i <= seq.length() - minSubstrLen; i++) {
            for (int j = i + minSubstrLen; j <= seq.length(); j++) {
                count = 0;
                for (int k = i; k < j; k++) {
                    if (seq.charAt(k) == 'G' || seq.charAt(k) == 'C') {
                        count++;
                    }
                }
                if (count * 1.0 / (j - i) > maxRatio) {
                    maxRatio = count * 1.0 / (j - i);
                    maxStr = seq.substring(i, j);
                }
            }
        }
        System.out.printf("%s", maxStr);
    }
}
```


Overlapping Code:
```
lic class DnaSequence {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String seq = sc.next(), maxStr = "";
int minSubstrLen = sc.nextInt(), count;
sc.close();
double maxRatio = 0.0;
for (int i = 0; i <= seq.length() - minSubstrLen; i++) {
for (int j = i + minSubstrLen; j <= seq.length(); j++) {
count = 0;
for (int k = i; k < j; k++) {
if (seq.charAt(k) == 'G' || seq.charAt(k) == 'C') {
count++;
}
}
if (count * 1.0 / (j - i) > maxRatio) {
maxRatio = count * 1.0 / (j - i);
maxStr = seq.substring(i, j);
}
}
}
System.out.printf("%s", maxSt
```
<Overlap Ratio: 0.9828473413379074>

---

--- 47 --
Question ID: 0914d1b4442209c610e77c3ba4620a79d6e1a5dd
Original Code:
```
public class FileLeafTest {

	private static Path basePath;
	private FileLeaf leaf;
	private Path file;
	private String fileName;
	private String content;

	// structure: rootBase -> parentA -> file
	private FolderComposite rootBase;
	private FolderComposite parentA;
	private FolderComposite parentB;

	private static Path folderA;
	private static Path folderB;


	private static final boolean cleanupFolder = true;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		basePath = Paths.get(FileUtils.getTempDirectoryPath(), "PeerWasp_Test_Tree");
		if(!Files.exists(basePath)) {
			Files.createDirectory(basePath);
		}

		folderA = basePath.resolve("folderA");
		if(!Files.exists(folderA)) {
			Files.createDirectory(folderA);
		}

		folderB = basePath.resolve("folderB");
		if(!Files.exists(folderB)) {
			Files.createDirectory(folderB);
		}
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		if(cleanupFolder) {
			FileUtils.deleteDirectory(basePath.toFile());
		}
	}

	@Before
	public void setUp() throws Exception {

		// create file with content in folderA
		fileName = "file1.txt";
		file = folderA.resolve(fileName);
		content = RandomStringUtils.randomAlphanumeric(1000);
		Files.write(file, content.getBytes());
		leaf = new TestFileLeaf(file, true);
		leaf.updateContentHash();


		rootBase = new TestFolderComposite(basePath, true, true); // root
		parentA = new TestFolderComposite(folderA, true, false); // not root
		parentB = new TestFolderComposite(folderB, true, false); // not root

		rootBase.putComponent(parentA.getPath(), parentA);
		rootBase.putComponent(parentB.getPath(), parentB);
		rootBase.putComponent(leaf.getPath(), leaf);

		assertNull(rootBase.getParent());
		assertEquals(parentA.getParent(), rootBase);
		assertEquals(parentB.getParent(), rootBase);
		assertEquals(leaf.getParent(), parentA);
		assertNotEquals(leaf.getParent(), parentB);
	}

	@After
	public void tearDown() throws Exception {
		leaf = null;
		content = null;
		file = null;
	}

	@Test
	public void testFileLeafCtr() throws IOException {
		String hash = PathUtils.computeFileContentHash(file);
		assertNotNull(hash);
		assertFalse(hash.isEmpty());

		FileLeaf leafA = new FileLeaf(file, true);
		leafA.updateContentHash();
		assertEquals(hash, leafA.getContentHash());

		FileLeaf leafB = new FileLeaf(file, false);
		assertEquals("", leafB.getContentHash());
	}

	@Test
	public void testIsFile() {
		assertTrue(leaf.isFile());
	}

	@Test
	public void testIsFolder() {
		assertFalse(leaf.isFolder());
	}

	@Test
	public void testGetAndSetPath() {
		assertNotNull(leaf.getPath());
		assertEquals(file, leaf.getPath());

		// "move" file to folderB by setting the path
		Path fileB = folderB.resolve(file.getFileName());
		leaf.setPath(fileB);
		assertEquals(fileB, leaf.getPath());

		// "rename" file
		Path newName = fileB.resolveSibling("newFileName.txt");
		leaf.setPath(newName);
		assertEquals(newName, leaf.getPath());
	}

	@Test
	public void testGetAction() {
		assertNotNull(leaf.getAction());
	}

	@Test
	public void testGetAndsetIsActionUploaded() {
		boolean isUploaded = leaf.isUploaded(); // initial expetced false
		assertFalse(leaf.isUploaded());

		isUploaded = !isUploaded; // toggle and test
		leaf.setIsUploaded(isUploaded);
		assertTrue(leaf.isUploaded());

		isUploaded = !isUploaded; // toggle and test
		leaf.setIsUploaded(isUploaded);
		assertFalse(leaf.isUploaded());
	}

	@Test
	public void testGetAndUpdateContentHash() throws IOException {
		String hash = PathUtils.computeFileContentHash(file);
		assertEquals(hash, leaf.getContentHash());

		for(int i = 0; i < 10; ++i) {
			// update file and test
			String s = RandomStringUtils.randomAlphanumeric(1000);
			Files.write(file, s.getBytes());
			hash = PathUtils.computeFileContentHash(file);
			boolean changed = leaf.updateContentHash();
			assertTrue(changed);
			assertEquals(hash, leaf.getContentHash());
		}

		// always same content and test
		String s = RandomStringUtils.randomAlphanumeric(1000);
		Files.write(file, s.getBytes());
		hash = PathUtils.computeFileContentHash(file);
		assertTrue(leaf.updateContentHash());
		for(int i = 0; i < 10; ++i) {
			Files.write(file, s.getBytes());
			boolean changed = leaf.updateContentHash();
			assertFalse(changed);
			assertEquals(hash, leaf.getContentHash());
		}
	}

	@Test
	public void testBubbleContentHashUpdate() throws IOException {
		String rootHash = rootBase.getContentHash();
		assertNotNull(rootHash);
		assertFalse(rootHash.isEmpty());

		String parentHash = parentA.getContentHash();
		assertNotNull(parentHash);
		assertFalse(parentHash.isEmpty());

		String s = RandomStringUtils.randomAlphanumeric(1000);
		Files.write(file, s.getBytes());
		leaf.updateContentHash();

		assertNotEquals(rootHash, rootBase.getContentHash());
		assertNotEquals(parentHash, parentA.getContentHash());
	}

	@Test
	public void testGetAndSetParent() {
		assertEquals(leaf.getParent(), parentA);

		leaf.setParent(parentB);

		assertEquals(leaf.getParent(), parentB);
	}

	@Test
	public void testIsReady() {
		// root is always "ready"
		assertTrue(rootBase.isReady());
		// because root is ready, parent should also be ready
		assertTrue(parentA.isReady());
		// parent is not yet uploaded -> file should not be ready
		assertFalse(leaf.isReady());

		// parent uploaded -> leaf is ready now
		parentA.setIsUploaded(true);
		assertTrue(leaf.isReady());

		// parent uploaded -> leaf is ready now
		parentA.setIsUploaded(false);
		assertFalse(leaf.isReady());
	}

//	@Test(expected=NotImplementedException.class)
//	public void testGetAndSetStructureHash() {
//		assertNotNull(leaf.getStructureHash());
//		assertTrue(leaf.getStructureHash().isEmpty());
//
//		leaf.setStructureHash("abc");
//		assertNotNull(leaf.getStructureHash());
//		assertEquals("abc", leaf.getStructureHash());
//	}

//	@Test(expected=NotImplementedException.class)
//	public void testGetComponent() {
//		assertNull(leaf.getComponent(Paths.get("aComponent")));
//	}

//	@Test(expected=NotImplementedException.class)
//	public void testPutComponent() {
//		leaf.putComponent(null, null);
//	}
//
//	@Test(expected=NotImplementedException.class)
//	public void testDeleteComponent() {
//		assertNull(leaf.deleteComponent(Paths.get("aComponent")));
//	}

}
```


Overlapping Code:
```
te static Path basePath;
private FileLeaf leaf;
private Path file;
private String fileName;
private String content;
// structure: rootBase -> parentA -> file
private FolderComposite rootBase;
private FolderComposite parentA;
private FolderComposite parentB;
private static Path folderA;
private static Path folderB;
private static final boolean cleanupFolder = true;
@BeforeClass
public static void setUpBeforeClass() throws Exception {
basePath = Paths.get(FileUtils.getTempDirectoryPath(), "PeerWasp_Test_Tree");
if(!Files.exists(basePath)) {
Files.createDirectory(basePath);
}
folderA = basePath.resolve("folderA");
if(!Files.exists(folderA)) {
Files.createDirectory(folderA);
}
folderB = basePath.resolve("folderB");
if(!Files.exists(folderB)) {
Files.createDirectory(folderB);
}
}
@AfterClass
public static void tearDownAfterClass() throws Exception {
if(cleanupFolder) {
FileUtils.deleteDirectory(basePath.toFile());
}
}
@Before
public void setUp() throws Exception {
// create file with content in folderA
fileName = "file1.txt";
file = folderA.resolve(fileName);
content = RandomStringUtils.randomAlphanumeric(1000);
Files.write(file, content.getBytes());
leaf = new TestFileLeaf(file, true);
leaf.updateContentHash();
rootBase = new TestFolderComposite(basePath, true, true); // root
parentA = new TestFolderComposite(folderA, true, false); // not root
parentB = new TestFolderComposite(folderB, true, false); // not root
rootBase.putComponent(parentA.getPath(), parentA);
rootBase.putComponent(parentB.getPath(), parentB);
rootBase.putComponent(leaf.getPath(), leaf);
assertNull(rootBase.getParent());
assertEquals(parentA.getParent(), rootBase);
assertEquals(parentB.getParent(), rootBase);
assertEquals(leaf.getParent(), parentA);
assertNotEquals(leaf.getParent(), parentB);
}
@After
public void tearDown() throws Exception {
leaf = null;
content = null;
file = null;
}
@Test
public void testFileLeafCtr() throws IOException {
String hash = PathUtils.computeFileContentHash(file);
assertNotNull(hash);
assertFalse(hash.isEmpty());
FileLeaf leafA = new FileLeaf(file, true);
leafA.updateContentHash();
assertEquals(hash, leafA.getContentHash());
FileLeaf leafB = new FileLeaf(file, false);
```
<Overlap Ratio: 0.9678838539375275>

---

--- 48 --
Question ID: 06a8d357be1d914b766b8791d5b07ad9c13f2a7a
Original Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
public class CompanyTest {

    @Autowired
    private CompanyRepository companyRepo;

    @Test
    public void companyRepositoryIsCreated() {
        assertNotNull(companyRepo);
    }

    @Test
    public void companyMustHaveId() {
        Company company = new Company();
        assertThrows(JpaSystemException.class, () -> companyRepo.save(company));
    }

    @Test
    public void companyWithIdCanBeAddedToDB() {
        Company company = new Company();
        company.setCompanyName("BedCompany");
        assertDoesNotThrow(() -> companyRepo.save(company));
    }

    @Test
    public void companyCanBeFetchedFromDB() {
        Company company = new Company();
        company.setCompanyName("BedCompany");
        companyRepo.save(company);
        Company dbCompany = companyRepo.findById("BedCompany").get();
        assertEquals(company.getCompanyName(), dbCompany.getCompanyName());
    }

    public Presentation addPresentationToCompany() {
        Company company = new Company();
        company.setCompanyName("BedCompany");

        Set<Presentation> presentations = new HashSet<>();
        Presentation p = new Presentation();
        p.setId(1);
        p.setDateOfPresentation(new Date());
        p.setCompanyPresenting(company);
        presentations.add(p);
        company.setPresentations(presentations);
        companyRepo.save(company);
        return p;
    }

    public int iteratorCount(Iterator iterator) {
        int count = 0;
        while (iterator.hasNext()) {
            iterator.next();
            count++;
        }
        return count;
    }

    @Test
    public void addingPresentationToCompanyAddsOne() {
        addPresentationToCompany();
        assertEquals(1, companyRepo.findById("BedCompany").get().getPresentations().size());
    }

    @Test
    public void canFindPresentationsRelatedToCompany() {
        Presentation pres = addPresentationToCompany();
        Presentation stored = companyRepo.findById("BedCompany").get().getPresentations().iterator().next();

        // Check that date is the same, needs to be compare to because formats can be different
        //assertEquals(0, stored.getDateOfPresentation().compareTo(pres.getDateOfPresentation()));

        // Check that presenting company is the same
        assertEquals(stored.getCompanyPresenting().getCompanyName(), pres.getCompanyPresenting().getCompanyName());
    }
}
```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
public class CompanyTest {
@Autowired
private CompanyRepository companyRepo;
@Test
public void companyRepositoryIsCreated() {
assertNotNull(companyRepo);
}
@Test
public void companyMustHaveId() {
Company company = new Company();
assertThrows(JpaSystemException.class, () -> companyRepo.save(company));
}
@Test
public void companyWithIdCanBeAddedToDB() {
Company company = new Company();
company.setCompanyName("BedCompany");
assertDoesNotThrow(() -> companyRepo.save(company));
}
@Test
public void companyCanBeFetchedFromDB() {
Company company = new Company();
company.setCompanyName("BedCompany");
companyRepo.save(company);
Company dbCompany = companyRepo.findById("BedCompany").get();
assertEquals(company.getCompanyName(), dbCompany.getCompanyName());
}
public Presentation addPresentationToCompany() {
Company company = new Company();
company.setCompanyName("BedCompany");
Set<Presentation> presentations = new HashSet<>();
Presentation p = new Presentation();
p.setId(1);
p.setDateOfPresentation(new Date());
p.setCompanyPresenting(company);
presentations.add(p);
company.setPresentations(presentations);
companyRepo.save(company);
return p;
}
public int iteratorCount(Iterator iterator) {
int count = 0;
while (iterator.hasNext()) {
iterator.next();
count++;
}
return count;
}
@Test
public void addingPresentationToCompanyAddsOne() {
addPresentationToCompany();
assertEquals(1, companyRepo.findById("BedCompany").get().getPresentations().size());
}
@Test
public void canFindPresentationsRelatedToCompany() {
Presentation pres = addPresentationToCompany();
Presentation stored = companyRepo.findById("BedCompany").get().getPresentations().iterator().next();
// Check that date is the same, needs to be compare to because formats can be different
//assertEquals(0, stored.getDateOfPresentation().compareTo(pres.getDateOfPresentation()));
// Check that presenting company is the same
assertEquals(stored.getCompanyPresenting().getCompanyName(), pres.getCompanyPresenting().getCompanyN
```
<Overlap Ratio: 0.9946183953033269>

---

--- 49 --
Question ID: e016aad04f98aba884732f9d3248fe553d62ea84
Original Code:
```
@Extension(
        name = "create",
        namespace = "file",
        description = "Create a file or a folder in the given location",
        parameters = {
                @Parameter(
                        name = "uri",
                        description = "Absolute file path which needs to be created.",
                        type = DataType.STRING,
                        dynamic = true
                ),
                @Parameter(
                        name = "is.directory",
                        description = "This flag is used when creating file path is a directory",
                        type = DataType.BOOL,
                        dynamic = true,
                        optional = true,
                        defaultValue = "false"
                ),
                @Parameter(
                        name = "file.system.options",
                        description = "The file options in key:value pairs separated by commas. \n" +
                                "eg:'USER_DIR_IS_ROOT:false,PASSIVE_MODE:true,AVOID_PERMISSION_CHECK:true," +
                                "IDENTITY:file://demo/.ssh/id_rsa,IDENTITY_PASS_PHRASE:wso2carbon'\n" +
                                "Note: when IDENTITY is used, use a RSA PRIVATE KEY",
                        type = DataType.STRING,
                        optional = true,
                        defaultValue = "<Empty_String>"
                )
        },
        parameterOverloads = {
                @ParameterOverload(
                        parameterNames = {"uri"}
                ),
                @ParameterOverload(
                        parameterNames = {"uri", "is.directory"}
                ),
                @ParameterOverload(
                        parameterNames = {"uri", "is.directory", "file.system.options"}
                )
        },
        examples = {
                @Example(
                        syntax = "from CreateFileStream#file:create('/User/wso2/source/test.txt', false)",
                        description = "Creates a file in the given path with the name of 'test.txt'."
                ),
                @Example(
                        syntax = "from CreateFileStream#file:create('/User/wso2/source/', true)",
                        description = "Creates a folder in the given path with the name of 'source'."
                )
        }
)
public class FileCreateExtension extends StreamFunctionProcessor {
    private static final Logger log = Logger.getLogger(FileCreateExtension.class);
    private int inputExecutorLength;
    private String fileSystemOptions = null;

    @Override
    protected StateFactory init(AbstractDefinition inputDefinition, ExpressionExecutor[] attributeExpressionExecutors,
                                ConfigReader configReader, boolean outputExpectsExpiredEvents,
                                SiddhiQueryContext siddhiQueryContext) {
        inputExecutorLength = attributeExpressionExecutors.length;
        if (inputExecutorLength == 3 &&
                attributeExpressionExecutors[2] instanceof ConstantExpressionExecutor) {
            fileSystemOptions = ((ConstantExpressionExecutor) attributeExpressionExecutors[2]).getValue().toString();
        }
        return null;
    }

    @Override
    public List<Attribute> getReturnAttributes() {
        return new ArrayList<>();
    }

    @Override
    public ProcessingMode getProcessingMode() {
        return ProcessingMode.BATCH;
    }

    @Override
    protected Object[] process(Object[] data) {
        String fileSourcePath = (String) data[0];
        boolean isDirectory;
        if (inputExecutorLength >= 2) {
            isDirectory = (Boolean) data[1];
        } else {
            isDirectory = false;
        }
        FileObject rootFileObject = Utils.getFileObject(fileSourcePath, fileSystemOptions);
        try {
            if (isDirectory) {
                rootFileObject.createFolder();
            } else {
                rootFileObject.createFile();
            }
        } catch (FileSystemException e) {
            throw new SiddhiAppRuntimeException("Failure occurred when creating the file " + fileSourcePath, e);
        }
        return new Object[0];
    }

    @Override
    protected Object[] process(Object data) {
        return new Object[0];
    }

    @Override
    public void start() {

    }

    @Override
    public void stop() {

    }
}
```


Overlapping Code:
```
create",
namespace = "file",
description = "Create a file or a folder in the given location",
parameters = {
@Parameter(
name = "uri",
description = "Absolute file path which needs to be created.",
type = DataType.STRING,
dynamic = true
),
@Parameter(
name = "is.directory",
description = "This flag is used when creating file path is a directory",
type = DataType.BOOL,
dynamic = true,
optional = true,
defaultValue = "false"
),
@Parameter(
name = "file.system.options",
description = "The file options in key:value pairs separated by commas. \n" +
"eg:'USER_DIR_IS_ROOT:false,PASSIVE_MODE:true,AVOID_PERMISSION_CHECK:true," +
"IDENTITY:file://demo/.ssh/id_rsa,IDENTITY_PASS_PHRASE:wso2carbon'\n" +
"Note: when IDENTITY is used, use a RSA PRIVATE KEY",
type = DataType.STRING,
optional = true,
defaultValue = "<Empty_String>"
)
},
parameterOverloads = {
@ParameterOverload(
parameterNames = {"uri"}
),
@ParameterOverload(
parameterNames = {"uri", "is.directory"}
),
@ParameterOverload(
parameterNames = {"uri", "is.directory", "file.system.options"}
)
},
examples = {
@Example(
syntax = "from CreateFileStream#file:create('/User/wso2/source/test.txt', false)",
description = "Creates a file in the given path with the name of 'test.txt'."
),
@Example(
syntax = "from CreateFileStream#file:create('/User/wso2/source/', true)",
description = "Creates a folder in the given path with the name of 'source'."
)
}
)
public class FileCreateExtension extends StreamFunctionProcessor {
private static final Logger log = Logger.getL
```
<Overlap Ratio: 0.9870382372002592>

---

--- 50 --
Question ID: d6d0822b925dc65ce3da92dfc0a2fccb02823fad
Original Code:
```
public class BuildStatusTest {
	
	@Test
	public void testOrder() {
		assertEquals(6, BuildStatus.values().length);
		assertEquals(0, BuildStatus.FORK.ordinal());
		assertEquals(1, BuildStatus.LOCK.ordinal());
		assertEquals(2, BuildStatus.BUILD_MDEPS.ordinal());
		assertEquals(3, BuildStatus.ACTUALIZE_PATCHES.ordinal());
		assertEquals(4, BuildStatus.BUILD.ordinal());
		assertEquals(5, BuildStatus.DONE.ordinal());
	}
}
```


Overlapping Code:
```
lic class BuildStatusTest {

@Test
public void testOrder() {
assertEquals(6, BuildStatus.values().length);
assertEquals(0, BuildStatus.FORK.ordinal());
assertEquals(1, BuildStatus.LOCK.ordinal());
assertEquals(2, BuildStatus.BUILD_MDEPS.ordinal());
assertEquals(3, BuildStatus.ACTUALIZE_PATCHES.ordinal());
assertEquals(4, BuildStatus.BUILD.ordinal());
assertEquals(5, BuildStatus.DONE.ordinal());
}

```
<Overlap Ratio: 0.9900990099009901>

---

--- 51 --
Question ID: c3776ac551d90de905978e802ee2cd6280d479b5
Original Code:
```
public class hm {
	private class hmNode {
		Integer key;
		String value;

		public hmNode(Integer key, String value) {
			this.key = key;
			this.value = value;
			// TODO Auto-generated constructor stub
		}
	}

	public LinkedList<hmNode> buckets[];
	public int size;

	public hm() {
		size = 0;
		initBuckets(4);
		// TODO Auto-generated constructor stub
	}

	private void initBuckets(int nob) {
		buckets = new LinkedList[nob];
		for (int i = 0; i < buckets.length; i++) {
			buckets[i] = new LinkedList<>();
		}

	}

	public void put(Integer key, String value) {
		int bi = hashFunc(key);
		int di = findWithinBucket(bi, key);
		LinkedList<hmNode> bucket = buckets[bi];
		if (di == -1) {
			hmNode newnode = new hmNode(key, value);
			bucket.addLast(newnode);
			size++;

		} else {
			bucket.get(di).value = value;

		}
		double lambda = (1.0) * this.size / buckets.length;
		if (lambda > 2.0) {
			rehash();
		}
	}

	public boolean containsKey(Integer key) {
		int bi = hashFunc(key);
		int di = findWithinBucket(bi, key);
		if (di == -1) {
			return false;
		} else {
			return true;
		}

	}

	public String get(Integer key) {
		int bi = hashFunc(key);
		int di = findWithinBucket(bi, key);
		if (di == -1) {
			return null;
		} else {
			return buckets[bi].get(di).value;
		}
	}

	public String remove(Integer key) {
		int bi = hashFunc(key);
		LinkedList<hmNode> bucket = buckets[bi];
		for (int i = 0; i < bucket.size(); i++) {
			hmNode node = bucket.get(i);
			if (node.key == key) {
				String ret = node.value;
				bucket.remove(i);
				size--;
				return ret;
			}
		}

		return null;
	}

	public void rehash() {

		LinkedList<hmNode>[] oa = buckets;
		buckets = (LinkedList<hmNode>[]) new LinkedList[2 * oa.length];
		for (int i = 0; i < buckets.length; i++) {
			buckets[i] = new LinkedList<>();
		}
		this.size = 0;
		for (int i = 0; i < oa.length; i++) {

			for (int j = 0; j < oa[i].size(); j++) {
				hmNode node = oa[i].get(j);
				this.put(node.key, node.value);
			}
		}

	}

	public void display() {
		for (int i = 0; i < buckets.length; i++) {
			System.out.print("Bucket" + i + "->");
			LinkedList<hmNode> bucket = buckets[i];
			for (int j = 0; j < bucket.size(); j++) {
				System.out.print(bucket.get(j).key + " " + bucket.get(j).value + ",  ");
			}
			System.out.println();
		}
	}

	private int hashFunc(int key) {
		int hc = key;
		int bi = Math.abs(hc) % buckets.length;
		return bi;
	}

	private int findWithinBucket(int bi, int key) {
		for (int di = 0; di < buckets[bi].size(); di++) {
			hmNode node = buckets[bi].get(di);
			if (node.key.equals(key)) {
				return di;
			}
		}
		return -1;
	}

	public static void main(String[] args) {
		hm map = new hm();
		map.put(0, "i");

		map.put(1, "c");
		map.put(2, "d");
		map.put(3, "a");
		map.put(4, "b");
		map.put(5, "n");
		map.put(6, "m");
		map.put(7, "x");

		map.display();
		System.out.println();
		map.put(8, "z");
		map.put(15, "w");
		map.display();

		// TODO Auto-generated method stub

	}

}
```


Overlapping Code:
```
ss hm {
private class hmNode {
Integer key;
String value;
public hmNode(Integer key, String value) {
this.key = key;
this.value = value;
// TODO Auto-generated constructor stub
}
}
public LinkedList<hmNode> buckets[];
public int size;
public hm() {
size = 0;
initBuckets(4);
// TODO Auto-generated constructor stub
}
private void initBuckets(int nob) {
buckets = new LinkedList[nob];
for (int i = 0; i < buckets.length; i++) {
buckets[i] = new LinkedList<>();
}
}
public void put(Integer key, String value) {
int bi = hashFunc(key);
int di = findWithinBucket(bi, key);
LinkedList<hmNode> bucket = buckets[bi];
if (di == -1) {
hmNode newnode = new hmNode(key, value);
bucket.addLast(newnode);
size++;
} else {
bucket.get(di).value = value;
}
double lambda = (1.0) * this.size / buckets.length;
if (lambda > 2.0) {
rehash();
}
}
public boolean containsKey(Integer key) {
int bi = hashFunc(key);
int di = findWithinBucket(bi, key);
if (di == -1) {
return false;
} else {
return true;
}
}
public String get(Integer key) {
int bi = hashFunc(key);
int di = findWithinBucket(bi, key);
if (di == -1) {
return null;
} else {
return buckets[bi].get(di).value;
}
}
public String remove(Integer key) {
int bi = hashFunc(key);
LinkedList<hmNode> bucket = buckets[bi];
for (int i = 0; i < bucket.size(); i++) {
hmNode node = bucket.get(i);
if (node.key == key) {
String ret = node.value;
bucket.remove(i);
size--;
return ret;
}
}
return null;
}
public void rehash() {
LinkedList<hmNode>[] oa = buckets;
buckets = (LinkedList<hmNode>[]) new LinkedList[2 * oa.length];
for (int i = 0; i < buckets.length; i++) {
buckets[i] = new LinkedList<>();
}
this.size = 0;
for (int i = 0; i < oa.length; i++) {
for (int j = 0; j < oa[i].size(); j++) {
hmNode node = oa[i].get(j);
this.put(node.key, node.value);
}
}
}
public void display() {
for (int i = 0; i < buckets.length; i++) {
System.out.print("Bucket" + i + "->");
LinkedList<hmNode> bucket = buckets[i];
for (int j = 0; j < bucket.size(); j++) {
System.out.print(bucket.get(j).key + " " + bucket.get(j).value + ", ");
}
System.out.println();
}
}
private int hashFunc(int key) {
int hc = key;
int bi = Math.abs(hc) % buckets.length;
return bi;
}
private int findWithinBucket(int bi, int key) {
for (int di = 0; di < bu
```
<Overlap Ratio: 0.9951348960636887>

---

--- 52 --
Question ID: cb98a377689cc05669d077b65e83dfa7d060254b
Original Code:
```
public class InheritanceData
{
    private final InheritanceData parent;

    private final String packageName;

    private final Set<String> methodNames = PlasticInternalUtils.newSet();
    private final Map<String, Boolean> methods = PlasticInternalUtils.newMap();
    private final Set<String> interfaceNames = PlasticInternalUtils.newSet();

    public InheritanceData(String packageName)
    {
        this(null, packageName);
    }

    private InheritanceData(InheritanceData parent, String packageName)
    {
        this.parent = parent;
        this.packageName = packageName;
    }

    /**
     * Is this bundle for a transformed class, or for a base class (typically Object)?
     *
     * @return true if this bundle is for transformed class, false otherwise
     */
    public boolean isTransformed()
    {
        return parent != null;
    }

    /**
     * Returns a new MethodBundle that represents the methods of a child class
     * of this bundle. The returned bundle will always be {@linkplain #isTransformed() transformed}.
     *
     * @param packageName
     *         the package that the child class will be created in
     * @return new method bundle
     */
    public InheritanceData createChild(String packageName)
    {
        return new InheritanceData(this, packageName);
    }

    /**
     * Adds a new instance method. Only non-private methods should be added (that is, methods which might
     * be overridden in subclasses). This can later be queried to see if any base class implements the method.
     *
     * @param name
     *         name of method
     * @param desc
     *         describes the parameters and return value of the method
     * @param samePackageOnly
     *         whether the method can only be overridden in classes that are in the same package
     */
    public void addMethod(String name, String desc, boolean samePackageOnly)
    {
        methods.put(toValue(name, desc), samePackageOnly);
        methodNames.add(name);
    }


    /**
     * Returns true if this class or a transformed parent class contains an implementation of,
     * or abstract placeholder for, the method.
     *
     * @param name
     *         method name
     * @param desc
     *         method descriptor
     * @return true if this class or a base class implements the method (including abstract methods)
     */
    public boolean isImplemented(String name, String desc)
    {
        return checkForMethod(toValue(name, desc), this);
    }

    /**
     * Returns true if the method is an override of a base class method
     *
     * @param name
     *         method name
     * @param desc
     *         method descriptor
     * @return true if a base class implements the method (including abstract methods)
     */
    public boolean isOverride(String name, String desc)
    {
        return checkForMethod(toValue(name, desc), parent);
    }

    private boolean checkForMethod(String value, InheritanceData cursor)
    {

        String thisPackageName = packageName;

        while (cursor != null)
        {
            if (cursor.methods.containsKey(value))
            {
                boolean mustBeInSamePackage = cursor.methods.get(value);

                if (!mustBeInSamePackage)
                {
                    return true;
                }
                boolean isInSamePackage = thisPackageName.equals(cursor.packageName);

                if (isInSamePackage)
                {
                    return true;
                }
            }

            cursor = cursor.parent;
        }

        return false;
    }

    /**
     * Returns true if the class represented by this data, or any parent data, implements
     * the named interface.
     */
    public boolean isInterfaceImplemented(String name)
    {
        InheritanceData cursor = this;

        while (cursor != null)
        {
            if (cursor.interfaceNames.contains(name))
            {
                return true;
            }

            cursor = cursor.parent;
        }

        return false;
    }

    public void addInterface(String name)
    {
        if (!interfaceNames.contains(name))
        {
            interfaceNames.add(name);
        }
    }

    /**
     * Combines a method name and its desc (which describes parameter types and return value) to form
     * a value, which is how methods are tracked.
     */
    private static String toValue(String name, String desc)
    {
        // TAP5-2268: ignore return-type to avoid methods with the same number (and type) of parameters but different
        //            return-types which is illegal in Java.
        // desc is something like "(I)Ljava/lang/String;", which means: takes an int, returns a String. We strip
        // everything after the parameter list.
        int endOfParameterSpecIdx = desc.indexOf(')');

        return name + ":" + desc.substring(0, endOfParameterSpecIdx+1);
    }

    /**
     * Returns the names of any methods in this bundle, or from any parent bundles.
     */
    public Set<String> methodNames()
    {
        Set<String> result = PlasticInternalUtils.newSet();

        InheritanceData cursor = this;

        while (cursor != null)
        {
            result.addAll(cursor.methodNames);
            cursor = cursor.parent;
        }

        return result;
    }
}
```


Overlapping Code:
```
blic class InheritanceData
{
private final InheritanceData parent;
private final String packageName;
private final Set<String> methodNames = PlasticInternalUtils.newSet();
private final Map<String, Boolean> methods = PlasticInternalUtils.newMap();
private final Set<String> interfaceNames = PlasticInternalUtils.newSet();
public InheritanceData(String packageName)
{
this(null, packageName);
}
private InheritanceData(InheritanceData parent, String packageName)
{
this.parent = parent;
this.packageName = packageName;
}
/**
* Is this bundle for a transformed class, or for a base class (typically Object)?
*
* @return true if this bundle is for transformed class, false otherwise
*/
public boolean isTransformed()
{
return parent != null;
}
/**
* Returns a new MethodBundle that represents the methods of a child class
* of this bundle. The returned bundle will always be {@linkplain #isTransformed() transformed}.
*
* @param packageName
* the package that the child class will be created in
* @return new method bundle
*/
public InheritanceData createChild(String packageName)
{
return new InheritanceData(this, packageName);
}
/**
* Adds a new instance method. Only non-private methods should be added (that is, methods which might
* be overridden in subclasses). This can later be queried to see if any base class implements the method.
*
* @param name
* name of method
* @param desc
* describes the parameters and return value of the method
* @param samePackageOnly
* whether the method can only be overridden in classes that are in the same package
*/
public void addMethod(String name, String desc, boolean samePackageOnly)
{
methods.put(toValue(name, desc), samePackageOnly);
methodNames.add(name);
}
/**
* Returns true if this class or a transformed parent class contains an implementation of,
* or abstract placeholder for, the method.
*
* @param name
* method name
* @param desc
* method descriptor
* @return true if this class or a base class implements the method (including abstract methods)
*/
public boolean isImplemented(String name, String desc)
{
return checkForMethod(toValue(name, desc)
```
<Overlap Ratio: 0.9943342776203966>

---

--- 53 --
Question ID: 4f25c79d3ce4213c9407f9d977856de673bcef22
Original Code:
```
@Service
public class FlowManagerService {
    protected final Logger logger = LoggerFactory.getLogger(this.getClass());

    public static final String FLOW_FILE_EXTENSION = ".flow.json";

    @Autowired
    private FlowManager flowManager;

    @Autowired
    private FlowRunnerImpl flowRunner;

    @Autowired
    private StepDefinitionManagerService stepDefinitionManagerService;

    @Autowired
    HubConfigImpl hubConfig;

    @Autowired
    private FileSystemWatcherService watcherService;

    @Autowired
    private DataHubService dataHubService;

    @Autowired
    private Scaffolding scaffolding;

    @Autowired
    private AsyncFlowService asyncFlowService;

    private CustomStepValidator customStepValidator = null;

    public List<FlowStepModel> getFlows() {
        return asyncFlowService.getFlows(true);
    }

    public FlowStepModel createFlow(String flowJson, boolean checkExists) throws IOException {
        JSONObject jsonObject;
        try {
            jsonObject = new JSONObject(flowJson);

            JSONUtils.trimText(jsonObject, "separator");
        }
        catch (IOException e) {
            throw new DataHubException("Unable to parse flow json string : " + e.getMessage());
        }

        if (!jsonObject.isExist("name") || StringUtils.isEmpty(jsonObject.getString("name"))) {
            throw new BadRequestException("Flow Name not provided. Flow Name is required.");
        }

        String flowName = jsonObject.getString("name");
        Flow flow = null;
        if (checkExists) {
            if (flowManager.isFlowExisted(flowName)) {
                throw new DataHubException("A Flow with " + flowName + " already exists.");
            }
            flow = new FlowImpl();
            flow.setName(flowName);
        }
        else {
            //for PUT updating
            flow = flowManager.getFlow(flowName);
            if (flow == null) {
                throw new DataHubException("Changing flow name not supported.");
            }
        }
        FlowStepModel.createFlowSteps(flow, jsonObject);
        flowManager.saveFlow(flow);

        FlowStepModel fsm = FlowStepModel.transformFromFlow(flow);
        return fsm;
    }

    public FlowStepModel getFlow(String flowName, boolean fromRunFlow) {
        Flow flow = flowManager.getFlow(flowName);
        if (flow == null) {
            throw new NotFoundException(flowName + " not found!");
        }
        FlowStepModel fsm = asyncFlowService.getFlowStepModel(flow, fromRunFlow, null);
        return fsm;
    }

    public List<String> getFlowNames() {
        return flowManager.getFlowNames();
    }

    public JsonNode validateStep(String flowName, String stepId){
        Flow flow = flowManager.getFlow(flowName);
        if (flow == null) {
            throw new NotFoundException("Could not find a flow with a name of " + flowName);
        }
        String stepNum = getStepKeyInStepMap(flow, stepId);
        return getCustomStepValidator().validate(flowName, stepNum);
    }

    public void deleteFlow(String flowName) {
        flowManager.deleteFlow(flowName);
        dataHubService.deleteDocument("/flows/" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.STAGING);
        dataHubService.deleteDocument("/flows/" + flowName + FLOW_FILE_EXTENSION, DatabaseKind.FINAL);
    }

    public List<StepModel> getSteps(String flowName) {
        Flow flow = flowManager.getFlow(flowName);
        Map<String, Step> stepMap = flow.getSteps();

        List<StepModel> stepModelList = new ArrayList<>();
        for (String key : stepMap.keySet()) {
            Step step = stepMap.get(key);
            StepModel stepModel = transformStepToWebModel(step);
            stepModelList.add(stepModel);
        }

        return stepModelList;
    }

    public StepModel getStep(String flowName, String stepId) {
        Flow flow = flowManager.getFlow(flowName);
        if (flow == null) {
            throw new NotFoundException(flowName + " not found.");
        }

        Step step = flow.getStep(getStepKeyInStepMap(flow, stepId));
        if (step == null) {
            throw new NotFoundException(stepId + " not found.");
        }

        return transformStepToWebModel(step);
    }

    public StepModel createStep(String flowName, Integer stepOrder, String stepId, String stringStep) {
        StepModel stepModel;
        JsonNode stepJson;
        Flow flow = flowManager.getFlow(flowName);
        Step existingStep = flow.getStep(getStepKeyInStepMap(flow, stepId));

        if (existingStep == null && !StringUtils.isEmpty(stepId)) {
            throw new NotFoundException("Step " + stepId + " Not Found");
        }

        try {
            stepJson = JSONObject.readInput(stringStep);

            JSONUtils.trimText(stepJson, "separator");

            stepModel = StepModel.fromJson(stepJson);
        }
        catch (IOException e) {
            throw new BadRequestException("Error parsing JSON");
        }

        if (stepModel == null) {
            throw new BadRequestException();
        }

        Step step = StepModel.transformToCoreStepModel(stepModel, stepJson);

        if (step.getStepDefinitionType() == null) {
            throw new BadRequestException("Invalid Step Definition Type");
        }

        if (step.getStepDefinitionName() == null) {
            throw new BadRequestException("Invalid Step Definition Name");
        }

        if (stepId != null) {
            if (!stepId.equals(step.getName() + "-" + step.getStepDefinitionType())) {
                throw new BadRequestException("Changing step name or step type not supported.");
            }
        }
        if(!EnumUtils.isValidEnumIgnoreCase(StepDefinition.StepDefinitionType.class, step.getStepDefinitionType().toString())) {
            throw new BadRequestException("Invalid Step Type");
        }

        step = upsertStepDefinition(stepModel, step);

        Map<String, Step> currSteps = flow.getSteps();
        if (stepId != null) {
            String key = getStepKeyInStepMap(flow, stepId);
            if (StringUtils.isNotEmpty(key)) {
                currSteps.put(key, step);
            }
            flow.setSteps(currSteps);
        }
        else {
            if (stepOrder == null || stepOrder > currSteps.size()) {
                currSteps.put(String.valueOf(currSteps.size() + 1), step);
            }
            else {
                Map<String, Step> newSteps = new LinkedHashMap<>();
                final Integer[] count = {1};
                Step finalStep = step;
                currSteps.values().forEach(s -> {
                    if (count[0].equals(stepOrder)) {
                        newSteps.put(String.valueOf(count[0]++), finalStep);
                    }
                    newSteps.put(String.valueOf(count[0]), s);
                    ++count[0];
                });
                flow.setSteps(newSteps);
            }
        }

        if (existingStep != null && existingStep.isEqual(step)) {
            return transformStepToWebModel(existingStep);
        }

        flowManager.saveFlow(flow);
        return transformStepToWebModel(step);
    }

    protected Step mergeDefaultStepDefinitionIntoStep(StepModel stepModel, Step step) {
        String stepType = step.getStepDefinitionType().toString().toLowerCase();
        StepDefinition defaultStepDefinition = getDefaultStepDefinitionFromResources("hub-internal-artifacts/step-definitions/" + stepType + "/marklogic/"+ step.getStepDefinitionName() +".step.json", step.getStepDefinitionType());
        Step defaultStep = defaultStepDefinition.transformToStep(step.getName(), defaultStepDefinition, new Step());
        return StepModel.mergeFields(stepModel, defaultStep, step);
    }

    protected Step upsertStepDefinition(StepModel stepModel, Step step) {
        if (stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType()) != null) {
            String stepType = step.getStepDefinitionType().toString().toLowerCase();
            if(step.getStepDefinitionName().equalsIgnoreCase("default-" + stepType) || "entity-services-mapping".equalsIgnoreCase(step.getStepDefinitionName())) {
                step = mergeDefaultStepDefinitionIntoStep(stepModel, step);
            }
            else {
                StepDefinition oldStepDefinition = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());
                StepDefinition stepDefinition = transformFromStep(oldStepDefinition, step, stepModel);
                stepDefinitionManagerService.saveStepDefinition(stepDefinition);
            }
        }
        else {
            String stepDefName = step.getStepDefinitionName();
            StepDefinition.StepDefinitionType stepDefType = step.getStepDefinitionType();
            String modulePath = "/custom-modules/" + stepDefType.toString().toLowerCase() + "/" + stepDefName + "/main.sjs";

            StepDefinition stepDefinition = StepDefinition.create(stepDefName, stepDefType);
            stepDefinition = transformFromStep(stepDefinition, step, stepModel);

            scaffolding.createCustomModule(stepDefName, stepDefType.toString());
            stepDefinition.setModulePath(modulePath);
            stepDefinitionManagerService.createStepDefinition(stepDefinition);
        }
        return step;
    }

    public void deleteStep(String flowName, String stepId) {
        Flow flow = flowManager.getFlow(flowName);
        String key = getStepKeyInStepMap(flow, stepId);

        if (StringUtils.isEmpty(key)) {
            throw new BadRequestException("Invalid Step Id");
        }

        try {
            flowManager.deleteStep(flow, key);
        }
        catch (DataHubProjectException e) {
            throw new NotFoundException(e.getMessage());
        }
    }

    /**
     * This is synchronized because Coverity is reporting that flowManagerService is being modified without proper
     * synchronization when it's invoked by FlowController.
     *
     * @param flowName
     * @param steps
     * @return
     */
    public synchronized FlowStepModel runFlow(String flowName, List<String> steps) {
        if (steps == null || steps.size() == 0) {
            flowRunner.runFlow(flowName);
        }
        else {
            Flow flow = flowManager.getFlow(flowName);
            List<String> restrictedSteps = new ArrayList<>();
            steps.forEach((step) -> restrictedSteps.add(this.getStepKeyInStepMap(flow, step)));
            flowRunner.runFlow(flowName, restrictedSteps);
        }
        return getFlow(flowName, true);
    }

    public FlowStepModel stop(String flowName) {
        List<String> jobIds = flowRunner.getQueuedJobIdsFromFlow(flowName);
        Iterator<String> itr = jobIds.iterator();
        if (!itr.hasNext()) {
            throw new BadRequestException("Flow not running.");
        }
        while (itr.hasNext()) {
            flowRunner.stopJob(itr.next());
        }
        return getFlow(flowName, false);
    }

    /*
    The core and web models for steps are different, webModel has 'modulePath' which provides the uri of the main.sjs
    whereas it is not present in the core step model. Hence the following 2 transform methods additionally are meant to
    set modulePaths in 'StepModel' and 'StepDefinition' .
     */
    private StepModel transformStepToWebModel(Step step) {
        StepModel stepModel = StepModel.transformToWebStepModel(step);
        StepDefinition stepDef = stepDefinitionManagerService.getStepDefinition(step.getStepDefinitionName(), step.getStepDefinitionType());
        stepModel.setModulePath(stepDef.getModulePath());
        return stepModel;
    }

    private StepDefinition transformFromStep(StepDefinition stepDefinition, Step step, StepModel stepModel) {
        StepDefinition newStepDefinition = stepDefinition.transformFromStep(stepDefinition, step);
        newStepDefinition.setModulePath(stepModel.getModulePath());
        return newStepDefinition;
    }

    private String getStepKeyInStepMap(Flow flow, String stepId) {
        if (flow == null || StringUtils.isEmpty(stepId)) {
            return null;
        }

        // Split on the last occurrence of "-"
        String[] stepStr = stepId.split("-(?!.*-)");

        if (stepStr.length == 2) {
            String name = stepStr[0];
            String type = stepStr[1];
            String[] key = new String[1];

            flow.getSteps().forEach((k, v) -> {
                if (name.equals(v.getName()) && type.equalsIgnoreCase(v.getStepDefinitionType().toString())) {
                    key[0] = k;
                }
            });

            return key[0];
        }

        return null;
    }

    private StepDefinition getDefaultStepDefinitionFromResources(String resourcePath, StepDefinition.StepDefinitionType stepDefinitionType) {
        try (InputStream in = FlowManagerService.class.getClassLoader().getResourceAsStream(resourcePath)) {
            JSONObject jsonObject = new JSONObject(IOUtils.toString(in));
            StepDefinition defaultStep = StepDefinition.create(stepDefinitionType.toString(), stepDefinitionType);
            defaultStep.deserialize(jsonObject.jsonNode());
            return defaultStep;
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private synchronized CustomStepValidator getCustomStepValidator() {
        if (customStepValidator == null) {
            customStepValidator = new CustomStepValidator(hubConfig.newStagingClient());
        }
        return customStepValidator;
    }
}
```


Overlapping Code:
```
erService {
protected final Logger logger = LoggerFactory.getLogger(this.getClass());
public static final String FLOW_FILE_EXTENSION = ".flow.json";
@Autowired
private FlowManager flowManager;
@Autowired
private FlowRunnerImpl flowRunner;
@Autowired
private StepDefinitionManagerService stepDefinitionManagerService;
@Autowired
HubConfigImpl hubConfig;
@Autowired
private FileSystemWatcherService watcherService;
@Autowired
private DataHubService dataHubService;
@Autowired
private Scaffolding scaffolding;
@Autowired
private AsyncFlowService asyncFlowService;
private CustomStepValidator customStepValidator = null;
public List<FlowStepModel> getFlows() {
return asyncFlowService.getFlows(true);
}
public FlowStepModel createFlow(String flowJson, boolean checkExists) throws IOException {
JSONObject jsonObject;
try {
jsonObject = new JSONObject(flowJson);
JSONUtils.trimText(jsonObject, "separator");
}
catch (IOException e) {
throw new DataHubException("Unable to parse flow json string : " + e.getMessage());
}
if (!jsonObject.isExist("name") || StringUtils.isEmpty(jsonObject.getString("name"))) {
throw new BadRequestException("Flow Name not provided. Flow Name is required.");
}
String flowName = jsonObject.getString("name");
Flow flow = null;
if (checkExists) {
if (flowManager.isFlowExisted(flowName)) {
throw new DataHubException("A Flow with " + flowName + " already exists.");
}
flow = new FlowImpl();
flow.setName(flowName);
}
else {
//for PUT updating
flow = flowManager.getFlow(flowName);
if (flow == null) {
throw new DataHubException("Changing flow name not supported.");
}
}
FlowStepModel.createFlowSteps(flow, jsonObject);
flowManager.saveFlow(flow);
FlowStepModel fsm = FlowStepModel.transformFromFlow(flow);
return fsm;
}
public FlowStepModel getFlow(String flowName, boolean fromRunFlow) {
Flow flow = flowManager.getFlow(flowName);
if (flow == null) {
throw new NotFoundException(flowName + " not found!");
}
FlowStepModel fsm = asyncFlo
```
<Overlap Ratio: 0.9698318496538081>

---

--- 54 --
Question ID: 10c93aeb12da1035e98a942007e4deb03fbb9355
Original Code:
```
class GfG
{
    
    static final int INT_BITS = 32; 
     public static int maxSubarrayXOR(int set[], int n)
    {
                    
    int index = 0; 
   
    for (int i = INT_BITS - 1; i >= 0; i--)  
    { 
    
    int maxInd = index; 
    int maxEle = Integer.MIN_VALUE; 
    for (int j = index; j < n; j++) { 
       
        if ((set[j] & (1 << i)) != 0 && set[j] > maxEle) 
        { 
        maxEle = set[j]; 
        maxInd = j; 
        } 
    } 
    
    if (maxEle == -2147483648) 
        continue; 
  
    int temp = set[index]; 
    set[index] = set[maxInd]; 
    set[maxInd] = temp; 
    maxInd = index; 
    for (int j = 0; j < n; j++) { 
      
        if (j != maxInd && (set[j] & (1 << i)) != 0) 
        set[j] = set[j] ^ set[maxInd]; 
    } 
    index++; 
    }
    
    
    int res = 0; 
    for (int i = 0; i < n; i++) 
    {res ^= set[i]; }
    return res; 
}
    
}
```


Overlapping Code:
```
atic final int INT_BITS = 32; 
public static int maxSubarrayXOR(int set[], int n)
{

int index = 0; 

for (int i = INT_BITS - 1; i >= 0; i--) 
{ 

int maxInd = index; 
int maxEle = Integer.MIN_VALUE; 
for (int j = index; j < n; j++) { 

if ((set[j] & (1 << i)) != 0 && set[j] > maxEle) 
{ 
maxEle = set[j]; 
maxInd = j; 
} 
} 

if (maxEle == -2147483648) 
continue; 

int temp = set[index]; 
set[index] = set[maxInd]; 
set[maxInd] = temp; 
maxInd = index; 
for (int j = 0; j < n; j++) { 

if (j != maxInd && (set[j] & (1 << i)) != 0) 
set[j] = set[j] ^ set[maxInd]; 
} 
index++; 
}


int res = 0; 
for (int i = 0; i < n; i++) 
{res ^= set[i]; }
retur
```
<Overlap Ratio: 0.9601181683899557>

---

--- 55 --
Question ID: 36869995fdb5cf8a717814fa617956da8a7887a4
Original Code:
```
@WebServlet("/bf_servlet")
public class BellmanFordServlet extends HttpServlet {
	private static final long serialVersionUID = 102831973239L;

    /**
     * Default constructor. 
     */
    public BellmanFordServlet() {
        // TODO Auto-generated constructor stub
    }

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		int source= Integer.parseInt(request.getParameter("source"));
		Integer[] destinations = {1023, 1013, 1028};
		File file = new File(request.getServletContext().getRealPath("/data.js"));
		HashMap<Integer, Node> nodes = importData(file);
		long startTime = System.nanoTime();
		BellManFordShortestPath d = new BellManFordShortestPath();
		d.setNodeList(nodes);
		for(int index=0;index<destinations.length;index++) {
			d.computeShortestPathsTo(index,nodes.get(destinations[index]));
		}
		long estimatedTime = System.nanoTime() - startTime;
		ArrayList<ArrayList<Integer>> pathList = new ArrayList<>();
		for(int i=0; i<destinations.length;i++) {
			ArrayList<Integer> tempList = new ArrayList<>();
			tempList = d.getShortestPathFrom(i,nodes.get(source));
			pathList.add(tempList);
		}
		request.setAttribute("paths", pathList);
		request.setAttribute("elapsedTime", estimatedTime);
		RequestDispatcher view = request.getRequestDispatcher("index.jsp");
		view.forward(request, response);			
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// TODO Auto-generated method stub
		doGet(request, response);
	}
	
	protected HashMap<Integer,Node> importData(File file) {
		String text = "";
		try {		
			text = new String(Files.readAllBytes(Paths.get(file.getPath())));
		} catch (IOException e) {
			e.printStackTrace();
		}
		StringBuilder sb = new StringBuilder(text);
		sb.deleteCharAt(text.length()-1);
		for(int i=7; i>-1;i--) {
			sb.deleteCharAt(i);
		}
		String str = sb.toString();
		str = str.replace(" \\", "");
		Gson gson = new Gson();  
		Node[] arr = gson.fromJson(str, Node[].class);
		HashMap<Integer,Node> map = new HashMap<Integer,Node>();
		for(int i=0; i<arr.length; i++) {
			map.put(arr[i].getID(), arr[i]);
		}
		return map;
	}

}
```


Overlapping Code:
```
("/bf_servlet")
public class BellmanFordServlet extends HttpServlet {
private static final long serialVersionUID = 102831973239L;
/**
* Default constructor. 
*/
public BellmanFordServlet() {
// TODO Auto-generated constructor stub
}
/**
* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
*/
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
int source= Integer.parseInt(request.getParameter("source"));
Integer[] destinations = {1023, 1013, 1028};
File file = new File(request.getServletContext().getRealPath("/data.js"));
HashMap<Integer, Node> nodes = importData(file);
long startTime = System.nanoTime();
BellManFordShortestPath d = new BellManFordShortestPath();
d.setNodeList(nodes);
for(int index=0;index<destinations.length;index++) {
d.computeShortestPathsTo(index,nodes.get(destinations[index]));
}
long estimatedTime = System.nanoTime() - startTime;
ArrayList<ArrayList<Integer>> pathList = new ArrayList<>();
for(int i=0; i<destinations.length;i++) {
ArrayList<Integer> tempList = new ArrayList<>();
tempList = d.getShortestPathFrom(i,nodes.get(source));
pathList.add(tempList);
}
request.setAttribute("paths", pathList);
request.setAttribute("elapsedTime", estimatedTime);
RequestDispatcher view = request.getRequestDispatcher("index.jsp");
view.forward(request, response); 
}
/**
* @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
*/
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
// TODO Auto-generated method stub
doGet(request, response);
}

protected HashMap<Integer,Node> importData(File file) {
String text = "";
try { 
text = new String(Files.readAllBytes(Paths.get(file.getPath())));
} catch (IOException e) {
e.printStackTrace();
}
StringBuilder sb = new StringBuilder(text);
sb.deleteCharAt(text.length()-1);
for(int i=7; i>-1;i--) {
sb.deleteCharAt(i);
}
String str = sb.toString();
str = str.replace(" \\", "");
Gson gson = new Gson(); 
Node[] arr = gson.fromJson(str, Node[].class);
HashMap<Integer,Node> map = new HashMap<Integer,Node>();
for(int i=0; i<arr.length; i++) {
map.put(arr[i].getID(), arr[i]);
}
return map
```
<Overlap Ratio: 0.9929390997352162>

---

--- 56 --
Question ID: c43bb3a25e364299bc97cb27f2d0061dd84356ae
Original Code:
```
@MultipartConfig
@WebServlet(name = "UserProfileServlet")
public class UserProfileServlet extends HttpServlet {

    private UserDAO userDAO;

    @Override
    public void init() throws ServletException {
        DAOFactory daoFactory = (DAOFactory) super.getServletContext().getAttribute("daoFactory");
        if (daoFactory == null) {
            throw new ServletException("Impossible to get dao factory!");
        }
        try {
            userDAO = daoFactory.getDAO(UserDAO.class);
        } catch (DAOFactoryException ex) {
            throw new ServletException("Impossible to get user dao from dao factory!", ex);
        }
    }

    // <editor-fold defaultstate="collapsed" desc="HttpServlet methods. Click on the + sign on the left to edit the code.">

    /**
     * Handles the HTTP <code>GET</code> method.
     *
     * @param request  servlet request
     * @param response servlet response
     * @throws ServletException if a servlet-specific error occurs
     * @throws IOException      if an I/O error occurs
     */
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        if (!response.isCommitted())
            request.getRequestDispatcher("/WEB-INF/views/user.jsp").forward(request, response);
    }

    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        HttpSession session = request.getSession(false);
        User user = (User) session.getAttribute("user");
        if (user == null) {
            response.sendError(500, "There was an error processing the request");
            return;
        }
        String message = null;
        boolean hasError = false;
        boolean modified = false;
        String avatarsFolder = getServletContext().getInitParameter("avatarsFolder");
        if (avatarsFolder == null) {
            response.sendError(500, "Avatars folder not configured");
            return;
        }

        String rootPath = System.getProperty("catalina.home");
        String firstName = request.getParameter("firstName");
        String lastName = request.getParameter("lastName");


        if (firstName == null || lastName == null || firstName.equals("") || lastName.equals("")) {
            hasError = true;
            message = "All fields are mandatory and must be filled!";
        } else {
            Part filePart = request.getPart("avatar");
            if ((filePart != null) && (filePart.getSize() > 0)) {
                String fileName = UtilityHelper.getFilename(filePart);
                fileName = UtilityHelper.renameImage(fileName, "Profile_" + user.getId());
                String userAvatarUploadDir = rootPath + File.separator + avatarsFolder + "Users";
                try {
                    user.setAvatar(UtilityHelper.uploadFileToDirectory(userAvatarUploadDir, fileName, filePart));
                } catch (IOException ex) {
                    response.sendError(500, ex.getMessage());
                }
                modified = true;
            }

            if (!firstName.equals(user.getFirstName())) {
                modified = true;
                user.setFirstName(firstName);
            }
            if (!lastName.equals(user.getLastName())) {
                modified = true;
                user.setLastName(lastName);
            }
        }

        if (hasError) {
            request.setAttribute("errorMessage", "errors");
            getServletContext().getRequestDispatcher("/WEB-INF/views/home.jsp").forward(request, response);
        } else {
            try {
                if (modified) {
                    user = userDAO.update(user);
                    message = "Profile was successfully updated";
                    session.setAttribute("successMessage", message);
                }
                response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + "/user/profile"));
            } catch (DAOException ex) {
                response.sendError(500, ex.toString());
            }
        }
    }

}
```


Overlapping Code:
```
UserProfileServlet")
public class UserProfileServlet extends HttpServlet {
private UserDAO userDAO;
@Override
public void init() throws ServletException {
DAOFactory daoFactory = (DAOFactory) super.getServletContext().getAttribute("daoFactory");
if (daoFactory == null) {
throw new ServletException("Impossible to get dao factory!");
}
try {
userDAO = daoFactory.getDAO(UserDAO.class);
} catch (DAOFactoryException ex) {
throw new ServletException("Impossible to get user dao from dao factory!", ex);
}
}
// <editor-fold defaultstate="collapsed" desc="HttpServlet methods. Click on the + sign on the left to edit the code.">
/**
* Handles the HTTP <code>GET</code> method.
*
* @param request servlet request
* @param response servlet response
* @throws ServletException if a servlet-specific error occurs
* @throws IOException if an I/O error occurs
*/
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
if (!response.isCommitted())
request.getRequestDispatcher("/WEB-INF/views/user.jsp").forward(request, response);
}
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
HttpSession session = request.getSession(false);
User user = (User) session.getAttribute("user");
if (user == null) {
response.sendError(500, "There was an error processing the request");
return;
}
String message = null;
boolean hasError = false;
boolean modified = false;
String avatarsFolder = getServletContext().getInitParameter("avatarsFolder");
if (avatarsFolder == null) {
response.sendError(500, "Avatars folder not configured");
return;
}
String rootPath = System.getProperty("catalina.home");
String firstName = request.getParameter("firstName");
String lastName = request.getParameter("lastName");
if (firstName == null || lastName == null || firstName.equals("") || lastName.equals("")) {
hasError = true;
message = "All fields are mandatory and must be filled!";
} else {

```
<Overlap Ratio: 0.962000962000962>

---

--- 57 --
Question ID: cae993c59e60d1a09d4092dd134bbdb191913f4b
Original Code:
```
@Layout("/browse/*")
public class BrowsePage extends AbstractPage<BrowsePage> {

    /**
     * Message block displayed when no results are present
     * @return element
     */
    public SelenideElement noContentInfo() {
        return $(".apiman-no-entities-description");
    }

    /**
     * Container for result elements
     * @return element
     */
    public SelenideElement resultContainer() {
        return $(".browse-items");
    }

    /**
     * Collection of results
     * @return elements collection
     */
    public ElementsCollection resultEntries() {
        return resultContainer().findAll(".item");
    }

    /**
     * Link to specific result
     * @return element
     */
    public SelenideElement resultLink(String title) {
        return resultContainer().find(linkText(title));
    }

    // Search

    /**
     * Search input
     * @return element
     */
    public SelenideElement searchInput() {
        return $("#apiman-search");
    }

    /**
     * Search button
     * @return element
     */
    public SelenideElement searchButton() {
        return $("#search-btn");
    }

    /**
     * Performs search operation
     * @param query value
     * @param clazz this page class object
     * @return this page object
     */
    public <ThisPageObject> ThisPageObject search(String query, Class<ThisPageObject> clazz) {
        searchInput().val(query);
        searchButton().click();
        return clazz.cast(this);
    }

    /**
     * Performs search operation
     * @param query value
     * @return this page object
     */
    public BrowsePage search(String query) {
        return search(query, BrowsePage.class);
    }
}
```


Overlapping Code:
```
class BrowsePage extends AbstractPage<BrowsePage> {
/**
* Message block displayed when no results are present
* @return element
*/
public SelenideElement noContentInfo() {
return $(".apiman-no-entities-description");
}
/**
* Container for result elements
* @return element
*/
public SelenideElement resultContainer() {
return $(".browse-items");
}
/**
* Collection of results
* @return elements collection
*/
public ElementsCollection resultEntries() {
return resultContainer().findAll(".item");
}
/**
* Link to specific result
* @return element
*/
public SelenideElement resultLink(String title) {
return resultContainer().find(linkText(title));
}
// Search
/**
* Search input
* @return element
*/
public SelenideElement searchInput() {
return $("#apiman-search");
}
/**
* Search button
* @return element
*/
public SelenideElement searchButton() {
return $("#search-btn");
}
/**
* Performs search operation
* @param query value
* @param clazz this page class object
* @return this page object
*/
public <ThisPageObject> ThisPageObject search(String query, Class<ThisPageObject> clazz) {
searchInput().val(query);
searchButton().click();
return clazz.cast(this);
}
/**
* Performs search operation
* @param query value
* @return this page object
*/
public BrowsePage search(String query) {
return sear
```
<Overlap Ratio: 0.9558823529411765>

---

--- 58 --
Question ID: 1f6b8556310164102fe5227f371459cb58cd68d9
Original Code:
```
@WebServlet("/SelezionaBar")
public class SelezioneBar extends HttpServlet {
	private static final long serialVersionUID = 1L;


	/**
	 * @see HttpServlet#HttpServlet()
	 */
	public SelezioneBar() {
		super();
	}

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse
	 *      response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
			HttpSession ses = request.getSession();
			int ido = Integer.parseInt(request.getParameter("ordine"));
			int idbar = Integer.parseInt(request.getParameter("bar"));
			Ordini o = new Ordini();
			Ordine or = o.bar(ido, idbar);
			if(or==null) {
				
			}else {
				ses.setAttribute("IDb", request.getAttribute("ID"));
				OrdineJson ord = new OrdineJson();
				ord.setId(String.valueOf(ido));
				ObjectMapper om = new ObjectMapper();
				response.setContentType("application/json");
				response.getWriter().append(om.writeValueAsString(ord));				
				}

	
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
	 *      response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		doGet(request, response);
	}
}
```


Overlapping Code:
```
r")
public class SelezioneBar extends HttpServlet {
private static final long serialVersionUID = 1L;
/**
* @see HttpServlet#HttpServlet()
*/
public SelezioneBar() {
super();
}
/**
* @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse
* response)
*/
protected void doGet(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
HttpSession ses = request.getSession();
int ido = Integer.parseInt(request.getParameter("ordine"));
int idbar = Integer.parseInt(request.getParameter("bar"));
Ordini o = new Ordini();
Ordine or = o.bar(ido, idbar);
if(or==null) {

}else {
ses.setAttribute("IDb", request.getAttribute("ID"));
OrdineJson ord = new OrdineJson();
ord.setId(String.valueOf(ido));
ObjectMapper om = new ObjectMapper();
response.setContentType("application/json");
response.getWriter().append(om.writeValueAsString(ord)); 
}

}
/**
* @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
* response)
*/
protected void doPost(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException {
doGet(request, response);
}
}
```
<Overlap Ratio: 0.9783923941227312>

---

--- 59 --
Question ID: 4c7b003c483b4ab8973c1a26e7e72c8d8d72c0ee
Original Code:
```
@Endpoint(id = "oauthTokens", enableByDefault = false)
@RequiredArgsConstructor
@Slf4j
public class OAuth20TokenManagementEndpoint {
    /**
     * The Ticket registry.
     */
    private final TicketRegistry ticketRegistry;

    /**
     * Gets access tokens.
     *
     * @return the access tokens
     */
    @ReadOperation
    public Collection<Ticket> getTokens() {
        return ticketRegistry.getTickets(ticket -> (ticket instanceof AccessToken || ticket instanceof RefreshToken) && !ticket.isExpired())
            .sorted(Comparator.comparing(Ticket::getId))
            .collect(Collectors.toList());
    }


    /**
     * Gets access token.
     *
     * @param ticketId the ticket id
     * @return the access token
     */
    @ReadOperation
    public Ticket getToken(@Selector final String ticketId) {
        var ticket = (Ticket) ticketRegistry.getTicket(ticketId, AccessToken.class);
        if (ticket == null) {
            ticket = ticketRegistry.getTicket(ticketId, RefreshToken.class);
        }
        if (ticket == null) {
            LOGGER.debug("Ticket [{}] is not found", ticketId);
            return null;
        }
        if (ticket.isExpired()) {
            LOGGER.debug("Ticket [{}] is has expired", ticketId);
            return null;
        }
        return ticket;
    }

    /**
     * Delete access token.
     *
     * @param ticketId the ticket id
     */
    @DeleteOperation
    public void deleteToken(@Selector final String ticketId) {
        val ticket = getToken(ticketId);
        if (ticket != null) {
            ticketRegistry.deleteTicket(ticketId);
        }
    }
}
```


Overlapping Code:
```
uthTokens", enableByDefault = false)
@RequiredArgsConstructor
@Slf4j
public class OAuth20TokenManagementEndpoint {
/**
* The Ticket registry.
*/
private final TicketRegistry ticketRegistry;
/**
* Gets access tokens.
*
* @return the access tokens
*/
@ReadOperation
public Collection<Ticket> getTokens() {
return ticketRegistry.getTickets(ticket -> (ticket instanceof AccessToken || ticket instanceof RefreshToken) && !ticket.isExpired())
.sorted(Comparator.comparing(Ticket::getId))
.collect(Collectors.toList());
}
/**
* Gets access token.
*
* @param ticketId the ticket id
* @return the access token
*/
@ReadOperation
public Ticket getToken(@Selector final String ticketId) {
var ticket = (Ticket) ticketRegistry.getTicket(ticketId, AccessToken.class);
if (ticket == null) {
ticket = ticketRegistry.getTicket(ticketId, RefreshToken.class);
}
if (ticket == null) {
LOGGER.debug("Ticket [{}] is not found", ticketId);
return null;
}
if (ticket.isExpired()) {
LOGGER.debug("Ticket [{}] is has expired", ticketId);
return null;
}
return ticket;
}
/**
* Delete access token.
*
* @param ticketId the ticket id
*/
@DeleteOperation
public void deleteToken(@Selector final String ticketId) {
val ticket = getToken(ticketId);
if (ticket != null) {
ticketRegis
```
<Overlap Ratio: 0.9607993850883936>

---

--- 60 --
Question ID: 178ce37da3dd338c29beea3fce8e185ac974c797
Original Code:
```
public class ArrayRotation {
	
	public static void rotate(int[] arr, int d, int n) {		
		if(d < 0) {
			System.out.println("Number of rotations cannot be less than 0");
		}
		
		int i,j,k,temp;
		for(i = 0; i<gcd(d,n); i++) {
			temp = arr[i];
			j = i;
			while(true) {
				k = j + d;
				while(k >= n)
					k = k - n;
				if(k == i)
					break;
				arr[j] = arr[k];
				j = k;
			}
			arr[j] = temp;
		}
	}
	
	public static int gcd(int i, int j) {
		if (j == 0)
			return i;
		else
			return gcd(j, i%j);
	}
	
	public static void printArray(int[] arr) {
		for(int i = 0; i<arr.length; i++) {
			System.out.print(arr[i]+ " ");
		}			
	}
	
	public static void leftRotatebyOne(int arr[], int n)
	{
	   int temp = arr[0];
	   int i;
	   for(i = 0; i < n-1; i++)
	   arr[i] = arr[i+1];
	    
	   arr[i] = temp;
	}
	 
	/*Function to left rotate arr[] of size n by d*/
	public static void leftRotate(int arr[], int d, int n)
	{
	    for (int i = 0; i < d; i++)
	    leftRotatebyOne(arr, n);
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] arr = {1,2,3,4,5,6,7,8,9};
		rotate(arr, 201, 9);
		printArray(arr);
		System.out.print("\n=================\n");
		leftRotate(arr, 2, 9);
		printArray(arr);
	}

}
```


Overlapping Code:
```
lic static void rotate(int[] arr, int d, int n) { 
if(d < 0) {
System.out.println("Number of rotations cannot be less than 0");
}

int i,j,k,temp;
for(i = 0; i<gcd(d,n); i++) {
temp = arr[i];
j = i;
while(true) {
k = j + d;
while(k >= n)
k = k - n;
if(k == i)
break;
arr[j] = arr[k];
j = k;
}
arr[j] = temp;
}
}

public static int gcd(int i, int j) {
if (j == 0)
return i;
else
return gcd(j, i%j);
}

public static void printArray(int[] arr) {
for(int i = 0; i<arr.length; i++) {
System.out.print(arr[i]+ " ");
} 
}

public static void leftRotatebyOne(int arr[], int n)
{
int temp = arr[0];
int i;
for(i = 0; i < n-1; i++)
arr[i] = arr[i+1];

arr[i] = temp;
}

/*Function to left rotate arr[] of size n by d*/
public static void leftRotate(int arr[], int d, int n)
{
for (int i = 0; i < d; i++)
leftRotatebyOne(arr, n);
}
public static void main(String[] args) {
// TODO Auto-generated method stub
int[] arr = {1,2,3,4,5,6,7,8,9};
rotate(arr, 201, 9);
printArray(arr);
System.out.print("\n=================\n");
leftRotate(arr, 2, 9);
printArray(arr)
```
<Overlap Ratio: 0.9650735294117647>

---

--- 61 --
Question ID: 5f639b1917ac0e6e9e1bdf8d1d8fb88e31bf9aa0
Original Code:
```
@RestController
@RequestMapping("/customer")
public class CustomerController {

    @Autowired
    private CustomerService customerService;

    @Autowired
    private AddressService addressService;

    @GetMapping("/search")
    public PageInfo<CustomerListOutDTO> search(CustomerSearchInDTO customerSearchInDTO,
                                               @RequestParam(defaultValue = "1") Integer pageNum){
        PageHelper.startPage(pageNum,5);
        List<Customer> customers = customerService.search(customerSearchInDTO);
        List<CustomerListOutDTO> customerListOutDTOS = customers.stream().map(customer -> {
            CustomerListOutDTO customerListOutDTO = new CustomerListOutDTO();
            customerListOutDTO.setCustomerId(customer.getCustomerId());
            customerListOutDTO.setUsername(customer.getUsername());
            customerListOutDTO.setRealName(customer.getRealName());
            customerListOutDTO.setMobile(customer.getMobile());
            customerListOutDTO.setEmail(customer.getEmail());
            customerListOutDTO.setStatus(customer.getStatus());
            customerListOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());
            return customerListOutDTO;
        }).collect(Collectors.toList());
        PageInfo<CustomerListOutDTO> pageInfo = new PageInfo<>(customerListOutDTOS);
        return pageInfo;
    }

    @PostMapping("/create")
    public String  create(@RequestBody CustomerCreateInDTO customerCreateInDTO){
        return null;
    }

    @GetMapping("/getCustomer")
    public CustomerShowOutDTO getCustomer(@RequestParam Integer customerId){
        Customer customer = customerService.getById(customerId);
        CustomerShowOutDTO customerShowOutDTO = new CustomerShowOutDTO();
        customerShowOutDTO.setCustomerId(customerId);
        customerShowOutDTO.setUsername(customer.getUsername());
        customerShowOutDTO.setRealName(customer.getRealName());
        customerShowOutDTO.setMobile(customer.getMobile());
        customerShowOutDTO.setEmail(customer.getEmail());
        customerShowOutDTO.setDefaultAddressId(customer.getDefaultAddressId());
        customerShowOutDTO.setStatus(customer.getStatus());
        customerShowOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());
        customerShowOutDTO.setNewsSubscribed(customer.getNewsSubscribed());
        customerShowOutDTO.setRewordPoints(customer.getRewordPoints());
        customerShowOutDTO.setAvatarUrl(customer.getAvatarUrl());

        Address addressById = addressService.getById(customer.getDefaultAddressId());
        if(addressById != null){
            customerShowOutDTO.setDefaultAddress(addressById.getContent());
        }


        return customerShowOutDTO;
    }

    @PostMapping("/update")
    public void update(@RequestBody CustomerUpdateInDTO customerUpdateInDTO){

    }

    @PostMapping("/setStatus")
    public void setStatus(@RequestBody CustomerSetStatusInDTO customerSetStatusInDTO){
        customerService.setStatus(customerSetStatusInDTO);
    }

}
```


Overlapping Code:
```
@RestController
@RequestMapping("/customer")
public class CustomerController {
@Autowired
private CustomerService customerService;
@Autowired
private AddressService addressService;
@GetMapping("/search")
public PageInfo<CustomerListOutDTO> search(CustomerSearchInDTO customerSearchInDTO,
@RequestParam(defaultValue = "1") Integer pageNum){
PageHelper.startPage(pageNum,5);
List<Customer> customers = customerService.search(customerSearchInDTO);
List<CustomerListOutDTO> customerListOutDTOS = customers.stream().map(customer -> {
CustomerListOutDTO customerListOutDTO = new CustomerListOutDTO();
customerListOutDTO.setCustomerId(customer.getCustomerId());
customerListOutDTO.setUsername(customer.getUsername());
customerListOutDTO.setRealName(customer.getRealName());
customerListOutDTO.setMobile(customer.getMobile());
customerListOutDTO.setEmail(customer.getEmail());
customerListOutDTO.setStatus(customer.getStatus());
customerListOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());
return customerListOutDTO;
}).collect(Collectors.toList());
PageInfo<CustomerListOutDTO> pageInfo = new PageInfo<>(customerListOutDTOS);
return pageInfo;
}
@PostMapping("/create")
public String create(@RequestBody CustomerCreateInDTO customerCreateInDTO){
return null;
}
@GetMapping("/getCustomer")
public CustomerShowOutDTO getCustomer(@RequestParam Integer customerId){
Customer customer = customerService.getById(customerId);
CustomerShowOutDTO customerShowOutDTO = new CustomerShowOutDTO();
customerShowOutDTO.setCustomerId(customerId);
customerShowOutDTO.setUsername(customer.getUsername());
customerShowOutDTO.setRealName(customer.getRealName());
customerShowOutDTO.setMobile(customer.getMobile());
customerShowOutDTO.setEmail(customer.getEmail());
customerShowOutDTO.setDefaultAddressId(customer.getDefaultAddressId());
customerShowOutDTO.setStatus(customer.getStatus());
customerShowOutDTO.setCreateTimestamp(customer.getCreateTime().getTime());
customerShowOutDTO.setNewsSubscribed(customer.getNewsSubscribed());
customerShowOutDTO.setRewordPoints(customer.getRewordPoints());
customerShowOutDTO.setAvata
```
<Overlap Ratio: 0.9901408450704225>

---

--- 62 --
Question ID: 9a566b4bc8b0067738083e87599123aa9b2cd505
Original Code:
```
public class ScreenShotPlayerActivity extends AppCompatActivity {

    private VideoView mVideoView;
    private ImageView mScreenShot;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_screen_shot_player);
        ActionBar actionBar = getSupportActionBar();
        if (actionBar != null) {
            actionBar.setTitle(R.string.str_screen_shot);
            actionBar.setDisplayHomeAsUpEnabled(true);
        }
        mVideoView = findViewById(R.id.player);
        mScreenShot = findViewById(R.id.iv_screen_shot);
        StandardVideoController controller = new StandardVideoController(this);
        mVideoView.setUrl("http://vfx.mtime.cn/Video/2019/03/12/mp4/190312143927981075.mp4");
        mVideoView.setVideoController(controller);
        mVideoView.start();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            finish();
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onPause() {
        super.onPause();
        mVideoView.pause();
    }

    @Override
    protected void onResume() {
        super.onResume();
        mVideoView.resume();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mVideoView.release();
    }


    @Override
    public void onBackPressed() {
        if (!mVideoView.onBackPressed()) {
            super.onBackPressed();
        }
    }

    public void doScreenShot(View view) {
        Bitmap bitmap = mVideoView.doScreenShot();
        mScreenShot.setImageBitmap(bitmap);
    }
}
```


Overlapping Code:
```
PlayerActivity extends AppCompatActivity {
private VideoView mVideoView;
private ImageView mScreenShot;
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_screen_shot_player);
ActionBar actionBar = getSupportActionBar();
if (actionBar != null) {
actionBar.setTitle(R.string.str_screen_shot);
actionBar.setDisplayHomeAsUpEnabled(true);
}
mVideoView = findViewById(R.id.player);
mScreenShot = findViewById(R.id.iv_screen_shot);
StandardVideoController controller = new StandardVideoController(this);
mVideoView.setUrl("http://vfx.mtime.cn/Video/2019/03/12/mp4/190312143927981075.mp4");
mVideoView.setVideoController(controller);
mVideoView.start();
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
if (item.getItemId() == android.R.id.home) {
finish();
}
return super.onOptionsItemSelected(item);
}
@Override
protected void onPause() {
super.onPause();
mVideoView.pause();
}
@Override
protected void onResume() {
super.onResume();
mVideoView.resume();
}
@Override
protected void onDestroy() {
super.onDestroy();
mVideoView.release();
}
@Override
public void onBackPressed() {
if (!mVideoView.onBackPressed()) {
super.onBackPressed();
}
}
public void doScreenShot(View view) {
Bitmap bitmap = mVideoView.doScreenShot();
mScreenShot.setImageBitmap(bitmap);
```
<Overlap Ratio: 0.9805335255948089>

---

--- 63 --
Question ID: d7aa85b09a9222d12a401472dc73286720a10017
Original Code:
```
public class GeneTreeHomologyReader{
	public static void main(String[] args)  throws IOException, NewickIOException {
		if(args.length != 1){
			System.err.println("Usage: java -classpath jprime.jar se.cbb.jprime.apps.phylotools.GeneTreeHomologyReader gene_tree_name");
			System.out.println("Exiting now...");
			System.exit(1);
		}
		System.out.println("Input true reconciliation file is " + args[0]);								
		String treepath = parseTreeFromReconciliationFile(args[0]);
		File gFile = new File(treepath);
		BufferedWriter writer = new BufferedWriter(new FileWriter(args[0]+".original"));
		
		PrIMENewickTree sRaw = PrIMENewickTreeReader.readTree(gFile, false, true);
		//System.out.println("Tree is " + sRaw.toString());
		//System.out.println(sRaw.toString());		
		System.out.println("Extracting true reconciliation events...");
		System.out.println("The tree is : " + sRaw);
		List<NewickVertex> vertices = sRaw.getVerticesAsList();
		int[] dupStatus = sRaw.getVertexDuplicationValues();
		for (NewickVertex v : vertices) {
			int id = v.getNumber();
			if(dupStatus[id] != Integer.MAX_VALUE){
				ArrayList<NewickVertex> children = v.getChildren();
				//String lchild = getLeafIds(children.get(0));
				//String rchild = getLeafIds(children.get(1));
				String lchild = getLeafNames(children.get(0));
				String rchild = getLeafNames(children.get(1));
				//System.out.println("The childern ids are " + lchild + " and " + rchild);
				//System.out.println("The node number " + id + " has dupStatus = " + dupStatus[id]);
				writer.write("["+lchild+", "+rchild+"]"+"\t"+dupStatus[id]+"\n");
				System.out.println("["+lchild+", "+rchild+"]"+"\t"+dupStatus[id]);
			}
		}
		writer.flush();
		writer.close();
		gFile.deleteOnExit();
		System.out.println("Done...");
		System.out.println("True values has been written to " + args[0]+".original");
	}
	
	private static String parseTreeFromReconciliationFile(String fileName) {
		try {
			String gfileName = "treeFromReconFile.tree";
			File f = new File(gfileName);
			if(f.exists())
			    f.delete();
			BufferedReader buf = new BufferedReader(new FileReader(fileName));
			BufferedWriter bw = new BufferedWriter(new FileWriter(gfileName));		
			String line = "";
			while((line = buf.readLine()) != null){
				line = line.trim();
				if(line.charAt(0) == '#')
					continue;
				else {
	//				StringTokenizer stk = new StringTokenizer(line);
	//				String tree = "";
	//				
	//				// true reconciliations is the last token
	//				while(stk.hasMoreTokens())
	//					tree = stk.nextToken();
					String[] token = line.split(";");
					
					String trueFile = "";
					if(token.length == 1)
						trueFile = token[0].trim();
					else
						trueFile = token[4].trim();
					bw.write(trueFile);
					bw.flush();
					bw.close();
					buf.close();
					
					return gfileName;
				}
			}
			bw.flush();
			bw.close();
			buf.close();
		}catch(Exception ex){
			System.err.println("Error in reading reconciliation file");
			System.err.println("Reason: " + ex.getMessage());
		}
		return null;
	}

	public static String getLeafNames(NewickVertex vertex){		 
		 String lNames = getLeafNamesRecursive(vertex);
		return lNames;
	}

	private static String getLeafNamesRecursive(NewickVertex vertex) {
		if(vertex.isLeaf())
			return vertex.getName();
		else {
			ArrayList<NewickVertex> ch = vertex.getChildren();
			return getLeafNamesRecursive(ch.get(0)) + " " + getLeafNamesRecursive(ch.get(1));
		}
	}
	
	public static String getLeafIds(NewickVertex vertex){
		String lNames = "";
		lNames += getLeafIdsRecursive(vertex);
		return lNames + "";
	}

	private static String getLeafIdsRecursive(NewickVertex vertex) {
		if(vertex.isLeaf())
			return vertex.getNumber()+"";
		else {
			ArrayList<NewickVertex> ch = vertex.getChildren();
			return getLeafIdsRecursive(ch.get(0)) + " " + getLeafIdsRecursive(ch.get(1));
		}
	}
}
```


Overlapping Code:
```
er{
public static void main(String[] args) throws IOException, NewickIOException {
if(args.length != 1){
System.err.println("Usage: java -classpath jprime.jar se.cbb.jprime.apps.phylotools.GeneTreeHomologyReader gene_tree_name");
System.out.println("Exiting now...");
System.exit(1);
}
System.out.println("Input true reconciliation file is " + args[0]); 
String treepath = parseTreeFromReconciliationFile(args[0]);
File gFile = new File(treepath);
BufferedWriter writer = new BufferedWriter(new FileWriter(args[0]+".original"));

PrIMENewickTree sRaw = PrIMENewickTreeReader.readTree(gFile, false, true);
//System.out.println("Tree is " + sRaw.toString());
//System.out.println(sRaw.toString()); 
System.out.println("Extracting true reconciliation events...");
System.out.println("The tree is : " + sRaw);
List<NewickVertex> vertices = sRaw.getVerticesAsList();
int[] dupStatus = sRaw.getVertexDuplicationValues();
for (NewickVertex v : vertices) {
int id = v.getNumber();
if(dupStatus[id] != Integer.MAX_VALUE){
ArrayList<NewickVertex> children = v.getChildren();
//String lchild = getLeafIds(children.get(0));
//String rchild = getLeafIds(children.get(1));
String lchild = getLeafNames(children.get(0));
String rchild = getLeafNames(children.get(1));
//System.out.println("The childern ids are " + lchild + " and " + rchild);
//System.out.println("The node number " + id + " has dupStatus = " + dupStatus[id]);
writer.write("["+lchild+", "+rchild+"]"+"\t"+dupStatus[id]+"\n");
System.out.println("["+lchild+", "+rchild+"]"+"\t"+dupStatus[id]);
}
}
writer.flush();
writer.close();
gFile.deleteOnExit();
System.out.println("Done...");
System.out.println("True values has been written to " + args[0]+".original");
}

private static String parseTreeFromReconciliationFile(String fileName) {
try {
String gfileName = "treeFromReconFile.tree";
File f = new File(gfileName);
if(f.exists())
f.delete();
BufferedReader buf = new BufferedReader(new FileReader(fileName));
BufferedWriter bw = new BufferedWriter(new FileWriter(gfileName)); 
String line = "";
while((line = buf.readLine()) != null){
line = line.trim();
if(line.charAt(0) == '#')
continue;
else {
// StringTokenizer stk = new StringTokenizer(line);
// String tree = "";
// 
// // true reconciliations is the
```
<Overlap Ratio: 0.9745908699397071>

---

--- 64 --
Question ID: 38aa23fa3e61ae0006a50f9755e6c17f8e2129e5
Original Code:
```
public abstract class AbstractResource implements Resource {
    public AbstractResource() {
    }

    public boolean exists() {
        Log logger;
        if (this.isFile()) {
            try {
                return this.getFile().exists();
            } catch (IOException var4) {
                logger = LogFactory.getLog(this.getClass());
                if (logger.isDebugEnabled()) {
                    logger.debug("Could not retrieve File for existence check of " + this.getDescription(), var4);
                }
            }
        }

        try {
            this.getInputStream().close();
            return true;
        } catch (Throwable var3) {
            logger = LogFactory.getLog(this.getClass());
            if (logger.isDebugEnabled()) {
                logger.debug("Could not retrieve InputStream for existence check of " + this.getDescription(), var3);
            }

            return false;
        }
    }

    public boolean isReadable() {
        return this.exists();
    }

    public boolean isOpen() {
        return false;
    }

    public boolean isFile() {
        return false;
    }

    public URL getURL() throws IOException {
        throw new FileNotFoundException(this.getDescription() + " cannot be resolved to URL");
    }

    public URI getURI() throws IOException {
        URL url = this.getURL();

        try {
            return ResourceUtils.toURI(url);
        } catch (URISyntaxException var3) {
            throw new NestedIOException("Invalid URI [" + url + "]", var3);
        }
    }

    public File getFile() throws IOException {
        throw new FileNotFoundException(this.getDescription() + " cannot be resolved to absolute file path");
    }

    public ReadableByteChannel readableChannel() throws IOException {
        return Channels.newChannel(this.getInputStream());
    }

    public long contentLength() throws IOException {
        InputStream is = this.getInputStream();
        boolean var16 = false;

        long var6;
        try {
            var16 = true;
            long size = 0L;
            byte[] buf = new byte[256];

            while(true) {
                int read;
                if ((read = is.read(buf)) == -1) {
                    var6 = size;
                    var16 = false;
                    break;
                }

                size += (long)read;
            }
        } finally {
            if (var16) {
                try {
                    is.close();
                } catch (IOException var17) {
                    Log logger = LogFactory.getLog(this.getClass());
                    if (logger.isDebugEnabled()) {
                        logger.debug("Could not close content-length InputStream for " + this.getDescription(), var17);
                    }
                }

            }
        }

        try {
            is.close();
        } catch (IOException var18) {
            Log logger = LogFactory.getLog(this.getClass());
            if (logger.isDebugEnabled()) {
                logger.debug("Could not close content-length InputStream for " + this.getDescription(), var18);
            }
        }

        return var6;
    }

    public long lastModified() throws IOException {
        File fileToCheck = this.getFileForLastModifiedCheck();
        long lastModified = fileToCheck.lastModified();
        if (lastModified == 0L && !fileToCheck.exists()) {
            throw new FileNotFoundException(this.getDescription() + " cannot be resolved in the file system for checking its last-modified timestamp");
        } else {
            return lastModified;
        }
    }

    protected File getFileForLastModifiedCheck() throws IOException {
        return this.getFile();
    }

    public Resource createRelative(String relativePath) throws IOException {
        throw new FileNotFoundException("Cannot create a relative resource for " + this.getDescription());
    }

    
    public String getFilename() {
        return null;
    }

    public boolean equals( Object other) {
        return this == other || other instanceof Resource && ((Resource)other).getDescription().equals(this.getDescription());
    }

    public int hashCode() {
        return this.getDescription().hashCode();
    }

    public String toString() {
        return this.getDescription();
    }
}
```


Overlapping Code:
```
public abstract class AbstractResource implements Resource {
public AbstractResource() {
}
public boolean exists() {
Log logger;
if (this.isFile()) {
try {
return this.getFile().exists();
} catch (IOException var4) {
logger = LogFactory.getLog(this.getClass());
if (logger.isDebugEnabled()) {
logger.debug("Could not retrieve File for existence check of " + this.getDescription(), var4);
}
}
}
try {
this.getInputStream().close();
return true;
} catch (Throwable var3) {
logger = LogFactory.getLog(this.getClass());
if (logger.isDebugEnabled()) {
logger.debug("Could not retrieve InputStream for existence check of " + this.getDescription(), var3);
}
return false;
}
}
public boolean isReadable() {
return this.exists();
}
public boolean isOpen() {
return false;
}
public boolean isFile() {
return false;
}
public URL getURL() throws IOException {
throw new FileNotFoundException(this.getDescription() + " cannot be resolved to URL");
}
public URI getURI() throws IOException {
URL url = this.getURL();
try {
return ResourceUtils.toURI(url);
} catch (URISyntaxException var3) {
throw new NestedIOException("Invalid URI [" + url + "]", var3);
}
}
public File getFile() throws IOException {
throw new FileNotFoundException(this.getDescription() + " cannot be resolved to absolute file path");
}
public ReadableByteChannel readableChannel() throws IOException {
return Channels.newChannel(this.getInputStream());
}
public long contentLength() throws IOException {
InputStream is = this.getInputStream();
boolean var16 = false;
long var6;
try {
var16 = true;
long size = 0L;
byte[] buf = new byte[256];
while(true) {
int read;
if ((read = is.read(buf)) == -1) {
var6 = size;
var16 = false;
break;
}
size += (long)read;
}

```
<Overlap Ratio: 0.9761227970437749>

---

--- 65 --
Question ID: fbb847b445407c3fe5c71244e7d927866222f275
Original Code:
```
public class Wrapperz {
	/*
	 * Character - char
	 * Boolean - boolean
	 * Byte - byte
	 * Short - short
	 * Integer - int
	 * Long - long
	 * Float - float
	 * Double - double
	 
	 * Auto-Boxing
	 * Boxing - implicit conversion from primitive to wrapper
	 * Unboxing - implicit conversion from wrapper to primitive
	 */
	static int myInt = 3;
	static Integer myInteger = 5;
	static Double myDouble = 45.93;
	
	public static int addEmUp(int a, int b) {
		return a+b;
	}

	public static void main(String[] args) {
		int result = addEmUp(myInt, myInteger);
		System.out.println(result);
		Integer i = 0;
		i = i.MAX_VALUE;
		System.out.println(i);
	}

}
```


Overlapping Code:
```
rz {
/*
* Character - char
* Boolean - boolean
* Byte - byte
* Short - short
* Integer - int
* Long - long
* Float - float
* Double - double

* Auto-Boxing
* Boxing - implicit conversion from primitive to wrapper
* Unboxing - implicit conversion from wrapper to primitive
*/
static int myInt = 3;
static Integer myInteger = 5;
static Double myDouble = 45.93;

public static int addEmUp(int a, int b) {
return a+b;
}
public static void main(String[] args) {
int result = addEmUp(myInt, myInteger);
System.out.println(result);
Integer i = 0;
i = i.MAX_
```
<Overlap Ratio: 0.9136212624584718>

---

--- 66 --
Question ID: a5ed88b60810840a9ad61b3ccf665cecb25aae33
Original Code:
```
@SuppressWarnings("all")
public class EventBContainerManager extends StateBasedContainerManager {
  @Override
  protected List<IContainer> getVisibleContainers(final List<String> handles, final IResourceDescriptions resourceDescriptions) {
    List<IContainer> result = super.getVisibleContainers(handles, resourceDescriptions);
    Iterable<IResourceDescription> _allResourceDescriptions = resourceDescriptions.getAllResourceDescriptions();
    for (final IResourceDescription rd : _allResourceDescriptions) {
      {
        IContainer container = super.getContainer(rd, resourceDescriptions);
        boolean _isEmpty = container.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          result.add(container);
        }
      }
    }
    return result;
  }
}
```


Overlapping Code:
```
essWarnings("all")
public class EventBContainerManager extends StateBasedContainerManager {
@Override
protected List<IContainer> getVisibleContainers(final List<String> handles, final IResourceDescriptions resourceDescriptions) {
List<IContainer> result = super.getVisibleContainers(handles, resourceDescriptions);
Iterable<IResourceDescription> _allResourceDescriptions = resourceDescriptions.getAllResourceDescriptions();
for (final IResourceDescription rd : _allResourceDescriptions) {
{
IContainer container = super.getContainer(rd, resourceDescriptions);
boolean _isEmpty = container.isEmpty();
boolean _not = (!_isEmpty);
if (_not) {
result.add(container);
}
}
}
return result;
}

```
<Overlap Ratio: 0.98989898989899>

---

--- 67 --
Question ID: 4f232995aa7f5e7eba5cfc2f2d2939b6e8451734
Original Code:
```
public class Strings1 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        
        String S = "Lorem at";
        int n = S.length();
        
        int k = 0;
        
        //determine if the string length is odd or even
        if (n % 2 == 0) {
            k = 4;
        } else {
            k = 3;
        }
        
        //function to transform the string
        String transformedString = transformString(S, k, n);
        
        System.out.println(transformedString);
    }
    
    public static String transformString (String S, int k, int n) {
        for (int i = 0; i < n;) {
            if (i + k > n)
                break;
            
            S = S.substring(0, i) + new String(new StringBuilder(
                   S.substring(i, i + k)).reverse()) +
                   S.substring(i + k);
            
            i += k; 
        }
        
        return S;
    }
    
}
```


Overlapping Code:
```
ass Strings1 {
/**
* @param args the command line arguments
*/
public static void main(String[] args) {
// TODO code application logic here

String S = "Lorem at";
int n = S.length();

int k = 0;

//determine if the string length is odd or even
if (n % 2 == 0) {
k = 4;
} else {
k = 3;
}

//function to transform the string
String transformedString = transformString(S, k, n);

System.out.println(transformedString);
}

public static String transformString (String S, int k, int n) {
for (int i = 0; i < n;) {
if (i + k > n)
break;

S = S.substring(0, i) + new String(new StringBuilder(
S.substring(i, i + k)).reverse()) +
S.substring(i + k);

i += k
```
<Overlap Ratio: 0.9572901325478645>

---

--- 68 --
Question ID: 0a75b00f3f760575d0cde31feb30b1f84279a528
Original Code:
```
public class GraphPane extends JComponent
    implements MouseListener, MouseWheelListener, MouseMotionListener, GraphListener, ComponentListener {

  private static final long serialVersionUID = 3827345534868023684L;

  private Graph graph;

  private Renderers renderers = new Renderers();

  private boolean mouseHoverEnabled = true;

  private StageMode stageMode = StageMode.PAN;
  private NodeDragMode nodeDragMode = NodeDragMode.SELECTION;
  private RenderContext renderContext;

  private List<NodeListener> nodeListeners = new ArrayList<>();
  private List<StageListener> stageListeners = new ArrayList<>();
  private List<EdgeListener> edgeListeners = new ArrayList<>();

  private boolean historyEnabled = false;
  private GraphHistory history;

  private boolean showBoundingBoxes = false;

  private boolean mouseWheelZoomEnabled = true;
  private double scale = 1d / 5d;
  private static final double MIN_ZOOM = 1d / 4d;
  private static final double MAX_ZOOM = 5d;

  private boolean isDragging = false;
  private Node nodeUnderMouse = null;
  private Edge edgeUnderMouse = null;

  protected AffineTransform transform = new AffineTransform();
  protected AffineTransform inverseTransform = new AffineTransform();

  private int startDragX;
  private int startDragY;

  private int nodeDragOffsetX;
  private int nodeDragOffsetY;

  private Set<String> selectedNodes = new HashSet<>();
  private Set<String> selectedEdges = new HashSet<>();
  private Map<String, NodeBoundingBox> boxesIndex = new HashMap<>();

  private Set<String> idleNodes = new HashSet<>();
  private Set<String> liveNodes = new HashSet<>();

  private Double selectionBox;

  private BufferedImage idleBuffer;
  private Graphics2D idleGraphics;

  private int lastBufferX;
  private int lastBufferY;

  private boolean isPrinting;

  public GraphPane(Graph graph) {
    super();
    this.graph = graph;
    this.history = new GraphHistory(this);
    this.renderContext = new RenderContext(this, graph);
    this.addMouseWheelListener(this);
    this.addMouseMotionListener(this);
    this.addMouseListener(this);
    this.addComponentListener(this);

    this.graph.addListener(this);

    this.idleNodes.addAll(this.graph.getNodeIds());
  }

  @Override
  protected void paintComponent(Graphics g) {
    Graphics2D g2d = (Graphics2D) g;
    paintGraph(g, this.transform, g2d.getClipBounds());
  }

  private void paintGraph(Graphics g, AffineTransform tx, Rectangle2D clipBounds) {
    Graphics2D g2d = (Graphics2D) g;

    AffineTransform currentTransform = g2d.getTransform();
    AffineTransform graphTransformation = (AffineTransform) currentTransform.clone();
    graphTransformation.concatenate(tx);

    int originX = (int) (-1 * currentTransform.getTranslateX());
    int originY = (int) (-1 * currentTransform.getTranslateY());

    try {
      clipBounds.setFrame(clipBounds.getX() - Math.abs(originX), clipBounds.getY() - Math.abs(originY),
          clipBounds.getWidth() + 2 * Math.abs(originX), clipBounds.getHeight() + 2 * Math.abs(originY));
      clipBounds = graphTransformation.createInverse().createTransformedShape(clipBounds).getBounds2D();
    } catch (NoninvertibleTransformException e) {
      throw new RuntimeException(e);
    }

    RenderingHints rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2d.setRenderingHints(rh);

    int imageWidth = this.getWidth() + Math.abs(originX);
    int imageHeight = this.getHeight() + Math.abs(originY);

    BufferedImage liveBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);
    Graphics2D liveGraphics = liveBuffer.createGraphics();
    liveGraphics.setRenderingHints(rh);
    
    //resetBuffer from other thread could cause NPE because it nulls attributes below
    BufferedImage idleBuffer = this.idleBuffer;
    Graphics2D idleGraphics = this.idleGraphics;

    boolean paintIdleNodes = idleBuffer == null || idleBuffer.getHeight() != imageHeight
        || idleBuffer.getWidth() != imageWidth || this.lastBufferX != originX || this.lastBufferY != originY;
    if (paintIdleNodes) {
      idleBuffer = new BufferedImage(imageWidth, imageHeight, BufferedImage.TYPE_INT_ARGB);
      idleGraphics = idleBuffer.createGraphics();
      idleGraphics.setRenderingHints(rh);

      idleGraphics.setBackground(getBackground());
      idleGraphics.clearRect(0, 0, imageWidth, imageHeight);

      this.lastBufferX = originX;
      this.lastBufferY = originY;
    }

    GraphRenderer graphRenderer = renderers.getGraphRenderer(this.graph.getType());
    graphRenderer.render(liveGraphics, this.graph);

    Collection<Edge> liveEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.liveNodes));
    paintEdges(liveGraphics, graphTransformation, clipBounds, liveEdges);
    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.liveNodes));
    
    HashSet<Edge> overlappedEdges = new HashSet<>(liveEdges);

    Collection<Edge> idleEdges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));
    overlappedEdges.addAll(idleEdges);
    if (paintIdleNodes) {
      idleEdges.removeAll(liveEdges);
      paintEdges(idleGraphics, graphTransformation, clipBounds, idleEdges);
      paintNodes(idleGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(this.idleNodes));
    }

    g2d.drawImage(idleBuffer, originX, originY, null);
    
    Set<String> nodesOfSelectedEdges = paintSelectedEdges(liveGraphics, graphTransformation, clipBounds, overlappedEdges);
    paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, graph.getNodes(nodesOfSelectedEdges));

    Node hoveredNode = getHoveredNode();
    if (hoveredNode != null && !isPrinting) {
      NodeBoundingBox box = this.boxesIndex.get(hoveredNode.getId());
      if (box != null) {
        NodeHoverRenderer renderer = renderers.getNodeHoverRenderer("default");
        GraphShape graphShape = renderer.render(g2d, box, renderContext);
        graphShape.draw(g2d, tx);
        paintNodes(liveGraphics, graphTransformation, currentTransform, clipBounds, Arrays.asList(hoveredNode));
      }
    }

    if (!isPrinting) {
      paintSelections(liveGraphics, graphTransformation, clipBounds);
    }

    if (this.selectionBox != null && !isPrinting) {
      paintSelectionBox(liveGraphics, graphTransformation);
    }

    Color color = liveGraphics.getColor();
    liveGraphics.setColor(Color.BLUE);
    liveGraphics.fill(graphTransformation.createTransformedShape(new Rectangle2D.Double(-2, -2, 4, 4)));
    liveGraphics.setColor(Color.GREEN);
    liveGraphics.fill(new Rectangle2D.Double(-2, -2, 4, 4));

    liveGraphics.setColor(color);
    g2d.drawImage(liveBuffer, originX, originY, null);

    liveGraphics.dispose();
  }

  private void paintSelections(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds) {
    for (String selectedId : this.selectedNodes) {
      Node node = this.graph.getNode(selectedId);
      NodeBoundingBox boundingBox = this.boxesIndex.get(node.getId());
      if (boundingBox.intersects(clipBounds)) {
        SelectionRenderer renderer = renderers.getSelectionRenderer(node.getSelectionType());
        GraphShape selectionGraphShape = renderer.render(g2d, boundingBox, renderContext);
        if (selectionGraphShape != null) {
          selectionGraphShape.draw(g2d, tx);
        }
      }
    }
  }

  private void paintSelectionBox(Graphics2D g2d, AffineTransform tx) {
    Color oldColor = g2d.getColor();
    g2d.setColor(this.graph.getSettings().getSelectionColor());
    g2d.draw(tx.createTransformedShape(selectionBox));
    g2d.setColor(oldColor);
  }

  private void paintNodes(Graphics2D g2d, AffineTransform stageTx, AffineTransform componentTx, Rectangle2D clipBounds,
      Collection<Node> nodes) {
    for (Node node : nodes) {
      NodeBoundingBox nodeBoundingBox = this.boxesIndex.get(node.getId());
      if (nodeBoundingBox == null) {
        nodeBoundingBox = new NodeBoundingBox(1.4d);
        this.boxesIndex.put(node.getId(), nodeBoundingBox);
      } else {
        nodeBoundingBox.clear();
      }

      NodeRenderer renderer = renderers.getNodeRenderer(node.getType());
      GraphShape nodeGraphShape = renderer.render(g2d, node, renderContext);
      if (nodeGraphShape != null && nodeGraphShape.getShape().intersects(clipBounds)) {
        nodeGraphShape.draw(g2d, stageTx);

        Rectangle2D bounds = nodeBoundingBox.addBox(nodeGraphShape.getShape());
        if (this.showBoundingBoxes) {
          g2d.draw(stageTx.createTransformedShape(bounds));
        }
      }

      LabelRenderer labelRenderer = renderers.getLabelRenderer(node.getLabelType());
      GraphShape labelGraphShape = labelRenderer.render(g2d, node, renderContext);
      if (labelGraphShape != null && labelGraphShape.getShape().intersects(clipBounds)) {
        labelGraphShape.draw(g2d, stageTx);

        Rectangle2D bounds = nodeBoundingBox.addBox(labelGraphShape.getShape());
        if (this.showBoundingBoxes) {
          g2d.draw(stageTx.createTransformedShape(bounds));
        }
      }
    }
  }

  private void paintEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {
    for (Edge edge : edges) {
      EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());
      GraphShape graphShape = renderer.render(g2d, edge, renderContext);
      if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {
        graphShape.draw(g2d, tx);
      }
    }
  }
  
  private Set<String> paintSelectedEdges(Graphics2D g2d, AffineTransform tx, Rectangle2D clipBounds, Collection<Edge> edges) {
      Set<String> nodesUnderEdges = new HashSet<>();
      for (Edge edge : edges) {
        if(selectedEdges.contains(edge.getId())) {
            edge.setColor(Color.RED);
            nodesUnderEdges.add(edge.getSource());
            nodesUnderEdges.add(edge.getTarget());
        }else if(edge.equals(this.edgeUnderMouse)){
            edge.setColor(Color.BLACK);
            nodesUnderEdges.add(edge.getSource());
            nodesUnderEdges.add(edge.getTarget());
        }else {
            continue;
        }
        EdgeRenderer renderer = renderers.getEdgeRenderer(edge.getType());
        GraphShape graphShape = renderer.render(g2d, edge, renderContext);
        if (graphShape != null && graphShape.getShape().intersects(clipBounds)) {
          graphShape.draw(g2d, tx);
        }
        edge.setColor(null);
      }
      return nodesUnderEdges;
  }

  public BufferedImage toImage() {
    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_ARGB);
    print(image.getGraphics());
    return image;
  }

  public Graph getGraph() {
    return graph;
  }

  public void addNodeListener(NodeListener nodeListener) {
    this.nodeListeners.add(nodeListener);
  }

  public void removeNodeListener(NodeListener nodeListener) {
    this.nodeListeners.remove(nodeListener);
  }

  public void addEdgeListener(EdgeListener listener) {
    this.edgeListeners.add(listener);
  }

  public void removeEdgeListener(EdgeListener listener) {
    this.edgeListeners.remove(listener);
  }

  public void addStageListener(StageListener stageListener) {
    this.stageListeners.add(stageListener);
  }

  public void removeStageListener(StageListener stageListener) {
    this.stageListeners.remove(stageListener);
  }

  @Override
  public void mouseClicked(MouseEvent e) {
    if (this.isEnabled()) {
      if (this.nodeUnderMouse != null) {
        notifyNodeClicked(this.nodeUnderMouse, e);
      } else {
        if(this.edgeUnderMouse != null) {
          notifyEdgeClicked(edgeUnderMouse, e);
        }else {
          notifyStageClicked(e);    
        }
      }
    }
  }

  private void notifyStageClicked(MouseEvent e) {
    for (StageListener stageListener : this.stageListeners) {
      stageListener.stageClicked(e);
    }
  }

  private void notifyZoomChanged() {
    for (StageListener stageListener : this.stageListeners) {
      stageListener.stageZoomChanged(getZoom());
    }
  }

  private void notifyStageDragStarted(MouseEvent e) {
    for (StageListener stageListener : this.stageListeners) {
      stageListener.stageDragStarted(e);
    }
  }

  private void notifyStageDragStopped(MouseEvent e) {
    for (StageListener stageListener : this.stageListeners) {
      stageListener.stageDragStopped(e);
    }
  }

  private void notifyStageMoved() {
    for (StageListener stageListener : this.stageListeners) {
      stageListener.stageMoved(getTranslateX(), getTranslateY());
    }
  }

  private void notifyNodeClicked(Node node, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeClicked(node, e);
    }
  }
  
  private void notifyEdgeClicked(Edge edge, MouseEvent e) {
    for (EdgeListener listener : this.edgeListeners) {
      listener.edgeClicked(edge, e);
    }
  }
  
  private void notifyEdgeHover(Edge edge, MouseEvent e) {
      for (EdgeListener listener : this.edgeListeners) {
        listener.edgeHovered(edge, e);
      }
  }
  
  private void notifyEdgeOut(Edge edge, MouseEvent e) {
      for (EdgeListener listener : this.edgeListeners) {
        listener.edgeOut(edge, e);
      }
  }
  
  private void notifyEdgesSelected(Collection<Edge> edges, MouseEvent e) {
      for (EdgeListener listener : this.edgeListeners) {
        listener.edgesSelected(edges, e);
      }
  }

  private void notifyNodePressed(Node node, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodePressed(node, e);
    }
  }

  private void notifyNodeHover(Node node, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeHover(node, e);
    }
  }

  private void notifyNodeOut(MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeOut(e);
    }
  }

  private void notifyNodeReleased(Node node, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeReleased(node, e);
    }
  }

  private void notifyNodeDragStarted(Collection<Node> nodes, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeDragStarted(nodes, e);
    }
  }

  private void notifyNodeDragStopped(Collection<Node> nodes, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeDragStopped(nodes, e);
    }
  }

  private void notifyNodeDragged(Collection<Node> nodes, MouseEvent e) {
    for (NodeListener listener : this.nodeListeners) {
      listener.nodeDragged(nodes, e);
    }
  }

  private Node getNodeUnderMouse(MouseEvent evt) {
    Point2D evtPoint = invert(evt.getPoint());
    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {
      NodeBoundingBox box = entry.getValue();
      if (box.contains(evtPoint)) {
        String id = entry.getKey();
        return this.graph.getNode(id);
      }
    }
    return null;
  }
  
  private Edge getEdgeUnderMouse(MouseEvent evt) {
      Point2D evtPoint = invert(evt.getPoint());
      Collection<Edge> edges = new ArrayList<>(graph.getNodesOverlappedEdges(this.idleNodes));
      
      for (Edge edge : edges) {
        if (isNearEdge(edge, evtPoint))
          return edge;
      }
      return null;
  }
  
  private boolean isNearEdge(Edge edge, Point2D p) {
      Node n1 = renderContext.getGraph().getNode(edge.getSource());
      Node n2 = renderContext.getGraph().getNode(edge.getTarget());
      double x1 = n1.getX() + n1.getSize() / 2, x2 = n2.getX() + n2.getSize() / 2;
      double y1 = n1.getY() + n1.getSize() / 2, y2 = n2.getY() + n2.getSize() / 2;
      
      double d = 5;
      
      if(x1 < x2 && (p.getX() < x1 - d || p.getX() > x2 + d))
          return false;
      if(x1 > x2 && (p.getX() > x1 + d || p.getX() < x2 - d))
          return false;
      if(y1 < y2 && (p.getY() < y1 - d || p.getY() > y2 + d))
          return false;
      if(y1 > y2 && (p.getY() > y1 + d || p.getY() < y2 - d))
          return false;
      
      double num = Math.abs((y2 - y1) * p.getX() - (x2 - x1) * p.getY() + x2 * y1 - y2 * x1);
      double div = Math.sqrt(Math.pow((y2 - y1), 2) + Math.pow(x2 - x1, 2));
      double dist = num / div;
      if(dist < d)
          return true;
      else
          return false;
  }

  private void applyCurrentSelection(MouseEvent e) {
    Set<String> prevSelectedEdges = new HashSet<>(selectedEdges);
    if (!e.isControlDown() && !e.isShiftDown()) {
      this.selectedNodes.clear();
      this.selectedEdges.clear();
    }
    for (Entry<String, NodeBoundingBox> entry : boxesIndex.entrySet()) {
      NodeBoundingBox box = entry.getValue();
      if (box.intersects(selectionBox)) {
        String id = entry.getKey();
        this.selectedNodes.add(id);
      }
    }
    if(selectedNodes.size() > 0) {
        return;
    }
    Collection<Edge> overlappedEdges = new ArrayList<>(graph.getNodesOverlappedEdges(graph.getNodeIds()));
    Collection<Edge> edgesSelected = new HashSet<>();
    for(Edge edge : overlappedEdges) {
        if(getEdgeShape(edge).intersects(selectionBox)) {
            selectedEdges.add(edge.getId());
            edgesSelected.add(edge);
        }
    }
    if(prevSelectedEdges.size() != selectedEdges.size()) {
        notifyEdgesSelected(edgesSelected, e);
    }else {
        for(String id : selectedEdges) {
            if(!prevSelectedEdges.contains(id)) {
                notifyEdgesSelected(edgesSelected, e);
                break;
            }
        }
    }
  }
  
  private Shape getEdgeShape(Edge edge) {
      Node n1 = this.graph.getNode(edge.getSource());
      Node n2 = this.graph.getNode(edge.getTarget());
      Line2D shape = new Line2D.Double(n1.getX() + n1.getSize() / 2, n1.getY() + n1.getSize() / 2, 
              n2.getX() + n2.getSize() / 2, n2.getY() + n2.getSize() / 2);
      return shape;
  }

  @Override
  public void mousePressed(MouseEvent e) {
    if (this.isEnabled()) {
      this.nodeUnderMouse = getNodeUnderMouse(e);
      if (this.nodeUnderMouse != null) {
        notifyNodePressed(this.nodeUnderMouse, e);
      }
    }
  }

  @Override
  public void mouseReleased(MouseEvent e) {
    if (this.isEnabled()) {
      stopDrag(e);
      this.nodeUnderMouse = getNodeUnderMouse(e);
      if (this.nodeUnderMouse != null) {
        notifyNodeReleased(this.nodeUnderMouse, e);
      }
      repaint();
    }
  }

  @Override
  public void mouseEntered(MouseEvent e) {

  }

  @Override
  public void mouseExited(MouseEvent e) {
    if (this.isEnabled()) {
      stopDrag(e);
      repaint();
    }
  }

  protected Point2D getCenter() {

    Dimension size = getSize();
    double widthOffset = size.width / 2d;
    double heightOffset = size.height / 2d;

    double zoom = getZoom();
    double x = getTranslateX() + widthOffset / zoom;
    double y = getTranslateY() + heightOffset / zoom;

    return new Point2D.Double(x, y);
  }

  @Override
  public void mouseWheelMoved(MouseWheelEvent e) {
    if (this.isEnabled()) {
      int notches = -1 * e.getWheelRotation();
      double zoom = getZoom();
      double newZoom = zoom + (scale * notches);
      newZoom = Math.min(newZoom, MAX_ZOOM);
      newZoom = Math.max(newZoom, MIN_ZOOM);

      if (zoom != newZoom) {
        setZoom(newZoom, e.getPoint());
        repaint();
      }
    }
  }

  public boolean isMouseWheelZoomEnabled() {
    return mouseWheelZoomEnabled;
  }

  public void setMouseWheelZoomEnabled(boolean mouseWheelZoomEnabled) {
    this.mouseWheelZoomEnabled = mouseWheelZoomEnabled;
    if (!mouseWheelZoomEnabled) {
      this.removeMouseWheelListener(this);
    }
  }

  public double getZoom() {
    return transform.getScaleX();
  }
  
  public void setZoom(double zoom) {
      setZoom(zoom, null);
  }

  public void setZoom(double zoom, Point evtPoint) {
    zoom = Math.min(zoom, MAX_ZOOM);
    zoom = Math.max(zoom, MIN_ZOOM);
    setGraphZoom(zoom, evtPoint);
  }
  
  protected void setGraphZoom(double zoom) {
      setGraphZoom(zoom, null);
  }

  protected void setGraphZoom(double zoom, Point evtPoint) {
    double oldZoom = getZoom();

    double translateX = this.getTranslateX();
    double translateY = this.getTranslateY();
    
    Point2D invPoint = null;
    if(evtPoint != null)
        invPoint = invert(evtPoint);

    this.transform.setToScale(zoom, zoom);
    this.transform.translate(translateX / oldZoom, translateY / oldZoom);
    
    try {
      this.inverseTransform = this.transform.createInverse();
    } catch (NoninvertibleTransformException e) {
      throw new RuntimeException(e);
    }
    
    notifyZoomChanged();
    resetBuffer();
    
    if(invPoint != null) {
        double widthOffset = getSize().width / 2d;
        double heightOffset = getSize().height / 2d;
        
        double dx = (evtPoint.getX() - widthOffset) / zoom;
        double dy = (evtPoint.getY() - heightOffset) / zoom;
        
        centerStageAt(invPoint.getX() - dx, invPoint.getY() - dy);
    }
    
  }

  @Override
  public void mouseDragged(MouseEvent evt) {
    if (this.isEnabled()) {
      if (!isDragging) {
        startDrag(evt);
      }
      if (nodeUnderMouse != null) {
        if (this.nodeDragMode == NodeDragMode.CURRENT) {
          dragNode(evt);
        } else if (this.nodeDragMode == NodeDragMode.SELECTION) {
          dragSelectedNodes(evt);
        }
        repaint();
      } else if (this.stageMode == StageMode.PAN) {
        dragStage(evt);
        repaint();
      } else if (this.stageMode == StageMode.SELECTION) {
        updateSelection(evt);
        repaint();
      }
    }
  }

  private void updateSelection(MouseEvent evt) {
    Point2D evtLocation = invert(evt.getPoint());
    double x = Math.min(this.startDragX, evtLocation.getX());
    double y = Math.min(this.startDragY, evtLocation.getY());
    double width = Math.abs(this.startDragX - evtLocation.getX());
    double height = Math.abs(this.startDragY - evtLocation.getY());
    if (selectionBox == null) {
      this.selectionBox = new Rectangle2D.Double(x, y, width, height);
    } else {
      this.selectionBox.x = x;
      this.selectionBox.y = y;
      this.selectionBox.width = width;
      this.selectionBox.height = height;
    }
  }

  private void dragStage(MouseEvent evt) {
    Point2D evtLocation = invert(evt.getPoint());
    double x = evtLocation.getX();
    double y = evtLocation.getY();

    double stageOffsetX = x - this.startDragX;
    double stageOffsetY = y - this.startDragY;

    translateStage(stageOffsetX, stageOffsetY);
  }

  protected void centerStageAt(Point2D point) {
    centerStageAt(point.getX(), point.getY());
  }

  public void centerStageAt(double newCenterX, double newCenterY) {
    double zoom = getZoom();

    newCenterX = newCenterX * zoom;
    newCenterY = newCenterY * zoom;

    Dimension size = getSize();
    double widthOffset = size.width / 2d;
    double heightOffset = size.height / 2d;

    double newX = widthOffset - newCenterX - getTranslateX();
    double newY = heightOffset - newCenterY - getTranslateY();

    translateStage(newX / zoom, newY / zoom);
  }

  public void moveStageTo(double x, double y) {
    x = x - getTranslateX();
    y = y - getTranslateY();
    translateStage(x, y);
  }

  public void translateStage(double x, double y) {
    this.transform.translate(x, y);

    try {
      this.inverseTransform = this.transform.createInverse();
    } catch (NoninvertibleTransformException e) {
      throw new RuntimeException(e);
    }
    notifyStageMoved();
    resetBuffer();
  }

  protected double getTranslateX() {
    return this.transform.getTranslateX();
  }

  protected double getTranslateY() {
    return this.transform.getTranslateY();
  }

  public void toOrigin() {
    moveStageTo(0, 0);
  }

  private void dragSelectedNodes(MouseEvent evt) {
    int oldX = this.nodeUnderMouse.getX();
    int oldY = this.nodeUnderMouse.getY();
    dragNode(evt);

    Set<String> selected = new HashSet<>(this.selectedNodes);
    selected.remove(this.nodeUnderMouse.getId());
    Set<Node> nodes = this.graph.getNodes(selected);

    int offsetX = this.nodeUnderMouse.getX() - oldX;
    int offsetY = this.nodeUnderMouse.getY() - oldY;
    for (Node node : nodes) {
      int x = node.getX() + offsetX;
      int y = node.getY() + offsetY;

      node.setX(x);
      node.setY(y);

    }
    nodes.add(nodeUnderMouse);
    notifyNodeDragged(nodes, evt);
  }

  private void dragNode(MouseEvent evt) {
    Point2D evtLocation = invert(evt.getPoint());
    int x = (int) (evtLocation.getX() - this.nodeDragOffsetX);
    int y = (int) (evtLocation.getY() - this.nodeDragOffsetY);

    nodeUnderMouse.setX(x);
    nodeUnderMouse.setY(y);
    notifyNodeDragged(Arrays.asList(this.nodeUnderMouse), evt);
  }

  private void startDrag(MouseEvent e) {
    this.isDragging = true;
    this.nodeUnderMouse = getNodeUnderMouse(e);

    Point2D startDrag = invert(e.getPoint());
    this.startDragX = (int) startDrag.getX();
    this.startDragY = (int) startDrag.getY();

    if (nodeUnderMouse != null) {
      this.nodeDragOffsetX = this.startDragX - nodeUnderMouse.getX();
      this.nodeDragOffsetY = this.startDragY - nodeUnderMouse.getY();

      this.idleNodes.remove(nodeUnderMouse.getId());
      this.liveNodes.add(nodeUnderMouse.getId());
      if (this.nodeDragMode == NodeDragMode.SELECTION) {
        this.liveNodes.addAll(selectedNodes);
        this.idleNodes.removeAll(selectedNodes);

        Set<Node> nodes = this.graph.getNodes(selectedNodes);
        nodes.add(nodeUnderMouse);
        notifyNodeDragStarted(nodes, e);
      } else if (this.nodeDragMode == NodeDragMode.CURRENT) {
        notifyNodeDragStarted(Arrays.asList(this.nodeUnderMouse), e);
      }
      resetBuffer();

    } else {
      notifyStageDragStarted(e);
    }

  }

  private void stopDrag(MouseEvent e) {
    if (this.isDragging) {
      if (this.selectionBox != null && this.stageMode == StageMode.SELECTION) {
        applyCurrentSelection(e);
      }

      if (nodeUnderMouse != null) {
        if (this.nodeDragMode == NodeDragMode.SELECTION) {
          Set<Node> nodes = this.graph.getNodes(selectedNodes);
          nodes.add(nodeUnderMouse);
          notifyNodeDragStopped(nodes, e);
        } else if (this.nodeDragMode == NodeDragMode.CURRENT) {
          notifyNodeDragStopped(Arrays.asList(this.nodeUnderMouse), e);
        }

        this.idleNodes.addAll(this.liveNodes);
        this.liveNodes.clear();
        resetBuffer();
      } else {
        notifyStageDragStopped(e);
      }
      this.isDragging = false;
      this.nodeUnderMouse = null;
      this.selectionBox = null;
    }
  }

  protected Point2D invert(Point original) {
    return this.inverseTransform.transform(original, new Point2D.Double());
  }

  public Shape invert(Shape shape) {
    return this.inverseTransform.createTransformedShape(shape);
  }

  public Shape transform(Shape shape) {
    return this.transform.createTransformedShape(shape);
  }

  public double transform(double distance) {
    return this.transform.getScaleX() * distance;
  }

  @Override
  public void mouseMoved(MouseEvent e) {
    if (isMouseHoverEnabled()) {
      boolean wasHovering = this.nodeUnderMouse != null;
      String oldId = wasHovering ? this.nodeUnderMouse.getId() : null;

      this.nodeUnderMouse = getNodeUnderMouse(e);

      boolean isHovering = this.nodeUnderMouse != null;
      String id = isHovering ? this.nodeUnderMouse.getId() : null;

      Edge oldEdge = this.edgeUnderMouse;
      this.edgeUnderMouse = getEdgeUnderMouse(e);
      
      if (wasHovering && !isHovering) {
        notifyNodeOut(e);
      } else if (!wasHovering && isHovering) {
        notifyNodeHover(getHoveredNode(), e);
      } else if (wasHovering && isHovering && !id.equals(oldId)) {
        notifyNodeOut(e);
        notifyNodeHover(getHoveredNode(), e);
      } else {
          if(oldEdge == null && this.edgeUnderMouse != null) {
              notifyEdgeHover(this.edgeUnderMouse, e);
          }else if(oldEdge != null && this.edgeUnderMouse == null) {
              notifyEdgeOut(oldEdge, e);
          }else if(oldEdge != null && this.edgeUnderMouse != null && !oldEdge.equals(this.edgeUnderMouse)) {
              notifyEdgeOut(oldEdge, e);
              notifyEdgeHover(this.edgeUnderMouse, e);
          }
      }
      repaint();
    }
  }

  public boolean isShowBoundingBoxes() {
    return showBoundingBoxes;
  }

  public void setShowBoundingBoxes(boolean showBoundingBoxes) {
    this.showBoundingBoxes = showBoundingBoxes;
  }

  public Set<String> getSelected() {
    return selectedNodes;
  }

  public boolean isNodeUnderMouse(Node node) {
    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());
  }

  public boolean isNodeSelected(Node node) {
    return this.selectedNodes.contains(node.getId());
  }
  
  public boolean isEdgeSelected(Edge edge) {
      return this.selectedEdges.contains(edge.getId());
  }

  public Set<Node> getSelectedNodes() {
    return this.graph.getNodes(this.selectedNodes);
  }

  public void removeNode(String id) {
    Node node = this.graph.getNode(id);
    this.graph.removeNode(node);
    repaint();
  }

  public void removeNodes(Set<String> ids) {
    Set<Node> nodes = this.graph.getNodes(ids);
    this.graph.removeNodes(nodes);
    repaint();
  }

  public void removeSelectedNodes() {
    removeNodes(selectedNodes);
  }

  public void selectNodes(Collection<String> ids, boolean keepSelection) {
    if (!keepSelection) {
      this.selectedNodes.clear();
    }
    boolean modified = !keepSelection;
    for (String id : ids) {
      if (!this.graph.containsNode(id)) {
        throw new IllegalArgumentException("Node " + id + " does not exist.");
      }
      modified = modified | this.selectedNodes.add(id);
    }
    if (modified) {
      repaint();
    }
  }

  public void selectNodes(Collection<String> ids) {
    this.selectNodes(ids, false);
  }

  public void selectNode(String id) {
    this.selectNode(id, false);
  }

  public void selectNode(String id, boolean keepSelection) {
    if (!this.graph.containsNode(id)) {
      throw new IllegalArgumentException("Node " + id + " does not exist.");
    }
    if (!keepSelection) {
      this.selectedNodes.clear();
    }
    if (this.selectedNodes.add(id) | !keepSelection) {
      repaint();
    }
  }

  public void deselectNode(String id) {
    this.selectedNodes.remove(id);
    repaint();
  }
  
  public void selectEdge(String id) {
      selectEdge(id, false);
  }
  
  public void selectEdge(String id, boolean keepSelection) {
      if (!this.graph.containsEdge(id)) {
          //throw new IllegalArgumentException("Edge " + id + " does not exist.");
      }
      if(!keepSelection) {
          this.selectedEdges.clear();    
      }
      
      if(this.selectedEdges.add(id) || !keepSelection) {
          repaint();
      }
  }
  
  public void deselectEdge(String id) {
      this.selectedEdges.remove(id);
      repaint();
  }

  public void deselectAll() {
    this.selectedNodes.clear();
    this.selectedEdges.clear();
    repaint();
  }

  public void selectAll() {
    this.selectedNodes.addAll(this.graph.getNodeIds());
    repaint();
  }

  public void nodesAdded(GraphEvent e) {
    for (Node node : e.getNodes()) {
      this.idleNodes.add(node.getId());
    }
  }

  public void nodesRemoved(GraphEvent e) {
    for (Node node : e.getNodes()) {
      String nodeId = node.getId();
      this.selectedNodes.remove(nodeId);
      this.boxesIndex.remove(nodeId);
      this.liveNodes.remove(nodeId);
      this.idleNodes.remove(nodeId);
    }

  }

  @Override
  public void elementsAdded(GraphEvent e) {
    nodesAdded(e);
    resetBuffer();
  }

  public void elementsRemoved(GraphEvent e) {
    nodesRemoved(e);
    resetBuffer();
  }

  public StageMode getStageMode() {
    return stageMode;
  }

  public void setStageMode(StageMode stageMode) {
    this.stageMode = stageMode;
  }

  public NodeDragMode getNodeDragMode() {
    return nodeDragMode;
  }

  public void setNodeDragMode(NodeDragMode nodeDragMode) {
    this.nodeDragMode = nodeDragMode;
  }

  public void resetBuffer() {
    if (this.idleGraphics != null) {
      this.idleGraphics.dispose();
    }
    this.idleBuffer = null;
    this.idleGraphics = null;
  }

  @Override
  public void componentResized(ComponentEvent e) {
    resetBuffer();
  }

  @Override
  public void componentMoved(ComponentEvent e) {

  }

  @Override
  public void componentShown(ComponentEvent e) {
    resetBuffer();
  }

  @Override
  public void componentHidden(ComponentEvent e) {

  }

  public Node getHoveredNode() {
    return this.nodeUnderMouse;
  }

  public boolean isHovered(Node node) {
    return this.nodeUnderMouse != null && this.nodeUnderMouse.getId().equals(node.getId());
  }

  @Override
  protected void printComponent(Graphics g) {
    this.isPrinting = true;
    resetBuffer();
    super.printComponent(g);
    this.isPrinting = false;
  }

  public boolean isHistoryEnabled() {
    return historyEnabled;
  }

  public void setHistoryEnabled(boolean historyEnabled) {
    this.historyEnabled = historyEnabled;
    if (historyEnabled) {
      this.addNodeListener(history.getMoveRecorder());
      this.graph.addListener(history.getGraphRecorder());
    } else {
      history.clear();
      this.removeNodeListener(history.getMoveRecorder());
      this.graph.removeListener(history.getGraphRecorder());
    }
  }

  public GraphHistory getHistory() {
    return history;
  }

  public Renderers getRenderers() {
    return renderers;
  }

  public Rectangle2D getMinimumBoundingBox() {

    Rectangle2D box = null;
    Set<Node> nodes = graph.getNodes();

    Iterator<Node> iterator = nodes.iterator();
    if (iterator.hasNext()) {

      Node node = iterator.next();
      String type = node.getType();
      NodeRenderer nodeRenderer = renderers.getNodeRenderer(type);
      GraphShape graphShape = nodeRenderer.render(null, node, renderContext);
      box = graphShape.getShape().getBounds2D();

      while (iterator.hasNext()) {
        node = iterator.next();
        type = node.getType();
        nodeRenderer = renderers.getNodeRenderer(type);

        graphShape = nodeRenderer.render(null, node, renderContext);
        Rectangle2D newBox = graphShape.getShape().getBounds2D();

        box = box.createUnion(newBox);

      }
    }

    return box;
  }

  public void reset() {
    toOrigin();
    setZoom(1d);
  }

  public boolean isMouseHoverEnabled() {
    return mouseHoverEnabled;
  }

  public void setMouseHoverEnabled(boolean mouseHoverEnabled) {
    this.mouseHoverEnabled = mouseHoverEnabled;
  }

  public void applyLayout(HistoryEnabledLayout layout) {
    Graphics2D graphics = (Graphics2D) getGraphics();

    AffineTransform oldTransform = graphics.getTransform();
    try {
      graphics.setTransform(new AffineTransform());
      Font font = graphics.getFont();
      FontMetrics fontMetrics = graphics.getFontMetrics(font);
      List<GraphAction> actions = layout.performLayout(this, fontMetrics);
      this.history.add(actions);
    } finally {
      graphics.setTransform(oldTransform);
    }
    resetBuffer();
  }

  public void fitToScreen() {
    fitToScreen(1.1d);
  }

  public void fitToScreen(double gapWeight) {
    Rectangle2D minimumBoundingBox = getMinimumBoundingBox();
    if (minimumBoundingBox != null) {

      double width = minimumBoundingBox.getWidth();
      double height = minimumBoundingBox.getHeight();

      double x = minimumBoundingBox.getX() - width * (gapWeight - 1d) / 2d;
      double y = minimumBoundingBox.getY() - height * (gapWeight - 1d) / 2d;
      width = width * gapWeight;
      height = height * gapWeight;

      fitToScreen(new Rectangle2D.Double(x, y, width, height), MIN_ZOOM, MAX_ZOOM);
    }
  }

  protected void fitToScreen(Rectangle2D minimumBoundingBox) {
    fitToScreen(minimumBoundingBox, 0d, java.lang.Double.MAX_VALUE);
  }

  protected void fitToScreen(Rectangle2D minimumBoundingBox, double minZoom, double maxZoom) {
    Dimension2D size = getSize();

    double graphWidth = minimumBoundingBox.getWidth();
    double previewWidth = size.getWidth();

    double zoomFactorWidth = 0.9d * previewWidth / graphWidth;

    double graphHeight = minimumBoundingBox.getHeight();
    double previewHeight = size.getHeight();

    double zoomFactorHeight = 0.9d * previewHeight / graphHeight;

    double zoom = Math.min(zoomFactorWidth, zoomFactorHeight);

    zoom = Math.min(zoom, maxZoom);
    zoom = Math.max(zoom, minZoom);

    setGraphZoom(zoom);

    double centerX = minimumBoundingBox.getCenterX();
    double centerY = minimumBoundingBox.getCenterY();

    centerStageAt(centerX, centerY);
  }
}
```


Overlapping Code:
```
Pane extends JComponent
implements MouseListener, MouseWheelListener, MouseMotionListener, GraphListener, ComponentListener {
private static final long serialVersionUID = 3827345534868023684L;
private Graph graph;
private Renderers renderers = new Renderers();
private boolean mouseHoverEnabled = true;
private StageMode stageMode = StageMode.PAN;
private NodeDragMode nodeDragMode = NodeDragMode.SELECTION;
private RenderContext renderContext;
private List<NodeListener> nodeListeners = new ArrayList<>();
private List<StageListener> stageListeners = new ArrayList<>();
private List<EdgeListener> edgeListeners = new ArrayList<>();
private boolean historyEnabled = false;
private GraphHistory history;
private boolean showBoundingBoxes = false;
private boolean mouseWheelZoomEnabled = true;
private double scale = 1d / 5d;
private static final double MIN_ZOOM = 1d / 4d;
private static final double MAX_ZOOM = 5d;
private boolean isDragging = false;
private Node nodeUnderMouse = null;
private Edge edgeUnderMouse = null;
protected AffineTransform transform = new AffineTransform();
protected AffineTransform inverseTransform = new AffineTransform();
private int startDragX;
private int startDragY;
private int nodeDragOffsetX;
private int nodeDragOffsetY;
private Set<String> selectedNodes = new HashSet<>();
private Set<String> selectedEdges = new HashSet<>();
private Map<String, NodeBoundingBox> boxesIndex = new HashMap<>();
private Set<String> idleNodes = new HashSet<>();
private Set<String> liveNodes = new HashSet<>();
private Double selectionBox;
private BufferedImage idleBuffer;
private Graphics2D idleGraphics;
private int lastBufferX;
private int lastBufferY;
private boolean isPrinting;
public GraphPane(Graph graph) {
super();
this.graph = graph;
this.history = new GraphHistory(this);
this.renderContext = new RenderContext(this, graph);
this.addMouseWheelListener(this);
this.addMouseMotionListener(this);
this.addMouseListener(this);
this.addComponentListener(this);
this.graph.addListener(this);
this.idleNodes.addAll(this.graph.getNodeIds());
}
@Override
protected void paintComponent(Graphics g) {
Graphics2D g2d = (Graphics2D) g;
paintGraph(g, this.transform, g2d.getClipBounds());
}
private void paintGraph(Graphics g, AffineTransform tx, Rectangle2D clipBounds) {
Graphics2D
```
<Overlap Ratio: 0.9858551221603086>

---

--- 69 --
Question ID: 612b8d4b1754a9a7fe63a33486713d10d2ab1701
Original Code:
```
public class CustomProcessor implements ProcedureResultProcessor {
  private ProcedureProcessorContext context;
  
  @Override
  public void close() {
    this.context = null;
  }

  @Override
  public List<Object> getNextResultRow(int resultSetNumber)
      throws InterruptedException {
    if (resultSetNumber == 1) return test(1);
    else return test(resultSetNumber);
  }

  @Override
  public Object[] getOutParameters() throws InterruptedException {
    // TODO Auto-generated method stub
    return null;
  }

  @Override
  public void init(ProcedureProcessorContext context) {
    this.context = context;
  }
  
  private List<Object> test(int num) throws InterruptedException{
    //Log.getLogWriter().info("in custom processor");
    System.out.println("in custom processor");
    IncomingResultSet[] inSets = context.getIncomingResultSets(num);
    //Log.getLogWriter().info("custom process result");
    if (inSets.length != SQLTest.numOfStores) {
      throw new TestException("does not get results set from all the nodes");
    }
    for (IncomingResultSet inSet : inSets) {
      
      List<Object> nextRow = inSet.waitPeekRow();
      if (nextRow == IncomingResultSet.END_OF_RESULTS) continue;
      
      List<Object> takeRow = inSet.takeRow();
      for (Object o: takeRow) {
        //Log.getLogWriter().info(o + ",");
        System.out.println(o + ",");
      }
      return takeRow;
    }
    return null;
  }

}
```


Overlapping Code:
```
 ProcedureResultProcessor {
private ProcedureProcessorContext context;

@Override
public void close() {
this.context = null;
}
@Override
public List<Object> getNextResultRow(int resultSetNumber)
throws InterruptedException {
if (resultSetNumber == 1) return test(1);
else return test(resultSetNumber);
}
@Override
public Object[] getOutParameters() throws InterruptedException {
// TODO Auto-generated method stub
return null;
}
@Override
public void init(ProcedureProcessorContext context) {
this.context = context;
}

private List<Object> test(int num) throws InterruptedException{
//Log.getLogWriter().info("in custom processor");
System.out.println("in custom processor");
IncomingResultSet[] inSets = context.getIncomingResultSets(num);
//Log.getLogWriter().info("custom process result");
if (inSets.length != SQLTest.numOfStores) {
throw new TestException("does not get results set from all the nodes");
}
for (IncomingResultSet inSet : inSets) {

List<Object> nextRow = inSet.waitPeekRow();
if (nextRow == IncomingResultSet.END_OF_RESULTS) continue;

List<Object> takeRow = inSet.takeRow();
for (Object o: takeRow) {
//Log.getLogWriter().info(o + ",");
System.out.println(o + ",");
}
return ta
```
<Overlap Ratio: 0.9493670886075949>

---

--- 70 --
Question ID: f81709dc48a9db40884f3f6849eae3e428b9a913
Original Code:
```
public class MapFragmentActivity extends AppCompatActivity implements MapFragment.OnMapViewReadyCallback,
  OnMapReadyCallback, MapView.OnDidFinishRenderingFrameListener {

  private static final String TAG = "com.mapbox.map";
  private MapboxMap mapboxMap;
  private MapView mapView;
  private boolean initialCameraAnimation = true;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_map_fragment);

    MapFragment mapFragment;
    if (savedInstanceState == null) {
      mapFragment = MapFragment.newInstance(createFragmentOptions());
      getFragmentManager()
        .beginTransaction()
        .add(R.id.fragment_container, mapFragment, TAG)
        .commit();
    } else {
      mapFragment = (MapFragment) getFragmentManager().findFragmentByTag(TAG);
    }
    mapFragment.getMapAsync(this);
  }

  private MapboxMapOptions createFragmentOptions() {
    MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null);

    options.scrollGesturesEnabled(false);
    options.zoomGesturesEnabled(false);
    options.tiltGesturesEnabled(false);
    options.rotateGesturesEnabled(false);
    options.debugActive(false);

    LatLng dc = new LatLng(38.90252, -77.02291);

    options.minZoomPreference(9);
    options.maxZoomPreference(11);
    options.camera(new CameraPosition.Builder()
      .target(dc)
      .zoom(11)
      .build());
    return options;
  }

  @Override
  public void onMapViewReady(MapView map) {
    mapView = map;
    mapView.addOnDidFinishRenderingFrameListener(this);
  }

  @Override
  public void onMapReady(@NonNull MapboxMap map) {
    mapboxMap = map;
    mapboxMap.setStyle(Style.OUTDOORS);
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    if (mapView != null) {
      mapView.removeOnDidFinishRenderingFrameListener(this);
    }
  }

  @Override
  public void onDidFinishRenderingFrame(boolean fully) {
    if (initialCameraAnimation && fully && mapboxMap != null) {
      mapboxMap.animateCamera(
        CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder().tilt(45.0).build()), 5000);
      initialCameraAnimation = false;
    }
  }
}
```


Overlapping Code:
```
class MapFragmentActivity extends AppCompatActivity implements MapFragment.OnMapViewReadyCallback,
OnMapReadyCallback, MapView.OnDidFinishRenderingFrameListener {
private static final String TAG = "com.mapbox.map";
private MapboxMap mapboxMap;
private MapView mapView;
private boolean initialCameraAnimation = true;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_map_fragment);
MapFragment mapFragment;
if (savedInstanceState == null) {
mapFragment = MapFragment.newInstance(createFragmentOptions());
getFragmentManager()
.beginTransaction()
.add(R.id.fragment_container, mapFragment, TAG)
.commit();
} else {
mapFragment = (MapFragment) getFragmentManager().findFragmentByTag(TAG);
}
mapFragment.getMapAsync(this);
}
private MapboxMapOptions createFragmentOptions() {
MapboxMapOptions options = MapboxMapOptions.createFromAttributes(this, null);
options.scrollGesturesEnabled(false);
options.zoomGesturesEnabled(false);
options.tiltGesturesEnabled(false);
options.rotateGesturesEnabled(false);
options.debugActive(false);
LatLng dc = new LatLng(38.90252, -77.02291);
options.minZoomPreference(9);
options.maxZoomPreference(11);
options.camera(new CameraPosition.Builder()
.target(dc)
.zoom(11)
.build());
return options;
}
@Override
public void onMapViewReady(MapView map) {
mapView = map;
mapView.addOnDidFinishRenderingFrameListener(this);
}
@Override
public void onMapReady(@NonNull MapboxMap map) {
mapboxMap = map;
mapboxMap.setStyle(Style.OUTDOORS);
}
@Override
protected void onDestroy() {
super.onDestroy();
if (mapView != null) {
mapView.removeOnDidFinishRenderingFrameListener(this);
}
}
@Override
public void onDidFinishRenderingFrame(boolean fully) {
if (initialCameraAnimation && fully && mapboxMap != null) {
mapboxMap.animateCamera(
CameraUpdateFactory.newCameraPosition(new CameraPosition.Builder().tilt(45.0).build()), 5000);
initialCameraAnimation = false;
}

```
<Overlap Ratio: 0.994931576279777>

---

--- 71 --
Question ID: 7d76c12ede26efc84372403866f00634c05d1f5f
Original Code:
```
public class ApiErrorFactory 
{
	//COMMON
	public static final int ERROR_UNKNOWN = 0;
	public static final int ERROR_JSON = 1;
	public static final int ERROR_NO_BALANCE = 2;
	public static final int ERROR_NOT_YET_RELEASED = 3;
	
	//VALIDATION
	public static final int ERROR_INVALID_SIGNATURE = 101;
	public static final int ERROR_INVALID_ADDRESS = 102;
	public static final int ERROR_INVALID_SEED = 103;
	public static final int ERROR_INVALID_AMOUNT = 104;
	public static final int ERROR_INVALID_FEE = 105;
	public static final int ERROR_INVALID_SENDER = 106;
	public static final int ERROR_INVALID_RECIPIENT = 107;
	public static final int ERROR_INVALID_NAME_LENGTH = 108;
	public static final int ERROR_INVALID_VALUE_LENGTH = 109;
	public static final int ERROR_INVALID_NAME_OWNER = 110;
	public static final int ERROR_INVALID_BUYER = 111;
	public static final int ERROR_INVALID_PUBLIC_KEY = 112;
	public static final int ERROR_INVALID_OPTIONS_LENGTH = 113;
	public static final int ERROR_INVALID_OPTION_LENGTH = 114;
	public static final int ERROR_INVALID_DATA = 115;
	public static final int ERROR_INVALID_DATA_LENGTH = 116;
	public static final int ERROR_INVALID_UPDATE_VALUE = 117;
	public static final int ERROR_KEY_ALREADY_EXISTS = 118;
	public static final int ERROR_KEY_NOT_EXISTS = 119;
	public static final int ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR = 120;
	public static final int ERROR_FEE_LESS_REQUIRED = 121;
	public static final int ERROR_WALLET_NOT_IN_SYNC = 122;
	public static final int ERROR_INVALID_NETWORK_ADDRESS = 123;
	
	//WALLET
	public static final int ERROR_WALLET_NO_EXISTS = 201;
	public static final int ERROR_WALLET_ADDRESS_NO_EXISTS = 202;
	public static final int ERROR_WALLET_LOCKED = 203;
	public static final int ERROR_WALLET_ALREADY_EXISTS = 204;
	public static final int ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER = 205;
	
	//BLOCKS
	public static final int ERROR_BLOCK_NO_EXISTS = 301;
	
	//TRANSACTIONS
	public static final int ERROR_TRANSACTION_NO_EXISTS = 311;
	public static final int ERROR_PUBLIC_KEY_NOT_FOUND = 304;	
		
	//NAMING
	public static final int ERROR_NAME_NO_EXISTS = 401;
	public static final int ERROR_NAME_ALREADY_EXISTS = 402;
	public static final int ERROR_NAME_ALREADY_FOR_SALE = 403;
	public static final int ERROR_NAME_NOT_LOWER_CASE = 404;
	public static final int ERROR_NAME_SALE_NO_EXISTS = 410;
	public static final int ERROR_BUYER_ALREADY_OWNER = 411;
	
	//POLLS
	public static final int ERROR_POLL_NO_EXISTS = 501;
	public static final int ERROR_POLL_ALREADY_EXISTS = 502;
	public static final int ERROR_DUPLICATE_OPTION = 503;
	public static final int ERROR_POLL_OPTION_NO_EXISTS = 504;
	public static final int ERROR_ALREADY_VOTED_FOR_THAT_OPTION = 505;
	
	//ASSET
	public static final int ERROR_INVALID_ASSET_ID = 601;
	
	//NAME PAYMENTS
	public static final int ERROR_NAME_NOT_REGISTERED = 701;
	public static final int ERROR_NAME_FOR_SALE = 702;
	public static final int ERROR_NAME_WITH_SPACE = 703;
	
	//ATs
	public static final int ERROR_INVALID_DESC_LENGTH = 801;
	public static final int ERROR_EMPTY_CODE = 802;
	public static final int ERROR_DATA_SIZE = 803;
	public static final int ERROR_NULL_PAGES = 804;
	public static final int ERROR_INVALID_TYPE_LENGTH = 805;
	public static final int ERROR_INVALID_TAGS_LENGTH = 806;
	public static final int ERROR_INVALID_CREATION_BYTES = 809;
	
	//BLOG/Namestorage
	public static final int ERROR_BODY_EMPTY = 901;
	public static final int ERROR_BLOG_DISABLED = 902;
	public static final int ERROR_NAME_NOT_OWNER = 903;
	public static final int ERROR_TX_AMOUNT = 904;
	public static final int ERROR_BLOG_ENTRY_NO_EXISTS = 905;
	public static final int ERROR_BLOG_EMPTY = 906;
	public static final int ERROR_POSTID_EMPTY = 907;
	public static final int ERROR_POST_NOT_EXISTING = 908;
	public static final int ERROR_COMMENTING_DISABLED = 909;
	public static final int ERROR_COMMENT_NOT_EXISTING = 910;
	public static final int ERROR_INVALID_COMMENT_OWNER = 911;
	
	//Messages
	public static final int ERROR_MESSAGE_FORMAT_NOT_HEX = 1001;
	public static final int ERROR_MESSAGE_BLANK = 1002;
	public static final int ERROR_NO_PUBLIC_KEY = 1003;
	public static final int ERROR_MESSAGESIZE_EXCEEDED = 1004;

	
	public static int BATCH_TX_AMOUNT = 50;
	
	
	private static ApiErrorFactory  instance;
	
	public static ApiErrorFactory  getInstance()
	{
		if(instance == null)
		{
			instance = new ApiErrorFactory();
		}
		
		return instance;
	}
	
	private Map<Integer, String> errorMessages;
	
	public ApiErrorFactory()
	{
		this.errorMessages = new HashMap<Integer, String>();
		
		//COMMON
		this.errorMessages.put(ERROR_UNKNOWN, Lang.getInstance().translate("unknown error"));
		this.errorMessages.put(ERROR_JSON, Lang.getInstance().translate("failed to parse json message"));
		this.errorMessages.put(ERROR_NO_BALANCE, Lang.getInstance().translate("not enough balance"));
		this.errorMessages.put(ERROR_NOT_YET_RELEASED, Lang.getInstance().translate("that feature is not yet released"));
		
		//VALIDATION		
		this.errorMessages.put(ERROR_INVALID_SIGNATURE, Lang.getInstance().translate("invalid signature"));
		this.errorMessages.put(ERROR_INVALID_ADDRESS, Lang.getInstance().translate("invalid address"));
		this.errorMessages.put(ERROR_INVALID_SEED, Lang.getInstance().translate("invalid seed"));
		this.errorMessages.put(ERROR_INVALID_AMOUNT, Lang.getInstance().translate("invalid amount"));
		this.errorMessages.put(ERROR_INVALID_FEE, Lang.getInstance().translate("invalid fee"));
		this.errorMessages.put(ERROR_INVALID_SENDER, Lang.getInstance().translate("invalid sender"));
		this.errorMessages.put(ERROR_INVALID_RECIPIENT, Lang.getInstance().translate("invalid recipient"));
		this.errorMessages.put(ERROR_INVALID_NAME_LENGTH, Lang.getInstance().translate("invalid name length"));
		this.errorMessages.put(ERROR_INVALID_VALUE_LENGTH, Lang.getInstance().translate("invalid value length"));
		this.errorMessages.put(ERROR_INVALID_NAME_OWNER, Lang.getInstance().translate("invalid name owner"));
		this.errorMessages.put(ERROR_INVALID_BUYER, Lang.getInstance().translate("invalid buyer"));
		this.errorMessages.put(ERROR_INVALID_PUBLIC_KEY, Lang.getInstance().translate("invalid public key"));
		this.errorMessages.put(ERROR_INVALID_OPTIONS_LENGTH, Lang.getInstance().translate("invalid options length"));
		this.errorMessages.put(ERROR_INVALID_OPTION_LENGTH, Lang.getInstance().translate("invalid option length"));
		this.errorMessages.put(ERROR_INVALID_DATA, Lang.getInstance().translate("invalid data"));
		this.errorMessages.put(ERROR_INVALID_DATA_LENGTH, Lang.getInstance().translate("invalid data length"));
		this.errorMessages.put(ERROR_INVALID_UPDATE_VALUE, Lang.getInstance().translate("invalid update value"));
		this.errorMessages.put(ERROR_KEY_ALREADY_EXISTS, Lang.getInstance().translate("key already exists, edit is false"));
		this.errorMessages.put(ERROR_KEY_NOT_EXISTS, Lang.getInstance().translate("the key does not exist"));
		this.errorMessages.put(ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR, Lang.getInstance().translate(("you can't delete the key \"%key%\" if it is the only key")).replace("%key%", Qorakeys.DEFAULT.toString()));
		this.errorMessages.put(ERROR_FEE_LESS_REQUIRED, Lang.getInstance().translate("fee less required"));
		this.errorMessages.put(ERROR_WALLET_NOT_IN_SYNC, Lang.getInstance().translate("wallet needs to be synchronized"));
		this.errorMessages.put(ERROR_INVALID_NETWORK_ADDRESS, Lang.getInstance().translate("invalid network address"));
				
		//WALLET
		this.errorMessages.put(ERROR_WALLET_NO_EXISTS, Lang.getInstance().translate("wallet does not exist"));
		this.errorMessages.put(ERROR_WALLET_ADDRESS_NO_EXISTS, Lang.getInstance().translate("address does not exist in wallet"));
		this.errorMessages.put(ERROR_WALLET_LOCKED, Lang.getInstance().translate("wallet is locked"));
		this.errorMessages.put(ERROR_WALLET_ALREADY_EXISTS, Lang.getInstance().translate("wallet already exists"));
		this.errorMessages.put(ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER, Lang.getInstance().translate("user denied api call"));
		
		//BLOCK
		this.errorMessages.put(ERROR_BLOCK_NO_EXISTS, Lang.getInstance().translate("block does not exist"));
		
		//TRANSACTIONS
		this.errorMessages.put(ERROR_TRANSACTION_NO_EXISTS, Lang.getInstance().translate("transactions does not exist"));
		this.errorMessages.put(ERROR_PUBLIC_KEY_NOT_FOUND, Lang.getInstance().translate("public key not found"));
		
		//NAMING
		this.errorMessages.put(ERROR_NAME_NO_EXISTS, Lang.getInstance().translate("name does not exist"));
		this.errorMessages.put(ERROR_NAME_ALREADY_EXISTS, Lang.getInstance().translate("name already exists"));
		this.errorMessages.put(ERROR_NAME_ALREADY_FOR_SALE, Lang.getInstance().translate("name already for sale"));
		this.errorMessages.put(ERROR_NAME_NOT_LOWER_CASE, Lang.getInstance().translate("name must be lower case"));
		this.errorMessages.put(ERROR_NAME_SALE_NO_EXISTS, Lang.getInstance().translate("namesale does not exist"));
		this.errorMessages.put(ERROR_BUYER_ALREADY_OWNER, Lang.getInstance().translate("buyer is already owner"));
		
		//POLLS
		this.errorMessages.put(ERROR_POLL_NO_EXISTS, Lang.getInstance().translate("poll does not exist"));
		this.errorMessages.put(ERROR_POLL_ALREADY_EXISTS, Lang.getInstance().translate("poll already exists"));
		this.errorMessages.put(ERROR_DUPLICATE_OPTION, Lang.getInstance().translate("not all options are unique"));
		this.errorMessages.put(ERROR_POLL_OPTION_NO_EXISTS, Lang.getInstance().translate("option does not exist"));
		this.errorMessages.put(ERROR_ALREADY_VOTED_FOR_THAT_OPTION, Lang.getInstance().translate("already voted for that option"));
		
		//ASSETS
		this.errorMessages.put(ERROR_INVALID_ASSET_ID, Lang.getInstance().translate("invalid asset id"));
		
		//NAME PAYMENTS
		this.errorMessages.put(ERROR_NAME_NOT_REGISTERED, Lang.getInstance().translate(NameResult.NAME_NOT_REGISTERED.getStatusMessage()));
		this.errorMessages.put(ERROR_NAME_FOR_SALE, Lang.getInstance().translate(NameResult.NAME_FOR_SALE.getStatusMessage()));
		this.errorMessages.put(ERROR_NAME_WITH_SPACE, Lang.getInstance().translate(NameResult.NAME_WITH_SPACE.getStatusMessage()));
		
		//AT
		this.errorMessages.put(ERROR_INVALID_CREATION_BYTES, Lang.getInstance().translate("error in creation bytes"));
		this.errorMessages.put(ERROR_INVALID_DESC_LENGTH, Lang.getInstance().translate("invalid description length. max length ") + AT_Constants.DESC_MAX_LENGTH);
		this.errorMessages.put(ERROR_EMPTY_CODE, Lang.getInstance().translate("code is empty"));
		this.errorMessages.put(ERROR_DATA_SIZE, Lang.getInstance().translate("invalid data length"));
		this.errorMessages.put(ERROR_INVALID_TYPE_LENGTH, Lang.getInstance().translate("invalid type length"));
		this.errorMessages.put(ERROR_INVALID_TAGS_LENGTH, Lang.getInstance().translate("invalid tags length"));
		this.errorMessages.put(ERROR_NULL_PAGES, Lang.getInstance().translate("invalid pages"));
		
		//BLOG
		this.errorMessages.put(ERROR_BODY_EMPTY, Lang.getInstance().translate("invalid body it must not be empty"));
		this.errorMessages.put(ERROR_BLOG_DISABLED, Lang.getInstance().translate("this blog is disabled"));
		this.errorMessages.put(ERROR_NAME_NOT_OWNER, Lang.getInstance().translate("the creator address does not own the author name"));
		this.errorMessages.put(ERROR_TX_AMOUNT, Lang.getInstance().translate("the data size is too large - currently only %BATCH_TX_AMOUNT% arbitrary transactions are allowed at once!").replace("%BATCH_TX_AMOUNT%", String.valueOf(BATCH_TX_AMOUNT)));
		this.errorMessages.put(ERROR_BLOG_ENTRY_NO_EXISTS, Lang.getInstance().translate("transaction with this signature contains no entries!"));
		this.errorMessages.put(ERROR_BLOG_EMPTY, Lang.getInstance().translate("this blog is empty"));
		this.errorMessages.put(ERROR_POSTID_EMPTY, Lang.getInstance().translate("the attribute postid is empty! this is the signature of the post you want to comment"));
		this.errorMessages.put(ERROR_POST_NOT_EXISTING, Lang.getInstance().translate("for the given postid no blogpost to comment was found"));
		this.errorMessages.put(ERROR_COMMENTING_DISABLED, Lang.getInstance().translate("commenting is for this blog disabled"));
		this.errorMessages.put(ERROR_COMMENT_NOT_EXISTING, Lang.getInstance().translate("for the given signature no comment was found"));
		this.errorMessages.put(ERROR_INVALID_COMMENT_OWNER, Lang.getInstance().translate("invalid comment owner"));
		
		
		//MESSAGES
		this.errorMessages.put(ERROR_MESSAGE_FORMAT_NOT_HEX, Lang.getInstance().translate("the Message format is not hex - correct the text or use isTextMessage = true"));
		this.errorMessages.put(ERROR_MESSAGE_BLANK, Lang.getInstance().translate("The message attribute is missing or content is blank"));
		this.errorMessages.put(ERROR_NO_PUBLIC_KEY, Lang.getInstance().translate("The recipient has not yet performed any action in the blockchain.\nYou can't send an encrypted message to him."));
		this.errorMessages.put(ERROR_MESSAGESIZE_EXCEEDED, Lang.getInstance().translate("Message size exceeded!"));

	}
	
	
	@SuppressWarnings("unchecked")
	public WebApplicationException createError(int error)
	{

		JSONObject jsonObject = new JSONObject();
		jsonObject.put("error", error);
		if ( error > Transaction.AT_ERROR )
		{
			jsonObject.put("message", AT_Error.getATError(error - Transaction.AT_ERROR) );
		}
		else
		{
			jsonObject.put("message", this.errorMessages.get(error));
		}
		
		
		return new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(jsonObject.toJSONString()).build());
	}
}
```


Overlapping Code:
```
s ApiErrorFactory 
{
//COMMON
public static final int ERROR_UNKNOWN = 0;
public static final int ERROR_JSON = 1;
public static final int ERROR_NO_BALANCE = 2;
public static final int ERROR_NOT_YET_RELEASED = 3;

//VALIDATION
public static final int ERROR_INVALID_SIGNATURE = 101;
public static final int ERROR_INVALID_ADDRESS = 102;
public static final int ERROR_INVALID_SEED = 103;
public static final int ERROR_INVALID_AMOUNT = 104;
public static final int ERROR_INVALID_FEE = 105;
public static final int ERROR_INVALID_SENDER = 106;
public static final int ERROR_INVALID_RECIPIENT = 107;
public static final int ERROR_INVALID_NAME_LENGTH = 108;
public static final int ERROR_INVALID_VALUE_LENGTH = 109;
public static final int ERROR_INVALID_NAME_OWNER = 110;
public static final int ERROR_INVALID_BUYER = 111;
public static final int ERROR_INVALID_PUBLIC_KEY = 112;
public static final int ERROR_INVALID_OPTIONS_LENGTH = 113;
public static final int ERROR_INVALID_OPTION_LENGTH = 114;
public static final int ERROR_INVALID_DATA = 115;
public static final int ERROR_INVALID_DATA_LENGTH = 116;
public static final int ERROR_INVALID_UPDATE_VALUE = 117;
public static final int ERROR_KEY_ALREADY_EXISTS = 118;
public static final int ERROR_KEY_NOT_EXISTS = 119;
public static final int ERROR_LAST_KEY_IS_DEFAULT_KEY_ERROR = 120;
public static final int ERROR_FEE_LESS_REQUIRED = 121;
public static final int ERROR_WALLET_NOT_IN_SYNC = 122;
public static final int ERROR_INVALID_NETWORK_ADDRESS = 123;

//WALLET
public static final int ERROR_WALLET_NO_EXISTS = 201;
public static final int ERROR_WALLET_ADDRESS_NO_EXISTS = 202;
public static final int ERROR_WALLET_LOCKED = 203;
public static final int ERROR_WALLET_ALREADY_EXISTS = 204;
public static final int ERROR_WALLET_API_CALL_FORBIDDEN_BY_USER = 205;

//BLOCKS
public static final int ERROR_BLOCK_NO_EXISTS = 301;

//TRANSACTIONS
public static final int ERROR_TRANSACTION_NO_EXISTS = 311;
public static final int ERROR_PUBLIC_KEY_NOT_FOUND = 304; 

//NAMING
public static final int ERROR_NAME_NO_EXISTS = 401;
public static final int ERROR_NAME_ALREADY_EXISTS = 402;
public static final int ERROR_NAME_ALREADY_FOR_SALE = 403;
public static final int ERROR_NAME_NOT_LOWER_CASE = 404;
public static final int ERROR_NAME_SALE_NO_EXISTS = 410;
public static final int ERROR_BUYER_ALREADY_OWNER = 411;

//POLLS
public static final int ERROR_POLL_NO_EXISTS =
```
<Overlap Ratio: 0.9860769860769861>

---

--- 72 --
Question ID: 1f6176b4de0b77eb779b265547630c5e00991260
Original Code:
```
public class AnswerCommand extends Command<QuizModel> {

    public static final String COMMAND_WORD = "ans:";
    public static final int STARTING_INDEX_OF_ANSWER = 4;
    public static final Status STATUS = Status.ON_QUESTION;

    private final String answer;

    public AnswerCommand(String answer) {
        this.answer = answer;
    }

    @Override
    public CommandResult execute(QuizModel model) throws CommandException {
        requireNonNull(model);

        if (!model.hasStarted()) {
            throw new CommandException(QuizCommandUtil.MESSAGE_QUIZ_NEVER_STARTED);
        }

        if (!QuizCommandUtil.getStatus().equals(STATUS)) {
            throw new CommandException(QuizCommandUtil.MESSAGE_UNAVAIL_ON_ANSWER);
        }

        model.saveAnswer(answer);
        QuizCard.setQuestion(model.getQuestion());
        String userAnswerToShow = "Your answer: " + answer + "\n\n";
        Answer answer = model.getAnswer();

        QuizCommandUtil.setStatus(Status.ON_ANSWER);

        String answerStringToShow = userAnswerToShow + "\nCorrect answer: " + answer.toString()
                + QuizCommandUtil.SPECIAL_LITERAL
                + QuizCommandUtil.MESSAGE_AVAIL_ON_ANSWER;
        QuizCommandUtil.updateCommandResult(answerStringToShow);

        return new QuizCommandResult(answerStringToShow, model.getQuiz(), ANSWER);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AnswerCommand // instanceof handles nulls
                && answer.equals(((AnswerCommand) other).answer)); // state check
    }
}
```


Overlapping Code:
```
d extends Command<QuizModel> {
public static final String COMMAND_WORD = "ans:";
public static final int STARTING_INDEX_OF_ANSWER = 4;
public static final Status STATUS = Status.ON_QUESTION;
private final String answer;
public AnswerCommand(String answer) {
this.answer = answer;
}
@Override
public CommandResult execute(QuizModel model) throws CommandException {
requireNonNull(model);
if (!model.hasStarted()) {
throw new CommandException(QuizCommandUtil.MESSAGE_QUIZ_NEVER_STARTED);
}
if (!QuizCommandUtil.getStatus().equals(STATUS)) {
throw new CommandException(QuizCommandUtil.MESSAGE_UNAVAIL_ON_ANSWER);
}
model.saveAnswer(answer);
QuizCard.setQuestion(model.getQuestion());
String userAnswerToShow = "Your answer: " + answer + "\n\n";
Answer answer = model.getAnswer();
QuizCommandUtil.setStatus(Status.ON_ANSWER);
String answerStringToShow = userAnswerToShow + "\nCorrect answer: " + answer.toString()
+ QuizCommandUtil.SPECIAL_LITERAL
+ QuizCommandUtil.MESSAGE_AVAIL_ON_ANSWER;
QuizCommandUtil.updateCommandResult(answerStringToShow);
return new QuizCommandResult(answerStringToShow, model.getQuiz(), ANSWER);
}
@Override
public boolean equals(Object other) {
return other == this // short circuit if same object
|| (other instanceof AnswerCommand // instanceof handles nulls
&& answer.equals(((AnswerCommand) other).answer)); // state check
```
<Overlap Ratio: 0.9789702683103698>

---

--- 73 --
Question ID: a4862962b3814f7582b05ead4ab8f461ce421340
Original Code:
```
public class CMSG_PET_NAME_QUERY extends AbstractRealmClientPacket {

    /**
     * Packet size.
     */
    private short size;
    
    /**
     * Pet number
     */
    private int number;
    
    /**
     * Pet ID.
     */
    private long guid;
    
    /**
     * Constructor with opcode.
     *
     * @param opcode
     */
    public CMSG_PET_NAME_QUERY(Opcodes opcode, short size) {
        super(opcode);
        this.size = size;
    }

    public short getSize() {
        return size;
    }

    public void setSize(short size) {
        this.size = size;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

    public long getGuid() {
        return guid;
    }

    public void setGuid(long guid) {
        this.guid = guid;
    }    
    
    public String toString() {
        String toString = "[CMSG_PET_NAME_QUERY ["
                + "number: "+this.number
                + ", guid: "+this.guid                
                +"]]";

        return toString;
    }

    @Override
    public void decode(ByteBuf buf) throws Exception {           
        if((buf.readableBytes()+4) < this.size)
        {
            throw new Exception();
        }
        
        this.number = buf.readInt();
        this.guid = buf.readLong();
    }

}
```


Overlapping Code:
```
 AbstractRealmClientPacket {
/**
* Packet size.
*/
private short size;

/**
* Pet number
*/
private int number;

/**
* Pet ID.
*/
private long guid;

/**
* Constructor with opcode.
*
* @param opcode
*/
public CMSG_PET_NAME_QUERY(Opcodes opcode, short size) {
super(opcode);
this.size = size;
}
public short getSize() {
return size;
}
public void setSize(short size) {
this.size = size;
}
public int getNumber() {
return number;
}
public void setNumber(int number) {
this.number = number;
}
public long getGuid() {
return guid;
}
public void setGuid(long guid) {
this.guid = guid;
} 

public String toString() {
String toString = "[CMSG_PET_NAME_QUERY ["
+ "number: "+this.number
+ ", guid: "+this.guid 
+"]]";
return toString;
}
@Override
public void decode(ByteBuf buf) throws Exception { 
if((buf.readableBytes()+4) < this.size)
{
throw new Exception();
}

this.number = buf.readInt();
this.guid = 
```
<Overlap Ratio: 0.9384775808133472>

---

--- 74 --
Question ID: 7935421d6050f2068428026103881b70fc142976
Original Code:
```
@ExtendWith(MockitoExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class FixedAssetsInvestmentsHandlerTest {

    @Mock
    private ApiClient apiClient;

    @Mock
    private SmallFullService smallFullService;

    @Mock
    private SmallFullResourceHandler smallFullResourceHandler;

    @Mock
    private FixedAssetsInvestmentsGet fixedAssetsInvestmentsGet;

    @Mock
    private FixedAssetsInvestmentsUpdate fixedAssetsInvestmentsUpdate;

    @Mock
    private FixedAssetsInvestmentsDelete fixedAssetsInvestmentsDelete;

    @Mock
    private FixedAssetsInvestmentsCreate fixedAssetsInvestmentsCreate;

    @Mock
    private FixedAssetsInvestmentsApi fixedAssetsInvestmentsApi;

    @Mock
    private SmallFullLinks smallFullLinks;

    @Mock
    private SmallFullApi smallFullApi;

    @Mock
    private FixedAssetsInvestmentsResourceHandler fixedAssetsInvestmentsResourceHandler;

    @InjectMocks
    private FixedAssetsInvestmentsHandler fixedAssetsInvestmentsHandler;

    private static final String COMPANY_ACCOUNTS_ID = "companyAccountsId";
    private static final String TRANSACTION_ID = "transactionId";

    private static final String URI = "/transactions/" + TRANSACTION_ID + "/company-accounts/" +
            COMPANY_ACCOUNTS_ID + "/small-full/notes/fixed-assets-investments";

    private static final String FIXED_ASSETS_INVESTMENTS_NOTE = "fixedAssetsInvestment";

    @Test
    @DisplayName("Get FixedAssetsInvestments resource URI")
    void getFixedAssetsInvestmentsURI() {
        assertEquals(URI, fixedAssetsInvestmentsHandler.getUri(TRANSACTION_ID, COMPANY_ACCOUNTS_ID));
    }

    @Test
    @DisplayName("Get FixedAssetsInvestments Resource")
    void getFixedAssetsInvestmentsResource() {

        setupFixedAssetsInvestmentsHandler();

        when(fixedAssetsInvestmentsHandler.get(apiClient, URI)).thenReturn(fixedAssetsInvestmentsGet);

        Executor<ApiResponse<FixedAssetsInvestmentsApi>> getFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.get(apiClient, URI);

        assertNotNull(getFixedAssetsInvestmentsApi);
        assertEquals(getFixedAssetsInvestmentsApi, fixedAssetsInvestmentsGet);
    }

    @Test
    @DisplayName("Update FixedAssetsInvestments Resource")
    void updateFixedAssetsInvestmentsResource() {

        setupFixedAssetsInvestmentsHandler();

        when(fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsUpdate);

        Executor<ApiResponse<Void>> updatedFixedAssetsInvestments = fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi);

        assertNotNull(updatedFixedAssetsInvestments);
        assertEquals(updatedFixedAssetsInvestments, fixedAssetsInvestmentsUpdate);
    }

    @Test
    @DisplayName("Create FixedAssetsInvestments Resource")
    void createFixedAssetsInvestmentsResource() {

        setupFixedAssetsInvestmentsHandler();

        when(fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInvestmentsCreate);

        Executor<ApiResponse<FixedAssetsInvestmentsApi>> createFixedAssetsInvestments = fixedAssetsInvestmentsHandler.create(apiClient, URI, fixedAssetsInvestmentsApi);

        assertNotNull(createFixedAssetsInvestments);
        assertEquals(createFixedAssetsInvestments, fixedAssetsInvestmentsCreate);
    }

    @Test
    @DisplayName("Delete FixedAssetsInvestments Resource")
    void deleteFixedAssetsInvestmentsResource() {

        setupFixedAssetsInvestmentsHandler();

        when(fixedAssetsInvestmentsHandler.delete(apiClient, URI)).thenReturn(fixedAssetsInvestmentsDelete);

        Executor<ApiResponse<Void>> deleteFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.delete(apiClient, URI);

        assertNotNull(deleteFixedAssetsInvestmentsApi);
        assertEquals(deleteFixedAssetsInvestmentsApi, fixedAssetsInvestmentsDelete);
    }

    @Test
    @DisplayName("Test parent resource exist")
    void testParentResourceExist() throws ServiceException {

        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenReturn(smallFullApi);
        when(smallFullApi.getLinks()).thenReturn(smallFullLinks);
        when(smallFullLinks.getFixedAssetsInvestmentsNote()).thenReturn(FIXED_ASSETS_INVESTMENTS_NOTE);

        assertTrue(fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));
    }

    @Test
    @DisplayName("Test parent resource throws service exception")
    void testParentResourceThrowsServiceException() throws ServiceException {

        when(smallFullService.getSmallFullAccounts(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID)).thenThrow(ServiceException.class);

        assertThrows(ServiceException.class, () -> fixedAssetsInvestmentsHandler.parentResourceExists(apiClient, TRANSACTION_ID, COMPANY_ACCOUNTS_ID));
    }

    @Test
    @DisplayName("Test method returns FixedAssetsInvestments as NoteType")
    void testFixedAssetsInvestmentsReturned() {

        assertEquals(NoteType.SMALL_FULL_FIXED_ASSETS_INVESTMENT, fixedAssetsInvestmentsHandler.getNoteType());
    }

    private void setupFixedAssetsInvestmentsHandler() {

        when(apiClient.smallFull()).thenReturn(smallFullResourceHandler);
        when(smallFullResourceHandler.fixedAssetsInvestments()).thenReturn(fixedAssetsInvestmentsResourceHandler);
    }
}
```


Overlapping Code:
```
@ExtendWith(MockitoExtension.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class FixedAssetsInvestmentsHandlerTest {
@Mock
private ApiClient apiClient;
@Mock
private SmallFullService smallFullService;
@Mock
private SmallFullResourceHandler smallFullResourceHandler;
@Mock
private FixedAssetsInvestmentsGet fixedAssetsInvestmentsGet;
@Mock
private FixedAssetsInvestmentsUpdate fixedAssetsInvestmentsUpdate;
@Mock
private FixedAssetsInvestmentsDelete fixedAssetsInvestmentsDelete;
@Mock
private FixedAssetsInvestmentsCreate fixedAssetsInvestmentsCreate;
@Mock
private FixedAssetsInvestmentsApi fixedAssetsInvestmentsApi;
@Mock
private SmallFullLinks smallFullLinks;
@Mock
private SmallFullApi smallFullApi;
@Mock
private FixedAssetsInvestmentsResourceHandler fixedAssetsInvestmentsResourceHandler;
@InjectMocks
private FixedAssetsInvestmentsHandler fixedAssetsInvestmentsHandler;
private static final String COMPANY_ACCOUNTS_ID = "companyAccountsId";
private static final String TRANSACTION_ID = "transactionId";
private static final String URI = "/transactions/" + TRANSACTION_ID + "/company-accounts/" +
COMPANY_ACCOUNTS_ID + "/small-full/notes/fixed-assets-investments";
private static final String FIXED_ASSETS_INVESTMENTS_NOTE = "fixedAssetsInvestment";
@Test
@DisplayName("Get FixedAssetsInvestments resource URI")
void getFixedAssetsInvestmentsURI() {
assertEquals(URI, fixedAssetsInvestmentsHandler.getUri(TRANSACTION_ID, COMPANY_ACCOUNTS_ID));
}
@Test
@DisplayName("Get FixedAssetsInvestments Resource")
void getFixedAssetsInvestmentsResource() {
setupFixedAssetsInvestmentsHandler();
when(fixedAssetsInvestmentsHandler.get(apiClient, URI)).thenReturn(fixedAssetsInvestmentsGet);
Executor<ApiResponse<FixedAssetsInvestmentsApi>> getFixedAssetsInvestmentsApi = fixedAssetsInvestmentsHandler.get(apiClient, URI);
assertNotNull(getFixedAssetsInvestmentsApi);
assertEquals(getFixedAssetsInvestmentsApi, fixedAssetsInvestmentsGet);
}
@Test
@DisplayName("Update FixedAssetsInvestments Resource")
void updateFixedAssetsInvestmentsResource() {
setupFixedAssetsInvestmentsHandler();
when(fixedAssetsInvestmentsHandler.update(apiClient, URI, fixedAssetsInvestmentsApi)).thenReturn(fixedAssetsInv
```
<Overlap Ratio: 0.9852282900626679>

---

--- 75 --
Question ID: 931e9971f7f4e826dfe7b99d4ec3cdb18740c0d5
Original Code:
```
public class MongoCmdOptionsBuilder extends AbstractBuilder<IMongoCmdOptions> {

	protected static final TypedProperty<Integer> SYNC_DELAY = TypedProperty.with("syncDelay", Integer.class);
	protected static final TypedProperty<String> STORAGE_ENGINE = TypedProperty.with("storageEngine", String.class);
	protected static final TypedProperty<Boolean> VERBOSE = TypedProperty.with("verbose", Boolean.class);
	protected static final TypedProperty<Boolean> NOPREALLOC = TypedProperty.with("noprealloc", Boolean.class);
	protected static final TypedProperty<Boolean> SMALLFILES = TypedProperty.with("smallfiles", Boolean.class);
	protected static final TypedProperty<Boolean> NOJOURNAL = TypedProperty.with("nojournal", Boolean.class);
	protected static final TypedProperty<Boolean> ENABLE_TEXTSEARCH = TypedProperty.with("enableTextSearch", Boolean.class);
	protected static final TypedProperty<Boolean> ENABLE_AUTH = TypedProperty.with("auth", Boolean.class);
	protected static final TypedProperty<Boolean> MASTER = TypedProperty.with("master", Boolean.class);


	public MongoCmdOptionsBuilder() {
		property(SYNC_DELAY).setDefault(0);
		property(STORAGE_ENGINE).setDefault(null);
		property(VERBOSE).setDefault(false);
		property(NOPREALLOC).setDefault(true);
		property(SMALLFILES).setDefault(true);
		property(NOJOURNAL).setDefault(true);
		property(ENABLE_TEXTSEARCH).setDefault(false);
		property(ENABLE_AUTH).setDefault(false);
		property(MASTER).setDefault(false);
	}

	public MongoCmdOptionsBuilder useNoPrealloc(boolean value) {
		set(NOPREALLOC, value);
		return this;
	}

	public MongoCmdOptionsBuilder useSmallFiles(boolean value) {
		set(SMALLFILES, value);
		return this;
	}

	public MongoCmdOptionsBuilder useNoJournal(boolean value) {
		set(NOJOURNAL, value);
		return this;
	}

	public MongoCmdOptionsBuilder syncDelay(int delay) {
		set(SYNC_DELAY, delay);
		return this;
	}

	public MongoCmdOptionsBuilder verbose(boolean verbose) {
		set(VERBOSE, verbose);
		return this;
	}

	public MongoCmdOptionsBuilder enableTextSearch(boolean verbose) {
		set(ENABLE_TEXTSEARCH, verbose);
		return this;
	}

	public MongoCmdOptionsBuilder useStorageEngine(String storageEngine) {
		set(STORAGE_ENGINE, storageEngine);
		return this;
	}

	public MongoCmdOptionsBuilder enableAuth(boolean enable) {
		set(ENABLE_AUTH, enable);
		return this;
	}

	public MongoCmdOptionsBuilder master(boolean enable) {
		set(MASTER, enable);
		return this;
	}

	public MongoCmdOptionsBuilder defaultSyncDelay() {
		set(SYNC_DELAY, null);
		return this;
	}

	@Override
	public IMongoCmdOptions build() {
		Integer syncDelay = get(SYNC_DELAY, null);
		String storageEngine = get(STORAGE_ENGINE, null);
		boolean verbose = get(VERBOSE);
		boolean noPrealloc = get(NOPREALLOC);
		boolean smallFiles = get(SMALLFILES);
		boolean noJournal = get(NOJOURNAL);
		boolean enableTextSearch = get(ENABLE_TEXTSEARCH);
		boolean auth = get(ENABLE_AUTH);
		boolean master = get(MASTER);
		return new MongoCmdOptions(syncDelay, storageEngine, verbose, noPrealloc, smallFiles, noJournal, enableTextSearch, auth, master);
	}

	static class MongoCmdOptions implements IMongoCmdOptions {

		private final Integer _syncDelay;
		private final boolean _verbose;
		private final boolean _noPrealloc;
		private final boolean _smallFiles;
		private final boolean _noJournal;
		private final boolean _enableTextSearch;
		private final boolean _auth;
		private final boolean _master;
		private final String _storageEngine;

		public MongoCmdOptions(Integer syncDelay, String storageEngine, boolean verbose, boolean noPrealloc, boolean smallFiles,
                               boolean noJournal, boolean enableTextSearch, boolean auth, boolean master) {
			_syncDelay = syncDelay;
			_storageEngine = storageEngine;
			_verbose = verbose;
			_noPrealloc = noPrealloc;
			_smallFiles = smallFiles;
			_noJournal = noJournal;
			_enableTextSearch = enableTextSearch;
			_auth = auth;
			_master = master;
		}

		@Override
		public Integer syncDelay() {
			return _syncDelay;
		}

		@Override
		public String storageEngine() {
			return _storageEngine;
		}

		@Override
		public boolean isVerbose() {
			return _verbose;
		}

		@Override
		public boolean useNoPrealloc() {
			return _noPrealloc;
		}

		@Override
		public boolean useSmallFiles() {
			return _smallFiles;
		}

		@Override
		public boolean useNoJournal() {
			return _noJournal;
		}

		@Override
		public boolean enableTextSearch() {
			return _enableTextSearch;
		}

		@Override
		public boolean auth() {
			return _auth;
		}

		@Override
		public boolean master() {
			return _master;
		}
	}
}
```


Overlapping Code:
```
blic class MongoCmdOptionsBuilder extends AbstractBuilder<IMongoCmdOptions> {
protected static final TypedProperty<Integer> SYNC_DELAY = TypedProperty.with("syncDelay", Integer.class);
protected static final TypedProperty<String> STORAGE_ENGINE = TypedProperty.with("storageEngine", String.class);
protected static final TypedProperty<Boolean> VERBOSE = TypedProperty.with("verbose", Boolean.class);
protected static final TypedProperty<Boolean> NOPREALLOC = TypedProperty.with("noprealloc", Boolean.class);
protected static final TypedProperty<Boolean> SMALLFILES = TypedProperty.with("smallfiles", Boolean.class);
protected static final TypedProperty<Boolean> NOJOURNAL = TypedProperty.with("nojournal", Boolean.class);
protected static final TypedProperty<Boolean> ENABLE_TEXTSEARCH = TypedProperty.with("enableTextSearch", Boolean.class);
protected static final TypedProperty<Boolean> ENABLE_AUTH = TypedProperty.with("auth", Boolean.class);
protected static final TypedProperty<Boolean> MASTER = TypedProperty.with("master", Boolean.class);
public MongoCmdOptionsBuilder() {
property(SYNC_DELAY).setDefault(0);
property(STORAGE_ENGINE).setDefault(null);
property(VERBOSE).setDefault(false);
property(NOPREALLOC).setDefault(true);
property(SMALLFILES).setDefault(true);
property(NOJOURNAL).setDefault(true);
property(ENABLE_TEXTSEARCH).setDefault(false);
property(ENABLE_AUTH).setDefault(false);
property(MASTER).setDefault(false);
}
public MongoCmdOptionsBuilder useNoPrealloc(boolean value) {
set(NOPREALLOC, value);
return this;
}
public MongoCmdOptionsBuilder useSmallFiles(boolean value) {
set(SMALLFILES, value);
return this;
}
public MongoCmdOptionsBuilder useNoJournal(boolean value) {
set(NOJOURNAL, value);
return this;
}
public MongoCmdOptionsBuilder syncDelay(int delay) {
set(SYNC_DELAY, delay);
return this;
}
public MongoCmdOptionsBuilder verbose(boolean verbose) {
set(VERBOSE, verbose);
return this;
}
public MongoCmdOptionsBuilder enableTextSearch(boolean verbose) {
set(ENABLE_TEXTSEARCH, verbose);
return this;
}
public MongoCmdOptionsBuilder useStorageEngine(String storageEngine) {
set(STORAGE_ENGINE, storageEngine);
return this;
}
public MongoCmdOptionsBuilder enableAuth(boolean enable) {
set(ENABLE_AUTH, enable);
return this;
}
public MongoCmdOptionsBuilder master(boolean enable) {
set(MASTER, enable);
return this;
}
public MongoCmdOptionsBuilder defaultSyncDelay() {
```
<Overlap Ratio: 0.9991673605328892>

---

--- 76 --
Question ID: 7227f47aa7610fe95ca27247cd92d5e1d2bfa855
Original Code:
```
public class VersionedNewPortfolio extends NewPortfolio {

  public enum Day {
    Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
  }
  
  protected int pdxId = 0;           
  protected String pdxName = "name";        
  protected String pdxStatus = "status";
  protected String pdxType = "type";
  protected Map pdxPositions = new HashMap();
  public String pdxUndefinedTestField = null;
  public Day aDay;
  
  static transient List dayList;
  
  static {
    Log.getLogWriter().info("In static initializer for testsVersions/version2/objects.VersionedPortfolio");
    dayList = new ArrayList();
    dayList.addAll(EnumSet.range(Day.Monday, Day.Friday));
  }
  
  public VersionedNewPortfolio() {
    myVersion = "testsVersions/version2/parReg.query.VersionedNewPortfolio";
  }
  public VersionedNewPortfolio(String name, int id) {
    super(name, id);

    
    this.pdxName = name;
    this.pdxId = id;
    
    this.pdxStatus = id % 2 == 0 ? "active" : "inactive";
    this.pdxType = "type" + (id % NUM_OF_TYPES);
    this.aDay = getDayForBase(id);
    
    setPositions();
  }
  
  private void setPositions() {
    int numOfPositions = rng.nextInt(MAX_NUM_OF_POSITIONS);
    if (numOfPositions == 0) 
      numOfPositions++;
     
    int secId =  rng.nextInt(NUM_OF_SECURITIES);
    
    for (int i=0; i < numOfPositions; i++) {
      Properties props = getProps();
      
//    secId needs to be UNIQUE in one portfolio, keep track MAX_NUM_OF_POSITIONS and NUM_OF_SECURITIES
      secId += i * 7;                    
      if (secId > NUM_OF_SECURITIES)
        secId -= NUM_OF_SECURITIES;
      props.setProperty("secId", new Integer(secId).toString());
      
      Position pos = new Position();
      pos.init(props);
      this.positions.put(pos.getSecId(), pos);
    }
  }

  /* (non-Javadoc)
   * @see java.lang.Object#toString()
   */
  @Override
  public String toString() {
    return this.getClass().getName() + " [pdxId=" + this.pdxId + ", pdxName="
        + this.pdxName + ", pdxStatus=" + this.pdxStatus + ", pdxType="
        + this.pdxType + ", pdxPositions=" + this.pdxPositions
        + ", pdxUndefinedTestField=" + this.pdxUndefinedTestField
        + ", aDay=" + this.aDay
        + ", myVersion=" + this.myVersion + ", id=" + this.id + ", name="
        + this.name + ", status=" + this.status + ", type=" + this.type
        + ", positions=" + this.positions + ", undefinedTestField="
        + this.undefinedTestField + "]";
  }

  /* (non-Javadoc)
   * @see com.gemstone.gemfire.pdx.PdxSerializable#toData(com.gemstone.gemfire.pdx.PdxWriter)
   */
  public void myToData(PdxWriter writer) {
    if (PdxPrms.getLogToAndFromData()) {
      Log.getLogWriter().info("In testsVersions/version2/parReg.query.VersionedNewPortfolio.myToData: " + this);
    }
    writer.writeString("myVersion", myVersion);
    writer.writeInt("id", id);
    writer.writeString("name", name);
    writer.writeString("status", status);
    writer.writeString("type", type);
    writer.writeObject("positions", positions);
    writer.writeString("undefinedTestField", undefinedTestField);
    writer.writeInt("pdxId", pdxId);
    writer.writeString("pdxName", pdxName);
    writer.writeString("pdxStatus", pdxStatus);
    writer.writeString("pdxType", pdxType);
    writer.writeObject("pdxPositions", pdxPositions);
    writer.writeString("pdxUndefinedTestField", pdxUndefinedTestField);
    writer.writeObject("aDay", aDay);
  }

  /* (non-Javadoc)
   * @see com.gemstone.gemfire.pdx.PdxSerializable#fromData(com.gemstone.gemfire.pdx.PdxReader)
   */
  public void myFromData(PdxReader reader) {
    myVersion = reader.readString("myVersion");
    if (PdxPrms.getLogToAndFromData()) {
      Log.getLogWriter().info("In testsVersions/version2/parReg.query.VersionedNewPortfolio.myFromData with myVersion: " + myVersion);
    }
    id = reader.readInt("id");
    name = reader.readString("name");
    status = reader.readString("status");
    type = reader.readString("type");
    positions = (Map)reader.readObject("positions");
    undefinedTestField = reader.readString("undefinedTestField");
    pdxId = reader.readInt("pdxId");
    pdxName = reader.readString("pdxName");
    pdxStatus = reader.readString("pdxStatus");
    pdxType = reader.readString("pdxType");
    pdxPositions = (Map)reader.readObject("pdxPositions");
    pdxUndefinedTestField = reader.readString("pdxUndefinedTestField");
    aDay = (Day)(reader.readObject("aDay"));
    if (PdxPrms.getLogToAndFromData()) {
      Log.getLogWriter().info("After reading fields in testsVersion/version2/parReg.query.VersionedNewPortfolio.fromData: " + this);
    }
  }
  
  /** Return the appropriate enum Day value given the base
   * 
   * @param base Index to base the Day calculation on.
   * @return A value of Day.
   */
  public static Day getDayForBase(int base) {
      Day aDay = (Day)(dayList.get((base % dayList.size())));
      return aDay;
  }
  
}
```


Overlapping Code:
```
xtends NewPortfolio {
public enum Day {
Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday
}

protected int pdxId = 0; 
protected String pdxName = "name"; 
protected String pdxStatus = "status";
protected String pdxType = "type";
protected Map pdxPositions = new HashMap();
public String pdxUndefinedTestField = null;
public Day aDay;

static transient List dayList;

static {
Log.getLogWriter().info("In static initializer for testsVersions/version2/objects.VersionedPortfolio");
dayList = new ArrayList();
dayList.addAll(EnumSet.range(Day.Monday, Day.Friday));
}

public VersionedNewPortfolio() {
myVersion = "testsVersions/version2/parReg.query.VersionedNewPortfolio";
}
public VersionedNewPortfolio(String name, int id) {
super(name, id);

this.pdxName = name;
this.pdxId = id;

this.pdxStatus = id % 2 == 0 ? "active" : "inactive";
this.pdxType = "type" + (id % NUM_OF_TYPES);
this.aDay = getDayForBase(id);

setPositions();
}

private void setPositions() {
int numOfPositions = rng.nextInt(MAX_NUM_OF_POSITIONS);
if (numOfPositions == 0) 
numOfPositions++;

int secId = rng.nextInt(NUM_OF_SECURITIES);

for (int i=0; i < numOfPositions; i++) {
Properties props = getProps();

// secId needs to be UNIQUE in one portfolio, keep track MAX_NUM_OF_POSITIONS and NUM_OF_SECURITIES
secId += i * 7; 
if (secId > NUM_OF_SECURITIES)
secId -= NUM_OF_SECURITIES;
props.setProperty("secId", new Integer(secId).toString());

Position pos = new Position();
pos.init(props);
this.positions.put(pos.getSecId(), pos);
}
}
/* (non-Javadoc)
* @see java.lang.Object#toString()
*/
@Override
public String toString() {
return this.getClass().getName() + " [pdxId=" + this.pdxId + ", pdxName="
+ this.pdxName + ", pdxStatus=" + this.pdxStatus + ", pdxType="
+ this.pdxType + ", pdxPositions=" + this.pdxPositions
+ ", pdxUndefinedTestField=" + this.pdxUndefinedTestField
+ ", aDay=" + this.aDay
+ ", myVersion=" + this.myVersion + ", id=" + this.id + ", name="
+ this.name + ", status=" + this.status + ", type=" + this.type
+ ", positions=" + this.positions + ", undefinedTestField="
+ this.undefinedTest
```
<Overlap Ratio: 0.9690816797415782>

---

--- 77 --
Question ID: 874f71e1aeb093c23b280ff35d06969d93d16e7a
Original Code:
```
@Getter
@Setter
@Slf4j
public class GeneratorContext {

	@RequiredArgsConstructor
	private static final class GeneratorId {

		private final String id;

		private final GeneratorTable table;

		@Override
		public boolean equals(final Object obj) {
			if (obj instanceof GeneratorId) {
				final GeneratorId other = (GeneratorId) obj;
				return this.id.equals(other.id) && Objects.equals(this.table, other.table);
			}
			return false;
		}

		@Override
		public int hashCode() {
			if (this.table == null) {
				return this.id.hashCode();
			}
			return this.id.hashCode() << 2 | this.table.getName().hashCode();
		}

		@Override
		public String toString() {
			if (this.table == null) {
				return this.id;
			}
			return this.id + '.' + this.table.getName();
		}

	}

	/**
	 * The settings key for the JPA provider.
	 *
	 * Contains either the fully qualified class name of an extension of {@link JpaProvider} or the simple name of one
	 * of the classes from {@code org.fastnate.generator.provider}.
	 *
	 * Defaults to {@code HibernateProvider}.
	 */
	public static final String PROVIDER_KEY = "fastnate.generator.jpa.provider";

	/** The settings key for the path to the persistence.xml, either relative to the current directory or absolute. */
	public static final String PERSISTENCE_FILE_KEY = "fastnate.generator.persistence.file";

	/**
	 * The settings key for the name of the persistence unit in the persistence.xml. The first persistence unit is used,
	 * if none is explicitly set.
	 */
	public static final String PERSISTENCE_UNIT_KEY = "fastnate.generator.persistence.unit";

	/**
	 * The settings key for the target SQL dialect.
	 *
	 * <p>
	 * Contains either the fully qualified name of a class that extends {@link GeneratorDialect} or the simple class
	 * name of one of the classes from {@code org.fastnate.generator.dialect}. The suffix 'Dialect' may be omitted in
	 * that case. For example 'MySql' would map to {@code org.fastnate.generator.dialect.MySqlDialect}.
	 * </p>
	 *
	 * <p>
	 * If no dialect is set explicitly then the configured {@link #PERSISTENCE_FILE_KEY persistence.xml} is scanned for
	 * a connection URL or provider specific dialect, which would be converted to our known dialects.
	 * </p>
	 *
	 * <p>
	 * If nothing is found, H2 is used as default.
	 * </p>
	 */
	public static final String DIALECT_KEY = "fastnate.generator.dialect";

	/** The settings key for {@link #writeNullValues}. */
	public static final String NULL_VALUES_KEY = "fastnate.generator.null.values";

	/** The settings key for {@link #writeRelativeIds}. */
	public static final String RELATIVE_IDS_KEY = "fastnate.generator.relative.ids";

	/** The settings key for the {@link #uniquePropertyQuality}. */
	public static final String UNIQUE_PROPERTIES_QUALITY_KEY = "fastnate.generator.unique.properties.quality";

	/** The settings key for the {@link #maxUniqueProperties}. */
	public static final String UNIQUE_PROPERTIES_MAX_KEY = "fastnate.generator.unique.properties.max";

	/** The settings key for {@link #preferSequenceCurentValue}. */
	public static final String PREFER_SEQUENCE_CURRENT_VALUE = "fastnate.generator.prefer.sequence.current.value";

	/**
	 * Tries to read any persistence file defined in the settings.
	 *
	 * @param settings
	 *            the current settings
	 */
	private static void readPersistenceFile(final Properties settings) {
		String persistenceFilePath = settings.getProperty(PERSISTENCE_FILE_KEY);
		if (StringUtils.isEmpty(persistenceFilePath)) {
			final URL url = GeneratorContext.class.getResource("/META-INF/persistence.xml");
			if (url == null) {
				return;
			}
			persistenceFilePath = url.toString();
		} else {
			final File persistenceFile = new File(persistenceFilePath);
			if (persistenceFile.isFile()) {
				persistenceFilePath = persistenceFile.toURI().toString();
			}
		}

		final String persistenceUnit = settings.getProperty(PERSISTENCE_UNIT_KEY);
		try {
			final Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder()
					.parse(persistenceFilePath);
			final NodeList persistenceUnits = document.getElementsByTagName("persistence-unit");
			for (int i = 0; i < persistenceUnits.getLength(); i++) {
				final Element persistenceUnitElement = (Element) persistenceUnits.item(i);
				if (StringUtils.isEmpty(persistenceUnit)
						|| persistenceUnit.equals(persistenceUnitElement.getAttribute("name"))) {
					final NodeList properties = persistenceUnitElement.getElementsByTagName("property");
					for (int i2 = 0; i2 < properties.getLength(); i2++) {
						final Element property = (Element) properties.item(i2);
						final String name = property.getAttribute("name");
						if (!settings.containsKey(name)) {
							settings.put(name, property.getAttribute("value"));
						}
					}
					break;
				}
			}
		} catch (final IOException | SAXException | ParserConfigurationException e) {
			log.error("Could not read " + persistenceFilePath + ": " + e, e);
		}
	}

	/** Identifies the SQL dialect for generating SQL statements. Encapsulates the database specifica. */
	private GeneratorDialect dialect;

	/** Identifies the JPA provider to indicate implementation specific details. */
	private JpaProvider provider;

	/** The maximum count of columns that are used when referencing an entity using it's unique properties. */
	private int maxUniqueProperties = 1;

	/**
	 * Indicates what kind of properties are used for referencing an entity with its unique properties.
	 */
	private UniquePropertyQuality uniquePropertyQuality = UniquePropertyQuality.onlyRequiredPrimitives;

	/**
	 * Indiciates to use "currval" of a sequence if the referenced entity is the last created entity for that sequence
	 * before checking for {@link #uniquePropertyQuality unique properties}.
	 */
	private boolean preferSequenceCurentValue = true;

	/**
	 * Indicates that we write into a schema that is not empty. By default we write all IDs as absolute values and
	 * change the sequences / table generators at the end. But this would crash if there is data in the database already
	 * that uses the same IDs. So in the case of incremental updates, one should set this setting to {@code true} -
	 * which will generate relative IDs which respect the existing IDs.
	 */
	private boolean writeRelativeIds;

	/** Indicates to include null values in statements. */
	private boolean writeNullValues;

	/** Contains the settings that were given during creation, resp. as read from the persistence configuration. */
	private final Properties settings;

	/** Contains the extracted metadata to every known class of an {@link Entity}. */
	private final Map<Class<?>, EntityClass<?>> descriptions = new HashMap<>();

	/** The mapping from the {@link Entity#name() name of an entity} to the {@link #descriptions extracted metadata}. */
	private final Map<String, EntityClass<?>> descriptionsByName = new HashMap<>();

	/** Mapping from the names of all known database table to their description (including column information). */
	private final Map<String, GeneratorTable> tables = new HashMap<>();

	/** Contains the state of single entities, maps from an entity name to the mapping of an id to its state. */
	private final Map<String, Map<Object, GenerationState>> states = new HashMap<>();

	/** Mapping from the name of a generator to the generator itself. */
	@Getter(AccessLevel.NONE)
	private final Map<GeneratorId, IdGenerator> generators = new HashMap<>();

	/** The default sequence generator, if none is explicitly specified in a {@link GeneratedValue}. */
	private SequenceIdGenerator defaultSequenceGenerator;

	/** The default table generator, if none is explicitly specified in a {@link GeneratedValue}. */
	private TableIdGenerator defaultTableGenerator;

	/** All listeners of this context. */
	private List<ContextModelListener> contextModelListeners = new ArrayList<>();

	/**
	 * Creates a default generator context.
	 */
	public GeneratorContext() {
		this(new H2Dialect());
	}

	/**
	 * Creates a generator context for a dialect.
	 *
	 * @param dialect
	 *            the database dialect to use during generation
	 */
	public GeneratorContext(final GeneratorDialect dialect) {
		this.dialect = dialect;
		this.provider = new HibernateProvider();
		this.settings = new Properties();
	}

	/**
	 * Creates a new instance of {@link GeneratorContext}.
	 *
	 * @param settings
	 *            contains the settings
	 */
	public GeneratorContext(final Properties settings) {
		this.settings = settings;

		readPersistenceFile(settings);

		String providerName = settings.getProperty(PROVIDER_KEY, "HibernateProvider");
		if (providerName.indexOf('.') < 0) {
			providerName = JpaProvider.class.getPackage().getName() + '.' + providerName;
		}
		try {
			this.provider = (JpaProvider) Class.forName(providerName).newInstance();
			this.provider.initialize(settings);
		} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException
				| ClassCastException e) {
			throw new IllegalArgumentException("Can't instantiate provider: " + providerName, e);
		}

		String dialectName = settings.getProperty(DIALECT_KEY, "H2Dialect");
		if (dialectName.indexOf('.') < 0) {
			dialectName = GeneratorDialect.class.getPackage().getName() + '.' + dialectName;
			if (!dialectName.endsWith("Dialect")) {
				dialectName += "Dialect";
			}
		}
		try {
			this.dialect = (GeneratorDialect) Class.forName(dialectName).newInstance();
		} catch (final InstantiationException | IllegalAccessException | ClassNotFoundException
				| ClassCastException e) {
			throw new IllegalArgumentException("Can't instantiate dialect: " + dialectName, e);
		}

		this.writeRelativeIds = Boolean
				.parseBoolean(settings.getProperty(RELATIVE_IDS_KEY, String.valueOf(this.writeRelativeIds)));
		this.writeNullValues = Boolean
				.parseBoolean(settings.getProperty(NULL_VALUES_KEY, String.valueOf(this.writeNullValues)));
		this.uniquePropertyQuality = UniquePropertyQuality
				.valueOf(settings.getProperty(UNIQUE_PROPERTIES_QUALITY_KEY, this.uniquePropertyQuality.name()));
		this.maxUniqueProperties = Integer
				.parseInt(settings.getProperty(UNIQUE_PROPERTIES_MAX_KEY, String.valueOf(this.maxUniqueProperties)));
		this.preferSequenceCurentValue = Boolean.parseBoolean(
				settings.getProperty(PREFER_SEQUENCE_CURRENT_VALUE, String.valueOf(this.preferSequenceCurentValue)));
	}

	/**
	 * Adds a new listener to this context.
	 *
	 * @param listener
	 *            the listener that is interested in new discovered model elements
	 */
	public void addContextModelListener(final ContextModelListener listener) {
		this.contextModelListeners.add(listener);
	}

	private <K, T> T addContextObject(final Map<K, ? super T> objects,
			final BiConsumer<ContextModelListener, ? super T> listenerFunction, final K key, final T object) {
		objects.put(key, object);
		fireContextObjectAdded(listenerFunction, object);
		return object;
	}

	/**
	 * Fires an event to all {@link #getContextModelListeners() listeners}.
	 *
	 * @param listenerFunction
	 *            the function that is called on the listeners
	 * @param contextObject
	 *            the object to offer to the listener function
	 */
	protected <T> void fireContextObjectAdded(final BiConsumer<ContextModelListener, T> listenerFunction,
			final T contextObject) {
		for (final ContextModelListener listener : this.contextModelListeners) {
			listenerFunction.accept(listener, contextObject);
		}
	}

	private IdGenerator getDefaultSequenceGenerator() {
		if (this.defaultSequenceGenerator == null) {
			final Map<String, Object> defaults = Stream
					.of(new SimpleEntry<String, Object>("sequenceName", this.provider.getDefaultSequence()),
							new SimpleEntry<String, Object>("allocationSize", Integer.valueOf(1)))
					.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));
			this.defaultSequenceGenerator = new SequenceIdGenerator(
					AnnotationDefaults.create(SequenceGenerator.class, defaults), this.dialect, this.writeRelativeIds);
			fireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultSequenceGenerator);
		}
		return this.defaultSequenceGenerator;
	}

	private IdGenerator getDefaultTableGenerator() {
		if (this.defaultTableGenerator == null) {
			final Map<String, Object> defaults = Stream
					.of(new SimpleEntry<String, Object>("pkColumnValue", "default"),
							new SimpleEntry<String, Object>("allocationSize", Integer.valueOf(1)))
					.collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));
			this.defaultTableGenerator = new TableIdGenerator(AnnotationDefaults.create(TableGenerator.class, defaults),
					this);
			fireContextObjectAdded(ContextModelListener::foundGenerator, this.defaultTableGenerator);
		}
		return this.defaultTableGenerator;
	}

	/**
	 * Finds the description for a class.
	 *
	 * @param entityClass
	 *            the class to lookup
	 * @return the description for the class or {@code null} if the class is not an {@link Entity}
	 */
	public <E> EntityClass<E> getDescription(final Class<E> entityClass) {
		// Lookup description
		EntityClass<E> description = (EntityClass<E>) this.descriptions.get(entityClass);
		if (description == null) {
			if (!entityClass.isAnnotationPresent(Entity.class)) {
				// Step up to find the parent description
				final Class<?> superClass = entityClass.getSuperclass();
				if (superClass == null) {
					return null;
				}

				return (EntityClass<E>) getDescription(superClass);
			}

			// Create the description
			description = new EntityClass<>(this, entityClass);

			// First remember the description (to prevent endless loops)
			this.descriptions.put(entityClass, description);
			this.descriptionsByName.put(description.getEntityName(), description);

			// And now build the properties
			description.build();

			// And notify listeners
			fireContextObjectAdded(ContextModelListener::foundEntityClass, description);
		}
		return description;
	}

	/**
	 * Finds the description for the class of an entity.
	 *
	 * @param entity
	 *            the entity to lookup
	 * @return the description for the class of the entity
	 * @throws IllegalArgumentException
	 *             if the given object is no {@link Entity}
	 */
	public <E> EntityClass<E> getDescription(final E entity) {
		if (entity == null) {
			throw new IllegalArgumentException("Can't inspect null entity");
		}
		final EntityClass<E> description = (EntityClass<E>) getDescription(entity.getClass());
		if (description == null) {
			throw new IllegalArgumentException(entity.getClass() + " is not an entity class");
		}
		return description;
	}

	/**
	 * Finds the correct generator for the given annotation.
	 *
	 * @param generatedValue
	 *            the annotation of the current primary key
	 * @param table
	 *            the name of the current table
	 * @param column
	 *            the name of the current column
	 * @return the generator that is responsible for managing the values
	 */
	@SuppressWarnings("null")
	public IdGenerator getGenerator(final GeneratedValue generatedValue, final GeneratorTable table,
			final GeneratorColumn column) {
		GenerationType strategy = generatedValue.strategy();
		final String name = generatedValue.generator();
		if (StringUtils.isNotEmpty(name)) {
			ModelException.test(strategy != GenerationType.IDENTITY,
					"Generator for GenerationType.IDENTITY not allowed");
			IdGenerator generator = this.generators.get(new GeneratorId(name, table));
			if (generator == null) {
				generator = this.generators.get(new GeneratorId(name, null));
				ModelException.test(generator != null, "Generator '{}' not found", name);

				final IdGenerator derived = generator.derive(table);
				if (derived != generator) {
					return addContextObject(this.generators, ContextModelListener::foundGenerator,
							new GeneratorId(name, table), derived);
				}
			}
			return generator;
		}
		if (strategy == GenerationType.AUTO) {
			strategy = this.dialect.getAutoGenerationType();
		}
		switch (strategy) {
			case IDENTITY:
				return addContextObject(this.generators, ContextModelListener::foundGenerator,
						new GeneratorId(column.getName(), table), new IdentityValue(this, table, column));
			case TABLE:
				return getDefaultTableGenerator();
			case SEQUENCE:
				return getDefaultSequenceGenerator();
			case AUTO:
			default:
				throw new ModelException("Unknown GenerationType: " + strategy);
		}
	}

	/**
	 * The entity states for the given entity class.
	 *
	 * @param entityClass
	 *            the current entity class
	 * @return the states of the entities of that class (with their IDs as keys)
	 */
	Map<Object, GenerationState> getStates(final EntityClass<?> entityClass) {
		Map<Object, GenerationState> entityStates = this.states.get(entityClass.getEntityName());
		if (entityStates == null) {
			entityStates = new HashMap<>();
			this.states.put(entityClass.getEntityName(), entityStates);
		}
		return entityStates;
	}

	/**
	 * Registers the {@link TableGenerator} and {@link SequenceGenerator} declared at the given element.
	 *
	 * If neither annotation is present, nothing happens.
	 *
	 * @param element
	 *            the inspected class, method or field
	 * @param table
	 *            the table of the current entity
	 */
	public void registerGenerators(final AnnotatedElement element, final GeneratorTable table) {
		final SequenceGenerator sequenceGenerator = element.getAnnotation(SequenceGenerator.class);
		if (sequenceGenerator != null) {
			GeneratorId key = new GeneratorId(sequenceGenerator.name(), null);
			final IdGenerator existingGenerator = this.generators.get(key);
			if (!(existingGenerator instanceof SequenceIdGenerator) || !((SequenceIdGenerator) existingGenerator)
					.getSequenceName().equals(sequenceGenerator.sequenceName())) {
				if (existingGenerator != null) {
					key = new GeneratorId(sequenceGenerator.name(), table);
				}
				addContextObject(this.generators, ContextModelListener::foundGenerator, key,
						new SequenceIdGenerator(sequenceGenerator, this.dialect, this.writeRelativeIds));
			}
		}

		final TableGenerator tableGenerator = element.getAnnotation(TableGenerator.class);
		if (tableGenerator != null) {
			final GeneratorId key = new GeneratorId(tableGenerator.name(), null);
			if (!this.generators.containsKey(key)) {
				addContextObject(this.generators, ContextModelListener::foundGenerator, key,
						new TableIdGenerator(tableGenerator, this));
			}
		}
	}

	/**
	 * Removes a listener from this context.
	 *
	 * @param listener
	 *            the listener that is not interested anymore
	 */
	public void removeContextModelListener(final ContextModelListener listener) {
		this.contextModelListeners.remove(listener);
	}

	/**
	 * Finds resp. builds the metadata to the given table.
	 *
	 * @param tableName
	 *            the name of the table from the database
	 * @return the metadata for the given table
	 */
	public GeneratorTable resolveTable(final String tableName) {
		final GeneratorTable table = this.tables.get(tableName);
		if (table != null) {
			return table;
		}
		return addContextObject(this.tables, ContextModelListener::foundTable, tableName,
				new GeneratorTable(this.tables.size(), tableName, this));
	}

	/**
	 * Builds all statements that are necessary to align ID generators in the database with the current IDs.
	 *
	 * @param writer
	 *            the target of any write operation
	 * @throws IOException
	 *             if the writer throws one
	 */
	public void writeAlignmentStatements(final StatementsWriter writer) throws IOException {
		for (final IdGenerator generator : this.generators.values()) {
			generator.alignNextValue(writer);
		}
		if (this.defaultSequenceGenerator != null) {
			this.defaultSequenceGenerator.alignNextValue(writer);
		}
		if (this.defaultTableGenerator != null) {
			this.defaultTableGenerator.alignNextValue(writer);
		}
	}
}
```


Overlapping Code:
```
er
@Slf4j
public class GeneratorContext {
@RequiredArgsConstructor
private static final class GeneratorId {
private final String id;
private final GeneratorTable table;
@Override
public boolean equals(final Object obj) {
if (obj instanceof GeneratorId) {
final GeneratorId other = (GeneratorId) obj;
return this.id.equals(other.id) && Objects.equals(this.table, other.table);
}
return false;
}
@Override
public int hashCode() {
if (this.table == null) {
return this.id.hashCode();
}
return this.id.hashCode() << 2 | this.table.getName().hashCode();
}
@Override
public String toString() {
if (this.table == null) {
return this.id;
}
return this.id + '.' + this.table.getName();
}
}
/**
* The settings key for the JPA provider.
*
* Contains either the fully qualified class name of an extension of {@link JpaProvider} or the simple name of one
* of the classes from {@code org.fastnate.generator.provider}.
*
* Defaults to {@code HibernateProvider}.
*/
public static final String PROVIDER_KEY = "fastnate.generator.jpa.provider";
/** The settings key for the path to the persistence.xml, either relative to the current directory or absolute. */
public static final String PERSISTENCE_FILE_KEY = "fastnate.generator.persistence.file";
/**
* The settings key for the name of the persistence unit in the persistence.xml. The first persistence unit is used,
* if none is explicitly set.
*/
public static final String PERSISTENCE_UNIT_KEY = "fastnate.generator.persistence.unit";
/**
* The settings key for the target SQL dialect.
*
* <p>
* Contains either the fully qualified name of a class that extends {@link GeneratorDialect} or the simple class
* name of one of the classes from {@code org.fastnate.generator.dialect}. The suffix 'Dialect' may be omitted in
* that case. For example 'MySql' would map to {@code org.fastnate.generator.dialect.MySqlDialect}.
* </p>
*
* <p>
* If no dialect is set explicitly then the configured {@link #PERSISTENCE_FILE_KEY persistence.xml} is scanned for
* a connection URL or provider specific dialect, which would be converted to our known dialects.
* </p>
*
* <p>
* If nothing is found, H2 is used as default.
* </p>
*/
public static final String DIALECT_KEY = "fastnate.generator.dialect";
/** The settings key for {@link #writeNullValues}. */
public static final S
```
<Overlap Ratio: 0.9766454352441614>

---

--- 78 --
Question ID: 18f7547b44b2b2974aef71b924ad9511ffe70652
Original Code:
```
public class Client implements Serializable {
	
	/**
	 * Defines a type of client.
	 * @author K. Benedyczak
	 */
	public static enum Type {
		/**
		 * The object represents an external client who was somehow 
		 * authenticated.
		 */
		AUTHENTICATED, 
		/**
		 * The object represents an external client who was not authenticated, 
		 * i.e. we don't know who it is
		 */
		ANONYMOUS,
		/**
		 * The object is associated with an operation invoked by the local server
		 * code on its own behalf 
		 */
		LOCAL
	}; 
	
	private static final long serialVersionUID=1L;
	
	//for some use cases, credentials are stored in the client object
	public static final String ATTRIBUTE_CREDENTIALS_USERNAME="creds.username";
	public static final String ATTRIBUTE_CREDENTIALS_PASSWORD="creds.password";
	
	//for storing the email address in the attributes
	public static final String ATTRIBUTE_USER_EMAIL="user.email";
	
	/**
	 * Fake DN used to identify an anonymous client. It is used just not to return null.
	 */
	public static final String ANONYMOUS_CLIENT_DN = "CN=ANONYMOUS,O=UNKNOWN,OU=UNKNOWN";

	/**
	 * Fake DN used to identify a local client.
	 */
	public static final String LOCAL_CLIENT_DN = "CN=Local_call";

	
	//the token by which a client is identified
	private SecurityTokens secTokens;
	
	//what kind of client
	private Type type; 
	
	//the (set of) possible unix login name(s) and groups optionally with the preferred one
	private Xlogin xlogin;

	//the role of the client
	private Role role;
	
	//list of VOs the user is a member of
	private String[] vos;
	
	//VO under which the request is performed, may be null
	private String vo;
	
	private Queue queue;
	
	
	//all attributes that were established by attribute sources.
	private SubjectAttributesHolder subjectAttributes;
	
	//additional attributes may contain things relevant on the target system 
	//such as license keys, ... In most cases subjectAttributes are what you need.
	private final Map<String,String> extraAttributes;
	
	/**
	 * Constructs an anonymous Client. Setters must be used to fully configure
	 * the Client.
	 */
	public Client() {
		setAnonymousClient();
		extraAttributes = new HashMap<String,String>();
		setSubjectAttributes(new SubjectAttributesHolder());
		xlogin = new Xlogin();
		role = new Role();
		vos = new String[0];
		queue = new Queue();
	}
	
	public String toString() {
		StringBuilder cInfo = new StringBuilder();
		
		cInfo.append("Name: ");
		cInfo.append(X500NameUtils.getReadableForm(getDistinguishedName()));
		cInfo.append("\nXlogin: ");
		cInfo.append(getXlogin());
		cInfo.append("\nRole: ");
		cInfo.append(getRole());
		if (queue.getValidQueues().length > 0) {
			cInfo.append("\nQueues: ");
			cInfo.append(queue);
		}
		if (vos.length > 0) {
			cInfo.append("\nVOs: ");
			cInfo.append(Arrays.toString(vos));
		}
		if (vo != null) {
			cInfo.append("\nSelected VO: ").append(vo);
		}
		if (secTokens != null)
		{
			cInfo.append("\nSecurity tokens: ");
			cInfo.append(secTokens);
		}	
		return cInfo.toString(); 
	}


	/**
	 * @return type of this client
	 */
	public Type getType() {
		return type;
	}

	/**
	 * Makes this client ANONYMOUS 
	 */
	public void setAnonymousClient() {
		this.type = Type.ANONYMOUS;
		this.secTokens = null;
	}

	/**
	 * Makes this client LOCAL 
	 */
	public void setLocalClient() {
		this.type = Type.LOCAL;
		this.secTokens = null;
	}

	/**
	 * Sets the type of this client basing on SecurityTokens - 
	 * it can be AUTHENTICATED or ANONYMOUS. 
	 * @param secTokens security tokens established during authentication 
	 */
	public void setAuthenticatedClient(SecurityTokens secTokens) {
		this.secTokens = secTokens;
		if (secTokens == null || secTokens.getEffectiveUserName() == null) {
			this.type = Type.ANONYMOUS;
			return;
		}
		this.type = Type.AUTHENTICATED;
	}

	/**
	 * @return Returns the {@link SecurityTokens} or null if 
	 * the client is not of AUTHENTICATED type
	 */
	public SecurityTokens getSecurityTokens() {
		return secTokens;
	}

	/**
	 * @return the client's distinguished name. For authenticated 
	 * clients it is the effective user's name. For other types of clients one 
	 * of predefined constants is returned. This method never returns null.
	 */
	public String getDistinguishedName() {
		if (type == Type.ANONYMOUS)
			return ANONYMOUS_CLIENT_DN;
		else if (type == Type.LOCAL)
			return LOCAL_CLIENT_DN;
		else
			return secTokens.getEffectiveUserName();
	}
	
	
	//****************** INCARNATION AND AUTHZ PART *******************************
	
	
	/**
	 * @return Returns the role.
	 */
	public Role getRole() {
		return role;
	}
	
	/**
	 * @param role The role to set.
	 */
	public void setRole(Role role) {
		this.role = role;
	}

	
	public Map<String, String> getExtraAttributes() {
		return extraAttributes;
	}
	
	/**
	 * convenience method for getting the user's xlogin
	 * @return an {@link Xlogin}
	 */
	public Xlogin getXlogin(){
		return xlogin;
	}
	
	/**
	 * convenience method for setting the user's xlogin
	 */
	public void setXlogin(Xlogin xlogin){
		if (xlogin == null)
			throw new IllegalArgumentException("Setting null xlogin is prohibited.");
		this.xlogin=xlogin;
	}

	/**
	 * Convenience method returning the selected Xlogin name.
	 */
	public String getSelectedXloginName() {
		return xlogin.getUserName();
	}

	/**
	 * Convenience method setting the selected Xlogin name.
	 * @param userName
	 */
	public void setSelectedXloginName(String userName) {
		xlogin.setSelectedLogin(userName);
	}

	public String getUserEmail(){
		return (String)extraAttributes.get(ATTRIBUTE_USER_EMAIL);
	}
	
	public void setUserEmail(String email){
		if(email==null) {
			extraAttributes.remove(ATTRIBUTE_USER_EMAIL);
		}
		else{
			extraAttributes.put(ATTRIBUTE_USER_EMAIL,email);
		}
	}

	public void setSubjectAttributes(SubjectAttributesHolder subjectAttributes) {
		this.subjectAttributes = subjectAttributes;
	}

	public SubjectAttributesHolder getSubjectAttributes() {
		return subjectAttributes;
	}

	public String[] getVos() {
		return vos;
	}

	public void setVos(String[] vos) {
		if (vos == null)
			throw new IllegalArgumentException("Can not set null VOs array, use empty array instead");
		this.vos = vos;
	}

	public Queue getQueue() {
		return queue;
	}

	public void setQueue(Queue queue) {
		if (queue == null)
			throw new IllegalArgumentException("Can not set null Queue object, use empty Queue instead");
		this.queue = queue;
	}
	
	/**
	 * @return the selected VO or null if request is not VO bound
	 */
	public String getVo() {
		return vo;
	}

	/**
	 * @param vo the vo to set. Must be one of VOs set for this object
	 * @throws IllegalArgumentException if argument is not in all client's VOs.
	 */
	public void setVo(String vo) {
		for (String v: vos)
			if (v.equals(vo))
			{
				this.vo = vo;
				return;
			}
		throw new IllegalArgumentException("The selected VO '" + vo + 
				"' is not one of the VOs the client is memeber of");
	}
}
```


Overlapping Code:
```
class Client implements Serializable {

/**
* Defitatic enum Type {
/**
* The object represents an external client who was somehow 
* authenticated.
*/
AUTHENTICATED, 
/**
* The object represents an external client who was not authenticated, 
* i.e. we don't know who it is
*/
ANONYMOUS,
/**
* The object is associated with an operation invoked by the local server
* code on its own behalf 
*/
LOCAL
}; 

private static final long serialVersionUID=1L;

//for some use cases, credentials are stored in the client object
public static final String ATTRIBUTE_CREDENTIALS_USERNAME="creds.username";
public static final String ATTRIBUTE_CREDENTIALS_PASSWOin the attributes
public static final String ATTRIBUTE_USER_EMAIL="user.email";

/**
* Fake DN used to identify an anonymous client. It is used just not to return null.
*/
public static final String ANONYMOUS_CLIENT_DN = "CN=ANONYMOUS,O=UNKNOWN,OU=UNKNOWN";
/**
* Fake DN used to identify a local client.
*/
public static final String LOCAL_CLIENT_DN = "CN=Local_call";

//the token by which a client is identified
private SecurityTokens secTokens;

//what kind of client
private Type type; 

//the (set of) possible unix login name(s) and groups optionally with the preferred one
private Xlogin xlogin;
//the role of the client
private Role role;

//list of VOs the user is a member of
private String[] vos;

//VO under which the request is performed, may be null
private String vo;

private Queue queue;


//all attributes that were established by attribute sources.
private SubjectAttributesHolder subjectAttributes;

//additional attributes may contain things relevant on the target system 
//such as license keys, ... In most cases subjectAttributes are what you need.
private final Map<String,String> extraAttributes;

/**
* Constructs an anonymous Client. Setters must be used to fully configure
* the Client.
*/
public Client() {
setAnonymousClient();
extraAttributes = new HashMap<String,String>();
setSubjectAttributes(new SubjectAttributesHolder());
xlogin = new Xlogin();
role = new Role();
vos = new String[0];
queue = new Queue();
}

public String toString() {
StringBuilder cInfo = new StringBuilder();

cInfo.append("Name: ");
cInfo.a
```
<Overlap Ratio: 0.9306260575296108>

---

--- 79 --
Question ID: 7dbf614e5287401f356ffad615bbbfb2b01433c6
Original Code:
```
public class Particle {

	protected Bitmap mImage;
	
	@Px
	public float mCurrentX;
	@Px
	public float mCurrentY;
	
	public float mScale = 1f;
	public int mAlpha = 255;
	
	public float mInitialRotation = 0f;
	
	public float mRotationSpeed = 0f;
	
	public float mSpeedX = 0f;
	public float mSpeedY = 0f;

	public float mAccelerationX;
	public float mAccelerationY;

	private Matrix mMatrix;
	private Paint mPaint;

	@Px
	private float mInitialX;
	@Px
	private float mInitialY;

	private float mRotation;

	private long mTimeToLive;

	protected long mStartingMillisecond;

	@Px
	private int mBitmapHalfWidth;
	@Px
	private int mBitmapHalfHeight;

	private List<ParticleModifier> mModifiers;


	protected Particle() {		
		mMatrix = new Matrix();
		mPaint = new Paint();
	}
	
	public Particle(Bitmap bitmap) {
		this();
		mImage = bitmap;
	}

	public void init() {
		mScale = 1;
		mAlpha = 255;	
	}
	
	public void configure(long timeToLive, @Px float emitterX, @Px float emitterY) {
		mBitmapHalfWidth = mImage.getWidth()/2;
		mBitmapHalfHeight = mImage.getHeight()/2;
		
		mInitialX = emitterX - mBitmapHalfWidth;
		mInitialY = emitterY - mBitmapHalfHeight;
		mCurrentX = mInitialX;
		mCurrentY = mInitialY;
		
		mTimeToLive = timeToLive;
	}

	public boolean update(long milliseconds) {
		long realMilliseconds = milliseconds - mStartingMillisecond;
		if (realMilliseconds > mTimeToLive) {
			return false;
		}
		mCurrentX = mInitialX+mSpeedX*realMilliseconds+mAccelerationX*realMilliseconds*realMilliseconds;
		mCurrentY = mInitialY+mSpeedY*realMilliseconds+mAccelerationY*realMilliseconds*realMilliseconds;
		mRotation = mInitialRotation + mRotationSpeed*realMilliseconds/1000;
		for (int i=0; i<mModifiers.size(); i++) {
			mModifiers.get(i).apply(this, realMilliseconds);
		}
		return true;
	}
	
	public void draw(@NonNull Canvas c) {
		mMatrix.reset();
		mMatrix.postRotate(mRotation, mBitmapHalfWidth, mBitmapHalfHeight);
		mMatrix.postScale(mScale, mScale, mBitmapHalfWidth, mBitmapHalfHeight);
		mMatrix.postTranslate(mCurrentX, mCurrentY);
		mPaint.setAlpha(mAlpha);		
		c.drawBitmap(mImage, mMatrix, mPaint);
	}

	public Particle activate(long startingMillisecond, @NonNull List<ParticleModifier> modifiers) {
		mStartingMillisecond = startingMillisecond;
		// We do store a reference to the list, there is no need to copy, since the modifiers do not care about states
		mModifiers = modifiers;
		return this;
	}
}
```


Overlapping Code:
```
rticle {
protected Bitmap mImage;

@Px
public float mCurrentX;
@Px
public float mCurrentY;

public float mScale = 1f;
public int mAlpha = 255;

public float mInitialRotation = 0f;

public float mRotationSpeed = 0f;

public float mSpeedX = 0f;
public float mSpeedY = 0f;
public float mAccelerationX;
public float mAccelerationY;
private Matrix mMatrix;
private Paint mPaint;
@Px
private float mInitialX;
@Px
private float mInitialY;
private float mRotation;
private long mTimeToLive;
protected long mStartingMillisecond;
@Px
private int mBitmapHalfWidth;
@Px
private int mBitmapHalfHeight;
private List<ParticleModifier> mModifiers;
protected Particle() { 
mMatrix = new Matrix();
mPaint = new Paint();
}

public Particle(Bitmap bitmap) {
this();
mImage = bitmap;
}
public void init() {
mScale = 1;
mAlpha = 255; 
}

public void configure(long timeToLive, @Px float emitterX, @Px float emitterY) {
mBitmapHalfWidth = mImage.getWidth()/2;
mBitmapHalfHeight = mImage.getHeight()/2;

mInitialX = emitterX - mBitmapHalfWidth;
mInitialY = emitterY - mBitmapHalfHeight;
mCurrentX = mInitialX;
mCurrentY = mInitialY;

mTimeToLive = timeToLive;
}
public boolean update(long milliseconds) {
long realMilliseconds = milliseconds - mStartingMillisecond;
if (realMilliseconds > mTimeToLive) {
return false;
}
mCurrentX = mInitialX+mSpeedX*realMilliseconds+mAccelerationX*realMilliseconds*realMilliseconds;
mCurrentY = mInitialY+mSpeedY*realMilliseconds+mAccelerationY*realMilliseconds*realMilliseconds;
mRotation = mInitialRotation + mRotationSpeed*realMilliseconds/1000;
for (int i=0; i<mModifiers.size(); i++) {
mModifiers.get(i).apply(this, realMilliseconds);
}
return true;
}

public void draw(@NonNull Canvas c) {
mMatrix.reset();
mMatrix.postRotate(mRotation, mBitmapHalfWidth, mBitmapHalfHeight);
mMatrix.postScale(mScale, mScale, mBitmapHalfWidth, mBitmapHalfHeight);
mMatrix.postTranslate(mCurrentX, mCurrentY);
mPaint.setAlpha(mAlpha); 
c.drawBitmap(mImage, mMatrix, mPaint);
}
public Particle activate(long startingMillisecond, @NonNull List<ParticleModifier> modifiers) {
mStartingMillisecond = startingMillisecond;
// We do store a reference to the list, there is no need to copy, since the modifiers do not care about states
mModifiers = modifiers;

```
<Overlap Ratio: 0.9864094695309075>

---

--- 80 --
Question ID: 18bc265c1b387562a8b492ea56c691d6b36373cd
Original Code:
```
class DelugeProgramOutput {

    static DelugeProgramOutput from(RunnerProgramOutput programOutput) {
        final var output = programOutput.output();
        final var duration = programOutput.executionDuration();
        final var error = programOutput.error().orElse(null);
        return new DelugeProgramOutput(output, duration, error);
    }

    static DelugeProgramOutput from(String[] output, Duration duration, Exception error) {
        return new DelugeProgramOutput(output, duration, error);
    }

    private final String[] output;

    private final Exception error;

    private final Duration duration;

    private DelugeProgramOutput(String[] output, Duration duration, Exception error) {
        this.output = output;
        this.duration = duration;
        this.error = error;
    }

    String[] output() {
        return output;
    }

    Exception error() {
        return error;
    }

    Duration executionDuration() {
        return duration;
    }

}
```


Overlapping Code:
```
ic DelugeProgramOutput from(RunnerProgramOutput programOutput) {
final var output = programOutput.output();
final var duration = programOutput.executionDuration();
final var error = programOutput.error().orElse(null);
return new DelugeProgramOutput(output, duration, error);
}
static DelugeProgramOutput from(String[] output, Duration duration, Exception error) {
return new DelugeProgramOutput(output, duration, error);
}
private final String[] output;
private final Exception error;
private final Duration duration;
private DelugeProgramOutput(String[] output, Duration duration, Exception error) {
this.output = output;
this.duration = duration;
this.error = error;
}
String[] output() {
return output;
}
Exception error() {
return error;
}
Durati
```
<Overlap Ratio: 0.9068923821039904>

---

--- 81 --
Question ID: 79d90f5d351dd78c45772f5bab87c78bec8d13e9
Original Code:
```
@Immutable
@Deprecated
class DefaultRedirectStrategyAdaptor implements RedirectStrategy {

    private final ch.boye.httpclientandroidlib.client.RedirectHandler handler;

    @Deprecated
    public DefaultRedirectStrategyAdaptor(final ch.boye.httpclientandroidlib.client.RedirectHandler handler) {
        super();
        this.handler = handler;
    }

    public boolean isRedirected(
            final HttpRequest request,
            final HttpResponse response,
            final HttpContext context) throws ProtocolException {
        return this.handler.isRedirectRequested(response, context);
    }

    public HttpUriRequest getRedirect(
            final HttpRequest request,
            final HttpResponse response,
            final HttpContext context) throws ProtocolException {
        URI uri = this.handler.getLocationURI(response, context);
        String method = request.getRequestLine().getMethod();
        if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {
            return new HttpHead(uri);
        } else {
            return new HttpGet(uri);
        }
    }

}
```


Overlapping Code:
```

@Deprecated
class DefaultRedirectStrategyAdaptor implements RedirectStrategy {
private final ch.boye.httpclientandroidlib.client.RedirectHandler handler;
@Deprecated
public DefaultRedirectStrategyAdaptor(final ch.boye.httpclientandroidlib.client.RedirectHandler handler) {
super();
this.handler = handler;
}
public boolean isRedirected(
final HttpRequest request,
final HttpResponse response,
final HttpContext context) throws ProtocolException {
return this.handler.isRedirectRequested(response, context);
}
public HttpUriRequest getRedirect(
final HttpRequest request,
final HttpResponse response,
final HttpContext context) throws ProtocolException {
URI uri = this.handler.getLocationURI(response, context);
String method = request.getRequestLine().getMethod();
if (method.equalsIgnoreCase(HttpHead.METHOD_NAME)) {
return new HttpHead(uri);
} else {
return new HttpGet(uri)
```
<Overlap Ratio: 0.9810055865921787>

---

--- 82 --
Question ID: 3c3d78c7d10506ab65a2e42e2db20acc6594fa83
Original Code:
```
@Slf4j
public class TransactionInfoEnricher {
    private final Map<String, ConfigValue> shopKeyWordsToConfigMap;
    private final AdditionalSourceManager additionalSourceManager;

    public TransactionInfoEnricher(@Nullable KeyWordsToCategoryMapJsonParser config, AdditionalSourceManager additionalSourceManager) {
        this.shopKeyWordsToConfigMap = config != null ? config.getShopMapping() : Collections.emptyMap();
        this.additionalSourceManager = additionalSourceManager;
    }

    private static MoneyTransaction enrichCategoryOrWallet(MoneyTransaction transaction, String categoryOrWallet) {
        if (transaction.getOperationType() == OperationType.TRANSFER) {
            return enrichWallet(transaction, categoryOrWallet);
        }
        return enrichCategory(transaction, categoryOrWallet);
    }

    private static MoneyTransaction enrichCategory(MoneyTransaction transaction, String categoryOrWallet) {
        return transaction.toBuilder()
                .category(categoryOrWallet)
                .build();
    }

    private static MoneyTransaction enrichWallet(MoneyTransaction transaction, String categoryOrWallet) {
        // One of wallet already filled with default wallet value
        // Fill other (not filled) wallet
        if (transaction.getSourceWallet() == null) {
            return transaction.toBuilder()
                    .sourceWallet(categoryOrWallet)
                    .build();
        }
        if (transaction.getTargetWallet() == null) {
            return transaction.toBuilder()
                    .targetWallet(categoryOrWallet)
                    .build();
        }
        return transaction;
    }

    private MoneyTransaction fillFromConfig(MoneyTransaction transaction, ConfigValue config) {
        return Optional.of(transaction)
                .map(tr -> enrichCategoryOrWallet(tr, config.getCategory()))
                .map(tr -> enrichWithAdditionalDescriptionIfExist(tr, config.getAdditionalDescription()))
                .orElseThrow(RuntimeException::new);
    }

    private MoneyTransaction enrichWithAdditionalDescriptionIfExist(MoneyTransaction tr, @Nullable String additionalDescription) {
        return Optional.ofNullable(additionalDescription)
                .map(description -> enrichWithAdditionalDescription(tr, description))
                .orElse(tr);
    }

    private MoneyTransaction enrichWithAdditionalDescription(MoneyTransaction tr, String additionalDescription) {
        return tr.toBuilder()
                .description(String.format("%s (%s)", additionalDescription, tr.getDescription()))
                .build();
    }

    private MoneyTransaction fillTransactionByShopName(MoneyTransaction transaction) {
        return shopKeyWordsToConfigMap.entrySet().stream()
                .filter(entry -> transaction.getDescription().toLowerCase().contains(entry.getKey().toLowerCase()))
                .findFirst()
                .map(entry -> fillFromConfig(transaction, entry.getValue()))
                .orElse(transaction);
    }

    public List<MoneyTransaction> fill(List<MoneyTransaction> transactionList) {
        return transactionList.stream()
                .map(this::fillTransactionByShopName)
                .map(this::fillTransactionFromAdditionalSources)
                .collect(Collectors.toList());
    }

    private MoneyTransaction fillTransactionFromAdditionalSources(MoneyTransaction moneyTransaction) {
        return additionalSourceManager.getAdditionalSources().stream()
                .filter(additionalSource -> moneyTransaction.getDescription().toLowerCase().contains(additionalSource.getSourceName().toLowerCase()))
                .findFirst()
                .map(additionalSource -> {
                    EnrichmentData enrichmentData = additionalSource.getEnrichmentData(moneyTransaction);
                    if (enrichmentData == null) {
                        return moneyTransaction;
                    }
                    String category = enrichmentData.getCategory();
                    String additionalDescription = enrichmentData.getAdditionalDescription();
                    if (category != null || additionalDescription != null) {
                        MoneyTransaction.MoneyTransactionBuilder builder = moneyTransaction.toBuilder();
                        if (category != null) {
                            builder.category(category);
                        }
                        if (additionalDescription != null) {
                            builder.description(moneyTransaction.getDescription() + ": " + additionalDescription);
                        }
                        return builder.build();
                    }
                    return moneyTransaction;
                })
                .orElse(moneyTransaction);
    }

}
```


Overlapping Code:
```
nfoEnricher {
private final Map<String, ConfigValue> shopKeyWordsToConfigMap;
private final AdditionalSourceManager additionalSourceManager;
public TransactionInfoEnricher(@Nullable KeyWordsToCategoryMapJsonParser config, AdditionalSourceManager additionalSourceManager) {
this.shopKeyWordsToConfigMap = config != null ? config.getShopMapping() : Collections.emptyMap();
this.additionalSourceManager = additionalSourceManager;
}
private static MoneyTransaction enrichCategoryOrWallet(MoneyTransaction transaction, String categoryOrWallet) {
if (transaction.getOperationType() == OperationType.TRANSFER) {
return enrichWallet(transaction, categoryOrWallet);
}
return enrichCategory(transaction, categoryOrWallet);
}
private static MoneyTransaction enrichCategory(MoneyTransaction transaction, String categoryOrWallet) {
return transaction.toBuilder()
.category(categoryOrWallet)
.build();
}
private static MoneyTransaction enrichWallet(MoneyTransaction transaction, String categoryOrWallet) {
// One of wallet already filled with default wallet value
// Fill other (not filled) wallet
if (transaction.getSourceWallet() == null) {
return transaction.toBuilder()
.sourceWallet(categoryOrWallet)
.build();
}
if (transaction.getTargetWallet() == null) {
return transaction.toBuilder()
.targetWallet(categoryOrWallet)
.build();
}
return transaction;
}
private MoneyTransaction fillFromConfig(MoneyTransaction transaction, ConfigValue config) {
return Optional.of(transaction)
.map(tr -> enrichCategoryOrWallet(tr, config.getCategory()))
.map(tr -> enrichWithAdditionalDescriptionIfExist(tr, config.getAdditionalDescription()))
.orElseThrow(RuntimeException::new);
}
private MoneyTransaction enrichWithAdditionalDescriptionIfExist(MoneyTransaction tr, @Nullable String additionalDescription) {
return Optional.ofNullable(additionalDescription)
.map(description -> enrichWithAdditionalDescription(tr, description))
.orElse(tr);
}
private MoneyTransaction enrichWithAdditionalDescription(MoneyTransaction tr, 
```
<Overlap Ratio: 0.9633911368015414>

---

--- 83 --
Question ID: 6f04cc5ed56709438efe1cf437002b0282a4c263
Original Code:
```
public class ModuleExtractor {
	private static String sigParseLog;
	private static SimpleShortFormProvider sf = new SimpleShortFormProvider();
	
    // Parse & tokenize signature file
    public static Set<OWLEntity> getSignature(OWLOntology ontology, BufferedReader file) throws IOException {
        Set<OWLEntity> sig = new HashSet<OWLEntity>();
        OWLOntologyManager man = ontology.getOWLOntologyManager();
        OWLDataFactory df = man.getOWLDataFactory();
        sigParseLog = "";

        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();
        
        boolean snomed = false;
        boolean termsFound = false, notFound = false;
        String termsIri = "";
        
        // Check entity IRIs for Snomed concepts 
        loopClasses:
        for(OWLClass c : ontology.getClassesInSignature()) {
        	if(c.getIRI().toString().contains("www.ihtsdo.org")) {
        		snomed = true;
        		termsIri += c.getIRI().toString();
        		termsIri = termsIri.substring(0, termsIri.indexOf(".org/")+5);
        		break loopClasses;
        	}
        }
        
        if(ontIri.toString().contains("www.ihtsdo.org")) {
        	snomed = true;
        	termsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(".org/")+5);
        }
        
        if(snomed) {
        	file.readLine();
            while (file.ready()) {
                String s = file.readLine();
                int pos = s.indexOf("|");
                if(pos < 0) throw new RuntimeException("There is no '|' in:   ");
                
                s = "SCT_" + s.substring(0,pos);
                IRI iri = IRI.create(termsIri + s);
                OWLClass cls = df.getOWLClass(iri);
                if (ontology.containsClassInSignature(iri)) {
                    sig.add(cls);
                    termsFound=true;
                }
                else {
                    sigParseLog += "\nThere is no class " + iri + " in the ontology.";
                    notFound = true;
                }
            }
            
            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + "RoleGroup");
            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);
            
            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {
                sig.add(roleGroup);
                sigParseLog += "\nRoleGroup added.";
            }
        }
        else {	// Use StringTokenizer
	        String delimiters = "	|, ";	// Delimiters allowed
	        String strLine = "";
	        while ((strLine = file.readLine()) != null) {
	        	// Skip commented lines
	        	if(!strLine.startsWith("%")) {
	        		if(strLine.contains("%"))
	        			strLine = strLine.substring(0, strLine.indexOf("%"));
	        		
	        		StringTokenizer st = new StringTokenizer(strLine, delimiters, false);
		        	
		        	while(st.hasMoreTokens()) {
		        		String s = st.nextToken();
		        		System.out.println("Token from signature file: " + s );
		        		IRI termIri = findTermIRI(ontology, s,df);
		        		if(termIri!=null){
			            if(ontology.containsClassInSignature(termIri)) {
			            	OWLClass cls = df.getOWLClass(termIri);
			                sig.add(cls); termsFound=true;
			                System.out.println("\tOWL class. IRI: " + termIri.toString());
			            }
			            else if(ontology.containsObjectPropertyInSignature(termIri)) {
			            	OWLObjectProperty prop = df.getOWLObjectProperty(termIri);
			            	sig.add(prop); termsFound=true;
			            	System.out.println("\tOWL object property. IRI: " + termIri.toString());
			            }
			            else if(ontology.containsDataPropertyInSignature(termIri)) {
			            	OWLDataProperty prop = df.getOWLDataProperty(termIri);
			            	sig.add(prop); termsFound=true;
			            	System.out.println("\tOWL data property. IRI: " + termIri.toString());
			            }
			            else {
			                sigParseLog += "\nThere is no term " + termIri + " in the ontology.";
			                System.out.println("\t! The term " + termIri + " is not in the ontology.");
			                notFound = true;
			            }
		        	}}
	        	}
	        }
        }
        sigParseLog += "\n" + sig.size() + " term(s) found. ";
        if(!termsFound && !notFound) sigParseLog += "Signature file is empty!";
        return sig;
    }
    
    public static IRI findTermIRI(OWLOntology ont, String name, OWLDataFactory df) {
    	IRI out = null;
    	IRI tempIRI = IRI.create(name);
    	for(OWLEntity c : ont.getClassesInSignature()){ 
    		if(c.getIRI().equals(tempIRI)) {
    			out = c.getIRI();
    			break;
    		}
    		else{
    			String str=null;
    			for (OWLDataProperty annotation : c.getDataPropertiesInSignature() ) {  
    				  if (((OWLAnnotation) annotation).getValue() instanceof OWLLiteral) { 
    				    OWLLiteral val = (OWLLiteral) ((OWLAnnotation) annotation).getValue();
    				    str=val.getLiteral();
    				    		       
    				      }
    				   }
    			if(str==null)
    			str=getManchesterSyntax(c);
    		  ISub mes=new ISub();
    		 //EditDistance mes=new EditDistance();
    		//  WordNetMatcher wn=new WordNetMatcher();
    		//double sim=  wn.compute(str, name);
    		 double sim= mes.getSimilarity(str, name);
    		//System.out.println(str+"\t"+name+"\t"+sim);
    		  if(sim>=0.6) {
    			out = c.getIRI();
    			break;
    		}}
    	}
    	//System.out.println("the URI \t"+out);
    	    	
    	return out;
    }
    
    public static String getSignatureParseLog() {
    	return sigParseLog;
    }

    public static OWLOntology extractModule(Set<OWLEntity> signature, OWLOntology o, String modName, ModuleType moduleType) 
    		throws OWLOntologyCreationException {
        SyntacticLocalityModuleExtractor extractor = new SyntacticLocalityModuleExtractor(o.getOWLOntologyManager(), o, moduleType);
        return extractor.extractAsOntology(signature, IRI.create(modName));
    }
    
	private static String getManchesterSyntax(OWLObject obj) {
		StringWriter wr = new StringWriter();
		ManchesterOWLSyntaxObjectRenderer render = new ManchesterOWLSyntaxObjectRenderer(wr, sf);
		obj.accept(render);
		String str = wr.getBuffer().toString();
		return str;
	}
	
	  // Parse & tokenize signature list
    public static Set<OWLEntity> getSignature(OWLOntology ontology, ArrayList<String> terms)  {
        Set<OWLEntity> sig = new HashSet<OWLEntity>();
        OWLOntologyManager man = ontology.getOWLOntologyManager();
        OWLDataFactory df = man.getOWLDataFactory();
        sigParseLog = "";

        IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();
        
        boolean snomed = false;
        boolean termsFound = false, notFound = false;
        String termsIri = "";
        
        // Check entity IRIs for Snomed concepts 
        loopClasses:
        for(OWLClass c : ontology.getClassesInSignature()) {   
        	if(c.getIRI().toString().contains("www.ihtsdo.org")) {
        		snomed = true;
        		termsIri += c.getIRI().toString();
        		termsIri = termsIri.substring(0, termsIri.indexOf(".org/")+5);
        		break loopClasses;
        	}
        }
        
      if(ontIri!=null) { if(ontIri.toString().contains("www.ihtsdo.org")) {
        	snomed = true;
        	termsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(".org/")+5);
        }}
        
        if(snomed) {
        	
            for (int i=0; i<terms.size(); i++) {
                String s = terms.get(i);//file.readLine();
                int pos = s.indexOf("|");
                if(pos < 0) throw new RuntimeException("There is no '|' in:   ");
                
                s = "SCT_" + s.substring(0,pos);
                IRI iri = IRI.create(termsIri + s);
                OWLClass cls = df.getOWLClass(iri);
                if (ontology.containsClassInSignature(iri)) {
                    sig.add(cls);
                    termsFound=true;
                }
                else {
                    sigParseLog += "\nThere is no class " + iri + " in the ontology.";
                    notFound = true;
                }
            }
            
            IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + "RoleGroup");
            OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);
            
            if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {
                sig.add(roleGroup);
                sigParseLog += "\nRoleGroup added.";
            }
        }
        else {	// Use StringTokenizer
	        String delimiters = "	|, ";	// Delimiters allowed
	        String strLine = "";
	        for (int j=0; j<terms.size();j++) {
	        	strLine=terms.get(j);
	        	// Skip commented lines
	        	if(!strLine.startsWith("%")) {
	        		if(strLine.contains("%"))
	        			strLine = strLine.substring(0, strLine.indexOf("%"));
	        		
	        		StringTokenizer st = new StringTokenizer(strLine, delimiters, false);
		        	
		        	while(st.hasMoreTokens()) {
		        		String s = st.nextToken();
		        		//System.out.println("Token from signature file: " + s );
		        		IRI termIri = findTermIRI(ontology, s,df);
		        		if(termIri!=null){
			            if(ontology.containsClassInSignature(termIri)) {
			            	OWLClass cls = df.getOWLClass(termIri);
			                sig.add(cls); termsFound=true;
			               // System.out.println("\tOWL class. IRI: " + termIri.toString());
			            }
			            else if(ontology.containsObjectPropertyInSignature(termIri)) {
			            	OWLObjectProperty prop = df.getOWLObjectProperty(termIri);
			            	sig.add(prop); termsFound=true;
			            	//System.out.println("\tOWL object property. IRI: " + termIri.toString());
			            }
			            else if(ontology.containsDataPropertyInSignature(termIri)) {
			            	OWLDataProperty prop = df.getOWLDataProperty(termIri);
			            	sig.add(prop); termsFound=true;
			            	//System.out.println("\tOWL data property. IRI: " + termIri.toString());
			            }
			            else {
			                sigParseLog += "\nThere is no term " + termIri + " in the ontology.";
			                //System.out.println("\t! The term " + termIri + " is not in the ontology.");
			                notFound = true;
			            }
		        	}}
	        	}
	        }
        }
        sigParseLog += "\n" + sig.size() + " term(s) found. ";
        if(!termsFound && !notFound) sigParseLog += "Signature file is empty!";
        return sig;
    }
}
```


Overlapping Code:
```
c class ModuleExtractor {
private static String sigParseLog;
private static SimpleShortFormProvider sf = new SimpleShortFormProvider();

// Parse & tokenize signature file
public static Set<OWLEntity> getSignature(OWLOntology ontology, BufferedReader file) throws IOException {
Set<OWLEntity> sig = new HashSet<OWLEntity>();
OWLOntologyManager man = ontology.getOWLOntologyManager();
OWLDataFactory df = man.getOWLDataFactory();
sigParseLog = "";
IRI ontIri = ontology.getOntologyID().getDefaultDocumentIRI();

boolean snomed = false;
boolean termsFound = false, notFound = false;
String termsIri = "";

// Check entity IRIs for Snomed concepts 
loopClasses:
for(OWLClass c : ontology.getClassesInSignature()) {
if(c.getIRI().toString().contains("www.ihtsdo.org")) {
snomed = true;
termsIri += c.getIRI().toString();
termsIri = termsIri.substring(0, termsIri.indexOf(".org/")+5);
break loopClasses;
}
}

if(ontIri.toString().contains("www.ihtsdo.org")) {
snomed = true;
termsIri = ontIri.toString().substring(0, ontIri.toString().indexOf(".org/")+5);
}

if(snomed) {
file.readLine();
while (file.ready()) {
String s = file.readLine();
int pos = s.indexOf("|");
if(pos < 0) throw new RuntimeException("There is no '|' in: ");

s = "SCT_" + s.substring(0,pos);
IRI iri = IRI.create(termsIri + s);
OWLClass cls = df.getOWLClass(iri);
if (ontology.containsClassInSignature(iri)) {
sig.add(cls);
termsFound=true;
}
else {
sigParseLog += "\nThere is no class " + iri + " in the ontology.";
notFound = true;
}
}

IRI roleGroupIRI = IRI.create(ontology.getOntologyID().getOntologyIRI() + "RoleGroup");
OWLObjectProperty roleGroup = df.getOWLObjectProperty(roleGroupIRI);

if (ontology.containsObjectPropertyInSignature(roleGroupIRI)) {
sig.add(roleGroup);
sigParseLog += "\nRoleGroup added.";
}
}
else { // U
```
<Overlap Ratio: 0.9787928221859706>

---

--- 84 --
Question ID: 05c6490c464f5fe68a723607c022f40d54fc7439
Original Code:
```
public final class StyleAndScriptIdentifier extends AbstractMarkupFilter
{
	/**
	 * Constructor.
	 */
	public StyleAndScriptIdentifier()
	{
	}

	@Override
	protected final MarkupElement onComponentTag(final ComponentTag tag) throws ParseException
	{
		if (tag.getNamespace() != null)
		{
			return tag;
		}

		String tagName = tag.getName();
		boolean isScript = XmlPullParser.SCRIPT.equalsIgnoreCase(tagName);
		boolean isStyle = XmlPullParser.STYLE.equalsIgnoreCase(tagName);
		if (isScript || isStyle)
		{
			if (tag.isOpen() && tag.getId() == null && ((isScript && tag.getAttribute("src") == null) || isStyle))
			{
				// Not needed, but must not be null
				tag.setId("_ScriptStyle");
				tag.setModified(true);
				tag.setAutoComponentTag(true);
				tag.setFlag(ComponentTag.RENDER_RAW, true);
			}
			
			tag.setUserData("STYLE_OR_SCRIPT", Boolean.TRUE);
		}

		return tag;
	}

	@Override
	public void postProcess(Markup markup)
	{
		for (int i = 0; i < markup.size(); i++)
		{
			MarkupElement elem = markup.get(i);
			if (elem instanceof ComponentTag)
			{
				ComponentTag open = (ComponentTag)elem;

				if (shouldProcess(open))
				{
					if (open.isOpen() && ((i + 2) < markup.size()))
					{
						MarkupElement body = markup.get(i + 1);
						MarkupElement tag2 = markup.get(i + 2);

						if ((body instanceof RawMarkup) && (tag2 instanceof ComponentTag))
						{
							ComponentTag close = (ComponentTag)tag2;
							if (close.closes(open))
							{
								String text = body.toString().trim();
								if (shouldWrapInCdata(text))
								{
									text = JavaScriptUtils.SCRIPT_CONTENT_PREFIX + body.toString() +
										JavaScriptUtils.SCRIPT_CONTENT_SUFFIX;
									markup.replace(i + 1, new RawMarkup(text));
								}
							}
						}
					}
				}
			}
		}
	}

	// OES == optional empty space

	// OES<!--OES
	private static final Pattern HTML_START_COMMENT = Pattern.compile("^\\s*<!--\\s*.*", Pattern.DOTALL);

	// OES<![CDATA[OES
	private static final Pattern CDATA_START_COMMENT = Pattern.compile("^\\s*<!\\[CDATA\\[\\s*.*", Pattern.DOTALL);

	// OES/*OES<![CDATA[OES*/OES
	private static final Pattern JS_CDATA_START_COMMENT = Pattern.compile("^\\s*\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/\\s*.*", Pattern.DOTALL);

	boolean shouldWrapInCdata(final String elementBody)
	{
		Args.notNull(elementBody, "elementBody");

		boolean shouldWrap = true;

		if (
				HTML_START_COMMENT.matcher(elementBody).matches() ||
				CDATA_START_COMMENT.matcher(elementBody).matches() ||
				JS_CDATA_START_COMMENT.matcher(elementBody).matches()
			)
		{
			shouldWrap = false;
		}

		return shouldWrap;
	}

	private boolean shouldProcess(ComponentTag openTag)
	{
		// do not wrap in CDATA any <script> which has special MIME type. WICKET-4425
		String typeAttribute = openTag.getAttribute("type");
		boolean shouldProcess =
				// style elements should be processed
				"style".equals(openTag.getName()) ||

				// script elements should be processed only if they have no type (HTML5 recommendation)
				// or the type is "text/javascript"
				(typeAttribute == null || "text/javascript".equalsIgnoreCase(typeAttribute));

		return shouldProcess && openTag.getUserData("STYLE_OR_SCRIPT") != null;
	}
}
```


Overlapping Code:
```
final class StyleAndScriptIdentifier extends AbstractMarkupFilter
{
/**
* Constructor.
*/
public StyleAndScriptIdentifier()
{
}
@Override
protected final MarkupElement onComponentTag(final ComponentTag tag) throws ParseException
{
if (tag.getNamespace() != null)
{
return tag;
}
String tagName = tag.getName();
boolean isScript = XmlPullParser.SCRIPT.equalsIgnoreCase(tagName);
boolean isStyle = XmlPullParser.STYLE.equalsIgnoreCase(tagName);
if (isScript || isStyle)
{
if (tag.isOpen() && tag.getId() == null && ((isScript && tag.getAttribute("src") == null) || isStyle))
{
// Not needed, but must not be null
tag.setId("_ScriptStyle");
tag.setModified(true);
tag.setAutoComponentTag(true);
tag.setFlag(ComponentTag.RENDER_RAW, true);
}

tag.setUserData("STYLE_OR_SCRIPT", Boolean.TRUE);
}
return tag;
}
@Override
public void postProcess(Markup markup)
{
for (int i = 0; i < markup.size(); i++)
{
MarkupElement elem = markup.get(i);
if (elem instanceof ComponentTag)
{
ComponentTag open = (ComponentTag)elem;
if (shouldProcess(open))
{
if (open.isOpen() && ((i + 2) < markup.size()))
{
MarkupElement body = markup.get(i + 1);
MarkupElement tag2 = markup.get(i + 2);
if ((body instanceof RawMarkup) && (tag2 instanceof ComponentTag))
{
ComponentTag close = (ComponentTag)tag2;
if (close.closes(open))
{
String text = body.toString().trim();
if (shouldWrapInCdata(text))
{
text = JavaScriptUtils.SCRIPT_CONTENT_PREFIX + body.toString() +
JavaScriptUtils.SCRIPT_CONTENT_SUFFIX;
markup.replace(i + 1, new RawMarkup(text));
}
}
}
}
}
}
}
}
// OES == optional empty space
// OES<!--OES
private static final Pattern HTML_START_COMMENT = Pattern.compile("^\\s*<!--\\s*.*", Pattern.DOTALL);
// OES<![CDATA[OES
private static final Pattern CDATA_START_COMMENT = Pattern.compile("^\\s*<!\\[CDATA\\[\\s*.*", Pattern.DOTALL);
// OES/*OES<![CDATA[OES*/OES
private static final Pattern JS_CDATA_START_COMMENT = Pattern.compile("^\\s*\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/\\s*.*", Pattern.DOTALL);
boolean shouldWrapInCdata(final String elementBody)
{
Args.notNull(elementBody, "elementBody");
boolean shouldWrap = true;
```
<Overlap Ratio: 0.9840674789128397>

---

--- 85 --
Question ID: b44adae5816e4318ec87fca8fd95f1a8ab6bf594
Original Code:
```
public class ImgDavaAndAvaForDouYin {

    public static void main(String[] args) {
        int size = 3;
        int h = 720;
        int w = 1280 / size;
        int x = 0;
        for (int i = 0; i < size; i++) {
            try {
                Thumbnails.of("/Users/kingtiger/Downloads/Me/儿童教育/DaveAndAva/temp/out.jpg")
                        .sourceRegion(x, 0, w, h)
                        .size(w, h)
                        .outputFormat("jpg")
                        .keepAspectRatio(false)
                        .toFile(String.format("/Users/kingtiger/Downloads/Me/儿童教育/DaveAndAva/temp/out_%s.jpg", i + 1));
                x += w;
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

    }
}
```


Overlapping Code:
```
c class ImgDavaAndAvaForDouYin {
public static void main(String[] args) {
int size = 3;
int h = 720;
int w = 1280 / size;
int x = 0;
for (int i = 0; i < size; i++) {
try {
Thumbnails.of("/Users/kingtiger/Downloads/Me/儿童教育/DaveAndAva/temp/out.jpg")
.sourceRegion(x, 0, w, h)
.size(w, h)
.outputFormat("jpg")
.keepAspectRatio(false)
.toFile(String.format("/Users/kingtiger/Downloads/Me/儿童教育/DaveAndAva/temp/out_%s.jpg", i + 1));
x += w;
} catch (IOException e) {
e.printStackTrace();
}
}
}
}
```
<Overlap Ratio: 0.9898785425101214>

---

--- 86 --
Question ID: cda8468b012872dd90533ea71dc6494f3a2c21a2
Original Code:
```
public class SerializeDeserializeBinarySearchTree {
    // Encodes a tree to a single string.
    // T:O(n), S:O(n)
    public String serialize(TreeNode root) {
        // preorder traverse
        StringBuilder builder = new StringBuilder();
        dfsSerialize(root, builder);
        // System.out.println(builder.toString());
        return builder.toString();
    }

    public void dfsSerialize(TreeNode node, StringBuilder builder) {
        if (node == null) return;

        builder.append(node.val);
        if(node.left != null) {
            builder.append(",");
            dfsSerialize(node.left, builder);
        }

        if(node.right != null) {
            builder.append(",");
            dfsSerialize(node.right, builder);
        }
    }

    // Decodes your encoded data to tree.
    // T:O(n), S:O(n)
    public TreeNode deserialize(String data) {
        if (data == null || data.length() == 0) return null;

        // "2,1,3"
        String[] array = data.split(",");
        Queue<Integer> q = new LinkedList<>();
        for (String s: array) {
            q.offer(Integer.parseInt(s));
        }
        // [2,1,3]
        return dfsDeserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    public TreeNode dfsDeserialize(Queue<Integer> q, int min, int max) {
        if (q.isEmpty()) return null;

        int val = q.peek();
        if (min > val || val > max) return null;

        TreeNode node = new TreeNode(q.poll());
        node.left = dfsDeserialize(q, min, node.val);
        node.right = dfsDeserialize(q, node.val, max);
        /**
         2
         left = dfsDeserialize([1,3], MIN_VALUE, 2);
         1
         left = dfsDeserialize([3], MIN_VALUE, 1);
         right = dfsDeserialize([1,3], MIN_VALUE, 2);
         */

        return node;
    }
}
```


Overlapping Code:
```
ee {
// Encodes a tree to a single string.
// T:O(n), S:O(n)
public String serialize(TreeNode root) {
// preorder traverse
StringBuilder builder = new StringBuilder();
dfsSerialize(root, builder);
// System.out.println(builder.toString());
return builder.toString();
}
public void dfsSerialize(TreeNode node, StringBuilder builder) {
if (node == null) return;
builder.append(node.val);
if(node.left != null) {
builder.append(",");
dfsSerialize(node.left, builder);
}
if(node.right != null) {
builder.append(",");
dfsSerialize(node.right, builder);
}
}
// Decodes your encoded data to tree.
// T:O(n), S:O(n)
public TreeNode deserialize(String data) {
if (data == null || data.length() == 0) return null;
// "2,1,3"
String[] array = data.split(",");
Queue<Integer> q = new LinkedList<>();
for (String s: array) {
q.offer(Integer.parseInt(s));
}
// [2,1,3]
return dfsDeserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);
}
public TreeNode dfsDeserialize(Queue<Integer> q, int min, int max) {
if (q.isEmpty()) return null;
int val = q.peek();
if (min > val || val > max) return null;
TreeNode node = new TreeNode(q.poll());
node.left = dfsDeserialize(q, min, node.val);
node.right = dfsDeserialize(q, node.val, max);
/**
2
left = dfsDeserialize([1,3], MIN_VALUE, 2);
1
left = dfsDeserialize([3], MIN_VALUE, 1);
right = dfsDeserialize([1,3], MIN_VALUE, 2
```
<Overlap Ratio: 0.9513742071881607>

---

--- 87 --
Question ID: 554241ecd65ac518af6fe99d9e10ce9745118665
Original Code:
```
public class WebDriverAppiumHelper extends WebDriverCommonHelper {

    /***
     * Default constructor.
     */
    public WebDriverAppiumHelper() {
    }

    public WebDriverAppiumHelper(Platform platform, int webDriverTimeout, TestLog testLog) {
        setLogger(testLog);
        setAppiumTheMainUsage(true);
        setWebDriverWaitTimeoutSeconds(webDriverTimeout);
        setDevicePlatform(platform);


        warnStfUsage();
    }
    // region Common Area

    /***
     * Helper to send values to an web element.
     * @param platform What platform?
     * @param selectorType: What is the type of this selector? What selector?
     * @param selectorId: The element selector.
     * @param value: The value to be be sent.
     * @throws Exception
     */
    public void sendKeys(Platform platform, SelectorType selectorType, String selectorId, String value) throws Exception {
        WebElement element = first(selectorType, selectorId);
        switch (platform) {
            case ANDROID:
                element.sendKeys(value);
                break;
            case IOS:
                IOSElement tempElement = (IOSElement) element;
                tempElement.setValue(value);
                break;
            default:
                throw new Exception(String.format("The webdriver platform %1$s is not supported yet.", platform.toString()));
        }
    }

    /**
     * This helper performs a click in a element.
     * The difference between this helper and a _common First.Click() is that this one is intended to Mobile elements instead regular WebElements - otherwise I can guarantee that you'll face instabilities while testing Apps.
     *
     * @param selectorType: What is the type of this selector? What selector?
     * @param selectorId:   The element selector.
     * @throws Exception
     */
    public void tap(SelectorType selectorType, String selectorId) throws Exception {
        MobileElement element;
        element = (MobileElement) first(selectorType, selectorId);
        element.click();
    }

    //endregion

    // region iOS Area

    /***
     *  Helper to send values to an web element for iOS.
     * @param selectorType: What is the type of this selector? What selector?
     * @param selectorId: The element selector.
     * @param value: The value to be be sent.
     * @throws Exception
     */
    public void sendKeysToiOS(SelectorType selectorType, String selectorId, String value) throws Exception {
        sendKeys(Platform.IOS, selectorType, selectorId, value);
    }
    // endregion

    // region Android Area

    /***
     * Helper to send values to an web element for Android.
     * @param selectorType: What is the type of this selector? What selector?
     * @param selectorId: The element selector.
     * @param value: The value to be be sent.
     * @throws Exception
     */
    public void sendKeysToAndroid(SelectorType selectorType, String selectorId, String value) throws Exception {
        sendKeys(Platform.ANDROID, selectorType, selectorId, value);
    }
    // endregion
}
```


Overlapping Code:
```
piumHelper extends WebDriverCommonHelper {
/***
* Default constructor.
*/
public WebDriverAppiumHelper() {
}
public WebDriverAppiumHelper(Platform platform, int webDriverTimeout, TestLog testLog) {
setLogger(testLog);
setAppiumTheMainUsage(true);
setWebDriverWaitTimeoutSeconds(webDriverTimeout);
setDevicePlatform(platform);
warnStfUsage();
}
// region Common Area
/***
* Helper to send values to an web element.
* @param platform What platform?
* @param selectorType: What is the type of this selector? What selector?
* @param selectorId: The element selector.
* @param value: The value to be be sent.
* @throws Exception
*/
public void sendKeys(Platform platform, SelectorType selectorType, String selectorId, String value) throws Exception {
WebElement element = first(selectorType, selectorId);
switch (platform) {
case ANDROID:
element.sendKeys(value);
break;
case IOS:
IOSElement tempElement = (IOSElement) element;
tempElement.setValue(value);
break;
default:
throw new Exception(String.format("The webdriver platform %1$s is not supported yet.", platform.toString()));
}
}
/**
* This helper performs a click in a element.
* The difference between this helper and a _common First.Click() is that this one is intended to Mobile elements instead regular WebElements - otherwise I can guarantee that you'll face instabilities while testing Apps.
*
* @param selectorType: What is the type of this selector? What selector?
* @param selectorId: The element selector.
* @throws Exception
*/
public void tap(SelectorType selectorType, String selectorId) throws Exception {
MobileElement element;
element = (MobileElement) first(selectorType, selectorId);
element.click();
}
//endregion
// region iOS Area
/***
* Helper to send values to an web element for iOS.
* @param selectorType: What is the type of this selector? What selector?
* @param selectorId: The element selector.
* @param value: The value to be be sent.
* @throws Exception
*/
public void sendKeysToiOS(SelectorType selectorType, String selectorId, String value) throws Exception {
sendKeys(P
```
<Overlap Ratio: 0.9860911270983214>

---

--- 88 --
Question ID: b7e2a194dbd0fec6cf557ec454a4d945e94c7783
Original Code:
```
public class HTTPAuthentication implements Serializable {

	/**
	 * serialVersionUID
	 */
	private static final long serialVersionUID = -590744458307191489L;

	/**
	 * 
	 * @param ras
	 * @return
	 */
	public static CredentialsProvider createBasicAuthentication(WebAppService ras) {
		HTTPHeader[] headers = ras.getAuthentication();
		String username = "";
		String password = "";
		if (headers != null && headers.length > 0) {
			for (HTTPHeader header : headers) {
				if (header.getKey().equals("username")) {
					username = header.getValue();
				} else if (header.getKey().equals("password")) {
					password = header.getValue();
				}
			}
		}
		UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
		CredentialsProvider provider = new BasicCredentialsProvider();
		// Create the authentication scope
		// AuthScope scope = new AuthScope("www.verisign.com", 443,
		// "realm"),
		// AuthScope scope = new AuthScope("localhost", 8080,
		// AuthScope.ANY_REALM);
		AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM);
		provider.setCredentials(scope, credentials);
		return provider;
	}

	/**
	 * 
	 * @param realm
	 * @return
	 */
	public static DigestScheme createDigestAuthentication(String realm) {
		DigestScheme digestAuth = new DigestScheme();
		digestAuth.overrideParamter("algorithm", "MD5");
		if (realm != null && !realm.equals("")) {
			digestAuth.overrideParamter("realm", realm);
		} else
			digestAuth.overrideParamter("realm", AuthScope.ANY_HOST);
		digestAuth.overrideParamter("nonce", Long.toString(new Random().nextLong(), 36));
		digestAuth.overrideParamter("qop", "auth");
		digestAuth.overrideParamter("nc", "0");
		digestAuth.overrideParamter("cnonce", DigestScheme.createCnonce());
		return digestAuth;
	}

}
```


Overlapping Code:
```
PAuthentication implements Serializable {
/**
* serialVersionUID
*/
private static final long serialVersionUID = -590744458307191489L;
/**
* 
* @param ras
* @return
*/
public static CredentialsProvider createBasicAuthentication(WebAppService ras) {
HTTPHeader[] headers = ras.getAuthentication();
String username = "";
String password = "";
if (headers != null && headers.length > 0) {
for (HTTPHeader header : headers) {
if (header.getKey().equals("username")) {
username = header.getValue();
} else if (header.getKey().equals("password")) {
password = header.getValue();
}
}
}
UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);
CredentialsProvider provider = new BasicCredentialsProvider();
// Create the authentication scope
// AuthScope scope = new AuthScope("www.verisign.com", 443,
// "realm"),
// AuthScope scope = new AuthScope("localhost", 8080,
// AuthScope.ANY_REALM);
AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM);
provider.setCredentials(scope, credentials);
return provider;
}
/**
* 
* @param realm
* @return
*/
public static DigestScheme createDigestAuthentication(String realm) {
DigestScheme digestAuth = new DigestScheme();
digestAuth.overrideParamter("algorithm", "MD5");
if (realm != null && !realm.equals("")) {
digestAuth.overrideParamter("realm", realm);
} else
digestAuth.overrideParamter("realm", AuthScope.ANY_HOST);
digestAuth.overrideParamter("nonce", Long.toString(new Random().nextLong(), 36));
digestAuth.overrideParamter("qop", "auth");
digestAuth.overrideParamter("nc", "0");
digestAuth.overrideParamter("cnonce", DigestScheme
```
<Overlap Ratio: 0.9671746776084408>

---

--- 89 --
Question ID: 15a708a8bb51e88715681aa659ea3904159a0dd3
Original Code:
```
class GoCDAzureClientTest extends BaseTest {

  @Mock(answer = Answers.RETURNS_DEEP_STUBS)
  private Azure azure;

  @Mock
  private NetworkDecorator mockNetworkDecorator;

  private GoCDAzureClient goCDAzureClient;
  private String resourceGroup = "AGENTS-group";

  @BeforeEach
  void setUp() {
    initMocks(this);
    goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

  }

  @Test
  void testShouldFetchRunningVirtualMachinesInResourceGroupWithCaseInsensitivityAndWithServerIdTag() {
    VirtualMachine vm1 = mock(VirtualMachine.class);
    VirtualMachine vm2 = mock(VirtualMachine.class);
    VirtualMachine vm3 = mock(VirtualMachine.class);

    when(vm1.resourceGroupName()).thenReturn("agents-group");
    Map<String, String> tagsMap = new HashMap<String, String>() {{
      put(GOCD_SERVER_ID_TAG_KEY, "server_id");
    }};
    when(vm1.tags()).thenReturn(tagsMap);
    when(vm2.resourceGroupName()).thenReturn("another-group");
    when(vm3.resourceGroupName()).thenReturn("agents-group");
    when(vm3.tags()).thenReturn(tagsMap);
    List<VirtualMachine> machines = asList(vm1, vm2, vm3);
    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());
    List<VirtualMachine> vms = new GoCDAzureClient(azure, "agents-group", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");

    assertEquals(2, vms.size());
    assertEquals(vm1, vms.get(0));
    assertEquals(vm3, vms.get(1));

    vms = new GoCDAzureClient(azure, "AGENTS-group", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");

    assertEquals(2, vms.size());
    assertEquals(vm1, vms.get(0));
    assertEquals(vm3, vms.get(1));
  }

  @Test
  void testRunningVirtualMachinesShouldNotFetchVmsWithFailedProvisioningState() {
    VirtualMachine runningVm = mock(VirtualMachine.class);
    VirtualMachine failedVm = mock(VirtualMachine.class);

    Map<String, String> tagsMap = new HashMap<String, String>() {{
      put(GOCD_SERVER_ID_TAG_KEY, "server_id");
    }};
    when(runningVm.resourceGroupName()).thenReturn("agents-group");
    when(runningVm.tags()).thenReturn(tagsMap);
    when(runningVm.provisioningState()).thenReturn("Succeeded");
    when(failedVm.resourceGroupName()).thenReturn("agents-group");
    when(failedVm.provisioningState()).thenReturn("Failed");
    when(failedVm.tags()).thenReturn(tagsMap);
    List<VirtualMachine> machines = asList(runningVm, failedVm);
    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());
    List<VirtualMachine> vms = new GoCDAzureClient(azure, "agents-group", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");

    assertEquals(1, vms.size());
    assertEquals(runningVm, vms.get(0));
  }

  @Test
  void testShouldFetchVmsWithFailedProvisioningState() {
    VirtualMachine runningVm = mock(VirtualMachine.class);
    VirtualMachine failedVm = mock(VirtualMachine.class);

    Map<String, String> tagsMap = new HashMap<String, String>() {{
      put(GOCD_SERVER_ID_TAG_KEY, "server_id");
    }};
    when(runningVm.resourceGroupName()).thenReturn("agents-group");
    when(runningVm.tags()).thenReturn(tagsMap);
    when(runningVm.provisioningState()).thenReturn("Succeeded");
    when(failedVm.resourceGroupName()).thenReturn("agents-group");
    when(failedVm.provisioningState()).thenReturn("Failed");
    when(failedVm.tags()).thenReturn(tagsMap);
    List<VirtualMachine> machines = asList(runningVm, failedVm);
    when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());
    List<VirtualMachine> vms = new GoCDAzureClient(azure, "agents-group", mockNetworkDecorator).failedProvisioningStateVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");

    assertEquals(1, vms.size());
    assertEquals(failedVm, vms.get(0));
  }

  @Test
  void shouldReturnFalseIfNetworkDoesnotExist() {
    when(azure.networks().getById("invalid-network-id")).thenReturn(null);

    assertFalse(goCDAzureClient.networkExists("invalid-network-id"));
  }

  @Test
  void shouldReturnTrueIfNetworkExist() {
    when(azure.networks().getById("invalid-network-id")).thenReturn(mock(Network.class));

    assertTrue(goCDAzureClient.networkExists("invalid-network-id"));
  }

  @Test
  void shouldCheckForInvalidNetworkId() {
    when(azure.networks().getById("some-invalid-format")).thenThrow(InvalidParameterException.class);

    assertFalse(goCDAzureClient.networkExists("some-invalid-format"));
  }

  @Test
  void shouldCheckIfResourceGroupExists() {
    when(azure.resourceGroups().contain("some-resource-group")).thenReturn(true);

    assertTrue(goCDAzureClient.resourceGroupExists("some-resource-group"));
  }

  @Test
  void shouldCheckIfRegionExistsByName() {
    Location location1 = mock(Location.class);
    when(location1.name()).thenReturn("valid-region-1");
    Location location2 = mock(Location.class);
    when(location2.name()).thenReturn("valid-region-2");
    List<Location> locations = asList(location1, location2);

    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());

    assertTrue(goCDAzureClient.regionExists("valid-region-1"));
    assertFalse(goCDAzureClient.regionExists("invalid-region"));
  }

  @Test
  void shouldCheckIfRegionExistsByDisplayName() {
    Location location1 = mock(Location.class);
    when(location1.displayName()).thenReturn("Valid Region 1");
    Location location2 = mock(Location.class);
    when(location2.displayName()).thenReturn("Valid Region 2");
    List<Location> locations = asList(location1, location2);

    when(azure.getCurrentSubscription().listLocations().stream()).thenReturn(locations.stream()).thenReturn(locations.stream());

    assertTrue(goCDAzureClient.regionExists("Valid Region 1"));
    assertFalse(goCDAzureClient.regionExists("Invalid Region"));
  }

  @Test
  void shouldCheckIfNetworkSecurityGroupExists() {
    when(azure.networkSecurityGroups().getById("valid-security-group-id"))
        .thenReturn(mock(NetworkSecurityGroup.class));
    when(azure.networkSecurityGroups().getById("invalid-security-group-id"))
        .thenReturn(null);

    assertTrue(goCDAzureClient.networkSecurityGroupExists("valid-security-group-id"));
    assertFalse(goCDAzureClient.networkSecurityGroupExists("invalid-security-group-id"));
  }

  @Test
  void shouldCheckIfSubnetExistsInAGivenNetwork() {
    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);
    when(azure.networks().getById("rg/test-net")).thenReturn(mockNetwork);
    when(mockNetwork.subnets().containsKey("test-subnet")).thenReturn(true);

    assertTrue(goCDAzureClient.subnetExists("rg/test-net", "test-subnet"));
  }

  @Test
  void shouldReturnSubnetDoesnotExistForAnInvalidNetwork() {
    when(azure.networks().getById("rg/test-net")).thenReturn(null);

    assertFalse(goCDAzureClient.subnetExists("rg/test-net", "test-subnet"));
  }

  @Test
  void shouldReturnSubnetDoesnotExistForAnInvalidSubnetInANetwork() {
    Network mockNetwork = mock(Network.class, RETURNS_DEEP_STUBS);
    when(mockNetwork.subnets().containsKey("test-subnet")).thenReturn(false);
    when(azure.networks().getById("rg/test-net")).thenReturn(mockNetwork);

    assertFalse(goCDAzureClient.subnetExists("rg/test-net", "test-subnet"));
  }

  @Test
  void testBuildVmShouldAddPlatformSpecificOSWithoutPlan() throws Exception {
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    Region region = mock(Region.class, RETURNS_DEEP_STUBS);
    WithOS mockOS = mock(WithOS.class);
    WithGroup mockWithGroup = mock(WithGroup.class);
    Blank mockStage = mock(Blank.class, RETURNS_DEEP_STUBS);
    WithNetwork mockWithNetwork = mock(WithNetwork.class, RETURNS_DEEP_STUBS);
    WithCreate mockWithCreate = mock(WithCreate.class, RETURNS_DEEP_STUBS);
    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);
    AzureVMExtension mockExtension = mock(AzureVMExtension.class);
    Map<String, String> tags = new HashMap<>();
    List<AzureVMExtension> extensions = asList(mockExtension);
    VirtualMachine expectedVM = mock(VirtualMachine.class);

    when(mockVMConfig.getRegion()).thenReturn(region);
    when(mockVMConfig.getImageReference()).thenReturn(null);
    when(mockVMConfig.getName()).thenReturn("vm-name");
    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);
    when(mockVMConfig.getTags()).thenReturn(tags);
    when(mockVMConfig.getOsDiskSize()).thenReturn(Optional.of(45));
    when(azure.virtualMachines().define("vm-name")).thenReturn(mockStage);
    when(mockStage.withRegion(region)).thenReturn(mockWithGroup);
    when(mockWithGroup.withExistingResourceGroup(resourceGroup)).thenReturn(mockWithNetwork);
    when(mockNetworkDecorator.add(mockWithNetwork, mockVMConfig)).thenReturn(mockOS);
    when(mockStrategy.addOS(mockOS, mockVMConfig)).thenReturn(mockWithCreate);
    when(mockStrategy.getExtensions(mockVMConfig)).thenReturn(extensions);
    when(mockWithCreate.withTags(tags)).thenReturn(mockWithCreate);

    when(mockExtension.addTo(mockWithCreate)).thenReturn(mockWithCreate);
    when(mockWithCreate.create()).thenReturn(expectedVM);

    VirtualMachine createdVM = goCDAzureClient.createVM(mockVMConfig);

    verify(mockStrategy).addOS(mockOS, mockVMConfig);
    verify(mockWithCreate).withTags(tags);
    verify(mockWithCreate, never()).withPlan(any());
    verify(mockExtension).addTo(mockWithCreate);
    verify(mockWithCreate).withOSDiskSizeInGB(45);
    verify(mockWithCreate).create();

    assertEquals(expectedVM, createdVM);
  }

  @Test
  void testRunCommandShouldDoNothingForBlankScript() throws Exception {
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    when(mockVMConfig.getCustomScript()).thenReturn(" ");

    goCDAzureClient.runCustomScript(mockVMConfig);

    verify(azure, never()).virtualMachines();
  }

  @Test
  void testRunCommandShouldInvokeCommandAndGenerateLogs() throws Exception {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, "AGENTS", mockNetworkDecorator);
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);
    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);
    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);
    when(mockVMConfig.getName()).thenReturn("vmName");
    when(mockVMConfig.getResourceGroup()).thenReturn("AGENTS");
    when(mockVMConfig.getCustomScript()).thenReturn("custom script");
    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);

    RunCommandResult runCommandResult = mock(RunCommandResult.class);
    InstanceViewStatus instanceViewStatus1 = mock(InstanceViewStatus.class);
    InstanceViewStatus instanceViewStatus2 = mock(InstanceViewStatus.class);
    when(instanceViewStatus1.message()).thenReturn("logs 1");
    when(instanceViewStatus2.message()).thenReturn("logs 2");
    when(runCommandResult.value()).thenReturn(Arrays.asList(instanceViewStatus1, instanceViewStatus2));
    when(mockStrategy.runScript("AGENTS", "vmName", mockVirtualMachines, "custom script")).thenReturn(runCommandResult);

    String logs = goCDAzureClient.runCustomScript(mockVMConfig);

    assertEquals("logs 1\nlogs 2\n", logs);
    verify(azure).virtualMachines();
    verify(mockStrategy).runScript("AGENTS", "vmName", mockVirtualMachines, "custom script");
  }

  @Test
  void testStartAgentShouldInvokeCommand() {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    AgentConfig agentConfig = mock(AgentConfig.class);
    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);
    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);
    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);
    when(mockVMConfig.getName()).thenReturn("vmName");
    when(mockVMConfig.getResourceGroup()).thenReturn("AGENTS");
    when(mockVMConfig.getAgentConfig()).thenReturn(agentConfig);
    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);

    goCDAzureClient.startAgent(mockVMConfig);

    verify(azure).virtualMachines();
    verify(mockStrategy).startAgent("AGENTS", "vmName", mockVirtualMachines, agentConfig);
  }

  @Test
  void testInstallAgentShouldInvokeCommand() throws ProvisionFailedException {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class, RETURNS_DEEP_STUBS);
    VirtualMachines mockVirtualMachines = mock(VirtualMachines.class);
    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);
    when(azure.virtualMachines()).thenReturn(mockVirtualMachines);

    goCDAzureClient.installGoAgent(mockVMConfig);

    verify(azure).virtualMachines();
    verify(mockStrategy).installGoAgent(mockVirtualMachines, mockVMConfig);
  }

  @Test
  void testShouldReRaiseExceptionAndTerminateVMOnCommandExecutionFailure() {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    VirtualMachine mockVM = mock(VirtualMachine.class);
    PlatformConfigStrategy mockStrategy = mock(PlatformConfigStrategy.class);

    when(mockVMConfig.getCustomScript()).thenReturn("custom script");
    when(mockVMConfig.getPlatformStrategy()).thenReturn(mockStrategy);
    when(mockVMConfig.getResourceGroup()).thenReturn(resourceGroup);
    when(mockVMConfig.getName()).thenReturn("Test-123");
    when(mockVM.id()).thenReturn("/resources/Test-123");
    when(azure.virtualMachines().getByResourceGroup(resourceGroup, "Test-123")).thenReturn(mockVM);
    when(mockStrategy.runScript(eq(resourceGroup), eq("Test-123"), any(), eq("custom script")))
        .thenThrow(new CloudException("script failed",
            Response.error(500, ResponseBody.create(MediaType.parse("application/json"), "boom")),
            new CloudError()));

    assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.runCustomScript(mockVMConfig));
    verify(azure.virtualMachines()).deleteById("/resources/Test-123");
  }

  @Test
  void shouldAddTagToTheVirtualMachine() {
    VirtualMachine mockVM = mock(VirtualMachine.class);
    VirtualMachine mockVMWithTags = mock(VirtualMachine.class);
    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);
    when(mockVM.update()).thenReturn(mockUpdate);
    when(azure.virtualMachines().getById("vm-id")).thenReturn(mockVM);
    when(mockUpdate.withTag("tag-1", "value-1").apply()).thenReturn(mockVMWithTags);

    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    VirtualMachine vmWithTags = goCDAzureClient.addTag("vm-id", "tag-1", "value-1");

    verify(mockUpdate.withTag("tag-1", "value-1"), times(1)).apply();
    assertEquals(mockVMWithTags, vmWithTags);
  }

  @Test
  void shouldRemoveTagFromVirtualMachine() {
    VirtualMachine mockVM = mock(VirtualMachine.class);
    VirtualMachine mockVMWithoutTag = mock(VirtualMachine.class);
    Update mockUpdate = mock(Update.class, RETURNS_DEEP_STUBS);
    when(mockVM.update()).thenReturn(mockUpdate);
    when(azure.virtualMachines().getById("vm-id")).thenReturn(mockVM);
    when(mockUpdate.withoutTag("tag-1").apply()).thenReturn(mockVMWithoutTag);

    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    VirtualMachine vmWithoutTags = goCDAzureClient.removeTag("vm-id", "tag-1");

    verify(mockUpdate.withoutTag("tag-1"), times(1)).apply();
    assertEquals(mockVMWithoutTag, vmWithoutTags);
  }

  @Test
  void shouldCleanupNICOnVMCreationFailure() {
    VmConfig mockVMConfig = mock(VmConfig.class, RETURNS_DEEP_STUBS);
    NetworkInterface mockNic = mock(NetworkInterface.class);
    when(mockVMConfig.getName()).thenReturn("vm-123");
    when(mockVMConfig.getNetworkInterfaceName()).thenReturn("nic-vm-123");
    when(mockVMConfig.getJobIdentifier().getRepresentation()).thenReturn("jobid");
    when(azure.virtualMachines().define("vm-123")).thenThrow(new RuntimeException("boom"));
    when(azure.virtualMachines().getByResourceGroup(anyString(), anyString())).thenReturn(null);
    when(azure.networkInterfaces().getByResourceGroup(resourceGroup, "nic-vm-123")).thenReturn(mockNic);
    when(mockNic.id()).thenReturn("nicId");

    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    ProvisionFailedException exception = assertThrows(ProvisionFailedException.class, () -> goCDAzureClient.createVM(mockVMConfig));
    assertEquals("Failed to create vm with name vm-123 for job jobid due to error: boom", exception.getMessage());

    verify(azure.networkInterfaces()).getByResourceGroup(resourceGroup, "nic-vm-123");
    verify(azure.networkInterfaces()).deleteById("nicId");
  }

  @Test
  void shouldValidateTheImageURNChosenIsCorrespondingToThePlatformSelected() {
    VirtualMachineImage mockVMImage = mock(VirtualMachineImage.class);
    OSDiskImage mockDiskImage = mock(OSDiskImage.class);

    when(mockDiskImage.operatingSystem()).thenReturn(OperatingSystemTypes.LINUX);
    when(mockVMImage.osDiskImage()).thenReturn(mockDiskImage);
    when(azure.virtualMachineImages().getImage(Region.INDIA_SOUTH, "pub-1", "offer-1", "sku-1", "version-1")).thenReturn(mockVMImage);

    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    assertFalse(goCDAzureClient.imageValidForPlatform(new ImageURN("pub-1:offer-1:sku-1:version-1"), Platform.WINDOWS, Region.INDIA_SOUTH));
    assertTrue(goCDAzureClient.imageValidForPlatform(new ImageURN("pub-1:offer-1:sku-1:version-1"), Platform.LINUX, Region.INDIA_SOUTH));

  }

  @Test
  void shouldTerminateVMAlongWithAssociatedResources() {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    VirtualMachine vm = mock(VirtualMachine.class);
    when(azure.virtualMachines().getById("resource-id-to-be-deleted")).thenReturn(vm);
    when(vm.id()).thenReturn("resource-id-to-be-deleted");
    when(vm.osDiskId()).thenReturn("os-disk-id");
    when(vm.dataDisks()).thenReturn(Collections.emptyMap());
    when(vm.networkInterfaceIds()).thenReturn(asList("nic-1"));

    goCDAzureClient.terminate("resource-id-to-be-deleted");
    verify(azure.virtualMachines()).deleteById("resource-id-to-be-deleted");
    verify(azure.disks()).deleteById("os-disk-id");
    verify(azure.networkInterfaces()).deleteById("nic-1");
  }

  @Test
  void shouldTerminateVMIfNICAndDiskIsNotAttached() {
    GoCDAzureClient goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);

    VirtualMachine vm = mock(VirtualMachine.class);
    when(azure.virtualMachines().getById("resource-id-to-be-deleted")).thenReturn(vm);
    when(vm.id()).thenReturn("resource-id-to-be-deleted");
    when(vm.osDiskId()).thenReturn(null);
    when(vm.dataDisks()).thenReturn(Collections.emptyMap());
    when(vm.networkInterfaceIds()).thenReturn(asList(""));

    goCDAzureClient.terminate("resource-id-to-be-deleted");
    verify(azure.virtualMachines()).deleteById("resource-id-to-be-deleted");
    verify(azure.disks(), never()).deleteById(null);
    verify(azure.networkInterfaces(), never()).deleteById(null);
  }

}
```


Overlapping Code:
```
ntTest extends BaseTest {
@Mock(answer = Answers.RETURNS_DEEP_STUBS)
private Azure azure;
@Mock
private NetworkDecorator mockNetworkDecorator;
private GoCDAzureClient goCDAzureClient;
private String resourceGroup = "AGENTS-group";
@BeforeEach
void setUp() {
initMocks(this);
goCDAzureClient = new GoCDAzureClient(azure, resourceGroup, mockNetworkDecorator);
}
@Test
void testShouldFetchRunningVirtualMachinesInResourceGroupWithCaseInsensitivityAndWithServerIdTag() {
VirtualMachine vm1 = mock(VirtualMachine.class);
VirtualMachine vm2 = mock(VirtualMachine.class);
VirtualMachine vm3 = mock(VirtualMachine.class);
when(vm1.resourceGroupName()).thenReturn("agents-group");
Map<String, String> tagsMap = new HashMap<String, String>() {{
put(GOCD_SERVER_ID_TAG_KEY, "server_id");
}};
when(vm1.tags()).thenReturn(tagsMap);
when(vm2.resourceGroupName()).thenReturn("another-group");
when(vm3.resourceGroupName()).thenReturn("agents-group");
when(vm3.tags()).thenReturn(tagsMap);
List<VirtualMachine> machines = asList(vm1, vm2, vm3);
when(azure.virtualMachines().list().stream()).thenReturn(machines.stream()).thenReturn(machines.stream());
List<VirtualMachine> vms = new GoCDAzureClient(azure, "agents-group", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");
assertEquals(2, vms.size());
assertEquals(vm1, vms.get(0));
assertEquals(vm3, vms.get(1));
vms = new GoCDAzureClient(azure, "AGENTS-group", mockNetworkDecorator).runningVirtualMachinesWithTag(GOCD_SERVER_ID_TAG_KEY, "server_id");
assertEquals(2, vms.size());
assertEquals(vm1, vms.get(0));
assertEquals(vm3, vms.get(1));
}
@Test
void testRunningVirtualMachinesShouldNotFetchVmsWithFailedProvisioningState() {
VirtualMachine runningVm = mock(VirtualMachine.class);
VirtualMachine failedVm = mock(VirtualMachine.class);
Map<String, String> tagsMap = new HashMap<String, String>() {{
put(GOCD_SERVER_ID_TAG_KEY, "server_id");
}};
when(runningVm.resourceGroupName()).thenReturn("agents-group");
when(runningVm.tags()).thenReturn(tagsMap);
when(runningVm.provisioningState()).thenReturn("Succeeded");
when(failedVm.resourceGroupName()).thenReturn("agents-group");
when(failedVm.provisioningState()).thenReturn("Failed");
when(failedVm.tags()).thenReturn(tagsMap);
List<VirtualMachine> machines = asList
```
<Overlap Ratio: 0.9904967602591793>

---

--- 90 --
Question ID: f6fe006954ef098ff1b1a60e656fdba79ec8114e
Original Code:
```
public class SharedMapCache extends AbstractValueAdaptingCache {

    private final Map<Key, Value> store;
    private final String name;

    protected SharedMapCache(String name) {
        super(false);
        this.name = name;
        this.store = new SharedOffHeapMap(2048);
    }

    @Override
    protected Object lookup(Object o) {
        Key key = Key.of((String) o);
        Value value = store.get(key);
        return (value == null ? null : value.get());
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public Object getNativeCache() {
        return store;
    }

    @Override
    public <T> T get(Object o, Callable<T> callable) {
        if (this.store.containsKey(Key.of((String) o))) {
            return (T) this.get(o).get();
        } else {
            synchronized(this.store) {
                if (this.store.containsKey(Key.of((String) o))) {
                    return (T) this.get(o).get();
                } else {
                    Object value;
                    try {
                        value = callable.call();
                    } catch (Throwable t) {
                        throw new ValueRetrievalException(o, callable, t);
                    }

                    this.put(o, value);
                    return (T) value;
                }
            }
        }

    }

    @Override
    public void put(Object o, Object o1) {
        store.put(Key.of((String) o), Value.of(o1));
    }

    @Override
    public ValueWrapper putIfAbsent(Object o, Object o1) {
        Object existing = this.store.putIfAbsent(Key.of((String) o), Value.of(this.toStoreValue(o1)));
        return this.toValueWrapper(existing);
    }

    @Override
    public void evict(Object o) {
        store.remove(Key.of((String) o));
    }

    @Override
    public void clear() {
        store.clear();
    }
}
```


Overlapping Code:
```
Cache extends AbstractValueAdaptingCache {
private final Map<Key, Value> store;
private final String name;
protected SharedMapCache(String name) {
super(false);
this.name = name;
this.store = new SharedOffHeapMap(2048);
}
@Override
protected Object lookup(Object o) {
Key key = Key.of((String) o);
Value value = store.get(key);
return (value == null ? null : value.get());
}
@Override
public String getName() {
return name;
}
@Override
public Object getNativeCache() {
return store;
}
@Override
public <T> T get(Object o, Callable<T> callable) {
if (this.store.containsKey(Key.of((String) o))) {
return (T) this.get(o).get();
} else {
synchronized(this.store) {
if (this.store.containsKey(Key.of((String) o))) {
return (T) this.get(o).get();
} else {
Object value;
try {
value = callable.call();
} catch (Throwable t) {
throw new ValueRetrievalException(o, callable, t);
}
this.put(o, value);
return (T) value;
}
}
}
}
@Override
public void put(Object o, Object o1) {
store.put(Key.of((String) o), Value.of(o1));
}
@Override
public ValueWrapper putIfAbsent(Object o, Object o1) {
Object existing = this.store.putIfAbsent(Key.of((String) o), Value.of(this.toStoreValue(o1)));
return this.toValueWrapper(existing);
}
@Override
public void evict(Object o) {
store.remove(Key.of((String) o));
}
@Override
public void clear() {
store.clear();
}
}
```
<Overlap Ratio: 0.9838591342626559>

---

--- 91 --
Question ID: 6f7430e1d2b4a7889fe2339392026a7a91a0e8fb
Original Code:
```
public class SettingsActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_settings);

        setTitle("Settings");
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        getFragmentManager().beginTransaction().
                add(R.id.container,new SettingsFragment()).commit();
    }

    @Override
    public boolean onSupportNavigateUp() {
        finish();
        return super.onSupportNavigateUp();
    }
}
```


Overlapping Code:
```
public class SettingsActivity extends AppCompatActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_settings);
setTitle("Settings");
getSupportActionBar().setDisplayHomeAsUpEnabled(true);
getFragmentManager().beginTransaction().
add(R.id.container,new SettingsFragment()).commit();
}
@Override
public boolean onSupportNavigateUp() {
finish();
return super.onSupportNavigateUp();
}
}
```
<Overlap Ratio: 1.0>

---

--- 92 --
Question ID: 3fd76c672e2258865a3ddf069142473672941fe6
Original Code:
```
@Component
public class PromotiondetailinfoServiceMapper extends AbstractServiceMapper {

	/**
	 * ModelMapper : bean to bean mapping library.
	 */
	private ModelMapper modelMapper;
	
	/**
	 * Constructor.
	 */
	public PromotiondetailinfoServiceMapper() {
		modelMapper = new ModelMapper();
		modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
	}

	/**
	 * Mapping from 'PromotiondetailinfoEntity' to 'Promotiondetailinfo'
	 * @param promotiondetailinfoEntity
	 */
	public Promotiondetailinfo mapPromotiondetailinfoEntityToPromotiondetailinfo(PromotiondetailinfoEntity promotiondetailinfoEntity) {
		if(promotiondetailinfoEntity == null) {
			return null;
		}

		//--- Generic mapping 
		Promotiondetailinfo promotiondetailinfo = map(promotiondetailinfoEntity, Promotiondetailinfo.class);

		//--- Link mapping ( link to Dishspecificationinfo )
		return promotiondetailinfo;
	}
	
	/**
	 * Mapping from 'Promotiondetailinfo' to 'PromotiondetailinfoEntity'
	 * @param promotiondetailinfo
	 * @param promotiondetailinfoEntity
	 */
	public void mapPromotiondetailinfoToPromotiondetailinfoEntity(Promotiondetailinfo promotiondetailinfo, PromotiondetailinfoEntity promotiondetailinfoEntity) {
		if(promotiondetailinfo == null) {
			return;
		}

		//--- Generic mapping 
		map(promotiondetailinfo, promotiondetailinfoEntity);

		//--- Link mapping ( link : promotiondetailinfo )

	}
	
	/**
	 * Verify that Dishspecificationinfo id is valid.
	 * @param Dishspecificationinfo Dishspecificationinfo
	 * @return boolean
	 */
	private boolean hasLinkToDishspecificationinfo(Promotiondetailinfo promotiondetailinfo) {
		if(promotiondetailinfo.getSpecificationid() != null) {
			return true;
		}
		return false;
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	protected ModelMapper getModelMapper() {
		return modelMapper;
	}

	protected void setModelMapper(ModelMapper modelMapper) {
		this.modelMapper = modelMapper;
	}

}
```


Overlapping Code:
```
lass PromotiondetailinfoServiceMapper extends AbstractServiceMapper {
/**
* ModelMapper : bean to bean mapping library.
*/
private ModelMapper modelMapper;

/**
* Constructor.
*/
public PromotiondetailinfoServiceMapper() {
modelMapper = new ModelMapper();
modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
}
/**
* Mapping from 'PromotiondetailinfoEntity' to 'Promotiondetailinfo'
* @param promotiondetailinfoEntity
*/
public Promotiondetailinfo mapPromotiondetailinfoEntityToPromotiondetailinfo(PromotiondetailinfoEntity promotiondetailinfoEntity) {
if(promotiondetailinfoEntity == null) {
return null;
}
//--- Generic mapping 
Promotiondetailinfo promotiondetailinfo = map(promotiondetailinfoEntity, Promotiondetailinfo.class);
//--- Link mapping ( link to Dishspecificationinfo )
return promotiondetailinfo;
}

/**
* Mapping from 'Promotiondetailinfo' to 'PromotiondetailinfoEntity'
* @param promotiondetailinfo
* @param promotiondetailinfoEntity
*/
public void mapPromotiondetailinfoToPromotiondetailinfoEntity(Promotiondetailinfo promotiondetailinfo, PromotiondetailinfoEntity promotiondetailinfoEntity) {
if(promotiondetailinfo == null) {
return;
}
//--- Generic mapping 
map(promotiondetailinfo, promotiondetailinfoEntity);
//--- Link mapping ( link : promotiondetailinfo )
}

/**
* Verify that Dishspecificationinfo id is valid.
* @param Dishspecificationinfo Dishspecificationinfo
* @return boolean
*/
private boolean hasLinkToDishspecificationinfo(Promotiondetailinfo promotiondetailinfo) {
if(promotiondetailinfo.getSpecificationid() != null) {
return true;
}
return false;
}
/**
* {@inheritDoc}
*/
@Override
protected ModelMapper getModelMapper() {
return modelMapper;
}
protected void setModelMapper(ModelMapper modelMapper) {
this.modelMapper = modelMapper;
}
}
```
<Overlap Ratio: 0.9895718990120747>

---

--- 93 --
Question ID: ffe7406a7609939ddb7d8d29b954183a1d2856ac
Original Code:
```
public class CelsiusConverterBOTest {

    public CelsiusConverterBOTest() {
    }

    @Test
    public void shouldConvertFromCelsiusToFahrenheit() {
        //given
        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
        double tempToConvert = ConstantsForTests.CELSIUS;
        double convertedTemp = 0.0;

        //when
        convertedTemp = celsiusConverterBO.toFahrenheit(tempToConvert);

        //then
        assertEquals(ConstantsForTests.FAHRENHEIT, convertedTemp, ConstantsForTests.DELTA);
    }

    @Test
    public void shouldConvertFromCelsiusToKelvin() {
        //given
        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
        double tempToConvert = ConstantsForTests.CELSIUS;
        double convertedTemp = 0.0;

        //when
        convertedTemp = celsiusConverterBO.toKelvin(tempToConvert);

        //then
        assertEquals(ConstantsForTests.KELVIN, convertedTemp, ConstantsForTests.DELTA);
    }

    @Test
    public void shouldConvertFromCelsiusToRankine() {
        //given
        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
        double tempToConvert = ConstantsForTests.CELSIUS;
        double convertedTemp = 0.0;

        //when
        convertedTemp = celsiusConverterBO.toRankine(tempToConvert);

        //then
        assertEquals(ConstantsForTests.RANKINE, convertedTemp, ConstantsForTests.DELTA);
    }

    @Test
    public void shouldConvertFromCelsiusToReaumur() {
        //given
        CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
        double tempToConvert = ConstantsForTests.CELSIUS;
        double convertedTemp = 0.0;

        //when
        convertedTemp = celsiusConverterBO.toReaumur(tempToConvert);
        //then
        assertEquals(ConstantsForTests.REAUMUR, convertedTemp, ConstantsForTests.DELTA);
    }

}
```


Overlapping Code:
```
iusConverterBOTest() {
}
@Test
public void shouldConvertFromCelsiusToFahrenheit() {
//given
CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
double tempToConvert = ConstantsForTests.CELSIUS;
double convertedTemp = 0.0;
//when
convertedTemp = celsiusConverterBO.toFahrenheit(tempToConvert);
//then
assertEquals(ConstantsForTests.FAHRENHEIT, convertedTemp, ConstantsForTests.DELTA);
}
@Test
public void shouldConvertFromCelsiusToKelvin() {
//given
CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
double tempToConvert = ConstantsForTests.CELSIUS;
double convertedTemp = 0.0;
//when
convertedTemp = celsiusConverterBO.toKelvin(tempToConvert);
//then
assertEquals(ConstantsForTests.KELVIN, convertedTemp, ConstantsForTests.DELTA);
}
@Test
public void shouldConvertFromCelsiusToRankine() {
//given
CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
double tempToConvert = ConstantsForTests.CELSIUS;
double convertedTemp = 0.0;
//when
convertedTemp = celsiusConverterBO.toRankine(tempToConvert);
//then
assertEquals(ConstantsForTests.RANKINE, convertedTemp, ConstantsForTests.DELTA);
}
@Test
public void shouldConvertFromCelsiusToReaumur() {
//given
CelsiusConverterBO celsiusConverterBO = new CelsiusConverterBO();
double tempToConvert = ConstantsForTests.CELSIUS;
double convertedTemp = 0.0;
//when
convertedTemp = celsiusConverterBO.toReaumur(tempToConvert);
//then
assertEquals(ConstantsForTests.REAUMUR, convertedTemp, Constan
```
<Overlap Ratio: 0.9540453074433657>

---

--- 94 --
Question ID: 6b7ab53d75c99b08fd5b4002862f6e89ad7c4140
Original Code:
```
public class TestMyTime {

	public static void main(String[] args) {
		MyTime time1 = new MyTime(20, 56, 58);
		MyTime time2 = new MyTime(20, 59, 58);
		MyTime time3 = new MyTime(23, 59, 58);

		for (int i = 0; i < 4; i++) {
			System.out.println(time1.nextSecond());
			System.out.println(time2.nextSecond());
			System.out.println(time3.nextSecond());
			System.out.println("");
		}
	}

}
```


Overlapping Code:
```
e {
public static void main(String[] args) {
MyTime time1 = new MyTime(20, 56, 58);
MyTime time2 = new MyTime(20, 59, 58);
MyTime time3 = new MyTime(23, 59, 58);
for (int i = 0; i < 4; i++) {
System.out.println(time1.nextSecond());
System.out.println(time2.nextSecond());
System.out.println(time3.nextSecond());
S
```
<Overlap Ratio: 0.8622589531680441>

---

--- 95 --
Question ID: 814087476f1ba62432f05c3705ffb1608b313e32
Original Code:
```
public class RelayClockCanvas extends Canvas
{
    private static final long serialVersionUID = 1L;

    private RelayClockDigitPCB digitS0;

    private RelayClockDigitPCB digitS1;

    private RelayClockDigitPCB digitM0;

    private RelayClockDigitPCB digitM1;

    private RelayClockDigitPCB digitH0;

    private RelayClockDigitPCB digitH1;

    /**
     * The constructor.
     */
    public RelayClockCanvas(RelayClock clock)
    {
        this.digitS0 = clock.getDisplayS0();
        this.digitS1 = clock.getDisplayS1();
        this.digitM0 = clock.getDisplayM0();
        this.digitM1 = clock.getDisplayM1();
        this.digitH0 = clock.getDisplayH0();
        this.digitH1 = clock.getDisplayH1();
    }

    @Override
    public void update(Graphics g)
    {
        paint(g);
    }

    @Override
    public void paint(Graphics g)
    {
        int w = getWidth();
        int h = getHeight();

        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, 0, w, h);

        // paint it in the middle of the canvas
        int x = (w - 330) / 2;
        int y = (h - 120) / 2;

        paint(digitH1.getDisplay(), g, x + 20, y + 20);
        paint(digitH0.getDisplay(), g, x + 70, y + 20);
        paint(digitM1.getDisplay(), g, x + 120, y + 20);
        paint(digitM0.getDisplay(), g, x + 170, y + 20);
        paint(digitS1.getDisplay(), g, x + 220, y + 20);
        paint(digitS0.getDisplay(), g, x + 270, y + 20);
    }

    private void paint(SevenSegmentDisplay digit, Graphics g, int xOffset, int yOffset)
    {
        g.setColor(Color.GREEN);

        if (digit.getA().isOn())
        {
            g.drawLine(xOffset, yOffset, xOffset + 40, yOffset);
        }
        if (digit.getB().isOn())
        {
            g.drawLine(xOffset + 40, yOffset, xOffset + 40, yOffset + 40);
        }
        if (digit.getC().isOn())
        {
            g.drawLine(xOffset + 40, yOffset + 40, xOffset + 40, yOffset + 80);
        }
        if (digit.getD().isOn())
        {
            g.drawLine(xOffset, yOffset + 80, xOffset + 40, yOffset + 80);
        }
        if (digit.getE().isOn())
        {
            g.drawLine(xOffset, yOffset + 80, xOffset, yOffset + 40);
        }
        if (digit.getF().isOn())
        {
            g.drawLine(xOffset, yOffset + 40, xOffset, yOffset);
        }
        if (digit.getG().isOn())
        {
            g.drawLine(xOffset, yOffset + 40, xOffset + 40, yOffset + 40);
        }
    }
}
```


Overlapping Code:
```
c class RelayClockCanvas extends Canvas
{
private static final long serialVersionUID = 1L;
private RelayClockDigitPCB digitS0;
private RelayClockDigitPCB digitS1;
private RelayClockDigitPCB digitM0;
private RelayClockDigitPCB digitM1;
private RelayClockDigitPCB digitH0;
private RelayClockDigitPCB digitH1;
/**
* The constructor.
*/
public RelayClockCanvas(RelayClock clock)
{
this.digitS0 = clock.getDisplayS0();
this.digitS1 = clock.getDisplayS1();
this.digitM0 = clock.getDisplayM0();
this.digitM1 = clock.getDisplayM1();
this.digitH0 = clock.getDisplayH0();
this.digitH1 = clock.getDisplayH1();
}
@Override
public void update(Graphics g)
{
paint(g);
}
@Override
public void paint(Graphics g)
{
int w = getWidth();
int h = getHeight();
g.setColor(Color.DARK_GRAY);
g.fillRect(0, 0, w, h);
// paint it in the middle of the canvas
int x = (w - 330) / 2;
int y = (h - 120) / 2;
paint(digitH1.getDisplay(), g, x + 20, y + 20);
paint(digitH0.getDisplay(), g, x + 70, y + 20);
paint(digitM1.getDisplay(), g, x + 120, y + 20);
paint(digitM0.getDisplay(), g, x + 170, y + 20);
paint(digitS1.getDisplay(), g, x + 220, y + 20);
paint(digitS0.getDisplay(), g, x + 270, y + 20);
}
private void paint(SevenSegmentDisplay digit, Graphics g, int xOffset, int yOffset)
{
g.setColor(Color.GREEN);
if (digit.getA().isOn())
{
g.drawLine(xOffset, yOffset, xOffset + 40, yOffset);
}
if (digit.getB().isOn())
{
g.drawLine(xOffset + 40, yOffset, xOffset + 40, yOffset + 40);
}
if (digit.getC().isOn())
{
g.drawLine(xOffset + 40, yOffset + 40, xOffset + 40, yOffset + 80);
}
if (digit.getD().isOn())
{
g.drawLine(xOffset, yOffset + 80, xOffset + 40, yOffset + 80);
}
if (digit.getE().isOn())
{
g.drawLine(xOffset, yOffset + 80, xOffset, yOffset + 40);
}
if (digit.getF().isOn())
{
g.drawLine(xOffset, yOffset + 40, xOffset, yOffset);
}
if (digit.getG().isOn())
{
g.drawLine(xOffset, yOffset + 40, xOffset + 40, yOffset + 
```
<Overlap Ratio: 0.9921671018276762>

---

--- 96 --
Question ID: 2a9ca0c3eaf49c3dd6f62664cefcd0fc221221e9
Original Code:
```
class _022ArrayPairSumTest {

	private _022ArrayPairSum pairSum = new _022ArrayPairSum();

	/**
	 * Test method for
	 * {@link org.redquark.ramanujan.mustdos._022ArrayPairSum#findPairs(int[], int)}.
	 */
	@Test
	void testFindPairs() {
		int[] a = new int[] { 1, 5, 7, -1, 5 };
		int sum = 6;
		Set<Pair> expected = new HashSet<>();
		expected.add(new Pair(1, 5));
		expected.add(new Pair(7, -1));
		assertTrue(expected.equals(pairSum.findPairs(a, sum)));

		a = new int[] { 2, 5, 17, -1 };
		sum = 7;
		expected = new HashSet<>();
		expected.add(new Pair(2, 5));
		assertTrue(expected.equals(pairSum.findPairs(a, sum)));
	}

}
```


Overlapping Code:
```
ivate _022ArrayPairSum pairSum = new _022ArrayPairSum();
/**
* Test method for
* {@link org.redquark.ramanujan.mustdos._022ArrayPairSum#findPairs(int[], int)}.
*/
@Test
void testFindPairs() {
int[] a = new int[] { 1, 5, 7, -1, 5 };
int sum = 6;
Set<Pair> expected = new HashSet<>();
expected.add(new Pair(1, 5));
expected.add(new Pair(7, -1));
assertTrue(expected.equals(pairSum.findPairs(a, sum)));
a = new int[] { 2, 5, 17, -1 };
sum = 7;
expected = new HashSet<>();
expected.add(new Pair(2, 5));
assertTrue(expected.equals(pairSum.findPairs(a, sum)));

```
<Overlap Ratio: 0.9422750424448217>

---

--- 97 --
Question ID: bb1d42e69aee131817a3cf876c3e59e7c0414f39
Original Code:
```
public class ArgParser
{

   private Logger log = LoggerFactory.getLogger(ArgParser.class);

   String args[]=null;
   
   /**
    * The constructor requires the arguements that are passed to the 
    * main method.
    */
   public ArgParser(String a[]) {
      args=a;
   }

   public String getStringArg(String key){
      return getStringArg(key, null);
   }

   /**
    * Returns the string corresponding to the requested key.
    */
   public String getStringArg(String key, String def) {
      for (int i=0; i<args.length; i++) {
         String arg=args[i];
         
         if (arg.equalsIgnoreCase(key) &&
             args.length >= i+2)
            return args[i+1].trim();
         
         if (arg.startsWith(key))
            return arg.substring(key.length()).trim();
      }
      return def;
   }

   public int size() {return args.length;}
   public String getLastArg() {
      if (args.length == 0)
         return null;
      return args[args.length-1];
   }

   /**
    *
    */
   public Integer getIntegerArg(String key) {
      String str=getStringArg(key);
      if (str == null || str.trim().length() <= 0) return null;
      
      Integer val=null;
      try {
         int i=Integer.parseInt(str.trim());
         val=new Integer(i);
      } catch (NumberFormatException ex) {
         log.warn("NumberFormatException reading "+key+" from "+
                             "args.");
      }
      return val;
   }

   /** */
   public int getIntArg(String key, int def) {
      Integer i=getIntegerArg(key);
      if (i == null)
         return def;
      else
         return i.intValue();
   }

   /** */
   public String toString() {
      StringBuffer sb=new StringBuffer();
      for (int i=0; i<args.length; i++) {
         sb.append("  "+i+": '"+args[i]+"'\n");
      }
      return sb.toString();
   }

   /**
    * Returns a boolean indicating whether a command like switch was
    * present.
    */ 
   public boolean getBooleanArg(String key) {
      for (int i=0; i<args.length; i++) {
         String arg=args[i];
         if (arg.equalsIgnoreCase(key))
            return true;
      }
      return false;
   }

   /**
    * Returns a boolean indicating whether a command like switch was
    * present.
    */ 
   public boolean getBooleanArg(String key, boolean def) {
      for (int i=0; i<args.length; i++) {
         String arg=args[i];
         if (arg.equalsIgnoreCase(key))
            return true;
      }
      return def;
   }
}
```


Overlapping Code:
```
er
{
private Logger log = LoggerFactory.getLogger(ArgParser.class);
String args[]=null;

/**
* The constructor requires the arguements that are passed to the 
* main method.
*/
public ArgParser(String a[]) {
args=a;
}
public String getStringArg(String key){
return getStringArg(key, null);
}
/**
* Returns the string corresponding to the requested key.
*/
public String getStringArg(String key, String def) {
for (int i=0; i<args.length; i++) {
String arg=args[i];

if (arg.equalsIgnoreCase(key) &&
args.length >= i+2)
return args[i+1].trim();

if (arg.startsWith(key))
return arg.substring(key.length()).trim();
}
return def;
}
public int size() {return args.length;}
public String getLastArg() {
if (args.length == 0)
return null;
return args[args.length-1];
}
/**
*
*/
public Integer getIntegerArg(String key) {
String str=getStringArg(key);
if (str == null || str.trim().length() <= 0) return null;

Integer val=null;
try {
int i=Integer.parseInt(str.trim());
val=new Integer(i);
} catch (NumberFormatException ex) {
log.warn("NumberFormatException reading "+key+" from "+
"args.");
}
return val;
}
/** */
public int getIntArg(String key, int def) {
Integer i=getIntegerArg(key);
if (i == null)
return def;
else
return i.intValue();
}
/** */
public String toString() {
StringBuffer sb=new StringBuffer();
for (int i=0; i<args.length; i++) {
sb.append(" "+i+": '"+args[i]+"'\n");
}
return sb.toString();
}
/**
* Returns a boolean indicating whether a command like switch was
* present.
*/ 
public boolean getBooleanArg(String key) {
for (int i=0; i<args.length; i++) {
String arg=args[i];
if (arg.equalsIgnoreCase(key))
return true;
}
return false;
}
/**
* Returns a boolean indicating whether a command like switch was
* present.
*/ 
public boolean getBooleanArg(String key, boolean def) {
for (int i=0; i<args.length; i++) {
String arg=args[i];
if (arg.equalsIgnoreCase(key))
retu
```
<Overlap Ratio: 0.9761781460383221>

---

--- 98 --
Question ID: 150f733a6699feb69b0ad9b07cc34aa2509834aa
Original Code:
```
public class Chat implements Receiver {
    protected JChannel channel;
    protected static final String CLUSTER="chat";

    @Override
    public void viewAccepted(View new_view) {
        System.out.println("Print view: " + new_view);
    }

    @Override
    public void receive(Message msg) {
        System.out.println("[" + msg.getSrc() + "]: " + msg.getObject());
    }

    public void start(JChannel channel) throws Exception {
        this.channel = channel;
        this.channel.setReceiver(this);
        this.channel.connect(CLUSTER);
        eventLoop();
        this.channel.close();
    }

    private void start(String props, String name, boolean nohup) throws Exception {
        this.channel = new JChannel(props);
        if (name != null) {
            this.channel.name(name);
        }
        this.channel.setReceiver(this);
        this.channel.connect(CLUSTER);
        if (!nohup) {
            eventLoop();
            this.channel.close();
        }
    }

    private void eventLoop() {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        while (true) {
            try {
                System.out.println("> ");
                System.out.flush();
                String line = in.readLine().toLowerCase();
                if (line.startsWith("quit") || line.startsWith("exit")) {
                    break;
                }
                Message msg = new Message(null, line);
                this.channel.send(msg);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws Exception {
        String props = "udp.xml";
        String name = null;
        boolean nohup = false;

        for (int i = 0; i < args.length; i++) {
            if(args[i].equals("-props")) {
                props=args[++i];
                continue;
            }
            if(args[i].equals("-name")) {
                name=args[++i];
                continue;
            }
            if(args[i].equals("-nohup")) {
                nohup=true;
                continue;
            }
            help();
            return;
        }

        new Chat().start(props, name, nohup);
    }

    private static void help() {
        System.out.println("Chat [-props XML config] [-name name] [-nohup]");
    }
}
```


Overlapping Code:
```
ass Chat implements Receiver {
protected JChannel channel;
protected static final String CLUSTER="chat";
@Override
public void viewAccepted(View new_view) {
System.out.println("Print view: " + new_view);
}
@Override
public void receive(Message msg) {
System.out.println("[" + msg.getSrc() + "]: " + msg.getObject());
}
public void start(JChannel channel) throws Exception {
this.channel = channel;
this.channel.setReceiver(this);
this.channel.connect(CLUSTER);
eventLoop();
this.channel.close();
}
private void start(String props, String name, boolean nohup) throws Exception {
this.channel = new JChannel(props);
if (name != null) {
this.channel.name(name);
}
this.channel.setReceiver(this);
this.channel.connect(CLUSTER);
if (!nohup) {
eventLoop();
this.channel.close();
}
}
private void eventLoop() {
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
while (true) {
try {
System.out.println("> ");
System.out.flush();
String line = in.readLine().toLowerCase();
if (line.startsWith("quit") || line.startsWith("exit")) {
break;
}
Message msg = new Message(null, line);
this.channel.send(msg);
} catch (Exception e) {
e.printStackTrace();
}
}
}
public static void main(String[] args) throws Exception {
String props = "udp.xml";
String name = null;
boolean nohup = false;
for (int i = 0; i < args.length; i++) {
if(args[i].equals("-props")) {
props=args[++i];
continue;
}
if(args[i].equals("-name")) {
name=args[++i];
continue;
}
if(args[i].equals("-nohup")) {
nohup=true;
continue;
}
help();
return;
}
new Chat().start(props, name, nohup);
}
private static void help() {
System.out.println("Chat [-props XML config] [-name name] [-nohup]");
```
<Overlap Ratio: 0.9922526817640047>

---

--- 99 --
Question ID: 6da84494d9f7a4023d8521930ca5bc512b552957
Original Code:
```
@Deprecated
public class PipelineBuilder {
  public PipelineBuilder(String application) {
    pipeline = Execution.newPipeline(application);
  }

  public PipelineBuilder withTrigger(Trigger trigger) {
    if (trigger != null) {
      pipeline.setTrigger(trigger);
    }
    return this;
  }

  public PipelineBuilder withNotifications(List<Map<String, Object>> notifications) {
    pipeline.getNotifications().clear();
    if (notifications != null) {
      pipeline.getNotifications().addAll(notifications);
    }
    return this;
  }

  public PipelineBuilder withPipelineConfigId(String id) {
    pipeline.setPipelineConfigId(id);
    return this;
  }

  public PipelineBuilder withStage(String type, String name, Map<String, Object> context) {
    if (context.get("providerType") != null && !(Arrays.asList("aws", "titus")).contains(context.get("providerType"))) {
      type += "_" + context.get("providerType");
    }
    pipeline.getStages().add(new Stage(pipeline, type, name, context));
    return this;
  }

  public PipelineBuilder withStage(String type, String name) {
    return withStage(type, name, new HashMap<>());
  }

  public PipelineBuilder withStage(String type) {
    return withStage(type, type, new HashMap<>());
  }

  public PipelineBuilder withStages(List<Map<String, Object>> stages) {
    stages.forEach(it -> {
      String type = it.remove("type").toString();
      String name = it.containsKey("name")? it.remove("name").toString() : null;
      withStage(type, name != null ? name : type, it);
    });
    return this;
  }

  public Execution build() {
    pipeline.setBuildTime(System.currentTimeMillis());
    pipeline.setAuthentication(Execution.AuthenticationDetails.build().orElse(new Execution.AuthenticationDetails()));

    return pipeline;
  }

  public PipelineBuilder withName(String name) {
    pipeline.setName(name);
    return this;
  }

  public PipelineBuilder withLimitConcurrent(boolean concurrent) {
    pipeline.setLimitConcurrent(concurrent);
    return this;
  }

  public PipelineBuilder withKeepWaitingPipelines(boolean waiting) {
    pipeline.setKeepWaitingPipelines(waiting);
    return this;
  }

  public PipelineBuilder withOrigin(String origin) {
    pipeline.setOrigin(origin);
    return this;
  }

  public PipelineBuilder withSource(Execution.PipelineSource source) {
    pipeline.setSource(source);
    return this;
  }

  public PipelineBuilder withStartTimeExpiry(String startTimeExpiry) {
    if (startTimeExpiry != null) {
      pipeline.setStartTimeExpiry(Long.valueOf(startTimeExpiry));
    }
    return this;
  }

  private final Execution pipeline;
}
```


Overlapping Code:
```
elineBuilder {
public PipelineBuilder(String application) {
pipeline = Execution.newPipeline(application);
}
public PipelineBuilder withTrigger(Trigger trigger) {
if (trigger != null) {
pipeline.setTrigger(trigger);
}
return this;
}
public PipelineBuilder withNotifications(List<Map<String, Object>> notifications) {
pipeline.getNotifications().clear();
if (notifications != null) {
pipeline.getNotifications().addAll(notifications);
}
return this;
}
public PipelineBuilder withPipelineConfigId(String id) {
pipeline.setPipelineConfigId(id);
return this;
}
public PipelineBuilder withStage(String type, String name, Map<String, Object> context) {
if (context.get("providerType") != null && !(Arrays.asList("aws", "titus")).contains(context.get("providerType"))) {
type += "_" + context.get("providerType");
}
pipeline.getStages().add(new Stage(pipeline, type, name, context));
return this;
}
public PipelineBuilder withStage(String type, String name) {
return withStage(type, name, new HashMap<>());
}
public PipelineBuilder withStage(String type) {
return withStage(type, type, new HashMap<>());
}
public PipelineBuilder withStages(List<Map<String, Object>> stages) {
stages.forEach(it -> {
String type = it.remove("type").toString();
String name = it.containsKey("name")? it.remove("name").toString() : null;
withStage(type, name != null ? name : type, it);
});
return this;
}
public Execution build() {
pipeline.setBuildTime(System.currentTimeMillis());
pipeline.setAuthentication(Execution.AuthenticationDetails.build().orElse(new Execution.AuthenticationDetails()));
return pipeline;
}
public PipelineBuilder withName(String name) {
pipeline.setName(name);
return this;
}
public PipelineBuilder withLimitConcurrent(boolean concurrent) {
pipeline.setLimitConcurrent(concurrent);
return this;
}
public PipelineBuilder withKeepWaitingPipelines(boolean waiting) {
pipeline.setKeepWaitingPipelines(waiting);
return this;
}
public PipelineBuilder withOrigin(String origin) {
pipeline.setOrigin(origin);
return this;
}
public PipelineBuilder withSource(Execution.PipelineSource source) {
pipeline.setSource(source);
return this;
}
public PipelineBuilder withStartTimeExpiry(String startTimeExpiry) {
if
```
<Overlap Ratio: 0.975177304964539>

---

--- 100 --
Question ID: 4e0feaadb88a73f8cd16c8a17885fed4045b4e8a
Original Code:
```
public class ExternalAPIAccessFilter implements Filter {
    private static final Logger logger = Logger.getLogger(ExternalAPIAccessFilter.class.getName());
    private static String appName = "";

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        appName = filterConfig.getInitParameter("app_name");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {


        logger.info("Get Patient Record request received ");

        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;

        String reg_url = httpServletRequest.getRequestURL().toString();
        // no token validation  for healthCheck request
        if (reg_url.contains("healthCheck")) {
            chain.doFilter(request, response);
        } else {

            String headerAuthToken = ((HttpServletRequest) request).getHeader("Authorization");
            String userID = "";

            // validate the incoming authorization token by calling dev keycloak and produce the principal user identifier associated with the token
            Client client = ClientBuilder.newClient();

            KeycloakConfig kc = getConfig();

            String url = kc.getAuthServerUrl();
            String path = kc.getPathPrefix() + "/" + kc.getRealm() + "/" + kc.getPathSuffix();

            WebTarget target = client.target(url).path(path);

            Boolean isUserAllowedAccess = false;

            try {
                Response kcResponse = target
                        .request()
                        .header("Authorization", "Bearer " + headerAuthToken)
                        .get();

                String entityResponse = kcResponse.readEntity(String.class);

                JSONParser parser = new JSONParser();
                JSONObject users = (JSONObject) parser.parse(entityResponse);
                userID = users.get("sub").toString();

                ((HttpServletRequest) request).getHeader("Authorization");

                if (kcResponse.getStatus() == HttpStatus.SC_OK) { // user is authorized in keycloak, so get the user record and ID associated with the token
               /* String entityResponse = kcResponse.readEntity(String.class);
                JSONParser parser = new JSONParser();
                JSONObject users = (JSONObject) parser.parse(entityResponse);
                userID = users.get("sub").toString();
                logger.info("userId: "+userID);*/

                    isUserAllowedAccess = UserCache.getExternalUserApplicationAccess(userID, appName);


                } else { // user is not authorized with this token
                    httpServletResponse.sendError(403, "Access is Forbidden");
                    return;
                }

            } catch (Exception ex) {
                httpServletResponse.sendError(403, "Access is Forbidden");
                return;
            }

            MutableHttpServletRequest mutableRequest = new MutableHttpServletRequest(httpServletRequest);

            mutableRequest.putHeader("user_id", userID);

            if (!isUserAllowedAccess) {
                httpServletResponse.sendError(403, "Access is Forbidden");
                return;
            } else {

                chain.doFilter(mutableRequest, response);
                return;
            }

        }
    }

    @Override
    public void destroy() {

    }

    private KeycloakConfig getConfig() throws IOException {
        JsonNode jsonnode =  ConfigManager.getConfigurationAsJson("keycloak_filter","ex_access_filter");
        KeycloakConfig keycloakConfig = new KeycloakConfig();
        keycloakConfig.setAuthServerUrl(jsonnode.get("auth-server-url").asText());
        keycloakConfig.setRealm(jsonnode.get("realm").asText());
        keycloakConfig.setPathPrefix(jsonnode.get("path_prefix").asText());
        keycloakConfig.setPathSuffix(jsonnode.get("path_suffix").asText());
        return keycloakConfig;
    }
}
```


Overlapping Code:
```
cessFilter implements Filter {
private static final Logger logger = Logger.getLogger(ExternalAPIAccessFilter.class.getName());
private static String appName = "";
@Override
public void init(FilterConfig filterConfig) throws ServletException {
appName = filterConfig.getInitParameter("app_name");
}
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
logger.info("Get Patient Record request received ");
HttpServletRequest httpServletRequest = (HttpServletRequest) request;
HttpServletResponse httpServletResponse = (HttpServletResponse) response;
String reg_url = httpServletRequest.getRequestURL().toString();
// no token validation for healthCheck request
if (reg_url.contains("healthCheck")) {
chain.doFilter(request, response);
} else {
String headerAuthToken = ((HttpServletRequest) request).getHeader("Authorization");
String userID = "";
// validate the incoming authorization token by calling dev keycloak and produce the principal user identifier associated with the token
Client client = ClientBuilder.newClient();
KeycloakConfig kc = getConfig();
String url = kc.getAuthServerUrl();
String path = kc.getPathPrefix() + "/" + kc.getRealm() + "/" + kc.getPathSuffix();
WebTarget target = client.target(url).path(path);
Boolean isUserAllowedAccess = false;
try {
Response kcResponse = target
.request()
.header("Authorization", "Bearer " + headerAuthToken)
.get();
String entityResponse = kcResponse.readEntity(String.class);
JSONParser parser = new JSONParser();
JSONObject users = (JSONObject) parser.parse(entityResponse);
userID = users.get("sub").toString();
((HttpServletRequest) request).getHeader("Authorization");
if (kcResponse.getStatus() == HttpStatus.SC_OK) { // user is authorized in keycloak, so get the user record and ID associated with the token
/* String entityResponse = kcResponse.readEntity(String.class);
JSONParser parser = new JSONParser();
JSONObject us
```
<Overlap Ratio: 0.9738400789733465>

---

--- 101 --
Question ID: 805c4d4e971b543d87c1fc83a49815496ed5bdc6
Original Code:
```
public final class CharUtil {
    private CharUtil() {
        noInstanceError();
    }

    public static final int indexOf(final char[] src, final char[] test) {
        return indexOf(src, test, 0);
    }

    public static final int indexOf(final char[] src, final char[] test, int fromIndex) {
        BooleanUtil.requireFalse(fromIndex < 0);

        if (src == test) {
            return fromIndex > 0 ? -1 : 0;
        }

        final int l1 = src.length, l2 = test.length;
        if (fromIndex == l1) {
            return -1;
        }
        BooleanUtil.requireTrue(fromIndex < l1);

        if (l2 == 0) {
            return fromIndex;
        }

        if (l2 > l1) {
            return -1;
        }

        final char first = test[0];
        for (int i = fromIndex, idx; i < l1; i++) {
            if (src[i] == first) {
                idx = 1;
                for (; idx < l2; idx++) {
                    if (src[idx + i] != test[idx]) {
                        break;
                    }
                }
                if (idx >= l2) {
                    return i;
                }
            }
        }
        return -1;
    }

    /**
     * "[4e00-9fa5]"
     *
     * @param ch
     * @return
     */
    public static final boolean isChinese(int ch) {
        return ch < 40870 && ch > 19967;
    }

    public static final boolean isLetterOrDigit(int ch) {
        return isDigit(ch) || isLetter(ch);
    }

    /**
     * A-Z,a-z
     *
     * @param ch
     * @return
     */
    public static final boolean isLetter(int ch) {
        return isLowerCase(ch) || isUpperCase(ch);
    }

    /**
     * A-Z
     *
     * @param ch
     * @return
     */
    public static final boolean isUpperCase(int ch) {
        return ch > 64 && ch < 91;
    }

    /**
     * a-z
     *
     * @param ch
     * @return
     */
    public static final boolean isLowerCase(int ch) {
        return ch > 96 && ch < 123;
    }

    /**
     * 0-9
     *
     * @param ch
     * @return
     */
    public static final boolean isDigit(int ch) {
        return ch > 47 && ch < 58;
    }

    public static final boolean equalsIgnoreCase(int ch1, int ch2) {
        if (ch1 == ch2) {
            return true;
        }
        if (isLowerCase(ch1) && isUpperCase(ch2)) {
            return ch1 - 32 == ch2;
        }
        if (isUpperCase(ch1) && isLowerCase(ch2)) {
            return ch2 - 32 == ch1;
        }
        return false;
    }

    public static final boolean isASCIICode(int ch) {
        return ch < 128;
    }

    public static boolean isChar(Object o) {
        return o != null && o.getClass() == Character.class;
    }

    public static char toCharValue(Boolean bool) {
        return (char) (bool == null || !bool ? 48 : 49);
    }

    public static char toCharValue(long value) {
        return (char) value;
    }

    public static char toCharValue(float value) {
        return (char) value;
    }

    public static char toCharValue(double value) {
        return (char) value;
    }

    public static char toCharValue(CharSequence cs) {
        if (cs == null) {
            throw new IllegalArgumentException(
                String.format("Can not cast to char of: %s", cs));
        }
        String temp = cs.toString();
        if (temp.length() == 1) {
            return temp.charAt(0);
        }
        throw new IllegalArgumentException(
            String.format("Can not cast to char of: %s", cs));
    }

    /**
     * @param o
     * @return
     * @see IntUtil#toIntValue(Object)
     */
    public static char toCharValue(Object o) {
        if (o == null) {
            return 0;
        }
        if (o instanceof Character) {
            return (Character) o;
        }
        if (o instanceof Number) {
            return (char) ((Number) o).intValue();
        }
        if (o instanceof CharSequence) {
            return toCharValue(o.toString());
        }
        if (o instanceof Boolean) {
            boolean bool = (boolean) o;
            return (char) (bool ? 49 : 48);
        }
        try {
            Object firstItem = SupportUtil.onlyOneItemOrSize(o);
            return toCharValue(firstItem);
        } catch (Exception e) {
            throw new IllegalArgumentException(String.format("Can not cast to char of: %s", o), e);
        }
    }
}
```


Overlapping Code:
```
 class CharUtil {
private CharUtil() {
noInstanceError();
}
public static final int indexOf(final char[] src, final char[] test) {
return indexOf(src, test, 0);
}
public static final int indexOf(final char[] src, final char[] test, int fromIndex) {
BooleanUtil.requireFalse(fromIndex < 0);
if (src == test) {
return fromIndex > 0 ? -1 : 0;
}
final int l1 = src.length, l2 = test.length;
if (fromIndex == l1) {
return -1;
}
BooleanUtil.requireTrue(fromIndex < l1);
if (l2 == 0) {
return fromIndex;
}
if (l2 > l1) {
return -1;
}
final char first = test[0];
for (int i = fromIndex, idx; i < l1; i++) {
if (src[i] == first) {
idx = 1;
for (; idx < l2; idx++) {
if (src[idx + i] != test[idx]) {
break;
}
}
if (idx >= l2) {
return i;
}
}
}
return -1;
}
/**
* "[4e00-9fa5]"
*
* @param ch
* @return
*/
public static final boolean isChinese(int ch) {
return ch < 40870 && ch > 19967;
}
public static final boolean isLetterOrDigit(int ch) {
return isDigit(ch) || isLetter(ch);
}
/**
* A-Z,a-z
*
* @param ch
* @return
*/
public static final boolean isLetter(int ch) {
return isLowerCase(ch) || isUpperCase(ch);
}
/**
* A-Z
*
* @param ch
* @return
*/
public static final boolean isUpperCase(int ch) {
return ch > 64 && ch < 91;
}
/**
* a-z
*
* @param ch
* @return
*/
public static final boolean isLowerCase(int ch) {
return ch > 96 && ch < 123;
}
/**
* 0-9
*
* @param ch
* @return
*/
public static final boolean isDigit(int ch) {
return ch > 47 && ch < 58;
}
public static final boolean equalsIgnoreCase(int ch1, int ch2) {
if (ch1 == ch2) {
return true;
}
if (isLowerCase(ch1) && isUpperCase(ch2)) {
return ch1 - 32 == ch2;
}
if (isUpperCase(ch1) && isLowerCase(ch2)) {
return ch2 - 32 == ch1;
}
return false;
}
public static final boolean is
```
<Overlap Ratio: 0.9931153184165232>

---

--- 102 --
Question ID: 31df0e4c199c6ad6811a1c4cf033a6a96ac3656d
Original Code:
```
@SuppressWarnings("WeakerAccess")
public class Fluentd extends Recorder implements SimpleBuildStep {
    public static final String DEFAULT_LOGGER = "Jenkins";
    public static final String DEFAULT_HOST = "localhost";
    public static final int DEFAULT_PORT = 24224;

    private static transient volatile FluentLogger fluentLogger;
    private final String tag;
    private final String json;
    private final String fileName;
    private final boolean failBuild;

    @DataBoundConstructor
    public Fluentd(String tag, boolean failBuild, String fileName, String json) {
        this.tag = tag;
        this.failBuild = failBuild;
        this.fileName = fileName;
        this.json = json;
    }

    @SuppressWarnings("unused")
    public String getTag() {
        return tag;
    }

    @SuppressWarnings("unused")
    public String getFileName() {
        return fileName;
    }

    @SuppressWarnings("unused")
    public String getJson() {
        return json;
    }

    @SuppressWarnings("unused")
    public boolean isFailBuild() {
        return failBuild;
    }

    @Override
    public void perform(@Nonnull Run<?, ?> build, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener) throws IOException, InterruptedException {
        boolean succeed = false;

        // TODO: Publish from slave if it's possible
        if (fileName != null && !fileName.isEmpty()) {
            final FilePath file = new FilePath(workspace, fileName);
            if (file.exists()) {
                succeed = send(json, file.readToString(), build, listener);
            } else {
                listener.error("File doesn't exist: " + fileName);
            }
        } else {
            succeed = send(json, "{}", build, listener);
        }

        if (!succeed && failBuild) {
            build.setResult(Result.FAILURE);
        }
    }

    private boolean send(String json, String jsonFromFile, @Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {
        final Map<String, String> envVars = getEnvVariables(build, listener);

        try {
            sendJson(getFluentLogger(), tag, envVars, json, jsonFromFile, build.getStartTimeInMillis());
            return true;
        } catch (IllegalArgumentException e) {
            listener.error(e.getMessage());
            e.printStackTrace(listener.getLogger());
            return false;
        }
    }

    private Map<String, String> getEnvVariables(@Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {
        Map<String, String> envVars;
        try {
            envVars = build.getEnvironment(listener);
        } catch (IOException e) {
            listener.error("Failed to get environment variables");
            e.printStackTrace(listener.getLogger());
            envVars = new HashMap<>();
        }
        return envVars;
    }

    private FluentLogger getFluentLogger() {
        if (fluentLogger == null) {
            synchronized (Fluentd.class) {
                if (fluentLogger == null) {
                    final DescriptorImpl desc = getDescriptor();
                    fluentLogger = FluentLogger.getLogger(desc.getLoggerName(), desc.getHost(), getDescriptor().getPort());
                }
            }
        }
        return fluentLogger;
    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Override
    public BuildStepMonitor getRequiredMonitorService() {
        return BuildStepMonitor.NONE;
    }

    /**
     * Descriptor for {@link Fluentd}. Used as a singleton.
     * The class is marked as public so that it can be accessed from views.
     * <p>
     * See <tt>src/main/resources/hudson/plugins/hello_world/Fluentd/*.jelly</tt>
     * for the actual HTML fragment for the configuration screen.
     */
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {
        /**
         * To persist global configuration information,
         * simply store it in a field and call save().
         * <p>
         * <p>
         * If you don't want fields to be persisted, use <tt>transient</tt>.
         */
        private String loggerName;
        private String host;
        private int port;

        /**
         * In order to load the persisted global configuration, you have to
         * call load() in the constructor.
         */
        public DescriptorImpl() {
            load();
            if (port == 0) port = DEFAULT_PORT;
            if (host == null || host.isEmpty()) host = DEFAULT_HOST;
            if (loggerName == null || loggerName.isEmpty()) loggerName = DEFAULT_LOGGER;
        }

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            // Indicates that this builder can be used with all kinds of project types 
            return true;
        }

        /**
         * This human readable name is used in the configuration screen.
         */
        @Override
        public String getDisplayName() {
            return "Send to Fluentd";
        }

        @Override
        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
            loggerName = formData.optString("loggerName", DEFAULT_LOGGER);
            port = formData.optInt("port", DEFAULT_PORT);
            host = formData.optString("host", DEFAULT_HOST);
            save();
            fluentLogger = null; // reset logger
            return super.configure(req, formData);
        }

        public String getLoggerName() {
            return loggerName;
        }

        public int getPort() {
            return port;
        }

        public String getHost() {
            return host;
        }
    }
}
```


Overlapping Code:
```
cess")
public class Fluentd extends Recorder implements SimpleBuildStep {
public static final String DEFAULT_LOGGER = "Jenkins";
public static final String DEFAULT_HOST = "localhost";
public static final int DEFAULT_PORT = 24224;
private static transient volatile FluentLogger fluentLogger;
private final String tag;
private final String json;
private final String fileName;
private final boolean failBuild;
@DataBoundConstructor
public Fluentd(String tag, boolean failBuild, String fileName, String json) {
this.tag = tag;
this.failBuild = failBuild;
this.fileName = fileName;
this.json = json;
}
@SuppressWarnings("unused")
public String getTag() {
return tag;
}
@SuppressWarnings("unused")
public String getFileName() {
return fileName;
}
@SuppressWarnings("unused")
public String getJson() {
return json;
}
@SuppressWarnings("unused")
public boolean isFailBuild() {
return failBuild;
}
@Override
public void perform(@Nonnull Run<?, ?> build, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener) throws IOException, InterruptedException {
boolean succeed = false;
// TODO: Publish from slave if it's possible
if (fileName != null && !fileName.isEmpty()) {
final FilePath file = new FilePath(workspace, fileName);
if (file.exists()) {
succeed = send(json, file.readToString(), build, listener);
} else {
listener.error("File doesn't exist: " + fileName);
}
} else {
succeed = send(json, "{}", build, listener);
}
if (!succeed && failBuild) {
build.setResult(Result.FAILURE);
}
}
private boolean send(String json, String jsonFromFile, @Nonnull Run<?, ?> build, @Nonnull TaskListener listener) throws InterruptedException {
final Map<String, String> envVars = getEnvVariables(build, listener);
try {
sendJson(getFluentLogger(), tag, envVars, json, jsonFromFile, build.getStartTimeInMillis());
return true;
} catch (IllegalArgumentException e) {
listener.error(e.getMessage());
e.printStackTrace(listener.getLogger());
return false;
}
}
private Map<String, String> getE
```
<Overlap Ratio: 0.9751824817518249>

---

--- 103 --
Question ID: 3761c5ddef33ec41d5f22744fe9138cd0ef2a45b
Original Code:
```
public class GroupMemberAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> implements View.OnClickListener {

    private List<GroupMember> memberList = new ArrayList<>();
    private int iconWidth;
    private int iconHeight;
    private int itemPadding;
    private Context mContext;

    private boolean mEnableCheckMenberInfo;
    private View.OnClickListener mAddGroupListener;

    private static final int CONTENT = 0;
    private static final int ADD_BTN = 1;

    public GroupMemberAdapter(Context context, boolean enableCheckMenberInfo, View.OnClickListener listener){
        itemPadding = AppTools.dip2px(8);
        iconWidth = (Resources.getSystem().getDisplayMetrics().widthPixels - itemPadding ) / 7;
        iconHeight = iconWidth;
        mContext = context;
        this.mAddGroupListener = listener;
        this.mEnableCheckMenberInfo = enableCheckMenberInfo;
    }
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        if (viewType == CONTENT){
            return new LogoNameViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));
        }else {
            return new AddMemberViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));
        }
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if (holder instanceof LogoNameViewHolder){

            LogoNameViewHolder holder1 = (LogoNameViewHolder) holder;
            GroupMember member = memberList.get(position);
            holder1.name.setText(member.name);

            holder1.itemView.setPadding( 0,  0,  itemPadding,  0);

            holder1.icon.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
            holder1.icon.load(FileURLBuilder.getUserIconUrl(member.account), R.mipmap.lianxiren, 999);
            holder1.itemView.setTag(member);
            holder1.itemView.setOnClickListener(this);
        }else if (holder instanceof AddMemberViewHolder){
            AddMemberViewHolder holder2 = (AddMemberViewHolder) holder;
            holder2.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
            holder2.imageView.setOnClickListener(mAddGroupListener);
            holder2.nameTv.setTextColor(mContext.getResources().getColor(R.color.tex_color_blue_1068ed));
        }
    }

    @Override
    public int getItemViewType(int position) {
        if (memberList.size() >  5){
            return position > 4 ? ADD_BTN : CONTENT;
        }else {
            return position < memberList.size() ? CONTENT : ADD_BTN;
        }
    }

    public void setmEnableCheckMenberInfo(boolean mEnableCheckMenberInfo) {
        this.mEnableCheckMenberInfo = mEnableCheckMenberInfo;
        notifyDataSetChanged();
    }

    boolean isFirstColumn(int pos) {
        return pos % 5 == 0;
    }

    boolean isFirstRow(int pos) {
        return pos < 5 ;
    }


    boolean isLastColumn(int pos) {
        return (pos+1) % 5 == 0;
    }


    public void addAll(List<GroupMember> list) {
        if (memberList.equals(list)) {
            return;
        }
        memberList.clear();
        if (list.size() > 5 ){
            memberList.addAll(list.subList(0, 5));
        }else {
            memberList.addAll(list);
        }

        notifyDataSetChanged();
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public int getItemCount() {
        return memberList.size() + 1;
    }


    @Override
    public void onClick(View v) {
        GroupMember member = (GroupMember) v.getTag();
        Friend friend = FriendRepository.queryFriend(member.account, mListener);
        if (friend != null){
            postQueryFriend(friend);
        }
    }

    private HttpRequestListener<BasePersonInfoResult> mListener = new HttpRequestListener<BasePersonInfoResult>() {
        @Override
        public void onHttpRequestSucceed(BasePersonInfoResult result, OriginalCall call) {
            if (result.isSuccess()){
                Friend friend = User.UserToFriend(result.getData());
                FriendRepository.save(friend);
                postQueryFriend(friend);
            }
        }

        @Override
        public void onHttpRequestFailure(Exception e, OriginalCall call) {

        }
    };

    private void postQueryFriend(Friend friend){
        if (mEnableCheckMenberInfo){
            Intent intent = new Intent(mContext, PersonInfoActivity.class);
            intent.putExtra(Friend.class.getName(), friend);
            mContext.startActivity(intent);
        }
    }

    public class AddMemberViewHolder extends RecyclerView.ViewHolder{
        @BindView(R.id.icon)
        WebImageView imageView;
        @BindView(R.id.name)
        TextView nameTv;

        public AddMemberViewHolder(@NonNull View itemView) {
            super(itemView);
            ButterKnife.bind(this, itemView);
        }
    }
}
```


Overlapping Code:
```
lass GroupMemberAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> implements View.OnClickListener {
private List<GroupMember> memberList = new ArrayList<>();
private int iconWidth;
private int iconHeight;
private int itemPadding;
private Context mContext;
private boolean mEnableCheckMenberInfo;
private View.OnClickListener mAddGroupListener;
private static final int CONTENT = 0;
private static final int ADD_BTN = 1;
public GroupMemberAdapter(Context context, boolean enableCheckMenberInfo, View.OnClickListener listener){
itemPadding = AppTools.dip2px(8);
iconWidth = (Resources.getSystem().getDisplayMetrics().widthPixels - itemPadding ) / 7;
iconHeight = iconWidth;
mContext = context;
this.mAddGroupListener = listener;
this.mEnableCheckMenberInfo = enableCheckMenberInfo;
}
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
if (viewType == CONTENT){
return new LogoNameViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));
}else {
return new AddMemberViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_grid_group_member, parent, false));
}
}
@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
if (holder instanceof LogoNameViewHolder){
LogoNameViewHolder holder1 = (LogoNameViewHolder) holder;
GroupMember member = memberList.get(position);
holder1.name.setText(member.name);
holder1.itemView.setPadding( 0, 0, itemPadding, 0);
holder1.icon.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
holder1.icon.load(FileURLBuilder.getUserIconUrl(member.account), R.mipmap.lianxiren, 999);
holder1.itemView.setTag(member);
holder1.itemView.setOnClickListener(this);
}else if (holder instanceof AddMemberViewHolder){
AddMemberViewHolder holder2 = (AddMemberViewHolder) holder;
holder2.imageView.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
holder2.imageView.setOnClickListener(mAddGroupListener);
holde
```
<Overlap Ratio: 0.9783210332103321>

---

--- 104 --
Question ID: 09343084dac137b7556062d8077e9fdff9e6951a
Original Code:
```
@Slf4j
@Service
public class CouponServiceImpl implements CouponService {

    @Autowired
    CouponRepository couponRepository;
    @Autowired
    CouponUserRepository couponUserRepository;


    @Override
    public Optional<CouponEntity> findById(Integer couponId) {
        return couponRepository.findById(couponId);
    }

    @Override
    public Optional<CouponEntity> findByCode(String code) {
        return couponRepository.findByCode(code);
    }

    @Override
    public Page<CouponEntity> findPage(Integer pageNum, Integer pageSize) {
        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {

            Predicate predicate = criteriaBuilder.conjunction();
            List<Expression<Boolean>> expressions = predicate.getExpressions();
            expressions.add(criteriaBuilder.equal(root.<Boolean>get("deleted"), false));
            return predicate;
        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, "id")));

        return page;
    }


    @Override
    public Page<CouponEntity> findByUserIdPage(String userId, Integer pageNum, Integer pageSize) {

        List<CouponUserEntity> couponUserEntities = couponUserRepository.findByUserIdAndDeleted(userId, false).orElseGet(() -> new ArrayList<>());
        List<Integer> couponIds = couponUserEntities.stream().map(CouponUserEntity::getCouponId).collect(Collectors.toList());
        Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {

            Predicate predicate = criteriaBuilder.conjunction();
            List<Expression<Boolean>> expressions = predicate.getExpressions();
            expressions.add(criteriaBuilder.equal(root.<Boolean>get("deleted"), false));
            if (!CollectionUtils.isEmpty(couponIds)) {
                CriteriaBuilder.In<Integer> in = criteriaBuilder.in(root.<Integer>get("id"));
                for (Integer id : couponIds) {
                    in.value(id);
                }
                expressions.add(criteriaBuilder.and(in));
            }


            return predicate;
        }, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, "id")));

        return page;
    }


    @Override
    public Optional<List<CouponEntity>> findByIdIn(List<Integer> couponIds) {
        return couponRepository.findByDeletedAndIdIn(false, couponIds);
    }


    /**
     * 检测优惠券是否适合
     *
     * @param userId
     * @param couponId
     * @param checkedGoodsPrice
     * @return
     */
    @Override
    public CouponEntity checkCoupon(String userId, Integer couponId, Integer userCouponId, BigDecimal checkedGoodsPrice) {
        CouponEntity couponEntity = couponRepository.findById(couponId).orElseThrow(() -> new BusinessException("拼团记录不存在"));

        CouponUserEntity couponUserEntity = couponUserRepository.findById(userCouponId).orElseGet(() -> {
            CouponUserEntity entity = couponUserRepository.findByUserIdAndCouponIdAndDeleted(userId, couponId, false)
                    .orElseGet(() -> new CouponUserEntity());
            return entity;
        });
        if (!couponId.equals(couponUserEntity.getCouponId())) {
            throw new BusinessException("优惠券未领取");
        }

        // 检查是否超期
        LocalDateTime now = LocalDateTime.now();
        CouponTimeTypeEnum commentTypeEnum = CouponTimeTypeEnum.parse(couponEntity.getTimeType());
        switch (commentTypeEnum) {
            case TIME_TYPE_TIME: {
                if (now.isBefore(couponEntity.getStartTime()) || now.isAfter(couponEntity.getEndTime())) {
                    throw new BusinessException("优惠券未领取");
                }
                break;
            }
            case TIME_TYPE_DAYS: {
                LocalDateTime expired = couponUserEntity.getAddTime().plusDays(couponEntity.getDays());
                if (now.isAfter(expired)) {
                    throw new BusinessException("优惠券未领取");
                }
                break;
            }
            default: {
                throw new BusinessException("优惠券未领取");
            }
        }

        // 检测商品是否符合
        // TODO 目前仅支持全平台商品，所以不需要检测
        if (GoodsRestrictionTypeEnum.GOODS_TYPE_ALL.getCode() != couponEntity.getGoodsType()) {
            throw new BusinessException("优惠券未领取");
        }

        // 检测订单状态
        if (CouponStatusEnum.STATUS_NORMAL.getCode() != couponEntity.getStatus()) {
            throw new BusinessException("优惠券未领取");
        }
        // 检测是否满足最低消费
        if (checkedGoodsPrice.compareTo(couponEntity.getMin()) == -1) {
            throw new BusinessException("优惠券未领取");
        }

        return couponEntity;
    }
}
```


Overlapping Code:
```
Service
public class CouponServiceImpl implements CouponService {
@Autowired
CouponRepository couponRepository;
@Autowired
CouponUserRepository couponUserRepository;
@Override
public Optional<CouponEntity> findById(Integer couponId) {
return couponRepository.findById(couponId);
}
@Override
public Optional<CouponEntity> findByCode(String code) {
return couponRepository.findByCode(code);
}
@Override
public Page<CouponEntity> findPage(Integer pageNum, Integer pageSize) {
Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {
Predicate predicate = criteriaBuilder.conjunction();
List<Expression<Boolean>> expressions = predicate.getExpressions();
expressions.add(criteriaBuilder.equal(root.<Boolean>get("deleted"), false));
return predicate;
}, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, "id")));
return page;
}
@Override
public Page<CouponEntity> findByUserIdPage(String userId, Integer pageNum, Integer pageSize) {
List<CouponUserEntity> couponUserEntities = couponUserRepository.findByUserIdAndDeleted(userId, false).orElseGet(() -> new ArrayList<>());
List<Integer> couponIds = couponUserEntities.stream().map(CouponUserEntity::getCouponId).collect(Collectors.toList());
Page<CouponEntity> page = couponRepository.findAll((Specification<CouponEntity>) (root, criteriaQuery, criteriaBuilder) -> {
Predicate predicate = criteriaBuilder.conjunction();
List<Expression<Boolean>> expressions = predicate.getExpressions();
expressions.add(criteriaBuilder.equal(root.<Boolean>get("deleted"), false));
if (!CollectionUtils.isEmpty(couponIds)) {
CriteriaBuilder.In<Integer> in = criteriaBuilder.in(root.<Integer>get("id"));
for (Integer id : couponIds) {
in.value(id);
}
expressions.add(criteriaBuilder.and(in));
}
return predicate;
}, PageRequest.of(pageNum, pageSize, new Sort(Sort.Direction.DESC, "id")));
return page;
}
@Override
public Optional<List<CouponEntity>> findByIdIn(List<Integer> couponIds) {
return couponRepository.findByDeletedAndIdIn(false, couponIds);

```
<Overlap Ratio: 0.9837631327602674>

---

--- 105 --
Question ID: ce4087cfa0e19ec9e27c4dfc66c095d3f1a8c929
Original Code:
```
@Service
public class DefaultShippingRateService implements ShippingRateService {
    private final ShippingRates shippingRates;

    @Inject
    public DefaultShippingRateService(ShippingRates shippingRates) {
        this.shippingRates = shippingRates;
    }

    private ShippingRate findShippingRate(List<ShippingRate> rates, Double value) {
        ShippingRate rate = null;
        for (ShippingRate rt : rates) {
            if (rt.getLowerBound() <= value) {
                if (rate == null || rate.getLowerBound() < rt.getLowerBound()) {
                    rate = rt;
                }
            }
        }
        return rate;
    }

    @Override
    public ShippingRate findShippingRateFor(ShippingType shippingType, ShippingRateType type, String countryCode,
        String stateCode, String zipCode, Double value) {
        ShippingRate shippingRate = null;
        List<ShippingRate> shippingRateList = null;

        if (zipCode != null) {
            shippingRateList = shippingRates.forZip(shippingType, type, countryCode, zipCode);
        }

        if ((shippingRateList == null || shippingRateList.size() == 0) && stateCode != null) {
            shippingRateList = shippingRates.forState(shippingType, type, countryCode, stateCode);
        }

        if ((shippingRateList == null || shippingRateList.size() == 0) && countryCode != null) {
            shippingRateList = shippingRates.forCountry(shippingType, type, countryCode);
        }

        if (shippingRateList == null || shippingRateList.size() == 0)
            return null;

        return findShippingRate(shippingRateList, value);
    }

}
```


Overlapping Code:
```
vice implements ShippingRateService {
private final ShippingRates shippingRates;
@Inject
public DefaultShippingRateService(ShippingRates shippingRates) {
this.shippingRates = shippingRates;
}
private ShippingRate findShippingRate(List<ShippingRate> rates, Double value) {
ShippingRate rate = null;
for (ShippingRate rt : rates) {
if (rt.getLowerBound() <= value) {
if (rate == null || rate.getLowerBound() < rt.getLowerBound()) {
rate = rt;
}
}
}
return rate;
}
@Override
public ShippingRate findShippingRateFor(ShippingType shippingType, ShippingRateType type, String countryCode,
String stateCode, String zipCode, Double value) {
ShippingRate shippingRate = null;
List<ShippingRate> shippingRateList = null;
if (zipCode != null) {
shippingRateList = shippingRates.forZip(shippingType, type, countryCode, zipCode);
}
if ((shippingRateList == null || shippingRateList.size() == 0) && stateCode != null) {
shippingRateList = shippingRates.forState(shippingType, type, countryCode, stateCode);
}
if ((shippingRateList == null || shippingRateList.size() == 0) && countryCode != null) {
shippingRateList = shippingRates.forCountry(shippingType, type, countryCode);
}
if (shippingRateList == null || shippingRateList.size() == 0)
return null;
return findS
```
<Overlap Ratio: 0.9363295880149812>

---

--- 106 --
Question ID: 74c857c84a0c4cd364460945e703d62d617ab4d0
Original Code:
```
public class BuyToGetFeaturesSpriteWithText extends Sprite {

	private AnimatedSprite animatedSpriteTowerLur;

	private AnimatedSprite animatedSpriteTowerSpear;

	private LFont font;

	private LFont fontHuge;

	private LFont fontMedium;

	private MainGame game;

	public BuyToGetFeaturesSpriteWithText(MainGame game) {
		super(game, "assets/buytogetfeatures.png", 0, new Vector2f(0f, 0f));
		this.game = game;
		this.animatedSpriteTowerSpear = AnimatedSpriteTower
				.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(109f,
						154f), TowerType.Spear, 0.4f);
		this.animatedSpriteTowerSpear.setDrawOrder(0x149);
		this.animatedSpriteTowerSpear.setAnimationSpeedRatio(3);
		this.animatedSpriteTowerSpear.setObeyGameOpacity(false);
		this.animatedSpriteTowerSpear.setOnlyAnimateIfGameStateStarted(false);
		this.animatedSpriteTowerLur = AnimatedSpriteTower
				.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(269f,
						132f), TowerType.Lur, 0.4f);
		this.animatedSpriteTowerLur.setDrawOrder(0x149);
		this.animatedSpriteTowerLur.setAnimationSpeedRatio(3);
		this.animatedSpriteTowerLur.setObeyGameOpacity(false);
		this.animatedSpriteTowerLur.setOnlyAnimateIfGameStateStarted(false);
		game.Components().add(this.animatedSpriteTowerSpear);
		game.Components().add(this.animatedSpriteTowerLur);
	}

	@Override
	public void draw(SpriteBatch batch, GameTime gameTime) {
		super.draw(batch, gameTime);
		Utils.DrawStringAlignCenter(batch, this.fontHuge,
				LanguageResources.getBuyGame(), 160f, 3f, LColor.white);
		Utils.DrawStringAlignCenter(batch, this.fontMedium,
				LanguageResources.getPleaseUnlock(), new Vector2f(160f, 74f),
				LColor.white);
		int num = 8;
		int num2 = 0xae;
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getMediumDifficulty(), num, 102f,
				LColor.white);
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getSpearTower(), num, 132f,
				LColor.white);
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getHardDifficulty(), num, 162f,
				LColor.white);
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getLurTower(), num2, 102f,
				LColor.white);
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getTwoExtraLevels(), num2, 132f,
				LColor.white);
		Utils.DrawStringAlignLeft(batch, this.font,
				"* " + LanguageResources.getSupportTheGame(), num2, 162f,
				LColor.white);
		Utils.DrawStringAlignCenter(batch, this.font, LanguageResources
				.getUnlockGame().toUpperCase(), 94f, 433f, LColor.white);
		Utils.DrawStringAlignCenter(batch, this.font,
				LanguageResources.getNotNow(), 242f, 433f, LColor.white);
	}

	public final void Exit() {
		if (this.animatedSpriteTowerSpear != null) {
			this.game.Components().remove(this.animatedSpriteTowerSpear);
		}
		if (this.animatedSpriteTowerLur != null) {
			this.game.Components().remove(this.animatedSpriteTowerLur);
		}
		this.game.Components().remove(this);
	}

	@Override
	protected void loadContent() {
		this.fontHuge = LFont.getFont(32);
		this.fontMedium = LFont.getFont(16);
		this.font = LFont.getFont(12);
		super.loadContent();
	}
}
```


Overlapping Code:
```
ss BuyToGetFeaturesSpriteWithText extends Sprite {
private AnimatedSprite animatedSpriteTowerLur;
private AnimatedSprite animatedSpriteTowerSpear;
private LFont font;
private LFont fontHuge;
private LFont fontMedium;
private MainGame game;
public BuyToGetFeaturesSpriteWithText(MainGame game) {
super(game, "assets/buytogetfeatures.png", 0, new Vector2f(0f, 0f));
this.game = game;
this.animatedSpriteTowerSpear = AnimatedSpriteTower
.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(109f,
154f), TowerType.Spear, 0.4f);
this.animatedSpriteTowerSpear.setDrawOrder(0x149);
this.animatedSpriteTowerSpear.setAnimationSpeedRatio(3);
this.animatedSpriteTowerSpear.setObeyGameOpacity(false);
this.animatedSpriteTowerSpear.setOnlyAnimateIfGameStateStarted(false);
this.animatedSpriteTowerLur = AnimatedSpriteTower
.GetAnimatedSpriteTowerForTowerToolbar(game, new Vector2f(269f,
132f), TowerType.Lur, 0.4f);
this.animatedSpriteTowerLur.setDrawOrder(0x149);
this.animatedSpriteTowerLur.setAnimationSpeedRatio(3);
this.animatedSpriteTowerLur.setObeyGameOpacity(false);
this.animatedSpriteTowerLur.setOnlyAnimateIfGameStateStarted(false);
game.Components().add(this.animatedSpriteTowerSpear);
game.Components().add(this.animatedSpriteTowerLur);
}
@Override
public void draw(SpriteBatch batch, GameTime gameTime) {
super.draw(batch, gameTime);
Utils.DrawStringAlignCenter(batch, this.fontHuge,
LanguageResources.getBuyGame(), 160f, 3f, LColor.white);
Utils.DrawStringAlignCenter(batch, this.fontMedium,
LanguageResources.getPleaseUnlock(), new Vector2f(160f, 74f),
LColor.white);
int num = 8;
int num2 = 0xae;
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getMediumDifficulty(), num, 102f,
LColor.white);
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getSpearTower(), num, 132f,
LColor.white);
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getHardDifficulty(), num, 162f,
LColor.white);
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getLurTower(), num2, 102f,
LColor.white);
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getTwoExtraLevels(), num2, 132f,
LColor.white);
Utils.DrawStringAlignLeft(batch, this.font,
"* " + LanguageResources.getSupportTheGame(), num2, 162f,
LColor.white);
Utils.DrawStringAlignCenter(batch, this
```
<Overlap Ratio: 0.9944657300979141>

---

--- 107 --
Question ID: 6c1a8a96cd60552269c9915646d5e27ec8cff213
Original Code:
```
public class TestOptions {

  public static final String TEST_PROPERTIES_RESOURCE = "/org/tmatesoft/svn/test/test.properties";
  public static final String TEST_PROPERTIES_TEMPLATE_RESOURCE = "/org/tmatesoft/svn/test/test.properties.template";

  public static TestOptions instance;

  public static TestOptions loadFrom(Properties properties) {
    final SVNURL repositoryUrl = getRepositoryUrl(properties);
    final File tempDirectory = getTempDirectory(properties);
    final String sqlite3Command = getSqlite3Command(properties);
    final long largeUpdateStep = getLargeUpdateStep(properties);
    final String svnCommand = getSvnCommand(properties);
    final List<SVNRevisionRange> updateSchedule = getUpdateSchedule(properties);
    final String apacheCtlCommand = getApacheCtlCommand(properties);
    final File apacheRoot = getApacheRoot(properties);
    final String htpasswdCommand = getHtpasswdCommand(properties);
    final String svnserveCommand = getSvnserveCommand(properties);
    return new TestOptions(repositoryUrl, tempDirectory, sqlite3Command, largeUpdateStep, svnCommand, updateSchedule, apacheCtlCommand, apacheRoot, htpasswdCommand, svnserveCommand);
  }

  private final SVNURL repositoryUrl;

  private final File tempDirectory;

  private final String sqlite3Command;

  private final long largeUpdateStep;

  private final String svnCommand;

  private final List<SVNRevisionRange> updateSchedule;

  private final String apacheCtlCommand;
  private final File apacheRoot;
  private final String htpasswdCommand;
  private final String svnserveCommand;

  public TestOptions(SVNURL repositoryUrl, File tempDirectory, String sqlite3Command, long largeUpdateStep, String svnCommand, List<SVNRevisionRange> updateSchedule, String apacheCtlCommand, File apacheRoot, String htpasswdCommand, String svnserveCommand) {
    this.repositoryUrl = repositoryUrl;
    this.tempDirectory = tempDirectory;
    this.sqlite3Command = sqlite3Command;
    this.largeUpdateStep = largeUpdateStep;
    this.svnCommand = svnCommand;
    this.updateSchedule = updateSchedule;
    this.apacheCtlCommand = apacheCtlCommand;
    this.apacheRoot = apacheRoot;
    this.htpasswdCommand = htpasswdCommand;
    this.svnserveCommand = svnserveCommand;
  }

  public SVNURL getRepositoryUrl() {
    return repositoryUrl;
  }

  public File getTempDirectory() {
    return tempDirectory;
  }

  public String getSqlite3Command() {
    return sqlite3Command;
  }

  public long getLargeUpdateStep() {
    return largeUpdateStep;
  }

  public String getSvnCommand() {
    return svnCommand;
  }

  public List<SVNRevisionRange> getUpdateSchedule() {
    return updateSchedule;
  }

  public String getApacheCtlCommand() {
    return apacheCtlCommand;
  }

  public File getApacheRoot() {
    return apacheRoot;
  }

  public String getHtpasswdCommand() {
    return htpasswdCommand;
  }

  public String getSvnserveCommand() {
    return svnserveCommand;
  }

  public static TestOptions getInstance() {
    if (instance == null) {
      Properties properties;

      properties = loadPropertiesFromResource(TEST_PROPERTIES_RESOURCE);
      if (properties != null) {
        instance = TestOptions.loadFrom(properties);
        return instance;
      }
      properties = loadPropertiesFromResource(TEST_PROPERTIES_TEMPLATE_RESOURCE);
      if (properties != null) {
        instance = TestOptions.loadFrom(properties);
        return instance;
      }

      throw new RuntimeException("Unable to load properties resources: " + TEST_PROPERTIES_RESOURCE + " and " + TEST_PROPERTIES_TEMPLATE_RESOURCE);
    }
    return instance;
  }

  private static Properties loadPropertiesFromResource(String resourceName) {
    final InputStream inputStream = TestOptions.class.getResourceAsStream(resourceName);
    if (inputStream == null) {
      return null;
    }
    final Properties properties = new Properties();
    try {
      properties.load(inputStream);
      return properties;
    } catch (IOException e) {
      return null;
    } finally {
      SVNFileUtil.closeFile(inputStream);
    }
  }

  private static SVNURL getRepositoryUrl(Properties properties) {
    try {
      return SVNURL.parseURIEncoded(properties.getProperty("repository.url"));
    } catch (SVNException e) {
      return null;
    }
  }

  private static File getTempDirectory(Properties properties) {
    final String tempDirectoryPath = properties.getProperty("temp.dir");
    return tempDirectoryPath == null ? new File(".tests") : new File(tempDirectoryPath);
  }

  private static String getSqlite3Command(Properties properties) {
    final String sqlite3Command = properties.getProperty("sqlite3.command");
    return sqlite3Command == null ? "sqlite3" : sqlite3Command;
  }

  private static long getLargeUpdateStep(Properties properties) {
    return getLongProperty(properties, "large.update.step", 10);
  }

  private static String getSvnCommand(Properties properties) {
    return properties.getProperty("svn.command", "svn");
  }

  private static long getLongProperty(Properties properties, String propertyName, long defaultValue) {
    final String valueString = properties.getProperty(propertyName);
    if (valueString == null) {
      return defaultValue;
    }

    try {
      return Long.parseLong(valueString);
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }

  private static List<SVNRevisionRange> getUpdateSchedule(Properties properties) {
    final String updateScheduleString = properties.getProperty("update.schedule");
    if (updateScheduleString == null) {
      return null;
    }

    final String[] rangeStrings = updateScheduleString.split(",");

    final List<SVNRevisionRange> ranges = new ArrayList<SVNRevisionRange>();
    for (String rangeString : rangeStrings) {
      final int dashIndex = rangeString.indexOf('-');
      if (dashIndex >= 0) {
        final String startRevisionString = rangeString.substring(0, dashIndex);
        final String endRevisionString = rangeString.substring(dashIndex + 1);
        ranges.add(new SVNRevisionRange(SVNRevision.parse(startRevisionString), SVNRevision.parse(endRevisionString)));
      } else {
        final SVNRevision revision = SVNRevision.parse(rangeString);
        ranges.add(new SVNRevisionRange(revision, revision));
      }
    }
    return ranges;
  }

  private static String getApacheCtlCommand(Properties properties) {
    return properties.getProperty("apachectl.command");
  }

  private static File getApacheRoot(Properties properties) {
    final String apacheRootPath = properties.getProperty("apache.root");
    if (apacheRootPath == null) {
      return null;
    }
    return new File(apacheRootPath);
  }

  private static String getHtpasswdCommand(Properties properties) {
    return properties.getProperty("htpasswd.command");
  }

  private static String getSvnserveCommand(Properties properties) {
    return properties.getProperty("svnserve.command");
  }
}
```


Overlapping Code:
```
tatic final String TEST_PROPERTIES_RESOURCE = "/org/tmatesoft/svn/test/test.properties";
public static final String TEST_PROPERTIES_TEMPLATE_RESOURCE = "/org/tmatesoft/svn/test/test.properties.template";
public static TestOptions instance;
public static TestOptions loadFrom(Properties properties) {
final SVNURL repositoryUrl = getRepositoryUrl(properties);
final File tempDirectory = getTempDirectory(properties);
final String sqlite3Command = getSqlite3Command(properties);
final long largeUpdateStep = getLargeUpdateStep(properties);
final String svnCommand = getSvnCommand(properties);
final List<SVNRevisionRange> updateSchedule = getUpdateSchedule(properties);
final String apacheCtlCommand = getApacheCtlCommand(properties);
final File apacheRoot = getApacheRoot(properties);
final String htpasswdCommand = getHtpasswdCommand(properties);
final String svnserveCommand = getSvnserveCommand(properties);
return new TestOptions(repositoryUrl, tempDirectory, sqlite3Command, largeUpdateStep, svnCommand, updateSchedule, apacheCtlCommand, apacheRoot, htpasswdCommand, svnserveCommand);
}
private final SVNURL repositoryUrl;
private final File tempDirectory;
private final String sqlite3Command;
private final long largeUpdateStep;
private final String svnCommand;
private final List<SVNRevisionRange> updateSchedule;
private final String apacheCtlCommand;
private final File apacheRoot;
private final String htpasswdCommand;
private final String svnserveCommand;
public TestOptions(SVNURL repositoryUrl, File tempDirectory, String sqlite3Command, long largeUpdateStep, String svnCommand, List<SVNRevisionRange> updateSchedule, String apacheCtlCommand, File apacheRoot, String htpasswdCommand, String svnserveCommand) {
this.repositoryUrl = repositoryUrl;
this.tempDirectory = tempDirectory;
this.sqlite3Command = sqlite3Command;
this.largeUpdateStep = largeUpdateStep;
this.svnCommand = svnCommand;
this.updateSchedule = updateSchedule;
this.apacheCtlCommand = apacheCtlCommand;
this.apacheRoot = apacheRoot;
this.htpasswdCommand = htpasswdCommand;
this.svnserveCommand = svnserveCommand;
}
public SVNURL getRepositoryUrl() {
return repositoryUrl;
}
public File getTempDirectory() {
return tempDirectory;
}
public String getSqlite3Command() {
return sqlite3Command;
}
public long getLargeUpdateSte
```
<Overlap Ratio: 0.9829059829059829>

---

--- 108 --
Question ID: 6fe74af6c99647a56667d387a66aa6551b413ffd
Original Code:
```
public class SpecialFood extends ItemFood
{
    protected int[] hunger;
    protected float[] saturation;
    protected String[] unlocalizedNames;
    protected String[] iconNames;
    protected IIcon[] icons;

    public SpecialFood(int[] hunger, float[] saturation, String[] textureNames, String[] iconNames)
    {
        super(0, 0, false);
        this.hunger = hunger;
        this.saturation = saturation;
        this.unlocalizedNames = textureNames;
        this.iconNames = iconNames;
    }

    @Override
    public ItemStack onEaten (ItemStack stack, World world, EntityPlayer player)
    {
        stack.stackSize--;
        int damage = stack.getItemDamage();
        player.getFoodStats().addStats(hunger[damage], saturation[damage]);
        world.playSoundAtEntity(player, "random.burp", 0.5F, world.rand.nextFloat() * 0.1F + 0.9F);
        this.onFoodEaten(stack, world, player);
        return stack;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public IIcon getIconFromDamage (int meta)
    {
        return icons[0];
    }

    @SideOnly(Side.CLIENT)
    @Override
    public void registerIcons (IIconRegister iconRegister)
    {
        this.icons = new IIcon[iconNames.length];

        for (int i = 0; i < this.icons.length; ++i)
        {
            this.icons[i] = iconRegister.registerIcon("tinker:" + iconNames[i]);
        }
    }

    @Override
    public String getUnlocalizedName (ItemStack stack)
    {
        int arr = MathHelper.clamp_int(stack.getItemDamage(), 0, unlocalizedNames.length);
        return getUnlocalizedName() + "." + unlocalizedNames[arr];
    }

    @Override
    public void getSubItems (Item b, CreativeTabs tab, List list)
    {
        for (int i = 0; i < unlocalizedNames.length; i++)
            list.add(new ItemStack(b, 1, i));
    }
}
```


Overlapping Code:
```
ublic class SpecialFood extends ItemFood
{
protected int[] hunger;
protected float[] saturation;
protected String[] unlocalizedNames;
protected String[] iconNames;
protected IIcon[] icons;
public SpecialFood(int[] hunger, float[] saturation, String[] textureNames, String[] iconNames)
{
super(0, 0, false);
this.hunger = hunger;
this.saturation = saturation;
this.unlocalizedNames = textureNames;
this.iconNames = iconNames;
}
@Override
public ItemStack onEaten (ItemStack stack, World world, EntityPlayer player)
{
stack.stackSize--;
int damage = stack.getItemDamage();
player.getFoodStats().addStats(hunger[damage], saturation[damage]);
world.playSoundAtEntity(player, "random.burp", 0.5F, world.rand.nextFloat() * 0.1F + 0.9F);
this.onFoodEaten(stack, world, player);
return stack;
}
@Override
@SideOnly(Side.CLIENT)
public IIcon getIconFromDamage (int meta)
{
return icons[0];
}
@SideOnly(Side.CLIENT)
@Override
public void registerIcons (IIconRegister iconRegister)
{
this.icons = new IIcon[iconNames.length];
for (int i = 0; i < this.icons.length; ++i)
{
this.icons[i] = iconRegister.registerIcon("tinker:" + iconNames[i]);
}
}
@Override
public String getUnlocalizedName (ItemStack stack)
{
int arr = MathHelper.clamp_int(stack.getItemDamage(), 0, unlocalizedNames.length);
return getUnlocalizedName() + "." + unlocalizedNames[arr];
}
@Override
public void getSubItems (Item b, CreativeTabs tab, List list)
{
for (int i = 0; i < unlocalizedNames.length; i++)
list.add(new ItemStack(b, 1, i));
}

```
<Overlap Ratio: 0.9986693280106453>

---

--- 109 --
Question ID: f612fd0e016f984b7cffce7955ab9d447adef8c9
Original Code:
```
public class ImapCrawlerParser extends CrawlerParser
{

    private static final long serialVersionUID = 6062546853256504993L;



    static public Store connect2Server(URLName url, ParseContext context) throws MessagingException
    {

        ImapCrawlerContext imapCrawlerContext = context.get(ImapCrawlerContext.class, new ImapCrawlerContext());

        Properties properties = System.getProperties();

        properties.setProperty("mail.store.protocol", url.getProtocol());

        if(imapCrawlerContext.getIgnoreSSLCertificates())
        {
            properties.setProperty("mail.imaps.socketFactory.class", CertificateIgnoringSocketFactory.class.getName());
            properties.setProperty("mail.imaps.socketFactory.fallback", "false");
        }

        if(!StringUtils.nullOrWhitespace(imapCrawlerContext.getSSLCertificateFilePath()) && "imaps".equalsIgnoreCase(url.getProtocol()))
        {
            properties.setProperty("javax.net.ssl.trustStore", imapCrawlerContext.getSSLCertificateFilePath());
            properties.setProperty("javax.net.ssl.trustStorePassword", imapCrawlerContext.getSSLCertificateFilePassword());
        }


        Session session = Session.getDefaultInstance(properties);
        Store mailStore = session.getStore(url.getProtocol());


        String strUserName = imapCrawlerContext.getUserName();
        if(strUserName == null) strUserName = url.getUsername();

        String strPassword = imapCrawlerContext.getPassword();
        if(strPassword == null) strPassword = url.getPassword();

        if(!mailStore.isConnected()) mailStore.connect(url.getHost(), url.getPort(), strUserName, strPassword);


        return mailStore;
    }



    /**
     * Does this folder hold any subfolders?
     * 
     * @param folder the folder to be checked
     * @return true if this folder has any subfolders, false otherwise
     * @throws MessagingException if it prooves impossible to find out
     */
    public static boolean holdsFolders(Folder folder) throws MessagingException
    {
        // this if has been added during the work on issue 2005759
        // gmail returns wrong type, it is necessary to call list() to determine
        // if a folder actually contains subfolders
        if((folder.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS)
        {
            return folder.list().length > 0;
        }
        else
        {
            // this means that the folder can't have any subfolders "by definition"
            return false;
        }
    }




    /**
     * Does this folder hold any messages?
     * 
     * @param folder the folder to be checked
     * @return true if this folder has any messages, false otherwise
     * @throws MessagingException if it prooves impossible to find out
     */
    public static boolean holdsMessages(Folder folder) throws MessagingException
    {
        return (folder.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;
    }



    protected HashMap<Folder, Boolean> m_hsImapFolder2Stickyness = new HashMap<Folder, Boolean>();


    protected Leech m_leech;



    protected Store m_mailStore;



    protected boolean checkIfInConstraints(String strURL2Check, MimeMessage message, ParseContext context) throws MessagingException
    {
        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());


        if(!crawlerContext.getURLFilter().accept(strURL2Check))
        {
            String strType = "IMAP directory ";
            if(message != null) strType = "IMAP message ";

            if(crawlerContext.getVerbose())
                LoggerFactory.getLogger(CrawlerParser.class.getName()).info(
                        strType + strURL2Check + " is outside the URL constraints for this data source. Skipping.");

            return false;
        }



        return true;
    }



    protected URLName getMessageUrl(Folder folderOfmessage, MimeMessage message) throws MessagingException
    {
        String strUrlName4Folder = folderOfmessage.getURLName().toString();
        if(!strUrlName4Folder.endsWith("/")) strUrlName4Folder += "/";

        // hier ist es bums, ob die id sticky ist oder nicht. Die URL ist der Pointer auf diese, momentane message, mit dem ich die erreichen und
        // downloaden kann. Fur das inkrementelle indexieren ist dann die dataExistsId relevant, die darf dann NICHT diese Url sein, wenn diese nicht
        // sticky ist. in diesem Fall (oder vielleicht sogar immer, mal schauen) nehme ich irgendwelche Daten aus dem header (wie wärs mit
        // folder+messageid)


        return new URLName(strUrlName4Folder + ";UID=" + ((UIDFolder) folderOfmessage).getUID(message));

        // if(uidsAreSticky(folderOfmessage))
        // {
        //
        // }
        // else
        // {
        // if(useHeadersHash)
        // {
        // return strUrlName4Folder + MailUtil.getMessageIdWithHeadersHash(message);
        // }
        // else
        // {
        // return strUrlName4Folder + MailUtil.getMessageId((MimeMessage) message);
        // }
        // }
    }



    @Override
    protected Iterator<MultiValueHashMap<String, Object>> getSubDataEntitiesInformation(InputStream stream, ContentHandler handler,
            Metadata metadata, ParseContext context) throws Exception
    {

        // imap url schema: imap[s]://uname@hostname:port/folder;uidvalidity=385759045/;uid=20. Examples (incl. message-referenzierung)
        // http://xml.resource.org/public/rfc/html/rfc2192.html#anchor10
        // allerdings nimmt der Java ImapStore auch URLs mit Passwörtern an. Dann geht auch
        // imap[s]://uname:pwd@hostname:port/folder;uidvalidity=385759045/;uid=20


        CrawlerContext crawlerContext = context.get(CrawlerContext.class, new CrawlerContext());


        String strContainerURL = metadata.get(Metadata.SOURCE);

        URLName containerURLName = new URLName(strContainerURL);

        if(m_mailStore == null) m_mailStore = connect2Server(containerURLName, context);

        // wenn kein directory angegeben wird, dann crawlen wir einfach den default folder und die inbox
        LinkedList<Folder> llFolderz2Crawl = new LinkedList<Folder>();
        if(containerURLName.getFile() != null)
        {
            Folder folder = m_mailStore.getFolder(containerURLName.getFile());
            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);
             else
                 throw new FileNotFoundException("Can't find imap folder '" + folder.getFullName() + "'");
            
        }
        else
        {
            Folder folder = m_mailStore.getDefaultFolder();
            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);

            folder = m_mailStore.getFolder("INBOX");
            if(folder != null && folder.exists()) llFolderz2Crawl.add(folder);
        }



        LinkedList<MultiValueHashMap<String, Object>> llEntityInfo = new LinkedList<MultiValueHashMap<String, Object>>();


        for (Folder folder2crawl : llFolderz2Crawl)
        {
            // Jetzt haben wir die Containerobjekte - nun geben wir die Daten zu den SubEntities zurück


            // die subfolder
            boolean bFolderCanHaveSubFolders = (folder2crawl.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS;

            if(bFolderCanHaveSubFolders)
            {
                folder2crawl.open(Folder.READ_ONLY);


                Folder[] subFolders = folder2crawl.list();
                for (Folder subFolder : subFolders)
                {
                    URLName urlName = subFolder.getURLName();
                    URLName urlNameWithPassword =
                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),
                                    urlName.getUsername(), containerURLName.getPassword());

                    if(!checkIfInConstraints(urlName.toString(), null, context)) continue;


                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();

                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);
                    hsEntityInformation.add("urlNameWithPassword", urlNameWithPassword);
                    hsEntityInformation.add("folder", subFolder.getFullName());

                    llEntityInfo.add(hsEntityInformation);
                }
            }


            // die messages
            boolean bFolderCanHaveMessages = (folder2crawl.getType() & Folder.HOLDS_MESSAGES) == Folder.HOLDS_MESSAGES;

            if(bFolderCanHaveMessages)
            {
                if(!folder2crawl.isOpen()) folder2crawl.open(Folder.READ_ONLY);


                // wir holen uns alle nicht-deleted messages, und werfen noch die raus, die 'expunged' sind
                Message[] relevantMessagesOfFolder = folder2crawl.search(new FlagTerm(new Flags(Flags.Flag.DELETED), false));
                ArrayList<Message> nonDelNonExpungedMessages = new ArrayList<Message>();
                for (Message message : relevantMessagesOfFolder)
                    if(!message.isExpunged()) nonDelNonExpungedMessages.add(message);
                relevantMessagesOfFolder = nonDelNonExpungedMessages.toArray(new Message[0]);

                // die Daten die wir später benötigen holen wir uns effizient in einem Rutsch - deswegen benötigen wir auch keinen Thread mit dem
                // OneAfterOneIterator, um Speicher zu sparen (siehe DirectoryCrawlerParser). Das Array haben wir hier eh. Entweder oder.
                FetchProfile profile = new FetchProfile();
                profile.add(UIDFolder.FetchProfileItem.UID);
                profile.add("Message-ID");
                folder2crawl.fetch(relevantMessagesOfFolder, profile);


                for (int i = 0; i < relevantMessagesOfFolder.length && !crawlerContext.stopRequested(); i++)
                {
                    MimeMessage message = (MimeMessage) relevantMessagesOfFolder[i];

                    // hier brauchen wir noch eine URL mit und eine ohne Passwort
                    URLName urlName = getMessageUrl(folder2crawl, message);
                    URLName urlNameWithPassword =
                            new URLName(containerURLName.getProtocol(), urlName.getHost(), urlName.getPort(), urlName.getFile(),
                                    urlName.getUsername(), containerURLName.getPassword());


                    if(!checkIfInConstraints(urlName.toString(), message, context)) continue;


                    MultiValueHashMap<String, Object> hsEntityInformation = new MultiValueHashMap<String, Object>();

                    hsEntityInformation.add(CrawlerParser.SOURCEID, urlName);
                    hsEntityInformation.add("urlNameWithPassword", urlNameWithPassword);
                    hsEntityInformation.add("Message-ID", message.getHeader("Message-ID")[0]);
                    hsEntityInformation.add("folder", folder2crawl.getFullName());

                    llEntityInfo.add(hsEntityInformation);
                }
            }

            // wir haben die folder abgearbeitet, dann können wir diesen Speicher wieder frei geben
            m_hsImapFolder2Stickyness.clear();





            if(folder2crawl.isOpen()) folder2crawl.close(false);
        }



        return llEntityInfo.iterator();
    }



    @Override
    public Set<MediaType> getSupportedTypes(ParseContext context)
    {
        return Collections.singleton(DatasourceMediaTypes.IMAPFOLDER);
    }



    @Override
    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException,
            TikaException
    {
        super.parse(stream, handler, metadata, context);


        // Wenn ein completter crawl fertig ist, dann schliessen wir auch wieder unseren MailStore

        int iCurrentCrawlingDepth = 0;
        String strDepth = metadata.get(CrawlerParser.CURRENT_CRAWLING_DEPTH);
        if(strDepth != null) iCurrentCrawlingDepth = Integer.valueOf(strDepth);


        if(iCurrentCrawlingDepth != 0) return;

        try
        {

            m_mailStore.close();
            m_mailStore = null;

        }
        catch (MessagingException e)
        {
            String strSourceID = metadata.get(Metadata.SOURCE);

            ExceptionUtils.handleException(e, strSourceID, metadata, context.get(CrawlerContext.class, new CrawlerContext()), context,
                    iCurrentCrawlingDepth, handler);
        }
    }



    @Override
    protected void processCurrentDataEntity(InputStream stream, Metadata metadata, ContentHandler handler, ParseContext context) throws Exception
    {
        // NOP - wie don't process directories - we only process the files inside
    }



    @Override
    protected void processSubDataEntity(MultiValueHashMap<String, Object> subDataEntityInformation, Metadata metadata,
            ContentHandler handler2use4recursiveCall, ParseContext context) throws Exception
    {

        URLName urlNameWithPassword = (URLName) subDataEntityInformation.getFirst("urlNameWithPassword");

        String strMessageId = (String) subDataEntityInformation.getFirst("Message-ID");
        String strMessageFolder = (String) subDataEntityInformation.getFirst("folder");

        String strEntityId = ImapURLStreamProvider.getEntityId(strMessageFolder, strMessageId);

        // wir setzten die hier schon mal - die Daten haben wir in einem prefetching-Schritt schon effizient geladen. Wenn diese hier schon im
        // Metadata-Objekt stehen, werden sie von der addFirstMetadata nicht nochmal geladen
        metadata.set(Metadata.SOURCE, urlNameWithPassword.toString());
        metadata.set(IncrementalCrawlingHistory.dataEntityId, strEntityId);
        metadata.set(IncrementalCrawlingHistory.dataEntityContentFingerprint,
                ImapURLStreamProvider.getDataEntityContentFingerprint(strEntityId));
        URLName urlNameWithoutPassword =
                new URLName(urlNameWithPassword.getProtocol(), urlNameWithPassword.getHost(), urlNameWithPassword.getPort(),
                        urlNameWithPassword.getFile(), urlNameWithPassword.getUsername(), "");
        metadata.set(LeechMetadata.RESOURCE_NAME_KEY, urlNameWithoutPassword.toString());
        if(strMessageId == null)
            metadata.set("Content-Type", DatasourceMediaTypes.IMAPFOLDER.toString());
        else
            metadata.set("Content-Type", "message/rfc822");



        metadata =
                URLStreamProvider.getURLStreamProvider4Protocol(urlNameWithPassword.getProtocol()).addFirstMetadata(urlNameWithPassword, metadata,
                        context);
        InputStream stream = URLStreamProvider.getURLStreamProvider(urlNameWithPassword).getStream(urlNameWithPassword, metadata, context);

        try
        {

            if(m_leech == null) m_leech = new Leech();


            // hier nimmt der dann bei einer message hoffentlich den Tika RFC822Parser
            Parser parser = m_leech.getParser();

            parser.parse(stream, handler2use4recursiveCall, metadata, context);

        }
        finally
        {
            if(stream != null) stream.close();
        }

    }




}
```


Overlapping Code:
```
awlerParser extends CrawlerParser
{
private static final long serialVersionUID = 6062546853256504993L;
static public Store connect2Server(URLName url, ParseContext context) throws MessagingException
{
ImapCrawlerContext imapCrawlerContext = context.get(ImapCrawlerContext.class, new ImapCrawlerContext());
Properties properties = System.getProperties();
properties.setProperty("mail.store.protocol", url.getProtocol());
if(imapCrawlerContext.getIgnoreSSLCertificates())
{
properties.setProperty("mail.imaps.socketFactory.class", CertificateIgnoringSocketFactory.class.getName());
properties.setProperty("mail.imaps.socketFactory.fallback", "false");
}
if(!StringUtils.nullOrWhitespace(imapCrawlerContext.getSSLCertificateFilePath()) && "imaps".equalsIgnoreCase(url.getProtocol()))
{
properties.setProperty("javax.net.ssl.trustStore", imapCrawlerContext.getSSLCertificateFilePath());
properties.setProperty("javax.net.ssl.trustStorePassword", imapCrawlerContext.getSSLCertificateFilePassword());
}
Session session = Session.getDefaultInstance(properties);
Store mailStore = session.getStore(url.getProtocol());
String strUserName = imapCrawlerContext.getUserName();
if(strUserName == null) strUserName = url.getUsername();
String strPassword = imapCrawlerContext.getPassword();
if(strPassword == null) strPassword = url.getPassword();
if(!mailStore.isConnected()) mailStore.connect(url.getHost(), url.getPort(), strUserName, strPassword);
return mailStore;
}
/**
* Does this folder hold any subfolders?
* 
* @param folder the folder to be checked
* @return true if this folder has any subfolders, false otherwise
* @throws MessagingException if it prooves impossible to find out
*/
public static boolean holdsFolders(Folder folder) throws MessagingException
{
// this if has been added during the work on issue 2005759
// gmail returns wrong type, it is necessary to call list() to determine
// if a folder actually contains subfolders
if((folder.getType() & Folder.HOLDS_FOLDERS) == Folder.HOLDS_FOLDERS)
{
return folder.list().length > 0;
}
else
{
// this means that the folder can't have any subfolders "by defini
```
<Overlap Ratio: 0.9887798036465638>

---

--- 110 --
Question ID: 675d3239af4e007f4f522b60e4a9f5e3b70ba816
Original Code:
```
public class XslCompileUriResolver implements URIResolver {

  private CompilerContext _cc;
  private OXPath10Expression _expr;

  public XslCompileUriResolver(CompilerContext cc, OXPath10Expression expr) {
    _cc = cc;
    _expr = expr;
  }

  public Source resolve(String href, String base) throws TransformerException {
    OXslSheet xslSheet = _cc.compileXslt(href);
    _expr.setXslSheet(xslSheet.uri, xslSheet);
    return new StreamSource(new StringReader(xslSheet.sheetBody));
  }
}
```


Overlapping Code:
```
CompileUriResolver implements URIResolver {
private CompilerContext _cc;
private OXPath10Expression _expr;
public XslCompileUriResolver(CompilerContext cc, OXPath10Expression expr) {
_cc = cc;
_expr = expr;
}
public Source resolve(String href, String base) throws TransformerException {
OXslSheet xslSheet = _cc.compileXslt(href);
_expr.setXslSheet(xslSheet.uri, xslSheet);
return new StreamSource(ne
```
<Overlap Ratio: 0.8771929824561403>

---

--- 111 --
Question ID: 105268f0a720ff7f616d129d86e10494ec305a22
Original Code:
```
@Component("guiaDetalleMapper")
public class GuiaDetalleMapper implements Mapper<GuiaDetallesDTO, GuiaDetalles> {

    private Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper;

    @Override
    public GuiaDetalles convert(final GuiaDetallesDTO guiaDetallesDTO) {
        if (guiaDetallesDTO == null) {
            return null;
        }
        final GuiaDetalles detalle = new GuiaDetalles();
        detalle.setCodigoInterno(guiaDetallesDTO.getCodigoInterno());
        detalle.setCodigoAdicional(guiaDetallesDTO.getCodigoAdicional());
        detalle.setDescripcion(guiaDetallesDTO.getDescripcion());
        detalle.setCantidad(guiaDetallesDTO.getCantidad());
        detalle.setDetAdicional(getDetAdicionalMapper().convertAll(guiaDetallesDTO.getDetAdicional()));
        return detalle;
    }

    protected Mapper<DetAdicionalDTO, DetAdicional> getDetAdicionalMapper() {
        return detAdicionalMapper;
    }

    @Autowired
    @Qualifier("detAdicionalMapper")
    public void setDetAdicionalMapper(Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper) {
        this.detAdicionalMapper = detAdicionalMapper;
    }
    
}
```


Overlapping Code:
```
lass GuiaDetalleMapper implements Mapper<GuiaDetallesDTO, GuiaDetalles> {
private Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper;
@Override
public GuiaDetalles convert(final GuiaDetallesDTO guiaDetallesDTO) {
if (guiaDetallesDTO == null) {
return null;
}
final GuiaDetalles detalle = new GuiaDetalles();
detalle.setCodigoInterno(guiaDetallesDTO.getCodigoInterno());
detalle.setCodigoAdicional(guiaDetallesDTO.getCodigoAdicional());
detalle.setDescripcion(guiaDetallesDTO.getDescripcion());
detalle.setCantidad(guiaDetallesDTO.getCantidad());
detalle.setDetAdicional(getDetAdicionalMapper().convertAll(guiaDetallesDTO.getDetAdicional()));
return detalle;
}
protected Mapper<DetAdicionalDTO, DetAdicional> getDetAdicionalMapper() {
return detAdicionalMapper;
}
@Autowired
@Qualifier("detAdicionalMapper")
public void setDetAdicionalMapper(Mapper<DetAdicionalDTO, DetAdicional> detAdicionalMapper) {
this.detAdicionalMapper = detAdicionalMappe
```
<Overlap Ratio: 0.9528585757271816>

---

--- 112 --
Question ID: 5488ea67e067453a405e5896520d1af5d8a288be
Original Code:
```
public class AstralBlockLootTables extends BlockLootTables {

    @Override
    protected void addTables() {
        registerLootTable(REDBULB.get(), onlyWithSilkTouchOrShears(REDBULB.get()));
        registerLootTable(CYANGRASS.get(), onlyWithSilkTouchOrShears(CYANGRASS.get()));
        registerLootTable(GENTLEGRASS.get(), onlyWithSilkTouchOrShears(GENTLEGRASS.get()));
        registerLootTable(WILDWEED.get(), onlyWithSilkTouchOrShears(WILDWEED.get()));
        registerLootTable(TALL_REDBULB.get(), onlyWithSilkTouchOrShears(TALL_REDBULB.get()));
        registerLootTable(TALL_CYANGRASS.get(), onlyWithSilkTouchOrShears(TALL_CYANGRASS.get()));
        registerLootTable(TALL_GENTLEGRASS.get(), onlyWithSilkTouchOrShears(TALL_GENTLEGRASS.get()));
        registerLootTable(TALL_WILDWEED.get(), onlyWithSilkTouchOrShears(TALL_WILDWEED.get()));
        registerLootTable(BLUECAP_MUSHROOM.get(), dropping(BLUECAP_MUSHROOM.get()));
        registerLootTable(RUSTCAP_MUSHROOM.get(), dropping(RUSTCAP_MUSHROOM.get()));
        registerLootTable(ETHEREAL_PLANKS.get(), dropping(ETHEREAL_PLANKS.get()));
        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));
        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));
        registerLootTable(COMFORTABLE_CUSHION.get(), dropping(COMFORTABLE_CUSHION.get()));
        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));
        registerLootTable(CRYSTAL_WEB.get(), droppingWithSilkTouchOrShearsTag(CRYSTAL_WEB.get(), ItemLootEntry.builder(AstralItems.DREAMCORD.get())));
        this.registerLootTable(SNOWBERRY_BUSH.get(), new LootTable.Builder()
                .addLootPool(new LootPool.Builder()
                        .name("ripe")
                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())
                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 3)))
                        .acceptFunction(SetCount.builder(RandomValueRange.of(2, 3)))
                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))
                .addLootPool(new LootPool.Builder()
                        .name("unripe")
                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())
                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 2)))
                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))
                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))
                .addLootPool(new LootPool.Builder()
                        .name("not_grown")
                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())
                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 1)))
                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))
                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))
                .addLootPool(new LootPool.Builder()
                        .name("planted")
                        .addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
                        .acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())
                                .fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 0)))
                        .acceptFunction(SetCount.builder(RandomValueRange.of(1, 1)))
                        .acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))
                .acceptFunction(ExplosionDecay.builder())
        );
        registerLootTable(FEVERWEED_BLOCK.get(), dropping(FEVERWEED_BLOCK.get()));
        registerLootTable(OFFERING_BRAZIER.get(), dropping(OFFERING_BRAZIER.get()));
        registerLootTable(ETHER_DIRT.get(), dropping(ETHER_DIRT.get()));
        registerLootTable(ETHER_GRASS.get(), droppingWithSilkTouch(ETHER_GRASS.get(), ETHER_DIRT.get()));
        registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));
        registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));
        registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));
        registerLootTable(ETHEREAL_LOG.get(), dropping(ETHEREAL_LOG.get()));
        registerLootTable(ETHEREAL_LEAVES.get(), new LootTable.Builder()
                .addLootPool(new LootPool.Builder()
                        .rolls(ConstantRange.of(1))
                        .addEntry(AlternativesLootEntry.builder(ItemLootEntry.builder(ETHEREAL_LEAVES.get())
                                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS),
                                ItemLootEntry.builder(AstralItems.ETHEREAL_SAPLING_ITEM.get())
                                        .acceptCondition(SurvivesExplosion.builder())
                                        .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, .05f, .0625f, 0.083333336f, 0.1f)))))
                .addLootPool(new LootPool.Builder()
                        .rolls(ConstantRange.of(1))
                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_BONE.get())
                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))
                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))
                                .acceptFunction(ExplosionDecay.builder()))
                        .addEntry(ItemLootEntry.builder(AstralItems.METAPHORIC_FLESH.get())
                                .acceptCondition(TableBonus.builder(Enchantments.FORTUNE, 0.02f, 0.022222223f, 0.025f, 0.033333335f, 0.1f))
                                .acceptFunction(SetCount.builder(RandomValueRange.of(1, 2)))
                                .acceptFunction(ExplosionDecay.builder()))
                        .acceptCondition(Inverted.builder(Constants.SILK_TOUCH_OR_SHEARS))));
        registerLootTable(ETHERIC_POWDER.get(), dropping(ETHERIC_POWDER.get()));
        registerLootTable(STRIPPED_ETHEREAL_LOG.get(), dropping(STRIPPED_ETHEREAL_LOG.get()));
        registerLootTable(STRIPPED_ETHEREAL_WOOD.get(), dropping(STRIPPED_ETHEREAL_WOOD.get()));
        registerLootTable(ETHEREAL_WOOD.get(), dropping(ETHEREAL_WOOD.get()));
        registerLootTable(INDEX_OF_KNOWLEDGE.get(), dropping(INDEX_OF_KNOWLEDGE.get()));
        registerLootTable(METAPHORIC_STONE.get(), droppingWithSilkTouch(METAPHORIC_STONE.get(), METAPHORIC_BONE_BLOCK.get()));
        registerLootTable(METAPHORIC_BONE_BLOCK.get(), dropping(METAPHORIC_BONE_BLOCK.get()));
        registerLootTable(METAPHORIC_FLESH_BLOCK.get(), dropping(METAPHORIC_FLESH_BLOCK.get()));
        registerLootTable(ETHEREAL_SPAWNER.get(), blockNoDrop());
    }

    @Override
    @Nonnull
    protected Iterable<Block> getKnownBlocks() {
        return BLOCKS.getEntries().stream().map(RegistryObject::get).collect(Collectors.toList());
    }

    private LootTable.Builder onlyWithSilkTouchOrShears(Block block) {
        return LootTable.builder()
                .addLootPool(LootPool.builder()
                        .rolls(ConstantRange.of(1))
                        .acceptCondition(Constants.SILK_TOUCH_OR_SHEARS)
                        .addEntry(ItemLootEntry.builder(block)));
    }

    private LootTable.Builder droppingWithSilkTouchOrShearsTag(Block block, LootEntry.Builder<?> drops){
        return dropping(block, Constants.SILK_TOUCH_OR_SHEARS, drops);
    }
}
```


Overlapping Code:
```
s AstralBlockLootTables extends BlockLootTables {
@Override
protected void addTables() {
registerLootTable(REDBULB.get(), onlyWithSilkTouchOrShears(REDBULB.get()));
registerLootTable(CYANGRASS.get(), onlyWithSilkTouchOrShears(CYANGRASS.get()));
registerLootTable(GENTLEGRASS.get(), onlyWithSilkTouchOrShears(GENTLEGRASS.get()));
registerLootTable(WILDWEED.get(), onlyWithSilkTouchOrShears(WILDWEED.get()));
registerLootTable(TALL_REDBULB.get(), onlyWithSilkTouchOrShears(TALL_REDBULB.get()));
registerLootTable(TALL_CYANGRASS.get(), onlyWithSilkTouchOrShears(TALL_CYANGRASS.get()));
registerLootTable(TALL_GENTLEGRASS.get(), onlyWithSilkTouchOrShears(TALL_GENTLEGRASS.get()));
registerLootTable(TALL_WILDWEED.get(), onlyWithSilkTouchOrShears(TALL_WILDWEED.get()));
registerLootTable(BLUECAP_MUSHROOM.get(), dropping(BLUECAP_MUSHROOM.get()));
registerLootTable(RUSTCAP_MUSHROOM.get(), dropping(RUSTCAP_MUSHROOM.get()));
registerLootTable(ETHEREAL_PLANKS.get(), dropping(ETHEREAL_PLANKS.get()));
registerLootTable(ETHEREAL_TRAPDOOR.get(), dropping(ETHEREAL_TRAPDOOR.get()));
registerLootTable(ETHEREAL_DOOR.get(), dropping(ETHEREAL_DOOR.get()));
registerLootTable(COMFORTABLE_CUSHION.get(), dropping(COMFORTABLE_CUSHION.get()));
registerLootTable(ETHEREAL_SAPLING.get(), dropping(ETHEREAL_SAPLING.get()));
registerLootTable(CRYSTAL_WEB.get(), droppingWithSilkTouchOrShearsTag(CRYSTAL_WEB.get(), ItemLootEntry.builder(AstralItems.DREAMCORD.get())));
this.registerLootTable(SNOWBERRY_BUSH.get(), new LootTable.Builder()
.addLootPool(new LootPool.Builder()
.name("ripe")
.addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
.acceptCondition(BlockStateProperty.builder(SNOWBERRY_BUSH.get())
.fromProperties(StatePropertiesPredicate.Builder.newBuilder().withIntProp(SweetBerryBushBlock.AGE, 3)))
.acceptFunction(SetCount.builder(RandomValueRange.of(2, 3)))
.acceptFunction(ApplyBonus.uniformBonusCount(Enchantments.FORTUNE, 1)))
.addLootPool(new LootPool.Builder()
.name("unripe")
.addEntry(ItemLootEntry.builder(AstralItems.SNOWBERRY.get()))
.acceptCondition(BlockStateProperty
```
<Overlap Ratio: 0.9914204003813155>

---

--- 113 --
Question ID: 1f64c40df7f6f68c27f9cc59b2e40bba2f38aa12
Original Code:
```
@ObfuscatedName("it")
@Implements("VarbitDefinition")
public class VarbitDefinition extends DualNode {
	@ObfuscatedName("c")
	@ObfuscatedSignature(
		signature = "Lhz;"
	)
	@Export("VarbitDefinition_archive")
	public static AbstractArchive VarbitDefinition_archive;
	@ObfuscatedName("x")
	@ObfuscatedSignature(
		signature = "Let;"
	)
	@Export("VarbitDefinition_cached")
	public static EvictingDualNodeHashTable VarbitDefinition_cached;
	@ObfuscatedName("a")
	@Export("BZip2Decompressor_block")
	static int[] BZip2Decompressor_block;
	@ObfuscatedName("t")
	@ObfuscatedGetter(
		intValue = -1892165457
	)
	@Export("baseVar")
	public int baseVar;
	@ObfuscatedName("g")
	@ObfuscatedGetter(
		intValue = 810805195
	)
	@Export("startBit")
	public int startBit;
	@ObfuscatedName("l")
	@ObfuscatedGetter(
		intValue = 1776174069
	)
	@Export("endBit")
	public int endBit;

	static {
		VarbitDefinition_cached = new EvictingDualNodeHashTable(64);
	}

	VarbitDefinition() {
	}

	@ObfuscatedName("x")
	@ObfuscatedSignature(
		signature = "(Lkz;I)V",
		garbageValue = "-1056617467"
	)
	@Export("decode")
	void decode(Buffer var1) {
		while (true) {
			int var2 = var1.readUnsignedByte();
			if (var2 == 0) {
				return;
			}

			this.decodeNext(var1, var2);
		}
	}

	@ObfuscatedName("t")
	@ObfuscatedSignature(
		signature = "(Lkz;IB)V",
		garbageValue = "26"
	)
	@Export("decodeNext")
	void decodeNext(Buffer var1, int var2) {
		if (var2 == 1) {
			this.baseVar = var1.readUnsignedShort();
			this.startBit = var1.readUnsignedByte();
			this.endBit = var1.readUnsignedByte();
		}

	}

	@ObfuscatedName("g")
	@ObfuscatedSignature(
		signature = "(IIII)V",
		garbageValue = "944071832"
	)
	static final void method4499(int var0, int var1, int var2) {
		int var3;
		for (var3 = 0; var3 < 8; ++var3) {
			for (int var4 = 0; var4 < 8; ++var4) {
				Tiles.Tiles_heights[var0][var3 + var1][var4 + var2] = 0;
			}
		}

		if (var1 > 0) {
			for (var3 = 1; var3 < 8; ++var3) {
				Tiles.Tiles_heights[var0][var1][var3 + var2] = Tiles.Tiles_heights[var0][var1 - 1][var3 + var2];
			}
		}

		if (var2 > 0) {
			for (var3 = 1; var3 < 8; ++var3) {
				Tiles.Tiles_heights[var0][var3 + var1][var2] = Tiles.Tiles_heights[var0][var3 + var1][var2 - 1];
			}
		}

		if (var1 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2] != 0) {
			Tiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2];
		} else if (var2 > 0 && Tiles.Tiles_heights[var0][var1][var2 - 1] != 0) {
			Tiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1][var2 - 1];
		} else if (var1 > 0 && var2 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2 - 1] != 0) {
			Tiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2 - 1];
		}

	}
}
```


Overlapping Code:
```
)
@Implements("VarbitDefinition")
public class VarbitDefinition extends DualNode {
@ObfuscatedName("c")
@ObfuscatedSignature(
signature = "Lhz;"
)
@Export("VarbitDefinition_archive")
public static AbstractArchive VarbitDefinition_archive;
@ObfuscatedName("x")
@ObfuscatedSignature(
signature = "Let;"
)
@Export("VarbitDefinition_cached")
public static EvictingDualNodeHashTable VarbitDefinition_cached;
@ObfuscatedName("a")
@Export("BZip2Decompressor_block")
static int[] BZip2Decompressor_block;
@ObfuscatedName("t")
@ObfuscatedGetter(
intValue = -1892165457
)
@Export("baseVar")
public int baseVar;
@ObfuscatedName("g")
@ObfuscatedGetter(
intValue = 810805195
)
@Export("startBit")
public int startBit;
@ObfuscatedName("l")
@ObfuscatedGetter(
intValue = 1776174069
)
@Export("endBit")
public int endBit;
static {
VarbitDefinition_cached = new EvictingDualNodeHashTable(64);
}
VarbitDefinition() {
}
@ObfuscatedName("x")
@ObfuscatedSignature(
signature = "(Lkz;I)V",
garbageValue = "-1056617467"
)
@Export("decode")
void decode(Buffer var1) {
while (true) {
int var2 = var1.readUnsignedByte();
if (var2 == 0) {
return;
}
this.decodeNext(var1, var2);
}
}
@ObfuscatedName("t")
@ObfuscatedSignature(
signature = "(Lkz;IB)V",
garbageValue = "26"
)
@Export("decodeNext")
void decodeNext(Buffer var1, int var2) {
if (var2 == 1) {
this.baseVar = var1.readUnsignedShort();
this.startBit = var1.readUnsignedByte();
this.endBit = var1.readUnsignedByte();
}
}
@ObfuscatedName("g")
@ObfuscatedSignature(
signature = "(IIII)V",
garbageValue = "944071832"
)
static final void method4499(int var0, int var1, int var2) {
int var3;
for (var3 = 0; var3 < 8; ++var3) {
for (int var4 = 0; var4 < 8; ++var4) {
Tiles.Tiles_heights[var0][var3 + var1][var4 + var2] = 0;
}
}
if (var1 > 0) {
for (var3 = 1; var3 < 8; ++var3) {
Tiles.Tiles_heights[var0][var1][var3 + var2] = Tiles.Tiles_heights[var0][var1 - 1][var3 + var2];
}
}
if (var2 > 0) {
for (var3 = 1; var3 < 8; ++var3) {
Tiles.Tiles_heights[var0][var3 + var1][var2] = Tiles.Tiles_heights[var0][var3 + var1][var2 - 1];
}
}
if (var1 > 0 && Tiles.Tiles_heights[var0][var1 - 1][var2] != 0) {
Tiles.Tiles_heights[var0][var1][var2] = Tiles.Tiles_heights[var0][var1 - 1][var2];
} else if (var2 > 0 && Tiles.Tiles_heights[var0][var1][var2 - 1] != 0) {
Tiles.Tiles_heights[var0][var1][v
```
<Overlap Ratio: 0.9914163090128756>

---

--- 114 --
Question ID: ab72d37a9ad701829fb4cd320b7b4132c6d2695f
Original Code:
```
public class GreatestCommonDivisor4
{
	public static void main(String[] args)
	{
		Scanner scannerObject = new Scanner(System.in);
		System.out.printf("Enter the first number. ");
		int firstNumber = scannerObject.nextInt();

		System.out.printf("Enter the second number. ");
		int secondNumber = scannerObject.nextInt();

		int divisor, dividend, remainder = -1;
		int gcd = 1;
		if(firstNumber >= 1 && secondNumber >= 1)
		{
			if(firstNumber == secondNumber)
			{
				gcd = firstNumber;
			}
			else
				for(int k = (firstNumber > secondNumber ? firstNumber / 2 : secondNumber / 2); k >= 2; k--)
				{
					if(firstNumber % k == 0 && secondNumber % k == 0)
					{
						gcd = k;
						break;
					}
				}

			System.out.printf("GCD(%d, %d): %d\n", firstNumber, secondNumber, gcd);
		}
		else
		{
			System.out.printf("Invalid input. Both numbers have to be natural numbers. The program will now exit.\n");
		}
	}
}
```


Overlapping Code:
```
monDivisor4
{
public static void main(String[] args)
{
Scanner scannerObject = new Scanner(System.in);
System.out.printf("Enter the first number. ");
int firstNumber = scannerObject.nextInt();
System.out.printf("Enter the second number. ");
int secondNumber = scannerObject.nextInt();
int divisor, dividend, remainder = -1;
int gcd = 1;
if(firstNumber >= 1 && secondNumber >= 1)
{
if(firstNumber == secondNumber)
{
gcd = firstNumber;
}
else
for(int k = (firstNumber > secondNumber ? firstNumber / 2 : secondNumber / 2); k >= 2; k--)
{
if(firstNumber % k == 0 && secondNumber % k == 0)
{
gcd = k;
break;
}
}
System.out.printf("GCD(%d, %d): %d\n", firstNumber, secondNumber, gcd);
}
else
{
System.out.printf("Invalid input. Both numbers have to be natural numbers. The program will now exit.\n");
}
}
}
```
<Overlap Ratio: 0.970873786407767>

---

--- 115 --
Question ID: 29955dc0f072a31c3c8d1dbf8d6fa21ddfd709dc
Original Code:
```
public class NumberFrequency {

    private Map<Integer, TreeMap<Integer, Integer>> save = new HashMap<>();

    public NumberFrequency(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            TreeMap<Integer, Integer> indexMap = save.computeIfAbsent(arr[i], k -> new TreeMap<>());
            Integer index = indexMap.floorKey(i);
            if (index == null){
                indexMap.put(i, 1);
            } else {
                indexMap.put(i, indexMap.get(index) + 1);
            }
        }
    }

    public int query(int left, int right, int value) {
        TreeMap<Integer, Integer> query = save.get(value);
        if (query == null){
            return 0;
        }
        Integer min = query.floorKey(left);
        if (min == null){
            Integer max = query.floorKey(right);
            if (max == null){
                return 0;
            }
            return query.get(max);
        }
        int minCount = query.get(min);
        minCount = min == left ? minCount - 1 : minCount;
        Integer max = query.floorKey(right);
        return query.get(max) - minCount;
    }


    public static void main(String[] args) {
        NumberFrequency test = new NumberFrequency(new int[]{12,33,4,56,22,2,34,33,22,12,34,56});
        System.out.println(test.query(0, 11, 33));
    }
}
```


Overlapping Code:
```
ivate Map<Integer, TreeMap<Integer, Integer>> save = new HashMap<>();
public NumberFrequency(int[] arr) {
for (int i = 0; i < arr.length; i++) {
TreeMap<Integer, Integer> indexMap = save.computeIfAbsent(arr[i], k -> new TreeMap<>());
Integer index = indexMap.floorKey(i);
if (index == null){
indexMap.put(i, 1);
} else {
indexMap.put(i, indexMap.get(index) + 1);
}
}
}
public int query(int left, int right, int value) {
TreeMap<Integer, Integer> query = save.get(value);
if (query == null){
return 0;
}
Integer min = query.floorKey(left);
if (min == null){
Integer max = query.floorKey(right);
if (max == null){
return 0;
}
return query.get(max);
}
int minCount = query.get(min);
minCount = min == left ? minCount - 1 : minCount;
Integer max = query.floorKey(right);
return query.get(max) - minCount;
}
public static void main(String[] args) {
NumberFrequency test = new NumberFrequency(new int[]{12,33,4,56,22,2,34,33,22,12,34,56});
System.out.print
```
<Overlap Ratio: 0.9378084896347483>

---

--- 116 --
Question ID: 696952ebc551cce7a2e411bcc24e01c722c3084a
Original Code:
```
@Named
@ViewScoped
public class SettingsBean implements Serializable {

	private static final long serialVersionUID = 1L;

	private Session session;
    
    private List<Setting> settings;
    private Map<Long, String> settingValues;

    @PostConstruct
    public void init() {
        session = HibernateUtil.getSessionFactory().openSession();
        settings = session.createQuery("select o from Setting o", Setting.class).getResultList();
        settingValues = new HashMap<>();
        for (Setting setting : settings) {
            settingValues.put(setting.getId(), setting.getValue());
        }
    }

    public void update() {

        session.getTransaction().begin();
        for (Map.Entry<Long, String> settingValue : settingValues.entrySet()) {
            Setting setting = session.get(Setting.class, settingValue.getKey());
            if (settingValue.getValue() != null && settingValue.getValue().trim().length() > 0) setting.setValue(settingValue.getValue());
            session.update(setting);
        }
        session.getTransaction().commit();
        
    }
    
    /**
     * @return the users
     */
    public List<Setting> getSettings() {
        return settings;
    }

    /**
     * @param settings the users to set
     */
    public void setUsers(List<Setting> settings) {
        this.settings = settings;
    }

    /**
     * @return the settingValues
     */
    public Map<Long, String> getSettingValues() {
        return settingValues;
    }

    /**
     * @param settingValues the settingValues to set
     */
    public void setSettingValues(Map<Long, String> settingValues) {
        this.settingValues = settingValues;
    }
}
```


Overlapping Code:
```
oped
public class SettingsBean implements Serializable {
private static final long serialVersionUID = 1L;
private Session session;

private List<Setting> settings;
private Map<Long, String> settingValues;
@PostConstruct
public void init() {
session = HibernateUtil.getSessionFactory().openSession();
settings = session.createQuery("select o from Setting o", Setting.class).getResultList();
settingValues = new HashMap<>();
for (Setting setting : settings) {
settingValues.put(setting.getId(), setting.getValue());
}
}
public void update() {
session.getTransaction().begin();
for (Map.Entry<Long, String> settingValue : settingValues.entrySet()) {
Setting setting = session.get(Setting.class, settingValue.getKey());
if (settingValue.getValue() != null && settingValue.getValue().trim().length() > 0) setting.setValue(settingValue.getValue());
session.update(setting);
}
session.getTransaction().commit();

}

/**
* @return the users
*/
public List<Setting> getSettings() {
return settings;
}
/**
* @param settings the users to set
*/
public void setUsers(List<Setting> settings) {
this.settings = settings;
}
/**
* @return the settingValues
*/
public Map<Long, String> getSettingValues() {
return settingValues;
}
/**
* @param settingValues the settingValues to set
*/
public void setSettingValues(Map<Long, String> settingValues) {
this.settingValues = settingValues
```
<Overlap Ratio: 0.9862914862914863>

---

--- 117 --
Question ID: 6d292050425fb000cbdaa7dd96734a7c4f9d92d4
Original Code:
```
public class MethodOverloadingTestCase extends BaseTestCase implements LogChute
{
    String logData;
    
    /**
    * VTL file extension.
    */
   private static final String TMPL_FILE_EXT = "vm";

   /**
    * Comparison file extension.
    */
   private static final String CMP_FILE_EXT = "cmp";

   /**
    * Comparison file extension.
    */
   private static final String RESULT_FILE_EXT = "res";

   /**
    * Path for templates. This property will override the
    * value in the default velocity properties file.
    */
   private final static String FILE_RESOURCE_LOADER_PATH = TEST_COMPARE_DIR + "/methodoverloading";

   /**
    * Results relative to the build directory.
    */
   private static final String RESULTS_DIR = TEST_RESULT_DIR + "/methodoverloading";

   /**
    * Results relative to the build directory.
    */
   private static final String COMPARE_DIR = TEST_COMPARE_DIR + "/methodoverloading/compare";

    /**
     * Default constructor.
     */
    public MethodOverloadingTestCase(String name)
    {
        super(name);
    }

    public void setUp()
    {
        assureResultsDirectoryExists(RESULTS_DIR);
    }

    public static Test suite()
    {
       return new TestSuite(MethodOverloadingTestCase.class);
    }

    public void testMethodOverloading()
    throws Exception
    {
        /**
         * test overloading in a single template
         */
        testFile("single");

        assertTrue(logData.indexOf("IllegalArgumentException") == -1);
    }

    public void testParsedMethodOverloading()
    throws Exception
    {
        /**
         * test overloading in a file included with #parse
         */
        testFile("main");
        
        assertTrue(logData.indexOf("IllegalArgumentException") == -1);
        
    }
    
    public void testFile(String basefilename)
    throws Exception
    {
        
        VelocityEngine ve = new VelocityEngine();
        ve.addProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
        ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );
        ve.init();
        
        Template template;
        FileOutputStream fos;
        Writer fwriter;
        Context context;
        
        template = ve.getTemplate( getFileName(null, basefilename, TMPL_FILE_EXT) );
        
        fos = new FileOutputStream (
                getFileName(RESULTS_DIR, basefilename, RESULT_FILE_EXT));
        
        fwriter = new BufferedWriter( new OutputStreamWriter(fos) );
        
        context = new VelocityContext();
        setupContext(context);
        template.merge(context, fwriter);
        fwriter.flush();
        fwriter.close();
        
        if (!isMatch(RESULTS_DIR, COMPARE_DIR, basefilename, RESULT_FILE_EXT, CMP_FILE_EXT))
        {
            fail("Output incorrect.");
        }
    }
        
    public void setupContext(Context context)
    {
      context.put("test", this);
      context.put("nullValue", null);  
    } 
    
    
    public String overloadedMethod ( Integer s )
    {
        return "Integer";
    }
    
    public String overloadedMethod ( String s )
    {
        return "String";
    }
    
    
    public String overloadedMethod2 ( Integer s )
    {
        return "Integer";
    }
    
    public String overloadedMethod2 ( String i )
    {
        return "String";
    }


    public void log(int level, String message)
    {
        String out = "";

        /*
         * Start with the appropriate prefix
         */
        switch( level )
        {
            case DEBUG_ID :
                out = DEBUG_PREFIX;
                break;
            case INFO_ID :
                out = INFO_PREFIX;
                break;
            case TRACE_ID :
                out = TRACE_PREFIX;
                break;
            case WARN_ID :
                out = WARN_PREFIX;
                break;
            case ERROR_ID :
                out = ERROR_PREFIX;
                break;
            default :
                out = INFO_PREFIX;
                break;
        }

        logData += "\n" + out + message;
    }

    public void init( RuntimeServices rs )
    {
        // do nothing with it
    }

    public void log(int level, String message, Throwable t)
    {
        // ignore the Throwable, we're not testing this method here
        log(level, message);
    }

    public boolean isLevelEnabled(int level)
    {
        return true;
    }
}
```


Overlapping Code:
```
estCase extends BaseTestCase implements LogChute
{
String logData;

/**
* VTL file extension.
*/
private static final String TMPL_FILE_EXT = "vm";
/**
* Comparison file extension.
*/
private static final String CMP_FILE_EXT = "cmp";
/**
* Comparison file extension.
*/
private static final String RESULT_FILE_EXT = "res";
/**
* Path for templates. This property will override the
* value in the default velocity properties file.
*/
private final static String FILE_RESOURCE_LOADER_PATH = TEST_COMPARE_DIR + "/methodoverloading";
/**
* Results relative to the build directory.
*/
private static final String RESULTS_DIR = TEST_RESULT_DIR + "/methodoverloading";
/**
* Results relative to the build directory.
*/
private static final String COMPARE_DIR = TEST_COMPARE_DIR + "/methodoverloading/compare";
/**
* Default constructor.
*/
public MethodOverloadingTestCase(String name)
{
super(name);
}
public void setUp()
{
assureResultsDirectoryExists(RESULTS_DIR);
}
public static Test suite()
{
return new TestSuite(MethodOverloadingTestCase.class);
}
public void testMethodOverloading()
throws Exception
{
/**
* test overloading in a single template
*/
testFile("single");
assertTrue(logData.indexOf("IllegalArgumentException") == -1);
}
public void testParsedMethodOverloading()
throws Exception
{
/**
* test overloading in a file included with #parse
*/
testFile("main");

assertTrue(logData.indexOf("IllegalArgumentException") == -1);

}

public void testFile(String basefilename)
throws Exception
{

VelocityEngine ve = new VelocityEngine();
ve.addProperty(RuntimeConstants.FILE_RESOURCE_LOADER_PATH, FILE_RESOURCE_LOADER_PATH);
ve.setProperty(VelocityEngine.RUNTIME_LOG_LOGSYSTEM, this );
ve.init();

Template template;
FileOutputStream fos;
Writer fwriter;
Context context;

template = ve.getTemplate( getFileName(null, basefilename, TMPL_FILE_EXT) );

fos = new FileOutputStream (
getFileName(RESULTS_DIR, basefil
```
<Overlap Ratio: 0.9835813237557722>

---

--- 118 --
Question ID: 080d89d04cc07bf8055ea12adb37fd71049e8b54
Original Code:
```
class InputReferenceCompiler
        implements RowExpressionVisitor<BytecodeNode, Scope>
{
    private final BiFunction<Scope, Integer, BytecodeExpression> blockResolver;
    private final BiFunction<Scope, Integer, BytecodeExpression> positionResolver;
    private final CallSiteBinder callSiteBinder;

    public InputReferenceCompiler(
            BiFunction<Scope, Integer, BytecodeExpression> blockResolver,
            BiFunction<Scope, Integer, BytecodeExpression> positionResolver,
            CallSiteBinder callSiteBinder)
    {
        this.blockResolver = requireNonNull(blockResolver, "blockResolver is null");
        this.positionResolver = requireNonNull(positionResolver, "positionResolver is null");
        this.callSiteBinder = requireNonNull(callSiteBinder, "callSiteBinder is null");
    }

    public static BytecodeNode generateInputReference(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)
    {
        return new InputReferenceNode(callSiteBinder, scope, type, block, position);
    }

    @Override
    public BytecodeNode visitInputReference(InputReferenceExpression node, Scope scope)
    {
        int field = node.getField();
        Type type = node.getType();

        BytecodeExpression block = blockResolver.apply(scope, field);
        BytecodeExpression position = positionResolver.apply(scope, field);

        return generateInputReference(callSiteBinder, scope, type, block, position);
    }

    @Override
    public BytecodeNode visitCall(CallExpression call, Scope scope)
    {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @Override
    public BytecodeNode visitSpecialForm(SpecialForm specialForm, Scope context)
    {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @Override
    public BytecodeNode visitConstant(ConstantExpression literal, Scope scope)
    {
        throw new UnsupportedOperationException("not yet implemented");
    }

    @Override
    public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)
    {
        throw new UnsupportedOperationException();
    }

    @Override
    public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)
    {
        throw new UnsupportedOperationException();
    }

    static class InputReferenceNode
            implements BytecodeNode
    {
        private final BytecodeNode body;
        private final BytecodeExpression block;
        private final BytecodeExpression position;

        private InputReferenceNode(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)
        {
            // Generate body based on block and position
            Variable wasNullVariable = scope.getVariable("wasNull");
            Class<?> javaType = type.getJavaType();
            if (!javaType.isPrimitive() && javaType != Slice.class) {
                javaType = Object.class;
            }

            IfStatement ifStatement = new IfStatement();
            ifStatement.condition(block.invoke("isNull", boolean.class, position));

            ifStatement.ifTrue()
                    .putVariable(wasNullVariable, true)
                    .pushJavaDefault(javaType);

            String methodName = "get" + Primitives.wrap(javaType).getSimpleName();
            ifStatement.ifFalse(constantType(callSiteBinder, type).invoke(methodName, javaType, block, position));

            this.body = ifStatement;
            this.block = block;
            this.position = position;
        }

        @Override
        public List<BytecodeNode> getChildNodes()
        {
            return ImmutableList.of();
        }

        @Override
        public void accept(MethodVisitor visitor, MethodGenerationContext generationContext)
        {
            body.accept(visitor, generationContext);
        }

        @Override
        public <T> T accept(BytecodeNode parent, BytecodeVisitor<T> visitor)
        {
            return visitor.visitIf(parent, (IfStatement) body);
        }

        public BytecodeNode produceBlockAndPosition()
        {
            BytecodeBlock blockAndPosition = new BytecodeBlock();
            blockAndPosition.append(block);
            blockAndPosition.append(position);
            return blockAndPosition;
        }
    }
}
```


Overlapping Code:
```
ceCompiler
implements RowExpressionVisitor<BytecodeNode, Scope>
{
private final BiFunction<Scope, Integer, BytecodeExpression> blockResolver;
private final BiFunction<Scope, Integer, BytecodeExpression> positionResolver;
private final CallSiteBinder callSiteBinder;
public InputReferenceCompiler(
BiFunction<Scope, Integer, BytecodeExpression> blockResolver,
BiFunction<Scope, Integer, BytecodeExpression> positionResolver,
CallSiteBinder callSiteBinder)
{
this.blockResolver = requireNonNull(blockResolver, "blockResolver is null");
this.positionResolver = requireNonNull(positionResolver, "positionResolver is null");
this.callSiteBinder = requireNonNull(callSiteBinder, "callSiteBinder is null");
}
public static BytecodeNode generateInputReference(CallSiteBinder callSiteBinder, Scope scope, Type type, BytecodeExpression block, BytecodeExpression position)
{
return new InputReferenceNode(callSiteBinder, scope, type, block, position);
}
@Override
public BytecodeNode visitInputReference(InputReferenceExpression node, Scope scope)
{
int field = node.getField();
Type type = node.getType();
BytecodeExpression block = blockResolver.apply(scope, field);
BytecodeExpression position = positionResolver.apply(scope, field);
return generateInputReference(callSiteBinder, scope, type, block, position);
}
@Override
public BytecodeNode visitCall(CallExpression call, Scope scope)
{
throw new UnsupportedOperationException("not yet implemented");
}
@Override
public BytecodeNode visitSpecialForm(SpecialForm specialForm, Scope context)
{
throw new UnsupportedOperationException("not yet implemented");
}
@Override
public BytecodeNode visitConstant(ConstantExpression literal, Scope scope)
{
throw new UnsupportedOperationException("not yet implemented");
}
@Override
public BytecodeNode visitLambda(LambdaDefinitionExpression lambda, Scope context)
{
throw new UnsupportedOperationException();
}
@Override
public BytecodeNode visitVariableReference(VariableReferenceExpression reference, Scope context)
{
throw new UnsupportedOperationException();
}
static class InputReferenceNode
implements BytecodeNode
{
private f
```
<Overlap Ratio: 0.9773567467652495>

---

--- 119 --
Question ID: 0c2f366cff190ea650d6a32a477a52b155cbc83b
Original Code:
```
final class UtilDigesterBeanDefinitionParser extends AbstractEncryptionBeanDefinitionParser {

    private static final String SCOPE_ATTRIBUTE = "scope";
    
    private static final String PARAM_ALGORITHM = "algorithm"; 
    private static final String PARAM_CONFIG_BEAN = "config-bean"; 
    private static final String PARAM_PROVIDER_BEAN = "provider-bean"; 
    private static final String PARAM_PROVIDER_NAME = "provider-name"; 
    private static final String PARAM_STRING_OUTPUT_TYPE = "string-output-type"; 
    
    static final int UTIL_TYPE_BASIC = 0;
    static final int UTIL_TYPE_STRONG = 1;
    static final int UTIL_TYPE_CONFIGURABLE = 2;
    
    private final int utilType;
    
    
    UtilDigesterBeanDefinitionParser(final int utilType) {
        super();
        this.utilType = utilType;
    }

    
    @Override
    protected Class<?> getBeanClass(final Element element) {
        if (this.utilType == UTIL_TYPE_BASIC) {
            return BasicPasswordEncryptor.class;
        } else if (this.utilType == UTIL_TYPE_STRONG) {
            return StrongPasswordEncryptor.class;
        } else if (this.utilType == UTIL_TYPE_CONFIGURABLE) {
            return ConfigurablePasswordEncryptor.class;
        } else {
            throw new IllegalArgumentException("Unknown util type: " + this.utilType);
        }
    }


    @Override
    protected void doParse(final Element element, final BeanDefinitionBuilder builder) {
        
        processStringAttribute(element, builder, PARAM_ALGORITHM, "algorithm");
        processBeanAttribute(element, builder, PARAM_CONFIG_BEAN, "config");
        processBeanAttribute(element, builder, PARAM_PROVIDER_BEAN, "provider");
        processStringAttribute(element, builder, PARAM_PROVIDER_NAME, "providerName");
        processStringAttribute(element, builder, PARAM_STRING_OUTPUT_TYPE, "stringOutputType");
        
        String scope = element.getAttribute(SCOPE_ATTRIBUTE);
        if (StringUtils.hasLength(scope)) {
            builder.setScope(scope);
        }
        
    }
    
    
}
```


Overlapping Code:
```
l class UtilDigesterBeanDefinitionParser extends AbstractEncryptionBeanDefinitionParser {
private static final String SCOPE_ATTRIBUTE = "scope";

private static final String PARAM_ALGORITHM = "algorithm"; 
private static final String PARAM_CONFIG_BEAN = "config-bean"; 
private static final String PARAM_PROVIDER_BEAN = "provider-bean"; 
private static final String PARAM_PROVIDER_NAME = "provider-name"; 
private static final String PARAM_STRING_OUTPUT_TYPE = "string-output-type"; 

static final int UTIL_TYPE_BASIC = 0;
static final int UTIL_TYPE_STRONG = 1;
static final int UTIL_TYPE_CONFIGURABLE = 2;

private final int utilType;


UtilDigesterBeanDefinitionParser(final int utilType) {
super();
this.utilType = utilType;
}

@Override
protected Class<?> getBeanClass(final Element element) {
if (this.utilType == UTIL_TYPE_BASIC) {
return BasicPasswordEncryptor.class;
} else if (this.utilType == UTIL_TYPE_STRONG) {
return StrongPasswordEncryptor.class;
} else if (this.utilType == UTIL_TYPE_CONFIGURABLE) {
return ConfigurablePasswordEncryptor.class;
} else {
throw new IllegalArgumentException("Unknown util type: " + this.utilType);
}
}
@Override
protected void doParse(final Element element, final BeanDefinitionBuilder builder) {

processStringAttribute(element, builder, PARAM_ALGORITHM, "algorithm");
processBeanAttribute(element, builder, PARAM_CONFIG_BEAN, "config");
processBeanAttribute(element, builder, PARAM_PROVIDER_BEAN, "provider");
processStringAttribute(element, builder, PARAM_PROVIDER_NAME, "providerName");
processStringAttribute(element, builder, PARAM_STRING_OUTPUT_TYPE, "stringOutputType");

String scope = element.getAttribute(SCOPE_ATTRIBUTE);
if (StringUtils.hasLength(scope)) {
builder.setScope(scope);
}
```
<Overlap Ratio: 0.9937214611872146>

---

--- 120 --
Question ID: 030296d544cde31942b92139cea5692a2e410f94
Original Code:
```
public class NodeSensorsFragment extends Fragment implements NodeStatusContract.View {

    private static final String BOARDER_ROUTER = NodeSensorsFragment.class.getCanonicalName()+".BOARDER_ROUTER";
    private static final String NODE_ADDRESS = NodeSensorsFragment.class.getCanonicalName()+".NODE_ADDRESS";

    public static NodeSensorsFragment instantiate(Node router, NetworkAddress address){
        NodeSensorsFragment fragment = new NodeSensorsFragment();

        Bundle args = new Bundle();
        args.putString(BOARDER_ROUTER,router.getTag());
        args.putByteArray(NODE_ADDRESS,address.getBytes());
        fragment.setArguments(args);
        return fragment;
    }

    private NodeStatusContract.Presenter mPresenter;

    private TextView mAddress;
    private SensorStatusView mTemperature;
    private SensorStatusView mPressure;
    private SensorStatusView mHumidity;
    private SensorStatusView mAccelerometer;
    private SensorStatusView mMagnetometer;
    private SensorStatusView mGyroscope;
    private LedStatusView mLedStatus;


    @Override
    public void showNodeAddress(NetworkAddress address) {
        FragmentUtil.runOnUiThread(this,()-> mAddress.setText(AddressFormatter.format(address)));

    }

    @Override
    public void showTemperature(float temperature) {
        FragmentUtil.runOnUiThread(this,()-> mTemperature.setSensorValue(getString(R.string.lowpan_details_temperature_format,temperature)));
    }

    @Override
    public void showPressure(float pressure) {
        FragmentUtil.runOnUiThread(this,()-> mPressure.setSensorValue(getString(R.string.lowpan_details_pressure_format,pressure)));
    }

    @Override
    public void showHumidity(float humidity) {
        FragmentUtil.runOnUiThread(this,()-> mHumidity.setSensorValue(getString(R.string.lowpan_details_humidity_format,humidity)));
    }

    @Override
    public void showAccelerometer(float x, float y, float z) {
        FragmentUtil.runOnUiThread(this,()-> mAccelerometer.setSensorValue(
                getString(R.string.lowpan_details_accelerometer_format, x,y,z)));
    }

    @Override
    public void showGyroscope(float x, float y, float z) {
        FragmentUtil.runOnUiThread(this,()-> mGyroscope.setSensorValue(
                getString(R.string.lowpan_details_gyroscope_format, x,y,z)));
    }

    @Override
    public void showMagnetometer(float x, float y, float z) {
        FragmentUtil.runOnUiThread(this,()-> mMagnetometer.setSensorValue(
                getString(R.string.lowpan_details_magnetometer_format, x,y,z)));
    }

    @Override
    public void showLedStatus(byte dimmingValue) {
        FragmentUtil.runOnUiThread(this,()->{
            mLedStatus.setLedStatus((byte) (dimmingValue/4));
            mLedStatus.setVisibility(View.VISIBLE);
        });
    }


    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setHasOptionsMenu(true);
        Bundle boundle = getArguments();
        Node n = Manager.getSharedInstance().getNodeWithTag(boundle.getString(BOARDER_ROUTER));
        Feature6LoWPANProtocol boarderRouter = n.getFeature(Feature6LoWPANProtocol.class);
        NetworkAddress nodeAddress = new NetworkAddress(boundle.getByteArray(NODE_ADDRESS));

        mPresenter = new NodeSensorPresenter(this,boarderRouter,nodeAddress);

    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
        View root = inflater.inflate(R.layout.framgnet_6lowpan_sensor_details,container,false);

        mAddress = root.findViewById(R.id.lowpan_details_address);
        mTemperature = root.findViewById(R.id.lowpan_details_temperature);
        mPressure = root.findViewById(R.id.lowpan_details_pressure);
        mHumidity = root.findViewById(R.id.lowpan_details_humidity);
        mAccelerometer = root.findViewById(R.id.lowpan_details_accelerometer);
        mMagnetometer = root.findViewById(R.id.lowpan_details_magnetometer);
        mGyroscope = root.findViewById(R.id.lowpan_details_gyroscope);
        mLedStatus = root.findViewById(R.id.lowpan_details_led);
        mLedStatus.setOnLedStatusChangeListener(newValue -> {
            if(mPresenter!=null)
                mPresenter.setDimmingStatus((byte)( newValue*25));
        });
        return root;
    }

    @Override
    public void onResume() {
        super.onResume();
        mPresenter.startRetrievingSensorData();
    }

    @Override
    public void onPause() {
        super.onPause();
        mPresenter.stopRetrievingSensorData();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if(item.getItemId()==android.R.id.home) {
            getFragmentManager().popBackStack();
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
}
```


Overlapping Code:
```
blic class NodeSensorsFragment extends Fragment implements NodeStatusContract.View {
private static final String BOARDER_ROUTER = NodeSensorsFragment.class.getCanonicalName()+".BOARDER_ROUTER";
private static final String NODE_ADDRESS = NodeSensorsFragment.class.getCanonicalName()+".NODE_ADDRESS";
public static NodeSensorsFragment instantiate(Node router, NetworkAddress address){
NodeSensorsFragment fragment = new NodeSensorsFragment();
Bundle args = new Bundle();
args.putString(BOARDER_ROUTER,router.getTag());
args.putByteArray(NODE_ADDRESS,address.getBytes());
fragment.setArguments(args);
return fragment;
}
private NodeStatusContract.Presenter mPresenter;
private TextView mAddress;
private SensorStatusView mTemperature;
private SensorStatusView mPressure;
private SensorStatusView mHumidity;
private SensorStatusView mAccelerometer;
private SensorStatusView mMagnetometer;
private SensorStatusView mGyroscope;
private LedStatusView mLedStatus;
@Override
public void showNodeAddress(NetworkAddress address) {
FragmentUtil.runOnUiThread(this,()-> mAddress.setText(AddressFormatter.format(address)));
}
@Override
public void showTemperature(float temperature) {
FragmentUtil.runOnUiThread(this,()-> mTemperature.setSensorValue(getString(R.string.lowpan_details_temperature_format,temperature)));
}
@Override
public void showPressure(float pressure) {
FragmentUtil.runOnUiThread(this,()-> mPressure.setSensorValue(getString(R.string.lowpan_details_pressure_format,pressure)));
}
@Override
public void showHumidity(float humidity) {
FragmentUtil.runOnUiThread(this,()-> mHumidity.setSensorValue(getString(R.string.lowpan_details_humidity_format,humidity)));
}
@Override
public void showAccelerometer(float x, float y, float z) {
FragmentUtil.runOnUiThread(this,()-> mAccelerometer.setSensorValue(
getString(R.string.lowpan_details_accelerometer_format, x,y,z)));
}
@Override
public void showGyroscope(float x, float y, float z) {
FragmentUtil.runOnUiThread(this,()-> mGyroscope.setSensorValue(
getString(R.string.lowpan_details_gyroscope_format, x,y,z)));
}
@Override
public void showMagnetometer(float x, float y, float z) {
FragmentUtil.runO
```
<Overlap Ratio: 0.9768287142208087>

---

--- 121 --
Question ID: ad163cd6a802ea0c9da3d83d79bd82b4e5dcc150
Original Code:
```
public class BooleanTest {
    @Test
    public void sample1Test() {
        String json = "[{$eq: [\"$IncomeStatus\", 30]}, {$eq: [\"$IncomeStatus\", 40]}, {$eq: [\"$ChannelFeeStatus\", 30]}, {$eq: [\"$BankChannelFeeStatus\", 30]}]";
        json = JSONUtils.fastjsonParsePreDeal(json);

        Document or = BooleanOperators.or(json);
        System.out.println(or);

        Document result = new Document("$or", Arrays.asList(
                new Document("$eq", Arrays.asList("$IncomeStatus", 30)),
                new Document("$eq", Arrays.asList("$IncomeStatus", 40)),
                new Document("$eq", Arrays.asList("$ChannelFeeStatus", 30)),
                new Document("$eq", Arrays.asList("$BankChannelFeeStatus", 30))
        ));
        System.out.println(result);
    }

    @Test
    public void sample2Test() {
        String json = "[{$eq: [\"$IncomeStatus\", 30]}, {$eq: [\"$IncomeStatus\", 40]}, {$eq: [\"$ChannelFeeStatus\", 30]}, {$eq: [\"$BankChannelFeeStatus\", 30]}]";
        json = JSONUtils.fastjsonParsePreDeal(json);

        Document or = BooleanOperators.or(json);
        System.out.println(or);

        Document result = new Document("$or", Arrays.asList(
                new Document("$eq", Arrays.asList("$IncomeStatus", 30)),
                new Document("$eq", Arrays.asList("$IncomeStatus", 40)),
                new Document("$eq", Arrays.asList("$ChannelFeeStatus", 30)),
                new Document("$eq", Arrays.asList("$BankChannelFeeStatus", 30))
        ));
        System.out.println(result);
    }

    @Test
    public void sample3Test() {
        String json = "{ $and : [ { $gte : [ { $avg : \"$Income\" }, 80 ] },{ $lt : [ { $avg : \"$Income\" }, 90 ] } ] }";
        json = JSONUtils.fastjsonParsePreDeal(json);

        Document and = ExpressionHelper.parse(json);
        System.out.println(and);

        Document result = new Document("$and", Arrays.asList(
                new Document("$gte", Arrays.asList(new Document("$avg", "$Income"), 80)),
                new Document("$lt", Arrays.asList(new Document("$avg", "$Income"), 90))
        ));
        System.out.println(result);
    }




}
```


Overlapping Code:
```
est {
@Test
public void sample1Test() {
String json = "[{$eq: [\"$IncomeStatus\", 30]}, {$eq: [\"$IncomeStatus\", 40]}, {$eq: [\"$ChannelFeeStatus\", 30]}, {$eq: [\"$BankChannelFeeStatus\", 30]}]";
json = JSONUtils.fastjsonParsePreDeal(json);
Document or = BooleanOperators.or(json);
System.out.println(or);
Document result = new Document("$or", Arrays.asList(
new Document("$eq", Arrays.asList("$IncomeStatus", 30)),
new Document("$eq", Arrays.asList("$IncomeStatus", 40)),
new Document("$eq", Arrays.asList("$ChannelFeeStatus", 30)),
new Document("$eq", Arrays.asList("$BankChannelFeeStatus", 30))
));
System.out.println(result);
}
@Test
public void sample2Test() {
String json = "[{$eq: [\"$IncomeStatus\", 30]}, {$eq: [\"$IncomeStatus\", 40]}, {$eq: [\"$ChannelFeeStatus\", 30]}, {$eq: [\"$BankChannelFeeStatus\", 30]}]";
json = JSONUtils.fastjsonParsePreDeal(json);
Document or = BooleanOperators.or(json);
System.out.println(or);
Document result = new Document("$or", Arrays.asList(
new Document("$eq", Arrays.asList("$IncomeStatus", 30)),
new Document("$eq", Arrays.asList("$IncomeStatus", 40)),
new Document("$eq", Arrays.asList("$ChannelFeeStatus", 30)),
new Document("$eq", Arrays.asList("$BankChannelFeeStatus", 30))
));
System.out.println(result);
}
@Test
public void sample3Test() {
String json = "{ $and : [ { $gte : [ { $avg : \"$Income\" }, 80 ] },{ $lt : [ { $avg : \"$Income\" }, 90 ] } ] }";
json = JSONUtils.fastjsonParsePreDeal(json);
Document and = ExpressionHelper.parse(json);
System.out.println(and);
Document result = new Document("$and", Arrays.asList(
new Document("$gte", Arrays.asList(new Document("$avg", "$Income"), 80)),
new Document("$lt", Arrays.asList(new Document("$avg", "$Income"), 90)
```
<Overlap Ratio: 0.9674523007856342>

---

--- 122 --
Question ID: 9052fb0897eef841b736fc7bc51610e7e6b9ceaa
Original Code:
```
public class BinarySearchST<Key extends Comparable<Key>, Value> {
    private Item[] items;
    private int N;

    private class Item implements Comparable<Item> {
        public Key key;
        public Value val;
        Item(Key key, Value val) {
            this.key = key;
            this.val = val;
        }

        public void val(Value val) {
            this.val = val;
        }

        public int compareTo(Item that) {
            return this.key.compareTo(that.key);
        }
    }

    public BinarySearchST() {
        this(5);
    }

    public BinarySearchST(int capacity) {
        items = new Item[capacity];
    }

    public BinarySearchST(Item[] items) {
        this.items = items;
        N = item.length;
        sort(this.items, 0, N - 1);
    }

    public int size() {
        return N;
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public Value get(Key key) {
        if (isEmpty()) return null;
        int i = rank(key);
        if (i < N && items[i].key.compareTo(key) == 0) return items[i].val;
        else return null;
    }

    public void put(Key key, Value val) {
        int i = rank(key);
        if (i < N && items[i].key.compareTo(key) == 0) {
            items[i].val(val);
            return;
        }

        for (int j = N; j > i; j--) {
            items[j] = items[j - 1];
        }
        items[i] = new Item(key, val);
        N++;
        resize();
    }

    public Key min() {
        return items[0].key;
    }

    public Key max() {
        return items[N - 1].key;
    }

    public Key select(int k) {
        return items[k].key;
    }

    public Key ceiling(Key key) {
        int i = rank(key);
        return items[i].key;
    }

    // public Key floor(Key key)

    // public Key delete(Key key)

    public int rank(Key key) {
        int low = 0;
        int high = N - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int cmp = key.compareTo(items[mid].key);
            if (cmp < 0) high = mid - 1;
            else if (cmp > 0) low = mid + 1;
            else return mid;
        }
        return low;
    }

    public Iterable<Key> keys(Key low, Key high) {
        Queue<Key> q = new Queue<Key>();
        for (int i = rank(low); i < rank(high); i++) {
            q.enqueue(items[i].key);
            if (ceiling(high) != null) {
                q.enqueue(items[rank(high)].key);
            }
        }
        return q;
    }

    private void resize() {
        if (N <= items.length / 2) return;
        int length = items.length * 2;
        Item[] items = new Item[length];

        for (int i = 0; i < N; i ++) {
            items[i] = this.items[i];
        }

        this.items = items;
    }

    private static void sort(Comparable[] a, int low, int high) {
        if (high <= low ) return;
        int mid = low + (high - low) / 2;
        sort(a, low, mid);
        sort(a, mid + 1, high);
        merge(a, low, mid, high);
    }

    public static void merge(Comparable[] a, int low, int mid, int high) {
        int i = low;
        int j = mid + 1;

        for (int k = low; k <= high; k++) {
            aux[k] = a[k];
        }

        for (int k = low; k <= high; k++) {
            if (i > mid) a[k] = aux[j++];
            else if (j > high) a[k] = aux[i++];
            else if (less(aux[j], aux[i])) a[k] = aux[j++];
            else a[k] = aux[i++];
        }
    }
}
```


Overlapping Code:
```
public class BinarySearchST<Key extends Comparable<Key>, Value> {
private Item[] items;
private int N;
private class Item implements Comparable<Item> {
public Key key;
public Value val;
Item(Key key, Value val) {
this.key = key;
this.val = val;
}
public void val(Value val) {
this.val = val;
}
public int compareTo(Item that) {
return this.key.compareTo(that.key);
}
}
public BinarySearchST() {
this(5);
}
public BinarySearchST(int capacity) {
items = new Item[capacity];
}
public BinarySearchST(Item[] items) {
this.items = items;
N = item.length;
sort(this.items, 0, N - 1);
}
public int size() {
return N;
}
public boolean isEmpty() {
return N == 0;
}
public Value get(Key key) {
if (isEmpty()) return null;
int i = rank(key);
if (i < N && items[i].key.compareTo(key) == 0) return items[i].val;
else return null;
}
public void put(Key key, Value val) {
int i = rank(key);
if (i < N && items[i].key.compareTo(key) == 0) {
items[i].val(val);
return;
}
for (int j = N; j > i; j--) {
items[j] = items[j - 1];
}
items[i] = new Item(key, val);
N++;
resize();
}
public Key min() {
return items[0].key;
}
public Key max() {
return items[N - 1].key;
}
public Key select(int k) {
return items[k].key;
}
public Key ceiling(Key key) {
int i = rank(key);
return items[i].key;
}
// public Key floor(Key key)
// public Key delete(Key key)
public int rank(Key key) {
int low = 0;
int high = N - 1;
while (low <= high) {
int mid = low + (high - low) / 2;
int cmp = key.compareTo(items[mid].key);
if (cmp < 0) high = mid - 1;
else if (cmp > 0) low = mid + 1;
else return mid;
}
return low;
}
public Iterable<Key> keys(Key low, Key high) {
Queue<Key> q = new Queue<Key>();
for (int i = rank(low); i < rank(high); i++) {
q.enqueue(items[i].key);
if (ceiling(high) != null) {
q.enqueue(items[rank(high)].key);
}
}
return q;
}
private 
```
<Overlap Ratio: 0.9961601755348327>

---

--- 123 --
Question ID: 632ead9166a319d9e1e3bfe928eeda51d32e4da2
Original Code:
```
@Preamble(description = "Model for a device enrollment denial.")
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public class DeviceEnrollmentDenial implements SdkModel {
    /**
     * Serialisation Id.
     */
    private static final long serialVersionUID = 3114354744522935L;

    /**
     * account id.
     */
    private final String accountId;

    /**
     * date on which the failed bootstrap was attempted on.
     */
    private final Date createdAt;

    /**
     * endpoint name.
     */
    private final String endpointName;

    /**
     * id of the recorded failed bootstrap attempt.
     */
    private String id;

    /**
     * Trusted certificate id.
     */
    private final String trustedCertificateId;

    /**
     * Internal constructor.
     * 
     * <p>
     * Constructor based on all fields.
     * <p>
     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.
     * 
     * @param accountId
     *            account id.
     * @param createdAt
     *            date on which the failed bootstrap was attempted on.
     * @param endpointName
     *            endpoint name.
     * @param id
     *            id of the recorded failed bootstrap attempt.
     * @param trustedCertificateId
     *            Trusted certificate id.
     */
    @Internal
    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String id,
                                  String trustedCertificateId) {
        super();
        this.accountId = accountId;
        this.createdAt = createdAt;
        this.endpointName = endpointName;
        this.trustedCertificateId = trustedCertificateId;
        setId(id);
    }

    /**
     * Internal constructor.
     * 
     * <p>
     * Constructor based on a similar object.
     * <p>
     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.
     * 
     * @param deviceEnrollmentDenial
     *            a device enrollment denial.
     */
    @Internal
    public DeviceEnrollmentDenial(DeviceEnrollmentDenial deviceEnrollmentDenial) {
        this(deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.accountId,
             deviceEnrollmentDenial == null ? new Date() : deviceEnrollmentDenial.createdAt,
             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.endpointName,
             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.id,
             deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.trustedCertificateId);
    }

    /**
     * Constructor.
     */
    public DeviceEnrollmentDenial() {
        this((String) null, new Date(), (String) null, (String) null, (String) null);
    }

    /**
     * Constructor.
     * 
     * <p>
     * Constructor based on object identifier.
     * <p>
     * 
     * @param id
     *            id of the recorded failed bootstrap attempt.
     */
    public DeviceEnrollmentDenial(String id) {
        this();
        setId(id);
    }

    /**
     * Internal constructor.
     * 
     * <p>
     * Constructor based on read-only fields.
     * <p>
     * Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.
     * 
     * @param accountId
     *            account id.
     * @param createdAt
     *            date on which the failed bootstrap was attempted on.
     * @param endpointName
     *            endpoint name.
     * @param trustedCertificateId
     *            Trusted certificate id.
     */
    @Internal
    public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String trustedCertificateId) {
        this(accountId, createdAt, endpointName, (String) null, trustedCertificateId);
    }

    /**
     * Gets account id.
     * 
     * @return accountId
     */
    public String getAccountId() {
        return accountId;
    }

    /**
     * Gets date on which the failed bootstrap was attempted on.
     * 
     * @return createdAt
     */
    public Date getCreatedAt() {
        return createdAt;
    }

    /**
     * Gets endpoint name.
     * 
     * @return endpointName
     */
    public String getEndpointName() {
        return endpointName;
    }

    /**
     * Gets id of the recorded failed bootstrap attempt.
     * 
     * @return id
     */
    @Override
    public String getId() {
        return id;
    }

    /**
     * Sets id of the recorded failed bootstrap attempt.
     * 
     * <p>
     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid
     * 
     * @param id
     *            id of the recorded failed bootstrap attempt.
     */
    @Override
    public void setId(String id) {
        this.id = id;
    }

    /**
     * Sets id of the recorded failed bootstrap attempt.
     * 
     * <p>
     * Similar to {@link #setId(String)}
     * <p>
     * Note: the length of the string has to match {@code /[a-f0-9]{32}/} to be valid
     * 
     * @param deviceEnrollmentDenialId
     *            id of the recorded failed bootstrap attempt.
     */
    @Internal
    public void setDeviceEnrollmentDenialId(String deviceEnrollmentDenialId) {
        setId(deviceEnrollmentDenialId);
    }

    /**
     * Checks whether id value is valid.
     * 
     * @return true if the value is valid; false otherwise.
     */
    @SuppressWarnings("PMD.UselessParentheses")
    public boolean isIdValid() {
        return (id == null || id.matches("[a-f0-9]{32}"));
    }

    /**
     * Gets trusted certificate id.
     * 
     * @return trustedCertificateId
     */
    public String getTrustedCertificateId() {
        return trustedCertificateId;
    }

    /**
     * Returns a string representation of the object.
     * 
     * <p>
     * 
     * @see java.lang.Object#toString()
     * @return the string representation
     */
    @Override
    public String toString() {
        return "DeviceEnrollmentDenial [accountId=" + accountId + ", createdAt=" + createdAt + ", endpointName="
               + endpointName + ", id=" + id + ", trustedCertificateId=" + trustedCertificateId + "]";
    }

    /**
     * Calculates the hash code of this instance based on field values.
     * 
     * <p>
     * 
     * @see java.lang.Object#hashCode()
     * @return hash code
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((accountId == null) ? 0 : accountId.hashCode());
        result = prime * result + ((createdAt == null) ? 0 : createdAt.hashCode());
        result = prime * result + ((endpointName == null) ? 0 : endpointName.hashCode());
        result = prime * result + ((id == null) ? 0 : id.hashCode());
        result = prime * result + ((trustedCertificateId == null) ? 0 : trustedCertificateId.hashCode());
        return result;
    }

    /**
     * Method to ensure {@link #equals(Object)} is correct.
     * 
     * <p>
     * Note: see this article: <a href="https://www.artima.com/lejava/articles/equality.html">canEqual()</a>
     * 
     * @param other
     *            another object.
     * @return true if the other object is an instance of the class in which canEqual is (re)defined, false otherwise.
     */
    protected boolean canEqual(Object other) {
        return other instanceof DeviceEnrollmentDenial;
    }

    /**
     * Indicates whether some other object is "equal to" this one.
     * 
     * <p>
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     * @param obj
     *            an object to compare with this instance.
     * @return true if this object is the same as the obj argument; false otherwise.
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof DeviceEnrollmentDenial)) {
            return false;
        }
        final DeviceEnrollmentDenial other = (DeviceEnrollmentDenial) obj;
        if (!other.canEqual(this)) {
            return false;
        }
        if (accountId == null) {
            if (other.accountId != null) {
                return false;
            }
        } else if (!accountId.equals(other.accountId)) {
            return false;
        }
        if (createdAt == null) {
            if (other.createdAt != null) {
                return false;
            }
        } else if (!createdAt.equals(other.createdAt)) {
            return false;
        }
        if (endpointName == null) {
            if (other.endpointName != null) {
                return false;
            }
        } else if (!endpointName.equals(other.endpointName)) {
            return false;
        }
        if (id == null) {
            if (other.id != null) {
                return false;
            }
        } else if (!id.equals(other.id)) {
            return false;
        }
        if (trustedCertificateId == null) {
            if (other.trustedCertificateId != null) {
                return false;
            }
        } else if (!trustedCertificateId.equals(other.trustedCertificateId)) {
            return false;
        }
        return true;
    }

    /**
     * Checks whether the model is valid or not.
     * 
     * <p>
     * 
     * @see SdkModel#isValid()
     * @return true if the model is valid; false otherwise.
     */
    @Override
    public boolean isValid() {
        return isIdValid();
    }

    /**
     * Clones this instance.
     * 
     * <p>
     * 
     * @see java.lang.Object#clone()
     * @return a cloned instance
     */
    @Override
    public DeviceEnrollmentDenial clone() {
        return new DeviceEnrollmentDenial(this);
    }
}
```


Overlapping Code:
```
@Preamble(description = "Model for a device enrollment denial.")
@SuppressWarnings("PMD.AvoidDuplicateLiterals")
public class DeviceEnrollmentDenial implements SdkModel {
/**
* Serialisation Id.
*/
private static final long serialVersionUID = 3114354744522935L;
/**
* account id.
*/
private final String accountId;
/**
* date on which the failed bootstrap was attempted on.
*/
private final Date createdAt;
/**
* endpoint name.
*/
private final String endpointName;
/**
* id of the recorded failed bootstrap attempt.
*/
private String id;
/**
* Trusted certificate id.
*/
private final String trustedCertificateId;
/**
* Internal constructor.
* 
* <p>
* Constructor based on all fields.
* <p>
* Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.
* 
* @param accountId
* account id.
* @param createdAt
* date on which the failed bootstrap was attempted on.
* @param endpointName
* endpoint name.
* @param id
* id of the recorded failed bootstrap attempt.
* @param trustedCertificateId
* Trusted certificate id.
*/
@Internal
public DeviceEnrollmentDenial(String accountId, Date createdAt, String endpointName, String id,
String trustedCertificateId) {
super();
this.accountId = accountId;
this.createdAt = createdAt;
this.endpointName = endpointName;
this.trustedCertificateId = trustedCertificateId;
setId(id);
}
/**
* Internal constructor.
* 
* <p>
* Constructor based on a similar object.
* <p>
* Note: Should not be used. Use {@link #DeviceEnrollmentDenial()} instead.
* 
* @param deviceEnrollmentDenial
* a device enrollment denial.
*/
@Internal
public DeviceEnrollmentDenial(DeviceEnrollmentDenial deviceEnrollmentDenial) {
this(deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.accountId,
deviceEnrollmentDenial == null ? new Date() : deviceEnrollmentDenial.createdAt,
deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.endpointName,
deviceEnrollmentDenial == null ? (String) null : deviceEnrollmentDenial.id,
deviceEn
```
<Overlap Ratio: 0.9900398406374502>

---

--- 124 --
Question ID: 3adb986857c8c1f1de67fe373e7d21834e7bd83f
Original Code:
```
public class Settings implements java.io.Serializable {
  private final static String FILENAME = "beanbowlSettings.ser";
  private final static int RECENT_FILE_COUNT = 5;
  transient static Settings settings;

  public List recentFiles;

  private Settings() {
    recentFiles = new LinkedList();
  }

  public static void addRecentFile(File file) {
    if (file != null && !settings.recentFiles.contains(file)) {
      settings.recentFiles.add(0, file);
    }
    while(settings.recentFiles.size() > 5) {
      settings.recentFiles.remove(4);
    }
  }

  public static Iterator getRecentFiles() {
    return settings.recentFiles.iterator();
  }

  static {
    if (getFile().exists()) {
      try {
        loadFromFile();
      } catch (Exception err) {
        System.err.println("Warning - settings could not be loaded: " + err.getMessage());
        settings = new Settings();
      }
    } else {
      settings = new Settings();
    }
  }

  @Override
protected void finalize() {
    try {
      saveToFile();
    } catch (Exception err) {
      System.err.println("Warning - settings could not be saved: " + err.getMessage());
    }
  }

  public static void loadFromFile() throws Exception {
    InputStream fileIn = new FileInputStream(getFile());
	  ObjectInputStream objectIn = new ObjectInputStream(fileIn);
	  settings = (Settings) (objectIn.readObject());
    objectIn.close();
    fileIn.close();
  }

  public static void saveToFile() throws Exception {
    FileOutputStream fileOut = new FileOutputStream(getFile());
    ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);
    objectOut.writeObject(settings);
    objectOut.close();
    fileOut.close();
  }

  private static File getFile() {
    File homeDir = new File(System.getProperties().getProperty("user.home"));
    return new File(homeDir, FILENAME);
  }

}
```


Overlapping Code:
```
ss Settings implements java.io.Serializable {
private final static String FILENAME = "beanbowlSettings.ser";
private final static int RECENT_FILE_COUNT = 5;
transient static Settings settings;
public List recentFiles;
private Settings() {
recentFiles = new LinkedList();
}
public static void addRecentFile(File file) {
if (file != null && !settings.recentFiles.contains(file)) {
settings.recentFiles.add(0, file);
}
while(settings.recentFiles.size() > 5) {
settings.recentFiles.remove(4);
}
}
public static Iterator getRecentFiles() {
return settings.recentFiles.iterator();
}
static {
if (getFile().exists()) {
try {
loadFromFile();
} catch (Exception err) {
System.err.println("Warning - settings could not be loaded: " + err.getMessage());
settings = new Settings();
}
} else {
settings = new Settings();
}
}
@Override
protected void finalize() {
try {
saveToFile();
} catch (Exception err) {
System.err.println("Warning - settings could not be saved: " + err.getMessage());
}
}
public static void loadFromFile() throws Exception {
InputStream fileIn = new FileInputStream(getFile());
ObjectInputStream objectIn = new ObjectInputStream(fileIn);
settings = (Settings) (objectIn.readObject());
objectIn.close();
fileIn.close();
}
public static void saveToFile() throws Exception {
FileOutputStream fileOut = new FileOutputStream(getFile());
ObjectOutputStream objectOut = new ObjectOutputStream(fileOut);
objectOut.writeObject(settings);
objectOut.close();
fileOut.close();
}
private static File getFile() {
File homeDir = new File(System.getProperties().getProperty("user.home"));
return new File(homeDir, F
```
<Overlap Ratio: 0.9859068627450981>

---

--- 125 --
Question ID: 89934386cfcaee1a5dac439ec3f086d90d6ed548
Original Code:
```
public class SingletonInstanceServerSocket extends SingletonInstance {

    private static int serverInstanceCount = 0;
    private final Server singletonServer;
    private final String fullName;

    public SingletonInstanceServerSocket(final long poll_ms, final int portNumber) {
        super(poll_ms);

        // Gather the local InetAddress, loopback is prioritized
        InetAddress ilh = null;
        try {
            ilh = InetAddress.getByName(null); // loopback
        } catch (final UnknownHostException e1) { }
        if(null == ilh) {
            try {
                ilh = InetAddress.getByName("localhost");
                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }
            } catch (final UnknownHostException e1) { }
        }
        if(null == ilh) {
            try {
                ilh = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 } );
                if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }
            } catch (final UnknownHostException e) { }
        }
        if(null == ilh) {
            try {
                ilh = InetAddress.getLocalHost();
            } catch (final UnknownHostException e) { }
        }
        if(null == ilh) {
            throw new RuntimeException(infoPrefix()+" EEE Could not determine local InetAddress");
        }

        fullName = ilh.toString()+":"+portNumber;
        singletonServer = new Server(ilh, portNumber);
        Runtime.getRuntime().addShutdownHook(new InterruptSource.Thread() {
            @Override
            public void run() {
                singletonServer.kill();
            }
        });
    }

    public final InetAddress getLocalInetAddress() {
        return singletonServer.getLocalInetAddress();
    }

    public final int getPortNumber() {
        return singletonServer.getPortNumber();
    }

    @Override
    public final String getName() { return fullName; }

    @Override
    protected boolean tryLockImpl() {
        if( singletonServer.isRunning() ) {
            return false; // same JVM .. server socket already installed !
        }

        // check if other JVM's locked the server socket ..
        final Socket clientSocket = singletonServer.connect();
        if(null != clientSocket) {
            try {
                clientSocket.close();
            } catch (final IOException e) { }
            return false;
        }

        if( !singletonServer.start() ) {
            return false;
        }

        return true;
    }

    @Override
    protected boolean unlockImpl() {
        return singletonServer.shutdown();
    }

    public class Server implements Runnable {
       private final InetAddress localInetAddress;
       private final int portNumber;

       private volatile boolean shallQuit = false;
       private volatile boolean alive = false;

       private final Object syncOnStartStop = new Object();
       private ServerSocket serverSocket = null;
       private Thread serverThread = null;  // allowing kill() to force-stop last server-thread

       public Server(final InetAddress localInetAddress, final int portNumber) {
           this.localInetAddress = localInetAddress;
           this.portNumber = portNumber;
       }

       public final InetAddress getLocalInetAddress() { return localInetAddress; }
       public final int getPortNumber() { return portNumber; }

       public final boolean start() {
           if(alive) return true;

           final String sname;
           synchronized (Server.class) {
               serverInstanceCount++;
               sname = "SingletonServerSocket"+serverInstanceCount+"-"+fullName;
           }
           synchronized (syncOnStartStop) {
               shallQuit = false;
               serverThread = new InterruptSource.Thread(null, this, sname);
               serverThread.setDaemon(true);  // be a daemon, don't keep the JVM running
               serverThread.start();
               try {
                   while( !alive && !shallQuit ) {
                       syncOnStartStop.wait();
                   }
               } catch (final InterruptedException ie) {
                   final InterruptedException ie2 = SourcedInterruptedException.wrap(ie);
                   shutdown(false);
                   throw new InterruptedRuntimeException(ie2);
               }
           }
           final boolean ok = isBound();
           if(!ok) {
               shutdown(true);
           }
           return ok;
       }

       public final boolean shutdown() {
           return shutdown(true);
       }
       private final boolean shutdown(final boolean wait) {
           if(!alive) return true;

           try {
               synchronized (syncOnStartStop) {
                   shallQuit = true;
                   connect();
                   if( wait ) {
                       try {
                           while( alive ) {
                               syncOnStartStop.wait();
                           }
                       } catch (final InterruptedException ie) {
                           throw new InterruptedRuntimeException(ie);
                       }
                   }
               }
           } finally {
               if(alive) {
                   System.err.println(infoPrefix()+" EEE "+getName()+" - Unable to remove lock: ServerThread still alive ?");
                   kill();
               }
           }
           return true;
       }

       /**
        * Brutally kill server thread and close socket regardless.
        * This is out last chance for JVM shutdown.
        */
       @SuppressWarnings("deprecation")
       public final void kill() {
           if(alive) {
                System.err.println(infoPrefix()+" XXX "+getName()+" - Kill @ JVM Shutdown");
           }
           alive = false;
           shallQuit = false;
           if(null != serverThread && serverThread.isAlive() ) {
               try {
                   serverThread.stop();
               } catch(final Throwable t) { }
           }
           if(null != serverSocket) {
               try {
                   final ServerSocket ss = serverSocket;
                   serverSocket = null;
                   ss.close();
               } catch (final Throwable t) { }
           }
       }

       public final boolean isRunning() { return alive; }

       public final boolean isBound() {
           return alive && null != serverSocket && serverSocket.isBound() ;
       }

       public final Socket connect() {
           try {
               return new Socket(localInetAddress, portNumber);
           } catch (final Exception e) { }
           return null;
       }

       @Override
       public void run() {
           if(DEBUG) {
               System.err.println(infoPrefix()+" III - Start");
           }
           try {
               synchronized (syncOnStartStop) {
                   try {
                       serverSocket = new ServerSocket(portNumber, 1, localInetAddress);
                       serverSocket.setReuseAddress(true); // reuse same port w/ subsequent instance, i.e. overcome TO state when JVM crashed
                       alive = true;
                   } catch (final IOException e) {
                       System.err.println(infoPrefix()+" III - Unable to install ServerSocket: "+e.getMessage());
                       shallQuit = true;
                   } finally {
                       syncOnStartStop.notifyAll();
                   }
               }

               while (!shallQuit) {
                   try {
                       final Socket clientSocket = serverSocket.accept();
                       clientSocket.close();
                   } catch (final IOException ioe) {
                       System.err.println(infoPrefix()+" EEE - Exception during accept: " + ioe.getMessage());
                   }
               }
           } catch(final ThreadDeath td) {
               if( DEBUG ) {
                   ExceptionUtils.dumpThrowable("", td);
               }
           } finally {
               synchronized (syncOnStartStop) {
                   if(DEBUG) {
                       System.err.println(infoPrefix()+" III - Stopping: alive "+alive+", shallQuit "+shallQuit+", hasSocket "+(null!=serverSocket));
                   }
                   if(null != serverSocket) {
                       try {
                           serverSocket.close();
                       } catch (final IOException e) {
                           System.err.println(infoPrefix()+" EEE - Exception during close: " + e.getMessage());
                       }
                   }
                   serverSocket = null;
                   alive = false;
                   syncOnStartStop.notifyAll();
               }
           }
       }
    }
}
```


Overlapping Code:
```
gletonInstanceServerSocket extends SingletonInstance {
private static int serverInstanceCount = 0;
private final Server singletonServer;
private final String fullName;
public SingletonInstanceServerSocket(final long poll_ms, final int portNumber) {
super(poll_ms);
// Gather the local InetAddress, loopback is prioritized
InetAddress ilh = null;
try {
ilh = InetAddress.getByName(null); // loopback
} catch (final UnknownHostException e1) { }
if(null == ilh) {
try {
ilh = InetAddress.getByName("localhost");
if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }
} catch (final UnknownHostException e1) { }
}
if(null == ilh) {
try {
ilh = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 } );
if(null!=ilh && !ilh.isLoopbackAddress()) { ilh = null; }
} catch (final UnknownHostException e) { }
}
if(null == ilh) {
try {
ilh = InetAddress.getLocalHost();
} catch (final UnknownHostException e) { }
}
if(null == ilh) {
throw new RuntimeException(infoPrefix()+" EEE Could not determine local InetAddress");
}
fullName = ilh.toString()+":"+portNumber;
singletonServer = new Server(ilh, portNumber);
Runtime.getRuntime().addShutdownHook(new InterruptSource.Thread() {
@Override
public void run() {
singletonServer.kill();
}
});
}
public final InetAddress getLocalInetAddress() {
return singletonServer.getLocalInetAddress();
}
public final int getPortNumber() {
return singletonServer.getPortNumber();
}
@Override
public final String getName() { return fullName; }
@Override
protected boolean tryLockImpl() {
if( singletonServer.isRunning() ) {
return false; // same JVM .. server socket already installed !
}
// check if other JVM's locked the server socket ..
final Socket clientSocket = singletonServer.connect();
if(null != clientSocket) {
try {
clientSocket.close();
} catch (final IOException e) { }
return false;
}
if( !singletonServer.start() ) {
retu
```
<Overlap Ratio: 0.9779179810725552>

---

--- 126 --
Question ID: ffd65bc8f8726f67837379ec1a8dcf56ef0348c8
Original Code:
```
public class ArraySortedOrNot {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] a = new int[n];
		int[] b = new int[n];
 		for(int i =0; i< a.length; i++)
		{
			a[i] = sc.nextInt();
			b[i] = a[i];
		}
 		Arrays.sort(a);
 		
 			if(Arrays.equals(a, b))
 			{
 				System.out.println("true");
 			}
 			else {
 				System.out.println("false");

 			}
	}

}
```


Overlapping Code:
```
rraySortedOrNot {
public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[] a = new int[n];
int[] b = new int[n];
for(int i =0; i< a.length; i++)
{
a[i] = sc.nextInt();
b[i] = a[i];
}
Arrays.sort(a);

if(Arrays.equals(a, b))
{
System.out.println("true");
}
else {
System.out.println("false");
}
}
```
<Overlap Ratio: 0.959493670886076>

---

--- 127 --
Question ID: 6103fc5e751818821a8a76fde1f7c7a79b8d7a55
Original Code:
```
public class ResultResponseSettings implements Parcelable {

    private String id;
    private String field;
    private String value;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getField() {
        return field;
    }

    public void setField(String field) {
        this.field = field;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }


    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(this.id);
        dest.writeString(this.field);
        dest.writeString(this.value);
    }

    public ResultResponseSettings() {
    }

    protected ResultResponseSettings(Parcel in) {
        this.id = in.readString();
        this.field = in.readString();
        this.value = in.readString();
    }

    public static final Parcelable.Creator<ResultResponseSettings> CREATOR = new Parcelable.Creator<ResultResponseSettings>() {
        @Override
        public ResultResponseSettings createFromParcel(Parcel source) {
            return new ResultResponseSettings(source);
        }

        @Override
        public ResultResponseSettings[] newArray(int size) {
            return new ResultResponseSettings[size];
        }
    };
}
```


Overlapping Code:
```
s implements Parcelable {
private String id;
private String field;
private String value;
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getField() {
return field;
}
public void setField(String field) {
this.field = field;
}
public String getValue() {
return value;
}
public void setValue(String value) {
this.value = value;
}
@Override
public int describeContents() {
return 0;
}
@Override
public void writeToParcel(Parcel dest, int flags) {
dest.writeString(this.id);
dest.writeString(this.field);
dest.writeString(this.value);
}
public ResultResponseSettings() {
}
protected ResultResponseSettings(Parcel in) {
this.id = in.readString();
this.field = in.readString();
this.value = in.readString();
}
public static final Parcelable.Creator<ResultResponseSettings> CREATOR = new Parcelable.Creator<ResultResponseSettings>() {
@Override
public ResultResponseSettings createFromParcel(Parcel source) {
return new ResultResponseSettings(source);
}
@Override
public ResultResponseSettings[] newArray(int size) {
return new ResultResponseSettings[size];

```
<Overlap Ratio: 0.9649122807017544>

---

--- 128 --
Question ID: bcd8fd4fb52bfe540c2022c05c1ed53ca81ebdeb
Original Code:
```
public class GallopingSearchJava {
  public static int find(ColumnVector values, int key, int start, int end) {
    assert (end != 0);
    assert (start < end);

    int bound = Math.max(start, 1);
    while (bound < end && values.getInt(bound) < key) {
      bound *= 2;
    }
    return binarySearch(values, key, Math.max(start, bound / 2), Math.min(bound + 1, end));
  }

  public static int binarySearch(ColumnVector vector, int key, int start, int end) {
    assert (0 <= start);
    assert (start < end);

    int L = start;
    int R = end;
    while (L < R) {
      int M = (L + R) / 2;
      if (vector.getInt(M) < key) {
        L = M + 1;
      } else if (vector.getInt(M) > key) {
        R = M - 1;
      } else {
        while (start < M && vector.getInt(M - 1) == key) {
          M -= 1;
        }
        return M;
      }
    }
    while (start < L && vector.getInt(L - 1) == key) {
      L -= 1;
    }

    return Math.min((L < end && vector.getInt(L) < key) ? L + 1 : L, end);
  }
}
```


Overlapping Code:
```
atic int find(ColumnVector values, int key, int start, int end) {
assert (end != 0);
assert (start < end);
int bound = Math.max(start, 1);
while (bound < end && values.getInt(bound) < key) {
bound *= 2;
}
return binarySearch(values, key, Math.max(start, bound / 2), Math.min(bound + 1, end));
}
public static int binarySearch(ColumnVector vector, int key, int start, int end) {
assert (0 <= start);
assert (start < end);
int L = start;
int R = end;
while (L < R) {
int M = (L + R) / 2;
if (vector.getInt(M) < key) {
L = M + 1;
} else if (vector.getInt(M) > key) {
R = M - 1;
} else {
while (start < M && vector.getInt(M - 1) == key) {
M -= 1;
}
return M;
}
}
while (start < L && vector.getInt(L - 1) == key) {
L -= 1;
}
return Math.min((L < end && ve
```
<Overlap Ratio: 0.8949880668257757>

---

--- 129 --
Question ID: 58ad840e21196d577a9e480e753fcfc8ee56aea8
Original Code:
```
public class PoetCodeUtil {

    /**
     * @param targetClass
     * @return field and field type
     */
    public static HashMap<String, TypeName> createFieldMap(TypeElement targetClass) {
        HashMap<String, TypeName> fieldMap = new HashMap<>();
        for (Element encloseElement : targetClass.getEnclosedElements()) {
            if (encloseElement.getKind() == ElementKind.FIELD) {
                String fieldName = encloseElement.getSimpleName().toString();
                TypeName fieldTypeName = TypeName.get(encloseElement.asType());
                fieldMap.put(fieldName, fieldTypeName);
            }
        }
        return fieldMap;
    }

    public static String createNewClazzName(TypeElement targetClass, String suffix) {
        String originClazzName = targetClass.getSimpleName().toString();
        return originClazzName + suffix;
    }

    public static ClassName createNewClazzType(String pkg, String newClazzName, String... clazzNames) {
        return ClassName.get(pkg, newClazzName, clazzNames);
    }

    public static String getTargetPkgName(TypeElement targetClass, Elements elementUtils) {
        PackageElement pkg = elementUtils.getPackageOf(targetClass);
        return pkg.getQualifiedName().toString();
    }

    public static MethodSpec createConstructMethod(Modifier... modifiers) {
        MethodSpec.Builder method = MethodSpec.constructorBuilder()
                .addModifiers(modifiers);
        return method.build();
    }

    public static MethodSpec createSetReturn(TypeName returnType, String fieldName, TypeName fieldType, Modifier... modifiers) {
        String methodName = "set" + upperFirstChar(fieldName);
        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(modifiers)
                .returns(returnType)
                .addParameter(fieldType, fieldName)
                .addStatement("this.$L = $L", fieldName, fieldName)
                .addStatement("return this");
        return method.build();
    }

    public static MethodSpec createSet(String fieldName, TypeName fieldType, Modifier... modifiers) {
        String methodName = "set" + upperFirstChar(fieldName);
        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(modifiers)
                .addParameter(fieldType, fieldName)
                .addStatement("this.$L = $L", fieldName, fieldName);
        return method.build();
    }

    public static MethodSpec createGet(String fieldName, TypeName fieldType, Modifier... modifiers) {
        String methodName = "get" + upperFirstChar(fieldName);
        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(modifiers)
                .returns(fieldType)
                .addStatement("return " + fieldName);
        return method.build();
    }

    public static MethodSpec createToString(String clazzName, HashMap<String, TypeName> fieldMap, Modifier... modifiers) {
        String methodName = "toString";
        MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                .addModifiers(modifiers)
                .addAnnotation(Override.class)
                .returns(String.class);

        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("\"")
                .append(clazzName)
                .append("{\"");
        for (String field : fieldMap.keySet()) {
            stringBuilder.append(" + \"").append(field).append(":\" + ").append(field);
        }
        stringBuilder.append(" + \"}\"");
        method.addStatement("return " + stringBuilder.toString());
        return method.build();
    }


    public static String upperFirstChar(String str) {
        char[] ch = str.toCharArray();
        if (ch[0] >= 'a' && ch[0] <= 'z') {
            ch[0] = (char) (ch[0] - 32);
        }
        return new String(ch);
    }

    public static class Parcelable {
        public static void createParcelable(TypeName typeName, TypeSpec.Builder typeSpecBuilder, HashMap<String, TypeName> fieldMap) {
            ClassName parcelableType = ClassName.get("android.os", "Parcelable");
            ClassName parcelType = ClassName.get("android.os", "Parcel");
            ClassName parcelableCreator = ClassName.get("android.os", "Parcelable", "Creator");
            TypeName creatorFieldType = ParameterizedTypeName.get(parcelableCreator, typeName);

            //1. implements Parcelable
            typeSpecBuilder.addSuperinterface(parcelableType);

            //2. describeContents
            MethodSpec.Builder method = MethodSpec.methodBuilder("describeContents")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .returns(int.class)
                    .addStatement("return 0");

            //3. writeToParcel
            MethodSpec.Builder method1 = MethodSpec.methodBuilder("writeToParcel")
                    .addModifiers(Modifier.PUBLIC)
                    .addAnnotation(Override.class)
                    .addParameter(parcelType, "dest")
                    .addParameter(int.class, "flags");
            for (String field : fieldMap.keySet()) {
                method1.addStatement("dest.writeValue($L)", "this." + field);
            }

            //4. construct(Parcel in)
            MethodSpec.Builder method2 = MethodSpec.constructorBuilder()
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(parcelType, "in")
                    .addStatement("$T classLoader = this.getClass().getClassLoader()", ClassLoader.class);
            for (String field : fieldMap.keySet()) {
                method2.addStatement("this.$L = ($T)in.readValue(classLoader)", field, fieldMap.get(field));
            }

            //5. CREATOR
            ArrayTypeName newTypeArray = ArrayTypeName.of(typeName);
            TypeSpec parcelableCreatorType = TypeSpec.anonymousClassBuilder("")
                    .addSuperinterface(creatorFieldType)
                    .addMethod(MethodSpec.methodBuilder("createFromParcel")
                            .addAnnotation(Override.class)
                            .addModifiers(Modifier.PUBLIC)
                            .addParameter(parcelType, "source")
                            .returns(typeName)
                            .addStatement("return new $T($N)", typeName, "source")
                            .build())
                    .addMethod(MethodSpec.methodBuilder("newArray")
                            .addAnnotation(Override.class)
                            .addModifiers(Modifier.PUBLIC)
                            .addParameter(int.class, "size")
                            .returns(newTypeArray)
                            .addStatement("return new $T[$N]", typeName, "size")
                            .build())
                    .build();
            FieldSpec.Builder creatorField = FieldSpec.builder(creatorFieldType, "CREATOR")
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                    .initializer("$L", parcelableCreatorType);

            typeSpecBuilder.addMethod(method.build());
            typeSpecBuilder.addMethod(method1.build());
            typeSpecBuilder.addMethod(method2.build());
            typeSpecBuilder.addField(creatorField.build());
        }
    }

    public static class Builder {
        public static TypeSpec createBuilder(String pkgName, String newClazzName, HashMap<String, TypeName> fieldMap) {
            ClassName newClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName);
            ClassName builderClassName = PoetCodeUtil.createNewClazzType(pkgName, newClazzName, "Builder");
            TypeSpec.Builder typeSpecB = TypeSpec.classBuilder("Builder")
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC);
            for (String field : fieldMap.keySet()) {
                typeSpecB.addField(fieldMap.get(field), field, Modifier.PRIVATE)
                        .addMethod(PoetCodeUtil.createSetReturn(builderClassName, field, fieldMap.get(field), Modifier.PUBLIC));
            }
            MethodSpec.Builder methodSpecB = MethodSpec.methodBuilder("create")
                    .addModifiers(Modifier.PUBLIC)
                    .returns(newClassName)
                    .addStatement("$T outClazz = new $T()", newClassName, newClassName);
            for (String field : fieldMap.keySet()) {
                methodSpecB.addStatement("outClazz.$L = $L", field, field);
            }
            methodSpecB.addStatement("return outClazz");
            typeSpecB.addMethod(methodSpecB.build());
            return typeSpecB.build();
        }
    }

    public static class PcsBean {
        public static FieldSpec createPcsField() {
            FieldSpec.Builder pcsField = FieldSpec.builder(PropertyChangeSupport.class, "pcs")
                    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
                    .initializer("new $T(this)", PropertyChangeSupport.class);
            return pcsField.build();
        }

        public static MethodSpec createPcsSet(String fieldName, TypeName fieldType, Modifier... modifiers) {
            String methodName = "set" + upperFirstChar(fieldName);
            MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
                    .addModifiers(modifiers)
                    .addParameter(fieldType, fieldName)
                    .addStatement("$T old$L = this.$L",fieldType,fieldName,fieldName)
                    .addStatement("this.$L = $L", fieldName, fieldName)
                    .addStatement("this.pcs.firePropertyChange($S,old$L,$L)",fieldName,fieldName,fieldName);
            return method.build();
        }

        public static MethodSpec createAddListenerMethod() {
            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder("addPropertyChangeListener")
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(PropertyChangeListener.class,"listener")
                    .addStatement("this.pcs.addPropertyChangeListener(listener)");
            return pcsMethod.build();
        }

        public static MethodSpec createRemoveListenerMethod() {
            MethodSpec.Builder pcsMethod = MethodSpec.methodBuilder("removePropertyChangeListener")
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(PropertyChangeListener.class,"listener")
                    .addStatement("this.pcs.removePropertyChangeListener(listener)");
            return pcsMethod.build();
        }
    }
}
```


Overlapping Code:
```
lic class PoetCodeUtil {
/**
* @param targetClass
* @return field and field type
*/
public static HashMap<String, TypeName> createFieldMap(TypeElement targetClass) {
HashMap<String, TypeName> fieldMap = new HashMap<>();
for (Element encloseElement : targetClass.getEnclosedElements()) {
if (encloseElement.getKind() == ElementKind.FIELD) {
String fieldName = encloseElement.getSimpleName().toString();
TypeName fieldTypeName = TypeName.get(encloseElement.asType());
fieldMap.put(fieldName, fieldTypeName);
}
}
return fieldMap;
}
public static String createNewClazzName(TypeElement targetClass, String suffix) {
String originClazzName = targetClass.getSimpleName().toString();
return originClazzName + suffix;
}
public static ClassName createNewClazzType(String pkg, String newClazzName, String... clazzNames) {
return ClassName.get(pkg, newClazzName, clazzNames);
}
public static String getTargetPkgName(TypeElement targetClass, Elements elementUtils) {
PackageElement pkg = elementUtils.getPackageOf(targetClass);
return pkg.getQualifiedName().toString();
}
public static MethodSpec createConstructMethod(Modifier... modifiers) {
MethodSpec.Builder method = MethodSpec.constructorBuilder()
.addModifiers(modifiers);
return method.build();
}
public static MethodSpec createSetReturn(TypeName returnType, String fieldName, TypeName fieldType, Modifier... modifiers) {
String methodName = "set" + upperFirstChar(fieldName);
MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
.addModifiers(modifiers)
.returns(returnType)
.addParameter(fieldType, fieldName)
.addStatement("this.$L = $L", fieldName, fieldName)
.addStatement("return this");
return method.build();
}
public static MethodSpec createSet(String fieldName, TypeName fieldType, Modifier... modifiers) {
String methodName = "set" + upperFirstChar(fieldName);
MethodSpec.Builder method = MethodSpec.methodBuilder(methodName)
.addModifiers(modifiers)
.addParameter(fieldType, fieldName)
.addStatement("this.$L = $L", fieldName, fieldName);
return method.build();
}
public static MethodSpec
```
<Overlap Ratio: 0.9985436893203884>

---

--- 130 --
Question ID: 5b97ddb89ab8e0b0cf15f57d8403bebc64ef24cb
Original Code:
```
@Named
@ViewScoped
public class HelloBean implements Serializable {

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

	@Inject
	private TesteService service;

	@Inject
	private FacesContext context;

	private Map<String, String> mapaCursos;
	private Map<String, String> mapaLivros;

	public String testeInjectServico() {
		return service.getStringTeste();
	}

	public String testeInjectContexto() {
		return context.toString();
	}

	public Map<String, String> getMapaLivros() {
		mapaLivros = new HashMap<String, String>();
		mapaLivros.put("Livro 1", "Effective Java Third Edition");
		mapaLivros.put("Livro 2", "Google Android");
		mapaLivros.put("Livro 3", "Matering JPA");
		mapaLivros.put("Livro 4", "Pro Git");

		return mapaLivros;
	}

	public void setMapaLivros(Map<String, String> mapaLivros) {
		this.mapaLivros = mapaLivros;
	}

	public Map<String, String> getMapaCursos() {

		mapaCursos = new HashMap<String, String>();
		mapaCursos.put("Curso 1", "Orientação a objeto com Java");
		mapaCursos.put("Curso 2", "API Rest com Spring Boot");
		mapaCursos.put("Curso 3", "Java Web com JSF e Primefaces");
		mapaCursos.put("Curso 4", "Git passao a passo");

		return mapaCursos;
	}

	public void setMapaCursos(Map<String, String> mapaCursos) {
		this.mapaCursos = mapaCursos;
	}

}
```


Overlapping Code:
```
ped
public class HelloBean implements Serializable {
/**
*
*/
private static final long serialVersionUID = 1L;
@Inject
private TesteService service;
@Inject
private FacesContext context;
private Map<String, String> mapaCursos;
private Map<String, String> mapaLivros;
public String testeInjectServico() {
return service.getStringTeste();
}
public String testeInjectContexto() {
return context.toString();
}
public Map<String, String> getMapaLivros() {
mapaLivros = new HashMap<String, String>();
mapaLivros.put("Livro 1", "Effective Java Third Edition");
mapaLivros.put("Livro 2", "Google Android");
mapaLivros.put("Livro 3", "Matering JPA");
mapaLivros.put("Livro 4", "Pro Git");
return mapaLivros;
}
public void setMapaLivros(Map<String, String> mapaLivros) {
this.mapaLivros = mapaLivros;
}
public Map<String, String> getMapaCursos() {
mapaCursos = new HashMap<String, String>();
mapaCursos.put("Curso 1", "Orientação a objeto com Java");
mapaCursos.put("Curso 2", "API Rest com Spring Boot");
mapaCursos.put("Curso 3", "Java Web com JSF e Primefaces");
mapaCursos.put("Curso 4", "Git passao a passo");
return mapaCursos;
}
public void setMapaCursos(Map<String, String> mapaCu
```
<Overlap Ratio: 0.9546191247974068>

---

--- 131 --
Question ID: 7a4a6b07c56055191150f09ae37715a4257ccd8e
Original Code:
```
public class NettyServer {

    public static void main(String[] args) {
        NettyServer nettyServer = new NettyServer();
        nettyServer.bind(9999);
    }

    private void bind(int port) {
        //配置服务的nio线程组
        EventLoopGroup group = new NioEventLoopGroup();


        try {
            Bootstrap b = new Bootstrap();
            b.group(group)
                    .channel(NioDatagramChannel.class)
                    .option(ChannelOption.SO_BROADCAST, true) //广播
                    .option(ChannelOption.SO_RCVBUF, 2048 * 1024)  // 设置UDP读缓冲区为2M
                    .option(ChannelOption.SO_SNDBUF, 1024 * 1024)  // 设置UDP写缓冲区为1M
                    .handler(new MyChannelInitializer());
            ChannelFuture f = b.bind(port).sync();
            System.out.println("服务端启动");
            f.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            group.shutdownGracefully();
        }

    }
}
```


Overlapping Code:
```
public class NettyServer {
public static void main(String[] args) {
NettyServer nettyServer = new NettyServer();
nettyServer.bind(9999);
}
private void bind(int port) {
//配置服务的nio线程组
EventLoopGroup group = new NioEventLoopGroup();
try {
Bootstrap b = new Bootstrap();
b.group(group)
.channel(NioDatagramChannel.class)
.option(ChannelOption.SO_BROADCAST, true) //广播
.option(ChannelOption.SO_RCVBUF, 2048 * 1024) // 设置UDP读缓冲区为2M
.option(ChannelOption.SO_SNDBUF, 1024 * 1024) // 设置UDP写缓冲区为1M
.handler(new MyChannelInitializer());
ChannelFuture f = b.bind(port).sync();
System.out.println("服务端启动");
f.channel().closeFuture().sync();
} catch (InterruptedException e) {
e.printStackTrace();
} finally {
group.shutdownGracefully();
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 132 --
Question ID: aaa23ecc9abcacf254e5ba09df157d118aa7a1fa
Original Code:
```
public class ListHelper {
    public static final Random rand = new Random();

    public static <T> T getRandomFromList(List<T> list) {
        return getRandomFromList(list, rand);
    }

    public static <T> T getRandomFromList(List<T> list, Random rand) {
        final int size = list.size();
        Preconditions.checkArgument(size > 0, "Can't select from empty list");
        if (size == 0) return null;
        if (size == 1) return list.get(0);
        int randomIndex = rand.nextInt(list.size());
        return list.get(randomIndex);
    }
}
```


Overlapping Code:
```
r {
public static final Random rand = new Random();
public static <T> T getRandomFromList(List<T> list) {
return getRandomFromList(list, rand);
}
public static <T> T getRandomFromList(List<T> list, Random rand) {
final int size = list.size();
Preconditions.checkArgument(size > 0, "Can't select from empty list");
if (size == 0) return null;
if (size == 1) return list.get(0);
int randomIndex = rand.nextInt(list.size());
return list.get(randomIndex);
}
```
<Overlap Ratio: 0.949685534591195>

---

--- 133 --
Question ID: e45eacab543132c7d40e95586c6e44a5339e0793
Original Code:
```
public class P1500 implements PA {

  private FastScanner scanner;

  @Override
  public void reset() {
    scanner = new FastScanner(System.in);
  }

  @Override
  public void trivialSolution() {
    reset();
    int testCaseCount = scanner.nextInt();
    while (testCaseCount-- > 0) {
      trivialProcessTestCase(scanner.nextInt(), scanner.nextInt());
    }
  }
  
  private void trivialProcessTestCase(int numberCount, int commandCount) {
    long[] numbers = new long[numberCount + 1];
    int p;
    int q;
    int v;
    while (commandCount-- > 0) {
      if (scanner.nextInt() == 0) {
        p = scanner.nextInt();
        q = scanner.nextInt();
        v = scanner.nextInt();
        for (int i = p; i <= q; i++) {
          numbers[i] += v;
        }
      } else {
        p = scanner.nextInt();
        q = scanner.nextInt();
        long sum = 0;
        for (int i = p; i <= q; i++) {
          sum += numbers[i];
        }
        System.out.println(sum);
      }
    }
  }

  @Override
  public void finalSolution() {
    reset();
    int testCaseCount = scanner.nextInt();
    while (testCaseCount-- > 0) {
      finalProcessTestCase(scanner.nextInt(), scanner.nextInt());
    }
  }

  private void finalProcessTestCase(int numberCount, int commandCount) {
    SegmentTree segmentTree = new SegmentTree(numberCount);
    while (commandCount-- > 0) {
      if (scanner.nextInt() == 0) {
        segmentTree.update(scanner.nextInt() - 1, scanner.nextInt() - 1, scanner.nextInt());
      } else {
        System.out.println(segmentTree.sum(scanner.nextInt() - 1, scanner.nextInt() - 1));
      }
    }
  }

  private static class SegmentTree {

    final int numberCount;

    final int treeSize;

    final int firstLeaf;

    final long[] tree;

    long[] lazy;

    SegmentTree(int numberCount) {
      this.numberCount = numberCount;
      this.treeSize = computeMaxTreeSize(numberCount);
      this.firstLeaf = treeSize / 2;
      this.tree = new long[this.treeSize];
      this.lazy = new long[this.treeSize];
    }

    int computeMaxTreeSize(int n) {
      int leafCount = 1;
      while (n > leafCount) {
        leafCount <<= 1;
      }
      return (2 * leafCount) - 1;
    }

    void update(int from, int to, int value) {
      Stack<Node> nodes = new Stack<>();
      nodes.push(new Node(0, 0, numberCount - 1));
      while (!nodes.isEmpty()) {
        Node node = nodes.pop();

        // Handle current node pending update
        long pendingUpdate = lazy[node.index];
        if (pendingUpdate > 0) {
          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;
          lazy[node.index] = 0;
          if (node.index < firstLeaf) {
            lazy[left(node.index)] += pendingUpdate;
            lazy[right(node.index)] += pendingUpdate;
          }
        }

        // Ignore node if out of range
        if (node.to < from || node.from > to) {
          continue;
        }

        if (node.from >= from && node.to <= to) {
          // Handle current node update if it lies completely in update range
          tree[node.index] += ((long) (node.to - node.from + 1) * value);
          if (node.index < firstLeaf) {
            lazy[left(node.index)] += value;
            lazy[right(node.index)] += value;
          }
        } else {
          // Handle current node update if it overlaps with update range
          tree[node.index] += (long) (Math.min(node.to, to) - Math.max(node.from, from) + 1) * value;
          nodes.push(right(node));
          nodes.push(left(node));
        }
      }
    }

    long sum(int from, int to) {
      long sum = 0;
      Stack<Node> nodes = new Stack<>();
      nodes.push(new Node(0, 0, numberCount - 1));
      while (!nodes.isEmpty()) {
        Node node = nodes.pop();

        // Handle current node pending update
        long pendingUpdate = lazy[node.index];
        if (pendingUpdate > 0) {
          tree[node.index] += (node.to - node.from + 1) * pendingUpdate;
          lazy[node.index] = 0;

          // Postpone children updates
          if (node.index < firstLeaf) {
            lazy[left(node.index)] += pendingUpdate;
            lazy[right(node.index)] += pendingUpdate;
          }
        }

        // Ignore node if out of range
        if (node.to < from || node.from > to) {
          continue;
        }

        if (node.from >= from && node.to <= to) {
          sum += tree[node.index];
        } else if (node.to >= from || node.from <= to) {
          nodes.push(right(node));
          nodes.push(left(node));
        }
      }
      return sum;
    }

    int middle(int from, int to) {
      return from + (to - from) / 2;
    }

    int left(int i) {
      return (i << 1) + 1;
    }

    int right(int i) {
      return (i << 1) + 2;
    }

    Node left(Node node) {
      int left = left(node.index);
      if (left >= treeSize) {
        return null;
      }
      return new Node(left(node.index), node.from, middle(node.from, node.to));
    }

    Node right(Node node) {
      int right = right(node.index);
      if (right >= treeSize) {
        return null;
      }
      return new Node(right(node.index), middle(node.from, node.to) + 1, node.to);
    }
  }

  private static class Node {

    final int index;

    final int from;

    final int to;

    Node(int index, int from, int to) {
      this.index = index;
      this.from = from;
      this.to = to;
    }

    @Override
    public String toString() {
      return "Node{" + "index=" + index + ", from=" + from + ", to=" + to + '}';
    }
  }
}
```


Overlapping Code:
```
PA {
private FastScanner scanner;
@Override
public void reset() {
scanner = new FastScanner(System.in);
}
@Override
public void trivialSolution() {
reset();
int testCaseCount = scanner.nextInt();
while (testCaseCount-- > 0) {
trivialProcessTestCase(scanner.nextInt(), scanner.nextInt());
}
}

private void trivialProcessTestCase(int numberCount, int commandCount) {
long[] numbers = new long[numberCount + 1];
int p;
int q;
int v;
while (commandCount-- > 0) {
if (scanner.nextInt() == 0) {
p = scanner.nextInt();
q = scanner.nextInt();
v = scanner.nextInt();
for (int i = p; i <= q; i++) {
numbers[i] += v;
}
} else {
p = scanner.nextInt();
q = scanner.nextInt();
long sum = 0;
for (int i = p; i <= q; i++) {
sum += numbers[i];
}
System.out.println(sum);
}
}
}
@Override
public void finalSolution() {
reset();
int testCaseCount = scanner.nextInt();
while (testCaseCount-- > 0) {
finalProcessTestCase(scanner.nextInt(), scanner.nextInt());
}
}
private void finalProcessTestCase(int numberCount, int commandCount) {
SegmentTree segmentTree = new SegmentTree(numberCount);
while (commandCount-- > 0) {
if (scanner.nextInt() == 0) {
segmentTree.update(scanner.nextInt() - 1, scanner.nextInt() - 1, scanner.nextInt());
} else {
System.out.println(segmentTree.sum(scanner.nextInt() - 1, scanner.nextInt() - 1));
}
}
}
private static class SegmentTree {
final int numberCount;
final int treeSize;
final int firstLeaf;
final long[] tree;
long[] lazy;
SegmentTree(int numberCount) {
this.numberCount = numberCount;
this.treeSize = computeMaxTreeSize(numberCount);
this.firstLeaf = treeSize / 2;
this.tree = new long[this.treeSize];
this.lazy = new long[this.treeSize];
}
int computeMaxTreeSize(int n) {
int leafCount = 1;
while (n > leafCount) {
leafCount <<= 1;
}
return (2 * leafCount) - 1;
}
void update(int from, int to, int value) {
Stack<Node> nodes = new Stack<>();
nodes.push(new Node(0, 0, numberCount - 1));
while (!nodes.isEmpty()) {
Node node = nodes.pop();
// Handle current node pending update
long pendingUpd
```
<Overlap Ratio: 0.9757751937984496>

---

--- 134 --
Question ID: 0da3c430cadcb83ec8c41116b7dcb920cd7f580c
Original Code:
```
public class Codec {
	/**
	 * All possible chars for representing a number as a String
	 */
	private static final char[] DIGIT_ALL = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".toCharArray();
	private static final char[] DIGITS    = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
	private static final String ASCII_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	private static final String ENCODING = "ISO-8859-1";

	/**
	 * @param text , text in plain format
	 * @param algorithm   MD5 OR SHA1
	 * @return hash in algorithm
	 */
	private static String getHash(String text, String algorithm) {
		return encodeString(digest(text, algorithm));
	}

	public static byte[] digest(String text, String algorithm) {
		try {
			MessageDigest md = MessageDigest.getInstance(algorithm);
			return md.digest(text.getBytes());
		} catch (NoSuchAlgorithmException ex) {
			throw new RuntimeException(ex.getMessage(), ex);
		}
	}

	public static String md5(String txt) {
		return getHash(txt, "MD5");
	}

	public static String sha1(String txt) {
		return getHash(txt, "SHA1");
	}

	public static final String encodeHex(byte bytes[]) {
		StringBuffer sb = new StringBuffer();
		for (int i = 0; i < bytes.length; ++i) {
			sb.append(Integer.toHexString((bytes[i] & 0xFF) | 0x100).substring(1, 3));
		}
		return sb.toString();
	}

	public static final byte[] decodeHex(String hex) {
		char chars[] = hex.toCharArray();
		byte bytes[] = new byte[chars.length / 2];
		int byteCount = 0;
		for (int i = 0; i < chars.length; i += 2) {
			int newByte = 0;
			newByte |= hexCharToByte(chars[i]);
			newByte <<= 4;
			newByte |= hexCharToByte(chars[i + 1]);
			bytes[byteCount] = (byte) newByte;
			byteCount++;
		}
		return bytes;
	}

	public static String encodeBase64(String data) {
		byte bytes[] = null;
		try {
			bytes = data.getBytes(ENCODING);
			return encodeBase64(bytes);
		} catch (UnsupportedEncodingException uee) {
			return null;
		}
	}

	public static String encodeBase64(byte data[]) {
		int len = data.length;
		StringBuffer ret = new StringBuffer((len / 3 + 1) * 4);
		for (int i = 0; i < len; i++) {
			int c = data[i] >> 2 & 0x3f;
			ret.append(ASCII_LETTERS.charAt(c));
			c = data[i] << 4 & 0x3f;
			if (++i < len)
				c |= data[i] >> 4 & 0xf;
			ret.append(ASCII_LETTERS.charAt(c));
			if (i < len) {
				c = data[i] << 2 & 0x3f;
				if (++i < len)
					c |= data[i] >> 6 & 3;
				ret.append(ASCII_LETTERS.charAt(c));
			} else {
				i++;
				ret.append('=');
			}
			if (i < len) {
				c = data[i] & 0x3f;
				ret.append(ASCII_LETTERS.charAt(c));
			} else {
				ret.append('=');
			}
		}

		return ret.toString();
	}

	public static String decodeBase64(String data) {
		byte bytes[] = null;
		try {
			bytes = data.getBytes(ENCODING);
			return decodeBase64(bytes);
		} catch (UnsupportedEncodingException uee) {
			return null;
		}
	}

	public static String decodeBase64(byte data[]) {
		int len = data.length;
		StringBuffer ret = new StringBuffer((len * 3) / 4);
		for (int i = 0; i < len; i++) {
			int c = ASCII_LETTERS.indexOf(data[i]);
			i++;
			int c1 = ASCII_LETTERS.indexOf(data[i]);
			c = c << 2 | c1 >> 4 & 3;
			ret.append((char) c);
			if (++i < len) {
				c = data[i];
				if (61 == c)
					break;
				c = ASCII_LETTERS.indexOf(c);
				c1 = c1 << 4 & 0xf0 | c >> 2 & 0xf;
				ret.append((char) c1);
			}
			if (++i >= len)
				continue;
			c1 = data[i];
			if (61 == c1)
				break;
			c1 = ASCII_LETTERS.indexOf(c1);
			c = c << 6 & 0xc0 | c1;
			ret.append((char) c);
		}

		return ret.toString();
	}

	public static String encodeString(byte[] data) {
		return encodeString(data, 0);
	}

	public static byte[] decodeString(String data) {
		return decodeString(data, 0);
	}

	public static String encodeString(byte[] data, int index) {
		return toBigIntegerString(new BigInteger(attachOddEven(data)), getDigits(DIGIT_ALL, index));
	}

	public static byte[] decodeString(String data, int index) {
		return verifyOddEven(toBigInteger(data, getDigits(DIGIT_ALL, index)).toByteArray());
	}

	public static String encodeString(byte[] data, char[] digits) {
		return toBigIntegerString(new BigInteger(attachOddEven(data)), digits);
	}

	public static byte[] decodeString(String data, char[] digits) {
		return verifyOddEven(toBigInteger(data, digits).toByteArray());
	}

	public static String encodeNumbers(int[] data) {
		int[] value = new int[data.length + 1];
		value[0] = data.length;
		System.arraycopy(data, 0, value, 1, data.length);
		ByteBuffer byteBuffer = ByteBuffer.allocate(value.length * 4);
        IntBuffer intBuffer = byteBuffer.asIntBuffer();
        intBuffer.put(value);
        byte[] bytes = byteBuffer.array();
		return encodeString(bytes, 0);
	}

	public static int[] decodeNumbers(String data) {
		byte[] bytes = decodeString(data, 0);
		byte[] buf = new byte[4];
		System.arraycopy(bytes, 0, buf, 0, buf.length);
		int size = ByteBuffer.wrap(buf).getInt();
		int[] values = new int[size];
		for(int i=0; i<values.length; i++) {
			System.arraycopy(bytes, (i+1)*4, buf, 0, buf.length);
			values[i] = ByteBuffer.wrap(buf).getInt();
		}
		return values;
	}

	private static byte[] attachOddEven(byte[] value) {
		// Add 1 byte odd even data on header
		byte[] odd = new byte[] {(byte)(value.length%2+1)};
		byte[] data = new byte[value.length + 1];
		System.arraycopy(odd, 0, data, 0, odd.length);
		System.arraycopy(value, 0, data, odd.length, value.length);
		return data;
	}

	private static byte[] verifyOddEven(byte[] data) {
		//Cut 1 byte odd even data.
		int odd = (int)(((data.length - 1)%2) + 1);
		if((int)data[0] != odd) {
			throw new IllegalArgumentException("Odd-even error.");
		}
		byte[] value = new byte[data.length-1];
		System.arraycopy(data, 1, value, 0, value.length);
		return value;
	}

	private  static String toBigIntegerString(BigInteger big, char[] digits) {
		int radix = digits.length;
		StringBuffer sb = new StringBuffer();
		if (big.signum() == -1) {
			sb.append('-');
		}
		BigInteger i = new BigInteger(big.abs().toByteArray());
		BigInteger r = new BigInteger(Integer.toString(radix));
		do {
			BigInteger dr[] = i.divideAndRemainder(r);
			sb.insert(0, digits[dr[1].intValue()]);
			i = dr[0];
		} while (!i.equals(BigInteger.ZERO));
		return sb.toString();
	}

	private static BigInteger toBigInteger(String value, char[] digits)
	{
		int radix = digits.length;
		int signum = 1;
		BigInteger big = new BigInteger(BigInteger.ZERO.toByteArray());
		BigInteger r = new BigInteger(Integer.toString(radix));
		char buf[] = value.toCharArray();
		if (buf[buf.length - 1] == '-') {
			signum = -1;
			char temp[] = new char[buf.length - 1];
			System.arraycopy(buf, 0, temp, 0, buf.length - 1);
			buf = temp;
		}
		for (int i = buf.length - 1; i >= 0; i--) {
			int num = binarySearch(digits, buf[i]);
			BigInteger v = new BigInteger(Integer.toString(num));
			big = big.add(v.multiply(r.pow(buf.length - 1 - i)));
		}
		if (signum == -1)
			return big.negate();
		else
			return big;
	}

	static int binarySearch(char[] array, char key) {
		int i= 0;
		for(char c : array) {
			if(key == c) {
				return i;
			} else {
				i++;
			}
		}
		return -1;
	}

	private static int[] getIntegerArray(int num, int index)
    {
    	if(num < index) {
    		throw new IllegalArgumentException(index + " > " + num );
    	}
		int[] array = new int[num];
		for(int i=0; i<index; i++) {
			array[i] = num - index + i;
		}
		for(int i=index; i<num; i++) {
			array[i] = i-index;
		}
        return array;
    }

    static char[] getDigits(char[] objs, int index)
    {
		int num = objs.length;
		int[] r = getIntegerArray(num, index);
		char[] ret   = new char[num];
		for(int i=0; i<num; i++) {
			ret[i] = objs[ r[i] ];
		}
        return ret;
	}

    static char[] getDigits(int index) {
    	return getDigits(DIGITS, index);
	}

	private static final byte hexCharToByte(char ch) {
		switch (ch) {
		case 48: // '0'
			return 0;

		case 49: // '1'
			return 1;

		case 50: // '2'
			return 2;

		case 51: // '3'
			return 3;

		case 52: // '4'
			return 4;

		case 53: // '5'
			return 5;

		case 54: // '6'
			return 6;

		case 55: // '7'
			return 7;

		case 56: // '8'
			return 8;

		case 57: // '9'
			return 9;

		case 97: // 'a'
			return 10;

		case 98: // 'b'
			return 11;

		case 99: // 'c'
			return 12;

		case 100: // 'd'
			return 13;

		case 101: // 'e'
			return 14;

		case 102: // 'f'
			return 15;

		case 58: // ':'
		case 59: // ';'
		case 60: // '<'
		case 61: // '='
		case 62: // '>'
		case 63: // '?'
		case 64: // '@'
		case 65: // 'A'
		case 66: // 'B'
		case 67: // 'C'
		case 68: // 'D'
		case 69: // 'E'
		case 70: // 'F'
		case 71: // 'G'
		case 72: // 'H'
		case 73: // 'I'
		case 74: // 'J'
		case 75: // 'K'
		case 76: // 'L'
		case 77: // 'M'
		case 78: // 'N'
		case 79: // 'O'
		case 80: // 'P'
		case 81: // 'Q'
		case 82: // 'R'
		case 83: // 'S'
		case 84: // 'T'
		case 85: // 'U'
		case 86: // 'V'
		case 87: // 'W'
		case 88: // 'X'
		case 89: // 'Y'
		case 90: // 'Z'
		case 91: // '['
		case 92: // '\\'
		case 93: // ']'
		case 94: // '^'
		case 95: // '_'
		case 96: // '`'
		default:
			return 0;
		}
	}

    ///////////////////////////////////////////////////
    static protected Random random;
    static
    {
		Calendar now = Calendar.getInstance();
		long seed = now.getTime().getTime();
        random = new Random( seed );
    }

    public static int getRandom(int min, int max) {
		int tmin, tmax;
		if(max<min) {
			tmin = max;
			tmax = min;
		} else {
			tmin = min;
			tmax = max;
		}
		if(max==min)
			return max;
        int ret = random.nextInt(tmax-tmin+1);
        return tmin + ret;
    }

    public static int[] getRandomArray(int n) {
		int[] array = new int[n];
		for(int i=0; i<n; i++)
		{
			array[i] =i;
		}
		for(int i=0; i<n; i++)
		{
			int r = getRandom(i, (n-1));
			int tmp = array[i];
			array[i] = array[r];
			array[r] = tmp;
		}
        return array;
    }

    public static int[] getRandomArrayArray(int n, int num) {
		int[] array = getRandomArray(n);
		int[] ret   = new int[num];
		for(int i=0; i<num; i++)
		{
			if(i < n)
			{
				ret[i] = array[i];
			} else
			{
				int r = getRandom(0, n-1);
				ret[i] = array[r];
			}
		}
        return ret;
    }

    public static <T> T[] getRandomArray(Class<T> type, T[] objs) {
		int n = objs.length;
		if(n <= 1)
			return objs;
		int[] r = getRandomArray(n);
		for(int i=0; i<n; i++) {
			T obj = objs[i];
			objs[i] = objs[ r[i] ];
			objs[ r[i] ] = obj;
		}
        return objs;
	}
/*
    public static <T> T[] getRandomArray(Class<T> type, T[] objs, int num) {
		int n = objs.length;
		if(n <= 1)
			return objs;
		//int[] r = getIntegerArray(n, num);
		T[] array = getRandomArray(type, objs);
		T[] ret   = new T[num];
		for(int i=0; i<num; i++) {
			ret[i] = array[ r[i] ];
		}
        return objs;
	}
*/
    /**
     *
     * @param format 9: Z: z: X: *:
     * @return
     */
    public static String getRandom(String format)
    {
        StringBuffer sb = new StringBuffer();
        int length = format.length();
        for(int i=0 ; i<length; i++ )
        {
			char f = format.charAt(i);
	        char ch;
	        if(f=='9') {
           		ch = getDigitChar();
			} else if(f=='X') {
           		ch = getASCIIChar();
			} else if(f=='Z') {
           		ch = Character.toUpperCase( getASCIIChar() );
			} else if(f=='z') {
           		ch = Character.toLowerCase( getASCIIChar() );
			} else if(f=='*') {
           		ch = getCodeChar();
			} else {
           		ch = f;
           	}
            sb.append(ch);
        }
        return sb.toString();
    }

    public static boolean getRandomBoolean()
    {
		boolean[] b = new boolean[] {true, false};
		int r = random.nextInt(2);
        return b[r];
    }

    static char getASCIIChar()
    {
		char[] chars = new char[] {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','1','2','3','4','5','6','7','8','9','0'};
		int r = random.nextInt(36);
		char ch;
		boolean b = getRandomBoolean();
		if(b) {
			ch = Character.toUpperCase(chars[r]);
		} else {
			ch = chars[r];
		}
        return ch;
    }

    static char getDigitChar()
    {
		int r = random.nextInt(10);
		char ch = String.valueOf(r).charAt(0);
        return ch;
    }

    static char getCodeChar()
    {
		char[] chars = new char[] {'!','\"','#','$','%','&','\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','[','\\',']','^','_','{','|','}','~',' '};
		int r = random.nextInt(31);
		char ch = chars[r];
        return ch;
    }
}
```


Overlapping Code:
```
ss Codec {
/**
* All possible chars for representing a number as a String
*/
private static final char[] DIGIT_ALL = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".toCharArray();
private static final char[] DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
private static final String ASCII_LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
private static final String ENCODING = "ISO-8859-1";
/**
* @param text , text in plain format
* @param algorithm MD5 OR SHA1
* @return hash in algorithm
*/
private static String getHash(String text, String algorithm) {
return encodeString(digest(text, algorithm));
}
public static byte[] digest(String text, String algorithm) {
try {
MessageDigest md = MessageDigest.getInstance(algorithm);
return md.digest(text.getBytes());
} catch (NoSuchAlgorithmException ex) {
throw new RuntimeException(ex.getMessage(), ex);
}
}
public static String md5(String txt) {
return getHash(txt, "MD5");
}
public static String sha1(String txt) {
return getHash(txt, "SHA1");
}
public static final String encodeHex(byte bytes[]) {
StringBuffer sb = new StringBuffer();
for (int i = 0; i < bytes.length; ++i) {
sb.append(Integer.toHexString((bytes[i] & 0xFF) | 0x100).substring(1, 3));
}
return sb.toString();
}
public static final byte[] decodeHex(String hex) {
char chars[] = hex.toCharArray();
byte bytes[] = new byte[chars.length / 2];
int byteCount = 0;
for (int i = 0; i < chars.length; i += 2) {
int newByte = 0;
newByte |= hexCharToByte(chars[i]);
newByte <<= 4;
newByte |= hexCharToByte(chars[i + 1]);
bytes[byteCount] = (byte) newByte;
byteCount++;
}
return bytes;
}
public static String encodeBase64(String data) {
byte bytes[] = null;
try {
bytes = data.getBytes(ENCODING);
return encodeBase64(bytes);
} catch (UnsupportedEncodingException uee) {
return null;
}
}
public static String encodeBase64(byte data[]) {
int len = data.length;
StringBuffer ret = new StringBuffer((len / 3 + 1) * 4);
for (int i = 0; i < len; i++) {
int c = data[i] >> 2 & 0x3f;
ret.append(ASCII_LETTERS.charAt(c));
c = data[i] << 4 & 0x3f;
if (++i < len)
c |= data[i] >> 4 & 0xf;
ret.append(ASCII_LETTERS.charAt(c));
if (i < len) {
c
```
<Overlap Ratio: 0.9769094138543517>

---

--- 135 --
Question ID: 26b168b2343b574ff632b2240231b1a8d0111d1b
Original Code:
```
public class UserDefinedTextWriter extends RecordWriter<UserDefinedDescriptiveText> {

    @Override
    public RecordType getRecordType() {
        return RecordType.RT2_USER_DEFINED_TEXT;
    }

    @Override
    public void write(OutputStream out, UserDefinedDescriptiveText record) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        Writer writer = new OutputStreamWriter(buffer, NistHelper.USASCII);

        String idc = String.format("%d.%03d:%d", RecordType.RT2_USER_DEFINED_TEXT.type, 2, record.getIdc());
        writer.write(idc);
        writer.write(NistHelper.SEP_GS);

        Map<Integer, String> userFields = record.getUserDefinedFields();
        int count = 1;
        for (Integer key : userFields.keySet()) {
            if (key == null || key < 3) {
                throw new IllegalArgumentException("User defined fields should be 2.003 and above");
            }
            String tag = String.format("%d.%03d:", RecordType.RT2_USER_DEFINED_TEXT.type, key);
            writer.write(tag);

            writer.write(userFields.get(key));

            if (count < userFields.size()) {
                writer.write(NistHelper.SEP_GS);
            }
            count++;
        }

        writer.flush();
        
        writeRecord(out, buffer);
    }

}
```


Overlapping Code:
```
public class UserDefinedTextWriter extends RecordWriter<UserDefinedDescriptiveText> {
@Override
public RecordType getRecordType() {
return RecordType.RT2_USER_DEFINED_TEXT;
}
@Override
public void write(OutputStream out, UserDefinedDescriptiveText record) throws IOException {
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
Writer writer = new OutputStreamWriter(buffer, NistHelper.USASCII);
String idc = String.format("%d.%03d:%d", RecordType.RT2_USER_DEFINED_TEXT.type, 2, record.getIdc());
writer.write(idc);
writer.write(NistHelper.SEP_GS);
Map<Integer, String> userFields = record.getUserDefinedFields();
int count = 1;
for (Integer key : userFields.keySet()) {
if (key == null || key < 3) {
throw new IllegalArgumentException("User defined fields should be 2.003 and above");
}
String tag = String.format("%d.%03d:", RecordType.RT2_USER_DEFINED_TEXT.type, key);
writer.write(tag);
writer.write(userFields.get(key));
if (count < userFields.size()) {
writer.write(NistHelper.SEP_GS);
}
count++;
}
writer.flush();

writeRecord(out, bu
```
<Overlap Ratio: 0.9905660377358491>

---

--- 136 --
Question ID: 828385e62ed47607e8cda42b1acdeb61773ad6b5
Original Code:
```
public class GetParam implements ParamSplit {
  /**
   * The Matrix id.
   */
  public final int matrixId;

  /**
   * Creates a new Get parameter.
   *
   * @param matrixId the matrix id
   */
  public GetParam(int matrixId) {
    this.matrixId = matrixId;
  }

  public GetParam() {
    this(-1);
  }

  /**
   * Gets matrix id.
   *
   * @return the matrix id
   */
  public int getMatrixId() {
    return matrixId;
  }

  @Override
  public List<PartitionGetParam> split() {
    List<PartitionKey> parts =
        PSAgentContext.get().getMatrixPartitionRouter().getPartitionKeyList(matrixId);
    int size = parts.size();

    List<PartitionGetParam> partParams = new ArrayList<PartitionGetParam>(size);

    for (int i = 0; i < size; i++) {
      partParams.add(new PartitionGetParam(matrixId, parts.get(i)));
    }

    return partParams;
  }
}
```


Overlapping Code:
```
aram implements ParamSplit {
/**
* The Matrix id.
*/
public final int matrixId;
/**
* Creates a new Get parameter.
*
* @param matrixId the matrix id
*/
public GetParam(int matrixId) {
this.matrixId = matrixId;
}
public GetParam() {
this(-1);
}
/**
* Gets matrix id.
*
* @return the matrix id
*/
public int getMatrixId() {
return matrixId;
}
@Override
public List<PartitionGetParam> split() {
List<PartitionKey> parts =
PSAgentContext.get().getMatrixPartitionRouter().getPartitionKeyList(matrixId);
int size = parts.size();
List<PartitionGetParam> partParams = new ArrayList<PartitionGetParam>(size);
for (int i = 0; i < size; i++) {
partParams.add(new PartitionGetParam(matrixId, parts.get(i)));
}
return partPa
```
<Overlap Ratio: 0.9647218453188603>

---

--- 137 --
Question ID: ddd1d15f6c3e27ca5b8859784df6a16d1c4a1cde
Original Code:
```
public class RotorCtlServiceTest {
    private Context testCtx;

    @Test
    public void hasCorrectStates() {
        assert (RotorCtlService.State.valueOf("MANUAL") != null);
        assert (RotorCtlService.State.valueOf("AUTONOMOUS") != null);
        assert (RotorCtlService.State.valueOf("HOMED") != null);
    }

    @Test
    public void transHomedToMan() {
        RotorCtlService rotorCtlService = new RotorCtlService(null);
        RotorCtlService.State initialState = rotorCtlService.getRotorState();
        assertEquals(initialState, RotorCtlService.State.HOMED);

        rotorCtlService.setState(RotorCtlService.State.MANUAL);
        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.MANUAL);
    }

    @Test
    public void transHomedToAuto() {
        RotorCtlService rotorCtlService = new RotorCtlService(null);
        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);

        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.AUTONOMOUS);
    }

    @Test(expected = IllegalArgumentException.class)
    public void transManToAuto() {
        RotorCtlService rotorCtlService = new RotorCtlService(null);
        rotorCtlService.setState(RotorCtlService.State.MANUAL);
        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
    }

    @Test(expected = IllegalArgumentException.class)
    public void transAutoToMan() {
        RotorCtlService rotorCtlService = new RotorCtlService(null);
        rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
        rotorCtlService.setState(RotorCtlService.State.MANUAL);
    }

    @Test
    public void verifyImmutable() {
        RotorCtlService rotorCtlService = new RotorCtlService(null);
        RotorCtlService.State initialState = rotorCtlService.getRotorState();
        initialState = RotorCtlService.State.AUTONOMOUS;
        assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);
    }
}
```


Overlapping Code:
```
ate Context testCtx;
@Test
public void hasCorrectStates() {
assert (RotorCtlService.State.valueOf("MANUAL") != null);
assert (RotorCtlService.State.valueOf("AUTONOMOUS") != null);
assert (RotorCtlService.State.valueOf("HOMED") != null);
}
@Test
public void transHomedToMan() {
RotorCtlService rotorCtlService = new RotorCtlService(null);
RotorCtlService.State initialState = rotorCtlService.getRotorState();
assertEquals(initialState, RotorCtlService.State.HOMED);
rotorCtlService.setState(RotorCtlService.State.MANUAL);
assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.MANUAL);
}
@Test
public void transHomedToAuto() {
RotorCtlService rotorCtlService = new RotorCtlService(null);
assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.HOMED);
rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
assertEquals(rotorCtlService.getRotorState(), RotorCtlService.State.AUTONOMOUS);
}
@Test(expected = IllegalArgumentException.class)
public void transManToAuto() {
RotorCtlService rotorCtlService = new RotorCtlService(null);
rotorCtlService.setState(RotorCtlService.State.MANUAL);
rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
}
@Test(expected = IllegalArgumentException.class)
public void transAutoToMan() {
RotorCtlService rotorCtlService = new RotorCtlService(null);
rotorCtlService.setState(RotorCtlService.State.AUTONOMOUS);
rotorCtlService.setState(RotorCtlService.State.MANUAL);
}
@Test
public void verifyImmutable() {
RotorCtlService rotorCtlService = new RotorCtlService(null);
RotorCtlService.State initialState = rotorCtlService.getRotorState();
initialState = RotorCtlService.State.AUTONOMOUS;
assertEquals(rotorCtlService.getRotorState(), RotorCtlService.St
```
<Overlap Ratio: 0.9695431472081218>

---

--- 138 --
Question ID: 17c6edbbc6087fc6a2ae572bf420ad84c0f27658
Original Code:
```
public class DefaultCredentialsProvider implements AlibabaCloudCredentialsProvider {
    private List<AlibabaCloudCredentialsProvider> defaultProviders = new ArrayList<AlibabaCloudCredentialsProvider>();
    private static final List<AlibabaCloudCredentialsProvider> USER_CONFIGURATION_PROVIDERS =
            new Vector<AlibabaCloudCredentialsProvider>();

    public DefaultCredentialsProvider() {
        defaultProviders.add(new SystemPropertiesCredentialsProvider());
        defaultProviders.add(new EnvironmentVariableCredentialsProvider());
        defaultProviders.add(new ProfileCredentialsProvider());
        String roleName = AuthUtils.getEnvironmentECSMetaData();
        if (roleName != null) {
            defaultProviders.add(new EcsRamRoleCredentialProvider(roleName));
        }
    }

    @Override
    public AlibabaCloudCredentials getCredentials() {
        AlibabaCloudCredentials credential;
        if (USER_CONFIGURATION_PROVIDERS.size() > 0) {
            for (AlibabaCloudCredentialsProvider provider : USER_CONFIGURATION_PROVIDERS) {
                credential = provider.getCredentials();
                if (null != credential) {
                    return credential;
                }
            }
        }
        for (AlibabaCloudCredentialsProvider provider : defaultProviders) {
            credential = provider.getCredentials();
            if (null != credential) {
                return credential;
            }
        }
        throw new CredentialException("not found credentials");
    }

    public static boolean addCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.add(provider);
    }

    public static boolean removeCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.remove(provider);
    }

    public static boolean containsCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
        return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.contains(provider);
    }

    public static void clearCredentialsProvider() {
        DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.clear();
    }
}
```


Overlapping Code:
```
public class DefaultCredentialsProvider implements AlibabaCloudCredentialsProvider {
private List<AlibabaCloudCredentialsProvider> defaultProviders = new ArrayList<AlibabaCloudCredentialsProvider>();
private static final List<AlibabaCloudCredentialsProvider> USER_CONFIGURATION_PROVIDERS =
new Vector<AlibabaCloudCredentialsProvider>();
public DefaultCredentialsProvider() {
defaultProviders.add(new SystemPropertiesCredentialsProvider());
defaultProviders.add(new EnvironmentVariableCredentialsProvider());
defaultProviders.add(new ProfileCredentialsProvider());
String roleName = AuthUtils.getEnvironmentECSMetaData();
if (roleName != null) {
defaultProviders.add(new EcsRamRoleCredentialProvider(roleName));
}
}
@Override
public AlibabaCloudCredentials getCredentials() {
AlibabaCloudCredentials credential;
if (USER_CONFIGURATION_PROVIDERS.size() > 0) {
for (AlibabaCloudCredentialsProvider provider : USER_CONFIGURATION_PROVIDERS) {
credential = provider.getCredentials();
if (null != credential) {
return credential;
}
}
}
for (AlibabaCloudCredentialsProvider provider : defaultProviders) {
credential = provider.getCredentials();
if (null != credential) {
return credential;
}
}
throw new CredentialException("not found credentials");
}
public static boolean addCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.add(provider);
}
public static boolean removeCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.remove(provider);
}
public static boolean containsCredentialsProvider(AlibabaCloudCredentialsProvider provider) {
return DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS.contains(provider);
}
public static void clearCredentialsProvider() {
DefaultCredentialsProvider.USER_CONFIGURATION_PROVIDERS
```
<Overlap Ratio: 0.9930961232076474>

---

--- 139 --
Question ID: f9165640edec4cd3855e4993c37ad1e68b971d7b
Original Code:
```
public class BlueprintsMap {
    private static BlueprintsMap instance;
    public final HashMap<String, Blueprint> blueprints;
    private Json json;

    private BlueprintsMap() {
        blueprints = new HashMap<>();
        json = new Json();
        json.setOutputType(JsonWriter.OutputType.json);
        loadBlueprints();
    }

    public static BlueprintsMap getInstance() {
        if (instance == null)
            instance = new BlueprintsMap();
        return instance;
    }

    private void loadBlueprints() {
        Logger.LOADING.log("blueprints");
        ArrayList<RawBlueprint> elements = json.fromJson(ArrayList.class, RawBlueprint.class, FileUtil.get(FileUtil.BLUEPRINTS_PATH));
        BlueprintProcessor processor = new BlueprintProcessor();
        for (RawBlueprint rawBlueprint : elements) {
            blueprints.put(rawBlueprint.name, processor.processRawBlueprint(rawBlueprint));
        }
        Logger.LOADING.log(blueprints.keySet().size() + " loaded from " + FileUtil.BLUEPRINTS_PATH);
    }

    public Blueprint getBlueprint(String name) {
        return blueprints.get(name);
    }
}
```


Overlapping Code:
```
class BlueprintsMap {
private static BlueprintsMap instance;
public final HashMap<String, Blueprint> blueprints;
private Json json;
private BlueprintsMap() {
blueprints = new HashMap<>();
json = new Json();
json.setOutputType(JsonWriter.OutputType.json);
loadBlueprints();
}
public static BlueprintsMap getInstance() {
if (instance == null)
instance = new BlueprintsMap();
return instance;
}
private void loadBlueprints() {
Logger.LOADING.log("blueprints");
ArrayList<RawBlueprint> elements = json.fromJson(ArrayList.class, RawBlueprint.class, FileUtil.get(FileUtil.BLUEPRINTS_PATH));
BlueprintProcessor processor = new BlueprintProcessor();
for (RawBlueprint rawBlueprint : elements) {
blueprints.put(rawBlueprint.name, processor.processRawBlueprint(rawBlueprint));
}
Logger.LOADING.log(blueprints.keySet().size() + " loaded from " + FileUtil.BLUEPRINTS_PATH);
}
public Blueprint getBlueprint(String
```
<Overlap Ratio: 0.9493670886075949>

---

--- 140 --
Question ID: 75dbbaf2513905b9ccb5a1e6708702fcb62ae9eb
Original Code:
```
public class MapObject implements Cloneable
{
    private Properties properties = new Properties();
    private ObjectGroup objectGroup;
    private Rectangle2D.Double bounds = new Rectangle2D.Double();
    private Shape shape = new Rectangle();
    private String name = "Object";
    private String type = "";
    private String imageSource = "";
    private Image image;
    private Image scaledImage;
    private Tile tile;

    public MapObject(double x, double y, double width, double height) {
        bounds = new Rectangle2D.Double(x, y, width, height);
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        MapObject clone = (MapObject) super.clone();
        clone.bounds = (Rectangle2D.Double) bounds.clone();
        clone.properties = (Properties) properties.clone();
        return clone;
    }

    /**
     * @return the object group this object is part of
     */
    public ObjectGroup getObjectGroup() {
        return objectGroup;
    }

    /**
     * Sets the object group this object is part of. Should only be called by
     * the object group.
     *
     * @param objectGroup the object group this object is part of
     */
    public void setObjectGroup(ObjectGroup objectGroup) {
        this.objectGroup = objectGroup;
    }

    public Rectangle2D.Double getBounds() {
        return bounds;
    }

    public void setBounds(Rectangle2D.Double bounds) {
        this.bounds = bounds;
    }

    public Shape getShape() {
        return shape;
    }

    public void setShape(Shape shape) {
        this.shape = shape;
    }

    public String getImageSource() {
        return imageSource;
    }

    public void setImageSource(String source) {
        if (imageSource.equals(source))
            return;

        imageSource = source;

        // Attempt to read the image
        if (imageSource.length() > 0) {
            try {
                image = ImageIO.read(new File(imageSource));
            } catch (IOException e) {
                image = null;
            }
        } else {
            image = null;
        }

        scaledImage = null;
    }

    public Tile getTile(){
        return tile;
    }

    public void setTile(Tile tile){
        this.tile = tile;
    }

    /**
     * Returns the image to be used when drawing this object. This image is
     * scaled to the size of the object.
     *
     * @param zoom the requested zoom level of the image
     * @return the image to be used when drawing this object
     */
    public Image getImage(double zoom) {
        if (image == null)
            return null;

        final int zoomedWidth = (int) (getWidth() * zoom);
        final int zoomedHeight = (int) (getHeight() * zoom);

        if (scaledImage == null || scaledImage.getWidth(null) != zoomedWidth
                || scaledImage.getHeight(null) != zoomedHeight)
        {
            scaledImage = image.getScaledInstance(zoomedWidth, zoomedHeight,
                    Image.SCALE_SMOOTH);
        }

        return scaledImage;
    }

    public double getX() {
        return bounds.x;
    }

    public void setX(double x) {
        bounds.x = x;
    }

    public double getY() {
        return bounds.y;
    }

    public void setY(double y) {
        bounds.y = y;
    }

    public void translate(double dx, double dy) {
        bounds.x += dx;
        bounds.y += dy;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public double getWidth() {
        return bounds.width;
    }

    public void setWidth(double width) {
        bounds.width = width;
    }

    public void setHeight(double height) {
        bounds.height = height;
    }

    public double getHeight() {
        return bounds.height;
    }

    public Properties getProperties() {
        return properties;
    }

    public void setProperties(Properties p) {
        properties = p;
    }

    @Override
    public String toString() {
        return type + " (" + getX() + "," + getY() + ")";
    }
}
```


Overlapping Code:
```
MapObject implements Cloneable
{
private Properties properties = new Properties();
private ObjectGroup objectGroup;
private Rectangle2D.Double bounds = new Rectangle2D.Double();
private Shape shape = new Rectangle();
private String name = "Object";
private String type = "";
private String imageSource = "";
private Image image;
private Image scaledImage;
private Tile tile;
public MapObject(double x, double y, double width, double height) {
bounds = new Rectangle2D.Double(x, y, width, height);
}
@Override
public Object clone() throws CloneNotSupportedException {
MapObject clone = (MapObject) super.clone();
clone.bounds = (Rectangle2D.Double) bounds.clone();
clone.properties = (Properties) properties.clone();
return clone;
}
/**
* @return the object group this object is part of
*/
public ObjectGroup getObjectGroup() {
return objectGroup;
}
/**
* Sets the object group this object is part of. Should only be called by
* the object group.
*
* @param objectGroup the object group this object is part of
*/
public void setObjectGroup(ObjectGroup objectGroup) {
this.objectGroup = objectGroup;
}
public Rectangle2D.Double getBounds() {
return bounds;
}
public void setBounds(Rectangle2D.Double bounds) {
this.bounds = bounds;
}
public Shape getShape() {
return shape;
}
public void setShape(Shape shape) {
this.shape = shape;
}
public String getImageSource() {
return imageSource;
}
public void setImageSource(String source) {
if (imageSource.equals(source))
return;
imageSource = source;
// Attempt to read the image
if (imageSource.length() > 0) {
try {
image = ImageIO.read(new File(imageSource));
} catch (IOException e) {
image = null;
}
} else {
image = null;
}
scaledImage = null;
}
public Tile getTile(){
return tile;
}
public void setTile(Tile tile){
this.tile = tile;
}
/**
* Returns the image to be used when drawing this object. This image is
* scaled to the size of the object.
*
* @param zoom the requested zoom level of the image
* @return the image to be used when draw
```
<Overlap Ratio: 0.9895522388059701>

---

--- 141 --
Question ID: babb512fdaf5f1f2c15a5a8b4cf2fd2069aa0fe1
Original Code:
```
public class AllCapitals {
    public static void main(String[] args) {
        String inputPathString = "/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/input.txt";
        String outputPathString = "/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/output.txt";

        Path inputPath = Paths.get(inputPathString);
        Path outputPath = Paths.get(outputPathString);

        try (BufferedReader reader = Files.newBufferedReader(inputPath);
             BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
            String line = reader.readLine();

            while (line != null) {
                writer.write(String.format("%s%n", line.toUpperCase()));
                line = reader.readLine();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
```


Overlapping Code:
```
ic class AllCapitals {
public static void main(String[] args) {
String inputPathString = "/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/input.txt";
String outputPathString = "/home/stoianov/home/Java Advanced/04.Files and Directories/04. Java-Advanced-Files-and-Streams-Exercises-Resources/output.txt";
Path inputPath = Paths.get(inputPathString);
Path outputPath = Paths.get(outputPathString);
try (BufferedReader reader = Files.newBufferedReader(inputPath);
BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
String line = reader.readLine();
while (line != null) {
writer.write(String.format("%s%n", line.toUpperCase()));
line = reader.readLine();
}
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
<Overlap Ratio: 0.9949302915082383>

---

--- 142 --
Question ID: 5f7a618a8e16cdac37543c338859de1a98fbe8b1
Original Code:
```
final class DisplayManager {

  private final Model model;
  private final int boardWidth;
  private final int boardHeight;

  /**
   * Constructor for the display manager
   *
   * @param model       the model (board) of the level
   * @param boardWidth  the width of the board
   * @param boardHeight the height of the board
   */
  DisplayManager(Model model, int boardWidth, int boardHeight) {
    Objects.requireNonNull(model);
    if (boardWidth <= 0 || boardHeight <= 0) {
      throw new IllegalArgumentException("boardWidth <= 0 || boardHeight <= 0");
    }
    this.model = model;
    this.boardWidth = boardWidth;
    this.boardHeight = boardHeight;
  }

  private void drawBoard(Graphics2D graphics, int startX , int startY, int squareSize) {
    Objects.requireNonNull(graphics);
    graphics.setColor(Color.GRAY);
    var width = boardWidth * squareSize;
    var height = boardHeight * squareSize;
    for (int i = 0; i <= boardHeight; i++) {
      graphics.fill(new Rectangle2D.Float(startX, i * squareSize, width, 1));
    }
    for (int j = 0; j <= boardWidth; j++) {
      graphics.fill(new Rectangle2D.Float(j * squareSize, startY, 1, height));
    }
  }

  private void drawElements(Graphics2D graphics, List<Displayable> elements, int x, int y, int squareSize) {
    for (var element : elements) {
      graphics.drawImage(element.image().getImage(),
          x + (element.x() * squareSize) + 1, y + (element.y() * squareSize) + 1,
          squareSize - 1, squareSize - 1, null);
    }
  }

  /**
   * Renders and displays a frame
   *
   * @param graphics the graphic engine zone
   * @param x        the x coordinate of the top left corner
   * @param y        the y coordinate of the top left corner
   * @param width    the width of the viewport
   * @param height   the height of the viewport
   */
  void display(Graphics2D graphics, int x, int y, int width, int height) {
    Objects.requireNonNull(graphics);
    if (width < 0 || height < 0) {
      throw new IllegalArgumentException("width < 0 || height < 0");
    }
    var squareSize = Math.min(width / boardWidth, height / boardHeight);
    drawBoard(graphics, x, y, squareSize);
    drawElements(graphics, model.displayableElements(), x, y, squareSize);
  }
}
```


Overlapping Code:
```
isplayManager {
private final Model model;
private final int boardWidth;
private final int boardHeight;
/**
* Constructor for the display manager
*
* @param model the model (board) of the level
* @param boardWidth the width of the board
* @param boardHeight the height of the board
*/
DisplayManager(Model model, int boardWidth, int boardHeight) {
Objects.requireNonNull(model);
if (boardWidth <= 0 || boardHeight <= 0) {
throw new IllegalArgumentException("boardWidth <= 0 || boardHeight <= 0");
}
this.model = model;
this.boardWidth = boardWidth;
this.boardHeight = boardHeight;
}
private void drawBoard(Graphics2D graphics, int startX , int startY, int squareSize) {
Objects.requireNonNull(graphics);
graphics.setColor(Color.GRAY);
var width = boardWidth * squareSize;
var height = boardHeight * squareSize;
for (int i = 0; i <= boardHeight; i++) {
graphics.fill(new Rectangle2D.Float(startX, i * squareSize, width, 1));
}
for (int j = 0; j <= boardWidth; j++) {
graphics.fill(new Rectangle2D.Float(j * squareSize, startY, 1, height));
}
}
private void drawElements(Graphics2D graphics, List<Displayable> elements, int x, int y, int squareSize) {
for (var element : elements) {
graphics.drawImage(element.image().getImage(),
x + (element.x() * squareSize) + 1, y + (element.y() * squareSize) + 1,
squareSize - 1, squareSize - 1, null);
}
}
/**
* Renders and displays a frame
*
* @param graphics the graphic engine zone
* @param x the x coordinate of the top left corner
* @param y the y coordinate of the top left corner
* @param width the width of the viewport
* @param height the height of the viewport
*/
void display(Graphics2D graphics, int x, int y, int width, int height) {
Objects.requireNonNull(graphics);
if (width < 0 || height < 0) {
throw new IllegalArgumentException("width < 0 || height < 0");
}
var squareSize = Math.min(width / boardWidth, height / boardHeight);
drawBoard(graphics, x, y, squareSize);
drawElements(graphics, model
```
<Overlap Ratio: 0.9706321553011449>

---

--- 143 --
Question ID: 3322c7ca293d1884e176aaafe5ce71a642c17d17
Original Code:
```
public class EqualTest {
	
	private Equal equal; 
	
	@Before
	public void init() {
		equal = new Equal(TestUtils.createElementsExtract());
	}
	
	@Test
	public void testInvalidWhere() {
		boolean valid = equal.isValid("");
		assertFalse(valid);
	}
	
	@Test
	public void testValidWhere() {
		boolean valid = equal.isValid("test.test=1");
		assertTrue(valid);
	}
	
	@Test
	public void testValidPredicateNumeric() {
		Predicate<String> predicate = equal.generate("test.test=1");
		assertNotNull(predicate);
		
		List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});
		
		List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());
	
		assertEquals(2, filteredObjects.size());
	}
	
	@Test
	public void testValidPredicateString() {
		Predicate<String> predicate = equal.generate("test.test='1'");
		assertNotNull(predicate);
		
		List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});
		
		List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());
	
		assertEquals(2, filteredObjects.size());
	}
	
	@Test
	public void testValidPredicateField() {
		Predicate<String> predicate = equal.generate("test.test=test.test");
		assertNotNull(predicate);
		
		List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});
		
		List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());
	
		assertEquals(2, filteredObjects.size());
	}
}
```


Overlapping Code:
```
ualTest {

private Equal equal; 

@Before
public void init() {
equal = new Equal(TestUtils.createElementsExtract());
}

@Test
public void testInvalidWhere() {
boolean valid = equal.isValid("");
assertFalse(valid);
}

@Test
public void testValidWhere() {
boolean valid = equal.isValid("test.test=1");
assertTrue(valid);
}

@Test
public void testValidPredicateNumeric() {
Predicate<String> predicate = equal.generate("test.test=1");
assertNotNull(predicate);

List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});

List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());

assertEquals(2, filteredObjects.size());
}

@Test
public void testValidPredicateString() {
Predicate<String> predicate = equal.generate("test.test='1'");
assertNotNull(predicate);

List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});

List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());

assertEquals(2, filteredObjects.size());
}

@Test
public void testValidPredicateField() {
Predicate<String> predicate = equal.generate("test.test=test.test");
assertNotNull(predicate);

List<String> objects = Arrays.asList(new String[]{"test.test=1","testsss.test=1","testa=1", "test[1].test=1"});

List<String> filteredObjects = objects.stream().filter(predicate).collect(Collectors.toList());

assertEquals(2, filteredObjects.size
```
<Overlap Ratio: 0.9848084544253632>

---

--- 144 --
Question ID: 31502ac9ab596a13274c4dd68ad040205e815044
Original Code:
```
public class PlayersAroundChecker {

    private final List<Location> playersLoc = new ArrayList<Location>();
    private final Map<Location, Integer> minDistanceCache = new HashMap<Location, Integer>();

    public PlayersAroundChecker(Plugin plugin, int period) {
        PlayersLocPoller poller = new PlayersLocPoller();

        poller.run();
        Bukkit.getScheduler().scheduleSyncRepeatingTask(plugin, poller, period, period);
    }

    /** Thread unsafe */
    public boolean isAnyPlayerAround(Location loc, int radius) {
        if (playersLoc.isEmpty()) return false;

        Integer cachedMinDist = minDistanceCache.get(loc);
        if (cachedMinDist == null) {
            int minDist = Integer.MAX_VALUE;
            for (Location playerLoc : playersLoc) {
                if (playerLoc.getWorld().equals(loc.getWorld())) {
                    int curDist = (int) playerLoc.distance(loc);
                    if (curDist < minDist) {
                        minDist = curDist;
                    }
                }
            }
            cachedMinDist = minDist;
            minDistanceCache.put(loc, cachedMinDist);
        }

        return cachedMinDist <= radius;
    }

    private class PlayersLocPoller implements Runnable {

        @Override
        public void run() {
            playersLoc.clear();
            minDistanceCache.clear();

            Player[] players = Bukkit.getServer().getOnlinePlayers();
            for (Player player : players) {
                playersLoc.add(player.getLocation());
            }
        }
    }
}
```


Overlapping Code:
```
layersAroundChecker {
private final List<Location> playersLoc = new ArrayList<Location>();
private final Map<Location, Integer> minDistanceCache = new HashMap<Location, Integer>();
public PlayersAroundChecker(Plugin plugin, int period) {
PlayersLocPoller poller = new PlayersLocPoller();
poller.run();
Bukkit.getScheduler().scheduleSyncRepeatingTask(plugin, poller, period, period);
}
/** Thread unsafe */
public boolean isAnyPlayerAround(Location loc, int radius) {
if (playersLoc.isEmpty()) return false;
Integer cachedMinDist = minDistanceCache.get(loc);
if (cachedMinDist == null) {
int minDist = Integer.MAX_VALUE;
for (Location playerLoc : playersLoc) {
if (playerLoc.getWorld().equals(loc.getWorld())) {
int curDist = (int) playerLoc.distance(loc);
if (curDist < minDist) {
minDist = curDist;
}
}
}
cachedMinDist = minDist;
minDistanceCache.put(loc, cachedMinDist);
}
return cachedMinDist <= radius;
}
private class PlayersLocPoller implements Runnable {
@Override
public void run() {
playersLoc.clear();
minDistanceCache.clear();
Player[] players = Bukkit.getServer().getOnlinePlayers();
for (Player player : players) {
playersLoc.add(player.
```
<Overlap Ratio: 0.9688289806234204>

---

--- 145 --
Question ID: 6aa4f7b1b0f657562e0d07ceaca2f5db957eb225
Original Code:
```
@Service(interfaceClass=SystemLogService.class)
public class SystemLogServiceImpl extends BaseServiceImpl<SystemLog> implements SystemLogService {
	
	@Resource
	private ICurrentUser currentUser;
	
	@Resource
	private SystemLogDao systemLogDao;
	
	@Resource
	private com.pepper.service.console.role.RoleService RoleService;

	public void log(String actionName,String url){
		ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
	    HttpServletRequest request = servletRequestAttributes.getRequest();
		AdminUser user = (AdminUser) currentUser.getCurrentUser();
		if(Objects.isNull(user)) {
			return;
		}
		List<Role> list = RoleService.findByUserId1(user.getId());
		SystemLog systemLog = new SystemLog();
		for(Role role : list ) {
			if(Objects.equals(role.getIsDefault(), true)) {
				systemLog.setRoleCode(role.getCode());
				systemLog.setRoleName(role.getName());
				systemLog.setRoleId(role.getId());
			}
		}
		systemLog.setAccount(user.getAccount());
		systemLog.setUserId(user==null?"":user.getId());
		systemLog.setUserName(user==null?"":user.getName());
		systemLog.setLogContent(actionName);
		systemLog.setUrl(request.getRequestURL().toString());
		
	    if(request.getParameterMap().size()>0) {
	    	ObjectMapper objectMapper = new ObjectMapper();
	    	try {
				systemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));
			} catch (JsonProcessingException e) {
			}
	    }
	    if(StringUtils.hasText(systemLog.getData())) {
	    	systemLog.setData(systemLog.getData() + " "+ binaryReader(request));
	    }else {
	    	systemLog.setData( binaryReader(request));
	    }
	    
		this.save(systemLog);
	}
	
	public void log(String actionName,String url,String data){
		ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
	    HttpServletRequest request = servletRequestAttributes.getRequest();
		AdminUser user = (AdminUser) currentUser.getCurrentUser();
		if(Objects.isNull(user)) {
			return;
		}
		List<Role> list = RoleService.findByUserId1(user.getId());
		SystemLog systemLog = new SystemLog();
		for(Role role : list ) {
			if(Objects.equals(role.getIsDefault(), true)) {
				systemLog.setRoleCode(role.getCode());
				systemLog.setRoleName(role.getName());
				systemLog.setRoleId(role.getId());
			}
		}
		systemLog.setAccount(user.getAccount());
		systemLog.setUserId(user==null?"":user.getId());
		systemLog.setUserName(user==null?"":user.getName());
		systemLog.setLogContent(actionName);
		if(request.getParameterMap().size()>0) {
	    	ObjectMapper objectMapper = new ObjectMapper();
	    	try {
				systemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));
			} catch (JsonProcessingException e) {
			}
	    }
		if(StringUtils.hasText(systemLog.getData())) {
	    	systemLog.setData(systemLog.getData() + " "+ binaryReader(request));
	    }else {
	    	systemLog.setData( binaryReader(request));
	    }
		systemLog.setUrl(request.getRequestURL().toString());
		this.save(systemLog);
	}
	
	public void log(String actionName,String url,AdminUser adminUser){
		if(Objects.isNull(adminUser)) {
			return;
		}
		ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
	    HttpServletRequest request = servletRequestAttributes.getRequest();
	    List<Role> list = RoleService.findByUserId1(adminUser.getId());
		SystemLog systemLog = new SystemLog();
		for(Role role : list ) {
			if(Objects.equals(role.getIsDefault(), true)) {
				systemLog.setRoleCode(role.getCode());
				systemLog.setRoleName(role.getName());
				systemLog.setRoleId(role.getId());
			}
		}
		systemLog.setAccount(adminUser.getAccount());
		systemLog.setUserId(adminUser==null?"":adminUser.getId());
		systemLog.setUserName(adminUser==null?"":adminUser.getName());
		systemLog.setLogContent(actionName);
		systemLog.setUrl(request.getRequestURL().toString());
		if(request.getParameterMap().size()>0) {
	    	ObjectMapper objectMapper = new ObjectMapper();
	    	try {
				systemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));
			} catch (JsonProcessingException e) {
			}
	    }
		if(StringUtils.hasText(systemLog.getData())) {
	    	systemLog.setData(systemLog.getData() + " "+ binaryReader(request));
	    }else {
	    	systemLog.setData( binaryReader(request));
	    }
		this.save(systemLog);
	}
	
	

	private String binaryReader(HttpServletRequest request) {
		
		try {
			StringWriter writer = new StringWriter();
			IOUtils.copy(request.getInputStream(), writer, StandardCharsets.UTF_8.name());
			String str = writer.toString();
			return str;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return "";
		
	}

	@Override
	public void log(String actionName) {
		ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
	    HttpServletRequest request = servletRequestAttributes.getRequest();
		AdminUser user = (AdminUser) currentUser.getCurrentUser();
		if(Objects.isNull(user)) {
			return;
		}
		List<Role> list = RoleService.findByUserId1(user.getId());
		SystemLog systemLog = new SystemLog();
		for(Role role : list ) {
			if(Objects.equals(role.getIsDefault(), true)) {
				systemLog.setRoleCode(role.getCode());
				systemLog.setRoleName(role.getName());
				systemLog.setRoleId(role.getId());
			}
		}
		systemLog.setAccount(user.getAccount());
		systemLog.setUserId(user==null?"":user.getId());
		systemLog.setUserName(user==null?"":user.getName());
		systemLog.setLogContent(actionName);
		systemLog.setUrl(request.getRequestURL().toString());
		this.save(systemLog);
	}
	
}
```


Overlapping Code:
```
public class SystemLogServiceImpl extends BaseServiceImpl<SystemLog> implements SystemLogService {

@Resource
private ICurrentUser currentUser;

@Resource
private SystemLogDao systemLogDao;

@Resource
private com.pepper.service.console.role.RoleService RoleService;
public void log(String actionName,String url){
ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
HttpServletRequest request = servletRequestAttributes.getRequest();
AdminUser user = (AdminUser) currentUser.getCurrentUser();
if(Objects.isNull(user)) {
return;
}
List<Role> list = RoleService.findByUserId1(user.getId());
SystemLog systemLog = new SystemLog();
for(Role role : list ) {
if(Objects.equals(role.getIsDefault(), true)) {
systemLog.setRoleCode(role.getCode());
systemLog.setRoleName(role.getName());
systemLog.setRoleId(role.getId());
}
}
systemLog.setAccount(user.getAccount());
systemLog.setUserId(user==null?"":user.getId());
systemLog.setUserName(user==null?"":user.getName());
systemLog.setLogContent(actionName);
systemLog.setUrl(request.getRequestURL().toString());

if(request.getParameterMap().size()>0) {
ObjectMapper objectMapper = new ObjectMapper();
try {
systemLog.setData(objectMapper.writeValueAsString(request.getParameterMap()));
} catch (JsonProcessingException e) {
}
}
if(StringUtils.hasText(systemLog.getData())) {
systemLog.setData(systemLog.getData() + " "+ binaryReader(request));
}else {
systemLog.setData( binaryReader(request));
}

this.save(systemLog);
}

public void log(String actionName,String url,String data){
ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();
HttpServletRequest request = servletRequestAttributes.getRequest();
AdminUser user = (AdminUser) currentUser.getCurrentUser();
if(Objects.isNull(user)) {
return;
}
List<Role> list = RoleService.findByUserId1(user.getId());
SystemLog systemLog = new SystemLog();
for(Role role : list ) {
if(Objects.equals(role.getIsDefault(), true)) {
systemLog.setRoleCode(role.getCode());
systemLog.setRoleName(role.getName());
systemLog.setRoleId(role.getId());
}
}
systemLog.setAccount(user.getAccount());
systemLog.setUserId(user==null?"":user.ge
```
<Overlap Ratio: 0.9710832973672853>

---

--- 146 --
Question ID: a889152c4799b6a8d000fa4cb82cf7275b5716b5
Original Code:
```
@Component
public class AuthenticationFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {

    @Autowired
    private RedisTemplate redisTemplate;

    private static final Logger logger = LoggerFactory.getLogger(AuthenticationFailureListener.class);

    @Override
    public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent authenticationFailureBadCredentialsEvent) {
        String account = authenticationFailureBadCredentialsEvent.getAuthentication().getPrincipal().toString();
        logger.info("登录失败调用-----------------------------------------------------{}"+account);

        //不管每台是否超过5次输入错误第二天将其还原
        redisTemplate.opsForValue().increment(account+"_",1);
        Integer i = (Integer) redisTemplate.opsForValue().get(account + "_");
        if (i > 3 && i <= 5 && redisTemplate.hasKey(account+"_")){  //如果大于3次锁定60秒
            redisTemplate.opsForValue().set(account+"enabled",0,60,TimeUnit.SECONDS);
            redisTemplate.opsForValue().set(account+"_",i,120,TimeUnit.SECONDS);//一天后失效
        }else if (i > 5 && redisTemplate.hasKey(account+"_")){//如果大于5次锁定120秒
            redisTemplate.opsForValue().set(account+"enabled",0,120,TimeUnit.SECONDS);//锁定一天时间
            redisTemplate.opsForValue().set(account+"_",i,120,TimeUnit.SECONDS);//一天后失效
        }


    }
}
```


Overlapping Code:
```
@Component
public class AuthenticationFailureListener implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {
@Autowired
private RedisTemplate redisTemplate;
private static final Logger logger = LoggerFactory.getLogger(AuthenticationFailureListener.class);
@Override
public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent authenticationFailureBadCredentialsEvent) {
String account = authenticationFailureBadCredentialsEvent.getAuthentication().getPrincipal().toString();
logger.info("登录失败调用-----------------------------------------------------{}"+account);
//不管每台是否超过5次输入错误第二天将其还原
redisTemplate.opsForValue().increment(account+"_",1);
Integer i = (Integer) redisTemplate.opsForValue().get(account + "_");
if (i > 3 && i <= 5 && redisTemplate.hasKey(account+"_")){ //如果大于3次锁定60秒
redisTemplate.opsForValue().set(account+"enabled",0,60,TimeUnit.SECONDS);
redisTemplate.opsForValue().set(account+"_",i,120,TimeUnit.SECONDS);//一天后失效
}else if (i > 5 && redisTemplate.hasKey(account+"_")){//如果大于5次锁定120秒
redisTemplate.opsForValue().set(account+"enabled",0,120,TimeUnit.SECONDS);//锁定一天时间
redisTemplate.opsForValue().set(account+"_",i,120,TimeUnit.SECO
```
<Overlap Ratio: 0.9849624060150376>

---

--- 147 --
Question ID: 7305313c03084ce925801f2c90e955492fb15f62
Original Code:
```
public class UZAPIMaster {
    private static UZAPIMaster ourInstance;

    public static UZAPIMaster getInstance() {
        if (ourInstance == null) {
            ourInstance = new UZAPIMaster();
        }
        return ourInstance;
    }

    private UZAPIMaster() {
    }

    private CompositeSubscription compositeSubscription = new CompositeSubscription();

    public void destroy() {
        if (!compositeSubscription.isUnsubscribed()) {
            compositeSubscription.unsubscribe();
        }
    }

    @SuppressWarnings("unchecked")
    public void subscribe(Observable observable, Subscriber subscriber) {
        //TODO maybe in some cases we don't need to check internet connection
        /*if (!NetworkUtils.hasConnection(this)) {
            subscriber.onError(new NoConnectionException());
            return;
        }*/
        Subscription subscription = observable.subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(subscriber);
        compositeSubscription.add(subscription);
    }
}
```


Overlapping Code:
```
ic UZAPIMaster ourInstance;
public static UZAPIMaster getInstance() {
if (ourInstance == null) {
ourInstance = new UZAPIMaster();
}
return ourInstance;
}
private UZAPIMaster() {
}
private CompositeSubscription compositeSubscription = new CompositeSubscription();
public void destroy() {
if (!compositeSubscription.isUnsubscribed()) {
compositeSubscription.unsubscribe();
}
}
@SuppressWarnings("unchecked")
public void subscribe(Observable observable, Subscriber subscriber) {
//TODO maybe in some cases we don't need to check internet connection
/*if (!NetworkUtils.hasConnection(this)) {
subscriber.onError(new NoConnectionException());
return;
}*/
Subscription subscription = observable.subscribeOn(Schedulers.newThread())
.observeOn(AndroidSchedulers.mainThread())
.subscribe(subscriber);
compositeSubscription.
```
<Overlap Ratio: 0.9302857142857143>

---

--- 148 --
Question ID: db50e644a4c5aeccec24f0037fb71469b2f91429
Original Code:
```
public class Table {
    // region object variables
    private List<Row> rowList;
    // endregion

    // region constructors
    public Table() {
        this.rowList = new ArrayList<Row>();
    }
    // endregion

    // region object methods
    /**
     * Direct method for adding a row.
     * @param row Row to add.
     */
    public void addRow(Row row) throws Exception {
        if(row == null) {
            throw new Exception("Row object is null");
        }
        if(this.rowList == null) {
            this.rowList = new ArrayList<Row>();
        }
        this.rowList.add(row);
    }

    /**
     * Direct methods for adding multiple rows.
     * For each row, the internal method addRow(in row: Row) will called.
     *
     * @param rows Multiple objects of type Row.
     * @throws Exception Thrown, if one row object is null.
     */
    public void addRows(Row... rows) throws Exception {
        for(Row row:rows) {
            this.addRow(row);
        }
    }
    // endregion

    // region getter & setter

    public List<Row> getRowList() {
        return rowList;
    }

    public void setRowList(List<Row> rowList) {
        this.rowList = rowList;
    }

    // endregion

    // region nested enum Type
    public enum Type {
        Table,
        DragAndDrop,
        Support
    }
    // endregion
}
```


Overlapping Code:
```
ss Table {
// region object variables
private List<Row> rowList;
// endregion
// region constructors
public Table() {
this.rowList = new ArrayList<Row>();
}
// endregion
// region object methods
/**
* Direct method for adding a row.
* @param row Row to add.
*/
public void addRow(Row row) throws Exception {
if(row == null) {
throw new Exception("Row object is null");
}
if(this.rowList == null) {
this.rowList = new ArrayList<Row>();
}
this.rowList.add(row);
}
/**
* Direct methods for adding multiple rows.
* For each row, the internal method addRow(in row: Row) will called.
*
* @param rows Multiple objects of type Row.
* @throws Exception Thrown, if one row object is null.
*/
public void addRows(Row... rows) throws Exception {
for(Row row:rows) {
this.addRow(row);
}
}
// endregion
// region getter & setter
public List<Row> getRowList() {
return rowList;
}
public void setRowList(List<Row> rowList) {
this.rowList = rowList;
}
// endregion
// region nested enum Type
public enum Type {
Table,
```
<Overlap Ratio: 0.9541984732824428>

---

--- 149 --
Question ID: 995212829dd8ab1ab8f10ad4cded7ebbc4f92e59
Original Code:
```
public class ExtraOefening5b {

	public static void main(String[] args) {
		Scanner keyboard = new Scanner(System.in);

		double volledigGetal, getal;

		System.out.println("Geef een getal in:");
		volledigGetal = keyboard.nextDouble();

		getal = ((int) (volledigGetal * 100)) / 100.0;
		System.out.println("AFGEKAPT: " + getal);

		getal = ((int) ((volledigGetal * 100) + 0.5)) / 100.0;
		System.out.println("AFGEROND: " + getal);

		keyboard.close();
	}

}
```


Overlapping Code:
```
public class ExtraOefening5b {
public static void main(String[] args) {
Scanner keyboard = new Scanner(System.in);
double volledigGetal, getal;
System.out.println("Geef een getal in:");
volledigGetal = keyboard.nextDouble();
getal = ((int) (volledigGetal * 100)) / 100.0;
System.out.println("AFGEKAPT: " + getal);
getal = ((int) ((volledigGetal * 100) + 0.5)) / 100.0;
System.out.println("AFGEROND: "
```
<Overlap Ratio: 0.9259259259259259>

---

--- 150 --
Question ID: 4d7cfd843a49c96e9ff655d6ff82023577ab3107
Original Code:
```
public class Tomcat {
	private static Thread tomcatThread;

	public static void startJettyServer(int portNum, List<WarSpec> warSpecs, String tmpDir) {
		start();
	}

	public static SubLObject stopJettyServer(String tmpDir) {
		stop();
		return Lisp.NIL;
	}

	/**
	 * @return
	 */
	public static void stop() {
		//Jetty.startJettyServer(portNum, warSpecs, tmpDir);
		daemon = Bootstrap.daemon;
		if (daemon != null)
			Bootstrap.main(new String[] { "stop" });
	}

	/**
	 * Daemon object used by main.
	 */
	//public static Bootstrap daemon = null;

	private static final Pattern PATH_PATTERN = Pattern.compile("(\".*?\")|(([^,])*)");

	private static void setCatalinaLoader() {
		Thread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);
		//Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
	}

	static Bootstrap daemon;

	/**
	 * 
	 */
	synchronized public static void start() {
		daemon = Bootstrap.daemon;
		if (daemon != null)
			return;
		tomcatThread = new Thread(() -> bgStart());
		tomcatThread.setName("Tomcat Starup thread");
		tomcatThread.setDaemon(true);
		tomcatThread.start();

	}

	/**
	 * 
	 */
	public static void bgStart() {
		//Jetty.startJettyServer(portNum, warSpecs, tmpDir);
		//System.setProperty("http.port", "" + portNum);
		String[] args = new String[] { "start" };

		//tomcatThread = new Thread(() -> {

		Thread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);

		if (daemon == null) {
			// Don'e set daemon until init() has completed
			Bootstrap bootstrap = new Bootstrap();
			try {
				bootstrap.init();
			} catch (Throwable e) {
				printStackTrace(e);
				Errors.handleError(e);
				return;
			}
			daemon = Bootstrap.daemon = bootstrap;
		} else {
			// When running as a service the call to stop will be on a new
			// thread so make sure the correct class loader is used to prevent
			// a range of class not found exceptions.
			setCatalinaLoader();
		}

		try {
			daemon.setAwait(false);
		} catch (Exception e) {
			printStackTrace(e);
			Errors.handleError(e);
		}
		try {
			daemon.load(args);
			SystemCurrent.recheckStdIO();
		} catch (Exception e) {
			printStackTrace(e);
			Errors.handleError(e);
		}
		try {
			daemon.start();
		} catch (Exception e) {
			printStackTrace(e);
			Errors.handleError(e);
		}

		//		if (null == daemon.getServer()) {
		//			Startup.exit(1);
		//		}
	}

}
```


Overlapping Code:
```
at {
private static Thread tomcatThread;
public static void startJettyServer(int portNum, List<WarSpec> warSpecs, String tmpDir) {
start();
}
public static SubLObject stopJettyServer(String tmpDir) {
stop();
return Lisp.NIL;
}
/**
* @return
*/
public static void stop() {
//Jetty.startJettyServer(portNum, warSpecs, tmpDir);
daemon = Bootstrap.daemon;
if (daemon != null)
Bootstrap.main(new String[] { "stop" });
}
/**
* Daemon object used by main.
*/
//public static Bootstrap daemon = null;
private static final Pattern PATH_PATTERN = Pattern.compile("(\".*?\")|(([^,])*)");
private static void setCatalinaLoader() {
Thread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);
//Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);
}
static Bootstrap daemon;
/**
* 
*/
synchronized public static void start() {
daemon = Bootstrap.daemon;
if (daemon != null)
return;
tomcatThread = new Thread(() -> bgStart());
tomcatThread.setName("Tomcat Starup thread");
tomcatThread.setDaemon(true);
tomcatThread.start();
}
/**
* 
*/
public static void bgStart() {
//Jetty.startJettyServer(portNum, warSpecs, tmpDir);
//System.setProperty("http.port", "" + portNum);
String[] args = new String[] { "start" };
//tomcatThread = new Thread(() -> {
Thread.currentThread().setContextClassLoader(IsolatedClassLoader.theIsolatedClassLoader);
if (daemon == null) {
// Don'e set daemon until init() has completed
Bootstrap bootstrap = new Bootstrap();
try {
bootstrap.init();
} catch (Throwable e) {
printStackTrace(e);
Errors.handleError(e);
return;
}
daemon = Bootstrap.daemon = bootstrap;
} else {
// When running as a service the call to stop will be on a new
// thread so make sure the correct class loader is used to prevent
// a range of class not found exceptions.
setCatalinaLoader();
}
try {
daemon.setAwait(false);
} catch (Exception e) {
printStackTrace(e);
Errors.handleError(e);
}
try {
daemon.load(args);
SystemCurrent.recheckStdIO();
} catch (Exception e) {
printStackTrace(e);
Errors.handleError(e);
}
try {
daemon.start();
} catch (Exception e) {
printStackTrace(e);
Errors.handleError(e);
}
// if (null == daemon.getServer()) {
// Startup.exit(1);
// }
}
}
```
<Overlap Ratio: 0.9923319801533604>

---

--- 151 --
Question ID: 06298ab36d38caa9333cade74e69b82b6e69cd5f
Original Code:
```
public class Ganzzahl implements EinfacherListenknoten {
 
    public int wert;
    private EinfacherListenknoten naechsterKnoten;
 
    public Ganzzahl(int i) {
        wert = i;
        naechsterKnoten = null;
    }
    /**
     * Einfuegen eines Nachfolgers
     * @param n einzufuegender Listenknoten
     */
    @Override
    public void setNachFolger(EinfacherListenknoten n) {
        naechsterKnoten = n;
    }
    /**
    * Auslesen des Nachfolgers
    * @return der Nachfolger
    */
    @Override
    public EinfacherListenknoten getNachfolger() {
        return naechsterKnoten;
    }
 
    /**
     * Hauptprogramm zum Testen
     * @param args Kommandozeilenparameter (nicht benötigt)
     */
    public static void main(String[] args) {
        Ganzzahl z1 = new Ganzzahl(11);
        Ganzzahl z2 = new Ganzzahl(22);
        Ganzzahl z3 = new Ganzzahl(33);
        z1.setNachFolger(z2);
        z2.setNachFolger(z3);
    }
}
```


Overlapping Code:
```
mplements EinfacherListenknoten {

public int wert;
private EinfacherListenknoten naechsterKnoten;

public Ganzzahl(int i) {
wert = i;
naechsterKnoten = null;
}
/**
* Einfuegen eines Nachfolgers
* @param n einzufuegender Listenknoten
*/
@Override
public void setNachFolger(EinfacherListenknoten n) {
naechsterKnoten = n;
}
/**
* Auslesen des Nachfolgers
* @return der Nachfolger
*/
@Override
public EinfacherListenknoten getNachfolger() {
return naechsterKnoten;
}

/**
* Hauptprogramm zum Testen
* @param args Kommandozeilenparameter (nicht benötigt)
*/
public static void main(String[] args) {
Ganzzahl z1 = new Ganzzahl(11);
Ganzzahl z2 = new Ganzzahl(22);
Ganzzahl z3 = new Ganzzahl(33);
z1.setNa
```
<Overlap Ratio: 0.9186351706036745>

---

--- 152 --
Question ID: e03ebcc2bf06aa2643cabea8d7ed9cedab7b3182
Original Code:
```
public class FilterBySpaceImplementation<Current, Other> implements FilterBySpace<Current, Other> {
    @Getter
    private FilterExpressionType expressionType;

    @Getter
    private MetaClass<Other> mappingSpace;

    @Getter
    private MetaField<? extends MetaClass<Current>, ?> mappingKeyField;

    @Getter
    private Index mappingIndex;

    @Getter
    private Tuple mappingIndexTuple;

    @Getter
    private MetaField<? extends MetaClass<Current>, ?> currentField;

    @Getter
    private MetaField<? extends MetaClass<Other>, ?> otherField;

    @Getter
    private final FilterBySpaceUseFieldsImplementation<Current, Other, ?> bySpaceUseFields;

    @Getter
    private final FilterBySpaceUseStringFieldsImplementation<Current, Other> bySpaceUseStringFields;

    @Getter
    private final FilterBySpaceUseNumberFieldsImplementation<Current, Other> bySpaceUseNumberFields;

    @Getter
    private final FilterBySpaceUseNumbersImplementation<Current> bySpaceUseNumbers;

    @Getter
    private final FilterBySpaceUseStringsImplementation<Current> bySpaceUseStrings;

    @Getter
    private final FilterBySpaceUseValuesImplementation<Current, ?> bySpaceUseValues;

    public FilterBySpaceImplementation(FilterRule<Current> rule) {
        bySpaceUseFields = new FilterBySpaceUseFieldsImplementation<>(rule);
        bySpaceUseStringFields = new FilterBySpaceUseStringFieldsImplementation<>(rule);
        bySpaceUseNumberFields = new FilterBySpaceUseNumberFieldsImplementation<>(rule);
        bySpaceUseNumbers = new FilterBySpaceUseNumbersImplementation<>(rule);
        bySpaceUseStrings = new FilterBySpaceUseStringsImplementation<>(rule);
        bySpaceUseValues = new FilterBySpaceUseValuesImplementation<>(rule);
    }

    FilterBySpaceImplementation<Current, Other> bySpace(MetaClass<Other> mappingSpace, MetaField<? extends MetaClass<Current>, ?> mappingField) {
        this.mappingSpace = mappingSpace;
        mappingKeyField = mappingField;
        return this;
    }

    final FilterBySpaceImplementation<Current, Other> byIndex(Index index, Tuple tuple) {
        mappingIndex = index;
        mappingIndexTuple = tuple;
        return this;
    }

    @Override
    public <FieldType> FilterBySpaceUseFields<Current, Other, FieldType> currentField(MetaField<? extends MetaClass<Current>, FieldType> currentField) {
        expressionType = FIELD;
        this.currentField = currentField;
        return cast(bySpaceUseFields);
    }

    @Override
    public FilterBySpaceUseStringFields<Current, Other> currentString(MetaField<? extends MetaClass<Current>, String> currentField) {
        expressionType = STRING_FIELD;
        this.currentField = currentField;
        return bySpaceUseStringFields;
    }

    @Override
    public FilterBySpaceUseNumberFields<Current, Other> currentNumber(MetaField<? extends MetaClass<Current>, ? extends Number> currentField) {
        expressionType = NUMBER_FIELD;
        this.currentField = currentField;
        return bySpaceUseNumberFields;
    }

    @Override
    public FilterBySpaceUseNumbers<Current> otherNumber(MetaField<? extends MetaClass<Other>, ? extends Number> otherField) {
        expressionType = NUMBER_VALUE;
        this.otherField = otherField;
        return bySpaceUseNumbers;
    }

    @Override
    public FilterBySpaceUseStrings<Current> otherString(MetaField<? extends MetaClass<Other>, String> otherField) {
        expressionType = STRING_VALUE;
        this.otherField = otherField;
        return bySpaceUseStrings;
    }

    @Override
    public <FieldType> FilterBySpaceUseValues<Current, FieldType> otherField(MetaField<? extends MetaClass<Other>, FieldType> otherField) {
        expressionType = VALUE;
        this.otherField = otherField;
        return cast(bySpaceUseValues);
    }
}
```


Overlapping Code:
```
ation<Current, Other> implements FilterBySpace<Current, Other> {
@Getter
private FilterExpressionType expressionType;
@Getter
private MetaClass<Other> mappingSpace;
@Getter
private MetaField<? extends MetaClass<Current>, ?> mappingKeyField;
@Getter
private Index mappingIndex;
@Getter
private Tuple mappingIndexTuple;
@Getter
private MetaField<? extends MetaClass<Current>, ?> currentField;
@Getter
private MetaField<? extends MetaClass<Other>, ?> otherField;
@Getter
private final FilterBySpaceUseFieldsImplementation<Current, Other, ?> bySpaceUseFields;
@Getter
private final FilterBySpaceUseStringFieldsImplementation<Current, Other> bySpaceUseStringFields;
@Getter
private final FilterBySpaceUseNumberFieldsImplementation<Current, Other> bySpaceUseNumberFields;
@Getter
private final FilterBySpaceUseNumbersImplementation<Current> bySpaceUseNumbers;
@Getter
private final FilterBySpaceUseStringsImplementation<Current> bySpaceUseStrings;
@Getter
private final FilterBySpaceUseValuesImplementation<Current, ?> bySpaceUseValues;
public FilterBySpaceImplementation(FilterRule<Current> rule) {
bySpaceUseFields = new FilterBySpaceUseFieldsImplementation<>(rule);
bySpaceUseStringFields = new FilterBySpaceUseStringFieldsImplementation<>(rule);
bySpaceUseNumberFields = new FilterBySpaceUseNumberFieldsImplementation<>(rule);
bySpaceUseNumbers = new FilterBySpaceUseNumbersImplementation<>(rule);
bySpaceUseStrings = new FilterBySpaceUseStringsImplementation<>(rule);
bySpaceUseValues = new FilterBySpaceUseValuesImplementation<>(rule);
}
FilterBySpaceImplementation<Current, Other> bySpace(MetaClass<Other> mappingSpace, MetaField<? extends MetaClass<Current>, ?> mappingField) {
this.mappingSpace = mappingSpace;
mappingKeyField = mappingField;
return this;
}
final FilterBySpaceImplementation<Current, Other> byIndex(Index index, Tuple tuple) {
mappingIndex = index;
mappingIndexTuple = tuple;
return this;
}
@Override
public <FieldType> FilterBySpaceUseFields<Current, Other, FieldType> currentField(MetaField<? extends MetaClass<Current>, FieldType> currentField) {
expressionType = FIELD;
this.currentField = currentField;
return cast(bySpaceUse
```
<Overlap Ratio: 0.971093044263776>

---

--- 153 --
Question ID: b5e21d7be9c20f2546ca6122ce45717016671652
Original Code:
```
class StartUseVcsDialog extends DialogWrapper {
  private final Map<String, String> myVcses;
  private VcsCombo myVcsCombo;
  private String mySelected;

  StartUseVcsDialog(@NotNull Project project) {
    super(project, true);
    myVcses = getVcses(project);
    setTitle(VcsBundle.message("dialog.enable.version.control.integration.title"));

    init();
  }

  @Override
  public JComponent getPreferredFocusedComponent() {
    return myVcsCombo;
  }

  @Override
  protected JComponent createCenterPanel() {
    JLabel selectText = new JLabel(VcsBundle.message("dialog.enable.version.control.integration.select.vcs.label.text"));
    selectText.setUI(new MultiLineLabelUI());

    JPanel mainPanel = new JPanel(new GridBagLayout());
    GridBagConstraints gb = new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.BASELINE, GridBagConstraints.NONE, JBUI.insets(5),
                                                   0, 0);
    mainPanel.add(selectText, gb);

    ++gb.gridx;

    myVcsCombo = new VcsCombo(prepareComboData());
    mainPanel.add(myVcsCombo, gb);

    JLabel helpText = new JLabel(VcsBundle.message("dialog.enable.version.control.integration.hint.text"));
    helpText.setUI(new MultiLineLabelUI());
    helpText.setForeground(UIUtil.getInactiveTextColor());

    gb.anchor = GridBagConstraints.NORTHWEST;
    gb.gridx = 0;
    ++ gb.gridy;
    gb.gridwidth = 2;
    mainPanel.add(helpText, gb);

    JPanel wrapper = new JPanel(new GridBagLayout());
    GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
                                                    JBUI.emptyInsets(), 0, 0);
    wrapper.add(mainPanel, gbc);
    return wrapper;
  }

  @Override
  protected String getHelpId() {
    return "reference.version.control.enable.version.control.integration";
  }

  @Override
  protected void doOKAction() {
    mySelected = myVcsCombo.getSelectedItem();
    super.doOKAction();
  }

  private String @NotNull [] prepareComboData() {
    ArrayList<String> keys = new ArrayList<>(myVcses.keySet());
    keys.sort((String o1, String o2) -> {
      if (o1.equals(o2)) return 0;
      if (o1.equals("Git")) return -1;
      if (o2.equals("Git")) return 1;
      return o1.compareTo(o2);
    });
    return ArrayUtil.toStringArray(keys);
  }

  @NotNull
  String getVcs() {
    return myVcses.get(mySelected);
  }

  private static Map<String, String> getVcses(@NotNull Project project) {
    VcsDescriptor[] allVcss = ProjectLevelVcsManager.getInstance(project).getAllVcss();
    Map<String, String> map = new HashMap<>(allVcss.length);
    for (VcsDescriptor vcs : allVcss) {
      map.put(vcs.getDisplayName(), vcs.getName());
    }
    return map;
  }

  private static class VcsCombo extends JComboBox<String> {
    private VcsCombo(String @NotNull [] items) {
      super(items);
      setSelectedIndex(0);
      setEditable(false);
    }

    @Override
    public String getSelectedItem() {
      return (String) super.getSelectedItem();
    }
  }
}
```


Overlapping Code:
```
class StartUseVcsDialog extends DialogWrapper {
private final Map<String, String> myVcses;
private VcsCombo myVcsCombo;
private String mySelected;
StartUseVcsDialog(@NotNull Project project) {
super(project, true);
myVcses = getVcses(project);
setTitle(VcsBundle.message("dialog.enable.version.control.integration.title"));
init();
}
@Override
public JComponent getPreferredFocusedComponent() {
return myVcsCombo;
}
@Override
protected JComponent createCenterPanel() {
JLabel selectText = new JLabel(VcsBundle.message("dialog.enable.version.control.integration.select.vcs.label.text"));
selectText.setUI(new MultiLineLabelUI());
JPanel mainPanel = new JPanel(new GridBagLayout());
GridBagConstraints gb = new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.BASELINE, GridBagConstraints.NONE, JBUI.insets(5),
0, 0);
mainPanel.add(selectText, gb);
++gb.gridx;
myVcsCombo = new VcsCombo(prepareComboData());
mainPanel.add(myVcsCombo, gb);
JLabel helpText = new JLabel(VcsBundle.message("dialog.enable.version.control.integration.hint.text"));
helpText.setUI(new MultiLineLabelUI());
helpText.setForeground(UIUtil.getInactiveTextColor());
gb.anchor = GridBagConstraints.NORTHWEST;
gb.gridx = 0;
++ gb.gridy;
gb.gridwidth = 2;
mainPanel.add(helpText, gb);
JPanel wrapper = new JPanel(new GridBagLayout());
GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
JBUI.emptyInsets(), 0, 0);
wrapper.add(mainPanel, gbc);
return wrapper;
}
@Override
protected String getHelpId() {
return "reference.version.control.enable.version.control.integration";
}
@Override
protected void doOKAction() {
mySelected = myVcsCombo.getSelectedItem();
super.doOKAction();
}
private String @NotNull [] prepareComboData() {
ArrayList<String> keys = new ArrayList<>(myVcses.keySet());
keys.sort((String o1, String o2) -> {
if (o1.equals(o2)) return 0;
if (o1.equals("Git")) return -1;
if (o2.equals("Git")) return 1;
return o1.compareTo(o2);
});
return ArrayUtil.toStringArray(keys);
}
@NotNull
String getVcs() {
return myVcses.get(mySelected);
}
private static Map<String, String> getVcses(@NotNull Project project) {
VcsD
```
<Overlap Ratio: 0.9972413793103448>

---

--- 154 --
Question ID: e5e4309335c0643774deb9fb42815a1bc17837d4
Original Code:
```
public class EdgePreserving implements Filter {
    public int flags = RECURS_FILTER;
//    int flags = NORMCONV_FILTER;
    public float sigma_s = 60;
    public float sigma_r = 0.4f;

    public int getFlags() {
        return flags;
    }

    public void setFlags(int flags) {
        this.flags = flags;
    }

    public float getSigma_s() {
        return sigma_s;
    }

    public void setSigma_s(float sigma_s) {
        this.sigma_s = sigma_s;
    }

    public float getSigma_r() {
        return sigma_r;
    }

    public void setSigma_r(float sigma_r) {
        this.sigma_r = sigma_r;
    }

    @Override
    public Mat apply(Mat in) {
        Mat dst = new Mat();
        edgePreservingFilter(in, dst, flags, sigma_s, sigma_r);
        return dst;
    }
}
```


Overlapping Code:
```
rving implements Filter {
public int flags = RECURS_FILTER;
// int flags = NORMCONV_FILTER;
public float sigma_s = 60;
public float sigma_r = 0.4f;
public int getFlags() {
return flags;
}
public void setFlags(int flags) {
this.flags = flags;
}
public float getSigma_s() {
return sigma_s;
}
public void setSigma_s(float sigma_s) {
this.sigma_s = sigma_s;
}
public float getSigma_r() {
return sigma_r;
}
public void setSigma_r(float sigma_r) {
this.sigma_r = sigma_r;
}
@Override
public Mat apply(Mat in) {
Mat dst = new Mat();
edgePreservingFilter(in,
```
<Overlap Ratio: 0.8885298869143781>

---

--- 155 --
Question ID: 82cde573ee27b8e140b79ba9b3a8091d3135b421
Original Code:
```
public class TestApiControllerIT {

    @Test
    public void testMethodTest() throws Exception {
        final String requestURL = "http://localhost:8002//test";
        final HttpClient client = HttpClientBuilder.create().build();
        final HttpResponse response = client.execute(new HttpGet(requestURL));
        assertEquals(response.getStatusLine().getStatusCode(), 501);
    }
}
```


Overlapping Code:
```
TestApiControllerIT {
@Test
public void testMethodTest() throws Exception {
final String requestURL = "http://localhost:8002//test";
final HttpClient client = HttpClientBuilder.create().build();
final HttpResponse response = client.execute(new HttpGet(requestURL));
assertEquals(response.getStatusLine().getStatusCode(), 50
```
<Overlap Ratio: 0.9416909620991254>

---

--- 156 --
Question ID: fab640bf849b789c3b80d7da9e275647abe3f253
Original Code:
```
public class ActionImpactCalculator implements Runnable {
	private static final int IMPACT_DECREASE = 1;
	private static final int IMPACT_INCREASE = 2;
	
	private HashMap<String, HashMap<String, Integer>> impactTable;
	
	@Override
	public void run() {
		System.out.println("Leading Eaop for action observations.");
		Design d = new ZIPDesignReader("./data/benchmarks/eaop.zip").read();
		
		if (d == null) {
			System.out.println("Could not read 'eaop.zip'.");
			System.exit(1);
		}
		
		System.out.println("Exploring all possible actions.");
		Set<Action> actions = d.getPossibleActions();
		System.out.printf("There are %d possible actions found.\n", actions.size());
		
		System.out.println("Calculating metrics.");
		MetricSummary summary = d.getMetrics().getSummary();
		System.out.println("Metrics calculated.");
		
		System.out.println("Starting operation. This may take a couple of minutes...");
		impactTable = new HashMap<String, HashMap<String,Integer>>();
		for (Action act : actions) {
			String type = act.getClass().getEnclosingClass().getSimpleName();
			
			Design cdesign = d.copy();
			act.perform(cdesign);
			
			MetricSummary csummary = cdesign.getMetrics().getSummary();
			
			for (Entry<String, Double> e : csummary.getMetrics().entrySet()) {
				if (e.getValue() + 1.0e-5 < summary.get(e.getKey())) {
					registerImpact(type, e.getKey(), IMPACT_DECREASE);
				} else 	if (e.getValue() - 1.0e-5 > summary.get(e.getKey())) {
					registerImpact(type, e.getKey(), IMPACT_INCREASE);
				}
			}
		}
		System.out.println("Completed operation.");
		
		for (Entry<String, HashMap<String, Integer>> e : impactTable.entrySet()) {
			String action = e.getKey();
			
			System.out.printf("%s:\n", action);
			
			for (Entry<String, Integer> me : e.getValue().entrySet()) {
				String metric = me.getKey();
				Integer impact = me.getValue();
				
				if (impact == null || impact == 0) continue;
				
				String impactText = "increase and decrease";
				if (impact == IMPACT_DECREASE)
					impactText = "decrease";
				else if (impact == IMPACT_INCREASE)
					impactText = "increase";
				
				System.out.printf("\t%s: %s\n", metric, impactText);
			}
		}
	}
	
	private void registerImpact(String action, String metric, int impact) {
		HashMap<String, Integer> imap = impactTable.get(action);
		if (imap == null) {
			imap = new HashMap<String, Integer>();
			impactTable.put(action, imap);
		}
		
		Integer value = imap.get(metric);
		if (value == null)
			value = impact;
		else
			value |= impact;
		
		imap.put(metric, value);
	}
}
```


Overlapping Code:
```
lculator implements Runnable {
private static final int IMPACT_DECREASE = 1;
private static final int IMPACT_INCREASE = 2;

private HashMap<String, HashMap<String, Integer>> impactTable;

@Override
public void run() {
System.out.println("Leading Eaop for action observations.");
Design d = new ZIPDesignReader("./data/benchmarks/eaop.zip").read();

if (d == null) {
System.out.println("Could not read 'eaop.zip'.");
System.exit(1);
}

System.out.println("Exploring all possible actions.");
Set<Action> actions = d.getPossibleActions();
System.out.printf("There are %d possible actions found.\n", actions.size());

System.out.println("Calculating metrics.");
MetricSummary summary = d.getMetrics().getSummary();
System.out.println("Metrics calculated.");

System.out.println("Starting operation. This may take a couple of minutes...");
impactTable = new HashMap<String, HashMap<String,Integer>>();
for (Action act : actions) {
String type = act.getClass().getEnclosingClass().getSimpleName();

Design cdesign = d.copy();
act.perform(cdesign);

MetricSummary csummary = cdesign.getMetrics().getSummary();

for (Entry<String, Double> e : csummary.getMetrics().entrySet()) {
if (e.getValue() + 1.0e-5 < summary.get(e.getKey())) {
registerImpact(type, e.getKey(), IMPACT_DECREASE);
} else if (e.getValue() - 1.0e-5 > summary.get(e.getKey())) {
registerImpact(type, e.getKey(), IMPACT_INCREASE);
}
}
}
System.out.println("Completed operation.");

for (Entry<String, HashMap<String, Integer>> e : impactTable.entrySet()) {
String action = e.getKey();

System.out.printf("%s:\n", action);

for (Entry<String, Integer> me : e.getValue().entrySet()) {
String metric = me.getKey();
Integer impact = me.getValue();

if (impact == null || impact == 0) continue;

String impactText = "increase and decrease";
if (impact == IMPACT_DECREASE)
impactText = "decrease";
else if (impact == IMPACT_INCREASE)
impactText = "increase";

System.out.printf("\t%s: %s\n", metric, impactText);
}
}
}

private void registerImpact(String action, String metric, int impact) {
HashMap<String, Integer> imap = impactTable.get(action);
if (imap == null) {
imap = new HashMap<String, Integer>();

```
<Overlap Ratio: 0.9681899641577061>

---

--- 157 --
Question ID: fa644c87a465c66b3e0f57c778797ac4e4986d9c
Original Code:
```
public class ReflectiveUtilsTests {

	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant() {
		Object obj = ReflectiveUtils.getXConstant(new Byte((byte) 42));
		assertNotNull(obj);
		assertTrue(obj instanceof ByteConstant);
		ByteConstant objAsBC = (ByteConstant) obj;
		assertEquals(42, objAsBC.byteValue());
	}
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant1() {
		Object obj = ReflectiveUtils.getXConstant(new Short((short) 42));
		assertNotNull(obj);
		assertTrue(obj instanceof ShortConstant);
		ShortConstant objAsSC = (ShortConstant) obj;
		assertEquals(42, objAsSC.shortValue());
	}
		
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant3() {
		Object obj = ReflectiveUtils.getXConstant(new Integer((int) 42));
		assertNotNull(obj);
		assertTrue(obj instanceof IntConstant);
		IntConstant objAsIC = (IntConstant) obj;
		assertEquals(42, objAsIC.intValue());
	}		
		
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant4() {
		Object obj = ReflectiveUtils.getXConstant(new Long((long) 42));
		assertNotNull(obj);
		assertTrue(obj instanceof LongConstant);
		LongConstant objAsLC = (LongConstant) obj;
		assertEquals(42, objAsLC.longValue());
	}		
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant5() {
		Object obj = ReflectiveUtils.getXConstant(new Float((float) 42.42));
		assertNotNull(obj);
		assertTrue(obj instanceof FloatConstant);
		FloatConstant objAsFC = (FloatConstant) obj;
		assertEquals(42.42, objAsFC.floatValue(), 0.00002);
	}	
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant6() {
		Object obj = ReflectiveUtils.getXConstant(new Double((double) 42.42));
		assertNotNull(obj);
		assertTrue(obj instanceof DoubleConstant);
		DoubleConstant objAsDC = (DoubleConstant) obj;
		assertEquals(42.42, objAsDC.doubleValue(), 0.00002);
	}	
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant7() {
		Object obj = ReflectiveUtils.getXConstant(new Character((char) 'a'));
		assertNotNull(obj);
		assertTrue(obj instanceof CharConstant);
		CharConstant objAsCC = (CharConstant) obj;
		assertEquals('a', objAsCC.charValue());
	}
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant8() {
		Object obj = ReflectiveUtils.getXConstant(new Boolean((boolean) true));
		assertNotNull(obj);
		assertTrue(obj instanceof BooleanConstant);
		BooleanConstant objAsBC = (BooleanConstant) obj;
		assertEquals(true, objAsBC.booleanValue());
	}
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant9() {
		Object obj = ReflectiveUtils.getXConstant(new String("hello"));
		assertNotNull(obj);
		assertTrue(obj instanceof StringConstant);
		StringConstant objAsSC = (StringConstant) obj;
		assertEquals("hello", objAsSC.stringValue());
	}
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant10() {
	
		
		Object obj = ReflectiveUtils.getXConstant(Weather.SUNNY);
		assertNotNull(obj);
		assertTrue(obj instanceof EnumConstantSignature);
		
		EnumConstantSignature objAsECS = (EnumConstantSignature) obj;
		assertEquals("Lstx/libjava/tests/mocks/Weather;", new String(objAsECS.getTypeName()));
		assertEquals("SUNNY", new String(objAsECS.getEnumConstantName()));
		
	}
	
	/**
	 * ReflectiveUtils.getXConstant() method test.
	 */
	@Test
	public void test_getXConstant11() {
	
		Object obj = ReflectiveUtils.getXConstant(SimpleMath.class);
		assertNotNull(obj);
		assertTrue(obj instanceof ClassSignature);
		
		ClassSignature objAsCS = (ClassSignature) obj;
		assertEquals("Lstx/libjava/tests/mocks/SimpleMath;", new String(objAsCS.getTypeName()));
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName() {
		String sig = ReflectiveUtils.getSigFromName("int");
		assertNotNull(sig);
		assertEquals("I", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName1() {
		String sig = ReflectiveUtils.getSigFromName("byte");
		assertNotNull(sig);
		assertEquals("B", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName2() {
		String sig = ReflectiveUtils.getSigFromName("short");
		assertNotNull(sig);
		assertEquals("S", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName3() {
		String sig = ReflectiveUtils.getSigFromName("long");
		assertNotNull(sig);
		assertEquals("J", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName4() {
		String sig = ReflectiveUtils.getSigFromName("boolean");
		assertNotNull(sig);
		assertEquals("Z", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName5() {
		String sig = ReflectiveUtils.getSigFromName("char");
		assertNotNull(sig);
		assertEquals("C", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName6() {
		String sig = ReflectiveUtils.getSigFromName("double");
		assertNotNull(sig);
		assertEquals("D", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName7() {
		String sig = ReflectiveUtils.getSigFromName("float");
		assertNotNull(sig);
		assertEquals("F", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName8() {
		String sig = ReflectiveUtils.getSigFromName("void");
		assertNotNull(sig);
		assertEquals("V", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName9() {
		String sig = ReflectiveUtils.getSigFromName("java.lang.Object");
		assertNotNull(sig);
		assertEquals("Ljava/lang/Object;", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName10() {
		String sig = ReflectiveUtils.getSigFromName("stx.libjava.tests.mocks.ArrayValueAnnotation");
		assertNotNull(sig);
		assertEquals("Lstx/libjava/tests/mocks/ArrayValueAnnotation;", sig);
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName11() {
		String sig = ReflectiveUtils.getSigFromName("[I");
		assertNotNull(sig);
		assertEquals("[I", sig);	
	}
	
	/**
	 * ReflectiveUtils.getSigFromName() method test.
	 */
	@Test
	public void test_getSigFromName12() {
		String sig = ReflectiveUtils.getSigFromName("[[Ljava.lang.Object;");
		assertNotNull(sig);
		assertEquals("[[Ljava/lang/Object;", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor() {
		String sig = ReflectiveUtils.getFieldDescriptor(int.class);
		assertNotNull(sig);
		assertEquals("I", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor1() {
		String sig = ReflectiveUtils.getFieldDescriptor(byte.class);
		assertNotNull(sig);
		assertEquals("B", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor2() {
		String sig = ReflectiveUtils.getFieldDescriptor(short.class);
		assertNotNull(sig);
		assertEquals("S", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor3() {
		String sig = ReflectiveUtils.getFieldDescriptor(long.class);
		assertNotNull(sig);
		assertEquals("J", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor4() {
		String sig = ReflectiveUtils.getFieldDescriptor(boolean.class);
		assertNotNull(sig);
		assertEquals("Z", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor5() {
		String sig = ReflectiveUtils.getFieldDescriptor(char.class);
		assertNotNull(sig);
		assertEquals("C", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor6() {
		String sig = ReflectiveUtils.getFieldDescriptor(double.class);
		assertNotNull(sig);
		assertEquals("D", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor7() {
		String sig = ReflectiveUtils.getFieldDescriptor(float.class);
		assertNotNull(sig);
		assertEquals("F", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor8() {
		String sig = ReflectiveUtils.getFieldDescriptor(void.class);
		assertNotNull(sig);
		assertEquals("V", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor9() {
		String sig = ReflectiveUtils.getFieldDescriptor(java.lang.Object.class);
		assertNotNull(sig);
		assertEquals("Ljava/lang/Object;", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor10() {
		String sig = ReflectiveUtils.getFieldDescriptor(stx.libjava.tests.mocks.ArrayValueAnnotation.class);
		assertNotNull(sig);
		assertEquals("Lstx/libjava/tests/mocks/ArrayValueAnnotation;", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor11() {
		String sig = ReflectiveUtils.getFieldDescriptor((new int[5]).getClass());
		assertNotNull(sig);
		assertEquals("[I", sig);	
	}
	
	/**
	 * ReflectiveUtils.getFieldDescriptor() method test.
	 */
	@Test
	public void test_getFieldDescriptor12() {
		String sig = ReflectiveUtils.getFieldDescriptor((new Object[5]).getClass());
		assertNotNull(sig);
		assertEquals("[Ljava/lang/Object;", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig() {
		String sig = ReflectiveUtils.getNameFromSig("I");
		assertNotNull(sig);
		assertEquals("int", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig1() {
		String sig = ReflectiveUtils.getNameFromSig("B");
		assertNotNull(sig);
		assertEquals("byte", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig2() {
		String sig = ReflectiveUtils.getNameFromSig("S");
		assertNotNull(sig);
		assertEquals("short", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig3() {
		String sig = ReflectiveUtils.getNameFromSig("J");
		assertNotNull(sig);
		assertEquals("long", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig4() {
		String sig = ReflectiveUtils.getNameFromSig("Z");
		assertNotNull(sig);
		assertEquals("boolean", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig5() {
		String sig = ReflectiveUtils.getNameFromSig("C");
		assertNotNull(sig);
		assertEquals("char", sig);	
	}
	
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig6() {
		String sig = ReflectiveUtils.getNameFromSig("D");
		assertNotNull(sig);
		assertEquals("double", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig7() {
		String sig = ReflectiveUtils.getNameFromSig("F");
		assertNotNull(sig);
		assertEquals("float", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig8() {
		String sig = ReflectiveUtils.getNameFromSig("V");
		assertNotNull(sig);
		assertEquals("void", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig9() {
		String sig = ReflectiveUtils.getNameFromSig("Lstx/libjava/tests/mocks/ArrayValueAnnotation;");
		assertNotNull(sig);
		assertEquals("stx.libjava.tests.mocks.ArrayValueAnnotation", sig);	
	}
	
	/**
	 * ReflectiveUtils.getNameFromSig() method test.
	 */
	@Test
	public void test_getNameFromSig10() {
		String sig = ReflectiveUtils.getNameFromSig("[Lstx/libjava/tests/mocks/ArrayValueAnnotation;");
		assertNotNull(sig);
		assertEquals("[Lstx.libjava.tests.mocks.ArrayValueAnnotation;", sig);	
	}
}
```


Overlapping Code:
```

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant() {
Object obj = ReflectiveUtils.getXConstant(new Byte((byte) 42));
assertNotNull(obj);
assertTrue(obj instanceof ByteConstant);
ByteConstant objAsBC = (ByteConstant) obj;
assertEquals(42, objAsBC.byteValue());
}

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant1() {
Object obj = ReflectiveUtils.getXConstant(new Short((short) 42));
assertNotNull(obj);
assertTrue(obj instanceof ShortConstant);
ShortConstant objAsSC = (ShortConstant) obj;
assertEquals(42, objAsSC.shortValue());
}

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant3() {
Object obj = ReflectiveUtils.getXConstant(new Integer((int) 42));
assertNotNull(obj);
assertTrue(obj instanceof IntConstant);
IntConstant objAsIC = (IntConstant) obj;
assertEquals(42, objAsIC.intValue());
} 

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant4() {
Object obj = ReflectiveUtils.getXConstant(new Long((long) 42));
assertNotNull(obj);
assertTrue(obj instanceof LongConstant);
LongConstant objAsLC = (LongConstant) obj;
assertEquals(42, objAsLC.longValue());
} 

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant5() {
Object obj = ReflectiveUtils.getXConstant(new Float((float) 42.42));
assertNotNull(obj);
assertTrue(obj instanceof FloatConstant);
FloatConstant objAsFC = (FloatConstant) obj;
assertEquals(42.42, objAsFC.floatValue(), 0.00002);
} 

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant6() {
Object obj = ReflectiveUtils.getXConstant(new Double((double) 42.42));
assertNotNull(obj);
assertTrue(obj instanceof DoubleConstant);
DoubleConstant objAsDC = (DoubleConstant) obj;
assertEquals(42.42, objAsDC.doubleValue(), 0.00002);
} 

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant7() {
Object obj = ReflectiveUtils.getXConstant(new Character((char) 'a'));
assertNotNull(obj);
assertTrue(obj instanceof CharConstant);
CharConstant objAsCC = (CharConstant) obj;
assertEquals('a', objAsCC.charValue());
}

/**
* ReflectiveUtils.getXConstant() method test.
*/
@Test
public void test_getXConstant8() {
Object obj = Refle
```
<Overlap Ratio: 0.9795831561037857>

---

--- 158 --
Question ID: d7d130924e27071ae6992cc90c60aaef859ab9a9
Original Code:
```
public class MetricsPublishTask extends TimerTask {
    private static final Logger LOGGER = LoggerFactory.getLogger(MetricsPublishTask.class);

    private final OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
    private final Gson gson = new Gson();
    private final Connection conn;

    public MetricsPublishTask(Connection conn) {
        this.conn = conn;
    }

    @Override
    public void run() {
        MetricsMessage metricsMessage = new MetricsMessage();
        metricsMessage.id = UUID.randomUUID().toString();
        metricsMessage.cpuPercentage = Math.round(osBean.getSystemCpuLoad() * 100.0) / 100.0;
        metricsMessage.totalPhysicalMemory = osBean.getTotalPhysicalMemorySize() / 1024 / 1024;
        metricsMessage.freePhysicalMemory = osBean.getFreePhysicalMemorySize() / 1024 / 1024;

        try {
            String msg = gson.toJson(metricsMessage);

            LOGGER.info("Publishing: " + msg);
            conn.publish("metrics-queue", gson.toJson(msg).getBytes());
        } catch (IOException e) {
            LOGGER.error("Error publishing metrics", e);
        }
    }

    /**
     * Message published to clients containing system metrics.
     */
    private static class MetricsMessage {
        String id;
        double cpuPercentage;
        double totalPhysicalMemory;
        double freePhysicalMemory;
    }
}
```


Overlapping Code:
```
ricsPublishTask extends TimerTask {
private static final Logger LOGGER = LoggerFactory.getLogger(MetricsPublishTask.class);
private final OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
private final Gson gson = new Gson();
private final Connection conn;
public MetricsPublishTask(Connection conn) {
this.conn = conn;
}
@Override
public void run() {
MetricsMessage metricsMessage = new MetricsMessage();
metricsMessage.id = UUID.randomUUID().toString();
metricsMessage.cpuPercentage = Math.round(osBean.getSystemCpuLoad() * 100.0) / 100.0;
metricsMessage.totalPhysicalMemory = osBean.getTotalPhysicalMemorySize() / 1024 / 1024;
metricsMessage.freePhysicalMemory = osBean.getFreePhysicalMemorySize() / 1024 / 1024;
try {
String msg = gson.toJson(metricsMessage);
LOGGER.info("Publishing: " + msg);
conn.publish("metrics-queue", gson.toJson(msg).getBytes());
} catch (IOException e) {
LOGGER.error("Error publishing metrics", e);
}
}
/**
* Message published to clients containing system metrics.
*/
private static class MetricsMessage {
String id;
double cpuPercentage;
double totalPhysicalMemory;
double freePhysicalMemory;

```
<Overlap Ratio: 0.984047019311503>

---

--- 159 --
Question ID: ee94ed59650d7bdb1cb15c5247d1e3990690ce94
Original Code:
```
class OrderedCode {
  // We want to encode a few extra symbols in strings:
  //      <sep>           Separator between items
  //      <infinity>      Infinite string
  //
  // Therefore we need an alphabet with at least 258 characters.  We
  // achieve this by using two-letter sequences starting with '\0' and '\xff'
  // as extra symbols:
  //      <sep>           encoded as =>           \0\1
  //      \0              encoded as =>           \0\xff
  //      \xff            encoded as =>           \xff\x00
  //      <infinity>      encoded as =>           \xff\xff
  //
  // The remaining two letter sequences starting with '\0' and '\xff'
  // are currently unused.

  static final byte ESCAPE1 = 0x00;
  static final byte NULL_CHARACTER = (byte) 0xff; // Combined with ESCAPE1
  static final byte SEPARATOR = 0x01; // Combined with ESCAPE1

  static final byte ESCAPE2 = (byte) 0xff;
  static final byte INFINITY = (byte) 0xff; // Combined with ESCAPE2
  static final byte FF_CHARACTER = 0x00; // Combined with ESCAPE2

  static final byte[] ESCAPE1_SEPARATOR = {ESCAPE1, SEPARATOR};

  static final byte[] INFINITY_ENCODED = {ESCAPE2, INFINITY};

  static final byte[] INFINITY_ENCODED_DECREASING = {invert(ESCAPE2), invert(INFINITY)};

  /**
   * This array maps encoding length to header bits in the first two bytes for SignedNumIncreasing
   * encoding.
   */
  private static final byte[][] LENGTH_TO_HEADER_BITS = {
    {0, 0},
    {(byte) 0x80, 0},
    {(byte) 0xc0, 0},
    {(byte) 0xe0, 0},
    {(byte) 0xf0, 0},
    {(byte) 0xf8, 0},
    {(byte) 0xfc, 0},
    {(byte) 0xfe, 0},
    {(byte) 0xff, 0},
    {(byte) 0xff, (byte) 0x80},
    {(byte) 0xff, (byte) 0xc0}
  };

  /**
   * This array maps encoding lengths to the header bits that overlap with the payload and need
   * fixing during readSignedNumIncreasing.
   */
  private static final long[] LENGTH_TO_MASK = {
    0L,
    0x80L,
    0xc000L,
    0xe00000L,
    0xf0000000L,
    0xf800000000L,
    0xfc0000000000L,
    0xfe000000000000L,
    0xff00000000000000L,
    0x8000000000000000L,
    0L
  };

  /**
   * This array maps the number of bits in a number to the encoding length produced by
   * WriteSignedNumIncreasing. For positive numbers, the number of bits is 1 plus the most
   * significant bit position (the highest bit position in a positive long is 63). For a negative
   * number n, we count the bits in ~n. That is, length = BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) +
   * 1].
   */
  private static final short[] BITS_TO_LENGTH = {
    1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8,
    9, 9, 9, 9, 9, 9, 9,
    10
  };

  // stores the current encoded value as a list of byte arrays. Note that this
  // is manipulated as we read/write items.
  // Note that every item will fit on at most one array. One array may
  // have more than one item (eg when used for decoding). While encoding,
  // one array will have exactly one item. While returning the encoded array
  // we will merge all the arrays in this list.
  private final ArrayList<byte[]> encodedArrays = new ArrayList<>();

  // This is the current position on the first array. Will be non-zero
  // only if the ordered code was created using encoded byte array.
  private int firstArrayPosition = 0;

  /** Creates OrderedCode from scratch. Typically used at encoding time. */
  public OrderedCode() {}

  /**
   * Creates OrderedCode from a given encoded byte array. Typically used at decoding time.
   *
   * <p><b> For better performance, it uses the input array provided (not a copy). Therefore the
   * input array should not be modified.</b>
   */
  public OrderedCode(byte[] encodedByteArray) {
    encodedArrays.add(encodedByteArray);
  }

  /**
   * Adds the given byte array item to the OrderedCode. It encodes the input byte array, followed by
   * a separator and appends the result to its internal encoded byte array store.
   *
   * <p>It works with the input array, so the input array 'value' should not be modified till the
   * method returns.
   *
   * @param value bytes to be written.
   * @see #readBytes()
   */
  public void writeBytes(byte[] value) {
    writeBytes(value, false);
  }

  public void writeBytesDecreasing(byte[] value) {
    writeBytes(value, true);
  }

  private void writeBytes(byte[] value, boolean invert) {
    // Determine the length of the encoded array
    int encodedLength = 2; // for separator
    for (byte b : value) {
      if ((b == ESCAPE1) || (b == ESCAPE2)) {
        encodedLength += 2;
      } else {
        encodedLength++;
      }
    }

    byte[] encodedArray = new byte[encodedLength];
    int copyStart = 0;
    int outIndex = 0;
    for (int i = 0; i < value.length; i++) {
      byte b = value[i];
      if (b == ESCAPE1) {
        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);
        outIndex += i - copyStart;
        encodedArray[outIndex++] = convert(invert, ESCAPE1);
        encodedArray[outIndex++] = convert(invert, NULL_CHARACTER);
        copyStart = i + 1;
      } else if (b == ESCAPE2) {
        arraycopy(invert, value, copyStart, encodedArray, outIndex, i - copyStart);
        outIndex += i - copyStart;
        encodedArray[outIndex++] = convert(invert, ESCAPE2);
        encodedArray[outIndex++] = convert(invert, FF_CHARACTER);
        copyStart = i + 1;
      }
    }
    if (copyStart < value.length) {
      arraycopy(invert, value, copyStart, encodedArray, outIndex, value.length - copyStart);
      outIndex += value.length - copyStart;
    }
    encodedArray[outIndex++] = convert(invert, ESCAPE1);
    encodedArray[outIndex] = convert(invert, SEPARATOR);

    encodedArrays.add(encodedArray);
  }

  private static byte convert(boolean invert, byte val) {
    return invert ? (byte) ~val : val;
  }

  private static byte invert(byte val) {
    return convert(true, val);
  }

  private void arraycopy(
      boolean invert, byte[] src, int srcPos, byte[] dest, int destPos, int length) {
    System.arraycopy(src, srcPos, dest, destPos, length);
    if (invert) {
      for (int i = destPos; i < destPos + length; i++) {
        dest[i] = (byte) ~dest[i];
      }
    }
  }

  /**
   * Encodes the long item, in big-endian format, and appends the result to its internal encoded
   * byte array store.
   *
   * @see #readNumIncreasing()
   */
  public void writeNumIncreasing(long value) {
    // Values are encoded with a single byte length prefix, followed
    // by the actual value in big-endian format with leading 0 bytes
    // dropped.
    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length
    int len = 0;
    while (value != 0) {
      len++;
      bufer[9 - len] = (byte) (value & 0xff);
      value >>>= 8;
    }
    bufer[9 - len - 1] = (byte) len;
    len++;
    byte[] encodedArray = new byte[len];
    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);
    encodedArrays.add(encodedArray);
  }

  public void writeNumIncreasing(UnsignedInteger unsignedInt) {
    writeNumIncreasing(unsignedInt.longValue());
  }

  /**
   * Encodes the long item, in big-endian format, and appends the result to its internal encoded
   * byte array store.
   *
   * @see #readNumIncreasing()
   */
  public void writeNumDecreasing(long value) {
    // Values are encoded with a complemented single byte length prefix,
    // followed by the complement of the actual value in big-endian format with
    // leading 0xff bytes dropped.
    byte[] bufer = new byte[9]; // 8 bytes for value plus one byte for length
    int len = 0;
    while (value != 0) {
      len++;
      bufer[9 - len] = (byte) ~(value & 0xff);
      value >>>= 8;
    }
    bufer[9 - len - 1] = (byte) ~len;
    len++;
    byte[] encodedArray = new byte[len];
    System.arraycopy(bufer, 9 - len, encodedArray, 0, len);
    encodedArrays.add(encodedArray);
  }

  public void writeNumDecreasing(UnsignedInteger unsignedInt) {
    writeNumDecreasing(unsignedInt.longValue());
  }

  /** Return floor(log2(n)) for positive integer n. Returns -1 iff n == 0. */
  @VisibleForTesting
  int log2Floor(long n) {
    checkArgument(n >= 0);
    return n == 0 ? -1 : LongMath.log2(n, RoundingMode.FLOOR);
  }

  /** Calculates the encoding length in bytes of the signed number n. */
  @VisibleForTesting
  int getSignedEncodingLength(long n) {
    return BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) + 1];
  }

  /** @see #readSignedNumIncreasing() */
  public void writeSignedNumIncreasing(long val) {
    long x = val < 0 ? ~val : val;
    if (x < 64) { // Fast path for encoding length == 1.
      byte[] encodedArray = new byte[] {(byte) (LENGTH_TO_HEADER_BITS[1][0] ^ val)};
      encodedArrays.add(encodedArray);
      return;
    }
    // buf = val in network byte order, sign extended to 10 bytes.
    byte signByte = val < 0 ? (byte) 0xff : 0;
    byte[] buf = new byte[2 + Longs.BYTES];
    buf[0] = buf[1] = signByte;
    System.arraycopy(Longs.toByteArray(val), 0, buf, 2, Longs.BYTES);
    int len = getSignedEncodingLength(x);
    if (len < 2) {
      throw new IllegalStateException(
          "Invalid length (" + len + ")" + " returned by getSignedEncodingLength(" + x + ")");
    }
    int beginIndex = buf.length - len;
    buf[beginIndex] ^= LENGTH_TO_HEADER_BITS[len][0];
    buf[beginIndex + 1] ^= LENGTH_TO_HEADER_BITS[len][1];

    byte[] encodedArray = new byte[len];
    System.arraycopy(buf, beginIndex, encodedArray, 0, len);
    encodedArrays.add(encodedArray);
  }

  public void writeSignedNumDecreasing(long val) {
    writeSignedNumIncreasing(~val);
  }

  /**
   * Encodes and appends INFINITY item to its internal encoded byte array store.
   *
   * @see #readInfinity()
   */
  public void writeInfinity() {
    writeTrailingBytes(INFINITY_ENCODED);
  }

  /**
   * Encodes and appends INFINITY item which would come before any real string.
   *
   * @see #readInfinityDecreasing()
   */
  public void writeInfinityDecreasing() {
    writeTrailingBytes(INFINITY_ENCODED_DECREASING);
  }

  /**
   * Appends the byte array item to its internal encoded byte array store. This is used for the last
   * item and is not encoded.
   *
   * <p>It stores the input array in the store, so the input array 'value' should not be modified.
   *
   * @param value bytes to be written.
   * @see #readTrailingBytes()
   */
  public void writeTrailingBytes(byte[] value) {
    if ((value == null) || (value.length == 0)) {
      throw new IllegalArgumentException("Value cannot be null or have 0 elements");
    }

    encodedArrays.add(value);
  }

  /**
   * Returns the next byte array item from its encoded byte array store and removes the item from
   * the store.
   *
   * @see #writeBytes(byte[])
   */
  public byte[] readBytes() {
    return readBytes(false);
  }

  public byte[] readBytesDecreasing() {
    return readBytes(true);
  }

  private byte[] readBytes(boolean invert) {
    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition <= 0)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    // Determine the length of the decoded array
    // We only scan up to "length-2" since a valid string must end with
    // a two character terminator: 'ESCAPE1 SEPARATOR'
    byte[] store = encodedArrays.get(0);
    int decodedLength = 0;
    boolean valid = false;
    int i = firstArrayPosition;
    while (i < store.length - 1) {
      byte b = store[i++];
      if (b == convert(invert, ESCAPE1)) {
        b = store[i++];
        if (b == convert(invert, SEPARATOR)) {
          valid = true;
          break;
        } else if (b == convert(invert, NULL_CHARACTER)) {
          decodedLength++;
        } else {
          throw new IllegalArgumentException("Invalid encoded byte array");
        }
      } else if (b == convert(invert, ESCAPE2)) {
        b = store[i++];
        if (b == convert(invert, FF_CHARACTER)) {
          decodedLength++;
        } else {
          throw new IllegalArgumentException("Invalid encoded byte array");
        }
      } else {
        decodedLength++;
      }
    }
    if (!valid) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    byte[] decodedArray = new byte[decodedLength];
    int copyStart = firstArrayPosition;
    int outIndex = 0;
    int j = firstArrayPosition;
    while (j < store.length - 1) {
      byte b = store[j++]; // note that j has been incremented
      if (b == convert(invert, ESCAPE1)) {
        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);
        outIndex += j - copyStart - 1;
        // ESCAPE1 SEPARATOR ends component
        // ESCAPE1 NULL_CHARACTER represents '\0'
        b = store[j++];
        if (b == convert(invert, SEPARATOR)) {
          if ((store.length - j) == 0) {
            // we are done with the first array
            encodedArrays.remove(0);
            firstArrayPosition = 0;
          } else {
            firstArrayPosition = j;
          }
          return decodedArray;
        } else if (b == convert(invert, NULL_CHARACTER)) {
          decodedArray[outIndex++] = 0x00;
        } // else not required - handled during length determination
        copyStart = j;
      } else if (b == convert(invert, ESCAPE2)) {
        arraycopy(invert, store, copyStart, decodedArray, outIndex, j - copyStart - 1);
        outIndex += j - copyStart - 1;
        // ESCAPE2 FF_CHARACTER represents '\xff'
        // ESCAPE2 INFINITY is an error
        b = store[j++];
        if (b == convert(invert, FF_CHARACTER)) {
          decodedArray[outIndex++] = (byte) 0xff;
        } // else not required - handled during length determination
        copyStart = j;
      }
    }
    // not required due to the first phase, but need to entertain the compiler
    throw new IllegalArgumentException("Invalid encoded byte array");
  }

  /**
   * Returns the next long item (encoded in big-endian format via {@code writeNumIncreasing(long)})
   * from its internal encoded byte array store and removes the item from the store.
   *
   * @see #writeNumIncreasing(long)
   */
  public long readNumIncreasing() {
    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    byte[] store = encodedArrays.get(0);
    // Decode length byte
    int len = store[firstArrayPosition];
    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    long result = 0;
    for (int i = 0; i < len; i++) {
      result <<= 8;
      result |= (store[firstArrayPosition + i + 1] & 0xff);
    }

    if ((store.length - firstArrayPosition - len - 1) == 0) {
      // we are done with the first array
      encodedArrays.remove(0);
      firstArrayPosition = 0;
    } else {
      firstArrayPosition = firstArrayPosition + len + 1;
    }

    return result;
  }

  /**
   * Returns the next long item (encoded in big-endian format via {@code writeNumDecreasing(long)})
   * from its internal encoded byte array store and removes the item from the store.
   *
   * @see #writeNumDecreasing(long)
   */
  public long readNumDecreasing() {
    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    byte[] store = encodedArrays.get(0);
    // Decode length byte
    int len = ~store[firstArrayPosition] & 0xff;
    if ((firstArrayPosition + len + 1 > store.length) || len > 8) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    long result = 0;
    for (int i = 0; i < len; i++) {
      result <<= 8;
      result |= (~store[firstArrayPosition + i + 1] & 0xff);
    }

    if ((store.length - firstArrayPosition - len - 1) == 0) {
      // we are done with the first array
      encodedArrays.remove(0);
      firstArrayPosition = 0;
    } else {
      firstArrayPosition = firstArrayPosition + len + 1;
    }

    return result;
  }

  /**
   * Returns the next long item (encoded via {@code writeSignedNumIncreasing(long)}) from its
   * internal encoded byte array store and removes the item from the store.
   *
   * @see #writeSignedNumIncreasing(long)
   */
  public long readSignedNumIncreasing() {
    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    byte[] store = encodedArrays.get(0);

    long xorMask = ((store[firstArrayPosition] & 0x80) == 0) ? ~0L : 0L;
    // Store first byte as an int rather than a (signed) byte -- to avoid
    // accidental byte-to-int promotion later which would extend the byte's
    // sign bit (if any).
    int firstByte = (store[firstArrayPosition] & 0xff) ^ (int) (xorMask & 0xff);

    // Now calculate and test length, and set x to raw (unmasked) result.
    int len;
    long x;
    if (firstByte != 0xff) {
      len = 7 - log2Floor(firstByte ^ 0xff);
      if (store.length - firstArrayPosition < len) {
        throw new IllegalArgumentException("Invalid encoded byte array");
      }
      x = xorMask; // Sign extend using xorMask.
      for (int i = firstArrayPosition; i < firstArrayPosition + len; i++) {
        x = (x << 8) | (store[i] & 0xff);
      }
    } else {
      len = 8;
      if (store.length - firstArrayPosition < len) {
        throw new IllegalArgumentException("Invalid encoded byte array");
      }
      int secondByte = (store[firstArrayPosition + 1] & 0xff) ^ (int) (xorMask & 0xff);
      if (secondByte >= 0x80) {
        if (secondByte < 0xc0) {
          len = 9;
        } else {
          int thirdByte = (store[firstArrayPosition + 2] & 0xff) ^ (int) (xorMask & 0xff);
          if (secondByte == 0xc0 && thirdByte < 0x80) {
            len = 10;
          } else {
            // Either len > 10 or len == 10 and #bits > 63.
            throw new IllegalArgumentException("Invalid encoded byte array");
          }
        }
        if (store.length - firstArrayPosition < len) {
          throw new IllegalArgumentException("Invalid encoded byte array");
        }
      }
      x =
          Longs.fromByteArray(
              Arrays.copyOfRange(store, firstArrayPosition + len - 8, firstArrayPosition + len));
    }

    x ^= LENGTH_TO_MASK[len]; // Remove spurious header bits.

    if (len != getSignedEncodingLength(x)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    if ((store.length - firstArrayPosition - len) == 0) {
      // We are done with the first array.
      encodedArrays.remove(0);
      firstArrayPosition = 0;
    } else {
      firstArrayPosition = firstArrayPosition + len;
    }

    return x;
  }

  public long readSignedNumDecreasing() {
    return ~readSignedNumIncreasing();
  }

  /**
   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether
   * INFINITY was present.
   *
   * @see #writeInfinity()
   */
  public boolean readInfinity() {
    return readInfinityInternal(INFINITY_ENCODED);
  }

  /**
   * Removes INFINITY item from its internal encoded byte array store if present. Returns whether
   * INFINITY was present.
   *
   * @see #writeInfinityDecreasing()
   */
  public boolean readInfinityDecreasing() {
    return readInfinityInternal(INFINITY_ENCODED_DECREASING);
  }

  private boolean readInfinityInternal(byte[] codes) {
    if (encodedArrays.isEmpty() || ((encodedArrays.get(0)).length - firstArrayPosition < 1)) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }
    byte[] store = encodedArrays.get(0);
    if (store.length - firstArrayPosition < 2) {
      return false;
    }
    if ((store[firstArrayPosition] == codes[0]) && (store[firstArrayPosition + 1] == codes[1])) {
      if ((store.length - firstArrayPosition - 2) == 0) {
        // we are done with the first array
        encodedArrays.remove(0);
        firstArrayPosition = 0;
      } else {
        firstArrayPosition = firstArrayPosition + 2;
      }
      return true;
    } else {
      return false;
    }
  }

  /**
   * Returns the trailing byte array item from its internal encoded byte array store and removes the
   * item from the store.
   *
   * @see #writeTrailingBytes(byte[])
   */
  public byte[] readTrailingBytes() {
    // one item is contained within one byte array
    if (encodedArrays.size() != 1) {
      throw new IllegalArgumentException("Invalid encoded byte array");
    }

    byte[] store = encodedArrays.get(0);
    encodedArrays.remove(0);
    assert encodedArrays.isEmpty();
    return Arrays.copyOfRange(store, firstArrayPosition, store.length);
  }

  /**
   * Returns the encoded bytes that represents the current state of the OrderedCode.
   *
   * <p><b> NOTE: This method returns OrederedCode's internal array (not a copy) for better
   * performance. Therefore the returned array should not be modified.</b>
   */
  public byte[] getEncodedBytes() {
    if (encodedArrays.isEmpty()) {
      return new byte[0];
    }
    if ((encodedArrays.size() == 1) && (firstArrayPosition == 0)) {
      return encodedArrays.get(0);
    }

    int totalLength = 0;

    for (int i = 0; i < encodedArrays.size(); i++) {
      byte[] bytes = encodedArrays.get(i);
      if (i == 0) {
        totalLength += bytes.length - firstArrayPosition;
      } else {
        totalLength += bytes.length;
      }
    }

    byte[] encodedBytes = new byte[totalLength];
    int destPos = 0;
    for (int i = 0; i < encodedArrays.size(); i++) {
      byte[] bytes = encodedArrays.get(i);
      if (i == 0) {
        System.arraycopy(
            bytes, firstArrayPosition, encodedBytes, destPos, bytes.length - firstArrayPosition);
        destPos += bytes.length - firstArrayPosition;
      } else {
        System.arraycopy(bytes, 0, encodedBytes, destPos, bytes.length);
        destPos += bytes.length;
      }
    }

    // replace the store with merged array, so that repeated calls
    // don't need to merge. The reads can handle both the versions.
    encodedArrays.clear();
    encodedArrays.add(encodedBytes);
    firstArrayPosition = 0;

    return encodedBytes;
  }

  /**
   * Returns true if it has more encoded bytes that haven't been read, false otherwise. Return value
   * of true doesn't imply anything about validity of remaining data.
   *
   * @return true if it has more encoded bytes that haven't been read, false otherwise.
   */
  public boolean hasRemainingEncodedBytes() {
    // We delete an array after fully consuming it.
    return encodedArrays.size() != 0;
  }
}
```


Overlapping Code:
```
lass OrderedCode {
// We want to encode a few extra symbols in strings:
// <sep> Separator between items
// <infinity> Infinite string
//
// Therefore we need an alphabet with at least 258 characters. We
// achieve this by using two-letter sequences starting with '\0' and '\xff'
// as extra symbols:
// <sep> encoded as => \0\1
// \0 encoded as => \0\xff
// \xff encoded as => \xff\x00
// <infinity> encoded as => \xff\xff
//
// The remaining two letter sequences starting with '\0' and '\xff'
// are currently unused.
static final byte ESCAPE1 = 0x00;
static final byte NULL_CHARACTER = (byte) 0xff; // Combined with ESCAPE1
static final byte SEPARATOR = 0x01; // Combined with ESCAPE1
static final byte ESCAPE2 = (byte) 0xff;
static final byte INFINITY = (byte) 0xff; // Combined with ESCAPE2
static final byte FF_CHARACTER = 0x00; // Combined with ESCAPE2
static final byte[] ESCAPE1_SEPARATOR = {ESCAPE1, SEPARATOR};
static final byte[] INFINITY_ENCODED = {ESCAPE2, INFINITY};
static final byte[] INFINITY_ENCODED_DECREASING = {invert(ESCAPE2), invert(INFINITY)};
/**
* This array maps encoding length to header bits in the first two bytes for SignedNumIncreasing
* encoding.
*/
private static final byte[][] LENGTH_TO_HEADER_BITS = {
{0, 0},
{(byte) 0x80, 0},
{(byte) 0xc0, 0},
{(byte) 0xe0, 0},
{(byte) 0xf0, 0},
{(byte) 0xf8, 0},
{(byte) 0xfc, 0},
{(byte) 0xfe, 0},
{(byte) 0xff, 0},
{(byte) 0xff, (byte) 0x80},
{(byte) 0xff, (byte) 0xc0}
};
/**
* This array maps encoding lengths to the header bits that overlap with the payload and need
* fixing during readSignedNumIncreasing.
*/
private static final long[] LENGTH_TO_MASK = {
0L,
0x80L,
0xc000L,
0xe00000L,
0xf0000000L,
0xf800000000L,
0xfc0000000000L,
0xfe000000000000L,
0xff00000000000000L,
0x8000000000000000L,
0L
};
/**
* This array maps the number of bits in a number to the encoding length produced by
* WriteSignedNumIncreasing. For positive numbers, the number of bits is 1 plus the most
* significant bit position (the highest bit position in a positive long is 63). For a negative
* number n, we count the bits in ~n. That is, length = BITS_TO_LENGTH[log2Floor(n < 0 ? ~n : n) +
* 1
```
<Overlap Ratio: 0.9876146788990826>

---

--- 160 --
Question ID: f621767f066b6046d9e13b34397549b0679c8668
Original Code:
```
public class AdViewPagerAdapter extends PagerAdapter{

    private List<ImageView> images;

    public AdViewPagerAdapter(List<ImageView> images){
        this.images = images;
    }

    @Override
    public int getCount(){
        return images.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object obj){
        return view == obj;
    }

    @Override
    public void destroyItem(ViewGroup view, int position, Object object){
        view.removeView(images.get(position));
    }

    @Override
    public Object instantiateItem(ViewGroup view, int position){
        // TODO Auto-generated method stub
        view.addView(images.get(position));
        return images.get(position);
    }
}
```


Overlapping Code:
```
AdViewPagerAdapter extends PagerAdapter{
private List<ImageView> images;
public AdViewPagerAdapter(List<ImageView> images){
this.images = images;
}
@Override
public int getCount(){
return images.size();
}
@Override
public boolean isViewFromObject(View view, Object obj){
return view == obj;
}
@Override
public void destroyItem(ViewGroup view, int position, Object object){
view.removeView(images.get(position));
}
@Override
public Object instantiateItem(ViewGroup view, int position){
// TODO Auto-generated method stub
view.addView(images.get(position));
return images.get(pos
```
<Overlap Ratio: 0.9600665557404326>

---

--- 161 --
Question ID: f755bec2228838a4e6a0ea76cc6ea865736e182a
Original Code:
```
public class SecurityInterceptors {

	public void basicAuthInterceptorRealm() {
		//START SNIPPET: basicAuthInterceptorRealm
		AuthenticationException ex = new AuthenticationException();
		ex.addAuthenticateHeaderForRealm("myRealm");
		throw ex;
		//END SNIPPET: basicAuthInterceptorRealm
	}

	// START SNIPPET: basicAuthInterceptor
	@Interceptor
	public class BasicSecurityInterceptor {

		/**
		 * This interceptor implements HTTP Basic Auth, which specifies that
		 * a username and password are provided in a header called Authorization.
		 */
		@Hook(Pointcut.SERVER_INCOMING_REQUEST_POST_PROCESSED)
		public boolean incomingRequestPostProcessed(RequestDetails theRequestDetails, HttpServletRequest theRequest, HttpServletResponse theResponse) throws AuthenticationException {
			String authHeader = theRequest.getHeader("Authorization");

			// The format of the header must be:
			// Authorization: Basic [base64 of username:password]
			if (authHeader == null || authHeader.startsWith("Basic ") == false) {
				throw new AuthenticationException("Missing or invalid Authorization header");
			}

			String base64 = authHeader.substring("Basic ".length());
			String base64decoded = new String(Base64.decodeBase64(base64));
			String[] parts = base64decoded.split(":");

			String username = parts[0];
			String password = parts[1];

			/*
			 * Here we test for a hardcoded username & password. This is
			 * not typically how you would implement this in a production
			 * system of course..
			 */
			if (!username.equals("someuser") || !password.equals("thepassword")) {
				throw new AuthenticationException("Invalid username or password");
			}

			// Return true to allow the request to proceed
			return true;
		}


	}
	//END SNIPPET: basicAuthInterceptor

}
```


Overlapping Code:
```
yInterceptors {
public void basicAuthInterceptorRealm() {
//START SNIPPET: basicAuthInterceptorRealm
AuthenticationException ex = new AuthenticationException();
ex.addAuthenticateHeaderForRealm("myRealm");
throw ex;
//END SNIPPET: basicAuthInterceptorRealm
}
// START SNIPPET: basicAuthInterceptor
@Interceptor
public class BasicSecurityInterceptor {
/**
* This interceptor implements HTTP Basic Auth, which specifies that
* a username and password are provided in a header called Authorization.
*/
@Hook(Pointcut.SERVER_INCOMING_REQUEST_POST_PROCESSED)
public boolean incomingRequestPostProcessed(RequestDetails theRequestDetails, HttpServletRequest theRequest, HttpServletResponse theResponse) throws AuthenticationException {
String authHeader = theRequest.getHeader("Authorization");
// The format of the header must be:
// Authorization: Basic [base64 of username:password]
if (authHeader == null || authHeader.startsWith("Basic ") == false) {
throw new AuthenticationException("Missing or invalid Authorization header");
}
String base64 = authHeader.substring("Basic ".length());
String base64decoded = new String(Base64.decodeBase64(base64));
String[] parts = base64decoded.split(":");
String username = parts[0];
String password = parts[1];
/*
* Here we test for a hardcoded username & password. This is
* not typically how you would implement this in a production
* system of course..
*/
if (!username.equals("someuser") || !password.equals({
throw new AuthenticationException("Invalid username or password");
}
// Return true to allow the request to proceed
return true;
}
}

```
<Overlap Ratio: 0.9559710494571774>

---

--- 162 --
Question ID: a0a830e37355c38527f0d1d22be7dc1be61724a9
Original Code:
```
@SuppressWarnings("WeakerAccess")
public class MavenRepositories {
    private static final String MAVEN_METADATA_FILE_NAME = "maven-metadata.xml";

    private MavenRepositories() {}

    /**
     * Finds the best matching {@link GradleCoordinate}.
     *
     * @param groupId      the artifact group id
     * @param artifactId   the artifact id
     * @param repository   the path to the m2repository directory
     * @param filter       an optional version filter that has to be satisfied by the matched coordinate
     * @param allowPreview whether preview versions are allowed to match
     * @return the best (highest version) matching coordinate, or null if none were found
     */
    @Nullable
    public static GradleCoordinate getHighestInstalledVersion(
            @NonNull String groupId,
            @NonNull String artifactId,
            @NonNull File repository,
            @Nullable Predicate<GradleVersion> filter,
            boolean allowPreview,
            @NonNull FileOp fileOp) {
        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);
        File[] versions = fileOp.listFiles(versionDir);
        GradleCoordinate maxVersion = null;
        for (File dir : versions) {
            if (!fileOp.isDirectory(dir)) {
                continue;
            }
            GradleCoordinate gc = GradleCoordinate.parseCoordinateString(
                    groupId + ":" + artifactId + ":" + dir.getName());

            if (gc != null && (allowPreview || !isPreview(gc))
                    && (maxVersion == null || COMPARE_PLUS_HIGHER.compare(gc, maxVersion) > 0)
                    && (applyVersionPredicate(gc.getRevision(), filter))) {
                maxVersion = gc;
            }
        }

        return maxVersion;
    }

    private static boolean applyVersionPredicate(@NonNull String revision,
            @Nullable Predicate<GradleVersion> predicate) {
        if (predicate == null) {
            return true;
        }
        GradleVersion version = GradleVersion.tryParse(revision);
        return version != null && predicate.test(version);
    }

    /**
     * Finds the best matching {@link GradleVersion}. Like
     * {@link #getHighestInstalledVersion(String, String, File, Predicate, boolean, FileOp)} but
     * operates on {@link GradleVersion} instead of {@link GradleCoordinate}.
     *
     * @param groupId      the artifact group id
     * @param artifactId   the artifact id
     * @param repository   the path to the m2repository directory
     * @param filter       an optional filter which the matched version must satisfy
     * @param allowPreview whether preview versions are allowed to match
     * @param fileOp       file operator to use for file access
     * @return the best (highest version) matching version, or null if none were found
     */
    @Nullable
    public static GradleVersion getHighestInstalledVersionNumber(
            @NonNull String groupId,
            @NonNull String artifactId,
            @NonNull File repository,
            @Nullable Predicate<GradleVersion> filter,
            boolean allowPreview,
            @NonNull FileOp fileOp) {
        File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);
        return getHighestVersion(versionDir, filter, allowPreview, fileOp);
    }

    /**
     * Given a directory containing version numbers returns the highest version number
     * matching the given filter
     *
     * @param versionDir   the directory containing version numbers
     * @param filter       an optional filter which the matched version must satisfy
     * @param allowPreview whether preview versions are allowed to match
     * @param fileOp       file operator to use for file access
     * @return the best (highest version), or null if none were found
     */
    @Nullable
    public static GradleVersion getHighestVersion(
            @NonNull File versionDir,
            @Nullable Predicate<GradleVersion> filter,
            boolean allowPreview, @NonNull FileOp fileOp) {
        File[] versionDirs = fileOp.listFiles(versionDir);
        GradleVersion maxVersion = null;
        for (File dir : versionDirs) {
            if (!fileOp.isDirectory(dir)) {
                continue;
            }
            String name = dir.getName();
            if (name.isEmpty() || !Character.isDigit(name.charAt(0))) {
                continue;
            }
            GradleVersion version = GradleVersion.tryParse(name);
            if (version != null && (allowPreview || !version.isPreview()
                    && (filter == null || filter.test(version)))
                    && (maxVersion == null || version.compareTo(maxVersion) > 0)) {
                maxVersion = version;
            }
        }

        return maxVersion;
    }

    /**
     * Decides whether a given {@link GradleCoordinate} is considered preview.
     *
     * <p>This is mostly compatible with {@link GradleCoordinate#isPreview()}, but there is one edge
     * case that we need to handle, related to Play Services. (See https://b.android.com/75292)
     */
    public static boolean isPreview(GradleCoordinate coordinate) {
        //noinspection SimplifiableIfStatement
        if (coordinate.isPreview()) {
            return true;
        }

        return "com.google.android.gms".equals(coordinate.getGroupId())
                && "play-services".equals(coordinate.getArtifactId())
                && "5.2.08".equals(coordinate.getRevision());
    }

    /**
     * Returns true if the group is an AndroidX group.
     *
     * @param groupId
     */
    public static boolean isAndroidX(@NonNull String groupId) {
        return groupId.startsWith("androidx.");
    }

    public static File getArtifactIdDirectory(
            @NonNull File repository,
            @NonNull String groupId,
            @NonNull String artifactId) {
        return new File(repository,
                groupId.replace('.', separatorChar) + separator + artifactId);
    }

    public static File getArtifactDirectory(
            @NonNull File repository,
            @NonNull GradleCoordinate coordinate) {
        File artifactIdDirectory = getArtifactIdDirectory(
                repository, coordinate.getGroupId(), coordinate.getArtifactId());

        return new File(artifactIdDirectory, coordinate.getRevision());
    }

    public static File getMavenMetadataFile(
            @NonNull File repository,
            @NonNull String groupId,
            @NonNull String artifactId) {
        return new File(getArtifactIdDirectory(repository, groupId, artifactId),
                MAVEN_METADATA_FILE_NAME);
    }
}
```


Overlapping Code:
```

public class MavenRepositories {
private static final String MAVEN_METADATA_FILE_NAME = "maven-metadata.xml";
private MavenRepositories() {}
/**
* Finds the best matching {@link GradleCoordinate}.
*
* @param groupId the artifact group id
* @param artifactId the artifact id
* @param repository the path to the m2repository directory
* @param filter an optional version filter that has to be satisfied by the matched coordinate
* @param allowPreview whether preview versions are allowed to match
* @return the best (highest version) matching coordinate, or null if none were found
*/
@Nullable
public static GradleCoordinate getHighestInstalledVersion(
@NonNull String groupId,
@NonNull String artifactId,
@NonNull File repository,
@Nullable Predicate<GradleVersion> filter,
boolean allowPreview,
@NonNull FileOp fileOp) {
File versionDir = getArtifactIdDirectory(repository, groupId, artifactId);
File[] versions = fileOp.listFiles(versionDir);
GradleCoordinate maxVersion = null;
for (File dir : versions) {
if (!fileOp.isDirectory(dir)) {
continue;
}
GradleCoordinate gc = GradleCoordinate.parseCoordinateString(
groupId + ":" + artifactId + ":" + dir.getName());
if (gc != null && (allowPreview || !isPreview(gc))
&& (maxVersion == null || COMPARE_PLUS_HIGHER.compare(gc, maxVersion) > 0)
&& (applyVersionPredicate(gc.getRevision(), filter))) {
maxVersion = gc;
}
}
return maxVersion;
}
private static boolean applyVersionPredicate(@NonNull String revision,
@Nullable Predicate<GradleVersion> predicate) {
if (predicate == null) {
return true;
}
GradleVersion version = GradleVersion.tryParse(revision);
return version != null && predicate.test(version);
}
/**
* Finds the best matching {@link GradleVersion}. Like
* {@link #getHighestInstalledVersion(String, String, File, Predicate, boolean, FileOp)} but
* operates on {@link GradleVersion} instead of {@link GradleCoordinate}.
*
* @param groupId the artifact group id
* @param artifactId the artifact id
* @param repository the pa
```
<Overlap Ratio: 0.9812345679012345>

---

--- 163 --
Question ID: 666806922449af44818ebd0d1a8edbe128833956
Original Code:
```
public class GooglePhotosService
    implements Exporter<PhotosModelWrapper>, Importer<PhotosModelWrapper> {

  private static final String CLIENT_NAME = "Portability";

  private final PicasawebService service;
  private final JobDataCache jobDataCache;

  public GooglePhotosService(Credential credential, JobDataCache jobDataCache) {
    this.jobDataCache = jobDataCache;
    this.service = new PicasawebService(CLIENT_NAME);
    this.service.setOAuth2Credentials(credential);
  }

  private static InputStream getImageAsStream(String urlStr) throws IOException {
    URL url = new URL(urlStr);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.connect();
    return conn.getInputStream();
  }

  @Override
  public PhotosModelWrapper export(ExportInformation exportInformation) throws IOException {
    if (exportInformation.getResource().isPresent()) {
      return exportPhotos(
          ((IdOnlyResource) exportInformation.getResource().get()).getId(),
          exportInformation.getPaginationInformation());
    } else {
      return exportAlbums(exportInformation.getPaginationInformation());
    }

  }

  private PhotosModelWrapper exportAlbums(Optional<PaginationInformation> pageInfo)
      throws IOException {
    URL albumUrl = new URL("https://picasaweb.google.com/data/feed/api/user/default?kind=album");

    UserFeed albumFeed;

    try {
      albumFeed = service.getFeed(albumUrl, UserFeed.class);
    } catch (ServiceException e) {
      throw new IOException("Problem making request to: " + albumUrl, e);
    }

    List<PhotoAlbum> albums = new ArrayList<>(albumFeed.getEntries().size());
    List<Resource> resources = new ArrayList<>(albumFeed.getEntries().size());

    for (GphotoEntry myAlbum : albumFeed.getEntries()) {
      // Adding sub-resources tells the framework to re-call
      // export to get all the photos.
      resources.add(new IdOnlyResource(myAlbum.getGphotoId()));
      // Saving data to the album allows the target service
      // to recreate the album structure.
      albums.add(new PhotoAlbum(
          myAlbum.getGphotoId(),
          myAlbum.getTitle().getPlainText(),
          myAlbum.getDescription().getPlainText()
      ));
    }

    return new PhotosModelWrapper(albums, null, new ContinuationInformation(resources, null));
  }

  private PhotosModelWrapper exportPhotos(
      String albumId, Optional<PaginationInformation> pageInfo) throws IOException {
    // imgmax=d gets the original immage as per:
    // https://developers.google.com/picasa-web/docs/2.0/reference
    URL photosUrl = new URL("https://picasaweb.google.com/data/feed/api/user/default/albumid/"
        + albumId + "?imgmax=d");
    AlbumFeed photoFeed;
    try {
      photoFeed = service.getFeed(photosUrl, AlbumFeed.class);
    } catch (ServiceException e) {
      throw new IOException("Problem making request to: " + photosUrl, e);
    }

    List<PhotoModel> photos = new ArrayList<>(photoFeed.getEntries().size());
    for (GphotoEntry photo : photoFeed.getEntries()) {
      MediaContent mediaContent = (MediaContent) photo.getContent();
      photos.add(new PhotoModel(
          photo.getTitle().getPlainText(),
          mediaContent.getUri(),
          photo.getDescription().getPlainText(),
          mediaContent.getMimeType().getMediaType(),
          albumId
      ));
    }

    return new PhotosModelWrapper(null, photos, new ContinuationInformation(null, null));
  }

  @Override
  public void importItem(PhotosModelWrapper wrapper) throws IOException {
    for (PhotoAlbum album : wrapper.getAlbums()) {
      if (true) {
        // Google doesn't support creating albums anymore
        continue;
      }
      AlbumEntry myAlbum = new AlbumEntry();

      myAlbum.setTitle(new PlainTextConstruct("copy of " + album.getName()));
      myAlbum.setDescription(new PlainTextConstruct(album.getDescription()));

      URL albumUrl = new URL(
          "https://picasaweb.google.com/data/feed/api/user/default");
      AlbumEntry insertedEntry;

      try {
        // https://developers.google.com/picasa-web/docs/2.0/developers_guide_java#AddAlbums
        insertedEntry = service.insert(albumUrl, myAlbum);
        jobDataCache.store(album.getId(), insertedEntry.getGphotoId());
      } catch (ServiceException e) {
        throw new IOException(
            "Problem copying" + album.getName() + " request to: " + albumUrl, e);
      }
    }

    for (PhotoModel photo : wrapper.getPhotos()) {
      //String newAlbumId = jobDataCache.getData(photo.getAlbumId(), String.class);
      String newAlbumId = "default";
      URL photoPostUrl = new URL("https://picasaweb.google.com/data/feed/api/user/default/albumid/"
          + newAlbumId);

      PhotoEntry myPhoto = new PhotoEntry();
      myPhoto.setTitle(new PlainTextConstruct("copy of " + photo.getTitle()));
      myPhoto.setDescription(new PlainTextConstruct(photo.getDescription()));
      myPhoto.setClient(CLIENT_NAME);

      String mediaType = photo.getMediaType();

      if (mediaType == null) {
        mediaType = "image/jpeg";
      }

      MediaStreamSource streamSource = new MediaStreamSource(
          getImageAsStream(photo.getFetchableUrl()),
          mediaType);
      myPhoto.setMediaSource(streamSource);

      try {
        service.insert(photoPostUrl, myPhoto);
      } catch (ServiceException e) {
        throw new IOException("Problem adding " + photo.getTitle() + " to "
            + newAlbumId, e);
      }
    }
  }
}
```


Overlapping Code:
```
blic class GooglePhotosService
implements Exporter<PhotosModelWrapper>, Importer<PhotosModelWrapper> {
private static final String CLIENT_NAME = "Portability";
private final PicasawebService service;
private final JobDataCache jobDataCache;
public GooglePhotosService(Credential credential, JobDataCache jobDataCache) {
this.jobDataCache = jobDataCache;
this.service = new PicasawebService(CLIENT_NAME);
this.service.setOAuth2Credentials(credential);
}
private static InputStream getImageAsStream(String urlStr) throws IOException {
URL url = new URL(urlStr);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.connect();
return conn.getInputStream();
}
@Override
public PhotosModelWrapper export(ExportInformation exportInformation) throws IOException {
if (exportInformation.getResource().isPresent()) {
return exportPhotos(
((IdOnlyResource) exportInformation.getResource().get()).getId(),
exportInformation.getPaginationInformation());
} else {
return exportAlbums(exportInformation.getPaginationInformation());
}
}
private PhotosModelWrapper exportAlbums(Optional<PaginationInformation> pageInfo)
throws IOException {
URL albumUrl = new URL("https://picasaweb.google.com/data/feed/api/user/default?kind=album");
UserFeed albumFeed;
try {
albumFeed = service.getFeed(albumUrl, UserFeed.class);
} catch (ServiceException e) {
throw new IOException("Problem making request to: " + albumUrl, e);
}
List<PhotoAlbum> albums = new ArrayList<>(albumFeed.getEntries().size());
List<Resource> resources = new ArrayList<>(albumFeed.getEntries().size());
for (GphotoEntry myAlbum : albumFeed.getEntries()) {
// Adding sub-resources tells the framework to re-call
// export to get all the photos.
resources.add(new IdOnlyResource(myAlbum.getGphotoId()));
// Saving data to the album allows the target service
// to recreate the album structure.
albums.add(new PhotoAlbum(
myAlbum.getGphotoId(),
myAlbum.getTitle().getPlainText(),
myAlbum.getDescription().getPlainText()
));
}
return new PhotosModelWrapper(albums, null, new ContinuationInformation(resources, null));
}
private PhotosModelWrapper exportPhotos(
String albumId, Optional<PaginationInformation> pageInfo) throws IOException {
// imgmax=d gets the orig
```
<Overlap Ratio: 0.992866696388765>

---

--- 164 --
Question ID: f8ec9fca2e74b41fa164e2bc4a24848c9a8b33d2
Original Code:
```
public class WriteStreamDataprocServerlessAcceptanceTestBase
    extends DataprocServerlessAcceptanceTestBase {

  public WriteStreamDataprocServerlessAcceptanceTestBase(String connectorJarPrefix) {
    super(connectorJarPrefix);
  }

  @Test
  public void testBatch() throws Exception {
    String testName = "write-stream-test";
    String jsonFileName = "write_stream_data.json";
    String jsonFileUri = context.testBaseGcsDir + "/" + testName + "/json/" + jsonFileName;

    AcceptanceTestUtils.uploadToGcs(
        getClass().getResourceAsStream("/acceptance/" + jsonFileName),
        jsonFileUri,
        "application/json");

    OperationSnapshot operationSnapshot =
        createAndRunPythonBatch(
            context,
            testName,
            "write_stream.py",
            null,
            Arrays.asList(
                context.testBaseGcsDir + "/" + testName + "/json/",
                context.bqDataset,
                context.bqStreamTable,
                AcceptanceTestUtils.BUCKET),
            240);
    assertThat(operationSnapshot.isDone()).isTrue();
    assertThat(operationSnapshot.getErrorMessage()).isEmpty();

    int numOfRows = getNumOfRowsOfBqTable(context.bqDataset, context.bqStreamTable);
    assertThat(numOfRows).isEqualTo(2);
  }
}
```


Overlapping Code:
```
erverlessAcceptanceTestBase
extends DataprocServerlessAcceptanceTestBase {
public WriteStreamDataprocServerlessAcceptanceTestBase(String connectorJarPrefix) {
super(connectorJarPrefix);
}
@Test
public void testBatch() throws Exception {
String testName = "write-stream-test";
String jsonFileName = "write_stream_data.json";
String jsonFileUri = context.testBaseGcsDir + "/" + testName + "/json/" + jsonFileName;
AcceptanceTestUtils.uploadToGcs(
getClass().getResourceAsStream("/acceptance/" + jsonFileName),
jsonFileUri,
"application/json");
OperationSnapshot operationSnapshot =
createAndRunPythonBatch(
context,
testName,
"write_stream.py",
null,
Arrays.asList(
context.testBaseGcsDir + "/" + testName + "/json/",
context.bqDataset,
context.bqStreamTable,
AcceptanceTestUtils.BUCKET),
240);
assertThat(operationSnapshot.isDone()).isTrue();
assertThat(operationSnapshot.getErrorMessage()).isEmpty();
int numOfRows = getNumOfRowsOfBqTable(context.bqDataset, context.bqStreamTable);
assertThat(numOfRows).isEqual
```
<Overlap Ratio: 0.959203036053131>

---

--- 165 --
Question ID: 3f22a92eb951ac54b1096a40b24bdfe73c5f1fc3
Original Code:
```
public class SidePanel extends UiPart<Region> {
    private static final String FXML = "SidePanel.fxml";
    private static final int MODULE_ROW_HEIGHT = 32;
    private final Logger logger = LogsCenter.getLogger(SidePanel.class);
    private final Consumer<ArrayList<Object>> tabConsumer;
    private final Logic logic;
    private Button selectedTabButton;

    @FXML
    private Button upcomingButton;

    @FXML
    private Button contactButton;

    @FXML
    private ListView<Module> moduleListView;

    @FXML
    private Button helpButton;


    /**
     * Constructor for SidePanel
     *
     * @param tabConsumer carries values to MainWindow
     */
    public SidePanel(Consumer<ArrayList<Object>> tabConsumer, Logic logic) {
        super(FXML);
        this.tabConsumer = tabConsumer;
        this.logic = logic;
        initialize();
    }

    /**
     * Initialises/reloads the tab buttons in the side panel.
     */
    public void initialize() {
        if (logic != null) {
            // Get modules tab buttons.
            ObservableList<Module> modules = logic.getFilteredModuleList();
            moduleListView.setPrefHeight(modules.size() * MODULE_ROW_HEIGHT);
            moduleListView.setItems(modules);
            moduleListView.setCellFactory(listView -> new ModuleListViewCell());

            // Set Default tab as upcoming tab.
            selectedTabButton = upcomingButton;
            updateButtonDetails(upcomingButton);
        }
    }

    /**
     * Relays message to MainWindow to get Upcoming panel information in TabPanel.
     */
    public void toggleUpcomingTab() {
        ArrayList<Object> upcomingValues = new ArrayList<>(Arrays.asList((Object) UpcomingPanel.TYPE));
        updateButtonDetails(upcomingButton);
        tabConsumer.accept(upcomingValues);
    }

    /**
     * Relays message to MainWindow to get Contact panel information in TabPanel.
     */
    public void toggleContactTab() {
        ArrayList<Object> contactValues = new ArrayList<>(Arrays.asList((Object) Contact.TYPE));
        updateButtonDetails(contactButton);
        tabConsumer.accept(contactValues);
    }

    /**
     * Relays message to MainWindow to get Help tab information in TabPanel.
     */
    public void toggleHelpTab() {
        ArrayList<Object> helpValues = new ArrayList<>(Arrays.asList((Object) HelpPanel.TYPE));
        updateButtonDetails(helpButton);
        tabConsumer.accept(helpValues);
    }

    /**
     * Colors the help button when help command is entered
     */
    public void updateHelpButton() {
        updateButtonDetails(helpButton);
    }

    /**
     * Updates the details of the current selected tab button.
     *
     * @param button The new selected tab button.
     */
    public void updateButtonDetails(Button button) {
        selectedTabButton.setStyle("-fx-text-fill: white;");
        selectedTabButton = button;
        selectedTabButton.setStyle("-fx-text-fill: #68C2E8;");
    }

    /**
     * Configure the module section that will include the module button as well as a coloured module circle label.
     *
     * @return HBox The module section.
     */
    public HBox getModuleSection() {
        HBox moduleSection = new HBox();
        moduleSection.setAlignment(Pos.CENTER_LEFT);
        moduleSection.setPadding(new Insets(0, 0, 0, 10));
        return moduleSection;
    }

    /**
     * Configure the module button tab in the side panel.
     *
     * @return moduleButton The module button.
     */
    public Button getModuleButton(Module module) {
        Button button = new Button(module.getCode().code);
        ArrayList<Object> moduleValues = new ArrayList<>(Arrays.asList(Module.TYPE, module));
        button.setOnAction(actionEvent -> {
            updateButtonDetails(button);
            tabConsumer.accept(moduleValues);
        });
        button.setPadding(new Insets(5));
        return button;
    }

    /**
     * Configure the coloured module circle that is displayed beside the module code.
     *
     * @return moduleCircle The module circle.
     */
    public Circle getModuleCircle(Module module, Logic logic) throws CommandException {
        Circle moduleCircle = new Circle(0, 0, 6);
        int moduleIndex = logic.getModuleIndex(module).getZeroBased();
        moduleCircle.setFill(Module.COLORS.get(moduleIndex % 10));
        return moduleCircle;
    }

    /**
     * Sets the view of the module tab in the side panel.
     */
    class ModuleListViewCell extends ListCell<Module> {
        @Override
        protected void updateItem(Module module, boolean empty) {
            super.updateItem(module, empty);

            if (empty || module == null) {
                setGraphic(null);
                setText(null);
            } else {
                try {
                    HBox moduleSection = getModuleSection();
                    Button updatedButton = getModuleButton(module);
                    Circle moduleCircle = getModuleCircle(module, logic);
                    moduleSection.getChildren().add(moduleCircle);
                    moduleSection.getChildren().add(updatedButton);
                    setGraphic(moduleSection);

                } catch (CommandException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```


Overlapping Code:
```
ePanel extends UiPart<Region> {
private static final String FXML = "SidePanel.fxml";
private static final int MODULE_ROW_HEIGHT = 32;
private final Logger logger = LogsCenter.getLogger(SidePanel.class);
private final Consumer<ArrayList<Object>> tabConsumer;
private final Logic logic;
private Button selectedTabButton;
@FXML
private Button upcomingButton;
@FXML
private Button contactButton;
@FXML
private ListView<Module> moduleListView;
@FXML
private Button helpButton;
/**
* Constructor for SidePanel
*
* @param tabConsumer carries values to MainWindow
*/
public SidePanel(Consumer<ArrayList<Object>> tabConsumer, Logic logic) {
super(FXML);
this.tabConsumer = tabConsumer;
this.logic = logic;
initialize();
}
/**
* Initialises/reloads the tab buttons in the side panel.
*/
public void initialize() {
if (logic != null) {
// Get modules tab buttons.
ObservableList<Module> modules = logic.getFilteredModuleList();
moduleListView.setPrefHeight(modules.size() * MODULE_ROW_HEIGHT);
moduleListView.setItems(modules);
moduleListView.setCellFactory(listView -> new ModuleListViewCell());
// Set Default tab as upcoming tab.
selectedTabButton = upcomingButton;
updateButtonDetails(upcomingButton);
}
}
/**
* Relays message to MainWindow to get Upcoming panel information in TabPanel.
*/
public void toggleUpcomingTab() {
ArrayList<Object> upcomingValues = new ArrayList<>(Arrays.asList((Object) UpcomingPanel.TYPE));
updateButtonDetails(upcomingButton);
tabConsumer.accept(upcomingValues);
}
/**
* Relays message to MainWindow to get Contact panel information in TabPanel.
*/
public void toggleContactTab() {
ArrayList<Object> contactValues = new ArrayList<>(Arrays.asList((Object) Contact.TYPE));
updateButtonDetails(contactButton);
tabConsumer.accept(contactValues);
}
/**
* Relays message to MainWindow to get Help tab information in TabPanel.
*/
public void toggleHelpTab() {
ArrayList<Object> helpValues = new ArrayList<>(Arrays.asList((Object) HelpPanel.TYPE));
updateButtonDetails(helpButton);
tabConsumer.accept(helpValues);
}
/**
* Colors the help button 
```
<Overlap Ratio: 0.9880153403643337>

---

--- 166 --
Question ID: 77a41e5bea116a1dac519e71d6d2b359c24c3e3a
Original Code:
```
public class leet125 {
    public static void main(String[] args) {
        String a="A man, a plan, a canal: Panama";
        String b="`l;`` 1o1 ??;l`";
//        System.out.println(isPalindrome(a));
        System.out.println(isPalindrome(b));

    }
    public static boolean isPalindrome(String s) {
        if(s.length()==0){
            return true;
        }
        String s0=s.replaceAll("[\\pP\\p{Punct}]","");
        StringBuilder s1= new StringBuilder();
        for(int i=0;i<s0.length();i++){
            String ss=s0.substring(i,i+1).toLowerCase();
            if(!ss.equals(" ")&&!ss.equals("''")){
               s1.append(ss);
            }
        }
        StringBuilder s2=new StringBuilder(s1.toString());
        StringBuilder s3=s2.reverse();
        String       s4=new String(s3);

        return s1.toString().equals(s4);
    }
}
```


Overlapping Code:
```
125 {
public static void main(String[] args) {
String a="A man, a plan, a canal: Panama";
String b="`l;`` 1o1 ??;l`";
// System.out.println(isPalindrome(a));
System.out.println(isPalindrome(b));
}
public static boolean isPalindrome(String s) {
if(s.length()==0){
return true;
}
String s0=s.replaceAll("[\\pP\\p{Punct}]","");
StringBuilder s1= new StringBuilder();
for(int i=0;i<s0.length();i++){
String ss=s0.substring(i,i+1).toLowerCase();
if(!ss.equals(" ")&&!ss.equals("''")){
s1.append(ss);
}
}
StringBuilder s2=new StringBuilder(s1.toString());
StringBuilder s3=s2.reverse();
String s4=new Strin
```
<Overlap Ratio: 0.9090909090909091>

---

--- 167 --
Question ID: 8f562c77f7141a4538231d77819cd6f7fdaf05a6
Original Code:
```
public class KmSpo2Task extends AsyncTask<Void,Void,Void> {

    private static final String TAG = "KmSpo2Task";


    private String deviceCode = null;
    private String currDay = WatchUtils.getCurrentDate();
    private String userId = null;

    private Gson gson = new Gson();

    private NohttpUtils nohttpUtils;


    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        deviceCode = MyApp.getInstance().getMacAddress();
        userId = (String) SharedPreferencesUtils.readObject(MyApp.getContext(), Commont.USER_ID_DATA);
        nohttpUtils = NohttpUtils.getNoHttpUtils();
    }

    @Override
    protected Void doInBackground(Void... voids) {

        if(deviceCode == null || userId == null)
            return null;
        findSpo2Data(deviceCode);

        return null;
    }

    private void findSpo2Data(String deviceCode) {
        String where = "bleMac = ? and dateStr = ?";
        List<B31Spo2hBean> currList = LitePal.where(where,deviceCode,
                currDay).find(B31Spo2hBean.class);
        if(currList == null)
            return;
        //血氧
        List<Map<String,Object>> spo2List = new ArrayList<>();

        //呼吸率
        List<Map<String,Object>> breatheRateList = new ArrayList<>();


        for(B31Spo2hBean b31Spo2hBean : currList){
            Spo2hOriginData spo2hOriginData = gson.fromJson(b31Spo2hBean.getSpo2hOriginData(),Spo2hOriginData.class);
            Map<String,Object> map = new HashMap<>();
            map.put("AccountId",userId);
            map.put("DeviceCode",deviceCode);
            map.put("Bo",spo2hOriginData.getOxygenValue());
            map.put("TestTime",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());
            spo2List.add(map);



            Map<String,Object> map2 = new HashMap<>();
            map2.put("AccountId",userId);
            map2.put("DeviceCode",deviceCode);
            map2.put("Value",spo2hOriginData.getRespirationRate());
            map2.put("TestTime",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());
            breatheRateList.add(map2);


        }

        //上传血氧
        if(spo2List.size()>0){
            String spo2Url = KmConstance.uploadBloodOxygen();
            nohttpUtils.getModelRequestJSONObject(0x01,spo2Url,gson.toJson(spo2List),onResponseListener);
        }

        if(breatheRateList.size()>0){
            String breathRatesUrl = KmConstance.uploadSpo2BreathRates();
            nohttpUtils.getModelRequestJSONObject(0x02,breathRatesUrl,gson.toJson(breatheRateList),onResponseListener);

        }

    }


    @Override
    protected void onPostExecute(Void aVoid) {
        super.onPostExecute(aVoid);
        if(nohttpUtils != null)
            nohttpUtils.cancleHttpPost();
    }

    @Override
    protected void onCancelled(Void aVoid) {
        super.onCancelled(aVoid);

    }

    @Override
    protected void onCancelled() {
        super.onCancelled();

    }

    private OnResponseListener<JSONObject> onResponseListener = new OnResponseListener<JSONObject>() {
        @Override
        public void onStart(int what) {

        }

        @Override
        public void onSucceed(int what, Response<JSONObject> response) {
            //Log.e(TAG,"------what="+what+"---response="+response.get());
        }

        @Override
        public void onFailed(int what, Response<JSONObject> response) {

        }

        @Override
        public void onFinish(int what) {

        }
    };
}
```


Overlapping Code:
```
mSpo2Task extends AsyncTask<Void,Void,Void> {
private static final String TAG = "KmSpo2Task";
private String deviceCode = null;
private String currDay = WatchUtils.getCurrentDate();
private String userId = null;
private Gson gson = new Gson();
private NohttpUtils nohttpUtils;
@Override
protected void onPreExecute() {
super.onPreExecute();
deviceCode = MyApp.getInstance().getMacAddress();
userId = (String) SharedPreferencesUtils.readObject(MyApp.getContext(), Commont.USER_ID_DATA);
nohttpUtils = NohttpUtils.getNoHttpUtils();
}
@Override
protected Void doInBackground(Void... voids) {
if(deviceCode == null || userId == null)
return null;
findSpo2Data(deviceCode);
return null;
}
private void findSpo2Data(String deviceCode) {
String where = "bleMac = ? and dateStr = ?";
List<B31Spo2hBean> currList = LitePal.where(where,deviceCode,
currDay).find(B31Spo2hBean.class);
if(currList == null)
return;
//血氧
List<Map<String,Object>> spo2List = new ArrayList<>();
//呼吸率
List<Map<String,Object>> breatheRateList = new ArrayList<>();
for(B31Spo2hBean b31Spo2hBean : currList){
Spo2hOriginData spo2hOriginData = gson.fromJson(b31Spo2hBean.getSpo2hOriginData(),Spo2hOriginData.class);
Map<String,Object> map = new HashMap<>();
map.put("AccountId",userId);
map.put("DeviceCode",deviceCode);
map.put("Bo",spo2hOriginData.getOxygenValue());
map.put("TestTime",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());
spo2List.add(map);
Map<String,Object> map2 = new HashMap<>();
map2.put("AccountId",userId);
map2.put("DeviceCode",deviceCode);
map2.put("Value",spo2hOriginData.getRespirationRate());
map2.put("TestTime",spo2hOriginData.getmTime().getDateAndClockForSleepSecond());
breatheRateList.add(map2);
}
//上传血氧
if(spo2List.size()>0){
String spo2Url = KmConstance.uploadBloodOxygen();
nohttpUtils.getModelRequestJSONObject(0x01,spo2Url,gson.toJson(spo2List),onResponseListener);
}
if(breatheRateList.size()>0){
String breathRatesUrl = KmConstance.uploadSpo2BreathRates();
nohttpUtils.getModelRequestJ
```
<Overlap Ratio: 0.9891196834817013>

---

--- 168 --
Question ID: 30a3925b18a09100470333dd45e84f4cebf2057a
Original Code:
```
@ApplicationScoped
public class StudyFormBean {

    @PersistenceContext(unitName = "sis-jpa")
    private EntityManager em;

    @Transactional
    public List<StudyForm> getStudyForms(QueryParameters query) {
        return JPAUtils.queryEntities(em, StudyForm.class, query);
    }

    @Transactional
    public List<StudyForm> getStudyForms(QueryParameters query, String searchQuery) {
        if(searchQuery == null) return getStudyForms(query);
        return JPAUtils.queryEntities(em, StudyForm.class, query, new SearchAllCriteriaFilter<>(searchQuery));
    }

    @Transactional
    public StudyForm getStudyForm(int id) {
        StudyForm c = em.find(StudyForm.class, id);
        if(c == null) throw new NoResultException("No study kind by this id");
        return c;
    }

    @Transactional
    public boolean existsStudyForm(int id) {
        return em.find(StudyForm.class, id) != null;
    }

    @Transactional
    public StudyForm insertStudyForm(StudyForm c) {
        em.persist(c);
        em.flush();
        return c;
    }

    @Transactional
    public void deleteStudyForm(int id) {
        StudyForm c = em.find(StudyForm.class, id);
        if(c != null) {
            c.setDeleted(!c.getDeleted());
            em.merge(c);
        } else {
            throw new NoResultException("Course by ID doesn't exist");
        }
    }

    @Transactional
    public StudyForm updateStudyForm(StudyForm c) {
        em.merge(c);
        em.flush();
        return c;
    }

}
```


Overlapping Code:
```
ss StudyFormBean {
@PersistenceContext(unitName = "sis-jpa")
private EntityManager em;
@Transactional
public List<StudyForm> getStudyForms(QueryParameters query) {
return JPAUtils.queryEntities(em, StudyForm.class, query);
}
@Transactional
public List<StudyForm> getStudyForms(QueryParameters query, String searchQuery) {
if(searchQuery == null) return getStudyForms(query);
return JPAUtils.queryEntities(em, StudyForm.class, query, new SearchAllCriteriaFilter<>(searchQuery));
}
@Transactional
public StudyForm getStudyForm(int id) {
StudyForm c = em.find(StudyForm.class, id);
if(c == null) throw new NoResultException("No study kind by this id");
return c;
}
@Transactional
public boolean existsStudyForm(int id) {
return em.find(StudyForm.class, id) != null;
}
@Transactional
public StudyForm insertStudyForm(StudyForm c) {
em.persist(c);
em.flush();
return c;
}
@Transactional
public void deleteStudyForm(int id) {
StudyForm c = em.find(StudyForm.class, id);
if(c != null) {
c.setDeleted(!c.getDeleted());
em.merge(c);
} else {
throw new NoResultException("Course by ID doesn't exist");
}
}
@Transactional
public StudyForm updateStudyForm(StudyF
```
<Overlap Ratio: 0.9380097879282219>

---

--- 169 --
Question ID: 4f1e4fe64b2e12389d031851155adfb02631bf92
Original Code:
```
public abstract class AbstractBitcoinNetParams extends NetworkParameters {

    /**
     * Scheme part for Bitcoin URIs.
     */
    public static final String BITCOIN_SCHEME = "bitcore";
    public static final int REWARD_HALVING_INTERVAL = 210000;

    private static final Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class);

    private static final BigInteger MASK256BIT = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    private static final int FORK1_HEIGHT = 10000;
    private static final int FORK2_HEIGHT = 21000;


    public AbstractBitcoinNetParams() {
        super();
    }

    /**
     * Checks if we are at a difficulty transition point.
     * @param height The height of the previous stored block
     * @return If this is a difficulty transition point
     */
    public final boolean isDifficultyTransitionPoint(final int height) {
        if (height > FORK2_HEIGHT)
            return ((height + 1) % this.getInterval2()) == 0;
        else
            return ((height + 1) % this.getInterval()) == 0;
    }

    @Override
    public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,
    	final BlockStore blockStore) throws VerificationException, BlockStoreException {
        if ((storedPrev.getHeight()+1) <= FORK1_HEIGHT) {
            DUAL_KGW3(storedPrev, nextBlock, blockStore);
        } else {
            final Block prev = storedPrev.getHeader();

            // Is this supposed to be a difficulty transition point?
            if (!isDifficultyTransitionPoint(storedPrev.getHeight())) {

                // No ... so check the difficulty didn't actually change.
                if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())
                    throw new VerificationException("Unexpected change in difficulty at height " + storedPrev.getHeight() +
                            ": " + Long.toHexString(nextBlock.getDifficultyTarget()) + " vs " +
                            Long.toHexString(prev.getDifficultyTarget()));
                return;
            }

            // We need to find a block far back in the chain. It's OK that this is expensive because it only occurs every
            // two weeks after the initial block chain download.
            Sha256Hash hash = prev.getHash();
            StoredBlock cursor = null;
            int interval = 0;
            if (storedPrev.getHeight() > FORK2_HEIGHT)
                interval = this.getInterval2()+1;
            else
                interval = this.getInterval()+1;

            for (int i = 0; i < interval; i++) {
                cursor = blockStore.get(hash);
                if (cursor == null) {
                    // we my have no enough blocks here
                    return;
                }
                hash = cursor.getHeader().getPrevBlockHash();
            }

            Block blockIntervalAgo = cursor.getHeader();
            int timespan = (int) (prev.getTimeSeconds() - blockIntervalAgo.getTimeSeconds());
            // Limit the adjustment step.
            int targetTimespan = 0;
            double factor = 0.0;
            if (storedPrev.getHeight() > FORK2_HEIGHT) {
                targetTimespan = this.getTargetTimespan2();
                factor = 1.15;
            } else {
                targetTimespan = this.getTargetTimespan();
                factor = 4.0;
            }

            if (timespan < (int)((double)targetTimespan / factor))
                timespan = (int)((double)targetTimespan / factor );
            if (timespan > (int)((double)targetTimespan * factor))
                timespan = (int)((double)targetTimespan * factor );

            BigInteger newTarget = Utils.decodeCompactBits(prev.getDifficultyTarget());
            newTarget = newTarget.multiply(BigInteger.valueOf(timespan));
            newTarget = newTarget.divide(BigInteger.valueOf(targetTimespan));

            if (newTarget.compareTo(this.getMaxTarget()) > 0) {
                log.info("Difficulty hit proof of work limit: {}", newTarget.toString(16));
                newTarget = this.getMaxTarget();
            }

            verifyDifficulty(newTarget, storedPrev, nextBlock);
        }
    }

    private void DUAL_KGW3(StoredBlock storedPrev, Block nextBlock, final BlockStore blockStore)
      throws BlockStoreException, VerificationException {
        final long Blocktime = 96 * 6; // = 9.6 * 60; // 9.6 = 10 min (Value = Value*0.96)
        long TimeDaySeconds = 60 * 60 * 24;
        long PastSecondsMin = TimeDaySeconds / 40;
        long PastSecondsMax = TimeDaySeconds * 7;
        long PastBlocksMin = PastSecondsMin / Blocktime;
        long PastBlocksMax = PastSecondsMax / Blocktime;

        // current difficulty formula, ERC3 - DUAL_KGW3, written by Christian Knoepke - apfelbaum@email.de
        // BitSend and Eropecoin Developer
        StoredBlock BlockLastSolved = storedPrev;
        StoredBlock BlockReading = storedPrev;

        long PastBlocksMass = 0;
        long PastRateActualSeconds = 0;
        long PastRateTargetSeconds = 0;
        double PastRateAdjustmentRatio = 1f;
        BigInteger PastDifficultyAverage = BigInteger.valueOf(0);
        BigInteger PastDifficultyAveragePrev = BigInteger.valueOf(0);;
        double EventHorizonDeviation;
        double EventHorizonDeviationFast;
        double EventHorizonDeviationSlow;

        BigInteger bnPowLimit = this.getMaxTarget();

        //DUAL_KGW3 SETUP
        if (BlockLastSolved == null || BlockLastSolved.getHeight() == 0 || (long)BlockLastSolved.getHeight() < PastBlocksMin) {
            verifyDifficulty(this.getMaxTarget(), storedPrev, nextBlock);
        } else {
            for (int i = 1; BlockReading != null && BlockReading.getHeight() > 0; i++) {
                if (PastBlocksMax > 0 && i > PastBlocksMax) { break; }
                PastBlocksMass++;

                PastDifficultyAverage = BlockReading.getHeader().getDifficultyTargetAsInteger();
                if (i > 1) {
                    if(PastDifficultyAverage.compareTo(PastDifficultyAveragePrev) >= 0)
                        PastDifficultyAverage = ((PastDifficultyAverage.subtract(PastDifficultyAveragePrev)).divide(BigInteger.valueOf(i)).add(PastDifficultyAveragePrev));
                    else
                        PastDifficultyAverage = PastDifficultyAveragePrev.subtract((PastDifficultyAveragePrev.subtract(PastDifficultyAverage)).divide(BigInteger.valueOf(i)));
                }
                PastDifficultyAveragePrev = PastDifficultyAverage;

                PastRateActualSeconds = BlockLastSolved.getHeader().getTimeSeconds() - BlockReading.getHeader().getTimeSeconds();
                PastRateTargetSeconds = Blocktime * PastBlocksMass;
                PastRateAdjustmentRatio = 1.0f;

                if (PastRateActualSeconds < 0)
                    PastRateActualSeconds = 0;

                if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0)
                    PastRateAdjustmentRatio = (double)PastRateTargetSeconds / PastRateActualSeconds;

                EventHorizonDeviation = 1.0 + (0.7084 * java.lang.Math.pow((Double.valueOf(PastBlocksMass)/Double.valueOf(72)), -1.228));
                EventHorizonDeviationFast = EventHorizonDeviation;
                EventHorizonDeviationSlow = 1.0 / EventHorizonDeviation;

                if (PastBlocksMass >= PastBlocksMin)
                    if ((PastRateAdjustmentRatio <= EventHorizonDeviationSlow) || (PastRateAdjustmentRatio >= EventHorizonDeviationFast))
                        break;

                StoredBlock BlockReadingPrev = BlockReading.getPrev(blockStore);
                if (BlockReadingPrev == null) {
                    // Since we are using the checkpoint system, there may not be enough blocks to do this diff adjust, so skip until we do
                    // break;
                    return;
                  }

                BlockReading = BlockReadingPrev;
            }

            //KGW Original
            BigInteger kgw_dual1 = PastDifficultyAverage;
            BigInteger kgw_dual2 = storedPrev.getHeader().getDifficultyTargetAsInteger();
            if (PastRateActualSeconds != 0 && PastRateTargetSeconds != 0) {
                kgw_dual1 = kgw_dual1.multiply(BigInteger.valueOf(PastRateActualSeconds));
                kgw_dual1 = kgw_dual1.and(MASK256BIT); // overflow is here, we need cut it back to 256 bit
                kgw_dual1 = kgw_dual1.divide(BigInteger.valueOf(PastRateTargetSeconds));
                kgw_dual1 = kgw_dual1.and(MASK256BIT);
            }

            StoredBlock BlockPrev = storedPrev.getPrev(blockStore);
            long nActualTime1 = storedPrev.getHeader().getTimeSeconds() - BlockPrev.getHeader().getTimeSeconds();

            // hack caused bug in c implementation
            if (nActualTime1 < 0)
                nActualTime1 = Blocktime;

            long nActualTimespanshort = nActualTime1;

            if (nActualTime1 < Blocktime / 3)
                nActualTime1 = Blocktime / 3;

            if (nActualTime1 > Blocktime * 3)
                nActualTime1 = Blocktime * 3;

            kgw_dual2 = kgw_dual2.multiply(BigInteger.valueOf(nActualTime1));
            kgw_dual2 = kgw_dual2.and(MASK256BIT);
            kgw_dual2 = kgw_dual2.divide(BigInteger.valueOf(Blocktime));
            kgw_dual2 = kgw_dual2.and(MASK256BIT);

            //Fusion from Retarget and Classic KGW3 (BitSend=)
            BigInteger newDifficulty = (kgw_dual2.add(kgw_dual1)).divide(BigInteger.valueOf(2));

            // DUAL KGW3 increased rapidly the Diff if Blocktime to last block under Blocktime/6 sec.
            if( nActualTimespanshort < Blocktime/6 ) {
                newDifficulty = newDifficulty.multiply(BigInteger.valueOf(85));
                newDifficulty = newDifficulty.divide(BigInteger.valueOf(100));
            }

            //BitBreak BitSend
            // Reduce difficulty if current block generation time has already exceeded maximum time limit.
            long nLongTimeLimit = 12 * 60 * 60;
            if ((nextBlock.getTimeSeconds() - storedPrev.getHeader().getTimeSeconds()) > nLongTimeLimit)
                newDifficulty = bnPowLimit;

            if (newDifficulty.compareTo(bnPowLimit) > 0)
                newDifficulty = bnPowLimit;

            verifyDifficulty(newDifficulty, storedPrev, nextBlock);
        }
    }

    private void verifyDifficulty(BigInteger newTarget, StoredBlock storedPrev, Block nextBlock) {
        int accuracyBytes = (int) (nextBlock.getDifficultyTarget() >>> 24) - 3;
        long receivedTargetCompact = nextBlock.getDifficultyTarget();

        // The calculated difficulty is to a higher precision than received, so reduce here.
        BigInteger mask = BigInteger.valueOf(0xFFFFFFL).shiftLeft(accuracyBytes * 8);
        newTarget = newTarget.and(mask);
        long newTargetCompact = Utils.encodeCompactBits(newTarget);

        if (newTargetCompact != receivedTargetCompact)
            throw new VerificationException("Network provided difficulty bits do not match what was calculated: " +
                    Long.toHexString(newTargetCompact) + " vs " + Long.toHexString(receivedTargetCompact));
    }

    @Override
    public Coin getMaxMoney() {
        return MAX_MONEY;
    }

    @Override
    public Coin getMinNonDustOutput() {
        return Transaction.MIN_NONDUST_OUTPUT;
    }

    @Override
    public MonetaryFormat getMonetaryFormat() {
        return new MonetaryFormat();
    }

    @Override
    public int getProtocolVersionNum(final ProtocolVersion version) {
        return version.getBitcoinProtocolVersion();
    }

    @Override
    public BitcoinSerializer getSerializer(boolean parseRetain) {
        return new BitcoinSerializer(this, parseRetain);
    }

    @Override
    public String getUriScheme() {
        return BITCOIN_SCHEME;
    }

    @Override
    public boolean hasMaxMoney() {
        return true;
    }
}
```


Overlapping Code:
```
lic abstract class AbstractBitcoinNetParams extends NetworkParameters {
/**
* Scheme part for Bitcoin URIs.
*/
public static final String BITCOIN_SCHEME = "bitcore";
public static final int REWARD_HALVING_INTERVAL = 210000;
private static final Logger log = LoggerFactory.getLogger(AbstractBitcoinNetParams.class);
private static final BigInteger MASK256BIT = new BigInteger("00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
private static final int FORK1_HEIGHT = 10000;
private static final int FORK2_HEIGHT = 21000;
public AbstractBitcoinNetParams() {
super();
}
/**
* Checks if we are at a difficulty transition point.
* @param height The height of the previous stored block
* @return If this is a difficulty transition point
*/
public final boolean isDifficultyTransitionPoint(final int height) {
if (height > FORK2_HEIGHT)
return ((height + 1) % this.getInterval2()) == 0;
else
return ((height + 1) % this.getInterval()) == 0;
}
@Override
public void checkDifficultyTransitions(final StoredBlock storedPrev, final Block nextBlock,
final BlockStore blockStore) throws VerificationException, BlockStoreException {
if ((storedPrev.getHeight()+1) <= FORK1_HEIGHT) {
DUAL_KGW3(storedPrev, nextBlock, blockStore);
} else {
final Block prev = storedPrev.getHeader();
// Is this supposed to be a difficulty transition point?
if (!isDifficultyTransitionPoint(storedPrev.getHeight())) {
// No ... so check the difficulty didn't actually change.
if (nextBlock.getDifficultyTarget() != prev.getDifficultyTarget())
throw new VerificationException("Unexpected change in difficulty at height " + storedPrev.getHeight() +
": " + Long.toHexString(nextBlock.getDifficultyTarget()) + " vs " +
Long.toHexString(prev.getDifficultyTarget()));
return;
}
// We need to find a block far back in the chain. It's OK that this is expensive because it only occurs every
// two weeks after the initial block chain download.
Sha256Hash hash = prev.getHash();
StoredBlock cursor = null;
int interval = 0;
if (storedPrev.getHeight() > FORK2_HEI
```
<Overlap Ratio: 0.9903006789524733>

---

--- 170 --
Question ID: 4fc8179d27d40dcab9c6e57dd24e80fd5ab115dc
Original Code:
```
public class CommandFreeze implements CommandExecutor {

    private IBasic plugin;

    public CommandFreeze(IBasic plugin) {
        this.plugin = plugin;
    }

    @Override
    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
        if (args.length != 1) {
            sender.sendMessage(ChatColor.RED + "Correct Usage: /" + label + " <player>");
            return true;
        }

        Player target = Bukkit.getPlayer(args[0]);

        if (target == null) {
            sender.sendMessage(ChatColor.RED + "Player '" + args[0] + "' is not online.");
            return true;
        }

        FreezeType freezeType = plugin.getFreezeListener().getFreezeType(target);

        if (freezeType == null) {
            plugin.getFreezeListener().freeze(target, sender, FreezeType.FREEZE);
            sender.sendMessage(ChatColor.GREEN + target.getName() + " is now frozen.");
            target.sendMessage(ChatColor.RED.toString() + ChatColor.BOLD + "You are now frozen.");
            return true;
        }

        if (FreezeType.FREEZE == freezeType) {
            plugin.getFreezeListener().unfreeze(target, FreezeType.FREEZE);
            sender.sendMessage(ChatColor.RED + target.getName() + " is now unfrozen.");
            target.sendMessage(ChatColor.GREEN.toString() + ChatColor.BOLD + "You are un-frozen.");
            return true;
        }

        if (FreezeType.HALT == freezeType) {
            sender.sendMessage(ChatColor.RED + target.getName() + " is currently halted. Use /halt " + target.getName() + " to unhalt.");
            return true;
        }

        // Support in-case extra enums are added.
        sender.sendMessage(ChatColor.RED + "Freeze type currently not implemented, inform an Administrator");
        return true;
    }
}
```


Overlapping Code:
```
lements CommandExecutor {
private IBasic plugin;
public CommandFreeze(IBasic plugin) {
this.plugin = plugin;
}
@Override
public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
if (args.length != 1) {
sender.sendMessage(ChatColor.RED + "Correct Usage: /" + label + " <player>");
return true;
}
Player target = Bukkit.getPlayer(args[0]);
if (target == null) {
sender.sendMessage(ChatColor.RED + "Player '" + args[0] + "' is not online.");
return true;
}
FreezeType freezeType = plugin.getFreezeListener().getFreezeType(target);
if (freezeType == null) {
plugin.getFreezeListener().freeze(target, sender, FreezeType.FREEZE);
sender.sendMessage(ChatColor.GREEN + target.getName() + " is now frozen.");
target.sendMessage(ChatColor.RED.toString() + ChatColor.BOLD + "You are now frozen.");
return true;
}
if (FreezeType.FREEZE == freezeType) {
plugin.getFreezeListener().unfreeze(target, FreezeType.FREEZE);
sender.sendMessage(ChatColor.RED + target.getName() + " is now unfrozen.");
target.sendMessage(ChatColor.GREEN.toString() + ChatColor.BOLD + "You are un-frozen.");
return true;
}
if (FreezeType.HALT == freezeType) {
sender.sendMessage(ChatColor.RED + target.getName() + " is currently halted. Use /halt " + target.getName() + " to unhalt.");
return true;
}
// Support in-case extra enums are added.
sender.sendMessage(ChatColor.RED + "Freeze type currently not implemented, inform an Administrator");
return
```
<Overlap Ratio: 0.9731543624161074>

---

--- 171 --
Question ID: 54a40c69ca15b8560a14b2677f485c8defef63fd
Original Code:
```
public class Client {

	public static void main(String[] args) throws IOException, InterruptedException {
		RMIRegistry rMIRegistry = RMIRegistry.builder().build();

		Service routingService = (Service) rMIRegistry.getStub("localhost", 3333, "tunnel");
		Service routedService = routingService.getService();

		routedService.useThisService();
		Thread.sleep(5000);
		routingService.useThisService();
	}
}
```


Overlapping Code:
```
public class Client {
public static void main(String[] args) throws IOException, InterruptedException {
RMIRegistry rMIRegistry = RMIRegistry.builder().build();
Service routingService = (Service) rMIRegistry.getStub("localhost", 3333, "tunnel");
Service routedService = routingService.getService();
routedService.useThisService();
Thread.sleep(5000);
rout
```
<Overlap Ratio: 0.917312661498708>

---

--- 172 --
Question ID: 62d8b30c2352c27c3568386b4ba8002903091fa3
Original Code:
```
public class CreateServiceJavaImplTest {
    private Dao mockedDao = mock(Dao.class);
    private CreateServiceJavaImpl javaService;


    @Before
    public void setUp() throws Exception {
        javaService = new CreateServiceJavaImpl(mockedDao);
    }

    @Test
    public void test_JavaServiceResult_saveNew_CREATED() {
        County newCounty = TestHelper.countyFactory(null, "46", "Lot");
        JavaServiceResult res = javaService.saveNew(newCounty);

        Assert.assertNotNull(res);
        Assert.assertEquals(Http.Status.CREATED, res.getHttpStatus());
    }
}
```


Overlapping Code:
```
vaImplTest {
private Dao mockedDao = mock(Dao.class);
private CreateServiceJavaImpl javaService;
@Before
public void setUp() throws Exception {
javaService = new CreateServiceJavaImpl(mockedDao);
}
@Test
public void test_JavaServiceResult_saveNew_CREATED() {
County newCounty = TestHelper.countyFactory(null, "46", "Lot");
JavaServiceResult res = javaService.saveNew(newCounty);
Assert.assertNotNull(res);
Assert.assertEquals(Http.Status.CREATED, res
```
<Overlap Ratio: 0.9>

---

--- 173 --
Question ID: 41adc46758e76b1c8633ceccf673cebc059395df
Original Code:
```
@RestController
public class AlarmPanelServerController {

    AlarmPanel alarmPanel;

    public AlarmPanelServerController(AlarmPanel alarmPanel) {
        this.alarmPanel = alarmPanel;
    }

    @RequestMapping(path="/state", method=RequestMethod.GET)
    public HttpEntity<AlarmPanelStateResource> alarmPanelStateResource() {

    	AlarmPanelStateResource alarmPanelStateResource = new AlarmPanelStateResource(alarmPanel);
    	alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelStateResource()).withSelfRel());
    	
    	alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withRel("bit-field"));
    	alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withRel("raw-data"));
    	alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withRel("keypad-text"));
    	alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withRel("numeric-code"));

        return new ResponseEntity<AlarmPanelStateResource>(alarmPanelStateResource, HttpStatus.OK);
    }
        
    @RequestMapping(path="/bit-field", method=RequestMethod.GET)
    public HttpEntity<AlarmPanelBitfieldResource> alarmPanelBitfieldResource() {

    	AlarmPanelBitfieldResource alarmPanelBitfieldResource = new AlarmPanelBitfieldResource(alarmPanel);
    	alarmPanelBitfieldResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withSelfRel());

        return new ResponseEntity<AlarmPanelBitfieldResource>(alarmPanelBitfieldResource, HttpStatus.OK);
    }
        
    @RequestMapping(path="/raw-data", method=RequestMethod.GET)
    public HttpEntity<AlarmPanelRawDataResource> alarmPanelRawDataResource() {

    	AlarmPanelRawDataResource alarmPanelRawDataResource = new AlarmPanelRawDataResource(alarmPanel);
    	alarmPanelRawDataResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withSelfRel());

        return new ResponseEntity<AlarmPanelRawDataResource>(alarmPanelRawDataResource, HttpStatus.OK);
    }
        
    @RequestMapping(path="/keypad-text", method=RequestMethod.GET)
    public HttpEntity<AlarmPanelKeypadTextResource> alarmPanelKeypadTextResource() {

    	AlarmPanelKeypadTextResource alarmPanelKeypadTextResource = new AlarmPanelKeypadTextResource(alarmPanel);
    	alarmPanelKeypadTextResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withSelfRel());

        return new ResponseEntity<AlarmPanelKeypadTextResource>(alarmPanelKeypadTextResource, HttpStatus.OK);
    }
        
    @RequestMapping(path="/numeric-code", method=RequestMethod.GET)
    public HttpEntity<AlarmPanelNumCodeResource> alarmPanelNumCodeResource() {

    	AlarmPanelNumCodeResource alarmPanelNumCodeResource = new AlarmPanelNumCodeResource(alarmPanel);
    	alarmPanelNumCodeResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withSelfRel());

        return new ResponseEntity<AlarmPanelNumCodeResource>(alarmPanelNumCodeResource, HttpStatus.OK);
    }
        
}
```


Overlapping Code:
```
rController {
AlarmPanel alarmPanel;
public AlarmPanelServerController(AlarmPanel alarmPanel) {
this.alarmPanel = alarmPanel;
}
@RequestMapping(path="/state", method=RequestMethod.GET)
public HttpEntity<AlarmPanelStateResource> alarmPanelStateResource() {
AlarmPanelStateResource alarmPanelStateResource = new AlarmPanelStateResource(alarmPanel);
alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelStateResource()).withSelfRel());

alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withRel("bit-field"));
alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withRel("raw-data"));
alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelKeypadTextResource()).withRel("keypad-text"));
alarmPanelStateResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelNumCodeResource()).withRel("numeric-code"));
return new ResponseEntity<AlarmPanelStateResource>(alarmPanelStateResource, HttpStatus.OK);
}

@RequestMapping(path="/bit-field", method=RequestMethod.GET)
public HttpEntity<AlarmPanelBitfieldResource> alarmPanelBitfieldResource() {
AlarmPanelBitfieldResource alarmPanelBitfieldResource = new AlarmPanelBitfieldResource(alarmPanel);
alarmPanelBitfieldResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelBitfieldResource()).withSelfRel());
return new ResponseEntity<AlarmPanelBitfieldResource>(alarmPanelBitfieldResource, HttpStatus.OK);
}

@RequestMapping(path="/raw-data", method=RequestMethod.GET)
public HttpEntity<AlarmPanelRawDataResource> alarmPanelRawDataResource() {
AlarmPanelRawDataResource alarmPanelRawDataResource = new AlarmPanelRawDataResource(alarmPanel);
alarmPanelRawDataResource.add(linkTo(methodOn(AlarmPanelServerController.class).alarmPanelRawDataResource()).withSelfRel());
return new ResponseEntity<AlarmPanelRawDataResource>(alarmPanelRawDataResource, HttpStatus.OK);
}

@RequestMapping(path="/keypad-text", method=RequestMethod.GET)
public HttpEntity<AlarmPanelKeypadTextResource> alarmPanelKeypadTextResource() {
AlarmPanelKeypadTextResource alarmPanelKeypadTextResource = new AlarmPanelKeypadTextResource
```
<Overlap Ratio: 0.9731833910034602>

---

--- 174 --
Question ID: 2d5f5d1979a7349dfa22bc295c4b17b5a3613205
Original Code:
```
@RunWith(Parameterized.class)
public class PersistentTreeMapTest extends AbstractPersistentMapTest {
    
    @Parameters(name = "{0}")
    public static Collection<Object[]> data() {
        return Arrays.asList(new Object[][] {{BalancerType.AVL}, {BalancerType.NON_BALANCED}});
    }
    
    private final BalancerType balancer;
    
    public PersistentTreeMapTest(BalancerType balancer) {
        this.balancer = balancer;
    }
    
    @Override
    protected PersistentMap<String, Integer> empty() {
        return PersistentTreeMap.<String, Integer>empty(String.class, balancer);
    }
    
    @Test
    public void invariants() {
        checkInvariants(mapEmpty);
        checkInvariants(mapSingleton);
        checkInvariants(mapThree);
        checkInvariants(mapLarge);
    }
    
    private void checkInvariants(PersistentMap<String, Integer> map) {
        PersistentTreeMap<?, ?, ?> treeMap = ObjectUtil.castOrNull(map, PersistentTreeMap.class);
        if (treeMap != null) {
            treeMap.checkInvariants();
        }
    }
    
}
```


Overlapping Code:
```
h(Parameterized.class)
public class PersistentTreeMapTest extends AbstractPersistentMapTest {

@Parameters(name = "{0}")
public static Collection<Object[]> data() {
return Arrays.asList(new Object[][] {{BalancerType.AVL}, {BalancerType.NON_BALANCED}});
}

private final BalancerType balancer;

public PersistentTreeMapTest(BalancerType balancer) {
this.balancer = balancer;
}

@Override
protected PersistentMap<String, Integer> empty() {
return PersistentTreeMap.<String, Integer>empty(String.class, balancer);
}

@Test
public void invariants() {
checkInvariants(mapEmpty);
checkInvariants(mapSingleton);
checkInvariants(mapThree);
checkInvariants(mapLarge);
}

private void checkInvariants(PersistentMap<String, Integer> map) {
PersistentTreeMap<?, ?, ?> treeMap = ObjectUtil.castOrNull(map, PersistentTreeMap.class);
if (treeMap != null) {
treeMap.
```
<Overlap Ratio: 0.963718820861678>

---

--- 175 --
Question ID: d345998f428ae9625b0a6d0ea6e07bb3411208d0
Original Code:
```
public class MainFormController {
    public AnchorPane root;
    public Label lblMainDate;
    public ImageView imgItem;
    public ImageView imgAgent;
    public ImageView imgCompany;
    public ImageView imgEmployee;
    public ImageView imgOrder;
    public Label lblMenu;
    public Label lblDescription;

    public void initialize (){
        FadeTransition ft = new FadeTransition(Duration.millis(2000), root);
        ft.setFromValue(0.0);
        ft.setToValue(2.0);
        ft.play();

        //setCurrentDate
        lblMainDate.setText(LocalDate.now()
                + " | " + LocalTime.now().getHour()+"."+ LocalTime.now().getMinute());
    }

    public void navigate(javafx.scene.input.MouseEvent mouseEvent) throws IOException {
        if (mouseEvent.getSource() instanceof ImageView){
            ImageView icon = (ImageView) mouseEvent.getSource();

            Parent root = null;

            switch(icon.getId()){
                case "imgItem":
                    root = FXMLLoader.load(this.getClass().getResource("/view/ManageItemForm.fxml"));
                    break;
                case "imgAgent":
                    root = FXMLLoader.load(this.getClass().getResource("/view/ManageAgentForm.fxml"));
                    break;
                case "imgCompany":
                    root = FXMLLoader.load(this.getClass().getResource("/view/ManageCompanyForm.fxml"));
                    break;
                case "imgEmployee":
                    root = FXMLLoader.load(this.getClass().getResource("/view/ManageEmployeeForm.fxml"));
                    break;
                case "imgOrder":
                    root = FXMLLoader.load(this.getClass().getResource("/view/PlaceOrderForm.fxml"));
                    break;
            }

            if (root != null){
                Scene subScene = new Scene(root);
                Stage primaryStage = (Stage) this.root.getScene().getWindow();
                primaryStage.setScene(subScene);
                primaryStage.centerOnScreen();

                TranslateTransition tt = new TranslateTransition(Duration.millis(350), subScene.getRoot());
                tt.setFromX(-subScene.getWidth());
                tt.setToX(0);
                tt.play();

            }
        }
    }

    public void playMouseExitAnimation(MouseEvent mouseEvent) {
        if (mouseEvent.getSource() instanceof ImageView){
            ImageView icon = (ImageView) mouseEvent.getSource();
            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);
            scaleT.setToX(1);
            scaleT.setToY(1);
            scaleT.play();

            icon.setEffect(null);
            lblMenu.setText("Welcome");
            lblDescription.setText("Please select one of above main operations to proceed");
        }
    }

    public void playMouseEnterAnimation(MouseEvent mouseEvent) {
        if (mouseEvent.getSource() instanceof ImageView){
            ImageView icon = (ImageView) mouseEvent.getSource();

            switch(icon.getId()){
                case "imgItem":
                    lblMenu.setText("Manage Items");
                    lblDescription.setText("Click to add, edit, delete, search or view items");
                    break;
                case "imgAgent":
                    lblMenu.setText("Manage Agents");
                    lblDescription.setText("Click to add, edit, delete, search or view agents");
                    break;
                case "imgCompany":
                    lblMenu.setText("Manage Companies");
                    lblDescription.setText("Click to add, edit, delete, search or view companies");
                    break;
                case "imgEmployee":
                    lblMenu.setText("Manage Employees");
                    lblDescription.setText("Click to add, edit, delete, search or view employees");
                    break;
                case "imgOrder":
                    lblMenu.setText("Place Orders");
                    lblDescription.setText("Click if you want to place orders or manage orders");
                    break;
            }

            ScaleTransition scaleT =new ScaleTransition(Duration.millis(200), icon);
            scaleT.setToX(1.2);
            scaleT.setToY(1.2);
            scaleT.play();

            DropShadow glow = new DropShadow();
            glow.setColor(Color.CORNFLOWERBLUE);
            glow.setWidth(20);
            glow.setHeight(20);
            glow.setRadius(20);
            icon.setEffect(glow);
        }
    }
}
```


Overlapping Code:
```
blic class MainFormController {
public AnchorPane root;
public Label lblMainDate;
public ImageView imgItem;
public ImageView imgAgent;
public ImageView imgCompany;
public ImageView imgEmployee;
public ImageView imgOrder;
public Label lblMenu;
public Label lblDescription;
public void initialize (){
FadeTransition ft = new FadeTransition(Duration.millis(2000), root);
ft.setFromValue(0.0);
ft.setToValue(2.0);
ft.play();
//setCurrentDate
lblMainDate.setText(LocalDate.now()
+ " | " + LocalTime.now().getHour()+"."+ LocalTime.now().getMinute());
}
public void navigate(javafx.scene.input.MouseEvent mouseEvent) throws IOException {
if (mouseEvent.getSource() instanceof ImageView){
ImageView icon = (ImageView) mouseEvent.getSource();
Parent root = null;
switch(icon.getId()){
case "imgItem":
root = FXMLLoader.load(this.getClass().getResource("/view/ManageItemForm.fxml"));
break;
case "imgAgent":
root = FXMLLoader.load(this.getClass().getResource("/view/ManageAgentForm.fxml"));
break;
case "imgCompany":
root = FXMLLoader.load(this.getClass().getResource("/view/ManageCompanyForm.fxml"));
break;
case "imgEmployee":
root = FXMLLoader.load(this.getClass().getResource("/view/ManageEmployeeForm.fxml"));
break;
case "imgOrder":
root = FXMLLoader.load(this.getClass().getResource("/view/PlaceOrderForm.fxml"));
break;
}
if (root != null){
Scene subScene = new Scene(root);
Stage primaryStage = (Stage) this.root.getScene().getWindow();
primaryStage.setScene(subScene);
primaryStage.centerOnScreen();
TranslateTransition tt = new TranslateTransition(Duration.millis(350), subScene.getRoot());
tt.setFromX(-subScene.getWidth());
tt.setToX(0);
tt.play();
}
}
}
public void playMouseExitAnimation(MouseEvent mouseEvent) {
if (mouseEvent.getSource() instanceof ImageView){
ImageView icon = (ImageView) mouseEvent.getSource();
ScaleTransition sca
```
<Overlap Ratio: 0.998914223669924>

---

--- 176 --
Question ID: f664df3b792a7bfc8a4428d77b5c2fffb8ff5eed
Original Code:
```
public class EProperties extends Properties implements Value<EProperties> {
   public static Logger log = LoggerFactory.getLogger(EProperties.class);
   
   /** When set to true, EProperties will emit some debug logging. */
   public static boolean debug=false;
   
   /** When set to true, eproperties will print warnings for potentially 
    * unresolved substitutions.  */
   public static boolean validateOnLoad=true;
   
   /** This is a formatting option for the 'save' function. */
   public static int INDENT_SPACES=3;
   
   /** An internal list of Key objects.  This maintains the order of the keys, 
    * useful for saving the properties object in the same order in which it 
    * was read. */
   private List<Key> keys = new ArrayList<Key>();
   
   // if this properties object is nested inside of another, then the
   // 'thisKey' is the value of the key that owns this object.  If this 
   // is the 'root' object, then thisKey is null;
   String thisKey=null;

   /** List of listeners... */
   List<PropertyListener> listeners = null;
   
   /** 
    * Root EProperties objects will have a source URL, corresponding to 
    * the file from which it was loaded.  If File A includes File B, then
    * File A will have a sourceURL, but not a includeURL.  File B will have a 
    * sourceURL AND an includeURL.
    */
   URL sourceURL=null;
   
   /** If this properties object is included via an include processor, 
    * then includeURL is set.  This is later used when writing properties
    * out.  If the includeURL at a particular level is non-null, then 
    * rather than writing the actual properties, it writes the include
    * url.  For example
    * foo=[http://bar.com/baz.properties]
    */
   String includeURL=null;

   /** Parent, if this object has a parent. */
   EProperties parent = null;
   
   /** */
   static CacheManager cacheManager=CacheManager.getInstance();
   
   /** lastModification is a unique number indicating the state of the source
    * at the last time load() was called.  Now - in the case of a File URL, 
    * this will simply be the last modification time.  <p>
    * 
    * This property is used to determine if the underlying property store 
    * has changed - ie, has the file, or http url, or database been modified, 
    * requiring a reload. <p>  
    * 
    * However, in a case 
    * where properties are in a database, we don't modification time.  So an 
    * alternate method may be chosen.  This could be as simple as a the hashcode
    * of a string composed of the concatenation of all the keys and values. 
    * How expensive this is depends on the relative proximity of the database, 
    * and the number of properties.  If such a calculation is expensive, 
    * the the monitoring thread should be slowed to an appropriate rate.  
    * */
   long lastModification=-1;
   
   public static boolean showVersion=true;
   private static volatile boolean versionShown=false;
   
   static synchronized final void showVersion() {
      if (showVersion == false)
         return;
      
      if (versionShown)
         return;
      
      versionShown=true;
      
      InputStream is=null;
      Properties p=null;
      try {
         is=EProperties.class.getResourceAsStream("version.properties");
         if (is != null) {
            p=new Properties();
            p.load(is);
         }
      } catch (Throwable t) {
         t.printStackTrace();
      } finally {
         if (is != null)
            try {is.close();} catch (Exception ex) {}
      }
      StringBuilder message=new StringBuilder();
      String version="UNKNOWN";
      if (p != null)
         version=p.getProperty("version");
      if (version == null)
         version="ERROR";
      int dlen=14;
      if (version.length() > dlen)
         version=version.substring(0,dlen);
      else if (version.length() < dlen) {
         int add=dlen-version.length();
         for (int i=0; i<add; i++)
            version=version+" ";
      }
      
      message.append("+-----------------------------------------------------------+\n");
      message.append("|         Loading EProperties version "+version   +"        |\n");
      message.append("| For more info, see the EProperties project on googlecode. |\n");
      message.append("|         http://code.google.com/p/eproperties/             |\n");
      message.append("+-----------------------------------------------------------+\n");

      log.info(message.toString());
   }

   /** Constructs a sub-properties object, the parent collection is passed
    * into the constructor. */
   public EProperties(EProperties par) {
      this();
      parent=par;
   }
   
   /** Empty constructor.  Most commonly used as a public API, with 
    * a load() operation called soon after.  */
   public EProperties() {
      showVersion();
   }
   
   /** Sets the URL from which this file was included. */
   public void setIncludedURL(String iurl) {
      includeURL=iurl;
   }
   
   public void setOwner(EProperties p) {
      this.parent=p;
   }
   
   /** 
    * Merges 2 property sets at the same level.  Any potentially duplicate
    * keys would be overwritten by the new values.
    * 
    * This operation will caused subsequent save() operations to write the 
    * merged proeprties.  
    * 
    * This is called by the parser to implement root property includes. 
    */
   public void merge(EProperties p) {
      log.debug("Merging "+p.size()+" new properties.  Current path is '"+getPath()+"'");
      log.debug("Merging, this.findSourceURL(): "+findSourceURL());
      log.debug("Merging, p.findSourceURL(): "+p.findSourceURL());
      
      List<Key> keys = p.getKeys();
      int size=keys.size();
      for (int i = 0; i < size; i++) {
         Key key = keys.get(i);

         // 21 jul 2009 - experimental.  I think we should merge the
         // pre-substitution values, not the derrived values.  
         
         //Object val = p.get(key); 
         Object val=p.preSubstitutionGet(key);
         
         if (val instanceof Value)
            ((Value)val).setOwner(this);
         
         this.put(key, val);
      }
   }
   
   /** 
    * Deep merge in more intelligent than merge.  Merge is draconian, 
    * totally overwriting any property (including potentially deeply 
    * nested properties) with the new value. 
    * 
    * Deep merge attempts to deal with nesting of properties.  Both strings 
    * and list values are still treated as atomic, and overwritten. But
    * deeper trees of properties a merged in a truer sense of the word.  It 
    * is more additive, with the merging properties taking precidece, but
    * not overwriting, rather merging deep trees.
    */
   public void deepMerge(EProperties p) {
      log.debug("Deep-Merging "+p.size()+" new properties.  Current path is '"+getPath()+"'");
      log.debug("Deep-Merging, this.findSourceURL(): "+findSourceURL());
      log.debug("Deep-Merging, p.findSourceURL(): "+p.findSourceURL());
      
      List<Key> keys=p.getKeys();
      for (Key key:keys) {
         String keyString=key.toString();
         
         Object val=p.preSubstitutionGet(keyString);
         
         log.debug("Deep-Merge: pre-substitution get returns "+
               (val == null? "null":(val.getClass().getName()+", "+val)));
         
         if (val instanceof EProperties) {
            EProperties mergingProps=(EProperties)val;
            
            Object existingVal=preSubstitutionGet(keyString);
            if (existingVal != null && existingVal instanceof EProperties) {
               EProperties existingProps=(EProperties)existingVal;
               existingProps.deepMerge(mergingProps);
            } else {
               this.put(keyString, val);
            }
         } else {
            //log.debug("Deep merge, pre-substitution value for key '"+key+"' is "+val);
            
            if (val instanceof Value) 
               ((Value)val).setOwner(this);
            this.put(keyString, val);
         }
      }
   }
   
   
   /** See flatten(String delim). */
   public EProperties flatten() {
      return flatten("|");
   }
   
   /** Flattens properties with the inbound delimiter. */
   public EProperties flatten(String delim) {
      return flatten("", delim);
   }
   
   /**
    * Flattens the property structure.  Nested properties are prefixed
    * with the name of the nesting structure.  For instance, if we have:
    * 
    * foo=bar
    * blah={
    *   bing=bat
    * }
    * 
    * Flatten would flatten the structure to:
    * foo=bar
    * blah|bing=bat
    * 
    * The delimiter is configurable (inbound on the method) with the 
    * default delimeter being the pipe character: '|'.
    * 
    * */
   protected EProperties flatten(String prefix, String delim) {
      EProperties flat=new EProperties();
      for (Key key:keys) {
         Object val=get(key);
         
         if (val == null) {
            log.warn("flatten: value is null for key "+key);
            if (!empty(prefix))
               flat.put(prefix+delim+key, val);
            else 
               flat.put(key.toString(), val);
         } else if (val instanceof EProperties) {
            EProperties epval=(EProperties)val;
            // recursion
            EProperties nestedFlat=null;
            if (!empty(prefix))
               nestedFlat=epval.flatten(prefix+delim+key.toString(), delim);
            else 
               nestedFlat=epval.flatten(key.toString(), delim);
            
            flat.addAll(nestedFlat);
         } else if (val instanceof List) {
            if (!empty(prefix))
               flat.put(prefix+delim+key, val.toString());
            else 
               flat.put(key.toString(), val.toString());
         } else {
            if (!empty(prefix))
               flat.put(prefix+delim+key, val.toString());
            else 
               flat.put(key.toString(), val.toString());
         }
      }
      return flat;
   }
   
   private static final boolean empty(String s) {
      if (s == null || s.length() == 0)
         return true;
      return false;
   }

   /** */
   public void addAll(Properties p) {
      Enumeration keyset=p.keys();
      while (keyset.hasMoreElements()) {
         Object key=keyset.nextElement();
         Object value=p.get(key);
         put(key, value);
      }
   }
   
   /** This method scans the properties tree, and returns a report of what
    * properties have un-resolved substitutions.  */
   public String validate() {
      int size=keys.size();
      
      StringBuilder sb=new StringBuilder();
      
      for (int i=0; i<size; i++) {
         Key key=keys.get(i);
         
         // substitutions should have happened at the point that
         // this is called.
         Object value=get(key);
         key.removeHit();
         if (value instanceof String) {
            String s=(String)value;
            if (SubstitutionProcessor.containsTokens(s)) {
               // this is an error.  Tokens should have been 
               // replaced by values here.
               sb.append("Warning: Value for key '"+key+"' defined in terms of "+
                     "un-resolvable substitution: '"+s+"'\n");
            }
         } else if (value instanceof List) {
            List<String> list=(List<String>)value;
            for (int j=0; j<list.size(); j++) {
               String lv=list.get(j);
               if (SubstitutionProcessor.containsTokens(lv)) {
                  sb.append("Warning: List item value for key '"+key+"["+j+"]' defined "+
                        "in terms of un-resolvable substitution: '"+lv+"'\n");
               }
            }
         } else if (value instanceof EProperties) {
            EProperties props=(EProperties)value;
            // maybe should indent here... 
            sb.append(props.validate());
         } else {
            // not really sure what this object is, if not one of the 
            // above types. I'm confused - but I'm not going to validate.
         }
      }
      return sb.toString();
   }
   
   public void list(PrintStream ps) {
      list((OutputStream)ps);
   }
   
   /** */
   public void list(OutputStream os) {
      list(os, false);
   }
   
   public void list(OutputStream ps, boolean hits) {
      list(new PrintWriter(new OutputStreamWriter(ps), true), 0, hits);
   }
   
   /** */
   public void list(PrintWriter pw) {
      list(pw,0);
   }
   
   public void list(PrintWriter pw, int depth) {
      list(pw, depth, false);
   }
   
   
   /** */
   public void list(PrintWriter pw, int depth, boolean printhits) {
      int size=keys.size();
      StringBuilder sb=new StringBuilder();
      for (int i=0; i<depth; i++) 
         sb.append("  ");
      String pad=sb.toString();
      
      for (int i=0; i<size; i++) {
         Key key=keys.get(i);
         Object value=get(key);
         key.removeHit();
         
         String keystring=null;
         if (printhits)
            keystring=key+"["+key.getHitCount()+"]";
         else
            keystring=key.toString();
         
         if (value instanceof EProperties) {
            pw.println(pad+keystring+" = {");
            ((EProperties)value).list(pw, depth+1, printhits);
            pw.println(pad+"}");
         } else if (value instanceof List) {
//            String s=value.toString();
//            // this will be a list starting and ending with []
//            // replace those with ()
//            s=s.substring(1, s.length()-1);
            List l=(List)value;
            StringBuilder sbb=new StringBuilder();
            for (Object item:l) {
               String sitem=item.toString();
               sitem=sitem.replace("\"", "\\\""); // escape quotes in list strings.
               sbb.append("\""+sitem+"\", ");
            }
            String s=sbb.toString();
            // trim the final , 
            s=s.substring(0, s.length()-2);
            
            pw.println (pad+keystring+"=("+s+")");
         }else {
            pw.println (pad+keystring+"="+value);
         }
      }
   }
   
   public String list() {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);
      list(pw);
      pw.flush();
      return baos.toString();
   }
   
   public String list(int depth) {
      ByteArrayOutputStream baos=new ByteArrayOutputStream();
      PrintWriter pw=new PrintWriter(new OutputStreamWriter(baos), true);
      list(pw, depth);
      pw.flush();
      return baos.toString();
   }
   ///////////////////////  Lineage  ////////////////////////////
   public void setParent(EProperties p, String key) {
      parent=p;
      thisKey=key;
   }
   
   /** */
   public String getPath() {
      StringBuilder sb=new StringBuilder();
      String key=thisKey;
      EProperties nextParent=parent;
      while (nextParent != null) {
         sb.insert(0, "->"+key);
         
         key=parent.thisKey;
         if (key == null)
            key="UNKNOWN";
         
         nextParent=nextParent.parent;
      }
      return sb.toString();
    }
   
   /**
    * This is the sole method for putting objects into the EProperties object.
    * 
    * This is synchronized to prevent concurrent access with load/read operations.
    */
   @Override
   public synchronized Object put(Object k, Object v) {
      if (k == null) {
         throw new NullPointerException("Key cannot be null in EProperties.");
      }
      Key key = null;
      // 
      if (k instanceof String) {
         key = new Key((String) k);
      } else if (k instanceof Key) {
         key = (Key) k;
      } else {
         throw new Error("Keys in EProperties must be [Key | String], not "+k.getClass().getName());
      }
      
      String keyString=key.toString();
      
      if (keyString.indexOf("->") != -1) {
         // this is a complex key.
         return putWithComplexKey(keyString, v);
         // FIXME: This does not account for listeners to keys/properties at any level
      }
      
      // Prevent duplicate keys, preserve order, notify listeners
      int keyIndex = keys.indexOf(key);
      if (keyIndex == -1)
         keys.add(key);
      else {
         //Key existingKey = keys.get(keys.indexOf(key));
         //existingKey.notifyListeners(v);
         key=keys.get(keyIndex); // replace created key w/ existing key
      }
      
      // build a value object.
      // There are 3 and only 3 types of values:
      //   1) String values.
      //   2) List Values, and
      //   3) EProperties values.
      // 
      // attempting to put any
      
      Object returnVal=v;
      Value value=null;
      
      if (v == null) {
         // Allowing us to call put(key, null). Setting a property to 
         // null is defined as removing that property.
         //super.put(key, v);
         super.remove(key);
      } else if (v instanceof String) {
         value=new StringValue((String)v, this);
         super.put(key, value);
      } else if (v instanceof List) {
         value=new ListValue((List)v, this);
         super.put(key, value);
      } else if (v instanceof EProperties) {
         super.put(key, v);
         
         // set parent.
         //setParent((EProperties)v, key.toString());
         ((EProperties)v).setParent(this, key.toString());
      } else if (v instanceof StringValue ||
                 v instanceof ListValue) {
         Value vv=(Value)v;
         
         log.debug("Putting raw StringValue or ListValue: persistent: "+
               vv.getPersistentValue()+" runtime: "+vv.getRuntimeValue());
         super.put(key, v);
      } else {
         throw new Error("EProperties put() values can only be: "+
               "[String | List<String> | EProperties | StringValue | ListValue].  "+
               "Not "+v.getClass().getName());
      }

      if (this.listeners != null) {
         notifyListeners(key, value);
      }
      // This will do nothing if there are no listeners.
      key.notifyListeners(returnVal);

      return returnVal;
   }
   
   /** 
    * putWithCompleKey() works much like getWithComplexKey().  I will give a 
    * simple example under 2 different conditions.
    * 
    * In both examples, the key is nested->foo.  In both cases the put method
    * has been called on a properties object we'll call 'root'.  
    * 
    * Case 1: The 'root' EProperties object already has a nested properties
    *         object named 'nested'.  In this case, we simply get a handle
    *         to the deeper properties object called 'nested' and on it
    *         we call put(key, val) with the key being a simple key 'foo' 
    *         and the value being the inbound value.  ALL BEHAVIORS OF PUT
    *         AT THAT POINT ARE IDENTICAL. Ie, if the value does not already 
    *         exist, it is added.  If the value does exist, IN ANY FORM - ie
    *         String, List or nested Properties - it is overwritten with 
    *         the inbound object value.
    *         
    * Case 2: The 'root' EProperties object does not already have a nested
    *         properties object called 'nested'.  In this case, a new properties
    *         object is created, named 'nested' and added to 'root'.  
    *         
    * For keys with more than 2 levels of depth (ie, a->b->c), the process
    * above is repeated until the last key (c in this example) is found - and 
    * that key represents the inbound value in the nested objects a->b that
    * either already exist, or are created by this method.
    */
   private synchronized Object putWithComplexKey(String key, Object value) {
      String keys[] = key.split("\\-\\>");
      
      log.debug ("getComplexKey(): "+Arrays.asList(keys));
      
      EProperties next = this;
      String currentPath = "";
      
      //StringBuilder path=new StringBuilder();
      
      for (int i = 0; i < keys.length - 1; i++) {
         // currentPath is used for debugging.
         EProperties prev=next;
         next=prev.getProperties(keys[i]);
         if (next == null) {
            // Create nested props that do not exist.
            next=new EProperties();
            prev.put(keys[i], next);
         }
      }
      
      return next.put(keys[keys.length-1], value);
   }

   /** */
   @Override
   public synchronized void putAll(Map m) {
      Iterator i=m.keySet().iterator();
      while (i.hasNext()) {
         Object key=i.next();
         Object val=m.get(key);
         put(key, val);
      }
   }

   /** */
   @Override
   public Object remove(Object k) {
      Key key = null;
      if (k instanceof String) {
         key = new Key((String) k);
      } else if (k instanceof Key) {
         key = (Key) k;
      } else {
         throw new Error("Keys in EProperties must be [Key, String].");
      }
      keys.remove(key);
     
      Object returnVal=super.remove(key);
      
      notifyListeners(key, returnVal);
      
      return returnVal;
   }
   
   /** Logs 'hits' to keys.  This allows us to know what properties are being
    * used in a long running JVM.  See Key.getHitCount(). */
   private void keyHit(Object key) {
      if (key instanceof String)
         key=new Key((String)key);
      int index=keys.indexOf(key);
      
      if (index < 0) {
      } else {
         Key thekey=keys.get(index);
         thekey.hit();
      }
   }
   
   /**
    * All getters funnel to this location.  This is the 'super' get.  
    */
   @Override
   public Object get(Object key) {
      Object val=null;
      
      if (key instanceof String) { 
         String skey=(String)key;
         if (skey.indexOf("->") > 0)
            val=getWithComplexKey(skey);
         else {
            val=super.get(key);
            if (val != null)
               keyHit(key);
         }
      } else { 
         val=super.get(key);
         if (val != null)
            keyHit(key);
      }

      log.debug("get, key: '"+key+"', keyclass: "+key.getClass().getName());
      log.debug ("get, val: '"+val+"' valClass: "+(val == null?"":val.getClass().getName()));
      if (val instanceof Value) {
         Value vv=(Value)val;
         log.debug("   Value.getPersistent: '" + vv.getPersistentValue()+"'");
         log.debug("   Value.getRuntime   : '"+vv.getRuntimeValue()+"'");
      }
      
      // At this point, val could be null.
      if (val == null)
         return val;
      
      // here, we'll process substitutions if they exist...
      if (val instanceof StringValue) {
         Object rtval=((StringValue)val).getRuntimeValue();
         
         if (rtval instanceof String &&
            SubstitutionProcessor.containsTokens((String)rtval)) {
            log.warn("Value for key '"+key+"' defined in terms of "+
                     "un-resolvable substitution: '"+rtval+"'");
         }
         return rtval;
      }
      else if (val instanceof ListValue) {
         List<String> list=((ListValue)val).getRuntimeValue();
         for (int j=0; j<list.size(); j++) {
            String lv=list.get(j);
            if (SubstitutionProcessor.containsTokens(lv)) {
               log.warn("List item value for key '"+key+"["+j+"]' defined "+
                     "in terms of un-resolvable substitution: '"+lv+"'\n");
            }
         }
         return list;
      }
      
      // this can and will be EProperties as well as primitives.
      return val;
   }
   
   private Object preSubstitutionGet(Object key) {
      log.debug("Pre-sub get "+key);
      return super.get(key);
   }
   
   /** */
   public Object internalGetValue(Object key) {
      // note, this key must be a Key, not a String
      return super.get(key);
   }
   
   /** */
   public EProperties internalResolveProperties(String path) {
      if (path.indexOf("->") == -1)
         return this;
      
      String keys[] = path.split("\\-\\>");
      
      log.debug ("getComplexKey(): "+Arrays.asList(keys));
      
      EProperties next = this;
      String currentPath = "";
      
      //StringBuilder path=new StringBuilder();
      
      for (int i = 0; i < keys.length - 1; i++) {
         // currentPath is used for debugging.
         if (currentPath.equals(""))
            currentPath = keys[i];
         else
            currentPath = currentPath + "->" + keys[i];

         Object nextTarget = next.get(keys[i]);
         if (nextTarget == null) {
            return null;
         } else if (nextTarget instanceof EProperties) {
            next = (EProperties) nextTarget;
         } else {
            log.debug("getComplexKey(): [" + path
                  + "]: Returning null because object at path "
                  + currentPath + " is not EProperties, it is "
                  + nextTarget.getClass().getName());
            return null;
         }
      }
      // here, we are pointed at the correct eproperties object.
      //return next.get(keys[keys.length-1]);
      return next;
   }
   
   /** */
   public Key internalResolveKey(String path) {
      EProperties p=null;
      String finalKey=null;
      if (path.indexOf("->") != -1) {
         p=internalResolveProperties(path); // can return null;
         
         String keyelements[]=path.split("\\-\\>");
         finalKey=keyelements[keyelements.length-1];
      } else {
         p=this;
         finalKey=path;
      }
      if (p == null)
         return null;
      List<Key> keys=p.getKeys();
      for (Key key:keys) {
         if (key.toString().equals(finalKey))
            return key;
      }
      return null;
   }
   
   /** */
   public Object get(String key, Object def) {
      Object ret = get(key);
      if (ret == null)
         return def;
      else
         return ret;
   }

   /** */
   public List<Key> getKeys() {
      return keys;
   }

   /** */
   public Object get(int keyNum) {
      return get(getKey(keyNum));
   }

   /** */
   public Key getKey(int i) {
      return keys.get(i);
   }

   /** Returns a list of keys that start with the input string. */
   public List<Key> getKeys(String s) {
      List<Key> prefixKeys = new ArrayList<Key>();
      int size = keys.size();
      for (int i = 0; i < size; i++) {
         Key key = keys.get(i);
         if (key.toString().startsWith(s))
            prefixKeys.add(key);
      }
      return prefixKeys;
   }
   
   @Override
   public synchronized Enumeration keys() {
      Vector v=new Vector();
      
      int size = keys.size();
      for (int i = 0; i < size; i++) {
         Key key = keys.get(i);
         v.add(key.toString());
      }
      return v.elements();
   }
   
   @Override
   public synchronized Collection values() {
      Vector v=new Vector();
      int size = keys.size();
      for (int i = 0; i < size; i++) {
         v.add(get(i));
      }
      return v;
   }
   
   @Override 
   public synchronized Enumeration elements() {
      return new VectorEnumerator((Vector)values());
   }
   
   public static class VectorEnumerator implements Enumeration {
      Vector v=null;
      int index=0;
      public VectorEnumerator(Vector v) {
         this.v=v;
      }
      public boolean hasMoreElements() {
         if (index < v.size())
            return true;
         return false;
      }
      public Object nextElement() {
         index++;
         return v.get(index-1);
      }
   }
   
   @Override
   public synchronized Set keySet() {
      HashSet hashSet=new HashSet();
      
      int size = keys.size();
      for (int i = 0; i < size; i++) {
         Key key = keys.get(i);
         hashSet.add(key.toString());
      }
      
      return hashSet;
   }
   
   @Override
   public Set<Map.Entry<Object, Object>> entrySet() {
      // This sucks to have to do, but Entry is a private class in 
      // hashmap.  And entrySet() is called fromn putAll().  Meaning I
      // MUST override this or people who copy this properties object
      // by constructing a new one, and calling putAll() and then assuming
      // that the keys are strings will fail. (Spring.  Spring sucks.)
      HashMap map=new HashMap();
      for (Key key:keys) {
         map.put(key.toString(), get(key));
      }
      return map.entrySet();
   }
   
   @Override
   public Enumeration<String> propertyNames() {
      return keys();
   }
   
   //@Override // this is an override only in 1.6
   public Set<String> stringPropertyNames() {
      return keySet();
   }
   
   @Override 
   public synchronized boolean containsKey(Object key) {
      Object val=get(key);
      if (val != null)
         return true;
      return false;
   }
   
   @Override
   public synchronized boolean contains(Object value) {
      if (value == null)
         return false;
      // inefficient, but functional.
      int size = keys.size();
      for (int i = 0; i < size; i++) {
         Object val=get(i);
         if (val.equals(value))
            return true;
      }
      return false;
   }
   
   @Override 
   public synchronized String toString() {
      return list();
   }

   ///////////////////////// Load/Save Methods ////////////////////////////
   /** This is the 'master' load() method.  All other load methods delegate
    * here for actual property loading.  */
   @Override
   public synchronized void load(InputStream is) 
   throws IOException {
      InputStream cis=cacheManager.getInputStream(is, sourceURL);
      
      EPropertiesParser parser=new EPropertiesParser(cis);
      parser.setSourceURL(sourceURL);

      try {
         parser.parse(this);
      } catch (Exception ex) {
         // this constructor is only available in Java 1.6
         //throw new IOException("Error parsing EProperties.", ex);
         ex.printStackTrace();
         throw new IOException("Error parsing Properties. "+ex.getMessage());
      } finally {
         if (cis != null) {
            try {
               cis.close();
            } catch (Exception clex) {
               clex.printStackTrace();
            }
         }
      }
      if (validateOnLoad)
         validate();
   }
   
//   @Override
//   public synchronized void load(Reader r) {
//      throw new RuntimeException("not implemented.");
//   }
   
   /**
    * Loads properties with a string representing either a URL or 
    * a file.  
    * 
    * @param surl
    */
   public void load(String surl) throws IOException {
      URL url=null;
      
      surl=URLUtil.convertClasspathURL(surl);
      
      String lcurl=surl.toLowerCase();

      if (lcurl.startsWith("http://") || lcurl.startsWith("https://") ||
          lcurl.startsWith("file:/") || lcurl.startsWith("jar:file:/")) {
         url=new URL(surl);
      } else {
         url=(new File(surl)).toURI().toURL();
      }
      load(url);
   }
   
   /** */
   public synchronized void load(URL url) 
      throws IOException {
      setSourceURL(url);
      InputStream is=null;
      try {
         is=cacheManager.getInputStream(url);
         
         load(is);
         
         lastModification=URLUtil.lastMod(url);
         log.debug("Last Mod is '"+lastModification+"'");
      } finally {
         if (is != null)
            is.close();
      }
   }
   
   /** */
   public boolean isSourceModified() {
      // FIXME, 18 AUG 2010 - possible NPE. sourceURL could be null.
      URL surl=sourceURL;
      if (surl == null) {
         surl=findSourceURL();
      }
      if (surl == null) 
         return false;
      
      try {
         
         long lastMod=URLUtil.lastMod(surl);
         
         if (lastMod != lastModification) 
            return true;
      } catch (Exception ex) {
         log.error("Error checking source modification", ex);
      }
      return false;
   }
   
   /** */
   public void load(File f) 
    throws IOException {
      load(f.toURI().toURL());
   }
   
   /** Reloads this EProperties object from its sourceURL. If this EProperties
    * object does not have a sourceURL, this method does nothing.
    */
   public void reload() 
      throws IOException {
      if (sourceURL != null) {
         load(sourceURL);
      } else {
         log.warn("reload() called on EProperties, but sourceURL is null.  noop.");
      }
   }
   
   /** */
   public URL getSourceURL() {
      URL url = sourceURL;
      if (url != null)
         return url;
      
      EProperties next = parent;
      while (next != null && url == null) {
         url = next.sourceURL;
         next = next.parent;
      }
      return url;
   }

   /** */
   public void setSourceURL(URL url) {
      log.debug("Setting source URL '"+url+"'");
      sourceURL = url;
   }

   /** */
   public final URL findSourceURL() {
      EProperties props = this;
      URL url = sourceURL;
      while (url == null && props != null) {
         props = props.parent;
         if (props != null)
            url = props.sourceURL;
      }
      return url;
   }
   
   /** Save to the file currently identified by sourceURL.  sourceURL must be
    * file based - and not http based - we can't magically save to an 
    * http stream.
    * 
    * If this method is called on a properties object without a sourceURL, 
    * this method searches up the tree to find a properties object that
    * does have a source URL - and that object is saved if it can be found, 
    * and has a file:// based source url.
    * 
    * @return Returns true if a save has been executed, false if not possible.
    * @throws IOException
    */
   public boolean save() throws IOException {
      if (sourceURL != null) {
         if (sourceURL.getProtocol() != null
               && sourceURL.getProtocol().equals("file")) {

            File f;
            try {
               f = new File(sourceURL.toURI());
            } catch (Exception ex) {
               // this constructor is only available in Java 1.6
               //throw new IOException("Unable to form File from URL.", ex);
               ex.printStackTrace();
               throw new IOException("Unable to form File from URL. "+ex.getMessage());
            }
            save(f);
         } else {
            log.debug("Cannot save properties with URL " + sourceURL);
         }
         return true;
      } else {
         if (parent != null) {
            return parent.save();
         } else {
            return false;
         }
      }
   }
   
   public void save(File f) throws IOException {
      save(new FileWriter(f));
   }
   
   public void save(OutputStream os)
   throws IOException {
      save(new OutputStreamWriter(os));
   }
   
   public void save(Writer w) 
   throws IOException {
      save(w, 0);
   }
   
   /** */
   private synchronized void save(Writer w, int indent) 
      throws IOException {
      String pad="";
      if (indent > 0) {
         StringBuilder sb=new StringBuilder();
         for (int i=0; i<INDENT_SPACES*indent; i++) {
            sb.append(" ");
         }
         pad=sb.toString();
      }
      
      try {
         int size=keys.size();
         for (int i=0; i<size; i++) {
            Key key=keys.get(i);
            
            // writing key= is the same for string, list, properties, or
            // inclusion.
            
            // first, write comment lines if they exist
            String comments=key.getComments();
            if (comments != null) {
               // trim off trailing newline, then pad, then append newline
               comments=comments.trim(); 
               
               comments=pad+comments;
               comments=comments.replace("\n", "\n"+pad);
               comments=comments+"\n";
               
               w.write(comments);
            }
            w.write(pad+key.toString()+"=");
            
            // now, write the value, depending on its type.
            Object val=preSubstitutionGet(key);
            
            if (val == null) {
               w.write("\n"); // null is an unquoted empty line.
               // this will allow for the definition of a non-null
               // empty string as "".
            } else if (val instanceof StringValue) {
               String s=(String) ((StringValue)val).getPersistentValue();
               w.write("\""+s+"\"\n");
            } else if (val instanceof EProperties) {
               EProperties pval=(EProperties)val;
               
               if (pval.includeURL != null) {
                  // these properties were included.
                  w.write("["+pval.includeURL+"]\n");
               } else {
                  w.write("{\n");
                  pval.save(w, indent+1);
                  w.write(pad+"}\n");
               }
            } else if (val instanceof ListValue) {
               List list=(List)((ListValue)val).getPersistentValue();
               
               if (list.size() == 0) {
                  w.write("( )\n");
               } else {
                  
                  String keypad=pad(key.toString().length()+2, " ");
                  w.write("(");
                  int lsize=list.size();
                  for (int j=0; j<lsize; j++) {
                     w.write("\""+list.get(j)+"\"");
                     
                     if (j == lsize-1) // last element
                        w.write(")\n");
                     else 
                        w.write(", \n"+pad+keypad);
                  }
               }
            } else {
               log.error("What kind of value?? "+val.getClass().getName());
            }
            
            // append this newline for whitespace readability
            //if (i != size-1)
            //   w.write("\n");
         }
         // end of the for loop.
      } finally {
         if (w != null)
            w.flush();
      }
   }
   
   /** */
   public void save(String filename) 
      throws IOException {
      save(new FileOutputStream(filename));
   }
   
   private static final String pad(int pad, String padChar) {
      StringBuilder sb=new StringBuilder();
      for (int i=0; i<pad; i++) {
         sb.append(padChar);
      }
      return sb.toString();
   }
   
   /////////////////////////   Convience Put Methods  ////////////////////
   /** */
   public void putBoolean(String key, boolean value) {
      String val = null;
      if (value)
         val = "true";
      else
         val = "false";
      put(key, val);
   }

   /** */
   public void putInt(String key, int i) {
      String val = "" + i;
      put(key, val);
   }

   /** */
   public void putLong(String key, long l) {
      String val = "" + l;
      put(key, val);
   }
   
   @Override
   public Object setProperty(String k, String v) {
      return put(k, v);
   }
   
   /////////////////////////  Token Substitution  /////////////////////////
   /**
    * This method will search up a tree of EProoperties objects, looking for 
    * a match.  It will return the first match.
    * 
    * @param s
    * @return
    */
   public String findProperty(String s) {
      String val=getString(s, null);
      log.debug("findProperty(): Path='"+getPath()+"', "+s+"="+val);
            
      if (val != null)
         return val;
      else {
         if (parent != null) {
            return parent.findProperty(s);
         } else {
            log.debug("findProperty(): parent is null at Path='"+getPath()+"'");
         }
      }
      
      return val;
   }
   
   /**
    * This method will search up a tree of EProoperties objects, looking for 
    * a match.  It will return the first match.
    * 
    * @param s
    * @return
    */
   public Object findValue(String s) {
      Object val=get(s, null);
      log.debug("findValue(): Path='"+getPath()+"', "+s+"="+val);
            
      if (val != null)
         return val;
      else {
         if (parent != null) {
            return parent.findValue(s);
         } else {
            log.debug("findValue(): parent is null at Path='"+getPath()+"'");
         }
      }
      
      return val;
   }
   
   // /////////////////////// Accessor Methods ///////////////////////////
   public EProperties getProperties(Key key) {
      return getProperties(key.toString());
   }

   
   private Object getWithComplexKey(String key) {
      // a complex key uses a pointer syntax find properties
      // deeper in a structure.
      // for instance:
      // String s=(String)get("system->user.home");
      // is equivalent to
      // String s=(String)getProperties("system").get("user.home");
      //
      // Which brings up the issue of error handling. What if one of the
      // indirections returns a null nested property object!!
      // At that we simply return null - as if you requested a value 
      // from an EProperties object where the key does not exist.
      //
      // The final key can return any type of object (String, Vector,
      // Properties),
      // however all of the initial keys must return a nested EProperties
      // object. If they do not, then it returns null.
      String keys[] = key.split("\\-\\>");
      
      log.debug ("getComplexKey(): "+Arrays.asList(keys));
      
      EProperties next = this;
      String currentPath = "";
      
      //StringBuilder path=new StringBuilder();
      
      for (int i = 0; i < keys.length - 1; i++) {
         // currentPath is used for debugging.
         if (currentPath.equals(""))
            currentPath = keys[i];
         else
            currentPath = currentPath + "->" + keys[i];

         Object nextTarget = next.get(keys[i]);
         if (nextTarget == null) {
            return null;
         } else if (nextTarget instanceof EProperties) {
            next = (EProperties) nextTarget;
         } else {
            log.debug("getComplexKey(): [" + key
                  + "]: Returning null because object at path "
                  + currentPath + " is not EProperties, it is "
                  + nextTarget.getClass().getName());
            return null;
         }
      }
      // here, we are pointed at the correct eproperties object.
      return next.get(keys[keys.length-1]);
   }

   /** */
   @Override
   public String getProperty(String key) {
      return getProperty(key, null);
   }

   /** */
   @Override
   public String getProperty(String key, String def) {
      Object val = get(key);
      
      if (val == null)
         return def;
      if (val instanceof String)
         return (String)val;
      else
         return def;
   }

   /** */
   public String getString(String key) {
      return getProperty(key);
   }

   /** */
   public String getString(String key, String def) {
      return getProperty(key, def);
   }

   /** */
   public List<String> getList(String key) {
      Object val = get(key);
      if (val == null)
         return null;
      if (val instanceof List)
         return (List<String>)val;
      
      // Automagically convert strings to lists.  If the return 
      // value is a string, it will be parsed as a csv list.
      // this method is quite dumb.  First, any and all substitutions
      // are processed when retrieving the String, not in the list.
      // Second, if the value is a single string - with no commas, 
      // a single element list with the String as the only element 
      // is returned.
      if (val instanceof String) {
         List<String> l=convertStringToList((String)val);
         return l;
      }
      
      return null;
   }
   
   /** converts a string to a list. */
   private static final List<String> convertStringToList(String s) {
      List<String> l=new ArrayList<String>();
      String parsed[]=s.split("\\,");
      for (String p:parsed) 
         l.add(p);
      return l;
   }
   
   /** Returns a list with a default value if the list is null. **/
   public List<String> getList(String key, List<String>def) {
      List<String>rval=getList(key);
      if (rval != null)
         return rval;
      return def;
   }

   /** Returns a nested EProperties object if one is available for the
    * given key.  If not, it returns null. */
   public EProperties getProperties(String key) {
      Object val = get(key);
      if (val == null)
         return null;

      if (val instanceof EProperties)
         return (EProperties) val;
      else
         return null;
   }

   /** Returns a boolean.  Booleans are stored as Strings.  If the 
    * string representing the key begins with [t|T], then this
    * method returns true - otherwise it return false.  If the 
    * key is not defined (null as a string) then this method returns
    * false by default. */
   public boolean getBoolean(String key) {
      return getBoolean(key, false);
   }

   /** Boolean is a string.  If the string starts with [t | T] then 
    * this method returns true.  Otherwise, it returns false.  */
   public boolean getBoolean(String key, boolean def) {
      Object val = get(key);
      
      if (val == null)
         return def;
      if (val instanceof String) {
         String s = (String) val;
         s=s.toLowerCase().trim();
         if (s.startsWith("t"))
            return true;
         else
            return false;
      } else
         return def;
   }

   /** Returns an integer.  Integers are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to an integer, then this method returns -1.  */
   public int getInt(String key) {
      return getInt(key, -1);
   }

   /** Returns an integer.  Integers are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to an integer, then this method returns the default
    * value passed in.  */
   public int getInt(String key, int def) {
      Object val = get(key);
      if (val == null) {
         return def;
      }
      if (val instanceof String) {
         String s = (String)val;
         try {
            return Integer.parseInt(s.trim());
         } catch (NumberFormatException ex) {
            log.error("Cannot parse int from '" + s.trim()
                  + "', returning default of " + def);
            return def;
         }
      } else
         return def;
   }

   /** Returns a long.  Longs are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a long, then this method returns -1.  */
   public long getLong(String key) {
      return getLong(key, -1);
   }

   /** Returns a long.  Longs are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a long, then this method returns the default
    * value passed in.  */
   public long getLong(String key, long def) {
      Object val = get(key);
      if (val == null)
         return def;
      if (val instanceof String) {
         String s = (String)val;
         try {
            return Long.parseLong(s.trim());
         } catch (NumberFormatException ex) {
            log.error("Cannot parse long from " + s.trim()
                  + ", returning default of " + def);
            return def;
         }
      } else
         return def;
   }

   /** Returns a float.  Floats are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a float, then this method returns 0.0f.  */
   public float getFloat(String key) {
      return getFloat(key, 0.0f);
   }

   /** Returns a float.  Floats are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a float, then this method returns the defualt value
    * passed in.  */
   public float getFloat(String key, float def) {
      Object val = get(key);
      if (val == null) {
         return def;
      }
      if (val instanceof String) {
         String s = (String) val;
         try {
            return Float.parseFloat(s.trim());
         } catch (NumberFormatException ex) {
            log.error("Cannot parse float from '" + s.trim()
                  + "', returning default of " + def);
            return def;
         }
      } else
         return def;
   }

   /** Returns a double.  Double are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a double, then this method returns 0.0f.  */
   public double getDouble(String key) {
      return getDouble(key, 0.0f);
   }

   /** Returns a double.  Double are stored as Strings.  If the 
    * string available with the inbound 'key' is null, or does not 
    * parse to a double, then this method returns the defualt value
    * passed in.  */
   public double getDouble(String key, double def) {
      Object val = get(key);
      if (val == null) {
         return def;
      }
      if (val instanceof String) {
         String s = (String) val;
         try {
            return Double.parseDouble(s.trim());
         } catch (NumberFormatException ex) {
            log.error("Cannot parse double from '" + s.trim()
                  + "', returning default of " + def);
            return def;
         }
      } else
         return def;
   }

   // ///////////////////// Listener Infrastructure //////////////////////
   /** */
   public void addListener(PropertyListener listener) {
      if (listeners == null)
         listeners = new ArrayList<PropertyListener>();
      listeners.remove(listener); // prevent duplicates
      listeners.add(listener);
   }

   /** */
   public void removeListener(PropertyListener obs) {
      if (listeners != null)
         listeners.remove(obs);
   }

   /** */
   void notifyListeners(Key key, Object value) {
      if (listeners == null)
         return;

      // generate the event
      PropertyChangeEvent evt = new PropertyChangeEvent(key, value);

      for (int i = 0; i < listeners.size(); i++) {
         PropertyListener obs = listeners.get(i);
         obs.propertyChange(evt);
      }
   }

   @Override
   public EProperties getPersistentValue() {
      return this;
   }

   @Override
   public Object getRuntimeValue() {
      return this;
   }
}
```


Overlapping Code:
```
erties extends Properties implements Value<EProperties> {
public static Logger log = LoggerFactory.getLogger(EProperties.class);

/** When set to true, EProperties will emit some debug logging. */
public static boolean debug=false;

/** When set to true, eproperties will print warnings for potentially 
* unresolved substitutions. */
public static boolean validateOnLoad=true;

/** This is a formatting option for the 'save' function. */
public static int INDENT_SPACES=3;

/** An internal list of Key objects. This maintains the order of the keys, 
* useful for saving the properties object in the same order in which it 
* was read. */
private List<Key> keys = new ArrayList<Key>();

// if this properties object is nested inside of another, then the
// 'thisKey' is the value of the key that owns this object. If this 
// is the 'root' object, then thisKey is null;
String thisKey=null;
/** List of listeners... */
List<PropertyListener> listeners = null;

/** 
* Root EProperties objects will have a source URL, corresponding to 
* the file from which it was loaded. If File A includes File B, then
* File A will have a sourceURL, but not a includeURL. File B will have a 
* sourceURL AND an includeURL.
*/
URL sourceURL=null;

/** If this properties object is included via an include processor, 
* then includeURL is set. This is later used when writing properties
* out. If the includeURL at a particular level is non-null, then 
* rather than writing the actual properties, it writes the include
* url. For example
* foo=[http://bar.com/baz.properties]
*/
String includeURL=null;
/** Parent, if this object has a parent. */
EProperties parent = null;

/** */
static CacheManager cacheManager=CacheManager.getInstance();

/** lastModification is a unique number indicating the state of the source
* at the last time load() was called. Now - in the case of a File URL, 
* this will simply be the last modification time. <p>
* 
* This property is used to determine if the underlying property store 
* has changed - ie, has the file, or http url, or database been modified, 
* requiring a reload. <p> 
* 
* However, in a case 
* where properties are in a database, we don't modification time. So an 
* alternate method may be chosen. This could be as si
```
<Overlap Ratio: 0.986451048951049>

---

--- 177 --
Question ID: e55f13615981add2d55c3af4a7b96afe54485fac
Original Code:
```
public class FormatProcess extends AbstractProcess {

    private static final String GROUP_ID = "net.revelc.code.formatter";
    private static final String ARTIFACT_ID = "formatter-maven-plugin";
    private static final String GOAL = "format";
    private static final String XML_CONFIG = "config/formatter.xml";

    public FormatProcess(boolean skip, Config config, MavenContext element, Logger logger) {
        super("FORMAT", skip, config, element, logger);
    }

    @Override
    public void executeInternal() throws Exception {
        Plugin formatterPlugin = getPluginFromComponentDependency(GROUP_ID, ARTIFACT_ID);
        assertPlugin(formatterPlugin, GROUP_ID, ARTIFACT_ID, "<dependency>");
        String configFile;
        File file = getMavenProjectFile(XML_CONFIG);
        if (file.exists() && file.isFile()) {
            configFile = file.getAbsolutePath();
        } else {
            configFile = processDefaultConfig(XML_CONFIG);
        }
        executeMojo(formatterPlugin,
                goal(GOAL),
                configuration(
                        element(name("lineEnding"), config.getLineEnding()),
                        element(name("encoding"), config.getEncoding()),
                        element(name("configFile"), configFile),
                        element(name("skipCssFormatting"), "" + config.isSkipCss()),
                        element(name("skipHtmlFormatting"), "" + config.isSkipHtml()),
                        element(name("skipJavaFormatting"), "" + config.isSkipJava()),
                        element(name("skipJsFormatting"), "" + config.isSkipJs()),
                        element(name("skipJsonFormatting"), "" + config.isSkipJson()),
                        element(name("skipXmlFormatting"), "true"),
                        element(name("directories"),
                                element(name("directory"), "${basedir}/src/main/java"),
                                element(name("directory"), "${basedir}/src/main/webapp"),
                                element(name("directory"), "${basedir}/src/test/java"),
                                element(name("directory"), "${basedir}/src/test/webapp")
                        ),
                        element(name("includes"),
                                element(name("include"), "**/*.java"),
                                element(name("include"), "**/*.html"),
                                element(name("include"), "**/*.xhtml"),
                                element(name("include"), "**/*.jsp"),
                                element(name("include"), "**/*.jspx"),
                                element(name("include"), "**/*.css"),
                                element(name("include"), "**/*.js"),
                                element(name("include"), "**/*.jsx"),
                                element(name("include"), "**/*.ts"),
                                element(name("include"), "**/*.tsx"),
                                element(name("include"), "**/*.json")
                        )
                ),
                executionEnvironment()
        );
    }

}
```


Overlapping Code:
```
tProcess extends AbstractProcess {
private static final String GROUP_ID = "net.revelc.code.formatter";
private static final String ARTIFACT_ID = "formatter-maven-plugin";
private static final String GOAL = "format";
private static final String XML_CONFIG = "config/formatter.xml";
public FormatProcess(boolean skip, Config config, MavenContext element, Logger logger) {
super("FORMAT", skip, config, element, logger);
}
@Override
public void executeInternal() throws Exception {
Plugin formatterPlugin = getPluginFromComponentDependency(GROUP_ID, ARTIFACT_ID);
assertPlugin(formatterPlugin, GROUP_ID, ARTIFACT_ID, "<dependency>");
String configFile;
File file = getMavenProjectFile(XML_CONFIG);
if (file.exists() && file.isFile()) {
configFile = file.getAbsolutePath();
} else {
configFile = processDefaultConfig(XML_CONFIG);
}
executeMojo(formatterPlugin,
goal(GOAL),
configuration(
element(name("lineEnding"), config.getLineEnding()),
element(name("encoding"), config.getEncoding()),
element(name("configFile"), configFile),
element(name("skipCssFormatting"), "" + config.isSkipCss()),
element(name("skipHtmlFormatting"), "" + config.isSkipHtml()),
element(name("skipJavaFormatting"), "" + config.isSkipJava()),
element(name("skipJsFormatting"), "" + config.isSkipJs()),
element(name("skipJsonFormatting"), "" + config.isSkipJson()),
element(name("skipXmlFormatting"), "true"),
element(name("directories"),
element(name("directory"), "${basedir}/src/main/java"),
element(name("directory"), "${basedir}/src/main/webapp"),
element(name("directory"), "${basedir}/src/test/java"),
element(name("directory"), "${basedir}/src/test/webapp")
),
element(name("includes"),
element(name("include"), "**/*.java"),
element(name("include"), "**/*.html"),
element
```
<Overlap Ratio: 0.982594048287479>

---

--- 178 --
Question ID: 67d8f5e2b9111ea46886be9b7bf66834322379cd
Original Code:
```
public class StoredQCUtils {

    public static Map<SQField, String> getQueryFields(HttpServletRequest servletRequest,
                                                      String defaultQueryField) {
        String tmpDefaultQueryField =
                defaultQueryField == null ?
                        servletRequest.getParameter(C.DEFAULT_QUERY_FIELD) :
                        defaultQueryField;

        String idString = servletRequest.getParameter(C.STORED_QUERY_ID);
        int id = StoredQuery.NOT_YET_LOADED;
        if (!StringUtils.isBlank(idString)) {
            try {
                id = Integer.parseInt(idString);
            } catch (NumberFormatException e) {
                //swallow
            }
        }
        String name = servletRequest.getParameter(C.STORED_QUERY_NAME);
        String maxHits = servletRequest.getParameter(C.MAX_SEARCH_RESULTS);
        if (StringUtils.isBlank(maxHits) || maxHits.equals("default")) {
            maxHits = Integer.toString(StoredQuery.RETRIEVE_ALL_HITS);
        }
        String priority = servletRequest.getParameter(C.STORED_QUERY_PRIORITY);
        if (StringUtils.isBlank(priority) || priority.equals("default") ||
                priority.equals("all")) {
            priority = Integer.toString(StoredQuery.DEFAULT_PRIORITY);
        }
        Map<SQField, String> map = new HashMap<>();
        map.put(SQField.ID, Integer.toString(id));
        map.put(SQField.NAME, name);
        map.put(SQField.DEFAULT_FIELD, tmpDefaultQueryField);
        map.put(SQField.MAIN_QUERY, servletRequest.getParameter(C.MAIN_QUERY));
        map.put(SQField.MAIN_QUERY_TRANSLATION, servletRequest.getParameter(C.MAIN_QUERY_TRANSLATION));
        map.put(SQField.FILTER_QUERY, servletRequest.getParameter(C.FILTER_QUERY));
        map.put(SQField.FILTER_QUERY_TRANSLATION, servletRequest.getParameter(C.FILTER_QUERY_TRANSLATION));
        map.put(SQField.GEO_QUERY_STRING, servletRequest.getParameter(C.GEO_QUERY));
        map.put(SQField.GEO_QUERY_RADIUS_STRING, servletRequest.getParameter(C.GEO_RADIUS));
        map.put(SQField.HIGHLIGHTING_STYLE, servletRequest.getParameter(C.HIGHLIGHT_STYLE));
        map.put(SQField.MAX_HITS, maxHits);
        map.put(SQField.PRIORITY, priority);
        map.put(SQField.NOTES, servletRequest.getParameter(C.STORED_QUERY_NOTES));
        return map;
    }

    public static StoredQuery buildStoredQuery(Map<SQField, String> fields) {
        int id = StoredQuery.NOT_YET_LOADED;
        String intVal = fields.get(SQField.ID);
        if (intVal != null) {
            try {
                id = Integer.parseInt(intVal);
            } catch (NumberFormatException e) {

            }
        }
        StoredQueryBuilder storedQueryBuilder = new StoredQueryBuilder(id, fields.get(SQField.NAME));
        for (Map.Entry<SQField, String> e : fields.entrySet()) {
            if (e.getKey().equals(SQField.NAME)) {
                continue;
            }
            storedQueryBuilder.add(e.getKey(), e.getValue());
        }
        return storedQueryBuilder.build();
    }

    public static StoredConcept buildStoredConcept(Map<SCField, String> fields) {
        StoredConceptBuilder storedConceptBuilder = new StoredConceptBuilder(fields.get(SCField.NAME));
        for (Map.Entry<SCField, String> e : fields.entrySet()) {
            if (e.getKey().equals(SCField.NAME)) {
                continue;
            }
            storedConceptBuilder.add(e.getKey(), e.getValue());
        }
        return storedConceptBuilder.build();
    }
}
```


Overlapping Code:
```

public static Map<SQField, String> getQueryFields(HttpServletRequest servletRequest,
String defaultQueryField) {
String tmpDefaultQueryField =
defaultQueryField == null ?
servletRequest.getParameter(C.DEFAULT_QUERY_FIELD) :
defaultQueryField;
String idString = servletRequest.getParameter(C.STORED_QUERY_ID);
int id = StoredQuery.NOT_YET_LOADED;
if (!StringUtils.isBlank(idString)) {
try {
id = Integer.parseInt(idString);
} catch (NumberFormatException e) {
//swallow
}
}
String name = servletRequest.getParameter(C.STORED_QUERY_NAME);
String maxHits = servletRequest.getParameter(C.MAX_SEARCH_RESULTS);
if (StringUtils.isBlank(maxHits) || maxHits.equals("default")) {
maxHits = Integer.toString(StoredQuery.RETRIEVE_ALL_HITS);
}
String priority = servletRequest.getParameter(C.STORED_QUERY_PRIORITY);
if (StringUtils.isBlank(priority) || priority.equals("default") ||
priority.equals("all")) {
priority = Integer.toString(StoredQuery.DEFAULT_PRIORITY);
}
Map<SQField, String> map = new HashMap<>();
map.put(SQField.ID, Integer.toString(id));
map.put(SQField.NAME, name);
map.put(SQField.DEFAULT_FIELD, tmpDefaultQueryField);
map.put(SQField.MAIN_QUERY, servletRequest.getParameter(C.MAIN_QUERY));
map.put(SQField.MAIN_QUERY_TRANSLATION, servletRequest.getParameter(C.MAIN_QUERY_TRANSLATION));
map.put(SQField.FILTER_QUERY, servletRequest.getParameter(C.FILTER_QUERY));
map.put(SQField.FILTER_QUERY_TRANSLATION, servletRequest.getParameter(C.FILTER_QUERY_TRANSLATION));
map.put(SQField.GEO_QUERY_STRING, servletRequest.getParameter(C.GEO_QUERY));
map.put(SQField.GEO_QUERY_RADIUS_STRING, servletRequest.getParameter(C.GEO_RADIUS));
map.put(SQField.HIGHLIGHTING_STYLE, servletRequest.getParameter(C.HIGHLIGHT_STYLE));
map.put(SQField.MAX_HITS, maxHits);
map.put(SQField.PRIORITY, priority);
map.put(SQField.NOTES, servletRequest.getParameter(C.STORED_QUERY_NOTES));
return map;
}
public static StoredQuery buildStoredQuery(Map<SQField, String> field
```
<Overlap Ratio: 0.9624876604146101>

---

--- 179 --
Question ID: f15535888b742bf4d27de0cdc58c5e1036331bae
Original Code:
```
public class ReaderTokenizerTest extends TestCase {

	public void testReaderTokenizerRules() throws IOException, TokenizerException {
		String input = FileUtils.getFromResource("ee/pri/rl/tokenizer/reader/test/test.rules");
		long start = System.currentTimeMillis();
		List<Token> tokens = ReaderTokenizer.tokenize(input);
		System.out.println("Tokenizing took " + (System.currentTimeMillis() - start) + "ms");
		assertFalse(tokens.isEmpty());
		assertTrue(tokens.get(0).equals(new Token("startState", "startState", 0)));
		assertTrue(tokens.get(1).equals(new Token("endState", "end", 0)));
	}
}
```


Overlapping Code:
```
st extends TestCase {
public void testReaderTokenizerRules() throws IOException, TokenizerException {
String input = FileUtils.getFromResource("ee/pri/rl/tokenizer/reader/test/test.rules");
long start = System.currentTimeMillis();
List<Token> tokens = ReaderTokenizer.tokenize(input);
System.out.println("Tokenizing took " + (System.currentTimeMillis() - start) + "ms");
assertFalse(tokens.isEmpty());
assertTrue(tokens.get(0).equals(new Token("startState", "startState", 0)));
assertTrue(tokens.get(
```
<Overlap Ratio: 0.8650519031141869>

---

--- 180 --
Question ID: ddb5b3026235ba7a3bddf3ecf1505502cfcf4ce2
Original Code:
```
public class LayerCacheUtils {

  private LayerCacheUtils() {}

  /** @return number of actually collected, which may be less than or equals to pointNumber */
  public static int cachePoints(
      TSDataType dataType,
      LayerPointReader source,
      ElasticSerializableTVList target,
      int pointNumber)
      throws QueryProcessException, IOException {
    int count = 0;
    while (count < pointNumber && cachePoint(dataType, source, target)) {
      ++count;
    }
    return count;
  }

  public static boolean cachePoint(
      TSDataType dataType, LayerPointReader source, ElasticSerializableTVList target)
      throws IOException, QueryProcessException {
    if (!source.next()) {
      return false;
    }
    if (source.isCurrentNull()) {
      target.putNull(source.currentTime());
    } else {
      switch (dataType) {
        case INT32:
          target.putInt(source.currentTime(), source.currentInt());
          break;
        case INT64:
          target.putLong(source.currentTime(), source.currentLong());
          break;
        case FLOAT:
          target.putFloat(source.currentTime(), source.currentFloat());
          break;
        case DOUBLE:
          target.putDouble(source.currentTime(), source.currentDouble());
          break;
        case BOOLEAN:
          target.putBoolean(source.currentTime(), source.currentBoolean());
          break;
        case TEXT:
          target.putBinary(
              source.currentTime(),
              UDFBinaryTransformer.transformToUDFBinary(source.currentBinary()));
          break;
        default:
          throw new UnsupportedOperationException(dataType.name());
      }
    }

    source.readyForNext();

    return true;
  }

  /** @return number of actually collected, which may be less than or equals to rowsNumber */
  public static int cacheRows(
      IUDFInputDataSet source, ElasticSerializableRowRecordList target, int rowsNumber)
      throws QueryProcessException, IOException {
    int count = 0;
    while (count < rowsNumber && cacheRow(source, target)) {
      ++count;
    }
    return count;
  }

  public static boolean cacheRow(IUDFInputDataSet source, ElasticSerializableRowRecordList target)
      throws IOException, QueryProcessException {
    if (source.hasNextRowInObjects()) {
      target.put(source.nextRowInObjects());
      return true;
    } else {
      return false;
    }
  }
}
```


Overlapping Code:
```
eUtils {
private LayerCacheUtils() {}
/** @return number of actually collected, which may be less than or equals to pointNumber */
public static int cachePoints(
TSDataType dataType,
LayerPointReader source,
ElasticSerializableTVList target,
int pointNumber)
throws QueryProcessException, IOException {
int count = 0;
while (count < pointNumber && cachePoint(dataType, source, target)) {
++count;
}
return count;
}
public static boolean cachePoint(
TSDataType dataType, LayerPointReader source, ElasticSerializableTVList target)
throws IOException, QueryProcessException {
if (!source.next()) {
return false;
}
if (source.isCurrentNull()) {
target.putNull(source.currentTime());
} else {
switch (dataType) {
case INT32:
target.putInt(source.currentTime(), source.currentInt());
break;
case INT64:
target.putLong(source.currentTime(), source.currentLong());
break;
case FLOAT:
target.putFloat(source.currentTime(), source.currentFloat());
break;
case DOUBLE:
target.putDouble(source.currentTime(), source.currentDouble());
break;
case BOOLEAN:
target.putBoolean(source.currentTime(), source.currentBoolean());
break;
case TEXT:
target.putBinary(
source.currentTime(),
UDFBinaryTransformer.transformToUDFBinary(source.currentBinary()));
break;
default:
throw new UnsupportedOperationException(dataType.name());
}
}
source.readyForNext();
return true;
}
/** @return number of actually collected, which may be less than or equals to rowsNumber */
public static int cacheRows(
IUDFInputDataSet source, ElasticSerializableRowRecordList target, int rowsNumber)
throws QueryProcessException, IOException {
int count = 0;
while (count < rowsNumber && cacheRow(source, target)) {
++count;
}
return count;
}
public static boolean cacheRow(IUDFInputDataSet source, ElasticSerializableRowRecordList target)
throws IOException, QueryProcessException {
if (source.hasNextRowInObjects()) {
target.put(source.nextRowInObjects());
return true;
} else {
return false;
}
```
<Overlap Ratio: 0.9868421052631579>

---

--- 181 --
Question ID: 3917982c1fdc78abf81711dbaacc636d46db79c3
Original Code:
```
public class DeleteExpiredDataResponse implements ToXContentObject {

    private static final ParseField DELETED = new ParseField("deleted");

    public DeleteExpiredDataResponse(boolean deleted) {
        this.deleted = deleted;
    }

    public static final ConstructingObjectParser<DeleteExpiredDataResponse, Void> PARSER =
        new ConstructingObjectParser<>("delete_expired_data_response", true,
            a -> new DeleteExpiredDataResponse((Boolean) a[0]));

    static {
        PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), DELETED);
    }

    public static DeleteExpiredDataResponse fromXContent(XContentParser parser) throws IOException {
        return PARSER.parse(parser, null);
    }

    private final Boolean deleted;

    public Boolean getDeleted() {
        return deleted;
    }

    @Override
    public int hashCode() {
        return Objects.hash(deleted);
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {
        builder.startObject();
        if (deleted != null) {
            builder.field(DELETED.getPreferredName(), deleted);
        }
        builder.endObject();
        return builder;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        DeleteExpiredDataResponse response = (DeleteExpiredDataResponse) obj;
        return Objects.equals(deleted, response.deleted);
    }
}
```


Overlapping Code:
```
sponse implements ToXContentObject {
private static final ParseField DELETED = new ParseField("deleted");
public DeleteExpiredDataResponse(boolean deleted) {
this.deleted = deleted;
}
public static final ConstructingObjectParser<DeleteExpiredDataResponse, Void> PARSER =
new ConstructingObjectParser<>("delete_expired_data_response", true,
a -> new DeleteExpiredDataResponse((Boolean) a[0]));
static {
PARSER.declareBoolean(ConstructingObjectParser.constructorArg(), DELETED);
}
public static DeleteExpiredDataResponse fromXContent(XContentParser parser) throws IOException {
return PARSER.parse(parser, null);
}
private final Boolean deleted;
public Boolean getDeleted() {
return deleted;
}
@Override
public int hashCode() {
return Objects.hash(deleted);
}
@Override
public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {
builder.startObject();
if (deleted != null) {
builder.field(DELETED.getPreferredName(), deleted);
}
builder.endObject();
return builder;
}
@Override
public boolean equals(Object obj) {
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
DeleteExpiredDataResponse response = (DeleteExpiredDataResponse) obj;
return Objects.equals(deleted, response.del
```
<Overlap Ratio: 0.96771714066103>

---

--- 182 --
Question ID: 5a9151cdab968b79fc588b9fc48a6421b5a8c539
Original Code:
```
public class PuppetPropertiesHandler {
    static List<InstanceProperty> getComponentInstanceProperties(ComponentType componentType, List<Fact> facts) {
        List<InstanceProperty> instanceProperties = new ArrayList<>();
        facts.forEach(fact -> instanceProperties.add(new InstanceProperty(fact.getName(),
            fact.getValue().getClass().getSimpleName(),
            fact.getValue())));
        EDMMPropertyMapperImplementation propMapper = new EDMMPropertyMapperImplementation();
        instanceProperties.forEach(instanceProperty -> instanceProperty.setKey(propMapper.mapToEDMMPropertyKey(
            componentType,
            instanceProperty.getKey())));
        List<InstanceProperty> toBeRemoved = new ArrayList<>();
        for (InstanceProperty instanceProperty : instanceProperties) {
            if (instanceProperty.getKey() == null) {
                toBeRemoved.add(instanceProperty);
            }
        }
        instanceProperties.removeAll(toBeRemoved);
        return instanceProperties;
    }

    private static String readPrivateKeyFileIntoString(String privateKeyLocation) {
        StringBuilder privateKey = new StringBuilder();
        try (Stream<String> stream = Files.lines(Paths.get(privateKeyLocation))) {
            stream.forEach(line -> privateKey.append(line).append("\n"));
        } catch (IOException e) {
            throw new InstanceTransformationException("Failed to convert private key!", e.getCause());
        }
        return privateKey.toString();
    }

    private static String generatePublicKeyFromPrivateKeyLocation(String privateKeyLocation) {
        String privateKeyString = readPrivateKeyFileIntoString(privateKeyLocation);
        privateKeyString = privateKeyString.replace("-----BEGIN RSA PRIVATE KEY-----\n", "");
        privateKeyString = privateKeyString.replace("-----END RSA PRIVATE KEY-----", "");
        try {
            byte[] decoded = Base64.decodeBase64(privateKeyString);
            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);
            java.security.Security.addProvider(
                new org.bouncycastle.jce.provider.BouncyCastleProvider()
            );
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
            RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) privateKey;
            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(privateCrtKey.getModulus(),
                privateCrtKey.getPublicExponent());
            PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);

            java.util.Base64.Encoder encoder = java.util.Base64.getEncoder();

            return encoder.encodeToString(publicKey.getEncoded());
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            throw new InstanceTransformationException("Failed to convert public key", e.getCause());
        }
    }
}
```


Overlapping Code:
```
sHandler {
static List<InstanceProperty> getComponentInstanceProperties(ComponentType componentType, List<Fact> facts) {
List<InstanceProperty> instanceProperties = new ArrayList<>();
facts.forEach(fact -> instanceProperties.add(new InstanceProperty(fact.getName(),
fact.getValue().getClass().getSimpleName(),
fact.getValue())));
EDMMPropertyMapperImplementation propMapper = new EDMMPropertyMapperImplementation();
instanceProperties.forEach(instanceProperty -> instanceProperty.setKey(propMapper.mapToEDMMPropertyKey(
componentType,
instanceProperty.getKey())));
List<InstanceProperty> toBeRemoved = new ArrayList<>();
for (InstanceProperty instanceProperty : instanceProperties) {
if (instanceProperty.getKey() == null) {
toBeRemoved.add(instanceProperty);
}
}
instanceProperties.removeAll(toBeRemoved);
return instanceProperties;
}
private static String readPrivateKeyFileIntoString(String privateKeyLocation) {
StringBuilder privateKey = new StringBuilder();
try (Stream<String> stream = Files.lines(Paths.get(privateKeyLocation))) {
stream.forEach(line -> privateKey.append(line).append("\n"));
} catch (IOException e) {
throw new InstanceTransformationException("Failed to convert private key!", e.getCause());
}
return privateKey.toString();
}
private static String generatePublicKeyFromPrivateKeyLocation(String privateKeyLocation) {
String privateKeyString = readPrivateKeyFileIntoString(privateKeyLocation);
privateKeyString = privateKeyString.replace("-----BEGIN RSA PRIVATE KEY-----\n", "");
privateKeyString = privateKeyString.replace("-----END RSA PRIVATE KEY-----", "");
try {
byte[] decoded = Base64.decodeBase64(privateKeyString);
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);
java.security.Security.addProvider(
new org.bouncycastle.jce.provider.BouncyCastleProvider()
);
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
RSAPrivateCrtKey privateCrtKey = (RSAPrivateCrtKey) privateKey;
RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(privateCrtKey.getModul
```
<Overlap Ratio: 0.9842707340324118>

---

--- 183 --
Question ID: 9ef90ac9481642aa9f15fc4c51765c42dbbd38ef
Original Code:
```
public class ASTDivNode extends SimpleNode {
    /**
     * Create the node given an id.
     *
     * @param id node id.
     */
    public ASTDivNode(int id) {
        super(id);
    }

    /**
     * Create a node with the given parser and id.
     *
     * @param p a parser.
     * @param id node id.
     */
    public ASTDivNode(Parser p, int id) {
        super(p, id);
    }

    /** {@inheritDoc} */
    public Object jjtAccept(ParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    /** {@inheritDoc} */
    public Object value(JexlContext jc) throws Exception {
        Object left = ((SimpleNode) jjtGetChild(0)).value(jc);
        Object right = ((SimpleNode) jjtGetChild(1)).value(jc);

        /*
         * the spec says 'and', I think 'or'
         */
        if (left == null && right == null) {
            return new Byte((byte) 0);
        }

        if (left instanceof BigInteger || right instanceof BigInteger) {
            BigInteger l = Coercion.coerceBigInteger(left);
            BigInteger r = Coercion.coerceBigInteger(right);
            return l.divide(r);
        }

        if (left instanceof BigDecimal || right instanceof BigDecimal) {
            BigDecimal l = Coercion.coerceBigDecimal(left);
            BigDecimal r = Coercion.coerceBigDecimal(right);
            return l.divide(r);
        }

        Double l = Coercion.coerceDouble(left);
        Double r = Coercion.coerceDouble(right);

        /*
         * catch div/0
         */
        if (r.doubleValue() == 0.0) {
            return new Double(0.0);
        }

        return new Double(l.doubleValue() / r.doubleValue());

    }
}
```


Overlapping Code:
```
ivNode extends SimpleNode {
/**
* Create the node given an id.
*
* @param id node id.
*/
public ASTDivNode(int id) {
super(id);
}
/**
* Create a node with the given parser and id.
*
* @param p a parser.
* @param id node id.
*/
public ASTDivNode(Parser p, int id) {
super(p, id);
}
/** {@inheritDoc} */
public Object jjtAccept(ParserVisitor visitor, Object data) {
return visitor.visit(this, data);
}
/** {@inheritDoc} */
public Object value(JexlContext jc) throws Exception {
Object left = ((SimpleNode) jjtGetChild(0)).value(jc);
Object right = ((SimpleNode) jjtGetChild(1)).value(jc);
/*
* the spec says 'and', I think 'or'
*/
if (left == null && right == null) {
return new Byte((byte) 0);
}
if (left instanceof BigInteger || right instanceof BigInteger) {
BigInteger l = Coercion.coerceBigInteger(left);
BigInteger r = Coercion.coerceBigInteger(right);
return l.divide(r);
}
if (left instanceof BigDecimal || right instanceof BigDecimal) {
BigDecimal l = Coercion.coerceBigDecimal(left);
BigDecimal r = Coercion.coerceBigDecimal(right);
return l.divide(r);
}
Double l = Coercion.coerceDouble(left);
Double r = Coercion.coerceDouble(right);
/*
* catch div/0
*/
if (r.doubleValue() == 0.0) {
return new Double(0.0);
}
return new Double(l.doubleValue() / r.doubleVal
```
<Overlap Ratio: 0.9791344667697064>

---

--- 184 --
Question ID: 2096f9da8bf6293bc5ccfca74d51f46d0f85a1c6
Original Code:
```
public class EncryptionUnit {
    /* The purpose of the EncryptionUnit is to encapsulate all security functionality
     * for the app. This object will handle the RSA key pair and specific information about
     * the decryption process, namely the private key, from the rest of the app. This class
     * will return a private key as a string that can be sent to the ESP32, as well as decrypt
     * and given message. This object is not intended to do an encryption because the only data
     * that is transmitted is sent from the ESP.
     */
    private String encryptionAlgorithm = "RSA";
    private KeyPairGenerator keyGen;
    private KeyPair keyPair;

    private SecretKeyFactory symetricKeyFactory;
    private SecretKey symmetricKey;

    private Cipher cipher;
    private Cipher dataCipher;

    private IvParameterSpec ivSpec;


    /* Constructor
     * The constructor will create the KeyPairGenerator, use it to create a public
     * and private key in a KeyPair object, and construct the cipher as well.
     */
    public EncryptionUnit(){
        //Constructs the KeyPairGenerator and the SecretKeyFactory
        try {
            keyGen = KeyPairGenerator.getInstance(encryptionAlgorithm);
            symetricKeyFactory = SecretKeyFactory.getInstance("AES/CBC/NoPadding");
        } catch (Exception NoSuchAlgorithmException) {
            Log.d("key gen", "Algorithm not found");
        }
        //Generates the Private/Public key pair
        keyPair = keyGen.generateKeyPair();
        //constructs the Cipher object.
        try {
            cipher = Cipher.getInstance(encryptionAlgorithm);
        } catch (Exception NoSuchAlgorithmException) {
            Log.d("cipher init", "Algorithm not found");
        }
        try {
            dataCipher = Cipher.getInstance("AES/CBC/NoPadding");
        } catch (Exception NoSuchAlgorithmException) {
            Log.d("cipher2 init", "Algorithm not found");
        }
        //sets the Cipher to decrypt by default
        try {
            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
        } catch(Exception InvalidKeyException){
            Log.d("cipther init", "Bad Private Key");
        }


    }

    public String getPubKeyS(){
        PublicKey pubKey = keyPair.getPublic();
//        byte[] keyBytes = Base64.encode(pubKey.getEncoded(), Base64.DEFAULT);
//        String pubKeyS = new String(keyBytes);

        String pubKeyS = pubKey.toString();
        return pubKeyS;
    }
    public byte[] getPubKey(){
        PublicKey pubKey = keyPair.getPublic();
        return pubKey.getEncoded();
    }

    public String getPrivKeyS(){
        PrivateKey privateKey = keyPair.getPrivate();
        return privateKey.toString();
    }
    public String getSymKeyS(){
        return symmetricKey.toString();
    }

    public byte[] getSymKey(){
        return symmetricKey.getEncoded();
    }

    /* This function creates a SecretKey object from the encrypted key sent by the board that
     * java functions can use to decrypt future received sensor data which will have been encrypted with
     * the symmetric key.
     * INPUT: keySource, The byte array received via readCharacteristic from the board containing the encrypted
     *  key, iv, the initialization vector sent by the board (unencrypted).
     * OUTPUT: No value is returned, but the global variable symmetricKey is set to the SecretKey
     *  generated from the value sent from the board.
     */
    public void createSymmetricKey(byte[] keySource, byte[] iv){
        byte[] decryptedSource = null;
        ivSpec = new IvParameterSpec(iv);
        try {
            cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
        } catch(Exception InvalidKeyException){
            Log.d("cipther init", "Bad Private Key");
        }
        try {
            decryptedSource = cipher.doFinal(keySource);
        } catch(Exception IllegalBlockSizeException){
            Log.d("decryption", "bad block size");
        }
        if (decryptedSource != null) {
            byte[] keyCliped = Arrays.copyOfRange(decryptedSource, 223, 255);
            symmetricKey = new SecretKeySpec(keyCliped, "AES/CBC/NoPadding");
        }

        try {
            dataCipher.init(Cipher.DECRYPT_MODE, symmetricKey, ivSpec);
        } catch(Exception InvalidKeyException){
            Log.d("cipther init", "Bad Private Key");
        }
    }

    /* Decrypts the message sent from the esp
     * INPUT: The string that was sent from the ESP
     * OUTPUT: A string that is the decrypted data ONLY if decryption was successful, otherwise an error
     * message (success means no errors were thrown, this does not mean the decrypted message is correct)
     */
    public byte[] decrypt(byte[] message){
        byte[] data = new byte[0];
        //decrypts the message
        try {
            data = dataCipher.doFinal(message);
        } catch(Exception IllegalBlockSizeException){
            Log.d("decryption", "bad block size");
        }
        byte[] iv_view = dataCipher.getIV();
        //re-init dataCipher with iv_view
        return data;
    }


}
```


Overlapping Code:
```
 The purpose of the EncryptionUnit is to encapsulate all security functionality
* for the app. This object will handle the RSA key pair and specific information about
* the decryption process, namely the private key, from the rest of the app. This class
* will return a private key as a string that can be sent to the ESP32, as well as decrypt
* and given message. This object is not intended to do an encryption because the only data
* that is transmitted is sent from the ESP.
*/
private String encryptionAlgorithm = "RSA";
private KeyPairGenerator keyGen;
private KeyPair keyPair;
private SecretKeyFactory symetricKeyFactory;
private SecretKey symmetricKey;
private Cipher cipher;
private Cipher dataCipher;
private IvParameterSpec ivSpec;
/* Constructor
* The constructor will create the KeyPairGenerator, use it to create a public
* and private key in a KeyPair object, and construct the cipher as well.
*/
public EncryptionUnit(){
//Constructs the KeyPairGenerator and the SecretKeyFactory
try {
keyGen = KeyPairGenerator.getInstance(encryptionAlgorithm);
symetricKeyFactory = SecretKeyFactory.getInstance("AES/CBC/NoPadding");
} catch (Exception NoSuchAlgorithmException) {
Log.d("key gen", "Algorithm not found");
}
//Generates the Private/Public key pair
keyPair = keyGen.generateKeyPair();
//constructs the Cipher object.
try {
cipher = Cipher.getInstance(encryptionAlgorithm);
} catch (Exception NoSuchAlgorithmException) {
Log.d("cipher init", "Algorithm not found");
}
try {
dataCipher = Cipher.getInstance("AES/CBC/NoPadding");
} catch (Exception NoSuchAlgorithmException) {
Log.d("cipher2 init", "Algorithm not found");
}
//sets the Cipher to decrypt by default
try {
cipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());
} catch(Exception InvalidKeyException){
Log.d("cipther init", "Bad Private Key");
}
}
public String getPubKeyS(){
PublicKey pubKey = keyPair.getPublic();
// byte[] keyBytes = Base64.encode(pubKey.getEncoded(), Base64.DEFAULT);
// String pubKeyS = new String(keyBytes);
String pubKeyS = pubKey.toString();
return
```
<Overlap Ratio: 0.9747979077508322>

---

--- 185 --
Question ID: 2a1cec440681d6709525614923a49a7328b40bd8
Original Code:
```
@Controller
public class ServiceController {
	
	@Autowired ServiceRepository serRepo;
	
	@GetMapping("/service")
	public String serviceList(Model model) {
		var serviceList = serRepo.getAllPrescence();
		
		System.out.print("serviceList -> serviceList.size()");
		System.out.println(serviceList.size());
		
		model.addAttribute("serviceList", serviceList);
		return "serviceList";
	}

}
```


Overlapping Code:
```

public class ServiceController {

@Autowired ServiceRepository serRepo;

@GetMapping("/service")
public String serviceList(Model model) {
var serviceList = serRepo.getAllPrescence();

System.out.print("serviceList -> serviceList.size()");
System.out.println(serviceList.size());

model.addAttribute("serviceList", serviceList);
return "serviceList";
```
<Overlap Ratio: 0.958904109589041>

---

--- 186 --
Question ID: 03bf50425e2ed4500979a26bb562e68bf9680a1d
Original Code:
```
class StatusMap extends LinkedHashMap<Long, Map<String, Object>> 
{
   private static final long serialVersionUID = 1L;
   private static final int MAX_JOB_EXECUTION_COUNT = 1000;

   protected boolean removeEldestEntry(Map.Entry<Long, Map<String, Object>> eldest) {
      Map<String, Object> data = eldest.getValue();
      boolean unregistered = (Boolean) data
            .get(InMemoryJobExecutionStatusHolder.JOB_UNREGISTERED);
      return unregistered && size() > MAX_JOB_EXECUTION_COUNT;
   }
}
```


Overlapping Code:
```
HashMap<Long, Map<String, Object>> 
{
private static final long serialVersionUID = 1L;
private static final int MAX_JOB_EXECUTION_COUNT = 1000;
protected boolean removeEldestEntry(Map.Entry<Long, Map<String, Object>> eldest) {
Map<String, Object> data = eldest.getValue();
boolean unregistered = (Boolean) data
.get(InMemoryJobExecutionStatusHolder.JOB_UNREGISTERED);
return unregistered && size() > 
```
<Overlap Ratio: 0.8733624454148472>

---

--- 187 --
Question ID: cf8d089649c6d4b70a4e05e41f112ac9b266964a
Original Code:
```
@Component
public class DatabaseLoader implements CommandLineRunner {

	@Autowired
    private CustomerRepository custRepo;
    @Autowired
    private AccountRepository acctRepo;
    @Autowired
    private TransactionRepository transRepo;

    @Autowired
    public DatabaseLoader(CustomerRepository custRepo, AccountRepository acctRepo, TransactionRepository transRepo) {
		this.custRepo = custRepo;
		this.acctRepo = acctRepo;
		this.transRepo = transRepo;
	}

	@Override
	public void run(String... args) throws Exception {
		Customer chris = new Customer("cj", "password", "Chris Jabb","chrisjabb@aol.com","nowhere", "1233334545");
		Customer matt = new Customer("mk", "password", "Matty K","servethesovietunion@lol.com","everwhere","2223334545");
		Customer nat = new Customer("nn", "password", "Natasha Ng","nn@yahoo.com","Seattle","3123334545");
		Customer dan = new Customer("db", "password", "Danny B","danny@netscape.com","somewhere", "693334545");
		
		Account chrisAcct = new Account();
		chris.addCustomerToAccount(chrisAcct);
		System.out.println(chrisAcct.getCustomersOnAccount());
		System.out.println(chris.getAccounts());
		Account natAcct = new Account(AccountType.SAVINGS);
		nat.addCustomerToAccount(natAcct);
		Account danXMatt = new Account(AccountType.BROKERAGE);
		dan.addCustomerToAccount(danXMatt);
		matt.addCustomerToAccount(danXMatt);
		
		Transaction trans1 = chrisAcct.deposit(100.0, "Initial deposit");
		Transaction trans2 = chrisAcct.withdraw(10.0, "Money for lunch");
		Transaction trans3 = danXMatt.deposit(1000.0, "Init dep");
		Transaction trans4 = natAcct.deposit(1000000.0, "Nats a high roller");
		
		this.custRepo.save(chris);
		this.custRepo.save(matt);
		this.custRepo.save(nat);
		this.custRepo.save(dan);
		
		this.acctRepo.save(chrisAcct);
		this.acctRepo.save(natAcct);
		this.acctRepo.save(danXMatt);
		
		this.transRepo.save(trans1);
		this.transRepo.save(trans2);
		this.transRepo.save(trans3);
		this.transRepo.save(trans4);
	}
    
}
```


Overlapping Code:
```
@Component
public class DatabaseLoader implements CommandLineRunner {
@Autowired
private CustomerRepository custRepo;
@Autowired
private AccountRepository acctRepo;
@Autowired
private TransactionRepository transRepo;
@Autowired
public DatabaseLoader(CustomerRepository custRepo, AccountRepository acctRepo, TransactionRepository transRepo) {
this.custRepo = custRepo;
this.acctRepo = acctRepo;
this.transRepo = transRepo;
}
@Override
public void run(String... args) throws Exception {
Customer chris = new Customer(e", "1233334545");
Customer matt = new Customer("mre","2223334545");
Customer nat = new Customer("nn123334545");
Customer dan = new Customer("db", "pa45");

Account chrisAcct = new Account();
chris.addCustomerToAccount(chrisAcct);
System.out.println(chrisAcct.getCustomersOnAccount());
System.out.println(chris.getAccounts());
Account natAcct = new Account(AccountType.SAVINGS);
nat.addCustomerToAccount(natAcct);
Account danXMatt = new Account(AccountType.BROKERAGE);
dan.addCustomerToAccount(danXMatt);
matt.addCustomerToAccount(danXMatt);

Transaction trans1 = chrisAcct.deposit(100.0, "Initial deposit");
Transaction trans2 = chrisAcct.withdraw(10.0, "Money for lunch");
Transaction trans3 = danXMatt.deposit(1000.0, "Init dep");
Transaction trans4 = natAcct.deposit(1000000.0, "Nats a high roller");

this.custRepo.save(chris);
this.custRepo.save(matt);
this.custRepo.save(nat);
this.custRepo.save(dan);

this.acctRepo.save(chrisAcct);
this.acctRepo.save(natAcct);
this.acctRepo.save(danXMatt);

this.transRepo.save(trans1);
this.transRepo.save(trans2);
this.transRepo.save(trans3);
this.transRe
```
<Overlap Ratio: 0.8617929562433297>

---

--- 188 --
Question ID: 9d20f169b97cef480ba19001efb76699d41b2a9c
Original Code:
```
public class JSONPluginTaskDataBuilder extends PluginTaskDataBuilder<JSONTaskData> {

	private PluginDataSource<JSONTaskData> dataSource;
	
	public static JSONPluginTaskDataBuilder newBuilder() {
		return new JSONPluginTaskDataBuilder();
	}

	public JSONPluginTaskDataBuilder withDataSource( PluginDataSource<JSONTaskData> dataSource) {
		this.dataSource = dataSource;
		return this;
	}
	
	@Override
	public PluginJobDetailImpl<JSONTaskData> build() {
		// TODO Auto-generated method stub
		JSONPluginJobDetailImpl impl = new JSONPluginJobDetailImpl();
		impl.setDataSource(dataSource);
		return impl;
	}
}
```


Overlapping Code:
```
PluginTaskDataBuilder extends PluginTaskDataBuilder<JSONTaskData> {
private PluginDataSource<JSONTaskData> dataSource;

public static JSONPluginTaskDataBuilder newBuilder() {
return new JSONPluginTaskDataBuilder();
}
public JSONPluginTaskDataBuilder withDataSource( PluginDataSource<JSONTaskData> dataSource) {
this.dataSource = dataSource;
return this;
}

@Override
public PluginJobDetailImpl<JSONTaskData> build() {
// TODO Auto-generated method stub
JSONPluginJobDetailImpl impl = new JSONPluginJobDetailImpl();
impl.setDataSource(dataSource);
ret
```
<Overlap Ratio: 0.9482758620689655>

---

--- 189 --
Question ID: 1e9917f7a1d92e43a183f5e4598c7ca83d807b1a
Original Code:
```
@EqualsAndHashCode
public class RoleRequestCondition implements RequestCondition<RoleRequestCondition> {
    private Set<String> roles;

    public RoleRequestCondition(Set<String> roles) {
        this.roles = roles;
    }

    public RoleRequestCondition(String... roles) {
        this(new HashSet<>(Arrays.asList(roles)));
    }

    public Set<String> getRoles() {
        return roles;
    }

    @Override
    public RoleRequestCondition combine(RoleRequestCondition other) {
        this.roles.addAll(other.getRoles());
        return this;
    }

    @Override
    public RoleRequestCondition getMatchingCondition(HttpServletRequest request) {
        Set<String> userRoles = SecurityContextHolder.getContext().getAuthentication().getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toSet());

        for (String role : userRoles) {
            if (this.roles.contains(role)) {
                return this;
            }
        }

        return null;
    }

    @Override
    public int compareTo(RoleRequestCondition other, HttpServletRequest request) {
        return this.roles.size() - other.getRoles().size();
    }
}
```


Overlapping Code:
```
sAndHashCode
public class RoleRequestCondition implements RequestCondition<RoleRequestCondition> {
private Set<String> roles;
public RoleRequestCondition(Set<String> roles) {
this.roles = roles;
}
public RoleRequestCondition(String... roles) {
this(new HashSet<>(Arrays.asList(roles)));
}
public Set<String> getRoles() {
return roles;
}
@Override
public RoleRequestCondition combine(RoleRequestCondition other) {
this.roles.addAll(other.getRoles());
return this;
}
@Override
public RoleRequestCondition getMatchingCondition(HttpServletRequest request) {
Set<String> userRoles = SecurityContextHolder.getContext().getAuthentication().getAuthorities().stream()
.map(GrantedAuthority::getAuthority)
.collect(Collectors.toSet());
for (String role : userRoles) {
if (this.roles.contains(role)) {
return this;
}
}
return null;
}
@Override
public int compareTo(RoleRequestCondition other, HttpServletRequest request) {
return this.roles.size() - other.getRo
```
<Overlap Ratio: 0.9763617677286742>

---

--- 190 --
Question ID: 7fed804b68876c4bf94dce0394e1695dc0ac1c97
Original Code:
```
public class PhilosophersStoneItem extends TransmutableReagentItem {
    public final long minCharge, maxCharge;

    // Kinda ugly hack to retain the ItemStack for getUnitCharge
    private static ItemStack heldStack = null;

    public PhilosophersStoneItem (Settings settings, AlchymReference.PhilosophersStoneCharges charge) {
        super (settings);

        minCharge = charge.min;
        maxCharge = charge.max;
    }

    @Override
    public boolean isReagent() {
        return true;
    }

    @Override
    public long getUnitCharge() {
        long charge = 0;

        if (heldStack != null) {
            charge = getStoneCharge (heldStack);
            heldStack = null;
        }
        return charge;
    }

    @Override
    public AlchymReference.Reagents getReagentType() {
        return AlchymReference.Reagents.PHILOSOPHERS_STONE;
    }

    @Override
    public TypedActionResult<ItemStack> use (World world, PlayerEntity player, Hand hand) {
        if (!world.isClient && isPhilosophersStone (player.getStackInHand (hand))) {
            PhilosophersStoneItem.setHeldStack (player.getStackInHand (hand));

            // Delegate to superclass use method
            return super.use (world, player, hand);
        }

        return new TypedActionResult(ActionResult.PASS, player.getStackInHand (hand));
    }

    public static long getStoneCharge (ItemStack stack) {
        long charge = 0L;

        if (stack != null && ! stack.isEmpty() && stack.getItem () instanceof PhilosophersStoneItem) {
            if (stack.hasTag () && stack.getTag ().contains (AlchymReference.MODID) &&
                    stack.getTag ().getCompound (AlchymReference.MODID).contains ("stone_charge")) {
                charge = stack.getTag ().getCompound (AlchymReference.MODID).getLong ("stone_charge");
            } else {
                CompoundTag tag = new CompoundTag ();
                charge = ((PhilosophersStoneItem) stack.getItem ()).minCharge;
                tag.putLong ("stone_charge", charge);
                stack.setTag(tag);
            }
        }

        return charge;
    }

    public static void setHeldStack (ItemStack stack) {
        heldStack = stack;
    }

    private boolean isPhilosophersStone (ItemStack stack) {
        return TransmutationHelper.isReagent (stack) && stack.getItem() instanceof PhilosophersStoneItem;
    }
}
```


Overlapping Code:
```
hilosophersStoneItem extends TransmutableReagentItem {
public final long minCharge, maxCharge;
// Kinda ugly hack to retain the ItemStack for getUnitCharge
private static ItemStack heldStack = null;
public PhilosophersStoneItem (Settings settings, AlchymReference.PhilosophersStoneCharges charge) {
super (settings);
minCharge = charge.min;
maxCharge = charge.max;
}
@Override
public boolean isReagent() {
return true;
}
@Override
public long getUnitCharge() {
long charge = 0;
if (heldStack != null) {
charge = getStoneCharge (heldStack);
heldStack = null;
}
return charge;
}
@Override
public AlchymReference.Reagents getReagentType() {
return AlchymReference.Reagents.PHILOSOPHERS_STONE;
}
@Override
public TypedActionResult<ItemStack> use (World world, PlayerEntity player, Hand hand) {
if (!world.isClient && isPhilosophersStone (player.getStackInHand (hand))) {
PhilosophersStoneItem.setHeldStack (player.getStackInHand (hand));
// Delegate to superclass use method
return super.use (world, player, hand);
}
return new TypedActionResult(ActionResult.PASS, player.getStackInHand (hand));
}
public static long getStoneCharge (ItemStack stack) {
long charge = 0L;
if (stack != null && ! stack.isEmpty() && stack.getItem () instanceof PhilosophersStoneItem) {
if (stack.hasTag () && stack.getTag ().contains (AlchymReference.MODID) &&
stack.getTag ().getCompound (AlchymReference.MODID).contains ("stone_charge")) {
charge = stack.getTag ().getCompound (AlchymReference.MODID).getLong ("stone_charge");
} else {
CompoundTag tag = new CompoundTag ();
charge = ((PhilosophersStoneItem) stack.getItem ()).minCharge;
tag.putLong ("stone_charge", charge);
stack.setTag(tag);
}
}
return charge;
}
public static void setHeldStack (ItemStack stack) {
heldStack = stack;
}
private boolean isPhilosophersStone (ItemStack stack) {
return TransmutationHelper.isReagent (stack) && stack.getItem() instanceof Phil
```
<Overlap Ratio: 0.981404958677686>

---

--- 191 --
Question ID: bbd7840f29894d8dba6056ef50d3f0feaa82da43
Original Code:
```
public class IoVsNio {

    public static void main(String[] args) throws Exception {
        File file = new File("C:\\Users\\leoca\\AppData\\Local\\Temp\\io-vs-nio5577439411617059014.data");
        createFile(25);
        System.out.println(file.getAbsolutePath());
        //  withNio(file);
        withIO(file);
        // withNio(file);


    }

    public static File createFile(final long sizeInMB) {
        File file = null;
        try {
            file = File.createTempFile("io-vs-nio", ".data");
            file.createNewFile();

            RandomAccessFile raf = new RandomAccessFile(file, "rw");
            raf.setLength(sizeInMB * 100000000);
            raf.close();

            return file;
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static long withIO(File origin) throws Exception {
        File destination = new File(origin.getAbsolutePath() + ".io-" + UUID.randomUUID());
        long time1 = System.currentTimeMillis();
        InputStream is = new FileInputStream(origin);
        FileOutputStream fos = new FileOutputStream(destination);
        byte[] buf = new byte[64 * 1024];
        int len = 0;
        while ((len = is.read(buf)) != -1) {
            fos.write(buf, 0, len);
        }
        fos.flush();
        fos.close();
        is.close();
        long time2 = System.currentTimeMillis();
        System.out.println("Time taken: " + (time2 - time1) + " ms with IO");
        destination.delete();
        return time2 - time1;

    }

    public static long withNio(File origin) throws Exception {
        File destination = new File(origin.getAbsolutePath() + ".nio" + UUID.randomUUID());
        long time1 = System.currentTimeMillis();
        FileInputStream is = new FileInputStream(origin);
        FileOutputStream fos = new FileOutputStream(destination);
        FileChannel f = is.getChannel();
        FileChannel f2 = fos.getChannel();
        ByteBuffer buf = ByteBuffer.allocateDirect(64 * 1024);
        long len = 0;
        while ((len = f.read(buf)) != -1) {
            buf.flip();
            f2.write(buf);
            buf.clear();
        }
        f2.close();
        f.close();
        long time2 = System.currentTimeMillis();
        System.out.println("Time taken: " + (time2 - time1) + " ms with NIO");
        destination.delete();
        return time2 - time1;
    }

}
```


Overlapping Code:
```
io {
public static void main(String[] args) throws Exception {
File file = new File("C:\\Users\\leoca\\AppData\\Local\\Temp\\io-vs-nio5577439411617059014.data");
createFile(25);
System.out.println(file.getAbsolutePath());
// withNio(file);
withIO(file);
// withNio(file);
}
public static File createFile(final long sizeInMB) {
File file = null;
try {
file = File.createTempFile("io-vs-nio", ".data");
file.createNewFile();
RandomAccessFile raf = new RandomAccessFile(file, "rw");
raf.setLength(sizeInMB * 100000000);
raf.close();
return file;
} catch (IOException e) {
e.printStackTrace();
}
return null;
}
public static long withIO(File origin) throws Exception {
File destination = new File(origin.getAbsolutePath() + ".io-" + UUID.randomUUID());
long time1 = System.currentTimeMillis();
InputStream is = new FileInputStream(origin);
FileOutputStream fos = new FileOutputStream(destination);
byte[] buf = new byte[64 * 1024];
int len = 0;
while ((len = is.read(buf)) != -1) {
fos.write(buf, 0, len);
}
fos.flush();
fos.close();
is.close();
long time2 = System.currentTimeMillis();
System.out.println("Time taken: " + (time2 - time1) + " ms with IO");
destination.delete();
return time2 - time1;
}
public static long withNio(File origin) throws Exception {
File destination = new File(origin.getAbsolutePath() + ".nio" + UUID.randomUUID());
long time1 = System.currentTimeMillis();
FileInputStream is = new FileInputStream(origin);
FileOutputStream fos = new FileOutputStream(destination);
FileChannel f = is.getChannel();
FileChannel f2 = fos.getChannel();
ByteBuffer buf = ByteBuffer.allocateDirect(64 * 1024);
long len = 0;
while ((len = f.read(buf)) != -1) {
buf.flip();
f2.write(buf);
buf.clear();
}
f2.close();
f.close();
long time2 = System.currentTimeMillis();
System.out.println("Time taken: " + (time2 - time1) + " ms with NIO");
destination.delete();
return time2 - t
```
<Overlap Ratio: 0.9858342077649528>

---

--- 192 --
Question ID: 5e30724853d8e221d7ed0a9cec203325c3bfe709
Original Code:
```
public class IdentitySets {

  private static class IdentitySingletonSet<E> extends AbstractSet<E> implements
      Serializable {

    private final E item;

    IdentitySingletonSet(E item) {
      this.item = item;
    }

    @Override
    public boolean contains(Object o) {
      return o == item;
    }

    @Override
    public Iterator<E> iterator() {
      return new SingletonIterator<E>(item);
    }

    @Override
    public int size() {
      return 1;
    }

    @Override
    public Object[] toArray() {
      return toArray(new Object[1]);
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T> T[] toArray(T[] a) {
      if (a.length < 1) {
        a = (T[]) Array.newInstance(a.getClass().getComponentType(), 1);
      }
      a[0] = (T) item;
      int i = 1;
      while (i < a.length) {
        a[i++] = null;
      }
      return a;
    }
  }
  private static final class SingletonIterator<T> implements Iterator<T> {

    /**
     * Sentinel value to mark that this iterator's single item was consumed.
     */
    private static final Object EMPTY = new Object();

    private T item;

    SingletonIterator(T item) {
      this.item = item;
    }

    @Override
    public boolean hasNext() {
      return item != EMPTY;
    }

    @Override
    @SuppressWarnings("unchecked")
    public T next() {
      if (!hasNext()) {
        throw new NoSuchElementException();
      }
      T toReturn = item;
      item = (T) EMPTY;
      return toReturn;
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  private static final Class<?> MULTI_SET_CLASS = IdentityHashSet.class;

  private static final Class<?> SINGLETON_SET_CLASS = IdentitySingletonSet.class;

  public static <T> Set<T> add(Set<T> set, T toAdd) {
    switch (set.size()) {
      case 0:
        // Empty -> Singleton
        return new IdentitySingletonSet<T>(toAdd);
      case 1: {
        if (set.contains(toAdd)) {
          return set;
        }
        // Singleton -> IdentityHashSet
        Set<T> result = new IdentityHashSet<T>();
        result.add(set.iterator().next());
        result.add(toAdd);
        return result;
      }
      default:
        // IdentityHashSet
        set.add(toAdd);
        return set;
    }
  }

  public static <T> Set<T> create() {
    return Collections.emptySet();
  }

  public static <T> Set<T> create(T item) {
    return new IdentitySingletonSet<T>(item);
  }

  public static <T> Set<T> normalize(Set<T> set) {
    switch (set.size()) {
      case 0:
        return create();
      case 1: {
        if (set.getClass() == SINGLETON_SET_CLASS) {
          return set;
        }
        return create(set.iterator().next());
      }
      default:
        if (set.getClass() == MULTI_SET_CLASS) {
          return set;
        }
        IdentityHashSet<T> result = new IdentityHashSet<T>();
        result.addAll(set);
        return result;
    }
  }

  public static <T> Set<T> remove(Set<T> set, T toRemove) {
    switch (set.size()) {
      case 0:
        // Empty
        return set;
      case 1:
        // Singleton -> Empty
        if (set.contains(toRemove)) {
          return create();
        }
        return set;
      case 2:
        // IdentityHashSet -> Singleton
        if (set.remove(toRemove)) {
          return create(set.iterator().next());
        }
        return set;
      default:
        // IdentityHashSet
        set.remove(toRemove);
        return set;
    }
  }
}
```


Overlapping Code:
```
ate static class IdentitySingletonSet<E> extends AbstractSet<E> implements
Serializable {
private final E item;
IdentitySingletonSet(E item) {
this.item = item;
}
@Override
public boolean contains(Object o) {
return o == item;
}
@Override
public Iterator<E> iterator() {
return new SingletonIterator<E>(item);
}
@Override
public int size() {
return 1;
}
@Override
public Object[] toArray() {
return toArray(new Object[1]);
}
@SuppressWarnings("unchecked")
@Override
public <T> T[] toArray(T[] a) {
if (a.length < 1) {
a = (T[]) Array.newInstance(a.getClass().getComponentType(), 1);
}
a[0] = (T) item;
int i = 1;
while (i < a.length) {
a[i++] = null;
}
return a;
}
}
private static final class SingletonIterator<T> implements Iterator<T> {
/**
* Sentinel value to mark that this iterator's single item was consumed.
*/
private static final Object EMPTY = new Object();
private T item;
SingletonIterator(T item) {
this.item = item;
}
@Override
public boolean hasNext() {
return item != EMPTY;
}
@Override
@SuppressWarnings("unchecked")
public T next() {
if (!hasNext()) {
throw new NoSuchElementException();
}
T toReturn = item;
item = (T) EMPTY;
return toReturn;
}
@Override
public void remove() {
throw new UnsupportedOperationException();
}
}
private static final Class<?> MULTI_SET_CLASS = IdentityHashSet.class;
private static final Class<?> SINGLETON_SET_CLASS = IdentitySingletonSet.class;
public static <T> Set<T> add(Set<T> set, T toAdd) {
switch (set.size()) {
case 0:
// Empty -> Singleton
return new IdentitySingletonSet<T>(toAdd);
case 1: {
if (set.contains(toAdd)) {
return set;
}
// Singleton -> IdentityHashSet
Set<T> result = new IdentityHashSet<T>();
result.add(set.iterator().next());
result.add(toAdd);
return result;
}
default:
// IdentityHashSet
set.add(toAdd);
return set;
}
}
public static <T> Set<T> create() {
return Collections.emptySet();
}
public static <T> Set<T> create(T item) {
return new IdentitySingletonSet<T>(item)
```
<Overlap Ratio: 0.9701492537313433>

---

--- 193 --
Question ID: f09a60ebc232f22fa0de186d6a0b896d022a02e5
Original Code:
```
@SuppressWarnings("rawtypes")
public final class Repository extends AbstractGitHubType<Map> implements Comparable<Repository> {

    private volatile String fullName;

    private volatile String name;

    private volatile Permissions permissions;

    /**
     * Creates a new pre-initalized instance
     * 
     * @param fullName The full name of the repository
     * @param name The name of the repository
     * @param permissions The user's permissions in this repository
     */
    public Repository(String fullName, String name, Permissions permissions) {
        super(null, null);
        this.fullName = fullName;
        this.name = name;
        this.permissions = permissions;
    }

    Repository(Map raw) {
        super(getString("url", raw), Map.class);
        initialize(raw);
    }

    @Override
    void initialize(Map raw) {
        this.fullName = getString("full_name", raw);
        this.name = getString("name", raw);
        this.permissions = new Permissions(getMap("permissions", raw));
    }

    /**
     * Returns the full name of the repository
     * 
     * @return the fill name of the repository
     */
    public String getFullName() {
        return this.fullName;
    }

    /**
     * Returns the name of the repository
     * 
     * @return the name of the repository
     */
    public String getName() {
        return this.name;
    }

    /**
     * Returns the user's permissions in this repository
     * 
     * @return the user's permissions in this repository
     */
    public Permissions getPermissions() {
        return this.permissions;
    }

    @Override
    public int compareTo(Repository o) {
        return this.fullName.compareToIgnoreCase(o.getFullName());
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result) + this.fullName.toLowerCase().hashCode();
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof Repository)) {
            return false;
        }
        Repository other = (Repository) obj;
        if (!this.fullName.equalsIgnoreCase(other.getFullName())) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "Repository [fullName=" + this.fullName + ", name=" + this.name + ", permissions=" + this.permissions + "]";
    }

}
```


Overlapping Code:
```
@SuppressWarnings("rawtypes")
public final class Repository extends AbstractGitHubType<Map> implements Comparable<Repository> {
private volatile String fullName;
private volatile String name;
private volatile Permissions permissions;
/**
* Creates a new pre-initalized instance
* 
* @param fullName The full name of the repository
* @param name The name of the repository
* @param permissions The user's permissions in this repository
*/
public Repository(String fullName, String name, Permissions permissions) {
super(null, null);
this.fullName = fullName;
this.name = name;
this.permissions = permissions;
}
Repository(Map raw) {
super(getString("url", raw), Map.class);
initialize(raw);
}
@Override
void initialize(Map raw) {
this.fullName = getString("full_name", raw);
this.name = getString("name", raw);
this.permissions = new Permissions(getMap("permissions", raw));
}
/**
* Returns the full name of the repository
* 
* @return the fill name of the repository
*/
public String getFullName() {
return this.fullName;
}
/**
* Returns the name of the repository
* 
* @return the name of the repository
*/
public String getName() {
return this.name;
}
/**
* Returns the user's permissions in this repository
* 
* @return the user's permissions in this repository
*/
public Permissions getPermissions() {
return this.permissions;
}
@Override
public int compareTo(Repository o) {
return this.fullName.compareToIgnoreCase(o.getFullName());
}
@Override
public int hashCode() {
final int prime = 31;
int result = 1;
result = (prime * result) + this.fullName.toLowerCase().hashCode();
return result;
}
@Override
public boolean equals(Object obj) {
if (this == obj) {
return true;
}
if (obj == null) {
return false;
}
if (!(obj instanceof Repository)) {
return false;
}
Repository other = (Repository) obj;
if (!this.fullName.equalsIgnoreCase(other.getFullName())) {
return false;
}
return true;
}
@Override
public String toString() {
return "Repository [fullName=" + this.
```
<Overlap Ratio: 0.984>

---

--- 194 --
Question ID: c908faee48de2a277a57e3204bd8cf65bfee01be
Original Code:
```
public class YangJavaTypeDefTranslator
        extends YangJavaTypeDef
        implements JavaCodeGeneratorInfo, JavaCodeGenerator {

    private static final long serialVersionUID = 806201620L;

    /**
     * File handle to maintain temporary java code fragments as per the code
     * snippet types.
     */
    private transient TempJavaCodeFragmentFiles tempFileHandle;

    /**
     * Creates a YANG java typedef object.
     */
    public YangJavaTypeDefTranslator() {
        super();
        setJavaFileInfo(new JavaFileInfoTranslator());
        getJavaFileInfo().setGeneratedFileTypes(GENERATE_TYPEDEF_CLASS);
    }

    /**
     * Returns the generated java file information.
     *
     * @return generated java file information
     */
    @Override
    public JavaFileInfoTranslator getJavaFileInfo() {

        if (javaFileInfo == null) {
            throw new TranslatorException("Missing java info in java datamodel node " +
                                                  getName() + " in " +
                                                  getLineNumber() + " at " +
                                                  getCharPosition()
                                                  + " in " + getFileName());
        }
        return (JavaFileInfoTranslator) javaFileInfo;
    }

    /**
     * Sets the java file info object.
     *
     * @param javaInfo java file info object
     */
    @Override
    public void setJavaFileInfo(JavaFileInfoTranslator javaInfo) {
        javaFileInfo = javaInfo;
    }

    /**
     * Returns the temporary file handle.
     *
     * @return temporary file handle
     */
    @Override
    public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
        return tempFileHandle;
    }

    /**
     * Sets temporary file handle.
     *
     * @param fileHandle temporary file handle
     */
    @Override
    public void setTempJavaCodeFragmentFiles(TempJavaCodeFragmentFiles fileHandle) {
        tempFileHandle = fileHandle;
    }

    /**
     * Prepare the information for java code generation corresponding to YANG
     * typedef info.
     *
     * @param yangPlugin YANG plugin config
     * @throws TranslatorException when fails to translate
     */
    @Override
    public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
        if (getReferredSchema() != null) {
            throw new InvalidNodeForTranslatorException();
        }
        // TODO update the below exception in all related places, remove file
        // name and other information.
        YangType typeInTypeDef = this.getTypeDefBaseType();
        InvalidNodeForTranslatorException exception = new InvalidNodeForTranslatorException();
        exception.setFileName(this.getFileName());
        exception.setCharPosition(this.getCharPosition());
        exception.setLine(this.getLineNumber());
        if (typeInTypeDef.getDataType() == DERIVED) {
            YangDerivedInfo derivedInfo = (YangDerivedInfo) typeInTypeDef.getDataTypeExtendedInfo();
            if (derivedInfo.getEffectiveBuiltInType() == LEAFREF) {
                throw exception;
            }
        } else if (typeInTypeDef.getDataType() == LEAFREF) {
            throw exception;
        }
        updateJNCPackageInfo(this,yangPlugin);

        if(typeInTypeDef.getDataType() == DERIVED){

            this.getTypeList().forEach(yangType -> {
                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());
            });
        }
        if(typeInTypeDef.getDataType() == BITS){

            this.getTypeList().forEach(yangType -> {
                ((YangJavaTypeTranslator)yangType).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());
            });
        }
        ((YangJavaTypeTranslator)typeInTypeDef).updateJavaQualifiedInfo(yangPlugin.getConflictResolver());

//        try {
//            generateCodeOfNode(this, yangPlugin);
//        } catch (IOException e) {
//            throw new TranslatorException(
//                    "Failed to prepare generate code entry for typedef node " + getName()
//                            + " in " + getLineNumber() +
//                            " at " + getCharPosition() +
//                            " in " + getFileName(), e);
//        }
    }

    /**
     * Create a java file using the YANG typedef info.
     *
     * @throws TranslatorException when fails to translate
     */
    @Override
    public void generateCodeExit() throws TranslatorException {
        String classname= YangElement.normalize(this.getName());
        JavaFileInfoTranslator fileInfo = this.getJavaFileInfo();
        JavaClass javaClass = new JavaClass(classname, fileInfo.getPackage(),
                "Code generated by "+this.getClass().getSimpleName() +
                        "\n * <p>"+
                        "\n * See line "+fileInfo.getLineNumber()+" in" +
                        "\n * "+fileInfo.getYangFileName()+
                        "\n * "+
                        "\n * @author Auto Generated");
        String absoluteDirPath = getAbsolutePackagePath(fileInfo.getBaseCodeGenPath(),
                fileInfo.getPackageFilePath());
//        YangJavaModule yangJavaModule = (YangJavaModule)this.getYangJavaModule();

        YangType typeInTypeDef = this.getTypeDefBaseType();


        if(typeInTypeDef.getDataType() == ENUMERATION){
            javaClass.setExtend(YangEnumeration.class.getName());

            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value,").addLine("\tnew String[] {")
                    .addLine(((YangJavaEnumeration)this.getTypeList().get(0).getDataTypeExtendedInfo()).getEnumSet().stream().map(yangEnum ->"\t\t\""+ yangEnum.getNamedValue()+"\"").collect(Collectors.joining(",\n\t\t")))
                    .addLine("\t}").addLine(");").addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("\tsuper.setValue(value);")
                    .addLine("\tcheck();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("\tsuper.check();")
            );
        }else if(typeInTypeDef.getDataType() == UINT8||typeInTypeDef.getDataType() == UINT16||typeInTypeDef.getDataType() == UINT32 ||typeInTypeDef.getDataType() == UINT64
                ||typeInTypeDef.getDataType() == INT16||typeInTypeDef.getDataType() == INT32||typeInTypeDef.getDataType() == INT64){
            String extend=null;
            String type =null;
            switch (typeInTypeDef.getDataType()){
                case UINT8:
                    extend= YangUInt8.class.getName();
                    type ="short";
                    break;
                case INT16:
                    extend= YangInt16.class.getName();
                    type ="short";
                    break;
                case UINT16:
                    extend= YangUInt16.class.getName();
                    type ="int";
                    break;
                case INT32:
                    extend= YangInt32.class.getName();
                    type ="int";
                    break;
                case UINT32:
                    extend= YangUInt32.class.getName();
                    type ="long";
                    break;
                case INT64:
                    extend= YangInt64.class.getName();
                    type ="long";
                    break;
                case UINT64:
                    extend= YangUInt64.class.getName();
                    type =BigInteger.class.getName();
                    break;
            }
            javaClass.setExtend(extend);
            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter(type,"value")
                    .addLine("super(value);")
                    .addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter(type,"value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("super.check();")
            );
        }else if(typeInTypeDef.getDataType() == UNION){
            javaClass.setExtend(YangUnion.class.getName());

            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value,").addLine("\tnew String[] {")

                    .addLine(
                            ((YangJavaUnion)((YangJavaType)this.getTypeList().get(0)).getDataTypeExtendedInfo()).getTypeList().stream()
                                    .map( yangType -> "\""+((YangJavaType)yangType).getJavaQualifiedInfo().getPkgInfo()+"."+ ((YangJavaType)yangType).getJavaQualifiedInfo().getClassInfo()+"\"").collect(Collectors.joining(","))
                    )
                    .addLine("}").addLine(");").addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("super.check();")
            );
        }else if(typeInTypeDef.getDataType() == STRING ||typeInTypeDef.getDataType()==BINARY){

            String extend=null;
            switch (typeInTypeDef.getDataType()){
                case STRING:
                    extend= YangString.class.getName();
                    break;
                case BINARY:
                    extend=YangBinary.class.getName();
                    break;
            }
            javaClass.setExtend(extend);

            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value);").addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("super.check();")
            );
        }else if(typeInTypeDef.getDataType() == DERIVED){
            JavaQualifiedTypeInfo javaQualifiedInfo = ((YangJavaTypeTranslator) this.getTypeList().get(0)).getJavaQualifiedInfo();
            javaClass.setExtend(javaQualifiedInfo.getPkgInfo()+"."+javaQualifiedInfo.getClassInfo());
            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value);").addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("super.check();")
            );
        }else if(typeInTypeDef.getDataType() == BITS){
            javaClass.setExtend(YangBits.class.getName());
            Set<Map.Entry<Integer, YangBit>> entries = ((com.airlenet.yang.compiler.datamodel.YangBits) typeInTypeDef.getDataTypeExtendedInfo()).getBitPositionMap().entrySet();





            javaClass.addMethod(new JavaMethod(classname,"")
                    .setModifiers("public")
                    .setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super(value,")
                    .addLine("\tnew java.math.BigInteger(\""+ entries.stream().map(entry->entry.getKey().intValue()).collect(Collectors.summarizingInt( position-> 1<<position)).getSum()+"\"),")
                    .addLine("\tnew String[] {"+entries.stream().map(entry->"\""+entry.getValue().getBitName()+"\"").collect(Collectors.joining(","))+" },")
                    .addLine("\tnew int[] {"+entries.stream().map(entry->entry.getKey().intValue()+"").collect(Collectors.joining(","))+" }")
                    .addLine(");")
                    .addLine("check();")
            );

            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter("String","value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("setValue","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addParameter(BigInteger.class.getName(),"value")
                    .addLine("super.setValue(value);")
                    .addLine("check();")
            );
            javaClass.addMethod(new JavaMethod("check","void").setModifiers("public").setExceptions(YangException.class.getName())
                    .addLine("super.check();")
            );
        }

        try {
            javaClass.write(absoluteDirPath);
        } catch (IOException e) {
            throw new TranslatorException(e);
        }
//        try {
//            generateJava(GENERATE_TYPEDEF_CLASS, this);
//        } catch (IOException e) {
//            throw new TranslatorException(
//                    "Failed to prepare generate code for typedef node " + getName()
//                            + " in " + getLineNumber() +
//                            " at " + getCharPosition() +
//                            " in " + getFileName(), e);
//        }
    }
}
```


Overlapping Code:
```
anslator
extends YangJavaTypeDef
implements JavaCodeGeneratorInfo, JavaCodeGenerator {
private static final long serialVersionUID = 806201620L;
/**
* File handle to maintain temporary java code fragments as per the code
* snippet types.
*/
private transient TempJavaCodeFragmentFiles tempFileHandle;
/**
* Creates a YANG java typedef object.
*/
public YangJavaTypeDefTranslator() {
super();
setJavaFileInfo(new JavaFileInfoTranslator());
getJavaFileInfo().setGeneratedFileTypes(GENERATE_TYPEDEF_CLASS);
}
/**
* Returns the generated java file information.
*
* @return generated java file information
*/
@Override
public JavaFileInfoTranslator getJavaFileInfo() {
if (javaFileInfo == null) {
throw new TranslatorException("Missing java info in java datamodel node " +
getName() + " in " +
getLineNumber() + " at " +
getCharPosition()
+ " in " + getFileName());
}
return (JavaFileInfoTranslator) javaFileInfo;
}
/**
* Sets the java file info object.
*
* @param javaInfo java file info object
*/
@Override
public void setJavaFileInfo(JavaFileInfoTranslator javaInfo) {
javaFileInfo = javaInfo;
}
/**
* Returns the temporary file handle.
*
* @return temporary file handle
*/
@Override
public TempJavaCodeFragmentFiles getTempJavaCodeFragmentFiles() {
return tempFileHandle;
}
/**
* Sets temporary file handle.
*
* @param fileHandle temporary file handle
*/
@Override
public void setTempJavaCodeFragmentFiles(TempJavaCodeFragmentFiles fileHandle) {
tempFileHandle = fileHandle;
}
/**
* Prepare the information for java code generation corresponding to YANG
* typedef info.
*
* @param yangPlugin YANG plugin config
* @throws TranslatorException when fails to translate
*/
@Override
public void generateCodeEntry(YangPluginConfig yangPlugin) throws TranslatorException {
if (getReferredSchema() != null) {
throw new InvalidNodeForTranslatorException();
}
//
```
<Overlap Ratio: 0.9640437727983324>

---

--- 195 --
Question ID: a44bb119eff1f8cc82761a192d68f83d520aa509
Original Code:
```
public class TLFileLocationToBeDeprecated extends TLObject {
    public static final int CONSTRUCTOR_ID = 0xbc7fc6cd;

    protected long volumeId;

    protected int localId;

    private final String _constructor = "fileLocationToBeDeprecated#bc7fc6cd";

    public TLFileLocationToBeDeprecated() {
    }

    public TLFileLocationToBeDeprecated(long volumeId, int localId) {
        this.volumeId = volumeId;
        this.localId = localId;
    }

    @Override
    public void serializeBody(OutputStream stream) throws IOException {
        writeLong(volumeId, stream);
        writeInt(localId, stream);
    }

    @Override
    @SuppressWarnings({"unchecked", "SimplifiableConditionalExpression"})
    public void deserializeBody(InputStream stream, TLContext context) throws IOException {
        volumeId = readLong(stream);
        localId = readInt(stream);
    }

    @Override
    public int computeSerializedSize() {
        int size = SIZE_CONSTRUCTOR_ID;
        size += SIZE_INT64;
        size += SIZE_INT32;
        return size;
    }

    @Override
    public String toString() {
        return _constructor;
    }

    @Override
    public int getConstructorId() {
        return CONSTRUCTOR_ID;
    }

    public long getVolumeId() {
        return volumeId;
    }

    public void setVolumeId(long volumeId) {
        this.volumeId = volumeId;
    }

    public int getLocalId() {
        return localId;
    }

    public void setLocalId(int localId) {
        this.localId = localId;
    }
}
```


Overlapping Code:
```
TLFileLocationToBeDeprecated extends TLObject {
public static final int CONSTRUCTOR_ID = 0xbc7fc6cd;
protected long volumeId;
protected int localId;
private final String _constructor = "fileLocationToBeDeprecated#bc7fc6cd";
public TLFileLocationToBeDeprecated() {
}
public TLFileLocationToBeDeprecated(long volumeId, int localId) {
this.volumeId = volumeId;
this.localId = localId;
}
@Override
public void serializeBody(OutputStream stream) throws IOException {
writeLong(volumeId, stream);
writeInt(localId, stream);
}
@Override
@SuppressWarnings({"unchecked", "SimplifiableConditionalExpression"})
public void deserializeBody(InputStream stream, TLContext context) throws IOException {
volumeId = readLong(stream);
localId = readInt(stream);
}
@Override
public int computeSerializedSize() {
int size = SIZE_CONSTRUCTOR_ID;
size += SIZE_INT64;
size += SIZE_INT32;
return size;
}
@Override
public String toString() {
return _constructor;
}
@Override
public int getConstructorId() {
return CONSTRUCTOR_ID;
}
public long getVolumeId() {
return volumeId;
}
public void setVolumeId(long volumeId) {
this.volumeId = volumeId;
}
public int getLocalId() {
return localId;
}
public void setLocalId(int localId) {
this.localId = localId;

```
<Overlap Ratio: 0.98714859437751>

---

--- 196 --
Question ID: c4567262a5c9119a559a4d268436eb9ffc088e2d
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class SynchronizeClockProcessorTest {

    private static final String TEST_ID = "testOperationId";
    private static final String TEST_DEVICE_ID = "testDevice";
    private static final String[] TEST_PATH = new String[] {"path", "to", "device"};
    private static final String TEST_SOURCE = "testSource";
    private static final ParameterSetOrConfigureOperation TEST_PARAMETER =
            new ParameterSetOrConfigureOperation(Collections.singletonList(new ValueSetting("source", "sync")));
    private static final RequestSetOrConfigureOperation TEST_REQUEST =
            new RequestSetOrConfigureOperation(TEST_PARAMETER);
    private static final String TEST_RESULT_DESCRIPTION = "result description";
    private static final Result TEST_RESULT = new Result(ResultCode.SUCCESSFUL, TEST_RESULT_DESCRIPTION);


    @Mock
    private OperationSynchronizeClock mockedSynchronizeClock;
    @InjectMocks
    private SynchronizeClockProcessor testProcessor;


    @Test
    public void testParseParameters() {
        String source = testProcessor.parseParameters(TEST_REQUEST);

        assertEquals("sync", source);
    }

    @Test(expected = IllegalArgumentException.class)
    public void testParseParametersNullParams() {
        RequestSetOrConfigureOperation nullParamsRequest = new RequestSetOrConfigureOperation(null);

        assertNull(testProcessor.parseParameters(nullParamsRequest));
    }

    @Test
    public void testParseParametersEmptyParams() {
        RequestSetOrConfigureOperation emptyParamsRequest = new RequestSetOrConfigureOperation(new ParameterSetOrConfigureOperation(null));

        assertNull(testProcessor.parseParameters(emptyParamsRequest));
    }

    @Test
    public void testProcessOperation() {
        testProcessor.processOperation(TEST_DEVICE_ID, TEST_SOURCE);

        verify(mockedSynchronizeClock).synchronizeClock(eq(TEST_DEVICE_ID), eq(TEST_SOURCE));
    }

    @Test
    public void testTranslateToOutput() {
        Output output = testProcessor.translateToOutput(TEST_RESULT, TEST_ID, TEST_DEVICE_ID, TEST_PATH);

        assertEquals(OPENGATE_VERSION, output.getVersion());
        OutputOperation outputOperation = output.getOperation();
        Response response = outputOperation.getResponse();
        assertEquals(TEST_ID, response.getId());
        assertEquals(TEST_DEVICE_ID, response.getDeviceId());
        assertArrayEquals(TEST_PATH, response.getPath());
        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());
        assertEquals(OperationResultCode.SUCCESSFUL, response.getResultCode());
        assertEquals(TEST_RESULT_DESCRIPTION, response.getResultDescription());
        List<Step> steps = response.getSteps();
        assertNotNull(steps);
        assertEquals(1, steps.size());
        Step step = steps.get(0);
        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());
        assertEquals(StepResultCode.SUCCESSFUL, step.getResult());
        assertEquals(TEST_RESULT_DESCRIPTION, step.getDescription());
    }

    @Test
    public void testTranslateToOutputResultWithError() {
        String errorDescription = "Error description";
        Result errorResult = new Result(ResultCode.ERROR_PROCESSING, errorDescription);

        Output output = testProcessor.translateToOutput(errorResult, TEST_ID, TEST_DEVICE_ID, TEST_PATH);

        assertEquals(OPENGATE_VERSION, output.getVersion());
        OutputOperation outputOperation = output.getOperation();
        Response response = outputOperation.getResponse();
        assertEquals(TEST_ID, response.getId());
        assertEquals(TEST_DEVICE_ID, response.getDeviceId());
        assertArrayEquals(TEST_PATH, response.getPath());
        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, response.getName());
        assertEquals(OperationResultCode.ERROR_PROCESSING, response.getResultCode());
        assertEquals(errorDescription, response.getResultDescription());
        List<Step> steps = response.getSteps();
        assertNotNull(steps);
        assertEquals(1, steps.size());
        Step step = steps.get(0);
        assertEquals(SYNCHRONIZE_CLOCK_OPERATION_NAME, step.getName());
        assertEquals(StepResultCode.ERROR, step.getResult());
        assertEquals(errorDescription, step.getDescription());
    }
}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class SynchronizeClockProcessorTest {
private static final String TEST_ID = "testOperationId";
private static final String TEST_DEVICE_ID = "testDevice";
private static final String[] TEST_PATH = new String[] {"path", "to", "device"};
private static final String TEST_SOURCE = "testSource";
private static final ParameterSetOrConfigureOperation TEST_PARAMETER =
new ParameterSetOrConfigureOperation(Collections.singletonList(new ValueSetting("source", "sync")));
private static final RequestSetOrConfigureOperation TEST_REQUEST =
new RequestSetOrConfigureOperation(TEST_PARAMETER);
private static final String TEST_RESULT_DESCRIPTION = "result description";
private static final Result TEST_RESULT = new Result(ResultCode.SUCCESSFUL, TEST_RESULT_DESCRIPTION);
@Mock
private OperationSynchronizeClock mockedSynchronizeClock;
@InjectMocks
private SynchronizeClockProcessor testProcessor;
@Test
public void testParseParameters() {
String source = testProcessor.parseParameters(TEST_REQUEST);
assertEquals("sync", source);
}
@Test(expected = IllegalArgumentException.class)
public void testParseParametersNullParams() {
RequestSetOrConfigureOperation nullParamsRequest = new RequestSetOrConfigureOperation(null);
assertNull(testProcessor.parseParameters(nullParamsRequest));
}
@Test
public void testParseParametersEmptyParams() {
RequestSetOrConfigureOperation emptyParamsRequest = new RequestSetOrConfigureOperation(new ParameterSetOrConfigureOperation(null));
assertNull(testProcessor.parseParameters(emptyParamsRequest));
}
@Test
public void testProcessOperation() {
testProcessor.processOperation(TEST_DEVICE_ID, TEST_SOURCE);
verify(mockedSynchronizeClock).synchronizeClock(eq(TEST_DEVICE_ID), eq(TEST_SOURCE));
}
@Test
public void testTranslateToOutput() {
Output output = testProcessor.translateToOutput(TEST_RESULT, TEST_ID, TEST_DEVICE_ID, TEST_PATH);
assertEquals(OPENGATE_VERSION, output.getVersion());
OutputOperation outputOperation = output.getOperation();
Response response = outputOperation.getResponse();
assertEquals(TEST_ID, response.getId());
assertEquals(TEST_DEVICE_ID, response.getDeviceId());
assertArrayEquals(TEST_PATH, response.getPath());
assertEquals(SYNCHRONIZE
```
<Overlap Ratio: 1.0>

---

--- 197 --
Question ID: 7689c960ebf8aa8b481ebe906ceddf32bae6a0a0
Original Code:
```
public class DataSetProvider extends ResourceProvider<DataSetResourceDescriptor> {

    private final DBUnitConfiguration configuration;

    public DataSetProvider(MetadataExtractor metadataExtractor, DBUnitConfiguration configuration) {
        super(UsingDataSet.class, metadataExtractor);
        this.configuration = configuration;
    }

    @Override
    protected DataSetResourceDescriptor createDescriptor(String resource) {
        return new DataSetResourceDescriptor(determineLocation(resource), inferFormat(resource));
    }

    @Override
    protected String defaultLocation() {
        return configuration.getDefaultDataSetLocation();
    }

    @Override
    protected String defaultFileName() {
        Format format = configuration.getDefaultDataSetFormat();
        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());
    }

    @Override
    public Collection<String> getResourceFileNames(Method testMethod) {
        UsingDataSet dataAnnotation = getResourceAnnotation(testMethod);
        String[] specifiedFileNames = dataAnnotation.value();
        if (specifiedFileNames.length == 0 || "".equals(specifiedFileNames[0].trim())) {
            return singletonList(getDefaultFileName(testMethod));
        }
        return asList(specifiedFileNames);
    }

    // Private methods

    private Format inferFormat(String dataFileName) {
        Format format = Format.inferFromFile(dataFileName);
        if (Format.UNSUPPORTED.equals(format)) {
            throw new UnsupportedDataFormatException("File " + dataFileName + " is not supported as data set format.");
        }
        return format;
    }

    Collection<Format> getDataFormats(Method testMethod) {
        final List<Format> formats = new ArrayList<Format>();
        for (String dataFileName : getResourceFileNames(testMethod)) {
            formats.add(inferFormat(dataFileName));
        }
        return formats;
    }

    private UsingDataSet getResourceAnnotation(Method testMethod) {
        return metadataExtractor.usingDataSet().fetchUsingFirst(testMethod);
    }

    private String getDefaultFileName(Method testMethod) {
        Format format = configuration.getDefaultDataSetFormat();

        if (metadataExtractor.usingDataSet().isDefinedOn(testMethod)) {
            return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass(), testMethod);
        }

        return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());
    }
}
```


Overlapping Code:
```
ceProvider<DataSetResourceDescriptor> {
private final DBUnitConfiguration configuration;
public DataSetProvider(MetadataExtractor metadataExtractor, DBUnitConfiguration configuration) {
super(UsingDataSet.class, metadataExtractor);
this.configuration = configuration;
}
@Override
protected DataSetResourceDescriptor createDescriptor(String resource) {
return new DataSetResourceDescriptor(determineLocation(resource), inferFormat(resource));
}
@Override
protected String defaultLocation() {
return configuration.getDefaultDataSetLocation();
}
@Override
protected String defaultFileName() {
Format format = configuration.getDefaultDataSetFormat();
return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass());
}
@Override
public Collection<String> getResourceFileNames(Method testMethod) {
UsingDataSet dataAnnotation = getResourceAnnotation(testMethod);
String[] specifiedFileNames = dataAnnotation.value();
if (specifiedFileNames.length == 0 || "".equals(specifiedFileNames[0].trim())) {
return singletonList(getDefaultFileName(testMethod));
}
return asList(specifiedFileNames);
}
// Private methods
private Format inferFormat(String dataFileName) {
Format format = Format.inferFromFile(dataFileName);
if (Format.UNSUPPORTED.equals(format)) {
throw new UnsupportedDataFormatException("File " + dataFileName + " is not supported as data set format.");
}
return format;
}
Collection<Format> getDataFormats(Method testMethod) {
final List<Format> formats = new ArrayList<Format>();
for (String dataFileName : getResourceFileNames(testMethod)) {
formats.add(inferFormat(dataFileName));
}
return formats;
}
private UsingDataSet getResourceAnnotation(Method testMethod) {
return metadataExtractor.usingDataSet().fetchUsingFirst(testMethod);
}
private String getDefaultFileName(Method testMethod) {
Format format = configuration.getDefaultDataSetFormat();
if (metadataExtractor.usingDataSet().isDefinedOn(testMethod)) {
return new DataSetFileNamingStrategy(format).createFileName(metadataExtractor.getJavaClass(), testMethod);
}
return new DataSetFileNamingStrategy(format).createFi
```
<Overlap Ratio: 0.979108635097493>

---

--- 198 --
Question ID: 65bf28103b1aa0b286f52418bbf009864303ce59
Original Code:
```
public class APDUTransceiveSuccessfulResponseTest {

    @Test
    public void testFromPayload() throws Exception {
        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};
        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
        transceiveApduCommand.parsePayload(apdu);
        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);
    }

    @Test
    public void testGetPayload() throws Exception {
        byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};
        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse(apdu);
        assertArrayEquals(transceiveApduCommand.getPayload(),apdu);
    }

    @Test
    public void testGetCommandCode() throws Exception {
        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
        assertEquals(transceiveApduCommand.getCommandCode(),(byte)0x02);
    }

    @Test
    public void testGetCommandFamily() throws Exception {
        APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
        assertArrayEquals(transceiveApduCommand.getCommandFamily(),new byte[]{0x00,0x04});
    }
}
```


Overlapping Code:
```
TransceiveSuccessfulResponseTest {
@Test
public void testFromPayload() throws Exception {
byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};
APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
transceiveApduCommand.parsePayload(apdu);
assertArrayEquals(transceiveApduCommand.getPayload(),apdu);
}
@Test
public void testGetPayload() throws Exception {
byte[] apdu = new byte[]{(byte) 0x00,(byte) 0x03,(byte) 0x53,(byte) 0xFE, (byte) 0xA5};
APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse(apdu);
assertArrayEquals(transceiveApduCommand.getPayload(),apdu);
}
@Test
public void testGetCommandCode() throws Exception {
APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
assertEquals(transceiveApduCommand.getCommandCode(),(byte)0x02);
}
@Test
public void testGetCommandFamily() throws Exception {
APDUTransceiveSuccessfulResponse transceiveApduCommand = new APDUTransceiveSuccessfulResponse();
assertArrayEquals(transceiveApduCommand.getComma
```
<Overlap Ratio: 0.9528301886792453>

---

--- 199 --
Question ID: 154c084c6e0d73897090274c46aa00b04a182ef3
Original Code:
```
public class ScaleInTransformer implements ViewPager2.PageTransformer {

    private float mMinScale = 0.85f;
    private float DEFAULT_CENTER = 0.5f;

    @Override
    public void transformPage(@NonNull View page, float position) {
        page.setElevation(-Math.abs(position));
        int pageWidth = page.getWidth();
        int pageHeight = page.getHeight();

        page.setPivotX(pageWidth / 2);
        page.setPivotY(pageHeight / 2);

        if (position < -1) {
            page.setScaleX(mMinScale);
            page.setScaleY(mMinScale);
            page.setPivotX(pageWidth);
        } else if (position <= -1) {
            if (position < 0) {
                float scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale;
                page.setScaleX(scaleFactor);
                page.setScaleY(scaleFactor);
                page.setPivotX(pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position));
            } else {
                float scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale;
                page.setScaleX(scaleFactor);
                page.setScaleY(scaleFactor);
                page.setPivotX(pageWidth * ((1 - position) * DEFAULT_CENTER));
            }
        }else {
            page.setPivotX(0f);
            page.setScaleX(mMinScale);
            page.setScaleY(mMinScale);
        }
    }
}
```


Overlapping Code:
```
Transformer implements ViewPager2.PageTransformer {
private float mMinScale = 0.85f;
private float DEFAULT_CENTER = 0.5f;
@Override
public void transformPage(@NonNull View page, float position) {
page.setElevation(-Math.abs(position));
int pageWidth = page.getWidth();
int pageHeight = page.getHeight();
page.setPivotX(pageWidth / 2);
page.setPivotY(pageHeight / 2);
if (position < -1) {
page.setScaleX(mMinScale);
page.setScaleY(mMinScale);
page.setPivotX(pageWidth);
} else if (position <= -1) {
if (position < 0) {
float scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale;
page.setScaleX(scaleFactor);
page.setScaleY(scaleFactor);
page.setPivotX(pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position));
} else {
float scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale;
page.setScaleX(scaleFactor);
page.setScaleY(scaleFactor);
page.setPivotX(pageWidth * ((1 - position) * DEFAULT_CENTER));
}
}else {
page.setPivotX(0f);
page.setScaleX(mMinScale);
page.setScaleY(mMinScale
```
<Overlap Ratio: 0.9726027397260274>

---

--- 200 --
Question ID: f14c094307df3bd2ab751f9ce70f0640341c5aa2
Original Code:
```
public class p225g23 {

	public static void main(String[] args) 
	{
		String str="application",str1="";
		char ch,ch1,ch2=' ';
		int i,j,len;
		len=str.length();
		for(i=0;i<len;i++)
		{
			ch=str.charAt(i);
			for(j=i+1;j<len;j++)
			{
				ch1=str.charAt(j);
				if(ch==ch1)
					continue;
				else
					str1=str1+ch1;
			}			
		}
		System.out.println(str1);//incomplete,,,,,,,,,
	}

}
```


Overlapping Code:
```
23 {
public static void main(String[] args) 
{
String str="application",str1="";
char ch,ch1,ch2=' ';
int i,j,len;
len=str.length();
for(i=0;i<len;i++)
{
ch=str.charAt(i);
for(j=i+1;j<len;j++)
{
ch1=str.charAt(j);
if(ch==ch1)
continue;
else
str1=str1+ch1;
} 
}
System.out.println(str1);//incomplete,,
```
<Overlap Ratio: 0.9118541033434651>

---

--- 201 --
Question ID: 91a6523a97a6c7f1206ef5d42f67e1db2c1f953b
Original Code:
```
@BeanDefinition(builderScope = "private", metaScope = "private", factoryName = "of")
final class ApiKeyCredentials implements Credentials, ImmutableBean {
  // this class is intended to stay package-scoped
  // users are not exposed to the data, to reduce attempts to query the data held within

  /**
   * The API Key ID with which to authenticate
   */
  @PropertyDefinition(validate = "notBlank", get = "")
  private final String apiKey;

  /**
   * The secret corresponding to the id with which to authenticate
   */
  @PropertyDefinition(validate = "notBlank", get = "")
  private final String secret;

  //-------------------------------------------------------------------------
  @Override
  public AccessTokenResult authenticate(AuthClient client) {
    return client.authenticateApiKey(apiKey, secret);
  }

  //------------------------- AUTOGENERATED START -------------------------
  /**
   * The meta-bean for {@code ApiKeyCredentials}.
   * @return the meta-bean, not null
   */
  public static MetaBean meta() {
    return ApiKeyCredentials.Meta.INSTANCE;
  }

  static {
    MetaBean.register(ApiKeyCredentials.Meta.INSTANCE);
  }

  /**
   * Obtains an instance.
   * @param apiKey  the value of the property, not blank
   * @param secret  the value of the property, not blank
   * @return the instance
   */
  public static ApiKeyCredentials of(
      String apiKey,
      String secret) {
    return new ApiKeyCredentials(
      apiKey,
      secret);
  }

  private ApiKeyCredentials(
      String apiKey,
      String secret) {
    JodaBeanUtils.notBlank(apiKey, "apiKey");
    JodaBeanUtils.notBlank(secret, "secret");
    this.apiKey = apiKey;
    this.secret = secret;
  }

  @Override
  public MetaBean metaBean() {
    return ApiKeyCredentials.Meta.INSTANCE;
  }

  //-----------------------------------------------------------------------
  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      ApiKeyCredentials other = (ApiKeyCredentials) obj;
      return JodaBeanUtils.equal(apiKey, other.apiKey) &&
          JodaBeanUtils.equal(secret, other.secret);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = getClass().hashCode();
    hash = hash * 31 + JodaBeanUtils.hashCode(apiKey);
    hash = hash * 31 + JodaBeanUtils.hashCode(secret);
    return hash;
  }

  @Override
  public String toString() {
    StringBuilder buf = new StringBuilder(96);
    buf.append("ApiKeyCredentials{");
    buf.append("apiKey").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');
    buf.append("secret").append('=').append(JodaBeanUtils.toString(secret));
    buf.append('}');
    return buf.toString();
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code ApiKeyCredentials}.
   */
  private static final class Meta extends DirectMetaBean {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code apiKey} property.
     */
    private final MetaProperty<String> apiKey = DirectMetaProperty.ofImmutable(
        this, "apiKey", ApiKeyCredentials.class, String.class);
    /**
     * The meta-property for the {@code secret} property.
     */
    private final MetaProperty<String> secret = DirectMetaProperty.ofImmutable(
        this, "secret", ApiKeyCredentials.class, String.class);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(
        this, null,
        "apiKey",
        "secret");

    /**
     * Restricted constructor.
     */
    private Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -1411301915:  // apiKey
          return apiKey;
        case -906277200:  // secret
          return secret;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends ApiKeyCredentials> builder() {
      return new ApiKeyCredentials.Builder();
    }

    @Override
    public Class<? extends ApiKeyCredentials> beanType() {
      return ApiKeyCredentials.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    @Override
    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
      switch (propertyName.hashCode()) {
        case -1411301915:  // apiKey
          return ((ApiKeyCredentials) bean).apiKey;
        case -906277200:  // secret
          return ((ApiKeyCredentials) bean).secret;
      }
      return super.propertyGet(bean, propertyName, quiet);
    }

    @Override
    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
      metaProperty(propertyName);
      if (quiet) {
        return;
      }
      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
    }

  }

  //-----------------------------------------------------------------------
  /**
   * The bean-builder for {@code ApiKeyCredentials}.
   */
  private static final class Builder extends DirectPrivateBeanBuilder<ApiKeyCredentials> {

    private String apiKey;
    private String secret;

    /**
     * Restricted constructor.
     */
    private Builder() {
    }

    //-----------------------------------------------------------------------
    @Override
    public Object get(String propertyName) {
      switch (propertyName.hashCode()) {
        case -1411301915:  // apiKey
          return apiKey;
        case -906277200:  // secret
          return secret;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
    }

    @Override
    public Builder set(String propertyName, Object newValue) {
      switch (propertyName.hashCode()) {
        case -1411301915:  // apiKey
          this.apiKey = (String) newValue;
          break;
        case -906277200:  // secret
          this.secret = (String) newValue;
          break;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
      return this;
    }

    @Override
    public ApiKeyCredentials build() {
      return new ApiKeyCredentials(
          apiKey,
          secret);
    }

    //-----------------------------------------------------------------------
    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder(96);
      buf.append("ApiKeyCredentials.Builder{");
      buf.append("apiKey").append('=').append(JodaBeanUtils.toString(apiKey)).append(',').append(' ');
      buf.append("secret").append('=').append(JodaBeanUtils.toString(secret));
      buf.append('}');
      return buf.toString();
    }

  }

  //-------------------------- AUTOGENERATED END --------------------------
}
```


Overlapping Code:
```
@BeanDefinition(builderScope = "private", metaScope = "private", factoryName = "of")
final class ApiKeyCredentials implements Credentials, ImmutableBean {
// this class is intended to stay package-scoped
// users are not exposed to the data, to reduce attempts to query the data held within
/**
* The API Key ID with which to authenticate
*/
@PropertyDefinition(validate = "notBlank", get = "")
private final String apiKey;
/**
* The secret corresponding to the id with which to authenticate
*/
@PropertyDefinition(validate = "notBlank", get = "")
private final String secret;
//-------------------------------------------------------------------------
@Override
public AccessTokenResult authenticate(AuthClient client) {
return client.authenticateApiKey(apiKey, secret);
}
//------------------------- AUTOGENERATED START -------------------------
/**
* The meta-bean for {@code ApiKeyCredentials}.
* @return the meta-bean, not null
*/
public static MetaBean meta() {
return ApiKeyCredentials.Meta.INSTANCE;
}
static {
MetaBean.register(ApiKeyCredentials.Meta.INSTANCE);
}
/**
* Obtains an instance.
* @param apiKey the value of the property, not blank
* @param secret the value of the property, not blank
* @return the instance
*/
public static ApiKeyCredentials of(
String apiKey,
String secret) {
return new ApiKeyCredentials(
apiKey,
secret);
}
private ApiKeyCredentials(
String apiKey,
String secret) {
JodaBeanUtils.notBlank(apiKey, "apiKey");
JodaBeanUtils.notBlank(secret, "secret");
this.apiKey = apiKey;
this.secret = secret;
}
@Override
public MetaBean metaBean() {
return ApiKeyCredentials.Meta.INSTANCE;
}
//-----------------------------------------------------------------------
@Override
public boolean equals(Object obj) {
if (obj == this) {
return true;
}
if (obj != null && obj.getClass() == this.getClass()) {
ApiKeyCredentials other = (ApiKeyCredentials) obj;
return JodaBeanUtils.equal(apiKey, other.apiKey) &&
JodaBeanUtils.equal(secret, other.secret);
}
return false;
}
@Override
public int hashCode() {
int hash = getClass().hashCode();
hash = hash * 31 + JodaBeanUtils.hashCode(apiKey);
hash = hash * 31 + JodaBeanUtils.hashCode(secret);
return hash;
}
@Override
public String toString() {
StringBuilder buf = new S
```
<Overlap Ratio: 1.0>

---

--- 202 --
Question ID: 71a9eae8332650a9501d7dbb7b04182e27f247b8
Original Code:
```
public class CursorUtils {

    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, TableStruct tableStruct) {
        long st = System.currentTimeMillis();
        try {
            T entity = type.newInstance();
            for (FCMap fcMap : tableStruct.fcmaps) {
                int index = cursor.getColumnIndex(fcMap.columnName);
                if (index > -1) {
                    Object value = fcMap.translator.readColumnValue(cursor, index, fcMap.field);
                    if (value != null) {
                        fcMap.field.set(entity, value);
                    }
                }
            }
            if (OrmConfig.Debug) {
                Log.d("CursorUtils", "readCurrentEntity With ColumnIndexMap cost:" + (System.currentTimeMillis() - st));
            }
            return entity;
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {
        long st = System.currentTimeMillis();
        try {
            T entity = type.newInstance();
            Field fields[] = type.getDeclaredFields();
            for (Field field : fields) {
                field.setAccessible(true);
                Column column = field.getAnnotation(Column.class);
                if (column != null) {
                    String columnName = TableUtils.getColumnName(field, column);
                    Class<?> fieldType = field.getType();
                    Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, columnIndex.get(columnName), field);
                    if (value != null) {
                        field.set(entity, value);
                    }
                }
            }
            if (OrmConfig.Debug) {
                Log.d("CursorUtils", "readCurrentEntity With ColumnIndexMap cost:" + (System.currentTimeMillis() - st));
            }
            return entity;
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    public static <T> List<T> readEntities(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {
        ArrayList<T> arrayList = new ArrayList<T>();
        while (cursor.moveToNext()) {
            arrayList.add(readCurrentEntity(type, cursor, columnIndex));
        }
        return arrayList;
    }

    public static <T> T readCurrentEntity(Class<T> type, Cursor cursor) {
        long st = System.currentTimeMillis();
        try {
            T entity = type.newInstance();
            Field fields[] = type.getDeclaredFields();
            for (Field field : fields) {
                field.setAccessible(true);
                Column column = field.getAnnotation(Column.class);
                if (column != null) {
                    String columnName = TableUtils.getColumnName(field);
                    Class<?> fieldType = field.getType();
                    int index = cursor.getColumnIndex(columnName);
                    if (index > -1) {
                        Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, index, field);
                        if (value != null) {
                            field.set(entity, value);
                        }
                    }
                }
            }
            if (OrmConfig.Debug) {
                Log.d("CursorUtils", "readCurrentEntity cost:" + (System.currentTimeMillis() - st));
            }
            return entity;
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
}
```


Overlapping Code:
```
public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, TableStruct tableStruct) {
long st = System.currentTimeMillis();
try {
T entity = type.newInstance();
for (FCMap fcMap : tableStruct.fcmaps) {
int index = cursor.getColumnIndex(fcMap.columnName);
if (index > -1) {
Object value = fcMap.translator.readColumnValue(cursor, index, fcMap.field);
if (value != null) {
fcMap.field.set(entity, value);
}
}
}
if (OrmConfig.Debug) {
Log.d("CursorUtils", "readCurrentEntity With ColumnIndexMap cost:" + (System.currentTimeMillis() - st));
}
return entity;
} catch (InstantiationException e) {
throw new RuntimeException(e);
} catch (IllegalAccessException e) {
throw new RuntimeException(e);
}
}
public static <T> T readCurrentEntity(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {
long st = System.currentTimeMillis();
try {
T entity = type.newInstance();
Field fields[] = type.getDeclaredFields();
for (Field field : fields) {
field.setAccessible(true);
Column column = field.getAnnotation(Column.class);
if (column != null) {
String columnName = TableUtils.getColumnName(field, column);
Class<?> fieldType = field.getType();
Object value = OrmConfig.getTranslator(fieldType).readColumnValue(cursor, columnIndex.get(columnName), field);
if (value != null) {
field.set(entity, value);
}
}
}
if (OrmConfig.Debug) {
Log.d("CursorUtils", "readCurrentEntity With ColumnIndexMap cost:" + (System.currentTimeMillis() - st));
}
return entity;
} catch (InstantiationException e) {
throw new RuntimeException(e);
} catch (IllegalAccessException e) {
throw new RuntimeException(e);
}
}
public static <T> List<T> readEntities(Class<T> type, Cursor cursor, Map<String, Integer> columnIndex) {
ArrayList<T> arrayList = new ArrayList<T>();
while (cursor.moveToNext()
```
<Overlap Ratio: 0.9812362030905077>

---

--- 203 --
Question ID: 29b78ee7cd65e40f45c2f175a939fbab2154e803
Original Code:
```
public class Is24CsvReadingExample {
    @SuppressWarnings("unused")
    private final static Logger LOGGER = LoggerFactory.getLogger(Is24CsvReadingExample.class);

    /**
     * Start the example application.
     *
     * @param args command line arguments
     */
    @SuppressWarnings("Duplicates")
    public static void main(String[] args) {
        // read example file, if no files were specified as command line arguments
        if (args.length < 1) {
            try {
                read(Is24CsvReadingExample.class.getResourceAsStream("is24.csv"));
            } catch (Exception ex) {
                LOGGER.error("Can't read example file!");
                LOGGER.error("> " + ex.getLocalizedMessage(), ex);
                System.exit(2);
            }
        }

        // read files, that were specified as command line arguments
        else {
            for (String arg : args) {
                try {
                    read(new File(arg));
                } catch (Exception ex) {
                    LOGGER.error("Can't read file '{}'!", arg);
                    LOGGER.error("> " + ex.getLocalizedMessage(), ex);
                    System.exit(2);
                }
            }
        }
    }

    /**
     * Read a {@link File} into an {@link Is24CsvParser} and print some of its
     * content to console.
     *
     * @param csvFile the CSV file to read
     * @throws IOException if the file is not readable
     */
    protected static void read(File csvFile) throws IOException {
        LOGGER.info("processing file '{}'", csvFile.getAbsolutePath());
        if (!csvFile.isFile()) {
            LOGGER.warn("> The provided file is invalid!");
            return;
        }
        try (Is24CsvParser parser = Is24CsvParser.create(csvFile)) {
            if (parser == null)
                LOGGER.warn("> Can't create parser!");
            else
                printToConsole(parser);
        }
    }

    /**
     * Read an {@link InputStream} into an {@link Is24CsvParser} and print some of
     * its content to console.
     *
     * @param csvInputStream the input stream to read
     * @throws IOException if the file is not readable
     */
    protected static void read(InputStream csvInputStream) throws IOException {
        LOGGER.info("processing example file");
        try (Is24CsvParser parser = Is24CsvParser.create(csvInputStream)) {
            if (parser == null)
                LOGGER.warn("> Can't create parser!");
            else
                printToConsole(parser);
        }
    }

    /**
     * Print some content of an {@link Is24CsvParser} to console.
     *
     * @param parser parser instance
     */
    protected static void printToConsole(Is24CsvParser parser) {
        // process records
        while (parser.hasNext()) {
            Is24CsvRecord record = parser.next();

            // get object nr
            String objectNr = record.getAnbieterObjektId();

            // get object title
            String objectTitle = record.getUeberschrift();

            // print object information to console
            LOGGER.info("> found object '{}': {}",
                    objectNr, objectTitle);
        }
    }
}
```


Overlapping Code:
```
ReadingExample {
@SuppressWarnings("unused")
private final static Logger LOGGER = LoggerFactory.getLogger(Is24CsvReadingExample.class);
/**
* Start the example application.
*
* @param args command line arguments
*/
@SuppressWarnings("Duplicates")
public static void main(String[] args) {
// read example file, if no files were specified as command line arguments
if (args.length < 1) {
try {
read(Is24CsvReadingExample.class.getResourceAsStream("is24.csv"));
} catch (Exception ex) {
LOGGER.error("Can't read example file!");
LOGGER.error("> " + ex.getLocalizedMessage(), ex);
System.exit(2);
}
}
// read files, that were specified as command line arguments
else {
for (String arg : args) {
try {
read(new File(arg));
} catch (Exception ex) {
LOGGER.error("Can't read file '{}'!", arg);
LOGGER.error("> " + ex.getLocalizedMessage(), ex);
System.exit(2);
}
}
}
}
/**
* Read a {@link File} into an {@link Is24CsvParser} and print some of its
* content to console.
*
* @param csvFile the CSV file to read
* @throws IOException if the file is not readable
*/
protected static void read(File csvFile) throws IOException {
LOGGER.info("processing file '{}'", csvFile.getAbsolutePath());
if (!csvFile.isFile()) {
LOGGER.warn("> The provided file is invalid!");
return;
}
try (Is24CsvParser parser = Is24CsvParser.create(csvFile)) {
if (parser == null)
LOGGER.warn("> Can't create parser!");
else
printToConsole(parser);
}
}
/**
* Read an {@link InputStream} into an {@link Is24CsvParser} and print some of
* its content to console.
*
* @param csvInputStream the input stream to read
* @throws IOException if the file is not readable
*/
protected static void read(InputStream csvInputStream) throws IOException {
LOGGER.info("processing example file");
try (Is24CsvParser parser = Is24CsvParser.create(csvInputStream)) {
if (parser == null)
LOGGER.warn("> Can't
```
<Overlap Ratio: 0.9778364116094986>

---

--- 204 --
Question ID: 77f357ef74ebc08199f5a3073ebb0eaa7f8aee9d
Original Code:
```
public class HelloController implements Controller, Initializable {
    private Stage primaryStage;
    private ResourceBundle resourceBundle;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        this.resourceBundle = resourceBundle;
    }

    public void setPrimaryStage(Stage primaryStage) {
        this.primaryStage = primaryStage;
    }

    @FXML
    private void sayHello() {
        System.out.println("say hello");
        Alert alert = new Alert(Alert.AlertType.INFORMATION);
        alert.setTitle("Say Hello");
        alert.setContentText(resourceBundle.getString("say.hello"));
        alert.initModality(Modality.WINDOW_MODAL);
        System.out.println("say hi");
        alert.initOwner(primaryStage);
        alert.showAndWait();
    }
}
```


Overlapping Code:
```
public class HelloController implements Controller, Initializable {
private Stage primaryStage;
private ResourceBundle resourceBundle;
@Override
public void initialize(URL url, ResourceBundle resourceBundle) {
this.resourceBundle = resourceBundle;
}
public void setPrimaryStage(Stage primaryStage) {
this.primaryStage = primaryStage;
}
@FXML
private void sayHello() {
System.out.println("say hello");
Alert alert = new Alert(Alert.AlertType.INFORMATION);
alert.setTitle("Say Hello");
alert.setContentText(resourceBundle.getString("say.hello"));
alert.initModality(Modality.WINDOW_MODAL);
System.out.println("say hi");
alert.initOwner(primaryStage);
alert.showAndWait()
```
<Overlap Ratio: 0.9925705794947994>

---

--- 205 --
Question ID: 76cc88da55396369697c278c4afdddd7141ac044
Original Code:
```
public class BlockWallSign extends BlockSign {

	public static final PropertyDirection FACING = PropertyDirection.create("facing", EnumFacing.Plane.HORIZONTAL);

	public BlockWallSign() {
		this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH));
	}

	@SuppressWarnings ("incomplete-switch")
	public void setBlockBoundsBasedOnState(IBlockAccess worldIn, BlockPos pos) {
		EnumFacing enumfacing = (EnumFacing) worldIn.getBlockState(pos).getValue(FACING);
		float f = 0.28125F;
		float f1 = 0.78125F;
		float f2 = 0.0F;
		float f3 = 1.0F;
		float f4 = 0.125F;
		this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);

		switch (enumfacing) {
			case NORTH:
				this.setBlockBounds(f2, f, 1.0F - f4, f3, f1, 1.0F);
				break;

			case SOUTH:
				this.setBlockBounds(f2, f, 0.0F, f3, f1, f4);
				break;

			case WEST:
				this.setBlockBounds(1.0F - f4, f, f2, 1.0F, f1, f3);
				break;

			case EAST:
				this.setBlockBounds(0.0F, f, f2, f4, f1, f3);
		}
	}

	/**
	 * Called when a neighboring block changes.
	 */
	public void onNeighborBlockChange(World worldIn, BlockPos pos, IBlockState state, Block neighborBlock) {
		EnumFacing enumfacing = (EnumFacing) state.getValue(FACING);

		if (!worldIn.getBlockState(pos.offset(enumfacing.getOpposite())).getBlock().getMaterial().isSolid()) {
			this.dropBlockAsItem(worldIn, pos, state, 0);
			worldIn.setBlockToAir(pos);
		}

		super.onNeighborBlockChange(worldIn, pos, state, neighborBlock);
	}

	/**
	 * Convert the given metadata into a BlockState for this Block
	 */
	public IBlockState getStateFromMeta(int meta) {
		EnumFacing enumfacing = EnumFacing.getFront(meta);

		if (enumfacing.getAxis() == EnumFacing.Axis.Y) {
			enumfacing = EnumFacing.NORTH;
		}

		return this.getDefaultState().withProperty(FACING, enumfacing);
	}

	/**
	 * Convert the BlockState into the correct metadata value
	 */
	public int getMetaFromState(IBlockState state) {
		return ((EnumFacing) state.getValue(FACING)).getIndex();
	}

	protected BlockState createBlockState() {
		return new BlockState(this, new IProperty[] {FACING});
	}

}
```


Overlapping Code:
```
ublic class BlockWallSign extends BlockSign {
public static final PropertyDirection FACING = PropertyDirection.create("facing", EnumFacing.Plane.HORIZONTAL);
public BlockWallSign() {
this.setDefaultState(this.blockState.getBaseState().withProperty(FACING, EnumFacing.NORTH));
}
@SuppressWarnings ("incomplete-switch")
public void setBlockBoundsBasedOnState(IBlockAccess worldIn, BlockPos pos) {
EnumFacing enumfacing = (EnumFacing) worldIn.getBlockState(pos).getValue(FACING);
float f = 0.28125F;
float f1 = 0.78125F;
float f2 = 0.0F;
float f3 = 1.0F;
float f4 = 0.125F;
this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
switch (enumfacing) {
case NORTH:
this.setBlockBounds(f2, f, 1.0F - f4, f3, f1, 1.0F);
break;
case SOUTH:
this.setBlockBounds(f2, f, 0.0F, f3, f1, f4);
break;
case WEST:
this.setBlockBounds(1.0F - f4, f, f2, 1.0F, f1, f3);
break;
case EAST:
this.setBlockBounds(0.0F, f, f2, f4, f1, f3);
}
}
/**
* Called when a neighboring block changes.
*/
public void onNeighborBlockChange(World worldIn, BlockPos pos, IBlockState state, Block neighborBlock) {
EnumFacing enumfacing = (EnumFacing) state.getValue(FACING);
if (!worldIn.getBlockState(pos.offset(enumfacing.getOpposite())).getBlock().getMaterial().isSolid()) {
this.dropBlockAsItem(worldIn, pos, state, 0);
worldIn.setBlockToAir(pos);
}
super.onNeighborBlockChange(worldIn, pos, state, neighborBlock);
}
/**
* Convert the given metadata into a BlockState for this Block
*/
public IBlockState getStateFromMeta(int meta) {
EnumFacing enumfacing = EnumFacing.getFront(meta);
if (enumfacing.getAxis() == EnumFacing.Axis.Y) {
enumfacing = EnumFacing.NORTH;
}
return this.getDefaultState().withProperty(FACING, enumfacing);
}
/**
* Convert the BlockState into the correct metadata value
*/
public int getMetaFromState(IBlockState state) {
return ((EnumFacing) state.getValue(FACING)).getIndex();
}
protected BlockState createBlockState() {
return new BlockState(this, new IProperty[] {FACING
```
<Overlap Ratio: 0.9959390862944163>

---

--- 206 --
Question ID: d0e44d48b966f3921579c64d5f0e2127162ffde1
Original Code:
```
public class LoadingIndicatorConfiguratorTest
        extends AbstractConfigurationTest {

    private final Registry registry = new Registry() {
        {
            set(UILifecycle.class, new UILifecycle());
            set(StateTree.class, new StateTree(this));
            set(LoadingIndicator.class, new LoadingIndicator());
        }
    };

    private NodeMap configuration;

    private LoadingIndicator loadingIndicator;

    @Before
    public void setup() {
        StateNode rootNode = registry.getStateTree().getRootNode();
        configuration = rootNode
                .getMap(NodeFeatures.LOADING_INDICATOR_CONFIGURATION);
        loadingIndicator = registry.getLoadingIndicator();
        LoadingIndicatorConfigurator.observe(rootNode, loadingIndicator);
    }

    @Override
    protected MapProperty getProperty(String key) {
        return configuration.getProperty(key);
    }

    @Test
    public void defaults() {
        Assert.assertEquals(FIRST_DELAY_DEFAULT,
                loadingIndicator.getFirstDelay());
        Assert.assertEquals(SECOND_DELAY_DEFAULT,
                loadingIndicator.getSecondDelay());
        Assert.assertEquals(THIRD_DELAY_DEFAULT,
                loadingIndicator.getThirdDelay());
    }

    @Test
    public void setGetFirstDelay() {
        testInt(FIRST_DELAY_KEY, loadingIndicator::getFirstDelay);
    }

    @Test
    public void setGetSecondDelay() {
        testInt(SECOND_DELAY_KEY, loadingIndicator::getSecondDelay);
    }

    @Test
    public void setGetThirdDelay() {
        testInt(THIRD_DELAY_KEY, loadingIndicator::getThirdDelay);
    }

}
```


Overlapping Code:
```
guratorTest
extends AbstractConfigurationTest {
private final Registry registry = new Registry() {
{
set(UILifecycle.class, new UILifecycle());
set(StateTree.class, new StateTree(this));
set(LoadingIndicator.class, new LoadingIndicator());
}
};
private NodeMap configuration;
private LoadingIndicator loadingIndicator;
@Before
public void setup() {
StateNode rootNode = registry.getStateTree().getRootNode();
configuration = rootNode
.getMap(NodeFeatures.LOADING_INDICATOR_CONFIGURATION);
loadingIndicator = registry.getLoadingIndicator();
LoadingIndicatorConfigurator.observe(rootNode, loadingIndicator);
}
@Override
protected MapProperty getProperty(String key) {
return configuration.getProperty(key);
}
@Test
public void defaults() {
Assert.assertEquals(FIRST_DELAY_DEFAULT,
loadingIndicator.getFirstDelay());
Assert.assertEquals(SECOND_DELAY_DEFAULT,
loadingIndicator.getSecondDelay());
Assert.assertEquals(THIRD_DELAY_DEFAULT,
loadingIndicator.getThirdDelay());
}
@Test
public void setGetFirstDelay() {
testInt(FIRST_DELAY_KEY, loadingIndicator::getFirstDelay);
}
@Test
public void setGetSecondDelay() {
testInt(SECOND_DELAY_KEY, loadingIndicator::getSecondDelay);
}
@Test
public void setGetThirdDelay() {
testInt(THIRD_DELAY_KEY, loadingIndica
```
<Overlap Ratio: 0.9556574923547401>

---

--- 207 --
Question ID: 3e27678292a92c3c3f4eaf18bb6319f84488535a
Original Code:
```
public class FileAgent {
    
    // hash map that saves all the files already loaded by the simulator
    // to avoid reading the same file multiple times.
    private static HashMap<String, ArrayList<String>> readFiles;
    public static DecimalFormat format;
    public static DecimalFormat timeFormat;
    public static final String columnSeparator = ",";
    private static final String lineSeparator = "\n";
    
    static {
	format = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
	format.setMinimumFractionDigits(1);
	format.setMaximumFractionDigits(10);
	timeFormat = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
//	timeFormat.setMinimumFractionDigits(3);
	timeFormat.setMaximumFractionDigits(0);
    }
    
    public static void init(final Configuration configuration) {
        try {

            String header = "";
            for (int i = 0; i < StatisticsMonitor.headersExperimentFile.length; i++) {
                header += StatisticsMonitor.headersExperimentFile[i];
                if (i < StatisticsMonitor.headersExperimentFile.length - 1)
                    header += columnSeparator;
            }
            header += lineSeparator;

            Path path = Paths.get(configuration.getBaseFolder() + "results-" + configuration.getSuffix() + ".csv");
            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);

            header = "";
            for (int i = 0; i < StatisticsMonitor.headersAverageFile.length; i++) {
                header += StatisticsMonitor.headersAverageFile[i];
                if (i < StatisticsMonitor.headersAverageFile.length - 1)
                    header += columnSeparator;
            }
            header += lineSeparator;

            path = Paths.get(configuration.getBaseFolder() + "results-avg-" + configuration.getSuffix() + ".csv");
            Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);

        } catch (final Exception e) {
            e.printStackTrace();
            throw new IllegalArgumentException("[" + Thread.currentThread().getName()
                    + "] Problem when creating files for the experiment " + configuration.getId());
        }
    }

    public static Configuration getConfiguration(final Config mainConfig)
            throws ParserConfigurationException, SAXException, IOException {
        final Configuration config = new Configuration(mainConfig.getInt("simulation.seed"));

        config.setSuffix(mainConfig.getString("simulation.suffix"));

        config.setBaseFolder(mainConfig.getString("simulation.folder"));

        final List<Integer> l = mainConfig.getIntList("simulation.policies");
        final ProvisioningPolicy.Policy[] policies = new ProvisioningPolicy.Policy[l.size()];
        for (int i = 0; i < l.size(); i++) {
            policies[i] = ProvisioningPolicy.Policy.fromInteger(l.get(i));
        }
        config.setPolicies(policies);

        config.setRhoProcessing(mainConfig.getDouble("simulation.rho-processing"));

        config.setRhoStorage(mainConfig.getDouble("simulation.rho-storage"));

        if ("range".equals(mainConfig.getString("simulation.load.type").toLowerCase())) {
            final Integer init = mainConfig.getInt("simulation.load.min");
            final Integer step = mainConfig.getInt("simulation.load.step");
            final Integer last = mainConfig.getInt("simulation.load.max");
            final int diff = (last - init) / step;
            final Integer[] intValues = new Integer[diff + 1];
            intValues[0] = init;
            for (int i = 1; i < intValues.length; i++)
                intValues[i] = init + step * i;
            config.setLoads(intValues);
        } else {
            // TODO implement new load configurations
            System.err.println("Load method not implemented!");
            throw new UnsupportedOperationException("Not supported yet."); // To change body of generated methods,
                                                                           // choose Tools | Templates.
        }

        config.setWavelengthsPerFiber(mainConfig.getInt("simulation.resources-per-link"));

        config.setNumberThreads(mainConfig.getInt("simulation.threads"));

        config.setExperiments(mainConfig.getInt("simulation.experiments"));

        config.setNumberArrivals(mainConfig.getInt("simulation.arrivals"));

        config.setIgnoreFirst(mainConfig.getInt("simulation.ignore-first"));

        final String topologyFile = mainConfig.getString("simulation.topology");

        config.setNumberDatacenters(mainConfig.getInt("simulation.number-dcs"));

        config.setTopologyName(topologyFile.replace(".xml", "").replace(".txt", ""));

        final Topology topo = readTopology(topologyFile, config);

        config.setTopology(topo);

        return config;
    }

    public static ArrayList<String> readFile(final String file) {
        if (readFiles == null)
            readFiles = new HashMap<>();
        if (readFiles.containsKey(file))
            return readFiles.get(file);

        final ArrayList<String> array = new ArrayList<>();
        try {
            try (Stream<String> lines = Files.lines(Paths.get(file)).filter(s -> !s.startsWith("#"));) {
                for (final Object o : lines.toArray())
                    array.add(o.toString());
            }
        } catch (final Exception e) {
            e.printStackTrace();
        }
        readFiles.put(file, array);
        return array;
    }

    private static Topology readTopology(final String topologyName, final Configuration configuration)
            throws ParserConfigurationException, SAXException, IOException {
        final String path = "resources" + File.separator + "topologies" + File.separator + topologyName;
        Topology topology = null;

        if (topologyName.endsWith(".txt")) {

            final ArrayList<String> lines = readFile(path);

            final int nNodes = Integer.parseInt(lines.get(0));
            final int nLinks = Integer.parseInt(lines.get(1));
            final int nDatacenters = Integer.parseInt(lines.get(2));

            topology = new Topology(nNodes, nLinks, configuration);

            // System.out.println("nLinks: " + nLinks);
            int node0;
            int node1;
            for (int link = 0; link < nLinks; link++) {
                final String[] nodes = lines.get(link + 3).split(" ");
                node0 = Integer.parseInt(nodes[0]) - 1;
                node1 = Integer.parseInt(nodes[1]) - 1;

                topology.getLinks()[link].setSource(node0);
                topology.getLinks()[link].setSourceNode(topology.getNodes()[node0]);
                topology.getLinks()[link].setDestination(node1);
                topology.getLinks()[link].setDestinationNode(topology.getNodes()[node1]);
                topology.getLinks()[link].setWeight(1.0);

                topology.getNodes()[node0].getLinks().add(topology.getLinks()[link]);
                topology.getNodes()[node1].getLinks().add(topology.getLinks()[link]);

                topology.getLinksVector()[node0][node1] = topology.getLinks()[link];
                topology.getLinksVector()[node1][node0] = topology.getLinks()[link];

            }

            final String[] dcs = lines.get(nLinks + 3).split(" ");

            for (final String dc : dcs) {
                final int i = Integer.parseInt(dc);
                topology.getNodes()[i - 1].setDatacenter(true);
                topology.addDC(topology.getNodes()[i - 1]);
            }
            configuration.setNumberDatacenters(nDatacenters);
        } else if (topologyName.endsWith(".xml")) {
            // TODO read from SNDlib

            final File file = new File(path);
            final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            final DocumentBuilder db = dbf.newDocumentBuilder();
            final Document doc = db.parse(file);
            doc.getDocumentElement().normalize();

            final NodeList nodeList = doc.getElementsByTagName("node");

            final int nNodes = nodeList.getLength();

            final NodeList linkList = doc.getElementsByTagName("link");

            final int nLinks = linkList.getLength();

            topology = new Topology(nNodes, nLinks, configuration);

            // nodeList is not iterable, so we are using for loop
            for (int itr = 0; itr < nodeList.getLength(); itr++) {
                final Node node = nodeList.item(itr);
                final Element eElement = (Element) node;
                final Element coordinates = (Element) eElement.getElementsByTagName("coordinates").item(0);

                topology.addNode(itr, node.getAttributes().getNamedItem("id").getNodeValue(),
                        Double.parseDouble(coordinates.getElementsByTagName("x").item(0).getTextContent()),
                        Double.parseDouble(coordinates.getElementsByTagName("y").item(0).getTextContent()));
            }

            for (int itr = 0; itr < linkList.getLength(); itr++) {
                final Node node = linkList.item(itr);
                final Element eElement = (Element) node;
                topology.addLink(itr, node.getAttributes().getNamedItem("id").getNodeValue(),
                        eElement.getElementsByTagName("source").item(0).getTextContent(),
                        eElement.getElementsByTagName("target").item(0).getTextContent(), true);
            }

            // defining the placement of DCs
            List<Object> dcs = Arrays.asList(topology.getNodes()).stream()
                    .sorted((n1, n2) -> n2.getDegree().compareTo(n1.getDegree()))
                    .limit(configuration.getNumberDatacenters()).collect(Collectors.toList());
            for (final Object o : dcs) {
                final simulator.cs.anycast.components.Node n = (simulator.cs.anycast.components.Node) o;
                n.setDatacenter(true);
                topology.addDC(n);
            }
        }

        for (final Link link : topology.getLinks()) {
            if (topology.getNodes()[link.getSource()].isDatacenter()
                    || topology.getNodes()[link.getDestination()].isDatacenter())
                link.setDCLink(true);
        }

        return topology;
    }

    /**
     * Method to write the results for one single experiment. It uses file lock to
     * prevent multiple writes at the same time
     * 
     * @param configuration
     * @param results
     */
    public static void reportExperimentStatistics(final Configuration configuration, final ArrayList<Double> results) {
        try {
            final Path path = Paths
                    .get(configuration.getBaseFolder() + "results-" + configuration.getSuffix() + ".csv");

            String text = configuration.getConnectionManager().getPolicyName() + columnSeparator
                    + configuration.getExperiment();
            for (final Double res : results)
                text += columnSeparator + format.format(res);
            text += lineSeparator;

            Files.write(path, text.getBytes(), StandardOpenOption.APPEND);

        } catch (final Exception ex) {
            ex.printStackTrace();
            throw new IllegalArgumentException("[" + Thread.currentThread().getName()
                    + "] Problem when creating experiment statistics files for the experiment "
                    + configuration.getId());
        }

    }

    /**
     * Method to write the final results for one experiment. It uses file lock to
     * prevent multiple writes at the same time
     * 
     * @param configuration
     * @param results
     */
    public static void reportFinalStatistics(final Configuration configuration, final ArrayList<BigDecimal> results) {
        try {

            String text = configuration.getConnectionManager().getPolicyName();
            for (final BigDecimal res : results)
                text += columnSeparator + format.format(res);
            text += lineSeparator;

            Files.write(Paths.get(configuration.getBaseFolder() + "results-avg-" + configuration.getSuffix() + ".csv"),
                    text.getBytes(), StandardOpenOption.APPEND);

        } catch (final Exception ex) {
            ex.printStackTrace();
            throw new IllegalArgumentException("[" + Thread.currentThread().getName()
                    + "] Problem when creating final statistics files for the experiment " + configuration.getId());
        }

    }

    public static void copyFolder(final Path src, final Path dst) throws IOException {
        Files.walk(src).forEach(source -> {
            try {
                Files.copy(src, dst.resolve(src.relativize(source)));
            } catch (final IOException ex) {
                Logger.getLogger(FileAgent.class.getName()).log(Level.SEVERE, null, ex);
            }
        });
    }
    
}
```


Overlapping Code:
```
ves all the files already loaded by the simulator
// to avoid reading the same file multiple times.
private static HashMap<String, ArrayList<String>> readFiles;
public static DecimalFormat format;
public static DecimalFormat timeFormat;
public static final String columnSeparator = ",";
private static final String lineSeparator = "\n";

static {
format = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
format.setMinimumFractionDigits(1);
format.setMaximumFractionDigits(10);
timeFormat = new DecimalFormat("0", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
// timeFormat.setMinimumFractionDigits(3);
timeFormat.setMaximumFractionDigits(0);
}

public static void init(final Configuration configuration) {
try {
String header = "";
for (int i = 0; i < StatisticsMonitor.headersExperimentFile.length; i++) {
header += StatisticsMonitor.headersExperimentFile[i];
if (i < StatisticsMonitor.headersExperimentFile.length - 1)
header += columnSeparator;
}
header += lineSeparator;
Path path = Paths.get(configuration.getBaseFolder() + "results-" + configuration.getSuffix() + ".csv");
Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);
header = "";
for (int i = 0; i < StatisticsMonitor.headersAverageFile.length; i++) {
header += StatisticsMonitor.headersAverageFile[i];
if (i < StatisticsMonitor.headersAverageFile.length - 1)
header += columnSeparator;
}
header += lineSeparator;
path = Paths.get(configuration.getBaseFolder() + "results-avg-" + configuration.getSuffix() + ".csv");
Files.write(path, header.getBytes(), StandardOpenOption.CREATE_NEW);
} catch (final Exception e) {
e.printStackTrace();
throw new IllegalArgumentException("[" + Thread.currentThread().getName()
+ "] Problem when creating files for the experiment " + configuration.getId());
}
}
public static Configuration getConfiguration(final Config mainConfig)
throws ParserConfigurationException, SAXException, IOException {
final Configuration config = new Configuration(mainConfig.
```
<Overlap Ratio: 0.9601536245799328>

---

--- 208 --
Question ID: b160dea1970d2ce12140a6977a430bfc9012caf2
Original Code:
```
public class BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspection
  extends BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspectionBase {

  @Override
  protected InspectionGadgetsFix buildFix(Object... infos) {
    if (infos.length != 1) return null;
    final Object name = infos[0];
    if (!(name instanceof String)) return null;
    return new MakePublicStaticVoidFix((String)name);
  }

  private static class MakePublicStaticVoidFix extends InspectionGadgetsFix {
    private final String myName;

    public MakePublicStaticVoidFix(String name) {
      myName = name;
    }

    @Override
    protected void doFix(final Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {
      final PsiMethod method = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiMethod.class);
      if (method != null) {
        final PsiModifierList modifierList = method.getModifierList();
        if (!modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {
          modifierList.setModifierProperty(PsiModifier.PUBLIC, true);
        }
        if (!modifierList.hasModifierProperty(PsiModifier.STATIC)) {
          modifierList.setModifierProperty(PsiModifier.STATIC, true);
        }

        if (!PsiType.VOID.equals(method.getReturnType())) {
          ChangeSignatureProcessor csp =
            new ChangeSignatureProcessor(project, method, false, PsiModifier.PUBLIC, method.getName(), PsiType.VOID,
                                         new ParameterInfoImpl[0]);
          csp.run();
        }
      }
    }

    @NotNull
    @Override
    public String getFamilyName() {
      return "Fix modifiers";
    }

    @Override
    @NotNull
    public String getName() {
      return myName;
    }
  }
}
```


Overlapping Code:
```
assOrAfterClassIsPublicStaticVoidNoArgInspection
extends BeforeClassOrAfterClassIsPublicStaticVoidNoArgInspectionBase {
@Override
protected InspectionGadgetsFix buildFix(Object... infos) {
if (infos.length != 1) return null;
final Object name = infos[0];
if (!(name instanceof String)) return null;
return new MakePublicStaticVoidFix((String)name);
}
private static class MakePublicStaticVoidFix extends InspectionGadgetsFix {
private final String myName;
public MakePublicStaticVoidFix(String name) {
myName = name;
}
@Override
protected void doFix(final Project project, ProblemDescriptor descriptor) throws IncorrectOperationException {
final PsiMethod method = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiMethod.class);
if (method != null) {
final PsiModifierList modifierList = method.getModifierList();
if (!modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {
modifierList.setModifierProperty(PsiModifier.PUBLIC, true);
}
if (!modifierList.hasModifierProperty(PsiModifier.STATIC)) {
modifierList.setModifierProperty(PsiModifier.STATIC, true);
}
if (!PsiType.VOID.equals(method.getReturnType())) {
ChangeSignatureProcessor csp =
new ChangeSignatureProcessor(project, method, false, PsiModifier.PUBLIC, method.getName(), PsiType.VOID,
new ParameterInfoImpl[0]);
csp.run();
}
}
}
@NotNull
@Override
public String getFamilyName() {
return "Fix modifiers";
}
@Override
@NotNull
public String getName() {
return myName;
}
}
```
<Overlap Ratio: 0.9843003412969283>

---

--- 209 --
Question ID: 07512f789654c0ad756fa362edc5312fdc9fe207
Original Code:
```
public class LoggingSanitizerTest {

    /**
     * The same as {@link LoggingSanitizer#SANITIZED_SUFIX}
     */
    private String SANITIZED_SUFIX = " (Sanitized)";


    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter contains Carriage Return (ASCII 13, \r) and Line Feed (ASCII 10, \n) characters.
     */
    @Test
    public void testRemoveCRLFInjectionStringWithCRLF() {
        final String message = "DEMO-SP\\n2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\\n\\r\\n\\r";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter does contains Carriage Return (ASCII 13, \r) and Line Feed (ASCII 10, \n) characters.
     */
    @Test
    public void testRemoveCRLFInjection() {
        final String message = "DEMO-SP 2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an URL.
     */
    @Test
    public void testRemoveCRLFInjectionUrl() {
        final String message = "http://localhost$-_.+!*'(),:8080/EidasNode/ColleagueRequest";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an URL with CRLF.
     */
    @Test
    public void testRemoveCRLFInjectionUrlWithCRLF() {
        final String message = "http://localhost$-_.+!*'(),:8080/\\n\\rEidasNode/ColleagueRequest";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an ID.
     */
    @Test
    public void testRemoveCRLFInjectionId() {
        final String message = "_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an ID with CRLF.
     */
    @Test
    public void testRemoveCRLFInjectionIdWithCRLF() {
        final String message = "_3WcFUc9H8b8a1kHoS.DfLcmyUR9WREN_2W6ejrWJFPrueVt-I6GcWaZx76EzQzv\\r";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an Hash.
     */
    @Test
    public void testRemoveCRLFInjectionHash() {
        final String message = "NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an Hash with CRLF.
     */
    @Test
    public void testRemoveCRLFInjectionHashWithCRLF() {
        final String message = "NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtr\\nlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is Null.
     */
    @Test
    public void testRemoveCRLFInjectionNullParameter() {
        final String message = "NU3P2SBD8BRUN9yEWoO5RbZP/BijYjrciZnKtrlxU6zexWYRlOWzdWH0HpofKynOcYVb/eO/OWzK26WtwkoEBA==";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message,messageWithoutCRLFInjection);
    }

    /**
     * Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
     * the String received as parameter is an empty string.
     */
    @Test
    public void testRemoveCRLFInjectionEmptyParameter() {
        final String message = "";
        final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
        assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
    }


    /**
     * Auxiliar method that contains the assertions when CRLF removal was applied.
     *
     * @param messageIn the inital string before CRLF removal
     * @param messageOut the output string after CRLF removal
     */
    private void assertCrlfRemovalApplied(String messageIn, String messageOut) {
        Assert.assertNotEquals(messageIn,messageOut);
        SANITIZED_SUFIX = " (Sanitized)";
        Assert.assertTrue("The Sanitized Sufix was not appended",messageOut.contains(SANITIZED_SUFIX));
    }

    /**
     * Auxiliar method that contains the assertions when CRLF removal was applied.
     *
     * @param messageIn the inital string before CRLF removal
     * @param messageOut the output string after CRLF removal
     */
    private void assertCrlfRemovalNotApplied(String messageIn, String messageOut) {
        Assert.assertEquals(messageIn,messageOut);
        Assert.assertFalse("The Sanitized Sufix was appended",messageOut.contains(SANITIZED_SUFIX));
    }

}
```


Overlapping Code:
```
{
/**
* The same as {@link LoggingSanitizer#SANITIZED_SUFIX}
*/
private String SANITIZED_SUFIX = " (Sanitized)";
/**
* Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
* the String received as parameter contains Carriage Return (ASCII 13, \r) and Line Feed (ASCII 10, \n) characters.
*/
@Test
public void testRemoveCRLFInjectionStringWithCRLF() {
final String message = "DEMO-SP\\n2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK\\n\\r\\n\\r";
final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
}
/**
* Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
* the String received as parameter does contains Carriage Return (ASCII 13, \r) and Line Feed (ASCII 10, \n) characters.
*/
@Test
public void testRemoveCRLFInjection() {
final String message = "DEMO-SP 2017-04-28; 13:10:29.328 [ajp-nio-8009-exec-10] INFO gOtThEmIlK";
final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
}
/**
* Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
* the String received as parameter is an URL.
*/
@Test
public void testRemoveCRLFInjectionUrl() {
final String message = "http://localhost$-_.+!*'(),:8080/EidasNode/ColleagueRequest";
final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
assertCrlfRemovalNotApplied(message, messageWithoutCRLFInjection);
}
/**
* Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
* the String received as parameter is an URL with CRLF.
*/
@Test
public void testRemoveCRLFInjectionUrlWithCRLF() {
final String message = "http://localhost$-_.+!*'(),:8080/\\n\\rEidasNode/ColleagueRequest";
final String messageWithoutCRLFInjection = LoggingSanitizer.removeCRLFInjection(message);
assertCrlfRemovalApplied(message, messageWithoutCRLFInjection);
}
/**
* Tests {@link LoggingSanitizer#removeCRLFInjection(String)} when,
* the String received as parameter is an ID.
*/
@Test
public void testRemoveCRLFInjectionId() {
final
```
<Overlap Ratio: 0.9689049121225778>

---

--- 210 --
Question ID: 09536f860f14c901cb00610fa5fadcff2c16f4a9
Original Code:
```
public class TestOpenTsdbMetricStreamerConfig {

    @Test
    public void validateValidConfig() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig("host", 4242,
                new TimeInterval(10L, TimeUnit.SECONDS), streams);
        config.validate();

        assertThat(config.getOpenTsdbHost(), is("host"));
        assertThat(config.getOpenTsdbPort(), is(4242));
        assertThat(config.getPollInterval(), is(new TimeInterval(10L, TimeUnit.SECONDS)));
        assertThat(config.getMetricStreams(), is(Collections.emptyList()));
    }

    /**
     * openTsdbPort, pollInterval and metricstreams is optional
     */
    @Test
    public void withDefaults() {
        Integer openTsdbPort = null;
        List<OpenTsdbMetricStreamDefinition> streams = null;
        TimeInterval pollInterval = null;
        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig("host", openTsdbPort, pollInterval,
                streams);
        config.validate();

        assertThat(config.getOpenTsdbPort(), is(OpenTsdbMetricStreamerConfig.DEFAULT_OPENTSDB_PORT));
        assertThat(config.getPollInterval(), is(OpenTsdbMetricStreamerConfig.DEFAULT_POLL_INTERVAL));
        assertThat(config.getMetricStreams(), is(Collections.emptyList()));
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithMissingHost() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        new OpenTsdbMetricStreamerConfig(null, 4242, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithNegativePort() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        new OpenTsdbMetricStreamerConfig("host", -1, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithZeroPort() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        new OpenTsdbMetricStreamerConfig("host", 0, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithTooHighPort() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        new OpenTsdbMetricStreamerConfig("host", 65354, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithNegativePollInterval() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        TimeInterval illegalPollInterval = JsonUtils
                .toObject(JsonUtils.parseJsonString("{\"time\": -1, \"unit\": \"seconds\"}"), TimeInterval.class);
        new OpenTsdbMetricStreamerConfig("host", 4242, illegalPollInterval, streams).validate();
    }

    @Test(expected = IllegalArgumentException.class)
    public void validateWithZeroPollInterval() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        TimeInterval illegalPollInterval = new TimeInterval(0L, TimeUnit.SECONDS);
        new OpenTsdbMetricStreamerConfig("host", 4242, illegalPollInterval, streams).validate();
    }

    @Test
    public void testEqualsAndHashcode() {
        List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
        OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig("host", 4242,
                new TimeInterval(10L, TimeUnit.SECONDS), streams);

        OpenTsdbMetricStreamerConfig equal = new OpenTsdbMetricStreamerConfig("host", 4242,
                new TimeInterval(10L, TimeUnit.SECONDS), streams);
        OpenTsdbMetricStreamerConfig differentHost = new OpenTsdbMetricStreamerConfig("host2", 4242,
                new TimeInterval(10L, TimeUnit.SECONDS), streams);
        OpenTsdbMetricStreamerConfig differentPort = new OpenTsdbMetricStreamerConfig("host", 2424,
                new TimeInterval(10L, TimeUnit.SECONDS), streams);
        OpenTsdbMetricStreamerConfig differentPoll = new OpenTsdbMetricStreamerConfig("host", 4242,
                new TimeInterval(11L, TimeUnit.SECONDS), streams);
        OpenTsdbMetricStreamerConfig differentStreams = config.withMetricStream(new OpenTsdbMetricStreamDefinition("id",
                "metric", MetricAggregator.MAX, false, null, null, null, null));

        assertTrue(config.equals(equal));
        assertFalse(config.equals(differentHost));
        assertFalse(config.equals(differentPort));
        assertFalse(config.equals(differentPoll));
        assertFalse(config.equals(differentStreams));

        assertTrue(config.hashCode() == equal.hashCode());
        assertFalse(config.hashCode() == differentHost.hashCode());
        assertFalse(config.hashCode() == differentPort.hashCode());
        assertFalse(config.hashCode() == differentPoll.hashCode());
        assertFalse(config.hashCode() == differentStreams.hashCode());
    }

    /**
     * Tests the
     * {@link OpenTsdbMetricStreamerConfig#withMetricStream(OpenTsdbMetricStreamDefinition)}
     * copy method.
     */
    @Test
    public void testWithMetricStreamDefinition() {
        OpenTsdbMetricStreamerConfig original = config();
        assertThat(original, is(config()));

        // use withStreamDefinition copy method to create a config with an add
        // stream definition
        OpenTsdbMetricStreamDefinition stream1 = new OpenTsdbMetricStreamDefinition("id1", "metric",
                MetricAggregator.SUM, true, null, null, new TimeInterval(10L, TimeUnit.SECONDS), null);
        OpenTsdbMetricStreamerConfig extendedCopy = original.withMetricStream(stream1);
        // extended copy is original + the new stream definition
        assertThat(extendedCopy, is(config(stream1)));
        // original should remain unchanged
        assertThat(original, is(config()));

        // test chaining calls
        OpenTsdbMetricStreamDefinition stream2 = new OpenTsdbMetricStreamDefinition("id2", "metric2",
                MetricAggregator.SUM, true, null, null, new TimeInterval(20L, TimeUnit.SECONDS), null);
        extendedCopy = original.withMetricStream(stream1).withMetricStream(stream2);
        assertThat(extendedCopy, is(config(stream1, stream2)));
    }

    private OpenTsdbMetricStreamerConfig config(OpenTsdbMetricStreamDefinition... streams) {
        List<OpenTsdbMetricStreamDefinition> streamDefList = Arrays.asList(streams);
        return new OpenTsdbMetricStreamerConfig("host", 4242, new TimeInterval(10L, TimeUnit.SECONDS), streamDefList);
    }

}
```


Overlapping Code:
```
StreamerConfig {
@Test
public void validateValidConfig() {
List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig("host", 4242,
new TimeInterval(10L, TimeUnit.SECONDS), streams);
config.validate();
assertThat(config.getOpenTsdbHost(), is("host"));
assertThat(config.getOpenTsdbPort(), is(4242));
assertThat(config.getPollInterval(), is(new TimeInterval(10L, TimeUnit.SECONDS)));
assertThat(config.getMetricStreams(), is(Collections.emptyList()));
}
/**
* openTsdbPort, pollInterval and metricstreams is optional
*/
@Test
public void withDefaults() {
Integer openTsdbPort = null;
List<OpenTsdbMetricStreamDefinition> streams = null;
TimeInterval pollInterval = null;
OpenTsdbMetricStreamerConfig config = new OpenTsdbMetricStreamerConfig("host", openTsdbPort, pollInterval,
streams);
config.validate();
assertThat(config.getOpenTsdbPort(), is(OpenTsdbMetricStreamerConfig.DEFAULT_OPENTSDB_PORT));
assertThat(config.getPollInterval(), is(OpenTsdbMetricStreamerConfig.DEFAULT_POLL_INTERVAL));
assertThat(config.getMetricStreams(), is(Collections.emptyList()));
}
@Test(expected = IllegalArgumentException.class)
public void validateWithMissingHost() {
List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
new OpenTsdbMetricStreamerConfig(null, 4242, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
}
@Test(expected = IllegalArgumentException.class)
public void validateWithNegativePort() {
List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
new OpenTsdbMetricStreamerConfig("host", -1, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
}
@Test(expected = IllegalArgumentException.class)
public void validateWithZeroPort() {
List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
new OpenTsdbMetricStreamerConfig("host", 0, new TimeInterval(10L, TimeUnit.SECONDS), streams).validate();
}
@Test(expected = IllegalArgumentException.class)
public void validateWithTooHighPort() {
List<OpenTsdbMetricStreamDefinition> streams = new ArrayList<>();
new OpenTsdbMetricStreamerConfig("host", 65354, new TimeInterval
```
<Overlap Ratio: 0.9803921568627451>

---

--- 211 --
Question ID: 1e962b0f24615bd7790c68851fd77406e48aa53a
Original Code:
```
@RunWith(Parameterized.class)
public class TestOneLineFormatterMillisPerformance {

    @Parameterized.Parameters(name = "{index}: format[{0}]")
    public static Collection<Object[]> parameters() {

        List<Object[]> parameterSets = new ArrayList<>();

        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSS" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SS" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.S" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss XXX" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSSXXX" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSXXX" });
        parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SXXX" });
        parameterSets.add(new String[] { "SSS dd-MMM-yyyy HH:mm:ss" });
        parameterSets.add(new String[] { "SS dd-MMM-yyyy HH:mm:ss" });
        parameterSets.add(new String[] { "S dd-MMM-yyyy HH:mm:ss" });

        return parameterSets;
    }


    @Parameter(0)
    public String timestampFormat;

    @Test
    public void testMillisHandling() {
        OneLineFormatter olf = new OneLineFormatter();
        olf.setTimeFormat(timestampFormat);

        long timeStamp = System.currentTimeMillis();
        StringBuilder buf = new StringBuilder(64);

        long start = System.nanoTime();
        for (int i = 0; i < 10000000; i++) {
            buf.setLength(0);
            olf.addTimestamp(buf, timeStamp);
        }
        System.out.println("Format: [" + timestampFormat + "], Output: [" + buf + "], Duration: [" + (System.nanoTime() - start) + "] ns");
    }
}
```


Overlapping Code:
```
s TestOneLineFormatterMillisPerformance {
@Parameterized.Parameters(name = "{index}: format[{0}]")
public static Collection<Object[]> parameters() {
List<Object[]> parameterSets = new ArrayList<>();
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSS" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SS" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.S" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss XXX" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSSXXX" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SSXXX" });
parameterSets.add(new String[] { "dd-MMM-yyyy HH:mm:ss.SXXX" });
parameterSets.add(new String[] { "SSS dd-MMM-yyyy HH:mm:ss" });
parameterSets.add(new String[] { "SS dd-MMM-yyyy HH:mm:ss" });
parameterSets.add(new String[] { "S dd-MMM-yyyy HH:mm:ss" });
return parameterSets;
}
@Parameter(0)
public String timestampFormat;
@Test
public void testMillisHandling() {
OneLineFormatter olf = new OneLineFormatter();
olf.setTimeFormat(timestampFormat);
long timeStamp = System.currentTimeMillis();
StringBuilder buf = new StringBuilder(64);
long start = System.nanoTime();
for (int i = 0; i < 10000000; i++) {
buf.setLength(0);
olf.addTimestamp(buf, timeStamp);
}
System.out.println("Format: [" + timestampFormat + "], Output: [" + buf + "], Duration: [" + (System.nano
```
<Overlap Ratio: 0.9519945909398242>

---

--- 212 --
Question ID: f35033385385fcf1569c01f2476ce3de0ccf8307
Original Code:
```
public class VersioningInterest implements CCNCategorizedStatistics {
	
	// ==============================================================================
	// Public API

	/**
	 * @param handle
	 * @param listener
	 */
	public VersioningInterest(CCNHandle handle) {
		_handle = handle;
	}
	
	/**
	 * Express an interest for #name.  We will assume that #name does not
	 * include a version, and we construct an interest that will only match
	 * 3 additional components to #name (version/segment/digest).
	 * 
	 * When the default CCN timeout is exceeded, we stop responding.
	 * 
	 * If there is already an interest for the same (name, listener), no action is taken.
	 * 
	 * The return value from #listener is ignored, the listener does not need to re-express
	 * an interest.  Interests are re-expressed automatically until canceled.
	 * 
	 * @param name
	 * @param listener
	 * @throws IOException 
	 */
	public void expressInterest(ContentName name, CCNContentHandler handler) throws IOException {
		expressInterest(name, handler, null, null);
	}

	/**
	 * As above, and provide a set of versions to exclude
	 * The return value from #listener is ignored, the listener does not need to re-express
	 * an interest.  Interests are re-expressed automatically until canceled.
	 * 
	 * @param name
	 * @param handler
	 * @param retrySeconds
	 * @param exclusions may be null
	 * @throws IOException 
	 */
	public void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions) throws IOException {
		expressInterest(name, handler, exclusions, null);
	}
	
	/**
	 * As above, and provide a set of versions to exclude and a hard floor startingVersion, any version
	 * before that will be ignored.
	 * 
	 * The return value from #listener is ignored, the listener does not need to re-express
	 * an interest.  Interests are re-expressed automatically until canceled.
	 * 
	 * @param name
	 * @param handler
	 * @param retrySeconds
	 * @param exclusions may be null
	 * @param startingVersion the minimum version to include (may be null)
	 * @throws IOException 
	 */
	public void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVeersion) throws IOException {
		addInterest(name, handler, exclusions, startingVeersion);
	}
	
	/**
	 * Kill off all interests.
	 */
	
	public void close() {
		removeAll();
	}

	/**
	 * Cancel a specific interest
	 * @param name
	 * @param handler
	 */
	public void cancelInterest(ContentName name, CCNContentHandler handler) {
		removeInterest(name, handler);
	}

	/**
	 * in case we're GC'd without a close().  Don't rely on this.
	 */
	protected void finalize() throws Throwable {
		try {
			removeAll();
		} finally {
			super.finalize();
		}
	}
	
	/**
	 * return the statistics for the interests corresponding to name
	 * @param name A ContentName or a URI-encoded string
	 * @return May be null if no interest expressed for name
	 */
	public CCNStats getStatsByName(Object name) throws ClassCastException {
		ContentName cn = null;
		if( name instanceof ContentName )
			cn = (ContentName) name;
		else if( name instanceof String )
			try {
				cn = ContentName.fromURI((String) name);
			} catch (MalformedContentNameStringException e) {
			}
	
		if( null == cn )
			throw new ClassCastException("Name must be a ContentName or a URI string");
		
		synchronized(_map) {
			BasenameState data = _map.get(cn);
			if( null != data )
				return data.getStats();
			return null;
		}
	}
	
	public Object[] getCategoryNames() {
		synchronized(_map) {
			return _map.keySet().toArray();
		}
	}
	
	// ==============================================================================
	// Internal implementation
	private final CCNHandle _handle;
	private final Map<ContentName, BasenameState> _map = new HashMap<ContentName, BasenameState>();

	private void addInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVersion) throws IOException {
		BasenameState data;
		
		synchronized(_map) {
			data = _map.get(name);
			if( null == data ) {
				data = new BasenameState(_handle, name, exclusions, startingVersion);
				_map.put(name, data);
				data.addListener(handler);
				data.start();
			} else {
				data.addListener(handler);
			}
		}
	}
	
	/**
	 * Remove a listener.  If it is the last listener, remove from map and
	 * kill all interests.
	 * @param name
	 * @param listener
	 */
	private void removeInterest(ContentName name, CCNContentHandler handler) {
		BasenameState data;
		
		synchronized(_map) {
			data = _map.get(name);
			if( null != data ) {
				data.removeListener(handler);
				if( data.size() == 0 ) {
					data.stop();
					_map.remove(name);
				}
			}
		}
	}
	
	private void removeAll() {
		synchronized(_map) {
			Iterator<BasenameState> iter = _map.values().iterator();
			while( iter.hasNext() ) {
				BasenameState bns = iter.next();
				bns.stop();
				iter.remove();
			}
		}
	}
	
	// ======================================================================
	// This is the state stored per base name
	
	private static class BasenameState implements CCNContentHandler, CCNStatistics {
		
		public BasenameState(CCNHandle handle, ContentName basename, Set<VersionNumber> exclusions, VersionNumber startingVersion) {
			_vim = new VersioningInterestManager(handle, basename, exclusions, startingVersion, this);
		}
		
		/**
		 * @param listener
		 * @param retrySeconds IGNORED, not implemented
		 * @return true if added, false if existed or only retrySeconds updated
		 */
		public boolean addListener(CCNContentHandler handler) {
			if( handler == null) return false;
			synchronized(_handlers) {
				return _handlers.add(handler);
			}
		}
		
		/**
		 * @return true if removed, false if not found
		 */
		public boolean removeListener(CCNContentHandler handler) {
			if( handler == null) return false;
			synchronized(_handlers) {
				return _handlers.remove(handler);
			}
		}
				
		public int size() {
			synchronized(_handlers) {
				return _handlers.size();
			}
		}

		/**
		 * start issuing interests.  No data is passed to
		 * any listener in the stopped state
		 * @throws IOException 
		 */
		public void start() throws IOException {
			_running = true;
			_vim.start();
		}
		
		/**
		 * Cancel all interests for the name
		 */
		public void stop() {
			_running = false;
			_vim.stop();
		}
		
		/**
		 * Pass any received data up to the user.
		 * @param data
		 * @param interest
		 * @return null
		 */
		public Interest handleContent(ContentObject data, Interest interest) {
			// when we're stopped, we do not pass any data
			if( ! _running )
				return null;
			
			synchronized(_handlers) {
				for(CCNContentHandler handler : _handlers) {
					try {
						handler.handleContent(data, interest);
					} catch(Exception e){
						e.printStackTrace();
					}
				}
			}
			return null;
		}
		
		public CCNStats getStats() {
			return _vim.getStats();
		}
		
		// =======
		
		private final Set<CCNContentHandler> _handlers = new HashSet<CCNContentHandler>();
		private final VersioningInterestManager _vim;
		private boolean _running = false;

	}

}
```


Overlapping Code:
```
ic class VersioningInterest implements CCNCategorizedStatistics {

// ==============================================================================
// Public API
/**
* @param handle
* @param listener
*/
public VersioningInterest(CCNHandle handle) {
_handle = handle;
}

/**
* Express an interest for #name. We will assume that #name does not
* include a version, and we construct an interest that will only match
* 3 additional components to #name (version/segment/digest).
* 
* When the default CCN timeout is exceeded, we stop responding.
* 
* If there is already an interest for the same (name, listener), no action is taken.
* 
* The return value from #listener is ignored, the listener does not need to re-express
* an interest. Interests are re-expressed automatically until canceled.
* 
* @param name
* @param listener
* @throws IOException 
*/
public void expressInterest(ContentName name, CCNContentHandler handler) throws IOException {
expressInterest(name, handler, null, null);
}
/**
* As above, and provide a set of versions to exclude
* The return value from #listener is ignored, the listener does not need to re-express
* an interest. Interests are re-expressed automatically until canceled.
* 
* @param name
* @param handler
* @param retrySeconds
* @param exclusions may be null
* @throws IOException 
*/
public void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions) throws IOException {
expressInterest(name, handler, exclusions, null);
}

/**
* As above, and provide a set of versions to exclude and a hard floor startingVersion, any version
* before that will be ignored.
* 
* The return value from #listener is ignored, the listener does not need to re-express
* an interest. Interests are re-expressed automatically until canceled.
* 
* @param name
* @param handler
* @param retrySeconds
* @param exclusions may be null
* @param startingVersion the minimum version to include (may be null)
* @throws IOException 
*/
public void expressInterest(ContentName name, CCNContentHandler handler, Set<VersionNumber> exclusions, VersionNumber startingVeersion) throws IOException {
addInterest(name, handler, exclusions, startingVeersion);
}

/**
* Kill off all interests.
*/

public void close() {
removeAll();
}
/**
* Cancel a specific interest
* @param name
* @param handler
*/
public void c
```
<Overlap Ratio: 0.994077834179357>

---

--- 213 --
Question ID: 79a2ee5af53d547fa81605da5a158b122df9028e
Original Code:
```
public class BinaryColumnVector extends ColumnVector {
	private static final long serialVersionUID = -8529155738773478597L;

	public byte[][] vector;
	private int nextFree;    // next free position in buffer

	/**
	 * Don't call this constructor except for testing purposes.
	 *
	 * @param size number of elements in the column vector
	 */
	public BinaryColumnVector(int size) {
		super(size);
		vector = new byte[size][];
	}

	@Override
	public Object get(int index) {
		return vector[index];
	}

	/**
	 * Additional reset work for BytesColumnVector (releasing scratch bytes for by value strings).
	 */
	@Override
	public void reset() {
		super.reset();
	}

	/**
	 * Set a field by reference.
	 *
	 * @param elementNum index within column vector to set
	 * @param sourceBuf  container of source data
	 * @param start      start byte position within source
	 * @param length     length of source byte sequence
	 */
	public void setRef(int elementNum, byte[] sourceBuf, int start, int length) {
		vector[elementNum] = sourceBuf;
	}

	/**
	 * Set a field by actually copying in to a local buffer.
	 * If you must actually copy data in to the array, use this method.
	 * DO NOT USE this method unless it's not practical to set data by reference with setRef().
	 * Setting data by reference tends to run a lot faster than copying data in.
	 *
	 * @param elementNum index within column vector to set
	 * @param sourceBuf  container of source data
	 */
	public void setVal(int elementNum, byte[] sourceBuf) {
		vector[elementNum] = sourceBuf;
	}

	/**
	 * Copy the current object contents into the output. Only copy selected entries,
	 * as indicated by selectedInUse and the sel array.
	 */
	@Override
	public void copySelected(boolean selectedInUse, int[] sel, int size, ColumnVector output) {

		// Output has nulls if and only if input has nulls.
		output.noNulls = noNulls;

		// Copy data values over
		if (selectedInUse) {
			for (int j = 0; j < size; j++) {
				int i = sel[j];
				((BinaryColumnVector) output).setVal(i, vector[i]);
			}
		} else {
			for (int i = 0; i < size; i++) {
				((BinaryColumnVector) output).setVal(i, vector[i]);
			}
		}

		// Copy nulls over if needed
		super.copySelected(selectedInUse, sel, size, output);
	}

	@Override
	public void setElement(int outElementNum, int inputElementNum, ColumnVector inputVector) {
		if (inputVector.noNulls || !inputVector.isNull[inputElementNum]) {
			isNull[outElementNum] = false;
			BinaryColumnVector in = (BinaryColumnVector) inputVector;
			setVal(outElementNum, in.vector[inputElementNum]);
		} else {
			isNull[outElementNum] = true;
			noNulls = false;
		}
	}

	@Override
	public void init() {
	}

	@Override
	public void shallowCopyTo(ColumnVector otherCv) {
		BinaryColumnVector other = (BinaryColumnVector) otherCv;
		super.shallowCopyTo(other);
		other.nextFree = nextFree;
		other.vector = vector;
	}
}
```


Overlapping Code:
```
ublic class BinaryColumnVector extends ColumnVector {
private static final long serialVersionUID = -8529155738773478597L;
public byte[][] vector;
private int nextFree; // next free position in buffer
/**
* Don't call this constructor except for testing purposes.
*
* @param size number of elements in the column vector
*/
public BinaryColumnVector(int size) {
super(size);
vector = new byte[size][];
}
@Override
public Object get(int index) {
return vector[index];
}
/**
* Additional reset work for BytesColumnVector (releasing scratch bytes for by value strings).
*/
@Override
public void reset() {
super.reset();
}
/**
* Set a field by reference.
*
* @param elementNum index within column vector to set
* @param sourceBuf container of source data
* @param start start byte position within source
* @param length length of source byte sequence
*/
public void setRef(int elementNum, byte[] sourceBuf, int start, int length) {
vector[elementNum] = sourceBuf;
}
/**
* Set a field by actually copying in to a local buffer.
* If you must actually copy data in to the array, use this method.
* DO NOT USE this method unless it's not practical to set data by reference with setRef().
* Setting data by reference tends to run a lot faster than copying data in.
*
* @param elementNum index within column vector to set
* @param sourceBuf container of source data
*/
public void setVal(int elementNum, byte[] sourceBuf) {
vector[elementNum] = sourceBuf;
}
/**
* Copy the current object contents into the output. Only copy selected entries,
* as indicated by selectedInUse and the sel array.
*/
@Override
public void copySelected(boolean selectedInUse, int[] sel, int size, ColumnVector output) {
// Output has nulls if and only if input has nulls.
output.noNulls = noNulls;
// Copy data values over
if (selectedInUse) {
for (int j = 0; j < size; j++) {
int i = sel[j];
((BinaryColumnVector) output).setVal(i, vector[i]);
}
} else {
for (int i = 0; i < size; i++) {
((BinaryColumnVector) output).setVal(i, vector[i]);
}
}
// Copy nulls over if needed
super.copySelected(selectedInUse, sel, size, output);
}
@Override
public void setElement(int outElementNum, int inputElementNum, ColumnVector inputVector) {
if (inputVector.noNulls || !inputVector.isNull[inputElementNum]) {
isNull[outElementNum] = false;
Binar
```
<Overlap Ratio: 0.9829059829059829>

---

--- 214 --
Question ID: 333f32ee75f5df978a34cd45852eb5a630f4e564
Original Code:
```
public class CrossoverSelectionTest {

    /**
     * Test that candidates selected by the source {@link Selection} are cross-bred.
     */
    @Test
    public void selectCandiates() {

        final Predicate<String> crossIf = cand -> !cand.equals("selected")
                && !cand.equals(",")
                && !cand.equals("and")
                && !cand.equals("are")
                && !cand.equals("candidates")
                && !cand.equals("crossed");

        final List<Map.Entry<Double, StringCrossBreeding>> candidates = Stream.of
                ("ignore", "the", "dummy", "candidates", ",", "they", "shall", "not", "be", "selected", "and", "are", "not", "crossed")
                .map(string -> new StringCrossBreeding(string, crossIf))
                .map(str -> new AbstractMap.SimpleEntry<>(666d, str))
                .collect(Collectors.toList());

        final Map<String, String> pairing = new LinkedHashMap<>();
        pairing.put("the", "selected");
        pairing.put("they", "are");
        pairing.put("be", "crossed");

        final String expected = "the selected candidates , they are selected and are crossed";
        final String actual = new CrossoverSelection<StringCrossBreeding>(

                (cand, cands) -> Optional.ofNullable(pairing.get(cand.string))
                        .map(mapped -> new StringCrossBreeding(mapped, crossIf))
                .orElse(cand),


                // Source selection
                cands -> cands.stream().map(Map.Entry::getValue)
                        .filter(cand -> !cand.string.equals("ignore"))
                        .filter(cand -> !cand.string.equals("dummy"))
                        .filter(cand -> !cand.string.equals("not"))
                        .filter(cand -> !cand.string.equals("nor"))
                        .filter(cand -> !cand.string.equals("as"))
                        .filter(cand -> !cand.string.equals("shall"))
                        .filter(cand -> !cand.string.equals("be"))
        ).selectCandiates(candidates).map(selected -> selected.string)
                .collect(Collectors.joining(" "));

        assertEquals("Incorrect selection!", expected, actual);
    }

    private final static class StringCrossBreeding implements CrossBreeding<StringCrossBreeding> {

        private final String string;
        private final Predicate<String> crossIf;

        private StringCrossBreeding(String string, Predicate<String> crossIf) {
            this.string = string;
            this.crossIf = crossIf;
        }

        @Override
        public StringCrossBreeding cross(StringCrossBreeding mate) {
            if(!crossIf.test(string)) {
                return new StringCrossBreeding(string, crossIf);
            }
            return new StringCrossBreeding(string + " " + mate.string, crossIf);
        }
    }
}
```


Overlapping Code:
```
ass CrossoverSelectionTest {
/**
* Test that candidates selected by the source {@link Selection} are cross-bred.
*/
@Test
public void selectCandiates() {
final Predicate<String> crossIf = cand -> !cand.equals("selected")
&& !cand.equals(",")
&& !cand.equals("and")
&& !cand.equals("are")
&& !cand.equals("candidates")
&& !cand.equals("crossed");
final List<Map.Entry<Double, StringCrossBreeding>> candidates = Stream.of
("ignore", "the", "dummy", "candidates", ",", "they", "shall", "not", "be", "selected", "and", "are", "not", "crossed")
.map(string -> new StringCrossBreeding(string, crossIf))
.map(str -> new AbstractMap.SimpleEntry<>(666d, str))
.collect(Collectors.toList());
final Map<String, String> pairing = new LinkedHashMap<>();
pairing.put("the", "selected");
pairing.put("they", "are");
pairing.put("be", "crossed");
final String expected = "the selected candidates , they are selected and are crossed";
final String actual = new CrossoverSelection<StringCrossBreeding>(
(cand, cands) -> Optional.ofNullable(pairing.get(cand.string))
.map(mapped -> new StringCrossBreeding(mapped, crossIf))
.orElse(cand),
// Source selection
cands -> cands.stream().map(Map.Entry::getValue)
.filter(cand -> !cand.string.equals("ignore"))
.filter(cand -> !cand.string.equals("dummy"))
.filter(cand -> !cand.string.equals("not"))
.filter(cand -> !cand.string.equals("nor"))
.filter(cand -> !cand.string.equals("as"))
.filter(cand -> !cand.string.equals("shall"))
.filter(cand -> !cand.string.equals("be"))
).selectCandiates(candidates).map(selected -> selected.string)
.collect(Collectors.joining(" "));
assertEquals("Incorrect selection!", expected, actual);
}
private final static class StringCrossBreeding implements CrossBreeding<StringCrossBreeding> {
private final String string;
private final Predicate<String> crossIf;
private StringCrossBreeding(String string, Predicate<String> crossIf) {
this.
```
<Overlap Ratio: 0.987012987012987>

---

--- 215 --
Question ID: ac464fab858ccb9e68428a213ef2d63a96ef44b1
Original Code:
```
public class ProfileActivity extends AppCompatActivity implements HintListener, UserListener, ErrorListener {

    private boolean inProgress;
    private boolean clicked;
    private HintManager hintManager;
    private UserManager userManager;
    private View progressBar;
    private View updateForm;
    private TextInputEditText firstNameField;
    private TextInputEditText lastNameField;
    private TextInputEditText cityField;
    private TextInputEditText phoneField;
    private HintSpinner provinceField;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_profile);

        Toolbar toolbar = findViewById(R.id.profile_toolbar);
        MRKUtil.setToolbar(this, toolbar);

        hintManager = new HintManager(this, this);

        userManager = new UserManager(this, this);

        progressBar = findViewById(R.id.profile_progress);
        updateForm = findViewById(R.id.profile_form);

        firstNameField = findViewById(R.id.profile_name_first);
        lastNameField = findViewById(R.id.profile_name_last);
        cityField = findViewById(R.id.profile_city);
        phoneField = findViewById(R.id.profile_phone);
        phoneField.setOnEditorActionListener((textView, id, keyEvent) -> {
            if (MRKUtil.checkIme(id)) {
                attemptModify();
                return true;
            }
            return false;
        });

        provinceField = findViewById(R.id.profile_province);
        provinceField.setOnItemClickListener((adapterView, view, position, l) -> SpinnerUtil.getClickedItemId(adapterView, position, provinceField));

        Button modifyButton = findViewById(R.id.profile_button_modify);
        modifyButton.setOnClickListener(view -> attemptModify());

        Button passwordButton = findViewById(R.id.profile_button_password);
        passwordButton.setOnClickListener(v -> goToPasswordChange());
    }

    @Override
    protected void onResume() {
        super.onResume();
        clicked = false;
        showProgress(true);
        hintManager.getProvinces(new ErrorListener() {
        });
        setUserData();
    }

    @Override
    protected void onPause() {
        hintManager.cancelCalls();
        userManager.cancelCalls();
        super.onPause();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        MRKUtil.backButtonClicked(this, item);
        return super.onOptionsItemSelected(item);
    }

    private void setUserData() {
        UserData user = SharedPrefUtil.getInstance(this).getUserData();
        firstNameField.setText(user.getFirstName());
        lastNameField.setText(user.getLastName());
        cityField.setText(user.getCity());
        phoneField.setText(user.getPhone());
        provinceField.setText(user.getProvince());
        provinceField.setItemId(user.getPrvId());
    }

    private void showProgress(final boolean show) {
        inProgress = show;
        MRKUtil.showProgressBar(this, updateForm, progressBar, show);
    }

    private void goToPasswordChange() {
        if (!clicked) {
            clicked = true;
            startActivity(new Intent(this, PasswordActivity.class));
        }
    }

    private void attemptModify() {
        if (inProgress) {
            return;
        }

        inProgress = true;

        firstNameField.setError(null);
        cityField.setError(null);
        provinceField.setError(null);
        phoneField.setError(null);

        String firstName = firstNameField.getText().toString();
        String lastName = lastNameField.getText().toString();
        String city = cityField.getText().toString();
        String phone = phoneField.getText().toString();
        Long province = provinceField.getItemId();

        boolean cancel = false;
        View focusView = null;

        if (!ValidUtil.phoneValid(this, phone, phoneField, true)) {
            focusView = phoneField;
            cancel = true;
        }

        if (ValidUtil.spinnerEmpty(this, province, provinceField)) {
            focusView = provinceField;
            cancel = true;
        }

        if (ValidUtil.fieldEmpty(this, city, cityField)) {
            focusView = cityField;
            cancel = true;
        }

        if (ValidUtil.fieldEmpty(this, firstName, firstNameField)) {
            focusView = firstNameField;
            cancel = true;
        }

        if (cancel) {
            focusView.requestFocus();
            inProgress = false;
        } else {
            showProgress(true);
            userManager.updateProfile(new UserData(firstName, lastName, city, province, phone), this);
        }
    }

    @Override
    public void provincesReceived(List<HintData> provinces) {
        SpinnerUtil.setHintAdapter(this, provinceField, provinces);
        showProgress(false);
    }

    @Override
    public void profileUpdated(UserData user) {
        SharedPrefUtil.getInstance(this).saveUserData(user);
        showProgress(false);
        MRKUtil.toast(this, getString(R.string.toast_profile_edited));
    }

    @Override
    public void unhandledError(Activity activity, String error) {
        showProgress(false);
        MRKUtil.connectionProblem(this);
    }

}
```


Overlapping Code:
```
public class ProfileActivity extends AppCompatActivity implements HintListener, UserListener, ErrorListener {
private boolean inProgress;
private boolean clicked;
private HintManager hintManager;
private UserManager userManager;
private View progressBar;
private View updateForm;
private TextInputEditText firstNameField;
private TextInputEditText lastNameField;
private TextInputEditText cityField;
private TextInputEditText phoneField;
private HintSpinner provinceField;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_profile);
Toolbar toolbar = findViewById(R.id.profile_toolbar);
MRKUtil.setToolbar(this, toolbar);
hintManager = new HintManager(this, this);
userManager = new UserManager(this, this);
progressBar = findViewById(R.id.profile_progress);
updateForm = findViewById(R.id.profile_form);
firstNameField = findViewById(R.id.profile_name_first);
lastNameField = findViewById(R.id.profile_name_last);
cityField = findViewById(R.id.profile_city);
phoneField = findViewById(R.id.profile_phone);
phoneField.setOnEditorActionListener((textView, id, keyEvent) -> {
if (MRKUtil.checkIme(id)) {
attemptModify();
return true;
}
return false;
});
provinceField = findViewById(R.id.profile_province);
provinceField.setOnItemClickListener((adapterView, view, position, l) -> SpinnerUtil.getClickedItemId(adapterView, position, provinceField));
Button modifyButton = findViewById(R.id.profile_button_modify);
modifyButton.setOnClickListener(view -> attemptModify());
Button passwordButton = findViewById(R.id.profile_button_password);
passwordButton.setOnClickListener(v -> goToPasswordChange());
}
@Override
protected void onResume() {
super.onResume();
clicked = false;
showProgress(true);
hintManager.getProvinces(new ErrorListener() {
});
setUserData();
}
@Override
protected void onPause() {
hintManager.cancelCalls();
userManager.cancelCalls();
super.onPause();
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
MRKUtil.backButtonClicked(this, item);
return super.onOptionsIte
```
<Overlap Ratio: 1.0>

---

--- 216 --
Question ID: 66518c0cfca862ae80cc8bf538581eda13ca9ea9
Original Code:
```
public class Leetcode0891 {
    public int sumSubseqWidths(int[] A) {
        int mod = 10_0000_0007;
        Arrays.sort(A);
        long res = 0;
        int[] pow = new int[A.length];
        pow[0] = 1;
        for (int i = 1; i < A.length; i++) pow[i] = pow[i - 1] * 2 % mod;
        for (int i = 0; i < A.length; i++) {
            res += 1L * pow[i] * A[i];
            res -= 1L * pow[A.length - 1 - i] * A[i];
            res %= mod;
        }
        return (int) res;
    }
}
```


Overlapping Code:
```
s Leetcode0891 {
public int sumSubseqWidths(int[] A) {
int mod = 10_0000_0007;
Arrays.sort(A);
long res = 0;
int[] pow = new int[A.length];
pow[0] = 1;
for (int i = 1; i < A.length; i++) pow[i] = pow[i - 1] * 2 % mod;
for (int i = 0; i < A.length; i++) {
res += 1L * pow[i] * A[i];
res -= 1L * pow[A.length - 1 - i] * A[i];
res %= mod;
}
return (int)
```
<Overlap Ratio: 0.9459459459459459>

---

--- 217 --
Question ID: ac97ae51da3e689cc2fdfc28f7a78855ba03f940
Original Code:
```
public class EditorSpriterInflater extends InflaterSystem {
	private SpriterCacheModule cache;
	private AssetsLoadingMonitorModule loadingMonitor;

	private ComponentMapper<ProtoVisSpriter> protoCm;
	private ComponentMapper<SpriterProperties> propertiesCm;
	private ComponentMapper<AssetReference> assetCm;

	public EditorSpriterInflater () {
		super(Aspect.all(ProtoVisSpriter.class, AssetReference.class));
	}

	@Override
	public void inserted (int entityId) {
		AssetReference assetRef = assetCm.get(entityId);
		ProtoVisSpriter protoComponent = protoCm.get(entityId);
		SpriterProperties propsComponent = propertiesCm.get(entityId);

		SpriterAsset asset = (SpriterAsset) assetRef.asset;

		try {
			VisSpriter component = cache.createComponent(asset, protoComponent.scale);

			protoComponent.fill(component);
			world.getEntity(entityId).edit().add(component);

			if (propsComponent.previewInEditor == false) component.setAnimationPlaying(false);
		} catch (GdxRuntimeException e) {
			Log.exception(e);
//			world.getEntity(entityId).edit().add(new VisSpriter(null, null, 1));
			loadingMonitor.addFailedResource(assetRef.asset, e);
		}

		protoCm.remove(entityId);
	}
}
```


Overlapping Code:
```
 EditorSpriterInflater extends InflaterSystem {
private SpriterCacheModule cache;
private AssetsLoadingMonitorModule loadingMonitor;
private ComponentMapper<ProtoVisSpriter> protoCm;
private ComponentMapper<SpriterProperties> propertiesCm;
private ComponentMapper<AssetReference> assetCm;
public EditorSpriterInflater () {
super(Aspect.all(ProtoVisSpriter.class, AssetReference.class));
}
@Override
public void inserted (int entityId) {
AssetReference assetRef = assetCm.get(entityId);
ProtoVisSpriter protoComponent = protoCm.get(entityId);
SpriterProperties propsComponent = propertiesCm.get(entityId);
SpriterAsset asset = (SpriterAsset) assetRef.asset;
try {
VisSpriter component = cache.createComponent(asset, protoComponent.scale);
protoComponent.fill(component);
world.getEntity(entityId).edit().add(component);
if (propsComponent.previewInEditor == false) component.setAnimationPlaying(false);
} catch (GdxRuntimeException e) {
Log.exception(e);
// world.getEntity(entityId).edit().add(new VisSpriter(null, null, 1));
loadingMonitor.addFailedResource(assetRef.asset, e);
}
protoCm.remove(enti
```
<Overlap Ratio: 0.9803921568627451>

---

--- 218 --
Question ID: 087d155b749678dc43772e44a9501b8e591257d7
Original Code:
```
public class ImageEntityDefinition {
    private final double myHeight;
    private final double myWidth;
    private final String myImageLocation;
    private final List<ConditionalBehavior> myBehaviors;
    private final String myName;
    private Map<String, String> myVariables = new HashMap<>();
    private boolean stationary = false;

    /**
     * @param name The Name identifying the type of entity.
     * @param height The starting height of entity instances.
     * @param width The starting height of entity instances.
     * @param imageLocation The String with the filepath of this entity's image.
     * @param behaviors The List of conditional behaviors that entity instances will execute.
     */
    public ImageEntityDefinition(String name, double height, double width, String imageLocation, List<ConditionalBehavior> behaviors){
        myName = name;
        myHeight = height;
        myWidth = width;
        myImageLocation = imageLocation;
        myBehaviors = behaviors;
    }

    /**
     * Creates an instance of this Entity type at a specified location.
     * @param xpos The X position of the created instance.
     * @param ypos The Y position of the created instance.
     * @return An instance of this definition's type at the specified location.
     */
    public ImageEntity makeInstanceAt(Double xpos, Double ypos){
        ImageEntity newEntity = new ImageEntity(myName, myImageLocation, xpos, ypos, myWidth, myHeight);
        newEntity.setConditionalBehaviors(myBehaviors);
        newEntity.setVariables(myVariables);
        newEntity.makeNonStationaryProperty(stationary);
        return newEntity;
    }

    /**
     * @return The String representation of this entity type.
     */
    @Override
    public String toString() {
        return myName + ": (" + myHeight + " x " + myWidth + ")";
    }

    /**
     * @return The starting height of entity instances.
     */
    public double getHeight() {
        return myHeight;
    }

    /**
     * @return The starting height of entity instances.
     */
    public double getWidth() {
        return myWidth;
    }

    /**
     * @param entityVariables The starting names and values of variables created instances should have.
     */
    public void setVariables(Map<String, String> entityVariables) { myVariables = entityVariables; }

    /**
     * @param isStationary True if this entity should NOT move onscreen based on camera moves.
     */
    public void setStationary(boolean isStationary){stationary = isStationary;}

    /**
     * @return True if this entity does NOT move onscreen based on camera moves.
     */
    public boolean getStationary() {
        return stationary;
    }
}
```


Overlapping Code:
```
ic class ImageEntityDefinition {
private final double myHeight;
private final double myWidth;
private final String myImageLocation;
private final List<ConditionalBehavior> myBehaviors;
private final String myName;
private Map<String, String> myVariables = new HashMap<>();
private boolean stationary = false;
/**
* @param name The Name identifying the type of entity.
* @param height The starting height of entity instances.
* @param width The starting height of entity instances.
* @param imageLocation The String with the filepath of this entity's image.
* @param behaviors The List of conditional behaviors that entity instances will execute.
*/
public ImageEntityDefinition(String name, double height, double width, String imageLocation, List<ConditionalBehavior> behaviors){
myName = name;
myHeight = height;
myWidth = width;
myImageLocation = imageLocation;
myBehaviors = behaviors;
}
/**
* Creates an instance of this Entity type at a specified location.
* @param xpos The X position of the created instance.
* @param ypos The Y position of the created instance.
* @return An instance of this definition's type at the specified location.
*/
public ImageEntity makeInstanceAt(Double xpos, Double ypos){
ImageEntity newEntity = new ImageEntity(myName, myImageLocation, xpos, ypos, myWidth, myHeight);
newEntity.setConditionalBehaviors(myBehaviors);
newEntity.setVariables(myVariables);
newEntity.makeNonStationaryProperty(stationary);
return newEntity;
}
/**
* @return The String representation of this entity type.
*/
@Override
public String toString() {
return myName + ": (" + myHeight + " x " + myWidth + ")";
}
/**
* @return The starting height of entity instances.
*/
public double getHeight() {
return myHeight;
}
/**
* @return The starting height of entity instances.
*/
public double getWidth() {
return myWidth;
}
/**
* @param entityVariables The starting names and values of variables created instances should have.
*/
public void setVariables(Map<String, String> entityVariables) { myVariables = entityVariables; }
/**
* @param isStationary True if this entity should NOT move onscreen based on camera moves.
*/
public void setStatio
```
<Overlap Ratio: 0.9885057471264368>

---

--- 219 --
Question ID: f6b4a9b676fe80667155d8f146a030d1b66e63d4
Original Code:
```
public class AsyncHistoryJobHandler extends AbstractAsyncHistoryJobHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHistoryJobHandler.class);

    public static final String JOB_TYPE = "async-history";

    protected Map<String, List<HistoryJsonTransformer>> historyJsonTransformers = new HashMap<>();

    @Override
    public String getType() {
        return JOB_TYPE;
    }

    public void initDefaultTransformers() {
        addHistoryJsonTransformer(new ProcessInstanceStartHistoryJsonTransformer());
        addHistoryJsonTransformer(new ProcessInstanceEndHistoryJsonTransformer());
        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryJsonTransformer());
        addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryByProcessDefinitionIdJsonTransformer());
        addHistoryJsonTransformer(new ProcessInstancePropertyChangedHistoryJsonTransformer());
        addHistoryJsonTransformer(new SubProcessInstanceHistoryJsonTransformer());
        addHistoryJsonTransformer(new SetProcessDefinitionHistoryJsonTransformer());

        addHistoryJsonTransformer(new ActivityStartHistoryJsonTransformer());
        addHistoryJsonTransformer(new ActivityEndHistoryJsonTransformer());
        addHistoryJsonTransformer(new ActivityFullHistoryJsonTransformer());

        addHistoryJsonTransformer(new TaskCreatedHistoryJsonTransformer());
        addHistoryJsonTransformer(new TaskEndedHistoryJsonTransformer());

        addHistoryJsonTransformer(new TaskPropertyChangedHistoryJsonTransformer());
        addHistoryJsonTransformer(new TaskAssigneeChangedHistoryJsonTransformer());
        addHistoryJsonTransformer(new TaskOwnerChangedHistoryJsonTransformer());
        
        addHistoryJsonTransformer(new IdentityLinkCreatedHistoryJsonTransformer());
        addHistoryJsonTransformer(new IdentityLinkDeletedHistoryJsonTransformer());
        
        addHistoryJsonTransformer(new VariableCreatedHistoryJsonTransformer());
        addHistoryJsonTransformer(new VariableUpdatedHistoryJsonTransformer());
        addHistoryJsonTransformer(new VariableRemovedHistoryJsonTransformer());
        addHistoryJsonTransformer(new HistoricDetailVariableUpdateHistoryJsonTransformer());
        addHistoryJsonTransformer(new FormPropertiesSubmittedHistoryJsonTransformer());
    }

    public void addHistoryJsonTransformer(HistoryJsonTransformer historyJsonTransformer) {
        String type = historyJsonTransformer.getType();
        if (!historyJsonTransformers.containsKey(type)) {
            historyJsonTransformers.put(type, new ArrayList<HistoryJsonTransformer>());
        }
        historyJsonTransformers.get(historyJsonTransformer.getType()).add(historyJsonTransformer);
    }

    @Override
    protected void processHistoryJson(CommandContext commandContext, HistoryJobEntity job, JsonNode historyNode) {
        
        String type = historyNode.get(HistoryJsonConstants.TYPE).asText();
        ObjectNode historicalJsonData = (ObjectNode) historyNode.get(HistoryJsonConstants.DATA);

        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Handling async history job (id={}, type={})", job.getId(), type);
        }

        List<HistoryJsonTransformer> transformers = historyJsonTransformers.get(type);
        if (transformers != null && !transformers.isEmpty()) {
            for (HistoryJsonTransformer transformer : transformers) {
                if (transformer.isApplicable(historicalJsonData, commandContext)) {
                    transformer.transformJson(job, historicalJsonData, commandContext);

                } else {
                    if (LOGGER.isDebugEnabled()) {
                        LOGGER.debug("Could not handle history job (id={}) for transformer {}. as it is not applicable. Unacquiring. {}", job.getId(), transformer.getType(), historicalJsonData);
                    }
                    throw new AsyncHistoryJobNotApplicableException();

                }
            }
        } else {
            LOGGER.debug("Cannot transform history json: no transformers found for type {}", type);
        }
    }

    public Map<String, List<HistoryJsonTransformer>> getHistoryJsonTransformers() {
        return historyJsonTransformers;
    }

    public void setHistoryJsonTransformers(Map<String, List<HistoryJsonTransformer>> historyJsonTransformers) {
        this.historyJsonTransformers = historyJsonTransformers;
    }

}
```


Overlapping Code:
```
tractAsyncHistoryJobHandler {
private static final Logger LOGGER = LoggerFactory.getLogger(AsyncHistoryJobHandler.class);
public static final String JOB_TYPE = "async-history";
protected Map<String, List<HistoryJsonTransformer>> historyJsonTransformers = new HashMap<>();
@Override
public String getType() {
return JOB_TYPE;
}
public void initDefaultTransformers() {
addHistoryJsonTransformer(new ProcessInstanceStartHistoryJsonTransformer());
addHistoryJsonTransformer(new ProcessInstanceEndHistoryJsonTransformer());
addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryJsonTransformer());
addHistoryJsonTransformer(new ProcessInstanceDeleteHistoryByProcessDefinitionIdJsonTransformer());
addHistoryJsonTransformer(new ProcessInstancePropertyChangedHistoryJsonTransformer());
addHistoryJsonTransformer(new SubProcessInstanceHistoryJsonTransformer());
addHistoryJsonTransformer(new SetProcessDefinitionHistoryJsonTransformer());
addHistoryJsonTransformer(new ActivityStartHistoryJsonTransformer());
addHistoryJsonTransformer(new ActivityEndHistoryJsonTransformer());
addHistoryJsonTransformer(new ActivityFullHistoryJsonTransformer());
addHistoryJsonTransformer(new TaskCreatedHistoryJsonTransformer());
addHistoryJsonTransformer(new TaskEndedHistoryJsonTransformer());
addHistoryJsonTransformer(new TaskPropertyChangedHistoryJsonTransformer());
addHistoryJsonTransformer(new TaskAssigneeChangedHistoryJsonTransformer());
addHistoryJsonTransformer(new TaskOwnerChangedHistoryJsonTransformer());

addHistoryJsonTransformer(new IdentityLinkCreatedHistoryJsonTransformer());
addHistoryJsonTransformer(new IdentityLinkDeletedHistoryJsonTransformer());

addHistoryJsonTransformer(new VariableCreatedHistoryJsonTransformer());
addHistoryJsonTransformer(new VariableUpdatedHistoryJsonTransformer());
addHistoryJsonTransformer(new VariableRemovedHistoryJsonTransformer());
addHistoryJsonTransformer(new HistoricDetailVariableUpdateHistoryJsonTransformer());
addHistoryJsonTransformer(new FormPropertiesSubmittedHistoryJsonTransformer());
}
public void addHistoryJsonTransformer(HistoryJsonTransformer historyJsonTransformer) {
String type = historyJson
```
<Overlap Ratio: 0.9606791778373548>

---

--- 220 --
Question ID: 963ba6a9e64cc1d54e629a947b068148fbc15e85
Original Code:
```
public class FreezeCommand extends ExecutedCommand {
	@Override
	public boolean execute(Player player, String playerName, Command cmd,
			String label, String[] args) {
		if (args.length <= 0) {
			StefsAPI.MessageHandler.buildMessage().addSender(playerName)
					.setMessage("error.notEnoughArguments", AdminEye.messages)
					.changeVariable("syntax", "/freeze <player name>").build();
		} else {
			freezePlayer(player, playerName, args[0]);
		}
		return true;
	}

	public static void freezePlayer(Player player, String playerName,
			String freezePlayerName) {
		ArrayList<Player> freezePlayers = AdminEyeUtils
				.requestPlayers(freezePlayerName);
		if (freezePlayers == null && freezePlayerName != null) {
			StefsAPI.MessageHandler.buildMessage().addSender(playerName)
					.setMessage("error.playerNotFound", AdminEye.messages)
					.changeVariable("playername", freezePlayerName).build();
			return;
		}

		String frozenPlayers = "";

		for (Player freezePlayer : freezePlayers) {
			PlayerFile playerFile = new PlayerFile(freezePlayer.getName());
			playerFile.frozenFroze = true;
			playerFile.save();

			frozenPlayers += "%A" + freezePlayer.getName() + "%N, ";
		}

		frozenPlayers = (freezePlayerName.equals("*") ? frozenPlayers = AdminEye.config
				.getFile().getString("chat.everyone") + "%N, "
				: frozenPlayers);

		AdminEye.broadcastAdminEyeMessage(playerName, "freeze", "freeze",
				"playernames", frozenPlayers);
	}
}
```


Overlapping Code:
```
Command extends ExecutedCommand {
@Override
public boolean execute(Player player, String playerName, Command cmd,
String label, String[] args) {
if (args.length <= 0) {
StefsAPI.MessageHandler.buildMessage().addSender(playerName)
.setMessage("error.notEnoughArguments", AdminEye.messages)
.changeVariable("syntax", "/freeze <player name>").build();
} else {
freezePlayer(player, playerName, args[0]);
}
return true;
}
public static void freezePlayer(Player player, String playerName,
String freezePlayerName) {
ArrayList<Player> freezePlayers = AdminEyeUtils
.requestPlayers(freezePlayerName);
if (freezePlayers == null && freezePlayerName != null) {
StefsAPI.MessageHandler.buildMessage().addSender(playerName)
.setMessage("error.playerNotFound", AdminEye.messages)
.changeVariable("playername", freezePlayerName).build();
return;
}
String frozenPlayers = "";
for (Player freezePlayer : freezePlayers) {
PlayerFile playerFile = new PlayerFile(freezePlayer.getName());
playerFile.frozenFroze = true;
playerFile.save();
frozenPlayers += "%A" + freezePlayer.getName() + "%N, ";
}
frozenPlayers = (freezePlayerName.equals("*") ? frozenPlayers = AdminEye.config
.getFile().getString("chat.everyone") + "%N, "
: frozenPlayers);
AdminEye.broadcastAdminEyeMessage(playerName, "freeze", "freeze",
"playernames", f
```
<Overlap Ratio: 0.9724292101341282>

---

--- 221 --
Question ID: 25b63ad81351c7672f3627e300e0de5dd5a12f22
Original Code:
```
public class RlpEncodeUtilTest {

  private final PublicKey recipient1 =
      PublicKey.from(Base64.getDecoder().decode("arhIcNa+MuYXZabmzJD5B33F3dZgqb0hEbM3FZsylSg="));
  private final PublicKey recipient2 =
      PublicKey.from(Base64.getDecoder().decode("B687sgdtqsem2qEXO8h8UqvW1Mb3yKo7id5hPFLwCmY="));
  private final PublicKey recipient3 =
      PublicKey.from(Base64.getDecoder().decode("HEkOUBXbgGCQ5+WDFUAhucXm/n5zUrfGkgdJY/5lfCs="));

  @Test
  public void bouncyCastleHexDecodeDoesSameAsTuweniFromHexString() {
    byte[] tuweniVal =
        Bytes.fromHexString("5375ba871e5c3d0f1d055b5da0ac02ea035bed38").toArrayUnsafe();

    byte[] myval = Hex.decode("5375ba871e5c3d0f1d055b5da0ac02ea035bed38");

    assertThat(tuweniVal).isEqualTo(myval);
    assertThat(Arrays.equals(tuweniVal, myval)).isTrue();
  }

  @Test
  public void encoodeListDoesSameAsTuweni() {

    final List<PublicKey> members = List.of(recipient1, recipient2, recipient3);

    List<byte[]> sortedKeys =
        members.stream()
            .distinct()
            .map(PublicKey::getKeyBytes)
            .sorted(Comparator.comparing(Arrays::hashCode))
            .collect(Collectors.toList());

    final byte[] rlpEncoded =
        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();

    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));
  }

  @Test
  public void encoodeListDoesSameAsTuweni55Length() {

    final byte[] data = new byte[54];
    Arrays.fill(data, (byte) 1);

    final List<PublicKey> members = List.of(PublicKey.from(data));

    List<byte[]> sortedKeys =
        members.stream()
            .distinct()
            .map(PublicKey::getKeyBytes)
            .sorted(Comparator.comparing(Arrays::hashCode))
            .collect(Collectors.toList());

    final byte[] rlpEncoded =
        RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();

    assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));
  }

  @Test
  public void encodeRLPElementNull() {
    byte[] result = RlpEncodeUtil.encodeRLPElement(null);
    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});
  }

  @Test
  public void encodeRLPElementEmpty() {
    byte[] result = RlpEncodeUtil.encodeRLPElement(new byte[0]);
    assertThat(result).isEqualTo(new byte[] {(byte) 0x80});
  }

  @Test
  public void encodeRLPElementLength55OrUnder() {
    final byte[] data = new byte[54];
    Arrays.fill(data, (byte) 1);
    byte[] result = RlpEncodeUtil.encodeRLPElement(data);
    assertThat(result)
        .isEqualTo(
            new byte[] {
              -74, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
            });
  }

  @Test
  public void encodeRLPElementLengthGreaterThan55() {
    final byte[] data = new byte[300];
    Arrays.fill(data, (byte) 1);

    final byte[] result = RlpEncodeUtil.encodeRLPElement(data);

    final byte[] expected = new byte[303];
    expected[0] = -71;
    expected[1] = 44;
    Arrays.fill(expected, 2, 303, (byte) 1);

    assertThat(result.length).isEqualTo(expected.length);
    assertThat(result).isEqualTo(expected);
  }

  @Test
  public void encodeRLPElementLengthOnlyOne() {
    final byte[] data = new byte[] {9};
    byte[] result = RlpEncodeUtil.encodeRLPElement(data);
    assertThat(result).isEqualTo(new byte[] {9});
  }
}
```


Overlapping Code:
```
tilTest {
private final PublicKey recipient1 =
Pubrivate final PublicKey recipient2 =
PublicKey.frome final PublicKey recipient3 =
PublicKey.from(Base64.getyCastleHexDecodeDoesSameAsTuweniFromHexString() {
byte[] tuweniVal =
Bytes.fromHexString("5375ba871e5c3d0f1d055b5da0ac02ea035bed38").toArrayUnsafe();
byte[] myval = Hex.decode("5375ba871e5c3d0f1d055b5da0ac02ea035bed38");
assertThat(tuweniVal).isEqualTo(myval);
assertThat(Arrays.equals(tuweniVal, myval)).isTrue();
}
@Test
public void encoodeListDoesSameAsTuweni() {
final List<PublicKey> members = List.of(recipient1, recipient2, recipient3);
List<byte[]> sortedKeys =
members.stream()
.distinct()
.map(PublicKey::getKeyBytes)
.sorted(Comparator.comparing(Arrays::hashCode))
.collect(Collectors.toList());
final byte[] rlpEncoded =
RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();
assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));
}
@Test
public void encoodeListDoesSameAsTuweni55Length() {
final byte[] data = new byte[54];
Arrays.fill(data, (byte) 1);
final List<PublicKey> members = List.of(PublicKey.from(data));
List<byte[]> sortedKeys =
members.stream()
.distinct()
.map(PublicKey::getKeyBytes)
.sorted(Comparator.comparing(Arrays::hashCode))
.collect(Collectors.toList());
final byte[] rlpEncoded =
RLP.encodeList(listWriter -> sortedKeys.forEach(listWriter::writeByteArray)).toArray();
assertThat(rlpEncoded).isEqualTo(RlpEncodeUtil.encodeList(sortedKeys));
}
@Test
public void encodeRLPElementNull() {
byte[] result = RlpEncodeUtil.encodeRLPElement(null);
assertThat(result).isEqualTo(new byte[] {(byte) 0x80});
}
@Test
public void encodeRLPElementEmpty() {
byte[] result = RlpEncodeUtil.encodeRLPElement(new byte[0]);
assertThat(result).isEqualTo(new byte[] {(byte) 0x80});
}
@Test
public void encodeRLPElementLength55OrUnder() {
final byte[] data = new byte[54];
Arrays.fill(da
```
<Overlap Ratio: 0.8636157680108745>

---

--- 222 --
Question ID: 99b3c76c2f7d629c97dde8e792ded6dca90385b3
Original Code:
```
public class AtendimentoDAO implements Serializable {

	private static final long serialVersionUID = 1L;

	@Inject
	private EntityManager manager;
	
	@Inject
	private ConvenioDAO conDao;

	public Atendimento porId(Long id) {
		Atendimento atendimento = manager.find(Atendimento.class, id);
		atendimento.getConvenio().setValores(conDao.valores(atendimento.getConvenio()));
		return atendimento;
	}

	@Transacional
	public Atendimento salvar(Atendimento atendimento) {
		/*Atendimento atend = manager.merge(atendimento);
		if(atend.getPagamentos()!=null && atend.getPagamentos().size()!=0) {
			for(Pagamento pag :atend.getPagamentos()) {
				manager.merge(pag);
			}
		}
		return atend;
		*/
		return manager.merge(atendimento);
	}

	@Transacional
	public void remover(Atendimento atendimento) {
		try {

			// TODO verificar se existe consultas com este atendimento

			atendimento = porId(atendimento.getId());
			manager.remove(atendimento);
			manager.flush();
		} catch (PersistenceException e) {
			e.printStackTrace();
		}
	}
	
	@Transacional
	public Atendimento cancelar(Atendimento atendimento){
			if(atendimento.isCancelado()) {
				throw new NegocioException("Este atendimento já está Cancelado!");
			}
			if(atendimento.isFinalizado()) {
				throw new NegocioException("Este atendimento já foi Finalizado!");
			}
			atendimento = this.salvar(atendimento);
			atendimento.setStatus(StatusAtendimento.CANCELADO);
			atendimento = this.salvar(atendimento);
			return atendimento;
		
	}
	
	@Transacional
	public Atendimento finalizar(Atendimento atendimento){
			if(atendimento.isCancelado()) {
				throw new NegocioException("Este atendimento já está Cancelado!");
			}
			if(atendimento.isFinalizado()) {
				throw new NegocioException("Este atendimento já foi Finalizado!");
			}
			
			if(atendimento.isFinalizavel()) {
				atendimento = this.salvar(atendimento);
				atendimento.setStatus(StatusAtendimento.FINALIZADO);
				atendimento = this.salvar(atendimento);
				return atendimento;
			}else
				throw new NegocioException("Este atendimento não pode ser Finalizado!");
	}

	public List<Atendimento> todos() {

		return manager.createQuery("from Atendimento", Atendimento.class).getResultList();
	}
	
	public List<Atendimento> atendimentosDoDia() throws Exception{
		Date d1 = new Date();
		d1.setHours(0);
		d1.setMinutes(0);
		d1.setSeconds(0);
		Date d2 = new Date();
		d2.setHours(23);
		d2.setMinutes(59);
		d2.setSeconds(59);
		
		SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String inicio = format.format(d1);
		String fim = format.format(d2);
		d1 = format.parse(inicio);
		d2 = format.parse(fim);
		
		Query query = manager.createQuery("select a from Atendimento a where a.data >= :d1 and a.data <= :d2", Atendimento.class);
		query.setParameter("d1", d1);
		query.setParameter("d2", d2);
		
		return query.getResultList();
		
	}

}
```


Overlapping Code:
```
 class AtendimentoDAO implements Serializable {
private static final long serialVersionUID = 1L;
@Inject
private EntityManager manager;

@Inject
private ConvenioDAO conDao;
public Atendimento porId(Long id) {
Atendimento atendimento = manager.find(Atendimento.class, id);
atendimento.getConvenio().setValores(conDao.valores(atendimento.getConvenio()));
return atendimento;
}
@Transacional
public Atendimento salvar(Atendimento atendimento) {
/*Atendimento atend = manager.merge(atendimento);
if(atend.getPagamentos()!=null && atend.getPagamentos().size()!=0) {
for(Pagamento pag :atend.getPagamentos()) {
manager.merge(pag);
}
}
return atend;
*/
return manager.merge(atendimento);
}
@Transacional
public void remover(Atendimento atendimento) {
try {
// TODO verificar se existe consultas com este atendimento
atendimento = porId(atendimento.getId());
manager.remove(atendimento);
manager.flush();
} catch (PersistenceException e) {
e.printStackTrace();
}
}

@Transacional
public Atendimento cancelar(Atendimento atendimento){
if(atendimento.isCancelado()) {
throw new NegocioException("Este atendimento já está Cancelado!");
}
if(atendimento.isFinalizado()) {
throw new NegocioException("Este atendimento já foi Finalizado!");
}
atendimento = this.salvar(atendimento);
atendimento.setStatus(StatusAtendimento.CANCELADO);
atendimento = this.salvar(atendimento);
return atendimento;

}

@Transacional
public Atendimento finalizar(Atendimento atendimento){
if(atendimento.isCancelado()) {
throw new NegocioException("Este atendimento já está Cancelado!");
}
if(atendimento.isFinalizado()) {
throw new NegocioException("Este atendimento já foi Finalizado!");
}

if(atendimento.isFinalizavel()) {
atendimento = this.salvar(atendimento);
atendimento.setStatus(StatusAtendimento.FINALIZADO);
atendimento = this.salvar(atendimento);
return atendimento;
}else
throw new NegocioException("Este atendimento não pode ser Finalizado!");
}
public List<Atendimento> todos() {
return manager.createQuery("from Atendimento", Atendimento.class).getResultList();
}

public List<Atendimento> atendimentosDoDia() throws Exception{
Date d1 = new Date();
d1.setHours(0);
d1.setMinutes(0);
d1.setSeconds(0);
Date d2 = new Da
```
<Overlap Ratio: 0.9874326750448833>

---

--- 223 --
Question ID: dd75b83ebcb1dd0814cbb8ae8494d06fe1da4394
Original Code:
```
@Entity
@Table(name = "seed",schema = "joko_security")
public class SeedEntity implements Serializable {

    private static final long serialVersionUID = 1L;


    @GenericGenerator(
            name = "seed_id_seq",
            strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
            parameters = {
                    @org.hibernate.annotations.Parameter(name = "sequence_name", value =
                            "joko_security.seed_id_seq"),
                    @org.hibernate.annotations.Parameter(name = "increment_size", value = "1")
            }
    )
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY, generator = "seed_id_seq")
    @Column(name = "id")
    private Long seedId;

    @Column(name = "user_id")
    private String userId;

    @Column(name = "seed_secret")
    private String seedSecret;

    public Long getSeedId() {
        return seedId;
    }

    public void setSeedId(Long seedId) {
        this.seedId = seedId;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getSeedSecret() {
        return seedSecret;
    }

    public void setSeedSecret(String seedSecret) {
        this.seedSecret = seedSecret;
    }

    @Override
    public String toString() {
        return "SeedEntity{" +
                "seedId='" + seedId + '\'' +
                ", userId='" + userId + '\'' +
                ", seedSecret='" + seedSecret + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;

        if (o == null || getClass() != o.getClass()) return false;

        SeedEntity that = (SeedEntity) o;

        return new EqualsBuilder()
                .append(seedId, that.seedId)
                .append(userId, that.userId)
                .append(seedSecret, that.seedSecret)
                .isEquals();
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder(17, 37)
                .append(seedId)
                .append(userId)
                .append(seedSecret)
                .toHashCode();
    }
}
```


Overlapping Code:
```
(name = "seed",schema = "joko_security")
public class SeedEntity implements Serializable {
private static final long serialVersionUID = 1L;
@GenericGenerator(
name = "seed_id_seq",
strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
parameters = {
@org.hibernate.annotations.Parameter(name = "sequence_name", value =
"joko_security.seed_id_seq"),
@org.hibernate.annotations.Parameter(name = "increment_size", value = "1")
}
)
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY, generator = "seed_id_seq")
@Column(name = "id")
private Long seedId;
@Column(name = "user_id")
private String userId;
@Column(name = "seed_secret")
private String seedSecret;
public Long getSeedId() {
return seedId;
}
public void setSeedId(Long seedId) {
this.seedId = seedId;
}
public String getUserId() {
return userId;
}
public void setUserId(String userId) {
this.userId = userId;
}
public String getSeedSecret() {
return seedSecret;
}
public void setSeedSecret(String seedSecret) {
this.seedSecret = seedSecret;
}
@Override
public String toString() {
return "SeedEntity{" +
"seedId='" + seedId + '\'' +
", userId='" + userId + '\'' +
", seedSecret='" + seedSecret + '\'' +
'}';
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
SeedEntity that = (SeedEntity) o;
return new EqualsBuilder()
.append(seedId, that.seedId)
.append(userId, that.userId)
.append(seedSecret, that.seedSecret)
.isEquals();
}
@Override
public int hashCode() {
return new HashCodeBuilder(17, 37)
.append(seedId)
.append(userId)
.append(seedSecret)
```
<Overlap Ratio: 0.9797917942437232>

---

--- 224 --
Question ID: 02e655cc0cdb7b64e1985ab4e63200e8b36b4491
Original Code:
```
public class BottleRefill {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int num, count;
        while (sc.hasNextInt()) {
            num = sc.nextInt();
            if (num == 0) {
                break;
            }
            count = 0;
            while (num >= 2) {
                count += num / 3;
                num = num / 3 + num % 3;
                if (num == 2) {
                    count++;
                    break;
                }
            }
            System.out.printf("%d ", count);
        }
        sc.close();
    }
}
```


Overlapping Code:
```
ll {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int num, count;
while (sc.hasNextInt()) {
num = sc.nextInt();
if (num == 0) {
break;
}
count = 0;
while (num >= 2) {
count += num / 3;
num = num / 3 + num % 3;
if (num == 2) {
count++;
break;
}
}
System.out.printf("%d ", count);

```
<Overlap Ratio: 0.8863636363636364>

---

--- 225 --
Question ID: 1f894ea3b3200ee91e1e6d51f7b5960f95264c32
Original Code:
```
public class VmtUser2LdapUserAdapterTest {
	@Test
	public void tetl2v(){
		LdapUser user=new LdapUser();
		user.setCstnetId("test@teset.com");
		user.setCurrentDisplay("display");
		user.setDn("dn");
		user.setName("name");
		user.setStatus("refuse");
		user.setUmtId("123");
		VmtUser vmtUser=VmtUser2LdapUserAdapter.convert(user);
		Assert.assertEquals(user.getCstnetId(), vmtUser.getCstnetId());
		Assert.assertEquals(user.getCurrentDisplay(), vmtUser.getCurrentDisplay());
		Assert.assertEquals(user.getDn(), vmtUser.getDn());
		Assert.assertEquals(user.getName(), vmtUser.getName());
		Assert.assertEquals(user.getStatus(), vmtUser.getStatus());
		Assert.assertEquals(user.getUmtId(), vmtUser.getUmtId());
	}
	@Test
	public void testbatch(){
		List<LdapUser> users=null;
		Assert.assertTrue(CommonUtils.isNull(users));
		users=new ArrayList<>();
		Assert.assertTrue(CommonUtils.isNull(users));
		LdapUser user1=new LdapUser();
		user1.setCstnetId("test@teset.com");
		user1.setCurrentDisplay("display");
		user1.setDn("dn");
		user1.setName("name");
		user1.setStatus("refuse");
		user1.setUmtId("123");
		
		LdapUser user2=new LdapUser();
		user2.setCstnetId("test@teset.com");
		user2.setCurrentDisplay("display");
		user2.setDn("dn");
		user2.setName("name");
		user2.setStatus("refuse");
		user2.setUmtId("123");
		users.add(user1);
		users.add(user2);
		List<VmtUser> vmtUsers=VmtUser2LdapUserAdapter.convert(users);
		Assert.assertEquals(2, vmtUsers.size());
		VmtUser vmtUser1=vmtUsers.get(0);
		VmtUser vmtUser2=vmtUsers.get(1);
		Assert.assertEquals(user1.getCstnetId(), vmtUser1.getCstnetId());
		Assert.assertEquals(user1.getCurrentDisplay(), vmtUser1.getCurrentDisplay());
		Assert.assertEquals(user1.getDn(), vmtUser1.getDn());
		Assert.assertEquals(user1.getName(), vmtUser1.getName());
		Assert.assertEquals(user1.getStatus(), vmtUser1.getStatus());
		Assert.assertEquals(user1.getUmtId(), vmtUser1.getUmtId());
		
		Assert.assertEquals(user2.getCstnetId(), vmtUser2.getCstnetId());
		Assert.assertEquals(user2.getCurrentDisplay(), vmtUser2.getCurrentDisplay());
		Assert.assertEquals(user2.getDn(), vmtUser2.getDn());
		Assert.assertEquals(user2.getName(), vmtUser2.getName());
		Assert.assertEquals(user2.getStatus(), vmtUser2.getStatus());
		Assert.assertEquals(user2.getUmtId(), vmtUser2.getUmtId());
		
		
	}

}
```


Overlapping Code:
```
UserAdapterTest {
@Test
public void tetl2v(){
Ldap("dn");
user.setName("name");
user.setStatus("refuse");
user.setUmtId("123");
VmtUser vmtUser=VmtUser2LdapUserAdapter.convert(user);
Assert.assertEquals(user.getCstnetId(), vmtUser.getCstnetId());
Assert.assertEquals(user.getCurrentDisplay(), vmtUser.getCurrentDisplay());
Assert.assertEquals(user.getDn(), vmtUser.getDn());
Assert.assertEquals(user.getName(), vmtUser.getName());
Assert.assertEquals(user.getStatus(), vmtUser.getStatus());
Assert.assertEquals(user.getUmtId(), vmtUser.getUmtId());
}
@Test
public void testbatch(){
List<LdapUser> users=null;
Assert.assertTrue(CommonUtils.isNull(users));
users=new ArrayList<>();
Assert.assertTrue(CommonUtils.isNull(users));
LdapUser user1=new LdapUentDisplay("display");
user1.setDn("dn");
user1.setName("name");
user1.setStatus("refuse");
user1.setUmtId("123");

LdapUser user2=new LdapUser();
use("display");
user2.setDn("dn");
user2.setName("name");
user2.setStatus("refuse");
user2.setUmtId("123");
users.add(user1);
users.add(user2);
List<VmtUser> vmtUsers=VmtUser2LdapUserAdapter.convert(users);
Assert.assertEquals(2, vmtUsers.size());
VmtUser vmtUser1=vmtUsers.get(0);
VmtUser vmtUser2=vmtUsers.get(1);
Assert.assertEquals(user1.getCstnetId(), vmtUser1.getCstnetId());
Assert.assertEquals(user1.getCurrentDisplay(), vmtUser1.getCurrentDisplay());
Assert.assertEquals(user1.getDn(), vmtUser1.getDn());
Assert.assertEquals(user1.getName(), vmtUser1.getName());
Assert.assertEquals(user1.getStatus(), vmtUser1.getStatus());
Assert.assertEquals(user1.getUmtId(), vmtUser1.getUmtId());

Assert.assertEquals(user2.getCstnetId(), vmtUser2.getCstnetId());
Assert.assertEquals(user2.getCurrentDisplay(), vmtUser2.getCurrentDisplay());
Assert.assertEquals(user2.getDn(), vmtUser2.getDn());
Assert.assertEquals(user2.getName(), vmtUser2.getName());
Assert.assertEquals(user2.getStatus(), vmtUser2.getStatus());
Assert.assertEquals(user2.getUmtId(), vm
```
<Overlap Ratio: 0.8779828905898244>

---

--- 226 --
Question ID: 2d11fce266e2875c55bdd4c93208ce4a8221c3d9
Original Code:
```
public class WithinFunctionTest extends AbstractScalarFunctionsTest {

    private static final String FNAME = WithinFunction.NAME;

    @Test
    public void testEvaluateWithNullArgs() throws Exception {
        assertEvaluate("within(geopoint, geoshape)", null, Literal.newGeoPoint(null), Literal.newGeoShape("POINT (10 10)"));
        assertEvaluate("within(geopoint, geoshape)", null, Literal.newGeoPoint("POINT (10 10)"), Literal.newGeoShape(null));
    }

    @Test
    public void testEvaluatePointLiteralWithinPolygonLiteral() {
        assertEvaluate("within(geopoint, geoshape)", true,
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POINT (10 10)")),
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
        );
    }

    @Test
    public void testEvaluateShapeWithinShape() {
        assertEvaluate("within(geoshape, geoshape)", true,
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("LINESTRING (8 15, 13 24)")),
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
        );
    }

    @Test
    public void testEvaluateShapeIsNotWithinShape() {
        assertEvaluate("within(geoshape, geoshape)", false,
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("LINESTRING (8 15, 40 74)")),
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
        );
    }

    @Test
    public void testEvaluateObjectWithinShape() {
        assertEvaluate("within(geopoint, geoshape)", true,
            Literal.of(ImmutableMap.<String, Object>of("type", "Point", "coordinates", new double[]{10.0, 10.0})),
            Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
        );
    }

    @Test
    public void testNormalizeWithReferenceAndLiteral() throws Exception {
        Symbol normalizedSymbol = normalize(FNAME, createReference("foo", DataTypes.GEO_POINT),
            Literal.newGeoShape("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"));
        assertThat(normalizedSymbol, isFunction(FNAME));
    }

    @Test
    public void testNormalizeWithTwoStringLiterals() throws Exception {
        assertNormalize("within('POINT (10 10)', 'POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))')", isLiteral(true));
    }

    @Test
    public void testNormalizeWithStringLiteralAndReference() throws Exception {
        Symbol normalized = normalize(FNAME,
            createReference("point", DataTypes.GEO_POINT),
            Literal.of("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"));
        assertThat(normalized, instanceOf(Function.class));
        Function function = (Function) normalized;
        Symbol symbol = function.arguments().get(1);
        assertThat(symbol.valueType(), equalTo(DataTypes.GEO_SHAPE));
    }

    @Test
    public void testNormalizeWithFirstArgAsStringReference() throws Exception {
        Symbol normalized = normalize(FNAME,
            createReference("location", DataTypes.STRING),
            Literal.newGeoShape("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"));
        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));
    }

    @Test
    public void testNormalizeWithSecondArgAsStringReference() throws Exception {
        Symbol normalized = normalize(FNAME,
            Literal.newGeoPoint(new Double[]{0.0d, 0.0d}),
            createReference("location", DataTypes.STRING));
        assertThat(normalized.symbolType(), is(SymbolType.FUNCTION));
        assertThat(((Function) normalized).info().ident().name(), is(WithinFunction.NAME));
    }

    @Test
    public void testFirstArgumentWithInvalidType() throws Exception {
        expectedException.expect(ConversionException.class);
        getFunction(FNAME, DataTypes.LONG, DataTypes.GEO_POINT);
    }

    @Test
    public void testSecondArgumentWithInvalidType() throws Exception {
        expectedException.expect(ConversionException.class);
        getFunction(FNAME, DataTypes.GEO_POINT, DataTypes.LONG);
    }

    @Test
    public void testNormalizeFromObject() throws Exception {
        Symbol normalized = normalize(FNAME,
            Literal.of("POINT (1.0 0.0)"),
            Literal.of(ImmutableMap.<String, Object>of("type", "Point", "coordinates", new double[]{0.0, 1.0})));
        assertThat(normalized.symbolType(), is(SymbolType.LITERAL));
        assertThat(((Literal) normalized).value(), is(Boolean.FALSE));
    }
}
```


Overlapping Code:
```
ic class WithinFunctionTest extends AbstractScalarFunctionsTest {
private static final String FNAME = WithinFunction.NAME;
@Test
public void testEvaluateWithNullArgs() throws Exception {
assertEvaluate("within(geopoint, geoshape)", null, Literal.newGeoPoint(null), Literal.newGeoShape("POINT (10 10)"));
assertEvaluate("within(geopoint, geoshape)", null, Literal.newGeoPoint("POINT (10 10)"), Literal.newGeoShape(null));
}
@Test
public void testEvaluatePointLiteralWithinPolygonLiteral() {
assertEvaluate("within(geopoint, geoshape)", true,
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POINT (10 10)")),
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
);
}
@Test
public void testEvaluateShapeWithinShape() {
assertEvaluate("within(geoshape, geoshape)", true,
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("LINESTRING (8 15, 13 24)")),
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
);
}
@Test
public void testEvaluateShapeIsNotWithinShape() {
assertEvaluate("within(geoshape, geoshape)", false,
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("LINESTRING (8 15, 40 74)")),
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
);
}
@Test
public void testEvaluateObjectWithinShape() {
assertEvaluate("within(geopoint, geoshape)", true,
Literal.of(ImmutableMap.<String, Object>of("type", "Point", "coordinates", new double[]{10.0, 10.0})),
Literal.of(DataTypes.GEO_SHAPE, DataTypes.GEO_SHAPE.value("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"))
);
}
@Test
public void testNormalizeWithReferenceAndLiteral() throws Exception {
Symbol normalizedSymbol = normalize(FNAME, createReference("foo", DataTypes.GEO_POINT),
Literal.newGeoShape("POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))"));
assertThat(normalizedSymbol, isFunction(FNAME));
}
@Test
public void testNormalizeWithTwoStringLiterals() throws Exception {
assertNormalize("within('POINT (10 10)', 'POLYGON ((5 5, 20 5, 30 30, 5 30, 5 5))')", isLiteral(true));
}
@Test
public void testNormalizeWithStringLiteralAndReference
```
<Overlap Ratio: 0.9894543787253554>

---

--- 227 --
Question ID: ca4a6b806eddc887f25f11f5f5d9a9d74a97a738
Original Code:
```
public class EdCompInstGMOSNorth extends EdCompInstGMOS<InstGmosNorth> {
    public EdCompInstGMOSNorth() {
        super();
    }

    @Override protected void init() {
        super.init();

        // Add the property change listeners defined in InstGmosCommon.
        final InstGmosNorth inst = getDataObject();
        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);
        inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);
    }

    @Override protected void cleanup() {
        super.cleanup();

        final InstGmosNorth inst = getDataObject();
        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);
        inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);
    }
}
```


Overlapping Code:
```
 EdCompInstGMOSNorth extends EdCompInstGMOS<InstGmosNorth> {
public EdCompInstGMOSNorth() {
super();
}
@Override protected void init() {
super.init();
// Add the property change listeners defined in InstGmosCommon.
final InstGmosNorth inst = getDataObject();
inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);
inst.addPropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);
}
@Override protected void cleanup() {
super.cleanup();
final InstGmosNorth inst = getDataObject();
inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateParallacticAnglePCL);
inst.removePropertyChangeListener(InstGmosNorth.FPUNIT_PROP.getName(), updateUnboundedAnglePCL);
}

```
<Overlap Ratio: 0.9828947368421053>

---

--- 228 --
Question ID: 22048f07e862ab21701c1f56ab4f445e44fe7997
Original Code:
```
public class RichLocalNotificationDismissReceiver extends BroadcastReceiver {

  private RichLocalNotificationManager richLocalNotificationManager;

  @Override
  public void onReceive(Context context, Intent intent) {
    Log.i("RLN", "Dimissing local notification");
    JSObject dataJson = getRichLocalNotificationManagerInstance(context).handleNotificationActionPerformed(intent);
    RichLocalNotifications.sendNotificationActionPerformed(dataJson);
  }

  private RichLocalNotificationManager getRichLocalNotificationManagerInstance(Context context) {
    if (richLocalNotificationManager == null) {
      this.richLocalNotificationManager = new RichLocalNotificationManager(context);
    }
    return this.richLocalNotificationManager;
  }

}
```


Overlapping Code:
```
chLocalNotificationDismissReceiver extends BroadcastReceiver {
private RichLocalNotificationManager richLocalNotificationManager;
@Override
public void onReceive(Context context, Intent intent) {
Log.i("RLN", "Dimissing local notification");
JSObject dataJson = getRichLocalNotificationManagerInstance(context).handleNotificationActionPerformed(intent);
RichLocalNotifications.sendNotificationActionPerformed(dataJson);
}
private RichLocalNotificationManager getRichLocalNotificationManagerInstance(Context context) {
if (richLocalNotificationManager == null) {
this.richLocalNotificationManager = new RichLocalNotificationManager(context);
}
return this.richLocalNotificationManager;
}
```
<Overlap Ratio: 0.9758179231863442>

---

--- 229 --
Question ID: 797553ef390bc60423b70777912447dc3d9b5a9e
Original Code:
```
public class RecipeBuilder {

    public static final String DEFAULT_NAME = "Ham Sandwich";
    public static final List<Ingredient> DEFAULT_INGREDIENT_LIST = List.of(new Ingredient("bread, 2 slices"),
            new Ingredient("ham, 1 slice"));
    public static final List<Instruction> DEFAULT_INSTRUCTION_LIST = List.of(
            new Instruction("place ham between " + "slices of bread"), new Instruction("eat"));
    public static final Photograph DEFAULT_PHOTOGRAPH = Photograph.PLACEHOLDER_PHOTOGRAPH;
    public static final String DEFAULT_CALORIE = "300";
    public static final int DEFAULT_SERVING = 1;
    public static final int DEFAULT_RATING = 3;
    public static final int DEFAULT_DIFFICULTY = 3;


    private Name name;
    private IngredientList ingredients;
    private InstructionList instructions;
    private Photograph photograph;
    private Calorie calorie;
    private Serving serving;
    private Rating rating;
    private Difficulty difficulty;
    private Time timing;
    private Set<Tag> tags;

    private Recipe recipe;

    public RecipeBuilder() {
        name = new Name(DEFAULT_NAME);
        ingredients = new IngredientList(DEFAULT_INGREDIENT_LIST);
        instructions = new InstructionList(DEFAULT_INSTRUCTION_LIST);
        photograph = DEFAULT_PHOTOGRAPH;
        calorie = new Calorie(DEFAULT_CALORIE);
        serving = new Serving(DEFAULT_SERVING);
        rating = new Rating(DEFAULT_RATING);
        difficulty = new Difficulty(DEFAULT_DIFFICULTY);
        tags = new HashSet<>();
    }

    /**
     * Initializes the RecipeBuilder with the data of {@code recipeToCopy}.
     */
    public RecipeBuilder(Recipe recipeToCopy) {
        name = recipeToCopy.getName();
        ingredients = recipeToCopy.getIngredients();
        instructions = recipeToCopy.getInstructions();
        photograph = recipeToCopy.getPhotograph();
        calorie = recipeToCopy.getCalorie();
        serving = recipeToCopy.getServing();
        rating = recipeToCopy.getRating();
        difficulty = recipeToCopy.getDifficulty();
        tags = new HashSet<>(recipeToCopy.getTags());
    }

    /**
     * Sets the {@code Name} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withName(String name) {
        this.name = new Name(name);
        return this;
    }

    /**
     * Parses the {@code tags} into a {@code Set<Tag>} and set it to the {@code Recipe} that we are building.
     */
    public RecipeBuilder withTags(String... tags) {
        this.tags = SampleDataUtil.getTagSet(tags);
        return this;
    }

    /**
     * Sets the {@code IngredientList} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withIngredients(String ingredients) {
        List<Ingredient> ingredientList =
                Stream.of(ingredients.trim().split(";")).map(String::trim).map(Ingredient::new)
                        .collect(Collectors.toList());
        this.ingredients = new IngredientList(ingredientList);
        return this;
    }

    /**
     * Sets the {@code InstructionList} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withInstructions(String instructions) {
        List<Instruction> instructionList = (Stream.of(instructions.trim().split(";")).map(String::trim)
                .map(Instruction::new).collect(Collectors.toList()));
        this.instructions = new InstructionList(instructionList);
        return this;
    }

    /**
     * Sets the {@code Photograph} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withPhotograph(String photograph) {
        Photograph ph;
        try {
            ph = new Photograph(photograph);
        } catch (IOException e) {
            return this;
        }
        this.photograph = ph;
        return this;
    }

    /**
     * Sets the {@code Calorie} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withCalorie(String calorie) {
        this.calorie = new Calorie(calorie);
        return this;
    }

    /**
     * Sets the {@code Serving} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withServing(int serving) {
        this.serving = new Serving(serving);
        return this;
    }

    /**
     * Sets the {@code Rating} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withRating(int rating) {
        this.rating = new Rating(rating);
        return this;
    }

    /**
     * Sets the {@code Difficulty} of the {@code Recipe} that we are building.
     */
    public RecipeBuilder withDifficulty(int difficulty) {
        this.difficulty = new Difficulty(difficulty);
        return this;
    }

    /**
     * builds a Recipe.
     * @return the Recipe.
     */
    public Recipe build() {
        Recipe toReturn = new Recipe(name, ingredients, instructions, photograph, calorie, serving, rating, difficulty,
                tags);
        return toReturn;
    }

    /**
     * adds a time to the recipe.
     * @param h the hour component of the time.
     * @param m the minute component of the time.
     * @param s the second component of the time.
     * @return
     */
    public RecipeBuilder addTime(int h, int m, int s) {
        this.timing = new Time(h, m, s);
        return this;
    }
}
```


Overlapping Code:
```
c class RecipeBuilder {
public static final String DEFAULT_NAME = "Ham Sandwich";
public static final List<Ingredient> DEFAULT_INGREDIENT_LIST = List.of(new Ingredient("bread, 2 slices"),
new Ingredient("ham, 1 slice"));
public static final List<Instruction> DEFAULT_INSTRUCTION_LIST = List.of(
new Instruction("place ham between " + "slices of bread"), new Instruction("eat"));
public static final Photograph DEFAULT_PHOTOGRAPH = Photograph.PLACEHOLDER_PHOTOGRAPH;
public static final String DEFAULT_CALORIE = "300";
public static final int DEFAULT_SERVING = 1;
public static final int DEFAULT_RATING = 3;
public static final int DEFAULT_DIFFICULTY = 3;
private Name name;
private IngredientList ingredients;
private InstructionList instructions;
private Photograph photograph;
private Calorie calorie;
private Serving serving;
private Rating rating;
private Difficulty difficulty;
private Time timing;
private Set<Tag> tags;
private Recipe recipe;
public RecipeBuilder() {
name = new Name(DEFAULT_NAME);
ingredients = new IngredientList(DEFAULT_INGREDIENT_LIST);
instructions = new InstructionList(DEFAULT_INSTRUCTION_LIST);
photograph = DEFAULT_PHOTOGRAPH;
calorie = new Calorie(DEFAULT_CALORIE);
serving = new Serving(DEFAULT_SERVING);
rating = new Rating(DEFAULT_RATING);
difficulty = new Difficulty(DEFAULT_DIFFICULTY);
tags = new HashSet<>();
}
/**
* Initializes the RecipeBuilder with the data of {@code recipeToCopy}.
*/
public RecipeBuilder(Recipe recipeToCopy) {
name = recipeToCopy.getName();
ingredients = recipeToCopy.getIngredients();
instructions = recipeToCopy.getInstructions();
photograph = recipeToCopy.getPhotograph();
calorie = recipeToCopy.getCalorie();
serving = recipeToCopy.getServing();
rating = recipeToCopy.getRating();
difficulty = recipeToCopy.getDifficulty();
tags = new HashSet<>(recipeToCopy.getTags());
}
/**
* Sets the {@code Name} of the {@code Recipe} that we are building.
*/
public RecipeBuilder withName(String name) {
this.name = new Name(name);
return this;
}
/**
* Parses the {@code tags} into a {@code Set<Tag>} and set it to the {@code Recipe} that we are building.
*/
public RecipeBuilder withTags(String.
```
<Overlap Ratio: 0.995835261453031>

---

--- 230 --
Question ID: 72588fc09bc511547775227caac4fef7870f5618
Original Code:
```
public class MergeThenTransform extends KeysetProcessor {
  
  /** constructors ============================================================ */
  
  /** Default constructor */
  public MergeThenTransform() {}
  
  /** methods ================================================================= */
    
  /**
   * Appends an XML attribute value.
   * @param xml the XML being constructed
   * @param name the attribute name
   * @param value the attribute value
   */
  protected StringBuilder appendXmlAttribute(StringBuilder xml, 
                                             String name, 
                                             String value) {
    String s = Val.chkStr(Val.escapeXml(value));
    xml.append(" ").append(name).append("=\"").append(s).append("\"");
    return xml;
  }
  
  /**
   * Appends an XML property element.
   * <br/>&lt;property name="[name]"/&gt;[value]&lt;/property&gt;
   * @param xml the XML being constructed
   * @param name the property name
   * @param value the property value
   */
  protected StringBuilder appendPropertyElement(StringBuilder xml, 
                                                String nl,
                                                String name, 
                                                String value) {
    String s = Val.chkStr(Val.escapeXml(value));
    xml.append(nl).append("<property");
    xml.append(" ").append("name").append("=\"").append(name).append("\">");
    xml.append(s).append("</property>");
    return xml;
  }
  
  /**
   * Appends an XML property element based upon a gpt.xml 
   * configuration parameter.
   * <br/>&lt;property name="[name]"/&gt;[value]&lt;/property&gt;
   * @param cfgParams the configuration parameters
   * @param xml the XML being constructed
   * @param nl the new line prefix
   * @param cfgKey the configuration parameter key
   */
  protected StringBuilder appendPropertyElement(StringAttributeMap cfgParams, 
                                                StringBuilder xml, 
                                                String nl, 
                                                String cfgKey) {
    if (cfgKey.indexOf("*") == -1) {
      this.appendPropertyElement(xml,nl,cfgKey,cfgParams.getValue(cfgKey));
    } else if (cfgKey.equals("*")) {
      for (StringAttribute attr: cfgParams.values()) {
        String sKey = attr.getKey();
        this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));
      }
    } else {
      String[] parts = cfgKey.split("\\*");
      for (StringAttribute attr: cfgParams.values()) {
        String sKey = attr.getKey();
        boolean bMatches = false;
        for (String sPart: parts) {
          int nIdx = sKey.indexOf(sPart);
          if (nIdx == -1) {
            bMatches = false;
            break;
          } else {
            bMatches = true;
            sKey = sKey.substring(nIdx+sPart.length());
          }
        }
        if (bMatches) {
          sKey = attr.getKey();
          this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));
        }
      } 
    }
    return xml;
  }
    
  /**
   * Processes the HTTP request.
   * @param request the HTTP request
   * @param response HTTP response
   * @param context request context
   * @throws Exception if an exception occurs
   */
  @Override
  public void execute(HttpServletRequest request,
                      HttpServletResponse response, 
                      RequestContext context) 
    throws Exception {
    String[] keys = this.readKeys(request,context,true);
    
    //String sXsltPath = Val.chkStr(request.getParameter("xslt"));
    //String sMimeType = Val.chkStr(request.getParameter("mimeType"));
    //String sContentDisposition = Val.chkStr(request.getParameter("contentDisposition"));
    
    StringAttributeMap cfgParams = context.getCatalogConfiguration().getParameters();    
    String sCfgPfx = "catalog.cart.processor.mergeThenTransform";
    String sXsltPath = Val.chkStr(
        cfgParams.getValue(sCfgPfx+".xslt"));
    String sProperties = Val.chkStr(
        cfgParams.getValue(sCfgPfx+".xslt.properties"));
    String sMimeType = Val.chkStr(
        cfgParams.getValue(sCfgPfx+".response.mimeType"));
    String sContentDisposition = Val.chkStr(
        cfgParams.getValue(sCfgPfx+".response.contentDisposition"));
    
    if ((keys.length > 0) && (sXsltPath.length() > 0)) {
      XsltTemplate template = this.getCompiledTemplate(sXsltPath);
      ServletOutputStream out = response.getOutputStream(); 
      
      if (sProperties.length() == 0) {
        sProperties = "catalog.cart.*";
      }
      
      if (sMimeType.length() == 0) {
        sMimeType = "text/plain";
      }
      response.setContentType(sMimeType+";charset=UTF-8"); 
      if (sContentDisposition.length() > 0) {
        response.addHeader("Content-Disposition",sContentDisposition);
      }
      
      String nl = "\r\n";
      try {   
        StringBuilder sbXmls = new StringBuilder();
        for (String sKey: keys) {
          String sXml = Val.chkStr(this.readXml(request,context,sKey));
          if (sXml.startsWith("<?xml ")) {
            sXml = Val.chkStr(sXml.substring(sXml.indexOf("?>") + 2));
          }
          if (sXml.length() > 0) {
            sbXmls.append(nl).append(sXml);
          }
        }
        
        if (sbXmls.length() > 0) {
          StringBuilder sb = new StringBuilder();
          sb.append("<collection>");
          
          // append client properties
          sb.append(nl).append("<client");
          appendXmlAttribute(sb,"session-id",request.getSession(true).getId());
          appendXmlAttribute(sb,"session-rid",request.getRequestedSessionId());
          appendXmlAttribute(sb,"remote-ip",request.getRemoteAddr());
          appendXmlAttribute(sb,"remote-host",request.getRemoteHost());
          appendXmlAttribute(sb,"remote-user",context.getUser().getName());
          appendXmlAttribute(sb,"user-agent",request.getHeader("User-Agent"));
          sb.append("/>");
                      
          // append configuration properties
          sb.append(nl).append("<properties>");
          this.appendPropertyElement(cfgParams,sb,nl,sProperties);
          sb.append(nl).append("</properties>");
          
          // append the XML records
          sb.append(nl).append("<records>");
          sb.append(sbXmls);
          sb.append(nl).append("</records>");
          sb.append(nl).append("</collection>");
          
          // transform then return the response
          boolean bTransform = true;
          if (bTransform) {
            String sResult = Val.chkStr(template.transform(sb.toString()));
            if (sResult.length() > 0) {
              byte[] bytes = sResult.getBytes("UTF-8");
              out.write(bytes);
              out.flush();
            }
          } else {
            byte[] bytes = sb.toString().getBytes("UTF-8");
            out.write(bytes);
            out.flush();
          }
        }
      } finally {
        out.flush();
        out.close();
      }
    }
  }

}
```


Overlapping Code:
```
henTransform extends KeysetProcessor {

/** constructors ============================================================ */

/** Default constructor */
public MergeThenTransform() {}

/** methods ================================================================= */

/**
* Appends an XML attribute value.
* @param xml the XML being constructed
* @param name the attribute name
* @param value the attribute value
*/
protected StringBuilder appendXmlAttribute(StringBuilder xml, 
String name, 
String value) {
String s = Val.chkStr(Val.escapeXml(value));
xml.append(" ").append(name).append("=\"").append(s).append("\"");
return xml;
}

/**
* Appends an XML property element.
* <br/>&lt;property name="[name]"/&gt;[value]&lt;/property&gt;
* @param xml the XML being constructed
* @param name the property name
* @param value the property value
*/
protected StringBuilder appendPropertyElement(StringBuilder xml, 
String nl,
String name, 
String value) {
String s = Val.chkStr(Val.escapeXml(value));
xml.append(nl).append("<property");
xml.append(" ").append("name").append("=\"").append(name).append("\">");
xml.append(s).append("</property>");
return xml;
}

/**
* Appends an XML property element based upon a gpt.xml 
* configuration parameter.
* <br/>&lt;property name="[name]"/&gt;[value]&lt;/property&gt;
* @param cfgParams the configuration parameters
* @param xml the XML being constructed
* @param nl the new line prefix
* @param cfgKey the configuration parameter key
*/
protected StringBuilder appendPropertyElement(StringAttributeMap cfgParams, 
StringBuilder xml, 
String nl, 
String cfgKey) {
if (cfgKey.indexOf("*") == -1) {
this.appendPropertyElement(xml,nl,cfgKey,cfgParams.getValue(cfgKey));
} else if (cfgKey.equals("*")) {
for (StringAttribute attr: cfgParams.values()) {
String sKey = attr.getKey();
this.appendPropertyElement(xml,nl,sKey,cfgParams.getValue(sKey));
}
} else {
String[] 
```
<Overlap Ratio: 0.9783728115345005>

---

--- 231 --
Question ID: d2ec30e6e006634cd5f430d21eb7bb03fb67ec20
Original Code:
```
public class LoopMoveList {
    public static void main(String[] args) {
        List list = Arrays.asList("one Two three Four five six".split(" "));
        System.out.println("List :" + list);
        Collections.rotate(list, 3);
        System.out.println("rotate: " + list);
    }
}
```


Overlapping Code:
```
 LoopMoveList {
public static void main(String[] args) {
List list = Arrays.asList("one Two three Four five six".split(" "));
System.out.println("List :" + list);
Collections.rotate(list, 3);
System.out.println("rotate:
```
<Overlap Ratio: 0.8902439024390244>

---

--- 232 --
Question ID: 0e07abac520ed61d2a2bb3517cfcb92874d1b226
Original Code:
```
public class DeleteCommentHandlerTest {

	Context createContext(String apiCall) {
		TestContext ctx = new TestContext();
		ctx.setFunctionName(apiCall);
		return ctx;
	}
	
	void testDelete(String incoming, int outgoing, String errMes, int numComments) {
		DeleteCommentHandler handler = new DeleteCommentHandler();
		DeleteCommentRequest req = new Gson().fromJson(incoming, DeleteCommentRequest.class);
		DeleteCommentResponse response = handler.handleRequest(req, createContext("deleteComment"));
		
		assertEquals(outgoing, response.getStatusCode());
		assertEquals(errMes, response.getStatusMessage());
		
		GetSnipCommentsHandler handler2 = new GetSnipCommentsHandler();
		GetSnipCommentsRequest req2 = new Gson().fromJson("{\"id\": \"" + req.snippetID +"\"}", GetSnipCommentsRequest.class);
		GetSnipCommentsResponse response2 = handler2.handleRequest(req2, createContext("getComments"));
		
		assertEquals(numComments, response2.getComments().size());
	}
	
	@Test
	public void testDeleteComment() throws Exception {
		SnippetDAO snipdao = new SnippetDAO();
		Snippet snip = new Snippet(snipdao.getAllSnippets(), "password");
		snipdao.addSnippet(snip);

		CommentDAO commdao = new CommentDAO();
		Comment comment = new Comment(commdao.getAllComments(), snip.getID(), 1, 1, "test");
		commdao.addComment(comment);
		
		String incoming = "{"
							+ "\"snippetID\": \"" + snip.getID() + "\","
							+ "\"id\": \"" + comment.getID() + "\","
							+ "\"password\": \"" + snip.getPassword() + "\""
						+ "}";
		int sc = 200;
		String errMes = "Comment deleted!";
		int numComments = 0;
		testDelete(incoming, sc, errMes, numComments);
		
		snipdao.deleteSnippet(snip.getID(), snip.getPassword());
		commdao = new CommentDAO();
		commdao.deleteCommentsBySnippet(snip, snip.getPassword());
		
	}
	
}
```


Overlapping Code:
```
DeleteCommentHandlerTest {
Context createContext(String apiCall) {
TestContext ctx = new TestContext();
ctx.setFunctionName(apiCall);
return ctx;
}

void testDelete(String incoming, int outgoing, String errMes, int numComments) {
DeleteCommentHandler handler = new DeleteCommentHandler();
DeleteCommentRequest req = new Gson().fromJson(incoming, DeleteCommentRequest.class);
DeleteCommentResponse response = handler.handleRequest(req, createContext("deleteComment"));

assertEquals(outgoing, response.getStatusCode());
assertEquals(errMes, response.getStatusMessage());

GetSnipCommentsHandler handler2 = new GetSnipCommentsHandler();
GetSnipCommentsRequest req2 = new Gson().fromJson("{\"id\": \"" + req.snippetID +"\"}", GetSnipCommentsRequest.class);
GetSnipCommentsResponse response2 = handler2.handleRequest(req2, createContext("getComments"));

assertEquals(numComments, response2.getComments().size());
}

@Test
public void testDeleteComment() throws Exception {
SnippetDAO snipdao = new SnippetDAO();
Snippet snip = new Snippet(snipdao.getAllSnippets(), "password");
snipdao.addSnippet(snip);
CommentDAO commdao = new CommentDAO();
Comment comment = new Comment(commdao.getAllComments(), snip.getID(), 1, 1, "test");
commdao.addComment(comment);

String incoming = "{"
+ "\"snippetID\": \"" + snip.getID() + "\","
+ "\"id\": \"" + comment.getID() + "\","
+ "\"password\": \"" + snip.getPassword() + "\""
+ "}";
int sc = 200;
String errMes = "Comment deleted!";
int numComments = 0;
testDelete(incoming, sc, errMes, numComments);

snipdao.deleteSnippet(snip.getID(), snip.getPassword());
commdao = new CommentDAO();
commdao.deleteCommentsBySnippet(snip, snip.ge
```
<Overlap Ratio: 0.9811764705882353>

---

--- 233 --
Question ID: c948e031acae3fb8e3242230aca8eefadf580b67
Original Code:
```
public class Camera {

	public static int x;
	public static int y;
	
	public static int clamp(int atual, int min, int max) {
		if(atual < min) atual = min;
		if(atual > max) atual = max;
		
		return atual;
	}
	
}
```


Overlapping Code:
```

public static int x;
public static int y;

public static int clamp(int atual, int min, int max) {
if(atual < min) atual = min;
if(atual > max) atual 
```
<Overlap Ratio: 0.7614213197969543>

---

--- 234 --
Question ID: 0d1e5cfa865ae7c784962c2db150dff34152e794
Original Code:
```
@DisplayName("A payment")
@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)
@IndicativeSentencesGeneration(separator = " ", generator = DisplayNameGenerator.ReplaceUnderscores.class)
public class PaymentTests {

    private EventLog eventLog;
    private PaymentProcessor paymentProcessor;
    private Payment payment;
    private PaymentRef ref;

    @BeforeEach
    public void setUp() {
        paymentProcessor = mock(PaymentProcessor.class);
        eventLog = mock(EventLog.class);
        ref = new PaymentRef();
        payment = Payment.builder()
                .amount(Amount.of(15, 0))
                .paymentProcessor(paymentProcessor)
                .eventLog(eventLog)
                .ref(ref)
                .build();
    }

    @Test
    public void should_start_in_the_new_state() {
        assertThat(payment.isNew()).isTrue();
    }

    @Test
    public void should_request_a_payment_from_the_payment_processor() {
        payment.request();
        assertThat(payment.isRequested()).isTrue();
        verify(paymentProcessor).request(payment);
    }

    @Test
    public void should_publish_an_event_when_it_requests_a_payment_from_the_payment_processor() {
        payment.request();
        verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
    }

    @Test
    public void should_reflect_a_successful_payment() {
        payment.request();
        payment.markSuccessful();
        assertThat(payment.isSuccessful()).isTrue();
    }

    @Test
    public void should_publish_an_event_when_a_payment_request_succeeds() {
        payment.request();
        verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
        payment.markSuccessful();
        verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentSuccessfulEvent.class));
    }

    @Test
    public void should_reflect_a_failed_payment() {
        payment.request();
        payment.markFailed();
        assertThat(payment.isFailed()).isTrue();
    }

    @Test
    public void should_publish_an_event_when_a_payment_request_fails() {
        payment.request();
        verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
        payment.markFailed();
        verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentFailedEvent.class));
    }

    @Test
    public void should_only_request_payment_from_the_payment_processor_if_it_is_in_the_new_state() {
        payment.request();
        payment.markSuccessful();
        assertThatIllegalStateException().isThrownBy(payment::request);
    }

    @Test
    public void should_only_mark_a_requested_payment_as_successful() {
        assertThatIllegalStateException().isThrownBy(payment::markSuccessful);
    }

    @Test
    public void should_only_mark_a_requested_payment_as_failed() {
        assertThatIllegalStateException().isThrownBy(payment::markFailed);
    }

    @Test
    public void accumulator_function_should_return_an_added_payment() {
        PaymentAddedEvent paymentAddedEvent = new PaymentAddedEvent(ref, payment.state());

        assertThat(payment.accumulatorFunction().apply(payment.identity(), paymentAddedEvent)).isEqualTo(payment);
    }

    @Test
    public void accumulator_function_should_return_a_requested_payment() {
        Payment expectedPayment = Payment.builder()
                .ref(ref)
                .eventLog(eventLog)
                .paymentProcessor(paymentProcessor)
                .amount(Amount.of(15, 0))
                .build();
        expectedPayment.request();

        PaymentRequestedEvent pre = new PaymentRequestedEvent(ref);

        assertThat(payment.accumulatorFunction().apply(payment, pre)).isEqualTo(expectedPayment);
    }

    @Test
    public void accumulator_function_should_return_a_successful_payment() {
        Payment expectedPayment = Payment.builder()
                .ref(ref)
                .eventLog(eventLog)
                .paymentProcessor(paymentProcessor)
                .amount(Amount.of(15, 0))
                .build();
        expectedPayment.request();
        expectedPayment.markSuccessful();

        PaymentSuccessfulEvent pse = new PaymentSuccessfulEvent(ref);

        assertThat(payment.accumulatorFunction().apply(payment, pse)).isEqualTo(expectedPayment);
    }

    @Test
    public void accumulator_function_should_return_a_failed_payment() {
        Payment expectedPayment = Payment.builder()
                .ref(ref)
                .eventLog(eventLog)
                .paymentProcessor(paymentProcessor)
                .amount(Amount.of(15, 0))
                .build();
        expectedPayment.request();
        expectedPayment.markFailed();

        PaymentFailedEvent pfe = new PaymentFailedEvent(ref);

        assertThat(payment.accumulatorFunction().apply(payment, pfe)).isEqualTo(expectedPayment);
    }

    @Test
    public void accumulator_function_should_throw_an_exception_with_an_unknown_event_type() {
        assertThatIllegalStateException().isThrownBy(() -> payment.accumulatorFunction().apply(payment, () -> null));
    }

}
```


Overlapping Code:
```
yment")
@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)
@IndicativeSentencesGeneration(separator = " ", generator = DisplayNameGenerator.ReplaceUnderscores.class)
public class PaymentTests {
private EventLog eventLog;
private PaymentProcessor paymentProcessor;
private Payment payment;
private PaymentRef ref;
@BeforeEach
public void setUp() {
paymentProcessor = mock(PaymentProcessor.class);
eventLog = mock(EventLog.class);
ref = new PaymentRef();
payment = Payment.builder()
.amount(Amount.of(15, 0))
.paymentProcessor(paymentProcessor)
.eventLog(eventLog)
.ref(ref)
.build();
}
@Test
public void should_start_in_the_new_state() {
assertThat(payment.isNew()).isTrue();
}
@Test
public void should_request_a_payment_from_the_payment_processor() {
payment.request();
assertThat(payment.isRequested()).isTrue();
verify(paymentProcessor).request(payment);
}
@Test
public void should_publish_an_event_when_it_requests_a_payment_from_the_payment_processor() {
payment.request();
verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
}
@Test
public void should_reflect_a_successful_payment() {
payment.request();
payment.markSuccessful();
assertThat(payment.isSuccessful()).isTrue();
}
@Test
public void should_publish_an_event_when_a_payment_request_succeeds() {
payment.request();
verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
payment.markSuccessful();
verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentSuccessfulEvent.class));
}
@Test
public void should_reflect_a_failed_payment() {
payment.request();
payment.markFailed();
assertThat(payment.isFailed()).isTrue();
}
@Test
public void should_publish_an_event_when_a_payment_request_fails() {
payment.request();
verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentRequestedEvent.class));
payment.markFailed();
verify(eventLog).publish(eq(new Topic("payments")), isA(PaymentFailedEvent.class));
}
@Test
public void should_only_request_payment_from_the_payment_processor_if_it_is_in_t
```
<Overlap Ratio: 0.9813307802776448>

---

--- 235 --
Question ID: ec223942ff91067be81344be661e3bec2ac6250a
Original Code:
```
public final class AccessToken implements Parcelable {
  public static final Creator<AccessToken> CREATOR = new Creator<AccessToken>() {
    public AccessToken createFromParcel(Parcel source) {
      return new AccessToken(source);
    }

    public AccessToken[] newArray(int size) {
      return new AccessToken[size];
    }
  };
  private static final long DEFAULT_TOKEN_REFRESH_INTERVAL = 604800L;
  private static final int PARCEL_VERSION = 2;
  private final String accountId;
  private final String applicationId;
  private final Date lastRefresh;
  private final String token;
  private final long tokenRefreshIntervalInSeconds;

  public AccessToken(@NonNull String token, @NonNull String accountId, @NonNull String applicationId, long tokenRefreshIntervalInSeconds, @Nullable Date lastRefreshTime) {
    this.token = token;
    this.accountId = accountId;
    this.applicationId = applicationId;
    this.tokenRefreshIntervalInSeconds = tokenRefreshIntervalInSeconds;
    this.lastRefresh = lastRefreshTime != null ? lastRefreshTime : new Date();
  }

  private AccessToken(Parcel parcel) {
    int version = 1;

    try {
      version = parcel.readInt();
    } catch (ClassCastException var6) {
    }

    String toSetToken;
    try {
      toSetToken = parcel.readString();
    } catch (ClassCastException var5) {
      parcel.readLong();
      toSetToken = parcel.readString();
    }

    this.token = toSetToken;
    this.accountId = parcel.readString();
    this.lastRefresh = new Date(parcel.readLong());
    this.applicationId = parcel.readString();
    if (version == 2) {
      this.tokenRefreshIntervalInSeconds = parcel.readLong();
    } else {
      this.tokenRefreshIntervalInSeconds = 604800L;
    }

  }

  public String getAccountId() {
    return this.accountId;
  }

  public String getApplicationId() {
    return this.applicationId;
  }

  public Date getLastRefresh() {
    return this.lastRefresh;
  }

  public String getToken() {
    return this.token;
  }

  public long getTokenRefreshIntervalSeconds() {
    return this.tokenRefreshIntervalInSeconds;
  }

  public String toString() {
    return "{AccessToken token:" + this.tokenToString() + " accountId:" + this.accountId + "}";
  }

  public boolean equals(Object other) {
    if (this == other) {
      return true;
    } else if (!(other instanceof AccessToken)) {
      return false;
    } else {
      AccessToken o = (AccessToken) other;
      return this.tokenRefreshIntervalInSeconds == o.tokenRefreshIntervalInSeconds && Utility.areObjectsEqual(this.accountId, o.accountId) && Utility.areObjectsEqual(this.applicationId, o.applicationId) && Utility.areObjectsEqual(this.lastRefresh, o.lastRefresh) && Utility.areObjectsEqual(this.token, o.token);
    }
  }

  public int hashCode() {
    int result = 17;
    result = result * 31 + Utility.getHashCode(this.accountId);
    result = result * 31 + Utility.getHashCode(this.applicationId);
    result = result * 31 + Utility.getHashCode(this.lastRefresh);
    result = result * 31 + Utility.getHashCode(this.token);
    result = result * 31 + Utility.getHashCode(this.tokenRefreshIntervalInSeconds);
    return result;
  }

  private String tokenToString() {
    if (this.token == null) {
      return "null";
    } else {
      return AccountKit.getLoggingBehaviors().isEnabled(LoggingBehavior.INCLUDE_ACCESS_TOKENS) ? this.token : "ACCESS_TOKEN_REMOVED";
    }
  }

  public int describeContents() {
    return 0;
  }

  public void writeToParcel(Parcel dest, int flags) {
    dest.writeInt(2);
    dest.writeString(this.token);
    dest.writeString(this.accountId);
    dest.writeLong(this.lastRefresh.getTime());
    dest.writeString(this.applicationId);
    dest.writeLong(this.tokenRefreshIntervalInSeconds);
  }
}
```


Overlapping Code:
```
ublic final class AccessToken implements Parcelable {
public static final Creator<AccessToken> CREATOR = new Creator<AccessToken>() {
public AccessToken createFromParcel(Parcel source) {
return new AccessToken(source);
}
public AccessToken[] newArray(int size) {
return new AccessToken[size];
}
};
private static final long DEFAULT_TOKEN_REFRESH_INTERVAL = 604800L;
private static final int PARCEL_VERSION = 2;
private final String accountId;
private final String applicationId;
private final Date lastRefresh;
private final String token;
private final long tokenRefreshIntervalInSeconds;
public AccessToken(@NonNull String token, @NonNull String accountId, @NonNull String applicationId, long tokenRefreshIntervalInSeconds, @Nullable Date lastRefreshTime) {
this.token = token;
this.accountId = accountId;
this.applicationId = applicationId;
this.tokenRefreshIntervalInSeconds = tokenRefreshIntervalInSeconds;
this.lastRefresh = lastRefreshTime != null ? lastRefreshTime : new Date();
}
private AccessToken(Parcel parcel) {
int version = 1;
try {
version = parcel.readInt();
} catch (ClassCastException var6) {
}
String toSetToken;
try {
toSetToken = parcel.readString();
} catch (ClassCastException var5) {
parcel.readLong();
toSetToken = parcel.readString();
}
this.token = toSetToken;
this.accountId = parcel.readString();
this.lastRefresh = new Date(parcel.readLong());
this.applicationId = parcel.readString();
if (version == 2) {
this.tokenRefreshIntervalInSeconds = parcel.readLong();
} else {
this.tokenRefreshIntervalInSeconds = 604800L;
}
}
public String getAccountId() {
return this.accountId;
}
public String getApplicationId() {
return this.applicationId;
}
public Date getLastRefresh() {
return this.lastRefresh;
}
public String getToken() {
return this.token;
}
public long getTokenRefreshIntervalSeconds() {
return this.tokenRefreshIntervalInSeconds;
}
public String toString() {
return "{AccessToken token:" + this.tokenToString() + " accountId:" + this.accountId + "}";
}
public boolean equals(Object other) {
if (this == other) {
return true;
} else if (!(other instanceof AccessToken)) {
return false;
} else {
AccessToken o = (AccessToken) other;
return this.tokenRefreshIntervalInSeconds == o
```
<Overlap Ratio: 0.993719156572454>

---

--- 236 --
Question ID: d42d3725c32c349c43c720d444ab377d375b7863
Original Code:
```
@SpringBootTest
class GulimallThirdPartyApplicationTests {

    @Autowired
    OSSClient ossClient;

    @Autowired
    SMSComponent smsComponent;

    @Test
    void testSendSms() {
        smsComponent.sendSMSCode("18931007018", "123456");
    }

    @Test
    void testOSSUpdate() throws FileNotFoundException {
        InputStream inputStream = new FileInputStream("/Users/zhengyuli/Desktop/avatar.png");
        ossClient.putObject("zli78122-gulimall", "avatar.png", inputStream);
        ossClient.shutdown();
    }
}
```


Overlapping Code:
```
ingBootTest
class GulimallThirdPartyApplicationTests {
@Autowired
OSSClient ossClient;
@Autowired
SMSComponent smsComponent;
@Test
void testSendSms() {
smsComponent.sendSMSCode("18931007018", "123456");
}
@Test
void testOSSUpdate() throws FileNotFoundException {
InputStream inputStream = new FileInputStream("/Users/zhengyuli/Desktop/avatar.png");
ossClient.putObject("zli78122-gulimall", "avatar.png", inputStream);
ossClient.shutdown(
```
<Overlap Ratio: 0.9776286353467561>

---

--- 237 --
Question ID: 640a5dafc5c50d19adf023ebe65c9e42673674fd
Original Code:
```
public class CurrencyDetailsViewModel extends BaseDisposableViewModel implements BaseViewModel {

    public static final String KEY_CURRENCY_CODE = "KEY_CURRENCY_CODE";
    private GetCurrencySeriesUseCase mGetSeriesUseCase;
    private boolean mIsProgressVisible;
    private List<SingleValue> mCurrencySeries;
    private String mCurrencyCode;

    public CurrencyDetailsViewModel(final GetCurrencySeriesUseCase getSeriesUseCase) {
        mGetSeriesUseCase = getSeriesUseCase;
        mCurrencySeries = new ArrayList<>();
    }

    @Bindable
    public String getCurrencyCode() {
        return mCurrencyCode;
    }

    public void setCurrencyCode(final String currencyCode) {
        mCurrencyCode = currencyCode;
        notifyPropertyChanged(BR.currencyCode);
    }

    @Bindable
    public List<SingleValue> getCurrencySeries() {
        return mCurrencySeries;
    }

    @Override
    public void onLoad(final Bundle bundle) {
        checkNotNull(bundle);
        checkArgument(bundle.containsKey(KEY_CURRENCY_CODE), "Currency code must be provided to onLoad method");
        setCurrencyCode(bundle.getString(KEY_CURRENCY_CODE));
        performRequest();
    }

    @Bindable
    public boolean isProgressVisible() {
        return mIsProgressVisible;
    }

    public void setProgressVisible(final boolean progressVisible) {
        mIsProgressVisible = progressVisible;
        notifyPropertyChanged(BR.progressVisible);
    }

    public void performRefresh() {
        performRequest();
    }

    private void performRequest() {
        setProgressVisible(true);
        Date endDate = new Date();
        int daysRange = 10;
        mCurrencySeries.clear();
        final Calendar calendar = Calendar.getInstance();
        calendar.setTime(endDate);
        calendar.add(Calendar.DAY_OF_YEAR, -daysRange);
        Date from = calendar.getTime();
        CurrencySeriesParam params = new CurrencySeriesParam(from, endDate, mCurrencyCode);
        addDisposable(
                mGetSeriesUseCase.run(params)
                        .doFinally(() -> {
                            setProgressVisible(false);
                            notifyPropertyChanged(BR.currencySeries);
                        })
                        .subscribe(currencyData -> {
                            mCurrencySeries.add(currencyData);
                        })
        );
    }

}
```


Overlapping Code:
```
sViewModel extends BaseDisposableViewModel implements BaseViewModel {
public static final String KEY_CURRENCY_CODE = "KEY_CURRENCY_CODE";
private GetCurrencySeriesUseCase mGetSeriesUseCase;
private boolean mIsProgressVisible;
private List<SingleValue> mCurrencySeries;
private String mCurrencyCode;
public CurrencyDetailsViewModel(final GetCurrencySeriesUseCase getSeriesUseCase) {
mGetSeriesUseCase = getSeriesUseCase;
mCurrencySeries = new ArrayList<>();
}
@Bindable
public String getCurrencyCode() {
return mCurrencyCode;
}
public void setCurrencyCode(final String currencyCode) {
mCurrencyCode = currencyCode;
notifyPropertyChanged(BR.currencyCode);
}
@Bindable
public List<SingleValue> getCurrencySeries() {
return mCurrencySeries;
}
@Override
public void onLoad(final Bundle bundle) {
checkNotNull(bundle);
checkArgument(bundle.containsKey(KEY_CURRENCY_CODE), "Currency code must be provided to onLoad method");
setCurrencyCode(bundle.getString(KEY_CURRENCY_CODE));
performRequest();
}
@Bindable
public boolean isProgressVisible() {
return mIsProgressVisible;
}
public void setProgressVisible(final boolean progressVisible) {
mIsProgressVisible = progressVisible;
notifyPropertyChanged(BR.progressVisible);
}
public void performRefresh() {
performRequest();
}
private void performRequest() {
setProgressVisible(true);
Date endDate = new Date();
int daysRange = 10;
mCurrencySeries.clear();
final Calendar calendar = Calendar.getInstance();
calendar.setTime(endDate);
calendar.add(Calendar.DAY_OF_YEAR, -daysRange);
Date from = calendar.getTime();
CurrencySeriesParam params = new CurrencySeriesParam(from, endDate, mCurrencyCode);
addDisposable(
mGetSeriesUseCase.run(params)
.doFinally(() -> {
setProgressVisible(false);
notifyPropertyChanged(BR.currencySeries);
})
.subscribe(currencyData -> 
```
<Overlap Ratio: 0.9610250934329952>

---

--- 238 --
Question ID: d731776d74d38dead201cbec35cbfea8e65e063f
Original Code:
```
@BeanDefinition(builderScope = "private", metaScope = "private", factoryName = "of")
public final class MarginError implements ImmutableBean {

  /**
   * The error reason.
   */
  @PropertyDefinition(validate = "notEmpty")
  private final String reason;
  /**
   * The error message.
   */
  @PropertyDefinition(validate = "notNull")
  private final String message;
  /**
   * The optional error type, such as an exception class name.
   */
  @PropertyDefinition(get = "optional")
  private final String type;

  @PropertyDefinition(validate = "notNull")
  private final Map<String, String> attributes;

  //------------------------- AUTOGENERATED START -------------------------
  /**
   * The meta-bean for {@code MarginError}.
   * @return the meta-bean, not null
   */
  public static MetaBean meta() {
    return MarginError.Meta.INSTANCE;
  }

  static {
    MetaBean.register(MarginError.Meta.INSTANCE);
  }

  /**
   * Obtains an instance.
   * @param reason  the value of the property, not empty
   * @param message  the value of the property, not null
   * @param type  the value of the property
   * @param attributes  the value of the property, not null
   * @return the instance
   */
  public static MarginError of(
      String reason,
      String message,
      String type,
      Map<String, String> attributes) {
    return new MarginError(
      reason,
      message,
      type,
      attributes);
  }

  private MarginError(
      String reason,
      String message,
      String type,
      Map<String, String> attributes) {
    JodaBeanUtils.notEmpty(reason, "reason");
    JodaBeanUtils.notNull(message, "message");
    JodaBeanUtils.notNull(attributes, "attributes");
    this.reason = reason;
    this.message = message;
    this.type = type;
    this.attributes = Collections.unmodifiableMap(new HashMap<>(attributes));
  }

  @Override
  public MetaBean metaBean() {
    return MarginError.Meta.INSTANCE;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the error reason.
   * @return the value of the property, not empty
   */
  public String getReason() {
    return reason;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the error message.
   * @return the value of the property, not null
   */
  public String getMessage() {
    return message;
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the optional error type, such as an exception class name.
   * @return the optional value of the property, not null
   */
  public Optional<String> getType() {
    return Optional.ofNullable(type);
  }

  //-----------------------------------------------------------------------
  /**
   * Gets the attributes.
   * @return the value of the property, not null
   */
  public Map<String, String> getAttributes() {
    return attributes;
  }

  //-----------------------------------------------------------------------
  @Override
  public boolean equals(Object obj) {
    if (obj == this) {
      return true;
    }
    if (obj != null && obj.getClass() == this.getClass()) {
      MarginError other = (MarginError) obj;
      return JodaBeanUtils.equal(reason, other.reason) &&
          JodaBeanUtils.equal(message, other.message) &&
          JodaBeanUtils.equal(type, other.type) &&
          JodaBeanUtils.equal(attributes, other.attributes);
    }
    return false;
  }

  @Override
  public int hashCode() {
    int hash = getClass().hashCode();
    hash = hash * 31 + JodaBeanUtils.hashCode(reason);
    hash = hash * 31 + JodaBeanUtils.hashCode(message);
    hash = hash * 31 + JodaBeanUtils.hashCode(type);
    hash = hash * 31 + JodaBeanUtils.hashCode(attributes);
    return hash;
  }

  @Override
  public String toString() {
    StringBuilder buf = new StringBuilder(160);
    buf.append("MarginError{");
    buf.append("reason").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');
    buf.append("message").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');
    buf.append("type").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');
    buf.append("attributes").append('=').append(JodaBeanUtils.toString(attributes));
    buf.append('}');
    return buf.toString();
  }

  //-----------------------------------------------------------------------
  /**
   * The meta-bean for {@code MarginError}.
   */
  private static final class Meta extends DirectMetaBean {
    /**
     * The singleton instance of the meta-bean.
     */
    static final Meta INSTANCE = new Meta();

    /**
     * The meta-property for the {@code reason} property.
     */
    private final MetaProperty<String> reason = DirectMetaProperty.ofImmutable(
        this, "reason", MarginError.class, String.class);
    /**
     * The meta-property for the {@code message} property.
     */
    private final MetaProperty<String> message = DirectMetaProperty.ofImmutable(
        this, "message", MarginError.class, String.class);
    /**
     * The meta-property for the {@code type} property.
     */
    private final MetaProperty<String> type = DirectMetaProperty.ofImmutable(
        this, "type", MarginError.class, String.class);
    /**
     * The meta-property for the {@code attributes} property.
     */
    @SuppressWarnings({"unchecked", "rawtypes" })
    private final MetaProperty<Map<String, String>> attributes = DirectMetaProperty.ofImmutable(
        this, "attributes", MarginError.class, (Class) Map.class);
    /**
     * The meta-properties.
     */
    private final Map<String, MetaProperty<?>> metaPropertyMap$ = new DirectMetaPropertyMap(
        this, null,
        "reason",
        "message",
        "type",
        "attributes");

    /**
     * Restricted constructor.
     */
    private Meta() {
    }

    @Override
    protected MetaProperty<?> metaPropertyGet(String propertyName) {
      switch (propertyName.hashCode()) {
        case -934964668:  // reason
          return reason;
        case 954925063:  // message
          return message;
        case 3575610:  // type
          return type;
        case 405645655:  // attributes
          return attributes;
      }
      return super.metaPropertyGet(propertyName);
    }

    @Override
    public BeanBuilder<? extends MarginError> builder() {
      return new MarginError.Builder();
    }

    @Override
    public Class<? extends MarginError> beanType() {
      return MarginError.class;
    }

    @Override
    public Map<String, MetaProperty<?>> metaPropertyMap() {
      return metaPropertyMap$;
    }

    //-----------------------------------------------------------------------
    @Override
    protected Object propertyGet(Bean bean, String propertyName, boolean quiet) {
      switch (propertyName.hashCode()) {
        case -934964668:  // reason
          return ((MarginError) bean).getReason();
        case 954925063:  // message
          return ((MarginError) bean).getMessage();
        case 3575610:  // type
          return ((MarginError) bean).type;
        case 405645655:  // attributes
          return ((MarginError) bean).getAttributes();
      }
      return super.propertyGet(bean, propertyName, quiet);
    }

    @Override
    protected void propertySet(Bean bean, String propertyName, Object newValue, boolean quiet) {
      metaProperty(propertyName);
      if (quiet) {
        return;
      }
      throw new UnsupportedOperationException("Property cannot be written: " + propertyName);
    }

  }

  //-----------------------------------------------------------------------
  /**
   * The bean-builder for {@code MarginError}.
   */
  private static final class Builder extends DirectPrivateBeanBuilder<MarginError> {

    private String reason;
    private String message;
    private String type;
    private Map<String, String> attributes = Collections.emptyMap();

    /**
     * Restricted constructor.
     */
    private Builder() {
    }

    //-----------------------------------------------------------------------
    @Override
    public Object get(String propertyName) {
      switch (propertyName.hashCode()) {
        case -934964668:  // reason
          return reason;
        case 954925063:  // message
          return message;
        case 3575610:  // type
          return type;
        case 405645655:  // attributes
          return attributes;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
    }

    @SuppressWarnings("unchecked")
    @Override
    public Builder set(String propertyName, Object newValue) {
      switch (propertyName.hashCode()) {
        case -934964668:  // reason
          this.reason = (String) newValue;
          break;
        case 954925063:  // message
          this.message = (String) newValue;
          break;
        case 3575610:  // type
          this.type = (String) newValue;
          break;
        case 405645655:  // attributes
          this.attributes = (Map<String, String>) newValue;
          break;
        default:
          throw new NoSuchElementException("Unknown property: " + propertyName);
      }
      return this;
    }

    @Override
    public MarginError build() {
      return new MarginError(
          reason,
          message,
          type,
          attributes);
    }

    //-----------------------------------------------------------------------
    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder(160);
      buf.append("MarginError.Builder{");
      buf.append("reason").append('=').append(JodaBeanUtils.toString(reason)).append(',').append(' ');
      buf.append("message").append('=').append(JodaBeanUtils.toString(message)).append(',').append(' ');
      buf.append("type").append('=').append(JodaBeanUtils.toString(type)).append(',').append(' ');
      buf.append("attributes").append('=').append(JodaBeanUtils.toString(attributes));
      buf.append('}');
      return buf.toString();
    }

  }

  //-------------------------- AUTOGENERATED END --------------------------
}
```


Overlapping Code:
```
@BeanDefinition(builderScope = "private", metaScope = "private", factoryName = "of")
public final class MarginError implements ImmutableBean {
/**
* The error reason.
*/
@PropertyDefinition(validate = "notEmpty")
private final String reason;
/**
* The error message.
*/
@PropertyDefinition(validate = "notNull")
private final String message;
/**
* The optional error type, such as an exception class name.
*/
@PropertyDefinition(get = "optional")
private final String type;
@PropertyDefinition(validate = "notNull")
private final Map<String, String> attributes;
//------------------------- AUTOGENERATED START -------------------------
/**
* The meta-bean for {@code MarginError}.
* @return the meta-bean, not null
*/
public static MetaBean meta() {
return MarginError.Meta.INSTANCE;
}
static {
MetaBean.register(MarginError.Meta.INSTANCE);
}
/**
* Obtains an instance.
* @param reason the value of the property, not empty
* @param message the value of the property, not null
* @param type the value of the property
* @param attributes the value of the property, not null
* @return the instance
*/
public static MarginError of(
String reason,
String message,
String type,
Map<String, String> attributes) {
return new MarginError(
reason,
message,
type,
attributes);
}
private MarginError(
String reason,
String message,
String type,
Map<String, String> attributes) {
JodaBeanUtils.notEmpty(reason, "reason");
JodaBeanUtils.notNull(message, "message");
JodaBeanUtils.notNull(attributes, "attributes");
this.reason = reason;
this.message = message;
this.type = type;
this.attributes = Collections.unmodifiableMap(new HashMap<>(attributes));
}
@Override
public MetaBean metaBean() {
return MarginError.Meta.INSTANCE;
}
//-----------------------------------------------------------------------
/**
* Gets the error reason.
* @return the value of the property, not empty
*/
public String getReason() {
return reason;
}
//-----------------------------------------------------------------------
/**
* Gets the error message.
* @return the value of the property, not null
*/
public String getMessage() {
return message;
}
//-----------------------------------------------------------------------
/**
* Gets the optional err
```
<Overlap Ratio: 0.9968496849684968>

---

--- 239 --
Question ID: 372131a3123cd20a5318bc147c894299daa61adc
Original Code:
```
class AccessSetHt extends AccessSet {
    // Normal per-object reference table
    private HashMap<Long, AccessSetObj> ht;
    // Flattened atomic table for faster atomic-nonatomic intersection
    private HashMap<Long, AccessSetObj> flattenedATable;

    // constructor for AccessSetHt
    public AccessSetHt() {
        ht = new HashMap<Long, AccessSetObj>();
        flattenedATable = new HashMap<Long, AccessSetObj>();
    }

    public void setHt(HashMap<Long, AccessSetObj> hm) {
        this.ht = hm;
    }

    public HashMap<Long, AccessSetObj> getHt() {
        return ht;
    }
    public HashMap<Long, AccessSetObj> getFlattenedATable() {
        return this.flattenedATable;
    }

    /**
     * Hashmap print
     */
    @Override
    public void print(){
        Long obj;
        AccessSetObj entry;
        System.out.println("Normal accesses");
        System.out.print("{");
        Set addrSet = this.ht.keySet();
        Iterator itr = addrSet.iterator();
        while (itr.hasNext()) {
            obj = (Long) itr.next();
            System.out.print(obj);
            entry = (AccessSetObj) this.ht.get(obj);
            if (entry != null) {
                System.out.print("(");
                entry.print();
                System.out.print("),");
            }

        }
        System.out.println("}");
        System.out.println("Atomic accesses");
    }

    /**
     * set intersection.
     */
    @Override
    public void intersect(AccessSet set, int taskType) {
        // perform intersection on reads/writes
        Long obj;
        AccessSetObj entry2;
        AccessSetObj entry;
        
        // if incoming set is a hashtable
        if (set instanceof AccessSetHt) {
            AccessSetHt setHt = (AccessSetHt) set;
            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();
            Set addrSet = ht2.keySet();
            Iterator itr = addrSet.iterator();
            while (itr.hasNext()) {
                obj = (Long) itr.next();
                entry = (AccessSetObj) this.ht.get(obj);
                if (entry != null) {
                    // skip the reduction object on S node
                    if (entry.accessInfo instanceof RubyReduction
                            && taskType != RaceTask.RACE_TASK_FINISH) {
                        continue;
                    }
                    entry2 = (AccessSetObj) ht2.get(obj);
                    entry.intersect(entry2, obj);
                }
            }
            // Intersect my atomic part with incoming non-atomic part
            // Note: no merge!
            // Note: use flattened atomic table
            for (Long objId : ht2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);
                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);

                if (myEntry != null) {
                    // skip the reduction object on S node
                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {
                        myEntry.intersect(incomingEntry, objId);
                    }
                }
            }
            // Intersect my non-atomic part with incoming atomic part
            // Note: no merge!
            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();
            for (Long objId : flattenedAT2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));
                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);

                if (myEntry != null) {
                    // skip the reduction object on S node
                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {
                        myEntry.intersect(incomingEntry, objId);
                    }
                }
            }
        }
        // the incoming log is a list
        else {
            AccessSetList setList = (AccessSetList) set;
            long[] reads = setList.getReads();
            long writes[] = setList.getWrites();
            Object[] readInfo = setList.getRdInfo();
            Object[] writeInfo = setList.getWrtInfo();
            IRubyObject[] readCommScope = setList.getReadCommScope();
            IRubyObject[] writeCommScope = setList.getWriteCommScope();

            for (int i = 0; i < setList.getReadSize(); i += 2) {
                obj = reads[i];
                // detect read-write conflicts
                // Incoming ops vs. atomic ops
                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;
                entry = (AccessSetObj) (workingTable.get(obj));
                // Only check for non-atomic ops
                if (readCommScope[i / 2] == null && entry != null) {
                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {
                        // only find reduction problems on P node
                        if (readInfo[i / 2] instanceof RubyReduction
                                && taskType != RaceTask.RACE_TASK_FINISH) {
                            continue;
                        }
                        if (RaceDetector.detailMode) {
                            RaceDetector.recordRace(obj, (int) reads[i + 1], (MemoryOprInfo) readInfo[i / 2],
                                    ((AccessSetObjDetailBm) entry).getMemOprInfo(
                                            (int) reads[i + 1], WRT_FLAG));
                        } else {
                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);
                        }
                    }
                }
                // Incoming ops vs. non-atomic ops
                workingTable = this.ht;
                entry = (AccessSetObj) (workingTable.get(obj));
                if (entry != null) {
                    if (entry.isIn((int) reads[i + 1], WRT_FLAG)) {
                        // only find reduction problems on P node
                        if (readInfo[i / 2] instanceof RubyReduction
                                && taskType != RaceTask.RACE_TASK_FINISH) {
                            continue;
                        }
                        if (RaceDetector.detailMode) {
                            RaceDetector.recordRace(obj, (int) reads[i + 1],
                                    (MemoryOprInfo) readInfo[i / 2], ((AccessSetObjDetailBm) entry)
                                            .getMemOprInfo((int) reads[i + 1], WRT_FLAG));
                        } else {
                            RaceDetector.recordRace(obj, readInfo[i / 2], (int) reads[i + 1]);
                        }
                    }
                }
            }
            for (int i = 0; i < setList.getWriteSize(); i += 2) {
                obj = writes[i];
                // detect write-write and read-write conflicts
                // Incoming ops vs. atomic ops
                HashMap<Long, AccessSetObj> workingTable = this.flattenedATable;
                entry = (AccessSetObj) (workingTable.get(obj));
                // Only check for non-atomic ops
                if (writeCommScope[i / 2] == null && entry != null) {
                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)
                        || entry.isIn((int) writes[i + 1], RD_FLAG)) {
                        // only find reduction problems on P node
                        if (writeInfo[i / 2] instanceof RubyReduction
                                && taskType != RaceTask.RACE_TASK_FINISH) {
                            continue;
                        }
                        if (RaceDetector.detailMode) {
                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))
                                RaceDetector.recordRace(obj, (int) writes[i + 1],
                                        (MemoryOprInfo) writeInfo[i / 2],
                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(
                                                (int) writes[i + 1], WRT_FLAG));
                            else
                                RaceDetector.recordRace(obj, (int) writes[i + 1],
                                        (MemoryOprInfo) writeInfo[i / 2],
                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(
                                                (int) writes[i + 1], RD_FLAG));
                        } else {
                            RaceDetector.recordRace(obj, writeInfo[i / 2], (int) writes[i + 1]);
                        }
                    }
                }
                // Incoming ops vs. non-atomic ops
                workingTable = this.ht;
                entry = (AccessSetObj) (workingTable.get(obj));
                if (entry != null) {
                    if (entry.isIn((int) writes[i + 1], WRT_FLAG)
                            || entry.isIn((int) writes[i + 1], RD_FLAG)) {
                        // only find reduction problems on P node
                        if (readInfo[i / 2] instanceof RubyReduction
                                && taskType != RaceTask.RACE_TASK_FINISH) {
                            continue;
                        }
                        if (RaceDetector.detailMode) {
                            if (entry.isIn((int) writes[i + 1], WRT_FLAG))
                                RaceDetector.recordRace(obj, (int) writes[i + 1],
                                        (MemoryOprInfo) writeInfo[i / 2],
                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(
                                                (int) writes[i + 1], WRT_FLAG));
                            else
                                RaceDetector.recordRace(obj, (int) writes[i + 1],
                                        (MemoryOprInfo) writeInfo[i / 2],
                                        ((AccessSetObjDetailBm) entry).getMemOprInfo(
                                                (int) writes[i + 1], RD_FLAG));
                        } else {
                            RaceDetector.recordRace(obj, writeInfo[i / 2],
                                    (int) writes[i + 1]);
                        }
                    }
                }
            }
        }
        // Perform intersection on methods
        intersectCall(set);
    }

    /**
     * set merge
     */
    @Override
    public AccessSet merge(AccessSet set) {
        AccessSetObj entry;
        Long obj;
        AccessSetObj entry2;
        // the incoming log is a hash table
        if (set instanceof AccessSetHt) {
            // Merge non-atomic part
            AccessSetHt setHt = (AccessSetHt) set;
            HashMap ht2 = setHt.getHt();
            Set addrSet = ht2.keySet();
            Iterator itr = addrSet.iterator();
            while (itr.hasNext()) {
                obj = (Long) itr.next();
                entry = (AccessSetObj) this.ht.get(obj);
                entry2 = (AccessSetObj) ht2.get(obj);
                if (entry != null) {
                    size += entry.merge(entry2);
                } else {
                    ht.put(obj, entry2);
                    size += entry2.size();
                }
            }
            // Merge flattened table
            // Intersect my non-atomic part with incoming atomic part
            // Note: no merge!
            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();
            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;
            for (Long objId : flattenedAT2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));
                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);
                if (myEntry != null) {
                    myEntry.merge(incomingEntry);
                } else {
                    myAT.put(objId, incomingEntry);
                }
            }
        } else { // the incoming log is a list
            AccessSetList setList = (AccessSetList) set;
            long[] reads = setList.getReads();
            long writes[] = setList.getWrites();
            Object[] readInfo = setList.getRdInfo();
            Object[] writeInfo = setList.getWrtInfo();
            IRubyObject[] readCommScope = setList.getReadCommScope();
            IRubyObject[] writeCommScope = setList.getWriteCommScope();
            for (int i = 0; i < setList.getReadSize(); i += 2) {
                obj = reads[i];
                // Check for atomic ops
                HashMap<Long, AccessSetObj> workingTable = this.ht;
                if (readCommScope[i / 2] != null) {
                    workingTable = this.flattenedATable;
                }
                entry = (AccessSetObj) (workingTable.get(obj));
                // merge reads
                if (entry == null) {
                    if (RaceDetector.spaceTreeOn
                            && readInfo[i / 2] instanceof String
                            && ((String) readInfo[i / 2]).equals("ARRAY")) {
                        entry = new AccessSetObjSt();
                        entry.insert((int) (reads[i + 1]), RD_FLAG);
                    } else if (RaceDetector.detailMode) {
                        entry = new AccessSetObjDetailBm((int) (reads[i + 1]),
                                RD_FLAG, (MemoryOprInfo) readInfo[i / 2]);
                        size += 2;
                    } else {
                        entry = new AccessSetObjBm(readInfo[i / 2],
                                (int) (reads[i + 1]), 0, 0, RD_FLAG);
                        size += 2;
                    }
                    workingTable.put(obj, entry);
                } else {
                    if (RaceDetector.detailMode) {
                        size += ((AccessSetObjDetailBm) entry).insert((int) reads[i + 1], RD_FLAG,
                                (MemoryOprInfo) readInfo[i / 2]);
                    } else {
                        size += entry.insert((int) reads[i + 1], RD_FLAG);
                    }
                }
            }
            for (int i = 0; i < setList.getWriteSize(); i += 2) {
                obj = writes[i];
                // For atomic ops
                HashMap<Long, AccessSetObj> workingTable = this.ht;
                if (writeCommScope[i / 2] != null) {
                    workingTable = this.flattenedATable;
                }
                entry = (AccessSetObj) (workingTable.get(obj));
                // merge writes
                if (entry == null) {
                    if (RaceDetector.spaceTreeOn
                            && writeInfo[i / 2] instanceof String
                            && ((String) writeInfo[i / 2]).equals("ARRAY")) {

                        entry = new AccessSetObjSt();
                        entry.insert((int) (writes[i + 1]), WRT_FLAG);
                    } else if (RaceDetector.detailMode) {
                        entry = new AccessSetObjDetailBm((int) (writes[i + 1]),
                                WRT_FLAG, (MemoryOprInfo) writeInfo[i / 2]);
                        size += 2;
                    } else {
                        entry = new AccessSetObjBm(writeInfo[i / 2],
                                (int) (writes[i + 1]), 0, 0, WRT_FLAG);
                        size += 2;
                    }
                    workingTable.put(obj, entry);
                } else {
                    if (RaceDetector.detailMode) {
                        size += ((AccessSetObjDetailBm) entry).insert((int) writes[i + 1], WRT_FLAG,
                                (MemoryOprInfo) writeInfo[i / 2]);
                    } else {
                        size += entry.insert((int) writes[i + 1], WRT_FLAG);
                    }
                }
            }
        }

        this.mergeNum += set.getMergeNum();

        // for commutative
        mergeCall(set);
        set.clear();
        return this;
    }

    /**
     * set intersection and merge
     */
    @Override
    public AccessSet intersectAndMerge(AccessSet set, int taskType) {
        long obj;
        AccessSetObj entry;
        AccessSetObj entry2;

        // TODO: intersect and merge with atomicTable
        // the incoming log is a hash table
        if (set instanceof AccessSetHt) {
             // Intersect and merge non-atomic part
            AccessSetHt setHt = (AccessSetHt) set;
            HashMap<Long, AccessSetObj> ht2 = setHt.getHt();

            Set addrSet = ht2.keySet();
            Iterator itr = addrSet.iterator();
            while (itr.hasNext()) {
                obj = (Long) itr.next();
                entry = (AccessSetObj) this.ht.get(obj);
                if (entry != null) {
                    entry2 = (AccessSetObj) ht2.get(obj);
                    // skip the reduction object on S node
                    if (!(entry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {
                        entry.intersect(entry2, obj);
                    }
                    size += entry.merge(entry2);

                } else {// merge
                    entry2 = (AccessSetObj) ht2.get(obj);
                    this.ht.put(obj, entry2);
                    size += entry2.size();
                }
            }
            this.mergeNum += set.getMergeNum();
            // Intersect my atomic part with incoming non-atomic part
            // Note: no merge!
            // Note: use flattened atomic table
            for (Long objId : ht2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) ht2.get(objId);
                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);
                if (myEntry != null) {
                    // skip the reduction object on S node
                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {
                        myEntry.intersect(incomingEntry, objId);
                    }
                }
            }
            // Intersect my non-atomic part with incoming atomic part
            // Note: no merge!
            HashMap<Long, AccessSetObj> flattenedAT2 = setHt.getFlattenedATable();
            for (Long objId : flattenedAT2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));
                AccessSetObj myEntry = (AccessSetObj) this.ht.get(objId);
                if (myEntry != null) {
                    // skip the reduction object on S node
                    if (!(myEntry.accessInfo instanceof RubyReduction && taskType != RaceTask.RACE_TASK_FINISH)) {
                        myEntry.intersect(incomingEntry, objId);
                    }
                }
            }
            // Merge flattened table
            HashMap<Long, AccessSetObj> myAT = this.flattenedATable;
            for (Long objId : flattenedAT2.keySet()) {
                AccessSetObj incomingEntry = (AccessSetObj) (flattenedAT2.get(objId));
                AccessSetObj myEntry = (AccessSetObj) this.flattenedATable.get(objId);
                if (myEntry != null) {
                    myEntry.merge(incomingEntry);
                } else {
                    myAT.put(objId, incomingEntry);
                }
            }
            // Deal with ac-ops
            intersectCall(set);
            mergeCall(set);
        }
        // the incoming log is a list
        else {
            this.intersect(set, taskType);
            this.merge(set);
        }

        set.clear();
        return this;
    }

    @Override
    public void clear() {
        this.mergeNum = 0;
        ht.clear();
        flattenedATable.clear();
        super.clear();
    }

    @Override
    public long size() {
        return this.size;
    }

    /**
     * Insert a log into current access-set 
     */
    @Override
    public AccessSet insert(long obj, int offset, int flag, int file,
            int line, Object info, IRubyObject commScope) {
        if (offset < 0){
            return this;
        }
        
        HashMap<Long, AccessSetObj> operatingTable = ht;
        int atomicModifier = 0;
        // If the incoming flag indicates this is an op in atomic method, change
        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {
            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;
            // Add this operation to flattened table
            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);
            if (flattenedEntry == null) {
                if (RaceDetector.detailMode) {
                    flattenedEntry = new AccessSetObjDetailBm(offset, flag - atomicModifier,
                            ((MemoryOprInfo) info).clone());
                } else {
                    flattenedEntry = new AccessSetObjBm(info, offset, line, file, flag
                            - atomicModifier);
                }
                this.flattenedATable.put(obj, flattenedEntry);
            } else {
                if (RaceDetector.detailMode) {
                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag - atomicModifier,
                            ((MemoryOprInfo) info).clone());
                } else {
                    flattenedEntry.insert(offset, flag - atomicModifier);
                }
            }
            return this;
        } 
        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);
        if (entry == null) {
            if (RaceDetector.spaceTreeOn && info instanceof String
                    && ((String) info).equals("ARRAY")) {
                entry = new AccessSetObjSt();
            } else if (RaceDetector.detailMode) {
                entry = new AccessSetObjDetailBm(offset, flag - atomicModifier,
                        ((MemoryOprInfo) info).clone());
            } else {
                entry = new AccessSetObjBm(info, offset, line, file, flag - atomicModifier);
            }
            operatingTable.put(obj, entry);
            size += 2;
        } else {
            if (RaceDetector.detailMode) {
                size += ((AccessSetObjDetailBm) entry).insert(offset, flag - atomicModifier,
                        ((MemoryOprInfo) info).clone());
            } else {
                size += entry.insert(offset, flag - atomicModifier);
            }
        }
        return this;
    }

    /**
     * Insert a batch of accesses into current set
     */
    @Override
    public AccessSet insert(long obj, int offset, int flag, int len, Object info, IRubyObject commScope) {
        if (offset < 0)
            return this;
        HashMap<Long, AccessSetObj> operatingTable = ht;
        int atomicModifier = 0;
        // If the incoming flag indicates this is an op in atomic method, change
        if (flag >= AccessSet.ATOMIC_OP_OFFSET) {
            atomicModifier = AccessSet.ATOMIC_OP_OFFSET;
            // Add this operation to flattened table
            AccessSetObj flattenedEntry = (AccessSetObj) this.flattenedATable.get(obj);
            if (flattenedEntry == null) {
                if (RaceDetector.detailMode) {
                    flattenedEntry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,
                            ((MemoryOprInfo) info).clone());
                } else {
                    flattenedEntry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);
                }
                this.flattenedATable.put(obj, flattenedEntry);
            } else {
                if (RaceDetector.detailMode) {
                    ((AccessSetObjDetailBm) flattenedEntry).insert(offset, flag, len
                            - atomicModifier, ((MemoryOprInfo) info).clone());
                } else {
                    flattenedEntry.insert(offset, flag - atomicModifier);
                }
            }
            return this;
        }
        
        AccessSetObj entry = (AccessSetObj) operatingTable.get(obj);

        if (entry == null) {
            if (RaceDetector.spaceTreeOn && info instanceof String
                    && ((String) info).equals("ARRAY")) {
                entry = new AccessSetObjSt();
                entry.insert(offset, flag - atomicModifier, len);
            } else {
                if (RaceDetector.detailMode) {
                    entry = new AccessSetObjDetailBm(offset, flag, len - atomicModifier,
                            ((MemoryOprInfo) info).clone());
                } else {
                    entry = new AccessSetObjBm(info, offset, flag - atomicModifier, len);
                }
            }
            operatingTable.put(obj, entry);
            // update the set size;
            size += 2;
        } else {
            if (RaceDetector.detailMode) {
                size += ((AccessSetObjDetailBm) entry).insert(offset, flag, len
                        - atomicModifier, ((MemoryOprInfo) info).clone());
            } else {
                size += entry.insert(offset, flag - atomicModifier, len);
            }
        }
        return this;
    }

    /**
     * Calculate the intersection of two sets
     */
    @Override
    public void calComSet(AccessSet set) {
        HashMap ht3 = new HashMap();
        HashMap ht2 = ((AccessSetHt) set).getHt();
        Set addrSet = ht.keySet();
        Iterator itr = addrSet.iterator();
        while (itr.hasNext()) {
            Long obj = (Long) itr.next();
            AccessSetObj entry = (AccessSetObj) ht2.get(obj);
            if (entry == null) {

            } else {
                AccessSetObj entry2 = (AccessSetObj) ht2.get(obj);
                entry.and(entry2);
                ht3.put(obj, entry2);
            }
        }
        System.out.println("common set size = " + ht3.size());
        addrSet = ht3.keySet();
        itr = addrSet.iterator();
        while (itr.hasNext()) {
            long obj = (Long) itr.next();
            AccessSetObj entry = (AccessSetObj) ht3.get(obj);
            if (entry.accessInfo != null)
                System.out.println(entry.accessInfo.toString() + ":accesses="
                        + entry.accessNum);
            else
                System.out.println(":accesses=" + entry.accessNum);
        }
    }

    @Override
    public void printStatis() {
        Set addrSet = this.ht.keySet();
        Iterator itr = addrSet.iterator();
        long sizeTotal = 0;
        while (itr.hasNext()) {
            long obj = (Long) itr.next();
            AccessSetObj entry = (AccessSetObj) this.ht.get(obj);
            sizeTotal += entry.size();
        }
    }

    @Override
    public boolean isLarge() {
        // TODO: change 4096
        return (this.ht.size() > 4096);
    }

}
```


Overlapping Code:
```
ss AccessSetHt extends AccessSet {
// Normal per-object reference table
private HashMap<Long, AccessSetObj> ht;
// Flattened atomic table for faster atomic-nonatomic intersection
private HashMap<Long, AccessSetObj> flattenedATable;
// constructor for AccessSetHt
public AccessSetHt() {
ht = new HashMap<Long, AccessSetObj>();
flattenedATable = new HashMap<Long, AccessSetObj>();
}
public void setHt(HashMap<Long, AccessSetObj> hm) {
this.ht = hm;
}
public HashMap<Long, AccessSetObj> getHt() {
return ht;
}
public HashMap<Long, AccessSetObj> getFlattenedATable() {
return this.flattenedATable;
}
/**
* Hashmap print
*/
@Override
public void print(){
Long obj;
AccessSetObj entry;
System.out.println("Normal accesses");
System.out.print("{");
Set addrSet = this.ht.keySet();
Iterator itr = addrSet.iterator();
while (itr.hasNext()) {
obj = (Long) itr.next();
System.out.print(obj);
entry = (AccessSetObj) this.ht.get(obj);
if (entry != null) {
System.out.print("(");
entry.print();
System.out.print("),");
}
}
System.out.println("}");
System.out.println("Atomic accesses");
}
/**
* set intersection.
*/
@Override
public void intersect(AccessSet set, int taskType) {
// perform intersection on reads/writes
Long obj;
AccessSetObj entry2;
AccessSetObj entry;

// if incoming set is a hashtable
if (set instanceof AccessSetHt) {
AccessSetHt setHt = (AccessSetHt) set;
HashMap<Long, AccessSetObj> ht2 = setHt.getHt();
Set addrSet = ht2.keySet();
Iterator itr = addrSet.iterator();
while (itr.hasNext()) {
obj = (Long) itr.next();
entry = (AccessSetObj) this.ht.get(obj);
if (entry != null) {
// skip the reduction object on S node
if (entry.accessInfo instanceof RubyReduction
&& taskType != RaceTask.RACE_TASK_FINISH) {
continue;
}
entry2 = (AccessSetObj) ht2.get(obj);
entry.intersect(entry2, obj);
}
}

```
<Overlap Ratio: 0.9950248756218906>

---

--- 240 --
Question ID: 164cf028d5d4b440494a45ab7117d3007973708a
Original Code:
```
public class QuickSort {
    public static void main(String args[]) {
        int A[] = {23, 45, 1, 4, 58, 85, 100, 12, 32, 13, 45};
        quickSort(A, 0, A.length-1);

        for(int i: A) {
            System.out.print(i + " ");
        }
    }

    private static void quickSort(int A[], int start, int end) {
        if(start < end) {
            int partition = partition(A, start, end);
            quickSort(A, start, partition-1);
            quickSort(A, partition+1, end);
        }
    }

    /* This method creates a sub-array in-place comparing each element with the last element of the given array amd returns the
    index of the in-place sorted element which splits the whole sub-array in two unsorted in-place sub-array..
    After the whole comparison the last element will be sorted in-place in the array and there will be two sub-array such that
    they will be unsorted in nature but all the elements of them will either be smaller or larger than this in-place sorted element.

    If the numbers compared are smaller than the last element than they are swapped such that after the last element is in-place they
    form the elements of left sub-array and vice versa for elements greater than the last element. (Done by the loop in the method)
     */
    private static int partition(int A[], int start, int end) {
        int i = start-1, x = A[end], temp;
        for(int j=start; j<end; j++) {
            if(A[j]<=x) {
                i += 1;
                temp = A[i];
                A[i] = A[j];
                A[j] = temp;
            }
        }
        /* i now holds the last element of sub-array and therefore to sort the last element in-pace we need to swap it with the first
        element of the right sub-array. */

        temp = A[i+1];
        A[i+1] = A[end];
        A[end] = temp;

        return i+1;
    }

    private static int hoarePartition(int A[], int start, int end) {
        int i = start-1;
        /*
        x=A[p}
        i=p-1
        j=r+1
        repeat:
            j=j-1
            until A[j]<=x
        repeat:
            i=i+1
            until A[i]>=x
        if(i<j)
        exchange A[i] with A[j]
        else
        return j
        */
        return i+1;
    }

    /* TODO: Create a randomized version for partitioning by randomly choosing any element of the array for in-place sorting rather
    than always choosing only first or last element.
    randomly choose any element from array.
    swap with first or last element and then execute normal partitioning algorithm
    */
}
```


Overlapping Code:
```
public class QuickSort {
public static void main(String args[]) {
int A[] = {23, 45, 1, 4, 58, 85, 100, 12, 32, 13, 45};
quickSort(A, 0, A.length-1);
for(int i: A) {
System.out.print(i + " ");
}
}
private static void quickSort(int A[], int start, int end) {
if(start < end) {
int partition = partition(A, start, end);
quickSort(A, start, partition-1);
quickSort(A, partition+1, end);
}
}
/* This method creates a sub-array in-place comparing each element with the last element of the given array amd returns the
index of the in-place sorted element which splits the whole sub-array in two unsorted in-place sub-array..
After the whole comparison the last element will be sorted in-place in the array and there will be two sub-array such that
they will be unsorted in nature but all the elements of them will either be smaller or larger than this in-place sorted element.
If the numbers compared are smaller than the last element than they are swapped such that after the last element is in-place they
form the elements of left sub-array and vice versa for elements greater than the last element. (Done by the loop in the method)
*/
private static int partition(int A[], int start, int end) {
int i = start-1, x = A[end], temp;
for(int j=start; j<end; j++) {
if(A[j]<=x) {
i += 1;
temp = A[i];
A[i] = A[j];
A[j] = temp;
}
}
/* i now holds the last element of sub-array and therefore to sort the last element in-pace we need to swap it with the first
element of the right sub-array. */
temp = A[i+1];
A[i+1] = A[end];
A[end] = temp;
return i+1;
}
private static int hoarePartition(int A[], int start, int end) {
int i = start-1;
/*
x=A[p}
i=p-1
j=r+1
repeat:
j=j-1
until A[j]<=x
repeat:
i=i+1
until A[i]>=x
if(i<j)
exchange A[i] with A[j]
else
return j
*/
return i+1;
}
/* TODO: Create a randomized version for partitioning by randomly choosing any element of the array for in-place sorting rather
than always choosing only first or last element.
randomly choose an
```
<Overlap Ratio: 0.9785643070787637>

---

--- 241 --
Question ID: 3b3b5d70ff3d2c91f7fc2e714c2484c0624ad0c6
Original Code:
```
public class NetDatacenterBroker extends SimEntity {

	// TODO: remove unnecessary variables

	/** The list of submitted VMs. */
	private List<? extends Vm> vmList;

	/** The list of created VMs. */
	private List<? extends Vm> vmsCreatedList;

	/** The list of submitted {@link NetworkCloudlet NetworkCloudlets}. */
	private List<? extends NetworkCloudlet> cloudletList;

	/** The list of submitted {@link AppCloudlet AppCloudlets}. */
	private List<? extends AppCloudlet> appCloudletList;

	/** The list of submitted {@link AppCloudlet AppCloudlets}.
         * @todo attribute appears to be redundant with {@link #appCloudletList}
         */
	private final Map<Integer, Integer> appCloudletRecieved;

	/** The list of submitted {@link Cloudlet Cloudlets}.
         */
	private List<? extends Cloudlet> cloudletSubmittedList;

	/** The list of received {@link Cloudlet Cloudlets}.
         * @todo attribute appears to be redundant with {@link #cloudletSubmittedList}
         */
	private List<? extends Cloudlet> cloudletReceivedList;

	/** The number of submitted cloudlets. */
	private int cloudletsSubmitted;

	/** The number of VMs requested. */
	private int vmsRequested;

	/** The acks sent to VMs. */
	private int vmsAcks;

	/** The number of VMs destroyed. */
	private int vmsDestroyed;

	/** The list of datacenter IDs. */
	private List<Integer> datacenterIdsList;

	/** The datacenter requested IDs list. 
         * @todo attribute appears to be redundant with {@link #datacenterIdsList}
         */
	private List<Integer> datacenterRequestedIdsList;

	/** The VMs to datacenters map where each key is a VM id
         * and the corresponding value is the datacenter where the VM is placed. */
	private Map<Integer, Integer> vmsToDatacentersMap;

	/** The datacenter characteristics map where each key 
         * is the datacenter id and each value is the datacenter itself. */
	private Map<Integer, DatacenterCharacteristics> datacenterCharacteristicsList;

	public static NetworkDatacenter linkDC;

	public boolean createvmflag = true;

	public static int cachedcloudlet = 0;

	/**
	 * Creates a new DatacenterBroker object.
	 * 
	 * @param name name to be associated with this entity
	 * 
	 * @throws Exception the exception
	 * 
	 * @pre name != null
	 * @post $none
	 */
	public NetDatacenterBroker(String name) throws Exception {
		super(name);

		setVmList(new ArrayList<NetworkVm>());
		setVmsCreatedList(new ArrayList<NetworkVm>());
		setCloudletList(new ArrayList<NetworkCloudlet>());
		setAppCloudletList(new ArrayList<AppCloudlet>());
		setCloudletSubmittedList(new ArrayList<Cloudlet>());
		setCloudletReceivedList(new ArrayList<Cloudlet>());
		appCloudletRecieved = new HashMap<Integer, Integer>();

		cloudletsSubmitted = 0;
		setVmsRequested(0);
		setVmsAcks(0);
		setVmsDestroyed(0);

		setDatacenterIdsList(new LinkedList<Integer>());
		setDatacenterRequestedIdsList(new ArrayList<Integer>());
		setVmsToDatacentersMap(new HashMap<Integer, Integer>());
		setDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());

	}

	/**
	 * Sends to the broker the list with virtual machines that must be
	 * created.
	 * 
	 * @param list the list
	 * 
	 * @pre list !=null
	 * @post $none
	 */
	public void submitVmList(List<? extends Vm> list) {
		getVmList().addAll(list);
	}

	/**
	 * Sends to the broker the list of cloudlets.
	 * 
	 * @param list the list
	 * 
	 * @pre list !=null
	 * @post $none
	 */
	public void submitCloudletList(List<? extends NetworkCloudlet> list) {
		getCloudletList().addAll(list);
	}

	public static void setLinkDC(NetworkDatacenter alinkDC) {
		linkDC = alinkDC;
	}

	/**
	 * Processes events available for this Broker.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != null
	 * @post $none
	 */
	@Override
	public void processEvent(SimEvent ev) {
		switch (ev.getTag()) {
		// Resource characteristics request
			case CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST:
				processResourceCharacteristicsRequest(ev);
				break;
			// Resource characteristics answer
			case CloudSimTags.RESOURCE_CHARACTERISTICS:
				processResourceCharacteristics(ev);
				break;
			// VM Creation answer

			// A finished cloudlet returned
			case CloudSimTags.CLOUDLET_RETURN:
				processCloudletReturn(ev);
				break;
			// if the simulation finishes
			case CloudSimTags.END_OF_SIMULATION:
				shutdownEntity();
				break;
			case CloudSimTags.NextCycle:
				if (NetworkConstants.BASE) {
					createVmsInDatacenterBase(linkDC.getId());
				}

				break;
			// other unknown tags are processed by this method
			default:
				processOtherEvent(ev);
				break;
		}
	}

	/**
	 * Processes the return of a request for the characteristics of a Datacenter.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != $null
	 * @post $none
	 */
	protected void processResourceCharacteristics(SimEvent ev) {
		DatacenterCharacteristics characteristics = (DatacenterCharacteristics) ev.getData();
		getDatacenterCharacteristicsList().put(characteristics.getId(), characteristics);

		if (getDatacenterCharacteristicsList().size() == getDatacenterIdsList().size()) {
			setDatacenterRequestedIdsList(new ArrayList<Integer>());
			createVmsInDatacenterBase(getDatacenterIdsList().get(0));
		}
	}

	/**
	 * Processes a request for the characteristics of a Datacenter.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != $null
	 * @post $none
	 */

	protected void processResourceCharacteristicsRequest(SimEvent ev) {
		setDatacenterIdsList(CloudSim.getCloudResourceList());
		setDatacenterCharacteristicsList(new HashMap<Integer, DatacenterCharacteristics>());

		Log.printConcatLine(CloudSim.clock(), ": ", getName(), ": Cloud Resource List received with ",
				getDatacenterIdsList().size(), " resource(s)");

		for (Integer datacenterId : getDatacenterIdsList()) {
			sendNow(datacenterId, CloudSimTags.RESOURCE_CHARACTERISTICS, getId());
		}
	}

	/**
	 * Processes the ack received due to a request for VM creation.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != null
	 * @post $none
	 */

	/**
	 * Processes a cloudlet return event.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != $null
	 * @post $none
	 */
	protected void processCloudletReturn(SimEvent ev) {
		Cloudlet cloudlet = (Cloudlet) ev.getData();
		getCloudletReceivedList().add(cloudlet);
		cloudletsSubmitted--;
		// all cloudlets executed
		if (getCloudletList().size() == 0 && cloudletsSubmitted == 0 && NetworkConstants.iteration > 10) {
			Log.printConcatLine(CloudSim.clock(), ": ", getName(), ": All Cloudlets executed. Finishing...");
			clearDatacenters();
			finishExecution();
		} else { // some cloudlets haven't finished yet
			if (getAppCloudletList().size() > 0 && cloudletsSubmitted == 0) {
				// all the cloudlets sent finished. It means that some bount
				// cloudlet is waiting its VM be created
				clearDatacenters();
				createVmsInDatacenterBase(0);
			}

		}
	}

	/**
	 * Processes non-default received events that aren't processed by
         * the {@link #processEvent(org.cloudbus.cloudsim.core.SimEvent)} method.
         * This method should be overridden by subclasses in other to process
         * new defined events.
	 * 
	 * @param ev a SimEvent object
	 * 
	 * @pre ev != null
	 * @post $none
	 */
	protected void processOtherEvent(SimEvent ev) {
		if (ev == null) {
			Log.printConcatLine(getName(), ".processOtherEvent(): Error - an event is null.");
			return;
		}

		Log.printConcatLine(getName(), ".processOtherEvent(): ",
				"Error - event unknown by this DatacenterBroker.");
	}

	/**
	 * Creates virtual machines in a datacenter and submit/schedule cloudlets to them.
	 * 
	 * @param datacenterId Id of the Datacenter to create the VMs
	 * 
	 * @pre $none
	 * @post $none
	 */
	protected void createVmsInDatacenterBase(int datacenterId) {
		// send as much vms as possible for this datacenter before trying the
		// next one
		int requestedVms = 0;

		// All host will have two VMs (assumption) VM is the minimum unit
		if (createvmflag) {
			CreateVMs(datacenterId);
			createvmflag = false;
		}

		// generate Application execution Requests
		for (int i = 0; i < 100; i++) {
			this.getAppCloudletList().add(
					new WorkflowApp(AppCloudlet.APP_Workflow, NetworkConstants.currentAppId, 0, 0, getId()));
			NetworkConstants.currentAppId++;

		}
		int k = 0;

		// schedule the application on VMs
		for (AppCloudlet app : this.getAppCloudletList()) {

			List<Integer> vmids = new ArrayList<Integer>();
			int numVms = linkDC.getVmList().size();
			UniformDistr ufrnd = new UniformDistr(0, numVms, 5);
			for (int i = 0; i < app.numbervm; i++) {

				int vmid = (int) ufrnd.sample();
				vmids.add(vmid);

			}

			if (vmids != null) {
				if (!vmids.isEmpty()) {

					app.createCloudletList(vmids);
					for (int i = 0; i < app.numbervm; i++) {
						app.clist.get(i).setUserId(getId());
						appCloudletRecieved.put(app.appID, app.numbervm);
						this.getCloudletSubmittedList().add(app.clist.get(i));
						cloudletsSubmitted++;

						// Sending cloudlet
						sendNow(
								getVmsToDatacentersMap().get(this.getVmList().get(0).getId()),
								CloudSimTags.CLOUDLET_SUBMIT,
								app.clist.get(i));
					}
					System.out.println("app" + (k++));
				}
			}

		}
		setAppCloudletList(new ArrayList<AppCloudlet>());
		if (NetworkConstants.iteration < 10) {

			NetworkConstants.iteration++;
			this.schedule(getId(), NetworkConstants.nexttime, CloudSimTags.NextCycle);
		}

		setVmsRequested(requestedVms);
		setVmsAcks(0);
	}

        /**
         * Creates virtual machines in a datacenter
         * @param datacenterId The id of the datacenter where to create the VMs.
         */
	private void CreateVMs(int datacenterId) {
		// two VMs per host
		int numVM = linkDC.getHostList().size() * NetworkConstants.maxhostVM;
		for (int i = 0; i < numVM; i++) {
			int vmid = i;
			int mips = 1;
			long size = 10000; // image size (MB)
			int ram = 512; // vm memory (MB)
			long bw = 1000;
			int pesNumber = NetworkConstants.HOST_PEs / NetworkConstants.maxhostVM;
			String vmm = "Xen"; // VMM name

			// create VM
			NetworkVm vm = new NetworkVm(
					vmid,
					getId(),
					mips,
					pesNumber,
					ram,
					bw,
					size,
					vmm,
					new NetworkCloudletSpaceSharedScheduler());
			linkDC.processVmCreateNetwork(vm);
			// add the VM to the vmList
			getVmList().add(vm);
			getVmsToDatacentersMap().put(vmid, datacenterId);
			getVmsCreatedList().add(VmList.getById(getVmList(), vmid));
		}
	}

	/**
	 * Sends request to destroy all VMs running on the datacenter.
	 * 
	 * @pre $none
	 * @post $none /** Destroy the virtual machines running in datacenters.
	 * 
	 * @pre $none
	 * @post $none
	 */
	protected void clearDatacenters() {
		for (Vm vm : getVmsCreatedList()) {
			Log.printConcatLine(CloudSim.clock(), ": ", getName(), ": Destroying VM #", vm.getId());
			sendNow(getVmsToDatacentersMap().get(vm.getId()), CloudSimTags.VM_DESTROY, vm);
		}

		getVmsCreatedList().clear();
	}

	/**
	 * Sends an internal event communicating the end of the simulation.
	 * 
	 * @pre $none
	 * @post $none
	 */
	private void finishExecution() {
		sendNow(getId(), CloudSimTags.END_OF_SIMULATION);
	}

	@Override
	public void shutdownEntity() {
		Log.printConcatLine(getName(), " is shutting down...");
	}

	@Override
	public void startEntity() {
		Log.printConcatLine(getName(), " is starting...");
		schedule(getId(), 0, CloudSimTags.RESOURCE_CHARACTERISTICS_REQUEST);
	}

	/**
	 * Gets the vm list.
	 * 
	 * @param <T> the generic type
	 * @return the vm list
	 */
	@SuppressWarnings("unchecked")
	public <T extends Vm> List<T> getVmList() {
		return (List<T>) vmList;
	}

	/**
	 * Sets the vm list.
	 * 
	 * @param <T> the generic type
	 * @param vmList the new vm list
	 */
	protected <T extends Vm> void setVmList(List<T> vmList) {
		this.vmList = vmList;
	}

	/**
	 * Gets the cloudlet list.
	 * 
	 * @param <T> the generic type
	 * @return the cloudlet list
	 */
	@SuppressWarnings("unchecked")
	public <T extends NetworkCloudlet> List<T> getCloudletList() {
		return (List<T>) cloudletList;
	}

	/**
	 * Sets the cloudlet list.
	 * 
	 * @param <T> the generic type
	 * @param cloudletList the new cloudlet list
	 */
	protected <T extends NetworkCloudlet> void setCloudletList(List<T> cloudletList) {
		this.cloudletList = cloudletList;
	}

	@SuppressWarnings("unchecked")
	public <T extends AppCloudlet> List<T> getAppCloudletList() {
		return (List<T>) appCloudletList;
	}

	public <T extends AppCloudlet> void setAppCloudletList(List<T> appCloudletList) {
		this.appCloudletList = appCloudletList;
	}

	/**
	 * Gets the cloudlet submitted list.
	 * 
	 * @param <T> the generic type
	 * @return the cloudlet submitted list
	 */
	@SuppressWarnings("unchecked")
	public <T extends Cloudlet> List<T> getCloudletSubmittedList() {
		return (List<T>) cloudletSubmittedList;
	}

	/**
	 * Sets the cloudlet submitted list.
	 * 
	 * @param <T> the generic type
	 * @param cloudletSubmittedList the new cloudlet submitted list
	 */
	protected <T extends Cloudlet> void setCloudletSubmittedList(List<T> cloudletSubmittedList) {
		this.cloudletSubmittedList = cloudletSubmittedList;
	}

	/**
	 * Gets the cloudlet received list.
	 * 
	 * @param <T> the generic type
	 * @return the cloudlet received list
	 */
	@SuppressWarnings("unchecked")
	public <T extends Cloudlet> List<T> getCloudletReceivedList() {
		return (List<T>) cloudletReceivedList;
	}

	/**
	 * Sets the cloudlet received list.
	 * 
	 * @param <T> the generic type
	 * @param cloudletReceivedList the new cloudlet received list
	 */
	protected <T extends Cloudlet> void setCloudletReceivedList(List<T> cloudletReceivedList) {
		this.cloudletReceivedList = cloudletReceivedList;
	}

	/**
	 * Gets the vm list.
	 * 
	 * @param <T> the generic type
	 * @return the vm list
	 */
	@SuppressWarnings("unchecked")
	public <T extends Vm> List<T> getVmsCreatedList() {
		return (List<T>) vmsCreatedList;
	}

	/**
	 * Sets the vm list.
	 * 
	 * @param <T> the generic type
	 * @param vmsCreatedList the vms created list
	 */
	protected <T extends Vm> void setVmsCreatedList(List<T> vmsCreatedList) {
		this.vmsCreatedList = vmsCreatedList;
	}

	/**
	 * Gets the vms requested.
	 * 
	 * @return the vms requested
	 */
	protected int getVmsRequested() {
		return vmsRequested;
	}

	/**
	 * Sets the vms requested.
	 * 
	 * @param vmsRequested the new vms requested
	 */
	protected void setVmsRequested(int vmsRequested) {
		this.vmsRequested = vmsRequested;
	}

	/**
	 * Gets the vms acks.
	 * 
	 * @return the vms acks
	 */
	protected int getVmsAcks() {
		return vmsAcks;
	}

	/**
	 * Sets the vms acks.
	 * 
	 * @param vmsAcks the new vms acks
	 */
	protected void setVmsAcks(int vmsAcks) {
		this.vmsAcks = vmsAcks;
	}

	/**
	 * Increment vms acks.
	 */
	protected void incrementVmsAcks() {
		vmsAcks++;
	}

	/**
	 * Gets the vms destroyed.
	 * 
	 * @return the vms destroyed
	 */
	protected int getVmsDestroyed() {
		return vmsDestroyed;
	}

	/**
	 * Sets the vms destroyed.
	 * 
	 * @param vmsDestroyed the new vms destroyed
	 */
	protected void setVmsDestroyed(int vmsDestroyed) {
		this.vmsDestroyed = vmsDestroyed;
	}

	/**
	 * Gets the datacenter ids list.
	 * 
	 * @return the datacenter ids list
	 */
	protected List<Integer> getDatacenterIdsList() {
		return datacenterIdsList;
	}

	/**
	 * Sets the datacenter ids list.
	 * 
	 * @param datacenterIdsList the new datacenter ids list
	 */
	protected void setDatacenterIdsList(List<Integer> datacenterIdsList) {
		this.datacenterIdsList = datacenterIdsList;
	}

	/**
	 * Gets the vms to datacenters map.
	 * 
	 * @return the vms to datacenters map
	 */
	protected Map<Integer, Integer> getVmsToDatacentersMap() {
		return vmsToDatacentersMap;
	}

	/**
	 * Sets the vms to datacenters map.
	 * 
	 * @param vmsToDatacentersMap the vms to datacenters map
	 */
	protected void setVmsToDatacentersMap(Map<Integer, Integer> vmsToDatacentersMap) {
		this.vmsToDatacentersMap = vmsToDatacentersMap;
	}

	/**
	 * Gets the datacenter characteristics list.
	 * 
	 * @return the datacenter characteristics list
	 */
	protected Map<Integer, DatacenterCharacteristics> getDatacenterCharacteristicsList() {
		return datacenterCharacteristicsList;
	}

	/**
	 * Sets the datacenter characteristics list.
	 * 
	 * @param datacenterCharacteristicsList the datacenter characteristics list
	 */
	protected void setDatacenterCharacteristicsList(
			Map<Integer, DatacenterCharacteristics> datacenterCharacteristicsList) {
		this.datacenterCharacteristicsList = datacenterCharacteristicsList;
	}

	/**
	 * Gets the datacenter requested ids list.
	 * 
	 * @return the datacenter requested ids list
	 */
	protected List<Integer> getDatacenterRequestedIdsList() {
		return datacenterRequestedIdsList;
	}

	/**
	 * Sets the datacenter requested ids list.
	 * 
	 * @param datacenterRequestedIdsList the new datacenter requested ids list
	 */
	protected void setDatacenterRequestedIdsList(List<Integer> datacenterRequestedIdsList) {
		this.datacenterRequestedIdsList = datacenterRequestedIdsList;
	}

}
```


Overlapping Code:
```
ity {
// TODO: remove unnecessary variables
/** The list of submitted VMs. */
private List<? extends Vm> vmList;
/** The list of created VMs. */
private List<? extends Vm> vmsCreatedList;
/** The list of submitted {@link NetworkCloudlet NetworkCloudlets}. */
private List<? extends NetworkCloudlet> cloudletList;
/** The list of submitted {@link AppCloudlet AppCloudlets}. */
private List<? extends AppCloudlet> appCloudletList;
/** The list of submitted {@link AppCloudlet AppCloudlets}.
* @todo attribute appears to be redundant with {@link #appCloudletList}
*/
private final Map<Integer, Integer> appCloudletRecieved;
/** The list of submitted {@link Cloudlet Cloudlets}.
*/
private List<? extends Cloudlet> cloudletSubmittedList;
/** The list of received {@link Cloudlet Cloudlets}.
* @todo attribute appears to be redundant with {@link #cloudletSubmittedList}
*/
private List<? extends Cloudlet> cloudletReceivedList;
/** The number of submitted cloudlets. */
private int cloudletsSubmitted;
/** The number of VMs requested. */
private int vmsRequested;
/** The acks sent to VMs. */
private int vmsAcks;
/** The number of VMs destroyed. */
private int vmsDestroyed;
/** The list of datacenter IDs. */
private List<Integer> datacenterIdsList;
/** The datacenter requested IDs list. 
* @todo attribute appears to be redundant with {@link #datacenterIdsList}
*/
private List<Integer> datacenterRequestedIdsList;
/** The VMs to datacenters map where each key is a VM id
* and the corresponding value is the datacenter where the VM is placed. */
private Map<Integer, Integer> vmsToDatacentersMap;
/** The datacenter characteristics map where each key 
* is the datacenter id and each value is the datacenter itself. */
private Map<Integer, DatacenterCharacteristics> datacenterCharacteristicsList;
public static NetworkDatacenter linkDC;
public boolean createvmflag = true;
public static int cachedcloudlet = 0;
/**
* Creates a new DatacenterBroker object.
* 
* @param name name to be associated with this entity
* 
* @throws Exception the exception
* 
* @pre name != null
* @post $none
*/
public NetDatacenterBroker(String name) throws Exception {
super(name);
setVmList(new ArrayList<NetworkVm>());
setVmsCreatedList(new ArrayList<NetworkVm>());
se
```
<Overlap Ratio: 0.9635974304068522>

---

--- 242 --
Question ID: 300ca4f5b3e497ba4b83e54bdedd85b0958887c4
Original Code:
```
public class ShapeFileReader
        extends RecordReader<ShapeKey, ShpRecord>
{

    /**
     * file parser
     */
    ShpFileParser parser = null;
    /**
     * record id
     */
    private ShapeKey recordKey = null;
    /**
     * primitive bytes value
     */
    private ShpRecord recordContent = null;
    /**
     * inputstream for .shp file
     */
    private FSDataInputStream shpInputStream = null;
    /**
     * Iterator of indexes of records
     */
    private int[] indexes;

    /**
     * whether use index, true when using indexes
     */
    private boolean useIndex = false;

    /**
     * current index id
     */
    private int indexId = 0;

    /**
     * empty constructor
     */
    public ShapeFileReader()
    {
    }

    /**
     * constructor with index
     *
     * @param indexes
     */
    public ShapeFileReader(int[] indexes)
    {
        this.indexes = indexes;
        useIndex = true;
    }

    public void initialize(InputSplit split, TaskAttemptContext context)
            throws IOException, InterruptedException
    {
        FileSplit fileSplit = (FileSplit) split;
        Path filePath = fileSplit.getPath();
        FileSystem fileSys = filePath.getFileSystem(context.getConfiguration());
        shpInputStream = fileSys.open(filePath);
        //assign inputstream to parser and parse file header to init;
        parser = new ShpFileParser(shpInputStream);
        parser.parseShapeFileHead();
    }

    public boolean nextKeyValue()
            throws IOException, InterruptedException
    {
        if (useIndex) {
            /**
             * with index, iterate until end and extract bytes with information from indexes
             */
            if (indexId == indexes.length) { return false; }
            // check offset, if current offset in inputStream not match with information in shx, move it
            if (shpInputStream.getPos() < indexes[indexId] * 2) {
                shpInputStream.skip(indexes[indexId] * 2 - shpInputStream.getPos());
            }
            int currentLength = indexes[indexId + 1] * 2 - 4;
            recordKey = new ShapeKey();
            recordKey.setIndex(parser.parseRecordHeadID());
            recordContent = parser.parseRecordPrimitiveContent(currentLength);
            indexId += 2;
            return true;
        }
        else {
            if (getProgress() >= 1) { return false; }
            recordKey = new ShapeKey();
            recordKey.setIndex(parser.parseRecordHeadID());
            recordContent = parser.parseRecordPrimitiveContent();
            return true;
        }
    }

    public ShapeKey getCurrentKey()
            throws IOException, InterruptedException
    {
        return recordKey;
    }

    public ShpRecord getCurrentValue()
            throws IOException, InterruptedException
    {
        return recordContent;
    }

    public float getProgress()
            throws IOException, InterruptedException
    {
        return parser.getProgress();
    }

    public void close()
            throws IOException
    {
        shpInputStream.close();
    }
}
```


Overlapping Code:
```
blic class ShapeFileReader
extends RecordReader<ShapeKey, ShpRecord>
{
/**
* file parser
*/
ShpFileParser parser = null;
/**
* record id
*/
private ShapeKey recordKey = null;
/**
* primitive bytes value
*/
private ShpRecord recordContent = null;
/**
* inputstream for .shp file
*/
private FSDataInputStream shpInputStream = null;
/**
* Iterator of indexes of records
*/
private int[] indexes;
/**
* whether use index, true when using indexes
*/
private boolean useIndex = false;
/**
* current index id
*/
private int indexId = 0;
/**
* empty constructor
*/
public ShapeFileReader()
{
}
/**
* constructor with index
*
* @param indexes
*/
public ShapeFileReader(int[] indexes)
{
this.indexes = indexes;
useIndex = true;
}
public void initialize(InputSplit split, TaskAttemptContext context)
throws IOException, InterruptedException
{
FileSplit fileSplit = (FileSplit) split;
Path filePath = fileSplit.getPath();
FileSystem fileSys = filePath.getFileSystem(context.getConfiguration());
shpInputStream = fileSys.open(filePath);
//assign inputstream to parser and parse file header to init;
parser = new ShpFileParser(shpInputStream);
parser.parseShapeFileHead();
}
public boolean nextKeyValue()
throws IOException, InterruptedException
{
if (useIndex) {
/**
* with index, iterate until end and extract bytes with information from indexes
*/
if (indexId == indexes.length) { return false; }
// check offset, if current offset in inputStream not match with information in shx, move it
if (shpInputStream.getPos() < indexes[indexId] * 2) {
shpInputStream.skip(indexes[indexId] * 2 - shpInputStream.getPos());
}
int currentLength = indexes[indexId + 1] * 2 - 4;
recordKey = new ShapeKey();
recordKey.setIndex(parser.parseRecordHeadID());
recordContent = parser.parseRecordPrimitiveContent(currentLength);
indexId += 2;
return true;
}
else {
if (getProgress() >= 1) { return false; }
recordKey = new ShapeKey();
recordKey.setIndex(parser.parseRe
```
<Overlap Ratio: 0.9948612538540597>

---

--- 243 --
Question ID: 12b7df7d34834ca6490a0291db05919ed1c0c3b0
Original Code:
```
public class StatelessNiFiSourceConnector extends SourceConnector {
    static final String OUTPUT_PORT_NAME = "output.port";
    static final String TOPIC_NAME = "topics";

    static final String TOPIC_NAME_ATTRIBUTE = "topic.name.attribute";
    static final String KEY_ATTRIBUTE = "key.attribute";
    static final String HEADER_REGEX = "header.attribute.regex";

    private Map<String, String> properties;
    private boolean primaryNodeOnly;

    @Override
    public void start(final Map<String, String> properties) {
        this.properties = new HashMap<>(properties);

        final StatelessDataflow dataflow = StatelessKafkaConnectorUtil.createDataflow(properties);
        primaryNodeOnly = dataflow.isSourcePrimaryNodeOnly();
        dataflow.shutdown();
    }

    @Override
    public Class<? extends Task> taskClass() {
        return StatelessNiFiSourceTask.class;
    }

    @Override
    public List<Map<String, String>> taskConfigs(final int maxTasks) {
        final int numTasks = primaryNodeOnly ? 1 : maxTasks;

        final List<Map<String, String>> configs = new ArrayList<>();
        for (int i=0; i < numTasks; i++) {
            final Map<String, String> taskConfig = new HashMap<>(properties);
            taskConfig.put("task.index", String.valueOf(i));
            configs.add(taskConfig);
        }

        return configs;
    }

    @Override
    public void stop() {

    }

    @Override
    public ConfigDef config() {
        final ConfigDef configDef = new ConfigDef();
        StatelessKafkaConnectorUtil.addCommonConfigElements(configDef);

        configDef.define(OUTPUT_PORT_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH, "The name of the Output Port to pull data from");
        configDef.define(TOPIC_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH,
            "The name of the Kafka topic to send data to. Either the topics or topic.name.attribute configuration must be specified.");

        configDef.define(TOPIC_NAME_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM,
            "Specifies the name of a FlowFile attribute to use for determining which Kafka Topic a FlowFile"
            + " will be sent to. Either the topic.name or topic.name.attribute configuration must be specified. If both are specified, the topic.name.attribute will be preferred, but if a FlowFile"
            + " does not have the specified attribute name, then the topic.name property will serve as the default topic name to use.");

        configDef.define(KEY_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM, "Specifies the name of a FlowFile attribute to use for determining the Kafka Message key. If not"
            + " specified, the message key will be null. If specified, the value of the attribute with the given name will be used as the message key.");

        configDef.define(HEADER_REGEX, ConfigDef.Type.STRING, null, new ConnectRegularExpressionValidator(), ConfigDef.Importance.MEDIUM,
            "Specifies a Regular Expression to evaluate against all FlowFile attributes. Any attribute whose name"
            + " matches the Regular Expression will be converted into a Kafka message header with the name of the attribute used as header key and the value of the attribute used as the header"
            + " value.");

        return configDef;
    }

    @Override
    public String version() {
        return StatelessKafkaConnectorUtil.getVersion();
    }
}
```


Overlapping Code:
```
iFiSourceConnector extends SourceConnector {
static final String OUTPUT_PORT_NAME = "output.port";
static final String TOPIC_NAME = "topics";
static final String TOPIC_NAME_ATTRIBUTE = "topic.name.attribute";
static final String KEY_ATTRIBUTE = "key.attribute";
static final String HEADER_REGEX = "header.attribute.regex";
private Map<String, String> properties;
private boolean primaryNodeOnly;
@Override
public void start(final Map<String, String> properties) {
this.properties = new HashMap<>(properties);
final StatelessDataflow dataflow = StatelessKafkaConnectorUtil.createDataflow(properties);
primaryNodeOnly = dataflow.isSourcePrimaryNodeOnly();
dataflow.shutdown();
}
@Override
public Class<? extends Task> taskClass() {
return StatelessNiFiSourceTask.class;
}
@Override
public List<Map<String, String>> taskConfigs(final int maxTasks) {
final int numTasks = primaryNodeOnly ? 1 : maxTasks;
final List<Map<String, String>> configs = new ArrayList<>();
for (int i=0; i < numTasks; i++) {
final Map<String, String> taskConfig = new HashMap<>(properties);
taskConfig.put("task.index", String.valueOf(i));
configs.add(taskConfig);
}
return configs;
}
@Override
public void stop() {
}
@Override
public ConfigDef config() {
final ConfigDef configDef = new ConfigDef();
StatelessKafkaConnectorUtil.addCommonConfigElements(configDef);
configDef.define(OUTPUT_PORT_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH, "The name of the Output Port to pull data from");
configDef.define(TOPIC_NAME, ConfigDef.Type.STRING, null, ConfigDef.Importance.HIGH,
"The name of the Kafka topic to send data to. Either the topics or topic.name.attribute configuration must be specified.");
configDef.define(TOPIC_NAME_ATTRIBUTE, ConfigDef.Type.STRING, null, ConfigDef.Importance.MEDIUM,
"Specifies the name of a FlowFile attribute to use for determining which Kafka Topic a FlowFile"
+ " will be sent to. Either the topic.name or topic.name.attribute configuration must be specified. If both are specified, the topic.name.attribute will be preferred, but if a FlowFile"
+ " does not have the specified attribute name, then the topic.name property will serve as the defa
```
<Overlap Ratio: 0.9854346836595357>

---

--- 244 --
Question ID: 315dc5b716520499b640778d8d95dea295c56069
Original Code:
```
public class ItemAdapter extends PagedListAdapter<Image, ItemAdapter.ItemViewHolder> {

    private static DiffUtil.ItemCallback<Image> DIFF_CALLBACK =
            new DiffUtil.ItemCallback<Image>() {
                @Override
                public boolean areItemsTheSame(Image oldItem, Image newItem) {
                    return oldItem.getId() == newItem.getId();
                }

                @Override
                public boolean areContentsTheSame(Image oldItem, Image newItem) {
                    return oldItem.equals(newItem);
                }
            };
    private Context mCtx;

    public ItemAdapter(Context mCtx) {
        super(DIFF_CALLBACK);
        this.mCtx = mCtx;
    }

    @NonNull
    @Override
    public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(mCtx).inflate(R.layout.image_layout, parent, false);
        return new ItemViewHolder(view);
    }

    @Override
    public void onBindViewHolder(@NonNull ItemViewHolder holder, int position) {
        final Image image = getItem(position);
        holder.userName.setText(image.getUser().toString());
        holder.like.setText(image.getLikes().toString());
        holder.comments.setText(image.getComments().toString());

        Picasso.get()
                .load(image.getLargeImageURL())
                .placeholder(R.drawable.shimmer_background)
                .into(holder.image);

        Transformation transformation = new RoundedTransformationBuilder()
                .borderColor(Color.BLACK)
                .borderWidthDp(1)
                .cornerRadiusDp(30)
                .oval(false)
                .build();

        if (!image.getUserImageURL().isEmpty()) {
            Picasso.get()
                    .load(image.getUserImageURL())
                    .fit()
                    .transform(transformation)
                    .into(holder.userImage);
        }
    }

    class ItemViewHolder extends RecyclerView.ViewHolder {

        TextView userName, like, comments;
        ImageView image, userImage;

        public ItemViewHolder(View view) {
            super(view);
            image = view.findViewById(R.id.image);
            userImage = view.findViewById(R.id.user_image);
            userName = view.findViewById(R.id.user);
            like = view.findViewById(R.id.like);
            comments = view.findViewById(R.id.comments);
        }
    }
}
```


Overlapping Code:
```
edListAdapter<Image, ItemAdapter.ItemViewHolder> {
private static DiffUtil.ItemCallback<Image> DIFF_CALLBACK =
new DiffUtil.ItemCallback<Image>() {
@Override
public boolean areItemsTheSame(Image oldItem, Image newItem) {
return oldItem.getId() == newItem.getId();
}
@Override
public boolean areContentsTheSame(Image oldItem, Image newItem) {
return oldItem.equals(newItem);
}
};
private Context mCtx;
public ItemAdapter(Context mCtx) {
super(DIFF_CALLBACK);
this.mCtx = mCtx;
}
@NonNull
@Override
public ItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
View view = LayoutInflater.from(mCtx).inflate(R.layout.image_layout, parent, false);
return new ItemViewHolder(view);
}
@Override
public void onBindViewHolder(@NonNull ItemViewHolder holder, int position) {
final Image image = getItem(position);
holder.userName.setText(image.getUser().toString());
holder.like.setText(image.getLikes().toString());
holder.comments.setText(image.getComments().toString());
Picasso.get()
.load(image.getLargeImageURL())
.placeholder(R.drawable.shimmer_background)
.into(holder.image);
Transformation transformation = new RoundedTransformationBuilder()
.borderColor(Color.BLACK)
.borderWidthDp(1)
.cornerRadiusDp(30)
.oval(false)
.build();
if (!image.getUserImageURL().isEmpty()) {
Picasso.get()
.load(image.getUserImageURL())
.fit()
.transform(transformation)
.into(holder.userImage);
}
}
class ItemViewHolder extends RecyclerView.ViewHolder {
TextView userName, like, comments;
ImageView image, userImage;
public ItemViewHolder(View view) {
super(view);
image = view.findViewById(R.id.image);
userImage = view.findViewById(R.id.user_image);
userName = view.findViewById(R.id.user);
like = view.findViewById(R.id.like);
comments = view.f
```
<Overlap Ratio: 0.9620670698185816>

---

--- 245 --
Question ID: af71b46898b0e48473f62f85ac57e4d7ad732427
Original Code:
```
public class HeartbeatFieldsTest {
    
    private HeartbeatFields createTestSubject() {
        return new HeartbeatFields();
    }
    
    @Test
    public void testGetAdditionalFields() throws Exception {
        HeartbeatFields testSubject;
        List<AlarmAdditionalInformation> result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.getAdditionalFields();
    }
    
    @Test
    public void testSetAdditionalFields() throws Exception {
        HeartbeatFields testSubject;
        List<AlarmAdditionalInformation> additionalFields = null;
        
        
        // default test
        testSubject = createTestSubject();
        testSubject.setAdditionalFields(additionalFields);
    }
    
    @Test
    public void testGetHeartbeatFieldsVersion() throws Exception {
        HeartbeatFields testSubject;
        Double result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.getHeartbeatFieldsVersion();
    }
    
    @Test
    public void testSetHeartbeatFieldsVersion() throws Exception {
        HeartbeatFields testSubject;
        Double heartbeatFieldsVersion = null;
        
        
        // default test
        testSubject = createTestSubject();
        testSubject.setHeartbeatFieldsVersion(heartbeatFieldsVersion);
    }
    
    @Test
    public void testGetHeartbeatInterval() throws Exception {
        HeartbeatFields testSubject;
        Integer result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.getHeartbeatInterval();
    }
    
    @Test
    public void testSetHeartbeatInterval() throws Exception {
        HeartbeatFields testSubject;
        Integer heartbeatInterval = 0;
        
        
        // default test
        testSubject = createTestSubject();
        testSubject.setHeartbeatInterval(heartbeatInterval);
    }
    
    @Test
    public void testToString() throws Exception {
        HeartbeatFields testSubject;
        String result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.toString();
    }
    
    @Test
    public void testGetAdditionalProperties() throws Exception {
        HeartbeatFields testSubject;
        Map<String, Object> result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.getAdditionalProperties();
    }
    
    @Test
    public void testSetAdditionalProperty() throws Exception {
        HeartbeatFields testSubject;
        String name = "";
        Object value = null;
        
        
        // default test
        testSubject = createTestSubject();
        testSubject.setAdditionalProperty(name, value);
    }
    
    @Test
    public void testHashCode() throws Exception {
        HeartbeatFields testSubject;
        int result;
        
        // default test
        testSubject = createTestSubject();
        result = testSubject.hashCode();
    }
    
    
}
```


Overlapping Code:
```
lic class HeartbeatFieldsTest {

private HeartbeatFields createTestSubject() {
return new HeartbeatFields();
}

@Test
public void testGetAdditionalFields() throws Exception {
HeartbeatFields testSubject;
List<AlarmAdditionalInformation> result;

// default test
testSubject = createTestSubject();
result = testSubject.getAdditionalFields();
}

@Test
public void testSetAdditionalFields() throws Exception {
HeartbeatFields testSubject;
List<AlarmAdditionalInformation> additionalFields = null;


// default test
testSubject = createTestSubject();
testSubject.setAdditionalFields(additionalFields);
}

@Test
public void testGetHeartbeatFieldsVersion() throws Exception {
HeartbeatFields testSubject;
Double result;

// default test
testSubject = createTestSubject();
result = testSubject.getHeartbeatFieldsVersion();
}

@Test
public void testSetHeartbeatFieldsVersion() throws Exception {
HeartbeatFields testSubject;
Double heartbeatFieldsVersion = null;


// default test
testSubject = createTestSubject();
testSubject.setHeartbeatFieldsVersion(heartbeatFieldsVersion);
}

@Test
public void testGetHeartbeatInterval() throws Exception {
HeartbeatFields testSubject;
Integer result;

// default test
testSubject = createTestSubject();
result = testSubject.getHeartbeatInterval();
}

@Test
public void testSetHeartbeatInterval() throws Exception {
HeartbeatFields testSubject;
Integer heartbeatInterval = 0;


// default test
testSubject = createTestSubject();
testSubject.setHeartbeatInterval(heartbeatInterval);
}

@Test
public void testToString() throws Exception {
HeartbeatFields testSubject;
String result;

// default test
testSubject = createTestSubject();
result = testSubject.toString();
}

@Test
public void testGetAdditionalProperties() throws Exception {
HeartbeatFields testSubject;
Map<String, Object> result;

// default test
testSubject = createTestSu
```
<Overlap Ratio: 0.9983957219251337>

---

--- 246 --
Question ID: 970f5700706d07e21a4327e16524f72c8de70fa5
Original Code:
```
public class AuthVerticle extends AbstractVerticle {

    @Override
    public void start() throws Exception {
        super.start();
        HttpServer server = vertx.createHttpServer();
        Router router = Router.router(vertx);
        router.post("/login").handler(BodyHandler.create());
        router.post("/login").handler(this::login);
        router.get("/validAccessToken/:token").handler(this::validToken);
        router.post("/refreshToken").handler(BodyHandler.create());
        router.post("/refreshToken").handler(this::refreshToken);
        router.post("/recoverPass").handler(BodyHandler.create());
        router.post("/recoverPass").handler(this::recoverPass);
        router.post("/restorePass").handler(BodyHandler.create());
        router.post("/restorePass").handler(this::restorePass);
        router.post("/resetPass").handler(BodyHandler.create());
        router.post("/resetPass").handler(this::resetPass);
        UtilsRouter.getInstance(vertx).mountSubRouter("/auth", router);
        Integer portNumber = config().getInteger(CONFIG_HTTP_SERVER_PORT);
        if (portNumber == null) {
            System.out.println("Could not start a HTTP server" + this.getClass().getSimpleName() + ", no port speficied in configuration");
        }
        server.requestHandler(UtilsRouter.getInstance(vertx)::accept)
                .listen(portNumber, ar -> {
                    if (ar.succeeded()) {
                        System.out.println(this.getClass().getSimpleName() + " running");
                    } else {
                        System.out.println("Could not start a HTTP server " + this.getClass().getSimpleName() + ", " + ar.cause());
                    }
                });
    }

    private void login(RoutingContext context) {
        JsonObject body = context.getBodyAsJson();
        String email = body.getString("email");
        String pass = UtilsSecurity.encodeSHA256(body.getString("pass"));
        JsonObject send = new JsonObject()
                .put("email", email)
                .put("pass", pass);
        DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_LOGIN);
        this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options,
                (AsyncResult<Message<JsonObject>> reply) -> {
                    if (reply.succeeded()) {
                        if (reply.result().body() == null) {
                            UtilsResponse.responseWarning(context, "User and/or password are invalid");
                        } else {
                            JsonObject result = reply.result().body();
                            result.put("accessToken", UtilsJWT.generateAccessToken(result.getInteger("id")))
                                    .put("refreshToken", UtilsJWT.generateRefreshToken(result.getInteger("id")));
                            UtilsResponse.responseOk(context, result);
                        }
                    } else {
                        responseError(context, UNEXPECTED_ERROR, reply.cause().getMessage());
                    }
                });

    }

    private void validToken(RoutingContext context) {
        String token = context.request().getParam("token");
        if (UtilsJWT.isAccessTokenValid(token)) {
            UtilsResponse.responseOk(context, "valid");
        } else {
            UtilsResponse.responseWarning(context, "not valid");
        }
    }

    private void refreshToken(RoutingContext context) {
        try {
            JsonObject body = context.getBodyAsJson();
            JsonObject newAccessToken = UtilsJWT.refreshToken(body.getString("refreshToken"), body.getString("accessToken"));
            UtilsResponse.responseOk(context, new JsonObject().put("newAccessToken", newAccessToken));
        } catch (RefreshException ex) {
            UtilsResponse.responseWarning(context, ex.getMessage(), ex.getRefreshProblem());
        } catch (Exception ex) {
            UtilsResponse.responseWarning(context, ex.getMessage());
        }
    }

    private void recoverPass(RoutingContext context) {
        JsonObject body = context.getBodyAsJson();
        this.vertx.eventBus().send(
                EmployeeDBV.class.getSimpleName(),
                body, new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_FIND_BY_MAIL),
                (AsyncResult<Message<JsonObject>> reply) -> {
                    if (reply.succeeded()) {
                        if (reply.result().body() != null) {
                            Random r = new Random();
                            //generar codigo de 8 digitos aleatorios
                            String code = String.valueOf(r.nextInt(99));
                            code += String.valueOf(r.nextInt(99));
                            code += String.valueOf(r.nextInt(99));
                            code += String.valueOf(r.nextInt(99));

                            final String employeeMail = reply.result().body().getString("email");
                            final String recoverCode = code;

                            JsonObject send = new JsonObject()
                                    .put("employee_email", employeeMail)
                                    .put("employee_name", reply.result().body().getString("name"))
                                    .put("recover_code", recoverCode);

                            this.vertx.eventBus().send(MailVerticle.class.getSimpleName(), send,
                                    new DeliveryOptions()
                                            .addHeader(ACTION, MailVerticle.ACTION_SEND_RECOVER_PASS),
                                    mailReply -> {
                                        if (mailReply.succeeded()) {
                                            String jws = UtilsJWT.generateRecoverPasswordToken(recoverCode, employeeMail);
                                            responseOk(context, new JsonObject()
                                                    .put("recover_token", jws), "Mail with code sended");
                                        } else {
                                            responseWarning(context, "can't send mail",
                                                    mailReply.cause().getMessage());
                                        }
                                    });
                        } else {
                            responseWarning(context, "Employee not found");
                        }
                    } else {
                        responseWarning(context, "can't found employee", reply.cause().getMessage());
                    }
                }
        );
    }

    private void restorePass(RoutingContext context) {
        JsonObject body = context.getBodyAsJson();
        String recoverCode = body.getString("recoverCode");
        String recoverToken = body.getString("recoverToken");
        String newPassword = body.getString("newPassword");
        UtilsJWT.RecoverValidation validation = UtilsJWT.isRecoverTokenMatching(recoverToken, recoverCode);
        if (validation.isValid()) {
            JsonObject send = new JsonObject()
                    .put("employee_email", validation.getEmployeeMail())
                    .put("new_password", UtilsSecurity.encodeSHA256(newPassword));
            DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_UPDATE_PASSWORD);
            this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options, reply -> {
                if (reply.succeeded()) {
                    responseOk(context, "Password restored");
                } else {
                    responseError(context, reply.cause().getMessage());
                }
            });
        } else {
            UtilsResponse.responseWarning(context, "Recover code or recover token are not matching");
        }
    }

    private void resetPass(RoutingContext context) {
        String token = context.request().headers().get(AUTHORIZATION);
        if (UtilsJWT.isAccessTokenValid(token)) {
            JsonObject body = context.getBodyAsJson();
            try {
                UtilsValidation.isGraterEqualAndNotNull(body, "employee_id", 0);
                UtilsValidation.isEmptyAndNotNull(body, "actual_pass");
                UtilsValidation.isEmptyAndNotNull(body, "new_pass");
                int employeeId = UtilsJWT.getEmployeeIdFrom(token);
                String actualPass = body.getString("actual_pass");
                String newPass = body.getString("new_pass");
                if (newPass.equals(actualPass)) {
                    responseWarning(context, "The new password can not be equal to the previous one");
                    return;
                }
                String actualPassEncoded = UtilsSecurity.encodeSHA256(actualPass);
                String newPassEncoded = UtilsSecurity.encodeSHA256(newPass);

                DeliveryOptions options = new DeliveryOptions()
                        .addHeader(ACTION, EmployeeDBV.ACTION_VALIDATE_PASS);

                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),
                        new JsonObject()
                                .put("employee_id", employeeId)
                                .put("pass", actualPassEncoded),
                        options,
                        reply -> {
                            if (reply.succeeded()) {
                                //update pass
                                DeliveryOptions optionsUpdate = new DeliveryOptions()
                                        .addHeader(ACTION, EmployeeDBV.ACTION_RESET_PASS);
                                this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(),
                                        new JsonObject()
                                                .put("employee_id", employeeId)
                                                .put("pass", newPassEncoded),
                                        optionsUpdate,
                                        updateReply -> {
                                            if (updateReply.succeeded()) {
                                                responseOk(context, "Pass reseted");
                                            } else {
                                                responseError(context, updateReply.cause().getMessage());
                                            }
                                        });
                            } else {
                                responseWarning(context, "Invalid actual password");
                            }
                        });
            } catch (UtilsValidation.PropertyValueException ex) {
                responsePropertyValue(context, ex);
            }
        } else {
            UtilsResponse.responseInvalidToken(context);
        }
    }

}
```


Overlapping Code:
```
lic class AuthVerticle extends AbstractVerticle {
@Override
public void start() throws Exception {
super.start();
HttpServer server = vertx.createHttpServer();
Router router = Router.router(vertx);
router.post("/login").handler(BodyHandler.create());
router.post("/login").handler(this::login);
router.get("/validAccessToken/:token").handler(this::validToken);
router.post("/refreshToken").handler(BodyHandler.create());
router.post("/refreshToken").handler(this::refreshToken);
router.post("/recoverPass").handler(BodyHandler.create());
router.post("/recoverPass").handler(this::recoverPass);
router.post("/restorePass").handler(BodyHandler.create());
router.post("/restorePass").handler(this::restorePass);
router.post("/resetPass").handler(BodyHandler.create());
router.post("/resetPass").handler(this::resetPass);
UtilsRouter.getInstance(vertx).mountSubRouter("/auth", router);
Integer portNumber = config().getInteger(CONFIG_HTTP_SERVER_PORT);
if (portNumber == null) {
System.out.println("Could not start a HTTP server" + this.getClass().getSimpleName() + ", no port speficied in configuration");
}
server.requestHandler(UtilsRouter.getInstance(vertx)::accept)
.listen(portNumber, ar -> {
if (ar.succeeded()) {
System.out.println(this.getClass().getSimpleName() + " running");
} else {
System.out.println("Could not start a HTTP server " + this.getClass().getSimpleName() + ", " + ar.cause());
}
});
}
private void login(RoutingContext context) {
JsonObject body = context.getBodyAsJson();
String email = body.getString("email");
String pass = UtilsSecurity.encodeSHA256(body.getString("pass"));
JsonObject send = new JsonObject()
.put("email", email)
.put("pass", pass);
DeliveryOptions options = new DeliveryOptions().addHeader(ACTION, EmployeeDBV.ACTION_LOGIN);
this.vertx.eventBus().send(EmployeeDBV.class.getSimpleName(), send, options,
(AsyncResult<Message<JsonObject>> reply) -> {
if (reply.succeeded()) {
if (reply.result().body() == null) {
UtilsResponse.responseWarning(context, "User and
```
<Overlap Ratio: 0.9975111996017919>

---

--- 247 --
Question ID: 0e329b1f30629aebe33f9da7a79931d96525d81f
Original Code:
```
class SequentialSearchST<Key, Value> {
    private int N;
    private Node first;
    private class Node {
        Key key;
        Value val;
        Node next;

        public Node(Key key, Value val, Node next) {
            this.key = key;
            this.val = val;
            this.next = next;
        }
    }

    public Value get(Key key) {
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) return x.val;
        }
        return null;
    }

    public void put(Key key, Value val) {
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) {
                x.val = val;
                return;
            }
        }
        first = new Node(key, val, first);
        N++;
    }

    public Key delete(Key key) {
        Node prev = null;
        for (Node x = first; x != null; prev = x, x = x.next) {
            if (key.equals(x.key)) {
                prev.next = x.next;
                N--;
                return key;
            }
        }
        return null;
    }

    public int size() {
        return N;
    }

    public Iterable<Key> keys() {
        List<Key> list = new ArrayList<Key>();
        for (Node x = first; x != null; x = x.next) {
            list.add(x.key);
        }
        return list;
    }
}
```


Overlapping Code:
```
SequentialSearchST<Key, Value> {
private int N;
private Node first;
private class Node {
Key key;
Value val;
Node next;
public Node(Key key, Value val, Node next) {
this.key = key;
this.val = val;
this.next = next;
}
}
public Value get(Key key) {
for (Node x = first; x != null; x = x.next) {
if (key.equals(x.key)) return x.val;
}
return null;
}
public void put(Key key, Value val) {
for (Node x = first; x != null; x = x.next) {
if (key.equals(x.key)) {
x.val = val;
return;
}
}
first = new Node(key, val, first);
N++;
}
public Key delete(Key key) {
Node prev = null;
for (Node x = first; x != null; prev = x, x = x.next) {
if (key.equals(x.key)) {
prev.next = x.next;
N--;
return key;
}
}
return null;
}
public int size() {
return N;
}
public Iterable<Key> keys() {
List<Key> list = new ArrayList<Key>();
for (Node x = first; x != null; x = x.next) {
list.add(x.key);
}
return lis
```
<Overlap Ratio: 0.9865921787709497>

---

--- 248 --
Question ID: bd407743f079c1913d3f4aa526acfab7ae0bcab8
Original Code:
```
public class GoogleSearchPageObjTest {
    WebDriver driver;

    @Before
    public void setUp() throws Exception {
        driver = new FirefoxDriver();
    }

    @Test
    public void workWithBasicAuthTest() {
        GoogleSearchPageObj google = new GoogleSearchPageObj(driver);
        google.searchFor("elemental selenium tips");
        boolean result = google.searchResultPresent("Recieve a Free, Weekly tip");
        assert (result == true);
    }

    @After
    public void tearDown() throws Exception {
        driver.quit();
    }
}
```


Overlapping Code:
```
Test {
WebDriver driver;
@Before
public void setUp() throws Exception {
driver = new FirefoxDriver();
}
@Test
public void workWithBasicAuthTest() {
GoogleSearchPageObj google = new GoogleSearchPageObj(driver);
google.searchFor("elemental selenium tips");
boolean result = google.searchResultPresent("Recieve a Free, Weekly tip");
assert (result == true);
}
@After
public void tearDown() throws Exception {
driver.quit();
}
}
```
<Overlap Ratio: 0.9298245614035088>

---

--- 249 --
Question ID: dfbafe37aa9d022d5eb6e4c8b3b6525d08803b4e
Original Code:
```
public class BooksServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        if (request.getParameter("logout") != null) {
            request.getSession().invalidate();
            response.sendRedirect("/books");
            return;
        }

        request.setAttribute("books", BookStore.getBooks());
        RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/public/books.jsp");
        dispatcher.forward(request, response);

    }

}
```


Overlapping Code:
```
ass BooksServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
if (request.getParameter("logout") != null) {
request.getSession().invalidate();
response.sendRedirect("/books");
return;
}
request.setAttribute("books", BookStore.getBooks());
RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/public/books.jsp");
dispatcher.forward(request, response);
}
}
```
<Overlap Ratio: 0.9815950920245399>

---

--- 250 --
Question ID: 6b130a36718fb7270bcfef6b4ed8c9940deee72e
Original Code:
```
public class CharArrayCodec implements BCodec<char[]> {

  /**
   * Get the char hmap, creates it if it does not already exist.
   *
   * @return a <code>char[]</code> value
   */
  public static char[] getCharMap() {
    if (CharArrayCodec.charMap == null)
      setLocale();
    return CharArrayCodec.charMap;
  }
  /**
   * Get the locale, sets the locale to default if it is not already set,
   * and if so also creates the char hmap.
   *
   * @return a <code>Locale</code> value
   */
  public static Locale getLocale() {
    if (CharArrayCodec.charMap == null)
      setLocale();
    return CharArrayCodec.locale;
  }


  /**
   * Set the locale to the default, also creates the precompiled charmap
   */
  public static void setLocale() {
    setLocale(Locale.getDefault());
  }


  /**
   * Set the locale, also creates the precompiled charmap
   *
   * @param locale
   *          a <code>Locale</code> value
   */
  public static void setLocale(Locale locale) {
    CharArrayCodec.locale = locale;
    CharArrayCodec.charMap = new CompiledLocale().getCompiledLocale(locale);
  }

  /**
   * Set the locale and the pre compiled charmap
   *
   * @param locale
   *          a <code>Locale</code> to set
   * @param charmap
   *          charmap to set
   */
  public static void setLocale(Locale locale, char[] charmap) {
    CharArrayCodec.locale = locale;
    CharArrayCodec.charMap = charmap;
  }

  private static char[] toChars(CharSequence str){
    char[] val = new char[str.length()];
    for(int i = 0; i < val.length; i++)
      val[i] = str.charAt(i);
    return val;
  }


  private static char[] charMap = null;

  private static Locale locale = null;

  @Override
  public int compare(char[] first, char[] second) {
    int n = Math.min(first.length, second.length);
    int i = 0;
    char c1,c2;
    if (charMap == null){
      while(n-- != 0){
        c1 = first[i];
        c2 = second[i];
        if(c1 != c2) return c1 - c2;
        i++;
      }
    }
    else {
      while(n-- != 0){
        c1 = charMap[(int) first[i]];
        c2 = charMap[(int) second[i]];
        if(c1 != c2) return c1-c2;
        i++;
      }
    }
    return first.length - second.length;
  }

  @Override
  public int byteSize(char[] value) {
    return CodecUtil.byteSize(UtfUtil.utfLength(value), true);
  }

  @Override
  public int byteSize(ByteBuffer bb) {
    return CodecUtil.peekSize(bb, true);
  }

  @Override
  public char[] from(ByteBuffer bb) {
    int length = CodecUtil.getSize(bb, true);
    return UtfUtil.decodeChars(bb, length);
  }

  @Override
  public void to(char[] value, ByteBuffer bb) {
      CodecUtil.putSize(UtfUtil.utfLength(value), bb, true);
      UtfUtil.encode(value, bb);
  }


  @Override
  public int byteCompare(int offset1, byte[] b1, int offset2, byte[] b2) {
    return charMap == null ? UtfUtil.compare(b1, offset1, b2, offset2) :
        UtfUtil.compare(b1, offset1, b2, offset2, charMap);
  }

  @Override
  public int byteCompare(int offset1, ByteBuffer bb1, int offset2,
                         ByteBuffer bb2) {
    return charMap == null ? UtfUtil.compare(bb1, offset1, bb2, offset2) :
        UtfUtil.compare(bb1, offset1, bb2, offset2, charMap);
  }

  @Override
  public int byteCompare(int offset1, int offset2, byte[] b) {
    return charMap == null ? UtfUtil.compare(b, offset1, b, offset2) :
        UtfUtil.compare(b, offset1, b, offset2, charMap);
  }

  /*@Override
  public boolean equals(Object o) {
    if(o instanceof CBCharArray) {
      int ret =  compareTo((CBCharArray) o);
      return ret == 0;
    }
    return false;
  }*/



}
```


Overlapping Code:
```
ass CharArrayCodec implements BCodec<char[]> {
/**
* Get the char hmap, creates it if it does not already exist.
*
* @return a <code>char[]</code> value
*/
public static char[] getCharMap() {
if (CharArrayCodec.charMap == null)
setLocale();
return CharArrayCodec.charMap;
}
/**
* Get the locale, sets the locale to default if it is not already set,
* and if so also creates the char hmap.
*
* @return a <code>Locale</code> value
*/
public static Locale getLocale() {
if (CharArrayCodec.charMap == null)
setLocale();
return CharArrayCodec.locale;
}
/**
* Set the locale to the default, also creates the precompiled charmap
*/
public static void setLocale() {
setLocale(Locale.getDefault());
}
/**
* Set the locale, also creates the precompiled charmap
*
* @param locale
* a <code>Locale</code> value
*/
public static void setLocale(Locale locale) {
CharArrayCodec.locale = locale;
CharArrayCodec.charMap = new CompiledLocale().getCompiledLocale(locale);
}
/**
* Set the locale and the pre compiled charmap
*
* @param locale
* a <code>Locale</code> to set
* @param charmap
* charmap to set
*/
public static void setLocale(Locale locale, char[] charmap) {
CharArrayCodec.locale = locale;
CharArrayCodec.charMap = charmap;
}
private static char[] toChars(CharSequence str){
char[] val = new char[str.length()];
for(int i = 0; i < val.length; i++)
val[i] = str.charAt(i);
return val;
}
private static char[] charMap = null;
private static Locale locale = null;
@Override
public int compare(char[] first, char[] second) {
int n = Math.min(first.length, second.length);
int i = 0;
char c1,c2;
if (charMap == null){
while(n-- != 0){
c1 = first[i];
c2 = second[i];
if(c1 != c2) return c1 - c2;
i++;
}
}
else {
while(n-- != 0){
c1 = charMap[(int) first[i]];
c2 = charMap[(int) second[i]];
if(c1 != c2) return c1-c2;
i++;
}
}
return first.length - second.length;
}
@Override
public int byteSize(char[] value) {
return CodecUtil.byteSize(UtfUtil.utfLength(value), true);
}
@Override
public int byteSize(ByteBuffer bb) {
return CodecUtil.peekSize(bb, true);
}
@Override
public char[] from(ByteBuffer bb) {
int len
```
<Overlap Ratio: 0.985452839042703>

---

--- 251 --
Question ID: 2cc6a074eb6321bdac1d18228d84b9ee6d635704
Original Code:
```
@Test(testName = "client.hotrod.query.RemoteQueryDslConditionsIspnDirTest", groups = "functional")
public class RemoteQueryDslConditionsIspnDirTest extends RemoteQueryDslConditionsTest {

   private static final String TEST_CACHE_NAME = "testCache";

   @Override
   protected void createCacheManagers() throws Throwable {
      GlobalConfigurationBuilder globalBuilder = new GlobalConfigurationBuilder().clusteredDefault();
      globalBuilder.serialization().addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);
      createClusteredCaches(1, globalBuilder, new ConfigurationBuilder(), true);

      ConfigurationBuilder cfg = getConfigurationBuilder();
      manager(0).defineConfiguration(TEST_CACHE_NAME, cfg.build());
      cache = manager(0).getCache(TEST_CACHE_NAME);

      hotRodServer = HotRodClientTestingUtil.startHotRodServer(manager(0));

      org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder();
      clientBuilder.addServer().host("127.0.0.1").port(hotRodServer.getPort()).addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);
      remoteCacheManager = new RemoteCacheManager(clientBuilder.build());
      remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);
   }

   @Override
   protected ConfigurationBuilder getConfigurationBuilder() {
      ConfigurationBuilder builder = super.getConfigurationBuilder();
      builder.indexing().addProperty("default.directory_provider", "local-heap");
      return builder;
   }
}
```


Overlapping Code:
```
.hotrod.query.RemoteQueryDslConditionsIspnDirTest", groups = "functional")
public class RemoteQueryDslConditionsIspnDirTest extends RemoteQueryDslConditionsTest {
private static final String TEST_CACHE_NAME = "testCache";
@Override
protected void createCacheManagers() throws Throwable {
GlobalConfigurationBuilder globalBuilder = new GlobalConfigurationBuilder().clusteredDefault();
globalBuilder.serialization().addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);
createClusteredCaches(1, globalBuilder, new ConfigurationBuilder(), true);
ConfigurationBuilder cfg = getConfigurationBuilder();
manager(0).defineConfiguration(TEST_CACHE_NAME, cfg.build());
cache = manager(0).getCache(TEST_CACHE_NAME);
hotRodServer = HotRodClientTestingUtil.startHotRodServer(manager(0));
org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder = HotRodClientTestingUtil.newRemoteConfigurationBuilder();
clientBuilder.addServer().host("127.0.0.1").port(hotRodServer.getPort()).addContextInitializers(TestDomainSCI.INSTANCE, NotIndexedSCI.INSTANCE);
remoteCacheManager = new RemoteCacheManager(clientBuilder.build());
remoteCache = remoteCacheManager.getCache(TEST_CACHE_NAME);
}
@Override
protected ConfigurationBuilder getConfigurationBuilder() {
ConfigurationBuilder builder = super.getConfigurationBuilder();
builder.indexing().addProperty("default.directory_provider", "local-heap");
return builder;
}

```
<Overlap Ratio: 0.9828414550446122>

---

--- 252 --
Question ID: 8e7dc8e2e2ccfa5ec900d2d82823b6b3b66e02c6
Original Code:
```
public class Blob {
  // Canto superior esquerdo e inferior direito
  float minx;
  float miny;
  float maxx;
  float maxy;
  int cor;
  // int id = -1;
  int numPixels = 0;

  Blob(float x, float y) {
    minx = x;
    miny = y;
    maxx = x;
    maxy = y;
  }
  Blob(float x, float y, int c) {
    minx = x;
    miny = y;
    maxx = x;
    maxy = y;
    cor = c;
  }

  Blob(Blob b) {
    minx = b.minx;
    miny = b.miny;
    maxx = b.maxx;
    maxy = b.maxy;
    cor = b.cor;
    // id = b.id;
    numPixels = b.numPixels;
  }

  Blob() {
  }
  
  protected Blob clone() {
    Blob b = new Blob(this);
    return b;
  }

  public PVector center() {
    PVector centro = new PVector();
    centro.x = (minx+maxx)/2;
    centro.y = (miny+maxy)/2;
    
    return centro;
  }

  void add(float x, float y) {
    minx = Math.min(minx, x);
    miny = Math.min(miny, y);
    maxx = Math.max(maxx, x);
    maxy = Math.max(maxy, y);
    numPixels++;
  }
  
  // Limpa as coordenadas do blob
  void reset() {
    minx = Float.MAX_VALUE;
    miny = Float.MAX_VALUE;
    maxx = 0;
    maxy = 0;
    numPixels = 0;
  }
  
  //// Verifica se um ponto (x, y) faz parte do blob
  boolean isNear(float x, float y) {
    int distancia = 10;
    float cx = Math.max(Math.min(x, maxx), minx);
    float cy = Math.max(Math.min(y, maxy), miny);
    float d = distSq(cx, cy, x, y);

  if (d < distancia*distancia) return true;
    return false;
  }

  float size() {
    return (maxx-minx)*(maxy-miny); 
  }

  private float distSq(float ax, float ay, float bx, float by) {
      return (ax-bx)*(ax-bx) + (ay-by)*(ay-by);
  }
}
```


Overlapping Code:
```
/ Canto superior esquerdo e inferior direito
float minx;
float miny;
float maxx;
float maxy;
int cor;
// int id = -1;
int numPixels = 0;
Blob(float x, float y) {
minx = x;
miny = y;
maxx = x;
maxy = y;
}
Blob(float x, float y, int c) {
minx = x;
miny = y;
maxx = x;
maxy = y;
cor = c;
}
Blob(Blob b) {
minx = b.minx;
miny = b.miny;
maxx = b.maxx;
maxy = b.maxy;
cor = b.cor;
// id = b.id;
numPixels = b.numPixels;
}
Blob() {
}

protected Blob clone() {
Blob b = new Blob(this);
return b;
}
public PVector center() {
PVector centro = new PVector();
centro.x = (minx+maxx)/2;
centro.y = (miny+maxy)/2;

return centro;
}
void add(float x, float y) {
minx = Math.min(minx, x);
miny = Math.min(miny, y);
maxx = Math.max(maxx, x);
maxy = Math.max(maxy, y);
numPixels++;
}

// Limpa as coordenadas do blob
void reset() {
minx = Float.MAX_VALUE;
miny = Float.MAX_VALUE;
maxx = 0;
maxy = 0;
numPixels = 0;
}

//// Verifica se um ponto (x, y) faz parte do blob
boolean isNear(float x, float y) {
int distancia = 10;
float cx = Math.max(Math.min(x, maxx), minx);
float cy = Math.max(Math.min(y, maxy), miny);
float d = distSq(cx, cy, x, y);
if (d < distancia*distancia) return true;
return false;
}
float size() {
return (maxx-minx)*(maxy-miny); 
}
private float distSq(float ax, float ay, float bx, float by) {
return 
```
<Overlap Ratio: 0.9568397951719093>

---

--- 253 --
Question ID: 92f111dccb6f07a2c235f8a35fee4e62ac022c9a
Original Code:
```
public class SingleDeleteStatement implements DeleteStatement {
    public final Boolean lowPriority;
    public final Boolean quick;
    public final Boolean ignore;
    public final TableName tableName;
    public final UidList uidList;
    public final Expression where;
    public final OrderByClause orderByClause;
    public final DecimalLiteral limit;

    SingleDeleteStatement(Boolean lowPriority, Boolean quick, Boolean ignore, TableName tableName,
        UidList uidList, Expression where, OrderByClause orderByClause, DecimalLiteral limit) {
      Preconditions.checkArgument(tableName != null);

      this.lowPriority = lowPriority;
      this.quick = quick;
      this.ignore = ignore;
      this.tableName = tableName;
      this.uidList = uidList;
      this.where = where;
      this.orderByClause = orderByClause;
      this.limit = limit;
    }

    @Override
    public String literal() {
      StringBuilder sb = new StringBuilder();
      sb.append("DELETE ");
      if (Boolean.TRUE.equals(lowPriority)) {
        sb.append("LOW_PRIORITY ");
      }
      if (Boolean.TRUE.equals(quick)) {
        sb.append("QUICK ");
      }
      if (Boolean.TRUE.equals(ignore)) {
        sb.append("IGNORE ");
      }
      sb.append("FROM ").append(tableName.literal()).append(" ");
      if (uidList != null) {
        sb.append("PARTITION (").append(uidList.literal()).append(") ");
      }
      if (where != null) {
        sb.append("WHERE ").append(where.literal()).append(" ");
      }
      if (orderByClause != null) {
        sb.append(orderByClause.literal()).append(" ");
      }
      if (limit != null) {
        sb.append("LIMIT ").append(limit.literal());
      }
      return sb.toString();
    }

  }
```


Overlapping Code:
```
ements DeleteStatement {
public final Boolean lowPriority;
public final Boolean quick;
public final Boolean ignore;
public final TableName tableName;
public final UidList uidList;
public final Expression where;
public final OrderByClause orderByClause;
public final DecimalLiteral limit;
SingleDeleteStatement(Boolean lowPriority, Boolean quick, Boolean ignore, TableName tableName,
UidList uidList, Expression where, OrderByClause orderByClause, DecimalLiteral limit) {
Preconditions.checkArgument(tableName != null);
this.lowPriority = lowPriority;
this.quick = quick;
this.ignore = ignore;
this.tableName = tableName;
this.uidList = uidList;
this.where = where;
this.orderByClause = orderByClause;
this.limit = limit;
}
@Override
public String literal() {
StringBuilder sb = new StringBuilder();
sb.append("DELETE ");
if (Boolean.TRUE.equals(lowPriority)) {
sb.append("LOW_PRIORITY ");
}
if (Boolean.TRUE.equals(quick)) {
sb.append("QUICK ");
}
if (Boolean.TRUE.equals(ignore)) {
sb.append("IGNORE ");
}
sb.append("FROM ").append(tableName.literal()).append(" ");
if (uidList != null) {
sb.append("PARTITION (").append(uidList.literal()).append(") ");
}
if (where != null) {
sb.append("WHERE ").append(where.literal()).append(" ");
}
if (orderByClause != null) {
sb.append(orderByClause.literal()).append(" ");
}
if (limit != null) {
sb.append("LIMIT ").append(limit.literal());
}
return sb.toStri
```
<Overlap Ratio: 0.9668508287292817>

---

--- 254 --
Question ID: cb4b061f3d804de1deddc717c8802f759f920a8e
Original Code:
```
public class CompraStateFactory {

	public enum Estado {
		CREADA, EN_ESPERA, VERIFICADA, CANCELADA, ENVIADA
	}
	
	public static CompraState buildState(Estado estado, Compra compra) {
		CompraState cs = null;
		switch (estado) {
			case CREADA:
				cs = new CreadaCompraState(compra);
				break;
			case EN_ESPERA:
				cs = new EnEsperaCompraState(compra);
				break;
			case VERIFICADA:
				cs =  new VerificadaCompraState(compra);
				break;
			case CANCELADA:
				cs = new CanceladaCompraState(compra);
				break;
			case ENVIADA:
				cs = new EnviadaCompraState(compra);
				break;
			default:
				throw new IllegalArgumentException();
		}
		return cs;
	}
}
```


Overlapping Code:
```
tateFactory {
public enum Estado {
CREADA, EN_ESPERA, VERIFICADA, CANCELADA, ENVIADA
}

public static CompraState buildState(Estado estado, Compra compra) {
CompraState cs = null;
switch (estado) {
case CREADA:
cs = new CreadaCompraState(compra);
break;
case EN_ESPERA:
cs = new EnEsperaCompraState(compra);
break;
case VERIFICADA:
cs = new VerificadaCompraState(compra);
break;
case CANCELADA:
cs = new CanceladaCompraState(compra);
break;
case ENVIADA:
cs = new EnviadaCompraState(compra);
break;
default:
throw new IllegalArgumentException();
}
return c
```
<Overlap Ratio: 0.9553264604810997>

---

--- 255 --
Question ID: 9d79243d109b602a953ff7ad838b6f6a21f700ed
Original Code:
```
public class BinarySearchTreeUtils {

	private BinarySearchTreeUtils() {
		throw new AssertionError("Non instantiability");
	}
	
	public static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src) {
		List<E> distinct = src.stream().distinct().collect(Collectors.toList());
		Collections.sort(distinct);
		return buildBST(distinct, 0, distinct.size() -1);
	}
	
	private static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src, int left, int right) {
		if(left > right) {
			return null;
		}
		int mid = left + (right - left) / 2;
		TreeNode<E> root = new TreeNode<>(src.get(mid));
		root.left = buildBST(src, left, mid -1);
		root.right = buildBST(src, mid+1, right);
		return root;
	}
}
```


Overlapping Code:
```
narySearchTreeUtils() {
throw new AssertionError("Non instantiability");
}

public static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src) {
List<E> distinct = src.stream().distinct().collect(Collectors.toList());
Collections.sort(distinct);
return buildBST(distinct, 0, distinct.size() -1);
}

private static <E extends Comparable<? super E>> TreeNode<E> buildBST(List<E> src, int left, int right) {
if(left > right) {
return null;
}
int mid = left + (right - left) / 2;
TreeNode<E> root = new TreeNode<>(src.get(mid));
root.left = buildBST(src, left, mid -1);
root.right = buildB
```
<Overlap Ratio: 0.8746355685131195>

---

--- 256 --
Question ID: fe402563a2cb0e659ac628ae27b579113e890fd1
Original Code:
```
public abstract class Resources {

	/** Pseudo URL prefix for loading from the class path: "classpath:" */
	public static final String CLASSPATH_URL_PREFIX = "classpath:";
	
	/**
	 * Pseudo URL prefix for all matching resources from the class path: "classpath*:"
	 * This differs from ResourceLoader's classpath URL prefix in that it
	 * retrieves all matching resources for a given name (e.g. "/beans.xml"),
	 * for example in the root of all deployed JAR files.
	 */
	public static String CLASSPATH_ALL_URL_PREFIX = "classpath*:";	

	/** URL prefix for loading from the file system: "file:" */
	public static final String FILE_URL_PREFIX = "file:";

	/** URL protocol for a file in the file system: "file" */
	public static final String URL_PROTOCOL_FILE = "file";

	/** URL protocol for an entry from a jar file: "jar" */
	public static final String URL_PROTOCOL_JAR = "jar";

	/** URL protocol for an entry from a zip file: "zip" */
	public static final String URL_PROTOCOL_ZIP = "zip";

	/** URL protocol for an entry from a JBoss jar file: "vfszip" */
	public static final String URL_PROTOCOL_VFSZIP = "vfszip";

	/** URL protocol for a JBoss VFS resource: "vfs" */
	public static final String URL_PROTOCOL_VFS = "vfs";

	/** URL protocol for an entry from a WebSphere jar file: "wsjar" */
	public static final String URL_PROTOCOL_WSJAR = "wsjar";

	/** URL protocol for an entry from an OC4J jar file: "code-source" */
	public static final String URL_PROTOCOL_CODE_SOURCE = "code-source";

	/** Separator between JAR URL and file path within the JAR */
	public static final String JAR_URL_SEPARATOR = "!/";
	
	private static final ResourceLoader 					 loader 	     = new DefaultResourceLoader();
	private static final PathMatchingResourcePatternResolver resolver        = new PathMatchingResourcePatternResolver();
	private static final PathMatchingResourcePatternResolver resolverQuietly = new PathMatchingResourcePatternResolver(true);
	
	/**
	 * Return whether the given resource location is a URL: either a special "classpath" pseudo URL or a standard URL.
	 * 
	 * @param resourceLocation the location String to check
	 * @return whether the location qualifies as a URL
	 * @see #CLASSPATH_URL_PREFIX
	 * @see java.net.URL
	 */
	public static boolean isUrl(String resourceLocation) {
		if (resourceLocation == null) {
			return false;
		}
		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
			return true;
		}
		try {
			new URL(resourceLocation);
			return true;
		} catch (MalformedURLException ex) {
			return false;
		}
	}
	
	/**
	 * Determine whether the given URL points to a resource in the file system, that is, has protocol "file" or "vfs".
	 * 
	 * @param url the URL to check
	 * @return whether the URL has been identified as a file system URL
	 */
	public static boolean isFileURL(URL url) {
		String protocol = url.getProtocol();
		return (URL_PROTOCOL_FILE.equals(protocol) || protocol.startsWith(URL_PROTOCOL_VFS));
	}

	/**
	 * Determine whether the given URL points to a resource in a jar file, that is, has protocol "jar", "zip", "wsjar"
	 * or "code-source".
	 * <p>
	 * "zip" and "wsjar" are used by BEA WebLogic Server and IBM WebSphere, respectively, but can be treated like jar
	 * files. The same applies to "code-source" URLs on Oracle OC4J, provided that the path contains a jar separator.
	 * 
	 * @param url the URL to check
	 * @return whether the URL has been identified as a JAR URL
	 */
	public static boolean isJarURL(URL url) {
		String protocol = url.getProtocol();
		return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol) || (URL_PROTOCOL_CODE_SOURCE
		        .equals(protocol) && url.getPath().contains(JAR_URL_SEPARATOR)));
	}	

	/**
	 * Resolve the given resource location to a <code>java.net.URL</code>.
	 * <p>
	 * Does not check whether the URL actually exists; simply returns the URL that the given location would correspond
	 * to.
	 * 
	 * @param resourceLocation the resource location to resolve: either a "classpath:" pseudo URL, a "file:" URL, or a
	 *            plain file path
	 * @return a corresponding URL object
	 * @throws ObjectNotFoundException if the resource cannot be resolved to a URL
	 */
	public static URL getURL(String resourceLocation) throws ObjectNotFoundException {
		Assert.notNull(resourceLocation, "Resource location must not be null");
		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
			String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
			URL url = Classes.getClassLoader().getResource(path);
			if (url == null) {
				String description = "class path resource [" + path + "]";
				throw new ObjectNotFoundException(description + " cannot be resolved to URL because it does not exist");
			}
			return url;
		}
		try {
			// try URL
			return new URL(resourceLocation);
		} catch (MalformedURLException ex) {
			// no URL -> treat as file path
			try {
				return new File(resourceLocation).toURI().toURL();
			} catch (MalformedURLException ex2) {
				throw new ObjectNotFoundException("Resource location [" + resourceLocation + "] is neither a URL not a well-formed file path");
			}
		}
	}
	
	//scan resources
	//-----------------------------------------------------------------------------
	public static Resource[] scan(String resourceLocationPattern) throws UncheckedIOException {
		return scan(resourceLocationPattern,false);
	}
	
	public static Resource[] scanQuietly(String resourceLocationPattern) throws UncheckedIOException {
		return scan(resourceLocationPattern,true);
	}
	
	public static Resource[] scan(String resourceLocationPattern,boolean quietly) throws UncheckedIOException {
		try {
	        Resource[] resources = quietly ? resolverQuietly.getResources(resourceLocationPattern) : resolver.getResources(resourceLocationPattern);
	        
	        List<Resource> list = new ArrayList<Resource>();
	        
	        for(Resource r : resources){
	        	if(r.exists()){
	        		list.add(r);
	        	}
	        }
	        
	        return Collections.toArray(list,Resource.class);
        } catch (IOException e) {
        	throw new UncheckedIOException("Error scanning location : " + resourceLocationPattern, e);
        }
	}
	
	public static Resource getResource(String resourceLocation) throws UncheckedIOException {
		Assert.notNull(resourceLocation,"Resource location must not be null");
		
		if(!isUrl(resourceLocation)){
			resourceLocation = CLASSPATH_URL_PREFIX + resourceLocation;
		}
		
        return loader.getResource(resourceLocation);
	}
	
	public static Resource getResource(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {
		Assert.notNull(clazz,"clazz must not be null");
		Assert.notNull(resourceNameInPackage,"resource name must not be null");
		
		String resourceLocation = CLASSPATH_URL_PREFIX + clazz.getPackage().getName().replace('.', '/') + "/" + resourceNameInPackage;
		
        return loader.getResource(resourceLocation);
	}
	
	//InputStream
	//-----------------------------------------------------------------------------
	
	public static InputStream getInputStream(String resourceLocation) throws UncheckedIOException {
		try {
			return getResource(resourceLocation).getInputStream();
        } catch (IOException e) {
        	throw new UncheckedIOException("Error getInputStream from :" + resourceLocation,e);
        }
	}
	
	public static InputStream getInputStream(Class<?> clazz,String resourceNameInPackage) throws UncheckedIOException {
		try {
			return getResource(clazz,resourceNameInPackage).getInputStream();
        } catch (IOException e) {
        	throw new UncheckedIOException("Error getInputStream from :" + resourceNameInPackage,e);
        }
	}
	
	//File
	//-----------------------------------------------------------------------------	

	/**
	 * Resolve the given resource location to a <code>java.io.File</code>, i.e. to a file in the file system.
	 * <p>
	 * Does not check whether the fil actually exists; simply returns the File that the given location would correspond
	 * to.
	 * 
	 * @param resourceLocation the resource location to resolve: either a "classpath:" pseudo URL, a "file:" URL, or a
	 *            plain file path
	 * @return a corresponding File object
	 * @throws ObjectNotFoundException if the resource cannot be resolved to a file in the file system
	 */
	public static File getFile(String resourceLocation) throws ObjectNotFoundException {
		Assert.notNull(resourceLocation, "Resource location must not be null");
		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
			String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
			String description = "class path resource [" + path + "]";
			URL url = Classes.getClassLoader().getResource(path);
			if (url == null) {
				throw new ObjectNotFoundException(description + " cannot be resolved to absolute file path "
				        + "because it does not reside in the file system");
			}
			return getFile(url, description);
		}
		try {
			// try URL
			return getFile(new URL(resourceLocation));
		} catch (MalformedURLException ex) {
			// no URL -> treat as file path
			return new File(resourceLocation);
		}
	}

	/**
	 * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.
	 * 
	 * @param resourceUrl the resource URL to resolve
	 * @return a corresponding File object
	 * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system
	 */
	public static File getFile(URL resourceUrl) throws ObjectNotFoundException {
		return getFile(resourceUrl, "URL");
	}

	/**
	 * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.
	 * 
	 * @param resourceUri the resource URI to resolve
	 * @return a corresponding File object
	 * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system
	 */
	public static File getFile(URI resourceUri) throws ObjectNotFoundException {
		return getFile(resourceUri, "URI");
	}
	
	/**
	 * Resolve the given resource URL to a <code>java.io.File</code>, i.e. to a file in the file system.
	 * 
	 * @param resourceUrl the resource URL to resolve
	 * @param description a description of the original resource that the URL was created for (for example, a class path
	 *            location)
	 * @return a corresponding File object
	 * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system
	 */
	static File getFile(URL resourceUrl, String description) throws ObjectNotFoundException {
		Assert.notNull(resourceUrl, "Resource URL must not be null");
		if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {
			throw new ObjectNotFoundException(description + " cannot be resolved to absolute file path "
			        + "because it does not reside in the file system: " + resourceUrl);
		}
		try {
			return new File(toURI(resourceUrl).getSchemeSpecificPart());
		} catch (URISyntaxException ex) {
			// Fallback for URLs that are not valid URIs (should hardly ever happen).
			return new File(resourceUrl.getFile());
		}
	}

	/**
	 * Resolve the given resource URI to a <code>java.io.File</code>, i.e. to a file in the file system.
	 * 
	 * @param resourceUri the resource URI to resolve
	 * @param description a description of the original resource that the URI was created for (for example, a class path
	 *            location)
	 * @return a corresponding File object
	 * @throws ObjectNotFoundException if the URL cannot be resolved to a file in the file system
	 */
	static File getFile(URI resourceUri, String description) throws ObjectNotFoundException {
		Assert.notNull(resourceUri, "Resource URI must not be null");
		if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {
			throw new ObjectNotFoundException(description + " cannot be resolved to absolute file path "
			        + "because it does not reside in the file system: " + resourceUri);
		}
		return new File(resourceUri.getSchemeSpecificPart());
	}

	/**
	 * Extract the URL for the actual jar file from the given URL (which may point to a resource in a jar file or to a
	 * jar file itself).
	 * 
	 * @param jarUrl the original URL
	 * @return the URL for the actual jar file
	 * @throws MalformedURLException if no valid jar file URL could be extracted
	 */
	static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
		String urlFile = jarUrl.getFile();
		int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);
		if (separatorIndex != -1) {
			String jarFile = urlFile.substring(0, separatorIndex);
			try {
				return new URL(jarFile);
			} catch (MalformedURLException ex) {
				// Probably no protocol in original jar URL, like "jar:C:/mypath/myjar.jar".
				// This usually indicates that the jar file resides in the file system.
				if (!jarFile.startsWith("/")) {
					jarFile = "/" + jarFile;
				}
				return new URL(FILE_URL_PREFIX + jarFile);
			}
		} else {
			return jarUrl;
		}
	}

	/**
	 * Create a URI instance for the given URL, replacing spaces with "%20" quotes first.
	 * <p>
	 * Furthermore, this method works on JDK 1.4 as well, in contrast to the <code>URL.toURI()</code> method.
	 * 
	 * @param url the URL to convert into a URI instance
	 * @return the URI instance
	 * @throws URISyntaxException if the URL wasn't a valid URI
	 * @see java.net.URL#toURI()
	 */
	static URI toURI(URL url) throws URISyntaxException {
		return toURI(url.toString());
	}

	/**
	 * Create a URI instance for the given location String, replacing spaces with "%20" quotes first.
	 * 
	 * @param location the location String to convert into a URI instance
	 * @return the URI instance
	 * @throws URISyntaxException if the location wasn't a valid URI
	 */
	static URI toURI(String location) throws URISyntaxException {
		return new URI(Strings.replace(location, " ", "%20"));
	}

	/**
	 * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the given connection, preferring
	 * <code>false</code> but leaving the flag at <code>true</code> for JNLP based resources.
	 * 
	 * @param con the URLConnection to set the flag on
	 */
	static void useCachesIfNecessary(URLConnection con) {
		con.setUseCaches(con.getClass().getName().startsWith("JNLP"));
	}
	
	static String applyRelativePath(String parentPath, String relativePath) {
		int separatorIndex = parentPath.lastIndexOf(Paths.UNIX_SEPARATOR_STR);
		if (separatorIndex != -1) {
			String newPath = parentPath.substring(0, separatorIndex);
			if (!relativePath.startsWith(Paths.UNIX_SEPARATOR_STR)) {
				newPath += Paths.UNIX_SEPARATOR_STR;
			}
			return newPath + relativePath;
		}
		else {
			return relativePath;
		}
	}
}
```


Overlapping Code:
```
 {
/** Pseudo URL prefix for loading from the class path: "classpath:" */
public static final String CLASSPATH_URL_PREFIX = "classpath:";

/**
* Pseudo URL prefix for all matching resources from the class path: "classpath*:"
* This differs from ResourceLoader's classpath URL prefix in that it
* retrieves all matching resources for a given name (e.g. "/beans.xml"),
* for example in the root of all deployed JAR files.
*/
public static String CLASSPATH_ALL_URL_PREFIX = "classpath*:"; 
/** URL prefix for loading from the file system: "file:" */
public static final String FILE_URL_PREFIX = "file:";
/** URL protocol for a file in the file system: "file" */
public static final String URL_PROTOCOL_FILE = "file";
/** URL protocol for an entry from a jar file: "jar" */
public static final String URL_PROTOCOL_JAR = "jar";
/** URL protocol for an entry from a zip file: "zip" */
public static final String URL_PROTOCOL_ZIP = "zip";
/** URL protocol for an entry from a JBoss jar file: "vfszip" */
public static final String URL_PROTOCOL_VFSZIP = "vfszip";
/** URL protocol for a JBoss VFS resource: "vfs" */
public static final String URL_PROTOCOL_VFS = "vfs";
/** URL protocol for an entry from a WebSphere jar file: "wsjar" */
public static final String URL_PROTOCOL_WSJAR = "wsjar";
/** URL protocol for an entry from an OC4J jar file: "code-source" */
public static final String URL_PROTOCOL_CODE_SOURCE = "code-source";
/** Separator between JAR URL and file path within the JAR */
public static final String JAR_URL_SEPARATOR = "!/";

private static final ResourceLoader loader = new DefaultResourceLoader();
private static final PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
private static final PathMatchingResourcePatternResolver resolverQuietly = new PathMatchingResourcePatternResolver(true);

/**
* Return whether the given resource location is a URL: either a special "classpath" pseudo URL or a standard URL.
* 
* @param resourceLocation the location String to check
* @return whether the location qualifies as a URL
* @see #CLASSPATH_URL_PREFIX
* @see java.net.URL
*/
public static boolean isUrl(String resourceLocation) {
if (resourceLocation == null) {
return false;
}
if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
return true;
}
try 
```
<Overlap Ratio: 0.9863130881094953>

---

--- 257 --
Question ID: df6ff0d20cbd8696208275a2ac68007fbec79201
Original Code:
```
public class GetPresenceRequestApi extends RequestApi {
    @JSONHint(ignore = true)
    private static final Logger Log = LoggerFactory
            .getLogger(GetPresenceRequestApi.class);

    public Object content;

    @Override
    public ResponseApi doRequest(GlobalSNSWebSocket globalSNSWebSocket) {
        final String logPrefix = "doRequest() : ";
        ResponseApi ret = null;
        if (globalSNSWebSocket == null) {
            Log.error(logPrefix + "globalSNSWebSocket is null.",
                    new Throwable());
            return ret;
        }
        String jid = globalSNSWebSocket.getJid();
        if (jid == null || "".equals(jid)) {
            Log.error(logPrefix + "globalSNSWebSocket's jid is invalid",
                    new Throwable());
            return ret;
        }
        int presence = WebSocketApiProcessor.getInstance().getDisplayPresence(
                jid);
        if (presence == -1) {
            Log.error(logPrefix + "presence is invalid", new Throwable());
            return ret;
        }
        GetPresenceResponseApi response = new GetPresenceResponseApi();
        response.id = id;
        response.request = request;
        response.version = version;
        ((GetPresenceResponseApi.Content) response.content).presence = presence;
        ret = response;
        return ret;
    }

}
```


Overlapping Code:
```
RequestApi extends RequestApi {
@JSONHint(ignore = true)
private static final Logger Log = LoggerFactory
.getLogger(GetPresenceRequestApi.class);
public Object content;
@Override
public ResponseApi doRequest(GlobalSNSWebSocket globalSNSWebSocket) {
final String logPrefix = "doRequest() : ";
ResponseApi ret = null;
if (globalSNSWebSocket == null) {
Log.error(logPrefix + "globalSNSWebSocket is null.",
new Throwable());
return ret;
}
String jid = globalSNSWebSocket.getJid();
if (jid == null || "".equals(jid)) {
Log.error(logPrefix + "globalSNSWebSocket's jid is invalid",
new Throwable());
return ret;
}
int presence = WebSocketApiProcessor.getInstance().getDisplayPresence(
jid);
if (presence == -1) {
Log.error(logPrefix + "presence is invalid", new Throwable());
return ret;
}
GetPresenceResponseApi response = new GetPresenceResponseApi();
response.id = id;
response.request = request;
response.version = version;
((GetPresenceResponseApi.Content) response.content).presence = presence;
ret = 
```
<Overlap Ratio: 0.9532888465204957>

---

--- 258 --
Question ID: 9b9ef24c8655a74c129369dc367521d188e417d8
Original Code:
```
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        BottomNavigationView navView = findViewById(R.id.nav_view);
        // Passing each menu ID as a set of Ids because each
        // menu should be considered as top level destinations.
        AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(
                R.id.navigation_home, R.id.navigation_favorites, R.id.navigation_search, R.id.navigation_profile)
                .build();
        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);
        NavigationUI.setupWithNavController(navView, navController);
        getSupportActionBar().setDisplayHomeAsUpEnabled(false);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            //Title bar back press triggers onBackPressed()
            onBackPressed();
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
    @Override
    public void onBackPressed() {
        if (getFragmentManager().getBackStackEntryCount() > 0 ) {
            getFragmentManager().popBackStack();
        }
        else {
            super.onBackPressed();
        }

    }

}
```


Overlapping Code:
```
public class MainActivity extends AppCompatActivity {
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
BottomNavigationView navView = findViewById(R.id.nav_view);
// Passing each menu ID as a set of Ids because each
// menu should be considered as top level destinations.
AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(
R.id.navigation_home, R.id.navigation_favorites, R.id.navigation_search, R.id.navigation_profile)
.build();
NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment);
NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);
NavigationUI.setupWithNavController(navView, navController);
getSupportActionBar().setDisplayHomeAsUpEnabled(false);
}
@Override
public boolean onOptionsItemSelected(MenuItem item) {
if (item.getItemId() == android.R.id.home) {
//Title bar back press triggers onBackPressed()
onBackPressed();
return true;
}
return super.onOptionsItemSelected(item);
}
@Override
public void onBackPressed() {
if (getFragmentManager().getBackStackEntryCount() > 0 ) {
getFragmentManager().popBackStack();
}
else {
super.onBackPresse
```
<Overlap Ratio: 0.991980753809142>

---

--- 259 --
Question ID: 9585fac25b2a77cb525150c5270863dcd32ec070
Original Code:
```
public class Query22Analyzer {
	public ArrayList<String> collectDatesList(String result) throws UnsupportedEncodingException {
		SAXQuery22TemplateTransformer transformer = new SAXQuery22TemplateTransformer();
		transformer.transform(new ByteArrayInputStream(result.getBytes("UTF-8")));
		return transformer.getDatesList();
	}
}
```


Overlapping Code:
```
c class Query22Analyzer {
public ArrayList<String> collectDatesList(String result) throws UnsupportedEncodingException {
SAXQuery22TemplateTransformer transformer = new SAXQuery22TemplateTransformer();
transformer.transform(new ByteArrayInputStream(result.getBytes("UTF-8")));
return transformer.getD
```
<Overlap Ratio: 0.9375>

---

--- 260 --
Question ID: e5550e0714b6404f6bbb5089cfab0cd14305c35a
Original Code:
```
@Service
@RequiredArgsConstructor
public class PollNodeServiceImpl implements PollNodeService {

    private final PollNodeRepository pollNodeRepository;

    @Override
    @NotNullArgs
    public PollNode create(PollNode node) {
        return pollNodeRepository.save(node);
    }

    @Override
    public PollNode update(PollNode node) {
        if (node.getId() == null) {
            throw new ReckueIllegalArgumentException("The parameter is null");
        }
        PollNode savedPollNode = pollNodeRepository
                .findById(node.getId())
                .orElseThrow(() -> new PollNodeNotFoundException(node.getId()));
        savedPollNode.setTitle(node.getTitle());
        savedPollNode.setItems(node.getItems());
        return pollNodeRepository.save(savedPollNode);
    }

    @Override
    public List<PollNode> findAll() {
        return pollNodeRepository.findAll();
    }

    @Override
    public List<PollNode> findAll(Integer limit, Integer offset, String sort, Boolean desc) {
        if (limit == null) limit = 10;
        if (offset == null) offset = 0;
        if (StringUtils.isEmpty(sort)) sort = "id";
        if (desc == null) desc = false;

        if (limit < 0 || offset < 0) {
            throw new ReckueIllegalArgumentException("Limit or offset is incorrect");
        }
        return findAllByTypeAndDesc(sort, desc).stream()
                .limit(limit)
                .skip(offset)
                .collect(Collectors.toList());
    }

    public List<PollNode> findAllByTypeAndDesc(String sort, boolean desc) {
        if (desc) {
            List<PollNode> node = findAllBySortType(sort);
            Collections.reverse(node);
            return node;
        }
        return findAllBySortType(sort);
    }

    public List<PollNode> findAllBySortType(String sort) {

        switch (sort) {
            case "title":
                return findAllAndSortByTitle();
            case "id":
                return findAllAndSortById();
        }
        throw new ReckueIllegalArgumentException("Such field as " + sort + " doesn't exist");
    }

    public List<PollNode> findAllAndSortById() {
        return findAll().stream()
                .sorted(Comparator.comparing(PollNode::getId))
                .collect(Collectors.toList());
    }

    public List<PollNode> findAllAndSortByTitle() {
        return findAll().stream()
                .sorted(Comparator.comparing(PollNode::getTitle))
                .collect(Collectors.toList());
    }

    @Override
    public PollNode findById(String id) {
        return pollNodeRepository.findById(id).orElseThrow(
                () -> new PollNodeNotFoundException(id));
    }

    @Override
    public void deleteById(String id) {
        if (pollNodeRepository.existsById(id)) {
            pollNodeRepository.deleteById(id);
        } else {
            throw new PollNodeNotFoundException(id);
        }
    }
}
```


Overlapping Code:
```
@Service
@RequiredArgsConstructor
public class PollNodeServiceImpl implements PollNodeService {
private final PollNodeRepository pollNodeRepository;
@Override
@NotNullArgs
public PollNode create(PollNode node) {
return pollNodeRepository.save(node);
}
@Override
public PollNode update(PollNode node) {
if (node.getId() == null) {
throw new ReckueIllegalArgumentException("The parameter is null");
}
PollNode savedPollNode = pollNodeRepository
.findById(node.getId())
.orElseThrow(() -> new PollNodeNotFoundException(node.getId()));
savedPollNode.setTitle(node.getTitle());
savedPollNode.setItems(node.getItems());
return pollNodeRepository.save(savedPollNode);
}
@Override
public List<PollNode> findAll() {
return pollNodeRepository.findAll();
}
@Override
public List<PollNode> findAll(Integer limit, Integer offset, String sort, Boolean desc) {
if (limit == null) limit = 10;
if (offset == null) offset = 0;
if (StringUtils.isEmpty(sort)) sort = "id";
if (desc == null) desc = false;
if (limit < 0 || offset < 0) {
throw new ReckueIllegalArgumentException("Limit or offset is incorrect");
}
return findAllByTypeAndDesc(sort, desc).stream()
.limit(limit)
.skip(offset)
.collect(Collectors.toList());
}
public List<PollNode> findAllByTypeAndDesc(String sort, boolean desc) {
if (desc) {
List<PollNode> node = findAllBySortType(sort);
Collections.reverse(node);
return node;
}
return findAllBySortType(sort);
}
public List<PollNode> findAllBySortType(String sort) {
switch (sort) {
case "title":
return findAllAndSortByTitle();
case "id":
return findAllAndSortById();
}
throw new ReckueIllegalArgumentException("Such field as " + sort + " doesn't exist");
}
public List<PollNode> findAllAndSortById() {
return findAll().stream()
.sorted(Comparator.comparing(PollNode::getId))
.collect(Collectors.toList());
}
public List<PollNode> findAllAndSortByTitle() {
return findAll().stream()
.sorted(Comparator.comparing(PollNode::getTitle))
.collect(Collectors.t
```
<Overlap Ratio: 0.9959183673469387>

---

--- 261 --
Question ID: 0eb0ffd73bf0b4053d167eff77958be954d782d0
Original Code:
```
class FSQueueTest {

    @TempDir
    static Path folder;

    private CommitterContext ctx;
    private FSQueue queue;

    @BeforeEach
    public void setup() {
        this.ctx = CommitterContext.builder().setWorkDir(folder).build();
        this.queue = new FSQueue();
    }

    @Test
    void testQueue() throws CommitterException, IOException {

        final MutableInt batchQty = new MutableInt();
        final Set<String> batchRefs = new TreeSet<>();

        queue.setBatchSize(5);
        queue.init(ctx, it -> {
            batchQty.increment();
            while (it.hasNext()) {
                ICommitterRequest req = it.next();
                batchRefs.add(req.getReference());
            }
        });

        // Add test data
        for (int i = 0; i < 13; i++) {
            queue.queue(TestUtil.upsertRequest(i + 1));
        }
        queue.close();

        // records should have been processed in 3 batches.
        Assertions.assertEquals(3, batchQty.getValue());

        // There should be 13 obtained from queue in total
        Assertions.assertEquals(13, batchRefs.size());

        // Queue directory should be empty.
        Assertions.assertEquals(0, Files.find(folder,  1,
                (f, a) -> f.toFile().getName().endsWith(
                        FSQueueUtil.EXT)).count());
    }

    @Test
    void testWriteRead() {
        FSQueue q = new FSQueue();
        q.setBatchSize(50);
        q.setMaxPerFolder(100);
        q.setCommitLeftoversOnInit(true);
        q.setIgnoreErrors(true);
        q.setMaxRetries(6);
        q.setRetryDelay(666);
        XML.assertWriteRead(q, "queue");
    }
}
```


Overlapping Code:
```
private CommitterContext ctx;
private FSQueue queue;
@BeforeEach
public void setup() {
this.ctx = CommitterContext.builder().setWorkDir(folder).build();
this.queue = new FSQueue();
}
@Test
void testQueue() throws CommitterException, IOException {
final MutableInt batchQty = new MutableInt();
final Set<String> batchRefs = new TreeSet<>();
queue.setBatchSize(5);
queue.init(ctx, it -> {
batchQty.increment();
while (it.hasNext()) {
ICommitterRequest req = it.next();
batchRefs.add(req.getReference());
}
});
// Add test data
for (int i = 0; i < 13; i++) {
queue.queue(TestUtil.upsertRequest(i + 1));
}
queue.close();
// records should have been processed in 3 batches.
Assertions.assertEquals(3, batchQty.getValue());
// There should be 13 obtained from queue in total
Assertions.assertEquals(13, batchRefs.size());
// Queue directory should be empty.
Assertions.assertEquals(0, Files.find(folder, 1,
(f, a) -> f.toFile().getName().endsWith(
FSQueueUtil.EXT)).count());
}
@Test
void testWriteRead() {
FSQueue q = new FSQueue();
q.setBatchSize(50);
q.setMaxPerFolder(100);
q.setCommitLeftoversOnInit(true);
q.setIgnoreErrors(true);
q.setMaxRetries(6);
q.setRetryDelay(666);
XML.assertWriteRead(q, "que
```
<Overlap Ratio: 0.9538950715421304>

---

--- 262 --
Question ID: e436addad1461c6544176d85187594400075ad2e
Original Code:
```
public class AssetAssembler {

  private static final NBTTagCompound compound = new NBTTagCompound("");

  static {
    File file = new File("assets.dat");
    if (file.exists()) {
      file.delete();
    }

    try {
      readBlockPalette();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private static void readBlockPalette() throws IOException {
    File nbtPalette = new File("palette.nbt");
    byte[] data = Files.readAllBytes(nbtPalette.toPath());
    NBTReader nbtReader = new NBTReader(Unpooled.wrappedBuffer(data), ByteOrder.BIG_ENDIAN);
    nbtReader.setUseVarint(true);

    List<Object> blockPalette = new ArrayList<>();

    while (true) {
      try {
        NBTTagCompound compound = nbtReader.parse();
        DumpUtil.dumpNBTCompund(compound);
        blockPalette.add(compound);
      } catch (AllocationLimitReachedException | IOException e) {
        List<Object> nbtTags = compound.getList("blockPalette", true);
        nbtTags.clear();
        nbtTags.addAll(blockPalette);
        return;
      }
    }
  }

  public static void writeToFile() {
    ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer();
    NBTWriter nbtWriter = new NBTWriter(buf, ByteOrder.BIG_ENDIAN);

    try {
      nbtWriter.write(compound);
    } catch (IOException e) {
      e.printStackTrace();
    }

    try (FileOutputStream out = new FileOutputStream(new File("assets.dat"))) {
      byte[] data = new byte[buf.readableBytes()];
      buf.readBytes(data);
      out.write(data);
    } catch (IOException e) {
      e.printStackTrace();
    }

    buf.release();
  }

  public static synchronized void addRecipe(String name, UUID uuid, byte type, ItemStack[] in, ItemStack[] out,
      int width, int height, String block, int prio) {
    List<Object> recipes = compound.getList("recipes", true);

    NBTTagCompound recipeCompound = new NBTTagCompound("");

    if (name != null) {
      recipeCompound.addValue("name", name);
    }

    if (block != null) {
      recipeCompound.addValue("block", block);
    }

    recipeCompound.addValue("prio", prio);
    recipeCompound.addValue("type", type);

    List<byte[]> input = new ArrayList<>();
    for (ItemStack itemStack : in) {
      input.add(serializeItem(itemStack));
    }

    recipeCompound.addValue("i", input);

    List<byte[]> output = new ArrayList<>();
    for (ItemStack itemStack : out) {
      output.add(serializeItem(itemStack));
    }

    recipeCompound.addValue("o", output);

    if (uuid != null) {
      recipeCompound.addValue("u", uuid.toString());
    }

    if (width != -1 && height != -1) {
      recipeCompound.addValue("w", width);
      recipeCompound.addValue("h", height);
    }

    recipes.add(recipeCompound);
  }

  public static synchronized void writeCreativeInventory(ItemStack[] items) {
    List<Object> nbtTags = compound.getList("creativeInventory", true);
    nbtTags.clear();

    for (ItemStack item : items) {
      byte[] itemData = serializeItem(item);
      nbtTags.add(itemData);
    }
  }

  public static synchronized void writeLegacyItems(List<StringShortPair> itemLegacyIds) {
    List<Object> nbtTags = compound.getList("itemLegacyIDs", true);
    nbtTags.clear();

    for (StringShortPair itemLegacyId : itemLegacyIds) {
      NBTTagCompound l = new NBTTagCompound("");
      l.addValue("name", itemLegacyId.getBlockId());
      l.addValue("id", itemLegacyId.getData());
      nbtTags.add(l);
    }
  }

  public static synchronized void writeBlockPalette(List<Object> blockPalette) {
    List<Object> nbtTags = compound.getList("blockPalette", true);
    nbtTags.clear();
    nbtTags.addAll(blockPalette);
  }

  private static byte[] serializeItem(ItemStack itemStack) {
    PacketBuffer buffer = new PacketBuffer(2);
    if (itemStack == null) {
      System.out.println("Nulled item");
    }

    buffer.writeShort((short) itemStack.getMaterial());
    buffer.writeByte(itemStack.getAmount());
    buffer.writeShort(itemStack.getData());

    if (itemStack.getNbtData() != null) {
      ByteBuf nbtBuf = PooledByteBufAllocator.DEFAULT.directBuffer();
      try {
        itemStack.getNbtData().writeTo(nbtBuf, false, ByteOrder.BIG_ENDIAN);
      } catch (IOException e) {

      }

      buffer.writeShort((short) nbtBuf.readableBytes());
      buffer.writeBytes(nbtBuf);
    } else {
      buffer.writeShort((short) 0);
    }

    byte[] data = new byte[buffer.getRemaining()];
    buffer.readBytes(data);
    buffer.release();
    return data;
  }

  public static synchronized void writeBiomeDefinition(NBTTagCompound nbt) {
    compound.addValue("biomeDefinitions", nbt.deepClone("biomeDefinitions"));
  }

}
```


Overlapping Code:
```
etAssembler {
private static final NBTTagCompound compound = new NBTTagCompound("");
static {
File file = new File("assets.dat");
if (file.exists()) {
file.delete();
}
try {
readBlockPalette();
} catch (IOException e) {
e.printStackTrace();
}
}
private static void readBlockPalette() throws IOException {
File nbtPalette = new File("palette.nbt");
byte[] data = Files.readAllBytes(nbtPalette.toPath());
NBTReader nbtReader = new NBTReader(Unpooled.wrappedBuffer(data), ByteOrder.BIG_ENDIAN);
nbtReader.setUseVarint(true);
List<Object> blockPalette = new ArrayList<>();
while (true) {
try {
NBTTagCompound compound = nbtReader.parse();
DumpUtil.dumpNBTCompund(compound);
blockPalette.add(compound);
} catch (AllocationLimitReachedException | IOException e) {
List<Object> nbtTags = compound.getList("blockPalette", true);
nbtTags.clear();
nbtTags.addAll(blockPalette);
return;
}
}
}
public static void writeToFile() {
ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer();
NBTWriter nbtWriter = new NBTWriter(buf, ByteOrder.BIG_ENDIAN);
try {
nbtWriter.write(compound);
} catch (IOException e) {
e.printStackTrace();
}
try (FileOutputStream out = new FileOutputStream(new File("assets.dat"))) {
byte[] data = new byte[buf.readableBytes()];
buf.readBytes(data);
out.write(data);
} catch (IOException e) {
e.printStackTrace();
}
buf.release();
}
public static synchronized void addRecipe(String name, UUID uuid, byte type, ItemStack[] in, ItemStack[] out,
int width, int height, String block, int prio) {
List<Object> recipes = compound.getList("recipes", true);
NBTTagCompound recipeCompound = new NBTTagCompound("");
if (name != null) {
recipeCompound.addValue("name", name);
}
if (block != null) {
recipeCompound.addValue("block", block);
}
recipeCompound.addValue("prio", prio);
recipeCompound.addValue("type", type);
List<byte[]> input = new ArrayList<>();
for (ItemStack itemStack : in) {
input.add(serializeItem(itemStack));
}
recipeCompound.addValue("i", input);
List<byte[]> output = new ArrayList<>();
for (ItemStack itemStack : out) {
output.add(serializeItem(itemStack));
}
recipeCompoun
```
<Overlap Ratio: 0.9781293624941834>

---

--- 263 --
Question ID: 5f1b4f49ce00715b49c9199388cde8ea63ceda40
Original Code:
```
public class CommandRunner {

  // For the moment one pool for all except
  public static ExecutorService executorService = new ThreadPoolExecutor(0,
      FlowConfiguration.getIntConfig(commonThreadPoolMaxSize), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
  public static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);

  public static ExecutorService getExecutorService() {
    return executorService;
  }

  public static <T> Future<T> submit(Runnable runnable) {
    return (Future<T>) getExecutorService().submit(runnable);
  }

  public static <T> Future<T> submit(Callable callable) {
    return (Future<T>) getExecutorService().submit(callable);
  }

  public static ScheduledFuture scheduleFuture(Runnable runnable, long timeout) {
    ScheduledFuture scheduledFuture = scheduledExecutorService.schedule(runnable, timeout, TimeUnit.MILLISECONDS);
    return scheduledFuture;
  }

  public static Object run(FlowDefinition flowDefinition, Object[] args) throws Exception {
    FlowCommand flowCommand = flowDefinition.getStartCommand();
    CommandContext commandContext = new CommandContext();
    commandContext.setArguments(args);
    commandContext.setFlowDefinition(flowDefinition);
    flowCommand.run(commandContext);

    return commandContext.getResult();
  }
}
```


Overlapping Code:
```
 moment one pool for all except
public static ExecutorService executorService = new ThreadPoolExecutor(0,
FlowConfiguration.getIntConfig(commonThreadPoolMaxSize), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
public static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);
public static ExecutorService getExecutorService() {
return executorService;
}
public static <T> Future<T> submit(Runnable runnable) {
return (Future<T>) getExecutorService().submit(runnable);
}
public static <T> Future<T> submit(Callable callable) {
return (Future<T>) getExecutorService().submit(callable);
}
public static ScheduledFuture scheduleFuture(Runnable runnable, long timeout) {
ScheduledFuture scheduledFuture = scheduledExecutorService.schedule(runnable, timeout, TimeUnit.MILLISECONDS);
return scheduledFuture;
}
public static Object run(FlowDefinition flowDefinition, Object[] args) throws Exception {
FlowCommand flowCommand = flowDefinition.getStartCommand();
CommandContext commandContext = new CommandContext();
commandContext.setArguments(args);
commandContext.setFlowDefinition(flowDefinition);
flowCommand.run(commandContext);
return commandContext.getR
```
<Overlap Ratio: 0.9592326139088729>

---

--- 264 --
Question ID: e37b6cadd228f4d4f6e8eeffd9c481d78a138217
Original Code:
```
class Allure2PluginTest {

    private Path directory;

    @BeforeEach
    void setUp(@TempDir final Path directory) {
        this.directory = directory;
    }

    @Test
    void shouldReadBeforesFromGroups() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/simple-testcase.json", generateTestResultName(),
                "allure2/first-testgroup.json", generateTestResultContainerName(),
                "allure2/second-testgroup.json", generateTestResultContainerName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1)
                .flatExtracting(TestResult::getBeforeStages)
                .hasSize(2)
                .extracting(StageResult::getName)
                .containsExactlyInAnyOrder("mockAuthorization", "loadTestConfiguration");
    }

    @Test
    void shouldReadAftersFromGroups() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/simple-testcase.json", generateTestResultName(),
                "allure2/first-testgroup.json", generateTestResultContainerName(),
                "allure2/second-testgroup.json", generateTestResultContainerName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1)
                .flatExtracting(TestResult::getAfterStages)
                .hasSize(2)
                .extracting(StageResult::getName)
                .containsExactlyInAnyOrder("unloadTestConfiguration", "cleanUpContext");
    }

    @SuppressWarnings("unchecked")
    @Test
    void shouldExcludeDuplicatedParams() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/duplicated-params.json", generateTestResultName()
        ).getResults();

        assertThat(testResults)
                .flatExtracting(TestResult::getParameters)
                .extracting(Parameter::getName, Parameter::getValue)
                .containsExactlyInAnyOrder(
                        tuple("name", "value"),
                        tuple("name2", "value"),
                        tuple("name", "value2"),
                        tuple("name2", "value2")
                );
    }

    @Test
    void shouldPickUpAttachmentsForTestCase() throws IOException {
        Set<TestResult> testResults = process(
                "allure2/simple-testcase.json", generateTestResultName(),
                "allure2/first-testgroup.json", generateTestResultContainerName(),
                "allure2/second-testgroup.json", generateTestResultContainerName(),
                "allure2/test-sample-attachment.txt", "test-sample-attachment.txt"
        ).getResults();

        assertThat(testResults)
                .describedAs("Test case is not found")
                .hasSize(1)
                .extracting(TestResult::getTestStage)
                .flatExtracting(StageResult::getSteps)
                .describedAs("Test case should have one step")
                .hasSize(1)
                .flatExtracting(Step::getAttachments)
                .describedAs("Step should have an attachment")
                .hasSize(1)
                .extracting(Attachment::getName)
                .containsExactly("String attachment in test");
    }

    @Test
    void shouldPickUpAttachmentsForAfters() throws IOException {
        Set<TestResult> testResults = process(
                "allure2/simple-testcase.json", generateTestResultName(),
                "allure2/first-testgroup.json", generateTestResultContainerName(),
                "allure2/second-testgroup.json", generateTestResultContainerName(),
                "allure2/after-sample-attachment.txt", "after-sample-attachment.txt"
        ).getResults();

        assertThat(testResults)
                .describedAs("Test case is not found")
                .hasSize(1)
                .flatExtracting(TestResult::getAfterStages)
                .describedAs("Test case should have afters")
                .hasSize(2)
                .flatExtracting(StageResult::getAttachments)
                .describedAs("Second after method should have an attachment")
                .hasSize(1)
                .extracting(Attachment::getName)
                .describedAs("Attachment's name is unexpected")
                .containsExactly("String attachment in after");
    }

    @Test
    void shouldDoNotOverrideAttachmentsForGroups() throws IOException {
        Set<TestResult> testResults = process(
                "allure2/other-testcase.json", generateTestResultName(),
                "allure2/other-testcase.json", generateTestResultName(),
                "allure2/second-testgroup.json", generateTestResultContainerName(),
                "allure2/after-sample-attachment.txt", "after-sample-attachment.txt"
        ).getResults();

        assertThat(testResults)
                .describedAs("Test cases is not found")
                .hasSize(2);

        testResults.forEach(testResult -> assertThat(testResult.getAfterStages())
                .hasSize(1)
                .flatExtracting(StageResult::getAttachments)
                .hasSize(1)
                .extracting(Attachment::getName)
                .containsExactly("String attachment in after"));

    }

    @Test
    void shouldProcessEmptyStatus() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/no-status.json", generateTestResultName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1)
                .extracting(TestResult::getStatus)
                .containsExactly(UNKNOWN);
    }

    @Test
    void shouldProcessNullStatus() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/null-status.json", generateTestResultName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1)
                .extracting(TestResult::getStatus)
                .containsExactly(UNKNOWN);
    }

    @Test
    void shouldProcessInvalidStatus() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/invalid-status.json", generateTestResultName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1)
                .extracting(TestResult::getStatus)
                .containsExactly(UNKNOWN);
    }

    @Test
    void shouldProcessNullStageTime() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/other-testcase.json", generateTestResultName(),
                "allure2/null-before-group.json", generateTestResultContainerName()
        ).getResults();

        assertThat(testResults)
                .hasSize(1);
    }

    @Test
    void shouldAddTestResultFormatLabel() throws Exception {
        Set<TestResult> testResults = process(
                "allure2/simple-testcase.json", generateTestResultName(),
                "allure2/first-testgroup.json", generateTestResultContainerName(),
                "allure2/second-testgroup.json", generateTestResultContainerName()
        ).getResults();

        assertThat(testResults)
                .extracting(result -> result.findOneLabel(LabelName.RESULT_FORMAT))
                .extracting(Optional::get)
                .containsOnly(Allure2Plugin.ALLURE2_RESULTS_FORMAT);
    }

    private LaunchResults process(String... strings) throws IOException {
        Iterator<String> iterator = Arrays.asList(strings).iterator();
        while (iterator.hasNext()) {
            String first = iterator.next();
            String second = iterator.next();
            copyFile(directory, first, second);
        }
        Allure2Plugin reader = new Allure2Plugin();
        final Configuration configuration = new ConfigurationBuilder().useDefault().build();
        final DefaultResultsVisitor resultsVisitor = new DefaultResultsVisitor(configuration);
        reader.readResults(configuration, resultsVisitor, directory);
        return resultsVisitor.getLaunchResults();
    }

    private void copyFile(Path dir, String resourceName, String fileName) throws IOException {
        try (InputStream is = getClass().getClassLoader().getResourceAsStream(resourceName)) {
            Files.copy(Objects.requireNonNull(is), dir.resolve(fileName));
        }
    }
}
```


Overlapping Code:
```
t {
private Path directory;
@BeforeEach
void setUp(@TempDir final Path directory) {
this.directory = directory;
}
@Test
void shouldReadBeforesFromGroups() throws Exception {
Set<TestResult> testResults = process(
"allure2/simple-testcase.json", generateTestResultName(),
"allure2/first-testgroup.json", generateTestResultContainerName(),
"allure2/second-testgroup.json", generateTestResultContainerName()
).getResults();
assertThat(testResults)
.hasSize(1)
.flatExtracting(TestResult::getBeforeStages)
.hasSize(2)
.extracting(StageResult::getName)
.containsExactlyInAnyOrder("mockAuthorization", "loadTestConfiguration");
}
@Test
void shouldReadAftersFromGroups() throws Exception {
Set<TestResult> testResults = process(
"allure2/simple-testcase.json", generateTestResultName(),
"allure2/first-testgroup.json", generateTestResultContainerName(),
"allure2/second-testgroup.json", generateTestResultContainerName()
).getResults();
assertThat(testResults)
.hasSize(1)
.flatExtracting(TestResult::getAfterStages)
.hasSize(2)
.extracting(StageResult::getName)
.containsExactlyInAnyOrder("unloadTestConfiguration", "cleanUpContext");
}
@SuppressWarnings("unchecked")
@Test
void shouldExcludeDuplicatedParams() throws Exception {
Set<TestResult> testResults = process(
"allure2/duplicated-params.json", generateTestResultName()
).getResults();
assertThat(testResults)
.flatExtracting(TestResult::getParameters)
.extracting(Parameter::getName, Parameter::getValue)
.containsExactlyInAnyOrder(
tuple("name", "value"),
tuple("name2", "value"),
tuple("name", "value2"),
tuple("name2", "value2")
);
}
@Test
void shouldPickUpAttachmentsForTestCase() throws IOException {
Set<TestResult> testResults = process(
"allure2/simple-testcase.json", generateTestResultName(),
"allure2/first-testgroup.json", generateTestResultContainerName(),
"allure2/sec
```
<Overlap Ratio: 0.9876210979547901>

---

--- 265 --
Question ID: 62b128546e839afeb4cf035b5ad88b2cbab5fb74
Original Code:
```
public class TapcardActivity extends Activity implements SurfaceHolder.Callback {
  private static final String TAG = TapcardActivity.class.getSimpleName();

  /**
   * Milliseconds between screen updates. Note that the fastest I've seen GPS
   * updates arrive is once per second.
   */
  private static long UPDATE_RATE = 100;
  private boolean isRunning;
  private UpdateHandler updater = new UpdateHandler();

  // Keys used in the bundle passed to this activity.
  private static final String PACKAGE_NAME = TapcardActivity.class.getPackage().getName();
  public static final String AIRPORT_ID = PACKAGE_NAME + "AirportId";

  // Dimensions of the "to" pointer in pixels
  private static final float POINTER_LENGTH = 17;
  private static final float POINTER_WIDTH = 12;

  private FlightMap flightMap;
  private AviationDbAdapter aviationDbAdapter;
  private LocationHandler locationHandler;
  private UserPrefs userPrefs;

  // Screen density
  private float density;

  // Magnetic variation w/ caching.
  private final CachedMagneticVariation magneticVariation = new CachedMagneticVariation();

  // Last known bearing
  private float lastBearing;

  // Items for the navigation display.
  private LatLng airportLatLng;
  private Path airplanePath = MapView.createAirplanePath();
  private Path pointerPath = new Path();
  private SurfaceView miniMap;
  private SurfaceHolder holder;
  private TextView distanceText;
  private TextView bearingText;
  private TextView eteText;
  private Paint navigationPaint = new Paint();
  private float[] distanceBearingResult = new float[2]; 
  
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // No title bar. This must be done before setContentView.
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    setContentView(R.layout.tapcard);

    flightMap = (FlightMap) getApplication();
    // Open database connection.
    userPrefs = new UserPrefs(flightMap);
    try {
      aviationDbAdapter = new CachedAviationDbAdapter(new AndroidAviationDbAdapter(userPrefs));
      aviationDbAdapter.open();
    } catch (Throwable t) {
      Log.w(TAG, "Unable to open database", t);
      finish();
    }

    // Screen density. Scale pixel sizes up based on this.
    density = getResources().getDisplayMetrics().density;

    // Get location updates
    locationHandler = flightMap.getLocationHandler();

    // Find which airport to show.
    final Intent startingIntent = getIntent();
    int airportId = startingIntent.getIntExtra(AIRPORT_ID, -1);
    Airport airport = aviationDbAdapter.getAirport(airportId);
    if (null == airport) {
      Log.w(TAG, "Unable to get airport for id " + airportId);
      finish();
    }
    initializeTapcardUi(airport, getResources());
  }

  /**
   * Initializes the tapcard UI. Should only be called once from onCreate().
   */
  private void initializeTapcardUi(Airport airport, Resources res) {
    // ICAO id and airport name.
    setIcaoAndName(airport, res);

    // Navigation info to airport
    setNavigationInfo(airport, res);

    // Communication info
    final List<Comm> comms = aviationDbAdapter.getAirportComms(airport.id);
    if (comms != null) {
      final CommDisplayManager commDisplayManager = new CommDisplayManager(comms);
      addCommInfo(commDisplayManager.getSortedComms(), res);
    }

    // Runway details
    addRunways(airport.runways, res);

    // Elevation
    addElevation(airport);
  }

  /**
   * Sets color for ICAO and name item at the top.
   */
  private void setIcaoAndName(Airport airport, Resources res) {
    TableRow nameRow = (TableRow) findViewById(R.id.tapcard_icao_and_name_row);
    int nameBackground =
        airport.isTowered ? res.getColor(R.color.ToweredAirport) : res
            .getColor(R.color.NonToweredAirport);
    nameRow.setBackgroundColor(nameBackground);

    // ICAO
    TextView icaoText = (TextView) findViewById(R.id.tapcard_icao);
    icaoText.setText(airport.icao);

    // Name
    TextView airportName = (TextView) findViewById(R.id.tapcard_airport_name);
    airportName.setText(airport.name);
  }

  /**
   * Sets up the static parts of the navigation display.
   */
  private void setNavigationInfo(Airport airport, Resources res) {
    airportLatLng = airport.location;
    navigationPaint.setColor(res.getColor(R.color.AircraftPaint));
    navigationPaint.setStrokeWidth(1.5f);
    navigationPaint.setAntiAlias(true);

    // Create path for the pointer.
    pointerPath.lineTo(POINTER_WIDTH / 2f, 0);
    pointerPath.lineTo(0, -POINTER_LENGTH);
    pointerPath.lineTo(-POINTER_WIDTH / 2f, 0);
    pointerPath.close();

    miniMap = (SurfaceView) findViewById(R.id.tapcard_minimap);
    holder = miniMap.getHolder();
    holder.addCallback(this);
    distanceText = (TextView) findViewById(R.id.tapcard_distance);
    bearingText = (TextView) findViewById(R.id.tapcard_bearing);
    eteText = (TextView) findViewById(R.id.tapcard_ete);
  }

  /**
   * Adds communication frequencies to the tapcard.
   */
  private void addCommInfo(final List<Comm> comms, Resources res) {
    final TableLayout commTable = (TableLayout) findViewById(R.id.tapcard_comm_table);
    final LayoutParams rowLayout =
        new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT);
    final int mainTextColor = res.getColor(R.color.TapcardForeground);
    final int annotationTextColor = res.getColor(R.color.TapcardForegroundAnnotation);

    if (comms == null) {
      TableRow emptyRow = new TableRow(this);
      emptyRow.setLayoutParams(rowLayout);
      TextView emptyMsg = new TextView(this);
      emptyMsg.setText(R.string.no_comm_freqs);
      emptyMsg.setTypeface(Typeface.SANS_SERIF);
      emptyMsg.setTextColor(annotationTextColor);
      emptyMsg.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);
      emptyMsg.setPadding(5, 10, 5, 0);
      emptyRow.addView(emptyMsg);
      commTable.addView(emptyRow);
      return;
    }

    for (Comm comm : comms) {
      TableRow commRow = new TableRow(this);
      commRow.setLayoutParams(rowLayout);

      // Identifier cell
      TextView ident = new TextView(this);
      ident.setText(comm.identifier);
      ident.setTypeface(Typeface.SANS_SERIF);
      ident.setTextColor(mainTextColor);
      ident.setTextSize(TypedValue.DENSITY_DEFAULT, 18 * density);
      ident.setPadding(5, 25, 5, 0);
      commRow.addView(ident);

      // Frequency cell
      TextView frequency = new TextView(this);
      frequency.setText(comm.frequency);
      frequency.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);
      frequency.setTextColor(mainTextColor);
      frequency.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);
      frequency.setPadding(10, 0, 5, 0);
      commRow.addView(frequency);

      commTable.addView(commRow);


      if (comm.remarks != null && comm.remarks.length() > 0) {
        commRow = new TableRow(this);
        commRow.setLayoutParams(rowLayout);
        TextView remarks = new TextView(this);
        remarks.setText(comm.remarks);
        remarks.setTypeface(Typeface.SANS_SERIF);
        remarks.setTextColor(annotationTextColor);
        remarks.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);
        remarks.setPadding(5, 0, 0, 0);

        commRow.addView(remarks);
        commTable.addView(commRow);
      }
    }
  }

  /**
   * Adds runway details to the tapcard.
   * 
   * @param res
   */
  private void addRunways(SortedSet<Runway> runways, Resources res) {
    final LinearLayout runwayLayout = (LinearLayout) findViewById(R.id.tapcard_runway_layout);
    final int textColor = res.getColor(R.color.TapcardForeground);
    final int textAnnotationColor = res.getColor(R.color.TapcardForegroundAnnotation);

    // Paint a horizontal rule to separate runway section from comms
    // TODO shobe to add drawable or whatever

    for (Runway runway : runways) {
      TextView letters = new TextView(this);
      letters.setText(runway.letters);
      letters.setTypeface(Typeface.SANS_SERIF, Typeface.BOLD);
      letters.setTextColor(textColor);
      letters.setTextSize(TypedValue.DENSITY_DEFAULT, 22 * density);
      letters.setPadding(5, 5, 5, 0);
      runwayLayout.addView(letters);

      TextView size = new TextView(this);
      size.setText(runway.length + "x" + runway.width + " " + runway.surface);
      size.setTypeface(Typeface.SANS_SERIF);
      size.setTextColor(textAnnotationColor);
      size.setTextSize(TypedValue.DENSITY_DEFAULT, 15 * density);
      size.setPadding(5, 0, 5, 10);
      runwayLayout.addView(size);
    }
  }

  /**
   * Adds airport elevation to the tapcard
   */
  private void addElevation(Airport airport) {
    final Map<String, String> airportProperties =
        aviationDbAdapter.getAirportProperties(airport.id);
    if (airportProperties == null) {
      return;
    }
    String elevation = airportProperties.get("Elevation");
    if (elevation == null) {
      return;
    }
    TextView elevationText = (TextView) findViewById(R.id.tapcard_elevation);
    elevationText.setText("ELEV " + elevation + "' MSL");
    elevationText.setPadding(10, 0, 0, 0);
  }

  @Override
  protected void onResume() {
    super.onResume();
    locationHandler.startListening();
    setRunning(true);
    update();
  }

  @Override
  protected void onPause() {
    super.onPause();
    setRunning(false);
    locationHandler.stopListening();
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    if (aviationDbAdapter != null) {
      aviationDbAdapter.close();
    }
  }

  /**
   * Surface dimensions changed.
   */
  @Override
  public synchronized void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
  }

  @Override
  public synchronized void surfaceCreated(SurfaceHolder holder) {
    this.holder = holder;
  }

  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
    this.holder = null;
  }

  /**
   * Updates the view every {@link #UPDATE_RATE} milliseconds using
   * {@link UpdateHandler}.
   */
  private void update() {
    updater.scheduleUpdate(UPDATE_RATE);
    if (!isRunning()) {
      return;
    }
    updateNavigationDisplay();
  }

  /**
   * Updates the pointer, distance, bearing and ETE to the selected airport.
   * This is called repeatedly by {@link #update()}.
   */
  private void updateNavigationDisplay() {
    final Location location = locationHandler.getLocation();
    float magneticConversion = 0;
    if (location != null) {
      final LatLng locationLatLng =
          LatLng.fromDouble(location.getLatitude(), location.getLongitude());
      magneticConversion =
          magneticVariation.getMagneticVariation(locationLatLng, (float) location.getAltitude());
    }

    setDistanceBearingResult(location);
    updateNavigationMiniMap(location, locationHandler.isLocationCurrent()
        && locationHandler.isLocationAccurate());
    updateNavigationTextItems(location, magneticConversion);
  }

  /**
   * Stores the distance and bearing from {@code location} to {@code
   * airportLatLng} in distanceBearingResult[]. Index 0 will be the distance in
   * meters, index 1 will be the bearing in true degrees.
   */
  private synchronized void setDistanceBearingResult(Location location) {
    // Calculate distance and bearing to airport.
    final double locationLat = location.getLatitude();
    final double locationLng = location.getLongitude();
    // results[0]===distance, results[1]==bearing
    Location.distanceBetween(locationLat, locationLng, airportLatLng.latDeg(), airportLatLng
        .lngDeg(), distanceBearingResult);
  }

  /**
   * Updates the mini map pointing to the airport.
   */
  private synchronized void updateNavigationMiniMap(Location location, boolean isCurrentLocation) {
    Canvas c = null;
    try {
      if (null == holder) {
        return;
      }
      c = holder.lockCanvas();
      synchronized (holder) {
        if (c != null) {
          c.drawColor(Color.BLACK);
          if (location == null) {
            return;
          }

          // Update bearing (if possible)
          if (location.hasBearing()) {
            lastBearing = location.getBearing();
          }

          // Center everythng on the canvas.
          c.translate(c.getWidth() / 2, c.getHeight() / 2);
          // Scale the image down based on the size of the canvas.
          final int width = c.getWidth();
          final float imageScale = width / 150f;
          c.save();
          c.scale(imageScale, imageScale);

          // Rotate the airplane, then draw it.
          // For north-up, rotate the airplane to its current track.
          // Do nothing for track-up (the airplane pointing up is right).
          if (userPrefs.isNorthUp()) {
            c.rotate(lastBearing);
          }
          navigationPaint.setStyle(Paint.Style.FILL);
          c.scale(density, density);
          if (isCurrentLocation) {
            c.drawPath(airplanePath, MapView.AIRPLANE_SOLID_PAINT);
          } else {
            c.drawPath(airplanePath, MapView.AIRPLANE_OUTLINE_STROKE_PAINT);
          }

          // Undo the downscaling and rotation for the airplane.
          c.restore();
          
          // If the location isn't current, the draw a red slash
          if (!isCurrentLocation) {
            float slashLength = POINTER_LENGTH * density;
            c.drawLine(-slashLength, -slashLength, slashLength, slashLength, MapView.RED_SLASH_PAINT);
            return;
          }

          // Draw a circle around the airplane.
          navigationPaint.setStyle(Paint.Style.STROKE);
          float radius = (width / 2f) - POINTER_LENGTH;
          c.drawCircle(0, 0, radius, navigationPaint);

          // Calculate pointer direction. If in north-up mode, the it's just
          // bearingTo, otherwise it's the relative bearing to.
          float bearingTo = distanceBearingResult[1];
          if (!userPrefs.isNorthUp()) {
            bearingTo = (float) NavigationUtil.normalizeBearing(bearingTo - lastBearing);
          }

          // Rotate the pointer and draw it.
          c.rotate(bearingTo);
          c.translate(0, -radius);
          navigationPaint.setStyle(Paint.Style.FILL);
          c.drawPath(pointerPath, navigationPaint);
        }
      }
    } finally {
      if (c != null) {
        holder.unlockCanvasAndPost(c);
      }
    }
  }

  /**
   * Updates the distance, bearing and ete text items.
   */
  private synchronized void updateNavigationTextItems(final Location location,
      float magneticConversion) {
    if (null == location) {
      distanceText.setText("Location unavailable");
      bearingText.setText("");
      eteText.setText("");
      return;
    }

    final float distanceMeters = distanceBearingResult[0];
    final float bearingTo =
        (float) NavigationUtil.normalizeBearing(distanceBearingResult[1] + magneticConversion);

    DistanceUnits distanceUnits = userPrefs.getDistanceUnits();
    String distance =
        String.format("      %.1f%s", distanceUnits.getDistance(distanceMeters),
            distanceUnits.distanceAbbreviation);
    distanceText.setText(distance);
    bearingText.setText(String.format(" %03.0f%s", bearingTo, MapView.DEGREES_SYMBOL));

    final DistanceUnits nauticalUnits = DistanceUnits.NAUTICAL_MILES;
    final double speedInKnots = nauticalUnits.getSpeed(location.getSpeed());
    if (speedInKnots > 3) {
      final float metersPerSecond = location.getSpeed();
      float timeInSeconds = distanceMeters / metersPerSecond;
      int hours = (int) (timeInSeconds / 60 / 60);
      int minutes = (int) (timeInSeconds / 60) - (hours * 60);
      int seconds = (int) (timeInSeconds - (hours * 60 * 60) - (minutes * 60));

      // Normally hours will be 0, so omit if possible.
      if (hours == 0) {
        eteText.setText(String.format(" %d:%02d", minutes, seconds));
      } else {
        eteText.setText(String.format(" %d:%02d:%02d", hours, minutes, seconds));
      }
    } else {
      eteText.setText("");
    }
  }

  /**
   * Updates the UI using a delayed message.
   */
  private class UpdateHandler extends Handler {
    private static final int UPDATE_MESSAGE = 1;

    @Override
    public void handleMessage(Message msg) {
      update();
    }

    /**
     * Call {@link #update} after {@code delay} milliseconds.
     */
    public void scheduleUpdate(long delay) {
      removeMessages(UPDATE_MESSAGE);
      sendMessageDelayed(obtainMessage(UPDATE_MESSAGE), delay);
    }
  }

  private synchronized boolean isRunning() {
    return isRunning;
  }

  private synchronized void setRunning(boolean isRunning) {
    this.isRunning = isRunning;
  }
}
```


Overlapping Code:
```
Activity extends Activity implements SurfaceHolder.Callback {
private static final String TAG = TapcardActivity.class.getSimpleName();
/**
* Milliseconds between screen updates. Note that the fastest I've seen GPS
* updates arrive is once per second.
*/
private static long UPDATE_RATE = 100;
private boolean isRunning;
private UpdateHandler updater = new UpdateHandler();
// Keys used in the bundle passed to this activity.
private static final String PACKAGE_NAME = TapcardActivity.class.getPackage().getName();
public static final String AIRPORT_ID = PACKAGE_NAME + "AirportId";
// Dimensions of the "to" pointer in pixels
private static final float POINTER_LENGTH = 17;
private static final float POINTER_WIDTH = 12;
private FlightMap flightMap;
private AviationDbAdapter aviationDbAdapter;
private LocationHandler locationHandler;
private UserPrefs userPrefs;
// Screen density
private float density;
// Magnetic variation w/ caching.
private final CachedMagneticVariation magneticVariation = new CachedMagneticVariation();
// Last known bearing
private float lastBearing;
// Items for the navigation display.
private LatLng airportLatLng;
private Path airplanePath = MapView.createAirplanePath();
private Path pointerPath = new Path();
private SurfaceView miniMap;
private SurfaceHolder holder;
private TextView distanceText;
private TextView bearingText;
private TextView eteText;
private Paint navigationPaint = new Paint();
private float[] distanceBearingResult = new float[2]; 

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
// No title bar. This must be done before setContentView.
requestWindowFeature(Window.FEATURE_NO_TITLE);
setContentView(R.layout.tapcard);
flightMap = (FlightMap) getApplication();
// Open database connection.
userPrefs = new UserPrefs(flightMap);
try {
aviationDbAdapter = new CachedAviationDbAdapter(new AndroidAviationDbAdapter(userPrefs));
aviationDbAdapter.open();
} catch (Throwable t) {
Log.w(TAG, "Unable to open database", t);
finish();
}
// Screen density. Scale pixel sizes up based on this.
density = getResources().getDisplayMetrics().density;
// Get location updates
locationHandler = flightMap.getLocationHandler();
// Find which airport to show.
final Intent star
```
<Overlap Ratio: 0.9788428324697754>

---

--- 266 --
Question ID: 639803c91bd894ec45208b20531f231b66d75b82
Original Code:
```
@RestController
public class ContestRankController {

    @Autowired
    private ContestDao contestDao;

    private final CachedRank cachedRank;

    public ContestRankController(CachedRank cachedRank) {
        this.cachedRank = cachedRank;
    }

    @RequestMapping("api/contest_rank")
    public Object getContestRank(@RequestParam(value = "offset",defaultValue = "0") Integer offset,
                                 @RequestParam(value = "limit",required = false) Integer limit,
                                 @RequestParam("contest_id") Integer contest_id,
                                 @RequestParam(value = "force_refresh",required = false) Integer force_refresh,
                                 @RequestParam(value = "download_csv",required = false) Integer download_csv,
                                 HttpServletRequest request) {
        if(download_csv!=null&&download_csv!=0){
            try {
                User user = Authentication.getUser(request);
                boolean admin = Authentication.isAdministrator(user);
                if (user == null || !admin) {
                    return new ReturnType("error", "you are not administrator");
                }
                CachedRank.writeCSV(Integer.toString(contest_id),contestDao.getProblemsID(contest_id).size(),cachedRank.getRank(contest_id,0));
                File file = new File("cachedrank/"+contest_id+".csv");
                Path path = Paths.get(file.getAbsolutePath());
                ByteArrayResource resource = new ByteArrayResource(Files.readAllBytes(path));

                HttpHeaders headers = new HttpHeaders();
                headers.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename="+contestDao.getContest(contest_id).getTitle()+"_Rank.csv");

                return ResponseEntity.ok()
                        .headers(headers)
                        .contentLength(file.length())
                        .contentType(MediaType.parseMediaType("application/octet-stream"))
                        .body(resource);
            }catch (Exception e){
                e.printStackTrace();
                return new ReturnType<>("error",e.getMessage());
            }
        }
        Integer frozen=contestDao.getFrozen(contest_id);
        if(frozen==null){
            frozen=0;
        }
//        if (force_refresh !=null && force_refresh !=0) {
//            cachedRank.refresh(contest_id,frozen);
//            if(frozen!=0){
//                cachedRank.refresh(contest_id,0);
//            }
//        }
//        Contest contest=contestDao.getContest(contest_id);

        User user = Authentication.getUser(request);
        if(Authentication.isAdministrator(user)){
            frozen=0;
        }
        var res = cachedRank.getRank(contest_id,frozen);
        int end = Math.min(res.size(), offset + limit);
        return new ReturnType<>(new ReturnListType<>(res.subList(offset, end), res.size()));
    }

    @GetMapping("api/contest_rank/myrank")
    public ReturnType<ReturnListType> getMyRank(@RequestParam("id") Integer id,HttpServletRequest request){
        Integer frozen=contestDao.getFrozen(id);
        if(frozen==null){
            frozen=-1000;
        }
        User user = Authentication.getUser(request);
        if(user==null){
            return new ReturnType<>(new ReturnListType(new ArrayList(),0));
        }
        var ranklist=cachedRank.getRank(id,0);
        ArrayList res=new ArrayList();
        try {
            for(var c:ranklist){
                if(Objects.equals(c.getUser().getId(), user.getId())){
                    long end=contestDao.getContest(id).getEnd_time().getTime();
                    try {
                        Solve solve = (Solve) c.clone();
                        if (end - frozen * 60 * 1000 < System.currentTimeMillis()) {
                            solve.setRank("?");
                        }
                        res.add(solve);
                    }catch (Exception e){
                        e.printStackTrace();
                    }
                    return new ReturnType<>(new ReturnListType(res,1));
                }
            }
        }catch (Exception e){
            return new ReturnType<>(new ReturnListType(new ArrayList(),0));
        }
        return new ReturnType<>(new ReturnListType(new ArrayList(),0));
    }


}
```


Overlapping Code:
```
oller {
@Autowired
private ContestDao contestDao;
private final CachedRank cachedRank;
public ContestRankController(CachedRank cachedRank) {
this.cachedRank = cachedRank;
}
@RequestMapping("api/contest_rank")
public Object getContestRank(@RequestParam(value = "offset",defaultValue = "0") Integer offset,
@RequestParam(value = "limit",required = false) Integer limit,
@RequestParam("contest_id") Integer contest_id,
@RequestParam(value = "force_refresh",required = false) Integer force_refresh,
@RequestParam(value = "download_csv",required = false) Integer download_csv,
HttpServletRequest request) {
if(download_csv!=null&&download_csv!=0){
try {
User user = Authentication.getUser(request);
boolean admin = Authentication.isAdministrator(user);
if (user == null || !admin) {
return new ReturnType("error", "you are not administrator");
}
CachedRank.writeCSV(Integer.toString(contest_id),contestDao.getProblemsID(contest_id).size(),cachedRank.getRank(contest_id,0));
File file = new File("cachedrank/"+contest_id+".csv");
Path path = Paths.get(file.getAbsolutePath());
ByteArrayResource resource = new ByteArrayResource(Files.readAllBytes(path));
HttpHeaders headers = new HttpHeaders();
headers.add(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename="+contestDao.getContest(contest_id).getTitle()+"_Rank.csv");
return ResponseEntity.ok()
.headers(headers)
.contentLength(file.length())
.contentType(MediaType.parseMediaType("application/octet-stream"))
.body(resource);
}catch (Exception e){
e.printStackTrace();
return new ReturnType<>("error",e.getMessage());
}
}
Integer frozen=contestDao.getFrozen(contest_id);
if(frozen==null){
frozen=0;
}
// if (force_refresh !=null && force_refresh !=0) {
// cachedRank.refresh(contest_id,frozen);
// i
```
<Overlap Ratio: 0.9531590413943355>

---

--- 267 --
Question ID: 4f248da82bb29dffe2f3b35145a9a4712f3910e2
Original Code:
```
public class TestVeritestingDumpXML {

    void testHarness(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7, char c8) {
        int outSPF = SPFWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
        int outJR = JRWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
        checkEquality(outSPF, outJR);
    }

    public void checkEquality(int outSPF, int outJR) {
        if (outSPF == outJR) System.out.println("Match");
        else {
            System.out.println("Mismatch");
            assert(false);
        }
//        assert(outSPF == outJR);
    }

    public int SPFWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
                                        char c6, char c7, char c8) {
        return NonVeritest(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
    }

    // This is a special method. Call this method to prevent SPF from veritesting any regions that appear in any
    // function or method call higher up in the stack. In the future, this call to SPFWrapperInner can be changed to
    // be a generic method call if other no-veritesting methods need to be invoked.
    private int NonVeritest(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
                                         char c6, char c7, char c8){
        return SPFWrapperInner(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
    }

    private int SPFWrapperInner(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
                                              char c6, char c7, char c8) {
        int ret = v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);
        return ret;
    }

    public int JRWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6,
                                       char c7, char c8) {
        return v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);
    }

    public void runTest(DumpXMLEqCheck t) {
        testHarness(t, '1', '2', '3', '4', '5', '6', '7', '8', '9');
    }
}
```


Overlapping Code:
```
tVeritestingDumpXML {
void testHarness(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6, char c7, char c8) {
int outSPF = SPFWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
int outJR = JRWrapper(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
checkEquality(outSPF, outJR);
}
public void checkEquality(int outSPF, int outJR) {
if (outSPF == outJR) System.out.println("Match");
else {
System.out.println("Mismatch");
assert(false);
}
// assert(outSPF == outJR);
}
public int SPFWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
char c6, char c7, char c8) {
return NonVeritest(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
}
// This is a special method. Call this method to prevent SPF from veritesting any regions that appear in any
// function or method call higher up in the stack. In the future, this call to SPFWrapperInner can be changed to
// be a generic method call if other no-veritesting methods need to be invoked.
private int NonVeritest(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
char c6, char c7, char c8){
return SPFWrapperInner(v, c0, c1, c2, c3, c4, c5, c6, c7, c8);
}
private int SPFWrapperInner(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5,
char c6, char c7, char c8) {
int ret = v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);
return ret;
}
public int JRWrapper(DumpXMLEqCheck v, char c0, char c1, char c2, char c3, char c4, char c5, char c6,
char c7, char c8) {
return v.testFunction(c0, c1, c2, c3, c4, c5, c6, c7, c8);
}
public void runTest(DumpXMLEqCheck t) {
testHarness(t, '1', '2', '3', '4', '5', '6', '7', '8', '9');
}
```
<Overlap Ratio: 0.9892086330935251>

---

--- 268 --
Question ID: 4bf26f31aafe4f78aeb843511bd7f32277f6001a
Original Code:
```
public class BinaryMinHeap<T> {
    private List<Node> allNodes = new ArrayList<>();
    private Map<T,Integer> nodePosition = new HashMap<>();

    public class Node {
        int weight;
        T key;
    }

    /**
     * Checks where the key exists in heap or not
     */
    public boolean containsData(T key){
        return nodePosition.containsKey(key);
    }

    /**
     * Add key and its weight to they heap
     */
    public void add(int weight,T key) {
        Node node = new Node();
        node.weight = weight;
        node.key = key;
        allNodes.add(node);
        int size = allNodes.size();
        int current = size - 1;
        int parentIndex = (current - 1) / 2;
        nodePosition.put(node.key, current);

        while (parentIndex >= 0) {
            Node parentNode = allNodes.get(parentIndex);
            Node currentNode = allNodes.get(current);
            if (parentNode.weight > currentNode.weight) {
                swap(parentNode,currentNode);
                updatePositionMap(parentNode.key,currentNode.key,parentIndex,current);
                current = parentIndex;
                parentIndex = (parentIndex - 1) / 2;
            } else {
                break;
            }
        }
    }

    /**
     * Get the heap min without extracting the key
     */
    public T min(){
        return allNodes.get(0).key;
    }

    /**
     * Checks with heap is empty or not
     */
    public boolean empty(){
        return allNodes.size() == 0;
    }

    /**
     * Decreases the weight of given key to newWeight
     */
    public void decrease(T data, int newWeight){
        Integer position = nodePosition.get(data);
        allNodes.get(position).weight = newWeight;
        int parent = (position -1 )/2;
        while(parent >= 0){
            if(allNodes.get(parent).weight > allNodes.get(position).weight){
                swap(allNodes.get(parent), allNodes.get(position));
                updatePositionMap(allNodes.get(parent).key,allNodes.get(position).key,parent,position);
                position = parent;
                parent = (parent-1)/2;
            }else{
                break;
            }
        }
    }

    /**
     * Get the weight of given key
     */
    public Integer getWeight(T key) {
        Integer position = nodePosition.get(key);
        if( position == null ) {
            return null;
        } else {
            return allNodes.get(position).weight;
        }
    }

    /**
     * Returns the min node of the heap
     */
    public Node extractMinNode() {
        int size = allNodes.size() -1;
        Node minNode = new Node();
        minNode.key = allNodes.get(0).key;
        minNode.weight = allNodes.get(0).weight;

        int lastNodeWeight = allNodes.get(size).weight;
        allNodes.get(0).weight = lastNodeWeight;
        allNodes.get(0).key = allNodes.get(size).key;
        nodePosition.remove(minNode.key);
        nodePosition.remove(allNodes.get(0));
        nodePosition.put(allNodes.get(0).key, 0);
        allNodes.remove(size);

        int currentIndex = 0;
        size--;
        while(true){
            int left = 2*currentIndex + 1;
            int right = 2*currentIndex + 2;
            if(left > size){
                break;
            }
            if(right > size){
                right = left;
            }
            int smallerIndex = allNodes.get(left).weight <= allNodes.get(right).weight ? left : right;
            if(allNodes.get(currentIndex).weight > allNodes.get(smallerIndex).weight){
                swap(allNodes.get(currentIndex), allNodes.get(smallerIndex));
                updatePositionMap(allNodes.get(currentIndex).key,allNodes.get(smallerIndex).key,currentIndex,smallerIndex);
                currentIndex = smallerIndex;
            }else{
                break;
            }
        }
        return minNode;
    }
    /**
     * Extract min value key from the heap
     */
    public T extractMin(){
        Node node = extractMinNode();
        return node.key;
    }

    private void printPositionMap(){
        System.out.println(nodePosition);
    }

    private void swap(Node node1,Node node2){
        int weight = node1.weight;
        T data = node1.key;

        node1.key = node2.key;
        node1.weight = node2.weight;

        node2.key = data;
        node2.weight = weight;
    }

    private void updatePositionMap(T data1, T data2, int pos1, int pos2){
        nodePosition.remove(data1);
        nodePosition.remove(data2);
        nodePosition.put(data1, pos1);
        nodePosition.put(data2, pos2);
    }

    public void printHeap(){
        for(Node n : allNodes){
            System.out.println(n.weight + " " + n.key);
        }
    }

    public static void main(String args[]){
        BinaryMinHeap<String> heap = new BinaryMinHeap<String>();
        heap.add(3, "Tushar");
        heap.add(4, "Ani");
        heap.add(8, "Vijay");
        heap.add(10, "Pramila");
        heap.add(5, "Roy");
        heap.add(6, "NTF");
        heap.add(2,"AFR");
        heap.decrease("Pramila", 1);
        heap.printHeap();
        heap.printPositionMap();
    }
}
```


Overlapping Code:
```
<T> {
private List<Node> allNodes = new ArrayList<>();
private Map<T,Integer> nodePosition = new HashMap<>();
public class Node {
int weight;
T key;
}
/**
* Checks where the key exists in heap or not
*/
public boolean containsData(T key){
return nodePosition.containsKey(key);
}
/**
* Add key and its weight to they heap
*/
public void add(int weight,T key) {
Node node = new Node();
node.weight = weight;
node.key = key;
allNodes.add(node);
int size = allNodes.size();
int current = size - 1;
int parentIndex = (current - 1) / 2;
nodePosition.put(node.key, current);
while (parentIndex >= 0) {
Node parentNode = allNodes.get(parentIndex);
Node currentNode = allNodes.get(current);
if (parentNode.weight > currentNode.weight) {
swap(parentNode,currentNode);
updatePositionMap(parentNode.key,currentNode.key,parentIndex,current);
current = parentIndex;
parentIndex = (parentIndex - 1) / 2;
} else {
break;
}
}
}
/**
* Get the heap min without extracting the key
*/
public T min(){
return allNodes.get(0).key;
}
/**
* Checks with heap is empty or not
*/
public boolean empty(){
return allNodes.size() == 0;
}
/**
* Decreases the weight of given key to newWeight
*/
public void decrease(T data, int newWeight){
Integer position = nodePosition.get(data);
allNodes.get(position).weight = newWeight;
int parent = (position -1 )/2;
while(parent >= 0){
if(allNodes.get(parent).weight > allNodes.get(position).weight){
swap(allNodes.get(parent), allNodes.get(position));
updatePositionMap(allNodes.get(parent).key,allNodes.get(position).key,parent,position);
position = parent;
parent = (parent-1)/2;
}else{
break;
}
}
}
/**
* Get the weight of given key
*/
public Integer getWeight(T key) {
Integer position = nodePosition.get(key);
if( position == null ) {
return null;
} else {
return allNodes.get(position
```
<Overlap Ratio: 0.9672219236969372>

---

--- 269 --
Question ID: 26a4299e1e00e69d2b72ef73fe98d474ee2b4767
Original Code:
```
public class BundleWatcher implements Runnable, BundleListener {

    private final Logger logger = LoggerFactory.getLogger(BundleWatcher.class);

    private BundleContext bundleContext;
    private ConfigurationAdmin configurationAdmin;

    private AtomicBoolean running = new AtomicBoolean(false);
    private long interval = 1000L;
    private List<String> watchURLs = new CopyOnWriteArrayList<String>();
    private AtomicInteger counter = new AtomicInteger(0);


    /**
     * Construcotr
     */
    public BundleWatcher() {
    }

    public void bundleChanged(BundleEvent event) {
        if (event.getType() == BundleEvent.INSTALLED
                || event.getType() == BundleEvent.UNINSTALLED) {
            counter.incrementAndGet();
        }
    }

    public void run() {
        if (logger.isDebugEnabled()) {
            logger.debug("Bundle watcher thread started");
        }
        int oldCounter = -1;
        Set<Bundle> watchedBundles = new HashSet<Bundle>();
        while (running.get() && watchURLs.size()>0) {
            if (oldCounter != counter.get()) {
                oldCounter = counter.get();
                watchedBundles.clear();
                for (String bundleURL : watchURLs) {
                    for (Bundle bundle : getBundlesByURL(bundleURL)) {
                        watchedBundles.add(bundle);
                    }
                }
            }
            if (watchedBundles.size()>0) {
                File localRepository = getLocalRepository();
                for (Bundle bundle : watchedBundles) {
                    try {
                        File location = getBundleExternalLocation(localRepository, bundle);
                        if (location != null
                                && location.exists()
                                && location.lastModified() > bundle.getLastModified())
                        {
                            InputStream is = new FileInputStream(location);
                            try {
                                System.out.println("[Watch] Updating watched bundle: " + bundle.getSymbolicName() + " (" + bundle.getVersion() + ")");
                                bundle.update(is);
                            } finally {
                                is.close();
                            }
                        }
                    } catch (IOException ex) {
                        logger.error("Error watching bundle.", ex);
                    } catch (BundleException ex) {
                        logger.error("Error updating bundle.", ex);
                    }
                }
            }
            try {
                Thread.sleep(interval);
            } catch (InterruptedException ex) {
                running.set(false);
            }
        }

        if (logger.isDebugEnabled()) {
            logger.debug("Bundle watcher thread stopped");
        }
    }

    /**
     * Adds a Bundle URLs to the watch list.
     * @param url
     */
    public void add(String url) {
        boolean shouldStart = running.get() && (watchURLs.size()==0);
        if (!watchURLs.contains(url)) {
            watchURLs.add(url);
            counter.incrementAndGet();
        }
        if (shouldStart) {
            Thread thread = new Thread(this);
            thread.start();
        }
    }

    /**
     * Removes a bundle URLs from the watch list.
     * @param url
     */
    public void remove(String url) {
        watchURLs.remove(url);
        counter.incrementAndGet();
    }

    /**
     * Returns the location of the Bundle inside the local maven repository.
     * @param bundle
     * @return
     */
    public File getBundleExternalLocation(File localRepository, Bundle bundle) {
        try {
            Parser p = new Parser(bundle.getLocation().substring(4));
            return new File(localRepository.getPath() + File.separator + p.getArtifactPath());
        } catch (MalformedURLException e) {
            logger.error("Could not parse artifact path for bundle" + bundle.getSymbolicName(), e);
        }
        return null;
    }

    public File getLocalRepository() {
        // Attempt to retrieve local repository location from MavenConfiguration
        MavenConfiguration configuration = retrieveMavenConfiguration();
        if (configuration != null) {
            MavenRepositoryURL localRepositoryURL = configuration.getLocalRepository();
            if (localRepositoryURL != null) {
                return localRepositoryURL.getFile().getAbsoluteFile();
            }
        }
        // If local repository not found assume default.
        String localRepo = System.getProperty("user.home") + File.separator + ".m2" + File.separator + "repository";
        return new File(localRepo).getAbsoluteFile();
    }

    protected MavenConfiguration retrieveMavenConfiguration() {
        MavenConfiguration mavenConfiguration = null;
        try {
            Configuration configuration = configurationAdmin.getConfiguration(ServiceConstants.PID);
            if (configuration != null) {
                Dictionary dictonary = configuration.getProperties();
                if (dictonary != null) {
                    DictionaryPropertyResolver resolver = new DictionaryPropertyResolver(dictonary);
                    mavenConfiguration = new MavenConfigurationImpl(resolver, ServiceConstants.PID);
                }
            }
        } catch (IOException e) {
            logger.error("Error retrieving maven configuration",e);
        }
        return mavenConfiguration;
    }

    /**
     * Returns the bundles that match
     * @param url
     * @return
     */
    public List<Bundle> getBundlesByURL(String url) {
        List<Bundle> bundleList = new ArrayList<Bundle>();
        try {
            Long id = Long.parseLong(url);
            Bundle bundle = bundleContext.getBundle(id);
            if (bundle != null) {
                bundleList.add(bundle);
            }
        } catch (NumberFormatException e) {
            for (int i = 0; i < bundleContext.getBundles().length; i++) {
                Bundle bundle = bundleContext.getBundles()[i];
                if (isMavenSnapshotUrl(bundle.getLocation()) && wildCardMatch(bundle.getLocation(), url)) {
                    bundleList.add(bundle);
                }
            }
        }
        return bundleList;
    }

    protected boolean isMavenSnapshotUrl(String url) {
        return url.startsWith("mvn:") && url.contains("-SNAPSHOT");
    }

    /**
     * Matches text using a pattern containing wildcards.
     *
     * @param text
     * @param pattern
     * @return
     */
    protected boolean wildCardMatch(String text, String pattern) {
        String[] cards = pattern.split("\\*");
        // Iterate over the cards.
        for (String card : cards) {
            int idx = text.indexOf(card);
            // Card not detected in the text.
            if (idx == -1) {
                return false;
            }

            // Move ahead, towards the right of the text.
            text = text.substring(idx + card.length());
        }
        return true;
    }


    public void start() {
        if (running.compareAndSet(false, true)) {
            if (watchURLs.size()>0) {
                Thread thread = new Thread(this);
                thread.start();
            }
        }
    }

    /**
     * Stops the execution of the thread and releases the singleton instance
     */
    public void stop() {
        running.set(false);
    }

    public ConfigurationAdmin getConfigurationAdmin() {
        return configurationAdmin;
    }

    public void setConfigurationAdmin(ConfigurationAdmin configurationAdmin) {
        this.configurationAdmin = configurationAdmin;
    }

    public BundleContext getBundleContext() {
        return bundleContext;
    }

    public void setBundleContext(BundleContext bundleContext) {
        this.bundleContext = bundleContext;
    }

    public List<String> getWatchURLs() {
        return watchURLs;
    }

    public void setWatchURLs(List<String> watchURLs) {
        this.watchURLs = watchURLs;
    }

    public long getInterval() {
        return interval;
    }

    public void setInterval(long interval) {
        this.interval = interval;
    }

    public boolean isRunning() {
        return running.get();
    }

}
```


Overlapping Code:
```
r implements Runnable, BundleListener {
private final Logger logger = LoggerFactory.getLogger(BundleWatcher.class);
private BundleContext bundleContext;
private ConfigurationAdmin configurationAdmin;
private AtomicBoolean running = new AtomicBoolean(false);
private long interval = 1000L;
private List<String> watchURLs = new CopyOnWriteArrayList<String>();
private AtomicInteger counter = new AtomicInteger(0);
/**
* Construcotr
*/
public BundleWatcher() {
}
public void bundleChanged(BundleEvent event) {
if (event.getType() == BundleEvent.INSTALLED
|| event.getType() == BundleEvent.UNINSTALLED) {
counter.incrementAndGet();
}
}
public void run() {
if (logger.isDebugEnabled()) {
logger.debug("Bundle watcher thread started");
}
int oldCounter = -1;
Set<Bundle> watchedBundles = new HashSet<Bundle>();
while (running.get() && watchURLs.size()>0) {
if (oldCounter != counter.get()) {
oldCounter = counter.get();
watchedBundles.clear();
for (String bundleURL : watchURLs) {
for (Bundle bundle : getBundlesByURL(bundleURL)) {
watchedBundles.add(bundle);
}
}
}
if (watchedBundles.size()>0) {
File localRepository = getLocalRepository();
for (Bundle bundle : watchedBundles) {
try {
File location = getBundleExternalLocation(localRepository, bundle);
if (location != null
&& location.exists()
&& location.lastModified() > bundle.getLastModified())
{
InputStream is = new FileInputStream(location);
try {
System.out.println("[Watch] Updating watched bundle: " + bundle.getSymbolicName() + " (" + bundle.getVersion() + ")");
bundle.update(is);
} finally {
is.close();
}
}
} catch (IOException ex) {
logger.error("Error watching bundle.", ex);
} catch (BundleExcept
```
<Overlap Ratio: 0.9845788849347569>

---

--- 270 --
Question ID: 5f190015d0ca9e6efd9166c1747319a5edf26c51
Original Code:
```
public class StringArrayUtil {

    public static String[] listToArray(List<String> list) {
        String[] array = new String[list.size()];
        return list.toArray(array);
    }

    public static String[] listToArrayRemoveDuplicates(List<String> list) {
        if (list == null) {
            return new String[0];
        }
        LinkedHashSet<String> set = new LinkedHashSet<>(list);
        return listToArray(new ArrayList<>(set));
    }

    public static List<String> arrayToList(String[] array) {
        return array != null && array.length != 0 ? new ArrayList<>(Arrays.asList(array)) : new ArrayList<>();
    }

    public static String joinStringList(List<String> strings, String joinChar, Integer maxLength) {
        final String str = String.join(joinChar == null ? ", " : joinChar, strings);
        return maxLength == null ? str : str.substring(maxLength);
    }

    public static boolean isAllEmptyOrNull(List<String> strings) {
        return strings == null || strings.isEmpty() || strings.stream().allMatch(StringUtils::isEmpty);
    }
}
```


Overlapping Code:
```
blic class StringArrayUtil {
public static String[] listToArray(List<String> list) {
String[] array = new String[list.size()];
return list.toArray(array);
}
public static String[] listToArrayRemoveDuplicates(List<String> list) {
if (list == null) {
return new String[0];
}
LinkedHashSet<String> set = new LinkedHashSet<>(list);
return listToArray(new ArrayList<>(set));
}
public static List<String> arrayToList(String[] array) {
return array != null && array.length != 0 ? new ArrayList<>(Arrays.asList(array)) : new ArrayList<>();
}
public static String joinStringList(List<String> strings, String joinChar, Integer maxLength) {
final String str = String.join(joinChar == null ? ", " : joinChar, strings);
return maxLength == null ? str : str.substring(maxLength);
}
public static boolean isAllEmptyOrNull(List<String> strings) {
return strings == null || strings.isEmpty() || strings.stream().allMatch(StringUtils::isEmpty);
}
```
<Overlap Ratio: 0.9957081545064378>

---

--- 271 --
Question ID: a9e146d2675401c8dbf33442ed126d7eedb0ae9c
Original Code:
```
public class MyGson {
    MyGson() {

    }

    String toJson(Object AnyObject) throws IllegalAccessException {
        Class<AnyObject> classString = AnyObject.class;

        Field[] fields = classString.getDeclaredFields();
        StringBuilder jsonString = new StringBuilder();
        if (fields.length != 0) {
            jsonString.append("{\"");
        } else {
            jsonString.append("{");
        }

        for (int i = 0; i < fields.length; i++) {
            if (fields[i].get(AnyObject) != null) {
                if (i != 0) {
                    jsonString.append(",\"");
                }
                jsonString.append(fields[i].getName() + "\":");
                if (fields[i].getType().isArray()) {
                    jsonString.append("[");
                }

                ToMyGsonStringInterface config = ConfigurationFactory.getConfiguration(fields[i].getType().toString());
                jsonString.append(config.ToMyGsonString(fields[i].get(AnyObject)));

                if (fields[i].getType().isArray()) {
                    jsonString.append("]");
                }
            }
        }
        jsonString.append("}");
        return jsonString.toString();
    }
}
```


Overlapping Code:
```
 MyGson {
MyGson() {
}
String toJson(Object AnyObject) throws IllegalAccessException {
Class<AnyObject> classString = AnyObject.class;
Field[] fields = classString.getDeclaredFields();
StringBuilder jsonString = new StringBuilder();
if (fields.length != 0) {
jsonString.append("{\"");
} else {
jsonString.append("{");
}
for (int i = 0; i < fields.length; i++) {
if (fields[i].get(AnyObject) != null) {
if (i != 0) {
jsonString.append(",\"");
}
jsonString.append(fields[i].getName() + "\":");
if (fields[i].getType().isArray()) {
jsonString.append("[");
}
ToMyGsonStringInterface config = ConfigurationFactory.getConfiguration(fields[i].getType().toString());
jsonString.append(config.ToMyGsonString(fields[i].get(AnyObject)));
if (fields[i].getType().isArray()) {
jsonString.append("]");
}
}
}
jsonString.append("}");
return jsonString.toString();
}

```
<Overlap Ratio: 0.984936268829664>

---

--- 272 --
Question ID: ccc147858c14857014520f932a19b0fb954d531f
Original Code:
```
public class BubbleSort extends SortStub {

  @Override
  public void onDoSort(int[] inputData) {
    super.onDoSort(inputData);

    int len = inputData != null ? inputData.length : -1;
    if (len > -1) {
      for (int i = 0; i < len; i++) {
        for (int j = len - 1; j > i; j--) {
          if (inputData[j] < inputData[j - 1]) {
            _exchange(inputData, j, j - 1);
          }
        }
      }
    }
  }

  private void _exchange(int[] array, int sourceIndex, int targetIndex) {
    int len = array != null ? array.length : -1;

    if (sourceIndex < 0 || targetIndex < 0 || sourceIndex >= len || targetIndex >= len) return;

    int temp = array[targetIndex];
    array[targetIndex] = array[sourceIndex];
    array[sourceIndex] = temp;
  }
}
```


Overlapping Code:
```
 {
@Override
public void onDoSort(int[] inputData) {
super.onDoSort(inputData);
int len = inputData != null ? inputData.length : -1;
if (len > -1) {
for (int i = 0; i < len; i++) {
for (int j = len - 1; j > i; j--) {
if (inputData[j] < inputData[j - 1]) {
_exchange(inputData, j, j - 1);
}
}
}
}
}
private void _exchange(int[] array, int sourceIndex, int targetIndex) {
int len = array != null ? array.length : -1;
if (sourceIndex < 0 || targetIndex < 0 || sourceIndex >= len || targetIndex >= len) return;
int temp = array[targetIndex];
array[targetIndex] = array[sourceIndex];
array[sourceIndex] = 
```
<Overlap Ratio: 0.9244992295839753>

---

--- 273 --
Question ID: 039e5289f5325e47f3f7e0acce78e60e0c47e626
Original Code:
```
public class ExecutionTest {

    @Test
    public void main() throws IOException {

        ShaclSail shaclSail = new ShaclSail(new MemoryStore());
        SailRepository sailRepository = new SailRepository(shaclSail);
        sailRepository.init();

        try (SailRepositoryConnection connection = sailRepository.getConnection()) {
            connection.begin();
            StringReader shaclRules = new StringReader(
                    String.join("\n", "",
                            "@prefix ex: <http://example.com/ns#> .",
                            "@prefix sh: <http://www.w3.org/ns/shacl#> .",
                            "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .",
                            "@prefix foaf: <http://xmlns.com/foaf/0.1/>.",

                            "ex:PersonShape",
                            "  a sh:NodeShape  ;",
                            "  sh:targetClass foaf:Person ;",
                            "  sh:property ex:PersonShapeProperty .",

                            "ex:PersonShapeProperty ",
                            "  sh:path foaf:age ;",
                            "  sh:datatype xsd:int ;",
                            "  sh:maxCount 1 ;",
                            "  sh:minCount 1 ."
                    ));

            connection.add(shaclRules, "", RDFFormat.TURTLE, RDF4J.SHACL_SHAPE_GRAPH);
            connection.commit();
        }

        try (SailRepositoryConnection connection = sailRepository.getConnection()) {
            connection.begin();

            StringReader invalidSampleData = new StringReader(
                    String.join("\n", "",
                            "@prefix ex: <http://example.com/ns#> .",
                            "@prefix foaf: <http://xmlns.com/foaf/0.1/>.",
                            "@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .",

                            "ex:peter a foaf:Person ;",
                            "  foaf:age 20, \"30\"^^xsd:int  ."

                    ));

            connection.add(invalidSampleData, "", RDFFormat.TURTLE);
            try {
                connection.commit();
            } catch (RepositoryException exception) {
                Throwable cause = exception.getCause();
                if (cause instanceof ShaclSailValidationException) {
                    ValidationReport validationReport = ((ShaclSailValidationException) cause).getValidationReport();
                    Model validationReportModel = ((ShaclSailValidationException) cause).validationReportAsModel();
                    return;
                }
                throw exception;
            }
        }
    }

}
```


Overlapping Code:
```
Test {
@Test
public void main() throws IOException {
ShaclSail shaclSail = new ShaclSail(new MemoryStore());
SailRepository sailRepository = new SailRepository(shaclSail);
sailRepository.init();
try (SailRepositoryConnection connection = sailRepository.getConnection()) {
connection.begin();
StringReader shaclRules = new StringReader(
String.join("\n", "",
"@prefix ex: <http://example.com/ns#> .",
"@prefix sh: <http://www.w3.org/ns/shacl#> .",
"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .",
"@prefix foaf: <http://xmlns.com/foaf/0.1/>.",
"ex:PersonShape",
" a sh:NodeShape ;",
" sh:targetClass foaf:Person ;",
" sh:property ex:PersonShapeProperty .",
"ex:PersonShapeProperty ",
" sh:path foaf:age ;",
" sh:datatype xsd:int ;",
" sh:maxCount 1 ;",
" sh:minCount 1 ."
));
connection.add(shaclRules, "", RDFFormat.TURTLE, RDF4J.SHACL_SHAPE_GRAPH);
connection.commit();
}
try (SailRepositoryConnection connection = sailRepository.getConnection()) {
connection.begin();
StringReader invalidSampleData = new StringReader(
String.join("\n", "",
"@prefix ex: <http://example.com/ns#> .",
"@prefix foaf: <http://xmlns.com/foaf/0.1/>.",
"@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .",
"ex:peter a foaf:Person ;",
" foaf:age 20, \"30\"^^xsd:int ."
));
connection.add(invalidSampleData, "", RDFFormat.TURTLE);
try {
connection.commit();
} catch (RepositoryException exception) {
Throwable cause = exception.getCause();
if (cause instanceof ShaclSailValidationException) {
ValidationReport validationReport = ((ShaclSailValidationException) cause).getValidationReport();
Model validationReportModel = ((ShaclSailValid
```
<Overlap Ratio: 0.9866017052375152>

---

--- 274 --
Question ID: f402f49e782ddcd0e031b882aeb7f1c9aa6a177a
Original Code:
```
public final class removal_modules_math extends SubLTranslatedFile implements V10 {
    public static final SubLFile me = new removal_modules_math();

    public static final String myName = "com.cyc.cycjava_2.cycl.inference.modules.removal.removal_modules_math";


    // defparameter
    public static final SubLSymbol $default_math_module_cost$ = makeSymbol("*DEFAULT-MATH-MODULE-COST*");

    private static final SubLObject $$interpolationWithCubicSpline = reader_make_constant_shell(makeString("interpolationWithCubicSpline"));



    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE = makeKeyword("REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE");

    private static final SubLList $list3 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("interpolationWithCubicSpline")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("interpolationWithCubicSpline")), makeKeyword("FULLY-BOUND"), list(makeKeyword("OR"), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("NOT-FULLY-BOUND"), makeKeyword("FULLY-BOUND")), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")))), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$interpolationWithCubicSpline <set-of-points> <2d-point-with-x-or-y-bound>)"), makeKeyword("EXAMPLE"), makeString("(#$interpolationWithCubicSpline \n    (#$TheSet \n     (#$The2DPoint \n      (#$Meter 440.1) \n      (#$DegreeCelsius 160.3)) \n     (#$The2DPoint \n      (#$Meter 441.1) \n      (#$DegreeCelsius 161.4)) \n     (#$The2DPoint \n      (#$Meter 442.3) \n      (#$DegreeCelsius 163.6)) \n     (#$The2DPoint \n      (#$Meter 443.6) \n      (#$DegreeCelsius 165.5)) \n     (#$The2DPoint \n      (#$Meter 444.9) \n      (#$DegreeCelsius 166.4)) \n     (#$The2DPoint \n      (#$Meter 445.8) \n      (#$DegreeCelsius 166.3)) \n     (#$The2DPoint \n      (#$Meter 446.7) \n      (#$DegreeCelsius 165.4)) \n     (#$The2DPoint \n      (#$Meter 447.9) \n      (#$DegreeCelsius 167.8))) \n    (#$The2DPoint \n     (#$Meter 445.0) \n     (#$DegreeCelsius ?VALUE)))") });

    private static final SubLSymbol JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X = makeSymbol("JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X");

    private static final SubLObject $const5$interpolationWithPiecewiseLinearP = reader_make_constant_shell(makeString("interpolationWithPiecewiseLinearPolynomial"));

    private static final SubLSymbol $REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL = makeKeyword("REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL");

    private static final SubLList $list7 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("interpolationWithPiecewiseLinearPolynomial")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("interpolationWithPiecewiseLinearPolynomial")), makeKeyword("FULLY-BOUND"), list(makeKeyword("OR"), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("NOT-FULLY-BOUND"), makeKeyword("FULLY-BOUND")), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")))), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$interpolationWithPiecewiseLinearPolynomial <set-of-points> <2d-point-with-x-or-y-bound>)"), makeKeyword("EXAMPLE"), makeString("(#$interpolationWithPiecewiseLinearPolynomial \n    (#$TheSet \n     (#$The2DPoint \n      (#$Meter 440.1) \n      (#$DegreeCelsius 160.3)) \n     (#$The2DPoint \n      (#$Meter 441.1) \n      (#$DegreeCelsius 161.4)) \n     (#$The2DPoint \n      (#$Meter 442.3) \n      (#$DegreeCelsius 163.6)) \n     (#$The2DPoint \n      (#$Meter 443.6) \n      (#$DegreeCelsius 165.5)) \n     (#$The2DPoint \n      (#$Meter 444.9) \n      (#$DegreeCelsius 166.4)) \n     (#$The2DPoint \n      (#$Meter 445.8) \n      (#$DegreeCelsius 166.3)) \n     (#$The2DPoint \n      (#$Meter 446.7) \n      (#$DegreeCelsius 165.4)) \n     (#$The2DPoint \n      (#$Meter 447.9) \n      (#$DegreeCelsius 167.8))) \n    (#$The2DPoint \n     (#$Meter 445.0) \n     (#$DegreeCelsius ?VALUE)))") });

    private static final SubLSymbol JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X = makeSymbol("JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X");

    private static final SubLObject $const9$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegression"));

    private static final SubLSymbol $REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION = makeKeyword("REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION");

    private static final SubLList $list11 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegression")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegression")), makeKeyword("FULLY-BOUND"), list(makeKeyword("OR"), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("NOT-FULLY-BOUND"), makeKeyword("FULLY-BOUND")), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")))), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$extrapolationWithSimpleLinearRegression <set-of-points> <2d-point-with-x-or-y-bound>)"), makeKeyword("EXAMPLE"), makeString("(#$extrapolationWithSimpleLinearRegression \n    (#$TheSet \n     (#$The2DPoint \n      (#$DaysDuration 1) \n      (#$DegreeCelsius 160.3)) \n     (#$The2DPoint \n      (#$DaysDuration 2) \n      (#$DegreeCelsius 161.4)) \n     (#$The2DPoint \n      (#$DaysDuration 3) \n      (#$DegreeCelsius 163.6)) \n     (#$The2DPoint \n      (#$DaysDuration 4) \n      (#$DegreeCelsius 165.5)) \n     (#$The2DPoint \n      (#$DaysDuration 5) \n      (#$DegreeCelsius 166.4)) \n     (#$The2DPoint \n      (#$DaysDuration 6) \n      (#$DegreeCelsius 166.3)) \n     (#$The2DPoint \n      (#$DaysDuration 7) \n      (#$DegreeCelsius 165.4)) \n     (#$The2DPoint \n      (#$DaysDuration 8) \n      (#$DegreeCelsius 167.8))) \n    (#$The2DPoint \n     (#$DaysDuration ?VALUE) \n     (#$DegreeCelsius 200)))") });

    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X = makeSymbol("JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X");

    private static final SubLSymbol EL_2D_POINT_P = makeSymbol("EL-2D-POINT-P");

    private static final SubLList $list14 = list(makeSymbol("THE-2D-POINT"), makeSymbol("QUERY-X-VALUE-WITH-UNITS"), makeSymbol("QUERY-Y-VALUE-WITH-UNITS"));





    private static final SubLObject $const17$extrapolationWithSimpleLinearRegr = reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegressionWithErrorBars"));

    private static final SubLSymbol $kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA = makeKeyword("REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS");

    private static final SubLList $list19 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegressionWithErrorBars")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("extrapolationWithSimpleLinearRegressionWithErrorBars")), makeKeyword("FULLY-BOUND"), list(makeKeyword("OR"), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("NOT-FULLY-BOUND"), makeKeyword("FULLY-BOUND")), list(reader_make_constant_shell(makeString("The2DPoint")), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND"))), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$extrapolationWithSimpleLinearRegressionWithErrorBars <set-of-points> <2d-point-with-x-or-y-bound> <error-term-unbound>)"), makeKeyword("EXAMPLE"), makeString("(#$extrapolationWithSimpleLinearRegressionWithErrorBars\n    (#$TheSet \n     (#$The2DPoint \n      (#$DaysDuration 1) \n      (#$DegreeCelsius 160.3)) \n     (#$The2DPoint \n      (#$DaysDuration 2) \n      (#$DegreeCelsius 161.4)) \n     (#$The2DPoint \n      (#$DaysDuration 3) \n      (#$DegreeCelsius 163.6)) \n     (#$The2DPoint \n      (#$DaysDuration 4) \n      (#$DegreeCelsius 165.5)) \n     (#$The2DPoint \n      (#$DaysDuration 5) \n      (#$DegreeCelsius 166.4)) \n     (#$The2DPoint \n      (#$DaysDuration 6) \n      (#$DegreeCelsius 166.3)) \n     (#$The2DPoint \n      (#$DaysDuration 7) \n      (#$DegreeCelsius 165.4)) \n     (#$The2DPoint \n      (#$DaysDuration 8) \n      (#$DegreeCelsius 167.8))) \n    (#$The2DPoint \n     (#$DaysDuration ?VALUE) \n     (#$DegreeCelsius 200))\n    ?ERROR)") });

    private static final SubLSymbol JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS = makeSymbol("JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS");

    private static final SubLObject $const21$regressionLinesForSetsIntersectAt = reader_make_constant_shell(makeString("regressionLinesForSetsIntersectAtPoint"));

    private static final SubLSymbol $REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT = makeKeyword("REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT");

    private static final SubLList $list23 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("regressionLinesForSetsIntersectAtPoint")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("regressionLinesForSetsIntersectAtPoint")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$regressionLinesForSetsIntersectAtPoint <set-of-points> <set-of-points> ?POINT)"), makeKeyword("EXAMPLE"), makeString("(#$regressionLinesForSetsIntersectAtPoint\n     (#$TheSet\n      (#$The2DPoint\n       (#$DegreeCelsius 200)\n       (#$SecondsDuration 1263118210))\n      (#$The2DPoint\n       (#$DegreeCelsius 210)\n       (#$SecondsDuration 1263204610))\n      (#$The2DPoint\n       (#$DegreeCelsius 220)\n       (#$SecondsDuration 1263291010)))\n     (TheSet\n      (#$The2DPoint\n       (#$DegreeCelsius 211)\n       (#$SecondsDuration 1263081600))\n      (#$The2DPoint\n       (#$DegreeCelsius 212)\n       (#$SecondsDuration 1263168000))\n      (#$The2DPoint\n       (#$DegreeCelsius 213)\n       (#$SecondsDuration 1263254400)))\n     ?POINT)") });

    private static final SubLObject $$The2DPoint = reader_make_constant_shell(makeString("The2DPoint"));

    private static final SubLObject $const25$slopeOfRegressionLineForSetOfPoin = reader_make_constant_shell(makeString("slopeOfRegressionLineForSetOfPoints"));

    private static final SubLSymbol $REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS = makeKeyword("REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS");

    private static final SubLList $list27 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("slopeOfRegressionLineForSetOfPoints")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("slopeOfRegressionLineForSetOfPoints")), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$slopeOfRegressionLineForSetOfPoints <set-of-points> ?SLOPE)"), makeKeyword("EXAMPLE"), makeString("(#$slopeOfRegressionLineForSetOfPoints\n     (#$TheSet\n      (#$The2DPoint\n       (#$DegreeCelsius 211)\n       (#$SecondsDuration 1263081600))\n      (#$The2DPoint\n       (#$DegreeCelsius 212)\n       (#$SecondsDuration 1263168000))\n      (#$The2DPoint\n       (#$DegreeCelsius 213)\n       (#$SecondsDuration 1263254400))) ?X)") });

    private static final SubLObject $const28$setOfFirstDerivativePointsBasedOn = reader_make_constant_shell(makeString("setOfFirstDerivativePointsBasedOnSetOfPoints"));

    private static final SubLSymbol $REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS = makeKeyword("REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS");

    private static final SubLList $list30 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("setOfFirstDerivativePointsBasedOnSetOfPoints")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("setOfFirstDerivativePointsBasedOnSetOfPoints")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$setOfFirstDerivativePointsBasedOnSetOfPoints <set-of-points> ?SET-OF-POINTS)"), makeKeyword("EXAMPLE"), makeString("(#$setOfFirstDerivativePointsBasedOnSetOfPoints\n    (#$TheSet\n     (#$The2DPoint (#$SecondsDuration 1) (#$DegreeCelsius 1))\n     (#$The2DPoint (#$SecondsDuration 3) (#$DegreeCelsius 5))\n     (#$The2DPoint (#$SecondsDuration 5) (#$DegreeCelsius 1)))\n    #$CubicSpline\n    ?X)\n    -->\n    (#$TheSet \n     (#$The2DPoint (#$SecondsDuration 1) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 6.0))\n     (#$The2DPoint (#$SecondsDuration 3) ((#$PerFn #$DegreeCelsius #$SecondsDuration) 0.0))\n     (#$The2DPoint (#$SecondsDuration 5) ((#$PerFn #$DegreeCelsius #$SecondsDuration) -6.0)))") });

    private static final SubLObject $const31$setHasPointsWithYValueRelnToMatch = reader_make_constant_shell(makeString("setHasPointsWithYValueRelnToMatchingXValuePointsInSet"));

    private static final SubLSymbol $kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN = makeKeyword("REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET");

    private static final SubLList $list33 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("setHasPointsWithYValueRelnToMatchingXValuePointsInSet")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("setHasPointsWithYValueRelnToMatchingXValuePointsInSet")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet <set-of-points> <set-of-points> <binary-function> <binary-predicate> <value-in-y-units> ?RESULT-SET-OF-POINTS)"), makeKeyword("EXAMPLE"), makeString("(#$setHasPointsWithYValueRelnToMatchingXValuePointsInSet \n    (#$TheSet \n      (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \n      (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \n      (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)) \n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170))) \n    (#$TheSet \n      (#$The2DPoint (#$Meter 702) (#$Kelvin 175)) \n      (#$The2DPoint (#$Meter 703) (#$Kelvin 175)) \n      (#$The2DPoint (#$Meter 704) (#$Kelvin 175)) \n      (#$The2DPoint (#$Meter 705) (#$Kelvin 170)))\n    #$DifferenceFn\n    #$greaterThanOrEqualTo \n    (#$Kelvin 2)\n    ?NEWSET)\n    -->\n    (((?NEWSET #$TheSet (#$The2DPoint (#$Meter 702) (#$Kelvin 177.5)) \n                        (#$The2DPoint (#$Meter 703) (#$Kelvin 177.5)) \n                        (#$The2DPoint (#$Meter 704) (#$Kelvin 177.5)))))") });



    private static final SubLString $str35$org_apache_commons_math_stat_regr = makeString("org.apache.commons.math.stat.regression.SimpleRegression");

    private static final SubLString $$$addData = makeString("addData");

    private static final SubLString $$$double = makeString("double");

    private static final SubLString $$$getSlope = makeString("getSlope");

    private static final SubLString $$$getIntercept = makeString("getIntercept");





    private static final SubLString $str42$org_apache_commons_math_analysis_ = makeString("org.apache.commons.math.analysis.interpolation.SplineInterpolator");

    private static final SubLString $$$interpolate = makeString("interpolate");

    private static final SubLString $str44$_D = makeString("[D");

    private static final SubLString $str45$org_apache_commons_math_analysis_ = makeString("org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction");

    private static final SubLString $$$value = makeString("value");

    private static final SubLSymbol $sym47$_ = makeSymbol("<");



    private static final SubLString $str49$org_apache_commons_math_analysis_ = makeString("org.apache.commons.math.analysis.interpolation.LinearInterpolator");

    private static final SubLString $$$predict = makeString("predict");

    private static final SubLString $$$getSumSquaredErrors = makeString("getSumSquaredErrors");

    private static final SubLString $str52$org_apache_commons_math_geometry_ = makeString("org.apache.commons.math.geometry.euclidean.twod.Line");

    private static final SubLString $str53$org_apache_commons_math_geometry_ = makeString("org.apache.commons.math.geometry.euclidean.twod.Vector2D");

    private static final SubLString $$$intersection = makeString("intersection");

    private static final SubLString $str55$org_apache_commons_math_geometry_ = makeString("org.apache.commons.math.geometry.partitioning.Hyperplane");

    private static final SubLString $$$getX = makeString("getX");

    private static final SubLString $$$getY = makeString("getY");

    private static final SubLObject $$CubicSpline = reader_make_constant_shell(makeString("CubicSpline"));

    private static final SubLObject $const59$LinearPolynomialFunction_Piecewis = reader_make_constant_shell(makeString("LinearPolynomialFunction-Piecewise"));

    private static final SubLString $$$derivative = makeString("derivative");



    private static final SubLObject $$setHasPointsWithYValueRelnTo = reader_make_constant_shell(makeString("setHasPointsWithYValueRelnTo"));

    private static final SubLSymbol $REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO = makeKeyword("REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO");

    private static final SubLList $list64 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("setHasPointsWithYValueRelnTo")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("setHasPointsWithYValueRelnTo")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$setHasPointsWithYValueRelnTo <set-of-points> <operator> <comparator> <quant1> <quant2> ?NEWSET)"), makeKeyword("EXAMPLE"), makeString("(#$setHasPointsWithYValueRelnTo \n (#$TheSet \n  (#$The2DPoint \n   (#$Meter 20.0) \n   (#$DegreeCelsius 68.35)) \n  (#$The2DPoint \n   (#$Meter 21.0) \n   (#$DegreeCelsius 72.98)) \n  (#$The2DPoint \n   (#$Meter 22.0) \n   (#$DegreeCelsius 75.68)) \n  (#$The2DPoint \n   (#$Meter 23.0) \n   (#$DegreeCelsius 78.16)) \n  (#$The2DPoint \n   (#$Meter 24.0) \n   (#$DegreeCelsius 80.79)))\n #$PlusFn\n #$lessThanOrEqualTo \n (#$DegreeCelsius 0) \n (#$DegreeCelsius 70) ?NEWSET)\n -->\n (((?NEWSET TheSet\n   (The2DPoint\n       (Meter 20.0)\n       (DegreeCelsius 68.35)))))") });

    private static final SubLObject $$operationResultComparison = reader_make_constant_shell(makeString("operationResultComparison"));



    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK = makeKeyword("REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK");

    private static final SubLList $list68 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("operationResultComparison")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("operationResultComparison")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK"), makeKeyword("DOCUMENTATION"), makeString("(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)"), makeKeyword("EXAMPLE"), makeString("(#$operationResultComparison #$PlusFn (#$DegreeCelsius 50) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\n   --> True") });

    private static final SubLSymbol $REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK = makeKeyword("REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK");

    private static final SubLList $list70 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("NEG"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("operationResultComparison")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("operationResultComparison")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK"), makeKeyword("DOCUMENTATION"), makeString("(#$operationResultComparison <OP> <A> <B> <COMP> <QUANT>)"), makeKeyword("EXAMPLE"), makeString("(#$not (#$operationResultComparison #$PlusFn (#$DegreeCelsius 100) (#$DegreeCelsius 0) #$lessThanOrEqualTo (#$DegreeCelsius 70))\n   --> True") });

    private static final SubLObject $$inflowLengthsWithStartingDepths = reader_make_constant_shell(makeString("inflowLengthsWithStartingDepths"));

    private static final SubLSymbol $REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS = makeKeyword("REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS");

    private static final SubLList $list73 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("inflowLengthsWithStartingDepths")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("inflowLengthsWithStartingDepths")), makeKeyword("FULLY-BOUND"), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOUND")), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$inflowLengthsWithStartingDepths <well> <set-of-points> ?LENGTH-AND-DEPTHS)"), makeKeyword("EXAMPLE"), makeString("(#$inflowLengthsWithStartingDepths\n  (#$The #$Well)\n  (#$TheSet \n   (#$The2DPoint (#$Meter 100) (#$DegreeCelsius  95))\n   (#$The2DPoint (#$Meter 110) (#$DegreeCelsius 110))\n   (#$The2DPoint (#$Meter 120) (#$DegreeCelsius 115))\n   (#$The2DPoint (#$Meter 130) (#$DegreeCelsius 114))\n   (#$The2DPoint (#$Meter 140) (#$DegreeCelsius 103))\n   (#$The2DPoint (#$Meter 150) (#$DegreeCelsius  95))\n   (#$The2DPoint (#$Meter 160) (#$DegreeCelsius 100))\n   (#$The2DPoint (#$Meter 170) (#$DegreeCelsius 102))\n   (#$The2DPoint (#$Meter 180) (#$DegreeCelsius 102))\n   (#$The2DPoint (#$Meter 190) (#$DegreeCelsius  91))\n   (#$The2DPoint (#$Meter 200) (#$DegreeCelsius 100))\n   (#$The2DPoint (#$Meter 210) (#$DegreeCelsius 110))\n   (#$The2DPoint (#$Meter 220) (#$DegreeCelsius 105))\n   (#$The2DPoint (#$Meter 230) (#$DegreeCelsius  97))\n   (#$The2DPoint (#$Meter 240) (#$DegreeCelsius  96))\n   (#$The2DPoint (#$Meter 250) (#$DegreeCelsius  95))\n   (#$The2DPoint (#$Meter 260) (#$DegreeCelsius  94))\n   (#$The2DPoint (#$Meter 270) (#$DegreeCelsius  93))\n   (#$The2DPoint (#$Meter 280) (#$DegreeCelsius  92)))\n  ?LENGTH-AND-DEPTHS)") });

    private static final SubLObject $$Meter = reader_make_constant_shell(makeString("Meter"));

    private static final SubLObject $$DegreeCelsius = reader_make_constant_shell(makeString("DegreeCelsius"));

    private static final SubLString $str76$____ = makeString("~%~%");

    private static final SubLList $list77 = list(makeSymbol("X-VALUE"), makeSymbol("Y-VALUE"));

    private static final SubLString $str78$High_value__x__A_y__A__ = makeString("High value: x=~A y=~A~%");

    private static final SubLList $list79 = list(makeSymbol("CUR-X-VALUE"), makeSymbol("CUR-Y-DERIVATIVE-VALUE"));

    private static final SubLString $str80$checking_x__A_deriv__A__ = makeString("checking x=~A deriv=~A~%");

    private static final SubLString $$$Bad_looping = makeString("Bad looping");

    private static final SubLFloat $float$0_5 = makeDouble(0.5);

    private static final SubLFloat $float$_0_5 = makeDouble(-0.5);

    private static final SubLString $str84$Got_interval___A__A___ = makeString("Got interval (~A ~A)~%");

    private static final SubLSymbol $sym85$_ = makeSymbol(">");

    private static final SubLString $str86$inflow_lengths___A__ = makeString("inflow-lengths: ~A~%");

    private static final SubLList $list87 = list(makeSymbol("START"), makeSymbol("END"));

    private static final SubLString $str88$merged_inflow_lengths___A__ = makeString("merged-inflow-lengths: ~A~%");

    private static final SubLObject $$TheList = reader_make_constant_shell(makeString("TheList"));

    public static SubLObject removal_interpolation_with_cubic_spline_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_CUBIC_SPLINE_FIND_Y_FOR_X);
    }

    public static SubLObject removal_interpolation_with_piecewise_linear_polynomial_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_PIECEWISE_LINEAR_FIND_Y_FOR_X);
    }

    public static SubLObject removal_extrapolation_with_simple_linear_regression_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        return removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X);
    }

    public static SubLObject removal_interpolation_or_extrapolation_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        if (NIL != el_extensional_set_p(set_of_points_in_units)) {
            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);
            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {
                thread.resetMultipleValues();
                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {
                    SubLObject current;
                    final SubLObject datum = current = query_point;
                    SubLObject the_2d_point = NIL;
                    SubLObject query_x_value_with_units = NIL;
                    SubLObject query_y_value_with_units = NIL;
                    destructuring_bind_must_consp(current, datum, $list14);
                    the_2d_point = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list14);
                    query_x_value_with_units = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list14);
                    query_y_value_with_units = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {
                            thread.resetMultipleValues();
                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);
                            final SubLObject query_x_value = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);
                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);
                            if (NIL != answer_y_value) {
                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);
                                final SubLObject v_bindings = quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units);
                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                            }
                        } else {
                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);
                            thread.resetMultipleValues();
                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);
                            final SubLObject query_y_value = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);
                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);
                            if (NIL != answer_x_value) {
                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);
                                final SubLObject v_bindings2 = quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units);
                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);
                            }
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list14);
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_extrapolation_with_simple_linear_regression_with_error_bars_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        return removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(asent, JAVA_LINK_X_Y_REGRESSION_FIND_Y_FOR_X_WITH_ERROR_BARS);
    }

    public static SubLObject removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper(final SubLObject asent, final SubLObject java_link_function) {
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject query_point = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject query_error_with_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        if (NIL != el_extensional_set_p(set_of_points_in_units)) {
            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);
            if ((NIL != v_2d_points) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED))) {
                thread.resetMultipleValues();
                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                if (((NIL != x_y_values) && (NIL != x_units)) && (NIL != y_units)) {
                    SubLObject current;
                    final SubLObject datum = current = query_point;
                    SubLObject the_2d_point = NIL;
                    SubLObject query_x_value_with_units = NIL;
                    SubLObject query_y_value_with_units = NIL;
                    destructuring_bind_must_consp(current, datum, $list14);
                    the_2d_point = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list14);
                    query_x_value_with_units = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list14);
                    query_y_value_with_units = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        if (NIL != variables.not_fully_bound_p(query_y_value_with_units)) {
                            thread.resetMultipleValues();
                            final SubLObject query_x_units = quantities.explode_interval(query_x_value_with_units);
                            final SubLObject query_x_value = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            final SubLObject normalized_query_x_value = quantities.convert_to_units_absolute(x_units, query_x_units, query_x_value, UNPROVIDED);
                            thread.resetMultipleValues();
                            final SubLObject answer_y_value = funcall(java_link_function, x_y_values, normalized_query_x_value);
                            final SubLObject answer_y_error = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            if ((NIL != answer_y_value) && (NIL != answer_y_error)) {
                                final SubLObject answer_y_value_with_units = quantities.make_interval(y_units, answer_y_value, UNPROVIDED);
                                final SubLObject answer_y_error_with_units = quantities.make_interval(y_units, answer_y_error, UNPROVIDED);
                                final SubLObject v_bindings = append(quantities.term_unify_with_units(query_y_value_with_units, answer_y_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_y_error_with_units));
                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                            }
                        } else {
                            final SubLObject y_x_values = Mapping.mapcar(NREVERSE, x_y_values);
                            thread.resetMultipleValues();
                            final SubLObject query_y_units = quantities.explode_interval(query_y_value_with_units);
                            final SubLObject query_y_value = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            final SubLObject normalized_query_y_value = quantities.convert_to_units_absolute(y_units, query_y_units, query_y_value, UNPROVIDED);
                            thread.resetMultipleValues();
                            final SubLObject answer_x_value = funcall(java_link_function, y_x_values, normalized_query_y_value);
                            final SubLObject answer_x_error = thread.secondMultipleValue();
                            thread.resetMultipleValues();
                            if ((NIL != answer_x_value) && (NIL != answer_x_error)) {
                                final SubLObject answer_x_value_with_units = quantities.make_interval(x_units, answer_x_value, UNPROVIDED);
                                final SubLObject answer_x_error_with_units = quantities.make_interval(x_units, answer_x_error, UNPROVIDED);
                                final SubLObject v_bindings2 = append(quantities.term_unify_with_units(query_x_value_with_units, answer_x_value_with_units), quantities.term_unify_with_units(query_error_with_units, answer_x_error_with_units));
                                backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);
                            }
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list14);
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_regression_lines_for_sets_intersect_at_point_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_in_units_1 = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject set_of_points_in_units_2 = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject query_point = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        if ((NIL != el_extensional_set_p(set_of_points_in_units_1)) && (NIL != el_extensional_set_p(set_of_points_in_units_2))) {
            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_in_units_1);
            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_in_units_2);
            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {
                thread.resetMultipleValues();
                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);
                thread.resetMultipleValues();
                final SubLObject x = java_link_point_intersection_of_two_x_y_regressions(x_y_values_1, x_y_values_2);
                final SubLObject y = thread.secondMultipleValue();
                thread.resetMultipleValues();
                if (x.isNumber() && y.isNumber()) {
                    if (NIL != variables.variable_p(query_point)) {
                        final SubLObject x_y_point_with_units = list($$The2DPoint, quantities.make_interval(x_units, x, UNPROVIDED), quantities.make_interval(y_units, y, UNPROVIDED));
                        final SubLObject v_bindings = quantities.term_unify_with_units(query_point, x_y_point_with_units);
                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                    } else {
                        final SubLObject v_bindings2 = append(quantities.term_unify_with_units(second(query_point), quantities.make_interval(x_units, x, UNPROVIDED)), quantities.term_unify_with_units(third(query_point), quantities.make_interval(y_units, y, UNPROVIDED)));
                        backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings2, asent), UNPROVIDED, UNPROVIDED), v_bindings2, UNPROVIDED);
                    }
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_slope_of_regression_line_for_set_of_points_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject query_slope = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        if ((NIL != el_extensional_set_p(set_of_points_in_units)) && ONE_INTEGER.numL(el_set_size(set_of_points_in_units))) {
            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);
            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {
                thread.resetMultipleValues();
                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                final SubLObject slope = java_link_slope_and_intercept_of_x_y_regression(x_y_values);
                final SubLObject bindings_1 = quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(y_units, x_units), slope, UNPROVIDED));
                final SubLObject bindings_2 = (NIL != czer_utilities.equals_elP(x_units, y_units, UNPROVIDED, UNPROVIDED, UNPROVIDED)) ? NIL : quantities.term_unify_with_units(query_slope, quantities.make_interval(quantities.unit_quotient(x_units, y_units), divide(ONE_INTEGER, slope), UNPROVIDED));
                if (NIL != bindings_1) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_1, asent), UNPROVIDED, UNPROVIDED), bindings_1, UNPROVIDED);
                }
                if (NIL != bindings_2) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(bindings_2, asent), UNPROVIDED, UNPROVIDED), bindings_2, UNPROVIDED);
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_set_of_first_derivative_points_based_on_set_of_points_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject function_type = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject set_of_derivative_points_in_units = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        if (NIL != el_extensional_set_p(set_of_points_in_units)) {
            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);
            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {
                thread.resetMultipleValues();
                final SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);
                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);
                SubLObject result = NIL;
                SubLObject v_bindings = NIL;
                SubLObject cdolist_list_var = x_y_derivative_points;
                SubLObject x_y_derivative_point = NIL;
                x_y_derivative_point = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    result = cons(list($$The2DPoint, list(x_units, x_y_derivative_point.first()), list(derivative_units, second(x_y_derivative_point))), result);
                    cdolist_list_var = cdolist_list_var.rest();
                    x_y_derivative_point = cdolist_list_var.first();
                } 
                result = make_el_extensional_set(nreverse(result));
                v_bindings = unification_utilities.term_unify(result, set_of_derivative_points_in_units, UNPROVIDED, UNPROVIDED);
                if (NIL != v_bindings) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject set_of_points_1_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject set_of_points_2_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject binary_function = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        final SubLObject binary_predicate = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);
        final SubLObject value_in_y_units = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);
        final SubLObject set_of_qualifying_points_in_units = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);
        if (((((NIL != el_extensional_set_p(set_of_points_1_in_units)) && (NIL != el_extensional_set_p(set_of_points_2_in_units))) && (NIL != fort_types_interface.functionP(binary_function))) && arity.arity(binary_function).eql(TWO_INTEGER)) && (NIL != kb_accessors.binary_predicateP(binary_predicate))) {
            final SubLObject v_2d_points_1 = extensional_set_elements(set_of_points_1_in_units);
            final SubLObject v_2d_points_2 = extensional_set_elements(set_of_points_2_in_units);
            if ((NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_1, UNPROVIDED)) && (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points_2, UNPROVIDED))) {
                thread.resetMultipleValues();
                final SubLObject x_y_values_1 = explode_2d_points_with_units(v_2d_points_1, UNPROVIDED, UNPROVIDED);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                final SubLObject x_y_values_2 = explode_2d_points_with_units(v_2d_points_2, x_units, y_units);
                final SubLObject y_compare_value = second(quantities.cyc_quantity_conversion(y_units, value_in_y_units));
                SubLObject result_x_y_values = NIL;
                SubLObject cdolist_list_var = x_y_values_1;
                SubLObject x_y_value_1 = NIL;
                x_y_value_1 = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    final SubLObject x_value_1 = x_y_value_1.first();
                    final SubLObject y_value_1 = second(x_y_value_1);
                    final SubLObject y_value_2 = second(find(x_value_1, x_y_values_2, EQL, FIRST, UNPROVIDED, UNPROVIDED));
                    if ((NIL != y_value_2) && (NIL != backward.removal_ask(list(binary_predicate, list(binary_function, y_value_1, y_value_2), y_compare_value), UNPROVIDED, UNPROVIDED, UNPROVIDED))) {
                        result_x_y_values = cons(x_y_value_1, result_x_y_values);
                    }
                    cdolist_list_var = cdolist_list_var.rest();
                    x_y_value_1 = cdolist_list_var.first();
                } 
                SubLObject result = NIL;
                SubLObject cdolist_list_var2 = result_x_y_values;
                SubLObject result_x_y_value = NIL;
                result_x_y_value = cdolist_list_var2.first();
                while (NIL != cdolist_list_var2) {
                    result = cons(list($$The2DPoint, list(x_units, result_x_y_value.first()), list(y_units, second(result_x_y_value))), result);
                    cdolist_list_var2 = cdolist_list_var2.rest();
                    result_x_y_value = cdolist_list_var2.first();
                } 
                result = make_el_extensional_set(nreverse(result));
                final SubLObject v_bindings = unification_utilities.term_unify(result, set_of_qualifying_points_in_units, UNPROVIDED, UNPROVIDED);
                if (NIL != v_bindings) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                }
            }
        }
        return NIL;
    }

    public static SubLObject java_link_debug_modeP() {
        final SubLThread thread = SubLProcess.currentSubLThread();
        return $inference_debugP$.getDynamicValue(thread);
    }

    public static SubLObject java_link_slope_and_intercept_of_x_y_regression(final SubLObject x_y_values) {
        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });
        final SubLObject slope_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSlope, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject intercept_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getIntercept, EMPTY_SUBL_OBJECT_ARRAY);
        SubLObject cdolist_list_var = x_y_values;
        SubLObject x_y_value = NIL;
        x_y_value = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value = cdolist_list_var.first();
        } 
        return values(JavaLink.java_call(slope_method, regression, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(intercept_method, regression, EMPTY_SUBL_OBJECT_ARRAY));
    }

    public static SubLObject java_link_x_y_cubic_spline_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {
        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {
            return NIL;
        }
        final SubLObject interpolator = JavaLink.java_new($str42$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject interpolate_method = JavaLink.java_method($str42$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });
        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });
        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);
        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });
        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });
    }

    public static SubLObject java_link_x_y_piecewise_linear_find_y_for_x(SubLObject x_y_values, final SubLObject x_value) {
        if ((x_value.numL(apply(MIN, Mapping.mapcar(FIRST, x_y_values))) || x_value.numG(apply(MAX, Mapping.mapcar(FIRST, x_y_values)))) || ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED)))) {
            return NIL;
        }
        final SubLObject interpolator = JavaLink.java_new($str49$org_apache_commons_math_analysis_, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject interpolate_method = JavaLink.java_method($str49$org_apache_commons_math_analysis_, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });
        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });
        x_y_values = Sort.sort(x_y_values, $sym47$_, FIRST);
        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });
        return JavaLink.java_call(value_method, poly_spline_function, new SubLObject[]{ x_value });
    }

    public static SubLObject java_link_x_y_regression_find_y_for_x(final SubLObject x_y_values, final SubLObject x_value) {
        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });
        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });
        SubLObject cdolist_list_var = x_y_values;
        SubLObject x_y_value = NIL;
        x_y_value = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value = cdolist_list_var.first();
        } 
        return JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value });
    }

    public static SubLObject java_link_x_y_regression_find_y_for_x_with_error_bars(final SubLObject x_y_values, final SubLObject x_value) {
        if (length(x_y_values).numL(THREE_INTEGER)) {
            return NIL;
        }
        final SubLObject number_of_points = length(x_y_values);
        final SubLObject regression = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });
        final SubLObject sse_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$getSumSquaredErrors, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });
        SubLObject cdolist_list_var = x_y_values;
        SubLObject x_y_value = NIL;
        x_y_value = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            JavaLink.java_call(add_data_method, regression, new SubLObject[]{ x_y_value.first(), second(x_y_value) });
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value = cdolist_list_var.first();
        } 
        final SubLObject sum_of_squared_errors = JavaLink.java_call(sse_method, regression, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject y_error = sqrt(divide(sum_of_squared_errors, subtract(number_of_points, TWO_INTEGER)));
        return values(JavaLink.java_call(predict_method, regression, new SubLObject[]{ x_value }), y_error);
    }

    public static SubLObject java_link_point_intersection_of_two_x_y_regressions(final SubLObject x_y_values_1, final SubLObject x_y_values_2) {
        if ((((NIL == x_y_values_1) || (NIL != list_utilities.singletonP(x_y_values_1))) || (NIL == x_y_values_2)) || (NIL != list_utilities.singletonP(x_y_values_2))) {
            return NIL;
        }
        final SubLObject regression_1 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject regression_2 = JavaLink.java_new($str35$org_apache_commons_math_stat_regr, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject add_data_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$addData, new SubLObject[]{ $$$double, $$$double });
        final SubLObject predict_method = JavaLink.java_method($str35$org_apache_commons_math_stat_regr, $$$predict, new SubLObject[]{ $$$double });
        final SubLObject l1_p1_x = x_y_values_1.first().first();
        final SubLObject l1_p2_x = second(x_y_values_1).first();
        final SubLObject l2_p1_x = x_y_values_2.first().first();
        final SubLObject l2_p2_x = second(x_y_values_2).first();
        SubLObject cdolist_list_var = x_y_values_1;
        SubLObject x_y_value_1 = NIL;
        x_y_value_1 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            JavaLink.java_call(add_data_method, regression_1, new SubLObject[]{ x_y_value_1.first(), second(x_y_value_1) });
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value_1 = cdolist_list_var.first();
        } 
        cdolist_list_var = x_y_values_2;
        SubLObject x_y_value_2 = NIL;
        x_y_value_2 = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            JavaLink.java_call(add_data_method, regression_2, new SubLObject[]{ x_y_value_2.first(), second(x_y_value_2) });
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value_2 = cdolist_list_var.first();
        } 
        final SubLObject l1_p1_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p1_x });
        final SubLObject l1_p2_y = JavaLink.java_call(predict_method, regression_1, new SubLObject[]{ l1_p2_x });
        final SubLObject l2_p1_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p1_x });
        final SubLObject l2_p2_y = JavaLink.java_call(predict_method, regression_2, new SubLObject[]{ l2_p2_x });
        final SubLObject line_class_name = $str52$org_apache_commons_math_geometry_;
        final SubLObject vector2d_class_name = $str53$org_apache_commons_math_geometry_;
        final SubLObject line_new_method = JavaLink.java_method(line_class_name, NIL, new SubLObject[]{ vector2d_class_name, vector2d_class_name });
        final SubLObject vector2d_new_method = JavaLink.java_method(vector2d_class_name, NIL, new SubLObject[]{ $$$double, $$$double });
        final SubLObject line_1 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p1_x, l1_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l1_p2_x, l1_p2_y }) });
        final SubLObject line_2 = JavaLink.java_new(line_new_method, new SubLObject[]{ JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p1_x, l2_p1_y }), JavaLink.java_new(vector2d_new_method, new SubLObject[]{ l2_p2_x, l2_p2_y }) });
        final SubLObject intersection_method = JavaLink.java_method(line_class_name, $$$intersection, new SubLObject[]{ $str55$org_apache_commons_math_geometry_ });
        final SubLObject intersection_2dvector = JavaLink.java_call(intersection_method, line_1, new SubLObject[]{ line_2 });
        if (NIL != intersection_2dvector) {
            final SubLObject vector2d_getx_method = JavaLink.java_method(vector2d_class_name, $$$getX, EMPTY_SUBL_OBJECT_ARRAY);
            final SubLObject vector2d_gety_method = JavaLink.java_method(vector2d_class_name, $$$getY, EMPTY_SUBL_OBJECT_ARRAY);
            return values(JavaLink.java_call(vector2d_getx_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY), JavaLink.java_call(vector2d_gety_method, intersection_2dvector, EMPTY_SUBL_OBJECT_ARRAY));
        }
        return NIL;
    }

    public static SubLObject java_link_x_y_derivatives_for_interpolation_at_each_x(SubLObject x_y_values, final SubLObject interpolator) {
        if ((NIL == java_link_debug_modeP()) && (NIL != list_utilities.duplicatesP(Mapping.mapcar(FIRST, x_y_values), UNPROVIDED, UNPROVIDED))) {
            return NIL;
        }
        final SubLObject interpolator_string = (interpolator.eql($$CubicSpline)) ? $str42$org_apache_commons_math_analysis_ : interpolator.eql($const59$LinearPolynomialFunction_Piecewis) ? $str49$org_apache_commons_math_analysis_ : $str42$org_apache_commons_math_analysis_;
        final SubLObject interpolator_$1 = JavaLink.java_new(interpolator_string, EMPTY_SUBL_OBJECT_ARRAY);
        final SubLObject interpolate_method = JavaLink.java_method(interpolator_string, $$$interpolate, new SubLObject[]{ $str44$_D, $str44$_D });
        final SubLObject value_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$value, new SubLObject[]{ $$$double });
        final SubLObject derivative_method = JavaLink.java_method($str45$org_apache_commons_math_analysis_, $$$derivative, EMPTY_SUBL_OBJECT_ARRAY);
        SubLObject derivative_x_y_values = NIL;
        x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);
        final SubLObject poly_spline_function = JavaLink.java_call(interpolate_method, interpolator_$1, new SubLObject[]{ Mapping.mapcar(FIRST, x_y_values), Mapping.mapcar(SECOND, x_y_values) });
        final SubLObject poly_spline_derivative = JavaLink.java_call(derivative_method, poly_spline_function, EMPTY_SUBL_OBJECT_ARRAY);
        SubLObject cdolist_list_var = x_y_values;
        SubLObject x_y_value = NIL;
        x_y_value = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject x_value = x_y_value.first();
            derivative_x_y_values = cons(list(x_value, JavaLink.java_call(value_method, poly_spline_derivative, new SubLObject[]{ x_value })), derivative_x_y_values);
            cdolist_list_var = cdolist_list_var.rest();
            x_y_value = cdolist_list_var.first();
        } 
        return nreverse(derivative_x_y_values);
    }

    public static SubLObject el_2d_point_p(final SubLObject v_object) {
        return makeBoolean(((NIL != el_formula_p(v_object)) && cycl_utilities.formula_operator(v_object).eql($$The2DPoint)) && (NIL != el_binary_formula_p(v_object)));
    }

    public static SubLObject explode_2d_points_with_units(final SubLObject v_2d_points, SubLObject x_units, SubLObject y_units) {
        if (x_units == UNPROVIDED) {
            x_units = NIL;
        }
        if (y_units == UNPROVIDED) {
            y_units = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        assert NIL != list_utilities.non_dotted_list_p(v_2d_points) : "list_utilities.non_dotted_list_p(v_2d_points) " + "CommonSymbols.NIL != list_utilities.non_dotted_list_p(v_2d_points) " + v_2d_points;
        SubLObject cdolist_list_var = v_2d_points;
        SubLObject elem = NIL;
        elem = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            assert NIL != el_2d_point_p(elem) : "removal_modules_math.el_2d_point_p(elem) " + "CommonSymbols.NIL != removal_modules_math.el_2d_point_p(elem) " + elem;
            cdolist_list_var = cdolist_list_var.rest();
            elem = cdolist_list_var.first();
        } 
        SubLObject x_y_values = NIL;
        cdolist_list_var = v_2d_points;
        SubLObject v_2d_point = NIL;
        v_2d_point = cdolist_list_var.first();
        while (NIL != cdolist_list_var) {
            final SubLObject x_y_with_units = cycl_utilities.formula_args(v_2d_point, UNPROVIDED);
            final SubLObject x_with_units = x_y_with_units.first();
            final SubLObject y_with_units = second(x_y_with_units);
            thread.resetMultipleValues();
            final SubLObject this_x_units = quantities.explode_interval(x_with_units);
            SubLObject this_x_value = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL == x_units) {
                x_units = this_x_units;
            }
            if (!x_units.equal(this_x_units)) {
                this_x_value = quantities.convert_to_units_absolute(x_units, this_x_units, this_x_value, UNPROVIDED);
            }
            thread.resetMultipleValues();
            final SubLObject this_y_units = quantities.explode_interval(y_with_units);
            SubLObject this_y_value = thread.secondMultipleValue();
            thread.resetMultipleValues();
            if (NIL == y_units) {
                y_units = this_y_units;
            }
            if (!y_units.equal(this_y_units)) {
                this_y_value = quantities.convert_to_units_absolute(y_units, this_y_units, this_y_value, UNPROVIDED);
            }
            x_y_values = cons(list(this_x_value, this_y_value), x_y_values);
            cdolist_list_var = cdolist_list_var.rest();
            v_2d_point = cdolist_list_var.first();
        } 
        return values(x_y_values, x_units, y_units);
    }

    public static SubLObject removal_set_has_points_with_y_value_reln_to_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject operator = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject comparator = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        final SubLObject quant1 = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);
        final SubLObject quant2 = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);
        final SubLObject newset_var = cycl_utilities.atomic_sentence_arg6(asent, UNPROVIDED);
        if ((((NIL != el_extensional_set_p(set_of_points_in_units)) && (NIL != fort_types_interface.functionP(operator))) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {
            final SubLObject x_y_values_with_units = extensional_set_elements(set_of_points_in_units);
            SubLObject result_points = NIL;
            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, x_y_values_with_units, UNPROVIDED)) {
                SubLObject cdolist_list_var = x_y_values_with_units;
                SubLObject x_y_value_with_units = NIL;
                x_y_value_with_units = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    final SubLObject y_value = cycl_utilities.formula_arg2(x_y_value_with_units, UNPROVIDED);
                    if (NIL != relation_evaluation.cyc_evaluate(list(comparator, list(operator, y_value, quant1), quant2))) {
                        result_points = cons(x_y_value_with_units, result_points);
                    }
                    cdolist_list_var = cdolist_list_var.rest();
                    x_y_value_with_units = cdolist_list_var.first();
                } 
            }
            if (NIL != result_points) {
                final SubLObject v_bindings = unification_utilities.term_unify(make_el_set(list_utilities.fast_remove_duplicates(result_points, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED), UNPROVIDED), newset_var, UNPROVIDED, UNPROVIDED);
                if (NIL != v_bindings) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                }
            }
        }
        return NIL;
    }

    public static SubLObject removal_operation_result_comparison_pos_check(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);
        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);
        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {
            final SubLObject expression = list(comparator, list(operator, a, b), quant);
            if (NIL != relation_evaluation.cyc_evaluate(expression)) {
                backward.removal_add_node(arguments.make_hl_support($OPAQUE, asent, UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(expression, UNPROVIDED)));
            }
        }
        return NIL;
    }

    public static SubLObject removal_operation_result_comparison_neg_check(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLObject operator = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject a = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject b = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        final SubLObject comparator = cycl_utilities.atomic_sentence_arg4(asent, UNPROVIDED);
        final SubLObject quant = cycl_utilities.atomic_sentence_arg5(asent, UNPROVIDED);
        if (((NIL != fort_types_interface.functionP(operator)) && (NIL != relation_evaluation.evaluatable_predicateP(comparator, UNPROVIDED))) && arity.arity(comparator).eql(TWO_INTEGER)) {
            final SubLObject expression = list(comparator, list(operator, a, b), quant);
            if (NIL == relation_evaluation.cyc_evaluate(expression)) {
                backward.removal_add_node(arguments.make_hl_support($OPAQUE, make_negation(asent), UNPROVIDED, UNPROVIDED), NIL, list(removal_modules_evaluation.make_eval_support(make_negation(expression), UNPROVIDED)));
            }
        }
        return NIL;
    }

    public static SubLObject removal_inflow_lengths_with_starting_depths_expand(final SubLObject asent, SubLObject sense) {
        if (sense == UNPROVIDED) {
            sense = NIL;
        }
        final SubLThread thread = SubLProcess.currentSubLThread();
        final SubLObject well = cycl_utilities.atomic_sentence_arg1(asent, UNPROVIDED);
        final SubLObject set_of_points_in_units = cycl_utilities.atomic_sentence_arg2(asent, UNPROVIDED);
        final SubLObject function_type = $$CubicSpline;
        final SubLObject length_and_depths_query = cycl_utilities.atomic_sentence_arg3(asent, UNPROVIDED);
        final SubLObject debugP = NIL;
        if (NIL != el_extensional_set_p(set_of_points_in_units)) {
            final SubLObject v_2d_points = extensional_set_elements(set_of_points_in_units);
            if (NIL != list_utilities.every_in_list(EL_2D_POINT_P, v_2d_points, UNPROVIDED)) {
                thread.resetMultipleValues();
                SubLObject x_y_values = explode_2d_points_with_units(v_2d_points, $$Meter, $$DegreeCelsius);
                final SubLObject x_units = thread.secondMultipleValue();
                final SubLObject y_units = thread.thirdMultipleValue();
                thread.resetMultipleValues();
                x_y_values = Sort.sort(copy_list(x_y_values), $sym47$_, FIRST);
                final SubLObject x_y_derivative_points = java_link_x_y_derivatives_for_interpolation_at_each_x(x_y_values, function_type);
                final SubLObject average_y_value = number_utilities.average(x_y_values, SECOND);
                final SubLObject derivative_units = quantities.unit_quotient(y_units, x_units);
                SubLObject inflow_lengths = NIL;
                if (NIL != debugP) {
                    print(x_y_values, UNPROVIDED);
                    print(x_y_derivative_points, UNPROVIDED);
                    format_nil.force_format(T, $str76$____, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                }
                SubLObject cdolist_list_var = Sort.sort(copy_list(x_y_values), $sym85$_, SECOND);
                SubLObject x_y_value = NIL;
                x_y_value = cdolist_list_var.first();
                while (NIL != cdolist_list_var) {
                    SubLObject current;
                    final SubLObject datum = current = x_y_value;
                    SubLObject x_value = NIL;
                    SubLObject y_value = NIL;
                    destructuring_bind_must_consp(current, datum, $list77);
                    x_value = current.first();
                    current = current.rest();
                    destructuring_bind_must_consp(current, datum, $list77);
                    y_value = current.first();
                    current = current.rest();
                    if (NIL == current) {
                        if (NIL != debugP) {
                            format_nil.force_format(T, $str78$High_value__x__A_y__A__, x_value, y_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                        }
                        if (y_value.numG(add(FIVE_INTEGER, average_y_value))) {
                            SubLObject already_in_inflowP = NIL;
                            SubLObject inflow_start_x = NIL;
                            SubLObject inflow_end_x = NIL;
                            if (NIL == already_in_inflowP) {
                                SubLObject csome_list_var = inflow_lengths;
                                SubLObject inflow_length = NIL;
                                inflow_length = csome_list_var.first();
                                while ((NIL == already_in_inflowP) && (NIL != csome_list_var)) {
                                    if (x_value.numGE(inflow_length.first()) && x_value.numLE(second(inflow_length))) {
                                        already_in_inflowP = T;
                                    }
                                    csome_list_var = csome_list_var.rest();
                                    inflow_length = csome_list_var.first();
                                } 
                            }
                            if (NIL == already_in_inflowP) {
                                SubLObject found_start_pointP = NIL;
                                if (NIL == found_start_pointP) {
                                    SubLObject cur_x_y_value = NIL;
                                    SubLObject cur_x_y_value_$2 = NIL;
                                    SubLObject cur_x_y_derivative_point = NIL;
                                    SubLObject cur_x_y_derivative_point_$3 = NIL;
                                    cur_x_y_value = nreverse(copy_list(x_y_values));
                                    cur_x_y_value_$2 = cur_x_y_value.first();
                                    cur_x_y_derivative_point = nreverse(copy_list(x_y_derivative_points));
                                    cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();
                                    while ((NIL == found_start_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {
                                        SubLObject current_$5;
                                        final SubLObject datum_$4 = current_$5 = cur_x_y_derivative_point_$3;
                                        SubLObject cur_x_value = NIL;
                                        SubLObject cur_y_derivative_value = NIL;
                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);
                                        cur_x_value = current_$5.first();
                                        current_$5 = current_$5.rest();
                                        destructuring_bind_must_consp(current_$5, datum_$4, $list79);
                                        cur_y_derivative_value = current_$5.first();
                                        current_$5 = current_$5.rest();
                                        if (NIL == current_$5) {
                                            final SubLObject cur_y_value = second(cur_x_y_value_$2);
                                            if (NIL != debugP) {
                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                if (!cur_x_value.eql(cur_x_y_value_$2.first())) {
                                                    print($$$Bad_looping, UNPROVIDED);
                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);
                                                }
                                            }
                                            if (cur_y_derivative_value.numGE($float$0_5) && cur_x_value.numL(x_value)) {
                                                found_start_pointP = T;
                                                inflow_start_x = cur_x_value;
                                            }
                                        } else {
                                            cdestructuring_bind_error(datum_$4, $list79);
                                        }
                                        cur_x_y_value = cur_x_y_value.rest();
                                        cur_x_y_value_$2 = cur_x_y_value.first();
                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();
                                        cur_x_y_derivative_point_$3 = cur_x_y_derivative_point.first();
                                    } 
                                }
                                SubLObject found_end_pointP = NIL;
                                if (NIL == found_end_pointP) {
                                    SubLObject cur_x_y_value = NIL;
                                    SubLObject cur_x_y_value_$3 = NIL;
                                    SubLObject cur_x_y_derivative_point = NIL;
                                    SubLObject cur_x_y_derivative_point_$4 = NIL;
                                    cur_x_y_value = x_y_values;
                                    cur_x_y_value_$3 = cur_x_y_value.first();
                                    cur_x_y_derivative_point = x_y_derivative_points;
                                    cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();
                                    while ((NIL == found_end_pointP) && ((NIL != cur_x_y_derivative_point) || (NIL != cur_x_y_value))) {
                                        SubLObject current_$6;
                                        final SubLObject datum_$5 = current_$6 = cur_x_y_derivative_point_$4;
                                        SubLObject cur_x_value = NIL;
                                        SubLObject cur_y_derivative_value = NIL;
                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);
                                        cur_x_value = current_$6.first();
                                        current_$6 = current_$6.rest();
                                        destructuring_bind_must_consp(current_$6, datum_$5, $list79);
                                        cur_y_derivative_value = current_$6.first();
                                        current_$6 = current_$6.rest();
                                        if (NIL == current_$6) {
                                            final SubLObject cur_y_value = second(cur_x_y_value_$3);
                                            if (NIL != debugP) {
                                                format_nil.force_format(T, $str80$checking_x__A_deriv__A__, cur_x_value, cur_y_derivative_value, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                                if (!cur_x_value.eql(cur_x_y_value_$3.first())) {
                                                    print($$$Bad_looping, UNPROVIDED);
                                                    Errors.sublisp_break(UNPROVIDED, EMPTY_SUBL_OBJECT_ARRAY);
                                                }
                                            }
                                            if (cur_y_derivative_value.numLE($float$_0_5) && cur_x_value.numG(x_value)) {
                                                found_end_pointP = T;
                                                inflow_end_x = cur_x_value;
                                            }
                                        } else {
                                            cdestructuring_bind_error(datum_$5, $list79);
                                        }
                                        cur_x_y_value = cur_x_y_value.rest();
                                        cur_x_y_value_$3 = cur_x_y_value.first();
                                        cur_x_y_derivative_point = cur_x_y_derivative_point.rest();
                                        cur_x_y_derivative_point_$4 = cur_x_y_derivative_point.first();
                                    } 
                                }
                            }
                            if ((NIL != inflow_start_x) && (NIL != inflow_end_x)) {
                                if (NIL != debugP) {
                                    format_nil.force_format(T, $str84$Got_interval___A__A___, inflow_start_x, inflow_end_x, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                                }
                                inflow_lengths = cons(list(inflow_start_x, inflow_end_x), inflow_lengths);
                            }
                        }
                    } else {
                        cdestructuring_bind_error(datum, $list77);
                    }
                    cdolist_list_var = cdolist_list_var.rest();
                    x_y_value = cdolist_list_var.first();
                } 
                inflow_lengths = Sort.sort(inflow_lengths, $sym47$_, FIRST);
                if (NIL != debugP) {
                    format_nil.force_format(T, $str86$inflow_lengths___A__, inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                }
                SubLObject merged_inflow_lengths = NIL;
                SubLObject cur_start = NIL;
                SubLObject cur_end = NIL;
                SubLObject cdolist_list_var2 = inflow_lengths;
                SubLObject inflow_length2 = NIL;
                inflow_length2 = cdolist_list_var2.first();
                while (NIL != cdolist_list_var2) {
                    SubLObject current2;
                    final SubLObject datum2 = current2 = inflow_length2;
                    SubLObject start = NIL;
                    SubLObject end = NIL;
                    destructuring_bind_must_consp(current2, datum2, $list87);
                    start = current2.first();
                    current2 = current2.rest();
                    destructuring_bind_must_consp(current2, datum2, $list87);
                    end = current2.first();
                    current2 = current2.rest();
                    if (NIL == current2) {
                        if ((NIL != cur_start) && (NIL != cur_end)) {
                            if (start.numLE(cur_end)) {
                                cur_end = end;
                            } else {
                                merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);
                                cur_start = start;
                                cur_end = end;
                            }
                        } else {
                            cur_start = start;
                            cur_end = end;
                        }
                    } else {
                        cdestructuring_bind_error(datum2, $list87);
                    }
                    cdolist_list_var2 = cdolist_list_var2.rest();
                    inflow_length2 = cdolist_list_var2.first();
                } 
                if ((NIL != cur_start) && (NIL != cur_end)) {
                    merged_inflow_lengths = cons(list(cur_start, cur_end), merged_inflow_lengths);
                }
                if (NIL != debugP) {
                    format_nil.force_format(T, $str88$merged_inflow_lengths___A__, merged_inflow_lengths, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED, UNPROVIDED);
                }
                inflow_lengths = merged_inflow_lengths;
                SubLObject result = NIL;
                SubLObject cdolist_list_var3 = inflow_lengths;
                SubLObject result_inflow_length = NIL;
                result_inflow_length = cdolist_list_var3.first();
                while (NIL != cdolist_list_var3) {
                    result = cons(list($$TheList, list(x_units, result_inflow_length.first()), list(x_units, subtract(second(result_inflow_length), result_inflow_length.first()))), result);
                    cdolist_list_var3 = cdolist_list_var3.rest();
                    result_inflow_length = cdolist_list_var3.first();
                } 
                result = make_el_list(result, UNPROVIDED);
                final SubLObject v_bindings = unification_utilities.term_unify(result, length_and_depths_query, UNPROVIDED, UNPROVIDED);
                if (NIL != v_bindings) {
                    backward.removal_add_node(arguments.make_hl_support($OPAQUE, bindings.apply_bindings(v_bindings, asent), UNPROVIDED, UNPROVIDED), v_bindings, UNPROVIDED);
                }
            }
        }
        return NIL;
    }

    public static SubLObject declare_removal_modules_math_file() {
        declareFunction("removal_interpolation_with_cubic_spline_expand", "REMOVAL-INTERPOLATION-WITH-CUBIC-SPLINE-EXPAND", 1, 1, false);
        declareFunction("removal_interpolation_with_piecewise_linear_polynomial_expand", "REMOVAL-INTERPOLATION-WITH-PIECEWISE-LINEAR-POLYNOMIAL-EXPAND", 1, 1, false);
        declareFunction("removal_extrapolation_with_simple_linear_regression_expand", "REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-EXPAND", 1, 1, false);
        declareFunction("removal_interpolation_or_extrapolation_with_java_link_function_expand_helper", "REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER", 2, 0, false);
        declareFunction("removal_extrapolation_with_simple_linear_regression_with_error_bars_expand", "REMOVAL-EXTRAPOLATION-WITH-SIMPLE-LINEAR-REGRESSION-WITH-ERROR-BARS-EXPAND", 1, 1, false);
        declareFunction("removal_interpolation_or_extrapolation_with_error_bars_with_java_link_function_expand_helper", "REMOVAL-INTERPOLATION-OR-EXTRAPOLATION-WITH-ERROR-BARS-WITH-JAVA-LINK-FUNCTION-EXPAND-HELPER", 2, 0, false);
        declareFunction("removal_regression_lines_for_sets_intersect_at_point_expand", "REMOVAL-REGRESSION-LINES-FOR-SETS-INTERSECT-AT-POINT-EXPAND", 1, 1, false);
        declareFunction("removal_slope_of_regression_line_for_set_of_points_expand", "REMOVAL-SLOPE-OF-REGRESSION-LINE-FOR-SET-OF-POINTS-EXPAND", 1, 1, false);
        declareFunction("removal_set_of_first_derivative_points_based_on_set_of_points_expand", "REMOVAL-SET-OF-FIRST-DERIVATIVE-POINTS-BASED-ON-SET-OF-POINTS-EXPAND", 1, 1, false);
        declareFunction("removal_set_has_points_with_y_value_reln_to_matching_x_value_points_in_set_expand", "REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-MATCHING-X-VALUE-POINTS-IN-SET-EXPAND", 1, 1, false);
        declareFunction("java_link_debug_modeP", "JAVA-LINK-DEBUG-MODE?", 0, 0, false);
        declareFunction("java_link_slope_and_intercept_of_x_y_regression", "JAVA-LINK-SLOPE-AND-INTERCEPT-OF-X-Y-REGRESSION", 1, 0, false);
        declareFunction("java_link_x_y_cubic_spline_find_y_for_x", "JAVA-LINK-X-Y-CUBIC-SPLINE-FIND-Y-FOR-X", 2, 0, false);
        declareFunction("java_link_x_y_piecewise_linear_find_y_for_x", "JAVA-LINK-X-Y-PIECEWISE-LINEAR-FIND-Y-FOR-X", 2, 0, false);
        declareFunction("java_link_x_y_regression_find_y_for_x", "JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X", 2, 0, false);
        declareFunction("java_link_x_y_regression_find_y_for_x_with_error_bars", "JAVA-LINK-X-Y-REGRESSION-FIND-Y-FOR-X-WITH-ERROR-BARS", 2, 0, false);
        declareFunction("java_link_point_intersection_of_two_x_y_regressions", "JAVA-LINK-POINT-INTERSECTION-OF-TWO-X-Y-REGRESSIONS", 2, 0, false);
        declareFunction("java_link_x_y_derivatives_for_interpolation_at_each_x", "JAVA-LINK-X-Y-DERIVATIVES-FOR-INTERPOLATION-AT-EACH-X", 2, 0, false);
        declareFunction("el_2d_point_p", "EL-2D-POINT-P", 1, 0, false);
        declareFunction("explode_2d_points_with_units", "EXPLODE-2D-POINTS-WITH-UNITS", 1, 2, false);
        declareFunction("removal_set_has_points_with_y_value_reln_to_expand", "REMOVAL-SET-HAS-POINTS-WITH-Y-VALUE-RELN-TO-EXPAND", 1, 1, false);
        declareFunction("removal_operation_result_comparison_pos_check", "REMOVAL-OPERATION-RESULT-COMPARISON-POS-CHECK", 1, 1, false);
        declareFunction("removal_operation_result_comparison_neg_check", "REMOVAL-OPERATION-RESULT-COMPARISON-NEG-CHECK", 1, 1, false);
        declareFunction("removal_inflow_lengths_with_starting_depths_expand", "REMOVAL-INFLOW-LENGTHS-WITH-STARTING-DEPTHS-EXPAND", 1, 1, false);
        return NIL;
    }

    public static SubLObject init_removal_modules_math_file() {
        defparameter("*DEFAULT-MATH-MODULE-COST*", $typical_hl_module_check_cost$.getGlobalValue());
        return NIL;
    }

    public static SubLObject setup_removal_modules_math_file() {
        inference_modules.register_solely_specific_removal_module_predicate($$interpolationWithCubicSpline);
        preference_modules.doomed_unless_arg_bindable($POS, $$interpolationWithCubicSpline, ONE_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_CUBIC_SPLINE, $list3);
        inference_modules.register_solely_specific_removal_module_predicate($const5$interpolationWithPiecewiseLinearP);
        preference_modules.doomed_unless_arg_bindable($POS, $const5$interpolationWithPiecewiseLinearP, ONE_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_INTERPOLATION_WITH_PIECEWISE_LINEAR_POLYNOMIAL, $list7);
        inference_modules.register_solely_specific_removal_module_predicate($const9$extrapolationWithSimpleLinearRegr);
        preference_modules.doomed_unless_arg_bindable($POS, $const9$extrapolationWithSimpleLinearRegr, ONE_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION, $list11);
        inference_modules.register_solely_specific_removal_module_predicate($const17$extrapolationWithSimpleLinearRegr);
        preference_modules.doomed_unless_arg_bindable($POS, $const17$extrapolationWithSimpleLinearRegr, ONE_INTEGER);
        inference_modules.inference_removal_module($kw18$REMOVAL_EXTRAPOLATION_WITH_SIMPLE_LINEAR_REGRESSION_WITH_ERROR_BA, $list19);
        inference_modules.register_solely_specific_removal_module_predicate($const21$regressionLinesForSetsIntersectAt);
        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, ONE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const21$regressionLinesForSetsIntersectAt, TWO_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_REGRESSION_LINES_FOR_SETS_INTERSECT_AT_POINT, $list23);
        inference_modules.register_solely_specific_removal_module_predicate($const25$slopeOfRegressionLineForSetOfPoin);
        preference_modules.doomed_unless_arg_bindable($POS, $const25$slopeOfRegressionLineForSetOfPoin, ONE_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_SLOPE_OF_REGRESSION_LINE_FOR_SET_OF_POINTS, $list27);
        inference_modules.register_solely_specific_removal_module_predicate($const28$setOfFirstDerivativePointsBasedOn);
        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, ONE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const28$setOfFirstDerivativePointsBasedOn, TWO_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_SET_OF_FIRST_DERIVATIVE_POINTS_BASED_ON_SET_OF_POINTS, $list30);
        inference_modules.register_solely_specific_removal_module_predicate($const31$setHasPointsWithYValueRelnToMatch);
        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, ONE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, TWO_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, THREE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FOUR_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $const31$setHasPointsWithYValueRelnToMatch, FIVE_INTEGER);
        inference_modules.inference_removal_module($kw32$REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO_MATCHING_X_VALUE_POIN, $list33);
        inference_modules.register_solely_specific_removal_module_predicate($$setHasPointsWithYValueRelnTo);
        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, ONE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, TWO_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, THREE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FOUR_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $$setHasPointsWithYValueRelnTo, FIVE_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_SET_HAS_POINTS_WITH_Y_VALUE_RELN_TO, $list64);
        inference_modules.register_solely_specific_removal_module_predicate($$operationResultComparison);
        preference_modules.doomed_unless_all_args_bindable($POS, $$operationResultComparison);
        preference_modules.doomed_unless_all_args_bindable($NEG, $$operationResultComparison);
        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_POS_CHECK, $list68);
        inference_modules.inference_removal_module($REMOVAL_OPERATION_RESULT_COMPARISON_NEG_CHECK, $list70);
        inference_modules.register_solely_specific_removal_module_predicate($$inflowLengthsWithStartingDepths);
        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, ONE_INTEGER);
        preference_modules.doomed_unless_arg_bindable($POS, $$inflowLengthsWithStartingDepths, TWO_INTEGER);
        inference_modules.inference_removal_module($REMOVAL_INFLOW_LENGTHS_WITH_STARTING_DEPTHS, $list73);
        return NIL;
    }

    @Override
    public void declareFunctions() {
        declare_removal_modules_math_file();
    }

    @Override
    public void initializeVariables() {
        init_removal_modules_math_file();
    }

    @Override
    public void runTopLevelForms() {
        setup_removal_modules_math_file();
    }

    static {




























































































    }
}
```


Overlapping Code:
```
 extends SubLTranslatedFile implements V10 {
public static final SubLFile me = new removal_modules_();
public static final String myName = "com.cyc.cycjava_2.cycl.inference.modules.removal.removal_modules";
// defparameter
public static final SubLSymbol $de");
private static final SubLList $list3 = list(new SubLObject[]{ makeKeyword("SENSE"), makeKeyword("POS"), makeKeyword("PREDICATE"), reader_make_constant_shell(makeString("")), makeKeyword("REQUIRED-PATTERN"), list(reader_make_constant_shell(makeString("e")), makeKeyword("FULLY-BOUND"), list(makeKeyword("OR"), list(reader_make_constant_shell(makeString(")), makeKeyword("NOT-FULLY-BOUND"), makeKeyword("FULLY-BOUND")), list(reader_make_constant_shell(makeString("Th)), makeKeyword("FULLY-BOUND"), makeKeyword("NOT-FULLY-BOU")))), makeKeyword("COST-EXPRESSION"), makeSymbol("*DEFAULT-MATH-MODULE-COST*"), makeKeyword("COMPLETENESS"), makeKeyword("COMPLETE"), makeKeyword("EXPAND"), makeSymbol("REMOVAL--EXPAND"), makeKeyword("DOCUMENTATION"), makeString("(#$iny-bound>)"), makeKeyword("EXAMPLE"), makeString("($The2DPoint \n (#$Meter 445.8) \n (#$DegreeCelsius
```
<Overlap Ratio: 0.4798456260720412>

---

--- 275 --
Question ID: d79faf19151178e5e36d66964728ae9f51a4895c
Original Code:
```
public class BaseFrame extends JFrame
        implements XmlConvertible<BaseFrame>, LocalizedComponent,
                    Titled, Foregrounded, Backgrounded, Enabled {
    /**
     *
     */
    private static final long serialVersionUID = -2623088843557577651L;
    public BaseFrame () throws HeadlessException
    {
        super();
    }

    public BaseFrame (GraphicsConfiguration gc)
    {
        super(gc);
    }

    public BaseFrame (String title) throws HeadlessException
    {
        super(title);
    }

    public BaseFrame (String title, GraphicsConfiguration gc)
    {
        super(title, gc);
    }

    protected XmlProxyConvertible<?> getFrameConverter (final Element elem)
    {
        return (null == elem) ? null : BaseFrameReflectiveProxy.BASEFRM;
    }
    /*
     * @see net.community.chest.dom.transform.XmlConvertible#fromXml(org.w3c.dom.Element)
     */
    @Override
    @CoVariantReturn
    public BaseFrame fromXml (Element elem) throws Exception
    {
        final XmlProxyConvertible<?>    proxy=getFrameConverter(elem);
        @SuppressWarnings("unchecked")
        final Object                    co=
            ((XmlProxyConvertible<Object>) proxy).fromXml(this, elem);
        if (co != this)
            throw new IllegalStateException(ClassUtil.getExceptionLocation(getClass(), "fromXml") + " mismatched updated instances");

        return this;
    }

    public BaseFrame (Element elem) throws Exception
    {
        final Object    inst=fromXml(elem);
        if (inst != this)
            throw new IllegalStateException(ClassUtil.getConstructorExceptionLocation(getClass()) + "[" + Window.class.getSimpleName() + "] mismatched instances");
    }
    /*
     * @see net.community.chest.dom.transform.XmlConvertible#toXml(org.w3c.dom.Document)
     */
    @Override
    public Element toXml (Document doc) throws Exception
    {
        // TODO implement toXml
        throw new UnsupportedOperationException(ClassUtil.getExceptionLocation(getClass(), "toXml") + " N/A");
    }

    private Locale    _lcl    /* =null */;
    /*
     * @see net.community.chest.ui.helpers.LocalizedComponent#getDisplayLocale()
     */
    @Override
    public synchronized Locale getDisplayLocale ()
    {
        if (null == _lcl)
            _lcl = Locale.getDefault();
        return _lcl;
    }
    /*
     * @see net.community.chest.ui.helpers.LocalizedComponent#setDisplayLocale(java.util.Locale)
     */
    @Override
    public synchronized void setDisplayLocale (Locale l)
    {
        if (_lcl != l)    // debug breakpoint
            _lcl = l;
    }

    public <C extends Component> C addConstrainedComponent (C comp, Node constValue)
    {
        return ContainerReflectiveProxy.addConstrainedComponent(this, comp, constValue);
    }

    public FocusTraversalPolicy setFocusTraversalPolicy (List<Component> comps)
    {
        if ((null == comps) || (comps.size() <= 0))
            return getFocusTraversalPolicy();

        final ByComponentFocusTraversalPolicy    p=new ByComponentFocusTraversalPolicy(comps);
        setFocusTraversalPolicy(p);
        return p;
    }

    public FocusTraversalPolicy setFocusTraversalPolicy (Component ... comps)
    {
        return setFocusTraversalPolicy(((null == comps) || (comps.length <= 0)) ? null : Arrays.asList(comps));
    }

    public FocusTraversalPolicy setFocusTraversalPolicy (String ... comps)
    {
        if ((null == comps) || (comps.length <= 0))
            return getFocusTraversalPolicy();

        final ByNameFocusTraversalPolicy    p=new ByNameFocusTraversalPolicy(comps);
        setFocusTraversalPolicy(p);
        return p;
    }
}
```


Overlapping Code:
```
ds JFrame
implements XmlConvertible<BaseFrame>, LocalizedComponent,
Titled, Foregrounded, Backgrounded, Enabled {
/**
*
*/
private static final long serialVersionUID = -2623088843557577651L;
public BaseFrame () throws HeadlessException
{
super();
}
public BaseFrame (GraphicsConfiguration gc)
{
super(gc);
}
public BaseFrame (String title) throws HeadlessException
{
super(title);
}
public BaseFrame (String title, GraphicsConfiguration gc)
{
super(title, gc);
}
protected XmlProxyConvertible<?> getFrameConverter (final Element elem)
{
return (null == elem) ? null : BaseFrameReflectiveProxy.BASEFRM;
}
/*
* @see net.community.chest.dom.transform.XmlConvertible#fromXml(org.w3c.dom.Element)
*/
@Override
@CoVariantReturn
public BaseFrame fromXml (Element elem) throws Exception
{
final XmlProxyConvertible<?> proxy=getFrameConverter(elem);
@SuppressWarnings("unchecked")
final Object co=
((XmlProxyConvertible<Object>) proxy).fromXml(this, elem);
if (co != this)
throw new IllegalStateException(ClassUtil.getExceptionLocation(getClass(), "fromXml") + " mismatched updated instances");
return this;
}
public BaseFrame (Element elem) throws Exception
{
final Object inst=fromXml(elem);
if (inst != this)
throw new IllegalStateException(ClassUtil.getConstructorExceptionLocation(getClass()) + "[" + Window.class.getSimpleName() + "] mismatched instances");
}
/*
* @see net.community.chest.dom.transform.XmlConvertible#toXml(org.w3c.dom.Document)
*/
@Override
public Element toXml (Document doc) throws Exception
{
// TODO implement toXml
throw new UnsupportedOperationException(ClassUtil.getExceptionLocation(getClass(), "toXml") + " N/A");
}
private Locale _lcl /* =null */;
/*
* @see net.community.chest.ui.helpers.LocalizedComponent#getDisplayLocale()
*/
@Override
public synchronized Locale getDisplayLocale ()
{
if (null == _lcl)
_lcl = Locale.getDefault();
return _lcl;
}
/*
* @see net.community.chest.ui.helpers.LocalizedComponent#setDisplayLocale(java.util.Locale)
*/
@Override
public synchronized void s
```
<Overlap Ratio: 0.9819247679531021>

---

--- 276 --
Question ID: cca4720897a5238d699d6f2848354504c689f40a
Original Code:
```
public class ProcessingImageSignatureOverCRUD {

    /**
    * Following example shows how to process Image Signature over all signature life-cycle.
    * First document is being signed with Image Signature, then verified for it, searched for same, updating and finally deleting this signature.
    */
    public static void run() throws Exception
    {
        System.out.print("\n--------------------------------------------------------------------------------------------------------------------");
        System.out.print("[Example Advanced Usage] # ProcessingImageSignatureOverCRUD : Process Image Signature over all signature life-cycle\n");

        // The path to the documents directory.
        String filePath = Constants.SAMPLE_WORDPROCESSING;
        String fileName = Paths.get(filePath).getFileName().toString();

        String outputFilePath = new File(Constants.OutputPath, "ProcessingImageSignatureOverCRUD\\"+ fileName).getPath();
        List<String> signatureIds = new ArrayList<String>();
        // -----------------------------------------------------------------------------------------------------------------------------
        // STEP 1. Sign document with Image Signature
        // -----------------------------------------------------------------------------------------------------------------------------
        Signature signature = new Signature(filePath);
        {
            ImageSignOptions signOptions = new ImageSignOptions(Constants.ImageHandwrite);
            signOptions.setVerticalAlignment(VerticalAlignment.Top);
            signOptions.setHorizontalAlignment(HorizontalAlignment.Center);
            signOptions.setWidth(100);
            signOptions.setHeight(40);
            signOptions.setMargin(new Padding(20));

            // sign document to file
            SignResult signResult = signature.sign(outputFilePath, signOptions);
            System.out.print("\nDocument "+filePath+" was signed with following signatures:");
            for (BaseSignature temp : signResult.getSucceeded())
            {
                // collect newly created signature' Id
                signatureIds.add(temp.getSignatureId());
                System.out.print("Signature : "+temp.getSignatureType()+" Id:"+temp.getSignatureId()+", Location: "+temp.getLeft()+"x"+temp.getTop()+". Size: "+temp.getWidth()+"x"+temp.getHeight());
            }
        }
        // -----------------------------------------------------------------------------------------------------------------------------
        // STEP 2. Search document for Image Signature
        // -----------------------------------------------------------------------------------------------------------------------------
        Signature signature2 = new Signature(outputFilePath);
        {
            ImageSearchOptions searchOptions = new ImageSearchOptions();
            // specify special pages to search on
            searchOptions.setAllPages(true);


            // search for image signatures in document
            List<ImageSignature> signatures = signature2.search(ImageSignature.class,searchOptions);
            System.out.print("\nSource document contains following Image signature(s).");
            // enumerate all signature for output
            for (ImageSignature imageSignature : signatures)
            {
                if (imageSignature != null)
                {
                    System.out.print("Found Image signature at page "+imageSignature.getPageNumber()+" and Image Size '"+imageSignature.getSize()+"'.");
                    System.out.print("Location at "+imageSignature.getLeft()+"-"+imageSignature.getTop()+". Size is "+imageSignature.getWidth()+"x"+imageSignature.getHeight()+".");
                }
            }
            // -----------------------------------------------------------------------------------------------------------------------------
            // STEP 3. Update document Image Signature after searching it
            // -----------------------------------------------------------------------------------------------------------------------------
            List<BaseSignature> signaturesToUpdate = new ArrayList<BaseSignature>();
            for (ImageSignature imageSignature : signatures)
            {
                // change position
                imageSignature.setLeft(imageSignature.getLeft() + 100);
                imageSignature.setTop(imageSignature.getTop() + 100);
                // change size. Please note not all documents support changing signature size
                imageSignature.setWidth(200);
                imageSignature.setHeight(50);
                signaturesToUpdate.add(imageSignature);
            }
            UpdateResult updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);
            if (updateResult.getSucceeded().size() == signatures.size())
            {
                System.out.print("\nAll signatures were successfully updated!");
            }
            else
            {
                System.out.print("Successfully updated signatures : "+updateResult.getSucceeded().size());
                System.out.print("Not updated signatures : "+updateResult.getFailed().size());
            }
            System.out.print("List of updated signatures:");
            for (BaseSignature temp : updateResult.getSucceeded())
            {
                System.out.print("Signature# Id:"+temp.getSignatureId()+", Location: "+temp.getLeft()+"x"+temp.getTop()+". Size: "+temp.getWidth()+"x"+temp.getHeight());
            }
            // -----------------------------------------------------------------------------------------------------------------------------
            // STEP 4. Update document Image Signature on saved SignatureId
            // create list of Image Signature by known SignatureId
            // -----------------------------------------------------------------------------------------------------------------------------
            signaturesToUpdate.clear();
            for ( String item : signatureIds)
            {
                ImageSignature temp = new ImageSignature(item);
                temp.setWidth(150);
                temp.setHeight(30);
                temp.setLeft(100);
                temp.setTop(100);

                signaturesToUpdate.add(temp);
            }
            // update all found signatures
            updateResult = signature2.update(new ByteArrayOutputStream(), signaturesToUpdate);
            if (updateResult.getSucceeded().size() == signatures.size())
            {
                System.out.print("\nAll signatures were successfully updated!");
            }
            else
            {
                System.out.print("Successfully updated signatures : "+updateResult.getSucceeded().size());
                System.out.print("Not updated signatures : "+updateResult.getFailed().size());
            }
            System.out.print("List of updated signatures:");
            for (BaseSignature temp : updateResult.getSucceeded())
            {
                System.out.print("Signature# Id:"+temp.getSignatureId()+", Location: "+temp.getLeft()+"x"+temp.getTop()+". Size: "+temp.getWidth()+"x"+temp.getHeight());
            }
            // -----------------------------------------------------------------------------------------------------------------------------
            // STEP 5. Delete document Image Signature by id
            // create list of Image Signature by known SignatureId
            signaturesToUpdate.clear();
            for (String item : signatureIds)
            {
                ImageSignature temp = new ImageSignature(item);
                signaturesToUpdate.add(temp);
            }
            // delete all signatures
            DeleteResult deleteResult = signature2.delete(new ByteArrayOutputStream(), signaturesToUpdate);
            if (deleteResult.getSucceeded().size() == signaturesToUpdate.size())
            {
                System.out.print("\nAll signatures were successfully deleted!");
            }
            else
            {
                System.out.print("Successfully deleted signatures : "+deleteResult.getSucceeded().size());
                System.out.print("Not deleted signatures : "+deleteResult.getFailed().size());
            }
            System.out.print("List of deleted signatures:");
            for (BaseSignature temp : deleteResult.getSucceeded())
            {
                System.out.print("Signature# Id:"+temp.getSignatureId()+", Location: "+temp.getLeft()+"x"+temp.getTop()+". Size: "+temp.getWidth()+"x"+temp.getHeight());
            }
        }
    }
}
```


Overlapping Code:
```
ngImageSignatureOverCRUD {
/**
* Following example shows how to process Image Signature over all signature life-cycle.
* First document is being signed with Image Signature, then verified for it, searched for same, updating and finally deleting this signature.
*/
public static void run() throws Exception
{
System.out.print("\n--------------------------------------------------------------------------------------------------------------------");
System.out.print("[Example Advanced Usage] # ProcessingImageSignatureOverCRUD : Process Image Signature over all signature life-cycle\n");
// The path to the documents directory.
String filePath = Constants.SAMPLE_WORDPROCESSING;
String fileName = Paths.get(filePath).getFileName().toString();
String outputFilePath = new File(Constants.OutputPath, "ProcessingImageSignatureOverCRUD\\"+ fileName).getPath();
List<String> signatureIds = new ArrayList<String>();
// -----------------------------------------------------------------------------------------------------------------------------
// STEP 1. Sign document with Image Signature
// -----------------------------------------------------------------------------------------------------------------------------
Signature signature = new Signature(filePath);
{
ImageSignOptions signOptions = new ImageSignOptions(Constants.ImageHandwrite);
signOptions.setVerticalAlignment(VerticalAlignment.Top);
signOptions.setHorizontalAlignment(HorizontalAlignment.Center);
signOptions.setWidth(100);
signOptions.setHeight(40);
signOptions.setMargin(new Padding(20));
// sign document to file
SignResult signResult = signature.sign(outputFilePath, signOptions);
System.out.print("\nDocument "+filePath+" was signed with following signatures:");
for (BaseSignature temp : signResult.getSucceeded())
{
// collect newly created signature' Id
signatureIds.add(temp.getSignatureId());
System.out.print("Signature : "+temp.getSignatureType()+" Id:"+temp.getSignatureId()+", Location: "+temp.getLeft()+"x"+temp.getTop()+". Size: "+temp.getWidth()+"x"+temp.getHeight());
}
}
// ----------------------------------------------------------------------------------------
```
<Overlap Ratio: 0.9903091832025842>

---

--- 277 --
Question ID: 82bec5a1f0dc3e2a23dce5c3e4d2867ee3bec7eb
Original Code:
```
@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)
public class CloneSnapshotIT extends AbstractSnapshotIntegTestCase {

    public void testShardClone() throws Exception {
        internalCluster().startMasterOnlyNode();
        internalCluster().startDataOnlyNode();
        final String repoName = "repo-name";
        final Path repoPath = randomRepoPath();
        createRepository(repoName, "fs", repoPath);

        final boolean useBwCFormat = randomBoolean();
        if (useBwCFormat) {
            initWithSnapshotVersion(repoName, repoPath, SnapshotsService.OLD_SNAPSHOT_FORMAT);
            // Re-create repo to clear repository data cache
            assertAcked(client().admin().cluster().prepareDeleteRepository(repoName).get());
            createRepository(repoName, "fs", repoPath);
        }

        final String indexName = "test-index";
        createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));
        final String sourceSnapshot = "source-snapshot";
        final SnapshotInfo sourceSnapshotInfo = createFullSnapshot(repoName, sourceSnapshot);

        final BlobStoreRepository repository =
                (BlobStoreRepository) internalCluster().getCurrentMasterNodeInstance(RepositoriesService.class).repository(repoName);
        final RepositoryData repositoryData = getRepositoryData(repoName);
        final IndexId indexId = repositoryData.resolveIndexId(indexName);
        final int shardId = 0;
        final RepositoryShardId repositoryShardId = new RepositoryShardId(indexId, shardId);

        final SnapshotId targetSnapshotId = new SnapshotId("target-snapshot", UUIDs.randomBase64UUID(random()));

        final String currentShardGen;
        if (useBwCFormat) {
            currentShardGen = null;
        } else {
            currentShardGen = repositoryData.shardGenerations().getShardGen(indexId, shardId);
        }
        final String newShardGeneration = PlainActionFuture.get(f -> repository.cloneShardSnapshot(
                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, currentShardGen, f));

        if (useBwCFormat) {
            final long gen = Long.parseLong(newShardGeneration);
            assertEquals(gen, 1L); // Initial snapshot brought it to 0, clone increments it to 1
        }

        final BlobStoreIndexShardSnapshot targetShardSnapshot = readShardSnapshot(repository, repositoryShardId, targetSnapshotId);
        final BlobStoreIndexShardSnapshot sourceShardSnapshot =
                readShardSnapshot(repository, repositoryShardId, sourceSnapshotInfo.snapshotId());
        assertThat(targetShardSnapshot.incrementalFileCount(), is(0));
        final List<BlobStoreIndexShardSnapshot.FileInfo> sourceFiles = sourceShardSnapshot.indexFiles();
        final List<BlobStoreIndexShardSnapshot.FileInfo> targetFiles = targetShardSnapshot.indexFiles();
        final int fileCount = sourceFiles.size();
        assertEquals(fileCount, targetFiles.size());
        for (int i = 0; i < fileCount; i++) {
            assertTrue(sourceFiles.get(i).isSame(targetFiles.get(i)));
        }
        final BlobStoreIndexShardSnapshots shardMetadata = readShardGeneration(repository, repositoryShardId, newShardGeneration);
        final List<SnapshotFiles> snapshotFiles = shardMetadata.snapshots();
        assertThat(snapshotFiles, hasSize(2));
        assertTrue(snapshotFiles.get(0).isSame(snapshotFiles.get(1)));

        // verify that repeated cloning is idempotent
        final String newShardGeneration2 = PlainActionFuture.get(f -> repository.cloneShardSnapshot(
                sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, newShardGeneration, f));
        assertEquals(newShardGeneration, newShardGeneration2);
    }

    private static BlobStoreIndexShardSnapshots readShardGeneration(BlobStoreRepository repository, RepositoryShardId repositoryShardId,
                                                                    String generation) {
        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,
                () -> BlobStoreRepository.INDEX_SHARD_SNAPSHOTS_FORMAT.read(repository.shardContainer(repositoryShardId.index(),
                        repositoryShardId.shardId()), generation, NamedXContentRegistry.EMPTY))));
    }

    private static BlobStoreIndexShardSnapshot readShardSnapshot(BlobStoreRepository repository, RepositoryShardId repositoryShardId,
                                                                 SnapshotId snapshotId) {
        return PlainActionFuture.get(f -> repository.threadPool().generic().execute(ActionRunnable.supply(f,
                () -> repository.loadShardSnapshot(repository.shardContainer(repositoryShardId.index(), repositoryShardId.shardId()),
                        snapshotId))));
    }
}
```


Overlapping Code:
```
@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, numDataNodes = 0)
public class CloneSnapshotIT extends AbstractSnapshotIntegTestCase {
public void testShardClone() throws Exception {
internalCluster().startMasterOnlyNode();
internalCluster().startDataOnlyNode();
final String repoName = "repo-name";
final Path repoPath = randomRepoPath();
createRepository(repoName, "fs", repoPath);
final boolean useBwCFormat = randomBoolean();
if (useBwCFormat) {
initWithSnapshotVersion(repoName, repoPath, SnapshotsService.OLD_SNAPSHOT_FORMAT);
// Re-create repo to clear repository data cache
assertAcked(client().admin().cluster().prepareDeleteRepository(repoName).get());
createRepository(repoName, "fs", repoPath);
}
final String indexName = "test-index";
createIndexWithRandomDocs(indexName, randomIntBetween(5, 10));
final String sourceSnapshot = "source-snapshot";
final SnapshotInfo sourceSnapshotInfo = createFullSnapshot(repoName, sourceSnapshot);
final BlobStoreRepository repository =
(BlobStoreRepository) internalCluster().getCurrentMasterNodeInstance(RepositoriesService.class).repository(repoName);
final RepositoryData repositoryData = getRepositoryData(repoName);
final IndexId indexId = repositoryData.resolveIndexId(indexName);
final int shardId = 0;
final RepositoryShardId repositoryShardId = new RepositoryShardId(indexId, shardId);
final SnapshotId targetSnapshotId = new SnapshotId("target-snapshot", UUIDs.randomBase64UUID(random()));
final String currentShardGen;
if (useBwCFormat) {
currentShardGen = null;
} else {
currentShardGen = repositoryData.shardGenerations().getShardGen(indexId, shardId);
}
final String newShardGeneration = PlainActionFuture.get(f -> repository.cloneShardSnapshot(
sourceSnapshotInfo.snapshotId(), targetSnapshotId, repositoryShardId, currentShardGen, f));
if (useBwCFormat) {
final long gen = Long.parseLong(newShardGeneration);
assertEquals(gen, 1L); // Initial snapshot brought it to 0, clone increments it to 1
}
final BlobStoreIndexShardSnapshot targetShardSnapshot = readShardSnapshot(repository, repositoryShardId, targetSnapshotId);
final BlobStoreIndexShardSnapshot sourc
```
<Overlap Ratio: 0.9995333644423705>

---

--- 278 --
Question ID: 8770b3d50c88f111d70c40d5262980e3ed5a9828
Original Code:
```
public class ListCompare implements Comparator<List<Integer>> {
    @Override
    public int compare(List<Integer> left, List<Integer> right) {
        int result = 0;
        if (left.size() != right.size()) {
            result = left.size() < right.size() ? -1 : -2;
        } else {
            for (int i = 0; i < left.size(); i++) {
                int com = left.get(i).compareTo(right.get(i));
                if (com != 0) {
                    result = com > 0 ? 1 : 2;
                } else {
                    result = 0;
                }
            }
        }
        return result;
    }
}
```


Overlapping Code:
```
public class ListCompare implements Comparator<List<Integer>> {
@Override
public int compare(List<Integer> left, List<Integer> right) {
int result = 0;
if (left.size() != right.size()) {
result = left.size() < right.size() ? -1 : -2;
} else {
for (int i = 0; i < left.size(); i++) {
int com = left.get(i).compareTo(right.get(i));
if (com != 0) {
result = com > 0 ? 1 : 2
```
<Overlap Ratio: 0.8872901678657075>

---

--- 279 --
Question ID: bca67ca38011d8655f7e8fd1f194db91efc352d6
Original Code:
```
public class NameParserGBIFTimeoutTest {

  @Test
  public void timeoutLongNames() throws Exception {
    final int timeout = 10;
    final int extra = 250;

    NameParser parser = new NameParserGBIF(timeout);
    StopWatch watch = new StopWatch();
    // warm up parser
    try {
      parser.parse("Abies", Rank.GENUS);
    } catch (UnparsableNameException ex) {
      // too short on your machine? ignore
    }

    // this name takes 13993ms on a new macbook pro !!!
    String name = "Desmarestia ligulata subsp. muelleri (M.E.Ramirez, A.F.Peters, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang & F.C.Küpper & van Reine, 2014) S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.Küpper, van Reine, S.S.Y. Wong, A.H.Y. Ngan, Riggs, J.L.L. Teng, A.F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.Küpper & van Reine, 2014";
    watch.start();
    try {
      parser.parse(name);
      fail("Expected to be unparsable, but only took " + watch.getTime() + "ms");

    } catch (UnparsableNameException ex) {

      final long duration = watch.getTime();
      System.out.println("Parsing took " + duration + "ms");

      // make sure no further parser threads are running. Give the JVM a few milliseconds to interrupt the task
      Thread.sleep(extra);

      Set<Thread> threads = Thread.getAllStackTraces().keySet();
      for (Thread t : threads) {
        if (t.getName().startsWith(NameParserGBIF.THREAD_NAME)) {
          System.out.println(t.getName() + "  -->  " + t.getState());
          assertFalse("Running parser thread detected", t.getState() == Thread.State.RUNNABLE);
        }
      }
    }
  }

}
```


Overlapping Code:
```
blic class NameParserGBIFTimeoutTest {
@Test
public void timeoutLongNames() throws Exception {
final int timeout = 10;
final int extra = 250;
NameParser parser = new NameParserGBIF(timeout);
StopWatch watch = new StopWatch();
// warm up parser
try {
parser.parse("Abies", Rank.GENUS);
} catch (UnparsableNameException ex) {
// too short on your machine? ignore
}
// this name takes 13993ms on a new macbook pro !!!
String name = "Desmarestia ligulata subsp. muelleri (M.E.Ramirez, A.F.PeterYang, A.F.Peters, E.C.Yang & F.C.Küpper & van Reine, 201F.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.Küpper, van ReinF.Peters, E.C.Yang, A.F.Peters, E.C.Yang, F.C.Küpper & van Reine, 2014";
watch.start();
try {
parser.parse(name);
fail("Expected to be unparsable, but only took " + watch.getTime() + "ms");
} catch (UnparsableNameException ex) {
final long duration = watch.getTime();
System.out.println("Parsing took " + duration + "ms");
// make sure no further parser threads are running. Give the JVM a few milliseconds to interrupt the task
Thread.sleep(extra);
Set<Thread> threads = Thread.getAllStackTraces().keySet();
for (Thread t : threads) {
if (t.getName().startsWith(NameParserGBIF.THREAD_NAME)) {
System.out.println(t.getName() + " --> " + t.getState());
assertFalse("Running parser thread detected", t.getState() == Thread.State.RUNNABL
```
<Overlap Ratio: 0.8805774278215223>

---

--- 280 --
Question ID: dee61b6a7c414eb7acd0915b4ad64bc318ba6e66
Original Code:
```
public class FindItemById extends BaseAction {

    public FindItemById(int key, String name) {
        super(key, name);
    }

    @Override
    public void execute(Input input, Tracker tracker) {
        String id = input.ask("Please, enter item id: ");
        Item item = tracker.findById(id);
        System.out.println("-------------------------------------------------");
        System.out.println("Id: " + item.getId());
        System.out.println("Name: " + item.getName());
        System.out.println("Description: " + item.getDescription());
        System.out.println("-------------------------------------------------");
    }
}
```


Overlapping Code:
```
public class FindItemById extends BaseAction {
public FindItemById(int key, String name) {
super(key, name);
}
@Override
public void execute(Input input, Tracker tracker) {
String id = input.ask("Please, enter item id: ");
Item item = tracker.findById(id);
System.out.println("-------------------------------------------------");
System.out.println("Id: " + item.getId());
System.out.println("Name: " + item.getName());
System.out.println("Description: " + item.getDescription());
System.out.println("-------------------------------------------------");
}
}
```
<Overlap Ratio: 1.0>

---

--- 281 --
Question ID: 4b8b58342947a1f429e602b2b205acc6b8ac53f5
Original Code:
```
@Service
public class FileCateServiceImpl implements FileCateService{
	
	@Autowired
	private BaseDao<FileCate> baseDao;

	@Override
	public List<FileCate> getFileCates() {
		// TODO Auto-generated method stub
		String [] sortColum=new String[1];
		sortColum[0]="cateNo";
		return baseDao.selectByCriteria("filecates",baseDao.createCriteria().order(sortColum,"asc"), FileCate.class);
		
	}

	@Override
	public FileCate getFileCate(String id) {
		// TODO Auto-generated method stub
		return baseDao.selectById("filecates", "id", id, FileCate.class);
	}

	@Override
	public List<FileCate> getFileCatesByParentId(String parentId) {
		// TODO Auto-generated method stub
		String [] sortColum=new String[1];
		sortColum[0]="cateNo";
		return baseDao.selectByCriteria("filecates",baseDao.createCriteria().eq("parentId", parentId).order(sortColum,"asc"), FileCate.class);
	
	}
	
	@Override
	public List<FileCate>  getchildCatesList(){
		String [] sortColum=new String[1];
		sortColum[0]="cateNo";
		return baseDao.selectByCriteria("filecates",baseDao.createCriteria().not().eq("parentId", "0").order(sortColum,"asc"), FileCate.class);
	}

	@Override
	public void saveFileCate(FileCate fileCate) {
		// TODO Auto-generated method stub
		UUID uuid=UUID.randomUUID();
		fileCate.setId(uuid.toString().replace("-", ""));
		baseDao.save("filecates", "id", fileCate);
	}
	
	
	@Override
	public void removeFileCate(String id){
		baseDao.removeById("filecates", "id", id);
	}
	

}
```


Overlapping Code:
```
mplements FileCateService{

@Autowired
private BaseDao<FileCate> baseDao;
@Override
public List<FileCate> getFileCates() {
// TODO Auto-generated method stub
String [] sortColum=new String[1];
sortColum[0]="cateNo";
return baseDao.selectByCriteria("filecates",baseDao.createCriteria().order(sortColum,"asc"), FileCate.class);

}
@Override
public FileCate getFileCate(String id) {
// TODO Auto-generated method stub
return baseDao.selectById("filecates", "id", id, FileCate.class);
}
@Override
public List<FileCate> getFileCatesByParentId(String parentId) {
// TODO Auto-generated method stub
String [] sortColum=new String[1];
sortColum[0]="cateNo";
return baseDao.selectByCriteria("filecates",baseDao.createCriteria().eq("parentId", parentId).order(sortColum,"asc"), FileCate.class);

}

@Override
public List<FileCate> getchildCatesList(){
String [] sortColum=new String[1];
sortColum[0]="cateNo";
return baseDao.selectByCriteria("filecates",baseDao.createCriteria().not().eq("parentId", "0").order(sortColum,"asc"), FileCate.class);
}
@Override
public void saveFileCate(FileCate fileCate) {
// TODO Auto-generated method stub
UUID uuid=UUID.randomUUID();
fileCate.setId(uuid.toString().replace("-", ""));
baseDao.save("filecates", "id", fileCate);
}


@Override
public void removeFileCate(String id){
baseDao.removeById("filecates", "id", id);
}


```
<Overlap Ratio: 0.9684361549497847>

---

--- 282 --
Question ID: 26d24c2f3114b2a095a5333b2fc0cf5e763f4686
Original Code:
```
public class DescribeClusterTemplateResponseUnmarshaller {

	public static DescribeClusterTemplateResponse unmarshall(DescribeClusterTemplateResponse describeClusterTemplateResponse, UnmarshallerContext _ctx) {
		
		describeClusterTemplateResponse.setRequestId(_ctx.stringValue("DescribeClusterTemplateResponse.RequestId"));

		TemplateInfo templateInfo = new TemplateInfo();
		templateInfo.setId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.Id"));
		templateInfo.setTemplateName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.TemplateName"));
		templateInfo.setEmrVer(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.EmrVer"));
		templateInfo.setLogEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.LogEnable"));
		templateInfo.setLogPath(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.LogPath"));
		templateInfo.setUserId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.UserId"));
		templateInfo.setUserDefinedEmrEcsRole(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.UserDefinedEmrEcsRole"));
		templateInfo.setMasterNodeTotal(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.MasterNodeTotal"));
		templateInfo.setVpcId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.VpcId"));
		templateInfo.setVSwitchId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.VSwitchId"));
		templateInfo.setNetType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.NetType"));
		templateInfo.setIoOptimized(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.IoOptimized"));
		templateInfo.setInstanceGeneration(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.InstanceGeneration"));
		templateInfo.setHighAvailabilityEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.HighAvailabilityEnable"));
		templateInfo.setEasEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.EasEnable"));
		templateInfo.setGmtCreate(_ctx.longValue("DescribeClusterTemplateResponse.TemplateInfo.GmtCreate"));
		templateInfo.setGmtModified(_ctx.longValue("DescribeClusterTemplateResponse.TemplateInfo.GmtModified"));
		templateInfo.setZoneId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ZoneId"));
		templateInfo.setClusterType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ClusterType"));
		templateInfo.setSecurityGroupId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupId"));
		templateInfo.setSecurityGroupName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.SecurityGroupName"));
		templateInfo.setConfigurations(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.Configurations"));
		templateInfo.setAllowNotebook(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.AllowNotebook"));
		templateInfo.setCreateSource(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.CreateSource"));
		templateInfo.setUseLocalMetaDb(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.UseLocalMetaDb"));
		templateInfo.setSshEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.SshEnable"));
		templateInfo.setIsOpenPublicIp(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.IsOpenPublicIp"));
		templateInfo.setDepositType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.DepositType"));
		templateInfo.setMachineType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.MachineType"));
		templateInfo.setUseCustomHiveMetaDb(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.UseCustomHiveMetaDb"));
		templateInfo.setInitCustomHiveMetaDb(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.InitCustomHiveMetaDb"));
		templateInfo.setKeyPairName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.KeyPairName"));
		templateInfo.setMasterPwd(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.MasterPwd"));
		templateInfo.setMetaStoreType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.MetaStoreType"));
		templateInfo.setMetaStoreConf(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.MetaStoreConf"));

		List<String> softwareInfoList = new ArrayList<String>();
		for (int i = 0; i < _ctx.lengthValue("DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList.Length"); i++) {
			softwareInfoList.add(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.SoftwareInfoList["+ i +"]"));
		}
		templateInfo.setSoftwareInfoList(softwareInfoList);

		List<BootstrapAction> bootstrapActionList = new ArrayList<BootstrapAction>();
		for (int i = 0; i < _ctx.lengthValue("DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList.Length"); i++) {
			BootstrapAction bootstrapAction = new BootstrapAction();
			bootstrapAction.setName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList["+ i +"].Name"));
			bootstrapAction.setPath(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList["+ i +"].Path"));
			bootstrapAction.setArg(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.BootstrapActionList["+ i +"].Arg"));

			bootstrapActionList.add(bootstrapAction);
		}
		templateInfo.setBootstrapActionList(bootstrapActionList);

		List<HostGroup> hostGroupList = new ArrayList<HostGroup>();
		for (int i = 0; i < _ctx.lengthValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList.Length"); i++) {
			HostGroup hostGroup = new HostGroup();
			hostGroup.setHostGroupId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].HostGroupId"));
			hostGroup.setHostGroupName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].HostGroupName"));
			hostGroup.setHostGroupType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].HostGroupType"));
			hostGroup.setChargeType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].ChargeType"));
			hostGroup.setPeriod(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].Period"));
			hostGroup.setNodeCount(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].NodeCount"));
			hostGroup.setInstanceType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].InstanceType"));
			hostGroup.setDiskType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].DiskType"));
			hostGroup.setDiskCapacity(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].DiskCapacity"));
			hostGroup.setDiskCount(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].DiskCount"));
			hostGroup.setSysDiskType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].SysDiskType"));
			hostGroup.setSysDiskCapacity(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].SysDiskCapacity"));
			hostGroup.setMultiInstanceTypes(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.HostGroupList["+ i +"].MultiInstanceTypes"));

			hostGroupList.add(hostGroup);
		}
		templateInfo.setHostGroupList(hostGroupList);

		List<Config> configList = new ArrayList<Config>();
		for (int i = 0; i < _ctx.lengthValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList.Length"); i++) {
			Config config = new Config();
			config.setServiceName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].ServiceName"));
			config.setFileName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].FileName"));
			config.setConfigKey(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].ConfigKey"));
			config.setConfigValue(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].ConfigValue"));
			config.setEncrypt(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].Encrypt"));
			config.setReplace(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ConfigList["+ i +"].Replace"));

			configList.add(config);
		}
		templateInfo.setConfigList(configList);

		List<Tag> tags = new ArrayList<Tag>();
		for (int i = 0; i < _ctx.lengthValue("DescribeClusterTemplateResponse.TemplateInfo.Tags.Length"); i++) {
			Tag tag = new Tag();
			tag.setTagKey(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.Tags["+ i +"].TagKey"));
			tag.setTagValue(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.Tags["+ i +"].TagValue"));

			tags.add(tag);
		}
		templateInfo.setTags(tags);
		describeClusterTemplateResponse.setTemplateInfo(templateInfo);
	 
	 	return describeClusterTemplateResponse;
	}
}
```


Overlapping Code:
```
cribeClusterTemplateResponseUnmarshaller {
public static DescribeClusterTemplateResponse unmarshall(DescribeClusterTemplateResponse describeClusterTemplateResponse, UnmarshallerContext _ctx) {

describeClusterTemplateResponse.setRequestId(_ctx.stringValue("DescribeClusterTemplateResponse.RequestId"));
TemplateInfo templateInfo = new TemplateInfo();
templateInfo.setId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.Id"));
templateInfo.setTemplateName(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.TemplateName"));
templateInfo.setEmrVer(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.EmrVer"));
templateInfo.setLogEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.LogEnable"));
templateInfo.setLogPath(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.LogPath"));
templateInfo.setUserId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.UserId"));
templateInfo.setUserDefinedEmrEcsRole(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.UserDefinedEmrEcsRole"));
templateInfo.setMasterNodeTotal(_ctx.integerValue("DescribeClusterTemplateResponse.TemplateInfo.MasterNodeTotal"));
templateInfo.setVpcId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.VpcId"));
templateInfo.setVSwitchId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.VSwitchId"));
templateInfo.setNetType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.NetType"));
templateInfo.setIoOptimized(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.IoOptimized"));
templateInfo.setInstanceGeneration(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.InstanceGeneration"));
templateInfo.setHighAvailabilityEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.HighAvailabilityEnable"));
templateInfo.setEasEnable(_ctx.booleanValue("DescribeClusterTemplateResponse.TemplateInfo.EasEnable"));
templateInfo.setGmtCreate(_ctx.longValue("DescribeClusterTemplateResponse.TemplateInfo.GmtCreate"));
templateInfo.setGmtModified(_ctx.longValue("DescribeClusterTemplateResponse.TemplateInfo.GmtModified"));
templateInfo.setZoneId(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ZoneId"));
templateInfo.setClusterType(_ctx.stringValue("DescribeClusterTemplateResponse.TemplateInfo.ClusterType"));
templateInfo.setSecurityGroupId(_ctx.stri
```
<Overlap Ratio: 0.9888751545117429>

---

--- 283 --
Question ID: f4a2369c27b9baa3be59d7c514a0c1d723b2ba58
Original Code:
```
public class StarSystemSpawner implements WorldGenerator.WorldSpawner {
	@Override
	public float getWeight() {
		return 1;
	}

	@Override
	public RenderLevel getSpawnLevel() {
		return RenderLevel.INTERSTELLAR;
	}

	@Override
	public void spawn(SpaceObject center, PVector pos) {
		createSystem(pos);
	}

	public static void createSystem(PVector pos) {
		Star star = createStar(pos);

		// Generate terrestrial planets
		int planetCt = (int)v.random(1, 8);
		for(int i = 0; i <= planetCt; i++) {
			float distance = v.random(.3F, 4) * AU_DISTANCE;
			Planet planet = createPlanet(star.getPosition().add(PVector.random2D().mult(distance)));
			orbit(star, planet, 0);
		}

		// Generate gas giants
		int gasGiantCt = (int)v.random(2);
		for(int i = 0; i <= gasGiantCt; i++) {
			float distance = v.random(3, 6) * AU_DISTANCE;
			Planet planet = createGasGiant(star.getPosition().add(PVector.random2D().mult(distance)));
			orbit(star, planet, 0);
		}
	}

	public static Star createStar(PVector pos) {
		float temperature = (float)Math.exp(v.random((float)Math.log(2400), (float)Math.log(50000))); //TODO: fiddle

		float power = pow(10, v.random(29f, 31.5f));
		float mass = v.random(0.8f, 4) * power;
		//		float radius = pow(10, v.random(.7F, 2));
//		float radius = pow(10, v.random(-1f, 1f)) * SUN_RADIUS;
		float density = pow(10, v.random(-.5f, .5f)) * 1408; // Sun's density
		return register(new Star(
				Resources.generateString("star"),
				mass, // Mass
				density, // Density
				temperature,
				pos, // Position
				new PVector() // Velocity
		));
	}

	public static Planet createPlanet(PVector pos) {
		float mass = pow(10, v.random(23, 25));
		float density = v.random(3000, 6000);
		TerrestrialPlanet planet = register(new TerrestrialPlanet(
				Resources.generateString("planet"),
				mass,                    // Mass
				density,                // Density
				pos,                    // Coords
				new PVector(),        // Velocity
				randomPlanetColor()    // Color
		));
		//		for(Feature feature : planet.getTerrain().getFeatures()) {
		//			feature.setPlanet(planet);
		//		}
		createMoons(planet, (int)v.random(3), .3F * LUNAR_DISTANCE, 2 * LUNAR_DISTANCE);
		return planet;
	}

	public static GasGiant createGasGiant(PVector pos) {
		float mass = pow(10, v.random(26, 28));
		float density = v.random(800, 1500);
		GasGiant planet = register(new GasGiant(
				Resources.generateString("gas_giant"),
				mass, // Mass
				density, // Radius
				pos, // Position
				new PVector(), // Velocity
				randomPlanetColor() // Color
		));
		createMoons(planet, (int)v.random(3, 6), 1 * LUNAR_DISTANCE, 20 * LUNAR_DISTANCE);
		return planet;
	}

	public static List<Moon> createMoons(Planet planet, int count, float minDist, float maxDist) {
		List<Moon> moons = new ArrayList<>();
		for(int i = 0; i < count; i++) {
			float distance = v.random(minDist, maxDist);
			Moon moon = createMoon(planet, distance);
			orbit(planet, moon, 0);
			moons.add(moon);
		}
		moons.sort(Comparator.comparingDouble(Moon::getOrbitDistance));
		for(int i = 0; i < moons.size(); i++) {
			moons.get(i).setName((i + 1) + " " + planet.getName());
		}
		return moons;
	}

	public static Moon createMoon(Planet planet, float distance) {
		PVector pos = planet.getPosition().add(PVector.random2D().mult(planet.getRadius() + distance));
		float mass = pow(10, v.random(18, 23));
		float density = v.random(2500, 4000);
		return register(new Moon(
				planet,
				Resources.generateString("moon"),
				mass, // Mass
				density,   // Density
				pos,  // Coords
				new PVector(),  // Velocity
				randomPlanetColor() // Color
		));
	}
}
```


Overlapping Code:
```
wner implements WorldGenerator.WorldSpawner {
@Override
public float getWeight() {
return 1;
}
@Override
public RenderLevel getSpawnLevel() {
return RenderLevel.INTERSTELLAR;
}
@Override
public void spawn(SpaceObject center, PVector pos) {
createSystem(pos);
}
public static void createSystem(PVector pos) {
Star star = createStar(pos);
// Generate terrestrial planets
int planetCt = (int)v.random(1, 8);
for(int i = 0; i <= planetCt; i++) {
float distance = v.random(.3F, 4) * AU_DISTANCE;
Planet planet = createPlanet(star.getPosition().add(PVector.random2D().mult(distance)));
orbit(star, planet, 0);
}
// Generate gas giants
int gasGiantCt = (int)v.random(2);
for(int i = 0; i <= gasGiantCt; i++) {
float distance = v.random(3, 6) * AU_DISTANCE;
Planet planet = createGasGiant(star.getPosition().add(PVector.random2D().mult(distance)));
orbit(star, planet, 0);
}
}
public static Star createStar(PVector pos) {
float temperature = (float)Math.exp(v.random((float)Math.log(2400), (float)Math.log(50000))); //TODO: fiddle
float power = pow(10, v.random(29f, 31.5f));
float mass = v.random(0.8f, 4) * power;
// float radius = pow(10, v.random(.7F, 2));
// float radius = pow(10, v.random(-1f, 1f)) * SUN_RADIUS;
float density = pow(10, v.random(-.5f, .5f)) * 1408; // Sun's density
return register(new Star(
Resources.generateString("star"),
mass, // Mass
density, // Density
temperature,
pos, // Position
new PVector() // Velocity
));
}
public static Planet createPlanet(PVector pos) {
float mass = pow(10, v.random(23, 25));
float density = v.random(3000, 6000);
TerrestrialPlanet planet = register(new TerrestrialPlanet(
Resources.generateString("planet"),
mass, // Mass
density, // Density
pos, // Coords
new PVector(), // Velocity
randomPlanetColor() // Color
));
// for(Feature feature : planet.getTerrain().getFeatures()) {
// feature.setPlanet(planet);
// }
createMoons(planet, (int)v.random(3), .3F * LUNAR_DISTANCE, 2 * LUNAR_DISTANCE);
return planet;
}
public static GasGiant createGasGiant(PVector pos) {
float mass = pow(10, v.random(26, 28));
float density = v.random(800, 1500);
GasGiant planet = register(new GasGiant(
Resources.generateString("gas_giant"),
mass, // Mass
density, // Radius
pos, // Pos
```
<Overlap Ratio: 0.9827204253433761>

---

--- 284 --
Question ID: 7c396a4665c4e1f18bdb7327881232a5e943c71b
Original Code:
```
public class NavListCell extends ListCell<Item> {
    CellController CC;

    public NavListCell(EventHandler navEvent, String FXML) {
        super();

        this.CC = new CellController(navEvent, FXML);
    }

    @Override
    public void updateItem(Item item, boolean empty) {
        super.updateItem(item, empty);
//        this.item = item;

        if (empty) {
            setGraphic(null);
        } else {
            CC.labelID.setText(item!=null ? " " + item.itemID + " " : "<null>");
            CC.labelName.setText(item!=null ? item.itemName : "<null>");
//            System.out.println("ID: " + item.itemID);
            CC.button.setId(item.itemID);
            if (item.progress <= 0) {
                if (item.progress < 0) {
                    CC.progress.setText("ERROR");
                }
            } else if (item.crawlSuccess) {
                CC.progress.setText(Integer.toString(item.total));
                CC.percent.setText(item.progress*100/item.pages + "%");
            } else{
                CC.progress.setText(item.progress + "/" + item.pages);
                CC.percent.setText(item.progress*100/item.pages + "%");
            }
            CC.pb.setProgress((double) item.progress/item.pages);

            setGraphic(CC.hbox);
        }
    }

//    @Override
//    protected void updateItem(AppBean app, boolean empty) {
//        super.updateItem(app, empty);
//        if (app == null) {
//            setText(null);
//            setGraphic(null);
//            return;
//        }
//        if (null == itemRoot) {
//            try {
//                itemRoot = FXMLLoader.load(getClass().getResource(("fxml/appList_item.fxml")));
//            } catch (IOException e) {
//                throw new RuntimeException(e);
//            }
//            label_AppName = (Label) itemRoot.lookup("#item_Label_AppName");
//            imgv_AppIcon = (ImageView) itemRoot.lookup("#item_ImageView_AppIcon");
//            itemRoot.setOnMouseClicked(clickHandler);
//        }
//        //  set user data. like android's setTag(Object).
//        itemRoot.setUserData(app);
//        label_AppName.setText(app.name);
//        imgv_AppIcon.setImage(new Image(getClass().getResource("img/icon_64.png").toExternalForm()));
//        setGraphic(itemRoot);
//    }
}
```


Overlapping Code:
```
tCell<Item> {
CellController CC;
public NavListCell(EventHandler navEvent, String FXML) {
super();
this.CC = new CellController(navEvent, FXML);
}
@Override
public void updateItem(Item item, boolean empty) {
super.updateItem(item, empty);
// this.item = item;
if (empty) {
setGraphic(null);
} else {
CC.labelID.setText(item!=null ? " " + item.itemID + " " : "<null>");
CC.labelName.setText(item!=null ? item.itemName : "<null>");
// System.out.println("ID: " + item.itemID);
CC.button.setId(item.itemID);
if (item.progress <= 0) {
if (item.progress < 0) {
CC.progress.setText("ERROR");
}
} else if (item.crawlSuccess) {
CC.progress.setText(Integer.toString(item.total));
CC.percent.setText(item.progress*100/item.pages + "%");
} else{
CC.progress.setText(item.progress + "/" + item.pages);
CC.percent.setText(item.progress*100/item.pages + "%");
}
CC.pb.setProgress((double) item.progress/item.pages);
setGraphic(CC.hbox);
}
}
// @Override
// protected void updateItem(AppBean app, boolean empty) {
// super.updateItem(app, empty);
// if (app == null) {
// setText(null);
// setGraphic(null);
// return;
// }
// if (null == itemRoot) {
// try {
// itemRoot = FXMLLoader.load(getClass().getResource(("fxml/appList_item.fxml")));
// } catch (IOException e) {
// throw new RuntimeException(e);
// }
// label_AppName = (Label) itemRoot.lookup("#item_Label_AppName");
// imgv_AppIcon = (ImageView) itemRoot.lookup("#item_ImageView_AppIcon");
// itemRoot.setOnMouseClicked(clickHandler);
// }
// // set user data. like android's setTag(Object).
// itemRoot.setUserData(app);
// label_AppName.setText(app.name);
// imgv_AppIcon.setImage(new Image(getClass().getResource("img/icon_64.png").toExternalForm()))
```
<Overlap Ratio: 0.9609949123798757>

---

--- 285 --
Question ID: ff680b66ce6919d62f4c73c63911436bef7a4a17
Original Code:
```
public class DecimalToHex {
  public static String toHex(int number) {
    char[] hexTable = {
      '0', '1', '2', '3',
      '4', '5', '6', '7',
      '8', '9', 'a', 'b',
      'c', 'd', 'e', 'f'
    };

    boolean isNegative = number < 0;
    number = Math.abs(number);
    StringBuilder result = new StringBuilder();
    do {
      result.append(hexTable[number % 16]);
      number /= 16;
    } while (number != 0);
    return isNegative ? result.append("-").reverse().toString() : result.reverse().toString();
  }
}
```


Overlapping Code:
```
ecimalToHex {
public static String toHex(int number) {
char[] hexTable = {
'0', '1', '2', '3',
'4', '5', '6', '7',
'8', '9', 'a', 'b',
'c', 'd', 'e', 'f'
};
boolean isNegative = number < 0;
number = Math.abs(number);
StringBuilder result = new StringBuilder();
do {
result.append(hexTable[number % 16]);
number /= 16;
} while (number != 0);
return isNegative ? result.append("-").reverse().toString() : result.
```
<Overlap Ratio: 0.9131403118040089>

---

--- 286 --
Question ID: 0d08bfd1af738f36d4c952a17268e0a01c77e0a3
Original Code:
```
public final class ConfigurationInfo {
    private final Map<String, String> settings;
    private final String name;
    private final String label;
    private final String description;
    private final String provider;
    private final String contents;

    ConfigurationInfo(Configuration config) {
        this.settings = config.getSettings();
        this.name = config.getName();
        this.label = config.getLabel();
        this.description = config.getDescription();
        this.provider = config.getProvider();
        this.contents = config.getContents();
    }

    private ConfigurationInfo(CompositeData cd) {
        this.settings = createMap(cd.get("settings"));
        this.name = (String) cd.get("name");
        this.label = (String) cd.get("label");
        this.description = (String) cd.get("description");
        this.provider = (String) cd.get("provider");
        this.contents = (String) cd.get("contents");
    }

    private static Map<String, String> createMap(Object o) {
        if (o instanceof TabularData) {
            TabularData td = (TabularData) o;
            Collection<?> values = td.values();
            Map<String, String> map = new HashMap<>(values.size());
            for (Object value : td.values()) {
                if (value instanceof CompositeData) {
                    CompositeData cdRow = (CompositeData) value;
                    Object k = cdRow.get("key");
                    Object v = cdRow.get("value");
                    if (k instanceof String && v instanceof String) {
                        map.put((String) k, (String) v);
                    }
                }
            }
            return Collections.unmodifiableMap(map);
        }
        return Collections.emptyMap();
    }

    /**
     * Returns the provider of the configuration associated with this
     * {@code ConfigurationInfo} (for example, {@code "OpenJDK"}).
     *
     * @return the provider, or {@code null} if doesn't exist
     *
     * @see Configuration#getProvider()
     */
    public String getProvider() {
        return provider;
    }

    /**
     * Returns the textual representation of the configuration associated with
     * this {@code ConfigurationInfo}, typically the contents of the
     * configuration file that was used to create the configuration.
     *
     * @return contents, or {@code null} if doesn't exist
     *
     * @see Configuration#getContents()
     */
    public String getContents() {
        return contents;
    }

    /**
     * Returns the settings for the configuration associated with this
     * {@code ConfigurationInfo}.
     *
     * @return a {@code Map} with settings, not {@code null}
     *
     * @see Configuration#getSettings()
     */
    public Map<String, String> getSettings() {
        return settings;
    }

    /**
     * Returns the human-readable name (for example, {@code "Continuous"} or {@code "Profiling"}) for
     * the configuration associated with this {@code ConfigurationInfo}
     *
     * @return the label, or {@code null} if doesn't exist
     *
     * @see Configuration#getLabel()
     */
    public String getLabel() {
        return label;
    }

    /**
     * Returns the name of the configuration associated with this
     * {@code ConfigurationInfo} (for example, {@code "default"}).
     *
     * @return the name, or {@code null} if doesn't exist
     *
     * @see Configuration#getLabel()
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a short sentence that describes the configuration associated with
     * this {@code ConfigurationInfo} (for example, {@code "Low
     * overhead configuration safe for continuous use in production
     * environments"}.
     *
     * @return the description, or {@code null} if doesn't exist
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a {@code ConfigurationInfo} object represented by the specified
     * {@code CompositeData}.
     * <p>
     * The following table shows the required attributes that the specified {@code CompositeData} must contain.
     * <blockquote>
     * <table class="striped">
     * <caption>Required names and types for CompositeData</caption>
     * <thead>
     * <tr>
     * <th scope="col" style="text-align:left">Name</th>
     * <th scope="col" style="text-align:left">Type</th>
     * </tr>
     * </thead>
     * <tbody>
     * <tr>
     * <th scope="row">name</th>
     * <td>{@code String}</td>
     * </tr>
     * <tr>
     * <th scope="row">label</th>
     * <td>{@code String}</td>
     * </tr>
     * <tr>
     * <th scope="row">description</th>
     * <td>{@code String}</td>
     * </tr>
     * <tr>
     * <th scope="row">provider</th>
     * <td>{@code String}</td>
     * </tr>
     * <tr>
     * <th scope="row">contents</th>
     * <td>{@code String}</td>
     * </tr>
     *
     * <tr>
     * <th scope="row">settings</th>
     * <td>{@code javax.management.openmbean.TabularData} with a
     * {@code TabularType} with the keys {@code "key"} and {@code "value"}, both
     * of the {@code String} type</td>
     * </tr>
     * </tbody>
     * </table>
     * </blockquote>
     *
     * @param cd {@code CompositeData} representing a {@code ConfigurationInfo}
     *
     * @throws IllegalArgumentException if {@code cd} does not represent a
     *         {@code ConfigurationInfo} with the required attributes
     *
     * @return a {@code ConfigurationInfo} object represented by {@code cd} if
     *         {@code cd} is not {@code null}, {@code null} otherwise
     */
    public static ConfigurationInfo from(CompositeData cd) {
        if (cd == null) {
            return null;
        }
        return new ConfigurationInfo(cd);
    }

    /**
     * Returns a description of the configuration that is associated with this
     * {@code ConfigurationInfo}.
     *
     * @return the description of the configuration, not {@code null}
     */
    @Override
    public String toString() {
        Stringifier s = new Stringifier();
        s.add("name", name);
        s.add("label", label);
        s.add("description", description);
        s.add("provider", provider);
        return s.toString();
    }
}
```


Overlapping Code:
```
blic final class ConfigurationInfo {
private final Map<String, String> settings;
private final String name;
private final String label;
private final String description;
private final String provider;
private final String contents;
ConfigurationInfo(Configuration config) {
this.settings = config.getSettings();
this.name = config.getName();
this.label = config.getLabel();
this.description = config.getDescription();
this.provider = config.getProvider();
this.contents = config.getContents();
}
private ConfigurationInfo(CompositeData cd) {
this.settings = createMap(cd.get("settings"));
this.name = (String) cd.get("name");
this.label = (String) cd.get("label");
this.description = (String) cd.get("description");
this.provider = (String) cd.get("provider");
this.contents = (String) cd.get("contents");
}
private static Map<String, String> createMap(Object o) {
if (o instanceof TabularData) {
TabularData td = (TabularData) o;
Collection<?> values = td.values();
Map<String, String> map = new HashMap<>(values.size());
for (Object value : td.values()) {
if (value instanceof CompositeData) {
CompositeData cdRow = (CompositeData) value;
Object k = cdRow.get("key");
Object v = cdRow.get("value");
if (k instanceof String && v instanceof String) {
map.put((String) k, (String) v);
}
}
}
return Collections.unmodifiableMap(map);
}
return Collections.emptyMap();
}
/**
* Returns the provider of the configuration associated with this
* {@code ConfigurationInfo} (for example, {@code "OpenJDK"}).
*
* @return the provider, or {@code null} if doesn't exist
*
* @see Configuration#getProvider()
*/
public String getProvider() {
return provider;
}
/**
* Returns the textual representation of the configuration associated with
* this {@code ConfigurationInfo}, typically the contents of the
* configuration file that was used to create the configuration.
*
* @return contents, or {@code null} if doesn't exist
*
* @see Configuration#getContents()
*/
public String getContents() {
return 
```
<Overlap Ratio: 0.9979869149471565>

---

--- 287 --
Question ID: fa1e8aba6a0f9bfdcf103880ce82d9bf370584dd
Original Code:
```
@Data
public class ArticlesDto implements Serializable {


    private int id;
    private String title;
    private String body;
    private Date created_at;
    private Date updated_at;
    private Integer topic_id;
    private Integer user_id;
    private String what_changed;

    private TopicsDto topic;
    private UsersDto user;


    public ArticlesDto() {
    }

    public ArticlesDto(int id, String title, String body, int topic_id, int user_id) {
        this.id = id;
        this.title = title;
        this.body = body;
        this.topic_id = topic_id;
        this.user_id = user_id;
    }

    public ArticlesDto(String title, String body, int topic_id, int user_id) {
        this.title = title;
        this.body = body;
        this.topic_id = topic_id;
        this.user_id = user_id;
    }

    public ArticlesDto(int id, String title, String body, int topic_id, int user_id, String what_changed) {
        this.id=id;
        this.title = title;
        this.body = body;
        this.topic_id = topic_id;
        this.user_id = user_id;
        this.what_changed = what_changed;

    }


    /**
     * ArticlesDto to Articles
     *
     * @return articles
     */
    public Articles convertToArticles() {
        Articles articles = new Articles();
        articles.setId(this.id);
        articles.setTitle(this.title);
        articles.setBody(this.body);
        articles.setUsersByUserId(new Users(this.user_id));
        articles.setTopicsByTopicId(new Topics(this.topic_id));
        // articles.setTopicId(this.topic_id);
        // articles.setUserId(this.user_id);
        articles.setWhatChanged(this.what_changed);
        return articles;
    }


    /**
     * ArticlesDto List to Articles List
     *
     * @param articlesDtoList
     * @return articlesList
     */
    public static List<Articles> convertToArticlesList(List<ArticlesDto> articlesDtoList) {

        List<Articles> articlesList = new ArrayList<>();

        for (ArticlesDto articlesDto : articlesDtoList) {
            articlesList.add(articlesDto.convertToArticles());
        }
        return articlesList;
    }


    /**
     * Articles to ArticlesDto
     *
     * @param articles
     * @return articlesDto
     */
    public static ArticlesDto convertFromArticles(Articles articles) {
        ArticlesDto articlesDto = new ArticlesDto();
        articlesDto.setId(articles.getId());
        articlesDto.setTitle(articles.getTitle());
        articlesDto.setBody(articles.getBody());
        articlesDto.setCreated_at(articles.getCreatedAt());
        articlesDto.setUpdated_at(articles.getUpdatedAt());
        articlesDto.setTopic_id(articles.getTopicsByTopicId().getId());
        articlesDto.setUser_id(articles.getUsersByUserId().getId());
        // articlesDto.setTopic_id(articles.getTopicId());
        //  articlesDto.setUser_id(articles.getUserId());
        articlesDto.setWhat_changed(articles.getWhatChanged());

        articlesDto.setUser(UsersDto.convertFromUsers(articles.getUsersByUserId()));
        articlesDto.setTopic(
                TopicsDto.convertFromTopics(articles.getTopicsByTopicId())
        );
        return articlesDto;

    }


    /**
     * Articles List to    ArticlesDto List
     *
     * @param articlesList
     * @return articlesDtoList
     */
    public static List<ArticlesDto> convertFromArticlesList(List<Articles> articlesList) {

        List<ArticlesDto> articlesDtoList = new ArrayList<>();

        for (Articles articles : articlesList) {
            ArticlesDto articlesDtoItem = convertFromArticles(articles);
            articlesDtoList.add(articlesDtoItem);
        }
        return articlesDtoList;
    }


}
```


Overlapping Code:
```
clesDto implements Serializable {
private int id;
private String title;
private String body;
private Date created_at;
private Date updated_at;
private Integer topic_id;
private Integer user_id;
private String what_changed;
private TopicsDto topic;
private UsersDto user;
public ArticlesDto() {
}
public ArticlesDto(int id, String title, String body, int topic_id, int user_id) {
this.id = id;
this.title = title;
this.body = body;
this.topic_id = topic_id;
this.user_id = user_id;
}
public ArticlesDto(String title, String body, int topic_id, int user_id) {
this.title = title;
this.body = body;
this.topic_id = topic_id;
this.user_id = user_id;
}
public ArticlesDto(int id, String title, String body, int topic_id, int user_id, String what_changed) {
this.id=id;
this.title = title;
this.body = body;
this.topic_id = topic_id;
this.user_id = user_id;
this.what_changed = what_changed;
}
/**
* ArticlesDto to Articles
*
* @return articles
*/
public Articles convertToArticles() {
Articles articles = new Articles();
articles.setId(this.id);
articles.setTitle(this.title);
articles.setBody(this.body);
articles.setUsersByUserId(new Users(this.user_id));
articles.setTopicsByTopicId(new Topics(this.topic_id));
// articles.setTopicId(this.topic_id);
// articles.setUserId(this.user_id);
articles.setWhatChanged(this.what_changed);
return articles;
}
/**
* ArticlesDto List to Articles List
*
* @param articlesDtoList
* @return articlesList
*/
public static List<Articles> convertToArticlesList(List<ArticlesDto> articlesDtoList) {
List<Articles> articlesList = new ArrayList<>();
for (ArticlesDto articlesDto : articlesDtoList) {
articlesList.add(articlesDto.convertToArticles());
}
return articlesList;
}
/**
* Articles to ArticlesDto
*
* @param articles
* @return articlesDto
*/
public static ArticlesDto convertFromArticles(Articles articles) {
ArticlesDto articlesDto = new ArticlesDto();
articlesDto.setId(articles.getId());
articlesDto.setTitle(articles.getTitle());
articlesDto.setBody(articles.
```
<Overlap Ratio: 0.984251968503937>

---

--- 288 --
Question ID: 12a4580df0bccd1cd60ae91ac8936d39e1fe4a3b
Original Code:
```
public class SetWarpCommand implements CommandExecutor {

    public static final String[] ALIASES = {"setwarp", "addwarp"};

    /**
     * Get the Command Specifications for this command
     *
     * @return CommandSpec
     */
    public static CommandSpec getCommandSpec() {
        return CommandSpec.builder()
                .permission("destinations.warp.create")
                .description(Text.of("/setwarp <name>"))
                .extendedDescription(Text.of("Set this location as a public warp."))
                .executor(new SetWarpCommand())
                .arguments(GenericArguments.remainingJoinedStrings(Text.of("name")))
                .build();
    }

    @Override
    public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {

        if (!(src instanceof Player)) {
            return CommandResult.empty();
        }

        String name = (String) args.getOne("name").orElse("");
        Player player = (Player) src;

        if (warpExists(name)) {
            player.sendMessage(MessagesUtil.error(player, "warp.exist", name));
            return CommandResult.success();
        }

        WarpEntity warp = new WarpEntity(name, false, new LocationEntity(player), PlayerCache.instance.get(player));
        warp = WarpRepository.instance.save(warp);
        WarpCache.instance.get().add(warp);

        player.sendMessage(MessagesUtil.success(player, "warp.create", name));
        // TODO: add private flag

        return CommandResult.success();
    }

    private boolean warpExists(String name) {
        for (WarpEntity warp : WarpCache.instance.get()) {
            if (warp.getName().equalsIgnoreCase(name)) {
                return true;
            }
        }
        return false;
    }

}
```


Overlapping Code:
```
 class SetWarpCommand implements CommandExecutor {
public static final String[] ALIASES = {"setwarp", "addwarp"};
/**
* Get the Command Specifications for this command
*
* @return CommandSpec
*/
public static CommandSpec getCommandSpec() {
return CommandSpec.builder()
.permission("destinations.warp.create")
.description(Text.of("/setwarp <name>"))
.extendedDescription(Text.of("Set this location as a public warp."))
.executor(new SetWarpCommand())
.arguments(GenericArguments.remainingJoinedStrings(Text.of("name")))
.build();
}
@Override
public CommandResult execute(CommandSource src, CommandContext args) throws CommandException {
if (!(src instanceof Player)) {
return CommandResult.empty();
}
String name = (String) args.getOne("name").orElse("");
Player player = (Player) src;
if (warpExists(name)) {
player.sendMessage(MessagesUtil.error(player, "warp.exist", name));
return CommandResult.success();
}
WarpEntity warp = new WarpEntity(name, false, new LocationEntity(player), PlayerCache.instance.get(player));
warp = WarpRepository.instance.save(warp);
WarpCache.instance.get().add(warp);
player.sendMessage(MessagesUtil.success(player, "warp.create", name));
// TODO: add private flag
return CommandResult.success();
}
private boolean warpExists(String name) {
for (WarpEntity warp : WarpCache.instance.get()) {
if (warp.getName().equalsIgnoreCase(name)) {
return true;
}
}
return false;
}
}
```
<Overlap Ratio: 0.9957416607523066>

---

--- 289 --
Question ID: eccc474756cb7236c86b3ffef8df5b704d96b430
Original Code:
```
public class MementoCard extends AbstractDynamicCard {
    // TEXT DECLARATION

    public static final String ID = HermitMod.makeID(MementoCard.class.getSimpleName());
    public static final String IMG = makeCardPath("memento.png");

    // /TEXT DECLARATION/


    // STAT DECLARATION

    private static final CardRarity RARITY = CardRarity.SPECIAL;
    private static final CardTarget TARGET = CardTarget.ALL;
    private static final CardType TYPE = CardType.CURSE;
    public static final CardColor COLOR = CardColor.CURSE;
    private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);
    public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;

    private static final int MAGIC_NUMBER = 1;

    private static final int COST = 0;

    // /STAT DECLARATION/

    public MementoCard() {
        super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET);
        baseMagicNumber = magicNumber = MAGIC_NUMBER;
        this.selfRetain = true;
        loadJokeCardImage(this, "memento.png");
    }

    public void use(AbstractPlayer p, AbstractMonster m) {
        Iterator var4 = AbstractDungeon.getCurrRoom().monsters.monsters.iterator();

        while(var4.hasNext()) {
            AbstractMonster mo = (AbstractMonster)var4.next();
            this.addToBot(new ApplyPowerAction(mo, p, new VulnerablePower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));

            if (this.upgraded)
            this.addToBot(new ApplyPowerAction(mo, p, new WeakPower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));
        }

        this.addToBot(new ApplyPowerAction(p, p, new VulnerablePower(p, magicNumber, false), magicNumber));

        if (this.upgraded)
        this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, magicNumber, false), magicNumber));
    }

    //Upgraded stats.
    @Override
    public void upgrade() {
    }

    public AbstractCard makeCopy() {
        return new MementoCard();
    }
}
```


Overlapping Code:
```
d extends AbstractDynamicCard {
// TEXT DECLARATION
public static final String ID = HermitMod.makeID(MementoCard.class.getSimpleName());
public static final String IMG = makeCardPath("memento.png");
// /TEXT DECLARATION/
// STAT DECLARATION
private static final CardRarity RARITY = CardRarity.SPECIAL;
private static final CardTarget TARGET = CardTarget.ALL;
private static final CardType TYPE = CardType.CURSE;
public static final CardColor COLOR = CardColor.CURSE;
private static final CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);
public static final String UPGRADE_DESCRIPTION = cardStrings.UPGRADE_DESCRIPTION;
private static final int MAGIC_NUMBER = 1;
private static final int COST = 0;
// /STAT DECLARATION/
public MementoCard() {
super(ID, IMG, COST, TYPE, COLOR, RARITY, TARGET);
baseMagicNumber = magicNumber = MAGIC_NUMBER;
this.selfRetain = true;
loadJokeCardImage(this, "memento.png");
}
public void use(AbstractPlayer p, AbstractMonster m) {
Iterator var4 = AbstractDungeon.getCurrRoom().monsters.monsters.iterator();
while(var4.hasNext()) {
AbstractMonster mo = (AbstractMonster)var4.next();
this.addToBot(new ApplyPowerAction(mo, p, new VulnerablePower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));
if (this.upgraded)
this.addToBot(new ApplyPowerAction(mo, p, new WeakPower(mo, magicNumber, false), magicNumber, true, AbstractGameAction.AttackEffect.NONE));
}
this.addToBot(new ApplyPowerAction(p, p, new VulnerablePower(p, magicNumber, false), magicNumber));
if (this.upgraded)
this.addToBot(new ApplyPowerAction(p, p, new WeakPower(p, magicNumber, false), magicNumber));
}
//Upgraded stats.
@Override
public void upgrade() {
}
public AbstractCard makeCopy() {
return new MementoCard();
}
}
```
<Overlap Ratio: 0.9871937639198218>

---

--- 290 --
Question ID: e37c75d21d711925fdb47bbb761a08f1d3080090
Original Code:
```
public class ConceptTest {

    Concept c1,c2,c3,c4;
    
    @Before
    public void setUp() throws Exception {
        c1 = new Concept(1);
        c2 = new Concept(2);
        c3 = new Concept(3);
        c4 = new Concept(4);

        c1.setPrimitive(true);
        c2.setPrimitive(true);
        c3.setPrimitive(true);
        c4.setPrimitive(true);
    }

    /*
     * Test case 1:
     * ------------
     * {1,2,3} is primitive
     * 1 isKindOf 2
     * 2 isKindOf 3
     * 
     * All primitive supertypes for concept 1: 
     * {2,3}
     * 
     * All supertypes for concept 1:
     * {2,3} 
     */
    @Test
    public void shouldPassPrimitiveParentTestCase1_WithCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
    }

    @Test
    public void shouldPassPrimitiveParentTestCase1_WithoutCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
    } 
    
    @Test
    public void shouldPassParentTestCase1_WithoutCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(2, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }     
    
    @Test
    public void shouldPassParentTestCase1_WithCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(2, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }         

    /*
     * Test case 2:
     * ------------
     * {1,3} is primitive, {2} is not primitive
     * 1 isKindOf 2
     * 2 isKindOf 3
     * 
     * All primitive supertypes for concept 1: 
     * {3}
     * 
     * All supertypes for concept 1:
     * {2,3}
     */ 
    @Test
    public void shouldPassPrimitiveParentTestCase2_WithCache() {
        c2.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c3));
    }
    @Test
    public void shouldPassPrimitiveParentTestCase2_WithoutCache() {
        c2.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c3));
    }
    
    @Test
    public void shouldPassParentTestCase2_WithCache() {
        c2.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(2, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }
    @Test
    public void shouldPassParentTestCase2_WithoutCache() {
        c2.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(2, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }    

    /*
     * Test case 3:
     * ------------
     * {1,4} is primitive, {2,3} is not primitive
     * 1 isKindOf 2
     * 2 isKindOf 3
     * 3 isKindOf 4
     * 
     * All primitive supertypes for concept 1: 
     * {4}
     * 
     * All supertypes for concept 1:
     * {2,3,4}
     */ 
    @Test
    public void shouldPassPrimitiveParentTestCase3_WithCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
    }    

    @Test
    public void shouldPassPrimitiveParentTestCase3_WithoutCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
    }      
    
    @Test
    public void shouldPassParentTestCase3_WithCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }    

    @Test
    public void shouldPassPrimitiveTestCase3_WithoutCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }     


    /*
     * Test case 4:
     * ------------
     * {1,2,3,4} is primitive
     * 1 isKindOf 2
     * 2 isKindOf 3
     * 3 isKindOf 4 
     * 
     * All primitive supertypes for concept 1: 
     * {2,3,4}
     * 
     * All supertypes for concept 1: 
     * {2,3,4}
     */
    @Test
    public void shouldPassPrimitiveParentTestCase4_WithCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(3, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
        assertTrue(allPrimitive.contains(c4));
    } 

    @Test
    public void shouldPassPrimitiveParentTestCase4_WithoutCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(3, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
        assertTrue(allPrimitive.contains(c4));
    } 
    
    @Test
    public void shouldPassParentTestCase4_WithCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    } 

    @Test
    public void shouldPassParentTestCase4_WithoutCache() {
        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }     

    /*
     * Test case 5:
     * ------------
     * {1,2,3,4,5} is primitive
     * 1 isKindOf 2
     * 1 isKindOf 3
     * 2 isKindof 4
     * 3 isKindOf 4
     * 
     * All primitive supertypes for concept 1: 
     * {2,3,4}
     * 
     * All supertypes for concept 1: 
     * {2,3,4}
     */
    @Test
    public void shouldPassPrimitiveParentTestCase5_WithCache() {
        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(3, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
        assertTrue(allPrimitive.contains(c4));
    }

    @Test
    public void shouldPassPrimitiveParentTestCase5_WithoutCache() {
        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(3, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c3));
        assertTrue(allPrimitive.contains(c4));
    }   
    
    @Test
    public void shouldPassParentTestCase5_WithCache() {
        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }

    @Test
    public void shouldPassParentTestCase5_WithoutCache() {
        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }       

    /*
     * Test case 6:
     * ------------
     * {1,2,4} is primitive, {3} is not primitive
     * 1 isKindOf 2
     * 2 isKindOf 3
     * 3 isKindof 4
     * 
     * All primitive supertypes for concept 1: 
     * {2,4}
     * 
     * All supertypes for concept 1: 
     * {2,3,4}
     */
    @Test
    public void shouldPassPrimitiveParentTestCase6_WithCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c4));
    }

    @Test
    public void shouldPassPrimitiveParentTestCase6_WithoutCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c2));
        assertTrue(allPrimitive.contains(c4));
    }  
    
    @Test
    public void shouldPassParentTestCase6_WithCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }

    @Test
    public void shouldPassParentTestCase6_WithoutCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c4));
    }      

    /*
     * Test case 7:
     * ------------
     * {1,4} is primitive, {2,3} is not primitive
     * 1 isKindOf 2
     * 1 isKindOf 3
     * 2 isKindof 4
     * 3 isKindOf 4
     * 
     * All primitive supertypes for concept 1: 
     * {4}
     * 
     * All supertypes for concept 1: 
     * {2,3,4}
     */
    @Test
    public void shouldPassPrimitiveParentTestCase7_WithCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);
        c1.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
    }   

    @Test
    public void shouldPassPrimitiveParentTestCase7_WithoutCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);
        c1.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(1, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
    }   
    
    @Test
    public void shouldPassParentTestCase7_WithCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);
        c1.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c4));
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }   

    @Test
    public void shouldPassParentTestCase7_WithoutCache() {
        c2.setPrimitive(false);
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c2.addKindOf(c3);
        c3.addKindOf(c4);
        c1.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c4));
        assertTrue(allKindOfs.contains(c2));
        assertTrue(allKindOfs.contains(c3));
    }       

    /*
     * Test case 8:
     * ------------
     * {1,2,4} is primitive, {3} is not primitive
     * 1 isKindOf 2
     * 1 isKindOf 3
     * 2 isKindof 4
     * 3 isKindOf 4
     * 
     * All primitive supertypes for concept 1: 
     * {2,4}
     * 
     * All supertypes for concept 1: 
     * {2,3,4}
     */
    @Test
    public void shouldPassPrimitiveParentTestCase8_WithCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
        assertTrue(allPrimitive.contains(c2));
    }   

    @Test
    public void shouldPassPrimitiveParentTestCase8_WithoutCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
        assertEquals(2, allPrimitive.size());
        assertTrue(allPrimitive.contains(c4));
        assertTrue(allPrimitive.contains(c2));
    }    
    @Test
    public void shouldPassParentTestCase8_WithCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c4));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c2));
    }   

    @Test
    public void shouldPassParentTestCase8_WithoutCache() {
        c3.setPrimitive(false);

        c1.addKindOf(c2);
        c1.addKindOf(c3);
        c2.addKindOf(c4);
        c3.addKindOf(c4);

        Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
        assertEquals(3, allKindOfs.size());
        assertTrue(allKindOfs.contains(c4));
        assertTrue(allKindOfs.contains(c3));
        assertTrue(allKindOfs.contains(c2));
    }
    
    
    

    @Test
    public void shouldReturnTrueForIsKindOfPredicate(){
        assertTrue(new Concept(Concept.IS_KIND_OF_RELATIONSHIP_TYPE_ID).isKindOfPredicate());
    }
    
    @Test
    public void shouldReturnTrueForIsPredicate(){
        Concept c = new Concept(123);
        c.addPredicateOfStatement(new Statement(Statement.SERIALISED_ID_NOT_DEFINED));
        assertTrue(c.isPredicate());
    }
    
    @Test
    public void shouldBeEqualConcepts(){
        Concept c1 = new Concept(123);
        Concept c2 = new Concept(123);
        assertEquals(c1, c2);
        assertEquals(c1.hashCode(), c2.hashCode());
    }
    
    @Test
    public void shouldBeUnequalConcepts(){
        Concept c1 = new Concept(123);
        Concept c2 = new Concept(1234);
        assertNotEquals(c1, c2);
        assertNotEquals(c1.hashCode(), c2.hashCode());
    }
    
    @Test
    public void shouldCreateGroupFromStatement() throws InvalidInputException{
        Concept c = new Concept(123);
        Concept p = new Concept(999);
        Concept o = new Concept(666);
        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(p);
        s.setObject(o);
        s.setGroupId(5);
        c.addSubjectOfStatement(s);
        Group g = new Group(s);
        assertTrue(g.equals(c.getGroup(s)));
    }
    
    @Test
    public void shouldGetGroupFromStatement() throws InvalidInputException{
        Concept c = new Concept(123);
        Concept p = new Concept(999);
        Concept o = new Concept(666);
        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(p);
        s.setObject(o);
        s.setGroupId(5);
        c.addSubjectOfStatement(s);
        Group g = new Group(s);
        //create group
        assertTrue(g.equals(c.getGroup(s)));
        //get group
        assertTrue(g.equals(c.getGroup(s)));
    }
    
    @Test
    public void shouldGetCorrectGroupFromMultipleGroupsTrue() throws InvalidInputException{
        Concept c = new Concept(123);
        
        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(new Concept(999));
        s.setObject(new Concept(666));
        s.setGroupId(5);

        Statement s1 = new Statement(444);
        s1.setSubject(c);
        s1.setPredicate(new Concept(9991));
        s1.setObject(new Concept(6661));
        s1.setGroupId(2);

        c.addSubjectOfStatement(s);
        c.addSubjectOfStatement(s1);
        
        assertTrue(new Group(s).equals(c.getGroup(s)));
    }

    @Test
    public void shouldGetCorrectGroupFromMultipleStatementsTrue() throws InvalidInputException{
        Concept c = new Concept(123);
        
        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(new Concept(999));
        s.setObject(new Concept(666));
        s.setGroupId(2);

        Statement s1 = new Statement(4441);
        s1.setSubject(c);
        s1.setPredicate(new Concept(9991));
        s1.setObject(new Concept(6661));
        s1.setGroupId(2);

        c.addSubjectOfStatement(s);
        c.addSubjectOfStatement(s1);
        
        assertTrue(new Group(Arrays.asList(s1, s)).equals(c.getGroup(s)));
    }
    
    @Test
    public void shouldGetCorrectGroupFromMultipleStatementsFalse() throws InvalidInputException{
        Concept c = new Concept(123);
        
        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(new Concept(999));
        s.setObject(new Concept(666));
        s.setGroupId(2);

        Statement s1 = new Statement(4441);
        s1.setSubject(c);
        s1.setPredicate(new Concept(9991));
        s1.setObject(new Concept(6661));
        s1.setGroupId(2);

        c.addSubjectOfStatement(s);
        c.addSubjectOfStatement(s1);
        
        assertTrue(!new Group(Arrays.asList(s1)).equals(c.getGroup(s)));
    }    
    
    @Test
    public void shouldGetCorrectGroupFromMultipleGroupsFalse() throws InvalidInputException{
        Concept c = new Concept(123);

        Statement s = new Statement(444);
        s.setSubject(c);
        s.setPredicate(new Concept(999));
        s.setObject(new Concept(666));
        s.setGroupId(5);

        Statement s1 = new Statement(444);
        s1.setSubject(c);
        s1.setPredicate(new Concept(9991));
        s1.setObject(new Concept(6661));
        s1.setGroupId(2);

        c.addSubjectOfStatement(s);
        c.addSubjectOfStatement(s1);

        assertTrue(!new Group(s1).equals(c.getGroup(s)));
    }
    
    

}
```


Overlapping Code:
```
oncept c1,c2,c3,c4;

@Before
public void setUp() throws Exception {
c1 = new Concept(1);
c2 = new Concept(2);
c3 = new Concept(3);
c4 = new Concept(4);
c1.setPrimitive(true);
c2.setPrimitive(true);
c3.setPrimitive(true);
c4.setPrimitive(true);
}
/*
* Test case 1:
* ------------
* {1,2,3} is primitive
* 1 isKindOf 2
* 2 isKindOf 3
* 
* All primitive supertypes for concept 1: 
* {2,3}
* 
* All supertypes for concept 1:
* {2,3} 
*/
@Test
public void shouldPassPrimitiveParentTestCase1_WithCache() {
c1.addKindOf(c2);
c2.addKindOf(c3);
Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(true);
assertEquals(2, allPrimitive.size());
assertTrue(allPrimitive.contains(c2));
assertTrue(allPrimitive.contains(c3));
}
@Test
public void shouldPassPrimitiveParentTestCase1_WithoutCache() {
c1.addKindOf(c2);
c2.addKindOf(c3);
Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(false);
assertEquals(2, allPrimitive.size());
assertTrue(allPrimitive.contains(c2));
assertTrue(allPrimitive.contains(c3));
} 

@Test
public void shouldPassParentTestCase1_WithoutCache() {
c1.addKindOf(c2);
c2.addKindOf(c3);
Set<Concept> allKindOfs = c1.getAllKindOfConcepts(false);
assertEquals(2, allKindOfs.size());
assertTrue(allKindOfs.contains(c2));
assertTrue(allKindOfs.contains(c3));
} 

@Test
public void shouldPassParentTestCase1_WithCache() {
c1.addKindOf(c2);
c2.addKindOf(c3);
Set<Concept> allKindOfs = c1.getAllKindOfConcepts(true);
assertEquals(2, allKindOfs.size());
assertTrue(allKindOfs.contains(c2));
assertTrue(allKindOfs.contains(c3));
} 
/*
* Test case 2:
* ------------
* {1,3} is primitive, {2} is not primitive
* 1 isKindOf 2
* 2 isKindOf 3
* 
* All primitive supertypes for concept 1: 
* {3}
* 
* All supertypes for concept 1:
* {2,3}
*/ 
@Test
public void shouldPassPrimitiveParentTestCase2_WithCache() {
c2.setPrimitive(false);
c1.addKindOf(c2);
c2.addKindOf(c3);
Set<Concept> allPrimitive = c1.getAllKindOfPrimitiveConcepts(tru
```
<Overlap Ratio: 0.9848178137651822>

---

--- 291 --
Question ID: 3879eb3512c3d2a7c961ea72f1a35473fe259687
Original Code:
```
public class PathSum {

    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<>();
        pathSum(root, sum, result, new ArrayList<>());
        return result;
    }

    public void pathSum(TreeNode node, int target, List<List<Integer>> result, List<Integer> temp) {
        if (node == null) {
            return;
        }
        temp.add(node.val);
        if (node.val == target && node.left == null && node.right == null) {
            result.add(new ArrayList<>(temp));
        } else {
            pathSum(node.left, target - node.val, result, temp);
            pathSum(node.right, target - node.val, result, temp);
        }
        temp.remove(temp.size() - 1);
    }

    @Test
    public void case1() {
        TreeNode root = TreeNode.from(5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1);
        int sum = 22;
        List<List<Integer>> expected = Arrays.asList(Arrays.asList(5, 4, 11, 2), Arrays.asList(5, 8, 4, 5));
        Assert.assertTrue(CommonUtil.isEquals(expected, pathSum(root, sum)));
    }
}
```


Overlapping Code:
```
ss PathSum {
public List<List<Integer>> pathSum(TreeNode root, int sum) {
List<List<Integer>> result = new ArrayList<>();
pathSum(root, sum, result, new ArrayList<>());
return result;
}
public void pathSum(TreeNode node, int target, List<List<Integer>> result, List<Integer> temp) {
if (node == null) {
return;
}
temp.add(node.val);
if (node.val == target && node.left == null && node.right == null) {
result.add(new ArrayList<>(temp));
} else {
pathSum(node.left, target - node.val, result, temp);
pathSum(node.right, target - node.val, result, temp);
}
temp.remove(temp.size() - 1);
}
@Test
public void case1() {
TreeNode root = TreeNode.from(5, 4, 8, 11, null, 13, 4, 7, 2, null, null, 5, 1);
int sum = 22;
List<List<Integer>> expected = Arrays.asList(Arrays.asList(5, 4, 11, 2), Arrays.asList(5, 8, 4, 5));
Assert.assertTrue(CommonUtil.isEquals(expected, pathSum(root, sum)
```
<Overlap Ratio: 0.9809843400447428>

---

--- 292 --
Question ID: d11f142bbca59ead04a7dda3b551c1120d7dfa96
Original Code:
```
public final class ListValueStackTest
    extends ValueStackTest
{
    @Override
    protected ValueStack<Object> newStack()
    {
        final Collection<Object> values = Arrays.asList(o1, o2, o3, o4, o5, o6);
        return new ListValueStack<>(values);
    }

    @Override
    protected void checkNoContents()
    {
        assertThat(stack.isEmpty()).isTrue();
    }

    @Override
    protected void checkContents(final Object first, final Object... others)
    {
        final List<Object> values = new ArrayList<>();
        values.add(first);
        Collections.addAll(values, others);

        final int expectedSize = 1 + others.length;

        assertThat(stack.size()).isEqualTo(expectedSize);

        try (
            final AutoCloseableSoftAssertions soft
                = new AutoCloseableSoftAssertions();
        ) {
            for (int index = 0; index < expectedSize; index++)
                soft.assertThat(stack.peek(index))
                    .as("element at index %d", index)
                    .isEqualTo(values.get(index));
        }

    }
}
```


Overlapping Code:
```
class ListValueStackTest
extends ValueStackTest
{
@Override
protected ValueStack<Object> newStack()
{
final Collection<Object> values = Arrays.asList(o1, o2, o3, o4, o5, o6);
return new ListValueStack<>(values);
}
@Override
protected void checkNoContents()
{
assertThat(stack.isEmpty()).isTrue();
}
@Override
protected void checkContents(final Object first, final Object... others)
{
final List<Object> values = new ArrayList<>();
values.add(first);
Collections.addAll(values, others);
final int expectedSize = 1 + others.length;
assertThat(stack.size()).isEqualTo(expectedSize);
try (
final AutoCloseableSoftAssertions soft
= new AutoCloseableSoftAssertions();
) {
for (int index = 0; index < expectedSize; index++)
soft.assertThat(stack.peek(index))
.as("element at index %d", index)
.isEqualTo(val
```
<Overlap Ratio: 0.9580838323353293>

---

--- 293 --
Question ID: 5d697c3187eab40f7dd3596f4be730d766fd7fe1
Original Code:
```
public class LoggingFilter implements ClientRequestFilter, ClientResponseFilter {

  private final Logger LOG = LoggerFactory.getLogger(LoggingFilter.class);

  @Override
  public void filter(ClientRequestContext requestContext) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    mapper.registerModule(new JavaTimeModule());

    LOG.info(System.getProperty("line.separator") + "!!! Test Request" + System
            .getProperty("line.separator") + "!!! URL: {}" + System.getProperty("line.separator")
            + "!!! Method: {}" + System.getProperty("line.separator") + "!!! Body: {}",
        requestContext.getUri(),
        requestContext.getMethod(),
        mapper.writerWithDefaultPrettyPrinter().writeValueAsString(requestContext.getEntity()));
  }

  @Override
  public void filter(ClientRequestContext clientRequestContext,
      ClientResponseContext clientResponseContext) throws IOException {
    LOG.info(System.getProperty("line.separator") + "!!! Test Response " + System
            .getProperty("line.separator") + "!!! Body: {} " + System.getProperty("line.separator")
            + "!!! Status: {}",
        responseToString(clientResponseContext),
        clientResponseContext.getStatus());
  }

  private String responseToString(ClientResponseContext clientResponseContext) {
    InputStream inputStream = clientResponseContext.getEntityStream();
    if (inputStream == null) {
      return "";
    } else {
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      try {
        IOUtils.copy(inputStream, baos);
        InputStream restoredStream = new ByteArrayInputStream(
            baos.toString().getBytes(StandardCharsets.UTF_8));
        clientResponseContext.setEntityStream(restoredStream);
      } catch (IOException e) {
        // nothing to do
      }
      return baos.toString();
    }
  }
}
```


Overlapping Code:
```
blic class LoggingFilter implements ClientRequestFilter, ClientResponseFilter {
private final Logger LOG = LoggerFactory.getLogger(LoggingFilter.class);
@Override
public void filter(ClientRequestContext requestContext) throws IOException {
ObjectMapper mapper = new ObjectMapper();
mapper.registerModule(new JavaTimeModule());
LOG.info(System.getProperty("line.separator") + "!!! Test Request" + System
.getProperty("line.separator") + "!!! URL: {}" + System.getProperty("line.separator")
+ "!!! Method: {}" + System.getProperty("line.separator") + "!!! Body: {}",
requestContext.getUri(),
requestContext.getMethod(),
mapper.writerWithDefaultPrettyPrinter().writeValueAsString(requestContext.getEntity()));
}
@Override
public void filter(ClientRequestContext clientRequestContext,
ClientResponseContext clientResponseContext) throws IOException {
LOG.info(System.getProperty("line.separator") + "!!! Test Response " + System
.getProperty("line.separator") + "!!! Body: {} " + System.getProperty("line.separator")
+ "!!! Status: {}",
responseToString(clientResponseContext),
clientResponseContext.getStatus());
}
private String responseToString(ClientResponseContext clientResponseContext) {
InputStream inputStream = clientResponseContext.getEntityStream();
if (inputStream == null) {
return "";
} else {
ByteArrayOutputStream baos = new ByteArrayOutputStream();
try {
IOUtils.copy(inputStream, baos);
InputStream restoredStream = new ByteArrayInputStream(
baos.toString().getBytes(StandardCharsets.UTF_8));
clientResponseContext.setEntityStream(restoredStream);
} catch (IOException e) {
// nothing to do
}
return baos.toString();
}
}
```
<Overlap Ratio: 0.9975594874923734>

---

--- 294 --
Question ID: 24793cc29f2a7a6a9401594fda2c1438d66b21b1
Original Code:
```
class MyTrackerEventLogger extends ContextDependentEventLogger
{
  MyTrackerEventLogger(@NonNull Application application)
  {
    super(application);
  }

  @Override
  public void initialize()
  {
    initTracker();
  }

  @Override
  public void sendTags(@NonNull String tag, @Nullable String[] params)
  {
    /* Do nothing */
  }

  @Override
  public void logEvent(@NonNull String event, @NonNull Map<String, String> params)
  {
    MyTracker.trackEvent(event, params);
  }

  @Override
  public void startActivity(@NonNull Activity context)
  {
    MyTracker.onStartActivity(context);
  }

  @Override
  public void stopActivity(@NonNull Activity context)
  {
    MyTracker.onStopActivity(context);
  }

  private void initTracker()
  {
    MyTracker.setDebugMode(BuildConfig.DEBUG);
    MyTracker.createTracker(PrivateVariables.myTrackerKey(), getApplication());
    final MyTrackerParams myParams = MyTracker.getTrackerParams();
    if (myParams != null)
    {
      myParams.setDefaultVendorAppPackage();
      boolean isLocationGranted = PermissionsUtils.isLocationGranted(getApplication());
      myParams.setTrackingLocationEnabled(isLocationGranted);
      myParams.setTrackingEnvironmentEnabled(isLocationGranted);
    }
    MyTracker.initTracker();
  }
}
```


Overlapping Code:
```
ss MyTrackerEventLogger extends ContextDependentEventLogger
{
MyTrackerEventLogger(@NonNull Application application)
{
super(application);
}
@Override
public void initialize()
{
initTracker();
}
@Override
public void sendTags(@NonNull String tag, @Nullable String[] params)
{
/* Do nothing */
}
@Override
public void logEvent(@NonNull String event, @NonNull Map<String, String> params)
{
MyTracker.trackEvent(event, params);
}
@Override
public void startActivity(@NonNull Activity context)
{
MyTracker.onStartActivity(context);
}
@Override
public void stopActivity(@NonNull Activity context)
{
MyTracker.onStopActivity(context);
}
private void initTracker()
{
MyTracker.setDebugMode(BuildConfig.DEBUG);
MyTracker.createTracker(PrivateVariables.myTrackerKey(), getApplication());
final MyTrackerParams myParams = MyTracker.getTrackerParams();
if (myParams != null)
{
myParams.setDefaultVendorAppPackage();
boolean isLocationGranted = PermissionsUtils.isLocationGranted(getApplication());
myParams.setTrackingLocationEnabled(isLocationGranted);
myParams.setTrackingEnvironmentEnabled(isLocationGranted)
```
<Overlap Ratio: 0.9691629955947136>

---

--- 295 --
Question ID: 11065489d735a4e66911f85a1b3c4a839664932b
Original Code:
```
@RestController
@RequestMapping("/api")
public class RoleResource {

    private final Logger log = LoggerFactory.getLogger(RoleResource.class);

    private static final String ENTITY_NAME = "role";

    @Value("${jhipster.clientApp.name}")
    private String applicationName;

    private final RoleService roleService;

    public RoleResource(RoleService roleService) {
        this.roleService = roleService;
    }

    /**
     * {@code POST  /roles} : Create a new role.
     *
     * @param role the role to create.
     * @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new role, or with status {@code 400 (Bad Request)} if the role has already an ID.
     * @throws URISyntaxException if the Location URI syntax is incorrect.
     */
    @PostMapping("/roles")
    @PreAuthorize("hasAuthority('" + ROLE_CREATE + "')")
    public ResponseEntity<Role> createRole(@Valid @RequestBody Role role) throws URISyntaxException {
        log.debug("REST request to save Role : {}", role);
        if (roleService.findOne(role.getName()).isPresent()) {
            throw new BadRequestAlertException("This role already exists", ENTITY_NAME, "idexists");
        }
        Role result = roleService.save(role);
        return ResponseEntity.created(new URI("/api/roles/" + result.getName()))
            .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getName()))
            .body(result);
    }

    /**
     * {@code GET  /roles} : get all the roles.
     *
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of roles in body.
     */
    @GetMapping("/roles")
    @PreAuthorize("hasAuthority('" + ROLE_READ + "')")
    public List<Role> getAllRoles() {
        log.debug("REST request to get all Roles");
        return roleService.findAll();
    }

    /**
     * {@code GET  /roles/:id} : get the "id" role.
     *
     * @param id the id of the role to retrieve.
     * @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the role, or with status {@code 404 (Not Found)}.
     */
    @GetMapping("/roles/{id}")
    @PreAuthorize("hasAuthority('" + ROLE_READ + "')")
    public ResponseEntity<Role> getRole(@PathVariable String id) {
        log.debug("REST request to get Role : {}", id);
        Optional<Role> role = roleService.findOne(id);
        return ResponseUtil.wrapOrNotFound(role);
    }

    /**
     * {@code DELETE  /roles/:id} : delete the "id" role.
     *
     * @param id the id of the role to delete.
     * @return the {@link ResponseEntity} with status {@code 204 (NO_CONTENT)}.
     */
    @DeleteMapping("/roles/{id}")
    @PreAuthorize("hasAuthority('" + ROLE_DELETE + "')")
    public ResponseEntity<Void> deleteRole(@PathVariable String id) {
        log.debug("REST request to delete Role : {}", id);
        roleService.delete(id);
        return ResponseEntity.noContent().headers(HeaderUtil.createEntityDeletionAlert(applicationName, true, ENTITY_NAME, id)).build();
    }
}
```


Overlapping Code:
```
@RestController
@RequestMapping("/api")
public class RoleResource {
private final Logger log = LoggerFactory.getLogger(RoleResource.class);
private static final String ENTITY_NAME = "role";
@Value("${jhipster.clientApp.name}")
private String applicationName;
private final RoleService roleService;
public RoleResource(RoleService roleService) {
this.roleService = roleService;
}
/**
* {@code POST /roles} : Create a new role.
*
* @param role the role to create.
* @return the {@link ResponseEntity} with status {@code 201 (Created)} and with body the new role, or with status {@code 400 (Bad Request)} if the role has already an ID.
* @throws URISyntaxException if the Location URI syntax is incorrect.
*/
@PostMapping("/roles")
@PreAuthorize("hasAuthority('" + ROLE_CREATE + "')")
public ResponseEntity<Role> createRole(@Valid @RequestBody Role role) throws URISyntaxException {
log.debug("REST request to save Role : {}", role);
if (roleService.findOne(role.getName()).isPresent()) {
throw new BadRequestAlertException("This role already exists", ENTITY_NAME, "idexists");
}
Role result = roleService.save(role);
return ResponseEntity.created(new URI("/api/roles/" + result.getName()))
.headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, result.getName()))
.body(result);
}
/**
* {@code GET /roles} : get all the roles.
*
* @return the {@link ResponseEntity} with status {@code 200 (OK)} and the list of roles in body.
*/
@GetMapping("/roles")
@PreAuthorize("hasAuthority('" + ROLE_READ + "')")
public List<Role> getAllRoles() {
log.debug("REST request to get all Roles");
return roleService.findAll();
}
/**
* {@code GET /roles/:id} : get the "id" role.
*
* @param id the id of the role to retrieve.
* @return the {@link ResponseEntity} with status {@code 200 (OK)} and with body the role, or with status {@code 404 (Not Found)}.
*/
@GetMapping("/roles/{id}")
@PreAuthorize("hasAuthority('" + ROLE_READ + "')")
public ResponseEntity<Role> getRole(@PathVariable String id) {
log.debug("REST request to get Role : {}", id);
Optional<Role> role = roleService.findOne(id);
return ResponseUtil.wrapOrNotFound(role);
}

```
<Overlap Ratio: 0.9799086757990868>

---

--- 296 --
Question ID: cb0e904b99d298c162dfe34669afb68f3b850e19
Original Code:
```
public class  OtherLock implements Runnable {

	int a = 100;

	synchronized void mul() throws InterruptedException {
		a = 1000;
		Thread.sleep(500);
		System.out.println("synchronized:" + a);
	}

	 void display() throws InterruptedException {
		Thread.sleep(200);
		a = 200;
		System.out.println("display:" + a);
	}

	public void run() {
		try {
			mul();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void main(String[] args) throws InterruptedException {
		OtherLock otherLock = new OtherLock();
		Thread thread = new Thread(otherLock);
		thread.start();
		System.out.println("firstmain:" + otherLock.a);
		Thread.sleep(100);
		otherLock.display();
		thread.join();
		System.out.println("secondmain:" + otherLock.a);
	}
}
```


Overlapping Code:
```
implements Runnable {
int a = 100;
synchronized void mul() throws InterruptedException {
a = 1000;
Thread.sleep(500);
System.out.println("synchronized:" + a);
}
void display() throws InterruptedException {
Thread.sleep(200);
a = 200;
System.out.println("display:" + a);
}
public void run() {
try {
mul();
} catch (Exception e) {
e.printStackTrace();
}
}
public static void main(String[] args) throws InterruptedException {
OtherLock otherLock = new OtherLock();
Thread thread = new Thread(otherLock);
thread.start();
System.out.println("firstmain:" + otherLock.a);
Thread.sleep(100);
otherLock.display();
thread.join();
System.out.println("secondmain
```
<Overlap Ratio: 0.935251798561151>

---

--- 297 --
Question ID: 76156c3a1f90a5e530d396fc7890f5ec7c408d99
Original Code:
```
@UtilityClass
public class RakNetUtils {

    public static void writeIntRanges(ByteBuf buffer, Queue<IntRange> ackQueue, int mtu) {
        int lengthIndex = buffer.writerIndex();
        buffer.writeZero(2);
        mtu -= 2;

        int count = 0;
        IntRange ackRange;
        while ((ackRange = ackQueue.poll()) != null) {

            IntRange nextRange;
            while ((nextRange = ackQueue.peek()) != null && (ackRange.end + 1) == nextRange.start) {
                ackQueue.remove();
                ackRange.end = nextRange.end;
            }

            if (ackRange.start == ackRange.end) {
                if (mtu < 4) {
                    break;
                }
                mtu -= 4;

                buffer.writeBoolean(true);
                buffer.writeMediumLE(ackRange.start);
            } else {
                if (mtu < 7) {
                    break;
                }
                mtu -= 7;

                buffer.writeBoolean(false);
                buffer.writeMediumLE(ackRange.start);
                buffer.writeMediumLE(ackRange.end);
            }
            count++;
        }

        int finalIndex = buffer.writerIndex();
        buffer.writerIndex(lengthIndex);
        buffer.writeShort(count);
        buffer.writerIndex(finalIndex);
    }

    public static boolean verifyUnconnectedMagic(ByteBuf buffer) {
        byte[] readMagic = new byte[RakNetConstants.RAKNET_UNCONNECTED_MAGIC.length];
        buffer.readBytes(readMagic);

        return Arrays.equals(readMagic, RakNetConstants.RAKNET_UNCONNECTED_MAGIC);
    }

    public static void writeUnconnectedMagic(ByteBuf buffer) {
        buffer.writeBytes(RakNetConstants.RAKNET_UNCONNECTED_MAGIC);
    }

    public static int clamp(int value, int low, int high) {
        return value < low ? low : value > high ? high : value;
    }

    public static int powerOfTwoCeiling(int value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
    }
}
```


Overlapping Code:
```
blic static void writeIntRanges(ByteBuf buffer, Queue<IntRange> ackQueue, int mtu) {
int lengthIndex = buffer.writerIndex();
buffer.writeZero(2);
mtu -= 2;
int count = 0;
IntRange ackRange;
while ((ackRange = ackQueue.poll()) != null) {
IntRange nextRange;
while ((nextRange = ackQueue.peek()) != null && (ackRange.end + 1) == nextRange.start) {
ackQueue.remove();
ackRange.end = nextRange.end;
}
if (ackRange.start == ackRange.end) {
if (mtu < 4) {
break;
}
mtu -= 4;
buffer.writeBoolean(true);
buffer.writeMediumLE(ackRange.start);
} else {
if (mtu < 7) {
break;
}
mtu -= 7;
buffer.writeBoolean(false);
buffer.writeMediumLE(ackRange.start);
buffer.writeMediumLE(ackRange.end);
}
count++;
}
int finalIndex = buffer.writerIndex();
buffer.writerIndex(lengthIndex);
buffer.writeShort(count);
buffer.writerIndex(finalIndex);
}
public static boolean verifyUnconnectedMagic(ByteBuf buffer) {
byte[] readMagic = new byte[RakNetConstants.RAKNET_UNCONNECTED_MAGIC.length];
buffer.readBytes(readMagic);
return Arrays.equals(readMagic, RakNetConstants.RAKNET_UNCONNECTED_MAGIC);
}
public static void writeUnconnectedMagic(ByteBuf buffer) {
buffer.writeBytes(RakNetConstants.RAKNET_UNCONNECTED_MAGIC);
}
public static int clamp(int value, int low, int high) {
return value < low ? low : value > high ? high : value;
}
public static int powerOfTwoCeiling(int value) {
value--;
value |= value >> 1;
value |= value >> 2;
value |= value >> 4;
value |= value >> 8;
value |= value >> 16;
value++;
return value;
}
}
```
<Overlap Ratio: 0.9720779220779221>

---

--- 298 --
Question ID: 871df602c1ff1b5a199e875e712f0a7e65ea02c8
Original Code:
```
public abstract class AbstractDMNValidationAwareMojo extends AbstractKieMojo {

    @Parameter(required = true, defaultValue = "${project.build.resources}")
    private List<Resource> resources;

    @Parameter(property = "validateDMN", defaultValue = "VALIDATE_SCHEMA,VALIDATE_MODEL,ANALYZE_DECISION_TABLE")
    private String validateDMN;

    protected String getValidateDMN() {
        return validateDMN;
    }

    protected void logValidationMessages(List<DMNMessage> validation,
                                         Function<DMNMessage, String> prefixer,
                                         Function<DMNMessage, String> computeMessage) {
        for (DMNMessage msg : validation) {
            Consumer<CharSequence> logFn = null;
            switch (msg.getLevel()) {
                case ERROR:
                    logFn = getLog()::error;
                    break;
                case WARNING:
                    logFn = getLog()::warn;
                    break;
                case INFO:
                default:
                    logFn = getLog()::info;
                    break;
            }
            StringBuilder sb = new StringBuilder();
            sb.append(prefixer.apply(msg));
            sb.append(computeMessage.apply(msg));
            logFn.accept(sb.toString());
        }
    }

    public List<Validation> computeFlagsFromCSVString(String csvString) {
        List<Validation> flags = new ArrayList<>();
        boolean resetFlag = false;
        for (String p : csvString.split(",")) {
            try {
                flags.add(Validation.valueOf(p));
            } catch (IllegalArgumentException e) {
                getLog().info("validateDMN configured with flag: '" + p + "' determines this Mojo will not be executed (reset all flags).");
                resetFlag = true;
            }
        }
        if (resetFlag) {
            flags.clear();
        }
        return flags;
    }

    protected boolean shallPerformDMNDTAnalysis() {
        return computeFlagsFromCSVString(getValidateDMN()).contains(Validation.ANALYZE_DECISION_TABLE);
    }

    public void performDMNDTAnalysis(InternalKieModule kieModule) throws MojoExecutionException, MojoFailureException {
        Collection<DMNModel> dmnModels = extractDMNModelsFromKieModule(kieModule);
        getLog().info("Initializing DMN DT Validator...");
        InternalDMNDTAnalyser analyser = InternalDMNDTAnalyserFactory.newDMNDTAnalyser(computeDMNProfiles());
        getLog().info("DMN DT Validator initialized.");
        for (DMNModel model : dmnModels) {
            getLog().info("Analysing decision tables in DMN Model '" + model.getName() + "' ...");
            List<DTAnalysis> results = analyser.analyse(model, new HashSet<>(Arrays.asList(Validation.ANALYZE_DECISION_TABLE)));
            if (results.isEmpty()) {
                getLog().info(" no decision tables found.");
            } else {
                for (DTAnalysis r : results) {
                    getLog().info(" analysis for decision table '" + r.nameOrIDOfTable() + "':");
                    List<DMNMessage> messages = r.asDMNMessages();
                    logValidationMessages(messages, (u) -> "  ", DMNMessage::getMessage);
                    if (messages.stream().anyMatch(m -> m.getLevel() == Level.ERROR)) {
                        throw new MojoFailureException("There are DMN Validation Error(s).");
                    }
                }
            }
        }
    }

    private Collection<DMNModel> extractDMNModelsFromKieModule(InternalKieModule kieModule) {
        Collection<KiePackage> kpkgs = kieModule.getKieModuleModel().getKieBaseModels().keySet().stream()
                                                .flatMap(name -> kieModule.getKnowledgePackagesForKieBase(name).stream())
                                                .collect(Collectors.toList());
        Set<DMNModel> models = new HashSet<>();
        for (KiePackage kp : kpkgs) {
            InternalKnowledgePackage ikpkg = (InternalKnowledgePackage) kp;
            ResourceTypePackage<DMNModel> rtp = (ResourceTypePackage<DMNModel>) ikpkg.getResourceTypePackages().get(ResourceType.DMN);
            if (rtp == null) {
                continue;
            }
            for (DMNModel dmnModel : rtp) {
                models.add(dmnModel);
            }
        }
        Map<org.kie.api.io.Resource, DMNModel> removeDups = new HashMap<>();
        for (DMNModel m : models) {
            removeDups.put(m.getResource(), m);
        }
        return removeDups.values();
    }

    protected List<Path> resourcesPaths() {
        List<Path> resourcesPaths = resources.stream().map(r -> new File(r.getDirectory()).toPath()).collect(Collectors.toList());
        if (getLog().isDebugEnabled()) {
            getLog().debug("resourcesPaths: " + resourcesPaths.stream().map(Path::toString).collect(Collectors.joining(",\n")));
        }
        return resourcesPaths;
    }

    protected List<DMNProfile> computeDMNProfiles() throws MojoExecutionException {
        ClassLoader classLoader = ClassLoaderUtil.findDefaultClassLoader();
        ChainedProperties chainedProperties = ChainedProperties.getChainedProperties(classLoader);
        List<KieModuleModel> kieModules = new ArrayList<>();
        for (Path p : resourcesPaths()) {
            try (Stream<Path> walk = Files.walk(p)) {
                List<Path> collect = walk.filter(f -> f.toString().endsWith("kmodule.xml")).collect(Collectors.toList());
                for (Path k : collect) {
                    kieModules.add(KieModuleModelImpl.fromXML(k.toFile()));
                }
            } catch (Exception e) {
                throw new MojoExecutionException("Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)", e);
            }
        }
        for (KieModuleModel kmm : kieModules) {
            Properties ps = new Properties();
            ps.putAll(kmm.getConfigurationProperties());
            chainedProperties.addProperties(ps);
        }
        List<DMNProfile> dmnProfiles = new ArrayList<>();
        dmnProfiles.addAll(DMNAssemblerService.getDefaultDMNProfiles(chainedProperties));
        try {
            Map<String, String> dmnProfileProperties = new HashMap<>();
            chainedProperties.mapStartsWith(dmnProfileProperties, DMNAssemblerService.DMN_PROFILE_PREFIX, false);
            for (Map.Entry<String, String> dmnProfileProperty : dmnProfileProperties.entrySet()) {
                DMNProfile dmnProfile = (DMNProfile) classLoader.loadClass(dmnProfileProperty.getValue()).newInstance();
                dmnProfiles.add(dmnProfile);
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
            throw new MojoExecutionException("Failed executing AbstractDMNValidationAwareMojo while computing DMNProfile(s)", e);
        }
        return dmnProfiles;
    }
}
```


Overlapping Code:
```
MNValidationAwareMojo extends AbstractKieMojo {
@Parameter(required = true, defaultValue = "${project.build.resources}")
private List<Resource> resources;
@Parameter(property = "validateDMN", defaultValue = "VALIDATE_SCHEMA,VALIDATE_MODEL,ANALYZE_DECISION_TABLE")
private String validateDMN;
protected String getValidateDMN() {
return validateDMN;
}
protected void logValidationMessages(List<DMNMessage> validation,
Function<DMNMessage, String> prefixer,
Function<DMNMessage, String> computeMessage) {
for (DMNMessage msg : validation) {
Consumer<CharSequence> logFn = null;
switch (msg.getLevel()) {
case ERROR:
logFn = getLog()::error;
break;
case WARNING:
logFn = getLog()::warn;
break;
case INFO:
default:
logFn = getLog()::info;
break;
}
StringBuilder sb = new StringBuilder();
sb.append(prefixer.apply(msg));
sb.append(computeMessage.apply(msg));
logFn.accept(sb.toString());
}
}
public List<Validation> computeFlagsFromCSVString(String csvString) {
List<Validation> flags = new ArrayList<>();
boolean resetFlag = false;
for (String p : csvString.split(",")) {
try {
flags.add(Validation.valueOf(p));
} catch (IllegalArgumentException e) {
getLog().info("validateDMN configured with flag: '" + p + "' determines this Mojo will not be executed (reset all flags).");
resetFlag = true;
}
}
if (resetFlag) {
flags.clear();
}
return flags;
}
protected boolean shallPerformDMNDTAnalysis() {
return computeFlagsFromCSVString(getValidateDMN()).contains(Validation.ANALYZE_DECISION_TABLE);
}
public void performDMNDTAnalysis(InternalKieModule kieModule) throws MojoExecutionException, MojoFailureException {
Collection<DMNModel> dmnModels = extractDMNModelsFromKieModule(kieModule);
getLog().info("Initializing DMN DT Validator...");
InternalDMNDTAnalyser analyser = InternalDMNDTAnalyserFactory.newDMNDTAnalyser(co
```
<Overlap Ratio: 0.9669156883671292>

---

--- 299 --
Question ID: 2c53cd45c502296492f9887395805fe9669aa4a4
Original Code:
```
public class StudentUI extends AppCompatActivity {

    Button btn;
    BottomNavigationView bottomNavigationView;
    Menu itemToHide;
    TextView cours;
    Bundle b;
    String coursId;
    String nom;
    String s;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_studentui);

        b = getIntent().getExtras();

        cours = (TextView) findViewById(R.id.txtdashboard2);
        s = cours.getText().toString();
        cours.setText(s + " (" + b.getString("name") + ") ");
        /*Window window = this.getWindow();
        window.setStatusBarColor(ContextCompat.getColor(this,R.color.colorDarkRed));

        ActionBar bar = getSupportActionBar();
        bar.setBackgroundDrawable(new ColorDrawable(getResources().getColor(R.color.colorRed)));
        bar.setTitle("AskNanterre : Etudiant");*/

        /*btn = (Button)findViewById(R.id.stud_btn);

        btn.setOnClickListener(
                new View.OnClickListener()
                {
                    public void onClick(View view)
                    {
                        Intent intent = new Intent(StudentUI.this, ProfessorUI.class);
                        startActivity(intent);
                    }
                });*/

        /*bottomNavigationView = (BottomNavigationView) findViewById(R.id.activity_main_bottom_navigation);
        itemToHide = bottomNavigationView.getMenu();
        itemToHide.findItem(R.id.action_goStud).setVisible(false);

        bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {
            @Override
            public boolean onNavigationItemSelected(@NonNull MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.action_home:
                        //Toast.makeText(StudentUI.this, "Recents", Toast.LENGTH_SHORT).show();
                        goToMainActivity();
                        break;
                    case R.id.action_goStud:
                        Toast.makeText(StudentUI.this, "Favorites", Toast.LENGTH_SHORT).show();
                        break;
                    case R.id.action_goProf:
                        //Toast.makeText(StudentUI.this, "Nearby", Toast.LENGTH_SHORT).show();
                        goToProfUIActivity();
                        break;
                }
                return true;
            }
        });*/
        coursId = b.getString("key");
        nom =  b.getString("name");
        Log.v("hfhfhfhf", coursId);
        Log.v("hfhfhfhf", nom);
    }

    /*public void displayQuestion(View v){
        Intent intent = new Intent(this, DisplayQuestion.class);
        startActivity(intent);
    }*/

    public void addQuestion(View v){
        Intent intent = new Intent(this, AddQuestion.class);
        Bundle b2 = new Bundle();
        b2.putString("key", coursId);
        b2.putString("name", nom);
        intent.putExtras(b2);
        startActivity(intent);
    }

    public void addQuestionQCM(View v){
        Intent intent = new Intent(this, AddQCM.class);
        Bundle b2 = new Bundle();
        b2.putString("key", coursId);
        b2.putString("name", nom);
        intent.putExtras(b2);
        startActivity(intent);
    }

    public void displayQuestionStud(View v){
        Intent intent = new Intent(this, DisplayQuestionStud.class);
        Bundle b2 = new Bundle();
        b2.putString("key", coursId);
        b2.putString("name", nom);
        intent.putExtras(b2);
        startActivity(intent);
    }

    public void goToMainActivity(View v){
        Intent intent = new Intent(this, MainActivity.class);
        startActivity(intent);
    }

    public void displayQuizz(View v) {
        Intent intent = new Intent(this, DisplayQuiz.class);
        Bundle b2 = new Bundle();
        b2.putString("key", coursId);
        b2.putString("name", nom);
        intent.putExtras(b2);
        startActivity(intent);
    }

    public void studentUI2(View v) {
        Intent intent = new Intent(this, StudentUI2.class);
        Bundle b2 = new Bundle();
        b2.putString("key", coursId);
        b2.putString("name", nom);
        intent.putExtras(b2);
        startActivity(intent);
    }

    public void annuler(View v) {
        finish();
    }
}
```


Overlapping Code:
```
tends AppCompatActivity {
Button btn;
BottomNavigationView bottomNavigationView;
Menu itemToHide;
TextView cours;
Bundle b;
String coursId;
String nom;
String s;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_studentui);
b = getIntent().getExtras();
cours = (TextView) findViewById(R.id.txtdashboard2);
s = cours.getText().toString();
cours.setText(s + " (" + b.getString("name") + ") ");
/*Window window = this.getWindow();
window.setStatusBarColor(ContextCompat.getColor(this,R.color.colorDarkRed));
ActionBar bar = getSupportActionBar();
bar.setBackgroundDrawable(new ColorDrawable(getResources().getColor(R.color.colorRed)));
bar.setTitle("AskNanterre : Etudiant");*/
/*btn = (Button)findViewById(R.id.stud_btn);
btn.setOnClickListener(
new View.OnClickListener()
{
public void onClick(View view)
{
Intent intent = new Intent(StudentUI.this, ProfessorUI.class);
startActivity(intent);
}
});*/
/*bottomNavigationView = (BottomNavigationView) findViewById(R.id.activity_main_bottom_navigation);
itemToHide = bottomNavigationView.getMenu();
itemToHide.findItem(R.id.action_goStud).setVisible(false);
bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() {
@Override
public boolean onNavigationItemSelected(@NonNull MenuItem item) {
switch (item.getItemId()) {
case R.id.action_home:
//Toast.makeText(StudentUI.this, "Recents", Toast.LENGTH_SHORT).show();
goToMainActivity();
break;
case R.id.action_goStud:
Toast.makeText(StudentUI.this, "Favorites", Toast.LENGTH_SHORT).show();
break;
case R.id.action_goProf:
//Toast.makeText(StudentUI.this, "Nearby", Toast.LENGTH_SHORT).show();
goToProfUIActivity();
break;
}
return true;
}
```
<Overlap Ratio: 0.9828444936358606>

---

--- 300 --
Question ID: 7e2cd5bf76a4cc1a86cef3d144d27bf3dddf8a08
Original Code:
```
public class TileEntityRopeLadderRenderer extends TileEntitySpecialRenderer {

	@Override
	public void renderTileEntityAt(TileEntity tileentity, double x, double y, double z, float f) {

		TileEntityRopeLadder rope = (TileEntityRopeLadder)tileentity;
		GL11.glPushMatrix();
		bindTexture(TextureMap.locationBlocksTexture);
		long ticks = OpenMods.proxy.getTicks(rope.worldObj);
		double offset = 0.0;
		if (rope.shouldAnimate()) {
			offset = (MathHelper.sin((float)(rope.yCoord + ((double)ticks / 5))) / 50);
		}
		ForgeDirection rot = rope.getRotation();
		GL11.glTranslated(x + 0.5 + (offset * rot.offsetX), y + 0.5, z + 0.5
				+ (offset * rot.offsetZ));
		GL11.glRotatef(BlockUtils.getRotationFromDirection(rot), 0, 1, 0);
		GL11.glDisable(GL11.GL_LIGHTING);

		Block b = OpenBlocks.Blocks.ropeLadder;
		Tessellator t = Tessellator.instance;
		GL11.glColor4f(1, 1, 1, 1);
		OpenRenderHelper.renderBlocks.setRenderBounds(-0.5, -0.5, -0.5, 0.5, 0.5, -0.4375);
		t.startDrawingQuads();

		OpenRenderHelper.renderBlocks.renderFaceZNeg(b, 0, 0, 0, b.getBlockTextureFromSide(0));
		OpenRenderHelper.renderBlocks.renderFaceZPos(b, 0, 0, 0, b.getBlockTextureFromSide(0));

		t.draw();

		GL11.glEnable(GL11.GL_LIGHTING);

		GL11.glPopMatrix();
	}

}
```


Overlapping Code:
```
opeLadderRenderer extends TileEntitySpecialRenderer {
@Override
public void renderTileEntityAt(TileEntity tileentity, double x, double y, double z, float f) {
TileEntityRopeLadder rope = (TileEntityRopeLadder)tileentity;
GL11.glPushMatrix();
bindTexture(TextureMap.locationBlocksTexture);
long ticks = OpenMods.proxy.getTicks(rope.worldObj);
double offset = 0.0;
if (rope.shouldAnimate()) {
offset = (MathHelper.sin((float)(rope.yCoord + ((double)ticks / 5))) / 50);
}
ForgeDirection rot = rope.getRotation();
GL11.glTranslated(x + 0.5 + (offset * rot.offsetX), y + 0.5, z + 0.5
+ (offset * rot.offsetZ));
GL11.glRotatef(BlockUtils.getRotationFromDirection(rot), 0, 1, 0);
GL11.glDisable(GL11.GL_LIGHTING);
Block b = OpenBlocks.Blocks.ropeLadder;
Tessellator t = Tessellator.instance;
GL11.glColor4f(1, 1, 1, 1);
OpenRenderHelper.renderBlocks.setRenderBounds(-0.5, -0.5, -0.5, 0.5, 0.5, -0.4375);
t.startDrawingQuads();
OpenRenderHelper.renderBlocks.renderFaceZNeg(b, 0, 0, 0, b.getBlockTextureFromSide(0));
OpenRenderHelper.renderBlocks.renderFaceZPos(b, 0, 0, 0, b.getBlockTextureFromSide(0));
t.draw();
GL11.glEnable(GL11.GL_LIGHTING);
GL11.glPopMatrix();
}
}
```
<Overlap Ratio: 0.9797639123102867>

---

--- 301 --
Question ID: 9948b3a68b97b3671e74ee572eb5877ca9633d38
Original Code:
```
public class PropertiesManagementMethods implements BaseTest {

    static String propertiesFilePath = "src/main/resources/config.properties";
    static String seleniumPropertiesFilePath = "src/main/resources/selenium.properties";
    static String environmentPropertiesFilePath = "src/main/resources/ENV.environment.properties";
    static String environment = System.getProperty("env").toLowerCase();

    public void setProperty(String propName, String propValue) {

        // create temp test file if not exists
        File file = new File(propertiesFilePath);

        try {
            if (file.createNewFile()) {
                Log.INFO("File: " + propertiesFilePath + " is created");
            }
        } catch (IOException e1) {
            e1.printStackTrace();
        }

        // load config file
        Properties props = null;
        try {
            FileInputStream in = new FileInputStream(propertiesFilePath);
            props = new Properties();
            props.load(in);
            in.close();
        } catch (Exception e) {

        }
        // edit config file
        try {
            FileOutputStream out = new FileOutputStream(propertiesFilePath);
            props.setProperty(propName, propValue);
            props.store(out, null);
            out.close();
        } catch (Exception e) {
        }
    }

    public String getProperty(String propName) {
        Properties prop = new Properties();

        InputStream is;
        try {
            is = new FileInputStream(propertiesFilePath);

            prop.load(is);
            String propertieValue = prop.getProperty(propName);

            is.close();

            return propertieValue;

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String getSeleniumProperty(String propName) {
        Properties prop = new Properties();

        InputStream is;
        try {
            is = new FileInputStream(seleniumPropertiesFilePath);

            prop.load(is);
            String propertieValue = prop.getProperty(propName);

            is.close();

            return propertieValue;

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    public String getEnvironmentProperty(String propName) {
        Properties prop = new Properties();

        InputStream is;
        try {
            is = new FileInputStream(environmentPropertiesFilePath.replace("ENV", environment));

            prop.load(is);
            String propertieValue = prop.getProperty(propName);

            is.close();

            return propertieValue;

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    // UTILS
    public static String getOS() {
        String OS = System.getProperty("os.name").toLowerCase();
        return OS;
    }

    public boolean isWindows() {
        String OS = getOS();
        return (OS.indexOf("win") >= 0);
    }

    public boolean isMac() {
        String OS = getOS();
        return (OS.indexOf("mac") >= 0);
    }

    public boolean isUnix() {
        String OS = getOS();
        return (OS.indexOf("nix") >= 0 || OS.indexOf("nux") >= 0 || OS.indexOf("aix") > 0);
    }
}
```


Overlapping Code:
```
thods implements BaseTest {
static String propertiesFilePath = "src/main/resources/config.properties";
static String seleniumPropertiesFilePath = "src/main/resources/selenium.properties";
static String environmentPropertiesFilePath = "src/main/resources/ENV.environment.properties";
static String environment = System.getProperty("env").toLowerCase();
public void setProperty(String propName, String propValue) {
// create temp test file if not exists
File file = new File(propertiesFilePath);
try {
if (file.createNewFile()) {
Log.INFO("File: " + propertiesFilePath + " is created");
}
} catch (IOException e1) {
e1.printStackTrace();
}
// load config file
Properties props = null;
try {
FileInputStream in = new FileInputStream(propertiesFilePath);
props = new Properties();
props.load(in);
in.close();
} catch (Exception e) {
}
// edit config file
try {
FileOutputStream out = new FileOutputStream(propertiesFilePath);
props.setProperty(propName, propValue);
props.store(out, null);
out.close();
} catch (Exception e) {
}
}
public String getProperty(String propName) {
Properties prop = new Properties();
InputStream is;
try {
is = new FileInputStream(propertiesFilePath);
prop.load(is);
String propertieValue = prop.getProperty(propName);
is.close();
return propertieValue;
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
return null;
}
public String getSeleniumProperty(String propName) {
Properties prop = new Properties();
InputStream is;
try {
is = new FileInputStream(seleniumPropertiesFilePath);
prop.load(is);
String propertieValue = prop.getProperty(propName);
is.close();
return propertieValue;
} catch (FileNotFoundException e) {
e.printStackTrace();
} catch (IOException e) {
e.printStackTrace();
}
return null;
}
public String getEnvironmentProperty(String propName) {
Propert
```
<Overlap Ratio: 0.9798728813559322>

---

--- 302 --
Question ID: 93e79422889aa11d4c9cdc1f8b909d253b6d7415
Original Code:
```
public class ReflectUtils {

	private static Class<?> androidBase64Class;
	
	private static Class<?> jdkBase64EncoderClass;
	
	private static Class<?> jdkBase64DecoderClass;
	
	private static Object jdkNewEncoder;
	
	private static Object jdkNewDecoder; 
	
	private static Map<String, Field> fields = new ConcurrentHashMap<String, Field>();
	
	static{
	    try
        {
            androidBase64Class = Class.forName("android.util.Base64");
        }
        catch (ClassNotFoundException e)
        {
        }
	    
        try {
			Class<?> base64 = Class.forName("java.util.Base64");
			jdkNewEncoder = base64.getMethod("getEncoder").invoke(null);
			jdkNewDecoder = base64.getMethod("getDecoder").invoke(null);
		} catch (Exception e1) {
		}
	    
	    try{
	        jdkBase64EncoderClass = Class.forName("sun.misc.BASE64Encoder");
	    }catch (ClassNotFoundException e) {
        }
	    
	    try{
	        jdkBase64DecoderClass = Class.forName("sun.misc.BASE64Decoder");
	    }catch (ClassNotFoundException e) {
        }
	    
	}
	
	public static String toBase64(byte[] data)
	{
	    if(androidBase64Class != null){
	        try{
	            Method m = androidBase64Class.getMethod("encode", byte[].class, int.class);
	            return new String((byte[])m.invoke(null, data, 2), Charset.defaultCharset());
	        }catch (Exception e) {
	        	throw new ServiceException(e);
            }
	    }
	    
	    if(jdkNewEncoder != null) {
	    	try{
	            Method m = jdkNewEncoder.getClass().getMethod("encode", byte[].class);
	            return new String((byte[])m.invoke(jdkNewEncoder, data), "UTF-8").replaceAll("\\s", "");
	        }catch (Exception e) {
	        	throw new ServiceException(e);
            }
	    }
	    
	    if(jdkBase64EncoderClass != null){
	        try{
	            Method m = jdkBase64EncoderClass.getMethod("encode", byte[].class);
	            return ((String)m.invoke(jdkBase64EncoderClass.getConstructor().newInstance(), data)).replaceAll("\\s", "");
	        }catch (Exception e) {
	        	throw new ServiceException(e);
            }
	    }
	    
	    throw new ServiceException("Failed to find a base64 encoder");
	}
	
	public static byte[] fromBase64(String b64Data) throws UnsupportedEncodingException
	{
	    if(androidBase64Class != null){
	        try{
	            Method m = androidBase64Class.getMethod("decode", byte[].class, int.class);
	            return (byte[])m.invoke(null, b64Data.getBytes("UTF-8"), 2);
	        }catch (Exception e) {
	        	throw new ServiceException(e);
            }
	    }
	    
	    if(jdkNewDecoder != null) {
	    	try{
	            Method m = jdkNewDecoder.getClass().getMethod("decode", byte[].class);
	            return (byte[])m.invoke(jdkNewDecoder, b64Data.getBytes("UTF-8"));
	        }catch (Exception e) {
	        	throw new ServiceException(e);
            }
	    }
	    
	    if(jdkBase64DecoderClass != null){
	        try{
                Method m = jdkBase64DecoderClass.getMethod("decodeBuffer", String.class);
                return (byte[])m.invoke(jdkBase64DecoderClass.getConstructor().newInstance(), b64Data);
            }catch (Exception e) {
            	throw new ServiceException(e);
            }
	    }
	    throw new ServiceException("Failed to find a base64 decoder");
	}
	
	
	public static void setInnerClient(Object obj, ObsClient obsClient) {
		if(obj != null && obsClient != null) {
			Class<?> clazz = obj.getClass();
			String name = clazz.getName();
			Field f = fields.get(name);
			try {
				if(f == null) {
					f = getFieldFromClass(clazz, "innerClient");
					f.setAccessible(true);
					fields.put(name, f);
				}
				f.set(obj, obsClient);
			} catch (Exception e) {
				throw new ObsException(e.getMessage(), e);
			} 
		}
	}

	private static Field getFieldFromClass(Class<?> clazz, String key) {
		do {
			try {
				return clazz.getDeclaredField(key);
			} catch (NoSuchFieldException e) {
				clazz = clazz.getSuperclass();
			} 
		}while(clazz != null);
		return null;
	}
	
}
```


Overlapping Code:
```
Utils {
private static Class<?> androidBase64Class;

private static Class<?> jdkBase64EncoderClass;

private static Class<?> jdkBase64DecoderClass;

private static Object jdkNewEncoder;

private static Object jdkNewDecoder; 

private static Map<String, Field> fields = new ConcurrentHashMap<String, Field>();

static{
try
{
androidBase64Class = Class.forName("android.util.Base64");
}
catch (ClassNotFoundException e)
{
}

try {
Class<?> base64 = Class.forName("java.util.Base64");
jdkNewEncoder = base64.getMethod("getEncoder").invoke(null);
jdkNewDecoder = base64.getMethod("getDecoder").invoke(null);
} catch (Exception e1) {
}

try{
jdkBase64EncoderClass = Class.forName("sun.misc.BASE64Encoder");
}catch (ClassNotFoundException e) {
}

try{
jdkBase64DecoderClass = Class.forName("sun.misc.BASE64Decoder");
}catch (ClassNotFoundException e) {
}

}

public static String toBase64(byte[] data)
{
if(androidBase64Class != null){
try{
Method m = androidBase64Class.getMethod("encode", byte[].class, int.class);
return new String((byte[])m.invoke(null, data, 2), Charset.defaultCharset());
}catch (Exception e) {
throw new ServiceException(e);
}
}

if(jdkNewEncoder != null) {
try{
Method m = jdkNewEncoder.getClass().getMethod("encode", byte[].class);
return new String((byte[])m.invoke(jdkNewEncoder, data), "UTF-8").replaceAll("\\s", "");
}catch (Exception e) {
throw new ServiceException(e);
}
}

if(jdkBase64EncoderClass != null){
try{
Method m = jdkBase64EncoderClass.getMethod("encode", byte[].class);
return ((String)m.invoke(jdkBase64EncoderClass.getConstructor().newInstance(), data)).replaceAll("\\s", "");
}catch (Exception e) {
throw new ServiceException(e);
}
}

throw new ServiceException("Failed to find a base64 encoder");
}

public static byte[] fromBase64(String b64Data) throws UnsupportedEncodingException
{
if(androidBase64Class != null){
try{
Method m = androidBase64Class.getMethod("decode", byte[].class, int.class);
return (byte[])m.invoke(null, b64Data.getBytes("UTF-8"), 2)
```
<Overlap Ratio: 0.9847365829640571>

---

--- 303 --
Question ID: f3909e6a2afaf2dfbe0b062794b512f8ba17e02a
Original Code:
```
public final class GetFileHash {

  private static final byte HORIZONTAL_TAB = 9;
  private static final byte LINE_FEED = 10;
  private static final byte CARRIAGE_RETURN = 13;
  private static final byte SPACE = 32;

  private GetFileHash() {}

  // Gets the 32-bit MurmurHash2 of the .jar file
  public static long getFileHash(Path path) throws IOException {

    // Reads .jar file and turns it into byte[]
    byte[] fileByteArray = Files.readAllBytes(path);

    // ArrayList with no whitespace
    List<Byte> noWs = new ArrayList<>();

    // Remove any whitespace characters
    for (byte b : fileByteArray) {
      if (!isWhitespaceCharacter(b)) {
        noWs.add(b);
      }
    }

    // Convert Byte ArrayList to byte array
    byte[] result = new byte[noWs.size()];
    for (int i = 0; i < noWs.size(); i++) {
      result[i] = noWs.get(i).byteValue();
    }

    return Murmur2.hash(result, result.length, 1);

  }

  // Determines if the byte is a whitespace character (look at an ASCII table)
  private static boolean isWhitespaceCharacter(byte b) {
    return b == HORIZONTAL_TAB || b == LINE_FEED || b == CARRIAGE_RETURN || b == SPACE;
  }

}
```


Overlapping Code:
```
static final byte HORIZONTAL_TAB = 9;
private static final byte LINE_FEED = 10;
private static final byte CARRIAGE_RETURN = 13;
private static final byte SPACE = 32;
private GetFileHash() {}
// Gets the 32-bit MurmurHash2 of the .jar file
public static long getFileHash(Path path) throws IOException {
// Reads .jar file and turns it into byte[]
byte[] fileByteArray = Files.readAllBytes(path);
// ArrayList with no whitespace
List<Byte> noWs = new ArrayList<>();
// Remove any whitespace characters
for (byte b : fileByteArray) {
if (!isWhitespaceCharacter(b)) {
noWs.add(b);
}
}
// Convert Byte ArrayList to byte array
byte[] result = new byte[noWs.size()];
for (int i = 0; i < noWs.size(); i++) {
result[i] = noWs.get(i).byteValue();
}
return Murmur2.hash(result, result.length, 1);
}
// Determines if the byte is a whitespace character (look at an ASCII table)
private static boolean isWhitespaceCharacter(byte b) {
return b == HORIZONTAL_TAB || b == LINE_FEED || b == CARRIAGE_RETURN || b == SPA
```
<Overlap Ratio: 0.9541984732824428>

---

--- 304 --
Question ID: a2aa1bfff4593de1db593dbc940d34ada2d14567
Original Code:
```
public class SNLDA extends AbstractSampler {

    public static final int POSITVE = 1;
    public static final int NEGATIVE = -1;
    // hyperparameters for fixed-height tree
    protected double[] alphas;          // [L-1]
    protected double[] betas;           // [L]
    protected double[] pis;     // [L-1] mean of bias coins
    protected double[] gammas;    // [L-1] scale of bias coins
    protected double rho;
    protected double mu;
    protected double[] sigmas;

    // inputs
    protected int[][] words; // all words
    protected double[] responses; // [D] continous responses
    protected int[] labels; // [D] binary responses
    protected ArrayList<Integer> docIndices; // indices of docs under consideration
    protected int V;    // vocabulary size
    protected int[] Ks; // [L-1]: number of children per node at each level
    protected PathAssumption path;
    // derived
    protected int D; // number of documents
    protected int L;
    // latent
    Node[][] z;
    Node root;
    // internal
    private int numTokensAccepted;
    private double[] docMeans;
    private boolean isBinary;
    private Set<Integer> positives;
    private double uniform;
    private boolean isRooted;

    // cached probabilities computed at the first level
    private HashMap<Node, Double> cachedProbabilities;

    public SNLDA() {
        this.basename = "SNLDA";
    }

    public SNLDA(String bname) {
        this.basename = bname;
    }

    public void configure(SNLDA sampler) {
        this.isBinary = sampler.isBinary;
        if (this.isBinary) {
            this.configureBinary(sampler.folder,
                    sampler.V,
                    sampler.Ks,
                    sampler.alphas,
                    sampler.betas,
                    sampler.pis,
                    sampler.gammas,
                    sampler.mu,
                    sampler.sigmas,
                    sampler.initState,
                    sampler.path,
                    sampler.paramOptimized,
                    sampler.isRooted,
                    sampler.BURN_IN,
                    sampler.MAX_ITER,
                    sampler.LAG,
                    sampler.REP_INTERVAL);
        } else {
            this.configureContinuous(sampler.folder,
                    sampler.V,
                    sampler.Ks,
                    sampler.alphas,
                    sampler.betas,
                    sampler.pis,
                    sampler.gammas,
                    sampler.rho,
                    sampler.mu,
                    sampler.sigmas,
                    sampler.initState,
                    sampler.path,
                    sampler.paramOptimized,
                    sampler.isRooted,
                    sampler.BURN_IN,
                    sampler.MAX_ITER,
                    sampler.LAG,
                    sampler.REP_INTERVAL);
        }
    }

    public void configureBinary(String folder,
            int V, int[] Ks,
            double[] alphas,
            double[] betas,
            double[] pis,
            double[] gammas,
            double mu,
            double[] sigmas,
            InitialState initState,
            PathAssumption pathAssumption,
            boolean paramOpt, boolean isRooted,
            int burnin, int maxiter, int samplelag, int repInt) {
        if (verbose) {
            logln("Configuring ...");
        }
        this.folder = folder;
        this.V = V;
        this.uniform = 1.0 / this.V;
        this.Ks = Ks;
        this.L = this.Ks.length + 1;

        this.alphas = alphas;
        this.betas = betas;
        this.pis = pis;
        this.gammas = gammas;
        this.mu = mu;
        this.sigmas = sigmas;

        this.hyperparams = new ArrayList<Double>();
        this.sampledParams = new ArrayList<ArrayList<Double>>();
        this.sampledParams.add(cloneHyperparameters());

        this.BURN_IN = burnin;
        this.MAX_ITER = maxiter;
        this.LAG = samplelag;
        this.REP_INTERVAL = repInt;

        this.initState = initState;
        this.path = pathAssumption;
        this.paramOptimized = paramOpt;
        this.prefix += initState.toString();
        this.isBinary = true;
        this.isRooted = isRooted;

        this.setName();

        if (verbose) {
            logln("--- V = " + V);
            logln("--- Ks = " + MiscUtils.arrayToString(this.Ks));
            logln("--- folder\t" + folder);
            logln("--- alphas:\t" + MiscUtils.arrayToString(alphas));
            logln("--- betas:\t" + MiscUtils.arrayToString(betas));
            logln("--- pis:\t" + MiscUtils.arrayToString(pis));
            logln("--- gammas:\t" + MiscUtils.arrayToString(gammas));
            logln("--- rho:\t" + MiscUtils.formatDouble(rho));
            logln("--- mu:\t" + MiscUtils.formatDouble(mu));
            logln("--- sigmas:\t" + MiscUtils.arrayToString(sigmas));
            logln("--- burn-in:\t" + BURN_IN);
            logln("--- max iter:\t" + MAX_ITER);
            logln("--- sample lag:\t" + LAG);
            logln("--- report interval:\t" + REP_INTERVAL);
            logln("--- paramopt:\t" + paramOptimized);
            logln("--- initialize:\t" + this.initState);
            logln("--- path assumption:\t" + this.path);
            logln("--- is rooted:\t" + this.isRooted);
        }

        validateInputHyperparameters();
    }

    public void configureContinuous(String folder,
            int V, int[] Ks,
            double[] alphas,
            double[] betas,
            double[] pis,
            double[] gammas,
            double rho,
            double mu,
            double[] sigmas,
            InitialState initState,
            PathAssumption pathAssumption,
            boolean paramOpt, boolean isRooted,
            int burnin, int maxiter, int samplelag, int repInt) {
        if (verbose) {
            logln("Configuring ...");
        }
        this.folder = folder;
        this.V = V;
        this.uniform = 1.0 / this.V;
        this.Ks = Ks;
        this.L = this.Ks.length + 1;

        this.alphas = alphas;
        this.betas = betas;
        this.pis = pis;
        this.gammas = gammas;
        this.rho = rho;
        this.mu = mu;
        this.sigmas = sigmas;

        this.hyperparams = new ArrayList<Double>();
        this.sampledParams = new ArrayList<ArrayList<Double>>();
        this.sampledParams.add(cloneHyperparameters());

        this.BURN_IN = burnin;
        this.MAX_ITER = maxiter;
        this.LAG = samplelag;
        this.REP_INTERVAL = repInt;

        this.initState = initState;
        this.path = pathAssumption;
        this.paramOptimized = paramOpt;
        this.prefix += initState.toString();
        this.isBinary = false;
        this.isRooted = isRooted;

        this.setName();

        if (verbose) {
            logln("--- V = " + V);
            logln("--- Ks = " + MiscUtils.arrayToString(this.Ks));
            logln("--- folder\t" + folder);
            logln("--- alphas:\t" + MiscUtils.arrayToString(alphas));
            logln("--- betas:\t" + MiscUtils.arrayToString(betas));
            logln("--- pis:\t" + MiscUtils.arrayToString(pis));
            logln("--- gammas:\t" + MiscUtils.arrayToString(gammas));
            logln("--- rho:\t" + MiscUtils.formatDouble(rho));
            logln("--- mu:\t" + MiscUtils.formatDouble(mu));
            logln("--- sigmas:\t" + MiscUtils.arrayToString(sigmas));
            logln("--- burn-in:\t" + BURN_IN);
            logln("--- max iter:\t" + MAX_ITER);
            logln("--- sample lag:\t" + LAG);
            logln("--- report interval:\t" + REP_INTERVAL);
            logln("--- paramopt:\t" + paramOptimized);
            logln("--- initialize:\t" + this.initState);
            logln("--- path assumption:\t" + this.path);
            logln("--- is rooted:\t" + this.isRooted);
        }

        validateInputHyperparameters();
    }

    private void validateInputHyperparameters() {
        if (L - 1 != Ks.length) {
            throw new MismatchRuntimeException(L - 1, Ks.length);
        }
        if (alphas.length != L - 1) {
            throw new MismatchRuntimeException(alphas.length, L - 1);
        }
        if (betas.length != L) {
            throw new MismatchRuntimeException(betas.length, L);
        }
        if (pis.length != L - 1) {
            throw new MismatchRuntimeException(pis.length, L - 1);
        }
        if (gammas.length != L - 1) {
            throw new MismatchRuntimeException(gammas.length, L - 1);
        }
        if (sigmas.length != L) {
            throw new MismatchRuntimeException(sigmas.length, L - 1);
        }
        if (!isBinary && rho == 0.0) {
            throw new RuntimeException("Rho should not be 0 when the response is continuous");
        }
    }

    protected void setName() {
        StringBuilder str = new StringBuilder();
        str.append(this.prefix)
                .append("_").append(basename);
        str.append("_Ks");
        for (int K : Ks) {
            str.append("-").append(K);
        }
        str.append("_B-").append(BURN_IN)
                .append("_M-").append(MAX_ITER)
                .append("_L-").append(LAG);
        str.append("_a");
        for (double la : alphas) {
            str.append("-").append(MiscUtils.formatDouble(la));
        }
        str.append("_b");
        for (double b : betas) {
            str.append("-").append(MiscUtils.formatDouble(b));
        }
        str.append("_p");
        for (double gm : pis) {
            str.append("-").append(MiscUtils.formatDouble(gm));
        }
        str.append("_g");
        for (double gs : gammas) {
            str.append("-").append(MiscUtils.formatDouble(gs));
        }
        str.append("_r-").append(MiscUtils.formatDouble(rho));
        str.append("_m-").append(MiscUtils.formatDouble(mu));
        str.append("_s");
        for (double s : sigmas) {
            str.append("-").append(MiscUtils.formatDouble(s));
        }
        str.append("_opt-").append(this.paramOptimized);
        str.append("_bin-").append(this.isBinary);
        str.append("_path-").append(this.path);
        str.append("_root-").append(this.isRooted);
        this.name = str.toString();
    }

    protected double getAlpha(int l) {
        return this.alphas[l];
    }

    protected double getBeta(int l) {
        return this.betas[l];
    }

    protected double getPi(int l) {
        return this.pis[l];
    }

    protected double getGamma(int l) {
        return this.gammas[l];
    }

    protected double getSigma(int l) {
        return this.sigmas[l];
    }

    @Override
    public String getCurrentState() {
        return this.getSamplerFolderPath() + "\n"
                + printGlobalTreeSummary() + "\n";
    }

    public boolean isLeafNode(int level) {
        return level == L - 1;
    }

    public double[] getPredictedValues() {
        return docMeans;
    }

    /**
     * Setting up text data.
     *
     * @param docWords
     * @param docIndices
     */
    private void setupTextData(int[][] docWords, ArrayList<Integer> docIndices) {
        this.docIndices = docIndices;
        if (this.docIndices == null) { // add all documents
            this.docIndices = new ArrayList<>();
            for (int dd = 0; dd < docWords.length; dd++) {
                this.docIndices.add(dd);
            }
        }
        this.numTokens = 0;
        this.D = this.docIndices.size();
        this.words = new int[D][];
        for (int ii = 0; ii < D; ii++) {
            int dd = this.docIndices.get(ii);
            this.words[ii] = docWords[dd];
            this.numTokens += this.words[ii].length;
        }

        if (verbose) {
            logln("--- # all docs:\t" + words.length);
            logln("--- # selected docs:\t" + D);
            logln("--- # tokens:\t" + numTokens);
        }
    }

    /**
     * Set up continuous responses.
     *
     * @param docResponses
     */
    public void setContinuousResponses(double[] docResponses) {
        this.responses = new double[D];
        for (int ii = 0; ii < D; ii++) {
            this.responses[ii] = docResponses[this.docIndices.get(ii)];
        }
        if (verbose) {
            logln("--- continuous responses:");
            logln("--- --- mean\t" + MiscUtils.formatDouble(
                    StatUtils.mean(responses)));
            logln("--- --- stdv\t" + MiscUtils.formatDouble(
                    StatUtils.standardDeviation(responses)));
            int[] histogram = StatUtils.bin(responses, 10);
            for (int ii = 0; ii < histogram.length; ii++) {
                logln("--- --- " + ii + "\t" + histogram[ii]);
            }
        }
    }

    /**
     * Set up binary responses.
     *
     * @param docLabels
     */
    public void setBinaryResponses(int[] docLabels) {
        this.labels = new int[D];
        this.positives = new HashSet<Integer>();
        for (int ii = 0; ii < D; ii++) {
            int dd = this.docIndices.get(ii);
            this.labels[ii] = docLabels[dd];
            if (this.labels[ii] == POSITVE) {
                this.positives.add(ii);
            }
        }
        if (verbose) {
            logln("--- binary responses:");
            int posCount = this.positives.size();
            logln("--- --- # postive: " + posCount
                    + " (" + ((double) posCount / D) + ")");
            logln("--- --- # negative: " + (D - posCount));
        }
    }

    /**
     * Set up training data with continuous responses.
     *
     * @param docWords All documents
     * @param docIndices Indices of selected documents. If this is null, all
     * documents are considered.
     * @param docResponses Continuous responses
     */
    public void train(int[][] docWords,
            ArrayList<Integer> docIndices,
            double[] docResponses) {
        setupTextData(docWords, docIndices);
        setContinuousResponses(docResponses);
    }

    /**
     * Set up training data with binary responses.
     *
     * @param docWords All documents
     * @param docIndices Indices of selected documents. If this is null, all
     * documents are considered.
     * @param docLabels Binary labels
     */
    public void train(int[][] docWords,
            ArrayList<Integer> docIndices,
            int[] docLabels) {
        setupTextData(docWords, docIndices);
        setBinaryResponses(docLabels);
    }

    /**
     * Set up test data.
     *
     * @param docWords Test documents
     * @param docIndices Indices of test documents
     */
    public void test(int[][] docWords, ArrayList<Integer> docIndices) {
        setupTextData(docWords, docIndices);
    }

    /**
     * Set up test data.
     *
     * @param stateFile Input file storing trained model
     * @param testStateFile Output file to store assignments
     * @param predictionFile Output file to store predictions at different test
     * iterations using the given trained model
     * @return Prediction on all documents using the given model
     */
    public double[] sampleTest(File stateFile, File testStateFile, File predictionFile) {
        setTestConfigurations(BURN_IN / 2, MAX_ITER / 2, LAG / 2);
        if (stateFile == null) {
            stateFile = getFinalStateFile();
        }
        inputModel(stateFile.toString()); // input stored model
        initializeDataStructure(); // initialize data

        // store predictions at different test iterations
        ArrayList<double[]> predResponsesList = new ArrayList<double[]>();

        // sample topic assignments for test document
        for (iter = 0; iter < this.testMaxIter; iter++) {
            isReporting = verbose && iter % testRepInterval == 0;
            if (isReporting) {
                String str = "Iter " + iter + "/" + testMaxIter
                        + ". current thread: " + Thread.currentThread().getId();
                if (iter < BURN_IN) {
                    logln("--- Burning in. " + str + "\n" + getCurrentState());
                } else {
                    logln("--- Sampling. " + str + "\n" + getCurrentState());
                }
            }

            if (iter == 0) {
                sampleZs(!REMOVE, !ADD, !REMOVE, ADD);
            } else {
                sampleZs(!REMOVE, !ADD, REMOVE, ADD);
            }

            // store prediction (on all documents) at a test iteration
            if (iter >= this.testBurnIn && iter % this.testSampleLag == 0) {
                double[] predResponses = new double[D];
                System.arraycopy(docMeans, 0, predResponses, 0, D);
                predResponsesList.add(predResponses);

                if (responses != null) { // debug
                    evaluatePerformances();
                }
            }
        }

        // output state file containing the assignments for test documents
        if (testStateFile != null) {
            outputState(testStateFile.getAbsolutePath(), false, true);
        }

        // store predictions if necessary
        if (predictionFile != null) {
            PredictionUtils.outputSingleModelRegressions(predictionFile, predResponsesList);
        }

        // average over all stored predictions
        double[] predictions = new double[D];
        for (int dd = 0; dd < D; dd++) {
            for (double[] predResponses : predResponsesList) {
                predictions[dd] += predResponses[dd] / predResponsesList.size();
            }
        }
        return predictions;
    }

    @Override
    public void initialize() {
        initialize(null, null);
    }

    public void initialize(double[][] priorTopics, double[] initEtas) {
        if (verbose) {
            logln("Initializing ...");
        }
        iter = INIT;
        isReporting = true;
        initializeModelStructure(priorTopics, initEtas);
        initializeDataStructure();
        initializeAssignments();
        updateEtas();

        if (verbose) {
            logln("--- Done initializing.\n" + printGlobalTree());
            logln("\n" + printGlobalTreeSummary() + "\n");
            getLogLikelihood();
        }

        outputTopicTopWords(new File(getSamplerFolderPath(), "init-" + TopWordFile), 20);
        validate("Initialized");
    }

    protected void initializeModelFirstLevelNodes(double[][] priorTopics, double[] initEtas) {
        int level = 1;
        for (int kk = 0; kk < Ks[0]; kk++) {
            // prior topic
            double[] prior;
            if (priorTopics == null) {
                prior = new double[V];
                Arrays.fill(prior, uniform);
            } else {
                prior = priorTopics[kk];
            }

            // initial eta
            double eta;
            if (initEtas != null) {
                eta = initEtas[kk];
            } else {
                eta = SamplerUtils.getGaussian(mu, getSigma(level));
            }

            // initialize
            DirMult topic = new DirMult(V, getBeta(1) * V, prior);
            Node node = new Node(iter, kk, level, topic, root, eta);
            this.root.addChild(kk, node);
        }
    }

    protected void initializeModelStructure(double[][] priorTopics, double[] initEtas) {
        if (verbose) {
            logln("--- Initializing model structure ...");
        }

        // initialize root node
        DirMult rootTopic = new DirMult(V, getBeta(0) * V, uniform);
        double rootEta = SamplerUtils.getGaussian(mu, getSigma(0));
        this.root = new Node(iter, 0, 0, rootTopic, null, rootEta);

        // first level
        initializeModelFirstLevelNodes(priorTopics, initEtas);
        Queue<Node> queue = new LinkedList<>();
        for (Node child : root.getChildren()) {
            queue.add(child);
        }

        // from 2nd-level downward
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int level = node.getLevel();
            if (level < L - 1) {
                for (int kk = 0; kk < Ks[level]; kk++) {
                    DirMult topic = new DirMult(V, getBeta(level + 1) * V, uniform);
                    Node child = new Node(iter, kk, level + 1, topic, node,
                            SamplerUtils.getGaussian(mu, getSigma(level)));
                    node.addChild(kk, child);
                    queue.add(child);
                }
            }
        }

        // initialize pi's and theta's
        Stack<Node> stack = new Stack<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            if (node.getLevel() < L - 1) {
                node.initializeGlobalTheta();
                node.initializeGlobalPi();
                for (Node child : node.getChildren()) {
                    stack.add(child);
                }
            }
        }

        if (verbose) {
            logln("--- --- Initialized model structure.\n" + printGlobalTreeSummary());
        }
    }

    protected void initializeDataStructure() {
        if (verbose) {
            logln("--- Initializing data structure ...");
        }
        this.z = new Node[D][];
        for (int dd = 0; dd < D; dd++) {
            this.z[dd] = new Node[words[dd].length];
        }
        this.docMeans = new double[D];
    }

    protected void initializeAssignments() {
        if (verbose) {
            logln("--- Initializing assignments. " + initState);
        }
        switch (initState) {
            case RANDOM:
                initializeRandomAssignments();
                break;
            case PRESET:
                initializePresetAssignments();
                break;
            default:
                throw new RuntimeException("Initialization not supported");
        }
    }

    private void initializeRandomAssignments() {
        sampleZs(!REMOVE, ADD, !REMOVE, ADD, !OBSERVED);
    }

    private void initializePresetAssignments() {
//        SLDA slda = new SLDA();
//        slda.setDebug(false);
//        slda.setVerbose(verbose);
//        slda.setLog(false);
//        
//        slda.configure(new File(foldFolder, modelFolder).getAbsolutePath(),
//                trainData.getWordVocab().size(), K,
//                alpha, beta, rho, mu, sigma,
//                initState, paramOpt, hasBias,
//                burn_in, max_iters, sample_lag, report_interval);
//        
//        LDA lda = runLDA(words, Ks[0], V, null);
//        int[][] ldaZs = lda.getZs();
//
//        for (int dd = 0; dd < D; dd++) {
//            for (int nn = 0; nn < words[dd].length; nn++) {
//                Node sampledNode = sampleNode(dd, nn, root.getChild(ldaZs[dd][nn]));
//                addToken(dd, nn, sampledNode, ADD, ADD);
//            }
//        }
    }

    /**
     * Add a token to a node.
     *
     * @param dd
     * @param nn
     * @param node
     * @param addToData
     * @param addToModel
     */
    private void addToken(int dd, int nn, Node node,
            boolean addToData, boolean addToModel) {
        if (addToModel) {
            node.getContent().increment(words[dd][nn]);
            Node tempNode = node;
            while (tempNode != null) {
                tempNode.incrementSubtreeWordCount(words[dd][nn]);
                tempNode = tempNode.getParent();
            }
        }
        if (addToData) {
            docMeans[dd] += node.pathEta / this.words[dd].length;
            node.nodeDocCounts.increment(dd);
            Node tempNode = node;
            while (tempNode != null) {
                tempNode.subtreeDocCounts.increment(dd);
                tempNode = tempNode.getParent();
            }
        }
    }

    /**
     * Remove a token from a node.
     *
     * @param dd
     * @param nn
     * @param node
     * @param removeFromData
     * @param removeFromModel
     */
    private void removeToken(int dd, int nn, Node node,
            boolean removeFromData, boolean removeFromModel) {
        if (removeFromData) {
            docMeans[dd] -= node.pathEta / this.words[dd].length;
            node.nodeDocCounts.decrement(dd);
            Node tempNode = node;
            while (tempNode != null) {
                tempNode.subtreeDocCounts.decrement(dd);
                tempNode = tempNode.getParent();
            }
        }
        if (removeFromModel) {
            node.getContent().decrement(words[dd][nn]);
            Node tempNode = node;
            while (tempNode != null) {
                tempNode.decrementSubtreeWordCount(words[dd][nn]);
                tempNode = tempNode.getParent();
            }
        }
    }

    @Override
    public void iterate() {
        if (isReporting) {
            System.out.println("\n");
            logln("Iteration " + iter + " / " + MAX_ITER);
        }
        sampleZs(REMOVE, ADD, REMOVE, ADD, OBSERVED);
        updateEtas();
    }

    // ONLY FOR DEBUGGING
    private Node sampleNodeSimple(int dd, int nn, boolean observed) {
        double[] logprobs = new double[Ks[0]];
        for (int kk = 0; kk < Ks[0]; kk++) {
            Node node = root.getChild(kk);
            logprobs[kk] = Math.log(node.subtreeDocCounts.getCount(dd) + getAlpha(0))
                    + Math.log(node.getNodeWordProbability(words[dd][nn]));
            if (observed) {
                double mean = docMeans[dd] + node.pathEta / words[dd].length;
                logprobs[kk] += StatUtils.logNormalProbability(responses[dd], mean, Math.sqrt(rho));
            }
        }
        int sampledZ = SamplerUtils.logMaxRescaleSample(logprobs);
        return root.getChild(sampledZ);
    }

    /**
     * Gibbs sample node assignment for all tokens.
     *
     * @param removeFromModel
     * @param addToModel
     * @param removeFromData
     * @param addToData
     * @return Elapsed time
     */
    protected long sampleZs(boolean removeFromModel, boolean addToModel,
            boolean removeFromData, boolean addToData) {
        if (isReporting) {
            logln("+++ Gibbs sampling Zs ...");
        }
        numTokensChanged = 0;
        long sTime = System.currentTimeMillis();
        for (int dd = 0; dd < D; dd++) {
            for (int nn = 0; nn < words[dd].length; nn++) {
                // remove
                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);

                Node sampledNode = sampleNode(dd, nn, root);
                if (z[dd][nn] == null || !z[dd][nn].equals(sampledNode)) {
                    numTokensChanged++;
                }
                z[dd][nn] = sampledNode;

                // add
                addToken(dd, nn, z[dd][nn], addToData, addToModel);
            }
        }

        long eTime = System.currentTimeMillis() - sTime;
        if (isReporting) {
            logln("--- --- time: " + eTime);
            logln("--- --- # tokens: " + numTokens
                    + ". # changed: " + numTokensChanged
                    + " (" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + ")"
            );
        }
        return eTime;
    }

    /**
     * MH sample node assignment for all tokens.
     *
     * @param removeFromModel
     * @param addToModel
     * @param removeFromData
     * @param addToData
     * @param observed
     * @return Elapsed time
     */
    protected long sampleZs(boolean removeFromModel, boolean addToModel,
            boolean removeFromData, boolean addToData, boolean observed) {
        if (isReporting) {
            logln("+++ MH-sampling Zs ...");
        }
        numTokensChanged = 0;
        numTokensAccepted = 0;

        long sTime = System.currentTimeMillis();
        for (int dd = 0; dd < D; dd++) {
            for (int nn = 0; nn < words[dd].length; nn++) {
                // remove
                removeToken(dd, nn, z[dd][nn], removeFromData, removeFromModel);

                boolean accept = false;
                Node sampledNode = sampleNode(dd, nn, root);
                if (z[dd][nn] == null) {
                    accept = true;
                    numTokensChanged++;
                    numTokensAccepted++;
                } else if (sampledNode.equals(z[dd][nn])) {
                    accept = true;
                    numTokensAccepted++;
                } else {
                    if (evaluateProposedNode(dd, nn, z[dd][nn], sampledNode, observed)) {
                        accept = true;
                        numTokensAccepted++;
                    }
                }
                if (accept) {
                    if (z[dd][nn] != null && !z[dd][nn].equals(sampledNode)) {
                        numTokensChanged++;
                    }
                    z[dd][nn] = sampledNode;
                }

                // add
                addToken(dd, nn, z[dd][nn], addToData, addToModel);
            }
        }

        long eTime = System.currentTimeMillis() - sTime;
        if (isReporting) {
            logln("--- --- time: " + eTime);
            logln("--- --- # tokens: " + numTokens
                    + ". # changed: " + numTokensChanged
                    + " (" + MiscUtils.formatDouble((double) numTokensChanged / numTokens) + ")"
                    + ". # accepted: " + numTokensAccepted
                    + " (" + MiscUtils.formatDouble((double) numTokensAccepted / numTokens) + ")");
        }
        return eTime;
    }

    /**
     * Recursively sample node level-by-level.
     *
     * @param dd
     * @param nn
     * @param curNode
     */
    private Node sampleNode(int dd, int nn, Node curNode) {
        if (curNode.isLeaf()) {
            return curNode;
        }
        if (curNode.isRoot()) {
            cachedProbabilities = new HashMap<>();
        }

        int level = curNode.getLevel();
        ArrayList<Node> nodeList = new ArrayList<>();
        ArrayList<Double> probList = new ArrayList<>();

        // staying at this node
        double gamma = getGamma(level);
        double stayprob;
        if (curNode.isRoot() && !isRooted) {
            stayprob = 0.0;
        } else {
            stayprob = (curNode.nodeDocCounts.getCount(dd) + gamma * curNode.pi)
                    / (curNode.subtreeDocCounts.getCount(dd) + gamma);
            double wordprob = curNode.getNodeWordProbability(words[dd][nn]);
            double prob = stayprob * wordprob;
            probList.add(prob);
            nodeList.add(curNode);

            if (curNode.isRoot()) {
                cachedProbabilities.put(curNode, prob);
            }
        }

        // moving to one of the children nodes
        double alpha = getAlpha(level);
        double passprob = 1.0 - stayprob;
        int KK = curNode.getNumChildren();
        double norm = curNode.getPassingCount(dd) + alpha * KK;
        for (Node child : curNode.getChildren()) {
            int kk = child.getIndex();
            double pathprob = (child.subtreeDocCounts.getCount(dd)
                    + alpha * KK * curNode.theta[kk]) / norm;
            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);
            double prob = passprob * pathprob * wordprob;
            probList.add(prob);
            nodeList.add(child);

            if (curNode.isRoot()) {
                cachedProbabilities.put(child, prob);
            }
        }

        int sampledIdx = SamplerUtils.scaleSample(probList);
        Node sampledNode = nodeList.get(sampledIdx);

        if (sampledNode.equals(curNode)) {
            return curNode;
        } else {
            return sampleNode(dd, nn, sampledNode);
        }
    }

    /**
     * Evaluate proposed node using Metropolis-Hastings algorithm.
     *
     * @param dd
     * @param nn
     * @param curNode
     * @param newNode
     * @param observed
     */
    private boolean evaluateProposedNode(int dd, int nn,
            Node curNode, Node newNode, boolean observed) {
        double newNodeTrueProb = getTrueLogProbability(dd, nn, newNode, observed);
        double curNodeTrueProb = getTrueLogProbability(dd, nn, curNode, observed);

        double newNodePropProb = getProporalProbability(dd, nn, newNode);
        double curNodePropProb = getProporalProbability(dd, nn, curNode);

        double ratio = (newNodeTrueProb * curNodePropProb) / (curNodeTrueProb * newNodePropProb);
        return rand.nextDouble() < Math.min(1.0, ratio);
    }

    private double getTrueLogProbability(int dd, int nn, Node node, boolean observed) {
        double lp = node.getNodeWordProbability(words[dd][nn]);
        if (observed) {
            lp *= Math.exp(getResponseLogLikelihood(dd, node));
        }
        lp *= getActualPathProbability(dd, nn, node, node);
        Node source = node.getParent();
        Node target = node;
        while (!target.isRoot()) {
            lp *= getActualPathProbability(dd, nn, source, target);
            target = source;
            source = source.getParent();
        }
        return lp;
    }

    private double getActualPathProbability(int dd, int nn, Node source, Node target) {
        int level = source.getLevel();
        if (level == L - 1) { // leaf node
            return 1.0;
        }
        double stayprob;
        if (source.isRoot() && !isRooted) {
            stayprob = 0.0;
        } else {
            stayprob = (source.nodeDocCounts.getCount(dd) + getGamma(level) * source.pi)
                    / (source.subtreeDocCounts.getCount(dd) + getGamma(level));
        }
        if (source.equals(target)) {
            return (stayprob);
        }

        double alpha = getAlpha(level);
        double passprob = 1.0 - stayprob;
        int KK = source.getNumChildren();
        double pathprob = (target.subtreeDocCounts.getCount(dd) + alpha * KK * source.theta[target.getIndex()])
                / (source.getPassingCount(dd) + alpha * KK);
        return (passprob * pathprob);
    }

    private double getProporalProbability(int dd, int nn, Node node) {
        double prob = getProposalPathProbability(dd, nn, node, node);
        Node source = node.getParent();
        Node target = node;
        while (!target.isRoot()) {
            prob *= getProposalPathProbability(dd, nn, source, target);
            target = source;
            source = source.getParent();
        }
        return prob;
    }

    private double getProposalPathProbability(int dd, int nn, Node source, Node target) {
        int level = source.getLevel();
        if (level == 0) { // use cached probabilities
            double totalProb = 0.0;
            for (double prob : cachedProbabilities.values()) {
                totalProb += prob;
            }
            Double prob = cachedProbabilities.get(target);
            if (prob == null) {
                throw new RuntimeException("Null probability");
            }
            return (prob / totalProb);
        } else if (level == L - 1) { // leaf node
            return 1.0;
        }

        double gamma = getGamma(level);
        double num = 0.0;
        double den = 0.0;

        double stayprob;
        if (source.isRoot() && !isRooted) {
            stayprob = 0.0;
        } else {
            stayprob = (source.nodeDocCounts.getCount(dd) + gamma * source.pi)
                    / (source.subtreeDocCounts.getCount(dd) + gamma);
            double wordprob = source.getNodeWordProbability(words[dd][nn]);
            double prob = stayprob * wordprob;
            if (source.equals(target)) {
                num = prob;
            }
            den += prob;
        }

        double alpha = getAlpha(level);
        double passprob = 1.0 - stayprob;
        int KK = source.getNumChildren();
        double norm = source.getPassingCount(dd) + alpha * KK;
        for (Node child : source.getChildren()) {
            int kk = child.getIndex();
            double pathprob = (child.subtreeDocCounts.getCount(dd)
                    + alpha * KK * source.theta[kk]) / norm;
            double wordprob = child.getSubtreeWordProbability(words[dd][nn]);
            double prob = passprob * pathprob * wordprob;
            if (target.equals(child)) {
                num = prob;
            }
            den += prob;
        }
        return (num / den);
    }

    private double getResponseLogLikelihood(int dd, Node node) {
        double aMean = docMeans[dd] + node.pathEta / this.words[dd].length;
        double resLLh;
        if (isBinary) {
            resLLh = getLabelLogLikelihood(labels[dd], aMean);
        } else {
            resLLh = StatUtils.logNormalProbability(responses[dd], aMean, Math.sqrt(rho));
        }
        return resLLh;
    }

    private double getLabelLogLikelihood(int label, double dotProb) {
        double logNorm = Math.log(Math.exp(dotProb) + 1);
        if (label == POSITVE) {
            return dotProb - logNorm;
        } else {
            return -logNorm;
        }
    }

    /**
     * Update regression parameters using L-BFGS.
     *
     * @return Elapsed time
     */
    public long updateEtas() {
        if (isReporting) {
            logln("+++ Updating eta's ...");
        }
        long sTime = System.currentTimeMillis();

        // list of nodes
        ArrayList<Node> nodeList = getNodeList();
        int N = nodeList.size();

        // design matrix
        SparseVector[] designMatrix = new SparseVector[D];
        for (int aa = 0; aa < D; aa++) {
            designMatrix[aa] = new SparseVector(N);
        }

        for (int kk = 0; kk < N; kk++) {
            Node node = nodeList.get(kk);
            if (node.isRoot()) {
                for (int dd = 0; dd < D; dd++) {
                    designMatrix[dd].set(kk, 1.0);
                }
            } else {
                for (int dd : node.subtreeDocCounts.getIndices()) {
                    int count = node.subtreeDocCounts.getCount(dd);
                    double val = (double) count / this.words[dd].length;
                    designMatrix[dd].change(kk, val);
                }
            }
        }

        // current params
        double[] etaArray = new double[N];
        double[] sigmaArray = new double[N];
        for (int kk = 0; kk < N; kk++) {
            etaArray[kk] = nodeList.get(kk).eta;
            sigmaArray[kk] = getSigma(nodeList.get(kk).getLevel());
        }

        boolean converged = false;
        if (isBinary) {
            RidgeLogisticRegressionOptimizable optimizable = new RidgeLogisticRegressionOptimizable(
                    labels, etaArray, designMatrix, mu, sigmaArray);
            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);
            try {
                converged = optimizer.optimize();
            } catch (Exception ex) {
                ex.printStackTrace();
            }

            // update regression parameters
            for (int kk = 0; kk < N; kk++) {
                nodeList.get(kk).eta = optimizable.getParameter(kk);
            }
        } else {
            RidgeLinearRegressionOptimizable optimizable = new RidgeLinearRegressionOptimizable(
                    responses, etaArray, designMatrix, rho, mu, sigmaArray);
            LimitedMemoryBFGS optimizer = new LimitedMemoryBFGS(optimizable);

            try {
                converged = optimizer.optimize();
            } catch (Exception ex) {
                ex.printStackTrace();
            }

            // update regression parameters
            for (int kk = 0; kk < N; kk++) {
                nodeList.get(kk).eta = optimizable.getParameter(kk);
            }
        }

        // update document means
        for (int dd = 0; dd < D; dd++) {
            docMeans[dd] = 0.0;
            for (int kk : designMatrix[dd].getIndices()) {
                docMeans[dd] += designMatrix[dd].get(kk) * nodeList.get(kk).eta;
            }
        }

        // update path thetas
        updatePathEtas();

        long eTime = System.currentTimeMillis() - sTime;
        if (isReporting) {
            logln("--- converged? " + converged
                    + ". " + designMatrix.length + " x " + nodeList.size());
            logln("--- --- time: " + eTime);
            evaluatePerformances();
        }
        return eTime;
    }

    protected void evaluatePerformances() {
        if (isBinary) {
            double[] predVals = new double[D];
            for (int d = 0; d < D; d++) {
                double expDotProd = Math.exp(docMeans[d]);
                double docPred = expDotProd / (expDotProd + 1);
                predVals[d] = docPred;
            }

            ArrayList<RankingItem<Integer>> rankDocs = new ArrayList<RankingItem<Integer>>();
            for (int d = 0; d < D; d++) {
                rankDocs.add(new RankingItem<Integer>(d, predVals[d]));
            }
            Collections.sort(rankDocs);
            int[] preds = new int[D];
            for (int ii = 0; ii < this.positives.size(); ii++) {
                int d = rankDocs.get(ii).getObject();
                preds[d] = POSITVE;
            }

            ClassificationEvaluation eval = new ClassificationEvaluation(labels, preds);
            eval.computePRF1();
            for (Measurement measurement : eval.getMeasurements()) {
                logln("--- --- " + measurement.getName() + ":\t" + measurement.getValue());
            }
        } else {
            RegressionEvaluation eval = new RegressionEvaluation(responses, docMeans);
            eval.computeCorrelationCoefficient();
            eval.computeMeanSquareError();
            eval.computeMeanAbsoluteError();
            eval.computeRSquared();
            eval.computePredictiveRSquared();
            ArrayList<Measurement> measurements = eval.getMeasurements();
            for (Measurement measurement : measurements) {
                logln("--- --- " + measurement.getName() + ":\t" + measurement.getValue());
            }
        }
    }

    /**
     * Update the eta sum for each path, which is represented by a node.
     */
    private void updatePathEtas() {
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            Node node = queue.poll();

            node.pathEta = node.eta;
            if (!node.isRoot()) {
                node.pathEta += node.getParent().pathEta;
            }

            for (Node child : node.getChildren()) {
                queue.add(child);
            }
        }
    }

    /**
     * Flatten the tree.
     */
    private ArrayList<Node> getNodeList() {
        ArrayList<Node> nodeList = new ArrayList<>();
        Stack<Node> stack = new Stack<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            for (Node child : node.getChildren()) {
                stack.add(child);
            }
            nodeList.add(node);
        }
        return nodeList;
    }

    @Override
    public double getLogLikelihood() {
        return 0.0;
    }

    @Override
    public double getLogLikelihood(ArrayList<Double> newParams) {
        throw new RuntimeException("Currently not supported");
    }

    @Override
    public void updateHyperparameters(ArrayList<Double> newParams) {
        throw new RuntimeException("Currently not supported");
    }

    @Override
    public void validate(String msg) {
        logln("Validating ... " + msg);
        Stack<Node> stack = new Stack<>();
        stack.add(root);
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            for (Node child : node.getChildren()) {
                stack.add(child);
            }
            node.validate(msg);
        }
    }

    public void outputState(String filepath, boolean outputModel, boolean outputAssignment) {
        if (verbose) {
            logln("--- Outputing current state to " + filepath);
        }

        StringBuilder modelStr = new StringBuilder();
        if (outputModel) {
            Stack<Node> stack = new Stack<>();
            stack.add(root);
            while (!stack.isEmpty()) {
                Node node = stack.pop();
                modelStr.append(Integer.toString(node.born)).append("\n");
                modelStr.append(node.getPathString()).append("\n");
                modelStr.append(node.eta).append("\n");
                modelStr.append(node.pi).append("\n");
                if (node.theta != null) {
                    modelStr.append(MiscUtils.arrayToString(node.theta));
                }
                modelStr.append("\n");
                modelStr.append(DirMult.output(node.getContent())).append("\n");
                modelStr.append(SparseCount.output(node.subtreeWordCounts)).append("\n");
                for (Node child : node.getChildren()) {
                    stack.add(child);
                }
            }
        }

        StringBuilder assignStr = new StringBuilder();
        if (outputAssignment) {
            for (int dd = 0; dd < z.length; dd++) {
                for (int nn = 0; nn < z[dd].length; nn++) {
                    assignStr.append(dd)
                            .append("\t").append(nn)
                            .append("\t").append(z[dd][nn].getPathString()).append("\n");
                }
            }
        }

        try { // output to a compressed file
            ArrayList<String> contentStrs = new ArrayList<>();
            contentStrs.add(modelStr.toString());
            contentStrs.add(assignStr.toString());

            String filename = IOUtils.removeExtension(IOUtils.getFilename(filepath));
            ArrayList<String> entryFiles = new ArrayList<>();
            entryFiles.add(filename + ModelFileExt);
            entryFiles.add(filename + AssignmentFileExt);

            this.outputZipFile(filepath, contentStrs, entryFiles);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while outputing to " + filepath);
        }
    }

    @Override
    public void outputState(String filepath) {
        if (verbose) {
            logln("--- Outputing current state to " + filepath);
        }
        outputState(filepath, true, true);
    }

    @Override
    public void inputState(String filepath) {
        if (verbose) {
            logln("--- Reading state from " + filepath);
        }
        try {
            inputModel(filepath);
            inputAssignments(filepath);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while inputing from " + filepath);
        }
    }

    public void inputModel(String zipFilepath) {
        if (verbose) {
            logln("--- --- Loading model from " + zipFilepath);
        }
        try {
            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));
            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + ModelFileExt);
            HashMap<String, Node> nodeMap = new HashMap<String, Node>();
            String line;
            while ((line = reader.readLine()) != null) {
                int born = Integer.parseInt(line);
                String pathStr = reader.readLine();
                double eta = Double.parseDouble(reader.readLine());
                double pi = Double.parseDouble(reader.readLine());
                line = reader.readLine().trim();
                double[] theta = null;
                if (!line.isEmpty()) {
                    theta = MiscUtils.stringToDoubleArray(line);
                }
                DirMult topic = DirMult.input(reader.readLine());
                SparseCount subtreeWordCounts = SparseCount.input(reader.readLine());

                // create node
                int lastColonIndex = pathStr.lastIndexOf(":");
                Node parent = null;
                if (lastColonIndex != -1) {
                    parent = nodeMap.get(pathStr.substring(0, lastColonIndex));
                }
                String[] pathIndices = pathStr.split(":");
                int nodeIndex = Integer.parseInt(pathIndices[pathIndices.length - 1]);
                int nodeLevel = pathIndices.length - 1;

                Node node = new Node(born, nodeIndex, nodeLevel, topic, parent, eta);
                node.pi = pi;
                node.theta = theta;
                node.subtreeWordCounts = subtreeWordCounts;

                if (node.getLevel() == 0) {
                    root = node;
                }
                if (parent != null) {
                    parent.addChild(node.getIndex(), node);
                }
                nodeMap.put(pathStr, node);
            }

            updatePathEtas();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while loading model from "
                    + zipFilepath);
        }
    }

    /**
     * Input a set of assignments.
     *
     * @param zipFilepath Compressed learned state file
     */
    public void inputAssignments(String zipFilepath) {
        if (verbose) {
            logln("--- --- Loading assignments from " + zipFilepath);
        }
        try {
            z = new Node[D][];
            for (int d = 0; d < D; d++) {
                z[d] = new Node[words[d].length];
            }

            String filename = IOUtils.removeExtension(IOUtils.getFilename(zipFilepath));
            BufferedReader reader = IOUtils.getBufferedReader(zipFilepath, filename + AssignmentFileExt);
            for (int dd = 0; dd < z.length; dd++) {
                for (int nn = 0; nn < z[dd].length; nn++) {
                    String[] sline = reader.readLine().split("\t");
                    if (dd != Integer.parseInt(sline[0])) {
                        throw new MismatchRuntimeException(Integer.parseInt(sline[0]), dd);
                    }
                    if (nn != Integer.parseInt(sline[1])) {
                        throw new MismatchRuntimeException(Integer.parseInt(sline[1]), nn);
                    }
                    String pathStr = sline[2];
                    z[dd][nn] = getNode(pathStr);
                    addToken(dd, nn, z[dd][nn], ADD, ADD);
                }
            }

            reader.close();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while loading assignments from "
                    + zipFilepath);
        }
    }

    /**
     * Parse the node path string.
     *
     * @param nodePath The node path string
     * @return
     */
    public int[] parseNodePath(String nodePath) {
        String[] ss = nodePath.split(":");
        int[] parsedPath = new int[ss.length];
        for (int i = 0; i < ss.length; i++) {
            parsedPath[i] = Integer.parseInt(ss[i]);
        }
        return parsedPath;
    }

    /**
     * Get a node in the tree given a parsed path
     *
     * @param parsedPath The parsed path
     */
    private Node getNode(int[] parsedPath) {
        Node node = root;
        for (int i = 1; i < parsedPath.length; i++) {
            node = node.getChild(parsedPath[i]);
        }
        return node;
    }

    /**
     * Get a node in the tree given its path.
     *
     * @param pathStr
     */
    private Node getNode(String pathStr) {
        return getNode(parseNodePath(pathStr));
    }

    /**
     * Summary of the current tree.
     *
     * @return Summary of the current tree
     */
    public String printGlobalTreeSummary() {
        StringBuilder str = new StringBuilder();
        SparseCount nodeCountPerLevel = new SparseCount();
        SparseCount obsCountPerLevel = new SparseCount();
        SparseCount subtreeObsCountPerLvl = new SparseCount();

        Stack<Node> stack = new Stack<Node>();
        stack.add(root);

        int totalObs = 0;
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            for (Node child : node.getChildren()) {
                stack.add(child);
            }
            if (node.isEmpty()) {
                continue;
            }

            int level = node.getLevel();
            nodeCountPerLevel.increment(level);
            obsCountPerLevel.changeCount(level, node.nodeDocCounts.getCountSum());
            subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());
            totalObs += node.nodeDocCounts.getCountSum();
        }
        str.append("global tree:\n\t>>> node count per level:\n");
        for (int l : nodeCountPerLevel.getSortedIndices()) {
            int obsCount = obsCountPerLevel.getCount(l);
            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);
            int nodeCount = nodeCountPerLevel.getCount(l);
            str.append("\t>>> >>> ").append(l)
                    .append(" [")
                    .append(nodeCount)
                    .append("] [").append(obsCount)
                    .append(", ").append(MiscUtils.formatDouble((double) obsCount / nodeCount))
                    .append(", ").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append("%")
                    .append("] [").append(subtreeObsCount)
                    .append(", ").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))
                    .append(", ").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append("%")
                    .append("]\n");
        }
        str.append("\n");
        str.append("\t>>> # observations = ").append(totalObs).append("\n");
        str.append("\t>>> # nodes = ").append(nodeCountPerLevel.getCountSum()).append("\n");
        return str.toString();
    }

    /**
     * The current tree.
     *
     * @return The current tree
     */
    public String printGlobalTree() {
        SparseCount nodeCountPerLvl = new SparseCount();
        SparseCount obsCountPerLvl = new SparseCount();
        SparseCount subtreeObsCountPerLvl = new SparseCount();
        int totalNumObs = 0;
        int numWords = 10;

        StringBuilder str = new StringBuilder();
        str.append("global tree\n");

        Stack<Node> stack = new Stack<Node>();
        stack.add(root);
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            String indentation = node.getIndentation();

            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();
            for (Node child : node.getChildren()) {
                rankChildren.add(new RankingItem<Node>(child, child.eta));
            }
            Collections.sort(rankChildren);
            for (RankingItem<Node> item : rankChildren) {
                stack.add(item.getObject());
            }

            // top words according to the distribution
            str.append(indentation);
            str.append(node.getPathString())
                    .append(" (").append(node.born)
                    .append("; ").append(node.getContent().getCountSum())
                    .append("; ").append(MiscUtils.formatDouble(node.eta))
                    .append("; ").append(MiscUtils.formatDouble(node.pathEta))
                    .append(")");
            str.append("\n");

            if (!node.isEmpty()) {
                // words with highest probabilities at subtree
                if (node.getLevel() < L - 1) {
                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);
                    str.append(indentation).append("@ subtree: ");
                    for (String topWord : subtreeTopWords) {
                        str.append(" ").append(topWord);
                    }
                    str.append("\n");
                }

                // words with highest probabilities at node
                String[] nodeTopWords = node.getNodeTopWords(numWords);
                str.append(indentation).append("@ node: ");
                for (String topWord : nodeTopWords) {
                    str.append(" ").append(topWord);
                }
                str.append("\n");

                // top assigned words
                str.append(indentation);
                str.append(node.getTopObservations()).append("\n\n");

                int level = node.getLevel();
                nodeCountPerLvl.increment(level);
                obsCountPerLvl.changeCount(level, node.nodeDocCounts.getCountSum());
                subtreeObsCountPerLvl.changeCount(level, node.subtreeDocCounts.getCountSum());
                totalNumObs += node.getContent().getCountSum();
            }

        }
        str.append("Tree summary").append("\n");
        for (int l : nodeCountPerLvl.getSortedIndices()) {
            int obsCount = obsCountPerLvl.getCount(l);
            int subtreeObsCount = subtreeObsCountPerLvl.getCount(l);
            int nodeCount = nodeCountPerLvl.getCount(l);
            str.append("\t>>> ").append(l)
                    .append(" [")
                    .append(nodeCount)
                    .append("] [").append(obsCount)
                    .append(", ").append(MiscUtils.formatDouble((double) obsCount / nodeCount))
                    .append(", ").append(MiscUtils.formatDouble((double) 100 * obsCount / numTokens)).append("%")
                    .append("] [").append(subtreeObsCount)
                    .append(", ").append(MiscUtils.formatDouble((double) subtreeObsCount / nodeCount))
                    .append(", ").append(MiscUtils.formatDouble((double) 100 * subtreeObsCount / numTokens)).append("%")
                    .append("]\n");
        }
        str.append("\t>>> # observations = ").append(totalNumObs).append("\n");
        str.append("\t>>> # nodes = ").append(nodeCountPerLvl.getCountSum()).append("\n");
        return str.toString();
    }

    /**
     * Output top words for each topic in the tree to text file.
     *
     * @param outputFile The output file
     * @param numWords Number of top words
     */
    @Override
    public void outputTopicTopWords(File outputFile, int numWords) {
        if (this.wordVocab == null) {
            throw new RuntimeException("The word vocab has not been assigned yet");
        }

        if (verbose) {
            logln("Outputing top words to file " + outputFile);
        }

        StringBuilder str = new StringBuilder();
        Stack<Node> stack = new Stack<Node>();
        stack.add(root);
        while (!stack.isEmpty()) {
            Node node = stack.pop();
            String indentation = node.getIndentation();

            ArrayList<RankingItem<Node>> rankChildren = new ArrayList<RankingItem<Node>>();
            for (Node child : node.getChildren()) {
                rankChildren.add(new RankingItem<Node>(child, child.eta));
            }
            Collections.sort(rankChildren);
            for (RankingItem<Node> item : rankChildren) {
                stack.add(item.getObject());
            }

            // top words according to the distribution
            str.append(indentation);
            str.append(node.getPathString())
                    .append(" (")
                    .append(node.born).append("; ")
                    .append(node.getContent().getCountSum()).append("; ")
                    //.append(MiscUtils.formatDouble(node.eta)).append("; eta: ")
                    .append(MiscUtils.formatDouble(node.pathEta))
                    .append(")");
            str.append(" ");

            if (!node.isEmpty()) {
                // words with highest probabilities at subtree
                if (node.getLevel() < L - 1) {
                    String[] subtreeTopWords = node.getSubtreeTopWords(numWords);
//                    str.append(indentation);
                    for (String topWord : subtreeTopWords) {
                        str.append(topWord).append(" ");
                    }
                    str.append("\n");
                } else { // words with highest probabilities at node
                    String[] nodeTopWords = node.getNodeTopWords(numWords);
//                    str.append(indentation);
                    for (String topWord : nodeTopWords) {
                        str.append(topWord).append(" ");
                    }
                    str.append("\n");
                }

                // top assigned words
//                str.append(indentation);
//                str.append(node.getTopObservations()).append("\n\n");
            }
            str.append("\n");
        }

        try {
            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);
            writer.write(str.toString());
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while outputing topics "
                    + outputFile);
        }
    }

    /**
     * Output posterior distribution over non-rooted nodes in the tree of all
     * documents.
     *
     * @param outputFile Output file
     */
    public void outputNodePosteriors(File outputFile) {
        ArrayList<Node> nodeList = getNodeList();
        try {
            BufferedWriter writer = IOUtils.getBufferedWriter(outputFile);
            for (int dd = 0; dd < D; dd++) {
                double[] nodePos = new double[nodeList.size()];
                for (int kk = 0; kk < nodeList.size(); kk++) {
                    Node node = nodeList.get(kk);
                    nodePos[kk] = (double) node.nodeDocCounts.getCount(dd) / words[dd].length;
                }
                writer.write(Integer.toString(dd));
                for (int kk = 0; kk < nodePos.length; kk++) {
                    writer.write("\t" + nodePos[kk]);
                }
                writer.write("\n");
            }
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while output to " + outputFile);
        }
    }

    class Node extends TreeNode<Node, DirMult> {

        protected final int born;
        protected SparseCount subtreeDocCounts;
        protected SparseCount nodeDocCounts;
        protected double[] theta;
        protected double pi;
        protected double eta;
        protected double pathEta;
        protected SparseCount subtreeWordCounts;

        public Node(int iter, int index, int level, DirMult content, Node parent,
                double eta) {
            super(index, level, content, parent);
            this.born = iter;
            this.subtreeDocCounts = new SparseCount();
            this.nodeDocCounts = new SparseCount();
            this.eta = eta;
            this.subtreeWordCounts = new SparseCount();
        }

        void incrementSubtreeWordCount(int vv) {
            subtreeWordCounts.increment(vv); // currently only for maximal assumption
        }

        void decrementSubtreeWordCount(int vv) {
            subtreeWordCounts.decrement(vv); // currently only for maximal assumption
        }

        double getNodeWordProbability(int vv) {
            return this.content.getProbability(vv);
        }

        double getSubtreeWordProbability(int vv) {
            return (content.getCount(vv) + subtreeWordCounts.getCount(vv)
                    + content.getConcentration() * content.getCenterElement(vv))
                    / (content.getCountSum() + subtreeWordCounts.getCountSum()
                    + content.getConcentration());
        }

        void setPathEta(double pathEta) {
            this.pathEta = pathEta;
        }

        void initializeGlobalPi() {
            this.pi = getPi(level);
        }

        void initializeGlobalTheta() {
            int KK = getNumChildren();
            this.theta = new double[KK];
            Arrays.fill(this.theta, 1.0 / KK);
        }

        /**
         * Return the number of tokens of a given document which are assigned to
         * any nodes below this node.
         *
         * @param dd Document index
         */
        int getPassingCount(int dd) {
            return subtreeDocCounts.getCount(dd) - nodeDocCounts.getCount(dd);
        }

        boolean isEmpty() {
            return this.getContent().isEmpty();
        }

        String[] getNodeTopWords(int numTopWords) {
            double[] phi = new double[V];
            for (int vv = 0; vv < V; vv++) {
                phi[vv] = getNodeWordProbability(vv);
            }
            ArrayList<RankingItem<String>> topicSortedVocab
                    = IOUtils.getSortedVocab(phi, wordVocab);
            String[] topWords = new String[numTopWords];
            for (int i = 0; i < numTopWords; i++) {
                topWords[i] = topicSortedVocab.get(i).getObject();
            }
            return topWords;
        }

        String[] getSubtreeTopWords(int numTopWords) {
            double[] phi = new double[V];
            for (int vv = 0; vv < V; vv++) {
                phi[vv] = getSubtreeWordProbability(vv);
            }
            ArrayList<RankingItem<String>> topicSortedVocab
                    = IOUtils.getSortedVocab(phi, wordVocab);
            String[] topWords = new String[numTopWords];
            for (int i = 0; i < numTopWords; i++) {
                topWords[i] = topicSortedVocab.get(i).getObject();
            }
            return topWords;
        }

        String getTopObservations() {
            return getTopObservations(getContent().getSparseCounts());
        }

        String getTopObservations(SparseCount counts) {
            ArrayList<RankingItem<Integer>> rankObs = new ArrayList<RankingItem<Integer>>();
            for (int obs : counts.getIndices()) {
                rankObs.add(new RankingItem<Integer>(obs, counts.getCount(obs)));
            }
            Collections.sort(rankObs);
            StringBuilder str = new StringBuilder();
            for (int ii = 0; ii < Math.min(10, rankObs.size()); ii++) {
                RankingItem<Integer> obs = rankObs.get(ii);
                str.append(wordVocab.get(obs.getObject())).append(":")
                        .append(obs.getPrimaryValue()).append(" ");
            }
            return str.toString();
        }

        void validate(String msg) {
            this.nodeDocCounts.validate(msg);
            this.subtreeDocCounts.validate(msg);
            if (theta != null && theta.length != getNumChildren()) {
                throw new RuntimeException(msg + ". MISMATCH. " + this.toString());
            }
        }

        @Override
        public String toString() {
            StringBuilder str = new StringBuilder();
            str.append("[").append(getPathString());
            str.append(", ").append(born);
            str.append(", c (").append(getChildren().size()).append(")");
            // word types
            str.append(", (").append(getContent().getCountSum()).append(")");
            // token counts
            str.append(", (").append(subtreeDocCounts.getCountSum());
            str.append(", ").append(nodeDocCounts.getCountSum()).append(")");
            str.append(", ").append(MiscUtils.formatDouble(eta));
            str.append(", ").append(MiscUtils.formatDouble(pathEta));
            str.append("]");
            return str.toString();
        }

        String getIndentation() {
            StringBuilder str = new StringBuilder();
            for (int i = 0; i < this.getLevel(); i++) {
                str.append("\t");
            }
            return str.toString();
        }
    }

    public static String getHelpString() {
        return "java -cp 'dist/segan.jar' " + SNLDA.class.getName() + " -help";
    }

    public static String getExampleCmd() {
        String example = new String();
        return example;
    }

    private static void addOpitions() throws Exception {
        parser = new BasicParser();
        options = new Options();

        // data input
        addOption("dataset", "Dataset");
        addOption("word-voc-file", "Word vocabulary file");
        addOption("word-file", "Document word file");
        addOption("info-file", "Document info file");
        addOption("selected-docs-file", "(Optional) Indices of selected documents");
        addOption("prior-topic-file", "File containing prior topics");
        addOption("init-eta-file", "File containing initial etas");
        addOption("num-top-words", "Number of top words per topic");

        // data output
        addOption("output-folder", "Output folder");

        // sampling
        addSamplingOptions();

        // parameters
        addOption("alphas", "Alpha");
        addOption("betas", "Beta");
        addOption("pis", "Mean");
        addOption("gammas", "Scale");
        addOption("rho", "Rho");
        addOption("mu", "Mu");
        addOption("sigmas", "Sigmas");
        addOption("Ks", "Number of topics");
        addOption("path", "Path assumption");

        // configurations
        addOption("init", "Initialization");

        options.addOption("train", false, "train");
        options.addOption("test", false, "test");
        options.addOption("parallel", false, "parallel");

        options.addOption("v", false, "verbose");
        options.addOption("d", false, "debug");
        options.addOption("z", false, "z-normalize");
        options.addOption("help", false, "Help");
        options.addOption("example", false, "Example command");
        options.addOption("binary", false, "Binary responses");
        options.addOption("root", false, "Is rooted");
    }

    private static void runModel() throws Exception {
        // sampling configurations
        int numTopWords = CLIUtils.getIntegerArgument(cmd, "num-top-words", 20);
        int burnIn = CLIUtils.getIntegerArgument(cmd, "burnIn", 500);
        int maxIters = CLIUtils.getIntegerArgument(cmd, "maxIter", 1000);
        int sampleLag = CLIUtils.getIntegerArgument(cmd, "sampleLag", 50);
        int repInterval = CLIUtils.getIntegerArgument(cmd, "report", 25);
        boolean paramOpt = cmd.hasOption("paramOpt");
        String init = CLIUtils.getStringArgument(cmd, "init", "random");
        InitialState initState;
        switch (init) {
            case "random":
                initState = InitialState.RANDOM;
                break;
            case "preset":
                initState = InitialState.PRESET;
                break;
            default:
                throw new RuntimeException("Initialization " + init + " not supported");
        }

        // model parameters
        int[] Ks = CLIUtils.getIntArrayArgument(cmd, "Ks", new int[]{15, 4}, ",");
        int L = Ks.length + 1;

        double[] alphas = CLIUtils.getDoubleArrayArgument(cmd, "alphas", new double[]{2.0, 1.0}, ",");
        double[] betas = CLIUtils.getDoubleArrayArgument(cmd, "betas", new double[]{0.5, 0.25, 0.1}, ",");
        double[] pis = CLIUtils.getDoubleArrayArgument(cmd, "pis", new double[]{0.2, 0.2}, ",");
        double[] gammas = CLIUtils.getDoubleArrayArgument(cmd, "gammas", new double[]{100, 10}, ",");
        double rho = CLIUtils.getDoubleArgument(cmd, "rho", 1.0);
        double mu = CLIUtils.getDoubleArgument(cmd, "mu", 0.0);
        double[] sigmas = CLIUtils.getDoubleArrayArgument(cmd, "sigmas", new double[]{0.5, 2.5}, ",");
        String path = CLIUtils.getStringArgument(cmd, "path", "none");
        PathAssumption pathAssumption = getPathAssumption(path);

        // data input
        String datasetName = cmd.getOptionValue("dataset");
        String wordVocFile = cmd.getOptionValue("word-voc-file");
        String docWordFile = cmd.getOptionValue("word-file");

        // data output
        String outputFolder = cmd.getOptionValue("output-folder");

        double[][] priorTopics = null;
        if (cmd.hasOption("prior-topic-file")) {
            String priorTopicFile = cmd.getOptionValue("prior-topic-file");
            priorTopics = IOUtils.input2DArray(new File(priorTopicFile));
        }

        double[] initEtas = null;
        if (cmd.hasOption("init-eta-file")) {
            String initEtaFile = cmd.getOptionValue("init-eta-file");
            initEtas = IOUtils.inputArray(new File(initEtaFile));
        }

        File docInfoFile = null;
        if (cmd.hasOption("info-file")) {
            docInfoFile = new File(cmd.getOptionValue("info-file"));
        }

        SNLDA sampler = new SNLDA();
        sampler.setVerbose(cmd.hasOption("v"));
        sampler.setDebug(cmd.hasOption("d"));
        sampler.setLog(true);
        sampler.setReport(true);

        boolean isBinary = cmd.hasOption("binary");
        boolean isRooted = cmd.hasOption("root");
        ResponseTextDataset contData = new ResponseTextDataset(datasetName);
        LabelTextDataset binData = new LabelTextDataset(datasetName);
        int V;
        if (isBinary) {
            binData.loadFormattedData(new File(wordVocFile),
                    new File(docWordFile),
                    docInfoFile,
                    null);
            V = binData.getWordVocab().size();
            sampler.setWordVocab(binData.getWordVocab());
            sampler.configureBinary(outputFolder, V, Ks,
                    alphas, betas, pis, gammas, mu, sigmas,
                    initState, pathAssumption, paramOpt, isRooted,
                    burnIn, maxIters, sampleLag, repInterval);
        } else {
            contData.loadFormattedData(new File(wordVocFile),
                    new File(docWordFile),
                    docInfoFile,
                    null);
            V = contData.getWordVocab().size();
            sampler.setWordVocab(contData.getWordVocab());
            sampler.configureContinuous(outputFolder, V, Ks,
                    alphas, betas, pis, gammas, rho, mu, sigmas,
                    initState, pathAssumption, paramOpt, isRooted,
                    burnIn, maxIters, sampleLag, repInterval);
        }

        File samplerFolder = new File(sampler.getSamplerFolderPath());
        IOUtils.createFolder(samplerFolder);

        if (isTraining()) {
            ArrayList<Integer> trainDocIndices;
            if (isBinary) {
                trainDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());
                sampler.train(binData.getWords(), trainDocIndices, binData.getSingleLabels());
            } else {
                trainDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());
                double[] docResponses = contData.getResponses();
                if (cmd.hasOption("z")) { // z-normalization
                    ZNormalizer zNorm = new ZNormalizer(docResponses);
                    docResponses = zNorm.normalize(docResponses);
                }
                sampler.train(contData.getWords(), trainDocIndices, docResponses);
            }

            sampler.initialize(priorTopics, initEtas);
            sampler.metaIterate();
            sampler.outputTopicTopWords(new File(samplerFolder, TopWordFile), numTopWords);
            sampler.outputNodePosteriors(new File(samplerFolder, "train-node-posteriors.txt"));
        }

        if (isTesting()) {
            int[][] testWords;
            ArrayList<Integer> testDocIndices;
            if (isBinary) {
                testWords = binData.getWords();
                testDocIndices = sampler.getSelectedDocIndices(binData.getDocIds());

            } else {
                testWords = contData.getWords();
                testDocIndices = sampler.getSelectedDocIndices(contData.getDocIds());
            }

            File testAssignmentFolder = new File(samplerFolder, AbstractSampler.IterAssignmentFolder);
            IOUtils.createFolder(testAssignmentFolder);

            File testPredFolder = new File(samplerFolder, AbstractSampler.IterPredictionFolder);
            IOUtils.createFolder(testPredFolder);

            double[] predictions;
            if (cmd.hasOption("parallel")) { // using multiple stored models
                predictions = SNLDA.parallelTest(testWords, testDocIndices, testPredFolder, testAssignmentFolder, sampler);
            } else { // using the last model
                File stateFile = sampler.getFinalStateFile();
                File outputPredFile = new File(testPredFolder, "iter-" + sampler.MAX_ITER + ".txt");
                File outputStateFile = new File(testPredFolder, "iter-" + sampler.MAX_ITER + ".zip");
                sampler.test(testWords, testDocIndices);
                predictions = sampler.sampleTest(stateFile, outputStateFile, outputPredFile);
                sampler.outputNodePosteriors(new File(samplerFolder, "test-node-posteriors.txt"));
            }

            File teResultFolder = new File(samplerFolder,
                    AbstractExperiment.TEST_PREFIX + AbstractExperiment.RESULT_FOLDER);
            IOUtils.createFolder(teResultFolder);

            if (isBinary) {
                PredictionUtils.outputClassificationPredictions(
                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),
                        binData.getDocIds(), binData.getSingleLabels(), predictions);
                PredictionUtils.outputBinaryClassificationResults(
                        new File(teResultFolder, AbstractExperiment.RESULT_FILE),
                        binData.getSingleLabels(), predictions);
            } else {
                double[] docResponses = contData.getResponses();
                if (cmd.hasOption("z")) { // z-normalization
                    ZNormalizer zNorm = new ZNormalizer(docResponses);
                    docResponses = zNorm.normalize(docResponses);
                }
                PredictionUtils.outputRegressionPredictions(
                        new File(teResultFolder, AbstractExperiment.PREDICTION_FILE),
                        contData.getDocIds(), docResponses, predictions);
                PredictionUtils.outputRegressionResults(
                        new File(teResultFolder, AbstractExperiment.RESULT_FILE), docResponses,
                        predictions);
            }
        }
    }

    public static void main(String[] args) {
        try {
            long sTime = System.currentTimeMillis();

            addOpitions();

            cmd = parser.parse(options, args);
            if (cmd.hasOption("help")) {
                CLIUtils.printHelp(getHelpString(), options);
                return;
            } else if (cmd.hasOption("example")) {
                System.out.println(getExampleCmd());
                return;
            }

            runModel();

            // date and time
            DateFormat df = new SimpleDateFormat("dd/MM/yy HH:mm:ss");
            Date dateobj = new Date();
            long eTime = (System.currentTimeMillis() - sTime) / 1000;
            System.out.println("Elapsed time: " + eTime + "s");
            System.out.println("End time: " + df.format(dateobj));
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException();
        }
    }

    /**
     * Run Gibbs sampling on test data using multiple models learned which are
     * stored in the ReportFolder. The runs on multiple models are parallel.
     *
     * @param newWords Words of new documents
     * @param newDocIndices Indices of test documents
     * @param iterPredFolder Output folder
     * @param iterStateFolder Folder to store assignments
     * @param sampler The configured sampler
     */
    public static double[] parallelTest(int[][] newWords,
            ArrayList<Integer> newDocIndices,
            File iterPredFolder,
            File iterStateFolder,
            SNLDA sampler) {
        File reportFolder = new File(sampler.getSamplerFolderPath(), ReportFolder);
        if (!reportFolder.exists()) {
            throw new RuntimeException("Report folder not found. " + reportFolder);
        }
        String[] filenames = reportFolder.list();
        double[] avgPredictions = null;
        try {
            IOUtils.createFolder(iterPredFolder);
            ArrayList<Thread> threads = new ArrayList<Thread>();
            ArrayList<File> partPredFiles = new ArrayList<>();
            for (String filename : filenames) { // all learned models
                if (!filename.contains("zip")) {
                    continue;
                }

                File stateFile = new File(reportFolder, filename);

                String stateFilename = IOUtils.removeExtension(filename);
                File iterOutputPredFile = new File(iterPredFolder, stateFilename + ".txt");
                File iterOutputStateFile = new File(iterStateFolder, stateFilename + ".zip");

                SNLDATestRunner runner = new SNLDATestRunner(sampler,
                        newWords, newDocIndices,
                        stateFile.getAbsolutePath(),
                        iterOutputStateFile.getAbsolutePath(),
                        iterOutputPredFile.getAbsolutePath());
                Thread thread = new Thread(runner);
                threads.add(thread);
                partPredFiles.add(iterOutputPredFile);
            }

            // run MAX_NUM_PARALLEL_THREADS threads at a time
            runThreads(threads);

            // average predictions
            avgPredictions = PredictionUtils.computeMultipleAverage(partPredFiles);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("Exception while sampling during parallel test.");
        }
        return avgPredictions;
    }
}
```


Overlapping Code:
```
extends AbstractSampler {
public static final int POSITVE = 1;
public static final int NEGATIVE = -1;
// hyperparameters for fixed-height tree
protected double[] alphas; // [L-1]
protected double[] betas; // [L]
protected double[] pis; // [L-1] mean of bias coins
protected double[] gammas; // [L-1] scale of bias coins
protected double rho;
protected double mu;
protected double[] sigmas;
// inputs
protected int[][] words; // all words
protected double[] responses; // [D] continous responses
protected int[] labels; // [D] binary responses
protected ArrayList<Integer> docIndices; // indices of docs under consideration
protected int V; // vocabulary size
protected int[] Ks; // [L-1]: number of children per node at each level
protected PathAssumption path;
// derived
protected int D; // number of documents
protected int L;
// latent
Node[][] z;
Node root;
// internal
private int numTokensAccepted;
private double[] docMeans;
private boolean isBinary;
private Set<Integer> positives;
private double uniform;
private boolean isRooted;
// cached probabilities computed at the first level
private HashMap<Node, Double> cachedProbabilities;
public SNLDA() {
this.basename = "SNLDA";
}
public SNLDA(String bname) {
this.basename = bname;
}
public void configure(SNLDA sampler) {
this.isBinary = sampler.isBinary;
if (this.isBinary) {
this.configureBinary(sampler.folder,
sampler.V,
sampler.Ks,
sampler.alphas,
sampler.betas,
sampler.pis,
sampler.gammas,
sampler.mu,
sampler.sigmas,
sampler.initState,
sampler.path,
sampler.paramOptimized,
sampler.isRooted,
sampler.BURN_IN,
sampler.MAX_ITER,
sampler.LAG,
sampler.REP_INTERVAL);
} else {
this.configureContinuous(sampler.folder,
sampler.V,
sampler.Ks,
sampler.alphas,
sampler.betas,
sampler.pis,
sampler.gammas,
sa
```
<Overlap Ratio: 0.9871364653243848>

---

--- 305 --
Question ID: 6c7cbb7c77d6c5b9075449651bbc46e1a1707b6b
Original Code:
```
public class SampleTest extends ValidationTest<Sample> {

  public SampleTest(ValidationTestCase<Sample> testCase) {
    super(testCase);
  }

  @Override
  protected Sample createValidTestSubject() {
    return Sample.create("xxxx", "yyy");
  }

  @Parameterized.Parameters
  public static Collection testCases() {
    final Collection<ValidationTestCase> ret = new ArrayList<>();
    ret.add(new ValidationTestCase<Sample>("basicCase")
            .adjustment(x -> {})
            .valid(true));
    ret.add(new ValidationTestCase<Sample>("nullIdentifier")
            .adjustment(x -> x.setIdentifier(null))
            .valid(false));
    ret.add(new ValidationTestCase<Sample>("tooShortIdentifier")
            .adjustment(x -> x.setIdentifier("z"))
            .valid(false));
    ret.add(new ValidationTestCase<Sample>("tooLongPayload")
            .adjustment(x -> x.setPayload(RandomStringUtils.randomAlphanumeric(513)))
            .valid(false));
    return ret;
  }

}
```


Overlapping Code:
```
pleTest extends ValidationTest<Sample> {
public SampleTest(ValidationTestCase<Sample> testCase) {
super(testCase);
}
@Override
protected Sample createValidTestSubject() {
return Sample.create("xxxx", "yyy");
}
@Parameterized.Parameters
public static Collection testCases() {
final Collection<ValidationTestCase> ret = new ArrayList<>();
ret.add(new ValidationTestCase<Sample>("basicCase")
.adjustment(x -> {})
.valid(true));
ret.add(new ValidationTestCase<Sample>("nullIdentifier")
.adjustment(x -> x.setIdentifier(null))
.valid(false));
ret.add(new ValidationTestCase<Sample>("tooShortIdentifier")
.adjustment(x -> x.setIdentifier("z"))
.valid(false));
ret.add(new ValidationTestCase<Sample>("tooLongPayload")
.adjustment(x -> x.setPayload(RandomStringUtils.randomAlphanumeric(513)))
.valid(false));
```
<Overlap Ratio: 0.9615384615384616>

---

--- 306 --
Question ID: aebb3f5ecb32edc2a6733e788e542683e8eaf0c4
Original Code:
```
public class MultiOptionListFormField extends OptionListFormField {

	private final class HistoryAwareValueChangeListener implements
			ValueChangeListener {
		private static final long serialVersionUID = 1L;

		private Collection<String> currentValue = MultiOptionListFormField.this
				.getValues();

		@Override
		@SuppressWarnings("unchecked")
		public void valueChange(ValueChangeEvent event) {
			if (!currentValue.equals(event.getProperty().getValue())) {
				currentValue = (Set<String>) event.getProperty().getValue();

				fireValueChangeEvent();
			}
		}
	}

	private static final long serialVersionUID = 1L;

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private ObjectProperty<Set<Object>> listProperty = new ObjectProperty(
			new HashSet(), Set.class);

	/**
	 * Nur für Tests.
	 * 
	 * @param config
	 *            Formular-Konfiguration
	 * @param optionList
	 *            Auswahl-Box-Modell
	 * @param eventRouter
	 *            EventRouter
	 */
	MultiOptionListFormField(
			FormFieldConfig config,
			OptionList optionList,
			EventRouter<FormFieldChangeEventHandler, FormFieldChangeEvent> eventRouter) {
		this(config, optionList);
		this.eventRouter = eventRouter;
	}

	/**
	 * Konstruktor mit Paramtern.
	 * 
	 * @param config
	 *            Formular-Konfiguration
	 * @param optionList
	 *            Auswahl-Box-Modell
	 */
	public MultiOptionListFormField(FormFieldConfig config, OptionList optionList) {
		super(config, optionList, false);
		if (config.getDefault() != null) {
			HashSet<Object> set = hashSetOf(config.getDefault());
			listProperty.setValue(set);
		}
		listProperty.addValueChangeListener(new HistoryAwareValueChangeListener());

	}

	private static final HashSet<Object> hashSetOf(Object... values) {
		return new HashSet<Object>(asList(values));
	}

	@Override
	public ObjectProperty<String> getProperty() {
		throw new UnsupportedOperationException();
	}

	public ObjectProperty<Set<Object>> getListProperty() {
		return listProperty;
	}

	@Override
	public String getValue() {
		return this.listProperty.getValue().size() == 1 ? (String) this.listProperty
				.getValue().iterator().next()
				: null;
	}

	/**
	 * Setzt die selektierten Einträge.
	 * 
	 * @param values
	 *            zu selektierenden Einträge
	 */
	public void setValues(Collection<String> values) {
		listProperty.setValue(new HashSet<Object>(values));
		if (values.size() == 0) {
			super.setValue(null);
		} else if (values.size() == 1) {
			super.setValue(values.iterator().next());
		}
	}

	@Override
	public void setValue(String value) {
		setValues(value == null ? new HashSet<String>() : Arrays.asList(value));
	}

	/**
	 * Selektiert einen Eintrag.
	 * 
	 * @return selektierter Eintrag
	 */
	public Set<String> getValues() {
		HashSet<String> set = new HashSet<String>();
		for (Object element : listProperty.getValue()) {
			set.add((String) element);
		}
		return set;
	}

}
```


Overlapping Code:
```
ptionListFormField extends OptionListFormField {
private final class HistoryAwareValueChangeListener implements
ValueChangeListener {
private static final long serialVersionUID = 1L;
private Collection<String> currentValue = MultiOptionListFormField.this
.getValues();
@Override
@SuppressWarnings("unchecked")
public void valueChange(ValueChangeEvent event) {
if (!currentValue.equals(event.getProperty().getValue())) {
currentValue = (Set<String>) event.getProperty().getValue();
fireValueChangeEvent();
}
}
}
private static final long serialVersionUID = 1L;
@SuppressWarnings({ "rawtypes", "unchecked" })
private ObjectProperty<Set<Object>> listProperty = new ObjectProperty(
new HashSet(), Set.class);
/**
* Nur für Tests.
* 
* @param config
* Formular-Konfiguration
* @param optionList
* Auswahl-Box-Modell
* @param eventRouter
* EventRouter
*/
MultiOptionListFormField(
FormFieldConfig config,
OptionList optionList,
EventRouter<FormFieldChangeEventHandler, FormFieldChangeEvent> eventRouter) {
this(config, optionList);
this.eventRouter = eventRouter;
}
/**
* Konstruktor mit Paramtern.
* 
* @param config
* Formular-Konfiguration
* @param optionList
* Auswahl-Box-Modell
*/
public MultiOptionListFormField(FormFieldConfig config, OptionList optionList) {
super(config, optionList, false);
if (config.getDefault() != null) {
HashSet<Object> set = hashSetOf(config.getDefault());
listProperty.setValue(set);
}
listProperty.addValueChangeListener(new HistoryAwareValueChangeListener());
}
private static final HashSet<Object> hashSetOf(Object... values) {
return new HashSet<Object>(asList(values));
}
@Override
public ObjectProperty<String> getProperty() {
throw new UnsupportedOperationException();
}
public ObjectProperty<Set<Object>> getListProperty() {
return listProperty;
}
@Override
public String getValue() {
return this.listProperty.getValue().size() == 1 ? (String) this.listProperty
.getValue().iterator().next()
: null;
}
/**
* Setzt die selektierten Einträge.
* 
* @param values
* zu selektierenden Einträge
*/
public void setValues(Collection<String> values) {
listProperty.setValue(new HashSet<Object>(values));
if (values.size() == 0) {
super.setValue(null);
} else if (values.si
```
<Overlap Ratio: 0.9721608484312859>

---

--- 307 --
Question ID: 67a3303bc899ae4afeabcaafcc90982e3bf6fa50
Original Code:
```
public class RepositoryUtils<T> {

    private BaseRepository<T, Long> repository;

    public RepositoryUtils(BaseRepository<T, Long> repository) {
        this.repository = repository;
    }

    public static<T> RepositoryUtils<T> getInstance(BaseRepository<T, Long> repository) {
        return new RepositoryUtils<>(repository);
    }

    public T one(long id) {
        return this.repository.findById(id).orElse(null);
    }

    public long count(Specification<T> specification) {
        return this.repository.count(specification);
    }

    public List<T> list(Specification<T> specification) {
        return this.repository.findAll(specification);
    }

    public List<T> list(Specification<T> specification, Sort sort) {
        return this.repository.findAll(specification, sort);
    }

    public ListResponse<T> listResponse(Specification<T> specification) {
        ListResponse<T> response = new ListResponse<>();
        response.setList(list(specification));
        return response;
    }
}
```


Overlapping Code:
```
 BaseRepository<T, Long> repository;
public RepositoryUtils(BaseRepository<T, Long> repository) {
this.repository = repository;
}
public static<T> RepositoryUtils<T> getInstance(BaseRepository<T, Long> repository) {
return new RepositoryUtils<>(repository);
}
public T one(long id) {
return this.repository.findById(id).orElse(null);
}
public long count(Specification<T> specification) {
return this.repository.count(specification);
}
public List<T> list(Specification<T> specification) {
return this.repository.findAll(specification);
}
public List<T> list(Specification<T> specification, Sort sort) {
return this.repository.findAll(specification, sort);
}
public ListResponse<T> listResponse(Specification<T> specification) {
ListResponse<T> response = new ListResponse<>();
response.setList(list(s
```
<Overlap Ratio: 0.9122006841505131>

---

--- 308 --
Question ID: 10b8e273f487ec2151d7e0443e9ab5aea275390e
Original Code:
```
public class AVRSymbol {

    public final String symbol;
    public final int value;

    AVRSymbol(String sym, int v) {
        symbol = sym;
        value = v;
    }

    public int getValue() {
        return value;
    }

    public int getEncodingValue() {
        return value;
    }

    public static class GPR extends AVRSymbol {

        private static HashMap<String, GPR> set = new HashMap<String, GPR>();

        private static GPR newGPR(String n, int v) {
            GPR obj = new GPR(n, v);
            set.put(n, obj);
            return obj;
        }

        GPR(String sym, int v) {
            super(sym, v);
        }

        public static final GPR R0 = newGPR("r0", 0);
        public static final GPR R1 = newGPR("r1", 1);
        public static final GPR R2 = newGPR("r2", 2);
        public static final GPR R3 = newGPR("r3", 3);
        public static final GPR R4 = newGPR("r4", 4);
        public static final GPR R5 = newGPR("r5", 5);
        public static final GPR R6 = newGPR("r6", 6);
        public static final GPR R7 = newGPR("r7", 7);
        public static final GPR R8 = newGPR("r8", 8);
        public static final GPR R9 = newGPR("r9", 9);
        public static final GPR R10 = newGPR("r10", 10);
        public static final GPR R11 = newGPR("r11", 11);
        public static final GPR R12 = newGPR("r12", 12);
        public static final GPR R13 = newGPR("r13", 13);
        public static final GPR R14 = newGPR("r14", 14);
        public static final GPR R15 = newGPR("r15", 15);
        public static final GPR R16 = newGPR("r16", 16);
        public static final GPR R17 = newGPR("r17", 17);
        public static final GPR R18 = newGPR("r18", 18);
        public static final GPR R19 = newGPR("r19", 19);
        public static final GPR R20 = newGPR("r20", 20);
        public static final GPR R21 = newGPR("r21", 21);
        public static final GPR R22 = newGPR("r22", 22);
        public static final GPR R23 = newGPR("r23", 23);
        public static final GPR R24 = newGPR("r24", 24);
        public static final GPR R25 = newGPR("r25", 25);
        public static final GPR R26 = newGPR("r26", 26);
        public static final GPR R27 = newGPR("r27", 27);
        public static final GPR R28 = newGPR("r28", 28);
        public static final GPR R29 = newGPR("r29", 29);
        public static final GPR R30 = newGPR("r30", 30);
        public static final GPR R31 = newGPR("r31", 31);
    }

    public static GPR get_GPR(String name) {
        return (GPR)GPR.set.get(name);
    }

    public static class ADR extends AVRSymbol {

        private static HashMap<String, ADR> set = new HashMap<String, ADR>();

        private static ADR newADR(String n, int v) {
            ADR obj = new ADR(n, v);
            set.put(n, obj);
            return obj;
        }

        ADR(String sym, int v) {
            super(sym, v);
        }

        public static final ADR X = newADR("X", 26);
        public static final ADR Y = newADR("Y", 28);
        public static final ADR Z = newADR("Z", 30);
    }

    public static ADR get_ADR(String name) {
        return (ADR)ADR.set.get(name);
    }

    public static class HGPR extends AVRSymbol.GPR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, HGPR> set = new HashMap<String, HGPR>();

        private static HGPR newHGPR(String n, int v, int ev) {
            HGPR obj = new HGPR(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        HGPR(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final HGPR R16 = newHGPR("r16", 16, 0);
        public static final HGPR R17 = newHGPR("r17", 17, 1);
        public static final HGPR R18 = newHGPR("r18", 18, 2);
        public static final HGPR R19 = newHGPR("r19", 19, 3);
        public static final HGPR R20 = newHGPR("r20", 20, 4);
        public static final HGPR R21 = newHGPR("r21", 21, 5);
        public static final HGPR R22 = newHGPR("r22", 22, 6);
        public static final HGPR R23 = newHGPR("r23", 23, 7);
        public static final HGPR R24 = newHGPR("r24", 24, 8);
        public static final HGPR R25 = newHGPR("r25", 25, 9);
        public static final HGPR R26 = newHGPR("r26", 26, 10);
        public static final HGPR R27 = newHGPR("r27", 27, 11);
        public static final HGPR R28 = newHGPR("r28", 28, 12);
        public static final HGPR R29 = newHGPR("r29", 29, 13);
        public static final HGPR R30 = newHGPR("r30", 30, 14);
        public static final HGPR R31 = newHGPR("r31", 31, 15);
    }

    public static HGPR get_HGPR(String name) {
        return (HGPR)HGPR.set.get(name);
    }

    public static class EGPR extends AVRSymbol.GPR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, EGPR> set = new HashMap<String, EGPR>();

        private static EGPR newEGPR(String n, int v, int ev) {
            EGPR obj = new EGPR(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        EGPR(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final EGPR R0 = newEGPR("r0", 0, 0);
        public static final EGPR R2 = newEGPR("r2", 2, 1);
        public static final EGPR R4 = newEGPR("r4", 4, 2);
        public static final EGPR R6 = newEGPR("r6", 6, 3);
        public static final EGPR R8 = newEGPR("r8", 8, 4);
        public static final EGPR R10 = newEGPR("r10", 10, 5);
        public static final EGPR R12 = newEGPR("r12", 12, 6);
        public static final EGPR R14 = newEGPR("r14", 14, 7);
        public static final EGPR R16 = newEGPR("r16", 16, 8);
        public static final EGPR R18 = newEGPR("r18", 18, 9);
        public static final EGPR R20 = newEGPR("r20", 20, 10);
        public static final EGPR R22 = newEGPR("r22", 22, 11);
        public static final EGPR R24 = newEGPR("r24", 24, 12);
        public static final EGPR R26 = newEGPR("r26", 26, 13);
        public static final EGPR R28 = newEGPR("r28", 28, 14);
        public static final EGPR R30 = newEGPR("r30", 30, 15);
    }

    public static EGPR get_EGPR(String name) {
        return (EGPR)EGPR.set.get(name);
    }

    public static class MGPR extends AVRSymbol.GPR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, MGPR> set = new HashMap<String, MGPR>();

        private static MGPR newMGPR(String n, int v, int ev) {
            MGPR obj = new MGPR(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        MGPR(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final MGPR R16 = newMGPR("r16", 16, 0);
        public static final MGPR R17 = newMGPR("r17", 17, 1);
        public static final MGPR R18 = newMGPR("r18", 18, 2);
        public static final MGPR R19 = newMGPR("r19", 19, 3);
        public static final MGPR R20 = newMGPR("r20", 20, 4);
        public static final MGPR R21 = newMGPR("r21", 21, 5);
        public static final MGPR R22 = newMGPR("r22", 22, 6);
        public static final MGPR R23 = newMGPR("r23", 23, 7);
    }

    public static MGPR get_MGPR(String name) {
        return (MGPR)MGPR.set.get(name);
    }

    public static class YZ extends AVRSymbol.ADR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, YZ> set = new HashMap<String, YZ>();

        private static YZ newYZ(String n, int v, int ev) {
            YZ obj = new YZ(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        YZ(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final YZ Y = newYZ("Y", 28, 1);
        public static final YZ Z = newYZ("Z", 30, 0);
    }

    public static YZ get_YZ(String name) {
        return (YZ)YZ.set.get(name);
    }

    public static class RDL extends AVRSymbol.GPR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, RDL> set = new HashMap<String, RDL>();

        private static RDL newRDL(String n, int v, int ev) {
            RDL obj = new RDL(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        RDL(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final RDL R24 = newRDL("r24", 24, 0);
        public static final RDL R26 = newRDL("r26", 26, 1);
        public static final RDL R28 = newRDL("r28", 28, 2);
        public static final RDL R30 = newRDL("r30", 30, 3);
    }

    public static RDL get_RDL(String name) {
        return (RDL)RDL.set.get(name);
    }

    public static class R0 extends AVRSymbol.GPR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, R0> set = new HashMap<String, R0>();

        private static R0 newR0(String n, int v, int ev) {
            R0 obj = new R0(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        R0(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final R0 R0 = newR0("r0", 0, 0);
    }

    public static R0 get_R0(String name) {
        return (R0)R0.set.get(name);
    }

    public static class RZ extends AVRSymbol.ADR {

        public final int encoding;

        public int getEncodingValue() {
            return encoding;
        }

        private static HashMap<String, RZ> set = new HashMap<String, RZ>();

        private static RZ newRZ(String n, int v, int ev) {
            RZ obj = new RZ(n, v, ev);
            set.put(n, obj);
            return obj;
        }

        RZ(String sym, int v, int ev) {
            super(sym, v);
            encoding = ev;
        }

        public static final RZ Z = newRZ("Z", 30, 0);
    }

    public static RZ get_RZ(String name) {
        return (RZ)RZ.set.get(name);
    }

}
```


Overlapping Code:
```
ass AVRSymbol {
public final String symbol;
public final int value;
AVRSymbol(String sym, int v) {
symbol = sym;
value = v;
}
public int getValue() {
return value;
}
public int getEncodingValue() {
return value;
}
public static class GPR extends AVRSymbol {
private static HashMap<String, GPR> set = new HashMap<String, GPR>();
private static GPR newGPR(String n, int v) {
GPR obj = new GPR(n, v);
set.put(n, obj);
return obj;
}
GPR(String sym, int v) {
super(sym, v);
}
public static final GPR R0 = newGPR("r0", 0);
public static final GPR R1 = newGPR("r1", 1);
public static final GPR R2 = newGPR("r2", 2);
public static final GPR R3 = newGPR("r3", 3);
public static final GPR R4 = newGPR("r4", 4);
public static final GPR R5 = newGPR("r5", 5);
public static final GPR R6 = newGPR("r6", 6);
public static final GPR R7 = newGPR("r7", 7);
public static final GPR R8 = newGPR("r8", 8);
public static final GPR R9 = newGPR("r9", 9);
public static final GPR R10 = newGPR("r10", 10);
public static final GPR R11 = newGPR("r11", 11);
public static final GPR R12 = newGPR("r12", 12);
public static final GPR R13 = newGPR("r13", 13);
public static final GPR R14 = newGPR("r14", 14);
public static final GPR R15 = newGPR("r15", 15);
public static final GPR R16 = newGPR("r16", 16);
public static final GPR R17 = newGPR("r17", 17);
public static final GPR R18 = newGPR("r18", 18);
public static final GPR R19 = newGPR("r19", 19);
public static final GPR R20 = newGPR("r20", 20);
public static final GPR R21 = newGPR("r21", 21);
public static final GPR R22 = newGPR("r22", 22);
public static final GPR R23 = newGPR("r23", 23);
public static final GPR R24 = newGPR("r24", 24);
public static final GPR R25 = newGPR("r25", 25);
public static final GPR R26 = newGPR("r26", 26);
public static final GPR R27 = newGPR("r27", 27);
public static final GPR R28 = newGPR("r28", 28);
public static final GPR R29 = newGPR("r29", 29);
public static final GPR R30 = newGPR("r30", 30);
public static final GPR R31 = newGPR("r31", 31);
}
public static GPR get_GPR(String name) 
```
<Overlap Ratio: 0.9951456310679612>

---

--- 309 --
Question ID: 6bc8ee2c40dd91b5ee529c3fce1b9c0109ad3e5e
Original Code:
```
public class DefaultQueryParser extends QueryParserBase<SolrDataQuery> {

	private static final Logger LOGGER = LoggerFactory.getLogger(DefaultQueryParser.class);

	/**
	 * Convert given Query into a SolrQuery executable via {@link org.apache.solr.client.solrj.SolrClient}
	 * 
	 * @param query
	 * @return
	 */
	@Override
	public final SolrQuery doConstructSolrQuery(SolrDataQuery query) {
		Assert.notNull(query, "Cannot construct solrQuery from null value.");
		Assert.notNull(query.getCriteria(), "Query has to have a criteria.");
		
		SolrQuery solrQuery = new SolrQuery();
		solrQuery.setParam(CommonParams.Q, getQueryString(query));
		if (query instanceof Query) {
			processQueryOptions(solrQuery, (Query) query);
		}
		if (query instanceof FacetQuery) {
			processFacetOptions(solrQuery, (FacetQuery) query);
		}
		if (query instanceof HighlightQuery) {
			processHighlightOptions(solrQuery, (HighlightQuery) query);
		}

		return solrQuery;
	}

	private void processQueryOptions(SolrQuery solrQuery, Query query) {
		appendPagination(solrQuery, query.getOffset(), query.getRows());
		appendProjectionOnFields(solrQuery, query.getProjectionOnFields());
		appendFilterQuery(solrQuery, query.getFilterQueries());
		appendSort(solrQuery, query.getSort());
		appendDefaultOperator(solrQuery, query.getDefaultOperator());
		appendTimeAllowed(solrQuery, query.getTimeAllowed());
		appendDefType(solrQuery, query.getDefType());
		appendRequestHandler(solrQuery, query.getRequestHandler());
		appendReRankQueryHandler(solrQuery,query.getRqqValue());

		processGroupOptions(solrQuery, query);
		processStatsOptions(solrQuery, query);
		processSpellcheckOptions(solrQuery, query);

		LOGGER.info(solrQuery.toQueryString());
		
		if (LOGGER.isDebugEnabled()) {
			LOGGER.debug("Constructed SolrQuery:\r\n %s", solrQuery);
		}
	}

	/**
	 * @param solrQuery
	 * @param rqqValue
	 */
	private void appendReRankQueryHandler(SolrQuery solrQuery, String rqqValue) {
		if(StringUtils.isNotBlank(rqqValue)) {
			solrQuery.set("rq", "{!rerank reRankQuery=$rqq reRankDocs=1000 reRankWeight=3}");
			solrQuery.set("rqq", rqqValue);
		}
	}

	private void processFacetOptions(SolrQuery solrQuery, FacetQuery query) {
		if (enableFaceting(solrQuery, query)) {
			appendFacetingOnFields(solrQuery, (FacetQuery) query);
			appendFacetingQueries(solrQuery, (FacetQuery) query);
			appendFacetingOnPivot(solrQuery, (FacetQuery) query);
			appendRangeFacetingOnFields(solrQuery, (FacetQuery) query);
		}
	}

	private void setObjectNameOnGroupQuery(Query query, Object object, String name) {

		if (query instanceof NamedObjectsQuery) {
			((NamedObjectsQuery) query).setName(object, name);
		}
	}

	private void processStatsOptions(SolrQuery solrQuery, Query query) {
		StatsOptions statsOptions = query.getStatsOptions();

		if (statsOptions == null
				|| (CollectionUtils.isEmpty(statsOptions.getFields()) && CollectionUtils.isEmpty(statsOptions.getFacets())
						&& CollectionUtils.isEmpty(statsOptions.getSelectiveFacets()))) {
			return;
		}

		solrQuery.set(StatsParams.STATS, true);

		for (Field field : statsOptions.getFields()) {
			solrQuery.add(StatsParams.STATS_FIELD, field.getName());

			String selectiveCalcDistinctParam = CommonParams.FIELD + "." + field.getName() + "."
					+ StatsParams.STATS_CALC_DISTINCT;
			Boolean selectiveCountDistincts = statsOptions.isSelectiveCalcDistincts(field);

			if (selectiveCountDistincts != null) {
				solrQuery.add(selectiveCalcDistinctParam, String.valueOf(selectiveCountDistincts.booleanValue()));
			}

		}

		for (Field field : statsOptions.getFacets()) {
			solrQuery.add(StatsParams.STATS_FACET, field.getName());
		}

		for (Entry<Field, Collection<Field>> entry : statsOptions.getSelectiveFacets().entrySet()) {

			Field field = entry.getKey();
			String prefix = CommonParams.FIELD + "." + field.getName() + ".";

			String paramName = prefix + StatsParams.STATS_FACET;
			for (Field facetField : entry.getValue()) {
				solrQuery.add(paramName, facetField.getName());
			}

		}

	}

	private void processGroupOptions(SolrQuery solrQuery, Query query) {

		GroupOptions groupOptions = query.getGroupOptions();

		if (groupOptions == null || (CollectionUtils.isEmpty(groupOptions.getGroupByFields())
				&& CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())
				&& CollectionUtils.isEmpty(groupOptions.getGroupByQueries()))) {
			return;
		}

		solrQuery.set(GroupParams.GROUP, true);
		solrQuery.set(GroupParams.GROUP_MAIN, groupOptions.isGroupMain());
		solrQuery.set(GroupParams.GROUP_FORMAT, "grouped");

		if (!CollectionUtils.isEmpty(groupOptions.getGroupByFields())) {
			for (Field field : groupOptions.getGroupByFields()) {
				solrQuery.add(GroupParams.GROUP_FIELD, field.getName());
			}
		}

		if (!CollectionUtils.isEmpty(groupOptions.getGroupByFunctions())) {
			for (Function function : groupOptions.getGroupByFunctions()) {
				String functionFragment = createFunctionFragment(function, 0);
				setObjectNameOnGroupQuery(query, function, functionFragment);
				solrQuery.add(GroupParams.GROUP_FUNC, functionFragment);
			}
		}

		if (!CollectionUtils.isEmpty(groupOptions.getGroupByQueries())) {
			for (Query groupQuery : groupOptions.getGroupByQueries()) {
				String queryFragment = getQueryString(groupQuery);
				setObjectNameOnGroupQuery(query, groupQuery, queryFragment);
				solrQuery.add(GroupParams.GROUP_QUERY, queryFragment);
			}
		}

		if (groupOptions.getSort() != null) {

			for (Order order : groupOptions.getSort()) {
				solrQuery.add(GroupParams.GROUP_SORT,
						order.getProperty().trim() + " " + (order.isAscending() ? ORDER.asc : ORDER.desc));
			}
		}

		if (groupOptions.getCachePercent() > 0) {
			solrQuery.add(GroupParams.GROUP_CACHE_PERCENTAGE, String.valueOf(groupOptions.getCachePercent()));
		}

		if (groupOptions.getLimit() != null) {
			solrQuery.set(GroupParams.GROUP_LIMIT, groupOptions.getLimit());
		}

		if (groupOptions.getOffset() != null && groupOptions.getOffset() >= 0) {
			solrQuery.set(GroupParams.GROUP_OFFSET, groupOptions.getOffset());
		}

		solrQuery.set(GroupParams.GROUP_TOTAL_COUNT, groupOptions.isTotalCount());
		solrQuery.set(GroupParams.GROUP_FACET, groupOptions.isGroupFacets());
		solrQuery.set(GroupParams.GROUP_TRUNCATE, groupOptions.isTruncateFacets());
	}

	private void processSpellcheckOptions(SolrQuery solrQuery, Query query) {

		if (query.getSpellcheckOptions() == null) {
			return;
		}

		SpellcheckOptions options = query.getSpellcheckOptions();

		if (options.getQuery() != null && options.getQuery().getCriteria() != null) {
			solrQuery.set(SpellingParams.SPELLCHECK_Q, createQueryStringFromCriteria(options.getQuery().getCriteria()));
		}

		ModifiableSolrParams params = new ModifiableSolrParams();
		params.add("spellcheck", "on");
		for (Entry<String, Object> entry : options.getParams().entrySet()) {

			if (entry.getValue() instanceof Iterable<?>) {
				for (Object o : ((Iterable<?>) entry.getValue())) {
					params.add(entry.getKey(), o.toString());
				}
			} else if (ObjectUtils.isArray(entry.getValue())) {
				for (Object o : ObjectUtils.toObjectArray(entry.getValue())) {
					params.add(entry.getKey(), o.toString());
				}
			} else {
				params.add(entry.getKey(), entry.getValue().toString());
			}
		}
		solrQuery.add(params);
	}

	/**
	 * Append highlighting parameters to {@link SolrQuery}
	 * 
	 * @param solrQuery
	 * @param query
	 */
	protected void processHighlightOptions(SolrQuery solrQuery, HighlightQuery query) {
		if (query.hasHighlightOptions()) {
			HighlightOptions highlightOptions = query.getHighlightOptions();
			solrQuery.setHighlight(true);
			if (!highlightOptions.hasFields()) {
				solrQuery.addHighlightField(HighlightOptions.ALL_FIELDS.getName());
			} else {
				for (Field field : highlightOptions.getFields()) {
					solrQuery.addHighlightField(field.getName());
				}
				for (FieldWithHighlightParameters fieldWithHighlightParameters : highlightOptions
						.getFieldsWithHighlightParameters()) {
					addPerFieldHighlightParameters(solrQuery, fieldWithHighlightParameters);
				}
			}
			for (HighlightParameter option : highlightOptions.getHighlightParameters()) {
				addOptionToSolrQuery(solrQuery, option);
			}
			if (highlightOptions.hasQuery()) {
				solrQuery.add(HighlightParams.Q, getQueryString(highlightOptions.getQuery()));
			}
		}
	}

	private void addOptionToSolrQuery(SolrQuery solrQuery, QueryParameter option) {
		if (option != null && StringUtils.isNotBlank(option.getName())) {
			solrQuery.add(option.getName(), conversionService.convert(option.getValue(), String.class));
		}
	}

	private void addFieldSpecificParameterToSolrQuery(SolrQuery solrQuery, Field field, QueryParameter option) {
		if (option != null && field != null && StringUtils.isNotBlank(option.getName())) {
			if (option.getValue() == null) {
				solrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), (String) null);
			} else {
				String value = option.getValue().toString();
				if (conversionService.canConvert(option.getValue().getClass(), String.class)) {
					value = conversionService.convert(option.getValue(), String.class);
				}
				solrQuery.add(createPerFieldOverrideParameterName(field, option.getName()), value);
			}
		}
	}

	private void addPerFieldHighlightParameters(SolrQuery solrQuery, FieldWithHighlightParameters field) {
		for (HighlightParameter option : field) {
			addFieldSpecificParameterToSolrQuery(solrQuery, field, option);
		}
	}

	protected String createPerFieldOverrideParameterName(Field field, String parameterName) {
		return "f." + field.getName() + "." + parameterName;
	}

	private boolean enableFaceting(SolrQuery solrQuery, FacetQuery query) {
		FacetOptions facetOptions = query.getFacetOptions();
		if (facetOptions == null || !facetOptions.hasFacets()) {
			return false;
		}
		solrQuery.setFacet(true);
		solrQuery.setFacetMinCount(facetOptions.getFacetMinCount());
		solrQuery.setFacetLimit(facetOptions.getPageable().getPageSize());
		if (facetOptions.getPageable().getPageNumber() > 0) {
			long offset = Math.max(0, facetOptions.getPageable().getOffset());
			solrQuery.set(FacetParams.FACET_OFFSET, "" + offset);
		}
		if (FacetOptions.FacetSort.INDEX.equals(facetOptions.getFacetSort())) {
			solrQuery.setFacetSort(FacetParams.FACET_SORT_INDEX);
		}
		return true;
	}

	private void appendFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {
		FacetOptions facetOptions = query.getFacetOptions();
		solrQuery.addFacetField(convertFieldListToStringArray(facetOptions.getFacetOnFields()));
		if (facetOptions.hasFacetPrefix()) {
			solrQuery.setFacetPrefix(facetOptions.getFacetPrefix());
		}
		for (FieldWithFacetParameters parametrizedField : facetOptions.getFieldsWithParameters()) {
			addPerFieldFacetParameters(solrQuery, parametrizedField);
			if (parametrizedField.getSort() != null && FacetOptions.FacetSort.INDEX.equals(parametrizedField.getSort())) {
				addFieldSpecificParameterToSolrQuery(solrQuery, parametrizedField,
						new FacetParameter(FacetParams.FACET_SORT, FacetParams.FACET_SORT_INDEX));
			}

		}
	}

	private void addPerFieldFacetParameters(SolrQuery solrQuery, FieldWithFacetParameters field) {
		for (FacetParameter parameter : field) {
			addFieldSpecificParameterToSolrQuery(solrQuery, field, parameter);
		}
	}

	private void appendRangeFacetingOnFields(SolrQuery solrQuery, FacetQuery query) {
		FacetOptions facetRangeOptions = query.getFacetOptions();

		if (facetRangeOptions == null) {
			return;
		}

		for (FieldWithRangeParameters<?, ?, ?> rangeField : facetRangeOptions.getFieldsWithRangeParameters()) {

			if (rangeField instanceof FieldWithDateRangeParameters) {
				appendFieldFacetingByDateRange(solrQuery, (FieldWithDateRangeParameters) rangeField);
			} else if (rangeField instanceof FieldWithNumericRangeParameters) {
				appendFieldFacetingByNumberRange(solrQuery, (FieldWithNumericRangeParameters) rangeField);
			}

			if (rangeField.getHardEnd() != null && rangeField.getHardEnd()) {
				FacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_HARD_END, true);
				addFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);
			}
			if (rangeField.getOther() != null) {
				FacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_OTHER, rangeField.getOther());
				addFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);
			}

			if (rangeField.getInclude() != null) {
				FacetParameter param = new FacetParameter(FacetParams.FACET_RANGE_INCLUDE, rangeField.getInclude());
				addFieldSpecificParameterToSolrQuery(solrQuery, rangeField, param);
			}

		}
	}

	private void appendFieldFacetingByNumberRange(SolrQuery solrQuery, FieldWithNumericRangeParameters field) {
		solrQuery.addNumericRangeFacet( //
				field.getName(), //
				field.getStart(), //
				field.getEnd(), //
				field.getGap());
	}

	private void appendFieldFacetingByDateRange(SolrQuery solrQuery, FieldWithDateRangeParameters field) {
		solrQuery.addDateRangeFacet( //
				field.getName(), //
				field.getStart(), //
				field.getEnd(), //
				field.getGap());
	}

	private void appendFacetingQueries(SolrQuery solrQuery, FacetQuery query) {
		FacetOptions facetOptions = query.getFacetOptions();
		for (SolrDataQuery fq : facetOptions.getFacetQueries()) {
			String facetQueryString = getQueryString(fq);
			if (StringUtils.isNotBlank(facetQueryString)) {
				solrQuery.addFacetQuery(facetQueryString);
			}
		}
	}

	private void appendFacetingOnPivot(SolrQuery solrQuery, FacetQuery query) {

		FacetOptions facetOptions = query.getFacetOptions();
		String[] pivotFields = convertFieldListToStringArray(facetOptions.getFacetOnPivots());
		solrQuery.addFacetPivotField(pivotFields);
	}

	/**
	 * Set filter filter queries for {@link SolrQuery}
	 * 
	 * @param solrQuery
	 * @param filterQueries
	 */
	protected void appendFilterQuery(SolrQuery solrQuery, List<FilterQuery> filterQueries) {
		if (CollectionUtils.isEmpty(filterQueries)) {
			return;
		}
		List<String> filterQueryStrings = getFilterQueryStrings(filterQueries);

		if (!filterQueryStrings.isEmpty()) {
			solrQuery.setFilterQueries(convertStringListToArray(filterQueryStrings));
		}
	}

	/**
	 * Append sorting parameters to {@link SolrQuery}
	 * 
	 * @param solrQuery
	 * @param sort
	 */
	protected void appendSort(SolrQuery solrQuery, @Nullable Sort sort) {
		if (sort == null) {
			return;
		}

		for (Order order : sort) {
			solrQuery.addSort(order.getProperty(), order.isAscending() ? ORDER.asc : ORDER.desc);
		}
	}

	private String[] convertFieldListToStringArray(List<? extends Field> fields) {
		String[] strResult = new String[fields.size()];
		for (int i = 0; i < fields.size(); i++) {
			strResult[i] = fields.get(i).getName();
		}
		return strResult;
	}

	private String[] convertStringListToArray(List<String> listOfString) {
		String[] strResult = new String[listOfString.size()];
		listOfString.toArray(strResult);
		return strResult;
	}

	private List<String> getFilterQueryStrings(List<FilterQuery> filterQueries) {
		List<String> filterQueryStrings = new ArrayList<>(filterQueries.size());

		for (FilterQuery filterQuery : filterQueries) {
			String filterQueryString = getQueryString(filterQuery);
			if (StringUtils.isNotBlank(filterQueryString)) {
				filterQueryStrings.add(filterQueryString);
			}
		}
		return filterQueryStrings;
	}

}
```


Overlapping Code:
```
ueryParser extends QueryParserBase<SolrDataQuery> {
private static final Logger LOGGER = LoggerFactory.getLogger(DefaultQueryParser.class);
/**
* Convert given Query into a SolrQuery executable via {@link org.apache.solr.client.solrj.SolrClient}
* 
* @param query
* @return
*/
@Override
public final SolrQuery doConstructSolrQuery(SolrDataQuery query) {
Assert.notNull(query, "Cannot construct solrQuery from null value.");
Assert.notNull(query.getCriteria(), "Query has to have a criteria.");

SolrQuery solrQuery = new SolrQuery();
solrQuery.setParam(CommonParams.Q, getQueryString(query));
if (query instanceof Query) {
processQueryOptions(solrQuery, (Query) query);
}
if (query instanceof FacetQuery) {
processFacetOptions(solrQuery, (FacetQuery) query);
}
if (query instanceof HighlightQuery) {
processHighlightOptions(solrQuery, (HighlightQuery) query);
}
return solrQuery;
}
private void processQueryOptions(SolrQuery solrQuery, Query query) {
appendPagination(solrQuery, query.getOffset(), query.getRows());
appendProjectionOnFields(solrQuery, query.getProjectionOnFields());
appendFilterQuery(solrQuery, query.getFilterQueries());
appendSort(solrQuery, query.getSort());
appendDefaultOperator(solrQuery, query.getDefaultOperator());
appendTimeAllowed(solrQuery, query.getTimeAllowed());
appendDefType(solrQuery, query.getDefType());
appendRequestHandler(solrQuery, query.getRequestHandler());
appendReRankQueryHandler(solrQuery,query.getRqqValue());
processGroupOptions(solrQuery, query);
processStatsOptions(solrQuery, query);
processSpellcheckOptions(solrQuery, query);
LOGGER.info(solrQuery.toQueryString());

if (LOGGER.isDebugEnabled()) {
LOGGER.debug("Constructed SolrQuery:\r\n %s", solrQuery);
}
}
/**
* @param solrQuery
* @param rqqValue
*/
private void appendReRankQueryHandler(SolrQuery solrQuery, String rqqValue) {
if(StringUtils.isNotBlank(rqqValue)) {
solrQuery.set("rq", "{!rerank reRankQuery=$rqq reRankDocs=1000 reRankWeight=3}");
solrQuery.set("rqq", rqqValue);
}
}
private void processFacetOptions(SolrQuery solrQuery, FacetQuery query) {
if (enableFaceting(solrQuery, query)) {
appendFacetingOnFields(solrQuery, (FacetQuery) query);
appendFacetingQueries(solrQuery, (FacetQuery) query);
appendFacetingOnPivot(solrQuery, (FacetQuery) query);
appendRangeFacetingOnFields(solrQuery, (FacetQuer
```
<Overlap Ratio: 0.9801436417405999>

---

--- 310 --
Question ID: 0445c22da4d333b6ddd4f895492be66d958cd572
Original Code:
```
public class ExecutionLayerConfiguration {

  private final Spec spec;
  private final Optional<String> engineEndpoint;
  private final Version engineVersion;
  private final Optional<String> engineJwtSecretFile;
  private final Optional<String> builderEndpoint;

  private ExecutionLayerConfiguration(
      final Spec spec,
      final Optional<String> engineEndpoint,
      final Version engineVersion,
      final Optional<String> engineJwtSecretFile,
      final Optional<String> builderEndpoint) {
    this.spec = spec;
    this.engineEndpoint = engineEndpoint;
    this.engineVersion = engineVersion;
    this.engineJwtSecretFile = engineJwtSecretFile;
    this.builderEndpoint = builderEndpoint;
  }

  public static Builder builder() {
    return new Builder();
  }

  public boolean isEnabled() {
    return spec.isMilestoneSupported(SpecMilestone.BELLATRIX);
  }

  public Spec getSpec() {
    return spec;
  }

  public String getEngineEndpoint() {
    return engineEndpoint.orElseThrow(
        () ->
            new InvalidConfigurationException(
                "Invalid configuration. --ee-endpoint parameter is mandatory when Bellatrix milestone is enabled"));
  }

  public Optional<String> getEngineJwtSecretFile() {
    return engineJwtSecretFile;
  }

  public Version getEngineVersion() {
    return engineVersion;
  }

  public Optional<String> getBuilderEndpoint() {
    return builderEndpoint;
  }

  public static class Builder {
    private Spec spec;
    private Optional<String> engineEndpoint = Optional.empty();
    private Version engineVersion = Version.DEFAULT_VERSION;
    private Optional<String> engineJwtSecretFile = Optional.empty();
    private Optional<String> builderEndpoint = Optional.empty();

    private Builder() {}

    public ExecutionLayerConfiguration build() {
      validateStubEndpoints();
      return new ExecutionLayerConfiguration(
          spec, engineEndpoint, engineVersion, engineJwtSecretFile, builderEndpoint);
    }

    public Builder engineEndpoint(final String engineEndpoint) {
      this.engineEndpoint = Optional.ofNullable(engineEndpoint);
      return this;
    }

    public Builder engineVersion(final Version version) {
      this.engineVersion = version;
      return this;
    }

    public Builder specProvider(final Spec spec) {
      this.spec = spec;
      return this;
    }

    public Builder engineJwtSecretFile(final String jwtSecretFile) {
      this.engineJwtSecretFile = Optional.ofNullable(jwtSecretFile).filter(StringUtils::isNotBlank);
      return this;
    }

    public Builder builderEndpoint(final String builderEndpoint) {
      this.builderEndpoint = Optional.ofNullable(builderEndpoint);
      return this;
    }

    private void validateStubEndpoints() {
      final boolean engineIsStub =
          engineEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);
      final boolean builderIsStub =
          builderEndpoint.map(endpoint -> endpoint.equals(STUB_ENDPOINT_IDENTIFIER)).orElse(false);

      checkState(
          engineIsStub == builderIsStub || builderEndpoint.isEmpty(),
          "mixed configuration with stubbed and non-stubbed execution layer endpoints is not supported");
    }
  }
}
```


Overlapping Code:
```
ration {
private final Spec spec;
private final Optional<String> engineEndpoint;
private final Version engineVersion;
private final Optional<String> engineJwtSecretFile;
private final Optional<String> builderEndpoint;
private ExecutionLayerConfiguration(
final Spec spec,
final Optional<String> engineEndpoint,
final Version engineVersion,
final Optional<String> engineJwtSecretFile,
final Optional<String> builderEndpoint) {
this.spec = spec;
this.engineEndpoint = engineEndpoint;
this.engineVersion = engineVersion;
this.engineJwtSecretFile = engineJwtSecretFile;
this.builderEndpoint = builderEndpoint;
}
public static Builder builder() {
return new Builder();
}
public boolean isEnabled() {
return spec.isMilestoneSupported(SpecMilestone.BELLATRIX);
}
public Spec getSpec() {
return spec;
}
public String getEngineEndpoint() {
return engineEndpoint.orElseThrow(
() ->
new InvalidConfigurationException(
"Invalid configuration. --ee-endpoint parameter is mandatory when Bellatrix milestone is enabled"));
}
public Optional<String> getEngineJwtSecretFile() {
return engineJwtSecretFile;
}
public Version getEngineVersion() {
return engineVersion;
}
public Optional<String> getBuilderEndpoint() {
return builderEndpoint;
}
public static class Builder {
private Spec spec;
private Optional<String> engineEndpoint = Optional.empty();
private Version engineVersion = Version.DEFAULT_VERSION;
private Optional<String> engineJwtSecretFile = Optional.empty();
private Optional<String> builderEndpoint = Optional.empty();
private Builder() {}
public ExecutionLayerConfiguration build() {
validateStubEndpoints();
return new ExecutionLayerConfiguration(
spec, engineEndpoint, engineVersion, engineJwtSecretFile, builderEndpoint);
}
public Builder engineEndpoint(final String engineEndpoint) {
this.engineEndpoint = Optional.ofNullable(engineEndpoint);
return this;
}
public Builder engineVersion(final Version version) {
this.engineVersion = version;
return this;
}
public Builder specProvider(final Spec spec) {
this.spec = spec;
return this;
}
public Builder engineJwtSecretFile(final String jwtSecretFile) {
this.engineJwtSecretFile = Optional.ofNullable(jwtSec
```
<Overlap Ratio: 0.980009086778737>

---

--- 311 --
Question ID: 7f60a2a0cf07b17a81254108d3bcdeb141b3471e
Original Code:
```
public class TimeHelper {
    private final Map<String, Long> mMap;

    private TimeHelper() {
        mMap = new ArrayMap<>();
    }

    public void start(@NonNull String id) {
        if (TextUtils.isEmpty(id) || mMap.containsKey(id)) {
            new IllegalArgumentException("Illegal id")
                    .printStackTrace();

            return;
        }

        mMap.put(id, System.currentTimeMillis());
    }

    public long stop(@NonNull String id) {
        if (TextUtils.isEmpty(id) || !mMap.containsKey(id)) {
            new IllegalArgumentException("Illegal id")
                    .printStackTrace();

            return 0L;
        }

        final long startTIme = mMap.remove(id);

        return System.currentTimeMillis() - startTIme;
    }

    public static TimeHelper getInstance() {
        return Holder.sInstance;
    }

    private interface Holder {
        TimeHelper sInstance = new TimeHelper();
    }
}
```


Overlapping Code:
```
blic class TimeHelper {
private final Map<String, Long> mMap;
private TimeHelper() {
mMap = new ArrayMap<>();
}
public void start(@NonNull String id) {
if (TextUtils.isEmpty(id) || mMap.containsKey(id)) {
new IllegalArgumentException("Illegal id")
.printStackTrace();
return;
}
mMap.put(id, System.currentTimeMillis());
}
public long stop(@NonNull String id) {
if (TextUtils.isEmpty(id) || !mMap.containsKey(id)) {
new IllegalArgumentException("Illegal id")
.printStackTrace();
return 0L;
}
final long startTIme = mMap.remove(id);
return System.currentTimeMillis() - startTIme;
}
public static TimeHelper getInstance() {
return Holder.sInstance;
}
private interface Holder {
TimeHelper sInstance = ne
```
<Overlap Ratio: 0.970873786407767>

---

--- 312 --
Question ID: b3e22891ce5d8c15a463f8031f247fd2ad09a813
Original Code:
```
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> ranges = new ArrayList<>();
        boolean isRange = false;
        for (int i = 0; i <= nums.length; i++) {
            if (i > 0 && i < nums.length && nums[i] - nums[i - 1] == 1) {
                isRange = true;
            } else if (isRange) {
                ranges.set(ranges.size() - 1, ranges.get(ranges.size() - 1) + "->" + Integer.toString(nums[i - 1]));
                if (i < nums.length) {
                    ranges.add(Integer.toString(nums[i]));
                }
                isRange = false;
            } else {
                if (i < nums.length) {
                    ranges.add(Integer.toString(nums[i]));
                }
            }
        }
        return ranges;
    }
}
```


Overlapping Code:
```
class Solution {
public List<String> summaryRanges(int[] nums) {
List<String> ranges = new ArrayList<>();
boolean isRange = false;
for (int i = 0; i <= nums.length; i++) {
if (i > 0 && i < nums.length && nums[i] - nums[i - 1] == 1) {
isRange = true;
} else if (isRange) {
ranges.set(ranges.size() - 1, ranges.get(ranges.size() - 1) + "->" + Integer.toString(nums[i - 1]));
if (i < nums.length) {
ranges.add(Integer.toString(nums[i]));
}
isRange = false;
} else {
if (i < nums.length) {
ranges.add(Int
```
<Overlap Ratio: 0.9107468123861566>

---

--- 313 --
Question ID: 701d7cddb4139c5c4c4ff51c366e9ea5e8229c0a
Original Code:
```
public class Block121 extends UIComponent {
    private UISpan title = new UISpan();
    private UIImage leftImage = new UIImage();
    private UrlRecord leftUrl = new UrlRecord();
    private UrlRecord rightUrl = new UrlRecord();
    private UISpan rightText = new UISpan();

    public Block121(UIComponent owner) {
        super(owner);
    }

    @Override
    public void output(HtmlWriter html) {
        html.println("<!-- %s -->", this.getClass().getName());
        html.print("<header  class='block121'>");
        if (this.leftImage.getSrc() != null && !"".equals(this.leftImage.getSrc())) {
            html.print("<a href='%s'  class='arrow-left'>", this.leftUrl.getUrl());
            this.leftImage.output(html);
            html.print("</a>");
        }
        html.print("<h1 class='title'>");
        this.title.output(html);
        html.print("</h1>");
        if (this.rightText.getText() != null && !"".equals(this.rightText.getText())) {
            html.print("<a href='%s' class='arrow-right'>", this.rightUrl.getUrl());
            this.rightText.output(html);
            html.print("</a>");
        }
        html.print("</header>");
    }

    public UrlRecord getRightUrl() {
        return rightUrl;
    }

    public UISpan getRightText() {
        return rightText;
    }

    public UISpan getTitle() {
        return title;
    }

    public UIImage getLeftImage() {
        return this.leftImage;
    }

    public UrlRecord getLeftUrl() {
        return leftUrl;
    }

}
```


Overlapping Code:
```
ss Block121 extends UIComponent {
private UISpan title = new UISpan();
private UIImage leftImage = new UIImage();
private UrlRecord leftUrl = new UrlRecord();
private UrlRecord rightUrl = new UrlRecord();
private UISpan rightText = new UISpan();
public Block121(UIComponent owner) {
super(owner);
}
@Override
public void output(HtmlWriter html) {
html.println("<!-- %s -->", this.getClass().getName());
html.print("<header class='block121'>");
if (this.leftImage.getSrc() != null && !"".equals(this.leftImage.getSrc())) {
html.print("<a href='%s' class='arrow-left'>", this.leftUrl.getUrl());
this.leftImage.output(html);
html.print("</a>");
}
html.print("<h1 class='title'>");
this.title.output(html);
html.print("</h1>");
if (this.rightText.getText() != null && !"".equals(this.rightText.getText())) {
html.print("<a href='%s' class='arrow-right'>", this.rightUrl.getUrl());
this.rightText.output(html);
html.print("</a>");
}
html.print("</header>");
}
public UrlRecord getRightUrl() {
return rightUrl;
}
public UISpan getRightText() {
return rightText;
}
public UISpan getTitle() {
return title;
}
public UIImage getLeftImage() {
return this.leftImage;
}
public UrlRecord getLeftUrl() {
return lef
```
<Overlap Ratio: 0.9844134536505332>

---

--- 314 --
Question ID: f00cefb6c7ab5e31256f7952232e39c564f67481
Original Code:
```
public class MinterSDK {
    @SuppressWarnings("unused")
    public final static String DEFAULT_COIN = BuildConfig.DEFAULT_COIN_NAME;
    @SuppressWarnings("unused")
    public final static BigInteger DEFAULT_COIN_ID = BigInteger.ZERO;
    public final static String PREFIX_ADDRESS = "Mx";
    public final static String PREFIX_TX = "Mt";
    public final static String PREFIX_CHECK = "Mc";
    public final static String PREFIX_PUBLIC_KEY = "Mp";
    private static MinterSDK INSTANCE;

    private MinterSDK() {
    }

    public static void initialize() throws NativeLoadException {
        if (INSTANCE != null) {
            return;
        }

        INSTANCE = new MinterSDK();

        NativeSecp256k1.init();
        NativeBip39.init();

        if (!NativeSecp256k1.isEnabled()) {
            throw new NativeLoadException(NativeSecp256k1.getError());
        }

        if (!NativeBip39.isEnabled()) {
            throw new NativeLoadException(NativeBip39.getError());
        }

        Security.insertProviderAt(new BouncyCastleProvider(), 1);
    }

    /**
     * Use this if you are catched {@link UnsatisfiedLinkError} and loaded native libraries by yourself, if not, it will crash at unexpected place
     * @param enabledNativeLibs
     */
    public static void setEnabledNativeLibs(boolean enabledNativeLibs) {
        NativeSecp256k1.setEnabled(enabledNativeLibs);
        NativeBip39.setEnabled(enabledNativeLibs);
    }

    public static MinterSDK getInstance() {
        if (INSTANCE == null) {
            throw new IllegalStateException("Did you forget to call MinterSDK.initialize()?");
        }
        return INSTANCE;
    }


}
```


Overlapping Code:
```
interSDK {
@SuppressWarnings("unused")
public final static String DEFAULT_COIN = BuildConfig.DEFAULT_COIN_NAME;
@SuppressWarnings("unused")
public final static BigInteger DEFAULT_COIN_ID = BigInteger.ZERO;
public final static String PREFIX_ADDRESS = "Mx";
public final static String PREFIX_TX = "Mt";
public final static String PREFIX_CHECK = "Mc";
public final static String PREFIX_PUBLIC_KEY = "Mp";
private static MinterSDK INSTANCE;
private MinterSDK() {
}
public static void initialize() throws NativeLoadException {
if (INSTANCE != null) {
return;
}
INSTANCE = new MinterSDK();
NativeSecp256k1.init();
NativeBip39.init();
if (!NativeSecp256k1.isEnabled()) {
throw new NativeLoadException(NativeSecp256k1.getError());
}
if (!NativeBip39.isEnabled()) {
throw new NativeLoadException(NativeBip39.getError());
}
Security.insertProviderAt(new BouncyCastleProvider(), 1);
}
/**
* Use this if you are catched {@link UnsatisfiedLinkError} and loaded native libraries by yourself, if not, it will crash at unexpected place
* @param enabledNativeLibs
*/
public static void setEnabledNativeLibs(boolean enabledNativeLibs) {
NativeSecp256k1.setEnabled(enabledNativeLibs);
NativeBip39.setEnabled(enabledNativeLibs);
}
public static MinterSDK getInstance() {
if (INSTANCE == null) {
throw new IllegalStateException("Did you forget to call MinterSDK.initializ
```
<Overlap Ratio: 0.9684361549497847>

---

--- 315 --
Question ID: 5711941de5e2c64e839760ce0516912ae3a5e68c
Original Code:
```
public class Optimizer {

    private final List<OptimizerPass> optimizationList = new ArrayList<>();
    protected List<CodeSequence> codeSequenceList = new ArrayList<>();

    protected boolean doDumping = false;
    protected String dumpingPath;

    protected Set<Obj> globalVariables;

    protected StringBuilder exceptionToThrow = new StringBuilder();

    public Optimizer(List<List<Quadruple>> code, List<Obj> functions, Set<Obj> globalVariables) {
        int i = 0;

        this.globalVariables = globalVariables;

        for (List<Quadruple> quadrupleList : code) {
            CodeSequence sequence = new CodeSequence();

            sequence.function = functions.get(i);
            sequence.labelIndices = BasicBlock.generateMapOfLabels(quadrupleList);
            sequence.basicBlocks = BasicBlock.extractBasicBlocksFromSequence(sequence.function, quadrupleList, sequence.labelIndices);
            assert sequence.basicBlocks != null;
            sequence.entryBlock = sequence.basicBlocks.stream().filter(BasicBlock::isEntryBlock).findFirst().orElseThrow();

            long numberOfBlocksWithoutPredecessors = sequence.basicBlocks.stream().filter(p -> p.predecessors.size() == 0).count();
            if (numberOfBlocksWithoutPredecessors > 1)
                exceptionToThrow.append("WARNING: At least one unreachable portion of code " +
                        "has been detected in function '" + sequence.function.getName() + "'.").append(System.lineSeparator());

            // update ENTER instruction and assign address to all variables
            Quadruple enterInstruction = sequence.entryBlock.instructions.get(1);

            Collection<Obj> allVariables = new HashSet<>();
            for (BasicBlock b : sequence.basicBlocks) {
                allVariables.addAll(b.extractAllVariables());
                allVariables.addAll(new HashSet<>(sequence.function.getLocalSymbols()));
            }

            int oldAllocationValue = ((QuadrupleIntegerConst) enterInstruction.getArg1()).getValue();

            //System.out.println("Variables for " + sequence.function.getName());
            int lastSize = giveAddressToTemps(allVariables, oldAllocationValue);

            enterInstruction.setArg1(new QuadrupleIntegerConst(SystemV_ABI.alignTo16(lastSize)));

            codeSequenceList.add(sequence);
            i++;
        }
    }

    public StringBuilder getExceptionToThrow() {
        return exceptionToThrow;
    }

    public static int giveAddressToAll(Collection<Obj> variables, int startValue) {
        for (Obj obj : variables) {
            int lastTaken = startValue;
            if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))
                lastTaken = SystemV_ABI.alignTo16(lastTaken);
            int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());
            obj.setAdr(thisVarAddress);
            startValue = thisVarAddress;

        }

        return startValue;
    }

    public static int giveAddressToTemps(Collection<Obj> variables, int startValue) {
        for (Obj obj : variables) {
            if (((obj.tempVar || obj.getName().startsWith(Config.prefix_phi)) || (obj.parameter && !obj.stackParameter)) && obj.getKind() != Obj.Con) {
                int lastTaken = startValue;
                if (SystemV_ABI.alignTo16(lastTaken) - lastTaken < SystemV_ABI.getX64VariableSize(obj.getType()))
                    lastTaken = SystemV_ABI.alignTo16(lastTaken);
                int thisVarAddress = lastTaken + SystemV_ABI.getX64VariableSize(obj.getType());
                obj.setAdr(thisVarAddress);
                startValue = thisVarAddress;
            }
        }

        return startValue;
    }

    @Override
    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();

        for (CodeSequence codeSequence : codeSequenceList) {
            if (codeSequence.inlined)
                continue;

            stringBuilder.append("-----------------------------------------------------------------------------------------\n");

            for (BasicBlock basicBlock : Optimizer.reassembleBasicBlocks(codeSequence.basicBlocks))
                for (Quadruple q : basicBlock.instructions)
                    stringBuilder.append(q).append(System.lineSeparator());

            stringBuilder.append("-----------------------------------------------------------------------------------------\n");
        }

        return stringBuilder.toString();
    }

    protected void addOptimizationPass(OptimizerPass optimizerPass) {
        optimizationList.add(optimizerPass);
    }

    public void executeOptimizations() {
        assert globalVariables != null;

        // non-SSA optimizations
        for (CodeSequence sequence : codeSequenceList) {
            // DO NOT REMOVE THIS LINE
            optimizationList.clear();

            // NOTE: do not comment the following line -> unreachable code elimination
            (new CFGCleaner(sequence)).optimize();

            internalDump(sequence, dumpingPath, "1_pre_non_ssa_opt_");

            addOptimizationPass(new ValueNumbering(sequence));
            addOptimizationPass(new FunctionInlining(sequence, codeSequenceList));
            addOptimizationPass(new CFGCleaner(sequence));

            for (OptimizerPass pass : optimizationList) {
                pass.optimize();
                pass.finalizePass();
            }

            internalDump(sequence, dumpingPath, "2_post_non_ssa_opt_");
        }

        // SSA optimizations
        for (CodeSequence sequence : codeSequenceList) {
            if (sequence.inlined)
                continue;

            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);
            SSAConverter ssaConverter = new SSAConverter(sequence.dominanceAnalyzer);

            // DO NOT REMOVE THIS LINE
            optimizationList.clear();

            ssaConverter.doPhiPlacement();
            ssaConverter.renameVariables();

            internalDump(sequence, dumpingPath, "3_pre_ssa_opt_");

            addOptimizationPass(new UninitializedVariableDetection(sequence, globalVariables));
            addOptimizationPass(new LoopInvariantCodeMotion(sequence));
            addOptimizationPass(new CFGCleaner(sequence));
            addOptimizationPass(new DeadCodeElimination(sequence)); // always call CFGCleaner after DCE
            addOptimizationPass(new CFGCleaner(sequence));
            for (OptimizerPass pass : optimizationList) {
                try {
                    pass.optimize();
                    pass.finalizePass();
                } catch (UninitializedVariableException ex) {
                    System.err.println(ex.getMessage());
                }
            }

            internalDump(sequence, dumpingPath, "4_post_ssa_opt_");

            // eliminating SSA from code
            ssaConverter.toNormalForm();

            internalDump(sequence, dumpingPath, "5_final_");
        }
    }

    public List<CodeSequence> getOptimizationOutput() {
        return codeSequenceList;
    }

    public static List<BasicBlock> reassembleBasicBlocks(List<BasicBlock> cfg) {
        /*List<BasicBlock> result = new ArrayList<>();

        Stack<BasicBlock> stack = new Stack<>();
        BasicBlock currentBlock = cfg.stream().filter(BasicBlock::isEntryBlock).collect(Collectors.toList()).get(0);
        // current block is the entry block

        int index = 0;
        while (index < cfg.size()) {
            if (cfg.size() == 1 || currentBlock.successor.size() == 0)
                result.add(currentBlock);
            else if (currentBlock.successor.size() == 1) {
                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);

                result.add(currentBlock);
                if (lastInstruction.getInstruction() == IRInstruction.JMP)
                    currentBlock = stack.pop();
                else
                    currentBlock = currentBlock.successor.get(0);
            } else if (currentBlock.successor.size() == 2) {
                Quadruple lastInstruction = currentBlock.instructions.get(currentBlock.instructions.size() - 1);

                QuadrupleLabel jumpDestination = (QuadrupleLabel) lastInstruction.getResult();

                BasicBlock successor1 = currentBlock.successor.get(0);
                BasicBlock successor2 = currentBlock.successor.get(1);

                BasicBlock addToStack = successor2;
                for (int i = 0; i < successor1.instructions.size(); i++) {
                    Quadruple q = successor1.instructions.get(i);
                    if (q.getInstruction() == IRInstruction.GEN_LABEL) {
                        if (((QuadrupleLabel) q.getArg1()).getLabelName().equals(jumpDestination.getLabelName())) {
                            addToStack = successor1;
                            break;
                        }
                    }
                }

                if (stack.isEmpty() || stack.peek() != addToStack)
                    stack.push(addToStack);
                result.add(currentBlock);
                currentBlock = (addToStack == successor1 ? successor2 : successor1);
            } else
                throw new RuntimeException("Basic block cannot have more than two successors.");

            // solution for IF without ELSE
            if (!stack.isEmpty() && stack.peek() == currentBlock)
                stack.pop();

            index++;
        }

        assert result.size() == result.stream().distinct().count();*/

        return cfg;
    }

    private void internalDump(CodeSequence sequence, String path, String prefix) {
        if (!doDumping)
            return;

        if (sequence.dominanceAnalyzer == null)
            sequence.dominanceAnalyzer = new DominanceAnalyzer(sequence);

        DominanceAnalyzer.dumpCFG(path + prefix + "cfg_" + sequence.function + ".dot",
                path + prefix + "rcfg_" + sequence.function + ".dot",
                sequence.dominanceAnalyzer.getBasicBlocks());
        DominanceAnalyzer.dumpDominatorTree(path + prefix + "dtree_" + sequence.function + ".dot",
                sequence.dominanceAnalyzer.getImmediateDominators());
        DominanceAnalyzer.dumpDominatorTree(path + prefix + "rdomtree_" + sequence.function + ".dot",
                sequence.dominanceAnalyzer.getReverseImmediateDominators());
    }

    public void setDumpFlag(String dumpingPath) {
        this.doDumping = true;
        this.dumpingPath = dumpingPath;
    }
}
```


Overlapping Code:
```
 List<OptimizerPass> optimizationList = new ArrayList<>();
protected List<CodeSequence> codeSequenceList = new ArrayList<>();
protected boolean doDumping = false;
protected String dumpingPath;
protected Set<Obj> globalVariables;
protected StringBuilder exceptionToThrow = new StringBuilder();
public Optimizer(List<List<Quadruple>> code, List<Obj> functions, Set<Obj> globalVariables) {
int i = 0;
this.globalVariables = globalVariables;
for (List<Quadruple> quadrupleList : code) {
CodeSequence sequence = new CodeSequence();
sequence.function = functions.get(i);
sequence.labelIndices = BasicBlock.generateMapOfLabels(quadrupleList);
sequence.basicBlocks = BasicBlock.extractBasicBlocksFromSequence(sequence.function, quadrupleList, sequence.labelIndices);
assert sequence.basicBlocks != null;
sequence.entryBlock = sequence.basicBlocks.stream().filter(BasicBlock::isEntryBlock).findFirst().orElseThrow();
long numberOfBlocksWithoutPredecessors = sequence.basicBlocks.stream().filter(p -> p.predecessors.size() == 0).count();
if (numberOfBlocksWithoutPredecessors > 1)
exceptionToThrow.append("WARNING: At least one unreachable portion of code " +
"has been detected in function '" + sequence.function.getName() + "'.").append(System.lineSeparator());
// update ENTER instruction and assign address to all variables
Quadruple enterInstruction = sequence.entryBlock.instructions.get(1);
Collection<Obj> allVariables = new HashSet<>();
for (BasicBlock b : sequence.basicBlocks) {
allVariables.addAll(b.extractAllVariables());
allVariables.addAll(new HashSet<>(sequence.function.getLocalSymbols()));
}
int oldAllocationValue = ((QuadrupleIntegerConst) enterInstruction.getArg1()).getValue();
//System.out.println("Variables for " + sequence.function.getName());
int lastSize = giveAddressToTemps(allVariables, oldAllocationValue);
enterInstruction.setArg1(new QuadrupleIntegerConst(SystemV_ABI.alignTo16(lastSize)));
codeSequenceList.add(sequence);
i++;
}
}
public StringBuilder getExceptionToThrow() {
return exceptionToThrow;
}
public static int giv
```
<Overlap Ratio: 0.9771210676835081>

---

--- 316 --
Question ID: ed642a17b04a00c6433c819f41e65b3a5dbb7279
Original Code:
```
public class PascalGen extends RandomVariateGenInt {
   protected int    n;
   protected double p;

   /**
    * Creates a Pascal random variate generator with parameters @f$n@f$
    * and @f$p@f$, using stream `s`.
    */
   public PascalGen (RandomStream s, int n, double p) {
      super (s, new PascalDist (n, p));
      setParams (n, p);
   }

   /**
    * Creates a new generator for the distribution `dist`, using stream
    * `s`.
    */
   public PascalGen (RandomStream s, PascalDist dist) {
      super (s, dist);
      if (dist != null)
         setParams (dist.getN1(), dist.getP());
   }

   /**
    * Generates a new variate from the *Pascal* distribution, with
    * parameters @f$n = @f$&nbsp;`n` and @f$p = @f$&nbsp;`p`, using stream
    * `s`.
    */
   public static int nextInt (RandomStream s, int n, double p) {
      return PascalDist.inverseF (n, p, s.nextDouble());
   }

   /**
    * Returns the parameter @f$n@f$ of this object.
    */
   public int getN() {
      return n;
   }

   /**
    * Returns the parameter @f$p@f$ of this object.
    */
   public double getP() {
      return p;
   }

   /**
    * Sets the parameter @f$n@f$ and @f$p@f$ of this object.
    */
   protected void setParams (int n, double p) {
      if (p < 0.0 || p > 1.0)
         throw new IllegalArgumentException ("p not in [0, 1]");
      if (n <= 0)
         throw new IllegalArgumentException ("n <= 0");
      this.p = p;
      this.n = n;
   }
}
```


Overlapping Code:
```
GenInt {
protected int n;
protected double p;
/**
* Creates a Pascal random variate generator with parameters @f$n@f$
* and @f$p@f$, using stream `s`.
*/
public PascalGen (RandomStream s, int n, double p) {
super (s, new PascalDist (n, p));
setParams (n, p);
}
/**
* Creates a new generator for the distribution `dist`, using stream
* `s`.
*/
public PascalGen (RandomStream s, PascalDist dist) {
super (s, dist);
if (dist != null)
setParams (dist.getN1(), dist.getP());
}
/**
* Generates a new variate from the *Pascal* distribution, with
* parameters @f$n = @f$&nbsp;`n` and @f$p = @f$&nbsp;`p`, using stream
* `s`.
*/
public static int nextInt (RandomStream s, int n, double p) {
return PascalDist.inverseF (n, p, s.nextDouble());
}
/**
* Returns the parameter @f$n@f$ of this object.
*/
public int getN() {
return n;
}
/**
* Returns the parameter @f$p@f$ of this object.
*/
public double getP() {
return p;
}
/**
* Sets the parameter @f$n@f$ and @f$p@f$ of this object.
*/
protected void setParams (int n, double p) {
if (p < 0.0 || p > 1.0)
throw new IllegalArgumentException ("p not in [0, 1]");
if (n <= 0)
throw new IllegalArgumentException ("n <= 0");
this.p = p;
this.n = n;
```
<Overlap Ratio: 0.9610073111291633>

---

--- 317 --
Question ID: 6573bb34150d1b5d261b5170dee911b127734cea
Original Code:
```
public class CommandQueryEngine implements IQueryEngine {
	public static final Log LOG = LogFactory.getLog(CommandQueryEngine.class);

	private static final MessageFormat SHELL_COMMAND_FORMAT = new MessageFormat(
			" sudo -u {0} -i \"source /etc/profile; {1} -e {2}\" ");
	private static final MessageFormat HIVE_COMMAND_FORMAT = new MessageFormat(
			" set hive.cli.print.header=true; use {0}; {1} ");
	private static final IQueryEngine INSTANCE = new CommandQueryEngine();

	public static IQueryEngine getInstance() {
		return INSTANCE;
	}

	@Override
	public QueryResult postQuery(Query query) {
		JobContext jobCtx = new JobContext();
		jobCtx.setId(query.getId());
		jobCtx.setUsername(query.getUsername());
		jobCtx.setPasswd(query.getPassword());
		jobCtx.setStoreResult(query.isStoreResult());
		jobCtx.setCommands(new String[] {
				"bash",
				"-c",
				buildExecCommand(query.getUsername(), query.getMode(),
						query.getDatabase(), query.getSql()) });
		jobCtx.setWorkDir(EnvironmentConstants.WORKING_DIRECTORY_ROOT
				+ File.separator + query.getId());

		Job job = JobAdapter.createJob(query.getMode(), jobCtx);
		JobManager.putJob(query.getId(), job, jobCtx);

		QueryResult queryRes = new QueryResult();
		queryRes.setId(query.getId());
		try {
			int exitCode = job.run();
			LOG.info("exitcode:" + exitCode + " ,id:" + jobCtx.getId());
			if (0 == exitCode) {
				queryRes.setSuccess(true);
				if (jobCtx.isStoreResult()) {
					String hdfsDataFileAbsolutePath = EnvironmentConstants.HDFS_DATA_ROOT_PATH
							+ File.separator
							+ Utilities.getLastPartFileName(jobCtx
									.getLocalDataPath());
					HDFSManager.putFileToHDFS(jobCtx.getLocalDataPath(),
							hdfsDataFileAbsolutePath);
					queryRes.setResultFilePath(hdfsDataFileAbsolutePath);
				}
				Utilities.fillInColumnsAndData(jobCtx.getStdout().toString(),
						queryRes);
			} else {
				queryRes.setErrorMsg(jobCtx.getStderr().toString());
			}
		} catch (Exception e) {
			LOG.error(e);
		} finally {
			FileUtils.deleteQuietly(new File(jobCtx.getWorkDir()));
			JobManager.removeJob(query.getId());
		}
		return queryRes;
	}

	private String getEngineCommandByMode(String mode) {
		if ("hive".equalsIgnoreCase(mode)) {
			return "hive";
		} else if ("shark".equalsIgnoreCase(mode)) {
			return "shark-witherror";
		}
		return mode;
	}

	private String buildExecCommand(String username, String mode,
			String database, String sql) {
		String hiveCommand = HIVE_COMMAND_FORMAT.format(new String[] {
				database, sql });
		String shellCommand = SHELL_COMMAND_FORMAT.format(new String[] {
				username, getEngineCommandByMode(mode), hiveCommand });
		if (LOG.isDebugEnabled()) {
			LOG.debug("execute command: " + shellCommand);
		}
		return shellCommand;
	}
}
```


Overlapping Code:
```
ueryEngine implements IQueryEngine {
public static final Log LOG = LogFactory.getLog(CommandQueryEngine.class);
private static final MessageFormat SHELL_COMMAND_FORMAT = new MessageFormat(
" sudo -u {0} -i \"source /etc/profile; {1} -e {2}\" ");
private static final MessageFormat HIVE_COMMAND_FORMAT = new MessageFormat(
" set hive.cli.print.header=true; use {0}; {1} ");
private static final IQueryEngine INSTANCE = new CommandQueryEngine();
public static IQueryEngine getInstance() {
return INSTANCE;
}
@Override
public QueryResult postQuery(Query query) {
JobContext jobCtx = new JobContext();
jobCtx.setId(query.getId());
jobCtx.setUsername(query.getUsername());
jobCtx.setPasswd(query.getPassword());
jobCtx.setStoreResult(query.isStoreResult());
jobCtx.setCommands(new String[] {
"bash",
"-c",
buildExecCommand(query.getUsername(), query.getMode(),
query.getDatabase(), query.getSql()) });
jobCtx.setWorkDir(EnvironmentConstants.WORKING_DIRECTORY_ROOT
+ File.separator + query.getId());
Job job = JobAdapter.createJob(query.getMode(), jobCtx);
JobManager.putJob(query.getId(), job, jobCtx);
QueryResult queryRes = new QueryResult();
queryRes.setId(query.getId());
try {
int exitCode = job.run();
LOG.info("exitcode:" + exitCode + " ,id:" + jobCtx.getId());
if (0 == exitCode) {
queryRes.setSuccess(true);
if (jobCtx.isStoreResult()) {
String hdfsDataFileAbsolutePath = EnvironmentConstants.HDFS_DATA_ROOT_PATH
+ File.separator
+ Utilities.getLastPartFileName(jobCtx
.getLocalDataPath());
HDFSManager.putFileToHDFS(jobCtx.getLocalDataPath(),
hdfsDataFileAbsolutePath);
queryRes.setResultFilePath(hdfsDataFileAbsolutePath);
}
Utilities.fillInColumnsAndData(jobCtx.getStdout().toString(),
queryRes);
} else {
queryRes.setErrorMsg(jobCtx.getStderr().toString());
}
} catch (Exception e) {
LOG.error(e);
} finally {
FileUtils.deleteQuietly(new File(jobCtx.getWorkDir()));
JobManager.removeJob(query.getId());
}
return queryRes;
}
private String getEngineCommandByMode(String mode) {
if ("hive".equalsIgnoreCase(mode)) {
return "hive";
} else if ("shark".equalsIgnoreCase(mode)) {
return "shark-witherror";
}
return mode;
}
private String buildExecCommand(String username, String mode,
String database, String sql) {
String hiveCommand = HIVE_COMMAN
```
<Overlap Ratio: 0.9778357235984355>

---

--- 318 --
Question ID: 611780d35f607cc64b3f7e9e2beecf6317a8442d
Original Code:
```
public class DepositDataFunction
        extends PagedBaseFunction<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> {

    private static final String FUNC_NAME = DepositFunction.getMainDescriptor() + "_data";

    public DepositDataFunction(Object descriptor, QueryParameters params, String continuationToken) {
        super(descriptor, params, FUNC_NAME, continuationToken);
    }

    protected FunctionQueryContext getContext(QueryContext context) {
        return super.getContext(context, FunctionQueryContext.class);
    }

    @Override
    public QueryResult<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> execute(
            QueryContext context) throws QueryExecutionException {
        FunctionQueryContext functionContext = getContext(context);
        DepositParameters parameters = new DepositParameters(
                getQueryParameters(),
                getQueryParameters().getDerivedParameters());

        try {
            Collection<Map.Entry<Long, StatDeposit>> result = functionContext.getSearchDao().getDeposits(
                    parameters,
                    TypeUtil.toLocalDateTime(parameters.getFromTime()),
                    TypeUtil.toLocalDateTime(parameters.getToTime()),
                    getFromId().orElse(null),
                    parameters.getSize()
            );
            return new BaseQueryResult<>(result::stream, () -> result);
        } catch (DaoException e) {
            throw new QueryExecutionException(e);
        }
    }
}
```


Overlapping Code:
```
Function
extends PagedBaseFunction<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> {
private static final String FUNC_NAME = DepositFunction.getMainDescriptor() + "_data";
public DepositDataFunction(Object descriptor, QueryParameters params, String continuationToken) {
super(descriptor, params, FUNC_NAME, continuationToken);
}
protected FunctionQueryContext getContext(QueryContext context) {
return super.getContext(context, FunctionQueryContext.class);
}
@Override
public QueryResult<Map.Entry<Long, StatDeposit>, Collection<Map.Entry<Long, StatDeposit>>> execute(
QueryContext context) throws QueryExecutionException {
FunctionQueryContext functionContext = getContext(context);
DepositParameters parameters = new DepositParameters(
getQueryParameters(),
getQueryParameters().getDerivedParameters());
try {
Collection<Map.Entry<Long, StatDeposit>> result = functionContext.getSearchDao().getDeposits(
parameters,
TypeUtil.toLocalDateTime(parameters.getFromTime()),
TypeUtil.toLocalDateTime(parameters.getToTime()),
getFromId().orElse(null),
parameters.getSize()
);
return new BaseQueryResult<>(result::stream, () -> result);
} catch (DaoException e) {
throw new QueryExecutionException(e);
}
}
}
```
<Overlap Ratio: 0.9807692307692307>

---

--- 319 --
Question ID: 0e9e02ded21272f19e8102222a48b78eb4b63383
Original Code:
```
public class WeightedKNearestNeighborsClassifier extends KNearestNeighborsClassifier {
    
    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm, int k) {
        super (dm, k);
    }
    public WeightedKNearestNeighborsClassifier (DistanceMeasure dm) {
        super (dm);
    }
    public WeightedKNearestNeighborsClassifier () {
        super ();
    }

    @Override
    public synchronized ClassProbabilityDistribution classDistribution (Features df) {
        HashMap<Features, Double> knearest = new HashMap<>(distance(df));
        HashMap<Features, Double> wvf = new HashMap<>(weightedVotingFunction(df, knearest));
        // Create Classification Distribution
        ClassProbabilityDistribution res = new ClassProbabilityDistribution();
        knearest.keySet().stream().forEach ((Features x) -> {
            double value = res.getOrDefault(x.getLabel(), 0.0);
            double vote = wvf.get(x);
            res.put(x.getLabel(), value + vote);
        });
        return res;
    }
    
    protected Map<Features, Double> weightedVotingFunction (Features f, Map<Features, Double> dis) {
        double sum = 0.0;
        for (double x : dis.values()) {
            sum += x;
        }
        HashMap<Features, Double> res = new HashMap<>(dis);
        for (Features x : dis.keySet()) {
            res.put(x, 1 - (dis.get(x) / sum));
        }
        return res;
    }
}
```


Overlapping Code:
```
borsClassifier extends KNearestNeighborsClassifier {

public WeightedKNearestNeighborsClassifier (DistanceMeasure dm, int k) {
super (dm, k);
}
public WeightedKNearestNeighborsClassifier (DistanceMeasure dm) {
super (dm);
}
public WeightedKNearestNeighborsClassifier () {
super ();
}
@Override
public synchronized ClassProbabilityDistribution classDistribution (Features df) {
HashMap<Features, Double> knearest = new HashMap<>(distance(df));
HashMap<Features, Double> wvf = new HashMap<>(weightedVotingFunction(df, knearest));
// Create Classification Distribution
ClassProbabilityDistribution res = new ClassProbabilityDistribution();
knearest.keySet().stream().forEach ((Features x) -> {
double value = res.getOrDefault(x.getLabel(), 0.0);
double vote = wvf.get(x);
res.put(x.getLabel(), value + vote);
});
return res;
}

protected Map<Features, Double> weightedVotingFunction (Features f, Map<Features, Double> dis) {
double sum = 0.0;
for (double x : dis.values()) {
sum += x;
}
HashMap<Features, Double> res = new HashMap<>(dis);
for (Features x : dis.keySet()) {
res.put(x, 1 - (dis.get(x) / s
```
<Overlap Ratio: 0.9507346585998271>

---

--- 320 --
Question ID: 4e4636fa00cc7eafe82760fe9c4d53b4293912ca
Original Code:
```
public class TestHeader extends LCCoreAbstractTest {

	@Test
	public void testMimeHeader() throws Exception {
		MimeHeader h = new MimeHeader("X-Test", "toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc");
		Assert.assertEquals("X-Test", h.getName());
		Assert.assertEquals("x-test", h.getNameLowerCase());
		Assert.assertEquals("toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc", h.getRawValue());
		ParameterizedHeaderValues values = h.getValue(ParameterizedHeaderValues.class);
		Assert.assertEquals(3, values.getValues().size());
		ParameterizedHeaderValue v = values.getMainValue("toto");
		Assert.assertNotNull(v);
		Assert.assertEquals(2, v.getParameters().size());
		Assert.assertEquals("tata", v.getParameter("titi"));
		Assert.assertEquals("world", v.getParameter("hello"));
		Assert.assertNull(v.getParameter("heho"));
		Assert.assertNull(v.getParameter("aa"));
		Assert.assertNull(v.getParameter("bb"));
		v = values.getMainValue("heho");
		Assert.assertNotNull(v);
		Assert.assertEquals(0, v.getParameters().size());
		Assert.assertNull(v.getParameter("aa"));
		Assert.assertNull(v.getParameterIgnoreCase("bb"));
		v = values.getMainValue("aa");
		Assert.assertNotNull(v);
		Assert.assertEquals(1, v.getParameters().size());
		Assert.assertEquals("cc", v.getParameter("bb"));
		
		Assert.assertNull(values.getMainValue("abcd"));
		Assert.assertFalse(values.hasMainValue("abcd"));
		Assert.assertTrue(values.hasMainValue("aa"));
		CharArrayStringBuffer s = new CharArrayStringBuffer();
		values.generate(s, 17, 13);
		Assert.assertEquals("toto;titi=tata;\r\n\thello=world,\r\n\theho,aa;bb=cc", s.toString());
		
		h.setRawValue("hello; fr=bonjour");
		Assert.assertEquals("hello; fr=bonjour", h.getRawValue());
		h.appendTo(new CharArrayStringBuffer());
		v = h.getValue(ParameterizedHeaderValue.class);
		Assert.assertEquals("hello", v.getMainValue());
		Assert.assertEquals("bonjour", v.getParameter("fr"));
		v = h.getValue(ParameterizedHeaderValue.class);
		Assert.assertEquals("hello", v.getMainValue());
		Assert.assertEquals("bonjour", v.getParameterIgnoreCase("FR"));
		h.setValue(new ParameterizedHeaderValue("world", "fr", "monde", "test", "yes"));
		Assert.assertEquals("world;fr=monde;test=yes", h.getRawValue());
		h.setValue(new ParameterizedHeaderValue("world", "fr", "monde", "test", "yes"));
		h.appendTo(new CharArrayStringBuffer());
		v.setMainValue("hello");
		v.setParameter("turlututu", "pointu");
		
		MimeHeaders mime = new MimeHeaders(
			new MimeHeader("h1", "v1"),
			new MimeHeader("h2", "v2")
		);
		mime.add(new MimeHeader("h3", "v3"));
		mime.set(new MimeHeader("h1", "v11"));
		mime.set(new MimeHeader("h4", "v4"));
		Assert.assertEquals(4, mime.getHeaders().size());
	}
	
	@Test
	public void testParser() {
		List<Token> tokens = MimeHeaderValueParser.parse("hello (a comment)  world [domain]  <user@mail.com> \"bonjour  \\\"ami\\\"\"");
		Iterator<Token> it = tokens.iterator();
		Token tok = it.next();
		Assert.assertEquals(Word.class, tok.getClass());
		Assert.assertEquals("hello", ((Word)tok).getContent());
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(Comment.class, tok.getClass());
		Assert.assertEquals("(a comment)", ((Comment)tok).asString());
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(Word.class, tok.getClass());
		Assert.assertEquals("world", ((Word)tok).getContent());
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(DomainLiteral.class, tok.getClass());
		Assert.assertEquals("[domain]", ((DomainLiteral)tok).asString());
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(Address.class, tok.getClass());
		Assert.assertEquals("<user@mail.com>", ((Address)tok).asString());
		((Address)tok).getContent();
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(Word.class, tok.getClass());
		Assert.assertEquals("bonjour  \"ami\"", ((Word)tok).getContent());
		Assert.assertFalse(it.hasNext());

	
		tokens = MimeHeaderValueParser.parse("(comment1 [domain1 (comment2) [domain2]] (comment3))");
		it = tokens.iterator();
		tok = it.next();
		Assert.assertEquals(Comment.class, tok.getClass());
		Assert.assertFalse(it.hasNext());
		it = ((Comment)tok).getContent().iterator();
		tok = it.next();
		Assert.assertEquals(Word.class, tok.getClass());
		Assert.assertEquals("comment1", ((Word)tok).getContent());
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(DomainLiteral.class, tok.getClass());

		Iterator<Token> it2 = ((DomainLiteral)tok).getContent().iterator();
		Token tok2 = it2.next();
		Assert.assertEquals(Word.class, tok2.getClass());
		Assert.assertEquals("domain1", ((Word)tok2).getContent());
		tok2 = it2.next();
		Assert.assertEquals(Space.class, tok2.getClass());
		tok2 = it2.next();
		Assert.assertEquals(Comment.class, tok2.getClass());
		Assert.assertEquals("(comment2)", ((Comment)tok2).asString());
		tok2 = it2.next();
		Assert.assertEquals(Space.class, tok2.getClass());
		tok2 = it2.next();
		Assert.assertEquals(DomainLiteral.class, tok2.getClass());
		Assert.assertEquals("[domain2]", ((DomainLiteral)tok2).asString());
		Assert.assertFalse(it2.hasNext());
		
		tok = it.next();
		Assert.assertEquals(Space.class, tok.getClass());
		tok = it.next();
		Assert.assertEquals(Comment.class, tok.getClass());
		Assert.assertEquals("(comment3)", ((Comment)tok).asString());
		Assert.assertFalse(it.hasNext());
		
		tokens = MimeHeaderValueParser.parse(" hel\\5lo ");
		Token.trim(tokens);
		Assert.assertEquals(1, tokens.size());
		Assert.assertEquals(Word.class, tokens.get(0).getClass());
		Assert.assertEquals("hel5lo", ((Word)tokens.get(0)).getContent());
	}
	
	@Test
	public void testMimeHeaders() {
		MimeHeaders headers = new MimeHeaders();
		headers.setRawValue("test", "hello");
		Assert.assertNull(headers.getFirstLongValue("test"));
		Assert.assertTrue(headers.has("test"));
		Assert.assertFalse(headers.has("test2"));
		Assert.assertNull(headers.getContentTypeValue());
		headers.setRawValue("Content-Type", "=?toto?=");
		Assert.assertNull(headers.getContentTypeValue());
		
		AsyncSupplier<Boolean, MimeException> consume = headers.createConsumer(10).consume(new ByteArray("X-Header: x-value\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
		
		consume = headers.createConsumer(10).consume(new ByteArray("X-Header-TooLong: x-value\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
		
		consume = headers.createConsumer(10).consume(new ByteArray("X: y\r\nZ: zzzzzzzzzz\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
		
		consume = headers.createConsumer(10).consume(new ByteArray("X: abcde\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
		
		consume = headers.createConsumer(100).consume(new ByteArray(" X: abcde\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
		
		consume = headers.createConsumer(100).consume(new ByteArray("123465789\r\n\r\n".getBytes(StandardCharsets.US_ASCII)));
		consume.block(0);
		Assert.assertTrue(consume.hasError());
	}
	
	public static class Container implements MimeHeadersContainer<Container> {
		
		private MimeHeaders headers = new MimeHeaders();
		
		@Override
		public MimeHeaders getHeaders() {
			return headers;
		}
	}
	
	@Test
	public void testHeadersContainer() throws Exception {
		Container c = new Container();
		c.addHeader(new MimeHeader("a", "b"));
		c.addHeader("c", "d");
		c.addHeader("e", new ParameterizedHeaderValue("f", "g", "h"));
		Assert.assertEquals("b", c.getHeaders().getFirstRawValue("a"));
		Assert.assertEquals("d", c.getHeaders().getFirstRawValue("c"));
		c.setHeader("c", "1");
		Assert.assertEquals("1", c.getHeaders().getFirstRawValue("c"));
		c.setHeader(new MimeHeader("c", "2"));
		Assert.assertEquals("2", c.getHeaders().getFirstRawValue("c"));
		c.setHeader("c", new ParameterizedHeaderValue("A", "B", "C"));
		Assert.assertEquals("A", c.getHeaders().getFirstValue("c", ParameterizedHeaderValue.class).getMainValue());
	}
	
}
```


Overlapping Code:
```
s TestHeader extends LCCoreAbstractTest {
@Test
public void testMimeHeader() throws Exception {
MimeHeader h = new MimeHeader("X-Test", "toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc");
Assert.assertEquals("X-Test", h.getName());
Assert.assertEquals("x-test", h.getNameLowerCase());
Assert.assertEquals("toto; titi=tata; (a comment) hello=world, heho, aa; bb=cc", h.getRawValue());
ParameterizedHeaderValues values = h.getValue(ParameterizedHeaderValues.class);
Assert.assertEquals(3, values.getValues().size());
ParameterizedHeaderValue v = values.getMainValue("toto");
Assert.assertNotNull(v);
Assert.assertEquals(2, v.getParameters().size());
Assert.assertEquals("tata", v.getParameter("titi"));
Assert.assertEquals("world", v.getParameter("hello"));
Assert.assertNull(v.getParameter("heho"));
Assert.assertNull(v.getParameter("aa"));
Assert.assertNull(v.getParameter("bb"));
v = values.getMainValue("heho");
Assert.assertNotNull(v);
Assert.assertEquals(0, v.getParameters().size());
Assert.assertNull(v.getParameter("aa"));
Assert.assertNull(v.getParameterIgnoreCase("bb"));
v = values.getMainValue("aa");
Assert.assertNotNull(v);
Assert.assertEquals(1, v.getParameters().size());
Assert.assertEquals("cc", v.getParameter("bb"));

Assert.assertNull(values.getMainValue("abcd"));
Assert.assertFalse(values.hasMainValue("abcd"));
Assert.assertTrue(values.hasMainValue("aa"));
CharArrayStringBuffer s = new CharArrayStringBuffer();
values.generate(s, 17, 13);
Assert.assertEquals("toto;titi=tata;\r\n\thello=world,\r\n\theho,aa;bb=cc", s.toString());

h.setRawValue("hello; fr=bonjour");
Assert.assertEquals("hello; fr=bonjour", h.getRawValue());
h.appendTo(new CharArrayStringBuffer());
v = h.getValue(ParameterizedHeaderValue.class);
Assert.assertEquals("hello", v.getMainValue());
Assert.assertEquals("bonjour", v.getParameter("fr"));
v = h.getValue(ParameterizedHeaderValue.class);
Assert.assertEquals("hello", v.getMainValue());
Assert.assertEquals("bonjour", v.getParameterIgnoreCase("FR"));
h.setValue(new ParameterizedHeaderValue("world", "fr", "monde", "test", "yes"));
Assert.assertEquals("world;fr=monde;test=yes", h.getRawValue());
h.setValue(new ParameterizedHeaderValue("world", "fr", "monde", "test", "yes"));
h.appendTo(new CharArrayStringBuffer());
v.setMainValue("hello
```
<Overlap Ratio: 0.9774755631109222>

---

--- 321 --
Question ID: 3feb49bc81f001ddcb0e322c540c724b505976bb
Original Code:
```
public class TestingUtils {
    public static SimpleDateFormat getFormatter(String pattern) {
        SimpleDateFormat sdf = new SimpleDateFormat(pattern);
        sdf.setTimeZone(TimeZone.getTimeZone(ZoneId.of("UTC")));
        return sdf;
    }
}
```


Overlapping Code:
```
blic class TestingUtils {
public static SimpleDateFormat getFormatter(String pattern) {
SimpleDateFormat sdf = new SimpleDateFormat(pattern);
sdf.setTimeZone(TimeZone.getTimeZone(ZoneId.of("UTC")));
re
```
<Overlap Ratio: 0.9305555555555556>

---

--- 322 --
Question ID: c5eecbac28a15c265e1d8b614660d6c86efff699
Original Code:
```
public class SnappyCodec implements Configurable, CompressionCodec {
  public static final String SNAPPY_BUFFER_SIZE_KEY = "io.compression.codec.snappy.buffersize";
  public static final int DEFAULT_SNAPPY_BUFFER_SIZE = 256 * 1024;

  Configuration conf;

  public void setConf(Configuration conf) {
    this.conf = conf;
  }

  public Configuration getConf() {
    return conf;
  }

  private static boolean nativeSnappyLoaded = false;

  static {
    if (SnappyNativeCodeLoader.isNativeCodeLoaded()) {
      nativeSnappyLoaded = SnappyCompressor.isNativeSnappyLoaded()
          && SnappyDecompressor.isNativeSnappyLoaded();
    }
  }
  
  /**
   * Are the native snappy libraries loaded & initialized? 
   * 
   * @param conf configuration
   * @return true if loaded & initialized, otherwise false
   */
  public static boolean isNativeSnappyLoaded(Configuration conf) {
    return nativeSnappyLoaded && conf.getBoolean("hadoop.native.lib", true);
  }

  public CompressionOutputStream createOutputStream(OutputStream out)
      throws IOException {
    return createOutputStream(out, createCompressor());
  }

  public CompressionOutputStream createOutputStream(OutputStream out,
      Compressor compressor) throws IOException {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }
    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,
        DEFAULT_SNAPPY_BUFFER_SIZE);

    int compressionOverhead = (bufferSize >> 3) + 128 + 3;
    // int compressionOverhead = 0;

    return new BlockCompressorStream(out, compressor, bufferSize,
        compressionOverhead);
  }

  public Class<? extends Compressor> getCompressorType() {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }

    return SnappyCompressor.class;
  }

  public Compressor createCompressor() {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }
    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,
        DEFAULT_SNAPPY_BUFFER_SIZE);
    return new SnappyCompressor(bufferSize);
  }

  public CompressionInputStream createInputStream(InputStream in)
      throws IOException {
    return createInputStream(in, createDecompressor());
  }

  public CompressionInputStream createInputStream(InputStream in,
      Decompressor decompressor) throws IOException {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }

    return new BlockDecompressorStream(in, decompressor, conf.getInt(
        SNAPPY_BUFFER_SIZE_KEY, DEFAULT_SNAPPY_BUFFER_SIZE));
  }

  public Class<? extends Decompressor> getDecompressorType() {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }

    return SnappyDecompressor.class;
  }

  public Decompressor createDecompressor() {
    if (!isNativeSnappyLoaded(conf)) {
      throw new RuntimeException("native snappy library not available");
    }
    int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,
        DEFAULT_SNAPPY_BUFFER_SIZE);
    return new SnappyDecompressor(bufferSize);
  }

  public String getDefaultExtension() {
    return ".snappy";
  }
}
```


Overlapping Code:
```
ss SnappyCodec implements Configurable, CompressionCodec {
public static final String SNAPPY_BUFFER_SIZE_KEY = "io.compression.codec.snappy.buffersize";
public static final int DEFAULT_SNAPPY_BUFFER_SIZE = 256 * 1024;
Configuration conf;
public void setConf(Configuration conf) {
this.conf = conf;
}
public Configuration getConf() {
return conf;
}
private static boolean nativeSnappyLoaded = false;
static {
if (SnappyNativeCodeLoader.isNativeCodeLoaded()) {
nativeSnappyLoaded = SnappyCompressor.isNativeSnappyLoaded()
&& SnappyDecompressor.isNativeSnappyLoaded();
}
}

/**
* Are the native snappy libraries loaded & initialized? 
* 
* @param conf configuration
* @return true if loaded & initialized, otherwise false
*/
public static boolean isNativeSnappyLoaded(Configuration conf) {
return nativeSnappyLoaded && conf.getBoolean("hadoop.native.lib", true);
}
public CompressionOutputStream createOutputStream(OutputStream out)
throws IOException {
return createOutputStream(out, createCompressor());
}
public CompressionOutputStream createOutputStream(OutputStream out,
Compressor compressor) throws IOException {
if (!isNativeSnappyLoaded(conf)) {
throw new RuntimeException("native snappy library not available");
}
int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,
DEFAULT_SNAPPY_BUFFER_SIZE);
int compressionOverhead = (bufferSize >> 3) + 128 + 3;
// int compressionOverhead = 0;
return new BlockCompressorStream(out, compressor, bufferSize,
compressionOverhead);
}
public Class<? extends Compressor> getCompressorType() {
if (!isNativeSnappyLoaded(conf)) {
throw new RuntimeException("native snappy library not available");
}
return SnappyCompressor.class;
}
public Compressor createCompressor() {
if (!isNativeSnappyLoaded(conf)) {
throw new RuntimeException("native snappy library not available");
}
int bufferSize = conf.getInt(SNAPPY_BUFFER_SIZE_KEY,
DEFAULT_SNAPPY_BUFFER_SIZE);
return new SnappyCompressor(bufferSize);
}
public CompressionInputStream createInputStream(InputStream in)
throws IOException {
return createInputStream(in, createDecompressor());
}
public CompressionInputStream createInputStream(InputStream in,
Decompressor decompressor) th
```
<Overlap Ratio: 0.9945004582951421>

---

--- 323 --
Question ID: f976d592164f77c32e8e5ff324db9bcca9393430
Original Code:
```
public class EnvironmentVariable {
    public static void main(String[] args) {
        // 使用 System.getenv() 获取所有环境变量
        Map<String, String> map = System.getenv();
        System.out.println(map);
        // 使用 System.getenv("xxx") 获取指定的环境变量
        System.out.println(System.getenv("JAVA_HOME"));
    }
}
```


Overlapping Code:
```
public class EnvironmentVariable {
public static void main(String[] args) {
// 使用 System.getenv() 获取所有环境变量
Map<String, String> map = System.getenv();
System.out.println(map);
// 使用 System.getenv("xxx") 获取指定的环境变量
System.o
```
<Overlap Ratio: 0.8365019011406845>

---

--- 324 --
Question ID: 910ae74fd7d5dace25c08978011bbbc12a5ca114
Original Code:
```
public class ProfileManagerTest {

    private ProfileManager profileManager = new ProfileManager();

    @Test
    public void constructor() {
        assertEquals(new UserPrefs(), profileManager.getUserPrefs());
        assertEquals(new GuiSettings(), profileManager.getGuiSettings());
        assertEquals(new ProfileList(), profileManager.getProfileList());
    }

    @Test
    public void setUserPrefs_nullUserPrefs_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.setUserPrefs(null));
    }

    @Test
    public void setUserPrefs_validUserPrefs_copiesUserPrefs() {
        UserPrefs userPrefs = new UserPrefs();
        userPrefs.setAddressBookFilePath(Paths.get("address/book/file/path"));
        userPrefs.setGuiSettings(new GuiSettings(1, 2, 3, 4));
        profileManager.setUserPrefs(userPrefs);
        assertEquals(userPrefs, profileManager.getUserPrefs());

        // Modifying userPrefs should not modify profileManager's userPrefs
        UserPrefs oldUserPrefs = new UserPrefs(userPrefs);
        userPrefs.setAddressBookFilePath(Paths.get("new/address/book/file/path"));
        assertEquals(oldUserPrefs, profileManager.getUserPrefs());
    }

    @Test
    public void setGuiSettings_nullGuiSettings_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.setGuiSettings(null));
    }

    @Test
    public void setGuiSettings_validGuiSettings_setsGuiSettings() {
        GuiSettings guiSettings = new GuiSettings(1, 2, 3, 4);
        profileManager.setGuiSettings(guiSettings);
        assertEquals(guiSettings, profileManager.getGuiSettings());
    }

    @Test
    public void setProfileListFilePath_nullPath_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.setProfileListFilePath(null));
    }

    @Test
    public void setProfileListFilePath_validPath_setsAddressBookFilePath() {
        Path path = Paths.get("address/book/file/path");
        profileManager.setProfileListFilePath(path);
        assertEquals(path, profileManager.getProfileListFilePath());
    }

    @Test
    public void hasProfile_nullPerson_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.hasProfile(null));
    }

    @Test
    public void hasProfile_profileNotInProfileList_returnsFalse() {
        assertFalse(profileManager.hasProfile(ALICE.getName()));
    }

    @Test
    public void hasProfile_profileInProfileList_returnsTrue() {
        profileManager.addProfile(ALICE);
        assertTrue(profileManager.hasProfile(ALICE.getName()));
        profileManager.deleteProfile(ALICE);
    }

    @Test
    public void hasProfile_profileDeletedFromProfileList_returnsFalse() {
        profileManager.addProfile(ALICE);
        profileManager.deleteProfile(ALICE);
        assertFalse(profileManager.hasProfile((ALICE.getName())));
    }

    @Test
    public void hasProfile_profileReplacedInProfileList_returnsTrue() {
        profileManager.addProfile(ALICE);
        profileManager.setProfile(ALICE, BENSON);
        assertTrue(profileManager.hasProfile(BENSON.getName()));
        profileManager.deleteProfile(BENSON);
    }


    @Test
    public void hasProfile_profileReplacedInProfileList_returnFalse() {
        profileManager.addProfile(ALICE);
        profileManager.setProfile(ALICE, BENSON);
        assertFalse(profileManager.hasProfile((ALICE.getName())));
        profileManager.deleteProfile(BENSON);
    }

    @Test
    public void getFilteredPersonList_modifyList_throwsUnsupportedOperationException() {
        assertThrows(UnsupportedOperationException.class, () -> profileManager.getFilteredPersonList().remove(0));
    }

    @Test
    public void hasOneProfile_profileInProfileList_returnsTrue() {
        profileManager.addProfile(ALICE);
        assertTrue(profileManager.hasOneProfile());
        profileManager.deleteProfile(ALICE);
    }

    @Test
    public void hasOneProfile_profileNotInProfileList_returnsFalse() {
        assertFalse(profileManager.hasOneProfile());
    }

    @Test
    public void getFirstProfile_profileInProfileList_returnsTrue() {
        profileManager.addProfile(BENSON);
        assertTrue(profileManager.getFirstProfile().equals(BENSON));
        profileManager.deleteProfile(BENSON);
    }

    @Test
    public void getFirstProfile_profileNotInProfileList_returnsFalse() {
        profileManager.addProfile(BENSON);
        assertFalse(profileManager.getFirstProfile().equals(ALICE));
        profileManager.deleteProfile(BENSON);
    }

    @Test
    public void addDeadline_nullDeadline_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.addDeadline(null));
    }

    @Test
    public void deleteDeadline_nullDeadline_throwsNullPointerException() {
        assertThrows(NullPointerException.class, () -> profileManager.deleteDeadline(null));
    }

    @Test
    public void replaceDeadline_nullDeadline_throwsNullPointerException() {
        Deadline deadline = new Deadline("CS1101S", "Dummy description");
        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(deadline, null));
        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, deadline));
        assertThrows(NullPointerException.class, () -> profileManager.replaceDeadline(null, null));
    }

    @Test
    public void clearDeadlineList_listSizeZero_returnsTrue() {
        profileManager.clearDeadlineList();
        assertTrue(profileManager.getSortedDeadlineList().size() == 0);
    }


}
```


Overlapping Code:
```
ublic class ProfileManagerTest {
private ProfileManager profileManager = new ProfileManager();
@Test
public void constructor() {
assertEquals(new UserPrefs(), profileManager.getUserPrefs());
assertEquals(new GuiSettings(), profileManager.getGuiSettings());
assertEquals(new ProfileList(), profileManager.getProfileList());
}
@Test
public void setUserPrefs_nullUserPrefs_throwsNullPointerException() {
assertThrows(NullPointerException.class, () -> profileManager.setUserPrefs(null));
}
@Test
public void setUserPrefs_validUserPrefs_copiesUserPrefs() {
UserPrefs userPrefs = new UserPrefs();
userPrefs.setAddressBookFilePath(Paths.get("address/book/file/path"));
userPrefs.setGuiSettings(new GuiSettings(1, 2, 3, 4));
profileManager.setUserPrefs(userPrefs);
assertEquals(userPrefs, profileManager.getUserPrefs());
// Modifying userPrefs should not modify profileManager's userPrefs
UserPrefs oldUserPrefs = new UserPrefs(userPrefs);
userPrefs.setAddressBookFilePath(Paths.get("new/address/book/file/path"));
assertEquals(oldUserPrefs, profileManager.getUserPrefs());
}
@Test
public void setGuiSettings_nullGuiSettings_throwsNullPointerException() {
assertThrows(NullPointerException.class, () -> profileManager.setGuiSettings(null));
}
@Test
public void setGuiSettings_validGuiSettings_setsGuiSettings() {
GuiSettings guiSettings = new GuiSettings(1, 2, 3, 4);
profileManager.setGuiSettings(guiSettings);
assertEquals(guiSettings, profileManager.getGuiSettings());
}
@Test
public void setProfileListFilePath_nullPath_throwsNullPointerException() {
assertThrows(NullPointerException.class, () -> profileManager.setProfileListFilePath(null));
}
@Test
public void setProfileListFilePath_validPath_setsAddressBookFilePath() {
Path path = Paths.get("address/book/file/path");
profileManager.setProfileListFilePath(path);
assertEquals(path, profileManager.getProfileListFilePath());
}
@Test
public void hasProfile_nullPerson_throwsNullPointerException() {
assertThrows(NullPointerException.class, () -> profileManager.hasProfile(null));
}
@Test
public void hasProfile_profileNotInProfileList_returnsFalse() {
assertFalse(profileManager.hasProfil
```
<Overlap Ratio: 0.9793861658268438>

---

--- 325 --
Question ID: e0d154d32d5187a23317189a6d69f59aad0505f0
Original Code:
```
public class CloneableObject {

    /*
     * This class will not use Clonable interface, as no longer recommended by Joshua Bloch
     */

    private List<Integer> list = new ArrayList<>();

    // Use this constructor to create first instance
    public CloneableObject() {
        Random random = new Random();
        list.add(random.nextInt(100));
        list.add(random.nextInt(100));
    }

    // Use this copy constructor to clone the prototype instance
    public CloneableObject(CloneableObject prototype) {
        list = new ArrayList<>(prototype.list);
    }

    public List<Integer> getValues() {
        return new ArrayList<>(list);
    }

    public void updateValues(int a, int b) {
        list.clear();
        list.add(a);
        list.add(b);
    }
}
```


Overlapping Code:
```
Object {
/*
* This class will not use Clonable intate List<Integer> list = new ArrayList<>();
// Use this constructor to create first instance
public CloneableObject() {
Random random = new Random();
list.add(random.nextInt(100));
list.add(random.nextInt(100));
}
// Use this copy constructor to clone the prototype instance
public CloneableObject(CloneableObject prototype) {
list = new ArrayList<>(prototype.list);
}
public List<Integer> getValues() {
return new ArrayList<>(list);
}
public void updateValues(int a, int b) {
list.clear();
list.add(
```
<Overlap Ratio: 0.8487654320987654>

---

--- 326 --
Question ID: aaba759feb1e3e6b78ec00820e3f798d2834bee1
Original Code:
```
public class BuildBase64 extends DataProcessorBase<xBase64> {
    @Override
    public Variable build(xBase64 item, IDataProcessorBuilder builder) {
        Variable input = queryVariableOrConstant(item.input, TheStream.getType());
        Variable output = createUserVariable(xString.inst.getType(), item.name);
        builder.base64(output, input);
        return output;
    }

    @Override
    public VariableType returnType(xBase64 item) {
        return xString.inst.getType();
    }

    @Override
    public String resultVariableName(xBase64 item) {
        return item.name;
    }
}
```


Overlapping Code:
```
 BuildBase64 extends DataProcessorBase<xBase64> {
@Override
public Variable build(xBase64 item, IDataProcessorBuilder builder) {
Variable input = queryVariableOrConstant(item.input, TheStream.getType());
Variable output = createUserVariable(xString.inst.getType(), item.name);
builder.base64(output, input);
return output;
}
@Override
public VariableType returnType(xBase64 item) {
return xString.inst.getType();
}
@Override
public String resultVariableName
```
<Overlap Ratio: 0.9013806706114399>

---

--- 327 --
Question ID: 13b7843b755ed20bcd5f9cb5b0e3c17b369ace0d
Original Code:
```
public class NetworkAnalyser {
	
	private static final Logger logger = LoggerFactory.getLogger(NetworkAnalyser.class);
	
	private static final String DUPLICATE_HOSTNAME_CODE = "Multiverse.Verify.DuplicateHostname";
	private static final String DUPLICATE_MAC_CODE = "Multiverse.Verify.DuplicateMacAddress";
	private static final String DUPLICATE_IP_CODE = "Multiverse.Verify.DuplicateIpAddress";
	private static final String DUPLICATE_VLAN_CODE = "Multiverse.Verify.DuplicateVlan";
	private static final String BAG_BGP_PEER_CODE = "Multiverse.Verify.MisconfiguredBgpPeer";
	
	private final Neo4jWrapper neo4j;

	public NetworkAnalyser(Neo4jWrapper neo4j) {
		this.neo4j = neo4j;
	}
	
	public void verifyNetwork(String networkId, Handler<AsyncResult<VerificationReport>> resultHandler) {
		Promise<ReportMessage> pDupHost = Promise.promise();
		Promise<ReportMessage> pDupMac = Promise.promise();
		Promise<ReportMessage> pDupIp = Promise.promise();
		Promise<ReportMessage> pDupVlan = Promise.promise();
		Promise<ReportMessage> pBadBgp = Promise.promise();
		
		verifyDupHostname(networkId, pDupHost);
		verifyDupMacAddress(networkId, pDupMac);
		verifyDupIpAddress(networkId, pDupIp);
		verifyDupVlan(networkId, pDupVlan);
		verifyBadBgp(networkId, pBadBgp);
		
		CompositeFuture.all(pDupHost.future(), pDupMac.future(), pDupIp.future(), pDupVlan.future(), pBadBgp.future())
				.onComplete(done -> {
			if (done.succeeded()) {
				VerificationReport report = new VerificationReport();
				report.setTimestamp(OffsetDateTime.now().toLocalDateTime().toString());
				report.setNetId(networkId);
				
				List<ReportMessage> reportMsgs = new ArrayList<ReportMessage>();
				reportMsgs.add(pDupHost.future().result());
				reportMsgs.add(pDupMac.future().result());
				reportMsgs.add(pDupIp.future().result());
				reportMsgs.add(pDupVlan.future().result());
				reportMsgs.add(pBadBgp.future().result());
				
				report.setReports(reportMsgs);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture("Failed to verify network. " + done.cause().getMessage()));
			}
		});
	}

	public void verifyDupHostname(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
		neo4j.find(networkId, CypherQuery.Verify.DUPLICATE_HOSTNAME, result -> {
			if (result.succeeded()) {
				ReportMessage report = new ReportMessage();
				report.setCode(DUPLICATE_HOSTNAME_CODE);
				List<String> messages = new ArrayList<String>();
				for(JsonObject row: result.result()) {
					// Hostname, count
					String msg = "Hostname <" + row.getString("hostname") + "> is used on " 
							+ row.getInteger("count") + " devices"; 
					messages.add(msg);
				}
				report.setMessages(messages);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture(result.cause()));
			}
		});
	}

	public void verifyDupMacAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
		neo4j.find(networkId, CypherQuery.Verify.DUPLICATE_MAC, result -> {
			if (result.succeeded()) {
				ReportMessage report = new ReportMessage();
				report.setCode(DUPLICATE_MAC_CODE);
				List<String> messages = new ArrayList<String>();
				for(JsonObject row: result.result()) {
					// deviceName, itfName, dupMacAddr
					String msg = "Duplicate MACADDR <" + row.getString("dupMacAddr") + "> on device "
							+ "<" + row.getString("deviceName") + "> " 
							+ "interface <" + row.getString("itfName") + ">"; 
					messages.add(msg);
				}
				report.setMessages(messages);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture(result.cause()));
			}
		});
	}
	
	public void verifyDupIpAddress(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
		neo4j.find(networkId, CypherQuery.Verify.DUPLICATE_IP, result -> {
			if (result.succeeded()) {
				ReportMessage report = new ReportMessage();
				report.setCode(DUPLICATE_IP_CODE);
				List<String> messages = new ArrayList<String>();
				for(JsonObject row: result.result()) {
					// deviceName, itfName, dupIpAddr
					String msg = "Duplicate IPADDR <" + row.getString("dupIpAddr") + "> on device "
							+ "<" + row.getString("deviceName") + "> " 
							+ "interface <" + row.getString("itfName") + ">"; 
					messages.add(msg);
				}
				report.setMessages(messages);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture(result.cause()));
			}
		});
	}
	
	public void verifyDupVlan(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
		neo4j.find(networkId, CypherQuery.Verify.DUPLICATE_VLAN, result -> {
			if (result.succeeded()) {
				ReportMessage report = new ReportMessage();
				report.setCode(DUPLICATE_VLAN_CODE);
				List<String> messages = new ArrayList<String>();
				for(JsonObject row: result.result()) {
					// deviceName1, itfName1, netAddr1,
					// deviceName2, itfName2, netAddr2, vlan
					String msg = "VLAN <" + row.getString("vlan") + "> is associated with "
							+ "subnet <" + row.getString("netAddr1") + "> on device <" + row.getString("deviceName1") + "> "
							+ "interface <" + row.getString("itfName1") + "> "
							+ "and "
							+ "subnet <" + row.getString("netAddr2") + "> on device <" + row.getString("deviceName2") + "> "
							+ "interface <" + row.getString("itfName2") + "> ";
					messages.add(msg);
				}
				report.setMessages(messages);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture(result.cause()));
			}
		});
	}
	
	public void verifyBadBgp(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
		neo4j.find(networkId, CypherQuery.Verify.BAD_BGP_PEER, result -> {
			if (result.succeeded()) {
				ReportMessage report = new ReportMessage();
				report.setCode(BAG_BGP_PEER_CODE);
				List<String> messages = new ArrayList<String>();
				for(JsonObject row: result.result()) {
					// deviceName1, ipAddr1, lAsn1, rAsn1, rAddr1,
					// deviceName2, ipAddr2, lAsn2, rAsn2, rAddr2
					String msg = "BGP peer between "
							+ "device <" + row.getString("deviceName1") + "> on <" + row.getString("ipAddr1") + "> "
							+ String.format("(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)",
									row.getString("lAsn1"), row.getString("rAsn1") , row.getString("rAddr1"))
							+ " and "
							+ "device <" + row.getString("deviceName2") + "> on <" + row.getString("ipAddr2") + "> "
							+ String.format("(LocalAsn=%s, RemoteAsn=%s, remoteAddr=%s)",
									row.getString("lAsn2"), row.getString("rAsn2") , row.getString("rAddr2"))
							+ " does not match";
					messages.add(msg);
				}
				report.setMessages(messages);
				resultHandler.handle(Future.succeededFuture(report));
			} else {
				resultHandler.handle(Future.failedFuture(result.cause()));
			}
		});
	}
}
```


Overlapping Code:
```
er {

private static final Logger logger = LoggerFactory.getLogger(NetworkAnalyser.class);

private static final String DUPLICATE_HOSTNAME_CODE = "Multiverse.Verify.DuplicateHostname";
private static final String DUPLICATE_MAC_CODE = "Multiverse.Verify.DuplicateMacAddress";
private static final String DUPLICATE_IP_CODE = "Multiverse.Verify.DuplicateIpAddress";
private static final String DUPLICATE_VLAN_CODE = "Multiverse.Verify.DuplicateVlan";
private static final String BAG_BGP_PEER_CODE = "Multiverse.Verify.MisconfiguredBgpPeer";

private final Neo4jWrapper neo4j;
public NetworkAnalyser(Neo4jWrapper neo4j) {
this.neo4j = neo4j;
}

public void verifyNetwork(String networkId, Handler<AsyncResult<VerificationReport>> resultHandler) {
Promise<ReportMessage> pDupHost = Promise.promise();
Promise<ReportMessage> pDupMac = Promise.promise();
Promise<ReportMessage> pDupIp = Promise.promise();
Promise<ReportMessage> pDupVlan = Promise.promise();
Promise<ReportMessage> pBadBgp = Promise.promise();

verifyDupHostname(networkId, pDupHost);
verifyDupMacAddress(networkId, pDupMac);
verifyDupIpAddress(networkId, pDupIp);
verifyDupVlan(networkId, pDupVlan);
verifyBadBgp(networkId, pBadBgp);

CompositeFuture.all(pDupHost.future(), pDupMac.future(), pDupIp.future(), pDupVlan.future(), pBadBgp.future())
.onComplete(done -> {
if (done.succeeded()) {
VerificationReport report = new VerificationReport();
report.setTimestamp(OffsetDateTime.now().toLocalDateTime().toString());
report.setNetId(networkId);

List<ReportMessage> reportMsgs = new ArrayList<ReportMessage>();
reportMsgs.add(pDupHost.future().result());
reportMsgs.add(pDupMac.future().result());
reportMsgs.add(pDupIp.future().result());
reportMsgs.add(pDupVlan.future().result());
reportMsgs.add(pBadBgp.future().result());

report.setReports(reportMsgs);
resultHandler.handle(Future.succeededFuture(report));
} else {
resultHandler.handle(Future.failedFuture("Failed to verify network. " + done.cause().getMessage()));
}
});
}
public void verifyDupHostname(String networkId, Handler<AsyncResult<ReportMessage>> resultHandler) {
neo4j.find(networkId, CypherQuery.Verify.DUPLICATE_HOSTNAME, result -> {
if (result.succeeded()) {
ReportMessage report = new ReportMessage();
report.setCode(DUPLICATE_HOSTNAME_CODE);
List<String> messages = new ArrayList<String>();
for(
```
<Overlap Ratio: 0.9872935196950444>

---

--- 328 --
Question ID: a57630901d1035d319d6315ea42f853a65889471
Original Code:
```
public class LoanAccountDto implements DataTransferObject {

    private final Integer accountId;
    private final Integer customerId;
    private final String prdOfferingShortName;
    private final Short prdOfferingId;
    private final Short accountState;
    private final Short interestDeductedAtDisbursement;
    private final Money loanAmount;
    private Double amountPaidAtDisbursement;

    private final List<CollectionSheetEntryInstallmentDto> accountTrxnDetails = new ArrayList<CollectionSheetEntryInstallmentDto>();

    public LoanAccountDto(Integer accountId, Integer customerId, String prdOfferingShortName,
            Short prdOfferingId, Short loanAccountState, Short interestDeductedAtDisbursement, Money loanAmount) {
        if (loanAmount == null) {
            throw new MifosRuntimeException("Null loanAmount is not allowed for LoanAccountDto");
        }
        this.accountId = accountId;
        this.customerId = customerId;
        this.prdOfferingShortName = prdOfferingShortName;
        this.prdOfferingId = prdOfferingId;
        this.accountState = loanAccountState;
        this.interestDeductedAtDisbursement = interestDeductedAtDisbursement;
        this.loanAmount = loanAmount;
    }

    public Integer getAccountId() {
        return accountId;
    }

    public Integer getCustomerId() {
        return this.customerId;
    }

    public String getPrdOfferingShortName() {
        return prdOfferingShortName;
    }

    public Short getPrdOfferingId() {
        return prdOfferingId;
    }

    public Short getAccountSate() {
        return accountState;
    }

    public List<CollectionSheetEntryInstallmentDto> getAccountTrxnDetails() {
        return accountTrxnDetails;
    }

    public void addTrxnDetails(List<CollectionSheetEntryInstallmentDto> accountTrxnDetails) {
        if (null != accountTrxnDetails && accountTrxnDetails.size() > 0) {
            this.accountTrxnDetails.addAll(accountTrxnDetails);
        }
    }

    public Double getTotalAmountDue() {
        Money totalAmount = new Money(loanAmount.getCurrency());
        if (isDisbursalAccount()) {
            return amountPaidAtDisbursement;
        }

        if (accountTrxnDetails != null && accountTrxnDetails.size() > 0) {
            for (CollectionSheetEntryInstallmentDto accountAction : accountTrxnDetails) {
                totalAmount = totalAmount.add(((CollectionSheetEntryLoanInstallmentDto) accountAction)
                        .getTotalDueWithFees());
            }
        }
        return totalAmount.getAmountDoubleValue();
    }

    public boolean isInterestDeductedAtDisbursement() {
        return this.interestDeductedAtDisbursement > 0 ? true : false;
    }

    public Double getAmountPaidAtDisbursement() {
        return amountPaidAtDisbursement;
    }

    public void setAmountPaidAtDisbursement(Double amountPaidAtDisbursement) {
        this.amountPaidAtDisbursement = amountPaidAtDisbursement;
    }

    public Double getTotalDisburseAmount() {
        return isDisbursalAccount() ? this.loanAmount.getAmountDoubleValue() : 0.0;
    }

    public boolean isDisbursalAccount() {
        return getAccountSate().equals(AccountState.LOAN_APPROVED.getValue())
                || getAccountSate().equals(AccountState.LOAN_DISBURSED_TO_LOAN_OFFICER.getValue());
    }
}
```


Overlapping Code:
```
ntDto implements DataTransferObject {
private final Integer accountId;
private final Integer customerId;
private final String prdOfferingShortName;
private final Short prdOfferingId;
private final Short accountState;
private final Short interestDeductedAtDisbursement;
private final Money loanAmount;
private Double amountPaidAtDisbursement;
private final List<CollectionSheetEntryInstallmentDto> accountTrxnDetails = new ArrayList<CollectionSheetEntryInstallmentDto>();
public LoanAccountDto(Integer accountId, Integer customerId, String prdOfferingShortName,
Short prdOfferingId, Short loanAccountState, Short interestDeductedAtDisbursement, Money loanAmount) {
if (loanAmount == null) {
throw new MifosRuntimeException("Null loanAmount is not allowed for LoanAccountDto");
}
this.accountId = accountId;
this.customerId = customerId;
this.prdOfferingShortName = prdOfferingShortName;
this.prdOfferingId = prdOfferingId;
this.accountState = loanAccountState;
this.interestDeductedAtDisbursement = interestDeductedAtDisbursement;
this.loanAmount = loanAmount;
}
public Integer getAccountId() {
return accountId;
}
public Integer getCustomerId() {
return this.customerId;
}
public String getPrdOfferingShortName() {
return prdOfferingShortName;
}
public Short getPrdOfferingId() {
return prdOfferingId;
}
public Short getAccountSate() {
return accountState;
}
public List<CollectionSheetEntryInstallmentDto> getAccountTrxnDetails() {
return accountTrxnDetails;
}
public void addTrxnDetails(List<CollectionSheetEntryInstallmentDto> accountTrxnDetails) {
if (null != accountTrxnDetails && accountTrxnDetails.size() > 0) {
this.accountTrxnDetails.addAll(accountTrxnDetails);
}
}
public Double getTotalAmountDue() {
Money totalAmount = new Money(loanAmount.getCurrency());
if (isDisbursalAccount()) {
return amountPaidAtDisbursement;
}
if (accountTrxnDetails != null && accountTrxnDetails.size() > 0) {
for (CollectionSheetEntryInstallmentDto accountAction : accountTrxnDetails) {
totalAmount = totalAmount.add(((CollectionSheetEntryLoanInstallmentDto) accountAction
```
<Overlap Ratio: 0.9772403982930299>

---

--- 329 --
Question ID: 2c8608a214bd27f28a7f0883fd11afd93a0a8a5d
Original Code:
```
public class OrderValidator implements Validator {

    private final Validator addressValidator;

    public OrderValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException(
                    "The supplied [Validator] is required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException(
                    "The supplied [Validator] must support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    @Override
    public boolean supports(Class<?> clazz) {
        return Order.class.isAssignableFrom(clazz);
    }

    @Override
    public void validate(Object obj, Errors errors) {
        validateCreditCard((Order) obj, errors);
        validateBillingAddress((Order) obj, errors);
        validateShippingAddress((Order) obj, errors);
    }

    public void validateCreditCard(Order order, Errors errors) {
        ValidationUtils.rejectIfEmpty(errors, "cardNumber", "required", new String[]{"FAKE (!) credit card number"});
        ValidationUtils.rejectIfEmpty(errors, "expireDate", "required", new String[]{"Expiry date"});
        ValidationUtils.rejectIfEmpty(errors, "cardType", "required", new String[]{"Card type"});
    }

    public void validateBillingAddress(Order order, Errors errors) {
        ValidationUtils.rejectIfEmpty(errors, "billToFirstname", "required", new String[]{"Billing Info: first name"});
        ValidationUtils.rejectIfEmpty(errors, "billToLastname", "required", new String[]{"Billing Info: last name"});

        errors.setNestedPath("order.billAddress");
        ValidationUtils.invokeValidator(this.addressValidator, order.getBillAddress(), errors);
    }

    public void validateShippingAddress(Order order, Errors errors) {
        ValidationUtils.rejectIfEmpty(errors, "shipToFirstname", "required", new String[]{"Shipping Info: first name"});
        ValidationUtils.rejectIfEmpty(errors, "shipToLastname", "required", new String[]{"Shipping Info: last name"});

        errors.setNestedPath("order.shipAddress");

        ValidationUtils.invokeValidator(this.addressValidator, order.getShipAddress(), errors);
    }
}
```


Overlapping Code:
```
ublic class OrderValidator implements Validator {
private final Validator addressValidator;
public OrderValidator(Validator addressValidator) {
if (addressValidator == null) {
throw new IllegalArgumentException(
"The supplied [Validator] is required and must not be null.");
}
if (!addressValidator.supports(Address.class)) {
throw new IllegalArgumentException(
"The supplied [Validator] must support the validation of [Address] instances.");
}
this.addressValidator = addressValidator;
}
@Override
public boolean supports(Class<?> clazz) {
return Order.class.isAssignableFrom(clazz);
}
@Override
public void validate(Object obj, Errors errors) {
validateCreditCard((Order) obj, errors);
validateBillingAddress((Order) obj, errors);
validateShippingAddress((Order) obj, errors);
}
public void validateCreditCard(Order order, Errors errors) {
ValidationUtils.rejectIfEmpty(errors, "cardNumber", "required", new String[]{"FAKE (!) credit card number"});
ValidationUtils.rejectIfEmpty(errors, "expireDate", "required", new String[]{"Expiry date"});
ValidationUtils.rejectIfEmpty(errors, "cardType", "required", new String[]{"Card type"});
}
public void validateBillingAddress(Order order, Errors errors) {
ValidationUtils.rejectIfEmpty(errors, "billToFirstname", "required", new String[]{"Billing Info: first name"});
ValidationUtils.rejectIfEmpty(errors, "billToLastname", "required", new String[]{"Billing Info: last name"});
errors.setNestedPath("order.billAddress");
ValidationUtils.invokeValidator(this.addressValidator, order.getBillAddress(), errors);
}
public void validateShippingAddress(Order order, Errors errors) {
ValidationUtils.rejectIfEmpty(errors, "shipToFirstname", "required", new String[]{"Shipping Info: first name"});
ValidationUtils.rejectIfEmpty(errors, "shipToLastname", "required", new String[]{"Shipping Info: last name"});
errors.setNestedPath("order.shipAddress");
ValidationUtils.invokeValidator(this.addressValidator, 
```
<Overlap Ratio: 0.9813414019162885>

---

--- 330 --
Question ID: 72d02099b1ed4d923ae366aa98b9754bf766cd2c
Original Code:
```
public class NavigatorAction extends CommonFormFields {

    private static Logger log = LoggerFactory.getLogger(TransformAction.class);

    /** The xml mapping file that conforms to navigator.xsd */
    private String navigator_xml_file_name;

    /** An reference xml that conforms to navigator.xsd */
    private String xml_ref;


    /** Where we store the result of the navigator processing. If not
     * set we display instead */
    private String key;

    String path;


    public String execute(IExecContext execContext) throws Exception {

        validate(execContext);
        
		setTheme(execContext.getThemes().getTheme(getTheme_name(execContext)));

		Navigator navigator = new Navigator();
		String navXml= null;
        if (StringUtils.isNotEmpty(getXml_ref())) {
        	navXml = navigator.buildHtml(execContext, getTheme(execContext), execContext.getString(getXml_ref()));
        } else {
            File file = new File(path, execContext.replace(getNavigator_xml_file_name()));
            if (!file.exists() || file.isDirectory()) {
                throw new IllegalArgumentException("Missing or invalid file name [" + file.getAbsolutePath()
                        + "] for navigator_xml_file_name attribute [" + getNavigator_xml_file_name() + "]");
            }
            String fileXml = ResourceUtils.loadXMLFileWithISO(file.getAbsolutePath());
        	navXml = navigator.buildHtml(execContext, getTheme(execContext), fileXml);
        }
        if (StringUtils.isNotEmpty(getKey())) {
        	execContext.put(key, navXml);
            return "";
        } else {
        	return navXml;
        }
    }

    public void validate(IExecContext execContext) {
        if (StringUtils.isEmpty(getNavigator_xml_file_name()) && StringUtils.isEmpty(getXml_ref())) {
            throw new IllegalArgumentException("Missing navigator_xml_file_name and xml_ref attribute in tranform.  At least one of these attributes must be set.");
        }
        if (StringUtils.isNotEmpty(getNavigator_xml_file_name()) && StringUtils.isNotEmpty(getXml_ref())) {
            throw new IllegalArgumentException("Both the navigator_xml_file_name and xml_ref attribute are set. Only one of these attributes must be set, not both");
        }
        if (path == null) {
            path = (String) execContext.get(ActionConst.WEB_REAL_PATH_BEAN_REF);
        }
        if (StringUtils.isEmpty(getId())){
            throw new IllegalArgumentException("Missing id attribute in navigator");
        }
    }

    public void setKey(String key) {
        this.key = key;
    }

    public String getKey() {
        return key;
    }

	public void setNavigator_xml_file_name(String navigator_xml_file_name) {
		this.navigator_xml_file_name = navigator_xml_file_name;
	}

	public String getNavigator_xml_file_name() {
		return navigator_xml_file_name;
	}

	public void setXml_ref(String xml_ref) {
		this.xml_ref = xml_ref;
	}

	public String getXml_ref() {
		return xml_ref;
	}

}
```


Overlapping Code:
```
tion extends CommonFormFields {
private static Logger log = LoggerFactory.getLogger(TransformAction.class);
/** The xml mapping file that conforms to navigator.xsd */
private String navigator_xml_file_name;
/** An reference xml that conforms to navigator.xsd */
private String xml_ref;
/** Where we store the result of the navigator processing. If not
* set we display instead */
private String key;
String path;
public String execute(IExecContext execContext) throws Exception {
validate(execContext);

setTheme(execContext.getThemes().getTheme(getTheme_name(execContext)));
Navigator navigator = new Navigator();
String navXml= null;
if (StringUtils.isNotEmpty(getXml_ref())) {
navXml = navigator.buildHtml(execContext, getTheme(execContext), execContext.getString(getXml_ref()));
} else {
File file = new File(path, execContext.replace(getNavigator_xml_file_name()));
if (!file.exists() || file.isDirectory()) {
throw new IllegalArgumentException("Missing or invalid file name [" + file.getAbsolutePath()
+ "] for navigator_xml_file_name attribute [" + getNavigator_xml_file_name() + "]");
}
String fileXml = ResourceUtils.loadXMLFileWithISO(file.getAbsolutePath());
navXml = navigator.buildHtml(execContext, getTheme(execContext), fileXml);
}
if (StringUtils.isNotEmpty(getKey())) {
execContext.put(key, navXml);
return "";
} else {
return navXml;
}
}
public void validate(IExecContext execContext) {
if (StringUtils.isEmpty(getNavigator_xml_file_name()) && StringUtils.isEmpty(getXml_ref())) {
throw new IllegalArgumentException("Missing navigator_xml_file_name and xml_ref attribute in tranform. At least one of these attributes must be set.");
}
if (StringUtils.isNotEmpty(getNavigator_xml_file_name()) && StringUtils.isNotEmpty(getXml_ref())) {
throw new IllegalArgumentException("Both the navigator_xml_file_name and xml_ref attribute are set. Only one of these attributes must be set, not both");
}
if (path == null) {
path = (String) execContext.get(ActionConst.WEB_REAL_PATH_BEAN_REF);
}
if (StringUt
```
<Overlap Ratio: 0.971042471042471>

---

--- 331 --
Question ID: a531e8e5dd6ef60b560a68a191fb4dfe77885d45
Original Code:
```
@Metadata(bv = {1, 0, 3}, d1 = {"\u0000.\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\b\n\u0000\n\u0002\u0010\u000e\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0002\b\u0003\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0002\b\u0002\b\u0000\u0018\u00002\u00020\u0001B\u0017\b\u0000\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0005¢\u0006\u0002\u0010\u0006J\b\u0010\r\u001a\u00020\u000eH\u0016J\b\u0010\u000f\u001a\u00020\u0005H\u0016R\u0014\u0010\u0007\u001a\u00020\bX\u0004¢\u0006\b\n\u0000\u001a\u0004\b\t\u0010\nR\u000e\u0010\u0002\u001a\u00020\u0003X\u0004¢\u0006\u0002\n\u0000R\u000e\u0010\u0004\u001a\u00020\u0005X\u0004¢\u0006\u0002\n\u0000R\u000e\u0010\u000b\u001a\u00020\fX\u0004¢\u0006\u0002\n\u0000¨\u0006\u0010"}, d2 = {"Lkotlinx/coroutines/ThreadPoolDispatcher;", "Lkotlinx/coroutines/ExecutorCoroutineDispatcherBase;", "nThreads", "", "name", "", "(ILjava/lang/String;)V", "executor", "Ljava/util/concurrent/Executor;", "getExecutor", "()Ljava/util/concurrent/Executor;", "threadNo", "Ljava/util/concurrent/atomic/AtomicInteger;", "close", "", "toString", "kotlinx-coroutines-core"}, k = 1, mv = {1, 1, 16})
/* compiled from: ThreadPoolDispatcher.kt */
public final class ThreadPoolDispatcher extends ExecutorCoroutineDispatcherBase {
    private final Executor executor = Executors.newScheduledThreadPool(this.nThreads, new ThreadPoolDispatcher$executor$1(this));
    /* access modifiers changed from: private */
    public final int nThreads;
    /* access modifiers changed from: private */
    public final String name;
    /* access modifiers changed from: private */
    public final AtomicInteger threadNo = new AtomicInteger();

    public ThreadPoolDispatcher(int i, String str) {
        this.nThreads = i;
        this.name = str;
        initFutureCancellation$kotlinx_coroutines_core();
    }

    public Executor getExecutor() {
        return this.executor;
    }

    public void close() {
        Executor executor2 = getExecutor();
        if (executor2 != null) {
            ((ExecutorService) executor2).shutdown();
            return;
        }
        throw new TypeCastException("null cannot be cast to non-null type java.util.concurrent.ExecutorService");
    }

    public String toString() {
        return "ThreadPoolDispatcher[" + this.nThreads + ", " + this.name + ']';
    }
}
```


Overlapping Code:
```
data(bv = {1, 0, 3}, d1 = {"\u0000.\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\b\n\u0000\n\u0002\u0010\u000e\n\u0002\b\u0002\n\u0002\u0018\u0002\n\u0002\b\u0003\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0002\b\u0002\b\u0000\u0018\u00002\u00020\u0001B\u00\u0000\u0012\u0006\u0010\u0002\u001a\u00020\u0003\u0012\u0006\u0010\u0004\u001a\u00020\u0005¢\u0006\u0002\u0010\u0006b\u0010\r\u001a\u00020\u000eH\u0016J\b\u0010\u000f\u001a\u00u0002\u001a\u00020\u0003X\u0004¢\u0006\u0002\n\u0000R\u000e\u0010\u0004\u001a\u00020\u0005X\u0004¢\u0006\u0002ispatcher;", "Lkotlinx/coroutines/ExecutorCoroutinecutor;", "getExecutor", "()Ljava/util/concurrent/toString", "kotlinx-coroutines-core"}, k = 1, mv = {1, 1, 16})
/* compiled from: ThreadPoolDispatcher.kt */
pubs ThreadPoolDispatcher extends ExecutorCoroutineDi {
private final Executor executor = Executors.newScheduledThreadPool(this.nThreads, new This));
/* access modifiers changed from: private */
public final int nThreads;
/* access modifiers changed from: private */
public final String name;
/* access modifiers changed from: private */
public final AtomicInteger threadNo = new AtomicIntegerlinx_coroutines_core();
}
public Executor getExecutor() {
return this.executor;
}
public void close() {
Executor executor2 = getExecutor();
if (executor2 != null) {
((ExecutorService) executor2).shutdown();
return;
}
throw new TypeCastException("null cannot be cast to non-null type java.util.concurrent.ExecutorServic
```
<Overlap Ratio: 0.6717763751127142>

---

--- 332 --
Question ID: 0d7f32d5fa6219f6444093373031e5a2ac2d402d
Original Code:
```
public class BeanParamAnnotationProcessor implements ParameterAnnotationProcessor {
  public static final Set<Class<?>> SUPPORTED_PARAM_ANNOTATIONS = new HashSet<>();

  public static final String SETTER_METHOD_PREFIX = "set";

  static {
    SUPPORTED_PARAM_ANNOTATIONS.add(PathParam.class);
    SUPPORTED_PARAM_ANNOTATIONS.add(QueryParam.class);
    SUPPORTED_PARAM_ANNOTATIONS.add(HeaderParam.class);
    SUPPORTED_PARAM_ANNOTATIONS.add(CookieParam.class);
    SUPPORTED_PARAM_ANNOTATIONS.add(FormParam.class);
  }

  @Override
  public void process(Object annotation, OperationGenerator operationGenerator, int paramIdx) {
    final Class<?> beanParamClazz = operationGenerator.getProviderMethod().getParameterTypes()[paramIdx];
    Map<String, Parameter> swaggerParamMap = new HashMap<>();
    try {
      // traversal fields, get those JAX-RS params
      traversalParamField(operationGenerator, beanParamClazz, swaggerParamMap);
    } catch (IllegalArgumentException | IntrospectionException e) {
      throw new Error(String.format(
          "Processing param failed, method=%s:%s, beanParamIdx=%d",
          operationGenerator.getProviderMethod().getDeclaringClass().getName(),
          operationGenerator.getProviderMethod().getName(),
          paramIdx)
          , e);
    }

    // set swagger params into operationGenerator, in declared field order
    Field[] declaredProducerFields = beanParamClazz.getDeclaredFields();
    Arrays.stream(declaredProducerFields)
        .map(declaredProducerField -> swaggerParamMap.get(declaredProducerField.getName()))
        .filter(Objects::nonNull)
        .forEach(operationGenerator::addProviderParameter);
  }

  /**
   * Traversal fields of {@code beanParamClazz},
   * generate swagger params according to JAX-RS param annotations and set them into {@code swaggerParamMap}.
   *
   * @param swaggerParamMap the map contains the generated swagger param,
   * key is the name defined by source code(the declared field name) and value is the swagger param
   */
  private void traversalParamField(OperationGenerator operationGenerator, Class<?> beanParamClazz,
      Map<String, Parameter> swaggerParamMap) throws IntrospectionException {
    for (Field beanParamField : beanParamClazz.getDeclaredFields()) {
      // ignore synthetic member to avoid build failure
      // see https://github.com/jacoco/jacoco/issues/168
      if (fieldShouldIgnore(beanParamField) || beanParamField.isSynthetic()) {
        continue;
      }
      // try to process this field directly
      Parameter swaggerParam = generateSwaggerParam(operationGenerator, beanParamField.getAnnotations(),
          beanParamField.getGenericType());
      if (null == swaggerParam) {
        // if swaggerParam is null, maybe the JAX-RS param annotation is tagged onto the write method
        swaggerParam = processFieldSetter(operationGenerator, beanParamClazz, beanParamField);
      }

      if (null == swaggerParam) {
        throw new IllegalArgumentException(String.format(
            "There is a field[%s] cannot be mapped to swagger param. Maybe you should tag @JsonIgnore on it.",
            beanParamField.getName())
        );
      }
      swaggerParamMap.put(beanParamField.getName(), swaggerParam);
    }
  }

  /**
   * Sometimes user may tag JAX-RS param annotations on setter method instead of fields.
   *
   * @param beanParamClazz class of the BeanParam
   * @param beanParamField the field of BeanParam whose setter method is processed
   * @return the generated swagger param, or null if the setter method is not tagged by JAX-RS param annotations
   * @throws IntrospectionException see {@linkplain PropertyDescriptor#PropertyDescriptor(String, Class)}
   */
  private Parameter processFieldSetter(OperationGenerator operationGenerator, Class<?> beanParamClazz,
      Field beanParamField) throws IntrospectionException {
    Parameter swaggerParam = null;
    PropertyDescriptor propertyDescriptor = new PropertyDescriptor(beanParamField.getName(), beanParamClazz);
    Method writeMethod = propertyDescriptor.getWriteMethod();
    if (null != writeMethod) {
      swaggerParam = generateSwaggerParam(operationGenerator, writeMethod.getAnnotations(),
          beanParamField.getGenericType());
    }
    return swaggerParam;
  }

  /**
   * Generate a swagger parameter according to {@code annotations} and {@code genericType}.
   *
   * @param operationGenerator operationGenerator
   * @param annotations annotations on fields or setter methods
   * @param genericType type of the fields, or the param type of the setter methods
   * @return a swagger param, or null if there is no JAX-RS annotation in {@code annotations}
   */
  private Parameter generateSwaggerParam(
      OperationGenerator operationGenerator,
      Annotation[] annotations,
      Type genericType) {
    String defaultValue = null;
    for (Annotation fieldAnnotation : annotations) {
      if (!SUPPORTED_PARAM_ANNOTATIONS.contains(fieldAnnotation.annotationType())) {
        if (fieldAnnotation instanceof DefaultValue) {
          defaultValue = ((DefaultValue) fieldAnnotation).value();
        }
        continue;
      }

      return setUpParameter(operationGenerator, fieldAnnotation, genericType, defaultValue);
    }
    return null;
  }

  /**
   * Generate swagger parameter, set default value, and return it.
   *
   * @param operationGenerator operationGenerator
   * @param fieldAnnotation JAX-RS param annotation
   * @param genericParamType type of the parameter
   * @param defaultValue default value, can be null
   * @return the generated swagger Parameter
   */
  private Parameter setUpParameter(
      OperationGenerator operationGenerator,
      Annotation fieldAnnotation,
      Type genericParamType,
      String defaultValue) {
    AbstractSerializableParameter<?> parameter = createParameter(
        operationGenerator.getContext(),
        fieldAnnotation,
        genericParamType);

    if (null != defaultValue) {
      parameter.setDefaultValue(defaultValue);
    }
    return parameter;
  }

  /**
   * Generate a swagger parameter, set up name and type info.
   *
   * @param swaggerGeneratorContext context data carried by {@linkplain OperationGenerator}
   * @param fieldAnnotation JAX-RS param annotation
   * @param genericParamType default value, can be null
   * @return the generated swagger parameter
   */
  private AbstractSerializableParameter<?> createParameter(
      SwaggerGeneratorContext swaggerGeneratorContext,
      Annotation fieldAnnotation,
      Type genericParamType) {
    // find the corresponding ParameterProcessor and process the parameter
    final AbstractParameterProcessor<?> parameterAnnotationProcessor =
        (AbstractParameterProcessor<?>) swaggerGeneratorContext
            .findParameterAnnotationProcessor(fieldAnnotation.annotationType());
    AbstractSerializableParameter<?> parameter = parameterAnnotationProcessor.createParameter();
    String paramName = parameterAnnotationProcessor.getAnnotationParameterName(fieldAnnotation);
    parameter.setName(paramName);
    ParamUtils.setParameterType(genericParamType, parameter);
    return parameter;
  }

  /**
   * Those fields tagged by @JsonIgnore should be ignored.
   */
  private boolean fieldShouldIgnore(Field beanParamField) {
    for (Annotation annotation : beanParamField.getAnnotations()) {
      if (annotation instanceof JsonIgnore) {
        return true;
      }
    }
    return false;
  }
}
```


Overlapping Code:
```
ic class BeanParamAnnotationProcessor implements ParameterAnnotationProcessor {
public static final Set<Class<?>> SUPPORTED_PARAM_ANNOTATIONS = new HashSet<>();
public static final String SETTER_METHOD_PREFIX = "set";
static {
SUPPORTED_PARAM_ANNOTATIONS.add(PathParam.class);
SUPPORTED_PARAM_ANNOTATIONS.add(QueryParam.class);
SUPPORTED_PARAM_ANNOTATIONS.add(HeaderParam.class);
SUPPORTED_PARAM_ANNOTATIONS.add(CookieParam.class);
SUPPORTED_PARAM_ANNOTATIONS.add(FormParam.class);
}
@Override
public void process(Object annotation, OperationGenerator operationGenerator, int paramIdx) {
final Class<?> beanParamClazz = operationGenerator.getProviderMethod().getParameterTypes()[paramIdx];
Map<String, Parameter> swaggerParamMap = new HashMap<>();
try {
// traversal fields, get those JAX-RS params
traversalParamField(operationGenerator, beanParamClazz, swaggerParamMap);
} catch (IllegalArgumentException | IntrospectionException e) {
throw new Error(String.format(
"Processing param failed, method=%s:%s, beanParamIdx=%d",
operationGenerator.getProviderMethod().getDeclaringClass().getName(),
operationGenerator.getProviderMethod().getName(),
paramIdx)
, e);
}
// set swagger params into operationGenerator, in declared field order
Field[] declaredProducerFields = beanParamClazz.getDeclaredFields();
Arrays.stream(declaredProducerFields)
.map(declaredProducerField -> swaggerParamMap.get(declaredProducerField.getName()))
.filter(Objects::nonNull)
.forEach(operationGenerator::addProviderParameter);
}
/**
* Traversal fields of {@code beanParamClazz},
* generate swagger params according to JAX-RS param annotations and set them into {@code swaggerParamMap}.
*
* @param swaggerParamMap the map contains the generated swagger param,
* key is the name defined by source code(the declared field name) and value is the swagger param
*/
private void traversalParamField(OperationGenerator operationGenerator, Class<?> beanParamClazz,
Map<String, Parameter> swaggerParamMap) throws IntrospectionException {
for (Field beanParamField : beanParamClazz.getDeclaredFields()) {
// ignore synthetic member to avoid build failure
// see https://github.com/jacoco/jacoco/issues/168
if (fieldShouldIgnore(beanParamField) || beanParam
```
<Overlap Ratio: 0.9805825242718447>

---

--- 333 --
Question ID: 7b7554c7f535b0338dfca8b7708befcc36ca7d1c
Original Code:
```
@RunWith(RoboRunner.class)
public class UriUtilsLocalTest extends TestCase {

    @Test
    public void testGenericItemWithinCollectionQuery() {
        final Uri uri = Uri.parse("content://test.com/item/1");
        assertTrue(UriUtils.isNumberedEntryWithinCollection(uri));
        assertEquals("item", UriUtils.getItemDirID(uri));
    }

    @Test
    public void testChangingRootOfQuery() {
        Uri uri = Uri.parse("content://test.com/root/item/1");
        assertTrue(UriUtils.isItem("root", uri));
        assertEquals("item", UriUtils.getItemDirID("root", uri));
        uri = Uri.parse("content://test.com/root/root2/item/1");
        assertTrue(UriUtils.isItem("root/root2", uri));
        assertEquals("item", UriUtils.getItemDirID("root/root2", uri));
    }

    @Test
    public void testGettingRowIds() {
        Uri uri = Uri.parse("content://test.com");
        Map<String, String> result = UriUtils.from(uri).getMappedIds();
        assertTrue(result.size() == 0);

        uri = Uri.parse("content://test.com/parent");
        result = UriUtils.from(uri).getMappedIds();
        assertTrue(result.size() == 0);

        uri = Uri.parse("content://test.com/parent/1");
        result = UriUtils.from(uri).getMappedIds();
        assertEquals(result.size(),1);
        assertTrue(result.containsKey("parent"));
        assertEquals("1", result.get("parent"));

        uri = Uri.parse("content://test.com/parent/1/child");
        result = UriUtils.from(uri).getMappedIds();
        assertTrue(result.size() == 1);
        assertTrue(result.containsKey("parent"));
        assertEquals("1", result.get("parent"));

        uri = Uri.parse("content://test.com/parent/1/child/6");
        result = UriUtils.from(uri).getMappedIds();
        assertTrue(result.size() == 2);
        assertTrue(result.containsKey("parent") && result.containsKey("child"));
        assertEquals("1", result.get("parent"));
        assertEquals("6", result.get("child"));
    }

    @Test
    public void testGettingParentDetails(){
        Uri uri = Uri.parse("content://test.com");
        assertEquals("",UriUtils.getParentColumnName(uri));
        assertEquals("",UriUtils.getParentId(uri));
        assertEquals(false,UriUtils.hasParent(uri));
        uri = Uri.parse("content://test.com/parent/1/child");
        assertEquals("parent",UriUtils.getParentColumnName(uri));
        assertEquals("1",UriUtils.getParentId(uri));
        assertEquals(true,UriUtils.hasParent(uri));
        uri = Uri.parse("content://test.com/parent/1/child/6");
        assertEquals("parent",UriUtils.getParentColumnName(uri));
        assertEquals("1",UriUtils.getParentId(uri));
        assertEquals(true,UriUtils.hasParent(uri));
        uri = Uri.parse("content://test.com/parent/1/child/6/subchild");
        assertEquals("child",UriUtils.getParentColumnName(uri));
        assertEquals("6",UriUtils.getParentId(uri));
        assertEquals(true,UriUtils.hasParent(uri));
        uri = Uri.parse("content://test.com/parent/1/child/6/subchild/3");
        assertEquals("child",UriUtils.getParentColumnName(uri));
        assertEquals("6",UriUtils.getParentId(uri));
        assertEquals(true,UriUtils.hasParent(uri));
    }
}
```


Overlapping Code:
```
lic class UriUtilsLocalTest extends TestCase {
@Test
public void testGenericItemWithinCollectionQuery() {
final Uri uri = Uri.parse("content://test.com/item/1");
assertTrue(UriUtils.isNumberedEntryWithinCollection(uri));
assertEquals("item", UriUtils.getItemDirID(uri));
}
@Test
public void testChangingRootOfQuery() {
Uri uri = Uri.parse("content://test.com/root/item/1");
assertTrue(UriUtils.isItem("root", uri));
assertEquals("item", UriUtils.getItemDirID("root", uri));
uri = Uri.parse("content://test.com/root/root2/item/1");
assertTrue(UriUtils.isItem("root/root2", uri));
assertEquals("item", UriUtils.getItemDirID("root/root2", uri));
}
@Test
public void testGettingRowIds() {
Uri uri = Uri.parse("content://test.com");
Map<String, String> result = UriUtils.from(uri).getMappedIds();
assertTrue(result.size() == 0);
uri = Uri.parse("content://test.com/parent");
result = UriUtils.from(uri).getMappedIds();
assertTrue(result.size() == 0);
uri = Uri.parse("content://test.com/parent/1");
result = UriUtils.from(uri).getMappedIds();
assertEquals(result.size(),1);
assertTrue(result.containsKey("parent"));
assertEquals("1", result.get("parent"));
uri = Uri.parse("content://test.com/parent/1/child");
result = UriUtils.from(uri).getMappedIds();
assertTrue(result.size() == 1);
assertTrue(result.containsKey("parent"));
assertEquals("1", result.get("parent"));
uri = Uri.parse("content://test.com/parent/1/child/6");
result = UriUtils.from(uri).getMappedIds();
assertTrue(result.size() == 2);
assertTrue(result.containsKey("parent") && result.containsKey("child"));
assertEquals("1", result.get("parent"));
assertEquals("6", result.get("child"));
}
@Test
public void testGettingParentDetails(){
Uri uri = Uri.parse("content://test.com");
assertEquals("",UriUtils.getParentColumnName(uri));
assertEquals("",UriUtils.getParentId(uri));
assertEquals(false,UriUtils.hasParent(uri));
uri = Uri.parse("content://test.com/parent/1/child");
assertEquals("parent",UriUtils.getParentColumnName(uri));
assertEquals("1",UriUtils.getParentId(uri));
assertEquals(true,UriUtils.hasParent(uri));
uri = Uri.par
```
<Overlap Ratio: 0.9858956276445698>

---

--- 334 --
Question ID: 4b65791b0251df886f359e813fc44c5bbe5cbe52
Original Code:
```
public class Intersect
{
    private static HashMap<String,ArrayList<String>> rules;
    private static boolean ignoreNTs;
    public static void main(String [] argv) throws Exception
    {
        String file1;
        String file2;
        String outputPrefix;
        if (argv[0].equals("-X")) {
            file1 = argv[1];
            file2 = argv[2];
            outputPrefix = argv[3];
            ignoreNTs = true;
        }
        else {
            file1 = argv[0];
            file2 = argv[1];
            outputPrefix = argv[2];
            ignoreNTs = false;
        }
        getRulesFromFile(file1);

        Scanner scanner;
        if (file2.endsWith(".gz"))
            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(file2))), "UTF-8");
        else
            scanner = new Scanner(new File(file2), "UTF-8");
        PrintStream firstGrammar = new PrintStream(new FileOutputStream(outputPrefix + ".1"));
        PrintStream secondGrammar = new PrintStream(new FileOutputStream(outputPrefix + ".2"));
        while (scanner.hasNextLine()) {
            String s = scanner.nextLine();
            String r = repr(s);
            if (rules.containsKey(r)) {
                secondGrammar.println(s);
                for (String x : rules.get(r))
                    firstGrammar.println(x);
                rules.get(r).clear();
            }
        }
        scanner.close();
        firstGrammar.close();
        secondGrammar.close();
        return;
    }

    private static String repr(String s)
    {
        String r = s.substring(0, s.lastIndexOf("|||"));
        if (ignoreNTs) 
            r = r.replaceAll("\\[[^]]+?\\]", "[X]");
        return r;
    }

    private static void getRulesFromFile(String filename) throws IOException
    {
        rules = new HashMap<String,ArrayList<String>>();
        Scanner scanner;
        if (filename.endsWith(".gz")) {
            scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(filename))), "UTF-8");
        }
        else {
            scanner = new Scanner(new File(filename), "UTF-8");
        }
        while (scanner.hasNextLine()) {
            String s = scanner.nextLine();
            String r = repr(s);
            if (rules.containsKey(r))
                rules.get(r).add(s);
            else {
                ArrayList<String> al = new ArrayList<String>();
                al.add(s);
                rules.put(r, al);
            }
        }
        scanner.close();
        return;
    }
}
```


Overlapping Code:
```
 HashMap<String,ArrayList<String>> rules;
private static boolean ignoreNTs;
public static void main(String [] argv) throws Exception
{
String file1;
String file2;
String outputPrefix;
if (argv[0].equals("-X")) {
file1 = argv[1];
file2 = argv[2];
outputPrefix = argv[3];
ignoreNTs = true;
}
else {
file1 = argv[0];
file2 = argv[1];
outputPrefix = argv[2];
ignoreNTs = false;
}
getRulesFromFile(file1);
Scanner scanner;
if (file2.endsWith(".gz"))
scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(file2))), "UTF-8");
else
scanner = new Scanner(new File(file2), "UTF-8");
PrintStream firstGrammar = new PrintStream(new FileOutputStream(outputPrefix + ".1"));
PrintStream secondGrammar = new PrintStream(new FileOutputStream(outputPrefix + ".2"));
while (scanner.hasNextLine()) {
String s = scanner.nextLine();
String r = repr(s);
if (rules.containsKey(r)) {
secondGrammar.println(s);
for (String x : rules.get(r))
firstGrammar.println(x);
rules.get(r).clear();
}
}
scanner.close();
firstGrammar.close();
secondGrammar.close();
return;
}
private static String repr(String s)
{
String r = s.substring(0, s.lastIndexOf("|||"));
if (ignoreNTs) 
r = r.replaceAll("\\[[^]]+?\\]", "[X]");
return r;
}
private static void getRulesFromFile(String filename) throws IOException
{
rules = new HashMap<String,ArrayList<String>>();
Scanner scanner;
if (filename.endsWith(".gz")) {
scanner = new Scanner(new GZIPInputStream(new FileInputStream(new File(filename))), "UTF-8");
}
else {
scanner = new Scanner(new File(filename), "UTF-8");
}
while (scanner.hasNextLine()) {
String s = scanner.nextLine();
String r = repr(s);
if (rules.containsKey(r))
rules.get(r).add(s);
else {
ArrayList<String> al = new ArrayList<String>();
al.add(s);
rules.put(r,
```
<Overlap Ratio: 0.9657836644591612>

---

--- 335 --
Question ID: 3c70cab69121f364f1772cd3c27494171b225d31
Original Code:
```
public class MethodTest {

	@Test
	public void test() {
		MethodExampleGen gen1 = new MethodExampleGen();
		gen1.setSomeString("foo");
		gen1.setSomeInt(1);

		MethodExampleGen gen2 = new MethodExampleGen();
		gen2.setSomeString("foo");
		gen2.setSomeInt(1);

		MethodExampleGen gen3 = new MethodExampleGen();
		gen3.setSomeString("foo");
		gen3.setSomeInt(2);

		assertEquals(gen1.hashCode(), gen2.hashCode());
		assertEquals(gen1, gen2);

		assertFalse(gen1.hashCode() == gen3.hashCode());
		assertFalse(gen1.equals(gen3));
		assertFalse(gen1.equals(null));
		assertFalse(gen1.equals(new Object()));
		assertFalse(new Object().equals(gen1));
	}

}
```


Overlapping Code:
```

@Test
public void test() {
MethodExampleGen gen1 = new MethodExampleGen();
gen1.setSomeString("foo");
gen1.setSomeInt(1);
MethodExampleGen gen2 = new MethodExampleGen();
gen2.setSomeString("foo");
gen2.setSomeInt(1);
MethodExampleGen gen3 = new MethodExampleGen();
gen3.setSomeString("foo");
gen3.setSomeInt(2);
assertEquals(gen1.hashCode(), gen2.hashCode());
assertEquals(gen1, gen2);
assertFalse(gen1.hashCode() == gen3.hashCode());
assertFalse(gen1.equals(gen3));
assertFalse(gen1.equals(null));
assertFalse(gen1.equals(new Object()));
assertFals
```
<Overlap Ratio: 0.9046052631578947>

---

--- 336 --
Question ID: b483f3bd9f9de9ef18cf4706a05bf986224b5487
Original Code:
```
public class MathFFT {

    public static double log2(double N)
    {

        // calculate log2 N indirectly
        // using log() method

        return (Math.log(N) / Math.log(2));
    }

}
```


Overlapping Code:
```
double N)
{
// calculate log2 N indirectly
// using log() method
return (Math.log(N) / Math.log(2));
```
<Overlap Ratio: 0.6535947712418301>

---

--- 337 --
Question ID: f8ac15263598dc5371a9bbb25442710fdc0a8de8
Original Code:
```
public class QueueServiceTest {
	 private HttpServer server;
	    private WebTarget target;

	    @Before
	    public void setUp() throws Exception {
	        // start the server
	        server = Main.startServer();
	        // create the client
	        Client c = ClientBuilder.newClient();
	        
	        c.register(MoxyJsonFeature.class);
	        c.register(MultiPartFeature.class);

	        target = c.target(Main.BASE_URI);
	    }

	    @After
	    public void tearDown() throws Exception {
	        server.stop();
	    }

	    /**
	     * Test to see that the message "Got it!" is sent in the response.
	     * @throws IOException 
	     */
	    @Test
	    public void testGetIt() throws IOException {
	    	Session sessions = getSessions("exception.txt");
	    	
	    	Session session = new Session();
	    	session.setEnvironment("RIDE");
	    	
	    	session.getProjects().putAll(sessions.getProjects());
	    	session.setFullStackTrace(null);
	    	
	    	Response response = target.path("queue/build/job1").request().post(Entity.entity(session, MediaType.APPLICATION_JSON));
	    	assertTrue(response.readEntity(String.class).contains("build/job1 queued"));
	    }
	    
	    
	@Test
	public void testUploadArchive() throws IOException {
		File zip = new File(getClass().getClassLoader()
				.getResource("upload.zip").getFile());

		final FormDataMultiPart multipart = new FormDataMultiPart();
		FileDataBodyPart filePart = new FileDataBodyPart("udc_archive_"
				+ zip.getName(), zip);
		multipart.bodyPart(filePart);
		

		final Response response = target.path("queue/myApp").request()
				.post(Entity.entity(multipart, multipart.getMediaType()));

		String result=response.readEntity(String.class);
		assertTrue(result.contains("Files: [upload.zip] queued")
				|| result.contains("Files: [] queued"));
	}
	    
	    
	    @SuppressWarnings("resource")
		private Session getSessions(String fileName) throws IOException {
			BufferedReader br;
			br = new BufferedReader(new FileReader(getClass().getClassLoader().getResource(fileName).getFile()));
			
			String sCurrentLine = null;
			StringBuffer sb = new StringBuffer();
			while ((sCurrentLine = br.readLine()) != null) {
				sb.append(sCurrentLine);
				sb.append("\n");
			}
			
			LineProcessor pro = new LineProcessor();
			return pro.process(sb.toString());
		}
}
```


Overlapping Code:
```
rviceTest {
private HttpServer server;
private WebTarget target;
@Before
public void setUp() throws Exception {
// start the server
server = Main.startServer();
// create the client
Client c = ClientBuilder.newClient();

c.register(MoxyJsonFeature.class);
c.register(MultiPartFeature.class);
target = c.target(Main.BASE_URI);
}
@After
public void tearDown() throws Exception {
server.stop();
}
/**
* Test to see that the message "Got it!" is sent in the response.
* @throws IOException 
*/
@Test
public void testGetIt() throws IOException {
Session sessions = getSessions("exception.txt");

Session session = new Session();
session.setEnvironment("RIDE");

session.getProjects().putAll(sessions.getProjects());
session.setFullStackTrace(null);

Response response = target.path("queue/build/job1").request().post(Entity.entity(session, MediaType.APPLICATION_JSON));
assertTrue(response.readEntity(String.class).contains("build/job1 queued"));
}


@Test
public void testUploadArchive() throws IOException {
File zip = new File(getClass().getClassLoader()
.getResource("upload.zip").getFile());
final FormDataMultiPart multipart = new FormDataMultiPart();
FileDataBodyPart filePart = new FileDataBodyPart("udc_archive_"
+ zip.getName(), zip);
multipart.bodyPart(filePart);

final Response response = target.path("queue/myApp").request()
.post(Entity.entity(multipart, multipart.getMediaType()));
String result=response.readEntity(String.class);
assertTrue(result.contains("Files: [upload.zip] queued")
|| result.contains("Files: [] queued"));
}


@SuppressWarnings("resource")
private Session getSessions(String fileName) throws IOException {
BufferedReader br;
br = new BufferedReader(new FileReader(getClass().getClassLoader().getResource(fileName).getFile()));

String sCurrentLine = null;
StringBuffer sb = new StringBuffer();
while ((sCurrentLine = br.readLine()) != null) {
sb.append(sCurrentLine);
sb.append("\n");
}

LineProcessor pro = new LineProcessor();
return pro.process(sb.toString());
}

```
<Overlap Ratio: 0.9896091044037605>

---

--- 338 --
Question ID: 27651879d758f37d00dbead897986e1a3375d6e8
Original Code:
```
class TestExecutionProfilerTopN extends StroomUnitTest {
    @Test
    void test() {
        final List<ExecutionProfiler> list = new ArrayList<>();
        list.add(new SimpleExecutionProfiler(10));
        list.add(new SimpleExecutionProfiler(1));
        list.add(new SimpleExecutionProfiler(5));

        final ExecutionProfilerTopN topN = new ExecutionProfilerTopN(list, 2);

        assertThat(topN.getTopN().get(0).getTotalExecutionCount()).isEqualTo(10);
        assertThat(topN.getTopN().get(1).getTotalExecutionCount()).isEqualTo(5);
        assertThat(topN.getTopN().size()).isEqualTo(2);
    }

    class SimpleExecutionProfiler implements ExecutionProfiler {
        int id;

        public SimpleExecutionProfiler(final int id) {
            this.id = id;
        }

        @Override
        public String getExecutionString() {
            return String.valueOf(id);
        }

        @Override
        public long getTotalExecutionTime() {
            return id;
        }

        @Override
        public long getTotalExecutionCount() {
            return id;
        }

    }
}
```


Overlapping Code:
```
s TestExecutionProfilerTopN extends StroomUnitTest {
@Test
void test() {
final List<ExecutionProfiler> list = new ArrayList<>();
list.add(new SimpleExecutionProfiler(10));
list.add(new SimpleExecutionProfiler(1));
list.add(new SimpleExecutionProfiler(5));
final ExecutionProfilerTopN topN = new ExecutionProfilerTopN(list, 2);
assertThat(topN.getTopN().get(0).getTotalExecutionCount()).isEqualTo(10);
assertThat(topN.getTopN().get(1).getTotalExecutionCount()).isEqualTo(5);
assertThat(topN.getTopN().size()).isEqualTo(2);
}
class SimpleExecutionProfiler implements ExecutionProfiler {
int id;
public SimpleExecutionProfiler(final int id) {
this.id = id;
}
@Override
public String getExecutionString() {
return String.valueOf(id);
}
@Override
public long getTotalExecutionTime() {
return id;
}
@Override
public long getTotalExecutionCount() {
return i
```
<Overlap Ratio: 0.9860788863109049>

---

--- 339 --
Question ID: 2d42323106644458b214a985ce3e6891d04cec19
Original Code:
```
public class PathEval
{
    /** Evaluate a path : SPARQL semantics */
    static public Iterator<Node> eval(Graph graph, Node node, Path path, Context context) {
        return eval$(graph, node, path, new PathEngineSPARQL(graph, true, context)) ;
        // return eval$(graph, node, path, new PathEngineN(graph, true)) ;
    }

    /** Evaluate a path */
    static public Iterator<Node> evalReverse(Graph graph, Node node, Path path, Context context) {
        return eval$(graph, node, path, new PathEngineSPARQL(graph, false, context)) ;
        // return eval$(graph, node, path, new PathEngineN(graph, false)) ;
    }

    /** Evaluate a path : counting semantics */
    static public Iterator<Node> evalN(Graph graph, Node node, Path path) {
        return eval$(graph, node, path, new PathEngineN(graph, true)) ;
    }

    /** Evaluate a path : counting semantics */
    static public Iterator<Node> evalReverseN(Graph graph, Node node, Path path) {
        return eval$(graph, node, path, new PathEngineN(graph, false)) ;
    }

    /** Evaluate a path : unique results */
    static public Iterator<Node> eval1(Graph graph, Node node, Path path) {
        return eval$(graph, node, path, new PathEngine1(graph, true)) ;
    }

    /** Evaluate a path : unique results */
    static public Iterator<Node> evalReverse1(Graph graph, Node node, Path path) {
        return eval$(graph, node, path, new PathEngine1(graph, false)) ;
    }

    /** Evaluate a path */
    static void eval$(Graph graph, Node node, Path path, PathEngine engine, Collection<Node> acc) {
        PathEvaluator evaluator = new PathEvaluator(graph, node, acc, engine) ;
        path.visit(evaluator) ;
    }

    /** Evaluate a path */
    static Iter<Node> eval$(Graph graph, Node node, Path path, PathEngine engine) {
        Collection<Node> acc = new ArrayList<>() ;
        eval$(graph, node, path, engine, acc); 
        return Iter.iter(acc) ;
    }
}
```


Overlapping Code:
```
lic class PathEval
{
/** Evaluate a path : SPARQL semantics */
static public Iterator<Node> eval(Graph graph, Node node, Path path, Context context) {
return eval$(graph, node, path, new PathEngineSPARQL(graph, true, context)) ;
// return eval$(graph, node, path, new PathEngineN(graph, true)) ;
}
/** Evaluate a path */
static public Iterator<Node> evalReverse(Graph graph, Node node, Path path, Context context) {
return eval$(graph, node, path, new PathEngineSPARQL(graph, false, context)) ;
// return eval$(graph, node, path, new PathEngineN(graph, false)) ;
}
/** Evaluate a path : counting semantics */
static public Iterator<Node> evalN(Graph graph, Node node, Path path) {
return eval$(graph, node, path, new PathEngineN(graph, true)) ;
}
/** Evaluate a path : counting semantics */
static public Iterator<Node> evalReverseN(Graph graph, Node node, Path path) {
return eval$(graph, node, path, new PathEngineN(graph, false)) ;
}
/** Evaluate a path : unique results */
static public Iterator<Node> eval1(Graph graph, Node node, Path path) {
return eval$(graph, node, path, new PathEngine1(graph, true)) ;
}
/** Evaluate a path : unique results */
static public Iterator<Node> evalReverse1(Graph graph, Node node, Path path) {
return eval$(graph, node, path, new PathEngine1(graph, false)) ;
}
/** Evaluate a path */
static void eval$(Graph graph, Node node, Path path, PathEngine engine, Collection<Node> acc) {
PathEvaluator evaluator = new PathEvaluator(graph, node, acc, engine) ;
path.visit(evaluator) ;
}
/** Evaluate a path */
static Iter<Node> eval$(Graph graph, Node node, Path path, PathEngine engine) {
Collection<Node> acc = new ArrayList<>() ;
eval$(graph, node, path, engine, acc); 
return Iter.ite
```
<Overlap Ratio: 0.9913494809688581>

---

--- 340 --
Question ID: bbb58af9e881f947b2321472f5d5393ed8eb998e
Original Code:
```
public class InterfaceDemoTest {
    public static void main(String[] args) {
        AnimalLivable animalLivable = new AnimalLivable();
        animalLivable.eat();
        animalLivable.sleep();
    }
}
```


Overlapping Code:
```
moTest {
public static void main(String[] args) {
AnimalLivable animalLivable = new AnimalLivable();
animalLivable.eat();
```
<Overlap Ratio: 0.7034883720930233>

---

--- 341 --
Question ID: 8c2f3f6ae803d3df64262670ce5e71f7e94d1434
Original Code:
```
final class TracingConnectionConsumer implements ConnectionConsumer {
  static ConnectionConsumer create(ConnectionConsumer delegate, JmsTracing jmsTracing) {
    if (delegate == null) throw new NullPointerException("connectionConsumer == null");
    if (delegate instanceof TracingConnectionConsumer) return delegate;
    return new TracingConnectionConsumer(delegate, jmsTracing);
  }

  final ConnectionConsumer delegate;
  final JmsTracing jmsTracing;

  TracingConnectionConsumer(ConnectionConsumer delegate, JmsTracing jmsTracing) {
    this.delegate = delegate;
    this.jmsTracing = jmsTracing;
  }

  @Override public ServerSessionPool getServerSessionPool() throws JMSException {
    return TracingServerSessionPool.create(delegate.getServerSessionPool(), jmsTracing);
  }

  @Override public void close() throws JMSException {
    delegate.close();
  }
}
```


Overlapping Code:
```
l class TracingConnectionConsumer implements ConnectionConsumer {
static ConnectionConsumer create(ConnectionConsumer delegate, JmsTracing jmsTracing) {
if (delegate == null) throw new NullPointerException("connectionConsumer == null");
if (delegate instanceof TracingConnectionConsumer) return delegate;
return new TracingConnectionConsumer(delegate, jmsTracing);
}
final ConnectionConsumer delegate;
final JmsTracing jmsTracing;
TracingConnectionConsumer(ConnectionConsumer delegate, JmsTracing jmsTracing) {
this.delegate = delegate;
this.jmsTracing = jmsTracing;
}
@Override public ServerSessionPool getServerSessionPool() throws JMSException {
return TracingServerSessionPool.create(delegate.getServerSessionPool(), jmsTracing);
}
@Override public void close() throws JMSException {
delegate.clo
```
<Overlap Ratio: 0.984009840098401>

---

--- 342 --
Question ID: 405269e118ad851aff1587464894a803c15db7cf
Original Code:
```
public class Boj15354 {
	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		int count = 0;
		char current = ' ';
		for(int i = 0; i < N; i++) {
			char next = br.readLine().charAt(0);
			
			if(current != next) count++;
			current = next;
		}
		
		System.out.println(count + 1);
	}
}
```


Overlapping Code:
```
s Boj15354 {
public static void main(String[] args) throws Exception{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());

int count = 0;
char current = ' ';
for(int i = 0; i < N; i++) {
char next = br.readLine().charAt(0);

if(current != next) count++;
current = next;
}

System.out.pri
```
<Overlap Ratio: 0.9186351706036745>

---

--- 343 --
Question ID: 1e1c1aa9f3d325dd442e59ed0de11008b5165cc0
Original Code:
```
public class JsonUtilsTest {
    private static final String singleLogConfig = "[{\"log_group_name\":\"test_group\"}]";
    private static final String multiLogConfig = "[{\"log_group_name\":\"test_group1\"}, {\"log_group_name\":\"test_group2\"}, {\"log_group_name\":\"test_group1\"}]";
    private static final String singleLogConfigWithStream = "[{\"log_group_name\":\"test_group\", \"log_stream_name\":\"test_stream\"}]";

    private static final String LOG_GROUP_NAME = "log_group_name";

    private ObjectMapper mapper = new ObjectMapper();

    @Test
    public void testGetLogGroup() throws IOException {
        JsonNode node = mapper.readTree(singleLogConfig);

        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);

        Assert.assertEquals(1, groupList.size());
        Assert.assertEquals("test_group", groupList.get(0));
    }

    @Test
    public void testGetMultipleLogGroups() throws IOException {
        JsonNode node = mapper.readTree(multiLogConfig);

        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);

        Assert.assertEquals(3, groupList.size());
        Assert.assertTrue(groupList.contains("test_group1"));
        Assert.assertTrue(groupList.contains("test_group2"));
    }

    @Test
    public void testGetLogGroupWithStreamPresent() throws IOException {
        JsonNode node = mapper.readTree(singleLogConfigWithStream);

        List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);

        Assert.assertEquals(1, groupList.size());
        Assert.assertEquals("test_group", groupList.get(0));
    }
}
```


Overlapping Code:
```
ublic class JsonUtilsTest {
private static final String singleLogConfig = "[{\"log_group_name\":\"test_group\"}]";
private static final String multiLogConfig = "[{\"log_group_name\":\"test_group1\"}, {\"log_group_name\":\"test_group2\"}, {\"log_group_name\":\"test_group1\"}]";
private static final String singleLogConfigWithStream = "[{\"log_group_name\":\"test_group\", \"log_stream_name\":\"test_stream\"}]";
private static final String LOG_GROUP_NAME = "log_group_name";
private ObjectMapper mapper = new ObjectMapper();
@Test
public void testGetLogGroup() throws IOException {
JsonNode node = mapper.readTree(singleLogConfig);
List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);
Assert.assertEquals(1, groupList.size());
Assert.assertEquals("test_group", groupList.get(0));
}
@Test
public void testGetMultipleLogGroups() throws IOException {
JsonNode node = mapper.readTree(multiLogConfig);
List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);
Assert.assertEquals(3, groupList.size());
Assert.assertTrue(groupList.contains("test_group1"));
Assert.assertTrue(groupList.contains("test_group2"));
}
@Test
public void testGetLogGroupWithStreamPresent() throws IOException {
JsonNode node = mapper.readTree(singleLogConfigWithStream);
List<String> groupList = JsonUtils.getMatchingListFromJsonArrayNode(node, LOG_GROUP_NAME);
Assert.assertEquals(1, groupList.size());
Assert.assertEquals("test_
```
<Overlap Ratio: 0.9793608521970706>

---

--- 344 --
Question ID: 908b6e8625ad9ea0b57ddddb23fec40061b2171d
Original Code:
```
public class GoodsModelAndDtoConversion implements BaseConversion<GoodsModel, GoodsDto> {

    private static class SingletonClassInstance {
        private static final GoodsModelAndDtoConversion conversion = new GoodsModelAndDtoConversion();
    }

    private GoodsModelAndDtoConversion() {
    }

    public static GoodsModelAndDtoConversion getConversion() {
        return SingletonClassInstance.conversion;
    }

    @Override
    public GoodsModel toModel(GoodsDto dto) {
        GoodsModel model = new GoodsModel();
        return model;
    }

    @Override
    public GoodsDto toDto(GoodsModel model) {
        GoodsDto dto = new GoodsDto();
        dto.setId(model.getId());
        dto.setUserId(model.getUserId());
        dto.setGoodsName(model.getGoodsName());
        dto.setGoodsUrl(model.getGoodsUrl());
        dto.setGoodsPrice(model.getGoodsPrice());
        dto.setGoodsTotalQty(model.getGoodsTotalQty());
        dto.setCreationTime(model.getCreationTime());
        dto.setLastUpdateTime(model.getLastUpdateTime());
        dto.setRemark(model.getRemark());
        return dto;
    }
}
```


Overlapping Code:
```
ents BaseConversion<GoodsModel, GoodsDto> {
private static class SingletonClassInstance {
private static final GoodsModelAndDtoConversion conversion = new GoodsModelAndDtoConversion();
}
private GoodsModelAndDtoConversion() {
}
public static GoodsModelAndDtoConversion getConversion() {
return SingletonClassInstance.conversion;
}
@Override
public GoodsModel toModel(GoodsDto dto) {
GoodsModel model = new GoodsModel();
return model;
}
@Override
public GoodsDto toDto(GoodsModel model) {
GoodsDto dto = new GoodsDto();
dto.setId(model.getId());
dto.setUserId(model.getUserId());
dto.setGoodsName(model.getGoodsName());
dto.setGoodsUrl(model.getGoodsUrl());
dto.setGoodsPrice(model.getGoodsPrice());
dto.setGoodsTotalQty(model.getGoodsTotalQty());
dto.setCreationTime(model.getCreationTime());
dto.setLastUpdateTime(model.getLastUpdateTime());
dto.set
```
<Overlap Ratio: 0.906183368869936>

---

--- 345 --
Question ID: fb0bfa1a52807b4d3670993650f05d0011c60482
Original Code:
```
public class InlineSegmentWranglerTest
{
  @Rule
  public ExpectedException expectedException = ExpectedException.none();

  private final InlineSegmentWrangler factory = new InlineSegmentWrangler();

  private final InlineDataSource inlineDataSource = InlineDataSource.fromIterable(
      ImmutableList.of(
          new Object[]{"foo", 1L},
          new Object[]{"bar", 2L}
      ),
      RowSignature.builder().add("str", ValueType.STRING).add("long", ValueType.LONG).build()
  );

  @Test
  public void test_getSegmentsForIntervals_nonInline()
  {
    expectedException.expect(ClassCastException.class);
    expectedException.expectMessage("TableDataSource cannot be cast");

    final Iterable<Segment> ignored = factory.getSegmentsForIntervals(
        new TableDataSource("foo"),
        Intervals.ONLY_ETERNITY
    );
  }

  @Test
  public void test_getSegmentsForIntervals_inline()
  {
    final List<Segment> segments = ImmutableList.copyOf(
        factory.getSegmentsForIntervals(
            inlineDataSource,
            Intervals.ONLY_ETERNITY
        )
    );

    Assert.assertEquals(1, segments.size());

    final Segment segment = Iterables.getOnlyElement(segments);
    Assert.assertThat(segment, CoreMatchers.instanceOf(RowBasedSegment.class));
  }
}
```


Overlapping Code:
```
ic class InlineSegmentWranglerTest
{
@Rule
public ExpectedException expectedException = ExpectedException.none();
private final InlineSegmentWrangler factory = new InlineSegmentWrangler();
private final InlineDataSource inlineDataSource = InlineDataSource.fromIterable(
ImmutableList.of(
new Object[]{"foo", 1L},
new Object[]{"bar", 2L}
),
RowSignature.builder().add("str", ValueType.STRING).add("long", ValueType.LONG).build()
);
@Test
public void test_getSegmentsForIntervals_nonInline()
{
expectedException.expect(ClassCastException.class);
expectedException.expectMessage("TableDataSource cannot be cast");
final Iterable<Segment> ignored = factory.getSegmentsForIntervals(
new TableDataSource("foo"),
Intervals.ONLY_ETERNITY
);
}
@Test
public void test_getSegmentsForIntervals_inline()
{
final List<Segment> segments = ImmutableList.copyOf(
factory.getSegmentsForIntervals(
inlineDataSource,
Intervals.ONLY_ETERNITY
)
);
Assert.assertEquals(1, segments.size());
final Segment segment = Iterables.getOnlyElement(segments);
Assert.assertThat(segment, CoreMatchers.instanceOf(RowBasedSegment.class)
```
<Overlap Ratio: 0.990990990990991>

---

--- 346 --
Question ID: 14c9502fd410f4499cfc677fad2f4078828dba00
Original Code:
```
@WebServlet("/comments-size")
public class ServletSize extends HttpServlet {

  private int numberOfComments;

  public int loadComments() throws IOException {
    Query commentsQuery = new Query("Comment"); // Get previous stored comments

    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    
    // Prepare to instance the past stored comments
    PreparedQuery comments = datastore.prepare(commentsQuery);

    return (int)comments.countEntities();
  }
  
  @Override
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    response.setContentType("text/html;");
    response.getWriter().println(loadComments());
  }
}
```


Overlapping Code:
```
rvletSize extends HttpServlet {
private int numberOfComments;
public int loadComments() throws IOException {
Query commentsQuery = new Query("Comment"); // Get previous stored comments
DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

// Prepare to instance the past stored comments
PreparedQuery comments = datastore.prepare(commentsQuery);
return (int)comments.countEntities();
}

@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
response.setContentType("text/html;");
response.getWriter().println(loadComments())
```
<Overlap Ratio: 0.9230769230769231>

---

--- 347 --
Question ID: d776db482f76279697a4de02d2a60eec296d956e
Original Code:
```
public class SortMethod {

    public static final String MESSAGE_CONSTRAINTS = "Sort method must be either name, date, or priority.";
    public static final Comparator STUB_COMPARATOR = (a, b) -> 0; //Stub comparator
    private final String sortMethodString;
    private final Comparator<Deadline> deadlineComparator;
    private final Comparator<Event> eventComparator;

    /**
     * Constructs a {@code SortMethod}.
     * @param method A valid method of sorting.
     */
    public SortMethod(String method) {
        requireNonNull(method);
        checkArgument(isValidSortMethod(method), MESSAGE_CONSTRAINTS);
        this.sortMethodString = method;
        this.deadlineComparator = generateDeadlineComparator(method);
        this.eventComparator = generateEventComparator(method);

    }

    /**
     * Returns true if a given string is a valid method of sorting.
     */
    public static boolean isValidSortMethod(String test) {
        return (test.equals("name") || test.equals("date") || test.equals("priority"));
    }

    /**
     * Returns the string value of the sort method.
     * @return The string representation of the method of sorting.
     */
    public String getSortMethodString() {
        return sortMethodString;
    }

    /**
     * Returns the DeadlineComparator of the sort method.
     * @return The Comparator used to sort the deadline list.
     */
    public Comparator<Deadline> getDeadlineComparator() {
        return deadlineComparator;
    }

    /**
     * Returns the EventComparator of the sort method.
     * @return The EventComparator used to sort the event list.
     */
    public Comparator<Event> getEventComparator() {
        return eventComparator;
    }

    /**
     * Generates and returns the DeadlineComparator used to sort the deadline list.
     * Default deadline comparator, sorts in ascending order.
     * Lexicographically smallest(a-z), earliest due date, highest priority at the top of the module deadline list.
     * @return The DeadlineComparator of this instance of {@code SortMethod}.
     */
    public Comparator<Deadline> generateDeadlineComparator(String method) {
        Comparator<Deadline> nameSorter = Comparator.comparing(l -> l.getName().toString(),
                String.CASE_INSENSITIVE_ORDER);
        Comparator<Deadline> dateSorter = Comparator.comparing(l -> l.getDueDate().toString());
        Comparator<Deadline> prioritySorter = Comparator.comparing(l -> l.getPriority().toString(),
                Comparator.reverseOrder());

        switch (method) {
        case "name":
            return nameSorter;
        case "date":
            return dateSorter;
        case "priority":
            return prioritySorter;
        default:
            throw new IllegalStateException("Unexpected value: " + getSortMethodString());
        }
    }

    /**
     * Generates and returns the EventComparator used to sort the event list.
     * Default event comparator, sorts in ascending order.
     * Lexicographically smallest(a-z), earliest start date, at the top of the module event list.
     * Will not sort based on priority.
     * @return The DeadlineComparator of this instance of {@code SortMethod}.
     */
    public Comparator<Event> generateEventComparator(String method) {
        Comparator<Event> nameSorter = Comparator.comparing(l -> l.getName().toString(),
                String.CASE_INSENSITIVE_ORDER);
        Comparator<Event> dateSorter = Comparator.comparing(l -> l.getStartDate().toString());
        Comparator<Event> prioritySorter = STUB_COMPARATOR;

        switch (method) {
        case "name":
            return nameSorter;
        case "date":
            return dateSorter;
        case "priority":
            return prioritySorter;
        default:
            throw new IllegalStateException("Unexpected value: " + getSortMethodString());
        }
    }

    @Override
    public String toString() {
        return getSortMethodString();
    }

}
```


Overlapping Code:
```
rtMethod {
public static final String MESSAGE_CONSTRAINTS = "Sort method must be either name, date, or priority.";
public static final Comparator STUB_COMPARATOR = (a, b) -> 0; //Stub comparator
private final String sortMethodString;
private final Comparator<Deadline> deadlineComparator;
private final Comparator<Event> eventComparator;
/**
* Constructs a {@code SortMethod}.
* @param method A valid method of sorting.
*/
public SortMethod(String method) {
requireNonNull(method);
checkArgument(isValidSortMethod(method), MESSAGE_CONSTRAINTS);
this.sortMethodString = method;
this.deadlineComparator = generateDeadlineComparator(method);
this.eventComparator = generateEventComparator(method);
}
/**
* Returns true if a given string is a valid method of sorting.
*/
public static boolean isValidSortMethod(String test) {
return (test.equals("name") || test.equals("date") || test.equals("priority"));
}
/**
* Returns the string value of the sort method.
* @return The string representation of the method of sorting.
*/
public String getSortMethodString() {
return sortMethodString;
}
/**
* Returns the DeadlineComparator of the sort method.
* @return The Comparator used to sort the deadline list.
*/
public Comparator<Deadline> getDeadlineComparator() {
return deadlineComparator;
}
/**
* Returns the EventComparator of the sort method.
* @return The EventComparator used to sort the event list.
*/
public Comparator<Event> getEventComparator() {
return eventComparator;
}
/**
* Generates and returns the DeadlineComparator used to sort the deadline list.
* Default deadline comparator, sorts in ascending order.
* Lexicographically smallest(a-z), earliest due date, highest priority at the top of the module deadline list.
* @return The DeadlineComparator of this instance of {@code SortMethod}.
*/
public Comparator<Deadline> generateDeadlineComparator(String method) {
Comparator<Deadline> nameSorter = Comparator.comparing(l -> l.getName().toString(),
String.CASE_INSENSITIVE_ORDER);
Comparator<Deadline> dateSorter = Comparator.comparing(l -> l.getDueDate().toString());
Comparator<Deadline> prioritySorter = Comparator.comparing(l -> l.getPriority(
```
<Overlap Ratio: 0.9871794871794872>

---

--- 348 --
Question ID: c63559d3be42f326bb942434a9722814a61aa588
Original Code:
```
public class ManuscriptDatabaseStorageImplTest extends ContextUnitTest {
    private static Logger log = Logger.getLogger(ManuscriptDatabaseStorageImplTest.class);
    private static final String TEST_JOURNAL_CODE = "test";
    private static final String TEST_JOURNAL_NAME = "Test Journal";
    private static final String TEST_MANUSCRIPT_ID_1 = "MS_TEST_12345";
    private static final String TEST_MANUSCRIPT_ID_2 = "MS_TEST_99999";

    private StoragePath collectionPath = new StoragePath();
    private StoragePath manuscriptPath1 = new StoragePath();
    private StoragePath manuscriptPath2 = new StoragePath();

    public ManuscriptDatabaseStorageImplTest() {
        collectionPath = StoragePath.createJournalPath(TEST_JOURNAL_CODE);
        manuscriptPath1 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_1);
        manuscriptPath2 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_2);
    }

    @Before
    public void setUp() {
        super.setUp();
        // Create a journal
        DryadJournalConcept journal = null;
        try {
            DryadJournalConcept journalConcept = new DryadJournalConcept();
            journalConcept.setFullName(TEST_JOURNAL_NAME);
            journalConcept.setJournalID(TEST_JOURNAL_CODE);
            Context context = new Context();
            JournalUtils.addDryadJournalConcept(context, journalConcept);
            journal = JournalConceptDatabaseStorageImpl.getJournalConceptByCodeOrISSN(context, TEST_JOURNAL_CODE);
            context.complete();
        } catch (Exception ex) {
            fail("Exception setting up test journal: " + ex);
        }

        // Create a manuscript
        Manuscript manuscript = new Manuscript();
        manuscript.configureTestValues();
        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);
        try {
            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);
            TableRow manuscriptRow = ManuscriptDatabaseStorageImpl.tableRowFromManuscript(manuscript, journal.getConceptID());
            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_VERSION, 1);
            manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_ACTIVE, ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);
            DatabaseManager.insert(context, manuscriptRow);
            context.commit();
        } catch (Exception ex) {
            fail("Exception setting up test manuscript: " + ex);
        }
    }

    @Override
    public void tearDown() {
        try {
            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);
            DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_2);
        } catch (SQLException ex) {
            fail("Exception clearing test journal and manuscript: " + ex);
        }
        super.tearDown();
    }

    /**
     * Test of objectExists method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testObjectExists() throws Exception {
        log.info("objectExists");
        StoragePath path = collectionPath;
        Manuscript manuscript = new Manuscript();
        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        Boolean expResult = Boolean.TRUE;
        Boolean result = instance.objectExists(path, manuscript);
        assertEquals("Test manuscript should exist", expResult, result);
    }

    /**
     * Test of addAll method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testAddAll() throws Exception {
        log.info("addAll");
        StoragePath path = collectionPath;
        List<Manuscript> manuscripts = new ArrayList<Manuscript>();
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        instance.addAll(path, manuscripts);
        Integer expectedSize = 1;
        Integer actualSize = manuscripts.size();
        assertEquals("There should be 1  manuscript", expectedSize, actualSize);
    }

    /**
     * Test of createObject method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testCreateObject() throws Exception {
        log.info("createObject");
        StoragePath path = manuscriptPath2;
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        Manuscript manuscript = instance.readObject(path);
        assertNull("Object must not exist before creating", manuscript);
        manuscript = new Manuscript();
        manuscript.configureTestValues();
        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_2);
        path = collectionPath;
        instance.createObject(path, manuscript);
        Boolean exists = instance.objectExists(path, manuscript);
        assertTrue("Newly saved object should exist", exists);
    }

    /**
     * Test of readObject method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testReadObject() throws Exception {
        log.info("readObject");
        StoragePath path = manuscriptPath1;
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        String expManuscriptId = TEST_MANUSCRIPT_ID_1;
        Manuscript result = instance.readObject(path);
        assertEquals("Read object should have same id as original", expManuscriptId, result.getManuscriptId());
    }

    /**
     * Test of deleteObject method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testDeleteObject() throws Exception {
        log.info("deleteObject");
        StoragePath path = manuscriptPath1;
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        instance.deleteObject(path);
        Manuscript dummyManuscript = new Manuscript();
        dummyManuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);
        dummyManuscript.setStatus(Manuscript.STATUS_ACCEPTED);
        Boolean exists = instance.objectExists(path, dummyManuscript);
        assertFalse("Deleted object should not exist", exists);
    }

    /**
     * Test of updateObject method, of class ManuscriptDatabaseStorageImpl.
     */
    @Test
    public void testUpdateObject() throws Exception {
        log.info("updateObject");
        StoragePath path = manuscriptPath1;
        Manuscript manuscript = new Manuscript();
        manuscript.configureTestValues();
        manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);
        String updatedTitle = "Updated Title";
        manuscript.setTitle(updatedTitle);
        ManuscriptDatabaseStorageImpl instance = new ManuscriptDatabaseStorageImpl();
        instance.updateObject(path, manuscript);
        manuscript = instance.readObject(path);
        assertEquals(updatedTitle, manuscript.getTitle());

        // version should change internally!
        String query = "SELECT * FROM MANUSCRIPT where msid = ? and active = ?";
        TableRow row = DatabaseManager.querySingleTable(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, query, manuscript.getManuscriptId(), ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);
    }
}
```


Overlapping Code:
```
 class ManuscriptDatabaseStorageImplTest extends ContextUnitTest {
private static Logger log = Logger.getLogger(ManuscriptDatabaseStorageImplTest.class);
private static final String TEST_JOURNAL_CODE = "test";
private static final String TEST_JOURNAL_NAME = "Test Journal";
private static final String TEST_MANUSCRIPT_ID_1 = "MS_TEST_12345";
private static final String TEST_MANUSCRIPT_ID_2 = "MS_TEST_99999";
private StoragePath collectionPath = new StoragePath();
private StoragePath manuscriptPath1 = new StoragePath();
private StoragePath manuscriptPath2 = new StoragePath();
public ManuscriptDatabaseStorageImplTest() {
collectionPath = StoragePath.createJournalPath(TEST_JOURNAL_CODE);
manuscriptPath1 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_1);
manuscriptPath2 = StoragePath.createManuscriptPath(TEST_JOURNAL_CODE, TEST_MANUSCRIPT_ID_2);
}
@Before
public void setUp() {
super.setUp();
// Create a journal
DryadJournalConcept journal = null;
try {
DryadJournalConcept journalConcept = new DryadJournalConcept();
journalConcept.setFullName(TEST_JOURNAL_NAME);
journalConcept.setJournalID(TEST_JOURNAL_CODE);
Context context = new Context();
JournalUtils.addDryadJournalConcept(context, journalConcept);
journal = JournalConceptDatabaseStorageImpl.getJournalConceptByCodeOrISSN(context, TEST_JOURNAL_CODE);
context.complete();
} catch (Exception ex) {
fail("Exception setting up test journal: " + ex);
}
// Create a manuscript
Manuscript manuscript = new Manuscript();
manuscript.configureTestValues();
manuscript.setManuscriptId(TEST_MANUSCRIPT_ID_1);
try {
DatabaseManager.deleteByValue(context, ManuscriptDatabaseStorageImpl.MANUSCRIPT_TABLE, ManuscriptDatabaseStorageImpl.COLUMN_MSID, TEST_MANUSCRIPT_ID_1);
TableRow manuscriptRow = ManuscriptDatabaseStorageImpl.tableRowFromManuscript(manuscript, journal.getConceptID());
manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_VERSION, 1);
manuscriptRow.setColumn(ManuscriptDatabaseStorageImpl.COLUMN_ACTIVE, ManuscriptDatabaseStorageImpl.ACTIVE_TRUE);
DatabaseManager.insert(context, manuscriptRow);
c
```
<Overlap Ratio: 0.9781089892873778>

---

--- 349 --
Question ID: c2de2df13e6f0b3d046af53e90c838e39b8fba77
Original Code:
```
@SuppressWarnings({"unchecked"})
public class TestDistortImageOps {

	Random rand = new Random(234);
	int width = 20;
	int height = 30;

	/**
	 * Checks to see if the two ways of specifying interpolation work
	 */
	@Test
	public void scale_InterpTypeStyle() {
		GrayF32 input = new GrayF32(width,height);
		GrayF32 output = new GrayF32(width,height);

		GImageMiscOps.fillUniform(input, rand, 0, 100);

		DistortImageOps.scale(input,output, BorderType.ZERO, InterpolationType.BILINEAR);

		InterpolatePixelS<GrayF32> interp = FactoryInterpolation.bilinearPixelS(input, BorderType.EXTENDED);
		interp.setImage(input);

		float scaleX = (float)input.width/(float)output.width;
		float scaleY = (float)input.height/(float)output.height;

		if( input.getDataType().isInteger() ) {
			for( int i = 0; i < output.height; i++ ) {
				for( int j = 0; j < output.width; j++ ) {
					float val = interp.get(j*scaleX,i*scaleY);
					assertEquals((int)val,output.get(j,i),1e-4);
				}
			}
		} else {
			for( int i = 0; i < output.height; i++ ) {
				for( int j = 0; j < output.width; j++ ) {
					float val = interp.get(j*scaleX,i*scaleY);
					assertEquals(val,output.get(j,i),1e-4);
				}
			}
		}
	}

	/**
	 * Very simple test for rotation accuracy.
	 */
	@Test
	public void rotate_SanityCheck() {
		GrayF32 input = new GrayF32(width,height);
		GrayF32 output = new GrayF32(height,width);

		GImageMiscOps.fillUniform(input, rand, 0, 100);

		DistortImageOps.rotate(input, output,BorderType.ZERO, InterpolationType.BILINEAR, (float) Math.PI / 2f);

		double error = 0;
		// the outside pixels are ignored because numerical round off can cause those to be skipped
		for( int y = 1; y < input.height-1; y++ ) {
			for( int x = 1; x < input.width-1; x++ ) {
				int xx = output.width-y;
				int yy = x;

				double e = input.get(x,y)-output.get(xx,yy);
				error += Math.abs(e);
			}
		}
		assertTrue(error / (width * height) < 0.1);
	}

	/**
	 * boundBox that checks to see if it is contained inside the output image.
	 */
	@Test
	public void boundBox_check() {

		// basic sanity check
		Affine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);
		PixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);
		RectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,30,40,transform);
		
		assertEquals(2,found.x0);
		assertEquals(3,found.y0);
		assertEquals(10,found.width);
		assertEquals(20,found.height);
		
		// bottom right border
		found = DistortImageOps.boundBox(10,20,8,18,transform);
		assertEquals(2,found.x0);
		assertEquals(3,found.y0);
		assertEquals(6,found.width);
		assertEquals(15,found.height);
		
		// top right border
		affine.set(new Affine2D_F32(1,0,0,1,-2,-3));
		found = DistortImageOps.boundBox(10,20,8,18,transform);
		assertEquals(0,found.x0);
		assertEquals(0,found.y0);
		assertEquals(8,found.width);
		assertEquals(17,found.height);
	}

	@Test
	public void boundBox() {

		// basic sanity check
		Affine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);
		PixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);
		RectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,transform);

		assertEquals(2,found.x0);
		assertEquals(3,found.y0);
		assertEquals(10,found.width);
		assertEquals(20,found.height);
	}

	@Test
	public void boundBox_F32() {

		// basic sanity check
		Affine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);
		PixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);
		RectangleLength2D_F32 found = DistortImageOps.boundBox_F32(10,20,transform);

		assertEquals(2,found.x0,1e-4);
		assertEquals(3,found.y0,1e-4);
		assertEquals(10,found.width,1e-4);
		assertEquals(20,found.height,1e-4);
	}

	@Test
	public void boundBox_F64() {
		// basic sanity check
		Affine2D_F64 affine = new Affine2D_F64(1,0,0,1,2,3);
		PixelTransformAffine_F64 transform = new PixelTransformAffine_F64(affine);
		RectangleLength2D_F64 found = DistortImageOps.boundBox_F64(10, 20, transform);

		assertEquals(2,found.x0,1e-8);
		assertEquals(3,found.y0,1e-8);
		assertEquals(10,found.width,1e-8);
		assertEquals(20,found.height,1e-8);
	}
}
```


Overlapping Code:
```
@SuppressWarnings({"unchecked"})
public class TestDistortImageOps {
Random rand = new Random(234);
int width = 20;
int height = 30;
/**
* Checks to see if the two ways of specifying interpolation work
*/
@Test
public void scale_InterpTypeStyle() {
GrayF32 input = new GrayF32(width,height);
GrayF32 output = new GrayF32(width,height);
GImageMiscOps.fillUniform(input, rand, 0, 100);
DistortImageOps.scale(input,output, BorderType.ZERO, InterpolationType.BILINEAR);
InterpolatePixelS<GrayF32> interp = FactoryInterpolation.bilinearPixelS(input, BorderType.EXTENDED);
interp.setImage(input);
float scaleX = (float)input.width/(float)output.width;
float scaleY = (float)input.height/(float)output.height;
if( input.getDataType().isInteger() ) {
for( int i = 0; i < output.height; i++ ) {
for( int j = 0; j < output.width; j++ ) {
float val = interp.get(j*scaleX,i*scaleY);
assertEquals((int)val,output.get(j,i),1e-4);
}
}
} else {
for( int i = 0; i < output.height; i++ ) {
for( int j = 0; j < output.width; j++ ) {
float val = interp.get(j*scaleX,i*scaleY);
assertEquals(val,output.get(j,i),1e-4);
}
}
}
}
/**
* Very simple test for rotation accuracy.
*/
@Test
public void rotate_SanityCheck() {
GrayF32 input = new GrayF32(width,height);
GrayF32 output = new GrayF32(height,width);
GImageMiscOps.fillUniform(input, rand, 0, 100);
DistortImageOps.rotate(input, output,BorderType.ZERO, InterpolationType.BILINEAR, (float) Math.PI / 2f);
double error = 0;
// the outside pixels are ignored because numerical round off can cause those to be skipped
for( int y = 1; y < input.height-1; y++ ) {
for( int x = 1; x < input.width-1; x++ ) {
int xx = output.width-y;
int yy = x;
double e = input.get(x,y)-output.get(xx,yy);
error += Math.abs(e);
}
}
assertTrue(error / (width * height) < 0.1);
}
/**
* boundBox that checks to see if it is contained inside the output image.
*/
@Test
public void boundBox_check() {
// basic sanity check
Affine2D_F32 affine = new Affine2D_F32(1,0,0,1,2,3);
PixelTransformAffine_F32 transform = new PixelTransformAffine_F32(affine);
RectangleLength2D_I32 found = DistortImageOps.boundBox(10,20,30,40,transform);

assertEquals(2,found.x0);
assertEquals(3,found.y0);
assertEquals(10,found.width);
assertEquals(20,found.height);

// bottom right border
found = DistortImageOps.boundBox(10,20,8,
```
<Overlap Ratio: 0.993978494623656>

---

--- 350 --
Question ID: 7dec64bf44dfdaeead1c9e4cadff8c00eb8dfe71
Original Code:
```
public class PostgresIntegrationTest
{
    private Photon photon;

    @SneakyThrows
    @Before
    public void setup()
    {
        String url = "jdbc:postgresql://localhost:15432/";
        photon = new Photon(url, "postgres", "bears", PhotonOptions.postgresOptions().build());

        try(PhotonTransaction transaction = photon.beginAutoCommitTransaction())
        {
            transaction.executeUpdate("CREATE DATABASE photon_test_db");
        }
        catch(PhotonException ex)
        {
            if(ex.getCause() == null || !ex.getCause().getMessage().equals("ERROR: database \"photon_test_db\" already exists"))
            {
                throw ex;
            }
        }

        url = "jdbc:postgresql://localhost:15432/photon_test_db";
        photon = new Photon(url, "postgres", "bears", PhotonOptions.postgresOptions().build());

        photon
            .registerAggregate(PhotonTestTable.class)
            .withId("id")
            .withPrimaryKeyAutoIncrement()
            .register();

        try(PhotonTransaction transaction = photon.beginTransaction())
        {
            transaction
                .query(
                "DROP TABLE IF EXISTS \"PhotonTestTable\";\n" +
                    "CREATE TABLE \"PhotonTestTable\"\n" +
                    "(\n" +
                    "    id SERIAL PRIMARY KEY,\n" +
                    "    \"uuidColumn\" uuid NOT NULL,\n" +
                    "    \"dateColumn\" timestamp without time zone NOT NULL,\n" +
                    "    \"varcharColumn\" character varying(32) COLLATE pg_catalog.\"default\" NOT NULL\n" +
                    ")\n" +
                    "WITH (\n" +
                    "    OIDS = FALSE\n" +
                    ")\n" +
                    "TABLESPACE pg_default;"
                ).executeInsert();

            transaction.commit();
        }

        try(PhotonTransaction transaction = photon.beginTransaction())
        {
            transaction
                .query("INSERT INTO \"PhotonTestTable\" (\"uuidColumn\", \"dateColumn\", \"varcharColumn\") VALUES ('8ED1E1BD-253E-4469-B4CB-71E1217825B7', to_timestamp(1489915698), 'Test String')")
                .executeInsert();

            transaction.commit();
        }
    }

    @Test
    public void fetchExistingAggregateById_populatesValues()
    {
        try(PhotonTransaction transaction = photon.beginTransaction())
        {
            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);

            // Note: Unlike MySQL and SQL Server, Postgres defaults to UTC when given epoch times with to_timestamp(). No need to apply an offset here.

            assertNotNull(photonTestTable);
            assertEquals(1, photonTestTable.getId());
            assertEquals(UUID.fromString("8ED1E1BD-253E-4469-B4CB-71E1217825B7"), photonTestTable.getUuidColumn());
            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochSecond(1489915698), ZoneId.systemDefault()), photonTestTable.getDateColumn());
            assertEquals("Test String", photonTestTable.getVarcharColumn());
        }
    }

    @Test
    public void insertAggregateAndFetch_insertsAggregateAndPopulatesValues()
    {
        PhotonTestTable photonTestTable = new PhotonTestTable(
            null,
            UUID.fromString("11111111-2222-3333-4444-555555555555"),
            ZonedDateTime.ofInstant(Instant.ofEpochSecond(1493493022), ZoneId.systemDefault()),
            "My Test String"
        );

        try(PhotonTransaction transaction = photon.beginTransaction())
        {
            transaction.insert(photonTestTable);
            transaction.commit();
        }

        try(PhotonTransaction transaction = photon.beginTransaction())
        {
            PhotonTestTable photonTestTableFetched = transaction.query(PhotonTestTable.class).fetchById(2);

            assertEquals(photonTestTable, photonTestTableFetched);
        }
    }
}
```


Overlapping Code:
```
ass PostgresIntegrationTest
{
private Photon photon;
@SneakyThrows
@Before
public void setup()
{
String url = "jdbc:postgresql://localhost:15432/";
photon = new Photon(url, "postgres", "bears", PhotonOptions.postgresOptions().build());
try(PhotonTransaction transaction = photon.beginAutoCommitTransaction())
{
transaction.executeUpdate("CREATE DATABASE photon_test_db");
}
catch(PhotonException ex)
{
if(ex.getCause() == null || !ex.getCause().getMessage().equals("ERROR: database \"photon_test_db\" already exists"))
{
throw ex;
}
}
url = "jdbc:postgresql://localhost:15432/photon_test_db";
photon = new Photon(url, "postgres", "bears", PhotonOptions.postgresOptions().build());
photon
.registerAggregate(PhotonTestTable.class)
.withId("id")
.withPrimaryKeyAutoIncrement()
.register();
try(PhotonTransaction transaction = photon.beginTransaction())
{
transaction
.query(
"DROP TABLE IF EXISTS \"PhotonTestTable\";\n" +
"CREATE TABLE \"PhotonTestTable\"\n" +
"(\n" +
" id SERIAL PRIMARY KEY,\n" +
" \"uuidColumn\" uuid NOT NULL,\n" +
" \"dateColumn\" timestamp without time zone NOT NULL,\n" +
" \"varcharColumn\" character varying(32) COLLATE pg_catalog.\"default\" NOT NULL\n" +
")\n" +
"WITH (\n" +
" OIDS = FALSE\n" +
")\n" +
"TABLESPACE pg_default;"
).executeInsert();
transaction.commit();
}
try(PhotonTransaction transaction = photon.beginTransaction())
{
transaction
.query("INSERT INTO \"PhotonTestTable\" (\"uuidColumn\", \"dateColumn\", \"varcharColumn\") VALUES ('8ED1E1BD-253E-4469-B4CB-71E1217825B7', to_timestamp(1489915698), 'Test String')")
.executeInsert();
transaction.commit();
}
}
@Test
public void fetchExistingAggregateById_populatesValues()
{
try(PhotonTransaction transaction = photon.beginTransaction())
{
PhotonTestTable photonTestTable = transaction.query(PhotonTestTable
```
<Overlap Ratio: 0.9917355371900827>

---

--- 351 --
Question ID: 24d42a85665fdc773da355db531eb2570d5677ee
Original Code:
```
public class TestIoCAnno1 {

	@Test
	public void test() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext("aop.target");
		Foo bar = context.getBean(Foo.class);
		bar.bar();
		System.out.println(bar);

		BarCat.BarCat11 bar1 = context.getBean(BarCat.BarCat11.class);
		System.out.println("。。。。。"+bar1);
		context.close();
	}

}
```


Overlapping Code:
```
{
@Test
public void test() {
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext("aop.target");
Foo bar = context.getBean(Foo.class);
bar.bar();
System.out.println(bar);
BarCat.BarCat11 bar1 = context.getBean(BarCat.BarCat11.class);
System.out.println("。。。。。"+bar1);
con
```
<Overlap Ratio: 0.8753623188405797>

---

--- 352 --
Question ID: ca9fd8d092b14c7dafbb7c112860fd752d8984d0
Original Code:
```
public class VirtualMemoryTest {
    private VirtualMemory vm;
    private MemoryPage page;
    private Memory mem;
    private byte[] bytes;

    @Before
    public void setup() {
        vm = new JavaVirtualMemory();
        bytes = new byte[32];
        mem = new ByteMemory(bytes);
        page = new MemoryPage(mem, 0, bytes.length);
        vm.add(page);
        vm.setBrk(32);
    }

    @Test
    public void compute001() {
        int val = 0xF0000021;
        long address = 0x00000000;
        vm.setI32(address, val);
        assertEquals(0xF0000021, vm.getI32(address));
    }

    @Test
    public void brk001() {
        long start = vm.brk();
        assertEquals(0x20, start);
        long brk = vm.brk(start + 0x10);
        assertEquals(0x30, brk);
        brk = vm.brk(brk + 0x10);
        assertEquals(0x40, brk);
        brk = vm.brk(brk + 0x10);
        assertEquals(0x50, brk);

        long address = start;
        for (int i = 0; i < 0x30; i++) {
            vm.setI8(address, (byte) i);
            address++;
        }

        address = start;
        for (int i = 0; i < 0x30; i++) {
            assertEquals((byte) i, vm.getI8(address));
            address++;
        }
    }

    @Test
    public void vm001() {
        vm.set32bit();
        Memory m = new ByteMemory(4096);
        m.setI32(0x42, 0xDEADBEEF);
        MemoryPage p = new MemoryPage(m, 0x80000000L, 4096);
        vm.add(p);
        assertEquals(0xDEADBEEF, vm.getI32(0x80000042));
    }

    @Test
    public void vm002() {
        vm.set32bit();
        Memory m = new ByteMemory(8192);
        MemoryPage p = new MemoryPage(m, 0x80000000L, 8192);
        vm.add(p);
        vm.setI32(0x80000042, 0xDEADBEEF);
        assertEquals(0xDEADBEEF, m.getI32(0x42));
    }

    @Test
    public void vmsplit001() {
        vm.set32bit();
        Memory m1 = new ByteMemory(65536);
        Memory m2 = new ByteMemory(4096);
        MemoryPage p1 = new MemoryPage(m1, 0x80000000L, 65536);
        MemoryPage p2 = new MemoryPage(m2, 0x80001000L, 4096);
        vm.add(p1);
        vm.add(p2);
        vm.setI32(0x80000042, 0xDEADBEEF);
        vm.setI32(0x80001042, 0xC0DEBABE);
        vm.setI32(0x80002042, 0xCAFEBABE);
        assertEquals(0xDEADBEEF, m1.getI32(0x42));
        assertEquals(0xC0DEBABE, m2.getI32(0x42));
        assertEquals(0xCAFEBABE, m1.getI32(0x2042));
    }

    @Test
    public void unmap001() throws PosixException {
        vm.set64bit();
        Memory m = new ByteMemory(4190208);
        MemoryPage p = new MemoryPage(m, 0x7f0000e2a000L, 4190208);
        vm.add(p);

        vm.setI32(0x7f0000e2af00L, 0xDEADBEEF);
        assertEquals(0xDEADBEEF, m.getI32(0xf00));

        vm.remove(0x00007f0000e2a000L, 1925120);

        vm.setI32(0x7f0001000000L, 0xDEADBEEF);
        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));

        vm.remove(0x7f0001200000L, 167936);

        vm.setI32(0x7f0001000010L, 0xC0DEBABE);
        assertEquals(0xDEADBEEF, m.getI32(0x1d6000));

        vm.setI32(0x7f0001000000L, 0xDEADCAFE);
        assertEquals(0xDEADCAFE, m.getI32(0x1d6000));

        assertEquals(0xC0DEBABE, m.getI32(0x1d6010));
    }
}
```


Overlapping Code:
```
irtualMemoryTest {
private VirtualMemory vm;
private MemoryPage page;
private Memory mem;
private byte[] bytes;
@Before
public void setup() {
vm = new JavaVirtualMemory();
bytes = new byte[32];
mem = new ByteMemory(bytes);
page = new MemoryPage(mem, 0, bytes.length);
vm.add(page);
vm.setBrk(32);
}
@Test
public void compute001() {
int val = 0xF0000021;
long address = 0x00000000;
vm.setI32(address, val);
assertEquals(0xF0000021, vm.getI32(address));
}
@Test
public void brk001() {
long start = vm.brk();
assertEquals(0x20, start);
long brk = vm.brk(start + 0x10);
assertEquals(0x30, brk);
brk = vm.brk(brk + 0x10);
assertEquals(0x40, brk);
brk = vm.brk(brk + 0x10);
assertEquals(0x50, brk);
long address = start;
for (int i = 0; i < 0x30; i++) {
vm.setI8(address, (byte) i);
address++;
}
address = start;
for (int i = 0; i < 0x30; i++) {
assertEquals((byte) i, vm.getI8(address));
address++;
}
}
@Test
public void vm001() {
vm.set32bit();
Memory m = new ByteMemory(4096);
m.setI32(0x42, 0xDEADBEEF);
MemoryPage p = new MemoryPage(m, 0x80000000L, 4096);
vm.add(p);
assertEquals(0xDEADBEEF, vm.getI32(0x80000042));
}
@Test
public void vm002() {
vm.set32bit();
Memory m = new ByteMemory(8192);
MemoryPage p = new MemoryPage(m, 0x80000000L, 8192);
vm.add(p);
vm.setI32(0x80000042, 0xDEADBEEF);
assertEquals(0xDEADBEEF, m.getI32(0x42));
}
@Test
public void vmsplit001() {
vm.set32bit();
Memory m1 = new ByteMemory(65536);
Memory m2 = new ByteMemory(4096);
MemoryPage p1 = new MemoryPage(m1, 0x80000000L, 65536);
MemoryPage p2 = new MemoryPage(m2, 0x80001000L, 4096);
vm.add(p1);
vm.add(p2);
vm.setI32(0x80000042, 0xDEADBEEF);
vm.setI32(0x80001042, 0xC0DEBABE);
vm.setI32(0x80002042, 0xCAFEBABE);
assertEquals(0xDEADBEEF, m1.getI32(0x42));
assertEquals(0xC0DEBABE, m2.getI32(0x42));
assertEquals(0xCAFEBABE, m1.getI32(0x2042));
}
@Test
public void unmap001() throws PosixException {
vm.set64bit();
Memory
```
<Overlap Ratio: 0.9803921568627451>

---

--- 353 --
Question ID: ac53ae52e2265abc3785b746e28eda3baf1421cf
Original Code:
```
public class TestElementIndex extends InternalSelenseTestBase {
  @Test
  public void testElementIndex() throws Exception {
    selenium.open("../tests/html/test_element_order.html");
    assertEquals(selenium.getElementIndex("d2"), "1");
    assertEquals(selenium.getElementIndex("d1.1.1"), "0");
    verifyEquals(selenium.getElementIndex("d2"), "1");
    verifyEquals(selenium.getElementIndex("d1.2"), "5");
    assertNotEquals("2", selenium.getElementIndex("d2"));
    verifyNotEquals("2", selenium.getElementIndex("d2"));
  }
}
```


Overlapping Code:
```
ic class TestElementIndex extends InternalSelenseTestBase {
@Test
public void testElementIndex() throws Exception {
selenium.open("../tests/html/test_element_order.html");
assertEquals(selenium.getElementIndex("d2"), "1");
assertEquals(selenium.getElementIndex("d1.1.1"), "0");
verifyEquals(selenium.getElementIndex("d2"), "1");
verifyEquals(selenium.getElementIndex("d1.2"), "5");
assertNotEquals("2", selenium.getElementIndex("d2"));
verifyNotEquals("2", selenium.getE
```
<Overlap Ratio: 0.9456740442655935>

---

--- 354 --
Question ID: 3b8822d52e95cd91642341425a04098e1b94030c
Original Code:
```
public class SQFLintServer {
	private final Options options;
	
	public SQFLintServer(Options options) {
		this.options = options;
	}
	
	public void start() {
		try {
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

			while (true) {
				try {
					if (!processMessage(new JSONObject(br.readLine()))) {
						break;
					}
				} catch (JSONException ex) {
					Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
					System.err.println("Error parsing client message");
				}
			}
		}  catch (IOException ex) {
			Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
	
	private boolean processMessage(JSONObject message) {
		LogUtil.benchLog(options, this, "/ClientMessage", "Client message received");
		
		String filePath = null; // declare here to use in catch block
		try {
			if (message.has("type") && "exit".equals(message.getString("type"))) {
				return false;
			}

			// read filepath
			filePath = message.getString("file");
			
			LogUtil.benchLog(options, this, filePath, "Starting");
			
			// Apply file specific options
			Options fileOptions = new Options(options, new ServerOutput(filePath));
			fileOptions.setRootPath(Paths.get(filePath).toAbsolutePath().getParent().toString());
			fileOptions.getSkippedVariables().clear();

			if (message.has("options")) {
				this.applyOptions(message.getJSONObject("options"), fileOptions);
			}

			SqfFile sqfFile = new SqfFile(
				fileOptions,
				message.has("contents") ?
					message.getString("contents")
					:
					StreamUtil.streamToString(new FileInputStream(filePath)),
				filePath
			);

			sqfFile.process();

			fileOptions.getOutputFormatter().print(sqfFile);

			LogUtil.benchLog(options, this, filePath, "Done");

		} catch (JSONException ex) {
			Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
		} catch (Exception ex) {
			Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, "Error when parsing {0}", filePath);
			Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
		}
		
		return true;
	}
	
	private void applyOptions(JSONObject data, Options fileOptions) {
		try {
			// @TODO: Clear options?
			
			if (data.has("checkPaths")) {
				fileOptions.setCheckPaths(data.getBoolean("checkPaths"));
			}
			
			if (data.has("pathsRoot")) {
				fileOptions.setRootPath(data.getString("pathsRoot"));
			}
			
			if (data.has("ignoredVariables")) {
				JSONArray vars = data.getJSONArray("ignoredVariables");
				for (int i = 0; i < vars.length(); i++) {
					fileOptions.getSkippedVariables().add(vars.getString(i));
				}
			}
						
			if (data.has("includePrefixes")) {
				fileOptions.getIncludePaths().clear();
				JSONObject paths = data.getJSONObject("includePrefixes");
				for (String key : paths.keySet()) {
					fileOptions.getIncludePaths().put(key, paths.getString(key));
				}
			}
			
			if (data.has("contextSeparation")) {
				fileOptions.setContextSeparationEnabled(data.getBoolean("contextSeparation"));
			}
			
		} catch (JSONException ex) {
			Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
		}
	}
	
}
```


Overlapping Code:
```
ver {
private final Options options;

public SQFLintServer(Options options) {
this.options = options;
}

public void start() {
try {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
while (true) {
try {
if (!processMessage(new JSONObject(br.readLine()))) {
break;
}
} catch (JSONException ex) {
Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
System.err.println("Error parsing client message");
}
}
} catch (IOException ex) {
Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
}
}

private boolean processMessage(JSONObject message) {
LogUtil.benchLog(options, this, "/ClientMessage", "Client message received");

String filePath = null; // declare here to use in catch block
try {
if (message.has("type") && "exit".equals(message.getString("type"))) {
return false;
}
// read filepath
filePath = message.getString("file");

LogUtil.benchLog(options, this, filePath, "Starting");

// Apply file specific options
Options fileOptions = new Options(options, new ServerOutput(filePath));
fileOptions.setRootPath(Paths.get(filePath).toAbsolutePath().getParent().toString());
fileOptions.getSkippedVariables().clear();
if (message.has("options")) {
this.applyOptions(message.getJSONObject("options"), fileOptions);
}
SqfFile sqfFile = new SqfFile(
fileOptions,
message.has("contents") ?
message.getString("contents")
:
StreamUtil.streamToString(new FileInputStream(filePath)),
filePath
);
sqfFile.process();
fileOptions.getOutputFormatter().print(sqfFile);
LogUtil.benchLog(options, this, filePath, "Done");
} catch (JSONException ex) {
Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
} catch (Exception ex) {
Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, "Error when parsing {0}", filePath);
Logger.getLogger(SQFLintServer.class.getName()).log(Level.SEVERE, null, ex);
}

return true;
}

private void applyOptions(JSONObject data, Options fileOptions) {
try {
// @TODO: Clear options?

if (data.has("checkPaths")) {
fileOptions.setCheckPaths(data.getBoolean("checkPaths"));
}

if (data.has("pathsRoot")) {
fileOptions.setRootPath(data.getString("pathsRoot"));
}

if (data.has("ignoredVariables")) 
```
<Overlap Ratio: 0.9818744473916887>

---

--- 355 --
Question ID: 4c8c908349d5cdcc86986d9ea3779cc02b3a87a1
Original Code:
```
public class ServerConfigTest
{
  private static final DefaultObjectMapper OBJECT_MAPPER = new DefaultObjectMapper();

  @Test
  public void testSerde() throws Exception
  {
    ServerConfig defaultConfig = new ServerConfig();
    String defaultConfigJson = OBJECT_MAPPER.writeValueAsString(defaultConfig);
    ServerConfig defaultConfig2 = OBJECT_MAPPER.readValue(defaultConfigJson, ServerConfig.class);
    Assert.assertEquals(defaultConfig, defaultConfig2);
    Assert.assertFalse(defaultConfig2.isEnableForwardedRequestCustomizer());

    ServerConfig modifiedConfig = new ServerConfig(
        999,
        888,
        defaultConfig.isEnableRequestLimit(),
        defaultConfig.getMaxIdleTime(),
        defaultConfig.getDefaultQueryTimeout(),
        defaultConfig.getMaxScatterGatherBytes(),
        defaultConfig.getMaxSubqueryRows(),
        defaultConfig.getMaxQueryTimeout(),
        defaultConfig.getMaxRequestHeaderSize(),
        defaultConfig.getGracefulShutdownTimeout(),
        defaultConfig.getUnannouncePropagationDelay(),
        defaultConfig.getInflateBufferSize(),
        defaultConfig.getCompressionLevel(),
        true,
        ImmutableList.of(HttpMethod.OPTIONS)
    );
    String modifiedConfigJson = OBJECT_MAPPER.writeValueAsString(modifiedConfig);
    ServerConfig modifiedConfig2 = OBJECT_MAPPER.readValue(modifiedConfigJson, ServerConfig.class);
    Assert.assertEquals(modifiedConfig, modifiedConfig2);
    Assert.assertEquals(999, modifiedConfig2.getNumThreads());
    Assert.assertEquals(888, modifiedConfig2.getQueueSize());
    Assert.assertTrue(modifiedConfig2.isEnableForwardedRequestCustomizer());
    Assert.assertEquals(1, modifiedConfig2.getAllowedHttpMethods().size());
    Assert.assertTrue(modifiedConfig2.getAllowedHttpMethods().contains(HttpMethod.OPTIONS));
  }

  @Test
  public void testEqualsAndHashCode()
  {
    EqualsVerifier.forClass(ServerConfig.class)
                  // this class uses non-final fields for serialization / de-serialization.
                  // There are no setters that mutate the fields, once the object is instantiated.
                  .suppress(Warning.NONFINAL_FIELDS)
                  .usingGetClass()
                  .verify();
  }
}
```


Overlapping Code:
```
nal DefaultObjectMapper OBJECT_MAPPER = new DefaultObjectMapper();
@Test
public void testSerde() throws Exception
{
ServerConfig defaultConfig = new ServerConfig();
String defaultConfigJson = OBJECT_MAPPER.writeValueAsString(defaultConfig);
ServerConfig defaultConfig2 = OBJECT_MAPPER.readValue(defaultConfigJson, ServerConfig.class);
Assert.assertEquals(defaultConfig, defaultConfig2);
Assert.assertFalse(defaultConfig2.isEnableForwardedRequestCustomizer());
ServerConfig modifiedConfig = new ServerConfig(
999,
888,
defaultConfig.isEnableRequestLimit(),
defaultConfig.getMaxIdleTime(),
defaultConfig.getDefaultQueryTimeout(),
defaultConfig.getMaxScatterGatherBytes(),
defaultConfig.getMaxSubqueryRows(),
defaultConfig.getMaxQueryTimeout(),
defaultConfig.getMaxRequestHeaderSize(),
defaultConfig.getGracefulShutdownTimeout(),
defaultConfig.getUnannouncePropagationDelay(),
defaultConfig.getInflateBufferSize(),
defaultConfig.getCompressionLevel(),
true,
ImmutableList.of(HttpMethod.OPTIONS)
);
String modifiedConfigJson = OBJECT_MAPPER.writeValueAsString(modifiedConfig);
ServerConfig modifiedConfig2 = OBJECT_MAPPER.readValue(modifiedConfigJson, ServerConfig.class);
Assert.assertEquals(modifiedConfig, modifiedConfig2);
Assert.assertEquals(999, modifiedConfig2.getNumThreads());
Assert.assertEquals(888, modifiedConfig2.getQueueSize());
Assert.assertTrue(modifiedConfig2.isEnableForwardedRequestCustomizer());
Assert.assertEquals(1, modifiedConfig2.getAllowedHttpMethods().size());
Assert.assertTrue(modifiedConfig2.getAllowedHttpMethods().contains(HttpMethod.OPTIONS));
}
@Test
public void testEqualsAndHashCode()
{
EqualsVerifier.forClass(ServerConfig.class)
// this class uses non-final fields for serialization / de-serialization.
// There are no setters that mutate the fields, once the object is instantiated.
.suppress(Warning.NONFINAL_FIELDS)
.usingGetClass()
.verify();
}

```
<Overlap Ratio: 0.9741468459152016>

---

--- 356 --
Question ID: 8c639d368aeee14d4cd133a64865ff55144c98ae
Original Code:
```
public class ProtostuffUtilTest extends TestCase {
	
	private List<KutaTuple<Long, Long>> getPages(long min, long max, long pageSize) {
		List<KutaTuple<Long, Long>> pages = new ArrayList<KutaTuple<Long,Long>>();
		if(max - min > pageSize) {
			for (long i = min; i <= max; i += pageSize) {
				if(i + pageSize <= max) {
					pages.add(new KutaTuple<Long, Long>(i==min? min : i+1, i + pageSize));
				}
				else {
					pages.add(new KutaTuple<Long, Long>(i==min? min : i+1, max));
				}
			}
		} else {
			pages.add(new KutaTuple<Long, Long>(min, max));
		}
		return pages;
	}
	
	public void testMapOrList(){
		 List<KutaTuple<Long, Long>> pages = getPages(50000,259200000, 2000000);
		 KutaConsoleUtil.printObj(pages, true);
//		System.out.println(address.toLowerCase());
	}
}
```


Overlapping Code:
```
tCase {

private List<KutaTuple<Long, Long>> getPages(long min, long max, long pageSize) {
List<KutaTuple<Long, Long>> pages = new ArrayList<KutaTuple<Long,Long>>();
if(max - min > pageSize) {
for (long i = min; i <= max; i += pageSize) {
if(i + pageSize <= max) {
pages.add(new KutaTuple<Long, Long>(i==min? min : i+1, i + pageSize));
}
else {
pages.add(new KutaTuple<Long, Long>(i==min? min : i+1, max));
}
}
} else {
pages.add(new KutaTuple<Long, Long>(min, max));
}
return pages;
}

public void testMapOrList(){
List<KutaTuple<Long, Long>> pages = getPages(50000,259200000, 2000000);
KutaConsoleUtil.printObj(pages, true);
// System.out.println(a
```
<Overlap Ratio: 0.9040333796940194>

---

--- 357 --
Question ID: d487db49a3830a9f3761971957cad5fe5d8ef01c
Original Code:
```
@Service
@Transactional
public class RoomTaskService {

    private final Logger log = LoggerFactory.getLogger(RoomTaskService.class);

    private final RoomTaskRepository roomTaskRepository;

    private final RoomTaskMapper roomTaskMapper;

    private final RoomService roomService;

    private final NotificationService notificationService;

    public RoomTaskService(RoomTaskRepository roomTaskRepository, RoomTaskMapper roomTaskMapper, NotificationService notificationService, RoomService roomService) {
        this.roomTaskRepository = roomTaskRepository;
        this.roomTaskMapper = roomTaskMapper;
        this.notificationService = notificationService;
        this.roomService = roomService;
    }

    /**
     * Save a roomTask.
     *
     * @param roomTaskDTO the entity to save
     * @return the persisted entity
     */
    public RoomTaskDTO save(RoomTaskDTO roomTaskDTO) {
        log.debug("Request to save RoomTask : {}", roomTaskDTO);
        RoomTask roomTask = roomTaskMapper.toEntity(roomTaskDTO);

        boolean sendNotification = roomTask.getId() == null;

        roomTask = roomTaskRepository.save(roomTask);

        if(sendNotification)
            sendNotificationRoomies(roomTask, true);

        RoomTaskDTO result = roomTaskMapper.toDto(roomTask);
        return result;
    }

    /**
     * Get all the roomTasks.
     *
     * @param pageable the pagination information
     * @return the list of entities
     */
    @Transactional(readOnly = true)
    public Page<RoomTaskDTO> findAll(Pageable pageable) {
        log.debug("Request to get all RoomTasks");
        return roomTaskRepository.findAll(pageable)
            .map(roomTaskMapper::toDto);
    }


    /**
     * Get one roomTask by id.
     *
     * @param id the id of the entity
     * @return the entity
     */
    @Transactional(readOnly = true)
    public Optional<RoomTaskDTO> findOne(Long id) {
        log.debug("Request to get RoomTask : {}", id);
        return roomTaskRepository.findById(id)
            .map(roomTaskMapper::toDto);
    }

    /**
     * Delete the roomTask by id.
     *
     * @param id the id of the entity
     */
    public void delete(Long id) {
        log.debug("Request to delete RoomTask : {}", id);
        roomTaskRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<RoomTaskDTO> findAllByRoom(Long id) {
        log.debug("Request to get all RoomTasks by room id");
        return roomTaskMapper.toDto(roomTaskRepository.findByRoomId(id));
    }


    /**
     * Task that sends task notifications every 30 minutes.
     * Scheduled task.
     */
    @Scheduled(cron = "0 0/30 * * * *")
    public void scheduledRoomTasksNotification(){
        log.info("Room Tasks notification execution: {}", Instant.now().toString());

        Instant startTime = Instant.now().plus(Duration.ofMinutes(59));
        Instant endTime = Instant.now().plus(Duration.ofMinutes(91));

        List<RoomTask> roomTasks = roomTaskRepository.findByDeadlineBetween(startTime, endTime);

        log.info("{} tasks found between {}, {}", roomTasks.size(), startTime.toString(), endTime.toString());

        for(RoomTask roomTask : roomTasks)
            sendNotificationRoomies(roomTask, false);
    }

    private void sendNotificationRoomies(RoomTask roomTask, Boolean isNew) {
        try {
            if(roomTask.getState().equals(RoomTaskState.COMPLETED))
                return;

            RoomDTO room = roomService.findOne(roomTask.getRoom().getId()).get();

            //Notify room owner
            sendNotification(roomTask, room.getOwnerId(), isNew);

            //Notify roomies
            for (RoomieDTO roomie : room.getRoomies())
                    sendNotification(roomTask, roomie.getId(), isNew);

        } catch (NullPointerException e){
            log.error("Error sending notification: {}", e.getMessage());
        }
    }

    private void sendNotification(RoomTask roomTask, Long recipientId, boolean isNew){
        NotificationDTO notification = new NotificationDTO();
        notification.setCreated(Instant.now());
        notification.setState(NotificationState.NEW);
        notification.setType(NotificationType.TODO);
        notification.setEntityId(roomTask.getId());
        notification.setRecipientId(recipientId);

        if(isNew)
            notification.setTitle("A new task has been added to the room!");
        else
            notification.setTitle("One of your room tasks needs to be completed soon!");

        notification.setBody(String.format("%s, deadline: %s UTC", roomTask.getTitle(), roomTask.getDeadline().toString()));

        notificationService.save(notification);
    }
}
```


Overlapping Code:
```
TaskService {
private final Logger log = LoggerFactory.getLogger(RoomTaskService.class);
private final RoomTaskRepository roomTaskRepository;
private final RoomTaskMapper roomTaskMapper;
private final RoomService roomService;
private final NotificationService notificationService;
public RoomTaskService(RoomTaskRepository roomTaskRepository, RoomTaskMapper roomTaskMapper, NotificationService notificationService, RoomService roomService) {
this.roomTaskRepository = roomTaskRepository;
this.roomTaskMapper = roomTaskMapper;
this.notificationService = notificationService;
this.roomService = roomService;
}
/**
* Save a roomTask.
*
* @param roomTaskDTO the entity to save
* @return the persisted entity
*/
public RoomTaskDTO save(RoomTaskDTO roomTaskDTO) {
log.debug("Request to save RoomTask : {}", roomTaskDTO);
RoomTask roomTask = roomTaskMapper.toEntity(roomTaskDTO);
boolean sendNotification = roomTask.getId() == null;
roomTask = roomTaskRepository.save(roomTask);
if(sendNotification)
sendNotificationRoomies(roomTask, true);
RoomTaskDTO result = roomTaskMapper.toDto(roomTask);
return result;
}
/**
* Get all the roomTasks.
*
* @param pageable the pagination information
* @return the list of entities
*/
@Transactional(readOnly = true)
public Page<RoomTaskDTO> findAll(Pageable pageable) {
log.debug("Request to get all RoomTasks");
return roomTaskRepository.findAll(pageable)
.map(roomTaskMapper::toDto);
}
/**
* Get one roomTask by id.
*
* @param id the id of the entity
* @return the entity
*/
@Transactional(readOnly = true)
public Optional<RoomTaskDTO> findOne(Long id) {
log.debug("Request to get RoomTask : {}", id);
return roomTaskRepository.findById(id)
.map(roomTaskMapper::toDto);
}
/**
* Delete the roomTask by id.
*
* @param id the id of the entity
*/
public void delete(Long id) {
log.debug("Request to delete RoomTask : {}", id);
roomTaskRepository.deleteById(id);
}
@Transactional(readOnly = true)
public List<RoomTaskDTO> findAllByRoom(Long id) {
log.debug("Request to get all RoomTasks by room id");
return roomTaskMapper.
```
<Overlap Ratio: 0.9724857685009488>

---

--- 358 --
Question ID: e36287f078f00cc006443cef39087027970c98eb
Original Code:
```
public class DockerContainer {
    public final DockerImage image;
    public final boolean privileged;
    public final List<EnvironmentVar> environment;
    public final List<String> volumes;
    public final List<DockerLink> links;

    public DockerContainer(
            DockerImage image,
            boolean privileged,
            List<EnvironmentVar> environment,
            List<String> volumes,
            List<DockerLink> links) {
        this.image = image;
        this.privileged = privileged;
        this.environment = environment;
        this.volumes = volumes;
        this.links = links;
    }

    public DockerContainer(DockerImage image) {
        this(image, false, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
    }

    public DockerContainer(JsonObject json)  {
        image = new DockerImage(json.get("image").getAsJsonObject());
        privileged = json.get("privileged").getAsBoolean();
        volumes = jsonToListOfString(json.get("volumes").getAsJsonArray());
        environment = jsonToList(json.get("environment").getAsJsonArray(), jsonElement -> new EnvironmentVar(jsonElement.getAsJsonObject()));
        links = jsonToList(json.get("links").getAsJsonArray(), jsonElement -> new DockerLink(jsonElement.getAsJsonObject()));
    }

    public JsonObject toJson() {
        JsonObject json = new JsonObject();
        json.add("image", image.toJson());
        json.addProperty("privileged", privileged);
        json.add("volumes", listOfString(volumes));
        json.add("environment", listOfObjects(environment, EnvironmentVar::toJson));
        json.add("links", listOfObjects(links, DockerLink::toJson));
        return json;
    }


}
```


Overlapping Code:
```
 {
public final DockerImage image;
public final boolean privileged;
public final List<EnvironmentVar> environment;
public final List<String> volumes;
public final List<DockerLink> links;
public DockerContainer(
DockerImage image,
boolean privileged,
List<EnvironmentVar> environment,
List<String> volumes,
List<DockerLink> links) {
this.image = image;
this.privileged = privileged;
this.environment = environment;
this.volumes = volumes;
this.links = links;
}
public DockerContainer(DockerImage image) {
this(image, false, new ArrayList<>(), new ArrayList<>(), new ArrayList<>());
}
public DockerContainer(JsonObject json) {
image = new DockerImage(json.get("image").getAsJsonObject());
privileged = json.get("privileged").getAsBoolean();
volumes = jsonToListOfString(json.get("volumes").getAsJsonArray());
environment = jsonToList(json.get("environment").getAsJsonArray(), jsonElement -> new EnvironmentVar(jsonElement.getAsJsonObject()));
links = jsonToList(json.get("links").getAsJsonArray(), jsonElement -> new DockerLink(jsonElement.getAsJsonObject()));
}
public JsonObject toJson() {
JsonObject json = new JsonObject();
json.add("image", image.toJson());
json.addProperty("privileged", privileged);
json.add("volumes", listOfString(volumes));
json.add("environment", listOfObjects(environment, EnvironmentVar::toJson));
json.add("links", listOfObjects(links, DockerLink::toJson));
return json;

```
<Overlap Ratio: 0.9783368273934312>

---

--- 359 --
Question ID: a7bc87a9e2f6e4f2190eea13f6b0e2bd3901515a
Original Code:
```
public class ClassTranslatorFactory<P> implements TranslatorFactory<P, PropertyContainer>
{
	/** Cache of existing translators, see the class javadoc */
	private Map<Class<P>, ClassTranslator<P>> translators = new HashMap<>();

	@Override
	public ClassTranslator<P> create(TypeKey<P> tk, CreateContext ctx, Path path) {
		Class<P> clazz = tk.getTypeAsClass();

		ClassTranslator<P> classTranslator = translators.get(clazz);
		if (classTranslator == null) {
			// Entity is an inherited annotation; this checks up the hierarchy
			classTranslator = (clazz.isAnnotationPresent(Entity.class))
					? createEntityClassTranslator(clazz, ctx, path)
					: createEmbeddedClassTranslator(clazz, ctx, path);

			translators.put(clazz, classTranslator);

			if (clazz.isAnnotationPresent(Subclass.class))
				registerSubclass(classTranslator, new TypeKey<>(clazz.getSuperclass(), tk), ctx, path);
		}

		return classTranslator;
	}

	/**
	 */
	public static <P> ClassTranslator<P> createEntityClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {
		KeyMetadata<P> keyMetadata = new KeyMetadata<>(clazz, ctx, path);
		Creator<P> creator = new EntityCreator<>(clazz, ctx.getFactory(), keyMetadata);
		Populator<P> populator = new ClassPopulator<>(clazz, ctx, path);

		return new ClassTranslator<>(clazz, path, creator, populator);
	}

	/**
	 */
	public static <P> ClassTranslator<P> createEmbeddedClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {
		Creator<P> creator = new EmbeddedCreator<>(clazz, ctx.getFactory());
		Populator<P> populator = new ClassPopulator<>(clazz, ctx, path);

		return new ClassTranslator<>(clazz, path, creator, populator);
	}

	/**
	 * Recursively register this subclass with all the superclass translators. This works because we cache
	 * translators uniquely in the factory.
	 */
	private void registerSubclass(ClassTranslator<P> translator, TypeKey<? super P> superclassTypeKey, CreateContext ctx, Path path) {
		if (superclassTypeKey.getTypeAsClass() == Object.class)
			return;

		@SuppressWarnings("unchecked")
		ClassTranslator<? super P> superTranslator = create((TypeKey)superclassTypeKey, ctx, path);
		superTranslator.registerSubclass(translator);

		registerSubclass(translator, new TypeKey<>(superclassTypeKey.getTypeAsClass().getSuperclass()), ctx, path);
	}
}
```


Overlapping Code:
```
class ClassTranslatorFactory<P> implements TranslatorFactory<P, PropertyContainer>
{
/** Cache of existing translators, see the class javadoc */
private Map<Class<P>, ClassTranslator<P>> translators = new HashMap<>();
@Override
public ClassTranslator<P> create(TypeKey<P> tk, CreateContext ctx, Path path) {
Class<P> clazz = tk.getTypeAsClass();
ClassTranslator<P> classTranslator = translators.get(clazz);
if (classTranslator == null) {
// Entity is an inherited annotation; this checks up the hierarchy
classTranslator = (clazz.isAnnotationPresent(Entity.class))
? createEntityClassTranslator(clazz, ctx, path)
: createEmbeddedClassTranslator(clazz, ctx, path);
translators.put(clazz, classTranslator);
if (clazz.isAnnotationPresent(Subclass.class))
registerSubclass(classTranslator, new TypeKey<>(clazz.getSuperclass(), tk), ctx, path);
}
return classTranslator;
}
/**
*/
public static <P> ClassTranslator<P> createEntityClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {
KeyMetadata<P> keyMetadata = new KeyMetadata<>(clazz, ctx, path);
Creator<P> creator = new EntityCreator<>(clazz, ctx.getFactory(), keyMetadata);
Populator<P> populator = new ClassPopulator<>(clazz, ctx, path);
return new ClassTranslator<>(clazz, path, creator, populator);
}
/**
*/
public static <P> ClassTranslator<P> createEmbeddedClassTranslator(Class<P> clazz, CreateContext ctx, Path path) {
Creator<P> creator = new EmbeddedCreator<>(clazz, ctx.getFactory());
Populator<P> populator = new ClassPopulator<>(clazz, ctx, path);
return new ClassTranslator<>(clazz, path, creator, populator);
}
/**
* Recursively register this subclass with all the superclass translators. This works because we cache
* translators uniquely in the factory.
*/
private void registerSubclass(ClassTranslator<P> translator, TypeKey<? super P> superclassTypeKey, CreateContext ctx, Path path) {
if (superclassTypeKey.getTypeAsClass() == Object.class)
return;
@SuppressWarnings("unchecked")
ClassTranslator<? super P> superTranslator = create((TypeKey)superclassTypeKey, ctx, path);
superTranslator.registerSubclass(translator);
registerSubclass(translator, new TypeKey<>(superclassTypeKey.getTypeAsClass().getSuperclass()), ctx, path);
}

```
<Overlap Ratio: 0.9963882618510158>

---

--- 360 --
Question ID: eb44049499b37c1511e88709a9ff2342cfd09d46
Original Code:
```
public class JaxrsUserTest extends AbstractJaxrsTest {

	@Before
	public void before() throws Exception {
		super.before();
		
		if (isUseTLS()) {
			
			Path srcdir = Paths.get("src/test/resources/tls-public");
			Path pemPath = srcdir.resolve("tls.pem");
			
			SSLContext sslContext = new SSLContextBuilder()
					.keystorePath(Paths.get("target/keystore-public.jks"))
					.addPem("self-signed-public", pemPath)
					.build();
			
			SSLContext.setDefault(sslContext);
			
			getConfig().setUseTLS(true);
		}
	}
	
	@Test
	public void testUserLifecycle() throws Exception {

		URL resUrl = getClass().getResource("/json/user-register.json");
		
		ObjectMapper mapper = new ObjectMapper();
		UserRegister user = mapper.readValue(resUrl, UserRegister.class);
		Assert.assertEquals("myuser@example.com", user.getEmail());
		
		// User Register
		
		// PUT http://localhost:8200/jaxrs/api/users
		// 
		// {
		//	  "firstName": "My",
		//	  "lastName":  "User", 
		//	  "email":	   "myuser@example.com",
		//	  "username":  "myuser", 
		//	  "password":  "mypass"
		// }
		
		URI uri = jaxrsUri("/api/users");
		Response res = withClient(uri, target -> target.request()
				.put(Entity.json(user)));
		
		assertStatus(res, Status.CREATED, Status.CONFLICT);
		
		// User Login
		
		// POST http://localhost:8200/jaxrs/api/user/token
		// Content-Type: application/x-www-form-urlencoded
		//
		// username: myuser 
		// password: mypass
		
		MultivaluedMap<String, String> data = new MultivaluedHashMap<>();
		data.add("username", user.getUsername());
		data.add("password", user.getPassword());
		
		uri = jaxrsUri("/api/users/login");
		res = withClient(uri, target -> target.request()
				.post(Entity.form(data)));
		
		assertStatus(res, Status.OK);
		
		UserTokens tokens = res.readEntity(UserTokens.class);
		String refreshToken = tokens.refreshToken;
		String userId = tokens.userId;
		
		// User State
		
		// GET http://localhost:8200/jaxrs/api/user/state
		// Authorization: "Bearer eyJhbGciOi..."
		
		KeycloakService kcsrv = getService(KeycloakService.class);
		String accessToken = kcsrv.refreshAccessToken(refreshToken);
		Assert.assertNotNull("Null access token", accessToken);
		
		uri = jaxrsUri("/api/user/" + userId + "/state");
		res = withClient(uri, target -> target.request()
					.header("Authorization", "Bearer " + accessToken)
					.get());
		
		assertStatus(res, Status.OK);
		
		UserState userInfo = res.readEntity(UserState.class);
		Assert.assertEquals("myuser@example.com", userInfo.getEmail());
		
		// User Delete
		
		// DELETE http://localhost:8200/jaxrs/api/user
		// Authorization: "Bearer eyJhbGciOi..."
		
		uri = jaxrsUri("/api/user/" + userId);
		res = withClient(uri, target -> target.request()
					.header("Authorization", "Bearer " + accessToken)
					.delete());
		
		assertStatus(res, Status.NO_CONTENT);
	}

	private boolean isUseTLS() {
		
		boolean useTLS = getConfig().isUseTLS();
		if (useTLS) return true; 
		
		String sysprop = System.getProperty("useTLS");
		if (!useTLS && sysprop != null) {
			useTLS = sysprop.length() > 0 ? Boolean.valueOf(sysprop) : true;
		}
		
		return useTLS;
	}
}
```


Overlapping Code:
```
JaxrsTest {
@Before
public void before() throws Exception {
super.before();

if (isUseTLS()) {

Path srcdir = Paths.get("src/test/resources/tls-public");
Path pemPath = srcdir.resolve("tls.pem");

SSLContext sslContext = new SSLContextBuilder()
.keystorePath(Paths.get("target/keystore-public.jks"))
.addPem("self-signed-public", pemPath)
.build();

SSLContext.setDefault(sslContext);

getConfig().setUseTLS(true);
}
}

@Test
public void testUserLifecycle() throws Exception {
URL resUrl = getClass().getResource("/json/user-register.json");

ObjectMapper mapper = new ObjectMapper();
UserRegister user = mapper.readValue(resUrl, UserRegister.class);er.getEmail());

// User Register

// PUT http://localhost:8200/jaxrs/api/users
// 
// {
// "firstName": "My",
// "lastName"

URI uri = jaxrsUri("/api/users");
Response res = withClient(uri, target -> target.request()
.put(Entity.json(user)));

assertStatus(res, Status.CREATED, Status.CONFLICT);

// User Login

// POST http://localhost:8200/jaxrs/api/user/token
// Content-Type: application/x-www-form-urlencoded
//
// username: myuser 
// passedMap<String, String> data = new MultivaluedHashMap<>();
data.add("username", user.getUsername());
data.add("password", user.getPassword());

uri = jaxrsUri("/api/users/login");
res = withClient(uri, target -> target.request()
.post(Entity.form(data)));

assertStatus(res, Status.OK);

UserTokens tokens = res.readEntity(UserTokens.class);
String refreshToken = tokens.refreshToken;
String userId = tokens.userId;

// User State

// GET http://localhost:8200/jaxrs/api/user/state
// Authorization: "Bearer eyJhbGciOi..."

KeycloakService kcsrv = getService(KeycloakService.class);
String accessToken = kcsrv.refreshAccessToken(refreshToken);
Assert.assertNotNull("Null access token", accessToken);

uri = jaxrsUri("/api/user/" + userId + "/state");
res = withClient(uri, target -> target.request()
.header("Authorization", "Bearer " + accessToken)
.get());

assertStatus(res, Status.OK);

UserState userInfo = res.readEntity(UserState.class);
Assert.a
```
<Overlap Ratio: 0.895059029296021>

---

--- 361 --
Question ID: 6a005427a48ce243e3fa1ae1f58c1005dde59421
Original Code:
```
public class SvnKitUpgradeClient extends BaseSvnClient implements UpgradeClient {

  @Override
  public void upgrade(@NotNull File path, @NotNull WorkingCopyFormat format, @Nullable ProgressTracker handler) throws VcsException {
    validateFormat(format, getSupportedFormats());

    SVNWCClient client = myVcs.getSvnKitManager().createUpgradeClient();

    client.setEventHandler(toEventHandler(handler));
    try {
      cleanupIfNecessary(path, format, client, handler);
      upgrade(path, format, client, handler);
    }
    catch (SVNException e) {
      throw new SvnBindException(e);
    }
  }

  @Override
  public List<WorkingCopyFormat> getSupportedFormats() throws VcsException {
    return SvnKitCheckoutClient.SUPPORTED_FORMATS;
  }

  private static void cleanupIfNecessary(@NotNull File path,
                                         @NotNull WorkingCopyFormat format,
                                         @NotNull SVNWCClient client,
                                         @Nullable ProgressTracker handler) throws SVNException, VcsException {
    // cleanup is executed only for SVNKit as it could handle both 1.6 and 1.7 formats
    if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(format)) {
      // fake event indicating cleanup start
      callHandler(handler, createEvent(path, EventAction.UPDATE_STARTED));
      client.doCleanup(path);
    }
  }

  private static void upgrade(@NotNull File path,
                              @NotNull WorkingCopyFormat format,
                              @NotNull SVNWCClient client,
                              @Nullable ProgressTracker handler) throws SVNException, VcsException {
    // fake event indicating upgrade start
    callHandler(handler, createEvent(path, EventAction.UPDATE_COMPLETED));
    client.doSetWCFormat(path, format.getFormat());
  }
}
```


Overlapping Code:
```
lic class SvnKitUpgradeClient extends BaseSvnClient implements UpgradeClient {
@Override
public void upgrade(@NotNull File path, @NotNull WorkingCopyFormat format, @Nullable ProgressTracker handler) throws VcsException {
validateFormat(format, getSupportedFormats());
SVNWCClient client = myVcs.getSvnKitManager().createUpgradeClient();
client.setEventHandler(toEventHandler(handler));
try {
cleanupIfNecessary(path, format, client, handler);
upgrade(path, format, client, handler);
}
catch (SVNException e) {
throw new SvnBindException(e);
}
}
@Override
public List<WorkingCopyFormat> getSupportedFormats() throws VcsException {
return SvnKitCheckoutClient.SUPPORTED_FORMATS;
}
private static void cleanupIfNecessary(@NotNull File path,
@NotNull WorkingCopyFormat format,
@NotNull SVNWCClient client,
@Nullable ProgressTracker handler) throws SVNException, VcsException {
// cleanup is executed only for SVNKit as it could handle both 1.6 and 1.7 formats
if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(format)) {
// fake event indicating cleanup start
callHandler(handler, createEvent(path, EventAction.UPDATE_STARTED));
client.doCleanup(path);
}
}
private static void upgrade(@NotNull File path,
@NotNull WorkingCopyFormat format,
@NotNull SVNWCClient client,
@Nullable ProgressTracker handler) throws SVNException, VcsException {
// fake event indicating upgrade start
callHandler(handler, createEvent(path, EventAction.UPDATE_COMPLETED));
client.doSe
```
<Overlap Ratio: 0.971198928332217>

---

--- 362 --
Question ID: 64f987239e854877551ba53d4c5929dcd3af5657
Original Code:
```
@RunWith(JUnit4.class)
@SmallTest
public class LoaderObserverTest {

    @Test
    public void testOnChanged() {
        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
        @SuppressWarnings("unchecked")
        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
                mock(Loader.class), callback);
        assertFalse("LoaderObserver should not have delivered data before onChanged",
                observer.hasDeliveredData());
        assertFalse("onLoadFinished should not be called before onChanged",
                callback.mOnLoadFinished);


        observer.onChanged(true);
        assertTrue("LoaderObserver should have delivered data after onChanged",
                observer.hasDeliveredData());
        assertTrue("onLoadFinished should be called after onChanged",
                callback.mOnLoadFinished);
    }

    @Test
    public void testReset() {
        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
        @SuppressWarnings("unchecked")
        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
                mock(Loader.class), callback);
        assertFalse("onLoaderReset shouldn't be called before onChanged+reset",
                callback.mOnLoaderReset);

        observer.reset();
        assertFalse("onLoaderReset should not be called after only reset",
                callback.mOnLoaderReset);
    }

    @Test
    public void testResetWithOnChanged() {
        ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
        @SuppressWarnings("unchecked")
        LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
                mock(Loader.class), callback);
        assertFalse("onLoaderReset shouldn't be called before onChanged+reset",
                callback.mOnLoaderReset);

        observer.onChanged(true);
        observer.reset();
        assertTrue("onLoaderReset should be called after onChanged+reset",
                callback.mOnLoaderReset);
    }
}
```


Overlapping Code:
```
SmallTest
public class LoaderObserverTest {
@Test
public void testOnChanged() {
ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
@SuppressWarnings("unchecked")
LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
mock(Loader.class), callback);
assertFalse("LoaderObserver should not have delivered data before onChanged",
observer.hasDeliveredData());
assertFalse("onLoadFinished should not be called before onChanged",
callback.mOnLoadFinished);
observer.onChanged(true);
assertTrue("LoaderObserver should have delivered data after onChanged",
observer.hasDeliveredData());
assertTrue("onLoadFinished should be called after onChanged",
callback.mOnLoadFinished);
}
@Test
public void testReset() {
ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
@SuppressWarnings("unchecked")
LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
mock(Loader.class), callback);
assertFalse("onLoaderReset shouldn't be called before onChanged+reset",
callback.mOnLoaderReset);
observer.reset();
assertFalse("onLoaderReset should not be called after only reset",
callback.mOnLoaderReset);
}
@Test
public void testResetWithOnChanged() {
ImmediateLoaderCallbacks callback = new ImmediateLoaderCallbacks(mock(Context.class));
@SuppressWarnings("unchecked")
LoaderManagerImpl.LoaderObserver<Boolean> observer = new LoaderManagerImpl.LoaderObserver<>(
mock(Loader.class), callback);
assertFalse("onLoaderReset shouldn't be called before onChanged+reset",
callback.mOnLoaderReset);
observer.onChanged(true);
observer.reset();
assertTrue("onLoaderReset should be called after onChanged+reset",
callback.mOnLoaderReset);
```
<Overlap Ratio: 0.984251968503937>

---

--- 363 --
Question ID: 754c82af254148b524468c9b7604e020fa21c2c7
Original Code:
```
public class RestCountriesJacksonTest {

    /**
     * This test uses Jackson for inspecting the JSON returned
     * by REST services.
     *
     * @throws java.io.IOException
     */
    @Test
    public void getCapitalHappyPath() throws java.io.IOException {
        ObjectMapper mapper = new ObjectMapper();

        // Get info about european country.
        Response response = get("http://restcountries.eu/rest/v1/name/switzerland");
        JsonNode countryInfo = mapper.readTree(response.asInputStream()).get(0);

        // Confirm value of capital.
        JsonNode capital = countryInfo.get("capital");
        String capitalAsText = capital.textValue();
        assertEquals("Bern", capitalAsText);

        // Confirm French name for country.
        assertEquals("Suisse", countryInfo.path("translations").path("fr").asText());

        // 'path' avoids NullPointerException when item is missing
        assertEquals("", countryInfo.path("anUnknownPropertyZ").path("fr").asText());

        // or 'get' will throw NullPointerException
        assertEquals("Suisse", countryInfo.get("translations").get("fr").textValue());
        try {
            countryInfo.get("anUnknownPropertyZ").get("fr").textValue();
            fail("Expected NullPointerException to be thrown in middle of chain.");
        } catch (NullPointerException npex) {
            // Expected NullPointerException due to get("anUnknownPropertyZ").
        }

        // Confirm population.
        assertTrue("Expected population > 8M.", 8000000 < countryInfo.get("population").asInt());

        // 'path' avoids NullPointerException.
        assertEquals(0, countryInfo.path("anUnknownPropertyZ").asInt());

        // Confirm measure of income distribution of a nation's residents.
        assertTrue("Expected Gini coefficient > 30", 30.0d < countryInfo.get("gini").asDouble());

        // 'path' avoids NullPointerException.
        assertEquals(0.0d, countryInfo.path("anUnknownPropertyZ").asDouble(), 0.001d);

    }

}
```


Overlapping Code:
```
ss RestCountriesJacksonTest {
/**
* This test uses Jackson for inspecting the JSON returned
* by REST services.
*
* @throws java.io.IOException
*/
@Test
public void getCapitalHappyPath() throws java.io.IOException {
ObjectMapper mapper = new ObjectMapper();
// Get info about european country.
Response response = get("http://restcountries.eu/rest/v1/name/switzerland");
JsonNode countryInfo = mapper.readTree(response.asInputStream()).get(0);
// Confirm value of capital.
JsonNode capital = countryInfo.get("capital");
String capitalAsText = capital.textValue();
assertEquals("Bern", capitalAsText);
// Confirm French name for country.
assertEquals("Suisse", countryInfo.path("translations").path("fr").asText());
// 'path' avoids NullPointerException when item is missing
assertEquals("", countryInfo.path("anUnknownPropertyZ").path("fr").asText());
// or 'get' will throw NullPointerException
assertEquals("Suisse", countryInfo.get("translations").get("fr").textValue());
try {
countryInfo.get("anUnknownPropertyZ").get("fr").textValue();
fail("Expected NullPointerException to be thrown in middle of chain.");
} catch (NullPointerException npex) {
// Expected NullPointerException due to get("anUnknownPropertyZ").
}
// Confirm population.
assertTrue("Expected population > 8M.", 8000000 < countryInfo.get("population").asInt());
// 'path' avoids NullPointerException.
assertEquals(0, countryInfo.path("anUnknownPropertyZ").asInt());
// Confirm measure of income distribution of a nation's residents.
assertTrue("Expected Gini coefficient > 30", 30.0d < countryInfo.get("gini").asDouble());
// 'path' avoids NullPointerException.
assertEquals(0.0d, countryInfo.path("anUnknownPropertyZ").asDouble
```
<Overlap Ratio: 0.984936268829664>

---

--- 364 --
Question ID: 320befaa222b43e1ef85c42ad5f22ef93ab2a7c8
Original Code:
```
public final class ExpressionAliases
{
    private final Multimap<String, Expression> map;

    public ExpressionAliases()
    {
        this.map = ArrayListMultimap.create();
    }

    public ExpressionAliases(ExpressionAliases expressionAliases)
    {
        requireNonNull(expressionAliases, "symbolAliases are null");
        this.map = ArrayListMultimap.create(expressionAliases.map);
    }

    public void put(String alias, Expression expression)
    {
        alias = alias(alias);
        if (map.containsKey(alias)) {
            checkState(map.get(alias).contains(expression), "Alias '%s' points to different expression '%s' and '%s'", alias, expression, map.get(alias));
        }
        else {
            checkState(!map.values().contains(expression), "Expression '%s' is already pointed by different alias than '%s', check mapping for '%s'", expression, alias, map);
            map.put(alias, expression);
        }
    }

    private static String alias(String alias)
    {
        return alias.toLowerCase().replace("(", "").replace(")", "").replace("\"", "");
    }

    public void updateAssignments(Map<Symbol, Expression> assignments)
    {
        ImmutableMultimap.Builder<String, Expression> mapUpdate = ImmutableMultimap.builder();
        for (Map.Entry<Symbol, Expression> assignment : assignments.entrySet()) {
            for (String alias : map.keys()) {
                if (map.get(alias).contains(assignment.getKey().toSymbolReference())) {
                    mapUpdate.put(alias, assignment.getValue());
                }
            }
        }
        map.putAll(mapUpdate.build());
    }
}
```


Overlapping Code:
```
onAliases
{
private final Multimap<String, Expression> map;
public ExpressionAliases()
{
this.map = ArrayListMultimap.create();
}
public ExpressionAliases(ExpressionAliases expressionAliases)
{
requireNonNull(expressionAliases, "symbolAliases are null");
this.map = ArrayListMultimap.create(expressionAliases.map);
}
public void put(String alias, Expression expression)
{
alias = alias(alias);
if (map.containsKey(alias)) {
checkState(map.get(alias).contains(expression), "Alias '%s' points to different expression '%s' and '%s'", alias, expression, map.get(alias));
}
else {
checkState(!map.values().contains(expression), "Expression '%s' is already pointed by different alias than '%s', check mapping for '%s'", expression, alias, map);
map.put(alias, expression);
}
}
private static String alias(String alias)
{
return alias.toLowerCase().replace("(", "").replace(")", "").replace("\"", "");
}
public void updateAssignments(Map<Symbol, Expression> assignments)
{
ImmutableMultimap.Builder<String, Expression> mapUpdate = ImmutableMultimap.builder();
for (Map.Entry<Symbol, Expression> assignment : assignments.entrySet()) {
for (String alias : map.keys()) {
if (map.get(alias).contains(assignment.getKey().toSymbolReference())) {
mapUpdate.put(alias, assignment.getValue());
}
}
}
map.putAll(mapUp
```
<Overlap Ratio: 0.966542750929368>

---

--- 365 --
Question ID: 6ecd3c9cf1c74b3510dfb62b8964bb14543fe450
Original Code:
```
class CallOrRunMV extends LocalVariablesSorter implements Opcodes {
	private static final String TARGET = TraceMain.class.getName().replace('.', '/');
	private static final String START_METHOD = "callRunnableCallInvoked";
	private static final String START_SIGNATURE = "(Ljava/lang/Object;)Ljava/lang/Object;";

	private static final String END_METHOD = "callRunnableCallEnd";
	private static final String END_METHOD_DESC = "(" +
			"Ljava/lang/Object;" +
			"Ljava/lang/Object;" +
			"Ljava/lang/Throwable;" +
			")V";

	private Label startFinally = new Label();
	private Type returnType;
	String name;
	String desc;
	private int statIdx;

	public CallOrRunMV(int access, String name, String desc, MethodVisitor mv) {
		super(ASM5, access, desc, mv);
		this.name = name;
		this.desc = desc;
		this.returnType = Type.getReturnType(desc);
	}

	@Override
	public void visitCode() {
		mv.visitVarInsn(Opcodes.ALOAD, 0);
		mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, START_METHOD, START_SIGNATURE, false);

		statIdx = newLocal(Type.getType(Object.class));
		mv.visitVarInsn(Opcodes.ASTORE, statIdx);
		mv.visitLabel(startFinally);
		mv.visitCode();
	}

	@Override
	public void visitInsn(int opcode) {
		if ((opcode >= IRETURN && opcode <= RETURN)) {
			capReturn();
		}
		mv.visitInsn(opcode);
	}

	private void capReturn() {
		Type tp = returnType;

		if (tp == null || tp.equals(Type.VOID_TYPE)) {
			mv.visitInsn(Opcodes.ACONST_NULL);
			mv.visitVarInsn(Opcodes.ALOAD, statIdx);
			mv.visitInsn(Opcodes.ACONST_NULL);
			mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);
			return;
		}

		switch (tp.getSort()) {
			case Type.DOUBLE:
			case Type.LONG:
				mv.visitInsn(Opcodes.DUP2);
				break;
			default:
				mv.visitInsn(Opcodes.DUP);
		}
		// TODO method return test dup and store
//		int rtnIdx = newLocal(tp);
//		mv.visitVarInsn(Opcodes.ASTORE, rtnIdx);
//		mv.visitVarInsn(Opcodes.ALOAD, rtnIdx);

		mv.visitVarInsn(Opcodes.ALOAD, statIdx);// stat
		mv.visitInsn(Opcodes.ACONST_NULL);// throwable
		mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);
	}

	@Override
	public void visitMaxs(int maxStack, int maxLocals) {
		Label endFinally = new Label();
		mv.visitTryCatchBlock(startFinally, endFinally, endFinally, null);
		mv.visitLabel(endFinally);
		mv.visitInsn(DUP);
		int errIdx = newLocal(Type.getType(Throwable.class));
		mv.visitVarInsn(Opcodes.ASTORE, errIdx);

		mv.visitInsn(Opcodes.ACONST_NULL);// return
		mv.visitVarInsn(Opcodes.ALOAD, statIdx);
		mv.visitVarInsn(Opcodes.ALOAD, errIdx);
		mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC,false);
		mv.visitInsn(ATHROW);
		mv.visitMaxs(maxStack + 8, maxLocals + 2);
	}
}
```


Overlapping Code:
```
MV extends LocalVariablesSorter implements Opcodes {
private static final String TARGET = TraceMain.class.getName().replace('.', '/');
private static final String START_METHOD = "callRunnableCallInvoked";
private static final String START_SIGNATURE = "(Ljava/lang/Object;)Ljava/lang/Object;";
private static final String END_METHOD = "callRunnableCallEnd";
private static final String END_METHOD_DESC = "(" +
"Ljava/lang/Object;" +
"Ljava/lang/Object;" +
"Ljava/lang/Throwable;" +
")V";
private Label startFinally = new Label();
private Type returnType;
String name;
String desc;
private int statIdx;
public CallOrRunMV(int access, String name, String desc, MethodVisitor mv) {
super(ASM5, access, desc, mv);
this.name = name;
this.desc = desc;
this.returnType = Type.getReturnType(desc);
}
@Override
public void visitCode() {
mv.visitVarInsn(Opcodes.ALOAD, 0);
mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, START_METHOD, START_SIGNATURE, false);
statIdx = newLocal(Type.getType(Object.class));
mv.visitVarInsn(Opcodes.ASTORE, statIdx);
mv.visitLabel(startFinally);
mv.visitCode();
}
@Override
public void visitInsn(int opcode) {
if ((opcode >= IRETURN && opcode <= RETURN)) {
capReturn();
}
mv.visitInsn(opcode);
}
private void capReturn() {
Type tp = returnType;
if (tp == null || tp.equals(Type.VOID_TYPE)) {
mv.visitInsn(Opcodes.ACONST_NULL);
mv.visitVarInsn(Opcodes.ALOAD, statIdx);
mv.visitInsn(Opcodes.ACONST_NULL);
mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);
return;
}
switch (tp.getSort()) {
case Type.DOUBLE:
case Type.LONG:
mv.visitInsn(Opcodes.DUP2);
break;
default:
mv.visitInsn(Opcodes.DUP);
}
// TODO method return test dup and store
// int rtnIdx = newLocal(tp);
// mv.visitVarInsn(Opcodes.ASTORE, rtnIdx);
// mv.visitVarInsn(Opcodes.ALOAD, rtnIdx);
mv.visitVarInsn(Opcodes.ALOAD, statIdx);// stat
mv.visitInsn(Opcodes.ACONST_NULL);// throwable
mv.visitMethodInsn(Opcodes.INVOKESTATIC, TARGET, END_METHOD, END_METHOD_DESC, false);
}
@Override
public void visitMaxs(int maxStack, int maxLocals) {
Label endFinally = new Label();
mv.visitTryCatchBlock(startFinally, endFinally, endFinally, null);
mv.visitLabel(endFinally);
mv.visitInsn(DUP);
int errIdx = newLocal(Type.getType(Throwable.class));
mv.visitVarInsn(Opcodes.ASTORE, errIdx);
mv.visitInsn(Opcodes.ACONST_
```
<Overlap Ratio: 0.9881002974925627>

---

--- 366 --
Question ID: ca6718a336d4b3b5c422d113ce1b8f56b8a3ab55
Original Code:
```
public class SBTabDocument<T> implements TreeNodeChangeListener {

	private static final transient Logger LOGGER = LogManager.getLogger(SBTabController.class);

	private T tempDoc;

	private File tempDocFile;

	boolean changed;

	/**
	 * Constructor for Document
	 *
	 * @param T doc
	 * 
	 * @param File file
	 */
	public SBTabDocument(T doc,File file) {
		try {
			tempDoc = doc;
			tempDocFile = file;

			if (tempDoc instanceof AbstractTreeNode) {
				((AbstractTreeNode) tempDoc).addTreeNodeChangeListener(this);
			}			
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		changed = false;
	}


	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		System.out.println("change");
		changed = true;
	}

	@Override
	public void nodeAdded(TreeNode node) {
		System.out.println("new entry");
		changed = true;
	}

	@Override
	public void nodeRemoved(TreeNodeRemovedEvent event) {
		TreeNode parent = event.getPreviousParent();
		System.out.println("Child of " + parent.toString() + " removed");
		changed = true;
	}
	
	public void setTempDoc(T doc) {
		tempDoc=doc;
	}
	
	public T getTempDoc() {
		return tempDoc;
	}
	
	public void setFile(File file) {
		tempDocFile=file;
	}
	
	/**
	 * 
	 * @return temporary File or null
	 */
	public File getFile() {
		if (tempDocFile!=null) {
		return tempDocFile;
		}
		else return null;
	}
	
	/**
	 * if document has unsaved changes, returns true 
	 * 
	 * @return boolean changed
	 */
	public boolean getChanged() {
		return changed;
	}
	
	/**
	 * 
	 * @param bool 
	 */
	public void setChanged(boolean bool) {
		changed=bool;
	}
}
```


Overlapping Code:
```
lic class SBTabDocument<T> implements TreeNodeChangeListener {
private static final transient Logger LOGGER = LogManager.getLogger(SBTabController.class);
private T tempDoc;
private File tempDocFile;
boolean changed;
/**
* Constructor for Document
*
* @param T doc
* 
* @param File file
*/
public SBTabDocument(T doc,File file) {
try {
tempDoc = doc;
tempDocFile = file;
if (tempDoc instanceof AbstractTreeNode) {
((AbstractTreeNode) tempDoc).addTreeNodeChangeListener(this);
} 
} catch (Exception e) {
e.printStackTrace();
}

changed = false;
}
@Override
public void propertyChange(PropertyChangeEvent evt) {
System.out.println("change");
changed = true;
}
@Override
public void nodeAdded(TreeNode node) {
System.out.println("new entry");
changed = true;
}
@Override
public void nodeRemoved(TreeNodeRemovedEvent event) {
TreeNode parent = event.getPreviousParent();
System.out.println("Child of " + parent.toString() + " removed");
changed = true;
}

public void setTempDoc(T doc) {
tempDoc=doc;
}

public T getTempDoc() {
return tempDoc;
}

public void setFile(File file) {
tempDocFile=file;
}

/**
* 
* @return temporary File or null
*/
public File getFile() {
if (tempDocFile!=null) {
return tempDocFile;
}
else return null;
}

/**
* if document has unsaved changes, returns true 
* 
* @return boolean changed
*/
public boolean getChanged() {
return changed;
}

/**
* 
* @param bool 
*/
public vo
```
<Overlap Ratio: 0.9655172413793104>

---

--- 367 --
Question ID: 675424e98a94049e43ed956c9af8c05a476937dd
Original Code:
```
@WebServlet(name = "Histogram", value = "/histogram")
public class Histogram extends HttpServlet {
  @Override
  public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Get this user's session.
    HttpSession session = request.getSession();

    // Will hold the size bounds for the histogram.
    long lowerBound;
    long upperBound;

    // Check whether the reset button was clicked or not.
    String resetButton = request.getParameter("reset-bounds-btn");
    if (resetButton != null) {
      // Reset was clicked, so set the bounds to be the extrema of the sizes, so the user can see
      // the entire range of sizes.
      lowerBound = (long) session.getAttribute("minBound");
      upperBound = (long) session.getAttribute("maxBound");

      // Reset the field that searches for a specific string in a pathname.
      session.setAttribute("name", "");
    } else {
      // Get user-chosen numbers from form in interactive-histogram.html.
      String lower = request.getParameter("lower-bound");
      String upper = request.getParameter("upper-bound");

      // Parse the bound from user input and set the bounds to the chosen bounds.
      lowerBound = parseBound(lower);
      upperBound = parseBound(upper);

      // Check the name field to see if a specific string in a pathname was searched for, and if so
      // add it to the session.
      String name = request.getParameter("path-filter");
      if (name != null) {
        session.setAttribute("name", name);
      }
    }

    // Set the session's histogram bounds to the new bounds.
    session.setAttribute("lowerBound", lowerBound);
    session.setAttribute("upperBound", upperBound);

    // Set the postFired option to be true since the user has done at least one post.
    session.setAttribute("postFired", true);

    // Reload the interactive-histogram.html.
    response.sendRedirect("/interactive-histogram.html");
  }

  @Override
  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
    // Response will be a Json.
    response.setContentType("application/json");

    // Get this user's session.
    HttpSession session = request.getSession();

    // Check whether doPost has been fired for the first time yet.
    boolean postFired = (boolean) session.getAttribute("postFired");

    // Will hold the size bounds for the histogram.
    long lowerBound;
    long upperBound;

    // Will hold the pathname from path filter.
    String name;

    // If the user hasn't entered custom bounds yet, use the initial min and max from regions list,
    // otherwise use the ones that were submitted previously and set to the session. If the user
    // hasn't chosen a specific name in the pathname to filter, just make it an empty string,
    // otherwise get it from the session.
    if (!postFired) {
      lowerBound = (long) session.getAttribute("minBound");
      upperBound = (long) session.getAttribute("maxBound");
      name = "";

      // Set the new variables to the session.
      session.setAttribute("lowerBound", lowerBound);
      session.setAttribute("upperBound", upperBound);
      session.setAttribute("name", "");
    } else {
      lowerBound = (long) session.getAttribute("lowerBound");
      upperBound = (long) session.getAttribute("upperBound");
      name = (String) session.getAttribute("name");
    }

    // Get the region list from the session, which was set when the file was uploaded.
    List<Region> regionList = (List<Region>) session.getAttribute("regionList");

    // Parse histogram data.
    List<Object[]> histogramData = makeDataArray(regionList, name);

    // Construct 2D array to hold the bounds.
    long[] bounds = {lowerBound, upperBound};

    // Transfer the arrays into JavaScript Objects (Json).
    Gson boundsGson = new Gson();
    Gson nameGson = new Gson();
    Gson histGson = new Gson();
    String boundsJson = boundsGson.toJson(bounds);
    String nameJson = nameGson.toJson(name);
    String histogramDataJson = histGson.toJson(histogramData);

    // Put the two Json strings into a list to send to histogram.js.
    List<String> jsonList = new ArrayList<String>();
    jsonList.add(boundsJson);
    jsonList.add(nameJson);
    jsonList.add(histogramDataJson);

    // Write Json to histogram.js
    response.getWriter().println(jsonList);
  }

  /**
   * Returns the input from the forms in interactive-histogram.html parsed as a long. The bound
   * input forms in interactive-histogram.html only allow positive integers, but accept numbers with
   * .0, so in that case drop the decimal when parsing.
   */
  public long parseBound(String bound) {
    if (bound.contains(".")) {
      return (long) Double.parseDouble(bound);
    }
    return Long.parseLong(bound);
  }

  /** Creates list of 2D Object arrays of data for histogram. */
  static ArrayList<Object[]> makeDataArray(List<Region> regions, String name) {
    // List must contain both Strings and numbers, so must be of type Object.
    ArrayList<Object[]> dataArray = new ArrayList<Object[]>();

    // First pair in list must define the format of the data.
    Object[] labelPair = {"Range", "Size"};
    dataArray.add(labelPair);

    // Add an array to init the data, but make range null and the size -1 so that it won't show up
    // in the actual chart.
    Object[] initPair = {null, -1};
    dataArray.add(initPair);

    // Go through the regions and add range/size pairs to the list, and check that it contains in
    // its pathname the specific name that was searched for (if no name was searched, it will just
    // be an empty string).
    for (int i = 0; i < regions.size(); i++) {
      Region curR = regions.get(i);
      if (curR.pathname().contains(name)) {
        String range = curR.startLoc() + " - " + curR.endLoc();
        Object val = (Object) curR.size();
        Object[] pair = {range, val};
        dataArray.add(pair);
      }
    }
    return dataArray;
  }
}
```


Overlapping Code:
```
ebServlet(name = "Histogram", value = "/histogram")
public class Histogram extends HttpServlet {
@Override
public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
// Get this user's session.
HttpSession session = request.getSession();
// Will hold the size bounds for the histogram.
long lowerBound;
long upperBound;
// Check whether the reset button was clicked or not.
String resetButton = request.getParameter("reset-bounds-btn");
if (resetButton != null) {
// Reset was clicked, so set the bounds to be the extrema of the sizes, so the user can see
// the entire range of sizes.
lowerBound = (long) session.getAttribute("minBound");
upperBound = (long) session.getAttribute("maxBound");
// Reset the field that searches for a specific string in a pathname.
session.setAttribute("name", "");
} else {
// Get user-chosen numbers from form in interactive-histogram.html.
String lower = request.getParameter("lower-bound");
String upper = request.getParameter("upper-bound");
// Parse the bound from user input and set the bounds to the chosen bounds.
lowerBound = parseBound(lower);
upperBound = parseBound(upper);
// Check the name field to see if a specific string in a pathname was searched for, and if so
// add it to the session.
String name = request.getParameter("path-filter");
if (name != null) {
session.setAttribute("name", name);
}
}
// Set the session's histogram bounds to the new bounds.
session.setAttribute("lowerBound", lowerBound);
session.setAttribute("upperBound", upperBound);
// Set the postFired option to be true since the user has done at least one post.
session.setAttribute("postFired", true);
// Reload the interactive-histogram.html.
response.sendRedirect("/interactive-histogram.html");
}
@Override
public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
// Response will be a Json.
response.setContentType("application/json");
// Get this user's session.
HttpSession session = request.getSession();
// Check whether doPost has been fired for the first time yet.
boolean postFired = (boolean) session.getAttribute("postFired");
// Will hold the size bounds for the histogram.
long lowerBound;
long upperBound;
// Will ho
```
<Overlap Ratio: 0.9902525476295968>

---

--- 368 --
Question ID: 5d823e0dc1a0d5be1d5e8e16b8f449191a205c3e
Original Code:
```
public class XGBoostJavaVariableImportance implements XGBoostVariableImportance {
    
    private final String[] _featureNames;
    
    public XGBoostJavaVariableImportance(XGBoostModelInfo modelInfo) {
        _featureNames = XGBoostUtils.assembleFeatureNames(modelInfo.dataInfo())._names;
    }

    @Override
    public Map<String, FeatureScore> getFeatureScores(byte[] boosterBytes) {
        Predictor predictor = PredictorFactory.makePredictor(boosterBytes, false);
        Map<String, FeatureScore> featureScore = new HashMap<>();
        if (!(predictor.getBooster() instanceof GBTree)) {
            return featureScore;
        }
        GBTree gbm = (GBTree) predictor.getBooster();
        final RegTree[][] trees = gbm.getGroupedTrees();
        for (final RegTree[] treeGroup : trees) {
            for (int j = 0; j < treeGroup.length; j++) {
                RegTree t = treeGroup[j];
                for (int k = 0; k < t.getNodes().length; k++) {
                    RegTreeNode node = t.getNodes()[k];
                    if (node.isLeaf()) continue;
                    RegTreeNodeStat stat = t.getStats()[k];
                    FeatureScore fs = new FeatureScore();
                    fs._gain = stat.getGain();
                    fs._cover = stat.getCover();
                    final String fid = _featureNames[node.getSplitIndex()];
                    if (featureScore.containsKey(fid)) {
                        featureScore.get(fid).add(fs);
                    } else {
                        featureScore.put(fid, fs);
                    }
                }
            }
        }
        return featureScore;
    }

}
```


Overlapping Code:
```
blic class XGBoostJavaVariableImportance implements XGBoostVariableImportance {

private final String[] _featureNames;

public XGBoostJavaVariableImportance(XGBoostModelInfo modelInfo) {
_featureNames = XGBoostUtils.assembleFeatureNames(modelInfo.dataInfo())._names;
}
@Override
public Map<String, FeatureScore> getFeatureScores(byte[] boosterBytes) {
Predictor predictor = PredictorFactory.makePredictor(boosterBytes, false);
Map<String, FeatureScore> featureScore = new HashMap<>();
if (!(predictor.getBooster() instanceof GBTree)) {
return featureScore;
}
GBTree gbm = (GBTree) predictor.getBooster();
final RegTree[][] trees = gbm.getGroupedTrees();
for (final RegTree[] treeGroup : trees) {
for (int j = 0; j < treeGroup.length; j++) {
RegTree t = treeGroup[j];
for (int k = 0; k < t.getNodes().length; k++) {
RegTreeNode node = t.getNodes()[k];
if (node.isLeaf()) continue;
RegTreeNodeStat stat = t.getStats()[k];
FeatureScore fs = new FeatureScore();
fs._gain = stat.getGain();
fs._cover = stat.getCover();
final String fid = _featureNames[node.getSplitIndex()];
if (featureScore.containsKey(fid)) {
featureScore.get(fid).add(fs);
} else {
featureScore.put(fid, fs);
}
}
}
}
```
<Overlap Ratio: 0.9776490066225165>

---

--- 369 --
Question ID: 1a3775db1532636ad54df958791a96df6592e03b
Original Code:
```
public class WebBook extends AppCompatActivity {

    private String URI;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.web_view);
        WebView webView = (WebView) findViewById(R.id.view_web);
        webView.getSettings().setJavaScriptEnabled(true);
        webView.setWebViewClient(new WebViewClient());
        Intent intent = getIntent();
        String name = intent.getStringExtra("name");
        URI = "https://www.amazon.cn/s/ref=nb_sb_ss_i_2_9/461-5115720-8747102?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&url=search-alias%3Daps&field-keywords=%E6%B5%B7%E6%B0%B4%E9%B1%BC%E5%9B%BE%E9%89%B4&sprefix="
                + name + "%2Caps%2C148&crid=115Y6JWK1RSDX\n";
        webView.loadUrl(URI);

    }
}
```


Overlapping Code:
```
ity {
private String URI;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.web_view);
WebView webView = (WebView) findViewById(R.id.view_web);
webView.getSettings().setJavaScriptEnabled(true);
webView.setWebViewClient(new WebViewClient());
Intent intent = getIntent();
String name = intent.getStringExtra("name");
URI = "https://www.amazon.cn/s/ref=nb_sb_ss_i_2_9/461-5115720-8747102?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&url=search-alias%3Daps&field-keywords=%E6%B5%B7%E6%B0%B4%E9%B1%BC%E5%9B%BE%E9%89%B4&sprefix="
+ name + "%2Caps%2C148&crid=115Y6JWK1RSDX
```
<Overlap Ratio: 0.8990318118948825>

---

--- 370 --
Question ID: 56d0ea3a37b86c8af344ad03a46204cd51be8247
Original Code:
```
public class MessageListItem extends RelativeLayout{

	private ImageView mBadgeImageView;
	
	public MessageListItem(Context context, AttributeSet attributeSet, int defStyle) {
		super(context, attributeSet, defStyle);
	}
	
	public MessageListItem(Context context, Notification notification) {
		super(context);
		initLayout(notification);
	}
	
	private void initLayout(Notification notification) {
		View v = View.inflate(getContext(), R.layout.message_list_item, this);
	    mBadgeImageView = (ImageView)v.findViewById(R.id.message_list_item_batch);
	    enableBatch(false);
	}
	
	public void enableBatch(boolean b) {
		mBadgeImageView.setVisibility(b ? View.VISIBLE:View.GONE);
	}

}
```


Overlapping Code:
```
geListItem extends RelativeLayout{
private ImageView mBadgeImageView;

public MessageListItem(Context context, AttributeSet attributeSet, int defStyle) {
super(context, attributeSet, defStyle);
}

public MessageListItem(Context context, Notification notification) {
super(context);
initLayout(notification);
}

private void initLayout(Notification notification) {
View v = View.inflate(getContext(), R.layout.message_list_item, this);
mBadgeImageView = (ImageView)v.findViewById(R.id.message_list_item_batch);
enableBatch(false);
}

public void enableBatch(boolean b) {
mBadgeImageView.setVisibility(
```
<Overlap Ratio: 0.9230769230769231>

---

--- 371 --
Question ID: d2258fe7d3f1d1320a8294d37c49498bd53afe95
Original Code:
```
class AccountResourceTest extends ServletTestBase {

    AccountResourceTest() {
        super("/ukelonn", "/api");
    }

    @Test
    void testGetAccount() throws Exception {
        // Create the request and response for the Shiro login
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        HttpServletResponse response = mock(HttpServletResponse.class);

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Log the user in to shiro
        loginUser(request, response, "jad", "1ad");

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());
        resource.ukelonn = ukelonn;

        // Run the method under test
        Account result = resource.getAccount("jad");

        // Check the result
        assertEquals("jad", result.getUsername());
        assertEquals(673.0, result.getBalance(), 0.0);
    }

    /**
     * Test that verifies that a regular user can't access other users than the
     * one they are logged in as.
     *
     * @throws Exception
     */
    @Test
    void testGetAccountOtherUsername() throws Exception {
        // Create the request and response for the Shiro login
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        HttpServletResponse response = mock(HttpServletResponse.class);

        // Log the user in to shiro
        loginUser(request, response, "jad", "1ad");

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        resource.ukelonn = ukelonn;

        // Run the method under test with a different username
        assertThrows(ForbiddenException.class, () -> {
                resource.getAccount("jod");
            });
    }

    /**
     * Test that verifies that an admin user can access other users than the
     * one they are logged in as.
     *
     * @throws Exception
     */
    @Test
    void testGetAccountWhenLoggedInAsAdministrator() throws Exception {
        // Create the request and response for the Shiro login
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        HttpServletResponse response = mock(HttpServletResponse.class);

        // Log the admin user in to shiro
        loginUser(request, response, "admin", "admin");

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());
        resource.ukelonn = ukelonn;

        // Run the method under test
        Account result = resource.getAccount("jad");

        // Check the response
        assertEquals("jad", result.getUsername());
        assertEquals(673.0, result.getBalance(), 0.0);
    }

    @Test
    void testGetAccountNoUsername() throws Exception {
        // Create the request and response for the Shiro login
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        resource.ukelonn = ukelonn;

        // Run the method under test
        assertThrows(BadRequestException.class, () -> {
                resource.getAccount(null);
            });
    }

    @Test
    void testGetAccountUsernameNotPresentInDatabase() throws Exception {
        // Create the request and response for the Shiro login
        HttpServletRequest request = mock(HttpServletRequest.class);
        HttpSession session = mock(HttpSession.class);
        when(request.getSession()).thenReturn(session);
        HttpServletResponse response = mock(HttpServletResponse.class);

        // Log the admin user in to shiro
        loginUser(request, response, "admin", "admin");

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        when(ukelonn.getAccount(anyString())).thenThrow(UkelonnException.class);
        resource.ukelonn = ukelonn;

        // Run the method under test
        assertThrows(InternalServerErrorException.class, () -> {
                resource.getAccount("on");
            });
    }

    @Test
    void testGetAccountWhenSubjectHasNullPrincipal() {
        createSubjectWithNullPrincipalAndBindItToThread();

        // Create the object to be tested
        AccountResource resource = new AccountResource();

        // Create mock OSGi services to inject and inject it
        MockLogService logservice = new MockLogService();
        resource.setLogservice(logservice);

        // Inject fake OSGi service UkelonnService
        UkelonnService ukelonn = mock(UkelonnService.class);
        resource.ukelonn = ukelonn;

        // Run the method under test
        assertThrows(InternalServerErrorException.class, () -> {
                resource.getAccount("on");
            });
    }
}
```


Overlapping Code:
```
TestBase {
AccountResourceTest() {
super("/ukelonn", "/api");
}
@Test
void testGetAccount() throws Exception {
// Create the request and response for the Shiro login
HttpServletRequest request = mock(HttpServletRequest.class);
HttpSession session = mock(HttpSession.class);
when(request.getSession()).thenReturn(session);
HttpServletResponse response = mock(HttpServletResponse.class);
// Create the object to be tested
AccountResource resource = new AccountResource();
// Log the user in to shiro
loginUser(request, response, "jad", "1ad");
// Create mock OSGi services to inject and inject it
MockLogService logservice = new MockLogService();
resource.setLogservice(logservice);
// Inject fake OSGi service UkelonnService
UkelonnService ukelonn = mock(UkelonnService.class);
when(ukelonn.getAccount(anyString())).thenReturn(getJadAccount());
resource.ukelonn = ukelonn;
// Run the method under test
Account result = resource.getAccount("jad");
// Check the result
assertEquals("jad", result.getUsername());
assertEquals(673.0, result.getBalance(), 0.0);
}
/**
* Test that verifies that a regular user can't access other users than the
* one they are logged in as.
*
* @throws Exception
*/
@Test
void testGetAccountOtherUsername() throws Exception {
// Create the request and response for the Shiro login
HttpServletRequest request = mock(HttpServletRequest.class);
HttpSession session = mock(HttpSession.class);
when(request.getSession()).thenReturn(session);
HttpServletResponse response = mock(HttpServletResponse.class);
// Log the user in to shiro
loginUser(request, response, "jad", "1ad");
// Create the object to be tested
AccountResource resource = new AccountResource();
// Create mock OSGi services to inject and inject it
MockLogService logservice = new MockLogService();
resource.setLogservice(logservice);
// Inject fake OSGi service UkelonnService
UkelonnService ukelonn = mock(UkelonnService.class);
resource.ukelonn = ukelonn;
// Run the method under test with a different username
assertThrows(ForbiddenException.class, () -> {
resource
```
<Overlap Ratio: 0.9785714285714285>

---

--- 372 --
Question ID: 5b9af69ee2a0bce2b0285a267045a60efe1c8b06
Original Code:
```
public class ProfileResultImpl implements ProfileResult {
   private static final Logger LOGGER = LogManager.getLogger();
   private static final ProfileLocationInfo EMPTY_INFO = new ProfileLocationInfo() {
      public long getTotalTime() {
         return 0L;
      }

      public long getVisitCount() {
         return 0L;
      }

      public Object2LongMap<String> getCounts() {
         return Object2LongMaps.emptyMap();
      }
   };
   private static final Splitter SPLITTER = Splitter.on('\u001e');
   private static final Comparator<Entry<String, ProfileResultImpl.CounterInfo>> COMPARATOR = Entry.<String, ProfileResultImpl.CounterInfo>comparingByValue(Comparator.comparingLong((counterInfo) -> counterInfo.totalTime)).reversed();
   private final Map<String, ? extends ProfileLocationInfo> locationInfos;
   private final long startTime;
   private final int startTick;
   private final long endTime;
   private final int endTick;
   private final int tickDuration;

   public ProfileResultImpl(Map<String, ? extends ProfileLocationInfo> locationInfos, long startTime, int startTick, long endTime, int endTick) {
      this.locationInfos = locationInfos;
      this.startTime = startTime;
      this.startTick = startTick;
      this.endTime = endTime;
      this.endTick = endTick;
      this.tickDuration = endTick - startTick;
   }

   private ProfileLocationInfo getInfo(String path) {
      ProfileLocationInfo profileLocationInfo = this.locationInfos.get(path);
      return profileLocationInfo != null ? profileLocationInfo : EMPTY_INFO;
   }

   public List<ProfilerTiming> getTimings(String parentPath) {
      ProfileLocationInfo profileLocationInfo = this.getInfo("root");
      long l = profileLocationInfo.getTotalTime();
      ProfileLocationInfo profileLocationInfo2 = this.getInfo(parentPath);
      long m = profileLocationInfo2.getTotalTime();
      long n = profileLocationInfo2.getVisitCount();
      List<ProfilerTiming> list = Lists.newArrayList();
      if (!parentPath.isEmpty()) {
         parentPath = parentPath + '\u001e';
      }

      long o = 0L;

      for (String string2 : this.locationInfos.keySet()) {
         if (isSubpath(parentPath, string2)) {
            o += this.getInfo(string2).getTotalTime();
         }
      }

      float f = (float)o;
      if (o < m) {
         o = m;
      }

      if (l < o) {
         l = o;
      }

      for (String string3 : this.locationInfos.keySet()) {
         if (isSubpath(parentPath, string3)) {
            ProfileLocationInfo profileLocationInfo3 = this.getInfo(string3);
            long p = profileLocationInfo3.getTotalTime();
            double d = (double) p * 100.0D / (double) o;
            double e = (double) p * 100.0D / (double) l;
            String string4 = string3.substring(parentPath.length());
            list.add(new ProfilerTiming(string4, d, e, profileLocationInfo3.getVisitCount()));
         }
      }

      if ((float)o > f) {
         list.add(new ProfilerTiming("unspecified", (double)((float)o - f) * 100.0D / (double)o, (double)((float)o - f) * 100.0D / (double)l, n));
      }

      Collections.sort(list);
      list.add(0, new ProfilerTiming(parentPath, 100.0D, (double)o * 100.0D / (double)l, n));
      return list;
   }

   private static boolean isSubpath(String parent, String path) {
      return path.length() > parent.length() && path.startsWith(parent) && path.indexOf(30, parent.length() + 1) < 0;
   }

   private Map<String, ProfileResultImpl.CounterInfo> setupCounters() {
      Map<String, ProfileResultImpl.CounterInfo> map = Maps.newTreeMap();
      this.locationInfos.forEach((string, profileLocationInfo) -> {
         Object2LongMap<String> object2LongMap = profileLocationInfo.getCounts();
         if (!object2LongMap.isEmpty()) {
            List<String> list = SPLITTER.splitToList(string);
            object2LongMap.forEach((stringx, long_) -> map.computeIfAbsent(stringx, (string1) -> new CounterInfo()).add(list.iterator(), long_));
         }

      });
      return map;
   }

   public long getStartTime() {
      return this.startTime;
   }

   public int getStartTick() {
      return this.startTick;
   }

   public long getEndTime() {
      return this.endTime;
   }

   public int getEndTick() {
      return this.endTick;
   }

   public boolean save(File file) {
      //noinspection ResultOfMethodCallIgnored
      file.getParentFile().mkdirs();
      OutputStreamWriter writer = null;

      try {
         writer = new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8);
         writer.write(this.asString(this.getTimeSpan(), this.getTickSpan()));
         return true;
      } catch (Throwable var8) {
         LOGGER.error("Could not save profiler results to {}", file, var8);
      } finally {
         IOUtils.closeQuietly(writer);
      }

      return false;
   }

   protected String asString(long timeSpan, int tickSpan) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("---- Minecraft Profiler Results ----\n");
      stringBuilder.append("// ");
      stringBuilder.append(generateWittyComment());
      stringBuilder.append("\n\n");
      stringBuilder.append("Version: ").append(ModID.MINECRAFT.getVersion()).append('\n');
      stringBuilder.append("Time span: ").append(timeSpan / 1000000L).append(" ms\n");
      stringBuilder.append("Tick span: ").append(tickSpan).append(" ticks\n");
      stringBuilder.append("// This is approximately ").append(String.format(Locale.ROOT, "%.2f", (float)tickSpan / ((float)timeSpan / 1.0E9F))).append(" ticks per second. It should be ").append(20).append(" ticks per second\n\n");
      stringBuilder.append("--- BEGIN PROFILE DUMP ---\n\n");
      this.appendTiming(0, "root", stringBuilder);
      stringBuilder.append("--- END PROFILE DUMP ---\n\n");
      Map<String, ProfileResultImpl.CounterInfo> map = this.setupCounters();
      if (!map.isEmpty()) {
         stringBuilder.append("--- BEGIN COUNTER DUMP ---\n\n");
         this.appendCounterDump(map, stringBuilder, tickSpan);
         stringBuilder.append("--- END COUNTER DUMP ---\n\n");
      }

      return stringBuilder.toString();
   }

   private static StringBuilder indent(StringBuilder sb, int size) {
      sb.append(String.format("[%02d] ", size));

      for(int i = 0; i < size; ++i) {
         sb.append("|   ");
      }

      return sb;
   }

   private void appendTiming(int level, String name, StringBuilder sb) {
      List<ProfilerTiming> list = this.getTimings(name);
      Object2LongMap<String> object2LongMap = ObjectUtils.firstNonNull(this.locationInfos.get(name), EMPTY_INFO).getCounts();
      object2LongMap.forEach((string, long_) -> indent(sb, level).append('#').append(string).append(' ').append(long_).append('/').append(long_ / (long)this.tickDuration).append('\n'));
      if (list.size() >= 3) {
         for(int i = 1; i < list.size(); ++i) {
            ProfilerTiming profilerTiming = list.get(i);
            indent(sb, level).append(profilerTiming.name).append('(').append(profilerTiming.visitCount).append('/').append(String.format(Locale.ROOT, "%.0f", (float)profilerTiming.visitCount / (float)this.tickDuration)).append(')').append(" - ").append(String.format(Locale.ROOT, "%.2f", profilerTiming.parentSectionUsagePercentage)).append("%/").append(String.format(Locale.ROOT, "%.2f", profilerTiming.totalUsagePercentage)).append("%\n");
            if (!"unspecified".equals(profilerTiming.name)) {
               try {
                  this.appendTiming(level + 1, name + '\u001e' + profilerTiming.name, sb);
               } catch (Exception var9) {
                  sb.append("[[ EXCEPTION ").append(var9).append(" ]]");
               }
            }
         }

      }
   }

   private void appendCounter(int depth, String name, ProfileResultImpl.CounterInfo info, int tickSpan, StringBuilder sb) {
      indent(sb, depth).append(name).append(" total:").append(info.selfTime).append('/').append(info.totalTime).append(" average: ").append(info.selfTime / (long)tickSpan).append('/').append(info.totalTime / (long)tickSpan).append('\n');
      info.subCounters.entrySet().stream().sorted(COMPARATOR).forEach((entry) -> this.appendCounter(depth + 1, entry.getKey(), entry.getValue(), tickSpan, sb));
   }

   private void appendCounterDump(Map<String, ProfileResultImpl.CounterInfo> counters, StringBuilder sb, int tickSpan) {
      counters.forEach((string, counterInfo) -> {
         sb.append("-- Counter: ").append(string).append(" --\n");
         this.appendCounter(0, "root", counterInfo.subCounters.get("root"), tickSpan, sb);
         sb.append("\n\n");
      });
   }

   private static String generateWittyComment() {
      String[] strings = new String[]{"Shiny numbers!", "Am I not running fast enough? :(", "I'm working as hard as I can!", "Will I ever be good enough for you? :(", "Speedy. Zoooooom!", "Hello world", "40% better than a crash report.", "Now with extra numbers", "Now with less numbers", "Now with the same numbers", "You should add flames to things, it makes them go faster!", "Do you feel the need for... optimization?", "*cracks redstone whip*", "Maybe if you treated it better then it'll have more motivation to work faster! Poor server."};

      try {
         return strings[(int)(Util.getMeasuringTimeNano() % (long)strings.length)];
      } catch (Throwable var2) {
         return "Witty comment unavailable :(";
      }
   }

   public int getTickSpan() {
      return this.tickDuration;
   }

   static class CounterInfo {
      private long selfTime;
      private long totalTime;
      private final Map<String, ProfileResultImpl.CounterInfo> subCounters;

      private CounterInfo() {
         this.subCounters = Maps.newHashMap();
      }

      public void add(Iterator<String> pathIterator, long time) {
         this.totalTime += time;
         if (!pathIterator.hasNext()) {
            this.selfTime += time;
         } else {
            this.subCounters.computeIfAbsent(pathIterator.next(), (string) -> new CounterInfo()).add(pathIterator, time);
         }

      }
   }
}
```


Overlapping Code:
```
 implements ProfileResult {
private static final Logger LOGGER = LogManager.getLogger();
private static final ProfileLocationInfo EMPTY_INFO = new ProfileLocationInfo() {
public long getTotalTime() {
return 0L;
}
public long getVisitCount() {
return 0L;
}
public Object2LongMap<String> getCounts() {
return Object2LongMaps.emptyMap();
}
};
private static final Splitter SPLITTER = Splitter.on('\u001e');
private static final Comparator<Entry<String, ProfileResultImpl.CounterInfo>> COMPARATOR = Entry.<String, ProfileResultImpl.CounterInfo>comparingByValue(Comparator.comparingLong((counterInfo) -> counterInfo.totalTime)).reversed();
private final Map<String, ? extends ProfileLocationInfo> locationInfos;
private final long startTime;
private final int startTick;
private final long endTime;
private final int endTick;
private final int tickDuration;
public ProfileResultImpl(Map<String, ? extends ProfileLocationInfo> locationInfos, long startTime, int startTick, long endTime, int endTick) {
this.locationInfos = locationInfos;
this.startTime = startTime;
this.startTick = startTick;
this.endTime = endTime;
this.endTick = endTick;
this.tickDuration = endTick - startTick;
}
private ProfileLocationInfo getInfo(String path) {
ProfileLocationInfo profileLocationInfo = this.locationInfos.get(path);
return profileLocationInfo != null ? profileLocationInfo : EMPTY_INFO;
}
public List<ProfilerTiming> getTimings(String parentPath) {
ProfileLocationInfo profileLocationInfo = this.getInfo("root");
long l = profileLocationInfo.getTotalTime();
ProfileLocationInfo profileLocationInfo2 = this.getInfo(parentPath);
long m = profileLocationInfo2.getTotalTime();
long n = profileLocationInfo2.getVisitCount();
List<ProfilerTiming> list = Lists.newArrayList();
if (!parentPath.isEmpty()) {
parentPath = parentPath + '\u001e';
}
long o = 0L;
for (String string2 : this.locationInfos.keySet()) {
if (isSubpath(parentPath, string2)) {
o += this.getInfo(string2).getTotalTime();
}
}
float f = (float)o;
if (o < m) {
o = m;
}
if (l < o) {
l = o;
}
for (String string3 : this.locationInfos.keySet()) {
if (isSub
```
<Overlap Ratio: 0.9731232622798888>

---

--- 373 --
Question ID: 3a62418f6aeee79bc6266838be3fbdcc3747ddd3
Original Code:
```
public class SchubFormDataServiceImpl implements SchubFormDataService
{
    protected ObjectMapper fObjectMapper;
    protected ProcessEngine fProcessEngine;

    public SchubFormDataServiceImpl()
    {
        fObjectMapper = new ObjectMapper();
        
        ProcessEngineProvider prov = getProcessEngineProvider();
        fProcessEngine = prov.getDefaultProcessEngine();
    }

    @Override
    public List<FormDataEntryDTO> getFormData(UriInfo uriInfo, String defId,
        String taskId)
    {
        //TODO: support for locked fields?
        
        List<FormDataEntryDTO> list = new ArrayList<FormDataEntryDTO>();
        
        if(taskId != null && !taskId.isEmpty())
        {
            TaskFormData data = fProcessEngine.getFormService().getTaskFormData(taskId);

            for(FormField field : data.getFormFields())
            {
                FormDataEntryDTO dto = new FormDataEntryDTO(field);
                list.add(dto);
            }
        }
        
        if(defId != null && !defId.isEmpty())
        {
            StartFormData data = fProcessEngine.getFormService().getStartFormData(defId);
            
            for(FormField field : data.getFormFields())
            {
                FormDataEntryDTO dto = new FormDataEntryDTO(field);
                list.add(dto);
            }
        }
        
        return list;
    }

    
    protected ProcessEngineProvider getProcessEngineProvider()
    {
        ServiceLoader<ProcessEngineProvider> serviceLoader =
            ServiceLoader.load(ProcessEngineProvider.class);
        Iterator<ProcessEngineProvider> iterator = serviceLoader.iterator();
    
        if(iterator.hasNext())
        {
          ProcessEngineProvider provider = iterator.next();
          return provider;
        }
        else
        {
          throw new RestException(Status.INTERNAL_SERVER_ERROR,
              "No process engine provider found");
        }
    }
}
```


Overlapping Code:
```
mpl implements SchubFormDataService
{
protected ObjectMapper fObjectMapper;
protected ProcessEngine fProcessEngine;
public SchubFormDataServiceImpl()
{
fObjectMapper = new ObjectMapper();

ProcessEngineProvider prov = getProcessEngineProvider();
fProcessEngine = prov.getDefaultProcessEngine();
}
@Override
public List<FormDataEntryDTO> getFormData(UriInfo uriInfo, String defId,
String taskId)
{
//TODO: support for locked fields?

List<FormDataEntryDTO> list = new ArrayList<FormDataEntryDTO>();

if(taskId != null && !taskId.isEmpty())
{
TaskFormData data = fProcessEngine.getFormService().getTaskFormData(taskId);
for(FormField field : data.getFormFields())
{
FormDataEntryDTO dto = new FormDataEntryDTO(field);
list.add(dto);
}
}

if(defId != null && !defId.isEmpty())
{
StartFormData data = fProcessEngine.getFormService().getStartFormData(defId);

for(FormField field : data.getFormFields())
{
FormDataEntryDTO dto = new FormDataEntryDTO(field);
list.add(dto);
}
}

return list;
}

protected ProcessEngineProvider getProcessEngineProvider()
{
ServiceLoader<ProcessEngineProvider> serviceLoader =
ServiceLoader.load(ProcessEngineProvider.class);
Iterator<ProcessEngineProvider> iterator = serviceLoader.iterator();

if(iterator.hasNext())
{
ProcessEngineProvider provider = iterator.next();
return provider;
}
else
{
throw new RestException(Status.INTERNAL_SERVER_ERROR,
"No process engine provider f
```
<Overlap Ratio: 0.9676531314521679>

---

--- 374 --
Question ID: 27c19a8b98a2afd14fb5b64546922426840a082e
Original Code:
```
public class PayUtils {

	/**采用Rsa加密算法*/
	private static final String ALGORITHM = "RSA";

	/**
	 * @param algorithm
	 * @param ins
	 * @return
	 * @throws NoSuchAlgorithmException
	 * @throws AlipayException
	 */
	private static PublicKey getPublicKeyFromX509(String algorithm, String bysKey) throws Exception {
		byte[] decodedKey = Base64.decode(bysKey);
		X509EncodedKeySpec x509 = new X509EncodedKeySpec(decodedKey);

		KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
		return keyFactory.generatePublic(x509);
	}

	public static String encrypt(String content, String key) {
		try {
			PublicKey pubkey = getPublicKeyFromX509(ALGORITHM, key);

			Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
			cipher.init(Cipher.ENCRYPT_MODE, pubkey);

			byte plaintext[] = content.getBytes("UTF-8");
			byte[] output = cipher.doFinal(plaintext);

			String s = new String(Base64.encode(output));

			return s;

		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	public static final String SIGN_ALGORITHMS = "SHA1WithRSA";

	public static String sign(String content, String privateKey) {
		String charset = "UTF-8";
		try {
			PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(
				Base64.decode(privateKey));
			KeyFactory keyf = KeyFactory.getInstance(ALGORITHM);
			PrivateKey priKey = keyf.generatePrivate(priPKCS8);

			Signature signature = Signature
				.getInstance(SIGN_ALGORITHMS);

			signature.initSign(priKey);
			signature.update(content.getBytes(charset));

			byte[] signed = signature.sign();

			return Base64.encode(signed);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return null;
	}

	public static String getMD5(String content) {
		String s = null;
		char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
		try {
			MessageDigest md = MessageDigest.getInstance("MD5");
			md.update(content.getBytes());
			byte tmp[] = md.digest();
			char str[] = new char[16 * 2];
			int k = 0;
			for (int i = 0; i < 16; i++) {
				byte byte0 = tmp[i];
				str[k++] = hexDigits[byte0 >>> 4 & 0xf];
				str[k++] = hexDigits[byte0 & 0xf];
			}
			s = new String(str);

		} catch (Exception e) {
			e.printStackTrace();
		}
		return s;
	}

	public static boolean doCheck(String content, String sign, String publicKey) {
		try {
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			byte[] encodedKey = Base64.decode(publicKey);
			PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));

			Signature signature = Signature.getInstance(SIGN_ALGORITHMS);

			signature.initVerify(pubKey);
			signature.update(content.getBytes("utf-8"));
			Log.i("Result", "content :   " + content);
			Log.i("Result", "sign:   " + sign);
			boolean bverify = signature.verify(Base64.decode(sign));
			Log.i("Result", "bverify = " + bverify);
			return bverify;
		} catch (Exception e) {
			e.printStackTrace();
		}

		return false;
	}

	public static String sha1(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}

		char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

		try {
			MessageDigest mdTemp = MessageDigest.getInstance("SHA1");
			mdTemp.update(str.getBytes());

			byte[] md = mdTemp.digest();
			int j = md.length;
			char buf[] = new char[j * 2];
			int k = 0;
			for (int i = 0; i < j; i++) {
				byte byte0 = md[i];
				buf[k++] = hexDigits[byte0 >>> 4 & 0xf];
				buf[k++] = hexDigits[byte0 & 0xf];
			}
			return new String(buf);
		} catch (Exception e) {
			return null;
		}
	}


}
```


Overlapping Code:
```
ublic class PayUtils {
/**采用Rsa加密算法*/
private static final String ALGORITHM = "RSA";
/**
* @param algorithm
* @param ins
* @return
* @throws NoSuchAlgorithmException
* @throws AlipayException
*/
private static PublicKey getPublicKeyFromX509(String algorithm, String bysKey) throws Exception {
byte[] decodedKey = Base64.decode(bysKey);
X509EncodedKeySpec x509 = new X509EncodedKeySpec(decodedKey);
KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
return keyFactory.generatePublic(x509);
}
public static String encrypt(String content, String key) {
try {
PublicKey pubkey = getPublicKeyFromX509(ALGORITHM, key);
Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
cipher.init(Cipher.ENCRYPT_MODE, pubkey);
byte plaintext[] = content.getBytes("UTF-8");
byte[] output = cipher.doFinal(plaintext);
String s = new String(Base64.encode(output));
return s;
} catch (Exception e) {
e.printStackTrace();
return null;
}
}
public static final String SIGN_ALGORITHMS = "SHA1WithRSA";
public static String sign(String content, String privateKey) {
String charset = "UTF-8";
try {
PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(
Base64.decode(privateKey));
KeyFactory keyf = KeyFactory.getInstance(ALGORITHM);
PrivateKey priKey = keyf.generatePrivate(priPKCS8);
Signature signature = Signature
.getInstance(SIGN_ALGORITHMS);
signature.initSign(priKey);
signature.update(content.getBytes(charset));
byte[] signed = signature.sign();
return Base64.encode(signed);
} catch (Exception e) {
e.printStackTrace();
}
return null;
}
public static String getMD5(String content) {
String s = null;
char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
try {
MessageDigest md = MessageDigest.getInstance("MD5");
md.update(content.getBytes());
byte tmp[] = md.digest();
char str[] = new char[16 * 2];
int k = 0;
for (int i = 0; i < 16; i++) {
byte byte0 = tmp[i];
str[k++] = hexDigits[byte0 >>> 4 & 0xf];
str[k++] = hexDigits[byte0 & 0xf];
}
s = new String(str);
} catch (Exception e) {
e.printStackTrace();
}
return s;
}
public static boolean doCheck(String content, String sign, String publicKey) {
try {
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
byte[] encodedKey = Base64.decode(publicKey);
PublicKey pubKey = keyFactory.generatePublic(new X
```
<Overlap Ratio: 0.9995665366276549>

---

--- 375 --
Question ID: e384ee8d3706771eda8bc52ccc8bcea0692fb8c0
Original Code:
```
class HeapPostCommit implements Serviceable
{
    /**************************************************************************
     * Fields of the class
     **************************************************************************
     */

    private AccessFactory access_factory  = null;
    private Heap          heap            = null;
    private long          page_number     = ContainerHandle.INVALID_PAGE_NUMBER;


    /**************************************************************************
     * Constructors for This class:
     **************************************************************************
     */
    HeapPostCommit(
    AccessFactory   access_factory,
    Heap            heap,
    long            input_page_number)
    {
        this.access_factory = access_factory; 
        this.heap           = heap; 
        this.page_number    = input_page_number; 
    }

    /**************************************************************************
     * Private/Protected methods of This class:
     **************************************************************************
     */

    /**
     * Reclaim space taken up by committed deleted rows.
     * <p>
     * This routine assumes it has been called by an internal transaction which
     * has performed no work so far, and that it has an exclusive intent table 
     * lock.  It will attempt obtain exclusive row locks on deleted rows, where
     * successful those rows can be reclaimed as they must be "committed 
     * deleted" rows.
     * <p>
     * This routine will latch the page and hold the latch due to interface
     * requirement from Page.purgeAtSlot.
     *
     * @param heap_control  The heap, already opened.
     * @param pageno        number of page to look for committed deletes.
     *
     * @see Page#purgeAtSlot
     * @exception  StandardException  Standard exception policy.
     **/
    private final void purgeCommittedDeletes(
    HeapController      heap_control,
    long                pageno)
        throws StandardException
    {
        // The following can fail either if it can't get the latch or
        // somehow the page requested no longer exists. 
	
	//resolve - what will happen if the user page doesnt exist  

        // wait to get the latch on the page 
        Page page = heap_control.getUserPageWait(pageno);
        boolean purgingDone = false;

        if (page != null)
        {
            try
            {
                // The number records that can be reclaimed is:
                // total recs - recs_not_deleted
                int num_possible_commit_delete = 
                    page.recordCount() - page.nonDeletedRecordCount();

                if (num_possible_commit_delete > 0)
                {
                    // loop backward so that purges which affect the slot table 
                    // don't affect the loop (ie. they only move records we 
                    // have already looked at).
                    for (int slot_no = page.recordCount() - 1; 
                         slot_no >= 0; 
                         slot_no--) 
                    {
                        boolean row_is_committed_delete = 
                            page.isDeletedAtSlot(slot_no);

                        if (row_is_committed_delete)
                        {
                            // At this point we only know that the row is
                            // deleted, not whether it is committed.

                            // see if we can purge the row, by getting an
                            // exclusive lock on the row.  If it is marked
                            // deleted and we can get this lock, then it
                            // must be a committed delete and we can purge 
                            // it.

                            RecordHandle rh =
                                page.fetchFromSlot(
                                    (RecordHandle) null,
                                    slot_no,
                                    RowUtil.EMPTY_ROW,
                                    RowUtil.EMPTY_ROW_FETCH_DESCRIPTOR,
                                    true);

                            row_is_committed_delete =
                                heap_control.lockRowAtSlotNoWaitExclusive(rh);

                            if (row_is_committed_delete)
                            {
                                purgingDone = true;

                                page.purgeAtSlot(slot_no, 1, false);

                                if (SanityManager.DEBUG)
                                {
                                    if (SanityManager.DEBUG_ON(
                                            "verbose_heap_post_commit"))
                                    {
                                        SanityManager.DEBUG_PRINT(
                                            "HeapPostCommit", 
                                            "Purging row[" + slot_no + "]" + 
                                            "on page:" + pageno + ".\n");
                                    }
                                }
                            }
                        }
                    }
                }
                if (page.recordCount() == 0)
                {
                    purgingDone = true;

                    // Deallocate the current page with 0 rows on it.
                    heap_control.removePage(page);

                    // removePage guarantees to unlatch the page even if an
                    // exception is thrown. The page is protected against reuse
                    // because removePage locks it with a dealloc lock, so it
                    // is OK to release the latch even after a purgeAtSlot is
                    // called.
                    // @see ContainerHandle#removePage

                    if (SanityManager.DEBUG)
                    {
                        if (SanityManager.DEBUG_ON("verbose_heap_post_commit"))
                        {
                            SanityManager.DEBUG_PRINT(
                                "HeapPostCommit", 
                                "Calling Heap removePage().; pagenumber="+pageno+"\n");
                        }
                    }
                }
            }
            finally
            {
                // If no purge happened on the page and the page is not
                // removed, feel free to unlatch it.  Otherwise, let
                // transaction commit take care of it.
				if (!purgingDone)
                {
                    page.unlatch();
                    page = null;
                }
            }
        }
        else
        {
            if (SanityManager.DEBUG)
            {
                if (SanityManager.DEBUG_ON("verbose_heap_post_commit"))
                {
                    SanityManager.DEBUG_PRINT(
                        "HeapPostCommit", 
                        "Get No Wait returned null. page num = " + 
                        pageno + "\n");

                    SanityManager.showTrace(new Throwable());
                }
            }
        }
        return;
    }

    /**************************************************************************
     * Public Methods implementing the Serviceable interface:
     **************************************************************************
     */

    /**
     * The urgency of this post commit work.
     * <p>
     * This determines where this Serviceable is put in the post commit 
     * queue.  Post commit work in the heap can be safely delayed until there
     * is not user work to do.
     *
     * @return false, this work should not be serviced ASAP
     **/
    public boolean serviceASAP()
    {
        return(true);
    }

	// @return true, if this work needs to be done on a user thread immediately
	public boolean serviceImmediately()
	{
		return false;
	}	


    /**
     * perform the work described in the postcommit work.
     * <p>
     * In this implementation the only work that can be executed by this
     * post commit processor is this class itself.
     * <p>
     *
     * @return Returns Serviceable.DONE when work has completed, or
     *         returns Serviceable.REQUEUE if work needs to be requeued.
     *
     * @param contextMgr the context manager started by the post commit daemon
     *
     * @exception  StandardException  Standard exception policy.
     **/
    public int performWork(ContextManager contextMgr)
        throws StandardException
    {
      // Gemstone changes begin.  
      TransactionManager  tc             = (TransactionManager)
            this.access_factory.getAndNameTransaction(
                contextMgr, AccessFactoryGlobals.SYS_TRANS_NAME);
      // Gemstone changes end.

        TransactionManager  internal_xact  = tc.getInternalTransaction();

        // only requeue if work was not completed in this try.
        boolean             requeue_work = false;

        HeapController      heapcontroller;

        if (SanityManager.DEBUG)
        {
            if (SanityManager.DEBUG_ON("verbose_heap_post_commit"))
                SanityManager.DEBUG_PRINT(
                    "HeapPostCommit", "starting internal xact\n");
        }

        try
        {
            // This call will attempt to open the heap table locked with 
            // table level IX mode, preparing to do record level locked space 
            // reclamation.  
            //
            // The call will either succeed immediately, or throw an exception
            // which could mean the container does not exist or that the lock
            // could not be granted immediately. 

			//Reversed the fix for 4255:
			//page reclaimation is done asynchronosly by raswstore daemon
			//not good to WAIT FOR LOCKS , as it can freeze the daemon
			//If we can not get the lock this reclamation request will 
			//requeued.

            heapcontroller = (HeapController)
                heap.open(
                    internal_xact,
                    internal_xact.getRawStoreXact(),
                    false,
                    ContainerHandle.MODE_FORUPDATE |
                    ContainerHandle.MODE_LOCK_NOWAIT,
                    TransactionController.MODE_RECORD,
                    internal_xact.getRawStoreXact().newLockingPolicy(
                        LockingPolicy.MODE_RECORD,
                        TransactionController.ISOLATION_REPEATABLE_READ, true),
                    heap,
                    (DynamicCompiledOpenConglomInfo) null);

            // We got a table intent lock, all deleted rows we encounter can
            // be reclaimed, once an "X" row lock is obtained on them.

            // Process all the rows on the page while holding the latch.
            purgeCommittedDeletes(heapcontroller, this.page_number);

        }
        catch (StandardException se)
        {
            // exception might have occured either container got dropper or lock not granted.
            // It is possible by the time this post commit work gets scheduled 
            // that the container has been dropped and that the open container 
            // call will return null - in this case just return assuming no 
            // work to be done.

			//If this expcetion is because lock could not be obtained , work is requeued.
			if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT) || 
				se.getMessageId().equals(SQLState.DEADLOCK))
			{
				requeue_work = true;
			}

            // Do not close the controller because that will unlatch the
            // page.  Let the commit and destroy do release the latch and
            // close the controller.
            // heapcontroller.close();
        }
            
        // It is ok to not sync this post work.  If no subsequent log record
        // is sync'd to disk then it is ok that this transaction not make
        // it to the database.  If any subsequent transaction is sync'd to
        // the log file, then this transaction will be sync'd as part of that
        // work.

        internal_xact.commitNoSync(Transaction.RELEASE_LOCKS);
        internal_xact.destroy();


        if (SanityManager.DEBUG)
        {
            if (SanityManager.DEBUG_ON("verbose_heap_post_commit"))
            {
                if (requeue_work)
                    SanityManager.DEBUG_PRINT(
                        "HeapPostCommit", 
                        "requeueing on page num = " + page_number);
            }
        }

        return(requeue_work ? Serviceable.REQUEUE : Serviceable.DONE);
    }
}
```


Overlapping Code:
```
eable
{
/**************************************************************************
* Fields of the class
**************************************************************************
*/
private AccessFactory access_factory = null;
private Heap heap = null;
private long page_number = ContainerHandle.INVALID_PAGE_NUMBER;
/**************************************************************************
* Constructors for This class:
**************************************************************************
*/
HeapPostCommit(
AccessFactory access_factory,
Heap heap,
long input_page_number)
{
this.access_factory = access_factory; 
this.heap = heap; 
this.page_number = input_page_number; 
}
/**************************************************************************
* Private/Protected methods of This class:
**************************************************************************
*/
/**
* Reclaim space taken up by committed deleted rows.
* <p>
* This routine assumes it has been called by an internal transaction which
* has performed no work so far, and that it has an exclusive intent table 
* lock. It will attempt obtain exclusive row locks on deleted rows, where
* successful those rows can be reclaimed as they must be "committed 
* deleted" rows.
* <p>
* This routine will latch the page and hold the latch due to interface
* requirement from Page.purgeAtSlot.
*
* @param heap_control The heap, already opened.
* @param pageno number of page to look for committed deletes.
*
* @see Page#purgeAtSlot
* @exception StandardException Standard exception policy.
**/
private final void purgeCommittedDeletes(
HeapController heap_control,
long pageno)
throws StandardException
{
// The following can fail either if it can't get the latch or
// somehow the page requested no longer exists. 

//resolve - what will happen if the user page doesnt exist 
// wait to get the latch on the page 
Page page = heap_control.getUserPageWait(pageno);
boolean purgingDone = false;
if (page != null)
{
try
{
// Th
```
<Overlap Ratio: 0.970402717127608>

---

--- 376 --
Question ID: 4f0d5c5849a723cc29ca59c2d2a24b223dae997b
Original Code:
```
public final class Db {

    private static final JdbcConnectionPool cp;
    private static volatile int maxActiveConnections;

    private static final ThreadLocal<DbConnection> localConnection = new ThreadLocal<>();
    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionCaches = new ThreadLocal<>();
    private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionBatches = new ThreadLocal<>();

    private static final class DbConnection extends FilteredConnection {

        private DbConnection(Connection con) {
            super(con);
        }

        @Override
        public void setAutoCommit(boolean autoCommit) throws SQLException {
            throw new UnsupportedOperationException("Use Db.beginTransaction() to start a new transaction");
        }

        @Override
        public void commit() throws SQLException {
            if (localConnection.get() == null) {
                super.commit();
            } else if (! this.equals(localConnection.get())) {
                throw new IllegalStateException("Previous connection not committed");
            } else {
                throw new UnsupportedOperationException("Use Db.commitTransaction() to commit the transaction");
            }
        }

        private void doCommit() throws SQLException {
            super.commit();
        }

        @Override
        public void rollback() throws SQLException {
            if (localConnection.get() == null) {
                super.rollback();
            } else if (! this.equals(localConnection.get())) {
                throw new IllegalStateException("Previous connection not committed");
            } else {
                throw new UnsupportedOperationException("Use Db.rollbackTransaction() to rollback the transaction");
            }
        }

        private void doRollback() throws SQLException {
            super.rollback();
        }

        @Override
        public void close() throws SQLException {
            if (localConnection.get() == null) {
                super.close();
            } else if (! this.equals(localConnection.get())) {
                throw new IllegalStateException("Previous connection not committed");
            }
        }

    }

    public static void init() {}

    static {
        long maxCacheSize = Nxt.getIntProperty("nxt.dbCacheKB");
        if (maxCacheSize == 0) {
        	maxCacheSize = Math.min(256, Math.max(16, (Runtime.getRuntime().maxMemory() / (1024 * 1024) - 128)/2)) * 1024;
        }
        String dbUrl = Constants.isTestnet ? Nxt.getStringProperty("nxt.testDbUrl") : Nxt.getStringProperty("nxt.dbUrl");
        if (! dbUrl.contains("CACHE_SIZE=")) {
            dbUrl += ";CACHE_SIZE=" + maxCacheSize;
        }
	// Replace old DB-Url if needed:
	if ( dbUrl.startsWith("jdbc:h2:ATM_db")) {
	    dbUrl = "jdbc:h2:./ATM_db" + dbUrl.substring(16);
	    Logger.logMessage(dbUrl);
	}

        Logger.logDebugMessage("Database jdbc url set to: " + dbUrl);
        cp = JdbcConnectionPool.create(dbUrl, "sa", "sa");
        cp.setMaxConnections(Nxt.getIntProperty("nxt.maxDbConnections"));
        cp.setLoginTimeout(Nxt.getIntProperty("nxt.dbLoginTimeout"));
        int defaultLockTimeout = Nxt.getIntProperty("nxt.dbDefaultLockTimeout") * 1000;
        try (Connection con = cp.getConnection();
             Statement stmt = con.createStatement()) {
            stmt.executeUpdate("SET DEFAULT_LOCK_TIMEOUT " + defaultLockTimeout);
        } catch (SQLException e) {
            throw new RuntimeException(e.toString(), e);
        }
    }
    
    public static void analyzeTables() {
        try (Connection con = cp.getConnection();
             Statement stmt = con.createStatement()) {
            stmt.execute("ANALYZE SAMPLE_SIZE 0");
        } catch (SQLException e) {
            throw new RuntimeException(e.toString(), e);
        }
    }

    public static void shutdown() {
        try {
            Connection con = cp.getConnection();
            Statement stmt = con.createStatement();
            stmt.execute("SHUTDOWN COMPACT");
            Logger.logShutdownMessage("Database shutdown completed");
        } catch (SQLException e) {
            Logger.logShutdownMessage(e.toString(), e);
        }
    }

    private static Connection getPooledConnection() throws SQLException {
        Connection con = cp.getConnection();
        int activeConnections = cp.getActiveConnections();
        if (activeConnections > maxActiveConnections) {
            maxActiveConnections = activeConnections;
            Logger.logDebugMessage("Database connection pool current size: " + activeConnections);
        }
        return con;
    }

    public static Connection getConnection() throws SQLException {
        Connection con = localConnection.get();
        if (con != null) {
            return con;
        }
        con = getPooledConnection();
        con.setAutoCommit(true);
        return new DbConnection(con);
    }

    static Map<DbKey,Object> getCache(String tableName) {
        if (!isInTransaction()) {
            throw new IllegalStateException("Not in transaction");
        }
        Map<DbKey,Object> cacheMap = transactionCaches.get().get(tableName);
        if (cacheMap == null) {
            cacheMap = new HashMap<>();
            transactionCaches.get().put(tableName, cacheMap);
        }
        return cacheMap;
    }

    static Map<DbKey,Object> getBatch(String tableName) {
        if(!isInTransaction()) {
            throw new IllegalStateException("Not in transaction");
        }
        Map<DbKey,Object> batchMap = transactionBatches.get().get(tableName);
        if(batchMap == null) {
            batchMap = new HashMap<>();
            transactionBatches.get().put(tableName, batchMap);
        }
        return batchMap;
    }

    public static boolean isInTransaction() {
        return localConnection.get() != null;
    }

    public static Connection beginTransaction() {
        if (localConnection.get() != null) {
            throw new IllegalStateException("Transaction already in progress");
        }
        try {
            Connection con = getPooledConnection();
            con.setAutoCommit(false);
            con = new DbConnection(con);
            localConnection.set((DbConnection)con);
            transactionCaches.set(new HashMap<String, Map<DbKey, Object>>());
            transactionBatches.set(new HashMap<String, Map<DbKey, Object>>());
            return con;
        } catch (SQLException e) {
            throw new RuntimeException(e.toString(), e);
        }
    }

    public static void commitTransaction() {
        DbConnection con = localConnection.get();
        if (con == null) {
            throw new IllegalStateException("Not in transaction");
        }
        try {
            con.doCommit();
        } catch (SQLException e) {
            throw new RuntimeException(e.toString(), e);
        }
    }

    public static void rollbackTransaction() {
        DbConnection con = localConnection.get();
        if (con == null) {
            throw new IllegalStateException("Not in transaction");
        }
        try {
            con.doRollback();
        } catch (SQLException e) {
            throw new RuntimeException(e.toString(), e);
        }
        transactionCaches.get().clear();
        transactionBatches.get().clear();
    }

    public static void endTransaction() {
        Connection con = localConnection.get();
        if (con == null) {
            throw new IllegalStateException("Not in transaction");
        }
        localConnection.set(null);
        transactionCaches.get().clear();
        transactionCaches.set(null);
        transactionBatches.get().clear();
        transactionBatches.set(null);
        DbUtils.close(con);
    }

    private Db() {} // never

}
```


Overlapping Code:
```
atic final JdbcConnectionPool cp;
private static volatile int maxActiveConnections;
private static final ThreadLocal<DbConnection> localConnection = new ThreadLocal<>();
private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionCaches = new ThreadLocal<>();
private static final ThreadLocal<Map<String,Map<DbKey,Object>>> transactionBatches = new ThreadLocal<>();
private static final class DbConnection extends FilteredConnection {
private DbConnection(Connection con) {
super(con);
}
@Override
public void setAutoCommit(boolean autoCommit) throws SQLException {
throw new UnsupportedOperationException("Use Db.beginTransaction() to start a new transaction");
}
@Override
public void commit() throws SQLException {
if (localConnection.get() == null) {
super.commit();
} else if (! this.equals(localConnection.get())) {
throw new IllegalStateException("Previous connection not committed");
} else {
throw new UnsupportedOperationException("Use Db.commitTransaction() to commit the transaction");
}
}
private void doCommit() throws SQLException {
super.commit();
}
@Override
public void rollback() throws SQLException {
if (localConnection.get() == null) {
super.rollback();
} else if (! this.equals(localConnection.get())) {
throw new IllegalStateException("Previous connection not committed");
} else {
throw new UnsupportedOperationException("Use Db.rollbackTransaction() to rollback the transaction");
}
}
private void doRollback() throws SQLException {
super.rollback();
}
@Override
public void close() throws SQLException {
if (localConnection.get() == null) {
super.close();
} else if (! this.equals(localConnection.get())) {
throw new IllegalStateException("Previous connection not committed");
}
}
}
public static void init() {}
static {
long maxCacheSize = Nxt.getIntProperty("nxt.dbCacheKB");
if (maxCacheSize == 0) {
maxCacheSize = Math.min(256, Math.max(16, (Runtime.getRuntime().maxMemory() / (1024 * 1024)
```
<Overlap Ratio: 0.9817444219066938>

---

--- 377 --
Question ID: 723a4f11a4f5f4f682c07c8c643e4428410bc310
Original Code:
```
@ApplicationScoped
public class OrderService {

    @Inject MongoClient mongoClient;

    public List<Order> list(){

        List<Order> list = new ArrayList<>();

        MongoCursor<Document> cursor = getCollection().find().iterator();

        try {
            while (cursor.hasNext()) {
                Document document = cursor.next();
                Order order = new Order();
                order.setOrderId(document.getString("orderId"));
                order.setName(document.getString("name"));
                order.setTotal(document.getString("total"));
                order.setCcNumber(document.getString("ccNumber"));
                order.setCcExp(document.getString("ccExp"));
                order.setBillingAddress(document.getString("billingAddress"));
                order.setStatus(document.getString("status"));
                list.add(order);
            }
        } finally {
            cursor.close();
        }

        return list;
    }

    public void add(Order order){

      Document document = new Document()
            .append("orderId", order.getOrderId())
            .append("name", order.getName())
            .append("total", order.getTotal())
            .append("ccNumber", order.getCcNumber())
            .append("ccExp", order.getCcExp())
            .append("billingAddress", order.getBillingAddress())
            .append("status", order.getStatus());
      getCollection().insertOne(document);

    }

    public void updateStatus(String orderId, String status){
        Document searchQuery = new Document("orderId", orderId);
        Document newValue = new Document("status", status);
        Document updateOperationDoc = new Document("$set", newValue);
        getCollection().updateOne(searchQuery, updateOperationDoc);
    }

    private MongoCollection<Document> getCollection(){
        return mongoClient.getDatabase("order").getCollection("order");
    }
}
```


Overlapping Code:
```
ice {
@Inject MongoClient mongoClient;
public List<Order> list(){
List<Order> list = new ArrayList<>();
MongoCursor<Document> cursor = getCollection().find().iterator();
try {
while (cursor.hasNext()) {
Document document = cursor.next();
Order order = new Order();
order.setOrderId(document.getString("orderId"));
order.setName(document.getString("name"));
order.setTotal(document.getString("total"));
order.setCcNumber(document.getString("ccNumber"));
order.setCcExp(document.getString("ccExp"));
order.setBillingAddress(document.getString("billingAddress"));
order.setStatus(document.getString("status"));
list.add(order);
}
} finally {
cursor.close();
}
return list;
}
public void add(Order order){
Document document = new Document()
.append("orderId", order.getOrderId())
.append("name", order.getName())
.append("total", order.getTotal())
.append("ccNumber", order.getCcNumber())
.append("ccExp", order.getCcExp())
.append("billingAddress", order.getBillingAddress())
.append("status", order.getStatus());
getCollection().insertOne(document);
}
public void updateStatus(String orderId, String status){
Document searchQuery = new Document("orderId", orderId);
Document newValue = new Document("status", status);
Document updateOperationDoc = new Document("$set", newValue);
getCollection().updateOne(searchQuery, updateOperationDoc);
}
private MongoCollection<Document> getCollection(){
return mongoClient.getDatabase("order").getCollection("orde
```
<Overlap Ratio: 0.9673115410273516>

---

--- 378 --
Question ID: 34ed57f18542aefc1b065339326099827dff7837
Original Code:
```
public class ModSetup {

    public static File modConfigDir;
    public static boolean lostcities = false;
    private Logger logger;

    private Configuration mainConfig;

    public void preInit(FMLPreInitializationEvent e) {
        logger = e.getModLog();

        MinecraftForge.EVENT_BUS.register(new ForgeEventHandlers());

        lostcities = Loader.isModLoaded("lostcities");

        modConfigDir = e.getModConfigurationDirectory();
        mainConfig = new Configuration(new File(modConfigDir.getPath(), "enigma.cfg"));

        EnigmaMessages.registerMessages("enigma");

        readMainConfig();
        ModItems.init();
        ModBlocks.init();
        FxAnimationHandler.init();
    }

    public Logger getLogger() {
        return logger;
    }

    private void readMainConfig() {
        Configuration cfg = mainConfig;
        try {
            cfg.load();
//            cfg.addCustomCategoryComment(GeneralConfiguration.CATEGORY_GENERAL, "General settings");

//            GeneralConfiguration.init(cfg);
        } catch (Exception e1) {
            FMLLog.log(Level.ERROR, e1, "Problem loading config file!");
        } finally {
            if (mainConfig.hasChanged()) {
                mainConfig.save();
            }
        }
    }

    public void init(FMLInitializationEvent e) {
    }

    public void postInit(FMLPostInitializationEvent e) {
        mainConfig = null;
    }

    public World getClientWorld() {
        throw new IllegalStateException("This should only be called from client side");
    }

    public EntityPlayer getClientPlayer() {
        throw new IllegalStateException("This should only be called from client side");
    }

    public <V> ListenableFuture<V> addScheduledTaskClient(Callable<V> callableToSchedule) {
        throw new IllegalStateException("This should only be called from client side");
    }

    public ListenableFuture<Object> addScheduledTaskClient(Runnable runnableToSchedule) {
        throw new IllegalStateException("This should only be called from client side");
    }

    public boolean isClient() {
        return false;
    }
}
```


Overlapping Code:
```
 class ModSetup {
public static File modConfigDir;
public static boolean lostcities = false;
private Logger logger;
private Configuration mainConfig;
public void preInit(FMLPreInitializationEvent e) {
logger = e.getModLog();
MinecraftForge.EVENT_BUS.register(new ForgeEventHandlers());
lostcities = Loader.isModLoaded("lostcities");
modConfigDir = e.getModConfigurationDirectory();
mainConfig = new Configuration(new File(modConfigDir.getPath(), "enigma.cfg"));
EnigmaMessages.registerMessages("enigma");
readMainConfig();
ModItems.init();
ModBlocks.init();
FxAnimationHandler.init();
}
public Logger getLogger() {
return logger;
}
private void readMainConfig() {
Configuration cfg = mainConfig;
try {
cfg.load();
// cfg.addCustomCategoryComment(GeneralConfiguration.CATEGORY_GENERAL, "General settings");
// GeneralConfiguration.init(cfg);
} catch (Exception e1) {
FMLLog.log(Level.ERROR, e1, "Problem loading config file!");
} finally {
if (mainConfig.hasChanged()) {
mainConfig.save();
}
}
}
public void init(FMLInitializationEvent e) {
}
public void postInit(FMLPostInitializationEvent e) {
mainConfig = null;
}
public World getClientWorld() {
throw new IllegalStateException("This should only be called from client side");
}
public EntityPlayer getClientPlayer() {
throw new IllegalStateException("This should only be called from client side");
}
public <V> ListenableFuture<V> addScheduledTaskClient(Callable<V> callableToSchedule) {
throw new IllegalStateException("This should only be called from client side");
}
public ListenableFuture<Object> addScheduledTaskClient(Runnable runnableToSchedule) {
throw new IllegalStateException("This should only be called from client side");
}
public boo
```
<Overlap Ratio: 0.9764503159103963>

---

--- 379 --
Question ID: a246f6aea1f675bb4ecfafd72d1ba814ad8ad967
Original Code:
```
public class BlogStatus2DB<T> implements DataObject2DB<T> {

	@Override
	public int getTotalRecord() {
		String sql = "select count(*) from blog_status";
		Object[] params = {};
		return (int)DBUtils.query(sql, params, new IntegerHandler());
	}

	@Override
	public int insertData(Object obj) {
		blog_status status = (blog_status)obj;
		blog_index index = new blog_index();
		index.setIndex_id(status.getStatus_id());
		index.setIndex_glance(status.getStatus_content());
		index.setIndex_type("2");
		String sql1 = "insert into blog_status(status_id,status_content,holder_id) values(?,?,?)";
		String sql2 = "insert into blog_index(index_id,index_type,index_glance,index_title) values(?,?,?,?)";
		Object[] param1 = {status.getStatus_id(), status.getStatus_content(), status.getHolder_id()};
		Object[] param2 = {index.getIndex_id(), index.getIndex_type(), index.getIndex_glance(), index.getIndex_title()};
		String[] sql = {sql1, sql2};
		Object[][] params = {param1, param2};
		return DBUtils.updateTranscation(sql, params);
	}

	@Override
	public int deleteData(String id) {
		String sql1 = "delete from blog_status where status_id=?";
		String sql2 = "delete from blog_index where index_id=?";
		Object[] param1 = {id};
		Object[] param2 = {id};
		String[] sql = {sql1, sql2};
		Object[][] params = {param1, param2};
		return DBUtils.updateTranscation(sql, params);
	}

	@Override
	public int updateData(Object obj) {
		blog_status status = (blog_status)obj;
		String sql = "update blog_status set status_content=? where status_id=?";
		Object[] params = {status.getStatus_content(), status.getStatus_id()};
 		return DBUtils.update(sql, params);
	}

	@Override
	public blog_page selectData(int currentPage, int pageContain, int pageInFrame) {
		int totalRecord = getTotalRecord();
		blog_page page = new blog_page(totalRecord, currentPage, pageContain, pageInFrame);
		int start = ((page.getCurrentPage() - 1) * page.getPageContain());
		if(start < 0){
			start = 0;
		}
		String sql = "select status_id, status_content, publish_date, holder_id from blog_status order by publish_date desc limit ?,?";
		Object[] params = {start, page.getPageContain()};
		page.setList(DBUtils.query(sql, params, new ListHandler<List<T>>(blog_status.class)));
		return page;
	}

	@Override
	public blog_page selectIndexData(int currentPage, int pageContain, int pageInFrame) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public T selectByID(String id) {
		// TODO Auto-generated method stub
		return null;
	}
}
```


Overlapping Code:
```
tus2DB<T> implements DataObject2DB<T> {
@Override
public int getTotalRecord() {
String sql = "select count(*) from blog_status";
Object[] params = {};
return (int)DBUtils.query(sql, params, new IntegerHandler());
}
@Override
public int insertData(Object obj) {
blog_status status = (blog_status)obj;
blog_index index = new blog_index();
index.setIndex_id(status.getStatus_id());
index.setIndex_glance(status.getStatus_content());
index.setIndex_type("2");
String sql1 = "insert into blog_status(status_id,status_content,holder_id) values(?,?,?)";
String sql2 = "insert into blog_index(index_id,index_type,index_glance,index_title) values(?,?,?,?)";
Object[] param1 = {status.getStatus_id(), status.getStatus_content(), status.getHolder_id()};
Object[] param2 = {index.getIndex_id(), index.getIndex_type(), index.getIndex_glance(), index.getIndex_title()};
String[] sql = {sql1, sql2};
Object[][] params = {param1, param2};
return DBUtils.updateTranscation(sql, params);
}
@Override
public int deleteData(String id) {
String sql1 = "delete from blog_status where status_id=?";
String sql2 = "delete from blog_index where index_id=?";
Object[] param1 = {id};
Object[] param2 = {id};
String[] sql = {sql1, sql2};
Object[][] params = {param1, param2};
return DBUtils.updateTranscation(sql, params);
}
@Override
public int updateData(Object obj) {
blog_status status = (blog_status)obj;
String sql = "update blog_status set status_content=? where status_id=?";
Object[] params = {status.getStatus_content(), status.getStatus_id()};
return DBUtils.update(sql, params);
}
@Override
public blog_page selectData(int currentPage, int pageContain, int pageInFrame) {
int totalRecord = getTotalRecord();
blog_page page = new blog_page(totalRecord, currentPage, pageContain, pageInFrame);
int start = ((page.getCurrentPage() - 1) * page.getPageContain());
if(start < 0){
start = 0;
}
String sql = "select status_id, status_content, publish_date, holder_id from blog_status order by publish_date desc limit ?,?";
Object[] params = {start, page.getPageContain()};
page.setList(DBUtils.query(sql, params, new ListHandler<List<T>>(blog_status.class)));
return page;
}
@Override
public blog_page selectIndexData(int currentPage, int pageContain, int pageInFrame) {
// TODO Auto-generated method stub
return null;
}
@Override
public T selectByID(String id) {
// TODO Au
```
<Overlap Ratio: 0.9824414715719063>

---

--- 380 --
Question ID: abdf24eaf6e987a6f9a2f58b74d289039d5e7314
Original Code:
```
public class MCIBoundedExistenceChecker extends BoundedExistenceChecker {
    public MCIBoundedExistenceChecker() {

        super();
    }

    @Override
    protected boolean evaluateState(Snapshot snapshot, Property verificationProperty) {
        int ambNum = 0;
        String tmp = "";

        StringTokenizer st = new StringTokenizer(snapshot.getSnapshotString(), " ");
        while (st.hasMoreTokens()) {
            String target = st.nextToken();
            if (target.equals("CurrentAmb:")) {
                ambNum = Integer.parseInt(st.nextToken());
            } else if (target.equals("Amb:")) {
                for (int i = 0; i < ambNum; i++) {
                    tmp = st.nextToken();
                    StringTokenizer st2 = new StringTokenizer(tmp, "/");
                    st2.nextToken();

                    if (st2.nextToken().equals(verificationProperty.getState())) { // Ambulance의 State가 Free인지 아닌지 확인
                        return false;
                    }
                }
            }
        }
        return true;
    }

    @Override
    public boolean check(Log log, Property verificationProperty, int until) {
        return false;
    }

    @Override
    public boolean check(Log log, Property verificationProperty, double prob, int T) {
        return false;
    }

    @Override
    public boolean check(Log log, Property verificationProperty, double prob, int t, int T) {
        return false;
    }

    @Override
    public boolean check(Log log, Property verificationProperty, int t, int T) {
        return false;
    }

    @Override
    protected boolean evaluateState(Log log, Property verificationProperty) {
        return false;
    }
}
```


Overlapping Code:
```
ExistenceChecker extends BoundedExistenceChecker {
public MCIBoundedExistenceChecker() {
super();
}
@Override
protected boolean evaluateState(Snapshot snapshot, Property verificationProperty) {
int ambNum = 0;
String tmp = "";
StringTokenizer st = new StringTokenizer(snapshot.getSnapshotString(), " ");
while (st.hasMoreTokens()) {
String target = st.nextToken();
if (target.equals("CurrentAmb:")) {
ambNum = Integer.parseInt(st.nextToken());
} else if (target.equals("Amb:")) {
for (int i = 0; i < ambNum; i++) {
tmp = st.nextToken();
StringTokenizer st2 = new StringTokenizer(tmp, "/");
st2.nextToken();
if (st2.nextToken().equals(verificationProperty.getState())) { // Ambulance의 State가 Free인지 아닌지 확인
return false;
}
}
}
}
return true;
}
@Override
public boolean check(Log log, Property verificationProperty, int until) {
return false;
}
@Override
public boolean check(Log log, Property verificationProperty, double prob, int T) {
return false;
}
@Override
public boolean check(Log log, Property verificationProperty, double prob, int t, int T) {
return false;
}
@Override
public boolean check(Log log, Property verificationProperty, int t, int T) {
return false;
}
@Override
protected boolean evaluateState(Log log, Property verificationProperty) {
return false;
}
}
```
<Overlap Ratio: 0.982225656877898>

---

--- 381 --
Question ID: 2700adf2ca2b8ae55e83253cd55075cfceef01f9
Original Code:
```
public class GetDNSCustomRRType {

	public static void main(String[] args) {
		HashMap<ContextOptionName, Object> options = new HashMap<ContextOptionName, Object>();
		options.put(ContextOptionName.STUB, true);
		options.put(ContextOptionName.DNS_TRANSPORT, 542);
		final IGetDNSContextSync context = GetDNSFactory.createSync(1, options);
		String queryString = "getdnsapi.net";
		String type = "A";
		HashMap<ExtensionName, Object> extensions = new HashMap<ExtensionName, Object>();
		extensions.put(ExtensionName.DNSSEC_RETURN_STATUS, GetDNSConstants.GETDNS_EXTENSION_TRUE);

		try {
			HashMap<String, Object> info = context.generalSync(queryString, RRType.valueOf(type), extensions);
			if (info != null) {
				if (Integer.parseInt(info.get("status").toString()) == 900) {
					byte[] rdataRaw = (byte[]) GetDNSUtil.getObject(info, "/replies_tree[0]/answer[0]/rdata/rdata_raw");
					System.out.println("Size: " + rdataRaw.length);
					System.out.println("Rdata: " + bytesToHex(rdataRaw));
				}

				else if (Integer.parseInt(info.get("status").toString()) == 901) {
					System.out.println("no such name: " + queryString + "with type: " + type);
				} else {

					System.out.println("Error in query GETDNS Status =" + info.get("status").toString());
				}
			} else {
				System.out.println("No response form DNS SERVER");
			}
		} finally {
			context.close();
		}
		System.exit(0);

	}

	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();

	public static String bytesToHex(byte[] bytes) {
		char[] hexChars = new char[bytes.length * 2];
		for (int j = 0; j < bytes.length; j++) {
			int v = bytes[j] & 0xFF;
			hexChars[j * 2] = hexArray[v >>> 4];
			hexChars[j * 2 + 1] = hexArray[v & 0x0F];
		}
		return new String(hexChars);
	}

}
```


Overlapping Code:
```
lass GetDNSCustomRRType {
public static void main(String[] args) {
HashMap<ContextOptionName, Object> options = new HashMap<ContextOptionName, Object>();
options.put(ContextOptionName.STUB, true);
options.put(ContextOptionName.DNS_TRANSPORT, 542);
final IGetDNSContextSync context = GetDNSFactory.createSync(1, options);
String queryString = "getdnsapi.net";
String type = "A";
HashMap<ExtensionName, Object> extensions = new HashMap<ExtensionName, Object>();
extensions.put(ExtensionName.DNSSEC_RETURN_STATUS, GetDNSConstants.GETDNS_EXTENSION_TRUE);
try {
HashMap<String, Object> info = context.generalSync(queryString, RRType.valueOf(type), extensions);
if (info != null) {
if (Integer.parseInt(info.get("status").toString()) == 900) {
byte[] rdataRaw = (byte[]) GetDNSUtil.getObject(info, "/replies_tree[0]/answer[0]/rdata/rdata_raw");
System.out.println("Size: " + rdataRaw.length);
System.out.println("Rdata: " + bytesToHex(rdataRaw));
}
else if (Integer.parseInt(info.get("status").toString()) == 901) {
System.out.println("no such name: " + queryString + "with type: " + type);
} else {
System.out.println("Error in query GETDNS Status =" + info.get("status").toString());
}
} else {
System.out.println("No response form DNS SERVER");
}
} finally {
context.close();
}
System.exit(0);
}
final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
public static String bytesToHex(byte[] bytes) {
char[] hexChars = new char[bytes.length * 2];
for (int j = 0; j < bytes.length; j++) {
int v = bytes[j] & 0xFF;
hexChars[j * 2] = hexArray[v >>> 4];
hexChars[j * 2 + 1] = hexArray[v & 0x0F];
}
return new String(hexChars);
}
}
```
<Overlap Ratio: 0.9951485748938751>

---

--- 382 --
Question ID: 327b1852eacff2a4065c38549285e0dfc84d271d
Original Code:
```
@Entity
@Table(name = "TESTCASE")
public class TestCase extends AbstractBaseEntity {

    /**
     * long serialVersionUID
     */
    private static final long serialVersionUID = 455667421219565288L;

    /**
     * String name
     */
    @Size(min = 1, max = 255)
    @Column(name = "NAME", unique = true)
    private String name;

    @Column(name = "DESCRIPTION", columnDefinition = "TEXT")
    private String description;

    @Column(name = "IS_AUTOMATED")
    private boolean automated = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PROJECT_ID")
    @Where(clause = "IS_DELETED=0")
    private Project project;

    @Column(name = "TESTCASE_FOLDER_ID")
    private Integer testCaseFolderId;

    @Column(name = "EXECUTION_DATE")
    private LocalDateTime executionDateTime;

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "TESTCASE_ID")
    @Where(clause = "IS_LOOK_UP=0 AND IS_DELETED=0")
    @OrderBy("position ASC")
    private List<TestStep> testSteps = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "TESTCASE_ID")
    @Where(clause = "IS_LOOK_UP=1 AND IS_DELETED=0")
    @OrderBy("position ASC")
    private List<TestStep> lookUps = new ArrayList<>();

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "TESTCASE_ID")
    @Where(clause = "IS_DELETED=0")
    private List<TestCaseTestRun> testCaseTestRunList = new ArrayList<>();

    @Transient
    private String testCaseFolder = "";

    @Transient
    private ExecutionStatus executionStatus = ExecutionStatus.NOTRUN;

    @Transient
    private String version = "";

    public TestCase() {
    }

    public TestCase(String name, String description, Project project, Integer testCaseFolderId) {
        super();
        this.name = name;
        this.description = description;
        this.project = project;
        this.testCaseFolderId = testCaseFolderId;
    }

    /**
     * @return the lookUps
     */
    public List<TestStep> getLookUps() {
        return lookUps;
    }

    /**
     * @param lookUps the lookUps to set
     */
    public void setLookUps(List<TestStep> lookUps) {
        this.lookUps = lookUps;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @param description the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @return the automated
     */
    public boolean isAutomated() {
        return automated;
    }

    /**
     * @param automated the automated to set
     */
    public void setAutomated(boolean automated) {
        this.automated = automated;
    }

    /**
     * @return the project
     */
    public Project getProject() {
        return project;
    }

    /**
     * @param project the project to set
     */
    public void setProject(Project project) {
        this.project = project;
    }

    /**
     * @return the testSteps
     */
    public List<TestStep> getTestSteps() {
        return testSteps;
    }

    /**
     * @param testSteps the testSteps to set
     */
    public void setTestSteps(List<TestStep> testSteps) {
        this.testSteps = testSteps;
    }

    /**
     * @return the testCaseTestRunList
     */
    public List<TestCaseTestRun> getTestCaseTestRunList() {
        return testCaseTestRunList;
    }

    /**
     * @param testCaseTestRunList the testCaseTestRunList to set
     */
    public void setTestCaseTestRunList(List<TestCaseTestRun> testCaseTestRunList) {
        this.testCaseTestRunList = testCaseTestRunList;
    }

    /**
     * @return the executionStatus
     */
    public ExecutionStatus getExecutionStatus() {
        return executionStatus;

    }

    public void setExecutionStatus(ExecutionStatus executionStatus) {
        this.executionStatus = executionStatus;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * @return the testCaseFolderId
     */
    public Integer getTestCaseFolderId() {
        return testCaseFolderId;
    }

    /**
     * @param testCaseFolderId the testCaseFolderId to set
     */
    public void setTestCaseFolderId(Integer testCaseFolderId) {
        this.testCaseFolderId = testCaseFolderId;
    }

    /**
     * @return the executionDateTime
     */
    public LocalDateTime getExecutionDateTime() {
        return executionDateTime;
    }

    /**
     * @param executionDateTime the executionDateTime to set
     */
    public void setExecutionDateTime(LocalDateTime executionDateTime) {
        this.executionDateTime = executionDateTime;
    }

    public String getTestCaseFolder() {
        return testCaseFolder;
    }

    public void setTestCaseFolder(String testCaseFolder) {
        this.testCaseFolder = testCaseFolder;
    }

    public TestCase cloneTestCase() {
        TestCase newTestCase = new TestCase();
        newTestCase.setAutomated(automated);
        newTestCase.setDescription(description);
        newTestCase.setExecutionDateTime(executionDateTime);
        newTestCase.setName(generateName());
        newTestCase.setProject(project);
        newTestCase.setTestCaseFolderId(testCaseFolderId);
        testSteps.forEach(testStep -> {
            TestStep clonedTestStep = testStep.cloneTestStep();
            newTestCase.getTestSteps().add(clonedTestStep);
        });
        lookUps.forEach(lookUp -> {
            TestStep clonedLookUp = lookUp.cloneTestStep();
            newTestCase.getLookUps().add(clonedLookUp);
        });
        return newTestCase;
    }

    public String generateName() {
        String newName = name;
        String[] splittedName = newName.split("_");
        try {
            Integer value = Integer.parseInt(splittedName[splittedName.length - 1]);
            newName = newName.substring(0, newName.lastIndexOf('_')) + "_" + (++value);
        } catch (NumberFormatException e) {
            newName = newName + "_2";
        }
        return newName;
    }

}
```


Overlapping Code:
```
lass TestCase extends AbstractBaseEntity {
/**
* long serialVersionUID
*/
private static final long serialVersionUID = 455667421219565288L;
/**
* String name
*/
@Size(min = 1, max = 255)
@Column(name = "NAME", unique = true)
private String name;
@Column(name = "DESCRIPTION", columnDefinition = "TEXT")
private String description;
@Column(name = "IS_AUTOMATED")
private boolean automated = false;
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "PROJECT_ID")
@Where(clause = "IS_DELETED=0")
private Project project;
@Column(name = "TESTCASE_FOLDER_ID")
private Integer testCaseFolderId;
@Column(name = "EXECUTION_DATE")
private LocalDateTime executionDateTime;
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@JoinColumn(name = "TESTCASE_ID")
@Where(clause = "IS_LOOK_UP=0 AND IS_DELETED=0")
@OrderBy("position ASC")
private List<TestStep> testSteps = new ArrayList<>();
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@JoinColumn(name = "TESTCASE_ID")
@Where(clause = "IS_LOOK_UP=1 AND IS_DELETED=0")
@OrderBy("position ASC")
private List<TestStep> lookUps = new ArrayList<>();
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@JoinColumn(name = "TESTCASE_ID")
@Where(clause = "IS_DELETED=0")
private List<TestCaseTestRun> testCaseTestRunList = new ArrayList<>();
@Transient
private String testCaseFolder = "";
@Transient
private ExecutionStatus executionStatus = ExecutionStatus.NOTRUN;
@Transient
private String version = "";
public TestCase() {
}
public TestCase(String name, String description, Project project, Integer testCaseFolderId) {
super();
this.name = name;
this.description = description;
this.project = project;
this.testCaseFolderId = testCaseFolderId;
}
/**
* @return the lookUps
*/
public List<TestStep> getLookUps() {
return lookUps;
}
/**
* @param lookUps the lookUps to set
*/
public void setLookUps(List<TestStep> lookUps) {
this.lookUps = lookUps;
}
/**
* @return the name
*/
public String getName() {
return name;
}
/**
* @param name the name to set
*/
public void setName(String name) {
this.name = name;
}
/**
```
<Overlap Ratio: 0.9802352941176471>

---

--- 383 --
Question ID: 7dc47f44ae1c80df2f9e4704ae2dafa18a3c4733
Original Code:
```
public class DexParser {

    private CountingInputStream in;
    private ByteOrder byteOrder = ByteOrder.LITTLE;

    private static final int NO_INDEX = 0xffffffff;

    private DexClass[] dexClasses;

    public DexParser(InputStream in) {
        this.in = new CountingInputStream(in, byteOrder);
    }

    public void parse() throws IOException {
        // read magic
        String magic = in.readChars(8);
        if (!magic.startsWith("dex\n")) {
            return;
        }
        int version = Integer.parseInt(magic.substring(4, 7));
        // now the version is 035
        if (version < 35) {
            // version 009 was used for the M3 releases of the Android platform (November–December 2007),
            // and version 013 was used for the M5 releases of the Android platform (February–March 2008)
            throw new ParserException("Dex file version: " + version + " is not supported");
        }

        // read header
        DexHeader header = readDexHeader();
        header.version = version;

        // read string pool
        long[] stringOffsets = readStringPool(header.stringIdsOff, header.stringIdsSize);

        // read types
        int[] typeIds = readTypes(header.typeIdsOff, header.typeIdsSize);

        // read classes
        DexClassStruct[] dexClassStructs = readClass(header.classDefsOff, header.classDefsSize);

        StringPool stringpool = readStrings(stringOffsets);

        String[] types = new String[typeIds.length];
        for (int i = 0; i < typeIds.length; i++) {
            types[i] = stringpool.get(typeIds[i]);
        }

        dexClasses = new DexClass[dexClassStructs.length];
        for (int i = 0; i < dexClasses.length; i++) {
            dexClasses[i] = new DexClass();
        }
        for (int i = 0; i < dexClassStructs.length; i++) {
            DexClassStruct dexClassStruct = dexClassStructs[i];
            DexClass dexClass = dexClasses[i];
            dexClass.setClassType(types[dexClassStruct.classIdx]);
            if (dexClassStruct.superclassIdx != NO_INDEX) {
                dexClass.setSuperClass(types[dexClassStruct.superclassIdx]);
            }
            dexClass.setAccessFlags(dexClassStruct.accessFlags);
        }
    }

    /**
     * read class info.
     */
    private DexClassStruct[] readClass(long classDefsOff, int classDefsSize) throws IOException {
        in.advanceTo(classDefsOff);

        DexClassStruct[] dexClassStructs = new DexClassStruct[classDefsSize];
        for (int i = 0; i < classDefsSize; i++) {
            DexClassStruct dexClassStruct = new DexClassStruct();
            dexClassStruct.classIdx = in.readInt();

            dexClassStruct.accessFlags = in.readInt();
            dexClassStruct.superclassIdx = in.readInt();

            dexClassStruct.interfacesOff = in.readUInt();
            dexClassStruct.sourceFileIdx = in.readInt();
            dexClassStruct.annotationsOff = in.readUInt();
            dexClassStruct.classDataOff = in.readUInt();
            dexClassStruct.staticValuesOff = in.readUInt();
            dexClassStructs[i] = dexClassStruct;
        }

        return dexClassStructs;
    }

    /**
     * read types.
     */
    private int[] readTypes(long typeIdsOff, int typeIdsSize) throws IOException {
        in.advanceTo(typeIdsOff);
        int[] typeIds = new int[typeIdsSize];
        for (int i = 0; i < typeIdsSize; i++) {
            typeIds[i] = (int) in.readUInt();
        }
        return typeIds;
    }

    /**
     * read string pool for dex file.
     * dex file string pool diff a bit with binary xml file or resource table.
     *
     * @param offsets
     * @return
     * @throws IOException
     */
    private StringPool readStrings(long[] offsets) throws IOException {
        // read strings.
        // in some apk, the strings' offsets may not well ordered. we sort it first

        StringPoolEntry[] entries = new StringPoolEntry[offsets.length];
        for (int i = 0; i < offsets.length; i++) {
            entries[i] = new StringPoolEntry(i, offsets[i]);
        }
        Arrays.sort(entries);

        String lastStr = null;
        long lastOffset = -1;
        StringPool stringpool = new StringPool(offsets.length);
        for (StringPoolEntry entry : entries) {
            if (entry.getOffset() == lastOffset) {
                stringpool.set(entry.getIdx(), lastStr);
                continue;
            }
            in.advanceTo(entry.getOffset());
            lastOffset = entry.getOffset();
            String str = readString();
            lastStr = str;
            stringpool.set(entry.getIdx(), str);
        }
        return stringpool;
    }

    /*
     * read string identifiers list.
     */
    private long[] readStringPool(long stringIdsOff, int stringIdsSize) throws IOException {
        in.advanceTo(stringIdsOff);
        long offsets[] = new long[stringIdsSize];
        for (int i = 0; i < stringIdsSize; i++) {
            offsets[i] = in.readUInt();
        }

        return offsets;
    }

    /**
     * read dex encoding string.
     */
    private String readString() throws IOException {
        // the length is char len, not byte len
        int strLen = readVarInts();
        try {
            return readString(strLen);
        } catch (UTFDataFormatException e) {
            return "";
        }
    }

    /**
     * read Modified UTF-8 encoding str.
     *
     * @param strLen the java-utf16-char len, not strLen nor bytes len.
     */
    private String readString(int strLen) throws IOException {
        char[] chars = new char[strLen];
        for (int i = 0; i < strLen; i++) {
            short a = in.readUByte();
            if ((a & 0x80) == 0) {
                // ascii char
                chars[i] = (char) a;
            } else if ((a & 0xe0) == 0xc0) {
                // read one more
                short b = in.readUByte();
                chars[i] = (char) (((a & 0x1F) << 6) | (b & 0x3F));
            } else if ((a & 0xf0) == 0xe0) {
                short b = in.readUByte();
                short c = in.readUByte();
                chars[i] = (char) (((a & 0x0F) << 12) | ((b & 0x3F) << 6) | (c & 0x3F));
            } else if ((a & 0xf0) == 0xf0) {
                throw new UTFDataFormatException();
            } else {
                throw new UTFDataFormatException();
            }
            if (chars[i] == 0) {
                // the end of string.
            }
        }

        return new String(chars);
    }


    /**
     * read varints.
     *
     * @return
     * @throws IOException
     */
    private int readVarInts() throws IOException {
        int i = 0;
        int count = 0;
        short s;
        do {
            if (count > 4) {
                throw new ParserException("read varints error.");
            }
            s = in.readUByte();
            i |= (s & 0x7f) << (count * 7);
            count++;
        } while ((s & 0x80) != 0);

        return i;
    }

    private DexHeader readDexHeader() throws IOException {

        // check sum. skip
        in.readUInt();

        // signature skip
        in.readBytes(DexHeader.kSHA1DigestLen);

        DexHeader header = new DexHeader();
        header.fileSize = in.readUInt();
        header.headerSize = in.readUInt();

        // skip?
        in.readUInt();

        // static link data
        header.linkSize = in.readUInt();
        header.linkOff = in.readUInt();

        // the map data is just the same as dex header.
        header.mapOff = in.readUInt();

        header.stringIdsSize = in.readInt();
        header.stringIdsOff = in.readUInt();

        header.typeIdsSize = in.readInt();
        header.typeIdsOff = in.readUInt();

        header.protoIdsSize = in.readInt();
        header.protoIdsOff = in.readUInt();

        header.fieldIdsSize = in.readInt();
        header.fieldIdsOff = in.readUInt();

        header.methodIdsSize = in.readInt();
        header.methodIdsOff = in.readUInt();

        header.classDefsSize = in.readInt();
        header.classDefsOff = in.readUInt();

        header.dataSize = in.readInt();
        header.dataOff = in.readUInt();

        in.advanceTo(header.headerSize);

        return header;
    }

    public DexClass[] getDexClasses() {
        return dexClasses;
    }

}
```


Overlapping Code:
```
{
private CountingInputStream in;
private ByteOrder byteOrder = ByteOrder.LITTLE;
private static final int NO_INDEX = 0xffffffff;
private DexClass[] dexClasses;
public DexParser(InputStream in) {
this.in = new CountingInputStream(in, byteOrder);
}
public void parse() throws IOException {
// read magic
String magic = in.readChars(8);
if (!magic.startsWith("dex\n")) {
return;
}
int version = Integer.parseInt(magic.substring(4, 7));
// now the version is 035
if (version < 35) {
// version 009 was used for the M3 releases of the Android platform (November–December 2007),
// and version 013 was used for the M5 releases of the Android platform (February–March 2008)
throw new ParserException("Dex file version: " + version + " is not supported");
}
// read header
DexHeader header = readDexHeader();
header.version = version;
// read string pool
long[] stringOffsets = readStringPool(header.stringIdsOff, header.stringIdsSize);
// read types
int[] typeIds = readTypes(header.typeIdsOff, header.typeIdsSize);
// read classes
DexClassStruct[] dexClassStructs = readClass(header.classDefsOff, header.classDefsSize);
StringPool stringpool = readStrings(stringOffsets);
String[] types = new String[typeIds.length];
for (int i = 0; i < typeIds.length; i++) {
types[i] = stringpool.get(typeIds[i]);
}
dexClasses = new DexClass[dexClassStructs.length];
for (int i = 0; i < dexClasses.length; i++) {
dexClasses[i] = new DexClass();
}
for (int i = 0; i < dexClassStructs.length; i++) {
DexClassStruct dexClassStruct = dexClassStructs[i];
DexClass dexClass = dexClasses[i];
dexClass.setClassType(types[dexClassStruct.classIdx]);
if (dexClassStruct.superclassIdx != NO_INDEX) {
dexClass.setSuperClass(types[dexClassStruct.superclassIdx]);
}
dexClass.setAccessFlags(dexClassStruct.accessFlags);
}
}
/**
* read class info.
*/
private DexClassStruct[] readClass(long classDefsOff, int classDefsSize) throws IOException {
in.advanceTo(classDefsOff);
DexClassStruct[] dexClassStructs = new DexClassStruct[classDefsSize];
for 
```
<Overlap Ratio: 0.9877149877149877>

---

