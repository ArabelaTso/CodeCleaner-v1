--- 0 --
Question ID: 6a74a054baab0863fb72b0acca404e4117016e5b
Original Code:
```
public class OddEvenLinkedList {

    public ListNode oddEvenList(ListNode head) {

        if (head == null || head.next == null) return head;

        ListNode oddNode = head;
        ListNode evenNode = head.next;
        ListNode firstEvenNode = head.next;

        while (oddNode.next != null && evenNode.next != null) {
            ListNode tmp = oddNode;
            oddNode = oddNode.next.next;
            tmp.next = oddNode;
            tmp = evenNode;
            evenNode = evenNode.next.next;
            tmp.next = evenNode;
        }

        oddNode.next = firstEvenNode;
        evenNode.next = null;

        return head;

    }

}
```


Overlapping Code:
```
ic class OddEvenLinkedList {
public ListNode oddEvenList(ListNode head) {
if (head == null || head.next == null) return head;
ListNode oddNode = head;
ListNode evenNode = head.next;
ListNode firstEvenNode = head.next;
while (oddNode.next != null && evenNode.next != null) {
ListNode tmp = oddNode;
oddNode = oddNode.next.next;
tmp.next = oddNode;
tmp = evenNode;
evenNode = evenNode.next.next;
tmp.next = evenNode;
}
oddNode.next = firstEvenNode;
evenNode.next = null;
return head;

```
<Overlap Ratio: 0.9856850715746421>

---

--- 1 --
Question ID: 77a6eca34a3c83b9075c359c5223261f562baeee
Original Code:
```
public class Cache
{
    private final Logger LOG= LoggerFactory.getLogger(Cache.class);
    private static final long DECAY = TimeUnit.SECONDS.toMillis(30);
    private final Map<CacheEntry, Object> cacheMap = new HashMap<>();
    private final Map<CacheEntry, Supplier<Object>> getterMap = new HashMap<>();

    {
        LOG.info("Creating a new cache");
    }
    public void registerSupplier(String key, Supplier<Object> function)
    {
        getterMap.put(new CacheEntry(key, -1), function);
    }

    public <T> T get(String key)
    {
        for (Map.Entry<CacheEntry, Object> entry : cacheMap.entrySet())
        {
            if (entry.getKey().getKey().equals(key))
            {
                long time = entry.getKey().getCreated();
                if (time + DECAY < System.currentTimeMillis())
                {
                    if (!getterMap.containsKey(entry.getKey()))
                    {
                        return null;
                    }
                    LOG.info("Recalculating the value for {}",key);
                    Object val = getterMap.get(entry.getKey()).get();
                    CacheEntry newEntry = new CacheEntry(key,
                            System.currentTimeMillis());
                    cacheMap.put(newEntry, val);
                    return (T) val;
                } else
                {
                    LOG.info("Retrieving cached value for {}",key);
                    return (T) entry.getValue();
                }
            }
        }
        CacheEntry keyEntry = new CacheEntry(key, DECAY);
        if (!getterMap.containsKey(keyEntry))
        {
            LOG.info("No information of values found for {}",key);
            return null;
        }
        LOG.info("Calculating the value for {}",key);
        Object val = getterMap.get(keyEntry).get();
        CacheEntry newEntry = new CacheEntry(key, System.currentTimeMillis());
        cacheMap.put(newEntry, val);
        return (T) val;
    }

    private static class CacheEntry
    {

        private final String key;
        private final long created;

        public CacheEntry(String key, long created)
        {
            this.key = key;
            this.created = created;
        }

        public long getCreated()
        {
            return created;
        }

        public String getKey()
        {
            return key;
        }

        @Override
        public int hashCode()
        {
            int hash = 7;
            hash = 53 * hash + Objects.hashCode(this.key);
            return hash;
        }

        @Override
        public boolean equals(Object obj)
        {
            if (this == obj)
            {
                return true;
            }
            if (obj == null)
            {
                return false;
            }
            if (getClass() != obj.getClass())
            {
                return false;
            }
            final CacheEntry other = (CacheEntry) obj;
            if (!Objects.equals(this.key, other.key))
            {
                return false;
            }
            return true;
        }

    }

}
```


Overlapping Code:
```
 class Cache
{
private final Logger LOG= LoggerFactory.getLogger(Cache.class);
private static final long DECAY = TimeUnit.SECONDS.toMillis(30);
private final Map<CacheEntry, Object> cacheMap = new HashMap<>();
private final Map<CacheEntry, Supplier<Object>> getterMap = new HashMap<>();
{
LOG.info("Creating a new cache");
}
public void registerSupplier(String key, Supplier<Object> function)
{
getterMap.put(new CacheEntry(key, -1), function);
}
public <T> T get(String key)
{
for (Map.Entry<CacheEntry, Object> entry : cacheMap.entrySet())
{
if (entry.getKey().getKey().equals(key))
{
long time = entry.getKey().getCreated();
if (time + DECAY < System.currentTimeMillis())
{
if (!getterMap.containsKey(entry.getKey()))
{
return null;
}
LOG.info("Recalculating the value for {}",key);
Object val = getterMap.get(entry.getKey()).get();
CacheEntry newEntry = new CacheEntry(key,
System.currentTimeMillis());
cacheMap.put(newEntry, val);
return (T) val;
} else
{
LOG.info("Retrieving cached value for {}",key);
return (T) entry.getValue();
}
}
}
CacheEntry keyEntry = new CacheEntry(key, DECAY);
if (!getterMap.containsKey(keyEntry))
{
LOG.info("No information of values found for {}",key);
return null;
}
LOG.info("Calculating the value for {}",key);
Object val = getterMap.get(keyEntry).get();
CacheEntry newEntry = new CacheEntry(key, System.currentTimeMillis());
cacheMap.put(newEntry, val);
return (T) val;
}
private static class CacheEntry
{
private final String key;
private final long created;
public CacheEntry(String key, long created)
{
this.key = key;
this.created = created;
}
public long getCreated()
{
return created;
}
public String getKey()
{
return key;
}
@Override
public int hashCode()
{
int hash = 7;
hash
```
<Overlap Ratio: 0.9965317919075144>

---

--- 2 --
Question ID: 0090665434bd1deaf7c0780958851f5dd53cac27
Original Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = SpringbootApplication.class)
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-test.properties")
public class UserControllerTest
{
    /**
     * Control de los E-mail.
     */
    @MockBean
    public JavaMailSender emailSender;
    /**
     * Repositorio de usuarios.
     */
    @MockBean
    public UserRepository userRepository;
    /**
     * MVC de pruebas.
     */
    @Autowired
    private MockMvc mvc;
    /**
     * Instancia del Contexto del servlet.
     */
    @Autowired
    ServletContext servletContext;
    /**
     * Instancia del servicio de emails
     */
    @Autowired
    private MailService mailService;
    /**
     * Instancia del servicio i18n
     */
    @Autowired
    private MessageSource messageSource;
    /**
     * Instancia del servicio de usuarios.
     */
    @Autowired
    private UserService userService;
    /**
     * Instancia del servicio de artículos.
     */
    @Autowired
    private ArticleService articleService;
    /**
     * Instancia del servicio de login.
     */
    @Autowired
    private UserAccessService userDetailsService;
    /**
     * Instancia del servicio de explorador de archivos.
     */
    @Autowired
    private BrowserService browserService;
    
    /**
     * Setup del test.
     * 
     * @throws Exception 
     */
    @Before
    public void setUp() throws Exception
    {
        // E-MAIL
        Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session)null));
        
        // Usuario
        User user = new User();
        user.setId(1);
        user.setEmail("admin@test.com");
        user.setNickname("admin");
        user.setActive(Boolean.TRUE);
        user.setUserRole("ROLE_USER");
        user.setUkey("UKEYTEST");
        user.setPassword("PASSWORD");
        
        // Repositorios
        // Usuarios
        Mockito.when(userRepository.findByNickname(Mockito.eq(user.getNickname()))).thenReturn(user);
        Mockito.when(userRepository.findByNickname(Mockito.eq("testing"))).thenReturn(null);
        Mockito.when(userRepository.findByEmail(Mockito.eq(user.getEmail()))).thenReturn(user);
        Mockito.when(userRepository.findByUkey(Mockito.eq(user.getUkey()))).thenReturn(user);
        Mockito.when(userRepository.findByUkey(Mockito.eq("UKEYNONE"))).thenReturn(null);
        Mockito.when(userRepository.findById(Mockito.eq(1))).thenReturn(Optional.of(user));
        Mockito.when(userRepository.save((User) argThat(hasProperty("id", is(1))))).thenReturn(user);
    }
    
    /**
     * Contexto.
     * @throws Exception 
     */
    @Test
    public void contextLoads() throws Exception
    {
        assertThat(servletContext).isNotNull();
        assertThat(mailService).isNotNull();
        assertThat(messageSource).isNotNull();
        assertThat(userService).isNotNull();
        assertThat(articleService).isNotNull();
        assertThat(userDetailsService).isNotNull();
        assertThat(browserService).isNotNull();
    }
    /**
     * Prueba de login sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessLoginNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/login"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/login"));
    }
    /**
     * Prueba de login con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessLoginUser() throws Throwable
    {
        mvc
            .perform(get("/user/login"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de logout sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessLogoutNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/logout"))
            .andExpect(status().isUnauthorized());;
    }
    /**
     * Prueba de logout con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessLogoutUser() throws Throwable
    {
        mvc
            .perform(get("/user/logout"))
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/"));
    }
    /**
     * Prueba de registro sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessRegisterNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/register"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/register"));
    }
    /**
     * Prueba de registro con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessRegisterUser() throws Throwable
    {
        mvc
            .perform(get("/user/register"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Registro sin usuario.
     * @throws Throwable 
     */
    @Test
    public void accessRegisterPostOk() throws Throwable
    {
        mvc
            .perform(post("/user/register")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
                .param("email", "test2@test.com")
                .param("emailRepeat", "test2@test.com")
                .param("nickname", "testing")
            )
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/"))
            .andExpect(model().hasNoErrors());
    }
    /**
     * Registro con usuario.
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessRegisterPostUser() throws Throwable
    {
        mvc
            .perform(post("/user/register")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
            )
            .andExpect(status().isUnauthorized());
    }
    /**
     * Registro sin csrf.
     * @throws Throwable 
     */
    @Test
    public void accessRegisterPostNoCsrf() throws Throwable
    {
        mvc
            .perform(post("/user/register")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            )
            .andExpect(status().isForbidden());
    }
    /**
     * Prueba de activar la cuenta sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessAccountActivateNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/?k=UKEYTEST"))
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/"));
    }
    /**
     * Prueba de activar la cuenta con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessAccountActivateUser() throws Throwable
    {
        mvc
            .perform(get("/user/?k=UKEYTEST"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de recuperar sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessRecoverNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/recover?k=UKEYTEST"))
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/user/profile/password"));
    }
    /**
     * Prueba de recuperar sin usuario pero UKEY incorrecta
     * @throws Throwable 
     */
    @Test
    public void accessRecoverNoUserNone() throws Throwable
    {
        mvc
            .perform(get("/user/recover?k=UKEYNONE"))
            .andExpect(status().isNotFound());
    }
    /**
     * Prueba de recuperar con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessRecoverUser() throws Throwable
    {
        mvc
            .perform(get("/user/recover?k=UKEYNONE"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de Contraseña olvidada sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessForgotNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/forgot"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/forgot"));
    }
    /**
     * Prueba de Contraseña olvidada con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessForgotUser() throws Throwable
    {
        mvc
            .perform(get("/user/forgot"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Recuperar contraseña sin usuario.
     * @throws Throwable 
     */
    @Test
    public void accessForgotPostOk() throws Throwable
    {
        mvc
            .perform(post("/user/forgot")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
                .param("email", "admin@test.com")
            )
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/"))
            .andExpect(model().hasNoErrors());
    }
    /**
     * Recuperar contraseña con usuario.
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessForgotPostUser() throws Throwable
    {
        mvc
            .perform(post("/user/forgot")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
            )
            .andExpect(status().isUnauthorized());
    }
    /**
     * Recuperar contraseña sin csrf.
     * @throws Throwable 
     */
    @Test
    public void accessForgotPostNoCsrf() throws Throwable
    {
        mvc
            .perform(post("/user/forgot")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            )
            .andExpect(status().isForbidden());
    }
    /**
     * Prueba de Acceso al perfil sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessProfileNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/profile"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de Acceso al perfil con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessProfileUser() throws Throwable
    {
        mvc
            .perform(get("/user/profile"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/profile"));
    }
    /**
     * Perfil sin usuario.
     * @throws Throwable 
     */
    @Test
    public void accessProfilePostNoUser() throws Throwable
    {
        mvc
            .perform(post("/user/profile")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
            )
            .andExpect(status().isUnauthorized());
    }
    /**
     * Perfil con usuario.
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessProfilePostOk() throws Throwable
    {
        mvc
            .perform(post("/user/profile")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
                .param("id", "1")
                .param("nickname", "testing")
                .param("avatar", "test")
            )
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/user/profile"))
            .andExpect(model().hasNoErrors());
    }
    /**
     * Perfil sin csrf.
     * @throws Throwable 
     */
    @Test
        public void accessProfilePostNoCsrf() throws Throwable
    {
        mvc
            .perform(post("/user/profile")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            )
            .andExpect(status().isForbidden());
    }
    /**
     * Prueba de Acceso al perfil - contraseña sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessProfilePasswordNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/profile/password"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de Acceso al perfil - contraseña con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessProfilePasswordUser() throws Throwable
    {
        mvc
            .perform(get("/user/profile/password"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/password"));
    }
    /**
     * Recuperar contraseña sin usuario.
     * @throws Throwable 
     */
    @Test
    public void accessProfilePasswordPostNoUser() throws Throwable
    {
        mvc
            .perform(post("/user/profile/password")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
            )
            .andExpect(status().isUnauthorized());
    }
    /**
     * Recuperar contraseña con usuario.
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessProfilePasswordPostOk() throws Throwable
    {
        mvc
            .perform(post("/user/profile/password")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                .with(csrf())
                .param("id", "1")
                .param("password", "PASSWORD")
                .param("passwordRepeat", "PASSWORD")
            )
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/user/profile"))
            .andExpect(model().hasNoErrors());
    }
    /**
     * Perfil sin csrf.
     * @throws Throwable 
     */
    @Test
        public void accessProfilePasswordPostNoCsrf() throws Throwable
    {
        mvc
            .perform(post("/user/profile/password")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            )
            .andExpect(status().isForbidden());
    }
    /**
     * Prueba de Acceso a los avatares - contraseña sin usuario
     * @throws Throwable 
     */
    @Test
    public void accessAvatarsNoUser() throws Throwable
    {
        mvc
            .perform(get("/user/avatars?field=test"))
            .andExpect(status().isUnauthorized());
    }
    /**
     * Prueba de Acceso a los avatares - contraseña con usuario
     * @throws Throwable 
     */
    @Test
    @WithMockUser(username = "admin@test.com", roles = {"USER"})
    public void accessAvatarsUser() throws Throwable
    {
        mvc
            .perform(get("/user/avatars?field=test"))
            .andExpect(status().isOk())
            .andExpect(view().name("user/avatars"));
    }
}
```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest(classes = SpringbootApplication.class)
@AutoConfigureMockMvc
@TestPropertySource(locations = "classpath:application-test.properties")
public class UserControllerTest
{
/**
* Control de los E-mail.
*/
@MockBean
public JavaMailSender emailSender;
/**
* Repositorio de usuarios.
*/
@MockBean
public UserRepository userRepository;
/**
* MVC de pruebas.
*/
@Autowired
private MockMvc mvc;
/**
* Instancia del Contexto del servlet.
*/
@Autowired
ServletContext servletContext;
/**
* Instancia del servicio de emails
*/
@Autowired
private MailService mailService;
/**
* Instancia del servicio i18n
*/
@Autowired
private MessageSource messageSource;
/**
* Instancia del servicio de usuarios.
*/
@Autowired
private UserService userService;
/**
* Instancia del servicio de artículos.
*/
@Autowired
private ArticleService articleService;
/**
* Instancia del servicio de login.
*/
@Autowired
private UserAccessService userDetailsService;
/**
* Instancia del servicio de explorador de archivos.
*/
@Autowired
private BrowserService browserService;

/**
* Setup del test.
* 
* @throws Exception 
*/
@Before
public void setUp() throws Exception
{
// E-MAIL
Mockito.when(emailSender.createMimeMessage()).thenReturn(new MimeMessage((Session)null));

// Usuario
User user = new User();
user.setId(1);
user.setEmail(");
user.setActive(Boolean.TRUE);
user.setUserRole("ROLE_USER");
user.setUkey("UKEYTEST");
user.setPassword("PASSWORD");

// Repositorios
// Usuarios
Mockito.when(userRepository.findByNickname(Mockito.eq(user.getNickname()))).thenReturn(user);
Mockito.when(userRepository.findByNickname(Mockito.eq("testing"))).thenReturn(null);
Mockito.when(userRepository.findByEmail(Mockito.eq(user.getEmail()))).thenReturn(user);
Mockito.when(userRepository.findByUkey(Mockito.eq(user.getUkey()))).thenReturn(user);
Mockito.when(userRepository.findByUkey(Mockito.eq("UKEYNONE"))).thenReturn(null);
Mockito.when(userRepository.findById(Mockito.eq(1))).thenReturn(Op
```
<Overlap Ratio: 0.9660688317983519>

---

--- 3 --
Question ID: b4e86ebccc11e0a83580d62e69b75ac5e6832dd8
Original Code:
```
public class AuthenticationUserService implements UserDetailsService {

  private UserRepository userRepository;

  public AuthenticationUserService(UserRepository userRepository) {
    this.userRepository = userRepository;
  }

  @Override
  public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {
    User user = userRepository.findById(id);
    if (user == null) {
      throw new UsernameNotFoundException("Not found: " + id);
    }
    return new AuthenticationUser(user);
  }
}
```


Overlapping Code:
```
lic class AuthenticationUserService implements UserDetailsService {
private UserRepository userRepository;
public AuthenticationUserService(UserRepository userRepository) {
this.userRepository = userRepository;
}
@Override
public UserDetails loadUserByUsername(String id) throws UsernameNotFoundException {
User user = userRepository.findById(id);
if (user == null) {
throw new UsernameNotFoundException("Not found: " + id);
}
return new Authenticati
```
<Overlap Ratio: 0.9574468085106383>

---

--- 4 --
Question ID: e103f7081c1393af45c4372fcadfd297eff78a10
Original Code:
```
public class tmtrafficpolicy_stats extends base_resource
{
	private String name;
	private String clearstats;
	private Long pipolicyhits;
	private Long pipolicyhitsrate;

	/**
	* <pre>
	* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.
	* </pre>
	*/
	public void set_name(String name) throws Exception{
		this.name = name;
	}

	/**
	* <pre>
	* The name of the TM traffic policy for which statistics will be displayed.  If not given statistics are shown for all policies.<br> Minimum length =  1
	* </pre>
	*/
	public String get_name() throws Exception {
		return this.name;
	}

	/**
	* <pre>
	* Clear the statsistics / counters
	* </pre>
	*/
	public void set_clearstats(String clearstats) throws Exception{
		this.clearstats = clearstats;
	}

	/**
	* <pre>
	* Clear the statsistics / counters.<br> Possible values = basic, full
	* </pre>
	*/
	public String get_clearstats() throws Exception {
		return this.clearstats;
	}

	/**
	* <pre>
	* Rate (/s) counter for pipolicyhits
	* </pre>
	*/
	public Long get_pipolicyhitsrate() throws Exception {
		return this.pipolicyhitsrate;
	}

	/**
	* <pre>
	* Number of hits on the policy
	* </pre>
	*/
	public Long get_pipolicyhits() throws Exception {
		return this.pipolicyhits;
	}

	/**
	* <pre>
	* converts nitro response into object and returns the object array in case of get request.
	* </pre>
	*/
	protected base_resource[] get_nitro_response(nitro_service service, String response) throws Exception{
		tmtrafficpolicy_response result = (tmtrafficpolicy_response) service.get_payload_formatter().string_to_resource(tmtrafficpolicy_response.class, response);
		if(result.errorcode != 0) {
			if (result.errorcode == 444) {
				service.clear_session();
			}
			if(result.severity != null)
			{
				if (result.severity.equals("ERROR"))
					throw new nitro_exception(result.message,result.errorcode);
			}
			else
			{
				throw new nitro_exception(result.message,result.errorcode);
			}
		}
		return result.tmtrafficpolicy;
	}

	/**
	* <pre>
	* Returns the value of object identifier argument
	* </pre>
	*/

	protected String get_object_name() {
		return this.name;
	}

	/**
	* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.
	*/
	public static tmtrafficpolicy_stats[] get(nitro_service service) throws Exception{
		tmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();
		tmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service);
		return response;
	}

	/**
	* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.
	*/
	public static tmtrafficpolicy_stats[] get(nitro_service service, options option) throws Exception{
		tmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();
		tmtrafficpolicy_stats[] response = (tmtrafficpolicy_stats[])obj.stat_resources(service,option);
		return response;
	}

	/**
	* Use this API to fetch statistics of tmtrafficpolicy_stats resource of given name .
	*/
	public static tmtrafficpolicy_stats get(nitro_service service, String name) throws Exception{
		tmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();
		obj.set_name(name);
		tmtrafficpolicy_stats response = (tmtrafficpolicy_stats) obj.stat_resource(service);
		return response;
	}

	public static class clearstatsEnum {
		public static final String basic = "basic";
		public static final String full = "full";
	}
}
```


Overlapping Code:
```
_stats extends base_resource
{
private String name;
private String clearstats;
private Long pipolicyhits;
private Long pipolicyhitsrate;
/**
* <pre>
* The name of the TM traffic policy for which statistics will be displayed. If not given statistics are shown for all policies.
* </pre>
*/
public void set_name(String name) throws Exception{
this.name = name;
}
/**
* <pre>
* The name of the TM traffic policy for which statistics will be displayed. If not given statistics are shown for all policies.<br> Minimum length = 1
* </pre>
*/
public String get_name() throws Exception {
return this.name;
}
/**
* <pre>
* Clear the statsistics / counters
* </pre>
*/
public void set_clearstats(String clearstats) throws Exception{
this.clearstats = clearstats;
}
/**
* <pre>
* Clear the statsistics / counters.<br> Possible values = basic, full
* </pre>
*/
public String get_clearstats() throws Exception {
return this.clearstats;
}
/**
* <pre>
* Rate (/s) counter for pipolicyhits
* </pre>
*/
public Long get_pipolicyhitsrate() throws Exception {
return this.pipolicyhitsrate;
}
/**
* <pre>
* Number of hits on the policy
* </pre>
*/
public Long get_pipolicyhits() throws Exception {
return this.pipolicyhits;
}
/**
* <pre>
* converts nitro response into object and returns the object array in case of get request.
* </pre>
*/
protected base_resource[] get_nitro_response(nitro_service service, String response) throws Exception{
tmtrafficpolicy_response result = (tmtrafficpolicy_response) service.get_payload_formatter().string_to_resource(tmtrafficpolicy_response.class, response);
if(result.errorcode != 0) {
if (result.errorcode == 444) {
service.clear_session();
}
if(result.severity != null)
{
if (result.severity.equals("ERROR"))
throw new nitro_exception(result.message,result.errorcode);
}
else
{
throw new nitro_exception(result.message,result.errorcode);
}
}
return result.tmtrafficpolicy;
}
/**
* <pre>
* Returns the value of object identifier argument
* </pre>
*/
protected String get_object_name() {
return this.name;
}
/**
* Use this API to fetch the statistics of all tmtrafficpolicy_stats resources that are configured on netscaler.
*/
public static tmtrafficpolicy_stats[] get(nitro_service service) throws Exception{
tmtrafficpolicy_stats obj = new tmtrafficpolicy_stats();
tmtrafficpolicy_stats[] response = 
```
<Overlap Ratio: 0.9859872611464968>

---

--- 5 --
Question ID: 8ee5ef0c8ee0282c20642cb3d1e484e0a0cae12b
Original Code:
```
public class JvmMetricsStartTest {

    private MetricRegistry metricRegistry;
    private JvmMetricsStart callback;

    @Before
    public void before() {
        metricRegistry = new MetricRegistry();
        callback = new JvmMetricsStart(metricRegistry);
    }

    @Test
    public void testOnBrokerStart_metricsRegistered() throws Exception {

        callback.onBrokerStart();

        final SortedSet<String> names = metricRegistry.getNames();

        //check for at least one metric from each metric set
        assertTrue(names.contains("com.hivemq.jvm.buffer-pool.direct.count"));
        assertTrue(names.contains("com.hivemq.jvm.buffer-pool.mapped.count"));
        assertTrue(names.contains("com.hivemq.jvm.class-loader.loaded"));
        assertTrue(names.contains("com.hivemq.jvm.file-descriptor.ratio"));
        assertTrue(names.contains("com.hivemq.jvm.garbage-collector.PS-MarkSweep.count"));
        assertTrue(names.contains("com.hivemq.jvm.garbage-collector.PS-Scavenge.count"));
        assertTrue(names.contains("com.hivemq.jvm.memory.heap.max"));
        assertTrue(names.contains("com.hivemq.jvm.memory.non-heap.max"));
        assertTrue(names.contains("com.hivemq.jvm.memory.total.max"));
        assertTrue(names.contains("com.hivemq.jvm.threads.count"));
    }
}
```


Overlapping Code:
```
vmMetricsStartTest {
private MetricRegistry metricRegistry;
private JvmMetricsStart callback;
@Before
public void before() {
metricRegistry = new MetricRegistry();
callback = new JvmMetricsStart(metricRegistry);
}
@Test
public void testOnBrokerStart_metricsRegistered() throws Exception {
callback.onBrokerStart();
final SortedSet<String> names = metricRegistry.getNames();
//check for at least one metric from each metric set
assertTrue(names.contains("com.hivemq.jvm.buffer-pool.direct.count"));
assertTrue(names.contains("com.hivemq.jvm.buffer-pool.mapped.count"));
assertTrue(names.contains("com.hivemq.jvm.class-loader.loaded"));
assertTrue(names.contains("com.hivemq.jvm.file-descriptor.ratio"));
assertTrue(names.contains("com.hivemq.jvm.garbage-collector.PS-MarkSweep.count"));
assertTrue(names.contains("com.hivemq.jvm.garbage-collector.PS-Scavenge.count"));
assertTrue(names.contains("com.hivemq.jvm.memory.heap.max"));
assertTrue(names.contains("com.hivemq.jvm.memory.non-heap.max"));
assertTrue(names.contains("com.hivemq.jvm.memory.total.max"));
assertTrue(names.contains("com.hivemq.jvm
```
<Overlap Ratio: 0.9683098591549296>

---

--- 6 --
Question ID: b086381ed79de7165255cb295f777c59bb9aacaf
Original Code:
```
public class MethodHierarchyBrowser extends MethodHierarchyBrowserBase {
  private static final Logger LOG = Logger.getInstance(MethodHierarchyBrowser.class);

  public MethodHierarchyBrowser(final Project project, final PsiMethod method) {
    super(project, method);
  }

  @Override
  protected void createTrees(@NotNull Map<String, JTree> trees) {
    final JTree tree = createTree(false);
    ActionGroup group = (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_METHOD_HIERARCHY_POPUP);
    PopupHandler.installPopupHandler(tree, group, ActionPlaces.METHOD_HIERARCHY_VIEW_POPUP, ActionManager.getInstance());
                    
    final BaseOnThisMethodAction action = new BaseOnThisMethodAction();
    action.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_METHOD_HIERARCHY).getShortcutSet(), tree);

    trees.put(METHOD_TYPE, tree);
  }

  @Override
  protected JPanel createLegendPanel() {
    return createStandardLegendPanel(IdeBundle.message("hierarchy.legend.method.is.defined.in.class"),
                                     IdeBundle.message("hierarchy.legend.method.defined.in.superclass"),
                                     IdeBundle.message("hierarchy.legend.method.should.be.defined"));
  }

  @Override
  protected PsiElement getElementFromDescriptor(@NotNull final HierarchyNodeDescriptor descriptor) {
    if (descriptor instanceof MethodHierarchyNodeDescriptor) {
      return ((MethodHierarchyNodeDescriptor)descriptor).getTargetElement();
    }
    return null;
  }

  @Override
  protected boolean isApplicableElement(@NotNull final PsiElement psiElement) {
    return psiElement instanceof PsiMethod;
  }

  @Override
  protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {
    if (!METHOD_TYPE.equals(typeName)) {
      LOG.error("unexpected type: " + typeName);
      return null;
    }
    return new MethodHierarchyTreeStructure(myProject, (PsiMethod)psiElement, getCurrentScopeType());
  }

  @Override
  protected Comparator<NodeDescriptor> getComparator() {
    return JavaHierarchyUtil.getComparator(myProject);
  }

  public PsiMethod getBaseMethod() {
    return (PsiMethod)getHierarchyBase();
  }

  public static final class BaseOnThisMethodAction extends MethodHierarchyBrowserBase.BaseOnThisMethodAction { }
}
```


Overlapping Code:
```
 MethodHierarchyBrowser extends MethodHierarchyBrowserBase {
private static final Logger LOG = Logger.getInstance(MethodHierarchyBrowser.class);
public MethodHierarchyBrowser(final Project project, final PsiMethod method) {
super(project, method);
}
@Override
protected void createTrees(@NotNull Map<String, JTree> trees) {
final JTree tree = createTree(false);
ActionGroup group = (ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_METHOD_HIERARCHY_POPUP);
PopupHandler.installPopupHandler(tree, group, ActionPlaces.METHOD_HIERARCHY_VIEW_POPUP, ActionManager.getInstance());

final BaseOnThisMethodAction action = new BaseOnThisMethodAction();
action.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_METHOD_HIERARCHY).getShortcutSet(), tree);
trees.put(METHOD_TYPE, tree);
}
@Override
protected JPanel createLegendPanel() {
return createStandardLegendPanel(IdeBundle.message("hierarchy.legend.method.is.defined.in.class"),
IdeBundle.message("hierarchy.legend.method.defined.in.superclass"),
IdeBundle.message("hierarchy.legend.method.should.be.defined"));
}
@Override
protected PsiElement getElementFromDescriptor(@NotNull final HierarchyNodeDescriptor descriptor) {
if (descriptor instanceof MethodHierarchyNodeDescriptor) {
return ((MethodHierarchyNodeDescriptor)descriptor).getTargetElement();
}
return null;
}
@Override
protected boolean isApplicableElement(@NotNull final PsiElement psiElement) {
return psiElement instanceof PsiMethod;
}
@Override
protected HierarchyTreeStructure createHierarchyTreeStructure(@NotNull final String typeName, @NotNull final PsiElement psiElement) {
if (!METHOD_TYPE.equals(typeName)) {
LOG.error("unexpected type: " + typeName);
return null;
}
return new MethodHierarchyTreeStructure(myProject, (PsiMethod)psiElement, getCurrentScopeType());
}
@Override
protected Comparator<NodeDescriptor> getComparator() {
return JavaHierarchyUtil.getComparator(myProject);
}
public PsiMethod getBaseMethod() {
return (PsiMethod)getHierarchyBase();
}
public static final class BaseOnThisMethodAction extends MethodHierarchyB
```
<Overlap Ratio: 0.9762900976290098>

---

--- 7 --
Question ID: 2b26f648b10ebca13e45c211468cfe0df4123a92
Original Code:
```
public class ProcessingTile
{

	public ProcessingTile(String s)
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #25  <Method void Object()>
		mCreateTime = 0L;
	//    2    4:aload_0         
	//    3    5:lconst_0        
	//    4    6:putfield        #27  <Field long mCreateTime>
		setParams(s);
	//    5    9:aload_0         
	//    6   10:aload_1         
	//    7   11:invokespecial   #30  <Method void setParams(String)>
	//    8   14:return          
	}

	public static ProcessingTile obtain(String s)
	{
		ProcessingTile processingtile = (ProcessingTile)M_POOL.acquire();
	//    0    0:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>
	//    1    3:invokevirtual   #36  <Method Object Pools$SynchronizedPool.acquire()>
	//    2    6:checkcast       #2   <Class ProcessingTile>
	//    3    9:astore_1        
		if(processingtile != null)
	//*   4   10:aload_1         
	//*   5   11:ifnull          21
		{
			processingtile.setParams(s);
	//    6   14:aload_1         
	//    7   15:aload_0         
	//    8   16:invokespecial   #30  <Method void setParams(String)>
			return processingtile;
	//    9   19:aload_1         
	//   10   20:areturn         
		} else
		{
			return new ProcessingTile(s);
	//   11   21:new             #2   <Class ProcessingTile>
	//   12   24:dup             
	//   13   25:aload_0         
	//   14   26:invokespecial   #38  <Method void ProcessingTile(String)>
	//   15   29:areturn         
		}
	}

	private void setParams(String s)
	{
		mKeyName = s;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #40  <Field String mKeyName>
		mCreateTime = System.currentTimeMillis() / 1000L;
	//    3    5:aload_0         
	//    4    6:invokestatic    #46  <Method long System.currentTimeMillis()>
	//    5    9:ldc2w           #47  <Long 1000L>
	//    6   12:ldiv            
	//    7   13:putfield        #27  <Field long mCreateTime>
	//    8   16:return          
	}

	public void recycle()
	{
		mKeyName = null;
	//    0    0:aload_0         
	//    1    1:aconst_null     
	//    2    2:putfield        #40  <Field String mKeyName>
		mCreateTime = 0L;
	//    3    5:aload_0         
	//    4    6:lconst_0        
	//    5    7:putfield        #27  <Field long mCreateTime>
		M_POOL.release(((Object) (this)));
	//    6   10:getstatic       #21  <Field Pools$SynchronizedPool M_POOL>
	//    7   13:aload_0         
	//    8   14:invokevirtual   #53  <Method boolean Pools$SynchronizedPool.release(Object)>
	//    9   17:pop             
	//   10   18:return          
	}

	private static final Pools.SynchronizedPool M_POOL = new Pools.SynchronizedPool(30);
	public long mCreateTime;
	public String mKeyName;

	static 
	{
	//    0    0:new             #15  <Class Pools$SynchronizedPool>
	//    1    3:dup             
	//    2    4:bipush          30
	//    3    6:invokespecial   #19  <Method void Pools$SynchronizedPool(int)>
	//    4    9:putstatic       #21  <Field Pools$SynchronizedPool M_POOL>
	//*   5   12:return          
	}
}
```


Overlapping Code:
```
gTile(String s)
{
// 0 0:aload_0 
// 1 1:invokespecial #25 <Method void Object()>
mCreateTime = 0L;
// 2 4:aload_0 
// 3 5:lconst_0 
// 4 6:putfield #27 <Field long mCreateTime>
setParams(s);
// 5 9:aload_0 
// 6 10:aload_1 
// 7 11:invokespecial #30 <Method void setParams(String)>
// 8 14:return 
}
public static ProcessingTile obtain(String s)
{
ProcessingTile processingtile = (ProcessingTile)M_POOL.acquire();
// 0 0:getstatic #21 <Field Pools$SynchronizedPool M_POOL>
// 1 3:invokevirtual #36 <Method Object Pools$SynchronizedPool.acquire()>
// 2 6:checkcast #2 <Class ProcessingTile>
// 3 9:astore_1 
if(processingtile != null)
//* 4 10:aload_1 
//* 5 11:ifnull 21
{
processingtile.setParams(s);
// 6 14:aload_1 
// 7 15:aload_0 
// 8 16:invokespecial #30 <Method void setParams(String)>
return processingtile;
// 9 19:aload_1 
// 10 20:areturn 
} else
{
return new ProcessingTile(s);
// 11 21:new #2 <Class ProcessingTile>
// 12 24:dup 
// 13 25:aload_0 
// 14 26:invokespecial #38 <Method void ProcessingTile(String)>
// 15 29:areturn 
}
}
private void setParams(String s)
{
mKeyName = s;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #40 <Field String mKeyName>
mCreateTime = System.currentTimeMillis() / 1000L;
// 3 5:aload_0 
// 4 6:invokestatic #46 <Method long System.currentTimeMillis()>
// 5 9:ldc2w #47 <Long 1000L>
// 6 12:ldiv 
// 7 13:putfield #27 <Field long mCreateTime>
// 8 16:return 
}
public void recycle()
{
mKeyName = null;
// 0 0:aload_0 
// 1 1:aconst_null 
// 2 2:putfield #40 <Field String mKeyName>
mCreateTime = 0L;
// 3 5:aload_0 
// 4 6:lconst_0 
// 5 7:putfield #27 <Field long mCreateTime>
M_POOL.release(((Object) (this)));
// 6 10:getstatic #21 <Field Pools$SynchronizedPool M_POOL>
// 7 13:aload_0 
// 8 14:invokevirtual #53 <Method boolean Pools$Synchroniz
```
<Overlap Ratio: 0.9693053311793215>

---

--- 8 --
Question ID: f922034e9a3512e65dd726851557ecfc328b7d36
Original Code:
```
@SuppressWarnings("serial")
public class AdminSession extends AuthenticatedWebSession
{
	private String userid = null;

	public AdminSession(Request request)
		{
		super(request);
		setLocale(Locale.ENGLISH);
		AdminApplication.getLogging().logDebug(" - internet session started with id XXXX");
		}

	public AdminSession(Request request, Logging newlog)
		{
		super(request);
		setLocale(Locale.ENGLISH);
		newlog.logDebug(" - internet session started with id XXXX");
		}

	public static AdminSession get()
		{
		return (AdminSession) Session.get();
		}

	public synchronized String getUser()
		{
		return userid;
		}

	public synchronized boolean isAuthenticated()
		{
		return (userid != null);
		}

	public synchronized void setUser(String user)
		{
		this.userid = user;
		dirty();
		}

	public DataContext getDataContext()
		{
		return (DataContext)BaseContext.getThreadObjectContext();
		}

	public Logging getLogging()
		{
		return AdminApplication.getLogging();
		}

	/**
	 * @see org.apache.wicket.authentication.AuthenticatedWebSession#authenticate(java.lang.String,
	 *      java.lang.String)
	 */
	@Override
	public boolean authenticate(final String username, final String password)
	{
		final String WICKET = "wicket";

		// Check username and password
		return WICKET.equals(username) && WICKET.equals(password);
	}

	/**
	 * @see org.apache.wicket.authroles.authentication.AbstractAuthenticatedWebSession#getRoles()
	 */
	@Override
	public Roles getRoles()
		{
		if (isSignedIn())
		{
			// If the user is signed in, they have these roles
			return new Roles(Roles.ADMIN);
		}
		return null;
		}

}
```


Overlapping Code:
```
SuppressWarnings("serial")
public class AdminSession extends AuthenticatedWebSession
{
private String userid = null;
public AdminSession(Request request)
{
super(request);
setLocale(Locale.ENGLISH);
AdminApplication.getLogging().logDebug(" - internet session started with id XXXX");
}
public AdminSession(Request request, Logging newlog)
{
super(request);
setLocale(Locale.ENGLISH);
newlog.logDebug(" - internet session started with id XXXX");
}
public static AdminSession get()
{
return (AdminSession) Session.get();
}
public synchronized String getUser()
{
return userid;
}
public synchronized boolean isAuthenticated()
{
return (userid != null);
}
public synchronized void setUser(String user)
{
this.userid = user;
dirty();
}
public DataContext getDataContext()
{
return (DataContext)BaseContext.getThreadObjectContext();
}
public Logging getLogging()
{
return AdminApplication.getLogging();
}
/**
* @see org.apache.wicket.authentication.AuthenticatedWebSession#authenticate(java.lang.String,
* java.lang.String)
*/
@Override
public boolean authenticate(final String username, final String password)
{
final String WICKET = "wicket";
// Check username and password
return WICKET.equals(username) && WICKET.equals(password);
}
/**
* @see org.apache.wicket.authroles.authentication.AbstractAuthenticatedWebSession#getRoles()
*/
@Override
public Roles getRoles()
{
if (isSignedIn())
{
// If the user is signed in, they have these roles
return new Roles(Roles.ADMIN);
}
return null;
}
```
<Overlap Ratio: 0.9979825151311366>

---

--- 9 --
Question ID: 32763839c821bbb58ed324d11364a24375818f13
Original Code:
```
public class Workspace {
	private static final Logger log = LoggerFactory.getLogger(Workspace.class);

	private PersistenceDirectoryManager<Challenge> challengeManager;
	
	private PersistenceDirectoryManager<String> modelManager;
	private PersistenceDirectoryManager<Playground> playgroundManager;

	private PersistenceDirectoryManager<PersistedInput> inputManager;
	private PersistenceDirectoryManager<PersistedOutput> outputManager;
	private PersistenceDirectoryManager<PersistedTest> testManager;

	private PersistenceFileManager configurationManager;
	private Configuration configuration;
	private PersistenceFileManager accessLogManager;
	private AccessLog accessLog;

	private HybridDecisionSession decisionSession;

	public Workspace(String workspaceUUID) throws Exception {
		modelManager = new PersistenceDirectoryManager<>(workspaceUUID, "models", String.class, "dmn");
		playgroundManager = new PersistenceDirectoryManager<>(workspaceUUID, "playgrounds", Playground.class, "json");
		challengeManager = new PersistenceDirectoryManager<>(workspaceUUID, "challenges", Challenge.class, "json");
		inputManager = new PersistenceDirectoryManager<>(workspaceUUID, "inputs", PersistedInput.class, "json");
		outputManager = new PersistenceDirectoryManager<>(workspaceUUID, "outputs", PersistedOutput.class, "json");
		testManager = new PersistenceDirectoryManager<>(workspaceUUID, "tests", PersistedTest.class, "json");

		configurationManager = new PersistenceFileManager(workspaceUUID, "configuration.json");
		configuration = new Configuration(configurationManager);

		accessLogManager = new PersistenceFileManager(workspaceUUID, "access.log");
		accessLog = new AccessLog(accessLogManager);

		decisionSession = new HybridDecisionSession();

		DroolsHelper.importModels(this);
	}
	
	public PersistenceDirectoryManager<Challenge> getChallengeManager() {
		return challengeManager;
	}

	public PersistenceDirectoryManager<String> getModelManager() {
		return modelManager;
	}

	public PersistenceDirectoryManager<Playground> getPlaygroundManager() {
		return playgroundManager;
	}

	public PersistenceDirectoryManager<PersistedInput> getInputManager() {
		return inputManager;
	}

	public PersistenceDirectoryManager<PersistedOutput> getOutputManager() {
		return outputManager;
	}

	public PersistenceDirectoryManager<PersistedTest> getTestManager() {
		return testManager;
	}

	public HybridDecisionSession getDecisionSession() {
		return decisionSession;
	}

	public void clearDecisionSession() throws Exception {
		decisionSession = new HybridDecisionSession();
	}

	public Configuration getConfig() {
		return configuration;
	}

	public AccessLog getAccessLog() {
		return accessLog;
	}

	public void verify() throws IOException {
		modelManager.verifyAllFiles();
		playgroundManager.verifyAllFiles();
		inputManager.verifyAllFiles();
		outputManager.verifyAllFiles();
		testManager.verifyAllFiles();
	}
}
```


Overlapping Code:
```
lass Workspace {
private static final Logger log = LoggerFactory.getLogger(Workspace.class);
private PersistenceDirectoryManager<Challenge> challengeManager;

private PersistenceDirectoryManager<String> modelManager;
private PersistenceDirectoryManager<Playground> playgroundManager;
private PersistenceDirectoryManager<PersistedInput> inputManager;
private PersistenceDirectoryManager<PersistedOutput> outputManager;
private PersistenceDirectoryManager<PersistedTest> testManager;
private PersistenceFileManager configurationManager;
private Configuration configuration;
private PersistenceFileManager accessLogManager;
private AccessLog accessLog;
private HybridDecisionSession decisionSession;
public Workspace(String workspaceUUID) throws Exception {
modelManager = new PersistenceDirectoryManager<>(workspaceUUID, "models", String.class, "dmn");
playgroundManager = new PersistenceDirectoryManager<>(workspaceUUID, "playgrounds", Playground.class, "json");
challengeManager = new PersistenceDirectoryManager<>(workspaceUUID, "challenges", Challenge.class, "json");
inputManager = new PersistenceDirectoryManager<>(workspaceUUID, "inputs", PersistedInput.class, "json");
outputManager = new PersistenceDirectoryManager<>(workspaceUUID, "outputs", PersistedOutput.class, "json");
testManager = new PersistenceDirectoryManager<>(workspaceUUID, "tests", PersistedTest.class, "json");
configurationManager = new PersistenceFileManager(workspaceUUID, "configuration.json");
configuration = new Configuration(configurationManager);
accessLogManager = new PersistenceFileManager(workspaceUUID, "access.log");
accessLog = new AccessLog(accessLogManager);
decisionSession = new HybridDecisionSession();
DroolsHelper.importModels(this);
}

public PersistenceDirectoryManager<Challenge> getChallengeManager() {
return challengeManager;
}
public PersistenceDirectoryManager<String> getModelManager() {
return modelManager;
}
public PersistenceDirectoryManager<Playground> getPlaygroundManager() {
return playgroundManager;
}
public PersistenceDirectoryManager<PersistedInput> getInputManager() {
return inputManager;
}
public PersistenceDirectoryManager<PersistedOutput> getOutputManager() {
return outputManager;
}
public PersistenceDirectoryManager<PersistedTest> getTestManager() {
return testManager;
}
public HybridDecisionSession getDecisionSession() {
return decisionSession;
}
publ
```
<Overlap Ratio: 0.9863297431648715>

---

--- 10 --
Question ID: 4ad6adcbfc1008c89cd3084b9b5b0696f4baddb9
Original Code:
```
public class StatusOffWebSocketClient extends SpringBootWebSocketClient {
    @Override
    public void onOpen(WebSocket webSocket, Response response) {
        super.onOpen(webSocket, response);
        sendConnectMessage(webSocket);
        for (String topic : topics.keySet()) {
            sendSubscribeMessage(webSocket, topic);
        }
        // turn the givenId user status off
        sendMessage(webSocket, "/app/userList/status/off", "1");
        closeHandler = new CloseHandler(webSocket);
    }
}
```


Overlapping Code:
```
ss StatusOffWebSocketClient extends SpringBootWebSocketClient {
@Override
public void onOpen(WebSocket webSocket, Response response) {
super.onOpen(webSocket, response);
sendConnectMessage(webSocket);
for (String topic : topics.keySet()) {
sendSubscribeMessage(webSocket, topic);
}
// turn the givenId user status off
sendMessage(webSocket, "/app/userList/status/off", "1");
closeHandler = new CloseH
```
<Overlap Ratio: 0.9259259259259259>

---

--- 11 --
Question ID: 18364d3c3b9ce3bc6900f838c173be3d2853b52b
Original Code:
```
public class Grib2PDSReaderTest {

	private static final int EXPECTEDLENGTH = 1138; //checked

	private static final int TEMPLATENUMBER = 0;
	private static final int NUMBEROFCOORDINATEVALUES = 276; //unchecked
	
	private Grib2PDSReader pdsReader;

	@BeforeMethod
	public void prepare() throws Exception {
		pdsReader = new Grib2PDSReader();
	}

	@DataProvider(name = "goodPDSDataSet")
	public static Object[][] goodPDSDataSet() throws IOException, URISyntaxException {
		final int OFFSET = 13;
		return new Object[][]{
				new Object[]{GOOD_PDS_ARRAY(), 0, EXPECTEDLENGTH, GOOD_PDS_OBJECT()},
				new Object[]{GOOD_PDS_ARRAY_WITH_OFFSET(OFFSET), OFFSET, EXPECTEDLENGTH, GOOD_PDS_OBJECT()}
		};
	}
	
	private static final Grib2PDS GOOD_PDS_OBJECT(){
		
		
		Grib2PDS pds = new Grib2PDS();
		pds.setLength(EXPECTEDLENGTH);
		pds.setTemplateNumber(TEMPLATENUMBER);
		pds.setNumberOfCoordinateValues(NUMBEROFCOORDINATEVALUES); 
		pds.setTemplate(new HorizontalLevelTemplate());
		return pds;
	}
	
	private static final byte[] GOOD_PDS_ARRAY() throws URISyntaxException, IOException {
		String filename = "ecmwf-grib2-example-product-definition-section.grb";

		String name = Grib2PDSReader.class.getResource(filename).toString();
		File f = new File(Grib2PDSReader.class.getResource(filename).toURI());
		if (!f.exists()) {
			throw new IOException("file does not exist at " + name);
		}
		RandomAccessFile raFile = new RandomAccessFile(f, "r");
		FileChannel fc = raFile.getChannel();
		fc.position(0);
		ByteBuffer buffer = ByteBuffer.allocate((int) raFile.length());
		fc.read(buffer);
		buffer.rewind();
		byte[] response = buffer.array();
		raFile.close();
		return response;
	};
	
	private static final byte[] GOOD_PDS_ARRAY_WITH_OFFSET(int offSet)
			throws URISyntaxException, IOException {
		byte[] bytes = GOOD_PDS_ARRAY();
		byte[] response = new byte[bytes.length + offSet];
		for (int i = 0; i < offSet; i++) {
			response[i] = (byte) 1;
		}
		for (int counter = 0; counter < bytes.length; counter++) {
			response[offSet + counter] = bytes[counter];
		}
		return response;
	}
	
	@Test(dataProvider = "goodPDSDataSet")
	public void testReadPDS(byte[] testArray, int headerOffSet, int expectedValue, Grib2PDS expectedResponseObject) throws BinaryNumberConversionException, IOException {
		int length = pdsReader.readSectionLength(testArray, headerOffSet);
		assertThat(length).isEqualTo(expectedValue);
		
		Grib2PDS pds = pdsReader.readPDSValues(testArray,headerOffSet);
		assertThat(pds).isNotNull();
		
		assertThat(pds.getTemplate()).isInstanceOf(ProductTemplate.class);
		//exclude datatemplate content itself, so artificial equal
		pds.setTemplate(expectedResponseObject.getTemplate());
		assertThat(pds).isEqualTo(expectedResponseObject);
	}
}
```


Overlapping Code:
```
ReaderTest {
private static final int EXPECTEDLENGTH = 1138; //checked
private static final int TEMPLATENUMBER = 0;
private static final int NUMBEROFCOORDINATEVALUES = 276; //unchecked

private Grib2PDSReader pdsReader;
@BeforeMethod
public void prepare() throws Exception {
pdsReader = new Grib2PDSReader();
}
@DataProvider(name = "goodPDSDataSet")
public static Object[][] goodPDSDataSet() throws IOException, URISyntaxException {
final int OFFSET = 13;
return new Object[][]{
new Object[]{GOOD_PDS_ARRAY(), 0, EXPECTEDLENGTH, GOOD_PDS_OBJECT()},
new Object[]{GOOD_PDS_ARRAY_WITH_OFFSET(OFFSET), OFFSET, EXPECTEDLENGTH, GOOD_PDS_OBJECT()}
};
}

private static final Grib2PDS GOOD_PDS_OBJECT(){


Grib2PDS pds = new Grib2PDS();
pds.setLength(EXPECTEDLENGTH);
pds.setTemplateNumber(TEMPLATENUMBER);
pds.setNumberOfCoordinateValues(NUMBEROFCOORDINATEVALUES); 
pds.setTemplate(new HorizontalLevelTemplate());
return pds;
}

private static final byte[] GOOD_PDS_ARRAY() throws URISyntaxException, IOException {
String filename = "ecmwf-grib2-example-product-definition-section.grb";
String name = Grib2PDSReader.class.getResource(filename).toString();
File f = new File(Grib2PDSReader.class.getResource(filename).toURI());
if (!f.exists()) {
throw new IOException("file does not exist at " + name);
}
RandomAccessFile raFile = new RandomAccessFile(f, "r");
FileChannel fc = raFile.getChannel();
fc.position(0);
ByteBuffer buffer = ByteBuffer.allocate((int) raFile.length());
fc.read(buffer);
buffer.rewind();
byte[] response = buffer.array();
raFile.close();
return response;
};

private static final byte[] GOOD_PDS_ARRAY_WITH_OFFSET(int offSet)
throws URISyntaxException, IOException {
byte[] bytes = GOOD_PDS_ARRAY();
byte[] response = new byte[bytes.length + offSet];
for (int i = 0; i < offSet; i++) {
response[i] = (byte) 1;
}
for (int counter = 0; counter < bytes.length; counter++) {
response[offSet + counter] = bytes[counter];
}
return response;
}

@Test(dataProvider = "goodPDSDataSet")
public void testReadPDS(byte[] testArray, int headerOffSet, int expectedValue, Grib2PDS expectedResponseObject) throws BinaryNumberConversionException, IOException {
int length = pdsReader.readSectionLength(testArray, headerOffSet);
assertThat(length).isEqualTo(expectedValue);

Grib2PDS pds = pdsReader.readPDSValues(testArray,headerOffSet);
assertT
```
<Overlap Ratio: 0.9873684210526316>

---

--- 12 --
Question ID: 8ba5c2badc32fc63f18e1eb093689f48513d1b04
Original Code:
```
public final class ScriptsLocation implements Comparable<ScriptsLocation> {

  private static final String CLASSPATH_PREFIX = "classpath:";
  public static final String FILESYSTEM_PREFIX = "filesystem:";

  private String prefix; // classpath or filesystem
  private String path;

  public ScriptsLocation(String descriptor) {
    String normalizedDescriptor = descriptor.trim().replace("\\", "/");

    if (normalizedDescriptor.contains(":")) {
      prefix = normalizedDescriptor.substring(0, normalizedDescriptor.indexOf(":") + 1);
      path = normalizedDescriptor.substring(normalizedDescriptor.indexOf(":") + 1);
    } else {
      prefix = CLASSPATH_PREFIX;
      path = normalizedDescriptor;
    }

    if (isClassPath()) {
      path = path.replace(".", "/");
      if (path.startsWith("/")) {
        path = path.substring(1);
      }
    } else {
      if (!isFileSystem()) {
        throw new CassandraMigrationException(
            "Unknown prefix for location. "
                + "Must be "
                + CLASSPATH_PREFIX
                + " or "
                + FILESYSTEM_PREFIX
                + "."
                + normalizedDescriptor);
      }
    }

    if (path.endsWith("/")) {
      path = path.substring(0, path.length() - 1);
    }
  }

  public boolean isClassPath() {
    return CLASSPATH_PREFIX.equals(prefix);
  }

  public boolean isFileSystem() {
    return FILESYSTEM_PREFIX.equals(prefix);
  }

  public boolean isParentOf(ScriptsLocation other) {
    return (other.getDescriptor() + "/").startsWith(getDescriptor() + "/");
  }

  public String getPrefix() {
    return prefix;
  }

  public String getPath() {
    return path;
  }

  public String getDescriptor() {
    return prefix + path;
  }

  @SuppressWarnings("NullableProblems")
  public int compareTo(ScriptsLocation o) {
    return getDescriptor().compareTo(o.getDescriptor());
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    ScriptsLocation location = (ScriptsLocation) o;

    return getDescriptor().equals(location.getDescriptor());
  }

  @Override
  public int hashCode() {
    return getDescriptor().hashCode();
  }

  @Override
  public String toString() {
    return getDescriptor();
  }
}
```


Overlapping Code:
```
ss ScriptsLocation implements Comparable<ScriptsLocation> {
private static final String CLASSPATH_PREFIX = "classpath:";
public static final String FILESYSTEM_PREFIX = "filesystem:";
private String prefix; // classpath or filesystem
private String path;
public ScriptsLocation(String descriptor) {
String normalizedDescriptor = descriptor.trim().replace("\\", "/");
if (normalizedDescriptor.contains(":")) {
prefix = normalizedDescriptor.substring(0, normalizedDescriptor.indexOf(":") + 1);
path = normalizedDescriptor.substring(normalizedDescriptor.indexOf(":") + 1);
} else {
prefix = CLASSPATH_PREFIX;
path = normalizedDescriptor;
}
if (isClassPath()) {
path = path.replace(".", "/");
if (path.startsWith("/")) {
path = path.substring(1);
}
} else {
if (!isFileSystem()) {
throw new CassandraMigrationException(
"Unknown prefix for location. "
+ "Must be "
+ CLASSPATH_PREFIX
+ " or "
+ FILESYSTEM_PREFIX
+ "."
+ normalizedDescriptor);
}
}
if (path.endsWith("/")) {
path = path.substring(0, path.length() - 1);
}
}
public boolean isClassPath() {
return CLASSPATH_PREFIX.equals(prefix);
}
public boolean isFileSystem() {
return FILESYSTEM_PREFIX.equals(prefix);
}
public boolean isParentOf(ScriptsLocation other) {
return (other.getDescriptor() + "/").startsWith(getDescriptor() + "/");
}
public String getPrefix() {
return prefix;
}
public String getPath() {
return path;
}
public String getDescriptor() {
return prefix + path;
}
@SuppressWarnings("NullableProblems")
public int compareTo(ScriptsLocation o) {
return getDescriptor().compareTo(o.getDescriptor());
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
ScriptsLocation location = (ScriptsLocation) o;
return getDescriptor().equals(location.getDescriptor());
}
@Override
public int hashCode() {
return getDescriptor().hashCode();
}
@Override
public String toString() {
return getDescriptor();
}

```
<Overlap Ratio: 0.9913132345426674>

---

--- 13 --
Question ID: 17c1a1b635eee45481c2266cf34fcc83bf048ff1
Original Code:
```
public class URIUtil {
    
    /**
     * Builds a URI as a string from a set of components. Embedded parameters within
     * the path segments are replaced with their values taken from paramValues. Matrix
     * URI parameters are added to the end of the corresponding path segment. E.g.
     * 
     * <pre>  pathSegments = {"{p1}/xyzzy/{p2}", "{p3}"}
     *   matrixParams = {{"p4"}, {}}
     *   paramValues = {"p1"=>"v1", "p2"=>"v2", "p3"=>"v3", "p4"=>"v4"}</pre>
     * 
     * would result in the following URI
     * 
     * <pre>  v1/xyzzy/v2;p4=v4/v3</pre>
     * @return The URI resulting from merging the URI components.
     * @param pathSegments a list of path segments
     * @param matrixParams a list of sets of matrix parameter names
     * @param paramValues a map of parameter name to value, values can be of any class, the object's 
     * toString method is used to render a stringified value
     */
    public static String buildURI(List<String> pathSegments, List<List<String>> matrixParams, Map<String, Object> paramValues) {
        ArrayList<String> merged = new ArrayList<String>();
        for (int i=0; i< pathSegments.size(); i++) {
            List<String> associatedMatrixParams = matrixParams==null ? null : matrixParams.get(i);
            PathSegment segment = new PathSegment(pathSegments.get(i), associatedMatrixParams);
            merged.add(segment.evaluate(paramValues));
        }
        return concatenate(merged);
    }
    
    /**
     * Join a list of URI fragments into a URI using '/' as a separator.
     * @param components the list of URI fragments
     * @return the resulting URI
     */
    public static String concatenate(List<String> components) {
        StringBuffer buf = new StringBuffer();
        
        for (int i=0; i<components.size(); i++) {
            if (i>0 && buf.charAt(buf.length()-1)!='/' && components.get(i).charAt(0)!='/')
                buf.append('/');
            buf.append(components.get(i));
        }
        
        return buf.toString();
    }
    
    /**
     * Add a query string to a URI
     * @param uri the URI
     * @param queryString the query string
     * @throws java.net.URISyntaxException if the resulting URI is malformed
     * @return the resulting URI
     */
    public static String appendQueryString(URI uri, String queryString) throws URISyntaxException {
        URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(),
                uri.getPort(), uri.getPath(), queryString, uri.getFragment());
        return newURI.toString();
    }
    
    /**
     * Add a query string to a URI
     * 
     * @return the resulting URI
     * @param uri the URI
     * @param queryString the query string
     */
    public static String appendQueryString(String uri, String queryString) {
        if (queryString==null || queryString.length()==0)
            return uri;
        else if (uri.endsWith("?"))
            return uri+queryString;
        else
            return uri+"?"+queryString;
    }
    /**
     * Builds a URI query string from a map of keys and values.
     * @param queryParams a map of keys and their values. A value may be a <code>List</code> for repeating values.
     * @return the resulting query string
     */
    public static String buildQueryString(Map<String, Object> queryParams) {
        StringBuffer buf = new StringBuffer();
        boolean firstParam = true;
        try {
            for (Map.Entry<String, Object> entry: queryParams.entrySet()) {
                if (entry.getValue() == null)
                    continue;
                if (entry.getValue() instanceof List<?>) {
                    List<?> values = (List<?>)entry.getValue();
                    for (Object value: values) {
                        if (!firstParam) {
                            buf.append('&');
                        }
                        buf.append(entry.getKey());
                        buf.append('=');
                        buf.append(java.net.URLEncoder.encode(value.toString(), "utf-8"));
                        firstParam = false;
                    }
                }
                else {
                    if (!firstParam) {
                        buf.append('&');
                    }
                    buf.append(entry.getKey());
                    buf.append('=');
                    buf.append(java.net.URLEncoder.encode(entry.getValue().toString(), "utf-8"));
                    firstParam = false;
                }
            } 
        } catch (UnsupportedEncodingException ex) {
            ex.printStackTrace();
        } 
        return buf.toString();
    }
}
```


Overlapping Code:
```
 URI as a string from a set of components. Embedded parameters within
* the path segments are replaced with their values taken from paramValues. Matrix
* URI parameters are added to the end of the corresponding path segment. E.g.
* 
* <pre> pathSegments = {"{p1}/xyzzy/{p2}", "{p3}"}
* matrixParams = {{"p4"}, {}}
* paramValues = {"p1"=>"v1", "p2"=>"v2", "p3"=>"v3", "p4"=>"v4"}</pre>
* 
* would result in the following URI
* 
* <pre> v1/xyzzy/v2;p4=v4/v3</pre>
* @return The URI resulting from merging the URI components.
* @param pathSegments a list of path segments
* @param matrixParams a list of sets of matrix parameter names
* @param paramValues a map of parameter name to value, values can be of any class, the object's 
* toString method is used to render a stringified value
*/
public static String buildURI(List<String> pathSegments, List<List<String>> matrixParams, Map<String, Object> paramValues) {
ArrayList<String> merged = new ArrayList<String>();
for (int i=0; i< pathSegments.size(); i++) {
List<String> associatedMatrixParams = matrixParams==null ? null : matrixParams.get(i);
PathSegment segment = new PathSegment(pathSegments.get(i), associatedMatrixParams);
merged.add(segment.evaluate(paramValues));
}
return concatenate(merged);
}

/**
* Join a list of URI fragments into a URI using '/' as a separator.
* @param components the list of URI fragments
* @return the resulting URI
*/
public static String concatenate(List<String> components) {
StringBuffer buf = new StringBuffer();

for (int i=0; i<components.size(); i++) {
if (i>0 && buf.charAt(buf.length()-1)!='/' && components.get(i).charAt(0)!='/')
buf.append('/');
buf.append(components.get(i));
}

return buf.toString();
}

/**
* Add a query string to a URI
* @param uri the URI
* @param queryString the query string
* @throws java.net.URISyntaxException if the resulting URI is malformed
* @return the resulting URI
*/
public static String appendQueryString(URI uri, String queryString) throws URISyntaxException {
URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(),
uri.getPort(), uri.getP
```
<Overlap Ratio: 0.9803186504217432>

---

--- 14 --
Question ID: 351160f553b8e0247668c6e48733d4f75e0ce310
Original Code:
```
public class ApacheHttpClient43EngineWithRetry extends ApacheHttpClient43Engine implements ClientHttpEngine {

    private static final Logger logger = LoggerFactory.getLogger(ApacheHttpClient43EngineWithRetry.class);

    @Override
    protected HttpClient createDefaultHttpClient() {
        logger.info("Bootstrapping http engine with request retry handler...");
        final HttpClientBuilder builder = HttpClientBuilder.create();
        RequestConfig.Builder requestBuilder = RequestConfig.custom();
        if(defaultProxy != null) {
            requestBuilder.setProxy(defaultProxy);
        }
        builder.disableContentCompression();
        builder.setDefaultRequestConfig(requestBuilder.build());

        HttpRequestRetryHandler retryHandler = new StandardHttpRequestRetryHandler();
        builder.setRetryHandler(retryHandler);
        return builder.build();
    }
}
```


Overlapping Code:
```
cheHttpClient43EngineWithRetry extends ApacheHttpClient43Engine implements ClientHttpEngine {
private static final Logger logger = LoggerFactory.getLogger(ApacheHttpClient43EngineWithRetry.class);
@Override
protected HttpClient createDefaultHttpClient() {
logger.info("Bootstrapping http engine with request retry handler...");
final HttpClientBuilder builder = HttpClientBuilder.create();
RequestConfig.Builder requestBuilder = RequestConfig.custom();
if(defaultProxy != null) {
requestBuilder.setProxy(defaultProxy);
}
builder.disableContentCompression();
builder.setDefaultRequestConfig(requestBuilder.build());
HttpRequestRetryHandler retryHandler = new StandardHttpRequestRetryHandler();
builder.setRetryHandler(retryHandler);
return builder.bui
```
<Overlap Ratio: 0.967741935483871>

---

--- 15 --
Question ID: 68cd42ec35674e6755538ccd6a40762a85d5c7a6
Original Code:
```
public class Number213 {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }
        return Math.max(process(nums, 0, n - 2), process(nums, 1, n - 1));
    }

    public int process(int[] nums, int begin, int end) {
        int pre = nums[begin];
        int cur = Math.max(nums[begin], nums[begin + 1]);
        int tmp;
        for (int i = begin + 2; i <= end; i++) {
            tmp = cur;
            cur = Math.max(cur, pre + nums[i]);
            pre = tmp;
        }
        return cur;
    }
}
```


Overlapping Code:
```
3 {
public int rob(int[] nums) {
int n = nums.length;
if (n == 1) {
return nums[0];
}
if (n == 2) {
return Math.max(nums[0], nums[1]);
}
return Math.max(process(nums, 0, n - 2), process(nums, 1, n - 1));
}
public int process(int[] nums, int begin, int end) {
int pre = nums[begin];
int cur = Math.max(nums[begin], nums[begin + 1]);
int tmp;
for (int i = begin + 2; i <= end; i++) {
tmp = cur;
cur = Math.max(cur, pre + nums[i]);
pre = tmp;
}
return c
```
<Overlap Ratio: 0.9414225941422594>

---

--- 16 --
Question ID: e49d2b3891f8b4208e0683d54ffa16c80af5e94c
Original Code:
```
@ConfiguresHttpCommandExecutorService
public class JavaUrlHttpCommandExecutorServiceModule extends AbstractModule {

   @Override
   protected void configure() {
      install(new SSLModule());
      bind(HttpCommandExecutorService.class).to(JavaUrlHttpCommandExecutorService.class).in(Scopes.SINGLETON);
      bind(TransformingHttpCommandExecutorService.class).to(TransformingHttpCommandExecutorServiceImpl.class).in(
               Scopes.SINGLETON);
   }

}
```


Overlapping Code:
```
ervice
public class JavaUrlHttpCommandExecutorServiceModule extends AbstractModule {
@Override
protected void configure() {
install(new SSLModule());
bind(HttpCommandExecutorService.class).to(JavaUrlHttpCommandExecutorService.class).in(Scopes.SINGLETON);
bind(TransformingHttpCommandExecutorService.class).to(TransformingHttpCommandExecutorServiceImp
```
<Overlap Ratio: 0.8413461538461539>

---

--- 17 --
Question ID: f6a5fd02ccebe585493b09ae910314f4194d4d02
Original Code:
```
public class BaseMessageStoreUnitTests extends
    BaseMessageStoreContractTests<TestKeyMessage, TestValueMessage> {

  @Override
  protected TestMessageStore givenASubjectToTest() {
    return this.givenASubjectToTest(new HashMap<>());
  }

  @Override
  protected TestMessageStore givenASubjectToTest(final Map<TestKeyMessage, TestValueMessage> data) {
    final MapKeyValueStore mapKeyValueStore = new MapKeyValueStore();

    for (final TestKeyMessage key : data.keySet()) {
      mapKeyValueStore.put(key.toByteArray(), data.get(key).toByteArray());
    }
    return new TestMessageStore(mapKeyValueStore, this.testFrameworkRule.getInstance(ExecutionUtils.class),
        this.testFrameworkRule.getInstance(ProtobufUtils.class));
  }

  @Override
  protected TestKeyMessage givenAKey() {
    return this.testFrameworkRule.getInstance(TestKeyMessage.class);
  }

  @Override
  protected TestValueMessage givenAValue() {
    return this.testFrameworkRule.getInstance(TestValueMessage.class);
  }

}
```


Overlapping Code:
```

BaseMessageStoreContractTests<TestKeyMessage, TestValueMessage> {
@Override
protected TestMessageStore givenASubjectToTest() {
return this.givenASubjectToTest(new HashMap<>());
}
@Override
protected TestMessageStore givenASubjectToTest(final Map<TestKeyMessage, TestValueMessage> data) {
final MapKeyValueStore mapKeyValueStore = new MapKeyValueStore();
for (final TestKeyMessage key : data.keySet()) {
mapKeyValueStore.put(key.toByteArray(), data.get(key).toByteArray());
}
return new TestMessageStore(mapKeyValueStore, this.testFrameworkRule.getInstance(ExecutionUtils.class),
this.testFrameworkRule.getInstance(ProtobufUtils.class));
}
@Override
protected TestKeyMessage givenAKey() {
return this.testFrameworkRule.getInstance(TestKeyMessage.class);
}
@Override
protected TestValueMessage givenAValue() {
return this.testFrameworkRule.getInstance
```
<Overlap Ratio: 0.918918918918919>

---

--- 18 --
Question ID: 883fefa627eeb5eee0b3eb44b4e89c5b858bd01e
Original Code:
```
public class CollectionMergeBackupOperation extends CollectionOperation implements BackupOperation {

    private Collection<CollectionItem> backupItems;

    public CollectionMergeBackupOperation() {
    }

    public CollectionMergeBackupOperation(String name, Collection<CollectionItem> backupItems) {
        super(name);
        this.backupItems = backupItems;
    }

    @Override
    public void run() throws Exception {
        CollectionContainer container = getOrCreateContainer();
        if (backupItems.isEmpty()) {
            RemoteService service = getService();
            service.destroyDistributedObject(name);
        } else {
            Map<Long, CollectionItem> backupMap = container.getMap();
            backupMap.clear();
            for (CollectionItem backupItem : backupItems) {
                backupMap.put(backupItem.getItemId(), backupItem);
            }
        }
    }

    @Override
    public int getId() {
        return CollectionDataSerializerHook.COLLECTION_MERGE_BACKUP;
    }

    @Override
    protected void writeInternal(ObjectDataOutput out) throws IOException {
        super.writeInternal(out);
        out.writeInt(backupItems.size());
        for (CollectionItem backupItem : backupItems) {
            out.writeObject(backupItem);
        }
    }

    @Override
    protected void readInternal(ObjectDataInput in) throws IOException {
        super.readInternal(in);
        int size = in.readInt();
        backupItems = new ArrayList<CollectionItem>(size);
        for (int i = 0; i < size; i++) {
            CollectionItem backupItem = in.readObject();
            backupItems.add(backupItem);
        }
    }
}
```


Overlapping Code:
```
c class CollectionMergeBackupOperation extends CollectionOperation implements BackupOperation {
private Collection<CollectionItem> backupItems;
public CollectionMergeBackupOperation() {
}
public CollectionMergeBackupOperation(String name, Collection<CollectionItem> backupItems) {
super(name);
this.backupItems = backupItems;
}
@Override
public void run() throws Exception {
CollectionContainer container = getOrCreateContainer();
if (backupItems.isEmpty()) {
RemoteService service = getService();
service.destroyDistributedObject(name);
} else {
Map<Long, CollectionItem> backupMap = container.getMap();
backupMap.clear();
for (CollectionItem backupItem : backupItems) {
backupMap.put(backupItem.getItemId(), backupItem);
}
}
}
@Override
public int getId() {
return CollectionDataSerializerHook.COLLECTION_MERGE_BACKUP;
}
@Override
protected void writeInternal(ObjectDataOutput out) throws IOException {
super.writeInternal(out);
out.writeInt(backupItems.size());
for (CollectionItem backupItem : backupItems) {
out.writeObject(backupItem);
}
}
@Override
protected void readInternal(ObjectDataInput in) throws IOException {
super.readInternal(in);
int size = in.readInt();
backupItems = new ArrayList<CollectionItem>(size);
for (int i = 0; i < size; i++) {
CollectionItem backupItem = in.readObject(
```
<Overlap Ratio: 0.9687034277198212>

---

--- 19 --
Question ID: 06efab1a475e514cf31d1fd62d00b4420de8a54f
Original Code:
```
public class InstrumentView extends RelativeLayout implements Instrument {

    private TextView labelView;
    private TextView measurementView;
    private TextView unitsView;

    public InstrumentView(Context context) {
        super(context);
        init(context, null, 0);
    }

    public InstrumentView(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context, attrs, 0);
    }

    public InstrumentView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(context, attrs, defStyle);
    }

    private void init(Context context, AttributeSet attrs, int defStyle) {
        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.InstrumentView, defStyle, 0);
        String labelText = ta.getString(R.styleable.InstrumentView_labelText);
        ta.recycle();

        View v = inflate(getContext(), R.layout.view_instrument, this);
        labelView = TextView.class.cast(v.findViewById(R.id.view_instrument_label));
        measurementView = TextView.class.cast(v.findViewById(R.id.view_instrument_measurement));
        unitsView = TextView.class.cast(v.findViewById(R.id.view_instrument_units));
        if (!TextUtils.isEmpty(labelText)) {
            setLabel(labelText);
        }
    }

    @Override
    public void setLabel(String label) {
        labelView.setText(label);
    }

    @Override
    public void updateReading(String value, String units) {
        measurementView.setText(value);
        unitsView.setText(units);
    }

}
```


Overlapping Code:
```
ds RelativeLayout implements Instrument {
private TextView labelView;
private TextView measurementView;
private TextView unitsView;
public InstrumentView(Context context) {
super(context);
init(context, null, 0);
}
public InstrumentView(Context context, AttributeSet attrs) {
super(context, attrs);
init(context, attrs, 0);
}
public InstrumentView(Context context, AttributeSet attrs, int defStyle) {
super(context, attrs, defStyle);
init(context, attrs, defStyle);
}
private void init(Context context, AttributeSet attrs, int defStyle) {
TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.InstrumentView, defStyle, 0);
String labelText = ta.getString(R.styleable.InstrumentView_labelText);
ta.recycle();
View v = inflate(getContext(), R.layout.view_instrument, this);
labelView = TextView.class.cast(v.findViewById(R.id.view_instrument_label));
measurementView = TextView.class.cast(v.findViewById(R.id.view_instrument_measurement));
unitsView = TextView.class.cast(v.findViewById(R.id.view_instrument_units));
if (!TextUtils.isEmpty(labelText)) {
setLabel(labelText);
}
}
@Override
public void setLabel(String label) {
labelView.setText(label);
}
@Override
public void updateReading(String value, String units) {
measurementView.setT
```
<Overlap Ratio: 0.9441087613293051>

---

--- 20 --
Question ID: 8d65dcfa9e34e222bc74fbbe881c1482d08a225b
Original Code:
```
final class PreambleUtil {

  private PreambleUtil() {}

  // ###### DO NOT MESS WITH THIS FROM HERE ...
  // Preamble byte Addresses
  static final int PREAMBLE_LONGS_BYTE   = 0; // Only low 6 bits used
  static final int LG_RESIZE_FACTOR_BIT  = 6; // upper 2 bits. Not used by compact or direct.
  static final int SER_VER_BYTE          = 1;
  static final int FAMILY_BYTE           = 2;
  static final int FLAGS_BYTE            = 3;
  static final int RESERVOIR_SIZE_SHORT  = 4; // used in ser_ver 1
  static final int RESERVOIR_SIZE_INT    = 4;
  static final int SERDE_ID_SHORT        = 6; // used in ser_ver 1
  static final int ITEMS_SEEN_LONG       = 8;

  static final int MAX_K_SIZE_INT        = 4; // used in Union only
  static final int OUTER_TAU_NUM_DOUBLE  = 16; // used in Varopt Union only
  static final int OUTER_TAU_DENOM_LONG  = 24; // used in Varopt Union only

  // constants and addresses used in varopt
  static final int ITEM_COUNT_H_INT      = 16;
  static final int ITEM_COUNT_R_INT      = 20;
  static final int TOTAL_WEIGHT_R_DOUBLE = 24;
  static final int VO_PRELONGS_EMPTY     = Family.VAROPT.getMinPreLongs();
  static final int VO_PRELONGS_WARMUP    = 3;   // Doesn't match min or max prelongs in Family
  static final int VO_PRELONGS_FULL      = Family.VAROPT.getMaxPreLongs();

  // flag bit masks
  //static final int BIG_ENDIAN_FLAG_MASK = 1;
  //static final int READ_ONLY_FLAG_MASK  = 2;
  static final int EMPTY_FLAG_MASK      = 4;
  static final int GADGET_FLAG_MASK     = 128;

  //Other constants
  static final int SER_VER                    = 2;

  static final boolean NATIVE_ORDER_IS_BIG_ENDIAN  =
      (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN);

  // STRINGS

  /**
   * Returns a human readable string summary of the preamble state of the given byte array.
   * Used primarily in testing.
   *
   * @param byteArr the given byte array.
   * @return the summary preamble string.
   */
  static String preambleToString(final byte[] byteArr) {
    final Memory mem = Memory.wrap(byteArr);
    return preambleToString(mem);
  }

  /**
   * Returns a human readable string summary of the preamble state of the given Memory.
   * Note: other than making sure that the given Memory size is large
   * enough for just the preamble, this does not do much value checking of the contents of the
   * preamble as this is primarily a tool for debugging the preamble visually.
   *
   * @param mem the given Memory.
   * @return the summary preamble string.
   */
  static String preambleToString(final Memory mem) {
    final int preLongs = getAndCheckPreLongs(mem);  // make sure we can get the assumed preamble

    final Family family = Family.idToFamily(mem.getByte(FAMILY_BYTE));

    switch (family) {
      case RESERVOIR:
      case VAROPT:
        return sketchPreambleToString(mem, family, preLongs);
      case RESERVOIR_UNION:
      case VAROPT_UNION:
        return unionPreambleToString(mem, family, preLongs);
      default:
        throw new SketchesArgumentException("Inspecting preamble with Sampling family's "
                + "PreambleUtil with object of family " + family.getFamilyName());
    }
  }

  private static String sketchPreambleToString(final Memory mem,
                                               final Family family,
                                               final int preLongs) {
    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));
    final int serVer = extractSerVer(mem);

    // Flags
    final int flags = extractFlags(mem);
    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + ", " + (flags);
    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;
    //final String nativeOrder = ByteOrder.nativeOrder().toString();
    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;
    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;
    final boolean isGadget = (flags & GADGET_FLAG_MASK) > 0;

    final int k;
    if (serVer == 1) {
      final short encK = extractEncodedReservoirSize(mem);
      k = ReservoirSize.decodeValue(encK);
    } else {
      k = extractK(mem);
    }

    long n = 0;
    if (!isEmpty) {
      n = extractN(mem);
    }
    final long dataBytes = mem.getCapacity() - (preLongs << 3);

    final StringBuilder sb = new StringBuilder();
    sb.append(LS)
      .append("### END ")
      .append(family.getFamilyName().toUpperCase())
      .append(" PREAMBLE SUMMARY").append(LS)
      .append("Byte  0: Preamble Longs       : ").append(preLongs).append(LS)
      .append("Byte  0: ResizeFactor         : ").append(rf.toString()).append(LS)
      .append("Byte  1: Serialization Version: ").append(serVer).append(LS)
      .append("Byte  2: Family               : ").append(family.toString()).append(LS)
      .append("Byte  3: Flags Field          : ").append(flagsStr).append(LS)
      //.append("  BIG_ENDIAN_STORAGE          : ").append(bigEndian).append(LS)
      //.append("  (Native Byte Order)         : ").append(nativeOrder).append(LS)
      //.append("  READ_ONLY                   : ").append(readOnly).append(LS)
      .append("  EMPTY                       : ").append(isEmpty).append(LS);
    if (family == Family.VAROPT) {
      sb.append("  GADGET                      : ").append(isGadget).append(LS);
    }
    sb.append("Bytes  4-7: Sketch Size (k)   : ").append(k).append(LS);
    if (!isEmpty) {
      sb.append("Bytes 8-15: Items Seen (n)    : ").append(n).append(LS);
    }
    if ((family == Family.VAROPT) && !isEmpty) {
      final int hCount = extractHRegionItemCount(mem);
      final int rCount = extractRRegionItemCount(mem);
      final double totalRWeight = extractTotalRWeight(mem);
      sb.append("Bytes 16-19: H region count   : ").append(hCount).append(LS)
        .append("Bytes 20-23: R region count   : ").append(rCount).append(LS);
      if (rCount > 0) {
        sb.append("Bytes 24-31: R region weight  : ").append(totalRWeight).append(LS);
      }
    }

    sb.append("TOTAL Sketch Bytes            : ").append(mem.getCapacity()).append(LS)
      .append("  Preamble Bytes              : ").append(preLongs << 3).append(LS)
      .append("  Data Bytes                  : ").append(dataBytes).append(LS)
      .append("### END ")
      .append(family.getFamilyName().toUpperCase())
      .append(" PREAMBLE SUMMARY").append(LS);
    return sb.toString();
  }

  private static String unionPreambleToString(final Memory mem,
                                              final Family family,
                                              final int preLongs) {
    final ResizeFactor rf = ResizeFactor.getRF(extractResizeFactor(mem));
    final int serVer = extractSerVer(mem);

    // Flags
    final int flags = extractFlags(mem);
    final String flagsStr = zeroPad(Integer.toBinaryString(flags), 8) + ", " + (flags);
    //final boolean bigEndian = (flags & BIG_ENDIAN_FLAG_MASK) > 0;
    //final String nativeOrder = ByteOrder.nativeOrder().toString();
    //final boolean readOnly = (flags & READ_ONLY_FLAG_MASK) > 0;
    final boolean isEmpty = (flags & EMPTY_FLAG_MASK) > 0;

    final int k;
    if (serVer == 1) {
      final short encK = extractEncodedReservoirSize(mem);
      k = ReservoirSize.decodeValue(encK);
    } else {
      k = extractK(mem);
    }

    final long dataBytes = mem.getCapacity() - (preLongs << 3);

    return LS
            + "### END " + family.getFamilyName().toUpperCase() + " PREAMBLE SUMMARY" + LS
            + "Byte  0: Preamble Longs           : " + preLongs + LS
            + "Byte  0: ResizeFactor             : " + rf.toString() + LS
            + "Byte  1: Serialization Version    : " + serVer + LS
            + "Byte  2: Family                   : " + family.toString() + LS
            + "Byte  3: Flags Field              : " + flagsStr + LS
            //+ "  BIG_ENDIAN_STORAGE              : " + bigEndian + LS
            //+ "  (Native Byte Order)             : " + nativeOrder + LS
            //+ "  READ_ONLY                       : " + readOnly + LS
            + "  EMPTY                           : " + isEmpty + LS
            + "Bytes  4-7: Max Sketch Size (maxK): " + k + LS
            + "TOTAL Sketch Bytes                : " + mem.getCapacity() + LS
            + "  Preamble Bytes                  : " + (preLongs << 3) + LS
            + "  Sketch Bytes                    : " + dataBytes + LS
            + "### END " + family.getFamilyName().toUpperCase() + " PREAMBLE SUMMARY" + LS;
  }

  // Extraction methods

  static int extractPreLongs(final Memory mem) {
    return mem.getByte(PREAMBLE_LONGS_BYTE) & 0x3F;
  }

  static int extractResizeFactor(final Memory mem) {
    return (mem.getByte(PREAMBLE_LONGS_BYTE) >>> LG_RESIZE_FACTOR_BIT) & 0x3;
  }

  static int extractSerVer(final Memory mem) {
    return mem.getByte(SER_VER_BYTE) & 0xFF;
  }

  static int extractFamilyID(final Memory mem) {
    return mem.getByte(FAMILY_BYTE) & 0xFF;
  }

  static int extractFlags(final Memory mem) {
    return mem.getByte(FLAGS_BYTE) & 0xFF;
  }

  static short extractEncodedReservoirSize(final Memory mem) {
    return mem.getShort(RESERVOIR_SIZE_SHORT);
  }

  static int extractK(final Memory mem) {
    return mem.getInt(RESERVOIR_SIZE_INT);
  }

  static int extractMaxK(final Memory mem) {
    return extractK(mem);
  }

  static long extractN(final Memory mem) {
    return mem.getLong(ITEMS_SEEN_LONG);
  }

  static int extractHRegionItemCount(final Memory mem) {
    return mem.getInt(ITEM_COUNT_H_INT);
  }

  static int extractRRegionItemCount(final Memory mem) {
    return mem.getInt(ITEM_COUNT_R_INT);
  }

  static double extractTotalRWeight(final Memory mem) {
    return mem.getDouble(TOTAL_WEIGHT_R_DOUBLE);
  }

  static double extractOuterTauNumerator(final Memory mem) {
    return mem.getDouble(OUTER_TAU_NUM_DOUBLE);
  }

  static long extractOuterTauDenominator(final Memory mem) {
    return mem.getLong(OUTER_TAU_DENOM_LONG);
  }

  // Insertion methods

  static void insertPreLongs(final WritableMemory wmem, final int preLongs) {
    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);
    final int mask = 0x3F;
    final byte newByte = (byte) ((preLongs & mask) | (~mask & curByte));
    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);
  }

  static void insertLgResizeFactor(final WritableMemory wmem, final int rf) {
    final int curByte = wmem.getByte(PREAMBLE_LONGS_BYTE);
    final int shift = LG_RESIZE_FACTOR_BIT; // shift in bits
    final int mask = 3;
    final byte newByte = (byte) (((rf & mask) << shift) | (~(mask << shift) & curByte));
    wmem.putByte(PREAMBLE_LONGS_BYTE, newByte);
  }

  static void insertSerVer(final WritableMemory wmem, final int serVer) {
    wmem.putByte(SER_VER_BYTE, (byte) serVer);
  }

  static void insertFamilyID(final WritableMemory wmem, final int famId) {
    wmem.putByte(FAMILY_BYTE, (byte) famId);
  }

  static void insertFlags(final WritableMemory wmem, final int flags) {
    wmem.putByte(FLAGS_BYTE,  (byte) flags);
  }

  static void insertK(final WritableMemory wmem, final int k) {
    wmem.putInt(RESERVOIR_SIZE_INT, k);
  }

  static void insertMaxK(final WritableMemory wmem, final int maxK) {
    insertK(wmem, maxK);
  }

  static void insertN(final WritableMemory wmem, final long totalSeen) {
    wmem.putLong(ITEMS_SEEN_LONG, totalSeen);
  }

  static void insertHRegionItemCount(final WritableMemory wmem, final int hCount) {
    wmem.putInt(ITEM_COUNT_H_INT, hCount);
  }

  static void insertRRegionItemCount(final WritableMemory wmem, final int rCount) {
    wmem.putInt(ITEM_COUNT_R_INT, rCount);
  }

  static void insertTotalRWeight(final WritableMemory wmem, final double weight) {
    wmem.putDouble(TOTAL_WEIGHT_R_DOUBLE, weight);
  }

  static void insertOuterTauNumerator(final WritableMemory wmem, final double numer) {
    wmem.putDouble(OUTER_TAU_NUM_DOUBLE, numer);
  }

  static void insertOuterTauDenominator(final WritableMemory wmem, final long denom) {
    wmem.putLong(OUTER_TAU_DENOM_LONG, denom);
  }

  /**
   * Checks Memory for capacity to hold the preamble and returns the extracted preLongs.
   * @param mem the given Memory
   * @return the extracted prelongs value.
   */
  static int getAndCheckPreLongs(final Memory mem) {
    final long cap = mem.getCapacity();
    if (cap < 8) { throwNotBigEnough(cap, 8); }
    final int preLongs = mem.getByte(0) & 0x3F;
    final int required = Math.max(preLongs << 3, 8);
    if (cap < required) { throwNotBigEnough(cap, required); }
    return preLongs;
  }

  private static void throwNotBigEnough(final long cap, final int required) {
    throw new SketchesArgumentException(
        "Possible Corruption: Size of byte array or Memory not large enough: Size: " + cap
        + ", Required: " + required);
  }
}
```


Overlapping Code:
```
al class PreambleUtil {
private PreambleUtil() {}
// ###### DO NOT MESS WITH THIS FROM HERE ...
// Preamble byte Addresses
static final int PREAMBLE_LONGS_BYTE = 0; // Only low 6 bits used
static final int LG_RESIZE_FACTOR_BIT = 6; // upper 2 bits. Not used by compact or direct.
static final int SER_VER_BYTE = 1;
static final int FAMILY_BYTE = 2;
static final int FLAGS_BYTE = 3;
static final int RESERVOIR_SIZE_SHORT = 4; // used in ser_ver 1
static final int RESERVOIR_SIZE_INT = 4;
static final int SERDE_ID_SHORT = 6; // used in ser_ver 1
static final int ITEMS_SEEN_LONG = 8;
static final int MAX_K_SIZE_INT = 4; // used in Union only
static final int OUTER_TAU_NUM_DOUBLE = 16; // used in Varopt Union only
static final int OUTER_TAU_DENOM_LONG = 24; // used in Varopt Union only
// constants and addresses used in varopt
static final int ITEM_COUNT_H_INT = 16;
static final int ITEM_COUNT_R_INT = 20;
static final int TOTAL_WEIGHT_R_DOUBLE = 24;
static final int VO_PRELONGS_EMPTY = Family.VAROPT.getMinPreLongs();
static final int VO_PRELONGS_WARMUP = 3; // Doesn't match min or max prelongs in Family
static final int VO_PRELONGS_FULL = Family.VAROPT.getMaxPreLongs();
// flag bit masks
//static final int BIG_ENDIAN_FLAG_MASK = 1;
//static final int READ_ONLY_FLAG_MASK = 2;
static final int EMPTY_FLAG_MASK = 4;
static final int GADGET_FLAG_MASK = 128;
//Other constants
static final int SER_VER = 2;
static final boolean NATIVE_ORDER_IS_BIG_ENDIAN =
(ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN);
// STRINGS
/**
* Returns a human readable string summary of the preamble state of the given byte array.
* Used primarily in testing.
*
* @param byteArr the given byte array.
* @return the summary preamble string.
*/
static String preambleToString(final byte[] byteArr) {
final Memory mem = Memory.wrap(byteArr);
return preambleToString(mem);
}
/**
* Returns a human readable string summary of the preamble state of the given Memory.
* Note: other than making sure that the given Memory size is large
* enough for just the preamble, this does not do much value checking of the contents of the
* preamble as this is primarily a tool for debugging the preamble visually.
*
* @param mem the given M
```
<Overlap Ratio: 0.9804704837993786>

---

--- 21 --
Question ID: 1506743c83de6e6f5d55d5049dbd1dd34d803cd6
Original Code:
```
@Component
@Slf4j
public class JsonMarshaller {
    private final ObjectMapper objectMapper;

    public JsonMarshaller(ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }


    public String marshal(Object object) {
        String json = "";
        try {
            json = objectMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            log.info(e.getMessage(), e);
        }

        return json;
    }

    public <T extends Object> T unmarshal(String json, Class<?> clazz) {
        Object object = null;

        try {
            object = objectMapper.readValue(json, clazz);
        } catch (IOException e) {
            log.info(e.getMessage(), e);
        }

        return (T) object;
    }

    public <T> List<T> unmarshalList(String json, Class<?> clazz) {
        List<T> objects = new ArrayList<>();

        CollectionType type = objectMapper.getTypeFactory().constructCollectionType(List.class, clazz);
        try {
            objects = objectMapper.readValue(json, type);
        } catch (IOException e) {
            log.info(e.getMessage(), e);
        }

        return objects;
    }

}
```


Overlapping Code:
```
 JsonMarshaller {
private final ObjectMapper objectMapper;
public JsonMarshaller(ObjectMapper objectMapper) {
this.objectMapper = objectMapper;
}
public String marshal(Object object) {
String json = "";
try {
json = objectMapper.writeValueAsString(object);
} catch (JsonProcessingException e) {
log.info(e.getMessage(), e);
}
return json;
}
public <T extends Object> T unmarshal(String json, Class<?> clazz) {
Object object = null;
try {
object = objectMapper.readValue(json, clazz);
} catch (IOException e) {
log.info(e.getMessage(), e);
}
return (T) object;
}
public <T> List<T> unmarshalList(String json, Class<?> clazz) {
List<T> objects = new ArrayList<>();
CollectionType type = objectMapper.getTypeFactory().constructCollectionType(List.class, clazz);
try {
objects = objectMapper.readValue(json, type);
} catch (IOException e) {
log.info(e.getMessage(), e);
}
return 
```
<Overlap Ratio: 0.9541984732824428>

---

--- 22 --
Question ID: fb22f7167097dc1a7903e0d62185f4c1769a0a7b
Original Code:
```
@RunWith(JUnit4.class)
public class MutateRowCallableTest {

  private static final RequestContext REQUEST_CONTEXT =
      RequestContext.create(InstanceName.of("fake-project", "fake-instance"), "fake-profile");
  private UnaryCallable<MutateRowRequest, MutateRowResponse> innerCallable;
  private ArgumentCaptor<MutateRowRequest> innerMutation;
  private SettableApiFuture<MutateRowResponse> innerResult;

  @SuppressWarnings("unchecked")
  @Before
  public void setUp() {
    innerCallable = Mockito.mock(UnaryCallable.class);
    innerMutation = ArgumentCaptor.forClass(MutateRowRequest.class);
    innerResult = SettableApiFuture.create();
    Mockito.when(
            innerCallable.futureCall(innerMutation.capture(), Mockito.any(ApiCallContext.class)))
        .thenReturn(innerResult);
  }

  @Test
  public void testRequestConversion() {
    MutateRowCallable callable = new MutateRowCallable(innerCallable, REQUEST_CONTEXT);
    RowMutation outerRequest =
        RowMutation.create("fake-table", "fake-key")
            .setCell("fake-family", "fake-qualifier", 1_000, "fake-value");

    innerResult.set(MutateRowResponse.getDefaultInstance());
    callable.call(outerRequest);

    Truth.assertThat(innerMutation.getValue()).isEqualTo(outerRequest.toProto(REQUEST_CONTEXT));
  }
}
```


Overlapping Code:
```
JUnit4.class)
public class MutateRowCallableTest {
private static final RequestContext REQUEST_CONTEXT =
RequestContext.create(InstanceName.of("fake-project", "fake-instance"), "fake-profile");
private UnaryCallable<MutateRowRequest, MutateRowResponse> innerCallable;
private ArgumentCaptor<MutateRowRequest> innerMutation;
private SettableApiFuture<MutateRowResponse> innerResult;
@SuppressWarnings("unchecked")
@Before
public void setUp() {
innerCallable = Mockito.mock(UnaryCallable.class);
innerMutation = ArgumentCaptor.forClass(MutateRowRequest.class);
innerResult = SettableApiFuture.create();
Mockito.when(
innerCallable.futureCall(innerMutation.capture(), Mockito.any(ApiCallContext.class)))
.thenReturn(innerResult);
}
@Test
public void testRequestConversion() {
MutateRowCallable callable = new MutateRowCallable(innerCallable, REQUEST_CONTEXT);
RowMutation outerRequest =
RowMutation.create("fake-table", "fake-key")
.setCell("fake-family", "fake-qualifier", 1_000, "fake-value");
innerResult.set(MutateRowResponse.getDefaultInstance());
callable.call(outerRequest);
Truth.assertThat(innerMutation.getValue()).isEqualTo(outerRequest.toPro
```
<Overlap Ratio: 0.9712837837837838>

---

--- 23 --
Question ID: 0d41d003c6ce2821ac7b75dfd5367e245d0832da
Original Code:
```
public class GenerateSignUtilsTest {

    @Test(timeout = 100)
    public void generateSignatureByAES() throws Exception{
        SortedMap<String,String> sortedMap = new TreeMap<String,String>();
        sortedMap.put("testKey1","testvalue1");
        sortedMap.put("testvalue1","testKey1");
        sortedMap.put("timeStamp",Long.toString(1576922894903L));
        sortedMap.put("you","me");
        Assert.assertEquals("4fcd007d0eb88b928a2c1ffdc8ad7127aa06eafe1eec22bc809ad95a5833009f",GenerateSignUtils.generateSignatureByAES(sortedMap));
    }
}
```


Overlapping Code:
```
st(timeout = 100)
public void generateSignatureByAES() throws Exception{
SortedMap<String,String> sortedMap = new TreeMap<String,String>();
sortedMap.put("testKey1","testvalue1");
sortedMap.put("testvalue1","testKey1");
sortedMap.put("timeStamp",Long.toString(1576922894903L));
sortedMap.put("you","me");
Assert.assertEquals("4fcd007d0eb88b928a2c1ffdc8ad7127aa06eafe1eec22bc809ad95a5833009f",Generate
```
<Overlap Ratio: 0.8179959100204499>

---

--- 24 --
Question ID: dd79ba918bd95fd7b3d536951ff08258324f179a
Original Code:
```
public class JamaItemTypeTest extends TestCase {

    public void testItemType() throws RestClientException {
        JamaConfig jamaConfig = new JamaConfig();
        jamaConfig.setBaseUrl("test");
        jamaConfig.setHttpClient(new TestHttpClient());
        jamaConfig.setPassword("");
        jamaConfig.setUsername("");
        jamaConfig.setResourceTimeOut(1);

        JamaInstance jamaInstance = new JamaInstance(jamaConfig);
        JamaItemType jamaItemType= jamaInstance.getItemType(89011);

        assertEquals(89011, jamaItemType.getId().intValue());
        assertEquals("TC", jamaItemType.getTypeKey().toString());
        assertEquals("Test Case", jamaItemType.getDisplay().toString());
        assertEquals("Test Cases", jamaItemType.getDisplayPlural().toString());
        assertEquals(JamaItemType.class, jamaItemType.getClass());
        //TODO: need to getImage and check it is of type ItemTypeImage
        assertEquals(ArrayList.class, jamaItemType.getFields().getClass());
        try {
            refresh(jamaItemType);
            fields(jamaItemType);
        } catch (Exception e) {
            throw new RestClientException(e);
        }
        System.out.println("Done");
    }

    public void refresh(JamaItemType jamaItemType) throws Exception {

        Field field = JamaItemType.class.getDeclaredField("display");
        field.setAccessible(true);
        String oldName = "oldName";
        field.set(jamaItemType, oldName);
        assertEquals("oldName", field.get(jamaItemType));
        TimeUnit.SECONDS.sleep(1);
        assertEquals("Test Case", jamaItemType.getDisplay());
    }

    public void checkField(Class clazz, JamaField fieldValue) {
        assertTrue(clazz.isInstance(fieldValue));
    }

    public void fields(JamaItemType jamaItemType) throws Exception, RestClientException {
        checkField(RichTextField.class, jamaItemType.getField("description"));
        checkField(TextField.class, jamaItemType.getField("name"));
        checkField(TestCaseStatusField.class, jamaItemType.getField("testCaseStatus"));
        checkField(TestCaseStepsField.class, jamaItemType.getField("testCaseSteps"));
        checkField(UserField.class, jamaItemType.getField("assignedTo"));
        checkField(PickListField.class, jamaItemType.getField("priority"));
        checkField(IntegerField.class, jamaItemType.getField("custom_number"));
    }
}
```


Overlapping Code:
```
 {
public void testItemType() throws RestClientException {
JamaConfig jamaConfig = new JamaConfig();
jamaConfig.setBaseUrl("test");
jamaConfig.setHttpClient(new TestHttpClient());
jamaConfig.setPassword("");
jamaConfig.setUsername("");
jamaConfig.setResourceTimeOut(1);
JamaInstance jamaInstance = new JamaInstance(jamaConfig);
JamaItemType jamaItemType= jamaInstance.getItemType(89011);
assertEquals(89011, jamaItemType.getId().intValue());
assertEquals("TC", jamaItemType.getTypeKey().toString());
assertEquals("Test Case", jamaItemType.getDisplay().toString());
assertEquals("Test Cases", jamaItemType.getDisplayPlural().toString());
assertEquals(JamaItemType.class, jamaItemType.getClass());
//TODO: need to getImage and check it is of type ItemTypeImage
assertEquals(ArrayList.class, jamaItemType.getFields().getClass());
try {
refresh(jamaItemType);
fields(jamaItemType);
} catch (Exception e) {
throw new RestClientException(e);
}
System.out.println("Done");
}
public void refresh(JamaItemType jamaItemType) throws Exception {
Field field = JamaItemType.class.getDeclaredField("display");
field.setAccessible(true);
String oldName = "oldName";
field.set(jamaItemType, oldName);
assertEquals("oldName", field.get(jamaItemType));
TimeUnit.SECONDS.sleep(1);
assertEquals("Test Case", jamaItemType.getDisplay());
}
public void checkField(Class clazz, JamaField fieldValue) {
assertTrue(clazz.isInstance(fieldValue));
}
public void fields(JamaItemType jamaItemType) throws Exception, RestClientException {
checkField(RichTextField.class, jamaItemType.getField("description"));
checkField(TextField.class, jamaItemType.getField("name"));
checkField(TestCaseStatusField.class, jamaItemType.getField("testCaseStatus"));
checkField(TestCaseStepsField.class, jamaItemType.getField("testCaseSteps"));
checkField(UserField.class, jamaItemType.getField("assignedTo"));
checkField(PickListField.class, jamaItemType.getField("priority"));
checkField(IntegerField.class, jamaItemType.getField("custom_number")
```
<Overlap Ratio: 0.9746588693957114>

---

--- 25 --
Question ID: 9ade6c1dcffa6e9d0b1b4ec408dd1c7974ea5ce8
Original Code:
```
public class ShoppingCartTest {



	@Test
	void testAddItem() {
		Product productToAddForTest = new Product("banana" +
			"", ProductUnit.Kilo);


		ShoppingCart shoppingCart = new ShoppingCart();
		shoppingCart.addItem(productToAddForTest);
		shoppingCart.addItem(productToAddForTest);
		shoppingCart.addItem(productToAddForTest);


		int sumProductQuantities=0;

		for (Map.Entry<Product, Double> entry : shoppingCart.productQuantities.entrySet()) {
			sumProductQuantities += entry.getValue();

		}
		assertThat(sumProductQuantities).isEqualTo(3);


	}


}
```


Overlapping Code:
```
ss ShoppingCartTest {
@Test
void testAddItem() {
Product productToAddForTest = new Product("banana" +
"", ProductUnit.Kilo);
ShoppingCart shoppingCart = new ShoppingCart();
shoppingCart.addItem(productToAddForTest);
shoppingCart.addItem(productToAddForTest);
shoppingCart.addItem(productToAddForTest);
int sumProductQuantities=0;
for (Map.Entry<Product, Double> entry : shoppingCart.productQuantities.entrySet()) {
sumProductQuantities += entry.getValue();
}
assertThat(sumProductQuantities).isEqualT
```
<Overlap Ratio: 0.9633911368015414>

---

--- 26 --
Question ID: 684b279240abd2df9bdefaf696f4f01eae679b96
Original Code:
```
public class ChannelCursor {

  private static final int NOTSET=-2;

  Session[] sessions;
  Layer[] layers;
  Channel channel;
  int pos=NOTSET;

  /**
   * Constructs a <i>ChannelCursor</i> for the specified
   * {@link net.sf.appia.core.Channel Channel}
   *
   * @param channel the cursors {@link net.sf.appia.core.Channel Channel}
   */
  public ChannelCursor(Channel channel) {
    this.channel=channel;
    this.sessions=channel.sessions;
    this.layers=channel.getQoS().layers;
  }

  /**
   * Go to the {@link net.sf.appia.core.Session Session} imediatly below in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   *
   * @throws AppiaCursorException with two possible
   * {@link net.sf.appia.core.AppiaCursorException#type types}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM}
   */
  public void down() throws AppiaCursorException {
    if (pos == NOTSET)
       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    if (pos < 0)
       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);

    --pos;
  }

  /**
   * Go to the {@link net.sf.appia.core.Session Session} imediatly above in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   *
   * @throws AppiaCursorException with two possible
   * {@link net.sf.appia.core.AppiaCursorException#type types}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}
   */
  public void up() throws AppiaCursorException {
    if (pos == NOTSET)
       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    if (pos >= sessions.length)
       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);

    ++pos;
  }

  /**
   * Go to the highest {@link net.sf.appia.core.Session Session} in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   */
  public void top() {
    pos=sessions.length-1;
  }

  /**
   * Go to the lowest {@link net.sf.appia.core.Session Session} in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   */
  public void bottom() {
    pos=0;
  }

  /**
   * Is the cursor in a valid position, is it set ?
   *
   * @return <i>true</i> if the cursor is within the satck, <i>false</i> otherwise
   */
  public boolean isPositioned() {
    return (pos >= 0) && (pos < sessions.length);
  }

  /**
   * Set the {@link net.sf.appia.core.Session Session} for the current position in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   *
   * @param session the {@link net.sf.appia.core.Session Session} to set
   * @throws AppiaCursorException with three possible
   * {@link net.sf.appia.core.AppiaCursorException#type types}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#ALREADYSET ALREADYSET},
   * {@link net.sf.appia.core.AppiaCursorException#WRONGLAYER WRONGLAYER},
   */
  public void setSession(Session session) throws AppiaCursorException {
    if (pos == NOTSET)
       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    if (sessions[pos] != null)
       throw new AppiaCursorException(AppiaCursorException.ALREADYSET,"Session has already been Set");

    if (layers[pos].getClass() != session.getLayer().getClass())
       throw new AppiaCursorException(AppiaCursorException.WRONGLAYER,"Wrong Session Layer");

    sessions[pos]=session;
  }

  /**
   * Get the current {@link net.sf.appia.core.Session Session} in the
   * {@link net.sf.appia.core.Channel Channel} stack.
   *
   * @return the current {@link net.sf.appia.core.Session Session}, <i>null</i> if no
   * {@link net.sf.appia.core.Session Session} has been set for the current position
   * @throws AppiaCursorException with three possible
   * {@link net.sf.appia.core.AppiaCursorException#type types}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM},
   * {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}
   */
  public Session getSession() throws AppiaCursorException {
    if (pos == NOTSET)
       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    if (pos < 0)
       throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);

    if (pos >= sessions.length)
       throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);

    return sessions[pos];
  }

  /**
   * Get the {@link net.sf.appia.core.Layer Layer} of the {@link net.sf.appia.core.QoS QoS} stack, that
   * corresponds to the current position in the {@link net.sf.appia.core.Channel Channel}
   * stack.
   *
   * @return layer the {@link net.sf.appia.core.Layer Layer} corresponding to the current
   * position
   * @throws AppiaCursorException with one possible
   * {@link net.sf.appia.core.AppiaCursorException#type type}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET}
   */
  public Layer getLayer() throws AppiaCursorException {
    if (pos<0)
       throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    return layers[pos];
  }

  /**
   * Jumps a number of Layers. If the <i>offset</i> is positive then it will
   * jump upwards. Otherwise it will jump downwards.
   *
   * @throws AppiaCursorException with two possible
   * {@link net.sf.appia.core.AppiaCursorException#type type}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}
   */
  public void jump(int offset) throws AppiaCursorException {
    if (pos == NOTSET)
      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    offset+=pos;
    if ((offset < 0) || (offset >= sessions.length))
      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);

    pos=offset;
  }

  /**
   * Jumps to a specified position in the Channel stack.
   *
   * @throws AppiaCursorException with two possible
   * {@link net.sf.appia.core.AppiaCursorException#type type}:
   * {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
   * {@link net.sf.appia.core.AppiaCursorException#INVALIDPOSITION INVALIDPOSITION}
   */
  public void jumpTo(int position) throws AppiaCursorException {
    if (pos == NOTSET)
      throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);

    if ((position < 0) || (position >= sessions.length))
      throw new AppiaCursorException(AppiaCursorException.INVALIDPOSITION);

    pos=position;
  }
}
```


Overlapping Code:
```
al int NOTSET=-2;
Session[] sessions;
Layer[] layers;
Channel channel;
int pos=NOTSET;
/**
* Constructs a <i>ChannelCursor</i> for the specified
* {@link net.sf.appia.core.Channel Channel}
*
* @param channel the cursors {@link net.sf.appia.core.Channel Channel}
*/
public ChannelCursor(Channel channel) {
this.channel=channel;
this.sessions=channel.sessions;
this.layers=channel.getQoS().layers;
}
/**
* Go to the {@link net.sf.appia.core.Session Session} imediatly below in the
* {@link net.sf.appia.core.Channel Channel} stack.
*
* @throws AppiaCursorException with two possible
* {@link net.sf.appia.core.AppiaCursorException#type types}:
* {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
* {@link net.sf.appia.core.AppiaCursorException#CURSORONBOTTOM CURSORONBOTTOM}
*/
public void down() throws AppiaCursorException {
if (pos == NOTSET)
throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);
if (pos < 0)
throw new AppiaCursorException(AppiaCursorException.CURSORONBOTTOM);
--pos;
}
/**
* Go to the {@link net.sf.appia.core.Session Session} imediatly above in the
* {@link net.sf.appia.core.Channel Channel} stack.
*
* @throws AppiaCursorException with two possible
* {@link net.sf.appia.core.AppiaCursorException#type types}:
* {@link net.sf.appia.core.AppiaCursorException#CURSORNOTSET CURSORNOTSET},
* {@link net.sf.appia.core.AppiaCursorException#CURSORONTOP CURSORONTOP}
*/
public void up() throws AppiaCursorException {
if (pos == NOTSET)
throw new AppiaCursorException(AppiaCursorException.CURSORNOTSET);
if (pos >= sessions.length)
throw new AppiaCursorException(AppiaCursorException.CURSORONTOP);
++pos;
}
/**
* Go to the highest {@link net.sf.appia.core.Session Session} in the
* {@link net.sf.appia.core.Channel Channel} stack.
*/
public void top() {
pos=sessions.length-1;
}
/**
* Go to the lowest {@link net.sf.appia.core.Session Session} in the
* {@link net.sf.appia.core.Channel Channel} stack.
*/
public void bottom() {
pos=0;
}
/**
* Is the cursor in a valid position, is it set ?
*
* @return <i>true</i> if the cursor is within the satck, <i>false</i> otherwise
*/
public boolean isPositioned() {
return (pos >= 0) && (pos < sessions.lengt
```
<Overlap Ratio: 0.970873786407767>

---

--- 27 --
Question ID: 555331c8f5a38f9f59cfbdbf6b8688ac45e9d4f3
Original Code:
```
public class ParseThreddsMetadataCreatedDate
{
//    @Parameterized.Parameters
//    public static Collection<Object[]> junk()
//    {
//
//    }

    @Test
    public void parseDataFormat()
            throws URISyntaxException,
                   XMLStreamException,
                   ThreddsXmlParserException
    {
        String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormat.xml";

        String mdXml = "<dataFormat>NEXRAD-2</dataFormat>";

        parseDataFormatHelper( docBaseUriString, mdXml );
    }

    @Test
    public void parseDataFormatWrapped()
            throws URISyntaxException,
                   ThreddsXmlParserException
    {
        String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormatWrapped.xml";
        String mdXml = "<metadata><dataFormat>NEXRAD-2</dataFormat></metadata>";

        parseDataFormatHelper( docBaseUriString, mdXml );
    }

    @Test
    public void parseDataFormatInherited()
            throws URISyntaxException,
                   ThreddsXmlParserException
    {
        String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormatInherited.xml";
        String mdXml = "<metadata inherited='true'><dataFormat>NEXRAD-2</dataFormat></metadata>";

        parseDataFormatHelper( docBaseUriString, mdXml );
    }

    private void assertCreatDateAsExpected( ThreddsMetadataBuilder.DatePointBuilder datePointBuilder )
    {

    }

    private void parseDataFormatHelper( String docBaseUriString, String mdXml )
            throws URISyntaxException,
                   ThreddsXmlParserException
    {
        URI docBaseUri = new URI( docBaseUriString );
        String catalogXml = CatalogXmlUtils.wrapThreddsXmlInContainerDataset( mdXml );

        CatalogBuilder catBuilder = CatalogXmlUtils.parseCatalogIntoBuilder( docBaseUri, catalogXml );

        assertNotNull( catBuilder );

        DatasetBuilder dsBldr = CatalogXmlUtils.assertCatalogWithContainerDatasetAsExpected( catBuilder, docBaseUri );
        ThreddsMetadataBuilder tmdBldr = dsBldr.getThreddsMetadataBuilder();
        DataFormatType dataFormat = tmdBldr.getDataFormat();
        assertEquals( dataFormat, DataFormatType.NEXRAD2 );
    }

}
```


Overlapping Code:
```
 class ParseThreddsMetadataCreatedDate
{
// @Parameterized.Parameters
// public static Collection<Object[]> junk()
// {
//
// }
@Test
public void parseDataFormat()
throws URISyntaxException,
XMLStreamException,
ThreddsXmlParserException
{
String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormat.xml";
String mdXml = "<dataFormat>NEXRAD-2</dataFormat>";
parseDataFormatHelper( docBaseUriString, mdXml );
}
@Test
public void parseDataFormatWrapped()
throws URISyntaxException,
ThreddsXmlParserException
{
String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormatWrapped.xml";
String mdXml = "<metadata><dataFormat>NEXRAD-2</dataFormat></metadata>";
parseDataFormatHelper( docBaseUriString, mdXml );
}
@Test
public void parseDataFormatInherited()
throws URISyntaxException,
ThreddsXmlParserException
{
String docBaseUriString = "http://cat2.stax.ParseMetadataTest/parseDataFormatInherited.xml";
String mdXml = "<metadata inherited='true'><dataFormat>NEXRAD-2</dataFormat></metadata>";
parseDataFormatHelper( docBaseUriString, mdXml );
}
private void assertCreatDateAsExpected( ThreddsMetadataBuilder.DatePointBuilder datePointBuilder )
{
}
private void parseDataFormatHelper( String docBaseUriString, String mdXml )
throws URISyntaxException,
ThreddsXmlParserException
{
URI docBaseUri = new URI( docBaseUriString );
String catalogXml = CatalogXmlUtils.wrapThreddsXmlInContainerDataset( mdXml );
CatalogBuilder catBuilder = CatalogXmlUtils.parseCatalogIntoBuilder( docBaseUri, catalogXml );
assertNotNull( catBuilder );
DatasetBuilder dsBldr = CatalogXmlUtils.assertCatalogWithContainerDatasetAsExpected( catBuilder, docBaseUri );
ThreddsMetadataBuilder tmdBldr = dsBldr.getThreddsMetadataBuilder();
DataFormatType dataFormat = tmdBldr.getDataFormat();
assertEquals( dataFormat, DataFormatType.NE
```
<Overlap Ratio: 0.9902860226659471>

---

--- 28 --
Question ID: 6c3bfd4f9f96538280371268a4ce25768261a4ce
Original Code:
```
public static class SmartRecommendationCardView$a
{

	public SmartRecommendationCardView$a a(int i)
	{
		a.c = i;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:iload_1         
	//    3    5:putfield        #29  <Field int SmartRecommendationCardView$b.c>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a a(com.irobot.home.n.b.a a1)
	{
		a.i = a1;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #34  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.i>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a a(com.irobot.home.n.b.c c1)
	{
		a.k = c1;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #39  <Field com.irobot.home.n.b$c SmartRecommendationCardView$b.k>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a a(String s)
	{
		a.e = s;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #44  <Field String SmartRecommendationCardView$b.e>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView a()
	{
		SmartRecommendationCardView smartrecommendationcardview = new SmartRecommendationCardView(b);
	//    0    0:new             #6   <Class SmartRecommendationCardView>
	//    1    3:dup             
	//    2    4:aload_0         
	//    3    5:getfield        #17  <Field Context b>
	//    4    8:invokespecial   #46  <Method void SmartRecommendationCardView(Context)>
	//    5   11:astore_1        
		SmartRecommendationCardView.a(smartrecommendationcardview, a);
	//    6   12:aload_1         
	//    7   13:aload_0         
	//    8   14:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    9   17:invokestatic    #49  <Method void SmartRecommendationCardView.a(SmartRecommendationCardView, SmartRecommendationCardView$b)>
		return smartrecommendationcardview;
	//   10   20:aload_1         
	//   11   21:areturn         
	}

	public SmartRecommendationCardView$a b(int i)
	{
		a.d = i;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:iload_1         
	//    3    5:putfield        #52  <Field int SmartRecommendationCardView$b.d>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a b(com.irobot.home.n.b.a a1)
	{
		a.j = a1;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #55  <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.j>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a b(String s)
	{
		a.f = s;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #58  <Field String SmartRecommendationCardView$b.f>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	public SmartRecommendationCardView$a c(int i)
	{
		a.h = b.getString(i);
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_0         
	//    3    5:getfield        #17  <Field Context b>
	//    4    8:iload_1         
	//    5    9:invokevirtual   #64  <Method String Context.getString(int)>
	//    6   12:putfield        #67  <Field String SmartRecommendationCardView$b.h>
		return this;
	//    7   15:aload_0         
	//    8   16:areturn         
	}

	public SmartRecommendationCardView$a c(String s)
	{
		a.g = s;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field SmartRecommendationCardView$b a>
	//    2    4:aload_1         
	//    3    5:putfield        #70  <Field String SmartRecommendationCardView$b.g>
		return this;
	//    4    8:aload_0         
	//    5    9:areturn         
	}

	private final SmartRecommendationCardView$b a;
	private final Context b;

	public SmartRecommendationCardView$a(Context context)
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #15  <Method void Object()>
		b = context;
	//    2    4:aload_0         
	//    3    5:aload_1         
	//    4    6:putfield        #17  <Field Context b>
		a = new SmartRecommendationCardView$b(context);
	//    5    9:aload_0         
	//    6   10:new             #19  <Class SmartRecommendationCardView$b>
	//    7   13:dup             
	//    8   14:aload_1         
	//    9   15:invokespecial   #21  <Method void SmartRecommendationCardView$b(Context)>
	//   10   18:putfield        #23  <Field SmartRecommendationCardView$b a>
	//   11   21:return          
	}
}
```


Overlapping Code:
```
dationCardView$a
{
public SmartRecommendationCardView$a a(int i)
{
a.c = i;
// 0 0:aload_0 
// 1 1:getfield #23 <Field SmartRecommendationCardView$b a>
// 2 4:iload_1 
// 3 5:putfield #29 <Field int SmartRecommendationCardView$b.c>
return this;
// 4 8:aload_0 
// 5 9:areturn 
}
public SmartRecommendationCardView$a a(com.irobot.home.n.b.a a1)
{
a.i = a1;
// 0 0:aload_0 
// 1 1:getfield #23 <Field SmartRecommendationCardView$b a>
// 2 4:aload_1 
// 3 5:putfield #34 <Field com.irobot.home.n.b$a SmartRecommendationCardView$b.i>
return this;
// 4 8:aload_0 
// 5 9:areturn 
}
public SmartRecommendationCardView$a a(com.irobot.home.n.b.c c1)
{
a.k = c1;
// 0 0:aload_0 
// 1 1:getfield #23 <Field SmartRecommendationCardView$b a>
// 2 4:aload_1 
// 3 5:putfield #39 <Field com.irobot.home.n.b$c SmartRecommendationCardView$b.k>
return this;
// 4 8:aload_0 
// 5 9:areturn 
}
public SmartRecommendationCardView$a a(String s)
{
a.e = s;
// 0 0:aload_0 
// 1 1:getfield #23 <Field SmartRecommendationCardView$b a>
// 2 4:aload_1 
// 3 5:putfield #44 <Field String SmartRecommendationCardView$b.e>
return this;
// 4 8:aload_0 
// 5 9:areturn 
}
public SmartRecommendationCardView a()
{
SmartRecommendationCardView smartrecommendationcardview = new SmartRecommendationCardView(b);
// 0 0:new #6 <Class SmartRecommendationCardView>
// 1 3:dup 
// 2 4:aload_0 
// 3 5:getfield #17 <Field Context b>
// 4 8:invokespecial #46 <Method void SmartRecommendationCardView(Context)>
// 5 11:astore_1 
SmartRecommendationCardView.a(smartrecommendationcardview, a);
// 6 12:aload_1 
// 7 13:aload_0 
// 8 14:getfield #23 <Field SmartRecommendationCardView$b a>
// 9 17:invokestatic #49 <Method void SmartRecommendationCardView.a(SmartRecommendationCardView, SmartRecommendationCardView$b)>
return smartrecommendationcardview;
// 10 20:aload_1 
// 11 21:areturn 
}
pub
```
<Overlap Ratio: 0.9615384615384616>

---

--- 29 --
Question ID: c8d23c77029cd24b93d6adcaf81358862f8432d5
Original Code:
```
public class MyWikiModel extends WikiModel {

    /**
     * Interwiki links pointing to other wikis in the web
     */
    private static final String[] INTERLANGUAGE_STRINGS = { "en", "de", "fr",
            "it", "pl", "es", "ja", "ru", "nl", "pt", "sv", "zh", "ca", "uk",
            "no", "fi", "hu", "cs", "ro", "tr", "ko", "vi", "da", "ar", "eo",
            "sr", "id", "lt", "vo", "sk", "he", "fa", "bg", "sl", "eu", "war",
            "lmo", "et", "hr", "new", "te", "nn", "th", "gl", "el", "ceb",
            "simple", "ms", "ht", "bs", "bpy", "lb", "ka", "is", "sq", "la",
            "br", "hi", "az", "bn", "mk", "mr", "sh", "tl", "cy", "io", "pms",
            "lv", "ta", "su", "oc", "jv", "nap", "nds", "scn", "be", "ast",
            "ku", "wa", "af", "be-x-old", "an", "ksh", "szl", "fy", "frr",
            "yue", "ur", "ia", "ga", "yi", "sw", "als", "hy", "am", "roa-rup",
            "map-bms", "bh", "co", "cv", "dv", "nds-nl", "fo", "fur", "glk",
            "gu", "ilo", "kn", "pam", "csb", "kk", "km", "lij", "li", "ml",
            "gv", "mi", "mt", "nah", "ne", "nrm", "se", "nov", "qu", "os",
            "pi", "pag", "ps", "pdc", "rm", "bat-smg", "sa", "gd", "sco", "sc",
            "si", "tg", "roa-tara", "tt", "to", "tk", "hsb", "uz", "vec",
            "fiu-vro", "wuu", "vls", "yo", "diq", "zh-min-nan", "zh-classical",
            "frp", "lad", "bar", "bcl", "kw", "mn", "haw", "ang", "ln", "ie",
            "wo", "tpi", "ty", "crh", "jbo", "ay", "zea", "eml", "ky", "ig",
            "or", "mg", "cbk-zam", "kg", "arc", "rmy", "gn", "mo (closed)",
            "so", "kab", "ks", "stq", "ce", "udm", "mzn", "pap", "cu", "sah",
            "tet", "sd", "lo", "ba", "pnb", "iu", "na", "got", "bo", "dsb",
            "chr", "cdo", "hak", "om", "my", "sm", "ee", "pcd", "ug", "as",
            "ti", "av", "bm", "zu", "pnt", "nv", "cr", "pih", "ss", "ve", "bi",
            "rw", "ch", "arz", "xh", "kl", "ik", "bug", "dz", "ts", "tn", "kv",
            "tum", "xal", "st", "tw", "bxr", "ak", "ab", "ny", "fj", "lbe",
            "ki", "za", "ff", "lg", "sn", "ha", "sg", "ii", "cho", "rn", "mh",
            "chy", "ng", "kj", "ho", "mus", "kr", "hz", "mwl", "pa", "ace",
            "bat-smg", "bjn", "cbk-zam", "cdo", "ceb", "crh", "dsb", "eml",
            "ext", "fiu-vro", "frp", "frr", "gag", "gan", "hak", "kaa", "kab",
            "kbd", "koi", "krc", "ksh", "lad", "lbe", "lmo", "map-bms", "mdf",
            "mrj", "mwl", "nap", "nds-nl", "nrm", "pcd", "pfl", "pih", "pnb", "rmy",
            "roa-tara", "rue", "sah", "sco", "stq", "szl", "udm",
            "war", "wuu", "xmf", "zea", "zh-classical", "zh-yue",
            "ckb", "hif", "mhr", "myv", "srn"};
    
    protected static final Set<String> INTERLANGUAGE_KEYS;
    
    /**
     * Localised prefixes for special pages, e.g. "Special". 
     */
    public static final Map<String, String> SPECIAL_PREFIX = new HashMap<String, String>();
    /**
     * Localised suffixes for special pages, e.g. "AllPages".
     */
    public static final Map<String, EnumMap<SpecialPage, String>> SPECIAL_SUFFIX = new HashMap<String, EnumMap<SpecialPage, String>>();

    /**
     * Enum for all available special pages.
     * 
     * @author Nico Kruber, kruber@zib.de
     */
    public static enum SpecialPage {
        /**
         * Redirect to random page.
         */
        SPECIAL_RANDOM,
        /**
         * List of all pages.
         */
        SPECIAL_ALLPAGES,
        /**
         * List of all pages with a given prefix.
         */
        SPECIAL_PREFIXINDEX,
        /**
         * Search for a page.
         */
        SPECIAL_SEARCH,
        /**
         * Pages linking to another page.
         */
        SPECIAL_WHATLINKSHERE,
        /**
         * List of available special pages.
         */
        SPECIAL_SPECIALPAGES,
        /**
         * Some statistics.
         */
        SPECIAL_STATS,
        /**
         * Version information.
         */
        SPECIAL_VERSION;
    }
    
    /**
     * Cache of processed magic words.
     */
    protected Map<String, String> magicWordCache = new HashMap<String, String>();

    protected LinkedMultiHashMap<String, Long> stats = new LinkedMultiHashMap<String, Long>();
    
    /**
     * All keys that have been read or written during the current operation.
     */
    protected final List<InvolvedKey> involvedKeys = new ArrayList<InvolvedKey>();
    
    protected ExistingPagesCache existingPages = ExistingPagesCache.NULL_CACHE;

    protected Map<NormalisedTitle, String> pageCache = new HashMap<NormalisedTitle, String>();

    /**
     * Text of the page to render, i.e. given to
     * {@link #renderPageWithCache(String)} or
     * {@link #renderPageWithCache(ITextConverter, String)}.
     */
    private String renderWikiText = null;
    
    protected static final Pattern MATCH_WIKI_FORBIDDEN_TITLE_CHARS =
            Pattern.compile("^.*?([\\p{Cc}\\p{Cn}\\p{Co}#<>\\[\\]|{}\\n\\r]).*$", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

    /**
     * Pattern to check whether a wikitext is redirecting or not.
     */
    public static final Pattern MATCH_WIKI_REDIRECT = Pattern.compile("^\\s*#REDIRECT[ ]?\\[\\[:?([^\\]#]*)[^\\]]*\\]\\].*$", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);

    static {
        // BEWARE: fields in Configuration are static -> this changes all configurations!
        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction("fullurl", MyFullurl.CONST);
        Configuration.DEFAULT_CONFIGURATION.addTemplateFunction("localurl", MyLocalurl.CONST);
        
        // do not put these into the HTML text (they are not rendered anyway)
        Configuration.DEFAULT_CONFIGURATION.addTokenTag("inputbox", new IgnoreTag("inputbox"));
        Configuration.DEFAULT_CONFIGURATION.addTokenTag("imagemap", new IgnoreTag("imagemap"));
        Configuration.DEFAULT_CONFIGURATION.addTokenTag("timeline", new IgnoreTag("timeline"));
        
        Configuration.AVOID_PAGE_BREAK_IN_TABLE = false;
        
        // allow style attributes:
        TagNode.addAllowedAttribute("style");
        
        // create set of keys for interlanguage wiki links
        // also add missing hsb interlanguage link:
        Map<String, String> interWikiMap = Configuration.DEFAULT_CONFIGURATION.getInterwikiMap();
        INTERLANGUAGE_KEYS = new HashSet<String>(INTERLANGUAGE_STRINGS.length);
        for (String lang : INTERLANGUAGE_STRINGS) {
            INTERLANGUAGE_KEYS.add(lang);
            // if there is no interwiki link for it, create one and guess the URL:
            if (!interWikiMap.containsKey(lang)) {
                Configuration.DEFAULT_CONFIGURATION.addInterwikiLink(lang, "http://" + lang + ".wiktionary.org/wiki/?${title}");
            }
        }
        
        // localised special pages titles (prefix + suffix)
        // BEWARE: keep SPECIAL_PREFIX and SPECIAL_SUFFIX in sync!
        SPECIAL_PREFIX.put("en", "Special");
        SPECIAL_PREFIX.put("simple", "Special");
        SPECIAL_PREFIX.put("de", "Spezial");
        SPECIAL_PREFIX.put("bar", "Spezial");
        SPECIAL_PREFIX.put("es", "Especial");
        SPECIAL_PREFIX.put("pl", "Specjalna");
        // BEWARE: include normalised page titles!

        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_EN = new EnumMap<SpecialPage, String>(SpecialPage.class);
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_RANDOM, "Random");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_ALLPAGES, "AllPages");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_PREFIXINDEX, "PrefixIndex");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SEARCH, "Search");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_WHATLINKSHERE, "WhatLinksHere");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_SPECIALPAGES, "SpecialPages");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_STATS, "Statistics");
        SPECIAL_SUFFIX_EN.put(SpecialPage.SPECIAL_VERSION, "Version");

        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_DE = new EnumMap<SpecialPage, String>(SpecialPage.class);
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_RANDOM, "Zufällige Seite");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_ALLPAGES, "Alle Seiten");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_PREFIXINDEX, "Präfixindex");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SEARCH, "Suche");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_WHATLINKSHERE, "Linkliste");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_SPECIALPAGES, "Spezialseiten");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_STATS, "Statistik");
        SPECIAL_SUFFIX_DE.put(SpecialPage.SPECIAL_VERSION, "Version");

        EnumMap<SpecialPage, String> SPECIAL_SUFFIX_ES = new EnumMap<SpecialPage, String>(SpecialPage.class);
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_RANDOM, "Aleatoria");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_ALLPAGES, "Todas");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_PREFIXINDEX, "PáginasPorPrefijo");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SEARCH, "Buscar");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_WHATLINKSHERE, "LoQueEnlazaAquí");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_SPECIALPAGES, "PáginasEspeciales");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_STATS, "Estadísticas");
        SPECIAL_SUFFIX_ES.put(SpecialPage.SPECIAL_VERSION, "Versión");
        
        SPECIAL_SUFFIX.put("en", SPECIAL_SUFFIX_EN);
        SPECIAL_SUFFIX.put("simple", SPECIAL_SUFFIX_EN);
        SPECIAL_SUFFIX.put("de", SPECIAL_SUFFIX_DE);
        SPECIAL_SUFFIX.put("bar", SPECIAL_SUFFIX_DE);
        SPECIAL_SUFFIX.put("es", SPECIAL_SUFFIX_ES);
    }
    
    /**
     * Creates a new wiki model to render wiki text fixing some bugs of
     * {@link WikiModel}.
     * 
     * @param imageBaseURL
     *            base url pointing to images - can contain ${image} for
     *            replacement
     * @param linkBaseURL
     *            base url pointing to links - can contain ${title} for
     *            replacement
     * @param namespace
     *            namespace of the wiki
     */
    public MyWikiModel(String imageBaseURL, String linkBaseURL, MyNamespace namespace) {
        super(new MyConfiguration(namespace), null, namespace, imageBaseURL, linkBaseURL);
        addTemplateFunction("#ifexist", MyIfexistTemplateFun.CONST);
    }
    
    /* (non-Javadoc)
     * @see info.bliki.wiki.model.AbstractWikiModel#getRawWikiContent(java.lang.String, java.lang.String, java.util.Map)
     */
    @Override
    public String getRawWikiContent(String namespace, String articleName,
            Map<String, String> templateParameters) {
        if (isTemplateNamespace(namespace)) {
            String processedMagicWord = null;
            processedMagicWord = processMagicWord(articleName);
            if (processedMagicWord != null) {
                return processedMagicWord;
            }
        }
        
        if (!isValidTitle(createFullPageName(namespace, articleName))) {
            return null;
        }

        // (ugly) fix for template parameter replacement if no parameters given,
        // e.g. "{{noun}}" in the simple English Wiktionary
        if (templateParameters != null && templateParameters.isEmpty()) {
            templateParameters.put("", null);
        }

        // note: cannot cache templates here since the text returned by the
        // implementation-specific retrievePage() method may depend in the exact
        // parameters or not
        return retrievePage(namespace, articleName, templateParameters);
    }

    /**
     * Checks whether the given template name is a magic word and if this is the
     * case, processes it and returns its value.
     * 
     * Retrieves magic word contents using
     * {@link #retrieveMagicWord(String, String, String)} and caches the
     * contents in {@link #magicWordCache}.
     * 
     * @param templateName
     *            the template's name without the namespace, e.g. a magic word
     *            including its parameters
     * 
     * @return the contents of the magic word or <tt>null</tt> if the template
     *         is no magic word
     */
    private String processMagicWord(String templateName) {
        int index = templateName.indexOf(':');
        String magicWord = templateName;
        String parameter = "";
        boolean hasParameter = false;
        if (index > 0) {
            hasParameter = true;
            // if it is a magic word, the first part is the word itself, the second its parameters
            magicWord = templateName.substring(0, index);
            parameter = templateName.substring(index + 1).trim();
        }
        
        if (isMagicWord(magicWord)) {
            // cache values for magic words:
            if (magicWordCache.containsKey(templateName)) {
                return magicWordCache.get(templateName);
            } else {
                String value = retrieveMagicWord(templateName, magicWord, parameter, hasParameter);
                magicWordCache.put(templateName, value);
                return value;
            }
        } else {
            return null;
        }
    }

    /**
     * Determines if a template name corresponds to a magic word using
     * {@link MyMagicWord#isMagicWord(String)} (does not recognise magic
     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).
     * 
     * @param name
     *            the template name (without the template namespace)
     * 
     * @return whether the template is a magic word or not
     */
    protected boolean isMagicWord(String name) {
        return MyMagicWord.isMagicWord(name);
    }

    /**
     * Determines if a template name corresponds to a magic word using
     * {@link #isMagicWord(String)} (also recognises magic
     * words with parameters, e.g. <tt>TALKPAGENAME:Title</tt>).
     * 
     * @param name
     *            the template name (without the template namespace)
     * 
     * @return whether the template is a magic word or not
     */
    public final boolean isMagicWordFull(String name) {
        return isMagicWord(MyMagicWord.extractMagicWordPart(name));
    }

    /**
     * Gets the names of all included pages in the template namespace (excluding
     * magic words).
     * 
     * @return page names without the template namespace prefix
     * @see #getTemplates()
     */
    public final Set<String> getTemplatesNoMagicWords() {
        final Set<String> result = new HashSet<String>(templates.size());
        // remove magic words:
        for (String template : templates) {
            if (!isMagicWordFull(template)) {
                result.add(template);
            }
        }
        return result;
    }
    
    /**
     * Retrieves the contents of the given magic word using
     * {@link MyMagicWord#processMagicWord(String, String, info.bliki.wiki.model.IWikiModel)}.
     * 
     * @param templateName
     *            the template's name without the namespace, e.g. a magic word
     *            including its parameters
     * @param magicWord
     *            the magic word alone
     * @param parameter
     *            the parameters of the magic word name
     * @param hasParameter
     *            whether a parameter was given or not (cannot distinguish from
     *            <tt>parameter</tt> value alone)
     * 
     * @return the contents of the magic word
     */
    protected String retrieveMagicWord(String templateName, String magicWord,
            String parameter, boolean hasParameter) {
        return MyMagicWord.processMagicWord(templateName, parameter, this, hasParameter);
    }
    
    /**
     * Renders the "redirect to" content in case no auto-redirection is used.
     * 
     * @param pageTitle
     *            the title of the page being redirected to
     * 
     * @return HTML redirect note
     */
    public String renderRedirectPage(String pageTitle) {
        final String redirectUrl = getWikiBaseURL().replace("${title}", pageTitle);
        final String safeRedirectTitle = StringEscapeUtils.escapeHtml(pageTitle);
        return "<div class=\"redirectMsg\">"
                + "<img src=\"skins/redirectltr.png\" alt=\"#REDIRECT\" />"
                + "<span class=\"redirectText\">"
                + "<a href=\"" + redirectUrl + "\" title=\"" + safeRedirectTitle + "\">" + pageTitle + "</a>"
                + "</span></div>";
    }
    
    /**
     * Creates the full pagename including the namespace (if non-empty).
     * 
     * @param namespace
     *            the namespace of a page
     * @param articleName
     *            the name of a page
     * 
     * @return the full name of the page
     */
    public static String createFullPageName(String namespace, String articleName) {
        String pageName;
        if (namespace.isEmpty()) {
            pageName = articleName;
        } else {
            pageName = namespace + ":" + articleName;
        }
        return pageName;
    }
    
    /**
     * Retrieves the contents of the given page.
     * 
     * @param namespace
     *            the namespace of the page
     * @param articleName
     *            the (unnormalised) page's name without the namespace
     * @param templateParameters
     *            template parameters if the page is a template, <tt>null</tt>
     *            otherwise
     * 
     * @return <tt>null</tt>
     * @see #retrievePage(String, String, Map, boolean)
     */
    final protected String retrievePage(String namespace, String articleName,
            Map<String, String> templateParameters) {
        return retrievePage(namespace, articleName, templateParameters, true);
    }

    /**
     * Retrieves the contents of the given page.
     * 
     * @param pageName0
     *            the unnormalised name of the page
     * @param templateParameters
     *            template parameters if the page is a template, <tt>null</tt>
     *            otherwise
     * @param followRedirect
     *            whether to follow a redirect or not (at most one redirect
     *            should be followed)
     * 
     * @return the page's contents or <tt>null</tt> if no connection exists
     * @see #retrievePage(String, String, Map, boolean)
     */
    final protected String retrievePage(String pageName0,
            Map<String, String> templateParameters, boolean followRedirect) {
        String[] parts = splitNsTitle(pageName0);
        return retrievePage(parts[0], parts[1], templateParameters, followRedirect);
    }

    /**
     * Retrieves the contents of the given page.
     * 
     * If {@link #hasDBConnection()} is <tt>true</tt>, uses
     * {@link #getRevFromDB(NormalisedTitle)} to get the content from the DB. If
     * <tt>followRedirect</tt> is set, resolves redirects by including the
     * redirected content instead.
     * 
     * Caches retrieved pages in {@link #pageCache}.
     * 
     * @param namespace
     *            the namespace of the page
     * @param articleName
     *            the (unnormalised) page's name without the namespace
     * @param templateParameters
     *            template parameters if the page is a template, <tt>null</tt>
     *            otherwise
     * @param followRedirect
     *            whether to follow a redirect or not (at most one redirect
     *            should be followed)
     * 
     * @return the page's contents or <tt>null</tt> if no connection exists
     */
    protected String retrievePage(String namespace, String articleName,
            Map<String, String> templateParameters, boolean followRedirect) {

        if (articleName.isEmpty()) {
            return null;
        }
        
        // normalise page name:
        NormalisedTitle pageName = normalisePageTitle(namespace, articleName);
        if (pageCache.containsKey(pageName)) {
            return pageCache.get(pageName);
        } else if (hasDBConnection()) {
            String text = null;
            // System.out.println("retrievePage(" + namespace + ", " + articleName + ")");
            RevisionResult getRevResult = getRevFromDB(pageName);
            addStats(getRevResult.stats);
            addInvolvedKeys(getRevResult.involvedKeys);
            if (getRevResult.success) {
                text = getRevResult.revision.unpackedText();
                if (getRevResult.page.isRedirect()) {
                    final Matcher matcher = MATCH_WIKI_REDIRECT.matcher(text);
                    if (matcher.matches()) {
                        String[] redirFullName = splitNsTitle(matcher.group(1));
                        if (followRedirect) {
                            // see https://secure.wikimedia.org/wikipedia/en/wiki/Help:Redirect#Transclusion
                            String redirText = retrievePage(redirFullName[0], redirFullName[1], templateParameters, false);
                            if (redirText != null && !redirText.isEmpty()) {
                                text = redirText;
                            } else {
                                text = "<ol><li>REDIRECT [["
                                        + createFullPageName(redirFullName[0],
                                                redirFullName[1]) + "]]</li></ol>";
                            }
                        } else {
                            // we must disarm the redirect here!
                            text = "<ol><li>REDIRECT [["
                                    + createFullPageName(redirFullName[0],
                                            redirFullName[1]) + "]]</li></ol>";
                        }
                    } else {
                        // we must disarm the redirect here!
                        System.err
                                .println("Couldn't parse the redirect title of \""
                                        + createFullPageName(namespace, articleName)
                                        + "\" in \""
                                        + createFullPageName(
                                                getNamespaceName(),
                                                getPageName())
                                        + "\" from: "
                                        + text.substring(0, Math.min(100, text.length())));
                        text = null;
                    }
                }
            } else {
                // NOTE: must return null for non-existing pages in order for #ifexist to work correctly!
                // System.err.println(getRevResult.message);
                // text = "<b>ERROR: template " + pageName + " not available: " + getRevResult.message + "</b>";
            }
            pageCache.put(pageName, text);
            return text;
        }
        return null;
    }
    
    protected boolean hasDBConnection() {
        return false;
    }
    
    protected RevisionResult getRevFromDB(NormalisedTitle title) {
        return new RevisionResult(false, new ArrayList<InvolvedKey>(),
                "no DB connection", true, title, null, null, false,
                false, title.toString(), 0l);
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.AbstractWikiModel#encodeTitleToUrl(java.lang.String, boolean)
     */
    @Override
    public String encodeTitleToUrl(String wikiTitle, boolean firstCharacterAsUpperCase) {
        try {
            // some links may contain '_' which needs to be translated back to ' ':
            wikiTitle = wikiTitle.replace('_', ' ');
            return URLEncoder.encode(wikiTitle, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return super.encodeTitleToUrl(wikiTitle, firstCharacterAsUpperCase);
        }
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.WikiModel#getNamespace()
     */
    @Override
    public MyNamespace getNamespace() {
        return (MyNamespace) super.getNamespace();
    }

    /**
     * Formats the given number using the wiki's locale.
     * 
     * Note: Currently, the English locale is always used.
     * 
     * @param rawNumber
     *            whether the raw number should be returned
     * @param number
     *            the number
     * 
     * @return the formatted number
     */
    public String formatStatisticNumber(boolean rawNumber, Number number) {
        if (rawNumber) {
            return number.toString();
        } else {
            // TODO: use locale from Wiki
            NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);
            nf.setGroupingUsed(true);
            return nf.format(number);
        }
    }

    /**
     * Splits the given full title at the first colon.
     * 
     * @param fullTitle
     *            the (full) title including a namespace (if present)
     * 
     * @return a 2-element array with the two components - the first may be
     *         empty if no colon is found
     */
    protected static String[] splitAtColon(String fullTitle) {
        int colonIndex = fullTitle.indexOf(':');
        if (colonIndex != (-1)) {
            return new String[] { fullTitle.substring(0, colonIndex),
                    fullTitle.substring(colonIndex + 1) };
        }
        return new String[] { "", fullTitle };
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.AbstractWikiModel#appendRedirectLink(java.lang.String)
     */
    @Override
    public boolean appendRedirectLink(String redirectLink) {
        // do not add redirection if we are parsing a template:
        if (getRecursionLevel() == 0) {
            // remove "#section" from redirect links (this form of redirects is unsupported)
            if (redirectLink != null) {
                return super.appendRedirectLink(redirectLink.replaceFirst("#.*$", ""));
            }
            return super.appendRedirectLink(null);
        }
        return true;
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.AbstractWikiModel#appendInterWikiLink(java.lang.String, java.lang.String, java.lang.String)
     */
    @Override
    public void appendInterWikiLink(String namespace, String title, String linkText) {
        appendInterWikiLink(namespace, title, linkText, true);
    }
    
    protected void appendInterWikiLink(String namespace, String title, String linkText, boolean ignoreInterLang) {
        if (INTERLANGUAGE_KEYS.contains(namespace)) {
            // also check if this is an inter wiki link to an external wiki in another language
            // -> only ignore inter language links to the same wiki
            String namespace2 = splitAtColon(title)[0];
            if (!ignoreInterLang || (!namespace2.isEmpty() && isInterWiki(namespace2))) {
                // bliki is not able to parse language-specific interwiki links
                // -> use default language
                super.appendInterWikiLink(namespace2, title, linkText);
            } else {
                // ignore interlanguage keys
            }
        } else {
            super.appendInterWikiLink(namespace, title, linkText);
        }
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.WikiModel#addLink(java.lang.String)
     */
    @Override
    public void addLink(String topicName) {
        /*
         * do not add links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to
         * the internal links
         */
        String[] nsTitle = splitAtColon(topicName);
        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {
            appendInterWikiLink(nsTitle[0], nsTitle[1], "");
        } else {
            super.addLink(topicName);
        }
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.WikiModel#appendInternalLink(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)
     */
    @Override
    public void appendInternalLink(String topic0, String hashSection, String topicDescription,
            String cssClass, boolean parseRecursive) {
        /*
         * convert links like [[:w:nl:User:WinContro|Dutch Wikipedia]] to
         * external links if the link is an interwiki link
         */
        String[] nsTitle = splitAtColon(topic0);
        if (!nsTitle[0].isEmpty() && isInterWiki(nsTitle[0])) {
            appendInterWikiLink(nsTitle[0], nsTitle[1], topicDescription, nsTitle[1].isEmpty() && topicDescription.equals(topic0));
        } else {
            boolean pageExists = true;
            if (existingPages.hasContains()) {
                pageExists = existingPages.contains(normalisePageTitle(topic0));
            }
            super.appendInternalLink(topic0, hashSection, topicDescription, cssClass, parseRecursive, pageExists);
        }
    }

    /**
     * Normalises the given string, i.e. capitalises the first letter and
     * replaces underscores with spaces.
     * 
     * @param value
     *            the string
     * 
     * @return a normalised string
     */
    public static String normaliseName(final String value) {
        return Encoder.normaliseTitle(value, true, ' ', true);
    }
    
    /**
     * Normalises the given page title by capitalising its first letter after
     * the namespace.
     * 
     * @param title
     *            the original page title
     * 
     * @return the normalised page title
     */
    public NormalisedTitle normalisePageTitle(final String title) {
        return NormalisedTitle.fromUnnormalised(title, getNamespace());
    }
    
    /**
     * Normalises the given page title by capitalising its first letter after
     * the namespace.
     * 
     * @param maybeNs
     *            the namespace of the page
     * @param articleName
     *            the (unnormalised) page's name without the namespace
     * 
     * @return the normalised page title
     */
    public NormalisedTitle normalisePageTitle(final String maybeNs, final String articleName) {
        return NormalisedTitle.fromUnnormalised(maybeNs, articleName, getNamespace());
    }
    
    /**
     * Normalises the given page title by capitalising its first letter after
     * the namespace.
     * 
     * @param <T>
     * 
     * @param titles
     *            the original page titles
     * @param normalisedTitles
     *            the container to write the normalised titles to
     * 
     * @return the normalised page titles
     */
    public <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, T normalisedTitles) {
        return MyWikiModel.<T>normalisePageTitles(titles, getNamespace(), normalisedTitles);
    }
    
    /**
     * Normalises the given page titles by capitalising their first letter after
     * the namespace.
     * 
     * @param <T>
     * 
     * @param titles
     *            the original page titles
     * @param nsObject
     *            the namespace for determining how to split the title
     * @param normalisedTitles
     *            the container to write the normalised titles to
     * 
     * @return the normalised page titles
     */
    public static <T extends Collection<NormalisedTitle>> T normalisePageTitles(final Collection<String> titles, final MyNamespace nsObject, T normalisedTitles) {
        for (String title: titles) {
            normalisedTitles.add(NormalisedTitle.fromUnnormalised(title, nsObject));
        }
        return normalisedTitles;
    }
    
    /**
     * De-normalises the given page titles.
     * 
     * @param <T>
     * 
     * @param titles
     *            the normalised page titles
     * @param denormalisedTitles
     *            the container to write the de-normalised titles to
     * 
     * @return the original page title
     */
    public <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, T denormalisedTitles) {
        return MyWikiModel.<T>denormalisePageTitles(titles, getNamespace(), denormalisedTitles);
    }
    
    /**
     * De-normalises the given page titles.
     * 
     * @param <T>
     * 
     * @param titles
     *            the normalised page titles
     * @param nsObject
     *            the namespace for determining how to split the title
     * @param denormalisedTitles
     *            the container to write the de-normalised titles to
     * 
     * @return the original page title
     */
    public static <T extends Collection<String>> T denormalisePageTitles(final Collection<NormalisedTitle> titles, final MyNamespace nsObject, T denormalisedTitles) {
        for (NormalisedTitle title: titles) {
            denormalisedTitles.add(title.denormalise(nsObject));
        }
        return denormalisedTitles;
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.WikiModel#setUp()
     */
    @Override
    public void setUp() {
        super.setUp();
        magicWordCache = new HashMap<String, String>();
        pageCache = new HashMap<NormalisedTitle, String>();
        if (renderWikiText != null) {
            pageCache.put(normalisePageTitle(getPageName()), renderWikiText );
        }
    }

    /**
     * Checks whether the given namespace is a valid media namespace.
     * 
     * @param namespace
     *            the namespace to check
     * 
     * @return <tt>true</tt> if it is one of the two media namespace strings
     */
    public boolean isMediaNamespace(String namespace) {
        return namespace.equalsIgnoreCase(fNamespace.getMedia()) || namespace.equalsIgnoreCase(fNamespace.getMedia2());
    }

    /**
     * Gets information about the time needed to look up pages.
     * 
     * @return a mapping of page titles to retrieval times
     */
    public Map<String, List<Long>> getStats() {
        return stats;
    }

    /**
     * Adds the time needed to retrieve the given page to the collected
     * statistics.
     * 
     * @param title
     *            the title of the page
     * @param value
     *            the number of milliseconds it took to retrieve the page
     */
    public void addStat(String title, long value) {
        stats.put1(title, value);
    }

    /**
     * Adds the time needed to retrieve the given page to the collected
     * statistics.
     * 
     * @param title
     *            the title of the page
     * @param value
     *            multiple number of milliseconds it took to retrieve the page
     */
    public void addStats(String title, List<Long> value) {
        stats.put(title, value);
    }

    /**
     * Adds the time needed to retrieve the given page to the collected
     * statistics.
     * 
     * @param values
     *            a mapping between page titles and the number of milliseconds
     *            it took to retrieve the page
     */
    public void addStats(Map<String, List<Long>> values) {
        stats.putAll(values);
    }
    
    /**
     * Adds an involved key to the collected statistics.
     * 
     * @param key
     *            the key to add
     */
    public void addInvolvedKey(InvolvedKey key) {
        involvedKeys.add(key);
    }
    
    /**
     * Adds a number of involved keys to the collected statistics.
     * 
     * @param keys
     *            the keys to add
     */
    public void addInvolvedKeys(Collection<? extends InvolvedKey> keys) {
        involvedKeys.addAll(keys);
    }

    /**
     * Gets the list of all keys that have been read or written during the
     * current operation.
     * 
     * @return the involvedKeys
     */
    public List<InvolvedKey> getInvolvedKeys() {
        return involvedKeys;
    }
    
    /**
     * @return the existingPages
     */
    public ExistingPagesCache getExistingPages() {
        return existingPages;
    }

    /**
     * @param existingPages the existingPages to set
     */
    public void setExistingPages(ExistingPagesCache existingPages) {
        this.existingPages = existingPages;
    }
    
    /**
     * The following characters are forbidden in page titles:
     * <tt># &lt; &gt; [ ] | { }</tt>. Any line breaks and non-printable unicode
     * characters are also forbidden here.
     * 
     * @param title
     *            the title to check
     * 
     * @return <tt>true</tt> if the title contains a forbidden character,
     *         <tt>false</tt> otherwise
     * 
     * @see #MATCH_WIKI_FORBIDDEN_TITLE_CHARS
     */
    public static boolean isValidTitle(String title) {
        if (title == null || title.isEmpty() || title.length() >= 256) {
            return false;
        }
        final Matcher matcher = MATCH_WIKI_FORBIDDEN_TITLE_CHARS.matcher(title);
        return !matcher.matches();
    }

    /**
     * Determines whether a page with the given properties is an article.
     * 
     * A new page in the main namespace will be counted as an article if it
     * contains at least one wiki link or is categorised to at least one
     * category.
     * 
     * @param namespace
     *            the ID of the namespace of the page
     * @param links
     *            the links in this page
     * @param categories
     *            categories of this page
     * 
     * @return whether the page is an article or not
     * 
     * @see <a
     *      href="https://www.mediawiki.org/wiki/Manual:Article_count">MediaWiki
     *      explanation</a>
     */
    public static boolean isArticle(int namespace, Collection<String> links,
            Collection<String> categories) {
        return (namespace == 0) && (!links.isEmpty() || !categories.isEmpty());
    }
    
    /**
     * Gets all localised variants for the given special page.
     * 
     * @param page
     *            the special page
     * 
     * @return localised variants including the English names
     */
    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page) {
        ArrayList<String> result = new ArrayList<String>();
        
        for (Entry<String, String> prefix : SPECIAL_PREFIX.entrySet()) {
            EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get(prefix.getKey());
            if (localisedSuffix != null) {
                result.add(MyWikiModel.createFullPageName(prefix.getValue(), localisedSuffix.get(page)));
            }
            // Also add the English suffix for the localised prefix.
            EnumMap<SpecialPage, String> englishSuffix = SPECIAL_SUFFIX.get("en");
            if (englishSuffix != null) {
                result.add(MyWikiModel.createFullPageName(prefix.getValue(), englishSuffix.get(page)));
            }
        }
        return result;
    }
    
    /**
     * Gets the localised variants for the given special page.
     * 
     * @param page
     *            the special page
     * @param language
     *            the language to get the variants for
     * 
     * @return localised variants including the English names
     */
    public static Collection<String> getLocalisedSpecialPageNames(SpecialPage page, String language) {
        ArrayList<String> result = new ArrayList<String>(4);
        
        String localisedPrefix = SPECIAL_PREFIX.get("en");
        EnumMap<SpecialPage, String> localisedSuffix = SPECIAL_SUFFIX.get("en");
        result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));
        
        localisedPrefix = SPECIAL_PREFIX.get(language);
        localisedSuffix = SPECIAL_SUFFIX.get(language);
        if (localisedPrefix != null && localisedSuffix != null) {
            result.add(MyWikiModel.createFullPageName(localisedPrefix, localisedSuffix.get(page)));
        }
        return result;
    }

    /* (non-Javadoc)
     * @see info.bliki.wiki.model.AbstractWikiModel#isImageNamespace(java.lang.String)
     */
    @Override
    public boolean isImageNamespace(String namespace) {
        return super.isImageNamespace(namespace) ||
                ((MyNamespace) fNamespace).getNumberByName(namespace) == Namespace.FILE_NAMESPACE_KEY;
    }

    /**
     * Renders the raw Wikipedia text into a string for a given converter
     * (renders the wiki text as if a template topic will be displayed
     * directly).
     * 
     * @param converter
     *            a text converter. <b>Note</b> the converter may be
     *            <code>null</code>, if you only would like to analyze the raw
     *            wiki text and don't need to convert. This speeds up the
     *            parsing process.
     * @param rawWikiText
     *            a raw wiki text
     * @return <code>null</code> if an IOException occurs or
     *         <code>converter==null</code>
     * 
     * @see info.bliki.wiki.model.AbstractWikiModel#render(info.bliki.wiki.filter.ITextConverter,
     *      java.lang.String, boolean)
     */
    public String renderPageWithCache(ITextConverter converter, String rawWikiText) {
        renderWikiText = rawWikiText;
        return super.render(converter, rawWikiText, true);
    }

    /**
     * Renders the raw Wikipedia text into an HTML string and use the default
     * HTMLConverter (renders the wiki text as if a template topic will be
     * displayed directly).
     * 
     * @param rawWikiText
     *            a raw wiki text
     * @return <code>null</code> if an IOException occurs
     * 
     * @see info.bliki.wiki.model.AbstractWikiModel#render(java.lang.String,
     *      boolean)
     */
    public String renderPageWithCache(String rawWikiText) {
        renderWikiText = rawWikiText;
        return super.render(new HTMLConverter(), rawWikiText, true);
    }
}
```


Overlapping Code:
```
blic class MyWikiModel extends WikiModel {
/**
* Interwiki links pointing to other wikis in the web
*/
private static final String[] INTERLANGUAGE_STRINGS = { "en", "de", "fr",
"it", "pl", "es", "ja", "ru", "nl", "pt", "sv", "zh", "ca", "uk",
"no", "fi", "hu", "cs", "ro", "tr", "ko", "vi", "da", "ar", "eo",
"sr", "id", "lt", "vo", "sk", "he", "fa", "bg", "sl", "eu", "war",
"lmo", "et", "hr", "new", "te", "nn", "th", "gl", "el", "ceb",
"simple", "ms", "ht", "bs", "bpy", "lb", "ka", "is", "sq", "la",
"br", "hi", "az", "bn", "mk", "mr", "sh", "tl", "cy", "io", "pms",
"lv", "ta", "su", "oc", "jv", "nap", "nds", "scn", "be", "ast",
"ku", "wa", "af", "be-x-old", "an", "ksh", "szl", "fy", "frr",
"yue", "ur", "ia", "ga", "yi", "sw", "als", "hy", "am", "roa-rup",
"map-bms", "bh", "co", "cv", "dv", "nds-nl", "fo", "fur", "glk",
"gu", "ilo", "kn", "pam", "csb", "kk", "km", "lij", "li", "ml",
"gv", "mi", "mt", "nah", "ne", "nrm", "se", "nov", "qu", "os",
"pi", "pag", "ps", "pdc", "rm", "bat-smg", "sa", "gd", "sco", "sc",
"si", "tg", "roa-tara", "tt", "to", "tk", "hsb", "uz", "vec",
"fiu-vro", "wuu", "vls", "yo", "diq", "zh-min-nan", "zh-classical",
"frp", "lad", "bar", "bcl", "kw", "mn", "haw", "ang", "ln", "ie",
"wo", "tpi", "ty", "crh", "jbo", "ay", "zea", "eml", "ky", "ig",
"or", "mg", "cbk-zam", "kg", "arc", "rmy", "gn", "mo (closed)",
"so", "kab", "ks", "stq", "ce", "udm", "mzn", "pap", "cu", "sah",
"tet", "sd", "lo", "ba", "pnb", "iu", "na", "got", "bo", "dsb",
"chr", "cdo", "hak", "om", "my", "sm", "ee", "pcd", "ug", "as",
"ti", "av", "bm", "zu", "pnt", "nv", "cr", "pih", "ss", "ve", "bi",
"rw", "ch", "arz", "xh", "kl", "ik", "bug", "dz", "ts", "tn", "kv",
"tum", "xal", "st", "tw", "bxr", "ak", "ab", "ny", "fj", "lbe",
"ki", "za", "ff", "lg", "sn", "ha", "sg", "ii", "cho", "rn", "mh",
"chy", "ng", "kj", "ho", "mus", "kr", "hz", "mwl", "pa", "ace",
"bat-smg", "bjn", "cbk-zam", "cdo", "ceb", "crh", "dsb", "eml",
"ext", "fiu-vro", "frp", "frr", "gag", "gan", "hak", "kaa", "kab",
"kbd", "koi", "krc", "ksh", "lad", "lbe", "lmo", "map-bms", "mdf",
"mrj", "mwl", "nap", "nds-nl", "nrm", "pcd"
```
<Overlap Ratio: 0.9985842378480415>

---

--- 30 --
Question ID: 80ee0a6a7f3a4985856807c16dd83c933a62d954
Original Code:
```
@Path("/mr_clients")
@Api( value= "MR_Clients", description = "Endpoint for a Message Router Client that implements a Publisher or a Subscriber" )
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Authorization
public class MR_ClientResource extends BaseLoggingClass {

	private MR_ClientService mr_clientService = new MR_ClientService();
	private ResponseBuilder responseBuilder = new ResponseBuilder();
	private RequiredChecker checker = new RequiredChecker();
		
	@GET
	@ApiOperation( value = "return MR_Client details", 
	notes = "Returns array of  `MR_Client` objects.", 
	response = MR_Client.class)
	@ApiResponses( value = {
	    @ApiResponse( code = 200, message = "Success", response = MR_Client.class),
	    @ApiResponse( code = 400, message = "Error", response = ApiError.class )
	})
	public Response getMr_Clients() {
		List<MR_Client> clients = mr_clientService.getAllMr_Clients();

		GenericEntity<List<MR_Client>> list = new GenericEntity<List<MR_Client>>(clients) {
        };
        return responseBuilder.success(list);
	}
		
	@POST
	@ApiOperation( value = "Associate an MR_Client object to a Topic", 
	notes = "Create a  `MR_Client` object."
			+ "The `dcaeLocation` attribute is used to match an `MR_Cluster` object with the same value, with the intent of localizing message traffic."
			+ "  In legacy implementation, the `clientRole` is granted appropriate permission in AAF."
			+ "  Newer implementions may instead specify an AAF Identity, which will be added to the appropriate `Topic` role.", 
	response = MR_Client.class)
	@ApiResponses( value = {
	    @ApiResponse( code = 200, message = "Success", response = MR_Client.class),
	    @ApiResponse( code = 400, message = "Error", response = ApiError.class )
	})
	public Response addMr_Client(MR_Client client) {
		ApiError apiError = new ApiError();

		try {
			checker.required( "fqtn", client.getFqtn());
			checker.required( "dcaeLocationName", client.getDcaeLocationName());
			String s = client.getClientRole();
			if ( s == null ) {
				s = client.getClientIdentity();
			}
			checker.required( "clientRole or clientIdentity", s);
			checker.required( "action", client.getAction());

		} catch ( RequiredFieldException rfe ) {
			logger.debug( rfe.getApiError().toString() );
			return responseBuilder.error(rfe.getApiError());
		}
		MR_ClusterService clusters = new MR_ClusterService();

		MR_Cluster cluster = clusters.getMr_Cluster(client.getDcaeLocationName(), apiError);
		if ( cluster == null ) {

			apiError.setCode(Status.BAD_REQUEST.getStatusCode());
			apiError.setMessage( "MR_Cluster alias not found for dcaeLocation: " + client.getDcaeLocationName());
			apiError.setFields("dcaeLocationName");
			logger.warn(apiError.toString());
			return responseBuilder.error(apiError);
		}

		TopicService topics = new TopicService();

		Topic t = topics.getTopic(client.getFqtn(), apiError);
		if ( t == null ) {
			return responseBuilder.error(apiError);
		}
		MR_Client nClient =  mr_clientService.addMr_Client(client, t, apiError);
		if (apiError.is2xx()) {
			t = topics.getTopic(client.getFqtn(), apiError);
			topics.checkForBridge(t, apiError);
			return responseBuilder.success(nClient);
		}
		else {
			return responseBuilder.error(apiError);
		}
	}
		
	@PUT
	@ApiOperation( value = "Update an MR_Client object", 
	notes = "Update a  `MR_Client` object, specified by clientId", 
	response = MR_Client.class)
	@ApiResponses( value = {
	    @ApiResponse( code = 200, message = "Success", response = MR_Client.class),
	    @ApiResponse( code = 400, message = "Error", response = ApiError.class )
	})
	@Path("/{clientId}")
	public Response updateMr_Client(@PathParam("clientId") String clientId, MR_Client client) {
		ApiError apiError = new ApiError();

		try {
			checker.required( "fqtn", client.getFqtn());
			checker.required( "dcaeLocationName", client.getDcaeLocationName());
			checker.required( "clientRole", client.getClientRole());
			checker.required( "action", client.getAction());

		} catch ( RequiredFieldException rfe ) {
			logger.debug( rfe.getApiError().toString() );
			return responseBuilder.error(rfe.getApiError());
		}
		client.setMrClientId(clientId);
		MR_Client nClient = mr_clientService.updateMr_Client(client, apiError);
		if (apiError.is2xx()) {
			return Response.ok(nClient)
				.build();
		}
		return Response.status(apiError.getCode())
				.entity(apiError)
				.build();
	}
		
	@DELETE
	@ApiOperation( value = "Delete an MR_Client object", 
	notes = "Delete a  `MR_Client` object, specified by clientId", 
	response = MR_Client.class)
	@ApiResponses( value = {
	    @ApiResponse( code = 204, message = "Success", response = MR_Client.class),
	    @ApiResponse( code = 400, message = "Error", response = ApiError.class )
	})
	@Path("/{subId}")
	public Response deleteMr_Client(@PathParam("subId") String id){
		ApiError apiError = new ApiError();

		mr_clientService.removeMr_Client(id, true, apiError);
		if (apiError.is2xx()) {
			return responseBuilder.success(NO_CONTENT.getStatusCode(), null);
		}
		
		return responseBuilder.error(apiError);
	}

	@GET
	@ApiOperation( value = "return MR_Client details", 
	notes = "Retrieve a  `MR_Client` object, specified by clientId", 
	response = MR_Client.class)
	@ApiResponses( value = {
	    @ApiResponse( code = 200, message = "Success", response = MR_Client.class),
	    @ApiResponse( code = 400, message = "Error", response = ApiError.class )
	})
	@Path("/{subId}")
	public Response getMr_Client(@PathParam("subId") String id) {
		ApiError apiError = new ApiError();

		MR_Client nClient =  mr_clientService.getMr_Client(id, apiError);
		if (apiError.is2xx()) {
			return responseBuilder.success(nClient);
		}
		return responseBuilder.error(apiError);
	}
}
```


Overlapping Code:
```
= "MR_Clients", description = "Endpoint for a Message Router Client that implements a Publisher or a Subscriber" )
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Authorization
public class MR_ClientResource extends BaseLoggingClass {
private MR_ClientService mr_clientService = new MR_ClientService();
private ResponseBuilder responseBuilder = new ResponseBuilder();
private RequiredChecker checker = new RequiredChecker();

@GET
@ApiOperation( value = "return MR_Client details", 
notes = "Returns array of `MR_Client` objects.", 
response = MR_Client.class)
@ApiResponses( value = {
@ApiResponse( code = 200, message = "Success", response = MR_Client.class),
@ApiResponse( code = 400, message = "Error", response = ApiError.class )
})
public Response getMr_Clients() {
List<MR_Client> clients = mr_clientService.getAllMr_Clients();
GenericEntity<List<MR_Client>> list = new GenericEntity<List<MR_Client>>(clients) {
};
return responseBuilder.success(list);
}

@POST
@ApiOperation( value = "Associate an MR_Client object to a Topic", 
notes = "Create a `MR_Client` object."
+ "The `dcaeLocation` attribute is used to match an `MR_Cluster` object with the same value, with the intent of localizing message traffic."
+ " In legacy implementation, the `clientRole` is granted appropriate permission in AAF."
+ " Newer implementions may instead specify an AAF Identity, which will be added to the appropriate `Topic` role.", 
response = MR_Client.class)
@ApiResponses( value = {
@ApiResponse( code = 200, message = "Success", response = MR_Client.class),
@ApiResponse( code = 400, message = "Error", response = ApiError.class )
})
public Response addMr_Client(MR_Client client) {
ApiError apiError = new ApiError();
try {
checker.required( "fqtn", client.getFqtn());
checker.required( "dcaeLocationName", client.getDcaeLocationName());
String s = client.getClientRole();
if ( s == null ) {
s = client.getClientIdentity();
}
checker.required( "clientRole or clientIdentity", s);
checker.required( "action", client.getAction());
} catch ( RequiredFieldException rfe ) {
logger.debug( rfe.getApiError().toString() );
return responseBuilder.error(rfe.getApiError());
}
MR_ClusterService clusters = new MR_ClusterService();
MR_Cluster cluster = clusters.getMr_Cluster(client.getDcae
```
<Overlap Ratio: 0.970513900589722>

---

--- 31 --
Question ID: 24a13cc142348668849b4995296030b60c66fedb
Original Code:
```
class AkoumHellkiteTriggeredAbility extends TriggeredAbilityImpl {

    private static final String text = "<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, {this} deals 1 damage to any target. "
            + "If that land is a Mountain, Akoum Hellkite deals 2 damage to that permanent or player instead.";

    public AkoumHellkiteTriggeredAbility() {
        super(Zone.BATTLEFIELD, new AkoumHellkiteDamageEffect());
    }

    public AkoumHellkiteTriggeredAbility(final AkoumHellkiteTriggeredAbility ability) {
        super(ability);
    }

    @Override
    public AkoumHellkiteTriggeredAbility copy() {
        return new AkoumHellkiteTriggeredAbility(this);
    }

    @Override
    public boolean checkEventType(GameEvent event, Game game) {
        return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;
    }

    @Override
    public boolean checkTrigger(GameEvent event, Game game) {
        Permanent permanent = game.getPermanent(event.getTargetId());
        if (permanent != null
                && permanent.isLand()
                && permanent.isControlledBy(getControllerId())) {
            Permanent sourcePermanent = game.getPermanent(getSourceId());
            if (sourcePermanent != null) {
                for (Effect effect : getEffects()) {
                    if (effect instanceof AkoumHellkiteDamageEffect) {
                        effect.setTargetPointer(new FixedTarget(permanent, game));
                    }
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public String getRule() {
        return text;
    }
}
```


Overlapping Code:
```
teTriggeredAbility extends TriggeredAbilityImpl {
private static final String text = "<i>Landfall</i> &mdash; Whenever a land enters the battlefield under your control, {this} deals 1 damage to any target. "
+ "If that land is a Mountain, Akoum Hellkite deals 2 damage to that permanent or player instead.";
public AkoumHellkiteTriggeredAbility() {
super(Zone.BATTLEFIELD, new AkoumHellkiteDamageEffect());
}
public AkoumHellkiteTriggeredAbility(final AkoumHellkiteTriggeredAbility ability) {
super(ability);
}
@Override
public AkoumHellkiteTriggeredAbility copy() {
return new AkoumHellkiteTriggeredAbility(this);
}
@Override
public boolean checkEventType(GameEvent event, Game game) {
return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;
}
@Override
public boolean checkTrigger(GameEvent event, Game game) {
Permanent permanent = game.getPermanent(event.getTargetId());
if (permanent != null
&& permanent.isLand()
&& permanent.isControlledBy(getControllerId())) {
Permanent sourcePermanent = game.getPermanent(getSourceId());
if (sourcePermanent != null) {
for (Effect effect : getEffects()) {
if (effect instanceof AkoumHellkiteDamageEffect) {
effect.setTargetPointer(new FixedTarget(permanent, game));
}
return true;
}
}
}
return false;
}
@Override
public String getRule() {
return text;
```
<Overlap Ratio: 0.9841986455981941>

---

--- 32 --
Question ID: dd93eb1f5722f8fe6795a75469980047418947d8
Original Code:
```
public class PacketRunningShoes implements IMessage
{
	boolean isRunningShoes;
	public PacketRunningShoes(){

	}

	public PacketRunningShoes(boolean isRunningShoes){
		this.isRunningShoes = isRunningShoes;
	}

	@Override
	public void fromBytes(ByteBuf buffer) 
	{
		isRunningShoes = buffer.readBoolean();
	}

	@Override
	public void toBytes(ByteBuf buffer) 
	{
		buffer.writeBoolean(isRunningShoes);
	}
	
	public static class Handler implements IMessageHandler<PacketRunningShoes, IMessage> 
	{
        @Override
        public IMessage onMessage(PacketRunningShoes message, MessageContext ctx) 
        {
        	EntityPlayer player = ctx.getServerHandler().playerEntity;
        	ExtendedPlayer props = ExtendedPlayer.get(player);
    		props.isRunning = message.isRunningShoes;
    		props.saveProxyData(player);
    		props.loadProxyData(player);
    		return null;
        }
    }

}
```


Overlapping Code:
```
ents IMessage
{
boolean isRunningShoes;
public PacketRunningShoes(){
}
public PacketRunningShoes(boolean isRunningShoes){
this.isRunningShoes = isRunningShoes;
}
@Override
public void fromBytes(ByteBuf buffer) 
{
isRunningShoes = buffer.readBoolean();
}
@Override
public void toBytes(ByteBuf buffer) 
{
buffer.writeBoolean(isRunningShoes);
}

public static class Handler implements IMessageHandler<PacketRunningShoes, IMessage> 
{
@Override
public IMessage onMessage(PacketRunningShoes message, MessageContext ctx) 
{
EntityPlayer player = ctx.getServerHandler().playerEntity;
ExtendedPlayer props = ExtendedPlayer.get(player);
props.isRunning = message.isRunningShoes;
props.saveProxyData(player);
props.loadProxyData(p
```
<Overlap Ratio: 0.9183673469387755>

---

--- 33 --
Question ID: 98431ce199502477d7e5d51902642e98a05b1485
Original Code:
```
public class ColorSpectrum extends Display {
	public ExPar Color = new ExPar(COLOR, new ExParValue(new ExParExpression(
			ExParExpression.GRAY)), "Dummy bar color");

	public ColorSpectrum() {
		setTitleAndTopic("Smooth Color Spectrum", DISPLAY_TEST_DSP | DEMO);
	}
	private int nLines;
	private int s1, x1, x2, y1, y2;
	private Color[] spectrum = new Color[(700 - 400) + 1];

	protected int create() {
		s1 = enterDisplayElement(new Bar(Color));
		SpectralDistribution sd;
		SpectralDistribution CIEy = SpectralDistributionFactory.yCMF31();
		int k = 0;
		for (int i = 400; i <= 700; i++) {
			sd = new SpectralDistribution(400, 701, 1, 0.0F);
			sd.setValueAt(i, 1.0);
			PxlColor c = sd.toXYZ();
			c.setY(CIEy.valueAt(i) * 80.0);
			spectrum[k++] = c.dev();
		}
		return s1;
	}

	protected void computeGeometry() {
		Rectangle r = centeredRect(width, height, (int) (4 * width / 5),
				(int) (height / 4));
		nLines = r.width;
		x1 = r.x;
		x2 = r.x;
		y1 = r.y;
		y2 = r.y + r.height;
	}

	/**
	 * This display has its own paint method for drawing the non-selectable
	 * transition area.
	 */
	public void show(Graphics g) {
		super.show(g);
		// Now draw the transition area. Positions have already been computed.
		if (nLines > 0) {
			int xx1 = x1;
			int xx2 = x2;
			for (int i = 0; i < nLines; i++) {
				g.setColor(spectrum[(int) ((double) ((spectrum.length - 1)) * i / (double) (nLines - 1))]);
				g.drawLine(xx1++, y1, xx2++, y2);
			}
		}
	}
}
```


Overlapping Code:
```
pectrum extends Display {
public ExPar Color = new ExPar(COLOR, new ExParValue(new ExParExpression(
ExParExpression.GRAY)), "Dummy bar color");
public ColorSpectrum() {
setTitleAndTopic("Smooth Color Spectrum", DISPLAY_TEST_DSP | DEMO);
}
private int nLines;
private int s1, x1, x2, y1, y2;
private Color[] spectrum = new Color[(700 - 400) + 1];
protected int create() {
s1 = enterDisplayElement(new Bar(Color));
SpectralDistribution sd;
SpectralDistribution CIEy = SpectralDistributionFactory.yCMF31();
int k = 0;
for (int i = 400; i <= 700; i++) {
sd = new SpectralDistribution(400, 701, 1, 0.0F);
sd.setValueAt(i, 1.0);
PxlColor c = sd.toXYZ();
c.setY(CIEy.valueAt(i) * 80.0);
spectrum[k++] = c.dev();
}
return s1;
}
protected void computeGeometry() {
Rectangle r = centeredRect(width, height, (int) (4 * width / 5),
(int) (height / 4));
nLines = r.width;
x1 = r.x;
x2 = r.x;
y1 = r.y;
y2 = r.y + r.height;
}
/**
* This display has its own paint method for drawing the non-selectable
* transition area.
*/
public void show(Graphics g) {
super.show(g);
// Now draw the transition area. Positions have already been computed.
if (nLines > 0) {
int xx1 = x1;
int xx2 = x2;
for (int i = 0; i < nLines; i++) {
g.setColor(spectrum[(int) ((double) ((spectrum.length - 1)) * i / (double) (nLines - 1))]);
g
```
<Overlap Ratio: 0.9565857247976454>

---

--- 34 --
Question ID: b59cbe299a80281192c5dc7496aaa332d63488a7
Original Code:
```
public class BorrowTracking {
	private LinkedList theBorrowed; //declare new linked list
	private Tree myLibrary; //deliver the Tree instance
	/**
	 * This is the constructor of the BorrowTacking system
	 * @param myLibrary need to use the Tree class to read the detailed information
	 */
	public BorrowTracking(Tree myLibrary) {
		theBorrowed = new LinkedList(myLibrary); //make new linked list
		this.myLibrary = myLibrary;
	}
	/**
	 * This method is to show whether anything be borrowed
	 */
	public void anyBeBorrowed() {
		if (theBorrowed.isEmpty() == true) { //if nothing borrowed
			System.out.println("Nothing got borrowed");
		} else { //something borrowed
			System.out.println("Something got borrowed");
		}
	}
	/**
	 * This method prints how many things are borrowed
	 */
	public void howManyBeBorrowed() {
		System.out.println("Number of total borrowed is "+theBorrowed.size()+".");
	}
	/**
	 * This method is to set the publication to be returned
	 * @param uniqueCode
	 */
	public void returned(String uniqueCode) {
		theBorrowed.deleteByCode(uniqueCode); //remove from Borrowing system
		myLibrary.returnByCode(uniqueCode); //set publication to be not borrowed
	}
	
	/**
	 * This method is to set the publication to be borrowed.
	 * @param name who borrowed this, need to be a string.
	 * @param uniqueCode what is the code, ISBN or ASIN of the publication, 
	 */
	public void borrow(String name, String uniqueCode) {
		theBorrowed.insert(name, uniqueCode); //add the info to borrow tracking system
		myLibrary.borrowByCode(uniqueCode); //set publication to be borrowed
	}
	/**
	 * This method is to sort the borrow tracking system information by the alphabetical order of name
	 */
	public void sort() {
		theBorrowed.sortByName();
	}
	/**
	 * This is to display the borrowed list information.
	 */
	public void displayBorrowedList() {
		theBorrowed.displayList();
	}
}
```


Overlapping Code:
```
LinkedList theBorrowed; //declare new linked list
private Tree myLibrary; //deliver the Tree instance
/**
* This is the constructor of the BorrowTacking system
* @param myLibrary need to use the Tree class to read the detailed information
*/
public BorrowTracking(Tree myLibrary) {
theBorrowed = new LinkedList(myLibrary); //make new linked list
this.myLibrary = myLibrary;
}
/**
* This method is to show whether anything be borrowed
*/
public void anyBeBorrowed() {
if (theBorrowed.isEmpty() == true) { //if nothing borrowed
System.out.println("Nothing got borrowed");
} else { //something borrowed
System.out.println("Something got borrowed");
}
}
/**
* This method prints how many things are borrowed
*/
public void howManyBeBorrowed() {
System.out.println("Number of total borrowed is "+theBorrowed.size()+".");
}
/**
* This method is to set the publication to be returned
* @param uniqueCode
*/
public void returned(String uniqueCode) {
theBorrowed.deleteByCode(uniqueCode); //remove from Borrowing system
myLibrary.returnByCode(uniqueCode); //set publication to be not borrowed
}

/**
* This method is to set the publication to be borrowed.
* @param name who borrowed this, need to be a string.
* @param uniqueCode what is the code, ISBN or ASIN of the publication, 
*/
public void borrow(String name, String uniqueCode) {
theBorrowed.insert(name, uniqueCode); //add the info to borrow tracking system
myLibrary.borrowByCode(uniqueCode); //set publication to be borrowed
}
/**
* This method is to sort the borrow tracking system information by the alphabetical order of name
*/
public void sort() {
theBorrowed.sortByName();
}
/**
* This is to display the borrowed list information.
*/
public void displayBorrowedList() {
theBorrowed.displayLis
```
<Overlap Ratio: 0.9743875278396437>

---

--- 35 --
Question ID: 0d9aecb6dc3050bed6dd31bcbed57b1cf8b9abad
Original Code:
```
public class TypoTokenFilterFactory extends TokenFilterFactory implements ResourceLoaderAware, MultiTermAwareComponent {

    private final HashMap<String, String> normMap = new HashMap<>();
    private final String dictionary;

    public TypoTokenFilterFactory(Map<String, String> args) {
        super(args);
        dictionary = require(args, "dictionary");

        if (!args.isEmpty()) {
            throw new IllegalArgumentException("Unknown parameters: " + args);
        }
    }

    @Override
    public TokenStream create(TokenStream tokenStream) {
        return new TypoTokenFilter(tokenStream, normMap);
    }

    @Override
    public AbstractAnalysisFactory getMultiTermComponent() {
        return this;
    }

    @Override
    public void inform(ResourceLoader loader) throws IOException {

        Set<String> wlist = new HashSet<>();
        List<String> files = splitFileNames(dictionary);

        for (String file : files) {
            List<String> lines = getLines(loader, file.trim());
            wlist.addAll(lines);
        }

        for (String s : wlist) {

            String[] parts = s.split("\t");

            if (parts.length != 2) throw new RuntimeException("more than two words in the phrase " + s);

            if (parts[0].contains(" ") || parts[1].contains(" "))
                throw new RuntimeException("typo parts should not contain spaces " + String.join("_", parts));

            normMap.put(parts[0], parts[1]);
        }


    }


    private static final class TypoTokenFilter extends TokenFilter {

        private final HashMap<String, String> map;

        private final CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);

        TypoTokenFilter(TokenStream input, HashMap<String, String> map) {
            super(input);
            this.map = map;
        }

        @Override
        public boolean incrementToken() throws IOException {

            if (!input.incrementToken()) return false;

            final String term = termAttribute.toString();

            //    boolean matched = false;

            List<String> matchedKeys = new ArrayList<>();

            for (String key : map.keySet()) {
                if (term.startsWith(key)) {
                    matchedKeys.add(key);
                }
            }

            if (matchedKeys.size() == 1) {
                termAttribute.setEmpty().append(map.get(matchedKeys.get(0)));
            } else if (matchedKeys.size() > 1) {
                String minKey = Collections.min(matchedKeys, Comparator.comparingInt(String::length));
                termAttribute.setEmpty().append(map.get(minKey));
                System.out.println(minKey + " " + matchedKeys);
            }

            return true;
        }
    }

    public static void main(String[] args) throws Exception {
        String text = "egzos egzost yunanlı orjinal cimnastik yapmışlar anotomi motorsiklet motorsiklette orjinali orjinalleri";
        System.out.println("--------typo----------------");
        System.out.println(getAnalyzedString(text, typo()));
    }
}
```


Overlapping Code:
```
TokenFilterFactory extends TokenFilterFactory implements ResourceLoaderAware, MultiTermAwareComponent {
private final HashMap<String, String> normMap = new HashMap<>();
private final String dictionary;
public TypoTokenFilterFactory(Map<String, String> args) {
super(args);
dictionary = require(args, "dictionary");
if (!args.isEmpty()) {
throw new IllegalArgumentException("Unknown parameters: " + args);
}
}
@Override
public TokenStream create(TokenStream tokenStream) {
return new TypoTokenFilter(tokenStream, normMap);
}
@Override
public AbstractAnalysisFactory getMultiTermComponent() {
return this;
}
@Override
public void inform(ResourceLoader loader) throws IOException {
Set<String> wlist = new HashSet<>();
List<String> files = splitFileNames(dictionary);
for (String file : files) {
List<String> lines = getLines(loader, file.trim());
wlist.addAll(lines);
}
for (String s : wlist) {
String[] parts = s.split("\t");
if (parts.length != 2) throw new RuntimeException("more than two words in the phrase " + s);
if (parts[0].contains(" ") || parts[1].contains(" "))
throw new RuntimeException("typo parts should not contain spaces " + String.join("_", parts));
normMap.put(parts[0], parts[1]);
}
}
private static final class TypoTokenFilter extends TokenFilter {
private final HashMap<String, String> map;
private final CharTermAttribute termAttribute = addAttribute(CharTermAttribute.class);
TypoTokenFilter(TokenStream input, HashMap<String, String> map) {
super(input);
this.map = map;
}
@Override
public boolean incrementToken() throws IOException {
if (!input.incrementToken()) return false;
final String term = termAttribute.toString();
// boolean matched = false;
List<String> matchedKeys = new ArrayList<>();
for (String key : map.keySet()) {
if (term.startsWith(key)) {
matchedKeys.add(key);
}
}
if (matchedKeys.size() == 1) {
termAttribute.setEmpty().append(map.get(matchedKeys.get(0)));
} else i
```
<Overlap Ratio: 0.9735234215885947>

---

--- 36 --
Question ID: b07c855d1039461983235df4b45d92ae11ad5b6c
Original Code:
```
public class GrMapTypeFromNamedArgs extends GrMapType {

  private final @NotNull LinkedHashMap<String, GrExpression> myStringEntries;
  private final @NotNull List<Couple<GrExpression>> myOtherEntries;

  private final VolatileNotNullLazyValue<List<Couple<PsiType>>> myTypesOfOtherEntries = new VolatileNotNullLazyValue<List<Couple<PsiType>>>() {
    @NotNull
    @Override
    protected List<Couple<PsiType>> compute() {
      return ContainerUtil.map(myOtherEntries, pair -> Couple.of(inferTypePreventingRecursion(pair.first), inferTypePreventingRecursion(pair.second)));
    }
  };

  private final VolatileNotNullLazyValue<LinkedHashMap<String, PsiType>> myTypesOfStringEntries = new VolatileNotNullLazyValue<LinkedHashMap<String,PsiType>>() {
    @NotNull
    @Override
    protected LinkedHashMap<String, PsiType> compute() {
      LinkedHashMap<String, PsiType> result = new LinkedHashMap<>();
      for (Map.Entry<String, GrExpression> entry : myStringEntries.entrySet()) {
        result.put(entry.getKey(), inferTypePreventingRecursion(entry.getValue()));
      }
      return result;
    }

  };

  public GrMapTypeFromNamedArgs(@NotNull PsiElement context, @NotNull GrNamedArgument[] namedArgs) {
    this(JavaPsiFacade.getInstance(context.getProject()), context.getResolveScope(), namedArgs);
  }

  public GrMapTypeFromNamedArgs(@NotNull JavaPsiFacade facade, @NotNull GlobalSearchScope scope, @NotNull GrNamedArgument[] namedArgs) {
    super(facade, scope);

    myStringEntries = new LinkedHashMap<>();
    myOtherEntries = new ArrayList<>();
    for (GrNamedArgument namedArg : namedArgs) {
      final GrArgumentLabel label = namedArg.getLabel();
      final GrExpression expression = namedArg.getExpression();
      if (label == null || expression == null) {
        continue;
      }

      final String name = label.getName();
      if (name != null) {
        myStringEntries.put(name, expression);
      }
      else {
        GrExpression labelExpression = label.getExpression();
        if (labelExpression != null) {
          myOtherEntries.add(Couple.of(labelExpression, expression));
        }
      }
    }
  }

  @Nullable
  @Override
  public PsiType getTypeByStringKey(String key) {
    GrExpression expression = myStringEntries.get(key);
    return expression != null ? inferTypePreventingRecursion(expression) : null;
  }

  @NotNull
  @Override
  public Set<String> getStringKeys() {
    return myStringEntries.keySet();
  }

  @Override
  public boolean isEmpty() {
    return myStringEntries.isEmpty() && myOtherEntries.isEmpty();
  }

  @Nullable
  private PsiType inferTypePreventingRecursion(final GrExpression expression) {
    return RecursionManager.doPreventingRecursion(expression, false,
                                                  () -> TypesUtil.boxPrimitiveType(expression.getType(), expression.getManager(), myScope));
  }

  @NotNull
  @Override
  protected List<Couple<PsiType>> getOtherEntries() {
    return myTypesOfOtherEntries.getValue();
  }

  @NotNull
  @Override
  protected LinkedHashMap<String, PsiType> getStringEntries() {
    return myTypesOfStringEntries.getValue();
  }

  @Override
  public boolean isValid() {
    for (GrExpression expression : myStringEntries.values()) {
      if (!expression.isValid()) return false;
    }

    for (Couple<GrExpression> entry : myOtherEntries) {
      if (!entry.first.isValid()) return false;
      if (!entry.second.isValid()) return false;
    }

    return true;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    GrMapTypeFromNamedArgs args = (GrMapTypeFromNamedArgs)o;

    if (!myStringEntries.equals(args.myStringEntries)) return false;
    if (!myOtherEntries.equals(args.myOtherEntries)) return false;

    return true;
  }

  @Override
  public int hashCode() {
    int result = super.hashCode();
    result = 31 * result + myStringEntries.hashCode();
    result = 31 * result + myOtherEntries.hashCode();
    return result;
  }
}
```


Overlapping Code:
```
pType {
private final @NotNull LinkedHashMap<String, GrExpression> myStringEntries;
private final @NotNull List<Couple<GrExpression>> myOtherEntries;
private final VolatileNotNullLazyValue<List<Couple<PsiType>>> myTypesOfOtherEntries = new VolatileNotNullLazyValue<List<Couple<PsiType>>>() {
@NotNull
@Override
protected List<Couple<PsiType>> compute() {
return ContainerUtil.map(myOtherEntries, pair -> Couple.of(inferTypePreventingRecursion(pair.first), inferTypePreventingRecursion(pair.second)));
}
};
private final VolatileNotNullLazyValue<LinkedHashMap<String, PsiType>> myTypesOfStringEntries = new VolatileNotNullLazyValue<LinkedHashMap<String,PsiType>>() {
@NotNull
@Override
protected LinkedHashMap<String, PsiType> compute() {
LinkedHashMap<String, PsiType> result = new LinkedHashMap<>();
for (Map.Entry<String, GrExpression> entry : myStringEntries.entrySet()) {
result.put(entry.getKey(), inferTypePreventingRecursion(entry.getValue()));
}
return result;
}
};
public GrMapTypeFromNamedArgs(@NotNull PsiElement context, @NotNull GrNamedArgument[] namedArgs) {
this(JavaPsiFacade.getInstance(context.getProject()), context.getResolveScope(), namedArgs);
}
public GrMapTypeFromNamedArgs(@NotNull JavaPsiFacade facade, @NotNull GlobalSearchScope scope, @NotNull GrNamedArgument[] namedArgs) {
super(facade, scope);
myStringEntries = new LinkedHashMap<>();
myOtherEntries = new ArrayList<>();
for (GrNamedArgument namedArg : namedArgs) {
final GrArgumentLabel label = namedArg.getLabel();
final GrExpression expression = namedArg.getExpression();
if (label == null || expression == null) {
continue;
}
final String name = label.getName();
if (name != null) {
myStringEntries.put(name, expression);
}
else {
GrExpression labelExpression = label.getExpression();
if (labelExpression != null) {
myOtherEntries.add(Couple.of(labelExpression, expression));
}
}
}
}
@Nullable
@Override
public PsiType getTypeByStringKey(String key) {
GrExpression expression = myStringEntries.get(key);
return expression != null ? inferTypePreventingRecursion(expression) : null;
}
@NotNull
@Override
public Set<String> getStringKeys() {
return myStringEntries.keySet();
}
@Override
publi
```
<Overlap Ratio: 0.9714030384271671>

---

--- 37 --
Question ID: 2978490b2682228ad2280b271b61c1caafa5da52
Original Code:
```
public class SiftingAppender extends SiftingAppenderBase
{

	public SiftingAppender()
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #9   <Method void SiftingAppenderBase()>
	//    2    4:return          
	}

	protected boolean eventMarksEndOfLife(ILoggingEvent iloggingevent)
	{
		iloggingevent = ((ILoggingEvent) (iloggingevent.getMarker()));
	//    0    0:aload_1         
	//    1    1:invokeinterface #18  <Method Marker ILoggingEvent.getMarker()>
	//    2    6:astore_1        
		if(iloggingevent == null)
	//*   3    7:aload_1         
	//*   4    8:ifnonnull       13
			return false;
	//    5   11:iconst_0        
	//    6   12:ireturn         
		else
			return ((Marker) (iloggingevent)).contains(ClassicConstants.FINALIZE_SESSION_MARKER);
	//    7   13:aload_1         
	//    8   14:getstatic       #24  <Field Marker ClassicConstants.FINALIZE_SESSION_MARKER>
	//    9   17:invokeinterface #30  <Method boolean Marker.contains(Marker)>
	//   10   22:ireturn         
	}

	protected volatile boolean eventMarksEndOfLife(Object obj)
	{
		return eventMarksEndOfLife((ILoggingEvent)obj);
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:checkcast       #14  <Class ILoggingEvent>
	//    3    5:invokevirtual   #33  <Method boolean eventMarksEndOfLife(ILoggingEvent)>
	//    4    8:ireturn         
	}

	protected long getTimestamp(ILoggingEvent iloggingevent)
	{
		return iloggingevent.getTimeStamp();
	//    0    0:aload_1         
	//    1    1:invokeinterface #39  <Method long ILoggingEvent.getTimeStamp()>
	//    2    6:lreturn         
	}

	protected volatile long getTimestamp(Object obj)
	{
		return getTimestamp((ILoggingEvent)obj);
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:checkcast       #14  <Class ILoggingEvent>
	//    3    5:invokevirtual   #42  <Method long getTimestamp(ILoggingEvent)>
	//    4    8:lreturn         
	}

	public void setDiscriminator(Discriminator discriminator)
	{
		super.setDiscriminator(discriminator);
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:invokespecial   #49  <Method void SiftingAppenderBase.setDiscriminator(Discriminator)>
	//    3    5:return          
	}
}
```


Overlapping Code:
```
pender extends SiftingAppenderBase
{
public SiftingAppender()
{
// 0 0:aload_0 
// 1 1:invokespecial #9 <Method void SiftingAppenderBase()>
// 2 4:return 
}
protected boolean eventMarksEndOfLife(ILoggingEvent iloggingevent)
{
iloggingevent = ((ILoggingEvent) (iloggingevent.getMarker()));
// 0 0:aload_1 
// 1 1:invokeinterface #18 <Method Marker ILoggingEvent.getMarker()>
// 2 6:astore_1 
if(iloggingevent == null)
//* 3 7:aload_1 
//* 4 8:ifnonnull 13
return false;
// 5 11:iconst_0 
// 6 12:ireturn 
else
return ((Marker) (iloggingevent)).contains(ClassicConstants.FINALIZE_SESSION_MARKER);
// 7 13:aload_1 
// 8 14:getstatic #24 <Field Marker ClassicConstants.FINALIZE_SESSION_MARKER>
// 9 17:invokeinterface #30 <Method boolean Marker.contains(Marker)>
// 10 22:ireturn 
}
protected volatile boolean eventMarksEndOfLife(Object obj)
{
return eventMarksEndOfLife((ILoggingEvent)obj);
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:checkcast #14 <Class ILoggingEvent>
// 3 5:invokevirtual #33 <Method boolean eventMarksEndOfLife(ILoggingEvent)>
// 4 8:ireturn 
}
protected long getTimestamp(ILoggingEvent iloggingevent)
{
return iloggingevent.getTimeStamp();
// 0 0:aload_1 
// 1 1:invokeinterface #39 <Method long ILoggingEvent.getTimeStamp()>
// 2 6:lreturn 
}
protected volatile long getTimestamp(Object obj)
{
return getTimestamp((ILoggingEvent)obj);
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:checkcast #14 <Class ILoggingEvent>
// 3 5:invokevirtual #42 <Method long getTimestamp(ILoggingEvent)>
// 4 8:lreturn 
}
public void setDiscriminator(Discriminator discriminator)
{
super.setDiscriminator(discriminator);
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:invokespecial #49 <Method void SiftingAppenderBase.setDiscriminator(Discriminator)>
// 3 5:return 
}
}
```
<Overlap Ratio: 0.9875846501128668>

---

--- 38 --
Question ID: ba1e9741d3b740b9893ddafbf1a7ba49afca8c8b
Original Code:
```
class DateVersionSelector implements VersionSelector {

    /**
     * a version date hint
     */
    private final long timestamp;

    /**
     * Creates a {@code DateVersionSelector} that will select the latest
     * version of all those that are older than the given timestamp.
     *
     * @param timestamp reference timestamp
     */
    public DateVersionSelector(String timestamp) {
        this.timestamp = ISO8601.parse(timestamp).getTimeInMillis();
    }

    @Override
    public NodeBuilder select(@Nonnull NodeBuilder history)
            throws RepositoryException {
        long latestDate = Long.MIN_VALUE;
        NodeBuilder latestVersion = null;
        for (String name: history.getChildNodeNames()) {
            // OAK-1192 skip hidden child nodes
            if (name.charAt(0) == ':') {
                continue;
            }
            NodeBuilder v = history.getChildNode(name);
            if (name.equals(JcrConstants.JCR_ROOTVERSION)
                    || name.equals(JcrConstants.JCR_VERSIONLABELS)) {
                // ignore root version and labels node
                continue;
            }
            long c = ISO8601.parse(v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE)).getTimeInMillis();
            if (c > latestDate && c <= timestamp) {
                latestDate = c;
                latestVersion = v;
            } else if (c == latestDate) {
                throw new RepositoryException("two versions share the same jcr:created timestamp in history:" + history);
            }
        }
        return latestVersion;
    }
}
```


Overlapping Code:
```
VersionSelector {
/**
* a version date hint
*/
private final long timestamp;
/**
* Creates a {@code DateVersionSelector} that will select the latest
* version of all those that are older than the given timestamp.
*
* @param timestamp reference timestamp
*/
public DateVersionSelector(String timestamp) {
this.timestamp = ISO8601.parse(timestamp).getTimeInMillis();
}
@Override
public NodeBuilder select(@Nonnull NodeBuilder history)
throws RepositoryException {
long latestDate = Long.MIN_VALUE;
NodeBuilder latestVersion = null;
for (String name: history.getChildNodeNames()) {
// OAK-1192 skip hidden child nodes
if (name.charAt(0) == ':') {
continue;
}
NodeBuilder v = history.getChildNode(name);
if (name.equals(JcrConstants.JCR_ROOTVERSION)
|| name.equals(JcrConstants.JCR_VERSIONLABELS)) {
// ignore root version and labels node
continue;
}
long c = ISO8601.parse(v.getProperty(JcrConstants.JCR_CREATED).getValue(Type.DATE)).getTimeInMillis();
if (c > latestDate && c <= timestamp) {
latestDate = c;
latestVersion = v;
} else if (c == latestDate) {
throw new RepositoryException("two versions share the same jcr:created timestamp in history:" + history
```
<Overlap Ratio: 0.9437652811735942>

---

--- 39 --
Question ID: e6c54a8daf7f2de3ea9cbce44f576440373d3d4a
Original Code:
```
public class userchoice
{
    public static void main()throws IOException
    {
        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
        System.out.println("Enter the Nth value");
        int n=Integer.parseInt(br.readLine());
        System.out.println("Enter your choice");
        int ch=Integer.parseInt(br.readLine());
        switch(ch)
        {
            case 1:double s=0;int j=4;
                   for(int i=1;i<=n;i++)
                   {
                       s=s+(double)((double)1/(double)j);
                       j=j+4;
                   }
                   System.out.println("Series1 is"+s);
                   break;
            case 2:double s1=0;int k=1;int f;
                   for(int i=1;i<=n;i++)
                   {
                       f=1;
                       for(int j1=1;j1<=i;j1++)
                         f=f*j1;
                       s1=s1+(double)(((double)1/(double)f)*k);
                       k=k*(-1);
                    }
                   System.out.println("Series2 is"+s1);
                   break;
            default:System.out.println("Invalid Input");
        }
    }
}
```


Overlapping Code:
```
e
{
public static void main()throws IOException
{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
System.out.println("Enter the Nth value");
int n=Integer.parseInt(br.readLine());
System.out.println("Enter your choice");
int ch=Integer.parseInt(br.readLine());
switch(ch)
{
case 1:double s=0;int j=4;
for(int i=1;i<=n;i++)
{
s=s+(double)((double)1/(double)j);
j=j+4;
}
System.out.println("Series1 is"+s);
break;
case 2:double s1=0;int k=1;int f;
for(int i=1;i<=n;i++)
{
f=1;
for(int j1=1;j1<=i;j1++)
f=f*j1;
s1=s1+(double)(((double)1/(double)f)*k);
k=k*(-1);
}
System.out.println("Series2 is"+s1);
break;
default:System.out.println("Inv
```
<Overlap Ratio: 0.9415121255349501>

---

--- 40 --
Question ID: 2617b47296faa5004cccc34808cd207c355eab21
Original Code:
```
public class CuratorManager implements Managed {

    private final CuratorFramework framework;

    /**
     * Constructor
     * 
     * @param framework
     *            {@link CuratorFramework}
     */
    public CuratorManager(@Nonnull final CuratorFramework framework) {
        this.framework = checkNotNull(framework);
        // start framework directly to allow other bundles to interact with
        // zookeeper during their run() method.
        if (this.framework.getState() != CuratorFrameworkState.STARTED) {
            this.framework.start();
        }
    }

    @Override
    public void start() throws Exception {
        framework.blockUntilConnected();
        final Stat stat = framework.checkExists().forPath("/");
        if (stat == null) {
            // ensure that the root path is available
            framework.create().creatingParentsIfNeeded().forPath("/");
        }
    }

    @Override
    public void stop() throws Exception {
        framework.close();
    }
}
```


Overlapping Code:
```
lass CuratorManager implements Managed {
private final CuratorFramework framework;
/**
* Constructor
* 
* @param framework
* {@link CuratorFramework}
*/
public CuratorManager(@Nonnull final CuratorFramework framework) {
this.framework = checkNotNull(framework);
// start framework directly to allow other bundles to interact with
// zookeeper during their run() method.
if (this.framework.getState() != CuratorFrameworkState.STARTED) {
this.framework.start();
}
}
@Override
public void start() throws Exception {
framework.blockUntilConnected();
final Stat stat = framework.checkExists().forPath("/");
if (stat == null) {
// ensure that the root path is available
framework.create().creatingParentsIfNeeded().forPath("/");
}
}
@Override
public void stop() throws Exception {
framework.close();
}
}
```
<Overlap Ratio: 0.9900621118012423>

---

--- 41 --
Question ID: c018f72b8c8dd46e35e2006e1a493888ae0e9cc6
Original Code:
```
@ApplicationScoped
public class OpenApiEndpointProducer {

    @Produces
    @ApplicationScoped
    DeploymentMetaData deployment() {
        DeploymentMetaData deployment = new DeploymentMetaData("microprofile-openapi");
        deployment.setContextPath("/openapi");
        deployment.addServlet(servlet());
        deployment.setManagement(true);
        return deployment;
    }

    ServletMetaData servlet() {
        ServletMetaData servlet = new ServletMetaData("endpoint", OpenApiServlet.class);
        servlet.addUrlPattern("/*");
        return servlet;
    }
}
```


Overlapping Code:
```
ionScoped
public class OpenApiEndpointProducer {
@Produces
@ApplicationScoped
DeploymentMetaData deployment() {
DeploymentMetaData deployment = new DeploymentMetaData("microprofile-openapi");
deployment.setContextPath("/openapi");
deployment.addServlet(servlet());
deployment.setManagement(true);
return deployment;
}
ServletMetaData servlet() {
ServletMetaData servlet = new ServletMetaData("endpoint", OpenApiServlet.class);
servlet.addUrlPattern("
```
<Overlap Ratio: 0.9297520661157025>

---

--- 42 --
Question ID: 0816306c2537cf28670a6f8f9080b30529052468
Original Code:
```
public class ExtractData
{

    public ExtractData(){}

    public ArrayList<String> course() throws IOException
    {
        ArrayList<String> course = new ArrayList<String>();
        //Get scanner instance
        Scanner scan = new Scanner(new File("D:\\Documents\\UUM\\Sem 4\\Real-time Programming\\STIW3054\\rtass2\\Ass2pdf.csv"));
         
        //Set the delimiter used in file
        scan.useDelimiter("[;\n]");
        String word= " ";
        

        while(scan.hasNext())
        {
            word=scan.next();
            if(!word.contains("BIL.")){
                if(!word.contains("CODE")){
                    if(!word.contains("COURSE")){
                        if(!word.contains("DATE/TIME")){
                            course.add(word);//add only data not include (BIL. , CODE , COURSE ,DATE/TIME)
                        }
                    }
                }
            }
        }
        scan.close();
        return course;
    }
}
```


Overlapping Code:
```
lic ExtractData(){}
public ArrayList<String> course() throws IOException
{
ArrayList<String> course = new ArrayList<String>();
//Get scanner instance
Scanner scan = new Scanner(new File("D:\\Documents\\UUM\\Sem 4\\Real-time Programming\\STIW3054\\rtass2\\Ass2pdf.csv"));

//Set the delimiter used in file
scan.useDelimiter("[;\n]");
String word= " ";

while(scan.hasNext())
{
word=scan.next();
if(!word.contains("BIL.")){
if(!word.contains("CODE")){
if(!word.contains("COURSE")){
if(!word.contains("DATE/TIME")){
course.add(word);//add only data not include (BIL. , CODE , COURSE ,DATE/TIME)
}
}
}
}

```
<Overlap Ratio: 0.9036144578313253>

---

--- 43 --
Question ID: 3c5afe9360c61362cb4d2b54f5faab701276b5b4
Original Code:
```
@ParametersExtractor("markScaleValueParametersExtractor")
public class MarkScaleValueParametersExtractor extends AbstractParametersExtractor<MarkScaleValue>  {

	@Resource(name = "markScaleDao")
	private Dao<MarkScale, MarkScale, Long> markScaleDao;
	
	@Override
	public Map<String, Object> getParameters(final MarkScaleValue entity, final Map<String, Object> parameters) {
		
		addParameter(entity.getMarkScale(), markScaleDao, "markScale", parameters);

		addParameter(entity.getStrValue(), "strValue", parameters);
		
		return parameters;
	}

}
```


Overlapping Code:
```
ractor("markScaleValueParametersExtractor")
public class MarkScaleValueParametersExtractor extends AbstractParametersExtractor<MarkScaleValue> {
@Resource(name = "markScaleDao")
private Dao<MarkScale, MarkScale, Long> markScaleDao;

@Override
public Map<String, Object> getParameters(final MarkScaleValue entity, final Map<String, Object> parameters) {

addParameter(entity.getMarkScale(), markScaleDao, "markScale", parameters);
addParameter(entity.getStrValue(), "strValue", parameters);

return pa
```
<Overlap Ratio: 0.9487666034155597>

---

--- 44 --
Question ID: 6d269195af8aff7c49389f53431ea814820b9662
Original Code:
```
public class ProvisioningClassLoaderConfigurer implements ClassLoaderConfigurer {
    // just some default if one is not set
    private URL[] added = new URL[0];
    private Filter excluded = FalseFilter.INSTANCE;

    @Override
    public URL[] additionalURLs() {
        return added;
    }

    @Override
    public boolean accept(final URL url) {
        try {
            final File file = URLs.toFile(url);
            return !excluded.accept(file.getName());
        } catch (final IllegalArgumentException iae) {
            return true;
        }
    }

    public void setConfiguration(final String configFile) {
        final Collection<URL> toAdd = new ArrayList<URL>();
        final Collection<String> toExclude = new ArrayList<String>();

        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(configFile));

            String line;
            while ((line = reader.readLine()) != null) {
                line = PropertyPlaceHolderHelper.SUBSTITUTOR.replace(line.trim());
                if (line.startsWith("#") || line.isEmpty()) {
                    continue;
                }

                if (line.startsWith("-")) {
                    toExclude.add(line);
                } else {
                    if (line.startsWith("+")) {
                        line = line.substring(1);
                    }

                    String location = line;
                    String algo = "MD5";
                    String hash = null;
                    final boolean validJar = line.contains("|");

                    if (validJar) {
                        final String[] segments = line.split("|");
                        location = segments[0];
                        if (segments.length >= 2) {
                            hash = segments[1];
                        }
                        if (segments.length >= 3) {
                            algo = segments[2].trim();
                        }

                    }

                    final Set<URL> repos = toUrls(ProvisioningUtil.realLocation(location));
                    toAdd.addAll(repos);

                    if (validJar) {
                        final String computedHash = Files.hash(repos, algo);
                        if (!computedHash.equals(hash)) {
                            throw new IllegalStateException("Hash of " + location + "(" + computedHash + ") doesn't match expected one (" + hash + ")");
                        }
                    }
                }
            }

        } catch (final Exception e) {
            Logger.getInstance(LogCategory.OPENEJB, ProvisioningClassLoaderConfigurer.class).error("Can't read " + configFile, e);
        } finally {
            IO.close(reader);
        }

        added = toAdd.toArray(new URL[toAdd.size()]);
        if (toExclude.size() > 0) {
            excluded = Filters.prefixes(toExclude.toArray(new String[toExclude.size()]));
        }
    }

    private static Set<URL> toUrls(final Set<String> strings) {
        final Set<URL> urls = new HashSet<>();
        for (final String s : strings) {
            try {
                urls.add(new File(s).toURI().toURL());
            } catch (final MalformedURLException e) {
                throw new IllegalArgumentException(e);
            }
        }
        return urls;
    }
}
```


Overlapping Code:
```
ublic class ProvisioningClassLoaderConfigurer implements ClassLoaderConfigurer {
// just some default if one is not set
private URL[] added = new URL[0];
private Filter excluded = FalseFilter.INSTANCE;
@Override
public URL[] additionalURLs() {
return added;
}
@Override
public boolean accept(final URL url) {
try {
final File file = URLs.toFile(url);
return !excluded.accept(file.getName());
} catch (final IllegalArgumentException iae) {
return true;
}
}
public void setConfiguration(final String configFile) {
final Collection<URL> toAdd = new ArrayList<URL>();
final Collection<String> toExclude = new ArrayList<String>();
BufferedReader reader = null;
try {
reader = new BufferedReader(new FileReader(configFile));
String line;
while ((line = reader.readLine()) != null) {
line = PropertyPlaceHolderHelper.SUBSTITUTOR.replace(line.trim());
if (line.startsWith("#") || line.isEmpty()) {
continue;
}
if (line.startsWith("-")) {
toExclude.add(line);
} else {
if (line.startsWith("+")) {
line = line.substring(1);
}
String location = line;
String algo = "MD5";
String hash = null;
final boolean validJar = line.contains("|");
if (validJar) {
final String[] segments = line.split("|");
location = segments[0];
if (segments.length >= 2) {
hash = segments[1];
}
if (segments.length >= 3) {
algo = segments[2].trim();
}
}
final Set<URL> repos = toUrls(ProvisioningUtil.realLocation(location));
toAdd.addAll(repos);
if (validJar) {
final String computedHash = Files.hash(repos, algo);
if (!computedHash.equals(hash)) {
throw new IllegalStateException("Hash of " + location + "(" + computedHash + ") doesn'
```
<Overlap Ratio: 0.9750152346130408>

---

--- 45 --
Question ID: 4146c44e5ff63502d4479ee779b916a7238ff048
Original Code:
```
public class TilkjentYtelseV1Test {

    private static ObjectMapper mapper = getObjectMapper();

    @Test
    public void skal_serialisere_riktig() throws JsonProcessingException {
        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()
                .setAktørId("9000012345678")
                .setSaksnummer("2525253")
                .setBehandlingId(100000123)
                .setVedtaksdato(LocalDate.of(2019, 3, 10))
                .setGjelderAdopsjon(false)
                .setAnsvarligSaksbehandler("Z000001")
                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);
        var andeler1 = new ArrayList<TilkjentYtelseAndelV1>();
        andeler1.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS));
        andeler1.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1000L, DAGSATS).medArbeidsgiverOrgNr("123123123"));
        var andeler2 = new ArrayList<TilkjentYtelseAndelV1>();
        andeler2.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 135L, DAGSATS));
        andeler2.add(TilkjentYtelseAndelV1.refusjon(ARBEIDSTAKER, 1586L, DAGSATS).medArbeidsgiverOrgNr("123123123").leggTilFeriepenger(Year.of(2018), 187));

        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();
        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler1));
        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2019, 3, 1), LocalDate.of(2019, 3, 31), andeler2));
        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)
                .setErOpphør(true)
                .setErOpphørEtterSkjæringstidspunkt(false);

        String resultat = mapper.writeValueAsString(tilkjentYtelseV1);

        //hvis du endrer noe slik at denne testen feiler, har du gjort noe galt! Endringene du ønsker krever at du oppretter en ny versjon av TilkjentYtelse
        assertThat(resultat).isEqualTo("{\"version\":\"1.0\",\"behandingsinfo\":{\"aktoerId\":\"9000012345678\",\"saksnummer\":\"2525253\",\"behandlingId\":100000123,\"ytelseType\":\"FORELDREPENGER\",\"gjelderAdopsjon\":false,\"vedtaksdato\":\"2019-03-10\",\"ansvarligSaksbehandler\":\"Z000001\"},\"perioder\":[{\"fom\":\"2018-12-24\",\"tom\":\"2019-02-28\",\"andeler\":[{\"utbetalesTilBruker\":true,\"inntektskategori\":\"FRILANSER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":100},{\"utbetalesTilBruker\":false,\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":1000}]},{\"fom\":\"2019-03-01\",\"tom\":\"2019-03-31\",\"andeler\":[{\"utbetalesTilBruker\":true,\"inntektskategori\":\"FRILANSER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":135},{\"utbetalesTilBruker\":false,\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsType\":\"DAGSATS\",\"feriepenger\":[{\"opptjeningsaar\":2018,\"beloep\":187}],\"satsBeloep\":1586}]}],\"erOpphoer\":true,\"erOpphoerEtterSkjaeringTidspunkt\":false}");
    }

    @Test
    public void skal_serialisere_og_deserialisere_med_feriepenger() throws IOException, ParseException {
        TilkjentYtelseBehandlingInfoV1 info = new TilkjentYtelseBehandlingInfoV1()
                .setAktørId("90000123")
                .setSaksnummer("2525253")
                .setBehandlingId(100000123)
                .setVedtaksdato(LocalDate.of(2019, 3, 10))
                .setGjelderAdopsjon(false)
                .setAnsvarligSaksbehandler("Z000001")
                .setYtelseType(TilkjentYtelseV1.YtelseType.FORELDREPENGER);
        var andeler = new ArrayList<TilkjentYtelseAndelV1>();
        andeler.add(TilkjentYtelseAndelV1.tilBruker(FRILANSER, 100L, DAGSATS).leggTilFeriepenger(Year.of(2018), 12));

        var perioder = new ArrayList<TilkjentYtelsePeriodeV1>();
        perioder.add(new TilkjentYtelsePeriodeV1(LocalDate.of(2018, 12, 24), LocalDate.of(2019, 2, 28), andeler));
        TilkjentYtelse tilkjentYtelseV1 = new TilkjentYtelseV1(info, perioder)
                .setEndringsdato(LocalDate.of(2018, 12, 27));

        String json = mapper.writeValueAsString(tilkjentYtelseV1);
        TilkjentYtelse resultat = mapper.readValue(json, TilkjentYtelse.class);
        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);

        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;
        ty.kryssvalider();

        assertThat(ty.getEndringsdato()).isEqualTo(LocalDate.of(2018, 12, 27));
        TilkjentYtelseAndelV1 andel = ty.getPerioder().iterator().next().getAndeler().iterator().next();
        List<TilkjentYtelseFeriepengerV1> feriepenger = andel.getFeriepenger();
        assertThat(feriepenger).hasSize(1);
        assertThat(feriepenger.get(0).getBeløp()).isEqualTo(12);
        assertThat(feriepenger.get(0).getOpptjeningsår()).isEqualTo(2018);
    }

    @Test
    public void skal_deserialisere() throws IOException, ParseException {
        TilkjentYtelse resultat = mapper.readValue("{\"version\":\"1.0\",\"behandingsinfo\":{\"saksnummer\":\"2525253\",\"behandlingId\":100000123,\"ytelseType\":\"FORELDREPENGER\",\"gjelderAdopsjon\":false,\"vedtaksdato\":\"2019-03-10\",\"ansvarligSaksbehandler\":\"Z000001\",\"aktoerId\":\"90000123\"},\"perioder\":[{\"fom\":\"2018-12-24\",\"tom\":\"2019-02-28\",\"andeler\":[{\"utbetalesTilBruker\":true,\"inntektskategori\":\"FRILANSER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":100},{\"utbetalesTilBruker\":false,\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":1000}]},{\"fom\":\"2019-03-01\",\"tom\":\"2019-03-31\",\"andeler\":[{\"utbetalesTilBruker\":true,\"inntektskategori\":\"FRILANSER\",\"satsType\":\"DAGSATS\",\"satsBeloep\":135},{\"utbetalesTilBruker\":false,\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsType\":\"DAGSATS\",\"feriepenger\":[{\"opptjeningsaar\":2018,\"beloep\":187}],\"satsBeloep\":1586}]}],\"erOpphoer\":true,\"erOpphoerEtterSkjaeringTidspunkt\":false}", TilkjentYtelse.class);

        assertThat(resultat).isInstanceOf(TilkjentYtelseV1.class);

        TilkjentYtelseV1 ty = (TilkjentYtelseV1) resultat;
        ty.kryssvalider();
        TilkjentYtelseBehandlingInfoV1 info = ty.getBehandingsinfo();
        assertThat(info.getAktørId()).isEqualTo("90000123");
        assertThat(info.getSaksnummer()).isEqualTo("2525253");
        assertThat(info.getBehandlingId()).isEqualTo(100000123);
        assertThat(info.getVedtaksdato()).isEqualTo(LocalDate.of(2019, 3, 10));
        assertThat(info.isGjelderAdopsjon()).isFalse();
        assertThat(info.getAnsvarligSaksbehandler()).isEqualTo("Z000001");
        assertThat(info.getYtelseType()).isEqualTo(TilkjentYtelseV1.YtelseType.FORELDREPENGER);

        assertThat(ty.getPerioder()).hasSize(2);
        TilkjentYtelsePeriodeV1 periode = ty.getPerioder().iterator().next();
        assertThat(periode.getAndeler()).hasSize(2);
        assertThat(periode.getFom()).isEqualTo(LocalDate.of(2018, 12, 24));
        assertThat(periode.getTom()).isEqualTo(LocalDate.of(2019, 2, 28));
        Iterator<TilkjentYtelseAndelV1> andeler = periode.getAndeler().iterator();
        TilkjentYtelseAndelV1 andel1 = andeler.next();
        assertThat(andel1.getUtbetalesTilBruker()).isTrue();
        assertThat(andel1.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.FRILANSER);
        assertThat(andel1.getSatsBeløp()).isEqualTo(100);
        assertThat(andel1.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);
        assertThat(andel1.getArbeidsgiverOrgNr()).isNull();
        assertThat(andel1.getArbeidsgiverAktørId()).isNull();
        TilkjentYtelseAndelV1 andel2 = andeler.next();
        assertThat(andel2.getUtbetalesTilBruker()).isFalse();
        assertThat(andel2.getInntektskategori()).isEqualTo(TilkjentYtelseV1.Inntektskategori.ARBEIDSTAKER);
        assertThat(andel2.getSatsBeløp()).isEqualTo(1000);
        assertThat(andel2.getSatsType()).isEqualTo(TilkjentYtelseV1.SatsType.DAGSATS);
        assertThat(andel2.getArbeidsgiverOrgNr()).isEqualTo("123123123");
        assertThat(andel2.getArbeidsgiverAktørId()).isNull();
    }

    @Test
    public void skal_ikke_deserialisere_ukjent_versjon() {
        assertThrows(InvalidTypeIdException.class, () -> mapper.readValue("{\"version\":\"1000.0\",\"behandingsinfo\":{\"aktoerId\":90000123,\"saksnummer\":\"2525253\",\"behandlingId\":100000123,\"ytelseType\":\"FORELDREPENGER\",\"gjelderAdopsjon\":false,\"vedtaksdato\":\"2019-03-10\",\"ansvarligSaksbehandler\":\"Z000001\",\"ansvarligBeslutter\":\"Z222222\"},\"perioder\":[{\"fom\":\"2018-12-24\",\"tom\":\"2019-02-28\",\"andeler\":[{\"inntektskategori\":\"FRILANSER\",\"satsBeløp\":100,\"satsType\":\"DAGSATS\"},{\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsBeløp\":1000,\"satsType\":\"DAGSATS\"}]},{\"fom\":\"2019-03-01\",\"tom\":\"2019-03-31\",\"andeler\":[{\"inntektskategori\":\"FRILANSER\",\"satsBeløp\":135,\"satsType\":\"DAGSATS\"},{\"arbeidsgiverOrgNr\":\"123123123\",\"inntektskategori\":\"ARBEIDSTAKER\",\"satsBeløp\":1586,\"satsType\":\"DAGSATS\"}]}]}", TilkjentYtelse.class));
    }

    private static ObjectMapper getObjectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new Jdk8Module());
        mapper.registerModule(new JavaTimeModule());
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return mapper;
    }

}
```


Overlapping Code:
```
(LocalDate.of(2019, 3, 1), LocalDate.of(2019, 3, 3
```
<Overlap Ratio: 0.022461814914645103>

---

--- 46 --
Question ID: bfc8323487cc8b05462c45e2c7c87ca68da330f2
Original Code:
```
public class GradleClassFinder extends NonClasspathClassFinder {

  @NotNull private final GradleInstallationManager myLibraryManager;

  public GradleClassFinder(Project project, @NotNull GradleInstallationManager manager) {
    super(project);
    myLibraryManager = manager;
  }

  @Override
  protected List<VirtualFile> calcClassRoots() {
    final List<VirtualFile> roots = myLibraryManager.getClassRoots(myProject);
    if (roots != null) {
      return roots;
    }
    return Collections.emptyList();
  }
}
```


Overlapping Code:
```
ic class GradleClassFinder extends NonClasspathClassFinder {
@NotNull private final GradleInstallationManager myLibraryManager;
public GradleClassFinder(Project project, @NotNull GradleInstallationManager manager) {
super(project);
myLibraryManager = manager;
}
@Override
protected List<VirtualFile> calcClassRoots() {
final List<VirtualFile> roots = myLibraryManager.getClassRoots(myProject);
if (roots != null) {
return roots;
}
return Collections.
```
<Overlap Ratio: 0.9574468085106383>

---

--- 47 --
Question ID: bdfdc02944813387a0451c853da04caa89656fc2
Original Code:
```
public class Products {

	public int[] product(int[] array) {
		int product = 1;
		int[] productArray = new int[array.length];

		for (int i = 0; i < array.length; i++) {
			for (int j = 0; j < array.length; j++) {
				if (j != i) {
					product = product * array[j];
				}
			}
			productArray[i] = product;
			product = 1;
		}
		return productArray;

	}

	public static void main(String[] args) {

		Products test = new Products();
		int[] array = { 1, 2, 3, 4, 5 };

		int[] array1 = test.product(array);

		for (int k : array1) {
			System.out.println(k);
		}
	}
}
```


Overlapping Code:
```
public class Products {
public int[] product(int[] array) {
int product = 1;
int[] productArray = new int[array.length];
for (int i = 0; i < array.length; i++) {
for (int j = 0; j < array.length; j++) {
if (j != i) {
product = product * array[j];
}
}
productArray[i] = product;
product = 1;
}
return productArray;
}
public static void main(String[] args) {
Products test = new Products();
int[] array = { 1, 2, 3, 4, 5 };
int[] array1 = test.product(array);
for (int k : array1) {
System.out.println(
```
<Overlap Ratio: 0.9823182711198428>

---

--- 48 --
Question ID: b6a477a06cbb2aa840b6e6dd3130bff948ff74e3
Original Code:
```
public class AjpProtocol extends AbstractAjpProtocol {
    
    
    private static final Log log = LogFactory.getLog(AjpProtocol.class);

    @Override
    protected Log getLog() { return log; }


    @Override
    protected AbstractEndpoint.Handler getHandler() {
        return cHandler;
    }


    // ------------------------------------------------------------ Constructor


    public AjpProtocol() {
        endpoint = new JIoEndpoint();
        cHandler = new AjpConnectionHandler(this);
        ((JIoEndpoint) endpoint).setHandler(cHandler);
        setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
        setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
        setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
    }

    
    // ----------------------------------------------------- Instance Variables

    
    /**
     * Connection handler for AJP.
     */
    private AjpConnectionHandler cHandler;


    // ----------------------------------------------------- JMX related methods

    @Override
    protected String getNamePrefix() {
        return ("ajp-bio");
    }


    // --------------------------------------  AjpConnectionHandler Inner Class


    protected static class AjpConnectionHandler
            extends AbstractConnectionHandler implements Handler {

        protected AjpProtocol proto;

        protected ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor> connections =
            new ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor>();

        protected RecycledProcessors<AjpProcessor> recycledProcessors =
            new RecycledProcessors<AjpProcessor>(this);

        public AjpConnectionHandler(AjpProtocol proto) {
            this.proto = proto;
        }
        
        @Override
        protected AbstractProtocol getProtocol() {
            return proto;
        }

        @Override
        protected Log getLog() {
            return log;
        }

        @Override
        public SSLImplementation getSslImplementation() {
            // AJP does not support SSL
            return null;
        }

        @Override
        public void recycle() {
            recycledProcessors.clear();
        }
        
        @Override
        public SocketState process(SocketWrapper<Socket> socket) {
            return process(socket,SocketStatus.OPEN);
        }

        @Override
        public SocketState process(SocketWrapper<Socket> socket, SocketStatus status) {
            AjpProcessor processor = connections.remove(socket);
            try {
                if (processor == null) {
                    processor = recycledProcessors.poll();
                }
                if (processor == null) {
                    processor = createProcessor();
                }

                SocketState state = socket.isAsync()?processor.asyncDispatch(status):processor.process(socket);
                if (state == SocketState.LONG) {
                    connections.put(socket, processor);
                    socket.setAsync(true);
                    // longPoll may change socket state (e.g. to trigger a
                    // complete or dispatch)
                    return processor.asyncPostProcess();
                } else {
                    socket.setAsync(false);
                    processor.recycle();
                    recycledProcessors.offer(processor);
                }
                return state;
            } catch(java.net.SocketException e) {
                // SocketExceptions are normal
                log.debug(sm.getString(
                        "ajpprotocol.proto.socketexception.debug"), e);
            } catch (java.io.IOException e) {
                // IOExceptions are normal
                log.debug(sm.getString(
                        "ajpprotocol.proto.ioexception.debug"), e);
            }
            // Future developers: if you discover any other
            // rare-but-nonfatal exceptions, catch them here, and log as
            // above.
            catch (Throwable e) {
                ExceptionUtils.handleThrowable(e);
                // any other exception or error is odd. Here we log it
                // with "ERROR" level, so it will show up even on
                // less-than-verbose logs.
                log.error(sm.getString("ajpprotocol.proto.error"), e);
            }
            processor.recycle();
            recycledProcessors.offer(processor);
            return SocketState.CLOSED;
        }

        protected AjpProcessor createProcessor() {
            AjpProcessor processor = new AjpProcessor(proto.packetSize, (JIoEndpoint)proto.endpoint);
            processor.setAdapter(proto.adapter);
            processor.setTomcatAuthentication(proto.tomcatAuthentication);
            processor.setRequiredSecret(proto.requiredSecret);
            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());
            processor.setClientCertProvider(proto.getClientCertProvider());
            register(processor);
            return processor;
        }
    }
}
```


Overlapping Code:
```
 AjpProtocol extends AbstractAjpProtocol {


private static final Log log = LogFactory.getLog(AjpProtocol.class);
@Override
protected Log getLog() { return log; }
@Override
protected AbstractEndpoint.Handler getHandler() {
return cHandler;
}
// ------------------------------------------------------------ Constructor
public AjpProtocol() {
endpoint = new JIoEndpoint();
cHandler = new AjpConnectionHandler(this);
((JIoEndpoint) endpoint).setHandler(cHandler);
setSoLinger(Constants.DEFAULT_CONNECTION_LINGER);
setSoTimeout(Constants.DEFAULT_CONNECTION_TIMEOUT);
setTcpNoDelay(Constants.DEFAULT_TCP_NO_DELAY);
}

// ----------------------------------------------------- Instance Variables

/**
* Connection handler for AJP.
*/
private AjpConnectionHandler cHandler;
// ----------------------------------------------------- JMX related methods
@Override
protected String getNamePrefix() {
return ("ajp-bio");
}
// -------------------------------------- AjpConnectionHandler Inner Class
protected static class AjpConnectionHandler
extends AbstractConnectionHandler implements Handler {
protected AjpProtocol proto;
protected ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor> connections =
new ConcurrentHashMap<SocketWrapper<Socket>, AjpProcessor>();
protected RecycledProcessors<AjpProcessor> recycledProcessors =
new RecycledProcessors<AjpProcessor>(this);
public AjpConnectionHandler(AjpProtocol proto) {
this.proto = proto;
}

@Override
protected AbstractProtocol getProtocol() {
return proto;
}
@Override
protected Log getLog() {
return log;
}
@Override
public SSLImplementation getSslImplementation() {
// AJP does not support SSL
return null;
}
@Override
public void recycle() {
recycledProcessors.clear();
}

@Override
public SocketState process(SocketWrapper<Socket> socket) {
return process(socket,SocketStatus.OPEN);
}
@Override
public SocketState process(SocketWrapper<Socket> socke
```
<Overlap Ratio: 0.993193717277487>

---

--- 49 --
Question ID: 93b3490859b65aadc79743e3929d101eaa8ecc65
Original Code:
```
public class Resource {
  private final String resourceUrl;
  private final AuthzStatus priorAclDecision;
  
  public Resource(String url, AuthzStatus priorAclDecision) {
    resourceUrl = url;
    this.priorAclDecision = priorAclDecision;
  }
  
  public String getUrl() {
    return resourceUrl;
  }
  
  public AuthzStatus getPriorAclDecision() {
    return priorAclDecision;
  }

  /**
   * Gets a collection of resources from a collection of urls with no Acls.
   * @param urls collection of urls.
   * @return collection of resources.
   */
  public static Collection<Resource> urlsToResourcesNoAcls(Collection<String> urls) {
    ImmutableList.Builder<Resource> resources = ImmutableList.builder();
    for (String url : urls) {
      resources.add(new Resource(url, null));
    }
    return resources.build();
  }

  /**
   * Gets the urls in a list of Resources.
   * @param resources collection of resources.
   * @return collection of urls.
   */
  public static Collection<String> resourcesToUrls(Collection<Resource> resources) {
    ImmutableList.Builder<String> resourceUrls = ImmutableList.builder();
    for (Resource resource : resources) {
      resourceUrls.add(resource.getUrl());
    }
    return resourceUrls.build();
  }

}
```


Overlapping Code:
```
ring resourceUrl;
private final AuthzStatus priorAclDecision;

public Resource(String url, AuthzStatus priorAclDecision) {
resourceUrl = url;
this.priorAclDecision = priorAclDecision;
}

public String getUrl() {
return resourceUrl;
}

public AuthzStatus getPriorAclDecision() {
return priorAclDecision;
}
/**
* Gets a collection of resources from a collection of urls with no Acls.
* @param urls collection of urls.
* @return collection of resources.
*/
public static Collection<Resource> urlsToResourcesNoAcls(Collection<String> urls) {
ImmutableList.Builder<Resource> resources = ImmutableList.builder();
for (String url : urls) {
resources.add(new Resource(url, null));
}
return resources.build();
}
/**
* Gets the urls in a list of Resources.
* @param resources collection of resources.
* @return collection of urls.
*/
public static Collection<String> resourcesToUrls(Collection<Resource> resources) {
ImmutableList.Builder<String> resourceUrls = ImmutableList.builder();
for (Resource resource : resources) {
resourceUrls.add(resource.getUrl())
```
<Overlap Ratio: 0.9325044404973357>

---

--- 50 --
Question ID: dd6b38bb949eba9f0a5e0c9e135aea57a0e47637
Original Code:
```
@Component
public class MailMan {

    private static final String KEY_HOST_SETTING = "mail.smtp.host";

    @Autowired
    private MailProps mailProps;

    /**
     * Sends a message to a user.
     * @param user the user who should get the message
     * @param content the content of the message
     * @param subject the subject of the message
     */
    public void sendMail(User user, String content, String subject) {

        Logger logger = LoggerFactory.getLogger(MailMan.class);

        if(user.getEmail() == null) {
            logger.error("User has no email set! Unable to send mail!");
            return;
        }

        Properties props = new Properties();
        props.put(KEY_HOST_SETTING, mailProps.getHost());

        Session session = Session.getInstance(props, null);

        try {
            MimeMessage msg = new MimeMessage(session);
            msg.setFrom(new InternetAddress(mailProps.getFrom()));
            InternetAddress[] address = {new InternetAddress(user.getEmail())};
            msg.setRecipients(Message.RecipientType.TO, address);
            msg.setSubject(subject);
            msg.setSentDate(new Date());
            msg.setHeader("X-Mailer", Consts.MAIL_XMAILER);
            msg.setText(content);
            msg.saveChanges(); // don't forget this
            if (mailProps.isAuthrequired()) {
                if (mailProps.getAuthpass().equals("changeme") || mailProps.getAuthusr().equals("changeme")) {
                    logger.warn("It seems like you didn't change the standard mail auth settings.");
                }
                Transport tr = session.getTransport("smtp");
                tr.connect(mailProps.getHost(), mailProps.getAuthusr(), mailProps.getAuthpass());
                tr.sendMessage(msg, msg.getAllRecipients());
                tr.close();
            } else {
                Transport.send(msg);
            }

            logger.debug("Email sent to " + user.getUsername());
        } catch (MessagingException mex) {
            logger.error("Error sending mail: ", mex);
        }
    }


}
```


Overlapping Code:
```
tic final String KEY_HOST_SETTING = "mail.smtp.host";
@Autowired
private MailProps mailProps;
/**
* Sends a message to a user.
* @param user the user who should get the message
* @param content the content of the message
* @param subject the subject of the message
*/
public void sendMail(User user, String content, String subject) {
Logger logger = LoggerFactory.getLogger(MailMan.class);
if(user.getEmail() == null) {
logger.error("User has no email set! Unable to send mail!");
return;
}
Properties props = new Properties();
props.put(KEY_HOST_SETTING, mailProps.getHost());
Session session = Session.getInstance(props, null);
try {
MimeMessage msg = new MimeMessage(session);
msg.setFrom(new InternetAddress(mailProps.getFrom()));
InternetAddress[] address = {new InternetAddress(user.getEmail())};
msg.setRecipients(Message.RecipientType.TO, address);
msg.setSubject(subject);
msg.setSentDate(new Date());
msg.setHeader("X-Mailer", Consts.MAIL_XMAILER);
msg.setText(content);
msg.saveChanges(); // don't forget this
if (mailProps.isAuthrequired()) {
if (mailProps.getAuthpass().equals("changeme") || mailProps.getAuthusr().equals("changeme")) {
logger.warn("It seems like you didn't change the standard mail auth settings.");
}
Transport tr = session.getTransport("smtp");
tr.connect(mailProps.getHost(), mailProps.getAuthusr(), mailProps.getAuthpass());
tr.sendMessage(msg, msg.getAllRecipients());
tr.close();
} else {
Transport.send(msg);
}
logger.debug("Email sent to " + user.getUsername());
} catch (MessagingException mex) {
logger.error(
```
<Overlap Ratio: 0.950920245398773>

---

--- 51 --
Question ID: 63a7db83f57a1d359c27d52be5eaaf01cbc7dbfd
Original Code:
```
public class CVRequest extends ASN1Object {

	private final ASN1Integer cvRequestVersion = new ASN1Integer(1);
	private Query query = null;
	private GeneralNames requestorRef = null;
	private ASN1OctetString requestNonce = null;
	private GeneralName requestorName = null;
	private GeneralName responderName = null;
	private Extensions requestExtensions = null;
	private AlgorithmIdentifier signatureAlg = null;
	private ASN1ObjectIdentifier hashAlg = null;
	private DERUTF8String requestorText = null;

	public CVRequest(Query query, GeneralNames requestorRef,
			ASN1OctetString requestNonce, GeneralName requestorName,
			GeneralName responderName, Extensions requestExtensions,
			AlgorithmIdentifier signatureAlg, ASN1ObjectIdentifier hashAlg,
			DERUTF8String requestorText) {
		this.query = query;
		this.requestorRef = requestorRef;
		this.requestNonce = requestNonce;
		this.requestorName = requestorName;
		this.responderName = responderName;
		this.requestExtensions = requestExtensions;
		this.signatureAlg = signatureAlg;
		this.hashAlg = hashAlg;
		this.requestorText = requestorText;
	}

	private CVRequest(ASN1Sequence seq) {
	}

	public static CVRequest getInstance(ASN1TaggedObject obj, boolean explicit) {
		return getInstance(ASN1Sequence.getInstance(obj, explicit));
	}

	public static CVRequest getInstance(Object obj) {
		if (obj instanceof CVRequest) {
			return (CVRequest) obj;
		} else if (obj != null) {
			return new CVRequest(ASN1Sequence.getInstance(obj));
		}
		return null;
	}

	@Override
	public ASN1Primitive toASN1Primitive() {
		ASN1EncodableVector v = new ASN1EncodableVector();
		v.add(cvRequestVersion);
		v.add(query);
		if (requestorRef != null) {
			v.add(new DERTaggedObject(false, 0, requestorRef));
		}
		if (requestNonce != null) {
			v.add(new DERTaggedObject(false, 1, requestNonce));
		}
		if (requestorName != null) {
			v.add(new DERTaggedObject(false, 2, requestorName));
		}
		if (responderName != null) {
			v.add(new DERTaggedObject(false, 3, responderName));
		}
		if (requestExtensions != null) {
			v.add(new DERTaggedObject(false, 4, requestExtensions));
		}
		if (signatureAlg != null) {
			v.add(new DERTaggedObject(false, 5, signatureAlg));
		}
		if (hashAlg != null) {
			v.add(new DERTaggedObject(false, 6, hashAlg));
		}
		if (requestorText != null) {
			v.add(new DERTaggedObject(false, 7, requestorText));
		}
		return new DERSequence(v);
	}

}
```


Overlapping Code:
```
ate final ASN1Integer cvRequestVersion = new ASN1Integer(1);
private Query query = null;
private GeneralNames requestorRef = null;
private ASN1OctetString requestNonce = null;
private GeneralName requestorName = null;
private GeneralName responderName = null;
private Extensions requestExtensions = null;
private AlgorithmIdentifier signatureAlg = null;
private ASN1ObjectIdentifier hashAlg = null;
private DERUTF8String requestorText = null;
public CVRequest(Query query, GeneralNames requestorRef,
ASN1OctetString requestNonce, GeneralName requestorName,
GeneralName responderName, Extensions requestExtensions,
AlgorithmIdentifier signatureAlg, ASN1ObjectIdentifier hashAlg,
DERUTF8String requestorText) {
this.query = query;
this.requestorRef = requestorRef;
this.requestNonce = requestNonce;
this.requestorName = requestorName;
this.responderName = responderName;
this.requestExtensions = requestExtensions;
this.signatureAlg = signatureAlg;
this.hashAlg = hashAlg;
this.requestorText = requestorText;
}
private CVRequest(ASN1Sequence seq) {
}
public static CVRequest getInstance(ASN1TaggedObject obj, boolean explicit) {
return getInstance(ASN1Sequence.getInstance(obj, explicit));
}
public static CVRequest getInstance(Object obj) {
if (obj instanceof CVRequest) {
return (CVRequest) obj;
} else if (obj != null) {
return new CVRequest(ASN1Sequence.getInstance(obj));
}
return null;
}
@Override
public ASN1Primitive toASN1Primitive() {
ASN1EncodableVector v = new ASN1EncodableVector();
v.add(cvRequestVersion);
v.add(query);
if (requestorRef != null) {
v.add(new DERTaggedObject(false, 0, requestorRef));
}
if (requestNonce != null) {
v.add(new DERTaggedObject(false, 1, requestNonce));
}
if (requestorName != null) {
v.add(new DERTaggedObject(false, 2, requestorName));
}
if (responderName != null) {
v.add(new DERTaggedObject(false, 3, responderName));
}
if (requestExtensions != null) {
v.add(new DERTaggedObject(false, 4, requestExtensions));
}
if (signatureAlg != null) {
v.add(new DERTaggedObject(false, 5, signatureAlg));
}
if (hashAlg != null) {
v.add(new DERTaggedObject(false, 6, hashAlg));
}
if (requestorText != null) {
v.add(new DERTaggedObject(false, 7, requestorText));
}
retur
```
<Overlap Ratio: 0.9678838539375275>

---

--- 52 --
Question ID: 41ace0bfd7cc7cd91f8953724ac5e8d85518d068
Original Code:
```
public class Stack<T> {
    Node<T> top;

    public Stack(){
        this.top = null;
    }

    // This function pushes an item into the stack.
    public void push(T value){
        Node<T> newNode = new Node<>(value);
        newNode.next = top;
        this.top = newNode;
    }

    // This function removes(pops) an item from the stack.
    public T pop(){
        if(top == null) throw new EmptyStackException();
        Node<T> temp = top;
        top = temp.next;
        return temp.value;
    }

    // This function returns the value that's at the top of the stack.
    public T peek(){
        if(top == null) throw new EmptyStackException();
        return top.value;
    }

    // This function returns true is the stack is empty, otherwise false.
    public boolean isEmpty(){
        return top == null ? true : false;
    }

    // This function returns the string of the stack
    public String toString(){
        // Declare variables
        Node<T> iterator = top;
        StringBuilder nodeString = new StringBuilder();
        nodeString.append("Stack: Top -> ");
        while(iterator != null){
            nodeString.append(iterator.toString());
            nodeString.append(" -> ");
            iterator = iterator.next;
        }
        // Finished the null / also works if top is null
        nodeString.append("null");
        return nodeString.toString();
    }
}
```


Overlapping Code:
```
ublic class Stack<T> {
Node<T> top;
public Stack(){
this.top = null;
}
// This function pushes an item into the stack.
public void push(T value){
Node<T> newNode = new Node<>(value);
newNode.next = top;
this.top = newNode;
}
// This function removes(pops) an item from the stack.
public T pop(){
if(top == null) throw new EmptyStackException();
Node<T> temp = top;
top = temp.next;
return temp.value;
}
// This function returns the value that's at the top of the stack.
public T peek(){
if(top == null) throw new EmptyStackException();
return top.value;
}
// This function returns true is the stack is empty, otherwise false.
public boolean isEmpty(){
return top == null ? true : false;
}
// This function returns the string of the stack
public String toString(){
// Declare variables
Node<T> iterator = top;
StringBuilder nodeString = new StringBuilder();
nodeString.append("Stack: Top -> ");
while(iterator != null){
nodeString.append(iterator.toString());
nodeString.append(" -> ");
iterator = iterator.next;
}
// Finished the null / also works if top is null
nodeString.append("null");
return nodeString.toString();
}
```
<Overlap Ratio: 0.9973309608540926>

---

--- 53 --
Question ID: 22ff4bad41f25fa56cf93ed3a5ed58682bdd5b26
Original Code:
```
@Ignore
public class BackPressureTest extends TestSuiteBase {

    private static final int TIMEOUT = 200000;
    private static final int SETUP_TIMEOUT = 60000;

    private CosmosDatabase createdDatabase;
    private CosmosContainer createdCollection;
    private List<CosmosItemProperties> createdDocuments;

    private CosmosClient client;

    public String getCollectionLink() {
        return TestUtils.getCollectionNameLink(createdDatabase.id(), createdCollection.id());
    }

    private static CosmosContainerProperties getSinglePartitionCollectionDefinition() {
        PartitionKeyDefinition partitionKeyDef = new PartitionKeyDefinition();
        ArrayList<String> paths = new ArrayList<String>();
        paths.add("/mypk");
        partitionKeyDef.paths(paths);

        CosmosContainerProperties collectionDefinition = new CosmosContainerProperties(UUID.randomUUID().toString(), partitionKeyDef);
        return collectionDefinition;
    }

    @Factory(dataProvider = "simpleClientBuildersWithDirectHttps")
    public BackPressureTest(CosmosClientBuilder clientBuilder) {
        super(clientBuilder);
    }

    @Test(groups = { "long" }, timeOut = 3 * TIMEOUT)
    public void readFeed() throws Exception {
        FeedOptions options = new FeedOptions();
        options.maxItemCount(1);
        options.enableCrossPartitionQuery(true);
        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.readAllItems(options);

        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);
        rxClient.httpRequests.clear();

        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);
        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);
        int sleepTimeInMillis = 10000; // 10 seconds

        int i = 0;
        // use a test subscriber and request for more result and sleep in between
        while (subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {
            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);
            sleepTimeInMillis /= 2;

            if (sleepTimeInMillis > 1000) {
                // validate that only one item is returned to subscriber in each iteration
                assertThat(subscriber.valueCount() - i).isEqualTo(1);
            }
            // validate that only one item is returned to subscriber in each iteration
            // validate that the difference between the number of requests to backend
            // and the number of returned results is always less than a fixed threshold
            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())
                .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);

            subscriber.requestMore(1);
            i++;
        }

        subscriber.assertNoErrors();
        subscriber.assertComplete();
        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());
    }

    @Test(groups = { "long" }, timeOut = 3 * TIMEOUT)
    public void query() throws Exception {
        FeedOptions options = new FeedOptions();
        options.maxItemCount(1);
        options.enableCrossPartitionQuery(true);
        Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.queryItems("SELECT * from r", options);

        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);
        rxClient.httpRequests.clear();

        TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);
        queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);
        int sleepTimeInMillis = 10000;

        int i = 0;
        // use a test subscriber and request for more result and sleep in between
        while(subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {
            TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);
            sleepTimeInMillis /= 2;

            if (sleepTimeInMillis > 1000) {
                // validate that only one item is returned to subscriber in each iteration
                assertThat(subscriber.valueCount() - i).isEqualTo(1);
            }
            // validate that the difference between the number of requests to backend
            // and the number of returned results is always less than a fixed threshold
            assertThat(rxClient.httpRequests.size() - subscriber.valueCount())
                    .isLessThanOrEqualTo(Queues.SMALL_BUFFER_SIZE);

            subscriber.requestMore(1);
            i++;
        }

        subscriber.assertNoErrors();
        subscriber.assertComplete();

        assertThat(subscriber.valueCount()).isEqualTo(createdDocuments.size());
    }

    @BeforeClass(groups = { "long" }, timeOut = 2 * SETUP_TIMEOUT)
    public void beforeClass() throws Exception {

        CosmosContainerRequestOptions options = new CosmosContainerRequestOptions();
        client = new ClientUnderTestBuilder(clientBuilder()).build();
        createdDatabase = getSharedCosmosDatabase(client);

        createdCollection = createCollection(createdDatabase, getSinglePartitionCollectionDefinition(), options, 1000);

        RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);

        // increase throughput to max for a single partition collection to avoid throttling
        // for bulk insert and later queries.
        Offer offer = rxClient.queryOffers(
                String.format("SELECT * FROM r WHERE r.offerResourceId = '%s'",
                        createdCollection.read().block().properties().resourceId())
                        , null).take(1).map(FeedResponse::results).single().block().get(0);
        offer.setThroughput(6000);
        offer = rxClient.replaceOffer(offer).single().block().getResource();
        assertThat(offer.getThroughput()).isEqualTo(6000);

        ArrayList<CosmosItemProperties> docDefList = new ArrayList<>();
        for(int i = 0; i < 1000; i++) {
            docDefList.add(getDocumentDefinition(i));
        }

        createdDocuments = bulkInsertBlocking(createdCollection, docDefList);

        waitIfNeededForReplicasToCatchUp(clientBuilder());
        warmUp();
    }

    private void warmUp() {
        // ensure collection is cached
        FeedOptions options = new FeedOptions();
        options.enableCrossPartitionQuery(true);
        createdCollection.queryItems("SELECT * from r", options).blockFirst();
    }

    // TODO: DANOBLE: Investigate DIRECT TCP performance issue
    // NOTE: This method requires multiple SHUTDOWN_TIMEOUT intervals
    // SEE: https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028https://msdata.visualstudio.com/CosmosDB/_workitems/edit/367028

    @AfterClass(groups = { "long" }, timeOut = 2 * SHUTDOWN_TIMEOUT, alwaysRun = true)
    public void afterClass() {
        safeDeleteCollection(createdCollection);
        safeClose(client);
    }

    private static CosmosItemProperties getDocumentDefinition(int cnt) {
        String uuid = UUID.randomUUID().toString();
        CosmosItemProperties doc = new CosmosItemProperties(String.format("{ "
                + "\"id\": \"%s\", "
                + "\"prop\" : %d, "
                + "\"mypk\": \"%s\", "
                + "\"sgmts\": [[6519456, 1471916863], [2498434, 1455671440]]"
                + "}"
                , uuid, cnt, uuid));
        return doc;
    }
}
```


Overlapping Code:
```

public class BackPressureTest extends TestSuiteBase {
private static final int TIMEOUT = 200000;
private static final int SETUP_TIMEOUT = 60000;
private CosmosDatabase createdDatabase;
private CosmosContainer createdCollection;
private List<CosmosItemProperties> createdDocuments;
private CosmosClient client;
public String getCollectionLink() {
return TestUtils.getCollectionNameLink(createdDatabase.id(), createdCollection.id());
}
private static CosmosContainerProperties getSinglePartitionCollectionDefinition() {
PartitionKeyDefinition partitionKeyDef = new PartitionKeyDefinition();
ArrayList<String> paths = new ArrayList<String>();
paths.add("/mypk");
partitionKeyDef.paths(paths);
CosmosContainerProperties collectionDefinition = new CosmosContainerProperties(UUID.randomUUID().toString(), partitionKeyDef);
return collectionDefinition;
}
@Factory(dataProvider = "simpleClientBuildersWithDirectHttps")
public BackPressureTest(CosmosClientBuilder clientBuilder) {
super(clientBuilder);
}
@Test(groups = { "long" }, timeOut = 3 * TIMEOUT)
public void readFeed() throws Exception {
FeedOptions options = new FeedOptions();
options.maxItemCount(1);
options.enableCrossPartitionQuery(true);
Flux<FeedResponse<CosmosItemProperties>> queryObservable = createdCollection.readAllItems(options);
RxDocumentClientUnderTest rxClient = (RxDocumentClientUnderTest)CosmosBridgeInternal.getAsyncDocumentClient(client);
rxClient.httpRequests.clear();
TestSubscriber<FeedResponse<CosmosItemProperties>> subscriber = new TestSubscriber<FeedResponse<CosmosItemProperties>>(1);
queryObservable.publishOn(Schedulers.elastic(), 1).subscribe(subscriber);
int sleepTimeInMillis = 10000; // 10 seconds
int i = 0;
// use a test subscriber and request for more result and sleep in between
while (subscriber.completions() == 0 && subscriber.getEvents().get(1).isEmpty()) {
TimeUnit.MILLISECONDS.sleep(sleepTimeInMillis);
sleepTimeInMillis /= 2;
if (sleepTimeInMillis > 1000) {
// validate that only one item is returned to subscriber in each iteration
assertThat(subscriber.valueCount() - i).isEqualTo(1);
}
// validate that only one item is returned to subscriber in each iteratio
```
<Overlap Ratio: 0.9963133640552996>

---

--- 54 --
Question ID: bbe64a90704d3e4dfa184cec1289a20e37e60ff0
Original Code:
```
public class ListAllCommands {

	public static void run() {
		ImageJ ij = new ImageJ();
		List<CommandInfo> commands = ij.command().getCommands();
		for(CommandInfo info : commands) {
			System.out.println(info.getClassName());
		}
	}

	public static void main(String...args) { run(); }
}
```


Overlapping Code:
```
{
public static void run() {
ImageJ ij = new ImageJ();
List<CommandInfo> commands = ij.command().getCommands();
for(CommandInfo info : commands) {
System.out.println(info.getClassName());
}
}
public static void main(String...args) { run();
```
<Overlap Ratio: 0.8786764705882353>

---

--- 55 --
Question ID: 72b8f431b1ecd9d9f89e91bea613ad9bdf2e9431
Original Code:
```
@RunWith(Parameterized.class)
public class CallTypeParserImplTest {
    private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();

    private final CallType callType;

    public CallTypeParserImplTest(CallType callType) {
        this.callType = callType;
    }

    @Parameterized.Parameters
    public static Collection<Object[]> data() {
        return Stream.of(ServerDeviceClientCallType.values(),
                ServerDeviceCallType.values(),
                ServerClientCallType.values(),
                DeviceServerCallType.values(),
                DeviceClientServerCallType.values(),
                ClientServerCallType.values())
                       .flatMap(Stream::of)
                       .map(v -> (CallType) v)
                       .map(callType -> new Object[]{callType})
                       .collect(Collectors.toList());
    }

    @Test
    public void shouldFindProperCallType() throws Exception {
        // when
        final Optional<CallType> parseCallTypeOptional = callTypeParser.parse(callType.getValue());

        // then
        assertThat(parseCallTypeOptional).contains(callType);
    }
}
```


Overlapping Code:
```
peParserImplTest {
private final CallTypeParserImpl callTypeParser = new CallTypeParserImpl();
private final CallType callType;
public CallTypeParserImplTest(CallType callType) {
this.callType = callType;
}
@Parameterized.Parameters
public static Collection<Object[]> data() {
return Stream.of(ServerDeviceClientCallType.values(),
ServerDeviceCallType.values(),
ServerClientCallType.values(),
DeviceServerCallType.values(),
DeviceClientServerCallType.values(),
ClientServerCallType.values())
.flatMap(Stream::of)
.map(v -> (CallType) v)
.map(callType -> new Object[]{callType})
.collect(Collectors.toList());
}
@Test
public void shouldFindProperCallType() throws Exception {
// when
final Optional<CallType> parseCallTypeOptional = callTypeParser.parse(callType.getValue());
// then
assertThat(parseC
```
<Overlap Ratio: 0.8998875140607424>

---

--- 56 --
Question ID: 4671840ff547f894fc86ca8d507b4562dedd301e
Original Code:
```
public class CheckAll extends ICmd {

    public CheckAll() {
        super("checkall", "[radius]", "列出所有在线玩家周围Entity数量");
    }

    @Override
    public boolean onCommand(CommandSender sender, String[] args) {
        int radius = AuditPlugin.getPlugin().getConfig()
                .getInt("entityCheck.radius", 100);
        try {
            radius = (args != null && args.length > 0)
                    ? Integer.parseInt(args[0]) : radius;
        } catch (NumberFormatException e) {
        }
        EntityCheck c = new EntityCheck();
        c.checkAll2(sender, radius);
        return true;
    }

    @Override
    public String permission() {
        return "xjcraft.checkall";
    }

}
```


Overlapping Code:
```
kAll() {
super("checkall", "[radius]", "列出所有在线玩家周围Entity数量");
}
@Override
public boolean onCommand(CommandSender sender, String[] args) {
int radius = AuditPlugin.getPlugin().getConfig()
.getInt("entityCheck.radius", 100);
try {
radius = (args != null && args.length > 0)
? Integer.parseInt(args[0]) : radius;
} catch (NumberFormatException e) {
}
EntityCheck c = new EntityCheck();
c.checkAll2(sender, radius);
return true;
}
@Override
public String permission() {
return "xjc
```
<Overlap Ratio: 0.8768382352941176>

---

--- 57 --
Question ID: b614cbabc7331a8bb6c755cb35fa42189bc13983
Original Code:
```
public class AlgXmlWriter extends AlgWriterImpl {

    private final XmlOutput xmlOutput;
    boolean generic = true;

    // TODO jvs 23-Dec-2005:  honor detail level.  The current inheritance structure makes this difficult without duplication; need to factor out the filtering of attributes before rendering.


    public AlgXmlWriter( PrintWriter pw, ExplainLevel detailLevel ) {
        super( pw, detailLevel, true );
        xmlOutput = new XmlOutput( pw );
        xmlOutput.setGlob( true );
        xmlOutput.setCompact( false );
    }


    @Override
    protected void explain_( AlgNode alg, List<Pair<String, Object>> values ) {
        if ( generic ) {
            explainGeneric( alg, values );
        } else {
            explainSpecific( alg, values );
        }
    }


    /**
     * Generates generic XML (sometimes called 'element-oriented XML'). Like this:
     *
     * <blockquote>
     * <code>
     * &lt;{@link AlgNode} id="1" type="Join"&gt;<br>
     * &nbsp;&nbsp;&lt;Property name="condition"&gt;EMP.DEPTNO =
     * DEPT.DEPTNO&lt;/Property&gt;<br>
     * &nbsp;&nbsp;&lt;Inputs&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id="2" type="Project"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property name="expr1"&gt;x +
     * y&lt;/Property&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property
     * name="expr2"&gt;45&lt;/Property&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id="3" type="TableAccess"&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property
     * name="table"&gt;SALES.EMP&lt;/Property&gt;<br>
     * &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>
     * &nbsp;&nbsp;&lt;/Inputs&gt;<br>
     * &lt;/AlgNode&gt;</code>
     * </blockquote>
     *
     * @param alg Relational expression
     * @param values List of term-value pairs
     */
    private void explainGeneric( AlgNode alg, List<Pair<String, Object>> values ) {
        String algType = alg.getAlgTypeName();
        xmlOutput.beginBeginTag( "AlgNode" );
        xmlOutput.attribute( "type", algType );

        xmlOutput.endBeginTag( "AlgNode" );

        final List<AlgNode> inputs = new ArrayList<>();
        for ( Pair<String, Object> pair : values ) {
            if ( pair.right instanceof AlgNode ) {
                inputs.add( (AlgNode) pair.right );
                continue;
            }
            if ( pair.right == null ) {
                continue;
            }
            xmlOutput.beginBeginTag( "Property" );
            xmlOutput.attribute( "name", pair.left );
            xmlOutput.endBeginTag( "Property" );
            xmlOutput.cdata( pair.right.toString() );
            xmlOutput.endTag( "Property" );
        }
        xmlOutput.beginTag( "Inputs", null );
        spacer.add( 2 );
        for ( AlgNode input : inputs ) {
            input.explain( this );
        }
        spacer.subtract( 2 );
        xmlOutput.endTag( "Inputs" );
        xmlOutput.endTag( "AlgNode" );
    }


    /**
     * Generates specific XML (sometimes called 'attribute-oriented XML'). Like this:
     *
     * <blockquote><pre>
     * &lt;Join condition="EMP.DEPTNO = DEPT.DEPTNO"&gt;
     *   &lt;Project expr1="x + y" expr2="42"&gt;
     *   &lt;TableAccess table="SALES.EMPS"&gt;
     * &lt;/Join&gt;
     * </pre></blockquote>
     *
     * @param alg Relational expression
     * @param values List of term-value pairs
     */
    private void explainSpecific( AlgNode alg, List<Pair<String, Object>> values ) {
        String tagName = alg.getAlgTypeName();
        xmlOutput.beginBeginTag( tagName );
        xmlOutput.attribute( "id", alg.getId() + "" );

        for ( Pair<String, Object> value : values ) {
            if ( value.right instanceof AlgNode ) {
                continue;
            }
            xmlOutput.attribute( value.left, value.right.toString() );
        }
        xmlOutput.endBeginTag( tagName );
        spacer.add( 2 );
        for ( AlgNode input : alg.getInputs() ) {
            input.explain( this );
        }
        spacer.subtract( 2 );
    }

}
```


Overlapping Code:
```
WriterImpl {
private final XmlOutput xmlOutput;
boolean generic = true;
// TODO jvs 23-Dec-2005: honor detail level. The current inheritance structure makes this difficult without duplication; need to factor out the filtering of attributes before rendering.
public AlgXmlWriter( PrintWriter pw, ExplainLevel detailLevel ) {
super( pw, detailLevel, true );
xmlOutput = new XmlOutput( pw );
xmlOutput.setGlob( true );
xmlOutput.setCompact( false );
}
@Override
protected void explain_( AlgNode alg, List<Pair<String, Object>> values ) {
if ( generic ) {
explainGeneric( alg, values );
} else {
explainSpecific( alg, values );
}
}
/**
* Generates generic XML (sometimes called 'element-oriented XML'). Like this:
*
* <blockquote>
* <code>
* &lt;{@link AlgNode} id="1" type="Join"&gt;<br>
* &nbsp;&nbsp;&lt;Property name="condition"&gt;EMP.DEPTNO =
* DEPT.DEPTNO&lt;/Property&gt;<br>
* &nbsp;&nbsp;&lt;Inputs&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id="2" type="Project"&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property name="expr1"&gt;x +
* y&lt;/Property&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property
* name="expr2"&gt;45&lt;/Property&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&lt;{@link AlgNode} id="3" type="TableAccess"&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Property
* name="table"&gt;SALES.EMP&lt;/Property&gt;<br>
* &nbsp;&nbsp;&nbsp;&nbsp;&lt;/AlgNode&gt;<br>
* &nbsp;&nbsp;&lt;/Inputs&gt;<br>
* &lt;/AlgNode&gt;</code>
* </blockquote>
*
* @param alg Relational expression
* @param values List of term-value pairs
*/
private void explainGeneric( AlgNode alg, List<Pair<String, Object>> values ) {
String algType = alg.getAlgTypeName();
xmlOutput.beginBeginTag( "AlgNode" );
xmlOutput.attribute( "type", algType );
xmlOutput.endBeginTag( "AlgNode" );
final List<AlgNode> inputs = new ArrayList<>();
for ( Pair<String, Object> pair : values ) {
if ( pair.right instanceof AlgNode ) {
inputs.add( (AlgNode) pair.right );
continue;
}
if ( pair.right == null ) {

```
<Overlap Ratio: 0.9771210676835081>

---

--- 58 --
Question ID: 90c0281ddbeca043629e879db96eb0b901182f6a
Original Code:
```
public class BitbucketCloudApi extends BitbucketApi {
    private final String baseUrl;

    protected BitbucketCloudApi(String apiUrl, StandardUsernamePasswordCredentials credentials) {
        super(apiUrl, credentials);
        this.baseUrl = this.apiUrl+"api/2.0/";
    }

    @Nonnull
    @Override
    public BbUser getUser() {
        try {
            InputStream inputStream = request.get(baseUrl+"user").getContent();
            return om.readValue(inputStream, BbCloudUser.class);
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbUser getUser(@Nonnull String userName) {
        try {
            InputStream inputStream = request.get(String.format("%s/%s",baseUrl+"users", userName)).getContent();
            return om.readValue(inputStream, BbCloudUser.class);
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbPage<BbOrg> getOrgs(int pageNumber, int pageSize) {
        try {
            /*
             * Bitbucket teams API work with three roles: admin, contributor, member
             *
             * We default to 'contributor' role, because we only want to only list teams that have at least one repo
             * where user has WRITE access.
             *
             * see: https://developer.atlassian.com/bitbucket/api/2/reference/resource/teams
             */
            if(pageNumber <= 0){
                pageNumber = 1;
            }

            if(pageSize <=0){
                pageSize = PagedResponse.DEFAULT_LIMIT;
            }
            InputStream inputStream = request.get(String.format("%s&page=%s&pagelen=%s",baseUrl+"teams/?role=contributor",
                    pageNumber,pageSize)).getContent();
            BbPage<BbOrg> page =  om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudTeam>>(){});
            if(pageNumber == 1){ //add user org as the first org on first page
                BbUser user = getUser();
                if(page instanceof BbCloudPage) {
                    List<BbOrg> teams = new ArrayList<>();
                    teams.add(new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar()));
                    int newSize = page.getSize() + 1;
                    int newPageLength = page.getLimit();
                    if (page.getSize() > page.getLimit()) {
                        newPageLength++;
                    }
                    teams.addAll(page.getValues());
                    return new BbCloudPage<>(newPageLength, pageNumber, newSize, ((BbCloudPage) page).getNext(), teams);
                }
            }
            return page;
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbOrg getOrg(@Nonnull String orgName) {
        try {
            BbUser user = getUser();
            // If user org, get user and return BbCloudTeam model
            if(orgName.equalsIgnoreCase(user.getSlug())){
                return new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar());
            }
            InputStream inputStream = request.get(String.format("%s/%s",baseUrl+"teams", orgName)).getContent();
            return om.readValue(inputStream, BbCloudTeam.class);
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbRepo getRepo(@Nonnull String orgId, String repoSlug) {
        try {
            InputStream inputStream = request.get(String.format("%s/%s",baseUrl+"repositories/"+orgId, repoSlug))
                    .getContent();
            return om.readValue(inputStream, BbCloudRepo.class);
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbPage<BbRepo> getRepos(@Nonnull String orgId, int pageNumber, int pageSize) {
        try {
            InputStream inputStream = request.get(String.format("%s?page=%s&limit=%s",baseUrl+"repositories/"+orgId,
                    pageNumber, pageSize)).getContent();
            return om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudRepo>>(){});
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public String getContent(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path, @Nonnull String commitId) {
        try {
            InputStream inputStream = request.get(String.format("%s/%s/%s/src/%s/%s",baseUrl+"repositories",orgId,
                    repoSlug, commitId, path)).getContent();
            return IOUtils.toString(inputStream);
        } catch (IOException e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbSaveContentResponse saveContent(@Nonnull String orgId,
                                             @Nonnull String repoSlug,
                                             @Nonnull String path,
                                             @Nonnull String content,
                                             @Nonnull String commitMessage,
                                             @Nullable String branch,
                                             @Nullable String sourceBranch,
                                             @Nullable String commitId) {
        MultipartEntityBuilder builder = MultipartEntityBuilder.create()
                    .addTextBody(path, content)
                .addTextBody("message", commitMessage);

        if(isNotBlank(branch)){
            builder.addTextBody("branch", branch);
        }

        if(isNotBlank(commitId)){
            builder.addTextBody("parents", commitId);
        }
        HttpEntity entity = builder.build();
        HttpResponse response = request.post(String.format("%s/%s/%s/src",baseUrl+"repositories",orgId,repoSlug), entity);
        int status = response.getStatus();
        if(status == 201){
            String location = response.getHeader("Location");
            if(location == null){
                throw new ServiceException.UnexpectedErrorException("Location header is missing on save content response");
            }
            String cid = location.substring(location.lastIndexOf("/") + 1);
            return new BbCloudSaveContentResponse(cid);
        }else{
            throw new ServiceException.UnexpectedErrorException("Failed to save file: "+path+" server returned status: "+status);
        }
    }

    @Override
    public boolean fileExists(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String path,  @Nonnull String branch) {
        throw new NotImplementedException("Not implemented");
    }

    @Override
    public BbBranch getBranch(@Nonnull String orgId, @Nonnull String repoSlug, @Nonnull String branch) {
        try {
            HttpResponse response = request.get(String.format("%s/%s/refs/branches/%s?fields=target.hash,target.repository.mainbranch.name,target.repository.*,target.repository.owner.*,target.repository.owner.links.avatar.href,name",
                    baseUrl+"repositories/"+orgId,
                    repoSlug,
                    branch));
            if(response.getStatus() == 404){
                return null;
            }
            return om.readValue(response.getContent(), BbCloudBranch.class);
        } catch (Exception e) {
            throw handleException(e);
        }
    }

    @Nonnull
    @Override
    public BbBranch createBranch(@Nonnull String orgId, @Nonnull String repoSlug, Map<String, String> payload) {
        throw new NotImplementedException("Not implemented");
    }

    @Override
    public BbBranch getDefaultBranch(@Nonnull String orgId, @Nonnull String repoSlug) {
        try {
            InputStream inputStream = request.get(String.format("%s/%s/?fields=mainbranch.*,mainbranch.target.*,mainbranch.target.repository.*,mainbranch.target.repository.mainbranch.name,mainbranch.target.repository.owner.*,mainbranch.target.repository.owner.links.avatar.*",
                    baseUrl+"repositories/"+orgId,
                    repoSlug))
                    .getContent();
            Map<String, BbCloudBranch> resp = om.readValue(inputStream, new TypeReference<Map<String, BbCloudBranch>>() {});
            return resp.get("mainbranch");
        } catch (IOException e) {
            throw handleException(e);
        }

    }

    @Override
    public boolean isEmptyRepo(@Nonnull String orgId, @Nonnull String repoSlug) {
        throw new NotImplementedException("Not implemented");
    }

    @Extension
    public static class BitbucketCloudApiFactory extends BitbucketApiFactory {
        @Override
        public boolean handles(@Nonnull String scmId) {
            return scmId.equals(BitbucketCloudScm.ID);
        }

        @Nonnull
        @Override
        public BitbucketApi create(@Nonnull String apiUrl, @Nonnull StandardUsernamePasswordCredentials credentials) {
            return new BitbucketCloudApi(apiUrl, credentials);
        }
    }

}
```


Overlapping Code:
```
lass BitbucketCloudApi extends BitbucketApi {
private final String baseUrl;
protected BitbucketCloudApi(String apiUrl, StandardUsernamePasswordCredentials credentials) {
super(apiUrl, credentials);
this.baseUrl = this.apiUrl+"api/2.0/";
}
@Nonnull
@Override
public BbUser getUser() {
try {
InputStream inputStream = request.get(baseUrl+"user").getContent();
return om.readValue(inputStream, BbCloudUser.class);
} catch (IOException e) {
throw handleException(e);
}
}
@Nonnull
@Override
public BbUser getUser(@Nonnull String userName) {
try {
InputStream inputStream = request.get(String.format("%s/%s",baseUrl+"users", userName)).getContent();
return om.readValue(inputStream, BbCloudUser.class);
} catch (IOException e) {
throw handleException(e);
}
}
@Nonnull
@Override
public BbPage<BbOrg> getOrgs(int pageNumber, int pageSize) {
try {
/*
* Bitbucket teams API work with three roles: admin, contributor, member
*
* We default to 'contributor' role, because we only want to only list teams that have at least one repo
* where user has WRITE access.
*
* see: https://developer.atlassian.com/bitbucket/api/2/reference/resource/teams
*/
if(pageNumber <= 0){
pageNumber = 1;
}
if(pageSize <=0){
pageSize = PagedResponse.DEFAULT_LIMIT;
}
InputStream inputStream = request.get(String.format("%s&page=%s&pagelen=%s",baseUrl+"teams/?role=contributor",
pageNumber,pageSize)).getContent();
BbPage<BbOrg> page = om.readValue(inputStream, new TypeReference<BbCloudPage<BbCloudTeam>>(){});
if(pageNumber == 1){ //add user org as the first org on first page
BbUser user = getUser();
if(page instanceof BbCloudPage) {
List<BbOrg> teams = new ArrayList<>();
teams.add(new BbCloudTeam(user.getSlug(), user.getDisplayName(), user.getAvatar()));
int newSize = page.getSize() + 1;
int newPageLength = page.getLimit();
if (page.getSize() > page.getLimit()) {
newPageLen
```
<Overlap Ratio: 0.9914255091103966>

---

--- 59 --
Question ID: b41b8f0c8e962f668e692cf871a41b166bc3603c
Original Code:
```
@Entity
@Table(name = "direct_asset")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
@Document(indexName = "directasset")
public class DirectAsset implements Serializable {

    private static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
    @SequenceGenerator(name = "sequenceGenerator")
    private Long id;

    @OneToOne
    @JoinColumn(unique = true)
    private MyAsset myAsset;


    @OneToMany(mappedBy = "directAsset", fetch = FetchType.EAGER,
        cascade = {CascadeType.ALL, CascadeType.PERSIST, CascadeType.MERGE}, orphanRemoval = true)
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    private Set<IndirectAsset> effects = new HashSet<>();

    // jhipster-needle-entity-add-field - JHipster will add fields here, do not remove
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public MyAsset getMyAsset() {
        return myAsset;
    }

    public DirectAsset myAsset(MyAsset myAsset) {
        this.myAsset = myAsset;
        return this;
    }

    public void setMyAsset(MyAsset myAsset) {
        this.myAsset = myAsset;
    }

    public Set<IndirectAsset> getEffects() {
        return effects;
    }

    public DirectAsset effects(Set<IndirectAsset> indirectAssets) {
        this.effects = indirectAssets;
        return this;
    }

    public DirectAsset addEffects(IndirectAsset indirectAsset) {
        this.effects.add(indirectAsset);
        indirectAsset.setDirectAsset(this);
        return this;
    }

    public DirectAsset removeEffects(IndirectAsset indirectAsset) {
        this.effects.remove(indirectAsset);
        indirectAsset.setDirectAsset(null);
        return this;
    }

    public void setEffects(Set<IndirectAsset> indirectAssets) {
        this.effects = indirectAssets;
    }
    // jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here, do not remove

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DirectAsset directAsset = (DirectAsset) o;
        if (directAsset.getId() == null || getId() == null) {
            return false;
        }
        return Objects.equals(getId(), directAsset.getId());
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(getId());
    }

    @Override
    public String toString() {
        return "DirectAsset{" +
            "id=" + getId() +
            "}";
    }
}
```


Overlapping Code:
```
@Table(name = "direct_asset")
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
@Document(indexName = "directasset")
public class DirectAsset implements Serializable {
private static final long serialVersionUID = 1L;
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
@SequenceGenerator(name = "sequenceGenerator")
private Long id;
@OneToOne
@JoinColumn(unique = true)
private MyAsset myAsset;
@OneToMany(mappedBy = "directAsset", fetch = FetchType.EAGER,
cascade = {CascadeType.ALL, CascadeType.PERSIST, CascadeType.MERGE}, orphanRemoval = true)
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
private Set<IndirectAsset> effects = new HashSet<>();
// jhipster-needle-entity-add-field - JHipster will add fields here, do not remove
public Long getId() {
return id;
}
public void setId(Long id) {
this.id = id;
}
public MyAsset getMyAsset() {
return myAsset;
}
public DirectAsset myAsset(MyAsset myAsset) {
this.myAsset = myAsset;
return this;
}
public void setMyAsset(MyAsset myAsset) {
this.myAsset = myAsset;
}
public Set<IndirectAsset> getEffects() {
return effects;
}
public DirectAsset effects(Set<IndirectAsset> indirectAssets) {
this.effects = indirectAssets;
return this;
}
public DirectAsset addEffects(IndirectAsset indirectAsset) {
this.effects.add(indirectAsset);
indirectAsset.setDirectAsset(this);
return this;
}
public DirectAsset removeEffects(IndirectAsset indirectAsset) {
this.effects.remove(indirectAsset);
indirectAsset.setDirectAsset(null);
return this;
}
public void setEffects(Set<IndirectAsset> indirectAssets) {
this.effects = indirectAssets;
}
// jhipster-needle-entity-add-getters-setters - JHipster will add getters and setters here, do not remove
@Override
public boolean equals(Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
DirectAsset directAsset = (DirectAsset) o;
if (directAsset.getId() == null || getId() == null) {
return false;
}
return Objects.equals(getId(), directAsset.getId());
}
@O
```
<Overlap Ratio: 0.9813307802776448>

---

--- 60 --
Question ID: 917400709796e064927d1b178ebdc081bcd4b3c3
Original Code:
```
@Controller
@RequestMapping("/mps/route")
public class ZuulRouteController extends AbstractController<SysZuulRouteService,SysZuulRoute> {

    @Override
    protected String getTemplatePath() {
        return "ftl/mps/route/";
    }

    @Override
    protected QueryWrapper<SysZuulRoute> getSearchQW(String search, Model model) {
        QueryWrapper<SysZuulRoute> qw = new QueryWrapper<SysZuulRoute>();
        if(StringUtils.isNotBlank(search)){
            qw.like("service_id",search);
            model.addAttribute("service_id",search);
        }
        return qw;
    }
}
```


Overlapping Code:
```
@RequestMapping("/mps/route")
public class ZuulRouteController extends AbstractController<SysZuulRouteService,SysZuulRoute> {
@Override
protected String getTemplatePath() {
return "ftl/mps/route/";
}
@Override
protected QueryWrapper<SysZuulRoute> getSearchQW(String search, Model model) {
QueryWrapper<SysZuulRoute> qw = new QueryWrapper<SysZuulRoute>();
if(StringUtils.isNotBlank(search)){
qw.like("service_id",search);
model.addAttribute("service_id",search);
}
ret
```
<Overlap Ratio: 0.9530612244897959>

---

--- 61 --
Question ID: 6c8ed5d664bd30f98777278940562ce4677360c8
Original Code:
```
public class StringWebResponse extends WebResponse {

    private boolean fromJavascript_;

    /**
     * Creates an instance associated with the specified originating URL.
     * @param content the content to return
     * @param originatingURL the URL that this should be associated with
     */
    public StringWebResponse(final String content, final URL originatingURL) {
        // use UTF-8 here to be sure, all chars in the string are part of the charset
        this(content, UTF_8, originatingURL);
    }

    /**
     * Creates an instance associated with the specified originating URL.
     * @param content the content to return
     * @param charset the charset used to convert the content
     * @param originatingURL the URL that this should be associated with
     */
    public StringWebResponse(final String content, final Charset charset, final URL originatingURL) {
        super(getWebResponseData(content, charset), buildWebRequest(originatingURL, charset), 0);
    }

    /**
     * Helper method for constructors. Converts the specified string into {@link WebResponseData}
     * with other defaults specified.
     *
     * @param contentString the string to be converted to a <tt>WebResponseData</tt>
     * @return a simple <tt>WebResponseData</tt> with defaults specified
     */
    private static WebResponseData getWebResponseData(final String contentString, final Charset charset) {
        final byte[] content = TextUtils.stringToByteArray(contentString, charset);
        final List<NameValuePair> compiledHeaders = new ArrayList<>();
        compiledHeaders.add(new NameValuePair(HttpHeader.CONTENT_TYPE, "text/html; charset=" + charset));
        return new WebResponseData(content, HttpStatus.SC_OK, "OK", compiledHeaders);
    }

    private static WebRequest buildWebRequest(final URL originatingURL, final Charset charset) {
        final WebRequest webRequest = new WebRequest(originatingURL, HttpMethod.GET);
        webRequest.setCharset(charset);
        return webRequest;
    }

    /**
     * Returns the fromJavascript property. This is true, if the response was created
     * from javascript (usually document.write).
     * @return the from fromJavascript_
     */
    public boolean isFromJavascript() {
        return fromJavascript_;
    }

    /**
     * Sets the fromJavascript_ property. Set this to true, if the response was created
     * from javascript (usually document.write).
     * @param fromJavascript the new fromJavascript
     */
    public void setFromJavascript(final boolean fromJavascript) {
        fromJavascript_ = fromJavascript;
    }
}
```


Overlapping Code:
```
Response extends WebResponse {
private boolean fromJavascript_;
/**
* Creates an instance associated with the specified originating URL.
* @param content the content to return
* @param originatingURL the URL that this should be associated with
*/
public StringWebResponse(final String content, final URL originatingURL) {
// use UTF-8 here to be sure, all chars in the string are part of the charset
this(content, UTF_8, originatingURL);
}
/**
* Creates an instance associated with the specified originating URL.
* @param content the content to return
* @param charset the charset used to convert the content
* @param originatingURL the URL that this should be associated with
*/
public StringWebResponse(final String content, final Charset charset, final URL originatingURL) {
super(getWebResponseData(content, charset), buildWebRequest(originatingURL, charset), 0);
}
/**
* Helper method for constructors. Converts the specified string into {@link WebResponseData}
* with other defaults specified.
*
* @param contentString the string to be converted to a <tt>WebResponseData</tt>
* @return a simple <tt>WebResponseData</tt> with defaults specified
*/
private static WebResponseData getWebResponseData(final String contentString, final Charset charset) {
final byte[] content = TextUtils.stringToByteArray(contentString, charset);
final List<NameValuePair> compiledHeaders = new ArrayList<>();
compiledHeaders.add(new NameValuePair(HttpHeader.CONTENT_TYPE, "text/html; charset=" + charset));
return new WebResponseData(content, HttpStatus.SC_OK, "OK", compiledHeaders);
}
private static WebRequest buildWebRequest(final URL originatingURL, final Charset charset) {
final WebRequest webRequest = new WebRequest(originatingURL, HttpMethod.GET);
webRequest.setCharset(charset);
return webRequest;
}
/**
* Returns the fromJavascript property. This is true, if the response was created
* from javascript (usually document.write).
* @return the from fromJavascript_
*/
public boolean isFromJavascript() {
return fromJavascript_;
}
/**
* Sets the fromJavascript_ property. Set this to true, if the response was created
* from javascript (usually document.write).
* @param fromJavascript the new fromJavascr
```
<Overlap Ratio: 0.9887640449438202>

---

--- 62 --
Question ID: a7c0c7c4d501e7bc23b6dc86e363abc43f63ad41
Original Code:
```
public class Vector2D implements Serializable, Cloneable {

	private static final long serialVersionUID = -8279176595720850402L;
	protected double length;
	protected double direction;
	protected Point2D.Float from;
	protected Point2D.Float to;

	/**
	 * Creates a vector with the given length and direction.
	 * 
	 * @param length
	 *            magnitude of vector
	 * @param direction
	 *            direction of vector in radians.
	 * 
	 */
	public Vector2D(double length, double direction) {
		super();
		this.length = length;
		this.direction = radianNorm(direction);
		this.from = new Point2D.Float(0, 0);
		setDirection(this.direction);
	}

	/**
	 * Creates a vector using two points.
	 */
	public Vector2D(Point2D.Float from, Point2D.Float to) {
		this.from = from;
		this.to = to;
		length = from.distance(to);
		setDirection();
	}

	/**
	 * Limits the radian value between 0 and 2 PI.
	 * 
	 * @param radian
	 * @return
	 */
	protected double radianNorm(double radian) {
		double r = radian / (Math.PI * 2);
		if (r < 1)
			return radian;
		r = Math.floor(r);
		return radian - r * (Math.PI * 2);
	}

	/**
	 * Returns the magnitude of the vector.
	 */
	public double getLength() {
		return length;
	}

	/**
	 * Returns the direction of the vector in radians.
	 */
	public double getRadian() {
		return direction;
	}

	/**
	 * Returns the direction of the vector in degrees.
	 */
	public double getDegree() {
		return Math.toDegrees(direction);
	}

	/**
	 * Sets starting point.
	 * 
	 */
	public void setP1(float x, float y) {
		setP1(new Point2D.Float(x, y));
	}

	/**
	 * Sets starting point.
	 * 
	 */
	public void setP1(Point2D.Float p1) {
		this.from = p1;
		length = from.distance(to);
		setDirection();
	}

	/**
	 * Sets end point.
	 * 
	 */
	public void setP2(float x, float y) {
		setP2(new Point2D.Float(x, y));
	}

	/**
	 * Sets end point.
	 * 
	 */
	public void setP2(Point2D.Float p2) {
		this.to = p2;
		length = from.distance(to);
		setDirection();
	}

	/**
	 * Returns starting point.
	 */
	public Point2D.Float getP1() {
		return from;
	}

	/**
	 * Returns end point.
	 */
	public Point2D.Float getP2() {
		return to;
	}

	/**
	 * Shifts a copy of the vector to the origo (0,0).
	 */
	public Vector2D getOrigo() {
		Point2D.Float p2 = new Point2D.Float(to.x - from.x, to.y - from.y);
		return new Vector2D(new Point2D.Float(0, 0), p2);
	}

	/**
	 * Shifts this vector by the given point.
	 * 
	 * @param p
	 */
	public void shiftWith(Point2D.Float p) {
		to.x += p.x;
		to.y += p.y;
		from.x += p.x;
		from.y += p.y;
	}

	/**
	 * Calculates the direction from p1 and p2.
	 */
	protected void setDirection() {
		float x = to.x - from.x;
		float y = to.y - from.y;
		direction = Math.atan2(x, y);
		if (direction < 0)
			direction = Math.abs(direction) + Math.PI / 2;
		else if (direction < Math.PI / 2) {
			direction = Math.abs(direction - Math.PI / 2);
		} else
			direction = 2.5 * Math.PI - direction;
	}

	/**
	 * Sets the new direction in radians.
	 */
	public void setDirection(double rad) {
		this.direction = radianNorm(rad);
		double y = Math.sin(direction) * length;
		double x = Math.cos(direction) * length;
		to = new Point2D.Float((float) x, (float) y);
		// System.out.println((to));
		// System.out.println(new Vector2D(from, to));
	}

	@Override
	public String toString() {
		return "length: " + length + "; deg: " + getDegree();
	}

	/**
	 * Multiplies the vector.
	 */
	public void multiply(double scale) {
		Vector2D org = getOrigo();
		Point2D.Float p2 = org.getP2();
		p2.x *= scale;
		p2.y *= scale;
		org.setP2(p2);
		org.shiftWith(getP1());
		setP1(org.getP1());
		setP2(org.getP2());
	}

	@Override
	public Vector2D clone() {
		Vector2D v;
		try {
			v = (Vector2D) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
			return null;
		}
		v.from = (Float) from.clone();
		v.to = (Float) to.clone();
		return v;
	}
}
```


Overlapping Code:
```
s Vector2D implements Serializable, Cloneable {
private static final long serialVersionUID = -8279176595720850402L;
protected double length;
protected double direction;
protected Point2D.Float from;
protected Point2D.Float to;
/**
* Creates a vector with the given length and direction.
* 
* @param length
* magnitude of vector
* @param direction
* direction of vector in radians.
* 
*/
public Vector2D(double length, double direction) {
super();
this.length = length;
this.direction = radianNorm(direction);
this.from = new Point2D.Float(0, 0);
setDirection(this.direction);
}
/**
* Creates a vector using two points.
*/
public Vector2D(Point2D.Float from, Point2D.Float to) {
this.from = from;
this.to = to;
length = from.distance(to);
setDirection();
}
/**
* Limits the radian value between 0 and 2 PI.
* 
* @param radian
* @return
*/
protected double radianNorm(double radian) {
double r = radian / (Math.PI * 2);
if (r < 1)
return radian;
r = Math.floor(r);
return radian - r * (Math.PI * 2);
}
/**
* Returns the magnitude of the vector.
*/
public double getLength() {
return length;
}
/**
* Returns the direction of the vector in radians.
*/
public double getRadian() {
return direction;
}
/**
* Returns the direction of the vector in degrees.
*/
public double getDegree() {
return Math.toDegrees(direction);
}
/**
* Sets starting point.
* 
*/
public void setP1(float x, float y) {
setP1(new Point2D.Float(x, y));
}
/**
* Sets starting point.
* 
*/
public void setP1(Point2D.Float p1) {
this.from = p1;
length = from.distance(to);
setDirection();
}
/**
* Sets end point.
* 
*/
public void setP2(float x, float y) {
setP2(new Point2D.Float(x, y));
}
/**
* Sets end point.
* 
*/
public void setP2(Point2D.Float p2) {
this.to = p2;
length = from.distance(to);
setDirection();
}
/**
* Returns starting point.
*/
public Point2D.Float getP1() {
return from;
}
/**
* Returns end point.
*/
public Point2D.Float getP2() {
return to;
}
/**
* Shifts a copy of the vector to the origo (0,0).
*/
public Vector2D getOrigo() {
Point2D.Float p2 = new Point2D.Float(to.x - from.x, to.y - from.y);
return new Vector2D(new Point2D.Float(0, 0), p2);
}
/**
* Shifts this vector by the given point.
* 
* @param p
*/
public void shiftWith(Poin
```
<Overlap Ratio: 0.9819144243493604>

---

--- 63 --
Question ID: bc5e6a40275f6b5472c504c25859529c458d7b3d
Original Code:
```
@Service
public class FeedbackServiceImpl implements FeedbackService {


   private static final Logger LOGGER = LoggerFactory.getLogger(FeedbackServiceImpl.class);

   @Autowired
   private GameService gameService;

   @Override
   public ResponseObject getFeedbackFor(final HttpSession session, final PinPlacement requestPlacement) {
      LOGGER.debug("--> getFeedbackFor");
      final ResponseObject responseObject = new ResponseObject();

      try {
         final Game currentGame = gameService.getCurrentGameOf(session);
         final PinPlacement solution = currentGame.getPinSolution();
         final Map<Integer, String> solutionMap = solution.getColors();
         final Map<Integer, String> placementMap = requestPlacement.getColors();
         List<Object> solutionValues = new ArrayList<>(solutionMap.values());
         List<Object> placementValues = new ArrayList<>(placementMap.values());

         List<Object> correctPositions = calculateCorrectPositions(solutionValues, placementValues);

         for (Object position : correctPositions) {
            solutionValues.remove(position);
            placementValues.remove(position);

         }

         int correctColors = calculateCorrectColors(solutionValues, placementValues);
         responseObject.setCorrectColors(correctColors);
         responseObject.setCorrectPositions(correctPositions.size());

      } catch (GameNotFoundException e) {
         responseObject.setCorrectPositions(0);
         responseObject.setCorrectColors(0);
      }


      LOGGER.debug("<-- getFeedbackFor");
      return responseObject;


   }

   private List<Object> calculateCorrectPositions(final List<Object> solutionEntries, final List<Object> placementEntries) {

      List<Object> correctPositionValues = new ArrayList<>();
      for (int i = 0; i < solutionEntries.size(); i++) {
         if (placementEntries.get(i).equals(solutionEntries.get(i))) {
            correctPositionValues.add(placementEntries.get(i));
         }
      }
      return correctPositionValues;
   }

   private int calculateCorrectColors(final List<Object> solutionEntries, final List<Object> placementEntries) {

      int correctColors = 0;
      List<Object> correctColorsValues = new ArrayList<>();

      for (int i = 0; i < solutionEntries.size(); i++) {
         Object color = solutionEntries.get(i);
         if (!correctColorsValues.contains(color)) {
            for (int a = 0; a < solutionEntries.size(); a++) {
               if (color.equals(placementEntries.get(a))) {
                  correctColors++;
                  correctColorsValues.add(color);
                  break;
               }
            }
         }
      }

      return correctColors;
   }


}
```


Overlapping Code:
```
@Service
public class FeedbackServiceImpl implements FeedbackService {
private static final Logger LOGGER = LoggerFactory.getLogger(FeedbackServiceImpl.class);
@Autowired
private GameService gameService;
@Override
public ResponseObject getFeedbackFor(final HttpSession session, final PinPlacement requestPlacement) {
LOGGER.debug("--> getFeedbackFor");
final ResponseObject responseObject = new ResponseObject();
try {
final Game currentGame = gameService.getCurrentGameOf(session);
final PinPlacement solution = currentGame.getPinSolution();
final Map<Integer, String> solutionMap = solution.getColors();
final Map<Integer, String> placementMap = requestPlacement.getColors();
List<Object> solutionValues = new ArrayList<>(solutionMap.values());
List<Object> placementValues = new ArrayList<>(placementMap.values());
List<Object> correctPositions = calculateCorrectPositions(solutionValues, placementValues);
for (Object position : correctPositions) {
solutionValues.remove(position);
placementValues.remove(position);
}
int correctColors = calculateCorrectColors(solutionValues, placementValues);
responseObject.setCorrectColors(correctColors);
responseObject.setCorrectPositions(correctPositions.size());
} catch (GameNotFoundException e) {
responseObject.setCorrectPositions(0);
responseObject.setCorrectColors(0);
}
LOGGER.debug("<-- getFeedbackFor");
return responseObject;
}
private List<Object> calculateCorrectPositions(final List<Object> solutionEntries, final List<Object> placementEntries) {
List<Object> correctPositionValues = new ArrayList<>();
for (int i = 0; i < solutionEntries.size(); i++) {
if (placementEntries.get(i).equals(solutionEntries.get(i))) {
correctPositionValues.add(placementEntries.get(i));
}
}
return correctPositionValues;
}
private int calculateCorrectColors(final List<Object> solutionEntries, final List<Object> placementEntries) {
int correctColors = 0;
List<Object> correctColorsValues = new ArrayList<>();
for (int i = 0; i < solutionEntries.size(); i++) {
Object color = solutionEntries.get(i);
if (!correctColorsValues.contains(color)) {
for (int a = 0; a < solutionEntries.size(); a++) {
i
```
<Overlap Ratio: 0.9953358208955224>

---

--- 64 --
Question ID: 658520e56f702f781b2023d11bfa82e9586eaa52
Original Code:
```
public class main {
    public static void main(String[] args){
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1.toString());
        System.out.println(singleton2.toString());
    }
}
```


Overlapping Code:
```
public class main {
public static void main(String[] args){
Singleton singleton1 = Singleton.getInstance();
Singleton singleton2 = Singleton.getInstance();
System.out.println(singleton1.toString()
```
<Overlap Ratio: 0.8>

---

--- 65 --
Question ID: de35dba180a26948b2d5f6beab387b8e3c2b8f95
Original Code:
```
public class GenericDeserializer extends JsonDeserializer<Object> {
    @Override
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
        JsonNode node = p.getCodec().readTree(p);
        String className = node.get("@class").asText();
        Class<?> c;
        try {
            c = Class.forName(className);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        JsonNode valueNode = node.get("value");
        Object o = new ObjectMapper().treeToValue(valueNode, c);
        return o;
    }
}
```


Overlapping Code:
```
ic class GenericDeserializer extends JsonDeserializer<Object> {
@Override
public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
JsonNode node = p.getCodec().readTree(p);
String className = node.get("@class").asText();
Class<?> c;
try {
c = Class.forName(className);
} catch (Exception e) {
throw new RuntimeException(e);
}
JsonNode valueNode = node.get("value");
Object o = new ObjectMapper().treeToValue(valueNode
```
<Overlap Ratio: 0.9513742071881607>

---

--- 66 --
Question ID: 329f1320c1944012db12dfb4d9d7eb4d2e85b21a
Original Code:
```
public class MockNonVisibleComponent extends MockComponent {

  private final Icon iconWidget;

  /**
   * Creates a new instance of a non-visible component whose icon is
   * loaded dynamically (not part of the icon image bundle)
   */
  public MockNonVisibleComponent(SimpleEditor editor, String type, Image iconImage) {
    super(editor, type, iconImage);
    iconWidget = new Icon(iconImage);

    initComponent(iconWidget);
  }

  @Override
  public void initComponent(Widget widget) {
    super.initComponent(widget);
  }

  /**
   * {@inheritDoc}
   *
   * This is always {@code false} for subclasses of this class.
   */
  @Override
  public final boolean isVisibleComponent() {
    return false;
  }

  @Override
  public final int getPreferredHeight() {
    return 0;
  }

  @Override
  public final int getPreferredWidth() {
    return 0;
  }

  @Override
  protected final void onSelectedChange(boolean selected) {
    super.onSelectedChange(selected);
    if (selected) {
      iconWidget.select();
    } else {
      iconWidget.deselect();
    }
  }

  // PropertyChangeListener implementation

  @Override
  public void onPropertyChange(String propertyName, String newValue) {
    super.onPropertyChange(propertyName, newValue);

    // No visual changes after property changes (other than icon name).
    if (propertyName.equals(PROPERTY_NAME_NAME)) {
      iconWidget.setCaption(newValue);
    }
  }
}
```


Overlapping Code:
```
onent extends MockComponent {
private final Icon iconWidget;
/**
* Creates a new instance of a non-visible component whose icon is
* loaded dynamically (not part of the icon image bundle)
*/
public MockNonVisibleComponent(SimpleEditor editor, String type, Image iconImage) {
super(editor, type, iconImage);
iconWidget = new Icon(iconImage);
initComponent(iconWidget);
}
@Override
public void initComponent(Widget widget) {
super.initComponent(widget);
}
/**
* {@inheritDoc}
*
* This is always {@code false} for subclasses of this class.
*/
@Override
public final boolean isVisibleComponent() {
return false;
}
@Override
public final int getPreferredHeight() {
return 0;
}
@Override
public final int getPreferredWidth() {
return 0;
}
@Override
protected final void onSelectedChange(boolean selected) {
super.onSelectedChange(selected);
if (selected) {
iconWidget.select();
} else {
iconWidget.deselect();
}
}
// PropertyChangeListener implementation
@Override
public void onPropertyChange(String propertyName, String newValue) {
super.onPropertyChange(propertyName, newValue);
// No visual changes after property changes (other than icon name).
if (propertyName.equals(PROPERTY_NAME_NAME)) {
iconWidge
```
<Overlap Ratio: 0.9523809523809523>

---

--- 67 --
Question ID: 143228d04d41b9fd94f764e27fafdfb01c5035ef
Original Code:
```
public final class ItemRegistry {

	private static final Map<Item, ItemProfile> registry = new IdentityHashMap<Item, ItemProfile>();

	static {
		for (final Item o : GameData.getItemRegistry().typeSafeIterable())
			createProfile(o);
	}

	private static ItemProfile createProfile(final Item item) {
		final ItemProfile profile;
		if (item.getHasSubtypes())
			profile = new MultiItemProfile(item);
		else if (item.isDamageable())
			profile = new DamagableItemProfile(item);
		else
			profile = new SingleItemProfile(item);
		registry.put(item, profile);
		return profile;
	}
	
	private static ItemProfile getProfile(final ItemStack stack) {
		final Item item = stack.getItem();
		ItemProfile profile = registry.get(item);
		if (profile == null) {
			ModLog.warn("Item registration is missing: " + ItemStackHelper.resolveInternalName(stack));
			if(GameData.getItemRegistry().getId(item) == -1) {
				ModLog.warn("Item is not registered with Forge!");
			} else {
				ModLog.warn("Looks like a late registration");
			}
			profile = createProfile(stack.getItem());
		}
		return profile;
	}

	public static ItemData get(final ItemStack stack) {
		return getProfile(stack).getItemData(stack);
	}

	public static void set(final ItemData data) {
		getProfile(data.stack).addItemData(data);
	}

	public static RecipeData getRecipe(final ItemStack stack) {
		return getProfile(stack).getRecipe(stack);
	}

	public static void setRecipe(final ItemStack stack, final RecipeData recipe) {
		getProfile(stack).addRecipe(stack, recipe);
	}

	public static void removeRecipe(final ItemStack stack) {
		getProfile(stack).removeRecipe(stack);
	}

	public static ExtractionData getExtractionData(final ItemStack stack) {
		return getProfile(stack).getExtractionData(stack);
	}

	public static void setExtractionData(final ItemStack stack, final ExtractionData data) {
		getProfile(stack).addExtractionData(stack, data);
	}

	public static void removeExtractionData(final ItemStack stack) {
		getProfile(stack).removeExtractionData(stack);
	}

	public static void setBlockedFromScrapping(final ItemStack stack, final boolean flag) {
		final ItemData data = get(stack);
		data.isBlockedFromScrapping = flag;
		set(data);
	}

	public static void setBlockedFromExtraction(final ItemStack stack, final boolean flag) {
		final ItemData data = get(stack);
		data.isBlockedFromExtraction = flag;
		set(data);
	}

	public static void setScrapValue(final ItemStack stack, final ScrapValue value) {
		final ItemData data = get(stack);
		data.value = value;
		set(data);
	}

	public static void setCompostIngredientValue(final ItemStack stack, final CompostIngredient value) {
		final ItemData data = get(stack);
		data.compostValue = value;
		set(data);
	}

	public static boolean canBeScrapped(final ItemStack stack) {
		return !getProfile(stack).getItemData(stack).isBlockedFromScrapping;
	}

	public static boolean canBeExtracted(final ItemStack stack) {
		return !getProfile(stack).getItemData(stack).isBlockedFromExtraction;
	}

	public static boolean isRecipeIgnored(final ItemStack stack) {
		final ItemData data = get(stack);
		return data.ignoreRecipe || data.isBlockedFromScrapping;
	}

	public static void setRecipeIgnored(final ItemStack stack, final boolean flag) {
		final ItemData data = get(stack);
		data.ignoreRecipe = flag;
		set(data);
	}

	public static void setRecipeIgnored(final Item item, final boolean flag) {
		setRecipeIgnored(OreDictionaryHelper.asGeneric(item), flag);
	}

	public static void setRecipeIgnored(final Block block, final boolean flag) {
		setRecipeIgnored(Item.getItemFromBlock(block), flag);
	}

	public static boolean isScrubbedFromOutput(final ItemStack stack) {
		return getProfile(stack).getItemData(stack).scrubFromOutput;
	}

	public static void setScrubbedFromOutput(final ItemStack stack, final boolean flag) {
		final ItemData data = get(stack);
		data.scrubFromOutput = flag;
		set(data);
	}
	
	public static boolean isBlockedFromVacuum(final ItemStack stack) {
		final ItemData data = get(stack);
		return data.isBlockedFromVacuum;
	}
	
	public static void setBlockedFromVacuum(final ItemStack stack, final boolean flag) {
		final ItemData data = get(stack);
		data.isBlockedFromVacuum = flag;
		set(data);
	}
	
	public static void ignoreMetaFilter(final ItemStack stack) {
		getProfile(stack).ignoreMetaFilter();
	}

	public static List<ItemData> getItemDataList() {
		final List<ItemData> data = new ArrayList<ItemData>();
		for (final ItemProfile profile : registry.values())
			profile.collectItemData(data);
		return data;
	}
	
	public static final int DIAG_ITEMDATA = 0;
	public static final int DIAG_RECIPES = 1;
	public static final int DIAG_EXTRACT = 2;

	public static void writeDiagnostic(final Writer writer, final int what) throws Exception {

		switch (what) {
		case ItemRegistry.DIAG_ITEMDATA:
			writer.write("Item Registry:\n");
			break;
		case ItemRegistry.DIAG_RECIPES:
			writer.write("Recycling Recipes:\n");
			break;
		case ItemRegistry.DIAG_EXTRACT:
			writer.write("Extraction Recipes:\n");
			break;
		}

		writer.write("=================================================================\n");
		for (final ItemProfile profile : registry.values())
			profile.writeDiagnostic(writer, what);
		writer.write("=================================================================\n\n\n");
	}

}
```


Overlapping Code:
```
lic final class ItemRegistry {
private static final Map<Item, ItemProfile> registry = new IdentityHashMap<Item, ItemProfile>();
static {
for (final Item o : GameData.getItemRegistry().typeSafeIterable())
createProfile(o);
}
private static ItemProfile createProfile(final Item item) {
final ItemProfile profile;
if (item.getHasSubtypes())
profile = new MultiItemProfile(item);
else if (item.isDamageable())
profile = new DamagableItemProfile(item);
else
profile = new SingleItemProfile(item);
registry.put(item, profile);
return profile;
}

private static ItemProfile getProfile(final ItemStack stack) {
final Item item = stack.getItem();
ItemProfile profile = registry.get(item);
if (profile == null) {
ModLog.warn("Item registration is missing: " + ItemStackHelper.resolveInternalName(stack));
if(GameData.getItemRegistry().getId(item) == -1) {
ModLog.warn("Item is not registered with Forge!");
} else {
ModLog.warn("Looks like a late registration");
}
profile = createProfile(stack.getItem());
}
return profile;
}
public static ItemData get(final ItemStack stack) {
return getProfile(stack).getItemData(stack);
}
public static void set(final ItemData data) {
getProfile(data.stack).addItemData(data);
}
public static RecipeData getRecipe(final ItemStack stack) {
return getProfile(stack).getRecipe(stack);
}
public static void setRecipe(final ItemStack stack, final RecipeData recipe) {
getProfile(stack).addRecipe(stack, recipe);
}
public static void removeRecipe(final ItemStack stack) {
getProfile(stack).removeRecipe(stack);
}
public static ExtractionData getExtractionData(final ItemStack stack) {
return getProfile(stack).getExtractionData(stack);
}
public static void setExtractionData(final ItemStack stack, final ExtractionData data) {
getProfile(stack).addExtractionData(stack, data);
}
public static void removeExtractionData(final ItemStack stack) {
getProfile(stack).removeExtractionData(stack);
}
public static void setBlockedFromScrapping(final ItemStack stack, final boolean flag) {
final ItemData data = get(stack);
data.isBlockedFromScrapping = flag;
set(data);
}
public static void setBlockedFromExtraction(final ItemStack stack, final boolean flag) {
final ItemData data = get(stack);
data.isBlockedFromExtraction = flag;
set(data);
}
public static void setScrapValue(final ItemStack stack, fina
```
<Overlap Ratio: 0.9792986903253063>

---

--- 68 --
Question ID: bc786a7c599bda940751dcc7562807bc6019832a
Original Code:
```
public class SWEA_1208_Flatten {
	private static int[] map;

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder stringBuilder = new StringBuilder();
		for(int tc=1;tc<=1;tc++) {
			int num = Integer.parseInt(bufferedReader.readLine());
			StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
			map = new int[100];
			for(int i=0;i<100;i++) {
				map[i] = Integer.parseInt(stringTokenizer.nextToken());
			}
			stringBuilder.append("#"+tc+" ");
			boolean end = false;
			int k=1;
			for( k=0;k<=num;k++) {
				int max=Integer.MIN_VALUE;
				int max_idx=-1;
				int min =Integer.MAX_VALUE;
				int min_idx=-1;
				for(int i=0;i<100;i++) {
					if(max<map[i]) {
						max_idx=i;
						max=map[i];
					}
					if(min>map[i]) {
						min_idx=i;
						min=map[i];
					}
				}
				//다했을 때 max,min이 정해진다.
				map[max_idx]-=1;
				map[min_idx]+=1;
				if(map[max_idx]==map[min_idx] ) { //차가 0 올 1 이 될때 그만둔다.
					stringBuilder.append(0+"\n");
					end = true;
					break;
				}
				else if(map[max_idx]-map[min_idx]==1 ) { //차가 0 올 1 이 될때 그만둔다.
					stringBuilder.append(1+"\n");
					end = true;
					break;
				}
				
				if(k==num&&!end) {
					stringBuilder.append((map[max_idx]-map[min_idx]+2)+"\n");
				}
			}
			
		}//tc
		System.out.println(stringBuilder);
	}
}
```


Overlapping Code:
```
te static int[] map;
public static void main(String[] args) throws NumberFormatException, IOException {

BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
StringBuilder stringBuilder = new StringBuilder();
for(int tc=1;tc<=1;tc++) {
int num = Integer.parseInt(bufferedReader.readLine());
StringTokenizer stringTokenizer = new StringTokenizer(bufferedReader.readLine());
map = new int[100];
for(int i=0;i<100;i++) {
map[i] = Integer.parseInt(stringTokenizer.nextToken());
}
stringBuilder.append("#"+tc+" ");
boolean end = false;
int k=1;
for( k=0;k<=num;k++) {
int max=Integer.MIN_VALUE;
int max_idx=-1;
int min =Integer.MAX_VALUE;
int min_idx=-1;
for(int i=0;i<100;i++) {
if(max<map[i]) {
max_idx=i;
max=map[i];
}
if(min>map[i]) {
min_idx=i;
min=map[i];
}
}
//다했을 때 max,min이 정해진다.
map[max_idx]-=1;
map[min_idx]+=1;
if(map[max_idx]==map[min_idx] ) { //차가 0 올 1 이 될때 그만둔다.
stringBuilder.append(0+"\n");
end = true;
break;
}
else if(map[max_idx]-map[min_idx]==1 ) { //차가 0 올 1 이 될때 그만둔다.
stringBuilder.append(1+"\n");
end = true;
break;
}

if(k==num&&!end) {
stringBuilder.append((map[max_idx]-map[min_idx]+2)+"\n");

```
<Overlap Ratio: 0.9296685529506872>

---

--- 69 --
Question ID: e461a59a52c86242f753f9940655bde177768b38
Original Code:
```
public class Dungeon {

    
    private int length, height, vampires, moves;
    private final boolean vampiresMove;
    private List<Vampire> vampireList  = new ArrayList<Vampire>();
    private Random random = new Random();
    private Player player = new Player();
    private Scanner input = new Scanner(System.in);
    
     public Dungeon(int length, int height, int vampires, int moves, boolean vampiresMove) {
        this.length=length;
        this.height=height;
        this.vampires=vampires;
        this.moves=moves;
        this.vampiresMove=vampiresMove;
     }
     
 
     
     private void printVampires() {
        for(Vampire vampire : vampireList) {
                 System.out.println(vampire);
             }
             System.out.println("");
     
     }
     
     private void createVampires() {
         
         for(int i=0;i<this.vampires;i++) {
                
                int x = this.random.nextInt(this.length);
                int y = this.random.nextInt(this.height);
             
                if(this.VampireAt(x, y) || this.player.isAt(x, y)) {
                x = this.random.nextInt(this.length);
                y = this.random.nextInt(this.height);
                this.vampireList.add(new Vampire(x,y));
                }
                
                else this.vampireList.add(new Vampire(x,y));
                
        }

     }
     
     private void printMap() {
         
         for(int y=0;y<this.height;y++) {
         
             for(int x=0;x<this.length;x++) {
                 if(this.player.isAt(x,y)) System.out.print("@");
                 else if(this.VampireAt(x,y)) System.out.print("v");
                 else System.out.print(".");  
             
             }
             System.out.println("");

         }
         System.out.println("");
         
     }
     
     private void randomize() {
         for(Vampire vampire : vampireList) {
             int x = this.random.nextInt(this.length);
             int y = this.random.nextInt(this.height);
             
             if(this.VampireAt(x, y) || this.player.isAt(x, y)) {
                x = this.random.nextInt(this.length);
                y = this.random.nextInt(this.height);
                vampire.setX(x);
                vampire.setY(y);
                }
             
             
             else{
             vampire.setX(x);
             vampire.setY(y);
                     }
         }
     }
     
    
     private boolean VampireAt(int x, int y) {
        for(Vampire vampire : vampireList) {
            if(vampire.getX()==x && vampire.getY()==y) return true;
        }
        return false;
    }
    
     
     private void action(String command) {
     
         ArrayList<Vampire> killed = new ArrayList<Vampire>();
         
         for(int position=0;position<command.length();position++) {
             char letter = command.charAt(position);
             this.player.move(letter);
             if(player.getX()>=this.length) player.setX(this.length-1);
             if(player.getY()>=this.height) player.setY(this.height-1);
             if(player.getX()<0) player.setX(0);
             if(player.getY()<0) player.setY(0);
                        for(Vampire vampire : vampireList) {
                        if(vampire.getX()==this.player.getX() && vampire.getY()==this.player.getY()) {
                killed.add(vampire);
            }
        }
                
             
         }
         
         
         this.vampireList.removeAll(killed);
     
     }
     
     
     public void run() {
     
         this.createVampires();

         while(moves>0) {
             System.out.println(this.moves + "\n");
             System.out.println("@ " + player.getX() + " " + player.getY());
             this.printVampires();
             this.printMap();
         
             String command = input.nextLine();
             this.action(command);
             
             if(this.vampireList.isEmpty()) {
                 System.out.println("YOU WIN");
                 break;
             }
             
             if(vampiresMove) this.randomize();
             moves--;
         }
     
         if(moves==0) System.out.println("YOU LOSE");
         
         
     
     }
 
    
}
```


Overlapping Code:
```
ight, vampires, moves;
private final boolean vampiresMove;
private List<Vampire> vampireList = new ArrayList<Vampire>();
private Random random = new Random();
private Player player = new Player();
private Scanner input = new Scanner(System.in);

public Dungeon(int length, int height, int vampires, int moves, boolean vampiresMove) {
this.length=length;
this.height=height;
this.vampires=vampires;
this.moves=moves;
this.vampiresMove=vampiresMove;
}



private void printVampires() {
for(Vampire vampire : vampireList) {
System.out.println(vampire);
}
System.out.println("");

}

private void createVampires() {

for(int i=0;i<this.vampires;i++) {

int x = this.random.nextInt(this.length);
int y = this.random.nextInt(this.height);

if(this.VampireAt(x, y) || this.player.isAt(x, y)) {
x = this.random.nextInt(this.length);
y = this.random.nextInt(this.height);
this.vampireList.add(new Vampire(x,y));
}

else this.vampireList.add(new Vampire(x,y));

}
}

private void printMap() {

for(int y=0;y<this.height;y++) {

for(int x=0;x<this.length;x++) {
if(this.player.isAt(x,y)) System.out.print("@");
else if(this.VampireAt(x,y)) System.out.print("v");
else System.out.print("."); 

}
System.out.println("");
}
System.out.println("");

}

private void randomize() {
for(Vampire vampire : vampireList) {
int x = this.random.nextInt(this.length);
int y = this.random.nextInt(this.height);

if(this.VampireAt(x, y) || this.player.isAt(x, y)) {
x = this.random.nextInt(this.length);
y = this.random.nextInt(this.height);
vampire.setX(x);
vampire.setY(y);
}


else{
vampire.setX(x);
vampire.setY(y);
}
}
}

```
<Overlap Ratio: 0.9592326139088729>

---

--- 70 --
Question ID: e7e068f6915ee3571e8252f1302a20b1be0c84ea
Original Code:
```
public class NetworkAutoRefresh extends BroadcastReceiver {

    private static final Logger log = LoggerFactory.getLogger(NetworkAutoRefresh.class);

    public static final String ACTION_RESCAN_INDEXED_FOLDERS = "com.archos.mediaprovider.video.NetworkAutoRefresh";
    public static final String ACTION_FORCE_RESCAN_INDEXED_FOLDERS = "com.archos.mediaprovider.video.NetworkAutoRefresh_force";

    private static final String AUTO_RESCAN_ON_APP_RESTART = "auto_rescan_on_app_restart";

    public static final String AUTO_RESCAN_STARTING_TIME_PREF = "auto_rescan_starting_time";
    public static final String AUTO_RESCAN_PERIOD = "auto_rescan_period";
    public static final String AUTO_RESCAN_LAST_SCAN = "auto_rescan_last_scan";
    public static final String AUTO_RESCAN_ERROR = "auto_rescan_error";
    public static final int AUTO_RESCAN_ERROR_UNABLE_TO_REACH_HOST = -1;
    public static final int AUTO_RESCAN_ERROR_NO_WIFI = -2;

    @Override
    public void onReceive(Context context, Intent intent) {

        if(intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {
            //reset alarm on boot
            int startingTime = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_STARTING_TIME_PREF, -1);
            int periode = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD,-1);
            if(startingTime!=-1&&periode>0){
                NetworkScannerUtil.scheduleNewRescan(context,startingTime,periode,false);
            }
            //start rescan if lastscan + period < current time (when has booted after scheduled time)
        }
        else if(intent.getAction().equals(ACTION_RESCAN_INDEXED_FOLDERS)||
                intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS)) {
            SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);
            /*
                do not scan if auto scan and already scan lately (for example on restart of device) or if already scanning
             */
            if(((pref.getInt(AUTO_RESCAN_PERIOD,0)<=0)
                    &&!intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS))
                    || com.archos.mediaprovider.video.NetworkScannerServiceVideo.isScannerAlive()
                    ) {
                SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
                Date dt = new Date();
                String S = sdf.format(dt);
                log.debug("onReceive: skipping rescan : " + S + " period = " + pref.getInt(AUTO_RESCAN_PERIOD, 0)+" is scanning ? "+String.valueOf(com.archos.mediaprovider.video.NetworkScannerReceiver.isScannerWorking()));
                return;
            }
            pref.edit().putLong(AUTO_RESCAN_LAST_SCAN, System.currentTimeMillis()).commit();
            log.debug("onReceive: received rescan intent");
            //updating
            Cursor cursor = ShortcutDbAdapter.VIDEO.queryAllShortcuts(context);
            List<Uri> toUpdate = new ArrayList<>();
            if (cursor.getCount() > 0) {
                int pathKey = cursor.getColumnIndex(ShortcutDbAdapter.KEY_PATH);
                cursor.moveToFirst();
                do {
                    Uri uri = Uri.parse(cursor.getString(pathKey));
                    toUpdate.add(uri);
                }
                while (cursor.moveToNext());
            }
            cursor.close();
            ShortcutDbAdapter.VIDEO.close();
            if(NetworkState.isLocalNetworkConnected(context)) {
                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, 0).commit();//reset error
                for (Uri uri : toUpdate) {
                    log.debug("onReceive: scanning "+uri);
                    if("upnp".equals(uri.getScheme())){ //start upnp service
                        UpnpServiceManager.startServiceIfNeeded(context);
                    }
                    if("ftp".equalsIgnoreCase(uri.getScheme())||"ftps".equals(uri.getScheme()))
                        Session.getInstance().removeFTPClient(uri);
                    if("sftp".equalsIgnoreCase(uri.getScheme()))
                        SFTPSession.getInstance().removeSession(uri);
                    Intent refreshIntent = new Intent(ArchosMediaIntent.ACTION_VIDEO_SCANNER_SCAN_FILE, uri);
                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_ON_FAIL_PREFERENCE, AUTO_RESCAN_ERROR);
                    refreshIntent.putExtra(NetworkScannerServiceVideo.RECORD_END_OF_SCAN_PREFERENCE, AUTO_RESCAN_LAST_SCAN);
                    refreshIntent.setPackage(ArchosUtils.getGlobalContext().getPackageName());
                    context.sendBroadcast(refreshIntent);
                }
            }
            else{
                PreferenceManager.getDefaultSharedPreferences(context).edit().putInt(AUTO_RESCAN_ERROR, AUTO_RESCAN_ERROR_NO_WIFI).commit();//reset error
                NetworkScannerServiceVideo.notifyListeners();
            }
            log.debug("onReceive: received rescan intent end");
        }
    }
    private static final AppState.OnForeGroundListener sForeGroundListener = new AppState.OnForeGroundListener() {
        @Override
        public void onForeGroundState(Context applicationContext, boolean foreground) {
            if (foreground&&autoRescanAtStart(applicationContext))
                forceRescan(applicationContext);
        }
    };
    public static void init() {
        AppState.addOnForeGroundListener(sForeGroundListener);
    }

    public static void forceRescan(Context context){
        Intent intent = new Intent(context, NetworkAutoRefresh.class);
        intent.setAction(ACTION_FORCE_RESCAN_INDEXED_FOLDERS);
        intent.setPackage(ArchosUtils.getGlobalContext().getPackageName());
        context.sendBroadcast(intent);
    }

    public static int getLastError(Context context){
        return  PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_ERROR, 0);
    }
    public static boolean autoRescanAtStart(Context context) {
        return PreferenceManager.getDefaultSharedPreferences(context).getBoolean(AUTO_RESCAN_ON_APP_RESTART,false);
    }
    public static void setAutoRescanAtStart(Context context, boolean autoRescanAtStart) {
        PreferenceManager.getDefaultSharedPreferences(context).edit().putBoolean(AUTO_RESCAN_ON_APP_RESTART,autoRescanAtStart).apply();
    }

    public static int getRescanPeriod(Context context) {
        return PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD, 0);
    }
}
```


Overlapping Code:
```
lass NetworkAutoRefresh extends BroadcastReceiver {
private static final Logger log = LoggerFactory.getLogger(NetworkAutoRefresh.class);
public static final String ACTION_RESCAN_INDEXED_FOLDERS = "com.archos.mediaprovider.video.NetworkAutoRefresh";
public static final String ACTION_FORCE_RESCAN_INDEXED_FOLDERS = "com.archos.mediaprovider.video.NetworkAutoRefresh_force";
private static final String AUTO_RESCAN_ON_APP_RESTART = "auto_rescan_on_app_restart";
public static final String AUTO_RESCAN_STARTING_TIME_PREF = "auto_rescan_starting_time";
public static final String AUTO_RESCAN_PERIOD = "auto_rescan_period";
public static final String AUTO_RESCAN_LAST_SCAN = "auto_rescan_last_scan";
public static final String AUTO_RESCAN_ERROR = "auto_rescan_error";
public static final int AUTO_RESCAN_ERROR_UNABLE_TO_REACH_HOST = -1;
public static final int AUTO_RESCAN_ERROR_NO_WIFI = -2;
@Override
public void onReceive(Context context, Intent intent) {
if(intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {
//reset alarm on boot
int startingTime = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_STARTING_TIME_PREF, -1);
int periode = PreferenceManager.getDefaultSharedPreferences(context).getInt(AUTO_RESCAN_PERIOD,-1);
if(startingTime!=-1&&periode>0){
NetworkScannerUtil.scheduleNewRescan(context,startingTime,periode,false);
}
//start rescan if lastscan + period < current time (when has booted after scheduled time)
}
else if(intent.getAction().equals(ACTION_RESCAN_INDEXED_FOLDERS)||
intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS)) {
SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(context);
/*
do not scan if auto scan and already scan lately (for example on restart of device) or if already scanning
*/
if(((pref.getInt(AUTO_RESCAN_PERIOD,0)<=0)
&&!intent.getAction().equals(ACTION_FORCE_RESCAN_INDEXED_FOLDERS))
|| com.archos.mediaprovider.video.NetworkScannerServiceVideo.isScannerAlive()
) {
SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss.SSS");
Date dt = new Date();
String S = sdf.format(dt);
log
```
<Overlap Ratio: 0.9868421052631579>

---

--- 71 --
Question ID: 8c69e59ac22e4898f825e302530424f432cc0f51
Original Code:
```
public class StereoOnWithCDCommand implements Command {
    Stereo stereo;

    public StereoOnWithCDCommand(Stereo stereo) {
        this.stereo = stereo;
    }

    @Override
    public void execute() {
        stereo.on();
        stereo.setCD();
        stereo.setVolume();
    }

    @Override
    public void undo() {
        stereo.off();
    }
}
```


Overlapping Code:
```
public class StereoOnWithCDCommand implements Command {
Stereo stereo;
public StereoOnWithCDCommand(Stereo stereo) {
this.stereo = stereo;
}
@Override
public void execute() {
stereo.on();
stereo.setCD();
stereo.setVolume();
}
@Override
public
```
<Overlap Ratio: 0.8832116788321168>

---

--- 72 --
Question ID: ce9cddc795975d7c65082cc6282c5b34f525ae0c
Original Code:
```
public final class GLTracer implements InvocationHandler {
    
    private final Object obj;
    private final IntMap<String> constMap;
    private static final HashMap<String, IntMap<Void>> nonEnumArgMap = new HashMap<String, IntMap<Void>>();
    
    private static final String ANSI_RESET = "\u001B[0m";
    private static final String ANSI_BRIGHT = "\u001B[1m";
    private static final String ANSI_RED = "\u001B[31m";
    private static final String ANSI_GREEN = "\u001B[32m";
    private static final String ANSI_YELLOW = "\u001B[33m";
    private static final String ANSI_BLUE = "\u001B[34m";
    private static final String ANSI_MAGENTA = "\u001B[35m";
    private static final String ANSI_CYAN = "\u001B[36m";

    private static void noEnumArgs(String method, int... argSlots) {
        IntMap<Void> argSlotsMap = new IntMap<>();
        for (int argSlot : argSlots) {
            argSlotsMap.put(argSlot, null);
        }
        nonEnumArgMap.put(method, argSlotsMap);
    }
    
    static {
        noEnumArgs("glViewport", 0, 1, 2, 3);
        noEnumArgs("glScissor", 0, 1, 2, 3);
        noEnumArgs("glClear", 0);
        noEnumArgs("glGetInteger", 1);
        noEnumArgs("glGetString", 1);
        
        noEnumArgs("glBindTexture", 1);
        noEnumArgs("glPixelStorei", 1);
//        noEnumArgs("glTexParameteri", 2);
        noEnumArgs("glTexImage2D", 1, 3, 4, 5);
        noEnumArgs("glTexImage3D", 1, 3, 4, 5, 6);
        noEnumArgs("glTexSubImage2D", 1, 2, 3, 4, 5);
        noEnumArgs("glTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
        noEnumArgs("glCompressedTexImage2D", 1, 3, 4, 5);
        noEnumArgs("glCompressedTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
        noEnumArgs("glDeleteTextures", 0);
        noEnumArgs("glReadPixels", 0, 1, 2, 3);
        
        noEnumArgs("glBindBuffer", 1);
        noEnumArgs("glEnableVertexAttribArray", 0);
        noEnumArgs("glDisableVertexAttribArray", 0);
        noEnumArgs("glVertexAttribPointer", 0, 1, 4, 5);
        noEnumArgs("glVertexAttribDivisorARB", 0, 1);
        noEnumArgs("glDrawRangeElements", 1, 2, 3, 5);
        noEnumArgs("glDrawArrays", 1, 2);
        noEnumArgs("glDeleteBuffers", 0);
        noEnumArgs("glBindVertexArray", 0);
        noEnumArgs("glGenVertexArrays", 0);
        
        noEnumArgs("glBindFramebufferEXT", 1);
        noEnumArgs("glBindRenderbufferEXT", 1);
        noEnumArgs("glRenderbufferStorageEXT", 2, 3);
        noEnumArgs("glRenderbufferStorageMultisampleEXT", 1, 3, 4);
        noEnumArgs("glFramebufferRenderbufferEXT", 3);
        noEnumArgs("glFramebufferTexture2DEXT", 3, 4);
        noEnumArgs("glFramebufferTextureLayerEXT", 2, 3, 4);
        noEnumArgs("glBlitFramebufferEXT", 0, 1, 2, 3, 4, 5, 6, 7, 8);
        
        noEnumArgs("glCreateProgram", -1);
        noEnumArgs("glCreateShader", -1);
        noEnumArgs("glShaderSource", 0);
        noEnumArgs("glCompileShader", 0);
        noEnumArgs("glGetShader", 0);
        noEnumArgs("glAttachShader", 0, 1);
        noEnumArgs("glLinkProgram", 0);
        noEnumArgs("glGetProgram", 0);
        noEnumArgs("glUseProgram", 0);
        noEnumArgs("glGetUniformLocation", 0, -1);
        noEnumArgs("glUniformMatrix3", 0);
        noEnumArgs("glUniformMatrix4", 0);
        noEnumArgs("glUniform1i", 0, 1);
        noEnumArgs("glUniform1f", 0);
        noEnumArgs("glUniform2f", 0);
        noEnumArgs("glUniform3f", 0);
        noEnumArgs("glUniform4", 0);
        noEnumArgs("glUniform4f", 0);
        noEnumArgs("glGetAttribLocation", 0, -1);
        noEnumArgs("glDetachShader", 0, 1);
        noEnumArgs("glDeleteShader", 0);
        noEnumArgs("glDeleteProgram", 0);
        noEnumArgs("glBindFragDataLocation", 0, 1);
    }
    
    public GLTracer(Object obj, IntMap<String> constMap) {
        this.obj = obj;
        this.constMap = constMap;
    }
    
    private static IntMap<String> generateConstantMap(Class<?> ... classes) {
        IntMap<String> constMap = new IntMap<>();
        for (Class<?> clazz : classes) {
            for (Field field : clazz.getFields()) {
                if (field.getType() == int.class) {
                    try {
                        int val = field.getInt(null);
                        String name = field.getName();
                        constMap.put(val, name);
                    } catch (IllegalArgumentException
                            | IllegalAccessException ex) {
                    }
                }
            }
        }
        // GL_ONE is more common than GL_TRUE (which is a boolean anyway)
        constMap.put(1, "GL_ONE");
        return constMap;
    }
    
    /**
     * Creates a tracer implementation that wraps OpenGL ES 2.
     *
     * @param glInterface OGL object to wrap
     * @param glInterfaceClasses The interface(s) to implement
     * @return A tracer that implements the given interface
     */
    public static Object createGlesTracer(Object glInterface, Class<?>... glInterfaceClasses) {
        IntMap<String> constMap = generateConstantMap(GL.class, GL2.class, GL3.class, GLFbo.class, GLExt.class);
        return Proxy.newProxyInstance(
                glInterface.getClass().getClassLoader(),
                glInterfaceClasses,
                new GLTracer(glInterface, constMap));
    }

    /**
     * Creates a tracer implementation that wraps OpenGL 2+.
     * 
     * @param glInterface OGL object to wrap
     * @param glInterfaceClasses The interface(s) to implement
     * @return A tracer that implements the given interface
     */
    public static Object createDesktopGlTracer(Object glInterface, Class<?> ... glInterfaceClasses) {
        IntMap<String> constMap = generateConstantMap(GL2.class, GL3.class, GL4.class, GLFbo.class, GLExt.class);
        return Proxy.newProxyInstance(glInterface.getClass().getClassLoader(),
                                      glInterfaceClasses, 
                                      new GLTracer(glInterface, constMap));
    }
    
    private void printStyle(String style, String string) {
        System.out.print(style + string + ANSI_RESET);
    }
    
    private void print(String string) {
        System.out.print(string);
    }
    
    private void printInt(int value) {
        print(Integer.toString(value));
    }
    
    private void printEnum(int value) {
        String enumName = constMap.get(value);
        if (enumName != null) {
            if (enumName.startsWith("GL_")) {
                enumName = enumName.substring(3);
            }
            if (enumName.endsWith("_EXT") || enumName.endsWith("_ARB")) {
                enumName = enumName.substring(0, enumName.length() - 4);
            }
            printStyle(ANSI_GREEN, enumName);
        } else {
            printStyle(ANSI_GREEN, "ENUM_" + Integer.toHexString(value));
        }
    }
    
    private void printIntOrEnum(String method, int value, int argIndex) {
        IntMap<Void> argSlotMap = nonEnumArgMap.get(method);
        if (argSlotMap != null && argSlotMap.containsKey(argIndex)) {
            printInt(value);
        } else {
            printEnum(value);
        }
    }
    
    private void printNewLine() {
        System.out.println();
    }
    
    private void printString(String value) {
        if (value.length() > 150) {
            value = value.substring(0, 150) + "...";
        }
        StringBuilder sb = new StringBuilder();
        sb.append(ANSI_YELLOW);
        sb.append("\"");
        sb.append(ANSI_RESET);
        for (String line : value.split("\n")) {
            sb.append(ANSI_YELLOW);
            sb.append(line.replaceAll("\0", "\\\\0"));
            sb.append(ANSI_RESET);
            sb.append("\n");
        }
        if (sb.length() > 1 && sb.charAt(sb.length() - 1) == '\n') {
            sb.setLength(sb.length() - 1);
        }
        sb.append(ANSI_YELLOW);
        sb.append("\"");
        sb.append(ANSI_RESET);
        print(sb.toString());
    }
    
    private void printBoolean(boolean bool) {
        printStyle(ANSI_BLUE, bool ? "true" : "false");
    }
    
    private void printBuffer(Buffer buffer) {
        StringBuilder sb = new StringBuilder();
        sb.append(ANSI_MAGENTA);
        if (buffer instanceof ByteBuffer) {
            sb.append("byte");
        } else if (buffer instanceof ShortBuffer) {
            sb.append("short");
        } else if (buffer instanceof CharBuffer) { 
            sb.append("char");
        } else if (buffer instanceof FloatBuffer) {
            sb.append("float");
        } else if (buffer instanceof IntBuffer) {
            sb.append("int");
        } else if (buffer instanceof LongBuffer) {
            sb.append("long");
        } else if (buffer instanceof DoubleBuffer) {
            sb.append("double");
        } else {
            throw new UnsupportedOperationException();
        }
        sb.append(ANSI_RESET);
        sb.append("[");
        
        if (buffer.position() == 0
                && buffer.limit() == buffer.capacity()) {
            // Common case. Just print buffer size.
            sb.append(buffer.capacity());
        } else {
            sb.append("pos=").append(buffer.position());
            sb.append(" lim=").append(buffer.limit());
            sb.append(" cap=").append(buffer.capacity());
        }
        
        sb.append("]");
        print(sb.toString());
    }
    
    private void printMethodName(String methodName) {
        if (methodName.startsWith("gl")) {
            // GL calls which actually draw (as opposed to change state)
            // will be printed in darker color
            methodName = methodName.substring(2);
            if (methodName.equals("Clear")
                    || methodName.equals("DrawRangeElements")
                    || methodName.equals("DrawElementsInstancedARB")) {
                print(methodName);
            } else {
                if (methodName.endsWith("EXT")) {
                    methodName = methodName.substring(0, methodName.length() - 3);
                }
                printStyle(ANSI_BRIGHT, methodName);
            }
        } else if (methodName.equals("resetStats")) {
            printStyle(ANSI_RED, "-- frame boundary --");
        }
    }
    
    private void printArgsClear(int mask) {
        boolean needAPipe = false;
        print("(");
        if ((mask & GL.GL_COLOR_BUFFER_BIT) != 0) {
            printStyle(ANSI_GREEN, "COLOR_BUFFER_BIT");
            needAPipe = true;
        }
        if ((mask & GL.GL_DEPTH_BUFFER_BIT) != 0) {
            if (needAPipe) {
                print(" | ");
            }
            printStyle(ANSI_GREEN, "DEPTH_BUFFER_BIT");
        }
        if ((mask & GL.GL_STENCIL_BUFFER_BIT) != 0) {
            if (needAPipe) {
                print(" | ");
            }
            printStyle(ANSI_GREEN, "STENCIL_BUFFER_BIT");
        }
        print(")");
    }
    
    private void printArgsGetInteger(Object[] args) {
        print("(");
        int param = (Integer)args[0];
        IntBuffer ib = (IntBuffer) args[1];
        printEnum(param);
        print(", ");
        printOut();
        if (param == GL2.GL_DRAW_BUFFER || param == GL2.GL_READ_BUFFER) {
            printEnum(ib.get(0));
        } else {
            printInt(ib.get(0));
        }
        print(")");
    }
    
    private void printArgsTexParameter(Object[] args) {
        print("(");

        int target = (Integer) args[0];
        int param = (Integer) args[1];
        int value = (Integer) args[2];

        printEnum(target);
        print(", ");
        printEnum(param);
        print(", ");
        
        if (param == GL2.GL_TEXTURE_BASE_LEVEL
                || param == GL2.GL_TEXTURE_MAX_LEVEL) {
            printInt(value);
        } else {
            printEnum(value);
        }
        
        print(")");
    }
    
    private void printOut() {
        printStyle(ANSI_CYAN, "out=");
    }
    
    private void printResult(String methodName, Object result, Class<?> returnType) {
        if (returnType != void.class) {
            print(" = ");
            if (result instanceof String) {
                printString((String) result);
            } else if (returnType == int.class) {
                int val = (Integer) result;
                printIntOrEnum(methodName, val, -1);
            } else if (returnType == boolean.class) {
                printBoolean((Boolean)result);
            } else {
                print(" = ???");
            }
        }
    }
    
    private void printNull() {
        printStyle(ANSI_BLUE, "null");
    }
    
    private void printArgs(String methodName, Object[] args, Class<?>[] paramTypes) {
        if (methodName.equals("glClear")) {
            printArgsClear((Integer)args[0]);
            return;
        } else if (methodName.equals("glTexParameteri")) {
            printArgsTexParameter(args);
            return;
        } else if (methodName.equals("glGetInteger")) {
            printArgsGetInteger(args);
            return;
        }
        
        if (args == null) {
            print("()");
            return;
        }
        
        print("(");
        for (int i = 0; i < args.length; i++) {
            if (paramTypes[i] == int.class) {
                int val = (Integer)args[i];
                printIntOrEnum(methodName, val, i);
            } else if (paramTypes[i] == boolean.class) {
                printBoolean((Boolean)args[i]);
            } else if (paramTypes[i] == String.class) {
                printString((String)args[i]);
            } else if (paramTypes[i] == String[].class) {
                String[] arr = (String[]) args[i];
                if (arr.length == 1) {
                    printString(arr[0]);
                } else {
                    print("string[" + arr.length + "]");
                }
            } else if (args[i] instanceof IntBuffer) {
                IntBuffer buf = (IntBuffer) args[i];
                if (buf.capacity() == 16) {
                    int val = buf.get(0);
                    printOut();
                    printIntOrEnum(methodName, val, i);
                } else if (buf.capacity() == 1) {
                    printOut();
                    print(Integer.toString(buf.get(0)));
                } else {
                    printBuffer(buf);
                }
            } else if (args[i] instanceof ByteBuffer) {
                ByteBuffer bb = (ByteBuffer)args[i];
                if (bb.capacity() == 250) {
                    printOut();
                    printBoolean(bb.get(0) != 0);
                } else {
                    printBuffer(bb);
                }
            } else if (args[i] instanceof Buffer) {
                printBuffer((Buffer)args[i]);
            } else if (args[i] != null) {
                print(args[i].toString());
            } else {
                printNull();
            }

            if (i != args.length - 1) {
                System.out.print(", ");
            }
        }
        print(")");
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String methodName = method.getName();
        printMethodName(methodName);
        
        if (methodName.startsWith("gl")) {
            try {
                // Try to evaluate result first, so we can see output values.
                Object result = method.invoke(obj, args);
                printArgs(methodName, args, method.getParameterTypes());
                printResult(methodName, result, method.getReturnType());
                printNewLine();
                return result;
            } catch (Throwable ex) {
                // Execution failed, print args anyway
                // but output values will be incorrect.
                printArgs(methodName, args, method.getParameterTypes());
                printNewLine();
                System.out.println("\tException occurred!");
                System.out.println(ex.toString());
                throw ex;
            }
        } else {
            printNewLine();
            return method.invoke(obj, args);
        }
    }
}
```


Overlapping Code:
```
c final class GLTracer implements InvocationHandler {

private final Object obj;
private final IntMap<String> constMap;
private static final HashMap<String, IntMap<Void>> nonEnumArgMap = new HashMap<String, IntMap<Void>>();

private static final String ANSI_RESET = "\u001B[0m";
private static final String ANSI_BRIGHT = "\u001B[1m";
private static final String ANSI_RED = "\u001B[31m";
private static final String ANSI_GREEN = "\u001B[32m";
private static final String ANSI_YELLOW = "\u001B[33m";
private static final String ANSI_BLUE = "\u001B[34m";
private static final String ANSI_MAGENTA = "\u001B[35m";
private static final String ANSI_CYAN = "\u001B[36m";
private static void noEnumArgs(String method, int... argSlots) {
IntMap<Void> argSlotsMap = new IntMap<>();
for (int argSlot : argSlots) {
argSlotsMap.put(argSlot, null);
}
nonEnumArgMap.put(method, argSlotsMap);
}

static {
noEnumArgs("glViewport", 0, 1, 2, 3);
noEnumArgs("glScissor", 0, 1, 2, 3);
noEnumArgs("glClear", 0);
noEnumArgs("glGetInteger", 1);
noEnumArgs("glGetString", 1);

noEnumArgs("glBindTexture", 1);
noEnumArgs("glPixelStorei", 1);
// noEnumArgs("glTexParameteri", 2);
noEnumArgs("glTexImage2D", 1, 3, 4, 5);
noEnumArgs("glTexImage3D", 1, 3, 4, 5, 6);
noEnumArgs("glTexSubImage2D", 1, 2, 3, 4, 5);
noEnumArgs("glTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
noEnumArgs("glCompressedTexImage2D", 1, 3, 4, 5);
noEnumArgs("glCompressedTexSubImage3D", 1, 2, 3, 4, 5, 6, 7);
noEnumArgs("glDeleteTextures", 0);
noEnumArgs("glReadPixels", 0, 1, 2, 3);

noEnumArgs("glBindBuffer", 1);
noEnumArgs("glEnableVertexAttribArray", 0);
noEnumArgs("glDisableVertexAttribArray", 0);
noEnumArgs("glVertexAttribPointer", 0, 1, 4, 5);
noEnumArgs("glVertexAttribDivisorARB", 0, 1);
noEnumArgs("glDrawRangeElements", 1, 2, 3, 5);
noEnumArgs("glDrawArrays", 1, 2);
noEnumArgs("glDeleteBuffers", 0);
noEnumArgs("glBindVertexArray", 0);
noEnumArgs("glGenVertexArrays", 0);

noEnumArgs("glBindFramebufferEXT", 1);
noEnumArgs("glBindRenderbufferEXT", 1);
noEnumArgs("glRenderbufferStorageEXT", 2, 3);
noEnumArgs("glRenderbufferStorageMultisampleEXT", 1, 3,
```
<Overlap Ratio: 0.9947990543735225>

---

--- 73 --
Question ID: 383854c2565eb2d95e745b173b337beb09602985
Original Code:
```
public class playstateinput3 implements InputProcessor {
    playstate3 ps3;



    public playstateinput3(playstate3 ps){
        this.ps3 = ps;
    }

    @Override

    public boolean keyDown(int keycode) {
        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        return false;
    }

    @Override
    public boolean keyTyped(char character) {
        return false;
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
        return false;
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
        if(ps3.getGeri().getButtonRect().contains(screenX,screenY)) {
            ps3.getSound2().stop();
            ps3.getSm3().pushState(new menustate(ps3.getSm3()));}
        if(ps3.getDeger()==ps3.getDeger2()){
            int a= ps3.getSkor();
            a=a+1;
            ps3.setSkor(a);

        }
        else
        {
            int c=ps3.getCan();
            if(c==5)
            {
                c--;
            }
            else if(c==4)
            {
                c--;
            }
            else if(c==3)
            {
                c--;
            }
            else if(c==2)
            {
                c--;
            }
            else if(c==1)
            {
                c--;
            }
            else if(c==0)
            {
                c=0;
            }

            ps3.setCan(c);
        }



        return false;
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {

        return false;
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
        return false;
    }

    @Override
    public boolean scrolled(int amount) {
        return false;
    }
}
```


Overlapping Code:
```
InputProcessor {
playstate3 ps3;
public playstateinput3(playstate3 ps){
this.ps3 = ps;
}
@Override
public boolean keyDown(int keycode) {
return false;
}
@Override
public boolean keyUp(int keycode) {
return false;
}
@Override
public boolean keyTyped(char character) {
return false;
}
@Override
public boolean touchDown(int screenX, int screenY, int pointer, int button) {
return false;
}
@Override
public boolean touchUp(int screenX, int screenY, int pointer, int button) {
if(ps3.getGeri().getButtonRect().contains(screenX,screenY)) {
ps3.getSound2().stop();
ps3.getSm3().pushState(new menustate(ps3.getSm3()));}
if(ps3.getDeger()==ps3.getDeger2()){
int a= ps3.getSkor();
a=a+1;
ps3.setSkor(a);
}
else
{
int c=ps3.getCan();
if(c==5)
{
c--;
}
else if(c==4)
{
c--;
}
else if(c==3)
{
c--;
}
else if(c==2)
{
c--;
}
else if(c==1)
{
c--;
}
else if(c==0)
{
c=0;
}
ps3.setCan(c);
}
return false;
}
@Override
public boolean touchDragged(int screenX, int screenY, int pointer) {
return false;
}
@Override
public boolean mouseMoved(int screenX, int screenY) {
return false;
}
@Override
public boolean scrolled(int amount) {
return false;
}
}
```
<Overlap Ratio: 0.9658119658119658>

---

--- 74 --
Question ID: 220079aeaf150fd54df0fd4ce56dc2d3c5cf40b5
Original Code:
```
public class MappingsTest
    extends TestCase
{
    /**
     * Constructor for MappingsTest.
     *
     * @param name the name for this test case
     */
    public MappingsTest(String name)
    {
        super(name);
    }

    private static final String TO_1 = "base64Binary";
    private static final String FROM_1 = "datatype.Blob";
    private static final String FROM_2 = "datatype.byte[]";
    private static final String FROM_3 = "datatype.Byte[]";
    private static final String FROM_4 = "datatype.Clob";
    private static final String TO_2 = "java.lang.String";
    private static final String FROM_5 = "datatype.String";
    private static final String NOT_MAPPED_1 = "datatype.byte";
    private static final String NOT_MAPPED_2 = "datatype.String[]";
    private static final String TO_3 = "Class<? extends ToType>";
    private static final String FROM_6 = "Class<? extends FromType>";

    /**
     *
     */
    public void testGetTo()
    {
        Mappings mappings1 = new Mappings();
        Mapping mapping1 = new Mapping();
        mapping1.setTo(TO_1);
        mapping1.addFrom(FROM_1);
        mapping1.addFrom(FROM_2);
        mapping1.addFrom(FROM_3);
        mapping1.addFrom(FROM_4);
        mappings1.addMapping(mapping1);

        // make sure the to == from when passing in a mappings1 that don't exist
        assertNotNull(mappings1.getTo(NOT_MAPPED_1));
        assertEquals(
            NOT_MAPPED_1,
            mappings1.getTo(NOT_MAPPED_1));
        assertEquals(
            mappings1.getTo(NOT_MAPPED_2),
            mappings1.getTo(NOT_MAPPED_2));

        // make sure we can retrieve the to using a from array.
        assertNotNull(mappings1.getTo(FROM_1));
        assertEquals(
            TO_1,
            mappings1.getTo(FROM_1));

        // make sure we can retrieve the to using a from non array.
        assertEquals(
            TO_1,
            mappings1.getTo(FROM_4));

        Mappings mappings2 = new Mappings();
        Mapping mapping2 = new Mapping();
        mapping2.setTo(TO_2);
        mapping2.addFrom(FROM_5);
        mappings2.addMapping(mapping2);
        assertEquals(
            TO_2,
            mappings2.getTo(FROM_5));

        Mappings mappings3 = new Mappings();
        Mapping mapping3 = new Mapping();
        mapping3.setTo(TO_3);
        mapping3.addFrom(FROM_6);
        mappings3.addMapping(mapping3);
        // make sure whitespace isn't deleted, only trimmed (Java generics would fail compilation otherwise for example)
        assertEquals(
            TO_3,
            mappings3.getTo(FROM_6));
    }

    /**
     *
     */
    public void testMappingsInheritance()
    {
        final URL testMappingsParentUri = MappingsTest.class.getResource("TestMappingsParent.xml");
        assertNotNull(testMappingsParentUri);
        final Mappings testMappingsParent = Mappings.getInstance(testMappingsParentUri);
        assertNotNull(testMappingsParent);
        final Collection<Mapping> mappings1 = testMappingsParent.getMappings();
        assertEquals(
            3,
            mappings1.size());
        final Iterator mappings1Iterator = mappings1.iterator();
        Mapping mapping1 = (Mapping)mappings1Iterator.next();
        assertEquals(
            "datatype::typeOne",
            mapping1.getFroms().iterator().next());
        assertEquals(
            "Type_One",
            mapping1.getTo());
        Mapping mapping2 = (Mapping)mappings1Iterator.next();
        assertEquals(
            "datatype::typeTwo",
            mapping2.getFroms().iterator().next());
        assertEquals(
            "Type_Two",
            mapping2.getTo());
        Mapping mapping3 = (Mapping)mappings1Iterator.next();
        assertEquals(
            "datatype::typeThree",
            mapping3.getFroms().iterator().next());
        assertEquals(
            "Type_Three",
            mapping3.getTo());

        final URL testMappingsUri = MappingsTest.class.getResource("TestMappings.xml");
        assertNotNull(testMappingsUri);
        Mappings testMappings = Mappings.getInstance(testMappingsUri);
        assertNotNull(testMappings);
        final Collection<Mapping> mappings2 = testMappings.getMappings();
        assertEquals(
            4,
            mappings2.size());
        final Iterator mappings2Iterator = mappings2.iterator();
        mapping1 = (Mapping)mappings2Iterator.next();
        assertEquals(
            "datatype::typeOne",
            mapping1.getFroms().iterator().next());
        assertEquals(
            "Type_One",
            mapping1.getTo());
        mapping2 = (Mapping)mappings2Iterator.next();
        assertEquals(
            "datatype::typeTwo",
            mapping2.getFroms().iterator().next());
        assertEquals(
            "Overridden",
            mapping2.getTo());
        mapping3 = (Mapping)mappings2Iterator.next();
        assertEquals(
            "datatype::typeThree",
            mapping3.getFroms().iterator().next());
        assertEquals(
            "Type_Three",
            mapping3.getTo());
        Mapping mapping4 = (Mapping)mappings2Iterator.next();
        assertEquals(
            "datatype::typeFour",
            mapping4.getFroms().iterator().next());
        assertEquals(
            "Type_Four",
            mapping4.getTo());
    }

    /**
     *
     */
    public void testEmptyMappings()
    {
        final URL testEmptyMappingsUri = MappingsTest.class.getResource("TestMappingsEmpty.xml");
        assertNotNull(testEmptyMappingsUri);

        final Mappings mappings = Mappings.getInstance(testEmptyMappingsUri);
        assertNotNull(mappings);

        final Collection<Mapping> mappingCollection = mappings.getMappings();
        assertEquals(0, mappingCollection.size());
    }

    /**
     *
     */
    public void testTransitivelyExtendingLogicalMappings()
    {
        // the order has been mixed up on purpose
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsExtendsLevelA.xml"));
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsExtendsLevelD.xml"));
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsExtendsLevelC.xml"));
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsExtendsLevelB.xml"));

        Mappings.initializeLogicalMappings();

        final Mappings mappings = Mappings.getInstance("TestMappingsExtendsLevelD");
        assertNotNull(mappings);

        final Mapping aaa = mappings.getMapping("datatype::aaa");
        assertNotNull(aaa);
        assertEquals("AAA", aaa.getTo());

        final Mapping bbb = mappings.getMapping("datatype::bbb");
        assertNotNull(bbb);
        assertEquals("BBB", bbb.getTo());

        final Mapping ccc = mappings.getMapping("datatype::ccc");
        assertNotNull(ccc);
        assertEquals("CCC", ccc.getTo());

        final Mapping ddd = mappings.getMapping("datatype::ddd");
        assertNotNull(ddd);
        assertEquals("DDD", ddd.getTo());
    }

    /**
     *
     */
    public void testCyclicInheritanceLogicalMappingsException()
    {
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsCyclicA.xml"));
        Mappings.addLogicalMappings(MappingsTest.class.getResource("TestMappingsCyclicB.xml"));

        try
        {
            Mappings.initializeLogicalMappings();
            fail("Expected exception");
        }
        catch (MappingsException mappingsException)
        {
            final String message = mappingsException.getMessage();
            assertTrue(message.startsWith("Logical mappings cannot be initialized due to invalid inheritance"));
            assertTrue(message.contains("TestMappingsCyclicA"));
            assertTrue(message.contains("TestMappingsCyclicB"));
        }
        finally
        {
            // clear out the cached entries so that the other tests won't fail because if the invalid
            // ones we have entered here
            Mappings.clearLogicalMappings();
        }
    }
}
```


Overlapping Code:
```
s MappingsTest
extends TestCase
{
/**
* Constructor for MappingsTest.
*
* @param name the name for this test case
*/
public MappingsTest(String name)
{
super(name);
}
private static final String TO_1 = "base64Binary";
private static final String FROM_1 = "datatype.Blob";
private static final String FROM_2 = "datatype.byte[]";
private static final String FROM_3 = "datatype.Byte[]";
private static final String FROM_4 = "datatype.Clob";
private static final String TO_2 = "java.lang.String";
private static final String FROM_5 = "datatype.String";
private static final String NOT_MAPPED_1 = "datatype.byte";
private static final String NOT_MAPPED_2 = "datatype.String[]";
private static final String TO_3 = "Class<? extends ToType>";
private static final String FROM_6 = "Class<? extends FromType>";
/**
*
*/
public void testGetTo()
{
Mappings mappings1 = new Mappings();
Mapping mapping1 = new Mapping();
mapping1.setTo(TO_1);
mapping1.addFrom(FROM_1);
mapping1.addFrom(FROM_2);
mapping1.addFrom(FROM_3);
mapping1.addFrom(FROM_4);
mappings1.addMapping(mapping1);
// make sure the to == from when passing in a mappings1 that don't exist
assertNotNull(mappings1.getTo(NOT_MAPPED_1));
assertEquals(
NOT_MAPPED_1,
mappings1.getTo(NOT_MAPPED_1));
assertEquals(
mappings1.getTo(NOT_MAPPED_2),
mappings1.getTo(NOT_MAPPED_2));
// make sure we can retrieve the to using a from array.
assertNotNull(mappings1.getTo(FROM_1));
assertEquals(
TO_1,
mappings1.getTo(FROM_1));
// make sure we can retrieve the to using a from non array.
assertEquals(
TO_1,
mappings1.getTo(FROM_4));
Mappings mappings2 = new Mappings();
Mapping mapping2 = new Mapping();
mapping2.setTo(TO_2);
mapping2.addFrom(FROM_5);
mappings2.addMapping(mapping2);
assertEquals(
TO_2,
mappings2.getTo(FROM_5));
Mappings mappings3 = new Mappings();
Mapping mapping3 = new Mapping();
mapping3.setTo(TO_3);
mapping3.addFrom(FROM_6);
mappings3.addMapping(mapping3);
// make sure whitespace isn't deleted, only trimmed (Java generics would fail compi
```
<Overlap Ratio: 0.9871668311944719>

---

--- 75 --
Question ID: 83363982165be6cd29bfe88c44fd30a52f9b8633
Original Code:
```
public class SchemaConverter {
  private static final Logger LOGGER = LoggerFactory.getLogger(SchemaConverter.class);

  public static SimpleFeatureType schemaToFeatureType(
      final StructType schema,
      final String typeName) {
    final SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();
    typeBuilder.setName(typeName);
    typeBuilder.setNamespaceURI(BasicFeatureTypes.DEFAULT_NAMESPACE);
    try {
      typeBuilder.setCRS(CRS.decode("EPSG:4326", true));
    } catch (final FactoryException e) {
      LOGGER.error(e.getMessage(), e);
    }

    final AttributeTypeBuilder attrBuilder = new AttributeTypeBuilder();

    for (final StructField field : schema.fields()) {
      final AttributeDescriptor attrDesc = attrDescFromStructField(attrBuilder, field);

      typeBuilder.add(attrDesc);
    }

    return typeBuilder.buildFeatureType();
  }

  private static AttributeDescriptor attrDescFromStructField(
      final AttributeTypeBuilder attrBuilder,
      final StructField field) {
    if (field.name().equals("geom")) {
      return attrBuilder.binding(Geometry.class).nillable(false).buildDescriptor("geom");
    }
    if (field.dataType() == DataTypes.StringType) {
      return attrBuilder.binding(String.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.DoubleType) {
      return attrBuilder.binding(Double.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.FloatType) {
      return attrBuilder.binding(Float.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.LongType) {
      return attrBuilder.binding(Long.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.IntegerType) {
      return attrBuilder.binding(Integer.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.BooleanType) {
      return attrBuilder.binding(Boolean.class).buildDescriptor(field.name());
    } else if (field.dataType() == DataTypes.TimestampType) {
      return attrBuilder.binding(Date.class).buildDescriptor(field.name());
    }

    return null;
  }

  public static StructType schemaFromFeatureType(final SimpleFeatureType featureType) {
    final List<StructField> fields = new ArrayList<>();

    for (final AttributeDescriptor attrDesc : featureType.getAttributeDescriptors()) {
      final SimpleFeatureDataType sfDataType = attrDescToDataType(attrDesc);

      final String fieldName = (sfDataType.isGeom() ? "geom" : attrDesc.getName().getLocalPart());

      final StructField field =
          DataTypes.createStructField(fieldName, sfDataType.getDataType(), true);

      fields.add(field);
    }

    if (fields.isEmpty()) {
      LOGGER.error("Feature type produced empty dataframe schema!");
      return null;
    }

    return DataTypes.createStructType(fields);
  }

  private static SimpleFeatureDataType attrDescToDataType(final AttributeDescriptor attrDesc) {
    boolean isGeom = false;
    DataType dataTypeOut = DataTypes.NullType;

    if (attrDesc.getType().getBinding().equals(String.class)) {

      dataTypeOut = DataTypes.StringType;
    } else if (attrDesc.getType().getBinding().equals(Double.class)) {
      dataTypeOut = DataTypes.DoubleType;
    } else if (attrDesc.getType().getBinding().equals(Float.class)) {
      dataTypeOut = DataTypes.FloatType;
    } else if (attrDesc.getType().getBinding().equals(Long.class)) {
      dataTypeOut = DataTypes.LongType;
    } else if (attrDesc.getType().getBinding().equals(Integer.class)) {
      dataTypeOut = DataTypes.IntegerType;
    } else if (attrDesc.getType().getBinding().equals(Boolean.class)) {
      dataTypeOut = DataTypes.BooleanType;
    } else if (attrDesc.getType().getBinding().equals(Date.class)) {
      dataTypeOut = DataTypes.TimestampType;
    }

    // Custom geometry types get WKB encoding
    else if (Geometry.class.isAssignableFrom(attrDesc.getType().getBinding())) {
      dataTypeOut = GeoWaveSpatialEncoders.geometryUDT;
      isGeom = true;
    }

    return new SimpleFeatureDataType(dataTypeOut, isGeom);
  }
}
```


Overlapping Code:
```
Converter {
private static final Logger LOGGER = LoggerFactory.getLogger(SchemaConverter.class);
public static SimpleFeatureType schemaToFeatureType(
final StructType schema,
final String typeName) {
final SimpleFeatureTypeBuilder typeBuilder = new SimpleFeatureTypeBuilder();
typeBuilder.setName(typeName);
typeBuilder.setNamespaceURI(BasicFeatureTypes.DEFAULT_NAMESPACE);
try {
typeBuilder.setCRS(CRS.decode("EPSG:4326", true));
} catch (final FactoryException e) {
LOGGER.error(e.getMessage(), e);
}
final AttributeTypeBuilder attrBuilder = new AttributeTypeBuilder();
for (final StructField field : schema.fields()) {
final AttributeDescriptor attrDesc = attrDescFromStructField(attrBuilder, field);
typeBuilder.add(attrDesc);
}
return typeBuilder.buildFeatureType();
}
private static AttributeDescriptor attrDescFromStructField(
final AttributeTypeBuilder attrBuilder,
final StructField field) {
if (field.name().equals("geom")) {
return attrBuilder.binding(Geometry.class).nillable(false).buildDescriptor("geom");
}
if (field.dataType() == DataTypes.StringType) {
return attrBuilder.binding(String.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.DoubleType) {
return attrBuilder.binding(Double.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.FloatType) {
return attrBuilder.binding(Float.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.LongType) {
return attrBuilder.binding(Long.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.IntegerType) {
return attrBuilder.binding(Integer.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.BooleanType) {
return attrBuilder.binding(Boolean.class).buildDescriptor(field.name());
} else if (field.dataType() == DataTypes.TimestampType) {
return attrBuilder.binding(Date.class).buildDescriptor(field.name());
}
return null;
}
public static StructType schemaFromFeatureType(final SimpleFeatureType featureType) {
final List<StructField> fields = new ArrayList<>();
for (final AttributeDescriptor attrDesc : featureType.getAttributeDescriptors()) {
final SimpleFeatureDataType sfDataType = attrDescToDataType(attrDesc);
final S
```
<Overlap Ratio: 0.9749560632688928>

---

--- 76 --
Question ID: 7cc50de08ccf9388650a986f705d1ff8a054770e
Original Code:
```
public class SdkTracker {

    /** Current SDK details - may be null */
    private volatile SdkProfile sdkProfile;

    /** List of listeners for SDK loaded */
    private final List<SdkListener> sdkListeners;
    /** Tracks Target Data Load Status */
	private TargetLoadStatusMonitor targetLoadStatusMonitor;

	/**
	 * Construct SdkTracker object
	 * @param objectFactory Object factory
	 */
    public SdkTracker(AndworxContext objectFactory) {
		sdkListeners = new ArrayList<>();
    }

    /**
     * Returns Information on an Android SDK installation and environment
     * @return SdkProfile object
     */
	public SdkProfile getSdkProfile() {
		return sdkProfile;
	}

	/**
	 * Get SDK details for given SDK location. If valid, update currentSdk field and notify SDK listeners.
	 * @param sdkLocation SDK file system path
	 * @return CurrentSdk object for given location
	 */
	public SdkProfile setCurrentSdk(String sdkLocation) {
		SdkProfile trialSdk = new SdkProfile(sdkLocation);
		if (trialSdk.isValid()) {
			if (targetLoadStatusMonitor != null)
				trialSdk.setTargetLoadStatusMonitor(targetLoadStatusMonitor);
	    	//System.out.println("Notifying " + sdkListeners.size() + " SDK listeners");
			sdkProfile = trialSdk;
			synchronized(sdkListeners) {
				sdkListeners.forEach(sdkListener -> sdkListener.onLoadSdk(trialSdk));
			}
		}
		return trialSdk;
	}

	/**
	 * Adds listener to be notified when a valid SDK is loaded
	 * @param sdkListener SDK listener
	 */
	public void addSdkListener(SdkListener sdkListener) {
		synchronized(sdkListeners) {
			sdkListeners.add(sdkListener);
			if (sdkProfile != null)
				sdkListener.onLoadSdk(sdkProfile);
		}
	}

	/**
	 * Sets Target Data Load Status Monitor
	 * @param monitor
	 */
	public void setTargetLoadStatusMonitor(TargetLoadStatusMonitor monitor) {
		this.targetLoadStatusMonitor = monitor;
		if (sdkProfile != null)
			sdkProfile.setTargetLoadStatusMonitor(monitor);
	}
}
```


Overlapping Code:
```
ic class SdkTracker {
/** Current SDK details - may be null */
private volatile SdkProfile sdkProfile;
/** List of listeners for SDK loaded */
private final List<SdkListener> sdkListeners;
/** Tracks Target Data Load Status */
private TargetLoadStatusMonitor targetLoadStatusMonitor;
/**
* Construct SdkTracker object
* @param objectFactory Object factory
*/
public SdkTracker(AndworxContext objectFactory) {
sdkListeners = new ArrayList<>();
}
/**
* Returns Information on an Android SDK installation and environment
* @return SdkProfile object
*/
public SdkProfile getSdkProfile() {
return sdkProfile;
}
/**
* Get SDK details for given SDK location. If valid, update currentSdk field and notify SDK listeners.
* @param sdkLocation SDK file system path
* @return CurrentSdk object for given location
*/
public SdkProfile setCurrentSdk(String sdkLocation) {
SdkProfile trialSdk = new SdkProfile(sdkLocation);
if (trialSdk.isValid()) {
if (targetLoadStatusMonitor != null)
trialSdk.setTargetLoadStatusMonitor(targetLoadStatusMonitor);
//System.out.println("Notifying " + sdkListeners.size() + " SDK listeners");
sdkProfile = trialSdk;
synchronized(sdkListeners) {
sdkListeners.forEach(sdkListener -> sdkListener.onLoadSdk(trialSdk));
}
}
return trialSdk;
}
/**
* Adds listener to be notified when a valid SDK is loaded
* @param sdkListener SDK listener
*/
public void addSdkListener(SdkListener sdkListener) {
synchronized(sdkListeners) {
sdkListeners.add(sdkListener);
if (sdkProfile != null)
sdkListener.onLoadSdk(sdkProfile);
}
}
/**
* Sets Target Data Load Status Monitor
* @param monitor
*/
public void setTargetLoadStatusMonitor(TargetLoadStatusMonitor monitor) {
this.targetLoadStatusMonitor = monitor;
if (sdkProfile != null)
sdkProfile.setTar
```
<Overlap Ratio: 0.9787472035794184>

---

--- 77 --
Question ID: e0c8377c74b7ba4b45056364cc0c53625cc79b45
Original Code:
```
@objid ("5855fce8-9795-40f8-927d-4d8fefceded3")
public class ModelUtils {
    @objid ("08d3e755-5c18-4e5d-be2b-7d70ebcac93d")
    private static String namespacingSeparator = "::";

    /**
     * return the ModelElement target of the FIRST dependency stereotyped stereotypeName  owned by source element
     * @param source : the ModelElement which is the source of the dependency
     * @param stereotypeName : the stereotype name applicable on Dependency Metaclass
     * @return the ModelElement target of the first dependency
     */
    @objid ("50592fea-05e0-4c0c-a045-16e588becc0a")
    public static ModelElement getTarget(ModelElement source, String stereotypeName) {
        for(Dependency dp: source.getDependsOnDependency()){
            if(dp.isStereotyped(ICPSWarmPeerModule.MODULE_NAME,  stereotypeName)){
                ModelElement element = dp.getDependsOn();
                if(element != null){
                    return element;
                }       
            }
        }
        return null;
    }

    /**
     * This method returns the list of Classifier associated (sharing an Association) to the given Association
     * @param center : the central association
     * @return the list of associated Association
     */
    @objid ("2c78105e-5dcc-4a94-b961-c29e71a4e341")
    public static List<Classifier> getAssociatedClassifier(final Classifier center) {
        List<Classifier> result = new ArrayList<Classifier>();
        
        for (AssociationEnd feature : center.getOwnedEnd()){
            AssociationEnd opposite = feature.getOpposite();
            Classifier owner = opposite.getOwner();
            if (!result.contains(owner))
                result.add(owner);
        }
        return result;
    }

    /**
     * This method test if the Analyst module is already deployed
     * @return true if the Analyst module is deployed
     */
    @objid ("e0511acc-2a34-4f62-9c84-079210755a79")
    public static boolean isRequirementDeployed() {
        return true;
    }

    /**
     * Allows the tagged value getting
     * @param tagtypeName : tagged value name
     * @param element : owner element
     * @return the tagged value values in a string form
     */
    @objid ("8c279abb-09c3-4263-9934-d649ac41d04b")
    public static String getTaggedValue(final String tagtypeName, final ModelElement element) {
        for (TaggedValue tag : element.getTag()) {
            TagType type = tag.getDefinition();
            String tagname = type.getName();
            if (tagname.equals(tagtypeName)) {
                if (!tag.getActual().isEmpty()) {
                    String result = "";
                    for (TagParameter tp: tag.getActual()) {
                        if (tag.getDefinition().getParamNumber().equals("1")) {
        
                            result = tp.getValue();
                        }
                        else {
                            result = result + tp.getValue() + " ";
                        }
                    }
                    return result; 
                }
            }
        }
        return "";
    }

    /**
     * Allows the tagged value values parsing to string tab
     * @param value : the tagged value
     * @return a string tab with many string values
     */
    @objid ("9ee07478-e4c2-466f-8265-7f3c6428b885")
    public static String[] parseValuesToStringTab(final String value) {
        ArrayList<String> dynamicList = new ArrayList<String>();
        String current = "";
        boolean hasManyElts = false;
        
        for (int i=0; i < value.length(); i++) {
            if (value.charAt(i) != ' ') {
                current = current + value.charAt(i);
        
                if ((i == value.length()-1) && (hasManyElts)) {
                    dynamicList.add(current);
                }
            }
        
            if ((value.charAt(i) == ' ')&&(!current.equals(""))) {
                dynamicList.add(current);
                current = "";
                hasManyElts = true;
            }
            else if (current.length() == value.length()) {
                dynamicList.add(current);
                current = "";
            }
        }
        
        String[] result = dynamicList.toArray(new String[dynamicList.size()]);
        return result;
    }

    /**
     * Allows the tagged value adding.
     * @param element : owner element
     * @param tagtypeName : tagged value name
     * @param value : value to add
     */
    @objid ("f13232aa-0596-4eb3-b523-afcf3beacc41")
    public static void addStringValue(final ModelElement element, final String tagtypeName, final String value) {
        // DON'T place Transition HERE
        boolean exist = false;
        List<TaggedValue> tagElements = element.getTag();
        TaggedValue tvFound = null;
        TagType type = null;
        
        // existing verification
        if (!tagElements.isEmpty()) {
            for (TaggedValue tag : tagElements) {
        
                type = tag.getDefinition();
                String tagname = type.getName();
        
                if (tagname.equals(tagtypeName)) {
                    exist = true;
                    tvFound = tag;
                }
            }
        }
        
        // if the tagged value doesn't exist yet, we create this
        if (!exist) {
            
                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(type, element);
                if (!v.getDefinition().getParamNumber().equals("0")) {
                    setTaggedValue(element, tagtypeName, value);
                }
            
        }
        // if the tagged value already exists
        else {
            if ((tvFound!= null) && (tvFound.getDefinition().getParamNumber().equals("0"))) {
                tvFound.delete();
            }
            else {
                setTaggedValue(element, tagtypeName, value);
            }
        }
    }

    /**
     * Allows the tagged value setting
     * @param elt : owner element
     * @param tagtypeName : name of the tagtype
     * @param value : taggeValue value
     */
    @objid ("46410fc4-66cc-4915-96e8-1cd2e86aaf9f")
    public static void setTaggedValue(final ModelElement elt, final String tagtypeName, final String value) {
        // if the element has tagged values
        if (!elt.getTag().isEmpty()) {
            // for each tagged values
            for (TaggedValue tag : elt.getTag()) {
                //good tagged value getting
                if (tag.getDefinition().getName().equals(tagtypeName)) {
                    // if the parameter number is one
                    if (tag.getDefinition().getParamNumber().equals("1")) {
                        if(tag.getActual().size() != 0) {
                            tag.getActual().get(0).setValue(value);
                        }
                        else {
                            tag.getActual().add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(value, tag));
                        }
                    }
                    //if the parameter number is multiple
                    else if (tag.getDefinition().getParamNumber().equals("*")) {
        
                        // string transformation to string tab
                        String[] tabValues = parseValuesToStringTab(value);
        
                        // array list for the news tag parameters
                        ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();
        
                        // old tag parameters deleting
                        for (TagParameter tp:tag.getActual()) {
                            tag.getActual().remove(tp);
                            tp.delete();
                        }
        
                        // new list creating
                        for (String s:tabValues) {
                            listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(s+" ", tag));
                        }
        
                        // new tag parameters adding
                        for (TagParameter tpl:listTagParam) {
                            tag.getActual().add(tpl);
                        }
                    }
                    else {
                        // else, the parameter number is another number, 2, 3 4 etc.
                        try {
                            int nbParam = Integer.parseInt(tag.getDefinition().getParamNumber());
        
                            // string transformation to string tab
                            String[] tabValues = parseValuesToStringTab(value);
        
                            /* if (tabValues.length > nbParam) {
                                //JOptionPane.showMessageDialog(null,  "You have too many parameter numbers, only "+tag.getDefinition().getParamNumber()+" has been set.", "Too many parameter numbers", JOptionPane.ERROR_MESSAGE);
                                //MessageDialog.openError(null, "Too many parameter numbers", "You have too many parameter numbers, only "+tag.getDefinition().getParamNumber()+" has been set.");
                                //MARTEFrame.marteShowMessageDialog(null, "Too many parameter numbers", "You have too many parameter numbers, only "+tag.getDefinition().getParamNumber()+" has been set.", JOptionPane.ERROR_MESSAGE);
                                MARTEFrame f = new MARTEFrame("You have to enter integers.");
                                f.show();
        
                            }*/
                            // array list for the news tag parameters
                            ArrayList<TagParameter> listTagParam = new ArrayList<TagParameter>();
        
                            // old tag parameters deleting
                            for (TagParameter tp:tag.getActual()) {
                                tag.getActual().remove(tp);
                                tp.delete();
                            }
        
                            // new list creating
                            for (int i = 0; i <tabValues.length;i++) {
                                if (i<nbParam) {
                                    listTagParam.add(CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTagParameter(tabValues[i]+" ", tag));
                                }
                            }
        
                            // new tag parameters adding
                            for (TagParameter tpl:listTagParam) {
                                tag.getActual().add(tpl);
                            }
        
                        }
                        catch (Exception e) {
                            JOptionPane.showMessageDialog(null, "Internal ERROR :\nThe parameter number is not a number.", "-- Internal Error --", JOptionPane.ERROR_MESSAGE);
                        }
        
                    }
                }
            }
        }
        else {
            
        }
    }

    /**
     * Allows a string tab creating. The string tab element has this form : parentName::elementName
     * @param listElement : the element list
     * @return a string tab
     */
    @objid ("b2373f7e-c6cb-43ee-8969-354271d51ac8")
    public static String[] createListString(final List<ModelElement> listElement) {
        List<String> listEltName = new ArrayList<String>();
        
        listEltName.add("");
        
        for (ModelElement elt: listElement) {
            listEltName.add(getCPSwarmName(elt));
        }
        
        Collections.sort(listEltName);
        String[] result = listEltName.toArray(new String[listEltName.size()]);
        return result;
    }

    /**
     * Returns the "CPSwarm" name
     * @param elt : the element
     * @return String : the marte name of the element.
     */
    @objid ("1bf0e048-da11-49ea-8659-d5cfa088ca39")
    public static String getCPSwarmName(final ModelElement elt) {
        String result = elt.getName();
        MObject owner = elt.getCompositionOwner();
        if (owner instanceof ModelElement){
            result = ((ModelElement) owner).getName() + namespacingSeparator + result;
        }
        return result;
    }

    /**
     * This method test if the SysML module is already deployed
     * @return true if the SysML module is deployed
     */
    @objid ("d14ab131-fdeb-4a7d-878b-b1e2124d3e66")
    public static boolean isSysMLDeployed() {
        return true;
    }

    /**
     * This method test if the MARTE module is already deployed
     * @return true if the MARTE module is deployed
     */
    @objid ("ae28d354-c74d-4379-9729-6fcbd287981e")
    public static boolean isMARTEDeployed() {
        return true;
    }

    /**
     * Method setTaggedValue
     * @author ebrosse
     * @param tvFound
     * @param elt
     * @param value
     * @param related
     * @param stereotypeLink @return
     */
    @objid ("0b34c93c-76cc-42f7-97dd-3ffd903d959d")
    public static void setTaggedValue(TaggedValue tvFound, ModelElement elt, String value, ModelElement related, String modulelink, String stereotypeLink) {
        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();
        
        for (Dependency existingLinks : new ArrayList<>(elt.getDependsOnDependency())) {
            if (existingLinks.isStereotyped(modulelink,stereotypeLink)) {
                existingLinks.delete();
            }
        }
        
        TagParameter firstElt = null;
        List<TagParameter> actuals = tvFound.getActual();
        if ((actuals != null) && (actuals.size() > 0)) {
            firstElt = actuals.get(0);
        } else {
            firstElt = model.createTagParameter();
            tvFound.getActual().add(firstElt);
        }
        
        if (value.equals("false")) {
            tvFound.delete();
        } else {
            firstElt.setValue(value);
            try {
                model.createDependency(elt, related,modulelink, stereotypeLink);
            } catch (Exception e) {
                CPSWarmModule.logService.error(e);
            }
        }
    }

    /**
     * Method addValue
     * @author ebrosse
     * @param name
     * @param value
     * @param element
     * @param related
     * @param stereotypeLink @return
     */
    @objid ("2e550c8b-36ec-40ac-9c7a-c22f8e19f516")
    public static void addValue(String modulename, String name, String value, ModelElement element, ModelElement related, String modulelink, String stereotypeLink) {
        // DON'T place Transition HERE
        
        boolean exist = false;
        
        TaggedValue tag = null;
        List<TaggedValue> tagElements = element.getTag();
        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();
        
        if (!tagElements.isEmpty()) {
            for (TaggedValue currentTag : tagElements) {
                TagType type = currentTag.getDefinition();
                String tagname = type.getName();
        
                if (tagname.equals(name)) {
                    exist = true;
                    tag = currentTag;
                    break;
        
                }
            }
        }
        
        if (!exist) {
            try {
                tag = model.createTaggedValue(modulename, name, element);
        
            } catch (Exception e) {
                CPSWarmModule.logService.error(e);
            }
        
        }
        
        setTaggedValue(tag, element, value, related,modulelink, stereotypeLink);
    }

    @objid ("7f16c153-7a5c-4f68-af78-a5c5e3a7bd2b")
    public static void addValue(String modulename, String name, String values, ModelElement element) {
        // DON'T place Transition HERE
        boolean exist = false;
        List<TaggedValue> tagElements = element.getTag();
        TaggedValue tvFound = null;
        
        // existing verification
        if (!tagElements.isEmpty()) {
            for (TaggedValue tag : tagElements) {
        
                TagType type = tag.getDefinition();
                String tagname = type.getName();
        
                if (tagname.equals(name)) {
                    exist = true;
                    // Modelio.out.println("tvFound FOUND");
                    tvFound = tag;
                }
            }
        }
        
        // if the tagged value doesn't exist yet, we create this
        if (!exist) {
            try {
                // Modelio.out.println("tvFound does not exist");
                TaggedValue v = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel().createTaggedValue(modulename, name, element);
                element.getTag().add(v);
                if (!v.getDefinition().getParamNumber().equals("0")) {
                    setTaggedValue(name, element, values);
                }
            } catch (Exception e) {
                CPSWarmModule.logService.error(e);
            }
        }
        // if the tagged value already exists
        else {
            if ((tvFound != null ) && (tvFound.getDefinition().getParamNumber().equals("0"))) {
                // Modelio.out.println("tvFound.getDefinition().getParamNumber().equals(0), the tv is deleted");
                tvFound.delete();
            } else {
                setTaggedValue(name, element, values);
            }
        }
    }

    @objid ("f6a4fdfd-ae3a-4f78-8506-965489d7889f")
    public static void setTaggedValue(String name, ModelElement elt, String value) {
        List<TaggedValue> tagElements = elt.getTag();
        IUmlModel model = CPSWarmModule.getInstance().getModuleContext().getModelingSession().getModel();
        
        if (!tagElements.isEmpty()) {
        
            for (TaggedValue tag : tagElements) {
                String tagname = tag.getDefinition().getName();
                if (tagname.equals(name)) {
        
                    TagParameter firstElt = null;
                    List<TagParameter> actuals = tag.getActual();
                    if ((actuals != null) && (actuals.size() > 0)) {
                        firstElt = actuals.get(0);
                    } else {
                        firstElt = model.createTagParameter();
                        tag.getActual().add(firstElt);
                    }
        
                    if (((value.equals("false")) && (tag.getDefinition().getParamNumber().equals("0")))
                            || ((value.equals("")) && (tag.getDefinition().getParamNumber().equals("1")))) {
                        tag.delete();
                    } else {
                        firstElt.setValue(value);
                    }
                }
            }
        }
    }

}
```


Overlapping Code:
```
public class ModelUtils {
@objid ("08d3e755-5c18-4e5d-be2b-7d70ebcac93d")
private static String namespacingSeparator = "::";
/**
* return the ModelElement target of the FIRST dependency stereotyped stereotypeName owned by source element
* @param source : the ModelElement which is the source of the dependency
* @param stereotypeName : the stereotype name applicable on Dependency Metaclass
* @return the ModelElement target of the first dependency
*/
@objid ("50592fea-05e0-4c0c-a045-16e588becc0a")
public static ModelElement getTarget(ModelElement source, String stereotypeName) {
for(Dependency dp: source.getDependsOnDependency()){
if(dp.isStereotyped(ICPSWarmPeerModule.MODULE_NAME, stereotypeName)){
ModelElement element = dp.getDependsOn();
if(element != null){
return element;
} 
}
}
return null;
}
/**
* This method returns the list of Classifier associated (sharing an Association) to the given Association
* @param center : the central association
* @return the list of associated Association
*/
@objid ("2c78105e-5dcc-4a94-b961-c29e71a4e341")
public static List<Classifier> getAssociatedClassifier(final Classifier center) {
List<Classifier> result = new ArrayList<Classifier>();

for (AssociationEnd feature : center.getOwnedEnd()){
AssociationEnd opposite = feature.getOpposite();
Classifier owner = opposite.getOwner();
if (!result.contains(owner))
result.add(owner);
}
return result;
}
/**
* This method test if the Analyst module is already deployed
* @return true if the Analyst module is deployed
*/
@objid ("e0511acc-2a34-4f62-9c84-079210755a79")
public static boolean isRequirementDeployed() {
return true;
}
/**
* Allows the tagged value getting
* @param tagtypeName : tagged value name
* @param element : owner element
* @return the tagged value values in a string form
*/
@objid ("8c279abb-09c3-4263-9934-d649ac41d04b")
public static String getTaggedValue(final String tagtypeName, final ModelElement element) {
for (TaggedVal
```
<Overlap Ratio: 0.956820412168793>

---

--- 78 --
Question ID: d1e9f855c4ac0a28d2aa075d4a0fe624ff98b5cb
Original Code:
```
@RestController
public class SpspController {

  private final Logger logger = LoggerFactory.getLogger(this.getClass());

  private final StreamReceiver streamReceiver;
  private final UrlPathHelper urlPathHelper;
  private final Supplier<SpspServerSettings> spspServerSettingsSupplier;

  public SpspController(
    final Supplier<SpspServerSettings> spspServerSettingsSupplier,
    final StreamReceiver streamReceiver
  ) {
    this.streamReceiver = Objects.requireNonNull(streamReceiver);
    this.spspServerSettingsSupplier = spspServerSettingsSupplier;
    this.urlPathHelper = new UrlPathHelper();
  }

  /**
   * A simple SPSP endpoint that merely returns a new Shared Secret and destination address to support a stateless
   * receiver.
   *
   * @param accountId The SPSP path, as a {@link String}.
   *
   * @return
   */
  @RequestMapping(
    path = "/{account_id}/**", method = RequestMethod.GET,
    produces = {"application/spsp4+json", APPLICATION_JSON_VALUE, MediaTypes.PROBLEM_VALUE}
  )
  public ResponseEntity<StreamConnectionDetails> getSpspResponse(
    @PathVariable("account_id") final String accountId,
    final HttpServletRequest servletRequest
  ) {
    Objects.requireNonNull(accountId);

    String paymentTarget = this.urlPathHelper.getPathWithinApplication(servletRequest).replaceAll("/", ".");
    if (paymentTarget.startsWith(".")) {
      paymentTarget = paymentTarget.replaceFirst(".", "");
    }
    if (paymentTarget.endsWith(".")) {
      paymentTarget = paymentTarget.substring(0, paymentTarget.length() - 1);
    }

    final InterledgerAddress paymentReceiverAddress = spspServerSettingsSupplier.get().operatorAddress()
      .with(paymentTarget);

    final StreamConnectionDetails connectionDetails = streamReceiver.setupStream(paymentReceiverAddress);
    final org.interledger.spsp.server.model.StreamConnectionDetails returnableStreamConnectionDetails =
      org.interledger.spsp.server.model.StreamConnectionDetails.builder()
        .destinationAddress(connectionDetails.destinationAddress())
        .sharedSecretBase64(Base64.getEncoder().encodeToString(connectionDetails.sharedSecret().key()))
        .build();
    final HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_JSON);

    // TODO: Add client-cache directive per RFC (i.e., configurable max-age).
    return new ResponseEntity(returnableStreamConnectionDetails, headers, HttpStatus.OK);
  }
}
```


Overlapping Code:
```
stController
public class SpspController {
private final Logger logger = LoggerFactory.getLogger(this.getClass());
private final StreamReceiver streamReceiver;
private final UrlPathHelper urlPathHelper;
private final Supplier<SpspServerSettings> spspServerSettingsSupplier;
public SpspController(
final Supplier<SpspServerSettings> spspServerSettingsSupplier,
final StreamReceiver streamReceiver
) {
this.streamReceiver = Objects.requireNonNull(streamReceiver);
this.spspServerSettingsSupplier = spspServerSettingsSupplier;
this.urlPathHelper = new UrlPathHelper();
}
/**
* A simple SPSP endpoint that merely returns a new Shared Secret and destination address to support a stateless
* receiver.
*
* @param accountId The SPSP path, as a {@link String}.
*
* @return
*/
@RequestMapping(
path = "/{account_id}/**", method = RequestMethod.GET,
produces = {"application/spsp4+json", APPLICATION_JSON_VALUE, MediaTypes.PROBLEM_VALUE}
)
public ResponseEntity<StreamConnectionDetails> getSpspResponse(
@PathVariable("account_id") final String accountId,
final HttpServletRequest servletRequest
) {
Objects.requireNonNull(accountId);
String paymentTarget = this.urlPathHelper.getPathWithinApplication(servletRequest).replaceAll("/", ".");
if (paymentTarget.startsWith(".")) {
paymentTarget = paymentTarget.replaceFirst(".", "");
}
if (paymentTarget.endsWith(".")) {
paymentTarget = paymentTarget.substring(0, paymentTarget.length() - 1);
}
final InterledgerAddress paymentReceiverAddress = spspServerSettingsSupplier.get().operatorAddress()
.with(paymentTarget);
final StreamConnectionDetails connectionDetails = streamReceiver.setupStream(paymentReceiverAddress);
final org.interledger.spsp.server.model.StreamConnectionDetails returnableStreamConnectionDetails =
org.interledger.spsp.server.model.StreamConnectionDetails.builder()
.destinationAddress(connectionDetails.destinationAddress())
.sharedSecretBase64(Base64.getEncoder().encodeToString(connectionDetails.sharedSecret().key()))
.build();
final HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
// TODO: Add client-cache directive per RFC (i.e., configurable max-age).
return new ResponseEntity(returnableStreamConnectionDetails, headers, HttpStatus.OK);
}
```
<Overlap Ratio: 0.9977827050997783>

---

--- 79 --
Question ID: aac22348abb6d23324c9d7af227e04e2519dcb68
Original Code:
```
public class StatsResponseTests extends AbstractResponseTestCase<EnrichStatsAction.Response, StatsResponse> {

    @Override
    protected EnrichStatsAction.Response createServerTestInstance(XContentType xContentType) {
        int numExecutingPolicies = randomIntBetween(0, 16);
        List<EnrichStatsAction.Response.ExecutingPolicy> executingPolicies = new ArrayList<>(numExecutingPolicies);
        for (int i = 0; i < numExecutingPolicies; i++) {
            TaskInfo taskInfo = randomTaskInfo();
            executingPolicies.add(new EnrichStatsAction.Response.ExecutingPolicy(randomAlphaOfLength(4), taskInfo));
        }
        int numCoordinatingStats = randomIntBetween(0, 16);
        List<EnrichStatsAction.Response.CoordinatorStats> coordinatorStats = new ArrayList<>(numCoordinatingStats);
        for (int i = 0; i < numCoordinatingStats; i++) {
            EnrichStatsAction.Response.CoordinatorStats stats = new EnrichStatsAction.Response.CoordinatorStats(
                randomAlphaOfLength(4), randomIntBetween(0, 8096), randomIntBetween(0, 8096), randomNonNegativeLong(),
                randomNonNegativeLong());
            coordinatorStats.add(stats);
        }
        return new EnrichStatsAction.Response(executingPolicies, coordinatorStats);
    }

    @Override
    protected StatsResponse doParseToClientInstance(XContentParser parser) throws IOException {
        return StatsResponse.fromXContent(parser);
    }

    @Override
    protected void assertInstances(EnrichStatsAction.Response serverTestInstance, StatsResponse clientInstance) {
        assertThat(clientInstance.getExecutingPolicies().size(), equalTo(serverTestInstance.getExecutingPolicies().size()));
        for (int i = 0; i < clientInstance.getExecutingPolicies().size(); i++) {
            StatsResponse.ExecutingPolicy actual = clientInstance.getExecutingPolicies().get(i);
            EnrichStatsAction.Response.ExecutingPolicy expected = serverTestInstance.getExecutingPolicies().get(i);
            assertThat(actual.getName(), equalTo(expected.getName()));
            assertThat(actual.getTaskInfo(), equalTo(actual.getTaskInfo()));
        }

        assertThat(clientInstance.getCoordinatorStats().size(), equalTo(serverTestInstance.getCoordinatorStats().size()));
        for (int i = 0; i < clientInstance.getCoordinatorStats().size(); i++) {
            StatsResponse.CoordinatorStats actual = clientInstance.getCoordinatorStats().get(i);
            EnrichStatsAction.Response.CoordinatorStats expected = serverTestInstance.getCoordinatorStats().get(i);
            assertThat(actual.getNodeId(), equalTo(expected.getNodeId()));
            assertThat(actual.getQueueSize(), equalTo(expected.getQueueSize()));
            assertThat(actual.getRemoteRequestsCurrent(), equalTo(expected.getRemoteRequestsCurrent()));
            assertThat(actual.getRemoteRequestsTotal(), equalTo(expected.getRemoteRequestsTotal()));
            assertThat(actual.getExecutedSearchesTotal(), equalTo(expected.getExecutedSearchesTotal()));
        }
    }

    private static TaskInfo randomTaskInfo() {
        TaskId taskId = new TaskId(randomAlphaOfLength(5), randomLong());
        String type = randomAlphaOfLength(5);
        String action = randomAlphaOfLength(5);
        String description = randomAlphaOfLength(5);
        long startTime = randomLong();
        long runningTimeNanos = randomLong();
        boolean cancellable = randomBoolean();
        TaskId parentTaskId = TaskId.EMPTY_TASK_ID;
        Map<String, String> headers = randomBoolean() ?
            Collections.emptyMap() :
            Collections.singletonMap(randomAlphaOfLength(5), randomAlphaOfLength(5));
        return new TaskInfo(taskId, type, action, description, null, startTime, runningTimeNanos, cancellable, parentTaskId, headers);
    }
}
```


Overlapping Code:
```
s extends AbstractResponseTestCase<EnrichStatsAction.Response, StatsResponse> {
@Override
protected EnrichStatsAction.Response createServerTestInstance(XContentType xContentType) {
int numExecutingPolicies = randomIntBetween(0, 16);
List<EnrichStatsAction.Response.ExecutingPolicy> executingPolicies = new ArrayList<>(numExecutingPolicies);
for (int i = 0; i < numExecutingPolicies; i++) {
TaskInfo taskInfo = randomTaskInfo();
executingPolicies.add(new EnrichStatsAction.Response.ExecutingPolicy(randomAlphaOfLength(4), taskInfo));
}
int numCoordinatingStats = randomIntBetween(0, 16);
List<EnrichStatsAction.Response.CoordinatorStats> coordinatorStats = new ArrayList<>(numCoordinatingStats);
for (int i = 0; i < numCoordinatingStats; i++) {
EnrichStatsAction.Response.CoordinatorStats stats = new EnrichStatsAction.Response.CoordinatorStats(
randomAlphaOfLength(4), randomIntBetween(0, 8096), randomIntBetween(0, 8096), randomNonNegativeLong(),
randomNonNegativeLong());
coordinatorStats.add(stats);
}
return new EnrichStatsAction.Response(executingPolicies, coordinatorStats);
}
@Override
protected StatsResponse doParseToClientInstance(XContentParser parser) throws IOException {
return StatsResponse.fromXContent(parser);
}
@Override
protected void assertInstances(EnrichStatsAction.Response serverTestInstance, StatsResponse clientInstance) {
assertThat(clientInstance.getExecutingPolicies().size(), equalTo(serverTestInstance.getExecutingPolicies().size()));
for (int i = 0; i < clientInstance.getExecutingPolicies().size(); i++) {
StatsResponse.ExecutingPolicy actual = clientInstance.getExecutingPolicies().get(i);
EnrichStatsAction.Response.ExecutingPolicy expected = serverTestInstance.getExecutingPolicies().get(i);
assertThat(actual.getName(), equalTo(expected.getName()));
assertThat(actual.getTaskInfo(), equalTo(actual.getTaskInfo()));
}
assertThat(clientInstance.getCoordinatorStats().size(), equalTo(serverTestInstance.getCoordinatorStats().size()));
for (int i = 0; i < clientInstance.getCoordinatorStats().size(); i++) {
StatsResponse.CoordinatorStats actual = clientInstance.getCoordinatorStats().get(i);
EnrichStatsAction.R
```
<Overlap Ratio: 0.9794614331355546>

---

--- 80 --
Question ID: 390356aa4960b6206cf134619915b00af46b2a7b
Original Code:
```
public class TroveIntObjTest implements IntTestSet {
    @Override
    public IntMapTest putAndUpdateTest() {
        return new TroveIntObjPutAndUpdateTest();
    }

    @Override
    public IntMapTest twoPutOneRemoveTest() {
        return new TroveIntObjTwoPutOneRemoveTest();
    }

    @Override
    public IntMapTest getTest() {
        return new TroveIntObjGetTest();
    }

    @Override
    public IntMapTest putTest() {
        return new TroveIntObjPutTest();
    }

    @Override
    public IntMapTest removeTest() {
        return new TroveIntObjRemoveTest();
    }

    @Override
    public IntMapTest mergeTest() {
        return new TroveIntObjMergeTest();
    }

    private static class TroveIntObjGetTest extends AbstractIntObjGetTest {

        private TIntObjectHashMap<Integer> m_map;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);
            for (int i = 0; i < keys.length; ++i) {
                if (i % oneFailureOutOf != 0) m_map.put(keys[i], new Integer(keys[i]));
            }
        }

        @Override
        public int test() {
            int res = 0;
            for (int i = 0; i < m_keys.length; ++i)
                if (m_map.get(m_keys[i]) != null) res += 1;
            return res;
        }

    }

    private static class TroveIntObjPutTest extends AbstractIntObjPutTest {
        private TIntObjectHashMap<Integer> m_map;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);
        }

        @Override
        public int test() {
            for (int j = 0; j < m_keys.length; j++) {
                m_map.put(m_keys[j], new Integer(j));
            }
            return m_map.size();
        }

    }

    private static class TroveIntObjPutAndUpdateTest extends AbstractIntObjPutTest {
        private TIntObjectHashMap<Integer> m_map;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);
        }

        @Override
        public int test() {
            for (int j = 0; j < m_keys.length; j++) {
                m_map.put(m_keys[j], new Integer(j));
            }
            for (int i = 0; i < m_keys2.length; i++) {
                m_map.put(m_keys2[i], new Integer(i));
            }
            return m_map.size();
        }

    }

    private static class TroveIntObjRemoveTest extends AbstractIntObjGetTest {
        private TIntObjectHashMap<Integer> m_map;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);
            for (int j = 0; j < keys.length; j++) {
                m_map.put(keys[j], new Integer(keys[j]));
            }
        }

        @Override
        public int test() {
            for (int i = 0; i < m_keys.length; i++) {
                m_map.remove(m_keys[i]);
            }
            return m_map.size();
        }

    }
    private static class TroveIntObjTwoPutOneRemoveTest extends AbstractIntObjGetTest {
        private TIntObjectHashMap<Integer> m_map;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<>(keys.length, fillFactor);
        }

        @Override
        public int test() {

            int add = 0, remove = 0;
            while (add < m_keys.length) {
                m_map.put(m_keys[add], new Integer(add));
                ++add;
                m_map.put(m_keys[add], new Integer(add));
                ++add;
                m_map.remove(m_keys[remove++]);
            }
            return m_map.size();
        }

    }

    private static class TroveIntObjMergeTest extends AbstractIntObjMergeTest {
        private TIntObjectHashMap<Integer> m_map;
        private TIntObjectHashMap<Integer> m_map2;

        @Override
        public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
            super.setup(keys, fillFactor, oneFailureOutOf);
            m_map = new TIntObjectHashMap<Integer>(keys.length / 2, fillFactor);
            for (int key : m_keys) m_map.put(key, new Integer(key));
            m_map2 = new TIntObjectHashMap<Integer>(keys.length, fillFactor);
            for (int key : m_keys2) m_map2.put(key, new Integer(key));
        }

        @Override
        public int test() {
            m_map2.forEachEntry((key, val) -> {
                if (m_map.containsKey(key)) {
                    m_map.put(key, m_map.get(key) + val);
                } else m_map.put(key, val);

                return true;
            });


            return m_map.size();
        }
    }
}
```


Overlapping Code:
```
public class TroveIntObjTest implements IntTestSet {
@Override
public IntMapTest putAndUpdateTest() {
return new TroveIntObjPutAndUpdateTest();
}
@Override
public IntMapTest twoPutOneRemoveTest() {
return new TroveIntObjTwoPutOneRemoveTest();
}
@Override
public IntMapTest getTest() {
return new TroveIntObjGetTest();
}
@Override
public IntMapTest putTest() {
return new TroveIntObjPutTest();
}
@Override
public IntMapTest removeTest() {
return new TroveIntObjRemoveTest();
}
@Override
public IntMapTest mergeTest() {
return new TroveIntObjMergeTest();
}
private static class TroveIntObjGetTest extends AbstractIntObjGetTest {
private TIntObjectHashMap<Integer> m_map;
@Override
public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
super.setup(keys, fillFactor, oneFailureOutOf);
m_map = new TIntObjectHashMap<>(keys.length, fillFactor);
for (int i = 0; i < keys.length; ++i) {
if (i % oneFailureOutOf != 0) m_map.put(keys[i], new Integer(keys[i]));
}
}
@Override
public int test() {
int res = 0;
for (int i = 0; i < m_keys.length; ++i)
if (m_map.get(m_keys[i]) != null) res += 1;
return res;
}
}
private static class TroveIntObjPutTest extends AbstractIntObjPutTest {
private TIntObjectHashMap<Integer> m_map;
@Override
public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
super.setup(keys, fillFactor, oneFailureOutOf);
m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);
}
@Override
public int test() {
for (int j = 0; j < m_keys.length; j++) {
m_map.put(m_keys[j], new Integer(j));
}
return m_map.size();
}
}
private static class TroveIntObjPutAndUpdateTest extends AbstractIntObjPutTest {
private TIntObjectHashMap<Integer> m_map;
@Override
public void setup(int[] keys, float fillFactor, int oneFailureOutOf) {
super.setup(keys, fillFactor, oneFailureOutOf);
m_map = new TIntObjectHashMap<Integer>(keys.length, fillFactor);
}
@Override
public int test() {
for (int j = 0; j < m_keys.length; j++)
```
<Overlap Ratio: 0.9989754098360656>

---

--- 81 --
Question ID: 24e91e53b67578b1d1aacc2692fe7f6579bc9237
Original Code:
```
public class FeaturePosting implements IFeaturePosting {
	protected String postingFileName;
	protected RandomAccessFile postingFile;

	public FeaturePosting(String postingFileName) {
		this.postingFileName = postingFileName;
		if (postingFileName != null)
			try {
				this.postingFile = new RandomAccessFile(this.postingFileName,
						"r");
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
	}

	public RandomAccessFile getPostingFile() {
		return this.postingFile;
	}

	public String getPostingFileName() {
		return this.postingFileName;
	}

	@Override
	public int[] getPosting(long postingShift) {
		String results = null;
		String[] tokens;
		if (this.postingFile == null)
			try {
				this.postingFile = new RandomAccessFile(this.postingFileName,
						"r");
			} catch (FileNotFoundException e1) {
				e1.printStackTrace();
			}
		try {
			this.postingFile.seek(postingShift);
			results = this.postingFile.readLine();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
		tokens = results.split(",");
		int[] posting = new int[tokens.length - 1];
		for (int i = 0; i < tokens.length - 1; i++)
			posting[i] = Integer.parseInt(tokens[i + 1]);
		return posting;
	}

	protected String getPostingString(long postingShift) {
		String results = null;
		if (this.postingFile == null)
			try {
				this.postingFile = new RandomAccessFile(this.postingFileName,
						"r");
			} catch (FileNotFoundException e1) {
				e1.printStackTrace();
			}
		try {
			this.postingFile.seek(postingShift);
			results = this.postingFile.readLine();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
		return results;
	}

	/**
	 * Read the postings starting from the "featureShift", rewrite it to the
	 * postingChannel and return the new shift.
	 * 
	 * @param postingChannel
	 * @param featureShift
	 * @param featureID
	 * @return
	 */
	public long savePostings(FileChannel postingChannel, long featureShift,
			int featureID) {
		ByteBuffer postbbuf = ByteBuffer.allocate(1024);
		long shift = -1;
		try {
			shift = postingChannel.position();
		} catch (IOException e) {
			e.printStackTrace();
		}
		String postingString = this.getPostingString(featureShift);
		byte[] bytes = null;
		// Change ID if necessary
		int index = postingString.indexOf(",");
		bytes = (featureID + postingString.substring(index) + '\n').getBytes();
		// Starting writing the postings
		int start = 0;
		int length = postbbuf.capacity();
		while (start < bytes.length) {
			if (start + length <= bytes.length)
				postbbuf.put(bytes, start, length);
			else
				postbbuf.put(bytes, start, bytes.length - start);
			postbbuf.flip();
			try {
				postingChannel.write(postbbuf);
			} catch (IOException e) {
				e.printStackTrace();
			}
			postbbuf.clear();
			start = start + length;
		}
		return shift;
	}
	
	/**
	 * Write the postings to the ostingChannel and return the new shift.
	 * 
	 * @param postingChannel
	 * @param featureShift
	 * @param featureID
	 * @return
	 */
	public static long savePostings(FileChannel postingChannel, int[] postings,
			int featureID) throws IOException {
		Arrays.sort(postings);
		StringBuffer postingBuffer = new StringBuffer(200);
		ByteBuffer bbuf = ByteBuffer.allocate(1024);
		postingBuffer.append(featureID);

		for (int i = 0; i < postings.length; i++) {
			postingBuffer.append(',');
			postingBuffer.append(postings[i]);
		}
		postingBuffer.append('\n');
		byte[] bytes = postingBuffer.toString().getBytes();
		long shift = postingChannel.position();
		int start = 0;
		int length = bbuf.capacity();
		while (start < bytes.length) {
			if (start + length <= bytes.length)
				bbuf.put(bytes, start, length);
			else
				bbuf.put(bytes, start, bytes.length - start);
			bbuf.flip();
			postingChannel.write(bbuf);
			bbuf.clear();
			start = start + length;
		}
		return shift;
	}
}
```


Overlapping Code:
```
osting {
protected String postingFileName;
protected RandomAccessFile postingFile;
public FeaturePosting(String postingFileName) {
this.postingFileName = postingFileName;
if (postingFileName != null)
try {
this.postingFile = new RandomAccessFile(this.postingFileName,
"r");
} catch (FileNotFoundException e) {
e.printStackTrace();
}
}
public RandomAccessFile getPostingFile() {
return this.postingFile;
}
public String getPostingFileName() {
return this.postingFileName;
}
@Override
public int[] getPosting(long postingShift) {
String results = null;
String[] tokens;
if (this.postingFile == null)
try {
this.postingFile = new RandomAccessFile(this.postingFileName,
"r");
} catch (FileNotFoundException e1) {
e1.printStackTrace();
}
try {
this.postingFile.seek(postingShift);
results = this.postingFile.readLine();
} catch (IOException e) {
e.printStackTrace();
return null;
}
tokens = results.split(",");
int[] posting = new int[tokens.length - 1];
for (int i = 0; i < tokens.length - 1; i++)
posting[i] = Integer.parseInt(tokens[i + 1]);
return posting;
}
protected String getPostingString(long postingShift) {
String results = null;
if (this.postingFile == null)
try {
this.postingFile = new RandomAccessFile(this.postingFileName,
"r");
} catch (FileNotFoundException e1) {
e1.printStackTrace();
}
try {
this.postingFile.seek(postingShift);
results = this.postingFile.readLine();
} catch (IOException e) {
e.printStackTrace();
return null;
}
return results;
}
/**
* Read the postings starting from the "featureShift", rewrite it to the
* postingChannel and return the new shift.
* 
* @param postingChannel
* @param featureShift
* @param featureID
* @return
*/
public long savePostings(FileChannel postingChannel, long featureShift,
int featureID) {
ByteBuffer postbbuf = ByteBuffer.allocate(1024);
long shift = -1;
try {
shift = postingChannel.position();
} catch (IOException e) {
e.printStackTrace();
}
String postingString = this.getPostingString(featureShift);
byte[] bytes = null;
// Change ID if necessary
int index = postingString.indexOf(",");
bytes = (featureID + postingString.substring(index) + '\n').getBytes();
// Starting writing the postings
int start = 0;
int length = postbbuf.cap
```
<Overlap Ratio: 0.9619588981198076>

---

--- 82 --
Question ID: f72d87085fc29ac63c2ef8523592889a464a5b1d
Original Code:
```
public class VMDCollisionTest {

    private static final Image IMAGE_LIST = ImageUtilities.loadImage("test/resources/list_32.png"); // NOI18N
    private static final Image IMAGE_CANVAS = ImageUtilities.loadImage("test/resources/custom_displayable_32.png"); // NOI18N
    private static final Image IMAGE_COMMAND = ImageUtilities.loadImage("test/resources/command_16.png"); // NOI18N
    private static final Image IMAGE_ITEM = ImageUtilities.loadImage("test/resources/item_16.png"); // NOI18N
    private static final Image GLYPH_PRE_CODE = ImageUtilities.loadImage("test/resources/preCodeGlyph.png"); // NOI18N
    private static final Image GLYPH_POST_CODE = ImageUtilities.loadImage("test/resources/postCodeGlyph.png"); // NOI18N
    private static final Image GLYPH_CANCEL = ImageUtilities.loadImage("test/resources/cancelGlyph.png"); // NOI18N

    private static int nodeID = 1;
    private static int edgeID = 1;

    public static void main (String[] args) {
        VMDGraphScene scene = new VMDGraphScene ();

        String mobile = VMDTest.createNode (scene, 100, 100, IMAGE_LIST, "menu", "List", null);
        VMDTest.createPin (scene, mobile, "start", IMAGE_ITEM, "Start", "Element");

        String game = VMDTest.createNode (scene, 600, 100, IMAGE_CANVAS, "gameCanvas", "MyCanvas", Arrays.asList (GLYPH_PRE_CODE, GLYPH_CANCEL, GLYPH_POST_CODE));
        VMDTest.createPin (scene, game, "ok", IMAGE_COMMAND, "okCommand1", "Command");

        VMDTest.createEdge (scene, "start", game);
        VMDTest.createEdge (scene, "ok", mobile);

        SceneSupport.show (scene);
    }

}
```


Overlapping Code:
```
c final Image IMAGE_LIST = ImageUtilities.loadImage("test/resources/list_32.png"); // NOI18N
private static final Image IMAGE_CANVAS = ImageUtilities.loadImage("test/resources/custom_displayable_32.png"); // NOI18N
private static final Image IMAGE_COMMAND = ImageUtilities.loadImage("test/resources/command_16.png"); // NOI18N
private static final Image IMAGE_ITEM = ImageUtilities.loadImage("test/resources/item_16.png"); // NOI18N
private static final Image GLYPH_PRE_CODE = ImageUtilities.loadImage("test/resources/preCodeGlyph.png"); // NOI18N
private static final Image GLYPH_POST_CODE = ImageUtilities.loadImage("test/resources/postCodeGlyph.png"); // NOI18N
private static final Image GLYPH_CANCEL = ImageUtilities.loadImage("test/resources/cancelGlyph.png"); // NOI18N
private static int nodeID = 1;
private static int edgeID = 1;
public static void main (String[] args) {
VMDGraphScene scene = new VMDGraphScene ();
String mobile = VMDTest.createNode (scene, 100, 100, IMAGE_LIST, "menu", "List", null);
VMDTest.createPin (scene, mobile, "start", IMAGE_ITEM, "Start", "Element");
String game = VMDTest.createNode (scene, 600, 100, IMAGE_CANVAS, "gameCanvas", "MyCanvas", Arrays.asList (GLYPH_PRE_CODE, GLYPH_CANCEL, GLYPH_POST_CODE));
VMDTest.createPin (scene, game, "ok", IMAGE_COMMAND, "okCommand1", "Command");
VMDTest.createEdge (scene, "start", game);
VMDTest.createEdge (scene, "ok", m
```
<Overlap Ratio: 0.9440323668240054>

---

--- 83 --
Question ID: 4bc1396e911ee7edf5f6bfb4bc60babb60fcd53d
Original Code:
```
public class SingletonTest {

    @Test
    public void testIODH() {
        IDGenerator generator1 = IDGenerator.get();
        IDGenerator generator2 = IDGenerator.get();
        assertThat(generator1).isSameAs(generator2);
    }
}
```


Overlapping Code:
```
void testIODH() {
IDGenerator generator1 = IDGenerator.get();
IDGenerator generator2 = IDGenerator.get();
assertThat(generator1).isSameAs(generator2);
```
<Overlap Ratio: 0.7653061224489796>

---

--- 84 --
Question ID: 20b41f9c57389d10ff16393c30505513d995ad2c
Original Code:
```
public class OverlayHelpTreeTest {

	@Test
    public void testSourceTOCFileThatDependsUponPreBuiltHelp() {
		//
		// We want to make sure the overlay tree will properly resolve help TOC items being 
		// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined
		// in a help <TOCITEM> that lives inside of a pre-built jar file.
		//
		/*
		 
		 	Example makeup we will create:
		 
			  	PreBuild_TOC.xml
			  	
			  		<tocitem id="root" target="fake">
			  			<tocitem id="child_1" target="fake" />
			  		</tocitem>
			 
			 
			 	TOC_Source.xml 
			 	
			 		<tocref id="root">
			 			<tocref="child_1">
			 				<tocdef id="child_2" target="fake" />
			 			</tocref>
			 		</tocref>
		  
		 */

		TOCItemExternal root = externalItem("root");
		TOCItemExternal child_1 = externalItem(root, "child_1");

		Path tocSourceFile = Paths.get("/fake/path_2/TOC_Source.xml");
		String root_ID = root.getIDAttribute();
		TOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);

		String child_1_ID = child_1.getIDAttribute();
		TOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);

		TOCItemDefinition child_2 = definitionItem(child_1_ref, "child_2", tocSourceFile);

		TOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();
		tocProvider.addExternal(root);
		tocProvider.addExternal(child_1);
		tocProvider.addDefinition(child_2);

		TOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);

		assertNodeCount(spy, 3);
		assertOrder(spy, 1, root);
		assertOrder(spy, 2, child_1);
		assertOrder(spy, 3, child_2);
	}

	@Test
    public void testSourceTOCFileThatDependsUponPreBuiltHelp_MultiplePreBuiltInputs() {
		//
		// We want to make sure the overlay tree will properly resolve help TOC items being 
		// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined
		// in a help <TOCITEM> that lives inside of multiple pre-built jar files.
		//
		/*
		 
		 	Example makeup we will create:
		 
			  	PreBuild_TOC.xml
			  	
			  		<tocitem id="root" target="fake">
			  			<tocitem id="child_1" target="fake">
			  				<tocitem="prebuilt_a_child" target="fake" />
			  			</tocitem>
			  		</tocitem>
			 
				Another PreBuild_TOC.xml
			  	
			  		<tocitem id="root" target="fake">
			  			<tocitem id="child_1" target="fake">
			  				<tocitem="prebuilt_b_child" target="fake" />
			  			</tocitem>
			  		</tocitem>
			 
			 
			 	TOC_Source.xml 
			 	
			 		<tocref id="root">
			 			<tocref="child_1">
			 				<tocdef id="child_2" target="fake" />
			 			</tocref>
			 		</tocref>
		  
		 */

		TOCItemExternal root_a = externalItem("root");
		TOCItemExternal child_1_a = externalItem(root_a, "child_1");
		TOCItemExternal prebuilt_a_child = externalItem(child_1_a, "prebuilt_a_child");

		// note: same ID values, since they represent the same nodes, but from different TOC files
		TOCItemExternal root_b = externalItemAlt(null, "root");
		TOCItemExternal child_1_b = externalItemAlt(root_b, "child_1");
		TOCItemExternal prebuilt_b_child = externalItemAlt(child_1_b, "prebuilt_b_child");

		Path tocSourceFile = Paths.get("/fake/path_2/TOC_Source.xml");
		String root_ID = root_a.getIDAttribute();
		TOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);

		String child_1_ID = child_1_a.getIDAttribute();
		TOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);

		TOCItemDefinition child_2 = definitionItem(child_1_ref, "child_2", tocSourceFile);

		TOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();
		tocProvider.addExternal(root_a);
		tocProvider.addExternal(root_b);
		tocProvider.addExternal(child_1_a);
		tocProvider.addExternal(child_1_b);
		tocProvider.addExternal(prebuilt_a_child);
		tocProvider.addExternal(prebuilt_b_child);
		tocProvider.addDefinition(child_2);

		TOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);

		assertNodeCount(spy, 3);
		assertOrder(spy, 1, root_a);// could also be root_b, same ID
		assertOrder(spy, 2, child_1_a);// could also be child_1_b, same ID
		assertOrder(spy, 3, child_2);

		// note: prebuilt_a_child and prebuilt_b_child don't get output, since they do not have 
		//       the same TOC file ID as the help file being processed (in other words, they don't
		//       live in the TOC_Source.xml being processes, so they are not part of the output).
	}

	@Test
    public void testSourceTOCFileThatDependsAnotherTOCSourceFile() {

		/*
		 
		 The first source file defines attributes that the second file references.
		 
		 Example makeup we will create:
		
		  	TOC_Source.xml
		  	
		  		<tocdef id="root" target="fake">
		  			<tocdef id="child_1" target="fake" />
		  		</tocdef>
		 
		 
		 	Another TOC_Source.xml 
		 	
		 		<tocref id="root">
		 			<tocref="child_1">
		 				<tocdef id="child_2" target="fake" />
		 			</tocref>
		 		</tocref>
		
		*/

		Path toc_1 = Paths.get("/fake/path_1/TOC_Source.xml");
		TOCItemDefinition root = definitionItem("root", toc_1);
		TOCItemDefinition child_1 = definitionItem(root, "child_1", toc_1);

		Path toc_2 = Paths.get("/fake/path_2/TOC_Source.xml");
		String root_ID = root.getIDAttribute();
		String child_1_ID = child_1.getIDAttribute();

		TOCItemReference root_ref = referenceItem(root_ID, toc_2);
		TOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, toc_2);
		TOCItemDefinition child_2 = definitionItem(child_1_ref, "child_2", toc_2);

		TOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();
		tocProvider.addDefinition(root);
		tocProvider.addDefinition(child_1);
		tocProvider.addDefinition(child_2);// in the second TOC file

		TOCSpyWriter spy = printOverlayTree(tocProvider, toc_2);

		assertNodeCount(spy, 3);
		assertOrder(spy, 1, root);
		assertOrder(spy, 2, child_1);
		assertOrder(spy, 3, child_2);
	}

//==================================================================================================
// Inner Classes
//==================================================================================================

	private TOCSpyWriter printOverlayTree(TOCItemProviderTestStub tocItemProvider, Path tocFile) {

		//
		// Create a test version of the LinkDatabase for the overlay tree, with test versions of
		// it's required TOC input file and HelpModuleLocation
		// 
		GhidraTOCFileDummy toc = new GhidraTOCFileDummy(tocFile);
		OverlayHelpModuleLocationTestStub location = new OverlayHelpModuleLocationTestStub(toc);
		LinkDatabaseTestStub db = new LinkDatabaseTestStub(location);

		// This is the class we are testing!!
		OverlayHelpTree overlayHelpTree = new OverlayHelpTree(tocItemProvider, db);

		TOCSpyWriter spy = new TOCSpyWriter();
		String TOCID = tocFile.toUri().toString();
		overlayHelpTree.printTreeForID(spy, TOCID);

		System.out.println(spy.toString());

		return spy;
	}

	private TOCItemDefinition definitionItem(String ID, Path tocSourceFile) {
		return definitionItem(null, ID, tocSourceFile);
	}

	private TOCItemDefinition definitionItem(TOCItem parent, String ID, Path tocSourceFile) {
		String target = "fake";
		String sort = "";
		int line = 1;
		return new TOCItemDefinition(parent, tocSourceFile, ID, ID, target, sort, line);
	}

	private TOCItemReference referenceItem(String referenceID, Path tocSourceFile) {
		return referenceItem(null, referenceID, tocSourceFile);
	}

	private TOCItemReference referenceItem(TOCItem parent, String referenceID, Path tocSourceFile) {
		return new TOCItemReference(parent, tocSourceFile, referenceID, 1);
	}

	private TOCItemExternal externalItem(String ID) {
		return externalItem(null, ID);
	}

	private TOCItemExternal externalItem(TOCItem parent, String ID) {
		Path tocFile = Paths.get("/fake/path_1/PreBuild_TOC.xml");
		String target = "fake";
		String sort = "";
		int line = 1;
		return new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);
	}

	private TOCItemExternal externalItemAlt(TOCItem parent, String ID) {
		Path tocFile = Paths.get("/fake/path_1/PreBuild_TOC.xml");
		String target = "fake";
		String sort = "";
		int line = 1;
		return new TOCItemExternal(parent, tocFile, ID, ID, target, sort, line);
	}

	private void assertOrder(TOCSpyWriter spy, int ordinal, TOCItem item) {
		String ID = spy.getItem(ordinal - 1 /* make an index */);
		assertEquals("Did not find TOC item at expected index: " + ordinal, item.getIDAttribute(),
			ID);
	}

	private void assertNodeCount(TOCSpyWriter spy, int count) {
		assertEquals("Did not get exactly one node per TOC item input", count, spy.getItemCount());
	}

	private class TOCSpyWriter extends PrintWriter {

		private StringWriter stringWriter;

		private List<String> tocItems = new ArrayList<>();

		public TOCSpyWriter() {
			super(new StringWriter(), true);
			stringWriter = ((StringWriter) out);
		}

		String getItem(int position) {
			return tocItems.get(position);
		}

		int getItemCount() {
			return tocItems.size();
		}

		@Override
		public void println(String s) {
			super.println(s);

			s = s.trim();
			if (!s.startsWith("<tocitem")) {
				return;
			}

			storeDisplayAttribute(s);
		}

		private void storeDisplayAttribute(String s) {
			// create a pattern to pull out the display string
			Pattern p = Pattern.compile(".*display=\"(.*)\" toc_id.*");
			Matcher matcher = p.matcher(s.trim());

			if (!matcher.matches()) {
				return;// not a TOC item
			}

			String value = matcher.group(1);
			tocItems.add(value);
		}

		@Override
		public String toString() {
			return stringWriter.getBuffer().toString();
		}
	}

	private class TOCItemProviderTestStub implements TOCItemProvider {

		Map<String, TOCItemExternal> externals = new HashMap<>();
		Map<String, TOCItemDefinition> definitions = new HashMap<>();

		void addExternal(TOCItemExternal item) {
			String displayText = item.getIDAttribute();
			externals.put(displayText, item);
		}

		void addDefinition(TOCItemDefinition item) {
			String ID = item.getIDAttribute();
			definitions.put(ID, item);
		}

		@Override
		public Map<String, TOCItemExternal> getTOCItemExternalsByDisplayMapping() {
			return externals;
		}

		@Override
		public Map<String, TOCItemDefinition> getTOCItemDefinitionsByIDMapping() {
			return definitions;
		}

	}

	private class LinkDatabaseTestStub extends LinkDatabase {

		public LinkDatabaseTestStub(HelpModuleLocation loc) {
			super(HelpModuleCollection.fromHelpLocations(Collections.singleton(loc)));
		}

		@Override
		public String getIDForLink(String target) {
			return "test_ID_" + target;
		}
	}

	private class OverlayHelpModuleLocationTestStub extends HelpModuleLocationTestDouble {

		OverlayHelpModuleLocationTestStub(GhidraTOCFileDummy toc) {
			super(Paths.get("/fake/help"));
			this.sourceTOCFile = toc;
		}

		@Override
		protected void loadHelpTopics() {
			// no! ...don't really go to the filesystem
		}

		@Override
		public GhidraTOCFile loadSourceTOCFile() {
			return null;// we set this in the constructor
		}

		@Override
		public HelpSet loadHelpSet() {
			return null;
		}

		@Override
		public boolean isHelpInputSource() {
			return true;
		}

	}

	private class GhidraTOCFileDummy extends GhidraTOCFileTestDouble {

		public GhidraTOCFileDummy(Path path) {
			super(path);
		}
	}
}
```


Overlapping Code:
```
eTest {
@Test
public void testSourceTOCFileThatDependsUponPreBuiltHelp() {
//
// We want to make sure the overlay tree will properly resolve help TOC items being 
// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined
// in a help <TOCITEM> that lives inside of a pre-built jar file.
//
/*

Example makeup we will create:

PreBuild_TOC.xml

<tocitem id="root" target="fake">
<tocitem id="child_1" target="fake" />
</tocitem>


TOC_Source.xml 

<tocref id="root">
<tocref="child_1">
<tocdef id="child_2" target="fake" />
</tocref>
</tocref>

*/
TOCItemExternal root = externalItem("root");
TOCItemExternal child_1 = externalItem(root, "child_1");
Path tocSourceFile = Paths.get("/fake/path_2/TOC_Source.xml");
String root_ID = root.getIDAttribute();
TOCItemReference root_ref = referenceItem(root_ID, tocSourceFile);
String child_1_ID = child_1.getIDAttribute();
TOCItemReference child_1_ref = referenceItem(root_ref, child_1_ID, tocSourceFile);
TOCItemDefinition child_2 = definitionItem(child_1_ref, "child_2", tocSourceFile);
TOCItemProviderTestStub tocProvider = new TOCItemProviderTestStub();
tocProvider.addExternal(root);
tocProvider.addExternal(child_1);
tocProvider.addDefinition(child_2);
TOCSpyWriter spy = printOverlayTree(tocProvider, tocSourceFile);
assertNodeCount(spy, 3);
assertOrder(spy, 1, root);
assertOrder(spy, 2, child_1);
assertOrder(spy, 3, child_2);
}
@Test
public void testSourceTOCFileThatDependsUponPreBuiltHelp_MultiplePreBuiltInputs() {
//
// We want to make sure the overlay tree will properly resolve help TOC items being 
// built from TOC_Source.xml files when that file uses <TOCREF> items that are defined
// in a help <TOCITEM> that lives inside of multiple pre-built jar files.
//
/*

Example makeup we will create:

PreBuild_TOC.xml

<tocitem id="root" target="fake">
<tocitem id="child_1" target="fake">
<tocitem="prebuilt_a_child" target="fake" />
</tocitem>
</tocitem>

Another PreBuild_TOC.xml

<tocitem id="root" target="fake">
<tocitem id="child_1" target="fake">
<tocitem="prebuilt_b_child" target="fake" />
</tocitem>
</t
```
<Overlap Ratio: 0.9668508287292817>

---

--- 85 --
Question ID: 8e05e5d71d31cef97b2bfa5ed7703f94687f8e5d
Original Code:
```
public class SessionManager {
  // Shared Preferences
  SharedPreferences sharedPreferences;

  // Editor for Shared preferences
  Editor editor;

  // Context
  Context _context;

  // Shared preferences mode
  int PRIVATE_MODE = 0;

  String prefName;

  public SessionManager(Context context, String PREF_NAME){
    this._context = context;
    this.prefName = PREF_NAME;
    sharedPreferences = _context.getSharedPreferences(PREF_NAME, PRIVATE_MODE);
    editor = sharedPreferences.edit();
  }

  public void createLoginSession(String username, String password){

    if (prefName.equals("Teacher")){

      // Storing name in sharedPreferences
      editor.putString("teacher_username", username);

      // Storing password in sharedPreferences
      editor.putString("teacher_password", password);

    }

    else {

      editor.putString("student_username", username);

      // Storing password in sharedPreferences
      editor.putString("student_password", password);

    }

    // commit changes
    editor.commit();
  }
}
```


Overlapping Code:
```
public class SessionManager {
// Shared Preferences
SharedPreferences sharedPreferences;
// Editor for Shared preferences
Editor editor;
// Context
Context _context;
// Shared preferences mode
int PRIVATE_MODE = 0;
String prefName;
public SessionManager(Context context, String PREF_NAME){
this._context = context;
this.prefName = PREF_NAME;
sharedPreferences = _context.getSharedPreferences(PREF_NAME, PRIVATE_MODE);
editor = sharedPreferences.edit();
}
public void createLoginSession(String username, String password){
if (prefName.equals("Teacher")){
// Storing name in sharedPreferences
editor.putString("teacher_username", username);
// Storing password in sharedPreferences
editor.putString("teacher_password", password);
}
else {
editor.putString("student_username", username);
// Storing password in sharedPreferences
editor.putString("student_password", password);
}
// com
```
<Overlap Ratio: 0.9649890590809628>

---

--- 86 --
Question ID: 2b43cbafa860eff2cd70ed10d0f881387877be35
Original Code:
```
final class DefaultMessageUpdate extends AbstractMessageRequest
    implements MongoMessageUpdate {

  private static final int UPSERT = 0;
  private static final int MULTI_UPDATE = 1;

  private static final int[][] RESERVED = new int[][] {{2, 31}};

  private String fullCollectionName;
  private final MongoMessageFlags flags = new DefaultMessageFlags();
  private BsonDocument selector;
  private BsonDocument update;

  DefaultMessageUpdate() {
    super(MongoMessageOpcode.UPDATE);
  }

  @Override
  public String fullCollectionName() {
    return fullCollectionName;
  }

  @Override
  public void fullCollectionName(String fullCollectionName) {
    Preconditions.checkNotNull(fullCollectionName);
    this.fullCollectionName = fullCollectionName;
  }

  @Override
  public BsonDocument selector() {
    return selector;
  }

  @Override
  public void selector(BsonDocument selector) {
    Preconditions.checkNotNull(selector);
    this.selector = selector;
  }

  @Override
  public BsonDocument update() {
    return update;
  }

  @Override
  public void update(BsonDocument update) {
    Preconditions.checkNotNull(update);
    this.update = update;
  }

  @Override
  public boolean upsert() {
    return flags.get(UPSERT);
  }

  @Override
  public void upsert(boolean upsert) {
    flags.set(UPSERT, upsert);
  }

  @Override
  public boolean multiUpdate() {
    return flags.get(MULTI_UPDATE);
  }

  @Override
  public void multiUpdate(boolean multiUpdate) {
    flags.set(MULTI_UPDATE, multiUpdate);
  }

  @Override
  protected void writeBodyTo(ByteBuffer buffer) {
    Preconditions.checkNotNull(buffer);

    for (int[] range : RESERVED)
      for (int position = range[0]; position <= range[1]; position++)
        assert !flags.get(position);

    buffer.putInt(0);
    buffer.put(fullCollectionName.getBytes(Charsets.UTF_8));
    buffer.put(BsonBytes.EOO);
    buffer.putInt(flags.mask());
    BsonDocuments.writeTo(buffer, selector);
    BsonDocuments.writeTo(buffer, update);
  }
}
```


Overlapping Code:
```
l class DefaultMessageUpdate extends AbstractMessageRequest
implements MongoMessageUpdate {
private static final int UPSERT = 0;
private static final int MULTI_UPDATE = 1;
private static final int[][] RESERVED = new int[][] {{2, 31}};
private String fullCollectionName;
private final MongoMessageFlags flags = new DefaultMessageFlags();
private BsonDocument selector;
private BsonDocument update;
DefaultMessageUpdate() {
super(MongoMessageOpcode.UPDATE);
}
@Override
public String fullCollectionName() {
return fullCollectionName;
}
@Override
public void fullCollectionName(String fullCollectionName) {
Preconditions.checkNotNull(fullCollectionName);
this.fullCollectionName = fullCollectionName;
}
@Override
public BsonDocument selector() {
return selector;
}
@Override
public void selector(BsonDocument selector) {
Preconditions.checkNotNull(selector);
this.selector = selector;
}
@Override
public BsonDocument update() {
return update;
}
@Override
public void update(BsonDocument update) {
Preconditions.checkNotNull(update);
this.update = update;
}
@Override
public boolean upsert() {
return flags.get(UPSERT);
}
@Override
public void upsert(boolean upsert) {
flags.set(UPSERT, upsert);
}
@Override
public boolean multiUpdate() {
return flags.get(MULTI_UPDATE);
}
@Override
public void multiUpdate(boolean multiUpdate) {
flags.set(MULTI_UPDATE, multiUpdate);
}
@Override
protected void writeBodyTo(ByteBuffer buffer) {
Preconditions.checkNotNull(buffer);
for (int[] range : RESERVED)
for (int position = range[0]; position <= range[1]; position++)
assert !flags.get(position);
buffer.putInt(0);
buffer.put(fullCollectionName.getBytes(Charsets.UTF_8));
buffer.put(BsonBytes.EOO);
buffer.putInt(flags.mask());
BsonDocuments.writeTo(buffer, selecto
```
<Overlap Ratio: 0.9722222222222222>

---

--- 87 --
Question ID: 4dcc551b3414ab7a0a365230495cc946a24752b9
Original Code:
```
public class T4777949 {
    public static void main(String... args) throws Exception {
        new T4777949().run();
    }

    void run() throws Exception {
        File javaFile = writeTestFile();
        File classFile = compileTestFile(javaFile);

        test(".", "p.q.r.Test", false);
        test("p", "q.r.Test", true);
        test("p/q", "r.Test", true);
        test("p/q/r", "Test", true);
        test(".", "p.q.r.Test.Inner", false);
        test(".", "p.q.r.Test$Inner", false);
        test("p", "q.r.Test.Inner", true);
        test("p", "q.r.Test$Inner", true);

        if (errors > 0)
            throw new Exception(errors + " errors found");
    }

    void test(String classPath, String className, boolean expectWarnings) {
        List<Diagnostic<? extends JavaFileObject>> diags =
            javap(Arrays.asList("-classpath", classPath), Arrays.asList(className));
        boolean foundWarnings = false;
        for (Diagnostic<? extends JavaFileObject> d: diags) {
            if (d.getKind() == Diagnostic.Kind.WARNING)
                foundWarnings = true;
        }
    }


    File writeTestFile() throws IOException {
        File f = new File("Test.java");
        PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));
        out.println("package p.q.r;");
        out.println("class Test { class Inner { } }");
        out.close();
        return f;
    }

    File compileTestFile(File f) {
        int rc = com.sun.tools.javac.Main.compile(new String[] { "-d", ".", f.getPath() });
        if (rc != 0)
            throw new Error("compilation failed. rc=" + rc);
        String path = f.getPath();
        return new File(path.substring(0, path.length() - 5) + ".class");
    }

    List<Diagnostic<? extends JavaFileObject>> javap(List<String> args, List<String> classes) {
        DiagnosticCollector<JavaFileObject> dc = new DiagnosticCollector<JavaFileObject>();
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        JavaFileManager fm = JavapFileManager.create(dc, pw);
        JavapTask t = new JavapTask(pw, fm, dc, args, classes);
        boolean ok = t.run();

        List<Diagnostic<? extends JavaFileObject>> diags = dc.getDiagnostics();

        if (!ok)
            error("javap failed unexpectedly");

        System.err.println("args=" + args + " classes=" + classes + "\n"
                           + diags + "\n"
                           + sw);

        return diags;
    }

    void error(String msg) {
        System.err.println("error: " + msg);
        errors++;
    }

    int errors;
}
```


Overlapping Code:
```
 {
public static void main(String... args) throws Exception {
new T4777949().run();
}
void run() throws Exception {
File javaFile = writeTestFile();
File classFile = compileTestFile(javaFile);
test(".", "p.q.r.Test", false);
test("p", "q.r.Test", true);
test("p/q", "r.Test", true);
test("p/q/r", "Test", true);
test(".", "p.q.r.Test.Inner", false);
test(".", "p.q.r.Test$Inner", false);
test("p", "q.r.Test.Inner", true);
test("p", "q.r.Test$Inner", true);
if (errors > 0)
throw new Exception(errors + " errors found");
}
void test(String classPath, String className, boolean expectWarnings) {
List<Diagnostic<? extends JavaFileObject>> diags =
javap(Arrays.asList("-classpath", classPath), Arrays.asList(className));
boolean foundWarnings = false;
for (Diagnostic<? extends JavaFileObject> d: diags) {
if (d.getKind() == Diagnostic.Kind.WARNING)
foundWarnings = true;
}
}
File writeTestFile() throws IOException {
File f = new File("Test.java");
PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(f)));
out.println("package p.q.r;");
out.println("class Test { class Inner { } }");
out.close();
return f;
}
File compileTestFile(File f) {
int rc = com.sun.tools.javac.Main.compile(new String[] { "-d", ".", f.getPath() });
if (rc != 0)
throw new Error("compilation failed. rc=" + rc);
String path = f.getPath();
return new File(path.substring(0, path.length() - 5) + ".class");
}
List<Diagnostic<? extends JavaFileObject>> javap(List<String> args, List<String> classes) {
DiagnosticCollector<JavaFileObject> dc = new DiagnosticCollector<JavaFileObject>();
StringWriter sw = new StringWriter();
PrintWriter pw = new PrintWriter(sw);
JavaFileManager fm = JavapFileManager.create(dc, pw);
JavapTask t = new JavapTask(pw, fm, dc, args, classes);
boolean ok = t.run();
List<Diagnostic<? extends JavaFileObject>> diags = dc.getDiagnostics();
if (!ok)
error("javap failed unexpectedly");
System.err.println("args=" + args + " classes=" + classes + "\
```
<Overlap Ratio: 0.9698169223156853>

---

--- 88 --
Question ID: fe118556438da80f134e4a6a3ebb2b62dd7f3c8a
Original Code:
```
public class BorderedRectangle implements Widget {

    /**
     * onepixel texture.
     */
    private Texture pixel;

    private float x;
    private float y;
    private float width;
    private float height;

    public BorderedRectangle(Texture pixel, int x, int y, int width, int height) {
        this.pixel = pixel;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    @Override
    public void render(Renderer renderer) {
        renderer.begin();
        pixel.bind();
        drawRect(renderer, x, y, width, height, Color.BLACK);
        drawRect(renderer, x + 1, y + 1, width - 2, height - 2, Color.WHITE);
        renderer.end();
    }

    private static void drawRect(Renderer renderer, float x, float y, float width, float height, Color color) {
        renderer.drawTextureRegion(
                x, y,
                x + width, y + height,
                0f, 0f,
                1f, 1f,
                color);
    }
}
```


Overlapping Code:
```
redRectangle implements Widget {
/**
* onepixel texture.
*/
private Texture pixel;
private float x;
private float y;
private float width;
private float height;
public BorderedRectangle(Texture pixel, int x, int y, int width, int height) {
this.pixel = pixel;
this.x = x;
this.y = y;
this.width = width;
this.height = height;
}
@Override
public void render(Renderer renderer) {
renderer.begin();
pixel.bind();
drawRect(renderer, x, y, width, height, Color.BLACK);
drawRect(renderer, x + 1, y + 1, width - 2, height - 2, Color.WHITE);
renderer.end();
}
private static void drawRect(Renderer renderer, float x, float y, float width, float height, Color color) {
renderer.drawTextureRegion(
x, y,
x + width, y + height,
0
```
<Overlap Ratio: 0.9421813403416557>

---

--- 89 --
Question ID: c0a47a79a9167e9c1f9c8a1dd735ddf95c431a83
Original Code:
```
public class ServerControlWrapperUnitTest extends TestBase
{
    @Test
    public void testEquality () throws Exception
    {
        TransactionFactoryImple imple = new TransactionFactoryImple("test");
        ControlImple tx = imple.createLocal(1000);
        
        ServerControlWrapper wrap1 = new ServerControlWrapper(tx);
        ServerControlWrapper wrap2 = new ServerControlWrapper(tx.getControl());
        
        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));
        
        wrap1 = new ServerControlWrapper(tx.getControl(), tx);
        wrap2 = new ServerControlWrapper(tx.getControl(), tx.get_uid());
        
        assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));
    }
    
    @Test
    public void testNested () throws Exception
    {
        TransactionFactoryImple imple = new TransactionFactoryImple("test");
        ControlImple tx = imple.createLocal(1000);
        
        ServerControlWrapper wrap = new ServerControlWrapper(tx);
        ControlWrapper sub = wrap.create_subtransaction();
        
        assertTrue(sub != null);
        
        assertEquals(sub.cancel(), ActionStatus.ABORTED);
    }
}
```


Overlapping Code:
```
rverControlWrapperUnitTest extends TestBase
{
@Test
public void testEquality () throws Exception
{
TransactionFactoryImple imple = new TransactionFactoryImple("test");
ControlImple tx = imple.createLocal(1000);

ServerControlWrapper wrap1 = new ServerControlWrapper(tx);
ServerControlWrapper wrap2 = new ServerControlWrapper(tx.getControl());

assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));

wrap1 = new ServerControlWrapper(tx.getControl(), tx);
wrap2 = new ServerControlWrapper(tx.getControl(), tx.get_uid());

assertTrue(wrap1.get_uid().equals(wrap2.get_uid()));
}

@Test
public void testNested () throws Exception
{
TransactionFactoryImple imple = new TransactionFactoryImple("test");
ControlImple tx = imple.createLocal(1000);

ServerControlWrapper wrap = new ServerControlWrapper(tx);
ControlWrapper sub = wrap.create_subtransaction();

assertTrue(sub != null);

assertEquals(sub.cancel()
```
<Overlap Ratio: 0.9544008483563097>

---

--- 90 --
Question ID: f9d32d398ab45f420b3ca27d39f82fd8a93078a8
Original Code:
```
class Insertionsort { 
	
	void sort(int array[]) 
	{ 
		int n = 5;		
                 for (int i = 1; i < 5; ++i) { 
			int key = array[i]; 
			int j = i - 1; 

		
			while (j >= 0 && array[j] > key) {
      //This program is coded by roja
				array[j+1] = array[j]; 
				j = j - 1; 
			} 
			array[j + 1] = key; 
		} 
	} 
public static void main(String args[]) 
	{ 
         int k;      
        System.out.println("enter the array size");

                Scanner obj = new Scanner(System.in);
                //This program is coded by roja
                int s = obj.nextInt();
                int array[] = new int[5];
 System.out.println("enter " + s + " element ");
 for( k = 0;  k < 5; k++)
{
int x =obj.nextInt();
array[k]=x;
}
   	Insertionsort ob = new Insertionsort(); 
		ob.sort(array);
          System.out.println("after sorting");
          for (int i = 0; i < 5; i++) 
        //This program is coded by roja
			System.out.print(array[i] + " "); 
      System.out.println();
                    

               
	
	} 
}
```


Overlapping Code:
```

void sort(int array[]) 
{ 
int n = 5; 
for (int i = 1; i < 5; ++i) { 
int key = array[i]; 
int j = i - 1; 

while (j >= 0 && array[j] > key) {
//This program is coded by roja
array[j+1] = array[j]; 
j = j - 1; 
} 
array[j + 1] = key; 
} 
} 
public static void main(String args[]) 
{ 
int k; 
System.out.println("enter the array size");
Scanner obj = new Scanner(System.in);
//This program is coded by roja
int s = obj.nextInt();
int array[] = new int[5];
System.out.println("enter " + s + " element ");
for( k = 0; k < 5; k++)
{
int x =obj.nextInt();
array[k]=x;
}
Insertionsort ob = new Insertionsort(); 
ob.sort(array);
System.out.println("after sorting");
for (int i = 0; i < 5; i++) 
//This program is coded by roja
System.out.print(array[i] + " "); 
System.out.println(
```
<Overlap Ratio: 0.9591584158415841>

---

--- 91 --
Question ID: be35ec8e1bcf9d063885955e73ae1e2702227622
Original Code:
```
public class NgConfiguration {
    private static final String PAGE_LOAD_TIMEOUT = "PAGE_LOAD_TIMEOUT";
    private static final String WEBDRIVER_TIMEOUT = "WEBDRIVER_TIMEOUT";
    private static final String ANGULAR_TIMEOUT = "ANGULAR_TIMEOUT";
    private static final String PAGE_SYNC_TIMEOUT = "PAGE_SYNC_TIMEOUT";
    public static final long DEFAULT_PAGE_LOAD_TIMEOUT = 10 * 1000;
    public static final long DEFAULT_PAGE_SYNC_TIMEOUT = 11 * 1000;
    public static final long DEFAULT_ANGULAR_TIMEOUT = 10 * 1000;
    public static final long DEFAULT_WEBDRIVER_TIMEOUT = 11 * 1000;
    private Properties properties;

    public NgConfiguration(URL url) {
        properties = new Properties();
        loadConfig(url);
    }

    public long getPageLoadTimeout() {
        return getProperty(PAGE_LOAD_TIMEOUT);
    }

    public long getPageSyncTimeout() {
        return getProperty(PAGE_SYNC_TIMEOUT);
    }

    public long getAngularTimeout() {
        return getProperty(ANGULAR_TIMEOUT);
    }

    public long getWebDriverTimeout() {
        return getProperty(WEBDRIVER_TIMEOUT);
    }

    private long getProperty(String key) {
        if (properties == null)
            loadDefaultProperties();
        return Long.parseLong((String) properties.get(key));
    }

    private void loadDefaultProperties() {
        setProperty(PAGE_LOAD_TIMEOUT, DEFAULT_PAGE_LOAD_TIMEOUT);
        setProperty(PAGE_SYNC_TIMEOUT, DEFAULT_PAGE_SYNC_TIMEOUT);
        setProperty(ANGULAR_TIMEOUT, DEFAULT_ANGULAR_TIMEOUT);
        setProperty(WEBDRIVER_TIMEOUT, DEFAULT_WEBDRIVER_TIMEOUT);
    }

    private void setProperty(String key, long value) {
        properties.setProperty(key, "" + value);
    }

    public void loadConfig(URL url) {
        loadDefaultProperties();
        if (url != null)
            try {
                properties.load(url.openStream());
            } catch (IOException e) {
                new RuntimeException(e);
            }
    }
}
```


Overlapping Code:
```
inal String PAGE_LOAD_TIMEOUT = "PAGE_LOAD_TIMEOUT";
private static final String WEBDRIVER_TIMEOUT = "WEBDRIVER_TIMEOUT";
private static final String ANGULAR_TIMEOUT = "ANGULAR_TIMEOUT";
private static final String PAGE_SYNC_TIMEOUT = "PAGE_SYNC_TIMEOUT";
public static final long DEFAULT_PAGE_LOAD_TIMEOUT = 10 * 1000;
public static final long DEFAULT_PAGE_SYNC_TIMEOUT = 11 * 1000;
public static final long DEFAULT_ANGULAR_TIMEOUT = 10 * 1000;
public static final long DEFAULT_WEBDRIVER_TIMEOUT = 11 * 1000;
private Properties properties;
public NgConfiguration(URL url) {
properties = new Properties();
loadConfig(url);
}
public long getPageLoadTimeout() {
return getProperty(PAGE_LOAD_TIMEOUT);
}
public long getPageSyncTimeout() {
return getProperty(PAGE_SYNC_TIMEOUT);
}
public long getAngularTimeout() {
return getProperty(ANGULAR_TIMEOUT);
}
public long getWebDriverTimeout() {
return getProperty(WEBDRIVER_TIMEOUT);
}
private long getProperty(String key) {
if (properties == null)
loadDefaultProperties();
return Long.parseLong((String) properties.get(key));
}
private void loadDefaultProperties() {
setProperty(PAGE_LOAD_TIMEOUT, DEFAULT_PAGE_LOAD_TIMEOUT);
setProperty(PAGE_SYNC_TIMEOUT, DEFAULT_PAGE_SYNC_TIMEOUT);
setProperty(ANGULAR_TIMEOUT, DEFAULT_ANGULAR_TIMEOUT);
setProperty(WEBDRIVER_TIMEOUT, DEFAULT_WEBDRIVER_TIMEOUT);
}
private void setProperty(String key, long value) {
properties.setProperty(key, "" + value);
}
public void loadConfig(URL url) {
loadDefaultProperties();
if (url != null)
try {
properties.load(url.openStream());
} catch (IOException e) {
new RuntimeException(e);
}
}
```
<Overlap Ratio: 0.9704284852142426>

---

--- 92 --
Question ID: 2babce80465b4a6a2f9ea601da5b9bcd8ec76f43
Original Code:
```
public class OctetEncodingTest extends TestCase implements
        XMLStreamConstants {
    
    public void testSmallChunkedOctets() throws Exception {
        String envNS = "http://envelope";
        String[] texts = new String[] {"sdf===ertS", "S", "I", "N", "G", "L", "E", "", "DDFFEdsfsdf23432423"};
        
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);
        XMLStreamWriter writer = serializer;
        writer.writeStartDocument();
        
        writer.setPrefix("ns1", envNS);
        writer.writeStartElement(envNS, "Envelope");
        writer.writeNamespace("ns1", envNS);
        StringBuffer patternBuffer = new StringBuffer();
        for(String s : texts) {
            byte[] buf = s.getBytes();
            serializer.writeOctets(buf, 0, buf.length);
            patternBuffer.append(s);
        }
        writer.writeEndElement(); // Close just last element
        
        writer.writeEndDocument();
        
        writer.flush();
        out.flush();
        out.close();
        
        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
        XMLStreamReader reader = new StAXDocumentParser(in);
        
        
        assertEquals(START_ELEMENT, reader.next());
        assertEquals("Envelope", reader.getLocalName());
        
        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();
        StringBuffer bufToTest = new StringBuffer();
        while(reader.next() == CHARACTERS) {
            char[] charBuf = reader.getText().toCharArray();
            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));
            bufToTest.append(decodedStr);
        }
        assertEquals(patternBuffer.toString(), bufToTest.toString());
        
        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>
        
        reader.close();
        in.close();
    }
    
    public void testBigChunkedOctets() throws Exception {
        String envNS = "http://envelope";
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);
        XMLStreamWriter writer = serializer;
        writer.writeStartDocument();
        
        writer.setPrefix("ns1", envNS);
        writer.writeStartElement(envNS, "Envelope");
        writer.writeNamespace("ns1", envNS);
        StringBuffer patternBuffer = new StringBuffer();
        for(int i = 0; i < 5; i++) {
            String s = createRandomString(2000 + i * 100);
            byte[] buf = s.getBytes();
            serializer.writeOctets(buf, 0, buf.length);
            patternBuffer.append(s);
        }
        
        writer.writeEndElement(); // Close just last element
        
        writer.writeEndDocument();
        
        writer.flush();
        out.flush();
        out.close();
        
        ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
        XMLStreamReader reader = new StAXDocumentParser(in);
        
        
        assertEquals(START_ELEMENT, reader.next());
        assertEquals("Envelope", reader.getLocalName());
        
        BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();
        StringBuffer bufToTest = new StringBuffer();
        while(reader.next() == CHARACTERS) {
            char[] charBuf = reader.getText().toCharArray();
            String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));
            bufToTest.append(decodedStr);
        }
        assertEquals(patternBuffer.toString(), bufToTest.toString());
        
        assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>
        
        reader.close();
        in.close();
    }
    
    private String createRandomString(int length) {
        StringBuffer sb = new StringBuffer(length);
        Random random = new Random();
        for(int i=0; i<length; i++) {
            sb.append((char) (random.nextInt(20) + 'a'));
        }
        
        return sb.toString();
    }
}
```


Overlapping Code:
```
 implements
XMLStreamConstants {

public void testSmallChunkedOctets() throws Exception {
String envNS = "http://envelope";
String[] texts = new String[] {"sdf===ertS", "S", "I", "N", "G", "L", "E", "", "DDFFEdsfsdf23432423"};

ByteArrayOutputStream out = new ByteArrayOutputStream();
StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);
XMLStreamWriter writer = serializer;
writer.writeStartDocument();

writer.setPrefix("ns1", envNS);
writer.writeStartElement(envNS, "Envelope");
writer.writeNamespace("ns1", envNS);
StringBuffer patternBuffer = new StringBuffer();
for(String s : texts) {
byte[] buf = s.getBytes();
serializer.writeOctets(buf, 0, buf.length);
patternBuffer.append(s);
}
writer.writeEndElement(); // Close just last element

writer.writeEndDocument();

writer.flush();
out.flush();
out.close();

ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());
XMLStreamReader reader = new StAXDocumentParser(in);


assertEquals(START_ELEMENT, reader.next());
assertEquals("Envelope", reader.getLocalName());

BASE64EncodingAlgorithm base64Decoder = new BASE64EncodingAlgorithm();
StringBuffer bufToTest = new StringBuffer();
while(reader.next() == CHARACTERS) {
char[] charBuf = reader.getText().toCharArray();
String decodedStr = new String((byte[]) base64Decoder.convertFromCharacters(charBuf, 0, charBuf.length));
bufToTest.append(decodedStr);
}
assertEquals(patternBuffer.toString(), bufToTest.toString());

assertEquals(END_ELEMENT, reader.getEventType()); // </Envelope>

reader.close();
in.close();
}

public void testBigChunkedOctets() throws Exception {
String envNS = "http://envelope";
ByteArrayOutputStream out = new ByteArrayOutputStream();
StAXDocumentSerializer serializer = new StAXDocumentSerializer(out);
XMLStreamWriter writer = serializer;
writer.writeStartDocument();

writer.setPrefix("ns1", envNS);
writer.writeStartElement(envNS, "Envelope");
writer.writeNamespace("ns1", envNS);
Stri
```
<Overlap Ratio: 0.9715994020926756>

---

--- 93 --
Question ID: 7f4ccdfaf3954b9021e497b88b35eab452862541
Original Code:
```
public class DataDisjunctionTest {

	public static void main(String[] args) {
		IntegerDataArray a1 = new IntegerDataArray(new Integer[]{1, 5, 7, 11, 15});
		IntegerDataArray a2 = new IntegerDataArray(new Integer[]{2, 3, 5, 11});
		IntegerDataArray a3 = new IntegerDataArray(new Integer[]{5, 11, 12 });
		IntegerDataArray a4 = new IntegerDataArray(new Integer[]{1, 3, 5});
		IntegerDataArray a5 = new IntegerDataArray(new Integer[]{5, 7, 11});
		
		DataDisjunction disjunction = new DataDisjunction(new IDataArray[]{a1, a2, a3, a4, a5}, 4);
		
//		System.out.println("advance : " + disjunction.advance(11));
		
		long data = -1;
		long begin = System.nanoTime();
		while((data = disjunction.nextDoc()) != IDataArray.NO_MORE_DATA) {
			System.out.println(data);
		}
		System.out.println("cost : " + (System.nanoTime() - begin) / (float) 1000000 + " ms");
	}
}
```


Overlapping Code:
```
public class DataDisjunctionTest {
public static void main(String[] args) {
IntegerDataArray a1 = new IntegerDataArray(new Integer[]{1, 5, 7, 11, 15});
IntegerDataArray a2 = new IntegerDataArray(new Integer[]{2, 3, 5, 11});
IntegerDataArray a3 = new IntegerDataArray(new Integer[]{5, 11, 12 });
IntegerDataArray a4 = new IntegerDataArray(new Integer[]{1, 3, 5});
IntegerDataArray a5 = new IntegerDataArray(new Integer[]{5, 7, 11});

DataDisjunction disjunction = new DataDisjunction(new IDataArray[]{a1, a2, a3, a4, a5}, 4);

// System.out.println("advance : " + disjunction.advance(11));

long data = -1;
long begin = System.nanoTime();
while((data = disjunction.nextDoc()) != IDataArray.NO_MORE_DATA) {
System.out.println(data);
}
System.out.println("cost : " + (System.nanoTime() - begin) / (float) 1000000 
```
<Overlap Ratio: 0.9842041312272175>

---

--- 94 --
Question ID: b5f3e8ad1c9de91212ae32aeb01c1d0cec208493
Original Code:
```
public class BitcoinBootstrapBlockCornerCaseTest {
    
    private static VeriBlockSecurity security;
    private static BitcoinBlockchain blockchain;

    private final static int block1Height = 601491;
    private final static BitcoinBlock block1  = new BitcoinBlock(
            766099456,
            Sha256Hash.wrap("00000000000000000004dc9c42c22f489ade54a9349e3a47aee5b55069062afd"),
            Sha256Hash.wrap("87839c0e4c6771557ef02a5076c8b46a7157e5532eff7153293791ca852d2e58"),
            1572336145, 0x17148edf, 790109764);

    private final static BitcoinBlock block2 = new BitcoinBlock(
            1073733632,
            Sha256Hash.wrap("0000000000000000000faad7ae177b313ee4e3f1da519dbbf5b3ab58ccff6338"),
            Sha256Hash.wrap("902e5a70c8fa99fb9ba6d0f855f5e84b8ffc3fe56b694889d07031d8adb6a0f8"),
            1572336708, 0x17148edf, 344118374);

    private final static BitcoinBlock block3 = new BitcoinBlock(
            536870912,
            Sha256Hash.wrap("00000000000000000001163c9e1130c26984d831cb16c16f994945a197550897"),
            Sha256Hash.wrap("2dfad61070eeea30ee035cc58ac20a325292802f9445851d14f23b4e71ddee61"),
            1572337243, 0x17148edf, 2111493782);

    @Before
    public void setUp() throws SQLException, IOException {
        VeriBlockIntegrationLibraryManager manager = new VeriBlockIntegrationLibraryManager();
        security = manager.init();
        blockchain = security.getBitcoinBlockchain();
    }
    
    @After
    public void tearDown() throws SQLException {
        security.shutdown();
    }

    @Test
    public void checkBitcoinContextuallyTest() throws SQLException {
        blockchain.bootstrap(Arrays.asList(block1, block2, block3), block1Height);

        security.checkConnectivity(block1);
        security.checkConnectivity(block2);
        security.checkConnectivity(block3);
    }

    @Test
    public void addBootstrapBlockTest() throws SQLException {
        blockchain.bootstrap(Arrays.asList(block1, block2), block1Height);

        blockchain.add(block1);
        blockchain.add(block2);
        blockchain.add(block3);
    }

}
```


Overlapping Code:
```
ockCornerCaseTest {

private static VeriBlockSecurity security;
private static BitcoinBlockchain blockchain;
private final static int block1Height = 601491;
private final static BitcoinBlock block1 = new BitcoinBlock(
766099456,
Sha256Hash.wrap("00000000000000000004dc9c42c22f489ade54a9349e3a47aee5b55069062afd"),
Sha256Hash.wrap("87839c0e4c6771557ef02a5076c8b46a7157e5532eff7153293791ca852d2e58"),
1572336145, 0x17148edf, 790109764);
private final static BitcoinBlock block2 = new BitcoinBlock(
1073733632,
Sha256Hash.wrap("0000000000000000000faad7ae177b313ee4e3f1da519dbbf5b3ab58ccff6338"),
Sha256Hash.wrap("902e5a70c8fa99fb9ba6d0f855f5e84b8ffc3fe56b694889d07031d8adb6a0f8"),
1572336708, 0x17148edf, 344118374);
private final static BitcoinBlock block3 = new BitcoinBlock(
536870912,
Sha256Hash.wrap("00000000000000000001163c9e1130c26984d831cb16c16f994945a197550897"),
Sha256Hash.wrap("2dfad61070eeea30ee035cc58ac20a325292802f9445851d14f23b4e71ddee61"),
1572337243, 0x17148edf, 2111493782);
@Before
public void setUp() throws SQLException, IOException {
VeriBlockIntegrationLibraryManager manager = new VeriBlockIntegrationLibraryManager();
security = manager.init();
blockchain = security.getBitcoinBlockchain();
}

@After
public void tearDown() throws SQLException {
security.shutdown();
}
@Test
public void checkBitcoinContextuallyTest() throws SQLException {
blockchain.bootstrap(Arrays.asList(block1, block2, block3), block1Height);
security.checkConnectivity(block1);
security.checkConnectivity(block2);
security.checkConnectivity(block3);
}
@Test
public void addBootstrapBlockTest() throws SQLException {
blockchain.bootstrap(Arrays.asList(block1, block2), block1Height);
blockchain.add(block1);
blockchain.add(block2);
blockchain.add(block3
```
<Overlap Ratio: 0.9792949076664801>

---

--- 95 --
Question ID: 006dee7657dd444e5d5d6fe4654427c204838aba
Original Code:
```
@RunWith(PowerMockRunner.class)
@PowerMockIgnore({"com.sun.org.apache.xerces.*", "javax.xml.*", "org.xml.*", "org.w3c.*", "com.sun.org.apache.xalan.*"})
public class SampleSubscriberServletTest {

  private SampleSubscriberServlet sampleSubServlet;
  private SubscriberProps props = SubscriberProps.getInstance();

  @Mock private HttpServletRequest request;
  @Mock private HttpServletResponse response;

  @Before
  public void setUp() {
    props =
        SubscriberProps.getInstance(
            System.getProperty(
                "org.onap.dmaap.datarouter.subscriber.properties", "testsubscriber.properties"));
    sampleSubServlet = new SampleSubscriberServlet();
    sampleSubServlet.init();
  }

  @After
  public void tearDown() throws Exception {
    FileUtils.deleteDirectory(
        new File(props.getValue("org.onap.dmaap.datarouter.subscriber.delivery.dir")));
  }

  @Test
  public void
      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Null_Then_Unathorized_Response_Is_Generated()
          throws Exception {
    when(request.getHeader("Authorization")).thenReturn(null);
    sampleSubServlet.doPut(request, response);
    verify(response).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED));
  }

  @Test
  public void
      Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Not_Authorized_Then_Forbidden_Response_Is_Generated()
          throws Exception {
    when(request.getHeader("Authorization")).thenReturn("Invalid Header");
    sampleSubServlet.doPut(request, response);
    verify(response).sendError(eq(HttpServletResponse.SC_FORBIDDEN));
  }

  @Test
  public void Given_Request_Is_HTTP_PUT_Then_Request_Succeeds() throws Exception {
    setUpSuccessfulFlow();
    sampleSubServlet.doPut(request, response);
    verify(response, times(2)).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));
  }

  @Test
  public void Given_Request_Is_HTTP_DELETE_Then_Request_Succeeds() throws Exception {
    setUpSuccessfulFlow();
    sampleSubServlet.doDelete(request, response);
    verify(response).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));
  }

  private void setUpSuccessfulFlow() throws IOException {
    when(request.getHeader("Authorization")).thenReturn("Basic TE9HSU46UEFTU1dPUkQ=");
    when(request.getPathInfo()).thenReturn("/publish/1/testfile");
    when(request.getHeader("X-DMAAP-DR-PUBLISH-ID")).thenReturn("1");
    when(request.getHeader("X-DMAAP-DR-META")).thenReturn("{\"Key\":\"Value\"}");
    when(request.getQueryString()).thenReturn(null);
    ServletInputStream inStream = mock(ServletInputStream.class);
    when(request.getInputStream()).thenReturn(inStream);
  }
}
```


Overlapping Code:
```
@RunWith(PowerMockRunner.class)
@PowerMockIgnore({"com.sun.org.apache.xerces.*", "javax.xml.*", "org.xml.*", "org.w3c.*", "com.sun.org.apache.xalan.*"})
public class SampleSubscriberServletTest {
private SampleSubscriberServlet sampleSubServlet;
private SubscriberProps props = SubscriberProps.getInstance();
@Mock private HttpServletRequest request;
@Mock private HttpServletResponse response;
@Before
public void setUp() {
props =
SubscriberProps.getInstance(
System.getProperty(
"org.onap.dmaap.datarouter.subscriber.properties", "testsubscriber.properties"));
sampleSubServlet = new SampleSubscriberServlet();
sampleSubServlet.init();
}
@After
public void tearDown() throws Exception {
FileUtils.deleteDirectory(
new File(props.getValue("org.onap.dmaap.datarouter.subscriber.delivery.dir")));
}
@Test
public void
Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Null_Then_Unathorized_Response_Is_Generated()
throws Exception {
when(request.getHeader("Authorization")).thenReturn(null);
sampleSubServlet.doPut(request, response);
verify(response).sendError(eq(HttpServletResponse.SC_UNAUTHORIZED));
}
@Test
public void
Given_Request_Is_HTTP_PUT_And_Request_Header_Is_Not_Authorized_Then_Forbidden_Response_Is_Generated()
throws Exception {
when(request.getHeader("Authorization")).thenReturn("Invalid Header");
sampleSubServlet.doPut(request, response);
verify(response).sendError(eq(HttpServletResponse.SC_FORBIDDEN));
}
@Test
public void Given_Request_Is_HTTP_PUT_Then_Request_Succeeds() throws Exception {
setUpSuccessfulFlow();
sampleSubServlet.doPut(request, response);
verify(response, times(2)).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));
}
@Test
public void Given_Request_Is_HTTP_DELETE_Then_Request_Succeeds() throws Exception {
setUpSuccessfulFlow();
sampleSubServlet.doDelete(request, response);
verify(response).setStatus(eq(HttpServletResponse.SC_NO_CONTENT));
}
private void setUpSuccessfulFlow() throws IOException {
when(request.getHeader("Authorization")).thenReturn("Basic TE9HSU46UEFTU1dPUkQ=");
when(request.getPathInfo()).thenReturn("/publish/1/testfile");
when(request.getHeader("X-DMAAP-DR-PUBLISH-ID")).thenReturn("1");
when(request.getHeader("X-DMAAP-DR-META")).thenReturn("{\"Key\":\"Value\"}");
when(request.getQueryString()).thenReturn(null);
S
```
<Overlap Ratio: 1.0>

---

--- 96 --
Question ID: 38a3e8b0de256a18e4f992c656668d91ff56f017
Original Code:
```
class ViewHighlighter$OverlayHighlighter$1
	implements Runnable
{

	public void run()
	{
		ViewHighlighter.OverlayHighlighter.access$100(ViewHighlighter.OverlayHighlighter.this);
	//    0    0:aload_0         
	//    1    1:getfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>
	//    2    4:invokestatic    #25  <Method void ViewHighlighter$OverlayHighlighter.access$100(ViewHighlighter$OverlayHighlighter)>
	//    3    7:return          
	}

	final ViewHighlighter.OverlayHighlighter this$0;

	ViewHighlighter$OverlayHighlighter$1()
	{
		this$0 = ViewHighlighter.OverlayHighlighter.this;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #17  <Field ViewHighlighter$OverlayHighlighter this$0>
		super();
	//    3    5:aload_0         
	//    4    6:invokespecial   #20  <Method void Object()>
	//    5    9:return          
	}
}
```


Overlapping Code:
```
$1
implements Runnable
{
public void run()
{
ViewHighlighter.OverlayHighlighter.access$100(ViewHighlighter.OverlayHighlighter.this);
// 0 0:aload_0 
// 1 1:getfield #17 <Field ViewHighlighter$OverlayHighlighter this$0>
// 2 4:invokestatic #25 <Method void ViewHighlighter$OverlayHighlighter.access$100(ViewHighlighter$OverlayHighlighter)>
// 3 7:return 
}
final ViewHighlighter.OverlayHighlighter this$0;
ViewHighlighter$OverlayHighlighter$1()
{
this$0 = ViewHighlighter.OverlayHighlighter.this;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #17 <Field ViewHighlighter$OverlayHighlighter this$0>
super();
// 3 5:aload_0 
// 4 6:invokespecial #20 <Method void Object()>
// 5 9:return 
}
}
```
<Overlap Ratio: 0.9451303155006858>

---

--- 97 --
Question ID: e2e5c458cf4d67fb97f5ae7d9459dcc8eddecba5
Original Code:
```
@Component
public class N2oCustomXmlReaderV1 extends N2oStandardControlReaderV1<N2oCustomField> {
    @Override
    public N2oCustomField read(Element element, Namespace namespace) {
        N2oCustomField n2oCustomField = new N2oCustomField();
        getControlFieldDefinition(element, n2oCustomField);
        return n2oCustomField;
    }

    @Override
    public Class<N2oCustomField> getElementClass() {
        return N2oCustomField.class;
    }

    @Override
    public String getElementName() {
        return "custom";
    }
}
```


Overlapping Code:
```
tomXmlReaderV1 extends N2oStandardControlReaderV1<N2oCustomField> {
@Override
public N2oCustomField read(Element element, Namespace namespace) {
N2oCustomField n2oCustomField = new N2oCustomField();
getControlFieldDefinition(element, n2oCustomField);
return n2oCustomField;
}
@Override
public Class<N2oCustomField> getElementClass() {
return N2oCustomField.class;
}
@Override
public String getElementName() {
return "cust
```
<Overlap Ratio: 0.9172113289760349>

---

--- 98 --
Question ID: 7c784517813a66674a232b5af31005ba39c17414
Original Code:
```
public class FlavorRulesShowPageSteps extends RulesShowPageGenericSteps<FlavorRulesShowPageSteps> {

    RulesShowPageObjects rulesShowPageObjects;
    FlavorRulesShowPage rulesShowPage;
    FlavorRulesTemplatesShowPage rulesTemplatesShowPage;

    @Step
    public FlavorRulesShowPageSteps openRulesPage() {
        rulesShowPage.open();
        rulesShowPage.waitFor(500).milliseconds();

        return getThis();
    }

    @Step
    public FlavorRulesShowPageSteps openTemplatesPage() {
        rulesTemplatesShowPage.open();

        return getThis();
    }

    @Step
    public FlavorRulesShowPageSteps verifyPermanentRuleExists(String ruleName, String flavor, String queryPairs) {
        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));
        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));

        return getThis();
    }

    @Step
    public FlavorRulesShowPageSteps verifyPendingAddedRuleIsShown(String ruleName, String flavor, String queryPairs) {
        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));
        Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));
        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));
        Assert.assertTrue("Rule Preview should have 'PENDING ADD' look and feel", rulesShowPageObjects.isRulePendingForAddition(ruleName));

        return getThis();
    }

    @Step
    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerIsShown(String ruleName, String serverPath) {
        rulesShowPage.waitFor(1).second();
        Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));
        Assert.assertTrue(rulesShowPage.isRuleReturningServerPath(ruleName, serverPath));
        Assert.assertTrue("Rule Preview should have 'PENDING ADD' look and feel", rulesShowPageObjects.isRulePendingForAddition(ruleName));
        return getThis();
    }

    @Step
    public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerContainsQueryPairsIsShown(String ruleName, String queryPairs) {
        Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));
        return getThis();
    }

    @Override
    public FlavorRulesShowPageSteps getThis() {
        return this;
    }
}
```


Overlapping Code:
```
esShowPageSteps extends RulesShowPageGenericSteps<FlavorRulesShowPageSteps> {
RulesShowPageObjects rulesShowPageObjects;
FlavorRulesShowPage rulesShowPage;
FlavorRulesTemplatesShowPage rulesTemplatesShowPage;
@Step
public FlavorRulesShowPageSteps openRulesPage() {
rulesShowPage.open();
rulesShowPage.waitFor(500).milliseconds();
return getThis();
}
@Step
public FlavorRulesShowPageSteps openTemplatesPage() {
rulesTemplatesShowPage.open();
return getThis();
}
@Step
public FlavorRulesShowPageSteps verifyPermanentRuleExists(String ruleName, String flavor, String queryPairs) {
Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));
Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));
return getThis();
}
@Step
public FlavorRulesShowPageSteps verifyPendingAddedRuleIsShown(String ruleName, String flavor, String queryPairs) {
Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));
Assert.assertTrue(rulesShowPage.isRuleReturningFlavor(ruleName, flavor));
Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));
Assert.assertTrue("Rule Preview should have 'PENDING ADD' look and feel", rulesShowPageObjects.isRulePendingForAddition(ruleName));
return getThis();
}
@Step
public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerIsShown(String ruleName, String serverPath) {
rulesShowPage.waitFor(1).second();
Assert.assertTrue(rulesShowPageObjects.isRulePresent(ruleName));
Assert.assertTrue(rulesShowPage.isRuleReturningServerPath(ruleName, serverPath));
Assert.assertTrue("Rule Preview should have 'PENDING ADD' look and feel", rulesShowPageObjects.isRulePendingForAddition(ruleName));
return getThis();
}
@Step
public FlavorRulesShowPageSteps verifyPendingAddedRuleAdvancedServerContainsQueryPairsIsShown(String ruleName, String queryPairs) {
Assert.assertTrue(rulesShowPage.isRuleReturningQueryPairs(ruleName, queryPairs));
return getThis();
}
@Override
public FlavorRulesShowPageSteps getThis() {
retu
```
<Overlap Ratio: 0.983284169124877>

---

--- 99 --
Question ID: e18c9d1c5dde3292c983cdccb6c492213c06650a
Original Code:
```
@SuppressWarnings({"ConstantConditions", "Duplicates"})
public class GeneratorRecipes extends RecipeProvider implements IConditionBuilder {

    public GeneratorRecipes(DataGenerator generator) {
        super(generator);
    }

    @Override
    protected void registerRecipes(Consumer<IFinishedRecipe> consumer) {
        registerBlockRecipes(consumer);
        registerItemRecipes(consumer);
    }

    private void registerBlockRecipes(Consumer<IFinishedRecipe> consumer) {

        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("projector"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_PROJECTOR.get())
                                .patternLine("IPI")
                                .patternLine("GRG")
                                .patternLine("IHI")
                                .key('P', Blocks.GLASS_PANE)
                                .key('G', Items.GOLD_INGOT)
                                .key('I', Items.IRON_INGOT)
                                .key('R', ModItems.MAGNETITE.get())
                                .key('H', Blocks.HOPPER)
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, ModBlocks.MAGNETIC_PROJECTOR.get().getRegistryName());


        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("insulator"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_INSULATOR.get())
                                .patternLine("MIM")
                                .patternLine("GIG")
                                .patternLine("III")
                                .key('G', Items.GOLD_INGOT)
                                .key('I', Items.IRON_INGOT)
                                .key('M', ModItems.MAGNETITE.get())
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, ModBlocks.MAGNETIC_INSULATOR.get().getRegistryName());

    }

    private void registerItemRecipes(Consumer<IFinishedRecipe> consumer) {
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_STONE.get(), Blocks.COBBLESTONE.asItem());
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_IRON.get(), Items.IRON_INGOT);
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_REDSTONE.get(), Items.REDSTONE);
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_GOLD.get(), Items.GOLD_INGOT);
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_OBSIDIAN.get(), Blocks.OBSIDIAN.asItem());
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_LAPIS.get(), Items.LAPIS_LAZULI);
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_DIAMOND.get(), Items.DIAMOND);
        addMagnetD(consumer, ModItems.MAGNET_DURABILITY_EMERALD.get(), Items.EMERALD);
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_STONE.get(), ModItems.MAGNET_DURABILITY_STONE.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_IRON.get(), ModItems.MAGNET_DURABILITY_IRON.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_REDSTONE.get(), ModItems.MAGNET_DURABILITY_REDSTONE.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_GOLD.get(), ModItems.MAGNET_DURABILITY_GOLD.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_OBSIDIAN.get(), ModItems.MAGNET_DURABILITY_OBSIDIAN.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_LAPIS.get(), ModItems.MAGNET_DURABILITY_LAPIS.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_DIAMOND.get(), ModItems.MAGNET_DURABILITY_DIAMOND.get());
        addMagnetDM(consumer, ModItems.MAGNET_MAGIC_DURABILITY_EMERALD.get(), ModItems.MAGNET_DURABILITY_EMERALD.get());

        addMagnetE_start(consumer, ModItems.MAGNET_ENERGY_LEADSTONE.get());
        addMagnetE(consumer, ModItems.MAGNET_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get(), Blocks.OBSIDIAN.asItem(), Items.IRON_INGOT);
        addMagnetE(consumer, ModItems.MAGNET_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_HARDENED.get(), Items.GOLD_INGOT, Blocks.OBSIDIAN.asItem());
        addMagnetE(consumer, ModItems.MAGNET_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_REINFORCED.get(), Items.REDSTONE, Items.GOLD_INGOT);
        addMagnetE(consumer, ModItems.MAGNET_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get(), Items.ENDER_PEARL, Items.DIAMOND);
        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_LEADSTONE.get(), ModItems.MAGNET_ENERGY_LEADSTONE.get());
        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_HARDENED.get(), ModItems.MAGNET_ENERGY_HARDENED.get());
        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_REINFORCED.get(), ModItems.MAGNET_ENERGY_REINFORCED.get());
        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_SIGNALUM.get(), ModItems.MAGNET_ENERGY_SIGNALUM.get());
        addMagnetEM(consumer, ModItems.MAGNET_MAGIC_ENERGY_RESONANT.get(), ModItems.MAGNET_ENERGY_RESONANT.get());

        addMagnetF(consumer, ModItems.MAGNET_FREE.get());
        addMagnetFM(consumer, ModItems.MAGNET_MAGIC_FREE.get(), ModItems.MAGNET_FREE.get());

    }

    private void addMagnetD(Consumer<IFinishedRecipe> consumer, Item magnet, Item resource) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("vanilla"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("RIR")
                                .patternLine("I I")
                                .patternLine("M M")
                                .key('M', ModItems.MAGNETITE.get())
                                .key('I', Items.IRON_INGOT)
                                .key('R', resource)
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetDM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("vanilla_magic"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("GEG")
                                .patternLine("RMR")
                                .patternLine("GEG")
                                .key('R', ModItems.MAGNETITE.get())
                                .key('G', Items.GOLD_INGOT)
                                .key('E', Items.ENDER_PEARL)
                                .key('M', magnetPrior)
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetE_start(Consumer<IFinishedRecipe> consumer, Item magnet) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("te"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("INI")
                                .patternLine("IRI")
                                .patternLine("IGI")
                                .key('N', Items.GOLD_NUGGET)
                                .key('I', Items.IRON_INGOT)
                                .key('G', Items.GOLD_INGOT)
                                .key('R', Items.REDSTONE)
                                .addCriterion("has_redstone", hasItem(Items.REDSTONE))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetE(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior, Item resourceOne, Item resourceTwo) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("te"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine(" A ")
                                .patternLine("BMB")
                                .patternLine(" A ")
                                .key('M', magnetPrior)
                                .key('A', resourceOne)
                                .key('B', resourceTwo)
                                .addCriterion("has_magnet", hasItem(magnetPrior))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetEM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("te_magic"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("GEG")
                                .patternLine("RMR")
                                .patternLine("GEG")
                                .key('R', Items.REDSTONE)
                                .key('G', Items.GOLD_INGOT)
                                .key('E', Items.ENDER_PEARL)
                                .key('M', magnetPrior)
                                .addCriterion("has_redstone", hasItem(Items.REDSTONE))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetF(Consumer<IFinishedRecipe> consumer, Item magnet) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("cursed"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("DGD")
                                .patternLine("ISI")
                                .patternLine("R R")
                                .key('D', Items.DIAMOND)
                                .key('G', Items.GHAST_TEAR)
                                .key('I', Items.IRON_INGOT)
                                .key('S', Blocks.SOUL_SAND.asItem())
                                .key('R', ModItems.MAGNETITE.get())
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

    private void addMagnetFM(Consumer<IFinishedRecipe> consumer, Item magnet, Item magnetPrior) {
        ConditionalRecipe.builder()
                .addCondition(new ConditionModuleEnabled("cursed_magic"))
                .addRecipe(
                        ShapedRecipeBuilder.shapedRecipe(magnet)
                                .patternLine("GEG")
                                .patternLine("RMR")
                                .patternLine("GEG")
                                .key('R', ModItems.MAGNETITE.get())
                                .key('G', Items.GOLD_INGOT)
                                .key('E', Items.ENDER_PEARL)
                                .key('M', magnetPrior)
                                .addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
                                ::build
                ).build(consumer, magnet.getRegistryName());
    }

}
```


Overlapping Code:
```
nings({"ConstantConditions", "Duplicates"})
public class GeneratorRecipes extends RecipeProvider implements IConditionBuilder {
public GeneratorRecipes(DataGenerator generator) {
super(generator);
}
@Override
protected void registerRecipes(Consumer<IFinishedRecipe> consumer) {
registerBlockRecipes(consumer);
registerItemRecipes(consumer);
}
private void registerBlockRecipes(Consumer<IFinishedRecipe> consumer) {
ConditionalRecipe.builder()
.addCondition(new ConditionModuleEnabled("projector"))
.addRecipe(
ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_PROJECTOR.get())
.patternLine("IPI")
.patternLine("GRG")
.patternLine("IHI")
.key('P', Blocks.GLASS_PANE)
.key('G', Items.GOLD_INGOT)
.key('I', Items.IRON_INGOT)
.key('R', ModItems.MAGNETITE.get())
.key('H', Blocks.HOPPER)
.addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
::build
).build(consumer, ModBlocks.MAGNETIC_PROJECTOR.get().getRegistryName());
ConditionalRecipe.builder()
.addCondition(new ConditionModuleEnabled("insulator"))
.addRecipe(
ShapedRecipeBuilder.shapedRecipe(ModBlocks.MAGNETIC_INSULATOR.get())
.patternLine("MIM")
.patternLine("GIG")
.patternLine("III")
.key('G', Items.GOLD_INGOT)
.key('I', Items.IRON_INGOT)
.key('M', ModItems.MAGNETITE.get())
.addCriterion("has_magnetite", hasItem(ModItems.MAGNETITE.get()))
::build
).build(consumer, ModBlocks.MAGNETIC_INSULATOR.get().getRegistryName());
}
private void registerItemRecipes(Consumer<IFinishedRecipe> consumer) {
addMagnetD(consumer, ModItems.MAGNET_DURABILITY_STONE.get(), Blocks.COBBLESTONE.asItem());
addMagnetD(consumer, ModItems.MAGNET_DURABILITY_IRON.get(), Items.IRON_INGOT);
addMagnetD(consumer, Mo
```
<Overlap Ratio: 0.9916417910447761>

---

--- 100 --
Question ID: dbf6542e8a615f8e73d4b26963728bffdc32e5a8
Original Code:
```
public class PartitionHashRecordV2 extends VisorDataTransferObject {
    /** */
    private static final long serialVersionUID = 0L;

    /** Moving partition size. */
    public static final long MOVING_PARTITION_SIZE = Long.MIN_VALUE;

    /** Partition key. */
    @GridToStringExclude
    private PartitionKeyV2 partKey;

    /** Is primary flag. */
    private boolean isPrimary;

    /** Consistent id. */
    @GridToStringInclude
    private Object consistentId;

    /** Partition hash. */
    @GridToStringExclude
    private int partHash;

    /** Update counter. */
    private long updateCntr;

    /** Size. */
    @GridToStringExclude
    private long size;

    /**
     * @param partKey Partition key.
     * @param isPrimary Is primary.
     * @param consistentId Consistent id.
     * @param partHash Partition hash.
     * @param updateCntr Update counter.
     * @param size Size.
     */
    public PartitionHashRecordV2(PartitionKeyV2 partKey, boolean isPrimary,
        Object consistentId, int partHash, long updateCntr, long size) {
        this.partKey = partKey;
        this.isPrimary = isPrimary;
        this.consistentId = consistentId;
        this.partHash = partHash;
        this.updateCntr = updateCntr;
        this.size = size;
    }

    /**
     * Default constructor for Externalizable.
     */
    public PartitionHashRecordV2() {
    }

    /**
     * @return Partition key.
     */
    public PartitionKeyV2 partitionKey() {
        return partKey;
    }

    /**
     * @return Is primary.
     */
    public boolean isPrimary() {
        return isPrimary;
    }

    /**
     * @return Consistent id.
     */
    public Object consistentId() {
        return consistentId;
    }

    /**
     * @return Partition hash.
     */
    public int partitionHash() {
        return partHash;
    }

    /**
     * @return Update counter.
     */
    public long updateCounter() {
        return updateCntr;
    }

    /**
     * @return Size.
     */
    public long size() {
        return size;
    }

    /** {@inheritDoc} */
    @Override protected void writeExternalData(ObjectOutput out) throws IOException {
        out.writeObject(partKey);
        out.writeBoolean(isPrimary);
        out.writeObject(consistentId);
        out.writeInt(partHash);
        out.writeLong(updateCntr);
        out.writeLong(size);
    }

    /** {@inheritDoc} */
    @Override protected void readExternalData(byte protoVer, ObjectInput in) throws IOException, ClassNotFoundException {
        partKey = (PartitionKeyV2)in.readObject();
        isPrimary = in.readBoolean();
        consistentId = in.readObject();
        partHash = in.readInt();
        updateCntr = in.readLong();
        size = in.readLong();
    }

    /** {@inheritDoc} */
    @Override public String toString() {
        return size == MOVING_PARTITION_SIZE ?
            S.toString(PartitionHashRecordV2.class, this, "state", "MOVING") :
            S.toString(PartitionHashRecordV2.class, this, "size", size, "partHash", partHash);
    }

    /** {@inheritDoc} */
    @Override public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;

        PartitionHashRecordV2 record = (PartitionHashRecordV2)o;

        return consistentId.equals(record.consistentId);
    }

    /** {@inheritDoc} */
    @Override public int hashCode() {
        return consistentId.hashCode();
    }
}
```


Overlapping Code:
```
tionHashRecordV2 extends VisorDataTransferObject {
/** */
private static final long serialVersionUID = 0L;
/** Moving partition size. */
public static final long MOVING_PARTITION_SIZE = Long.MIN_VALUE;
/** Partition key. */
@GridToStringExclude
private PartitionKeyV2 partKey;
/** Is primary flag. */
private boolean isPrimary;
/** Consistent id. */
@GridToStringInclude
private Object consistentId;
/** Partition hash. */
@GridToStringExclude
private int partHash;
/** Update counter. */
private long updateCntr;
/** Size. */
@GridToStringExclude
private long size;
/**
* @param partKey Partition key.
* @param isPrimary Is primary.
* @param consistentId Consistent id.
* @param partHash Partition hash.
* @param updateCntr Update counter.
* @param size Size.
*/
public PartitionHashRecordV2(PartitionKeyV2 partKey, boolean isPrimary,
Object consistentId, int partHash, long updateCntr, long size) {
this.partKey = partKey;
this.isPrimary = isPrimary;
this.consistentId = consistentId;
this.partHash = partHash;
this.updateCntr = updateCntr;
this.size = size;
}
/**
* Default constructor for Externalizable.
*/
public PartitionHashRecordV2() {
}
/**
* @return Partition key.
*/
public PartitionKeyV2 partitionKey() {
return partKey;
}
/**
* @return Is primary.
*/
public boolean isPrimary() {
return isPrimary;
}
/**
* @return Consistent id.
*/
public Object consistentId() {
return consistentId;
}
/**
* @return Partition hash.
*/
public int partitionHash() {
return partHash;
}
/**
* @return Update counter.
*/
public long updateCounter() {
return updateCntr;
}
/**
* @return Size.
*/
public long size() {
return size;
}
/** {@inheritDoc} */
@Override protected void writeExternalData(ObjectOutput out) throws IOException {
out.writeObject(partKey);
out.writeBoolean(isPrimary);
out.writeObject(consistentId);
out.writeInt(partHash);
out.writeLong(updateCntr);
out.writeLong(size);
}
/** {@inheritDoc} */
@Override protected void readExternalData(byte protoVer, ObjectInput in) throws IOException, ClassNotFo
```
<Overlap Ratio: 0.9911286347954658>

---

--- 101 --
Question ID: 9eb0ea9c511874a4964887fce55de921883a147a
Original Code:
```
public class ClearCaseScmProvider
    extends AbstractScmProvider
{
    // ----------------------------------------------------------------------
    // ScmProvider Implementation
    // ----------------------------------------------------------------------

    /**
     * Contains parameters loaded from clearcase-settings.xml
     */
    private Settings settings;

    /** {@inheritDoc} */
    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )
        throws ScmRepositoryException
    {
        settings = ClearCaseUtil.getSettings();
        return new ClearCaseScmProviderRepository( getLogger(), scmSpecificUrl, settings );
    }

    /** {@inheritDoc} */
    public String getScmType()
    {
        return "clearcase";
    }

    /** {@inheritDoc} */
    public boolean requiresEditMode()
    {
        return true;
    }

    /** {@inheritDoc} */
    public ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,
                                         CommandParameters parameters )
        throws ScmException
    {
        ClearCaseChangeLogCommand command = new ClearCaseChangeLogCommand();

        command.setLogger( getLogger() );

        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    public CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,
                                     CommandParameters parameters )
        throws ScmException
    {
        ClearCaseCheckInCommand command = new ClearCaseCheckInCommand();

        command.setLogger( getLogger() );

        return (CheckInScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    public CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,
                                       CommandParameters parameters )
        throws ScmException
    {
        ClearCaseCheckOutCommand command = new ClearCaseCheckOutCommand();

        command.setLogger( getLogger() );
        command.setSettings( settings );

        return (CheckOutScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet,
                                      CommandParameters parameters )
        throws ScmException
    {
        ClearCaseUpdateCommand command = new ClearCaseUpdateCommand();

        command.setLogger( getLogger() );

        return (UpdateScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    public TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )
        throws ScmException
    {
        ClearCaseTagCommand command = new ClearCaseTagCommand();

        command.setLogger( getLogger() );

        return (TagScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet,
                                      CommandParameters parameters )
        throws ScmException
    {
        ClearCaseStatusCommand command = new ClearCaseStatusCommand();

        command.setLogger( getLogger() );

        return (StatusScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet,
                                  CommandParameters parameters )
        throws ScmException
    {
        ClearCaseEditCommand command = new ClearCaseEditCommand();

        command.setLogger( getLogger() );

        return (EditScmResult) command.execute( repository, fileSet, parameters );
    }

    /** {@inheritDoc} */
    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters parameters )
        throws ScmException
    {
        ClearCaseBlameCommand command = new ClearCaseBlameCommand();

        command.setLogger( getLogger() );

        return (BlameScmResult) command.execute( repository, fileSet, parameters );
    }
}
```


Overlapping Code:
```

extends AbstractScmProvider
{
// ----------------------------------------------------------------------
// ScmProvider Implementation
// ----------------------------------------------------------------------
/**
* Contains parameters loaded from clearcase-settings.xml
*/
private Settings settings;
/** {@inheritDoc} */
public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )
throws ScmRepositoryException
{
settings = ClearCaseUtil.getSettings();
return new ClearCaseScmProviderRepository( getLogger(), scmSpecificUrl, settings );
}
/** {@inheritDoc} */
public String getScmType()
{
return "clearcase";
}
/** {@inheritDoc} */
public boolean requiresEditMode()
{
return true;
}
/** {@inheritDoc} */
public ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,
CommandParameters parameters )
throws ScmException
{
ClearCaseChangeLogCommand command = new ClearCaseChangeLogCommand();
command.setLogger( getLogger() );
return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );
}
/** {@inheritDoc} */
public CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet,
CommandParameters parameters )
throws ScmException
{
ClearCaseCheckInCommand command = new ClearCaseCheckInCommand();
command.setLogger( getLogger() );
return (CheckInScmResult) command.execute( repository, fileSet, parameters );
}
/** {@inheritDoc} */
public CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,
CommandParameters parameters )
throws ScmException
{
ClearCaseCheckOutCommand command = new ClearCaseCheckOutCommand();
command.setLogger( getLogger() );
command.setSettings( settings );
return (CheckOutScmResult) command.execute( repository, fileSet, parameters );
}
/** {@inheritDoc} */
protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet,
CommandParameters parameters )
throws ScmException
{
ClearC
```
<Overlap Ratio: 0.9640039447731755>

---

--- 102 --
Question ID: aa4c3f7f2b4db7166aca700427e9a616d038a789
Original Code:
```
public class FilterParser {

	// TODO @see org.odata4j.expression.ExpressionParser ... ;-)

	public static FilterExpression parse(String filterString) {
		Result r = nextCriteria(filterString, 0);
		FilterExpression expression = r.expression;
		while (r.position < filterString.length()) {
			r = nextCriteria(filterString, r.position + 1);
			expression = new FilterAndOrExpression(expression, r.expression);
		}
		return expression;
	}

	private static Result nextCriteria(String filterString, int fromIndex) {
		int indexOfNextEqualsSign = filterString.indexOf('=', fromIndex);
		assertChar(filterString, indexOfNextEqualsSign + 1, '"');

		String variablePath = filterString.substring(fromIndex, indexOfNextEqualsSign);

		int indexOfNextNonEscapedQuote = filterString.indexOf('\"', indexOfNextEqualsSign + 2);
		while (filterString.charAt(indexOfNextNonEscapedQuote - 1) == '\\') {
			indexOfNextNonEscapedQuote = filterString.indexOf('\"', indexOfNextNonEscapedQuote + 1);
		}

		String literal = filterString.substring(indexOfNextEqualsSign + 2, indexOfNextNonEscapedQuote);
		literal = literal.replace("\\\"", "\"");

		FilterCriteriaExpression expression = new FilterCriteriaExpression(variablePath, FilterOperator.EQUALS, literal);

		fromIndex = indexOfNextNonEscapedQuote + 1;
		if (fromIndex < filterString.length()) {
			assertChar(filterString, fromIndex, '+');
		}

		return new Result(expression, fromIndex);
	}

	private static class Result {
		FilterCriteriaExpression expression;
		int position;

		Result(FilterCriteriaExpression expression, int position) {
			this.expression = expression;
			this.position = position;
		}
	}

	private static void assertChar(String string, int pos, char expectedCharacter) {
		char charAtPos = string.charAt(pos);
		if (charAtPos != expectedCharacter) {
			throw new IllegalArgumentException("Expected character at position " + pos + " to be a '"
					+ expectedCharacter + "' but instead it's a " + charAtPos);
		}
	}

}
```


Overlapping Code:
```
odata4j.expression.ExpressionParser ... ;-)
public static FilterExpression parse(String filterString) {
Result r = nextCriteria(filterString, 0);
FilterExpression expression = r.expression;
while (r.position < filterString.length()) {
r = nextCriteria(filterString, r.position + 1);
expression = new FilterAndOrExpression(expression, r.expression);
}
return expression;
}
private static Result nextCriteria(String filterString, int fromIndex) {
int indexOfNextEqualsSign = filterString.indexOf('=', fromIndex);
assertChar(filterString, indexOfNextEqualsSign + 1, '"');
String variablePath = filterString.substring(fromIndex, indexOfNextEqualsSign);
int indexOfNextNonEscapedQuote = filterString.indexOf('\"', indexOfNextEqualsSign + 2);
while (filterString.charAt(indexOfNextNonEscapedQuote - 1) == '\\') {
indexOfNextNonEscapedQuote = filterString.indexOf('\"', indexOfNextNonEscapedQuote + 1);
}
String literal = filterString.substring(indexOfNextEqualsSign + 2, indexOfNextNonEscapedQuote);
literal = literal.replace("\\\"", "\"");
FilterCriteriaExpression expression = new FilterCriteriaExpression(variablePath, FilterOperator.EQUALS, literal);
fromIndex = indexOfNextNonEscapedQuote + 1;
if (fromIndex < filterString.length()) {
assertChar(filterString, fromIndex, '+');
}
return new Result(expression, fromIndex);
}
private static class Result {
FilterCriteriaExpression expression;
int position;
Result(FilterCriteriaExpression expression, int position) {
this.expression = expression;
this.position = position;
}
}
private static void assertChar(String string, int pos, char expectedCharacter) {
char charAtPos = string.charAt(pos);
if (charAtPos != expectedCharacter) {
throw new IllegalArgumentException("Expected character at position " + pos + " to be a '"
+ expectedCharacter + "' but in
```
<Overlap Ratio: 0.9579563597658329>

---

--- 103 --
Question ID: 0101e6e78661e2797114a2be1fe852ba952bb5c0
Original Code:
```
public class DimensionTest {

    @After
    public void tearDown() throws Exception {}

    @Test
    public void testAspect() {
        AspectRatioDimension dim4x3 = new AspectRatioDimension(4, 3);
        assertTrue(dim4x3.check(640, 480));
        assertTrue(dim4x3.check(480, 360));
        assertFalse(dim4x3.check(640, 360));
        AspectRatioDimension dim16x9 = new AspectRatioDimension(16, 9);
        assertFalse(dim16x9.check(640, 480));
        assertFalse(dim16x9.check(480, 360));
        assertTrue(dim16x9.check(640, 360));
    }

}
```


Overlapping Code:
```
nTest {
@After
public void tearDown() throws Exception {}
@Test
public void testAspect() {
AspectRatioDimension dim4x3 = new AspectRatioDimension(4, 3);
assertTrue(dim4x3.check(640, 480));
assertTrue(dim4x3.check(480, 360));
assertFalse(dim4x3.check(640, 360));
AspectRatioDimension dim16x9 = new AspectRatioDimension(16, 9);
assertFalse(dim16x9.check(640, 480));
assertFalse(dim16x9.check(480, 360));
```
<Overlap Ratio: 0.8660907127429806>

---

--- 104 --
Question ID: 57b0d23dbeb06e2306f5091c6ab4ba6f93eb9210
Original Code:
```
@Controller
@RequestMapping(path = "/people")
@Secured("ROLE_USER")
@Slf4j
@RequiredArgsConstructor
class PeopleController {

  private final RestTemplate template;

  @GetMapping
  public String getAllPeople(Model model) {
    LOGGER.info("GetAllPeople: Authentication={}", getContext().getAuthentication());

    ResponseEntity<List<Person>> people =
        template.exchange("/", GET, null, new ParameterizedTypeReference<>() {
        });

    model.addAttribute("people", people.getBody());

    return "people";
  }

  @GetMapping(path = "/{id}")
  public String getPersonById(@PathVariable UUID id, Model model) {
    LOGGER.info("GetPersonById: Id={}, Authentication={}", id, getContext().getAuthentication());

    var person = template.getForObject("/" + id.toString(), Person.class);

    model.addAttribute("person", person);

    return "person";
  }
}
```


Overlapping Code:
```
r
@RequestMapping(path = "/people")
@Secured("ROLE_USER")
@Slf4j
@RequiredArgsConstructor
class PeopleController {
private final RestTemplate template;
@GetMapping
public String getAllPeople(Model model) {
LOGGER.info("GetAllPeople: Authentication={}", getContext().getAuthentication());
ResponseEntity<List<Person>> people =
template.exchange("/", GET, null, new ParameterizedTypeReference<>() {
});
model.addAttribute("people", people.getBody());
return "people";
}
@GetMapping(path = "/{id}")
public String getPersonById(@PathVariable UUID id, Model model) {
LOGGER.info("GetPersonById: Id={}, Authentication={}", id, getContext().getAuthentication());
var person = template.getForObject("/" + id.toString(), Person.class);
model.addAttribute("person", person);
return "pers
```
<Overlap Ratio: 0.9773584905660377>

---

--- 105 --
Question ID: 65fae0c076d5b89cfee5e25f05834c7db68f592d
Original Code:
```
public class Wizard {

    /*
     * telport:
     *	Bamf the hero someplace else
     */
    public static void teleport(Player player) {
        AbstractCoordinate c = new Coordinate();

        Display.mvaddch(player.getPosition(), Pack.floor_at().getValue());
        DrawRoom.find_floor(null, c, false, true);
        if (!Chase.roomin(c).equals(player.getRoom())) {
            Rooms.leave_room(player.getPosition());
            player.setPosition(c);
            Rooms.enter_room(player.getPosition());
        } else {
            player.setPosition(c);
            Misc.look(true);
        }
        Display.mvaddch(player.getPosition(), ObjectType.PLAYER.getValue());
        /*
         * turn off ISHELD in case teleportation was done while fighting
         * a Flytrap
         */
        if (player.containsState(StateEnum.ISHELD)) {

            player.removeState(StateEnum.ISHELD);
            Global.vf_hit = 0;
            for (OriginalMonster mp : Global.mlist) {
                if (mp.getType() == 'F')
                    mp.getStatus().s_dmg = "0x0";
            }
        }
        Global.no_move = 0;
        Global.count = 0;
        Global.running = false;
        Mach_dep.flush_type();
    }

    /*
     * whatIs:
     *	What a certin object is
     */
    public static void whatIs(Player player, boolean insist, int type) {

        if (player.getBaggageSize() == 0) {
            IOUtil.msg("you don't have anything in your pack to identify");
            return;
        }

        Thing obj;
        for (; ; ) {
            obj = Pack.get_item("identify", ObjectType.get((char) type));
            if (insist) {
                if (Global.n_objs == 0) {
                    return;
                } else if (obj == null) {
                    IOUtil.msg("you must identify something");
                } else if (type != 0 && obj.getDisplay().getValue() != type &&
                        !(type == Const.R_OR_S && (obj instanceof Ring || obj instanceof Stick))) {
                    IOUtil.msg("you must identify a %s", type_name(type));
                } else {
                    break;
                }
            } else {
                break;
            }
        }

        if (obj == null) {
            return;
        }

        if (obj instanceof Scroll) {
            set_know(obj, Global.scr_info);
        } else if (obj instanceof Potion) {
            set_know(obj, Global.pot_info);
        } else if (obj instanceof Stick) {
            set_know(obj, Global.ws_info);
        } else if (obj instanceof Weapon || obj instanceof Armor) {
            obj.add_o_flags(Const.ISKNOW);
        } else if (obj instanceof Ring) {
            set_know(obj, Global.ring_info);
        }
        IOUtil.msg(ThingMethod.inventoryName(obj, false));
    }

    /*
     * set_know:
     *	Set things up when we really know what a thing is
     */
    private static void set_know(Thing obj, Obj_info[] info) {
        info[obj.getNumber()].know();
        obj.add_o_flags(Const.ISKNOW);
    }

    /*
     * type_name:
     *	Return a pointer to the name of the type
     */
    static String type_name(int type) {
        List<Help_list> tlist = new ArrayList<>();
        {
            Help_list h = new Help_list(ObjectType.POTION.getValue(), "potion", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.SCROLL.getValue(), "scroll", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.FOOD.getValue(), "food", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list((char) Const.R_OR_S, "ring, wand or staff", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.RING.getValue(), "ring", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.STICK.getValue(), "wand or staff", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.WEAPON.getValue(), "weapon", false);
            tlist.add(h);
        }
        {
            Help_list h = new Help_list(ObjectType.ARMOR.getValue(), "suit of armor", false);
            tlist.add(h);
        }

        for (Help_list hp : tlist) {
            if (type == hp.h_ch) {
                return hp.h_desc;
            }
        }
        /* NOTREACHED */
        return "";
    }


}
```


Overlapping Code:
```
Wizard {
/*
* telport:
* Bamf the hero someplace else
*/
public static void teleport(Player player) {
AbstractCoordinate c = new Coordinate();
Display.mvaddch(player.getPosition(), Pack.floor_at().getValue());
DrawRoom.find_floor(null, c, false, true);
if (!Chase.roomin(c).equals(player.getRoom())) {
Rooms.leave_room(player.getPosition());
player.setPosition(c);
Rooms.enter_room(player.getPosition());
} else {
player.setPosition(c);
Misc.look(true);
}
Display.mvaddch(player.getPosition(), ObjectType.PLAYER.getValue());
/*
* turn off ISHELD in case teleportation was done while fighting
* a Flytrap
*/
if (player.containsState(StateEnum.ISHELD)) {
player.removeState(StateEnum.ISHELD);
Global.vf_hit = 0;
for (OriginalMonster mp : Global.mlist) {
if (mp.getType() == 'F')
mp.getStatus().s_dmg = "0x0";
}
}
Global.no_move = 0;
Global.count = 0;
Global.running = false;
Mach_dep.flush_type();
}
/*
* whatIs:
* What a certin object is
*/
public static void whatIs(Player player, boolean insist, int type) {
if (player.getBaggageSize() == 0) {
IOUtil.msg("you don't have anything in your pack to identify");
return;
}
Thing obj;
for (; ; ) {
obj = Pack.get_item("identify", ObjectType.get((char) type));
if (insist) {
if (Global.n_objs == 0) {
return;
} else if (obj == null) {
IOUtil.msg("you must identify something");
} else if (type != 0 && obj.getDisplay().getValue() != type &&
!(type == Const.R_OR_S && (obj instanceof Ring || obj instanceof Stick))) {
IOUtil.msg("you must identify a %s", type_name(type));
} else {
break;
}
} else {
break;
}
}
if (obj == null) {
return;
}
if (obj instanceof Scroll) {
set_know(obj, Global.scr_info);
} else if (obj instanceof Potion) {
set_know(obj, Global
```
<Overlap Ratio: 0.9664582148948266>

---

--- 106 --
Question ID: 72a1754027ce6cde68357c134bba2f46e9cbe0a3
Original Code:
```
public class CustomSignalInfoUnit implements SignalInfoUnitInterface {
	private static final Logger logger = LoggerFactory.getLogger(CustomSignalInfoUnit.class); 
	private int cusSigId;
	private boolean ifNotifing;
	private boolean ifAlarm;
	private short alarmClass;
	private short alarmDelayBef;
	private short alarmDelayAft;
	private boolean ifDisplay;
	/* custom signal name language map */
	private Map<Integer, String> signalNameLangMap;
	/* custom signal unit language map */
	private Map<Integer, String> signalUnitLangMap;
	/* custom group language map */
	private Map<Integer, String> groupLangMap;
	/* custom enumerate signal language map */
	private Map<Integer, Map<Integer, String> > signalEnumLangMap;
	/* custom alarm info */
	
	private SignalInterface customSignalInterface;
	private Object signalValue;
	

	public CustomSignalInfoUnit(int cusSigId, boolean ifNotifing, boolean ifAlarm, short alarmClass,
			short alarmDelayBef, short alarmDelayAft, boolean ifDisplay, Map<Integer, String> signalNameLangMap,
			Map<Integer, String> signalUnitLangMap, Map<Integer, String> groupLangMap,
			Map<Integer, Map<Integer, String>> signalEnumLangMap, SignalInterface customSignalInterface) {
		super();
		this.cusSigId = cusSigId;
		this.ifNotifing = ifNotifing;
		this.ifAlarm = ifAlarm;
		this.alarmClass = alarmClass;
		this.alarmDelayBef = alarmDelayBef;
		this.alarmDelayAft = alarmDelayAft;
		this.ifDisplay = ifDisplay;
		this.signalNameLangMap = signalNameLangMap;
		this.signalUnitLangMap = signalUnitLangMap;
		this.groupLangMap = groupLangMap;
		this.signalEnumLangMap = signalEnumLangMap;
		this.customSignalInterface = customSignalInterface;
	}
	
	public boolean isIfNotifing() {
		return ifNotifing;
	}
	public boolean isIfAlarm() {
		return ifAlarm;
	}
	public boolean isIfDisplay() {
		return ifDisplay;
	}
	public Map<Integer, String> getSignalNameLangMap() {
		return signalNameLangMap;
	}
	public Map<Integer, String> getGroupLangMap() {
		return groupLangMap;
	}
	public Map<Integer, Map<Integer, String>> getSignalEnumLangMap() {
		return signalEnumLangMap;
	}

	@Override
	public String toString() {
		return "CustomSignalInfoUnit [cusSigId=" + cusSigId + ", ifNotifing=" + ifNotifing + ", ifAlarm=" + ifAlarm
				+ ", alarmClass=" + alarmClass + ", alarmDelayBef=" + alarmDelayBef + ", alarmDelayAft=" + alarmDelayAft
				+ ", ifDisplay=" + ifDisplay + ", signalNameLangMap=" + signalNameLangMap + ", signalUnitLangMap="
				+ signalUnitLangMap + ", groupLangMap=" + groupLangMap + ", signalEnumLangMap=" + signalEnumLangMap
				+ ", customSignalInterface=" + customSignalInterface + ", signalValue=" + signalValue + "]";
	}

	@Override
	public boolean ifNotifying() {
		return ifNotifing;
	}
	@Override
	public int getSignalId() {
		return cusSigId;
	}
	@Override
	public SignalInterface getSignalInterface() {
		return customSignalInterface;
	}
	@Override
	public boolean ifConfigDef() {
		return false;
	}
	@Override
	public boolean ifAlarm() {
		return ifAlarm;
	}
	@Override
	public boolean ifDisplay() {
		return ifDisplay;
	}
	@Override
	public Map<Integer, String> getSignalUnitLangMap() {
		return signalUnitLangMap;
	}
	
	@Override
	public boolean putSignalValue(Entry<Integer, Map.Entry<Byte, Object>> entry) {
		boolean ret = false;
		try {
			signalValue = entry.getValue().getValue();
		} catch(Exception e) {
			Util.logger(logger, Util.ERROR, e);
			ret = false;
		}
		return ret;
	}
	
	@Override
	public boolean checkSignalValueUnformed(Byte valueType, Object value) {
		boolean ret = true;
		/* check if signal info exist */
		if(null == customSignalInterface) {
			return ret;
		}
		/* check if a alarm signal */
		if(!ifAlarm && (valueType & BPPacket.VAL_ALARM_FLAG) != 0) {
			return ret;
		}
		try {
			switch (valueType & BPPacket.VAL_TYPE_MASK) {
			case BPPacket.VAL_TYPE_UINT32: {
				CustomSignalU32InfoHbn customSignalU32InfoHbn = (CustomSignalU32InfoHbn)customSignalInterface;
				Long v = (Long)value;
				if(v >= customSignalU32InfoHbn.getMinVal() && v <= customSignalU32InfoHbn.getMaxVal()) {
					ret =false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_UINT16: {
				CustomSignalU16InfoHbn customSignalU16InfoHbn = (CustomSignalU16InfoHbn)customSignalInterface;
				Integer v = (Integer)value;
				if(v >= customSignalU16InfoHbn.getMinVal() && v <= customSignalU16InfoHbn.getMaxVal()) {
					ret =false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_IINT32: {
				CustomSignalI32InfoHbn customSignalI32InfoHbn = (CustomSignalI32InfoHbn)customSignalInterface;
				Integer v = (Integer)value;
				if(v >= customSignalI32InfoHbn.getMinVal() && v <= customSignalI32InfoHbn.getMaxVal()) {
					ret =false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_IINT16: {
				CustomSignalI16InfoHbn customSignalI16InfoHbn = (CustomSignalI16InfoHbn)customSignalInterface;
				Short v = (Short)value;
				if(v >= customSignalI16InfoHbn.getMinVal() && v <= customSignalI16InfoHbn.getMaxVal()) {
					ret =false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_ENUM: {
				Integer v = (Integer)value;
				Iterator<Map.Entry<Integer, Map<Integer, String> > > it = signalEnumLangMap.entrySet().iterator();
				if(it.hasNext()) {
					Map<Integer, String> signalEnumValueMap = it.next().getValue();
					if(null != signalEnumValueMap && signalEnumValueMap.containsKey(v)) {
						ret = false;
					}
				}
				
				break;
			}
			case BPPacket.VAL_TYPE_FLOAT: {
				CustomSignalFloatInfoHbn customSignalFloatInfoHbn = (CustomSignalFloatInfoHbn)customSignalInterface;
				Float v = (Float)value;
				if(v >= customSignalFloatInfoHbn.getMinVal() && v <= customSignalFloatInfoHbn.getMaxVal()) {
					ret =false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_STRING: {
				String v = (String)value;
				if(v.length() <= BPPacket.MAX_STR_LENGTH) {
					ret = false;
				}
				break;
			}
			case BPPacket.VAL_TYPE_BOOLEAN: {
				if(value instanceof Boolean) {
					ret = false;
				}
				
				break;
			}
			default:
				/* do nothing */
			}
		} catch (Exception e) {
			Util.logger(logger, Util.ERROR, e);
			ret = true;
		}
		return ret;
	}
	public Object getSignalValue() {
		return signalValue;
	}
	public void setSignalValue(Object signalValue) {
		this.signalValue = signalValue;
	}
	@Override
	public short getAlarmClass() {
		return alarmClass;
	}
	@Override
	public short getAlarmDelayBef() {
		return alarmDelayBef;
	}
	@Override
	public short getAlarmDelayAft() {
		return alarmDelayAft;
	}
}
```


Overlapping Code:
```
it implements SignalInfoUnitInterface {
private static final Logger logger = LoggerFactory.getLogger(CustomSignalInfoUnit.class); 
private int cusSigId;
private boolean ifNotifing;
private boolean ifAlarm;
private short alarmClass;
private short alarmDelayBef;
private short alarmDelayAft;
private boolean ifDisplay;
/* custom signal name language map */
private Map<Integer, String> signalNameLangMap;
/* custom signal unit language map */
private Map<Integer, String> signalUnitLangMap;
/* custom group language map */
private Map<Integer, String> groupLangMap;
/* custom enumerate signal language map */
private Map<Integer, Map<Integer, String> > signalEnumLangMap;
/* custom alarm info */

private SignalInterface customSignalInterface;
private Object signalValue;

public CustomSignalInfoUnit(int cusSigId, boolean ifNotifing, boolean ifAlarm, short alarmClass,
short alarmDelayBef, short alarmDelayAft, boolean ifDisplay, Map<Integer, String> signalNameLangMap,
Map<Integer, String> signalUnitLangMap, Map<Integer, String> groupLangMap,
Map<Integer, Map<Integer, String>> signalEnumLangMap, SignalInterface customSignalInterface) {
super();
this.cusSigId = cusSigId;
this.ifNotifing = ifNotifing;
this.ifAlarm = ifAlarm;
this.alarmClass = alarmClass;
this.alarmDelayBef = alarmDelayBef;
this.alarmDelayAft = alarmDelayAft;
this.ifDisplay = ifDisplay;
this.signalNameLangMap = signalNameLangMap;
this.signalUnitLangMap = signalUnitLangMap;
this.groupLangMap = groupLangMap;
this.signalEnumLangMap = signalEnumLangMap;
this.customSignalInterface = customSignalInterface;
}

public boolean isIfNotifing() {
return ifNotifing;
}
public boolean isIfAlarm() {
return ifAlarm;
}
public boolean isIfDisplay() {
return ifDisplay;
}
public Map<Integer, String> getSignalNameLangMap() {
return signalNameLangMap;
}
public Map<Integer, String> getGroupLangMap() {
return groupLangMap;
}
public Map<Integer, Map<Integer, String>> getSignalEnumLangMap() {
return signalEnumLangMap;
}
@Override
public String toString() {
return "CustomSignalInfoUnit [cusSigId=" + cusSigId + ", ifNotifing=" + ifNotifing + ", ifAlarm=" + ifAlarm
+ ", alarmClass=" + alarmClass + ", alarmDelayBef=" + alarmDelayBef + ", alarmDelayAft=" + alarmDelayAft
+ ", ifDisplay=" + ifDisplay + ", sign
```
<Overlap Ratio: 0.9696061643835616>

---

--- 107 --
Question ID: b3c8a8f3660a160fee6a89d53a895196ada747b1
Original Code:
```
public class TubeServiceImpl implements TubeService {
    private final TubeRepository tubeRepository;
    private final ModelMapper modelMapper;
    private final ValidationUtil validationUtil;

    @Inject
    public TubeServiceImpl(TubeRepository tubeRepository, ModelMapper modelMapper, ValidationUtil validationUtil) {
        this.tubeRepository = tubeRepository;
        this.modelMapper = modelMapper;
        this.validationUtil = validationUtil;
    }

    @Override
    public void saveTube(TubeServiceModel tubeServiceModel) throws IllegalAccessException {
        if(!this.validationUtil.isValid(tubeServiceModel)){
            throw new IllegalAccessException("Required fields are missing or incorrect.");
        }

        try{
            TubeDetailsViewModel tubeFromDb = this.getByName(tubeServiceModel.getName());
        }catch (NoResultException nre){
            Tube tube = this.modelMapper.map(tubeServiceModel, Tube.class);
            Tube savedTube = this.tubeRepository.save(tube);
            return;
        }

        throw new IllegalArgumentException(String.format("Tube with name - \"%s\" already exists", tubeServiceModel.getName()));
    }

    @Override
    public List<TubeAllViewModel> getAll() {
        List<Tube> tubeList = this.tubeRepository.getAll();

        List<TubeAllViewModel> allViewModels = tubeList.stream()
                .map(tube -> this.modelMapper.map(tube, TubeAllViewModel.class))
                .collect(Collectors.toList());

        return allViewModels;
    }

    @Override
    public TubeDetailsViewModel getByName(String name) {
        Tube tube = this.tubeRepository.findByName(name);
        if(tube != null){
            return this.modelMapper.map(tube, TubeDetailsViewModel.class);
        }

        return null;
    }
}
```


Overlapping Code:
```
blic class TubeServiceImpl implements TubeService {
private final TubeRepository tubeRepository;
private final ModelMapper modelMapper;
private final ValidationUtil validationUtil;
@Inject
public TubeServiceImpl(TubeRepository tubeRepository, ModelMapper modelMapper, ValidationUtil validationUtil) {
this.tubeRepository = tubeRepository;
this.modelMapper = modelMapper;
this.validationUtil = validationUtil;
}
@Override
public void saveTube(TubeServiceModel tubeServiceModel) throws IllegalAccessException {
if(!this.validationUtil.isValid(tubeServiceModel)){
throw new IllegalAccessException("Required fields are missing or incorrect.");
}
try{
TubeDetailsViewModel tubeFromDb = this.getByName(tubeServiceModel.getName());
}catch (NoResultException nre){
Tube tube = this.modelMapper.map(tubeServiceModel, Tube.class);
Tube savedTube = this.tubeRepository.save(tube);
return;
}
throw new IllegalArgumentException(String.format("Tube with name - \"%s\" already exists", tubeServiceModel.getName()));
}
@Override
public List<TubeAllViewModel> getAll() {
List<Tube> tubeList = this.tubeRepository.getAll();
List<TubeAllViewModel> allViewModels = tubeList.stream()
.map(tube -> this.modelMapper.map(tube, TubeAllViewModel.class))
.collect(Collectors.toList());
return allViewModels;
}
@Override
public TubeDetailsViewModel getByName(String name) {
Tube tube = this.tubeRepository.findByName(name);
if(tube != null){
return this.modelMapper.map(tube, TubeDetailsViewModel.class);
}
return 
```
<Overlap Ratio: 0.9926519706078825>

---

--- 108 --
Question ID: bb2801aa233354e620a22506010470ba263a6a95
Original Code:
```
public class ChainSkills {

    private Map<String, ChainSkill> multiSkills = new FastMap<String, ChainSkill>();
    private ChainSkill chainSkill = new ChainSkill("", 0, 0);

    //private Logger log = LoggerFactory.getLogger(ChainSkills.class);
    public int getChainCount(Player player, SkillTemplate template, String category) {
        if (category == null) {
            return 0;
        }
        long nullTime = player.getSkillCoolDown(template.getCooldownId());
        if (this.multiSkills.get(category) != null) {
            if (System.currentTimeMillis() >= nullTime && this.multiSkills.get(category).getUseTime() <= nullTime) {
                this.multiSkills.get(category).setChainCount(0);
            }

            return this.multiSkills.get(category).getChainCount();
        }

        return 0;
    }

    public long getLastChainUseTime(String category) {
        if (this.multiSkills.get(category) != null) {
            return this.multiSkills.get(category).getUseTime();
        } else if (chainSkill.getCategory().equals(category)) {
            return this.chainSkill.getUseTime();
        } else {
            return 0;
        }
    }

    /**
     * returns true if next chain skill can still be casted, or time is over
     *
     * @param category
     * @param time
     * @return
     */
    public boolean chainSkillEnabled(String category, int time) {
        long useTime = 0;
        if (this.multiSkills.get(category) != null) {
            useTime = this.multiSkills.get(category).getUseTime();
        } else if (chainSkill.getCategory().equals(category)) {
            useTime = chainSkill.getUseTime();
        }

        if ((useTime + time) >= System.currentTimeMillis()) {
            return true;
        } else {
            return false;
        }
    }

    public void addChainSkill(String category, boolean multiCast) {
        if (multiCast) {
            if (this.multiSkills.get(category) != null) {
                if (multiCast) {
                    this.multiSkills.get(category).increaseChainCount();
                }
                this.multiSkills.get(category).setUseTime(System.currentTimeMillis());
            } else {
                this.multiSkills.put(category, new ChainSkill(category, (multiCast ? 1 : 0), System.currentTimeMillis()));
            }
        } else {
            chainSkill.updateChainSkill(category);
        }
    }

    public Collection<ChainSkill> getChainSkills() {
        Collection<ChainSkill> collection = new ArrayList<ChainSkill>();
        collection.add(this.chainSkill);
        collection.addAll(this.multiSkills.values());

        return collection;
    }
}
```


Overlapping Code:
```
ing, ChainSkill> multiSkills = new FastMap<String, ChainSkill>();
private ChainSkill chainSkill = new ChainSkill("", 0, 0);
//private Logger log = LoggerFactory.getLogger(ChainSkills.class);
public int getChainCount(Player player, SkillTemplate template, String category) {
if (category == null) {
return 0;
}
long nullTime = player.getSkillCoolDown(template.getCooldownId());
if (this.multiSkills.get(category) != null) {
if (System.currentTimeMillis() >= nullTime && this.multiSkills.get(category).getUseTime() <= nullTime) {
this.multiSkills.get(category).setChainCount(0);
}
return this.multiSkills.get(category).getChainCount();
}
return 0;
}
public long getLastChainUseTime(String category) {
if (this.multiSkills.get(category) != null) {
return this.multiSkills.get(category).getUseTime();
} else if (chainSkill.getCategory().equals(category)) {
return this.chainSkill.getUseTime();
} else {
return 0;
}
}
/**
* returns true if next chain skill can still be casted, or time is over
*
* @param category
* @param time
* @return
*/
public boolean chainSkillEnabled(String category, int time) {
long useTime = 0;
if (this.multiSkills.get(category) != null) {
useTime = this.multiSkills.get(category).getUseTime();
} else if (chainSkill.getCategory().equals(category)) {
useTime = chainSkill.getUseTime();
}
if ((useTime + time) >= System.currentTimeMillis()) {
return true;
} else {
return false;
}
}
public void addChainSkill(String category, boolean multiCast) {
if (multiCast) {
if (this.multiSkills.get(category) != null) {
if (multiCast) {
this.multiSkills.get(category).increaseChainCount();
}
this.multiSkills.get(category).setUseTime(System.currentTimeMillis());
} else {
this.multiSkills.put(category, new ChainSkill(category, (multiCast ? 1 : 0), System.currentTimeMillis()));
}
} else {
chainSkill.updateChainSkill(category);
}
}
public Collection<ChainSkill> getChainSkills() {
Collect
```
<Overlap Ratio: 0.9693877551020408>

---

--- 109 --
Question ID: 8b76ab5038324a2f66e7e80e42c4876e04e6e1b2
Original Code:
```
public class DayOfTheProgrammer {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int year = scanner.nextInt();
        System.out.println(dayOfProgrammer(year));
    }

    private static String dayOfProgrammer(int year) {
        if (year == 1918) {
            return "26.09.1918";
        }
        return (isLeapYear(year) ? "12.09." : "13.09.") + year;
    }

    private static boolean isLeapYear(int year) {
        return (year <= 1917 && year % 4 == 0)
                || (year % 400 == 0 || (year  % 4 == 0 && year % 100 != 0));
    }
}
```


Overlapping Code:
```
ublic class DayOfTheProgrammer {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int year = scanner.nextInt();
System.out.println(dayOfProgrammer(year));
}
private static String dayOfProgrammer(int year) {
if (year == 1918) {
return "26.09.1918";
}
return (isLeapYear(year) ? "12.09." : "13.09.") + year;
}
private static boolean isLeapYear(int year) {
return (year <= 1917 && year % 4 == 0)
|| (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0))
```
<Overlap Ratio: 0.9877800407331976>

---

--- 110 --
Question ID: 2e363ad0cdf82d8e6f2607cd28e016e59c024894
Original Code:
```
public class SegmentSelectorTest {

    private final String scope = "scope";
    private final String streamName = "streamName";
    private final EventWriterConfig config = EventWriterConfig.builder().build();
    private final Consumer<Segment> segmentSealedCallback = segment -> { };

    @Test
    public void testUsesAllSegments() {
        Controller controller = Mockito.mock(Controller.class);
        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
        addNewSegment(segments, 0, 0.0, 0.25);
        addNewSegment(segments, 1, 0.25, 0.5);
        addNewSegment(segments, 2, 0.5, 0.75);
        addNewSegment(segments, 3, 0.75, 1.0);
        StreamSegments streamSegments = new StreamSegments(segments, "");

        when(controller.getCurrentSegments(scope, streamName))
               .thenReturn(CompletableFuture.completedFuture(streamSegments));
        selector.refreshSegmentEventWriters(segmentSealedCallback);
        int[] counts = new int[4];
        Arrays.fill(counts, 0);
        for (int i = 0; i < 20; i++) {
            Segment segment = selector.getSegmentForEvent("" + i);
            assertNotNull(segment);
            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;
        }
        for (int count : counts) {
            assertTrue(count > 1);
        }
    }

    private void addNewSegment(TreeMap<Double, SegmentWithRange> segments, int number, double low, double high) {
        segments.put(high, new SegmentWithRange(new Segment(scope, streamName, number), low, high));
    }

    @Test
    public void testNullRoutingKey() {
        Controller controller = Mockito.mock(Controller.class);
        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
        addNewSegment(segments, 0, 0.0, 0.25);
        addNewSegment(segments, 1, 0.25, 0.5);
        addNewSegment(segments, 2, 0.5, 0.75);
        addNewSegment(segments, 3, 0.75, 1.0);
        StreamSegments streamSegments = new StreamSegments(segments, "");

        when(controller.getCurrentSegments(scope, streamName))
               .thenReturn(CompletableFuture.completedFuture(streamSegments));
        selector.refreshSegmentEventWriters(segmentSealedCallback);
        int[] counts = new int[4];
        Arrays.fill(counts, 0);
        for (int i = 0; i < 100; i++) {
            Segment segment = selector.getSegmentForEvent(null);
            assertNotNull(segment);
            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;
        }
        for (int count : counts) {
            assertTrue(count > 1);
        }
    }

    @Test
    public void testSameRoutingKey() {
        Controller controller = Mockito.mock(Controller.class);
        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
        addNewSegment(segments, 0, 0.0, 0.25);
        addNewSegment(segments, 1, 0.25, 0.5);
        addNewSegment(segments, 2, 0.5, 0.75);
        addNewSegment(segments, 3, 0.75, 1.0);
        StreamSegments streamSegments = new StreamSegments(segments, "");

        when(controller.getCurrentSegments(scope, streamName))
               .thenReturn(CompletableFuture.completedFuture(streamSegments));
        selector.refreshSegmentEventWriters(segmentSealedCallback);
        int[] counts = new int[4];
        Arrays.fill(counts, 0);
        for (int i = 0; i < 20; i++) {
            Segment segment = selector.getSegmentForEvent("Foo");
            assertNotNull(segment);
            counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;
        }
        assertArrayEquals(new int[] { 20, 0, 0, 0 }, counts);
    }

    @Test
    public void testStreamDeletion() {
        final Segment segment0 = new Segment(scope, streamName, 0);
        final Segment segment1 = new Segment(scope, streamName, 1);
        final CompletableFuture<Void> writerFuture = new CompletableFuture<>();

        // Setup Mock.
        SegmentOutputStream s0Writer = Mockito.mock(SegmentOutputStream.class);
        SegmentOutputStream s1Writer = Mockito.mock(SegmentOutputStream.class);
        when(s0Writer.getUnackedEventsOnSeal())
                .thenReturn(ImmutableList.of(PendingEvent.withHeader("0", ByteBuffer.wrap("e".getBytes()), writerFuture)));

        SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
        when(factory.createOutputStreamForSegment(eq(segment0), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))
                .thenReturn(s0Writer);
        when(factory.createOutputStreamForSegment(eq(segment1), ArgumentMatchers.<Consumer<Segment>>any(), any(EventWriterConfig.class), anyString()))
                .thenReturn(s1Writer);

        Controller controller = Mockito.mock(Controller.class);
        SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
        TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
        addNewSegment(segments, 0, 0.0, 0.5);
        addNewSegment(segments, 1, 0.5, 1.0);
        StreamSegments streamSegments = new StreamSegments(segments, "");

        when(controller.getCurrentSegments(scope, streamName))
                .thenReturn(CompletableFuture.completedFuture(streamSegments));
        //trigger refresh.
        selector.refreshSegmentEventWriters(segmentSealedCallback);

        //simulate stream deletion where controller.getSuccessors() is completed exceptionally.
        when(controller.getSuccessors(segment0))
                .thenAnswer(i -> {
                    CompletableFuture<StreamSegmentsWithPredecessors> result = new CompletableFuture<>();
                    // Controller throws io.pravega.controller.store.stream.StoreException$DataNotFoundException which is type RuntimeException.
                    // Using RunTimeException here as the controller exception is not visible.
                    result.completeExceptionally(new RuntimeException());
                    return result;
                });

        assertEquals(Collections.emptyList(), selector.refreshSegmentEventWritersUponSealed(segment0, segmentSealedCallback));
        assertFutureThrows("Writer Future", writerFuture, t -> t instanceof NoSuchSegmentException);
    }

}
```


Overlapping Code:
```
public class SegmentSelectorTest {
private final String scope = "scope";
private final String streamName = "streamName";
private final EventWriterConfig config = EventWriterConfig.builder().build();
private final Consumer<Segment> segmentSealedCallback = segment -> { };
@Test
public void testUsesAllSegments() {
Controller controller = Mockito.mock(Controller.class);
SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
addNewSegment(segments, 0, 0.0, 0.25);
addNewSegment(segments, 1, 0.25, 0.5);
addNewSegment(segments, 2, 0.5, 0.75);
addNewSegment(segments, 3, 0.75, 1.0);
StreamSegments streamSegments = new StreamSegments(segments, "");
when(controller.getCurrentSegments(scope, streamName))
.thenReturn(CompletableFuture.completedFuture(streamSegments));
selector.refreshSegmentEventWriters(segmentSealedCallback);
int[] counts = new int[4];
Arrays.fill(counts, 0);
for (int i = 0; i < 20; i++) {
Segment segment = selector.getSegmentForEvent("" + i);
assertNotNull(segment);
counts[StreamSegmentNameUtils.getSegmentNumber(segment.getSegmentId())]++;
}
for (int count : counts) {
assertTrue(count > 1);
}
}
private void addNewSegment(TreeMap<Double, SegmentWithRange> segments, int number, double low, double high) {
segments.put(high, new SegmentWithRange(new Segment(scope, streamName, number), low, high));
}
@Test
public void testNullRoutingKey() {
Controller controller = Mockito.mock(Controller.class);
SegmentOutputStreamFactory factory = Mockito.mock(SegmentOutputStreamFactory.class);
SegmentSelector selector = new SegmentSelector(new StreamImpl(scope, streamName), controller, factory, config);
TreeMap<Double, SegmentWithRange> segments = new TreeMap<>();
addNewSegment(segments, 0, 0.0, 0.25);
addNewSegment(segments, 1, 0.25, 0.5);
addNewSegment(segments, 2, 0.5, 0.75);
addNewSegment(segments, 3, 0.75, 1.0);
StreamSegments streamSegments = new StreamSegments(segments, "");
when(controller.getCurrentSegments(scope, streamName))
```
<Overlap Ratio: 1.0>

---

--- 111 --
Question ID: 8b3b372e754c24f330a50b51e3f29c68b563e0e6
Original Code:
```
@SuppressWarnings("restriction")
public class GenericResolveContextResolveTest extends TestCase {

	private static final LogService	log	= new NullLogService();

	public static void testSimpleResolve() {

		Repository repository = createRepo(IO.getFile("testdata/repo3.index.xml"));
		GenericResolveContext grc = new GenericResolveContext(log);
		Resource framework = grc.getFrameworkResource(Arrays.asList(repository), "org.apache.felix.framework", null);

		List<Requirement> systemRequirements = new ArrayList<Requirement>();
		List<Capability> systemCapabilities = new ArrayList<Capability>();

		systemRequirements.addAll(framework.getRequirements(null));
		systemCapabilities.addAll(framework.getCapabilities(null));

		systemCapabilities.addAll(GenericResolveContext.getEECapabilities(EE.JavaSE_1_7));

		GenericResolveContext context = new GenericResolveContext(systemCapabilities, systemRequirements, log);

		context.addRepository(repository);

		Requirement requirement = GenericResolveContext.createBundleRequirement("org.apache.felix.gogo.shell", "[0,1)");
		context.addInputRequirement(GenericResolveContext.createBundleRequirement("org.apache.felix.gogo.shell", "[0,1)"));

		Resolver resolver = new BndResolver(new ResolverLogger(4));

		try {
			Map<Resource,List<Wire>> resolved = resolver.resolve(context);
			Set<Resource> resources = resolved.keySet();
			Resource resource = getResource(resources, "org.apache.felix.gogo.runtime", "0.10");
			assertNotNull(resource);
		}
		catch (ResolutionException e) {
			fail("Resolve failed");
		}
	}

	public static void testResolveRequirementNoDirective() {

		Repository repository = createRepo(IO.getFile("testdata/repo6/index.xml"));
		GenericResolveContext grc = new GenericResolveContext(log);

		GenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),
				Collections.<Requirement> emptyList(), log);

		context.addRepository(repository);

		List<Capability> providers = context.findProviders(new CapReqBuilder("osgi.service").addDirective("filter",
				"(objectClass=org.osgi.service.log.LogService)").buildSyntheticRequirement());

		assertEquals(2, providers.size());

		Set<String> resourceNames = new HashSet<String>();
		for(Capability cap : providers) {
			resourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE)
					.get(0).getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());
		}
		
		Set<String> expectedResourceNames = new HashSet<String>(Arrays.asList("test.a", "test.b"));
		
		assertEquals(expectedResourceNames, resourceNames);
	}

	public static void testResolveRequirementResolveDirective() {

		Repository repository = createRepo(IO.getFile("testdata/repo6/index.xml"));
		GenericResolveContext grc = new GenericResolveContext(log);

		GenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),
				Collections.<Requirement> emptyList(), log);

		context.addRepository(repository);

		List<Capability> providers = context.findProviders(new CapReqBuilder("osgi.service")
				.addDirective("filter", "(objectClass=org.osgi.service.log.LogService)")
				.addDirective("effective", "resolve").buildSyntheticRequirement());

		assertEquals(2, providers.size());

		Set<String> resourceNames = new HashSet<String>();
		for (Capability cap : providers) {
			resourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)
					.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());
		}

		Set<String> expectedResourceNames = new HashSet<String>(Arrays.asList("test.a", "test.b"));

		assertEquals(expectedResourceNames, resourceNames);
	}

	public static void testResolveRequirementActiveDirective() {

		Repository repository = createRepo(IO.getFile("testdata/repo6/index.xml"));
		GenericResolveContext grc = new GenericResolveContext(log);

		GenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),
				Collections.<Requirement> emptyList(), log);

		context.addRepository(repository);

		List<Capability> providers = context.findProviders(new CapReqBuilder("osgi.service")
				.addDirective("filter", "(objectClass=org.osgi.service.log.LogService)")
				.addDirective("effective", "active").buildSyntheticRequirement());

		assertEquals(3, providers.size());

		Set<String> resourceNames = new HashSet<String>();
		for (Capability cap : providers) {
			resourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE).get(0)
					.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());
		}

		Set<String> expectedResourceNames = new HashSet<String>(Arrays.asList("test.a", "test.b", "test.c"));

		assertEquals(expectedResourceNames, resourceNames);
	}

	private static Resource getResource(Set<Resource> resources, String bsn, String versionString) {
		for (Resource resource : resources) {
			List<Capability> identities = resource.getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE);
			if (identities != null && identities.size() == 1) {
				Capability idCap = identities.get(0);
				Object id = idCap.getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE);
				Object version = idCap.getAttributes().get(IdentityNamespace.CAPABILITY_VERSION_ATTRIBUTE);
				if (bsn.equals(id)) {
					if (versionString == null) {
						return resource;
					}
					Version requested = Version.parseVersion(versionString);
					Version current;
					if (version instanceof Version) {
						current = (Version) version;
					} else {
						current = Version.parseVersion((String) version);
					}
					if (requested.equals(current)) {
						return resource;
					}
				}
			}
		}
		return null;
	}
}
```


Overlapping Code:
```
triction")
public class GenericResolveContextResolveTest extends TestCase {
private static final LogService log = new NullLogService();
public static void testSimpleResolve() {
Repository repository = createRepo(IO.getFile("testdata/repo3.index.xml"));
GenericResolveContext grc = new GenericResolveContext(log);
Resource framework = grc.getFrameworkResource(Arrays.asList(repository), "org.apache.felix.framework", null);
List<Requirement> systemRequirements = new ArrayList<Requirement>();
List<Capability> systemCapabilities = new ArrayList<Capability>();
systemRequirements.addAll(framework.getRequirements(null));
systemCapabilities.addAll(framework.getCapabilities(null));
systemCapabilities.addAll(GenericResolveContext.getEECapabilities(EE.JavaSE_1_7));
GenericResolveContext context = new GenericResolveContext(systemCapabilities, systemRequirements, log);
context.addRepository(repository);
Requirement requirement = GenericResolveContext.createBundleRequirement("org.apache.felix.gogo.shell", "[0,1)");
context.addInputRequirement(GenericResolveContext.createBundleRequirement("org.apache.felix.gogo.shell", "[0,1)"));
Resolver resolver = new BndResolver(new ResolverLogger(4));
try {
Map<Resource,List<Wire>> resolved = resolver.resolve(context);
Set<Resource> resources = resolved.keySet();
Resource resource = getResource(resources, "org.apache.felix.gogo.runtime", "0.10");
assertNotNull(resource);
}
catch (ResolutionException e) {
fail("Resolve failed");
}
}
public static void testResolveRequirementNoDirective() {
Repository repository = createRepo(IO.getFile("testdata/repo6/index.xml"));
GenericResolveContext grc = new GenericResolveContext(log);
GenericResolveContext context = new GenericResolveContext(Collections.<Capability> emptyList(),
Collections.<Requirement> emptyList(), log);
context.addRepository(repository);
List<Capability> providers = context.findProviders(new CapReqBuilder("osgi.service").addDirective("filter",
"(objectClass=org.osgi.service.log.LogService)").buildSyntheticRequirement());
assertEquals(2, providers.size());
Set<String> resourceNames = new HashSet<String>();
for(Capability cap : providers) {
resourceNames.add(cap.getResource().getCapabilities(IdentityNamespace.IDENTITY_NAMESPACE)
.get(0).getAttributes().get(IdentityNamespace.IDENTITY_NAMESPACE).toString());
}

Set<String> expectedResour
```
<Overlap Ratio: 0.9832635983263598>

---

--- 112 --
Question ID: 7f98e684b1d2a1fb9e78c9bd66c9d22a1bdc2ef2
Original Code:
```
class X {
    void f() {
        int i = 2;
        // begin
        int o = 0; //mid
        // end
    }
}
```


Overlapping Code:
```
void f() {
int i = 2;
// begin
int o = 0; //mid
//
```
<Overlap Ratio: 0.7352941176470589>

---

--- 113 --
Question ID: ae58d6d724faca17f4d0b8242239003a15004a78
Original Code:
```
class Producer extends Thread { 
    static final int MAXQUEUE = 5; 
    private Vector messages = new Vector(); 
    public void run() { 
        try { 
            while ( true ) { 
                putMessage(); 
                sleep(1000); 
            } 
        }  
        catch( InterruptedException e ){} 
    } 
    private synchronized void putMessage() 
        throws InterruptedException { 

        while ( messages.size() == MAXQUEUE )
            wait(); 
        messages.addElement( new java.util.Date().toString() ); 
        notify(); 
    } 
    public synchronized String getMessage() 
        throws InterruptedException { 
        notify(); 
        while ( messages.size() == 0 ) 
            wait(); 
        String message = (String)messages.firstElement(); 
        messages.removeElement( message ); 
        return message; 
    } 
}
```


Overlapping Code:
```
Producer extends Thread { 
static final int MAXQUEUE = 5; 
private Vector messages = new Vector(); 
public void run() { 
try { 
while ( true ) { 
putMessage(); 
sleep(1000); 
} 
} 
catch( InterruptedException e ){} 
} 
private synchronized void putMessage() 
throws InterruptedException { 
while ( messages.size() == MAXQUEUE )
wait(); 
messages.addElement( new java.util.Date().toString() ); 
notify(); 
} 
public synchronized String getMessage() 
throws InterruptedException { 
notify(); 
while ( messages.size() == 0 ) 
wait(); 
String message = (String)messages.firstElement(); 
messages.removeElement( mess
```
<Overlap Ratio: 0.9458204334365325>

---

--- 114 --
Question ID: 5a8681d2f64bbaa08bd02d575411880b8fe4e259
Original Code:
```
public class NoteTestPassesMatcherTest {
    private static final String xpathValuesControlXML =
            "<root>" +
                    "<outer attr=\"urk\">" +
                    "<inner attr=\"urk\">controlDocument</inner>" +
                    "</outer>" +
                    "</root>";
    private static final String xpathValuesTestXML =
            "<root>" +
                    "<outer attr=\"urk\">" +
                    "<inner attr=\"ugh\">testDocument</inner>" +
                    "</outer>" +
                    "</root>";

    @Test
    public void testNodeTest() throws Exception {
        DocumentUtils documentUtils = new DocumentUtils(new XmlUnitProperties());

        NodeTester tester = new CountingNodeTester(1);

        assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.TEXT_NODE));
        try {
            assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.ELEMENT_NODE));
            fail("Expected node test failure #1!");
        } catch (AssertionError e) {
        }

        NodeTest test = new NodeTest(documentUtils, new StringReader(xpathValuesTestXML));
        tester = new CountingNodeTester(4);
        assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));
        assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));

        try {
            assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));
            fail("Expected node test failure #2!");
        } catch (AssertionError e) {
        }

        try {
            assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));
            fail("Expected node test failure #3!");
        } catch (AssertionError e) {
        }
    }
}
```


Overlapping Code:
```
ic class NoteTestPassesMatcherTest {
private static final String xpathValuesControlXML =
"<root>" +
"<outer attr=\"urk\">" +
"<inner attr=\"urk\">controlDocument</inner>" +
"</outer>" +
"</root>";
private static final String xpathValuesTestXML =
"<root>" +
"<outer attr=\"urk\">" +
"<inner attr=\"ugh\">testDocument</inner>" +
"</outer>" +
"</root>";
@Test
public void testNodeTest() throws Exception {
DocumentUtils documentUtils = new DocumentUtils(new XmlUnitProperties());
NodeTester tester = new CountingNodeTester(1);
assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.TEXT_NODE));
try {
assertThat(new NodeTest(documentUtils, xpathValuesControlXML), passesWith(tester, Node.ELEMENT_NODE));
fail("Expected node test failure #1!");
} catch (AssertionError e) {
}
NodeTest test = new NodeTest(documentUtils, new StringReader(xpathValuesTestXML));
tester = new CountingNodeTester(4);
assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));
assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));
try {
assertThat(test, notPassesWith(tester, new short[] { Node.TEXT_NODE, Node.ELEMENT_NODE }));
fail("Expected node test failure #2!");
} catch (AssertionError e) {
}
try {
assertThat(test, passesWith(tester, new short[] { Node.TEXT_NODE, Node.COMMENT_NODE }));
fail("Expected node test failure
```
<Overlap Ratio: 0.9681881051175657>

---

--- 115 --
Question ID: 90f253e2ebebe2f9ca0e7650a6acbed85ab16f77
Original Code:
```
public class Rating {
    public enum RatingEvent implements Audit.ApiAuditEvent {
        RATING_CREATED, RATING_UPDATED, RATING_DELETED
    }
    private String id;
    private String referenceId;
    private RatingReferenceType referenceType;
    private String user;
    private byte rate;
    private String title;
    private String comment;
    private Date createdAt;
    private Date updatedAt;

    public Rating() {
    }

    public Rating(Rating cloned) {
        this.id = cloned.id;
        this.user = cloned.user;
        this.rate = cloned.rate;
        this.title = cloned.title;
        this.comment = cloned.comment;
        this.createdAt = cloned.createdAt;
        this.updatedAt = cloned.updatedAt;
        this.referenceId = cloned.referenceId;
        this.referenceType = cloned.referenceType;
    }


    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUser() {
        return user;
    }

    public void setUser(String user) {
        this.user = user;
    }

    public byte getRate() {
        return rate;
    }

    public void setRate(byte rate) {
        this.rate = rate;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getComment() {
        return comment;
    }

    public void setComment(String comment) {
        this.comment = comment;
    }

    public Date getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    public Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    
    public String getReferenceId() {
        return referenceId;
    }

    public void setReferenceId(String referenceId) {
        this.referenceId = referenceId;
    }

    public RatingReferenceType getReferenceType() {
        return referenceType;
    }

    public void setReferenceType(RatingReferenceType referenceType) {
        this.referenceType = referenceType;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Rating)) return false;
        Rating rating = (Rating) o;
        return Objects.equals(id, rating.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, referenceId, referenceType);
    }

    @Override
    public String toString() {
        return "Rating{" +
                "id='" + id + '\'' +
                ", referenceId='" + referenceId + '\'' +
                ", referenceType=" + referenceType +
                ", user='" + user + '\'' +
                ", rate=" + rate +
                ", title='" + title + '\'' +
                ", comment='" + comment + '\'' +
                ", createdAt=" + createdAt +
                ", updatedAt=" + updatedAt +
                '}';
    }
}
```


Overlapping Code:
```
atingEvent implements Audit.ApiAuditEvent {
RATING_CREATED, RATING_UPDATED, RATING_DELETED
}
private String id;
private String referenceId;
private RatingReferenceType referenceType;
private String user;
private byte rate;
private String title;
private String comment;
private Date createdAt;
private Date updatedAt;
public Rating() {
}
public Rating(Rating cloned) {
this.id = cloned.id;
this.user = cloned.user;
this.rate = cloned.rate;
this.title = cloned.title;
this.comment = cloned.comment;
this.createdAt = cloned.createdAt;
this.updatedAt = cloned.updatedAt;
this.referenceId = cloned.referenceId;
this.referenceType = cloned.referenceType;
}
public String getId() {
return id;
}
public void setId(String id) {
this.id = id;
}
public String getUser() {
return user;
}
public void setUser(String user) {
this.user = user;
}
public byte getRate() {
return rate;
}
public void setRate(byte rate) {
this.rate = rate;
}
public String getTitle() {
return title;
}
public void setTitle(String title) {
this.title = title;
}
public String getComment() {
return comment;
}
public void setComment(String comment) {
this.comment = comment;
}
public Date getCreatedAt() {
return createdAt;
}
public void setCreatedAt(Date createdAt) {
this.createdAt = createdAt;
}
public Date getUpdatedAt() {
return updatedAt;
}
public void setUpdatedAt(Date updatedAt) {
this.updatedAt = updatedAt;
}

public String getReferenceId() {
return referenceId;
}
public void setReferenceId(String referenceId) {
this.referenceId = referenceId;
}
public RatingReferenceType getReferenceType() {
return referenceType;
}
public void setReferenceType(RatingReferenceType referenceType) {
this.referenceType = referenceType;
}
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (!(o instanceof Rating)) return false;
Rating rating = (Rating) o;
return Objects.equals(id, rating.id);
}
@Override
public int hashCode() {
return Objects.hash(id, re
```
<Overlap Ratio: 0.9778225806451613>

---

--- 116 --
Question ID: de4b40b6a3c4c6a9cd99a09538e26a5137eb3083
Original Code:
```
public class Leetcode347 {

    private class Freq implements Comparable<Freq>{
        public int e, freq;

        public Freq(int e, int freq) {
            this.e = e;
            this.freq = freq;
        }

        @Override
        public int compareTo(Freq o) {
            if(this.freq < o.freq)
                return 1;
            else if(this.freq > o.freq)
                return -1;
            else
                return 0;
        }
    }

    public List<Integer> topKFrequent(int[] nums, int k) {

        TreeMap<Integer, Integer> map = new TreeMap<>();

        for (int num : nums) {
            if(!map.containsKey(num)){
                map.put(num, 1);
            }else
                map.put(num, map.get(num) + 1);
        }

        PriorityQueue<Freq> pq = new PriorityQueue<>();
        for (int key: map.keySet()){
            if(pq.getSize() < k)
                pq.enqueue(new Freq(key, map.get(key)));
            else if(map.get(key) > pq.getFront().freq){
                pq.dequeue();
                pq.enqueue(new Freq(key, map.get(key)));
            }
        }

        LinkedList<Integer> list = new LinkedList<>();
        while (!pq.isEmpty())
            list.add(pq.dequeue().e);

        return list;
    }

}
```


Overlapping Code:
```
 class Freq implements Comparable<Freq>{
public int e, freq;
public Freq(int e, int freq) {
this.e = e;
this.freq = freq;
}
@Override
public int compareTo(Freq o) {
if(this.freq < o.freq)
return 1;
else if(this.freq > o.freq)
return -1;
else
return 0;
}
}
public List<Integer> topKFrequent(int[] nums, int k) {
TreeMap<Integer, Integer> map = new TreeMap<>();
for (int num : nums) {
if(!map.containsKey(num)){
map.put(num, 1);
}else
map.put(num, map.get(num) + 1);
}
PriorityQueue<Freq> pq = new PriorityQueue<>();
for (int key: map.keySet()){
if(pq.getSize() < k)
pq.enqueue(new Freq(key, map.get(key)));
else if(map.get(key) > pq.getFront().freq){
pq.dequeue();
pq.enqueue(new Freq(key, map.get(key)));
}
}
LinkedList<Integer> list = new LinkedList<>();
while (!pq.isEmpty())
list.add(pq.dequeue().
```
<Overlap Ratio: 0.936768149882904>

---

--- 117 --
Question ID: 2c4df6ebddadcb830114fa120fffbb89cec57c7f
Original Code:
```
public class BenchmarkTest {

   private static Dispatcher dispatcher;

   @BeforeClass
   public static void BeforeClass() {
      dispatcher = MockDispatcherFactory.createDispatcher();
      dispatcher.getRegistry().addPerRequestResource(HelloResource.class);
   }

   @Before
   public void before() {
      ResteasyContext.getContextDataMap().put(Configurable.class, dispatcher.getProviderFactory());
   }

   @Path("/hello")
   public static class HelloResource {
      @GET
      @Produces("text/plain")
      public String get() {
         return "hello world";
      }

      @POST
      @Produces("text/plain")
      @Consumes("text/plain")
      public String post(String name) {
         return "Hello " + name;
      }

      @GET
      @Path("{id}")
      @Produces("text/plain")
      public String getPath(@PathParam("id") int id) {
         return "hello world " + id;
      }


   }

   private static final int ITERATIONS=1000000;

   //@Test
   public void runPathGet() {
      long start = System.currentTimeMillis();
      for (int i = 0; i < ITERATIONS; i++) {
         testPathGet();
      }
      long end = System.currentTimeMillis() - start;
      //System.out.println("Took " + end);
   }

   public void testPathGet() {
      MockHttpRequest request = MockHttpRequest.create("GET", "/hello/1", "", "");
      MockHttpResponse response = new MockHttpResponse();
      dispatcher.invoke(request, response);

   }
   public void testPlainGet() {
      MockHttpRequest request = MockHttpRequest.create("GET", "/hello", "", "");
      MockHttpResponse response = new MockHttpResponse();
      dispatcher.invoke(request, response);

   }
   public void testPlainPost() {
      MockHttpRequest request = MockHttpRequest.create("GET", "/hello", "", "");
      request.contentType("text/plain").content("world".getBytes());
      MockHttpResponse response = new MockHttpResponse();
      dispatcher.invoke(request, response);

   }


}
```


Overlapping Code:
```
ss BenchmarkTest {
private static Dispatcher dispatcher;
@BeforeClass
public static void BeforeClass() {
dispatcher = MockDispatcherFactory.createDispatcher();
dispatcher.getRegistry().addPerRequestResource(HelloResource.class);
}
@Before
public void before() {
ResteasyContext.getContextDataMap().put(Configurable.class, dispatcher.getProviderFactory());
}
@Path("/hello")
public static class HelloResource {
@GET
@Produces("text/plain")
public String get() {
return "hello world";
}
@POST
@Produces("text/plain")
@Consumes("text/plain")
public String post(String name) {
return "Hello " + name;
}
@GET
@Path("{id}")
@Produces("text/plain")
public String getPath(@PathParam("id") int id) {
return "hello world " + id;
}
}
private static final int ITERATIONS=1000000;
//@Test
public void runPathGet() {
long start = System.currentTimeMillis();
for (int i = 0; i < ITERATIONS; i++) {
testPathGet();
}
long end = System.currentTimeMillis() - start;
//System.out.println("Took " + end);
}
public void testPathGet() {
MockHttpRequest request = MockHttpRequest.create("GET", "/hello/1", "", "");
MockHttpResponse response = new MockHttpResponse();
dispatcher.invoke(request, response);
}
public void testPlainGet() {
MockHttpRequest request = MockHttpRequest.create("GET", "/hello", "", "");
MockHttpResponse response = new MockHttpResponse();
dispatcher.invoke(request, response);
}
public void testPlainPost() {
MockHttpRequest request = MockHttpRequest.create("GET", "/hello", "", "");
request.contentType("text/plain").content("world".getBytes());
MockHttpResponse response = new MockHttpResponse();
dispatcher.invoke(request, response);

```
<Overlap Ratio: 0.9921212121212121>

---

--- 118 --
Question ID: 894995dc2211b293e6e3d532e03565e16d032060
Original Code:
```
public class AugmentedStmtGraph implements DirectedGraph
{
    private HashMap binding, original2clone;
    private IterableSet aug_list, stmt_list;
    private List bheads, btails, cheads, ctails;


    public AugmentedStmtGraph( AugmentedStmtGraph other)
    {
	this();

	HashMap old2new = new HashMap();

	Iterator it = other.aug_list.iterator();
	while (it.hasNext()) {
	    AugmentedStmt oas = (AugmentedStmt) it.next();
	    Stmt s = oas.get_Stmt();

	    AugmentedStmt nas = new AugmentedStmt( s);
	    aug_list.add( nas);
	    stmt_list.add( s);
	    binding.put( s, nas);

	    old2new.put( oas, nas);
	}

	
	it = other.aug_list.iterator();
	while (it.hasNext()) {
	    AugmentedStmt oas = (AugmentedStmt) it.next();
	    AugmentedStmt nas = (AugmentedStmt) old2new.get( oas);

	    Iterator pit = oas.bpreds.iterator();
	    while (pit.hasNext())
		nas.bpreds.add( old2new.get( pit.next()));
	    if (nas.bpreds.isEmpty())
		bheads.add( nas);

	    pit = oas.cpreds.iterator();
	    while (pit.hasNext())
		nas.cpreds.add( old2new.get( pit.next()));
	    if (nas.cpreds.isEmpty())
		cheads.add( nas);

	    Iterator sit = oas.bsuccs.iterator();
	    while (sit.hasNext())
		nas.bsuccs.add( old2new.get( sit.next()));
	    if (nas.bsuccs.isEmpty())
		btails.add( nas);

	    sit = oas.csuccs.iterator();
	    while (sit.hasNext())
		nas.csuccs.add( old2new.get( sit.next()));
	    if (nas.csuccs.isEmpty())
		ctails.add( nas);
	}

	find_Dominators();
    }
   
    public AugmentedStmtGraph( BriefUnitGraph bug, TrapUnitGraph cug)
    {
	this();

	Dava.v().log( "AugmentedStmtGraph::AugmentedStmtGraph() - cug.size() = " + cug.size());

	// make the augmented statements
	Iterator it = cug.iterator();
	while (it.hasNext()) {
	    Stmt s = (Stmt) it.next();
	    add_StmtBinding( s, new AugmentedStmt( s));
	}

	// make the list of augmented statements in pseudo topological order!
        it = (new PseudoTopologicalOrderer()).newList( cug, false ).iterator();
	while (it.hasNext()) {
	    Stmt s = (Stmt) it.next();
	    aug_list.add( get_AugStmt( s));
	    stmt_list.add( s);
	}

	// now that we've got all the augmented statements, mirror the statement graph
	it = aug_list.iterator();
	while (it.hasNext()) {
	    AugmentedStmt as = (AugmentedStmt) it.next();
	    
	    mirror_PredsSuccs( as, bug);
	    mirror_PredsSuccs( as, cug);
	}

	find_Dominators();
    }

    public AugmentedStmtGraph()
    {
        binding  = new HashMap();
	original2clone = new HashMap();
	aug_list = new IterableSet();
	stmt_list = new IterableSet();

	bheads = new LinkedList();
	btails = new LinkedList();
	cheads = new LinkedList();
	ctails = new LinkedList();
    }

    public void add_AugmentedStmt( AugmentedStmt as)
    {
	Stmt s = as.get_Stmt();

	aug_list.add( as);
	stmt_list.add( s);
	
	add_StmtBinding( s, as);

	if (as.bpreds.isEmpty())
	    bheads.add( as);
	
	if (as.cpreds.isEmpty())
	    cheads.add( as);
	
	if (as.bsuccs.isEmpty())
	    btails.add( as);
	
	if (as.csuccs.isEmpty())
	    ctails.add( as);

	check_List( as.bpreds, btails);
	check_List( as.bsuccs, bheads);
	check_List( as.cpreds, ctails);
	check_List( as.csuccs, cheads);
    }

    public boolean contains( Object o)
    {
	return aug_list.contains( o);
    }

    public AugmentedStmt get_CloneOf( AugmentedStmt as)
    {
	return (AugmentedStmt) original2clone.get( as);
    }

    public int size()
    {
	return aug_list.size();
    }

    private void check_List( List psList, List htList)
    {
	Iterator it = psList.iterator();
	while (it.hasNext()) {
	    Object o = it.next();

	    if (htList.contains( o))
		htList.remove(o);
	}
    }


    public void calculate_Reachability( AugmentedStmt source, HashSet blockers, AugmentedStmt dominator)
    {
	if (blockers == null)
	    throw new RuntimeException( "Tried to call AugmentedStmtGraph:calculate_Reachability() with null blockers.");

	if (source == null)
	    return;

	LinkedList<AugmentedStmt> worklist = new LinkedList<AugmentedStmt>();
	HashSet<AugmentedStmt> touchSet = new HashSet<AugmentedStmt>();
	
	worklist.addLast( source);
	touchSet.add( source);
	
	while (worklist.isEmpty() == false) {
	    AugmentedStmt as = worklist.removeFirst();
	    
	    Iterator sit = as.csuccs.iterator();
	    while (sit.hasNext()) {
		AugmentedStmt sas = (AugmentedStmt) sit.next();
		
		if ((touchSet.contains( sas)) || (sas.get_Dominators().contains( dominator) == false))
		    continue;
		
		touchSet.add( sas);
		
		IterableSet reachers = sas.get_Reachers();
		
		if (reachers.contains( source) == false)
		    reachers.add( source);
		
		if (blockers.contains( sas) == false)
		    worklist.addLast( sas);
	    }
	}
    }

    public void calculate_Reachability( Collection sources, HashSet blockers, AugmentedStmt dominator)
    {
	Iterator srcIt = sources.iterator();
	while (srcIt.hasNext())
	    calculate_Reachability( (AugmentedStmt) srcIt.next(), blockers, dominator);
    }

    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt blocker, AugmentedStmt dominator)
    {
	HashSet h = new HashSet();

	h.add( blocker);

	calculate_Reachability( source, h, dominator);
    }
    
    public void calculate_Reachability( Collection sources, AugmentedStmt blocker, AugmentedStmt dominator)
    {
	HashSet h = new HashSet();
	
	h.add( blocker);
	
	calculate_Reachability( sources, h, dominator);
    }

    public void calculate_Reachability( AugmentedStmt source, AugmentedStmt dominator)
    {
	calculate_Reachability( source, new HashSet(), dominator);
    }

    public void calculate_Reachability( Collection sources, AugmentedStmt dominator)
    {
	calculate_Reachability( sources, new HashSet(), dominator);
    }

    public void calculate_Reachability( AugmentedStmt source)
    {
	calculate_Reachability( source, null);
    }

    public void calculate_Reachability( Collection sources)
    {
	calculate_Reachability( sources, null);
    }

    public void add_StmtBinding( Stmt s, AugmentedStmt as)
    {
	binding.put( s, as);
    }

    public AugmentedStmt get_AugStmt( Stmt s)
    {
	AugmentedStmt as = (AugmentedStmt) binding.get( s);
	if (as == null)
	    throw new RuntimeException( "Could not find augmented statement for: " + s.toString());

	return as;
    }


    // now put in the methods to satisfy the DirectedGraph interface

    public List getHeads()
    {
	return cheads;
    }

    public List getTails()
    {
	return ctails;
    }

    public Iterator iterator()
    {
	return aug_list.iterator();
    }

    public List getPredsOf( Object s)
    {
	if (s instanceof AugmentedStmt)
	    return ((AugmentedStmt) s).cpreds;
	else if (s instanceof Stmt)
	    return get_AugStmt((Stmt) s).cpreds;
	else
	    throw new RuntimeException( "Object " + s + " class: " + s.getClass() + " not a member of this AugmentedStmtGraph");
    }

    public List getSuccsOf( Object s)
    {
	if (s instanceof AugmentedStmt)
	    return ((AugmentedStmt) s).csuccs;
	else if (s instanceof Stmt)
	    return get_AugStmt((Stmt) s).csuccs;
	else
	    throw new RuntimeException( "Object " + s + " class: " + s.getClass() + " not a member of this AugmentedStmtGraph");
    }
    
    // end of methods satisfying DirectedGraph

    public List get_BriefHeads()
    {
	return bheads;
    }

    public List get_BriefTails()
    {
	return btails;
    }

    public IterableSet get_ChainView()
    {
	IterableSet c = new IterableSet();

	c.addAll( aug_list);
	return c;
    }

    public Object clone()
    {
	return new AugmentedStmtGraph( this);
    }

    public boolean remove_AugmentedStmt( AugmentedStmt toRemove)
    {
	if (aug_list.contains( toRemove) == false)
	    return false;
	
	Iterator pit = toRemove.bpreds.iterator();
	while (pit.hasNext()) {
	    AugmentedStmt pas = (AugmentedStmt) pit.next();
	    if (pas.bsuccs.contains( toRemove))
		pas.bsuccs.remove( toRemove);
	}

	pit = toRemove.cpreds.iterator();
	while (pit.hasNext()) {
	    AugmentedStmt pas = (AugmentedStmt) pit.next();
	    if (pas.csuccs.contains( toRemove))
		pas.csuccs.remove( toRemove);
	}

	Iterator sit = toRemove.bsuccs.iterator();
	while (sit.hasNext()) {
	    AugmentedStmt sas = (AugmentedStmt) sit.next();
	    if (sas.bpreds.contains( toRemove))
		sas.bpreds.remove( toRemove);
	}

	sit = toRemove.csuccs.iterator();
	while (sit.hasNext()) {
	    AugmentedStmt sas = (AugmentedStmt) sit.next();
	    if (sas.cpreds.contains( toRemove))
		sas.cpreds.remove( toRemove);
	}

	aug_list.remove( toRemove);
	stmt_list.remove( toRemove.get_Stmt());

	if (bheads.contains( toRemove))
	    bheads.remove( toRemove);
	if (btails.contains( toRemove))
	    btails.remove( toRemove);
	if (cheads.contains( toRemove))
	    cheads.remove( toRemove);
	if (ctails.contains( toRemove))
	    ctails.remove( toRemove);
	
	binding.remove( toRemove.get_Stmt());

	return true;

	// NOTE: we do *NOT* touch the underlying unit graphs.
    }

    public String toString()
    {
	StringBuffer b = new StringBuffer();
	String cr = "\n";

	b.append( "AugmentedStmtGraph (size: " + size() + " stmts)" + cr);

	Iterator it = aug_list.iterator();
	while (it.hasNext()) {
	    AugmentedStmt as = (AugmentedStmt) it.next();

	    b.append( "| .---" + cr + "| | AugmentedStmt " + as.toString() + cr + "| |" + cr + "| |  preds:");

	    Iterator pit = as.cpreds.iterator();
	    while (pit.hasNext()) {
		AugmentedStmt pas = (AugmentedStmt) pit.next();

		b.append( " " + pas.toString());
	    }

	    b.append( cr + "| |" + cr + "| |  succs:");
	    Iterator sit = as.csuccs.iterator();
	    while (sit.hasNext()) {
		AugmentedStmt sas = (AugmentedStmt) sit.next();

		b.append( " " + sas.toString());
	    }

	    b.append( cr + "| |" + cr + "| |  doms:");
	    Iterator dit = as.get_Dominators().iterator();
	    while (dit.hasNext()) {
		AugmentedStmt das = (AugmentedStmt) dit.next();

		b.append( " " + das.toString());
	    }

	    b.append( cr + "| `---" + cr);
	}

	b.append( "-" + cr);
	return b.toString();
    }


    private void mirror_PredsSuccs( AugmentedStmt as, UnitGraph ug)
    {
	Stmt s = as.get_Stmt();

	LinkedList 
	    preds = new LinkedList(),
	    succs = new LinkedList();
	
	// mirror the predecessors
	Iterator pit = ug.getPredsOf( s).iterator();
	while (pit.hasNext()) {
	    Object po = get_AugStmt( (Stmt) pit.next());
	    if (preds.contains( po) == false)
		preds.add( po);
	}

	// mirror the successors
	Iterator sit = ug.getSuccsOf( s).iterator();
	while (sit.hasNext()) {
	    Object so = get_AugStmt( (Stmt) sit.next());
	    if (succs.contains( so) == false)
		succs.add( so);
	}

	// attach the mirrors properly to the AugmentedStmt
	if (ug instanceof BriefUnitGraph) {
	    as.bpreds = preds;
	    as.bsuccs = succs;

	    if (preds.size() == 0)
		bheads.add( as);
	    if (succs.size() == 0)
		btails.add( as);
	}
	else if (ug instanceof TrapUnitGraph) {
	    as.cpreds = preds;
	    as.csuccs = succs;

	    if (preds.size() == 0)
		cheads.add( as);
	    if (succs.size() == 0)
		ctails.add( as);
	}
	else throw new RuntimeException( "Unknown UnitGraph type: " + ug.getClass());
    }


    public IterableSet clone_Body( IterableSet oldBody)
    {
	HashMap 
	    old2new = new HashMap(),
	    new2old = new HashMap();
	
	IterableSet newBody = new IterableSet();

	Iterator it = oldBody.iterator();
	while (it.hasNext()) {
	    AugmentedStmt as = (AugmentedStmt) it.next();
	    AugmentedStmt clone = (AugmentedStmt) as.clone();

	    original2clone.put( as, clone);

	    old2new.put( as, clone);
	    new2old.put( clone, as);
	    newBody.add( clone);
	}

	it = newBody.iterator();
	while (it.hasNext()) {
	    AugmentedStmt newAs = (AugmentedStmt) it.next();
	    AugmentedStmt oldAs = (AugmentedStmt) new2old.get( newAs);

	    mirror_PredsSuccs( oldAs, oldAs.bpreds, newAs.bpreds, old2new);
	    mirror_PredsSuccs( oldAs, oldAs.cpreds, newAs.cpreds, old2new);
	    mirror_PredsSuccs( oldAs, oldAs.bsuccs, newAs.bsuccs, old2new);
	    mirror_PredsSuccs( oldAs, oldAs.csuccs, newAs.csuccs, old2new);
	}

	it = newBody.iterator();
	while (it.hasNext()) 
	    add_AugmentedStmt( (AugmentedStmt) it.next());

	HashMap<Stmt, Stmt> so2n = new HashMap<Stmt, Stmt>();

	it = oldBody.iterator();
	while (it.hasNext()) {
	    AugmentedStmt as = (AugmentedStmt) it.next();
	    
	    Stmt os = as.get_Stmt();
	    Stmt ns = ((AugmentedStmt) old2new.get( as)).get_Stmt();

	    so2n.put( os, ns);
	}

	it = newBody.iterator();
	while (it.hasNext()) {
	    AugmentedStmt nas = (AugmentedStmt) it.next();
	    AugmentedStmt oas = (AugmentedStmt) new2old.get( nas);
	    	    
	    Stmt 
		ns = nas.get_Stmt(),
		os = oas.get_Stmt();

	    if (os instanceof IfStmt) {
		Unit 
		    target = ((IfStmt) os).getTarget(),
		    newTgt = null;

		if ((newTgt = so2n.get( target)) != null)
		    ((IfStmt) ns).setTarget( newTgt);
		else
		    ((IfStmt) ns).setTarget( target);
	    }

	    else if (os instanceof TableSwitchStmt) {
		TableSwitchStmt 
		    otss = (TableSwitchStmt) os,
		    ntss = (TableSwitchStmt) ns;

		Unit
		    target = otss.getDefaultTarget(),
		    newTgt = null;

		if ((newTgt = so2n.get( target)) != null)
		    ntss.setDefaultTarget( newTgt);
		else
		    ntss.setDefaultTarget( target);
		
		LinkedList<Unit> new_target_list = new LinkedList<Unit>();
		
		int target_count = otss.getHighIndex() - otss.getLowIndex() + 1;
		for (int i=0; i<target_count; i++) {
		    target = otss.getTarget(i);
		    newTgt = null;

		    if ((newTgt = so2n.get( target)) != null)
			new_target_list.add( newTgt);
		    else
			new_target_list.add( target);
		}
		ntss.setTargets( new_target_list);
	    }

	    else if (os instanceof LookupSwitchStmt) {
		LookupSwitchStmt 
		    olss = (LookupSwitchStmt) os,
		    nlss = (LookupSwitchStmt) ns;

		Unit
		    target = olss.getDefaultTarget(),
		    newTgt = null;

		if ((newTgt = so2n.get( target)) != null)
		    nlss.setDefaultTarget( newTgt);
		else
		    nlss.setDefaultTarget( target);
		
		Unit[] new_target_list = new Unit[ olss.getTargetCount()];
		
		for (int i=0; i<new_target_list.length; i++) {
		    target = olss.getTarget(i);
		    newTgt = null;

		    if ((newTgt = so2n.get( target)) != null)
			new_target_list[i] = newTgt;
		    else
			new_target_list[i] = target;
		}
		nlss.setTargets( new_target_list);
		nlss.setLookupValues( olss.getLookupValues());
	    }
	}
	
	return newBody;
    }

    private void mirror_PredsSuccs( AugmentedStmt originalAs, List oldList, List newList, Map old2new)
    {
	Iterator it = oldList.iterator();
	while (it.hasNext()) {
	    AugmentedStmt oldAs = (AugmentedStmt) it.next();
	    AugmentedStmt newAs = (AugmentedStmt) old2new.get( oldAs);
	    
	    if (newAs != null)
		newList.add( newAs);

	    else {
		newList.add( oldAs);
		
		AugmentedStmt clonedAs = (AugmentedStmt) old2new.get( originalAs);

		if (oldList == originalAs.bpreds)
		    oldAs.bsuccs.add( clonedAs);
		else if (oldList == originalAs.cpreds)
		    oldAs.csuccs.add( clonedAs);
		else if (oldList == originalAs.bsuccs)
		    oldAs.bpreds.add( clonedAs);
		else if (oldList == originalAs.csuccs)
		    oldAs.cpreds.add( clonedAs);
		else 
		    throw new RuntimeException( "Error mirroring preds and succs in Try block splitting.");
	    }
	}
    }


    public void find_Dominators()
    {
	// set up the dominator sets for all the nodes in the graph
	Iterator asgit = aug_list.iterator();
	while (asgit.hasNext()) {
	    AugmentedStmt as = (AugmentedStmt) asgit.next();

	    // Dominators:
	    // safe starting approximation for S(0) ... empty set
	    // unsafe starting approximation for S(i) .. full set
	    if (as.cpreds.size() != 0) {

		if (as.get_Dominators().isEmpty() == false)
		    as.get_Dominators().clear();

		as.get_Dominators().addAll( aug_list);
	    }
	    else 
		as.get_Dominators().clear();
	}

	// build the worklist
	IterableSet worklist = new IterableSet();
	worklist.addAll( aug_list);

	// keep going until the worklist is empty
	while (worklist.isEmpty() == false) {
	    AugmentedStmt as = (AugmentedStmt) worklist.getFirst();
	    worklist.removeFirst();
	    
	    IterableSet pred_intersection = new IterableSet();
	    boolean first_pred = true;

	    // run through all the predecessors and get their dominance intersection
	    Iterator pit = as.cpreds.iterator();
	    while (pit.hasNext()) {
		AugmentedStmt pas = (AugmentedStmt) pit.next();
		
		// for the first predecessor just take all his dominators
		if (first_pred) {
		    pred_intersection.addAll( pas.get_Dominators());
		    if (pred_intersection.contains( pas) == false)
			pred_intersection.add( pas);
		    first_pred = false;
		}

		// for the subsequent predecessors remove the ones they do not have from the intersection
		else {
		    Iterator piit = pred_intersection.snapshotIterator();
		    while (piit.hasNext()) {
			AugmentedStmt pid = (AugmentedStmt) piit.next();

			if ((pas.get_Dominators().contains( pid) == false) && (pas != pid))
			    pred_intersection.remove( pid);
		    }
		}
	    }

	    // update dominance if we have a change
	    if (as.get_Dominators().equals( pred_intersection) == false) {
		Iterator sit = as.csuccs.iterator();
		while (sit.hasNext()) {
		    Object o = sit.next();

		    if (worklist.contains( o) == false)
			worklist.add( o);
		}

		as.get_Dominators().clear();
		as.get_Dominators().addAll( pred_intersection);
	    }
	}
    }
}
```


Overlapping Code:
```
lic class AugmentedStmtGraph implements DirectedGraph
{
private HashMap binding, original2clone;
private IterableSet aug_list, stmt_list;
private List bheads, btails, cheads, ctails;
public AugmentedStmtGraph( AugmentedStmtGraph other)
{
this();
HashMap old2new = new HashMap();
Iterator it = other.aug_list.iterator();
while (it.hasNext()) {
AugmentedStmt oas = (AugmentedStmt) it.next();
Stmt s = oas.get_Stmt();
AugmentedStmt nas = new AugmentedStmt( s);
aug_list.add( nas);
stmt_list.add( s);
binding.put( s, nas);
old2new.put( oas, nas);
}

it = other.aug_list.iterator();
while (it.hasNext()) {
AugmentedStmt oas = (AugmentedStmt) it.next();
AugmentedStmt nas = (AugmentedStmt) old2new.get( oas);
Iterator pit = oas.bpreds.iterator();
while (pit.hasNext())
nas.bpreds.add( old2new.get( pit.next()));
if (nas.bpreds.isEmpty())
bheads.add( nas);
pit = oas.cpreds.iterator();
while (pit.hasNext())
nas.cpreds.add( old2new.get( pit.next()));
if (nas.cpreds.isEmpty())
cheads.add( nas);
Iterator sit = oas.bsuccs.iterator();
while (sit.hasNext())
nas.bsuccs.add( old2new.get( sit.next()));
if (nas.bsuccs.isEmpty())
btails.add( nas);
sit = oas.csuccs.iterator();
while (sit.hasNext())
nas.csuccs.add( old2new.get( sit.next()));
if (nas.csuccs.isEmpty())
ctails.add( nas);
}
find_Dominators();
}

public AugmentedStmtGraph( BriefUnitGraph bug, TrapUnitGraph cug)
{
this();
Dava.v().log( "AugmentedStmtGraph::AugmentedStmtGraph() - cug.size() = " + cug.size());
// make the augmented statements
Iterator it = cug.iterator();
while (it.hasNext()) {
Stmt s = (Stmt) it.next();
add_StmtBinding( s, new AugmentedStmt( s));
}
// make the list of augmented statements in pseudo topological order!
it = (new PseudoTopologicalOrderer()).newList( cug, false ).iterator();
while (it.hasNext()) {
Stmt s = (Stmt) it.next();
aug_list.add( get_AugStmt( s));
stmt_list.add( s);
}
// now that we've got all the augmented statements, mirror the statement graph
it = aug_list.iterator();
while (it.hasNext()) {
AugmentedStmt as = (AugmentedStmt) it.next();

mirror_PredsSuccs( as, bug);
mirror_PredsSuccs( as, cug);
}
find_Dominators();
}
public AugmentedStmtGraph()
{
binding = new HashMap();
original2clone = new Has
```
<Overlap Ratio: 0.9887640449438202>

---

--- 119 --
Question ID: 47d539cd740d162402a3804ed62c269e7e3849e8
Original Code:
```
public final class MonitoringControllerHolder {

	private static volatile IMonitoringController monitoringController;
	private static volatile MonitoringConfiguration monitoringConfiguration;

	private MonitoringControllerHolder( ) {
		// Avoid instantiation
	}

	public static IMonitoringController getMonitoringController( ) {
		return monitoringController;
	}

	public static void setMonitoringController( final IMonitoringController aMonitoringController ) {
		monitoringController = aMonitoringController;
	}

	public static MonitoringConfiguration getCurrentConfiguration( ) {
		return monitoringConfiguration;
	}

	public static void setCurrentConfiguration( final MonitoringConfiguration aMonitoringConfiguration ) {
		monitoringConfiguration = aMonitoringConfiguration;
	}

	public static IMonitoringController clearMonitoringController( ) {
		final IMonitoringController controller = monitoringController;
		monitoringController = null;
		return controller;
	}

}
```


Overlapping Code:
```
c final class MonitoringControllerHolder {
private static volatile IMonitoringController monitoringController;
private static volatile MonitoringConfiguration monitoringConfiguration;
private MonitoringControllerHolder( ) {
// Avoid instantiation
}
public static IMonitoringController getMonitoringController( ) {
return monitoringController;
}
public static void setMonitoringController( final IMonitoringController aMonitoringController ) {
monitoringController = aMonitoringController;
}
public static MonitoringConfiguration getCurrentConfiguration( ) {
return monitoringConfiguration;
}
public static void setCurrentConfiguration( final MonitoringConfiguration aMonitoringConfiguration ) {
monitoringConfiguration = aMonitoringConfiguration;
}
public static IMonitoringController clearMonitoringController( ) {
final IMonitoringController controller = monitoringController;
monitoringController = null;
return c
```
<Overlap Ratio: 0.9796791443850268>

---

--- 120 --
Question ID: 965f35d7167e00e38221ad1b42e6106e70a4f179
Original Code:
```
public abstract class ElFunction {
	/**
	 * 当前时间
	 * @return
	 */
	public static Date now() {
		return new Date();
	}

	public static boolean contains(Collection<?> container, Object element) {
		if (container == null || element == null) {
			return false;
		}
		return container.contains(element);
	}

	public static Object invoke(Object obj, String method)
			throws SecurityException, NoSuchMethodException,
			IllegalArgumentException, IllegalAccessException,
			InvocationTargetException {
		if (obj == null || StringUtils.isBlank(method)) {
			return null;
		}
		Class<?> clazz = obj.getClass();
		return clazz.getMethod(method).invoke(obj);
	}

	public static Object invoke(Object obj, String methodName, Object arg0)
			throws SecurityException, NoSuchMethodException,
			IllegalArgumentException, IllegalAccessException,
			InvocationTargetException {
		if (obj == null || StringUtils.isBlank(methodName)) {
			return null;
		}
		Class<?> clazz = obj.getClass();
		Method method;
		if (arg0 != null) {
			method = clazz.getMethod(methodName, arg0.getClass());
		} else {
			for (Method m : clazz.getDeclaredMethods()) {
				if (m.getName().equals(methodName)
						&& m.getParameterTypes().length == 1) {
					method = m;
				}
			}
			throw new NoSuchMethodException(clazz.getName() + "." + methodName
					+ "(Object arg0)");
		}
		return method.invoke(obj, arg0);
	}

	public static Object invoke(Object obj, String methodName, Object arg0,
			Object arg1) throws SecurityException, NoSuchMethodException,
			IllegalArgumentException, IllegalAccessException,
			InvocationTargetException {
		if (obj == null || StringUtils.isBlank(methodName)) {
			return null;
		}
		Class<?> clazz = obj.getClass();
		Method method;
		if (arg0 != null && arg1 != null) {
			method = clazz.getMethod(methodName, arg0.getClass(),
					arg1.getClass());
		} else {
			for (Method m : clazz.getDeclaredMethods()) {
				if (m.getName().equals(methodName)
						&& m.getParameterTypes().length == 2) {
					method = m;
				}
			}
			throw new NoSuchMethodException(clazz.getName() + "." + methodName
					+ "(Object arg0,Object arg1)");
		}
		return method.invoke(obj, arg0, arg1);
	}

	public static Object invoke(Object obj, String methodName, Object arg0,
			Object arg1, Object arg2) throws SecurityException,
			NoSuchMethodException, IllegalArgumentException,
			IllegalAccessException, InvocationTargetException {
		if (obj == null || StringUtils.isBlank(methodName)) {
			return null;
		}
		Class<?> clazz = obj.getClass();
		Method method;
		if (arg0 != null && arg1 != null && arg2 != null) {
			method = clazz.getMethod(methodName, arg0.getClass(),
					arg1.getClass(), arg2.getClass());
		} else {
			for (Method m : clazz.getDeclaredMethods()) {
				if (m.getName().equals(methodName)
						&& m.getParameterTypes().length == 3) {
					method = m;
				}
			}
			throw new NoSuchMethodException(clazz.getName() + "." + methodName
					+ "(Object arg0,Object arg1,Object arg2)");
		}
		return method.invoke(obj, arg0, arg1, arg2);
	}

	public static Object invoke(Object obj, String methodName, Object arg0,
			Object arg1, Object arg2, Object arg3) throws SecurityException,
			NoSuchMethodException, IllegalArgumentException,
			IllegalAccessException, InvocationTargetException {
		if (obj == null || StringUtils.isBlank(methodName)) {
			return null;
		}
		Class<?> clazz = obj.getClass();
		Method method;
		if (arg0 != null && arg1 != null && arg2 != null) {
			method = clazz.getMethod(methodName, arg0.getClass(),
					arg1.getClass(), arg2.getClass(), arg3.getClass());
		} else {
			for (Method m : clazz.getDeclaredMethods()) {
				if (m.getName().equals(methodName)
						&& m.getParameterTypes().length == 4) {
					method = m;
				}
			}
			throw new NoSuchMethodException(clazz.getName() + "." + methodName
					+ "(Object arg0,Object arg1,Object arg2,Object arg3)");
		}
		return method.invoke(obj, arg0, arg1, arg2, arg3);
	}
}
```


Overlapping Code:
```
ass ElFunction {
/**
* 当前时间
* @return
*/
public static Date now() {
return new Date();
}
public static boolean contains(Collection<?> container, Object element) {
if (container == null || element == null) {
return false;
}
return container.contains(element);
}
public static Object invoke(Object obj, String method)
throws SecurityException, NoSuchMethodException,
IllegalArgumentException, IllegalAccessException,
InvocationTargetException {
if (obj == null || StringUtils.isBlank(method)) {
return null;
}
Class<?> clazz = obj.getClass();
return clazz.getMethod(method).invoke(obj);
}
public static Object invoke(Object obj, String methodName, Object arg0)
throws SecurityException, NoSuchMethodException,
IllegalArgumentException, IllegalAccessException,
InvocationTargetException {
if (obj == null || StringUtils.isBlank(methodName)) {
return null;
}
Class<?> clazz = obj.getClass();
Method method;
if (arg0 != null) {
method = clazz.getMethod(methodName, arg0.getClass());
} else {
for (Method m : clazz.getDeclaredMethods()) {
if (m.getName().equals(methodName)
&& m.getParameterTypes().length == 1) {
method = m;
}
}
throw new NoSuchMethodException(clazz.getName() + "." + methodName
+ "(Object arg0)");
}
return method.invoke(obj, arg0);
}
public static Object invoke(Object obj, String methodName, Object arg0,
Object arg1) throws SecurityException, NoSuchMethodException,
IllegalArgumentException, IllegalAccessException,
InvocationTargetException {
if (obj == null || StringUtils.isBlank(methodName)) {
return null;
}
Class<?> clazz = obj.getClass();
Method method;
if (arg0 != null && arg1 != null) {
method = clazz.getMethod(methodName, arg0.getClass(),
arg1.getClass());
} else {
for (Method m : clazz.getDeclaredMethods()) {
if (m.getName().equals(methodName)
&& m.getParameterTypes().length == 2) {
method = m;
}
}
throw new NoSuchMethodException(clazz.getName() + "." + methodName
+ "(Object arg0,Object arg1)");
}
return method.invoke(obj, arg0, arg1);
}
public static Object invoke(Object obj, String methodName, Object arg0,
Object arg1, Object arg2) throws SecurityException,
NoSuchMethodException, IllegalArgumentException,
IllegalAccessException, InvocationTargetException {
if (o
```
<Overlap Ratio: 0.9918955425484016>

---

--- 121 --
Question ID: 3013abb6c9b614e7b89f05cfb63a130f4c3e56d7
Original Code:
```
public class Hud{
	private int vidas;
	private int score;
	private int bombas;
	public static boolean x2;
	
	public Hud() {
		score = 0;
		vidas = 3;
		x2 =false;
		bombas = 3;
	}

	public void update() {
		
	}
	public void menosBombas(){
		bombas--;
	}
	public void masBombas(){
		bombas++;
	}
	public void setX2(boolean e){
		x2 = e;
	}
	public void draw(Canvas g2d) {
		dibijarScore(g2d);
		dibijarVidas(g2d);
		dibijarBombas(g2d);
	}
	public void addScore(int valor){
		if(x2){
			score +=(valor*2);
		}else{
			score +=valor;
		}
		
	}
	public void addDaño(int valor){
		vidas -=valor;
	}
	private void dibijarVidas(Canvas g){
		Vector2D pos = new Vector2D(Constantes.ANCHO-Assets.nave_2.getWidth()-10,40);
		Paint g2 = new Paint();
        g2.setTextSize(60);
        g2.setColor(Color.WHITE);
        g.drawText(vidas+"X",Constantes.ANCHO-Assets.bomba.getWidth()-90,+Assets.bomba.getHeight(),g2);
		g.drawBitmap(Assets.nave_2,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.nave_2.getWidth()+(int)pos.getX(),(int)Assets.nave_2.getHeight()+(int)pos.getY()),g2);
		
	}
	private void dibijarBombas(Canvas g){
		Vector2D pos = new Vector2D(Constantes.ANCHO-Assets.bomba.getWidth()-10,60+Assets.nave_2.getHeight());
		Paint g2 = new Paint();
		g2.setTextSize(60);
		g2.setColor(Color.WHITE);
		g.drawText(bombas+"X",Constantes.ANCHO-Assets.bomba.getWidth()-90,20+40+Assets.nave_2.getHeight(),g2);
		g.drawBitmap(Assets.bomba,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.bomba.getWidth()+(int)pos.getX(),(int)Assets.bomba.getHeight()+(int)pos.getY()),g2);
	}
	private void dibijarScore(Canvas g){
		Paint g2 = new Paint();
		g2.setTextSize(60);
		g2.setColor(Color.WHITE);
		Vector2D pos = new Vector2D(550,25);
		String e = Integer.toString(score);

		g.drawText("PTS="+e,50,100,g2);
	}
	public int getVidas(){
		return vidas;
	}
	public int getScore(){
		return score;
	}
	public int getSbombas(){
		return bombas;
	}
	public void setVidas(){
		vidas++;
	}
	public void setPts1000(){
		if(x2){
			score +=(5000*2);
		}else{
			score +=5000;
		}
	}
}
```


Overlapping Code:
```
nt score;
private int bombas;
public static boolean x2;

public Hud() {
score = 0;
vidas = 3;
x2 =false;
bombas = 3;
}
public void update() {

}
public void menosBombas(){
bombas--;
}
public void masBombas(){
bombas++;
}
public void setX2(boolean e){
x2 = e;
}
public void draw(Canvas g2d) {
dibijarScore(g2d);
dibijarVidas(g2d);
dibijarBombas(g2d);
}
public void addScore(int valor){
if(x2){
score +=(valor*2);
}else{
score +=valor;
}

}
public void addDaño(int valor){
vidas -=valor;
}
private void dibijarVidas(Canvas g){
Vector2D pos = new Vector2D(Constantes.ANCHO-Assets.nave_2.getWidth()-10,40);
Paint g2 = new Paint();
g2.setTextSize(60);
g2.setColor(Color.WHITE);
g.drawText(vidas+"X",Constantes.ANCHO-Assets.bomba.getWidth()-90,+Assets.bomba.getHeight(),g2);
g.drawBitmap(Assets.nave_2,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.nave_2.getWidth()+(int)pos.getX(),(int)Assets.nave_2.getHeight()+(int)pos.getY()),g2);

}
private void dibijarBombas(Canvas g){
Vector2D pos = new Vector2D(Constantes.ANCHO-Assets.bomba.getWidth()-10,60+Assets.nave_2.getHeight());
Paint g2 = new Paint();
g2.setTextSize(60);
g2.setColor(Color.WHITE);
g.drawText(bombas+"X",Constantes.ANCHO-Assets.bomba.getWidth()-90,20+40+Assets.nave_2.getHeight(),g2);
g.drawBitmap(Assets.bomba,null,new Rect((int)pos.getX(),(int)pos.getY(),(int)Assets.bomba.getWidth()+(int)pos.getX(),(int)Assets.bomba.getHeight()+(int)pos.getY()),g2);
}
private void dibijarScore(Canvas g){
Paint g2 = new Paint();
g2.setTextSize(60);
g2.setColor(Color.WHITE);
Vector2D pos = new Vector2D(550,25);
String e = Integer.toString(score);
g.drawText("PTS="+e,50,100,g2);
}
public int getVidas(){
return vidas;
}
public int getScore(){
return score;
}
public int getSbombas(){
return bombas;
}
public void setVidas(){
vidas++;
}
public void setPts1000(){
if(x2){
score +=(5000*2);

```
<Overlap Ratio: 0.9625390218522373>

---

--- 122 --
Question ID: 5ccc0c023bd1bb938c08a32d0d699772cd4311c3
Original Code:
```
@Service
@Transactional(readOnly = true)
public class LicenseClosureProcessflowService {

    @Autowired
    private SecurityUtils securityUtils;

    @Autowired
    private LicenseConfigurationService licenseConfigurationService;

    @Autowired
    private AssignmentService assignmentService;

    @Autowired
    private PositionMasterService positionMasterService;

    @Autowired
    private LicenseProcessWorkflowService licenseProcessWorkflowService;

    @Autowired
    @Qualifier("workflowService")
    private SimpleWorkflowService<TradeLicense> licenseWorkflowService;

    @Autowired
    private LicenseUtils licenseUtils;

    @Autowired
    private LicenseAppTypeService licenseAppTypeService;

    public void startClosureProcessflow(TradeLicense license) {
        if (securityUtils.currentUserIsEmployee()) {
            startClosureProcessByEmployee(license);
        } else {
            startClosureProcessByExternalUsers(license);
        }
    }

    private void startClosureProcessByEmployee(TradeLicense license) {
        User currentUser = securityUtils.getCurrentUser();
        List<Assignment> assignments = assignmentService.getAllActiveEmployeeAssignmentsByEmpId(currentUser.getId());
        Position flowInitiator = assignments.get(0).getPosition();

        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
        Position processOwner = positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId());
        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();
        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());
        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())
            licenseStateInfo.setRejectionPosition(processOwner.getId());

        if (!license.hasState())
            license.transition().start();
        else
            license.transition().startNext();

        license.transition()
                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))
                .withSenderName(currentUser.getName())
                .withComments(license.getWorkflowContainer().getApproverComments())
                .withStateValue(workflowMatrix.getNextState())
                .withDateInfo(new Date())
                .withOwner(processOwner)
                .withNextAction(workflowMatrix.getNextAction())
                .withExtraInfo(licenseStateInfo)
                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())
                .withInitiator(flowInitiator);
    }

    private void startClosureProcessByExternalUsers(TradeLicense license) {
        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
        List<Assignment> assignments = licenseProcessWorkflowService.getAssignments(workflowMatrix, license.getAdminWard());

        Position processOwner = assignments.get(0).getPosition();
        LicenseStateInfo licenseStateInfo = new LicenseStateInfo();
        licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());
        if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())
            licenseStateInfo.setRejectionPosition(processOwner.getId());

        if (!license.hasState())
            license.transition().start();

        else
            license.transition().startNext();

        license.transition()
                .withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))
                .withSenderName(securityUtils.getCurrentUser().getName())
                .withComments(license.getWorkflowContainer().getApproverComments())
                .withStateValue(workflowMatrix.getNextState())
                .withDateInfo(new Date())
                .withOwner(processOwner)
                .withNextAction(workflowMatrix.getNextAction())
                .withExtraInfo(licenseStateInfo)
                .withNatureOfTask(licenseAppTypeService.getLicenseAppTypeByCode(CLOSURE_APPTYPE_CODE).getName())
                .withInitiator(processOwner);
    }

    public void processCancellation(TradeLicense license) {
        User currentUser = securityUtils.getCurrentUser();
        license.transition().end()
                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())
                .withComments(license.getWorkflowContainer().getApproverComments())
                .withDateInfo(new Date())
                .withNextAction(COMPLETED);
    }

    public void processApproval(TradeLicense license) {
        license.getWorkflowContainer().setAdditionalRule(CLOSURE_ADDITIONAL_RULE);
        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
        User currentUser = securityUtils.getCurrentUser();
        license.transition().end()
                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())
                .withComments(licenseConfigurationService.digitalSignEnabled() ? WF_DIGI_SIGNED : "Approved")
                .withDateInfo(new Date())
                .withStateValue(workflowMatrix.getNextState())
                .withNextAction(COMPLETED);
        license.setApprovedBy(currentUser);
    }

    public void processForward(TradeLicense license) {
        User currentUser = securityUtils.getCurrentUser();
        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
        LicenseStateInfo licenseStateInfo = license.extraInfo();
        if (workflowMatrix.isRejectEnabled())
            licenseStateInfo.setRejectionPosition(license.getCurrentState().getOwnerPosition().getId());

        license.transition().progressWithStateCopy()
                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())
                .withComments(license.getWorkflowContainer().getApproverComments())
                .withStateValue(workflowMatrix.getNextState())
                .withDateInfo(new Date())
                .withOwner(positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId()))
                .withNextAction(workflowMatrix.getNextAction())
                .withExtraInfo(licenseStateInfo);
    }

    public void processRejection(TradeLicense license) {
        User currentUser = securityUtils.getCurrentUser();
        WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
        LicenseStateInfo licenseStateInfo = license.extraInfo();
        Position processOwner;
        if (licenseStateInfo.getRejectionPosition() != null
                && !licenseStateInfo.getRejectionPosition().equals(license.getCurrentState().getOwnerPosition().getId()))
            processOwner = positionMasterService.getPositionById(licenseStateInfo.getRejectionPosition());
        else
            processOwner = license.getCurrentState().getInitiatorPosition();
        license.transition().progressWithStateCopy()
                .withSenderName(currentUser.getUsername() + DELIMITER_COLON + currentUser.getName())
                .withComments(license.getWorkflowContainer().getApproverComments())
                .withStateValue(workflowMatrix.getNextState())
                .withDateInfo(new Date())
                .withOwner(processOwner)
                .withNextAction(workflowMatrix.getNextAction())
                .withExtraInfo(licenseStateInfo);
    }

    public WorkFlowMatrix getWorkFlowMatrix(TradeLicense tradeLicense) {
        WorkflowContainer workflowContainer = tradeLicense.getWorkflowContainer();
        String additionalRule = BUTTONREJECT.equals(workflowContainer.getWorkFlowAction())
                ? CLOSURE_LICENSE_REJECT : workflowContainer.getAdditionalRule();
        WorkFlowMatrix workflowMatrix;
        if (tradeLicense.transitionInprogress()) {
            State<Position> state = tradeLicense.getState();
            workflowMatrix = this.licenseWorkflowService.getWfMatrix(
                    tradeLicense.getStateType(), "ANY", null, additionalRule,
                    workflowContainer.getCurrentState() == null ? state.getValue() : workflowContainer.getCurrentState(),
                    null, new Date(), workflowContainer.getCurrentDesignation() == null
                            ? "%" + state.getOwnerPosition().getDeptDesig().getDesignation().getName() + "%" :
                            workflowContainer.getCurrentDesignation());
        } else {
            workflowMatrix = this.licenseWorkflowService.getWfMatrix(tradeLicense.getStateType(), null,
                    null, workflowContainer.getAdditionalRule(), "Start", null, new Date(), null);
        }
        return workflowMatrix;
    }
}
```


Overlapping Code:
```
@Service
@Transactional(readOnly = true)
public class LicenseClosureProcessflowService {
@Autowired
private SecurityUtils securityUtils;
@Autowired
private LicenseConfigurationService licenseConfigurationService;
@Autowired
private AssignmentService assignmentService;
@Autowired
private PositionMasterService positionMasterService;
@Autowired
private LicenseProcessWorkflowService licenseProcessWorkflowService;
@Autowired
@Qualifier("workflowService")
private SimpleWorkflowService<TradeLicense> licenseWorkflowService;
@Autowired
private LicenseUtils licenseUtils;
@Autowired
private LicenseAppTypeService licenseAppTypeService;
public void startClosureProcessflow(TradeLicense license) {
if (securityUtils.currentUserIsEmployee()) {
startClosureProcessByEmployee(license);
} else {
startClosureProcessByExternalUsers(license);
}
}
private void startClosureProcessByEmployee(TradeLicense license) {
User currentUser = securityUtils.getCurrentUser();
List<Assignment> assignments = assignmentService.getAllActiveEmployeeAssignmentsByEmpId(currentUser.getId());
Position flowInitiator = assignments.get(0).getPosition();
WorkFlowMatrix workflowMatrix = getWorkFlowMatrix(license);
Position processOwner = positionMasterService.getPositionById(license.getWorkflowContainer().getApproverPositionId());
LicenseStateInfo licenseStateInfo = new LicenseStateInfo();
licenseStateInfo.setOldAppType(license.getLicenseAppType().getName());
if (workflowMatrix.isRejectEnabled() != null && workflowMatrix.isRejectEnabled())
licenseStateInfo.setRejectionPosition(processOwner.getId());
if (!license.hasState())
license.transition().start();
else
license.transition().startNext();
license.transition()
.withSLA(licenseUtils.getSlaForAppType(licenseAppTypeService.getClosureLicenseApplicationType()))
.withSenderName(currentUser.getName())
.withComments(license.getWorkflowContainer().getApproverComments())
.withStateValue(workflowMatrix.getNextState())
.withDateInfo(new Date())
.withOwner(processOwner)
.withNextAction(workflowMatrix.getNextAction())
.withExtraInfo(licenseStateInfo)
.wi
```
<Overlap Ratio: 0.9937799043062201>

---

--- 123 --
Question ID: 23d45a57d49b97eced4076aa7dcdb4d8b5d08c19
Original Code:
```
class dq$1
	implements fg$c
{

	public void a()
	{
		dq.a(a).r();
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field dq a>
	//    2    4:invokestatic    #23  <Method s dq.a(dq)>
	//    3    7:invokeinterface #28  <Method void s.r()>
	//    4   12:return          
	}

	final dq a;

	dq$1(dq dq1)
	{
		a = dq1;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #16  <Field dq a>
		super();
	//    3    5:aload_0         
	//    4    6:invokespecial   #19  <Method void Object()>
	//    5    9:return          
	}
}
```


Overlapping Code:
```
{
public void a()
{
dq.a(a).r();
// 0 0:aload_0 
// 1 1:getfield #16 <Field dq a>
// 2 4:invokestatic #23 <Method s dq.a(dq)>
// 3 7:invokeinterface #28 <Method void s.r()>
// 4 12:return 
}
final dq a;
dq$1(dq dq1)
{
a = dq1;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #16 <Field dq a>
super();
// 3 5:aload_0 
// 4 6:invokespecial #19 <Method void Object()>
// 5 9:return 
}
}
```
<Overlap Ratio: 0.9341463414634147>

---

--- 124 --
Question ID: 70a166c3a407c99fd83bbca65b2a0445bfa500fc
Original Code:
```
@ObfuscatedName("fc")
@Implements("MilliClock")
public class MilliClock extends Clock {
	@ObfuscatedName("z")
	long[] field1993;
	@ObfuscatedName("n")
	@ObfuscatedGetter(
		intValue = 1174263325
	)
	int field1992;
	@ObfuscatedName("v")
	@ObfuscatedGetter(
		intValue = -133065269
	)
	int field1994;
	@ObfuscatedName("u")
	@ObfuscatedGetter(
		longValue = 4855142476282651555L
	)
	long field1997;
	@ObfuscatedName("r")
	@ObfuscatedGetter(
		intValue = -118742351
	)
	int field1996;
	@ObfuscatedName("p")
	@ObfuscatedGetter(
		intValue = -432514755
	)
	int field1995;

	MilliClock() {
		this.field1993 = new long[10];
		this.field1992 = 256;
		this.field1994 = 1;
		this.field1996 = 0;
		this.field1997 = class30.currentTimeMillis();

		for (int var1 = 0; var1 < 10; ++var1) {
			this.field1993[var1] = this.field1997;
		}

	}

	@ObfuscatedName("z")
	@ObfuscatedSignature(
		signature = "(B)V",
		garbageValue = "-54"
	)
	@Export("mark")
	public void mark() {
		for (int var1 = 0; var1 < 10; ++var1) {
			this.field1993[var1] = 0L;
		}

	}

	@ObfuscatedName("n")
	@ObfuscatedSignature(
		signature = "(III)I",
		garbageValue = "569029249"
	)
	@Export("wait")
	public int wait(int var1, int var2) {
		int var3 = this.field1992;
		int var4 = this.field1994;
		this.field1992 = 300;
		this.field1994 = 1;
		this.field1997 = class30.currentTimeMillis();
		if (0L == this.field1993[this.field1995]) {
			this.field1992 = var3;
			this.field1994 = var4;
		} else if (this.field1997 > this.field1993[this.field1995]) {
			this.field1992 = (int)((long)(var1 * 2560) / (this.field1997 - this.field1993[this.field1995]));
		}

		if (this.field1992 < 25) {
			this.field1992 = 25;
		}

		if (this.field1992 > 256) {
			this.field1992 = 256;
			this.field1994 = (int)((long)var1 - (this.field1997 - this.field1993[this.field1995]) / 10L);
		}

		if (this.field1994 > var1) {
			this.field1994 = var1;
		}

		this.field1993[this.field1995] = this.field1997;
		this.field1995 = (this.field1995 + 1) % 10;
		if (this.field1994 > 1) {
			for (int var5 = 0; var5 < 10; ++var5) {
				if (0L != this.field1993[var5]) {
					this.field1993[var5] += (long)this.field1994;
				}
			}
		}

		if (this.field1994 < var2) {
			this.field1994 = var2;
		}

		long var10 = (long)this.field1994;
		if (var10 > 0L) {
			if (var10 % 10L == 0L) {
				long var7 = var10 - 1L;

				try {
					Thread.sleep(var7);
				} catch (InterruptedException var16) {
				}

				try {
					Thread.sleep(1L);
				} catch (InterruptedException var15) {
				}
			} else {
				try {
					Thread.sleep(var10);
				} catch (InterruptedException var14) {
				}
			}
		}

		int var13;
		for (var13 = 0; this.field1996 < 256; this.field1996 += this.field1992) {
			++var13;
		}

		this.field1996 &= 255;
		return var13;
	}
}
```


Overlapping Code:
```
)
@Implements("MilliClock")
public class MilliClock extends Clock {
@ObfuscatedName("z")
long[] field1993;
@ObfuscatedName("n")
@ObfuscatedGetter(
intValue = 1174263325
)
int field1992;
@ObfuscatedName("v")
@ObfuscatedGetter(
intValue = -133065269
)
int field1994;
@ObfuscatedName("u")
@ObfuscatedGetter(
longValue = 4855142476282651555L
)
long field1997;
@ObfuscatedName("r")
@ObfuscatedGetter(
intValue = -118742351
)
int field1996;
@ObfuscatedName("p")
@ObfuscatedGetter(
intValue = -432514755
)
int field1995;
MilliClock() {
this.field1993 = new long[10];
this.field1992 = 256;
this.field1994 = 1;
this.field1996 = 0;
this.field1997 = class30.currentTimeMillis();
for (int var1 = 0; var1 < 10; ++var1) {
this.field1993[var1] = this.field1997;
}
}
@ObfuscatedName("z")
@ObfuscatedSignature(
signature = "(B)V",
garbageValue = "-54"
)
@Export("mark")
public void mark() {
for (int var1 = 0; var1 < 10; ++var1) {
this.field1993[var1] = 0L;
}
}
@ObfuscatedName("n")
@ObfuscatedSignature(
signature = "(III)I",
garbageValue = "569029249"
)
@Export("wait")
public int wait(int var1, int var2) {
int var3 = this.field1992;
int var4 = this.field1994;
this.field1992 = 300;
this.field1994 = 1;
this.field1997 = class30.currentTimeMillis();
if (0L == this.field1993[this.field1995]) {
this.field1992 = var3;
this.field1994 = var4;
} else if (this.field1997 > this.field1993[this.field1995]) {
this.field1992 = (int)((long)(var1 * 2560) / (this.field1997 - this.field1993[this.field1995]));
}
if (this.field1992 < 25) {
this.field1992 = 25;
}
if (this.field1992 > 256) {
this.field1992 = 256;
this.field1994 = (int)((long)var1 - (this.field1997 - this.field1993[this.field1995]) / 10L);
}
if (this.field1994 > var1) {
this.field1994 = var1;
}
this.field1993[this.field1995] = this.field1997;
this.field1995 = (this.field1995 + 1) % 10;
if (this.field1994 > 1) {
for (int var5 = 0; var5 < 10; ++var5) {
if (0L != this.field1993[var5]) {
this.field1993[var5] += (long)this.field1994;
}
}
}
if (this.field1994 < var2) {
this.field1994 = var2;
}
long var10 = (long)this.field1994;
if (var10 > 0L) {
if (var10 % 10L == 0L) {
long var7 = var10 - 1L;
try {
Thread.sleep(var7);
} catch (InterruptedException var16) {
}
try {
Thread.sleep(1L);
} catch (InterruptedException var
```
<Overlap Ratio: 0.9899299474605955>

---

--- 125 --
Question ID: 981c5dc4fccf04a61c0023635c6b2ee50fb23046
Original Code:
```
public class BookmarkActivity extends Activity {

	private Intent intent;

	public static final int MAXIMAGES = 10;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		intent = getIntent();
		String action = intent.getAction();
		String type = intent.getType();

		if (Intent.ACTION_SEND.equals(action) && type != null) {
			handleSendImage(intent);
		}
		if (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {
			handleSendMultipleImages(intent);
		}

		finish();
	}

	void handleSendImage(Intent intent) {
		Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
		if (imageUri != null) {
			new BookmarkTask(this).execute(imageUri);
		}
	}

	void handleSendMultipleImages(Intent intent) {
		ArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
		if (imageUris != null) {
			if (imageUris.size() <= MAXIMAGES) {
				new BookmarkTask(this).execute(imageUris.toArray(new Uri[0]));
			}
			else {
				String str = getString(R.string.msg_too_many, MAXIMAGES);
				Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
			}
		}
	}
}
```


Overlapping Code:
```
Activity extends Activity {
private Intent intent;
public static final int MAXIMAGES = 10;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
intent = getIntent();
String action = intent.getAction();
String type = intent.getType();
if (Intent.ACTION_SEND.equals(action) && type != null) {
handleSendImage(intent);
}
if (Intent.ACTION_SEND_MULTIPLE.equals(action) && type != null) {
handleSendMultipleImages(intent);
}
finish();
}
void handleSendImage(Intent intent) {
Uri imageUri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
if (imageUri != null) {
new BookmarkTask(this).execute(imageUri);
}
}
void handleSendMultipleImages(Intent intent) {
ArrayList<Uri> imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
if (imageUris != null) {
if (imageUris.size() <= MAXIMAGES) {
new BookmarkTask(this).execute(imageUris.toArray(new Uri[0]));
}
else {
String str = getString(R.string.msg_too_many, MAXIMAGES);
Toast.makeText(this, str, Toast.LENGTH_SHORT).show();
}

```
<Overlap Ratio: 0.9754716981132076>

---

--- 126 --
Question ID: bcaf35a80255ec75d456fd6ed06a66960e264ed7
Original Code:
```
public class GrpcConnector implements AutoCloseable{
    private static Logger logger = LoggerFactory.getLogger(GrpcConnector.class);
    private final LinkedList<String> addrs;
    private final ConcurrentHashMap<String, ManagedChannel> channelMap;
    private int robinIndex;
    public GrpcConnector(){
        addrs = new LinkedList<>();
        channelMap = new ConcurrentHashMap<>();
        robinIndex = 0;
    }

    public ManagedChannel getChannel(){
        String address = getAddrs();
        if(address == null){
            logger.info("Get channel failed for addrs is empty");
            return null;
        }

        ManagedChannel channel = channelMap.get(address);
        if(channel != null){
            return channel;
        }

        return createChannel(address);
    }

    public int getAddrsCount(){
        return addrs.size();
    }

    public void kickOutChannel(String serverName,String address){
        logger.info("Kick out {} channel for:{}", address, serverName);
        synchronized (this){
            ManagedChannel channel = channelMap.get(address);
            if(channel != null){
                channel.shutdown();
            }
            addrs.remove(address);
        }
    }

    public void addAddress(List<String> addrList){
        synchronized (this){
            for(String str: addrList){
                if(addrs.contains(str)){
                    continue;
                }
                addrs.add(str);
            }
        }
    }

    public void addAddress(String addr){
        synchronized (this){
            if(!addrs.contains(addr)){
                addrs.add(addr);
            }
        }
    }

    private ManagedChannel createChannel(String address){
        synchronized (this){
            ManagedChannel channel = channelMap.get(address);
            if(channel != null){
                return channel;
            }
            /***connect channel***/
            logger.info("Use server:{}", address);
            String[] host = address.split(":");
            channel = ManagedChannelBuilder.forAddress(host[0], Integer.valueOf(host[1])).usePlaintext().build();
            channelMap.put(address, channel);
            return channel;
        }
    }

    private String getAddrs(){
        synchronized (this){
            if(addrs.isEmpty()){
                return null;
            }
            int ridx = robinIndex % addrs.size();
            robinIndex = (robinIndex + 1) % addrs.size();
            return addrs.get(ridx);
        }
    }

    @Override
    public void close() throws Exception {
        synchronized (this){
            addrs.clear();
            for(ManagedChannel channel:channelMap.values()){
                channel.shutdown();
            }

            channelMap.clear();
        }
    }
}
```


Overlapping Code:
```
mplements AutoCloseable{
private static Logger logger = LoggerFactory.getLogger(GrpcConnector.class);
private final LinkedList<String> addrs;
private final ConcurrentHashMap<String, ManagedChannel> channelMap;
private int robinIndex;
public GrpcConnector(){
addrs = new LinkedList<>();
channelMap = new ConcurrentHashMap<>();
robinIndex = 0;
}
public ManagedChannel getChannel(){
String address = getAddrs();
if(address == null){
logger.info("Get channel failed for addrs is empty");
return null;
}
ManagedChannel channel = channelMap.get(address);
if(channel != null){
return channel;
}
return createChannel(address);
}
public int getAddrsCount(){
return addrs.size();
}
public void kickOutChannel(String serverName,String address){
logger.info("Kick out {} channel for:{}", address, serverName);
synchronized (this){
ManagedChannel channel = channelMap.get(address);
if(channel != null){
channel.shutdown();
}
addrs.remove(address);
}
}
public void addAddress(List<String> addrList){
synchronized (this){
for(String str: addrList){
if(addrs.contains(str)){
continue;
}
addrs.add(str);
}
}
}
public void addAddress(String addr){
synchronized (this){
if(!addrs.contains(addr)){
addrs.add(addr);
}
}
}
private ManagedChannel createChannel(String address){
synchronized (this){
ManagedChannel channel = channelMap.get(address);
if(channel != null){
return channel;
}
/***connect channel***/
logger.info("Use server:{}", address);
String[] host = address.split(":");
channel = ManagedChannelBuilder.forAddress(host[0], Integer.valueOf(host[1])).usePlaintext().build();
channelMap.put(address, channel);
return channel;
}
}
private String getAddrs(){
synchronized (this){
if(addrs.isEmpty()){
return null;
}
int ridx = robinIndex % addrs.size();
robinIndex = (robinIndex +
```
<Overlap Ratio: 0.9741046831955923>

---

--- 127 --
Question ID: 5913abb6ae4e4434205e8ee24b456b8fe22365e2
Original Code:
```
public class UglyNumber {
    public static int GetUglyNumber_Solution(int index) {
        List<Integer> array = new ArrayList<>(index - 1);
        List<Integer> ugly = new ArrayList<>();
        ugly.add(2);
        ugly.add(3);
        ugly.add(5);
        array.add(1);
        int num = 2;
        while (array.size() < index) {
            List<Integer> primeNumber = new ArrayList<>();
            for (int i = 2; i < num; i++) {
                if (num % i == 0) {
                    primeNumber.add(i);
                }
            }
            primeNumber.removeAll(ugly);
            if (primeNumber.size() == 0) {
                array.add(num++);
            }
        }
        return array.get(array.size() - 1);
    }

    public static void main(String[] args) {
        System.out.println(GetUglyNumber_Solution(8));
    }
}
```


Overlapping Code:
```
ublic static int GetUglyNumber_Solution(int index) {
List<Integer> array = new ArrayList<>(index - 1);
List<Integer> ugly = new ArrayList<>();
ugly.add(2);
ugly.add(3);
ugly.add(5);
array.add(1);
int num = 2;
while (array.size() < index) {
List<Integer> primeNumber = new ArrayList<>();
for (int i = 2; i < num; i++) {
if (num % i == 0) {
primeNumber.add(i);
}
}
primeNumber.removeAll(ugly);
if (primeNumber.size() == 0) {
array.add(num++);
}
}
return array.get(array.size() - 1);
}
public static void main(String[] args) {
System.out.println(GetUglyNumber_Solution(8
```
<Overlap Ratio: 0.9434276206322796>

---

--- 128 --
Question ID: 3c36230c7f758bdd0997c580bc150ea871a1ca75
Original Code:
```
@Singleton
public class WorkspaceShareWithMe implements ParameterizedHandler {
    private final UserRepository userRepository;
    private final WorkspaceRepository workspaceRepository;

    @Inject
    public WorkspaceShareWithMe(
            final UserRepository userRepository,
            final WorkspaceRepository workspaceRepository
    ) {
        this.userRepository = userRepository;
        this.workspaceRepository = workspaceRepository;
    }

    @Handle
    public ClientApiSuccess handle(
            @Required(name = "workspaceId") String workspaceId,
            @Required(name = "user-name") String userName,
            User me
    ) throws Exception {
        User user = userRepository.findByUsername(userName);
        if (user == null) {
            throw new OpenLumifyResourceNotFoundException("Could not find user: " + userName);
        }

        Workspace workspace = workspaceRepository.findById(workspaceId, user);
        if (workspace == null) {
            throw new OpenLumifyResourceNotFoundException("Could not find workspace: " + workspaceId);
        }

        workspaceRepository.updateUserOnWorkspace(workspace, me.getUserId(), WorkspaceAccess.WRITE, user);

        return OpenLumifyResponse.SUCCESS;
    }
}
```


Overlapping Code:
```
public class WorkspaceShareWithMe implements ParameterizedHandler {
private final UserRepository userRepository;
private final WorkspaceRepository workspaceRepository;
@Inject
public WorkspaceShareWithMe(
final UserRepository userRepository,
final WorkspaceRepository workspaceRepository
) {
this.userRepository = userRepository;
this.workspaceRepository = workspaceRepository;
}
@Handle
public ClientApiSuccess handle(
@Required(name = "workspaceId") String workspaceId,
@Required(name = "user-name") String userName,
User me
) throws Exception {
User user = userRepository.findByUsername(userName);
if (user == null) {
throw new OpenLumifyResourceNotFoundException("Could not find user: " + userName);
}
Workspace workspace = workspaceRepository.findById(workspaceId, user);
if (workspace == null) {
throw new OpenLumifyResourceNotFoundException("Could not find workspace: " + workspaceId);
}
workspaceRepository.updateUserOnWorkspace(workspace, me.getUserId(), WorkspaceAccess.WRITE, user);
return OpenL
```
<Overlap Ratio: 0.9645254074784276>

---

--- 129 --
Question ID: da20f5758911f23636511305d40b1855af9c2d22
Original Code:
```
public class RegisterDAOImpl implements lk.ijse.dep.akashStainlessSteel.dao.custom.RegisterDAO {


    @Override
    public boolean saveRegister(RegisterEntity registerEntity) throws Exception {
        return CrudUtil.execute("INSERT INTO register VALUES (?,?,?)",
                registerEntity.getUserType(),
                registerEntity.getUserName(),
                registerEntity.getPassword()
        );
    }

    @Override
    public boolean deleteRegister(String userName) throws Exception {
        CrudUtil.execute("DELETE FROM register WHERE userName = ?",userName);
        return false;
    }

    @Override
    public boolean updateRegister(RegisterEntity registerEntity) throws Exception {
        return CrudUtil.execute("UPDATE register SET password = ?,userType = ?WHERE userName =?" ,
                registerEntity.getPassword(),
                registerEntity.getUserType(),
                registerEntity.getUserName()

        );
    }

    @Override
    public List<RegisterEntity> findAllRegisters() throws Exception {
        ResultSet resultSet = CrudUtil.execute("SELECT * FROM register");
        List<RegisterEntity> alRegisters = new ArrayList<>();
        while (resultSet.next()){
            alRegisters.add(new RegisterEntity(
                    resultSet.getString(1),
                    resultSet.getString(2),
                    resultSet.getString(3)
            ));
        }
        return alRegisters;
    }

    @Override
    public RegisterEntity findRegister(String userName) throws Exception {
        ResultSet resultSet = CrudUtil.execute("SELECT * FROM register WHERE userName =?",userName);
        if(resultSet.next()){
            return new RegisterEntity(
                    resultSet.getString(1),
                    resultSet.getString(2),
                    resultSet.getString(3)
            );
        }
        return null;
    }
}
```


Overlapping Code:
```
public class RegisterDAOImpl implements lk.ijse.dep.akashStainlessSteel.dao.custom.RegisterDAO {
@Override
public boolean saveRegister(RegisterEntity registerEntity) throws Exception {
return CrudUtil.execute("INSERT INTO register VALUES (?,?,?)",
registerEntity.getUserType(),
registerEntity.getUserName(),
registerEntity.getPassword()
);
}
@Override
public boolean deleteRegister(String userName) throws Exception {
CrudUtil.execute("DELETE FROM register WHERE userName = ?",userName);
return false;
}
@Override
public boolean updateRegister(RegisterEntity registerEntity) throws Exception {
return CrudUtil.execute("UPDATE register SET password = ?,userType = ?WHERE userName =?" ,
registerEntity.getPassword(),
registerEntity.getUserType(),
registerEntity.getUserName()
);
}
@Override
public List<RegisterEntity> findAllRegisters() throws Exception {
ResultSet resultSet = CrudUtil.execute("SELECT * FROM register");
List<RegisterEntity> alRegisters = new ArrayList<>();
while (resultSet.next()){
alRegisters.add(new RegisterEntity(
resultSet.getString(1),
resultSet.getString(2),
resultSet.getString(3)
));
}
return alRegisters;
}
@Override
public RegisterEntity findRegister(String userName) throws Exception {
ResultSet resultSet = CrudUtil.execute("SELECT * FROM register WHERE userName =?",userName);
if(resultSet.next()){
return new RegisterEntity(
resultSet.getString(1),
resultSet.getString(2),
resultSet.getString(3)
);
}
return null;
}

```
<Overlap Ratio: 0.9993108201240524>

---

--- 130 --
Question ID: 2265c1d4383d6d2de66da1a0deeeda03b46626c5
Original Code:
```
public class ApplicationActor extends UntypedActor {

  private static final Logger LOG = LoggerFactory.getLogger(ApplicationActor.class);

  private final AkkaContext context;

  private final Map<EndpointObjectHash, GlobalEndpointActorMetaData> globalEndpointSessions;
  /**
   * The endpoint sessions.
   */
  private final Map<EndpointObjectHash, LocalEndpointActorMetaData> localEndpointSessions;

  private final Map<String, EndpointObjectHash> endpointActorMap;

  /**
   * The topic sessions.
   */
  private final Map<String, ActorRef> topicSessions;

  private final String nodeId;

  private final String tenantId;

  private final String appToken;

  private final Map<String, ActorRef> logsSessions;

  private final Map<String, ActorRef> userVerifierSessions;

  private ActorRef applicationLogActor;

  private ActorRef userVerifierActor;

  /**
   * Instantiates a new application actor.
   *
   * @param context          the context
   * @param applicationToken the application token
   */
  private ApplicationActor(AkkaContext context, String tenantId, String applicationToken) {
    this.context = context;
    this.nodeId = context.getClusterService().getNodeId();
    this.tenantId = tenantId;
    this.appToken = applicationToken;
    this.globalEndpointSessions = new HashMap<>();
    this.localEndpointSessions = new HashMap<>();
    this.endpointActorMap = new HashMap<>();
    this.topicSessions = new HashMap<>();
    this.logsSessions = new HashMap<>();
    this.userVerifierSessions = new HashMap<>();
    this.applicationLogActor = getOrCreateLogActor();
    this.userVerifierActor = getOrCreateUserVerifierActor();
  }

  /**
   * Builds the topic key.
   *
   * @param topicId the topic id
   * @return the string
   */
  public static String buildTopicKey(String topicId) {
    // TODO: Improve;
    return topicId;
  }

  @Override
  public SupervisorStrategy supervisorStrategy() {
    return SupervisionStrategyFactory.createApplicationActorStrategy(context);
  }

  /*
   * (non-Javadoc)
   *
   * @see akka.actor.UntypedActor#onReceive(java.lang.Object)
   */
  @Override
  public void onReceive(Object message) throws Exception {
    if (LOG.isTraceEnabled()) {
      LOG.trace("[{}] Received: {}", appToken, message);
    } else {
      LOG.debug("[{}] Received: {}", appToken, message.getClass().getName());
    }
    if (message instanceof EndpointAwareMessage) {
      processEndpointAwareMessage((EndpointAwareMessage) message);
    }
    if (message instanceof EndpointActorMsg) {
      processEndpointActorMsg((EndpointActorMsg) message);
    } else if (message instanceof SessionAware) {
      processSessionAwareMessage((SessionAware) message);
    } else if (message instanceof EndpointEventDeliveryMessage) {
      processEndpointEventDeliveryMessage((EndpointEventDeliveryMessage) message);
    } else if (message instanceof Terminated) {
      processTermination((Terminated) message);
    } else if (message instanceof ThriftNotificationMessage) {
      processThriftNotification((ThriftNotificationMessage) message);
    } else if (message instanceof EndpointStopMessage) {
      updateEndpointActor((EndpointStopMessage) message);
    } else if (message instanceof LogEventPackMessage) {
      processLogEventPackMessage((LogEventPackMessage) message);
    } else if (message instanceof UserVerificationRequestMessage) {
      processUserVerificationRequestMessage((UserVerificationRequestMessage) message);
    } else if (message instanceof EndpointUserActionMessage) {
      processEndpointUserActionMessage((EndpointUserActionMessage) message, true);
    } else if (message instanceof EndpointUserActionRouteMessage) {
      processEndpointUserActionMessage(((EndpointUserActionRouteMessage) message).getMessage(),
          false);
    } else if (message instanceof StatusRequestMessage) {
      processStatusRequest((StatusRequestMessage) message);
    } else if (message instanceof ClusterUpdateMessage) {
      processClusterUpdate((ClusterUpdateMessage) message);
    } else if (message instanceof RouteMessage<?>) {
      processRouteMessage((RouteMessage<?>) message);
    }
  }

  private void processEndpointActorMsg(EndpointActorMsg message) {
    EndpointAddress address = message.getAddress();
    EndpointObjectHash endpointId = EndpointObjectHash.fromBytes(address.getEntityId());
    ActorClassifier classifier = message.getClassifier();
    if (classifier == ActorClassifier.APPLICATION) {
      boolean processed = false;
      if (message instanceof ThriftEndpointActorMsg<?>) {
        processed = processCommonThriftEndpointActorMsg(
            endpointId, (ThriftEndpointActorMsg<?>) message);
      }
      if (!processed) {
        LOG.warn("[{}] Failed to lookup processor for endpoint msg {}.", endpointId, message);
      }
    } else {
      EndpointActorMetaData actorMetaData = null;
      if (classifier == ActorClassifier.GLOBAL) {
        actorMetaData = globalEndpointSessions.get(endpointId);
      } else if (classifier == ActorClassifier.LOCAL) {
        actorMetaData = localEndpointSessions.get(endpointId);
      }
      if (actorMetaData != null) {
        actorMetaData.actorRef.tell(message, context().self());
      } else {
        LOG.warn("[{}] Failed to lookup {} actor for endpoint.", endpointId, classifier.name());
      }
    }
  }

  private boolean processCommonThriftEndpointActorMsg(EndpointObjectHash endpointId,
                                                      ThriftEndpointActorMsg<?> msg) {
    if (msg.getMsg() instanceof ThriftEndpointDeregistrationMessage) {
      forwardMessageQuietly(globalEndpointSessions.get(endpointId), msg);
      forwardMessageQuietly(localEndpointSessions.get(endpointId), msg);
      return true;
    } else {
      return false;
    }
  }

  private void forwardMessageQuietly(EndpointActorMetaData actorMetaData, Object msg) {
    if (actorMetaData != null) {
      actorMetaData.actorRef.tell(msg, context().self());
    }
  }

  private void processClusterUpdate(ClusterUpdateMessage message) {
    for (Entry<EndpointObjectHash, LocalEndpointActorMetaData> entry :
        localEndpointSessions.entrySet()) {
      String globalActorNodeId = getGlobalEndpointActorNodeId(entry.getKey());
      if (!globalActorNodeId.equals(entry.getValue().globalActorNodeId)) {
        entry.getValue().globalActorNodeId = globalActorNodeId;
        notifyGlobalEndpointActor(entry.getKey(), globalActorNodeId);
      }
    }
    for (GlobalEndpointActorMetaData entry : globalEndpointSessions.values()) {
      entry.actorRef.tell(message, context().self());
    }
  }

  /**
   * Process log event pack message.
   *
   * @param message the message
   */
  private void processLogEventPackMessage(LogEventPackMessage message) {
    LOG.debug("[{}] Processing log event pack message", appToken);
    applicationLogActor.tell(message, self());
  }

  private void processUserVerificationRequestMessage(UserVerificationRequestMessage message) {
    LOG.debug("[{}] Processing user verification request message", appToken);
    userVerifierActor.tell(message, self());
  }

  private void processLogNotificationMessage(ThriftNotificationMessage message) {
    processThriftNotificationMessage(applicationLogActor, message);
  }

  private void processUserVerifierNotificationMessage(ThriftNotificationMessage message) {
    processThriftNotificationMessage(userVerifierActor, message);
  }

  private void processThriftNotificationMessage(ActorRef actor, ThriftNotificationMessage message) {
    LOG.debug("[{}] Processing thrift notification message {}", appToken, message);
    actor.tell(message, self());
  }

  private void processStatusRequest(StatusRequestMessage message) {
    LOG.debug("[{}] Processing status request", message.getId());
    int endpointCount = localEndpointSessions.size();
    context().parent()
        .tell(new ApplicationActorStatusResponse(message.getId(), endpointCount),
            ActorRef.noSender());
  }

  /**
   * Process thrift notification.
   *
   * @param message the message
   */
  private void processThriftNotification(ThriftNotificationMessage message) {
    Notification notification = message.getNotification();
    if (notification.isSetNotificationId()) {
      LOG.debug("[{}] Forwarding message to specific topic", appToken);
      sendToSpecificTopic(message);
    } else if (notification.isSetAppenderId()) {
      LOG.debug("[{}] Forwarding message to application log actor", appToken);
      processLogNotificationMessage(message);
    } else if (notification.isSetUserVerifierToken()) {
      LOG.debug("[{}] Forwarding message to application user verifier actor", appToken);
      processUserVerifierNotificationMessage(message);
    } else {
      LOG.debug("[{}] Broadcasting message to all endpoints", appToken);
      broadcastToAllEndpoints(message);
    }
  }

  /**
   * Send to specific topic.
   *
   * @param message the message
   */
  private void sendToSpecificTopic(ThriftNotificationMessage message) {
    Notification notification = message.getNotification();
    ActorRef topicActor = getOrCreateTopic(notification.getTopicId());
    topicActor.tell(message, self());
  }

  /**
   * Gets the or create topic.
   *
   * @param topicId the topic id
   * @return the or create topic
   */
  private ActorRef getOrCreateTopic(String topicId) {
    ActorRef topicActor = topicSessions.get(topicId);
    if (topicActor == null) {
      topicActor = context().actorOf(
          Props.create(new TopicActor.ActorCreator(context.getNotificationDeltaService()))
              .withDispatcher(TOPIC_DISPATCHER_NAME),
          buildTopicKey(topicId)
      );
      topicSessions.put(topicId, topicActor);
      context().watch(topicActor);
    }
    return topicActor;
  }

  /**
   * Broadcast to all endpoints.
   *
   * @param message the message
   */
  private void broadcastToAllEndpoints(ThriftNotificationMessage message) {
    for (LocalEndpointActorMetaData endpoint : localEndpointSessions.values()) {
      endpoint.actorRef.tell(message, self());
    }
  }

  /**
   * Process endpoint aware message.
   *
   * @param message the message
   */
  private void processEndpointAwareMessage(EndpointAwareMessage message) {
    if (message instanceof TopicSubscriptionMessage) {
      processEndpointTopicRegistration((TopicSubscriptionMessage) message);
    } else if (message instanceof EndpointUserConnectMessage) {
      processEndpointUserRegistration((EndpointUserConnectMessage) message);
    } else if (message instanceof EndpointUserDisconnectMessage) {
      processEndpointUserDeregistration((EndpointUserDisconnectMessage) message);
    } else if (message instanceof EndpointEventSendMessage) {
      processEndpointEventSendMessage((EndpointEventSendMessage) message);
    } else if (message instanceof EndpointEventReceiveMessage) {
      processEndpointEventReceiveMessage((EndpointEventReceiveMessage) message);
    } else {
      processEndpointRequest(message);
    }
  }

  /**
   * Process endpoint aware message.
   *
   * @param message the message
   */
  private void processSessionAwareMessage(SessionAware message) {
    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions
        .get(message.getSessionInfo().getKey());
    if (endpointMetaData != null) {
      endpointMetaData.actorRef.tell(message, self());
    } else {
      LOG.debug("[{}] Can't find endpoint actor that corresponds to {}",
          appToken, message.getSessionInfo().getKey());
    }
  }

  private void processEndpointEventReceiveMessage(EndpointEventReceiveMessage message) {
    LocalEndpointActorMetaData endpointActor = localEndpointSessions.get(message.getKey());
    if (endpointActor != null) {
      endpointActor.actorRef.tell(message, self());
    } else {
      LOG.debug("[{}] Can't find endpoint actor that corresponds to {}",
          appToken, message.getKey());
      context().parent()
          .tell(new EndpointEventDeliveryMessage(message, EventDeliveryStatus.FAILURE), self());
    }
  }

  private void processEndpointEventSendMessage(EndpointEventSendMessage message) {
    LOG.debug("[{}] Forwarding message to specific user", appToken, message.getUserId());
    context().parent().tell(message, self());
  }

  private void processEndpointEventDeliveryMessage(EndpointEventDeliveryMessage message) {
    LOG.debug("[{}] Forwarding message to specific user", appToken, message.getUserId());
    context().parent().tell(message, self());
  }

  /**
   * Process endpoint registration.
   *
   * @param message the message
   */
  private void processEndpointTopicRegistration(TopicSubscriptionMessage message) {
    ActorRef topicActor = getOrCreateTopic(message.getTopicId());
    topicActor.tell(message, self());
  }

  /**
   * Process endpoint registration.
   *
   * @param message the message
   */
  private void processEndpointUserRegistration(EndpointUserConnectMessage message) {
    context().parent().tell(message, self());
  }

  /**
   * Process endpoint deregistration.
   *
   * @param message the message
   */
  private void processEndpointUserDeregistration(EndpointUserDisconnectMessage message) {
    context().parent().tell(message, self());
  }

  /**
   * Process session endpoint request.
   *
   * @param message the message
   */
  private void processEndpointRequest(EndpointAwareMessage message) {
    LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(message.getKey());
    if (actorMetaData == null) {
      EndpointObjectHash endpointKey = message.getKey();
      String endpointActorId = LocalEndpointActorCreator.generateActorKey();
      LOG.debug("[{}] Creating actor with endpointKey: {}", appToken, endpointActorId);
      String globalActorNodeId = getGlobalEndpointActorNodeId(endpointKey);
      actorMetaData = new LocalEndpointActorMetaData(context()
          .actorOf(Props
              .create(new LocalEndpointActorCreator(
                  context,
                  endpointActorId,
                  message.getAppToken(),
                  message.getKey()
              )).withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),
          endpointActorId, globalActorNodeId);
      localEndpointSessions.put(message.getKey(), actorMetaData);
      endpointActorMap.put(endpointActorId, message.getKey());
      context().watch(actorMetaData.actorRef);
      notifyGlobalEndpointActor(endpointKey, globalActorNodeId);
    }
    actorMetaData.actorRef.tell(message, self());
  }

  private String getGlobalEndpointActorNodeId(EndpointObjectHash endpointKey) {
    return context.getClusterService().getEntityNode(endpointKey);
  }

  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey, String globalActorNodeId) {
    notifyGlobalEndpointActor(endpointKey, globalActorNodeId, RouteOperation.ADD);
  }

  private void notifyGlobalEndpointActor(EndpointObjectHash endpointKey,
                                         String globalActorNodeId, RouteOperation operation) {
    EndpointRouteMessage msg = new EndpointRouteMessage(
        new EndpointClusterAddress(nodeId, tenantId, appToken, endpointKey), operation);
    if (globalActorNodeId.equals(nodeId)) {
      processEndpointRouteMessage(msg);
    } else {
      context.getClusterService().sendRouteMessage(msg);
    }
  }

  private void processRouteMessage(RouteMessage<?> msg) {
    if (msg instanceof EndpointRouteMessage) {
      processEndpointRouteMessage((EndpointRouteMessage) msg);
    }
  }

  private void processEndpointRouteMessage(EndpointRouteMessage msg) {
    EndpointObjectHash endpointKey = msg.getAddress().getEndpointKey();
    GlobalEndpointActorMetaData actorMetaData = globalEndpointSessions.get(endpointKey);
    if (actorMetaData == null) {
      String endpointActorId = GlobalEndpointActorCreator.generateActorKey();
      LOG.debug("[{}] Creating global endpoint actor for endpointKey: {}", appToken, endpointKey);
      actorMetaData = new GlobalEndpointActorMetaData(
          context().actorOf(Props.create(
              new GlobalEndpointActorCreator(context, endpointActorId, appToken, endpointKey))
              .withDispatcher(ENDPOINT_DISPATCHER_NAME), endpointActorId),
          endpointActorId);
      globalEndpointSessions.put(endpointKey, actorMetaData);
      context().watch(actorMetaData.actorRef);
    }
    actorMetaData.actorRef.tell(msg, self());
  }

  private void processEndpointUserActionMessage(EndpointUserActionMessage message,
                                                boolean escalate) {
    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(message.getKey());
    if (endpointMetaData != null) {
      LOG.debug("[{}] Found affected endpoint and forwarding message to it", appToken);
      endpointMetaData.actorRef.tell(message, self());
    } else if (escalate) {
      LOG.debug("[{}] Failed to fing affected endpoint in scope of current application."
          + " Forwarding message to tenant actor", appToken);
      EndpointUserActionRouteMessage routeMessage =
          new EndpointUserActionRouteMessage(message, appToken);
      context().parent().tell(routeMessage, self());
    }
  }

  private void updateEndpointActor(EndpointStopMessage message) {
    String actorKey = message.getActorKey();
    EndpointObjectHash endpointKey = message.getEndpointKey();
    LOG.debug("[{}] Stoping actor [{}] with [{}]", appToken, message.getActorKey(), endpointKey);
    LocalEndpointActorMetaData endpointMetaData = localEndpointSessions.get(endpointKey);
    if (endpointMetaData != null) {
      if (actorKey.equals(endpointMetaData.actorId)) {
        localEndpointSessions.remove(endpointKey);
        LOG.debug("[{}] Removed actor [{}] from endpoint sessions map", appToken, actorKey);
      }
    } else {
      LOG.warn("[{}] EndpointSession for actor {} is not found!", appToken, endpointKey);
    }
    endpointActorMap.remove(actorKey);
    message.getOriginator().tell(message, self());
  }

  /**
   * Process termination.
   *
   * @param message the message
   */
  private void processTermination(Terminated message) {
    ActorRef terminated = message.actor();
    if (terminated instanceof LocalActorRef) {
      LocalActorRef localActor = (LocalActorRef) terminated;
      String name = localActor.path().name();
      EndpointObjectHash endpointHash = endpointActorMap.remove(name);
      if (endpointHash != null) {
        LocalEndpointActorMetaData actorMetaData = localEndpointSessions.get(endpointHash);
        if (actorMetaData != null && actorMetaData.actorRef.equals(localActor)) {
          localEndpointSessions.remove(endpointHash);
          LOG.debug("[{}] removed endpoint: {}", appToken, localActor);
          notifyGlobalEndpointActor(endpointHash,
              actorMetaData.globalActorNodeId, RouteOperation.DELETE);
        }
      } else if (topicSessions.remove(name) != null) {
        LOG.debug("[{}] removed topic: {}", appToken, localActor);
      } else if (logsSessions.remove(name) != null) {
        LOG.debug("[{}] removed log: {}", appToken, localActor);
        applicationLogActor = getOrCreateLogActor(name);
        LOG.debug("[{}] created log: {}", appToken, applicationLogActor);
      } else if (userVerifierSessions.remove(name) != null) {
        LOG.debug("[{}] removed log: {}", appToken, localActor);
        userVerifierActor = getOrCreateUserVerifierActor(name);
        LOG.debug("[{}] created log: {}", appToken, applicationLogActor);
      }
    } else {
      LOG.warn("remove commands for remote actors are not supported yet!");
    }
  }

  private ActorRef getOrCreateLogActor() {
    return getOrCreateLogActor(null);
  }

  private ActorRef getOrCreateLogActor(String name) {
    ActorRef logActor = logsSessions.get(name);
    if (logActor == null) {
      logActor = context().actorOf(
          Props.create(new ApplicationLogActor.ActorCreator(context, appToken))
              .withDispatcher(LOG_DISPATCHER_NAME)
      );
      context().watch(logActor);
      logsSessions.put(logActor.path().name(), logActor);
    }
    return logActor;
  }

  private ActorRef getOrCreateUserVerifierActor() {
    return getOrCreateUserVerifierActor(null);
  }

  private ActorRef getOrCreateUserVerifierActor(String name) {
    ActorRef userVerifierActor = userVerifierSessions.get(name);
    if (userVerifierActor == null) {
      userVerifierActor = context()
          .actorOf(
              Props.create(new ApplicationUserVerifierActor.ActorCreator(context, appToken))
                  .withDispatcher(VERIFIER_DISPATCHER_NAME)
          );
      context().watch(userVerifierActor);
      userVerifierSessions.put(userVerifierActor.path().name(), userVerifierActor);
    }
    return userVerifierActor;
  }

  /*
   * (non-Javadoc)
   *
   * @see akka.actor.UntypedActor#preStart()
   */
  @Override
  public void preStart() {
    LOG.info("[{}] Starting ", appToken);
  }

  /*
   * (non-Javadoc)
   *
   * @see akka.actor.UntypedActor#postStop()
   */
  @Override
  public void postStop() {
    LOG.info("[{}] Stoped ", appToken);
  }


  public static class ActorCreator implements Creator<ApplicationActor> {

    private static final long serialVersionUID = 1L;

    private final AkkaContext context;

    private final String tenantId;

    private final String appToken;

    /**
     * Instantiates a new actor creator.
     *
     * @param context  the context
     * @param tenantId the tenant id
     * @param appToken the application token
     */
    public ActorCreator(AkkaContext context, String tenantId, String appToken) {
      super();
      this.context = context;
      this.tenantId = tenantId;
      this.appToken = appToken;
    }

    /*
     * (non-Javadoc)
     *
     * @see akka.japi.Creator#create()
     */
    @Override
    public ApplicationActor create() throws Exception {
      return new ApplicationActor(context, tenantId, appToken);
    }
  }
}
```


Overlapping Code:
```
lic class ApplicationActor extends UntypedActor {
private static final Logger LOG = LoggerFactory.getLogger(ApplicationActor.class);
private final AkkaContext context;
private final Map<EndpointObjectHash, GlobalEndpointActorMetaData> globalEndpointSessions;
/**
* The endpoint sessions.
*/
private final Map<EndpointObjectHash, LocalEndpointActorMetaData> localEndpointSessions;
private final Map<String, EndpointObjectHash> endpointActorMap;
/**
* The topic sessions.
*/
private final Map<String, ActorRef> topicSessions;
private final String nodeId;
private final String tenantId;
private final String appToken;
private final Map<String, ActorRef> logsSessions;
private final Map<String, ActorRef> userVerifierSessions;
private ActorRef applicationLogActor;
private ActorRef userVerifierActor;
/**
* Instantiates a new application actor.
*
* @param context the context
* @param applicationToken the application token
*/
private ApplicationActor(AkkaContext context, String tenantId, String applicationToken) {
this.context = context;
this.nodeId = context.getClusterService().getNodeId();
this.tenantId = tenantId;
this.appToken = applicationToken;
this.globalEndpointSessions = new HashMap<>();
this.localEndpointSessions = new HashMap<>();
this.endpointActorMap = new HashMap<>();
this.topicSessions = new HashMap<>();
this.logsSessions = new HashMap<>();
this.userVerifierSessions = new HashMap<>();
this.applicationLogActor = getOrCreateLogActor();
this.userVerifierActor = getOrCreateUserVerifierActor();
}
/**
* Builds the topic key.
*
* @param topicId the topic id
* @return the string
*/
public static String buildTopicKey(String topicId) {
// TODO: Improve;
return topicId;
}
@Override
public SupervisorStrategy supervisorStrategy() {
return SupervisionStrategyFactory.createApplicationActorStrategy(context);
}
/*
* (non-Javadoc)
*
* @see akka.actor.UntypedActor#onReceive(java.lang.Object)
*/
@Override
public void onReceive(Object message) throws Exception {
if (LOG.isTraceEnabled()) {
LOG.trace("[{}] Received: {}", appToken, message);
} else {
LOG.debug("[{}] Received: {}", appToken, message.getClass().getName());
}
if (message instanceof EndpointAwareMessage) {
processEndpointAwareMessage((EndpointAwareMessage) message);
}
if (
```
<Overlap Ratio: 0.9938162544169611>

---

--- 131 --
Question ID: eb780de4f5cbed5d8575942547886f0ad07cb51d
Original Code:
```
@Aspect
@Component
@Order(0)
public class SplittingValuesAspect {

    private final Logger logger = LoggerFactory.getLogger(SplittingValuesAspect.class);

    @Autowired
    private SelfAssessmentService selfAssessmentService;

    @Autowired
    private EconomicResultsService economicResultsService;

    @Autowired
    private SplittingValueService splittingValueService;

    /**
     * Pointcut for methods annotated with UpdateSplittingValuesHook.
     */
    @Pointcut("@annotation(eu.hermeneut.aop.annotation.UpdateSplittingValuesHook)")
    public void updateSplittingValuesHook() {
    }

    /**
     * Cross-cutting method to update the SplittingValues of a SelfAssessment.
     *
     * @param joinPoint
     */
    @AfterReturning("updateSplittingValuesHook()")
    public void updateSplittingValues(JoinPoint joinPoint) {
        logger.debug("Updating SplittingValues AOP...");

        SelfAssessment selfAssessment = null;

        Object[] args = joinPoint.getArgs();

        if (args != null && args.length > 0) {
            //The first parameter must be the ID of the SelfAssessment
            if (args[0] instanceof Long) {
                selfAssessment = this.selfAssessmentService.findOne((Long) args[0]);
            }
        }

        if (selfAssessment != null) {
            // GET the existing SplittingValues for this SelfAssessment and update them.
            List<SplittingValue> splittingValues = this.splittingValueService.findAllBySelfAssessmentID(selfAssessment.getId());

            if (splittingValues != null && !splittingValues.isEmpty()) {
                EconomicResults economicResults = this.economicResultsService.findOneBySelfAssessmentID(selfAssessment.getId());

                if (economicResults != null) {
                    BigDecimal intangibleCapital = economicResults.getIntangibleCapital();

                    if (intangibleCapital != null) {
                        for (SplittingValue splittingValue : splittingValues) {
                            final CategoryType categoryType = splittingValue.getCategoryType();
                            final SectorType sectorType = splittingValue.getSectorType();

                            if (categoryType != CategoryType.DATA) {
                                BigDecimal splitting = Calculator.calculateSplittingValue(intangibleCapital, categoryType, sectorType);

                                if (splitting != null) {
                                    splittingValue.setValue(splitting);
                                    splittingValue = this.splittingValueService.save(splittingValue);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
```


Overlapping Code:
```
)
public class SplittingValuesAspect {
private final Logger logger = LoggerFactory.getLogger(SplittingValuesAspect.class);
@Autowired
private SelfAssessmentService selfAssessmentService;
@Autowired
private EconomicResultsService economicResultsService;
@Autowired
private SplittingValueService splittingValueService;
/**
* Pointcut for methods annotated with UpdateSplittingValuesHook.
*/
@Pointcut("@annotation(eu.hermeneut.aop.annotation.UpdateSplittingValuesHook)")
public void updateSplittingValuesHook() {
}
/**
* Cross-cutting method to update the SplittingValues of a SelfAssessment.
*
* @param joinPoint
*/
@AfterReturning("updateSplittingValuesHook()")
public void updateSplittingValues(JoinPoint joinPoint) {
logger.debug("Updating SplittingValues AOP...");
SelfAssessment selfAssessment = null;
Object[] args = joinPoint.getArgs();
if (args != null && args.length > 0) {
//The first parameter must be the ID of the SelfAssessment
if (args[0] instanceof Long) {
selfAssessment = this.selfAssessmentService.findOne((Long) args[0]);
}
}
if (selfAssessment != null) {
// GET the existing SplittingValues for this SelfAssessment and update them.
List<SplittingValue> splittingValues = this.splittingValueService.findAllBySelfAssessmentID(selfAssessment.getId());
if (splittingValues != null && !splittingValues.isEmpty()) {
EconomicResults economicResults = this.economicResultsService.findOneBySelfAssessmentID(selfAssessment.getId());
if (economicResults != null) {
BigDecimal intangibleCapital = economicResults.getIntangibleCapital();
if (intangibleCapital != null) {
for (SplittingValue splittingValue : splittingValues) {
final CategoryType categoryType = splittingValue.getCategoryType();
final SectorType sectorType = splittingValue.getSectorType();
if (categoryType != CategoryType.DATA) {
BigDecimal splitting = Calculator.calculateSplittingValue(intangibleCapital, categoryType, sectorType);
if (splitting != null) {
splittingValue.s
```
<Overlap Ratio: 0.9838546922300706>

---

--- 132 --
Question ID: ce97e1323f28c32feafdaa565129dd4c401eb343
Original Code:
```
@Table(name = "oauth_client_details")
public class OAuthClientDetails {
    @Id
    @Column(name = "client_id")
    private String clientId;

    @Column(name = "resource_ids")
    private String resourceIds;

    @Column(name = "client_secret")
    private String clientSecret;

    private String scope;

    @Column(name = "authorized_grant_types")
    private String authorizedGrantTypes;

    @Column(name = "web_server_redirect_uri")
    private String webServerRedirectUri;

    private String authorities;

    @Column(name = "access_token_validity")
    private Integer accessTokenValidity;

    @Column(name = "refresh_token_validity")
    private Integer refreshTokenValidity;

    @Column(name = "additional_information")
    private String additionalInformation;

    private String autoapprove;

    @Column(name = "created_at")
    private Date createdAt;

    @Column(name = "updated_at")
    private Date updatedAt;

    @Column(name = "deleted_at")
    private Date deletedAt;

    /**
     * @return client_id
     */
    public String getClientId() {
        return clientId;
    }

    /**
     * @param clientId
     */
    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    /**
     * @return resource_ids
     */
    public String getResourceIds() {
        return resourceIds;
    }

    /**
     * @param resourceIds
     */
    public void setResourceIds(String resourceIds) {
        this.resourceIds = resourceIds;
    }

    /**
     * @return client_secret
     */
    public String getClientSecret() {
        return clientSecret;
    }

    /**
     * @param clientSecret
     */
    public void setClientSecret(String clientSecret) {
        this.clientSecret = clientSecret;
    }

    /**
     * @return scope
     */
    public String getScope() {
        return scope;
    }

    /**
     * @param scope
     */
    public void setScope(String scope) {
        this.scope = scope;
    }

    /**
     * @return authorized_grant_types
     */
    public String getAuthorizedGrantTypes() {
        return authorizedGrantTypes;
    }

    /**
     * @param authorizedGrantTypes
     */
    public void setAuthorizedGrantTypes(String authorizedGrantTypes) {
        this.authorizedGrantTypes = authorizedGrantTypes;
    }

    /**
     * @return web_server_redirect_uri
     */
    public String getWebServerRedirectUri() {
        return webServerRedirectUri;
    }

    /**
     * @param webServerRedirectUri
     */
    public void setWebServerRedirectUri(String webServerRedirectUri) {
        this.webServerRedirectUri = webServerRedirectUri;
    }

    /**
     * @return authorities
     */
    public String getAuthorities() {
        return authorities;
    }

    /**
     * @param authorities
     */
    public void setAuthorities(String authorities) {
        this.authorities = authorities;
    }

    /**
     * @return access_token_validity
     */
    public Integer getAccessTokenValidity() {
        return accessTokenValidity;
    }

    /**
     * @param accessTokenValidity
     */
    public void setAccessTokenValidity(Integer accessTokenValidity) {
        this.accessTokenValidity = accessTokenValidity;
    }

    /**
     * @return refresh_token_validity
     */
    public Integer getRefreshTokenValidity() {
        return refreshTokenValidity;
    }

    /**
     * @param refreshTokenValidity
     */
    public void setRefreshTokenValidity(Integer refreshTokenValidity) {
        this.refreshTokenValidity = refreshTokenValidity;
    }

    /**
     * @return additional_information
     */
    public String getAdditionalInformation() {
        return additionalInformation;
    }

    /**
     * @param additionalInformation
     */
    public void setAdditionalInformation(String additionalInformation) {
        this.additionalInformation = additionalInformation;
    }

    /**
     * @return autoapprove
     */
    public String getAutoapprove() {
        return autoapprove;
    }

    /**
     * @param autoapprove
     */
    public void setAutoapprove(String autoapprove) {
        this.autoapprove = autoapprove;
    }

    /**
     * @return created_at
     */
    public Date getCreatedAt() {
        return createdAt;
    }

    /**
     * @param createdAt
     */
    public void setCreatedAt(Date createdAt) {
        this.createdAt = createdAt;
    }

    /**
     * @return updated_at
     */
    public Date getUpdatedAt() {
        return updatedAt;
    }

    /**
     * @param updatedAt
     */
    public void setUpdatedAt(Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    /**
     * @return deleted_at
     */
    public Date getDeletedAt() {
        return deletedAt;
    }

    /**
     * @param deletedAt
     */
    public void setDeletedAt(Date deletedAt) {
        this.deletedAt = deletedAt;
    }

    public static ClientDetails ClientDetailsBuilder(OAuthClientDetails oAuthClientDetails){

        BaseClientDetails newClientDetails = new BaseClientDetails(oAuthClientDetails.getClientId(),
                oAuthClientDetails.getResourceIds(),
                oAuthClientDetails.getScope(),
                oAuthClientDetails.getAuthorizedGrantTypes(),
                oAuthClientDetails.getAuthorities(),
                oAuthClientDetails.getWebServerRedirectUri()
                );
        newClientDetails.setClientSecret(oAuthClientDetails.getClientSecret());
//        newClientDetails.setAdditionalInformation();
        return newClientDetails;
    }
}
```


Overlapping Code:
```
@Table(name = "oauth_client_details")
public class OAuthClientDetails {
@Id
@Column(name = "client_id")
private String clientId;
@Column(name = "resource_ids")
private String resourceIds;
@Column(name = "client_secret")
private String clientSecret;
private String scope;
@Column(name = "authorized_grant_types")
private String authorizedGrantTypes;
@Column(name = "web_server_redirect_uri")
private String webServerRedirectUri;
private String authorities;
@Column(name = "access_token_validity")
private Integer accessTokenValidity;
@Column(name = "refresh_token_validity")
private Integer refreshTokenValidity;
@Column(name = "additional_information")
private String additionalInformation;
private String autoapprove;
@Column(name = "created_at")
private Date createdAt;
@Column(name = "updated_at")
private Date updatedAt;
@Column(name = "deleted_at")
private Date deletedAt;
/**
* @return client_id
*/
public String getClientId() {
return clientId;
}
/**
* @param clientId
*/
public void setClientId(String clientId) {
this.clientId = clientId;
}
/**
* @return resource_ids
*/
public String getResourceIds() {
return resourceIds;
}
/**
* @param resourceIds
*/
public void setResourceIds(String resourceIds) {
this.resourceIds = resourceIds;
}
/**
* @return client_secret
*/
public String getClientSecret() {
return clientSecret;
}
/**
* @param clientSecret
*/
public void setClientSecret(String clientSecret) {
this.clientSecret = clientSecret;
}
/**
* @return scope
*/
public String getScope() {
return scope;
}
/**
* @param scope
*/
public void setScope(String scope) {
this.scope = scope;
}
/**
* @return authorized_grant_types
*/
public String getAuthorizedGrantTypes() {
return authorizedGrantTypes;
}
/**
* @param authorizedGrantTypes
*/
public void setAuthorizedGrantTypes(String authorizedGrantTypes) {
this.authorizedGrantTypes = authorizedGrantTypes;
}
/**
* @return web_server_redirect_uri
*/
public String getWebServerRedirectUri() {
return webServerRedirectUri;
}
/**
* @param webServerRedirect
```
<Overlap Ratio: 0.9940652818991098>

---

--- 133 --
Question ID: 481d03a1becba31b033ad6c2e30ee6a23f965efc
Original Code:
```
public class LM35_Example {

	public static void main(String[] args) throws InterruptedException {
		// ! [Interesting]

		// Instantiate a LM35 on analog pin A0, with a default analog
		// reference voltage of 5.0
		upm_lm35.LM35 sensor = new upm_lm35.LM35(0);

		// Every half second, sample the sensor and output the temperature

		while (true) {
			System.out.println("Temperature: " + sensor.getTemperature() + " C");
			Thread.sleep(500);
		}

		// ! [Interesting]
	}
}
```


Overlapping Code:
```
_Example {
public static void main(String[] args) throws InterruptedException {
// ! [Interesting]
// Instantiate a LM35 on analog pin A0, with a default analog
// reference voltage of 5.0
upm_lm35.LM35 sensor = new upm_lm35.LM35(0);
// Every half second, sample the sensor and output the temperature
while (true) {
System.out.println("Temperature: " + sensor.getTemperature() + " C");
Thread.sleep(500);
}
/
```
<Overlap Ratio: 0.9147982062780269>

---

--- 134 --
Question ID: c2c16b5cc558ddafb2073ddf4944d0283cbe23d5
Original Code:
```
class Average
{
	public static void main ( String args[]) throws IOException
	{
		InputStreamReader ab= new InputStreamReader(System.in);
		BufferedReader cd= new BufferedReader(ab);
		System.out.println ("Enter 3 numbers:");
		int a,b,c;
		double d;
		a = Integer.parseInt(cd.readLine());
		b = Integer.parseInt(cd.readLine());
	       	c = Integer.parseInt(cd.readLine());
		d = (a+b+c)/3;
		System.out.println ("Average ="+d);
	}
}
```


Overlapping Code:
```

public static void main ( String args[]) throws IOException
{
InputStreamReader ab= new InputStreamReader(System.in);
BufferedReader cd= new BufferedReader(ab);
System.out.println ("Enter 3 numbers:");
int a,b,c;
double d;
a = Integer.parseInt(cd.readLine());
b = Integer.parseInt(cd.readLine());
c = Integer.parseInt(cd.readLine());
d = (a+b+c)/3;

```
<Overlap Ratio: 0.8663366336633663>

---

--- 135 --
Question ID: de5fec4d9cc696e0be03e836fcbbb68328e884fc
Original Code:
```
public class ChangelogStateBackendHandleTest {

    @Test
    public void testPublicConstructor() {
        long checkpointId = 2L;
        long materializationID = 1L;
        long size = 2L;
        validateHandle(
                checkpointId,
                materializationID,
                size,
                new ChangelogStateBackendHandleImpl(
                        emptyList(),
                        emptyList(),
                        KeyGroupRange.of(1, 2),
                        checkpointId,
                        materializationID,
                        size));
    }

    @Test
    public void testRestore() {
        long checkpointId = 2L;
        long materializationID = 1L;
        long size = 2L;
        validateHandle(
                checkpointId,
                materializationID,
                size,
                ChangelogStateBackendHandleImpl.restore(
                        emptyList(),
                        emptyList(),
                        KeyGroupRange.of(1, 2),
                        checkpointId,
                        materializationID,
                        size,
                        randomStateHandleId()));
    }

    private void validateHandle(
            long checkpointId,
            long materializationID,
            long size,
            ChangelogStateBackendHandleImpl handle) {
        assertEquals(checkpointId, handle.getCheckpointId());
        assertEquals(materializationID, handle.getMaterializationID());
        assertEquals(size, handle.getCheckpointedSize());
    }
}
```


Overlapping Code:
```
blic class ChangelogStateBackendHandleTest {
@Test
public void testPublicConstructor() {
long checkpointId = 2L;
long materializationID = 1L;
long size = 2L;
validateHandle(
checkpointId,
materializationID,
size,
new ChangelogStateBackendHandleImpl(
emptyList(),
emptyList(),
KeyGroupRange.of(1, 2),
checkpointId,
materializationID,
size));
}
@Test
public void testRestore() {
long checkpointId = 2L;
long materializationID = 1L;
long size = 2L;
validateHandle(
checkpointId,
materializationID,
size,
ChangelogStateBackendHandleImpl.restore(
emptyList(),
emptyList(),
KeyGroupRange.of(1, 2),
checkpointId,
materializationID,
size,
randomStateHandleId()));
}
private void validateHandle(
long checkpointId,
long materializationID,
long size,
ChangelogStateBackendHandleImpl handle) {
assertEquals(checkpointId, handle.getCheckpointId());
assertEquals(materializationID, handle.getMaterializationID());
assertEquals(size, handle.getCheckpointedSize());
```
<Overlap Ratio: 0.9937238493723849>

---

--- 136 --
Question ID: 015ae58a1c6e892578967f6ca10a7ca6ac07bfaa
Original Code:
```
public class Disabled {
    
    public static void init() {
        Command a = new RumbleOff();
        a.start();
        Scheduler.getInstance().removeAll();
        a.close();
        Robot.vision.teleopInit();
    }

    //Periodic method called roughly once every 20ms
    public static void periodic() {
        Scheduler.getInstance().run();
    }
}
```


Overlapping Code:
```
 {

public static void init() {
Command a = new RumbleOff();
a.start();
Scheduler.getInstance().removeAll();
a.close();
Robot.vision.teleopInit();
}
//Periodic method called roughly once every 20ms
public static void periodic() {
Scheduler.getInstanc
```
<Overlap Ratio: 0.8771929824561403>

---

--- 137 --
Question ID: 9dc33dec127558f27ce92ed64fc076de066ff090
Original Code:
```
public class MediasDisplayHelper {

    private static final Comparator<MediaModel> mediaModelComparator = 
    		(MediaModel m1, MediaModel m2) -> 
            NaturalOrderComparator.NUMERICAL_ORDER.compare(m1.getTitle(), m2.getTitle());
	
	public static void addMedias(List<MediaModel> mediaModels, TilePane tilePane, int start, int end){
		/* sort model list */
		Collections.sort(mediaModels, mediaModelComparator);
		
		/* fill the panes */
		int numberMedia = 0;
		for (int i = start; i < end; i++) {
			numberMedia++;			
			if (numberMedia <= Sizes.MEDIA_NUMBER_STAGE) {
				tilePane.getChildren().add(new MediaModelView(mediaModels.get(i)).getBox());
			}			
		}		
	}
	
	public static Stage createStage(Stage backStage, MediasDisplayController controller,
			                        BorderPane mainPane, String menu, int indiceStage){
        
		/* create the Scene */
		Scene scene = new Scene(mainPane);
        String css = MediasDisplayHelper.class.getResource(PathsProject.CSS_MEDIAS_PATH).toExternalForm(); 
        scene.getStylesheets().add(css);
		
		/* create the Stage */
		Stage nextStage = new Stage();
        StageSettings.setFitScreen(nextStage, false);
        nextStage.setScene(scene);

		/* set the controller */
		controller.setTitle(menu);
        controller.setMediasModels(MediasDisplayHelper.listModel(159),indiceStage);
        controller.setBackStage(backStage);
        controller.setCurrentStage(nextStage);
        
        return nextStage;
		
	}
	
	public static List<MediaModel> listModel(int size){
		List<MediaModel> models = new ArrayList<>();
		for (int i = 0; i< size; i++) {
			MediaModel mediaModel = new MediaModel();
			mediaModel.setTitle("Image test "+(i+1));
			mediaModel.setIconPaths(Arrays.asList("/home/vivien/Images/coloriage-tigre-1.gif"));
			models.add(mediaModel);
		}
		return models;
	}

}
```


Overlapping Code:
```
asDisplayHelper {
private static final Comparator<MediaModel> mediaModelComparator = 
(MediaModel m1, MediaModel m2) -> 
NaturalOrderComparator.NUMERICAL_ORDER.compare(m1.getTitle(), m2.getTitle());

public static void addMedias(List<MediaModel> mediaModels, TilePane tilePane, int start, int end){
/* sort model list */
Collections.sort(mediaModels, mediaModelComparator);

/* fill the panes */
int numberMedia = 0;
for (int i = start; i < end; i++) {
numberMedia++; 
if (numberMedia <= Sizes.MEDIA_NUMBER_STAGE) {
tilePane.getChildren().add(new MediaModelView(mediaModels.get(i)).getBox());
} 
} 
}

public static Stage createStage(Stage backStage, MediasDisplayController controller,
BorderPane mainPane, String menu, int indiceStage){

/* create the Scene */
Scene scene = new Scene(mainPane);
String css = MediasDisplayHelper.class.getResource(PathsProject.CSS_MEDIAS_PATH).toExternalForm(); 
scene.getStylesheets().add(css);

/* create the Stage */
Stage nextStage = new Stage();
StageSettings.setFitScreen(nextStage, false);
nextStage.setScene(scene);
/* set the controller */
controller.setTitle(menu);
controller.setMediasModels(MediasDisplayHelper.listModel(159),indiceStage);
controller.setBackStage(backStage);
controller.setCurrentStage(nextStage);

return nextStage;

}

public static List<MediaModel> listModel(int size){
List<MediaModel> models = new ArrayList<>();
for (int i = 0; i< size; i++) {
MediaModel mediaModel = new MediaModel();
mediaModel.setTitle("Image test "+(i+1));
mediaModel.setIconPaths(Arrays.asList("/home/vivien/Images/coloriage-tigre-1.gif"));
models.add(mediaModel);
}
return mo
```
<Overlap Ratio: 0.9841849148418491>

---

--- 138 --
Question ID: 74d49e70dbafd5c3cdc1c56de75fdee66d1d2f27
Original Code:
```
@SuppressWarnings({"unused", "WeakerAccess"})
public class PreservationActionsApiImpl extends AbstractApiCallImpl<PreservationActions, PreservationAction> implements PreservationActionsApi {

    /**
     * Default Constructor
     *
     * @param apiClient Configured client
     */
    public PreservationActionsApiImpl(ApiClient apiClient) {
        super(apiClient, "/preservation-actions", PreservationActions.class, PreservationAction.class);
    }

    /**
     * Constructor allowing for authenticated GETs
     *
     * @param apiClient Configured client
     * @param authNames Authentication/Authorization schema to use
     */
    public PreservationActionsApiImpl(ApiClient apiClient, String[] authNames) {
        this(apiClient);
        this.localVarAuthNames = authNames;
    }

    @Override
    public PreservationActions getAllPreservationActions() throws ApiException {
        return getListingApiResponse(null, null, null, null, Collections.emptyMap()).getData();
    }

    @Override
    public PreservationActions getPagedListOfPreservationActions(Integer offset, Integer limit) throws ApiException {
        return getListingApiResponse(null, null, offset, limit, Collections.emptyMap()).getData();
    }

    @Override
    public PreservationActions getPagedListOfPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, Collections.emptyMap()).getData();
    }

    @Override
    public PreservationActions getPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore) throws ApiException {
        return getListingApiResponse(modifiedAfter, modifiedBefore, null, null, Collections.emptyMap()).getData();
    }

    @Override
    public PreservationActions getPreservationActionsByTools(List<String> toolIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getToolsFilterHeader(toolIds)).getData();
    }

    @Override
    public PreservationActions getPreservationActionsByTypes(List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getTypesFilterHeader(preservationActionTypeIds)).getData();
    }

    @Override
    public PreservationActions getPreservationActionsByToolsAndTypes(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
        Map<String, String> headers = getToolsFilterHeader(toolIds);
        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));
        return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, headers).getData();
    }

    @Override
    public void getPreservationActionsAsync(List<String> toolIds, List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, ApiCallback<PreservationActions> callback) throws ApiException {
        Map<String, String> headers = getToolsFilterHeader(toolIds);
        headers.putAll(getTypesFilterHeader(preservationActionTypeIds));
        getListingAsync(null, modifiedAfter, modifiedBefore, headers, callback);
    }

    @Override
    public PreservationAction getPreservationActionById(String id) throws ApiException {
        return getEntity(id, null).getData();
    }

    @Override
    public void getPreservationActionByIdAsync(String id, ApiCallback<PreservationAction> callback) throws ApiException {
        getEntityAsync(id, null, callback);
    }

    @Override
    public PreservationAction updatePreservationAction(String id, PreservationAction data) throws ApiException {
        return updateEntity(id, data).getData();
    }

    @Override
    public void updatePreservationActionAsync(String id, PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {
        updateEntityAsync(id, data, callback);
    }

    @Override
    public PreservationAction createPreservationAction(PreservationAction data) throws ApiException {
        return createNewEntity(data).getData();
    }

    @Override
    public void createPreservationActionAsync(PreservationAction data, ApiCallback<PreservationAction> callback) throws ApiException {
        createNewEntityAsync(data, callback);
    }

    // --- Private internal methods

    private ApiResponse<PreservationActions> getListingApiResponse(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit, Map<String, String> headers) throws ApiException {
        return getListing(null, modifiedAfter, modifiedBefore, offset, limit, headers);
    }

    private Map<String, String> getToolsFilterHeader(List<String> toolIds) {
        return getFilterHeader("tool", toolIds);
    }

    private Map<String, String> getTypesFilterHeader(List<String> preservationActionTypeIds) {
        return getFilterHeader("preservation_action_type", preservationActionTypeIds);
    }

}
```


Overlapping Code:
```
@SuppressWarnings({"unused", "WeakerAccess"})
public class PreservationActionsApiImpl extends AbstractApiCallImpl<PreservationActions, PreservationAction> implements PreservationActionsApi {
/**
* Default Constructor
*
* @param apiClient Configured client
*/
public PreservationActionsApiImpl(ApiClient apiClient) {
super(apiClient, "/preservation-actions", PreservationActions.class, PreservationAction.class);
}
/**
* Constructor allowing for authenticated GETs
*
* @param apiClient Configured client
* @param authNames Authentication/Authorization schema to use
*/
public PreservationActionsApiImpl(ApiClient apiClient, String[] authNames) {
this(apiClient);
this.localVarAuthNames = authNames;
}
@Override
public PreservationActions getAllPreservationActions() throws ApiException {
return getListingApiResponse(null, null, null, null, Collections.emptyMap()).getData();
}
@Override
public PreservationActions getPagedListOfPreservationActions(Integer offset, Integer limit) throws ApiException {
return getListingApiResponse(null, null, offset, limit, Collections.emptyMap()).getData();
}
@Override
public PreservationActions getPagedListOfPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, Collections.emptyMap()).getData();
}
@Override
public PreservationActions getPreservationActionsByModifiedDate(String modifiedAfter, String modifiedBefore) throws ApiException {
return getListingApiResponse(modifiedAfter, modifiedBefore, null, null, Collections.emptyMap()).getData();
}
@Override
public PreservationActions getPreservationActionsByTools(List<String> toolIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getToolsFilterHeader(toolIds)).getData();
}
@Override
public PreservationActions getPreservationActionsByTypes(List<String> preservationActionTypeIds, String modifiedAfter, String modifiedBefore, Integer offset, Integer limit) throws ApiException {
return getListingApiResponse(modifiedAfter, modifiedBefore, offset, limit, getTypes
```
<Overlap Ratio: 0.9785276073619632>

---

--- 139 --
Question ID: 1de105c2e58ab13258f4f9e3b1de5ea89fa6c1f0
Original Code:
```
public class CaptureVideo extends javax.microedition.lcdui.Canvas implements CommandListener, WorkflowElement, ActionListener, Showable {
	private Capture capture;
	private VideoControl vidc;
	private Command cmStart;
	private Command cmStop;
	private Command cmCancel;
	private Handler handler;

	public static final int OK = 1;
	public static final int CANCEL = 2;
	
	public CaptureVideo() {
		capture = new Capture(this);
	    cmStart = new Command("Start", Command.OK, 1);
	    cmStop = new Command("Stop", Command.OK, 2);
	    cmCancel = new Command("Cancel", Command.CANCEL, 3);
	    addCommand(cmStart);
	    addCommand(cmCancel);
	    setCommandListener(this);	    
	}

	public void setHandler(Handler handler) {
		this.handler = handler;
	}
	
	protected void showNotify() {
		try {
			if (capture.state == Capture.INIT) {
				initPlayer();
				if (!Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {
					initRecording();
				}
				startPlayer();
				capture.state = Capture.STARTING;
			}
		} catch (PavoException e) {
			handle(e);
		}
	}
	
	public void commandAction(Command c, Displayable d) {
		if (c == cmStart) {
			removeCommand(cmStart);
			addCommand(cmStop);
			actionPerformed(new ActionEvent(cmStart));
		} else if (c == cmStop) {
			actionPerformed(new ActionEvent(cmStop));
		} else if (c == cmCancel) {
			capture.abortRecording();
			capture.state = Capture.FINISHED;
			handle(new Params().set("result", Handler.CANCEL));
		}
	}
	
	public synchronized void actionPerformed(ActionEvent ev) {
		try {
			switch (capture.state) {
			case Capture.STARTING:
				if(Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {
					teardownPlayer();
					initPlayer();
					initRecording();
					startRecording();
					startPlayer();
				} else {
					startRecording();
				}
		        capture.state = Capture.CAPTURING;
				break;
			case Capture.CAPTURING:
				finishRecording();
				break;
			case Capture.COMMITED:
				finishRecording();
				break;
			}
		} catch (PavoException e) {
			if(capture.state == Capture.CAPTURING || capture.state == Capture.COMMITED) {
				try { capture.abortRecording();	} catch (Exception ee) { }
			}
			handle(e);
		}
	}

	void initPlayer() throws PavoException {
		capture.initPlayer(Settings.getString(Settings.DEVICE_VIDEO));
		vidc = (VideoControl) ((Player) capture.player).getControl("VideoControl");
		vidc.initDisplayMode(VideoControl.USE_DIRECT_VIDEO, this);
		try {vidc.setDisplayFullScreen(Settings.getBool(Settings.VIDEO_CAPTURE_FULLSCREEN));} catch (Exception e) { throw new PavoException("setFullscreen", e); }
		vidc.setVisible(true);
	}
	
	void initRecording() throws PavoException {
		capture.initRecordControl(Settings.getString(Settings.VIDEO_CAPTURE_DIR) + "pavotmp.3gp");
		capture.setRecordSizeLimit(Settings.getInt(Settings.VIDEO_CAPTURE_SIZE_LIMIT));
	}
	
	void startPlayer() throws PavoException {
		try { capture.player.start(); } catch (Exception e) { throw new PavoException("playerStart", e); }
	}
	
	void startRecording() throws PavoException {
        capture.recordControl.startRecord();
	}
		
	void teardownPlayer() {
		vidc.setVisible(false);
		capture.stopPlayer();
		vidc = null;
	}
	
	void finishRecording() throws PavoException {
		if(capture.state == Capture.CAPTURING) {
			capture.commitRecording();	
		}
		teardownPlayer();
		capture.state = Capture.FINISHED;
		// doing this or will get Prefetch error -14 on nokia n95
		javax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(new DummyCanvas());
		handle(new Params().set("result", Handler.OK).set("content-type", capture.getContentType()).set("file", capture.getResult()));
	}
	
	private void handle(Params result) {
		if(handler != null) {
			handler.handle(result);
		}
	}
	
	private void handle(PavoException e) {
		Connection.sendException(this, e);
		handle(new Params().set("result", Handler.ERROR).set("exception", e));
	}

	protected void paint(Graphics arg0) {
	}
	
	public void show() {
		javax.microedition.lcdui.Display.getDisplay(Main.INSTANCE).setCurrent(this);
	}
	
}
```


Overlapping Code:
```
nds javax.microedition.lcdui.Canvas implements CommandListener, WorkflowElement, ActionListener, Showable {
private Capture capture;
private VideoControl vidc;
private Command cmStart;
private Command cmStop;
private Command cmCancel;
private Handler handler;
public static final int OK = 1;
public static final int CANCEL = 2;

public CaptureVideo() {
capture = new Capture(this);
cmStart = new Command("Start", Command.OK, 1);
cmStop = new Command("Stop", Command.OK, 2);
cmCancel = new Command("Cancel", Command.CANCEL, 3);
addCommand(cmStart);
addCommand(cmCancel);
setCommandListener(this); 
}
public void setHandler(Handler handler) {
this.handler = handler;
}

protected void showNotify() {
try {
if (capture.state == Capture.INIT) {
initPlayer();
if (!Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {
initRecording();
}
startPlayer();
capture.state = Capture.STARTING;
}
} catch (PavoException e) {
handle(e);
}
}

public void commandAction(Command c, Displayable d) {
if (c == cmStart) {
removeCommand(cmStart);
addCommand(cmStop);
actionPerformed(new ActionEvent(cmStart));
} else if (c == cmStop) {
actionPerformed(new ActionEvent(cmStop));
} else if (c == cmCancel) {
capture.abortRecording();
capture.state = Capture.FINISHED;
handle(new Params().set("result", Handler.CANCEL));
}
}

public synchronized void actionPerformed(ActionEvent ev) {
try {
switch (capture.state) {
case Capture.STARTING:
if(Settings.getBool(Settings.VIDEO_CAPTURE_RECORD_BEFORE_PLAY)) {
teardownPlayer();
initPlayer();
initRecording();
startRecording();
startPlayer();
} else {
startRecording();
}
capture.state = Capture.CAPTURING;
break;
case Capture.CAPTURING:
finishRecording();
break;
case Capture.COMMITED:
finishRecording();
break;
}
} catch (PavoException e) {
if(capture.state == Capture.CAPTURING || capture.state == Capture.COMMITED) {
try { capture.abortRecording(); } catch (Exception ee) { }
}
handle(e);
}
}
void initPlayer() throws PavoException {
capture.initPlayer(Settings.getString(Settings.DEVICE_VIDEO));
vidc = (VideoControl) ((Player) capture.player).getControl("VideoContr
```
<Overlap Ratio: 0.9690816797415782>

---

--- 140 --
Question ID: 83b0701971c3d7b66b752f6c65dc65b3b294b67c
Original Code:
```
class GitStubDownloader implements StubDownloader {

	private static final Log log = LogFactory.getLog(GitStubDownloader.class);

	// Preloading class for the shutdown hook not to throw ClassNotFound
	private static final Class CLAZZ = TemporaryFileStorage.class;

	private final StubRunnerOptions stubRunnerOptions;

	private final boolean deleteStubsAfterTest;

	private final GitContractsRepo gitContractsRepo;

	GitStubDownloader(StubRunnerOptions stubRunnerOptions) {
		this.stubRunnerOptions = stubRunnerOptions;
		this.deleteStubsAfterTest = this.stubRunnerOptions.isDeleteStubsAfterTest();
		this.gitContractsRepo = new GitContractsRepo(stubRunnerOptions);
		registerShutdownHook();
	}

	@Override
	public Map.Entry<StubConfiguration, File> downloadAndUnpackStubJar(
			StubConfiguration stubConfiguration) {
		try {
			if (log.isDebugEnabled()) {
				log.debug("Trying to find a contract for ["
						+ stubConfiguration.toColonSeparatedDependencyNotation() + "]");
			}
			Resource repo = this.stubRunnerOptions.getStubRepositoryRoot();
			File clonedRepo = this.gitContractsRepo.clonedRepo(repo);
			FileWalker walker = new FileWalker(stubConfiguration);
			Files.walkFileTree(clonedRepo.toPath(), walker);
			if (walker.foundFile != null) {
				return new AbstractMap.SimpleEntry<>(stubConfiguration,
						walker.foundFile.toFile());
			}
		}
		catch (IOException e) {
			throw new IllegalStateException(e);
		}
		if (log.isWarnEnabled()) {
			log.warn("No matching contracts were found in the repo for ["
					+ stubConfiguration.toColonSeparatedDependencyNotation() + "]");
		}
		return null;
	}

	private void registerShutdownHook() {
		Runtime.getRuntime().addShutdownHook(new Thread(() -> TemporaryFileStorage
				.cleanup(GitStubDownloader.this.deleteStubsAfterTest)));
	}

}
```


Overlapping Code:
```
r implements StubDownloader {
private static final Log log = LogFactory.getLog(GitStubDownloader.class);
// Preloading class for the shutdown hook not to throw ClassNotFound
private static final Class CLAZZ = TemporaryFileStorage.class;
private final StubRunnerOptions stubRunnerOptions;
private final boolean deleteStubsAfterTest;
private final GitContractsRepo gitContractsRepo;
GitStubDownloader(StubRunnerOptions stubRunnerOptions) {
this.stubRunnerOptions = stubRunnerOptions;
this.deleteStubsAfterTest = this.stubRunnerOptions.isDeleteStubsAfterTest();
this.gitContractsRepo = new GitContractsRepo(stubRunnerOptions);
registerShutdownHook();
}
@Override
public Map.Entry<StubConfiguration, File> downloadAndUnpackStubJar(
StubConfiguration stubConfiguration) {
try {
if (log.isDebugEnabled()) {
log.debug("Trying to find a contract for ["
+ stubConfiguration.toColonSeparatedDependencyNotation() + "]");
}
Resource repo = this.stubRunnerOptions.getStubRepositoryRoot();
File clonedRepo = this.gitContractsRepo.clonedRepo(repo);
FileWalker walker = new FileWalker(stubConfiguration);
Files.walkFileTree(clonedRepo.toPath(), walker);
if (walker.foundFile != null) {
return new AbstractMap.SimpleEntry<>(stubConfiguration,
walker.foundFile.toFile());
}
}
catch (IOException e) {
throw new IllegalStateException(e);
}
if (log.isWarnEnabled()) {
log.warn("No matching contracts were found in the repo for ["
+ stubConfiguration.toColonSeparatedDependencyNotation() + "]");
}
return null;
}
private void registerShutdownHook() {
Runtime.getRuntime().addShutdownHook(new Thread(() -> TemporaryFileStorage
.cleanup(GitStubDownloader.this.deleteStubsAfterT
```
<Overlap Ratio: 0.9804270462633452>

---

--- 141 --
Question ID: 946acf05163866f1a33cc371456dcd79e5ae5f7f
Original Code:
```
class variable3
{
    public static void main()
    {
        int a,b,c,d,e;
        a=9;
        b=7;
        c=8;
        d=6;
        e=(a+(b+c)+(c+d)+(d+b));
        System.out.println(e);
    }
}
```


Overlapping Code:
```
oid main()
{
int a,b,c,d,e;
a=9;
b=7;
c=8;
d=6;
e=
```
<Overlap Ratio: 0.3787878787878788>

---

--- 142 --
Question ID: e36f079f4fe1cc3c6d5b09e14f2dff29c0a3fee1
Original Code:
```
public class AddRemoteStep extends AbstractStepImpl {
    private String serverUrl;
    private String serverName;
    private String conanHome;

    @DataBoundConstructor
    public AddRemoteStep(String serverUrl, String serverName, String conanHome) {
        this.serverUrl = serverUrl;
        this.serverName = serverName;
        this.conanHome = conanHome;
    }

    public String getServerUrl() {
        return this.serverUrl;
    }

    public String getServerName() {
        return this.serverName;
    }

    public String getConanHome() {
        return this.conanHome;
    }

    public static class Execution extends AbstractSynchronousStepExecution<Boolean> {
        private static final long serialVersionUID = 1L;

        @StepContextParameter
        private transient Run build;

        @StepContextParameter
        private transient TaskListener listener;

        @StepContextParameter
        private transient Launcher launcher;

        @Inject(optional = true)
        private transient AddRemoteStep step;

        @StepContextParameter
        private transient FilePath ws;

        @StepContextParameter
        private transient EnvVars env;

        @Override
        protected Boolean run() throws Exception {
            ArgumentListBuilder args = new ArgumentListBuilder();
            args.addTokenized("conan remote add");
            args.add(step.getServerName());
            args.add(step.getServerUrl());
            EnvVars extendedEnv = new EnvVars(env);
            extendedEnv.put(Utils.CONAN_USER_HOME, step.getConanHome());
            Utils.exeConan(args, ws, launcher, listener, build, extendedEnv);
            return true;
        }
    }

    @Extension
    public static final class DescriptorImpl extends AbstractStepDescriptorImpl {

        public DescriptorImpl() {
            super(AddRemoteStep.Execution.class);
        }

        @Override
        public String getFunctionName() {
            return "conanAddRemote";
        }

        @Override
        public String getDisplayName() {
            return "Add new repo to Conan config";
        }

        @Override
        public boolean isAdvanced() {
            return true;
        }
    }
}
```


Overlapping Code:
```
 extends AbstractStepImpl {
private String serverUrl;
private String serverName;
private String conanHome;
@DataBoundConstructor
public AddRemoteStep(String serverUrl, String serverName, String conanHome) {
this.serverUrl = serverUrl;
this.serverName = serverName;
this.conanHome = conanHome;
}
public String getServerUrl() {
return this.serverUrl;
}
public String getServerName() {
return this.serverName;
}
public String getConanHome() {
return this.conanHome;
}
public static class Execution extends AbstractSynchronousStepExecution<Boolean> {
private static final long serialVersionUID = 1L;
@StepContextParameter
private transient Run build;
@StepContextParameter
private transient TaskListener listener;
@StepContextParameter
private transient Launcher launcher;
@Inject(optional = true)
private transient AddRemoteStep step;
@StepContextParameter
private transient FilePath ws;
@StepContextParameter
private transient EnvVars env;
@Override
protected Boolean run() throws Exception {
ArgumentListBuilder args = new ArgumentListBuilder();
args.addTokenized("conan remote add");
args.add(step.getServerName());
args.add(step.getServerUrl());
EnvVars extendedEnv = new EnvVars(env);
extendedEnv.put(Utils.CONAN_USER_HOME, step.getConanHome());
Utils.exeConan(args, ws, launcher, listener, build, extendedEnv);
return true;
}
}
@Extension
public static final class DescriptorImpl extends AbstractStepDescriptorImpl {
public DescriptorImpl() {
super(AddRemoteStep.Execution.class);
}
@Override
public String getFunctionName() {
return "conanAddRemote";
}
@Override
public String getDisplayName() {
return "Add new repo to Conan config";
}
@Override
public boolean isAdvanced() {
return true;
}
}
}
```
<Overlap Ratio: 0.984927536231884>

---

--- 143 --
Question ID: c3f383db0374dffc761d81751199127be69277d8
Original Code:
```
public class AccumuloDeleteSchemaTask extends AbstractTask<String, CoalesceStringResponseType, DataStore> {

    @Override
    protected CoalesceStringResponseType doWork(TaskParameters<DataStore, String> parameters)
            throws CoalesceException
    {
        CoalesceStringResponseType result = new CoalesceStringResponseType();

        DataStore datastore = parameters.getTarget();
        String name = parameters.getParams();

        try
        {
            datastore.removeSchema(name);
            result.setStatus(EResultStatus.SUCCESS);
        }
        catch (IOException | IllegalArgumentException e)
        {
            throw new CoalescePersistorException(String.format("(FAILED) Removing Schema: (%s)", name), e);
        }

        return result;
    }

    @Override
    protected Map<String, String> getParameters(String params, boolean isTrace)
    {
        return new HashMap<>();
    }

    @Override
    protected CoalesceStringResponseType createResult()
    {
        return new CoalesceStringResponseType();
    }
}
```


Overlapping Code:
```
AccumuloDeleteSchemaTask extends AbstractTask<String, CoalesceStringResponseType, DataStore> {
@Override
protected CoalesceStringResponseType doWork(TaskParameters<DataStore, String> parameters)
throws CoalesceException
{
CoalesceStringResponseType result = new CoalesceStringResponseType();
DataStore datastore = parameters.getTarget();
String name = parameters.getParams();
try
{
datastore.removeSchema(name);
result.setStatus(EResultStatus.SUCCESS);
}
catch (IOException | IllegalArgumentException e)
{
throw new CoalescePersistorException(String.format("(FAILED) Removing Schema: (%s)", name), e);
}
return result;
}
@Override
protected Map<String, String> getParameters(String params, boolean isTrace)
{
return new HashMap<>();
}
@Override
protected CoalesceStringResponseType createResult()
{
return new CoalesceStringResponseType(
```
<Overlap Ratio: 0.977803738317757>

---

--- 144 --
Question ID: 5543a5df229ebca97c5533caee2ff41e064fcfca
Original Code:
```
@TeleOp(name = "TankDrive TeleOp Example", group = "ARC")
public class TankDriveTeleOpExample extends OpMode {

  private static final int TICKS_PER_INCH = 1000, TICKS_PER_360 = 1440 * 4;
  private TankDrive tankDrive;

  @Override
  public void init() {
    DcMotor motorL = hardwareMap.dcMotor.get("motorL");
    DcMotor motorR = hardwareMap.dcMotor.get("motorR");
    motorL.setDirection(Direction.REVERSE);

    tankDrive = TankDrive.fromMotors(
        motorL, motorR, this, TICKS_PER_INCH, TICKS_PER_360);
  }

  @Override
  public void loop() {
    // The Y axis for gamepad sticks is reversed, negate it in use
    tankDrive.setMovementAndRotation(-gamepad1.left_stick_y, gamepad1.left_stick_x);

    telemetry.addData("Left stick X", gamepad1.left_stick_x);
    telemetry.addData("Left stick Y", -gamepad1.left_stick_y);
    telemetry.update();
  }
}
```


Overlapping Code:
```
mple", group = "ARC")
public class TankDriveTeleOpExample extends OpMode {
private static final int TICKS_PER_INCH = 1000, TICKS_PER_360 = 1440 * 4;
private TankDrive tankDrive;
@Override
public void init() {
DcMotor motorL = hardwareMap.dcMotor.get("motorL");
DcMotor motorR = hardwareMap.dcMotor.get("motorR");
motorL.setDirection(Direction.REVERSE);
tankDrive = TankDrive.fromMotors(
motorL, motorR, this, TICKS_PER_INCH, TICKS_PER_360);
}
@Override
public void loop() {
// The Y axis for gamepad sticks is reversed, negate it in use
tankDrive.setMovementAndRotation(-gamepad1.left_stick_y, gamepad1.left_stick_x);
telemetry.addData("Left stick X", gamepad1.left_stick_x);
telemetry.addData("Left stick Y", -gamepad1.left_stick_y);
telemetry.updat
```
<Overlap Ratio: 0.9445843828715366>

---

--- 145 --
Question ID: 3b1ba4da378b6581930b861293808a8b08adb495
Original Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
@ContextConfiguration(classes = CrowDemon.class)
@TestPropertySource(locations = "classpath:testDockerExecution.properties")
public class SpringDockerExecutionIT implements IJobLogger {

	public static final String CONTAINER_NAME = "SpringDockerExecutionIT";

	private Logger LOG = LoggerFactory.getLogger(SpringDockerExecutionIT.class);

	public IDockerClientTest containerFactory;

	public List<String> containers = new LinkedList<>();

	public IDockerClient dockerClient;

	public ByteArrayOutputStream outStream;

	public ByteArrayOutputStream outErrorStream;

	public List<IJobLogger> logger;

	public CountDownLatch latch;

	@Autowired
	JobRepository repository;

	@Autowired
	JobDispatcher dispatcher;

	@Before
	public void setup() throws DockerCertificateException, DockerException, InterruptedException {
		dockerClient = DockerClientFactory.initializeDockerClient();
		containerFactory = DockerTestClientFactory.initializeDockerClient();
		logger = new ArrayList<>();
		logger.add(this);
		latch = new CountDownLatch(1);
	}

	@After
	public void tearDown() {
		containerFactory.deleteContainers();
	}

	@Test
	public void testRepository_ListJobs_TwoDockerJobsAdded() {
		List<CrowConfiguration> jobs = repository.listJobs();

		assertEquals(Integer.valueOf(1), Integer.valueOf(jobs.size()));
		jobs.stream().forEach(j -> assertNotNull(j.getContainerName().orElse(null)));
	}

	@Test
	public void testExecution_ExecuteManually_OutputCorrect() throws DockerException, InterruptedException {
		Optional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> "EchoDockerContainer".equals(j
				.getJobName().orElse(null))).findFirst();
		this.containerFactory.runContainer(CONTAINER_NAME);

		this.dispatcher.execute(JobId.of(job.get().getJobId().orElse(null)), null, logger);
		latch.await();

		String output = new String(this.outStream.toByteArray());
		assertEquals("Hello Docker World!\n", output);
	}

	@Test
	public void testExecution_ExecuteTestExecutionManually_OutputCorrect() throws DockerException,
			InterruptedException {
		Optional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> "EchoDockerContainer".equals(j
				.getJobName().orElse(null))).findFirst();
		this.containerFactory.runContainer(CONTAINER_NAME);

		this.dispatcher.testExecute(JobId.of(job.get().getJobId().orElse(null)), null, logger);
		latch.await();

		String output = new String(this.outStream.toByteArray());
		assertEquals("Hello Docker World!\n", output);
	}

	@Override
	public void initializeLogger() {
		this.outStream = new ByteArrayOutputStream();
		this.outErrorStream = new ByteArrayOutputStream();
	}

	@Override
	public void finishLogger() {
		try {
			outStream.close();
			outErrorStream.close();
		} catch (IOException e) {
			LOG.error("Error closing streams!", e);
			throw new RuntimeException(e);
		}
		latch.countDown();
	}

	@Override
	public OutputStream getInfoLogConsumer() {
		return this.outStream;
	}

	@Override
	public OutputStream getErrorLogConsumer() {
		return this.outErrorStream;
	}

}
```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest
@ContextConfiguration(classes = CrowDemon.class)
@TestPropertySource(locations = "classpath:testDockerExecution.properties")
public class SpringDockerExecutionIT implements IJobLogger {
public static final String CONTAINER_NAME = "SpringDockerExecutionIT";
private Logger LOG = LoggerFactory.getLogger(SpringDockerExecutionIT.class);
public IDockerClientTest containerFactory;
public List<String> containers = new LinkedList<>();
public IDockerClient dockerClient;
public ByteArrayOutputStream outStream;
public ByteArrayOutputStream outErrorStream;
public List<IJobLogger> logger;
public CountDownLatch latch;
@Autowired
JobRepository repository;
@Autowired
JobDispatcher dispatcher;
@Before
public void setup() throws DockerCertificateException, DockerException, InterruptedException {
dockerClient = DockerClientFactory.initializeDockerClient();
containerFactory = DockerTestClientFactory.initializeDockerClient();
logger = new ArrayList<>();
logger.add(this);
latch = new CountDownLatch(1);
}
@After
public void tearDown() {
containerFactory.deleteContainers();
}
@Test
public void testRepository_ListJobs_TwoDockerJobsAdded() {
List<CrowConfiguration> jobs = repository.listJobs();
assertEquals(Integer.valueOf(1), Integer.valueOf(jobs.size()));
jobs.stream().forEach(j -> assertNotNull(j.getContainerName().orElse(null)));
}
@Test
public void testExecution_ExecuteManually_OutputCorrect() throws DockerException, InterruptedException {
Optional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> "EchoDockerContainer".equals(j
.getJobName().orElse(null))).findFirst();
this.containerFactory.runContainer(CONTAINER_NAME);
this.dispatcher.execute(JobId.of(job.get().getJobId().orElse(null)), null, logger);
latch.await();
String output = new String(this.outStream.toByteArray());
assertEquals("Hello Docker World!\n", output);
}
@Test
public void testExecution_ExecuteTestExecutionManually_OutputCorrect() throws DockerException,
InterruptedException {
Optional<CrowConfiguration> job = repository.listJobs().stream().filter(j -> "EchoDockerContainer".equals(j
.getJobName().orElse(null))).findFirst();
this.containerFactory.runContainer(CONTAINER_NAME);
this.dispatcher.testExecute(JobId.of(job.get().getJobId().orElse(null)), null, logger);
latch.await();
String output = new String(this.outStream.toByteArr
```
<Overlap Ratio: 0.9904086738949124>

---

--- 146 --
Question ID: b6f51f784d8ee5a13e1baa43195deea8a7e573b9
Original Code:
```
public class Tree<T> extends AbstractTreeLikeStructure<T, Tree<T>> implements Serializable /* TODO:extends Iterable<T> */{

	private static final long serialVersionUID = -7482343083286183794L;

	private final Tree<T> parent;
	private final T value;
	private final List<Tree<T>> children;

	// -- constructors + factory methods

	public Tree(T value) {
		this(null, value, List.of(), TreeTransformer::identity, TreeTransformer::identity);
	}

	public Tree(T value, Iterable<Tree<T>> children) {
		this(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);
	}

	public Tree(Tree<T> parent, T value) {
		this(parent, value, List.of(), TreeTransformer::addThisToParent, TreeTransformer::identity);
	}

	public Tree(Tree<T> parent, T value, Iterable<Tree<T>> children) {
		this(parent, value, children, TreeTransformer::addThisToParent, TreeTransformer::updateChildren);
	}

	// DEV-NOTE: beware of NPEs because this is leaving the constructor
	Tree(Tree<T> parent, T value, Iterable<Tree<T>> children, TreeTransformer<T> updateParent,
			TreeTransformer<T> updateChildren) {
		requireNonNull(children, "children is null");
		requireNonNull(updateParent, "updateParent is null");
		requireNonNull(updateChildren, "updateChildren is null");
		this.value = value;
		this.children = List.of(children).replaceAll(updateChildren.apply(this));
		this.parent = Option.of(parent).map(updateParent.apply(this)).orElse(null);
	}

	/**
	 * Factory method for easy tree building.
	 * <p>
	 * <strong>Example:</strong>
	 * <p>
	 * {@code tree("A", tree("B"), tree("C", tree("D"), tree("E", tree("F", tree("G")))))}
	 * <p>
	 * results in:
	 * 
	 * <pre>
	 * <code>
	 *   A
	 *  / \
	 * B   C
	 *    / \
	 *   D   E
	 *       |
	 *       F
	 *       |
	 *       G
	 * </code>
	 * </pre>
	 * 
	 * @param <T> value type of the result Tree
	 * @param value The value of the Tree.
	 * @param children The children of the Tree.
	 * @return A new Tree instance based on the arguments.
	 */
	@SafeVarargs
	public static <T> Tree<T> tree(T value, Tree<T>... children) {
		final List<Tree<T>> childList = List.of(children);
		return new Tree<>(null, value, childList, TreeTransformer::identity, TreeTransformer::updateChildren);
	}

	// -- core

	public Option<Tree<T>> getParent() {
		return Option.of(parent);
	}

	public Tree<T> setParent(Tree<T> parent) {
		if (Objects.equals(this.parent, parent)) {
			return this;
		} else {
			return new Tree<>(parent, value, children, TreeTransformer::addThisToParent,
					TreeTransformer::updateChildren);
		}
	}

	public Tree<T> getRoot() {
		Tree<T> tree = this;
		while (tree.parent != null) {
			tree = tree.parent;
		}
		return tree;
	}

	public boolean isRoot() {
		return parent == null;
	}

	@Override
	public T getValue() {
		return value;
	}

	@Override
	public Tree<T> setValue(T value) {
		return new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);
	}

	@Override
	public List<Tree<T>> getChildren() {
		return children;
	}

	@Override
	public Tree<T> setChildren(Iterable<Tree<T>> children) {
		return new Tree<>(parent, value, children, TreeTransformer.updateParent(this), TreeTransformer::updateChildren);
	}

	// -- operations

	@Override
	public Tree<T> attach(Iterable<Tree<T>> trees) {
		return new Tree<>(parent, value, List.of(trees).prependAll(children), TreeTransformer.updateParent(this),
				TreeTransformer::updateChildren);
	}

	@Override
	public Tree<T> detach(Iterable<Tree<T>> trees) {
		return new Tree<>(parent, value, children.removeAll(trees), TreeTransformer.updateParent(this),
				TreeTransformer::updateChildren);
	}

	@Override
	public Tree<T> subtree() {
		return new Tree<>(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);
	}

	// -- conversion

	public Node<T> asNode() {
		return new Node<T>(value, children.stream().map(child -> child.asNode()).collect(List.collector()));
	}

	// -- transformation

	/**
	 * Manifest-type for and holder of Tree transformations.
	 * 
	 * @param <T>
	 */
	static interface TreeTransformer<T> extends Function<Tree<T>, UnaryOperator<Tree<T>>> {

		/**
		 * Use-case: tree tells its children to re-create all their children without re-creating their parents.
		 * <p>
		 * Example: (1 2 3).detach(3)<br>
		 * 
		 * <pre>
		 * <code>
		 *    1
		 *   / \
		 *  2   3
		 * 
		 * new1 = Tree(prev1.parent, prev1.value, updateChildren(prev1.children.remove(3)))
		 * updateChildren(prev2) = new2 = Tree(new1, prev2.value, ())
		 * 
		 *    1
		 *    |
		 *    2
		 * </code>
		 * </pre>
		 * 
		 * @param self
		 * @return
		 */
		static <T> UnaryOperator<Tree<T>> updateChildren(Tree<T> self) {
			return child -> new Tree<>(self, child.value, child.children, TreeTransformer::identity,
					TreeTransformer::updateChildren);
		}

		// Use-case 1: tree passes itself as parent to its children
		// Use-case 2: tree defers decending children, see Node.asTree()
		// TODO: return None instead of identity() to reduce O(n) to O(1)
		static <T> UnaryOperator<Tree<T>> identity(Tree<T> self) {
			return parent -> parent;
		}

		// Use-case: update the whole parent structure but substitute parent.oldChild with this new child
		static <T> TreeTransformer<T> updateParent(Tree<T> prevChild) {
			return self -> parent -> new Tree<>(parent.parent, parent.value, parent.children,
					TreeTransformer.updateParent(parent), TreeTransformer.substitutePreviousChild(prevChild, self));
		}

		// Use-case: existing tree instructs its parent to replace it and re-create the rest of the children
		static <T> TreeTransformer<T> substitutePreviousChild(Tree<T> prevChild, Tree<T> newChild) {
			return self -> child -> (child.equals(prevChild)) ? newChild : new Tree<>(self, child.value,
					child.children, TreeTransformer::identity, TreeTransformer::updateChildren);
		}

		// Use-case: creating new Tree node with a specific parent
		static <T> UnaryOperator<Tree<T>> addThisToParent(Tree<T> self) {
			return parent -> new Tree<>(parent.parent, parent.value, parent.children.append(self),
					TreeTransformer.updateParent(parent), TreeTransformer::updateChildren);
		}
	}
}
```


Overlapping Code:
```
LikeStructure<T, Tree<T>> implements Serializable /* TODO:extends Iterable<T> */{
private static final long serialVersionUID = -7482343083286183794L;
private final Tree<T> parent;
private final T value;
private final List<Tree<T>> children;
// -- constructors + factory methods
public Tree(T value) {
this(null, value, List.of(), TreeTransformer::identity, TreeTransformer::identity);
}
public Tree(T value, Iterable<Tree<T>> children) {
this(null, value, children, TreeTransformer::identity, TreeTransformer::updateChildren);
}
public Tree(Tree<T> parent, T value) {
this(parent, value, List.of(), TreeTransformer::addThisToParent, TreeTransformer::identity);
}
public Tree(Tree<T> parent, T value, Iterable<Tree<T>> children) {
this(parent, value, children, TreeTransformer::addThisToParent, TreeTransformer::updateChildren);
}
// DEV-NOTE: beware of NPEs because this is leaving the constructor
Tree(Tree<T> parent, T value, Iterable<Tree<T>> children, TreeTransformer<T> updateParent,
TreeTransformer<T> updateChildren) {
requireNonNull(children, "children is null");
requireNonNull(updateParent, "updateParent is null");
requireNonNull(updateChildren, "updateChildren is null");
this.value = value;
this.children = List.of(children).replaceAll(updateChildren.apply(this));
this.parent = Option.of(parent).map(updateParent.apply(this)).orElse(null);
}
/**
* Factory method for easy tree building.
* <p>
* <strong>Example:</strong>
* <p>
* {@code tree("A", tree("B"), tree("C", tree("D"), tree("E", tree("F", tree("G")))))}
* <p>
* results in:
* 
* <pre>
* <code>
* A
* / \
* B C
* / \
* D E
* |
* F
* |
* G
* </code>
* </pre>
* 
* @param <T> value type of the result Tree
* @param value The value of the Tree.
* @param children The children of the Tree.
* @return A new Tree instance based on the arguments.
*/
@SafeVarargs
public static <T> Tree<T> tree(T value, Tree<T>... children) {
final List<Tree<T>> childList = List.of(children);
return new Tree<>(null, value, childList, TreeTransformer::identity, TreeTransformer::updateChildren);
}
// -- core
public Option<Tree<T>> getParent() {
return Option.of(parent);
}
public Tree<T> setParent(Tree<T> parent) {
if (Objects.equals(this.parent, parent)) {
return this;
} else {
return new Tree<>(parent, value, children, Tree
```
<Overlap Ratio: 0.976006855184233>

---

--- 147 --
Question ID: 11df047728c9c9f5a030f7ddafd589c5f32a2934
Original Code:
```
class Six_b {
	public static void main (String[] argr) {
		String str = "aaabbcccccaa";
		System.out.println(compressedString(str));
	}

	static String compressedString(String str) {
		int count = 0;
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < str.length(); i++) {
			count++;
			if (i + 1 >= str.length() || str.charAt(i) != str.charAt(i+1)) {
				sb.append(str.charAt(i));
				sb.append(count);
				count = 0;
			}
		}
		return sb.length() > str.length() ? str : sb.toString();
	}
}
```


Overlapping Code:
```
tatic void main (String[] argr) {
String str = "aaabbcccccaa";
System.out.println(compressedString(str));
}
static String compressedString(String str) {
int count = 0;
StringBuilder sb = new StringBuilder();
for (int i = 0; i < str.length(); i++) {
count++;
if (i + 1 >= str.length() || str.charAt(i) != str.charAt(i+1)) {
sb.append(str.charAt(i));
sb.append(count);
count = 0;
}
}
return sb.length() > str.len
```
<Overlap Ratio: 0.8836206896551724>

---

--- 148 --
Question ID: 4c99a12a1a0e2b68fe6840b904c1e3ed2da35850
Original Code:
```
@Getter @Setter
public class SmsCodeService extends GeneralTokenService<SmsCodeTokenRequest, SmsCode> {

    @Override
    public SmsCode allocate(SmsCodeTokenRequest request) {
        String key = generateCodeSeq(request.getCodeLength());
        return new SmsCode(key, request.getCodeValidityDuration(), request.getMobilePhone());
    }

    private String generateCodeSeq(int length) {
        final Random random = new Random();
        char[] seq = new char[length];
        char[] codes = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
        for (int i = 0; i < length; i++) {
            seq[i] = codes[random.nextInt(codes.length)];
        }

        return new String(seq);
    }


}
```


Overlapping Code:
```

public class SmsCodeService extends GeneralTokenService<SmsCodeTokenRequest, SmsCode> {
@Override
public SmsCode allocate(SmsCodeTokenRequest request) {
String key = generateCodeSeq(request.getCodeLength());
return new SmsCode(key, request.getCodeValidityDuration(), request.getMobilePhone());
}
private String generateCodeSeq(int length) {
final Random random = new Random();
char[] seq = new char[length];
char[] codes = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
for (int i = 0; i < length; i++) {
seq[i] = codes[random.nextInt(codes.length)];
}
return new String(se
```
<Overlap Ratio: 0.9634551495016611>

---

--- 149 --
Question ID: cdd33960844f9bf562cdc623853607af599feb84
Original Code:
```
public class CosplayerView extends RelativeLayout {

    private ImageView iconView;
    private TextView titleView;
    private TextView subTitleView;

    public CosplayerView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    /** {@inheritDoc} */
    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        iconView = ((ImageView) findViewById(R.id.icon));
        titleView = ((TextView) findViewById(android.R.id.text1));
        subTitleView = ((TextView) findViewById(android.R.id.text2));
    }

    public void bind(Cosplayer item) {
        titleView.setText(item.name);
        subTitleView.setText(item.option);

        final FaceApplication application = (FaceApplication) getContext().getApplicationContext();
        Picasso.with(getContext())
               .load(item.url)
               .transform(new FaceTrimming(application.getFaceDetector()))
               .memoryPolicy(MemoryPolicy.NO_STORE)
               .into(iconView);
    }
}
```


Overlapping Code:
```
ublic class CosplayerView extends RelativeLayout {
private ImageView iconView;
private TextView titleView;
private TextView subTitleView;
public CosplayerView(Context context, AttributeSet attrs) {
super(context, attrs);
}
/** {@inheritDoc} */
@Override
protected void onFinishInflate() {
super.onFinishInflate();
iconView = ((ImageView) findViewById(R.id.icon));
titleView = ((TextView) findViewById(android.R.id.text1));
subTitleView = ((TextView) findViewById(android.R.id.text2));
}
public void bind(Cosplayer item) {
titleView.setText(item.name);
subTitleView.setText(item.option);
final FaceApplication application = (FaceApplication) getContext().getApplicationContext();
Picasso.with(getContext())
.load(item.url)
.transform(new FaceTrimming(application.getFaceDetector()))
.memoryPolicy(Memo
```
<Overlap Ratio: 0.9523809523809523>

---

--- 150 --
Question ID: fa9090ee63a587e637a8749cdb94b5675a06b008
Original Code:
```
public class Appointment {

    private final AppointmentPatientId patientId;
    private final AppointmentDoctorId doctorId;
    private final AppointmentDate date;
    private final AppointmentTime time;
    private final AppointmentStatus appointmentStatus;
    private Patient patient;
    private Doctor doctor;

    /**
     * Constructs a new {@code Appointment}. New appointments default to ACTIVE status.
     *
     * @param patientId A valid patientId.
     * @param doctorId A valid doctorId.
     * @param date A valid appointment date
     * @param time A valid appointment time
     */
    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,
                       AppointmentTime time) {

        this(patientId, doctorId, date, time, AppointmentStatus.ACTIVE);
        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);
    }

    /**
     * Constructs an {@code Appointment} with a stated status.
     *
     * @param patientId A valid patientId.
     * @param doctorId A valid doctorId.
     * @param date A valid appointment date
     * @param time A valid appointment time
     */
    public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,
                       AppointmentTime time, AppointmentStatus appointmentStatus) {
        /**
         * Every field must be present and not null.
         */
        requireAllNonNull(patientId, doctorId, date, time, appointmentStatus);
        //checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);
        this.patientId = patientId;
        this.doctorId = doctorId;
        this.date = date;
        this.time = time;
        this.appointmentStatus = appointmentStatus;
    }

    /**
     * Returns true if a given string is a valid appointment.
     */
    public static boolean isValidAppointment(String test) {
        return !test.trim().isEmpty();
    }

    @Override
    public String toString() {
        String str = "";
        str += "Appointment - ";
        str += "Patient ID: " + patientId;
        str += " Doctor ID: " + doctorId;
        str += " Date: " + date;
        str += " Time: " + time;
        return str;
    }

    public AppointmentPatientId getPatientId() {
        return patientId;
    }

    public AppointmentDoctorId getDoctorId() {
        return doctorId;
    }

    public Patient getPatient() {
        return patient;
    }

    public void setPatient(Patient patient) {
        this.patient = patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public void setDoctor(Doctor doctor) {
        this.doctor = doctor;
    }

    public AppointmentDate getDate() {
        return date;
    }

    public AppointmentTime getTime() {
        return time;
    }

    public AppointmentStatus getAppointmentStatus() {
        return appointmentStatus;
    }

    public boolean isSameAppointment(Appointment that) {
        return this.equals(that);
    }

    /**
     * Checks if an appointment is in the past compared to system time.
     *
     * @return true if the appointment is in the past.
     */
    public boolean isPast() {
        LocalDateTime currentDateTime = LocalDateTime.now();
        LocalDateTime appointmentDateTime = LocalDateTime.of(date.date, time.time);

        final boolean past = appointmentDateTime.isBefore(currentDateTime);
        return past;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        // subclasses of this class are equal to the superclass
        if (o == null || !(o instanceof Appointment)) {
            return false;
        }

        Appointment that = (Appointment) o;

        if (!this.doctorId.equals(that.doctorId)) {
            return false;
        }

        if (!this.patientId.equals(that.patientId)) {
            return false;
        }

        if (!this.date.equals(that.date)) {
            return false;
        }

        if (!this.time.equals(that.time)) {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode() {
        return Objects.hash(patientId, doctorId, date, time);
    }
}
```


Overlapping Code:
```
nt {
private final AppointmentPatientId patientId;
private final AppointmentDoctorId doctorId;
private final AppointmentDate date;
private final AppointmentTime time;
private final AppointmentStatus appointmentStatus;
private Patient patient;
private Doctor doctor;
/**
* Constructs a new {@code Appointment}. New appointments default to ACTIVE status.
*
* @param patientId A valid patientId.
* @param doctorId A valid doctorId.
* @param date A valid appointment date
* @param time A valid appointment time
*/
public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,
AppointmentTime time) {
this(patientId, doctorId, date, time, AppointmentStatus.ACTIVE);
//checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);
}
/**
* Constructs an {@code Appointment} with a stated status.
*
* @param patientId A valid patientId.
* @param doctorId A valid doctorId.
* @param date A valid appointment date
* @param time A valid appointment time
*/
public Appointment(AppointmentPatientId patientId, AppointmentDoctorId doctorId, AppointmentDate date,
AppointmentTime time, AppointmentStatus appointmentStatus) {
/**
* Every field must be present and not null.
*/
requireAllNonNull(patientId, doctorId, date, time, appointmentStatus);
//checkArgument(isValidAppointment(appointment), MESSAGE_CONSTRAINTS);
this.patientId = patientId;
this.doctorId = doctorId;
this.date = date;
this.time = time;
this.appointmentStatus = appointmentStatus;
}
/**
* Returns true if a given string is a valid appointment.
*/
public static boolean isValidAppointment(String test) {
return !test.trim().isEmpty();
}
@Override
public String toString() {
String str = "";
str += "Appointment - ";
str += "Patient ID: " + patientId;
str += " Doctor ID: " + doctorId;
str += " Date: " + date;
str += " Time: " + time;
return str;
}
public AppointmentPatientId getPatientId() {
return patientId;
}
public AppointmentDoctorId getDoctorId() {
return doctorId;
}
public Patient getPatient() {
return patient;
}
public void setPatient(P
```
<Overlap Ratio: 0.989387361312108>

---

--- 151 --
Question ID: 9afab408d56361520835ce0cd1c7a97c431f9d2a
Original Code:
```
@Component
@Order(-10)
public class ProxyFilter implements WebFilter {
    private final static Pattern pattern = Pattern.compile(
            "(2[5][0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})");
    private static Logger logger = LoggerFactory.getLogger(ProxyFilter.class);
    private static AtomicLong SessionId = new AtomicLong(0L);
    @Override
    public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {
        serverWebExchange.getRequest().getHeaders();
        GrpcConManger.getInstance().addSession(new SessionInfo(SessionId.incrementAndGet(), getIp(serverWebExchange)));
        return webFilterChain.filter(serverWebExchange);
    }

    private static String getIp(ServerWebExchange exchange){
        String ip;
        ip = getIpFromHead(exchange.getRequest().getHeaders());
        if(ip != null){
            logger.debug("IP:{}", ip);
        }

        ip = getValIp(exchange.getRequest().getHeaders().get(HttpHeaders.FROM));
        if(ip != null){
            logger.debug("IP:{}", ip);
            return ip;
        }

        if(exchange.getRequest().getRemoteAddress() != null){
            ip = exchange.getRequest().getRemoteAddress().getHostString();
            logger.debug("IP:{}", ip);
            return ip;
        }

        return ConstValues.IG_IP;
    }

    private static String getIpFromHead(HttpHeaders headers){
        String[] headNames = new String[]{"X-Real-IP", "X-Forwarded-For", "Proxy-Client-IP",
                                          "WL-Proxy-Client-IP","HTTP_CLIENT_IP","HTTP_X_FORWARDED_FOR"};
        for (String n:headNames){
            List<String> list = headers.get(n);
            String ip = getValIp(list);
            if(ip != null){
                return ip;
            }
        }

        return null;
    }

    private static String getValIp(List<String> list){
        if(list == null){
            return null;
        }

        for(String ip:list){
            if(isValidIP(ip)){
                return ip;
            }
        }
        return null;
    }

    private static boolean isValidIP(String ip){
        if((ip == null) || ip.isEmpty()){
            return false;
        }

        Matcher matcher = pattern.matcher(ip);
        return matcher.matches();
    }
}
```


Overlapping Code:
```
 class ProxyFilter implements WebFilter {
private final static Pattern pattern = Pattern.compile(
"(2[5][0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})\\.(25[0-5]|2[0-4]\\d|1\\d{2}|\\d{1,2})");
private static Logger logger = LoggerFactory.getLogger(ProxyFilter.class);
private static AtomicLong SessionId = new AtomicLong(0L);
@Override
public Mono<Void> filter(ServerWebExchange serverWebExchange, WebFilterChain webFilterChain) {
serverWebExchange.getRequest().getHeaders();
GrpcConManger.getInstance().addSession(new SessionInfo(SessionId.incrementAndGet(), getIp(serverWebExchange)));
return webFilterChain.filter(serverWebExchange);
}
private static String getIp(ServerWebExchange exchange){
String ip;
ip = getIpFromHead(exchange.getRequest().getHeaders());
if(ip != null){
logger.debug("IP:{}", ip);
}
ip = getValIp(exchange.getRequest().getHeaders().get(HttpHeaders.FROM));
if(ip != null){
logger.debug("IP:{}", ip);
return ip;
}
if(exchange.getRequest().getRemoteAddress() != null){
ip = exchange.getRequest().getRemoteAddress().getHostString();
logger.debug("IP:{}", ip);
return ip;
}
return ConstValues.IG_IP;
}
private static String getIpFromHead(HttpHeaders headers){
String[] headNames = new String[]{"X-Real-IP", "X-Forwarded-For", "Proxy-Client-IP",
"WL-Proxy-Client-IP","HTTP_CLIENT_IP","HTTP_X_FORWARDED_FOR"};
for (String n:headNames){
List<String> list = headers.get(n);
String ip = getValIp(list);
if(ip != null){
return ip;
}
}
return null;
}
private static String getValIp(List<String> list){
if(list == null){
return null;
}
for(String ip:list){
if(isValidIP(ip)){
return ip;
}
}
return null;
}
private static boolean isValidIP(String ip){
if((ip == null) || ip.isEmpty()){
return false;
}
Matcher matcher = pattern.matcher(ip);
return matcher.matches();
}
}
```
<Overlap Ratio: 0.9845333333333334>

---

--- 152 --
Question ID: 7c3747bfd629bc2021240fec64ad1bf506105983
Original Code:
```
public class Cleanup01
{
	public static void main(String[] args)
	{
		boolean success = false;
		boolean trying = true;
		int tries = 0;

		try
		{
			ORBInterface.initORB(args, null);
			OAInterface.initOA();

			String profileName = args[args.length - 1];

			int numberOfDrivers = JDBCProfileStore.numberOfDrivers(profileName);
			for (int index = 0; index < numberOfDrivers; index++)
			{
				String driver = JDBCProfileStore.driver(profileName, index);

				Class.forName(driver);
			}

			String databaseURL = JDBCProfileStore.databaseURL(profileName);
			String databaseUser = JDBCProfileStore.databaseUser(profileName);
			String databasePassword = JDBCProfileStore.databasePassword(profileName);
			String databaseDynamicClass = JDBCProfileStore.databaseDynamicClass(profileName);

			Connection connection;
			if (databaseDynamicClass != null)
			{
				Properties databaseProperties = new Properties();

				databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.userName, databaseUser);
				databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.password, databasePassword);
				databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.dynamicClass, databaseDynamicClass);

				connection = DriverManager.getConnection(databaseURL, databaseProperties);
			}
			else
			{
				connection = DriverManager.getConnection(databaseURL, databaseUser, databasePassword);
			}

            String tableName = JDBCProfileStore.getTableName(databaseUser, "Infotable");
            
			while (trying)
			{
				try
				{
					Statement statement = connection.createStatement();

					System.err.println("DROP TABLE " + tableName);
					statement.executeUpdate("DROP TABLE " + tableName);

					statement.close();
					connection.close();

					trying = false;
					success = true;
					/* Server might have crashed and table might still be busy. */
				}
				catch (java.sql.SQLException s)
				{
					System.err.println("Cleanup01.main: " + s);
					System.err.println("SQL state is: " + s.getSQLState());
					if (s.getSQLState() == "42000" ||	/* no table to drop */
							s.getSQLState() == "42S02" ||	/* table not found */
							s.getSQLState() == null)		/* connection failed */
					{
						trying = false;
					}
					else
					{
						tries++;
						if (tries >= 6)
						{
							trying = false;
							System.err.println("Giving up.");
						}
						else
						{
							try
							{
								System.err.println("Sleeping " + (tries * 10) + " seconds and re-trying ...");
								Thread.sleep(tries * 10000);
							}
							catch (Exception e)
							{
								System.err.println("Cleanup01.main: " + e);
								trying = false;
							}
						}
					}
				}
				catch (Exception e)
				{
					System.err.println("Cleanup01.main: " + e);
					trying = false;
				}
			}
		}
		catch (Exception exception)
		{
			System.err.println("Cleanup01.main: " + exception);
		}

		try
		{
			OAInterface.shutdownOA();
			ORBInterface.shutdownORB();
		}
		catch (Exception exception)
		{
			System.err.println("Cleanup01.main: " + exception);
			exception.printStackTrace(System.err);

			success = false;
		}

		System.out.println(success ? "Passed" : "Failed");
	}
}
```


Overlapping Code:
```
c class Cleanup01
{
public static void main(String[] args)
{
boolean success = false;
boolean trying = true;
int tries = 0;
try
{
ORBInterface.initORB(args, null);
OAInterface.initOA();
String profileName = args[args.length - 1];
int numberOfDrivers = JDBCProfileStore.numberOfDrivers(profileName);
for (int index = 0; index < numberOfDrivers; index++)
{
String driver = JDBCProfileStore.driver(profileName, index);
Class.forName(driver);
}
String databaseURL = JDBCProfileStore.databaseURL(profileName);
String databaseUser = JDBCProfileStore.databaseUser(profileName);
String databasePassword = JDBCProfileStore.databasePassword(profileName);
String databaseDynamicClass = JDBCProfileStore.databaseDynamicClass(profileName);
Connection connection;
if (databaseDynamicClass != null)
{
Properties databaseProperties = new Properties();
databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.userName, databaseUser);
databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.password, databasePassword);
databaseProperties.put(com.arjuna.ats.jdbc.TransactionalDriver.dynamicClass, databaseDynamicClass);
connection = DriverManager.getConnection(databaseURL, databaseProperties);
}
else
{
connection = DriverManager.getConnection(databaseURL, databaseUser, databasePassword);
}
String tableName = JDBCProfileStore.getTableName(databaseUser, "Infotable");

while (trying)
{
try
{
Statement statement = connection.createStatement();
System.err.println("DROP TABLE " + tableName);
statement.executeUpdate("DROP TABLE " + tableName);
statement.close();
connection.close();
trying = false;
success = true;
/* Server might have crashed and table might still be busy. */
}
catch (java.sql.SQLException s)
{
System.err.println("Cleanup01.main: " + s);
System.err.println("SQL state is: " + s.getSQLState());
if (s.getSQLState() == "42000" || /* no table to drop */
s.getSQLState() == "42S02" || /* table not found */
s.getSQLState() == null) /* connection failed */
{
trying = false;
}
else
{
tries++;
if (tries >= 6)
{
trying = false;
System.err.println("Giving up.");
}
else
{
try
{
System.err.println("Sleeping " + (tries * 10) + " seconds an
```
<Overlap Ratio: 0.9894058037770612>

---

--- 153 --
Question ID: 67bfb6565f53947daaed60f5a55a436a7b420114
Original Code:
```
public class AnnotationEmitter implements SpecialEmitter {

    private static final Map<Class<?>, BiConsumer<JavaEmitterContext, Object>> value_emitters = new HashMap<>();

    static {
        value_emitters.put(Boolean.class, (ctx, value) -> ctx.printString(String.valueOf(value)));
        value_emitters.put(Integer.class, (ctx, value) -> ctx.printString(String.valueOf(value)));
        value_emitters.put(int[].class, (ctx, value) -> {
            int[] values = (int[]) value;
            ctx.printString("{");
            for (int i = 0; i < values.length; i++) {
                if (i > 0) {
                    ctx.printString(", ");
                }
                ctx.printString(String.valueOf(values[i]));
            }
            ctx.printString("}");
        });
        value_emitters.put(ArrayList.class, (ctx, value) -> {
            List<?> list = (List<?>) value;
            if (list.isEmpty()) {
                ctx.printString("{}");
            } else if (list.size() == 1) {
                emitValue(ctx, list.get(0));
            } else {
                ctx.printString("{");
                for (int i = 0; i < list.size(); i++) {
                    if (i != 0) {
                        ctx.printString(", ");
                    }
                    emitValue(ctx, list.get(i));
                }
                ctx.printString("}");
            }
        });
        value_emitters.put(String.class, (ctx, value) -> {
            ctx.printString("\"");
            ctx.printString(StringConstantEmitter.escape((String) value));
            ctx.printString("\"");
        });
        value_emitters.put(String[].class, (ctx, value) -> {
            String[] values = (String[]) value;
            ctx.printString("{");
            for (int i = 0; i < values.length; i++) {
                if (i > 0) {
                    ctx.printString(", ");
                }
                ctx.printString("\"");
                ctx.printString(StringConstantEmitter.escape(values[i]));
                ctx.printString("\"");
            }
            ctx.printString("}");
        });
        value_emitters.put(EnumConstant.class, (ctx, value) -> {
            EnumConstant e = (EnumConstant) value;
            ctx.emitType(e.getEnumType());
            ctx.printString(".");
            ctx.printString(e.getConstantName());
        });
        value_emitters.put(ClassTypeSignature.class, (ctx, value) -> ctx.emitTypeName(((ClassTypeSignature) value).getName()));
    }

    public static void emitValue(JavaEmitterContext ctx, Object value) {
        BiConsumer<JavaEmitterContext, Object> emitter = value_emitters.get(value.getClass());
        if (emitter == null) {
            throw new IllegalStateException("Unknown annotation value type in emitter: " + value.getClass().getName());
        }
        emitter.accept(ctx, value);
    }

    /**
     * Emits the given annotation.
     */
    public void emit(JavaEmitterContext ctx, Annotation annotation) {
        ctx.printString("@");
        ctx.emitType(annotation.getType().getName());
        if (annotation.getKeys().isEmpty()) {
            return;
        } else if (annotation.getKeys().size() == 1 && "value".equals(annotation.getKeys().iterator().next())) {
            ctx.printString("(");
            emitValue(ctx, annotation.getValue("value"));
            ctx.printString(" ", ctx.getFormat().insert_space_before_closing_paren_in_annotation);
            ctx.printString(")");
        } else {
            ctx.printString("(");
            boolean first = true;
            for (String key : annotation.getKeys()) {
                if (!first) {
                    ctx.printString(", ");
                }
                first = false;
                ctx.printString(key);
                ctx.printString(" = ");
                Object value = annotation.getValue(key);
                emitValue(ctx, value);
            }
            ctx.printString(" ", ctx.getFormat().insert_space_before_closing_paren_in_annotation);
            ctx.printString(")");
        }
    }

}
```


Overlapping Code:
```
cialEmitter {
private static final Map<Class<?>, BiConsumer<JavaEmitterContext, Object>> value_emitters = new HashMap<>();
static {
value_emitters.put(Boolean.class, (ctx, value) -> ctx.printString(String.valueOf(value)));
value_emitters.put(Integer.class, (ctx, value) -> ctx.printString(String.valueOf(value)));
value_emitters.put(int[].class, (ctx, value) -> {
int[] values = (int[]) value;
ctx.printString("{");
for (int i = 0; i < values.length; i++) {
if (i > 0) {
ctx.printString(", ");
}
ctx.printString(String.valueOf(values[i]));
}
ctx.printString("}");
});
value_emitters.put(ArrayList.class, (ctx, value) -> {
List<?> list = (List<?>) value;
if (list.isEmpty()) {
ctx.printString("{}");
} else if (list.size() == 1) {
emitValue(ctx, list.get(0));
} else {
ctx.printString("{");
for (int i = 0; i < list.size(); i++) {
if (i != 0) {
ctx.printString(", ");
}
emitValue(ctx, list.get(i));
}
ctx.printString("}");
}
});
value_emitters.put(String.class, (ctx, value) -> {
ctx.printString("\"");
ctx.printString(StringConstantEmitter.escape((String) value));
ctx.printString("\"");
});
value_emitters.put(String[].class, (ctx, value) -> {
String[] values = (String[]) value;
ctx.printString("{");
for (int i = 0; i < values.length; i++) {
if (i > 0) {
ctx.printString(", ");
}
ctx.printString("\"");
ctx.printString(StringConstantEmitter.escape(values[i]));
ctx.printString("\"");
}
ctx.printString("}");
});
value_emitters.put(EnumConstant.class, (ctx, value) -> {
EnumConstant e = (EnumConstant) value;
ctx.emitType(e.getEnumType());
ctx.printString(".");
ctx.printString(e.getConstantName());
});
value_emitters.put(ClassTypeSignature.class, (ctx, value) -> ctx.emitTypeName(((ClassTypeSigna
```
<Overlap Ratio: 0.96045197740113>

---

--- 154 --
Question ID: a630a6063a8578224a637c0fa85ce61e8bd5650f
Original Code:
```
public class AnimatorSetCompat
{

	public static void playTogether(AnimatorSet animatorset, List list)
	{
		int j = list.size();
	//    0    0:aload_1         
	//    1    1:invokeinterface #16  <Method int List.size()>
	//    2    6:istore_3        
		long l = 0L;
	//    3    7:lconst_0        
	//    4    8:lstore          4
		for(int i = 0; i < j; i++)
	//*   5   10:iconst_0        
	//*   6   11:istore_2        
	//*   7   12:iload_2         
	//*   8   13:iload_3         
	//*   9   14:icmpge          54
		{
			Animator animator = (Animator)list.get(i);
	//   10   17:aload_1         
	//   11   18:iload_2         
	//   12   19:invokeinterface #20  <Method Object List.get(int)>
	//   13   24:checkcast       #22  <Class Animator>
	//   14   27:astore          6
			l = Math.max(l, animator.getStartDelay() + animator.getDuration());
	//   15   29:lload           4
	//   16   31:aload           6
	//   17   33:invokevirtual   #26  <Method long Animator.getStartDelay()>
	//   18   36:aload           6
	//   19   38:invokevirtual   #29  <Method long Animator.getDuration()>
	//   20   41:ladd            
	//   21   42:invokestatic    #35  <Method long Math.max(long, long)>
	//   22   45:lstore          4
		}

	//   23   47:iload_2         
	//   24   48:iconst_1        
	//   25   49:iadd            
	//   26   50:istore_2        
	//*  27   51:goto            12
		ValueAnimator valueanimator = ValueAnimator.ofInt(new int[] {
			0, 0
		});
	//   28   54:iconst_2        
	//   29   55:newarray        int[]
	//   30   57:dup             
	//   31   58:iconst_0        
	//   32   59:iconst_0        
	//   33   60:iastore         
	//   34   61:dup             
	//   35   62:iconst_1        
	//   36   63:iconst_0        
	//   37   64:iastore         
	//   38   65:invokestatic    #41  <Method ValueAnimator ValueAnimator.ofInt(int[])>
	//   39   68:astore          6
		((Animator) (valueanimator)).setDuration(l);
	//   40   70:aload           6
	//   41   72:lload           4
	//   42   74:invokevirtual   #45  <Method Animator Animator.setDuration(long)>
	//   43   77:pop             
		list.add(0, ((Object) (valueanimator)));
	//   44   78:aload_1         
	//   45   79:iconst_0        
	//   46   80:aload           6
	//   47   82:invokeinterface #49  <Method void List.add(int, Object)>
		animatorset.playTogether(((java.util.Collection) (list)));
	//   48   87:aload_0         
	//   49   88:aload_1         
	//   50   89:invokevirtual   #54  <Method void AnimatorSet.playTogether(java.util.Collection)>
	//   51   92:return          
	}
}
```


Overlapping Code:
```
lic class AnimatorSetCompat
{
public static void playTogether(AnimatorSet animatorset, List list)
{
int j = list.size();
// 0 0:aload_1 
// 1 1:invokeinterface #16 <Method int List.size()>
// 2 6:istore_3 
long l = 0L;
// 3 7:lconst_0 
// 4 8:lstore 4
for(int i = 0; i < j; i++)
//* 5 10:iconst_0 
//* 6 11:istore_2 
//* 7 12:iload_2 
//* 8 13:iload_3 
//* 9 14:icmpge 54
{
Animator animator = (Animator)list.get(i);
// 10 17:aload_1 
// 11 18:iload_2 
// 12 19:invokeinterface #20 <Method Object List.get(int)>
// 13 24:checkcast #22 <Class Animator>
// 14 27:astore 6
l = Math.max(l, animator.getStartDelay() + animator.getDuration());
// 15 29:lload 4
// 16 31:aload 6
// 17 33:invokevirtual #26 <Method long Animator.getStartDelay()>
// 18 36:aload 6
// 19 38:invokevirtual #29 <Method long Animator.getDuration()>
// 20 41:ladd 
// 21 42:invokestatic #35 <Method long Math.max(long, long)>
// 22 45:lstore 4
}
// 23 47:iload_2 
// 24 48:iconst_1 
// 25 49:iadd 
// 26 50:istore_2 
//* 27 51:goto 12
ValueAnimator valueanimator = ValueAnimator.ofInt(new int[] {
0, 0
});
// 28 54:iconst_2 
// 29 55:newarray int[]
// 30 57:dup 
// 31 58:iconst_0 
// 32 59:iconst_0 
// 33 60:iastore 
// 34 61:dup 
// 35 62:iconst_1 
// 36 63:iconst_0 
// 37 64:iastore 
// 38 65:invokestatic #41 <Method ValueAnimator ValueAnimator.ofInt(int[])>
// 39 68:astore 6
((Animator) (valueanimator)).setDuration(l);
// 40 70:aload 6
// 41 72:lload 4
// 42 74:invokevirtual #45 <Method Animator Animator.setDuration(long)>
// 43 77:pop 
list.add(0, ((Object) (valueanimator)));
// 44 78:aload_1 
// 45 79:iconst_0 
// 46 80:aload 6
// 47 82:invokeinterface #49 <Method void List.add(int, Object)>
animatorset.playTogether(((java.util.Collection) (list)));
// 48 87:aload_0 
// 49 88:aload_1 
// 50 89:invokevirtual #54 <
```
<Overlap Ratio: 0.9895547003848268>

---

--- 155 --
Question ID: 4d5f471ea8ae38c5f679def66fd20c866953ae80
Original Code:
```
public class DistBuildLogsCommandIntegrationTest {

  private static final StampedeId STAMPEDE_ID = new StampedeId().setId("super_cool_stampede_id");

  @Rule public TemporaryPaths tmp = new TemporaryPaths();

  @Test
  public void runCommandAndCheckOutputFile() throws IOException {
    BuildSlaveInfo slave1 =
        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId("build_slave_1"));
    BuildSlaveInfo slave2 =
        new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId("build_slave_2"));
    BuildJob buildJob = new BuildJob().setStampedeId(STAMPEDE_ID);
    buildJob.addToBuildSlaves(slave1);
    buildJob.addToBuildSlaves(slave2);

    LogDir logDir1 =
        new LogDir().setBuildSlaveRunId(slave1.getBuildSlaveRunId()).setData(getZipContents());
    LogDir logDir2 =
        new LogDir().setBuildSlaveRunId(slave2.getBuildSlaveRunId()).setData(getZipContents());
    List<LogDir> logDirs = Lists.newArrayList(logDir1, logDir2);

    try (Server server = new Server(buildJob, logDirs)) {
      ProjectWorkspace workspace =
          TestDataHelper.createProjectWorkspaceForScenario(this, "dist_build_logs_command", tmp);
      workspace.setUp();
      workspace
          .runBuckCommand(
              "distbuild",
              "logs",
              "--stampede-id=" + STAMPEDE_ID.getId(),
              server.getStampedeConfigArg(),
              server.getPingEndpointConfigArg())
          .assertSuccess();

      ListAllFiles filesLister = new ListAllFiles();
      Files.walkFileTree(tmp.getRoot(), filesLister);

      List<String> helloWorldFiles =
          filesLister.getAbsPaths().stream()
              .filter(x -> x.contains("hello_world.txt"))
              .sorted()
              .collect(Collectors.toList());

      Assert.assertEquals(2, helloWorldFiles.size());
      Assert.assertTrue(helloWorldFiles.get(0).contains(slave1.getBuildSlaveRunId().getId()));
      Assert.assertTrue(helloWorldFiles.get(1).contains(slave2.getBuildSlaveRunId().getId()));
    }
  }

  private byte[] getZipContents() {
    // Zip file containing one empty file named "hello_world.txt".
    String base64Contents =
        "UEsDBAoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABwAaGVsbG9fd29ybGQudHh0VVQJAA"
            + "NycehZcnHoWXV4CwABBNE7wRgEui3Tb1BLAQIeAwoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABgAAAAAAAAAAACkg"
            + "QAAAABoZWxsb193b3JsZC50eHRVVAUAA3Jx6Fl1eAsAAQTRO8EYBLot029QSwUGAAAAAAEAAQBVAAAASQAAAAAA";
    return Base64.getDecoder().decode(base64Contents);
  }

  private static class ListAllFiles implements FileVisitor<Path> {

    List<String> absPaths;

    public ListAllFiles() {
      absPaths = Lists.newArrayList();
    }

    public List<String> getAbsPaths() {
      return absPaths;
    }

    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
      return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
      absPaths.add(file.toAbsolutePath().toString());
      return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) {
      return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
      return FileVisitResult.CONTINUE;
    }
  }

  private static class Server extends FakeFrontendHttpServer {

    private final BuildJob buildJob;
    private final List<LogDir> logDirs;

    public Server(BuildJob buildJob, List<LogDir> logDirs) throws IOException {
      this.buildJob = buildJob;
      this.logDirs = logDirs;
    }

    @Override
    public FrontendResponse handleRequest(FrontendRequest request) {
      FrontendResponse response = new FrontendResponse();
      response.setType(request.getType());
      response.setWasSuccessful(true);

      if (request.getType() == FrontendRequestType.BUILD_STATUS) {
        BuildStatusResponse statusResponse = new BuildStatusResponse();
        statusResponse.setBuildJob(buildJob);
        response.setBuildStatusResponse(statusResponse);
      } else if (request.getType() == FrontendRequestType.GET_BUILD_SLAVE_LOG_DIR) {
        MultiGetBuildSlaveLogDirResponse logDirResponse = new MultiGetBuildSlaveLogDirResponse();
        logDirResponse.setLogDirs(logDirs);
        response.setMultiGetBuildSlaveLogDirResponse(logDirResponse);
      } else {
        Assert.fail("This call was not expected.");
      }

      return response;
    }
  }
}
```


Overlapping Code:
```
DistBuildLogsCommandIntegrationTest {
private static final StampedeId STAMPEDE_ID = new StampedeId().setId("super_cool_stampede_id");
@Rule public TemporaryPaths tmp = new TemporaryPaths();
@Test
public void runCommandAndCheckOutputFile() throws IOException {
BuildSlaveInfo slave1 =
new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId("build_slave_1"));
BuildSlaveInfo slave2 =
new BuildSlaveInfo().setBuildSlaveRunId(new BuildSlaveRunId().setId("build_slave_2"));
BuildJob buildJob = new BuildJob().setStampedeId(STAMPEDE_ID);
buildJob.addToBuildSlaves(slave1);
buildJob.addToBuildSlaves(slave2);
LogDir logDir1 =
new LogDir().setBuildSlaveRunId(slave1.getBuildSlaveRunId()).setData(getZipContents());
LogDir logDir2 =
new LogDir().setBuildSlaveRunId(slave2.getBuildSlaveRunId()).setData(getZipContents());
List<LogDir> logDirs = Lists.newArrayList(logDir1, logDir2);
try (Server server = new Server(buildJob, logDirs)) {
ProjectWorkspace workspace =
TestDataHelper.createProjectWorkspaceForScenario(this, "dist_build_logs_command", tmp);
workspace.setUp();
workspace
.runBuckCommand(
"distbuild",
"logs",
"--stampede-id=" + STAMPEDE_ID.getId(),
server.getStampedeConfigArg(),
server.getPingEndpointConfigArg())
.assertSuccess();
ListAllFiles filesLister = new ListAllFiles();
Files.walkFileTree(tmp.getRoot(), filesLister);
List<String> helloWorldFiles =
filesLister.getAbsPaths().stream()
.filter(x -> x.contains("hello_world.txt"))
.sorted()
.collect(Collectors.toList());
Assert.assertEquals(2, helloWorldFiles.size());
Assert.assertTrue(helloWorldFiles.get(0).contains(slave1.getBuildSlaveRunId().getId()));
Assert.assertTrue(helloWorldFiles.get(1).contains(slave2.getBuildSlaveRunId().getId()));
}
}
private byte[] getZipContents() {
// Zip file containing one empty file named "hello_world.txt".
String base64Contents =
"UEsDBAoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABwAaGVsbG9fd29ybGQudHh0VVQJAA"
+ "NycehZcnHoWXV4CwABBNE7wRgEui3Tb1BLAQIeAwoAAAAAADNUU0sAAAAAAAAAAAAAAAAPABgAAAAAAAAAAACkg"
+ "QAAAABoZWxsb193b3JsZC50eHRVVAUAA3Jx6Fl1eAsAAQTRO8EYBLot029QSwUGAAAAAAEAAQBVAAAASQAAAAAA";
r
```
<Overlap Ratio: 0.974025974025974>

---

--- 156 --
Question ID: f2f59e7d252719a8869e8b418bd7f91ef37dc5de
Original Code:
```
public class TestUtil {


	public static void main(String[] args) {
		ApplicationContext ctx = new FileSystemXmlApplicationContext(
				new String[] { "src/applicationContext_jndi.xml",
						"src/applicationContext_dao.xml" });
		ResourceDAO dao = (ResourceDAO) ctx.getBean("resourceDAO");
		
		HysResources u = new HysResources();
		u.setName("aaa");
		u.setType(1);
		u.setValue("usdfs");
		
		dao.save(u);
		
		
		
//		List list = new ArrayList();
//		list.add(1);
//		list.add(2);
//		list.add(3);
//		list.add(4);
//		list.add(5);
//		System.out.println(org.apache.commons.lang.StringUtils.join(list.iterator(), ","));
		
		

	}

}
```


Overlapping Code:
```
ublic class TestUtil {
public static void main(String[] args) {
ApplicationContext ctx = new FileSystemXmlApplicationContext(
new String[] { "src/applicationContext_jndi.xml",
"src/applicationContext_dao.xml" });
ResourceDAO dao = (ResourceDAO) ctx.getBean("resourceDAO");

HysResources u = new HysResources();
u.setName("aaa");
u.setType(1);
u.setValue("usdfs");

dao.save(u);



// List list = new ArrayList();
// list.add(1);
// list.add(2);
// list.add(3);
// list.add(4);
// list.add(5);
// System.out.println(org.apache.commons.lang.StringUtils.join(list.iterator(), ","));


}
}
```
<Overlap Ratio: 0.9982935153583617>

---

--- 157 --
Question ID: f6497444b00f21016a5008d62ccd5c337ea9bd72
Original Code:
```
public class E32_OrnamentalGarden3 {
    public static void main(String[] args) throws Exception {
        // All must share a single CountDownLatch object:
        CountDownLatch latch = new CountDownLatch(5);
        ExecutorService exec = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i++)
            exec.execute(new Entrance3(latch, i));
        TimeUnit.SECONDS.sleep(3);
        Entrance3.cancel();
        exec.shutdown();
        latch.await();  // Wait for results
        print("Total: " + Entrance3.getTotalCount());
        print("Sum of Entrances: " + Entrance3.sumEntrances());
    }
}
```


Overlapping Code:
```
n3 {
public static void main(String[] args) throws Exception {
// All must share a single CountDownLatch object:
CountDownLatch latch = new CountDownLatch(5);
ExecutorService exec = Executors.newCachedThreadPool();
for (int i = 0; i < 5; i++)
exec.execute(new Entrance3(latch, i));
TimeUnit.SECONDS.sleep(3);
Entrance3.cancel();
exec.shutdown();
latch.await(); // Wait for results
print("Total: " + Entrance3.getTotalCount());
print("Sum of Entrances: " + Entrance3.sumEntra
```
<Overlap Ratio: 0.915057915057915>

---

--- 158 --
Question ID: 4311e683ea70dba8870aafaae9986dfd03d360ca
Original Code:
```
final class zzco
	implements com.google.android.gms.cast.Cast.ApplicationConnectionResult
{

	public zzco(Status status)
	{
		this(status, ((ApplicationMetadata) (null)), ((String) (null)), ((String) (null)), false);
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:aconst_null     
	//    3    3:aconst_null     
	//    4    4:aconst_null     
	//    5    5:iconst_0        
	//    6    6:invokespecial   #21  <Method void zzco(Status, ApplicationMetadata, String, String, boolean)>
	//    7    9:return          
	}

	public zzco(Status status, ApplicationMetadata applicationmetadata, String s, String s1, boolean flag)
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #25  <Method void Object()>
		zzge = status;
	//    2    4:aload_0         
	//    3    5:aload_1         
	//    4    6:putfield        #27  <Field Status zzge>
		zzvr = applicationmetadata;
	//    5    9:aload_0         
	//    6   10:aload_2         
	//    7   11:putfield        #29  <Field ApplicationMetadata zzvr>
		zzvs = s;
	//    8   14:aload_0         
	//    9   15:aload_3         
	//   10   16:putfield        #31  <Field String zzvs>
		zzvt = s1;
	//   11   19:aload_0         
	//   12   20:aload           4
	//   13   22:putfield        #33  <Field String zzvt>
		zzvu = flag;
	//   14   25:aload_0         
	//   15   26:iload           5
	//   16   28:putfield        #35  <Field boolean zzvu>
	//   17   31:return          
	}

	public final ApplicationMetadata getApplicationMetadata()
	{
		return zzvr;
	//    0    0:aload_0         
	//    1    1:getfield        #29  <Field ApplicationMetadata zzvr>
	//    2    4:areturn         
	}

	public final String getApplicationStatus()
	{
		return zzvs;
	//    0    0:aload_0         
	//    1    1:getfield        #31  <Field String zzvs>
	//    2    4:areturn         
	}

	public final String getSessionId()
	{
		return zzvt;
	//    0    0:aload_0         
	//    1    1:getfield        #33  <Field String zzvt>
	//    2    4:areturn         
	}

	public final Status getStatus()
	{
		return zzge;
	//    0    0:aload_0         
	//    1    1:getfield        #27  <Field Status zzge>
	//    2    4:areturn         
	}

	public final boolean getWasLaunched()
	{
		return zzvu;
	//    0    0:aload_0         
	//    1    1:getfield        #35  <Field boolean zzvu>
	//    2    4:ireturn         
	}

	private final Status zzge;
	private final ApplicationMetadata zzvr;
	private final String zzvs;
	private final String zzvt;
	private final boolean zzvu;
}
```


Overlapping Code:
```
final class zzco
implements com.google.android.gms.cast.Cast.ApplicationConnectionResult
{
public zzco(Status status)
{
this(status, ((ApplicationMetadata) (null)), ((String) (null)), ((String) (null)), false);
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:aconst_null 
// 3 3:aconst_null 
// 4 4:aconst_null 
// 5 5:iconst_0 
// 6 6:invokespecial #21 <Method void zzco(Status, ApplicationMetadata, String, String, boolean)>
// 7 9:return 
}
public zzco(Status status, ApplicationMetadata applicationmetadata, String s, String s1, boolean flag)
{
// 0 0:aload_0 
// 1 1:invokespecial #25 <Method void Object()>
zzge = status;
// 2 4:aload_0 
// 3 5:aload_1 
// 4 6:putfield #27 <Field Status zzge>
zzvr = applicationmetadata;
// 5 9:aload_0 
// 6 10:aload_2 
// 7 11:putfield #29 <Field ApplicationMetadata zzvr>
zzvs = s;
// 8 14:aload_0 
// 9 15:aload_3 
// 10 16:putfield #31 <Field String zzvs>
zzvt = s1;
// 11 19:aload_0 
// 12 20:aload 4
// 13 22:putfield #33 <Field String zzvt>
zzvu = flag;
// 14 25:aload_0 
// 15 26:iload 5
// 16 28:putfield #35 <Field boolean zzvu>
// 17 31:return 
}
public final ApplicationMetadata getApplicationMetadata()
{
return zzvr;
// 0 0:aload_0 
// 1 1:getfield #29 <Field ApplicationMetadata zzvr>
// 2 4:areturn 
}
public final String getApplicationStatus()
{
return zzvs;
// 0 0:aload_0 
// 1 1:getfield #31 <Field String zzvs>
// 2 4:areturn 
}
public final String getSessionId()
{
return zzvt;
// 0 0:aload_0 
// 1 1:getfield #33 <Field String zzvt>
// 2 4:areturn 
}
public final Status getStatus()
{
return zzge;
// 0 0:aload_0 
// 1 1:getfield #27 <Field Status zzge>
// 2 4:areturn 
}
public final boolean getWasLaunched()
{
return zzvu;
// 0 0:aload_0 
// 1 1:getfield #35 <Field boolean zzvu>
// 2 4:ireturn 
}
private final Status zzge;
private final ApplicationMetadata zzvr;
private final String zzvs;
p
```
<Overlap Ratio: 0.9919571045576407>

---

--- 159 --
Question ID: 419c448b0da2fe975d2e69e947a97a967e6da489
Original Code:
```
public class Update extends ConditionSqlBase {

    private Update(SqlType sqlType) {
        super(sqlType);
    }

    public static Update sql() {
        return new Update(SqlType.UPDATE);
    }

    public Update update(Object item) {
        String tableName = getTableName(item);

        SampleMirrorObject sampleMirrorObject = SampleMirrorObject.forObject(item);

        List<String> names = findParamsList(item);

        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);

        StringBuilder setData = new StringBuilder();

        boolean isStart = true;

        for (String paramName : names) {
            Object paramValue = sampleMirrorObject.getValue(paramName);
            if (paramValue != null) {
                if (isStart) {
                    setData.append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);
                    isStart = false;
                } else {
                    setData.append(COMMA).append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);
                }
                this.paramList.add(paramValue);
            }
        }

        if (setData.length() > 0) {
            this.sql.append(SET).append(SPLIT).append(setData).append(SPLIT);
        } else {
            throw new RuntimeException();
        }
        return this;
    }

    public Update update(String tableName, String[] paramsNames, Object[] params) {
        if (paramsNames.length != params.length) {
            throw new RuntimeException();
        }
        this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);
        StringBuilder setData = new StringBuilder();
        boolean isStart = true;
        for (int a = 0; a < params.length; a++) {
            if (params[a] == null) {
                throw new RuntimeException();
            }
            if (isStart) {
                setData.append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);
                isStart = false;
            } else {
                setData.append(COMMA).append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);
            }
            this.paramList.add(params[a]);
        }
        this.sql.append(setData);
        return this;
    }

}
```


Overlapping Code:
```
class Update extends ConditionSqlBase {
private Update(SqlType sqlType) {
super(sqlType);
}
public static Update sql() {
return new Update(SqlType.UPDATE);
}
public Update update(Object item) {
String tableName = getTableName(item);
SampleMirrorObject sampleMirrorObject = SampleMirrorObject.forObject(item);
List<String> names = findParamsList(item);
this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);
StringBuilder setData = new StringBuilder();
boolean isStart = true;
for (String paramName : names) {
Object paramValue = sampleMirrorObject.getValue(paramName);
if (paramValue != null) {
if (isStart) {
setData.append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);
isStart = false;
} else {
setData.append(COMMA).append(TAG).append(paramName).append(TAG).append(EQUAL).append(PLACEHOLDER);
}
this.paramList.add(paramValue);
}
}
if (setData.length() > 0) {
this.sql.append(SET).append(SPLIT).append(setData).append(SPLIT);
} else {
throw new RuntimeException();
}
return this;
}
public Update update(String tableName, String[] paramsNames, Object[] params) {
if (paramsNames.length != params.length) {
throw new RuntimeException();
}
this.sql.append(UPDATE).append(SPLIT).append(TAG).append(tableName).append(TAG).append(SPLIT);
StringBuilder setData = new StringBuilder();
boolean isStart = true;
for (int a = 0; a < params.length; a++) {
if (params[a] == null) {
throw new RuntimeException();
}
if (isStart) {
setData.append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);
isStart = false;
} else {
setData.append(COMMA).append(paramsNames[a]).append(SPLIT).append(EQUAL).append(PLACEHOLDER);
}
this.paramList.add(params[a]);
}
this.sql.append(setData);
return t
```
<Overlap Ratio: 0.9915014164305949>

---

--- 160 --
Question ID: 1455b9b83fb36f437472bc43b5047bb280a2d23c
Original Code:
```
public class StartKafkaCommand extends AbstractBaseAdminCommand implements Command {
  private static final Logger LOGGER = LoggerFactory.getLogger(StartKafkaCommand.class);

  @Option(name = "-port", required = false, metaVar = "<int>", usage = "Port to start Kafka server on.")
  private int _port = KafkaStarterUtils.DEFAULT_KAFKA_PORT;

  @Option(name = "-help", required = false, help = true, aliases = {"-h", "--h", "--help"}, usage = "Print this message.")
  private boolean _help = false;

  @Option(name = "-brokerId", required = false, metaVar = "<int>", usage = "Kafka broker ID.")
  private int _brokerId = KafkaStarterUtils.DEFAULT_BROKER_ID;

  @Option(name = "-zkAddress", required = false, metaVar = "<string>", usage = "Address of Zookeeper.")
  private String _zkAddress = "localhost:2181";
  private StreamDataServerStartable _kafkaStarter;

  @Override
  public boolean getHelp() {
    return _help;
  }

  @Override
  public String getName() {
    return "StartKafka";
  }

  @Override
  public String toString() {
    return "StartKafka -port " + _port + " -brokerId " + _brokerId + " -zkAddress " + _zkAddress;
  }

  @Override
  public String description() {
    return "Start Kafka at the specified port.";
  }

  @Override
  public boolean execute()
      throws IOException {
    try {
      _kafkaStarter = StreamDataProvider.getServerDataStartable(KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, KafkaStarterUtils.getDefaultKafkaConfiguration());
    } catch (Exception e) {
      throw new RuntimeException("Failed to start " + KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, e);
    }
    _kafkaStarter.start();

    LOGGER.info("Start kafka at localhost:" + _port + " in thread " + Thread.currentThread().getName());

    savePID(System.getProperty("java.io.tmpdir") + File.separator + ".kafka.pid");
    return true;
  }
}
```


Overlapping Code:
```
fkaCommand extends AbstractBaseAdminCommand implements Command {
private static final Logger LOGGER = LoggerFactory.getLogger(StartKafkaCommand.class);
@Option(name = "-port", required = false, metaVar = "<int>", usage = "Port to start Kafka server on.")
private int _port = KafkaStarterUtils.DEFAULT_KAFKA_PORT;
@Option(name = "-help", required = false, help = true, aliases = {"-h", "--h", "--help"}, usage = "Print this message.")
private boolean _help = false;
@Option(name = "-brokerId", required = false, metaVar = "<int>", usage = "Kafka broker ID.")
private int _brokerId = KafkaStarterUtils.DEFAULT_BROKER_ID;
@Option(name = "-zkAddress", required = false, metaVar = "<string>", usage = "Address of Zookeeper.")
private String _zkAddress = "localhost:2181";
private StreamDataServerStartable _kafkaStarter;
@Override
public boolean getHelp() {
return _help;
}
@Override
public String getName() {
return "StartKafka";
}
@Override
public String toString() {
return "StartKafka -port " + _port + " -brokerId " + _brokerId + " -zkAddress " + _zkAddress;
}
@Override
public String description() {
return "Start Kafka at the specified port.";
}
@Override
public boolean execute()
throws IOException {
try {
_kafkaStarter = StreamDataProvider.getServerDataStartable(KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, KafkaStarterUtils.getDefaultKafkaConfiguration());
} catch (Exception e) {
throw new RuntimeException("Failed to start " + KafkaStarterUtils.KAFKA_SERVER_STARTABLE_CLASS_NAME, e);
}
_kafkaStarter.start();
LOGGER.info("Start kafka at localhost:" + _port + " in thread " + Thread.currentThread().getName());
savePID(System.getProperty("java.io.tmpdir") + File.separator + ".k
```
<Overlap Ratio: 0.9724454649827784>

---

--- 161 --
Question ID: c93fc34ff40a388c36c6e707f8ce7b61a178a900
Original Code:
```
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public class PhoneLogPlugin
    implements MethodCallHandler, PluginRegistry.RequestPermissionsResultListener {
  private final Registrar registrar;
  private Result pendingResult;

  private PhoneLogPlugin(Registrar registrar) {
    this.registrar = registrar;
  }

  public static void registerWith(Registrar registrar) {
    final MethodChannel channel =
        new MethodChannel(registrar.messenger(), "github.com/jiajiabingcheng/phone_log");
    PhoneLogPlugin phoneLogPlugin = new PhoneLogPlugin(registrar);
    channel.setMethodCallHandler(phoneLogPlugin);
    registrar.addRequestPermissionsResultListener(phoneLogPlugin);
  }

  @Override
  public void onMethodCall(MethodCall call, Result result) {
    if (pendingResult != null) {
      pendingResult.error("multiple_requests", "Cancelled by a second request.", null);
      pendingResult = null;
    }
    pendingResult = result;
    switch (call.method) {
      case "checkPermission":
        pendingResult.success(checkPermission());
        pendingResult = null;
        break;
      case "requestPermission":
        requestPermission();
        break;
      case "getPhoneLogs":
        String startDate = call.argument("startDate");
        String duration = call.argument("duration");
        fetchCallRecords(startDate, duration);
        break;
      default:
        result.notImplemented();
    }
  }

  private void requestPermission() {
    Log.i("PhoneLogPlugin", "Requesting permission : " + Manifest.permission.READ_CALL_LOG);
    String[] perm = {Manifest.permission.READ_CALL_LOG};
    registrar.activity().requestPermissions(perm, 0);
  }

  private String checkPermission() {
    Log.i("PhoneLogPlugin", "Checking permission : " + Manifest.permission.READ_CALL_LOG);
    boolean isGranted =
        PackageManager.PERMISSION_GRANTED
            == registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG);
    if (isGranted) {
      return "granted";
    } else if (registrar
        .activity()
        .shouldShowRequestPermissionRationale(Manifest.permission.READ_CALL_LOG)) {
      return "denied";
    }
    return "deniedAndCannotRequest";
  }

  @Override
  public boolean onRequestPermissionsResult(int requestCode, String[] strings, int[] grantResults) {
    boolean res = false;
    if (requestCode == 0 && grantResults.length > 0) {
      res = grantResults[0] == PackageManager.PERMISSION_GRANTED;
      pendingResult.success(res);
      pendingResult = null;
    }
    return res;
  }

  private static final String[] PROJECTION = {
    CallLog.Calls.CACHED_FORMATTED_NUMBER,
    CallLog.Calls.CACHED_MATCHED_NUMBER,
    CallLog.Calls.TYPE,
    CallLog.Calls.DATE,
    CallLog.Calls.DURATION,
  };

  @TargetApi(Build.VERSION_CODES.M)
  private void fetchCallRecords(String startDate, String duration) {
    if (registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG)
        == PackageManager.PERMISSION_GRANTED) {
      String selectionCondition = null;
      if (startDate != null) {
        selectionCondition = CallLog.Calls.DATE + "> " + startDate;
      }
      if (duration != null) {
        String durationSelection = CallLog.Calls.DURATION + "> " + duration;
        if (selectionCondition != null) {
          selectionCondition = selectionCondition + " AND " + durationSelection;
        } else {
          selectionCondition = durationSelection;
        }
      }
      Cursor cursor =
          registrar
              .context()
              .getContentResolver()
              .query(
                  CallLog.Calls.CONTENT_URI,
                  PROJECTION,
                  selectionCondition,
                  null,
                  CallLog.Calls.DATE + " DESC");

      try {
        ArrayList<HashMap<String, Object>> records = getCallRecordMaps(cursor);
        pendingResult.success(records);
        pendingResult = null;
      } catch (Exception e) {
        Log.e("PhoneLog", "Error on fetching call record" + e);
        pendingResult.error("PhoneLog", e.getMessage(), null);
        pendingResult = null;
      } finally {
        if (cursor != null) {
          cursor.close();
        }
      }

    } else {
      pendingResult.error("PhoneLog", "Permission is not granted", null);
      pendingResult = null;
    }
  }

  /**
   * Builds the list of call record maps from the cursor
   *
   * @param cursor
   * @return the list of maps
   */
  private ArrayList<HashMap<String, Object>> getCallRecordMaps(Cursor cursor) {
    ArrayList<HashMap<String, Object>> records = new ArrayList<>();

    while (cursor != null && cursor.moveToNext()) {
      CallRecord record = new CallRecord();
      record.formattedNumber = cursor.getString(0);
      record.number = cursor.getString(1);
      record.callType = getCallType(cursor.getInt(2));

      Date date = new Date(cursor.getLong(3));
      Calendar cal = Calendar.getInstance();
      cal.setTime(date);
      record.dateYear = cal.get(Calendar.YEAR);
      record.dateMonth = cal.get(Calendar.MONTH);
      record.dateDay = cal.get(Calendar.DAY_OF_MONTH);
      record.dateHour = cal.get(Calendar.HOUR_OF_DAY);
      record.dateMinute = cal.get(Calendar.MINUTE);
      record.dateSecond = cal.get(Calendar.SECOND);
      record.duration = cursor.getLong(4);

      records.add(record.toMap());
    }
    return records;
  }

  private String getCallType(int anInt) {
    switch (anInt) {
      case CallLog.Calls.INCOMING_TYPE:
        return "INCOMING_TYPE";
      case CallLog.Calls.OUTGOING_TYPE:
        return "OUTGOING_TYPE";
      case CallLog.Calls.MISSED_TYPE:
        return "MISSED_TYPE";
      default:
        break;
    }
    return null;
  }
}
```


Overlapping Code:
```
@TargetApi(Build.VERSION_CODES.LOLLIPOP)
public class PhoneLogPlugin
implements MethodCallHandler, PluginRegistry.RequestPermissionsResultListener {
private final Registrar registrar;
private Result pendingResult;
private PhoneLogPlugin(Registrar registrar) {
this.registrar = registrar;
}
public static void registerWith(Registrar registrar) {
final MethodChannel channel =
new MethodChannel(registrar.messenger(), "github.com/jiajiabingcheng/phone_log");
PhoneLogPlugin phoneLogPlugin = new PhoneLogPlugin(registrar);
channel.setMethodCallHandler(phoneLogPlugin);
registrar.addRequestPermissionsResultListener(phoneLogPlugin);
}
@Override
public void onMethodCall(MethodCall call, Result result) {
if (pendingResult != null) {
pendingResult.error("multiple_requests", "Cancelled by a second request.", null);
pendingResult = null;
}
pendingResult = result;
switch (call.method) {
case "checkPermission":
pendingResult.success(checkPermission());
pendingResult = null;
break;
case "requestPermission":
requestPermission();
break;
case "getPhoneLogs":
String startDate = call.argument("startDate");
String duration = call.argument("duration");
fetchCallRecords(startDate, duration);
break;
default:
result.notImplemented();
}
}
private void requestPermission() {
Log.i("PhoneLogPlugin", "Requesting permission : " + Manifest.permission.READ_CALL_LOG);
String[] perm = {Manifest.permission.READ_CALL_LOG};
registrar.activity().requestPermissions(perm, 0);
}
private String checkPermission() {
Log.i("PhoneLogPlugin", "Checking permission : " + Manifest.permission.READ_CALL_LOG);
boolean isGranted =
PackageManager.PERMISSION_GRANTED
== registrar.activity().checkSelfPermission(Manifest.permission.READ_CALL_LOG);
if (isGranted) {
return "granted";
} else if (registrar
.activity()
.shouldShowRequestPermissionRationale(Manifest.permission.READ_CALL_LOG)) {
return "denied";
}
return "deniedAndCannotRequest";
}
@Override
public boolean onRequestPermissionsResult(int requestCode, String[] strings, int[] grantResults) {
boolean res = false;
if (requestCode == 0 && grantResults.length > 0) {
res = grantResults[0] == PackageManager.PERMISSION_GRANTED;
pendingResult.su
```
<Overlap Ratio: 0.9922196796338673>

---

--- 162 --
Question ID: 6a61e7684c8fbe7d634ef3e85c8d9ec1f49a8e5f
Original Code:
```
public class PDFContentProvider implements Closeable {

	private File file;
	private PDDocument document;

	public PDFContentProvider(File file) {
		this.file = file;
		initialize();
	}

	private void initialize() {
		try {
			PDFParser parser = new PDFParser(new RandomAccessFile(file, "r"));
			parser.parse();
			document = new PDDocument(parser.getDocument());
		} catch (FileNotFoundException e) {
			throw new PdfgenException("File was not found.", e);
		} catch (IOException e) {
			throw new PdfgenException("Error while reading or parsing file.", e);
		}
	}

	public List<BufferedImage> getAllImages() {
		List<BufferedImage> images = new ArrayList<>();

		for (PDPage page : document.getPages()) {
			images.addAll(getImagesFromResources(page.getResources()));
		}

		return images;
	}

	private List<BufferedImage> getImagesFromResources(PDResources resources) {
		List<BufferedImage> images = new ArrayList<>();

		try {
			for (COSName xObjectName : resources.getXObjectNames()) {
				PDXObject xObject = resources.getXObject(xObjectName);

				if (xObject instanceof PDFormXObject) {
					images.addAll(getImagesFromResources(((PDFormXObject) xObject).getResources()));
				} else if (xObject instanceof PDImageXObject) {
					images.add(((PDImageXObject) xObject).getImage());
				}
			}
		} catch (IOException e) {
		}

		return images;
	}

	public String getText() {
		return getText(1, document.getNumberOfPages());
	}

	public String getText(int fromPage, int toPage) {
		try {
			PDFTextStripper textStripper = new PDFTextStripper();
			textStripper.setStartPage(fromPage);
			textStripper.setEndPage(toPage);

			return textStripper.getText(document);
		} catch (IOException e) {
			throw new PdfgenException("Error while reading file.", e);
		}
	}

	public int getPagesCount() {
		return document.getNumberOfPages();
	}

	@Override
	public void close() {
		try {
			document.close();
		} catch (IOException e) {
			throw new PdfgenException("Failed to close the file.", e);
		}
	}
}
```


Overlapping Code:
```
ontentProvider implements Closeable {
private File file;
private PDDocument document;
public PDFContentProvider(File file) {
this.file = file;
initialize();
}
private void initialize() {
try {
PDFParser parser = new PDFParser(new RandomAccessFile(file, "r"));
parser.parse();
document = new PDDocument(parser.getDocument());
} catch (FileNotFoundException e) {
throw new PdfgenException("File was not found.", e);
} catch (IOException e) {
throw new PdfgenException("Error while reading or parsing file.", e);
}
}
public List<BufferedImage> getAllImages() {
List<BufferedImage> images = new ArrayList<>();
for (PDPage page : document.getPages()) {
images.addAll(getImagesFromResources(page.getResources()));
}
return images;
}
private List<BufferedImage> getImagesFromResources(PDResources resources) {
List<BufferedImage> images = new ArrayList<>();
try {
for (COSName xObjectName : resources.getXObjectNames()) {
PDXObject xObject = resources.getXObject(xObjectName);
if (xObject instanceof PDFormXObject) {
images.addAll(getImagesFromResources(((PDFormXObject) xObject).getResources()));
} else if (xObject instanceof PDImageXObject) {
images.add(((PDImageXObject) xObject).getImage());
}
}
} catch (IOException e) {
}
return images;
}
public String getText() {
return getText(1, document.getNumberOfPages());
}
public String getText(int fromPage, int toPage) {
try {
PDFTextStripper textStripper = new PDFTextStripper();
textStripper.setStartPage(fromPage);
textStripper.setEndPage(toPage);
return textStripper.getText(document);
} catch (IOException e) {
throw new PdfgenException("Error while reading file.", e);
}
}
public int getPagesCount() {
return document.getNumberOfPages();
}
@Override
public void close() {
try {
document.close();
} catch (IOException e) {
throw new PdfgenException("Failed to 
```
<Overlap Ratio: 0.9762547220723151>

---

--- 163 --
Question ID: 9f3940b2af4930e3b7d82166da0c6956a27222df
Original Code:
```
public class Fun extends Function{
	public Fun(final ByteBuffer b){
		super(b);
	}

	public Fun(final Descriptor<?> a, final Descriptor<?> b){
		super(OPC.OpcFun, a, b);
	}

	public Fun(final Descriptor<?>[] args){
		super(OPC.OpcFun, args);
	}

	@Override
	public final StringBuilder decompile(final int prec, final StringBuilder pout, final int mode) {
		if(prec < Descriptor.P_STMT) pout.append('(');
		pout.append("Fun ");
		final Descriptor<?> ptr = this.getDescriptor(0);
		if(ptr.dtype() == DTYPE.T) pout.append(ptr.toString());
		else ptr.decompile(Descriptor.P_SUBS, pout, mode & ~Descriptor.DECO_X);
		this.addArguments(2, " (", ") ", pout, mode);
		Function.addCompoundStatement(1, this, 1, pout, mode);
		if(prec < Descriptor.P_STMT) pout.append(')');
		return pout;
	}

	@Override
	public final Descriptor<?> evaluate() {
		try{
			final DATA<?>[] args = Descriptor.getDATAs(this.getArguments());
			return BINARY.getCommon(args).add(args[0].toDescriptor(), args[1].toDescriptor());
		}catch(final MdsException e){
			System.err.println(e.getMessage());
			return Missing.NEW;
		}
	}
}
```


Overlapping Code:
```
Function{
public Fun(final ByteBuffer b){
super(b);
}
public Fun(final Descriptor<?> a, final Descriptor<?> b){
super(OPC.OpcFun, a, b);
}
public Fun(final Descriptor<?>[] args){
super(OPC.OpcFun, args);
}
@Override
public final StringBuilder decompile(final int prec, final StringBuilder pout, final int mode) {
if(prec < Descriptor.P_STMT) pout.append('(');
pout.append("Fun ");
final Descriptor<?> ptr = this.getDescriptor(0);
if(ptr.dtype() == DTYPE.T) pout.append(ptr.toString());
else ptr.decompile(Descriptor.P_SUBS, pout, mode & ~Descriptor.DECO_X);
this.addArguments(2, " (", ") ", pout, mode);
Function.addCompoundStatement(1, this, 1, pout, mode);
if(prec < Descriptor.P_STMT) pout.append(')');
return pout;
}
@Override
public final Descriptor<?> evaluate() {
try{
final DATA<?>[] args = Descriptor.getDATAs(this.getArguments());
return BINARY.getCommon(args).add(args[0].toDescriptor(), args[1].toDescriptor());
}catch(final MdsException e){
System.err.println(e.getMessage());
return Mis
```
<Overlap Ratio: 0.9615384615384616>

---

--- 164 --
Question ID: 1ff0d748f517c0b4241d4cc57a6f3b7a957ddae7
Original Code:
```
static class GhostViewApi21$Creator
	implements GhostViewImpl.Creator
{

	public GhostViewImpl addGhost(View view, ViewGroup viewgroup, Matrix matrix)
	{
		GhostViewApi21.access$000();
	//    0    0:invokestatic    #23  <Method void GhostViewApi21.access$000()>
		if(GhostViewApi21.access$100() != null)
	//*   1    3:invokestatic    #27  <Method Method GhostViewApi21.access$100()>
	//*   2    6:ifnull          59
		{
			try
			{
				view = ((View) (new GhostViewApi21((View)GhostViewApi21.access$100().invoke(((Object) (null)), new Object[] {
					view, viewgroup, matrix
				}), ((GhostViewApi21._cls1) (null)))));
	//    3    9:new             #8   <Class GhostViewApi21>
	//    4   12:dup             
	//    5   13:invokestatic    #27  <Method Method GhostViewApi21.access$100()>
	//    6   16:aconst_null     
	//    7   17:iconst_3        
	//    8   18:anewarray       Object[]
	//    9   21:dup             
	//   10   22:iconst_0        
	//   11   23:aload_1         
	//   12   24:aastore         
	//   13   25:dup             
	//   14   26:iconst_1        
	//   15   27:aload_2         
	//   16   28:aastore         
	//   17   29:dup             
	//   18   30:iconst_2        
	//   19   31:aload_3         
	//   20   32:aastore         
	//   21   33:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>
	//   22   36:checkcast       #35  <Class View>
	//   23   39:aconst_null     
	//   24   40:invokespecial   #38  <Method void GhostViewApi21(View, GhostViewApi21$1)>
	//   25   43:astore_1        
			}
	//*  26   44:aload_1         
	//*  27   45:areturn         
	//*  28   46:astore_1        
	//*  29   47:new             #40  <Class RuntimeException>
	//*  30   50:dup             
	//*  31   51:aload_1         
	//*  32   52:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>
	//*  33   55:invokespecial   #47  <Method void RuntimeException(Throwable)>
	//*  34   58:athrow          
	//*  35   59:aconst_null     
	//*  36   60:areturn         
			// Misplaced declaration of an exception variable
			catch(View view)
	//*  37   61:astore_1        
			{
				return null;
	//   38   62:aconst_null     
	//   39   63:areturn         
			}
			// Misplaced declaration of an exception variable
			catch(View view)
			{
				throw new RuntimeException(((InvocationTargetException) (view)).getCause());
			}
			return ((GhostViewImpl) (view));
		} else
		{
			return null;
		}
	}

	public void removeGhost(View view)
	{
		GhostViewApi21.access$300();
	//    0    0:invokestatic    #52  <Method void GhostViewApi21.access$300()>
		if(GhostViewApi21.access$400() != null)
	//*   1    3:invokestatic    #55  <Method Method GhostViewApi21.access$400()>
	//*   2    6:ifnull          39
			try
			{
				GhostViewApi21.access$400().invoke(((Object) (null)), new Object[] {
					view
				});
	//    3    9:invokestatic    #55  <Method Method GhostViewApi21.access$400()>
	//    4   12:aconst_null     
	//    5   13:iconst_1        
	//    6   14:anewarray       Object[]
	//    7   17:dup             
	//    8   18:iconst_0        
	//    9   19:aload_1         
	//   10   20:aastore         
	//   11   21:invokevirtual   #33  <Method Object Method.invoke(Object, Object[])>
	//   12   24:pop             
				return;
	//   13   25:return          
			}
	//*  14   26:astore_1        
	//*  15   27:new             #40  <Class RuntimeException>
	//*  16   30:dup             
	//*  17   31:aload_1         
	//*  18   32:invokevirtual   #44  <Method Throwable InvocationTargetException.getCause()>
	//*  19   35:invokespecial   #47  <Method void RuntimeException(Throwable)>
	//*  20   38:athrow          
	//*  21   39:return          
			// Misplaced declaration of an exception variable
			catch(View view)
	//*  22   40:astore_1        
			{
				return;
	//   23   41:return          
			}
			// Misplaced declaration of an exception variable
			catch(View view)
			{
				throw new RuntimeException(((InvocationTargetException) (view)).getCause());
			}
		else
			return;
	}

	GhostViewApi21$Creator()
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #13  <Method void Object()>
	//    2    4:return          
	}
}
```


Overlapping Code:
```
or
implements GhostViewImpl.Creator
{
public GhostViewImpl addGhost(View view, ViewGroup viewgroup, Matrix matrix)
{
GhostViewApi21.access$000();
// 0 0:invokestatic #23 <Method void GhostViewApi21.access$000()>
if(GhostViewApi21.access$100() != null)
//* 1 3:invokestatic #27 <Method Method GhostViewApi21.access$100()>
//* 2 6:ifnull 59
{
try
{
view = ((View) (new GhostViewApi21((View)GhostViewApi21.access$100().invoke(((Object) (null)), new Object[] {
view, viewgroup, matrix
}), ((GhostViewApi21._cls1) (null)))));
// 3 9:new #8 <Class GhostViewApi21>
// 4 12:dup 
// 5 13:invokestatic #27 <Method Method GhostViewApi21.access$100()>
// 6 16:aconst_null 
// 7 17:iconst_3 
// 8 18:anewarray Object[]
// 9 21:dup 
// 10 22:iconst_0 
// 11 23:aload_1 
// 12 24:aastore 
// 13 25:dup 
// 14 26:iconst_1 
// 15 27:aload_2 
// 16 28:aastore 
// 17 29:dup 
// 18 30:iconst_2 
// 19 31:aload_3 
// 20 32:aastore 
// 21 33:invokevirtual #33 <Method Object Method.invoke(Object, Object[])>
// 22 36:checkcast #35 <Class View>
// 23 39:aconst_null 
// 24 40:invokespecial #38 <Method void GhostViewApi21(View, GhostViewApi21$1)>
// 25 43:astore_1 
}
//* 26 44:aload_1 
//* 27 45:areturn 
//* 28 46:astore_1 
//* 29 47:new #40 <Class RuntimeException>
//* 30 50:dup 
//* 31 51:aload_1 
//* 32 52:invokevirtual #44 <Method Throwable InvocationTargetException.getCause()>
//* 33 55:invokespecial #47 <Method void RuntimeException(Throwable)>
//* 34 58:athrow 
//* 35 59:aconst_null 
//* 36 60:areturn 
// Misplaced declaration of an exception variable
catch(View view)
//* 37 61:astore_1 
{
return null;
// 38 62:aconst_null 
// 39 63:areturn 
}
// Misplaced declaration of an exception variable
catch(View view)
{
throw new RuntimeException(((InvocationTargetException) (view)).getCause());
}
return ((GhostViewImpl) (view));
} else
{
return null;
}
}
public void removeGhost(View view)
{
Gh
```
<Overlap Ratio: 0.9807492195629552>

---

--- 165 --
Question ID: 69c7e5570b21ad0e49f243eba08a1731cf7c11c3
Original Code:
```
public class VectorTest
{
	public static void main(String[] args)
	{
		Vector vector = new Vector();
		
		vector.add("hello");
		vector.add("world");
		vector.add("hello world");
		
		for(int i = 0; i < vector.size(); i++)
		{
			System.out.println(vector.get(i));
		}
	}
}
```


Overlapping Code:
```
lass VectorTest
{
public static void main(String[] args)
{
Vector vector = new Vector();

vector.add("hello");
vector.add("world");
vector.add("hello world");

for(int i = 0; i < vector.size(); i++)
{
System.out.pri
```
<Overlap Ratio: 0.8634538152610441>

---

--- 166 --
Question ID: 96cdb480e98e0ea4fe84257bd25c036c94c3a4a4
Original Code:
```
@Service
public class DiffService {

    public LinkedList<diff_match_patch.Diff> getDiff(Context context, Options options) {
        diff_match_patch diffMatchPatch = new diff_match_patch();

        diffMatchPatch.Diff_Timeout = options.getTimeout();

        LinkedList<diff_match_patch.Diff> diffLinkedList = diffMatchPatch.diff_main(context.getOriginal(), context.getRevised(), options.isCheckLines());

        if (options.getCleanupSemantic()) {
            diffMatchPatch.diff_cleanupSemantic(diffLinkedList);
        }

        return diffLinkedList;
    }
    public String toPrettyHtml(LinkedList<diff_match_patch.Diff> diffs) {
        StringBuffer buffer = new StringBuffer();
        diffs.forEach(diff -> {
            switch (diff.operation) {
                case EQUAL:
                    buffer.append(String.format("<span>%s</span>", diff.text));
                    break;
                case INSERT:
                    buffer.append(String.format("<ins>%s</ins>", diff.text));
                    break;
                case  DELETE:
                    buffer.append(String.format("<del>%s</del>", diff.text));
                    break;
            }
        });

        return buffer.toString();
    }

}
```


Overlapping Code:
```
ss DiffService {
public LinkedList<diff_match_patch.Diff> getDiff(Context context, Options options) {
diff_match_patch diffMatchPatch = new diff_match_patch();
diffMatchPatch.Diff_Timeout = options.getTimeout();
LinkedList<diff_match_patch.Diff> diffLinkedList = diffMatchPatch.diff_main(context.getOriginal(), context.getRevised(), options.isCheckLines());
if (options.getCleanupSemantic()) {
diffMatchPatch.diff_cleanupSemantic(diffLinkedList);
}
return diffLinkedList;
}
public String toPrettyHtml(LinkedList<diff_match_patch.Diff> diffs) {
StringBuffer buffer = new StringBuffer();
diffs.forEach(diff -> {
switch (diff.operation) {
case EQUAL:
buffer.append(String.format("<span>%s</span>", diff.text));
break;
case INSERT:
buffer.append(String.format("<ins>%s</ins>", diff.text));
break;
case DELETE:
buffer.append(String.format("<del>%s</del>", diff.text));
break;
}
});
return buffer.toString(
```
<Overlap Ratio: 0.972972972972973>

---

--- 167 --
Question ID: 51ecebb0d5a4a026301ab714acd28a68913018ad
Original Code:
```
public class RunExamples {
    /*
     * Method which runs a static method in the example class. Assumes that
     * method accepts a single parameter of type PrintStream, and saves
     * contents that are written to this stream under the method's name in a
     * JSONObject (i.e. a HashMap)
     */

    /// @export "run-method"
    public static void runMethod(Method method, PrintStream out, ByteArrayOutputStream byteStream, JSONObject outputStreams) throws Exception {
        System.out.println("Running method " + method.getName());
        method.invoke(null, out);

        out.flush();
        outputStreams.put(method.getName(), byteStream.toString());
        byteStream.reset();
    }

    /// @export "class-names"
    public static String[] classNames() {
        return new String[] {
            "com.opengamma.analytics.example.coupledfokkerplank.CoupledFokkerPlankExample",
            "com.opengamma.analytics.example.curveconstruction.AnnuityExample",
            "com.opengamma.analytics.example.curveconstruction.CashExample",
            "com.opengamma.analytics.example.curveconstruction.CurveConstructionExample",
            "com.opengamma.analytics.example.curveconstruction.CurveExample",
            "com.opengamma.analytics.example.curveconstruction.FunctionExample",
            "com.opengamma.analytics.example.curveconstruction.MatrixExample",
            "com.opengamma.analytics.example.curveconstruction.YieldCurveExample",
            "com.opengamma.analytics.example.sabrextrapolation.SabrExtrapolationExample",
            "com.opengamma.analytics.example.timeseries.TimeSeriesExample"
        };
    }
    /// @end

    public static void runExamples() throws Exception {
        String[] classNames = classNames();
        String outputFilename = "dexy--example-output.json";
        String fieldsFilename = "dexy--example-fields.json";

        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        PrintStream out = new PrintStream(byteStream);
        JSONObject outputStreams = new JSONObject();
        JSONObject fieldInfo = new JSONObject();

        /// @export "find-methods-to-run"
        for (int k = 0; k < classNames.length; k++) {
            String className = classNames[k];
            Class thisClass = Class.forName(className);

            JSONObject classOutputStreams = new JSONObject();
            Method[] methods = thisClass.getMethods();
            for (int i = 0; i < methods.length; i++) {
                Method method = methods[i];
                Class[] params = method.getParameterTypes();
                if (params.length == 1 && params[0] == PrintStream.class) {
                    runMethod(method, out, byteStream, classOutputStreams);
                }
            }
            outputStreams.put(className, classOutputStreams);
            /// @end

            JSONObject classFieldInfo = new JSONObject();
            Field[] fields = thisClass.getDeclaredFields();
            for (int i = 0; i < fields.length; i++) {
                Field field = fields[i];

                try {
                    Object value = field.get(null);

                    // Handle any special data types that cause problems for the JSON conversion...
                    if (field.getType().equals(double[].class)) {
                        double[] values = (double[])value;
                        JSONArray array = new JSONArray();
                        for (int j = 0; j < values.length; j++) {
                            array.add(values[j]);
                        }
                        classFieldInfo.put(field.getName(), array);
                    } else {
                        // default case

                        // check class, if not a directly supported type, then explicitly call toString() or else we get invalid JSON
                        Class fieldClass = field.getType();

                        // TODO Finish this, need to recognize all classes that should not be converted to strings.
                        // The values can be any of these types: Boolean, JSONArray, JSONObject, Number, String, or the JSONObject.NULL object.
                        if (fieldClass.equals(double.class)) {
                            // ok
                        } else if (fieldClass.equals(int.class)) {
                            // ok
                        } else if (fieldClass.equals(long.class)) {
                            // ok
                        } else if (fieldClass.equals(boolean.class)) {
                            // ok
                        } else if (java.lang.Number.class.isAssignableFrom(fieldClass)) {
                            // ok
                        } else {
                            value = value.toString();
                        }
                        classFieldInfo.put(field.getName(), value);
                    }
                } catch (java.lang.IllegalAccessException e) {
                    // Skip any fields that aren't accessible.
                    System.out.println("Not allowed to see value of " + field.getName() + " in " + className);
                }
            }
            fieldInfo.put(className, classFieldInfo);
        }

        File f;
        FileWriter file;

        f = new File(outputFilename);
        file = new FileWriter(f);
        outputStreams.writeJSONString(file);
        file.close();

        f = new File(fieldsFilename);
        file = new FileWriter(f);
        fieldInfo.writeJSONString(file);
        file.close();
    }

    public static void main(String[] args) throws Exception {
        runExamples();
    }
}
```


Overlapping Code:
```
 {
/*
* Method which runs a static method in the example class. Assumes that
* method accepts a single parameter of type PrintStream, and saves
* contents that are written to this stream under the method's name in a
* JSONObject (i.e. a HashMap)
*/
/// @export "run-method"
public static void runMethod(Method method, PrintStream out, ByteArrayOutputStream byteStream, JSONObject outputStreams) throws Exception {
System.out.println("Running method " + method.getName());
method.invoke(null, out);
out.flush();
outputStreams.put(method.getName(), byteStream.toString());
byteStream.reset();
}
/// @export "class-names"
public static String[] classNames() {
return new String[] {
"com.opengamma.analytics.example.coupledfokkerplank.CoupledFokkerPlankExample",
"com.opengamma.analytics.example.curveconstruction.AnnuityExample",
"com.opengamma.analytics.example.curveconstruction.CashExample",
"com.opengamma.analytics.example.curveconstruction.CurveConstructionExample",
"com.opengamma.analytics.example.curveconstruction.CurveExample",
"com.opengamma.analytics.example.curveconstruction.FunctionExample",
"com.opengamma.analytics.example.curveconstruction.MatrixExample",
"com.opengamma.analytics.example.curveconstruction.YieldCurveExample",
"com.opengamma.analytics.example.sabrextrapolation.SabrExtrapolationExample",
"com.opengamma.analytics.example.timeseries.TimeSeriesExample"
};
}
/// @end
public static void runExamples() throws Exception {
String[] classNames = classNames();
String outputFilename = "dexy--example-output.json";
String fieldsFilename = "dexy--example-fields.json";
ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
PrintStream out = new PrintStream(byteStream);
JSONObject outputStreams = new JSONObject();
JSONObject fieldInfo = new JSONObject();
/// @export "find-methods-to-run"
for (int k = 0; k < classNames.length; k++) {
String className = classNames[k];
Class thisClass = Class.forName(className);
JSONObject classOutputStreams = new JSONObject();
Method[] methods = thisClass.getMethods();
for (int i = 0; i < methods.length; i++) {
```
<Overlap Ratio: 0.9886039886039886>

---

--- 168 --
Question ID: 140cb7aeb3f796eeca7cdb3aa0b0ae777dd32e05
Original Code:
```
public class TestQueryHelper
{
  public static Logger LOG = new Logger(TestQueryHelper.class);
  private final QueryResourceTestClient queryClient;
  private final ObjectMapper jsonMapper;
  private final String broker;

  @Inject
  TestQueryHelper(
      ObjectMapper jsonMapper,
      QueryResourceTestClient queryClient,
      IntegrationTestingConfig config
  )
  {
    this.jsonMapper = jsonMapper;
    this.queryClient = queryClient;
    this.broker = config.getBrokerUrl();
  }

  public void testQueriesFromFile(String filePath, int timesToRun) throws Exception
  {
    testQueriesFromFile(getBrokerURL(), filePath, timesToRun);
  }

  public void testQueriesFromFile(String url, String filePath, int timesToRun) throws Exception
  {
    LOG.info("Starting query tests for [%s]", filePath);
    List<QueryWithResults> queries =
        jsonMapper.readValue(
            TestQueryHelper.class.getResourceAsStream(filePath),
            new TypeReference<List<QueryWithResults>>()
            {
            }
        );
    testQueries(url, queries, timesToRun);
  }

  public void testQueriesFromString(String str, int timesToRun) throws Exception
  {
    testQueriesFromString(getBrokerURL(), str, timesToRun);
  }

  public void testQueriesFromString(String url, String str, int timesToRun) throws Exception
  {
    LOG.info("Starting query tests using\n%s", str);
    List<QueryWithResults> queries =
        jsonMapper.readValue(
            str,
            new TypeReference<List<QueryWithResults>>()
            {
            }
        );
    testQueries(url, queries, timesToRun);
  }

  private void testQueries(String url, List<QueryWithResults> queries, int timesToRun) throws Exception
  {
    for (int i = 0; i < timesToRun; i++) {
      LOG.info("Starting Iteration %d", i);

      boolean failed = false;
      for (QueryWithResults queryWithResult : queries) {
        LOG.info("Running Query %s", queryWithResult.getQuery().getType());
        List<Map<String, Object>> result = queryClient.query(url, queryWithResult.getQuery());
        if (!QueryResultVerifier.compareResults(result, queryWithResult.getExpectedResults())) {
          LOG.error(
              "Failed while executing query %s \n expectedResults: %s \n actualResults : %s",
              queryWithResult.getQuery(),
              jsonMapper.writeValueAsString(queryWithResult.getExpectedResults()),
              jsonMapper.writeValueAsString(result)
          );
          failed = true;
        } else {
          LOG.info("Results Verified for Query %s", queryWithResult.getQuery().getType());
        }
      }

      if (failed) {
        throw new ISE("one or more queries failed");
      }
    }
  }

  private String getBrokerURL()
  {
    return StringUtils.format("%s/druid/v2?pretty", broker);
  }

  @SuppressWarnings("unchecked")
  public int countRows(String dataSource, String interval)
  {
    TimeseriesQuery query = Druids.newTimeseriesQueryBuilder()
                                  .dataSource(dataSource)
                                  .aggregators(
                                      ImmutableList.<AggregatorFactory>of(
                                          new LongSumAggregatorFactory("rows", "count")
                                      )
                                  )
                                  .granularity(Granularities.ALL)
                                  .intervals(interval)
                                  .build();

    List<Map<String, Object>> results = queryClient.query(getBrokerURL(), query);
    if (results.isEmpty()) {
      return 0;
    } else {
      Map<String, Object> map = (Map<String, Object>) results.get(0).get("result");

      return (Integer) map.get("rows");
    }
  }
}
```


Overlapping Code:
```
lic class TestQueryHelper
{
public static Logger LOG = new Logger(TestQueryHelper.class);
private final QueryResourceTestClient queryClient;
private final ObjectMapper jsonMapper;
private final String broker;
@Inject
TestQueryHelper(
ObjectMapper jsonMapper,
QueryResourceTestClient queryClient,
IntegrationTestingConfig config
)
{
this.jsonMapper = jsonMapper;
this.queryClient = queryClient;
this.broker = config.getBrokerUrl();
}
public void testQueriesFromFile(String filePath, int timesToRun) throws Exception
{
testQueriesFromFile(getBrokerURL(), filePath, timesToRun);
}
public void testQueriesFromFile(String url, String filePath, int timesToRun) throws Exception
{
LOG.info("Starting query tests for [%s]", filePath);
List<QueryWithResults> queries =
jsonMapper.readValue(
TestQueryHelper.class.getResourceAsStream(filePath),
new TypeReference<List<QueryWithResults>>()
{
}
);
testQueries(url, queries, timesToRun);
}
public void testQueriesFromString(String str, int timesToRun) throws Exception
{
testQueriesFromString(getBrokerURL(), str, timesToRun);
}
public void testQueriesFromString(String url, String str, int timesToRun) throws Exception
{
LOG.info("Starting query tests using\n%s", str);
List<QueryWithResults> queries =
jsonMapper.readValue(
str,
new TypeReference<List<QueryWithResults>>()
{
}
);
testQueries(url, queries, timesToRun);
}
private void testQueries(String url, List<QueryWithResults> queries, int timesToRun) throws Exception
{
for (int i = 0; i < timesToRun; i++) {
LOG.info("Starting Iteration %d", i);
boolean failed = false;
for (QueryWithResults queryWithResult : queries) {
LOG.info("Running Query %s", queryWithResult.getQuery().getType());
List<Map<String, Object>> result = queryClient.query(url, queryWithResult.getQuery());
if (!QueryResultVerifier.compareResults(result, queryWithResult.getExpectedResults())) {
LOG.error(
"Failed while executing query %s \n expectedResults: %s \n actualResults : %s",
queryWithResult.getQuery(),
jsonMapper.writeValueAsString(queryWithResult.getExpectedResults()),
jsonMapper.writeValueAsString(result)
);
failed = true;
} else 
```
<Overlap Ratio: 0.9981087470449173>

---

--- 169 --
Question ID: 1f693c000ac2d52bbc1d7402ececd725273ffef9
Original Code:
```
public class TestBench {

  byte[] challenge = new byte[0];
  private SaslServer saslServer;
  private SaslClient saslClient;

  public static void main(String[] args) throws Exception {
    new TestBench().run();
  }

  private void run() throws Exception {
    System.setProperty("java.security.krb5.conf", "/etc/krb5.conf");

    LoginParams serverParam = new LoginParams();
    serverParam.put(LoginParam.PRINCIPAL, "om/om@ATHENA.MIT.EDU");
    serverParam.put(LoginParam.KEYTAB, "/tmp/om.keytab");

    LoginContext serverContext =
        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,
            (Subject) null, null,
            new LoginConfiguration(serverParam));
    serverContext.login();
    saslServer = Subject.doAs(serverContext.getSubject(),
        (PrivilegedExceptionAction<SaslServer>) this::getSaslServer);

    LoginParams clientParams = new LoginParams();
    clientParams.put(LoginParam.PRINCIPAL, "admin/admin@ATHENA.MIT.EDU");
    clientParams.put(LoginParam.KEYTAB, "/tmp/admin.keytab");

    LoginContext clientContext =
        new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,
            (Subject) null, null,
            new LoginConfiguration(clientParams));
    clientContext.login();

    saslClient = Subject.doAs(clientContext.getSubject(),
        (PrivilegedExceptionAction<SaslClient>) () -> getSaslClient());

    Subject.doAs(clientContext.getSubject(),
        (PrivilegedExceptionAction<Void>) () -> {
          challenge =
              saslClient.evaluateChallenge(challenge);
          return null;
        });
    challenge = saslServer.evaluateResponse(challenge);
    System.out.println(saslServer.isComplete());
    challenge = saslClient.evaluateChallenge(challenge);
    challenge = saslServer.evaluateResponse(challenge);
    System.out.println(saslServer.isComplete());
    System.out.println(saslServer.getAuthorizationID());
    return;

  }

  private SaslClient getSaslClient() throws SaslException {
    Enumeration<SaslClientFactory> saslClientFactories =
        Sasl.getSaslClientFactories();
    while (saslClientFactories.hasMoreElements()) {
      SaslClient saslClient = saslClientFactories.nextElement()
          .createSaslClient(new String[] {"GSSAPI"}, "",
              "om", "om",
              new HashMap<String, String>(), null);
      if (saslClient != null) {
        return saslClient;
      }
    }
    throw new IllegalArgumentException(
        "Can't found SaslClient implementation compatible with GSSAPI");
  }

  private SaslServer getSaslServer() throws SaslException {
    Enumeration<SaslServerFactory> saslServerFactories =
        Sasl.getSaslServerFactories();
    while (saslServerFactories.hasMoreElements()) {
      SaslServer saslServer = saslServerFactories.nextElement()
          .createSaslServer("GSSAPI", "om", "om",
              new HashMap<String, String>(),
              new SaslGssCallbackHandler());
      if (saslServer != null) {
        return saslServer;
      }
    }
    throw new IllegalArgumentException(
        "Can't found SaslServer implementation compatible with GSSAPI");
  }
}
```


Overlapping Code:
```
byte[] challenge = new byte[0];
private SaslServer saslServer;
private SaslClient saslClient;
public static void main(String[] args) throws Exception {
new TestBench().run();
}
private void run() throws Exception {
System.setProperty("java.security.krb5.conf", "/etc/krb5.conf");
LoginParams serverParam = new LoginParams();
serverParam.put(LoginParam.PRINCIPAL, "om/om@ATHENA.MIT.EDU");
serverParam.put(LoginParam.KEYTAB, "/tmp/om.keytab");
LoginContext serverContext =
new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,
(Subject) null, null,
new LoginConfiguration(serverParam));
serverContext.login();
saslServer = Subject.doAs(serverContext.getSubject(),
(PrivilegedExceptionAction<SaslServer>) this::getSaslServer);
LoginParams clientParams = new LoginParams();
clientParams.put(LoginParam.PRINCIPAL, "admin/admin@ATHENA.MIT.EDU");
clientParams.put(LoginParam.KEYTAB, "/tmp/admin.keytab");
LoginContext clientContext =
new LoginContext(LoginConfiguration.KERBEROS_CONFIG_NAME,
(Subject) null, null,
new LoginConfiguration(clientParams));
clientContext.login();
saslClient = Subject.doAs(clientContext.getSubject(),
(PrivilegedExceptionAction<SaslClient>) () -> getSaslClient());
Subject.doAs(clientContext.getSubject(),
(PrivilegedExceptionAction<Void>) () -> {
challenge =
saslClient.evaluateChallenge(challenge);
return null;
});
challenge = saslServer.evaluateResponse(challenge);
System.out.println(saslServer.isComplete());
challenge = saslClient.evaluateChallenge(challenge);
challenge = saslServer.evaluateResponse(challenge);
System.out.println(saslServer.isComplete());
System.out.println(saslServer.getAuthorizationID());
return;
}
private SaslClient getSaslClient() throws SaslException {
Enumeration<SaslClientFactory> saslClientFactories =
Sasl.getSaslClientFactories();
while (saslClientFactories.hasMoreElements()) {
SaslClient saslClient = saslClientFactories.nextElement()
.createSaslClient(new String[] {"GSSAPI"}, "",
"om", "om",
new HashMap<String, String>(), null);
if (saslClient != null) {
return saslClient;
}
}
throw new IllegalArgumentException(
"Can't found SaslClient implemen
```
<Overlap Ratio: 0.9805375347544022>

---

--- 170 --
Question ID: fae383f4fbd6db1d747fff4daf37605b0c0898a4
Original Code:
```
public class PurgeAction extends SharedAction {
	private static final Logger logger = LoggerFactory.getLogger(PurgeAction.class);

	@SuppressWarnings("static-access")
	public PurgeAction() {
		createOption("purge",
                "Warning: Rollback all current deltas and reset index accordingly. DEPRECATED: use purge");
	}

    public void invoke(FacadeFactory factory, ProjectAndEnv projectAndEnv, Collection<Parameter> unused,
			Collection<Parameter> artifacts, String... args) throws CfnAssistException, MissingArgumentException, InterruptedException {
		logger.info("Invoking rollback for " + projectAndEnv);
		AwsFacade aws = factory.createFacade();
		aws.rollbackTemplatesByIndexTag(projectAndEnv);
	}

	@Override
	public void validate(ProjectAndEnv projectAndEnv, Collection<Parameter> cfnParams,
			Collection<Parameter> artifacts, String... argumentForAction)
			throws CommandLineException {
		guardForProjectAndEnv(projectAndEnv);
		guardForNoBuildNumber(projectAndEnv);	
		guardForNoArtifacts(artifacts);
	}

	@Override
	public boolean usesProject() {
		return true;
	}

	@Override
	public boolean usesComment() {
		return false;
	}

	@Override
	public boolean usesSNS() {
		return true;
	}

}
```


Overlapping Code:
```
Action extends SharedAction {
private static final Logger logger = LoggerFactory.getLogger(PurgeAction.class);
@SuppressWarnings("static-access")
public PurgeAction() {
createOption("purge",
"Warning: Rollback all current deltas and reset index accordingly. DEPRECATED: use purge");
}
public void invoke(FacadeFactory factory, ProjectAndEnv projectAndEnv, Collection<Parameter> unused,
Collection<Parameter> artifacts, String... args) throws CfnAssistException, MissingArgumentException, InterruptedException {
logger.info("Invoking rollback for " + projectAndEnv);
AwsFacade aws = factory.createFacade();
aws.rollbackTemplatesByIndexTag(projectAndEnv);
}
@Override
public void validate(ProjectAndEnv projectAndEnv, Collection<Parameter> cfnParams,
Collection<Parameter> artifacts, String... argumentForAction)
throws CommandLineException {
guardForProjectAndEnv(projectAndEnv);
guardForNoBuildNumber(projectAndEnv); 
guardForNoArtifacts(artifacts);
}
@Override
public boolean usesProject() {
return true;
}
@Override
public boolean usesComment() {
return false;
}
@Override
public boolean usesSNS() {
return true;

```
<Overlap Ratio: 0.9815140845070423>

---

--- 171 --
Question ID: 25b569027fdbb487b2fda5b46c9f39236b227963
Original Code:
```
public class PUT_NaturalIdIT extends JerseyTestOnDerby {

    @Override
    protected void doAddResources(FeatureContext context) {
        context.register(Resource.class);
    }

    @Test
    public void test_PUT_SingleId() {
        insert("e20", "name", "'John'");
        insert("e20", "name", "'Brian'");

        Response response = target("/single-id/John")
                .request()
                .put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));

        onSuccess(response).bodyEquals(1, "{\"id\":\"John\",\"age\":28,\"description\":\"zzz\",\"name\":\"John\"}");

        assertEquals(1, intForQuery("SELECT COUNT(1) FROM utest.e20 WHERE age = 28 AND description = 'zzz'"));
    }

    @Test
    public void test_PUT_Single_Id_SeveralExistingObjects() {
        insert("e20", "name", "'John'");
        insert("e20", "name", "'John'");

        Response response = target("/single-id/John").request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));

        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());
        assertEquals("{\"success\":false,\"message\":\"Found more than one object for ID 'John' and entity 'E20'\"}",
                response.readEntity(String.class));
    }

    @Test
    public void test_PUT_MultiId() {
        insert("e21", "age, name", "18, 'John'");
        insert("e21", "age, name", "27, 'Brian'");

        Response response = target("/multi-id/byid").queryParam("age", 18)
                .queryParam("name", "John")
                .request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));

        onSuccess(response).bodyEquals(1,
                "{\"id\":{\"age\":28,\"name\":\"John\"},\"age\":28,\"description\":\"zzz\",\"name\":\"John\"}");

        assertEquals(1, intForQuery("SELECT COUNT(1) FROM utest.e21 WHERE age = 28 AND description = 'zzz'"));
    }

    @Test
    public void test_PUT_SeveralExistingObjects_MultiId() {
        insert("e21", "age, name", "18, 'John'");
        insert("e21", "age, name", "18, 'John'");

        Response response = target("/multi-id/byid").queryParam("age", 18).queryParam("name", "John")
                .request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));

        assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());
        assertEquals("{\"success\":false,\"message\":\"Found more than one object for ID '{name:John,age:18}' and entity 'E21'\"}",
                response.readEntity(String.class));
    }

    @Path("")
    public static class Resource {

        @Context
        private Configuration config;

        @PUT
        @Path("single-id/{id}")
        public DataResponse<E20> createOrUpdate_E20(
                @PathParam("id") String name,
                EntityUpdate<E20> update,
                @Context UriInfo uriInfo) {

            return Ag.idempotentCreateOrUpdate(E20.class, config).id(name).uri(uriInfo).syncAndSelect(update);
        }

        @PUT
        @Path("multi-id/byid")
        public DataResponse<E21> createOrUpdate_E21(
                @QueryParam("age") int age,
                @QueryParam("name") String name,
                EntityUpdate<E21> update,
                @Context UriInfo uriInfo) {

            Map<String, Object> id = new HashMap<>(3);
            id.put("age", age);
            id.put("name", name);
            return Ag.idempotentCreateOrUpdate(E21.class, config).id(id).uri(uriInfo).syncAndSelect(update);
        }
    }

}
```


Overlapping Code:
```
c class PUT_NaturalIdIT extends JerseyTestOnDerby {
@Override
protected void doAddResources(FeatureContext context) {
context.register(Resource.class);
}
@Test
public void test_PUT_SingleId() {
insert("e20", "name", "'John'");
insert("e20", "name", "'Brian'");
Response response = target("/single-id/John")
.request()
.put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));
onSuccess(response).bodyEquals(1, "{\"id\":\"John\",\"age\":28,\"description\":\"zzz\",\"name\":\"John\"}");
assertEquals(1, intForQuery("SELECT COUNT(1) FROM utest.e20 WHERE age = 28 AND description = 'zzz'"));
}
@Test
public void test_PUT_Single_Id_SeveralExistingObjects() {
insert("e20", "name", "'John'");
insert("e20", "name", "'John'");
Response response = target("/single-id/John").request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));
assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());
assertEquals("{\"success\":false,\"message\":\"Found more than one object for ID 'John' and entity 'E20'\"}",
response.readEntity(String.class));
}
@Test
public void test_PUT_MultiId() {
insert("e21", "age, name", "18, 'John'");
insert("e21", "age, name", "27, 'Brian'");
Response response = target("/multi-id/byid").queryParam("age", 18)
.queryParam("name", "John")
.request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));
onSuccess(response).bodyEquals(1,
"{\"id\":{\"age\":28,\"name\":\"John\"},\"age\":28,\"description\":\"zzz\",\"name\":\"John\"}");
assertEquals(1, intForQuery("SELECT COUNT(1) FROM utest.e21 WHERE age = 28 AND description = 'zzz'"));
}
@Test
public void test_PUT_SeveralExistingObjects_MultiId() {
insert("e21", "age, name", "18, 'John'");
insert("e21", "age, name", "18, 'John'");
Response response = target("/multi-id/byid").queryParam("age", 18).queryParam("name", "John")
.request().put(Entity.json("{\"age\":28,\"description\":\"zzz\"}"));
assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(), response.getStatus());
assertEquals("{\"success\":false,\"message\":\"Found more than one object for ID '{name:John,age:18}' and entity 'E21'\"}",
```
<Overlap Ratio: 0.9948405253283302>

---

--- 172 --
Question ID: 8dd3c20136e85234227656d2adccc535ed2c6014
Original Code:
```
class Thrower {
    public void f() {
        // Compiler gives an error: "unreported
        // exception MyException; must be caught
        // or declared to be thrown"
        //! throw new MyException("Inside f()");
    }

    public void g() throws MyException {
        throw new MyException("Inside g()");
    }
}
```


Overlapping Code:
```
iler gives an error: "unreported
// exception MyException; must be caught
// or declared to be thrown"
//! throw new MyException("Inside f()");
}
public void g() throws MyException {
throw new MyExcept
```
<Overlap Ratio: 0.7613636363636364>

---

--- 173 --
Question ID: 430c367bd4f526313c7a504abd13a3a865e4ea62
Original Code:
```
public class _0207CourseSchedule {
	public static void main(String[] args) {
		System.out.println(canFinish(2, new int[][] { new int[] { 1, 0 } }));
		System.out.println(canFinish(2, new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 } }));
	}

	public static boolean canFinish(int numCourses, int[][] prerequisites) {
		HashMap<Integer, HashSet<Integer>> adjList = new HashMap<Integer, HashSet<Integer>>();
		HashMap<Integer, Integer> adjListCount = new HashMap<Integer, Integer>();
		for (int i = 0; i < numCourses; i++) {
			adjList.put(i, new HashSet<Integer>());
			adjListCount.put(i, 0);
		}

		for (int[] prereq : prerequisites) {
			adjList.get(prereq[1]).add(prereq[0]);
			adjListCount.put(prereq[1], adjListCount.get(prereq[1]) + 1);
		}

		Queue<Integer> q = new LinkedList<Integer>();
		for (Map.Entry<Integer, Integer> entry : adjListCount.entrySet()) {
			if (entry.getValue() == 0) {
				q.add(entry.getKey());
				adjListCount.put(entry.getKey(), -1);
			}
		}
		int count = 0;
		while (!q.isEmpty()) {
			int size = q.size();
			for (int i = 0; i < size; i++) {
				Integer node = q.poll();
				count++;
				// find all nodes with values of this node and remove adjlistcount
				for (Map.Entry<Integer, HashSet<Integer>> entry : adjList.entrySet()) {
					if (entry.getValue().contains(node)) {
						entry.getValue().remove(node);
						adjListCount.put(entry.getKey(), adjListCount.get(entry.getKey()) - 1);
					}

					if (adjListCount.get(entry.getKey()) == 0) {
						q.add(entry.getKey());
						adjListCount.put(entry.getKey(), -1);
					}
				}
			}

		}

		return count == numCourses;
	}
}
```


Overlapping Code:
```
ic class _0207CourseSchedule {
public static void main(String[] args) {
System.out.println(canFinish(2, new int[][] { new int[] { 1, 0 } }));
System.out.println(canFinish(2, new int[][] { new int[] { 1, 0 }, new int[] { 0, 1 } }));
}
public static boolean canFinish(int numCourses, int[][] prerequisites) {
HashMap<Integer, HashSet<Integer>> adjList = new HashMap<Integer, HashSet<Integer>>();
HashMap<Integer, Integer> adjListCount = new HashMap<Integer, Integer>();
for (int i = 0; i < numCourses; i++) {
adjList.put(i, new HashSet<Integer>());
adjListCount.put(i, 0);
}
for (int[] prereq : prerequisites) {
adjList.get(prereq[1]).add(prereq[0]);
adjListCount.put(prereq[1], adjListCount.get(prereq[1]) + 1);
}
Queue<Integer> q = new LinkedList<Integer>();
for (Map.Entry<Integer, Integer> entry : adjListCount.entrySet()) {
if (entry.getValue() == 0) {
q.add(entry.getKey());
adjListCount.put(entry.getKey(), -1);
}
}
int count = 0;
while (!q.isEmpty()) {
int size = q.size();
for (int i = 0; i < size; i++) {
Integer node = q.poll();
count++;
// find all nodes with values of this node and remove adjlistcount
for (Map.Entry<Integer, HashSet<Integer>> entry : adjList.entrySet()) {
if (entry.getValue().contains(node)) {
entry.getValue().remove(node);
adjListCount.put(entry.getKey(), adjListCount.get(entry.getKey()) - 1);
}
if (adjListCount.get(entry.getKey()) == 0) {
q.add(entry.getKey());
adjListCount.put(entry.getKey(), -1);
}
}
```
<Overlap Ratio: 0.9729546991210277>

---

--- 174 --
Question ID: 4535051c7c3cb06e6fb1e3ce1a44f900648e6f1c
Original Code:
```
public class GraphQLUIServlet extends HttpServlet {

    private String graphQlPath = null;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ConfigurationUtil configurationUtil = ConfigurationUtil.getInstance();

        if (this.graphQlPath == null) {
            String contextPath = configurationUtil.get("kumuluzee.server.context-path").orElse("");
            String path = configurationUtil.get("kumuluzee.graphql.mapping").orElse("/graphql");

            if (contextPath.endsWith("/")) {
                contextPath = contextPath.substring(0, contextPath.length() - 1);
            }

            if (!path.startsWith("/")) {
                path = "/" + path;
            }

            path = contextPath + path;

            try {
                URI u = new URI(path);

                if(u.isAbsolute()) {
                    resp.getWriter().println("URL must be relative. Extension not initialized.");
                    return;
                }
            } catch(Exception E) {
                resp.getWriter().println("Malformed url: " + path + ". Extension not initialized.");
                return;
            }

            if (path.charAt(0) != '/') {
                path = '/' + path;
            }

            graphQlPath = path;
        }

        if (req.getPathInfo() == null) {
            // no trailing slash, redirect to trailing slash in order to fix relative requests
            resp.sendRedirect(req.getContextPath() + req.getServletPath() + "/");
            return;
        }

        if ("/main.js".equals(req.getPathInfo())) {
            resp.setContentType("application/javascript");
            // inject _kumuluzee_graphql_path variable into js
            sendFile(resp, "main.js", "_kumuluzee_graphql_path = \"" + graphQlPath + "\";\n");
        } else {
            sendFile(resp, "index.html", null);
        }
    }

    private void sendFile(HttpServletResponse resp, String file, String prepend) throws IOException {
        InputStream in = this.getClass().getResourceAsStream("/html/" + file);
        OutputStream out = resp.getOutputStream();

        if (prepend != null) {
            out.write(prepend.getBytes());
        }

        byte[] buf = new byte[10000];
        int length;
        while ((length = in.read(buf)) > 0) {
            out.write(buf, 0, length);
        }

        in.close();
        out.close();
    }
}
```


Overlapping Code:
```
tpServlet {
private String graphQlPath = null;
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
ConfigurationUtil configurationUtil = ConfigurationUtil.getInstance();
if (this.graphQlPath == null) {
String contextPath = configurationUtil.get("kumuluzee.server.context-path").orElse("");
String path = configurationUtil.get("kumuluzee.graphql.mapping").orElse("/graphql");
if (contextPath.endsWith("/")) {
contextPath = contextPath.substring(0, contextPath.length() - 1);
}
if (!path.startsWith("/")) {
path = "/" + path;
}
path = contextPath + path;
try {
URI u = new URI(path);
if(u.isAbsolute()) {
resp.getWriter().println("URL must be relative. Extension not initialized.");
return;
}
} catch(Exception E) {
resp.getWriter().println("Malformed url: " + path + ". Extension not initialized.");
return;
}
if (path.charAt(0) != '/') {
path = '/' + path;
}
graphQlPath = path;
}
if (req.getPathInfo() == null) {
// no trailing slash, redirect to trailing slash in order to fix relative requests
resp.sendRedirect(req.getContextPath() + req.getServletPath() + "/");
return;
}
if ("/main.js".equals(req.getPathInfo())) {
resp.setContentType("application/javascript");
// inject _kumuluzee_graphql_path variable into js
sendFile(resp, "main.js", "_kumuluzee_graphql_path = \"" + graphQlPath + "\";\n");
} else {
sendFile(resp, "index.html", null);
}
}
private void sendFile(HttpServletResponse resp, String file, String prepend) throws IOException {
InputStream in = this.getClass().getResourceAsStream("/html/" + file);
OutputStream out = resp.getOutputStream();
if (prepend != null) {
out.write(prepend.getBytes());
}
byte[] buf = new byte[10000];
int length;
while ((length = in.read(buf)) > 0) {
out.write(buf, 0, length);
}
in.close();
out.close()
```
<Overlap Ratio: 0.9758583690987125>

---

--- 175 --
Question ID: dd6d07a055746585e959bb38a95af3aa37b4a34d
Original Code:
```
public class DataMigrator extends Thread {
  private static final Logger LOG = LoggerFactory.getLogger(DataMigrator.class);

  private final List<Integer> resolutions;
  private final DatasetFramework datasetFramework;
  private final String v2TableNamePrefix;
  private final String v3TableNamePrefix;
  private final int sleepMillisBetweenTransfer;
  private final MetricDatasetFactory metricDatasetFactory;

  private volatile boolean stopping;
  private MetricsTableMigration metricsTableMigration;
  /**
   * Data migrator to run data migration for metrics tables from v2 to v3 metrics tables.
   * @param resolutions - list of resolution tables to migrate data from
   * @param sleepMillisBetweenTransfer while the data transfer is running -
   *                                   amount of time to sleep between each record transfer
   */
  public DataMigrator(DatasetFramework datasetFramework, MetricDatasetFactory metricDatasetFactory,
                      List<Integer> resolutions,
                      String v2TableNamePrefix, String v3TableNamePrefix, int sleepMillisBetweenTransfer) {
    super("MetricsMigratorThread");
    setDaemon(true);
    this.datasetFramework = datasetFramework;
    this.metricDatasetFactory = metricDatasetFactory;
    this.resolutions = resolutions;
    this.v2TableNamePrefix = v2TableNamePrefix;
    this.v3TableNamePrefix = v3TableNamePrefix;
    this.sleepMillisBetweenTransfer = sleepMillisBetweenTransfer;
    stopping = false;
    metricsTableMigration = null;
  }

  public void requestStop() {
    stopping = true;
    if (metricsTableMigration != null) {
      metricsTableMigration.requestStop();
    }
  }

  @Override
  public void run() {
    // iterate through resolutions, if datasetFramework has v2metricsTable then try to get V2 table with a retry
    // once you get v2 table, get v3 table and run migration
    // after migration is completed, we delete the v2 table for that resolution
    // if v2 table does not exist continue to next resolution
    // if no v2 tables exist then exit this thread - data migration is complete.
    for (int resolution : resolutions) {
      try {
        DatasetId v2MetricsTableId = getMetricsDatasetId(v2TableNamePrefix, resolution);
        DatasetId v3MetricsTableId = getMetricsDatasetId(v3TableNamePrefix, resolution);
        if (MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v2MetricsTableId)) {
          // if v3 table is not available, call getOrCreate,
          // this could happen when migrator thread might have started running before processing threads
          if (!MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v3MetricsTableId)) {
            metricDatasetFactory.getOrCreateFactTable(resolution);
          }
          try (MetricsTable v2MetricsTable =
                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v2MetricsTableId);
               MetricsTable v3MetricsTable =
                 MigrationTableHelper.getDatasetWithRetry(datasetFramework, v3MetricsTableId)) {
            MetricsTableMigration metricsTableMigration =
              new MetricsTableMigration(v2MetricsTableId.getDataset(), v2MetricsTable,
                                        v3MetricsTableId.getDataset(), v3MetricsTable);

            metricsTableMigration.transferData(sleepMillisBetweenTransfer);
            LOG.info("Metrics table data migration is complete for {}", v2MetricsTableId.getDataset());
            // don't delete if we are stopping
            if (stopping) {
              break;
            }
            // now transfer is complete; its safe to delete the v2 metrics table
            MigrationTableHelper.deleteInstanceWithRetry(datasetFramework, v2MetricsTableId);
            LOG.info("Deleted Metrics table {}", v2MetricsTableId.getDataset());
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            break;
          }
        }
      } catch (Exception e) {
        LOG.error("Exception while performing dataset operation during metrics table migration", e);
        return;
      }
    }
  }

  private DatasetId getMetricsDatasetId(String tableNamePrefix, int resolution) {
    String tableName =  tableNamePrefix + resolution;
    return NamespaceId.SYSTEM.dataset(tableName);
  }
}
```


Overlapping Code:
```
r extends Thread {
private static final Logger LOG = LoggerFactory.getLogger(DataMigrator.class);
private final List<Integer> resolutions;
private final DatasetFramework datasetFramework;
private final String v2TableNamePrefix;
private final String v3TableNamePrefix;
private final int sleepMillisBetweenTransfer;
private final MetricDatasetFactory metricDatasetFactory;
private volatile boolean stopping;
private MetricsTableMigration metricsTableMigration;
/**
* Data migrator to run data migration for metrics tables from v2 to v3 metrics tables.
* @param resolutions - list of resolution tables to migrate data from
* @param sleepMillisBetweenTransfer while the data transfer is running -
* amount of time to sleep between each record transfer
*/
public DataMigrator(DatasetFramework datasetFramework, MetricDatasetFactory metricDatasetFactory,
List<Integer> resolutions,
String v2TableNamePrefix, String v3TableNamePrefix, int sleepMillisBetweenTransfer) {
super("MetricsMigratorThread");
setDaemon(true);
this.datasetFramework = datasetFramework;
this.metricDatasetFactory = metricDatasetFactory;
this.resolutions = resolutions;
this.v2TableNamePrefix = v2TableNamePrefix;
this.v3TableNamePrefix = v3TableNamePrefix;
this.sleepMillisBetweenTransfer = sleepMillisBetweenTransfer;
stopping = false;
metricsTableMigration = null;
}
public void requestStop() {
stopping = true;
if (metricsTableMigration != null) {
metricsTableMigration.requestStop();
}
}
@Override
public void run() {
// iterate through resolutions, if datasetFramework has v2metricsTable then try to get V2 table with a retry
// once you get v2 table, get v3 table and run migration
// after migration is completed, we delete the v2 table for that resolution
// if v2 table does not exist continue to next resolution
// if no v2 tables exist then exit this thread - data migration is complete.
for (int resolution : resolutions) {
try {
DatasetId v2MetricsTableId = getMetricsDatasetId(v2TableNamePrefix, resolution);
DatasetId v3MetricsTableId = getMetricsDatasetId(v3TableNamePrefix, resolution);
if (MigrationTableHelper.hasInstanceWithRetry(datasetFramework, v2MetricsTableId)) {
// if v3 table is not available, call getOrCr
```
<Overlap Ratio: 0.9834599910594546>

---

--- 176 --
Question ID: fb2eda00abf5381409eecbc715aae4b3dbc06a17
Original Code:
```
public class RemoteRosterEntry {

    private Jid user;
    private String name;
    private final List<String> groupNames = new ArrayList<String>();

    /**
     * Creates a new remote roster entry.
     *
     * @param user the user.
     * @param name the user's name.
     * @param groups the list of group names the entry will belong to, or <tt>null</tt> if the
     *      the roster entry won't belong to a group.
     */
    public RemoteRosterEntry(Jid user, String name, String [] groups) {
        this.user = user;
        this.name = name;
        if (groups != null) {
            groupNames.addAll(Arrays.asList(groups));
        }
    }

    /**
     * Returns the user.
     *
     * @return the user.
     */
    public Jid getUser() {
        return user;
    }

    /**
     * Returns the user's name.
     *
     * @return the user's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns an Iterator for the group names (as Strings) that the roster entry
     * belongs to.
     *
     * @return an Iterator for the group names.
     */
    public Iterator<String> getGroupNames() {
        synchronized (groupNames) {
            return Collections.unmodifiableList(groupNames).iterator();
        }
    }

    /**
     * Returns a String array for the group names that the roster entry
     * belongs to.
     *
     * @return a String[] for the group names.
     */
    public String[] getGroupArrayNames() {
        synchronized (groupNames) {
            return Collections.unmodifiableList(groupNames).toArray(new String[groupNames.size()]);
        }
    }

    public String toXML() {
        StringBuilder buf = new StringBuilder();
        buf.append("<item jid=\"").append(user).append('"');
        if (name != null) {
            buf.append(" name=\"").append(name).append('"');
        }
        buf.append('>');
        synchronized (groupNames) {
            for (String groupName : groupNames) {
                buf.append("<group>").append(groupName).append("</group>");
            }
        }
        buf.append("</item>");
        return buf.toString();
    }

}
```


Overlapping Code:
```
terEntry {
private Jid user;
private String name;
private final List<String> groupNames = new ArrayList<String>();
/**
* Creates a new remote roster entry.
*
* @param user the user.
* @param name the user's name.
* @param groups the list of group names the entry will belong to, or <tt>null</tt> if the
* the roster entry won't belong to a group.
*/
public RemoteRosterEntry(Jid user, String name, String [] groups) {
this.user = user;
this.name = name;
if (groups != null) {
groupNames.addAll(Arrays.asList(groups));
}
}
/**
* Returns the user.
*
* @return the user.
*/
public Jid getUser() {
return user;
}
/**
* Returns the user's name.
*
* @return the user's name.
*/
public String getName() {
return name;
}
/**
* Returns an Iterator for the group names (as Strings) that the roster entry
* belongs to.
*
* @return an Iterator for the group names.
*/
public Iterator<String> getGroupNames() {
synchronized (groupNames) {
return Collections.unmodifiableList(groupNames).iterator();
}
}
/**
* Returns a String array for the group names that the roster entry
* belongs to.
*
* @return a String[] for the group names.
*/
public String[] getGroupArrayNames() {
synchronized (groupNames) {
return Collections.unmodifiableList(groupNames).toArray(new String[groupNames.size()]);
}
}
public String toXML() {
StringBuilder buf = new StringBuilder();
buf.append("<item jid=\"").append(user).append('"');
if (name != null) {
buf.append(" name=\"").append(name).append('"');
}
buf.append('>');
synchronized (groupNames) {
for (String groupName : groupNames) {
buf.append("<group>").append(groupName).append("</group>");
}
}
buf.append("</item>");
return buf
```
<Overlap Ratio: 0.9774881516587678>

---

--- 177 --
Question ID: 002aa70c49ade1a72d2db048be8138088d0030bd
Original Code:
```
public class CliSequenceTestCase {

    private static final String CLI_TEST_SEQUENCE = "CliTestSequence";
    private static final String CLI_SAMPLE_SEQUENCE = "CliSampleSequence";

    /**
     * Get information about all Sequence
     */
    @Test
    public void miShowSequenceAllTest() throws IOException {

        List<String> outputForCLICommand = TestUtils.getOutputForCLICommand(Constants.SEQUENCE, Constants.SHOW);
        String artifactName_seq_1[] = TestUtils.getArtifactList(outputForCLICommand).get(0).split(" ", 2);
        String artifactName_seq_2[] = TestUtils.getArtifactList(outputForCLICommand).get(1).split(" ", 2);

        Assert.assertEquals(artifactName_seq_1[0], CLI_TEST_SEQUENCE);
        Assert.assertEquals(artifactName_seq_2[0], CLI_SAMPLE_SEQUENCE);
    }

    /**
     * Get information about single Sequence
     */
    @Test
    public void miShowSequenceTest() throws IOException {

        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, CLI_TEST_SEQUENCE);
        Assert.assertEquals(outputForCLICommand.get(0), "Name - CliTestSequence");
    }

    /**
     * Test un-deployed Sequence
     */
    @Test
    public void miShowSequenceNotFoundTest() throws IOException {

        List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, "CLITestSequence");
        Assert.assertEquals(outputForCLICommand.get(0), "[ERROR] Getting Information of the Sequence 404 Not Found");
    }
}
```


Overlapping Code:
```
 {
private static final String CLI_TEST_SEQUENCE = "CliTestSequence";
private static final String CLI_SAMPLE_SEQUENCE = "CliSampleSequence";
/**
* Get information about all Sequence
*/
@Test
public void miShowSequenceAllTest() throws IOException {
List<String> outputForCLICommand = TestUtils.getOutputForCLICommand(Constants.SEQUENCE, Constants.SHOW);
String artifactName_seq_1[] = TestUtils.getArtifactList(outputForCLICommand).get(0).split(" ", 2);
String artifactName_seq_2[] = TestUtils.getArtifactList(outputForCLICommand).get(1).split(" ", 2);
Assert.assertEquals(artifactName_seq_1[0], CLI_TEST_SEQUENCE);
Assert.assertEquals(artifactName_seq_2[0], CLI_SAMPLE_SEQUENCE);
}
/**
* Get information about single Sequence
*/
@Test
public void miShowSequenceTest() throws IOException {
List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, CLI_TEST_SEQUENCE);
Assert.assertEquals(outputForCLICommand.get(0), "Name - CliTestSequence");
}
/**
* Test un-deployed Sequence
*/
@Test
public void miShowSequenceNotFoundTest() throws IOException {
List<String> outputForCLICommand = TestUtils.getOutputForCLICommandArtifactName(Constants.SEQUENCE, Constants.SHOW, "CLITestSequence");
Assert.assertEquals(outputForCLICommand.get(0), "[ERROR] Getting Informati
```
<Overlap Ratio: 0.9487364620938629>

---

--- 178 --
Question ID: b5876612483b981d46d65bed168dc3f7cc20f03e
Original Code:
```
public class InService {

    private static final Logger LOGGER = LoggerFactory.getLogger(InService.class);

    private final PlantOutRepository plantOutRepository;
    private final PlantInRepository plantInRepository;
    private final DetailInRepository detailInRepository;

    public InService(
            final PlantOutRepository plantOutRepository,
            final PlantInRepository plantInRepository,
            final DetailInRepository detailInRepository
    ) {
        this.plantOutRepository = plantOutRepository;
        this.plantInRepository = plantInRepository;
        this.detailInRepository = detailInRepository;
    }

    public void write(
            final UUID userId,
            final String type,
            final String password,
            final Date inTimestamp,
            final double temperature,
            final double humidity,
            final double light,
            final double conductivity
    ) throws ConsumeException {

        final Optional<Plant> optionalPlant = this.plantOutRepository.getByUserId(userId);

        if (!optionalPlant.isPresent()) {
            final String problem = String.format("No plant with user id [%s]", userId);
            LOGGER.warn(problem);
            throw new ConsumeException(problem);
        }

        final Plant plant = optionalPlant.get();

        if (!PasswordHasher.verify(plant.getPassword(), password)) {
            final String problem = String.format("Password [%s] is incorrect for plant with user id [%s]", password, userId);
            LOGGER.warn(problem);
            throw new ConsumeException(problem);
        }

        // If type is different, get it in
        // TODO Validate type when there's something to validate against.
        // TODO Possible an enum of acceptable plants
        if (StringUtils.isNotBlank(type) && !type.equalsIgnoreCase(plant.getType())) {
            this.plantInRepository.updateType(type, plant.getId());
        }

        // We're going to trust the date

        // TODO Ugh.
        final boolean temperatureValid = verify(temperature);
        final boolean humidityValid = verify(humidity);
        final boolean lightValid = verify(light);
        final boolean conductivityValid = verify(conductivity);

        if (temperatureValid && humidityValid && lightValid && conductivityValid) {
            try {
                this.detailInRepository.save(plant.getId(), inTimestamp, temperature, humidity, light, conductivity);
            } catch (UnableToExecuteStatementException e) {
                LOGGER.warn("SQL problem saving detail", e);
            }
        } else {
            final String problem = String.format(
                    "Data invalid for detail - plantId: [%d], inTimestamp: [%s], temp: [%f], hum: [%f], light: [%f], cond: [%f]",
                    plant.getId(), inTimestamp, temperature, humidity, light, conductivity
            );
            LOGGER.warn(problem);
            throw new ConsumeException(problem);
        }

    }

    // TODO This could do with being pulled out and unit tested, it is likely to change
    // TODO Also, different verification is likely to take place on the different numbers...
    // TODO e.g temperature probably won't be 0 to infinity
    private boolean verify(double candidate) {
        return candidate >= 0;
    }

}
```


Overlapping Code:
```
nService {
private static final Logger LOGGER = LoggerFactory.getLogger(InService.class);
private final PlantOutRepository plantOutRepository;
private final PlantInRepository plantInRepository;
private final DetailInRepository detailInRepository;
public InService(
final PlantOutRepository plantOutRepository,
final PlantInRepository plantInRepository,
final DetailInRepository detailInRepository
) {
this.plantOutRepository = plantOutRepository;
this.plantInRepository = plantInRepository;
this.detailInRepository = detailInRepository;
}
public void write(
final UUID userId,
final String type,
final String password,
final Date inTimestamp,
final double temperature,
final double humidity,
final double light,
final double conductivity
) throws ConsumeException {
final Optional<Plant> optionalPlant = this.plantOutRepository.getByUserId(userId);
if (!optionalPlant.isPresent()) {
final String problem = String.format("No plant with user id [%s]", userId);
LOGGER.warn(problem);
throw new ConsumeException(problem);
}
final Plant plant = optionalPlant.get();
if (!PasswordHasher.verify(plant.getPassword(), password)) {
final String problem = String.format("Password [%s] is incorrect for plant with user id [%s]", password, userId);
LOGGER.warn(problem);
throw new ConsumeException(problem);
}
// If type is different, get it in
// TODO Validate type when there's something to validate against.
// TODO Possible an enum of acceptable plants
if (StringUtils.isNotBlank(type) && !type.equalsIgnoreCase(plant.getType())) {
this.plantInRepository.updateType(type, plant.getId());
}
// We're going to trust the date
// TODO Ugh.
final boolean temperatureValid = verify(temperature);
final boolean humidityValid = verify(humidity);
final boolean lightValid = verify(light);
final boolean conductivityValid = verify(conductivity);
if (temperatureValid && humidityValid && lightValid && conductivityValid) {
try {
this.detailInRepository.save(plant.getId(), inTimestamp, temperature, humidity, light, conductivity)
```
<Overlap Ratio: 0.991609081934847>

---

--- 179 --
Question ID: ba4e8f72acb5a5fafb85f587d9a06ca9e8ed9f6d
Original Code:
```
@PrepareForTest(FilesUtils.class)
public class PXConfigurationTest extends PowerMockTestCase {
    @Test
    public void testMergeConfigurations() throws FileNotFoundException {
        PXConfiguration pxConfiguration = PXConfiguration.builder()
                .appId("appId")
                .cookieKey("cookieKey")
                .authToken("authToken")
                .sensitiveRoutes(new HashSet<>(Arrays.asList("/profile")))
                .moduleMode(ModuleMode.BLOCKING)
                .remoteConfigurationEnabled(false)
                .validateRequestQueueInterval(1000 * 100)
                .bypassMonitorHeader("X-PX-BYPASS-MONITOR")
                .configFilePath("config.json")
                .build();
        PowerMock.mockStaticPartial(FilesUtils.class, "readFile");
        EasyMock.expect(FilesUtils.readFile("config.json")).andReturn("{\n" +
                "  \"px_module_mode\": 0,\n" +
                "  \"px_remote_configuration_interval_ms\": 1\n" +
                "}\n").times(2);
        PowerMock.replayAll();
        pxConfiguration.mergeConfigurations();
        Assert.assertEquals(pxConfiguration.getModuleMode(), ModuleMode.MONITOR);
        Assert.assertEquals(pxConfiguration.getRemoteConfigurationInterval(), 1);
    }
}
```


Overlapping Code:
```
ss)
public class PXConfigurationTest extends PowerMockTestCase {
@Test
public void testMergeConfigurations() throws FileNotFoundException {
PXConfiguration pxConfiguration = PXConfiguration.builder()
.appId("appId")
.cookieKey("cookieKey")
.authTokenys.asList("/profile")))
.moduleMode(ModuleMode.BLOCKING)
.remoteConfigurationEnabled(false)
.validateRequestQueueInterval(1000 * 100)
.bypassMonitorHeader("X-PX-BYPASS-MONITOR")
.configFilePath("config.json")
.build();
PowerMock.mockStaticPartial(FilesUtils.class, "readFile");
EasyMock.expect(FilesUtils.readFile("config.json")).andReturn("{\n" +
" \"px_module_mode\": 0,\n" +
" \"px_remote_configuration_interval_ms\": 1\n" +
"}\n").times(2);
PowerMock.replayAll();
pxConfiguration.mergeConfigurations();
Assert.assertEquals(pxConfiguration.getModuleMode(), ModuleMode.MONITOR);
Assert.assertEquals(pxConfiguration.getRemoteConfigurationInterval(), 1);
}

```
<Overlap Ratio: 0.9189463019250254>

---

--- 180 --
Question ID: a8a65c83d2a84f6a2d3c3d8eacc81c82424af4d4
Original Code:
```
public class Displ209Test extends DisplaytagCase
{

    /**
     * @see org.displaytag.test.DisplaytagCase#getJspName()
     */
    public String getJspName()
    {
        return "DISPL-209.jsp";
    }

    /**
     * Check list index/view index values.
     * @param jspName jsp name, with full path
     * @throws Exception any axception thrown during test.
     */
    public void doTest(String jspName) throws Exception
    {
        WebRequest request = new GetMethodWebRequest(jspName);
        WebResponse response = runner.getResponse(request);

        ParamEncoder encoder = new ParamEncoder("table");
        request.setParameter(encoder.encodeParameterName(TableTagParameters.PARAMETER_PAGE), "2");

        if (log.isDebugEnabled())
        {
            log.debug(response.getText());
        }

        WebTable[] tables = response.getTables();
        assertEquals("Wrong number of tables in result.", 1, tables.length);
        assertEquals("Wrong number of rows in result.", 4, tables[0].getRowCount());

        if (log.isDebugEnabled())
        {
            log.debug(response.getText());
        }

        assertEquals("Wrong value", "a", tables[0].getCellAsText(1, 0));
        assertEquals("Wrong viewIndex", "0", tables[0].getCellAsText(1, 1));
        assertEquals("Wrong listIndex", "0", tables[0].getCellAsText(1, 2));

        assertEquals("Wrong value", "b", tables[0].getCellAsText(2, 0));
        assertEquals("Wrong viewIndex", "1", tables[0].getCellAsText(2, 1));
        assertEquals("Wrong listIndex", "1", tables[0].getCellAsText(2, 2));

        assertEquals("Wrong value", "c", tables[0].getCellAsText(3, 0));
        assertEquals("Wrong viewIndex", "2", tables[0].getCellAsText(3, 1));
        assertEquals("Wrong listIndex", "2", tables[0].getCellAsText(3, 2));
    }

}
```


Overlapping Code:
```
Test extends DisplaytagCase
{
/**
* @see org.displaytag.test.DisplaytagCase#getJspName()
*/
public String getJspName()
{
return "DISPL-209.jsp";
}
/**
* Check list index/view index values.
* @param jspName jsp name, with full path
* @throws Exception any axception thrown during test.
*/
public void doTest(String jspName) throws Exception
{
WebRequest request = new GetMethodWebRequest(jspName);
WebResponse response = runner.getResponse(request);
ParamEncoder encoder = new ParamEncoder("table");
request.setParameter(encoder.encodeParameterName(TableTagParameters.PARAMETER_PAGE), "2");
if (log.isDebugEnabled())
{
log.debug(response.getText());
}
WebTable[] tables = response.getTables();
assertEquals("Wrong number of tables in result.", 1, tables.length);
assertEquals("Wrong number of rows in result.", 4, tables[0].getRowCount());
if (log.isDebugEnabled())
{
log.debug(response.getText());
}
assertEquals("Wrong value", "a", tables[0].getCellAsText(1, 0));
assertEquals("Wrong viewIndex", "0", tables[0].getCellAsText(1, 1));
assertEquals("Wrong listIndex", "0", tables[0].getCellAsText(1, 2));
assertEquals("Wrong value", "b", tables[0].getCellAsText(2, 0));
assertEquals("Wrong viewIndex", "1", tables[0].getCellAsText(2, 1));
assertEquals("Wrong listIndex", "1", tables[0].getCellAsText(2, 2));
assertEquals("Wrong value", "c", tables[0].getCellAsText(3, 0));
assertEquals("Wrong viewIndex", "2", tables[0].getCellAsText(3, 1));
assertEquals("Wrong listIndex", "2", tables[0].getCellAsText(3, 2
```
<Overlap Ratio: 0.9817351598173516>

---

--- 181 --
Question ID: 84eee976f52695b87dca16bac04b65017ee3a4d4
Original Code:
```
public class SimpleFragmentPagerAdapter extends FragmentPagerAdapter {
    public boolean CHANGE_VISIBILITY = true;

    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager) {
        super(fragmentManager);
    }

    public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @Nullable List<Page> pages) {
        super(fragmentManager, pages);
    }

    @Nullable
    @Override
    public CharSequence getPageTitle(int position) {
        try {
            CharSequence title = super.getPageTitle(position);
            if (title != null && title.length() > 0)
                return title;
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            Page page = getPageAtOrThrow(position);
            if (page.isCreated()) {
                Fragment fragment = page.getFragment();

                if (fragment instanceof NameableAdapter) {
                    String name = ((NameableAdapter) fragment).getName();
                    if (name != null && name.length() > 0)
                        return name;
                }
                if (fragment instanceof SimpleFragment) {
                    String name = ((SimpleFragment) fragment).getTitle();
                    if (name != null && name.length() > 0)
                        return name;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    protected void setVisible(@NonNull Fragment fragment, boolean visible) {
        super.setVisible(fragment, visible);

        if (CHANGE_VISIBILITY && fragment instanceof VisibilityAdapter) {
            VisibilityAdapter visibilityAdapter = (VisibilityAdapter) fragment;
            visibilityAdapter.setVisibility(visible, false);
        }
    }
}
```


Overlapping Code:
```
public class SimpleFragmentPagerAdapter extends FragmentPagerAdapter {
public boolean CHANGE_VISIBILITY = true;
public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager) {
super(fragmentManager);
}
public SimpleFragmentPagerAdapter(@NonNull FragmentManager fragmentManager, @Nullable List<Page> pages) {
super(fragmentManager, pages);
}
@Nullable
@Override
public CharSequence getPageTitle(int position) {
try {
CharSequence title = super.getPageTitle(position);
if (title != null && title.length() > 0)
return title;
} catch (Exception e) {
e.printStackTrace();
}
try {
Page page = getPageAtOrThrow(position);
if (page.isCreated()) {
Fragment fragment = page.getFragment();
if (fragment instanceof NameableAdapter) {
String name = ((NameableAdapter) fragment).getName();
if (name != null && name.length() > 0)
return name;
}
if (fragment instanceof SimpleFragment) {
String name = ((SimpleFragment) fragment).getTitle();
if (name != null && name.length() > 0)
return name;
}
}
} catch (Exception e) {
e.printStackTrace();
}
return null;
}
@Override
protected void setVisible(@NonNull Fragment fragment, boolean visible) {
super.setVisible(fragment, visible);
if (CHANGE_VISIBILITY && fragment instanceof VisibilityAdapter) {
VisibilityAdapter visibilityAdapter = (VisibilityAdapter) fragment;
visibilityAdapter.setV
```
<Overlap Ratio: 0.9765739385065886>

---

--- 182 --
Question ID: 4e0c4f164ba0e837f6c3ae51d983cd6447416911
Original Code:
```
@XmlRootElement
public class CourseSchedule {

    private short taughtYear;
    private short startPeriod;
    private short endPeriod;
    private short periodIdxAmongAllPlanPeriods;

    private CourseSchedule(){
        // for jaxb
    }
    public short getPeriodIdxAmongAllPlanPeriods() {
        return periodIdxAmongAllPlanPeriods;
    }

    public void setPeriodIdxAmongAllPlanPeriods(short periodIdxAmongAllPlanPeriods) {
        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;
    }

    public CourseSchedule(short taughtYear, short startPeriod) {
        this.taughtYear = taughtYear;
        this.startPeriod = startPeriod;
    }
    
    public CourseSchedule(short taughtYear, short startPeriod, short periodIdxAmongAllPlanPeriods) {
        this.taughtYear = taughtYear;
        this.startPeriod = startPeriod;
        this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;
    }

    public short getTaughtYear() {
        return taughtYear;
    }

    public void setTaughtYear(short taughtYear) {
        this.taughtYear = taughtYear;
    }

    public short getStartPeriod() {
        return startPeriod;
    }

    public void setStartPeriod(short startPeriod) {
        this.startPeriod = startPeriod;
    }

    public short getEndPeriod() {
        return endPeriod;
    }

    public void setEndPeriod(short endPeriod) {
        this.endPeriod = endPeriod;
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 83 * hash + this.taughtYear;
        hash = 83 * hash + this.startPeriod;
        hash = 83 * hash + this.endPeriod;
        return hash;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final CourseSchedule other = (CourseSchedule) obj;
        if (this.taughtYear != other.taughtYear) {
            return false;
        }
        if (this.startPeriod != other.startPeriod) {
            return false;
        }
        if (this.endPeriod != other.endPeriod) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "CourseSchedule{" + "taughtYear=" + taughtYear + ", startPeriod=" + startPeriod + ", endPeriod=" + endPeriod + '}';
    }

}
```


Overlapping Code:
```
{
private short taughtYear;
private short startPeriod;
private short endPeriod;
private short periodIdxAmongAllPlanPeriods;
private CourseSchedule(){
// for jaxb
}
public short getPeriodIdxAmongAllPlanPeriods() {
return periodIdxAmongAllPlanPeriods;
}
public void setPeriodIdxAmongAllPlanPeriods(short periodIdxAmongAllPlanPeriods) {
this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;
}
public CourseSchedule(short taughtYear, short startPeriod) {
this.taughtYear = taughtYear;
this.startPeriod = startPeriod;
}

public CourseSchedule(short taughtYear, short startPeriod, short periodIdxAmongAllPlanPeriods) {
this.taughtYear = taughtYear;
this.startPeriod = startPeriod;
this.periodIdxAmongAllPlanPeriods = periodIdxAmongAllPlanPeriods;
}
public short getTaughtYear() {
return taughtYear;
}
public void setTaughtYear(short taughtYear) {
this.taughtYear = taughtYear;
}
public short getStartPeriod() {
return startPeriod;
}
public void setStartPeriod(short startPeriod) {
this.startPeriod = startPeriod;
}
public short getEndPeriod() {
return endPeriod;
}
public void setEndPeriod(short endPeriod) {
this.endPeriod = endPeriod;
}
@Override
public int hashCode() {
int hash = 7;
hash = 83 * hash + this.taughtYear;
hash = 83 * hash + this.startPeriod;
hash = 83 * hash + this.endPeriod;
return hash;
}
@Override
public boolean equals(Object obj) {
if (obj == null) {
return false;
}
if (getClass() != obj.getClass()) {
return false;
}
final CourseSchedule other = (CourseSchedule) obj;
if (this.taughtYear != other.taughtYear) {
return false;
}
if (this.startPeriod != other.startPeriod) {
return false;
}
if (this.endPeriod != other.endPeriod) {
return false;
}
return true;
}
@Override
public String toString() {
return "CourseSchedule{" + "taughtYear=" + taughtYear + ", startPeriod=" + startPeriod + ", endPeriod=" + endPeriod + '}'
```
<Overlap Ratio: 0.9741969457609269>

---

--- 183 --
Question ID: 61ba8ff113176b7843d6b18dc06a80bc2331f087
Original Code:
```
public class ELKITools {

	/**
	 * creates an ELKI database instance from a list of given feature vectors. List
	 * of feature vector must contain at least one entry.
	 * 
	 * The database will be initialized as well.
	 * 
	 * @param featureVectors input feature vectors
	 * @return ELKI Database
	 */
	public static Database createAndInitializeELKIDatabase(List<? extends NumericalFeatureVector> featureVectors) {
		Objects.requireNonNull(featureVectors);

		int count = featureVectors.size();

		if (count == 0)
			throw new IllegalArgumentException(
					"ELKITools.createAndInitializeELKIDatabase requires non-empty list of FV");

		int dimensions = featureVectors.get(0).getSize();

		double[][] data = new double[count][dimensions];
		for (int i = 0; i < count; i++) {
			data[i] = featureVectors.get(i).getVector();
		}

		DatabaseConnection dbc = new ArrayAdapterDatabaseConnection(data);
		Database db = new StaticArrayDatabase(dbc, null);

		// initialize
		db.initialize();

		return db;
	}
}
```


Overlapping Code:
```
ass ELKITools {
/**
* creates an ELKI database instance from a list of given feature vectors. List
* of feature vector must contain at least one entry.
* 
* The database will be initialized as well.
* 
* @param featureVectors input feature vectors
* @return ELKI Database
*/
public static Database createAndInitializeELKIDatabase(List<? extends NumericalFeatureVector> featureVectors) {
Objects.requireNonNull(featureVectors);
int count = featureVectors.size();
if (count == 0)
throw new IllegalArgumentException(
"ELKITools.createAndInitializeELKIDatabase requires non-empty list of FV");
int dimensions = featureVectors.get(0).getSize();
double[][] data = new double[count][dimensions];
for (int i = 0; i < count; i++) {
data[i] = featureVectors.get(i).getVector();
}
DatabaseConnection dbc = new ArrayAdapterDatabaseConnection(data);
Database db = new StaticArrayDatabase(dbc, null);
// initialize
db.initialize();
```
<Overlap Ratio: 0.9744952178533475>

---

--- 184 --
Question ID: 2e3f7f9cefefad929e844fa48cbfeab1b5cb9526
Original Code:
```
public class HelloWorld
{
    public static void main(String[] args) throws Exception
    {
        // The path to the documents directory.
        String dataDir = "src/quickstart/helloworld/data/";
        // Create a blank document.
        Document doc = new Document();
        // DocumentBuilder provides members to easily add content to a document.
        DocumentBuilder builder = new DocumentBuilder(doc);
        // Write a new paragraph in the document with the text "Hello World!"
        builder.writeln("Hello World!");
        // Save the document in DOCX format. The format to save as is inferred from the extension of the file name.
        // Aspose.Words supports saving any document in many more formats.
        doc.save(dataDir + "HelloWorld Out.docx");
    }
}
```


Overlapping Code:
```
public class HelloWorld
{
public static void main(String[] args) throws Exception
{
// The path to the documents directory.
String dataDir = "src/quickstart/helloworld/data/";
// Create a blank document.
Document doc = new Document();
// DocumentBuilder provides members to easily add content to a document.
DocumentBuilder builder = new DocumentBuilder(doc);
// Write a new paragraph in the document with the text "Hello World!"
builder.writeln("Hello World!");
// Save the document in DOCX format. The format to save as is inferred from the extension of the file name.
// Aspose.Words supports saving any document in many more formats.
doc.save(dataDir + "H
```
<Overlap Ratio: 0.9634502923976608>

---

--- 185 --
Question ID: 71dc8679e7c5a049927d447832b0eb8e18fa9953
Original Code:
```
public final class WebUtils {

    private WebUtils() {}

    public static void clearCookies(@NonNull Context context) {
        CookieManager c = CookieManager.getInstance();
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            c.removeAllCookies(null);
        } else {
            //noinspection deprecation
            CookieSyncManager.createInstance(context);
            //noinspection deprecation
            c.removeAllCookie();
        }
    }

    public static void clearWebStorage() {
        WebStorage.getInstance().deleteAllData();
    }

    public static void clearHistory(@NonNull Context context,
                                    @NonNull HistoryRepository historyRepository,
                                    @NonNull Scheduler databaseScheduler) {
        historyRepository.deleteHistory()
            .subscribeOn(databaseScheduler)
            .subscribe();
        WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(context);
        webViewDatabase.clearFormData();
        webViewDatabase.clearHttpAuthUsernamePassword();
        Utils.trimCache(context);
    }

    public static void clearCache(@Nullable ConstraintWebLayout view) {
        if (view == null) return;
        view.clearCache(true);
    }

}
```


Overlapping Code:
```
public final class WebUtils {
private WebUtils() {}
public static void clearCookies(@NonNull Context context) {
CookieManager c = CookieManager.getInstance();
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
c.removeAllCookies(null);
} else {
//noinspection deprecation
CookieSyncManager.createInstance(context);
//noinspection deprecation
c.removeAllCookie();
}
}
public static void clearWebStorage() {
WebStorage.getInstance().deleteAllData();
}
public static void clearHistory(@NonNull Context context,
@NonNull HistoryRepository historyRepository,
@NonNull Scheduler databaseScheduler) {
historyRepository.deleteHistory()
.subscribeOn(databaseScheduler)
.subscribe();
WebViewDatabase webViewDatabase = WebViewDatabase.getInstance(context);
webViewDatabase.clearFormData();
webViewDatabase.clearHttpAuthUsernamePassword();
Utils.trimCache(context);
}
public static void clearCache(@Nullable ConstraintWebLayout view) {
if (view 
```
<Overlap Ratio: 0.9563894523326572>

---

--- 186 --
Question ID: e4f8f6bfbc5ddd32518ca82d52fc886e32a50393
Original Code:
```
public class XMLDocument extends XMLNode {
	private static final long serialVersionUID = -8106159267601656260L;

	public XMLDocument() {
	}

	public XMLDocument(final Node node) {
		super(node);
	}

	public XMLDocument(final String xml) throws SAXException, IOException, ParserConfigurationException {
		loadString(xml);
	}

	public XMLNode getDocumentElement() {
		return new XMLNode(((Document) node_).getDocumentElement());
	}

	public void loadURL(final String urlString) throws SAXException, IOException, ParserConfigurationException {
		URL url = new URL(urlString);
		URLConnection conn = url.openConnection();

		node_ = getBuilder().parse((InputStream) conn.getContent());
	}

	public void loadInputStream(final InputStream is) throws SAXException, IOException, ParserConfigurationException {
		node_ = getBuilder().parse(is);
	}

	public void loadString(final String s) throws SAXException, IOException, ParserConfigurationException {
		loadInputStream(new ByteArrayInputStream(s.getBytes("UTF-8"))); //$NON-NLS-1$
	}

	private DocumentBuilder getBuilder() throws ParserConfigurationException {
		DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
		fac.setValidating(false);
		// fac.setNamespaceAware(true);
		return fac.newDocumentBuilder();
	}

	public static String escapeXPathValue(final String input) {
		return input.replace("'", "\\'"); //$NON-NLS-1$ //$NON-NLS-2$
	}

	@Override
	public String toString() {
		try {
			return getXml(null);
		} catch (IOException e) {
			return e.getMessage();
		}
	}
}
```


Overlapping Code:
```
ublic class XMLDocument extends XMLNode {
private static final long serialVersionUID = -8106159267601656260L;
public XMLDocument() {
}
public XMLDocument(final Node node) {
super(node);
}
public XMLDocument(final String xml) throws SAXException, IOException, ParserConfigurationException {
loadString(xml);
}
public XMLNode getDocumentElement() {
return new XMLNode(((Document) node_).getDocumentElement());
}
public void loadURL(final String urlString) throws SAXException, IOException, ParserConfigurationException {
URL url = new URL(urlString);
URLConnection conn = url.openConnection();
node_ = getBuilder().parse((InputStream) conn.getContent());
}
public void loadInputStream(final InputStream is) throws SAXException, IOException, ParserConfigurationException {
node_ = getBuilder().parse(is);
}
public void loadString(final String s) throws SAXException, IOException, ParserConfigurationException {
loadInputStream(new ByteArrayInputStream(s.getBytes("UTF-8"))); //$NON-NLS-1$
}
private DocumentBuilder getBuilder() throws ParserConfigurationException {
DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();
fac.setValidating(false);
// fac.setNamespaceAware(true);
return fac.newDocumentBuilder();
}
public static String escapeXPathValue(final String input) {
return input.replace("'", "\\'"); //$NON-NLS-1$ //$NON-NLS-2$
}
@Override
public String toString() {
try {
return getXml(null);
} catch (IOException e) {
return e.getMessage();
}
}

```
<Overlap Ratio: 0.9986357435197817>

---

--- 187 --
Question ID: 0d5e8ed35c18af33a8d2435779aaa62c49a9ab44
Original Code:
```
public class ConstantDoublesCurveTest {
  private static final double Y1 = 20;
  private static final double Y2 = 21;
  private static final String NAME1 = "a";
  private static final String NAME2 = "b";
  private static final ConstantDoublesCurve CURVE = new ConstantDoublesCurve(Y1, NAME1);

  @Test(expectedExceptions = UnsupportedOperationException.class)
  public void testGetXData() {
    CURVE.getXData();
  }

  @Test
  public void testEqualsAndHashCode() {
    ConstantDoublesCurve other = new ConstantDoublesCurve(Y1, NAME1);
    assertEquals(CURVE, other);
    assertEquals(CURVE.hashCode(), other.hashCode());
    other = new ConstantDoublesCurve(Y2, NAME1);
    assertFalse(CURVE.equals(other));
    other = new ConstantDoublesCurve(Y1);
    assertFalse(CURVE.equals(other));
    other = new ConstantDoublesCurve(Y1, NAME2);
    assertFalse(CURVE.equals(other));
  }

  @Test
  public void testGetters() {
    assertEquals(CURVE.getName(), NAME1);
    assertEquals(CURVE.getYValue(30.1), Y1, 0);
    assertEquals(CURVE.size(), 1);
    assertArrayEquals(CURVE.getYData(), new Double[] {Y1});
  }

  @Test
  public void testStaticConstruction() {
    ConstantDoublesCurve curve = new ConstantDoublesCurve(Y1);
    ConstantDoublesCurve other = ConstantDoublesCurve.from(Y1);
    assertArrayEquals(curve.getYData(), other.getYData());
    assertFalse(curve.getName().equals(other.getName()));
    curve = new ConstantDoublesCurve(Y1, NAME1);
    other = ConstantDoublesCurve.from(Y1, NAME1);
    assertEquals(curve, other);
  }

  @Test
  public void testConvert() {
    final double eps = 1e-15;
    final double[] x = new double[] {0, 1, 2};
    final double[] y = new double[] {Y1, Y1, Y1};
    final LinearInterpolator1D interpolator = new LinearInterpolator1D();
    InterpolatedDoublesCurve other = CURVE.toInterpolatedDoublesCurve(x, interpolator);
    assertArrayEquals(other.getXDataAsPrimitive(), x, eps);
    assertArrayEquals(other.getYDataAsPrimitive(), y, eps);
  }
}
```


Overlapping Code:
```
static final double Y1 = 20;
private static final double Y2 = 21;
private static final String NAME1 = "a";
private static final String NAME2 = "b";
private static final ConstantDoublesCurve CURVE = new ConstantDoublesCurve(Y1, NAME1);
@Test(expectedExceptions = UnsupportedOperationException.class)
public void testGetXData() {
CURVE.getXData();
}
@Test
public void testEqualsAndHashCode() {
ConstantDoublesCurve other = new ConstantDoublesCurve(Y1, NAME1);
assertEquals(CURVE, other);
assertEquals(CURVE.hashCode(), other.hashCode());
other = new ConstantDoublesCurve(Y2, NAME1);
assertFalse(CURVE.equals(other));
other = new ConstantDoublesCurve(Y1);
assertFalse(CURVE.equals(other));
other = new ConstantDoublesCurve(Y1, NAME2);
assertFalse(CURVE.equals(other));
}
@Test
public void testGetters() {
assertEquals(CURVE.getName(), NAME1);
assertEquals(CURVE.getYValue(30.1), Y1, 0);
assertEquals(CURVE.size(), 1);
assertArrayEquals(CURVE.getYData(), new Double[] {Y1});
}
@Test
public void testStaticConstruction() {
ConstantDoublesCurve curve = new ConstantDoublesCurve(Y1);
ConstantDoublesCurve other = ConstantDoublesCurve.from(Y1);
assertArrayEquals(curve.getYData(), other.getYData());
assertFalse(curve.getName().equals(other.getName()));
curve = new ConstantDoublesCurve(Y1, NAME1);
other = ConstantDoublesCurve.from(Y1, NAME1);
assertEquals(curve, other);
}
@Test
public void testConvert() {
final double eps = 1e-15;
final double[] x = new double[] {0, 1, 2};
final double[] y = new double[] {Y1, Y1, Y1};
final LinearInterpolator1D interpolator = new LinearInterpolator1D();
InterpolatedDoublesCurve other = CURVE.toInterpolatedDoublesCurve(x, interpolator);
assertArrayEquals(other.getXDataAsPrimitive(), x, eps);
assertArrayEquals(other.
```
<Overlap Ratio: 0.9547190398254228>

---

--- 188 --
Question ID: 2690577af099a835ff2c35af294eb925114821bc
Original Code:
```
public class ModelServiceLoader {

    /**
     * Liefert eine Liste mit allen Algorithmen, die das {@code AdaptationAlgorithm}-Interface implementieren.
     *
     * @return eine Liste mit allen Adaptionsalgorithmen
     */
    public Collection<AdaptationAlgorithm> getAdaptAlgorithmList() {
        ArrayList<AdaptationAlgorithm> list = new ArrayList<>();
        ServiceLoader.load(AdaptationAlgorithm.class).iterator().forEachRemaining(list::add);
        return list;
    }

    /**
     * Liefert eine Liste mit allen Algorithmen, die das {@code PairingAlgorithm}-Interface implementieren.
     *
     * @return eine Liste mit allen Paarungsalgorithmen
     */
    public Collection<PairingAlgorithm> getPairAlgorithmList() {
        ArrayList<PairingAlgorithm> list = new ArrayList<>();
        ServiceLoader.load(PairingAlgorithm.class).iterator().forEachRemaining(list::add);
        return list;
    }

    /**
     * Liefert eine Liste mit allen Algorithmen, die das {@code RankingAlgorithm}-Interface implementieren.
     *
     * @return eine Liste mit allen Bewertungsalgorithmen
     */
    public Collection<RankingAlgorithm> getRankAlgorithmList() {
        ArrayList<RankingAlgorithm> list = new ArrayList<>();
        ServiceLoader.load(RankingAlgorithm.class).iterator().forEachRemaining(list::add);
        return list;
    }

    /**
     * Liefert eine Liste mit allen Bedingungen, die das {@code Condition}-Interface implementieren.
     *
     * @return eine Liste mit allen Bedingungen
     */
    public Collection<Condition> getConditionList() {
        ArrayList<Condition> list = new ArrayList<>();
        ServiceLoader.load(Condition.class).iterator().forEachRemaining(list::add);
        return list;
    }

    /**
     * Liefert eine Liste mit allen Strategien, die das {@code BaseStrategy}-Interface implementieren.
     *
     * @return eine Liste mit allen Basis-Strategien
     */
    public Collection<BaseStrategy> getBaseStrategyList() {
        ArrayList<BaseStrategy> list = new ArrayList<>();
        ServiceLoader.load(BaseStrategy.class).iterator().forEachRemaining(list::add);
        return list;
    }

}
```


Overlapping Code:
```
 {
/**
* Liefert eine Liste mit allen Algorithmen, die das {@code AdaptationAlgorithm}-Interface implementieren.
*
* @return eine Liste mit allen Adaptionsalgorithmen
*/
public Collection<AdaptationAlgorithm> getAdaptAlgorithmList() {
ArrayList<AdaptationAlgorithm> list = new ArrayList<>();
ServiceLoader.load(AdaptationAlgorithm.class).iterator().forEachRemaining(list::add);
return list;
}
/**
* Liefert eine Liste mit allen Algorithmen, die das {@code PairingAlgorithm}-Interface implementieren.
*
* @return eine Liste mit allen Paarungsalgorithmen
*/
public Collection<PairingAlgorithm> getPairAlgorithmList() {
ArrayList<PairingAlgorithm> list = new ArrayList<>();
ServiceLoader.load(PairingAlgorithm.class).iterator().forEachRemaining(list::add);
return list;
}
/**
* Liefert eine Liste mit allen Algorithmen, die das {@code RankingAlgorithm}-Interface implementieren.
*
* @return eine Liste mit allen Bewertungsalgorithmen
*/
public Collection<RankingAlgorithm> getRankAlgorithmList() {
ArrayList<RankingAlgorithm> list = new ArrayList<>();
ServiceLoader.load(RankingAlgorithm.class).iterator().forEachRemaining(list::add);
return list;
}
/**
* Liefert eine Liste mit allen Bedingungen, die das {@code Condition}-Interface implementieren.
*
* @return eine Liste mit allen Bedingungen
*/
public Collection<Condition> getConditionList() {
ArrayList<Condition> list = new ArrayList<>();
ServiceLoader.load(Condition.class).iterator().forEachRemaining(list::add);
return list;
}
/**
* Liefert eine Liste mit allen Strategien, die das {@code BaseStrategy}-Interface implementieren.
*
* @return eine Liste mit allen Basis-Strategien
*/
public Collection<BaseStrategy> getBaseStrategyList() {
ArrayList<BaseStrategy> list = new ArrayList<>();
ServiceLoader.load(BaseStrategy.class).iterator().forEachRemaining(list::add);
return list;
}

```
<Overlap Ratio: 0.9828877005347594>

---

--- 189 --
Question ID: 4641d2e9a5af6f1bf0a386fc4e83e19729eae3c3
Original Code:
```
public class DefaultApiKeysGenerator implements ApiKeysGenerator {

	private static final long serialVersionUID = -5113876047087704787L;
	
	protected String algorithm;
	protected String encoding;
	
	@Override
	public String [] generate () throws ApiKeysGeneratorException {
		
		if (Lang.isNullOrEmpty (algorithm)) {
			algorithm = "HMACSHA1";
		}
		
		if (Lang.isNullOrEmpty (encoding)) {
			encoding = Encodings.UTF8;
		}
		
		try {
			KeyGenerator generator = KeyGenerator.getInstance (algorithm);

			generator.init (120);
			byte[] accessKey = generator.generateKey ().getEncoded ();

			generator.init (240);
			byte[] secretKey = generator.generateKey ().getEncoded ();

			return new String [] {hash (accessKey, encoding), hash (secretKey, encoding)};
		} catch (Exception ex) {
			throw new ApiKeysGeneratorException (ex);
		}
		
	}

	public void setAlgorithm (String algorithm) {
		this.algorithm = algorithm;
	}
	public String getAlgorithm () {
		return algorithm;
	}

	public void setEncoding (String encoding) {
		this.encoding = encoding;
	}
	public String getEncoding () {
		return encoding;
	}

	private static String hash (byte [] key, String encoding) throws Exception {
		return new String (Base64.encodeBase64 (key), encoding).trim ();
	}
	
	public static void main(String[] args) throws ApiKeysGeneratorException {
		String [] keys = new DefaultApiKeysGenerator ().generate ();
		System.out.println (keys [0]);
		System.out.println (keys [1]);
	}
	
}
```


Overlapping Code:
```
s DefaultApiKeysGenerator implements ApiKeysGenerator {
private static final long serialVersionUID = -5113876047087704787L;

protected String algorithm;
protected String encoding;

@Override
public String [] generate () throws ApiKeysGeneratorException {

if (Lang.isNullOrEmpty (algorithm)) {
algorithm = "HMACSHA1";
}

if (Lang.isNullOrEmpty (encoding)) {
encoding = Encodings.UTF8;
}

try {
KeyGenerator generator = KeyGenerator.getInstance (algorithm);
generator.init (120);
byte[] accessKey = generator.generateKey ().getEncoded ();
generator.init (240);
byte[] secretKey = generator.generateKey ().getEncoded ();
return new String [] {hash (accessKey, encoding), hash (secretKey, encoding)};
} catch (Exception ex) {
throw new ApiKeysGeneratorException (ex);
}

}
public void setAlgorithm (String algorithm) {
this.algorithm = algorithm;
}
public String getAlgorithm () {
return algorithm;
}
public void setEncoding (String encoding) {
this.encoding = encoding;
}
public String getEncoding () {
return encoding;
}
private static String hash (byte [] key, String encoding) throws Exception {
return new String (Base64.encodeBase64 (key), encoding).trim ();
}

public static void main(String[] args) throws ApiKeysGeneratorException {
String [] keys = new DefaultApiKeysGenerator ().generate ();
System.out.println (keys [0]);
System.out.println 
```
<Overlap Ratio: 0.9803921568627451>

---

--- 190 --
Question ID: bbc74af564193bf70d4ec54a2c0dee0605588592
Original Code:
```
public class SqliteTest {

    @Before
    public void testInitDB(){
        Sqlite.getSqlite().initDB();
    }

    @Test
    public void testInsertId(){
        String sql = "insert into roles(service, role_name, type, ping_url, metric, client_id, members, add_time) " +
                "VALUES ('lzz-cpu','aaa','ping','http://',"+1+",'127.0.0.1','@all',1)";
        int id = Sqlite.getSqlite().insertId( sql );
        System.out.println(id);
    }

    @Test
    public void testSelectRow(){
        String sql = "select id from roles where role_name='0:0:0:0:0:0:0:1_null'";
        Map map = Sqlite.getSqlite().selectRow(sql);
        System.out.println(map);
    }

    @Test
    public void testSelects(){
        String sql = "select id from roles";
        List list = Sqlite.getSqlite().select( sql );
        System.out.println( list );
    }
}
```


Overlapping Code:
```
tInitDB(){
Sqlite.getSqlite().initDB();
}
@Test
public void testInsertId(){
String sql = "insert into roles(service, role_name, type, ping_url, metric, client_id, members, add_time) " +
"VALUES ('lzz-cpu','aaa','ping','http://',"+1+",'127.0.0.1','@all',1)";
int id = Sqlite.getSqlite().insertId( sql );
System.out.println(id);
}
@Test
public void testSelectRow(){
String sql = "select id from roles where role_name='0:0:0:0:0:0:0:1_null'";
Map map = Sqlite.getSqlite().selectRow(sql);
System.out.println(map);
}
@Test
public void testSelects(){
String sql = "select id from roles";
List list = Sqlite.getSqlite().select( sql );
System.out.println( li
```
<Overlap Ratio: 0.9180790960451978>

---

--- 191 --
Question ID: 2d5b29148a8b28dba3c22519968dbe2adfed787a
Original Code:
```
@ExtensionPoint(
  id = "FileOpenSaveNewExtensionPoint",
  extensionPointId = "SpoonOpenSaveNew",
  description = "Open the new file browser"
)
public class FileOpenSaveExtensionPoint implements ExtensionPointInterface {

  private static final String TRANSFORMATION = "transformation";
  private static final String REPOSITORY = "repository";

  private static final int WIDTH = ( Const.isOSX() || Const.isLinux() ) ? 930 : 947;
  private static final int HEIGHT = ( Const.isOSX() || Const.isLinux() ) ? 618 : 626;

  private Supplier<Spoon> spoonSupplier = Spoon::getInstance;

  @Override public void callExtensionPoint( LogChannelInterface logChannelInterface, Object o ) throws KettleException {
    FileDialogOperation fileDialogOperation = (FileDialogOperation) o;

    FileOpenSaveDialog repositoryOpenSaveDialog =
      new FileOpenSaveDialog( spoonSupplier.get().getShell(), WIDTH, HEIGHT, logChannelInterface );

    resolveProvider( fileDialogOperation );
    repositoryOpenSaveDialog.open( fileDialogOperation );

    if ( repositoryOpenSaveDialog.getProvider() != null && repositoryOpenSaveDialog.getProvider()
      .equalsIgnoreCase( REPOSITORY ) ) {
      RepositoryObject repositoryObject = new RepositoryObject();
      repositoryObject.setObjectId( repositoryOpenSaveDialog::getObjectId );
      repositoryObject.setName( repositoryOpenSaveDialog.getName() );
      repositoryObject
        .setRepositoryDirectory( getRepository().findDirectory( repositoryOpenSaveDialog.getParentPath() ) );
      if ( repositoryOpenSaveDialog.getType() != null ) {
        repositoryObject.setObjectType(
          repositoryOpenSaveDialog.getType().equals( TRANSFORMATION ) ? RepositoryObjectType.TRANSFORMATION
            : RepositoryObjectType.JOB );
      }
      fileDialogOperation.setRepositoryObject( repositoryObject );
      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );
      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );
    } else {
      fileDialogOperation.setPath( repositoryOpenSaveDialog.getPath() );
      fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );
      fileDialogOperation.setConnection( repositoryOpenSaveDialog.getConnection() );
      fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );
    }
  }

  private void resolveProvider( FileDialogOperation op ) {
    if ( op.getProvider() == null ) {
      if ( op.getConnection() != null ) {
        op.setProvider( VFSFileProvider.TYPE );
      } else if ( spoonSupplier.get().rep != null ) {
        op.setProvider( RepositoryFileProvider.TYPE );
      } else {
        op.setProvider( LocalFileProvider.TYPE );
      }
    }
  }

  private Repository getRepository() {
    return RepositoryBrowserController.repository != null ? RepositoryBrowserController.repository
      : spoonSupplier.get().getRepository();
  }
}
```


Overlapping Code:
```
enSaveNewExtensionPoint",
extensionPointId = "SpoonOpenSaveNew",
description = "Open the new file browser"
)
public class FileOpenSaveExtensionPoint implements ExtensionPointInterface {
private static final String TRANSFORMATION = "transformation";
private static final String REPOSITORY = "repository";
private static final int WIDTH = ( Const.isOSX() || Const.isLinux() ) ? 930 : 947;
private static final int HEIGHT = ( Const.isOSX() || Const.isLinux() ) ? 618 : 626;
private Supplier<Spoon> spoonSupplier = Spoon::getInstance;
@Override public void callExtensionPoint( LogChannelInterface logChannelInterface, Object o ) throws KettleException {
FileDialogOperation fileDialogOperation = (FileDialogOperation) o;
FileOpenSaveDialog repositoryOpenSaveDialog =
new FileOpenSaveDialog( spoonSupplier.get().getShell(), WIDTH, HEIGHT, logChannelInterface );
resolveProvider( fileDialogOperation );
repositoryOpenSaveDialog.open( fileDialogOperation );
if ( repositoryOpenSaveDialog.getProvider() != null && repositoryOpenSaveDialog.getProvider()
.equalsIgnoreCase( REPOSITORY ) ) {
RepositoryObject repositoryObject = new RepositoryObject();
repositoryObject.setObjectId( repositoryOpenSaveDialog::getObjectId );
repositoryObject.setName( repositoryOpenSaveDialog.getName() );
repositoryObject
.setRepositoryDirectory( getRepository().findDirectory( repositoryOpenSaveDialog.getParentPath() ) );
if ( repositoryOpenSaveDialog.getType() != null ) {
repositoryObject.setObjectType(
repositoryOpenSaveDialog.getType().equals( TRANSFORMATION ) ? RepositoryObjectType.TRANSFORMATION
: RepositoryObjectType.JOB );
}
fileDialogOperation.setRepositoryObject( repositoryObject );
fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );
fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );
} else {
fileDialogOperation.setPath( repositoryOpenSaveDialog.getPath() );
fileDialogOperation.setFilename( repositoryOpenSaveDialog.getName() );
fileDialogOperation.setConnection( repositoryOpenSaveDialog.getConnection() );
fileDialogOperation.setProvider( repositoryOpenSaveDialog.getProvider() );
}
}
private void resolveProvider( FileDialogOperation op ) {
if ( op.getProvider() == null ) {
if ( op.getConnection() != null ) {
op.setProvide
```
<Overlap Ratio: 0.9851851851851852>

---

--- 192 --
Question ID: 7ebaf9ef0e6d725cf6d6043ed9966d8710fe3a12
Original Code:
```
public class CommandManager {

    private Map<String, CommandTemplate> commands = new HashMap<>();
    private Map<String, List<CommandExecutor>> commandExecutors = new HashMap<>();
    private String customChar;
    private TS3Api api;
    private List<Thread> commandThreads = new ArrayList<>();
    private Thread listenerThread;
    private List<String> registeredCommands = new ArrayList<>();
    private Teamspeak3Bot instance;

    public CommandManager(TS3Api api, char customChar, Teamspeak3Bot instance) {

        registeredCommands.add("quit");
        registeredCommands.add("exit");
        registeredCommands.add("stop");
        registeredCommands.add("uploadErrorLog");

        this.customChar = String.valueOf(customChar);
        this.api = api;
        this.instance = instance;

        AtomicBoolean breakOut = new AtomicBoolean(false);

        listenerThread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(60000);
                    int x = commandThreads.size();

                    if (x == 0) {
                        instance.debug(Language.COMMAND, "Nothing found to remove.");
                        run();
                    }

                    for (int i = x - 1; i >= 0; i--) {

                        Thread thr = commandThreads.get(i);
                        if (thr.isInterrupted() || !thr.isAlive()) {
                            commandThreads.remove(thr);
                            instance.debug(Language.COMMAND, "Thread " + thr.getName() + " removed from list.");
                        }
                    }
                } catch (Exception x) {
                    x.printStackTrace();
                    breakOut.set(true);
                }
                if (!breakOut.get()) {
                    run();
                }
            }
        }, "CommandManager-Thread");
        listenerThread.start();
    }


    public CommandTemplate registerNewCommand(CommandTemplate cmdTemp) {
        commands.put(cmdTemp.getCommand(), cmdTemp);
        return cmdTemp;
    }

    public CommandTemplate getCommand(String name) {
        return commands.getOrDefault(name, null);
    }

    public CommandTemplate getCommand(JavaPlugin plugin, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {
        return getCommand(plugin.getName(), str, cmdEx, cmdTemp);
    }

    public CommandTemplate getCommand(String pluginName, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {
        CommandTemplate cmd = commands.get(str);

        if (cmd == null) {
            cmd = registerNewCommand(cmdTemp);
        }

        List<CommandExecutor> executors = commandExecutors.getOrDefault(str, new ArrayList<>());
        executors.add(cmdEx);

        commandExecutors.put(str, executors);
        List<String> aliasList = cmd.getAliases();
        if (!aliasList.contains(str)) {
            aliasList.add(str);
        }

        // Command cmd = new Command(aliasList.toArray(new String[]{}), description, str, pluginName);
        commands.put(str, cmd);
        for (String s : cmd.getAliases()) {
            registeredCommands.add(pluginName + ":" + s);
            registeredCommands.add(s);
        }
        return cmd;
    }

    public boolean executeCommand(String cmd, String[] args, CommandSender source, int clientId, int channelId, boolean run) {

        String cmdString = getCommandStringFromAlias(resolveCommand(cmd));

        if (!Validator.notNull(api)) {

            if (commands.containsKey(cmdString)) {
                if (run) {
                    Map<String, String> map = new HashMap<>();
                    map.put("invokerid", clientId + "");
                    map.put("channelid", channelId + "");
                    parseRun(cmd, args, source, map);
                }
                return true;
            }
        } else
            Teamspeak3Bot.getLogger().error(Language.COMMAND + "API is null !!!!");
        return false;
    }

    private void parseRun(String cmd, String[] args, CommandSender source, Map<String, String> map) {

        List<CommandExecutor> executors = commandExecutors.getOrDefault(getCommandStringFromAlias(resolveCommand(cmd)), new ArrayList<>());
        CommandTemplate cmdTemp = commands.get(getCommandStringFromAlias(resolveCommand(cmd)));

        for (CommandExecutor executor : executors) {
            //To prevent a constant loop in the command
            Thread thread = new Thread(() -> executor.run(source, new Command(cmdTemp, map), cmd, args), cmdTemp.getCommand() + "-" + commandThreads.size());
            commandThreads.add(thread);
            instance.debug(Language.COMMAND, thread.getName());

            thread.start();
        }
    }

    public boolean checkCommand(String cmdString, int clientId, CommandSender source) {
        return checkCommand(new String[]{cmdString}, clientId, source);
    }

    public boolean checkCommand(String[] cmd, int clientId, CommandSender source) {
        List<String> aList = new ArrayList<>();
        Collections.addAll(aList, cmd);

        String consoleMessage = "Command From %source%: " + aList.get(0);

        aList.set(0, aList.get(0).replaceFirst(customChar, ""));
        consoleMessage = consoleMessage.replaceAll("%source%", source.toString().toLowerCase());

        instance.debug(Language.COMMAND, consoleMessage);
        instance.debug(Language.COMMAND, "Custom Prefix Key: " + customChar);

        String str = getCommandStringFromAlias(resolveCommand(aList.get(0)));

        if (!(source instanceof ConsoleCommandSender) && !(cmd[0].startsWith(customChar))) {
            return false;
        }

        if (str != null) {
            CommandTemplate cCommand = commands.get(str);
            String cPlugin = cCommand.getPlugin();
            List<String> cAliases = cCommand.getAliases();
            instance.debug(Language.COMMAND, cPlugin + ":" + str + ", " + Arrays.toString(cAliases.toArray()));
            return true;
        }

        source.sendMessage(0, clientId, "Unknown Command: " + cmd[0]);
        source.sendMessage(0, clientId, "Please use help or ? for help");
        return false;
    }

    public String getCommandStringFromAlias(String alias) {

        for (String key : commands.keySet()) {
            if (alias.equalsIgnoreCase(key)) {
                return key;
            }
            List<String> values = commands.get(key).getAliases();
            for (String value : values) {
                if (alias.equalsIgnoreCase(value)) {
                    return key;
                }
            }
        }

        return null;
    }

    public String resolveCommand(String arg) {
        String[] str = arg.split(":+");
        String command = "";

        if (str.length == 1) {
            command = str[0];
        } else if (str.length > 1) {
            if (commands.containsKey(getCommandStringFromAlias(str[1]))) {
                if (commands.get(getCommandStringFromAlias(str[1])).getPlugin().equalsIgnoreCase(str[0])) {
                    command = str[1];
                }
            }
        }
        return command;
    }

    public String getCommandFromArray(String[] cmdArray) {
        return cmdArray[0].replaceFirst(String.valueOf(customChar), "");
    }

    public List<String> getCommandList() {
        return registeredCommands;
    }

    public Map<String, CommandTemplate> getCommands() {
        return commands;
    }
}
```


Overlapping Code:
```
public class CommandManager {
private Map<String, CommandTemplate> commands = new HashMap<>();
private Map<String, List<CommandExecutor>> commandExecutors = new HashMap<>();
private String customChar;
private TS3Api api;
private List<Thread> commandThreads = new ArrayList<>();
private Thread listenerThread;
private List<String> registeredCommands = new ArrayList<>();
private Teamspeak3Bot instance;
public CommandManager(TS3Api api, char customChar, Teamspeak3Bot instance) {
registeredCommands.add("quit");
registeredCommands.add("exit");
registeredCommands.add("stop");
registeredCommands.add("uploadErrorLog");
this.customChar = String.valueOf(customChar);
this.api = api;
this.instance = instance;
AtomicBoolean breakOut = new AtomicBoolean(false);
listenerThread = new Thread(new Runnable() {
@Override
public void run() {
try {
Thread.sleep(60000);
int x = commandThreads.size();
if (x == 0) {
instance.debug(Language.COMMAND, "Nothing found to remove.");
run();
}
for (int i = x - 1; i >= 0; i--) {
Thread thr = commandThreads.get(i);
if (thr.isInterrupted() || !thr.isAlive()) {
commandThreads.remove(thr);
instance.debug(Language.COMMAND, "Thread " + thr.getName() + " removed from list.");
}
}
} catch (Exception x) {
x.printStackTrace();
breakOut.set(true);
}
if (!breakOut.get()) {
run();
}
}
}, "CommandManager-Thread");
listenerThread.start();
}
public CommandTemplate registerNewCommand(CommandTemplate cmdTemp) {
commands.put(cmdTemp.getCommand(), cmdTemp);
return cmdTemp;
}
public CommandTemplate getCommand(String name) {
return commands.getOrDefault(name, null);
}
public CommandTemplate getCommand(JavaPlugin plugin, String str, CommandExecutor cmdEx, CommandTemplate cmdTemp) {
return getCommand(plugin.getName(), str, cmdEx, cmdTemp);
}
public CommandTemplate getCo
```
<Overlap Ratio: 0.9813698630136987>

---

--- 193 --
Question ID: 5d9065b7917c993b8a7ad8ee635ff4bebdbd5189
Original Code:
```
public class MultisigAccountGraphInfoDTO {
  @SerializedName("level")
  private Integer level = null;

  @SerializedName("multisigEntries")
  private List<MultisigAccountInfoDTO> multisigEntries = new ArrayList<MultisigAccountInfoDTO>();

  public MultisigAccountGraphInfoDTO level(Integer level) {
    this.level = level;
    return this;
  }

   /**
   * Get level
   * @return level
  **/
  @ApiModelProperty(required = true, value = "")
  public Integer getLevel() {
    return level;
  }

  public void setLevel(Integer level) {
    this.level = level;
  }

  public MultisigAccountGraphInfoDTO multisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {
    this.multisigEntries = multisigEntries;
    return this;
  }

  public MultisigAccountGraphInfoDTO addMultisigEntriesItem(MultisigAccountInfoDTO multisigEntriesItem) {
    this.multisigEntries.add(multisigEntriesItem);
    return this;
  }

   /**
   * Get multisigEntries
   * @return multisigEntries
  **/
  @ApiModelProperty(required = true, value = "")
  public List<MultisigAccountInfoDTO> getMultisigEntries() {
    return multisigEntries;
  }

  public void setMultisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {
    this.multisigEntries = multisigEntries;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MultisigAccountGraphInfoDTO multisigAccountGraphInfoDTO = (MultisigAccountGraphInfoDTO) o;
    return Objects.equals(this.level, multisigAccountGraphInfoDTO.level) &&
        Objects.equals(this.multisigEntries, multisigAccountGraphInfoDTO.multisigEntries);
  }

  @Override
  public int hashCode() {
    return Objects.hash(level, multisigEntries);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MultisigAccountGraphInfoDTO {\n");
    
    sb.append("    level: ").append(toIndentedString(level)).append("\n");
    sb.append("    multisigEntries: ").append(toIndentedString(multisigEntries)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
```


Overlapping Code:
```
lass MultisigAccountGraphInfoDTO {
@SerializedName("level")
private Integer level = null;
@SerializedName("multisigEntries")
private List<MultisigAccountInfoDTO> multisigEntries = new ArrayList<MultisigAccountInfoDTO>();
public MultisigAccountGraphInfoDTO level(Integer level) {
this.level = level;
return this;
}
/**
* Get level
* @return level
**/
@ApiModelProperty(required = true, value = "")
public Integer getLevel() {
return level;
}
public void setLevel(Integer level) {
this.level = level;
}
public MultisigAccountGraphInfoDTO multisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {
this.multisigEntries = multisigEntries;
return this;
}
public MultisigAccountGraphInfoDTO addMultisigEntriesItem(MultisigAccountInfoDTO multisigEntriesItem) {
this.multisigEntries.add(multisigEntriesItem);
return this;
}
/**
* Get multisigEntries
* @return multisigEntries
**/
@ApiModelProperty(required = true, value = "")
public List<MultisigAccountInfoDTO> getMultisigEntries() {
return multisigEntries;
}
public void setMultisigEntries(List<MultisigAccountInfoDTO> multisigEntries) {
this.multisigEntries = multisigEntries;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
MultisigAccountGraphInfoDTO multisigAccountGraphInfoDTO = (MultisigAccountGraphInfoDTO) o;
return Objects.equals(this.level, multisigAccountGraphInfoDTO.level) &&
Objects.equals(this.multisigEntries, multisigAccountGraphInfoDTO.multisigEntries);
}
@Override
public int hashCode() {
return Objects.hash(level, multisigEntries);
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class MultisigAccountGraphInfoDTO {\n");

sb.append(" level: ").append(toIndentedString(level)).append("\n");
sb.append(" multisigEntries: ").append(toIndentedString(multisigEntries)).append("\n");
sb.append("}");
return sb.toString();
}
/**
* Convert the given object to string with each line indented by 4 spaces
* (except the first line).
*/
private String toIndentedString(java.lang.Object o) {
if (o == null) {
return "null";
}
return o.toString().replace("\n", "\n ");
}
}
```
<Overlap Ratio: 0.9963336388634281>

---

--- 194 --
Question ID: 6767dab337666325589573c903cf855a982aaee7
Original Code:
```
public class Str_ser
{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
System.out.println("enter string");
String w=sc.nextLine();
int al=1;
w=w.trim();
for(int i=0;i<w.length();i++)
{
if(w.charAt(i)==' ')
{
al++;
}
}

String m[]=new String[al];
int h=0;
m[0]="";
for(int j=0;j<w.length();j++)
{
 if(w.charAt(j)==' ')
 {
     h=h+1;
     m[h]="";
    }
    else
    {
    m[h]=m[h]+w.charAt(j);
}
}

for(int k=0;k<al/2;k++)
{
System.out.print(m[k]+" ");
int l=al-k-1;
if(k==l)
{
break;
}
System.out.print(m[al-k-1]+" ");
}
if(al%2!=0)
{
System.out.println(m[al/2]);
}
}
}
```


Overlapping Code:
```
r
{
public static void main(String args[])
{
Scanner sc=new Scanner(System.in);
System.out.println("enter string");
String w=sc.nextLine();
int al=1;
w=w.trim();
for(int i=0;i<w.length();i++)
{
if(w.charAt(i)==' ')
{
al++;
}
}
String m[]=new String[al];
int h=0;
m[0]="";
for(int j=0;j<w.length();j++)
{
if(w.charAt(j)==' ')
{
h=h+1;
m[h]="";
}
else
{
m[h]=m[h]+w.charAt(j);
}
}
for(int k=0;k<al/2;k++)
{
System.out.print(m[k]+" ");
int l=al-k-1;
if(k==l)
{
break;
}
System.out.print(m[al-k-1]+" ");
}
if(al
```
<Overlap Ratio: 0.8910369068541301>

---

--- 195 --
Question ID: 479be213edd9fc6374cba96bf60e6c678a560dcb
Original Code:
```
public class HibernatePropertiesUtil
{
	private HibernatePropertiesUtil() { super(); }
	
	public static void configure(File configFile, Properties props) 
		throws IOException
	{
		File tmpFile = File.createTempFile("HibernatePropertiesUtil", ".properties");
		tmpFile.deleteOnExit();
		BufferedReader br = new BufferedReader(new FileReader(configFile));
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(tmpFile)));
		String line = null;
		while ((line = br.readLine()) != null) {
			int index = line.indexOf('=');
			if (index == -1) index = line.indexOf(' ');
			if (index == -1) {
				out.println(line);
				continue;
			}
			String key = line.substring(0, index);
			if (! props.containsKey(key)) {
				out.println(line);
				continue;
			}
			String delimiter = line.substring(index, index+1);
			String value = line.substring(index+1);
			out.println(key + delimiter + props.getProperty(key)); 
		}
		out.flush();
		out.close();
		br.close();
		FileUtils.copy(tmpFile, configFile);
		tmpFile.delete();
	}
}
```


Overlapping Code:
```
ePropertiesUtil
{
private HibernatePropertiesUtil() { super(); }

public static void configure(File configFile, Properties props) 
throws IOException
{
File tmpFile = File.createTempFile("HibernatePropertiesUtil", ".properties");
tmpFile.deleteOnExit();
BufferedReader br = new BufferedReader(new FileReader(configFile));
PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(tmpFile)));
String line = null;
while ((line = br.readLine()) != null) {
int index = line.indexOf('=');
if (index == -1) index = line.indexOf(' ');
if (index == -1) {
out.println(line);
continue;
}
String key = line.substring(0, index);
if (! props.containsKey(key)) {
out.println(line);
continue;
}
String delimiter = line.substring(index, index+1);
String value = line.substring(index+1);
out.println(key + delimiter + props.getProperty(key)); 
}
out.flush();
out.close();
br.close();
FileUtils.copy(tmpFile,
```
<Overlap Ratio: 0.9414225941422594>

---

--- 196 --
Question ID: 7f063e02da7239b80f8210e703f815bf861362c7
Original Code:
```
@RunWith(Arquillian.class)
@RunAsClient
public class MPClientCollectionTest {
    protected static final Logger LOG = Logger.getLogger(MPCollectionTest.class.getName());
    private static final String WAR_SERVICE = "war_service";
    private static final String WAR_CLIENT = "war_client";

    @Deployment(name=WAR_SERVICE)
    public static Archive<?> serviceDeploy() {
        WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);
        war.addClasses(MPCollectionService.class,
                MPCollectionActivator.class);
        return TestUtil.finishContainerPrepare(war, null, null);
    }

    @Deployment(name=WAR_CLIENT)
    public static Archive<?> clientDeploy() {
        WebArchive war = TestUtil.prepareArchive(WAR_CLIENT);
        war.addClasses(MPCollectionResource.class,
                MPCollectionServiceIntf.class,
                MPPatronActivator.class);
        return TestUtil.finishContainerPrepare(war, null, null);
    }

    static ResteasyClient client;
    @BeforeClass
    public static void before() throws Exception {
        client = (ResteasyClient)ClientBuilder.newClient();
    }

    @AfterClass
    public static void after() throws Exception {
        client.close();
    }

    private String generateURL(String path, String deployName) {
        return PortProviderUtil.generateURL(path, deployName);
    }

    @Test
    public void preTest() throws Exception {
        // pre-test, confirm the service is reachable
        // If this test fails the other tests will not pass
        Response response = client.target(
                generateURL("/theService/ping", WAR_SERVICE)).request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals("pong", response.readEntity(String.class));
    }

    @Test
    public void testStringReturnType() throws Exception {

        // Test service is accessed via injection
        // Test endpoint with simple (String) return type
        Response response = client.target(
                generateURL("/thePatron/checking", WAR_CLIENT)).request().get();
        Assert.assertEquals(200, response.getStatus());
        Assert.assertEquals("pong thePatron", response.readEntity(String.class));
    }

    @Test
    public void testGenericTypeReturnType() throws Exception {
        // Test service is accessed via injection
        // Test endpoint with GenericType return type
        Response response = client.target(
                generateURL("/thePatron/got", WAR_CLIENT)).request().get();
        Assert.assertEquals(200, response.getStatus());
        List<String> l = response.readEntity(new GenericType<List<String>>() {});
        Assert.assertEquals(4, l.size());
        Assert.assertEquals("thePatron", l.get(3));
    }
}
```


Overlapping Code:
```
@RunWith(Arquillian.class)
@RunAsClient
public class MPClientCollectionTest {
protected static final Logger LOG = Logger.getLogger(MPCollectionTest.class.getName());
private static final String WAR_SERVICE = "war_service";
private static final String WAR_CLIENT = "war_client";
@Deployment(name=WAR_SERVICE)
public static Archive<?> serviceDeploy() {
WebArchive war = TestUtil.prepareArchive(WAR_SERVICE);
war.addClasses(MPCollectionService.class,
MPCollectionActivator.class);
return TestUtil.finishContainerPrepare(war, null, null);
}
@Deployment(name=WAR_CLIENT)
public static Archive<?> clientDeploy() {
WebArchive war = TestUtil.prepareArchive(WAR_CLIENT);
war.addClasses(MPCollectionResource.class,
MPCollectionServiceIntf.class,
MPPatronActivator.class);
return TestUtil.finishContainerPrepare(war, null, null);
}
static ResteasyClient client;
@BeforeClass
public static void before() throws Exception {
client = (ResteasyClient)ClientBuilder.newClient();
}
@AfterClass
public static void after() throws Exception {
client.close();
}
private String generateURL(String path, String deployName) {
return PortProviderUtil.generateURL(path, deployName);
}
@Test
public void preTest() throws Exception {
// pre-test, confirm the service is reachable
// If this test fails the other tests will not pass
Response response = client.target(
generateURL("/theService/ping", WAR_SERVICE)).request().get();
Assert.assertEquals(200, response.getStatus());
Assert.assertEquals("pong", response.readEntity(String.class));
}
@Test
public void testStringReturnType() throws Exception {
// Test service is accessed via injection
// Test endpoint with simple (String) return type
Response response = client.target(
generateURL("/thePatron/checking", WAR_CLIENT)).request().get();
Assert.assertEquals(200, response.getStatus());
Assert.assertEquals("pong thePatron", response.readEntity(String.class));
}
@Test
public void testGenericTypeReturnType() throws Exception {
// Test service is accessed via injection
// Test endpoint with GenericType return type
Response response = client.target(
generateURL("/thePat
```
<Overlap Ratio: 0.9933774834437086>

---

--- 197 --
Question ID: 41b8a5b94cbecdbe407aa42e43b737e27fd5674b
Original Code:
```
public class HalfSigmoidValueTransformer implements ValueTransformer<Double> {
    private double _center;
    private double _scale;

    public HalfSigmoidValueTransformer (double min, double expectedMax) {
        _center = min;
        _scale = expectedMax;
    }

    @Override
    public Double transform (Double value) {
        double scaledInput = (value-_center) / (_scale - _center);

        // We only care about the top half.
        return (1/(1+Math.exp(-scaledInput)))*2.0-1.0;
    }

    @Override
    public Double getMaximumValue () {
        return 1.0;
    }
}
```


Overlapping Code:
```
gmoidValueTransformer implements ValueTransformer<Double> {
private double _center;
private double _scale;
public HalfSigmoidValueTransformer (double min, double expectedMax) {
_center = min;
_scale = expectedMax;
}
@Override
public Double transform (Double value) {
double scaledInput = (value-_center) / (_scale - _center);
// We only care about the top half.
return (1/(1+Math.exp(-scaledInput)))*2.0-1.0;
}
@Override
public Double getMaximumValue () {
return 1.0;
}
}
```
<Overlap Ratio: 0.9612244897959183>

---

--- 198 --
Question ID: f52449133dc1b8fb835cce8ab3b487a6fe536655
Original Code:
```
public class MyLockDemo {

    MyLock lock = new MyLock();
    int i = 0;

    public void safeIncrease(){
        for (int j = 0; j < 10000; j++){
            lock.lock();
            i++;
            lock.unlock();
        }
    }

    public void unsafeIncrease(){
        for (int j = 0; j < 10000; j++){
            i++;
        }
    }

    public static void main(String[] args) throws InterruptedException{
        MyLockDemo demo = new MyLockDemo();
        CountDownLatch count = new CountDownLatch(10);
        for (int i = 0; i < 10; i++){
            Thread t = new Thread(() -> {
//                demo.unsafeIncrease(); // 执行结果必然小于100000
                demo.safeIncrease(); // 执行结果等于100000
                count.countDown();
            });
            t.start();
        }
        count.await();
        System.out.println(demo.i);
    }
}
```


Overlapping Code:
```
= new MyLock();
int i = 0;
public void safeIncrease(){
for (int j = 0; j < 10000; j++){
lock.lock();
i++;
lock.unlock();
}
}
public void unsafeIncrease(){
for (int j = 0; j < 10000; j++){
i++;
}
}
public static void main(String[] args) throws InterruptedException{
MyLockDemo demo = new MyLockDemo();
CountDownLatch count = new CountDownLatch(10);
for (int i = 0; i < 10; i++){
Thread t = new Thread(() -> {
// demo.unsafeIncrease(); // 执行结果必然小于100000
demo.safeIncrease(); // 执行结果等于100000
count.countDown();
});
t.start();
}
count.await();
System.out
```
<Overlap Ratio: 0.90311986863711>

---

--- 199 --
Question ID: fa4045814253d6f037396762201ba96f22972330
Original Code:
```
@UseAgent
public class GrpcTest extends AiJarSmokeTest {

  @Test
  @TargetUri("/simple")
  public void doSimpleTest() throws Exception {
    List<Envelope> rdList = mockedIngestion.waitForItems("RequestData", 2);

    Envelope rdEnvelope1 = getRequestEnvelope(rdList, "GET /simple");
    Envelope rdEnvelope2 = getRequestEnvelope(rdList, "example.Greeter/SayHello");
    String operationId = rdEnvelope1.getTags().get("ai.operation.id");

    List<Envelope> rddList =
        mockedIngestion.waitForItemsInOperation("RemoteDependencyData", 1, operationId);
    // auto-collected grpc events are suppressed by exporter because they are noisy
    assertEquals(0, mockedIngestion.getCountForType("MessageData", operationId));

    Envelope rddEnvelope = getDependencyEnvelope(rddList, "example.Greeter/SayHello");

    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();
    RemoteDependencyData rdd =
        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();

    assertEquals("localhost:10203", rdd.getTarget());

    assertTrue(rd1.getProperties().isEmpty());
    assertTrue(rd1.getSuccess());

    assertTrue(rdd.getProperties().isEmpty());
    assertTrue(rdd.getSuccess());

    // TODO (trask): verify rd2

    assertParentChild(rd1, rdEnvelope1, rddEnvelope, "GET /simple");
    assertParentChild(
        rdd.getId(), rddEnvelope, rdEnvelope2, "GET /simple", "example.Greeter/SayHello", false);
  }

  @Test
  @TargetUri("/conversation")
  public void doConversationTest() throws Exception {
    List<Envelope> rdList = mockedIngestion.waitForItems("RequestData", 2);

    Envelope rdEnvelope1 = getRequestEnvelope(rdList, "GET /conversation");
    Envelope rdEnvelope2 = getRequestEnvelope(rdList, "example.Greeter/Conversation");
    String operationId = rdEnvelope1.getTags().get("ai.operation.id");

    List<Envelope> rddList =
        mockedIngestion.waitForItemsInOperation("RemoteDependencyData", 1, operationId);
    // auto-collected grpc events are suppressed by exporter because they are noisy
    assertEquals(0, mockedIngestion.getCountForType("MessageData", operationId));

    Envelope rddEnvelope = getDependencyEnvelope(rddList, "example.Greeter/Conversation");

    RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();
    RemoteDependencyData rdd =
        (RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();

    assertEquals("localhost:10203", rdd.getTarget());

    assertTrue(rd1.getProperties().isEmpty());
    assertTrue(rd1.getSuccess());

    assertTrue(rdd.getProperties().isEmpty());
    assertTrue(rdd.getSuccess());

    // TODO (trask): verify rd2

    assertParentChild(rd1, rdEnvelope1, rddEnvelope, "GET /conversation");
    assertParentChild(
        rdd.getId(),
        rddEnvelope,
        rdEnvelope2,
        "GET /conversation",
        "example.Greeter/Conversation",
        false);
  }

  private static Envelope getRequestEnvelope(List<Envelope> envelopes, String name) {
    for (Envelope envelope : envelopes) {
      RequestData rd = (RequestData) ((Data<?>) envelope.getData()).getBaseData();
      if (rd.getName().equals(name)) {
        return envelope;
      }
    }
    throw new IllegalStateException("Could not find request with name: " + name);
  }

  private static Envelope getDependencyEnvelope(List<Envelope> envelopes, String name) {
    for (Envelope envelope : envelopes) {
      RemoteDependencyData rdd =
          (RemoteDependencyData) ((Data<?>) envelope.getData()).getBaseData();
      if (rdd.getName().equals(name)) {
        return envelope;
      }
    }
    throw new IllegalStateException("Could not find dependency with name: " + name);
  }
}
```


Overlapping Code:
```
lic class GrpcTest extends AiJarSmokeTest {
@Test
@TargetUri("/simple")
public void doSimpleTest() throws Exception {
List<Envelope> rdList = mockedIngestion.waitForItems("RequestData", 2);
Envelope rdEnvelope1 = getRequestEnvelope(rdList, "GET /simple");
Envelope rdEnvelope2 = getRequestEnvelope(rdList, "example.Greeter/SayHello");
String operationId = rdEnvelope1.getTags().get("ai.operation.id");
List<Envelope> rddList =
mockedIngestion.waitForItemsInOperation("RemoteDependencyData", 1, operationId);
// auto-collected grpc events are suppressed by exporter because they are noisy
assertEquals(0, mockedIngestion.getCountForType("MessageData", operationId));
Envelope rddEnvelope = getDependencyEnvelope(rddList, "example.Greeter/SayHello");
RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();
RemoteDependencyData rdd =
(RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();
assertEquals("localhost:10203", rdd.getTarget());
assertTrue(rd1.getProperties().isEmpty());
assertTrue(rd1.getSuccess());
assertTrue(rdd.getProperties().isEmpty());
assertTrue(rdd.getSuccess());
// TODO (trask): verify rd2
assertParentChild(rd1, rdEnvelope1, rddEnvelope, "GET /simple");
assertParentChild(
rdd.getId(), rddEnvelope, rdEnvelope2, "GET /simple", "example.Greeter/SayHello", false);
}
@Test
@TargetUri("/conversation")
public void doConversationTest() throws Exception {
List<Envelope> rdList = mockedIngestion.waitForItems("RequestData", 2);
Envelope rdEnvelope1 = getRequestEnvelope(rdList, "GET /conversation");
Envelope rdEnvelope2 = getRequestEnvelope(rdList, "example.Greeter/Conversation");
String operationId = rdEnvelope1.getTags().get("ai.operation.id");
List<Envelope> rddList =
mockedIngestion.waitForItemsInOperation("RemoteDependencyData", 1, operationId);
// auto-collected grpc events are suppressed by exporter because they are noisy
assertEquals(0, mockedIngestion.getCountForType("MessageData", operationId));
Envelope rddEnvelope = getDependencyEnvelope(rddList, "example.Greeter/Conversation");
RequestData rd1 = (RequestData) ((Data<?>) rdEnvelope1.getData()).getBaseData();
RemoteDependencyData rdd =
(RemoteDependencyData) ((Data<?>) rddEnvelope.getData()).getBaseData();
assertEquals("localho
```
<Overlap Ratio: 0.979636048526863>

---

--- 200 --
Question ID: a0c31dbd4eb4ecd3c4e8ed833c6b3df064333380
Original Code:
```
public class TestUtil {

    public static Operand operand(String key, String value) {
        Operand operand = new Operand();
        Field field = new Field();
        field.setKey(key);
        field.setValue(value);
        operand.setField(field);
        return operand;
    }

    public static Dispatcher dispatcher(String endpoint, Dispatcher.Type type) {
        Dispatcher dispatcher = new Dispatcher();
        dispatcher.setEndpoint(endpoint);
        dispatcher.setType(type);
        return dispatcher;
    }

    public static User user(String id) {
        User user = new User();
        user.setId(id);
        return user;
    }
}
```


Overlapping Code:
```
ic static Operand operand(String key, String value) {
Operand operand = new Operand();
Field field = new Field();
field.setKey(key);
field.setValue(value);
operand.setField(field);
return operand;
}
public static Dispatcher dispatcher(String endpoint, Dispatcher.Type type) {
Dispatcher dispatcher = new Dispatcher();
dispatcher.setEndpoint(endpoint);
dispatcher.setType(type);
return dispatcher;
}
public static User user(String id) {
User user = new User();
user.setId(id);
return user;
}

```
<Overlap Ratio: 0.9442307692307692>

---

--- 201 --
Question ID: 3983f0713254782b2320800fb0e18ee5303657ab
Original Code:
```
public class CryptoUtils {

	public static byte[] makeECDSASignature(PrivateKey privateKey, String input) {
		Signature signature;
		byte[] outputBytes = new byte[0];
		try {
			signature = Signature.getInstance("SHA256withECDSA", "BC");
			signature.initSign(privateKey);
			byte[] inputBytes = input.getBytes();
			signature.update(inputBytes);
			byte[] signtureBytes = signature.sign();
			outputBytes = signtureBytes;

		} catch (Exception e) {
			throw new RuntimeException(e);
		}
		return outputBytes;
	}


	public static boolean verifyECDSASignature(PublicKey publicKey, byte[] data, byte[] signatureBytes) {
		Signature sig;
		try {
			sig = Signature.getInstance("SHA256withECDSA", "BC");
			sig.initVerify(publicKey);
			sig.update(data);
			if (!sig.verify(signatureBytes))
			{
				//System.out.println("Fail");
				return false;
			} else {
				//System.out.println("Good");
				return true;
			}
		} catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | SignatureException e) {
			e.printStackTrace();
		}
		return false;


	}

	public static String getStringFromKey(Key key) {
		return Base64.getEncoder().encodeToString(key.getEncoded());
	}

}
```


Overlapping Code:
```
ss CryptoUtils {
public static byte[] makeECDSASignature(PrivateKey privateKey, String input) {
Signature signature;
byte[] outputBytes = new byte[0];
try {
signature = Signature.getInstance("SHA256withECDSA", "BC");
signature.initSign(privateKey);
byte[] inputBytes = input.getBytes();
signature.update(inputBytes);
byte[] signtureBytes = signature.sign();
outputBytes = signtureBytes;
} catch (Exception e) {
throw new RuntimeException(e);
}
return outputBytes;
}
public static boolean verifyECDSASignature(PublicKey publicKey, byte[] data, byte[] signatureBytes) {
Signature sig;
try {
sig = Signature.getInstance("SHA256withECDSA", "BC");
sig.initVerify(publicKey);
sig.update(data);
if (!sig.verify(signatureBytes))
{
//System.out.println("Fail");
return false;
} else {
//System.out.println("Good");
return true;
}
} catch (NoSuchAlgorithmException | NoSuchProviderException | InvalidKeyException | SignatureException e) {
e.printStackTrace();
}
return false;
}
public static String getStringFromKey(Key key) {
return Base64.getEncoder().encodeToString(key.getEncoded());
}

```
<Overlap Ratio: 0.9899175068744271>

---

--- 202 --
Question ID: 3e640f396d26823a541044cc8314cd2cec6f5cbd
Original Code:
```
public class BigDecimalTests {

    @Test
    void test1() {
        float f1 = 1.0f - 0.9f;
        float f2 = 0.9f - 0.8f;

        assertThat(f1 == f2).isTrue();
    }

    @Test
    void test2() {
        BigDecimal a = new BigDecimal("0.1");
        BigDecimal b = new BigDecimal("0.9");
        BigDecimal c = new BigDecimal("0.8");

        final BigDecimal subtract = b.subtract(c);

        assertThat(subtract).isEqualTo(a);
    }

    @Test
    void test3() {
        BigDecimal m = new BigDecimal("1.255433");
        BigDecimal n = m.setScale(3, RoundingMode.HALF_DOWN);

        assertThat(n.toString()).isEqualTo("1.255");
    }
}
```


Overlapping Code:
```

@Test
void test1() {
float f1 = 1.0f - 0.9f;
float f2 = 0.9f - 0.8f;
assertThat(f1 == f2).isTrue();
}
@Test
void test2() {
BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");
final BigDecimal subtract = b.subtract(c);
assertThat(subtract).isEqualTo(a);
}
@Test
void test3() {
BigDecimal m = new BigDecimal("1.255433");
BigDecimal n = m.setScale(3, RoundingMode.HALF_DOWN);
assertThat(n.t
```
<Overlap Ratio: 0.8754863813229572>

---

--- 203 --
Question ID: bbfccaf5417cb8b937ed914d8979873e8f65491c
Original Code:
```
public class PinCommandTest {
    private Model testModelNoPinned = new ModelManager(
            getTypicalSourceManager(),
            new UserPrefs(),
            getTypicalDeletedSources(),
            0);
    private Model testModelWithPinned = new ModelManager(
            getTypicalSourceManager(),
            new UserPrefs(),
            getTypicalDeletedSources(),
            2);
    private Model testModelWithMaxPinned = new ModelManager(
            getTypicalSourceManager(),
            new UserPrefs(),
            getTypicalDeletedSources(),
            PinCommand.PINNED_LIMIT);
    private CommandHistory commandHistory = new CommandHistory();

    @Test
    public void execute_basicOperationPinSource_success() {
        int targetIndex = 2;

        Model expectedModel = new ModelManager(
                testModelNoPinned.getSourceManager(),
                new UserPrefs(),
                testModelNoPinned.getDeletedSources(),
                0);

        Source sourceToPin = testModelNoPinned.getFilteredSourceList().get(targetIndex - 1);
        expectedModel.deleteSource(sourceToPin);
        expectedModel.addSourceAtIndex(sourceToPin, 0);

        PinnedSourcesCoordinationCenter.incrementPinnedSources(expectedModel);

        String expectedMessage = String.format(PinCommand.MESSAGE_SUCCESS, sourceToPin);

        assertCommandSuccess(
                new PinCommand(targetIndex),
                testModelNoPinned,
                commandHistory,
                expectedMessage,
                expectedModel);
    }

    @Test
    public void execute_pinAlreadyPinnedSource_failure() {
        int targetIndex = 1;

        String expectedMessage = PinCommand.MESSAGE_SOURCE_PINNED_INVALID;

        assertCommandFailure(
                new PinCommand(targetIndex),
                testModelWithPinned,
                commandHistory,
                expectedMessage);
    }

    @Test
    public void execute_inputIndexZero_failure() {
        int targetIndex = 0;

        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;

        assertCommandFailure(
                new PinCommand(targetIndex),
                testModelWithPinned,
                commandHistory,
                expectedMessage);
    }

    @Test
    public void execute_inputIndexOutOfBounds_failure() {
        int targetIndex = testModelWithPinned.getFilteredSourceList().size() + 1;

        String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;

        assertCommandFailure(
                new PinCommand(targetIndex),
                testModelWithPinned,
                commandHistory,
                expectedMessage);
    }

    @Test
    public void execute_exceedMaxPinnedSources_failure() {
        int targetIndex = PinCommand.PINNED_LIMIT + 1;

        String expectedMessage = PinCommand.MESSAGE_MAX_PINNED_INVALID;

        assertCommandFailure(
                new PinCommand(targetIndex),
                testModelWithMaxPinned,
                commandHistory,
                expectedMessage);
    }
}
```


Overlapping Code:
```
inCommandTest {
private Model testModelNoPinned = new ModelManager(
getTypicalSourceManager(),
new UserPrefs(),
getTypicalDeletedSources(),
0);
private Model testModelWithPinned = new ModelManager(
getTypicalSourceManager(),
new UserPrefs(),
getTypicalDeletedSources(),
2);
private Model testModelWithMaxPinned = new ModelManager(
getTypicalSourceManager(),
new UserPrefs(),
getTypicalDeletedSources(),
PinCommand.PINNED_LIMIT);
private CommandHistory commandHistory = new CommandHistory();
@Test
public void execute_basicOperationPinSource_success() {
int targetIndex = 2;
Model expectedModel = new ModelManager(
testModelNoPinned.getSourceManager(),
new UserPrefs(),
testModelNoPinned.getDeletedSources(),
0);
Source sourceToPin = testModelNoPinned.getFilteredSourceList().get(targetIndex - 1);
expectedModel.deleteSource(sourceToPin);
expectedModel.addSourceAtIndex(sourceToPin, 0);
PinnedSourcesCoordinationCenter.incrementPinnedSources(expectedModel);
String expectedMessage = String.format(PinCommand.MESSAGE_SUCCESS, sourceToPin);
assertCommandSuccess(
new PinCommand(targetIndex),
testModelNoPinned,
commandHistory,
expectedMessage,
expectedModel);
}
@Test
public void execute_pinAlreadyPinnedSource_failure() {
int targetIndex = 1;
String expectedMessage = PinCommand.MESSAGE_SOURCE_PINNED_INVALID;
assertCommandFailure(
new PinCommand(targetIndex),
testModelWithPinned,
commandHistory,
expectedMessage);
}
@Test
public void execute_inputIndexZero_failure() {
int targetIndex = 0;
String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INVALID;
assertCommandFailure(
new PinCommand(targetIndex),
testModelWithPinned,
commandHistory,
expectedMessage);
}
@Test
public void execute_inputIndexOutOfBounds_failure() {
int targetIndex = testModelWithPinned.getFilteredSourceList().size() + 1;
String expectedMessage = PinCommand.MESSAGE_SOURCE_INDEX_INV
```
<Overlap Ratio: 0.9898774640383591>

---

--- 204 --
Question ID: e308ee752f217b9309e2d890de5ccb5f3d116e48
Original Code:
```
@State(Scope.Benchmark)
public class ShakespearePlaysScrabble {
    public static int numProc = Runtime.getRuntime().availableProcessors();
    public static boolean fast;


    /** for words matching the suffix, hash the word and modify the score */
    @Param("ks")
    public String suffix = "ks";

    /** the number of times to hash each word matching the suffix */
    @Param("0")
    public int numHash;
    
    static {
        try { numProc = Integer.parseInt(System.getProperty("np")); }
        catch (Exception ex) {}
        fast = System.getProperty("fast") != null;
    }

    protected void getProperties() {
        suffix = System.getProperty("suffix");
        try { numHash = Integer.parseInt(System.getProperty("numHash")); }
        catch (Exception ex) {}
        try { size = Integer.parseInt(System.getProperty("size")); }
        catch (Exception ex) {}
        try { soft = Integer.parseInt(System.getProperty("soft")); }
        catch (Exception ex) {}
        try { sleep = Integer.parseInt(System.getProperty("sleep")); }
        catch (Exception ex) {}
        mode = System.getProperty("mode");
    }
    
    static public int numPool = Math.max(1,numProc-1);
    
    public static final int [] letterScores = {
    // a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p,  q, r, s, t, u, v, w, x, y,  z
       1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10} ;

    public static final int [] scrabbleAvailableLetters = {
     // a, b, c, d,  e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
        9, 2, 2, 1, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1} ;
    
    
    public Set<String> scrabbleWords = null ;
    private Set<String> words = null ;
    public Iterable<Stringx> shakespeareWords() {
        if (sleep < -1) return LimitSource::new;
        if (sleep == -1) return BurnSource::new;
        return sleep==0 ? Source::new : SleepSource::new;
    }
    AtomicInteger outstanding = new AtomicInteger();


    /**
     * most implementations support a queue size.
     * if this value is non-zero, it is used.
     * otherwise, the size is computed based on the soft limit.
     */
    @Param("0")
    public int size;

    /**
     * the soft limit on the number of outstanding iterator objects.
     * only active for positive sleep values
     */
    @Param("32")
    public int soft = 32;

    /** 
     * for positive values, the number of times to sleep before exceeding the soft limit.
     * if less than -1, only iterate through the first -sleep values.
     * if -1, burn the cpu using an additional task and only use the first 100 values.
     */
    @Param("0")
    public int sleep;

    /**
     * modes allow setting multiple params as a group.
     * only the first letter is needed.
     * supported values are: fast, all, burn, cost, delay, effort.
     * some single letter modes can embed other param values.
     * ie "a200" does 200 iterations and d80 or e80 uses a soft limit of 80.
     */
    @Param({"fast", "all", "burn", "cost", "delay"})
    public String mode;

    // hard limit on the number of soft limit sleeps
    static int MAX_YIELD = 1000;

    boolean startsWith(String txt) { return mode.startsWith(txt.substring(0,1)); }

    void getSoft() {
        try { soft = Integer.parseInt(mode.substring(1)); }
        catch (Exception ex) {}
    }
    void getLimit() {
        try { sleep = -Integer.parseInt(mode.substring(1)); }
        catch (Exception ex) {}
    }
    
    @Setup
    public void init() {
    	scrabbleWords = Util.readScrabbleWords() ;
        words = Util.readShakespeareWords();
        if (mode==null || mode.length()==0);
        else if (startsWith("fast")) {}
        else if (startsWith("all")) { suffix=""; numHash=numHash==0 ? 1000:numHash; sleep=-100; getLimit(); }
        else if (startsWith("burn")) { sleep=-1; }
        else if (startsWith("cost")) { numHash=1000; }
        else if (startsWith("delay")) { sleep=1; getSoft(); }
        else if (startsWith("effort")) { sleep=10; getSoft(); }
        else System.out.println("mode not found, using defaults: " + mode);
        if (sleep <= 0)
            soft = 0;
    }

    class Source implements Iterator<Stringx> {
        Iterator<String> iter = words.iterator();
        public boolean hasNext() { return iter.hasNext(); }
        public Stringx next() { return new Stringx(iter.next()); }
    }

    class SleepSource implements Iterator<Stringx> {
        int maxOut = soft;
        int nyield;
        Iterator<String> iter = words.iterator();
        public boolean hasNext() { return iter.hasNext(); }
        public Stringx next() {
            try {
                int ii=0;
                for (; ii <= sleep && outstanding.get() >= maxOut; ii++)
                    Thread.sleep(ii < sleep ? 0:1);
                if (ii > sleep && ++nyield > MAX_YIELD) {
                    String msg = "number of yields exceeded - shutting down immediately";
                    new AssertionError(msg).printStackTrace();
                    System.exit(1);
                }
                outstanding.incrementAndGet();
                return new Stringx(iter.next());
            }
            catch (InterruptedException ex) {}
            return null;
        }
    }

    class BurnSource implements Iterator<Stringx> {
        int index;
        Thread [] burners = new Thread[numProc];
        Iterator<String> iter = words.iterator();
        {
            for (int ii=0; ii < burners.length; ii++)
                (burners[ii] = new Thread(() -> Blackhole.consumeCPU(100_000_000))).start();
        }
        public boolean hasNext() {
            try {
                Thread.sleep(1);
                if (index < 100)
                    return iter.hasNext();
                for (Thread thread : burners)
                    thread.join();
            }
            catch (InterruptedException ex) {}
            return false;
        }
        public Stringx next() {
            index++;
            return new Stringx(iter.next());
        }
    }
    class LimitSource implements Iterator<Stringx> {
        int index;
        int limit = -sleep;
        Iterator<String> iter = words.iterator();
        public boolean hasNext() {
            if (index < limit)
                return iter.hasNext();
            return false;
        }
        public Stringx next() {
            index++;
            return new Stringx(iter.next());
        }
    }

    public class Stringx {
        public String data;
        public Stringx(String data) { this.data = data; }
        public void dispose() {
            outstanding.decrementAndGet();
        }
    }
}
```


Overlapping Code:
```
cope.Benchmark)
public class ShakespearePlaysScrabble {
public static int numProc = Runtime.getRuntime().availableProcessors();
public static boolean fast;
/** for words matching the suffix, hash the word and modify the score */
@Param("ks")
public String suffix = "ks";
/** the number of times to hash each word matching the suffix */
@Param("0")
public int numHash;

static {
try { numProc = Integer.parseInt(System.getProperty("np")); }
catch (Exception ex) {}
fast = System.getProperty("fast") != null;
}
protected void getProperties() {
suffix = System.getProperty("suffix");
try { numHash = Integer.parseInt(System.getProperty("numHash")); }
catch (Exception ex) {}
try { size = Integer.parseInt(System.getProperty("size")); }
catch (Exception ex) {}
try { soft = Integer.parseInt(System.getProperty("soft")); }
catch (Exception ex) {}
try { sleep = Integer.parseInt(System.getProperty("sleep")); }
catch (Exception ex) {}
mode = System.getProperty("mode");
}

static public int numPool = Math.max(1,numProc-1);

public static final int [] letterScores = {
// a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 4, 4, 8, 4, 10} ;
public static final int [] scrabbleAvailableLetters = {
// a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
9, 2, 2, 1, 12, 2, 3, 2, 9, 1, 1, 4, 2, 6, 8, 2, 1, 6, 4, 6, 4, 2, 2, 1, 2, 1} ;


public Set<String> scrabbleWords = null ;
private Set<String> words = null ;
public Iterable<Stringx> shakespeareWords() {
if (sleep < -1) return LimitSource::new;
if (sleep == -1) return BurnSource::new;
return sleep==0 ? Source::new : SleepSource::new;
}
AtomicInteger outstanding = new AtomicInteger();
/**
* most implementations support a queue size.
* if this value is non-zero, it is used.
* otherwise, the size is computed based on the soft limit.
*/
@Param("0")
public int size;
/**
* the soft limit on the number of outstanding iterator objects.
* only active for positive sleep values
*/
@Param("32")
public int soft = 32;
/** 
* for positive values, the number of times to sleep befo
```
<Overlap Ratio: 0.9866174434702354>

---

--- 205 --
Question ID: 091be020cbd8fd41dd763bacf33ce2d2a44a4880
Original Code:
```
class PropertyHolder
{
	private PropertyLoader loader;

	/** store the properties */
	private Properties defaultProperties;
	private Properties specificProperperties;

	/** store parsed properties */
	private Map<String, Double> doubleProperties;
	private Map<String, Integer> intProperties;

	/**
	 * Creates a new PropertyHolder and loads the files from the specified paths.
	 *
	 * @param defaultPropertiesPath the path of the property file that contains the default properties, if there is no
	 * default property file specify null
	 * @param specificPropertiesPath the path of the property file that contains the specific properties
	 */
	public PropertyHolder(String defaultPropertiesPath, String specificPropertiesPath)
	{
		loader = new PropertyLoader();
		defaultProperties = loader.load(defaultPropertiesPath, true);
		specificProperperties = loader.load(specificPropertiesPath, false);
		doubleProperties = new HashMap<>();
		intProperties = new HashMap<>();
	}

	/**
	 * Returns the property value of the specified key.
	 *
	 * @param key the key of the property
	 * @return the value of the specified key
	 */
	public String getProperty(String key)
	{
		return specificProperperties.getProperty(key);
	}

	/**
	 * Returns the property value of the specified key as a double and stores the parsed value.
	 *
	 * @param key the key of the property
	 * @return the value of the key
	 */
	public double getDoubleProperty(String key)
	{
		Double result = doubleProperties.get(key);

		if (result != null) {
			return result;
		} else {
			try {
				result = Double.parseDouble(specificProperperties.getProperty(key));
				doubleProperties.put(key, result);
				return result;
			} catch (NumberFormatException e) {
				System.err.println("Invalid double property: " + key + " = " + specificProperperties.getProperty(key));
				e.printStackTrace();
				return 1;
			}
		}
	}

	/**
	 * Returns the property value of the specified key as a integer and stores the parsed value.
	 *
	 * @param key the key of the property
	 * @return the value of the key
	 */
	public int getIntegerProperty(String key)
	{
		Integer result = intProperties.get(key);

		if (result != null) {
			return result;
		} else {
			try {
				result = Integer.parseInt(specificProperperties.getProperty(key));
				intProperties.put(key, result);
				return result;
			} catch (NumberFormatException e) {
				System.err.println("Invalid integer property: " + key + " = " + specificProperperties.getProperty(key));
				e.printStackTrace();
				return 1;
			}
		}
	}

	/**
	 * Returns the property value of the specified key as a float and stores the parsed value.
	 *
	 * @param key the key of the property
	 * @return the value of the key
	 */
	public float getFloatProperty(String key)
	{
		return (float) getDoubleProperty(key);
	}

	/**
	 * Returns the property value of the specified key as a short and stores the parsed value.
	 *
	 * @param key the key of the property
	 * @return the value of the key
	 */
	public int getShortProperty(String key)
	{
		return (short) getIntegerProperty(key);
	}

	/**
	 * Returns the property value of the specified key as a byte and stores the parsed value.
	 *
	 * @param key the key of the property
	 * @return the value of the key
	 */
	public int getByteProperty(String key)
	{
		return (byte) getIntegerProperty(key);
	}

	private class PropertyLoader
	{
		/**
		 * Loads a .properties file from the specified path.
		 *
		 * @param path the path of the property file
		 * @param isDefault true if the file to be loaded contains default properties otherwise false
		 * @return a java.util.Properties object containing the properties
		 */
		private Properties load(String path, boolean isDefault)
		{
			if (path == null) {
				return null;
			}

			Properties result = isDefault ? new Properties() : new Properties(defaultProperties);

			try (InputStream in = PropertyLoader.class.getResourceAsStream(path)) {
				result.load(in);
			} catch (IOException e) {
				System.err.println("Unable to load property file from " + path);
				e.printStackTrace();
			}

			return result;
		}
	}
}
```


Overlapping Code:
```
loader;
/** store the properties */
private Properties defaultProperties;
private Properties specificProperperties;
/** store parsed properties */
private Map<String, Double> doubleProperties;
private Map<String, Integer> intProperties;
/**
* Creates a new PropertyHolder and loads the files from the specified paths.
*
* @param defaultPropertiesPath the path of the property file that contains the default properties, if there is no
* default property file specify null
* @param specificPropertiesPath the path of the property file that contains the specific properties
*/
public PropertyHolder(String defaultPropertiesPath, String specificPropertiesPath)
{
loader = new PropertyLoader();
defaultProperties = loader.load(defaultPropertiesPath, true);
specificProperperties = loader.load(specificPropertiesPath, false);
doubleProperties = new HashMap<>();
intProperties = new HashMap<>();
}
/**
* Returns the property value of the specified key.
*
* @param key the key of the property
* @return the value of the specified key
*/
public String getProperty(String key)
{
return specificProperperties.getProperty(key);
}
/**
* Returns the property value of the specified key as a double and stores the parsed value.
*
* @param key the key of the property
* @return the value of the key
*/
public double getDoubleProperty(String key)
{
Double result = doubleProperties.get(key);
if (result != null) {
return result;
} else {
try {
result = Double.parseDouble(specificProperperties.getProperty(key));
doubleProperties.put(key, result);
return result;
} catch (NumberFormatException e) {
System.err.println("Invalid double property: " + key + " = " + specificProperperties.getProperty(key));
e.printStackTrace();
return 1;
}
}
}
/**
* Returns the property value of the specified key as a integer and stores the parsed value.
*
* @param key the key of the property
* @return the value of the key
*/
public int getIntegerProperty(String key)
{
Integer result = intProperties.get(key);
if (result != null) {
return result;
} else {
try {
result = Integer.parseInt(specificProperperties.getProperty(key));
intProperties.put(key, result);
return result;
} catch (NumberFormatException e) {
System.err.println("Invalid integer property: " + key + " = " + specifi
```
<Overlap Ratio: 0.9631849315068494>

---

--- 206 --
Question ID: 2d8246dca5218444ffecab3e4892707a1c1ff186
Original Code:
```
public class RangeSumOfBST {

    static int sum = 0;

    static public int rangeSumBST(TreeNode root, int L, int R) {
        int sum1 = 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.getVal() >= L && node.getVal() <= R) sum1 += node.getVal();
                if (node.getLeft() != null) queue.offer(node.getLeft());
                if (node.getRight() != null) queue.offer(node.getRight());
            }
        }
        return sum1;
    }

    static public int rangeSumBST2(TreeNode root, int L, int R) {

        if (root == null) return 0;

        if (root.getVal() > R) rangeSumBST2(root.getLeft(), L, R);
        if (root.getVal() < L) rangeSumBST2(root.getRight(), L, R);

        return root.getVal() + rangeSumBST2(root.getRight(), L, R) + rangeSumBST2(root.getLeft(), L, R);

    }


    static void f(TreeNode root, int L, int R) {
        if (root == null) return;
        f(root.getLeft(), L, R);
        if (root.getVal() >= L && root.getVal() <= R) sum += root.getVal();
        f(root.getRight(), L, R);
    }

    static public void main(String[] args) {
        TreeNode root = new TreeNode(10).setLeft(new TreeNode(5).setLeft(new TreeNode(3)).setRight(new TreeNode(7)))
                .setRight(new TreeNode(15).setRight(new TreeNode(18)));

        //System.out.println(rangeSumBST(root, 7, 15));
        System.out.println(rangeSumBST2(root, 7, 15));

    }
}
```


Overlapping Code:
```
ass RangeSumOfBST {
static int sum = 0;
static public int rangeSumBST(TreeNode root, int L, int R) {
int sum1 = 0;
Queue<TreeNode> queue = new LinkedList<>();
queue.offer(root);
while (!queue.isEmpty()) {
int size = queue.size();
for (int i = 0; i < size; i++) {
TreeNode node = queue.poll();
if (node.getVal() >= L && node.getVal() <= R) sum1 += node.getVal();
if (node.getLeft() != null) queue.offer(node.getLeft());
if (node.getRight() != null) queue.offer(node.getRight());
}
}
return sum1;
}
static public int rangeSumBST2(TreeNode root, int L, int R) {
if (root == null) return 0;
if (root.getVal() > R) rangeSumBST2(root.getLeft(), L, R);
if (root.getVal() < L) rangeSumBST2(root.getRight(), L, R);
return root.getVal() + rangeSumBST2(root.getRight(), L, R) + rangeSumBST2(root.getLeft(), L, R);
}
static void f(TreeNode root, int L, int R) {
if (root == null) return;
f(root.getLeft(), L, R);
if (root.getVal() >= L && root.getVal() <= R) sum += root.getVal();
f(root.getRight(), L, R);
}
static public void main(String[] args) {
TreeNode root = new TreeNode(10).setLeft(new TreeNode(5).setLeft(new TreeNode(3)).setRight(new TreeNode(7)))
.setRight(new TreeNode(15).setRight(new TreeNode(18)));
//System.out.println(rangeSumBST(root, 7, 15));
System.out.println(rangeSumBST2(root, 7, 15));
}

```
<Overlap Ratio: 0.9923664122137404>

---

--- 207 --
Question ID: d15cf8b971881b1679401ff535080476ff4e7230
Original Code:
```
@DisplayName("`AddDishToOrder` command should be interpreted by `OrderAggregate` and ")
public class AddDishToOrderTest extends OrderCommandTest {

    @Override
    @BeforeEach
    public void setUp() {
        super.setUp();
        final CreateOrder createOrder = createOrderInstance();
        final Command createOrderCommand = requestFactory.command()
                                                         .create(createOrder);
        commandBus.post(createOrderCommand, noOpObserver());
    }

    @Test
    @DisplayName("produce `DishAddedToOrder` event")
    void produceEvent() {
        final AddDishToOrder addDishToOrder = addDishToOrderInstance();

        final Command addDishToOrderCommand = requestFactory.command()
                                                            .create(addDishToOrder);

        final DishAddedToOrderSubscriber dishAddedToOrderSubscriber =
                new DishAddedToOrderSubscriber();

        eventBus.register(dishAddedToOrderSubscriber);

        commandBus.post(addDishToOrderCommand, noOpObserver());

        final DishAddedToOrder event =
                (DishAddedToOrder) dishAddedToOrderSubscriber.getEventMessage();

        assertEquals(addDishToOrder.getOrderId(), event.getOrderId());
        assertEquals(addDishToOrder.getDish(), event.getDish());
    }

    @Test
    @DisplayName("add dish to order")
    void addDishToOrder() {
        final AddDishToOrder addDishToOrder = addDishToOrderInstance();

        final Command addDishToOrderCommand = requestFactory.command()
                                                            .create(addDishToOrder);

        commandBus.post(addDishToOrderCommand, noOpObserver());

        final Optional<Repository> repositoryOptional = boundedContext.findRepository(Order.class);

        assertTrue(repositoryOptional.isPresent());
        assertTrue(repositoryOptional.get() instanceof OrderRepository);
        final OrderRepository orderRepository = (OrderRepository) repositoryOptional.get();

        final Order order = orderRepository.find(ORDER_ID)
                                           .get()
                                           .getState();

        assertEquals(ORDER_ACTIVE, order.getStatus());
        assertEquals(addDishToOrder.getOrderId(), order.getId());
        assertEquals(addDishToOrder.getDish(), order.getDish(0));
    }

    @Test
    @DisplayName("throw `DishVendorMismatch` rejection")
    void notAddDish() {
        final AddDishToOrder addDishToOrder = addDishToOrderInstance(ORDER_ID, INVALID_DISH);
        final DishVendorMismatchSubscriber dishVendorMismatchSubscriber
                = new DishVendorMismatchSubscriber();
        final Command addDishToOrderCommand = requestFactory.command()
                                                            .create(addDishToOrder);

        rejectionBus.register(dishVendorMismatchSubscriber);
        assertNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());

        commandBus.post(addDishToOrderCommand, noOpObserver());
        assertNotNull(OrderTestEnv.DishVendorMismatchSubscriber.getRejection());

        final Rejections.DishVendorMismatch dishVendorMismatch
                = OrderTestEnv.DishVendorMismatchSubscriber.getRejection();

        final VendorId expected = INVALID_DISH.getId()
                                              .getMenuId()
                                              .getVendorId();
        final VendorId actualVendorId = dishVendorMismatch.getVendorMismatch()
                                                  .getActual();
        final VendorId targetVendorId = dishVendorMismatch.getVendorMismatch()
                                                  .getTarget();

        assertEquals(expected, actualVendorId);
        assertEquals(ORDER_ID.getVendorId(), targetVendorId);
    }

    @Test
    @DisplayName("throw `CannotAddDishToNotActiveOrder` rejection")
    void notAddDishToNotActiveOrder() {
        final AddDishToOrder addDishToOrder = addDishToOrderInstance();
        final CancelOrder cancelOrder = cancelOrderInstance();

        final CannotAddDishToNotActiveOrderSubscriber rejectionSubscriber
                = new CannotAddDishToNotActiveOrderSubscriber();

        final Command cancelOrderCommand = requestFactory.command()
                                                         .create(cancelOrder);
        final Command addDishToOrderCommand = requestFactory.command()
                                                            .create(addDishToOrder);

        rejectionBus.register(rejectionSubscriber);
        assertNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());

        commandBus.post(cancelOrderCommand, noOpObserver());
        commandBus.post(addDishToOrderCommand, noOpObserver());
        assertNotNull(OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection());

        final Rejections.CannotAddDishToNotActiveOrder rejection
                = OrderTestEnv.CannotAddDishToNotActiveOrderSubscriber.getRejection();
        assertEquals(ORDER_ID, rejection.getOrderId());
        assertEquals(DISH1.getId(), rejection.getDishId());
    }
}
```


Overlapping Code:
```
@DisplayName("`AddDishToOrder` command should be interpreted by `OrderAggregate` and ")
public class AddDishToOrderTest extends OrderCommandTest {
@Override
@BeforeEach
public void setUp() {
super.setUp();
final CreateOrder createOrder = createOrderInstance();
final Command createOrderCommand = requestFactory.command()
.create(createOrder);
commandBus.post(createOrderCommand, noOpObserver());
}
@Test
@DisplayName("produce `DishAddedToOrder` event")
void produceEvent() {
final AddDishToOrder addDishToOrder = addDishToOrderInstance();
final Command addDishToOrderCommand = requestFactory.command()
.create(addDishToOrder);
final DishAddedToOrderSubscriber dishAddedToOrderSubscriber =
new DishAddedToOrderSubscriber();
eventBus.register(dishAddedToOrderSubscriber);
commandBus.post(addDishToOrderCommand, noOpObserver());
final DishAddedToOrder event =
(DishAddedToOrder) dishAddedToOrderSubscriber.getEventMessage();
assertEquals(addDishToOrder.getOrderId(), event.getOrderId());
assertEquals(addDishToOrder.getDish(), event.getDish());
}
@Test
@DisplayName("add dish to order")
void addDishToOrder() {
final AddDishToOrder addDishToOrder = addDishToOrderInstance();
final Command addDishToOrderCommand = requestFactory.command()
.create(addDishToOrder);
commandBus.post(addDishToOrderCommand, noOpObserver());
final Optional<Repository> repositoryOptional = boundedContext.findRepository(Order.class);
assertTrue(repositoryOptional.isPresent());
assertTrue(repositoryOptional.get() instanceof OrderRepository);
final OrderRepository orderRepository = (OrderRepository) repositoryOptional.get();
final Order order = orderRepository.find(ORDER_ID)
.get()
.getState();
assertEquals(ORDER_ACTIVE, order.getStatus());
assertEquals(addDishToOrder.getOrderId(), order.getId());
assertEquals(addDishToOrder.getDish(), order.getDish(0));
}
@Test
@DisplayName("throw `DishVendorMismatch` rejection")
void
```
<Overlap Ratio: 0.981404958677686>

---

--- 208 --
Question ID: 553fd24b554214847d3ff9c9b63403c55f9b5b41
Original Code:
```
@SuppressWarnings({"serial", "EqualsWhichDoesntCheckParameterClass", 
		"StatementWithEmptyBody", "KeySetIterationMayUseEntrySet"})
public class NonReusingHashJoinIteratorITCase extends TestLogger {
	
	private static final int MEMORY_SIZE = 16000000;		// total memory

	private static final int INPUT_1_SIZE = 20000;
	private static final int INPUT_2_SIZE = 1000;

	private static final long SEED1 = 561349061987311L;
	private static final long SEED2 = 231434613412342L;
	
	private final AbstractInvokable parentTask = new DummyInvokable();

	private IOManager ioManager;
	private MemoryManager memoryManager;
	
	private TypeSerializer<Tuple2<Integer, String>> recordSerializer;
	private TypeComparator<Tuple2<Integer, String>> record1Comparator;
	private TypeComparator<Tuple2<Integer, String>> record2Comparator;
	private TypePairComparator<Tuple2<Integer, String>, Tuple2<Integer, String>> recordPairComparator;
	
	private TypeSerializer<IntPair> pairSerializer;
	private TypeComparator<IntPair> pairComparator;
	private TypePairComparator<IntPair, Tuple2<Integer, String>> pairRecordPairComparator;
	private TypePairComparator<Tuple2<Integer, String>, IntPair> recordPairPairComparator;


	@SuppressWarnings("unchecked")
	@Before
	public void beforeTest() {
		this.recordSerializer = TestData.getIntStringTupleSerializer();
		
		this.record1Comparator = TestData.getIntStringTupleComparator();
		this.record2Comparator = TestData.getIntStringTupleComparator();
		
		this.recordPairComparator = new GenericPairComparator(record1Comparator, record2Comparator);
		
		this.pairSerializer = new IntPairSerializer();
		this.pairComparator = new TestData.IntPairComparator();
		this.pairRecordPairComparator = new IntPairTuplePairComparator();
		this.recordPairPairComparator = new TupleIntPairPairComparator();
		
		this.memoryManager = new MemoryManager(MEMORY_SIZE, 1);
		this.ioManager = new IOManagerAsync();
	}

	@After
	public void afterTest() throws Exception {
		if (this.ioManager != null) {
			this.ioManager.close();
			this.ioManager = null;
		}
		
		if (this.memoryManager != null) {
			Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.",
				this.memoryManager.verifyEmpty());
			this.memoryManager.shutdown();
			this.memoryManager = null;
		}
	}


	@Test
	public void testBuildFirst() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
			
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<Tuple2<Integer, String>>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildFirstHashJoinIterator<>(
						input1, input2, this.recordSerializer, this.record1Comparator, 
						this.recordSerializer, this.record2Comparator, this.recordPairComparator,
						this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);
			
			iterator.open();

			//noinspection StatementWithEmptyBody
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildFirstWithHighNumberOfCommonKeys()
	{
		// the size of the left and right inputs
		final int INPUT_1_SIZE = 200;
		final int INPUT_2_SIZE = 100;
		
		final int INPUT_1_DUPLICATES = 10;
		final int INPUT_2_DUPLICATES = 2000;
		final int DUPLICATE_KEY = 13;
		
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			
			final TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			final TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "LEFT String for Duplicate Keys", INPUT_1_DUPLICATES);
			final TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "RIGHT String for Duplicate Keys", INPUT_2_DUPLICATES);
			
			final List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();
			inList1.add(gen1Iter);
			inList1.add(const1Iter);
			
			final List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();
			inList2.add(gen2Iter);
			inList2.add(const2Iter);
			
			MutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);
			MutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);
			
			
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
			
			// re-create the whole thing for actual processing
			
			// reset the generators and iterators
			generator1.reset();
			generator2.reset();
			const1Iter.reset();
			const2Iter.reset();
			gen1Iter.reset();
			gen2Iter.reset();
			
			inList1.clear();
			inList1.add(gen1Iter);
			inList1.add(const1Iter);
			
			inList2.clear();
			inList2.add(gen2Iter);
			inList2.add(const2Iter);
	
			input1 = new UnionIterator<>(inList1);
			input2 = new UnionIterator<>(inList2);
			
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildFirstHashJoinIterator<>(
						input1, input2, this.recordSerializer, this.record1Comparator, 
						this.recordSerializer, this.record2Comparator, this.recordPairComparator,
						this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);

			iterator.open();
			
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecond() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
			
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values			
			NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildSecondHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator, 
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);

			iterator.open();
			
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecondWithHighNumberOfCommonKeys()
	{
		// the size of the left and right inputs
		final int INPUT_1_SIZE = 200;
		final int INPUT_2_SIZE = 100;
		
		final int INPUT_1_DUPLICATES = 10;
		final int INPUT_2_DUPLICATES = 2000;
		final int DUPLICATE_KEY = 13;
		
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			
			final TestData.TupleGeneratorIterator gen1Iter = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator gen2Iter = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			final TestData.TupleConstantValueIterator const1Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "LEFT String for Duplicate Keys", INPUT_1_DUPLICATES);
			final TestData.TupleConstantValueIterator const2Iter = new TestData.TupleConstantValueIterator(DUPLICATE_KEY, "RIGHT String for Duplicate Keys", INPUT_2_DUPLICATES);
			
			final List<MutableObjectIterator<Tuple2<Integer, String>>> inList1 = new ArrayList<>();
			inList1.add(gen1Iter);
			inList1.add(const1Iter);
			
			final List<MutableObjectIterator<Tuple2<Integer, String>>> inList2 = new ArrayList<>();
			inList2.add(gen2Iter);
			inList2.add(const2Iter);
			
			MutableObjectIterator<Tuple2<Integer, String>> input1 = new UnionIterator<>(inList1);
			MutableObjectIterator<Tuple2<Integer, String>> input2 = new UnionIterator<>(inList2);
			
			
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = joinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
			
			// re-create the whole thing for actual processing
			
			// reset the generators and iterators
			generator1.reset();
			generator2.reset();
			const1Iter.reset();
			const2Iter.reset();
			gen1Iter.reset();
			gen2Iter.reset();
			
			inList1.clear();
			inList1.add(gen1Iter);
			inList1.add(const1Iter);
			
			inList2.clear();
			inList2.add(gen2Iter);
			inList2.add(const2Iter);
	
			input1 = new UnionIterator<>(inList1);
			input2 = new UnionIterator<>(inList2);
			
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();

			NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildSecondHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator, 
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, false, false, true);
			
			iterator.open();
			
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildFirstWithMixedDataTypes() {
		try {
			MutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);
			
			final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			// collect expected data
			final Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(
					collectIntPairData(input1),
					collectTupleData(input2));
			
			final FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			input1 = new UniformIntPairGenerator(500, 40, false);
			generator2.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildSecondHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildSecondHashJoinIterator<>(
						input1, input2, this.pairSerializer, this.pairComparator,
						this.recordSerializer, this.record2Comparator, this.pairRecordPairComparator,
						this.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);
			
			iterator.open();
			
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecondWithMixedDataTypes() {
		try {
			MutableObjectIterator<IntPair> input1 = new UniformIntPairGenerator(500, 40, false);
			
			final TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
			
			// collect expected data
			final Map<Integer, Collection<TupleIntPairMatch>> expectedMatchesMap = joinIntPairs(
					collectIntPairData(input1),
					collectTupleData(input2));
			
			final FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> matcher = new TupleIntPairMatchRemovingMatcher(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			input1 = new UniformIntPairGenerator(500, 40, false);
			generator2.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildFirstHashJoinIterator<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildFirstHashJoinIterator<>(
						input1, input2, this.pairSerializer, this.pairComparator, 
						this.recordSerializer, this.record2Comparator, this.recordPairPairComparator,
						this.memoryManager, this.ioManager, this.parentTask, 1.0, false, false, true);
			
			iterator.open();
			
			while (iterator.callWithNextKey(matcher, collector));
			
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleIntPairMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildFirstAndProbeSideOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildFirstHashJoinIterator<>(
							input1, input2, this.recordSerializer, this.record1Comparator,
							this.recordSerializer, this.record2Comparator, this.recordPairComparator,
							this.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildFirstAndBuildSideOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(
				collectTupleData(input1),
				collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildFirstHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator,
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildFirstAndFullOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 1000, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(
				collectTupleData(input1),
				collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildFirstHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildFirstHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator,
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecondAndProbeSideOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = leftOuterJoinTuples(
					collectTupleData(input1),
					collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
					new NonReusingBuildSecondHashJoinIterator<>(
							input1, input2, this.recordSerializer, this.record1Comparator,
							this.recordSerializer, this.record2Comparator, this.recordPairComparator,
							this.memoryManager, ioManager, this.parentTask, 1.0, true, false, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecondAndBuildSideOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = rightOuterJoinTuples(
				collectTupleData(input1),
				collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildSecondHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator,
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, false, true, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
	
	@Test
	public void testBuildSecondAndFullOuterJoin() {
		try {
			TupleGenerator generator1 = new TupleGenerator(SEED1, 1000, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
			TupleGenerator generator2 = new TupleGenerator(SEED2, 500, 2048, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
	
			final TestData.TupleGeneratorIterator input1 = new TestData.TupleGeneratorIterator(generator1, INPUT_1_SIZE);
			final TestData.TupleGeneratorIterator input2 = new TestData.TupleGeneratorIterator(generator2, INPUT_2_SIZE);
	
			// collect expected data
			final Map<Integer, Collection<TupleMatch>> expectedMatchesMap = fullOuterJoinTuples(
				collectTupleData(input1),
				collectTupleData(input2));
	
			final TupleMatchRemovingJoin matcher = new TupleMatchRemovingJoin(expectedMatchesMap);
			final Collector<Tuple2<Integer, String>> collector = new DiscardingOutputCollector<>();
	
			// reset the generators
			generator1.reset();
			generator2.reset();
			input1.reset();
			input2.reset();
	
			// compare with iterator values
			NonReusingBuildSecondHashJoinIterator<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>> iterator =
				new NonReusingBuildSecondHashJoinIterator<>(
					input1, input2, this.recordSerializer, this.record1Comparator,
					this.recordSerializer, this.record2Comparator, this.recordPairComparator,
					this.memoryManager, ioManager, this.parentTask, 1.0, true, true, false);
	
			iterator.open();
	
			while (iterator.callWithNextKey(matcher, collector));
	
			iterator.close();
	
			// assert that each expected match was seen
			for (Entry<Integer, Collection<TupleMatch>> entry : expectedMatchesMap.entrySet()) {
				if (!entry.getValue().isEmpty()) {
					Assert.fail("Collection for key " + entry.getKey() + " is not empty");
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
			Assert.fail("An exception occurred during the test: " + e.getMessage());
		}
	}
		
	// --------------------------------------------------------------------------------------------
	//                                    Utilities
	// --------------------------------------------------------------------------------------------

	
	
	public static Map<Integer, Collection<TupleMatch>> joinTuples(
			Map<Integer, Collection<String>> leftMap,
			Map<Integer, Collection<String>> rightMap)
	{
		Map<Integer, Collection<TupleMatch>> map = new HashMap<>();

		for (Integer key : leftMap.keySet()) {
			Collection<String> leftValues = leftMap.get(key);
			Collection<String> rightValues = rightMap.get(key);

			if (rightValues == null) {
				continue;
			}

			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<TupleMatch>());
			}

			Collection<TupleMatch> matchedValues = map.get(key);

			for (String leftValue : leftValues) {
				for (String rightValue : rightValues) {
					matchedValues.add(new TupleMatch(leftValue, rightValue));
				}
			}
		}

		return map;
	}

	public static Map<Integer, Collection<TupleMatch>> leftOuterJoinTuples(
			Map<Integer, Collection<String>> leftMap,
			Map<Integer, Collection<String>> rightMap)
	{
		Map<Integer, Collection<TupleMatch>> map = new HashMap<>();

		for (Integer key : leftMap.keySet()) {
			Collection<String> leftValues = leftMap.get(key);
			Collection<String> rightValues = rightMap.get(key);

			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<TupleMatch>());
			}

			Collection<TupleMatch> matchedValues = map.get(key);

			for (String leftValue : leftValues) {
				if(rightValues != null) {
					for (String rightValue : rightValues) {
						matchedValues.add(new TupleMatch(leftValue, rightValue));
					}
				}
				else {
					matchedValues.add(new TupleMatch(leftValue, null));
				}
			}
		}

		return map;
	}

	public static Map<Integer, Collection<TupleMatch>> rightOuterJoinTuples(
			Map<Integer, Collection<String>> leftMap,
			Map<Integer, Collection<String>> rightMap)
	{
		Map<Integer, Collection<TupleMatch>> map = new HashMap<>();

		for (Integer key : rightMap.keySet()) {
			Collection<String> leftValues = leftMap.get(key);
			Collection<String> rightValues = rightMap.get(key);

			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<TupleMatch>());
			}

			Collection<TupleMatch> matchedValues = map.get(key);

			for (String rightValue : rightValues) {
				if(leftValues != null) {
					for (String leftValue : leftValues) {
						matchedValues.add(new TupleMatch(leftValue, rightValue));
					}
				}
				else {
					matchedValues.add(new TupleMatch(null, rightValue));
				}
			}
		}

		return map;
	}

	public static Map<Integer, Collection<TupleMatch>> fullOuterJoinTuples(
		Map<Integer, Collection<String>> leftMap,
		Map<Integer, Collection<String>> rightMap)
	{
		Map<Integer, Collection<TupleMatch>> map = new HashMap<>();

		for (Integer key : rightMap.keySet()) {
			Collection<String> leftValues = leftMap.get(key);
			Collection<String> rightValues = rightMap.get(key);

			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<TupleMatch>());
			}

			Collection<TupleMatch> matchedValues = map.get(key);

			for (String rightValue : rightValues) {
				if(leftValues != null) {
					for (String leftValue : leftValues) {
						matchedValues.add(new TupleMatch(leftValue, rightValue));
					}
				}
				else {
					matchedValues.add(new TupleMatch(null, rightValue));
				}
			}
		}

		for (Integer key : leftMap.keySet()) {
			Collection<String> leftValues = leftMap.get(key);
			Collection<String> rightValues = rightMap.get(key);
			if (rightValues == null) {
				if (!map.containsKey(key)) {
					map.put(key, new ArrayList<TupleMatch>());
				}

				Collection<TupleMatch> matchedValues = map.get(key);

				for (String leftValue : leftValues) {
					matchedValues.add(new TupleMatch(leftValue, null));
				}
			}
		}

		return map;
	}
	
	public static Map<Integer, Collection<TupleIntPairMatch>> joinIntPairs(
			Map<Integer, Collection<Integer>> leftMap,
			Map<Integer, Collection<String>> rightMap)
	{
		final Map<Integer, Collection<TupleIntPairMatch>> map = new HashMap<>();
	
		for (Integer i : leftMap.keySet()) {
			
			final Collection<Integer> leftValues = leftMap.get(i);
			final Collection<String> rightValues = rightMap.get(i);
	
			if (rightValues == null) {
				continue;
			}
	
			if (!map.containsKey(i)) {
				map.put(i, new ArrayList<TupleIntPairMatch>());
			}
	
			final Collection<TupleIntPairMatch> matchedValues = map.get(i);
	
			for (Integer v : leftValues) {
				for (String val : rightValues) {
					matchedValues.add(new TupleIntPairMatch(v, val));
				}
			}
		}
	
		return map;
	}

	
	public static Map<Integer, Collection<String>> collectTupleData(MutableObjectIterator<Tuple2<Integer, String>> iter)
	throws Exception
	{
		Map<Integer, Collection<String>> map = new HashMap<>();
		Tuple2<Integer, String> pair = new Tuple2<>();
		
		while ((pair = iter.next(pair)) != null) {

			Integer key = pair.f0;
			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<String>());
			}

			Collection<String> values = map.get(key);
			values.add(pair.f1);
		}

		return map;
	}
	
	public static Map<Integer, Collection<Integer>> collectIntPairData(MutableObjectIterator<IntPair> iter)
	throws Exception
	{
		Map<Integer, Collection<Integer>> map = new HashMap<>();
		IntPair pair = new IntPair();
		
		while ((pair = iter.next(pair)) != null) {

			final int key = pair.getKey();
			final int value = pair.getValue();
			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<Integer>());
			}

			Collection<Integer> values = map.get(key);
			values.add(value);
		}

		return map;
	}

	/**
	 * Class used for storage of the expected matches in a hash-map.
	 */
	public static class TupleMatch {
		
		private final String left;
		private final String right;

		public TupleMatch(String left, String right) {
			this.left = left;
			this.right = right;
		}

		@Override
		public boolean equals(Object obj) {
			TupleMatch that = (TupleMatch) obj;

			return (this.right == null ? that.right == null :
							(that.right != null && this.right.equals(that.right))) &&
					(this.left == null ? that.left == null :
							(that.left != null && this.left.equals(that.left)));
		}
		
		@Override
		public int hashCode() {
			int hc = this.left != null ? this.left.hashCode() : 23;
			hc = hc ^ (this.right != null ? this.right.hashCode() : 41);
			return hc;
		}

		@Override
		public String toString() {
			String s = left == null ? "<null>" : left;
			s += ", " + (right == null ? "<null>" : right);
			return s;
		}
	}
	
	/**
	 * Private class used for storage of the expected matches in a hash-map.
	 */
	public static class TupleIntPairMatch
	{
		private final int left;
		private final String right;

		public TupleIntPairMatch(int left, String right) {
			this.left = left;
			this.right = right;
		}

		@Override
		public boolean equals(Object obj) {
			TupleIntPairMatch o = (TupleIntPairMatch) obj;
			return this.left == o.left && this.right.equals(o.right);
		}
		
		@Override
		public int hashCode() {
			return this.left ^ this.right.hashCode();
		}

		@Override
		public String toString() {
			return left + ", " + right;
		}
	}
	
	static final class TupleMatchRemovingJoin implements FlatJoinFunction<Tuple2<Integer, String>, Tuple2<Integer, String>, Tuple2<Integer, String>>
	{
		private final Map<Integer, Collection<TupleMatch>> toRemoveFrom;
		
		protected TupleMatchRemovingJoin(Map<Integer, Collection<TupleMatch>> map) {
			this.toRemoveFrom = map;
		}
		
		@Override
		public void join(Tuple2<Integer, String> rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception
		{

			int key = rec1 != null ? rec1.f0 : rec2.f0;
			String value1 = rec1 != null ? rec1.f1 : null;
			String value2 = rec2 != null ? rec2.f1 : null;

			//System.err.println("rec1 key = "+key+"  rec2 key= "+rec2.f0);
			Collection<TupleMatch> matches = this.toRemoveFrom.get(key);
			if (matches == null) {
				Assert.fail("Match " + key + " - " + value1 + ":" + value2 + " is unexpected.");
			}
			
			Assert.assertTrue("Produced match was not contained: " + key + " - " + value1 + ":" + value2,
				matches.remove(new TupleMatch(value1, value2)));
			
			if (matches.isEmpty()) {
				this.toRemoveFrom.remove(key);
			}
		}
	}
	
	static final class TupleIntPairMatchRemovingMatcher implements FlatJoinFunction<IntPair, Tuple2<Integer, String>, Tuple2<Integer, String>>
	{
		private final Map<Integer, Collection<TupleIntPairMatch>> toRemoveFrom;
		
		protected TupleIntPairMatchRemovingMatcher(Map<Integer, Collection<TupleIntPairMatch>> map) {
			this.toRemoveFrom = map;
		}
		
		@Override
		public void join(IntPair rec1, Tuple2<Integer, String> rec2, Collector<Tuple2<Integer, String>> out) throws Exception
		{
			final int k = rec1.getKey();
			final int v = rec1.getValue(); 
			
			final Integer key = rec2.f0;
			final String value = rec2.f1;

			Assert.assertTrue("Key does not match for matching IntPair Tuple combination.", k == key);
			
			Collection<TupleIntPairMatch> matches = this.toRemoveFrom.get(key);
			if (matches == null) {
				Assert.fail("Match " + key + " - " + v + ":" + value + " is unexpected.");
			}
			
			Assert.assertTrue("Produced match was not contained: " + key + " - " + v + ":" + value,
				matches.remove(new TupleIntPairMatch(v, value)));
			
			if (matches.isEmpty()) {
				this.toRemoveFrom.remove(key);
			}
		}
	}
	
	static final class IntPairTuplePairComparator extends TypePairComparator<IntPair, Tuple2<Integer, String>>
	{
		private int reference;
		
		@Override
		public void setReference(IntPair reference) {
			this.reference = reference.getKey();	
		}

		@Override
		public boolean equalToReference(Tuple2<Integer, String> candidate) {
			try {
				return candidate.f0 == this.reference;
			} catch (NullPointerException npex) {
				throw new NullKeyFieldException();
			}
		}

		@Override
		public int compareToReference(Tuple2<Integer, String> candidate) {
			try {
				return candidate.f0 - this.reference;
			} catch (NullPointerException npex) {
				throw new NullKeyFieldException();
			}
		}
	}
	
	static final class TupleIntPairPairComparator extends TypePairComparator<Tuple2<Integer, String>, IntPair>
	{
		private int reference;
		
		@Override
		public void setReference(Tuple2<Integer, String> reference) {
			this.reference = reference.f0;
		}

		@Override
		public boolean equalToReference(IntPair candidate) {
			return this.reference == candidate.getKey();
		}

		@Override
		public int compareToReference(IntPair candidate) {
			return candidate.getKey() - this.reference;
		}
	}
}
```


Overlapping Code:
```
esntCheckParameterClass", 
"StatementWithEmptyBody", "KeySetIterationMayUseEntrySet"})
public class NonReusingHashJoinIteratorITCase extends TestLogger {

private static final int MEMORY_SIZE = 16000000; // total memory
private static final int INPUT_1_SIZE = 20000;
private static final int INPUT_2_SIZE = 1000;
private static final long SEED1 = 561349061987311L;
private static final long SEED2 = 231434613412342L;

private final AbstractInvokable parentTask = new DummyInvokable();
private IOManager ioManager;
private MemoryManager memoryManager;

private TypeSerializer<Tuple2<Integer, String>> recordSerializer;
private TypeComparator<Tuple2<Integer, String>> record1Comparator;
private TypeComparator<Tuple2<Integer, String>> record2Comparator;
private TypePairComparator<Tuple2<Integer, String>, Tuple2<Integer, String>> recordPairComparator;

private TypeSerializer<IntPair> pairSerializer;
private TypeComparator<IntPair> pairComparator;
private TypePairComparator<IntPair, Tuple2<Integer, String>> pairRecordPairComparator;
private TypePairComparator<Tuple2<Integer, String>, IntPair> recordPairPairComparator;
@SuppressWarnings("unchecked")
@Before
public void beforeTest() {
this.recordSerializer = TestData.getIntStringTupleSerializer();

this.record1Comparator = TestData.getIntStringTupleComparator();
this.record2Comparator = TestData.getIntStringTupleComparator();

this.recordPairComparator = new GenericPairComparator(record1Comparator, record2Comparator);

this.pairSerializer = new IntPairSerializer();
this.pairComparator = new TestData.IntPairComparator();
this.pairRecordPairComparator = new IntPairTuplePairComparator();
this.recordPairPairComparator = new TupleIntPairPairComparator();

this.memoryManager = new MemoryManager(MEMORY_SIZE, 1);
this.ioManager = new IOManagerAsync();
}
@After
public void afterTest() throws Exception {
if (this.ioManager != null) {
this.ioManager.close();
this.ioManager = null;
}

if (this.memoryManager != null) {
Assert.assertTrue("Memory Leak: Not all memory has been returned to the memory manager.",
this.memoryManager.verifyEmpty());
this.memoryManager.shutdown();
this.memoryManager = null;
}
}
@Test
public void testBuildFirst() {
try {
TupleGenerator generator1 = new TupleGenerator(SEED1, 500, 4096, KeyMode.RANDOM, ValueMode.RANDOM_LENGTH);
TupleGenerator generator2 = new TupleG
```
<Overlap Ratio: 0.9816207184628237>

---

--- 209 --
Question ID: 6c9459798c71d5f8316c1f39aa76f766adc19069
Original Code:
```
class PackageReference
{
    private final static String PACKAGE_REFERENCE_PATTERN = 
        "([+-]?)([.a-zA-Z0-9-+]+)((?:=)|(?:>)|(?:>=)|(?:<)|(?:<=))?([0-9.]+?)?";
    
    private PackageKind packageKind;
    private String packageName;
    private ComparisonOperator operator;
    private PackageVersion packageVersion;
    
    private PackageReference() { }

    public PackageKind getPackageKind()
    {
        return packageKind;
    }
    
    public String getPackageName()
    {
        return packageName;
    }

    public ComparisonOperator getOperator()
    {
        return operator;
    }

    public PackageVersion getPackageVersion()
    {
        return packageVersion;
    }
    
    public boolean fits(PackageReference other)
    {
        if (getPackageName().equals(other.getPackageName()))
        {
            if (other.operator == ComparisonOperator.None) return true;
            if (other.operator == ComparisonOperator.Equal && 
                packageVersion.getTotal() == other.packageVersion.getTotal()) return true;
            if (other.operator == ComparisonOperator.Greater && 
                packageVersion.getTotal() > other.packageVersion.getTotal()) return true;
            if (other.operator == ComparisonOperator.GreaterOrEqual && 
                packageVersion.getTotal() >= other.packageVersion.getTotal()) return true;
            if (other.operator == ComparisonOperator.Less && 
                packageVersion.getTotal() < other.packageVersion.getTotal()) return true;
            if (other.operator == ComparisonOperator.LessOrEqual && 
                packageVersion.getTotal() <= other.packageVersion.getTotal()) return true;
        }
        
        return false;
    }
    
    @Override
    public String toString()
    {
        if (operator != ComparisonOperator.None)
        {
            return packageName + getOperatorText(operator) + packageVersion;
        }
        
        return packageName;
    }
    
    private String getOperatorText(ComparisonOperator operator)
    {
        if (operator == ComparisonOperator.Equal) return "=";
        if (operator == ComparisonOperator.Greater) return ">";
        if (operator == ComparisonOperator.GreaterOrEqual) return ">=";
        if (operator == ComparisonOperator.Less) return "<";
        if (operator == ComparisonOperator.LessOrEqual) return "<=";
        
        return null;
    }
    
    public static PackageReference parse(String input)
    {
        PackageReference result;
        Pattern pattern;
        Matcher matcher;
        String kind, name, operator, version;
        
        result = new PackageReference();
        pattern = Pattern.compile(PACKAGE_REFERENCE_PATTERN);
        matcher = pattern.matcher(input);
        
        if (matcher.matches())
        {
            kind = matcher.group(1);
            name = matcher.group(2);
            operator = matcher.group(3);
            version = matcher.group(4);
            
            if (kind == null)
            {
                result.packageKind = PackageKind.None;
            }
            else if (kind.equals("+"))
            {
                result.packageKind = PackageKind.Positive;
            }
            else
            {
                result.packageKind = PackageKind.Negative;
            }
            
            result.packageName = name;
            
            if (operator != null)
            {
                if (operator.equals("=")) result.operator = ComparisonOperator.Equal;
                else if (operator.equals(">")) result.operator = ComparisonOperator.Greater;
                else if (operator.equals(">=")) result.operator = ComparisonOperator.GreaterOrEqual;
                else if (operator.equals("<")) result.operator = ComparisonOperator.Less;
                else result.operator = ComparisonOperator.LessOrEqual;
            }
            else
            {
                result.operator = ComparisonOperator.None;
            }
            
            if (version == null)
            {
                version = "0";
            }
            
            result.packageVersion = PackageVersion.parse(version);
            
            return result;
        }

        throw new IllegalArgumentException(input);
    }
    
    public static PackageReference parse(Package _package)
    {
        PackageReference result;
        
        result = new PackageReference();
        result.packageName = _package.getName();
        result.packageVersion = PackageVersion.parse(_package.getVersion());
        result.operator = ComparisonOperator.Equal;
        result.packageKind = PackageKind.None;
        
        return result;
    }
}
```


Overlapping Code:
```
ference
{
private final static String PACKAGE_REFERENCE_PATTERN = 
"([+-]?)([.a-zA-Z0-9-+]+)((?:=)|(?:>)|(?:>=)|(?:<)|(?:<=))?([0-9.]+?)?";

private PackageKind packageKind;
private String packageName;
private ComparisonOperator operator;
private PackageVersion packageVersion;

private PackageReference() { }
public PackageKind getPackageKind()
{
return packageKind;
}

public String getPackageName()
{
return packageName;
}
public ComparisonOperator getOperator()
{
return operator;
}
public PackageVersion getPackageVersion()
{
return packageVersion;
}

public boolean fits(PackageReference other)
{
if (getPackageName().equals(other.getPackageName()))
{
if (other.operator == ComparisonOperator.None) return true;
if (other.operator == ComparisonOperator.Equal && 
packageVersion.getTotal() == other.packageVersion.getTotal()) return true;
if (other.operator == ComparisonOperator.Greater && 
packageVersion.getTotal() > other.packageVersion.getTotal()) return true;
if (other.operator == ComparisonOperator.GreaterOrEqual && 
packageVersion.getTotal() >= other.packageVersion.getTotal()) return true;
if (other.operator == ComparisonOperator.Less && 
packageVersion.getTotal() < other.packageVersion.getTotal()) return true;
if (other.operator == ComparisonOperator.LessOrEqual && 
packageVersion.getTotal() <= other.packageVersion.getTotal()) return true;
}

return false;
}

@Override
public String toString()
{
if (operator != ComparisonOperator.None)
{
return packageName + getOperatorText(operator) + packageVersion;
}

return packageName;
}

private String getOperatorText(ComparisonOperator operator)
{
if (operator == ComparisonOperator.Equal) return "=";
if (operator == ComparisonOperator.Greater) return ">";
if (operator == ComparisonOperator.GreaterOrEqual) return ">=";
if (operator == ComparisonOperator.Less) return "<";
if (operator == ComparisonOperator.LessOrEqual) return "<=";

return null;
}

public static PackageReference
```
<Overlap Ratio: 0.975>

---

--- 210 --
Question ID: a1daf720ce934a1a0226eb822af7054d269cb18b
Original Code:
```
@Service
public class WechatUserInfoService extends CrudService<WechatUserInfoDao, WechatUserInfo>{

	public WechatUserInfo findByOpenId(String openId) {
		Assert.hasLength(openId,"openId 为空");
		WechatUserInfo wechatUserInfo = new WechatUserInfo();
		wechatUserInfo.setOpenid(openId);
		List<WechatUserInfo> list = this.findList(wechatUserInfo);
		return list.size() > 0 ? list.get(0):null;
	}
	
}
```


Overlapping Code:
```
erInfoService extends CrudService<WechatUserInfoDao, WechatUserInfo>{
public WechatUserInfo findByOpenId(String openId) {
Assert.hasLength(openId,"openId 为空");
WechatUserInfo wechatUserInfo = new WechatUserInfo();
wechatUserInfo.setOpenid(openId);
List<WechatUserInfo> list = this.findList(wechatUserInfo);
return list.size() > 0 ? list.get(0):null;

```
<Overlap Ratio: 0.9114583333333334>

---

--- 211 --
Question ID: f022bf9ba7715b08fd97ad06c4e7135dac37b831
Original Code:
```
public class studentController {

	private static String ID, NAME, ClassGrade;
	private static Statement statement;
	private ResultSet resultCourses, resultClass;

	@FXML
	private Label lblName, lblID, lblClass;
	@FXML
	private TableView<Course> coursesTable;
	@FXML
	private TableColumn<Course, String> colCourse, colInstructor, colQuiz, colMidterm, colFinal;

	private ObservableList<Course> coursesList = FXCollections.observableArrayList();

	public static void setID(String id) {
		ID = id;
	}

	public static void setName(String name) {
		NAME = name;
	}

	public static void setClassGrade(String classGrade) {
		ClassGrade = classGrade;
	}

	public static void setStatement(Statement stm) {
		statement = stm;
	}

	@FXML
	public void initialize() {
		getClassGrade();
		loadCourses();
		init_grades_table();
		init_labels();
	}

	public void getClassGrade() {
		try {
			String getClassGrade = String.format("select concat(class_grade, class_room) as class"
					+ " from students inner join classes using (class_id) where students.student_id = %s;", ID);
			resultClass = statement.executeQuery(getClassGrade);
			resultClass.next();
			ClassGrade = resultClass.getString("class");
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	public void init_grades_table() {
		colCourse.setCellValueFactory(new PropertyValueFactory<>("courseName"));
		colInstructor.setCellValueFactory(new PropertyValueFactory<>("instructor_name"));
		colQuiz.setCellValueFactory(new PropertyValueFactory<>("quiz"));
		colMidterm.setCellValueFactory(new PropertyValueFactory<>("mid"));
		colFinal.setCellValueFactory(new PropertyValueFactory<>("fin"));
		coursesTable.setItems(coursesList);
	}

	public void init_labels() {
		lblName.setText(NAME);
		lblID.setText(ID);
		lblClass.setText(ClassGrade);
	}

	public void loadCourses() {
		try {
			String selectClasses = String.format(
					"select course_name, teacher_name, teacher_id, quiz, midterm, final from (((grade inner join students using (student_id)) inner join courses using (course_id)) inner join teaches using (class_id, course_id)) left join teachers using (teacher_id) where students.student_id = %s;",
					ID);
			resultCourses = statement.executeQuery(selectClasses);

			Course crs;
			String courseName, teacherName, teacherID, quiz, mid, fin;

			while (resultCourses.next()) {
				courseName = resultCourses.getString("course_name");
				teacherName = resultCourses.getString("teacher_name");
				teacherID = resultCourses.getString("teacher_id");
				quiz = resultCourses.getString("quiz");
				mid = resultCourses.getString("midterm");
				fin = resultCourses.getString("final");
				crs = new Course(courseName, teacherName, teacherID, quiz, mid, fin);
				coursesList.add(crs);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	@FXML
	public void onLogOut() throws IOException {
		Main.switchToMain();
	}
}
```


Overlapping Code:
```
static String ID, NAME, ClassGrade;
private static Statement statement;
private ResultSet resultCourses, resultClass;
@FXML
private Label lblName, lblID, lblClass;
@FXML
private TableView<Course> coursesTable;
@FXML
private TableColumn<Course, String> colCourse, colInstructor, colQuiz, colMidterm, colFinal;
private ObservableList<Course> coursesList = FXCollections.observableArrayList();
public static void setID(String id) {
ID = id;
}
public static void setName(String name) {
NAME = name;
}
public static void setClassGrade(String classGrade) {
ClassGrade = classGrade;
}
public static void setStatement(Statement stm) {
statement = stm;
}
@FXML
public void initialize() {
getClassGrade();
loadCourses();
init_grades_table();
init_labels();
}
public void getClassGrade() {
try {
String getClassGrade = String.format("select concat(class_grade, class_room) as class"
+ " from students inner join classes using (class_id) where students.student_id = %s;", ID);
resultClass = statement.executeQuery(getClassGrade);
resultClass.next();
ClassGrade = resultClass.getString("class");
} catch (SQLException e) {
e.printStackTrace();
}
}
public void init_grades_table() {
colCourse.setCellValueFactory(new PropertyValueFactory<>("courseName"));
colInstructor.setCellValueFactory(new PropertyValueFactory<>("instructor_name"));
colQuiz.setCellValueFactory(new PropertyValueFactory<>("quiz"));
colMidterm.setCellValueFactory(new PropertyValueFactory<>("mid"));
colFinal.setCellValueFactory(new PropertyValueFactory<>("fin"));
coursesTable.setItems(coursesList);
}
public void init_labels() {
lblName.setText(NAME);
lblID.setText(ID);
lblClass.setText(ClassGrade);
}
public void loadCourses() {
try {
String selectClasses = String.format(
"select course_name, teacher_name, teacher_id, quiz, midterm, final from (((grade inner join students using (student_id)) inner join courses using (course_id)) inner join teaches using (class_id, course_id)) left join teachers using (teacher_id) where students.student_id = %s;",
ID);
resultCourses = statement.executeQuery(selectClasses);
Course crs;
String courseName, teacherName, teacherID, quiz, mid, fin;
while (resultCourses.next()) {
courseName = resultCourses.getString("course_name");
teacherName = resultCourses.getString("teacher_name");
teacherID = resul
```
<Overlap Ratio: 0.9754028837998303>

---

--- 212 --
Question ID: cc47ebfdcc5f7c94cc2334cdc7b4781d4f77576d
Original Code:
```
public final class JsonObject extends JsonElement
{

	public JsonObject()
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #11  <Method void JsonElement()>
	//    2    4:aload_0         
	//    3    5:new             #13  <Class LinkedTreeMap>
	//    4    8:dup             
	//    5    9:invokespecial   #14  <Method void LinkedTreeMap()>
	//    6   12:putfield        #16  <Field LinkedTreeMap members>
	//    7   15:return          
	}

	private JsonElement createJsonElement(Object obj)
	{
		if(obj == null)
	//*   0    0:aload_1         
	//*   1    1:ifnonnull       8
			return ((JsonElement) (JsonNull.INSTANCE));
	//    2    4:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>
	//    3    7:areturn         
		else
			return ((JsonElement) (new JsonPrimitive(obj)));
	//    4    8:new             #27  <Class JsonPrimitive>
	//    5   11:dup             
	//    6   12:aload_1         
	//    7   13:invokespecial   #30  <Method void JsonPrimitive(Object)>
	//    8   16:areturn         
	}

	public void add(String s, JsonElement jsonelement)
	{
		Object obj = ((Object) (jsonelement));
	//    0    0:aload_2         
	//    1    1:astore_3        
		if(jsonelement == null)
	//*   2    2:aload_2         
	//*   3    3:ifnonnull       10
			obj = ((Object) (JsonNull.INSTANCE));
	//    4    6:getstatic       #25  <Field JsonNull JsonNull.INSTANCE>
	//    5    9:astore_3        
		members.put(((Object) (s)), obj);
	//    6   10:aload_0         
	//    7   11:getfield        #16  <Field LinkedTreeMap members>
	//    8   14:aload_1         
	//    9   15:aload_3         
	//   10   16:invokevirtual   #36  <Method Object LinkedTreeMap.put(Object, Object)>
	//   11   19:pop             
	//   12   20:return          
	}

	public void addProperty(String s, Boolean boolean1)
	{
		add(s, createJsonElement(((Object) (boolean1))));
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:aload_0         
	//    3    3:aload_2         
	//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>
	//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>
	//    6   10:return          
	}

	public void addProperty(String s, Character character)
	{
		add(s, createJsonElement(((Object) (character))));
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:aload_0         
	//    3    3:aload_2         
	//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>
	//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>
	//    6   10:return          
	}

	public void addProperty(String s, Number number)
	{
		add(s, createJsonElement(((Object) (number))));
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:aload_0         
	//    3    3:aload_2         
	//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>
	//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>
	//    6   10:return          
	}

	public void addProperty(String s, String s1)
	{
		add(s, createJsonElement(((Object) (s1))));
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:aload_0         
	//    3    3:aload_2         
	//    4    4:invokespecial   #40  <Method JsonElement createJsonElement(Object)>
	//    5    7:invokevirtual   #42  <Method void add(String, JsonElement)>
	//    6   10:return          
	}

	volatile JsonElement deepCopy()
	{
		return ((JsonElement) (deepCopy()));
	//    0    0:aload_0         
	//    1    1:invokevirtual   #50  <Method JsonObject deepCopy()>
	//    2    4:areturn         
	}

	JsonObject deepCopy()
	{
		JsonObject jsonobject = new JsonObject();
	//    0    0:new             #2   <Class JsonObject>
	//    1    3:dup             
	//    2    4:invokespecial   #51  <Method void JsonObject()>
	//    3    7:astore_1        
		java.util.Map.Entry entry;
		for(Iterator iterator = members.entrySet().iterator(); iterator.hasNext(); jsonobject.add((String)entry.getKey(), ((JsonElement)entry.getValue()).deepCopy()))
	//*   4    8:aload_0         
	//*   5    9:getfield        #16  <Field LinkedTreeMap members>
	//*   6   12:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>
	//*   7   15:invokeinterface #61  <Method Iterator Set.iterator()>
	//*   8   20:astore_2        
	//*   9   21:aload_2         
	//*  10   22:invokeinterface #67  <Method boolean Iterator.hasNext()>
	//*  11   27:ifeq            68
			entry = (java.util.Map.Entry)iterator.next();
	//   12   30:aload_2         
	//   13   31:invokeinterface #71  <Method Object Iterator.next()>
	//   14   36:checkcast       #73  <Class java.util.Map$Entry>
	//   15   39:astore_3        

	//   16   40:aload_1         
	//   17   41:aload_3         
	//   18   42:invokeinterface #76  <Method Object java.util.Map$Entry.getKey()>
	//   19   47:checkcast       #78  <Class String>
	//   20   50:aload_3         
	//   21   51:invokeinterface #81  <Method Object java.util.Map$Entry.getValue()>
	//   22   56:checkcast       #4   <Class JsonElement>
	//   23   59:invokevirtual   #83  <Method JsonElement JsonElement.deepCopy()>
	//   24   62:invokevirtual   #42  <Method void add(String, JsonElement)>
	//*  25   65:goto            21
		return jsonobject;
	//   26   68:aload_1         
	//   27   69:areturn         
	}

	public Set entrySet()
	{
		return members.entrySet();
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:invokevirtual   #55  <Method Set LinkedTreeMap.entrySet()>
	//    3    7:areturn         
	}

	public boolean equals(Object obj)
	{
		return obj == this || (obj instanceof JsonObject) && ((JsonObject)obj).members.equals(((Object) (members)));
	//    0    0:aload_1         
	//    1    1:aload_0         
	//    2    2:if_acmpeq       34
	//    3    5:aload_1         
	//    4    6:instanceof      #2   <Class JsonObject>
	//    5    9:ifeq            32
	//    6   12:aload_1         
	//    7   13:checkcast       #2   <Class JsonObject>
	//    8   16:getfield        #16  <Field LinkedTreeMap members>
	//    9   19:aload_0         
	//   10   20:getfield        #16  <Field LinkedTreeMap members>
	//   11   23:invokevirtual   #89  <Method boolean LinkedTreeMap.equals(Object)>
	//   12   26:ifeq            32
	//   13   29:goto            34
	//   14   32:iconst_0        
	//   15   33:ireturn         
	//   16   34:iconst_1        
	//   17   35:ireturn         
	}

	public JsonElement get(String s)
	{
		return (JsonElement)members.get(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>
	//    4    8:checkcast       #4   <Class JsonElement>
	//    5   11:areturn         
	}

	public JsonArray getAsJsonArray(String s)
	{
		return (JsonArray)members.get(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>
	//    4    8:checkcast       #98  <Class JsonArray>
	//    5   11:areturn         
	}

	public JsonObject getAsJsonObject(String s)
	{
		return (JsonObject)members.get(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>
	//    4    8:checkcast       #2   <Class JsonObject>
	//    5   11:areturn         
	}

	public JsonPrimitive getAsJsonPrimitive(String s)
	{
		return (JsonPrimitive)members.get(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #94  <Method Object LinkedTreeMap.get(Object)>
	//    4    8:checkcast       #27  <Class JsonPrimitive>
	//    5   11:areturn         
	}

	public boolean has(String s)
	{
		return members.containsKey(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #107 <Method boolean LinkedTreeMap.containsKey(Object)>
	//    4    8:ireturn         
	}

	public int hashCode()
	{
		return members.hashCode();
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:invokevirtual   #111 <Method int LinkedTreeMap.hashCode()>
	//    3    7:ireturn         
	}

	public JsonElement remove(String s)
	{
		return (JsonElement)members.remove(((Object) (s)));
	//    0    0:aload_0         
	//    1    1:getfield        #16  <Field LinkedTreeMap members>
	//    2    4:aload_1         
	//    3    5:invokevirtual   #114 <Method Object LinkedTreeMap.remove(Object)>
	//    4    8:checkcast       #4   <Class JsonElement>
	//    5   11:areturn         
	}

	private final LinkedTreeMap members = new LinkedTreeMap();
}
```


Overlapping Code:
```
ublic final class JsonObject extends JsonElement
{
public JsonObject()
{
// 0 0:aload_0 
// 1 1:invokespecial #11 <Method void JsonElement()>
// 2 4:aload_0 
// 3 5:new #13 <Class LinkedTreeMap>
// 4 8:dup 
// 5 9:invokespecial #14 <Method void LinkedTreeMap()>
// 6 12:putfield #16 <Field LinkedTreeMap members>
// 7 15:return 
}
private JsonElement createJsonElement(Object obj)
{
if(obj == null)
//* 0 0:aload_1 
//* 1 1:ifnonnull 8
return ((JsonElement) (JsonNull.INSTANCE));
// 2 4:getstatic #25 <Field JsonNull JsonNull.INSTANCE>
// 3 7:areturn 
else
return ((JsonElement) (new JsonPrimitive(obj)));
// 4 8:new #27 <Class JsonPrimitive>
// 5 11:dup 
// 6 12:aload_1 
// 7 13:invokespecial #30 <Method void JsonPrimitive(Object)>
// 8 16:areturn 
}
public void add(String s, JsonElement jsonelement)
{
Object obj = ((Object) (jsonelement));
// 0 0:aload_2 
// 1 1:astore_3 
if(jsonelement == null)
//* 2 2:aload_2 
//* 3 3:ifnonnull 10
obj = ((Object) (JsonNull.INSTANCE));
// 4 6:getstatic #25 <Field JsonNull JsonNull.INSTANCE>
// 5 9:astore_3 
members.put(((Object) (s)), obj);
// 6 10:aload_0 
// 7 11:getfield #16 <Field LinkedTreeMap members>
// 8 14:aload_1 
// 9 15:aload_3 
// 10 16:invokevirtual #36 <Method Object LinkedTreeMap.put(Object, Object)>
// 11 19:pop 
// 12 20:return 
}
public void addProperty(String s, Boolean boolean1)
{
add(s, createJsonElement(((Object) (boolean1))));
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:aload_0 
// 3 3:aload_2 
// 4 4:invokespecial #40 <Method JsonElement createJsonElement(Object)>
// 5 7:invokevirtual #42 <Method void add(String, JsonElement)>
// 6 10:return 
}
public void addProperty(String s, Character character)
{
add(s, createJsonElement(((Object) (character))));
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:aload_0 
// 3 3:aload_2 
// 4 4:invokespecial #40 <Method JsonElement createJsonElement(Obj
```
<Overlap Ratio: 0.9967811158798283>

---

--- 213 --
Question ID: 3c03439e87a969828a0d3ab9289436457057f412
Original Code:
```
public class EightQueen {

    int result[] = new int[8];

    public void solution() {
        cal(0);

    }

    private void cal(int row) {
        if (row == 8) {
            print();
            return;
        }
        for (int col = 0; col < 8; ++col) {
            if (isOk(row, col)) {
                result[row] = col;
                cal(row + 1);
            }
        }
    }

    private boolean isOk(int row, int column) {
        int leftup = column - 1;
        int rightup = column + 1;
        for (int i = row - 1; i >= 0; --i) {
            if (result[i] == column) {
                return false;
            }
            if (leftup >= 0) {
                if (result[i] == leftup) {
                    return false;
                }
            }
            if (rightup < 8) {
                if (result[i] == rightup) {
                    return false;
                }
            }
            --leftup;
            ++rightup;
        }
        return true;
    }

    private void print() {
        for (int row = 0; row < 8; ++row) {
            for (int col = 0; col < 8; ++col) {
                if (result[row] == col) {
                    System.out.print("Q ");
                } else {
                    System.out.print("* ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {
        EightQueen eightQueen = new EightQueen();
        eightQueen.solution();
    }
}
```


Overlapping Code:
```
] = new int[8];
public void solution() {
cal(0);
}
private void cal(int row) {
if (row == 8) {
print();
return;
}
for (int col = 0; col < 8; ++col) {
if (isOk(row, col)) {
result[row] = col;
cal(row + 1);
}
}
}
private boolean isOk(int row, int column) {
int leftup = column - 1;
int rightup = column + 1;
for (int i = row - 1; i >= 0; --i) {
if (result[i] == column) {
return false;
}
if (leftup >= 0) {
if (result[i] == leftup) {
return false;
}
}
if (rightup < 8) {
if (result[i] == rightup) {
return false;
}
}
--leftup;
++rightup;
}
return true;
}
private void print() {
for (int row = 0; row < 8; ++row) {
for (int col = 0; col < 8; ++col) {
if (result[row] == col) {
System.out.print("Q ");
} else {
System.out.print("* ");
}
}
System.out.println();
}
System.out.println();
}
public static void main(String[] args) {
EightQueen eightQueen = new EightQueen();
eig
```
<Overlap Ratio: 0.9354144241119483>

---

--- 214 --
Question ID: abbf2824cf970392193234012de529c775bebec8
Original Code:
```
public class DatabaseHelper extends OrmLiteSqliteOpenHelper {

    // name of the database file for your application -- change to something appropriate for your app
    private static final String DATABASE_NAME = "ormlite.db";
    // any time you make changes to your database objects, you may have to increase the database version
    private static final int DATABASE_VERSION = 1;

    // the DAO objects
    private Dao<AddressBook, Integer> addressBookDao = null;
    private Dao<AddressItem, Integer> addressItemDao = null;
    private Dao<Contact, Integer> contactDao = null;
    private Dao<SimpleAddressItem, Integer> simpleAddressDao = null;

    public DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION, R.raw.ormlite_config);
    }

    /**
     * This is called when the database is first created. Usually you should call createTable statements here to create
     * the tables that will store your data.
     */
    @Override
    public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {
        try {
            Log.i(DatabaseHelper.class.getName(), "onCreate");
            TableUtils.createTable(connectionSource, AddressBook.class);
            TableUtils.createTable(connectionSource, AddressItem.class);
            TableUtils.createTable(connectionSource, Contact.class);
            TableUtils.createTable(connectionSource, SimpleAddressItem.class);
        } catch (SQLException e) {
            Log.e(DatabaseHelper.class.getName(), "Can't create database", e);
            throw new RuntimeException(e);
        }
    }

    /**
     * This is called when your application is upgraded and it has a higher version number. This allows you to adjust
     * the various data to match the new version number.
     */
    @Override
    public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {
        try {
            Log.i(DatabaseHelper.class.getName(), "onUpgrade");
            TableUtils.dropTable(connectionSource, AddressBook.class, true);
            TableUtils.dropTable(connectionSource, AddressItem.class, true);
            TableUtils.dropTable(connectionSource, Contact.class, true);
            TableUtils.dropTable(connectionSource, SimpleAddressItem.class, true);
            // after we drop the old databases, we create the new ones
            onCreate(db, connectionSource);
        } catch (SQLException e) {
            Log.e(DatabaseHelper.class.getName(), "Can't drop databases", e);
            throw new RuntimeException(e);
        }
    }

    /**
     * Returns the Database Access Object (DAO) for our AddressBook class
     */
    public Dao<AddressBook, Integer> getAddressBookDao() throws SQLException {
        if (addressBookDao == null) {
            addressBookDao = getDao(AddressBook.class);
        }
        return addressBookDao;
    }

    /**
     * Returns the Database Access Object (DAO) for our AddressItem class
     */
    public Dao<AddressItem, Integer> getAddressItemDao() throws SQLException {
        if (addressItemDao == null) {
            addressItemDao = getDao(AddressItem.class);
        }
        return addressItemDao;
    }

    /**
     * Returns the Database Access Object (DAO) for our Contact class
     */
    public Dao<Contact, Integer> getContactDao() throws SQLException {
        if (contactDao == null) {
            contactDao = getDao(Contact.class);
        }
        return contactDao;
    }

    /**
     * Returns the Database Access Object (DAO) for our SimpleAddressItem class
     */
    public Dao<SimpleAddressItem, Integer> getSimpleAddressItemDao() throws SQLException {
        if (simpleAddressDao == null) {
            simpleAddressDao = getDao(SimpleAddressItem.class);
        }
        return simpleAddressDao;
    }

    /**
     * Close the database connections and clear any cached DAOs.
     */
    @Override
    public void close() {
        super.close();
        addressBookDao = null;
        addressItemDao = null;
        contactDao = null;
        simpleAddressDao = null;
   }
}
```


Overlapping Code:
```
public class DatabaseHelper extends OrmLiteSqliteOpenHelper {
// name of the database file for your application -- change to something appropriate for your app
private static final String DATABASE_NAME = "ormlite.db";
// any time you make changes to your database objects, you may have to increase the database version
private static final int DATABASE_VERSION = 1;
// the DAO objects
private Dao<AddressBook, Integer> addressBookDao = null;
private Dao<AddressItem, Integer> addressItemDao = null;
private Dao<Contact, Integer> contactDao = null;
private Dao<SimpleAddressItem, Integer> simpleAddressDao = null;
public DatabaseHelper(Context context) {
super(context, DATABASE_NAME, null, DATABASE_VERSION, R.raw.ormlite_config);
}
/**
* This is called when the database is first created. Usually you should call createTable statements here to create
* the tables that will store your data.
*/
@Override
public void onCreate(SQLiteDatabase db, ConnectionSource connectionSource) {
try {
Log.i(DatabaseHelper.class.getName(), "onCreate");
TableUtils.createTable(connectionSource, AddressBook.class);
TableUtils.createTable(connectionSource, AddressItem.class);
TableUtils.createTable(connectionSource, Contact.class);
TableUtils.createTable(connectionSource, SimpleAddressItem.class);
} catch (SQLException e) {
Log.e(DatabaseHelper.class.getName(), "Can't create database", e);
throw new RuntimeException(e);
}
}
/**
* This is called when your application is upgraded and it has a higher version number. This allows you to adjust
* the various data to match the new version number.
*/
@Override
public void onUpgrade(SQLiteDatabase db, ConnectionSource connectionSource, int oldVersion, int newVersion) {
try {
Log.i(DatabaseHelper.class.getName(), "onUpgrade");
TableUtils.dropTable(connectionSource, AddressBook.class, true);
TableUtils.dropTable(connectionSource, AddressItem.class, true);
TableUtils.dropTable(connectionSource, Contact.class, true);
TableUtils.dropTable(connectionSource, SimpleAddressItem.class, true);
// after we drop the old databases, we create the new ones
onCreate(db, connectionSource);
} catch (SQLException e) {
Log.e(DatabaseHelper
```
<Overlap Ratio: 1.0>

---

--- 215 --
Question ID: b22a251b850cc3425deb6d83bfb30027031b9cc4
Original Code:
```
public class ActionFacadeLogicImpl
    extends ActionFacadeLogic
{
    private static final long serialVersionUID = 34L;
    /**
     * @param metaObject
     * @param context
     */
    public ActionFacadeLogicImpl(
        final org.eclipse.uml2.Action metaObject,
        final String context)
    {
        super(metaObject, context);
    }

    /**
     * @return owner
     * @see org.andromda.metafacades.uml.ActionFacade#getTransition()
     */
    protected Object handleGetTransition()
    {
        final Element owner = this.metaObject.getActivity().getOwner();
        return owner instanceof Transition ? owner : null;
    }

    /**
     * @return owner
     * @see org.andromda.metafacades.uml.ActionFacade#getActionState()
     */
    protected Object handleGetActionState()
    {
        final Element owner = this.metaObject.getActivity().getOwner();
        return owner instanceof State ? owner : null;
    }

    /**
     * @see org.andromda.core.metafacade.MetafacadeBase#getValidationOwner()
     */
    public Object getValidationOwner()
    {
        Object validationOwner = getTransition();

        if (validationOwner == null)
        {
            validationOwner = getActionState();
        }

        return validationOwner;
    }
}
```


Overlapping Code:
```
ic class ActionFacadeLogicImpl
extends ActionFacadeLogic
{
private static final long serialVersionUID = 34L;
/**
* @param metaObject
* @param context
*/
public ActionFacadeLogicImpl(
final org.eclipse.uml2.Action metaObject,
final String context)
{
super(metaObject, context);
}
/**
* @return owner
* @see org.andromda.metafacades.uml.ActionFacade#getTransition()
*/
protected Object handleGetTransition()
{
final Element owner = this.metaObject.getActivity().getOwner();
return owner instanceof Transition ? owner : null;
}
/**
* @return owner
* @see org.andromda.metafacades.uml.ActionFacade#getActionState()
*/
protected Object handleGetActionState()
{
final Element owner = this.metaObject.getActivity().getOwner();
return owner instanceof State ? owner : null;
}
/**
* @see org.andromda.core.metafacade.MetafacadeBase#getValidationOwner()
*/
public Object getValidationOwner()
{
Object validationOwner = getTransition();
if (validationOwner == null)
{
validationOwner = getActionState();
}
re
```
<Overlap Ratio: 0.9717348927875243>

---

--- 216 --
Question ID: e0880c606fbbafdce24a11d26466e2e0ad36f48d
Original Code:
```
@Slf4j
public final class SymbolPortfolioRecord implements WriteBytesMarshallable, StateHash {

    public final long uid;

    public final int symbol;
    public final int currency;

    // open positions state (for margin trades only)
    public PortfolioPosition position = PortfolioPosition.EMPTY;
    public long openVolume = 0;
    public long openPriceSum = 0; //
    public long profit = 0;

    // pending orders total size
    // increment before sending order to matching engine
    // decrement after receiving trade confirmation from matching engine
    public long pendingSellSize = 0;
    public long pendingBuySize = 0;

    public SymbolPortfolioRecord(long uid, int symbol, int currency) {
        this.uid = uid;

        this.symbol = symbol;
        this.currency = currency;
    }

    public SymbolPortfolioRecord(long uid, BytesIn bytes) {
        this.uid = uid;

        this.symbol = bytes.readInt();
        this.currency = bytes.readInt();
        this.position = PortfolioPosition.of(bytes.readByte());
        this.openVolume = bytes.readLong();
        this.openPriceSum = bytes.readLong();
        this.profit = bytes.readLong();
        this.pendingSellSize = bytes.readLong();
        this.pendingBuySize = bytes.readLong();
    }


    /**
     * Check if portfolio is empty (no pending orders, no open trades) - can remove it from hashmap
     *
     * @return true if portfolio is empty (no pending orders, no open trades)
     */
    public boolean isEmpty() {
        return position == PortfolioPosition.EMPTY
                && pendingSellSize == 0
                && pendingBuySize == 0;
    }

    public void pendingHold(OrderAction orderAction, long size) {
        if (orderAction == OrderAction.ASK) {
            pendingSellSize += size;
        } else {
            pendingBuySize += size;
        }
    }

    public void pendingRelease(OrderAction orderAction, long size) {
        if (orderAction == OrderAction.ASK) {
            pendingSellSize -= size;
        } else {
            pendingBuySize -= size;
        }

//        if (pendingSellSize < 0 || pendingBuySize < 0) {
//            log.error("uid {} : pendingSellSize:{} pendingBuySize:{}", uid, pendingSellSize, pendingBuySize);
//        }
    }

    public long estimateProfit(final CoreSymbolSpecification spec, final RiskEngine.LastPriceCacheRecord lastPriceCacheRecord) {
        switch (position) {
            case EMPTY:
                return profit;
            case LONG:
                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.bidPrice != 0)
                        ? (openVolume * lastPriceCacheRecord.bidPrice - openPriceSum)
                        : spec.depositBuy * openVolume); // unknown price - no liquidity - require extra margin
            case SHORT:
                return profit + ((lastPriceCacheRecord != null && lastPriceCacheRecord.askPrice != Long.MAX_VALUE)
                        ? (openPriceSum - openVolume * lastPriceCacheRecord.askPrice)
                        : spec.depositSell * openVolume); // unknown price - no liquidity - require extra margin
            default:
                throw new IllegalStateException();
        }
    }

    /**
     * Calculate required deposit based on specification and current position/orders
     *
     * @param spec
     * @return
     */
    public long calculateRequiredDepositForFutures(CoreSymbolSpecification spec) {
        final long specDepositBuy = spec.depositBuy;
        final long specDepositSell = spec.depositSell;

        final long signedPosition = openVolume * position.getMultiplier();
        final long currentRiskBuySize = pendingBuySize + signedPosition;
        final long currentRiskSellSize = pendingSellSize - signedPosition;

        final long depositBuy = specDepositBuy * currentRiskBuySize;
        final long depositSell = specDepositSell * currentRiskSellSize;
        // depositBuy or depositSell can be negative, but not both of them
        return Math.max(depositBuy, depositSell);
    }

    /**
     * Calculate required deposit based on specification and current position/orders
     * considering extra size added to current position (or outstanding orders)
     *
     * @param spec   symbols specification
     * @param action order action
     * @param size   order size
     * @return -1 if order will reduce current exposure (no additional margin required), otherwise full deposit for symbol position if order placed/executed
     */
    public long calculateRequiredDepositForOrder(final CoreSymbolSpecification spec, final OrderAction action, final long size) {
        final long specDepositBuy = spec.depositBuy;
        final long specDepositSell = spec.depositSell;

        final long signedPosition = openVolume * position.getMultiplier();
        final long currentRiskBuySize = pendingBuySize + signedPosition;
        final long currentRiskSellSize = pendingSellSize - signedPosition;

        long depositBuy = specDepositBuy * currentRiskBuySize;
        long depositSell = specDepositSell * currentRiskSellSize;
        // either depositBuy or depositSell can be negative (because of signedPosition), but not both of them
        final long currentDeposit = Math.max(depositBuy, depositSell);

        if (action == OrderAction.BID) {
            depositBuy += spec.depositBuy * size;
        } else {
            depositSell += spec.depositSell * size;
        }

        // depositBuy or depositSell can be negative, but not both of them
        final long newDeposit = Math.max(depositBuy, depositSell);

        return (newDeposit <= currentDeposit) ? -1 : newDeposit;
    }


    /**
     * Update portfolio for one user
     * 1. Un-hold pending size
     * 2. Reduce opposite position accordingly (if exists)
     * 3. Increase forward position accordingly (if size left in the trading event)
     */
    public void updatePortfolioForMarginTrade(OrderAction action, long size, long price, final long commission) {

        // 1. Un-hold pending size
        pendingRelease(action, size);

        // 2. Reduce opposite position accordingly (if exists)
        final long sizeToOpen = closeCurrentPositionFutures(action, size, price);

        // 3. Increase forward position accordingly (if size left in the trading event)
        if (sizeToOpen > 0) {
            openPositionFutures(action, sizeToOpen, price, commission);
        }
    }

    private long closeCurrentPositionFutures(final OrderAction action, final long tradeSize, final long tradePrice) {

        // log.debug("{} {} {} {} cur:{}-{} profit={}", uid, action, tradeSize, tradePrice, position, totalSize, profit);

        if (position == PortfolioPosition.EMPTY || position == PortfolioPosition.of(action)) {
            // nothing to close
            return tradeSize;
        }

        if (openVolume > tradeSize) {
            // current position is bigger than trade size - just reduce position accordingly, don't fix profit
            openVolume -= tradeSize;
            openPriceSum -= tradeSize * tradePrice;
            return 0;
        }

        // current position smaller than trade size, can close completely and calculate profit
        profit += (openVolume * tradePrice - openPriceSum) * position.getMultiplier();
        openPriceSum = 0;
        position = PortfolioPosition.EMPTY;
        final long sizeToOpen = tradeSize - openVolume;
        openVolume = 0;

        // validateInternalState();

        return sizeToOpen;
    }

    private void openPositionFutures(OrderAction action, long sizeToOpen, long tradePrice, long commission) {
        openVolume += sizeToOpen;
        openPriceSum += tradePrice * sizeToOpen;
        position = PortfolioPosition.of(action);
        profit -= commission * sizeToOpen;

        // validateInternalState();
    }

    @Override
    public void writeMarshallable(BytesOut bytes) {
        bytes.writeInt(symbol);
        bytes.writeInt(currency);
        bytes.writeByte((byte) position.getMultiplier());
        bytes.writeLong(openVolume);
        bytes.writeLong(openPriceSum);
        bytes.writeLong(profit);
        bytes.writeLong(pendingSellSize);
        bytes.writeLong(pendingBuySize);
    }

    public void reset() {

        // log.debug("records: {}, Pending B{} S{} total size: {}", records.size(), pendingBuySize, pendingSellSize, totalSize);

        pendingBuySize = 0;
        pendingSellSize = 0;

        openVolume = 0;
        openPriceSum = 0;
        position = PortfolioPosition.EMPTY;
    }

    public void validateInternalState() {
        if (position == PortfolioPosition.EMPTY && (openVolume != 0 || openPriceSum != 0)) {
            log.error("uid {} : position:{} totalSize:{} openPriceSum:{}", uid, position, openVolume, openPriceSum);
            throw new IllegalStateException();
        }
        if (position != PortfolioPosition.EMPTY && (openVolume <= 0 || openPriceSum <= 0)) {
            log.error("uid {} : position:{} totalSize:{} openPriceSum:{}", uid, position, openVolume, openPriceSum);
            throw new IllegalStateException();
        }

        if (pendingSellSize < 0 || pendingBuySize < 0) {
            log.error("uid {} : pendingSellSize:{} pendingBuySize:{}", uid, pendingSellSize, pendingBuySize);
            throw new IllegalStateException();
        }
    }

    @Override
    public int stateHash() {
        return Objects.hash(symbol, currency, position.getMultiplier(), openVolume, openPriceSum, profit, pendingSellSize, pendingBuySize);
    }

    @Override
    public String toString() {
        return "SPR{" +
                "u" + uid +
                " sym" + symbol +
                " cur" + currency +
                " pos" + position +
                " Σv=" + openVolume +
                " Σp=" + openPriceSum +
                " pnl=" + profit +
                " pendingS=" + pendingSellSize +
                " pendingB=" + pendingBuySize +
                '}';
    }
}
```


Overlapping Code:
```
l class SymbolPortfolioRecord implements WriteBytesMarshallable, StateHash {
public final long uid;
public final int symbol;
public final int currency;
// open positions state (for margin trades only)
public PortfolioPosition position = PortfolioPosition.EMPTY;
public long openVolume = 0;
public long openPriceSum = 0; //
public long profit = 0;
// pending orders total size
// increment before sending order to matching engine
// decrement after receiving trade confirmation from matching engine
public long pendingSellSize = 0;
public long pendingBuySize = 0;
public SymbolPortfolioRecord(long uid, int symbol, int currency) {
this.uid = uid;
this.symbol = symbol;
this.currency = currency;
}
public SymbolPortfolioRecord(long uid, BytesIn bytes) {
this.uid = uid;
this.symbol = bytes.readInt();
this.currency = bytes.readInt();
this.position = PortfolioPosition.of(bytes.readByte());
this.openVolume = bytes.readLong();
this.openPriceSum = bytes.readLong();
this.profit = bytes.readLong();
this.pendingSellSize = bytes.readLong();
this.pendingBuySize = bytes.readLong();
}
/**
* Check if portfolio is empty (no pending orders, no open trades) - can remove it from hashmap
*
* @return true if portfolio is empty (no pending orders, no open trades)
*/
public boolean isEmpty() {
return position == PortfolioPosition.EMPTY
&& pendingSellSize == 0
&& pendingBuySize == 0;
}
public void pendingHold(OrderAction orderAction, long size) {
if (orderAction == OrderAction.ASK) {
pendingSellSize += size;
} else {
pendingBuySize += size;
}
}
public void pendingRelease(OrderAction orderAction, long size) {
if (orderAction == OrderAction.ASK) {
pendingSellSize -= size;
} else {
pendingBuySize -= size;
}
// if (pendingSellSize < 0 || pendingBuySize < 0) {
// log.error("uid {} : pendingSellSize:{} pendingBuySize:{}", uid, pendingSellSize, pendingBuySize);
// }
}
public long estimateProfit(final CoreSymbolSpecification spec, final RiskEngine.LastPriceCacheRecord lastPriceCacheRecord) {
switch (position) {
case EMPTY:
retu
```
<Overlap Ratio: 0.9810587663914522>

---

--- 217 --
Question ID: 313b20e3f83814f5165f90e1f4b7e6b111cc48a6
Original Code:
```
public class SchemaTranslation {

  private static final BiMap<TypeName, RunnerApi.Schema.AtomicType> ATOMIC_TYPE_MAPPING =
      ImmutableBiMap.<TypeName, RunnerApi.Schema.AtomicType>builder()
          .put(TypeName.BYTE, RunnerApi.Schema.AtomicType.BYTE)
          .put(TypeName.INT16, RunnerApi.Schema.AtomicType.INT16)
          .put(TypeName.INT32, RunnerApi.Schema.AtomicType.INT32)
          .put(TypeName.INT64, RunnerApi.Schema.AtomicType.INT64)
          .put(TypeName.FLOAT, RunnerApi.Schema.AtomicType.FLOAT)
          .put(TypeName.DOUBLE, RunnerApi.Schema.AtomicType.DOUBLE)
          .put(TypeName.STRING, RunnerApi.Schema.AtomicType.STRING)
          .put(TypeName.BOOLEAN, RunnerApi.Schema.AtomicType.BOOLEAN)
          .put(TypeName.BYTES, RunnerApi.Schema.AtomicType.BYTES)
          .build();

  private static final String URN_BEAM_LOGICAL_DATETIME = "beam:fieldtype:datetime";
  private static final String URN_BEAM_LOGICAL_DECIMAL = "beam:fieldtype:decimal";

  public static RunnerApi.Schema toProto(Schema schema) {
    String uuid = schema.getUUID() != null ? schema.getUUID().toString() : "";
    RunnerApi.Schema.Builder builder = RunnerApi.Schema.newBuilder().setId(uuid);
    for (Field field : schema.getFields()) {
      RunnerApi.Schema.Field protoField =
          toProto(
              field,
              schema.indexOf(field.getName()),
              schema.getEncodingPositions().get(field.getName()));
      builder.addFields(protoField);
    }
    return builder.build();
  }

  private static RunnerApi.Schema.Field toProto(Field field, int fieldId, int position) {
    return RunnerApi.Schema.Field.newBuilder()
        .setName(field.getName())
        .setDescription(field.getDescription())
        .setType(toProto(field.getType()))
        .setId(fieldId)
        .setEncodingPosition(position)
        .build();
  }

  private static RunnerApi.Schema.FieldType toProto(FieldType fieldType) {
    RunnerApi.Schema.FieldType.Builder builder = RunnerApi.Schema.FieldType.newBuilder();
    switch (fieldType.getTypeName()) {
      case ROW:
        builder.setRowType(
            RunnerApi.Schema.RowType.newBuilder().setSchema(toProto(fieldType.getRowSchema())));
        break;

      case ARRAY:
        builder.setArrayType(
            RunnerApi.Schema.ArrayType.newBuilder()
                .setElementType(toProto(fieldType.getCollectionElementType())));
        break;

      case MAP:
        builder.setMapType(
            RunnerApi.Schema.MapType.newBuilder()
                .setKeyType(toProto(fieldType.getMapKeyType()))
                .setValueType(toProto(fieldType.getMapValueType()))
                .build());
        break;

      case LOGICAL_TYPE:
        LogicalType logicalType = fieldType.getLogicalType();
        builder.setLogicalType(
            RunnerApi.Schema.LogicalType.newBuilder()
                .setUrn(logicalType.getIdentifier())
                .setArgs(logicalType.getArgument())
                .setRepresentation(toProto(logicalType.getBaseType()))
                .build());
        break;
        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,
        // but not yet in Java. (BEAM-7554)
      case DATETIME:
        builder.setLogicalType(
            RunnerApi.Schema.LogicalType.newBuilder()
                .setUrn(URN_BEAM_LOGICAL_DATETIME)
                .setRepresentation(toProto(FieldType.INT64))
                .build());
        break;
      case DECIMAL:
        builder.setLogicalType(
            RunnerApi.Schema.LogicalType.newBuilder()
                .setUrn(URN_BEAM_LOGICAL_DECIMAL)
                .setRepresentation(toProto(FieldType.BYTES))
                .build());
        break;
      default:
        builder.setAtomicType(ATOMIC_TYPE_MAPPING.get(fieldType.getTypeName()));
        break;
    }
    builder.setNullable(fieldType.getNullable());
    return builder.build();
  }

  public static Schema fromProto(RunnerApi.Schema protoSchema) {
    Schema.Builder builder = Schema.builder();
    Map<String, Integer> encodingLocationMap = Maps.newHashMap();
    for (RunnerApi.Schema.Field protoField : protoSchema.getFieldsList()) {
      Field field = fieldFromProto(protoField);
      builder.addField(field);
      encodingLocationMap.put(protoField.getName(), protoField.getEncodingPosition());
    }
    Schema schema = builder.build();
    schema.setEncodingPositions(encodingLocationMap);
    if (!protoSchema.getId().isEmpty()) {
      schema.setUUID(UUID.fromString(protoSchema.getId()));
    }

    return schema;
  }

  private static Field fieldFromProto(RunnerApi.Schema.Field protoField) {
    return Field.of(protoField.getName(), fieldTypeFromProto(protoField.getType()))
        .withDescription(protoField.getDescription());
  }

  private static FieldType fieldTypeFromProto(RunnerApi.Schema.FieldType protoFieldType) {
    FieldType fieldType;
    switch (protoFieldType.getTypeInfoCase()) {
      case ATOMIC_TYPE:
        TypeName typeName = ATOMIC_TYPE_MAPPING.inverse().get(protoFieldType.getAtomicType());
        fieldType = FieldType.of(typeName);
        break;
      case ROW_TYPE:
        fieldType = FieldType.row(fromProto(protoFieldType.getRowType().getSchema()));
        break;
      case ARRAY_TYPE:
        fieldType =
            FieldType.array(fieldTypeFromProto(protoFieldType.getArrayType().getElementType()));
        break;
      case MAP_TYPE:
        fieldType =
            FieldType.map(
                fieldTypeFromProto(protoFieldType.getMapType().getKeyType()),
                fieldTypeFromProto(protoFieldType.getMapType().getValueType()));
        break;
      case LOGICAL_TYPE:
        // Special-case for DATETIME and DECIMAL which are logical types in portable representation,
        // but not yet in Java. (BEAM-7554)
        String urn = protoFieldType.getLogicalType().getUrn();
        if (urn.equals(URN_BEAM_LOGICAL_DATETIME)) {
          fieldType = FieldType.DATETIME;
        } else if (urn.equals(URN_BEAM_LOGICAL_DECIMAL)) {
          fieldType = FieldType.DECIMAL;
        } else {
          // TODO: Look up logical type class by URN.
          throw new IllegalArgumentException("Decoding logical types is not yet supported.");
        }
        break;
      default:
        throw new IllegalArgumentException(
            "Unexpected type_info: " + protoFieldType.getTypeInfoCase());
    }

    if (protoFieldType.getNullable()) {
      fieldType = fieldType.withNullable(true);
    }
    return fieldType;
  }
}
```


Overlapping Code:
```
lation {
private static final BiMap<TypeName, RunnerApi.Schema.AtomicType> ATOMIC_TYPE_MAPPING =
ImmutableBiMap.<TypeName, RunnerApi.Schema.AtomicType>builder()
.put(TypeName.BYTE, RunnerApi.Schema.AtomicType.BYTE)
.put(TypeName.INT16, RunnerApi.Schema.AtomicType.INT16)
.put(TypeName.INT32, RunnerApi.Schema.AtomicType.INT32)
.put(TypeName.INT64, RunnerApi.Schema.AtomicType.INT64)
.put(TypeName.FLOAT, RunnerApi.Schema.AtomicType.FLOAT)
.put(TypeName.DOUBLE, RunnerApi.Schema.AtomicType.DOUBLE)
.put(TypeName.STRING, RunnerApi.Schema.AtomicType.STRING)
.put(TypeName.BOOLEAN, RunnerApi.Schema.AtomicType.BOOLEAN)
.put(TypeName.BYTES, RunnerApi.Schema.AtomicType.BYTES)
.build();
private static final String URN_BEAM_LOGICAL_DATETIME = "beam:fieldtype:datetime";
private static final String URN_BEAM_LOGICAL_DECIMAL = "beam:fieldtype:decimal";
public static RunnerApi.Schema toProto(Schema schema) {
String uuid = schema.getUUID() != null ? schema.getUUID().toString() : "";
RunnerApi.Schema.Builder builder = RunnerApi.Schema.newBuilder().setId(uuid);
for (Field field : schema.getFields()) {
RunnerApi.Schema.Field protoField =
toProto(
field,
schema.indexOf(field.getName()),
schema.getEncodingPositions().get(field.getName()));
builder.addFields(protoField);
}
return builder.build();
}
private static RunnerApi.Schema.Field toProto(Field field, int fieldId, int position) {
return RunnerApi.Schema.Field.newBuilder()
.setName(field.getName())
.setDescription(field.getDescription())
.setType(toProto(field.getType()))
.setId(fieldId)
.setEncodingPosition(position)
.build();
}
private static RunnerApi.Schema.FieldType toProto(FieldType fieldType) {
RunnerApi.Schema.FieldType.Builder builder = RunnerApi.Schema.FieldType.newBuilder();
switch (fieldType.getTypeName()) {
case ROW:
builder.setRowType(
RunnerApi.Schema.RowType.newBuilder().setSchema(toProto(fieldType.getRowSchema())));
break;
case ARRAY:
builder.setArrayType(
RunnerApi.Schema.ArrayType.newBuilder()
.setElementType(toProto(fieldType.getCollectionElementType())));
break;
case MAP:
builder.setMapTy
```
<Overlap Ratio: 0.9787334593572778>

---

--- 218 --
Question ID: da10b58f8dc10f22f7d0cff63bae49bb186f6ef7
Original Code:
```
class GbmModel_Forest_6 {
  public static void score0(double[] fdata, double[] preds) {
    preds[1] += GbmModel_Tree_6_class_0.score0(fdata);
    preds[2] += GbmModel_Tree_6_class_1.score0(fdata);
    preds[3] += GbmModel_Tree_6_class_2.score0(fdata);
    preds[4] += GbmModel_Tree_6_class_3.score0(fdata);
    preds[5] += GbmModel_Tree_6_class_4.score0(fdata);
    preds[6] += GbmModel_Tree_6_class_5.score0(fdata);
  }
}
```


Overlapping Code:
```
GbmModel_Forest_6 {
public static void score0(double[] fdata, double[] preds) {
preds[1] += GbmModel_Tree_6_class_0.score0(fdata);
preds[2] += GbmModel_Tree_6_class_1.score0(fdata);
preds[3] += GbmModel_Tree_6_class_2.score0(fdata);
preds[4] += GbmModel_Tree_6_class_3.score0(fdata);
preds[5] += GbmModel_Tree_6_class_4.score0(fdata);
preds[6] += Gbm
```
<Overlap Ratio: 0.8860759493670886>

---

--- 219 --
Question ID: c57309757218f4452d89227ab50180b8e1638380
Original Code:
```
public class TaxonomyHostsAndEntryJoinMapper
        implements PairFlatMapFunction<
                Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>>,
                String,
                Taxonomy> {
    private static final long serialVersionUID = -4297072275882262089L;

    @Override
    public Iterator<Tuple2<String, Taxonomy>> call(
            Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>> tuple)
            throws Exception {
        List<Tuple2<String, Taxonomy>> result = new ArrayList<>();
        if (tuple._2 != null && tuple._2._2.isPresent()) {
            TaxonomyEntry entry = tuple._2._2.get();
            Taxonomy host =
                    new TaxonomyBuilder()
                            .taxonId(entry.getTaxonId())
                            .scientificName(entry.getScientificName())
                            .commonName(entry.getCommonName())
                            .mnemonic(entry.getMnemonic())
                            .build();
            for (String taxId : tuple._2._1) {
                result.add(new Tuple2<>(taxId, host));
            }
        }
        return result.iterator();
    }
}
```


Overlapping Code:
```
JoinMapper
implements PairFlatMapFunction<
Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>>,
String,
Taxonomy> {
private static final long serialVersionUID = -4297072275882262089L;
@Override
public Iterator<Tuple2<String, Taxonomy>> call(
Tuple2<String, Tuple2<Iterable<String>, Optional<TaxonomyEntry>>> tuple)
throws Exception {
List<Tuple2<String, Taxonomy>> result = new ArrayList<>();
if (tuple._2 != null && tuple._2._2.isPresent()) {
TaxonomyEntry entry = tuple._2._2.get();
Taxonomy host =
new TaxonomyBuilder()
.taxonId(entry.getTaxonId())
.scientificName(entry.getScientificName())
.commonName(entry.getCommonName())
.mnemonic(entry.getMnemonic())
.build();
for (String taxId : tuple._2._1) {
result.add(new Tuple2<>(taxId,
```
<Overlap Ratio: 0.9079903147699758>

---

--- 220 --
Question ID: dcd4aaf48aa52b3cacd9a090b60f56760ec87604
Original Code:
```
public class SpeechToText {

	public String lang;
	private String apiKey;
	
	/**
	 * @param lang language
	 */
	public SpeechToText(String lang, String apiKey) {
		this.lang = lang;
		this.apiKey = apiKey;
	}
	
	/**
	 * 
	 * @param speech audio file to transcribe
	 * @return text
	 */
	public String speechToText(File speech) {
		URLBuilder urlb = new URLBuilder("http://www.google.com/speech-api/v2/recognize");
		
		urlb.args.put("key", apiKey);
		urlb.args.put("lang", lang);
		
		String transcript = null;
		try {
			String resultJsonString = NetworkUtils.uploadAudioFileAndGetResult(urlb.buildUrl(), speech);
			System.out.println(resultJsonString);
			JSONObject resultJson = new JSONObject(resultJsonString);
			
			JSONArray resultArray = resultJson.getJSONArray("result");
			JSONArray alternativeArray = resultArray.getJSONObject(0).getJSONArray("alternative");
			
			double hiestConfidence = -1.0;
			for (int i = 0; i < alternativeArray.length(); i++) {
				JSONObject obj = alternativeArray.getJSONObject(i);

				double currentConf = obj.getDouble("confidence");
				if (currentConf > hiestConfidence) {
					hiestConfidence = currentConf; 
					transcript = obj.getString("transcript");
				}
				
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
		return transcript;
	}
}
```


Overlapping Code:
```
lass SpeechToText {
public String lang;
private String apiKey;

/**
* @param lang language
*/
public SpeechToText(String lang, String apiKey) {
this.lang = lang;
this.apiKey = apiKey;
}

/**
* 
* @param speech audio file to transcribe
* @return text
*/
public String speechToText(File speech) {
URLBuilder urlb = new URLBuilder("http://www.google.com/speech-api/v2/recognize");

urlb.args.put("key", apiKey);
urlb.args.put("lang", lang);

String transcript = null;
try {
String resultJsonString = NetworkUtils.uploadAudioFileAndGetResult(urlb.buildUrl(), speech);
System.out.println(resultJsonString);
JSONObject resultJson = new JSONObject(resultJsonString);

JSONArray resultArray = resultJson.getJSONArray("result");
JSONArray alternativeArray = resultArray.getJSONObject(0).getJSONArray("alternative");

double hiestConfidence = -1.0;
for (int i = 0; i < alternativeArray.length(); i++) {
JSONObject obj = alternativeArray.getJSONObject(i);
double currentConf = obj.getDouble("confidence");
if (currentConf > hiestConfidence) {
hiestConfidence = currentConf; 
transcript = obj.getString("transcript");
}

}

} catch (Exception e) {
e.printStackTrace();
}
return tran
```
<Overlap Ratio: 0.9840201850294366>

---

--- 221 --
Question ID: 9e073177adef4e3090460db8508c681c6f118851
Original Code:
```
public class AnnotatedDependsOnDemo {

	public static void main(String... args) {
		GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
		ctx.load("classpath:spring/app-context-02.xml");
		ctx.refresh();

		Singer johnMayer = ctx.getBean("johnMayer", Singer.class);
		johnMayer.sing();

		ctx.close();
	}

}
```


Overlapping Code:
```
tedDependsOnDemo {
public static void main(String... args) {
GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
ctx.load("classpath:spring/app-context-02.xml");
ctx.refresh();
Singer johnMayer = ctx.getBean("johnMayer", Singer.class);
johnMayer.s
```
<Overlap Ratio: 0.8636363636363636>

---

--- 222 --
Question ID: de4fa7e508a8ccd4630e5d932cdec5820ffdb6a8
Original Code:
```
@Slf4j
@Configuration
public class AsyncPoolConfig extends WebMvcConfigurerAdapter {

    @Bean(name = "asyncPoolTaskExecutor")
    public ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(20);
        taskExecutor.setMaxPoolSize(200);
        taskExecutor.setQueueCapacity(25);
        taskExecutor.setKeepAliveSeconds(200);
        taskExecutor.setThreadNamePrefix("MvcAsync-callable-");
        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        taskExecutor.initialize();
        return taskExecutor;
    }

    @Override
    public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {
        configurer.setDefaultTimeout(60 * 1000);
        configurer.registerCallableInterceptors(timeoutInterceptor());
        configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());
    }

    @Bean
    public TimeoutCallableInterceptor timeoutInterceptor() {
        return new TimeoutCallableInterceptor();
    }

    static class TimeoutCallableInterceptor implements CallableProcessingInterceptor {
        @Override
        public <T> void beforeConcurrentHandling(NativeWebRequest request, Callable<T> task) throws Exception {
        }

        @Override
        public <T> void preProcess(NativeWebRequest request, Callable<T> task) throws Exception {
        }

        @Override
        public <T> void postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult) throws Exception {
        }

        @Override
        public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {
            log.error("任务超时:{}", task.getClass().getName());
            return null;
        }

        @Override
        public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {
            log.error("任务正常结束:{}", task.getClass().getName());
        }
    }

    static class AsyncHandlerInterceptor implements org.springframework.web.servlet.AsyncHandlerInterceptor {
        @Override
        public void afterConcurrentHandlingStarted(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        }

        @Override
        public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
            return false;
        }

        @Override
        public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        }

        @Override
        public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

        }
    }
}
```


Overlapping Code:
```
onfiguration
public class AsyncPoolConfig extends WebMvcConfigurerAdapter {
@Bean(name = "asyncPoolTaskExecutor")
public ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {
ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
taskExecutor.setCorePoolSize(20);
taskExecutor.setMaxPoolSize(200);
taskExecutor.setQueueCapacity(25);
taskExecutor.setKeepAliveSeconds(200);
taskExecutor.setThreadNamePrefix("MvcAsync-callable-");
taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
taskExecutor.initialize();
return taskExecutor;
}
@Override
public void configureAsyncSupport(final AsyncSupportConfigurer configurer) {
configurer.setDefaultTimeout(60 * 1000);
configurer.registerCallableInterceptors(timeoutInterceptor());
configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());
}
@Bean
public TimeoutCallableInterceptor timeoutInterceptor() {
return new TimeoutCallableInterceptor();
}
static class TimeoutCallableInterceptor implements CallableProcessingInterceptor {
@Override
public <T> void beforeConcurrentHandling(NativeWebRequest request, Callable<T> task) throws Exception {
}
@Override
public <T> void preProcess(NativeWebRequest request, Callable<T> task) throws Exception {
}
@Override
public <T> void postProcess(NativeWebRequest request, Callable<T> task, Object concurrentResult) throws Exception {
}
@Override
public <T> Object handleTimeout(NativeWebRequest request, Callable<T> task) throws Exception {
log.error("任务超时:{}", task.getClass().getName());
return null;
}
@Override
public <T> void afterCompletion(NativeWebRequest request, Callable<T> task) throws Exception {
log.error("任务正常结束:{}", task.getClass().getName());
}
}
static class AsyncHandlerInterceptor implements org.springframework.web.servlet.AsyncHandlerInterceptor {
@Override
public void afterConcurrentHandlingStarted(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
}
@Override
public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
retur
```
<Overlap Ratio: 0.9953007518796992>

---

--- 223 --
Question ID: 420f6cd166494f60b19c3681fe6137ac5969a80e
Original Code:
```
public class DebugBridge {
    private static AndroidDebugBridge sDebugBridge;

    @SuppressWarnings("unused")
    private static String getAdbLocation() throws Exception {
        String sdkDir = System.getenv("ANDROID_HOME");
        if (sdkDir == null || sdkDir.equalsIgnoreCase("")) {
            throw new Exception("ENV Variables ANDROID_HOME IS NOT SETTED");
        }

        String toolsDir = sdkDir + File.separator + "tools";
        File sdk = new File(toolsDir).getParentFile();

        // check if adb is present in platform-tools
        File platformTools = new File(sdk, "platform-tools");
        File adb = new File(platformTools, SdkConstants.FN_ADB);
        if (adb.exists()) {
            return adb.getAbsolutePath();
        }

        // check if adb is present in the tools directory
        adb = new File(toolsDir, SdkConstants.FN_ADB);
        if (adb.exists()) {
            return adb.getAbsolutePath();
        }

        // check if we're in the Android source tree where adb is in $ANDROID_HOST_OUT/bin/adb
        String androidOut = System.getenv("ANDROID_HOST_OUT");
        if (androidOut != null) {
            String adbLocation = androidOut + File.separator + "bin" + File.separator +
                    SdkConstants.FN_ADB;
            if (new File(adbLocation).exists()) {
                return adbLocation;
            }
        }

        return null;
    }

    /**
     * Init.
     */
    public static void init() {
        if (sDebugBridge == null) {
            String adbLocation = null;
            try {
                adbLocation = getAdbLocation();
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (adbLocation != null) {
                AndroidDebugBridge.init(false);
                sDebugBridge = AndroidDebugBridge.createBridge(adbLocation, false);
                waitDeviceList(sDebugBridge);
            }
        }
    }

    /**
     * Terminate.
     */
    public static void terminate() {
        if (sDebugBridge != null) {
            sDebugBridge = null;
            AndroidDebugBridge.terminate();
        }
    }

    /**
     * Gets devices.
     *
     * @return the devices
     */
    public static List<IDevice> getDevices() {
        return Arrays.asList(sDebugBridge.getDevices());
    }

    private static void waitDeviceList(AndroidDebugBridge bridge) {
        int count = 0;
        while (!bridge.hasInitialDeviceList()) {
            try {
                Thread.sleep(500);
                count++;
            } catch (InterruptedException ignored) {
            }
            if (count > 60) {
                System.err.print("等待获取设备超时");
                break;
            }
        }
    }

    /**
     * Gets device.
     *
     * @return the device
     * @throws IOException the io exception
     */
    public static IDevice getDevice() throws IOException {
        List<IDevice> devices = getDevices();
        if (devices.size() == 0) {
            throw new IOException("No Android devices were detected by adb.");
        } else if (devices.size() >= 1) {
            return devices.get(0);
        }
        return null;
    }

    /**
     * Gets device.
     *
     * @param index the index
     * @return the device
     * @throws IOException the io exception
     */
    public static IDevice getDevice(int index) throws IOException {
        List<IDevice> devices = getDevices();
        if (devices.size() == 0) {
            throw new IOException("No Android devices were detected by adb.");
        } else if (devices.size() >= 1) {
            return devices.get(index);
        }
        return null;
    }
}
```


Overlapping Code:
```
ugBridge {
private static AndroidDebugBridge sDebugBridge;
@SuppressWarnings("unused")
private static String getAdbLocation() throws Exception {
String sdkDir = System.getenv("ANDROID_HOME");
if (sdkDir == null || sdkDir.equalsIgnoreCase("")) {
throw new Exception("ENV Variables ANDROID_HOME IS NOT SETTED");
}
String toolsDir = sdkDir + File.separator + "tools";
File sdk = new File(toolsDir).getParentFile();
// check if adb is present in platform-tools
File platformTools = new File(sdk, "platform-tools");
File adb = new File(platformTools, SdkConstants.FN_ADB);
if (adb.exists()) {
return adb.getAbsolutePath();
}
// check if adb is present in the tools directory
adb = new File(toolsDir, SdkConstants.FN_ADB);
if (adb.exists()) {
return adb.getAbsolutePath();
}
// check if we're in the Android source tree where adb is in $ANDROID_HOST_OUT/bin/adb
String androidOut = System.getenv("ANDROID_HOST_OUT");
if (androidOut != null) {
String adbLocation = androidOut + File.separator + "bin" + File.separator +
SdkConstants.FN_ADB;
if (new File(adbLocation).exists()) {
return adbLocation;
}
}
return null;
}
/**
* Init.
*/
public static void init() {
if (sDebugBridge == null) {
String adbLocation = null;
try {
adbLocation = getAdbLocation();
} catch (Exception e) {
e.printStackTrace();
}
if (adbLocation != null) {
AndroidDebugBridge.init(false);
sDebugBridge = AndroidDebugBridge.createBridge(adbLocation, false);
waitDeviceList(sDebugBridge);
}
}
}
/**
* Terminate.
*/
public static void terminate() {
if (sDebugBridge != null) {
sDebugBridge = null;
AndroidDebugBridge.terminate();
}
}
/**
* Gets devices.
*
* @return the devices
*/
public static List<IDevice> getDevices() {
return Arrays.asList(sDebugBridge.getDevices());
}
private static void waitDeviceList(AndroidDebugBridge bridge) {
int count = 0;
while (!bridge.hasInitialDeviceList()) {
try 
```
<Overlap Ratio: 0.9909429941395844>

---

--- 224 --
Question ID: 222ddd87afd4681494ed1c57cd57e975d01443c5
Original Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class AbiDefinition {
    private boolean constant;
    private List<NamedType> inputs;
    private String name;
    private List<NamedType> outputs;
    private String type;
    private boolean payable;

    /**
     * The stateMutability function modifier.
     *
     * <p>this does not factor into the <code>#hashCode()</code> or <code>#equals()</code> logic
     * since multiple functions with the same signature that only differ in mutability are not
     * allowed in Solidity.
     *
     * <p>Valid values are:
     *
     * <ul>
     *   <li>pure
     *   <li>view
     *   <li>nonpayable
     *   <li>payable
     * </ul>
     */
    private String stateMutability;

    public AbiDefinition() {}

    public AbiDefinition(AbiDefinition from) {
        this(
                from.constant,
                clone(from.inputs),
                from.name,
                clone(from.outputs),
                from.type,
                from.payable,
                from.stateMutability);
    }

    public AbiDefinition(
            boolean constant,
            List<NamedType> inputs,
            String name,
            List<NamedType> outputs,
            String type,
            boolean payable) {
        this(constant, inputs, name, outputs, type, payable, null);
    }

    public AbiDefinition(
            boolean constant,
            List<NamedType> inputs,
            String name,
            List<NamedType> outputs,
            String type,
            boolean payable,
            String stateMutability) {
        this.constant = constant;
        this.inputs = inputs;
        this.name = name;
        this.outputs = outputs;
        this.type = type;
        this.payable = payable;
        this.stateMutability = stateMutability;
    }

    public boolean isConstant() {
        return constant;
    }

    public void setConstant(boolean constant) {
        this.constant = constant;
    }

    public List<NamedType> getInputs() {
        return inputs;
    }

    public void setInputs(List<NamedType> inputs) {
        this.inputs = inputs;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<NamedType> getOutputs() {
        return outputs;
    }

    public boolean hasOutputs() {
        return !outputs.isEmpty();
    }

    public void setOutputs(List<NamedType> outputs) {
        this.outputs = outputs;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public boolean isPayable() {
        return payable;
    }

    public void setPayable(boolean payable) {
        this.payable = payable;
    }

    public String getStateMutability() {
        return stateMutability;
    }

    public void setStateMutability(String stateMutability) {
        this.stateMutability = stateMutability;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof AbiDefinition)) {
            return false;
        }

        AbiDefinition that = (AbiDefinition) o;

        if (isConstant() != that.isConstant()) {
            return false;
        }
        if (isPayable() != that.isPayable()) {
            return false;
        }
        if (getInputs() != null
                ? !getInputs().equals(that.getInputs())
                : that.getInputs() != null) {
            return false;
        }
        if (getName() != null ? !getName().equals(that.getName()) : that.getName() != null) {
            return false;
        }
        if (getOutputs() != null
                ? !getOutputs().equals(that.getOutputs())
                : that.getOutputs() != null) {
            return false;
        }
        if (getStateMutability() != null
                ? !getStateMutability().equals(that.getStateMutability())
                : that.getStateMutability() != null) {
            return false;
        }
        return getType() != null ? getType().equals(that.getType()) : that.getType() == null;
    }

    @Override
    public int hashCode() {
        int result = (isConstant() ? 1 : 0);
        result = 31 * result + (getInputs() != null ? getInputs().hashCode() : 0);
        result = 31 * result + (getName() != null ? getName().hashCode() : 0);
        result = 31 * result + (getOutputs() != null ? getOutputs().hashCode() : 0);
        result = 31 * result + (getType() != null ? getType().hashCode() : 0);
        result = 31 * result + (isPayable() ? 1 : 0);
        result = 31 * result + (getStateMutability() != null ? getStateMutability().hashCode() : 0);
        return result;
    }

    public static class NamedType {
        private String name;
        private String type;
        private boolean indexed;

        public NamedType() {}

        public NamedType(NamedType from) {
            this(from.name, from.type, from.indexed);
        }

        public NamedType(String name, String type) {
            this.name = name;
            this.type = type;
        }

        public NamedType(String name, String type, boolean indexed) {
            this.name = name;
            this.type = type;
            this.indexed = indexed;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public boolean isIndexed() {
            return indexed;
        }

        public void setIndexed(boolean indexed) {
            this.indexed = indexed;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (!(o instanceof NamedType)) {
                return false;
            }

            NamedType namedType = (NamedType) o;

            if (isIndexed() != namedType.isIndexed()) {
                return false;
            }

            if (getName() != null
                    ? !getName().equals(namedType.getName())
                    : namedType.getName() != null) {
                return false;
            }
            return getType() != null
                    ? getType().equals(namedType.getType())
                    : namedType.getType() == null;
        }

        @Override
        public int hashCode() {
            int result = getName() != null ? getName().hashCode() : 0;
            result = 31 * result + (getType() != null ? getType().hashCode() : 0);
            result = 31 * result + (isIndexed() ? 1 : 0);
            return result;
        }
    }

    private static List<NamedType> clone(final List<NamedType> from) {
        return from.stream().map(NamedType::new).collect(Collectors.toList());
    }
}
```


Overlapping Code:
```
@JsonIgnoreProperties(ignoreUnknown = true)
public class AbiDefinition {
private boolean constant;
private List<NamedType> inputs;
private String name;
private List<NamedType> outputs;
private String type;
private boolean payable;
/**
* The stateMutability function modifier.
*
* <p>this does not factor into the <code>#hashCode()</code> or <code>#equals()</code> logic
* since multiple functions with the same signature that only differ in mutability are not
* allowed in Solidity.
*
* <p>Valid values are:
*
* <ul>
* <li>pure
* <li>view
* <li>nonpayable
* <li>payable
* </ul>
*/
private String stateMutability;
public AbiDefinition() {}
public AbiDefinition(AbiDefinition from) {
this(
from.constant,
clone(from.inputs),
from.name,
clone(from.outputs),
from.type,
from.payable,
from.stateMutability);
}
public AbiDefinition(
boolean constant,
List<NamedType> inputs,
String name,
List<NamedType> outputs,
String type,
boolean payable) {
this(constant, inputs, name, outputs, type, payable, null);
}
public AbiDefinition(
boolean constant,
List<NamedType> inputs,
String name,
List<NamedType> outputs,
String type,
boolean payable,
String stateMutability) {
this.constant = constant;
this.inputs = inputs;
this.name = name;
this.outputs = outputs;
this.type = type;
this.payable = payable;
this.stateMutability = stateMutability;
}
public boolean isConstant() {
return constant;
}
public void setConstant(boolean constant) {
this.constant = constant;
}
public List<NamedType> getInputs() {
return inputs;
}
public void setInputs(List<NamedType> inputs) {
this.inputs = inputs;
}
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}
public List<NamedType> getOutputs() {
return outputs;
}
public boolean hasOutputs() {
return !outputs.isEmpty();
}
public void setOutputs(List<NamedType> outputs) {
this.outputs = output
```
<Overlap Ratio: 1.0>

---

--- 225 --
Question ID: cd2984fbc240149c4d17851a81de8c97e95bc149
Original Code:
```
public class NewtonUnconstrainedTest extends TestCase {
	private DoubleFactory2D F2 = DoubleFactory2D.dense;
	private Log log = LogFactory.getLog(this.getClass().getName());

	/**
	 * Quadratic objective.
	 */
	public void testOptimize() throws Exception {
		log.debug("testOptimize");
		// START SNIPPET: newtonUnconstrained-1
		
		RealMatrix PMatrix = new Array2DRowRealMatrix(new double[][] {
				{ 1.68, 0.34, 0.38 },
				{ 0.34, 3.09, -1.59 }, 
				{ 0.38, -1.59, 1.54 } });
		RealVector qVector = new ArrayRealVector(new double[] { 0.018, 0.025, 0.01 });

	    // Objective function.
		double theta = 0.01522;
		RealMatrix P = PMatrix.scalarMultiply(theta);
		RealVector q = qVector.mapMultiply(-1);
		PDQuadraticMultivariateRealFunction objectiveFunction = new PDQuadraticMultivariateRealFunction(P.getData(), q.toArray(), 0);
		
		OptimizationRequest or = new OptimizationRequest();
		or.setF0(objectiveFunction);
		or.setInitialPoint(new double[] {0.04, 0.50, 0.46});
		or.setTolerance(1.e-8);
		
	    //optimization
		NewtonUnconstrained opt = new NewtonUnconstrained();
		opt.setOptimizationRequest(or);
		int returnCode = opt.optimize(); 
		
		// END SNIPPET: newtonUnconstrained-1
		
		if(returnCode==OptimizationResponse.FAILED){
			fail();
		}
		
		OptimizationResponse response = opt.getOptimizationResponse();
		double[] sol = response.getSolution();
		log.debug("sol   : " + ArrayUtils.toString(sol));
		log.debug("value : "	+ objectiveFunction.value(sol));

		// we know the analytic solution of the problem
		// sol = -PInv * q
		CholeskyDecomposition cFact = new CholeskyDecomposition(P);
		RealVector benchSol = cFact.getSolver().solve(q).mapMultiply(-1);
		log.debug("benchSol   : " + ArrayUtils.toString(benchSol.toArray()));
		log.debug("benchValue : " + objectiveFunction.value(benchSol.toArray()));

		assertEquals(benchSol.getEntry(0), sol[0], 0.00000000000001);
		assertEquals(benchSol.getEntry(1), sol[1], 0.00000000000001);
		assertEquals(benchSol.getEntry(2), sol[2], 0.00000000000001);
	}

	/**
	 * Test with quite large positive definite symmetric matrix.
	 */
	public void testOptimize2() throws Exception {
		log.debug("testOptimize2");

		int dim = 40;
		
		// positive definite matrix
		Long seed = new Long(54321);
		DoubleMatrix2D mySymmPD = Utils.randomValuesPositiveMatrix(dim, dim, -0.01, 15.5, seed);
		DoubleMatrix1D CVector = Utils.randomValuesMatrix(1, dim, -0.01, 15.5, seed).viewRow(0);
		MySymmFunction objectiveFunction = new MySymmFunction(mySymmPD,	CVector);
		
		//optimization
		OptimizationRequest or = new OptimizationRequest();
		or.setF0(objectiveFunction);
		NewtonUnconstrained opt = new NewtonUnconstrained();
		opt.setOptimizationRequest(or);
		int returnCode = opt.optimize();
		
		if(returnCode==OptimizationResponse.FAILED){
			fail();
		}
		
		OptimizationResponse response = opt.getOptimizationResponse();
		double[] sol = response.getSolution();
		log.debug("sol   : " + ArrayUtils.toString(sol));
		log.debug("value : " + objectiveFunction.value(sol));
		
	  // we know the analytic solution of the problem: Qinv.sol = - C
		cern.colt.matrix.linalg.CholeskyDecomposition cFact = new cern.colt.matrix.linalg.CholeskyDecomposition(mySymmPD);
		DoubleMatrix1D benchSol = cFact.solve(F2.make(CVector.copy().assign(Mult.mult(-1)).toArray(), CVector.size())).viewColumn(0);
		log.debug("benchSol   : " + ArrayUtils.toString(benchSol.toArray()));
		log.debug("benchValue : "	+ objectiveFunction.value(benchSol.toArray()));

		for(int i=0; i<dim;i++){
			assertEquals(benchSol.get(i), sol[i], 0.000001);
		}
	}

	private class MySymmFunction extends PDQuadraticMultivariateRealFunction {

		public MySymmFunction(DoubleMatrix2D P, DoubleMatrix1D q) {
			super(P.toArray(), q.toArray(), 0);
		}

	}
}
```


Overlapping Code:
```
 class NewtonUnconstrainedTest extends TestCase {
private DoubleFactory2D F2 = DoubleFactory2D.dense;
private Log log = LogFactory.getLog(this.getClass().getName());
/**
* Quadratic objective.
*/
public void testOptimize() throws Exception {
log.debug("testOptimize");
// START SNIPPET: newtonUnconstrained-1

RealMatrix PMatrix = new Array2DRowRealMatrix(new double[][] {
{ 1.68, 0.34, 0.38 },
{ 0.34, 3.09, -1.59 }, 
{ 0.38, -1.59, 1.54 } });
RealVector qVector = new ArrayRealVector(new double[] { 0.018, 0.025, 0.01 });
// Objective function.
double theta = 0.01522;
RealMatrix P = PMatrix.scalarMultiply(theta);
RealVector q = qVector.mapMultiply(-1);
PDQuadraticMultivariateRealFunction objectiveFunction = new PDQuadraticMultivariateRealFunction(P.getData(), q.toArray(), 0);

OptimizationRequest or = new OptimizationRequest();
or.setF0(objectiveFunction);
or.setInitialPoint(new double[] {0.04, 0.50, 0.46});
or.setTolerance(1.e-8);

//optimization
NewtonUnconstrained opt = new NewtonUnconstrained();
opt.setOptimizationRequest(or);
int returnCode = opt.optimize(); 

// END SNIPPET: newtonUnconstrained-1

if(returnCode==OptimizationResponse.FAILED){
fail();
}

OptimizationResponse response = opt.getOptimizationResponse();
double[] sol = response.getSolution();
log.debug("sol : " + ArrayUtils.toString(sol));
log.debug("value : " + objectiveFunction.value(sol));
// we know the analytic solution of the problem
// sol = -PInv * q
CholeskyDecomposition cFact = new CholeskyDecomposition(P);
RealVector benchSol = cFact.getSolver().solve(q).mapMultiply(-1);
log.debug("benchSol : " + ArrayUtils.toString(benchSol.toArray()));
log.debug("benchValue : " + objectiveFunction.value(benchSol.toArray()));
assertEquals(benchSol.getEntry(0), sol[0], 0.00000000000001);
assertEquals(benchSol.getEntry(1), sol[1], 0.00000000000001);
assertEquals(benchSol.getEntry(2), sol[2], 0.00000000000001);
}
/**
* Test with quite large positive definite symmetric matrix.
*/
public void testOptimize2() throws Exception {
log.debug("testOptimize2");
int dim = 40;

// positive definite matrix
Long seed = new Long(54321);
DoubleMatrix2D mySymmPD = Utils.randomValuesPositiveMatrix(dim, dim, -0.01, 15.5, seed);
DoubleMatrix1D CVector = Utils.randomValuesMatr
```
<Overlap Ratio: 0.980819529206626>

---

--- 226 --
Question ID: d49b3984ad6ded734a79ffc8c31a25948fd3d85d
Original Code:
```
public class RecipeUtil {
    private static final CBRecipeBackend SERVICE = BackendManager.request(CBRecipeBackend.class).orElseThrow(UnsupportedOperationException::new);

    /**
     * Registers the given recipe.
     * @param recipe the recipe
     */
    public static void register(@NotNull Recipe recipe){
        Bukkit.addRecipe(recipe);
    }

    /**
     * Unregisters the given recipe.
     * @param recipe the recipe
     */
    @Beta
    public static void unregister(@NotNull Recipe recipe){
        SERVICE.removeIf(r -> compare(r, recipe));
    }

    /**
     * Checks if the given recipe is registered.
     * @param recipe the recipe
     * @return {@code true} if it was or {@code false} otherwise
     */
    @Beta
    public static boolean isRegistered(@NotNull Recipe recipe){
        return SERVICE.anyMatch(r -> compare(r, recipe));
    }

    /**
     * Compares two given recipe.
     * @param recipe the first recipe
     * @param otherRecipe the second recipe
     * @return {@code true} if they are equal or {@code false} otherwise
     */
    public static boolean compare(@Nullable Recipe recipe, @Nullable Recipe otherRecipe){
        if(recipe == null && otherRecipe == null) return true;
        if(recipe == null || otherRecipe == null) return false;
        if(NMSVersion.current().compare(NMSVersion.v1_12_R1) >= 0 && recipe instanceof Keyed && otherRecipe instanceof Keyed){
            return ((Keyed) recipe).getKey().equals(((Keyed) otherRecipe).getKey());
        }
        if(recipe instanceof ShapedRecipe && otherRecipe instanceof ShapedRecipe) {
            ShapedRecipe a = (ShapedRecipe) recipe;
            ShapedRecipe b = (ShapedRecipe) otherRecipe;
            if(ItemUtil.compare(a.getResult(), b.getResult())){
                List<ItemStack> ai = new ArrayList<>();
                List<ItemStack> bi = new ArrayList<>();
                for(String as : a.getShape()){
                    for(char ac : as.toCharArray()) ai.add(a.getIngredientMap().get(ac));
                }
                for(String bs : b.getShape()){
                    for(char bc : bs.toCharArray()) bi.add(b.getIngredientMap().get(bc));
                }
                return ItemUtil.compare(ai, bi);
            }
        }
        else if(recipe instanceof ShapelessRecipe && otherRecipe instanceof ShapelessRecipe){
            ShapelessRecipe a = (ShapelessRecipe) recipe;
            ShapelessRecipe b = (ShapelessRecipe) otherRecipe;
            if(ItemUtil.compare(a.getResult(), b.getResult()))
                return ItemUtil.compare(a.getIngredientList(), b.getIngredientList());
        }
        else if(recipe instanceof FurnaceRecipe && otherRecipe instanceof FurnaceRecipe){
            FurnaceRecipe a = (FurnaceRecipe) recipe;
            FurnaceRecipe b = (FurnaceRecipe) otherRecipe;
            return a.getExperience() == b.getExperience()
                    && ItemUtil.compare(a.getInput(), b.getInput())
                    && ItemUtil.compare(a.getResult(), b.getResult());
        }
        else if(recipe instanceof MerchantRecipe && otherRecipe instanceof MerchantRecipe){
            MerchantRecipe a = (MerchantRecipe) recipe;
            MerchantRecipe b = (MerchantRecipe) otherRecipe;
            return a.hasExperienceReward() == b.hasExperienceReward() && a.getMaxUses() == b.getMaxUses() && a.getUses() == b.getUses() && ItemUtil.compare(a.getResult(), b.getResult()) && ItemUtil.compare(a.getIngredients(), b.getIngredients());
        }
        return false;
    }
}
```


Overlapping Code:
```
ublic class RecipeUtil {
private static final CBRecipeBackend SERVICE = BackendManager.request(CBRecipeBackend.class).orElseThrow(UnsupportedOperationException::new);
/**
* Registers the given recipe.
* @param recipe the recipe
*/
public static void register(@NotNull Recipe recipe){
Bukkit.addRecipe(recipe);
}
/**
* Unregisters the given recipe.
* @param recipe the recipe
*/
@Beta
public static void unregister(@NotNull Recipe recipe){
SERVICE.removeIf(r -> compare(r, recipe));
}
/**
* Checks if the given recipe is registered.
* @param recipe the recipe
* @return {@code true} if it was or {@code false} otherwise
*/
@Beta
public static boolean isRegistered(@NotNull Recipe recipe){
return SERVICE.anyMatch(r -> compare(r, recipe));
}
/**
* Compares two given recipe.
* @param recipe the first recipe
* @param otherRecipe the second recipe
* @return {@code true} if they are equal or {@code false} otherwise
*/
public static boolean compare(@Nullable Recipe recipe, @Nullable Recipe otherRecipe){
if(recipe == null && otherRecipe == null) return true;
if(recipe == null || otherRecipe == null) return false;
if(NMSVersion.current().compare(NMSVersion.v1_12_R1) >= 0 && recipe instanceof Keyed && otherRecipe instanceof Keyed){
return ((Keyed) recipe).getKey().equals(((Keyed) otherRecipe).getKey());
}
if(recipe instanceof ShapedRecipe && otherRecipe instanceof ShapedRecipe) {
ShapedRecipe a = (ShapedRecipe) recipe;
ShapedRecipe b = (ShapedRecipe) otherRecipe;
if(ItemUtil.compare(a.getResult(), b.getResult())){
List<ItemStack> ai = new ArrayList<>();
List<ItemStack> bi = new ArrayList<>();
for(String as : a.getShape()){
for(char ac : as.toCharArray()) ai.add(a.getIngredientMap().get(ac));
}
for(String bs : b.getShape()){
for(char bc : bs.toCharArray()) bi.add(b.getIngredientMap().get(bc));
}
return ItemUtil.compare(ai, bi);
}
}
else if(recipe instanceof ShapelessRecipe && otherRecipe instanceof ShapelessRecipe){
ShapelessRecipe a = (ShapelessRecipe) recipe;
ShapelessRecipe b = (Shap
```
<Overlap Ratio: 0.9823182711198428>

---

--- 227 --
Question ID: a1dd3ed47914f0a80fc7c291f437b9fca0235a12
Original Code:
```
class B implements I {
    public void m() {
        <selection>System.out.println(A.TEXT);</selection>
    }
}
```


Overlapping Code:
```
() {
<selection>System.out.println(A.TEXT);</selec
```
<Overlap Ratio: 0.5263157894736842>

---

--- 228 --
Question ID: 1da401e2657d0e2241f5d273e46bcfa6c48b49ff
Original Code:
```
public class DatumUtilsTest {
  @Test
  public void testNewEmptySubDatum() {
    Subscriber subscriber = new Subscriber();
    subscriber.setDataId("subscriber-dataId");
    subscriber.setGroup("DEFAULT_GROUP");
    subscriber.setInstanceId("InstanceId");
    subscriber.setDataInfoId("dataInfoId");
    SubDatum subDatum =
        DatumUtils.newEmptySubDatum(subscriber, "testDc", ValueConstants.DEFAULT_NO_DATUM_VERSION);
    Assert.assertEquals(subDatum.getDataCenter(), "testDc");
    Assert.assertEquals(subDatum.getDataInfoId(), subscriber.getDataInfoId());
    Assert.assertEquals(subDatum.getDataId(), subscriber.getDataId());
    Assert.assertEquals(subDatum.getInstanceId(), subscriber.getInstanceId());
    Assert.assertEquals(subDatum.getGroup(), subscriber.getGroup());
    Assert.assertEquals(subDatum.getVersion(), ValueConstants.DEFAULT_NO_DATUM_VERSION);
    Assert.assertTrue(subDatum.mustGetPublishers().isEmpty());
  }

  @Test
  public void testIntern() {
    Map<String, DatumVersion> m = Collections.singletonMap("test", DatumVersion.of(100));
    Assert.assertEquals(DatumUtils.intern(m), m);
  }

  @Test
  public void testDatum() {
    Datum datum = new Datum();
    Publisher publisher = new Publisher();
    publisher.setRegisterId("testRegisterId");
    publisher.setCell("testCell");
    publisher.setDataList(Collections.emptyList());
    publisher.setVersion(100);
    publisher.setRegisterTimestamp(System.currentTimeMillis());
    publisher.setPublishSource(PublishSource.CLIENT);
    datum.addPublisher(publisher);
    datum.setDataCenter("testDc");
    datum.setDataId("testDataId");
    datum.setVersion(200);
    datum.setInstanceId("testInstanceId");
    datum.setGroup("testGroup");
    datum.setDataInfoId("testDataInfoId");
    SubDatum subDatum = DatumUtils.of(datum);

    Assert.assertEquals(subDatum.getDataCenter(), datum.getDataCenter());
    Assert.assertEquals(subDatum.getDataInfoId(), datum.getDataInfoId());
    Assert.assertEquals(subDatum.getDataId(), datum.getDataId());
    Assert.assertEquals(subDatum.getInstanceId(), datum.getInstanceId());
    Assert.assertEquals(subDatum.getGroup(), datum.getGroup());
    Assert.assertEquals(subDatum.getVersion(), datum.getVersion());

    Publisher p = datum.getPubMap().get(publisher.getRegisterId());

    Assert.assertEquals(p.getRegisterId(), publisher.getRegisterId());
    Assert.assertEquals(p.getCell(), publisher.getCell());
    Assert.assertEquals(p.getDataList(), publisher.getDataList());
    Assert.assertEquals(p.getVersion(), publisher.getVersion());
    Assert.assertEquals(p.getRegisterTimestamp(), publisher.getRegisterTimestamp());
    Assert.assertEquals(p.getPublishSource(), publisher.getPublishSource());
  }

  @Test
  public void testDataBoxListSize() {
    DataBox box = new DataBox();
    box.setData("111111111111111111111111111111111");
    Assert.assertEquals(33, DatumUtils.DataBoxListSize(Lists.newArrayList(box)));
    Assert.assertEquals(0, DatumUtils.DataBoxListSize(null));
  }

  @Test
  public void testServerDataBoxListSize() {
    ServerDataBox box = new ServerDataBox("111111111111111111111111111111111");
    Assert.assertEquals(40, DatumUtils.ServerDataBoxListSize(Lists.newArrayList(box)));
    Assert.assertEquals(0, DatumUtils.ServerDataBoxListSize(null));
  }

  @Test
  public void testCompress() {
    Datum datum = new Datum();
    Publisher publisher = new Publisher();
    publisher.setRegisterId("testRegisterId");
    publisher.setCell("testCell");
    publisher.setDataList(Collections.emptyList());
    publisher.setVersion(100);
    publisher.setRegisterTimestamp(System.currentTimeMillis());
    publisher.setPublishSource(PublishSource.CLIENT);
    datum.addPublisher(publisher);
    datum.setDataCenter("testDc");
    datum.setDataId("testDataId");
    datum.setVersion(200);
    datum.setInstanceId("testInstanceId");
    datum.setGroup("testGroup");
    datum.setDataInfoId("testDataInfoId");
    SubDatum subDatum = DatumUtils.of(datum);

    SubDatum zip = DatumUtils.compressSubDatum(subDatum, CompressUtils.mustGet("zstd"));
    SubDatum unzip = DatumUtils.decompressSubDatum(zip);
    Assert.assertEquals(1, zip.getPubNum());
    Assert.assertEquals(1, unzip.getPubNum());
    Assert.assertEquals("testRegisterId", unzip.mustGetPublishers().get(0).getRegisterId());
  }
}
```


Overlapping Code:
```
st
public void testNewEmptySubDatum() {
Subscriber subscriber = new Subscriber();
subscriber.setDataId("subscriber-dataId");
subscriber.setGroup("DEFAULT_GROUP");
subscriber.setInstanceId("InstanceId");
subscriber.setDataInfoId("dataInfoId");
SubDatum subDatum =
DatumUtils.newEmptySubDatum(subscriber, "testDc", ValueConstants.DEFAULT_NO_DATUM_VERSION);
Assert.assertEquals(subDatum.getDataCenter(), "testDc");
Assert.assertEquals(subDatum.getDataInfoId(), subscriber.getDataInfoId());
Assert.assertEquals(subDatum.getDataId(), subscriber.getDataId());
Assert.assertEquals(subDatum.getInstanceId(), subscriber.getInstanceId());
Assert.assertEquals(subDatum.getGroup(), subscriber.getGroup());
Assert.assertEquals(subDatum.getVersion(), ValueConstants.DEFAULT_NO_DATUM_VERSION);
Assert.assertTrue(subDatum.mustGetPublishers().isEmpty());
}
@Test
public void testIntern() {
Map<String, DatumVersion> m = Collections.singletonMap("test", DatumVersion.of(100));
Assert.assertEquals(DatumUtils.intern(m), m);
}
@Test
public void testDatum() {
Datum datum = new Datum();
Publisher publisher = new Publisher();
publisher.setRegisterId("testRegisterId");
publisher.setCell("testCell");
publisher.setDataList(Collections.emptyList());
publisher.setVersion(100);
publisher.setRegisterTimestamp(System.currentTimeMillis());
publisher.setPublishSource(PublishSource.CLIENT);
datum.addPublisher(publisher);
datum.setDataCenter("testDc");
datum.setDataId("testDataId");
datum.setVersion(200);
datum.setInstanceId("testInstanceId");
datum.setGroup("testGroup");
datum.setDataInfoId("testDataInfoId");
SubDatum subDatum = DatumUtils.of(datum);
Assert.assertEquals(subDatum.getDataCenter(), datum.getDataCenter());
Assert.assertEquals(subDatum.getDataInfoId(), datum.getDataInfoId());
Assert.assertEquals(subDatum.getDataId(), datum.getDataId());
Assert.assertEquals(subDatum.getInstanceId(), datum.getInstanceId());
Assert.assertEquals(subDatum.getGroup(), datum.getGroup());
Assert.assertEquals(subDatum.getVersion(), datum.getVersion());
Publisher p = datum.getPubMap().get(publisher.getRegisterId());
Assert.assertEquals(p.getRegisterId(), publisher.getRegisterId());
Assert.assertEquals(p.getCell(), publisher.getCell());
Assert.assertEquals(p.getDataList(), pu
```
<Overlap Ratio: 0.9757155247181266>

---

--- 229 --
Question ID: d2df215913367b4c103bb7a7ee7e8b8409022d69
Original Code:
```
public final class ApiSignature {
    /**
     * API auth signature creation method using token and
     * secret key. Uses Hash HMAC algorithm with SHA256
     *
     * @param token         Unique auth token provided to user
     * @param secret        Secret key of the user
     * @param parameters    Request parameters as key value pair
     * @param url           Complete API url without query string or request params
     * @param requestMethod HTTP request method for this request (GET|POST|PUT|DELETE|OPTIONS)
     * @return base64 encoded signature
     */
    public static String createSignature(String token, String secret, HashMap<String, String> parameters, String url, String requestMethod) {
        AppLog.d("API trace: X-Api-AuthToken : " + token);
        AppLog.d("API trace: Requested Url : " + url + "; Method Type : " + requestMethod);

        String longStr = requestMethod + '|' + url + "\n";

        // if mapData is present the sort it and add key value to the string
        if (parameters != null) {
            TreeMap<String, String> sortedData = new TreeMap<>(parameters);
            for (Map.Entry<String, String> entry : sortedData.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
                longStr += (key + value);
            }
        }

        // trim the string
        longStr = (longStr + token).trim();

        // if secret is null then there is no need of creating th signature since signature creating needs
        // api secret
        if (secret != null) {
            try {
                final String algorithm = "HmacSHA256";
                SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes(), algorithm);
                Mac mac = Mac.getInstance(algorithm);
                mac.init(signingKey);
                byte[] rawHmac = mac.doFinal(longStr.getBytes());
                String hexHmacString = Utility.bytesToHex(rawHmac);
                byte[] hexHmacByte = hexHmacString.trim().toLowerCase().getBytes();
                return Base64.encodeToString(hexHmacByte, Base64.NO_WRAP);
            } catch (NoSuchAlgorithmException exception) {
                AppLog.e(exception);
                return null;
            } catch (InvalidKeyException exception) {
                AppLog.e(exception);
                return null;
            }
        }
        return null;
    }
}
```


Overlapping Code:
```
ass ApiSignature {
/**
* API auth signature creation method using token and
* secret key. Uses Hash HMAC algorithm with SHA256
*
* @param token Unique auth token provided to user
* @param secret Secret key of the user
* @param parameters Request parameters as key value pair
* @param url Complete API url without query string or request params
* @param requestMethod HTTP request method for this request (GET|POST|PUT|DELETE|OPTIONS)
* @return base64 encoded signature
*/
public static String createSignature(String token, String secret, HashMap<String, String> parameters, String url, String requestMethod) {
AppLog.d("API trace: X-Api-AuthToken : " + token);
AppLog.d("API trace: Requested Url : " + url + "; Method Type : " + requestMethod);
String longStr = requestMethod + '|' + url + "\n";
// if mapData is present the sort it and add key value to the string
if (parameters != null) {
TreeMap<String, String> sortedData = new TreeMap<>(parameters);
for (Map.Entry<String, String> entry : sortedData.entrySet()) {
String key = entry.getKey();
String value = entry.getValue();
longStr += (key + value);
}
}
// trim the string
longStr = (longStr + token).trim();
// if secret is null then there is no need of creating th signature since signature creating needs
// api secret
if (secret != null) {
try {
final String algorithm = "HmacSHA256";
SecretKeySpec signingKey = new SecretKeySpec(secret.getBytes(), algorithm);
Mac mac = Mac.getInstance(algorithm);
mac.init(signingKey);
byte[] rawHmac = mac.doFinal(longStr.getBytes());
String hexHmacString = Utility.bytesToHex(rawHmac);
byte[] hexHmacByte = hexHmacString.trim().toLowerCase().getBytes();
return Base64.encodeToString(hexHmacByte, Base64.NO_WRAP);
} catch (NoSuchAlgorithmException exception) {
AppLog.e(exception);
return null;
} catch (InvalidKeyException exception) {
AppLog.e(excepti
```
<Overlap Ratio: 0.9721492380451918>

---

--- 230 --
Question ID: 05a03bbd55ae1a5cad492d5614bbafd937996336
Original Code:
```
@ApiModel(description = "JIT provisioning related configurations")
public class JITProvisioningDTO  {
  
  
  
  private Boolean enable = null;
  
  
  private String userstoreDomain = null;

  
  /**
   **/
  @ApiModelProperty(value = "")
  @JsonProperty("enable")
  public Boolean getEnable() {
    return enable;
  }
  public void setEnable(Boolean enable) {
    this.enable = enable;
  }

  
  /**
   **/
  @ApiModelProperty(value = "")
  @JsonProperty("userstoreDomain")
  public String getUserstoreDomain() {
    return userstoreDomain;
  }
  public void setUserstoreDomain(String userstoreDomain) {
    this.userstoreDomain = userstoreDomain;
  }

  

  @Override
  public String toString()  {
    StringBuilder sb = new StringBuilder();
    sb.append("class JITProvisioningDTO {\n");
    
    sb.append("  enable: ").append(enable).append("\n");
    sb.append("  userstoreDomain: ").append(userstoreDomain).append("\n");
    sb.append("}\n");
    return sb.toString();
  }
}
```


Overlapping Code:
```
 provisioning related configurations")
public class JITProvisioningDTO {



private Boolean enable = null;


private String userstoreDomain = null;

/**
**/
@ApiModelProperty(value = "")
@JsonProperty("enable")
public Boolean getEnable() {
return enable;
}
public void setEnable(Boolean enable) {
this.enable = enable;
}

/**
**/
@ApiModelProperty(value = "")
@JsonProperty("userstoreDomain")
public String getUserstoreDomain() {
return userstoreDomain;
}
public void setUserstoreDomain(String userstoreDomain) {
this.userstoreDomain = userstoreDomain;
}

@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class JITProvisioningDTO {\n");

sb.append(" enable: ").append(enable).append("\n");
sb.append(" userstoreDomain: ").append(userstoreDomain).append("\n");
sb.append("}\n");
return sb.toString();
}
}
```
<Overlap Ratio: 0.967816091954023>

---

--- 231 --
Question ID: fc1939f013d8e79b6c3887a37823ff5a31eb1d79
Original Code:
```
public class LambdaHandlerTest extends AbstractRequestHandler<UserRequestTest, UserResponseTest> {

    @Override
    public void before(Context context) throws HttpException {
        addResponseHeader("Access-Control-Allow-Origin", "*");
    }

    @Override
    public UserResponseTest execute(UserRequestTest input, Context context) throws HttpException {
                            
        UserResponseTest response = new UserResponseTest();
        response.setId(UUID.randomUUID().toString());
        response.setName(input.getName());
        response.setAddress(input.getAddress());
        
        return response;
    }

}
```


Overlapping Code:
```
blic class LambdaHandlerTest extends AbstractRequestHandler<UserRequestTest, UserResponseTest> {
@Override
public void before(Context context) throws HttpException {
addResponseHeader("Access-Control-Allow-Origin", "*");
}
@Override
public UserResponseTest execute(UserRequestTest input, Context context) throws HttpException {

UserResponseTest response = new UserResponseTest();
response.setId(UUID.randomUUID().toString());
response.setName(input.getName());
response.setAddress(input.getAddress());

return response;

```
<Overlap Ratio: 0.9904942965779467>

---

--- 232 --
Question ID: bf6b88c597bbc2599d68689fd7edfb1fa27724c7
Original Code:
```
public class LeadingSpan extends RelativeLineHeightSpan {
    public LeadingSpan(float scalar) {
        super(scalar);
    }

    @Override public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int v,
                                       Paint.FontMetricsInt metrics) {
        // Only operate on the first line (see IconMarginSpan, DrawableMarginSpan). This will affect
        // all following lines through the metrics parameter output
        if (start == ((Spanned) text).getSpanStart(this)) {
            // Don't change the state of metrics until all calculations are performed.
            int scaledAscender = (int) scaledAscender(metrics);
            int scaledDescender = (int) scaledDescender(metrics);

            metrics.ascent = scaledAscender;
            metrics.descent = scaledDescender;
        }
    }
}
```


Overlapping Code:
```
tiveLineHeightSpan {
public LeadingSpan(float scalar) {
super(scalar);
}
@Override public void chooseHeight(CharSequence text, int start, int end, int spanstartv, int v,
Paint.FontMetricsInt metrics) {
// Only operate on the first line (see IconMarginSpan, DrawableMarginSpan). This will affect
// all following lines through the metrics parameter output
if (start == ((Spanned) text).getSpanStart(this)) {
// Don't change the state of metrics until all calculations are performed.
int scaledAscender = (int) scaledAscender(metrics);
int scaledDescender = (int) scaledDescender(metrics);
metrics.ascent = scaledAscender;
metrics.descent = scaledDescender;
}

```
<Overlap Ratio: 0.9426934097421203>

---

--- 233 --
Question ID: 69b7d346760caef0f459834a300f9f748badb527
Original Code:
```
public class XmlReader {

	public static Element racine;
	
	public static void main(String[] args) {
		// Import fichier xml pour lecture
		File file = new File("C:\\Users\\HB\\workspace\\Initiation_Java\\ressources\\trainees.xml");

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		DocumentBuilder db = null;
		Document document = null;
		
		try {
			db = dbf.newDocumentBuilder();
			document = (Document) db.parse(file);
		} catch (SAXException | IOException | ParserConfigurationException e ) {
			e.printStackTrace();
		}
		
		// Element racine
		final Element racine = document.getDocumentElement();
		
		// Noeuds enfant
		final NodeList trainees = racine.getChildNodes();

		
		// Elements
		Element trainee, lastname, firstname, email, hobbies, hobby, title, director, singer;
		
		// Parcourir les noeuds
		for (int i=0; i<trainees.getLength(); i++) {
			if (trainees.item(i).getNodeType() == Node.ELEMENT_NODE) { // Si Noeud du type Element
				// Noeud trainee
				trainee = (Element) trainees.item(i);
				System.out.println("\nsexe : " + trainee.getAttribute("sexe"));
					// Noeud lastname
					lastname = (Element) trainee.getElementsByTagName("lastname").item(0);
					System.out.println("lastname : " + lastname.getTextContent());
					// Noeud firstname
					firstname = (Element) trainee.getElementsByTagName("firstname").item(0);
					System.out.println("firstname : " + firstname.getTextContent());
					// Noeud email
					email = (Element) trainee.getElementsByTagName("email").item(0);
					System.out.println("email : " + email.getTextContent());
					
					// Noeud Hobbies
					NodeList hobbiesNodes = null;
					hobbiesNodes = trainee.getElementsByTagName("hobbies");						
					for (int j=0; j<hobbiesNodes.getLength(); j++) {
						
						hobbies = (Element) hobbiesNodes.item(j);
						System.out.println("hobbies : " + "\n{");
						
						// Noeud Hobby
						NodeList hobbyNodes = null;
						hobbyNodes = hobbies.getElementsByTagName("hobby");
						for (int k = 0; k < hobbyNodes.getLength(); k++) {
							hobby = (Element) hobbyNodes.item(k);
							
							if (hobby.getAttribute("category").equals("cinema")) { // cinema
								title = (Element) hobby.getElementsByTagName("title").item(0);
								director = (Element) hobby.getElementsByTagName("director").item(0);
								System.out.println("  cinema : " + title.getTextContent() + ", director : " + director.getTextContent());
							}
							if (hobby.getAttribute("category").equals("music")) { // music
								title = (Element) hobby.getElementsByTagName("title").item(0);
								singer = (Element) hobby.getElementsByTagName("singer").item(0);
								System.out.println("  music : " + title.getTextContent() + ", singer : " + singer.getTextContent());
							}
							if (hobby.getAttribute("category").equals("sport")) { // sport
								System.out.println("  sport : " + hobby.getTextContent());
							}
							
						}
						
						System.out.println("}");
		
					}
			
						
			}
		}

	}

}
```


Overlapping Code:
```
s XmlReader {
public static Element racine;

public static void main(String[] args) {
// Import fichier xml pour lecture
File file = new File("C:\\Users\\HB\\workspace\\Initiation_Java\\ressources\\trainees.xml");
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder db = null;
Document document = null;

try {
db = dbf.newDocumentBuilder();
document = (Document) db.parse(file);
} catch (SAXException | IOException | ParserConfigurationException e ) {
e.printStackTrace();
}

// Element racine
final Element racine = document.getDocumentElement();

// Noeuds enfant
final NodeList trainees = racine.getChildNodes();

// Elements
Element trainee, lastname, firstname, email, hobbies, hobby, title, director, singer;

// Parcourir les noeuds
for (int i=0; i<trainees.getLength(); i++) {
if (trainees.item(i).getNodeType() == Node.ELEMENT_NODE) { // Si Noeud du type Element
// Noeud trainee
trainee = (Element) trainees.item(i);
System.out.println("\nsexe : " + trainee.getAttribute("sexe"));
// Noeud lastname
lastname = (Element) trainee.getElementsByTagName("lastname").item(0);
System.out.println("lastname : " + lastname.getTextContent());
// Noeud firstname
firstname = (Element) trainee.getElementsByTagName("firstname").item(0);
System.out.println("firstname : " + firstname.getTextContent());
// Noeud email
email = (Element) trainee.getElementsByTagName("email").item(0);
System.out.println("email : " + email.getTextContent());

// Noeud Hobbies
NodeList hobbiesNodes = null;
hobbiesNodes = trainee.getElementsByTagName("hobbies"); 
for (int j=0; j<hobbiesNodes.getLength(); j++) {

hobbies = (Element) hobbiesNodes.item(j);
System.out.println("hobbies : " + "\n{");

// Noeud Hobby
NodeList hobbyNodes = null;
hobbyNodes = hobbies.getElementsByTagName("hobby");
for (int k = 0; k < hobbyNodes.getLength(); k++) {
hobby = (Element) hobbyNodes.item(k);

if (hobby.getAttribute("category").equals("cinema")) { // cinema
title = (Element) hobby.getElementsByTagName("title").item(0);
director = (Element) hobby.getElementsByTagName("director").item(0);
System.out.println(" cinema : " + title.getTextContent() + "
```
<Overlap Ratio: 0.9790528233151184>

---

--- 234 --
Question ID: 067a1f566ea53e71034717887a5dd1a38c3c2170
Original Code:
```
public class MapReference<E> implements Reference<E> {
    private final String name;
    private final Class<E> eClass;
    private final MapView<String, E> underlyingMap;
    @NotNull
    private final Asset asset;

    public MapReference(@NotNull RequestContext context, @NotNull Asset asset, MapView<String, E> underlying) throws AssetNotFoundException {
        this(context.name(), context.type(), asset, underlying);
    }

    public MapReference(String name, Class<E> type, @NotNull Asset asset, MapView<String, E> mapView) {
        assert asset != null;
        this.name = name;
        this.eClass = type;
        this.asset = asset;
        this.underlyingMap = mapView;
        assert underlyingMap != null;
    }

    @Override
    public long set(E event) {
        underlyingMap.set(name, event);
        return 0;
    }

    @Nullable
    @Override
    public E get() {
        return underlyingMap.get(name);
    }

    @Override
    public void remove() {
        underlyingMap.remove(name);
    }

    @Override
    public void registerSubscriber(boolean bootstrap, int throttlePeriodMs, @NotNull Subscriber<E> subscriber) throws AssetNotFoundException {

        asset.subscription(true)
                .registerSubscriber(requestContext()
                                .bootstrap(bootstrap)
                                .throttlePeriodMs(throttlePeriodMs)
                                .type(eClass),
                        subscriber, Filter.empty());
    }

    @Override
    public void unregisterSubscriber(@NotNull Subscriber subscriber) {
        @Nullable SubscriptionCollection subscription = asset.subscription(false);
        if (subscription != null)
            subscription.unregisterSubscriber(subscriber);
    }

    @Override
    public int subscriberCount() {
        @Nullable SubscriptionCollection subscription = asset.subscription(false);
        if (subscription != null)
            return subscription.subscriberCount();
        return 0;
    }

    @Override
    public Class getType() {
        return eClass;
    }

    @NotNull
    @Override
    public String toString() {
        return "MapReference{" +
                "name='" + name + '\'' +
                ", eClass=" + eClass +
                '}';
    }
}
```


Overlapping Code:
```
 Reference<E> {
private final String name;
private final Class<E> eClass;
private final MapView<String, E> underlyingMap;
@NotNull
private final Asset asset;
public MapReference(@NotNull RequestContext context, @NotNull Asset asset, MapView<String, E> underlying) throws AssetNotFoundException {
this(context.name(), context.type(), asset, underlying);
}
public MapReference(String name, Class<E> type, @NotNull Asset asset, MapView<String, E> mapView) {
assert asset != null;
this.name = name;
this.eClass = type;
this.asset = asset;
this.underlyingMap = mapView;
assert underlyingMap != null;
}
@Override
public long set(E event) {
underlyingMap.set(name, event);
return 0;
}
@Nullable
@Override
public E get() {
return underlyingMap.get(name);
}
@Override
public void remove() {
underlyingMap.remove(name);
}
@Override
public void registerSubscriber(boolean bootstrap, int throttlePeriodMs, @NotNull Subscriber<E> subscriber) throws AssetNotFoundException {
asset.subscription(true)
.registerSubscriber(requestContext()
.bootstrap(bootstrap)
.throttlePeriodMs(throttlePeriodMs)
.type(eClass),
subscriber, Filter.empty());
}
@Override
public void unregisterSubscriber(@NotNull Subscriber subscriber) {
@Nullable SubscriptionCollection subscription = asset.subscription(false);
if (subscription != null)
subscription.unregisterSubscriber(subscriber);
}
@Override
public int subscriberCount() {
@Nullable SubscriptionCollection subscription = asset.subscription(false);
if (subscription != null)
return subscription.subscriberCount();
return 0;
}
@Override
public Class getType() {
return eClass;
}
@NotNull
@Override
public String toString() {
return "MapReference{" +
"name='" + name + '\'' +
", eC
```
<Overlap Ratio: 0.9631728045325779>

---

--- 235 --
Question ID: 3517d91799527d2b981a09edb8bbf4c9059c7e6f
Original Code:
```
public class HCF_const_call
{
  public static void main(String args[]) throws IOException
  {
      DataInputStream in=new DataInputStream(System.in);
      System.out.println("enetr 1st no.");
      int n1=Integer.parseInt(in.readLine());
      System.out.println("enetr 2nd no.");
      int n2=Integer.parseInt(in.readLine());
      HCF_const h=new HCF_const(n1,n2);
      int r=h.cal();
      System.out.println("HCF = "+r);
    }
}
```


Overlapping Code:
```
l
{
public static void main(String args[]) throws IOException
{
DataInputStream in=new DataInputStream(System.in);
System.out.println("enetr 1st no.");
int n1=Integer.parseInt(in.readLine());
System.out.println("enetr 2nd no.");
int n2=Integer.parseInt(in.readLine());
HCF_const h=new HCF_const(n1,n2);
int r=h
```
<Overlap Ratio: 0.8179419525065963>

---

--- 236 --
Question ID: 92d959a555c7bbbe1512cc1e8965d9e2c494c71e
Original Code:
```
@Autonomous(name="[TEST] Mineral Sampling Test", group = "Tests")
public class MineralSamplingTest extends LinearOpMode
{
    Robot robot;
    Auto auto;

    @Override
    public void runOpMode() throws InterruptedException
    {
        // Initialize objects
        robot = new Robot(hardwareMap);
        auto = new Auto(this, robot);

        GoldDetector.Position goldPos = GoldDetector.Position.NONE;

        auto.initSampling();

        waitForStart();
        if(goldPos == GoldDetector.Position.NONE) {
            goldPos = auto.attemptSampleMinerals(1000);
        }

        auto.rotate(160, 0.3);

        telemetry.addData("Gold Mineral Position", goldPos.toString());
        telemetry.update();

        switch (goldPos){
            case LEFT:
                auto.rotate(21, 0.3);
                break;
            case RIGHT:
                auto.rotate(-21, 0.3);
                break;
        }

        while (opModeIsActive());
    }


}
```


Overlapping Code:
```
Sampling Test", group = "Tests")
public class MineralSamplingTest extends LinearOpMode
{
Robot robot;
Auto auto;
@Override
public void runOpMode() throws InterruptedException
{
// Initialize objects
robot = new Robot(hardwareMap);
auto = new Auto(this, robot);
GoldDetector.Position goldPos = GoldDetector.Position.NONE;
auto.initSampling();
waitForStart();
if(goldPos == GoldDetector.Position.NONE) {
goldPos = auto.attemptSampleMinerals(1000);
}
auto.rotate(160, 0.3);
telemetry.addData("Gold Mineral Position", goldPos.toString());
telemetry.update();
switch (goldPos){
case LEFT:
auto.rotate(21, 0.3);
break;
case RIGHT:
auto.rotate(-21, 0.3);
br
```
<Overlap Ratio: 0.9040333796940194>

---

--- 237 --
Question ID: 53fda02fabe1b6c43a6b6582833db1aec541d79f
Original Code:
```
public class LastIndexOf extends AbstractNativeFunction {

    public LastIndexOf(GlobalObject globalObject) {
        super(globalObject, "searchElement");
    }

    @Override
    public Object call(ExecutionContext context, Object self, Object... args) {
        // 15.4.4.14
        JSObject o = Types.toObject(context, self);
        long len = Types.toUint32(context, o.get(context, "length"));

        if (len == 0) {
            return -1L;
        }

        long n = len;
        if (args.length >= 2) {
            if (args[1] != Types.UNDEFINED) {
                n = Types.toInteger(context, args[1]);
            } else {
                n = (long)Double.NaN;  // http://es5.github.com/rev1/x15.4.4.15.html
            }
        }

        long k = Math.min(n, len-1);
        if (n < 0) {
            k = (len - Math.abs(n));
        }

        while ( k >= 0 ) {
            if (o.hasProperty(context, "" +k )) {
                Object element = o.get(context, ""+k);
                if ( Types.compareStrictEquality(context, args[0], element)) {
                    return k;
                }
            }
            --k;
        }
        
        return -1L;
    }
    
    @Override
    public void setFileName() {
        this.filename = "org/dynjs/runtime/builtins/types/array/prototype/LastIndexOf.java";
    }

    @Override
    public void setupDebugContext() {
        this.debugContext = "<native function: lastIndexOf>";
    }

}
```


Overlapping Code:
```
iveFunction {
public LastIndexOf(GlobalObject globalObject) {
super(globalObject, "searchElement");
}
@Override
public Object call(ExecutionContext context, Object self, Object... args) {
// 15.4.4.14
JSObject o = Types.toObject(context, self);
long len = Types.toUint32(context, o.get(context, "length"));
if (len == 0) {
return -1L;
}
long n = len;
if (args.length >= 2) {
if (args[1] != Types.UNDEFINED) {
n = Types.toInteger(context, args[1]);
} else {
n = (long)Double.NaN; // http://es5.github.com/rev1/x15.4.4.15.html
}
}
long k = Math.min(n, len-1);
if (n < 0) {
k = (len - Math.abs(n));
}
while ( k >= 0 ) {
if (o.hasProperty(context, "" +k )) {
Object element = o.get(context, ""+k);
if ( Types.compareStrictEquality(context, args[0], element)) {
return k;
}
}
--k;
}

return -1L;
}

@Override
public void setFileName() {
this.filename = "org/dynjs/runtime/builtins/types/array/prototype/LastIndexOf.java";
}
@Override
public void setupDebugContext() {
this.debugContext = "<native function: 
```
<Overlap Ratio: 0.9417293233082706>

---

--- 238 --
Question ID: 76d77960f74f16aa7557143e42bf18d5980d2fd6
Original Code:
```
public class ClassParsed {

	private Class<?> clz;
	private String simpleName;
	private String fullName;
	private String pkg;
	private String basePkg;
	
	private String mapping;
	private Set<String> importSet = new HashSet<>();
	private List<MethodParsed> methodList = new ArrayList<>();

	private Class actualType;
	
	public ClassParsed(){}
	public ClassParsed(Class<?> clz2) {
		this.clz = clz2;
		this.fullName = clz.getName();
		this.pkg = clz.getPackage().getName();
		this.simpleName = this.fullName.replace(this.pkg+".", "");
	}
	public Class<?> getClz() {
		return clz;
	}
	public void setClz(Class<?> clz) {
		this.clz = clz;
	}
	public String getSimpleName() {
		return simpleName;
	}
	public void setSimpleName(String simpleName) {
		this.simpleName = simpleName;
	}
	public String getFullName() {
		return fullName;
	}
	public void setFullName(String fullName) {
		this.fullName = fullName;
	}
	public String getMapping() {
		return mapping;
	}
	public void setMapping(String mapping) {
		this.mapping = mapping;
	}
	public String getPkg() {
		return pkg;
	}
	public void setPkg(String pkg) {
		this.pkg = pkg;
	}
	public Set<String> getImportSet() {
		return importSet;
	}

	public Class getActualType() {
		return actualType;
	}

	public void setActualType(Class actualType) {
		this.actualType = actualType;
	}

	public void setImportSet(Set<String> importSet) {
		this.importSet = importSet;
	}
	public List<MethodParsed> getMethodList() {
		return methodList;
	}
	public void setMethodList(List<MethodParsed> methodList) {
		this.methodList = methodList;
	}
	public String getBasePkg() {
		return basePkg;
	}
	public void setBasePkg(String basePkg) {
		this.basePkg = basePkg;
	}

	public void createMapping(String pkg,String clzSuffix, String simpleName){
		String clzMapping = simpleName.replace(clzSuffix, "");
		clzMapping = BeanUtil.getByFirstLower(clzMapping);
		String find = "";
		if (clzMapping.contains("$")){
			find = clzMapping.substring(clzMapping.lastIndexOf("$"));
			clzMapping = clzMapping.replace(find,"");
			find = "/" + find;
		}

		pkg = pkg.replace(basePkg, "");

		String mapping = pkg;
		if (! pkg.endsWith("."+clzMapping)){
			mapping = pkg + "." + clzMapping;
		}
		mapping += find;

		mapping = mapping.replace(".", "/");
		setMapping(mapping);
	}

	@Override
	public String toString() {
		return "ClassParsed [clz=" + clz + ", simpleName=" + simpleName + ", fullName=" + fullName + ", pkg=" + pkg
				+ ", basePkg=" + basePkg + ", mapping=" + mapping + ", importSet=" + importSet + ", methodList="
				+ methodList + "]";
	}

}
```


Overlapping Code:
```
?> clz;
private String simpleName;
private String fullName;
private String pkg;
private String basePkg;

private String mapping;
private Set<String> importSet = new HashSet<>();
private List<MethodParsed> methodList = new ArrayList<>();
private Class actualType;

public ClassParsed(){}
public ClassParsed(Class<?> clz2) {
this.clz = clz2;
this.fullName = clz.getName();
this.pkg = clz.getPackage().getName();
this.simpleName = this.fullName.replace(this.pkg+".", "");
}
public Class<?> getClz() {
return clz;
}
public void setClz(Class<?> clz) {
this.clz = clz;
}
public String getSimpleName() {
return simpleName;
}
public void setSimpleName(String simpleName) {
this.simpleName = simpleName;
}
public String getFullName() {
return fullName;
}
public void setFullName(String fullName) {
this.fullName = fullName;
}
public String getMapping() {
return mapping;
}
public void setMapping(String mapping) {
this.mapping = mapping;
}
public String getPkg() {
return pkg;
}
public void setPkg(String pkg) {
this.pkg = pkg;
}
public Set<String> getImportSet() {
return importSet;
}
public Class getActualType() {
return actualType;
}
public void setActualType(Class actualType) {
this.actualType = actualType;
}
public void setImportSet(Set<String> importSet) {
this.importSet = importSet;
}
public List<MethodParsed> getMethodList() {
return methodList;
}
public void setMethodList(List<MethodParsed> methodList) {
this.methodList = methodList;
}
public String getBasePkg() {
return basePkg;
}
public void setBasePkg(String basePkg) {
this.basePkg = basePkg;
}
public void createMapping(String pkg,String clzSuffix, String simpleName){
String clzMapping = simpleName.replace(clzSuffix, "");
clzMapping = BeanUtil.getByFirstLower(clzMapping);
String find = "";
if (clzMapping.contains("$")){
find = clzMapping.substring(clzMapping.lastIndexOf("$"));
clzMapping = clzMapping.replace(find,"");
find = "/" + find;
}
pkg = pkg.replace(basePkg, "");
String mapping = pkg;
if (! pkg.endsWith("."+clzMapping)){
mapping = pkg + "." + clzMapping;
}
mapping += find;
mapping = mapping.replace(".", "/");
setMapping(mapping);
}
@Override
public String toString() {
return "ClassParsed [clz=" + clz + ", simpleName=" + simpleName + ", fullName=" + fullName + ", pkg=" + pkg
+ ", basePkg=" + basePkg + ", mapping=" + m
```
<Overlap Ratio: 0.9791400595998297>

---

--- 239 --
Question ID: a569ae9bd4b420cb3e1426ae758ee98b3e14fbfb
Original Code:
```
public class TestSlice extends StreamingProgramTestBase {

	private String resultPath;
	private String expectedResult;

	@Rule
	public TemporaryFolder tempFolder = new TemporaryFolder();

	@Override
	protected void preSubmit() throws Exception {
		resultPath = tempFolder.newFile().toURI().toString();
	}

	@Override
	protected void postSubmit() throws Exception {
		compareResultsByLinesInMemory(expectedResult, resultPath);
	}

	@Override
	public void testProgram() throws Exception {
		testFoldNeighborsDefault();
		testFoldNeighborsIn();
		testFoldNeighborsAll();
		testReduceOnNeighborsDefault();
		testReduceOnNeighborsIn();
		testReduceOnNeighborsAll();
		testApplyOnNeighborsDefault();
		testApplyOnNeighborsIn();
		testApplyOnNeighborsAll();
	}

	public void testFoldNeighborsDefault() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))
			.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,25\n" +
				"2,23\n" +
				"3,69\n" +
				"4,45\n" +
				"5,51\n";
	}

	public void testFoldNeighborsIn() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)
			.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,51\n" +
				"2,12\n" +
				"3,36\n" +
				"4,34\n" +
				"5,80\n";
	}

	public void testFoldNeighborsAll() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)
			.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,76\n" +
				"2,35\n" +
				"3,105\n" +
				"4,79\n" +
				"5,131\n";
	}

	public void testReduceOnNeighborsDefault() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))
			.reduceOnEdges(new SumEdgeValuesReduce());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,25\n" +
				"2,23\n" +
				"3,69\n" +
				"4,45\n" +
				"5,51\n";
	}

	public void testReduceOnNeighborsIn() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)
				.reduceOnEdges(new SumEdgeValuesReduce());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,51\n" +
				"2,12\n" +
				"3,36\n" +
				"4,34\n" +
				"5,80\n";
	}

	public void testReduceOnNeighborsAll() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)
				.reduceOnEdges(new SumEdgeValuesReduce());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,76\n" +
				"2,35\n" +
				"3,105\n" +
				"4,79\n" +
				"5,131\n";
	}

	public void testApplyOnNeighborsDefault() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))
				.applyOnNeighbors(new SumEdgeValuesApply());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,small\n" +
				"2,small\n" +
				"3,big\n" +
				"4,small\n" +
				"5,big\n";
	}

	public void testApplyOnNeighborsIn() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)
				.applyOnNeighbors(new SumEdgeValuesApply());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,big\n" +
				"2,small\n" +
				"3,small\n" +
				"4,small\n" +
				"5,big\n";
	}

	public void testApplyOnNeighborsAll() throws Exception {

		final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

		SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);

		DataStream<Tuple2<Long, String>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)
				.applyOnNeighbors(new SumEdgeValuesApply());

		sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
		env.execute();
		expectedResult = "1,big\n" +
				"2,small\n" +
				"3,big\n" +
				"4,big\n" +
				"5,big\n";
	}

	@SuppressWarnings("serial")
	private static final class SumEdgeValues implements EdgesFold<Long, Long, Tuple2<Long, Long>> {

		public Tuple2<Long, Long> foldEdges(Tuple2<Long, Long> accum, Long id, Long neighborID, Long edgeValue) {
			accum.setField(id, 0);
			accum.setField(accum.f1 + edgeValue, 1);
			return accum;
		}
	}

	@SuppressWarnings("serial")
	private static final class SumEdgeValuesReduce implements EdgesReduce<Long> {

		@Override
		public Long reduceEdges(Long firstEdgeValue, Long secondEdgeValue) {
			return firstEdgeValue + secondEdgeValue;
		}
	}

	@SuppressWarnings("serial")
	private static final class SumEdgeValuesApply implements EdgesApply<Long, Long, Tuple2<Long, String>> {

		@Override
		public void applyOnEdges(Long vertexID,
				Iterable<Tuple2<Long, Long>> neighbors, Collector<Tuple2<Long, String>> out) {
			long sum = 0;
			for (Tuple2<Long, Long> n: neighbors) {
				sum += n.f1;
			}
			if (sum > 50) {
				out.collect(new Tuple2<Long, String>(vertexID, "big"));
			}
			else {
				out.collect(new Tuple2<Long, String>(vertexID, "small"));
			}
		}
	}
}
```


Overlapping Code:
```
extends StreamingProgramTestBase {
private String resultPath;
private String expectedResult;
@Rule
public TemporaryFolder tempFolder = new TemporaryFolder();
@Override
protected void preSubmit() throws Exception {
resultPath = tempFolder.newFile().toURI().toString();
}
@Override
protected void postSubmit() throws Exception {
compareResultsByLinesInMemory(expectedResult, resultPath);
}
@Override
public void testProgram() throws Exception {
testFoldNeighborsDefault();
testFoldNeighborsIn();
testFoldNeighborsAll();
testReduceOnNeighborsDefault();
testReduceOnNeighborsIn();
testReduceOnNeighborsAll();
testApplyOnNeighborsDefault();
testApplyOnNeighborsIn();
testApplyOnNeighborsAll();
}
public void testFoldNeighborsDefault() throws Exception {
final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);
DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS))
.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());
sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
env.execute();
expectedResult = "1,25\n" +
"2,23\n" +
"3,69\n" +
"4,45\n" +
"5,51\n";
}
public void testFoldNeighborsIn() throws Exception {
final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);
DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.IN)
.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeValues());
sum.writeAsCsv(resultPath, FileSystem.WriteMode.OVERWRITE);
env.execute();
expectedResult = "1,51\n" +
"2,12\n" +
"3,36\n" +
"4,34\n" +
"5,80\n";
}
public void testFoldNeighborsAll() throws Exception {
final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
SimpleEdgeStream<Long, Long> graph = new SimpleEdgeStream<>(GraphStreamTestUtils.getLongLongEdgeDataStream(env), env);
DataStream<Tuple2<Long, Long>> sum = graph.slice(Time.of(1, TimeUnit.SECONDS), EdgeDirection.ALL)
.foldNeighbors(new Tuple2<Long, Long>(0l, 0l), new SumEdgeVa
```
<Overlap Ratio: 0.9864687909209952>

---

--- 240 --
Question ID: 91e55880c96dc3cea3c58991d6f11f788d57f87c
Original Code:
```
public class ElementPanel extends JPanel implements IElementUpdater
{
	private static final long serialVersionUID = 2345409972608231073L;

	protected ElementManager manager;

	protected SizePanel panelSize;
	protected PositionPanel panelPosition;

    public ElementPanel(ElementManager manager)
    {
        this.manager = manager;
        setBackground(ModelCreator.BACKGROUND);
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        initComponents();
        addComponents();
    }

    protected void initComponents()
    {
        panelSize = new SizePanel(manager);
        panelPosition = new PositionPanel(manager);
    }

    protected void addComponents()
    {
        add(Box.createRigidArea(new Dimension(188, 5)));
        add(panelSize);
        add(Box.createRigidArea(new Dimension(188, 5)));
        add(panelPosition);
    }

    @Override
    public void updateValues(Element cube)
    {
        panelSize.updateValues(cube);
        panelPosition.updateValues(cube);
    }
}
```


Overlapping Code:
```
ic class ElementPanel extends JPanel implements IElementUpdater
{
private static final long serialVersionUID = 2345409972608231073L;
protected ElementManager manager;
protected SizePanel panelSize;
protected PositionPanel panelPosition;
public ElementPanel(ElementManager manager)
{
this.manager = manager;
setBackground(ModelCreator.BACKGROUND);
setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
initComponents();
addComponents();
}
protected void initComponents()
{
panelSize = new SizePanel(manager);
panelPosition = new PositionPanel(manager);
}
protected void addComponents()
{
add(Box.createRigidArea(new Dimension(188, 5)));
add(panelSize);
add(Box.createRigidArea(new Dimension(188, 5)));
add(panelPosition);
}
@Override
public void updateValues(Element cube)
{
panelSize.updateValues(cube);
panelPosition.updateVa
```
<Overlap Ratio: 0.9774078478002378>

---

--- 241 --
Question ID: b08534df7d002be8cc031157b9836464527f4da6
Original Code:
```
public class ContextHelper {
    public static String getUserAgent(ContainerRequestContext request) {
  	return request.getHeaderString("user-agent");
      }

      public static String getRemoteAdress(ContainerRequestContext request) {
  	String forwarded = request.getHeaderString("x-forwarded-for");
  	String remoteIP;
  	if (forwarded != null) {
  	    int i = forwarded.indexOf(",");
  	    if (i > -1) {
  		remoteIP = forwarded.substring(0, i);
  	    } else {
  		remoteIP = forwarded;
  	    }
  	} else {
  	    Object p = request.getProperty(IPFilter.REMOTE_IP);
  	    if (p != null) {
  		remoteIP = p.toString();
  	    } else {
  		remoteIP = "0.0.0.0";
  	    }
  	}
  	return remoteIP;
      }
}
```


Overlapping Code:
```
class ContextHelper {
public static String getUserAgent(ContainerRequestContext request) {
return request.getHeaderString("user-agent");
}
public static String getRemoteAdress(ContainerRequestContext request) {
String forwarded = request.getHeaderString("x-forwarded-for");
String remoteIP;
if (forwarded != null) {
int i = forwarded.indexOf(",");
if (i > -1) {
remoteIP = forwarded.substring(0, i);
} else {
remoteIP = forwarded;
}
} else {
Object p = request.getProperty(IPFilter.REMOTE_IP);
if (p != null) {
remoteIP = p.toString();
} else {
remot
```
<Overlap Ratio: 0.919732441471572>

---

--- 242 --
Question ID: 6604793eed37901b5888d3a2f11c282c414079e8
Original Code:
```
class FinnDateConverter {

    private static final String FINN_DATE_PATTERN = "yyyy-MM-dd'T'HH:mm:ss[.SSS]Z";


    public static LocalDateTime convertDate(String date) {
        if (StringUtils.isBlank(date)) {
            return null;
        }

        date = date.replace("Z", "+0000");
        return LocalDateTime.parse(date, DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));
    }

    public static String toString(LocalDateTime date) {

        String dateValue = date.atZone(ZoneId.of("Z"))
                .format(DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));
        return dateValue.replace("+0000", "Z");
    }
}
```


Overlapping Code:
```
 String FINN_DATE_PATTERN = "yyyy-MM-dd'T'HH:mm:ss[.SSS]Z";
public static LocalDateTime convertDate(String date) {
if (StringUtils.isBlank(date)) {
return null;
}
date = date.replace("Z", "+0000");
return LocalDateTime.parse(date, DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));
}
public static String toString(LocalDateTime date) {
String dateValue = date.atZone(ZoneId.of("Z"))
.format(DateTimeFormatter.ofPattern(FINN_DATE_PATTERN));
return dateV
```
<Overlap Ratio: 0.8538899430740038>

---

--- 243 --
Question ID: 0fab1bbcb68a1dd0ef168d85911a929ed62962c1
Original Code:
```
class Outperformance extends CombinationStrategy {
    /**
     * Map stores the number of times each forecastMethod had the overall lowest forecast error in the last runs timesteps.
     */
    @NotNull
    private final Map<AbstractForecastMethod, Integer> outperformanceWeights;
    /**
     * Maximum number of the last stored winner counts.
     */
    private final int runs = 10;
    /**
     * Moving window of the last runs best AbstractForecastMethods.
     */
    private final List<AbstractForecastMethod> forecastWinners = new ArrayList<>(runs);
    private double bestWeight = Double.MAX_VALUE;
    @Nullable
    private AbstractForecastMethod bestForecastMethod;

    Outperformance() {
        this.outperformanceWeights = new HashMap<>();
    }

    void addForecastMethod(final AbstractForecastMethod forecastMethod) {
        this.outperformanceWeights.put(forecastMethod, 0);
    }

    public double run() {
        List<Double> weights = getWeights();
        if (weights.isEmpty()) {
            return Double.NaN;
        }

        removeInvalidEntries(forecasts, weights);
        if (weights.isEmpty()) {
            return Double.NaN;
        }

        return simpleWeightedSum(forecasts, weights);
    }

    @NotNull
    private List<Double> getWeights() {
        if (this.bestForecastMethod == null) {
            return Collections.emptyList();
        }

        updateOutperformanceMap(this.bestForecastMethod);
        if (this.forecastWinners.size() < this.runs) {
            return Collections.emptyList();
        }

        return calculateOutperformanceWeights();
    }

    @NotNull
    private List<Double> calculateOutperformanceWeights() {
        List<Double> weights = new ArrayList<>(this.outperformanceWeights.size());
        for (double count : this.outperformanceWeights.values()) {
            weights.add((1 + count) / (this.outperformanceWeights.size() + this.runs));
        }

        logWeights(weights);

        return weights;
    }

    private void updateOutperformanceMap(AbstractForecastMethod forecastMethod) {
        this.outperformanceWeights.computeIfPresent(forecastMethod, (p, count) -> count + 1);
        this.forecastWinners.add(forecastMethod);

        while (this.forecastWinners.size() > runs) {
            AbstractForecastMethod oldest = this.forecastWinners.remove(0);
            this.outperformanceWeights.computeIfPresent(oldest, (p, count) -> count - 1);
        }
    }

    void reset() {
        this.bestForecastMethod = null;
        this.bestWeight = Double.MAX_VALUE;
    }

    void update(double weight, AbstractForecastMethod forecastMethod) {
        if (weight < this.bestWeight) {
            this.bestForecastMethod = forecastMethod;
            this.bestWeight = weight;
        }
    }
}
```


Overlapping Code:
```
mbinationStrategy {
/**
* Map stores the number of times each forecastMethod had the overall lowest forecast error in the last runs timesteps.
*/
@NotNull
private final Map<AbstractForecastMethod, Integer> outperformanceWeights;
/**
* Maximum number of the last stored winner counts.
*/
private final int runs = 10;
/**
* Moving window of the last runs best AbstractForecastMethods.
*/
private final List<AbstractForecastMethod> forecastWinners = new ArrayList<>(runs);
private double bestWeight = Double.MAX_VALUE;
@Nullable
private AbstractForecastMethod bestForecastMethod;
Outperformance() {
this.outperformanceWeights = new HashMap<>();
}
void addForecastMethod(final AbstractForecastMethod forecastMethod) {
this.outperformanceWeights.put(forecastMethod, 0);
}
public double run() {
List<Double> weights = getWeights();
if (weights.isEmpty()) {
return Double.NaN;
}
removeInvalidEntries(forecasts, weights);
if (weights.isEmpty()) {
return Double.NaN;
}
return simpleWeightedSum(forecasts, weights);
}
@NotNull
private List<Double> getWeights() {
if (this.bestForecastMethod == null) {
return Collections.emptyList();
}
updateOutperformanceMap(this.bestForecastMethod);
if (this.forecastWinners.size() < this.runs) {
return Collections.emptyList();
}
return calculateOutperformanceWeights();
}
@NotNull
private List<Double> calculateOutperformanceWeights() {
List<Double> weights = new ArrayList<>(this.outperformanceWeights.size());
for (double count : this.outperformanceWeights.values()) {
weights.add((1 + count) / (this.outperformanceWeights.size() + this.runs));
}
logWeights(weights);
return weights;
}
private void updateOutperformanceMap(AbstractForecastMethod forecastMethod) {
this.outperformanceWeights.computeIfPresent(forecastMethod, (p, count) -> count + 1);
this.forecastWinners.add(forecastMethod);
while (this.forecastWinners.size() > runs) {
AbstractForecastMethod oldest = this.forecastWinners.remove(0);
this.outperformanceWeights.computeIfPresent(oldest, (p, count) -> cou
```
<Overlap Ratio: 0.9657170449058425>

---

--- 244 --
Question ID: 0778168cf8ee1719cfd0e54a0c7d8fa22860b38a
Original Code:
```
@ConfigurationProperties(prefix = "fullstop.processor")
public class CloudTrailProcessingLibraryProperties {

    private Map<String, String> properties = new HashMap<String, String>();

    public Map<String, String> getProperties() {
        return properties;
    }

    public void setProperties(final Map<String, String> properties) {
        this.properties = properties;
    }

    public Properties getAsProperties() {
        final Properties properties = new Properties();
        properties.putAll(getProperties());
        return properties;
    }

}
```


Overlapping Code:
```
operties(prefix = "fullstop.processor")
public class CloudTrailProcessingLibraryProperties {
private Map<String, String> properties = new HashMap<String, String>();
public Map<String, String> getProperties() {
return properties;
}
public void setProperties(final Map<String, String> properties) {
this.properties = properties;
}
public Properties getAsProperties() {
final Properties properties = new Properties();
properties.putAll(getProperties());
```
<Overlap Ratio: 0.9202453987730062>

---

--- 245 --
Question ID: c2b1d3ff934e9d8ea779da8367572ce7735c4fc1
Original Code:
```
public class TextFileDataWriter extends DataWriter {
	protected BufferedWriter dataWriter;
	private String intendedFileName;
	private boolean storeData;

	/**
	 * Create a data writer which collects data and immediately writes them to
	 * the given data file.
	 * 
	 * @param fn
	 *            name of the data file.
	 */
	public TextFileDataWriter(String fn) {
		super();
		dataFileName = null;
		intendedFileName = fn;
		dataWriter = null;
		storeData = true;
		logSession("Start");
	}

	private void openDataWriter() {
		Debug.show(Debug.FILES, "TextFileDataWriter(): Open file "
				+ intendedFileName);
		try {
			dataWriter = new BufferedWriter(new FileWriter(intendedFileName));
			dataFileName = intendedFileName;
			if (!StringExt.nonEmpty(ExPar.DataFileName.getString())) {
				ExPar.DataFileName.set(dataFileName);
			}
		} catch (IOException iox) {
			new FileError("Can't open data file " + intendedFileName
					+ "\nData are not stored!");
			storeData = false;
		}
	}

	protected void logSession(String prefix) {
		ExPar.setDate();
		String fs = ExPar.SessionDescriptorFormat.getString();
		if (StringExt.nonEmpty(fs)) {
			try {
				File df = new File(intendedFileName);
				File sf = new File(df.getParent(), "experiment.log");
				BufferedWriter wr = new BufferedWriter(new FileWriter(
						sf.getPath(), true));
				String nl = System.getProperty("line.separator");
				wr.write(prefix + " " + fs + nl);
				wr.close();
			} catch (IOException iex) {
				new FileError(
						"Error while trying to write experiment log file!");
			}
		}
	}

	/**
	 * Deliver a data string to this DataWriter.
	 * 
	 * @param data
	 *            the data string to be written.
	 */
	public void store(ExDesignNode data) {
		// System.out.println("TextFileDataWriter.store() " + data);
		String dt = dataStringOf(data);
		if (dt != null) {
			if (storeData && (dataWriter == null))
				openDataWriter();
			if (storeData) {
				try {
					String nl = System.getProperty("line.separator");
					dataWriter.write(dt + nl);
					dataWriter.flush();
				} catch (IOException ioex) {
					new FileError("Errow while trying to write data string <"
							+ dt + "> to destination " + dataFileName);
				}
			}
		}
	}

	/**
	 * Signal this DataWriter object that data collection is complete.
	 * 
	 * @param status
	 *            the final status of the data source.
	 */
	public void dataComplete(int status) {
		if (storeData && (dataWriter != null)) {
			try {
				dataWriter.close();
				Debug.show(Debug.FILES,
						"TextFileDataWriter.dataComplete(): Closed file "
								+ dataFileName);
			} catch (IOException ioex) {
				new FileError(
						"Errow while trying to close the data destination "
								+ dataFileName);
			}
		}
		logSession("End");
	}
}
```


Overlapping Code:
```
 TextFileDataWriter extends DataWriter {
protected BufferedWriter dataWriter;
private String intendedFileName;
private boolean storeData;
/**
* Create a data writer which collects data and immediately writes them to
* the given data file.
* 
* @param fn
* name of the data file.
*/
public TextFileDataWriter(String fn) {
super();
dataFileName = null;
intendedFileName = fn;
dataWriter = null;
storeData = true;
logSession("Start");
}
private void openDataWriter() {
Debug.show(Debug.FILES, "TextFileDataWriter(): Open file "
+ intendedFileName);
try {
dataWriter = new BufferedWriter(new FileWriter(intendedFileName));
dataFileName = intendedFileName;
if (!StringExt.nonEmpty(ExPar.DataFileName.getString())) {
ExPar.DataFileName.set(dataFileName);
}
} catch (IOException iox) {
new FileError("Can't open data file " + intendedFileName
+ "\nData are not stored!");
storeData = false;
}
}
protected void logSession(String prefix) {
ExPar.setDate();
String fs = ExPar.SessionDescriptorFormat.getString();
if (StringExt.nonEmpty(fs)) {
try {
File df = new File(intendedFileName);
File sf = new File(df.getParent(), "experiment.log");
BufferedWriter wr = new BufferedWriter(new FileWriter(
sf.getPath(), true));
String nl = System.getProperty("line.separator");
wr.write(prefix + " " + fs + nl);
wr.close();
} catch (IOException iex) {
new FileError(
"Error while trying to write experiment log file!");
}
}
}
/**
* Deliver a data string to this DataWriter.
* 
* @param data
* the data string to be written.
*/
public void store(ExDesignNode data) {
// System.out.println("TextFileDataWriter.store() " + data);
String dt = dataStringOf(data);
if (dt != null) {
if (storeData && (dataWriter == null))
openDataWriter();
if (storeData) {
try {
String nl = System.getProperty("line.separator");
dataWriter.write(dt + nl);
dataWriter.flush();
} catch (IOException ioex) {
new FileError("Errow while trying to write data string <"
+ dt + "> to destination " + dataFileName);
}
}
}
}
/**
* Signal this DataWriter object that data collection is complete.
* 
* @param status
* the final status of the data source.
*/
public void dataComplete(int status) {
i
```
<Overlap Ratio: 0.9944341372912802>

---

--- 246 --
Question ID: 227473961d81c7fa871ac19f305a71b5be88c6bd
Original Code:
```
public class AndroidEnvironment {
    private final static String ANDWORX_HOME_PATH = "andworx";
	private static final String ANDWORX_HOME_ERROR = "Error creating Andworx home directory %s";
	private static final String REPOSITORY_FOLDER = "libraries";
	private static final String DEFAULT_ANDROID_HOME = System.getProperty("user.dir") + File.separator + AndroidLocation.FOLDER_DOT_ANDROID;

	private static class FailedTargetLoadStatus implements TargetLoadStatusMonitor {

		@Override
		public LoadStatus getLoadStatus(String hashString) {
			return LoadStatus.FAILED;
		}
		
	}
	
	/** Location of the expanded AARs stored in a Maven repository structure */ 
	protected File repositoryLocation;
	/** Android's own home location */
	protected File androidHome;
	private final ILogger logger;
	protected TargetLoadStatusMonitor targetLoadStatusMonitor;

	public AndroidEnvironment(ILogger logger) {
		this.logger = logger;
		targetLoadStatusMonitor = new FailedTargetLoadStatus();
	}
	
	/**
	 * Returns flag set true if Android SDK is available
	 * @return boolean
	 */
	public boolean isValid() {
		return false;
	}

	/**
	 * Returns the available Android targets (both Platform and Add-ons
	 * @return Android target collection
	 */
	public Collection<IAndroidTarget> getAndroidTargets() { 
		return Collections.emptyList();
    }

	/**
	 * Returns the location of the libraries repository within Android home
	 * @return File object
	 */
	public File getRepositoryLocation() {
		if (repositoryLocation == null)
			repositoryLocation = new File(getAndworxHome(), REPOSITORY_FOLDER);
		return repositoryLocation;
	}

	/**
	 * Returns Android SDK interface to {@link RepoManager}
	 * @return AndroidSdkHandler object or null if not available
	 */
	@Nullable
	public  AndroidSdkHandler getAndroidSdkHandler() {
		return null;
	}
	
	/**
	 * Returns closest match Target Platform to given version
	 * @param targetHash Target platform version specified as a hash string
	 * @return IAndroidTarget object or null if none available
	 */
	@Nullable
	public IAndroidTarget getAvailableTarget(String targetHash) {
		return null;
	}
	
	/**
	 * Returns Android's own home location. 
	 * @return File object
	 */
	public File getAndroidHome() {
		if (androidHome == null) {
			try {
        	/* getFolder()
		     * Returns the folder used to store android related files.
		     * If the folder is not created yet, it will be created.
		     * @return an OS specific path, terminated by a separator.
        	 */
			String androidHomeDir = AndroidLocation.getFolder();
            androidHome = new File(androidHomeDir);
            if (!androidHome.exists()) {
            	if (!androidHome.mkdirs())
            		throw new IOException(String.format("Cannot create path %s", androidHome.getAbsolutePath()));
            } else if (!androidHome.isDirectory())
        		throw new IOException(String.format("Path %s is not a directory", androidHome.getAbsolutePath()));
	        } catch (AndroidLocationException | IOException | SecurityException e) {
	        	logger.error(e, "Error finding Android home");
	        	// Apply default
	        	androidHome = new File(DEFAULT_ANDROID_HOME);
	        }
		}
		return androidHome;
	}

	/**
	 * Returns Andworx's own home location inside Android home
	 * @return File object
	 */
	public File getAndworxHome() {
    	File androidHomeDir = getAndroidHome();
        File andworxHomePath = new File(androidHomeDir, ANDWORX_HOME_PATH);
    	if (!andworxHomePath.exists()) {
    		try {
    			andworxHomePath.mkdirs();
    		} catch (SecurityException t) {
    			logger.error(t, ANDWORX_HOME_ERROR, andworxHomePath);
    		}
    	}
    	if (!andworxHomePath.exists()) 
    		throw new AndworxException(String.format(ANDWORX_HOME_ERROR, andworxHomePath));
    	return andworxHomePath;
    }
	
	/**
	 * Return Signing Configuration
	 * @return SigningConfig object
	 */
	public SigningConfig getDefaultDebugSigningConfig() {
		File keystoreFile = new File(getAndroidHome(), "debug.keystore");
		if (!keystoreFile.exists())
			try {
				KeystoreHelper.createDebugStore(
					null, 
					keystoreFile, 
					DefaultSigningConfig.DEFAULT_PASSWORD, 
					DefaultSigningConfig.DEFAULT_PASSWORD, 
					DefaultSigningConfig.DEFAULT_ALIAS, 
					logger);
			} catch (KeytoolException e) {
				throw new AndworxException("Error creating debug keystore " + keystoreFile.toString(), e);
			}
		return DefaultSigningConfig.debugSigningConfig(keystoreFile);
	}

	/**
	 * Returns monitor which always return FAILED load status. Replace targetLoadStatusMonitor to return actual status.
	 * @return TargetLoadStatusMonitor
	 */
	public TargetLoadStatusMonitor getTargetLoadStatusMonitor() {
		return targetLoadStatusMonitor;
	}
}
```


Overlapping Code:
```
 {
private final static String ANDWORX_HOME_PATH = "andworx";
private static final String ANDWORX_HOME_ERROR = "Error creating Andworx home directory %s";
private static final String REPOSITORY_FOLDER = "libraries";
private static final String DEFAULT_ANDROID_HOME = System.getProperty("user.dir") + File.separator + AndroidLocation.FOLDER_DOT_ANDROID;
private static class FailedTargetLoadStatus implements TargetLoadStatusMonitor {
@Override
public LoadStatus getLoadStatus(String hashString) {
return LoadStatus.FAILED;
}

}

/** Location of the expanded AARs stored in a Maven repository structure */ 
protected File repositoryLocation;
/** Android's own home location */
protected File androidHome;
private final ILogger logger;
protected TargetLoadStatusMonitor targetLoadStatusMonitor;
public AndroidEnvironment(ILogger logger) {
this.logger = logger;
targetLoadStatusMonitor = new FailedTargetLoadStatus();
}

/**
* Returns flag set true if Android SDK is available
* @return boolean
*/
public boolean isValid() {
return false;
}
/**
* Returns the available Android targets (both Platform and Add-ons
* @return Android target collection
*/
public Collection<IAndroidTarget> getAndroidTargets() { 
return Collections.emptyList();
}
/**
* Returns the location of the libraries repository within Android home
* @return File object
*/
public File getRepositoryLocation() {
if (repositoryLocation == null)
repositoryLocation = new File(getAndworxHome(), REPOSITORY_FOLDER);
return repositoryLocation;
}
/**
* Returns Android SDK interface to {@link RepoManager}
* @return AndroidSdkHandler object or null if not available
*/
@Nullable
public AndroidSdkHandler getAndroidSdkHandler() {
return null;
}

/**
* Returns closest match Target Platform to given version
* @param targetHash Target platform version specified as a hash string
* @return IAndroidTarget object or null if none available
*/
@Nullable
public IAndroidTarget getAvailableTarget(String targetHash) {
return null;
}

/**
* Returns Android's own home location. 
* @return File object
*/
public File getAndroidHome() {
if (androidHome == null) {
try {
/* getFolder()
* Returns the folder used to store android related files.
* If the folder is not created yet, it will be created.
* @return an OS specific path, terminated by a separa
```
<Overlap Ratio: 0.9850107066381156>

---

--- 247 --
Question ID: df1909ebee4db989d987fb9faad99ef2d958e871
Original Code:
```
public final class zzdbg extends zzfm implements zzdbf {
    zzdbg(IBinder iBinder) {
        super(iBinder, "com.google.android.gms.gass.internal.IGassService");
    }

    /* renamed from: a */
    public final zzdbd mo31367a(zzdbb zzdbb) throws RemoteException {
        Parcel a = mo31749a();
        zzfo.m30222a(a, (Parcelable) zzdbb);
        Parcel a2 = mo31750a(1, a);
        zzdbd zzdbd = (zzdbd) zzfo.m30220a(a2, zzdbd.CREATOR);
        a2.recycle();
        return zzdbd;
    }

    /* renamed from: a */
    public final void mo31368a(zzday zzday) throws RemoteException {
        Parcel a = mo31749a();
        zzfo.m30222a(a, (Parcelable) zzday);
        mo31752b(2, a);
    }
}
```


Overlapping Code:
```
 implements zzdbf {
zzdbg(IBinder iBinder) {
super(iBinder, "com.google.android.gms.gass.internal.IGassService");
}
/* renamed from: a */
public final zzdbd mo31367a(zzdbb zzdbb) throws RemoteException {
Parcel a = mo31749a();
zzfo.m30222a(a, (Parcelable) zzdbb);
Parcel a2 = mo31750a(1, a);
zzdbd zzdbd = (zzdbd) zzfo.m30220a(a2, zzdbd.CREATOR);
a2.recycle();
return zzdbd;
}
/* renamed from: a */
public final void mo31368a(zzday zzday) throws RemoteException {
Parcel a = mo31749a();
zzfo.m30222a(a, (Parcelabl
```
<Overlap Ratio: 0.8844827586206897>

---

--- 248 --
Question ID: a1da78f2a230ec67db194face8d2ebbbd4923a30
Original Code:
```
public class JassFunctions {

    private static final String TAG = "JassFunctions";

    //fill CardRecog with the names of all 36 cards
    public CardRecog[] fillCardNames(){
        CardRecog myCard;
        CardRecog[] myCards = new CardRecog[36];

        String cardType = "Rosen ";
        for(int i = 0; i < 36; i++){
            myCard = new CardRecog();
            myCards[i] = myCard;
            if(i == 9){
                cardType = "Eicheln ";
            }
            if(i == 18){
                cardType = "Schellen ";
            }
            if(i == 27){
                cardType = "Schilten ";
            }

            if(i % 9 < 5) {
                myCards[i].setCardTitle(cardType + ((i%9) + 6));
                myCards[i].setConfidence(0);
            }
            else if(i % 9 == 5){
                myCards[i].setCardTitle(cardType + "Under");
                myCards[i].setConfidence(0);
            }
            else if(i % 9 == 6){
                myCards[i].setCardTitle(cardType + "Ober");
                myCards[i].setConfidence(0);
            }
            else if(i % 9 == 7){
                myCards[i].setCardTitle(cardType + "König");
                myCards[i].setConfidence(0);
            }
            else if(i % 9 == 8){
                myCards[i].setCardTitle(cardType + "Ass");
                myCards[i].setConfidence(0);
            }
            Log.d(TAG, myCards[i].getCardTitle());
        }
//        Test data for model from example app

        myCards[27].setCardTitle("chair");
        myCards[28].setCardTitle("backpack");
        myCards[29].setCardTitle("book");
        myCards[30].setCardTitle("clock");
        myCards[31].setCardTitle("scissors");
        myCards[32].setCardTitle("mouse");
        myCards[33].setCardTitle("keyboard");
        myCards[34].setCardTitle("bed");
        myCards[35].setCardTitle("tv");

        return myCards;
    }

    //convert the Strings of the nine recognised cards into the norm card array (local point of view) used by the RNN
    public int[] getNormArray(String[] recCards){
        int[] normArray = new int[37];
        CardRecog[] cardsNamed = fillCardNames();

        //36 cards + trump
        for (int i = 0; i < 37; i++){
            normArray[i] = 0;
        }

        //convert recognised cards into norm array
        for (int a = 0; a < 9; a++){
            for (int b = 0; b < 36; b++){
                if(cardsNamed[b].getCardTitle().equals(recCards[a])){
                    normArray[b] = 1;
                    break;
                }
            }
        }
        return normArray;
    }


}
```


Overlapping Code:
```
class JassFunctions {
private static final String TAG = "JassFunctions";
//fill CardRecog with the names of all 36 cards
public CardRecog[] fillCardNames(){
CardRecog myCard;
CardRecog[] myCards = new CardRecog[36];
String cardType = "Rosen ";
for(int i = 0; i < 36; i++){
myCard = new CardRecog();
myCards[i] = myCard;
if(i == 9){
cardType = "Eicheln ";
}
if(i == 18){
cardType = "Schellen ";
}
if(i == 27){
cardType = "Schilten ";
}
if(i % 9 < 5) {
myCards[i].setCardTitle(cardType + ((i%9) + 6));
myCards[i].setConfidence(0);
}
else if(i % 9 == 5){
myCards[i].setCardTitle(cardType + "Under");
myCards[i].setConfidence(0);
}
else if(i % 9 == 6){
myCards[i].setCardTitle(cardType + "Ober");
myCards[i].setConfidence(0);
}
else if(i % 9 == 7){
myCards[i].setCardTitle(cardType + "König");
myCards[i].setConfidence(0);
}
else if(i % 9 == 8){
myCards[i].setCardTitle(cardType + "Ass");
myCards[i].setConfidence(0);
}
Log.d(TAG, myCards[i].getCardTitle());
}
// Test data for model from example app
myCards[27].setCardTitle("chair");
myCards[28].setCardTitle("backpack");
myCards[29].setCardTitle("book");
myCards[30].setCardTitle("clock");
myCards[31].setCardTitle("scissors");
myCards[32].setCardTitle("mouse");
myCards[33].setCardTitle("keyboard");
myCards[34].setCardTitle("bed");
myCards[35].setCardTitle("tv");
return myCards;
}
//convert the Strings of the nine recognised cards into the norm card array (local point of view) used by the RNN
public int[] getNormArray(String[] recCards){
int[] normArray = new int[37];
CardRecog[] cardsNamed = fillCardNames();
//36 cards + trump
for (int i = 0; i < 37; i++){
normArray[i] = 0;
}
//convert recognised cards into norm array
for (int a = 0; a < 9; a++){
for (int b = 0; b < 36; b++){
if(cardsNamed[
```
<Overlap Ratio: 0.9744017807456873>

---

--- 249 --
Question ID: c57faef56c1afc9fad41de4a68b771186bcdf42f
Original Code:
```
public class MarkDownPreviewActivity extends BackBaseActivity {

    private static final String EXTRA_MARKDOWN = "markdown";
    private MarkdownView markdownView;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_back_base);
        setCustomTitle("MarkDown预览");
        FrameLayout layout = (FrameLayout) findViewById(R.id.container);

        markdownView = new MarkdownView(this);
        layout.addView(markdownView);
//        markdownView.loadMarkdown();
        showWebContent(StringUtils.renderMarkdown(getIntent().getStringExtra(EXTRA_MARKDOWN)));
    }





    public static void open(Context context, String markdown) {
        Intent intent = new Intent(context, MarkDownPreviewActivity.class);
        intent.putExtra(EXTRA_MARKDOWN, markdown);
        context.startActivity(intent);
    }


    public void showWebContent(String htmlBody) {
        String prompt = "";
        AssetManager assetManager = getResources().getAssets();

        try {
            InputStream inputStream;

            if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(SettingsFragment.KEY_PREF_THEME, false)) {
                Log.e("theme", "is dark theme");
                inputStream = assetManager.open("dark_template.html");
            } else {
                Log.e("theme", "is light theme");
                inputStream = assetManager.open("h5_template.html");
            }

            byte[] b = new byte[inputStream.available()];
            inputStream.read(b);
            prompt = new String(b);
            prompt = prompt.concat(htmlBody.replace("<img src=\"/photo/",
                    "<img src=\"https://testerhome.com/photo/")).concat("</body></html>");
            inputStream.close();
        } catch (IOException e) {
            Log.e("", "Counldn't open updrage-alter.html", e);
        }

        markdownView.setBackgroundColor(0);
        markdownView.loadDataWithBaseURL(null, prompt, "text/html", "utf-8", null);

    }


    @Override
    protected void onDestroy() {
        super.onDestroy();
        markdownView.removeAllViews();
        markdownView.destroy();
    }
}
```


Overlapping Code:
```
rkDownPreviewActivity extends BackBaseActivity {
private static final String EXTRA_MARKDOWN = "markdown";
private MarkdownView markdownView;
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_back_base);
setCustomTitle("MarkDown预览");
FrameLayout layout = (FrameLayout) findViewById(R.id.container);
markdownView = new MarkdownView(this);
layout.addView(markdownView);
// markdownView.loadMarkdown();
showWebContent(StringUtils.renderMarkdown(getIntent().getStringExtra(EXTRA_MARKDOWN)));
}
public static void open(Context context, String markdown) {
Intent intent = new Intent(context, MarkDownPreviewActivity.class);
intent.putExtra(EXTRA_MARKDOWN, markdown);
context.startActivity(intent);
}
public void showWebContent(String htmlBody) {
String prompt = "";
AssetManager assetManager = getResources().getAssets();
try {
InputStream inputStream;
if (PreferenceManager.getDefaultSharedPreferences(this).getBoolean(SettingsFragment.KEY_PREF_THEME, false)) {
Log.e("theme", "is dark theme");
inputStream = assetManager.open("dark_template.html");
} else {
Log.e("theme", "is light theme");
inputStream = assetManager.open("h5_template.html");
}
byte[] b = new byte[inputStream.available()];
inputStream.read(b);
prompt = new String(b);
prompt = prompt.concat(htmlBody.replace("<img src=\"/photo/",
"<img src=\"https://testerhome.com/photo/")).concat("</body></html>");
inputStream.close();
} catch (IOException e) {
Log.e("", "Counldn't open updrage-alter.html", e);
}
markdownView.setBackgroundColor(0);
markdownView.loadDataWithBaseURL(null, prompt, "text/html", "utf-8", null);
}
@Override
protected void onDestroy() {
super.onDestroy();
markdownView.removeA
```
<Overlap Ratio: 0.9706045479755963>

---

--- 250 --
Question ID: c4384f0415035b18e6ac59d1df420fcfec693011
Original Code:
```
@Category(DefaultTest.class)
public class SocialUtilsTestCase extends TestCase{

    /**
     * Test Period Date.
     * @throws IOException
     * @throws HttpException
     * @throws EnmeFailOperation
     */
    @Test(timeout = 5000)
    public void testGetGoGlShortUrl() throws HttpException, IOException, EnmeFailOperation{
        //System.out.println(SocialUtils.getGoGl("http://blog.jotadeveloper.com",
         //                                       "AIzaSyCvEMnlGa4q4Suayx1bMYXg-Wkf1jYmmaQ"));
    }

    @Test(timeout = 5000)
    public void testgetTinyUrl() throws HttpException, IOException{
       // System.out.println(SocialUtils.getTinyUrl("http://blog.jotadeveloper.com"));
    }

    @Test(timeout = 5000)
    public void testgetGoogleStas() throws HttpException, IOException{
       // System.out.println(SocialUtils.getGoGlStats("http://blog.jotadeveloper.com"));
    }

    @Test(timeout = 5000)
    public void testgetBitLy() throws HttpException, IOException, EnmeFailOperation{
        //System.out.println(SocialUtils.getBitLy("http://blog.jotadeveloper.com",
         //       "R_5ea5369d4eee11edbd860ec8ef5dc7a0", "jotadeveloper"));
        //System.out.println(SocialUtils.getBitLy("http://www.encuestame.org",
         //       "R_5ea5369d4eee11edbd860ec8ef5dc7a0", "jotadeveloper"));
    }
}
```


Overlapping Code:
```
Test.class)
public class SocialUtilsTestCase extends TestCase{
/**
* Test Period Date.
* @throws IOException
* @throws HttpException
* @throws EnmeFailOperation
*/
@Test(timeout = 5000)
public void testGetGoGlShortUrl() throws HttpException, IOException, EnmeFailOperation{
//System.out.println(SocialUtils.getGoGl("http://blog.jotadeveloper.com",
//stgetTinyUrl() throws HttpException, IOException{
// System.out.println(SocialUtils.getTinyUrl("http://blog.jotadeveloper.com"));
}
@Test(timeout = 5000)
public void testgetGoogleStas() throws HttpException, IOException{
// System.out.println(SocialUtils.getGoGlStats("http://blog.jotadeveloper.com"));
}
@Test(timeout = 5000)
public void testgetBitLy() throws HttpException, IOException, EnmeFailOperation{
//System.out.println(SocialUtils.getBitLy("http://blog.jotadeveloper.com",
// "R_5ea5369d4eee11edbd860ec8ef5dc7a0", "jotadeveloper"));
//System.out.println(SocialUtils.getBitLy("http://www.encuestame.org",
// "R_5ea5369d4eee11edbd860ec8ef5dc7
```
<Overlap Ratio: 0.8865248226950354>

---

--- 251 --
Question ID: fb060ba4989ff3c8e426094e9cdcd89227db1c4b
Original Code:
```
public class SearchHelper {
  public void resize(int width, int height) {
    mHalfScreenWidth = width * 0.5f;
    mHalfScreenHeight = height * 0.5f;
  }
  
  public void setTarget(Vector3 target, String targetName) {
    mTargetName = targetName;
    mTarget = target.copy();
    mTransformedPosition = null;
    mLastUpdateTime = System.currentTimeMillis();
    mTransitionFactor = targetInFocusRadiusImpl() ? 1 : 0;
  }
  
  public void setTransform(Matrix4x4 transformMatrix) {
    mTransformMatrix = transformMatrix;
    mTransformedPosition = null;
  }
  
  public Vector3 getTransformedPosition() {
    if (mTransformedPosition == null && mTransformMatrix != null) {
      // Transform the label position by our transform matrix
      mTransformedPosition = Matrix4x4.transformVector(mTransformMatrix, mTarget);
    }
    return mTransformedPosition;
  }
  
  public boolean targetInFocusRadius() {
    return mWasInFocusLastCheck;
  }
  
  public void setTargetFocusRadius(float radius) {
    mTargetFocusRadius = radius;
  }
  
  // Returns a number between 0 and 1, 0 meaning that we should draw the UI as if the target
  // is not in focus, 1 meaning it should be fully in focus, and between the two meaning
  // it just transitioned between the two, so we should be drawing the transition.
  public float getTransitionFactor() {
    return mTransitionFactor;
  }
  
  // Checks whether the search target is in the focus or not, and updates the seconds in the state
  // accordingly.
  public void checkState() {
    boolean inFocus = targetInFocusRadiusImpl();
    mWasInFocusLastCheck = inFocus;
    long time = System.currentTimeMillis();
    float delta = 0.001f * (time - mLastUpdateTime);
    mTransitionFactor += delta * (inFocus ? 1 : -1);
    mTransitionFactor = Math.min(1, Math.max(0, mTransitionFactor));
    mLastUpdateTime = time;
  }
  
  public String getTargetName() {
    return mTargetName;
  }
  
  // Returns the distance from the center of the screen, in pixels, if the target is in front of
  // the viewer.  Returns infinity if the point is behind the viewer.
  private float getDistanceFromCenterOfScreen() {
    Vector3 position = getTransformedPosition();
    if (position.z > 0) {
      float dx = position.x * mHalfScreenWidth;
      float dy = position.y * mHalfScreenHeight;
      return MathUtil.sqrt(dx*dx + dy*dy);
    } else {
      return Float.POSITIVE_INFINITY;
    }
  }
  
  private boolean targetInFocusRadiusImpl() {
    float distFromCenter = getDistanceFromCenterOfScreen();
    return 0.5f * mTargetFocusRadius > distFromCenter;
  }
  
  private Vector3 mTarget = new Vector3(0, 0, 0);
  private Vector3 mTransformedPosition = new Vector3(0, 0, 0);
  private float mHalfScreenWidth = 1;
  private float mHalfScreenHeight = 1;
  private Matrix4x4 mTransformMatrix = null;
  private float mTargetFocusRadius = 0;
  private float mTransitionFactor = 0;
  private long mLastUpdateTime = 0;
  private boolean mWasInFocusLastCheck = false;
  private String mTargetName = "Default target name";
}
```


Overlapping Code:
```
r {
public void resize(int width, int height) {
mHalfScreenWidth = width * 0.5f;
mHalfScreenHeight = height * 0.5f;
}

public void setTarget(Vector3 target, String targetName) {
mTargetName = targetName;
mTarget = target.copy();
mTransformedPosition = null;
mLastUpdateTime = System.currentTimeMillis();
mTransitionFactor = targetInFocusRadiusImpl() ? 1 : 0;
}

public void setTransform(Matrix4x4 transformMatrix) {
mTransformMatrix = transformMatrix;
mTransformedPosition = null;
}

public Vector3 getTransformedPosition() {
if (mTransformedPosition == null && mTransformMatrix != null) {
// Transform the label position by our transform matrix
mTransformedPosition = Matrix4x4.transformVector(mTransformMatrix, mTarget);
}
return mTransformedPosition;
}

public boolean targetInFocusRadius() {
return mWasInFocusLastCheck;
}

public void setTargetFocusRadius(float radius) {
mTargetFocusRadius = radius;
}

// Returns a number between 0 and 1, 0 meaning that we should draw the UI as if the target
// is not in focus, 1 meaning it should be fully in focus, and between the two meaning
// it just transitioned between the two, so we should be drawing the transition.
public float getTransitionFactor() {
return mTransitionFactor;
}

// Checks whether the search target is in the focus or not, and updates the seconds in the state
// accordingly.
public void checkState() {
boolean inFocus = targetInFocusRadiusImpl();
mWasInFocusLastCheck = inFocus;
long time = System.currentTimeMillis();
float delta = 0.001f * (time - mLastUpdateTime);
mTransitionFactor += delta * (inFocus ? 1 : -1);
mTransitionFactor = Math.min(1, Math.max(0, mTransitionFactor));
mLastUpdateTime = time;
}

public String getTargetName() {
return mTargetName;
}

// Returns the distance from the center of the screen, in pixels, if the target is in front of
// the viewer. Returns infinity if the point is behind the viewer.
private float getDistanceFromCenterOfScreen() {
Vector3 position = getTransformedPosition();
if (position.z > 0) {
float dx = position.x * mHalfScreenWidth;
float dy = position.y * mHalfScreenHeight;
return MathUtil.sqrt(dx*dx + dy*dy);
} else {
return Float.POSITIVE_INFINITY;
}
}

private boolean targetInFocusRadiusImpl() {
float distFromCenter = ge
```
<Overlap Ratio: 0.9894459102902374>

---

--- 252 --
Question ID: 354be56115891094a590c44f1daca45cf507d1d0
Original Code:
```
@Repository(value="setCallColumnInfoDao")
public class SetCallColumnInfoDaoImpl implements SetCallColumnInfoDao {

    @Override
    public int selectCountByDateSet(String dataSetCode) {

        int count = 0;
        String queryStr = "SELECT COUNT(*) from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo =1 AND dataset = '"+dataSetCode+"'";
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);

        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(queryStr);

            while (resultSet.next()){
              count = resultSet.getInt(1);
            }

            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return  count;
    }

    @Override
    public List<CallColumnInfoBean> selectCallColumnInfoByDateSet(String s) {
        return null;
    }


    @Override
    public int updateCallColumnInfo(CallColumnInfoBean callColumnInfoBean) {
        String updateStr = "UPDATE analysisplatform.callcolumninfo SET displaylevel =? WHERE showsensitiveinfo =1 and id =?";
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);
      int coutn = 0;
        try {
            PreparedStatement  preparedStatement = connection.prepareStatement(updateStr);

            preparedStatement.setString(1,callColumnInfoBean.getDisplaylevel());
            preparedStatement.setInt(2,callColumnInfoBean.getId());

            coutn = preparedStatement.executeUpdate();

            connection.close();
        } catch (SQLException e) {
            System.out.println("["+e.getMessage()+"]");
        }

        return  coutn;
    }

    @Override
    public List<CallColumnInfoBean> selectCallColumnInfoByRoleName(String roleName) {
        String queryStr = "SELECT id,displaylevel,showsensitiveinfo,dataset from analysisplatform.callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%"+roleName+",%'";
        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);
    }

    @Override
    public int selectCountByDateSetAndRoleName(int id, String dataSetCode, String roleName) {
        String queryStr = "SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE column_id ="+id+" and role ='"+roleName+"' and dataset ='"+dataSetCode+"'";
        return  getCount(queryStr);
    }

    @Override
    public List<CallColumnInfoBean> selectByDateSetAndRoleName(String roleName, String dataSetCode) {
        String queryStr = "SELECT id,displaylevel,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%"+roleName+",%' and dataset ='"+dataSetCode+"'";

        return null;//getCallColumnInfoBeanListByQueryStr(queryStr);
    }



    @Override
    public List<SetCallColumnInfoBean> selectSetCallColumnInfoByDateSet(String dataSetCode) {

        String queryStr = "SELECT id,show_sensitiveinfo,dataset from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo = 1 and dataset = '"+dataSetCode+"'";
        return getCallColumnInfoBeanListByQueryStr(queryStr);
    }

    @Override
    public int selectCountByDateSetAndRoleName(String dataSetCode, String roleName) {
        String queryStr = "SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE role ='"+roleName+"' and dataset ='"+dataSetCode+"'";
        return  getCount(queryStr);
    }


    @Override
    public boolean insertRoleNameToSetCall(int id, String rolesname, String dataSetCode) {
        int count =0;
        String insertStr = "INSERT INTO analysisplatform.set_callcolumn_role (column_id,role,dataset)VALUES(?,?,?)";
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);

        try {
            PreparedStatement preparedStatement = connection.prepareStatement(insertStr);
             preparedStatement.setInt(1,id);
             preparedStatement.setString(2,rolesname);
             preparedStatement.setString(3,dataSetCode);
             count =preparedStatement.executeUpdate();

             connection.close();
        } catch (SQLException e) {
            System.out.println("["+e.getMessage()+"]");
        }


        return count ==1;
    }

    @Override
    public boolean deleteRoleNameSetCall(String rolesname, String dataSetCode) {
        String deleteStr = "DELETE FROM analysisplatform.set_callcolumn_role WHERE role =? AND dataset =?";

       int count = 0;
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);

        try {
            PreparedStatement preparedStatement = connection.prepareStatement(deleteStr);
            preparedStatement.setString(1,rolesname);
            preparedStatement.setString(2,dataSetCode);
            count =preparedStatement.executeUpdate();

            connection.close();
        } catch (SQLException e) {
            System.out.println("["+e.getMessage()+"]");
        }


        return count ==1;
    }

    private int getCount(String queryStr) {
        int count = 0;
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);

        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(queryStr);

            while (resultSet.next()){
                count = resultSet.getInt(1);
            }

            connection.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return count;
    }


    private List<SetCallColumnInfoBean>  getCallColumnInfoBeanListByQueryStr(String queryStr) {
        List<SetCallColumnInfoBean> setCallColumnInfoBeanList = new ArrayList<>();
        Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);
        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery(queryStr);

            while (resultSet.next()){
                SetCallColumnInfoBean setCallColumnInfoBean = new SetCallColumnInfoBean();

                setCallColumnInfoBean.setId(resultSet.getInt(1));
                setCallColumnInfoBean.setShow_sensitiveinfo(resultSet.getInt(2));
                setCallColumnInfoBean.setDataset(resultSet.getString(3));

                setCallColumnInfoBeanList.add(setCallColumnInfoBean);
            }

            connection.close();
        } catch (SQLException e) {
            System.out.println("["+e.getMessage()+"]");
        }
        return  setCallColumnInfoBeanList;
    }

}
```


Overlapping Code:
```
foDao")
public class SetCallColumnInfoDaoImpl implements SetCallColumnInfoDao {
@Override
public int selectCountByDateSet(String dataSetCode) {
int count = 0;
String queryStr = "SELECT COUNT(*) from analysisplatform.set_callcolumninfo WHERE show_sensitiveinfo =1 AND dataset = '"+dataSetCode+"'";
Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);
try {
Statement statement = connection.createStatement();
ResultSet resultSet = statement.executeQuery(queryStr);
while (resultSet.next()){
count = resultSet.getInt(1);
}
connection.close();
} catch (SQLException e) {
e.printStackTrace();
}
return count;
}
@Override
public List<CallColumnInfoBean> selectCallColumnInfoByDateSet(String s) {
return null;
}
@Override
public int updateCallColumnInfo(CallColumnInfoBean callColumnInfoBean) {
String updateStr = "UPDATE analysisplatform.callcolumninfo SET displaylevel =? WHERE showsensitiveinfo =1 and id =?";
Connection connection = MySQLConnectionBean.getInstance().getDefaultConnection(Global.DatabaseName);
int coutn = 0;
try {
PreparedStatement preparedStatement = connection.prepareStatement(updateStr);
preparedStatement.setString(1,callColumnInfoBean.getDisplaylevel());
preparedStatement.setInt(2,callColumnInfoBean.getId());
coutn = preparedStatement.executeUpdate();
connection.close();
} catch (SQLException e) {
System.out.println("["+e.getMessage()+"]");
}
return coutn;
}
@Override
public List<CallColumnInfoBean> selectCallColumnInfoByRoleName(String roleName) {
String queryStr = "SELECT id,displaylevel,showsensitiveinfo,dataset from analysisplatform.callcolumninfo WHERE showsensitiveinfo =1 and displaylevel LIKE '%"+roleName+",%'";
return null;//getCallColumnInfoBeanListByQueryStr(queryStr);
}
@Override
public int selectCountByDateSetAndRoleName(int id, String dataSetCode, String roleName) {
String queryStr = "SELECT COUNT(*) from analysisplatform.set_callcolumn_role WHERE column_id ="+id+" and role ='"+roleName+"' and dataset ='"+dataSetCode+"'";
return getCount(queryStr);
}
@
```
<Overlap Ratio: 0.9747979077508322>

---

--- 253 --
Question ID: fe621f0c1804e5bf30835d1b01f5acee8fb59abc
Original Code:
```
public class ThermostatUserInterfaceConfigurationClient extends ClientCluster {

	private static final DoubleByte THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB = new DoubleByte(0x0204);
	
	public static final DoubleByte KEYPAD_LOOKOUT_ATTRIBUTE_ID = new DoubleByte(0x0001);
	
	@Override
	protected ZFrame[] manageClusterSpecificFrame(AfIncomingMsg af, ZclDevice dev,MqttConnection connection) {
		return new ZFrame[0];
	}

	@Override
	protected ZFrame[] manageProfileWideFrame(AfIncomingMsg af, ZclDevice dev) {
		return new ZFrame[0];
	}

	@Override
	public ZFrame[] init(ZclDevice dev) {
		if (dev == null) {
			return new ZFrame[0];
		}
		ZclCluster tuicCluster = dev.getZclCluster(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB);
		if (tuicCluster == null) {
			return new ZFrame[0];
		}
		ZFrame frame = tuicCluster.buildWriteAttributes(
				KEYPAD_LOOKOUT_ATTRIBUTE_ID, "0");
		return new ZFrame[] {frame};
	}

	@Override
	public DoubleByte getClusterId() {
		return new DoubleByte(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB.intValue());
	}
}
```


Overlapping Code:
```
ThermostatUserInterfaceConfigurationClient extends ClientCluster {
private static final DoubleByte THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB = new DoubleByte(0x0204);

public static final DoubleByte KEYPAD_LOOKOUT_ATTRIBUTE_ID = new DoubleByte(0x0001);

@Override
protected ZFrame[] manageClusterSpecificFrame(AfIncomingMsg af, ZclDevice dev,MqttConnection connection) {
return new ZFrame[0];
}
@Override
protected ZFrame[] manageProfileWideFrame(AfIncomingMsg af, ZclDevice dev) {
return new ZFrame[0];
}
@Override
public ZFrame[] init(ZclDevice dev) {
if (dev == null) {
return new ZFrame[0];
}
ZclCluster tuicCluster = dev.getZclCluster(THERMOSTAT_USER_INTERFACE_CONFIGURATION_ID_DB);
if (tuicCluster == null) {
return new ZFrame[0];
}
ZFrame frame = tuicCluster.buildWriteAttributes(
KEYPAD_LOOKOUT_ATTRIBUTE_ID, "0");
return new ZFrame[] {frame};
}
@Override
public DoubleByte getClusterId() {
return new DoubleByte(THERMOSTAT_USER_INTERFACE
```
<Overlap Ratio: 0.95>

---

--- 254 --
Question ID: b1df6f12d984dc0151a1b348b24c52dc7ba0cf2f
Original Code:
```
public class Problem1472 {
    static class BrowserHistory {
        private List<String> history = new ArrayList<>();
        private int index;

        public BrowserHistory(String homepage) {
            history.add(homepage);
        }

        public void visit(String url) {
            index++;
            if (index < history.size()) {
                history = history.subList(0, index);
            }
            history.add(url);
        }

        public String back(int steps) {
            index -= steps;
            if (index < 0) {
                index = 0;
            }
            return history.get(index);
        }

        public String forward(int steps) {
            index += steps;
            if (index >= history.size()) {
                index = history.size() - 1;
            }
            return history.get(index);
        }
    }
}
```


Overlapping Code:
```
em1472 {
static class BrowserHistory {
private List<String> history = new ArrayList<>();
private int index;
public BrowserHistory(String homepage) {
history.add(homepage);
}
public void visit(String url) {
index++;
if (index < history.size()) {
history = history.subList(0, index);
}
history.add(url);
}
public String back(int steps) {
index -= steps;
if (index < 0) {
index = 0;
}
return history.get(index);
}
public String forward(int steps) {
index += steps;
if (index >= history.size()) {
index = history.size() - 1;
}
return history.get(index);

```
<Overlap Ratio: 0.9598603839441536>

---

--- 255 --
Question ID: e72646c6d101390165630655d359f6e40c641310
Original Code:
```
public class BOJ_1919 {

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer stringTokenizer = new StringTokenizer(bReader.readLine());
		String string1 = stringTokenizer.nextToken();
		stringTokenizer = new StringTokenizer(bReader.readLine());
		String string2 = stringTokenizer.nextToken();
		
		int[] alpa = new int [26];
		for(int i=0;i<string1.length();i++) {
			int a = string1.charAt(i)-'a';
			alpa[a]++;
		}
		for(int i=0;i<string2.length();i++) {
			int a = string2.charAt(i)-'a';
			alpa[a]--;
		}
		int sum=0;
		for (int i : alpa) {
			if(i<0)
				sum-=i;
			else
				sum+=i;
		}
		System.out.println(sum);
	}

}
```


Overlapping Code:
```
OJ_1919 {
public static void main(String[] args) throws IOException {
// TODO Auto-generated method stub
BufferedReader bReader = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer stringTokenizer = new StringTokenizer(bReader.readLine());
String string1 = stringTokenizer.nextToken();
stringTokenizer = new StringTokenizer(bReader.readLine());
String string2 = stringTokenizer.nextToken();

int[] alpa = new int [26];
for(int i=0;i<string1.length();i++) {
int a = string1.charAt(i)-'a';
alpa[a]++;
}
for(int i=0;i<string2.length();i++) {
int a = string2.charAt(i)-'a';
alpa[a]--;
}
int sum=0;
for (int i : alpa) {
if(i<0)
sum-=i;

```
<Overlap Ratio: 0.9193776520509194>

---

--- 256 --
Question ID: 971e4aee24839ba31704292af155c0849bd77a1c
Original Code:
```
public class Solution_96 {
    public static void main(String[] args) {
        Solution solution = new Solution_96().new Solution();
    }

    //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public int numTrees(int n) {
            int[] dp = new int[n + 1];
            dp[0] = 1;
            dp[1] = 1;

            // 把某个数字当成root,则其组合数为左边的可能*右边的可能
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= i; j++) {
                    dp[i] += dp[j - 1] * dp[i - j];
                }
            }
            return dp[n];
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
```


Overlapping Code:
```
ic class Solution_96 {
public static void main(String[] args) {
Solution solution = new Solution_96().new Solution();
}
//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
public int numTrees(int n) {
int[] dp = new int[n + 1];
dp[0] = 1;
dp[1] = 1;
// 把某个数字当成root,则其组合数为左边的可能*右边的可能
for (int i = 2; i <= n; i++) {
for (int j = 1; j <= i; j++) {
dp[i] += dp[j - 1] * dp[i - j];
}
}
return dp[n];
}
}
//leetcode submit region end(Prohibit modification and deletion)
}
```
<Overlap Ratio: 0.9920159680638723>

---

--- 257 --
Question ID: 6b7fa9ffc9aedfba70fa6d992497088c5ee95939
Original Code:
```
public class ConnectInfo
	implements IMessageEntity
{

	public ConnectInfo()
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #19  <Method void Object()>
	//    2    4:return          
	}

	public ConnectInfo(List list, List list1, String s, String s1)
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #19  <Method void Object()>
		apiNameList = list;
	//    2    4:aload_0         
	//    3    5:aload_1         
	//    4    6:putfield        #23  <Field List apiNameList>
		scopeList = list1;
	//    5    9:aload_0         
	//    6   10:aload_2         
	//    7   11:putfield        #25  <Field List scopeList>
		fingerprint = s;
	//    8   14:aload_0         
	//    9   15:aload_3         
	//   10   16:putfield        #27  <Field String fingerprint>
		subAppID = s1;
	//   11   19:aload_0         
	//   12   20:aload           4
	//   13   22:putfield        #29  <Field String subAppID>
	//   14   25:return          
	}

	public List getApiNameList()
	{
		return apiNameList;
	//    0    0:aload_0         
	//    1    1:getfield        #23  <Field List apiNameList>
	//    2    4:areturn         
	}

	public String getFingerprint()
	{
		return fingerprint;
	//    0    0:aload_0         
	//    1    1:getfield        #27  <Field String fingerprint>
	//    2    4:areturn         
	}

	public List getScopeList()
	{
		return scopeList;
	//    0    0:aload_0         
	//    1    1:getfield        #25  <Field List scopeList>
	//    2    4:areturn         
	}

	public String getSubAppID()
	{
		return subAppID;
	//    0    0:aload_0         
	//    1    1:getfield        #29  <Field String subAppID>
	//    2    4:areturn         
	}

	public void setApiNameList(List list)
	{
		apiNameList = list;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #23  <Field List apiNameList>
	//    3    5:return          
	}

	public void setFingerprint(String s)
	{
		fingerprint = s;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #27  <Field String fingerprint>
	//    3    5:return          
	}

	public void setScopeList(List list)
	{
		scopeList = list;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #25  <Field List scopeList>
	//    3    5:return          
	}

	public void setSubAppID(String s)
	{
		subAppID = s;
	//    0    0:aload_0         
	//    1    1:aload_1         
	//    2    2:putfield        #29  <Field String subAppID>
	//    3    5:return          
	}

	private List apiNameList;
	private String fingerprint;
	private List scopeList;
	private String subAppID;
}
```


Overlapping Code:
```
plements IMessageEntity
{
public ConnectInfo()
{
// 0 0:aload_0 
// 1 1:invokespecial #19 <Method void Object()>
// 2 4:return 
}
public ConnectInfo(List list, List list1, String s, String s1)
{
// 0 0:aload_0 
// 1 1:invokespecial #19 <Method void Object()>
apiNameList = list;
// 2 4:aload_0 
// 3 5:aload_1 
// 4 6:putfield #23 <Field List apiNameList>
scopeList = list1;
// 5 9:aload_0 
// 6 10:aload_2 
// 7 11:putfield #25 <Field List scopeList>
fingerprint = s;
// 8 14:aload_0 
// 9 15:aload_3 
// 10 16:putfield #27 <Field String fingerprint>
subAppID = s1;
// 11 19:aload_0 
// 12 20:aload 4
// 13 22:putfield #29 <Field String subAppID>
// 14 25:return 
}
public List getApiNameList()
{
return apiNameList;
// 0 0:aload_0 
// 1 1:getfield #23 <Field List apiNameList>
// 2 4:areturn 
}
public String getFingerprint()
{
return fingerprint;
// 0 0:aload_0 
// 1 1:getfield #27 <Field String fingerprint>
// 2 4:areturn 
}
public List getScopeList()
{
return scopeList;
// 0 0:aload_0 
// 1 1:getfield #25 <Field List scopeList>
// 2 4:areturn 
}
public String getSubAppID()
{
return subAppID;
// 0 0:aload_0 
// 1 1:getfield #29 <Field String subAppID>
// 2 4:areturn 
}
public void setApiNameList(List list)
{
apiNameList = list;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #23 <Field List apiNameList>
// 3 5:return 
}
public void setFingerprint(String s)
{
fingerprint = s;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #27 <Field String fingerprint>
// 3 5:return 
}
public void setScopeList(List list)
{
scopeList = list;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #25 <Field List scopeList>
// 3 5:return 
}
public void setSubAppID(String s)
{
subAppID = s;
// 0 0:aload_0 
// 1 1:aload_1 
// 2 2:putfield #29 <Field Strin
```
<Overlap Ratio: 0.9842342342342343>

---

--- 258 --
Question ID: fab1a06c233d3c5e207c132fe276f209dd4d3bbb
Original Code:
```
public class DepartmentDaoImpl implements DepartmentDao {
	
	public int save(Department dept) {
		String sql = "insert into dept values(?,?,?)";
		Object[] params = {dept.getDeptno(),dept.getDeptName(),dept.getLocation()};
		
		return DBUtil.executeUpdate(sql, params);
		
	}

	@Override
	public List<Department> findAll() {
		
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		
		List<Department> depts = null;
		
		try {
			conn = DBUtil.getConnection();
			String sql = "select * from dept";
			ps=conn.prepareStatement(sql);
			rs=ps.executeQuery();
			depts = new ArrayList<>();
			while(rs.next()) {
				Department dept=new Department();
				dept.setDeptno(rs.getInt("deptno"));
				dept.setDeptName(rs.getString("deptName"));
				dept.setLocation(rs.getString("location"));
				depts.add(dept);
			}
			System.out.println(depts);
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			DBUtil.closeAll(rs, ps, conn);
		}
		
		return depts;
	}

	@Override
	public int delete(int deptNo) {
		
		String sql = "delete from dept where deptno=?";
		Object[] params = {deptNo};
		
		return DBUtil.executeUpdate(sql, params);
	}

	@Override
	public Department findById(int deptNo) {
		
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		
		Department dept=null;
		
		try {
			conn = DBUtil.getConnection();
			String sql = "select * from dept where deptno=?";
			ps=conn.prepareStatement(sql);
			ps.setInt(1, deptNo);
			rs=ps.executeQuery();
			while(rs.next()) {
				dept=new Department();
				dept.setDeptno(rs.getInt("deptno"));
				dept.setDeptName(rs.getString("deptName"));
				dept.setLocation(rs.getString("location"));
			}
			System.out.println(dept);
			
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			DBUtil.closeAll(rs, ps, conn);
		}
		
		return dept;
	}

	@Override
	public int update(Department dept) {
		
		String sql = "update dept set deptname=?,location=? where deptno=?";
		Object[] params = {dept.getDeptName(),dept.getLocation(),dept.getDeptno()};
		
		return DBUtil.executeUpdate(sql, params);
	}
}
```


Overlapping Code:
```
ublic class DepartmentDaoImpl implements DepartmentDao {

public int save(Department dept) {
String sql = "insert into dept values(?,?,?)";
Object[] params = {dept.getDeptno(),dept.getDeptName(),dept.getLocation()};

return DBUtil.executeUpdate(sql, params);

}
@Override
public List<Department> findAll() {

Connection conn = null;
PreparedStatement ps = null;
ResultSet rs = null;

List<Department> depts = null;

try {
conn = DBUtil.getConnection();
String sql = "select * from dept";
ps=conn.prepareStatement(sql);
rs=ps.executeQuery();
depts = new ArrayList<>();
while(rs.next()) {
Department dept=new Department();
dept.setDeptno(rs.getInt("deptno"));
dept.setDeptName(rs.getString("deptName"));
dept.setLocation(rs.getString("location"));
depts.add(dept);
}
System.out.println(depts);

} catch (Exception e) {
e.printStackTrace();
}finally {
DBUtil.closeAll(rs, ps, conn);
}

return depts;
}
@Override
public int delete(int deptNo) {

String sql = "delete from dept where deptno=?";
Object[] params = {deptNo};

return DBUtil.executeUpdate(sql, params);
}
@Override
public Department findById(int deptNo) {

Connection conn = null;
PreparedStatement ps = null;
ResultSet rs = null;

Department dept=null;

try {
conn = DBUtil.getConnection();
String sql = "select * from dept where deptno=?";
ps=conn.prepareStatement(sql);
ps.setInt(1, deptNo);
rs=ps.executeQuery();
while(rs.next()) {
dept=new Department();
dept.setDeptno(rs.getInt("deptno"));
dept.setDeptName(rs.getString("deptName"));
dept.setLocation(rs.getString("location"));
}
System.out.println(dept);

} catch (Exception e) {
e.printStackTrace();
}finally {
DBUtil.closeAll(rs, ps, conn);
}

return dept;
}
@Override
public int update(Department dept) {

String sql = "update dept set deptname=?,location=? where deptno=?";
Object[] params = {dept.getDeptName(),dept.getLocation(),dept.getDeptno()};

return D
```
<Overlap Ratio: 0.9801670146137788>

---

--- 259 --
Question ID: 86c3088cd2b3473c5bff37b0e5aff318267547bb
Original Code:
```
public class OutsetHandler extends ItemStackHandler
{
	ItemStack[] ghostStacks;
	public OutsetHandler()
	{
		super();
	}

	public OutsetHandler( int size )
	{
		super( size );
		ghostStacks = new ItemStack[size];
	}

	public OutsetHandler( ItemStack[] stacks )
	{
		super( stacks );
		ghostStacks = new ItemStack[stacks.length];
	}

    public void setSize(int size)
    {
    	super.setSize( size );
    	ghostStacks = new ItemStack[size];
    }

	public void setStackGhosted(int slot, ItemStack stack)
    {
        validateSlotIndex(slot);
        if (ItemStack.matches(this.ghostStacks[slot], stack))
            return;
        this.ghostStacks[slot] = stack;
    }
}
```


Overlapping Code:
```
ublic class OutsetHandler extends ItemStackHandler
{
ItemStack[] ghostStacks;
public OutsetHandler()
{
super();
}
public OutsetHandler( int size )
{
super( size );
ghostStacks = new ItemStack[size];
}
public OutsetHandler( ItemStack[] stacks )
{
super( stacks );
ghostStacks = new ItemStack[stacks.length];
}
public void setSize(int size)
{
super.setSize( size );
ghostStacks = new ItemStack[size];
}
public void setStackGhosted(int slot, ItemStack stack)
{
validateSlotIndex(slot);
if (ItemStack.matches(this.ghostStacks[slot], stack))
return;
this.ghostStacks[slot] = stack;
}
}
```
<Overlap Ratio: 0.9982788296041308>

---

--- 260 --
Question ID: ee59db94735aa440c35792460eda6bdcf7b49c3f
Original Code:
```
public final class XServletHandlerToSimpleHandler implements IXServletHandler
{
  private static final Logger LOGGER = LoggerFactory.getLogger (XServletHandlerToSimpleHandler.class);

  private final IMutableStatisticsHandlerCounter m_aStatsHasLastModification = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                    "$has-lastmodification");
  private final IMutableStatisticsHandlerCounter m_aStatsHasETag = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                        "$has-etag");
  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                           "$notmodified.if-modified-since");
  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                        "$modified.if-modified-since");
  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                             "$notmodified.if-unmodified-since");
  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                          "$modified.if-unmodified-since");
  private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                      "$notmodified.if-unon-match");
  private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +
                                                                                                                   "$modified.if-unon-match");

  private final IXServletSimpleHandler m_aSimpleHandler;

  public XServletHandlerToSimpleHandler (@Nonnull final IXServletSimpleHandler aSimpleHandler)
  {
    ValueEnforcer.notNull (aSimpleHandler, "SimpleHandler");
    m_aSimpleHandler = aSimpleHandler;
  }

  @Override
  public void onServletInit (@Nonnull final ICommonsMap <String, String> aInitParams) throws ServletException
  {
    // Pass-through!
    m_aSimpleHandler.onServletInit (aInitParams);
  }

  private void _onException (@Nonnull final IRequestWebScopeWithoutResponse aRequestScope,
                             @Nonnull final UnifiedResponse aUnifiedResponse,
                             @Nonnull final Throwable t) throws IOException, ServletException
  {
    if (LOGGER.isErrorEnabled ())
      LOGGER.error ("An exception was caught in servlet processing for URL '" + aRequestScope.getURL () + "'", t);

    // Invoke exception handler
    if (m_aSimpleHandler.onException (aRequestScope, aUnifiedResponse, t).isContinue ())
    {
      // Propagate exception
      if (t instanceof IOException)
        throw (IOException) t;
      if (t instanceof ServletException)
        throw (ServletException) t;
      throw new ServletException (t);
    }
  }

  @Nonnull
  private EContinue _handleETag (@Nonnull final HttpServletRequest aHttpRequest,
                                 @Nonnull final IRequestWebScopeWithoutResponse aRequestScope,
                                 @Nonnull final UnifiedResponse aUnifiedResponse)
  {
    final LocalDateTime aLastModification = m_aSimpleHandler.getLastModificationDateTime (aRequestScope);
    if (aLastModification != null)
    {
      m_aStatsHasLastModification.increment ();

      // Get the If-Modified-Since date header
      final long nRequestIfModifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_MODIFIED_SINCE);
      if (nRequestIfModifiedSince >= 0)
      {
        final LocalDateTime aRequestIfModifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfModifiedSince);
        if (aLastModification.compareTo (aRequestIfModifiedSince) <= 0)
        {
          if (LOGGER.isDebugEnabled ())
            LOGGER.debug ("Requested resource was not modified: " + aRequestScope.getPathWithinServlet ());

          // Was not modified since the passed time
          m_aStatsNotModifiedIfModifiedSince.increment ();
          return EContinue.BREAK;
        }
        m_aStatsModifiedIfModifiedSince.increment ();
      }

      // Get the If-Unmodified-Since date header
      final long nRequestIfUnmodifiedSince = aHttpRequest.getDateHeader (CHttpHeader.IF_UNMODIFIED_SINCE);
      if (nRequestIfUnmodifiedSince >= 0)
      {
        final LocalDateTime aRequestIfUnmodifiedSince = CHttp.convertMillisToLocalDateTime (nRequestIfUnmodifiedSince);
        if (aLastModification.compareTo (aRequestIfUnmodifiedSince) >= 0)
        {
          if (LOGGER.isDebugEnabled ())
            LOGGER.debug ("Requested resource was not modified: " + aRequestScope.getPathWithinServlet ());

          // Was not modified since the passed time
          m_aStatsNotModifiedIfUnmodifiedSince.increment ();
          return EContinue.BREAK;
        }
        m_aStatsModifiedIfUnmodifiedSince.increment ();
      }

      // No If-Modified-Since request header present, set the Last-Modified
      // header for later reuse
      aUnifiedResponse.setLastModified (aLastModification);
    }

    // Handle the ETag
    final String sSupportedETag = m_aSimpleHandler.getSupportedETag (aRequestScope);
    if (StringHelper.hasText (sSupportedETag))
    {
      m_aStatsHasETag.increment ();

      // get the request ETag
      final String sRequestETags = aHttpRequest.getHeader (CHttpHeader.IF_NON_MATCH);
      if (StringHelper.hasText (sRequestETags))
      {
        // Request header may contain several ETag values
        final ICommonsList <String> aAllETags = RegExHelper.getSplitToList (sRequestETags, ",\\s+");
        if (aAllETags.isEmpty ())
        {
          if (LOGGER.isWarnEnabled ())
            LOGGER.warn ("Empty ETag list found (" + sRequestETags + ")");
        }
        else
        {
          // Scan all found ETags for match
          for (final String sCurrentETag : aAllETags)
            if (sSupportedETag.equals (sCurrentETag))
            {
              if (LOGGER.isDebugEnabled ())
                LOGGER.debug ("Requested resource has the same E-Tag: " + aRequestScope.getPathWithinServlet ());

              // We have a matching ETag
              m_aStatsNotModifiedIfNonMatch.increment ();
              return EContinue.BREAK;
            }
        }
        m_aStatsModifiedIfNonMatch.increment ();
      }

      // Save the ETag for the response
      aUnifiedResponse.setETagIfApplicable (sSupportedETag);
    }
    return EContinue.CONTINUE;
  }

  public void onRequest (@Nonnull final HttpServletRequest aHttpRequest,
                         @Nonnull final HttpServletResponse aHttpResponse,
                         @Nonnull final EHttpVersion eHttpVersion,
                         @Nonnull final EHttpMethod eHttpMethod,
                         @Nonnull final IRequestWebScope aRequestScope) throws ServletException, IOException
  {
    final UnifiedResponse aUnifiedResponse = m_aSimpleHandler.createUnifiedResponse (eHttpVersion,
                                                                                     eHttpMethod,
                                                                                     aHttpRequest,
                                                                                     aRequestScope);
    if (m_aSimpleHandler.initRequestState (aRequestScope, aUnifiedResponse).isBreak ())
    {
      if (LOGGER.isDebugEnabled ())
        LOGGER.debug ("Cancelled request after initRequestState with response " + aUnifiedResponse);

      // May e.g. be an 404 error for some not-found resource
    }
    else
    {
      // Init was successful

      // Check for last-modification on GET and HEAD
      boolean bExecute = true;
      if (eHttpMethod == EHttpMethod.GET || eHttpMethod == EHttpMethod.HEAD)
        if (_handleETag (aHttpRequest, aRequestScope, aUnifiedResponse).isBreak ())
        {
          // ETag present in request
          aUnifiedResponse.setStatus (HttpServletResponse.SC_NOT_MODIFIED);
          bExecute = false;
        }

      if (bExecute)
      {
        // On request begin
        try
        {
          m_aSimpleHandler.onRequestBegin (aRequestScope);
        }
        catch (final Throwable t)
        {
          _onException (aRequestScope, aUnifiedResponse, t);
        }

        Throwable aCaughtException = null;
        try
        {
          // main servlet handling
          m_aSimpleHandler.handleRequest (aRequestScope, aUnifiedResponse);

          if (LOGGER.isDebugEnabled ())
            LOGGER.debug ("Successfully handled request: " + aRequestScope.getPathWithinServlet ());
        }
        catch (final ForcedRedirectException ex)
        {
          // Pass through
          throw ex;
        }
        catch (final Exception ex)
        {
          // Invoke exception handler
          // This internally re-throws the exception if needed
          aCaughtException = ex;
          _onException (aRequestScope, aUnifiedResponse, ex);
        }
        finally
        {
          // On request end
          try
          {
            m_aSimpleHandler.onRequestEnd (aCaughtException);
          }
          catch (final Exception ex)
          {
            LOGGER.error ("onRequestEnd failed", ex);
            // Don't throw anything here
          }
        }
      }
    }
    aUnifiedResponse.applyToResponse (aHttpResponse);
  }

  @Override
  public void onServletDestroy ()
  {
    // Pass-through!
    m_aSimpleHandler.onServletDestroy ();
  }
}
```


Overlapping Code:
```
 XServletHandlerToSimpleHandler implements IXServletHandler
{
private static final Logger LOGGER = LoggerFactory.getLogger (XServletHandlerToSimpleHandler.class);
private final IMutableStatisticsHandlerCounter m_aStatsHasLastModification = StatisticsManager.getCounterHandler (getClass ().getName () +
"$has-lastmodification");
private final IMutableStatisticsHandlerCounter m_aStatsHasETag = StatisticsManager.getCounterHandler (getClass ().getName () +
"$has-etag");
private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
"$notmodified.if-modified-since");
private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfModifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
"$modified.if-modified-since");
private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
"$notmodified.if-unmodified-since");
private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfUnmodifiedSince = StatisticsManager.getCounterHandler (getClass ().getName () +
"$modified.if-unmodified-since");
private final IMutableStatisticsHandlerCounter m_aStatsNotModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +
"$notmodified.if-unon-match");
private final IMutableStatisticsHandlerCounter m_aStatsModifiedIfNonMatch = StatisticsManager.getCounterHandler (getClass ().getName () +
"$modif
```
<Overlap Ratio: 0.9798308392973325>

---

--- 261 --
Question ID: 7117cb099dbb5068ecf9fb8fcac9df79992de0ce
Original Code:
```
@RestController
@RequestMapping(value = "router/youngyedu/ym/sync")
public class ZyMYoungyeduSyncController {

	@Autowired
	private YoungyeduSyncDataService dataService;
	@Autowired
	private YoungyeduHttpClient client;
	@Autowired
	private MqSender mqSender;
	@Autowired
	private UserChannelService ucService;

	/**
	 * 提醒进行同步操作
	 *
	 * @param id
	 *            同步id
	 * @return {@link Value}
	 */
	@MasterSlaveDataSource(type = "M")
	@RolesAllowed(anyone = true)
	@RequestMapping(value = "noticeSync", method = { RequestMethod.GET, RequestMethod.POST })
	public Value noticeSync(String id) {
		UserChannel uc = ucService.findByName(UserChannel.YOUNGEDU);
		Integer channelCode = uc == null ? null : uc.getCode();

		if (channelCode == null) {
			client.updateVersion(id, false);
			return new Value(new IllegalArgException());
		}

		JSONObject jsonObject = new JSONObject();
		jsonObject.put("classId", id);
		jsonObject.put("channelCode", channelCode);

		mqSender.asynSend(MqYoomathYoungyeduRegistryConstants.EX_YM_YOUNGEDU,
				MqYoomathYoungyeduRegistryConstants.RK_YM_YOUNGEDU_SYNC, MQ.builder().data(jsonObject).build());

		client.updateVersion(id, true);

		return new Value();
	}

}
```


Overlapping Code:
```
estController
@RequestMapping(value = "router/youngyedu/ym/sync")
public class ZyMYoungyeduSyncController {
@Autowired
private YoungyeduSyncDataService dataService;
@Autowired
private YoungyeduHttpClient client;
@Autowired
private MqSender mqSender;
@Autowired
private UserChannelService ucService;
/**
* 提醒进行同步操作
*
* @param id
* 同步id
* @return {@link Value}
*/
@MasterSlaveDataSource(type = "M")
@RolesAllowed(anyone = true)
@RequestMapping(value = "noticeSync", method = { RequestMethod.GET, RequestMethod.POST })
public Value noticeSync(String id) {
UserChannel uc = ucService.findByName(UserChannel.YOUNGEDU);
Integer channelCode = uc == null ? null : uc.getCode();
if (channelCode == null) {
client.updateVersion(id, false);
return new Value(new IllegalArgException());
}
JSONObject jsonObject = new JSONObject();
jsonObject.put("classId", id);
jsonObject.put("channelCode", channelCode);
mqSender.asynSend(MqYoomathYoungyeduRegistryConstants.EX_YM_YOUNGEDU,
MqYoomathYoungyeduRegistryConstants.RK_YM_YOUNGEDU_SYNC, MQ.builder().data(jsonObject).build());
client.updateVersi
```
<Overlap Ratio: 0.9651162790697675>

---

--- 262 --
Question ID: 88ea1e41f12eaebfc6b0221b571367b24ab07478
Original Code:
```
public final class ArgEdge<S extends State, A extends Action> {
	private static final int HASH_SEED = 3653;
	private volatile int hashCode = 0;

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		ArgEdge<?, ?> argEdge = (ArgEdge<?, ?>) o;
		return Objects.equals(source.getState(), argEdge.source.getState())
				&& Objects.equals(target.getState(), argEdge.target.getState())
				&& Objects.equals(action.toString(), argEdge.action.toString());
	}

	@Override
	public int hashCode() {
		int result = hashCode;
		if (result == 0) {
			result = HASH_SEED;
			result = 31 * result + source.getState().hashCode();
			result = 31 * result + target.getState().hashCode();
			result = 31 * result + action.toString().hashCode();
			hashCode = result;
		}
		return result;
		// return Objects.hash(source.getState(), target.getState(), action.toString());
	}

	private final ArgNode<S, A> source;
	private final ArgNode<S, A> target;
	private final A action;

	ArgEdge(final ArgNode<S, A> source, final A action, final ArgNode<S, A> target) {
		this.source = source;
		this.action = action;
		this.target = target;
	}

	public ArgNode<S, A> getSource() {
		return source;
	}

	public ArgNode<S, A> getTarget() {
		return target;
	}

	public A getAction() {
		return action;
	}

}
```


Overlapping Code:
```
inal class ArgEdge<S extends State, A extends Action> {
private static final int HASH_SEED = 3653;
private volatile int hashCode = 0;
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
ArgEdge<?, ?> argEdge = (ArgEdge<?, ?>) o;
return Objects.equals(source.getState(), argEdge.source.getState())
&& Objects.equals(target.getState(), argEdge.target.getState())
&& Objects.equals(action.toString(), argEdge.action.toString());
}
@Override
public int hashCode() {
int result = hashCode;
if (result == 0) {
result = HASH_SEED;
result = 31 * result + source.getState().hashCode();
result = 31 * result + target.getState().hashCode();
result = 31 * result + action.toString().hashCode();
hashCode = result;
}
return result;
// return Objects.hash(source.getState(), target.getState(), action.toString());
}
private final ArgNode<S, A> source;
private final ArgNode<S, A> target;
private final A action;
ArgEdge(final ArgNode<S, A> source, final A action, final ArgNode<S, A> target) {
this.source = source;
this.action = action;
this.target = target;
}
public ArgNode<S, A> getSource() {
return source;
}
public ArgNode<S, A> getTarget() {
return target
```
<Overlap Ratio: 0.95859375>

---

--- 263 --
Question ID: ab028a00db13fd3589cc69066fda4680cbf7a2d7
Original Code:
```
public class baekjoon_12018 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] in = br.readLine().split(" ");
        int n = Integer.parseInt(in[0]); // 과목수
        int m = Integer.parseInt(in[1]); // 마일리지

        int[] list = new int[n]; // 과목당 필요 마일리지
        for(int i=0; i<n; i++) {
            in = br.readLine().split(" ");
            int P = Integer.parseInt(in[0]); // 신청한 사람
            int L = Integer.parseInt(in[1]); // 제한 인원

            in = br.readLine().split(" ");
            if(P<L) { // 어차피 자리 남음
                list[i]=1;
            } else {
                int[] pList = new int[P];
                for(int person=0; person<P; person++) {
                    pList[person] = Integer.parseInt(in[person]);
                }
                Arrays.sort(pList);
                list[i] = pList[P-L]; // L번째 순위랑 같게
            }
        }
        Arrays.sort(list);

        int solution=0;
        for(int i=0; i<n; i++) {
            if(m>=list[i]) {
                m-=list[i];
                ++solution;
            } else break;
        }
        System.out.println(solution);
    }
}
```


Overlapping Code:
```
_12018 {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] in = br.readLine().split(" ");
int n = Integer.parseInt(in[0]); // 과목수
int m = Integer.parseInt(in[1]); // 마일리지
int[] list = new int[n]; // 과목당 필요 마일리지
for(int i=0; i<n; i++) {
in = br.readLine().split(" ");
int P = Integer.parseInt(in[0]); // 신청한 사람
int L = Integer.parseInt(in[1]); // 제한 인원
in = br.readLine().split(" ");
if(P<L) { // 어차피 자리 남음
list[i]=1;
} else {
int[] pList = new int[P];
for(int person=0; person<P; person++) {
pList[person] = Integer.parseInt(in[person]);
}
Arrays.sort(pList);
list[i] = pList[P-L]; // L번째 순위랑 같게
}
}
Arrays.sort(list);
int solution=0;
for(int i=0; i<n; i++) {
if(m>=list[i]) {
m-=list[i];
++solution;
} else
```
<Overlap Ratio: 0.9259259259259259>

---

--- 264 --
Question ID: c74a7bb37080f5e69bddec915a5d542efab5b0db
Original Code:
```
@Service
public class CallbackService {

    private final static Logger logger = LoggerFactory.getLogger(CallbackService.class);
    private final static String CHECK_URL = "check_url";
    private final static String EVENT_TYPE = "EventType";
    private final static String SUCCESS = "success";

    public Map<String, String> callback(String signature, String timeStamp, String nonce, String encrypt) {
        if(ToolsKit.isEmpty(signature) || ToolsKit.isEmpty(timeStamp) || ToolsKit.isEmpty(nonce)) {
            throw new ServiceException("回调时，所有参数不能为空");
        }

        String plainText = DingTalkUtils.getDecryptMsg(signature, timeStamp, nonce, encrypt);
        logger.warn("明文: " + plainText);
        Map callbackMap = ToolsKit.jsonParseObject(plainText, Map.class);
        if(ToolsKit.isEmpty(callbackMap)) {
            throw new ServiceException("根据解密的字符串转换成Map时出错: Map为空");
        }
        String eventType = callbackMap.get(EVENT_TYPE) + "";

//        switch (eventType) {
//            case "user_modify_org" :
//                logger.warn("通讯录用户更改");
//                break;
//            case "bpms_task_change" :
//                logger.warn("审批任务开始/结束");
//                break;
//            case "bpms_instance_change" :
//                logger.warn("审批实例开始/结束");
//                break;
//             default:
//                 logger.warn("############");
//        }


        try {
            if(!CHECK_URL.equalsIgnoreCase(eventType)) {
                IStrategy strategy = DingTalkUtils.getStrategy(eventType);
                if(ToolsKit.isNotEmpty(strategy)) {
                    // throw new ServiceException("没有找到对应的策略类进行实施操作");
                    strategy.handle(plainText);
                }
            }
            // 返回success的加密信息表示回调处理成功
            return DingTalkUtils.getEncryptedMap(SUCCESS, System.currentTimeMillis(), DingTalkUtils.getRandomStr(8));
        } catch (Exception e) {
            throw new ServiceException(e.getMessage(), e);
        }
    }
}
```


Overlapping Code:
```
blic class CallbackService {
private final static Logger logger = LoggerFactory.getLogger(CallbackService.class);
private final static String CHECK_URL = "check_url";
private final static String EVENT_TYPE = "EventType";
private final static String SUCCESS = "success";
public Map<String, String> callback(String signature, String timeStamp, String nonce, String encrypt) {
if(ToolsKit.isEmpty(signature) || ToolsKit.isEmpty(timeStamp) || ToolsKit.isEmpty(nonce)) {
throw new ServiceException("回调时，所有参数不能为空");
}
String plainText = DingTalkUtils.getDecryptMsg(signature, timeStamp, nonce, encrypt);
logger.warn("明文: " + plainText);
Map callbackMap = ToolsKit.jsonParseObject(plainText, Map.class);
if(ToolsKit.isEmpty(callbackMap)) {
throw new ServiceException("根据解密的字符串转换成Map时出错: Map为空");
}
String eventType = callbackMap.get(EVENT_TYPE) + "";
// switch (eventType) {
// case "user_modify_org" :
// logger.warn("通讯录用户更改");
// break;
// case "bpms_task_change" :
// logger.warn("审批任务开始/结束");
// break;
// case "bpms_instance_change" :
// logger.warn("审批实例开始/结束");
// break;
// default:
// logger.warn("############");
// }
try {
if(!CHECK_URL.equalsIgnoreCase(eventType)) {
IStrategy strategy = DingTalkUtils.getStrategy(eventType);
if(ToolsKit.isNotEmpty(strategy)) {
// throw new ServiceException("没有找到对应的策略类进行实施操作");
strategy.handle(plainText);
}
}
// 返回success的加密信息表示回调处理成功
return DingTalkUtils.getEncryptedMap(SUCCESS, System.currentTimeMillis(), DingTalkUtils.getRandomStr(8));
} catch (Exception e) {
throw new ServiceException(e.getMessage(), e);
}
}
}
```
<Overlap Ratio: 0.9929936305732484>

---

--- 265 --
Question ID: bcd7fd2887e9ee1b297d72db7f284a482dd320ac
Original Code:
```
public final class TagTest {

    @Test
    public void test() throws IOException {
        final CompoundTag compoundTag = new CompoundTag();

        // Boolean value
        final BooleanTag booleanTag = new BooleanTag(true);
        compoundTag.put("A", booleanTag);

        // Boolean array value
        final BooleanArrayTag booleanArrayTag = new BooleanArrayTag(true, false, true, true);
        compoundTag.put("B", booleanArrayTag);

        // Byte value
        final ByteTag byteTag = new ByteTag((byte) 5);
        compoundTag.put("C", byteTag);

        // Byte array value
        final ByteArrayTag byteArrayTag = new ByteArrayTag((byte) 6, (byte) 9, (byte) 20, (byte) 30);
        compoundTag.put("D", byteArrayTag);

        // Char value
        final CharTag charTag = new CharTag('C');
        compoundTag.put("E", charTag);

        // Char array value
        final CharArrayTag charArrayTag = new CharArrayTag('A', 'B', 'C', 'D');
        compoundTag.put("F", charArrayTag);

        // Double value
        final DoubleTag doubleTag = new DoubleTag(7.3);
        compoundTag.put("G", doubleTag);

        // Double array value
        final DoubleArrayTag doubleArrayTag = new DoubleArrayTag(7.3, 7.4, 5.3, 1.2);
        compoundTag.put("H", doubleArrayTag);

        compoundTag.put("I", new FloatTag(5.1f));
        compoundTag.put("J", new FloatArrayTag(5.1f, 5.32f));
        compoundTag.put("K", new IntTag(3));
        compoundTag.put("L", new IntArrayTag(30, 50, 60, 80));
        compoundTag.put("M", new LongTag(40));
        compoundTag.put("N", new LongArrayTag(30, 60));
        compoundTag.put("O", new ShortTag((short) 3));
        compoundTag.put("P", new ShortArrayTag((short) 3, (short) 7));
        compoundTag.put("Q", new StringTag("Test"));
        compoundTag.put("R", new StringArrayTag("Haha", "Hehe", "Hoho"));
        final CompoundTag compoundTag1 = new CompoundTag();
        compoundTag1.put("A", new IntArrayTag(1000));
        compoundTag.put("S", compoundTag1);
        final ListTag<IntTag> listTag = new ListTag<>();
        listTag.add(new IntTag(20));
        listTag.add(new IntTag(30));
        compoundTag.put("T", listTag);
        final ListTag<DoubleArrayTag> listTag1 = new ListTag<>();
        listTag1.add(new DoubleArrayTag(7.3, 7.4));
        listTag1.add(new DoubleArrayTag(5.3, 1.2));
        compoundTag.put("U", listTag1);
        final MapTag<IntTag, DoubleTag> intToDoubleMapTag = new MapTag<>();
        intToDoubleMapTag.put(new IntTag(100), new DoubleTag(253.98));
        intToDoubleMapTag.put(new IntTag(20), new DoubleTag(96035.047821));
        compoundTag.put("V", intToDoubleMapTag);
        final MapTag<IntTag, CharTag> intToCharMapTag = new MapTag<>();
        intToCharMapTag.put(new IntTag(100), new CharTag('B'));
        intToCharMapTag.put(new IntTag(20), new CharTag('Q'));
        compoundTag.put("W", intToCharMapTag);
        final MapTag<IntTag, Tag<?>> intToMixedMapTag = new MapTag<>();
        intToMixedMapTag.put(new IntTag(100), new CharTag('B'));
        intToMixedMapTag.put(new IntTag(20), new StringTag("Hallo"));
        intToMixedMapTag.put(new IntTag(10), new LongTag(9L));
        intToMixedMapTag.put(new IntTag(12), new CharArrayTag('H', 'O', 'L', 'A'));
        compoundTag.put("X", intToMixedMapTag);

        final NbtTagOutputStream nos = new NbtTagOutputStream(
                new GZIPOutputStream(Files.newOutputStream(Paths.get("test.nbt"))));
        nos.write(compoundTag);
        nos.flush();
        nos.close();

        final NbtTagInputStream nis = new NbtTagInputStream(
                new GZIPInputStream(Files.newInputStream(Paths.get("test.nbt"))));
        final CompoundTag newCompoundTag = (CompoundTag) nis.read();
        System.out.println(newCompoundTag);
        nis.close();

        // Boolean value
        assertEquals(booleanTag, newCompoundTag.get("A"));
        assertEquals(booleanTag.booleanValue(), newCompoundTag.getBoolean("A"));

        // Boolean array value
        assertEquals(booleanArrayTag, newCompoundTag.get("B"));

        // Byte value
        assertEquals(byteTag, newCompoundTag.get("C"));
        assertEquals(byteTag.byteValue(), newCompoundTag.getByte("C"));

        // Byte array value
        assertEquals(byteArrayTag, newCompoundTag.get("D"));

        // Char value
        assertEquals(charTag, newCompoundTag.get("E"));
        assertEquals(charTag.charValue(), newCompoundTag.getChar("E"));

        // Char array value
        assertEquals(charArrayTag, newCompoundTag.get("F"));

        // Double value
        assertEquals(doubleTag, newCompoundTag.get("G"));
        assertEquals(doubleTag.doubleValue(), newCompoundTag.getDouble("G"), 0.00000000001);

        // Double array value
        assertEquals(doubleArrayTag, newCompoundTag.get("H"));

        // The complete compound tags
        assertEquals(compoundTag, newCompoundTag);
    }
}
```


Overlapping Code:
```
gTest {
@Test
public void test() throws IOException {
final CompoundTag compoundTag = new CompoundTag();
// Boolean value
final BooleanTag booleanTag = new BooleanTag(true);
compoundTag.put("A", booleanTag);
// Boolean array value
final BooleanArrayTag booleanArrayTag = new BooleanArrayTag(true, false, true, true);
compoundTag.put("B", booleanArrayTag);
// Byte value
final ByteTag byteTag = new ByteTag((byte) 5);
compoundTag.put("C", byteTag);
// Byte array value
final ByteArrayTag byteArrayTag = new ByteArrayTag((byte) 6, (byte) 9, (byte) 20, (byte) 30);
compoundTag.put("D", byteArrayTag);
// Char value
final CharTag charTag = new CharTag('C');
compoundTag.put("E", charTag);
// Char array value
final CharArrayTag charArrayTag = new CharArrayTag('A', 'B', 'C', 'D');
compoundTag.put("F", charArrayTag);
// Double value
final DoubleTag doubleTag = new DoubleTag(7.3);
compoundTag.put("G", doubleTag);
// Double array value
final DoubleArrayTag doubleArrayTag = new DoubleArrayTag(7.3, 7.4, 5.3, 1.2);
compoundTag.put("H", doubleArrayTag);
compoundTag.put("I", new FloatTag(5.1f));
compoundTag.put("J", new FloatArrayTag(5.1f, 5.32f));
compoundTag.put("K", new IntTag(3));
compoundTag.put("L", new IntArrayTag(30, 50, 60, 80));
compoundTag.put("M", new LongTag(40));
compoundTag.put("N", new LongArrayTag(30, 60));
compoundTag.put("O", new ShortTag((short) 3));
compoundTag.put("P", new ShortArrayTag((short) 3, (short) 7));
compoundTag.put("Q", new StringTag("Test"));
compoundTag.put("R", new StringArrayTag("Haha", "Hehe", "Hoho"));
final CompoundTag compoundTag1 = new CompoundTag();
compoundTag1.put("A", new IntArrayTag(1000));
compoundTag.put("S", compoundTag1);
final ListTag<IntTag> listTag = new ListTag<>();
listTag.add(new IntTag(20));
listTag.add(new IntTag(30));
compoundTag.put("T", listTag);
final ListTag<DoubleArrayTag> listTag1 = new ListTag<>();
listTag1.add(new DoubleArrayTag(7.3, 7.4));
listTag1.add(new DoubleArrayTag(5.3, 1.2));
compoundTag.put("U", listTag1);
final MapTag<IntTag, DoubleTag> i
```
<Overlap Ratio: 0.966618979494516>

---

--- 266 --
Question ID: 60e7f62e86111963763b8d0f2f3de50c8c0143d3
Original Code:
```
@Entity
@NamedQueries({
         @NamedQuery(name = Customer.FIND_BY_LOGIN, query = "SELECT c FROM Customer c WHERE c.login = :login"),
         @NamedQuery(name = Customer.FIND_BY_EMAIL, query = "SELECT c FROM Customer c WHERE c.email = :email"),
         @NamedQuery(name = Customer.FIND_BY_LOGIN_PASSWORD, query = "SELECT c FROM Customer c WHERE c.login = :login AND c.password = :password"),
         @NamedQuery(name = Customer.FIND_BY_UUID, query = "SELECT c FROM Customer c WHERE c.uuid = :uuid"),
         @NamedQuery(name = Customer.FIND_ALL, query = "SELECT c FROM Customer c")
})
@XmlRootElement
public class Customer implements Serializable
{

   // ======================================
   // = Attributes =
   // ======================================

   @Id
   @GeneratedValue(strategy = GenerationType.AUTO)
   @Column(name = "id", updatable = false, nullable = false)
   private Long id;
   @Version
   @Column(name = "version")
   private int version;

   @Column(length = 50, name = "first_name", nullable = false)
   @NotNull
   @Size(min = 2, max = 50)
   private String firstName;

   @Column(length = 50, name = "last_name", nullable = false)
   @NotNull
   @Size(min = 2, max = 50)
   private String lastName;

   @Column
   private String telephone;

   @Column
   @Email
   private String email;

   @Column(length = 10, nullable = false)
   @Login
   private String login;

   @Column(length = 256, nullable = false)
   @NotNull
   @Size(min = 1, max = 256)
   private String password;

   @Column(length = 256)
   @Size(min = 1, max = 256)
   private String uuid;

   private UserRole role;

   @Column(name = "date_of_birth")
   @Temporal(TemporalType.DATE)
   @Past
   private Date dateOfBirth;

   @Transient
   private Integer age;

   @Embedded
   @Valid
   private Address homeAddress = new Address();

   // ======================================
   // = Constants =
   // ======================================

   public static final String FIND_BY_LOGIN = "Customer.findByLogin";
   public static final String FIND_BY_LOGIN_PASSWORD = "Customer.findByLoginAndPassword";
   public static final String FIND_ALL = "Customer.findAll";
   public static final String FIND_BY_EMAIL = "Customer.findByEmail";
   public static final String FIND_BY_UUID = "Customer.findByUUID";

   // ======================================
   // = Constructors =
   // ======================================

   public Customer()
   {
   }

   public Customer(String firstName, String lastName, String login, String plainTextPassword, String email,
            Address address)
   {
      this.firstName = firstName;
      this.lastName = lastName;
      this.login = login;
      this.password = digestPassword(plainTextPassword);
      this.email = email;
      this.homeAddress = address;
      this.dateOfBirth = new Date();
   }

   // ======================================
   // = Lifecycle Methods =
   // ======================================

   /**
    * This method calculates the age of the customer
    */
   @PostLoad
   @PostPersist
   @PostUpdate
   public void calculateAge()
   {
      if (dateOfBirth == null)
      {
         age = null;
         return;
      }

      Calendar birth = new GregorianCalendar();
      birth.setTime(dateOfBirth);
      Calendar now = new GregorianCalendar();
      now.setTime(new Date());
      int adjust = 0;
      if (now.get(Calendar.DAY_OF_YEAR) - birth.get(Calendar.DAY_OF_YEAR) < 0)
      {
         adjust = -1;
      }
      age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR) + adjust;
   }

   @PrePersist
   private void digestPassword()
   {
      password = digestPassword(password);
   }

   // ======================================
   // = Business methods =
   // ======================================

   /**
    * Digest password with <code>SHA-256</code> then encode it with Base64.
    *
    * @param plainTextPassword the password to digest and encode
    * @return digested password
    */
   public String digestPassword(String plainTextPassword)
   {
      try
      {
         MessageDigest md = MessageDigest.getInstance("SHA-256");
         md.update(plainTextPassword.getBytes("UTF-8"));
         byte[] passwordDigest = md.digest();
         return new BASE64Encoder().encode(passwordDigest);
      }
      catch (Exception e)
      {
         throw new RuntimeException("Exception encoding password", e);
      }
   }

   // ======================================
   // = Getters & setters =
   // ======================================

   public Long getId()
   {
      return this.id;
   }

   public void setId(final Long id)
   {
      this.id = id;
   }

   public int getVersion()
   {
      return this.version;
   }

   public void setVersion(final int version)
   {
      this.version = version;
   }

   public String getLogin()
   {
      return login;
   }

   public void setLogin(String login)
   {
      this.login = login;
   }

   public UserRole getRole()
   {
      return role;
   }

   public void setRole(UserRole role)
   {
      this.role = role;
   }

   public String getUuid()
   {
      return uuid;
   }

   public void setUuid(String uuid)
   {
      this.uuid = uuid;
   }

   public String getPassword()
   {
      return password;
   }

   public void setPassword(String password)
   {
      this.password = password;
   }

   public String getFirstName()
   {
      return firstName;
   }

   public void setFirstName(String firstName)
   {
      this.firstName = firstName;
   }

   public String getLastName()
   {
      return lastName;
   }

   public void setLastName(String lastName)
   {
      this.lastName = lastName;
   }

   public String getFullName()
   {
      return firstName + " " + lastName;
   }

   public String getTelephone()
   {
      return telephone;
   }

   public void setTelephone(String telephone)
   {
      this.telephone = telephone;
   }

   public String getEmail()
   {
      return email;
   }

   public void setEmail(String email)
   {
      this.email = email;
   }

   public Date getDateOfBirth()
   {
      return dateOfBirth;
   }

   public void setDateOfBirth(Date dateOfBirth)
   {
      this.dateOfBirth = dateOfBirth;
   }

   public Integer getAge()
   {
      return age;
   }

   public Address getHomeAddress()
   {
      return homeAddress;
   }

   public void setHomeAddress(Address homeAddress)
   {
      this.homeAddress = homeAddress;
   }

   // ======================================
   // = Methods hash, equals, toString =
   // ======================================

   @Override
   public final boolean equals(Object o)
   {
      if (this == o)
         return true;
      if (!(o instanceof Customer))
         return false;
      Customer customer = (Customer) o;
      return Objects.equals(login, customer.login);
   }

   @Override
   public final int hashCode()
   {
      return Objects.hash(login);
   }

   @Override
   public String toString()
   {
      return firstName + ' ' + lastName + " (" + login + ")";
   }
}
```


Overlapping Code:
```
tity
@NamedQueries({
@NamedQuery(name = Customer.FIND_BY_LOGIN, query = "SELECT c FROM Customer c WHERE c.login = :login"),
@NamedQuery(name = Customer.FIND_BY_EMAIL, query = "SELECT c FROM Customer c WHERE c.email = :email"),
@NamedQuery(name = Customer.FIND_BY_LOGIN_PASSWORD, query = "SELECT c FROM Customer c WHERE c.login = :login AND c.password = :password"),
@NamedQuery(name = Customer.FIND_BY_UUID, query = "SELECT c FROM Customer c WHERE c.uuid = :uuid"),
@NamedQuery(name = Customer.FIND_ALL, query = "SELECT c FROM Customer c")
})
@XmlRootElement
public class Customer implements Serializable
{
// ======================================
// = Attributes =
// ======================================
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
@Column(name = "id", updatable = false, nullable = false)
private Long id;
@Version
@Column(name = "version")
private int version;
@Column(length = 50, name = "first_name", nullable = false)
@NotNull
@Size(min = 2, max = 50)
private String firstName;
@Column(length = 50, name = "last_name", nullable = false)
@NotNull
@Size(min = 2, max = 50)
private String lastName;
@Column
private String telephone;
@Column
@Email
private String email;
@Column(length = 10, nullable = false)
@Login
private String login;
@Column(length = 256, nullable = false)
@NotNull
@Size(min = 1, max = 256)
private String password;
@Column(length = 256)
@Size(min = 1, max = 256)
private String uuid;
private UserRole role;
@Column(name = "date_of_birth")
@Temporal(TemporalType.DATE)
@Past
private Date dateOfBirth;
@Transient
private Integer age;
@Embedded
@Valid
private Address homeAddress = new Address();
// ======================================
// = Constants =
// ======================================
public static final String FIND_BY_LOGIN = "Customer.findByLogin";
public static final String FIND_BY_LOGIN_PASSWORD = "Customer.findByLoginAndPassword";
public static final String FIND_ALL = "Customer.findAll";
public static final String FIND_BY_EMAIL = "Customer.findByEmail";
public static final String FIND_BY_UUID = "Customer.findByUUID";
// ======================================
// = Constructors =
// ======================================
public Customer()
{
}
public Customer(String firstName, St
```
<Overlap Ratio: 0.9969053934571176>

---

--- 267 --
Question ID: ba1a3bb4c200131d37bc07151571ef2c0b6854e5
Original Code:
```
public class TestCaseMain {

    private static final int DELAY_TIME = 50;

    private static ScriptEngine engine;

    private static ExecutionEventManager eventManager;

    /**
     * Setup test case or test suite before executing.
     *
     * CustomKeywords now has many custom keyword static methods, each one is
     * named with format [packageName].[className].[keywordName] but Groovy compiler
     * itself cannot invoke that formatted name. Therefore, we must change the
     * meta class of CustomKeywords to another one.
     * 
     * @throws IOException
     */
    public static void beforeStart() throws IOException {
        LogbackConfigurator.init();
        
        GroovyClassLoader classLoader = new GroovyClassLoader(TestCaseMain.class.getClassLoader());
        engine = ScriptEngine.getDefault(classLoader);

        // Load GlobalVariable class
//        loadGlobalVariableClass(classLoader);
//        loadInternalGlobalVariableClass(classLoader);
        loadCustomKeywordsClass(classLoader);

        eventManager = ExecutionEventManager.getInstance();
    }

    private static void loadCustomKeywordsClass(GroovyClassLoader cl) {
        // Load CustomKeywords class
        Class<?> clazz = cl.parseClass("class CustomKeywords { }");
        InvokerHelper.metaRegistry.setMetaClass(clazz, new CustomKeywordDelegatingMetaClass(clazz, cl));
    }

    private static void loadGlobalVariableClass(GroovyClassLoader cl) {
        try {
            cl.loadClass(StringConstants.GLOBAL_VARIABLE_CLASS_NAME);
        } catch (ClassNotFoundException ex) {
            try {
                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.GLOBAL_VARIABLE_FILE_NAME));
            } catch (CompilationFailedException | IOException ignored) {

            }
        }
    }
    
    private static void loadInternalGlobalVariableClass(GroovyClassLoader cl) {
        try {
            cl.loadClass(StringConstants.INTERNAL_GLOBAL_VARIABLE_CLASS_NAME);
        } catch (ClassNotFoundException ex) {
            try {
                cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.INTERNAL_GLOBAL_VARIABLE_FILE_NAME));
            } catch (CompilationFailedException | IOException ignored) {

            }
        }
    }
    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,
            FailureHandling flowControl) throws InterruptedException {
        return runTestCase(testCaseId, testCaseBinding, flowControl, true, true);
    }

    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,
            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {
        return runTestCase(testCaseId, testCaseBinding, flowControl, true, doCleanUp);
    }

    public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,
            FailureHandling flowControl, boolean isMain, boolean doCleanUp) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        InternalTestCaseContext testCaseContext = new InternalTestCaseContext(testCaseId);
        testCaseContext.setMainTestCase(isMain);
        return new TestCaseExecutor(testCaseBinding, engine, eventManager, testCaseContext, doCleanUp)
                .execute(flowControl);
    }
    
    public static TestResult runWSVerificationScript(String verificationScript, FailureHandling flowControl,
            boolean doCleanUp) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        return new WSVerificationExecutor(verificationScript, engine, eventManager, doCleanUp).execute(flowControl);
    }

    public static TestResult runWSVerificationScript(TestCaseBinding testCaseBinding, String verificationScript,
            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        return new WSVerificationExecutor(testCaseBinding, verificationScript, engine, eventManager, doCleanUp)
                .execute(flowControl);
    }

    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,
            FailureHandling flowControl) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,
                new InternalTestCaseContext(testCaseId)).execute(flowControl);
    }

    public static TestResult runFeatureFile(String featureFile) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        String verificationScript = MessageFormat
                .format("import com.kms.katalon.core.cucumber.keyword.CucumberBuiltinKeywords as CucumberKW\n" +

                        "CucumberKW.runFeatureFile(''{0}'')", featureFile);
        return new WSVerificationExecutor(verificationScript, engine, eventManager, true)
                .execute(FailureHandling.STOP_ON_FAILURE);
    }

    public static TestResult runTestCaseRawScript(String testScript, String testCaseId, TestCaseBinding testCaseBinding,
            FailureHandling flowControl, boolean doCleanUp) throws InterruptedException {
        Thread.sleep(DELAY_TIME);
        return new RawTestScriptExecutor(testScript, testCaseBinding, engine, eventManager,
                new InternalTestCaseContext(testCaseId), doCleanUp).execute(flowControl);
    }

    public static void startTestSuite(String testSuiteId, Map<String, String> suiteProperties,
            List<TestCaseBinding> testCaseBindings) {
        TestSuiteExecutor testSuiteExecutor = new TestSuiteExecutor(testSuiteId, engine, eventManager);
        testSuiteExecutor.execute(suiteProperties, testCaseBindings);
    }

    public static void invokeStartSuite(String testSuiteId) {
        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();
        testSuiteContext.setTestSuiteId(testSuiteId);
        eventManager.publicEvent(ExecutionListenerEvent.BEFORE_TEST_SUITE, new Object[] { testSuiteContext });
    }

    public static void invokeEndSuite(String testSuiteId) {
        InternalTestSuiteContext testSuiteContext = new InternalTestSuiteContext();
        testSuiteContext.setTestSuiteId(testSuiteId);

        eventManager.publicEvent(ExecutionListenerEvent.AFTER_TEST_SUITE, new Object[] { testSuiteContext });
    }

    public static ScriptEngine getScriptEngine() {
        return engine;
    }
}
```


Overlapping Code:
```
atic final int DELAY_TIME = 50;
private static ScriptEngine engine;
private static ExecutionEventManager eventManager;
/**
* Setup test case or test suite before executing.
*
* CustomKeywords now has many custom keyword static methods, each one is
* named with format [packageName].[className].[keywordName] but Groovy compiler
* itself cannot invoke that formatted name. Therefore, we must change the
* meta class of CustomKeywords to another one.
* 
* @throws IOException
*/
public static void beforeStart() throws IOException {
LogbackConfigurator.init();

GroovyClassLoader classLoader = new GroovyClassLoader(TestCaseMain.class.getClassLoader());
engine = ScriptEngine.getDefault(classLoader);
// Load GlobalVariable class
// loadGlobalVariableClass(classLoader);
// loadInternalGlobalVariableClass(classLoader);
loadCustomKeywordsClass(classLoader);
eventManager = ExecutionEventManager.getInstance();
}
private static void loadCustomKeywordsClass(GroovyClassLoader cl) {
// Load CustomKeywords class
Class<?> clazz = cl.parseClass("class CustomKeywords { }");
InvokerHelper.metaRegistry.setMetaClass(clazz, new CustomKeywordDelegatingMetaClass(clazz, cl));
}
private static void loadGlobalVariableClass(GroovyClassLoader cl) {
try {
cl.loadClass(StringConstants.GLOBAL_VARIABLE_CLASS_NAME);
} catch (ClassNotFoundException ex) {
try {
cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.GLOBAL_VARIABLE_FILE_NAME));
} catch (CompilationFailedException | IOException ignored) {
}
}
}

private static void loadInternalGlobalVariableClass(GroovyClassLoader cl) {
try {
cl.loadClass(StringConstants.INTERNAL_GLOBAL_VARIABLE_CLASS_NAME);
} catch (ClassNotFoundException ex) {
try {
cl.parseClass(new File(RunConfiguration.getProjectDir(), StringConstants.INTERNAL_GLOBAL_VARIABLE_FILE_NAME));
} catch (CompilationFailedException | IOException ignored) {
}
}
}
public static TestResult runTestCase(String testCaseId, TestCaseBinding testCaseBinding,
FailureHandling flowControl) throws InterruptedException {
return runTestCase(testCas
```
<Overlap Ratio: 0.9804575786463299>

---

--- 268 --
Question ID: d2d456aa7424232cdf56ff5880dc8e920f1cc9a1
Original Code:
```
public class AddLibraryUtility {
    static final String FILE_SUFFIX = ".jar";

    static void addLibraryRoot(File file, Library.ModifiableModel libraryModel) {
        if (file.isFile()) {
            libraryModel.addRoot(VfsUtil.getUrlForLibraryRoot(file), OrderRootType.CLASSES);
        } else {
            for (File file0 : file.listFiles()) {
                addLibraryRoot(file0, libraryModel);
            }
        }
    }

    static void addLibraryFiles(File file, Library.ModifiableModel libraryModel, String[] files) {
        List filesList = Arrays.asList(files);
        for (File file0 : file.listFiles()) {
            if (filesList.contains(extractArtifactName(file0.getName()).toLowerCase())) {
                addLibraryRoot(file0, libraryModel);
            }
        }
    }

    static String extractArtifactName(String nameWithVersion) {
        if (nameWithVersion == null) {
            return "";
        }
        nameWithVersion = nameWithVersion.trim();
        if (!nameWithVersion.endsWith(FILE_SUFFIX)){
            return nameWithVersion;
        }

        nameWithVersion = nameWithVersion.substring(0, nameWithVersion.length() - FILE_SUFFIX.length());
        int index = nameWithVersion.indexOf('.');
        if (index < 0) {
            return nameWithVersion;
        }

        String artifactName = nameWithVersion;

        int lastIndex = nameWithVersion.lastIndexOf('-');
        while (lastIndex > index) {
            nameWithVersion = nameWithVersion.substring(0, lastIndex);
            lastIndex = nameWithVersion.lastIndexOf('-');
        }

        if (lastIndex < 0) {
            return artifactName;
        }

        artifactName = nameWithVersion.substring(0, lastIndex);
        return artifactName;
    }
}
```


Overlapping Code:
```

static final String FILE_SUFFIX = ".jar";
static void addLibraryRoot(File file, Library.ModifiableModel libraryModel) {
if (file.isFile()) {
libraryModel.addRoot(VfsUtil.getUrlForLibraryRoot(file), OrderRootType.CLASSES);
} else {
for (File file0 : file.listFiles()) {
addLibraryRoot(file0, libraryModel);
}
}
}
static void addLibraryFiles(File file, Library.ModifiableModel libraryModel, String[] files) {
List filesList = Arrays.asList(files);
for (File file0 : file.listFiles()) {
if (filesList.contains(extractArtifactName(file0.getName()).toLowerCase())) {
addLibraryRoot(file0, libraryModel);
}
}
}
static String extractArtifactName(String nameWithVersion) {
if (nameWithVersion == null) {
return "";
}
nameWithVersion = nameWithVersion.trim();
if (!nameWithVersion.endsWith(FILE_SUFFIX)){
return nameWithVersion;
}
nameWithVersion = nameWithVersion.substring(0, nameWithVersion.length() - FILE_SUFFIX.length());
int index = nameWithVersion.indexOf('.');
if (index < 0) {
return nameWithVersion;
}
String artifactName = nameWithVersion;
int lastIndex = nameWithVersion.lastIndexOf('-');
while (lastIndex > index) {
nameWithVersion = nameWithVersion.substring(0, lastIndex);
lastIndex = nameWithVersion.lastIndexOf('-');
}
if (lastIndex < 0) {
return artifactName;
}
artifactName = nameWithVersion.substring(0, lastIndex);
return artifactName;

```
<Overlap Ratio: 0.9747292418772563>

---

--- 269 --
Question ID: 2bf17f18f2f76831470d2da405d6882568857c00
Original Code:
```
public class TypesTest {
    @Test
    public void shouldBuildABasic200OKResponse() {
        Response response = Types.ok(1);

        assertEquals("200 OK", response.status());
        assertEquals("1", response.headers().get("Content-Length"));
        assertEquals("text/plain; charset=utf-8", response.headers().get("Content-Type"));

    }

    @Test
    public void shouldBuildA301MovedPermanentlyResponse() {
        Response response = Types.movedPermanently("localhost", "/new-location");

        assertEquals("301 Moved Permanently", response.status());
        assertEquals("http://localhost/new-location", response.headers().get("Location"));
    }

    @Test
    public void shouldBuildA400BadRequestResponse() {
        Response response = Types.badRequest();

        assertEquals("400 Bad Request", response.status());
    }

    @Test
    public void shouldBuildA404NotFoundResponse() {
        Response response = Types.notFound();

        assertEquals("404 Not Found", response.status());
    }

    @Test
    public void shouldBuildA405NotAllowedResponse() {
        Response response = Types.methodNotAllowed("GET, HEAD");

        assertEquals("405 Method Not Allowed", response.status());
        assertEquals("GET, HEAD", response.headers().get("Allow"));
    }

    @Test
    public void shouldBuildA500InternalServerErrorResponse() {
        Response response = Types.internalServerError();

        assertEquals("500 Internal Server Error", response.status());
    }
}
```


Overlapping Code:
```
class TypesTest {
@Test
public void shouldBuildABasic200OKResponse() {
Response response = Types.ok(1);
assertEquals("200 OK", response.status());
assertEquals("1", response.headers().get("Content-Length"));
assertEquals("text/plain; charset=utf-8", response.headers().get("Content-Type"));
}
@Test
public void shouldBuildA301MovedPermanentlyResponse() {
Response response = Types.movedPermanently("localhost", "/new-location");
assertEquals("301 Moved Permanently", response.status());
assertEquals("http://localhost/new-location", response.headers().get("Location"));
}
@Test
public void shouldBuildA400BadRequestResponse() {
Response response = Types.badRequest();
assertEquals("400 Bad Request", response.status());
}
@Test
public void shouldBuildA404NotFoundResponse() {
Response response = Types.notFound();
assertEquals("404 Not Found", response.status());
}
@Test
public void shouldBuildA405NotAllowedResponse() {
Response response = Types.methodNotAllowed("GET, HEAD");
assertEquals("405 Method Not Allowed", response.status());
assertEquals("GET, HEAD", response.headers().get("Allow"));
}
@Test
public void shouldBuildA500InternalServerErrorResponse() {
Response response = Types.internalServerError();
assertEquals("500 Internal Server Er
```
<Overlap Ratio: 0.9720062208398134>

---

--- 270 --
Question ID: 4bb7b0b33f43a1a96775422655b795aa952466a5
Original Code:
```
public class RecentChanges extends AbstractSpecialPage {

  /**
   * We don't actually do 'recent' in terms of date as that's less useful.
   */
  static final long RECENT_CHANGES_DEFAULT_HISTORY_SIZE = 50;
  static final long RECENT_CHANGES_MAX_HISTORY_SIZE = 250;
  
  private static final Predicate<ChangeInfo> MAJOR_ONLY = new Predicate<ChangeInfo>() {
    public Boolean transform(final ChangeInfo in) {
      return !in.isMinorEdit();
    }
  };

  private final PageStore _store;
  private final FeedWriter _feedWriter;
  private final WikiUrls _wikiUrls;
  private final WikiConfiguration _configuration;

  public RecentChanges(final WikiConfiguration configuration, final DefaultPage defaultPage, final CachingPageStore store, final FeedWriter feedWriter, final WikiUrls wikiUrls) {
    super(defaultPage);
    _configuration = configuration;
    _store = store;
    _feedWriter = feedWriter;
    _wikiUrls = wikiUrls;
  }

  @Override
  public View get(PageReference page, ConsumedPath path, HttpServletRequest request, HttpServletResponse response) throws Exception {
    final boolean showMinor = request.getParameter("showMinor") != null;
    final List<ChangeInfo> recentChanges = getRecentChanges(getLimit(request), showMinor);
    request.setAttribute("recentChanges", recentChanges);
    if (ViewTypeConstants.is(request, CTYPE_ATOM)) {
      return new FeedView(_configuration, _feedWriter, recentChanges, _wikiUrls.feed(URLOutputFilter.NULL));
    }
    return new JspView("RecentChanges");
  }

  private Long getLimit(HttpServletRequest request) throws InvalidInputException {
    Long limit = RequestParameterReaders.getLong(request, "limit");
    if (limit == null) {
      limit = RECENT_CHANGES_DEFAULT_HISTORY_SIZE;
    }
    limit = Math.min(limit, RECENT_CHANGES_MAX_HISTORY_SIZE);
    return limit;
  }

  private List<ChangeInfo> getRecentChanges(final long limit, final boolean showMinor) throws PageStoreException {
    return list(filter(_store.recentChanges(limit), showMinor ? Predicates.<ChangeInfo>all() : MAJOR_ONLY));
  }

  public String getName() {
    return "RecentChanges";
  }

}
```


Overlapping Code:
```
es extends AbstractSpecialPage {
/**
* We don't actually do 'recent' in terms of date as that's less useful.
*/
static final long RECENT_CHANGES_DEFAULT_HISTORY_SIZE = 50;
static final long RECENT_CHANGES_MAX_HISTORY_SIZE = 250;

private static final Predicate<ChangeInfo> MAJOR_ONLY = new Predicate<ChangeInfo>() {
public Boolean transform(final ChangeInfo in) {
return !in.isMinorEdit();
}
};
private final PageStore _store;
private final FeedWriter _feedWriter;
private final WikiUrls _wikiUrls;
private final WikiConfiguration _configuration;
public RecentChanges(final WikiConfiguration configuration, final DefaultPage defaultPage, final CachingPageStore store, final FeedWriter feedWriter, final WikiUrls wikiUrls) {
super(defaultPage);
_configuration = configuration;
_store = store;
_feedWriter = feedWriter;
_wikiUrls = wikiUrls;
}
@Override
public View get(PageReference page, ConsumedPath path, HttpServletRequest request, HttpServletResponse response) throws Exception {
final boolean showMinor = request.getParameter("showMinor") != null;
final List<ChangeInfo> recentChanges = getRecentChanges(getLimit(request), showMinor);
request.setAttribute("recentChanges", recentChanges);
if (ViewTypeConstants.is(request, CTYPE_ATOM)) {
return new FeedView(_configuration, _feedWriter, recentChanges, _wikiUrls.feed(URLOutputFilter.NULL));
}
return new JspView("RecentChanges");
}
private Long getLimit(HttpServletRequest request) throws InvalidInputException {
Long limit = RequestParameterReaders.getLong(request, "limit");
if (limit == null) {
limit = RECENT_CHANGES_DEFAULT_HISTORY_SIZE;
}
limit = Math.min(limit, RECENT_CHANGES_MAX_HISTORY_SIZE);
return limit;
}
private List<ChangeInfo> getRecentChanges(final long limit, final boolean showMinor) throws PageStoreException {
return list(filter(_store.recentChanges(limit), showMinor ? Predicates.<ChangeInfo>all() : MAJOR_ONLY));
}
public
```
<Overlap Ratio: 0.9639776763064434>

---

--- 271 --
Question ID: 2f2a3a4c61d42bfa8e018fbc184672a21036ac3c
Original Code:
```
@JEIPlugin
public class SoundMufflerJEIPlugin implements IModPlugin {

    @Override
    public void register (IModRegistry registry) {
        Block block = SuperSoundMuffler.blockSoundMuffler;
        registry.addIngredientInfo(new ItemStack(SuperSoundMuffler.blockSoundMuffler, 1), ItemStack.class,"jei." + block.getUnlocalizedName());

        Item item = SuperSoundMuffler.itemSoundMufflerBauble;
        registry.addIngredientInfo(new ItemStack(item, 1), ItemStack.class,"jei." + item.getUnlocalizedName());
    }
}
```


Overlapping Code:
```
ass SoundMufflerJEIPlugin implements IModPlugin {
@Override
public void register (IModRegistry registry) {
Block block = SuperSoundMuffler.blockSoundMuffler;
registry.addIngredientInfo(new ItemStack(SuperSoundMuffler.blockSoundMuffler, 1), ItemStack.class,"jei." + block.getUnlocalizedName());
Item item = SuperSoundMuffler.itemSoundMufflerBauble;
registry.addIngredientInfo(new ItemStack(item, 1), ItemStack.class,"jei." + item.getUnlocalizedName())
```
<Overlap Ratio: 0.9473684210526315>

---

--- 272 --
Question ID: 67a8266acd0822f3d2b268eb97986ed1ad00c464
Original Code:
```
class Utils {
    static void main() {
        A a = new A();
        a.a = 248;
        a.b = 233;
        a.printIntegersBetweenTwoValues();
        a.printDivisorsOfA();
        a.printPrimeDivisorsOfB();
        System.out.println(String.format("The most frequent digit of b (%d) is: %d", a.b, a.getTheMostFrequentDigitOfB()));

        B b = new B();
        b._a(-100, 100);
        b._b(Integer.MIN_VALUE, Integer.MAX_VALUE);
        b.printThreeRandomIntegersBetweenTwoValues();
        b.printThreeMultiplesOfA();
        b.printEveryIntegerCreatedFromTheDigitsOfB();
        b.getMaximumDigitOfB();
    }
}
```


Overlapping Code:
```
);
a.a = 248;
a.b = 233;
a.printIntegersBetweenTwoValues();
a.printDivisorsOfA();
a.printPrimeDivisorsOfB();
System.out.println(String.format("The most frequent digit of b (%d) is: %d", a.b, a.getTheMostFrequentDigitOfB()));
B b = new B();
b._a(-100, 100);
b._b(Integer.MIN_VALUE, Integer.MAX_VALUE);
b.printThreeRandomIntegersBetweenTwoValues();
b.printThreeMultiplesOfA();
b.printEveryIntegerCreate
```
<Overlap Ratio: 0.8080808080808081>

---

--- 273 --
Question ID: e854fd0b23c578a892d03de494d8765675941309
Original Code:
```
@ApiModel(description = "")
public class WsdlDTO  {
  
  
  @NotNull
  private String name = null;
  
  
  private String wsdlDefinition = null;

  
  /**
   **/
  @ApiModelProperty(required = true, value = "")
  @JsonProperty("name")
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }

  
  /**
   **/
  @ApiModelProperty(value = "")
  @JsonProperty("wsdlDefinition")
  public String getWsdlDefinition() {
    return wsdlDefinition;
  }
  public void setWsdlDefinition(String wsdlDefinition) {
    this.wsdlDefinition = wsdlDefinition;
  }

  

  @Override
  public String toString()  {
    StringBuilder sb = new StringBuilder();
    sb.append("class WsdlDTO {\n");
    
    sb.append("  name: ").append(name).append("\n");
    sb.append("  wsdlDefinition: ").append(wsdlDefinition).append("\n");
    sb.append("}\n");
    return sb.toString();
  }
}
```


Overlapping Code:
```
(description = "")
public class WsdlDTO {


@NotNull
private String name = null;


private String wsdlDefinition = null;

/**
**/
@ApiModelProperty(required = true, value = "")
@JsonProperty("name")
public String getName() {
return name;
}
public void setName(String name) {
this.name = name;
}

/**
**/
@ApiModelProperty(value = "")
@JsonProperty("wsdlDefinition")
public String getWsdlDefinition() {
return wsdlDefinition;
}
public void setWsdlDefinition(String wsdlDefinition) {
this.wsdlDefinition = wsdlDefinition;
}

@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class WsdlDTO {\n");

sb.append(" name: ").append(name).append("\n");
sb.append(" wsdlDefinition: ").append(wsdlDefinition).append("\n");
sb.append("}\n");
return sb.toString();
}
}
```
<Overlap Ratio: 0.9887640449438202>

---

--- 274 --
Question ID: 3b56464494cf915749fe88f0e13f48efa582dfef
Original Code:
```
public class Textures {

  public static void upload(BufferedImage img, int format, int tex) {
    int width = img.getWidth();
    int height = img.getHeight();
    if (Visage.trace)
      Visage.log.finest(
          "Uploading " + width + "x" + height + " (" + (width * height) + " pixel) image");

    BufferedImage unindexed = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

    int[] argb = new int[width * height];
    img.getRGB(0, 0, width, height, argb, 0, width);

    unindexed.setRGB(0, 0, width, height, argb, 0, width);
    unindexed.coerceData(true);
    unindexed.getRGB(0, 0, width, height, argb, 0, width);

    IntBuffer buf = BufferUtils.createIntBuffer(width * height);
    buf.put(argb);
    buf.flip();

    glBindTexture(GL_TEXTURE_2D, tex);
    glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, buf);

    checkGLError();
  }
}
```


Overlapping Code:
```

public static void upload(BufferedImage img, int format, int tex) {
int width = img.getWidth();
int height = img.getHeight();
if (Visage.trace)
Visage.log.finest(
"Uploading " + width + "x" + height + " (" + (width * height) + " pixel) image");
BufferedImage unindexed = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
int[] argb = new int[width * height];
img.getRGB(0, 0, width, height, argb, 0, width);
unindexed.setRGB(0, 0, width, height, argb, 0, width);
unindexed.coerceData(true);
unindexed.getRGB(0, 0, width, height, argb, 0, width);
IntBuffer buf = BufferUtils.createIntBuffer(width * height);
buf.put(argb);
buf.flip();
glBindTexture(GL_TEXTURE_2D, tex);
glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_BGRA, GL_UNSIGNED_BYTE, buf);
checkGLError();
```
<Overlap Ratio: 0.9668711656441717>

---

--- 275 --
Question ID: a147692ec63231ffaccb5802b20459728690725b
Original Code:
```
@SuppressWarnings({"unchecked", "rawtypes"})
public class IntervalAnalysisStateTest {

  @Test
  public void pseudoPartiotionKey() {
    IntervalAnalysisState s = new IntervalAnalysisState();
    IntervalAnalysisState sa1 = s.addInterval("a", new Interval(1L, 1L), 10);
    IntervalAnalysisState sb2 = s.addInterval("b", new Interval(2L, 2L), 10);
    IntervalAnalysisState sa1b2 = sa1.addInterval("b", new Interval(2L, 2L), 10);
    IntervalAnalysisState sa1b3 = sa1.addInterval("b", new Interval(3L, 3L), 10);
    IntervalAnalysisState sa1b23 = sa1.addInterval("b", new Interval(2L, 3L), 10);

    Comparable cs = s.getPseudoPartitionKey();
    Comparable csa1 = sa1.getPseudoPartitionKey();
    Comparable csb2 = sb2.getPseudoPartitionKey();
    Comparable csa1b2 = sa1b2.getPseudoPartitionKey();
    Comparable csa1b3 = sa1b3.getPseudoPartitionKey();
    Comparable csa1b23 = sa1b23.getPseudoPartitionKey();

    checkEquals(cs, cs);
    checkEquals(csa1, csa1);
    checkEquals(csb2, csb2);
    checkEquals(csa1b2, csa1b2);
    checkEquals(csa1b3, csa1b3);
    checkEquals(csa1b23, csa1b23);

    checkEquals(csa1, csb2);
    checkEquals(csa1b2, csa1b3);

    checkLess(cs, csa1);
    checkLess(cs, csb2);
    checkLess(cs, csa1b2);
    checkLess(cs, csa1b3);
    checkLess(csa1, csa1b2);
    checkLess(csa1, csa1b3);
    checkLess(csb2, csa1b2);

    checkLess(csa1, csa1b23);
    checkLess(csb2, csa1b23);
    checkLess(csa1b23, csa1b2);
    checkLess(csa1b23, csa1b3);
  }

  private void checkLess(Comparable c1, Comparable c2) {
    assertThat(c1.compareTo(c2) < 0).isTrue();
    assertThat(c2.compareTo(c1) > 0).isTrue();
  }

  private void checkEquals(Comparable c1, Comparable c2) {
    assertThat(c1.compareTo(c2)).isEqualTo(0);
    assertThat(c2.compareTo(c1)).isEqualTo(0);
  }
}
```


Overlapping Code:
```
@SuppressWarnings({"unchecked", "rawtypes"})
public class IntervalAnalysisStateTest {
@Test
public void pseudoPartiotionKey() {
IntervalAnalysisState s = new IntervalAnalysisState();
IntervalAnalysisState sa1 = s.addInterval("a", new Interval(1L, 1L), 10);
IntervalAnalysisState sb2 = s.addInterval("b", new Interval(2L, 2L), 10);
IntervalAnalysisState sa1b2 = sa1.addInterval("b", new Interval(2L, 2L), 10);
IntervalAnalysisState sa1b3 = sa1.addInterval("b", new Interval(3L, 3L), 10);
IntervalAnalysisState sa1b23 = sa1.addInterval("b", new Interval(2L, 3L), 10);
Comparable cs = s.getPseudoPartitionKey();
Comparable csa1 = sa1.getPseudoPartitionKey();
Comparable csb2 = sb2.getPseudoPartitionKey();
Comparable csa1b2 = sa1b2.getPseudoPartitionKey();
Comparable csa1b3 = sa1b3.getPseudoPartitionKey();
Comparable csa1b23 = sa1b23.getPseudoPartitionKey();
checkEquals(cs, cs);
checkEquals(csa1, csa1);
checkEquals(csb2, csb2);
checkEquals(csa1b2, csa1b2);
checkEquals(csa1b3, csa1b3);
checkEquals(csa1b23, csa1b23);
checkEquals(csa1, csb2);
checkEquals(csa1b2, csa1b3);
checkLess(cs, csa1);
checkLess(cs, csb2);
checkLess(cs, csa1b2);
checkLess(cs, csa1b3);
checkLess(csa1, csa1b2);
checkLess(csa1, csa1b3);
checkLess(csb2, csa1b2);
checkLess(csa1, csa1b23);
checkLess(csb2, csa1b23);
checkLess(csa1b23, csa1b2);
checkLess(csa1b23, csa1b3);
}
private void checkLess(Comparable c1, Comparable c2) {
assertThat(c1.compareTo(c2) < 0).isTrue();
assertThat(c2.compareTo(c1) > 0).isTrue();
}
private void checkEquals(Comparable c1, Comparable c2) {
assertThat(c1.compareTo(c2)).isEqualTo(0);
assertThat(c2.compareTo
```
<Overlap Ratio: 0.9859241126070991>

---

--- 276 --
Question ID: 8b8a0fdc9e2e5176fb105c18f63471f88ae8c642
Original Code:
```
public final class DeadlockGlobalCache implements IDeadlockGlobalCacheSubmitter, IDeadlockGlobalCache {

    private final ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache;

    private final ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache;

    @SuppressWarnings({"unused", "FieldCanBeLocal"})
    private final DeadlockCollector fileCollector;

    private final IDeadlockCollectBindingResolver resolver;


    static DeadlockGlobalCache
    create(IDeadlockCollectBindingResolver resolver, ICachingStrategy.ICachingStrategyCreator<ICacheEntry, IThreadEntry> strategyCreator) {

        ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache = JctraceUtil.uncheckedCast(
            strategyCreator.apply(e -> new LockCacheEntry((ILockThreadEntry) e)));
        ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache = JctraceUtil.uncheckedCast(
            strategyCreator.apply(e -> new FieldCacheEntry((IFieldThreadEntry) e)));

        return new DeadlockGlobalCache(resolver, lockCache, fieldCache);
    }

    private DeadlockGlobalCache(IDeadlockCollectBindingResolver resolver,
                                ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache,
                                ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache) {
        this.resolver = resolver;
        this.lockCache = lockCache;
        this.fieldCache = fieldCache;
        this.fileCollector = new DeadlockCollector(resolver);

    }

    @Override
    public void waitForProcessing() {
    }

    @Nullable
    @Override
    public ILockCacheEntry getLockCacheEntryForThreadUnsafe(ILockThreadEntry threadEntry) {
        return lockCache.getCacheEntryUnsafe(threadEntry);
    }

    @Override
    public void newLockMonitorEnter(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {
        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);
        lockEntry.updateLockCacheEntry(resolver, lockThreadEntry, heldLocks);

    }

    @Override
    public void newFieldGet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {
        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);
        fieldEntry.fieldGetCacheEntry(resolver, fieldThreadEntry, heldLocks);
    }

    @Override
    public void newFieldSet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {
        FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);
        fieldEntry.fieldSetCacheEntry(resolver, fieldThreadEntry, heldLocks);
    }

    @Override
    public void newLockCreated(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {
        LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);
        lockEntry.newLockCreatedCacheEntry(resolver, lockThreadEntry, heldLocks);
    }

    @Override
    public List<ILockCacheEntry> getLockEntries() {
        return lockCache.getEntries();
    }

    @Override
    public List<IFieldCacheEntry> getFieldEntries() {
        return fieldCache.getEntries();
    }

    @Override
    public List<ILockCacheEntry> getLockEntriesExpungeStallEntries() {
        return lockCache.getEntriesExpungeStallEntries();
    }

    @Override
    public List<IFieldCacheEntry> getFieldEntriesExpungeStallEntries() {
        return fieldCache.getEntriesExpungeStallEntries();
    }


    @ThreadSafe
    static final class LockCacheEntry extends AbstractCacheEntry implements ILockCacheEntry {
        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);

        private final String lockClass;

        @GuardedBy("this")
        private long lockedCount = 0;

        @GuardedBy("this")
        private final TIntSet dependentLocks = new TIntHashSet();


        LockCacheEntry(ILockThreadEntry entry) {
            super(globalIdCounter.incrementAndGet());
            requireNonNull(entry);
            Object lock = entry.getLock();
            requireNonNull(lock);
            if (lock instanceof Class) {
                Class<?> clazz = (Class<?>) lock;
                lockClass = "(ClassLock) " + clazz.getName();
            } else {
                lockClass = lock.getClass().getName();
            }

        }

        protected ISerializableData createSerObjInternal(int revision) {
            return new LockCacheEntrySer(this, revision);
        }

        void newLockCreatedCacheEntry(IDeadlockCollectBindingResolver resolver,
                                      ILockThreadEntry lockThreadEntry,
                                      ILockThreadEntry[] heldLocks) {
            synchronized (this) {
                setChangedSinceLastSnapshot();
                int locationId = lockThreadEntry.getLocationId();
                int threadId = lockThreadEntry.getThreadId();
                boolean newLocationAdded = addLocationId(locationId);
                if (newLocationAdded) {
                    checkNewLocationForStacktracing(resolver, locationId);
                }
                addThreadId(threadId);
            }
        }

        void updateLockCacheEntry(IDeadlockCollectBindingResolver resolver,
                                  ILockThreadEntry lockThreadEntry,
                                  ILockThreadEntry[] heldLocks) {
            synchronized (this) {
                setChangedSinceLastSnapshot();
                int locationId = lockThreadEntry.getLocationId();
                int threadId = lockThreadEntry.getThreadId();
                boolean newLocationAdded = addLocationId(locationId);
                if (newLocationAdded) {
                    checkNewLocationForStacktracing(resolver, locationId);
                }
                addThreadId(threadId);
                incrementLockCount();
                TIntList dependentLocksLst = addDependentLocks(resolver, lockThreadEntry, heldLocks);
                addStackEntry(locationId, threadId, dependentLocksLst);
            }
        }

        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {

            TIntList dependentLocks = null;
            if (isStackCapturingEnabled()) {
                dependentLocks = new TIntArrayList();
            }
            for (ILockThreadEntry lockThObj : heldLocks) {
                if (lockThObj == null) {
                    continue;
                }
                if (lockThObj == lockThreadEntry) {
                    continue;
                }
                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);
                if (lockEntry == null) {
                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);
                    throw new IllegalStateException("There must be a ILockCacheEntry for the lock " + lockThObj + " second try " + lockEntry2);
                }
                addDependentLocks(lockEntry);
                if (isStackCapturingEnabled()) {
                    requireNonNull(dependentLocks).add(lockEntry.getId());
                }
            }
            return dependentLocks;
        }

        private void incrementLockCount() {
            lockedCount++;
        }

        private void addDependentLocks(ILockCacheEntry lock) {
            dependentLocks.add(lock.getId());
        }

        @Override
        public boolean hasDependentLock(ILockCacheEntry lock) {
            return hasDependentLock(lock.getId());
        }

        @Override
        public boolean hasDependentLock(int lockId) {
            synchronized (this) {
                return dependentLocks.contains(lockId);
            }
        }

        @Override
        public int compareTo(@Nonnull ILockCacheEntry o) {
            int id1 = this.getId();
            int id2 = o.getId();
            return Integer.compare(id1, id2);
        }

        @Override
        public long getLockedCount() {
            return lockedCount;
        }

        @Override
        public String getLockClass() {
            return lockClass;
        }

        @Override
        public int[] getDependentLocks() {
            synchronized (this) {
                return dependentLocks.toArray();
            }
        }

        @Override
        public String toString() {
            return "LockCacheEntry [id=" + getId() + ", lockClass=" + lockClass + ", lockedCount=" + lockedCount + "]";
        }

    }


    @ThreadSafe
    static final class FieldCacheEntry extends AbstractCacheEntry implements IFieldCacheEntry {
        private static final AtomicInteger globalIdCounter = new AtomicInteger(0);

        private final int fieldDescriptorId;

        @GuardedBy("this")
        private long readCount = 0;

        @GuardedBy("this")
        private long writeCount = 0;

        private final int ownerIdentityHash;

        FieldCacheEntry(IFieldThreadEntry entry) {
            super(globalIdCounter.incrementAndGet());

            requireNonNull(entry);
            Object owner = entry.getOwner();
            requireNonNull(owner);
            ownerIdentityHash = System.identityHashCode(owner);
            fieldDescriptorId = entry.getFieldDescriptorId();
        }

        protected ISerializableData createSerObjInternal(int revision) {
            return new FieldCacheEntrySer(this, revision);
        }

        void fieldGetCacheEntry(IDeadlockCollectBindingResolver resolver,
                                IFieldThreadEntry fieldThreadEntry,
                                ILockThreadEntry[] heldLocks) {
            synchronized (this) {
                fieldUsage(resolver, fieldThreadEntry, heldLocks);
                this.incrementReadCount();
            }
        }

        void fieldSetCacheEntry(IDeadlockCollectBindingResolver resolver,
                                IFieldThreadEntry fieldThreadEntry,
                                ILockThreadEntry[] heldLocks) {
            synchronized (this) {
                fieldUsage(resolver, fieldThreadEntry, heldLocks);
                this.incrementWriteCount();
            }
        }

        private void fieldUsage(IDeadlockCollectBindingResolver resolver, IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {
            setChangedSinceLastSnapshot();
            int locationId = fieldThreadEntry.getLocationId();
            int threadId = fieldThreadEntry.getThreadId();
            boolean newLocationAdded = addLocationId(locationId);
            if (newLocationAdded) {
                checkNewLocationForStacktracing(resolver, locationId);
            }
            addThreadId(threadId);
            TIntList dependentLocksList = addDependentLocks(resolver, heldLocks);
            addStackEntry(locationId, threadId, dependentLocksList);
        }

        private TIntList addDependentLocks(IDeadlockCollectBindingResolver resolver, ILockThreadEntry[] heldLocks) {

            TIntList dependentLocks = null;
            if (isStackCapturingEnabled()) {
                dependentLocks = new TIntArrayList();
            }
            for (ILockThreadEntry lockThObj : heldLocks) {
                if (lockThObj == null) {
                    continue;
                }
                ILockCacheEntry lockEntry = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);
                if (lockEntry == null) {
                    ILockCacheEntry lockEntry2 = resolver.getLockCache().getLockCacheEntryForThreadUnsafe(lockThObj);
                    throw new IllegalStateException("There must be a ILockCacheEntry for the lock " + lockThObj + " second try " + lockEntry2);
                }
                //addDependentLocks(lockEntry);
                if (isStackCapturingEnabled()) {
                    requireNonNull(dependentLocks).add(lockEntry.getId());
                }
            }
            return dependentLocks;
        }

        private void incrementWriteCount() {
            writeCount++;
        }

        private void incrementReadCount() {
            readCount++;
        }

        @Override
        public int compareTo(@Nonnull IFieldCacheEntry o) {
            int id1 = this.getId();
            int id2 = o.getId();
            return Integer.compare(id1, id2);
        }


        @Override
        public int getFieldDescriptorId() {
            return fieldDescriptorId;
        }

        @Override
        public long getReadCount() {
            synchronized (this) {
                return readCount;
            }
        }

        @Override
        public long getWriteCount() {
            synchronized (this) {
                return writeCount;
            }
        }

        public int getOwnerIdentityHash() {
            return ownerIdentityHash;
        }

        @Override
        public String toString() {
            return "FieldCacheEntry [id=" + getId() + ", fieldDescriptorId=" + fieldDescriptorId + "]";
        }

    }

}
```


Overlapping Code:
```
public final class DeadlockGlobalCache implements IDeadlockGlobalCacheSubmitter, IDeadlockGlobalCache {
private final ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache;
private final ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache;
@SuppressWarnings({"unused", "FieldCanBeLocal"})
private final DeadlockCollector fileCollector;
private final IDeadlockCollectBindingResolver resolver;
static DeadlockGlobalCache
create(IDeadlockCollectBindingResolver resolver, ICachingStrategy.ICachingStrategyCreator<ICacheEntry, IThreadEntry> strategyCreator) {
ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache = JctraceUtil.uncheckedCast(
strategyCreator.apply(e -> new LockCacheEntry((ILockThreadEntry) e)));
ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache = JctraceUtil.uncheckedCast(
strategyCreator.apply(e -> new FieldCacheEntry((IFieldThreadEntry) e)));
return new DeadlockGlobalCache(resolver, lockCache, fieldCache);
}
private DeadlockGlobalCache(IDeadlockCollectBindingResolver resolver,
ICachingStrategy<ILockCacheEntry, ILockThreadEntry> lockCache,
ICachingStrategy<IFieldCacheEntry, IFieldThreadEntry> fieldCache) {
this.resolver = resolver;
this.lockCache = lockCache;
this.fieldCache = fieldCache;
this.fileCollector = new DeadlockCollector(resolver);
}
@Override
public void waitForProcessing() {
}
@Nullable
@Override
public ILockCacheEntry getLockCacheEntryForThreadUnsafe(ILockThreadEntry threadEntry) {
return lockCache.getCacheEntryUnsafe(threadEntry);
}
@Override
public void newLockMonitorEnter(ILockThreadEntry lockThreadEntry, ILockThreadEntry[] heldLocks) {
LockCacheEntry lockEntry = (LockCacheEntry) lockCache.getCacheEntryOrCreate(lockThreadEntry);
lockEntry.updateLockCacheEntry(resolver, lockThreadEntry, heldLocks);
}
@Override
public void newFieldGet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {
FieldCacheEntry fieldEntry = (FieldCacheEntry) fieldCache.getCacheEntryOrCreate(fieldThreadEntry);
fieldEntry.fieldGetCacheEntry(resolver, fieldThreadEntry, heldLocks);
}
@Override
public void newFieldSet(IFieldThreadEntry fieldThreadEntry, ILockThreadEntry[] heldLocks) {
Fiel
```
<Overlap Ratio: 0.9917845732542219>

---

--- 277 --
Question ID: d4cf654c76f1480cfb73edb861dd43f6b35a7a4e
Original Code:
```
public class FindMode {

    private static void recursion(TreeNode root, Map<Integer, Integer> m, int maxCount) {
        if (root == null) return;
        m.put(root.val, 1 + m.getOrDefault(root.val, 0));
        recursion(root.left, m, maxCount);
        recursion(root.right, m, maxCount);
    }

    private static int[] findMode(TreeNode root) {
        int maxCount = 0;
        Map<Integer, Integer> m = new HashMap<>();
        recursion(root, m, maxCount);
        List<Integer> r = new ArrayList<>();
        for (Integer k: m.keySet()) {
            if (m.get(k) > maxCount) {
                maxCount = m.get(k);
            }
        }
        for (Integer k: m.keySet()) {
            if (m.get(k) == maxCount) {
                r.add(k);
            }
        }
        int[] result = new int[r.size()];
        for (int i=0; i<r.size(); i++) {
            result[i] = r.get(i);
        }
        return result;
    }

}
```


Overlapping Code:
```
lass FindMode {
private static void recursion(TreeNode root, Map<Integer, Integer> m, int maxCount) {
if (root == null) return;
m.put(root.val, 1 + m.getOrDefault(root.val, 0));
recursion(root.left, m, maxCount);
recursion(root.right, m, maxCount);
}
private static int[] findMode(TreeNode root) {
int maxCount = 0;
Map<Integer, Integer> m = new HashMap<>();
recursion(root, m, maxCount);
List<Integer> r = new ArrayList<>();
for (Integer k: m.keySet()) {
if (m.get(k) > maxCount) {
maxCount = m.get(k);
}
}
for (Integer k: m.keySet()) {
if (m.get(k) == maxCount) {
r.add(k);
}
}
int[] result = new int[r.size()];
for (int i=0; i<r.size(); i++) {
result[i] = r.get(i);
}
return result
```
<Overlap Ratio: 0.9813486370157819>

---

--- 278 --
Question ID: 8f1cbe4e99b1e50af407273513a48899c4741802
Original Code:
```
class Test {

    public static void main(String[] args) {
        final String s = "text";
        <selection>class A {
            {
                System.out.println(s);
            }
        }</selection>
    }
}
```


Overlapping Code:
```
class Test {
public static void main(String[] args) {
final String s = "text";
<selection>class A {
{
System.out.pr
```
<Overlap Ratio: 0.7986111111111112>

---

--- 279 --
Question ID: eaf86dd552a96231f8247577e3bcb7ce1ddd7801
Original Code:
```
public class PressureSensor extends Subsystem {
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public PressureSensor() {

    }

    private double pressure;
    private final double supplyVoltage = 5;
    private final double requiredToClimb = 45;

    public void findPressure() {
        // apply a formula for turning voltage to psi value
        // 250 (voltageOut/supplyVoltage) - 25
        pressure = 250 * (RobotMap.pressureSensor.getAverageVoltage() / supplyVoltage) - 25;
    }
    public double getPressure() {
        findPressure();
        return pressure;
    }
    public boolean canClimb() {
        return getPressure() > requiredToClimb;
    }

    @Override
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}
```


Overlapping Code:
```
ensor extends Subsystem {
// Put methods for controlling this subsystem
// here. Call these from Commands.
public PressureSensor() {
}
private double pressure;
private final double supplyVoltage = 5;
private final double requiredToClimb = 45;
public void findPressure() {
// apply a formula for turning voltage to psi value
// 250 (voltageOut/supplyVoltage) - 25
pressure = 250 * (RobotMap.pressureSensor.getAverageVoltage() / supplyVoltage) - 25;
}
public double getPressure() {
findPressure();
return pressure;
}
public boolean canClimb() {
return getPressure() > requiredToClimb;
}
@Override
public void initDefaultCommand() {
// Set the default command for a subsystem here.
// setDefaultCommand(new MySpecialCommand());
}
}
```
<Overlap Ratio: 0.9706666666666667>

---

--- 280 --
Question ID: e523a965e47b47658d479973dfd371d024212b45
Original Code:
```
public class SelectDSL<TYPE> {

    private final SliceQueryExecutor sliceQueryExecutor;
    private final Class<TYPE> entityClass;
    private final EntityMeta meta;
    private final SliceType sliceType;

    protected SelectDSL(SliceQueryExecutor sliceQueryExecutor, Class<TYPE> entityClass, EntityMeta meta, SliceType sliceType) {
        this.sliceQueryExecutor = sliceQueryExecutor;
        this.entityClass = entityClass;
        this.meta = meta;
        this.sliceType = sliceType;
    }

    /**
     *
     * Start the Select DSL with provided partition components
     *
     * <pre class="code"><code class="java">
     *
     *  manager.sliceQuery(ArticleRating.class)
     *      .forSelect()
     *      .withPartitionComponents(articleId)
     *
     * </code></pre>
     *
     * Generated CQL3 query:
     *
     * <br/>
     *  SELECT * FROM article_rating WHERE article_id=...
     *
     * @return slice DSL
     */
    public SelectFromPartition<TYPE> withPartitionComponents(Object... partitionKeyComponents) {
        final SelectFromPartition<TYPE> selectFromPartition = new SelectFromPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);
        selectFromPartition.withPartitionComponentsInternal(partitionKeyComponents);
        return selectFromPartition;
    }

    /**
     *
     * Start the Select DSL with provided partition components IN
     *
     * <pre class="code"><code class="java">
     *
     *  manager.sliceQuery(MessageEntity.class)
     *      .forSelect()
     *      .withPartitionComponents(10L)
     *      .andPartitionComponentsIN(2013, 2014)
     *
     * </code></pre>
     *
     * Generated CQL3 query:
     *
     * <br/>
     *  SELECT * FROM messages WHERE user_id=10 AND year IN (2013,2014)
     *
     * @return slice DSL
     */
    public SelectWithPartition<TYPE> withPartitionComponentsIN(Object... partitionKeyComponents) {
        final SelectWithPartition<TYPE> selectWithPartition = new SelectWithPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);
        selectWithPartition.withPartitionComponentsINInternal(partitionKeyComponents);
        return selectWithPartition;
    }


}
```


Overlapping Code:
```
L<TYPE> {
private final SliceQueryExecutor sliceQueryExecutor;
private final Class<TYPE> entityClass;
private final EntityMeta meta;
private final SliceType sliceType;
protected SelectDSL(SliceQueryExecutor sliceQueryExecutor, Class<TYPE> entityClass, EntityMeta meta, SliceType sliceType) {
this.sliceQueryExecutor = sliceQueryExecutor;
this.entityClass = entityClass;
this.meta = meta;
this.sliceType = sliceType;
}
/**
*
* Start the Select DSL with provided partition components
*
* <pre class="code"><code class="java">
*
* manager.sliceQuery(ArticleRating.class)
* .forSelect()
* .withPartitionComponents(articleId)
*
* </code></pre>
*
* Generated CQL3 query:
*
* <br/>
* SELECT * FROM article_rating WHERE article_id=...
*
* @return slice DSL
*/
public SelectFromPartition<TYPE> withPartitionComponents(Object... partitionKeyComponents) {
final SelectFromPartition<TYPE> selectFromPartition = new SelectFromPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);
selectFromPartition.withPartitionComponentsInternal(partitionKeyComponents);
return selectFromPartition;
}
/**
*
* Start the Select DSL with provided partition components IN
*
* <pre class="code"><code class="java">
*
* manager.sliceQuery(MessageEntity.class)
* .forSelect()
* .withPartitionComponents(10L)
* .andPartitionComponentsIN(2013, 2014)
*
* </code></pre>
*
* Generated CQL3 query:
*
* <br/>
* SELECT * FROM messages WHERE user_id=10 AND year IN (2013,2014)
*
* @return slice DSL
*/
public SelectWithPartition<TYPE> withPartitionComponentsIN(Object... partitionKeyComponents) {
final SelectWithPartition<TYPE> selectWithPartition = new SelectWithPartition<>(sliceQueryExecutor, entityClass, meta, sliceType);
selectWithPartition.withPartitionComponentsINInternal(partitionKeyComponents);
return selectWithPartition;
```
<Overlap Ratio: 0.9863013698630136>

---

--- 281 --
Question ID: 281a46ab5705bea02890d49807f1f9744c4c5c17
Original Code:
```
public class DataBaseHelper implements EntityManagerHelper {

    private final Map<String, ThreadLocal<EntityManager>> sessions = new HashMap<>();
    private static final Logger LOG = Logger.getLogger(DataBaseHelper.class.getName());
    private static final Map<String, String> propMap = new HashMap();
    public final static int SALVAR = 0, ATUALIZAR = 1, DELETAR = 2;
    public final static String DATABASE_PU = "DATABASE_PU";

    public DataBaseHelper() {
    }

    @Override
    public boolean getOperation(int operation_type, Object object, String persistence_unit) {
        EntityManager session = getSession(persistence_unit);
        EntityTransaction transaction = session.getTransaction();
        try {
            transaction.begin();
            switch (operation_type) {
                case SALVAR:
                    LOG.info("Salvando registro no banco de dados");
                    session.persist(object);
                    session.getTransaction().commit();
                    break;
                case ATUALIZAR:
                    LOG.info("Atualizando registro no banco de dados");
                    session.merge(object);
                    session.getTransaction().commit();
                    break;
                case DELETAR:
                    LOG.info("Deletando registro no banco de dados");
                    session.remove(session.merge(object));
                    session.getTransaction().commit();
                    break;
            }
            this.closeSession(persistence_unit);
            return true;
        } catch (Exception e) {
            //transaction.rollback();
            this.closeSession(persistence_unit);
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public EntityManager getSession(String persistence_unit) {
        EntityManager session = null;
        if (sessions.isEmpty()) {
            sessions.put(persistence_unit, new ThreadLocal());
            session = sessions.get(persistence_unit).get();
            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;
        } else {
            session = sessions.get(persistence_unit).get();
            session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;
        }
        return session;
    }

    @Override
    public void closeSession(String persistence_unit) {
        EntityManager session = null;
        if (!sessions.isEmpty()) {
            session = sessions.get(persistence_unit).get();
            LOG.info("Encerrando sessão do banco de dados");
            if (session != null) {
                if (session.isOpen()) {
                    session.close();
                }
            }
        }
        LOG.info("Removendo Entity Manager desta sessão");
        sessions.remove(persistence_unit);
    }

    @Override
    public void closeAll() {
        LOG.info("Encerrando todas as sessões");
        sessions.clear();
    }

    @Override
    public Connection getConnection(String persistence_unit) {
        try {
            EntityManager entityManager = getSession(persistence_unit);
            Connection conn = ((EntityManagerImpl) (entityManager.getDelegate())).getServerSession().getAccessor().getConnection();
            return conn;
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    @Override
    public List getObjectList(String strHQL, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Optional getObjectList(Class entity, String strHQL, Map parameters, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public List getObjectList(String strHQL, String strParam, Object valor, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Optional getObjectListNamedQuery(Class classType, String namedQuery, String[] strParam, Object[] valor, String persistence_unit) {
        try {
            EntityManager session = this.getSession(persistence_unit);
            session.getTransaction().begin();
            Query query = session.createNamedQuery(namedQuery, classType);
            int cont = 0;
            if (strParam != null) {
                for (String p : strParam) {
                    query.setParameter(p, valor[cont++]);
                }
            }
            Optional<List<?>> objects = Optional.ofNullable(query.getResultList());
            this.closeSession(persistence_unit);
            return objects;
        } catch (Exception e) {
            e.printStackTrace();
            this.closeSession(persistence_unit);
            return Optional.empty();
        }
    }

    @Override
    public Optional getObjectNamedQuery(Class classType, String namedQuery, String strParam, Object valor, String persistence_unit) {
        try {
            EntityManager session = this.getSession(persistence_unit);
            session.getTransaction().begin();
            Query query = session.createNamedQuery(namedQuery, classType);
            if (strParam != null) {
                query.setParameter(strParam, valor);
            }
            Object object = query.getSingleResult();
            this.closeSession(persistence_unit);
            return Optional.ofNullable(object);
        } catch (Exception e) {
            //e.printStackTrace();
            this.closeSession(persistence_unit);
            return Optional.empty();
        }
    }

    @Override
    public List getObjectList(String strHQL, String strParam, Boolean valor, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Object getObject(String strHQL, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Object getObject(String strHQL, String strParam, Object valor, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public Object getObject(String strHQL, String[] strParam, String[] valor, String persistence_unit) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

}
```


Overlapping Code:
```
per implements EntityManagerHelper {
private final Map<String, ThreadLocal<EntityManager>> sessions = new HashMap<>();
private static final Logger LOG = Logger.getLogger(DataBaseHelper.class.getName());
private static final Map<String, String> propMap = new HashMap();
public final static int SALVAR = 0, ATUALIZAR = 1, DELETAR = 2;
public final static String DATABASE_PU = "DATABASE_PU";
public DataBaseHelper() {
}
@Override
public boolean getOperation(int operation_type, Object object, String persistence_unit) {
EntityManager session = getSession(persistence_unit);
EntityTransaction transaction = session.getTransaction();
try {
transaction.begin();
switch (operation_type) {
case SALVAR:
LOG.info("Salvando registro no banco de dados");
session.persist(object);
session.getTransaction().commit();
break;
case ATUALIZAR:
LOG.info("Atualizando registro no banco de dados");
session.merge(object);
session.getTransaction().commit();
break;
case DELETAR:
LOG.info("Deletando registro no banco de dados");
session.remove(session.merge(object));
session.getTransaction().commit();
break;
}
this.closeSession(persistence_unit);
return true;
} catch (Exception e) {
//transaction.rollback();
this.closeSession(persistence_unit);
e.printStackTrace();
return false;
}
}
@Override
public EntityManager getSession(String persistence_unit) {
EntityManager session = null;
if (sessions.isEmpty()) {
sessions.put(persistence_unit, new ThreadLocal());
session = sessions.get(persistence_unit).get();
session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;
} else {
session = sessions.get(persistence_unit).get();
session = session == null ? DataBaseFactoryService.getEntityManagerFactory(persistence_unit, propMap).createEntityManager() : session;
}
return sess
```
<Overlap Ratio: 0.9865301724137931>

---

--- 282 --
Question ID: 93a068555222aa88730159d2368fee07ec9ed1fc
Original Code:
```
public class Hierarchy {
    protected Grammar LexerRoot = null;
    protected Grammar ParserRoot = null;
    protected Grammar TreeParserRoot = null;
    protected Hashtable symbols;	// table of grammars
    protected Hashtable files;	// table of grammar files read in
    protected antlr.Tool antlrTool;

    public Hierarchy(antlr.Tool tool) {
        this.antlrTool = tool;
        LexerRoot = new Grammar(tool, "Lexer", null, null);
        ParserRoot = new Grammar(tool, "Parser", null, null);
        TreeParserRoot = new Grammar(tool, "TreeParser", null, null);
        symbols = new Hashtable(10);
        files = new Hashtable(10);

        LexerRoot.setPredefined(true);
        ParserRoot.setPredefined(true);
        TreeParserRoot.setPredefined(true);

        symbols.put(LexerRoot.getName(), LexerRoot);
        symbols.put(ParserRoot.getName(), ParserRoot);
        symbols.put(TreeParserRoot.getName(), TreeParserRoot);
    }

    public void addGrammar(Grammar gr) {
        gr.setHierarchy(this);
        // add grammar to hierarchy
        symbols.put(gr.getName(), gr);
        // add grammar to file.
        GrammarFile f = getFile(gr.getFileName());
        f.addGrammar(gr);
    }

    public void addGrammarFile(GrammarFile gf) {
        files.put(gf.getName(), gf);
    }

    public void expandGrammarsInFile(String fileName) {
        GrammarFile f = getFile(fileName);
        for (Enumeration e = f.getGrammars().elements(); e.hasMoreElements();) {
            Grammar g = (Grammar)e.nextElement();
            g.expandInPlace();
        }
    }

    public Grammar findRoot(Grammar g) {
        if (g.getSuperGrammarName() == null) {		// at root
            return g;
        }
        // return root of super.
        Grammar sg = g.getSuperGrammar();
        if (sg == null) return g;		// return this grammar if super missing
        return findRoot(sg);
    }

    public GrammarFile getFile(String fileName) {
        return (GrammarFile)files.get(fileName);
    }

    public Grammar getGrammar(String gr) {
        return (Grammar)symbols.get(gr);
    }

    public static String optionsToString(IndexedVector options) {
        String s = "options {" + System.getProperty("line.separator");
        for (Enumeration e = options.elements(); e.hasMoreElements();) {
            s += (Option)e.nextElement() + System.getProperty("line.separator");
        }
        s += "}" +
            System.getProperty("line.separator") +
            System.getProperty("line.separator");
        return s;
    }

    public void readGrammarFile(String file) throws FileNotFoundException {
        Reader grStream = new BufferedReader(new FileReader(file));
        addGrammarFile(new GrammarFile(antlrTool, file));

        // Create the simplified grammar lexer/parser
        PreprocessorLexer ppLexer = new PreprocessorLexer(grStream);
        ppLexer.setFilename(file);
        Preprocessor pp = new Preprocessor(ppLexer);
		pp.setTool(antlrTool);
        pp.setFilename(file);

        // populate the hierarchy with class(es) read in
        try {
            pp.grammarFile(this, file);
        }
        catch (TokenStreamException io) {
            antlrTool.toolError("Token stream error reading grammar(s):\n" + io);
        }
        catch (ANTLRException se) {
            antlrTool.toolError("error reading grammar(s):\n" + se);
        }
    }

    /** Return true if hierarchy is complete, false if not */
    public boolean verifyThatHierarchyIsComplete() {
        boolean complete = true;
        // Make a pass to ensure all grammars are defined
        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {
            Grammar c = (Grammar)e.nextElement();
            if (c.getSuperGrammarName() == null) {
                continue;		// at root: ignore predefined roots
            }
            Grammar superG = c.getSuperGrammar();
            if (superG == null) {
                antlrTool.toolError("grammar " + c.getSuperGrammarName() + " not defined");
                complete = false;
                symbols.remove(c.getName()); // super not defined, kill sub
            }
        }

        if (!complete) return false;

        // Make another pass to set the 'type' field of each grammar
        // This makes it easy later to ask a grammar what its type
        // is w/o having to search hierarchy.
        for (Enumeration e = symbols.elements(); e.hasMoreElements();) {
            Grammar c = (Grammar)e.nextElement();
            if (c.getSuperGrammarName() == null) {
                continue;		// ignore predefined roots
            }
            c.setType(findRoot(c).getName());
        }

        return true;
    }

    public antlr.Tool getTool() {
        return antlrTool;
    }

    public void setTool(antlr.Tool antlrTool) {
        this.antlrTool = antlrTool;
    }
}
```


Overlapping Code:
```
{
protected Grammar LexerRoot = null;
protected Grammar ParserRoot = null;
protected Grammar TreeParserRoot = null;
protected Hashtable symbols; // table of grammars
protected Hashtable files; // table of grammar files read in
protected antlr.Tool antlrTool;
public Hierarchy(antlr.Tool tool) {
this.antlrTool = tool;
LexerRoot = new Grammar(tool, "Lexer", null, null);
ParserRoot = new Grammar(tool, "Parser", null, null);
TreeParserRoot = new Grammar(tool, "TreeParser", null, null);
symbols = new Hashtable(10);
files = new Hashtable(10);
LexerRoot.setPredefined(true);
ParserRoot.setPredefined(true);
TreeParserRoot.setPredefined(true);
symbols.put(LexerRoot.getName(), LexerRoot);
symbols.put(ParserRoot.getName(), ParserRoot);
symbols.put(TreeParserRoot.getName(), TreeParserRoot);
}
public void addGrammar(Grammar gr) {
gr.setHierarchy(this);
// add grammar to hierarchy
symbols.put(gr.getName(), gr);
// add grammar to file.
GrammarFile f = getFile(gr.getFileName());
f.addGrammar(gr);
}
public void addGrammarFile(GrammarFile gf) {
files.put(gf.getName(), gf);
}
public void expandGrammarsInFile(String fileName) {
GrammarFile f = getFile(fileName);
for (Enumeration e = f.getGrammars().elements(); e.hasMoreElements();) {
Grammar g = (Grammar)e.nextElement();
g.expandInPlace();
}
}
public Grammar findRoot(Grammar g) {
if (g.getSuperGrammarName() == null) { // at root
return g;
}
// return root of super.
Grammar sg = g.getSuperGrammar();
if (sg == null) return g; // return this grammar if super missing
return findRoot(sg);
}
public GrammarFile getFile(String fileName) {
return (GrammarFile)files.get(fileName);
}
public Grammar getGrammar(String gr) {
return (Grammar)symbols.get(gr);
}
public static String optionsToString(IndexedVector options) {
String s = "options {" + System.getProperty("line.separator");
for (Enumeration e = options.elements(); e.hasMoreElements();) {
s += (Option)e.nextElement() + System.getProperty("line.separator");
}
s += "}" +
System.getProperty("line.separator") +
System.getProperty("l
```
<Overlap Ratio: 0.9883438562408936>

---

--- 283 --
Question ID: 2e767f2619da99b7069529fbcea829177548c706
Original Code:
```
public class AnnotationMergerAE
  extends CommonAE
{
  public static final String PARAM_SUBSUMING_ANNOTATION = "SubsumingAnnotation";
  @ConfigurationParameter(name="SubsumingAnnotation", mandatory=true)
  private String subsumingAnnotationName;
  public static final String PARAM_SUBSUMED_ANNOTATION = "SubsumedAnnotation";
  @ConfigurationParameter(name="SubsumedAnnotation", mandatory=true)
  private String subsumedAnnotationName;
  public static final String PARAM_STRICT_OFFSET = "StrictOffset";
  @ConfigurationParameter(name="StrictOffset", mandatory=false, defaultValue={"false"})
  private boolean strictOffset;
  
  public void initialize(UimaContext aContext)
    throws ResourceInitializationException
  {
/* 110 */     super.initialize(aContext);
    

/* 113 */     if (this.subsumedAnnotationName == null) { this.subsumedAnnotationName = this.subsumingAnnotationName;
    }
  }
  








  protected String processContextAnnotation(JCas inputViewJCas, FSIterator<Annotation> contextAnnotationsFSIter, Annotation contextAnnotation, FSIterator<Annotation> contextualizedInputAnnotationsFSIter, String inputFeatureString, JCas outputViewJCas, String outputAnnotationString, String ouputFeatureString)
    throws AnalysisEngineProcessException
  {
/* 128 */     LocatedAnnotationIndexInterface locatedAnnotationIndex = LocatedAnnotationIndexBuilder.buildsIndex(inputViewJCas);
    
/* 130 */     Map<String, LocatedAnnotation> locatedAnnotationSortedMap = locatedAnnotationIndex.getLocatedAnnotationIndex();
    
/* 132 */     Set<String> sortedOffsetSet = locatedAnnotationSortedMap.keySet();
    

/* 135 */     for (String offset : sortedOffsetSet)
    {
/* 137 */       LocatedAnnotation locatedAnnotation = (LocatedAnnotation)locatedAnnotationSortedMap.get(offset);
      


/* 141 */       List<Annotation> currentAnnotations = locatedAnnotation.getCurrent();
/* 142 */       Boolean isCurrentSubsumingAnnotation = Boolean.valueOf(false);
/* 143 */       Boolean isCurrentSubsumedAnnotation = Boolean.valueOf(false);
      
/* 145 */       for (Annotation currentAnnotation : currentAnnotations) {
/* 146 */         if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumingAnnotationName)) {
/* 147 */           isCurrentSubsumingAnnotation = Boolean.valueOf(true);
        }
/* 149 */         else if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumedAnnotationName)) {
/* 150 */           isCurrentSubsumedAnnotation = Boolean.valueOf(true);
        }
      }
      
/* 154 */       if (isCurrentSubsumingAnnotation.booleanValue())
      {
/* 156 */         AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());



      }
/* 161 */       else if (isCurrentSubsumedAnnotation.booleanValue())
      {

/* 164 */         List<LocatedAnnotation> superAnnotations = locatedAnnotation.getContiguousParent();
/* 165 */         Boolean isSuperSubsumingAnnotation = Boolean.valueOf(false);
        
/* 167 */         for (LocatedAnnotation superAnnotation : superAnnotations) {
/* 168 */           if (superAnnotation.containsCurrent(this.subsumingAnnotationName)) {
/* 169 */             isSuperSubsumingAnnotation = Boolean.valueOf(true);
          }
        }
/* 172 */         if (!isSuperSubsumingAnnotation.booleanValue())
        {
/* 174 */           List<LocatedAnnotation> partialPreviousAnnotations = locatedAnnotation.getContiguousPartialPreceding();
/* 175 */           Boolean isPartialPreviousSubsumingAnnotation = Boolean.valueOf(false);
          
/* 177 */           for (LocatedAnnotation partialPreviousAnnotation : partialPreviousAnnotations) {
/* 178 */             if (partialPreviousAnnotation.containsCurrent(this.subsumingAnnotationName)) {
/* 179 */               isPartialPreviousSubsumingAnnotation = Boolean.valueOf(true);
            }
          }
/* 182 */           if (!isPartialPreviousSubsumingAnnotation.booleanValue())
          {
/* 184 */             List<LocatedAnnotation> partialNextAnnotations = locatedAnnotation.getContiguousPartialPreceding();
/* 185 */             Boolean isPartialNextSubsumingAnnotation = Boolean.valueOf(false);
            
/* 187 */             for (LocatedAnnotation partialNextAnnotation : partialNextAnnotations) {
/* 188 */               if (partialNextAnnotation.containsCurrent(this.subsumingAnnotationName)) {
/* 189 */                 isPartialNextSubsumingAnnotation = Boolean.valueOf(true);
              }
            }
/* 192 */             if (!isPartialNextSubsumingAnnotation.booleanValue())
            {
/* 194 */               AnnotationUtils.createAnnotation(inputViewJCas, outputAnnotationString, locatedAnnotation.getBegin(), locatedAnnotation.getEnd());
            }
          }
        }
      }
    }
    











/* 212 */     return contextAnnotation.getCoveredText();
  }
  




  private void doAnnotationMergerBasedOnDistinctSubsumingAndSubsumedAnnotations(JCas inputViewJCas)
    throws AnalysisEngineProcessException
  {
/* 222 */     Map<Annotation, Integer> annotationAlreadySeenMap = new HashMap();
    
/* 224 */     Type subsumingAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumingAnnotationName);
/* 225 */     AnnotationIndex<Annotation> subsumingAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumingAnnotationType);
    


/* 229 */     FSIterator<Annotation> subsumingAnnotationIterator = subsumingAnnotationIndex.iterator();
    

/* 232 */     while (subsumingAnnotationIterator.hasNext()) {
/* 233 */       Annotation aSubsumingAnnotation = (Annotation)subsumingAnnotationIterator.next();
      

/* 236 */       if (!annotationAlreadySeenMap.containsKey(aSubsumingAnnotation)) {
/* 237 */         int minSubsumedAnnotationBegin = aSubsumingAnnotation.getEnd();
/* 238 */         int maxSubsumedAnnotationEnd = aSubsumingAnnotation.getBegin();
        
/* 240 */         Map<Annotation, Integer> subsumedAnnotationPotentiallyAlreadySeenMap = new HashMap();
        
/* 242 */         FSIterator<Annotation> subsumedAnnotationIterator = AnnotationCollectionUtils.subiterator(inputViewJCas, aSubsumingAnnotation);
        


/* 246 */         while (subsumedAnnotationIterator.hasNext()) {
/* 247 */           Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();
          




/* 253 */           if (aSubsumedAnnotation.getBegin() < minSubsumedAnnotationBegin) minSubsumedAnnotationBegin = aSubsumedAnnotation.getBegin();
/* 254 */           if (aSubsumedAnnotation.getEnd() > maxSubsumedAnnotationEnd) { maxSubsumedAnnotationEnd = aSubsumedAnnotation.getEnd();
          }
/* 256 */           subsumedAnnotationPotentiallyAlreadySeenMap.put(aSubsumedAnnotation, Integer.valueOf(1));
        }
        



/* 262 */         if ((aSubsumingAnnotation.getBegin() == minSubsumedAnnotationBegin) && (aSubsumingAnnotation.getEnd() == maxSubsumedAnnotationEnd))
        {



/* 267 */           annotationAlreadySeenMap.putAll(subsumedAnnotationPotentiallyAlreadySeenMap);
          

/* 270 */           AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumingAnnotation.getBegin(), aSubsumingAnnotation.getEnd());
        }
      }
    }
    








/* 283 */     Type subsumedAnnotationType = inputViewJCas.getTypeSystem().getType(this.subsumedAnnotationName);
/* 284 */     System.err.println("Debug: subsumedAnnotationName " + this.subsumedAnnotationName + " subsumingAnnotationName " + this.subsumingAnnotationName);
/* 285 */     AnnotationIndex<Annotation> subsumedAnnotationIndex = inputViewJCas.getAnnotationIndex(subsumedAnnotationType);
    



/* 290 */     FSIterator<Annotation> subsumedAnnotationIterator = subsumedAnnotationIndex.iterator();
/* 291 */     while (subsumedAnnotationIterator.hasNext()) {
/* 292 */       Annotation aSubsumedAnnotation = (Annotation)subsumedAnnotationIterator.next();
/* 293 */       if (!annotationAlreadySeenMap.containsKey(aSubsumedAnnotation)) {
/* 294 */         AnnotationUtils.createAnnotation(inputViewJCas, getOutputAnnotation(), aSubsumedAnnotation.getBegin(), aSubsumedAnnotation.getEnd());
      }
    }
  }
}
```


Overlapping Code:
```
nds CommonAE
{
public static final String PARAM_SUBSUMING_ANNOTATION = "SubsumingAnnotation";
@ConfigurationParameter(name="SubsumingAnnotation", mandatory=true)
private String subsumingAnnotationName;
public static final String PARAM_SUBSUMED_ANNOTATION = "SubsumedAnnotation";
@ConfigurationParameter(name="SubsumedAnnotation", mandatory=true)
private String subsumedAnnotationName;
public static final String PARAM_STRICT_OFFSET = "StrictOffset";
@ConfigurationParameter(name="StrictOffset", mandatory=false, defaultValue={"false"})
private boolean strictOffset;

public void initialize(UimaContext aContext)
throws ResourceInitializationException
{
/* 110 */ super.initialize(aContext);

/* 113 */ if (this.subsumedAnnotationName == null) { this.subsumedAnnotationName = this.subsumingAnnotationName;
}
}

protected String processContextAnnotation(JCas inputViewJCas, FSIterator<Annotation> contextAnnotationsFSIter, Annotation contextAnnotation, FSIterator<Annotation> contextualizedInputAnnotationsFSIter, String inputFeatureString, JCas outputViewJCas, String outputAnnotationString, String ouputFeatureString)
throws AnalysisEngineProcessException
{
/* 128 */ LocatedAnnotationIndexInterface locatedAnnotationIndex = LocatedAnnotationIndexBuilder.buildsIndex(inputViewJCas);

/* 130 */ Map<String, LocatedAnnotation> locatedAnnotationSortedMap = locatedAnnotationIndex.getLocatedAnnotationIndex();

/* 132 */ Set<String> sortedOffsetSet = locatedAnnotationSortedMap.keySet();

/* 135 */ for (String offset : sortedOffsetSet)
{
/* 137 */ LocatedAnnotation locatedAnnotation = (LocatedAnnotation)locatedAnnotationSortedMap.get(offset);

/* 141 */ List<Annotation> currentAnnotations = locatedAnnotation.getCurrent();
/* 142 */ Boolean isCurrentSubsumingAnnotation = Boolean.valueOf(false);
/* 143 */ Boolean isCurrentSubsumedAnnotation = Boolean.valueOf(false);

/* 145 */ for (Annotation currentAnnotation : currentAnnotations) {
/* 146 */ if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumingAnnotationName)) {
/* 147 */ isCurrentSubsumingAnnotation = Boolean.valueOf(true);
}
/* 149 */ else if (currentAnnotation.getType().getName().equalsIgnoreCase(this.subsumedAnnotationName)) {
/* 150 */ isCurrentSubsumedAnnotation =
```
<Overlap Ratio: 0.9744478129060199>

---

--- 284 --
Question ID: 09dac61e444c3c583568113dc31ee8ec23bc8182
Original Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class GraphQLQueryIntegrationTest {

  @Autowired
  GraphQLSchema schema;

  @Autowired
  private TestRestTemplate restTemplate;

  @Before
  public void verifySchema() {
    assertNotNull(schema);
  }

  @Test
  public void shouldReturnBadRequest() {
    ResponseEntity<String> response = restTemplate.postForEntity("/graphql", "{}", String.class);
    String message = response.getBody();
    assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
  }


  @Test
  public void shouldReturnUserList() {
    String request = "{\n" +
      "\t\"query\": \"{users{id}}\"\n" +
      "}";
    ResponseEntity<String> response = restTemplate.postForEntity("/graphql", request, String.class);
    String message = response.getBody();
    assertEquals(HttpStatus.OK, response.getStatusCode());
  }


  @Test
  public void shouldAddNewUserSuccessfully() {
    String request = "{\n" +
      "\"query\":\"mutation {user(name:\\\"dkf\\\", email:\\\"dkf@asd.com\\\"){id name}}\"," +
      "\"variables\":null" +
      "}";
    ResponseEntity<String> response = restTemplate.postForEntity("/graphql", request, String.class);
    String message = response.getBody();
    assertEquals(HttpStatus.OK, response.getStatusCode());
    assertThat("Response should contain name", message, CoreMatchers.containsString("\"name\":\"dkf\""));
  }

  @Test
  public void shouldExecuteProperly() {
    ExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query { user(id:1) { id name } }")
      .build();


    GraphQL graphQL = GraphQL.newGraphQL(schema).build();

    ExecutionResult executionResult = graphQL.execute(executionInput);


    User user = JacksonHelper.deserialize(JacksonHelper.serialize(executionResult.getData()), UserDTO.class).getUser();
    List<GraphQLError> errors = executionResult.getErrors();

    Assert.assertEquals("No error", 0, errors.size());
    Assert.assertNotNull(user);
    Assert.assertEquals("ID", 1, user.getId());


  }


}
```


Overlapping Code:
```
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class GraphQLQueryIntegrationTest {
@Autowired
GraphQLSchema schema;
@Autowired
private TestRestTemplate restTemplate;
@Before
public void verifySchema() {
assertNotNull(schema);
}
@Test
public void shouldReturnBadRequest() {
ResponseEntity<String> response = restTemplate.postForEntity("/graphql", "{}", String.class);
String message = response.getBody();
assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
}
@Test
public void shouldReturnUserList() {
String request = "{\n" +
"\t\"query\": \"{users{id}}\"\n" +
"}";
ResponseEntity<String> response = restTemplate.postForEntity("/graphql", request, String.class);
String message = response.getBody();
assertEquals(HttpStatus.OK, response.getStatusCode());
}
@Test
public void shouldAddNewUserSuccessfully() {
String request = "{\n" +
"\"query\":\"mutation {ame}}\"," +
"\"variables\":null" +
"}";
ResponseEntity<String> response = restTemplate.postForEntity("/graphql", request, String.class);
String message = response.getBody();
assertEquals(HttpStatus.OK, response.getStatusCode());
assertThat("Response should contain name", message, CoreMatchers.containsString("\"name\":\"dkf\""));
}
@Test
public void shouldExecuteProperly() {
ExecutionInput executionInput = ExecutionInput.newExecutionInput().query("query { user(id:1) { id name } }")
.build();
GraphQL graphQL = GraphQL.newGraphQL(schema).build();
ExecutionResult executionResult = graphQL.execute(executionInput);
User user = JacksonHelper.deserialize(JacksonHelper.serialize(executionResult.getData()), UserDTO.class).getUser();
List<GraphQLError> errors = executionResult.getErrors();
Assert.assertEquals("No error", 0, errors.size());
Assert.assertNotNull(user);
Assert.assertEquals("ID", 1, us
```
<Overlap Ratio: 0.9632159747766684>

---

--- 285 --
Question ID: 7e3140f478b7540ebbfc7ed008247e37f6c66bda
Original Code:
```
public class OutputConnection {

    public static Connection _con;

    public OutputConnection(String url) {
        Connect(url);
        CreateGraphSQL();
    }

    private void Connect(String url) {
        try {
            _con = DriverManager.getConnection(url);
            System.out.println("Connection for output established.");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void DropTablesIfExists() {
        try {
            Statement stmt = _con.createStatement();
            stmt.executeUpdate("DROP TABLE IF EXISTS node;");
            stmt.executeUpdate("DROP TABLE IF EXISTS edge;");
            stmt.executeUpdate("DROP TABLE IF EXISTS property;");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void CreateNodeTable() {
        try {
            Statement stmt = _con.createStatement();
            stmt.executeUpdate("CREATE TABLE node(id INTEGER NOT NULL, label TEXT, PRIMARY KEY (id));");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void CreateEdgeTable() {
        try {
            Statement stmt = _con.createStatement();
            stmt.executeUpdate(
                    "CREATE TABLE edge(id INTEGER NOT NULL, srcId INTEGER, tgtId INTEGER, label TEXT, PRIMARY KEY (id));");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    private void CreatePropertyTable() {
        try {
            Statement stmt = _con.createStatement();
            stmt.executeUpdate(
                    "CREATE TABLE property(id INTEGER NOT NULL, pkey VARCHAR(256), pvalue TEXT, PRIMARY KEY (id, pkey));");
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void InsertPropertyRow(ResultSet values, ResultSetMetaData valuesMd, String currIdentifier) {

        String sql = "INSERT INTO property VALUES(?,?,?);";
        try {
            int length = valuesMd.getColumnCount();

            PreparedStatement st = _con.prepareStatement(sql);
            for (int i = 1; i < length; i++) {
                String currAtt = valuesMd.getColumnName(i);
                Object currVal = values.getObject(i);
                if (currVal != null) {
                    Property prop = new Property(currIdentifier, currAtt, currVal.toString());
                    st.setInt(1, Integer.parseInt(prop.Id));
                    st.setString(2, prop.Key);
                    st.setString(3, prop.Value);
                    st.addBatch();
                }
            }
            int[] result = st.executeBatch();
            System.out.println(result.length + " property(ies) added.");

        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
        }
    }

    public static void InsertEdgeRow(Edge edge) {
        try {
            App._statementEdges.setInt(1, Integer.parseInt(edge.Id));
            App._statementEdges.setInt(2, Integer.parseInt(edge.SrcId));
            App._statementEdges.setInt(3, Integer.parseInt(edge.TgtId));
            App._statementEdges.setString(4, edge.Label);
            App._statementEdges.addBatch();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void InsertNodeRow(Node n) {
        try {
            String sql = "INSERT INTO node VALUES(?,?);";
            PreparedStatement st = _con.prepareStatement(sql);
            st.setInt(1, Integer.parseInt(n.Id));
            st.setString(2, n.Label);

            Integer result = st.executeUpdate();
            System.out.println(result.toString().concat(" node added."));
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static List<String> JoinNodeAndProperty(String relName, String key, String val) {
        String sql = "SELECT n.id, n.label, p.pkey, p.pvalue FROM node n INNER JOIN property p ON n.id = p.id AND p.pvalue='"
                .concat(val).concat("' AND p.pkey='").concat(key).concat("' AND n.label='").concat(relName)
                .concat("';");
        List<String> results = new ArrayList<>();

        try {
            Statement stmt = _con.createStatement();
            ResultSet values = stmt.executeQuery(sql);
            while (values.next()) {
                results.add(values.getString(1));
            }
        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
            return null;
        } finally {
            return results;
        }

    }

    public static void Statistics() {
        String sql = "SELECT COUNT(*) as stats FROM node UNION SELECT COUNT(*) FROM property UNION SELECT COUNT(*) FROM edge;";
        List<String> results = new ArrayList<>();

        try {
            Statement stmt = _con.createStatement();
            ResultSet values = stmt.executeQuery(sql);
            while (values.next()) {
                results.add(values.getString(1));
            }
        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
        } finally {
            System.out.println("# Nodes: ".concat(results.get(0)));
            System.out.println("# Properties: ".concat(results.get(1)));
            System.out.println("# Edges: ".concat(results.get(2)));
        }
    }

    public static ResultSet GetNodeData() {
        String sql = "select * from node;";

        try {
            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.CONCUR_READ_ONLY);
            stmt.setFetchSize(500);
            ResultSet values = stmt.executeQuery();
            return values;
        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
            return null;
        }
    }

    public static ResultSet GetPropertyData() {
        String sql = "select * from property;";

        try {
            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.CONCUR_READ_ONLY);
            stmt.setFetchSize(500);
            ResultSet values = stmt.executeQuery();
            return values;
        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
            return null;
        }
    }

    public static ResultSet GetEdgeData() {
        String sql = "select * from edge;";

        try {
            PreparedStatement stmt = _con.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY,
                    ResultSet.CONCUR_READ_ONLY);
            stmt.setFetchSize(500);
            ResultSet values = stmt.executeQuery();
            return values;
        } catch (SQLException e) {
            System.out.println(sql);
            e.printStackTrace();
            return null;
        }
    }

    public void CreateGraphSQL() {
        DropTablesIfExists();
        CreateNodeTable();
        CreateEdgeTable();
        CreatePropertyTable();
        System.out.println("Mapping - Created tables.");
    }
}
```


Overlapping Code:
```
Connection _con;
public OutputConnection(String url) {
Connect(url);
CreateGraphSQL();
}
private void Connect(String url) {
try {
_con = DriverManager.getConnection(url);
System.out.println("Connection for output established.");
} catch (SQLException e) {
e.printStackTrace();
}
}
private void DropTablesIfExists() {
try {
Statement stmt = _con.createStatement();
stmt.executeUpdate("DROP TABLE IF EXISTS node;");
stmt.executeUpdate("DROP TABLE IF EXISTS edge;");
stmt.executeUpdate("DROP TABLE IF EXISTS property;");
} catch (SQLException e) {
e.printStackTrace();
}
}
private void CreateNodeTable() {
try {
Statement stmt = _con.createStatement();
stmt.executeUpdate("CREATE TABLE node(id INTEGER NOT NULL, label TEXT, PRIMARY KEY (id));");
} catch (SQLException e) {
e.printStackTrace();
}
}
private void CreateEdgeTable() {
try {
Statement stmt = _con.createStatement();
stmt.executeUpdate(
"CREATE TABLE edge(id INTEGER NOT NULL, srcId INTEGER, tgtId INTEGER, label TEXT, PRIMARY KEY (id));");
} catch (SQLException e) {
e.printStackTrace();
}
}
private void CreatePropertyTable() {
try {
Statement stmt = _con.createStatement();
stmt.executeUpdate(
"CREATE TABLE property(id INTEGER NOT NULL, pkey VARCHAR(256), pvalue TEXT, PRIMARY KEY (id, pkey));");
} catch (SQLException e) {
e.printStackTrace();
}
}
public static void InsertPropertyRow(ResultSet values, ResultSetMetaData valuesMd, String currIdentifier) {
String sql = "INSERT INTO property VALUES(?,?,?);";
try {
int length = valuesMd.getColumnCount();
PreparedStatement st = _con.prepareStatement(sql);
for (int i = 1; i < length; i++) {
String currAtt = valuesMd.getColumnName(i);
Object currVal = values.getObject(i);
if (currVal != null) {
Property prop = new Property(currIdentifier, currAtt, currVal.toString());
st.setInt(1, Inte
```
<Overlap Ratio: 0.9508716323296355>

---

--- 286 --
Question ID: 730c54a448d63b3a8301ffb2d5d1259527816880
Original Code:
```
public class TestGrunt extends TestCase {
    MiniCluster cluster = MiniCluster.buildCluster();

	
	@Test 
	public void testCopyFromLocal() throws Throwable {
		PigServer server = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
        PigContext context = server.getPigContext();
        
        String strCmd = "copyFromLocal /tmp/TestMe;";
        
        ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());
        InputStreamReader reader = new InputStreamReader(cmd);
        
        Grunt grunt = new Grunt(new BufferedReader(reader), context);
	
        grunt.exec();
	}
}
```


Overlapping Code:
```
tends TestCase {
MiniCluster cluster = MiniCluster.buildCluster();

@Test 
public void testCopyFromLocal() throws Throwable {
PigServer server = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
PigContext context = server.getPigContext();

String strCmd = "copyFromLocal /tmp/TestMe;";

ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());
InputStreamReader reader = new InputStreamReader(cmd);

Grunt grunt = new Grunt(new BufferedReader(reader), context);

grunt.exec();
}
```
<Overlap Ratio: 0.9491525423728814>

---

--- 287 --
Question ID: 68d043774c359c27a914cca3b582174bca0dddea
Original Code:
```
public class hashmap {

	public static void main(String[] args) 
	{
	HashMap<Integer, String> hm= new HashMap<Integer,String>();
	hm.put(1, "sachin");
	hm.put(2, "ravi");
	hm.put(3, "raj");
	
	System.out.println(hm.get(1));
	System.out.println(hm.containsKey(3));
	for(Entry m: hm.entrySet())
	{
		System.out.println(m.getKey()+ " "+m.getValue());
	}
	HashMap<Integer, Employee> emp= new HashMap<Integer,Employee>();
	Employee e1= new Employee(1, "raj", "Admin");
	Employee e2= new Employee(1, "ravi", "testing");
	Employee e3= new Employee(1, "sachin", "devlop");
	
	emp.put(1, e1);
	emp.put(2, e2);
	emp.put(3, e3);
	
	for(Entry<Integer,Employee>m :emp.entrySet())
	{
	int key=m.getKey();
	
		Employee e=m.getValue();
		System.out.println(key + "info");
		System.out.println(e.id+" "+e.name+" "+e.dept);
		
	}
	

	}

}
```


Overlapping Code:
```
public class hashmap {
public static void main(String[] args) 
{
HashMap<Integer, String> hm= new HashMap<Integer,String>();
hm.put(1, "sachin");
hm.put(2, "ravi");
hm.put(3, "raj");

System.out.println(hm.get(1));
System.out.println(hm.containsKey(3));
for(Entry m: hm.entrySet())
{
System.out.println(m.getKey()+ " "+m.getValue());
}
HashMap<Integer, Employee> emp= new HashMap<Integer,Employee>();
Employee e1= new Employee(1, "raj", "Admin");
Employee e2= new Employee(1, "ravi", "testing");
Employee e3= new Employee(1, "sachin", "devlop");

emp.put(1, e1);
emp.put(2, e2);
emp.put(3, e3);

for(Entry<Integer,Employee>m :emp.entrySet())
{
int key=m.getKey();

Employee e=m.getValue();
System.out.println(key + "info");
System.out.println(e.id+" "+e.name
```
<Overlap Ratio: 0.9730423620025674>

---

--- 288 --
Question ID: 21367ad8ce3fdd05aafe4e9a44a618b120aff271
Original Code:
```
@DisplayName("Separate The Numbers should")
class SeparateNumbersTests {

    @Test
    @DisplayName("make sure input string is not empty")
    void makeSureInputStringIsNotEmpty() {
        final String value = null;
        assertThrows(IllegalArgumentException.class,
                () -> SeparateNumbers.separateNumbers(value)
        );

        String otherValue = "";
        assertThrows(IllegalArgumentException.class,
                () -> SeparateNumbers.separateNumbers(otherValue)
        );

        String lastValue = "abcd";
        assertThrows(IllegalArgumentException.class,
                () -> SeparateNumbers.separateNumbers(lastValue)
        );

    }

    @Test
    @DisplayName("return YES for 'single-digit' beautiful strings")
    void returnYESForSingleDigitBeautifulStrings() {
        assertEquals("YES 1", SeparateNumbers.separateNumbers("1234"));
        assertEquals("YES 4", SeparateNumbers.separateNumbers("4567"));
        assertEquals("YES 7", SeparateNumbers.separateNumbers("789"));
        assertEquals("YES 2", SeparateNumbers.separateNumbers("23456789"));
    }
}
```


Overlapping Code:
```
ers should")
class SeparateNumbersTests {
@Test
@DisplayName("make sure input string is not empty")
void makeSureInputStringIsNotEmpty() {
final String value = null;
assertThrows(IllegalArgumentException.class,
() -> SeparateNumbers.separateNumbers(value)
);
String otherValue = "";
assertThrows(IllegalArgumentException.class,
() -> SeparateNumbers.separateNumbers(otherValue)
);
String lastValue = "abcd";
assertThrows(IllegalArgumentException.class,
() -> SeparateNumbers.separateNumbers(lastValue)
);
}
@Test
@DisplayName("return YES for 'single-digit' beautiful strings")
void returnYESForSingleDigitBeautifulStrings() {
assertEquals("YES 1", SeparateNumbers.separateNumbers("1234"));
assertEquals("YES 4", SeparateNumbers.separateNumbers("4567"));
assertEquals("YES 7", SeparateNumbers.separateNumbers("789"));
assertEquals("YES 2", SeparateNum
```
<Overlap Ratio: 0.9249183895538629>

---

--- 289 --
Question ID: 7fe132c6686439330c7f049fcce4acbd711581b8
Original Code:
```
public class SpringELParser extends AbstractScriptParser {

    /**
     * # 号
     */
    private static final String POUND = "#";

    /**
     * 撇号
     */
    private static final String apostrophe = "'";

    private final ExpressionParser parser = new SpelExpressionParser();

    private final ConcurrentHashMap<String, Expression> expCache = new ConcurrentHashMap<String, Expression>();

    private static Method hash = null;

    private static Method empty = null;

    static {
        try {
            hash = CacheUtil.class.getDeclaredMethod("getUniqueHashStr", new Class[]{Object.class});
            empty = CacheUtil.class.getDeclaredMethod("isEmpty", new Class[]{Object.class});
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private final ConcurrentHashMap<String, Method> funcs = new ConcurrentHashMap<String, Method>(8);

    /**
     * @param name   方法名
     * @param method 方法
     */
    @Override
    public void addFunction(String name, Method method) {
        funcs.put(name, method);
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T> T getElValue(String keySpEL, Object target, Object[] arguments, Object retVal, boolean hasRetVal,
                            Class<T> valueType) throws Exception {
        if (valueType.equals(String.class)) {
            // 如果不是表达式，直接返回字符串
            if (keySpEL.indexOf(POUND) == -1 && keySpEL.indexOf("'") == -1) {
                return (T) keySpEL;
            }
        }
        StandardEvaluationContext context = new StandardEvaluationContext();

        context.registerFunction(HASH, hash);
        context.registerFunction(EMPTY, empty);
        Iterator<Map.Entry<String, Method>> it = funcs.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Method> entry = it.next();
            context.registerFunction(entry.getKey(), entry.getValue());
        }
        context.setVariable(TARGET, target);
        context.setVariable(ARGS, arguments);
        if (hasRetVal) {
            context.setVariable(RET_VAL, retVal);
        }
        Expression expression = expCache.get(keySpEL);
        if (null == expression) {
            expression = parser.parseExpression(keySpEL);
            expCache.put(keySpEL, expression);
        }
        return expression.getValue(context, valueType);
    }

}
```


Overlapping Code:
```
nds AbstractScriptParser {
/**
* # 号
*/
private static final String POUND = "#";
/**
* 撇号
*/
private static final String apostrophe = "'";
private final ExpressionParser parser = new SpelExpressionParser();
private final ConcurrentHashMap<String, Expression> expCache = new ConcurrentHashMap<String, Expression>();
private static Method hash = null;
private static Method empty = null;
static {
try {
hash = CacheUtil.class.getDeclaredMethod("getUniqueHashStr", new Class[]{Object.class});
empty = CacheUtil.class.getDeclaredMethod("isEmpty", new Class[]{Object.class});
} catch (NoSuchMethodException e) {
e.printStackTrace();
} catch (SecurityException e) {
e.printStackTrace();
} catch (Exception e) {
e.printStackTrace();
}
}
private final ConcurrentHashMap<String, Method> funcs = new ConcurrentHashMap<String, Method>(8);
/**
* @param name 方法名
* @param method 方法
*/
@Override
public void addFunction(String name, Method method) {
funcs.put(name, method);
}
@SuppressWarnings("unchecked")
@Override
public <T> T getElValue(String keySpEL, Object target, Object[] arguments, Object retVal, boolean hasRetVal,
Class<T> valueType) throws Exception {
if (valueType.equals(String.class)) {
// 如果不是表达式，直接返回字符串
if (keySpEL.indexOf(POUND) == -1 && keySpEL.indexOf("'") == -1) {
return (T) keySpEL;
}
}
StandardEvaluationContext context = new StandardEvaluationContext();
context.registerFunction(HASH, hash);
context.registerFunction(EMPTY, empty);
Iterator<Map.Entry<String, Method>> it = funcs.entrySet().iterator();
while (it.hasNext()) {
Map.Entry<String, Method> entry = it.next();
context.registerFunction(entry.getKey(), entry.getValue());
}
context.setVariable(TARGET, target);
context.setVariable(ARGS, arguments);
if (hasRetVal) {
context.setVariable(RET_VAL, retVal);
}
Expression expression = expCache.get(keySpEL);
if (null == expression) {
expression = parser.parseExpression(keySpEL);
exp
```
<Overlap Ratio: 0.9753593429158111>

---

--- 290 --
Question ID: e8fa10e616d63f166afde3879bafde0396873be0
Original Code:
```
public class Main {

	public static void main (String[] args) throws IOException {
		NameServerProxy ns = NameServerProxy.locateNS(null);
		PyroProxy remoteobject = new PyroProxy(ns.lookup("ping.playfield"));
		Object result = remoteobject.call("test", 42, "hello", new int[]{1,2,3});
		String message = (String)result;  // cast to the type that 'pythonmethod' returns
		System.out.println("result message="+message);
		remoteobject.close();
		ns.close();
	}
	
}
```


Overlapping Code:
```
public class Main {
public static void main (String[] args) throws IOException {
NameServerProxy ns = NameServerProxy.locateNS(null);
PyroProxy remoteobject = new PyroProxy(ns.lookup("ping.playfield"));
Object result = remoteobject.call("test", 42, "hello", new int[]{1,2,3});
String message = (String)result; // cast to the type that 'pythonmethod' returns
System.out.println("result message="+message);
remoteobject.close();
ns.close();

```
<Overlap Ratio: 0.9909706546275395>

---

--- 291 --
Question ID: 89e006c2e24be097b444fc1c7d7e088bdd9e3d5c
Original Code:
```
public class OrbFastBarrier implements Barrier {
  
  private final Logger logger = LoggerFactory.getLogger(OrbFastBarrier.class);
  
  private OrbConfiguration orbConf;
  private String barrierName;
  int numOfMembers;
  private String member;
  private ZooKeeper zk;
  private boolean active;
  
  /**
   * Constructs an OrbFastBarrier object.
   * 
   * @param orbConf
   *          - OrbConfiguration
   * @param barrierName
   *          - The barrier's name
   * @param numOfMembers
   *          - The total number of expected members to join under the barrier node
   * @param member
   *          - A member node's name
   * @param zk
   *          - ZooKeeper object
   */
  public OrbFastBarrier(OrbConfiguration orbConf,
                        String barrierName,
                        int numOfMembers,
                        String member,
                        ZooKeeper zk) {
    this.orbConf = orbConf;
    this.barrierName = barrierName;
    this.numOfMembers = numOfMembers;
    this.member = member;
    this.zk = zk;
    this.active = true;
  }
  
  /**
   * This method creates a new member node under the barrier node if it does not already exist. It uses a O(n)
   * algorithm.
   * 
   * @exception InterruptedException
   *              throws OrbZKFailure
   * @exception KeeperException
   *              throws OrbZKFailure
   */
  @Override
  public void enter() throws OrbZKFailure {
    // general path looks like: "/barrierName/member"
    String memberPath = barrierName + "/" + member;
    logger.debug("enter(): {}", memberPath);
    /*
     * If this barrier is the first to enter() it will create the barrier node and firstToEnter will be the
     * path of the barrier node. Otherwise firstToEnter will equal null.
     */
    String firstToEnter = ZookeeperUtils.tryToCreateNode(zk, barrierName, CreateMode.PERSISTENT);
    ZookeeperUtils.tryToCreateNode(zk, memberPath, CreateMode.EPHEMERAL);
    
    if (firstToEnter != null) { // becomes the counter for this barrier
      logger.debug("{} is the counter", memberPath);
      try {
        BarrierWatcher bw = new BarrierWatcher(this);
        List<String> memberList = zk.getChildren(barrierName, bw);
        synchronized (this) {
          while (memberList.size() < numOfMembers) {
            // synchronized(this) {
            this.wait(1000);
            memberList = zk.getChildren(barrierName, bw);
          }
        }
        logger.debug("all {} have joined, sending AllClear", memberList.size());
        // Everyone has joined, give the All Clear to move forward
        ZookeeperUtils.tryToCreateNode(zk, barrierName + "/AllClear", CreateMode.EPHEMERAL);
        // delete its node on they way out
        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);
      } catch (KeeperException e) {
        throw new OrbZKFailure(e);
      } catch (InterruptedException e) {
        throw new OrbZKFailure(e);
      }
    } else { // not first to enter, therefore just watches for the AllClear node
      try {
        logger.debug("{} not first to enter, waiting", memberPath);
        BarrierWatcher bw = new BarrierWatcher(this);
        while (zk.exists(barrierName + "/AllClear", bw) == null) {
          synchronized (this) {
            this.wait(1000);
          }
        }
        logger.debug("{} recvd AllClear, moving on", memberPath);
        // delete its node on they way out
        ZookeeperUtils.deleteNodeIfEmpty(zk, memberPath);
      } catch (KeeperException e) {
        throw new OrbZKFailure(e);
      } catch (InterruptedException e) {
        throw new OrbZKFailure(e);
      }
    }
  }
  
  /**
   * Makes this inactive.
   */
  public void makeInactive() {
    this.active = false;
  }
  
  @Override
  public void setOrbConf(OrbConfiguration orbConf) {
    this.orbConf = orbConf;
  }
  
  @Override
  public OrbConfiguration getOrbConf() {
    return orbConf;
  }
  
  /**
   * This class implements a Watcher for usage in the barrier mechanism for ZooKeeper.
   * 
   */
  class BarrierWatcher implements Watcher {
    OrbFastBarrier ofb;
    
    /**
     * This constructs a BarrierWatcher object given a configured OrbFastBarrier object.
     * 
     * @param orbFastBarrier
     */
    public BarrierWatcher(OrbFastBarrier orbFastBarrier) {
      this.ofb = orbFastBarrier;
    }
    
    /**
     * This method processes notifications triggered by Watchers.
     */
    @Override
    public synchronized void process(WatchedEvent event) {
      synchronized (ofb) {
        if (OrbFastBarrier.this.active) {
          ofb.notify();
        }
      }
    }
    
  }
  
}
```


Overlapping Code:
```
ments Barrier {

private final Logger logger = LoggerFactory.getLogger(OrbFastBarrier.class);

private OrbConfiguration orbConf;
private String barrierName;
int numOfMembers;
private String member;
private ZooKeeper zk;
private boolean active;

/**
* Constructs an OrbFastBarrier object.
* 
* @param orbConf
* - OrbConfiguration
* @param barrierName
* - The barrier's name
* @param numOfMembers
* - The total number of expected members to join under the barrier node
* @param member
* - A member node's name
* @param zk
* - ZooKeeper object
*/
public OrbFastBarrier(OrbConfiguration orbConf,
String barrierName,
int numOfMembers,
String member,
ZooKeeper zk) {
this.orbConf = orbConf;
this.barrierName = barrierName;
this.numOfMembers = numOfMembers;
this.member = member;
this.zk = zk;
this.active = true;
}

/**
* This method creates a new member node under the barrier node if it does not already exist. It uses a O(n)
* algorithm.
* 
* @exception InterruptedException
* throws OrbZKFailure
* @exception KeeperException
* throws OrbZKFailure
*/
@Override
public void enter() throws OrbZKFailure {
// general path looks like: "/barrierName/member"
String memberPath = barrierName + "/" + member;
logger.debug("enter(): {}", memberPath);
/*
* If this barrier is the first to enter() it will create the barrier node and firstToEnter will be the
* path of the barrier node. Otherwise firstToEnter will equal null.
*/
String firstToEnter = ZookeeperUtils.tryToCreateNode(zk, barrierName, CreateMode.PERSISTENT);
ZookeeperUtils.tryToCreateNode(zk, memberPath, CreateMode.EPHEMERAL);

if (firstToEnter != null) { // becomes the counter for this barrier
logger.debug("{} is the counter", memberPath);
try {
BarrierWatcher bw = new BarrierWatcher(this);
List<String> memberList = zk.getChildren(barrierName, bw);
synchronized (this) {
while (memberList.size() < numOfMembers) {
// synchronized(this) {
this.wait(1000);
memberList = zk.getChildren(barrierName, bw);
}
}
logger.debug("all {} have joined, sen
```
<Overlap Ratio: 0.9727626459143969>

---

--- 292 --
Question ID: 64f0c8be3399ea411a6b8ffb3ff3ef31f32719bf
Original Code:
```
public class ArgumentDiagramEditPart extends DiagramEditPart {

	/**
	 * @generated
	 */
	public final static String MODEL_ID = "Argument"; //$NON-NLS-1$

	/**
	 * @generated
	 */
	public static final int VISUAL_ID = 1000;

	/**
	 * @generated
	 */
	public ArgumentDiagramEditPart(View view) {
		super(view);
	}

	/**
	 * @generated
	 */
	protected void createDefaultEditPolicies() {
		super.createDefaultEditPolicies();
		installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
				new ArgumentDiagramItemSemanticEditPolicy());
		installEditPolicy(EditPolicyRoles.CANONICAL_ROLE,
				new ArgumentDiagramCanonicalEditPolicy());
		// removeEditPolicy(org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles.POPUPBAR_ROLE);
	}

	/**
	 * @generated
	 */
	/*package-local*/static class NodeLabelDragPolicy extends
			NonResizableEditPolicy {

		/**
		 * @generated
		 */
		@SuppressWarnings("rawtypes")
		protected List createSelectionHandles() {
			MoveHandle h = new MoveHandle((GraphicalEditPart) getHost());
			h.setBorder(null);
			return Collections.singletonList(h);
		}

		/**
		 * @generated
		 */
		public Command getCommand(Request request) {
			return null;
		}

		/**
		 * @generated
		 */
		public boolean understandsRequest(Request request) {
			return false;
		}
	}

	/**
	 * @generated
	 */
	/*package-local*/static class LinkLabelDragPolicy extends
			NonResizableLabelEditPolicy {

		/**
		 * @generated
		 */
		@SuppressWarnings("rawtypes")
		protected List createSelectionHandles() {
			MoveHandle mh = new MoveHandle((GraphicalEditPart) getHost());
			mh.setBorder(null);
			return Collections.singletonList(mh);
		}
	}

}
```


Overlapping Code:
```
agramEditPart extends DiagramEditPart {
/**
* @generated
*/
public final static String MODEL_ID = "Argument"; //$NON-NLS-1$
/**
* @generated
*/
public static final int VISUAL_ID = 1000;
/**
* @generated
*/
public ArgumentDiagramEditPart(View view) {
super(view);
}
/**
* @generated
*/
protected void createDefaultEditPolicies() {
super.createDefaultEditPolicies();
installEditPolicy(EditPolicyRoles.SEMANTIC_ROLE,
new ArgumentDiagramItemSemanticEditPolicy());
installEditPolicy(EditPolicyRoles.CANONICAL_ROLE,
new ArgumentDiagramCanonicalEditPolicy());
// removeEditPolicy(org.eclipse.gmf.runtime.diagram.ui.editpolicies.EditPolicyRoles.POPUPBAR_ROLE);
}
/**
* @generated
*/
/*package-local*/static class NodeLabelDragPolicy extends
NonResizableEditPolicy {
/**
* @generated
*/
@SuppressWarnings("rawtypes")
protected List createSelectionHandles() {
MoveHandle h = new MoveHandle((GraphicalEditPart) getHost());
h.setBorder(null);
return Collections.singletonList(h);
}
/**
* @generated
*/
public Command getCommand(Request request) {
return null;
}
/**
* @generated
*/
public boolean understandsRequest(Request request) {
return false;
}
}
/**
* @generated
*/
/*package-local*/static class LinkLabelDragPolicy extends
NonResizableLabelEditPolicy {
/**
* @generated
*/
@SuppressWarnings("rawtypes")
protected List createSelectionHandles() {
MoveHandle mh = new MoveHandle((GraphicalEditPart) getHost());
mh.setBorder(null);
return Collections.singlet
```
<Overlap Ratio: 0.9731543624161074>

---

--- 293 --
Question ID: d30dac85ab1b54f9487f62d51c77e43b0066bfd3
Original Code:
```
public class ConfigTom extends ConfigTrades {

	@Expose public List<String> POI_LOSS_PHRASES = new ArrayList<String>();
	@Expose public List<String> DESPAWN_PHRASES = new ArrayList<String>();
	
	@Expose public int DESPAWN_DELAY;
	
	@Expose public int TRADES_COUNT;

	public ConfigTom() {

	}

	@Override
	public String getLocation() {
		return "tom.json";
	}
	
	@Override
	protected void resetConfig() {
		this.POI_LOSS_PHRASES.add("I'm lost, where should I go?");
		this.DESPAWN_PHRASES.add("Nothing left for me here...");
		this.DESPAWN_DELAY = 24000;
		this.TRADES_COUNT = 10;
		this.DEFAULT_TRADE = new Trade(new Product(null, 0, 10, null), null, new Product(Items.DIAMOND, 0, 1, null), 5000);		
	}

}
```


Overlapping Code:
```
ic class ConfigTom extends ConfigTrades {
@Expose public List<String> POI_LOSS_PHRASES = new ArrayList<String>();
@Expose public List<String> DESPAWN_PHRASES = new ArrayList<String>();

@Expose public int DESPAWN_DELAY;

@Expose public int TRADES_COUNT;
public ConfigTom() {
}
@Override
public String getLocation() {
return "tom.json";
}

@Override
protected void resetConfig() {
this.POI_LOSS_PHRASES.add("I'm lost, where should I go?");
this.DESPAWN_PHRASES.add("Nothing left for me here...");
this.DESPAWN_DELAY = 24000;
this.TRADES_COUNT = 10;
this.DEFAULT_TRADE = new Trade(new Product(null, 0, 10, null), null, new Product(Items.DIAMOND, 0, 1, 
```
<Overlap Ratio: 0.9672619047619048>

---

--- 294 --
Question ID: 936d97f1ec6dbfa587ccd5bec549a5ae12f0229d
Original Code:
```
public class CustomAlertDialog extends AlertDialog {

    private View view;

    private Thread thread;

    @SuppressLint("InflateParams")
    public CustomAlertDialog(@NonNull Context context, @LayoutRes int resource) {
        super(context);
        if (this.getWindow() != null) {
            this.getWindow().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT));
        }
        this.view = ((Activity) context).getLayoutInflater().inflate(resource, null);
        this.setView(this.view, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0);
    }

    public CustomAlertDialog canceled(boolean b) {
        this.setCancelable(b);
        return this;
    }

    public View getView() {
        return view;
    }

    private View getV(@IdRes int id) {
        return this.view.findViewById(id);
    }

    public TextView getTV(@IdRes int id) {
        return this.view.findViewById(id);
    }

    public ImageView getIV(@IdRes int id) {
        return this.view.findViewById(id);
    }

    public Button getBV(@IdRes int id) {
        return this.view.findViewById(id);
    }

    public CustomAlertDialog setText(@IdRes int id, @StringRes int s) {
        this.setText(id, this.getContext().getResources().getString(s));
        return this;
    }

    public CustomAlertDialog setText(@IdRes int id, String s) {
        this.getTV(id).setText(s);
        return this;
    }

    public CustomAlertDialog setVisible(@IdRes int id, int visible) {
        this.getV(id).setVisibility(visible);
        return this;
    }

    public CustomAlertDialog setClickListener(@IdRes int id1, @IdRes int id2, View.OnClickListener listener) {
        this.getV(id1).findViewById(id2).setOnClickListener(listener);
        return this;
    }

    public CustomAlertDialog setClickListener(@IdRes int id, View.OnClickListener listener) {
        this.getV(id).setOnClickListener(listener);
        return this;
    }

    public CustomAlertDialog setDismissListener(Dialog.OnDismissListener listener) {
        this.setOnDismissListener(listener);
        return this;
    }

    public CustomAlertDialog mShow() {
        this.show();
        if (this.thread != null) {
            this.thread.start();
        }
        return this;
    }

    public CustomAlertDialog setThread(Thread thread) {
        this.thread = thread;
        return this;
    }

    public void mDismiss() {
        if (this.thread != null) {
            this.thread.interrupt();
            this.thread = null;
        }
        this.dismiss();
    }
}
```


Overlapping Code:
```
rtDialog extends AlertDialog {
private View view;
private Thread thread;
@SuppressLint("InflateParams")
public CustomAlertDialog(@NonNull Context context, @LayoutRes int resource) {
super(context);
if (this.getWindow() != null) {
this.getWindow().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.TRANSPARENT));
}
this.view = ((Activity) context).getLayoutInflater().inflate(resource, null);
this.setView(this.view, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0, (int) getContext().getResources().getDimension(R.dimen.space_20dp), 0);
}
public CustomAlertDialog canceled(boolean b) {
this.setCancelable(b);
return this;
}
public View getView() {
return view;
}
private View getV(@IdRes int id) {
return this.view.findViewById(id);
}
public TextView getTV(@IdRes int id) {
return this.view.findViewById(id);
}
public ImageView getIV(@IdRes int id) {
return this.view.findViewById(id);
}
public Button getBV(@IdRes int id) {
return this.view.findViewById(id);
}
public CustomAlertDialog setText(@IdRes int id, @StringRes int s) {
this.setText(id, this.getContext().getResources().getString(s));
return this;
}
public CustomAlertDialog setText(@IdRes int id, String s) {
this.getTV(id).setText(s);
return this;
}
public CustomAlertDialog setVisible(@IdRes int id, int visible) {
this.getV(id).setVisibility(visible);
return this;
}
public CustomAlertDialog setClickListener(@IdRes int id1, @IdRes int id2, View.OnClickListener listener) {
this.getV(id1).findViewById(id2).setOnClickListener(listener);
return this;
}
public CustomAlertDialog setClickListener(@IdRes int id, View.OnClickListener listener) {
this.getV(id).setOnClickListener(listener);
return this;
}
public CustomAlertDialog setDismissListener(Dialog.OnDismissListener listener) {
this.setOnDismissListener(listener);
return this;
}
public CustomAlertDialog mShow() {
this.show();
if (this.thread != null) {
this.thread.start();
}
return this;
}
public CustomAlertDialog setThread(Thread thread) {
this.thread = thread;
return this;
}
public void mDi
```
<Overlap Ratio: 0.9851033157135992>

---

--- 295 --
Question ID: b0ac5571a153fa419266c1daafe7f8e5c6a29352
Original Code:
```
public class Vlan extends VdsNetworkInterface {

    private static final long serialVersionUID = -2458958954004227402L;

    public Vlan() {
    }

    public Vlan(int vlanId) {
        setVlanId(vlanId);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" {id=")
                .append(getId())
                .append(", vdsId=")
                .append(getVdsId())
                .append(", name=")
                .append(getName())
                .append(", networkName=")
                .append(getNetworkName())
                .append(", vlanId=")
                .append(getVlanId())
                .append(", bootProtocol=")
                .append(getBootProtocol())
                .append(", address=")
                .append(getAddress())
                .append(", subnet=")
                .append(getSubnet())
                .append(", gateway=")
                .append(getGateway())
                .append(", mtu=")
                .append(getMtu())
                .append(", bridged=")
                .append(isBridged())
                .append(", type=")
                .append(getType())
                .append(", networkImplementationDetails=")
                .append(getNetworkImplementationDetails())
                .append("}");
        return builder.toString();
    }
}
```


Overlapping Code:
```
an extends VdsNetworkInterface {
private static final long serialVersionUID = -2458958954004227402L;
public Vlan() {
}
public Vlan(int vlanId) {
setVlanId(vlanId);
}
@Override
public String toString() {
StringBuilder builder = new StringBuilder();
builder.append(getName())
.append(" {id=")
.append(getId())
.append(", vdsId=")
.append(getVdsId())
.append(", name=")
.append(getName())
.append(", networkName=")
.append(getNetworkName())
.append(", vlanId=")
.append(getVlanId())
.append(", bootProtocol=")
.append(getBootProtocol())
.append(", address=")
.append(getAddress())
.append(", subnet=")
.append(getSubnet())
.append(", gateway=")
.append(getGateway())
.append(", mtu=")
.append(getMtu())
.append(", bridged=")
.append(isBridged())
.append(", type=")
.append(getType())
.append(", networkImplementationDetails=")
.append(getNetworkImplementationDetails())
.append("}");
return builder.toSt
```
<Overlap Ratio: 0.9719222462203023>

---

--- 296 --
Question ID: 0f2d56bf9f383d3d665dfc69b4de68bbb210d464
Original Code:
```
public class ConstraintsAspectDescriptor extends BaseConstraintsAspectDescriptor {
  public ConstraintsAspectDescriptor() {
  }

  @Override
  public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {
    SAbstractConcept cncpt = concept;
    switch (conceptIndex.index(cncpt)) {
      case 0:
        return new AnalogCondition_Constraints();
      case 1:
        return new AnalogSensor_Constraints();
      case 2:
        return new Brick_Constraints();
      case 3:
        return new LogicalSensor_Constraints();
      case 4:
        return new State_Constraints();
      default:
    }
    return new BaseConstraintsDescriptor(concept);
  }
  private static final ConceptSwitchIndex conceptIndex = new ConceptSwitchIndexBuilder().put(MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271b69b0L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271951bbL), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685e1L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df27195156L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685daL)).seal();
}
```


Overlapping Code:
```
public class ConstraintsAspectDescriptor extends BaseConstraintsAspectDescriptor {
public ConstraintsAspectDescriptor() {
}
@Override
public ConstraintsDescriptor getConstraints(SAbstractConcept concept) {
SAbstractConcept cncpt = concept;
switch (conceptIndex.index(cncpt)) {
case 0:
return new AnalogCondition_Constraints();
case 1:
return new AnalogSensor_Constraints();
case 2:
return new Brick_Constraints();
case 3:
return new LogicalSensor_Constraints();
case 4:
return new State_Constraints();
default:
}
return new BaseConstraintsDescriptor(concept);
}
private static final ConceptSwitchIndex conceptIndex = new ConceptSwitchIndexBuilder().put(MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271b69b0L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df271951bbL), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685e1L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x6b9055df27195156L), MetaIdFactory.conceptId(0x6d5f556878454ac1L, 0xba976d57e4d58942L, 0x3c2a1b6d4a4685daL)
```
<Overlap Ratio: 0.9900181488203267>

---

--- 297 --
Question ID: b8bb6b2cb38b07114e8e23658909565c6308dd07
Original Code:
```
public class FindPersonCommandParserTest {

    private FindPersonCommandParser parser = new FindPersonCommandParser();

    @Test
    public void parse_emptyArg_throwsParseException() {
        assertParseFailure(parser, "     ", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
            FindPersonCommand.MESSAGE_USAGE));
    }

    @Test
    public void parse_validArgs_returnsFindCommand() {
        // no leading and trailing whitespaces
        FindPersonCommand expectedFindPersonCommand =
                new FindPersonCommand(new NameContainsKeywordsPredicate(Arrays.asList("Alice", "Bob")));
        assertParseSuccess(parser, "Alice Bob", expectedFindPersonCommand);

        // multiple whitespaces between keywords
        assertParseSuccess(parser, " \n Alice \n \t Bob  \t", expectedFindPersonCommand);
    }

}
```


Overlapping Code:
```
c class FindPersonCommandParserTest {
private FindPersonCommandParser parser = new FindPersonCommandParser();
@Test
public void parse_emptyArg_throwsParseException() {
assertParseFailure(parser, " ", String.format(MESSAGE_INVALID_COMMAND_FORMAT,
FindPersonCommand.MESSAGE_USAGE));
}
@Test
public void parse_validArgs_returnsFindCommand() {
// no leading and trailing whitespaces
FindPersonCommand expectedFindPersonCommand =
new FindPersonCommand(new NameContainsKeywordsPredicate(Arrays.asList("Alice", "Bob")));
assertParseSuccess(parser, "Alice Bob", expectedFindPersonCommand);
// multiple whitespaces between keywords
assertParseSuccess(parser, " \n Alice \n \t Bob \t", expectedFindPersonCommand);

```
<Overlap Ratio: 0.9887640449438202>

---

--- 298 --
Question ID: 0189f1401135c38ee4bd5d4ebb276d6413b9ee3b
Original Code:
```
@Stateless
public class MedioDePagoLogic {

    private static final Logger LOGGER = Logger.getLogger(MedioDePagoLogic.class.getName());
    
    @Inject
    private MedioDePagoPersistence persistence;
    

    /**
     * Crea una nueva entidad MedioDePago.
     * @param entity La entidad de tipo MedioDePago que se va a persistir.
     * @return La entidad luego de persistirla.
     * @throws BusinessLogicException Si ya existe un MedioDePago con esa
     * informacion.
     */
    public MedioDePagoEntity createMedioDePago(MedioDePagoEntity entity) throws BusinessLogicException {
        LOGGER.info("Inicia el proceso de creacion de un nuevo medio de pago");
        if(persistence.findByReferencia(entity.getNumeroReferencia()) != null)
        {
            throw new BusinessLogicException("Ya existe un medio de pago con ese numero de referencia:" + entity.getNumeroReferencia());        
        }
        else if(persistence.findByTipo(entity.getTipo()) != null)
        {
            throw new BusinessLogicException("Ya existe un medio de pago con ese tipo:" + entity.getTipo());
        }
        persistence.create(entity);
        LOGGER.info("Termina el proceso de creacion del medio de pago");
        return entity;
    }

    /**
     * *
     * Obtiene todos los MedioDePago que hay en la base de datos.
     * @return Lista de la entidades de tipo MedioDePago.
     */
    public List<MedioDePagoEntity> getMediosDePago()  {
        LOGGER.info("Inicia el proceso de consultar todos los medio de pago");
        List<MedioDePagoEntity> list = persistence.findAll();
        LOGGER.info("Termina el proceso de consultar todos los medio de pago");
        return list;
    }

    /**
     * Obtiene un MedioDePago con el id especificado.
     * @param id  Identificador del medio de pago.
     * @return El MedioDePago correspondiente a el id.
     */
    public MedioDePagoEntity getMedioDePago(Long id) {
        LOGGER.log(Level.INFO,"Inicia el proceso de consultar un medio de pago con id={0}", id);
        MedioDePagoEntity medio = persistence.find(id);
        if(medio == null)
        {
            LOGGER.log(Level.SEVERE, "El medio de pago con el id={0} no existe", id);
        }
        return  medio;
    }

    /**
     * Actualiza un MedioDePago con el id dado.
     * @param id Identificador del medio de pago.
     * @param entity Nueva informacion del MedioDePago.
     * @return La entidad MedioDePago con la nueva informacion.
     * @throws BusinessLogicException Excepciones por reglas de negocio.
     */   
    public MedioDePagoEntity updateMedioDePago(Long id, MedioDePagoEntity entity) throws BusinessLogicException {
        LOGGER.log(Level.SEVERE, "Inicia el proceso de actualizar un medio de pago");
        MedioDePagoEntity medio = persistence.find(id);
        if(medio == null)
        {
            LOGGER.log(Level.SEVERE, "El medio de pago con el id={0} no existe para ser actualizado", entity.getId());
        }
        else if (persistence.findByReferencia(entity.getNumeroReferencia()) != null)
        {
          throw new BusinessLogicException("Ya existe un medio de pago con ese numero de referencia:" + entity.getNumeroReferencia());        
        }
        else if(persistence.findByTipo(entity.getTipo()) != null)
        {
            throw new BusinessLogicException("Ya existe un medio de pago con ese tipo:" + entity.getTipo());
        }
        persistence.update(entity);
        return entity;
    }

    /**
     * *
     * Elimina un MedioDePago segun el id.
     * @param id Identificador del MedioDePago a eliminar.
     */
    public void deleteMedioDePago( Long id) {
        LOGGER.log(Level.SEVERE, "Inicia el proceso de eliminar un cliente");
        MedioDePagoEntity medio = persistence.find(id); 
        if(medio == null)
        {
            LOGGER.log(Level.SEVERE, "El medio de pago con el id={0} no existe para ser elimiado", id);
        }
        persistence.delete(id);
        LOGGER.log(Level.SEVERE, "Termina el proceso de eliminar un medui de pago");    
    }

    /**
     * Obtiene una coleccion de las instacias de cliente asociadas a un medio de pago.
     * @param id Identificador del medio pago.
     * @return Coleccion de las instacias de clientes asociadas a un medio de pago.
     */
    public List<ClienteEntity> listClientes (Long id)
    {
        LOGGER.log(Level.INFO, "Inicia proceso de consultar todos los clientes del medio de pago con id = {0}", id);
        return getMedioDePago(id).getClientes();
    }
    
    /**
     * Obtiene un cliente existente asociado a un medio de pago especifico.
     * @param id Identificador del medio de pago.
     * @param clienteId Identificador del cliente.
     * @return La instancia de cliente asociado al medio de pago.
     */
    public ClienteEntity getCliente (Long id, Long clienteId){
       LOGGER.log(Level.INFO, "Inicia proceso de consultar un cliente que utiliza el medio de pago con id = {0}", id);
       List<ClienteEntity> list = getMedioDePago(id).getClientes();
       ClienteEntity clientesEntity = new ClienteEntity();
       clientesEntity.setId(clienteId);
       int index = list.indexOf(clientesEntity);
        if (index >= 0) {
            return list.get(index);
        }
        return null;
   }
   
    /**
     * Asocia un cliente a un medio de pago especifico.
     * @param id Identificador del medio de pago.
     * @param clienteId Identificador del cliente a asociar.
     * @return El cliente ahora asociado al medio de pago.
     */
   public ClienteEntity addCliente(Long id, Long clienteId){
       MedioDePagoEntity medio = getMedioDePago(id);
       ClienteEntity cliente = new ClienteEntity();
       cliente.setId(clienteId);
       medio.getClientes().add(cliente);
       return getCliente(id, clienteId);
   }
   
   /**
    * Reeplaza la informacion de los clientes asociados al medio de pago.
    * @param id Identificador del medio de pago.
    * @param  list Coleccion de clientes con la nueva informacion a actualizar
     * respecto a los clientes asociados.
    * @return Los clientes asociados al medio de pago.
    */
   public List<ClienteEntity> replaceCliente (Long id, List<ClienteEntity> list){
       MedioDePagoEntity medio = getMedioDePago(id);
       medio.setClientes(list);
       return medio.getClientes();
   }
   
   /**
    * Desasocia un cliente existente de un medio de pago.
    * @param id Identificador del medio de pago
    * @param clienteId Identificador del cliente a retirar.
    */
   public void removeCliente(Long id, Long clienteId){
       MedioDePagoEntity medio = getMedioDePago(id);
       ClienteEntity cliente = new ClienteEntity();
       cliente.setId(clienteId);
       medio.getClientes().remove(cliente);
   }
}
```


Overlapping Code:
```
less
public class MedioDePagoLogic {
private static final Logger LOGGER = Logger.getLogger(MedioDePagoLogic.class.getName());

@Inject
private MedioDePagoPersistence persistence;

/**
* Crea una nueva entidad MedioDePago.
* @param entity La entidad de tipo MedioDePago que se va a persistir.
* @return La entidad luego de persistirla.
* @throws BusinessLogicException Si ya existe un MedioDePago con esa
* informacion.
*/
public MedioDePagoEntity createMedioDePago(MedioDePagoEntity entity) throws BusinessLogicException {
LOGGER.info("Inicia el proceso de creacion de un nuevo medio de pago");
if(persistence.findByReferencia(entity.getNumeroReferencia()) != null)
{
throw new BusinessLogicException("Ya existe un medio de pago con ese numero de referencia:" + entity.getNumeroReferencia()); 
}
else if(persistence.findByTipo(entity.getTipo()) != null)
{
throw new BusinessLogicException("Ya existe un medio de pago con ese tipo:" + entity.getTipo());
}
persistence.create(entity);
LOGGER.info("Termina el proceso de creacion del medio de pago");
return entity;
}
/**
* *
* Obtiene todos los MedioDePago que hay en la base de datos.
* @return Lista de la entidades de tipo MedioDePago.
*/
public List<MedioDePagoEntity> getMediosDePago() {
LOGGER.info("Inicia el proceso de consultar todos los medio de pago");
List<MedioDePagoEntity> list = persistence.findAll();
LOGGER.info("Termina el proceso de consultar todos los medio de pago");
return list;
}
/**
* Obtiene un MedioDePago con el id especificado.
* @param id Identificador del medio de pago.
* @return El MedioDePago correspondiente a el id.
*/
public MedioDePagoEntity getMedioDePago(Long id) {
LOGGER.log(Level.INFO,"Inicia el proceso de consultar un medio de pago con id={0}", id);
MedioDePagoEntity medio = persistence.find(id);
if(medio == null)
{
LOGGER.log(Level.SEVERE, "El medio de pago con el id={0} no existe", id);
}
return medio;
}
/**
* Actualiza un MedioDePago con el id dado.
* @param id Identificador del medio de pago.
* @param entity Nueva informacion del MedioDePago.
* @return La entidad MedioDePago con la n
```
<Overlap Ratio: 0.9789029535864979>

---

--- 299 --
Question ID: cd08f04da2392b2f07f4b2f9178cf5466713bc00
Original Code:
```
public class FileManager {
    
    /**
     * Internal reference to a tabbed panel
     */
    private JTabbedPane tabs;
    
    /*
    * Internal reference to the font size
    */
    private float fontSize = (new JLabel()).getFont().getSize();
    
    /**
     * Internal class to represent tab data
     */
    private class Tab {
        String name;
        String filepath;
        JScrollPane panel;
        CodeEditor editor;
        boolean edited = false;
        
        public void setChanged(boolean changed, JTabbedPane parent){
            boolean updated = changed != edited;
            this.edited = changed;
            this.panel.setName(this.name + (this.edited ? "*" : ""));
            if(updated){
                int idx = parent.indexOfComponent(this.panel);
                if(idx >= 0){
                    parent.setTitleAt(idx, this.panel.getName());
                }
            }
        }
    }
    
    /**
     * List of tab data
     */
    private LinkedList<Tab> openTabs = new LinkedList<Tab>();
    
    /**
     * Create a file manager
     */
    public FileManager(){
        tabs = new JTabbedPane();
        tabs.setAutoscrolls(false);
    }
    
    /**
     * Create an empty file
     */
    public void empty(){
        open(null);
    }
    
    public void setFontSize(float f){
        this.fontSize = f;
        for(Tab tab : openTabs){
            tab.editor.setFont(tab.editor.getFont().deriveFont(this.fontSize));
        }
    }
    
    /**
     * Open a file in the editor
     * @param file 
     */
    public void open(String file){
        try{
            Tab t = new Tab();
            t.name = null;
            
            try{
                t.name = new File(file).getName();
            }catch(Exception e){
                JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            }
            
            t.filepath = file;
            
            CodeEditor editor = new CodeEditor();
            editor.setFont(editor.getFont().deriveFont(fontSize));
            editor.setBackground(new Color(253, 247, 225));
            //First word of line colour
            editor.addStyle("(?:^|\\n)\\s*.*?(?=(?:$|\\s))", new Color(99,125,160));
            //Keyword colour
            editor.addStyle("\\b(?:begin|end|measure)\\b", new Color(168, 23, 141));
            //Label colour
            editor.addStyle("\\..+", new Color(236, 173, 135));
            //String colour
            editor.addStyle("\\\"[^\\r\\n]*?\\\"", new Color(236, 173, 135));
            //Comment colour
            editor.addStyle("\\/\\/.*?(?=(?:\\n|$))", new Color(111, 159, 147));
            
            JScrollPane editor_scroll = new JScrollPane(editor);
            editor_scroll.getVerticalScrollBar().setUnitIncrement(16);
            editor_scroll.setAutoscrolls(false);
            
            t.editor = editor;
            t.panel = editor_scroll;
            t.panel.setName(t.name);
            
            try{
                String content = String.join("\n",Files.readAllLines(Paths.get(file)));
                t.editor.setText(content);
            }catch(Exception e){
                JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            }
            
            editor.addChangeListener((str) -> {
                t.setChanged(true, tabs);
            });
            
            tabs.add(t.panel);
            tabs.repaint();
            
            AutoComplete auto = new AutoComplete(editor);
            auto.setCharactersUntilSuggestions(2);
            auto.addWord("measure");
            auto.addWord("qreg");
            auto.addWord("creg");
            auto.addWord("import");
            auto.addWord("begin");
            auto.addWord("end");
            
            auto.addWord("ccnot");
            auto.addWord("toffoli");
            auto.addWord("cnot");
            auto.addWord("cx");
            auto.addWord("cy");
            auto.addWord("cz");
            
            openTabs.add(t);
        }catch(Exception e){
            JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    /**
     * Save the current file
     */
    public void save(){
        try{
            int i = tabs.getSelectedIndex();
            if(i < 0)
                return;
            Tab openTab = openTabs.get(i);
            if(openTab.name == null){
                //Create a file chooser
                final JFileChooser fc = new JFileChooser();
                //In response to a button click:
                int returnVal = fc.showSaveDialog(null);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    File file = fc.getSelectedFile();
                    try(PrintWriter pw = new PrintWriter(file.getAbsolutePath())){
                        pw.print(openTab.editor.getText());
                    }
                    openTab.name = file.getName();
                    openTab.filepath = file.getAbsolutePath();
                    //JOptionPane.showMessageDialog(null, "File: " + openTab.name, "Saved", JOptionPane.INFORMATION_MESSAGE);
                    openTab.setChanged(false, tabs);
                }
            }else{
                try(PrintWriter pw = new PrintWriter(openTab.filepath)){
                    pw.print(openTab.editor.getText());
                }
                //JOptionPane.showMessageDialog(null, "File: " + openTab.name, "Saved", JOptionPane.INFORMATION_MESSAGE);
                openTab.setChanged(false, tabs);
            }
        }catch(Exception e){
            JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
    
    /**
     * Close the current file
     */
    public void close(){
        int i = tabs.getSelectedIndex();
        if(i < 0)
            return;
        Tab openTab = openTabs.get(i);
        tabs.remove(openTab.panel);
        openTabs.remove(openTab);
        tabs.repaint();
    }
    
    /**
     * Get the current file
     * @return 
     */
    public File getActive(){
        int i = tabs.getSelectedIndex();
        if(i < 0)
            return null;
        Tab openTab = openTabs.get(i);
        return new File(openTab.filepath);
    }
    
    /**
     * Get the internal reference to the tabbed panel
     * @return 
     */
    public JTabbedPane getPanel(){
        return tabs;
    }
    
}
```


Overlapping Code:
```
eManager {

/**
* Internal reference to a tabbed panel
*/
private JTabbedPane tabs;

/*
* Internal reference to the font size
*/
private float fontSize = (new JLabel()).getFont().getSize();

/**
* Internal class to represent tab data
*/
private class Tab {
String name;
String filepath;
JScrollPane panel;
CodeEditor editor;
boolean edited = false;

public void setChanged(boolean changed, JTabbedPane parent){
boolean updated = changed != edited;
this.edited = changed;
this.panel.setName(this.name + (this.edited ? "*" : ""));
if(updated){
int idx = parent.indexOfComponent(this.panel);
if(idx >= 0){
parent.setTitleAt(idx, this.panel.getName());
}
}
}
}

/**
* List of tab data
*/
private LinkedList<Tab> openTabs = new LinkedList<Tab>();

/**
* Create a file manager
*/
public FileManager(){
tabs = new JTabbedPane();
tabs.setAutoscrolls(false);
}

/**
* Create an empty file
*/
public void empty(){
open(null);
}

public void setFontSize(float f){
this.fontSize = f;
for(Tab tab : openTabs){
tab.editor.setFont(tab.editor.getFont().deriveFont(this.fontSize));
}
}

/**
* Open a file in the editor
* @param file 
*/
public void open(String file){
try{
Tab t = new Tab();
t.name = null;

try{
t.name = new File(file).getName();
}catch(Exception e){
JOptionPane.showMessageDialog(null, e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);
}

t.filepath = file;

CodeEditor editor = new CodeEditor();
editor.setFont(editor.getFont().deriveFont(fontSize));
editor.setBackground(new Color(253, 247, 225));
//First word of line colour
editor.addStyle("(?:^|\\n)\\s*.*?(?=(?:$|\\s))", new Color(99,125,160));
//Keyword colour
editor.addStyle("\\b(?:begin|end|measure)\\b", new Color(168, 23, 141));
//La
```
<Overlap Ratio: 0.984936268829664>

---

--- 300 --
Question ID: 98a43751f61b2282759e3165647f194c7c736d5d
Original Code:
```
public class ParabolicSarIndicator extends RecursiveCachedIndicator<Num> {

    private final Num maxAcceleration;
    private final Num accelerationIncrement;
    private final Num accelerationStart;
    private Num accelerationFactor;
    private boolean currentTrend; // true if uptrend, false otherwise
    private int startTrendIndex = 0; // index of start bar of the current trend
    private LowPriceIndicator lowPriceIndicator;
    private HighPriceIndicator highPriceIndicator;
    private Num currentExtremePoint; // the extreme point of the current calculation
    private Num minMaxExtremePoint; // depending on trend the maximum or minimum extreme point value of trend

    /**
     * Constructor with default parameters
     *
     * @param series the bar series for this indicator
     */
    public ParabolicSarIndicator(BarSeries series) {
        this(series, series.numOf(0.02), series.numOf(0.2), series.numOf(0.02));

    }

    /**
     * Constructor with custom parameters and default increment value
     *
     * @param series the bar series for this indicator
     * @param aF     acceleration factor
     * @param maxA   maximum acceleration
     */
    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA) {
        this(series, aF, maxA, series.numOf(0.02));
    }

    /**
     * Constructor with custom parameters
     *
     * @param series    the bar series for this indicator
     * @param aF        acceleration factor
     * @param maxA      maximum acceleration
     * @param increment the increment step
     */
    public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA, Num increment) {
        super(series);
        highPriceIndicator = new HighPriceIndicator(series);
        lowPriceIndicator = new LowPriceIndicator(series);
        maxAcceleration = maxA;
        accelerationFactor = aF;
        accelerationIncrement = increment;
        accelerationStart = aF;
    }

    @Override
    protected Num calculate(int index) {
        Num sar = NaN;
        if (index == getBarSeries().getBeginIndex()) {
            return sar; // no trend detection possible for the first value
        } else if (index == getBarSeries().getBeginIndex() + 1) {// start trend detection
            currentTrend = getBarSeries().getBar(getBarSeries().getBeginIndex()).getClosePrice()
                    .isLessThan(getBarSeries().getBar(index).getClosePrice());
            if (!currentTrend) { // down trend
                sar = highPriceIndicator.getValue(index); // put sar on max price of candlestick
                currentExtremePoint = sar;
                minMaxExtremePoint = currentExtremePoint;
            } else { // up trend
                sar = lowPriceIndicator.getValue(index); // put sar on min price of candlestick
                currentExtremePoint = sar;
                minMaxExtremePoint = currentExtremePoint;

            }
            return sar;
        }

        Num priorSar = getValue(index - 1);
        if (currentTrend) { // if up trend
            sar = priorSar.plus(accelerationFactor.multipliedBy((currentExtremePoint.minus(priorSar))));
            currentTrend = lowPriceIndicator.getValue(index).isGreaterThan(sar);
            if (!currentTrend) { // check if sar touches the min price
                sar = minMaxExtremePoint; // sar starts at the highest extreme point of previous up trend
                currentTrend = false; // switch to down trend and reset values
                startTrendIndex = index;
                accelerationFactor = accelerationStart;
                currentExtremePoint = getBarSeries().getBar(index).getLowPrice(); // put point on max
                minMaxExtremePoint = currentExtremePoint;
            } else { // up trend is going on
                currentExtremePoint = new HighestValueIndicator(highPriceIndicator, index - startTrendIndex)
                        .getValue(index);
                if (currentExtremePoint.isGreaterThan(minMaxExtremePoint)) {
                    incrementAcceleration();
                    minMaxExtremePoint = currentExtremePoint;
                }

            }
        } else { // downtrend
            sar = priorSar.minus(accelerationFactor.multipliedBy(((priorSar.minus(currentExtremePoint)))));
            currentTrend = highPriceIndicator.getValue(index).isGreaterThanOrEqual(sar);
            if (currentTrend) { // check if switch to up trend
                sar = minMaxExtremePoint; // sar starts at the lowest extreme point of previous down trend
                accelerationFactor = accelerationStart;
                startTrendIndex = index;
                currentExtremePoint = getBarSeries().getBar(index).getHighPrice();
                minMaxExtremePoint = currentExtremePoint;
            } else { // down trend io going on
                currentExtremePoint = new LowestValueIndicator(lowPriceIndicator, index - startTrendIndex)
                        .getValue(index);
                if (currentExtremePoint.isLessThan(minMaxExtremePoint)) {
                    incrementAcceleration();
                    minMaxExtremePoint = currentExtremePoint;
                }
            }
        }
        return sar;
    }

    /**
     * Increments the acceleration factor.
     */
    private void incrementAcceleration() {
        if (accelerationFactor.isGreaterThanOrEqual(maxAcceleration)) {
            accelerationFactor = maxAcceleration;
        } else {
            accelerationFactor = accelerationFactor.plus(accelerationIncrement);
        }
    }
}
```


Overlapping Code:
```
ParabolicSarIndicator extends RecursiveCachedIndicator<Num> {
private final Num maxAcceleration;
private final Num accelerationIncrement;
private final Num accelerationStart;
private Num accelerationFactor;
private boolean currentTrend; // true if uptrend, false otherwise
private int startTrendIndex = 0; // index of start bar of the current trend
private LowPriceIndicator lowPriceIndicator;
private HighPriceIndicator highPriceIndicator;
private Num currentExtremePoint; // the extreme point of the current calculation
private Num minMaxExtremePoint; // depending on trend the maximum or minimum extreme point value of trend
/**
* Constructor with default parameters
*
* @param series the bar series for this indicator
*/
public ParabolicSarIndicator(BarSeries series) {
this(series, series.numOf(0.02), series.numOf(0.2), series.numOf(0.02));
}
/**
* Constructor with custom parameters and default increment value
*
* @param series the bar series for this indicator
* @param aF acceleration factor
* @param maxA maximum acceleration
*/
public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA) {
this(series, aF, maxA, series.numOf(0.02));
}
/**
* Constructor with custom parameters
*
* @param series the bar series for this indicator
* @param aF acceleration factor
* @param maxA maximum acceleration
* @param increment the increment step
*/
public ParabolicSarIndicator(BarSeries series, Num aF, Num maxA, Num increment) {
super(series);
highPriceIndicator = new HighPriceIndicator(series);
lowPriceIndicator = new LowPriceIndicator(series);
maxAcceleration = maxA;
accelerationFactor = aF;
accelerationIncrement = increment;
accelerationStart = aF;
}
@Override
protected Num calculate(int index) {
Num sar = NaN;
if (index == getBarSeries().getBeginIndex()) {
return sar; // no trend detection possible for the first value
} else if (index == getBarSeries().getBeginIndex() + 1) {// start trend detection
currentTrend = getBarSeries().getBar(getBarSeries().getBeginIndex()).getClosePrice()
.isLessThan(getBarSeries().getBar(index).getClosePrice());
if (!currentTrend) { // do
```
<Overlap Ratio: 0.9784543325526932>

---

--- 301 --
Question ID: 41514e9056b071c02de5f1eca89a0e5a059236d9
Original Code:
```
public class A44_Printf {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        double sum = 0.0;
        int sign = 1;
        for ( int i =1; i<=n; i++, sign = -sign) {
            sum += sign+1.0/i;
            // i ++;
            // sign = -sign;
        }
        System.out.println(sum);
        System.out.printf("%.2f",sum);
    }
}
```


Overlapping Code:
```
Printf {
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int n = in.nextInt();
double sum = 0.0;
int sign = 1;
for ( int i =1; i<=n; i++, sign = -sign) {
sum += sign+1.0/i;
// i ++;
// sign = -sign;
}
System.out.println(sum);
System.out.printf("%.2f",
```
<Overlap Ratio: 0.9153094462540716>

---

--- 302 --
Question ID: 8efddaf039ff96eacb880145a6677f6977b81e86
Original Code:
```
public class AppbarCustomizer {

    public static void configureAppbar(Activity activity, boolean showBackArrow) {
        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();
        if (actionBar != null) {
            actionBar.setDisplayUseLogoEnabled(!showBackArrow);
            actionBar.setDisplayShowHomeEnabled(!showBackArrow);
            actionBar.setDisplayHomeAsUpEnabled(showBackArrow);
            if (!showBackArrow) actionBar.setIcon(R.mipmap.ic_launcher);
        }
    }

    public static void changeAppbarColor(Activity activity, @ColorRes int id) {
        ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();
        if (actionBar != null) actionBar.setBackgroundDrawable(new ColorDrawable(activity.getResources().getColor(id)));
    }

    public static void changeAppbarTitle (Activity activity, @StringRes int id) {
        changeAppbarTitle(activity, activity.getResources().getString(id));
    }

    public static void changeAppbarTitle(Activity activity, String text) {
        ActionBar actionBar = ((AppCompatActivity)activity).getSupportActionBar();
        if (actionBar != null) actionBar.setTitle(fontifyString(activity, text));
    }

    public static SpannableString fontifyString(Context context, String text) {
        SpannableString string = new SpannableString(text);
        string.setSpan(new TypefaceSpan(context, FONT_NAME), 0, string.length(),
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        return string;
    }
}
```


Overlapping Code:
```
c void configureAppbar(Activity activity, boolean showBackArrow) {
ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();
if (actionBar != null) {
actionBar.setDisplayUseLogoEnabled(!showBackArrow);
actionBar.setDisplayShowHomeEnabled(!showBackArrow);
actionBar.setDisplayHomeAsUpEnabled(showBackArrow);
if (!showBackArrow) actionBar.setIcon(R.mipmap.ic_launcher);
}
}
public static void changeAppbarColor(Activity activity, @ColorRes int id) {
ActionBar actionBar = ((AppCompatActivity) activity).getSupportActionBar();
if (actionBar != null) actionBar.setBackgroundDrawable(new ColorDrawable(activity.getResources().getColor(id)));
}
public static void changeAppbarTitle (Activity activity, @StringRes int id) {
changeAppbarTitle(activity, activity.getResources().getString(id));
}
public static void changeAppbarTitle(Activity activity, String text) {
ActionBar actionBar = ((AppCompatActivity)activity).getSupportActionBar();
if (actionBar != null) actionBar.setTitle(fontifyString(activity, text));
}
public static SpannableString fontifyString(Context context, String text) {
SpannableString string = new SpannableString(text);
string.setSpan(new TypefaceSpan(context, FONT_NAME), 0, string.length(),
Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
return string
```
<Overlap Ratio: 0.9630746043707611>

---

--- 303 --
Question ID: a6c66284c7bdc3794f7e3328e89d126ab2dd8400
Original Code:
```
@SuppressWarnings("unused")
public final class TypesBrokerReport extends Table {
    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb) {
        return getRootAsTypesBrokerReport(_bb, new TypesBrokerReport());
    }

    public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb, TypesBrokerReport obj) {
        _bb.order(ByteOrder.LITTLE_ENDIAN);
        return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));
    }

    public void __init(int _i, ByteBuffer _bb) {
        bb_pos = _i;
        bb = _bb;
    }

    public TypesBrokerReport __assign(int _i, ByteBuffer _bb) {
        __init(_i, _bb);
        return this;
    }

    public String brokerID() {
        int o = __offset(4);
        return o != 0 ? __string(o + bb_pos) : null;
    }

    public ByteBuffer brokerIDAsByteBuffer() {
        return __vector_as_bytebuffer(4, 1);
    }

    public long timeTag() {
        int o = __offset(6);
        return o != 0 ? bb.getLong(o + bb_pos) : 0L;
    }

    public double loadRatio() {
        int o = __offset(8);
        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;
    }

    public double bandWidthBytes() {
        int o = __offset(10);
        return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;
    }

    public TypesChannelReport channelReports(int j) {
        return channelReports(new TypesChannelReport(), j);
    }

    public TypesChannelReport channelReports(TypesChannelReport obj, int j) {
        int o = __offset(12);
        return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null;
    }

    public int channelReportsLength() {
        int o = __offset(12);
        return o != 0 ? __vector_len(o) : 0;
    }

    public static int createTypesBrokerReport(FlatBufferBuilder builder,
                                              int brokerIDOffset,
                                              long timeTag,
                                              double loadRatio,
                                              double bandWidthBytes,
                                              int channelReportsOffset) {
        builder.startObject(5);
        TypesBrokerReport.addBandWidthBytes(builder, bandWidthBytes);
        TypesBrokerReport.addLoadRatio(builder, loadRatio);
        TypesBrokerReport.addTimeTag(builder, timeTag);
        TypesBrokerReport.addChannelReports(builder, channelReportsOffset);
        TypesBrokerReport.addBrokerID(builder, brokerIDOffset);
        return TypesBrokerReport.endTypesBrokerReport(builder);
    }

    public static void startTypesBrokerReport(FlatBufferBuilder builder) {
        builder.startObject(5);
    }

    public static void addBrokerID(FlatBufferBuilder builder, int brokerIDOffset) {
        builder.addOffset(0, brokerIDOffset, 0);
    }

    public static void addTimeTag(FlatBufferBuilder builder, long timeTag) {
        builder.addLong(1, timeTag, 0L);
    }

    public static void addLoadRatio(FlatBufferBuilder builder, double loadRatio) {
        builder.addDouble(2, loadRatio, 0.0);
    }

    public static void addBandWidthBytes(FlatBufferBuilder builder, double bandWidthBytes) {
        builder.addDouble(3, bandWidthBytes, 0.0);
    }

    public static void addChannelReports(FlatBufferBuilder builder, int channelReportsOffset) {
        builder.addOffset(4, channelReportsOffset, 0);
    }

    public static int createChannelReportsVector(FlatBufferBuilder builder, int[] data) {
        builder.startVector(4, data.length, 4);
        for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]);
        return builder.endVector();
    }

    public static void startChannelReportsVector(FlatBufferBuilder builder, int numElems) {
        builder.startVector(4, numElems, 4);
    }

    public static int endTypesBrokerReport(FlatBufferBuilder builder) {
        int o = builder.endObject();
        return o;
    }

    public static void finishTypesBrokerReportBuffer(FlatBufferBuilder builder, int offset) {
        builder.finish(offset);
    }
}
```


Overlapping Code:
```
@SuppressWarnings("unused")
public final class TypesBrokerReport extends Table {
public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb) {
return getRootAsTypesBrokerReport(_bb, new TypesBrokerReport());
}
public static TypesBrokerReport getRootAsTypesBrokerReport(ByteBuffer _bb, TypesBrokerReport obj) {
_bb.order(ByteOrder.LITTLE_ENDIAN);
return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb));
}
public void __init(int _i, ByteBuffer _bb) {
bb_pos = _i;
bb = _bb;
}
public TypesBrokerReport __assign(int _i, ByteBuffer _bb) {
__init(_i, _bb);
return this;
}
public String brokerID() {
int o = __offset(4);
return o != 0 ? __string(o + bb_pos) : null;
}
public ByteBuffer brokerIDAsByteBuffer() {
return __vector_as_bytebuffer(4, 1);
}
public long timeTag() {
int o = __offset(6);
return o != 0 ? bb.getLong(o + bb_pos) : 0L;
}
public double loadRatio() {
int o = __offset(8);
return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;
}
public double bandWidthBytes() {
int o = __offset(10);
return o != 0 ? bb.getDouble(o + bb_pos) : 0.0;
}
public TypesChannelReport channelReports(int j) {
return channelReports(new TypesChannelReport(), j);
}
public TypesChannelReport channelReports(TypesChannelReport obj, int j) {
int o = __offset(12);
return o != 0 ? obj.__assign(__indirect(__vector(o) + j * 4), bb) : null;
}
public int channelReportsLength() {
int o = __offset(12);
return o != 0 ? __vector_len(o) : 0;
}
public static int createTypesBrokerReport(FlatBufferBuilder builder,
int brokerIDOffset,
long timeTag,
double loadRatio,
double bandWidthBytes,
int channelReportsOffset) {
builder.startObject(5);
TypesBrokerReport.addBandWidthBytes(builder, bandWidthBytes);
TypesBrokerReport.addLoadRatio(builder, loadRatio);
TypesBrokerReport.addTimeTag(builder, timeTag);
TypesBrokerReport.addChannelReports(builder, channelReportsOffset);
TypesBrokerReport.addBrokerID(
```
<Overlap Ratio: 0.9834368530020704>

---

--- 304 --
Question ID: cc296ba0118e3c532513f2f394ca71359abf13c4
Original Code:
```
public class TwoIlluminants extends SpectralColorDisplay {
	public ExPar Illuminant1 = new ExPar(SPECTRUM, new ExParValue("D6500"),
			"First illuminant spectrum");
	public ExPar Illuminant2 = new ExPar(SPECTRUM, new ExParValue("D2400"),
			"Second illuminant spectrum");
	public ExPar Illuminant1Luminance = new ExPar(0.0, 200.0, new ExParValue(
			180.0), "Luminance of the 1st illuminant");
	public ExPar Illuminant2Luminance = new ExPar(0.0, 200.0, new ExParValue(
			120.0), "Luminance of the 2nd illuminant");
	public ExPar Background = new ExPar(SPECTRUM, new ExParValue("2.5R 3/2"),
			"Background reflectance");
	public ExPar Center = new ExPar(SPECTRUM, new ExParValue("5R 6/4"),
			"Center reflectance");
	public ExPar CenterSize = new ExPar(PROPORT, new ExParValue(0.33),
			"Center square size");

	/** Cunstructor creating the title of the display. */
	public TwoIlluminants() {
		setTitleAndTopic("Two Illuminants for a Center and Surround Field",
				SPECTRAL_COLOR_DSP | DEMO);
	}
	private ExPar c1, c2, c3, c4;
	private int s1, s2, s3, s4;

	protected int create() {
		SpectralLightSource ls1 = getLightSource(this.Illuminant1,
				this.Illuminant1Luminance);
		SpectralLightSource ls2 = getLightSource(this.Illuminant2,
				this.Illuminant2Luminance);
		SpectralLightFilter bg = getLightFilter(this.Background);
		SpectralLightFilter ct = getLightFilter(this.Center);
		c1 = enterLight("Left background", ls1, bg);
		c2 = enterLight("Right background", ls2, bg);
		c3 = enterLight("Left center", ls1, ct);
		c4 = enterLight("Right center", ls2, ct);
		s1 = enterDisplayElement(new Bar(c1));
		s2 = enterDisplayElement(new Bar(c2));
		s3 = enterDisplayElement(new Bar(c3));
		s4 = enterDisplayElement(new Bar(c4));
		return (s4);
	}

	protected void computeGeometry() {
		double p = CenterSize.getDouble();
		Rectangle l = new Rectangle(-width / 2, -height / 2, width / 2, height);
		Rectangle r = new Rectangle(0, -height / 2, width - width / 2, height);
		getDisplayElement(s1).setRect(l);
		getDisplayElement(s2).setRect(r);
		getDisplayElement(s3).setRect(innerRect(l, p));
		getDisplayElement(s4).setRect(innerRect(r, p));
	}
}
```


Overlapping Code:
```
s extends SpectralColorDisplay {
public ExPar Illuminant1 = new ExPar(SPECTRUM, new ExParValue("D6500"),
"First illuminant spectrum");
public ExPar Illuminant2 = new ExPar(SPECTRUM, new ExParValue("D2400"),
"Second illuminant spectrum");
public ExPar Illuminant1Luminance = new ExPar(0.0, 200.0, new ExParValue(
180.0), "Luminance of the 1st illuminant");
public ExPar Illuminant2Luminance = new ExPar(0.0, 200.0, new ExParValue(
120.0), "Luminance of the 2nd illuminant");
public ExPar Background = new ExPar(SPECTRUM, new ExParValue("2.5R 3/2"),
"Background reflectance");
public ExPar Center = new ExPar(SPECTRUM, new ExParValue("5R 6/4"),
"Center reflectance");
public ExPar CenterSize = new ExPar(PROPORT, new ExParValue(0.33),
"Center square size");
/** Cunstructor creating the title of the display. */
public TwoIlluminants() {
setTitleAndTopic("Two Illuminants for a Center and Surround Field",
SPECTRAL_COLOR_DSP | DEMO);
}
private ExPar c1, c2, c3, c4;
private int s1, s2, s3, s4;
protected int create() {
SpectralLightSource ls1 = getLightSource(this.Illuminant1,
this.Illuminant1Luminance);
SpectralLightSource ls2 = getLightSource(this.Illuminant2,
this.Illuminant2Luminance);
SpectralLightFilter bg = getLightFilter(this.Background);
SpectralLightFilter ct = getLightFilter(this.Center);
c1 = enterLight("Left background", ls1, bg);
c2 = enterLight("Right background", ls2, bg);
c3 = enterLight("Left center", ls1, ct);
c4 = enterLight("Right center", ls2, ct);
s1 = enterDisplayElement(new Bar(c1));
s2 = enterDisplayElement(new Bar(c2));
s3 = enterDisplayElement(new Bar(c3));
s4 = enterDisplayElement(new Bar(c4));
return (s4);
}
protected void computeGeometry() {
double p = CenterSize.getDouble();
Rectangle l = new Rectangle(-width / 2, -height / 2, width / 2, height);
Rectangle r = new Rectangle(0, -height / 2, width - width / 2, height);
getDisplayElement(s1).setRect(l);
getDisplayElement(s2).setRect(r);
getDisplayElement(s3).setRect(innerRect(l, p));
getDisplayElement(s4)
```
<Overlap Ratio: 0.9727626459143969>

---

--- 305 --
Question ID: a8cfa4379d00fdcd850ba80ded5a1f5e6a76858d
Original Code:
```
public final class zzgy
{

	zzgy(long l, String s, int i)
	{
	//    0    0:aload_0         
	//    1    1:invokespecial   #15  <Method void Object()>
		value = l;
	//    2    4:aload_0         
	//    3    5:lload_1         
	//    4    6:putfield        #17  <Field long value>
		zzajf = s;
	//    5    9:aload_0         
	//    6   10:aload_3         
	//    7   11:putfield        #19  <Field String zzajf>
		zzajg = i;
	//    8   14:aload_0         
	//    9   15:iload           4
	//   10   17:putfield        #21  <Field int zzajg>
	//   11   20:return          
	}

	public final boolean equals(Object obj)
	{
		if(obj != null)
	//*   0    0:aload_1         
	//*   1    1:ifnull          43
		{
			if(!(obj instanceof zzgy))
	//*   2    4:aload_1         
	//*   3    5:instanceof      #2   <Class zzgy>
	//*   4    8:ifne            13
				return false;
	//    5   11:iconst_0        
	//    6   12:ireturn         
			obj = ((Object) ((zzgy)obj));
	//    7   13:aload_1         
	//    8   14:checkcast       #2   <Class zzgy>
	//    9   17:astore_1        
			if(((zzgy) (obj)).value == value && ((zzgy) (obj)).zzajg == zzajg)
	//*  10   18:aload_1         
	//*  11   19:getfield        #17  <Field long value>
	//*  12   22:aload_0         
	//*  13   23:getfield        #17  <Field long value>
	//*  14   26:lcmp            
	//*  15   27:ifne            43
	//*  16   30:aload_1         
	//*  17   31:getfield        #21  <Field int zzajg>
	//*  18   34:aload_0         
	//*  19   35:getfield        #21  <Field int zzajg>
	//*  20   38:icmpne          43
				return true;
	//   21   41:iconst_1        
	//   22   42:ireturn         
		}
		return false;
	//   23   43:iconst_0        
	//   24   44:ireturn         
	}

	public final int hashCode()
	{
		return (int)value;
	//    0    0:aload_0         
	//    1    1:getfield        #17  <Field long value>
	//    2    4:l2i             
	//    3    5:ireturn         
	}

	final long value;
	final String zzajf;
	final int zzajg;
}
```


Overlapping Code:
```
zgy(long l, String s, int i)
{
// 0 0:aload_0 
// 1 1:invokespecial #15 <Method void Object()>
value = l;
// 2 4:aload_0 
// 3 5:lload_1 
// 4 6:putfield #17 <Field long value>
zzajf = s;
// 5 9:aload_0 
// 6 10:aload_3 
// 7 11:putfield #19 <Field String zzajf>
zzajg = i;
// 8 14:aload_0 
// 9 15:iload 4
// 10 17:putfield #21 <Field int zzajg>
// 11 20:return 
}
public final boolean equals(Object obj)
{
if(obj != null)
//* 0 0:aload_1 
//* 1 1:ifnull 43
{
if(!(obj instanceof zzgy))
//* 2 4:aload_1 
//* 3 5:instanceof #2 <Class zzgy>
//* 4 8:ifne 13
return false;
// 5 11:iconst_0 
// 6 12:ireturn 
obj = ((Object) ((zzgy)obj));
// 7 13:aload_1 
// 8 14:checkcast #2 <Class zzgy>
// 9 17:astore_1 
if(((zzgy) (obj)).value == value && ((zzgy) (obj)).zzajg == zzajg)
//* 10 18:aload_1 
//* 11 19:getfield #17 <Field long value>
//* 12 22:aload_0 
//* 13 23:getfield #17 <Field long value>
//* 14 26:lcmp 
//* 15 27:ifne 43
//* 16 30:aload_1 
//* 17 31:getfield #21 <Field int zzajg>
//* 18 34:aload_0 
//* 19 35:getfield #21 <Field int zzajg>
//* 20 38:icmpne 43
return true;
// 21 41:iconst_1 
// 22 42:ireturn 
}
return false;
// 23 43:iconst_0 
// 24 44:ireturn 
}
public final int hashCode()
{
return (int)value;
// 0 0:aload_0 
// 1 1:getfield #17 <Field long value>
// 2 4:l2i 
// 3 5:ireturn 
}
final long value;
final String zzajf;
final 
```
<Overlap Ratio: 0.9719222462203023>

---

--- 306 --
Question ID: 70b0e3f3cd02ee1231e61f4ed20dc96cfb897750
Original Code:
```
public class TabelaHash
{
  private Aluno[] tabela;

  public TabelaHash(int N)
  {
    tabela = new Aluno[N];
  }

  private int hash(int k)
  {
    return k % tabela.length;
  }

  public Aluno get(int k)
  {
    int h = hash(k);
    Aluno aluno = tabela[h];

    while (aluno != null)
    {
      if (aluno.getMatricula() == k)
      {
        return aluno;
      }

      aluno = aluno.getProx();
    }
    return null;
  }

  public void set(String nome, int matricula, float mediaGeral)
  {
    int h = hash(matricula);
    Aluno aluno = tabela[h];

    while (aluno != null)
    {
      if (aluno.getMatricula() == matricula)
      {
        break;
      }

      aluno = aluno.getProx();
    }

    if (aluno == null)
    {
      aluno = new Aluno();
      aluno.setMatricula(matricula);
      aluno.setProx(tabela[h]);
      tabela[h] = aluno;
    }

    aluno.setNome(nome);
    aluno.setMediaGeral(mediaGeral);
  }

  public void remove(int k)
  {
    int h = hash(k);
    Aluno anterior = null;
    Aluno atual = tabela[h];
    while (atual != null && atual.getMatricula() != k)
    {
      anterior = atual;
      atual = atual.getProx();
    }

    if (atual == null)
    {
      return;
    }
    if (anterior == null)
    {
      tabela[h] = atual.getProx();
    }
    else
    {
      anterior.setProx(atual.getProx());
    }
  }

  @Override
  public String toString()
  {
    return "TabelaHash [tabela = " + Arrays.toString(tabela) + "]";
  }
}
```


Overlapping Code:
```
 class TabelaHash
{
private Aluno[] tabela;
public TabelaHash(int N)
{
tabela = new Aluno[N];
}
private int hash(int k)
{
return k % tabela.length;
}
public Aluno get(int k)
{
int h = hash(k);
Aluno aluno = tabela[h];
while (aluno != null)
{
if (aluno.getMatricula() == k)
{
return aluno;
}
aluno = aluno.getProx();
}
return null;
}
public void set(String nome, int matricula, float mediaGeral)
{
int h = hash(matricula);
Aluno aluno = tabela[h];
while (aluno != null)
{
if (aluno.getMatricula() == matricula)
{
break;
}
aluno = aluno.getProx();
}
if (aluno == null)
{
aluno = new Aluno();
aluno.setMatricula(matricula);
aluno.setProx(tabela[h]);
tabela[h] = aluno;
}
aluno.setNome(nome);
aluno.setMediaGeral(mediaGeral);
}
public void remove(int k)
{
int h = hash(k);
Aluno anterior = null;
Aluno atual = tabela[h];
while (atual != null && atual.getMatricula() != k)
{
anterior = atual;
atual = atual.getProx();
}
if (atual == null)
{
return;
}
if (anterior == null)
{
tabela[h] = atual.getProx();
}
else
{
anterior.setProx(atual.getProx());
}
}
@Override
public String toString()
{
return "TabelaHash [tabela = " + Arrays.toString(tabela) + "]";
}

```
<Overlap Ratio: 0.9939498703543648>

---

--- 307 --
Question ID: 4f1fe265e4ed3313651d99528cbdac78d87fe8fa
Original Code:
```
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-12-08T12:42:53.880-06:00[America/Chicago]")
public class PackageMeasurements {
  public static final String SERIALIZED_NAME_ATTRIBUTES = "attributes";
  @SerializedName(SERIALIZED_NAME_ATTRIBUTES)
  private Map<String, Object> attributes = null;

  public static final String SERIALIZED_NAME_HEIGHT = "height";
  @SerializedName(SERIALIZED_NAME_HEIGHT)
  private Measurement height = null;

  public static final String SERIALIZED_NAME_LENGTH = "length";
  @SerializedName(SERIALIZED_NAME_LENGTH)
  private Measurement length = null;

  public static final String SERIALIZED_NAME_WEIGHT = "weight";
  @SerializedName(SERIALIZED_NAME_WEIGHT)
  private Measurement weight = null;

  public static final String SERIALIZED_NAME_WIDTH = "width";
  @SerializedName(SERIALIZED_NAME_WIDTH)
  private Measurement width = null;

  public PackageMeasurements attributes(Map<String, Object> attributes) {
    this.attributes = attributes;
    return this;
  }

  public PackageMeasurements putAttributesItem(String key, Object attributesItem) {
    if (this.attributes == null) {
      this.attributes = new HashMap<String, Object>();
    }
    this.attributes.put(key, attributesItem);
    return this;
  }

   /**
   * Get attributes
   * @return attributes
  **/
  @ApiModelProperty(value = "")
  public Map<String, Object> getAttributes() {
    return attributes;
  }

  public void setAttributes(Map<String, Object> attributes) {
    this.attributes = attributes;
  }

  public PackageMeasurements height(Measurement height) {
    this.height = height;
    return this;
  }

   /**
   * Get height
   * @return height
  **/
  @ApiModelProperty(value = "")
  public Measurement getHeight() {
    return height;
  }

  public void setHeight(Measurement height) {
    this.height = height;
  }

  public PackageMeasurements length(Measurement length) {
    this.length = length;
    return this;
  }

   /**
   * Get length
   * @return length
  **/
  @ApiModelProperty(value = "")
  public Measurement getLength() {
    return length;
  }

  public void setLength(Measurement length) {
    this.length = length;
  }

  public PackageMeasurements weight(Measurement weight) {
    this.weight = weight;
    return this;
  }

   /**
   * Get weight
   * @return weight
  **/
  @ApiModelProperty(value = "")
  public Measurement getWeight() {
    return weight;
  }

  public void setWeight(Measurement weight) {
    this.weight = weight;
  }

  public PackageMeasurements width(Measurement width) {
    this.width = width;
    return this;
  }

   /**
   * Get width
   * @return width
  **/
  @ApiModelProperty(value = "")
  public Measurement getWidth() {
    return width;
  }

  public void setWidth(Measurement width) {
    this.width = width;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PackageMeasurements packageMeasurements = (PackageMeasurements) o;
    return Objects.equals(this.attributes, packageMeasurements.attributes) &&
        Objects.equals(this.height, packageMeasurements.height) &&
        Objects.equals(this.length, packageMeasurements.length) &&
        Objects.equals(this.weight, packageMeasurements.weight) &&
        Objects.equals(this.width, packageMeasurements.width);
  }

  @Override
  public int hashCode() {
    return Objects.hash(attributes, height, length, weight, width);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PackageMeasurements {\n");
    
    sb.append("    attributes: ").append(toIndentedString(attributes)).append("\n");
    sb.append("    height: ").append(toIndentedString(height)).append("\n");
    sb.append("    length: ").append(toIndentedString(length)).append("\n");
    sb.append("    weight: ").append(toIndentedString(weight)).append("\n");
    sb.append("    width: ").append(toIndentedString(width)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
```


Overlapping Code:
```
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2020-12-08T12:42:53.880-06:00[America/Chicago]")
public class PackageMeasurements {
public static final String SERIALIZED_NAME_ATTRIBUTES = "attributes";
@SerializedName(SERIALIZED_NAME_ATTRIBUTES)
private Map<String, Object> attributes = null;
public static final String SERIALIZED_NAME_HEIGHT = "height";
@SerializedName(SERIALIZED_NAME_HEIGHT)
private Measurement height = null;
public static final String SERIALIZED_NAME_LENGTH = "length";
@SerializedName(SERIALIZED_NAME_LENGTH)
private Measurement length = null;
public static final String SERIALIZED_NAME_WEIGHT = "weight";
@SerializedName(SERIALIZED_NAME_WEIGHT)
private Measurement weight = null;
public static final String SERIALIZED_NAME_WIDTH = "width";
@SerializedName(SERIALIZED_NAME_WIDTH)
private Measurement width = null;
public PackageMeasurements attributes(Map<String, Object> attributes) {
this.attributes = attributes;
return this;
}
public PackageMeasurements putAttributesItem(String key, Object attributesItem) {
if (this.attributes == null) {
this.attributes = new HashMap<String, Object>();
}
this.attributes.put(key, attributesItem);
return this;
}
/**
* Get attributes
* @return attributes
**/
@ApiModelProperty(value = "")
public Map<String, Object> getAttributes() {
return attributes;
}
public void setAttributes(Map<String, Object> attributes) {
this.attributes = attributes;
}
public PackageMeasurements height(Measurement height) {
this.height = height;
return this;
}
/**
* Get height
* @return height
**/
@ApiModelProperty(value = "")
public Measurement getHeight() {
return height;
}
public void setHeight(Measurement height) {
this.height = height;
}
public PackageMeasurements length(Measurement length) {
this.length = length;
return this;
}
/**
* Get length
* @return length
**/
@ApiModelProperty(value = "")
public Measurement getLength() {
return length;
}
public void setLength(Measurement length) {
this.length = length;
}
public PackageMeasurements weight(Measurement weight) {
this.weight = weight;
return this;
}
/**
* Get weight
* @return weight
**/
@ApiModelProperty(value = "")
public Measurement getWeight() {
return weight;
}
public void setWeight(Measurem
```
<Overlap Ratio: 0.9964726631393298>

---

--- 308 --
Question ID: 9111a20a4d82522445b4ded8983b79e919e38c0d
Original Code:
```
public class ArrayInstance extends Instance {

    private final Type mType;

    private final int mLength;

    private final long mValuesOffset;

    public ArrayInstance(long id, @NonNull StackTrace stack, @NonNull Type type, int length,
            long valuesOffset) {
        super(id, stack);
        mType = type;
        mLength = length;
        mValuesOffset = valuesOffset;
    }

    @NonNull
    public Object[] getValues() {
        Object[] values = new Object[mLength];

        getBuffer().setPosition(mValuesOffset);
        for (int i = 0; i < mLength; i++) {
            values[i] = readValue(mType);
        }
        return values;
    }

    @NonNull
    public byte[] asRawByteArray(int start, int elementCount) {
        getBuffer().setPosition(mValuesOffset);
        assert mType != Type.OBJECT;
        assert start + elementCount <= mLength;
        byte[] bytes = new byte[elementCount * mType.getSize()];
        getBuffer().readSubSequence(bytes, start * mType.getSize(), elementCount * mType.getSize());
        return bytes;
    }

    @NonNull
    public char[] asCharArray(int offset, int length) {
        assert mType == Type.CHAR;
        // TODO: Make this copy less by supporting offset in asRawByteArray.
        CharBuffer charBuffer = ByteBuffer.wrap(asRawByteArray(offset, length)).order(
                DataBuffer.HPROF_BYTE_ORDER).asCharBuffer();
        char[] result = new char[length];
        charBuffer.get(result);
        return result;
    }

    @Override
    public final int getSize() {
        // TODO: Take the rest of the fields into account: length, type, etc (~16 bytes).
        return mLength * mHeap.mSnapshot.getTypeSize(mType);
    }

    @Override
    public final void resolveReferences() {
        if (mType == Type.OBJECT) {
            for (Object value : getValues()) {
                if (value instanceof Instance) {
                    ((Instance)value).addReverseReference(null, this);
                    mHardForwardReferences.add((Instance)value);
                }
            }
        }
    }

    @Override
    public final void accept(@NonNull Visitor visitor) {
        visitor.visitArrayInstance(this);
        for (Instance instance : mHardForwardReferences) {
            visitor.visitLater(this, instance);
        }
    }

    @Override
    public ClassObj getClassObj() {
        if (mType == Type.OBJECT) {
            return super.getClassObj();
        } else {
            // Primitive arrays don't set their classId, we need to do the lookup manually.
            ClassObj primitiveArrayClassObj =
                    mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(false));
            if (primitiveArrayClassObj == null) {
                // We might not be parsing an Android hprof.
                primitiveArrayClassObj =
                        mHeap.mSnapshot.findClass(mType.getClassNameOfPrimitiveArray(true));
            }
            return primitiveArrayClassObj;
        }
    }

    /**
     * Returns the number of elements in the array.
     */
    public int getLength() {
        return mLength;
    }

    public Type getArrayType() {
        return mType;
    }

    public final String toString() {
        String className = getClassObj().getClassName();
        if (className.endsWith("[]")) {
            className = className.substring(0, className.length() - 2);
        }
        return String.format("%s[%d]@%d (0x%x)", className, mLength, getUniqueId(), getUniqueId());
    }
}
```


Overlapping Code:
```
lic class ArrayInstance extends Instance {
private final Type mType;
private final int mLength;
private final long mValuesOffset;
public ArrayInstance(long id, @NonNull StackTrace stack, @NonNull Type type, int length,
long valuesOffset) {
super(id, stack);
mType = type;
mLength = length;
mValuesOffset = valuesOffset;
}
@NonNull
public Object[] getValues() {
Object[] values = new Object[mLength];
getBuffer().setPosition(mValuesOffset);
for (int i = 0; i < mLength; i++) {
values[i] = readValue(mType);
}
return values;
}
@NonNull
public byte[] asRawByteArray(int start, int elementCount) {
getBuffer().setPosition(mValuesOffset);
assert mType != Type.OBJECT;
assert start + elementCount <= mLength;
byte[] bytes = new byte[elementCount * mType.getSize()];
getBuffer().readSubSequence(bytes, start * mType.getSize(), elementCount * mType.getSize());
return bytes;
}
@NonNull
public char[] asCharArray(int offset, int length) {
assert mType == Type.CHAR;
// TODO: Make this copy less by supporting offset in asRawByteArray.
CharBuffer charBuffer = ByteBuffer.wrap(asRawByteArray(offset, length)).order(
DataBuffer.HPROF_BYTE_ORDER).asCharBuffer();
char[] result = new char[length];
charBuffer.get(result);
return result;
}
@Override
public final int getSize() {
// TODO: Take the rest of the fields into account: length, type, etc (~16 bytes).
return mLength * mHeap.mSnapshot.getTypeSize(mType);
}
@Override
public final void resolveReferences() {
if (mType == Type.OBJECT) {
for (Object value : getValues()) {
if (value instanceof Instance) {
((Instance)value).addReverseReference(null, this);
mHardForwardReferences.add((Instance)value);
}
}
}
}
@Override
public final void accept(@NonNull Visitor visitor) {
visitor.visitArrayInstance(this);
for (Instance instance : mHardForwardReferences) {
visitor.visitLater(this, instance);
}
}
@Override
public ClassObj getClassObj() {
if (mType == Type.OBJECT) {
return super.getC
```
<Overlap Ratio: 0.9756838905775076>

---

--- 309 --
Question ID: 79f22dfde110f798d07d95958a9d86776c9445c5
Original Code:
```
public class BrickWall {
    public int leastBricks(List<List<Integer>> wall) {
        int max = 0;
        Map<Integer, Integer> map = new HashMap<>();
        for (List<Integer> wa : wall) {
            int sum = 0;
            for (int i=0;i<wa.size()-1;i++) {
                sum += wa.get(i);
                map.put(sum, map.getOrDefault(sum, 0) + 1);
                max = Math.max(max, map.get(sum));
            }

        }
        return wall.size() - max;
    }
}
```


Overlapping Code:
```
blic class BrickWall {
public int leastBricks(List<List<Integer>> wall) {
int max = 0;
Map<Integer, Integer> map = new HashMap<>();
for (List<Integer> wa : wall) {
int sum = 0;
for (int i=0;i<wa.size()-1;i++) {
sum += wa.get(i);
map.put(sum, map.getOrDefault(sum, 0) + 1);
max = Math.max(max, map.get(sum));
}
}
return 
```
<Overlap Ratio: 0.9300291545189504>

---

--- 310 --
Question ID: f3590d6a195db9a59a3e060d92da68cfcf7b9700
Original Code:
```
public class JoystickCommandPair {

    // A button from the operator interface
    private JoystickButton button;
    
    // Contains the details about the command that you are binding to the button
    private CommandDetails commandDetails;
 
    // Instance of a ControlsProcessor 
    private ControlsProcessor controlsProcessor;

    // Save previous state to call only when on edge.
    private boolean lastState = false;

    /**
     * @param controlsProcessor The current ControlsProcessor object in reference
     * @param commandInput The whole command string appended
     * @param buttonToPair The button to pair the command with
     */
    public JoystickCommandPair(ControlsProcessor controlsProcessor, String commandInput, JoystickButton buttonToPair) {
        this.button = buttonToPair;
        this.commandDetails = new CommandDetails(commandInput);
        this.controlsProcessor = controlsProcessor;
    }

    /**
     * Called periodically to check for button edges 
     */
    public void checkButton() {
        boolean currentState = this.button.get();

        if (currentState && !this.lastState) {
            controlsProcessor.callCommand(this.commandDetails);
        }

        if (!currentState && this.lastState && this.commandDetails.type() == 
            CommandDetails.CommandType.SERIES) {
            controlsProcessor.cancelCommand(this.commandDetails);
        }

        this.lastState = currentState;
    }
}
```


Overlapping Code:
```
mmandPair {
// A button from the operator interface
private JoystickButton button;

// Contains the details about the command that you are binding to the button
private CommandDetails commandDetails;

// Instance of a ControlsProcessor 
private ControlsProcessor controlsProcessor;
// Save previous state to call only when on edge.
private boolean lastState = false;
/**
* @param controlsProcessor The current ControlsProcessor object in reference
* @param commandInput The whole command string appended
* @param buttonToPair The button to pair the command with
*/
public JoystickCommandPair(ControlsProcessor controlsProcessor, String commandInput, JoystickButton buttonToPair) {
this.button = buttonToPair;
this.commandDetails = new CommandDetails(commandInput);
this.controlsProcessor = controlsProcessor;
}
/**
* Called periodically to check for button edges 
*/
public void checkButton() {
boolean currentState = this.button.get();
if (currentState && !this.lastState) {
controlsProcessor.callCommand(this.commandDetails);
}
if (!currentState && this.lastState && this.commandDetails.type() == 
CommandDetails.CommandType.SERIES) {
controlsProcessor.cancelCommand(this.commandDetails);
}
this.la
```
<Overlap Ratio: 0.96>

---

--- 311 --
Question ID: a53265b8898d0e563a419fe4c452c5dab5c9c963
Original Code:
```
public class OrderManagerTest {

	@BeforeClass
	public static void registerDefaultCurrencyPairs() {
		if(BitfinexCurrencyPair.values().size() < 10) {
			BitfinexCurrencyPair.unregisterAll();
			BitfinexCurrencyPair.registerDefaults();	
		}
	}
	
    /**
     * Test order submit failed
     *
     * @throws BitfinexClientException
     * @throws InterruptedException
     */
    @Test
    public void testOrderSubmissionFailed() throws BitfinexClientException, InterruptedException {
        final String jsonString = "[0,\"n\",[null,\"on-req\",null,null,[null,null,1513970684865000,\"tBTCUSD\",null,null,0.001,0.001,\"EXCHANGE MARKET\",null,null,null,null,null,null,null,12940,null,null,null,null,null,null,0,null,null],null,\"ERROR\",\"Invalid order: minimum size for BTC/USD is 0.002\"]]";
        final JSONArray jsonArray = new JSONArray(jsonString);

        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {
            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());
            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());
            Assert.assertEquals(1513970684865000L, (long)e.getClientId());
            Assert.assertEquals(BitfinexCurrencyPair.of("BTC", "USD").toBitfinexString(), e.getCurrencyPair().toBitfinexString());
        };

        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);
        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
        notificationHandler.onOrderNotification((a, eo) -> {
            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);
        });

        notificationHandler.handleChannelData("n", jsonArray.getJSONArray(2));
    }


    /**
     * Test notifications with null value
     *
     * @throws BitfinexClientException
     * @throws InterruptedException
     */
    @Test
    public void testNotificationWithNull() throws BitfinexClientException, InterruptedException {
        final String jsonString = "[0,\"n\",[1523930407542,\"on-req\",null,null,[null,null,1523930407442000,null,null,null,0.0001,null,\"LIMIT\",null,null,null,null,null,null,null,6800,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null],null,\"ERROR\",\"amount: invalid\"]]";
        final JSONArray jsonArray = new JSONArray(jsonString);

        final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {
            Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());
            Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());
            Assert.assertEquals(1523930407442000L, (long) e.getClientId());
            Assert.assertNull(e.getCurrencyPair());
        };

        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);
        final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));

        notificationHandler.handleChannelData("n", jsonArray.getJSONArray(2));

        notificationHandler.onOrderNotification((a, eo) -> {
            bitfinexApiBroker.getOrderManager().updateOrder(a, eo);
        });
    }

    /**
     * Test the order channel handler - single order
     *
     * @throws BitfinexClientException
     */
    @Test
    public void testOrderChannelHandler1() throws BitfinexClientException {
        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        final String jsonString = "[0,\"on\",[6784335053,null,1514956504945000,\"tIOTUSD\",1514956505134,1514956505164,-24.175121,-24.175121,\"EXCHANGE STOP\",null,null,null,0,\"ACTIVE\",null,null,3.84,0,null,null,null,null,null,0,0,0]]";
        final JSONArray jsonArray = new JSONArray(jsonString);
        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
        orderHandler.onSubmittedOrderEvent((a, eos) -> {
            for (BitfinexSubmittedOrder exchangeOrder : eos) {
                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);
            }
        });

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        Assert.assertTrue(orderManager.getOrders().isEmpty());
        orderHandler.handleChannelData("on", jsonArray.getJSONArray(2));

        Assert.assertEquals(1, orderManager.getOrders().size());

        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());
    }

    /**
     * Test the order channel handler - snapshot
     *
     * @throws BitfinexClientException
     */
    @Test
    public void testOrderChannelHandler2() throws BitfinexClientException {
        final String jsonString = "[0,\"on\",[[6784335053,null,1514956504945000,\"tIOTUSD\",1514956505134,1514956505164,-24.175121,-24.175121,\"EXCHANGE STOP\",null,null,null,0,\"ACTIVE\",null,null,3.84,0,null,null,null,null,null,0,0,0], [67843353243,null,1514956234945000,\"tBTCUSD\",1514956505134,1514956505164,-24.175121,-24.175121,\"EXCHANGE STOP\",null,null,null,0,\"ACTIVE\",null,null,3.84,0,null,null,null,null,null,0,0,0]]]";
        final JSONArray jsonArray = new JSONArray(jsonString);
        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
        orderHandler.onSubmittedOrderEvent((a, eos) -> {
            for (BitfinexSubmittedOrder exchangeOrder : eos) {
                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);
            }
        });

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        Assert.assertTrue(orderManager.getOrders().isEmpty());
        orderHandler.handleChannelData("on", jsonArray.getJSONArray(2));
        Assert.assertEquals(2, orderManager.getOrders().size());

        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());
        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(1).getStatus());

        orderManager.clear();
        Assert.assertTrue(orderManager.getOrders().isEmpty());
    }

    /**
     * Test the order channel handler - posclose order
     *
     * @throws BitfinexClientException
     */
    @Test
    public void testOrderChannelHandler3() throws BitfinexClientException {
        final String jsonString = "[0,\"on\",[6827301913,null,null,\"tXRPUSD\",1515069803530,1515069803530,-60,-60,\"MARKET\",null,null,null,0,\"ACTIVE (note:POSCLOSE)\",null,null,0,3.2041,null,null,null,null,null,0,0,0]]";

        final JSONArray jsonArray = new JSONArray(jsonString);
        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
        orderHandler.onSubmittedOrderEvent((a,eos) -> {
            for (BitfinexSubmittedOrder exchangeOrder : eos) {
                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);
            }
        });

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        Assert.assertTrue(orderManager.getOrders().isEmpty());
        orderHandler.handleChannelData("on", jsonArray.getJSONArray(2));

        Assert.assertEquals(1, orderManager.getOrders().size());
        Assert.assertEquals(BitfinexSubmittedOrderStatus.ACTIVE, orderManager.getOrders().get(0).getStatus());
    }

    /**
     * Test the order channel handler - partFilled order
     *
     * @throws BitfinexClientException
     */
    @Test
    public void testOrderChannelHandler4() throws BitfinexClientException {
        final String jsonString = "[0,\"oc\",[11291120775,null,null,\"tNEOBTC\",1524661302976,1524661303001,0,-0.41291886,\"MARKET\",null,null,null,0,\"INSUFFICIENT BALANCE (G1) was: ACTIVE (note:POSCLOSE), PARTIALLY FILLED @ 0.008049(-0.41291886)\",null,null,0,0.008049,null,null,null,null,null,0,0,0,null,null,\"\",null,null,null]]";

        final JSONArray jsonArray = new JSONArray(jsonString);
        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        final OrderHandler orderHandler = new OrderHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
        orderHandler.onSubmittedOrderEvent((a, eos) -> {
            for (BitfinexSubmittedOrder exchangeOrder : eos) {
                bitfinexApiBroker.getOrderManager().updateOrder(a, exchangeOrder);
            }
        });

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        Assert.assertTrue(orderManager.getOrders().isEmpty());
        orderHandler.handleChannelData("oc", jsonArray.getJSONArray(2));

        Assert.assertEquals(1, orderManager.getOrders().size());
        Assert.assertEquals(BitfinexSubmittedOrderStatus.PARTIALLY_FILLED, orderManager.getOrders().get(0).getStatus());
    }

    /**
     * Test the cancelation of an order
     *
     * @throws InterruptedException
     * @throws BitfinexClientException
     */
    @Test(expected = BitfinexClientException.class)
    public void testCancelOrderUnauth() throws BitfinexClientException, InterruptedException {

        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        orderManager.cancelOrderAndWaitForCompletion(12);
    }

    /**
     * Test the cancelation of an order
     *
     * @throws InterruptedException
     * @throws BitfinexClientException
     */
    @Test(timeout = 60000)
    public void testCancelOrder() throws BitfinexClientException, InterruptedException {
        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();
        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "apiKey");

        final Runnable r = () -> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                return;
            }
            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();
            exchangeOrder.setOrderId(12L);
            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.CANCELED);
            orderManager.updateOrder(symbol, exchangeOrder);
        };

        // Cancel event
        (new Thread(r)).start();

        orderManager.cancelOrderAndWaitForCompletion(12);
    }

    /**
     * Test the placement of an order
     *
     * @throws InterruptedException
     * @throws BitfinexClientException
     */
    @Test(expected = BitfinexClientException.class)
    public void testPlaceOrderUnauth() throws BitfinexClientException, InterruptedException {

        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        Mockito.when(bitfinexApiBroker.getApiKeyPermissions()).thenReturn(BitfinexApiKeyPermissions.NO_PERMISSIONS);

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();

        final BitfinexNewOrder order
                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of("BTC", "USD"), BitfinexOrderType.MARKET, 12).build();

        orderManager.placeOrderAndWaitUntilActive(order);
    }


    /**
     * Test the placement of an order
     *
     * @throws InterruptedException
     * @throws BitfinexClientException
     */
    @Test(timeout = 60000)
    public void testPlaceOrder() throws BitfinexClientException, InterruptedException {

        final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
        Mockito.when(bitfinexApiBroker.isAuthenticated()).thenReturn(true);

        final OrderManager orderManager = bitfinexApiBroker.getOrderManager();

        final BitfinexNewOrder order
                = BitfinexOrderBuilder.create(BitfinexCurrencyPair.of("BTC", "USD"), BitfinexOrderType.MARKET, 1).build();
        BitfinexAccountSymbol symbol = BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "apiKey");

        final Runnable r = () -> {
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                return;
            }
            final BitfinexSubmittedOrder exchangeOrder = new BitfinexSubmittedOrder();
            exchangeOrder.setClientId(order.getClientId());
            exchangeOrder.setStatus(BitfinexSubmittedOrderStatus.ACTIVE);
            orderManager.updateOrder(symbol, exchangeOrder);
        };

        // Cancel event
        (new Thread(r)).start();

        orderManager.placeOrderAndWaitUntilActive(order);
    }


}
```


Overlapping Code:
```
public class OrderManagerTest {
@BeforeClass
public static void registerDefaultCurrencyPairs() {
if(BitfinexCurrencyPair.values().size() < 10) {
BitfinexCurrencyPair.unregisterAll();
BitfinexCurrencyPair.registerDefaults(); 
}
}

/**
* Test order submit failed
*
* @throws BitfinexClientException
* @throws InterruptedException
*/
@Test
public void testOrderSubmissionFailed() throws BitfinexClientException, InterruptedException {
final String jsonString = "[0,\"n\",[null,\"on-req\",null,null,[null,null,1513970684865000,\"tBTCUSD\",null,null,0.001,0.001,\"EXCHANGE MARKET\",null,null,null,null,null,null,null,12940,null,null,null,null,null,null,0,null,null],null,\"ERROR\",\"Invalid order: minimum size for BTC/USD is 0.002\"]]";
final JSONArray jsonArray = new JSONArray(jsonString);
final Consumer<BitfinexSubmittedOrder> orderCallback = (e) -> {
Assert.assertEquals(BitfinexSubmittedOrderStatus.ERROR, e.getStatus());
Assert.assertEquals(TestHelper.API_KEY, e.getApiKey());
Assert.assertEquals(1513970684865000L, (long)e.getClientId());
Assert.assertEquals(BitfinexCurrencyPair.of("BTC", "USD").toBitfinexString(), e.getCurrencyPair().toBitfinexString());
};
final BitfinexWebsocketClient bitfinexApiBroker = TestHelper.buildMockedBitfinexConnection();
bitfinexApiBroker.getOrderManager().registerCallback(orderCallback);
final NotificationHandler notificationHandler = new NotificationHandler(0, BitfinexSymbols.account(BitfinexApiKeyPermissions.ALL_PERMISSIONS, "api-key"));
notificationHandler.onOrderNotification((a, eo) -> {
bitfinexApiBroker.getOrderManager().updateOrder(a, eo);
});
notificationHandler.handleChannelData("n", jsonArray.getJSONArray(2));
}
/**
* Test notifications with null value
*
* @throws BitfinexClientException
* @throws InterruptedException
*/
@Test
public void testNotificationWithNull() throws BitfinexClientException, InterruptedException {
final String jsonString = "[0,\"n\",[1523930407542,\"on-req\",null,null,[null,null,1523930407442000,null,null,null,0.0001,null,\"LIMIT\",null,null,null,null,null,null,null,6800,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null],null,\"ERROR\",\"amount: invalid\"]]";
final JSONArray jsonArray = new JSONArray(jsonString);
final Consum
```
<Overlap Ratio: 0.9986583184257602>

---

--- 312 --
Question ID: da1f15ab787bcfb841ad8898bfdd68ad26ab20ba
Original Code:
```
public class GitRepositoryManagerImpl extends AbstractProjectComponent implements Disposable, GitRepositoryManager, VcsListener {

  private static final Logger LOG = Logger.getInstance(GitRepositoryManager.class);

  @NotNull private final AbstractVcs myVcs;
  @NotNull private final ProjectLevelVcsManager myVcsManager;

  @NotNull private final Map<VirtualFile, GitRepository> myRepositories = new HashMap<VirtualFile, GitRepository>();

  @NotNull private final ReentrantReadWriteLock REPO_LOCK = new ReentrantReadWriteLock();
  @NotNull private final GitPlatformFacade myPlatformFacade;

  public GitRepositoryManagerImpl(@NotNull Project project, @NotNull GitPlatformFacade platformFacade) {
    super(project);
    myPlatformFacade = platformFacade;
    myVcsManager = ProjectLevelVcsManager.getInstance(myProject);
    myVcs = platformFacade.getVcs(myProject);
  }

  @Override
  public void initComponent() {
    Disposer.register(myProject, this);
    myProject.getMessageBus().connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);
    GitRootScanner rootScanner = new GitRootScanner(myProject);
    Disposer.register(this, rootScanner);
  }

  @Override
  public void dispose() {
    try {
      REPO_LOCK.writeLock().lock();
      myRepositories.clear();
    }
    finally {
      REPO_LOCK.writeLock().unlock();
    }
  }

  @Override
  public void directoryMappingChanged() {
    updateRepositoriesCollection();
  }

  @Override
  @Nullable
  public GitRepository getRepositoryForRoot(@Nullable VirtualFile root) {
    if (root == null) {
      return null;
    }
    try {
      REPO_LOCK.readLock().lock();
      return myRepositories.get(root);
    }
    finally {
      REPO_LOCK.readLock().unlock();
    }
  }

  @Override
  @Nullable
  public GitRepository getRepositoryForFile(@NotNull VirtualFile file) {
    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);
    return getRepositoryForVcsRoot(vcsRoot, file.getPath());
  }

  @Override
  public GitRepository getRepositoryForFile(@NotNull FilePath file) {
    final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);
    return getRepositoryForVcsRoot(vcsRoot, file.getPath());
  }

  @Nullable
  private GitRepository getRepositoryForVcsRoot(VcsRoot vcsRoot, String filePath) {
    if (vcsRoot == null) {
      return null;
    }
    final AbstractVcs vcs = vcsRoot.getVcs();
    if (!myVcs.equals(vcs)) {
      if (vcs != null) {
        // if null, the file is just not under version control, nothing interesting;
        // otherwise log, because Git method is requested not for a Git-controlled file
        LOG.info(String.format("getRepositoryForFile returned non-Git (%s) root for file %s", vcs.getDisplayName(), filePath));
      }
      return null;
    }
    return getRepositoryForRoot(vcsRoot.getPath());
  }

  @Override
  @NotNull
  public List<GitRepository> getRepositories() {
    try {
      REPO_LOCK.readLock().lock();
      return GitUtil.sortRepositories(myRepositories.values());
    }
    finally {
      REPO_LOCK.readLock().unlock();
    }
  }

  @Override
  public boolean moreThanOneRoot() {
    return myRepositories.size() > 1;
  }

  @Override
  public void updateRepository(VirtualFile root) {
    GitRepository repo = getRepositoryForRoot(root);
    if (repo != null) {
      repo.update();
    }
  }

  @Override
  public void updateAllRepositories() {
    Map<VirtualFile, GitRepository> repositories;
    try {
      REPO_LOCK.readLock().lock();
      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);
    }
    finally {
      REPO_LOCK.readLock().unlock();
    }

    for (VirtualFile root : repositories.keySet()) {
      updateRepository(root);
    }
  }

  // note: we are not calling this method during the project startup - it is called anyway by the GitRootTracker
  private void updateRepositoriesCollection() {
    Map<VirtualFile, GitRepository> repositories;
    try {
      REPO_LOCK.readLock().lock();
      repositories = new HashMap<VirtualFile, GitRepository>(myRepositories);
    }
    finally {
      REPO_LOCK.readLock().unlock();
    }

    final VirtualFile[] roots = myVcsManager.getRootsUnderVcs(myVcs);
      // remove repositories that are not in the roots anymore
      for (Iterator<Map.Entry<VirtualFile, GitRepository>> iterator = repositories.entrySet().iterator(); iterator.hasNext(); ) {
        if (!ArrayUtil.contains(iterator.next().getValue().getRoot(), roots)) {
          iterator.remove();
        }
      }
      // add GitRepositories for all roots that don't have correspondent GitRepositories yet.
      for (VirtualFile root : roots) {
        if (!repositories.containsKey(root)) {
          if (gitRootOK(root)) {
            try {
              GitRepository repository = createGitRepository(root);
              repositories.put(root, repository);
            }
            catch (GitRepoStateException e) {
              LOG.error("Couldn't initialize GitRepository in " + root.getPresentableUrl(), e);
            }
          }
          else {
            LOG.info("Invalid Git root: " + root);
          }
        }
      }

    REPO_LOCK.writeLock().lock();
    try {
      myRepositories.clear();
      myRepositories.putAll(repositories);
    }
    finally {
        REPO_LOCK.writeLock().unlock();
    }
  }

  private static boolean gitRootOK(@NotNull VirtualFile root) {
    VirtualFile gitDir = root.findChild(GitUtil.DOT_GIT);
    return gitDir != null && gitDir.exists();
  }

  private GitRepository createGitRepository(VirtualFile root) {
    return GitRepositoryImpl.getFullInstance(root, myProject, myPlatformFacade, this);
  }

  @Override
  public String toString() {
    return "GitRepositoryManager{myRepositories: " + myRepositories + '}';
  }

}
```


Overlapping Code:
```
tractProjectComponent implements Disposable, GitRepositoryManager, VcsListener {
private static final Logger LOG = Logger.getInstance(GitRepositoryManager.class);
@NotNull private final AbstractVcs myVcs;
@NotNull private final ProjectLevelVcsManager myVcsManager;
@NotNull private final Map<VirtualFile, GitRepository> myRepositories = new HashMap<VirtualFile, GitRepository>();
@NotNull private final ReentrantReadWriteLock REPO_LOCK = new ReentrantReadWriteLock();
@NotNull private final GitPlatformFacade myPlatformFacade;
public GitRepositoryManagerImpl(@NotNull Project project, @NotNull GitPlatformFacade platformFacade) {
super(project);
myPlatformFacade = platformFacade;
myVcsManager = ProjectLevelVcsManager.getInstance(myProject);
myVcs = platformFacade.getVcs(myProject);
}
@Override
public void initComponent() {
Disposer.register(myProject, this);
myProject.getMessageBus().connect().subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED, this);
GitRootScanner rootScanner = new GitRootScanner(myProject);
Disposer.register(this, rootScanner);
}
@Override
public void dispose() {
try {
REPO_LOCK.writeLock().lock();
myRepositories.clear();
}
finally {
REPO_LOCK.writeLock().unlock();
}
}
@Override
public void directoryMappingChanged() {
updateRepositoriesCollection();
}
@Override
@Nullable
public GitRepository getRepositoryForRoot(@Nullable VirtualFile root) {
if (root == null) {
return null;
}
try {
REPO_LOCK.readLock().lock();
return myRepositories.get(root);
}
finally {
REPO_LOCK.readLock().unlock();
}
}
@Override
@Nullable
public GitRepository getRepositoryForFile(@NotNull VirtualFile file) {
final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);
return getRepositoryForVcsRoot(vcsRoot, file.getPath());
}
@Override
public GitRepository getRepositoryForFile(@NotNull FilePath file) {
final VcsRoot vcsRoot = myVcsManager.getVcsRootObjectFor(file);
return getRepositoryForVcsRoot(vcsRoot, file.getPath());
}
@Nullable
private GitRepository getRepositoryForVcsRoot(VcsRoot vcsRoot, String filePath) {
if (vcsRoot == null) {
return null;
}
final AbstractVcs vcs = vcsRoot.getVcs();
if (!myVcs.equals(vcs)) {
if (vcs != null) {
// if null, the file is just not u
```
<Overlap Ratio: 0.974745237040319>

---

--- 313 --
Question ID: e13ef3b5b38848d557b2834b678da71689547c16
Original Code:
```
public class ScreenUtil {

    /**
     * 获取屏幕像素
     *
     * @param context
     * @return widthPixels, heightPixels
     */
    public static int[] getPixels(Context context) {
        WindowManager windowManager =
                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        if (windowManager == null) return new int[]{0, 0};
        DisplayMetrics metrics = new DisplayMetrics();
        windowManager.getDefaultDisplay().getMetrics(metrics);
        return new int[]{metrics.widthPixels, metrics.heightPixels};
    }
}
```


Overlapping Code:
```
ram context
* @return widthPixels, heightPixels
*/
public static int[] getPixels(Context context) {
WindowManager windowManager =
(WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
if (windowManager == null) return new int[]{0, 0};
DisplayMetrics metrics = new DisplayMetrics();
windowManager.getDefaultDisplay().getMetrics(metrics);
return new int[]{metrics.widthPixels, metrics.heightPixels};
}
}
```
<Overlap Ratio: 0.8997821350762527>

---

--- 314 --
Question ID: acae353ff26e8aa7a37623fb47732b221f51e668
Original Code:
```
@Test
public class BusinessDayConventionTest {

  private static final LocalDate FRI_2014_07_11 = LocalDate.of(2014, 7, 11);
  private static final LocalDate SAT_2014_07_12 = LocalDate.of(2014, 7, 12);
  private static final LocalDate SUN_2014_07_13 = LocalDate.of(2014, 7, 13);
  private static final LocalDate MON_2014_07_14 = LocalDate.of(2014, 7, 14);
  private static final LocalDate TUE_2014_07_15 = LocalDate.of(2014, 7, 15);

  private static final LocalDate FRI_2014_08_29 = LocalDate.of(2014, 8, 29);
  private static final LocalDate SAT_2014_08_30 = LocalDate.of(2014, 8, 30);
  private static final LocalDate SUN_2014_08_31 = LocalDate.of(2014, 8, 31);
  private static final LocalDate MON_2014_09_01 = LocalDate.of(2014, 9, 1);

  private static final LocalDate FRI_2014_10_31 = LocalDate.of(2014, 10, 31);
  private static final LocalDate SAT_2014_11_01 = LocalDate.of(2014, 11, 1);
  private static final LocalDate SUN_2014_11_02 = LocalDate.of(2014, 11, 2);
  private static final LocalDate MON_2014_11_03 = LocalDate.of(2014, 11, 3);

  private static final LocalDate FRI_2014_11_14 = LocalDate.of(2014, 11, 14);
  private static final LocalDate SAT_2014_11_15 = LocalDate.of(2014, 11, 15);
  private static final LocalDate SUN_2014_11_16 = LocalDate.of(2014, 11, 16);
  private static final LocalDate MON_2014_11_17 = LocalDate.of(2014, 11, 17);

  //-------------------------------------------------------------------------
  @DataProvider(name = "types")
  static Object[][] data_types() {
    StandardBusinessDayConventions[] conv = StandardBusinessDayConventions.values();
    Object[][] result = new Object[conv.length][];
    for (int i = 0; i < conv.length; i++) {
      result[i] = new Object[] {conv[i]};
    }
    return result;
  }

  @Test(dataProvider = "types")
  public void test_null(BusinessDayConvention type) {
    assertThrows(() -> type.adjust(null, HolidayCalendars.NO_HOLIDAYS), IllegalArgumentException.class);
    assertThrows(() -> type.adjust(FRI_2014_11_14, null), IllegalArgumentException.class);
    assertThrows(() -> type.adjust(null, null), IllegalArgumentException.class);
  }

  //-------------------------------------------------------------------------
  @DataProvider(name = "convention")
  static Object[][] data_convention() {
    return new Object[][] {
        {NO_ADJUST, FRI_2014_07_11, FRI_2014_07_11},
        {NO_ADJUST, SAT_2014_07_12, SAT_2014_07_12},
        {NO_ADJUST, SUN_2014_07_13, SUN_2014_07_13},
        {NO_ADJUST, MON_2014_07_14, MON_2014_07_14},

        {FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},
        {FOLLOWING, SAT_2014_07_12, MON_2014_07_14},
        {FOLLOWING, SUN_2014_07_13, MON_2014_07_14},
        {FOLLOWING, MON_2014_07_14, MON_2014_07_14},

        {FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},
        {FOLLOWING, SAT_2014_08_30, MON_2014_09_01},
        {FOLLOWING, SUN_2014_08_31, MON_2014_09_01},
        {FOLLOWING, MON_2014_09_01, MON_2014_09_01},

        {FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},
        {FOLLOWING, SAT_2014_11_01, MON_2014_11_03},
        {FOLLOWING, SUN_2014_11_02, MON_2014_11_03},
        {FOLLOWING, MON_2014_11_03, MON_2014_11_03},

        {MODIFIED_FOLLOWING, FRI_2014_07_11, FRI_2014_07_11},
        {MODIFIED_FOLLOWING, SAT_2014_07_12, MON_2014_07_14},
        {MODIFIED_FOLLOWING, SUN_2014_07_13, MON_2014_07_14},
        {MODIFIED_FOLLOWING, MON_2014_07_14, MON_2014_07_14},

        {MODIFIED_FOLLOWING, FRI_2014_08_29, FRI_2014_08_29},
        {MODIFIED_FOLLOWING, SAT_2014_08_30, FRI_2014_08_29},  // modified
        {MODIFIED_FOLLOWING, SUN_2014_08_31, FRI_2014_08_29},  // modified
        {MODIFIED_FOLLOWING, MON_2014_09_01, MON_2014_09_01},

        {MODIFIED_FOLLOWING, FRI_2014_10_31, FRI_2014_10_31},
        {MODIFIED_FOLLOWING, SAT_2014_11_01, MON_2014_11_03},
        {MODIFIED_FOLLOWING, SUN_2014_11_02, MON_2014_11_03},
        {MODIFIED_FOLLOWING, MON_2014_11_03, MON_2014_11_03},

        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_07_11, FRI_2014_07_11},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_07_12, MON_2014_07_14},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_07_13, MON_2014_07_14},
        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_07_14, MON_2014_07_14},

        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_08_29, FRI_2014_08_29},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_08_30, FRI_2014_08_29},  // modified
        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_08_31, FRI_2014_08_29},  // modified
        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_09_01, MON_2014_09_01},

        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_10_31, FRI_2014_10_31},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_01, MON_2014_11_03},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_02, MON_2014_11_03},
        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_03, MON_2014_11_03},

        {MODIFIED_FOLLOWING_BI_MONTHLY, FRI_2014_11_14, FRI_2014_11_14},
        {MODIFIED_FOLLOWING_BI_MONTHLY, SAT_2014_11_15, FRI_2014_11_14},  // modified
        {MODIFIED_FOLLOWING_BI_MONTHLY, SUN_2014_11_16, MON_2014_11_17},
        {MODIFIED_FOLLOWING_BI_MONTHLY, MON_2014_11_17, MON_2014_11_17},

        {PRECEDING, FRI_2014_07_11, FRI_2014_07_11},
        {PRECEDING, SAT_2014_07_12, FRI_2014_07_11},
        {PRECEDING, SUN_2014_07_13, FRI_2014_07_11},
        {PRECEDING, MON_2014_07_14, MON_2014_07_14},

        {PRECEDING, FRI_2014_08_29, FRI_2014_08_29},
        {PRECEDING, SAT_2014_08_30, FRI_2014_08_29},
        {PRECEDING, SUN_2014_08_31, FRI_2014_08_29},
        {PRECEDING, MON_2014_09_01, MON_2014_09_01},

        {PRECEDING, FRI_2014_10_31, FRI_2014_10_31},
        {PRECEDING, SAT_2014_11_01, FRI_2014_10_31},
        {PRECEDING, SUN_2014_11_02, FRI_2014_10_31},
        {PRECEDING, MON_2014_11_03, MON_2014_11_03},

        {MODIFIED_PRECEDING, FRI_2014_07_11, FRI_2014_07_11},
        {MODIFIED_PRECEDING, SAT_2014_07_12, FRI_2014_07_11},
        {MODIFIED_PRECEDING, SUN_2014_07_13, FRI_2014_07_11},
        {MODIFIED_PRECEDING, MON_2014_07_14, MON_2014_07_14},

        {MODIFIED_PRECEDING, FRI_2014_08_29, FRI_2014_08_29},
        {MODIFIED_PRECEDING, SAT_2014_08_30, FRI_2014_08_29},
        {MODIFIED_PRECEDING, SUN_2014_08_31, FRI_2014_08_29},
        {MODIFIED_PRECEDING, MON_2014_09_01, MON_2014_09_01},

        {MODIFIED_PRECEDING, FRI_2014_10_31, FRI_2014_10_31},
        {MODIFIED_PRECEDING, SAT_2014_11_01, MON_2014_11_03},  // modified
        {MODIFIED_PRECEDING, SUN_2014_11_02, MON_2014_11_03},  // modified
        {MODIFIED_PRECEDING, MON_2014_11_03, MON_2014_11_03},

        {NEAREST, FRI_2014_07_11, FRI_2014_07_11},
        {NEAREST, SAT_2014_07_12, FRI_2014_07_11},
        {NEAREST, SUN_2014_07_13, MON_2014_07_14},
        {NEAREST, MON_2014_07_14, MON_2014_07_14},
    };
  }

  @Test(dataProvider = "convention")
  public void test_convention(BusinessDayConvention convention, LocalDate input, LocalDate expected) {
    assertEquals(convention.adjust(input, HolidayCalendars.SAT_SUN), expected);
  }

  public void test_nearest() {
    HolidayCalendar cal = ImmutableHolidayCalendar.of("Test", ImmutableList.of(MON_2014_07_14), SATURDAY, SUNDAY);
    assertEquals(NEAREST.adjust(FRI_2014_07_11, cal), FRI_2014_07_11);
    assertEquals(NEAREST.adjust(SAT_2014_07_12, cal), FRI_2014_07_11);
    assertEquals(NEAREST.adjust(SUN_2014_07_13, cal), TUE_2014_07_15);
    assertEquals(NEAREST.adjust(MON_2014_07_14, cal), TUE_2014_07_15);
  }

  //-------------------------------------------------------------------------
  @DataProvider(name = "name")
  static Object[][] data_name() {
    return new Object[][] {
        {NO_ADJUST, "NoAdjust"},
        {FOLLOWING, "Following"},
        {MODIFIED_FOLLOWING, "ModifiedFollowing"},
        {MODIFIED_FOLLOWING_BI_MONTHLY, "ModifiedFollowingBiMonthly"},
        {PRECEDING, "Preceding"},
        {MODIFIED_PRECEDING, "ModifiedPreceding"},
        {NEAREST, "Nearest"},
    };
  }

  @Test(dataProvider = "name")
  public void test_name(BusinessDayConvention convention, String name) {
    assertEquals(convention.getName(), name);
  }

  @Test(dataProvider = "name")
  public void test_toString(BusinessDayConvention convention, String name) {
    assertEquals(convention.toString(), name);
  }

  @Test(dataProvider = "name")
  public void test_of_lookup(BusinessDayConvention convention, String name) {
    assertEquals(BusinessDayConvention.of(name), convention);
  }

  @Test(dataProvider = "name")
  public void test_extendedEnum(BusinessDayConvention convention, String name) {
    ImmutableMap<String, BusinessDayConvention> map = BusinessDayConvention.extendedEnum().lookupAll();
    assertEquals(map.get(name), convention);
  }

  public void test_of_lookup_notFound() {
    assertThrows(() -> BusinessDayConvention.of("Rubbish"), IllegalArgumentException.class);
  }

  public void test_of_lookup_null() {
    assertThrows(() -> BusinessDayConvention.of(null), IllegalArgumentException.class);
  }

  //-------------------------------------------------------------------------
  public void coverage() {
    coverPrivateConstructor(BusinessDayConventions.class);
    coverEnum(StandardBusinessDayConventions.class);
  }

  public void test_serialization() {
    assertSerialization(NO_ADJUST);
  }

  public void test_jodaConvert() {
    assertJodaConvert(BusinessDayConvention.class, NO_ADJUST);
    assertJodaConvert(BusinessDayConvention.class, MODIFIED_FOLLOWING);
  }

}
```


Overlapping Code:
```
ssDayConventionTest {
private static final LocalDate FRI_2014_07_11 = LocalDate.of(2014, 7, 11);
private static final LocalDate SAT_2014_07_12 = LocalDate.of(2014, 7, 12);
private static final LocalDate SUN_2014_07_13 = LocalDate.of(2014, 7, 13);
private static final LocalDate MON_2014_07_14 = LocalDate.of(2014, 7, 14);
private static final LocalDate TUE_2014_07_15 = LocalDate.of(2014, 7, 15);
private static final LocalDate FRI_2014_08_29 = LocalDate.of(2014, 8, 29);
private static final LocalDate SAT_2014_08_30 = LocalDate.of(2014, 8, 30);
private static final LocalDate SUN_2014_08_31 = LocalDate.of(2014, 8, 31);
private static final LocalDate MON_2014_09_01 = LocalDate.of(2014, 9, 1);
private static final LocalDate FRI_2014_10_31 = LocalDate.of(2014, 10, 31);
private static final LocalDate SAT_2014_11_01 = LocalDate.of(2014, 11, 1);
private static final LocalDate SUN_2014_11_02 = LocalDate.of(2014, 11, 2);
private static final LocalDate MON_2014_11_03 = LocalDate.of(2014, 11, 3);
private static final LocalDate FRI_2014_11_14 = LocalDate.of(2014, 11, 14);
private static final LocalDate SAT_2014_11_15 = LocalDate.of(2014, 11, 15);
private static final LocalDate SUN_2014_11_16 = LocalDate.of(2014, 11, 16);
private static final LocalDate MON_2014_11_17 = LocalDate.of(2014, 11, 17);
//-------------------------------------------------------------------------
@DataProvider(name = "types")
static Object[][] data_types() {
StandardBusinessDayConventions[] conv = StandardBusinessDayConventions.values();
Object[][] result = new Object[conv.length][];
for (int i = 0; i < conv.length; i++) {
result[i] = new Object[] {conv[i]};
}
return result;
}
@Test(dataProvider = "types")
public void test_null(BusinessDayConvention type) {
assertThrows(() -> type.adjust(null, HolidayCalendars.NO_HOLIDAYS), IllegalArgumentException.class);
assertThrows(() -> type.adjust(FRI_2014_11_14, null), IllegalArgumentException.class);
assertThrows(() -> type.adjust(null, null), IllegalArgumentException.class);
}
//-------------------------------------------------------------------------
@DataProvider(name = "convention")
static Object[][] data_convention() {
return new Object[][] {
{NO_ADJUST, FRI_2014_07_11, FRI_2014_07_11},
{NO_ADJUST, SAT_2014_07_12, SAT_2014_07_12},
{NO_ADJUST, SUN_2014_07_1
```
<Overlap Ratio: 0.9729272419627749>

---

--- 315 --
Question ID: bf7162efaf1e0020b71320c90f61d2948a0517f5
Original Code:
```
@Slf4j
public class LoggingODataErrorCallback implements ODataErrorCallback {

	/**
	 * Called when an exception is catched in the OData service.
	 * <p>
	 * Simply logs the exception thrown and produces the default error response.
	 * {@link ContainerManagedODataJPAServiceFactory#setDetailErrors(boolean)} can define how
	 * detailed the error description will be.
	 * <p>
	 * You can also customize the error message by calling:
	 * <ul>
	 * <li>{@link ODataErrorContext#setInnerError(String)}</li>
	 * <li>{@link ODataErrorContext#setMessage(String)}</li>
	 * <li>{@link ODataErrorContext#setErrorCode(String)}</li>
	 * <ul>
	 * <p>
	 */
	@Override
	public ODataResponse handleError(ODataErrorContext context) throws ODataApplicationException {
		Throwable exception = context.getException();
		log.error("Handle error", exception);
		
		return EntityProvider.writeErrorDocument(context);
	}

}
```


Overlapping Code:
```
@Slf4j
public class LoggingODataErrorCallback implements ODataErrorCallback {
/**
* Called when an exception is catched in the OData service.
* <p>
* Simply logs the exception thrown and produces the default error response.
* {@link ContainerManagedODataJPAServiceFactory#setDetailErrors(boolean)} can define how
* detailed the error description will be.
* <p>
* You can also customize the error message by calling:
* <ul>
* <li>{@link ODataErrorContext#setInnerError(String)}</li>
* <li>{@link ODataErrorContext#setMessage(String)}</li>
* <li>{@link ODataErrorContext#setErrorCode(String)}</li>
* <ul>
* <p>
*/
@Override
public ODataResponse handleError(ODataErrorContext context) throws ODataApplicationException {
Throwable exception = context.getException();
log.error("Handle error", exception);

return EntityProvider.writeErrorDocument(context);
}
```
<Overlap Ratio: 0.9976635514018691>

---

--- 316 --
Question ID: 7c1989cc73e0ef77b697ddb4c729848c6d9e4f94
Original Code:
```
@Slf4j
public class Iso8601DateFormat
{
  public static final String BASIC_FORMAT = "yyyyMMdd'T'HHmmssZ";
  private static final String GMT = "GMT";

  // 20031107T152420-0500  or
  // 2003-11-07T15:24:20-05:00
  private static final Pattern PATTERN_MATCH =
    Pattern.compile(
      "^(?:(\\d{2,4})-?)?" + // year
      "(?:(\\d{2})-?)?" + // month
      "(\\d{2})?" + // day of month
      "T?" + // time separator
      "(?:(\\d{2}):?)?" + // hour
      "(?:(\\d{2}):?)?" + // minutes
      "(\\d{2})?" + // seconds
      "(Z?|(?:\\+|-).+)?$"); // timezone: -0500 or +08:00 or -05 or Z
  private String pattern;

  /**
   * Creates a new Iso8601DateFormat object.
   */
  public Iso8601DateFormat()
  {
    log.debug("new Iso8601DateFormat()");
    this.pattern = BASIC_FORMAT;
  }

  /**
   * DOCUMENT ME!
   *
   * @param simpleDateFormatPattern
   *
   * @see java.text.SimpleDateFormat
   */
  public Iso8601DateFormat(String simpleDateFormatPattern)
  {
    log.debug("new Iso8601DateFormat(String " + simpleDateFormatPattern + ")");
    this.pattern = simpleDateFormatPattern;
  }

  /**
   * DOCUMENTATION PENDING
   *
   * @param date DOCUMENTATION PENDING
   *
   * @return DOCUMENTATION PENDING
   */
  public String format(Date date)
  {
    log.debug("format(Date " + date + ")");
    SimpleDateFormat sdf = null;
    if(this.pattern == null)
    {
      sdf = new SimpleDateFormat();
    }
    else
    {
      sdf = new SimpleDateFormat(pattern);
    }

    return sdf.format(date);
  }

  /**
   * DOCUMENTATION PENDING
   *
   * @param iso8601String DOCUMENTATION PENDING
   *
   * @return DOCUMENTATION PENDING
   *
   * @throws Iso8601FormatException DOCUMENTATION PENDING
   */
  public Calendar parse(String iso8601String)
    throws Iso8601FormatException
  {
    log.debug("parse(String " + iso8601String + ")");
    if(iso8601String == null)
    {
      throw new Iso8601FormatException(
        "illegal String iso8601TimeInterval argument: iso8601String == null");
    }

    iso8601String = iso8601String.toUpperCase();
    final Matcher matcher = PATTERN_MATCH.matcher(iso8601String);
    if(matcher.matches())
    {
      if(log.isDebugEnabled())
      {
        for(int i = 0; i <= matcher.groupCount(); i++)
        {
          log.debug(i + "=" + matcher.group(i));
        }
      }

      String tz = matcher.group(7);
      Calendar cal = null;
      if((tz != null) && (tz.length() > 0))
      {
        if("Z".equals(tz))
        {
          tz = "Zulu";
        }
        else
        {
          tz = GMT + tz;
        }

        if(log.isDebugEnabled())
        {
          log.debug("tz=" + tz);
          log.debug("TimeZone.getID()=" + TimeZone.getTimeZone(tz).getID());
        }

        cal = GregorianCalendar.getInstance(TimeZone.getTimeZone(tz));
      }
      else
      {
        cal = GregorianCalendar.getInstance();

        /* data must be zeroed out to counteract now behavior*/
        cal.clear();
      }

      /* year */
      if(matcher.group(1) != null)
      {
        final int year = Integer.parseInt(matcher.group(1));
        cal.set(Calendar.YEAR, year);
      }
      else
      {
        throw new Iso8601FormatException("Year is required");
      }

      /* month */
      if(matcher.group(2) != null)
      {
        final int month = Integer.parseInt(matcher.group(2)) - 1; // zero based
        cal.set(Calendar.MONTH, month);
      }

      /* date (day) */
      if(matcher.group(3) != null)
      {
        final int date = Integer.parseInt(matcher.group(3));
        cal.set(Calendar.DAY_OF_MONTH, date);
      }

      /* hour */
      if(matcher.group(4) != null)
      {
        final int hour = Integer.parseInt(matcher.group(4));
        cal.set(Calendar.HOUR_OF_DAY, hour);
      }

      /* minutes */
      if(matcher.group(5) != null)
      {
        final int min = Integer.parseInt(matcher.group(5));
        cal.set(Calendar.MINUTE, min);
      }

      /* seconds */
      if(matcher.group(6) != null)
      {
        final int sec = Integer.parseInt(matcher.group(6));
        cal.set(Calendar.SECOND, sec);
      }

      return cal;
    }

    throw new Iso8601FormatException("ISO8601 format could not be matched");
  }
}
```


Overlapping Code:
```
ass Iso8601DateFormat
{
public static final String BASIC_FORMAT = "yyyyMMdd'T'HHmmssZ";
private static final String GMT = "GMT";
// 20031107T152420-0500 or
// 2003-11-07T15:24:20-05:00
private static final Pattern PATTERN_MATCH =
Pattern.compile(
"^(?:(\\d{2,4})-?)?" + // year
"(?:(\\d{2})-?)?" + // month
"(\\d{2})?" + // day of month
"T?" + // time separator
"(?:(\\d{2}):?)?" + // hour
"(?:(\\d{2}):?)?" + // minutes
"(\\d{2})?" + // seconds
"(Z?|(?:\\+|-).+)?$"); // timezone: -0500 or +08:00 or -05 or Z
private String pattern;
/**
* Creates a new Iso8601DateFormat object.
*/
public Iso8601DateFormat()
{
log.debug("new Iso8601DateFormat()");
this.pattern = BASIC_FORMAT;
}
/**
* DOCUMENT ME!
*
* @param simpleDateFormatPattern
*
* @see java.text.SimpleDateFormat
*/
public Iso8601DateFormat(String simpleDateFormatPattern)
{
log.debug("new Iso8601DateFormat(String " + simpleDateFormatPattern + ")");
this.pattern = simpleDateFormatPattern;
}
/**
* DOCUMENTATION PENDING
*
* @param date DOCUMENTATION PENDING
*
* @return DOCUMENTATION PENDING
*/
public String format(Date date)
{
log.debug("format(Date " + date + ")");
SimpleDateFormat sdf = null;
if(this.pattern == null)
{
sdf = new SimpleDateFormat();
}
else
{
sdf = new SimpleDateFormat(pattern);
}
return sdf.format(date);
}
/**
* DOCUMENTATION PENDING
*
* @param iso8601String DOCUMENTATION PENDING
*
* @return DOCUMENTATION PENDING
*
* @throws Iso8601FormatException DOCUMENTATION PENDING
*/
public Calendar parse(String iso8601String)
throws Iso8601FormatException
{
log.debug("parse(String " + iso8601String + ")");
if(iso8601String == null)
{
throw new Iso8601FormatException(
"illegal String iso8601TimeInterval argument: iso8601String == null");
}
iso8601String = iso8601String.toUpperCase();
final Matcher matcher = PATTERN_MATCH.matcher(iso8601String);
if(matcher.matches())
{
if(log.isDebugEnabled())
{
for(int i = 0; i <= matcher.groupCount(); i++)
{
log.debug(i + "=" + matcher.group(i));
}
}
String tz = matcher.group(7);
Calendar cal = null;
if((tz != null) && (tz.length(
```
<Overlap Ratio: 0.9720246562351825>

---

--- 317 --
Question ID: e2f38036b45e16efbd8e9cbd243b8364127535d0
Original Code:
```
public class AppointmentManager {
    public static final LocalTime OPENING_HOUR = LocalTime.parse("09:00");
    public static final LocalTime CLOSING_HOUR = LocalTime.parse("18:00");

    private final List<Appointment> appointments;

    public AppointmentManager() {
        appointments = new ArrayList<>();
    }

    public List<Appointment> getAppointmentList() {
        return appointments;
    }

    public void delete(Appointment app) {
        appointments.remove(app);
    }

    public boolean hasDuplicateAppointment(Appointment app) {
        return appointments.contains(app);
    }


    /**
     * Finds and returns the {@code Appointment} in the list of appointments with the given date and start time,
     * if it exists.
     *
     * @param date the {@code LocalDate} date of the {@code Appointment} to find.
     * @param start the {@code LocalTime} start time of the {@code Appointment} to find.
     * @return the {@code Appointment} found, if it exists, else returns {@code Optional.empty()}.
     */
    public Optional<Appointment> getAppointment(LocalDate date, LocalTime start) {
        List<Appointment> filtered = appointments.stream()
                .filter(a -> a.getDate().equals(date))
                .filter(a -> a.getStart().equals(start))
                .collect(Collectors.toList());

        // filtered cannot contain > 1 appointment as each appointment is uniquely identified by its
        // date and start fields.
        assert filtered.size() <= 1;

        if (filtered.isEmpty()) {
            return Optional.empty();
        } else {
            return Optional.of(filtered.get(0));
        }
    }

    /**
     * Returns a {@code List} of {@code Appointment}s that are within the given search range of dates.
     *
     * @param start the {@code LocalDate start} date of the search range.
     * @param end the {@code LocalDate end} date of the search range.
     * @return {@code List} of {@code Appointment}s that has dates from {@code start} to {@code end}.
     */
    private List<Appointment> getAppointments(LocalDate start, LocalDate end) {
        List<Appointment> validApps = new ArrayList<>();
        LocalDate date;

        for (Appointment app : appointments) {
            date = app.getDate();
            // Add appointments to validApps only with dates between the given range (inclusive)
            if (date.compareTo(start) >= 0 && date.compareTo(end) <= 0) {
                validApps.add(app);
            }

            // Stop adding when date of appointment is after given end date, since appointments are already sorted
            if (date.compareTo(end) > 0) {
                break;
            }
        }
        return validApps;
    }

    /**
     * Returns a {@code List} of {@code Appointment}s that were created for the given {@code Patient}.
     *
     * @param patient the {@code Patient} whose {@code Appointment}s to be retrieved.
     * @return {@code List} of {@code Appointment}s that were created for {@code Patient patient}.
     */
    private List<Appointment> getAppointments(Patient patient) {
        List<Appointment> validApps = new ArrayList<>();

        for (Appointment app : appointments) {
            // Add appointments to validApps only if they were created for the given patient
            if (app.getPatient().equals(patient)) {
                validApps.add(app);
            }
        }
        return validApps;
    }

    /**
     * Adds an {@code Appointment} to the ordered list of appointments, in the correct position.
     *
     * @param toAdd the {@code Appointment} to add.
     */
    public void addAppointment(Appointment toAdd) {
        // checking for time conflicts should have happened in AddAppCommand
        assert !this.hasTimeConflicts(toAdd);
        if (appointments.isEmpty()) {
            appointments.add(toAdd);
            return;
        }

        // place appointment in correct position
        for (Appointment app : appointments) {
            if (app.compareTo(toAdd) > 0) {
                int index = appointments.indexOf(app);
                appointments.add(index, toAdd);
                return;
            }
        }

        // toAdd is to be placed at the end of the list
        appointments.add(toAdd);
    }

    /**
     * Checks if there are any conflicts in appointment timings between the current list of appointments
     * and the given {@code Appointment}.
     *
     * @param otherApp given {@code Appointment} to check timing against the existing list of appointments.
     * @return {@code true} if there exists a conflict in timing, else return {@code false}.
     */
    public boolean hasTimeConflicts(Appointment otherApp) {
        LocalDate date = otherApp.getDate();

        for (Appointment app : appointments) {
            if (app.getDate().compareTo(date) == 0) {
                if (hasOverlappingTime(app, otherApp)) {
                    return true;
                }
            } else if (app.getDate().isAfter(date)) {
                // terminate loop early since appointments are already sorted by date and time
                break;
            }
        }
        return false;
    }

    /**
     * Checks if two {@code Appointment}s have an overlap in timing.
     *
     * @param appA first {@code Appointment} given.
     * @param appB second {@code Appontment} given.
     * @return {@code true} if there is an overlap in timing, else return {@code false}.
     */
    private boolean hasOverlappingTime(Appointment appA, Appointment appB) {
        LocalTime startA = appA.getStart();
        LocalTime endA = appA.getEnd();
        LocalTime startB = appB.getStart();
        LocalTime endB = appB.getEnd();

        // shortcut to check for overlaps between two intervals
        return startA.isBefore(endB) && startB.isBefore(endA);
    }

    /**
     * Generates a {@code String} of {@code Appointment} details with dates between a search range, inclusive.
     *
     * @param start the {@code LocalDate start} date of the search range.
     * @param end the {@code LocalDate end} date of the search range.
     * @return {@code String} of {@code Appointment} details with dates from {@code start} to {@code end}.
     */
    public String listAppointments(LocalDate start, LocalDate end) {
        List<Appointment> toList = getAppointments(start, end);
        return listAppointments(toList);
    }

    /**
     * Generates a {@code String} of {@code Appointment} details created for a given {@code Patient}.
     *
     * @param patient the {@code Patient} whose {@code Appointment} details to list.
     * @return {@code String} of {@code Appointment} details created for the given {@code Patient}.
     */
    public String listAppointments(Patient patient) {
        List<Appointment> toList = getAppointments(patient);
        return listAppointments(toList);
    }

    /**
     * Generates a {@code String} of {@code Appointment} details given the appointments.
     *
     * @param appsToList the {@code List} of {@code Appointment}s to list.
     * @return {@code String} of {@code Appointment} details.
     */
    public String listAppointments(List<Appointment> appsToList) {
        StringBuilder sb = new StringBuilder();
        // index of the appointment to be displayed
        int i = 1;

        for (Appointment app : appsToList) {
            sb.append(i)
                    .append(") ")
                    .append(app.toString())
                    .append("\n");
            i++;
        }
        return sb.toString();
    }

    /**
     * Generates a {@code List} of free {@code Slot}s within a given search range of dates.
     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.
     *
     * @param start the {@code LocalDate start} date of the search range.
     * @param end the {@code LocalDate end} date of the search range.
     * @return {@code List} of free {@code Slot}s within the given search range.
     */
    private List<Slot> getFreeSlots(LocalDate start, LocalDate end) {
        List<Slot> freeSlots = new ArrayList<>();
        List<Appointment> toSearch = getAppointments(start, end);

        // all slots are free
        if (toSearch.isEmpty()) {
            for (LocalDate date = start; date.compareTo(end) <= 0; date = date.plusDays(1)) {
                freeSlots.add(new Slot(date, OPENING_HOUR, CLOSING_HOUR));
            }
            return freeSlots;
        }

        Slot slot;
        LocalDate date = start;
        int index = 0;
        Appointment app = toSearch.get(index);
        Appointment prevApp = new Appointment(
                app.getPatient(), app.getDate().minusDays(1), app.getStart(), app.getEnd(), app.getComment());

        // loop through all search dates from the start
        while (date.compareTo(end) <= 0) {

            // no appointments for given date
            if (!date.isEqual(app.getDate())) {
                slot = new Slot(date, OPENING_HOUR, CLOSING_HOUR);
                freeSlots.add(slot);
            }

            LocalTime startTime;
            LocalTime endTime;
            // there are appointments in given date
            while (date.isEqual(app.getDate())) {

                // start a new slot for the day
                if (prevApp.getDate().isBefore(date)) {
                    startTime = OPENING_HOUR;
                } else {
                    startTime = prevApp.getEnd();
                }
                endTime = app.getStart();

                // do not add a free slot if the start time and end time are the same
                if (startTime != endTime) {
                    slot = new Slot(date, startTime, endTime);
                    freeSlots.add(slot);
                }
                prevApp = app;

                // no more next appointment, create last slot for the day
                if (toSearch.size() == index + 1 || date.isBefore(toSearch.get(index + 1).getDate())) {
                    startTime = app.getEnd();
                    endTime = CLOSING_HOUR;

                    // do not add a free slot if the start time and end time are the same
                    if (startTime != endTime) {
                        slot = new Slot(date, startTime, endTime);
                        freeSlots.add(slot);
                    }

                    // no more appointments in toSearch
                    if (toSearch.size() == index + 1) {
                        break;
                    }
                }
                index++;
                app = toSearch.get(index);
            }

            date = date.plusDays(1);
        }

        return freeSlots;
    }

    /**
     * Generates a {@code String} of free {@code Slot}s given a search range of dates.
     * A {@code Slot} is free if there are no {@code Appointment}s scheduled during that time slot.
     *
     * @param start the {@code LocalDate start} date of the search range.
     * @param end the {@code LocalDate end} date of the search range.
     * @return {@code String} of free {@code Slot}s within the given search range.
     */
    public String listFreeSlots(LocalDate start, LocalDate end) {
        List<Slot> freeSlots = getFreeSlots(start, end);
        StringBuilder sb = new StringBuilder();
        LocalDate date = start.minusDays(1);

        for (Slot slot : freeSlots) {
            // start listing for a new date
            if (slot.getDate().isAfter(date)) {
                date = slot.getDate();
                sb.append("\n")
                        .append(date)
                        .append(": ");
            } else {
                sb.append(", ");
            }

            // Whole day is free
            if (slot.getStart().equals(OPENING_HOUR) && slot.getEnd().equals(CLOSING_HOUR)) {
                sb.append("All slots are free");
            } else {
                sb.append(slot.getStart())
                        .append(" to ")
                        .append(slot.getEnd());
            }
        }
        return sb.toString();
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        if (!(other instanceof AppointmentManager)) {
            return false;
        }

        AppointmentManager otherManager = (AppointmentManager) other;
        return otherManager.appointments.equals(this.appointments);
    }
}
```


Overlapping Code:
```
c static final LocalTime OPENING_HOUR = LocalTime.parse("09:00");
public static final LocalTime CLOSING_HOUR = LocalTime.parse("18:00");
private final List<Appointment> appointments;
public AppointmentManager() {
appointments = new ArrayList<>();
}
public List<Appointment> getAppointmentList() {
return appointments;
}
public void delete(Appointment app) {
appointments.remove(app);
}
public boolean hasDuplicateAppointment(Appointment app) {
return appointments.contains(app);
}
/**
* Finds and returns the {@code Appointment} in the list of appointments with the given date and start time,
* if it exists.
*
* @param date the {@code LocalDate} date of the {@code Appointment} to find.
* @param start the {@code LocalTime} start time of the {@code Appointment} to find.
* @return the {@code Appointment} found, if it exists, else returns {@code Optional.empty()}.
*/
public Optional<Appointment> getAppointment(LocalDate date, LocalTime start) {
List<Appointment> filtered = appointments.stream()
.filter(a -> a.getDate().equals(date))
.filter(a -> a.getStart().equals(start))
.collect(Collectors.toList());
// filtered cannot contain > 1 appointment as each appointment is uniquely identified by its
// date and start fields.
assert filtered.size() <= 1;
if (filtered.isEmpty()) {
return Optional.empty();
} else {
return Optional.of(filtered.get(0));
}
}
/**
* Returns a {@code List} of {@code Appointment}s that are within the given search range of dates.
*
* @param start the {@code LocalDate start} date of the search range.
* @param end the {@code LocalDate end} date of the search range.
* @return {@code List} of {@code Appointment}s that has dates from {@code start} to {@code end}.
*/
private List<Appointment> getAppointments(LocalDate start, LocalDate end) {
List<Appointment> validApps = new ArrayList<>();
LocalDate date;
for (Appointment app : appointments) {
date = app.getDate();
// Add appointments to validApps only with dates between the given range (inclusive)
if (date.compareTo(start) >= 0 && date.compareTo(end) <= 0) {
vali
```
<Overlap Ratio: 0.97340930674264>

---

--- 318 --
Question ID: 3064f42d658ff54d36b408b13285844915338959
Original Code:
```
public final class LsBenchLsSetup {

    private LsBenchLsSetup() {
    }

    public static LogstashInstallation logstashFromGit(final String pwd, final String version,
        final JRubyInstallation jruby) {
        final File lsdir = Paths.get(pwd, "logstash").toFile();
        final LogstashInstallation logstash;
        if (version.contains("#")) {
            final String[] parts = version.split("#");
            logstash = new LogstashInstallation.FromGithub(lsdir, parts[0], parts[1], jruby);
        } else {
            logstash = new LogstashInstallation.FromGithub(lsdir, version, jruby);
        }
        return logstash;
    }

    public static LogstashInstallation setupLS(final String pwd, final String version,
        final LsVersionType type, final UserOutput output) {
        final LogstashInstallation logstash;
        if (type == LsVersionType.LOCAL) {
            logstash = new LogstashInstallation.FromLocalPath(version);
        } else {
            logstash = new LogstashInstallation.FromRelease(
                Paths.get(pwd, String.format("ls-release-%s", version)).toFile(), version, output
            );
        }
        return logstash;
    }
}
```


Overlapping Code:
```
 final class LsBenchLsSetup {
private LsBenchLsSetup() {
}
public static LogstashInstallation logstashFromGit(final String pwd, final String version,
final JRubyInstallation jruby) {
final File lsdir = Paths.get(pwd, "logstash").toFile();
final LogstashInstallation logstash;
if (version.contains("#")) {
final String[] parts = version.split("#");
logstash = new LogstashInstallation.FromGithub(lsdir, parts[0], parts[1], jruby);
} else {
logstash = new LogstashInstallation.FromGithub(lsdir, version, jruby);
}
return logstash;
}
public static LogstashInstallation setupLS(final String pwd, final String version,
final LsVersionType type, final UserOutput output) {
final LogstashInstallation logstash;
if (type == LsVersionType.LOCAL) {
logstash = new LogstashInstallation.FromLocalPath(version);
} else {
logstash = new LogstashInstallation.FromRelease(
Paths.get(pwd, String.format("ls-release-%s", version)).toFile(), version, output
);
}
return
```
<Overlap Ratio: 0.979381443298969>

---

--- 319 --
Question ID: 8d65c9681c50330945f676ab475c960daedb8523
Original Code:
```
public class ConstructionHelmetTeleport implements Listener {
    @EventHandler(ignoreCancelled = true)
    private void onInventoryClickEvent(InventoryClickEvent event) {
        if (event.getCurrentItem() == null)
            return;
        if (event.getCurrentItem().getType() != Material.GOLD_HELMET)
            return;
        InventoryAction click = event.getAction();
        if (!event.getCurrentItem().hasItemMeta() || !event.getCurrentItem().getItemMeta().hasDisplayName() ||
                !event.getCurrentItem().getItemMeta().getDisplayName().equals(ChatColor.DARK_PURPLE + "Construction Helmet"))
            return;
        else if (click == InventoryAction.UNKNOWN || click == InventoryAction.NOTHING)
            return;

        event.setCancelled(true);
        event.getClickedInventory().setItem(event.getSlot(), new ItemStack(Material.AIR));

        Player player = (Player) event.getWhoClicked();
        player.updateInventory();

        String worldName = player.getLocation().getWorld().getName();
        Dungeon dungeon = DungeonMod.getConfigManager().getDungeon(worldName);
        if (dungeon == null)
            return;
        dungeon.teleportPlayerToExit(player);
    }
}
```


Overlapping Code:
```
ublic class ConstructionHelmetTeleport implements Listener {
@EventHandler(ignoreCancelled = true)
private void onInventoryClickEvent(InventoryClickEvent event) {
if (event.getCurrentItem() == null)
return;
if (event.getCurrentItem().getType() != Material.GOLD_HELMET)
return;
InventoryAction click = event.getAction();
if (!event.getCurrentItem().hasItemMeta() || !event.getCurrentItem().getItemMeta().hasDisplayName() ||
!event.getCurrentItem().getItemMeta().getDisplayName().equals(ChatColor.DARK_PURPLE + "Construction Helmet"))
return;
else if (click == InventoryAction.UNKNOWN || click == InventoryAction.NOTHING)
return;
event.setCancelled(true);
event.getClickedInventory().setItem(event.getSlot(), new ItemStack(Material.AIR));
Player player = (Player) event.getWhoClicked();
player.updateInventory();
String worldName = player.getLocation().getWorld().getName();
Dungeon dungeon = DungeonMod.getConfigManager().getDungeon(worldName);
if (dungeon == null)
return;
dungeon.teleportPlayerToExi
```
<Overlap Ratio: 0.9852216748768473>

---

--- 320 --
Question ID: 18e408ad48f9c79560eafb262b0e0535194da6cb
Original Code:
```
public class CassandraEntireSSTableStreamReader implements IStreamReader
{
    private static final Logger logger = LoggerFactory.getLogger(CassandraEntireSSTableStreamReader.class);

    private final TableId tableId;
    private final StreamSession session;
    private final StreamMessageHeader messageHeader;
    private final CassandraStreamHeader header;
    private final int fileSequenceNumber;

    public CassandraEntireSSTableStreamReader(StreamMessageHeader messageHeader, CassandraStreamHeader streamHeader, StreamSession session)
    {
        if (streamHeader.format != SSTableFormat.Type.BIG && streamHeader.format != SSTableFormat.Type.BTI)
            throw new AssertionError("Unsupported SSTable format " + streamHeader.format);

        if (session.getPendingRepair() != null)
        {
            // we should only ever be streaming pending repair sstables if the session has a pending repair id
            if (!session.getPendingRepair().equals(messageHeader.pendingRepair))
                throw new IllegalStateException(format("Stream Session & SSTable (%s) pendingRepair UUID mismatch.", messageHeader.tableId));
        }

        this.header = streamHeader;
        this.session = session;
        this.messageHeader = messageHeader;
        this.tableId = messageHeader.tableId;
        this.fileSequenceNumber = messageHeader.sequenceNumber;
    }

    /**
     * @param in where this reads data from
     * @return SSTable transferred
     * @throws IOException if reading the remote sstable fails. Will throw an RTE if local write fails.
     */
    @SuppressWarnings("resource") // input needs to remain open, streams on top of it can't be closed
    @Override
    public SSTableMultiWriter read(DataInputPlus in) throws IOException
    {
        ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);
        if (cfs == null)
        {
            // schema was dropped during streaming
            throw new IOException("Table " + tableId + " was dropped during streaming");
        }

        ComponentManifest manifest = header.componentManifest;
        long totalSize = manifest.totalSize();

        logger.debug("[Stream #{}] Started receiving sstable #{} from {}, size = {}, table = {}",
                     session.planId(),
                     fileSequenceNumber,
                     session.peer,
                     prettyPrintMemory(totalSize),
                     cfs.metadata());

        SSTableZeroCopyWriter writer = null;

        try
        {
            writer = createWriter(cfs, totalSize, manifest.components());
            long bytesRead = 0;
            for (Component component : manifest.components())
            {
                long length = manifest.sizeOf(component);

                logger.debug("[Stream #{}] Started receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}",
                             session.planId(),
                             component,
                             session.peer,
                             prettyPrintMemory(length),
                             prettyPrintMemory(bytesRead),
                             prettyPrintMemory(totalSize));

                writer.writeComponent(component.type, in, length);
                session.progress(writer.descriptor.filenameFor(component), ProgressInfo.Direction.IN, length, length);
                bytesRead += length;

                logger.debug("[Stream #{}] Finished receiving {} component from {}, componentSize = {}, readBytes = {}, totalSize = {}",
                             session.planId(),
                             component,
                             session.peer,
                             prettyPrintMemory(length),
                             prettyPrintMemory(bytesRead),
                             prettyPrintMemory(totalSize));
            }

            UnaryOperator<StatsMetadata> transform = stats -> stats.mutateLevel(header.sstableLevel)
                                                                   .mutateRepairedMetadata(messageHeader.repairedAt, messageHeader.pendingRepair, false);
            String description = String.format("level %s and repairedAt time %s and pendingRepair %s",
                                               header.sstableLevel, messageHeader.repairedAt, messageHeader.pendingRepair);
            writer.descriptor.getMetadataSerializer().mutate(writer.descriptor, description, transform);
            return writer;
        }
        catch (Throwable e)
        {
            logger.error("[Stream {}] Error while reading sstable from stream for table = {}", session.planId(), cfs.metadata(), e);
            if (writer != null)
                e = writer.abort(e);
            Throwables.throwIfUnchecked(e);
            throw new RuntimeException(e);
        }
    }

    private File getDataDir(ColumnFamilyStore cfs, long totalSize) throws IOException
    {
        Directories.DataDirectory localDir = cfs.getDirectories().getWriteableLocation(totalSize);
        if (localDir == null)
            throw new IOException(format("Insufficient disk space to store %s", prettyPrintMemory(totalSize)));

        File dir = cfs.getDirectories().getLocationForDisk(cfs.getDiskBoundaries().getCorrectDiskForKey(header.firstKey));

        if (dir == null)
            return cfs.getDirectories().getDirectoryForNewSSTables();

        return dir;
    }

    @SuppressWarnings("resource")
    protected SSTableZeroCopyWriter createWriter(ColumnFamilyStore cfs, long totalSize, Collection<Component> components) throws IOException
    {
        File dataDir = getDataDir(cfs, totalSize);

        StreamReceiver streamReceiver = session.getAggregator(tableId);
        assert streamReceiver instanceof CassandraStreamReceiver;

        LifecycleNewTracker lifecycleNewTracker = CassandraStreamReceiver.fromReceiver(session.getAggregator(tableId)).createLifecycleNewTracker();

        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version, header.format);

        logger.debug("[Table #{}] {} Components to write: {}", cfs.metadata(), desc.filenameFor(Component.DATA), components);

        return new SSTableZeroCopyWriter(desc, cfs.metadata, lifecycleNewTracker, components);
    }
}
```


Overlapping Code:
```
eSSTableStreamReader implements IStreamReader
{
private static final Logger logger = LoggerFactory.getLogger(CassandraEntireSSTableStreamReader.class);
private final TableId tableId;
private final StreamSession session;
private final StreamMessageHeader messageHeader;
private final CassandraStreamHeader header;
private final int fileSequenceNumber;
public CassandraEntireSSTableStreamReader(StreamMessageHeader messageHeader, CassandraStreamHeader streamHeader, StreamSession session)
{
if (streamHeader.format != SSTableFormat.Type.BIG && streamHeader.format != SSTableFormat.Type.BTI)
throw new AssertionError("Unsupported SSTable format " + streamHeader.format);
if (session.getPendingRepair() != null)
{
// we should only ever be streaming pending repair sstables if the session has a pending repair id
if (!session.getPendingRepair().equals(messageHeader.pendingRepair))
throw new IllegalStateException(format("Stream Session & SSTable (%s) pendingRepair UUID mismatch.", messageHeader.tableId));
}
this.header = streamHeader;
this.session = session;
this.messageHeader = messageHeader;
this.tableId = messageHeader.tableId;
this.fileSequenceNumber = messageHeader.sequenceNumber;
}
/**
* @param in where this reads data from
* @return SSTable transferred
* @throws IOException if reading the remote sstable fails. Will throw an RTE if local write fails.
*/
@SuppressWarnings("resource") // input needs to remain open, streams on top of it can't be closed
@Override
public SSTableMultiWriter read(DataInputPlus in) throws IOException
{
ColumnFamilyStore cfs = ColumnFamilyStore.getIfExists(tableId);
if (cfs == null)
{
// schema was dropped during streaming
throw new IOException("Table " + tableId + " was dropped during streaming");
}
ComponentManifest manifest = header.componentManifest;
long totalSize = manifest.totalSize();
logger.debug("[Stream #{}] Started receiving sstable #{} from {}, size = {}, table = {}",
session.planId(),
fileSequenceNumber,
session.peer,
prettyPrintMemory(totalSize),
cfs.metadata());
SSTableZeroCopyWriter w
```
<Overlap Ratio: 0.9808612440191388>

---

--- 321 --
Question ID: df9d190287ecfb6ec430b13b7c4c37613e619845
Original Code:
```
public class OperationDispatcher implements Runnable {
    
	private static Logger logger = LoggerFactory.getLogger(OperationDispatcher.class);
	
    private static final long POLLING_DELAY = 10;
    private static final long POLLING_INTERVAL = 10;
    
    private final TrackerDeviceContextService contextService;
    private final DeviceCredentials tenantCredentials;
    private final OperationExecutor operationHelper;
    private volatile ScheduledFuture<?> future;


    public OperationDispatcher(DeviceCredentials tenantCredentials,  
    		TrackerDeviceContextService contextService, OperationExecutor operationHelper) throws SDKException {
		this.tenantCredentials = tenantCredentials;
        this.contextService = contextService;
		this.operationHelper = operationHelper;
    }
    
    public void startPolling(ScheduledExecutorService operationsExecutor) {
        future = operationsExecutor.scheduleWithFixedDelay(this, POLLING_DELAY, POLLING_INTERVAL, SECONDS);
    }

    @Override
    public void run() {
        logger.trace("Executing queued operations");
        try {
            contextService.enterContext(tenantCredentials.getTenant());
            executePendingOps();
            contextService.leaveContext();
        } catch (Exception x) {
            logger.warn("Error while executing operations", x);
        }
    }

    private void executePendingOps() throws SDKException {
        logger.debug("Querying for pending operations");
        for (OperationRepresentation operation : getOperationsByStatus(OperationStatus.PENDING)) {
        	// TODO lest enter the context here 
        	GId deviceId = operation.getDeviceId();
        	TrackerDevice device = ManagedObjectCache.instance().get(deviceId);
        	if (device == null) {
        		logger.trace("Ignore operation with ID {} -> device with id {} hasn't been identified yet", operation.getId(), deviceId);
        		continue; // Device hasn't been identified yet
        	}
        	contextService.enterContext(tenantCredentials.getTenant(), device.getImei());
        	try {
        		operationHelper.execute(operation, device);
        	} finally {
        		contextService.leaveContext();
        	}
        }
    }
    
    private Iterable<OperationRepresentation> getOperationsByStatus(OperationStatus status) throws SDKException {
        Iterable<OperationRepresentation> operationsIterable = Collections.emptyList();
        try {
            operationsIterable = operationHelper.getOperationsByStatusAndAgent(status);
//            when tenant is disabled then thrown exception is BeanInstantiationException with SDKException with 401 status as a cause
        } catch (final Exception e) {
//            404 - someone deleted device, 401 tenant is disabled
            switch (handleSDKException(e, 401, 404)) {
                case OTHER_EXCEPTION:
                    throw e;
                case STATUS_MATCHES:
                    if (future != null) {
                        future.cancel(false);
                    }
            }
        }
        return operationsIterable;
    }

}
```


Overlapping Code:
```
cher implements Runnable {

private static Logger logger = LoggerFactory.getLogger(OperationDispatcher.class);

private static final long POLLING_DELAY = 10;
private static final long POLLING_INTERVAL = 10;

private final TrackerDeviceContextService contextService;
private final DeviceCredentials tenantCredentials;
private final OperationExecutor operationHelper;
private volatile ScheduledFuture<?> future;
public OperationDispatcher(DeviceCredentials tenantCredentials, 
TrackerDeviceContextService contextService, OperationExecutor operationHelper) throws SDKException {
this.tenantCredentials = tenantCredentials;
this.contextService = contextService;
this.operationHelper = operationHelper;
}

public void startPolling(ScheduledExecutorService operationsExecutor) {
future = operationsExecutor.scheduleWithFixedDelay(this, POLLING_DELAY, POLLING_INTERVAL, SECONDS);
}
@Override
public void run() {
logger.trace("Executing queued operations");
try {
contextService.enterContext(tenantCredentials.getTenant());
executePendingOps();
contextService.leaveContext();
} catch (Exception x) {
logger.warn("Error while executing operations", x);
}
}
private void executePendingOps() throws SDKException {
logger.debug("Querying for pending operations");
for (OperationRepresentation operation : getOperationsByStatus(OperationStatus.PENDING)) {
// TODO lest enter the context here 
GId deviceId = operation.getDeviceId();
TrackerDevice device = ManagedObjectCache.instance().get(deviceId);
if (device == null) {
logger.trace("Ignore operation with ID {} -> device with id {} hasn't been identified yet", operation.getId(), deviceId);
continue; // Device hasn't been identified yet
}
contextService.enterContext(tenantCredentials.getTenant(), device.getImei());
try {
operationHelper.execute(operation, device);
} finally {
contextService.leaveContext();
}
}
}

private Iterable<OperationRepresentation> getOperationsByStatus(OperationStatus status) throws SDKException {
Iterable<OperationRepresentation> operationsIterable = Collections.emptyList();
try {
operationsIterable = operationHelper.getOpera
```
<Overlap Ratio: 0.9845288326300985>

---

--- 322 --
Question ID: b022ca7489f0b6aa70d67b873157ea8b69be9d10
Original Code:
```
public class EventStoreDao {
    private final CassandraAsyncExecutor cassandraAsyncExecutor;
    private final PreparedStatement insert;
    private final PreparedStatement select;
    private final JsonEventSerializer jsonEventSerializer;

    @Inject
    public EventStoreDao(Session session, JsonEventSerializer jsonEventSerializer) {
        this.cassandraAsyncExecutor = new CassandraAsyncExecutor(session);
        this.jsonEventSerializer = jsonEventSerializer;
        this.insert = prepareInsert(session);
        this.select = prepareSelect(session);
    }

    private PreparedStatement prepareInsert(Session session) {
        return session.prepare(insertInto(EVENTS_TABLE)
            .value(AGGREGATE_ID, bindMarker(AGGREGATE_ID))
            .value(EVENT_ID, bindMarker(EVENT_ID))
            .value(EVENT, bindMarker(EVENT))
            .ifNotExists());
    }

    private PreparedStatement prepareSelect(Session session) {
        return session.prepare(select()
            .from(EVENTS_TABLE)
            .where(eq(AGGREGATE_ID, bindMarker(AGGREGATE_ID))));
    }

    public Mono<Boolean> appendAll(List<Event> events) {
        BatchStatement batch = new BatchStatement();
        events.forEach(event -> batch.add(insertEvent(event)));
        return cassandraAsyncExecutor.executeReturnApplied(batch);
    }

    private BoundStatement insertEvent(Event event) {
        try {
            return insert
                .bind()
                .setString(AGGREGATE_ID, event.getAggregateId().asAggregateKey())
                .setInt(EVENT_ID, event.eventId().serialize())
                .setString(EVENT, jsonEventSerializer.serialize(event));
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    public History getEventsOfAggregate(AggregateId aggregateId) {
        return cassandraAsyncExecutor.executeRows(
                select.bind()
                    .setString(AGGREGATE_ID, aggregateId.asAggregateKey()))
            .map(this::toEvent)
            .collectList()
            .map(History::of)
            .block();
    }

    private Event toEvent(Row row) {
        try {
            return jsonEventSerializer.deserialize(row.getString(EVENT));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```


Overlapping Code:
```
entStoreDao {
private final CassandraAsyncExecutor cassandraAsyncExecutor;
private final PreparedStatement insert;
private final PreparedStatement select;
private final JsonEventSerializer jsonEventSerializer;
@Inject
public EventStoreDao(Session session, JsonEventSerializer jsonEventSerializer) {
this.cassandraAsyncExecutor = new CassandraAsyncExecutor(session);
this.jsonEventSerializer = jsonEventSerializer;
this.insert = prepareInsert(session);
this.select = prepareSelect(session);
}
private PreparedStatement prepareInsert(Session session) {
return session.prepare(insertInto(EVENTS_TABLE)
.value(AGGREGATE_ID, bindMarker(AGGREGATE_ID))
.value(EVENT_ID, bindMarker(EVENT_ID))
.value(EVENT, bindMarker(EVENT))
.ifNotExists());
}
private PreparedStatement prepareSelect(Session session) {
return session.prepare(select()
.from(EVENTS_TABLE)
.where(eq(AGGREGATE_ID, bindMarker(AGGREGATE_ID))));
}
public Mono<Boolean> appendAll(List<Event> events) {
BatchStatement batch = new BatchStatement();
events.forEach(event -> batch.add(insertEvent(event)));
return cassandraAsyncExecutor.executeReturnApplied(batch);
}
private BoundStatement insertEvent(Event event) {
try {
return insert
.bind()
.setString(AGGREGATE_ID, event.getAggregateId().asAggregateKey())
.setInt(EVENT_ID, event.eventId().serialize())
.setString(EVENT, jsonEventSerializer.serialize(event));
} catch (JsonProcessingException e) {
throw new RuntimeException(e);
}
}
public History getEventsOfAggregate(AggregateId aggregateId) {
return cassandraAsyncExecutor.executeRows(
select.bind()
.setString(AGGREGATE_ID, aggregateId.asAggregateKey()))
.map(this::toEvent)
.collectList()
.map(History::of)
.block();
}
private Event toEvent(Row row) {
try {
return jsonEventSerializer.deserialize(row.getString(EVENT));
} catch (IOException e) {
throw new RuntimeException(e);
}
}
}
```
<Overlap Ratio: 0.9919268030139935>

---

--- 323 --
Question ID: 7513219d7c6dde893ed257c76940124088489ab7
Original Code:
```
public class LineEventDisruptor {

    public Disruptor<LineEvent> create(ThreadFactory threadFactory,
                                       ColumnType[] types,
                                       ChLineEventHandler clickhouseHandler) {
        final int threads = typesCount(types);

        EventFactory<LineEvent> factory = () -> new LineEvent(threads);

        // Specify the size of the ring buffer, must be power of 2.
        int bufferSize = getRingBufferSize();

        // Construct the Disruptor
        Disruptor<LineEvent> disruptor =
                new Disruptor<>(factory, bufferSize, threadFactory,
                        getProducerType(), getWaitStrategy());

        // Connect the handler
        final EventHandler<LineEvent>[] parseHandlers = getParseHandlers(types);
        if (parseHandlers.length > 0) {
            disruptor
                    .handleEventsWith(parseHandlers)
                    .then(clickhouseHandler);
        } else {
            throw new IllegalArgumentException("Nothing to parse");
        }

        disruptor.start();

        return disruptor;
    }

    protected int getRingBufferSize() {
        return 1024 * 32;
    }

    protected WaitStrategy getWaitStrategy() {
        return new SleepingWaitStrategy();
    }

    protected ProducerType getProducerType() {
        return ProducerType.SINGLE;
    }

    public static int typesCount(ColumnType[] types) {
        return Arrays.stream(types).collect(Collectors.toSet()).size();
    }

    public static EventHandler<LineEvent>[] getParseHandlers(ColumnType[] types) {
        Set<ColumnType> typeSet = Arrays.stream(types).collect(Collectors.toSet());
        List<EventHandler<LineEvent>> handlers = new ArrayList<>();
        int id = 0;
        for (ColumnType type : typeSet) {
            switch (type) {
                case INT_32:
                    handlers.add(new IntegerValidation(id++,
                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.INT_32)));
                    break;
                case DOUBLE:
                    handlers.add(new DoubleValidation(id++,
                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.DOUBLE)));
                    break;
                case LOCAL_DATE:
                    throw new NotImplementedException("LOCAL_DATE");
                case SQL_DATE:
                    handlers.add(new SqlDateValidation(id++,
                            ParsePacketCsvDisruptor.typeColumns(types, ColumnType.SQL_DATE)));
                    break;
            }
        }
        EventHandler<LineEvent>[] result = new EventHandler[handlers.size()];
        for (int i = 0; i < handlers.size(); ++i) result[i] = handlers.get(i);
        return result;
    }


}
```


Overlapping Code:
```
isruptor<LineEvent> create(ThreadFactory threadFactory,
ColumnType[] types,
ChLineEventHandler clickhouseHandler) {
final int threads = typesCount(types);
EventFactory<LineEvent> factory = () -> new LineEvent(threads);
// Specify the size of the ring buffer, must be power of 2.
int bufferSize = getRingBufferSize();
// Construct the Disruptor
Disruptor<LineEvent> disruptor =
new Disruptor<>(factory, bufferSize, threadFactory,
getProducerType(), getWaitStrategy());
// Connect the handler
final EventHandler<LineEvent>[] parseHandlers = getParseHandlers(types);
if (parseHandlers.length > 0) {
disruptor
.handleEventsWith(parseHandlers)
.then(clickhouseHandler);
} else {
throw new IllegalArgumentException("Nothing to parse");
}
disruptor.start();
return disruptor;
}
protected int getRingBufferSize() {
return 1024 * 32;
}
protected WaitStrategy getWaitStrategy() {
return new SleepingWaitStrategy();
}
protected ProducerType getProducerType() {
return ProducerType.SINGLE;
}
public static int typesCount(ColumnType[] types) {
return Arrays.stream(types).collect(Collectors.toSet()).size();
}
public static EventHandler<LineEvent>[] getParseHandlers(ColumnType[] types) {
Set<ColumnType> typeSet = Arrays.stream(types).collect(Collectors.toSet());
List<EventHandler<LineEvent>> handlers = new ArrayList<>();
int id = 0;
for (ColumnType type : typeSet) {
switch (type) {
case INT_32:
handlers.add(new IntegerValidation(id++,
ParsePacketCsvDisruptor.typeColumns(types, ColumnType.INT_32)));
break;
case DOUBLE:
handlers.add(new DoubleValidation(id++,
ParsePacketCsvDisruptor.typeColumns(types, ColumnType.DOUBLE)));
break;
case LOCAL_DATE:
throw new NotImplementedException("LOCAL_DATE");
case SQL_DATE:
handlers.add(new SqlDateValidation(id++,
ParseP
```
<Overlap Ratio: 0.9669056811913955>

---

--- 324 --
Question ID: d9fc71398869941f6126733480bc012d12e97ca3
Original Code:
```
public class Productos implements Parcelable {
    private int codigoProducto;
    private String descripcion, urlFoto, tipo;
    private float stock, precio;

    public Productos(int codigoProducto, String descripcion,String urlFoto,String tipo, float stock, float precio) {
        this.codigoProducto = codigoProducto;
        this.descripcion = descripcion;
        this.stock = stock;
        this.urlFoto=urlFoto;
        this.precio = precio;
        this.tipo=tipo;
    }
    public Productos(String descripcion, float precio, String urlFoto){
        this.descripcion=descripcion;
        this.precio=precio;
        this.urlFoto=urlFoto;
    }
    public Productos(){}

    protected Productos(Parcel in) {
        codigoProducto = in.readInt();
        descripcion = in.readString();
        urlFoto = in.readString();
        tipo = in.readString();
        stock = in.readFloat();
        precio = in.readFloat();
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(codigoProducto);
        dest.writeString(descripcion);
        dest.writeString(urlFoto);
        dest.writeString(tipo);
        dest.writeFloat(stock);
        dest.writeFloat(precio);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public static final Creator<Productos> CREATOR = new Creator<Productos>() {
        @Override
        public Productos createFromParcel(Parcel in) {
            return new Productos(in);
        }

        @Override
        public Productos[] newArray(int size) {
            return new Productos[size];
        }
    };

    public String getUrlFoto() {
        return urlFoto;
    }

    public void setUrlFoto(String urlFoto) {
        this.urlFoto = urlFoto;
    }

    public String getTipo() {
        return tipo;
    }

    public void setTipo(String tipo) {
        this.tipo = tipo;
    }

    public int getCodigoProducto() {
        return codigoProducto;
    }

    public void setCodigoProducto(int codigoProducto) {
        this.codigoProducto = codigoProducto;
    }

    public String getDescripcion() {
        return descripcion;
    }

    public void setDescripcion(String descripcion) {
        this.descripcion = descripcion;
    }

    public float getStock() {
        return stock;
    }

    public void setStock(float stock) {
        this.stock = stock;
    }

    public float getPrecio() {
        return precio;
    }

    public void setPrecio(float precio) {
        this.precio = precio;
    }
}
```


Overlapping Code:
```
lass Productos implements Parcelable {
private int codigoProducto;
private String descripcion, urlFoto, tipo;
private float stock, precio;
public Productos(int codigoProducto, String descripcion,String urlFoto,String tipo, float stock, float precio) {
this.codigoProducto = codigoProducto;
this.descripcion = descripcion;
this.stock = stock;
this.urlFoto=urlFoto;
this.precio = precio;
this.tipo=tipo;
}
public Productos(String descripcion, float precio, String urlFoto){
this.descripcion=descripcion;
this.precio=precio;
this.urlFoto=urlFoto;
}
public Productos(){}
protected Productos(Parcel in) {
codigoProducto = in.readInt();
descripcion = in.readString();
urlFoto = in.readString();
tipo = in.readString();
stock = in.readFloat();
precio = in.readFloat();
}
@Override
public void writeToParcel(Parcel dest, int flags) {
dest.writeInt(codigoProducto);
dest.writeString(descripcion);
dest.writeString(urlFoto);
dest.writeString(tipo);
dest.writeFloat(stock);
dest.writeFloat(precio);
}
@Override
public int describeContents() {
return 0;
}
public static final Creator<Productos> CREATOR = new Creator<Productos>() {
@Override
public Productos createFromParcel(Parcel in) {
return new Productos(in);
}
@Override
public Productos[] newArray(int size) {
return new Productos[size];
}
};
public String getUrlFoto() {
return urlFoto;
}
public void setUrlFoto(String urlFoto) {
this.urlFoto = urlFoto;
}
public String getTipo() {
return tipo;
}
public void setTipo(String tipo) {
this.tipo = tipo;
}
public int getCodigoProducto() {
return codigoProducto;
}
public void setCodigoProducto(int codigoProducto) {
this.codigoProducto = codigoProducto;
}
public String getDescripcion() {
return descripcion;
}
public void setDescripcion(String descripcion) {
this.descripcion = descripcion;
}
public float getStock() {
return stock;
}
public void setStock(float stock) {
this.stock = stock;
}
publi
```
<Overlap Ratio: 0.9942166140904312>

---

--- 325 --
Question ID: 22c8987d39433b3ad7ee7226f44cc795e6c54e7b
Original Code:
```
public class ParseComponentTest extends ICalendarTestAbstract
{           
    /** Tests FREQ=YEARLY */
    @Test
    public void canParseYearly1()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "CATEGORIES:group13" + System.lineSeparator()
                              + "CREATED:20151109T082900Z" + System.lineSeparator()
                              + "DESCRIPTION:Yearly1 Description" + System.lineSeparator()
                              + "DTSTAMP:20151109T083000Z" + System.lineSeparator()
                              + "DTSTART:20151109T100000" + System.lineSeparator()
                              + "DURATION:PT1H" + System.lineSeparator()
                              + "LAST-MODIFIED:20151110T183000Z" + System.lineSeparator()
                              + "RRULE:FREQ=YEARLY" + System.lineSeparator()
                              + "SUMMARY:Yearly1 Summary" + System.lineSeparator()
                              + "UID:20151109T082900-0@jfxtras.org" + System.lineSeparator()
                              + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getYearly1();
        assertEquals(expectedVEvent, vEvent);
        assertEquals(vEventString, expectedVEvent.toString());
    }

    @Test
    public void canParseDaily3()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTEND:20151109T110000" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + "DTSTART:20151109T100000" + System.lineSeparator()
                              + "RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14" + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getDaily3();
        assertEquals(expectedVEvent, vEvent);
        assertEquals(vEventString, expectedVEvent.toString());
    }
    
    @Test
    public void canIgnoreBlankLines()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTEND:20151109T110000" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + System.lineSeparator()
                              + "DTSTART:20151109T100000" + System.lineSeparator()
                              + "RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14" + System.lineSeparator()
                              + System.lineSeparator()
                              + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getDaily3();
        assertEquals(expectedVEvent, vEvent);
        String vEventString2 = "BEGIN:VEVENT" + System.lineSeparator()
                + "DTEND:20151109T110000" + System.lineSeparator()
                + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                + "DTSTART:20151109T100000" + System.lineSeparator()
                + "RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14" + System.lineSeparator()
                + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                + "END:VEVENT";
        assertEquals(vEventString2, expectedVEvent.toString());
    }
        
    @Test
    public void canParseDailyUTC()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTSTART:20151109T100000Z" + System.lineSeparator()
                              + "DTEND:20151109T110000Z" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + "CATEGORIES:group03" + System.lineSeparator()
                              + "DESCRIPTION:DailyUTC Description" + System.lineSeparator()
                              + "SUMMARY:DailyUTC Summary" + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "RRULE:FREQ=DAILY;INTERVAL=2;UNTIL=20151201T100000Z" + System.lineSeparator()
                              + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getDailyUTC();
        assertEquals(expectedVEvent, vEvent);
        assertEquals(vEventString, expectedVEvent.toString());
    }
    
    /** Tests FREQ=YEARLY */
    @Test
    public void canParseDailyWithException1()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                + "DTSTART:20151109T100000" + System.lineSeparator()
                + "DURATION:PT1H30M" + System.lineSeparator()
                + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                + "CATEGORIES:group03" + System.lineSeparator()
                + "DESCRIPTION:Daily2 Description" + System.lineSeparator()
                + "SUMMARY:Daily2 Summary" + System.lineSeparator()
                + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                + "RRULE:FREQ=DAILY;INTERVAL=3;COUNT=6" + System.lineSeparator()
                + "EXDATE:20151112T100000,20151115T100000" + System.lineSeparator()
                + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getDailyWithException1();
        assertEquals(expectedVEvent, vEvent);
        assertEquals(vEventString, expectedVEvent.toString());
    }
    
    @Test
    public void canParseWholeDay1()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTSTART;VALUE=DATE:20151109" + System.lineSeparator()
                              + "DTEND;VALUE=DATE:20151112" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getWholeDayDaily1();
        assertEquals(expectedVEvent, vEvent);
    }
    
    @Test
    public void canParseGoogleIndividual()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                + "DTSTART:20160214T123000Z" + System.lineSeparator()
                + "DTEND:20160214T150000Z" + System.lineSeparator()
                + "DTSTAMP:20160214T022532Z" + System.lineSeparator()
                + "UID:vpqej26mlpg3adcncqqs7t7a34@google.com" + System.lineSeparator()
                + "CREATED:20160214T022513Z" + System.lineSeparator()
                + "DESCRIPTION:" + System.lineSeparator()
                + "LAST-MODIFIED:20160214T022513Z" + System.lineSeparator()
                + "LOCATION:" + System.lineSeparator()
                + "SEQUENCE:0" + System.lineSeparator()
                + "STATUS:CONFIRMED" + System.lineSeparator() // currently not supported
                + "SUMMARY:test1" + System.lineSeparator()
                + "TRANSP:OPAQUE" + System.lineSeparator() // currently not supported
                + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getGoogleIndividual();
        vEvent.equals(expectedVEvent);
        assertEquals(expectedVEvent, vEvent);
        assertEquals(vEventString, vEvent.toString());
    }
    
    @Test
    public void canParseGoogleRepeat()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                + "DTSTART;TZID=America/Los_Angeles:20160214T080000" + System.lineSeparator()
                + "DTEND;TZID=America/Los_Angeles:20160214T110000" + System.lineSeparator()
                + "RRULE:FREQ=WEEKLY;BYDAY=SU,TU,FR" + System.lineSeparator()
                + "DTSTAMP:20160214T022532Z" + System.lineSeparator()
                + "UID:im8hmpakeigu3d85j3vq9q8bcc@google.com" + System.lineSeparator()
                + "CREATED:20160214T022525Z" + System.lineSeparator()
                + "DESCRIPTION:" + System.lineSeparator()
                + "LAST-MODIFIED:20160214T022525Z" + System.lineSeparator()
                + "LOCATION:" + System.lineSeparator()
                + "SEQUENCE:0" + System.lineSeparator()
                + "STATUS:CONFIRMED" + System.lineSeparator() // currently not supported
                + "SUMMARY:test2" + System.lineSeparator()
                + "TRANSP:OPAQUE" + System.lineSeparator() // currently not supported
                + "END:VEVENT";
        VEvent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getGoogleRepeatable();
        assertEquals(expectedVEvent, vEvent);
    }
    
    @Test
    public void canParseGoogleRepeatWithExDates()
    {
        String content = "BEGIN:VEVENT" + System.lineSeparator()
                + "DTSTART;TZID=America/Los_Angeles:20160207T123000" + System.lineSeparator()
                + "DTEND;TZID=America/Los_Angeles:20160207T153000" + System.lineSeparator()
                + "RRULE:FREQ=DAILY;UNTIL=20160512T193000Z" + System.lineSeparator()
                + "EXDATE;TZID=America/Los_Angeles:20160210T123000" + System.lineSeparator()
                + "EXDATE;TZID=America/Los_Angeles:20160212T123000" + System.lineSeparator()
                + "EXDATE;TZID=America/Los_Angeles:20160209T123000" + System.lineSeparator()
                + "DTSTAMP:20160214T072231Z" + System.lineSeparator()
                + "UID:86801l7316n97h75cefk1ruc00@google.com" + System.lineSeparator()
                + "CREATED:20160214T022525Z" + System.lineSeparator()
                + "DESCRIPTION:" + System.lineSeparator()
                + "LAST-MODIFIED:20160214T022525Z" + System.lineSeparator()
                + "LOCATION:" + System.lineSeparator()
                + "SEQUENCE:0" + System.lineSeparator()
                + "STATUS:CONFIRMED" + System.lineSeparator() // currently not supported
                + "SUMMARY:test3" + System.lineSeparator()
                + "TRANSP:OPAQUE" + System.lineSeparator() // currently not supported
                + "END:VEVENT";
        VEvent vEvent = VEvent.parse(content);
        VEvent expectedVEvent = getGoogleWithExceptions();
        assertEquals(expectedVEvent, vEvent);
    }    

    @Test
    public void canParseEmptyVevent()
    {
    	String expectedContent = "BEGIN:VEVENT" + System.lineSeparator() +
    			"END:VEVENT";
        VComponent vEvent = VEvent.parse(expectedContent);
        VComponent vExpected = new VEvent();
        assertEquals(vExpected, vEvent);
        assertEquals(expectedContent, vEvent.toString());
    }

    @Test
    public void canParseWithFoldedLines()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTSTART;VALUE=DATE:20151109" + System.lineSeparator()
                              + "DTEND;VALUE=DATE:20151112" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "COMMENT:This is a multiline " + System.lineSeparator()
                              + " comment." + System.lineSeparator()
                              + "DESCRIPTION:A dog ran " + System.lineSeparator()
                              + "" + System.lineSeparator() // ignore blank line
                              + " far away." + System.lineSeparator()
                              + "END:VEVENT";
        VComponent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getWholeDayDaily1()
                .withComments("This is a multiline comment.")
                .withDescription("A dog ran far away.");
        assertEquals(expectedVEvent, vEvent);
    }
    
    @Test
    public void canParseWithSubComponent()
    {
        String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
                              + "DTSTART;VALUE=DATE:20151109" + System.lineSeparator()
                              + "DTEND;VALUE=DATE:20151112" + System.lineSeparator()
                              + "DTSTAMP:20150110T080000Z" + System.lineSeparator()
                              + "UID:20150110T080000-0@jfxtras.org" + System.lineSeparator()
                              + "COMMENT:This is a multiline " + System.lineSeparator()
                              + " comment." + System.lineSeparator()
                              + "BEGIN:VALARM" + System.lineSeparator()
                              + "ACTION:DISPLAY" + System.lineSeparator()
                              + "DESCRIPTION:This is a multiline " + System.lineSeparator()
                              + " description." + System.lineSeparator()
                              + "TRIGGER;RELATED=START:-PT30M" + System.lineSeparator()
                              + "END:VALARM" + System.lineSeparator()
                              + "END:VEVENT";
        VComponent vEvent = VEvent.parse(vEventString);
        VEvent expectedVEvent = getWholeDayDaily1()
                .withComments("This is a multiline comment.")
                .withVAlarms(new VAlarm()
                        .withAction(ActionType.DISPLAY)
                        .withDescription("This is a multiline description.")
                        .withTrigger(new Trigger<Duration>(Duration.ofMinutes(-30))
                                .withAlarmTrigger(new AlarmTriggerRelationship(AlarmTriggerRelationshipType.START))));
    
        assertEquals(expectedVEvent, vEvent);
    }
}
```


Overlapping Code:
```
blic class ParseComponentTest extends ICalendarTestAbstract
{ 
/** Tests FREQ=YEARLY */
@Test
public void canParseYearly1()
{
String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
+ "CATEGORIES:group13" + System.lineSeparator()
+ "CREATED:20151109T082900Z" + System.lineSeparator()
+ "DESCRIPTION:Yearly1 Description" + System.lineSeparator()
+ "DTSTAMP:20151109T083000Z" + System.lineSeparator()
+ "DTSTART:20151109T100000" + System.lineSeparator()
+ "DURATION:PT1H" + System.lineSeparator()
+ "LAST-MODIFIED:20151110T183000Z" + System.lineSeparator()
+ "RRULE:FREQ=YEARLY" + System.lineSeparator()
+ "SUMMARY:Yearly1 Summary" + System.lineSeparator()
m.lineSeparator()
+ "END:VEVENT";
VEvent vEvent = VEvent.parse(vEventString);
VEvent expectedVEvent = getYearly1();
assertEquals(expectedVEvent, vEvent);
assertEquals(vEventString, expectedVEvent.toString());
}
@Test
public void canParseDaily3()
{
String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
+ "DTEND:20151109T110000" + System.lineSeparator()
+ "DTSTAMP:20150110T080000Z" + System.lineSeparator()
+ "DTSTART:20151109T100000" + System.lineSeparator()
+ "RRULE:FREQ=DAILY;INTERVAL=3;COUNT=10;BYMONTHDAY=9,10,11,12,13,14" + System.lineSeparator()
+ "UID:20150110T080000-m.lineSeparator()
+ "END:VEVENT";
VEvent vEvent = VEvent.parse(vEventString);
VEvent expectedVEvent = getDaily3();
assertEquals(expectedVEvent, vEvent);
assertEquals(vEventString, expectedVEvent.toString());
}

@Test
public void canIgnoreBlankLines()
{
String vEventString = "BEGIN:VEVENT" + System.lineSeparator()
+ "DTEND:20151109T110000" + System.lineSeparator()
+ "DTSTAMP:20150110T080000Z" + System.lineSeparator()
```
<Overlap Ratio: 0.9525171624713958>

---

--- 326 --
Question ID: be0261294ea05f813512d543683ec02bd0b0c489
Original Code:
```
public abstract class AbstractScriptCache<K, V> implements ScriptCache<K, V> {

    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    protected Map<K, V> cacheMap;
    protected int cacheSize;

    public AbstractScriptCache(int cacheSize) {
        this.cacheSize = cacheSize;
    }

    @Override
    public void put(K k, V v) {
        ObjectsUtil.requireNonNull(v);
        Lock lock = readWriteLock.writeLock();
        try {
            lock.lock();
            cacheMap.put(k, v);
        } finally {
            lock.unlock();
        }
    }

    @Override
    public V get(K k) {
        Lock lock = readWriteLock.readLock();
        try {
            lock.lock();
            return cacheMap.get(k);
        } finally {
            lock.unlock();
        }
    }

    @Override
    public boolean evict(K k) {
        if (cacheMap.containsKey(k)) {
            Lock lock = readWriteLock.writeLock();
            try {
                lock.lock();
                cacheMap.remove(k);
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;
    }

    @Override
    public void clean() {
        Lock lock = readWriteLock.writeLock();
        try {
            lock.lock();
            cacheMap.clear();
        } finally {
            lock.unlock();
        }
    }
}
```


Overlapping Code:
```
tScriptCache<K, V> implements ScriptCache<K, V> {
private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
protected Map<K, V> cacheMap;
protected int cacheSize;
public AbstractScriptCache(int cacheSize) {
this.cacheSize = cacheSize;
}
@Override
public void put(K k, V v) {
ObjectsUtil.requireNonNull(v);
Lock lock = readWriteLock.writeLock();
try {
lock.lock();
cacheMap.put(k, v);
} finally {
lock.unlock();
}
}
@Override
public V get(K k) {
Lock lock = readWriteLock.readLock();
try {
lock.lock();
return cacheMap.get(k);
} finally {
lock.unlock();
}
}
@Override
public boolean evict(K k) {
if (cacheMap.containsKey(k)) {
Lock lock = readWriteLock.writeLock();
try {
lock.lock();
cacheMap.remove(k);
return true;
} finally {
lock.unlock();
}
}
return false;
}
@Override
public void clean() {
Lock lock = readWriteLock.writeLock();
try {
lock.lock();
cacheMap.clear();
} finally {

```
<Overlap Ratio: 0.9483667017913593>

---

--- 327 --
Question ID: 8afc2656232abb298c3d281da7d640e37fc58954
Original Code:
```
class UnaryTable {
  public static class Iter {
    int index;
    UnaryTable table;

    public Iter(int index, UnaryTable table) {
      this.table = table;
      if (table.count == 0)
        this.index = 64 * table.bitmap.length;
      else {
        this.index = index;
        if (!table.contains(0))
          next();
      }
    }

    public int get() {
      return index;
    }

    public boolean done() {
      return index >= 64 * table.bitmap.length;
    }

    public void next() {
      int size = 64 * table.bitmap.length;
      do {
        index++;
      } while (index < size && !table.contains(index));
    }
  }


  final int InitSize = 4;

  long[] bitmap = new long[InitSize];
  int count = 0;

  public SurrObjMapper mapper;

  public UnaryTable(SurrObjMapper mapper) {
    this.mapper = mapper;
  }

  public int size() {
    return count;
  }

  public boolean contains(int surr) {
    int widx = surr / 64;
    return widx < bitmap.length && ((bitmap[widx] >>> (int) (surr % 64) & 1) != 0);
  }

  public Iter getIter() {
    return new Iter(0, this);
  }

  int liveCount() {
    int liveCount = 0;
    for (int i=0 ; i < bitmap.length ; i++) {
      long mask = bitmap[i];
      for (int j=0 ; j < 64 ; j++)
        if (((mask >>> j) & 1) != 0)
          liveCount++;
    }
    return liveCount;
  }

  public void insert(int surr) {
    int widx = surr / 64;
    int bidx = (int) (surr % 64);

    int len = bitmap.length;
    if (widx >= len) {
      int newLen = 2 * len;
      while (widx >= newLen)
        newLen *= 2;
      long[] newBitmap = new long[newLen];
      Array.copy(bitmap, newBitmap, len);
      bitmap = newBitmap;
    }

    long mask = bitmap[widx];
    if (((mask >>> bidx) & 1) == 0) {
      bitmap[widx] = mask | (1L << bidx);
      count++;
    }
    // Miscellanea._assert(count == LiveCount());
  }

  public void delete(int surr) {
    Miscellanea._assert(surr < 64 * bitmap.length);

    int widx = surr / 64;
    if (widx < bitmap.length) {
      long mask = bitmap[widx];
      int bidx = (int) surr % 64;
      if (((mask >>> bidx) & 1) == 1) {
        bitmap[widx] = mask & ~(1L << bidx);
        count--;
      }
    }
    // Miscellanea._assert(count == LiveCount());
  }

  public long[] clear(int minCapacity) {
    count = 0;
    int size = InitSize;
    while (64 * size < minCapacity)
      size *= 2;
    long[] bitmapCopy = bitmap;
    bitmap = new long[size];
    return bitmapCopy;
  }

  public Obj copy() {
    return copy(new UnaryTable[] {this});
  }

//    public static String IntToBinaryString(int number) {
//      String binStr = "";
//      while (number != 0) {
//        binStr = (number & 1) + binStr;
//        number = number >>> 1;
//      }
//      if (binStr == "")
//        binStr = "0";
//      return binStr;
//    }
//
//    public static String IntToBinaryString(long number) {
//      String binStr = "";
//      while (number > 0) {
//        binStr = (number & 1) + binStr;
//        number = number >>> 1;
//      }
//      if (binStr == "")
//        binStr = "0";
//      return binStr;
//    }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////

  public static Obj copy(UnaryTable[] tables) {
    int count = 0;
    for (int i=0 ; i < tables.length ; i++)
      count += tables[i].count;
    if (count == 0)
      return EmptyRelObj.singleton;
    Obj[] objs = new Obj[count];
    int next = 0;
    for (int i=0 ; i < tables.length ; i++) {
      UnaryTable table = tables[i];
      SurrObjMapper mapper = table.mapper;
      long[] bitmap = table.bitmap;
      for (int j=0 ; j < bitmap.length ; j++) {
        long mask = bitmap[j];
        for (int k=0 ; k < 64 ; k++)
          if (((mask >>> k) & 1) != 0)
            objs[next++] = mapper.surrToObj(k + 64 * j);
      }
    }
    Miscellanea._assert(next == count);
    return Builder.createSet(objs, objs.length);
  }
}
```


Overlapping Code:
```
tatic class Iter {
int index;
UnaryTable table;
public Iter(int index, UnaryTable table) {
this.table = table;
if (table.count == 0)
this.index = 64 * table.bitmap.length;
else {
this.index = index;
if (!table.contains(0))
next();
}
}
public int get() {
return index;
}
public boolean done() {
return index >= 64 * table.bitmap.length;
}
public void next() {
int size = 64 * table.bitmap.length;
do {
index++;
} while (index < size && !table.contains(index));
}
}
final int InitSize = 4;
long[] bitmap = new long[InitSize];
int count = 0;
public SurrObjMapper mapper;
public UnaryTable(SurrObjMapper mapper) {
this.mapper = mapper;
}
public int size() {
return count;
}
public boolean contains(int surr) {
int widx = surr / 64;
return widx < bitmap.length && ((bitmap[widx] >>> (int) (surr % 64) & 1) != 0);
}
public Iter getIter() {
return new Iter(0, this);
}
int liveCount() {
int liveCount = 0;
for (int i=0 ; i < bitmap.length ; i++) {
long mask = bitmap[i];
for (int j=0 ; j < 64 ; j++)
if (((mask >>> j) & 1) != 0)
liveCount++;
}
return liveCount;
}
public void insert(int surr) {
int widx = surr / 64;
int bidx = (int) (surr % 64);
int len = bitmap.length;
if (widx >= len) {
int newLen = 2 * len;
while (widx >= newLen)
newLen *= 2;
long[] newBitmap = new long[newLen];
Array.copy(bitmap, newBitmap, len);
bitmap = newBitmap;
}
long mask = bitmap[widx];
if (((mask >>> bidx) & 1) == 0) {
bitmap[widx] = mask | (1L << bidx);
count++;
}
// Miscellanea._assert(count == LiveCount());
}
public void delete(int surr) {
Miscellanea._assert(surr < 64 * bitmap.length);
int widx = surr / 64;
if (widx < bitmap.length) {
long mask = bitmap[widx];
int bidx = (int) surr % 64;
if (((mask >>> bidx) & 1) == 1) {
bitmap[widx] = mask & ~(1L << bidx);
count--;
}
}
// Miscellanea._assert(count == LiveCount());
}
public long[] clear(int minCapacity) {
count = 0;
int size = InitSize;
while (64 * size < minCapacity)
size *= 2;
long[] bitmapCopy = bitmap;
bitmap = new long[size];
return bitmapCopy;
}
publi
```
<Overlap Ratio: 0.9751340809361287>

---

--- 328 --
Question ID: ed9e41080fdd18224044973968d161aa0d22b443
Original Code:
```
public class TimesToJavaSerializer implements ToJavaSerializer<Times> {

    @Override
    public String serialize(int numberOfSpacesToIndent, Times times) {
        StringBuffer output = new StringBuffer();
        if (times != null) {
            appendNewLineAndIndent(numberOfSpacesToIndent * INDENT_SIZE, output);
            if (times.isUnlimited()) {
                output.append("Times.unlimited()");
            } else if (times.getRemainingTimes() == 1) {
                output.append("Times.once()");
            } else {
                output.append("Times.exactly(").append(times.getRemainingTimes()).append(")");
            }
        }

        return output.toString();
    }

    private StringBuffer appendNewLineAndIndent(int numberOfSpacesToIndent, StringBuffer output) {
        return output.append(NEW_LINE).append(Strings.padStart("", numberOfSpacesToIndent, ' '));
    }
}
```


Overlapping Code:
```
ements ToJavaSerializer<Times> {
@Override
public String serialize(int numberOfSpacesToIndent, Times times) {
StringBuffer output = new StringBuffer();
if (times != null) {
appendNewLineAndIndent(numberOfSpacesToIndent * INDENT_SIZE, output);
if (times.isUnlimited()) {
output.append("Times.unlimited()");
} else if (times.getRemainingTimes() == 1) {
output.append("Times.once()");
} else {
output.append("Times.exactly(").append(times.getRemainingTimes()).append(")");
}
}
return output.toString();
}
private StringBuffer appendNewLineAndIndent(int numberOfSpacesToIndent, StringBuffer output) {
return output.append(NEW_LINE).append(Strings.padStart("", numberOfSpacesToIndent, ' '));

```
<Overlap Ratio: 0.9423868312757202>

---

--- 329 --
Question ID: d77bea1350674b6acd4fb00409b918543b03efe7
Original Code:
```
public class SameTree {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) { val = x; }
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } else if (p == null) {
            return false;
        } else if (q == null) {
            return false;
        }
        return  (p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
    }

    public void demo() {
        TreeNode root1 = new TreeNode(1);
        root1.left = new TreeNode(2);
        root1.right = new TreeNode(3);
        TreeNode root2 = new TreeNode(1);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(3);
        System.out.println(isSameTree(root1, root2));
    }

    public static void main(String[] args) {
        new SameTree().demo();
    }
}
```


Overlapping Code:
```
lic class SameTree {
public class TreeNode {
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) { val = x; }
}
public boolean isSameTree(TreeNode p, TreeNode q) {
if (p == null && q == null) {
return true;
} else if (p == null) {
return false;
} else if (q == null) {
return false;
}
return (p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
}
public void demo() {
TreeNode root1 = new TreeNode(1);
root1.left = new TreeNode(2);
root1.right = new TreeNode(3);
TreeNode root2 = new TreeNode(1);
root2.left = new TreeNode(2);
root2.right = new TreeNode(3);
System.out.println(isSameTree(root1, root2));
}
public static void main(String[] args) {
new S
```
<Overlap Ratio: 0.9660537482319661>

---

--- 330 --
Question ID: 54e4b1574e367e57e131ee34fb2e7d6039bd4430
Original Code:
```
public class NonEmptyStringUdf implements UserDefinedFunction {
  public Object execute(Evaluator evaluator, Argument[] arguments) {
    Object arg = arguments[0].evaluateScalar(evaluator);
    if (arg instanceof String) {
      String s = (String) arg;
      if (s.length() > 0) {
        return s;
      }
    }
    return null;
  }

  public String getDescription() {
    return "Returns string value if non-empty.";
  }

  public String getName() {
    return "NonEmptyString";
  }

  public Type[] getParameterTypes() {
    return new Type[] {
      new ScalarType()
    };
  }

  public String[] getReservedWords() {
    return null;
  }

  public Type getReturnType(Type[] parameterTypes) {
    return new StringType();
  }

  public Syntax getSyntax() {
    return Syntax.Function;
  }

}
```


Overlapping Code:
```
ringUdf implements UserDefinedFunction {
public Object execute(Evaluator evaluator, Argument[] arguments) {
Object arg = arguments[0].evaluateScalar(evaluator);
if (arg instanceof String) {
String s = (String) arg;
if (s.length() > 0) {
return s;
}
}
return null;
}
public String getDescription() {
return "Returns string value if non-empty.";
}
public String getName() {
return "NonEmptyString";
}
public Type[] getParameterTypes() {
return new Type[] {
new ScalarType()
};
}
public String[] getReservedWords() {
return null;
}
public Type getReturnType(Type[] parameterTypes) {
return new StringType();
}
public Syntax getSyntax() {
return Syntax.Function;
}

```
<Overlap Ratio: 0.964963503649635>

---

--- 331 --
Question ID: 2a73ddc1c5aa403106ef2a42483e3664a26f5754
Original Code:
```
@ParentPackage("default")
@Namespace("/collection/request")
@Component
@Scope("prototype")
public class CollectionRequestAccessAction extends AbstractRequestAccessController<ResourceCollection>
        implements Preparable, PersistableLoadingAction<ResourceCollection> {

    private Set<EmailType> emailTypes = new HashSet<>(EmailType.valuesWithoutConfidentialFiles());

    private static final String SUCCESS_UNAUTH = "success-unauth";
    private static final long serialVersionUID = -6110216327414755768L;
    private EmailType type = EmailType.CONTACT;

    @Override
    public void prepare() {
        getLogger().trace("id: {}, {}", getId(), getPersistableClass());
        try {
            prepareAndLoad(this, RequestType.VIEW);
        } catch (Throwable t) {
            getLogger().error("{}", t, t);
        }
        if (PersistableUtils.isNullOrTransient(getPersistable())) {
            return;
        }

    }

    @Action(value = "{id}", results = { @Result(name = SUCCESS, location = "request-access.ftl"),
            @Result(name = SUCCESS_UNAUTH, location = "request-access-unauthenticated.ftl"),
            @Result(name = ERROR, type = TdarActionSupport.FREEMARKERHTTP, location = "/WEB-INF/content/errors/error.ftl", params = {
                    "status", "500" }),
            @Result(name = INPUT, type = TdarActionSupport.FREEMARKERHTTP, location = "/WEB-INF/content/errors/error.ftl", params = {
                    "status", "500" }) })
    @HttpsOnly
    @SkipValidation
    @Override
    public String execute() throws TdarActionException {
        // if we're logged out, go to request-access-unathenticated.ftl
        if (PersistableUtils.isNullOrTransient(getAuthenticatedUser())) {
            return SUCCESS_UNAUTH;
        }

        return SUCCESS;
    }

    @Override
    public boolean authorize() throws TdarActionException {
        return true;
    }

    @Override
    public InternalTdarRights getAdminRights() {
        return InternalTdarRights.VIEW_ANYTHING;
    }

    @Override
    public String getTypeNamespace() {
        return "collection";
    }

    public Set<EmailType> getEmailTypes() {
        return emailTypes;
    }

    public void setEmailTypes(Set<EmailType> emailTypes) {
        this.emailTypes = emailTypes;
    }

    public ResourceCollection getCollection() {
        return getPersistable();
    }

    public Class<ResourceCollection> getPersistableClass() {
        return ResourceCollection.class;
    }
}
```


Overlapping Code:
```
tPackage("default")
@Namespace("/collection/request")
@Component
@Scope("prototype")
public class CollectionRequestAccessAction extends AbstractRequestAccessController<ResourceCollection>
implements Preparable, PersistableLoadingAction<ResourceCollection> {
private Set<EmailType> emailTypes = new HashSet<>(EmailType.valuesWithoutConfidentialFiles());
private static final String SUCCESS_UNAUTH = "success-unauth";
private static final long serialVersionUID = -6110216327414755768L;
private EmailType type = EmailType.CONTACT;
@Override
public void prepare() {
getLogger().trace("id: {}, {}", getId(), getPersistableClass());
try {
prepareAndLoad(this, RequestType.VIEW);
} catch (Throwable t) {
getLogger().error("{}", t, t);
}
if (PersistableUtils.isNullOrTransient(getPersistable())) {
return;
}
}
@Action(value = "{id}", results = { @Result(name = SUCCESS, location = "request-access.ftl"),
@Result(name = SUCCESS_UNAUTH, location = "request-access-unauthenticated.ftl"),
@Result(name = ERROR, type = TdarActionSupport.FREEMARKERHTTP, location = "/WEB-INF/content/errors/error.ftl", params = {
"status", "500" }),
@Result(name = INPUT, type = TdarActionSupport.FREEMARKERHTTP, location = "/WEB-INF/content/errors/error.ftl", params = {
"status", "500" }) })
@HttpsOnly
@SkipValidation
@Override
public String execute() throws TdarActionException {
// if we're logged out, go to request-access-unathenticated.ftl
if (PersistableUtils.isNullOrTransient(getAuthenticatedUser())) {
return SUCCESS_UNAUTH;
}
return SUCCESS;
}
@Override
public boolean authorize() throws TdarActionException {
return true;
}
@Override
public InternalTdarRights getAdminRights() {
return InternalTdarRights.VIEW_ANYTHING;
}
@Override
public String getTypeNamespace() {
return "collection";
}
public Set<EmailType> getEmailTypes() {
return emailTypes;
}
public void setEmailTypes(Set<EmailType> emailTypes) {
this.emailTypes = emailTypes;
}
public ResourceCollection getCollection() {
return getPersistable();
}
public Class<ResourceCollection> getPersistableClass() {
return ResourceCollection.class;
```
<Overlap Ratio: 0.9952175992348159>

---

--- 332 --
Question ID: 32f403095b03c2cf2dabff8ac2d2cec2981947fa
Original Code:
```
@SuppressWarnings("Convert2streamapi")
public class PbskyImpl extends RefreshLoader implements Pbsky {

    final static Logger log = LoggerFactory.getLogger(PbskyImpl.class);

    private List<PbsServerConfig> pbsServers;
    private PbsCache pbsCache;
    private PbsConnector pbsConnector;

    private List<PBS> pbsky;
    private Map<String, Queue> queuesMap;
    private List<Job> allJobs;
    private JobsInfo jobsInfo;

    public void setPbsServers(List<PbsServerConfig> pbsServers) {
        this.pbsServers = pbsServers;
    }

    @Override
    public List<PbsServerConfig> getPbsServerConfigs() {
        return pbsServers;
    }

    public void setPbsCache(PbsCache pbsCache) {
        this.pbsCache = pbsCache;
    }

    public void setPbsConnector(PbsConnector pbsConnector) {
        this.pbsConnector = pbsConnector;
    }

    public PbskyImpl() {
    }

    @Override
    public List<PBS> getListOfPBS() {
        //obsahuje checkLoad(), takze neni potreba tam, kde se volaji getListOfPBS()
        checkLoad();
        return pbsky;
    }

    private static PBS findPBSForServer(PbsServerConfig server, List<PBS> pbsList) {
        if(pbsList==null) return null;
        for (PBS p : pbsList) {
            if (p.getServerConfig().equals(server)) {
                return p;
            }
        }
        return null;
    }

    @Override
    protected void load() {
        try {
            List<PBS> pbskyNew = new ArrayList<>();
            Map<String, Queue> queuesMapNew = new HashMap<>();
            List<PBS> oldPbsky = new ArrayList<>();
            //nacti vsechno cerstve. pokud to jde, jinak si nech stara data
            for (PbsServerConfig server : pbsServers) {
                PBS oldData = findPBSForServer(server, pbsky);
                try {
                    long time = System.currentTimeMillis();
                    PBS pbs = pbsConnector.loadData(server);
                    time = System.currentTimeMillis()- time;
                    if(time > 20000L) {
                        log.warn("loading data from PBS {} took {} ms", server.getHost(), time);
                    }
                    pbs.uprav();
                    pbskyNew.add(pbs);
                    log.debug("got new data "+pbs);
                    if(oldData!=null) {
                        oldPbsky.add(oldData);
                        log.debug("marked old data for clearing "+oldData);
                    }
                } catch (RuntimeException ex) {
                    log.error("Cannot load PBS data from server " + server.getHost(),ex);
                    //keep old data for that server
                    if (oldData != null) {
                        log.warn("keeping old data " + pbsky.toString());
                        pbskyNew.add(oldData);
                    } else {
                        log.warn("could not find old PBS data for server " + server.getHost());
                    }
                }

            }
            //predpripravit nova data
            for (PBS pbs : pbskyNew) {
                for (Queue q : pbs.getQueues().values()) {
                    queuesMapNew.put(q.getName(), q);
                }
                for (Node node : pbs.getNodesByName()) {
                    node.setGpuJobMap(pbsCache.getGpuAlloc(node));
                }
            }
            //vsechno se povedlo, mame nova data
            //prirazeni novych dat
            Map<String, Queue> oldQueuesMap = queuesMap;
            synchronized (this) {
                pbsky = pbskyNew;
                queuesMap = queuesMapNew;
                allJobs = null;
                jobsInfo = null;
            }
            //pomoc Garbage Collectoru
            if (oldQueuesMap != null) {
                oldQueuesMap.clear();
            }
            new Uklizec(oldPbsky).start();
        } catch (RuntimeException ex) {
            log.error("Cannot load PBS", ex);
        }

    }


    @Override
    synchronized public JobsInfo getJobsInfo() {
        if (jobsInfo == null) {
            jobsInfo = new JobsInfo(getAllJobs());
        }
        return jobsInfo;
    }

    private synchronized List<Job> getAllJobs() {
        List<PBS> list = getListOfPBS();
        if (allJobs == null) {
            int jobCount = 0;
            for (PBS pbs : list) {
                jobCount += pbs.getJobsById().size();
            }
            ArrayList<Job> jobs = new ArrayList<>(jobCount);
            for (PBS pbs : list) {
                jobs.addAll(pbs.getJobsById());
            }
            allJobs = jobs;
        }
        return allJobs;
    }

    @Override
    public Queue getQueueByName(String queueName) {
        checkLoad();
        return queuesMap.get(queueName);
    }

    @Override
    public Job getJobByName(String jobName) {
        for (PBS pbs : getListOfPBS()) {
            Job job = pbs.getJobs().get(jobName);
            //ignore jobs in Moved state, they are reported by another server in another state
            if (job != null && !"M".equals(job.getState())) return job;
        }
        return null;
    }

    @Override
    public List<Job> getSortedJobs(JobsSortOrder poradi) {
        checkLoad();
        List<Job> jobs = getAllJobs();
        if(poradi==null) poradi = JobsSortOrder.Id;
        jobs = new ArrayList<>(jobs);
        switch (poradi) {
            case Id:
                jobs.sort(jobsIdComparator);
                break;
            case CPU:
                jobs.sort(jobCPUComparator);
                break;
            case CPUTime:
                jobs.sort(jobCPUTimeUsedComparator);
                break;
            case Name:
                jobs.sort(jobNameComparator);
                break;
            case Queue:
                jobs.sort(jobQueueComparator);
                break;
            case Ctime:
                jobs.sort(jobCtimeComparator);
                break;
            case ReservedMemTotal:
                jobs.sort(jobReservedMemTotalComparator);
                break;
            case UsedMem:
                jobs.sort(jobUsedMemComparator);
                break;
            case User:
                jobs.sort(jobUserComparator);
                break;
            case WallTime:
                jobs.sort(jobWallTimeUsedComparator);
                break;
            case State:
                jobs.sort(jobStateComparator);
                break;
        }
        return jobs;
    }

    @Override
    public List<Node> getAllNodes() {
        int nodeCount = 0;
        List<PBS> list = getListOfPBS();
        for (PBS pbs : list) {
            nodeCount += pbs.getNodesByName().size();
        }
        ArrayList<Node> nodes = new ArrayList<>(nodeCount);
        for (PBS pbs : list) {
            nodes.addAll(pbs.getNodesByName());
        }
        nodes.sort(nodesNameComparator);
        return nodes;
    }

    private static User getUserByName(String userName, List<PBS> list) {
        User u = null;
        for (PBS pbs : list) {
            User u2 = pbs.getUsersMap().get(userName);
            if (u2 != null) {
                u = (u == null ? u2 : new User(u, u2));
            }
        }
        return u;
    }

    public User getUserByName(String userName) {
        return getUserByName(userName, getListOfPBS());
    }

    @Override
    public List<Job> getUserJobs(String userName, JobsSortOrder sort) {
        ArrayList<Job> jobs = new ArrayList<>();
        for (Job job : this.getSortedJobs(sort)) {
            if (job.getUser().equals(userName)) {
                jobs.add(job);
            }
        }
        return jobs;
    }

    @Override
    public Node getNodeByName(String nodeName) {
        for (PBS pbs : getListOfPBS()) {
            Node node = pbs.getNodes().get(nodeName);
            if (node != null) return node;
        }
        return null;
    }

    @Override
    public Node getNodeByFQDN(String fqdn) {
        for (PBS pbs : getListOfPBS()) {
            Node node = pbs.getFqdnToNodeMap().get(fqdn);
            if (node != null) return node;
        }
        return null;
    }

    @Override
    public int getJobsQueuedCount() {
        int total = 0;
        for (PBS pbs : getListOfPBS()) {
            total += pbs.getJobsQueuedCount();
        }
        return total;
    }

    private static Set<String> getUserNames(List<PBS> list) {
        Set<String> userNames = new TreeSet<>();
        for (PBS pbs : list) {
            userNames.addAll(pbs.getUsersMap().keySet());
        }
        return userNames;
    }

    @Override
    public Set<String> getUserNames() {
        return getUserNames(getListOfPBS());
    }


    @Override
    public List<User> getSortedUsers(UsersSortOrder usersSortOrder) {
        //spojit udaje ze vsech PBSek
        List<PBS> list = getListOfPBS();
        List<User> users = new ArrayList<>();
        for (String userName : getUserNames(list)) {
            users.add(getUserByName(userName, list));
        }
        //seradit
        switch (usersSortOrder) {
            case name:
                users.sort(userNameComparator);
                break;
            case jobsTotal:
                users.sort(userJobsTotalComparator);
                break;
            case jobsStateQ:
                users.sort(userJobsStateQComparator);
                break;
            case jobsStateR:
                users.sort(userJobsStateRComparator);
                break;
            case jobsStateC:
                users.sort(userJobsStateCComparator);
                break;
            case jobsOther:
                users.sort(userJobsOtherComparator);
                break;
            case cpusTotal:
                users.sort(userCpusTotalComparator);
                break;
            case cpusStateQ:
                users.sort(userCpusStateQComparator);
                break;
            case cpusStateR:
                users.sort(userCpusStateRComparator);
                break;
            case cpusStateC:
                users.sort(userCpusStateCComparator);
                break;
            case cpusOther:
                users.sort(userCpusOtherComparator);
                break;
            case fairshare:
                //neni zatim podle ceho tridit
                break;
            default:
                throw new RuntimeException("unknow choice usersSortOrder=" + usersSortOrder);
        }
        return users;
    }

    @SuppressWarnings("Convert2streamapi")
    @Override
    public List<TextWithCount> getReasonsForJobsQueued(PBS pbs) {
        HashMap<String, Integer> counters = new HashMap<>();
            for (Job job : pbs.getJobsById()) {
                if ("Q".equals(job.getState())) {
                    String comment = job.getComment();
                    Integer count = counters.get(comment);
                    if (count == null) {
                        count = 0;
                    }
                    counters.put(comment, count + 1);
                }
            }
        List<TextWithCount> duvody = new ArrayList<>(counters.size());
        for (String duvod : counters.keySet()) {
            duvody.add(new TextWithCount(duvod, counters.get(duvod)));
        }
        Collections.sort(duvody);
        return duvody;
    }

    private static class Uklizec extends Thread {
        private final List<PBS> pbsky_old;

        private Uklizec(List<PBS> pbsky) {
            super("uklizec");
            this.pbsky_old = pbsky;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(90000);
            } catch (InterruptedException e) {
                log.error("problem v cekani", e);
            }
            for (PBS pbs : pbsky_old) {
                pbs.clear();
            }
            pbsky_old.clear();
        }
    }


    //comparators for array sorting
    static final Comparator<Queue> queuesPriorityComparator = (o1, o2) -> o2.getPriority() - o1.getPriority();

    static Comparator<Node> nodesNameComparator = (h1, h2) -> {
        String h1clustName = h1.getClusterName();
        if (h1clustName == null) {
            log.error("Node h1=" + h1 + " has no clusterName");
            throw new IllegalArgumentException("node " + h1.getName() + " has no clusterName");
        }
        if (!h1clustName.equals(h2.getClusterName())) {
            return h1.getClusterName().compareTo(h2.getClusterName());
        } else {
            int diffNumInCluster = h1.getNumInCluster() - h2.getNumInCluster();
            if (diffNumInCluster != 0) {
                return diffNumInCluster;
            } else {
                return h1.getVirtNum() - h2.getVirtNum();
            }
        }
    };

    static final Comparator<Job> jobsIdComparator = (j1, j2) -> {
        //first compare server part of id, e.g. arien-pro.ics.muni.cz
        int serverDiff = j1.getIdServer().compareTo(j2.getIdServer());
        if (serverDiff != 0) return serverDiff;
        //if server part is the same, compare numerical id
        int numDiff = j1.getIdNum() - j2.getIdNum();
        if (numDiff != 0) return numDiff;
        //if server and id are the same, maybe job array id is different
        int subNumDiff = j1.getIdSubNum() - j2.getIdSubNum();
        if (subNumDiff !=0 ) return subNumDiff;
        //if the whole ids are identical, it is Moved job, sort by server
        return j1.getPbs().getHost().compareTo(j2.getPbs().getHost());
    };


    private static Comparator<Job> jobCPUComparator = (o1, o2) -> o2.getNoOfUsedCPU() - o1.getNoOfUsedCPU();

    private static Comparator<Job> jobNameComparator = Comparator.comparing(Job::getJobName);

    private static Comparator<Job> jobUserComparator = Comparator.comparing(Job::getUser);

    private static Comparator<Job> jobCPUTimeUsedComparator = (o1, o2) -> (int) (o2.getCPUTimeUsedSec() - o1.getCPUTimeUsedSec());

    private static Comparator<Job> jobWallTimeUsedComparator = (j1,j2) -> {
        Duration d1 = j1.getWalltimeUsed();
        if(d1==null) d1 = Duration.ZERO;
        Duration d2 = j2.getWalltimeUsed();
        if(d2==null) d2 = Duration.ZERO;
        return d1.compareTo(d2);
    };

    private static Comparator<Job> jobStateComparator = Comparator.comparing(o -> JobState.valueOf(o.getState()));

    private static Comparator<Job> jobQueueComparator = Comparator.comparing(Job::getQueueName);

    private static Comparator<Job> jobCtimeComparator = Comparator.comparing(Job::getTimeCreated);

    private static Comparator<Job> jobUsedMemComparator = (o1, o2) -> {
        long l = o2.getUsedMemoryNum() - o1.getUsedMemoryNum();
        return (l > 0 ? 1 : (l < 0 ? -1 : 0));
    };
    private static Comparator<Job> jobReservedMemTotalComparator = (o1, o2) -> {
        long l = o2.getReservedMemoryTotalNum() - o1.getReservedMemoryTotalNum();
        return (l > 0 ? 1 : (l < 0 ? -1 : 0));
    };

    private static Comparator<User> userNameComparator = Comparator.comparing(User::getName);

    private static Comparator<User> userJobsTotalComparator = (u1, u2) -> u2.getJobsTotal() - u1.getJobsTotal();

    private static Comparator<User> userJobsStateQComparator = (u1, u2) -> u2.getJobsStateQ() - u1.getJobsStateQ();

    private static Comparator<User> userJobsStateRComparator = (u1, u2) -> u2.getJobsStateR() - u1.getJobsStateR();

    private static Comparator<User> userJobsStateCComparator = (u1, u2) -> u2.getJobsStateC() - u1.getJobsStateC();

    private static Comparator<User> userJobsOtherComparator = (u1, u2) -> u2.getJobsOther() - u1.getJobsOther();

    private static Comparator<User> userCpusTotalComparator = (u1, u2) -> u2.getCpusTotal() - u1.getCpusTotal();

    private static Comparator<User> userCpusStateQComparator = (u1, u2) -> u2.getCpusStateQ() - u1.getCpusStateQ();

    private static Comparator<User> userCpusStateRComparator = (u1, u2) -> u2.getCpusStateR() - u1.getCpusStateR();

    private static Comparator<User> userCpusStateCComparator = (u1, u2) -> u2.getCpusStateC() - u1.getCpusStateC();

    private static Comparator<User> userCpusOtherComparator = (u1, u2) -> u2.getCpusOther() - u1.getCpusOther();


}
```


Overlapping Code:
```
sWarnings("Convert2streamapi")
public class PbskyImpl extends RefreshLoader implements Pbsky {
final static Logger log = LoggerFactory.getLogger(PbskyImpl.class);
private List<PbsServerConfig> pbsServers;
private PbsCache pbsCache;
private PbsConnector pbsConnector;
private List<PBS> pbsky;
private Map<String, Queue> queuesMap;
private List<Job> allJobs;
private JobsInfo jobsInfo;
public void setPbsServers(List<PbsServerConfig> pbsServers) {
this.pbsServers = pbsServers;
}
@Override
public List<PbsServerConfig> getPbsServerConfigs() {
return pbsServers;
}
public void setPbsCache(PbsCache pbsCache) {
this.pbsCache = pbsCache;
}
public void setPbsConnector(PbsConnector pbsConnector) {
this.pbsConnector = pbsConnector;
}
public PbskyImpl() {
}
@Override
public List<PBS> getListOfPBS() {
//obsahuje checkLoad(), takze neni potreba tam, kde se volaji getListOfPBS()
checkLoad();
return pbsky;
}
private static PBS findPBSForServer(PbsServerConfig server, List<PBS> pbsList) {
if(pbsList==null) return null;
for (PBS p : pbsList) {
if (p.getServerConfig().equals(server)) {
return p;
}
}
return null;
}
@Override
protected void load() {
try {
List<PBS> pbskyNew = new ArrayList<>();
Map<String, Queue> queuesMapNew = new HashMap<>();
List<PBS> oldPbsky = new ArrayList<>();
//nacti vsechno cerstve. pokud to jde, jinak si nech stara data
for (PbsServerConfig server : pbsServers) {
PBS oldData = findPBSForServer(server, pbsky);
try {
long time = System.currentTimeMillis();
PBS pbs = pbsConnector.loadData(server);
time = System.currentTimeMillis()- time;
if(time > 20000L) {
log.warn("loading data from PBS {} took {} ms", server.getHost(), time);
}
pbs.uprav();
pbskyNew.add(pbs);
log.debug("got new data "+pbs);
if(oldData!=null) {
oldPbsky.add(oldData);
log.debug("marked old data for clear
```
<Overlap Ratio: 0.9693053311793215>

---

--- 333 --
Question ID: 6bbbbef48b6488c2618a9019bddf3c467e6eb7d3
Original Code:
```
@Configuration
public class VelocityEngineProvider {
    @Bean
    public VelocityEngine velocityEngine() {
        VelocityEngine velocityEngine = new VelocityEngine();

        velocityEngine.setProperty("resource.loader", "class");
        velocityEngine.setProperty("class.resource.loader.class",
                "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
        velocityEngine.setProperty(RuntimeConstants.EVENTHANDLER_INCLUDE, IncludeRelativePath.class.getName());
        velocityEngine.setProperty("velocimacro.library", TemplatesLocation.MACROS);

        velocityEngine.init();

        return velocityEngine;
    }
}
```


Overlapping Code:
```
on
public class VelocityEngineProvider {
@Bean
public VelocityEngine velocityEngine() {
VelocityEngine velocityEngine = new VelocityEngine();
velocityEngine.setProperty("resource.loader", "class");
velocityEngine.setProperty("class.resource.loader.class",
"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
velocityEngine.setProperty(RuntimeConstants.EVENTHANDLER_INCLUDE, IncludeRelativePath.class.getName());
velocityEngine.setProperty("velocimacro.library", TemplatesLocation.MACROS);
velocityEngine.init();
return velocityEngine;
}
```
<Overlap Ratio: 0.9754385964912281>

---

--- 334 --
Question ID: e2519feb61e206419eb942658f459b4d28491170
Original Code:
```
public class FindByHeader extends CommandState {

    public FindByHeader(Tracker tracker, Input input) {
        super(tracker, input);
    }

    @Override
    public void execute() {
        String header = this.input.ask("Enter task name for search.");
        this.tracker.findByHeader(header);
        System.out.println(tracker.getMessage());
        System.out.println("=========================================================");
    }

    @Override
    public boolean checkCommand(final String commandFlag) {
        return commandFlag.equals("f -h");
    }
}
```


Overlapping Code:
```
yHeader extends CommandState {
public FindByHeader(Tracker tracker, Input input) {
super(tracker, input);
}
@Override
public void execute() {
String header = this.input.ask("Enter task name for search.");
this.tracker.findByHeader(header);
System.out.println(tracker.getMessage());
System.out.println("=========================================================");
}
@Override
public boolean checkCommand(final String commandFlag) {
return commandFlag.
```
<Overlap Ratio: 0.9240246406570842>

---

--- 335 --
Question ID: a4cf48de469b563c0faf5017f247750722ef9e4a
Original Code:
```
public class UnfollowServlet extends DendriteServlet {

    private static final long serialVersionUID = -1671751304334555912L;

    private boolean isTargetIdValid(final String id) {
        final User target = new User();
        target.setId(id);
        return target.isInStore();
    }

    @Override
    protected void doPost(final HttpServletRequest req,
            final HttpServletResponse resp)
                    throws ServletException, IOException {
        final String targetId = req.getParameter("id");
        final boolean isTargetIdValid = isTargetIdValid(targetId);
        if (isTargetIdValid == true) {
            final UnfollowController controller = new UnfollowController();
            controller.setTargetId(targetId);
            final User source = User.getMyUser();
            final String sourceId = source.getId();
            controller.setSourceId(sourceId);
            controller.enableUnfollow();
            resp.setStatus(HttpServletResponse.SC_OK);
        } else {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        }
    }
}
```


Overlapping Code:
```
vlet extends DendriteServlet {
private static final long serialVersionUID = -1671751304334555912L;
private boolean isTargetIdValid(final String id) {
final User target = new User();
target.setId(id);
return target.isInStore();
}
@Override
protected void doPost(final HttpServletRequest req,
final HttpServletResponse resp)
throws ServletException, IOException {
final String targetId = req.getParameter("id");
final boolean isTargetIdValid = isTargetIdValid(targetId);
if (isTargetIdValid == true) {
final UnfollowController controller = new UnfollowController();
controller.setTargetId(targetId);
final User source = User.getMyUser();
final String sourceId = source.getId();
controller.setSourceId(sourceId);
controller.enableUnfollow();
resp.setStatus(HttpServletResponse.SC_OK);
} else {
resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
}
}
}
```
<Overlap Ratio: 0.9724770642201835>

---

--- 336 --
Question ID: ef71506d0ec030e2b2bc29d0db1cb82e7ad57c0a
Original Code:
```
public class GT_TileEntity_CircuitAssemblyLine extends GT_MetaTileEntity_MultiBlockBase {

    public String getTypeForDisplay() {
        if (this.type.equals(new NBTTagCompound()))
            return "";
        return GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));
    }

    private NBTTagCompound type = new NBTTagCompound();
    private GT_Recipe bufferedRecipe;

    public GT_TileEntity_CircuitAssemblyLine(int aID, String aName, String aNameRegional) {
        super(aID, aName, aNameRegional);
    }

    public GT_TileEntity_CircuitAssemblyLine(String aName) {
        super(aName);
    }

    private boolean imprintMachine(ItemStack itemStack){
        if (!this.type.equals(new NBTTagCompound()))
            return true;
        if (!GT_Utility.isStackValid(itemStack))
            return false;
        if (itemStack.getItem() instanceof BW_Meta_Items.BW_GT_MetaGenCircuits && itemStack.getItemDamage() == 0 && itemStack.getTagCompound() != null && this.type.equals(new NBTTagCompound())){
            this.type = itemStack.getTagCompound();
            this.mInventory[1] = null;
            this.getBaseMetaTileEntity().issueBlockUpdate();
            return true;
        }
        return false;
    }

    @Override
    public boolean isCorrectMachinePart(ItemStack itemStack) {
        return true;
    }

    @Override
    public void startSoundLoop(byte aIndex, double aX, double aY, double aZ) {
        super.startSoundLoop(aIndex, aX, aY, aZ);
        if (aIndex == 20) {
            GT_Utility.doSoundAtClient(GregTech_API.sSoundList.get(212), 10, 1.0F, aX, aY, aZ);
        }
    }

    @Override
    public void loadNBTData(NBTTagCompound aNBT) {
        this.type = aNBT.getCompoundTag("Type");
        super.loadNBTData(aNBT);
    }

    @Override
    public void saveNBTData(NBTTagCompound aNBT) {
        if (!this.type.equals(new NBTTagCompound()))
            aNBT.setTag("Type", this.type);
        super.saveNBTData(aNBT);

    }

    private final Collection<GT_Recipe> GT_RECIPE_COLLECTION = new HashSet<>();

    @Override
    public boolean checkRecipe(ItemStack itemStack) {
        if (this.type.equals(new NBTTagCompound()))
            if (!this.imprintMachine(itemStack))
                return false;

        if (this.bufferedRecipe != null && this.bufferedRecipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this))) {
            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);
            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);
            this.mOutputItems = this.bufferedRecipe.mOutputs;
            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;
            this.updateSlots();
            return true;
        }

        ItemStack stack = ItemStack.loadItemStackFromNBT(this.type);

        if (stack == null)
            return false;

        if (this.GT_RECIPE_COLLECTION.isEmpty()) {
            for (GT_Recipe recipe : BWRecipes.instance.getMappingsFor((byte) 3).mRecipeList) {
                if (GT_Utility.areStacksEqual(recipe.mOutputs[0], stack, true)) {
                    this.GT_RECIPE_COLLECTION.add(recipe);
                }
            }
        }

        for (GT_Recipe recipe : this.GT_RECIPE_COLLECTION) {
            if (recipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getItemsFromInputBusses(this)))
                this.bufferedRecipe = recipe;
            else
                continue;

            BW_Util.calculateOverclockedNessMulti(this.bufferedRecipe.mEUt,this.bufferedRecipe.mDuration,1,this.getMaxInputVoltage(),this);
            this.mMaxProgresstime = Math.max(1, this.mMaxProgresstime);
            this.mOutputItems = this.bufferedRecipe.mOutputs;
            this.mOutputFluids = this.bufferedRecipe.mFluidOutputs;
            this.updateSlots();
            return true;
        }
        return false;
    }

    @Override
    public boolean checkMachine(IGregTechTileEntity aBaseMetaTileEntity, ItemStack aStack) {
        int xDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetX;
        int zDir = ForgeDirection.getOrientation(aBaseMetaTileEntity.getBackFacing()).offsetZ;
        int r;
        int i;
        IGregTechTileEntity tTileEntity;
        if (xDir != 0) {
            for(r = 0; r <= 7; ++r) {
                i = r * xDir;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, 0, i);
                if (!this.addEnergyInputToMachineList(tTileEntity, 16))
                    if ((aBaseMetaTileEntity.getBlockOffset(0, 0, i) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(0, 0, i) != 10) && r == 1)
                        return false;
                if (!aBaseMetaTileEntity.getBlockOffset(0, -1, i).getUnlocalizedName().equals("blockAlloyGlass"))
                    return false;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(0, -2, i);
                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))
                    if (aBaseMetaTileEntity.getBlockOffset(0, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(0, -2, i) != 0)
                        return false;

                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(xDir, -1, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir, -1, i) != 5))
                    return false;

                if (!aBaseMetaTileEntity.getBlockOffset(xDir * 2, -1, i).getUnlocalizedName().equals("blockAlloyGlass"))
                    return false;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir * 2, -2, i);
                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))
                    if (aBaseMetaTileEntity.getBlockOffset(xDir * 2, -2, i) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(xDir * 2, -2, i) != 0)
                        return false;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(xDir, -2, i);
                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))
                    return r > 0 && this.mEnergyHatches.size() > 0;

            }
        } else {

            for(r = 0; r <= 7; ++r) {
                i = r * -zDir;

                //top with grate and energy hatch
                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, 0, zDir);
                if (!this.addEnergyInputToMachineList(tTileEntity, 16))
                    if ((aBaseMetaTileEntity.getBlockOffset(i, 0, 0) != GregTech_API.sBlockCasings3 || aBaseMetaTileEntity.getMetaIDOffset(i, 0, 0) != 10) && r == 1)
                        return false;

                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, 0).getUnlocalizedName().equals("blockAlloyGlass"))
                    return false;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, 0);
                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))
                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, 0) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, 0) != 0)
                        return false;

                if (i != 0 && (aBaseMetaTileEntity.getBlockOffset(i, -1, zDir) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -1, zDir) != 5))
                    return false;

                if (!aBaseMetaTileEntity.getBlockOffset(i, -1, zDir * 2).getUnlocalizedName().equals("blockAlloyGlass"))
                    return false;


                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir * 2);
                if (!this.addMaintenanceToMachineList(tTileEntity, 16) && !this.addInputToMachineList(tTileEntity, 16))
                    if (aBaseMetaTileEntity.getBlockOffset(i, -2, zDir * 2) != GregTech_API.sBlockCasings2 || aBaseMetaTileEntity.getMetaIDOffset(i, -2, zDir * 2) != 0)
                        return false;

                tTileEntity = aBaseMetaTileEntity.getIGregTechTileEntityOffset(i, -2, zDir);
                if (!this.addInputToMachineList(tTileEntity, 16) && this.addOutputToMachineList(tTileEntity, 16))
                    return r > 0 && this.mEnergyHatches.size() == 1;
            }
        }

        return false;
    }

    @Override
    public boolean addInputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {
        if (aTileEntity == null) {
            return false;
        } else {
            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();
            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_Input) {
                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);
                ((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity).mRecipeMap = this.getRecipeMap();
                return this.mInputHatches.add((GT_MetaTileEntity_Hatch_Input)aMetaTileEntity);
            } else if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_InputBus && ((GT_MetaTileEntity_Hatch_InputBus) aMetaTileEntity).mTier == 0) {
                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);
                ((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity).mRecipeMap = this.getRecipeMap();
                return this.mInputBusses.add((GT_MetaTileEntity_Hatch_InputBus)aMetaTileEntity);
            } else {
                return false;
            }
        }
    }

    @Override
    public boolean addOutputToMachineList(IGregTechTileEntity aTileEntity, int aBaseCasingIndex) {
        if (aTileEntity == null) {
            return false;
        } else {
            IMetaTileEntity aMetaTileEntity = aTileEntity.getMetaTileEntity();
            if (aMetaTileEntity instanceof GT_MetaTileEntity_Hatch_OutputBus && ((GT_MetaTileEntity_Hatch_OutputBus) aMetaTileEntity).mTier == 0) {
                ((GT_MetaTileEntity_Hatch)aMetaTileEntity).updateTexture(aBaseCasingIndex);
                return this.mOutputBusses.add((GT_MetaTileEntity_Hatch_OutputBus)aMetaTileEntity);
            } else {
                return false;
            }
        }
    }

    @Override
    public int getMaxEfficiency(ItemStack itemStack) {
        return 10000;
    }

    @Override
    public int getPollutionPerTick(ItemStack itemStack) {
        return 0;
    }

    @Override
    public int getDamageToComponent(ItemStack itemStack) {
        return 0;
    }

    @Override
    public boolean explodesOnComponentBreak(ItemStack itemStack) {
        return false;
    }

    @Override
    public IMetaTileEntity newMetaEntity(IGregTechTileEntity iGregTechTileEntity) {
        return new GT_TileEntity_CircuitAssemblyLine(this.mName);
    }

    @Override
    public String[] getDescription() {
        return new String[]{
                "Circuit Assembly Line", "Size(WxHxD): (2-7)x3x3, variable length",
                "Bottom: Steel Machine Casing(or 1x Maintenance or Input Hatch),",
                "ULV Input Bus (Last ULV Output Bus), Steel Machine Casing",
                "Middle: Reinforced Glass, Assembling Line Casing, Reinforced Glass",
                "Top: Grate Machine Casing (or Controller or 1x Energy Hatch)",
                "Up to 7 repeating slices, last is Output Bus",
                "Imprint this machine with a Circuit Imprint,",
                "by putting the imprint in the controller.",
                "Every Circuit Assembly Line can only be imprinted ONCE.",
                StatCollector.translateToLocal("tooltip.bw.1.name") + ChatColorHelper.DARKGREEN + " BartWorks"
        };
    }

    @Override
    public String[] getInfoData() {
        String[] ret = new String[super.getInfoData().length+1];
        System.arraycopy(super.getInfoData(),0,ret,0,super.getInfoData().length);
        ret[super.getInfoData().length] = "Imprinted with: "+ GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));
        return ret;
    }

    @Override
    public boolean isGivingInformation() {
        return true;
    }

    @Override
    public ITexture[] getTexture(IGregTechTileEntity aBaseMetaTileEntity, byte aSide, byte aFacing, byte aColorIndex, boolean aActive, boolean aRedstone) {
        return aSide == aFacing ? new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16], new GT_RenderedTexture(aActive ? Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE_ACTIVE : Textures.BlockIcons.OVERLAY_FRONT_ASSEMBLY_LINE)} : new ITexture[]{Textures.BlockIcons.CASING_BLOCKS[16]};
    }
}
```


Overlapping Code:
```
ic class GT_TileEntity_CircuitAssemblyLine extends GT_MetaTileEntity_MultiBlockBase {
public String getTypeForDisplay() {
if (this.type.equals(new NBTTagCompound()))
return "";
return GT_LanguageManager.getTranslation(GT_LanguageManager.getTranslateableItemStackName(CircuitImprintLoader.getStackFromTag(this.type)));
}
private NBTTagCompound type = new NBTTagCompound();
private GT_Recipe bufferedRecipe;
public GT_TileEntity_CircuitAssemblyLine(int aID, String aName, String aNameRegional) {
super(aID, aName, aNameRegional);
}
public GT_TileEntity_CircuitAssemblyLine(String aName) {
super(aName);
}
private boolean imprintMachine(ItemStack itemStack){
if (!this.type.equals(new NBTTagCompound()))
return true;
if (!GT_Utility.isStackValid(itemStack))
return false;
if (itemStack.getItem() instanceof BW_Meta_Items.BW_GT_MetaGenCircuits && itemStack.getItemDamage() == 0 && itemStack.getTagCompound() != null && this.type.equals(new NBTTagCompound())){
this.type = itemStack.getTagCompound();
this.mInventory[1] = null;
this.getBaseMetaTileEntity().issueBlockUpdate();
return true;
}
return false;
}
@Override
public boolean isCorrectMachinePart(ItemStack itemStack) {
return true;
}
@Override
public void startSoundLoop(byte aIndex, double aX, double aY, double aZ) {
super.startSoundLoop(aIndex, aX, aY, aZ);
if (aIndex == 20) {
GT_Utility.doSoundAtClient(GregTech_API.sSoundList.get(212), 10, 1.0F, aX, aY, aZ);
}
}
@Override
public void loadNBTData(NBTTagCompound aNBT) {
this.type = aNBT.getCompoundTag("Type");
super.loadNBTData(aNBT);
}
@Override
public void saveNBTData(NBTTagCompound aNBT) {
if (!this.type.equals(new NBTTagCompound()))
aNBT.setTag("Type", this.type);
super.saveNBTData(aNBT);
}
private final Collection<GT_Recipe> GT_RECIPE_COLLECTION = new HashSet<>();
@Override
public boolean checkRecipe(ItemStack itemStack) {
if (this.type.equals(new NBTTagCompound()))
if (!this.imprintMachine(itemStack))
return false;
if (this.bufferedRecipe != null && this.bufferedRecipe.isRecipeInputEqual(true,false, BW_Util.getFluidsFromInputHatches(this), BW_Util.getIte
```
<Overlap Ratio: 0.9914204003813155>

---

--- 337 --
Question ID: 81163eed525c75854386220fafe777f638bca3dd
Original Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-04-19T15:41:52.549-07:00")
public class StoragepoolStoragepools {
  @SerializedName("storagepools")
  private List<StoragepoolStoragepool> storagepools = null;

  @SerializedName("total")
  private Integer total = null;

  public StoragepoolStoragepools storagepools(List<StoragepoolStoragepool> storagepools) {
    this.storagepools = storagepools;
    return this;
  }

  public StoragepoolStoragepools addStoragepoolsItem(StoragepoolStoragepool storagepoolsItem) {
    if (this.storagepools == null) {
      this.storagepools = new ArrayList<StoragepoolStoragepool>();
    }
    this.storagepools.add(storagepoolsItem);
    return this;
  }

   /**
   * Get storagepools
   * @return storagepools
  **/
  @ApiModelProperty(value = "")
  public List<StoragepoolStoragepool> getStoragepools() {
    return storagepools;
  }

  public void setStoragepools(List<StoragepoolStoragepool> storagepools) {
    this.storagepools = storagepools;
  }

  public StoragepoolStoragepools total(Integer total) {
    this.total = total;
    return this;
  }

   /**
   * Total number of items available.
   * minimum: 0
   * maximum: 4294967295
   * @return total
  **/
  @ApiModelProperty(value = "Total number of items available.")
  public Integer getTotal() {
    return total;
  }

  public void setTotal(Integer total) {
    this.total = total;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StoragepoolStoragepools storagepoolStoragepools = (StoragepoolStoragepools) o;
    return Objects.equals(this.storagepools, storagepoolStoragepools.storagepools) &&
        Objects.equals(this.total, storagepoolStoragepools.total);
  }

  @Override
  public int hashCode() {
    return Objects.hash(storagepools, total);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StoragepoolStoragepools {\n");
    
    sb.append("    storagepools: ").append(toIndentedString(storagepools)).append("\n");
    sb.append("    total: ").append(toIndentedString(total)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
```


Overlapping Code:
```
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-04-19T15:41:52.549-07:00")
public class StoragepoolStoragepools {
@SerializedName("storagepools")
private List<StoragepoolStoragepool> storagepools = null;
@SerializedName("total")
private Integer total = null;
public StoragepoolStoragepools storagepools(List<StoragepoolStoragepool> storagepools) {
this.storagepools = storagepools;
return this;
}
public StoragepoolStoragepools addStoragepoolsItem(StoragepoolStoragepool storagepoolsItem) {
if (this.storagepools == null) {
this.storagepools = new ArrayList<StoragepoolStoragepool>();
}
this.storagepools.add(storagepoolsItem);
return this;
}
/**
* Get storagepools
* @return storagepools
**/
@ApiModelProperty(value = "")
public List<StoragepoolStoragepool> getStoragepools() {
return storagepools;
}
public void setStoragepools(List<StoragepoolStoragepool> storagepools) {
this.storagepools = storagepools;
}
public StoragepoolStoragepools total(Integer total) {
this.total = total;
return this;
}
/**
* Total number of items available.
* minimum: 0
* maximum: 4294967295
* @return total
**/
@ApiModelProperty(value = "Total number of items available.")
public Integer getTotal() {
return total;
}
public void setTotal(Integer total) {
this.total = total;
}
@Override
public boolean equals(java.lang.Object o) {
if (this == o) {
return true;
}
if (o == null || getClass() != o.getClass()) {
return false;
}
StoragepoolStoragepools storagepoolStoragepools = (StoragepoolStoragepools) o;
return Objects.equals(this.storagepools, storagepoolStoragepools.storagepools) &&
Objects.equals(this.total, storagepoolStoragepools.total);
}
@Override
public int hashCode() {
return Objects.hash(storagepools, total);
}
@Override
public String toString() {
StringBuilder sb = new StringBuilder();
sb.append("class StoragepoolStoragepools {\n");

sb.append(" storagepools: ").append(toIndentedString(storagepools)).append("\n");
sb.append(" total: ").append(toIndentedString(total)).append("\n");
sb.append("}");
return sb.toString();
}
/**
* Convert the given object to string with each line indented by 4 spaces
* (except the first line).
*/
private String toIndentedString(java.lang.Object o) {
if (o ==
```
<Overlap Ratio: 1.0>

---

--- 338 --
Question ID: 3f832fd92f3dbb085aa0e555bafb95e2496d546c
Original Code:
```
public class SubsetProxy  extends AbstractProxy
{
   private static final String PREFIX = "sys-subset-";


   /**
    * 
    */
   public SubsetProxy() { }

   /**
    * @param h
    * @param name
    */
   public SubsetProxy(IHandle h, String name)
   {
      super(h, decorate(name));
   }

//   public SubsetProxy(XModel m, String name)
//   {
//      super(m, );
//      
//      m.associate(name(), this);      
//      
//      JimaMisc.log().println("subset proxy: " + name + " -> " + get_handle());
//   }

   private static String decorate(String name)
   {
      return PREFIX + name;
   }
   
   private static String undecorate(String s)
   {
      return s.substring(PREFIX.length());
   }
   

//   /**
//    * @see il.ac.technion.micropatterns.jane.model.IProxy#accept(il.ac.technion.micropatterns.jane.model.IVisitor)
//    */
//   public void accept(IVisitor v)
//   {
//      v.visit(this);
//   }

   /**
    * @see il.ac.technion.micropatterns.jane.model.IProxy#create(il.ac.technion.micropatterns.jane.model.IModelRequest)
    */
   public IElement create(IModelRequest mr)
   {
      JimaMisc.ensure(mr != null);
      
      XModel m = mr.model();
      try
      {
         IElement result = (IElement) m.fetch(this.name());
         return result;
      }
      catch (Throwable e)
      {
//         System.out.println("Error " + e);
//         e.printStackTrace();
//         
         IElement result = new SubsetElement(get_handle(), this.name());
         return result;
      }
   }
   
   public String pretty_name()
   {
      return undecorate(name());
   }
   
   public String toString()
   {
      return "SubsetProxy(" + pretty_name() + ", " + get_handle() + ")";
   }   
}
```


Overlapping Code:
```
Proxy
{
private static final String PREFIX = "sys-subset-";
/**
* 
*/
public SubsetProxy() { }
/**
* @param h
* @param name
*/
public SubsetProxy(IHandle h, String name)
{
super(h, decorate(name));
}
// public SubsetProxy(XModel m, String name)
// {
// super(m, );
// 
// m.associate(name(), this); 
// 
// JimaMisc.log().println("subset proxy: " + name + " -> " + get_handle());
// }
private static String decorate(String name)
{
return PREFIX + name;
}

private static String undecorate(String s)
{
return s.substring(PREFIX.length());
}

// /**
// * @see il.ac.technion.micropatterns.jane.model.IProxy#accept(il.ac.technion.micropatterns.jane.model.IVisitor)
// */
// public void accept(IVisitor v)
// {
// v.visit(this);
// }
/**
* @see il.ac.technion.micropatterns.jane.model.IProxy#create(il.ac.technion.micropatterns.jane.model.IModelRequest)
*/
public IElement create(IModelRequest mr)
{
JimaMisc.ensure(mr != null);

XModel m = mr.model();
try
{
IElement result = (IElement) m.fetch(this.name());
return result;
}
catch (Throwable e)
{
// System.out.println("Error " + e);
// e.printStackTrace();
// 
IElement result = new SubsetElement(get_handle(), this.name());
return result;
}
}

public String pretty_name()
{
return undecorate(name());
}

public String toString()
{
return "SubsetProxy(" + pretty_name() + ", " + get_handle() + ")";
} 
```
<Overlap Ratio: 0.9691313711414213>

---

--- 339 --
Question ID: 6ba0928e1a5ce8e75455db388ae7d444e0e104c1
Original Code:
```
class pattern9
{
	public static void main(String[] args)
	{
		Scanner kb=new Scanner(System.in);
		System.out.print("N=");
		int n=kb.nextInt();
		int i,j,k;
		for(i=1;i<=n;i++)
		{
			for(j=1;j<i;j++)
			{
				System.out.print(" ");
			}
			for(k=i;k<=n;k++)
			{
				System.out.print(k);
			}
			System.out.println();
		}


		for(i=1;i<n;i++)
		{
			for(j=n-i-1;j>0;j--)
			{
				System.out.print(" ");
			}
			for(k=n-i;k<=n;k++)
			{
				System.out.print(k);
			}
			System.out.println();
		}
	}
}
```


Overlapping Code:
```
9
{
public static void main(String[] args)
{
Scanner kb=new Scanner(System.in);
System.out.print("N=");
int n=kb.nextInt();
int i,j,k;
for(i=1;i<=n;i++)
{
for(j=1;j<i;j++)
{
System.out.print(" ");
}
for(k=i;k<=n;k++)
{
System.out.print(k);
}
System.out.println();
}
for(i=1;i<n;i++)
{
for(j=n-i-1;j>0;j--)
{
System.out.print(" ");
}
for(k=n-i;k<=n;k++)
{
System.out.print(k);
}
System.out.println();
}
}

```
<Overlap Ratio: 0.9665071770334929>

---

--- 340 --
Question ID: 5b18d3e45be0f2e9ebb4767b9e5bcad36eb805fe
Original Code:
```
public class OFDescriptionStatistics implements OFStatistics {
    public static int DESCRIPTION_STRING_LENGTH = 256;
    public static int SERIAL_NUMBER_LENGTH = 32;

    protected String manufacturerDescription;
    protected String hardwareDescription;
    protected String softwareDescription;
    protected String serialNumber;
    protected String datapathDescription;

    /**
     * @return the manufacturerDescription
     */
    public String getManufacturerDescription() {
        return this.manufacturerDescription;
    }

    /**
     * @param manufacturerDescription
     *            the manufacturerDescription to set
     */
    public void setManufacturerDescription(final String manufacturerDescription) {
        this.manufacturerDescription = manufacturerDescription;
    }

    /**
     * @return the hardwareDescription
     */
    public String getHardwareDescription() {
        return this.hardwareDescription;
    }

    /**
     * @param hardwareDescription
     *            the hardwareDescription to set
     */
    public void setHardwareDescription(final String hardwareDescription) {
        this.hardwareDescription = hardwareDescription;
    }

    /**
     * @return the softwareDescription
     */
    public String getSoftwareDescription() {
        return this.softwareDescription;
    }

    /**
     * @param softwareDescription
     *            the softwareDescription to set
     */
    public void setSoftwareDescription(final String softwareDescription) {
        this.softwareDescription = softwareDescription;
    }

    /**
     * @return the serialNumber
     */
    public String getSerialNumber() {
        return this.serialNumber;
    }

    /**
     * @param serialNumber
     *            the serialNumber to set
     */
    public void setSerialNumber(final String serialNumber) {
        this.serialNumber = serialNumber;
    }

    /**
     * @return the datapathDescription
     */
    public String getDatapathDescription() {
        return this.datapathDescription;
    }

    /**
     * @param datapathDescription
     *            the datapathDescription to set
     */
    public void setDatapathDescription(final String datapathDescription) {
        this.datapathDescription = datapathDescription;
    }

    @Override
    public int getLength() {
        return 1056;
    }

    @Override
    public void readFrom(final ChannelBuffer data) {
        this.manufacturerDescription = StringByteSerializer.readFrom(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);
        this.hardwareDescription = StringByteSerializer.readFrom(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);
        this.softwareDescription = StringByteSerializer.readFrom(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);
        this.serialNumber = StringByteSerializer.readFrom(data,
                OFDescriptionStatistics.SERIAL_NUMBER_LENGTH);
        this.datapathDescription = StringByteSerializer.readFrom(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH);
    }

    @Override
    public void writeTo(final ChannelBuffer data) {
        StringByteSerializer.writeTo(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,
                this.manufacturerDescription);
        StringByteSerializer.writeTo(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,
                this.hardwareDescription);
        StringByteSerializer.writeTo(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,
                this.softwareDescription);
        StringByteSerializer
                .writeTo(data, OFDescriptionStatistics.SERIAL_NUMBER_LENGTH,
                        this.serialNumber);
        StringByteSerializer.writeTo(data,
                OFDescriptionStatistics.DESCRIPTION_STRING_LENGTH,
                this.datapathDescription);
    }

    @Override
    public int hashCode() {
        final int prime = 409;
        int result = 1;
        result = prime
                * result
                + (this.datapathDescription == null ? 0
                        : this.datapathDescription.hashCode());
        result = prime
                * result
                + (this.hardwareDescription == null ? 0
                        : this.hardwareDescription.hashCode());
        result = prime
                * result
                + (this.manufacturerDescription == null ? 0
                        : this.manufacturerDescription.hashCode());
        result = prime
                * result
                + (this.serialNumber == null ? 0 : this.serialNumber.hashCode());
        result = prime
                * result
                + (this.softwareDescription == null ? 0
                        : this.softwareDescription.hashCode());
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof OFDescriptionStatistics)) {
            return false;
        }
        final OFDescriptionStatistics other = (OFDescriptionStatistics) obj;
        if (this.datapathDescription == null) {
            if (other.datapathDescription != null) {
                return false;
            }
        } else if (!this.datapathDescription.equals(other.datapathDescription)) {
            return false;
        }
        if (this.hardwareDescription == null) {
            if (other.hardwareDescription != null) {
                return false;
            }
        } else if (!this.hardwareDescription.equals(other.hardwareDescription)) {
            return false;
        }
        if (this.manufacturerDescription == null) {
            if (other.manufacturerDescription != null) {
                return false;
            }
        } else if (!this.manufacturerDescription
                .equals(other.manufacturerDescription)) {
            return false;
        }
        if (this.serialNumber == null) {
            if (other.serialNumber != null) {
                return false;
            }
        } else if (!this.serialNumber.equals(other.serialNumber)) {
            return false;
        }
        if (this.softwareDescription == null) {
            if (other.softwareDescription != null) {
                return false;
            }
        } else if (!this.softwareDescription.equals(other.softwareDescription)) {
            return false;
        }
        return true;
    }
}
```


Overlapping Code:
```
lic class OFDescriptionStatistics implements OFStatistics {
public static int DESCRIPTION_STRING_LENGTH = 256;
public static int SERIAL_NUMBER_LENGTH = 32;
protected String manufacturerDescription;
protected String hardwareDescription;
protected String softwareDescription;
protected String serialNumber;
protected String datapathDescription;
/**
* @return the manufacturerDescription
*/
public String getManufacturerDescription() {
return this.manufacturerDescription;
}
/**
* @param manufacturerDescription
* the manufacturerDescription to set
*/
public void setManufacturerDescription(final String manufacturerDescription) {
this.manufacturerDescription = manufacturerDescription;
}
/**
* @return the hardwareDescription
*/
public String getHardwareDescription() {
return this.hardwareDescription;
}
/**
* @param hardwareDescription
* the hardwareDescription to set
*/
public void setHardwareDescription(final String hardwareDescription) {
this.hardwareDescription = hardwareDescription;
}
/**
* @return the softwareDescription
*/
public String getSoftwareDescription() {
return this.softwareDescription;
}
/**
* @param softwareDescription
* the softwareDescription to set
*/
public void setSoftwareDescription(final String softwareDescription) {
this.softwareDescription = softwareDescription;
}
/**
* @return the serialNumber
*/
public String getSerialNumber() {
return this.serialNumber;
}
/**
* @param serialNumber
* the serialNumber to set
*/
public void setSerialNumber(final String serialNumber) {
this.serialNumber = serialNumber;
}
/**
* @return the datapathDescription
*/
public String getDatapathDescription() {
return this.datapathDescription;
}
/**
* @param datapathDescription
* the datapathDescription to set
*/
public void setDatapathDescription(final String datapathDescription) {
this.datapathDescription = datapathDescription;
}
@Override
public int getLength() {
return 1056;
}
@Override
public void readFrom(final ChannelBuffer data) {
this.manufacturerDescription = StringByteSe
```
<Overlap Ratio: 0.9871858058156727>

---

--- 341 --
Question ID: 4fe5e7988b9ef5ef61e7f7584eafd33cd434ea44
Original Code:
```
public abstract class AbstractNetty4RawSocketServer extends AbstractNetty4SocketServer {

    @Override
    protected BElement handleIncomingMessage(String channelId, Object msg) throws Exception {
        return (BElement) msg;
    }

    @Override
    protected void onInitChannel(SocketChannel socketChannel) {
        Netty4RawChannelPreset.applyLengthPrepender(socketChannel);
        Netty4RawChannelPreset.applyBElementCodec(socketChannel, //
                getConfigs().getString("format", null), //
                getConfigs().getBoolean("nativeBytesEnabled", false));
    }

    @Override
    public final ChannelFuture send(String routingId, BElement data) {
        Channel channel = this.getChannel(routingId);
        if (channel != null) {
            if (data == null) {
                channel.close();
            } else {
                return channel.writeAndFlush(data).addListener(ChannelFutureListener.CLOSE);
            }
        }
        return null;
    }
}
```


Overlapping Code:
```
awSocketServer extends AbstractNetty4SocketServer {
@Override
protected BElement handleIncomingMessage(String channelId, Object msg) throws Exception {
return (BElement) msg;
}
@Override
protected void onInitChannel(SocketChannel socketChannel) {
Netty4RawChannelPreset.applyLengthPrepender(socketChannel);
Netty4RawChannelPreset.applyBElementCodec(socketChannel, //
getConfigs().getString("format", null), //
getConfigs().getBoolean("nativeBytesEnabled", false));
}
@Override
public final ChannelFuture send(String routingId, BElement data) {
Channel channel = this.getChannel(routingId);
if (channel != null) {
if (data == null) {
channel.close();
} else {
return channel.writeAndFlush(data).addListener(ChannelFutureListener.CLOSE);
}
}
return nul
```
<Overlap Ratio: 0.9457755359394704>

---

--- 342 --
Question ID: 26bdb990132c73a7b419f79d1bd19d32d26e2f67
Original Code:
```
public class FreeMarkerWorker {

    public static final String module = FreeMarkerWorker.class.getName();

    // use soft references for this so that things from Content records don't kill all of our memory, or maybe not for performance reasons... hmmm, leave to config file...
    public static UtilCache<String, Template> cachedTemplates = UtilCache.createUtilCache("template.ftl.general", 0, 0, false);
    protected static BeansWrapper defaultOfbizWrapper = BeansWrapper.getDefaultInstance();
    protected static Configuration defaultOfbizConfig = makeConfiguration(defaultOfbizWrapper);

    public static Configuration makeConfiguration(BeansWrapper wrapper) {
        Configuration newConfig = new Configuration();

        newConfig.setObjectWrapper(wrapper);
        newConfig.setSharedVariable("Static", wrapper.getStaticModels());
        newConfig.setLocalizedLookup(false);
        newConfig.setSharedVariable("StringUtil", new BeanModel(StringUtil.INSTANCE, wrapper));
        newConfig.setTemplateLoader(new FlexibleTemplateLoader());
        newConfig.setAutoImports(UtilProperties.getProperties("freemarkerImports"));
        newConfig.setTemplateExceptionHandler(new FreeMarkerWorker.OFBizTemplateExceptionHandler());
        try {
            newConfig.setSetting("datetime_format", "yyyy-MM-dd HH:mm:ss.SSS");
            newConfig.setSetting("number_format", "0.##########");
        } catch (TemplateException e) {
            Debug.logError("Unable to set date/time and number formats in FreeMarker: " + e, module);
        }
        // Transforms properties file set up as key=transform name, property=transform class name
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Enumeration<URL> resources;
        try {
            resources = loader.getResources("freemarkerTransforms.properties");
        } catch (IOException e) {
            Debug.logError(e, "Could not load list of freemarkerTransforms.properties", module);
            throw UtilMisc.initCause(new InternalError(e.getMessage()), e);
        }
        while (resources.hasMoreElements()) {
            URL propertyURL = resources.nextElement();
            Debug.logInfo("loading properties: " + propertyURL, module);
            Properties props = UtilProperties.getProperties(propertyURL);
            if (props == null || props.isEmpty()) {
                Debug.logError("Unable to locate properties file " + propertyURL, module);
            } else {
                loadTransforms(loader, props, newConfig);
            }
        }

        return newConfig;
    }

    /**
     * Protected helper method.
     */
    protected static void loadTransforms(ClassLoader loader, Properties props, Configuration config) {
        for (Iterator<Object> i = props.keySet().iterator(); i.hasNext();) {
            String key = (String) i.next();
            String className = props.getProperty(key);
            if (Debug.verboseOn()) {
                Debug.logVerbose("Adding FTL Transform " + key + " with class " + className, module);
            }
            try {
                config.setSharedVariable(key, loader.loadClass(className).newInstance());
            } catch (Exception e) {
                Debug.logError(e, "Could not pre-initialize dynamically loaded class: " + className + ": " + e, module);
            }
        }
    }

    /**
     * Renders a template at the specified location.
     * @param templateLocation Location of the template - file path or URL
     * @param context The context Map
     * @param outWriter The Writer to render to
     */
    public static void renderTemplateAtLocation(String templateLocation, Map<String, Object> context, Appendable outWriter) throws MalformedURLException, TemplateException, IOException {
        renderTemplate(templateLocation, context, outWriter);
    }

    /**
     * Renders a template contained in a String.
     * @param templateLocation A unique ID for this template - used for caching
     * @param templateString The String containing the template
     * @param context The context Map
     * @param outWriter The Writer to render to
     */
    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {
        renderTemplate(templateLocation, templateString, context, outWriter, true);
    }

    /**
     * Renders a template contained in a String.
     * @param templateLocation A unique ID for this template - used for caching
     * @param templateString The String containing the template
     * @param context The context Map
     * @param outWriter The Writer to render to
     * @param useCache try to get template from cache
     */
    public static void renderTemplate(String templateLocation, String templateString, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {
        if (UtilValidate.isEmpty(templateString)) {
            renderTemplate(templateLocation, context, outWriter);
        } else {
            renderTemplateFromString(templateString, templateLocation, context, outWriter, useCache);
        }
    }

    /**
     * Renders a template from a Reader.
     * @param templateLocation A unique ID for this template - used for caching
     * @param context The context Map
     * @param outWriter The Writer to render to
     */
    public static void renderTemplate(String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {
        Template template = getTemplate(templateLocation);
        renderTemplate(template, context, outWriter);
    }

    /**
     * @deprecated Renamed to {@link #renderTemplateFromString(String, String, Map, Appendable, boolean)}
     */
    @Deprecated
    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {
        Template template = cachedTemplates.get(templateLocation);
        if (template == null) {
            synchronized (cachedTemplates) {
                template = cachedTemplates.get(templateLocation);
                if (template == null) {
                    Reader templateReader = new StringReader(templateString);
                    template = new Template(templateLocation, templateReader, defaultOfbizConfig);
                    templateReader.close();
                    cachedTemplates.put(templateLocation, template);
                }
            }
        }
        return renderTemplate(template, context, outWriter);
    }

    public static Environment renderTemplateFromString(String templateString, String templateLocation, Map<String, Object> context, Appendable outWriter, boolean useCache) throws TemplateException, IOException {
        Template template = null;
        if (useCache){
            template = cachedTemplates.get(templateLocation);
        }
        if (template == null) {
            if (useCache){
                synchronized (cachedTemplates) {
                    template = cachedTemplates.get(templateLocation);
                    if (template == null) {
                        Reader templateReader = new StringReader(templateString);
                        template = new Template(templateLocation, templateReader, defaultOfbizConfig);
                        templateReader.close();
                        cachedTemplates.put(templateLocation, template);
                    }
                }
            } else {
                Reader templateReader = new StringReader(templateString);
                template = new Template(templateLocation, templateReader, defaultOfbizConfig);
                templateReader.close();
            }
        }

        return renderTemplate(template, context, outWriter);
    }

    public static void clearTemplateFromCache(String templateLocation) {
        synchronized (cachedTemplates) {
            cachedTemplates.remove(templateLocation);
        }
    }

    /**
     * Renders a Template instance.
     * @param template A Template instance
     * @param context The context Map
     * @param outWriter The Writer to render to
     */
    public static Environment renderTemplate(Template template, Map<String, Object> context, Appendable outWriter) throws TemplateException, IOException {
        // make sure there is no "null" string in there as FreeMarker will try to use it
        context.remove("null");
        // Since the template cache keeps a single instance of a Template that is shared among users,
        // and since that Template instance is immutable, we need to create an Environment instance and
        // use it to process the template with the user's settings.
        //
        // FIXME: the casting from Appendable to Writer is a temporary fix that could cause a
        //        run time error if in the future we will pass a different class to the method
        //        (such as a StringBuffer).
        Environment env = template.createProcessingEnvironment(context, (Writer) outWriter);
        applyUserSettings(env, context);
        env.process();
        return env;
    }

    /**
     * Apply user settings to an Environment instance.
     * @param env An Environment instance
     * @param context The context Map containing the user settings
     */
    public static void applyUserSettings(Environment env, Map<String, Object> context) throws TemplateException {
        Locale locale = (Locale) context.get("locale");
        if (locale == null) {
            locale = Locale.getDefault();
        }
        env.setLocale(locale);

        TimeZone timeZone = (TimeZone) context.get("timeZone");
        if (timeZone == null) {
            timeZone = TimeZone.getDefault();
        }
        env.setTimeZone(timeZone);
    }

    public static Configuration getDefaultOfbizConfig() {
        return defaultOfbizConfig;
    }

    /** Make sure to close the reader when you're done! That's why this method is private, BTW. */
    private static Reader makeReader(String templateLocation) throws IOException {
        if (UtilValidate.isEmpty(templateLocation)) {
            throw new IllegalArgumentException("FreeMarker template location null or empty");
        }

        URL locationUrl = null;
        try {
            locationUrl = FlexibleLocation.resolveLocation(templateLocation);
        } catch (MalformedURLException e) {
            throw new IllegalArgumentException(e.getMessage());
        }
        if (locationUrl == null) {
            throw new IllegalArgumentException("FreeMarker file not found at location: " + templateLocation);
        }

        InputStream locationIs = locationUrl.openStream();
        Reader templateReader = new InputStreamReader(locationIs);

        String locationProtocol = locationUrl.getProtocol();
        if ("file".equals(locationProtocol) && Debug.verboseOn()) {
            String locationFile = locationUrl.getFile();
            int lastSlash = locationFile.lastIndexOf("/");
            String locationDir = locationFile.substring(0, lastSlash);
            String filename = locationFile.substring(lastSlash + 1);
            Debug.logVerbose("FreeMarker render: filename=" + filename + ", locationDir=" + locationDir, module);
        }

        return templateReader;
    }

    /**
     * Gets a Template instance from the template cache. If the Template instance isn't
     * found in the cache, then one will be created.
     * @param templateLocation Location of the template - file path or URL
     */
    public static Template getTemplate(String templateLocation) throws TemplateException, IOException {
        return getTemplate(templateLocation, cachedTemplates, defaultOfbizConfig);
    }

    public static Template getTemplate(String templateLocation, UtilCache<String, Template> cache, Configuration config) throws TemplateException, IOException {
        Template template = cache.get(templateLocation);
        if (template == null) {
            synchronized (cache) {
                template = cache.get(templateLocation);
                if (template == null) {
                    // only make the reader if we need it, and then close it right after!
                    Reader templateReader = makeReader(templateLocation);
                    template = new Template(templateLocation, templateReader, config);
                    templateReader.close();
                    cache.put(templateLocation, template);
                }
            }
        }
        return template;
    }

    public static String getArg(Map<String, ? extends Object> args, String key, Environment env) {
        Map<String, ? extends Object> templateContext = FreeMarkerWorker.getWrappedObject("context", env);
        return getArg(args, key, templateContext);
    }

    public static String getArg(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {
        //SimpleScalar s = null;
        Object o = args.get(key);
        String returnVal = (String) unwrap(o);
        if (returnVal == null) {
            try {
                if (templateContext != null) {
                    returnVal = (String) templateContext.get(key);
                }
            } catch (ClassCastException e2) {
                //return null;
            }
        }
        return returnVal;
    }

    public static Object getArgObject(Map<String, ? extends Object> args, String key, Map<String, ? extends Object> templateContext) {
        //SimpleScalar s = null;
        Object o = args.get(key);
        Object returnVal = unwrap(o);
        if (returnVal == null) {
            try {
                if (templateContext != null) {
                    returnVal = templateContext.get(key);
                }
            } catch (ClassCastException e2) {
                //return null;
            }
        }
        return returnVal;
    }

   /**
    * Gets BeanModel from FreeMarker context and returns the object that it wraps.
    * @param varName the name of the variable in the FreeMarker context.
    * @param env the FreeMarker Environment
    */
    public static <T> T getWrappedObject(String varName, Environment env) {
        Object obj = null;
        try {
            obj = env.getVariable(varName);
            if (obj != null) {
                if (obj == TemplateModel.NOTHING) {
                    obj = null;
                } else if (obj instanceof BeanModel) {
                    BeanModel bean = (BeanModel) obj;
                    obj = bean.getWrappedObject();
                } else if (obj instanceof SimpleScalar) {
                    obj = obj.toString();
                }
            }
        } catch (TemplateModelException e) {
            Debug.logInfo(e.getMessage(), module);
        }
        return UtilGenerics.<T>cast(obj);
    }

   /**
    * Gets BeanModel from FreeMarker context and returns the object that it wraps.
    * @param varName the name of the variable in the FreeMarker context.
    * @param env the FreeMarker Environment
    */
    public static BeanModel getBeanModel(String varName, Environment env) {
        BeanModel bean = null;
        try {
            bean = (BeanModel) env.getVariable(varName);
        } catch (TemplateModelException e) {
            Debug.logInfo(e.getMessage(), module);
        }
        return bean;
    }

    public static Object get(SimpleHash args, String key) {
        Object o = null;
        try {
            o = args.get(key);
        } catch (TemplateModelException e) {
            Debug.logVerbose(e.getMessage(), module);
            return null;
        }

        Object returnObj = unwrap(o);

        if (returnObj == null) {
            Object ctxObj = null;
            try {
                ctxObj = args.get("context");
            } catch (TemplateModelException e) {
                Debug.logInfo(e.getMessage(), module);
                return returnObj;
            }
            Map<String, ?> ctx = null;
            if (ctxObj instanceof BeanModel) {
                ctx = UtilGenerics.cast(((BeanModel) ctxObj).getWrappedObject());
                returnObj = ctx.get(key);
            }
            /*
            try {
                Map templateContext = (Map) FreeMarkerWorker.getWrappedObject("context", env);
                if (templateContext != null) {
                    returnObj = (String) templateContext.get(key);
                }
            } catch (ClassCastException e2) {
                //return null;
            }
            */
        }
        return returnObj;
    }

    public static Object unwrap(Object o) {
        Object returnObj = null;

        if (o == TemplateModel.NOTHING) {
            returnObj = null;
        } else if (o instanceof SimpleScalar) {
            returnObj = o.toString();
        } else if (o instanceof BeanModel) {
            returnObj = ((BeanModel) o).getWrappedObject();
        }

        return returnObj;
    }

    public static void checkForLoop(String path, Map<String, Object> ctx) throws IOException {
        List<String> templateList = UtilGenerics.checkList(ctx.get("templateList"));
        if (templateList == null) {
            templateList = FastList.newInstance();
        } else {
            if (templateList.contains(path)) {
                throw new IOException(path + " has already been visited.");
            }
        }
        templateList.add(path);
        ctx.put("templateList", templateList);
    }

    public static Map<String, Object> createEnvironmentMap(Environment env) {
        Map<String, Object> templateRoot = FastMap.newInstance();
        Set<String> varNames = null;
        try {
            varNames = UtilGenerics.checkSet(env.getKnownVariableNames());
        } catch (TemplateModelException e1) {
            Debug.logError(e1, "Error getting FreeMarker variable names, will not put pass current context on to sub-content", module);
        }
        if (varNames != null) {
            for (String varName: varNames) {
                //freemarker.ext.beans.StringModel varObj = (freemarker.ext.beans.StringModel) varNameIter.next();
                //Object varObj =  varNameIter.next();
                //String varName = varObj.toString();
                templateRoot.put(varName, FreeMarkerWorker.getWrappedObject(varName, env));
            }
        }
        return templateRoot;
    }

    public static void saveContextValues(Map<String, Object> context, String [] saveKeyNames, Map<String, Object> saveMap) {
        //Map saveMap = new HashMap();
        for (String key: saveKeyNames) {
            Object o = context.get(key);
            if (o instanceof Map<?, ?>) {
                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));
            } else if (o instanceof List<?>) {
                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));
            }
            saveMap.put(key, o);
        }
    }

    public static Map<String, Object> saveValues(Map<String, Object> context, String [] saveKeyNames) {
        Map<String, Object> saveMap = FastMap.newInstance();
        for (String key: saveKeyNames) {
            Object o = context.get(key);
            if (o instanceof Map<?, ?>) {
                o = UtilMisc.makeMapWritable(UtilGenerics.checkMap(o));
            } else if (o instanceof List<?>) {
                o = UtilMisc.makeListWritable(UtilGenerics.checkList(o));
            }
            saveMap.put(key, o);
        }
        return saveMap;
    }


    public static void reloadValues(Map<String, Object> context, Map<String, Object> saveValues, Environment env) {
        for (Map.Entry<String, Object> entry: saveValues.entrySet()) {
            String key = entry.getKey();
            Object o = entry.getValue();
            if (o instanceof Map<?, ?>) {
                context.put(key, UtilMisc.makeMapWritable(UtilGenerics.checkMap(o)));
            } else if (o instanceof List<?>) {
                List<Object> list = new ArrayList<Object>();
                list.addAll(UtilGenerics.checkList(o));
                context.put(key, list);
            } else {
                context.put(key, o);
            }
            env.setVariable(key, autoWrap(o, env));
        }
    }

    public static void removeValues(Map<String, ?> context, String... removeKeyNames) {
        for (String key: removeKeyNames) {
            context.remove(key);
        }
    }

    public static void overrideWithArgs(Map<String, Object> ctx, Map<String, Object> args) {
        for (Map.Entry<String, Object> entry: args.entrySet()) {
            String key = entry.getKey();
            Object obj = entry.getValue();
            //if (Debug.infoOn()) Debug.logInfo("in overrideWithArgs, key(3):" + key + " obj:" + obj + " class:" + obj.getClass().getName() , module);
            if (obj != null) {
                if (obj == TemplateModel.NOTHING) {
                    ctx.put(key, null);
                } else {
                    Object unwrappedObj = unwrap(obj);
                    if (unwrappedObj == null) {
                        unwrappedObj = obj;
                    }
                    ctx.put(key, unwrappedObj.toString());
                }
            } else {
                ctx.put(key, null);
            }
        }
    }

    public static void convertContext(Map<String, Object> ctx) {
        for (Map.Entry<String, Object> entry: ctx.entrySet()) {
            Object obj = entry.getValue();
            if (obj != null) {
                Object unwrappedObj = unwrap(obj);
                if (unwrappedObj != null) {
                    entry.setValue(unwrappedObj);
                }
            }
        }
    }

    public static void getSiteParameters(HttpServletRequest request, Map<String, Object> ctx) {
        if (request == null) {
            return;
        }
        if (ctx == null) {
            throw new IllegalArgumentException("Error in getSiteParameters, context/ctx cannot be null");
        }
        ServletContext servletContext = request.getSession().getServletContext();
        String rootDir = (String)ctx.get("rootDir");
        String webSiteId = (String)ctx.get("webSiteId");
        String https = (String)ctx.get("https");
        if (UtilValidate.isEmpty(rootDir)) {
            rootDir = servletContext.getRealPath("/");
            ctx.put("rootDir", rootDir);
        }
        if (UtilValidate.isEmpty(webSiteId)) {
            webSiteId = (String) servletContext.getAttribute("webSiteId");
            ctx.put("webSiteId", webSiteId);
        }
        if (UtilValidate.isEmpty(https)) {
            https = (String) servletContext.getAttribute("https");
            ctx.put("https", https);
        }
    }

    public static TemplateModel autoWrap(Object obj, Environment env) {
       BeansWrapper wrapper = BeansWrapper.getDefaultInstance();
       TemplateModel templateModelObj = null;
       try {
           templateModelObj = wrapper.wrap(obj);
       } catch (TemplateModelException e) {
           throw new RuntimeException(e.getMessage());
       }
       return templateModelObj;
    }

    /**
     * OFBiz Template Source. This class is used by FlexibleTemplateLoader.
     */
    static class FlexibleTemplateSource {
        protected String templateLocation = null;
        protected Date createdDate = new Date();

        protected FlexibleTemplateSource() {}
        public FlexibleTemplateSource(String templateLocation) {
            this.templateLocation = templateLocation;
        }

        @Override
        public int hashCode() {
            return templateLocation.hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            return obj instanceof FlexibleTemplateSource && obj.hashCode() == this.hashCode();
        }

        public String getTemplateLocation() {
            return templateLocation;
        }

        public long getLastModified() {
            return createdDate.getTime();
        }
    }

    /**
     * OFBiz Template Loader. This template loader uses the FlexibleLocation
     * class to locate and load Freemarker templates.
     */
    static class FlexibleTemplateLoader implements TemplateLoader {
        public Object findTemplateSource(String name) throws IOException {
            return new FlexibleTemplateSource(name);
        }

        public long getLastModified(Object templateSource) {
            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;
            return fts.getLastModified();
        }

        public Reader getReader(Object templateSource, String encoding) throws IOException {
            FlexibleTemplateSource fts = (FlexibleTemplateSource) templateSource;
            return makeReader(fts.getTemplateLocation());
        }

        public void closeTemplateSource(Object templateSource) throws IOException {
            // do nothing
        }
    }

    /**
     * OFBiz specific TemplateExceptionHandler.  Sanitizes any error messages present in
     * the stack trace prior to printing to the output writer.
     */
    static class OFBizTemplateExceptionHandler implements TemplateExceptionHandler {
        public void handleTemplateException(TemplateException te, Environment env, Writer out) throws TemplateException {
            StringWriter tempWriter = new StringWriter();
            PrintWriter pw = new PrintWriter(tempWriter, true);
            te.printStackTrace(pw);
            String stackTrace = tempWriter.toString();

            StringUtil.SimpleEncoder simpleEncoder = FreeMarkerWorker.getWrappedObject("simpleEncoder", env);
            if (simpleEncoder != null) {
                stackTrace = simpleEncoder.encode(stackTrace);
            }
            try {
                out.write(stackTrace);
            } catch (IOException e) {
                Debug.logError(e, module);
            }
        }
    }

    public static String encodeDoubleQuotes(String htmlString) {
        return htmlString.replaceAll("\"", "\\\\\"");
    }
}
```


Overlapping Code:
```
ublic static final String module = FreeMarkerWorker.class.getName();
// use soft references for this so that things from Content records don't kill all of our memory, or maybe not for performance reasons... hmmm, leave to config file...
public static UtilCache<String, Template> cachedTemplates = UtilCache.createUtilCache("template.ftl.general", 0, 0, false);
protected static BeansWrapper defaultOfbizWrapper = BeansWrapper.getDefaultInstance();
protected static Configuration defaultOfbizConfig = makeConfiguration(defaultOfbizWrapper);
public static Configuration makeConfiguration(BeansWrapper wrapper) {
Configuration newConfig = new Configuration();
newConfig.setObjectWrapper(wrapper);
newConfig.setSharedVariable("Static", wrapper.getStaticModels());
newConfig.setLocalizedLookup(false);
newConfig.setSharedVariable("StringUtil", new BeanModel(StringUtil.INSTANCE, wrapper));
newConfig.setTemplateLoader(new FlexibleTemplateLoader());
newConfig.setAutoImports(UtilProperties.getProperties("freemarkerImports"));
newConfig.setTemplateExceptionHandler(new FreeMarkerWorker.OFBizTemplateExceptionHandler());
try {
newConfig.setSetting("datetime_format", "yyyy-MM-dd HH:mm:ss.SSS");
newConfig.setSetting("number_format", "0.##########");
} catch (TemplateException e) {
Debug.logError("Unable to set date/time and number formats in FreeMarker: " + e, module);
}
// Transforms properties file set up as key=transform name, property=transform class name
ClassLoader loader = Thread.currentThread().getContextClassLoader();
Enumeration<URL> resources;
try {
resources = loader.getResources("freemarkerTransforms.properties");
} catch (IOException e) {
Debug.logError(e, "Could not load list of freemarkerTransforms.properties", module);
throw UtilMisc.initCause(new InternalError(e.getMessage()), e);
}
while (resources.hasMoreElements()) {
URL propertyURL = resources.nextElement();
Debug.logInfo("loading properties: " + propertyURL, module);
Properties props = UtilProperties.getProperties(propertyURL);
if (props == null || props.isEmpty()) {
Debug.logError("Unable to locate properties file " + propertyURL, module);
```
<Overlap Ratio: 0.9806004618937645>

---

--- 343 --
Question ID: 57ef1a5cc41115a5e70502cc466a8290ba6f2d1b
Original Code:
```
@Test(groups = "live", testName = "DatabaseApiLiveTest")
public class DatabaseApiLiveTest extends BaseTroveApiLiveTest {

   // region to instance
   private static Map<String, List<Instance>> instancesToDelete = Maps.newHashMap();
   // not deleting databases. they will be deleted when instances are deleted

   @Override
   @BeforeClass(groups = { "integration", "live" })
   public void setup() {
      super.setup();
      TroveUtils utils = new TroveUtils(api);
      for (String region : api.getConfiguredRegions()) {
         // create instances
         List<Instance> instanceList = Lists.newArrayList();
         Instance first = utils.getWorkingInstance(region, "first_database_testing_" + region, "1", 1);
         Instance second = utils.getWorkingInstance(region, "second_database_testing_" + region, "1", 1);
         instanceList.add(first);
         instanceList.add(second);
         instancesToDelete.put(region, instanceList);

         DatabaseApi databaseApiFirst = api.getDatabaseApi(region, first.getId());
         DatabaseApi databaseApiSecond = api.getDatabaseApi(region, second.getId());
         databaseApiFirst.create("livetest_db1");
         databaseApiFirst.create("livetest_db2");
         databaseApiSecond.create("livetest_db3");
      }
   }

   @Override
   @AfterClass(groups = { "integration", "live" })
   public void tearDown(){
      for (String region : api.getConfiguredRegions()) {
         InstanceApi instanceApi = api.getInstanceApi(region);
         for (Instance instance : instancesToDelete.get(region)) {
            if (!instanceApi.delete(instance.getId()))
               throw new RuntimeException("Could not delete a database instance after tests!");
         }
      }
      super.tearDown();
   }

   @Test
   public void testListDatabases() {
      for (String region : api.getConfiguredRegions()) {
         InstanceApi instanceApi = api.getInstanceApi(region);
         assertTrue(instanceApi.list().size() >= 2);
         for (Instance instance : instancesToDelete.get(region)) {
            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());
            if (!instance.getName().contains("database_testing"))
               continue;
            assertTrue(databaseApi.list().size() >= 1);
            for (String database : databaseApi.list()) {
               assertNotNull(database);
            }
         }
      }
   }

   @Test
   public void testDeleteDatabases() {
      for (String region : api.getConfiguredRegions()) {
         InstanceApi instanceApi = api.getInstanceApi(region);
         assertTrue(instanceApi.list().size() >= 2);
         for (Instance instance : instancesToDelete.get(region)) {
            DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());
            if (!instance.getName().contains("database_testing"))
               continue;
            assertTrue(databaseApi.list().size() >= 1);
            for (String database : databaseApi.list()) {
               assertNotNull(database);
               assertTrue(database.equals("livetest_db1") || database.equals("livetest_db2") || database.equals("livetest_db3") );
               assertTrue(databaseApi.delete(database));
               assertTrue(databaseApi.create(database));
            }
         }
      }
   }
}
```


Overlapping Code:
```
e = "DatabaseApiLiveTest")
public class DatabaseApiLiveTest extends BaseTroveApiLiveTest {
// region to instance
private static Map<String, List<Instance>> instancesToDelete = Maps.newHashMap();
// not deleting databases. they will be deleted when instances are deleted
@Override
@BeforeClass(groups = { "integration", "live" })
public void setup() {
super.setup();
TroveUtils utils = new TroveUtils(api);
for (String region : api.getConfiguredRegions()) {
// create instances
List<Instance> instanceList = Lists.newArrayList();
Instance first = utils.getWorkingInstance(region, "first_database_testing_" + region, "1", 1);
Instance second = utils.getWorkingInstance(region, "second_database_testing_" + region, "1", 1);
instanceList.add(first);
instanceList.add(second);
instancesToDelete.put(region, instanceList);
DatabaseApi databaseApiFirst = api.getDatabaseApi(region, first.getId());
DatabaseApi databaseApiSecond = api.getDatabaseApi(region, second.getId());
databaseApiFirst.create("livetest_db1");
databaseApiFirst.create("livetest_db2");
databaseApiSecond.create("livetest_db3");
}
}
@Override
@AfterClass(groups = { "integration", "live" })
public void tearDown(){
for (String region : api.getConfiguredRegions()) {
InstanceApi instanceApi = api.getInstanceApi(region);
for (Instance instance : instancesToDelete.get(region)) {
if (!instanceApi.delete(instance.getId()))
throw new RuntimeException("Could not delete a database instance after tests!");
}
}
super.tearDown();
}
@Test
public void testListDatabases() {
for (String region : api.getConfiguredRegions()) {
InstanceApi instanceApi = api.getInstanceApi(region);
assertTrue(instanceApi.list().size() >= 2);
for (Instance instance : instancesToDelete.get(region)) {
DatabaseApi databaseApi = api.getDatabaseApi(region, instance.getId());
if (!instance.getName().contains("database_testing"))
continue;
assertTrue(databaseApi.list().size() >= 1);
for (String database : databaseApi.list()) {
assertNotNull(database);
}
}
}
}
@Test
public void testDeleteDatabases() {
for (String reg
```
<Overlap Ratio: 0.977587029089175>

---

--- 344 --
Question ID: 189f9552921978485e4ef4fa5e5b0fb81850746b
Original Code:
```
public class SidebarRenderer {

  public static final String NUTRITION_INFO_NAME = "Limit Nutrition (per serving)";

  private static final SearchResult EMPTY_SEARCH_RESULT = new SearchResult.Builder().build();
  private static final RangedSpec UNSELECTED_RANGE = RangedSpec.of(0, 0);
  private static final DietSpec UNSELECTED_DIET = DietSpec.of("NONE", 1F);

  private static final FacetData EMPTY_FACET_DATA =
      new FacetData.Builder().dimension("EMPTY").build();

  public SidebarRenderer() {}

  public SidebarInfo render(SearchQuery query, UriComponentsBuilder uriBuilder) {
    return render(query, EMPTY_SEARCH_RESULT, uriBuilder);
  }

  public SidebarInfo render(
      SearchQuery query, SearchResult result, UriComponentsBuilder uriBuilder) {
    var builder = new SidebarInfo.Builder();

    var sort = new FilterInfo.Builder().name(Category.SORT.getTitle()).isRemovable(false);
    addCategoryOptions(sort, Category.SORT, query.sort(), result, uriBuilder);
    builder.addFilters(sort.build());

    var hasFacetData = !result.facets().isEmpty();

    var diet = new FilterInfo.Builder().name(Category.DIET.getTitle());
    addCategoryOptions(
        diet, Category.DIET, query.diet().orElse(UNSELECTED_DIET), result, uriBuilder);
    diet.showCounts(hasFacetData && query.diet().isEmpty());
    builder.addFilters(diet.build());

    var numIngredient = new FilterInfo.Builder().name(Category.NUM_INGREDIENT.getTitle());
    addCategoryOptions(
        numIngredient,
        Category.NUM_INGREDIENT,
        query.numIngredients().orElse(UNSELECTED_RANGE),
        result,
        uriBuilder);
    numIngredient.showCounts(hasFacetData && query.numIngredients().isEmpty());
    builder.addFilters(numIngredient.build());

    var totalTime =
        new FilterInfo.Builder().name(Category.TOTAL_TIME.getTitle()).showCounts(hasFacetData);
    addCategoryOptions(
        totalTime,
        Category.TOTAL_TIME,
        query.totalTime().orElse(UNSELECTED_RANGE),
        result,
        uriBuilder);
    totalTime.showCounts(hasFacetData && query.totalTime().isEmpty());
    builder.addFilters(totalTime.build());

    var nutrition = new FilterInfo.Builder().name(NUTRITION_INFO_NAME).showCounts(hasFacetData);
    addCategoryOptions(
        nutrition,
        Category.CALORIES,
        query.calories().orElse(UNSELECTED_RANGE),
        result,
        uriBuilder);
    addCategoryOptions(
        nutrition,
        Category.FAT_CONTENT,
        query.fatContent().orElse(UNSELECTED_RANGE),
        result,
        uriBuilder);
    addCategoryOptions(
        nutrition,
        Category.CARB_CONTENT,
        query.carbohydrateContent().orElse(UNSELECTED_RANGE),
        result,
        uriBuilder);
    nutrition.showCounts(
        hasFacetData
            && query.calories().isEmpty()
            && query.fatContent().isEmpty()
            && query.carbohydrateContent().isEmpty());
    builder.addFilters(nutrition.build());

    return builder.build();
  }

  private int countLabelData(SearchResult result, Category category, CategoryOption label) {
    return result
        .facets()
        .getOrDefault(category.getIndexKey(), EMPTY_FACET_DATA)
        .children()
        .getOrDefault(label.getIndexKey(), 0L)
        .intValue();
  }

  private void addCategoryOptions(
      FilterInfo.Builder infoBuilder,
      Category category,
      Object selected,
      SearchResult result,
      UriComponentsBuilder cloneMe) {

    var uriBuilder = cloneMe.cloneBuilder();

    category
        .getOptions()
        .forEach(
            opt -> {
              var isActive = opt.isActive(selected);

              if (isActive) {
                uriBuilder.replaceQueryParam(category.getIndexKey());
              } else {
                uriBuilder.replaceQueryParam(category.getIndexKey(), opt.getIndexKey());
              }

              var filterOption =
                  new FilterInfo.FilterOption.Builder()
                      .name(opt.getTitle())
                      .count(countLabelData(result, category, opt))
                      .isActive(isActive)
                      .href(uriBuilder.build().toUriString())
                      .build();

              infoBuilder.addOptions(filterOption);
            });
  }
}
```


Overlapping Code:
```
tic final String NUTRITION_INFO_NAME = "Limit Nutrition (per serving)";
private static final SearchResult EMPTY_SEARCH_RESULT = new SearchResult.Builder().build();
private static final RangedSpec UNSELECTED_RANGE = RangedSpec.of(0, 0);
private static final DietSpec UNSELECTED_DIET = DietSpec.of("NONE", 1F);
private static final FacetData EMPTY_FACET_DATA =
new FacetData.Builder().dimension("EMPTY").build();
public SidebarRenderer() {}
public SidebarInfo render(SearchQuery query, UriComponentsBuilder uriBuilder) {
return render(query, EMPTY_SEARCH_RESULT, uriBuilder);
}
public SidebarInfo render(
SearchQuery query, SearchResult result, UriComponentsBuilder uriBuilder) {
var builder = new SidebarInfo.Builder();
var sort = new FilterInfo.Builder().name(Category.SORT.getTitle()).isRemovable(false);
addCategoryOptions(sort, Category.SORT, query.sort(), result, uriBuilder);
builder.addFilters(sort.build());
var hasFacetData = !result.facets().isEmpty();
var diet = new FilterInfo.Builder().name(Category.DIET.getTitle());
addCategoryOptions(
diet, Category.DIET, query.diet().orElse(UNSELECTED_DIET), result, uriBuilder);
diet.showCounts(hasFacetData && query.diet().isEmpty());
builder.addFilters(diet.build());
var numIngredient = new FilterInfo.Builder().name(Category.NUM_INGREDIENT.getTitle());
addCategoryOptions(
numIngredient,
Category.NUM_INGREDIENT,
query.numIngredients().orElse(UNSELECTED_RANGE),
result,
uriBuilder);
numIngredient.showCounts(hasFacetData && query.numIngredients().isEmpty());
builder.addFilters(numIngredient.build());
var totalTime =
new FilterInfo.Builder().name(Category.TOTAL_TIME.getTitle()).showCounts(hasFacetData);
addCategoryOptions(
totalTime,
Category.TOTAL_TIME,
query.totalTime().orElse(UNSELECTED_RANGE),
result,
uriBuilder);
totalTime.showCounts(hasFacetData && query.totalTime().isEmpty());
builder.addFilters(totalTime.build());
var nutrition = new FilterInfo.Builder().name(NUTRITION_INFO_NAME).showCounts(hasFacetData);
addCategoryOptions(
nutrition,
Category.CALORIES,
query.calories().orElse(UNSELECTED_RANGE),
result,
uriBuilder);
addCategoryOptions(
nutrition,
Category.FAT_CONTENT,
query.
```
<Overlap Ratio: 0.9715318572074108>

---

--- 345 --
Question ID: 91d4c7887eaa04d2f2f99ee2b5f3879a0f7f6a30
Original Code:
```
public class EL3204_2 extends Slave {
    static final long vendorID = 0x00000002L;
    static final long productCode = 0x0c843052;

    public class Input extends TxPDO {
        protected Input(int address) {
            super(address);
        }

        Bool underrange = new Bool();
        Bool overrange = new Bool();
        Member limit1 = new Bit2();
        Member limit2 = new Bit2();
        Bool error = new Bool();
        Bit7 gap = new Bit7();
        Bool txPDOState = new Bool();
        Bool txPDOToggle = new Bool();
        Signed16 value = new Signed16();
    }

    private final Input temperatureOverheatedGas = new Input(0x1a00);
    private final Input temperatureSwitchOnSensor = new Input(0x1a01);
    private final Input temperatureReserve1 = new Input(0x1a02);
    private final Input temperatureReserve2 = new Input(0x1a03);


    public EL3204_2(int aliasAddress, int configAddress) {
        super(vendorID, productCode, aliasAddress, configAddress);

        registerSyncManager(new SyncManager(2, false));
        registerSyncManager(new SyncManager(3, false));

        sm(3).registerPDO(temperatureOverheatedGas);
        sm(3).registerPDO(temperatureSwitchOnSensor);
        sm(3).registerPDO(temperatureReserve1);
        sm(3).registerPDO(temperatureReserve2);
    }

    @Override
    protected void configure(boolean dcEnabled, long cycleTimeInNs) {
        // Configure PT1000
        writeSDO(32768, 25, (short) 2);
        writeSDO(32784, 25, (short) 2);
        writeSDO(32800, 25, (short) 2);
        writeSDO(32816, 25, (short) 2);
    }


    public float getTemperatureSwitchOnSensor() {
        return convert(temperatureSwitchOnSensor.value.get());
    }

    public boolean getTemperatureSwitchOnSensorUnderrange() {
        return temperatureSwitchOnSensor.underrange.get();
    }

    public boolean getTemperatureSwitchOnSensorOverrange() {
        return temperatureSwitchOnSensor.overrange.get();
    }

    public boolean getTemperatureSwitchOnSensorError() {
        return temperatureSwitchOnSensor.error.get();
    }


    public float getTemperatureOverheatedGas() {
        return convert(temperatureOverheatedGas.value.get());
    }

    public boolean getTemperatureOverheatedGasUnderrange() {
        return temperatureOverheatedGas.underrange.get();
    }

    public boolean getTemperatureOverheatedGasOverrange() {
        return temperatureOverheatedGas.overrange.get();
    }

    public boolean getTemperatureOverheatedGasError() {
        return temperatureOverheatedGas.error.get();
    }


    public float getTemperatureReserve1() {
        return convert(temperatureReserve1.value.get());
    }

    public boolean getTemperatureReserve1Underrange() {
        return temperatureReserve1.underrange.get();
    }

    public boolean getTemperatureReserve1Overrange() {
        return temperatureReserve1.overrange.get();
    }

    public boolean getTemperatureReserve1Error() {
        return temperatureReserve1.error.get();
    }


    public float getTemperatureReserve2() {
        return convert(temperatureReserve2.value.get());
    }

    public boolean getTemperatureReserve2Underrange() {
        return temperatureReserve2.underrange.get();
    }

    public boolean getTemperatureReserve2Overrange() {
        return temperatureReserve2.overrange.get();
    }

    public boolean getTemperatureReserve2Error() {
        return temperatureReserve2.error.get();
    }

    public String toProcessdataString() {
        return new StringJoiner(", ", EL3204_2.class.getSimpleName() + "[", "]")
            .add("TemperatureSwitchOnSensor=" + getTemperatureSwitchOnSensor())
            .add("TemperatureSwitchOnSensorError=" + getTemperatureSwitchOnSensorError())
            .add("TemperatureSwitchOnSensorUnderrange=" + getTemperatureSwitchOnSensorUnderrange())
            .add("TemperatureSwitchOnSensor=Overrange" + getTemperatureSwitchOnSensorOverrange())

            .add("TemperatureOverheatedGas=" + getTemperatureOverheatedGas())
            .add("TemperatureOverheatedGasError=" + getTemperatureOverheatedGasError())
            .add("TemperatureOverheatedGasUnderrange=" + getTemperatureOverheatedGasUnderrange())
            .add("TemperatureOverheatedGas=Overrange" + getTemperatureOverheatedGasOverrange())

            .add("TemperatureReserve1=" + getTemperatureReserve1())
            .add("TemperatureReserve1Error=" + getTemperatureReserve1Error())
            .add("TemperatureReserve1Underrange=" + getTemperatureReserve1Underrange())
            .add("TemperatureReserve1=Overrange" + getTemperatureReserve1Overrange())

            .add("TemperatureReserve2=" + getTemperatureReserve2())
            .add("TemperatureReserve2Error=" + getTemperatureReserve2Error())
            .add("TemperatureReserve2Underrange=" + getTemperatureReserve2Underrange())
            .add("TemperatureReserve2=Overrange" + getTemperatureReserve2Overrange())

            .toString();
    }

    private float convert(short value) {
        return Float.valueOf(value) / 10;
    }


/* Slaveinfo:

7 - 0:6 EL3204
	Manufacturer: 0x00000002
	Product code: 0x0c843052
	Revision: 1114112
	Distributed Clocks: yes
	SM(0) Address: 0x1000, length: 128	Flags: 65574	Type: Mailbox messages receive
	SM(1) Address: 0x1080, length: 128	Flags: 65570	Type: Mailbox messages transmit
	SM(2) Address: 0x1100, length: 0	Flags: 4	Type: Cyclic process data receive
	SM(3) Address: 0x1180, length: 16	Flags: 65568	Type: Cyclic process data transmit
		TxPDO 0x1a00	RTD TxPDO-Map Ch.1
			0x6000:0x01 BOOLEAN	Underrange
			0x6000:0x02 BOOLEAN	Overrange
			0x6000:0x03 BIT2	Limit 1
			0x6000:0x05 BIT2	Limit 2
			0x6000:0x07 BOOLEAN	Error
			0x0000:0x00 (7 bit)
			0x1800:0x07 BOOLEAN	TxPDO State
			0x1800:0x09 BOOLEAN	TxPDO Toggle
			0x6000:0x11 INTEGER16	Value
		TxPDO 0x1a01	RTD TxPDO-Map Ch.2
			0x6010:0x01 BOOLEAN	Underrange
			0x6010:0x02 BOOLEAN	Overrange
			0x6010:0x03 BIT2	Limit 1
			0x6010:0x05 BIT2	Limit 2
			0x6010:0x07 BOOLEAN	Error
			0x0000:0x00 (7 bit)
			0x1801:0x07 BOOLEAN	TxPDO State
			0x1801:0x09 BOOLEAN	TxPDO Toggle
			0x6010:0x11 INTEGER16	Value
		TxPDO 0x1a02	RTD TxPDO-Map Ch.3
			0x6020:0x01 BOOLEAN	Underrange
			0x6020:0x02 BOOLEAN	Overrange
			0x6020:0x03 BIT2	Limit 1
			0x6020:0x05 BIT2	Limit 2
			0x6020:0x07 BOOLEAN	Error
			0x0000:0x00 (7 bit)
			0x1802:0x07 BOOLEAN	TxPDO State
			0x1802:0x09 BOOLEAN	TxPDO Toggle
			0x6020:0x11 INTEGER16	Value
		TxPDO 0x1a03	RTD TxPDO-Map Ch.4
			0x6030:0x01 BOOLEAN	Underrange
			0x6030:0x02 BOOLEAN	Overrange
			0x6030:0x03 BIT2	Limit 1
			0x6030:0x05 BIT2	Limit 2
			0x6030:0x07 BOOLEAN	Error
			0x0000:0x00 (7 bit)
			0x1803:0x07 BOOLEAN	TxPDO State
			0x1803:0x09 BOOLEAN	TxPDO Toggle
			0x6030:0x11 INTEGER16	Value
7 - 0:6 EL3204
	Manufacturer: 0x00000002
	Product code: 0x0c843052
	Revision: 1114112
	Distributed Clocks: yes
	SM(0) Address: 0x1000, length: 128	Flags: 65574	Type: Mailbox messages receive
	SM(1) Address: 0x1080, length: 128	Flags: 65570	Type: Mailbox messages transmit
	SM(2) Address: 0x1100, length: 0	Flags: 4	Type: Cyclic process data receive
	SM(3) Address: 0x1180, length: 16	Flags: 65568	Type: Cyclic process data transmit

 */

}
```


Overlapping Code:
```
ss EL3204_2 extends Slave {
static final long vendorID = 0x00000002L;
static final long productCode = 0x0c843052;
public class Input extends TxPDO {
protected Input(int address) {
super(address);
}
Bool underrange = new Bool();
Bool overrange = new Bool();
Member limit1 = new Bit2();
Member limit2 = new Bit2();
Bool error = new Bool();
Bit7 gap = new Bit7();
Bool txPDOState = new Bool();
Bool txPDOToggle = new Bool();
Signed16 value = new Signed16();
}
private final Input temperatureOverheatedGas = new Input(0x1a00);
private final Input temperatureSwitchOnSensor = new Input(0x1a01);
private final Input temperatureReserve1 = new Input(0x1a02);
private final Input temperatureReserve2 = new Input(0x1a03);
public EL3204_2(int aliasAddress, int configAddress) {
super(vendorID, productCode, aliasAddress, configAddress);
registerSyncManager(new SyncManager(2, false));
registerSyncManager(new SyncManager(3, false));
sm(3).registerPDO(temperatureOverheatedGas);
sm(3).registerPDO(temperatureSwitchOnSensor);
sm(3).registerPDO(temperatureReserve1);
sm(3).registerPDO(temperatureReserve2);
}
@Override
protected void configure(boolean dcEnabled, long cycleTimeInNs) {
// Configure PT1000
writeSDO(32768, 25, (short) 2);
writeSDO(32784, 25, (short) 2);
writeSDO(32800, 25, (short) 2);
writeSDO(32816, 25, (short) 2);
}
public float getTemperatureSwitchOnSensor() {
return convert(temperatureSwitchOnSensor.value.get());
}
public boolean getTemperatureSwitchOnSensorUnderrange() {
return temperatureSwitchOnSensor.underrange.get();
}
public boolean getTemperatureSwitchOnSensorOverrange() {
return temperatureSwitchOnSensor.overrange.get();
}
public boolean getTemperatureSwitchOnSensorError() {
return temperatureSwitchOnSensor.error.get();
}
public float getTemperatureOverheatedGas() {
return convert(temperatureOverheatedGas.value.get());
}
public boolean getTemperatureOverheatedGasUnderrange() {
return temperatureOverheatedGas.underrange.get();
}
public boolean getTemperatureOverheatedGasOverrange() {
return temperatureOverheatedGas.overrange.get();
}
public boolean getTemperatureOverheate
```
<Overlap Ratio: 0.9919697685403873>

---

--- 346 --
Question ID: bae171a517c0c1b291893b423f8e3500bf5160cd
Original Code:
```
public class FeedbackPresenterImpl implements FeedbackPresenter,
        FeedbackDataModel.OnFinishedPresenterListener, FeedbackDataModel.OnSubmitFeedbackPresenterListener,
        FeedbackDataModel.HasUserSubmittedAFeedbackPresenterListener
{

    private FeedbackView feedbackView;
    private FeedbackDataModel feedbackDataModel;

    public FeedbackPresenterImpl(FeedbackView feedbackActivity, FeedbackDataModel feedbackDataModel) {
        this.feedbackView = feedbackActivity;
        this.feedbackDataModel = feedbackDataModel;
    }

    @Override
    public void onLoading() {
        feedbackDataModel.hasUserSubmittedAFeedback(this);
    }

    @Override
    public void onHasUserSubmittedFeedback() {
        feedbackView.installFeedbackFragment();
    }

    @Override
    public void onHasUserNotSubmittedFeedback() {
        if (feedbackView != null) {
            feedbackView.showProgress();
        }
        feedbackDataModel.getQuestions(this);
    }

    @Override
    public void onDestroy() {
        feedbackView = null;
    }

    @Override
    public void saveState() {
//        Log.e("onDestroy submit", feedbackDataModel.getFeedbackSubmitEntity().getJsonElement().getAsJsonObject().toString());
        feedbackDataModel.setFeedbackResponseFromSharedPreferences(this);
    }

    @Override
    public void restoreState() {
        feedbackDataModel.getFeedbackResponseFromSharedPreferences();
    }

    @Override
    public void submitFeedback() {
        feedbackDataModel.submitFeedback(this);
    }

    @Override
    public void onClickChangeFeedbackResponse() {
        feedbackView.uninstallFeedbackFragment();
        if (feedbackView != null) {
            feedbackView.showProgress();
        }
        feedbackDataModel.getQuestions(this);
    }

    @Override
    public void onFinished(List<FeedbackQuestionEntity> items) {
        if (feedbackView != null) {
            Log.e("onFinished", "onFinished: " + items.toString());
//            feedbackView.hideProgress();
            feedbackView.setItems(items, feedbackDataModel.getFeedbackSubmitEntity(items));
        }
    }

    @Override
    public void onSubmit() {
        feedbackView.showMessageForSubmittedFeedback("Thank you for your feedback!");
    }

    @Override
    public void onFailed() {
        feedbackView.showMessageForErrorOnSubmit("Fields with marks(*) are required.");
    }
}
```


Overlapping Code:
```
lic class FeedbackPresenterImpl implements FeedbackPresenter,
FeedbackDataModel.OnFinishedPresenterListener, FeedbackDataModel.OnSubmitFeedbackPresenterListener,
FeedbackDataModel.HasUserSubmittedAFeedbackPresenterListener
{
private FeedbackView feedbackView;
private FeedbackDataModel feedbackDataModel;
public FeedbackPresenterImpl(FeedbackView feedbackActivity, FeedbackDataModel feedbackDataModel) {
this.feedbackView = feedbackActivity;
this.feedbackDataModel = feedbackDataModel;
}
@Override
public void onLoading() {
feedbackDataModel.hasUserSubmittedAFeedback(this);
}
@Override
public void onHasUserSubmittedFeedback() {
feedbackView.installFeedbackFragment();
}
@Override
public void onHasUserNotSubmittedFeedback() {
if (feedbackView != null) {
feedbackView.showProgress();
}
feedbackDataModel.getQuestions(this);
}
@Override
public void onDestroy() {
feedbackView = null;
}
@Override
public void saveState() {
// Log.e("onDestroy submit", feedbackDataModel.getFeedbackSubmitEntity().getJsonElement().getAsJsonObject().toString());
feedbackDataModel.setFeedbackResponseFromSharedPreferences(this);
}
@Override
public void restoreState() {
feedbackDataModel.getFeedbackResponseFromSharedPreferences();
}
@Override
public void submitFeedback() {
feedbackDataModel.submitFeedback(this);
}
@Override
public void onClickChangeFeedbackResponse() {
feedbackView.uninstallFeedbackFragment();
if (feedbackView != null) {
feedbackView.showProgress();
}
feedbackDataModel.getQuestions(this);
}
@Override
public void onFinished(List<FeedbackQuestionEntity> items) {
if (feedbackView != null) {
Log.e("onFinished", "onFinished: " + items.toString());
// feedbackView.hideProgress();
feedbackView.setItems(items, feedbackDataModel.getFeedbackSubmitEntity(items));
}
}
@Override
public void onSubmit() {
feedbackView.showMessageForSubmittedFeedback("Thank you for your feedback!");
}
@Override
public void onFailed() {
feedbackView.showMessageForErrorOnS
```
<Overlap Ratio: 0.974512743628186>

---

--- 347 --
Question ID: c711523dc51490f2eb9f0fe8625de27870a40a32
Original Code:
```
@Parcel // annotation indicates class is Parcelable
public class Tweet {

    // list out the attributes
    public String body;
    public long uid; // database ID for the tweet
    public User user;
    public String createdAt;
    public boolean favorited;
    public boolean retweeted;
    public String mediaUrl;
    public int favoriteCount;
    public int retweetCount;
    public int replyCount;

    // deserialize the JSON
    public static Tweet fromJSON(JSONObject jsonObject) throws JSONException {
        Tweet tweet = new Tweet();

        // extract the values from JSON
        tweet.body = jsonObject.getString("text");
        tweet.uid = jsonObject.getLong("id");
        tweet.createdAt = getRelativeTimeAgo(jsonObject.getString("created_at"));
        tweet.user = User.fromJSON(jsonObject.getJSONObject("user"));
        tweet.favorited = jsonObject.getBoolean("favorited");
        tweet.retweeted = jsonObject.getBoolean("retweeted");
        if (jsonObject.has("favorite_count")) {
            tweet.favoriteCount = jsonObject.getInt("favorite_count");
        }
        if (jsonObject.has("retweet_count")) {
            tweet.retweetCount = jsonObject.getInt("retweet_count");
        }
        // This object is only available with the Premium and Enterprise tier products.
        if (jsonObject.has("reply_count")) {
            tweet.replyCount = jsonObject.getInt("reply_count");
        }

        JSONObject entities = jsonObject.getJSONObject("entities");
        // check if there is media
        if (entities.has("media")) {
            // extract media url from the first image entity
            tweet.mediaUrl = entities.getJSONArray("media").getJSONObject(0)
                    .getString("media_url_https");
        }

        return tweet;
    }

    // getRelativeTimeAgo("Mon Apr 01 21:16:23 +0000 2014");
    public static String getRelativeTimeAgo(String rawJsonDate) {
        String twitterFormat = "EEE MMM dd HH:mm:ss ZZZZZ yyyy";
        SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);
        sf.setLenient(true);

        String relativeDate = "";
        try {
            long dateMillis = sf.parse(rawJsonDate).getTime();
            relativeDate = DateUtils.getRelativeTimeSpanString(dateMillis,
                    System.currentTimeMillis(), DateUtils.SECOND_IN_MILLIS).toString();
        } catch (ParseException e) {
            e.printStackTrace();
        }

        return relativeDate;
    }

    public void setFavorited(boolean favorited) {
        this.favorited = favorited;
    }

    public void setRetweeted(boolean retweeted) {
        this.retweeted = retweeted;
    }
}
```


Overlapping Code:
```
el // annotation indicates class is Parcelable
public class Tweet {
// list out the attributes
public String body;
public long uid; // database ID for the tweet
public User user;
public String createdAt;
public boolean favorited;
public boolean retweeted;
public String mediaUrl;
public int favoriteCount;
public int retweetCount;
public int replyCount;
// deserialize the JSON
public static Tweet fromJSON(JSONObject jsonObject) throws JSONException {
Tweet tweet = new Tweet();
// extract the values from JSON
tweet.body = jsonObject.getString("text");
tweet.uid = jsonObject.getLong("id");
tweet.createdAt = getRelativeTimeAgo(jsonObject.getString("created_at"));
tweet.user = User.fromJSON(jsonObject.getJSONObject("user"));
tweet.favorited = jsonObject.getBoolean("favorited");
tweet.retweeted = jsonObject.getBoolean("retweeted");
if (jsonObject.has("favorite_count")) {
tweet.favoriteCount = jsonObject.getInt("favorite_count");
}
if (jsonObject.has("retweet_count")) {
tweet.retweetCount = jsonObject.getInt("retweet_count");
}
// This object is only available with the Premium and Enterprise tier products.
if (jsonObject.has("reply_count")) {
tweet.replyCount = jsonObject.getInt("reply_count");
}
JSONObject entities = jsonObject.getJSONObject("entities");
// check if there is media
if (entities.has("media")) {
// extract media url from the first image entity
tweet.mediaUrl = entities.getJSONArray("media").getJSONObject(0)
.getString("media_url_https");
}
return tweet;
}
// getRelativeTimeAgo("Mon Apr 01 21:16:23 +0000 2014");
public static String getRelativeTimeAgo(String rawJsonDate) {
String twitterFormat = "EEE MMM dd HH:mm:ss ZZZZZ yyyy";
SimpleDateFormat sf = new SimpleDateFormat(twitterFormat, Locale.ENGLISH);
sf.setLenient(true);
String relativeDate = "";
try {
long dateMillis = sf.parse(rawJsonDate).getTime();
relativeDate = DateUtils.getRelativeTimeSpanString(dateMillis,
System.currentTimeMillis(), DateUtils.SECOND_IN_MILLIS).toString();
} catch (ParseException e) {
e.printStackTrace();
}
return relativeDate;
}
publi
```
<Overlap Ratio: 0.9975704567541303>

---

--- 348 --
Question ID: 62a3871cbd1b202556754083c0141c839d45bc5c
Original Code:
```
public class BenchmarkTask implements
        ParallelTaskRunner.TaskWithException<VariantAnnotation, Pair<VariantAnnotationDiff, VariantAnnotationDiff>, Exception> {

    private FastaIndexManager fastaIndexManager;
    private static final String VARIANT_STRING_PATTERN = "[ACGT]*";
//    private static final String VARIANT_STRING_PATTERN = "([ACGT]*)|(<CNV>)|(<INV>)|(<DEL>)|(<INS>)|(<DUP:TANDEM>)";
    private VariantAnnotator variantAnnotator;

    public BenchmarkTask(VariantAnnotator variantAnnotator, FastaIndexManager fastaIndexManager) {
        this.variantAnnotator = variantAnnotator;
        this.fastaIndexManager = fastaIndexManager;
    }

    public void pre() {
        variantAnnotator.open();
    }

    public List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> apply(List<VariantAnnotation> batch)
            throws Exception {
        // VEP format does not include the reference allele. It's needed for the benchmark if the cache is activated -
        // otherwise VariantAnnotationCalculator wont find most of the variants in the variation collection
        fixReference(batch);
        removeInvalidVariants(batch);
        List<Variant> cellBaseBatch = createEmptyVariantList(batch);
        variantAnnotator.run(cellBaseBatch);
        List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> comparisonResultList = new ArrayList<>();
        for (int i = 0; i < batch.size(); i++) {
            // Variants such as MT:453:TTT:ATT are skipped for the benchmark - will not have CellBase annotation
            // compatible with VEP annotation and therefore consequenceTypeList = null
            if (batch.get(i).getConsequenceTypes() != null && batch.get(i).getConsequenceTypes().size() > 0
                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes() != null
                    && cellBaseBatch.get(i).getAnnotation().getConsequenceTypes().size() > 0) {
                Pair<VariantAnnotationDiff, VariantAnnotationDiff> comparisonResult = compare(batch.get(i),
                        cellBaseBatch.get(i).getAnnotation());
                comparisonResult.getLeft().setVariantAnnotation(batch.get(i));
                comparisonResult.getRight().setVariantAnnotation(cellBaseBatch.get(i).getAnnotation());
                comparisonResultList.add(comparisonResult);
            }
        }
        return comparisonResultList;
    }

    private void fixReference(List<VariantAnnotation> variantAnnotationList) throws RocksDBException {
        for (VariantAnnotation variantAnnotation : variantAnnotationList) {
            if (!variantAnnotation.getReference().isEmpty() && !variantAnnotation.getReference().equals("-")) {
                variantAnnotation.setReference(fastaIndexManager.query(variantAnnotation.getChromosome(),
                        variantAnnotation.getStart(), variantAnnotation.getStart()
                                + variantAnnotation.getReference().length() - 1));
            }
        }
    }

    private void removeInvalidVariants(List<VariantAnnotation> variantAnnotationList) {
        int i = 0;
        while (i < variantAnnotationList.size()) {
            if (isValid(variantAnnotationList.get(i))) {
                i++;
            } else {
                variantAnnotationList.remove(i);
            }
        }
    }

    /**
     * Checks whether a variant is valid.
     *
     * @param variantAnnotation Variant object to be checked.
     * @return   true/false depending on whether 'variant' does contain valid values. Currently just a simple check of
     * reference/alternate attributes being strings of [A,C,G,T] of length >= 0 is performed to detect cases such as
     * 19:13318673:(CAG)4:(CAG)5 which are not currently supported by CellBase. Ref and alt alleles must be different
     * as well for the variant to be valid. Functionality of the method may be improved in the future.
     */
    private boolean isValid(VariantAnnotation variantAnnotation) {
        return (variantAnnotation.getAlternate().matches(VARIANT_STRING_PATTERN)
//                && variantAnnotation.getReferenceStart().matches(VARIANT_STRING_PATTERN)
                && !variantAnnotation.getAlternate().equals(variantAnnotation.getReference()));
    }

    private Pair<VariantAnnotationDiff, VariantAnnotationDiff> compare(VariantAnnotation variant1, VariantAnnotation variant2) {
        Pair<VariantAnnotationDiff, VariantAnnotationDiff> result
                = Pair.of(new VariantAnnotationDiff(), new VariantAnnotationDiff());
        compareSequenceOntologyTerms(result, variant1.getConsequenceTypes(),
                variant2.getConsequenceTypes());

        return result;
    }

    private void compareSequenceOntologyTerms(Pair<VariantAnnotationDiff, VariantAnnotationDiff> result,
                                              List<ConsequenceType> consequenceTypeList1,
                                              List<ConsequenceType> consequenceTypeList2) {
        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1 = getSequenceOntologySet(consequenceTypeList1);
        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet2 = getSequenceOntologySet(consequenceTypeList2);
        Set<SequenceOntologyTermComparisonObject> sequenceOntologySet1bak = new HashSet<>(sequenceOntologySet1);
        sequenceOntologySet1.removeAll(sequenceOntologySet2);
        sequenceOntologySet2.removeAll(sequenceOntologySet1bak);
        if (sequenceOntologySet1.size() > 0) {
            result.getLeft().setSequenceOntology(new ArrayList(sequenceOntologySet1));
        }
        if (sequenceOntologySet2.size() > 0) {
            result.getRight().setSequenceOntology(new ArrayList(sequenceOntologySet2));
        }
    }

    private Set<SequenceOntologyTermComparisonObject> getSequenceOntologySet(List<ConsequenceType> consequenceTypeList) {
        if (consequenceTypeList != null) {
            Set<SequenceOntologyTermComparisonObject> set = new HashSet<>(consequenceTypeList.size());
            for (ConsequenceType consequenceType : consequenceTypeList) {
                for (SequenceOntologyTerm sequenceOntologyTerm : consequenceType.getSequenceOntologyTerms()) {
//                    // Expected many differences depending on the regulatory source databases used by the annotators.
//                    // Better skip regulatory_region_variant annotations
//                    if (!(sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.REGULATORY_REGION_VARIANT)
//                            || sequenceOntologyTerm.getName().equals(VariantAnnotationUtils.TF_BINDING_SITE_VARIANT))) {
                    set.add(new SequenceOntologyTermComparisonObject(consequenceType.getEnsemblTranscriptId(),
                            sequenceOntologyTerm));
//                    }
                }
            }

            return set;
        } else {
            return null;
        }
    }

    private List<Variant> createEmptyVariantList(List<VariantAnnotation> variantAnnotationList) {
        List<Variant> newVariantList = new ArrayList<>(variantAnnotationList.size());
        for (VariantAnnotation variantAnnotation : variantAnnotationList) {
            Variant variant = new Variant(variantAnnotation.getChromosome(), variantAnnotation.getStart(),
                    variantAnnotation.getEnd(), variantAnnotation.getReference(), variantAnnotation.getAlternate());
            variant.resetType();
            variant.resetLength();
            newVariantList.add(variant);
        }

        return newVariantList;
    }

    public void post() {
        variantAnnotator.close();
    }
}
```


Overlapping Code:
```
lTaskRunner.TaskWithException<VariantAnnotation, Pair<VariantAnnotationDiff, VariantAnnotationDiff>, Exception> {
private FastaIndexManager fastaIndexManager;
private static final String VARIANT_STRING_PATTERN = "[ACGT]*";
// private static final String VARIANT_STRING_PATTERN = "([ACGT]*)|(<CNV>)|(<INV>)|(<DEL>)|(<INS>)|(<DUP:TANDEM>)";
private VariantAnnotator variantAnnotator;
public BenchmarkTask(VariantAnnotator variantAnnotator, FastaIndexManager fastaIndexManager) {
this.variantAnnotator = variantAnnotator;
this.fastaIndexManager = fastaIndexManager;
}
public void pre() {
variantAnnotator.open();
}
public List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> apply(List<VariantAnnotation> batch)
throws Exception {
// VEP format does not include the reference allele. It's needed for the benchmark if the cache is activated -
// otherwise VariantAnnotationCalculator wont find most of the variants in the variation collection
fixReference(batch);
removeInvalidVariants(batch);
List<Variant> cellBaseBatch = createEmptyVariantList(batch);
variantAnnotator.run(cellBaseBatch);
List<Pair<VariantAnnotationDiff, VariantAnnotationDiff>> comparisonResultList = new ArrayList<>();
for (int i = 0; i < batch.size(); i++) {
// Variants such as MT:453:TTT:ATT are skipped for the benchmark - will not have CellBase annotation
// compatible with VEP annotation and therefore consequenceTypeList = null
if (batch.get(i).getConsequenceTypes() != null && batch.get(i).getConsequenceTypes().size() > 0
&& cellBaseBatch.get(i).getAnnotation().getConsequenceTypes() != null
&& cellBaseBatch.get(i).getAnnotation().getConsequenceTypes().size() > 0) {
Pair<VariantAnnotationDiff, VariantAnnotationDiff> comparisonResult = compare(batch.get(i),
cellBaseBatch.get(i).getAnnotation());
comparisonResult.getLeft().setVariantAnnotation(batch.get(i));
comparisonResult.getRight().setVariantAnnotation(cellBaseBatch.get(i).getAnnotation());
comparisonResultList.add(comparisonResult);
}
}
return comparisonResultList;
}
private void fixReference(List<VariantAnnotation> variantAnnotationList) throws RocksDBEx
```
<Overlap Ratio: 0.9762900976290098>

---

--- 349 --
Question ID: 3fef80058b1052597d0be6af7ff50012a5823b98
Original Code:
```
public class MatrixCheck {
    public boolean mono(boolean[][] data) {
        boolean result = true;
        for (int index1 = 0, index = data.length - 1; index1 < data.length - 1; index1++, index--) {
            if (data[0][data.length - 1] != data[index][index1] || data[0][0] != data[index][index]) {
                result = false;
                break;
            }
        }
        return result;
    }
}
```


Overlapping Code:
```
public class MatrixCheck {
public boolean mono(boolean[][] data) {
boolean result = true;
for (int index1 = 0, index = data.length - 1; index1 < data.length - 1; index1++, index--) {
if (data[0][data.length - 1] != data[index][index1] || data[0][0] != data[index][index]) {
result = false;
break;
}
}
return result;
}
}
```
<Overlap Ratio: 1.0>

---

--- 350 --
Question ID: 6be49d6d1ca1bef57cf943da7f4580df86863d00
Original Code:
```
public class AppsSettingsTests extends InstrumentationTestCase {
    private static final boolean LOCAL_LOGV = false;
    private static final String SETTINGS_PACKAGE = "com.android.settings";
    private static final String TAG = "AboutPhoneSettingsTest";
    private static final int TIMEOUT = 2000;
    private ActivityHelper mActivityHelper = null;

    private UiDevice mDevice;

    private static final String[] sResourceTexts = {
        "Storage",
        "Data usage",
        "Permissions",
        "App notifications",
        "Open by default",
        "Battery",
        "Memory"
    };

    @Override
    public void setUp() throws Exception {
        if (LOCAL_LOGV) {
            Log.d(TAG, "-------");
        }
        super.setUp();
        mDevice = UiDevice.getInstance(getInstrumentation());
        mActivityHelper = ActivityHelper.getInstance();
        try {
            mDevice.setOrientationNatural();
        } catch (RemoteException e) {
            throw new RuntimeException("Failed to freeze device orientaion", e);
        }

        // make sure we are in a clean state before starting the test
        mDevice.pressHome();
        Thread.sleep(TIMEOUT * 2);
        launchAppsSettings();
        UiObject2 view =
                mDevice.wait(
                        Until.findObject(By.text("All apps")), TIMEOUT);
        assertNotNull("Could not find Settings > Apps screen", view);
    }

    @Override
    protected void tearDown() throws Exception {
        mDevice.pressBack();
        mDevice.pressHome(); // finish settings activity
        mDevice.waitForIdle(TIMEOUT * 2); // give UI time to finish animating
        super.tearDown();
    }

    @MediumTest
    public void testAppSettingsListForCalculator() {
        UiObject2 calculator = mDevice.wait(
                Until.findObject(By.text("Calculator")), TIMEOUT);
        calculator.click();
        for (String setting : sResourceTexts) {
            UiObject2 appSetting =
                mDevice.wait(
                        Until.findObject(By.text(setting)), TIMEOUT);
            assertNotNull("Missing setting for Calculator: " + setting, appSetting);
            appSetting.scroll(Direction.DOWN, 10.0f);
        }
    }

    @MediumTest
    public void testDisablingAndEnablingSystemApp() throws Exception {
        launchAppsSettings();
        UiObject2 calculator = mDevice.wait(
                Until.findObject(By.text("Calculator")), TIMEOUT);
        calculator.click();
        mDevice.waitForIdle(TIMEOUT);
        UiObject2 appInfoList = mDevice.wait(
            Until.findObject(By.res(SETTINGS_PACKAGE, "list")), TIMEOUT);
        appInfoList.scroll(Direction.DOWN, 100.0f);
        UiObject2 disableButton = mDevice.wait(
                Until.findObject(By.text("DISABLE")), TIMEOUT);
        disableButton.click();
        mDevice.waitForIdle(TIMEOUT);
        // Click on "Disable App" on dialog.
        mDevice.wait(
                Until.findObject(By.text("DISABLE APP")), TIMEOUT).click();
        mDevice.waitForIdle(TIMEOUT);
        UiObject2 enableButton = mDevice.wait(
                Until.findObject(By.text("ENABLE")), TIMEOUT);
        assertNotNull("App not disabled successfully", enableButton);
        enableButton.click();
        mDevice.waitForIdle(TIMEOUT);
        disableButton = mDevice.wait(
                Until.findObject(By.text("DISABLE")), TIMEOUT);
        assertNotNull("App not enabled successfully", disableButton);
    }

    private void launchAppsSettings() throws Exception {
        Intent appsSettingsIntent = new
                Intent(Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS);
        mActivityHelper.launchIntent(appsSettingsIntent);
    }
}
```


Overlapping Code:
```
gsTests extends InstrumentationTestCase {
private static final boolean LOCAL_LOGV = false;
private static final String SETTINGS_PACKAGE = "com.android.settings";
private static final String TAG = "AboutPhoneSettingsTest";
private static final int TIMEOUT = 2000;
private ActivityHelper mActivityHelper = null;
private UiDevice mDevice;
private static final String[] sResourceTexts = {
"Storage",
"Data usage",
"Permissions",
"App notifications",
"Open by default",
"Battery",
"Memory"
};
@Override
public void setUp() throws Exception {
if (LOCAL_LOGV) {
Log.d(TAG, "-------");
}
super.setUp();
mDevice = UiDevice.getInstance(getInstrumentation());
mActivityHelper = ActivityHelper.getInstance();
try {
mDevice.setOrientationNatural();
} catch (RemoteException e) {
throw new RuntimeException("Failed to freeze device orientaion", e);
}
// make sure we are in a clean state before starting the test
mDevice.pressHome();
Thread.sleep(TIMEOUT * 2);
launchAppsSettings();
UiObject2 view =
mDevice.wait(
Until.findObject(By.text("All apps")), TIMEOUT);
assertNotNull("Could not find Settings > Apps screen", view);
}
@Override
protected void tearDown() throws Exception {
mDevice.pressBack();
mDevice.pressHome(); // finish settings activity
mDevice.waitForIdle(TIMEOUT * 2); // give UI time to finish animating
super.tearDown();
}
@MediumTest
public void testAppSettingsListForCalculator() {
UiObject2 calculator = mDevice.wait(
Until.findObject(By.text("Calculator")), TIMEOUT);
calculator.click();
for (String setting : sResourceTexts) {
UiObject2 appSetting =
mDevice.wait(
Until.findObject(By.text(setting)), TIMEOUT);
assertNotNull("Missing setting for Calculator: " + setting, appSetting);
appSetting.scroll(Direction.DOWN, 10.0f);
}
}
@MediumTest
public void testDisablingAndEnablingSystemApp() throws Exception {
launchAppsSettings();
UiObject2 calculator = mDevice.wait(
Until.findObject(By.text("Cal
```
<Overlap Ratio: 0.9675126903553299>

---

--- 351 --
Question ID: 2d833dc833eddac348d5c214ff30ba3c5d94e2e1
Original Code:
```
public class HostessRoleAndPermissions extends AbstractRoleAndPermissionsFixtureScript {

    public static final String ROLE_NAME = "hostess-role";

    public HostessRoleAndPermissions() {
        super(ROLE_NAME, "Can manage ecpcrm dom, except centers");
    }

    @Override
    protected void execute(final ExecutionContext executionContext) {
        newPackagePermissions(
                ApplicationPermissionRule.ALLOW,
                ApplicationPermissionMode.CHANGING,
                EcpCrmLoyaltyCardsModule.class.getPackage().getName(),
                EcpCrmApplicationModule.class.getPackage().getName()
        );
        newPackagePermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                Center.class.getPackage().getName()
        );
        newClassPermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                CenterMenu.class
        );
        newMemberPermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                User.class,
                "center"
        );
        newMemberPermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                Card.class,
                "center"
        );

        newPackagePermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                AdminMenu.class.getPackage().getName()
        );
        newMemberPermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                CardMenu.class,
                "downloadAllCards"
        );
        newMemberPermissions(
                ApplicationPermissionRule.VETO,
                ApplicationPermissionMode.VIEWING,
                UserMenu.class,
                "downloadAllUsers"
        );
    }
}
```


Overlapping Code:
```
blic class HostessRoleAndPermissions extends AbstractRoleAndPermissionsFixtureScript {
public static final String ROLE_NAME = "hostess-role";
public HostessRoleAndPermissions() {
super(ROLE_NAME, "Can manage ecpcrm dom, except centers");
}
@Override
protected void execute(final ExecutionContext executionContext) {
newPackagePermissions(
ApplicationPermissionRule.ALLOW,
ApplicationPermissionMode.CHANGING,
EcpCrmLoyaltyCardsModule.class.getPackage().getName(),
EcpCrmApplicationModule.class.getPackage().getName()
);
newPackagePermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
Center.class.getPackage().getName()
);
newClassPermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
CenterMenu.class
);
newMemberPermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
User.class,
"center"
);
newMemberPermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
Card.class,
"center"
);
newPackagePermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
AdminMenu.class.getPackage().getName()
);
newMemberPermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
CardMenu.class,
"downloadAllCards"
);
newMemberPermissions(
ApplicationPermissionRule.VETO,
ApplicationPermissionMode.VIEWING,
UserMenu.class,
"dow
```
<Overlap Ratio: 0.9832483612527313>

---

--- 352 --
Question ID: 4d597e19a9d663739698f9bb7859d31cf67b1c1c
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class ZapReleaseComparitorUnitTest {

    private static final String DEV_BUILD = "Dev Build";

    @Test
    public void testComparitor() {
        ZapReleaseComparitor zrc = new ZapReleaseComparitor();

        // Test equals
        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(DEV_BUILD)) == 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.0"), new ZapRelease("2.0.0")) == 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.alpha"), new ZapRelease("2.0.alpha")) == 0);
        assertTrue(
                zrc.compare(new ZapRelease("D-2013-01-01"), new ZapRelease("D-2013-01-01")) == 0);

        // Test first more recent that second
        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("D-2012-08-01")) > 0);
        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("1.4.1")) > 0);
        assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("2.4.beta")) > 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.0.1"), new ZapRelease("2.0.0")) > 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.0.1"), new ZapRelease("2.0.alpha")) > 0);
        assertTrue(zrc.compare(new ZapRelease("1.4"), new ZapRelease("1.3.4")) > 0);
        assertTrue(zrc.compare(new ZapRelease("2.0"), new ZapRelease("1.3.4")) > 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.11"), new ZapRelease("2.0.5")) > 0);
        assertTrue(zrc.compare(new ZapRelease("1.4.alpha"), new ZapRelease("1.3.4")) > 0);
        assertTrue(zrc.compare(new ZapRelease("D-2012-08-02"), new ZapRelease("D-2012-08-01")) > 0);
        assertTrue(zrc.compare(new ZapRelease("D-2013-10-10"), new ZapRelease("D-2012-01-01")) > 0);
        assertTrue(zrc.compare(new ZapRelease("D-2013-01-01"), new ZapRelease("D-2012-12-31")) > 0);
        assertTrue(zrc.compare(new ZapRelease("D-2013-01-07"), new ZapRelease("D-2012-12-31")) > 0);
        assertTrue(zrc.compare(new ZapRelease("D-2013-01-07"), new ZapRelease("2.0.1")) > 0);

        // Test first older that second
        assertTrue(zrc.compare(new ZapRelease("1.4.1"), new ZapRelease(DEV_BUILD)) < 0);
        assertTrue(zrc.compare(new ZapRelease("2.4.beta"), new ZapRelease(DEV_BUILD)) < 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.0"), new ZapRelease("2.0.0.1")) < 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.alpha"), new ZapRelease("2.0.0.1")) < 0);
        assertTrue(zrc.compare(new ZapRelease("1.3.4"), new ZapRelease("1.4")) < 0);
        assertTrue(zrc.compare(new ZapRelease("1.3.4"), new ZapRelease("2.0")) < 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.6"), new ZapRelease("2.0.12")) < 0);
        assertTrue(zrc.compare(new ZapRelease("1.3.4"), new ZapRelease("1.4.alpha")) < 0);
        assertTrue(zrc.compare(new ZapRelease("D-2012-08-01"), new ZapRelease("D-2012-08-02")) < 0);
        assertTrue(zrc.compare(new ZapRelease("D-2012-01-01"), new ZapRelease("D-2013-10-10")) < 0);
        assertTrue(zrc.compare(new ZapRelease("D-2012-12-31"), new ZapRelease("D-2013-01-01")) < 0);
        assertTrue(zrc.compare(new ZapRelease("D-2012-12-31"), new ZapRelease("D-2013-01-07")) < 0);
        assertTrue(zrc.compare(new ZapRelease("2.0.1"), new ZapRelease("D-2013-01-07")) < 0);

        // Bad versions
        try {
            zrc.compare(new ZapRelease("1.4.1.theta"), new ZapRelease("1.4.1.alpha"));
            fail("Should have thrown an exception");
        } catch (IllegalArgumentException e) {
            // worked
        }
        try {
            zrc.compare(new ZapRelease("1.4.1.0"), new ZapRelease("1.4.1.theta"));
            fail("Should have thrown an exception");
        } catch (IllegalArgumentException e) {
            // worked
        }
    }
}
```


Overlapping Code:
```
RunWith(MockitoJUnitRunner.class)
public class ZapReleaseComparitorUnitTest {
private static final String DEV_BUILD = "Dev Build";
@Test
public void testComparitor() {
ZapReleaseComparitor zrc = new ZapReleaseComparitor();
// Test equals
assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease(DEV_BUILD)) == 0);
assertTrue(zrc.compare(new ZapRelease("2.0.0"), new ZapRelease("2.0.0")) == 0);
assertTrue(zrc.compare(new ZapRelease("2.0.alpha"), new ZapRelease("2.0.alpha")) == 0);
assertTrue(
zrc.compare(new ZapRelease("D-2013-01-01"), new ZapRelease("D-2013-01-01")) == 0);
// Test first more recent that second
assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("D-2012-08-01")) > 0);
assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("1.4.1")) > 0);
assertTrue(zrc.compare(new ZapRelease(DEV_BUILD), new ZapRelease("2.4.beta")) > 0);
assertTrue(zrc.compare(new ZapRelease("2.0.0.1"), new ZapRelease("2.0.0")) > 0);
assertTrue(zrc.compare(new ZapRelease("2.0.0.1"), new ZapRelease("2.0.alpha")) > 0);
assertTrue(zrc.compare(new ZapRelease("1.4"), new ZapRelease("1.3.4")) > 0);
assertTrue(zrc.compare(new ZapRelease("2.0"), new ZapRelease("1.3.4")) > 0);
assertTrue(zrc.compare(new ZapRelease("2.0.11"), new ZapRelease("2.0.5")) > 0);
assertTrue(zrc.compare(new ZapRelease("1.4.alpha"), new ZapRelease("1.3.4")) > 0);
assertTrue(zrc.compare(new ZapRelease("D-2012-08-02"), new ZapRelease("D-2012-08-01")) > 0);
assertTrue(zrc.compare(new ZapRelease("D-2013-10-10"), new ZapRelease("D-2012-01-01")) > 0);
assertTrue(zrc.compare(new ZapRelease("D-2013-01-01"), new ZapRelease("D-2012-12-31")) > 0);
assertTrue(zrc.compare(new ZapRelease("D-2013-01-07"), new ZapRelease("D-2012-12-31")) > 0);
assertTrue(zrc.compare(new ZapRelease("D-2013-01-07"), new ZapRelease("2.0.1")) > 0);
// Test first older that second
assertTrue(zrc.compare(new ZapRelease("1.4.1"), new ZapRelease(DEV_BUILD)) < 0);
assertTrue(zrc.compare(new ZapRelease("2.4.beta"), new ZapRelease(DEV_BUILD)) < 0);
assertTrue(zrc.compare(new ZapRelease("2.0.0"), new ZapRelease("2.0.0.1")) < 0);
assertTrue(zrc.compare(new ZapRelease("2.0.alpha"), new ZapRelease("2.0.0.1")) < 0);
assertTrue(zrc.compare(new ZapRelease("1.3.4"), new ZapRelease("1.
```
<Overlap Ratio: 0.9982222222222222>

---

--- 353 --
Question ID: 72654c4918164f8ff97d8d7a55a9f6c0868b81ce
Original Code:
```
public class NoClassDefFoundWithClassLoaderError
        extends
            NoClassDefFoundError
{
    private static final long serialVersionUID = 1L; // helps with serialization

    /**
     * Constructs a <code>NoClassDefFoundError</code> with the specified
     * detail message.
     *
     * @param className the name of the Class that could not be loaded
     * @param msg   the detail message.
     * @param loader the ModuleClassLoader that was used
     */
    public NoClassDefFoundWithClassLoaderError(
            String            className,
            String            msg,
            ModuleClassLoader loader )
    {
        super( msg );

        theClassName   = className;
        theClassLoader = loader;
    }

    /**
     * Obtain the name of the Class that could not be loaded.
     * 
     * @return the name of the Class
     */
    public String getClassName()
    {
        return theClassName;
    }

    /**
     * Obtain the ClassLoader that could not load the class.
     * 
     * @return the ClassLoader
     */
    public ModuleClassLoader getModuleClassLoader()
    {
        return theClassLoader;
    }

    /**
     * Convert to String representation, for debugging.
     *
     * @return String representation
     */
    @Override
    public String toString()
    {
        StringBuilder buf = new StringBuilder();
        buf.append( super.toString() );
        buf.append( ": ClassLoader of Module " );
        if( theClassLoader.getModule() != null ) {
            buf.append( theClassLoader.getModule().toString() );
        } else {
            buf.append( "? (" ).append( theClassLoader.getClass().getName() ).append( ")" );
        }

        return buf.toString();
    }

    /**
     * Name of the Class that could not be loaded.
     */
    protected String theClassName;

    /**
     * The ClassLoader through which loading failed.
     */
    protected ModuleClassLoader theClassLoader;
}
```


Overlapping Code:
```
ssLoaderError
extends
NoClassDefFoundError
{
private static final long serialVersionUID = 1L; // helps with serialization
/**
* Constructs a <code>NoClassDefFoundError</code> with the specified
* detail message.
*
* @param className the name of the Class that could not be loaded
* @param msg the detail message.
* @param loader the ModuleClassLoader that was used
*/
public NoClassDefFoundWithClassLoaderError(
String className,
String msg,
ModuleClassLoader loader )
{
super( msg );
theClassName = className;
theClassLoader = loader;
}
/**
* Obtain the name of the Class that could not be loaded.
* 
* @return the name of the Class
*/
public String getClassName()
{
return theClassName;
}
/**
* Obtain the ClassLoader that could not load the class.
* 
* @return the ClassLoader
*/
public ModuleClassLoader getModuleClassLoader()
{
return theClassLoader;
}
/**
* Convert to String representation, for debugging.
*
* @return String representation
*/
@Override
public String toString()
{
StringBuilder buf = new StringBuilder();
buf.append( super.toString() );
buf.append( ": ClassLoader of Module " );
if( theClassLoader.getModule() != null ) {
buf.append( theClassLoader.getModule().toString() );
} else {
buf.append( "? (" ).append( theClassLoader.getClass().getName() ).append( ")" );
}
return buf.toString();
}
/**
* Name of the Class that could not be loaded.
*/
protected String theClassName;
/**
* The ClassLoader through which loading failed.
```
<Overlap Ratio: 0.9452411994784876>

---

--- 354 --
Question ID: d94a1d4125a8dc34ed0d8afffc51f874a8f6baee
Original Code:
```
public class TestServer extends ServerHelper {
    @Test
    public void testVolume() throws JarvisException {
        assertEquals(100, jarvis.getVolume());
    }

    @Test
    public void testSetVolume() throws JarvisException {
        assertEquals(20, jarvis.setVolume(20));
    }

    @Test
    public void testVolumeUp() throws JarvisException {
        assertEquals(105, jarvis.volumeUp());
    }

    @Test
    public void testVolumeDown() throws JarvisException {
        assertEquals(95, jarvis.volumeDown());
    }

    @Test
    public void testTempo() throws JarvisException {
        assertEquals(80, jarvis.getTempo());
    }

    @Test
    public void testSetTempo() throws JarvisException {
        assertEquals(20, jarvis.setTempo(20));
    }

    @Test
    public void testTempoUp() throws JarvisException {
        assertEquals(85, jarvis.tempoUp());
    }

    @Test
    public void testTempoDown() throws JarvisException {
        assertEquals(75, jarvis.tempoDown());
    }

    @Test(expected = JarvisException.class)
    public void testNoCommandFound() throws JarvisException {
        jarvis.sendMessage("definitelynotacommandatall");
    }

    @Test(expected = JarvisException.class)
    public void testGeneratorCommandGeneratorNotLoaded() throws JarvisException {
        jarvis.loadGenerator("Random");
        jarvis.sendMessage("Otomata.poke 1 1");
    }

    @Test
    public void testListGenerators() throws JarvisException {
        String[] list = jarvis.getGenerators();
        assertTrue(list.length > 0);
    }

    @Test
    public void testStart() throws JarvisException {
        String response = jarvis.start();
        assertTrue(response.contains("successfully"));
    }

    @Test
    public void testStop() throws JarvisException {
        jarvis.start();
        String response = jarvis.stop();
        assertTrue(response.contains("successfully"));
    }
}
```


Overlapping Code:
```
est
public void testVolume() throws JarvisException {
assertEquals(100, jarvis.getVolume());
}
@Test
public void testSetVolume() throws JarvisException {
assertEquals(20, jarvis.setVolume(20));
}
@Test
public void testVolumeUp() throws JarvisException {
assertEquals(105, jarvis.volumeUp());
}
@Test
public void testVolumeDown() throws JarvisException {
assertEquals(95, jarvis.volumeDown());
}
@Test
public void testTempo() throws JarvisException {
assertEquals(80, jarvis.getTempo());
}
@Test
public void testSetTempo() throws JarvisException {
assertEquals(20, jarvis.setTempo(20));
}
@Test
public void testTempoUp() throws JarvisException {
assertEquals(85, jarvis.tempoUp());
}
@Test
public void testTempoDown() throws JarvisException {
assertEquals(75, jarvis.tempoDown());
}
@Test(expected = JarvisException.class)
public void testNoCommandFound() throws JarvisException {
jarvis.sendMessage("definitelynotacommandatall");
}
@Test(expected = JarvisException.class)
public void testGeneratorCommandGeneratorNotLoaded() throws JarvisException {
jarvis.loadGenerator("Random");
jarvis.sendMessage("Otomata.poke 1 1");
}
@Test
public void testListGenerators() throws JarvisException {
String[] list = jarvis.getGenerators();
assertTrue(list.length > 0);
}
@Test
public void testStart() throws JarvisException {
String response = jarvis.start();
assertTrue(response.contains("successfully"));
}
@Test
public void testStop() throws JarvisException {
jarvis.start();
String response = jarvis.stop();
assertTrue(response.contains("successfully"));
}
}
```
<Overlap Ratio: 0.9693558474046279>

---

--- 355 --
Question ID: 08836f15dac4972085c740da5e5e1876a573ff3f
Original Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@TestPropertySource(properties = { "spring.application.name=multiplehopsintegrationtests",
		"spring.sleuth.http.legacy.enabled=true" })
@SpringBootTest(classes = MultipleHopsIntegrationTests.Config.class, webEnvironment = RANDOM_PORT)
@ActiveProfiles("baggage")
public class MultipleHopsIntegrationTests {

	@Autowired
	Tracer tracer;

	@Autowired
	ArrayListSpanReporter reporter;

	@Autowired
	RestTemplate restTemplate;

	@Autowired
	Config config;

	@Autowired
	DemoApplication application;

	@Before
	public void setup() {
		this.reporter.clear();
	}

	@Test
	public void should_prepare_spans_for_export() throws Exception {
		this.restTemplate.getForObject(
				"http://localhost:" + this.config.port + "/greeting", String.class);

		await().atMost(5, SECONDS).untilAsserted(() -> {
			then(this.reporter.getSpans()).hasSize(14);
		});
		then(this.reporter.getSpans().stream().map(zipkin2.Span::name).collect(toList()))
				.containsAll(asList("http:/greeting", "send"));
		then(this.reporter.getSpans().stream().map(zipkin2.Span::kind)
				// no server kind due to test constraints
				.collect(toList()))
						.containsAll(asList(zipkin2.Span.Kind.CONSUMER,
								zipkin2.Span.Kind.PRODUCER, zipkin2.Span.Kind.SERVER));
		then(this.reporter.getSpans().stream().map(span -> span.tags().get("channel"))
				.filter(Objects::nonNull).distinct().collect(toList())).hasSize(3)
						.containsAll(asList("words", "counts", "greetings"));
	}

	// issue #237 - baggage
	@Test
	// Notes:
	// * path-prefix header propagation can't reliably support mixed case, due to http/2
	// downcasing
	// * Since not all tokenizers are case insensitive, mixed case can break correlation
	// * Brave's ExtraFieldPropagation downcases due to the above
	// * This code should probably test the side-effect on http headers
	// * the assumption all correlation fields (baggage) are saved to a span is an
	// interesting one
	// * should all correlation fields (baggage) be added to the MDC context?
	// * Until below, a configuration item of a correlation field whitelist is needed
	// * https://github.com/openzipkin/brave/pull/577
	// * probably needed anyway as an empty whitelist is a nice way to disable the feature
	public void should_propagate_the_baggage() throws Exception {
		// tag::baggage[]
		Span initialSpan = this.tracer.nextSpan().name("span").start();
		ExtraFieldPropagation.set(initialSpan.context(), "foo", "bar");
		ExtraFieldPropagation.set(initialSpan.context(), "UPPER_CASE", "someValue");
		// end::baggage[]

		try (Tracer.SpanInScope ws = this.tracer.withSpanInScope(initialSpan)) {
			// tag::baggage_tag[]
			initialSpan.tag("foo",
					ExtraFieldPropagation.get(initialSpan.context(), "foo"));
			initialSpan.tag("UPPER_CASE",
					ExtraFieldPropagation.get(initialSpan.context(), "UPPER_CASE"));
			// end::baggage_tag[]

			HttpHeaders headers = new HttpHeaders();
			headers.put("baggage-baz", Collections.singletonList("baz"));
			headers.put("baggage-bizarreCASE", Collections.singletonList("value"));
			RequestEntity requestEntity = new RequestEntity(headers, HttpMethod.GET,
					URI.create("http://localhost:" + this.config.port + "/greeting"));
			this.restTemplate.exchange(requestEntity, String.class);
		}
		finally {
			initialSpan.finish();
		}
		await().atMost(5, SECONDS).untilAsserted(() -> {
			then(this.reporter.getSpans()).isNotEmpty();
		});

		then(this.application.allSpans()).as("All have foo")
				.allMatch(span -> "bar".equals(baggage(span, "foo")));
		then(this.application.allSpans()).as("All have UPPER_CASE")
				.allMatch(span -> "someValue".equals(baggage(span, "UPPER_CASE")));
		then(this.application.allSpans().stream()
				.filter(span -> "baz".equals(baggage(span, "baz")))
				.collect(Collectors.toList())).as("Someone has baz").isNotEmpty();
		then(this.reporter.getSpans().stream()
				.filter(span -> span.tags().containsKey("foo")
						&& span.tags().containsKey("UPPER_CASE"))
				.collect(Collectors.toList())).as("Someone has foo and UPPER_CASE tags")
						.isNotEmpty();
		then(this.application.allSpans().stream()
				.filter(span -> "value".equals(baggage(span, "bizarreCASE")))
				.collect(Collectors.toList())).isNotEmpty();
	}

	private String baggage(Span span, String name) {
		return ExtraFieldPropagation.get(span.context(), name);
	}

	@Configuration
	@SpringBootApplication(exclude = JmxAutoConfiguration.class)
	public static class Config
			implements ApplicationListener<ServletWebServerInitializedEvent> {

		int port;

		@Override
		public void onApplicationEvent(ServletWebServerInitializedEvent event) {
			this.port = event.getSource().getPort();
		}

		@Bean
		RestTemplate restTemplate() {
			return new RestTemplate();
		}

		@Bean
		ArrayListSpanReporter arrayListSpanAccumulator() {
			return new ArrayListSpanReporter();
		}

		@Bean
		Sampler defaultTraceSampler() {
			return Sampler.ALWAYS_SAMPLE;
		}

	}

}
```


Overlapping Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@TestPropertySource(properties = { "spring.application.name=multiplehopsintegrationtests",
"spring.sleuth.http.legacy.enabled=true" })
@SpringBootTest(classes = MultipleHopsIntegrationTests.Config.class, webEnvironment = RANDOM_PORT)
@ActiveProfiles("baggage")
public class MultipleHopsIntegrationTests {
@Autowired
Tracer tracer;
@Autowired
ArrayListSpanReporter reporter;
@Autowired
RestTemplate restTemplate;
@Autowired
Config config;
@Autowired
DemoApplication application;
@Before
public void setup() {
this.reporter.clear();
}
@Test
public void should_prepare_spans_for_export() throws Exception {
this.restTemplate.getForObject(
"http://localhost:" + this.config.port + "/greeting", String.class);
await().atMost(5, SECONDS).untilAsserted(() -> {
then(this.reporter.getSpans()).hasSize(14);
});
then(this.reporter.getSpans().stream().map(zipkin2.Span::name).collect(toList()))
.containsAll(asList("http:/greeting", "send"));
then(this.reporter.getSpans().stream().map(zipkin2.Span::kind)
// no server kind due to test constraints
.collect(toList()))
.containsAll(asList(zipkin2.Span.Kind.CONSUMER,
zipkin2.Span.Kind.PRODUCER, zipkin2.Span.Kind.SERVER));
then(this.reporter.getSpans().stream().map(span -> span.tags().get("channel"))
.filter(Objects::nonNull).distinct().collect(toList())).hasSize(3)
.containsAll(asList("words", "counts", "greetings"));
}
// issue #237 - baggage
@Test
// Notes:
// * path-prefix header propagation can't reliably support mixed case, due to http/2
// downcasing
// * Since not all tokenizers are case insensitive, mixed case can break correlation
// * Brave's ExtraFieldPropagation downcases due to the above
// * This code should probably test the side-effect on http headers
// * the assumption all correlation fields (baggage) are saved to a span is an
// interesting one
// * should all correlation fields (baggage) be added to the MDC context?
// * Until below, a configuration item of a correlation field whitelist is needed
// * https://github.com/openzipkin/brave/pull/577
// * probably needed anyway as an empty whitelist is a nice way to disable the feature
public void should_propagate_the_baggage() throws Exception {
// tag::baggage[]
Span initialSpan = this.tracer.nextSpan().name("span").start();
ExtraFieldPropagation.set(initialSpan.context(), "foo", "bar");
ExtraFieldPropagation.set(initialSpa
```
<Overlap Ratio: 1.0>

---

--- 356 --
Question ID: 1d89d46a7a92c46d22cf60304201d42e2b644114
Original Code:
```
public class RewriteApiRequestVisitor extends SelectiveApiRequestVisitor {

	private static final long serialVersionUID = 1782406079539122227L;
	
	interface Spec {
		String Rewrite	= "rewrite";
		String Rules	= "rules";
		
		String Endpoint	= "endpoint";
		String Path		= "path";

		String If 		= "if";
		String Condition= "condition";
		String Scope 	= "scope";
		String Then 	= "then";
		String Negate 	= "negate";
		String Methods 	= "methods";
		
		interface Checkers {
			String Isnt 	= "isnt";
			String Is 		= "is";
			String Starts 	= "starts";
			String Ends 	= "ends";
			String Contains = "contains";
			String RegEx 	= "regex";
		}
		interface Actions {
			String Bypass	= "bypass";
			String Response	= "response";
			
			String Append 	= "append";
			String Prepend 	= "prepend";
			String Replace 	= "replace";
		}
	}
	
	private static final Map<String, RewriteConditionChecker> Checkers = new HashMap<String, RewriteConditionChecker> ();
	static {
		Checkers.put (Spec.Checkers.Is, new IsConditionChecker ());
		Checkers.put (Spec.Checkers.Isnt, new IsntConditionChecker ());
		Checkers.put (Spec.Checkers.Starts, new StartsConditionChecker ());
		Checkers.put (Spec.Checkers.Ends, new EndsConditionChecker ());
		Checkers.put (Spec.Checkers.Contains, new ContainsConditionChecker ());
		Checkers.put (Spec.Checkers.RegEx, new RegExConditionChecker ());
	}
	
	private static final Map<String, RewriteAction> Actions = new HashMap<String, RewriteAction> ();
	static {
		Actions.put (Spec.Actions.Bypass, new BypassAction ());
		Actions.put (Spec.Actions.Response, new ResponseAction ());

		Actions.put (Spec.Actions.Append, new AppendAction ());
		Actions.put (Spec.Actions.Prepend, new PrependAction ());
		Actions.put (Spec.Actions.Replace, new ReplaceAction ());
	}
	
	protected ApiServer server;
	
	@Override
	protected String [] endpoint (ApiRequest request, String [] endpoint) {
		JsonObject oRewrite = pickRewrite (request, Spec.Endpoint);
		if (oRewrite == null) {
			return endpoint;
		}
		
		// process rules
		String [] rewriten = applyRewrite (request, Placeholder.endpoint, oRewrite, endpoint);
		if (rewriten != null) {
			return rewriten;
		}
		
		return endpoint;
	}
	
	@Override
	protected String [] path (ApiRequest request, String [] path) {
		
		//server.tracer ().log (Level.Info, "Rewrite with Res.Value {0}", Lang.join (path, Lang.SLASH));
		
		JsonObject oRewrite = pickRewrite (request, Spec.Path);
		if (oRewrite == null) {
			return path;
		}
		
		//server.tracer ().log (Level.Info, "Rewrite Spec {0}", oRewrite);

		// process rules
		String [] rewriten = applyRewrite (request, Placeholder.path, oRewrite, path);
		if (rewriten != null) {
			return rewriten;
		}
		
		return path;
	}
	
	private JsonObject pickRewrite (ApiRequest request, String target) {
		String spaceNs = request.getSpace ();
		
		// at the node level
		if (Lang.isNullOrEmpty (spaceNs)) {
			return (JsonObject)Json.find (spec, Spec.Rewrite, target);
		}
		
		// space ns resolved
		
		ApiSpace space = null;
		try {
			space = server.space (spaceNs);
		} catch (Exception ex) {
			// ignore. Space not found
		}	
		if (space == null) {
			return null;
		}
		
		Object rewrite = space.getRuntime (Spec.Rewrite);

		//server.tracer ().log (Level.Info, "Space Rewrite {0}", rewrite);
		
		if (rewrite == null || !(rewrite instanceof JsonObject)) {
			return null;
		}
		
		JsonObject oRewrite = (JsonObject)rewrite;
		if (Json.isNullOrEmpty (oRewrite)) {
			return null;
		}
		
		JsonObject oTargetRewrite = Json.getObject (oRewrite, target);
		if (Json.isNullOrEmpty (oTargetRewrite)) {
			return null;
		}
		
		return oTargetRewrite;
	}
	
	private String [] applyRewrite (ApiRequest request, Placeholder placeholder, JsonObject oRewrite, String [] aTarget) {
		
		//server.tracer ().log (Level.Info, "\tApply rewrite on ", placeholder);

		JsonArray aRules = Json.getArray (oRewrite, Spec.Rules);
		if (Json.isNullOrEmpty (aRules)) {
			return aTarget;
		}
		
		//server.tracer ().log (Level.Info, "\tFound {0} rules", aRules.count ());

		for (int i = 0; i < aRules.count (); i++) {
			JsonObject oRule = (JsonObject)aRules.get (i);
			aTarget = applyRule (request, placeholder, oRule, aTarget);
		}
		
		return aTarget;
	}
	
	private String [] applyRule (ApiRequest request, Placeholder placeholder, JsonObject rule, String [] aTarget) {
		
		// check methods
		JsonArray methods = Json.getArray (rule, Spec.Methods);
		
		if (!Json.isNullOrEmpty (methods) && !methods.contains (request.getVerb ().name ())) {
			return aTarget;
		}
		
		// check condition
		Object oIf = rule.get (Spec.If);
		
		String condition = null;
		Placeholder scope = placeholder;
		
		if (oIf instanceof JsonObject) {
			condition = Json.getString ((JsonObject)oIf, Spec.Condition);
			scope = Placeholder.valueOf (Json.getString ((JsonObject)oIf, Spec.Scope, placeholder.name ()));
		} else {
			condition = Json.getString (rule, Spec.If);
		}		
		
		//server.tracer ().log (Level.Info, "\tApply rule with condition {0}", condition);

		boolean apply = true;
		
		String conditionValue = null;
		
		if (!Lang.isNullOrEmpty (condition)) {
			int indexOfColon = condition.indexOf (Lang.COLON);
			if (indexOfColon > 0) {
				String checkerId 	= condition.substring (0, indexOfColon).trim ();
				conditionValue 		= condition.substring (indexOfColon + 1).trim ();
				
				RewriteConditionChecker checker = Checkers.get (checkerId);
				server.tracer ().log (Level.Debug, "\tRule checker {0}", checker);
				
				apply = (checker == null) || 
						checker.check (scope.equals (Placeholder.endpoint) ? request.getEndpoint () : request.getPath (), conditionValue);
				
				if (Json.getBoolean (rule, Spec.Negate, false)) {
					apply = !apply;
				}
				
			}
		}
		
		//server.tracer ().log (Level.Info, "\tShould apply actions? {0}", apply);

		if (!apply) {
			return aTarget;
		}
		
		// apply actions
		Object then = rule.get (Spec.Then);
		if (then == null || !(then instanceof JsonObject)) {
			return aTarget;
		}
		
		//server.tracer ().log (Level.Info, "\tApply actions {0}", then);
		
		JsonObject actions = (JsonObject)then;
		if (Json.isNullOrEmpty (actions)) {
			return aTarget;
		}
		
		Iterator<String> actionIds = actions.keys ();
		while (actionIds.hasNext ()) {
			String actionId = actionIds.next ();
			//server.tracer ().log (Level.Info, "\tApply action {0}", actionId);
			RewriteAction action = Actions.get (actionId);
			if (action == null) {
				continue;
			}
			//server.tracer ().log (Level.Info, "\t\t with processor {0}", action);
			aTarget = action.apply (request, placeholder, aTarget, actions.get (actionId), conditionValue);
		}
		
		return aTarget;
	}

	public void setServer (ApiServer server) {
		this.server = server;
	}

}
```


Overlapping Code:
```
writeApiRequestVisitor extends SelectiveApiRequestVisitor {
private static final long serialVersionUID = 1782406079539122227L;

interface Spec {
String Rewrite = "rewrite";
String Rules = "rules";

String Endpoint = "endpoint";
String Path = "path";
String If = "if";
String Condition= "condition";
String Scope = "scope";
String Then = "then";
String Negate = "negate";
String Methods = "methods";

interface Checkers {
String Isnt = "isnt";
String Is = "is";
String Starts = "starts";
String Ends = "ends";
String Contains = "contains";
String RegEx = "regex";
}
interface Actions {
String Bypass = "bypass";
String Response = "response";

String Append = "append";
String Prepend = "prepend";
String Replace = "replace";
}
}

private static final Map<String, RewriteConditionChecker> Checkers = new HashMap<String, RewriteConditionChecker> ();
static {
Checkers.put (Spec.Checkers.Is, new IsConditionChecker ());
Checkers.put (Spec.Checkers.Isnt, new IsntConditionChecker ());
Checkers.put (Spec.Checkers.Starts, new StartsConditionChecker ());
Checkers.put (Spec.Checkers.Ends, new EndsConditionChecker ());
Checkers.put (Spec.Checkers.Contains, new ContainsConditionChecker ());
Checkers.put (Spec.Checkers.RegEx, new RegExConditionChecker ());
}

private static final Map<String, RewriteAction> Actions = new HashMap<String, RewriteAction> ();
static {
Actions.put (Spec.Actions.Bypass, new BypassAction ());
Actions.put (Spec.Actions.Response, new ResponseAction ());
Actions.put (Spec.Actions.Append, new AppendAction ());
Actions.put (Spec.Actions.Prepend, new PrependAction ());
Actions.put (Spec.Actions.Replace, new ReplaceAction ());
}

protected ApiServer server;

@Override
protected String [] endpoint (ApiRequest request, String [] endpoint) {
JsonObject oRewrite = pickRewrite (request, Spec.Endpoint);
if (oRewrite == null) {
return endpoint;
}

// process rules
String [] rewriten = applyRewrite (request, Placeholder.endpoint, oRewrite, endpoint);
if (rewriten != null) {
return rewriten;
}

return endpoint;
}

@Override
protected String [] path (ApiRequest request, String [] path) {

//server.tracer ().log (Level.Info, "Rewrite with Res.Value {0}", Lang.join (path, Lang.SLASH));

JsonObject oRewrite = pickRewrite (request, Spec.Path);
if (oRewrite == null) {
return path;
}
```
<Overlap Ratio: 0.9896729776247849>

---

--- 357 --
Question ID: 8bdc2e88c1163d94bad3909c999c04280a97eaec
Original Code:
```
@SuppressWarnings( { "ClassWithoutLogger", "UseOfSystemOutOrSystemErr" } )
public class DirectoryWatcherTest {

	@BeforeClass
	public static void setUpClass() {
		System.out.println("---- DirectoryWatcherTest --------------------------------------");
	}

	private Path dir_a;
	private Path dir_a_c;
	private Path dir_b;
	private ExecutorService executor;
	private Path file_a;
	private Path file_a_c;
	private Path file_b1;
	private Path file_b2;
	private Path root;

	@Before
	public void setUp() throws IOException {
		executor = Executors.newSingleThreadExecutor();
		root = Files.createTempDirectory("DW_");
		dir_a = Files.createTempDirectory(root, "DW_a_");
		file_a = Files.createTempFile(dir_a, "DW_a_", ".test");
		dir_a_c = Files.createTempDirectory(dir_a, "DW_a_c_");
		file_a_c = Files.createTempFile(dir_a_c, "DW_a_c_", ".test");
		dir_b = Files.createTempDirectory(root, "DW_b_");
		file_b1 = Files.createTempFile(dir_b, "DW_b1_", ".test");
		file_b2 = Files.createTempFile(dir_b, "DW_b2_", ".test");
	}

	@After
	public void tearDown() throws IOException {
		Files.walkFileTree(root, new DeleteFileVisitor());
		executor.shutdown();
	}

	/**
	 * Test of close method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test( expected = RejectedExecutionException.class )
	public void testClose() throws IOException, RejectedExecutionException, InterruptedException {

		System.out.println("  Testing 'close'...");

		CountDownLatch latchErrors = new CountDownLatch(1);
		CountDownLatch latchEvents = new CountDownLatch(1);
		DirectoryWatcher watcher = build(executor);
		Disposable errrorsSubscription = watcher.errors().subscribe(t -> {}, t -> {}, latchErrors::countDown);
		Disposable eventsSubscription = watcher.events().subscribe(t -> {}, t -> {}, latchEvents::countDown);

		assertFalse(watcher.isClosed());

		watcher.delete(
			file_b2,
			t -> {
				assertTrue(t);
			},
			e -> {
				fail(MessageFormat.format("File not deleted: {0}", file_b2));
			}
		);

		watcher.close();

		assertTrue(watcher.isClosed());

		if ( !latchErrors.await(15, TimeUnit.SECONDS) ) {
			fail("Missing 'onComplete' for errors stream in 15 seconds.");
		}
		if ( !latchEvents.await(15, TimeUnit.SECONDS) ) {
			fail("Missing 'onComplete' for events stream in 15 seconds.");
		}

		watcher.delete(
			file_b1,
			t -> {
				fail("Operation has not been rejected.");
			},
			e -> {
				fail("Operation has not been rejected.");
			}
		);

		errrorsSubscription.dispose();
		eventsSubscription.dispose();

	}

	/**
	 * Test of build method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testCreate() throws IOException {

		System.out.println("  Testing 'create'...");

		try ( DirectoryWatcher watcher = build(executor) ) {
			assertNotNull(watcher);
			assertFalse(watcher.isClosed());
		}

	}

	/**
	 * Test of createDirectories method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testCreateDirectories() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''createDirectories'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			CountDownLatch latch = new CountDownLatch(2);
			Path toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), "dir_a_x", "dir_a_y", "dir_a_z");

			watcher.createDirectories(
				toBeCreated,
				p -> {
					assertNotNull(p);
					assertTrue(Files.exists(p));
					assertTrue(Files.isDirectory(p));
					assertEquals(toBeCreated, p);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("Directory not created: {0}", toBeCreated));
					latch.countDown();
				}
			);

			Path toFail = file_a;

			watcher.createDirectories(
				toFail,
				p -> {
					fail(MessageFormat.format("Directory was created: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof FileAlreadyExistsException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("Directories creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of createDirectory method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testCreateDirectory() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''createDirectory'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			CountDownLatch latch = new CountDownLatch(3);
			Path toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), "dir_a_z");

			watcher.createDirectory(
				toBeCreated,
				p -> {
					assertNotNull(p);
					assertTrue(Files.exists(p));
					assertTrue(Files.isDirectory(p));
					assertEquals(toBeCreated, p);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("Directory not created: {0}", toBeCreated));
					latch.countDown();
				}
			);

			Path toFail1 = dir_a_c;

			watcher.createDirectory(
				toFail1,
				p -> {
					fail(MessageFormat.format("Directory was created: {0}", toFail1));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof FileAlreadyExistsException);
					latch.countDown();
				}
			);

			Path toFail2 = FileSystems.getDefault().getPath(dir_a.toString(), "dir_a_x", "dir_a_y", "dir_a_z");

			watcher.createDirectory(
				toFail2,
				p -> {
					fail(MessageFormat.format("Directory was created: {0}", toFail2));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("Directory creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of createFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testCreateFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''createFile'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			CountDownLatch latch = new CountDownLatch(2);
			Path toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), "created_file.txt");

			watcher.createFile(
				toBeCreated,
				t -> {
					assertNotNull(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not created: {0}", toBeCreated));
					latch.countDown();
				}
			);

			Path toFail = FileSystems.getDefault().getPath(dir_a.toString(), "non-exitent", "created_file.txt");

			watcher.createFile(
				toFail,
				t -> {
					fail(MessageFormat.format("File was created: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of delete method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testDelete() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''delete'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			CountDownLatch latch = new CountDownLatch(5);

			watcher.delete(
				file_b2,
				t -> {
					assertTrue(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not deleted: {0}", file_b2));
					latch.countDown();
				}
			);
			watcher.delete(
				file_b2,
				t -> {
					assertFalse(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not deleted: {0}", file_b2));
					latch.countDown();
				}
			);
			watcher.delete(
				dir_b,
				t -> {
					fail(MessageFormat.format("Non-empty directory was deleted: {0}", file_b2));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);
			watcher.delete(
				file_b1,
				t -> {
					assertTrue(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not deleted: {0}", file_b2));
					latch.countDown();
				}
			);
			watcher.delete(
				dir_b,
				t -> {
					assertTrue(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("Directory not deleted: {0}", file_b2));
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File deletion not completed in 1 minute.");
			}

			assertFalse(Files.exists(dir_b));
			assertFalse(Files.exists(file_b1));
			assertFalse(Files.exists(file_b2));

		}

	}

	/**
	 * Test of deleteTree method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testDeleteTree() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''deleteTree'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			CountDownLatch latch = new CountDownLatch(2);

			watcher.deleteTree(
				dir_a,
				t -> {
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("Tree not deleted: {0}", file_b2));
					latch.countDown();
				}
			);
			watcher.deleteTree(
				Paths.get("a", "b", "c", "d", "e", "1", "2", "3", "4", "5"),
				t -> {
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("Tree not deleted: {0}", file_b2));
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File deletion not completed in 1 minute.");
			}

			assertFalse(Files.exists(file_a_c));
			assertFalse(Files.exists(dir_a_c));
			assertFalse(Files.exists(file_a));
			assertFalse(Files.exists(dir_a));

		}

	}

	/**
	 * Test of errors method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testErrors() throws IOException {

		System.out.println("  Testing 'errors'...");

		try ( DirectoryWatcher watcher = build(executor) ) {

			Observable<Throwable> errorsStream = watcher.errors();

			assertNotNull(errorsStream);

		}

	}

	/**
	 * Test of events method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testEvents() throws IOException {

		System.out.println("  Testing 'events'...");

		try ( DirectoryWatcher watcher = build(executor) ) {

			Observable<DirectoryWatcher.DirectoryEvent> event = watcher.events();

			assertNotNull(event);

		}

	}

	/**
	 * Test of isCloseComplete method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testIsCloseComplete() throws IOException {

		System.out.println("  Testing 'isCloseComplete'...");

		DirectoryWatcher watcher = build(executor);

		assertFalse(watcher.isClosed());
		assertFalse(watcher.isCloseComplete());

		watcher.close();

		assertFalse(watcher.isCloseComplete());
		assertTrue(watcher.isClosed());

		long startTime = System.currentTimeMillis();
		long currentTime = startTime;

		while ( !watcher.isCloseComplete() && startTime + 60000L > currentTime ) {
			currentTime = System.currentTimeMillis();
		}

		assertTrue(watcher.isCloseComplete());

	}

	/**
	 * Test of isClosed method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testIsClosed() throws IOException {

		System.out.println("  Testing 'isClosed'...");

		DirectoryWatcher watcher = build(executor);

		assertFalse(watcher.isClosed());

		watcher.close();

		assertTrue(watcher.isClosed());

	}

	/**
	 * Test of isWatched method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	@SuppressWarnings( "CallToThreadYield" )
	public void testIsWatched() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''isWatched'' [on {0}]...", root));

		DirectoryWatcher watcher = build(executor);

		watcher.watch(dir_a);
		assertTrue(watcher.isWatched(dir_a));

		watcher.watch(dir_a_c);
		assertTrue(watcher.isWatched(dir_a_c));

		watcher.watch(dir_b);
		assertTrue(watcher.isWatched(dir_b));

		CountDownLatch latch = new CountDownLatch(1);

		Disposable subscription = watcher.events().subscribe(event -> {
			event.getEvents().stream().forEach(e -> {
				if ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {
					System.out.println("    Path deleted: " + e.context());
					if ( dir_a_c.equals(event.getWatchedPath().resolve((Path) e.context())) ) {
						latch.countDown();
					}
				}
			});
		});

		Files.walkFileTree(dir_a_c, new DeleteFileVisitor());

		if ( !latch.await(1, TimeUnit.MINUTES) ) {
			fail("File deletion not signalled in 1 minute.");
		}

		assertFalse(watcher.isWatched(dir_a_c));

		watcher.delete(
			dir_a,
			success -> assertFalse(watcher.isWatched(dir_a)),
			null
		);

		subscription.dispose();
		watcher.close();

		while ( !watcher.isCloseComplete() ) {
			Thread.yield();
		}

		assertFalse(watcher.isWatched(dir_b));

	}

	/**
	 * Test of readBinaryFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testReadBinaryFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''readBinaryFile'' [on {0}]...", root));

		byte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Files.write(file_b1, content);

			watcher.readBinaryFile(
				file_b1,
				t -> {
					assertArrayEquals(content, t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not read: {0}", file_b1));
					latch.countDown();
				}
			);

			Path toFail = FileSystems.getDefault().getPath(dir_a.toString(), "non-exitent", "created_file.txt");

			watcher.readBinaryFile(
				toFail,
				t -> {
					fail(MessageFormat.format("File was read: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of readTextFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testReadTextFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''readTextFile'' [on {0}]...", root));

		String content = "First line of text.\nSecond line of text.";
		Charset charset = defaultCharset();
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Files.write(file_b1, content.getBytes(charset), CREATE, WRITE, TRUNCATE_EXISTING);

			watcher.readTextFile(
				file_b1,
				charset,
				t -> {
					assertEquals(content, t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not read: {0}", file_b1));
					latch.countDown();
				}
			);

			Path toFail = FileSystems.getDefault().getPath(dir_a.toString(), "non-exitent", "created_file.txt");

			watcher.readTextFile(
				toFail,
				charset,
				t -> {
					fail(MessageFormat.format("File was read: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of writeBinaryFile and readBinaryFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testReadWriteBinaryFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''writeBinaryFile'' and ''readBinaryFile'' [on {0}]...", root));

		byte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Path readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), "created_file.txt");

			watcher.writeBinaryFile(
				readWriteFile,
				content,
				t -> {
					assertNotNull(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not written: {0}", readWriteFile));
					latch.countDown();
				}
			);
			watcher.readBinaryFile(
				readWriteFile,
				t -> {
					assertArrayEquals(content, t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not read: {0}", file_b1));
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of writeTextFile and readTextFile methods, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testReadWriteTextFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''writeTextFile'' and ''readTextFile'' [on {0}]...", root));

		String content = "First line of text.\nSecond line of text.";
		Charset charset = defaultCharset();
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Path readWriteFile = FileSystems.getDefault().getPath(dir_a.toString(), "created_file.txt");

			watcher.writeTextFile(
				readWriteFile,
				content,
				charset,
				t -> {
					assertNotNull(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not written: {0}", readWriteFile));
					latch.countDown();
				}
			);
			watcher.readTextFile(
				readWriteFile,
				charset,
				t -> {
					assertEquals(content, t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not read: {0}", file_b1));
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

		}

	}

	/**
	 * Test of unwatch method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testUnwatch() throws IOException {

		System.out.println(MessageFormat.format("  Testing ''unwatch'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			watcher.watch(dir_a);
			assertTrue(watcher.isWatched(dir_a));

			watcher.watch(dir_a_c);
			assertTrue(watcher.isWatched(dir_a_c));

			watcher.watch(dir_b);
			assertTrue(watcher.isWatched(dir_b));

			watcher.unwatch(dir_a);
			assertFalse(watcher.isWatched(dir_a));

			watcher.unwatch(dir_a_c);
			assertFalse(watcher.isWatched(dir_a_c));

			watcher.unwatch(dir_b);
			assertFalse(watcher.isWatched(dir_b));

		}

	}

	/**
	 * Test of watch method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testWatch() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''watch'' [on {0}]...", root));

		CountDownLatch createLatch = new CountDownLatch(1);
		CountDownLatch deleteLatch = new CountDownLatch(1);
		CountDownLatch modifyLatch = new CountDownLatch(1);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Disposable subscription = watcher.events().subscribe(event -> {
				event.getEvents().stream().forEach(e -> {
					if ( StandardWatchEventKinds.ENTRY_CREATE.equals(e.kind()) ) {
						System.out.println("    File created: " + e.context());
						createLatch.countDown();
					} else if ( StandardWatchEventKinds.ENTRY_DELETE.equals(e.kind()) ) {
						System.out.println("    File deleted: " + e.context());
						deleteLatch.countDown();
					} else if ( StandardWatchEventKinds.ENTRY_MODIFY.equals(e.kind()) ) {
						System.out.println("    File modified: " + e.context());
						modifyLatch.countDown();
					}
				});
			});

			watcher.watch(root);

			Path tmpFile = Files.createTempFile(root, "DW_", ".test");

			if ( !createLatch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not signalled in 1 minute.");
			}

			Files.write(tmpFile, "Some text content".getBytes(), APPEND);

			if ( !modifyLatch.await(1, TimeUnit.MINUTES) ) {
				fail("File modification not signalled in 1 minute.");
			}

			Files.delete(tmpFile);

			if ( !deleteLatch.await(1, TimeUnit.MINUTES) ) {
				fail("File deletion not signalled in 1 minute.");
			}

			subscription.dispose();

		}

	}

	/**
	 * Test of watchOrStreamError method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testWatchOrStreamError() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''watchOrStreamError'' [on {0}]...", root));

		CountDownLatch errorLatch = new CountDownLatch(1);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Disposable subscription = watcher.errors().subscribe(throwable -> {
				if ( throwable instanceof NotDirectoryException ) {
					errorLatch.countDown();
				}
			});

			watcher.watchOrStreamError(file_a);

			if ( !errorLatch.await(1, TimeUnit.MINUTES) ) {
				fail("File deletion not signalled in 1 minute.");
			}
			subscription.dispose();

		}

	}

	/**
	 * Test of watchUp and unwatchUp methods, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 */
	@Test
	public void testWatchUpAndUnwatchUp() throws IOException {

		System.out.println(MessageFormat.format("  Testing ''watchUp'' and ''unwatchUp'' [on {0}]...", root));

		try ( DirectoryWatcher watcher = build(executor) ) {

			watcher.watchUp(dir_a_c, root);
			assertTrue(watcher.isWatched(dir_a));
			assertTrue(watcher.isWatched(dir_a_c));
			assertFalse(watcher.isWatched(root));

			watcher.watch(root);
			assertTrue(watcher.isWatched(root));

			watcher.unwatchUp(dir_a_c, root);
			assertFalse(watcher.isWatched(dir_a));
			assertFalse(watcher.isWatched(dir_a_c));
			assertTrue(watcher.isWatched(root));

		}

	}

	/**
	 * Test of writeBinaryFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testWriteBinaryFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''writeBinaryFile'' [on {0}]...", root));

		byte[] content = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x03, 0x02, 0x01, 0x00 };
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Path toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), "created_file.txt");

			watcher.writeBinaryFile(
				toBeCreated,
				content,
				t -> {
					assertNotNull(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not written: {0}", toBeCreated));
					latch.countDown();
				}
			);

			Path toFail = FileSystems.getDefault().getPath(dir_a.toString(), "non-exitent", "created_file.txt");

			watcher.writeBinaryFile(
				toFail,
				content,
				t -> {
					fail(MessageFormat.format("File was written: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

			assertArrayEquals(content, Files.readAllBytes(toBeCreated));

		}

	}

	/**
	 * Test of writeTextFile method, of class DirectoryWatcher.
	 *
	 * @throws java.io.IOException
	 * @throws java.lang.InterruptedException
	 */
	@Test
	public void testWriteTextFile() throws IOException, InterruptedException {

		System.out.println(MessageFormat.format("  Testing ''writeTextFile'' [on {0}]...", root));

		String content = "First line of text.\nSecond line of text.";
		Charset charset = defaultCharset();
		CountDownLatch latch = new CountDownLatch(2);

		try ( DirectoryWatcher watcher = build(executor) ) {

			Path toBeCreated = FileSystems.getDefault().getPath(dir_a.toString(), "created_file.txt");

			watcher.writeTextFile(
				toBeCreated,
				content,
				charset,
				t -> {
					assertNotNull(t);
					latch.countDown();
				},
				e -> {
					fail(MessageFormat.format("File not written: {0}", toBeCreated));
					latch.countDown();
				}
			);

			Path toFail = FileSystems.getDefault().getPath(dir_a.toString(), "non-exitent", "created_file.txt");

			watcher.writeTextFile(
				toFail,
				content,
				charset,
				t -> {
					fail(MessageFormat.format("File was written: {0}", toFail));
					latch.countDown();
				},
				e -> {
					assertNotNull(e);
					assertTrue(e instanceof IOException);
					latch.countDown();
				}
			);

			if ( !latch.await(1, TimeUnit.MINUTES) ) {
				fail("File creation not completed in 1 minute.");
			}

			assertEquals(content, new String(Files.readAllBytes(toBeCreated), charset));

		}

	}

}
```


Overlapping Code:
```
essWarnings( { "ClassWithoutLogger", "UseOfSystemOutOrSystemErr" } )
public class DirectoryWatcherTest {
@BeforeClass
public static void setUpClass() {
System.out.println("---- DirectoryWatcherTest --------------------------------------");
}
private Path dir_a;
private Path dir_a_c;
private Path dir_b;
private ExecutorService executor;
private Path file_a;
private Path file_a_c;
private Path file_b1;
private Path file_b2;
private Path root;
@Before
public void setUp() throws IOException {
executor = Executors.newSingleThreadExecutor();
root = Files.createTempDirectory("DW_");
dir_a = Files.createTempDirectory(root, "DW_a_");
file_a = Files.createTempFile(dir_a, "DW_a_", ".test");
dir_a_c = Files.createTempDirectory(dir_a, "DW_a_c_");
file_a_c = Files.createTempFile(dir_a_c, "DW_a_c_", ".test");
dir_b = Files.createTempDirectory(root, "DW_b_");
file_b1 = Files.createTempFile(dir_b, "DW_b1_", ".test");
file_b2 = Files.createTempFile(dir_b, "DW_b2_", ".test");
}
@After
public void tearDown() throws IOException {
Files.walkFileTree(root, new DeleteFileVisitor());
executor.shutdown();
}
/**
* Test of close method, of class DirectoryWatcher.
*
* @throws java.io.IOException
* @throws java.lang.InterruptedException
*/
@Test( expected = RejectedExecutionException.class )
public void testClose() throws IOException, RejectedExecutionException, InterruptedException {
System.out.println(" Testing 'close'...");
CountDownLatch latchErrors = new CountDownLatch(1);
CountDownLatch latchEvents = new CountDownLatch(1);
DirectoryWatcher watcher = build(executor);
Disposable errrorsSubscription = watcher.errors().subscribe(t -> {}, t -> {}, latchErrors::countDown);
Disposable eventsSubscription = watcher.events().subscribe(t -> {}, t -> {}, latchEvents::countDown);
assertFalse(watcher.isClosed());
watcher.delete(
file_b2,
t -> {
assertTrue(t);
},
e -> {
fail(MessageFormat.format("File not deleted: {0}", file_b2));
}
);
watcher.close();
assertTrue(watcher.isClosed());
if ( !latchErrors.await(15, TimeUnit.SECONDS) ) {
fail("Missing 'onComplete' for errors stream in 15 seconds.");
}
if ( !latchEvents.await(15, TimeUnit.SECONDS) ) {
fail("Missing 'onComplete' for events stream in 15 seconds.");
}
watcher.delete(
file_b1,
t -> {
fail("Operation has not been rejected.");
},
e -> {
fail("Operation has not been rejected."
```
<Overlap Ratio: 0.9957319675629535>

---

--- 358 --
Question ID: aa8d1e8b841e48ce0ee040d753ce2d033a80f61b
Original Code:
```
public class JSONUtils {
	
	static XStream xstream = new XStream(new JettisonMappedXmlDriver(){
		
		public HierarchicalStreamWriter createWriter(Writer writer) {
            return new JsonWriter(writer, JsonWriter.DROP_ROOT_MODE);
        }
		
	});
	
	public static String toJson(Object object){
		xstream.setMode(XStream.NO_REFERENCES);
		String json = xstream.toXML(object);
        return json;
	}
	
	public static <T> T toObject(String json, Class<T> aClass){
		xstream.setMode(XStream.NO_REFERENCES);
		return (T) xstream.fromXML(json);
		
	}

}
```


Overlapping Code:
```
 {

static XStream xstream = new XStream(new JettisonMappedXmlDriver(){

public HierarchicalStreamWriter createWriter(Writer writer) {
return new JsonWriter(writer, JsonWriter.DROP_ROOT_MODE);
}

});

public static String toJson(Object object){
xstream.setMode(XStream.NO_REFERENCES);
String json = xstream.toXML(object);
return json;
}

public static <T> T toObject(String json, Class<T> aClass){
xstream.setMode(XStream.NO_REFERENCES);
return (T) x
```
<Overlap Ratio: 0.9036144578313253>

---

--- 359 --
Question ID: 3dd92e6e3dd8d7926cc6b0042590a8765c7942e1
Original Code:
```
public class MemcachedNodesManagerTest {

	private MemcachedClientCallback _mcc;

	@BeforeMethod
	public void beforeClass() {
		_mcc = mock(MemcachedClientCallback.class);
	}

	@Test(expectedExceptions = IllegalArgumentException.class)
	public void testParseWithNullShouldThrowException() {
		createFor(null, null, null, _mcc);
	}

	@Test(expectedExceptions = IllegalArgumentException.class)
	public void testParseWithEmptyStringShouldThrowException() {
		createFor("", null, null, _mcc);
	}

	@Test(expectedExceptions = IllegalArgumentException.class)
	public void testSingleSimpleNodeAndFailoverNodeShouldThrowException() {
		createFor("localhost:11211", "n1", null, _mcc);
	}

	@Test(expectedExceptions = IllegalArgumentException.class)
	public void testSingleNodeAndFailoverNodeShouldThrowException() {
		createFor("n1:localhost:11211", "n1", null, _mcc);
	}

    @Test(expectedExceptions = IllegalArgumentException.class)
    public void testCouchbaseNodesAndFailoverNodeShouldThrowException() {
        createFor("http://localhost:8091/pools", "n1", null, _mcc);
    }

	@DataProvider
	public static Object[][] nodesAndExpectedCountDataProvider() {
		return new Object[][] {
				{ "localhost:11211", 1 },
                { "http://localhost:8091/pools", 1},
                { "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", 2},
                { "n1:localhost:11211", 1 },
				{ "n1:localhost:11211,n2:localhost:11212", 2 },
				{ "n1:localhost:11211 n2:localhost:11212", 2 }
		};
	}

	@Test( dataProvider = "nodesAndExpectedCountDataProvider" )
	public void testCountNodes( final String memcachedNodes, final int expectedCount ) {
		final MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );
		assertNotNull(result);
		assertEquals(result.getCountNodes(),  expectedCount);
	}

	@DataProvider
	public static Object[][] nodesAndPrimaryNodesDataProvider() {
		return new Object[][] {
				{ "localhost:11211", null, new NodeIdList() },
                { "http://localhost:8091/pools", null, new NodeIdList() },
                { "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null, new NodeIdList() },
				{ "n1:localhost:11211", null, new NodeIdList("n1") },
				{ "n1:localhost:11211,n2:localhost:11212", "n1", new NodeIdList("n2") },
				{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", "n1", new NodeIdList("n2", "n3") },
				{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", "n1,n2", new NodeIdList("n3") }
		};
	}

	@Test( dataProvider = "nodesAndPrimaryNodesDataProvider" )
	public void testPrimaryNodes(final String memcachedNodes, final String failoverNodes, final NodeIdList expectedPrimaryNodeIds) {
		final MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );
		assertNotNull(result);
		assertEquals(result.getPrimaryNodeIds(), expectedPrimaryNodeIds);
	}

	@DataProvider
	public static Object[][] nodesAndFailoverNodesDataProvider() {
		return new Object[][] {
				{ "localhost:11211", null, Collections.emptyList() },
				{ "localhost:11211", "", Collections.emptyList() },
                { "http://localhost:8091/pools", null, Collections.emptyList() },
				{ "n1:localhost:11211", null, Collections.emptyList() },
				{ "n1:localhost:11211,n2:localhost:11212", "n1", Arrays.asList("n1") },
				{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", "n1,n2", Arrays.asList("n1", "n2") },
				{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", "n1 n2", Arrays.asList("n1", "n2") }
		};
	}

	@Test( dataProvider = "nodesAndFailoverNodesDataProvider" )
	public void testFailoverNodes(final String memcachedNodes, final String failoverNodes, final List<String> expectedFailoverNodeIds) {
		final MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );
		assertNotNull(result);
		assertEquals(result.getFailoverNodeIds(), expectedFailoverNodeIds);
	}

	@DataProvider
	public static Object[][] nodesAndExpectedEncodedInSessionIdDataProvider() {
		return new Object[][] {
				{ "localhost:11211", null, false },
                { "http://localhost:8091/pools", null, false },
                { "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null, false },
				{ "n1:localhost:11211", null, true },
				{ "n1:localhost:11211,n2:localhost:11212", "n1", true }
		};
	}

	@Test( dataProvider = "nodesAndExpectedEncodedInSessionIdDataProvider" )
	public void testIsEncodeNodeIdInSessionId( final String memcachedNodes, final String failoverNodes, final boolean expectedIsEncodeNodeIdInSessionId ) {
		final MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );
		assertNotNull(result);
		assertEquals(result.isEncodeNodeIdInSessionId(), expectedIsEncodeNodeIdInSessionId);
	}

	@Test(expectedExceptions = IllegalArgumentException.class)
	public void testGetNodeIdShouldThrowExceptionForNullArgument() {
		final MemcachedNodesManager result = createFor( "n1:localhost:11211", null, null, _mcc );
		result.getNodeId(null);
	}

	@DataProvider
	public static Object[][] testGetNodeIdDataProvider() {
		return new Object[][] {
				{ "n1:localhost:11211", null, new InetSocketAddress("localhost", 11211), "n1" },
				{ "n1:localhost:11211,n2:localhost:11212", null, new InetSocketAddress("localhost", 11212), "n2" },
				{ "n1:localhost:11211,n2:localhost:11212", "n1", new InetSocketAddress("localhost", 11211), "n1" }
		};
	}

	@Test( dataProvider = "testGetNodeIdDataProvider" )
	public void testGetNodeId(final String memcachedNodes, final String failoverNodes, final InetSocketAddress socketAddress, final String expectedNodeId) {
		final MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );
		assertEquals(result.getNodeId(socketAddress), expectedNodeId);
	}

	/**
	 * Test for {@link MemcachedNodesManager#getNextPrimaryNodeId(String)}.
	 * @see NodeIdList#getNextNodeId(String)
	 * @see NodeIdListTest#testGetNextNodeId()
	 */
	@Test
	public void testGetNextPrimaryNodeId() {
		assertNull(createFor( "n1:localhost:11211", null, null, _mcc ).getNextPrimaryNodeId("n1"));
		assertEquals(createFor( "n1:localhost:11211,n2:localhost:11212", null, null, _mcc ).getNextPrimaryNodeId("n1"), "n2");
	}

    @Test
    public void testGetNextAvailableNodeId() {
        assertNull(createFor( "n1:localhost:11211", null, null, _mcc ).getNextAvailableNodeId("n1"));
        assertEquals(createFor( "n1:localhost:11211,n2:localhost:11212", null, null, _mcc ).getNextAvailableNodeId("n1"), "n2");

        final MemcachedClientCallback mcc = mock(MemcachedClientCallback.class);
        when(mcc.get(anyString())).thenReturn(null);
        when(mcc.get(endsWith("n2"))).thenThrow(new OperationTimeoutException("SimulatedException"));
        assertNull(createFor( "n1:localhost:11211,n2:localhost:11212", null, null, mcc).getNextAvailableNodeId("n1"));

        assertEquals(createFor( "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", null, null, mcc).getNextAvailableNodeId("n1"), "n3");
    }

	@DataProvider
	public static Object[][] testgGetAllMemcachedAddressesDataProvider() {
		return new Object[][] {
				{ "localhost:11211", null, asList(new InetSocketAddress("localhost", 11211)) },
				{ "http://localhost:8091/pools", null, asList(new InetSocketAddress("localhost", 8091)) },
                { "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null,
				    asList(new InetSocketAddress("10.10.0.1", 8091), new InetSocketAddress("10.10.0.2", 8091)) },
				{ "n1:localhost:11211", null, asList(new InetSocketAddress("localhost", 11211)) },
				{ "n1:localhost:11211,n2:localhost:11212", null, asList(new InetSocketAddress("localhost", 11211), new InetSocketAddress("localhost", 11212)) },
				{ "n1:localhost:11211,n2:localhost:11212", "n1", asList(new InetSocketAddress("localhost", 11211), new InetSocketAddress("localhost", 11212)) }
		};
	}

	@Test( dataProvider = "testgGetAllMemcachedAddressesDataProvider" )
	public void testGetAllMemcachedAddresses(final String memcachedNodes, final String failoverNodes, final Collection<InetSocketAddress> expectedSocketAddresses) {
		final MemcachedNodesManager result = createFor( memcachedNodes, failoverNodes, null, _mcc );
		assertEquals(result.getAllMemcachedAddresses(), expectedSocketAddresses);
	}

	@Test
	public void testGetSessionIdFormat() {
		final SessionIdFormat sessionIdFormat = createFor( "n1:localhost:11211", null, null, _mcc ).getSessionIdFormat();
		assertNotNull(sessionIdFormat);
	}

    @Test
    public void testSessionIdFormatForSingleNodeSetupShouldSupportLocking() {
        final SessionIdFormat sessionIdFormat = createFor( "localhost:11211", null, StorageKeyFormat.EMPTY, _mcc ).getSessionIdFormat();
        assertNotNull(sessionIdFormat);
        final String sessionId = "12345678";
        assertEquals(sessionIdFormat.createLockName(sessionId), "lock:" + sessionId);
    }

	@Test
	public void testCreateSessionIdShouldOnlyAddNodeIdIfPresent() {
		assertEquals(createFor( "n1:localhost:11211", null, null, _mcc ).createSessionId("foo"), "foo-n1" );
		assertEquals(createFor( "localhost:11211", null, null, _mcc ).createSessionId("foo"), "foo" );
	}

	@Test
	public void testSetNodeAvailable() {
		final MemcachedNodesManager cut = createFor( "n1:localhost:11211,n2:localhost:11212", null, null, _mcc );
		assertTrue(cut.isNodeAvailable("n1"));
		assertTrue(cut.isNodeAvailable("n2"));

		cut.setNodeAvailable("n1", false);

		assertFalse(cut.isNodeAvailable("n1"));
		assertTrue(cut.isNodeAvailable("n2"));
	}

    @Test
    public void testIsCouchbaseBucketConfig() {
        assertTrue(createFor("http://10.10.0.1:8091/pools", null, null, _mcc ).isCouchbaseBucketConfig());
        assertTrue(createFor("http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null, null, _mcc ).isCouchbaseBucketConfig());
    }

    @Test
    public void testGetCouchbaseBucketURIs() throws URISyntaxException {
        assertEquals(createFor("http://10.10.0.1:8091/pools", null, null, _mcc ).getCouchbaseBucketURIs(),
                Arrays.asList(new URI("http://10.10.0.1:8091/pools")));
        assertEquals(createFor("http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null, null, _mcc ).getCouchbaseBucketURIs(),
                Arrays.asList(new URI("http://10.10.0.1:8091/pools"), new URI("http://10.10.0.2:8091/pools")));
    }

    @Test
    public void testChangeSessionIdForTomcatFailover() {
        assertEquals(createFor("localhost:11211", null, null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", null, null), null), sessionId("123", null, null));
        assertEquals(createFor("localhost:11211", null, null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", null, "tc1"), "tc2"), sessionId("123", null, "tc2"));

        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", null, null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), null), sessionId("123", "n1", null));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", null, null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), "tc2"), sessionId("123", "n1", "tc2"));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", null, null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", "tc1"), "tc2"), sessionId("123", "n1", "tc2"));

        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n2", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), null), sessionId("123", "n1", null));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n2", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), "tc2"), sessionId("123", "n1", "tc2"));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n2", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", "tc1"), "tc2"), sessionId("123", "n1", "tc2"));

        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n1", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), null), sessionId("123", "n2", null));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n1", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", null), "tc2"), sessionId("123", "n2", "tc2"));
        assertEquals(createFor("n1:localhost:11211,n2:localhost:11212", "n1", null, _mcc)
                .changeSessionIdForTomcatFailover(sessionId("123", "n1", "tc1"), "tc2"), sessionId("123", "n2", "tc2"));

    }

    private static String sessionId(final String plainId, final String memcachedId, final String jvmRoute) {
        final SessionIdFormat sessionIdFormat = new SessionIdFormat();
        final String withMemcachedId = sessionIdFormat.createSessionId(plainId, memcachedId);
        return jvmRoute != null ? sessionIdFormat.changeJvmRoute(withMemcachedId, jvmRoute) : withMemcachedId;
    }

}
```


Overlapping Code:
```
achedNodesManagerTest {
private MemcachedClientCallback _mcc;
@BeforeMethod
public void beforeClass() {
_mcc = mock(MemcachedClientCallback.class);
}
@Test(expectedExceptions = IllegalArgumentException.class)
public void testParseWithNullShouldThrowException() {
createFor(null, null, null, _mcc);
}
@Test(expectedExceptions = IllegalArgumentException.class)
public void testParseWithEmptyStringShouldThrowException() {
createFor("", null, null, _mcc);
}
@Test(expectedExceptions = IllegalArgumentException.class)
public void testSingleSimpleNodeAndFailoverNodeShouldThrowException() {
createFor("localhost:11211", "n1", null, _mcc);
}
@Test(expectedExceptions = IllegalArgumentException.class)
public void testSingleNodeAndFailoverNodeShouldThrowException() {
createFor("n1:localhost:11211", "n1", null, _mcc);
}
@Test(expectedExceptions = IllegalArgumentException.class)
public void testCouchbaseNodesAndFailoverNodeShouldThrowException() {
createFor("http://localhost:8091/pools", "n1", null, _mcc);
}
@DataProvider
public static Object[][] nodesAndExpectedCountDataProvider() {
return new Object[][] {
{ "localhost:11211", 1 },
{ "http://localhost:8091/pools", 1},
{ "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", 2},
{ "n1:localhost:11211", 1 },
{ "n1:localhost:11211,n2:localhost:11212", 2 },
{ "n1:localhost:11211 n2:localhost:11212", 2 }
};
}
@Test( dataProvider = "nodesAndExpectedCountDataProvider" )
public void testCountNodes( final String memcachedNodes, final int expectedCount ) {
final MemcachedNodesManager result = createFor( memcachedNodes, null, null, _mcc );
assertNotNull(result);
assertEquals(result.getCountNodes(), expectedCount);
}
@DataProvider
public static Object[][] nodesAndPrimaryNodesDataProvider() {
return new Object[][] {
{ "localhost:11211", null, new NodeIdList() },
{ "http://localhost:8091/pools", null, new NodeIdList() },
{ "http://10.10.0.1:8091/pools,http://10.10.0.2:8091/pools", null, new NodeIdList() },
{ "n1:localhost:11211", null, new NodeIdList("n1") },
{ "n1:localhost:11211,n2:localhost:11212", "n1", new NodeIdList("n2") },
{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", "n1", new NodeIdList("n2", "n3") },
{ "n1:localhost:11211,n2:localhost:11212,n3:localhost:11213", 
```
<Overlap Ratio: 0.9761388286334056>

---

--- 360 --
Question ID: 2de57659c7f83e63d11fccd26dbb2ad9f991edc0
Original Code:
```
public class Utils {

	
	public static double calculateWordDifficulty(String word)
	{
		return 0;
	}
	
	public static String translateRulesToHTMLTags(Rule rule)
	{
		if (rule.getPresentationStyle() == Rule.HIGHLIGHT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.HIGHLIGHT_WHOLE_WORD)
		{
			return "background-color";
		}
		else if (rule.getPresentationStyle() == Rule.PAINT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.PAINT_WHOLE_WORD)
		{
			return "color";
		}
		else
			return ""; 
	}
	
	public static String rgbToHEX(java.awt.Color color)
	{
		String hex = Integer.toHexString(color.getRGB() & 0xffffff);
		if (hex.length() < 6) 
		{
		    hex = "0" + hex;
		}
		hex = "#" + hex;
		return hex;
	}
	
}
```


Overlapping Code:
```


public static double calculateWordDifficulty(String word)
{
return 0;
}

public static String translateRulesToHTMLTags(Rule rule)
{
if (rule.getPresentationStyle() == Rule.HIGHLIGHT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.HIGHLIGHT_WHOLE_WORD)
{
return "background-color";
}
else if (rule.getPresentationStyle() == Rule.PAINT_PROBLEMATIC_PARTS || rule.getPresentationStyle() == Rule.PAINT_WHOLE_WORD)
{
return "color";
}
else
return ""; 
}

public static String rgbToHEX(java.awt.Color color)
{
String hex = Integer.toHexString(color.getRGB() & 0xffffff);
if (hex.length() < 6) 
{
hex = "0" + hex;
}
hex = "#" + hex;
return hex;
}

```
<Overlap Ratio: 0.9672619047619048>

---

--- 361 --
Question ID: ad614d4ecea52698f884507175c5038688d59d42
Original Code:
```
@RunWith(MockitoJUnitRunner.class)
public class PodServiceTest {

    @Spy
    @InjectMocks
    private PodService spy;
    @Mock
    private HostPodDao hostPodDao;
    @Mock
    private HostJdbcDao hostJdbcDao;

    @Test
    public void getAllPodsEnabledFromZoneTest() {
        List<HostPodVO> hosts = new ArrayList<>();
        Mockito.doReturn(hosts).when(hostPodDao).listByDataCenterId(Mockito.anyLong());

        List<HostPodVO> result = spy.getAllPodsEnabledFromZone(0l);

        Mockito.verify(hostPodDao).listByDataCenterId(Mockito.anyLong());
        Assert.assertEquals(hosts, result);
    }

    @Test
    public void findPodByIdTest() {
        HostPodVO host = Mockito.mock(HostPodVO.class);
        Mockito.doReturn(host).when(hostPodDao).findById(Mockito.anyLong());
        HostPodVO result = spy.findPodById(0l);
        Mockito.verify(hostPodDao).findById(Mockito.anyLong());
        Assert.assertEquals(host, result);
    }

    @Test
    public void isThereAnyHostOnPodDeactivatedByOurManagerTestTrue() {
        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(true);
    }

    @Test
    public void isThereAnyHostOnPodDeactivatedByOurManagerTestFalse() {
        executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(false);
    }

    private void executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(boolean expected) {
        Mockito.doReturn(expected).when(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());
        boolean result = spy.isThereAnyHostOnPodDeactivatedByOurManager(0l);
        Mockito.verify(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());
        Assert.assertEquals(expected, result);
    }

}
```


Overlapping Code:
```
@RunWith(MockitoJUnitRunner.class)
public class PodServiceTest {
@Spy
@InjectMocks
private PodService spy;
@Mock
private HostPodDao hostPodDao;
@Mock
private HostJdbcDao hostJdbcDao;
@Test
public void getAllPodsEnabledFromZoneTest() {
List<HostPodVO> hosts = new ArrayList<>();
Mockito.doReturn(hosts).when(hostPodDao).listByDataCenterId(Mockito.anyLong());
List<HostPodVO> result = spy.getAllPodsEnabledFromZone(0l);
Mockito.verify(hostPodDao).listByDataCenterId(Mockito.anyLong());
Assert.assertEquals(hosts, result);
}
@Test
public void findPodByIdTest() {
HostPodVO host = Mockito.mock(HostPodVO.class);
Mockito.doReturn(host).when(hostPodDao).findById(Mockito.anyLong());
HostPodVO result = spy.findPodById(0l);
Mockito.verify(hostPodDao).findById(Mockito.anyLong());
Assert.assertEquals(host, result);
}
@Test
public void isThereAnyHostOnPodDeactivatedByOurManagerTestTrue() {
executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(true);
}
@Test
public void isThereAnyHostOnPodDeactivatedByOurManagerTestFalse() {
executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(false);
}
private void executeIsThereAnyHostOnPodDeactivatedByOurManagerTest(boolean expected) {
Mockito.doReturn(expected).when(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());
boolean result = spy.isThereAnyHostOnPodDeactivatedByOurManager(0l);
Mockito.verify(hostJdbcDao).isThereAnyHostOnPodDeactivatedByOurManager(Mockito.anyLong());
Assert.assertEquals(expected, result);

```
<Overlap Ratio: 0.9979743416610398>

---

--- 362 --
Question ID: 3972e76df8fb5123c864af245858ee78215452f5
Original Code:
```
public class Stealth_Mode extends CustomCard {
    public static final String ID = "Yohane:Stealth_Mode";
    private static CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);
    public static final String NAME = cardStrings.NAME;
    public static final String DESCRIPTION = cardStrings.DESCRIPTION;
    public static final String IMG_PATH = "cards/Stealth_Mode.png";
    private static final int COST = 0;
    private static final int POOL = 1;
    private static final int INTANGIBLE = 1;
    private static final CardRarity rarity = CardRarity.RARE;
    private static final CardTarget target = CardTarget.SELF;

    public Stealth_Mode() {
        super(ID, NAME, IMG_PATH, COST, DESCRIPTION,
                CardType.SKILL, AbstractCardEnum.YOHANE_GREY,
                        rarity, target);
        this.magicNumber = this.baseMagicNumber = INTANGIBLE;
        this.retain = true;
    }

    @Override
    public void use(AbstractPlayer p, AbstractMonster m) {
    }

    @Override
    public void applyPowers() {
        super.applyPowers();
        this.retain = true;
    }

    public void triggerOnEndOfTurnForPlayingCard() {
        AbstractPlayer p = AbstractDungeon.player;
        if (!p.drawPile.group.isEmpty()) {
            for (AbstractCard c : p.drawPile.group) {
                c.current_y = (-200.0F * Settings.scale);
                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);
                c.target_y = (Settings.HEIGHT / 2.0F);
                c.targetAngle = 0.0F;
                c.lighten(false);
                c.drawScale = 0.12F;
                c.targetDrawScale = 0.75F;
                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.drawPile));
            }
        }
        if (!p.discardPile.group.isEmpty()) {
            for (AbstractCard c : p.discardPile.group) {
                c.current_y = (-200.0F * Settings.scale);
                c.target_x = (Settings.WIDTH / 2.0F + 200.0F);
                c.target_y = (Settings.HEIGHT / 2.0F);
                c.targetAngle = 0.0F;
                c.lighten(false);
                c.drawScale = 0.12F;
                c.targetDrawScale = 0.75F;
                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.discardPile));
            }
        } else {
            for (AbstractCard c : p.hand.group) {
                AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.hand));
            }
        }
        AbstractDungeon.actionManager.addToBottom(new com.megacrit.cardcrawl.actions.common.ApplyPowerAction(p, p, new IntangiblePlayerPower(p, this.magicNumber), this.magicNumber));
    }
    

    @Override
    public AbstractCard makeCopy() {
        return new Stealth_Mode();
    }

    @Override
    public void upgrade() {
        if (!this.upgraded) {
            this.upgradeName();
        }
    }

}
```


Overlapping Code:
```
e extends CustomCard {
public static final String ID = "Yohane:Stealth_Mode";
private static CardStrings cardStrings = CardCrawlGame.languagePack.getCardStrings(ID);
public static final String NAME = cardStrings.NAME;
public static final String DESCRIPTION = cardStrings.DESCRIPTION;
public static final String IMG_PATH = "cards/Stealth_Mode.png";
private static final int COST = 0;
private static final int POOL = 1;
private static final int INTANGIBLE = 1;
private static final CardRarity rarity = CardRarity.RARE;
private static final CardTarget target = CardTarget.SELF;
public Stealth_Mode() {
super(ID, NAME, IMG_PATH, COST, DESCRIPTION,
CardType.SKILL, AbstractCardEnum.YOHANE_GREY,
rarity, target);
this.magicNumber = this.baseMagicNumber = INTANGIBLE;
this.retain = true;
}
@Override
public void use(AbstractPlayer p, AbstractMonster m) {
}
@Override
public void applyPowers() {
super.applyPowers();
this.retain = true;
}
public void triggerOnEndOfTurnForPlayingCard() {
AbstractPlayer p = AbstractDungeon.player;
if (!p.drawPile.group.isEmpty()) {
for (AbstractCard c : p.drawPile.group) {
c.current_y = (-200.0F * Settings.scale);
c.target_x = (Settings.WIDTH / 2.0F + 200.0F);
c.target_y = (Settings.HEIGHT / 2.0F);
c.targetAngle = 0.0F;
c.lighten(false);
c.drawScale = 0.12F;
c.targetDrawScale = 0.75F;
AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.drawPile));
}
}
if (!p.discardPile.group.isEmpty()) {
for (AbstractCard c : p.discardPile.group) {
c.current_y = (-200.0F * Settings.scale);
c.target_x = (Settings.WIDTH / 2.0F + 200.0F);
c.target_y = (Settings.HEIGHT / 2.0F);
c.targetAngle = 0.0F;
c.lighten(false);
c.drawScale = 0.12F;
c.targetDrawScale = 0.75F;
AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c, p.discardPile));
}
} else {
for (AbstractCard c : p.hand.group) {
AbstractDungeon.actionManager.addToBottom(new ExhaustSpecificCardAction(c,
```
<Overlap Ratio: 0.9826264690853347>

---

--- 363 --
Question ID: 3000c4a07de26d597f41f5e1397ab49958c4d4e4
Original Code:
```
public class PointTest {

    private Point point;
    private VectorSequence coordinates;

    @Test
    public void isEmptyTest() {
        point = new Point();
        assertFalse(point.isEmpty());
    }


    @Test
    public void makeDimensionTest() {
        Point point1 = new Point();
        point1.makeDimension(2);
        assertTrue(point1.getDimension() == 2);
    }


    @Test
    public void loadTest() {
        Point p = new Point(1, 1, 1);
        try {
            byte[] bytes = p.storeToByteArray();
            long s = p.getByteArraySize();
            assertTrue(bytes.length == s);
            Point p2 = new Point();
            p2.loadFromByteArray(bytes);
            assertTrue(p2.getDimension() == 3);
            assertTrue(p2.getY() == 1);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    @Test
    public void storeTest() {
        Point p = new Point(1, 1, 1);
        try {
            byte[] t = p.storeToByteArray();
            Point p1 = (Point) p.clone();
            byte[] t2 = p1.storeToByteArray();
            assertEquals(t.length, t2.length);
            assertArrayEquals(t, t2);
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    @Test
    public void getByteArraySizeTest() {
        point = new Point();
        long byteArraySize = point.getByteArraySize();
        try {
            byte[] bs = point.storeToByteArray();
            assertEquals(bs.length, byteArraySize);
        } catch (IOException e) {

        }
    }

    @Test
    public void cloneTest() {
        Point point1 = new Point(1, 2, 3);
        Point point2 = (Point) point1.clone();
        assertEquals(point1, point2);
        System.out.println(point1.getVectorSequence());
        System.out.println(point2.getVectorSequence());
        assertEquals(point1.getVectorSequence(), point2.getVectorSequence());
        assertTrue(point2.getX() == point1.getX());
        assertTrue(point2.getY() == 2);
        assertTrue(point2.getZ() == 3);

        Point point3 = new Point(3);
        VectorSequence coordinate1 = point3.getVectorSequence();
        coordinate1.add(4, 5, 6);
        Point point4 = (Point) point3.clone();
        System.out.println(point4.getDimension());
        Vector v = point4.getVectorSequence().getVector(1);
        assertTrue(v.getX() == 4);
        assertTrue(v.getY() == 5);
        assertTrue(v.getZ() == 6);

        double[] de = {1.2, 1.4, 1.5};
        VectorSequence vectorSequence = new PackedVectorSequence(de, 3);
        Point point5 = new Point(vectorSequence);
    }

}
```


Overlapping Code:
```
public class PointTest {
private Point point;
private VectorSequence coordinates;
@Test
public void isEmptyTest() {
point = new Point();
assertFalse(point.isEmpty());
}
@Test
public void makeDimensionTest() {
Point point1 = new Point();
point1.makeDimension(2);
assertTrue(point1.getDimension() == 2);
}
@Test
public void loadTest() {
Point p = new Point(1, 1, 1);
try {
byte[] bytes = p.storeToByteArray();
long s = p.getByteArraySize();
assertTrue(bytes.length == s);
Point p2 = new Point();
p2.loadFromByteArray(bytes);
assertTrue(p2.getDimension() == 3);
assertTrue(p2.getY() == 1);
} catch (IOException e) {
e.printStackTrace();
}
}
@Test
public void storeTest() {
Point p = new Point(1, 1, 1);
try {
byte[] t = p.storeToByteArray();
Point p1 = (Point) p.clone();
byte[] t2 = p1.storeToByteArray();
assertEquals(t.length, t2.length);
assertArrayEquals(t, t2);
} catch (IOException e) {
e.printStackTrace();
}
}
@Test
public void getByteArraySizeTest() {
point = new Point();
long byteArraySize = point.getByteArraySize();
try {
byte[] bs = point.storeToByteArray();
assertEquals(bs.length, byteArraySize);
} catch (IOException e) {
}
}
@Test
public void cloneTest() {
Point point1 = new Point(1, 2, 3);
Point point2 = (Point) point1.clone();
assertEquals(point1, point2);
System.out.println(point1.getVectorSequence());
System.out.println(point2.getVectorSequence());
assertEquals(point1.getVectorSequence(), point2.getVectorSequence());
assertTrue(point2.getX() == point1.getX());
assertTrue(point2.getY() == 2);
assertTrue(point2.getZ() == 3);
Point point3 = new Point(3);
VectorSequence coordinate1 = point3.getVectorSequence();
coordinate1.add(4, 5, 6);
Point point4 = (Point) point3.clone();
System.out.println(point4.getDimension());
Vector v = point4.getVectorSequence().getVector(1);
assertTrue(v.getX() == 4);
assertTrue(v.getY() == 5);
assertTrue(v.getZ() == 6);
double[] de = {1.2, 1.
```
<Overlap Ratio: 0.9937238493723849>

---

--- 364 --
Question ID: a585178eddf349d67cdbbb48fc7170c94b329e3c
Original Code:
```
public class CopyTaskCommand extends Command {

    public static final String COMMAND_WORD = "copytask";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Copies the Task identified by the index from one plan to another.\n"
            + "Parameters:\n"
            + PREFIX_TASK + "TASK_INDEX "
            + PREFIX_PLAN_FROM + "PLAN_FROM_INDEX "
            + PREFIX_PLAN_TO + "PLAN_TO_INDEX\n"
            + "Example:\n"
            + COMMAND_WORD + " "
            + PREFIX_TASK + "10 "
            + PREFIX_PLAN_FROM + "1 "
            + PREFIX_PLAN_TO + "2";

    public static final String MESSAGE_MOVE_TASK_SUCCESS = "Task [%1$s] copied from Plan [%2$s] to Plan [%3$s].";

    private final CopyTaskDescriptor copyTaskDescriptor;

    /**
     * Creates a CopyTaskCommand to copy a {@code Task} from the specified {@code Plan} to another
     *
     * @param copyTaskDescriptor details of the plan and problem involved
     */
    public CopyTaskCommand(CopyTaskDescriptor copyTaskDescriptor) {
        requireNonNull(copyTaskDescriptor);

        this.copyTaskDescriptor = copyTaskDescriptor;
    }

    @Override
    public CommandResult execute(Model model, CommandHistory history) throws CommandException {
        requireNonNull(model);

        String successMessage =
            TaskCommandUtil.shiftTask(
                model,
                copyTaskDescriptor.planFromIndex,
                copyTaskDescriptor.planToIndex,
                copyTaskDescriptor.taskIndex,
                false,
                MESSAGE_MOVE_TASK_SUCCESS
            );

        return new CommandResult(successMessage);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof CopyTaskCommand // instanceof handles nulls
                && copyTaskDescriptor.equals(((CopyTaskCommand) other).copyTaskDescriptor)); // state check
    }

    /**
     * Stores the details of the plan and problem involved.
     */
    public static class CopyTaskDescriptor {
        private Index taskIndex;
        private Index planFromIndex;
        private Index planToIndex;

        public CopyTaskDescriptor(Index taskIndex, Index planFromIndex, Index planToIndex) {
            this.taskIndex = taskIndex;
            this.planFromIndex = planFromIndex;
            this.planToIndex = planToIndex;
        }

        @Override
        public boolean equals(Object other) {
            return other == this // short circuit if same object
                || (other instanceof CopyTaskDescriptor // instanceof handles nulls
                && taskIndex.equals(((CopyTaskDescriptor) other).taskIndex)
                && planFromIndex.equals(((CopyTaskDescriptor) other).planFromIndex)
                && planToIndex.equals(((CopyTaskDescriptor) other).planToIndex));
        }
    }
}
```


Overlapping Code:
```
pyTaskCommand extends Command {
public static final String COMMAND_WORD = "copytask";
public static final String MESSAGE_USAGE = COMMAND_WORD
+ ": Copies the Task identified by the index from one plan to another.\n"
+ "Parameters:\n"
+ PREFIX_TASK + "TASK_INDEX "
+ PREFIX_PLAN_FROM + "PLAN_FROM_INDEX "
+ PREFIX_PLAN_TO + "PLAN_TO_INDEX\n"
+ "Example:\n"
+ COMMAND_WORD + " "
+ PREFIX_TASK + "10 "
+ PREFIX_PLAN_FROM + "1 "
+ PREFIX_PLAN_TO + "2";
public static final String MESSAGE_MOVE_TASK_SUCCESS = "Task [%1$s] copied from Plan [%2$s] to Plan [%3$s].";
private final CopyTaskDescriptor copyTaskDescriptor;
/**
* Creates a CopyTaskCommand to copy a {@code Task} from the specified {@code Plan} to another
*
* @param copyTaskDescriptor details of the plan and problem involved
*/
public CopyTaskCommand(CopyTaskDescriptor copyTaskDescriptor) {
requireNonNull(copyTaskDescriptor);
this.copyTaskDescriptor = copyTaskDescriptor;
}
@Override
public CommandResult execute(Model model, CommandHistory history) throws CommandException {
requireNonNull(model);
String successMessage =
TaskCommandUtil.shiftTask(
model,
copyTaskDescriptor.planFromIndex,
copyTaskDescriptor.planToIndex,
copyTaskDescriptor.taskIndex,
false,
MESSAGE_MOVE_TASK_SUCCESS
);
return new CommandResult(successMessage);
}
@Override
public boolean equals(Object other) {
return other == this // short circuit if same object
|| (other instanceof CopyTaskCommand // instanceof handles nulls
&& copyTaskDescriptor.equals(((CopyTaskCommand) other).copyTaskDescriptor)); // state check
}
/**
* Stores the details of the plan and problem involved.
*/
public static class CopyTaskDescriptor {
private Index taskIndex;
private Index planFromIndex;
private Index planToIndex;
public CopyTaskDescriptor(Index taskIndex, Index planFromIndex, Index planToIndex) {
this.taskIndex = taskIndex;
this.planFromIndex = planFromIndex;
this.planToIndex = planToIndex;
}
@Override
public boolean equals(Object other) {
```
<Overlap Ratio: 0.9924242424242424>

---

--- 365 --
Question ID: f55fbabaef19b27f7d4aabb8e4e1c4c45a9ad8f8
Original Code:
```
public class BMI160_Example
{
    public static void main(String[] args) throws InterruptedException
    {
// ! [Interesting]
        System.out.println("Initializing...");

        // Instantiate a BMI160 instance using default i2c bus and address
        BMI160 sensor = new BMI160();

        while (true)
            {
                // update our values from the sensor
                sensor.update();

                AbstractList<Float> dataA = sensor.getAcceleration();

                System.out.println("Accelerometer: "
                                   + "AX: "
                                   + dataA.get(0)
                                   + " AY: "
                                   + dataA.get(1)
                                   + " AZ: "
                                   + dataA.get(2));

                AbstractList<Float> dataG = sensor.getGyroscope();

                System.out.println("Gryoscope:     "
                                   + "GX: "
                                   + dataG.get(0)
                                   + " GY: "
                                   + dataG.get(1)
                                   + " GZ: "
                                   + dataG.get(2));

                AbstractList<Float> dataM = sensor.getMagnetometer();

                System.out.println("Magnetometer:  "
                                   + "MX: "
                                   + dataM.get(0)
                                   + " MY: "
                                   + dataM.get(1)
                                   + " MZ: "
                                   + dataM.get(2));

                System.out.println();
                Thread.sleep(500);
            }

// ! [Interesting]
    }
}
```


Overlapping Code:
```
Example
{
public static void main(String[] args) throws InterruptedException
{
// ! [Interesting]
System.out.println("Initializing...");
// Instantiate a BMI160 instance using default i2c bus and address
BMI160 sensor = new BMI160();
while (true)
{
// update our values from the sensor
sensor.update();
AbstractList<Float> dataA = sensor.getAcceleration();
System.out.println("Accelerometer: "
+ "AX: "
+ dataA.get(0)
+ " AY: "
+ dataA.get(1)
+ " AZ: "
+ dataA.get(2));
AbstractList<Float> dataG = sensor.getGyroscope();
System.out.println("Gryoscope: "
+ "GX: "
+ dataG.get(0)
+ " GY: "
+ dataG.get(1)
+ " GZ: "
+ dataG.get(2));
AbstractList<Float> dataM = sensor.getMagnetometer();
System.out.println("Magnetometer: "
+ "MX: "
+ dataM.get(0)
+ " MY: "
+ dataM.get(1)
+ " MZ: "
+ dataM.get(2));
System.out.println();
Threa
```
<Overlap Ratio: 0.9341657207718501>

---

--- 366 --
Question ID: 200123a7130a3c6ce28560064be52a809e50a64a
Original Code:
```
@RunWith(AndroidJUnit4.class)
public class TestPerformance {
    private static final String TAG = "TestPerformance";

    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.chienpm.zimagesample", appContext.getPackageName());
    }

    @Test
    public void crawImage(){
        //https://api.imgur.com/3/gallery/search/viral/%7Bpage%7D?q_type=jpg&client_id=546c25a59c58ad7&q=school
        StringBuffer response = null;
        String keywords[] = new String[]{"messi", "ronaldo", "neymar", "rooney", "torres", "kaka", "tom", "jerry"};
        String keywords2[] = new String[]{"lady", "girl", "marie", "lan-ngoc", "ngoc-trinh"};
        String clientId = "546c25a59c58ad7";

        JSONObject json = null;

        int count = 0;
        for(String keyword: keywords2) {
            for (int page = 1; page < 5; page++) {
                try {
                    URL apiURL = new URL("https://api.imgur.com/3/gallery/search/viral/" + page + "?q_type=jpg&client_id=" + clientId + "&q=" + keyword);
                    HttpURLConnection connection = (HttpURLConnection) apiURL.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setReadTimeout(10000); //10 seconds

                    int responseCode = connection.getResponseCode();

                    if (responseCode == HttpURLConnection.HTTP_OK) {
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                        String inputLine;
                        response = new StringBuffer();

                        // read data
                        while ((inputLine = bufferedReader.readLine()) != null) {
                            response.append(inputLine);
                        }

                        // process data
                        try {

                            json = new JSONObject(response.toString());

                            JSONArray galleries = json.getJSONArray("data");

                            for (int i = 0; i < galleries.length(); ++i) {

                                if (galleries.getJSONObject(i).has("images")) {

                                    JSONArray images = galleries.getJSONObject(i).getJSONArray("images");

                                    for (int j = 0; j < images.length(); ++j) {

                                        JSONObject img = images.getJSONObject(j);
                                        if (img.has("link")) {
                                            String link = img.getString("link");
                                            if (!link.contains(".mp4")) {
                                                System.out.println(link);
                                            }
                                        }
                                    }
                                }

                            }

                        } catch (JSONException e) {
                            e.printStackTrace();
                            System.out.println("error: " + e.getMessage());
                            json = null;
                        }


                    } else {
                        System.out.println("GET request not worked");
                    }


                } catch (MalformedURLException e) {
                    e.printStackTrace();
                    response = null;
                } catch (IOException e) {
                    e.printStackTrace();
                    response = null;
                }
            }
        }

        System.out.printf(json.toString());

        assertNotNull(response);
        assertTrue(response.length() > 0);
    }

    public List<String> loadImages(){
        List<String> images = new ArrayList<>();

        try {

            Context testContext = InstrumentationRegistry.getInstrumentation().getContext();
            InputStream inputStream = testContext.getAssets().open("images.txt");

            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));

            String line;

            while ((line = bufferedReader.readLine())!=null){
                images.add(line);
                System.out.println(line);
            }

        } catch (IOException e) {
            e.printStackTrace();
            images.clear();
        }

        assertTrue(images.size()>0);
        return  images;
    }
}
```


Overlapping Code:
```
c class TestPerformance {
private static final String TAG = "TestPerformance";
@Test
public void useAppContext() {
// Context of the app under test.
Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
assertEquals("com.chienpm.zimagesample", appContext.getPackageName());
}
@Test
public void crawImage(){
//https://api.imgur.com/3/gallery/search/viral/%7Bpage%7D?q_type=jpg&client_id=546c25a59c58ad7&q=school
StringBuffer response = null;
String keywords[] = new String[]{"messi", "ronaldo", "neymar", "rooney", "torres", "kaka", "tom", "jerry"};
String keywords2[] = new String[]{"lady", "girl", "marie", "lan-ngoc", "ngoc-trinh"};
String clientId = "546c25a59c58ad7";
JSONObject json = null;
int count = 0;
for(String keyword: keywords2) {
for (int page = 1; page < 5; page++) {
try {
URL apiURL = new URL("https://api.imgur.com/3/gallery/search/viral/" + page + "?q_type=jpg&client_id=" + clientId + "&q=" + keyword);
HttpURLConnection connection = (HttpURLConnection) apiURL.openConnection();
connection.setRequestMethod("GET");
connection.setReadTimeout(10000); //10 seconds
int responseCode = connection.getResponseCode();
if (responseCode == HttpURLConnection.HTTP_OK) {
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
String inputLine;
response = new StringBuffer();
// read data
while ((inputLine = bufferedReader.readLine()) != null) {
response.append(inputLine);
}
// process data
try {
json = new JSONObject(response.toString());
JSONArray galleries = json.getJSONArray("data");
for (int i = 0; i < galleries.length(); ++i) {
if (galleries.getJSONObject(i).has("images")) {
JSONArray images = galleries.getJSONObject(i).getJSONArray("images");
for (int j = 0; j < images.length
```
<Overlap Ratio: 0.9796255506607929>

---

--- 367 --
Question ID: f921f6507cad2c813014192f14a31ca2fce652a1
Original Code:
```
public class ModelManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final KeyboardFlashCards keyboardFlashCards;
    private final UserPrefs userPrefs;
    private final FilteredList<FlashCard> filteredFlashCards;
    private final FilteredList<Deadline> filteredDeadlines;
    private final FilteredList<Category> categoryList;
    private FlashCardTestModel flashCardTestModel;
    private ArrayList<Float> performance;


    /**
     * Initializes a ModelManager with the given keyboardFlashCards and userPrefs.
     */
    public ModelManager(ReadOnlyKeyboardFlashCards addressBook, ReadOnlyUserPrefs userPrefs) {
        super();
        requireAllNonNull(addressBook, userPrefs);

        logger.fine("Initializing with address book: " + addressBook + " and user prefs " + userPrefs);

        this.keyboardFlashCards = new KeyboardFlashCards(addressBook);
        this.userPrefs = new UserPrefs(userPrefs);
        filteredFlashCards = new FilteredList<>(this.keyboardFlashCards.getFlashcardList());
        filteredDeadlines = new FilteredList<>(this.keyboardFlashCards.getDeadlineList());
        categoryList = new FilteredList<>(this.keyboardFlashCards.getCategoryList());
        flashCardTestModel = new FlashCardTestModel(new LinkedList<>());
        this.performance = new ArrayList<Float>();
    }

    public ModelManager() {
        this(new KeyboardFlashCards(), new UserPrefs());
    }

    //=========== UserPrefs ==================================================================================

    @Override
    public void setUserPrefs(ReadOnlyUserPrefs userPrefs) {
        requireNonNull(userPrefs);
        this.userPrefs.resetData(userPrefs);
    }

    @Override
    public ReadOnlyUserPrefs getUserPrefs() {
        return userPrefs;
    }

    @Override
    public GuiSettings getGuiSettings() {
        return userPrefs.getGuiSettings();
    }

    @Override
    public void setGuiSettings(GuiSettings guiSettings) {
        requireNonNull(guiSettings);
        userPrefs.setGuiSettings(guiSettings);
    }

    public void setStyleSheet(String styleSheet) {
        userPrefs.setStyleSheet(styleSheet);
    }

    public String getStyleSheet() {
        return userPrefs.getStyleSheet();
    }

    @Override
    public Path getKeyboardFlashCardsFilePath() {
        return userPrefs.getKeyboardFlashCardsFilePath();
    }

    @Override
    public void setKeyboardFlashCardsFilePath(Path keyboardFlashCardsFilePath) {
        requireNonNull(keyboardFlashCardsFilePath);
        userPrefs.setKeyboardFlashCardsFilePath(keyboardFlashCardsFilePath);
    }

    //=========== KeyboardFlashCards ================================================================================

    @Override
    public void setKeyboardFlashCards(ReadOnlyKeyboardFlashCards keyboardFlashCards) {
        this.keyboardFlashCards.resetData(keyboardFlashCards);
    }

    @Override
    public ReadOnlyKeyboardFlashCards getKeyboardFlashCards() {
        return keyboardFlashCards;
    }

    @Override
    public boolean hasFlashcard(FlashCard flashCard) {
        requireNonNull(flashCard);
        return keyboardFlashCards.hasFlashcard(flashCard);
    }

    @Override
    public void deleteFlashCard(FlashCard target) {
        keyboardFlashCards.removeFlashCard(target);
    }

    //@@author shutingy
    @Override
    public void addFlashCard(FlashCard flashCard) {
        keyboardFlashCards.addFlashcard(flashCard);
        updateFilteredFlashCardList(PREDICATE_SHOW_ALL_FLASHCARDS);
        updateFilteredCategoryList(PREDICATE_SHOW_ALL_CATEGORIES);
    }

    @Override
    public void setFlashCard(FlashCard target, FlashCard editedFlashCard) {
        requireAllNonNull(target, editedFlashCard);

        keyboardFlashCards.setFlashcard(target, editedFlashCard);
    }

    @Override
    public void addDeadline(Deadline deadline) {
        keyboardFlashCards.addDeadline(deadline);
        updateFilteredDeadlineList(PREDICATE_SHOW_ALL_DEADLINES);
    }

    @Override
    public boolean hasDeadline(Deadline deadline) {
        requireNonNull(deadline);
        return keyboardFlashCards.hasDeadline(deadline);
    }

    //@@author LeonardTay748
    @Override
    public void editStats(int type) {
        if (type == 0) {
            keyboardFlashCards.addGood();
        }
        if (type == 1) {
            keyboardFlashCards.addHard();
        }
        if (type == 2) {
            keyboardFlashCards.addEasy();
        }
    }

    public int[] getTestStats() {
        return keyboardFlashCards.getStats();
    }

    @Override
    public ArrayList<Float> getPerformance() {
        return performance;
    }

    @Override
    public void updatePerformance(Model model) {
        requireNonNull(model);
        float numGood = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate("good")).size();
        float numHard = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate("hard")).size();
        float numEasy = model.getFilteredFlashCardListNoCommit(new RatingContainsKeywordPredicate("easy")).size();
        float value;
        if ((numEasy + numGood + numHard) == 0) {
            value = 0;
        } else {
            value = ((numEasy + numGood) * 100) / (numEasy + numGood + numHard);
        }
        performance.add(value);
    }

    @Override
    public void resetPerformance(Model model) {
        requireNonNull(model);
        performance.clear();
    }

    @Override
    public void deleteDeadline(Deadline target) {
        keyboardFlashCards.removeDeadline(target);
    }

    @Override
    public void setDeadline(Deadline target, Deadline editedDeadline) {
        requireAllNonNull(target, editedDeadline);
        keyboardFlashCards.setDeadline(target, editedDeadline);
    }


    //=========== Filtered FlashCard List Accessors =============================================================

    /**
     * Returns an unmodifiable view of the list of {@code FlashCard} backed by the internal list of
     * {@code versionedAddressBook}
     */
    @Override
    public ObservableList<FlashCard> getFilteredFlashCardList() {
        return filteredFlashCards;
    }

    @Override
    public void updateFilteredFlashCardList(Predicate<FlashCard> predicate) {
        requireNonNull(predicate);
        filteredFlashCards.setPredicate(predicate);
    }

    //=========== Filtered Deadline List Accessors =============================================================

    /**
     * Returns an unmodifiable view of the list of {@code Deadline} backed by the internal list of
     * {@code versionedAddressBook}
     */
    @Override
    public ObservableList<Deadline> getFilteredDeadlineList() {
        return filteredDeadlines;
    }

    @Override
    public void updateFilteredDeadlineList(Predicate<Deadline> predicate) {
        requireNonNull(predicate);
        filteredDeadlines.setPredicate(predicate);
    }

    //@@author keiteo
    @Override
    public ObservableList<FlashCard> getFlashCardList() {
        return keyboardFlashCards.getFlashcardList();
    }

    //=========== FlashCardTestModel ================================================================================
    @Override
    public void initializeTestModel(List<FlashCard> testList) {
        flashCardTestModel = new FlashCardTestModel(testList);
    }

    @Override
    public boolean hasTestFlashCard() {
        return !flashCardTestModel.isEmpty();
    }

    @Override
    public void setTestFlashCard() {
        flashCardTestModel.setFlashcard();
    }

    @Override
    public String getTestQuestion() {
        return flashCardTestModel.getQuestion();
    }

    @Override
    public String getTestAnswer() {
        return flashCardTestModel.getAnswer();
    }

    @Override
    public FlashCard getCurrentTestFlashCard() {
        return flashCardTestModel.getCurrentFlashCard();
    }

    //@@author shutingy
    @Override
    public TestFlashCardPanel getTestFlashCardPanel() {
        return flashCardTestModel.getTestFlashCardPanel();
    }

    @Override
    public void showAnswer() {
        flashCardTestModel.showAnswer();
    }

    //@@author LeowWB
    @Override
    public ObservableList<FlashCard> getFilteredFlashCardListNoCommit(Predicate<FlashCard> predicate) {
        requireNonNull(predicate);
        FilteredList<FlashCard> simulatedList = new FilteredList<FlashCard>(filteredFlashCards);
        simulatedList.setPredicate(predicate);
        return simulatedList;
    }

    //@@author shutingy
    @Override
    public ObservableList<Category> getCategoryList() {
        return categoryList;
    }

    //@@author shutingy
    @Override
    public void updateFilteredCategoryList(Predicate<Category> predicate) {
        requireNonNull(predicate);
        categoryList.setPredicate(predicate);
    }

    @Override
    public boolean equals(Object obj) {
        // short circuit if same object
        if (obj == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(obj instanceof ModelManager)) {
            return false;
        }

        // state check
        ModelManager other = (ModelManager) obj;
        return keyboardFlashCards.equals(other.keyboardFlashCards)
                && userPrefs.equals(other.userPrefs)
                && filteredFlashCards.equals(other.filteredFlashCards)
                && categoryList.equals(other.categoryList)
                && filteredDeadlines.equals(other.filteredDeadlines)
                && flashCardTestModel.equals(other.flashCardTestModel);
    }

}
```


Overlapping Code:
```
public class ModelManager implements Model {
private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
private final KeyboardFlashCards keyboardFlashCards;
private final UserPrefs userPrefs;
private final FilteredList<FlashCard> filteredFlashCards;
private final FilteredList<Deadline> filteredDeadlines;
private final FilteredList<Category> categoryList;
private FlashCardTestModel flashCardTestModel;
private ArrayList<Float> performance;
/**
* Initializes a ModelManager with the given keyboardFlashCards and userPrefs.
*/
public ModelManager(ReadOnlyKeyboardFlashCards addressBook, ReadOnlyUserPrefs userPrefs) {
super();
requireAllNonNull(addressBook, userPrefs);
logger.fine("Initializing with address book: " + addressBook + " and user prefs " + userPrefs);
this.keyboardFlashCards = new KeyboardFlashCards(addressBook);
this.userPrefs = new UserPrefs(userPrefs);
filteredFlashCards = new FilteredList<>(this.keyboardFlashCards.getFlashcardList());
filteredDeadlines = new FilteredList<>(this.keyboardFlashCards.getDeadlineList());
categoryList = new FilteredList<>(this.keyboardFlashCards.getCategoryList());
flashCardTestModel = new FlashCardTestModel(new LinkedList<>());
this.performance = new ArrayList<Float>();
}
public ModelManager() {
this(new KeyboardFlashCards(), new UserPrefs());
}
//=========== UserPrefs ==================================================================================
@Override
public void setUserPrefs(ReadOnlyUserPrefs userPrefs) {
requireNonNull(userPrefs);
this.userPrefs.resetData(userPrefs);
}
@Override
public ReadOnlyUserPrefs getUserPrefs() {
return userPrefs;
}
@Override
public GuiSettings getGuiSettings() {
return userPrefs.getGuiSettings();
}
@Override
public void setGuiSettings(GuiSettings guiSettings) {
requireNonNull(guiSettings);
userPrefs.setGuiSettings(guiSettings);
}
public void setStyleSheet(String styleSheet) {
userPrefs.setStyleSheet(styleSheet);
}
public String getStyleSheet() {
return userPrefs.getStyleSheet();
}
@Override
public Path getKeyboardFlashCardsFilePath() {
return userPrefs.getKeyboardFlashCardsFilePath();
}
@Override
public void setKeyboardFlashCardsFile
```
<Overlap Ratio: 0.9944802207911684>

---

--- 368 --
Question ID: 0f01c3ec9f23839a634e5ec961653b94040384e0
Original Code:
```
@Component
public class ResourceGenerator {

    public Resource<OperationDto> getOperationResource(OperationDto operationDto) {
        Resource<OperationDto> resource = new Resource<>(operationDto);
        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(OperationController.class)
                .getOperation(operationDto.getIdUser(), operationDto.getIdOperation())).withRel("self"));
        return resource;
    }

    public Resource<UserDto> getUserResource(UserDto userDto) {
        Resource<UserDto> resource = new Resource<>(userDto);
        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(UserController.class)
                .getUserProfile(userDto.getId())).withRel("self"));
        return resource;
    }

    public Resource<ProductDto> getProductResource(ProductDto productDto) {
        Resource<ProductDto> resource = new Resource<>(productDto);
        resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ProductController.class)
                .getProduct(productDto.getIdProduct())).withRel("self"));
        return resource;
    }

    public Resource<PageDto<Resource<ProductDto>>> getProductsResource(Collection<ProductDto> products, Long totalElements, Integer numberOfElements) {
        List<Resource<ProductDto>> list = products.stream().map(this::getProductResource).collect(Collectors.toList());
        return new Resource<>(PageDto.of(list, totalElements, numberOfElements));
    }
}
```


Overlapping Code:
```
tor {
public Resource<OperationDto> getOperationResource(OperationDto operationDto) {
Resource<OperationDto> resource = new Resource<>(operationDto);
resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(OperationController.class)
.getOperation(operationDto.getIdUser(), operationDto.getIdOperation())).withRel("self"));
return resource;
}
public Resource<UserDto> getUserResource(UserDto userDto) {
Resource<UserDto> resource = new Resource<>(userDto);
resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(UserController.class)
.getUserProfile(userDto.getId())).withRel("self"));
return resource;
}
public Resource<ProductDto> getProductResource(ProductDto productDto) {
Resource<ProductDto> resource = new Resource<>(productDto);
resource.add(ControllerLinkBuilder.linkTo(ControllerLinkBuilder.methodOn(ProductController.class)
.getProduct(productDto.getIdProduct())).withRel("self"));
return resource;
}
public Resource<PageDto<Resource<ProductDto>>> getProductsResource(Collection<ProductDto> products, Long totalElements, Integer numberOfElements) {
List<Resource<ProductDto>> list = products.stream().map(this::getProductResource).collect(Collectors.toList());
return new Resource<>(PageDto.of(list, total
```
<Overlap Ratio: 0.9462528387585163>

---

--- 369 --
Question ID: c13091d0c7466e5f8048a3bb2ad4d509bc95d48f
Original Code:
```
public class BarcodeGeneratorProvider {

    private static BarcodeGeneratorProvider instance;
    private static final Logger LOGGER = Logger.getLogger(BarcodeGeneratorProvider.class.getName());
    private final ServiceLoader<BarcodeGenerator> loader;
    private final ConcurrentMap<String, Class<BarcodeGenerator>> barcodeGenerators;

    /**
     * Initialize this singleton.
     */
    private BarcodeGeneratorProvider() {
        this.barcodeGenerators = new ConcurrentHashMap<String, Class<BarcodeGenerator>>();
        loader = ServiceLoader.load(BarcodeGenerator.class);
        initialize();
    }

    /**
     * Gets the Provider.
     *
     * @return single instance
     */
    public static synchronized BarcodeGeneratorProvider getInstance() {
        if (instance == null) {
            instance = new BarcodeGeneratorProvider();
            LOGGER.log(Level.INFO, "Created new instance.");
        }
        return instance;
    }

    /**
     * Lists all names of available BarcodeGenerators.
     *
     * @return Set of available BarcodeGenerator names
     */
    public Collection<String> getAvailableBarcodeGenerators() {
        final Set<String> res = new TreeSet<String>();
        res.addAll(barcodeGenerators.keySet());
        return res;
    }

    /**
     * Instanciates a fresh copy of a BarcodeGenerator.
     *
     * @param id Name of Barcode ({@link #getAvailableBarcodeGenerators() })
     * @return a fresh copy
     * @throws BarcodeException if barcode with {@code id} is not available 
     */
    public BarcodeGenerator getBarcodeGenerator(String id) throws BarcodeException {
        final Class<BarcodeGenerator> clazz = barcodeGenerators.get(id);

        if (clazz == null) {
            throw new BarcodeException("BarcodeGenerator with " + id + " is not available.");
        }

        BarcodeGenerator res = null;
        try {
            res = clazz.newInstance();
        } catch (InstantiationException ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        }
        return res;
    }

    /**
     * Loads all implementing Classes through ServiceLoader interface.
     */
    private void initialize() {
        final Iterator<BarcodeGenerator> iterator = loader.iterator();
        while (iterator.hasNext()) {
            try {
                final BarcodeGenerator bg = iterator.next();
                final String id = bg.getId();
                @SuppressWarnings("unchecked")
                final Class<BarcodeGenerator> clazz = (Class<BarcodeGenerator>) bg.getClass();
                barcodeGenerators.put(id, clazz);
                final Collection<String> addIds = bg.getAdditionalNames();
                if (addIds != null) {
                    for (final String addId : addIds) {
                        barcodeGenerators.putIfAbsent(addId, clazz);
                    }
                }
            } catch (ServiceConfigurationError e) {
                LOGGER.log(Level.WARNING,
                        "Failed to load a BarcodeGenerator service.", e);
            }
        }
        if (LOGGER.isLoggable(Level.INFO)) {
            LOGGER.info("Available BarcodeGenerators: ");
            for (final Map.Entry<String, Class<BarcodeGenerator>> entrySet : barcodeGenerators.entrySet()) {
                final String key = entrySet.getKey();
                final Class<BarcodeGenerator> value = entrySet.getValue();
                LOGGER.log(Level.INFO, "{0} -> {1}", new Object[]{key, value.getName()});
            }
        }
    }
}
```


Overlapping Code:
```
eGeneratorProvider {
private static BarcodeGeneratorProvider instance;
private static final Logger LOGGER = Logger.getLogger(BarcodeGeneratorProvider.class.getName());
private final ServiceLoader<BarcodeGenerator> loader;
private final ConcurrentMap<String, Class<BarcodeGenerator>> barcodeGenerators;
/**
* Initialize this singleton.
*/
private BarcodeGeneratorProvider() {
this.barcodeGenerators = new ConcurrentHashMap<String, Class<BarcodeGenerator>>();
loader = ServiceLoader.load(BarcodeGenerator.class);
initialize();
}
/**
* Gets the Provider.
*
* @return single instance
*/
public static synchronized BarcodeGeneratorProvider getInstance() {
if (instance == null) {
instance = new BarcodeGeneratorProvider();
LOGGER.log(Level.INFO, "Created new instance.");
}
return instance;
}
/**
* Lists all names of available BarcodeGenerators.
*
* @return Set of available BarcodeGenerator names
*/
public Collection<String> getAvailableBarcodeGenerators() {
final Set<String> res = new TreeSet<String>();
res.addAll(barcodeGenerators.keySet());
return res;
}
/**
* Instanciates a fresh copy of a BarcodeGenerator.
*
* @param id Name of Barcode ({@link #getAvailableBarcodeGenerators() })
* @return a fresh copy
* @throws BarcodeException if barcode with {@code id} is not available 
*/
public BarcodeGenerator getBarcodeGenerator(String id) throws BarcodeException {
final Class<BarcodeGenerator> clazz = barcodeGenerators.get(id);
if (clazz == null) {
throw new BarcodeException("BarcodeGenerator with " + id + " is not available.");
}
BarcodeGenerator res = null;
try {
res = clazz.newInstance();
} catch (InstantiationException ex) {
LOGGER.log(Level.SEVERE, null, ex);
} catch (IllegalAccessException ex) {
LOGGER.log(Level.SEVERE, null, ex);
}
return res;
}
/**
* Loads all implementing Classes through ServiceLoader interface.
*/
private void initialize() {
final Iterator<BarcodeGenerator> iterator = loader.iterator();
while (iterator.hasNext()) {
try {
final BarcodeGenerator bg = iterator.next();
f
```
<Overlap Ratio: 0.9775937652216269>

---

--- 370 --
Question ID: 27e4bf1831937dadd8cc6819de7f541347644bec
Original Code:
```
public class Verlet extends AbstractODESolver {
  private double[] rate1;       // stores the initial rate
  private double[] rate2;       // used to compute the estimated the acceleration at x(n+1).
  private int rateCounter = -1; // step has not yet been called

  /**
   * Constructs the velocity Verlet ODESolver for a system of ordinary  differential equations.
   *
   * @param ode the system of differential equations.
   */
  public Verlet(ODE ode) {
    super(ode);
  }

  /**
   * Initializes the ODE solver.
   *
   * The rate array is allocated.  The number of differential equations is
   * determined by invoking getState().length on the ODE.
   *
   * @param stepSize
   */
  public void initialize(double stepSize) {
    super.initialize(stepSize);
    rate1 = new double[numEqn];
    rate2 = new double[numEqn];
    rateCounter = -1; // step has not yet been called
  }

  /**
   * Gets the counter that records the number of times the rate has been evaluated during the current step.
   *
   * This method allows a model to improve its performance
   * by enabling the model to determine if this is the first or second time that the rate is being evaluated.
   * The Verlet algorithm first invokes the model's getRate method to update the position and
   * then again to update velocity.  Because the force at the new position is computed the
   * second time that getRate is invoked, a model can improve its performance if it skips the force computation
   * during the first call to getRate.
   *
   * A typical dynamics simulation should comptute the force when rateCounter is one and stores this force
   * for use during the next postion update.
   *
   * The Verlet algorithm will perform correctly (but more slowly) if the
   * force is computed every time that getRate is invoked.
   *
   * @return int  the counter
   */
  public int getRateCounter() {
    return rateCounter;
  }

  /**
   * Steps (advances) the differential equations by the stepSize.
   *
   * The ODESolver invokes the ODE's getState method to obtain the initial state of the system.
   * The ODESolver advances the solution and copies the new state into the
   * state array at the end of the solution step.
   *
   * @return the step size
   */
  public double step() {
    // state[]: x1, d x1/dt, x2, d x2/dt .... xN, d xN/dt, t
    double[] state = ode.getState();
    if(state.length!=numEqn) {
      initialize(stepSize);
    }
    rateCounter = 0; // getRate has not been called
    ode.getRate(state, rate1); // get the initial rate
    double dt2 = stepSize*stepSize; // the step size squared
    // increment the positions using the velocity and acceleration
    for(int i = 0; i<numEqn-1; i += 2) {
      state[i] += stepSize*rate1[i]+dt2*rate1[i+1]/2;
    }
    rateCounter = 1; // getRate has been called once
    ode.getRate(state, rate2); // rate at the new positions
    rateCounter = 2; // getRate has been called twice
    for(int i = 1; i<numEqn; i += 2) {
      // increment the velocities with the average rate
      state[i] += stepSize*(rate1[i]+rate2[i])/2.0;
    }
    if(numEqn%2==1) {                              // last equation if  we have an odd number of equations
      state[numEqn-1] += stepSize*rate1[numEqn-1]; // usually the independent variable
    }
    return stepSize;
  }

}
```


Overlapping Code:
```
olver {
private double[] rate1; // stores the initial rate
private double[] rate2; // used to compute the estimated the acceleration at x(n+1).
private int rateCounter = -1; // step has not yet been called
/**
* Constructs the velocity Verlet ODESolver for a system of ordinary differential equations.
*
* @param ode the system of differential equations.
*/
public Verlet(ODE ode) {
super(ode);
}
/**
* Initializes the ODE solver.
*
* The rate array is allocated. The number of differential equations is
* determined by invoking getState().length on the ODE.
*
* @param stepSize
*/
public void initialize(double stepSize) {
super.initialize(stepSize);
rate1 = new double[numEqn];
rate2 = new double[numEqn];
rateCounter = -1; // step has not yet been called
}
/**
* Gets the counter that records the number of times the rate has been evaluated during the current step.
*
* This method allows a model to improve its performance
* by enabling the model to determine if this is the first or second time that the rate is being evaluated.
* The Verlet algorithm first invokes the model's getRate method to update the position and
* then again to update velocity. Because the force at the new position is computed the
* second time that getRate is invoked, a model can improve its performance if it skips the force computation
* during the first call to getRate.
*
* A typical dynamics simulation should comptute the force when rateCounter is one and stores this force
* for use during the next postion update.
*
* The Verlet algorithm will perform correctly (but more slowly) if the
* force is computed every time that getRate is invoked.
*
* @return int the counter
*/
public int getRateCounter() {
return rateCounter;
}
/**
* Steps (advances) the differential equations by the stepSize.
*
* The ODESolver invokes the ODE's getState method to obtain the initial state of the system.
* The ODESolver advances the solution and copies the new state into the
* state array at the end of the solution step.
*
* @return the step size
*/
public double step() {
// state[]: x1, d x1/dt, x2, d x2/dt .... xN, d xN/dt, t
double[] state = ode.getState();
if(state.length!=num
```
<Overlap Ratio: 0.968609865470852>

---

--- 371 --
Question ID: 787ae5d06251a17281a109162229ea75b94c435d
Original Code:
```
public class UuidTypeHandler extends BaseTypeHandler<UUID> {
    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, UUID uuid, JdbcType jdbcType) throws SQLException {
        preparedStatement.setString(i, uuid.toString());
    }

    @Override
    public UUID getNullableResult(ResultSet resultSet, String s) throws SQLException {
        String uuidString = resultSet.getString(s);
        if (uuidString != null) {
            return UUID.fromString(uuidString);
        }
        return null;
    }

    @Override
    public UUID getNullableResult(ResultSet resultSet, int i) throws SQLException {
        String uuidString = resultSet.getString(i);
        if (uuidString != null) {
            return UUID.fromString(uuidString);
        }
        return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
        String uuidString = callableStatement.getString(i);
        if (uuidString != null) {
            return UUID.fromString(uuidString);
        }
        return null;
    }
}
```


Overlapping Code:
```
public class UuidTypeHandler extends BaseTypeHandler<UUID> {
@Override
public void setNonNullParameter(PreparedStatement preparedStatement, int i, UUID uuid, JdbcType jdbcType) throws SQLException {
preparedStatement.setString(i, uuid.toString());
}
@Override
public UUID getNullableResult(ResultSet resultSet, String s) throws SQLException {
String uuidString = resultSet.getString(s);
if (uuidString != null) {
return UUID.fromString(uuidString);
}
return null;
}
@Override
public UUID getNullableResult(ResultSet resultSet, int i) throws SQLException {
String uuidString = resultSet.getString(i);
if (uuidString != null) {
return UUID.fromString(uuidString);
}
return null;
}
@Override
public UUID getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
String uuidString = callableStatement.getString(i);
if (uuidString != null) {
return UUID.fromString(uuidString);

```
<Overlap Ratio: 0.9803707742639041>

---

--- 372 --
Question ID: 61af6386948720266369806342cde60c6f0f893f
Original Code:
```
public class MergeSequenceTest
{
  @Test
  public void testSanity() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(1, 3, 5, 7, 9),
        TestSequence.create(2, 8),
        TestSequence.create(4, 6, 8)
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testWorksWhenBeginningOutOfOrder() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(2, 8),
        TestSequence.create(1, 3, 5, 7, 9),
        TestSequence.create(4, 6, 8)
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testMergeEmpties() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(1, 3, 5, 7, 9),
        TestSequence.create(),
        TestSequence.create(2, 8),
        TestSequence.create(4, 6, 8)
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testMergeEmpties1() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(),
        TestSequence.create(1, 3, 5, 7, 9),
        TestSequence.create(2, 8),
        TestSequence.create(4, 6, 8)
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testMergeEmpties2() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(1, 3, 5, 7, 9),
        TestSequence.create(2, 8),
        TestSequence.create(),
        TestSequence.create(4, 6, 8),
        TestSequence.create()
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testScrewsUpOnOutOfOrder() throws Exception
  {
    final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
        TestSequence.create(1, 3, 5, 4, 7, 9),
        TestSequence.create(2, 8),
        TestSequence.create(4, 6)
    );

    MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
    SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 4, 6, 7, 8, 9));

    for (TestSequence<Integer> sequence : testSeqs) {
      Assert.assertTrue(sequence.isClosed());
    }
  }

  @Test
  public void testHierarchicalMerge() throws Exception
  {
    final Sequence<Integer> seq1 = new MergeSequence<>(
        Ordering.natural(), Sequences.simple(
        Collections.singletonList(TestSequence.create(1))
    )
    );

    final Sequence<Integer> finalMerged = new MergeSequence<>(
        Ordering.natural(),
        Sequences.simple(
            Collections.singletonList(seq1)
        )
    );

    SequenceTestHelper.testAll(finalMerged, Collections.singletonList(1));
  }

  @Test
  public void testMergeOne() throws Exception
  {
    final Sequence<Integer> mergeOne = new MergeSequence<>(
        Ordering.natural(), Sequences.simple(
        Collections.singletonList(TestSequence.create(1))
    )
    );

    SequenceTestHelper.testAll(mergeOne, Collections.singletonList(1));
  }

}
```


Overlapping Code:
```
enceTest
{
@Test
public void testSanity() throws Exception
{
final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
TestSequence.create(1, 3, 5, 7, 9),
TestSequence.create(2, 8),
TestSequence.create(4, 6, 8)
);
MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));
for (TestSequence<Integer> sequence : testSeqs) {
Assert.assertTrue(sequence.isClosed());
}
}
@Test
public void testWorksWhenBeginningOutOfOrder() throws Exception
{
final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
TestSequence.create(2, 8),
TestSequence.create(1, 3, 5, 7, 9),
TestSequence.create(4, 6, 8)
);
MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));
for (TestSequence<Integer> sequence : testSeqs) {
Assert.assertTrue(sequence.isClosed());
}
}
@Test
public void testMergeEmpties() throws Exception
{
final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
TestSequence.create(1, 3, 5, 7, 9),
TestSequence.create(),
TestSequence.create(2, 8),
TestSequence.create(4, 6, 8)
);
MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));
for (TestSequence<Integer> sequence : testSeqs) {
Assert.assertTrue(sequence.isClosed());
}
}
@Test
public void testMergeEmpties1() throws Exception
{
final ArrayList<TestSequence<Integer>> testSeqs = Lists.newArrayList(
TestSequence.create(),
TestSequence.create(1, 3, 5, 7, 9),
TestSequence.create(2, 8),
TestSequence.create(4, 6, 8)
);
MergeSequence<Integer> seq = new MergeSequence<>(Ordering.<Integer>natural(), (Sequence) Sequences.simple(testSeqs));
SequenceTestHelper.testAll(seq, Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 8, 9));
for (TestSequence<Integer> sequence : testSeqs) {
Assert.assertTrue(sequence.isClosed());
}
}
@Test
public void testMergeEmpties2() throws Exception

```
<Overlap Ratio: 0.9792137370085856>

---

--- 373 --
Question ID: 8d541a1d9f20d73c4badbd20839a934045baf6a1
Original Code:
```
public class SumNumbers {
  public static void main(String[] args) {
    String sample = "aa11b33";
    System.out.println("Output : " + sumNumbers(sample));
  }

  /**
   * Sum the numbers in the given string.
   * @param str
   * @return
   */
  public static int sumNumbers(String str) {
    int sum = 0;
    StringBuffer str_number = new StringBuffer();
    for (int i = 0; i < str.length(); i++) {
      if (Character.isDigit(str.charAt(i))) {
        str_number.append(str.charAt(i));
      } else if (str_number.length() > 0) {
        sum = sum + Integer.parseInt(str_number.toString());
        str_number = new StringBuffer();
      }
    }
    if (str_number.length() > 0) {
      sum = sum + Integer.parseInt(str_number.toString());
      return sum;
    }
    return sum;
  }
}
```


Overlapping Code:
```
public class SumNumbers {
public static void main(String[] args) {
String sample = "aa11b33";
System.out.println("Output : " + sumNumbers(sample));
}
/**
* Sum the numbers in the given string.
* @param str
* @return
*/
public static int sumNumbers(String str) {
int sum = 0;
StringBuffer str_number = new StringBuffer();
for (int i = 0; i < str.length(); i++) {
if (Character.isDigit(str.charAt(i))) {
str_number.append(str.charAt(i));
} else if (str_number.length() > 0) {
sum = sum + Integer.parseInt(str_number.toString());
str_number = new StringBuffer();
}
}
if (str_number.length() > 0) {
sum = sum + Integer.parseInt(str_number
```
<Overlap Ratio: 0.9364844903988183>

---

--- 374 --
Question ID: 9a3bd858301c0018a4c593722f3dc858c19ccb1e
Original Code:
```
public class FeignClientScannerRegistrar implements ImportBeanDefinitionRegistrar {

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(FeignClientScan.class.getName()));
        ClassPathFeignClientScanner scanner = new ClassPathFeignClientScanner(registry);

        Class<?> markerInterface = annoAttrs.getClass("markerInterface");
        if (!Class.class.equals(markerInterface)) {
            scanner.setMarkerInterface(markerInterface);
        }

        scanner.setFeignBuilderBeanName(annoAttrs.getString("feignBuilderRef"));

        List<String> basePackages = new ArrayList<>();
        for (String pkg : annoAttrs.getStringArray("value")) {
            if (StringUtils.hasText(pkg)) {
                basePackages.add(pkg);
            }
        }
        for (String pkg : annoAttrs.getStringArray("basePackages")) {
            if (StringUtils.hasText(pkg)) {
                basePackages.add(pkg);
            }
        }
        scanner.registerFilters();
        scanner.doScan(StringUtils.toStringArray(basePackages));
    }

}
```


Overlapping Code:
```
lass FeignClientScannerRegistrar implements ImportBeanDefinitionRegistrar {
@Override
public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(FeignClientScan.class.getName()));
ClassPathFeignClientScanner scanner = new ClassPathFeignClientScanner(registry);
Class<?> markerInterface = annoAttrs.getClass("markerInterface");
if (!Class.class.equals(markerInterface)) {
scanner.setMarkerInterface(markerInterface);
}
scanner.setFeignBuilderBeanName(annoAttrs.getString("feignBuilderRef"));
List<String> basePackages = new ArrayList<>();
for (String pkg : annoAttrs.getStringArray("value")) {
if (StringUtils.hasText(pkg)) {
basePackages.add(pkg);
}
}
for (String pkg : annoAttrs.getStringArray("basePackages")) {
if (StringUtils.hasText(pkg)) {
basePackages.add(pkg);
}
}
scanner.registerFilters();
scanner.doScan(StringUtils.toStringArray(basePackages));
}

```
<Overlap Ratio: 0.9912790697674418>

---

--- 375 --
Question ID: e294d4fe5d44fa0721c53f7775d4a5198a2997c2
Original Code:
```
public class ModelCleanup implements OptimizerStateListener {
    private SimulationModel model;
    private ModelFactory factory;
    private DelayedDeleter deleter;

    @Inject
    public ModelCleanup(SimulationModel model, ModelFactory factory) {
        this.model = model;
        this.factory = factory;
        this.deleter = DelayedDeleter.activate();

        Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
    }

    private synchronized void shutdown() {
        try {
            if (model != null) {
                model.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            model = null;
        }
        try {
            if (factory != null) {
                factory.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            factory = null;
        }
        deleter.tryDelete();
    }

    @Override
    public void optimizationStarted(Optimizer optimizer) {}

    @Override
    public void optimizationStopped(Optimizer optimizer) {
        shutdown();
    }
}
```


Overlapping Code:
```
p implements OptimizerStateListener {
private SimulationModel model;
private ModelFactory factory;
private DelayedDeleter deleter;
@Inject
public ModelCleanup(SimulationModel model, ModelFactory factory) {
this.model = model;
this.factory = factory;
this.deleter = DelayedDeleter.activate();
Runtime.getRuntime().addShutdownHook(new Thread(this::shutdown));
}
private synchronized void shutdown() {
try {
if (model != null) {
model.close();
}
} catch (Exception e) {
e.printStackTrace();
} finally {
model = null;
}
try {
if (factory != null) {
factory.close();
}
} catch (Exception e) {
e.printStackTrace();
} finally {
factory = null;
}
deleter.tryDelete();
}
@Override
public void optimizationStarted(Optimizer optimizer) {}
@Override
public void optimizationStopped(Optimizer optimizer) {
shutdow
```
<Overlap Ratio: 0.9615384615384616>

---

--- 376 --
Question ID: c5f119c48b788ec270dfcd0edbc460c71dc48892
Original Code:
```
public class GeofenceTransitionsJobIntentService extends JobIntentService {

    private static final int JOB_ID = 573;

    private static final String CHANNEL_ID = "channel_01";

    public static final String TRANSITION = "TRANSITION";

    /**
     * Convenience method for enqueuing work in to this service.
     */
    public static void enqueueWork(Context context, Intent intent) {
        enqueueWork(context, GeofenceTransitionsJobIntentService.class, JOB_ID, intent);
    }
    /**
     * Handles incoming intents.
     * @param intent sent by Location Services. This Intent is provided to Location
     *               Services (inside a PendingIntent) when addGeofences() is called.
     */
    @SuppressLint("StringFormatInvalid")
    @Override
    protected void onHandleWork(Intent intent) {
        GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent(intent);
        if (geofencingEvent.hasError()) {
            return;
        }
        // Get the transition type.
        int geofenceTransition = geofencingEvent.getGeofenceTransition();
        List<Geofence> triggeringGeofences = geofencingEvent.getTriggeringGeofences();
        // Get the geofences that were triggered. A single event can trigger multiple geofences.
        // Get the transition details as a String.
        String geofenceTransitionDetails = getGeofenceTransitionDetails(geofenceTransition,
                triggeringGeofences);
        // Test that the reported transition was of interest.
        switch (geofenceTransition) {
            case Geofence.GEOFENCE_TRANSITION_ENTER:
                sendNotification(geofenceTransitionDetails, triggeringGeofences);
                startLocationService(triggeringGeofences);
                break;
            case Geofence.GEOFENCE_TRANSITION_EXIT:
                stopLocationService();
                break;
            case Geofence.GEOFENCE_TRANSITION_DWELL:
                stopLocationService();
                break;
            default:
                break;
        }
        // Send notification and log the transition details.
        broadcastGeofenceTransition(triggeringGeofences, geofenceTransition);
    }

    /**
     * Gets transition details and returns them as a formatted string.
     *
     * @param geofenceTransition    The ID of the geofence transition.
     * @param triggeringGeofences   The geofence(s) triggered.
     * @return                      The transition details formatted as String.
     */
    private String getGeofenceTransitionDetails(int geofenceTransition,
                                                List<Geofence> triggeringGeofences) {

        String geofenceTransitionString = getTransitionString(geofenceTransition);

        // Get the Ids of each geofence that was triggered.
        ArrayList<String> triggeringGeofencesIdsList = new ArrayList<>();
        for (Geofence geofence : triggeringGeofences) {
            triggeringGeofencesIdsList.add(geofence.getRequestId());
        }
        String triggeringGeofencesIdsString = TextUtils.join(", ",  triggeringGeofencesIdsList);

        return geofenceTransitionString + ": " + triggeringGeofencesIdsString;
    }

    /**
     * Posts a notification in the notification bar when a transition is detected.
     * If the user clicks the notification, control goes to the MainActivity.
     */
    private void sendNotification(String notificationDetails, List<Geofence> geofenceList) {
        ArrayList<String> fencesTriggersIdList = new ArrayList<>();
        // Get an instance of the Notification manager
        NotificationManager mNotificationManager =
                (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);

        createNotificationChannel();

        for(Geofence geofence : geofenceList){
            fencesTriggersIdList.add(geofence.getRequestId());
        }

        NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID)
                .setSmallIcon(R.drawable.notifications_smart_parking)
                .setLargeIcon(BitmapFactory.decodeResource(getResources(),
                        R.drawable.notifications_smart_parking))
                .setTimeoutAfter(Constants.getMinutesInMilliseconds() * 5)
                .setColor(Color.GREEN)
                .setContentTitle(notificationDetails)
                .setContentText(getString(R.string.geofence_transition_notification_text))
                .setPriority(NotificationCompat.PRIORITY_HIGH)
                .setAutoCancel(true);

        // Set the Channel ID for Android O.
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            builder.setChannelId(CHANNEL_ID); // Channel ID
        }
        // Issue the notification
        mNotificationManager.notify(0, builder.build());
    }

    /**
     * Maps geofence transition types to their human-readable equivalents.
     *
     * @param transitionType    A transition type constant defined in Geofence
     * @return                  A String indicating the type of transition
     */
    private String getTransitionString(int transitionType) {
        switch (transitionType) {
            case Geofence.GEOFENCE_TRANSITION_ENTER:
                return getString(R.string.geofence_transition_entered);
            case Geofence.GEOFENCE_TRANSITION_EXIT:
                return getString(R.string.geofence_transition_exited);
            case Geofence.GEOFENCE_TRANSITION_DWELL:
                return getString(R.string.geofence_transition_dwell);
            default:
                return getString(R.string.unknown_geofence_transition);
        }
    }

    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            CharSequence name = getString(R.string.channel_name);
            String description = getString(R.string.channel_description);
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name,
                    NotificationManager.IMPORTANCE_HIGH);
            channel.setDescription(description);
            NotificationManager notificationManager = getSystemService(NotificationManager.class);
            notificationManager.createNotificationChannel(channel);
        }
    }

    private void broadcastGeofenceTransition(List<Geofence> triggeringGeofences,
                                             int geofenceTransition) {
        Intent intent = new Intent(Constants.getBroadcastGeofenceTriggerIntent());
        intent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,
                namesOfGeofencesTrigger(triggeringGeofences));
        intent.putExtra(TRANSITION, geofenceTransition);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    public void startLocationService(List<Geofence> triggeringGeofences) {
        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);
        Utils.saveGeofencesTrigger(this,namesOfGeofencesTrigger(triggeringGeofences));
//        serviceIntent.putStringArrayListExtra(Constants.GEOFENCE_TRIGGED,
//                namesOfGeofencesTrigger(triggeringGeofences));
        startService(serviceIntent);
    }

    public void stopLocationService() {
        Intent serviceIntent = new Intent(this, LocationUpdatesService.class);
        stopService(serviceIntent);
    }

    public ArrayList<String> namesOfGeofencesTrigger(List<Geofence> triggeringGeofences){
        ArrayList<String> fencesTriggered = new ArrayList<>();
        if(triggeringGeofences != null){
            for(Geofence geofence : triggeringGeofences){
                fencesTriggered.add(geofence.getRequestId());
            }
        }
        return fencesTriggered;
    }

}
```


Overlapping Code:
```
fenceTransitionsJobIntentService extends JobIntentService {
private static final int JOB_ID = 573;
private static final String CHANNEL_ID = "channel_01";
public static final String TRANSITION = "TRANSITION";
/**
* Convenience method for enqueuing work in to this service.
*/
public static void enqueueWork(Context context, Intent intent) {
enqueueWork(context, GeofenceTransitionsJobIntentService.class, JOB_ID, intent);
}
/**
* Handles incoming intents.
* @param intent sent by Location Services. This Intent is provided to Location
* Services (inside a PendingIntent) when addGeofences() is called.
*/
@SuppressLint("StringFormatInvalid")
@Override
protected void onHandleWork(Intent intent) {
GeofencingEvent geofencingEvent = GeofencingEvent.fromIntent(intent);
if (geofencingEvent.hasError()) {
return;
}
// Get the transition type.
int geofenceTransition = geofencingEvent.getGeofenceTransition();
List<Geofence> triggeringGeofences = geofencingEvent.getTriggeringGeofences();
// Get the geofences that were triggered. A single event can trigger multiple geofences.
// Get the transition details as a String.
String geofenceTransitionDetails = getGeofenceTransitionDetails(geofenceTransition,
triggeringGeofences);
// Test that the reported transition was of interest.
switch (geofenceTransition) {
case Geofence.GEOFENCE_TRANSITION_ENTER:
sendNotification(geofenceTransitionDetails, triggeringGeofences);
startLocationService(triggeringGeofences);
break;
case Geofence.GEOFENCE_TRANSITION_EXIT:
stopLocationService();
break;
case Geofence.GEOFENCE_TRANSITION_DWELL:
stopLocationService();
break;
default:
break;
}
// Send notification and log the transition details.
broadcastGeofenceTransition(triggeringGeofences, geofenceTransition);
}
/**
* Gets transition details and returns them as a formatted string.
*
* @param geofenceTransition The ID of the geofence transition.
* @param triggeringGeofences The geofence(s) triggered.
* @return The 
```
<Overlap Ratio: 0.9903553299492386>

---

--- 377 --
Question ID: f8ab0d3f87d77ab850dbd24836df4671e9fb08a6
Original Code:
```
public class ClasspathSetterHandler implements HttpHandler {
    // TODO change me to an empty dir where the error output will be written
    public static File outputCustomizeClasspathRootDir = new File("tmp" + SLASH + "output" + SLASH + "CustomizeClasspath");
    static final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {
        httpServerExchange.getResponseHeaders()
                .put(new HttpString("Access-Control-Allow-Origin"), "*");
        String jsonString = getString(httpServerExchange.getInputStream());
        byte[] jsonBytes = jsonString.getBytes("UTF-8");
        int jsonHash = Math.abs(jsonString.hashCode());
        File customizeClasspath = new File(outputCustomizeClasspathRootDir.getPath(), jsonHash + ".json");
        customizeClasspath.getParentFile().mkdirs();
        Files.write(customizeClasspath.toPath(), jsonBytes);
        httpServerExchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
        httpServerExchange.getResponseSender().send("{\"classpathHash\": \"" + jsonHash + "\"}");
    }

    private String getString(InputStream is) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));
        return br.lines().collect(Collectors.joining(System.lineSeparator()));
    }
}
```


Overlapping Code:
```
ss ClasspathSetterHandler implements HttpHandler {
// TODO change me to an empty dir where the error output will be written
public static File outputCustomizeClasspathRootDir = new File("tmp" + SLASH + "output" + SLASH + "CustomizeClasspath");
static final ObjectMapper objectMapper = new ObjectMapper();
@Override
public void handleRequest(HttpServerExchange httpServerExchange) throws Exception {
httpServerExchange.getResponseHeaders()
.put(new HttpString("Access-Control-Allow-Origin"), "*");
String jsonString = getString(httpServerExchange.getInputStream());
byte[] jsonBytes = jsonString.getBytes("UTF-8");
int jsonHash = Math.abs(jsonString.hashCode());
File customizeClasspath = new File(outputCustomizeClasspathRootDir.getPath(), jsonHash + ".json");
customizeClasspath.getParentFile().mkdirs();
Files.write(customizeClasspath.toPath(), jsonBytes);
httpServerExchange.getResponseHeaders().add(Headers.CONTENT_TYPE, "application/json");
httpServerExchange.getResponseSender().send("{\"classpathHash\": \"" + jsonHash + "\"}");
}
private String getString(InputStream is) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));
return br.lines().collect(Collectors.joining(System.lineSeparator()));
}
}
```
<Overlap Ratio: 0.9921568627450981>

---

--- 378 --
Question ID: 610b54d380f6cefdb781ddab0b330c2e086fdc76
Original Code:
```
public class FamilyProfileChangePrimaryCG extends FamilyProfileChangeHead {

    public static FamilyProfileChangePrimaryCG newInstance(String familyID) {
        FamilyProfileChangePrimaryCG fragment = new FamilyProfileChangePrimaryCG();
        Bundle args = new Bundle();
        args.putString(FamilyProfileChangeHead.FAMILY_ID, familyID);
        fragment.setArguments(args);
        return fragment;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        // Inflate the layout for this fragment
        View root = inflater.inflate(R.layout.fragment_family_profile_change_primary_cg, container, false);
        super.prepareViews(root);
        members = new ArrayList<>();
        presenter = new FamilyChangeContractPresenter(this, this.familyID);
        presenter.getAdultMembersExcludePCG();
        return root;
    }

    @Override
    protected void validateSave(int itemPosition) {
        Boolean valid = memberAdapter.validateSave((MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition));
        if (valid) {
            HashMap<String, String> res = memberAdapter.getSelectedResults(
                    (MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition),
                    itemPosition
            );
            res.put(Constants.PROFILE_CHANGE_ACTION.ACTION_TYPE, Constants.PROFILE_CHANGE_ACTION.PRIMARY_CARE_GIVER);
            updateFamilyMember(res);
        }
    }
}
```


Overlapping Code:
```
yProfileChangePrimaryCG extends FamilyProfileChangeHead {
public static FamilyProfileChangePrimaryCG newInstance(String familyID) {
FamilyProfileChangePrimaryCG fragment = new FamilyProfileChangePrimaryCG();
Bundle args = new Bundle();
args.putString(FamilyProfileChangeHead.FAMILY_ID, familyID);
fragment.setArguments(args);
return fragment;
}
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container,
Bundle savedInstanceState) {
// Inflate the layout for this fragment
View root = inflater.inflate(R.layout.fragment_family_profile_change_primary_cg, container, false);
super.prepareViews(root);
members = new ArrayList<>();
presenter = new FamilyChangeContractPresenter(this, this.familyID);
presenter.getAdultMembersExcludePCG();
return root;
}
@Override
protected void validateSave(int itemPosition) {
Boolean valid = memberAdapter.validateSave((MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition));
if (valid) {
HashMap<String, String> res = memberAdapter.getSelectedResults(
(MemberAdapter.MyViewHolder) recyclerView.findViewHolderForAdapterPosition(itemPosition),
itemPosition
);
res.put(Constants.PROFILE_CHANGE_ACTION.ACTION_TYPE, Constants.PROFILE_CHANGE_ACTION.PRIMARY_CARE_GIVER
```
<Overlap Ratio: 0.9607993850883936>

---

--- 379 --
Question ID: 4a8677c23c3c1f50a2a19e2bf0836624c1112b70
Original Code:
```
public class Configuration {
    private final Logger logger = LoggerFactory.getLogger(getClass());
    public final static String PID = "net.es.enos.swagger.config";

    // Last resort defaults.
    public final static String DEFAULT_HOST = "localhost";
    public final static String DEFAULT_PORT = "8181";
    public final static String DEFAULT_PATH = "/services";

    // Swagger configuration property keys.
    public final static String KEY_BASEPATH = "swagger.basePath";
    public final static String KEY_HOST = "swagger.host";
    public final static String KEY_TITLE = "swagger.info.title";
    public final static String KEY_DESCRIPTION = "swagger.info.description";
    public final static String KEY_VERSION = "swagger.info.version";
    public final static String KEY_TERMSOFSERVICE = "swagger.info.termsOfService";
    public final static String KEY_CONTACTNAME = "swagger.info.contact.name";
    public final static String KEY_CONTACTURL = "swagger.info.contact.url";
    public final static String KEY_CONTACTEMAIL = "swagger.info.contact.email";
    public final static String KEY_LICENSENAME = "swagger.info.license.name";
    public final static String KEY_LICENSEURL = "swagger.info.license.url";

    // Configuration values.
    private String basePath;
    private String host;
    private String title;
    private String description;
    private String version;
    private String termsOfService;
    private String contactName;
    private String contactURL;
    private String contactEmail;
    private String licenseName;
    private String licenseURL;

    public Configuration() {

    }

    public void refresh() {
        logger.info("net.es.enos.swagger.Configuration refresh, basePath=" + basePath);

        BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();
        ServiceReference reference = bundleContext.getServiceReference(ConfigurationAdmin.class.getName());
        ConfigurationAdmin configAdmin = (ConfigurationAdmin) bundleContext.getService(reference);

        // Get the swagger configuration to verify it exists.
        org.osgi.service.cm.Configuration swagger;
        try {
            swagger = configAdmin.getConfiguration("com.eclipsesource.jaxrs.swagger.config");
        } catch (IOException ex) {
            logger.error("Could not read com.eclipsesource.jaxrs.swagger.config configuration", ex);
            bundleContext.ungetService(reference);
            return;
        }

        Dictionary<String, Object> properties = swagger.getProperties();

        // if null, the configuration is new.
        if (properties == null) {
            properties = new Hashtable();
            logger.info("enos-swagger: creating a new configuration.");
        }

        // We are considered the master of the swagger config to overwrite
        // the com.eclipsesource.jaxrs.swagger.config version.
        properties.put(KEY_HOST, Strings.isNullOrEmpty(host) ? getHost(configAdmin) : host);
        properties.put(KEY_BASEPATH, Strings.isNullOrEmpty(basePath) ? getPath(configAdmin) : basePath);

        if (!Strings.isNullOrEmpty(title)) {
            properties.put(KEY_TITLE, title);
        }

        if (!Strings.isNullOrEmpty(description)) {
            properties.put(KEY_DESCRIPTION, description);
        }

        if (!Strings.isNullOrEmpty(version)) {
            properties.put(KEY_VERSION, version);
        }

        if (!Strings.isNullOrEmpty(termsOfService)) {
            properties.put(KEY_TERMSOFSERVICE, termsOfService);
        }

        if (!Strings.isNullOrEmpty(contactName)) {
            properties.put(KEY_CONTACTNAME, contactName);
        }

        if (!Strings.isNullOrEmpty(contactURL)) {
            properties.put(KEY_CONTACTURL, contactURL);
        }

        if (!Strings.isNullOrEmpty(contactEmail)) {
            properties.put(KEY_CONTACTEMAIL, contactEmail);
        }

        if (!Strings.isNullOrEmpty(licenseName)) {
            properties.put(KEY_LICENSENAME, licenseName);
        }

        if (!Strings.isNullOrEmpty(licenseURL)) {
            properties.put(KEY_LICENSEURL, licenseURL);
        }

        try {
            swagger.update(properties);
        } catch (IOException ex) {
            logger.error("Could not update com.eclipsesource.jaxrs.swagger.config configuration", ex);
        }

        // We are done with the configuration service.
        bundleContext.ungetService(reference);
    }

    private String getProperty(Dictionary<String, Object> properties, String key, String defaultValue) {
        if (properties == null) {
            return defaultValue;
        }

        Object value = properties.get(key);
        if (value == null || !(value instanceof String)) {
            return defaultValue;
        }

        String vstring = (String) value;
        if (vstring.isEmpty()) {
            return defaultValue;
        }

        return vstring;
    }

    private String getHost(ConfigurationAdmin configAdmin) {
        String ahost;
        String port;

        // Get the web service configuration so we can properly set the http port.
        try {
            org.osgi.service.cm.Configuration http = configAdmin.getConfiguration("org.ops4j.pax.web");
            Dictionary<String, Object> httpProperties = http.getProperties();
            ahost = getProperty(httpProperties, "org.ops4j.pax.web.listening.addresses", DEFAULT_HOST);
            port = getProperty(httpProperties, "org.osgi.service.http.port", DEFAULT_PORT);
        } catch (IOException ex) {
            logger.error("Could not read org.ops4j.pax.web configuration", ex);
            ahost = DEFAULT_HOST;
            port = DEFAULT_PORT;
        }

        String hp = ahost + ":" + port;
        logger.info("enos-swagger: bound to http service " + hp);
        return hp;
    }

    private String getPath(ConfigurationAdmin configAdmin) {
        String root;

        // Get the relative path to our swagger managed services.
        try {
            org.osgi.service.cm.Configuration jaxrs = configAdmin.getConfiguration("com.eclipsesource.jaxrs.connector");
            Dictionary<String, Object> jaxrsProperties = jaxrs.getProperties();
            root = getProperty(jaxrsProperties, "root", DEFAULT_PATH);
        } catch (IOException ex) {
            logger.error("Could not read com.eclipsesource.jaxrs.connector configuration", ex);
            root = DEFAULT_PATH;
        }

        logger.info("enos-swagger: bound REST services to basePath " + root);
        return root;
    }

    /**
     * @return the basePath
     */
    public String getBasePath() {
        return basePath;
    }

    /**
     * @param basePath the basePath to set
     */
    public void setBasePath(String basePath) {
        this.basePath = basePath;
    }

    /**
     * @return the host
     */
    public String getHost() {
        return host;
    }

    /**
     * @param host the host to set
     */
    public void setHost(String host) {
        this.host = host;
    }

    /**
     * @return the title
     */
    public String getTitle() {
        return title;
    }

    /**
     * @param title the title to set
     */
    public void setTitle(String title) {
        this.title = title;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @param description the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * @param version the version to set
     */
    public void setVersion(String version) {
        this.version = version;
    }

    /**
     * @return the termsOfService
     */
    public String getTermsOfService() {
        return termsOfService;
    }

    /**
     * @param termsOfService the termsOfService to set
     */
    public void setTermsOfService(String termsOfService) {
        this.termsOfService = termsOfService;
    }

    /**
     * @return the contactName
     */
    public String getContactName() {
        return contactName;
    }

    /**
     * @param contactName the contactName to set
     */
    public void setContactName(String contactName) {
        this.contactName = contactName;
    }

    /**
     * @return the contactURL
     */
    public String getContactURL() {
        return contactURL;
    }

    /**
     * @param contactURL the contactURL to set
     */
    public void setContactURL(String contactURL) {
        this.contactURL = contactURL;
    }

    /**
     * @return the contactEmail
     */
    public String getContactEmail() {
        return contactEmail;
    }

    /**
     * @param contactEmail the contactEmail to set
     */
    public void setContactEmail(String contactEmail) {
        this.contactEmail = contactEmail;
    }

    /**
     * @return the licenseName
     */
    public String getLicenseName() {
        return licenseName;
    }

    /**
     * @param licenseName the licenseName to set
     */
    public void setLicenseName(String licenseName) {
        this.licenseName = licenseName;
    }

    /**
     * @return the licenseURL
     */
    public String getLicenseURL() {
        return licenseURL;
    }

    /**
     * @param licenseURL the licenseURL to set
     */
    public void setLicenseURL(String licenseURL) {
        this.licenseURL = licenseURL;
    }
}
```


Overlapping Code:
```
ublic class Configuration {
private final Logger logger = LoggerFactory.getLogger(getClass());
public final static String PID = "net.es.enos.swagger.config";
// Last resort defaults.
public final static String DEFAULT_HOST = "localhost";
public final static String DEFAULT_PORT = "8181";
public final static String DEFAULT_PATH = "/services";
// Swagger configuration property keys.
public final static String KEY_BASEPATH = "swagger.basePath";
public final static String KEY_HOST = "swagger.host";
public final static String KEY_TITLE = "swagger.info.title";
public final static String KEY_DESCRIPTION = "swagger.info.description";
public final static String KEY_VERSION = "swagger.info.version";
public final static String KEY_TERMSOFSERVICE = "swagger.info.termsOfService";
public final static String KEY_CONTACTNAME = "swagger.info.contact.name";
public final static String KEY_CONTACTURL = "swagger.info.contact.url";
public final static String KEY_CONTACTEMAIL = "swagger.info.contact.email";
public final static String KEY_LICENSENAME = "swagger.info.license.name";
public final static String KEY_LICENSEURL = "swagger.info.license.url";
// Configuration values.
private String basePath;
private String host;
private String title;
private String description;
private String version;
private String termsOfService;
private String contactName;
private String contactURL;
private String contactEmail;
private String licenseName;
private String licenseURL;
public Configuration() {
}
public void refresh() {
logger.info("net.es.enos.swagger.Configuration refresh, basePath=" + basePath);
BundleContext bundleContext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();
ServiceReference reference = bundleContext.getServiceReference(ConfigurationAdmin.class.getName());
ConfigurationAdmin configAdmin = (ConfigurationAdmin) bundleContext.getService(reference);
// Get the swagger configuration to verify it exists.
org.osgi.service.cm.Configuration swagger;
try {
swagger = configAdmin.getConfiguration("com.eclipsesource.jaxrs.swagger.config");
} catch (IOException ex) {
logger.error("Could not read com.eclipsesource.jaxrs.swagger.config configuration", ex);
bundleContext.ungetServ
```
<Overlap Ratio: 0.9852017937219731>

---

--- 380 --
Question ID: 47e2f44e3d18191cb198f1d9adda29b22820cda2
Original Code:
```
public class _257BinaryTreePaths{
	public static class TreeNode {
		int val;
		TreeNode left;
		TreeNode right;
		TreeNode(int x) { val = x; }
	}

	public static void main(String[] args) {
		TreeNode tn=new TreeNode(1);
		tn.left=new TreeNode(2);
		tn.right=new TreeNode(3);
		tn.left.left=new TreeNode(4);
		tn.left.right=new TreeNode(5);
		tn.right.left=new TreeNode(6);
		tn.right.right=new TreeNode(7);
		binaryTreePaths(tn);
	}
	static int[] path;
	static List<String> list;
	public static List<String> binaryTreePaths(TreeNode root) {
		path=new int[100];
		list=new ArrayList<String>();
		if(root==null)
		{
			return list;
		}
		printNodes(root,0);
		return list;
	}
	private static void printNodes(TreeNode root, int i) {
		if(root==null)
			return;
		if(root.left==null && root.right==null){
			path[i]=root.val;
			String str=(Arrays.toString(Arrays.copyOf(path, i+1)));
			str=str.replace(", ", "->").replace("[", "").replace("]", "");
			list.add(str);
			return;
		}
		path[i]=root.val;
		printNodes(root.left, i+1);
		printNodes(root.right, i+1);
	}
	

}
```


Overlapping Code:
```
{
public static class TreeNode {
int val;
TreeNode left;
TreeNode right;
TreeNode(int x) { val = x; }
}
public static void main(String[] args) {
TreeNode tn=new TreeNode(1);
tn.left=new TreeNode(2);
tn.right=new TreeNode(3);
tn.left.left=new TreeNode(4);
tn.left.right=new TreeNode(5);
tn.right.left=new TreeNode(6);
tn.right.right=new TreeNode(7);
binaryTreePaths(tn);
}
static int[] path;
static List<String> list;
public static List<String> binaryTreePaths(TreeNode root) {
path=new int[100];
list=new ArrayList<String>();
if(root==null)
{
return list;
}
printNodes(root,0);
return list;
}
private static void printNodes(TreeNode root, int i) {
if(root==null)
return;
if(root.left==null && root.right==null){
path[i]=root.val;
String str=(Arrays.toString(Arrays.copyOf(path, i+1)));
str=str.replace(", ", "->").replace("[", "").replace("]", "");
list.add(str);
return;
}
path[i]=root.val;
printNodes(root.left, i+
```
<Overlap Ratio: 0.9299492385786802>

---

--- 381 --
Question ID: 6050304fdf34be0dee8b071ac6c9048f2990a697
Original Code:
```
class stack1
{
  BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); 
    class stack
    {
        int x;
        void input()throws IOException
        {
           x=Integer.parseInt(br.readLine());
        }
        void disp()
        {
            System.out.println(x);
        }
        stack next;
    }
    stack top;//top1;
    stack1()
    {
      //top=new stack();
      top=null;
      //top1=top;
      
    }
    stack push(stack s)throws IOException
    {
        stack p;
        p=new stack();
        p.input();
        p.next=s;
        s=p;
        return s;
    }
    stack pop(stack s)
    {
        if(s==null)
       {
           System.out.println("Nothing to pop....");
           return s;
        }
        System.out.println("Popped element:");
        s.disp();
        stack p;
        p=new stack();
        p=s.next;
        s=p;
        return s;
    }
    void display(stack s)
    {
       if(s==null)
       {
           System.out.println("Nothing to display....");
           return;
        }
        stack p;
       p=new stack();
        p=s;
        while(p!=null)
        {
            p.disp();
            p=p.next;
        }
    }
     void impl()throws IOException
    {
        int x;
        do
        {
            System.out.println("Press 1 for Push:");
            System.out.println("Press 2 for Pop:");
            System.out.println("Press 3 for Display:");
            System.out.println("Press 4 for Exit:");
            System.out.println("Enter choice:");
            x=Integer.parseInt(br.readLine());
            switch(x)
            {
                case 1:top= push(top);
                        break;
                case 2:top= pop(top);
                        break;
                case 3:display(top);
                       break;
                case 4: System.exit(0);
                        break;
            }
        }while(true);
    }
}
```


Overlapping Code:
```
lass stack1
{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); 
class stack
{
int x;
void input()throws IOException
{
x=Integer.parseInt(br.readLine());
}
void disp()
{
System.out.println(x);
}
stack next;
}
stack top;//top1;
stack1()
{
//top=new stack();
top=null;
//top1=top;

}
stack push(stack s)throws IOException
{
stack p;
p=new stack();
p.input();
p.next=s;
s=p;
return s;
}
stack pop(stack s)
{
if(s==null)
{
System.out.println("Nothing to pop....");
return s;
}
System.out.println("Popped element:");
s.disp();
stack p;
p=new stack();
p=s.next;
s=p;
return s;
}
void display(stack s)
{
if(s==null)
{
System.out.println("Nothing to display....");
return;
}
stack p;
p=new stack();
p=s;
while(p!=null)
{
p.disp();
p=p.next;
}
}
void impl()throws IOException
{
int x;
do
{
System.out.println("Press 1 for Push:");
System.out.println("Press 2 for Pop:");
System.out.println("Press 3 for Display:");
System.out.println("Press 4 for Exit:");
System.out.println("Enter choice:");
x=Integer.parseInt(br.readLine());
switch(x)
{
case 1:top= push(top);
break;
case 2:top= pop(top);
break;
case 3:display(top);
break;
case 4: System.exit(0);
break;
}
}while(tru
```
<Overlap Ratio: 0.9932829554995802>

---

--- 382 --
Question ID: 8f485ea35e4570be7e0b206a5f13b639a4943bb1
Original Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = CarLocationApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class CarLocationIT {

    private static final String SUCCESS_CAR_UUID = "9E219725-490E-4509-A42D-D0388DF317D4";
    private static final String NOT_FOUND_CAR_UUID = "";
    private static final String ERROR_CAR_UUID = "9E219725-490E-4509-A42D-D0388DF317DG";

    @LocalServerPort
    private int randomServerPort;

    @Test
    public void smoke_test(){
        assertThat(true).isTrue();
    }

    @Test
    public void should_request_by_uuid_and_obtain_car_location() {
        //Given
        final RestTemplate restTemplate = new RestTemplate();

        //When
        final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+SUCCESS_CAR_UUID+"?q=foobar", CarLocationDTO.class);

        //Then
        assertThat(carLocation).isNotNull();
        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
        assertThat(carLocation.getLatitude()).isNotNull();
        assertThat(carLocation.getLongitude()).isNotNull();
    }

    /*@Test
    public void should_request_by_uuid_and_obtain_not_found() {
        //Given
        final RestTemplate restTemplate = new RestTemplate();

        //When
        final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+NOT_FOUND_CAR_UUID+"?q=foobar", CarLocationDTO.class);

        //Then
        assertThat(carLocation).isNotNull();
        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
        assertThat(carLocation.getLatitude()).isNotNull();
        assertThat(carLocation.getLongitude()).isNotNull();
    }*/

    /*@Test
    public void should_request_by_uuid_and_obtain_error() {
        //Given
        final RestTemplate restTemplate = new RestTemplate();

        //When
        final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+ERROR_CAR_UUID+"?q=foobar", CarLocationDTO.class);

        //Then
        assertThat(carLocation).isNotNull();
        assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
        assertThat(carLocation.getLatitude()).isNotNull();
        assertThat(carLocation.getLongitude()).isNotNull();
    }*/

    @Test
    public void should_request_by_uuid_and_save_in_db_and_find_by_uuid() {
        //Given
        final RestTemplate restTemplate = new RestTemplate();
        final CarLocationDTO carLocationRemote = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+SUCCESS_CAR_UUID, CarLocationDTO.class);
        restTemplate.postForObject("http://localhost:" + randomServerPort + "/carlocation/", carLocationRemote, List.class);
        final ResponseEntity<List<CarLocationDTO>> exchange = restTemplate.exchange("http://localhost:" + randomServerPort + "/carlocation/db/" + SUCCESS_CAR_UUID, HttpMethod.GET, null, new ParameterizedTypeReference<List<CarLocationDTO>>() {});
        final List<CarLocationDTO> carLocationFromDbList = exchange.getBody();

        assertThat(carLocationFromDbList).isNotNull();

        for(CarLocationDTO carLocationFromDb : carLocationFromDbList) {
            if(!StringUtils.isEmpty(carLocationFromDb.getUuid())){
                assertThat(carLocationFromDb.getUuid().toUpperCase()).isEqualTo(SUCCESS_CAR_UUID);
                assertThat(carLocationFromDb.getLatitude()).isNotNull();
                assertThat(carLocationFromDb.getLongitude()).isNotNull();
            }
        }
    }

}
```


Overlapping Code:
```
@RunWith(SpringJUnit4ClassRunner.class)
@SpringBootTest(classes = CarLocationApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class CarLocationIT {
private static final String SUCCESS_CAR_UUID = "9E219725-490E-4509-A42D-D0388DF317D4";
private static final String NOT_FOUND_CAR_UUID = "";
private static final String ERROR_CAR_UUID = "9E219725-490E-4509-A42D-D0388DF317DG";
@LocalServerPort
private int randomServerPort;
@Test
public void smoke_test(){
assertThat(true).isTrue();
}
@Test
public void should_request_by_uuid_and_obtain_car_location() {
//Given
final RestTemplate restTemplate = new RestTemplate();
//When
final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+SUCCESS_CAR_UUID+"?q=foobar", CarLocationDTO.class);
//Then
assertThat(carLocation).isNotNull();
assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
assertThat(carLocation.getLatitude()).isNotNull();
assertThat(carLocation.getLongitude()).isNotNull();
}
/*@Test
public void should_request_by_uuid_and_obtain_not_found() {
//Given
final RestTemplate restTemplate = new RestTemplate();
//When
final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+NOT_FOUND_CAR_UUID+"?q=foobar", CarLocationDTO.class);
//Then
assertThat(carLocation).isNotNull();
assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
assertThat(carLocation.getLatitude()).isNotNull();
assertThat(carLocation.getLongitude()).isNotNull();
}*/
/*@Test
public void should_request_by_uuid_and_obtain_error() {
//Given
final RestTemplate restTemplate = new RestTemplate();
//When
final CarLocationDTO carLocation = restTemplate.getForObject("http://localhost:" + randomServerPort + "/carlocation/"+ERROR_CAR_UUID+"?q=foobar", CarLocationDTO.class);
//Then
assertThat(carLocation).isNotNull();
assertThat(carLocation.getUuid()).isEqualToIgnoringCase(SUCCESS_CAR_UUID);
assertThat(carLocation.getLatitude()).isNotNull();
assertThat(carLocation.getLongitude()).isNotNull();
}*/
@Test
public void should_request_by_uuid_and_save_in_
```
<Overlap Ratio: 0.9917657822506862>

---

--- 383 --
Question ID: e10f99dd7a854d5cc38842e20d28c67e1816a35d
Original Code:
```
@Slf4j
public class ExceptionHandlerAdvice {

    /**
     * 异常处理。
     * @param e
     * 异常。
     * @return 返回。
     */
    @ExceptionHandler(value = { Exception.class })
    @ResponseBody
    public Response<Serializable> handlerException(final Exception e) {
        log.warn("handlerException-exp: " + e);
        if(e instanceof AuthenException){
            //解析错误代码
            final RespStatus respStatus = RespStatus.parse(((AuthenException)e).getCode());
            if(respStatus != null){
                //创建响应报文
                return RespUtils.createResponse(respStatus);
            }
        }
        return RespUtils.createResponse(RespStatus.ErrWithServer, e.getMessage());
    }
}
```


Overlapping Code:
```
tionHandlerAdvice {
/**
* 异常处理。
* @param e
* 异常。
* @return 返回。
*/
@ExceptionHandler(value = { Exception.class })
@ResponseBody
public Response<Serializable> handlerException(final Exception e) {
log.warn("handlerException-exp: " + e);
if(e instanceof AuthenException){
//解析错误代码
final RespStatus respStatus = RespStatus.parse(((AuthenException)e).getCode());
if(respStatus != null){
//创建响应报文
return RespUtils.createResponse(respStatus);
}
}
return RespUtils.createResponse(RespStatus.ErrWithServer, e.
```
<Overlap Ratio: 0.9208103130755064>

---

