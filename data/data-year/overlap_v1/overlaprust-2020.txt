--- 0 --
Question ID: 231a609c136c60aaef94ec0274a5df7acb8cffbb_2
Original Code:
```
fn test_oldest_free() {
        use super::VoiceArray;
        let mut voices = VoiceArray::new(vec![1,2]);
        let v1 = voices.note_on(1).clone();
        let v2 = voices.note_on(2).clone();

        voices.note_off(1);
        voices.note_off(2);
        let v3 = voices.note_on(3).clone();
        assert_eq!(v3, v1);

        voices.note_off(3);
        let v4 = voices.note_on(4).clone();
        assert_eq!(v4, v2);
    }
```


Overlapping Code:
```
{
use super::VoiceArray;
let mut voices = VoiceArray::new(vec![1,2]);
let v1 = voices.note_on(1).clone();
let v2 = voices.note_on(2).clone();
voices.note_off(1);
voices.note_off(2);
let v3 = voices.note_on(3).clone();
assert_eq!(v3, v1);
voices.note_off(3);
let v4 = voices.note_on(4).clone();
assert_eq!(v4, v2);
```
<Overlap Ratio: 0.9287833827893175>

---

--- 1 --
Question ID: c39b3b198cf7b572f6922a56376abacb5ac5391c_0
Original Code:
```
fn prepare_headers(custom_node_attr_keys: &[String]) -> Vec<String> {
  let mut headers: Vec<String> = NEXTCLADE_CSV_HEADERS
    .iter()
    .copied()
    .map(ToOwned::to_owned)
    .collect_vec();

  let index_of_clade_col = headers
    .iter()
    .position(|header| header == "clade")
    .unwrap_or(headers.len());

  custom_node_attr_keys.iter().rev().for_each(|key| {
    headers.insert(index_of_clade_col + 1, key.clone());
  });

  headers
}
```


Overlapping Code:
```
(custom_node_attr_keys: &[String]) -> Vec<String> {
let mut headers: Vec<String> = NEXTCLADE_CSV_HEADERS
.iter()
.copied()
.map(ToOwned::to_owned)
.collect_vec();
let index_of_clade_col = headers
.iter()
.position(|header| header == "clade")
.unwrap_or(headers.len());
custom_node_attr_keys.iter().rev().for_each(|key| {
headers.insert(index_of_clade
```
<Overlap Ratio: 0.8641975308641975>

---

--- 2 --
Question ID: c5c3519079250bd716bd41cbebaafd7699a932a9_0
Original Code:
```
fn format_event<S, N>(
    ctx: &FmtContext<'_, S, N>,
    writer: &mut dyn std::fmt::Write,
    event: &Event<'_>,
) -> std::fmt::Result
where
    S: Subscriber + for<'a> LookupSpan<'a>,
    N: for<'writer> FormatFields<'writer> + 'static,
{
    let now = chrono::offset::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
    let mut parents = vec![];
    ctx.visit_spans::<(), _>(|span| {
        let meta = span.metadata();
        let name = meta.name();
        let file = meta.file();
        let line = meta.line();
        let module_path = meta.module_path();
        let level = meta.level();
        let target = meta.target();
        let id = span.id();
        let json = json!({"id": id.as_serde(), "name": name, "level": level.as_serde(), "target": target, "module_path": module_path, "file": file, "line": line});
        parents.push(json);
        Ok(())
    })
    .ok();
    let meta = event.metadata();
    let name = meta.name();
    let file = meta.file();
    let line = meta.line();
    let module_path = meta.module_path();
    let level = meta.level();
    let target = meta.target();
    let mut values = EventFieldVisitor::new();
    event.record(&mut values);
    let json = json!({"time": now, "name": name, "level": level.as_serde(), "target": target, "module_path": module_path, "file": file, "line": line, "fields": values.json, "spans": parents});
    writeln!(writer, "{}", json)
}
```


Overlapping Code:
```
&FmtContext<'_, S, N>,
writer: &mut dyn std::fmt::Write,
event: &Event<'_>,
) -> std::fmt::Result
where
S: Subscriber + for<'a> LookupSpan<'a>,
N: for<'writer> FormatFields<'writer> + 'static,
{
let now = chrono::offset::Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true);
let mut parents = vec![];
ctx.visit_spans::<(), _>(|span| {
let meta = span.metadata();
let name = meta.name();
let file = meta.file();
let line = meta.line();
let module_path = meta.module_path();
let level = meta.level();
let target = meta.target();
let id = span.id();
let json = json!({"id": id.as_serde(), "name": name, "level": level.as_serde(), "target": target, "module_path": module_path, "file": file, "line": line});
parents.push(json);
Ok(())
})
.ok();
let meta = event.metadata();
let name = meta.name();
let file = meta.file();
let line = meta.line();
let module_path = meta.module_path();
let level = meta.level();
let target = meta.target();
let mut values = EventFieldVisitor::new();
event.record(&mut values);
let json = json!({"time": now, "name": name, "level": level.as_serde(), "target": target, "module_path": module_path, "file": file, "line": line, "fields": values.json, "spans": parents});
writeln!(w
```
<Overlap Ratio: 0.9619349722442506>

---

--- 3 --
Question ID: 9dd3103e46981a906d29bb4d37bd6b406cd472e8_2
Original Code:
```
pub fn evaluate_blake2s<ConstraintF: PrimeField>(
    input: &[Boolean<ConstraintF>],
) -> Result<Vec<UInt32<ConstraintF>>, SynthesisError> {
    assert!(input.len() % 8 == 0);
    let mut parameters = [0; 8];
    parameters[0] = 0x01010000 ^ 32;
    evaluate_blake2s_with_parameters(input, &parameters)
}
```


Overlapping Code:
```
onstraintF: PrimeField>(
input: &[Boolean<ConstraintF>],
) -> Result<Vec<UInt32<ConstraintF>>, SynthesisError> {
assert!(input.len() % 8 == 0);
let mut parameters = [0; 8];
parameters[0] = 0x01010000 ^ 32;
evaluate_blake2s_with_parameters(input, &par
```
<Overlap Ratio: 0.8771929824561403>

---

--- 4 --
Question ID: 427fd6006422e8553f166bb425ee7093a287f2a3_3
Original Code:
```
fn npm_install() -> Result<()> {
    let npm = npm();
    let status = Command::new(npm)
        .current_dir(frontend_dir())
        .arg("install")
        .status()?;

    if !status.success() {
        return Err(anyhow!("'npm install' failed"));
    }

    Ok(())
}
```


Overlapping Code:
```
> Result<()> {
let npm = npm();
let status = Command::new(npm)
.current_dir(frontend_dir())
.arg("install")
.status()?;
if !status.success() {
return Err(anyhow!("
```
<Overlap Ratio: 0.7546296296296297>

---

--- 5 --
Question ID: f9ad4795b3816d5f10ab42dfdc78b7a3de427600_0
Original Code:
```
pub fn establish_connection() -> PgConnection {
    dotenv().ok();

    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    PgConnection::establish(&database_url).expect(&format!("Error connecting to {}", database_url))
}
```


Overlapping Code:
```
pub fn establish_connection() -> PgConnection {
dotenv().ok();
let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
PgConnection::establish(&database_url).expect(&format!("Error connecting to {}", database_url))
}
```
<Overlap Ratio: 1.0>

---

--- 6 --
Question ID: 003458e0f21354b51a889b03e9b3f5a6615a3142_0
Original Code:
```
pub fn bench(c: &mut Criterion) {
    setup();
    let mut group = c.benchmark_group("sched_exec_tests");
    // try to limit the length of test runs
    // group.significance_level(0.1).sample_size(10).measurement_time(Duration::from_secs(30));
    // group.significance_level(0.1).sample_size(10);
    group.significance_level(0.1);

    log::info!("create_destroy_2000_machines: setup complete");
    group.bench_function("create_destroy_2000_machines", |b| b.iter(create_destroy_2000_machines));
    log::info!("create_destroy_2000_machines: tear-down complete");

    let mut send_cmd = DaisyChainDriver::default();
    send_cmd.machine_count = 1;
    send_cmd.message_count = 200;
    send_cmd.duration = Duration::from_secs(30);
    send_cmd.setup();
    group.bench_function("send 200 cmds", |b| b.iter(|| send_cmd.run()));
    DaisyChainDriver::teardown(send_cmd);

    let mut fanout_fanin = FanoutFaninDriver::default();
    fanout_fanin.setup();
    group.bench_function("fanout_fanin_bound", |b| b.iter(|| fanout_fanin.run()));
    FanoutFaninDriver::teardown(fanout_fanin);

    let mut fanout_fanin = FanoutFaninDriver::default();
    fanout_fanin.bound_queue = false;
    fanout_fanin.setup();
    group.bench_function("fanout_fanin_unbound", |b| b.iter(|| fanout_fanin.run()));
    FanoutFaninDriver::teardown(fanout_fanin);

    let mut daisy_chain = DaisyChainDriver::default();
    daisy_chain.duration = Duration::from_secs(30);
    daisy_chain.setup();
    group.bench_function("daisy_chain_bound 200 cmds 4000 machines", |b| b.iter(|| daisy_chain.run()));
    DaisyChainDriver::teardown(daisy_chain);

    let mut daisy_chain = DaisyChainDriver::default();
    daisy_chain.bound_queue = false;
    daisy_chain.duration = Duration::from_secs(30);
    daisy_chain.setup();
    group.bench_function("daisy_chain_unbound 200 cmds 4000 machines", |b| b.iter(|| daisy_chain.run()));
    DaisyChainDriver::teardown(daisy_chain);

    let mut chaos_monkey = ChaosMonkeyDriver::default();
    chaos_monkey.setup();
    group.bench_function("chaos_monkey_bound", |b| b.iter(|| chaos_monkey.run()));
    ChaosMonkeyDriver::teardown(chaos_monkey);

    let mut chaos_monkey = ChaosMonkeyDriver::default();
    chaos_monkey.bound_queue = false;
    chaos_monkey.setup();
    group.bench_function("chaos_monkey_unbound", |b| b.iter(|| chaos_monkey.run()));
    ChaosMonkeyDriver::teardown(chaos_monkey);
    group.finish();
    teardown();
}
```


Overlapping Code:
```
;
let mut group = c.benchmark_group("sched_exec_tests");
// try to limit the length of test runs
// group.significance_level(0.1).sample_size(10).measurement_time(Duration::from_secs(30));
// group.significance_level(0.1).sample_size(10);
group.significance_level(0.1);
log::info!("create_destroy_2000_machines: setup complete");
group.bench_function("create_destroy_2000_machines", |b| b.iter(create_destroy_2000_machines));
log::info!("create_destroy_2000_machines: tear-down complete");
let mut send_cmd = DaisyChainDriver::default();
send_cmd.machine_count = 1;
send_cmd.message_count = 200;
send_cmd.duration = Duration::from_secs(30);
send_cmd.setup();
group.bench_function("send 200 cmds", |b| b.iter(|| send_cmd.run()));
DaisyChainDriver::teardown(send_cmd);
let mut fanout_fanin = FanoutFaninDriver::default();
fanout_fanin.setup();
group.bench_function("fanout_fanin_bound", |b| b.iter(|| fanout_fanin.run()));
FanoutFaninDriver::teardown(fanout_fanin);
let mut fanout_fanin = FanoutFaninDriver::default();
fanout_fanin.bound_queue = false;
fanout_fanin.setup();
group.bench_function("fanout_fanin_unbound", |b| b.iter(|| fanout_fanin.run()));
FanoutFaninDriver::teardown(fanout_fanin);
let mut daisy_chain = DaisyChainDriver::default();
daisy_chain.duration = Duration::from_secs(30);
daisy_chain.setup();
group.bench_function("daisy_chain_bound 200 cmds 4000 machines", |b| b.iter(|| daisy_chain.run()));
DaisyChainDriver::teardown(daisy_chain);
let mut daisy_chain = DaisyChainDriver::default();
daisy_chain.bound_queue = false;
daisy_chain.duration = Duration::from_secs(30);
daisy_chain.setup();
group.bench_function("daisy_chain_unbound 200 cmds 4000 machines", |b| b.iter(|| daisy_chain.run()));
DaisyChainDriver::teardown(daisy_chain);
let mut chaos_monkey = ChaosMonkeyDriver::default();
chaos_monkey.setup();
group.bench_function("chaos_monkey_bound", |b| b.iter(|| chaos_monkey.run()));
ChaosMonkeyDriver::teardown(chaos_monkey);
let mut chaos_monkey = ChaosMonkeyDriver::default();
chaos_monkey.bound_queue = false;
chaos_monkey.setup();
group.bench_function("chaos_monkey_unbound", |b| b.iter(|| chaos_monkey.run()));
ChaosMonkeyDriver::teardown(chaos_monkey);
group.finish();

```
<Overlap Ratio: 0.9760425909494232>

---

--- 7 --
Question ID: 586860cbd43665456d19d61adedcb4aa23f7e82a_1
Original Code:
```
pub fn server() {
    let mut single_rt = Builder::new()
    .basic_scheduler()
    .enable_all()
    .build()
    .unwrap();

    // Automatically select the best implementation for your platform.
    let mut watcher: RecommendedWatcher = Watcher::new_immediate(|res: Result<notify::event::Event, nError>| {
        match res {
            Ok(event) => {
                let watcher = Arc::clone(&FILE_WATCHER);
                let tx = watcher.0.lock().unwrap();
                for path in event.paths {
                    tx.broadcast(path.into_os_string().into_string().unwrap()).unwrap();
                }
            },
            Err(e) => {
                println!("watch error: {:?}", e);
            }
        }
    }).unwrap();

    // Add a path to be watched. All files and directories at that path and
    // below will be monitored for changes.
    watcher.watch("./control-panel", RecursiveMode::Recursive).unwrap();
    
  
    let local = tokio::task::LocalSet::new();
    let system_fut = actix_rt::System::run_in_tokio("Dashboard Server", &local);

    local.block_on(&mut single_rt, async {
      tokio::task::spawn_local(system_fut);

      let server = ReloadServer::default().start();
  
      let _ = actix_web::HttpServer::new(move || {
            App::new()
            .data(server.clone())
            .route("/livereload", web::get().to(index_ws))
            .route("/{filename:.*}", web::get().to(index))
        })
        .workers(1)
        .bind("127.0.0.1:8086")
        .unwrap()
        .run()
        .await;
    });
}
```


Overlapping Code:
```
t single_rt = Builder::new()
.basic_scheduler()
.enable_all()
.build()
.unwrap();
// Automatically select the best implementation for your platform.
let mut watcher: RecommendedWatcher = Watcher::new_immediate(|res: Result<notify::event::Event, nError>| {
match res {
Ok(event) => {
let watcher = Arc::clone(&FILE_WATCHER);
let tx = watcher.0.lock().unwrap();
for path in event.paths {
tx.broadcast(path.into_os_string().into_string().unwrap()).unwrap();
}
},
Err(e) => {
println!("watch error: {:?}", e);
}
}
}).unwrap();
// Add a path to be watched. All files and directories at that path and
// below will be monitored for changes.
watcher.watch("./control-panel", RecursiveMode::Recursive).unwrap();


let local = tokio::task::LocalSet::new();
let system_fut = actix_rt::System::run_in_tokio("Dashboard Server", &local);
local.block_on(&mut single_rt, async {
tokio::task::spawn_local(system_fut);
let server = ReloadServer::default().start();

let _ = actix_web::HttpServer::new(move || {
App::new()
.data(server.clone())
.route("/livereload", web::get().to(index_ws))
.route("/{filename:.*}", web::get().to(index))
})
.workers(1)
.bind("127.0.0.1:8086")
.unw
```
<Overlap Ratio: 0.9588138385502472>

---

--- 8 --
Question ID: 1c68ac60b7e9e8ca7a99bcec601782d40b2a5bfb_2
Original Code:
```
fn new_row_data(types: &[column::Type], values: &[column::Value]) -> Vec<u8> {
        let mut buf = Vec::<u8>::new();
        push_row_data(&mut buf, types, values);
        buf
    }
```


Overlapping Code:
```
(types: &[column::Type], values: &[column::Value]) -> Vec<u8> {
let mut buf = Vec::<u8>::new();
push
```
<Overlap Ratio: 0.6410256410256411>

---

--- 9 --
Question ID: bc94764c8105cd5f7283f593f2741e4a2b0d7150_16
Original Code:
```
fn solver_017_test() {
    assert_eq!(Solver017::default().solve(), 21124);

    assert_eq!(Solver017 { n: 5 }.solve(), 19);
    assert_eq!(Solver017 { n: 19 }.solve(), 106);
    assert_eq!(Solver017 { n: 19999 }.solve(), 737203);

    // for a more comprehensive set of tests on the algorithm, check the java version
}
```


Overlapping Code:
```
sert_eq!(Solver017::default().solve(), 21124);
assert_eq!(Solver017 { n: 5 }.solve(), 19);
assert_eq!(Solver017 { n: 19 }.solve(), 106);
assert_eq!(Solver017 { n: 19999 }.solve(), 737203);
// for a more comprehensive set of tests on the algorithm, ch
```
<Overlap Ratio: 0.8417508417508418>

---

--- 10 --
Question ID: 4288f64500675406d8b3af363a3524b27723b533_0
Original Code:
```
fn singleton_enum_serialize() {
        // This test is basically just here so that we can provide a reference for how the
        // Phoenix/Elixir website needs to send arena control messages

        let query = ArenaControlCommand::QueryMechs;
        let s = serde_json::to_string(&query).unwrap();
        assert_eq!("\"QueryMechs\"", s);

        let sm = ArenaControlCommand::StartMatch(CreateMatch {
            actors: Vec::new(),
            aps_per_turn: 4,
            match_id: "test".to_string(),
            board_height: 10,
            board_width: 20,
            max_turns: 100,
        });
        let s2 = serde_json::to_string(&sm).unwrap();
        assert_eq!(
            "{\"StartMatch\":{\"match_id\":\"test\",\"actors\":[],\"board_height\":10,\"board_width\":20,\"max_turns\":100,\"aps_per_turn\":4}}", 
            s2);
    }
```


Overlapping Code:
```
lize() {
// This test is basically just here so that we can provide a reference for how the
// Phoenix/Elixir website needs to send arena control messages
let query = ArenaControlCommand::QueryMechs;
let s = serde_json::to_string(&query).unwrap();
assert_eq!("\"QueryMechs\"", s);
let sm = ArenaControlCommand::StartMatch(CreateMatch {
actors: Vec::new(),
aps_per_turn: 4,
match_id: "test".to_string(),
board_height: 10,
board_width: 20,
max_turns: 100,
});
let s2 = serde_json::to_string(&sm).unwrap();
assert_eq!(
"{\"StartMatch\":{\"match_id\":\"test\",\"actors\":[],\"board_height\":10,\"board_width\":20,\"max_turns\":100,\"aps_per_turn\":4}}", 
```
<Overlap Ratio: 0.9558823529411765>

---

--- 11 --
Question ID: f0a295479c997372d6954e123f5d62358876d817_10
Original Code:
```
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
```


Overlapping Code:
```
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
assert_eq!(
::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
8usize,
concat!(
"Size of: ",
stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
)
);
assert_eq!(
::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
4usize,
concat!(
"Alignment of ",
stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
"::",
stringify!(__low)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
as *const _ as usize
},
4usize,
concat!(
"Offset of field: ",
stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
"::",
stringify!(__high)
)
);
}
```
<Overlap Ratio: 1.0>

---

--- 12 --
Question ID: 665fa328276b0ec718ea476beed61dde34e99284_0
Original Code:
```
fn test_matrix_rows() {
        let mut a = Matrix::new(3, 3, (0..9).collect::<Vec<usize>>());

        let data = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];

        for (i, row) in a.iter_rows().enumerate() {
            assert_eq!(data[i], *row);
        }

        for (i, row) in a.iter_rows_mut().enumerate() {
            assert_eq!(data[i], *row);
        }

        for row in a.iter_rows_mut() {
            for r in row {
                *r = 0;
            }
        }

        assert_eq!(a.into_vec(), vec![0; 9]);
    }
```


Overlapping Code:
```
() {
let mut a = Matrix::new(3, 3, (0..9).collect::<Vec<usize>>());
let data = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];
for (i, row) in a.iter_rows().enumerate() {
assert_eq!(data[i], *row);
}
for (i, row) in a.iter_rows_mut().enumerate() {
assert_eq!(data[i], *row);
}
for row in a.iter_rows_mut() {
for r in row {
*r = 0;
}
}
assert_eq!(a.into_vec(), vec![0; 9])
```
<Overlap Ratio: 0.9421052631578948>

---

--- 13 --
Question ID: 174fc228c11a48d7ff661f3072db09bcfa8a0d66_12
Original Code:
```
fn test_version_serialize_bytes() {
    let version_a = Version::new(0, 0, 0, "alphabeta", "buildmeta").unwrap();
    let res = version_a.to_bytes();
    assert!(res.is_ok());

    let version_a_bytes = res.unwrap();
    let res = Version::from_bytes(&version_a_bytes);
    assert!(res.is_ok());

    let version_b = res.unwrap();
    assert_eq!(version_a, version_b);
}
```


Overlapping Code:
```
et version_a = Version::new(0, 0, 0, "alphabeta", "buildmeta").unwrap();
let res = version_a.to_bytes();
assert!(res.is_ok());
let version_a_bytes = res.unwrap();
let res = Version::from_bytes(&version_a_bytes);
assert!(res.is_ok());
let version_b = res.unwrap();
assert_eq!
```
<Overlap Ratio: 0.8154761904761905>

---

--- 14 --
Question ID: d9e36f59ae1cb4330409c2bd19837d2013ac8458_2
Original Code:
```
pub fn test_term_u64() {
        let mut schema_builder = Schema::builder();
        let count_field = schema_builder.add_u64_field("count", INDEXED);
        let term = Term::from_field_u64(count_field, 983u64);
        assert_eq!(term.field(), count_field);
        assert_eq!(term.typ(), Type::U64);
        assert_eq!(term.as_slice().len(), super::FAST_VALUE_TERM_LEN);
        assert_eq!(term.as_u64(), Some(983u64))
    }
```


Overlapping Code:
```
) {
let mut schema_builder = Schema::builder();
let count_field = schema_builder.add_u64_field("count", INDEXED);
let term = Term::from_field_u64(count_field, 983u64);
assert_eq!(term.field(), count_field);
assert_eq!(term.typ(), Type::U64);
assert_eq!(term.as_slice().len(), super::FAST_VALUE_TERM_LEN);
assert
```
<Overlap Ratio: 0.8474114441416893>

---

--- 15 --
Question ID: 05eed096b4f4427058dfd15b8faf34062971ecc1_0
Original Code:
```
fn main() -> Result<(), String> {
    // Create a DDlog configuration with 1 worker thread and with the self-profiling feature
    // enabled.
    let config = Config::new()
        .with_timely_workers(1)
        .with_profiling_config(ProfilingConfig::SelfProfiling);
    // Instantiate the DDlog program with this configuration.
    // The second argument of `run_with_config` is a Boolean flag that indicates
    // whether DDlog will track the complete snapshot of output relations.  It
    // should only be set for debugging in order to dump the contents of output
    // tables using `HDDlog::dump_table()`.  Otherwise, indexes are the preferred
    // way to achieve this.
    let (hddlog, init_state) = tutorial_ddlog::run_with_config(config, false)?;

    // Alternatively, use `tutorial_ddlog::run` to instantiate the program with default
    // configuration.  The first argument specifies the number of workers.

    // let (hddlog, init_state) = tutorial_ddlog::run(1, false)?;

    println!("Initial state");
    dump_delta(&hddlog, &init_state);

    /*
     * We perform two transactions that insert in the following two DDlog relations
     * (see `tutorial.dl`):
     *
     * ```
     * input relation Word1(word: string, cat: Category)
     * input relation Word2(word: string, cat: Category)
     * ```
     *
     * The first transactio uses the type-safe API, which should be preferred when
     * writing a client bound to a specific known DDlog program.
     *
     * The second transaction uses the dynamically typed record API.
     */

    // There can be at most one transaction at a time.  Attempt to start another transaction
    // when there is one in execution will return an error.
    hddlog.transaction_start()?;

    // A transaction can consist of multiple `apply_updates()` calls, each taking
    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog
    // relation.
    let updates = vec![
        Update::Insert {
            // We are going to insert..
            relid: Relations::Word1 as RelId, // .. into relation with this Id.
            // `Word1` type, declared in the `types` crate has the same fields as
            // the corresponding DDlog type.
            v: Word1 {
                word: "foo-".to_string(),
                cat: Category::CategoryOther,
            }
            .into_ddvalue(),
        },
        Update::Insert {
            relid: Relations::Word2 as RelId,
            v: Word2 {
                word: "bar".to_string(),
                cat: Category::CategoryOther,
            }
            .into_ddvalue(),
        },
    ];
    hddlog.apply_updates(&mut updates.into_iter())?;

    // Commit the transaction; returns a `DeltaMap` object that contains the set
    // of changes to output relations produced by the transaction.
    let mut delta = hddlog.transaction_commit_dump_changes()?;
    //assert_eq!(delta, delta_expected);

    println!("\nState after transaction 1");
    dump_delta(&hddlog, &delta);

    // This shows how to extract values from `DeltaMap`.
    println!("\nEnumerating new phrases");

    // Retrieve the set of changes for a particular relation.
    let new_phrases = delta.get_rel(Relations::Phrases as RelId);
    for (val, weight) in new_phrases.iter() {
        // weight = 1 - insert.
        // weight = -1 - delete.
        assert_eq!(*weight, 1);
        let phrase: &Phrases = Phrases::from_ddvalue_ref(val);
        println!("New phrase: {}", phrase.phrase);
    }

    hddlog.transaction_start()?;

    // `Record` type

    let relid_word1 = hddlog.inventory.get_table_id("Word1").unwrap() as RelId;

    // `UpdCmd` is a dynamically typed representation of a DDlog command.
    // It takes a vector or `Record`'s, which represent dynamically typed
    // DDlog values.
    let commands = vec![UpdCmd::Insert(
        RelIdentifier::RelId(relid_word1),
        Record::PosStruct(
            // Positional struct consists of constructor name
            // and a vector of arguments whose number and
            // types must match those of the DDlog constructor.
            // The alternative is `NamedStruct` where arguments
            // are represented as (name, value) pairs.
            Cow::from("Word1"), // Constructor name.
            // Constructor arguments.
            vec![
                Record::String("buzz".to_string()),
                Record::PosStruct(Cow::from("CategoryOther"), vec![]),
            ],
        ),
    )];

    // Use `apply_updates_dynamic` instead of `apply_updates` for dynamically
    // typed commands.
    // This will fail if the records in `commands` don't match the DDlog type
    // declarations (e.g., missing constructor arguments, string instead of integer, etc.)
    hddlog.apply_updates_dynamic(&mut commands.into_iter())?;

    let delta = hddlog.transaction_commit_dump_changes()?;

    println!("\nState after transaction 2");
    dump_delta(&hddlog, &delta);

    hddlog.stop().unwrap();
    Ok(())
}
```


Overlapping Code:
```
-> Result<(), String> {
// Create a DDlog configuration with 1 worker thread and with the self-profiling feature
// enabled.
let config = Config::new()
.with_timely_workers(1)
.with_profiling_config(ProfilingConfig::SelfProfiling);
// Instantiate the DDlog program with this configuration.
// The second argument of `run_with_config` is a Boolean flag that indicates
// whether DDlog will track the complete snapshot of output relations. It
// should only be set for debugging in order to dump the contents of output
// tables using `HDDlog::dump_table()`. Otherwise, indexes are the preferred
// way to achieve this.
let (hddlog, init_state) = tutorial_ddlog::run_with_config(config, false)?;
// Alternatively, use `tutorial_ddlog::run` to instantiate the program with default
// configuration. The first argument specifies the number of workers.
// let (hddlog, init_state) = tutorial_ddlog::run(1, false)?;
println!("Initial state");
dump_delta(&hddlog, &init_state);
/*
* We perform two transactions that insert in the following two DDlog relations
* (see `tutorial.dl`):
*
* ```
* input relation Word1(word: string, cat: Category)
* input relation Word2(word: string, cat: Category)
* ```
*
* The first transactio uses the type-safe API, which should be preferred when
* writing a client bound to a specific known DDlog program.
*
* The second transaction uses the dynamically typed record API.
*/
// There can be at most one transaction at a time. Attempt to start another transaction
// when there is one in execution will return an error.
hddlog.transaction_start()?;
// A transaction can consist of multiple `apply_updates()` calls, each taking
// multiple updates. An update inserts, deletes or modifies a record in a DDlog
// relation.
let updates = vec![
Update::Insert {
// We are going to insert..
relid: Relations::Word1 as RelId, // .. into relation with this Id.
// `Word1` type, declared in the `types` crate has the same fields as
// the corresponding DDlog type.
v: Word1 {
word: "foo-".to_string(),
cat: Category::CategoryOther,
}
.into_ddvalue(),
},
Update::Insert {
relid: Rela
```
<Overlap Ratio: 0.9799346710219319>

---

--- 16 --
Question ID: 11075a0348f32450e695baae613d19a55c6e2794_3
Original Code:
```
pub fn doit<'a>(lines: impl Iterator<Item = &'a String>, validate: bool) -> usize {
    let mut result = 0;

    for p in split_passports(lines) {
        result += match get_passport(&p) {
            Some(p) => match validate {
                true => match p.validate() {
                    Ok(_) => 1,
                    Err(_) => 0,
                },
                false => 1,
            },
            None => 0,
        };
    }

    result
}
```


Overlapping Code:
```
Item = &'a String>, validate: bool) -> usize {
let mut result = 0;
for p in split_passports(lines) {
result += match get_passport(&p) {
Some(p) => match validate {
true => match p.validate() {
Ok(_) => 1,
Err(_) => 0,
},
false => 1,
},
None => 0,
};

```
<Overlap Ratio: 0.8417508417508418>

---

--- 17 --
Question ID: 48a5b6beb22786857e15fcc6b238a06880e3ee51_0
Original Code:
```
pub fn build_rust_code_from_protobuffer_with_options(proto_filename: &PathBuf, includes: Vec<String>, rpc_generator: pb_rs::types::RpcGeneratorFunction) -> Result<PathBuf, Error> {
	use pb_rs::types::Config;
	log::info!("Building protobuf for {:?}...", &proto_filename);

	let out_dir = autogen_dir();
	std::fs::create_dir_all(&out_dir)?;
	let out_file = get_protobuf_generated_filename(proto_filename);
	log::info!("Generating {:?}.", out_file);

    let config = Config {
        in_file: proto_filename.to_owned(),
        out_file: out_file.clone(), 
        single_module: true,
        import_search_path: vec![PathBuf::from("./schema")],
        no_output: false,
        error_cycle: false,
        headers: true,
		dont_use_cow: true,
        custom_struct_derive: vec!["derive_new::new".into()], //, "Eq".into(), "Hash".into()],
        custom_rpc_generator: rpc_generator,
		custom_includes: includes,
    };

    if let Err(e) = pb_rs::types::FileDescriptor::write_proto(&config) {
		return Err(failure::format_err!("{:?}", e));
	}

	log::info!("...Pb-rs ran on {:?} and created {:?}", proto_filename, out_file);

	Ok(out_file)
}
```


Overlapping Code:
```
ust_code_from_protobuffer_with_options(proto_filename: &PathBuf, includes: Vec<String>, rpc_generator: pb_rs::types::RpcGeneratorFunction) -> Result<PathBuf, Error> {
use pb_rs::types::Config;
log::info!("Building protobuf for {:?}...", &proto_filename);
let out_dir = autogen_dir();
std::fs::create_dir_all(&out_dir)?;
let out_file = get_protobuf_generated_filename(proto_filename);
log::info!("Generating {:?}.", out_file);
let config = Config {
in_file: proto_filename.to_owned(),
out_file: out_file.clone(), 
single_module: true,
import_search_path: vec![PathBuf::from("./schema")],
no_output: false,
error_cycle: false,
headers: true,
dont_use_cow: true,
custom_struct_derive: vec!["derive_new::new".into()], //, "Eq".into(), "Hash".into()],
custom_rpc_generator: rpc_generator,
custom_includes: includes,
};
if let Err(e) = pb_rs::types::FileDescriptor::write_proto(&config) {
return Err(failure::format_err!("{:?}", e));
}
log::info!("...Pb-rs ran on {:?} and created {:?}", proto_filename, ou
```
<Overlap Ratio: 0.9643201542912246>

---

--- 18 --
Question ID: 0d12d4dabbe103e589461731bba78fdfb38c0526_0
Original Code:
```
pub fn get_volumes() -> Result<Vec<Volume>, ScannerError> {
    let mut mounts = get_mounts()?;

    let mut sc = ScannerAscii::scan_path("/proc/diskstats")?;

    let mut volumes = Vec::with_capacity(1);

    loop {
        if sc.drop_next()?.is_none() {
            break;
        }

        sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;

        let device =
            unsafe { String::from_utf8_unchecked(sc.next_raw()?.ok_or(ErrorKind::UnexpectedEof)?) };

        if let Some(points) = mounts.remove(&device) {
            for _ in 0..2 {
                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
            }

            let read_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;

            for _ in 0..3 {
                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
            }

            let write_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;

            for _ in 0..2 {
                sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
            }

            let time_spent = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;

            if time_spent > 0 {
                let (size, used) = {
                    let path = CString::new(points[0].as_bytes()).unwrap();

                    let mut stats: libc::statvfs = unsafe { zeroed() };

                    let rtn = unsafe { libc::statvfs(path.as_ptr(), &mut stats as *mut _) };

                    if rtn != 0 {
                        return Err(io::Error::last_os_error().into());
                    }

                    (
                        stats.f_bsize as u64 * stats.f_blocks as u64,
                        stats.f_bsize as u64 * (stats.f_blocks - stats.f_bavail) as u64,
                    )
                };

                let stat = VolumeStat {
                    read_bytes,
                    write_bytes,
                };

                let volume = Volume {
                    device,
                    stat,
                    size,
                    used,
                    points,
                };

                volumes.push(volume);
            }

            sc.drop_next_line()?.ok_or(ErrorKind::UnexpectedEof)?;
        }
    }

    Ok(volumes)
}
```


Overlapping Code:
```
 fn get_volumes() -> Result<Vec<Volume>, ScannerError> {
let mut mounts = get_mounts()?;
let mut sc = ScannerAscii::scan_path("/proc/diskstats")?;
let mut volumes = Vec::with_capacity(1);
loop {
if sc.drop_next()?.is_none() {
break;
}
sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
let device =
unsafe { String::from_utf8_unchecked(sc.next_raw()?.ok_or(ErrorKind::UnexpectedEof)?) };
if let Some(points) = mounts.remove(&device) {
for _ in 0..2 {
sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
}
let read_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;
for _ in 0..3 {
sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
}
let write_bytes = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;
for _ in 0..2 {
sc.drop_next()?.ok_or(ErrorKind::UnexpectedEof)?;
}
let time_spent = sc.next_u64()?.ok_or(ErrorKind::UnexpectedEof)?;
if time_spent > 0 {
let (size, used) = {
let path = CString::new(points[0].as_bytes()).unwrap();
let mut stats: libc::statvfs = unsafe { zeroed() };
let rtn = unsafe { libc::statvfs(path.as_ptr(), &mut stats as *mut _) };
if rtn != 0 {
return Err(io::Error::last_os_error().into());
}
(
stats.f_bsize as u64 * stats.f_blocks as u64,
stats.f_bsize as u64 * (stats.f_blocks - stats.f_bavail) as u64,
)
};
let stat = VolumeStat {
read_bytes,
write_bytes,
};
let volume = Volume {
device,
stat,
size,
used,
points,
};
volumes.push(volume);
}
sc.drop_next_line()?.ok_or(ErrorKind::UnexpectedEof)?;
}

```
<Overlap Ratio: 0.9875862068965517>

---

--- 19 --
Question ID: 00531fd4fe2d656d52fd30c1dad5dd37814e2487_2
Original Code:
```
fn seats_to_shuffle(input: &Vec<Vec<SeatFill>>) -> Vec<(usize, usize)> {
    let mut seats_to_change: Vec<(usize, usize)> = Vec::new();
    for i in 0..input.len() {
        let line = input.get(i).unwrap();
        for j in 0..line.len() {
            let current_seat = line.get(j).unwrap();
            if *current_seat == SeatFill::Floor {
                continue;
            }

            let mut n_occupied = 0;
            for sx in -1..=1 {
                for sy in -1..=1 {
                    if sx == 0 && sy == 0 {
                        continue;
                    }

                    if occupied_seat_visible(&input, (j, i), (sx, sy)) {
                        n_occupied += 1;
                    }
                }
            }


            if (*current_seat == SeatFill::Empty && n_occupied <= MAX_OCCUPIED_TO_FILL) ||
                *current_seat == SeatFill::Occupied && n_occupied >= MIN_OCCUPIED_TO_EMPTY {
                seats_to_change.push((i, j));
            }
        }
    }

    seats_to_change
}
```


Overlapping Code:
```
_shuffle(input: &Vec<Vec<SeatFill>>) -> Vec<(usize, usize)> {
let mut seats_to_change: Vec<(usize, usize)> = Vec::new();
for i in 0..input.len() {
let line = input.get(i).unwrap();
for j in 0..line.len() {
let current_seat = line.get(j).unwrap();
if *current_seat == SeatFill::Floor {
continue;
}
let mut n_occupied = 0;
for sx in -1..=1 {
for sy in -1..=1 {
if sx == 0 && sy == 0 {
continue;
}
if occupied_seat_visible(&input, (j, i), (sx, sy)) {
n_occupied += 1;
}
}
}
if (*current_seat == SeatFill::Empty && n_occupied <= MAX_OCCUPIED_TO_FILL) ||
*current_seat == SeatFill::Occupied && n_occupied >= MIN_OCCUPIED_TO_EMPTY {
seats_to_change.push((i
```
<Overlap Ratio: 0.9406657018813314>

---

--- 20 --
Question ID: ed40fb87bf68c186d25e479eac8e98993f88f1f4_0
Original Code:
```
pub fn random_word(file_contents: &str) -> String {
    let mut words: Vec<String> = Vec::new();

    for word in file_contents.split(" ") {
        words.push(word.trim().to_string());
    }

    String::from(&words[rand::thread_rng().gen_range(0, words.len())])
}
```


Overlapping Code:
```
word(file_contents: &str) -> String {
let mut words: Vec<String> = Vec::new();
for word in file_contents.split(" ") {
words.push(word.trim().to_string());
}
String::from(&words[rand::thread_rng().gen_
```
<Overlap Ratio: 0.8368200836820083>

---

--- 21 --
Question ID: 57614c17dca1f1104be2060b0b5b1fea63783202_62
Original Code:
```
pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        operational_insights_resource_provider: &str,
        workspace_name: &str,
        metadata_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/{}/workspaces/{}/providers/Microsoft.SecurityInsights/metadata/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            operational_insights_resource_provider,
            workspace_name,
            metadata_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn delete(
operation_config: &crate::OperationConfig,
subscription_id: &str,
resource_group_name: &str,
operational_insights_resource_provider: &str,
workspace_name: &str,
metadata_name: &str,
) -> std::result::Result<delete::Response, delete::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/subscriptions/{}/resourceGroups/{}/providers/{}/workspaces/{}/providers/Microsoft.SecurityInsights/metadata/{}",
operation_config.base_path(),
subscription_id,
resource_group_name,
operational_insights_resource_provider,
workspace_name,
metadata_name
);
let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::DELETE);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(delete::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => Ok(delete::Response::Ok200),
http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::CloudError =
serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
Err(delete::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 22 --
Question ID: 358c80ac6a11f86317dc01f1b171bb92ac7be63b_6
Original Code:
```
fn serialize_list() -> Result<()> {
        assert_eq!(to_string(&Vec::<u8>::default())?, "the empty list");
        assert_eq!(
            to_string(&vec![1, 2, 3])?,
            "the list where an item is 1 and another item is 2 and another item is 3"
        );
        assert_eq!(to_string(&vec![vec![1, 2], vec![], vec![3, 4]])?, "the list henceforth `the list` where an item is the list where an item is 1 and another item is 2 and another item of `the list` is the empty list and another item is the list where an item is 3 and another item is 4");
        Ok(())
    }
```


Overlapping Code:
```
ert_eq!(to_string(&Vec::<u8>::default())?, "the empty list");
assert_eq!(
to_string(&vec![1, 2, 3])?,
"the list where an item is 1 and another item is 2 and another item is 3"
);
assert_eq!(to_string(&vec![vec![1, 2], vec![], vec![3, 4]])?, "the list henceforth `the list` where an item is the list where an item is 1 and another item is 2 and another item of `the list` is the empty list and another item is the list where an item is 3 and another i
```
<Overlap Ratio: 0.8840864440078585>

---

--- 23 --
Question ID: 11a41c56ce12ae30a52a9a4634b7c114286542f4_1
Original Code:
```
pub unsafe fn lv2_atom_sequence_append_event(
    seq: *mut LV2AtomSequence,
    capacity: u32,
    event: *const LV2AtomEvent,
) -> *const LV2AtomEvent {
    let total_size = size_of::<LV2AtomEvent>() as u32 + (*event).body.size;

    if (capacity - (*seq).atom.size) < total_size {
        return 0 as *const LV2AtomEvent;
    }

    let e = lv2_atom_sequence_end(&(*seq).body, (*seq).atom.size);
    memcpy(
        e as *mut c_void,
        event as *const c_void,
        total_size as usize,
    );

    (*seq).atom.size += lv2_atom_pad_size(total_size);

    e
}
```


Overlapping Code:
```
q: *mut LV2AtomSequence,
capacity: u32,
event: *const LV2AtomEvent,
) -> *const LV2AtomEvent {
let total_size = size_of::<LV2AtomEvent>() as u32 + (*event).body.size;
if (capacity - (*seq).atom.size) < total_size {
return 0 as *const LV2AtomEvent;
}
let e = lv2_atom_sequence_end(&(*seq).body, (*seq).atom.size);
memcpy(
e as *mut c_void,
event as *const c_void,
total_size as usize,
);
(*seq).atom.s
```
<Overlap Ratio: 0.8179959100204499>

---

--- 24 --
Question ID: 6178f7789e51d39c95384c36ca843b828e53c045_0
Original Code:
```
fn parse_chest(i: &[u8]) -> IResult<&[u8], Chest> {
    let (i, item_id) = le_u8(i)?;
    let (i, arg) = le_u8(i)?;
    let (i, text) = le_u8(i)?;
    let (i, unknown) = le_u8(i)?;

    Ok((
        i,
        Chest {
            item_id,
            arg,
            text,
            unknown,
        },
    ))
}
```


Overlapping Code:
```
st(i: &[u8]) -> IResult<&[u8], Chest> {
let (i, item_id) = le_u8(i)?;
let (i, arg) = le_u8(i)?;
let (i, text) = le_u8(i)?;
let (i, unknown) = le_u8(i)?;
Ok((
i,
Chest {
item_id,
arg,
text,
unknown,
},
```
<Overlap Ratio: 0.9216589861751152>

---

--- 25 --
Question ID: 0ff40e66345a25521016013896ad94c66b3d3645_0
Original Code:
```
fn roundtrip<T: Vlq>(value: T) -> T {
        let mut buf = vec![];
        buf.write_vlq(value).expect("successful write");
        Cursor::new(buf).read_vlq().expect("successful read")
    }
```


Overlapping Code:
```
lue: T) -> T {
let mut buf = vec![];
buf.write_vlq(value).expect("successful write");
Cursor::new(bu
```
<Overlap Ratio: 0.6097560975609756>

---

--- 26 --
Question ID: 79aeee125fc000f48463805cd42a44a104e6d011_4
Original Code:
```
fn semiconstrainted_bounds() {
    let data = b"\x02\x10\x01";
    let mut d = aper::Decoder::new(data);
    assert_eq!(4096, d.decode_int(Some(-1), None).unwrap());
}
```


Overlapping Code:
```
ainted_bounds() {
let data = b"\x02\x10\x01";
let mut d = aper::Decoder::new(data);
assert_eq!(4096,
```
<Overlap Ratio: 0.6451612903225806>

---

--- 27 --
Question ID: 020612929287927557a65376d349b8788eb72c48_1
Original Code:
```
fn extract_source(out_dir_path: &Path, version: &str) -> String {
    let archive_dir_path = out_dir_path.join("archive");
    if !archive_dir_path.exists() {
        std::fs::create_dir(&archive_dir_path)
            .expect(&format!("Failed to create {:?}", archive_dir_path));
    }

    let archive_file_path = archive_dir_path.join(format!("openh264-{}.tar.gz", version));
    if !archive_file_path.exists() {
        let url = format!(
            "https://github.com/cisco/openh264/archive/v{}.tar.gz",
            version
        );
        let mut response = reqwest::get(&url).expect(&format!("Failed to download {}", url));
        assert!(
            response.status().is_success(),
            format!("Request to {} doesn't succeed: {}", url, response.status())
        );
        let mut file_buf = Vec::new();
        response
            .copy_to(&mut file_buf)
            .expect(&format!("Failed to download {}", url));
        let mut file = File::create(&archive_file_path)
            .expect(&format!("Failed to create {:?}", archive_file_path));
        file.write_all(&file_buf).expect(&format!(
            "Failed to save {} to {:?}",
            url, archive_file_path
        ));
    }

    let mut archive_file =
        File::open(&archive_file_path).expect(&format!("Failed to open {:?}", archive_file_path));

    let mut gzip_decoder = gzip::Decoder::new(&mut archive_file).expect(&format!(
        "Failed to create gzip decoder for {:?}",
        archive_file_path
    ));
    let mut tar_vec = Vec::new();
    std::io::copy(&mut gzip_decoder, &mut tar_vec).expect(&format!(
        "Failed to extract gzip archive {:?}",
        archive_file_path
    ));

    let mut tar_archive = Archive::new(&tar_vec[..]);
    let tar_extract_dir_path = out_dir_path.join("src");
    if tar_extract_dir_path.exists() {
        std::fs::remove_dir_all(tar_extract_dir_path.clone()).expect(&format!(
            "Failed to remove old archive extraction dir: {:?}",
            tar_extract_dir_path.clone()
        ));
    }
    for mut entry in tar_archive
        .entries()
        .expect(&format!(
            "Failed to read tar archive entries in {:?}",
            archive_file_path
        ))
        .map(|entry| {
            entry.expect(&format!(
                "Failed to extract tar archive entry in {:?}",
                archive_file_path
            ))
        }) {
        entry
            .unpack_in(tar_extract_dir_path.clone())
            .expect(&format!(
                "Failed to unpack file in {:?} for {:?}",
                archive_file_path,
                entry.path()
            ));
    }

    let openh264_src_dir_path = std::fs::read_dir(&tar_extract_dir_path)
        .expect(&format!("Failed to read dir {:?}", tar_extract_dir_path))
        .map(|entry| {
            entry.expect(&format!(
                "Failed to read dir entry in {:?}",
                tar_extract_dir_path
            ))
        })
        .find(|entry| {
            entry
                .file_type()
                .expect(&format!(
                    "Failed to read file type for {:?} in {:?}",
                    entry, tar_extract_dir_path
                ))
                .is_dir()
        }).expect(
            &format!("Failed to find openh264 extracted src path in {:?}, perhaps downloaded archive {:?} was broken.",
            tar_extract_dir_path, archive_file_path)
        ).path();
    openh264_src_dir_path
        .to_str()
        .expect(&format!(
            "Failed to extract rust string from {:?}",
            openh264_src_dir_path
        ))
        .to_string()
}
```


Overlapping Code:
```
ath: &Path, version: &str) -> String {
let archive_dir_path = out_dir_path.join("archive");
if !archive_dir_path.exists() {
std::fs::create_dir(&archive_dir_path)
.expect(&format!("Failed to create {:?}", archive_dir_path));
}
let archive_file_path = archive_dir_path.join(format!("openh264-{}.tar.gz", version));
if !archive_file_path.exists() {
let url = format!(
"https://github.com/cisco/openh264/archive/v{}.tar.gz",
version
);
let mut response = reqwest::get(&url).expect(&format!("Failed to download {}", url));
assert!(
response.status().is_success(),
format!("Request to {} doesn't succeed: {}", url, response.status())
);
let mut file_buf = Vec::new();
response
.copy_to(&mut file_buf)
.expect(&format!("Failed to download {}", url));
let mut file = File::create(&archive_file_path)
.expect(&format!("Failed to create {:?}", archive_file_path));
file.write_all(&file_buf).expect(&format!(
"Failed to save {} to {:?}",
url, archive_file_path
));
}
let mut archive_file =
File::open(&archive_file_path).expect(&format!("Failed to open {:?}", archive_file_path));
let mut gzip_decoder = gzip::Decoder::new(&mut archive_file).expect(&format!(
"Failed to create gzip decoder for {:?}",
archive_file_path
));
let mut tar_vec = Vec::new();
std::io::copy(&mut gzip_decoder, &mut tar_vec).expect(&format!(
"Failed to extract gzip archive {:?}",
archive_file_path
));
let mut tar_archive = Archive::new(&tar_vec[..]);
let tar_extract_dir_path = out_dir_path.join("src");
if tar_extract_dir_path.exists() {
std::fs::remove_dir_all(tar_extract_dir_path.clone()).expect(&format!(
"Failed to remove old archive extraction dir: {:?}",
tar_extract_dir_path.clone()
));
}
for mut entry in tar_archive
.entries()
.expect(&format!(
"Failed to read tar archive entries in {:?}",
archive_file_path
))
.map(|entry| {
entry.expect(&format!(
"Failed to extract tar archive entry in {:?}",
archive_file_path
))
}) {
entry
.unpack_in(tar_extract_dir_path.clone())
.e
```
<Overlap Ratio: 0.9813789632611978>

---

--- 28 --
Question ID: 0d77e416beec73e8af5ac2311a94d63a5d5ff5e1_0
Original Code:
```
fn search(query: web::Query<SearchQuery>) -> impl Responder {

    let index_path = "/tmp/pkgbuildsearch";
    let directory = std::path::Path::new(&index_path);
    let index = Index::open_in_dir(directory).unwrap();
    let schema = index.schema();
    let pkgbuild = schema.get_field("pkgbuild").unwrap();
    let query_parser = QueryParser::new(schema.clone(), vec![pkgbuild], index.tokenizers().clone());

    let now = Instant::now();
    let index_query = query_parser.parse_query(&query.name.unwrap()).unwrap();
    let searcher = index.reader().unwrap().searcher();


    let top_docs = searcher.search(&index_query, &TopDocs::with_limit(10)).unwrap();

    for (_score, doc_address) in top_docs {
        let retrieved_doc = searcher.doc(doc_address).unwrap();
        let foo = retrieved_doc.get_all(pkgbuild);
        println!("{}", &foo[0].text().unwrap());
        //let values = retrieved_doc.get_all();
        //println!("{}", values[0].text);
        println!("{}", schema.to_json(&retrieved_doc));
    }

    /*
    let results = match &query.name {
        Some(name) => vec![name.clone()],
        None => vec![],
    };
    */

    HttpResponse::Ok().json(SearchResults {
        results: results,
    })
}
```


Overlapping Code:
```
uery<SearchQuery>) -> impl Responder {
let index_path = "/tmp/pkgbuildsearch";
let directory = std::path::Path::new(&index_path);
let index = Index::open_in_dir(directory).unwrap();
let schema = index.schema();
let pkgbuild = schema.get_field("pkgbuild").unwrap();
let query_parser = QueryParser::new(schema.clone(), vec![pkgbuild], index.tokenizers().clone());
let now = Instant::now();
let index_query = query_parser.parse_query(&query.name.unwrap()).unwrap();
let searcher = index.reader().unwrap().searcher();
let top_docs = searcher.search(&index_query, &TopDocs::with_limit(10)).unwrap();
for (_score, doc_address) in top_docs {
let retrieved_doc = searcher.doc(doc_address).unwrap();
let foo = retrieved_doc.get_all(pkgbuild);
println!("{}", &foo[0].text().unwrap());
//let values = retrieved_doc.get_all();
//println!("{}", values[0].text);
println!("{}", schema.to_json(&retrieved_doc));
}
/*
let results = match &query.name {
Some(name) => vec![name.clone()],
None => vec![],
};
*/
HttpResponse::Ok().json(SearchResults {
results: results,

```
<Overlap Ratio: 0.9749303621169917>

---

--- 29 --
Question ID: a9a03adb351f7cf0f5d6e58d7a4defffdc648980_1
Original Code:
```
fn decrypt(cipher_text: &[u8], key: &[u8]) -> Result<Vec<u8>> {
    if cipher_text.len() <= aes::BLOCK_SIZE {
        return Err(Error::CipherTextTooShort(cipher_text.len()));
    }
    let iv = &cipher_text[..aes::BLOCK_SIZE];
    let cipher_text = &cipher_text[aes::BLOCK_SIZE..];
    let cipher: Cbc<Aes128, Pkcs7> = Cbc::new_from_slices(key, iv)?;

    Ok(cipher.decrypt_vec(cipher_text)?)
}
```


Overlapping Code:
```
8]) -> Result<Vec<u8>> {
if cipher_text.len() <= aes::BLOCK_SIZE {
return Err(Error::CipherTextTooShort(cipher_text.len()));
}
let iv = &cipher_text[..aes::BLOCK_SIZE];
let cipher_text = &cipher_text[aes::BLOCK_SIZE..];
let cipher: Cbc<Aes128, Pkcs7> = Cbc::new_from_slices(key, iv)?;
Ok(cipher.decry
```
<Overlap Ratio: 0.8287292817679558>

---

--- 30 --
Question ID: 31c31cf725f85efbe01a963ef9302e300570b386_2
Original Code:
```
fn oxygen_spread_time(grid: &HashMap<(i64, i64), Tile>) -> i64 {
    let mut queue: VecDeque<(i64, i64)> = VecDeque::new();
    let mut discovered: HashSet<(i64, i64)> = HashSet::new();
    let mut distances: HashMap<(i64, i64), i64> = HashMap::new();

    let start_pos = *grid
        .iter()
        .filter(|(_, v)| **v == Tile::Oxygen)
        .map(|(k, _)| k)
        .next()
        .unwrap();

    discovered.insert(start_pos);
    queue.push_back(start_pos);
    distances.insert(start_pos, 0);
    while !queue.is_empty() {
        let v = queue.pop_front().unwrap();
        for npos in vec![
            (v.0 + 1, v.1),
            (v.0 - 1, v.1),
            (v.0, v.1 - 1),
            (v.0, v.1 + 1),
        ] {
            if *grid.get(&npos).unwrap_or(&Tile::Wall) == Tile::Wall {
                continue;
            } else if discovered.contains(&npos) {
                continue;
            }
            discovered.insert(npos);
            queue.push_back(npos);
            distances.insert(npos, distances.get(&v).unwrap_or(&0) + 1);
        }
    }
    *distances.values().max().unwrap()
}
```


Overlapping Code:
```
e(grid: &HashMap<(i64, i64), Tile>) -> i64 {
let mut queue: VecDeque<(i64, i64)> = VecDeque::new();
let mut discovered: HashSet<(i64, i64)> = HashSet::new();
let mut distances: HashMap<(i64, i64), i64> = HashMap::new();
let start_pos = *grid
.iter()
.filter(|(_, v)| **v == Tile::Oxygen)
.map(|(k, _)| k)
.next()
.unwrap();
discovered.insert(start_pos);
queue.push_back(start_pos);
distances.insert(start_pos, 0);
while !queue.is_empty() {
let v = queue.pop_front().unwrap();
for npos in vec![
(v.0 + 1, v.1),
(v.0 - 1, v.1),
(v.0, v.1 - 1),
(v.0, v.1 + 1),
] {
if *grid.get(&npos).unwrap_or(&Tile::Wall) == Tile::Wall {
continue;
} else if discovered.contains(&npos) {
continue;
}
discovered.insert(npos);
queue.push_back(npos);
distances.insert(npos, distances.get(&v).unwrap_or(&0) + 1);
}
}
*dist
```
<Overlap Ratio: 0.9400705052878966>

---

--- 31 --
Question ID: c2915c496d585ac52bdccdeadd76833b2c4030a5_4
Original Code:
```
fn spanning() {
		let data: u8 = 0u8;
		let bp = BitPtr::new(&data, 0u8.idx(), 8);

		assert!(bp.domain().is_spanning());

		let data: &[u16] = &[0u16, !0u16];
		let bp = BitPtr::new(&data[0], 0u8.idx(), 32);

		assert!(bp.domain().is_spanning());
	}
```


Overlapping Code:
```
nning() {
let data: u8 = 0u8;
let bp = BitPtr::new(&data, 0u8.idx(), 8);
assert!(bp.domain().is_spanning());
let data: &[u16] = &[0u16, !0u16];
let bp = BitPtr::new(&data[0], 0u8.idx(), 32);
assert!(bp.domain().is_spanning(
```
<Overlap Ratio: 0.9529914529914529>

---

--- 32 --
Question ID: 2afdd4248c765d2779b17e977ddbce15b85a65a3_4
Original Code:
```
fn plan_view_select(
    qcx: &QueryContext,
    s: &Select,
) -> Result<(RelationExpr, Scope), failure::Error> {
    // Step 1. Handle FROM clause, including joins.
    let (left, left_scope) = {
        let typ = RelationType::new(vec![]);
        (
            RelationExpr::constant(vec![vec![]], typ),
            Scope::from_source(
                None,
                iter::empty::<Option<ColumnName>>(),
                Some(qcx.outer_scope.clone()),
            ),
        )
    };
    let (mut relation_expr, from_scope) =
        s.from.iter().fold(Ok((left, left_scope)), |l, twj| {
            let (left, left_scope) = l?;
            plan_table_with_joins(qcx, left, left_scope, &JoinOperator::CrossJoin, twj)
        })?;

    // Step 2. Handle WHERE clause.
    if let Some(selection) = &s.selection {
        let ecx = &ExprContext {
            qcx,
            name: "WHERE clause",
            scope: &from_scope,
            relation_type: &qcx.relation_type(&relation_expr),
            allow_aggregates: false,
            allow_subqueries: true,
        };
        let expr = plan_expr(ecx, &selection, Some(ScalarType::Bool))?;
        let typ = ecx.column_type(&expr);
        if typ.scalar_type != ScalarType::Bool && typ.scalar_type != ScalarType::Unknown {
            bail!(
                "WHERE clause must have boolean type, not {:?}",
                typ.scalar_type
            );
        }
        relation_expr = relation_expr.filter(vec![expr]);
    }

    // Step 3. Handle GROUP BY clause.
    let (group_scope, select_all_mapping) = {
        // gather group columns
        let ecx = &ExprContext {
            qcx,
            name: "GROUP BY clause",
            scope: &from_scope,
            relation_type: &qcx.relation_type(&relation_expr),
            allow_aggregates: false,
            allow_subqueries: true,
        };
        let mut group_key = vec![];
        let mut group_exprs = vec![];
        let mut group_scope = Scope::empty(Some(qcx.outer_scope.clone()));
        let mut select_all_mapping = BTreeMap::new();
        for group_expr in &s.group_by {
            let (expr, maybe_name) =
                plan_expr_or_col_index(ecx, group_expr, Some(ScalarType::String), "GROUP BY")?;
            let new_column = group_key.len();
            // repeated exprs in GROUP BY confuse name resolution later, and dropping them doesn't change the result
            if group_exprs
                .iter()
                .find(|existing_expr| **existing_expr == expr)
                .is_none()
            {
                let scope_item = if let ScalarExpr::Column(ColumnRef {
                    level: 0,
                    column: old_column,
                }) = &expr
                {
                    // If we later have `SELECT foo.*` then we have to find all the `foo` items in `from_scope` and figure out where they ended up in `group_scope`.
                    // This is really hard to do right using SQL name resolution, so instead we just track the movement here.
                    select_all_mapping.insert(*old_column, new_column);
                    let mut scope_item = ecx.scope.items[*old_column].clone();
                    scope_item.expr = Some(group_expr.clone());
                    scope_item
                } else {
                    ScopeItem {
                        names: maybe_name.into_iter().collect(),
                        expr: Some(group_expr.clone()),
                        nameable: true,
                    }
                };

                group_key.push(from_scope.len() + group_exprs.len());
                group_exprs.push(expr);
                group_scope.items.push(scope_item);
            }
        }
        // gather aggregates
        let mut aggregate_visitor = AggregateFuncVisitor::new();
        for p in &s.projection {
            aggregate_visitor.visit_select_item(p);
        }
        if let Some(having) = &s.having {
            aggregate_visitor.visit_expr(having);
        }
        let ecx = &ExprContext {
            qcx,
            name: "aggregate function",
            scope: &from_scope,
            relation_type: &qcx.relation_type(&relation_expr.clone().map(group_exprs.clone())),
            allow_aggregates: false,
            allow_subqueries: true,
        };
        let mut aggregates = vec![];
        for sql_function in aggregate_visitor.into_result()? {
            aggregates.push(plan_aggregate(ecx, sql_function)?);
            group_scope.items.push(ScopeItem {
                names: vec![ScopeItemName {
                    table_name: None,
                    column_name: Some(sql_function.name.to_string().into()),
                }],
                expr: Some(Expr::Function(sql_function.clone())),
                nameable: true,
            });
        }
        if !aggregates.is_empty() || !group_key.is_empty() || s.having.is_some() {
            // apply GROUP BY / aggregates
            relation_expr = relation_expr.map(group_exprs).reduce(group_key, aggregates);
            (group_scope, select_all_mapping)
        } else {
            // if no GROUP BY, aggregates or having then all columns remain in scope
            (
                from_scope.clone(),
                (0..from_scope.len()).map(|i| (i, i)).collect(),
            )
        }
    };

    // Step 4. Handle HAVING clause.
    if let Some(having) = &s.having {
        let ecx = &ExprContext {
            qcx,
            name: "HAVING clause",
            scope: &group_scope,
            relation_type: &qcx.relation_type(&relation_expr),
            allow_aggregates: true,
            allow_subqueries: true,
        };
        let expr = plan_expr(ecx, having, Some(ScalarType::Bool))?;
        let typ = ecx.column_type(&expr);
        if typ.scalar_type != ScalarType::Bool {
            bail!(
                "HAVING clause must have boolean type, not {:?}",
                typ.scalar_type
            );
        }
        relation_expr = relation_expr.filter(vec![expr]);
    }

    // Step 5. Handle projections.
    let project_scope = {
        let mut project_exprs = vec![];
        let mut project_key = vec![];
        let mut project_scope = Scope::empty(Some(qcx.outer_scope.clone()));
        for p in &s.projection {
            let ecx = &ExprContext {
                qcx,
                name: "SELECT clause",
                scope: &group_scope,
                relation_type: &qcx.relation_type(&relation_expr),
                allow_aggregates: true,
                allow_subqueries: true,
            };
            for (expr, scope_item) in plan_select_item(ecx, p, &from_scope, &select_all_mapping)? {
                project_key.push(group_scope.len() + project_exprs.len());
                project_exprs.push(expr);
                project_scope.items.push(scope_item);
            }
        }
        relation_expr = relation_expr.map(project_exprs).project(project_key);
        project_scope
    };

    // Step 6. Handle DISTINCT.
    if s.distinct {
        relation_expr = relation_expr.distinct();
    }

    Ok((relation_expr, project_scope))
}
```


Overlapping Code:
```
lect,
) -> Result<(RelationExpr, Scope), failure::Error> {
// Step 1. Handle FROM clause, including joins.
let (left, left_scope) = {
let typ = RelationType::new(vec![]);
(
RelationExpr::constant(vec![vec![]], typ),
Scope::from_source(
None,
iter::empty::<Option<ColumnName>>(),
Some(qcx.outer_scope.clone()),
),
)
};
let (mut relation_expr, from_scope) =
s.from.iter().fold(Ok((left, left_scope)), |l, twj| {
let (left, left_scope) = l?;
plan_table_with_joins(qcx, left, left_scope, &JoinOperator::CrossJoin, twj)
})?;
// Step 2. Handle WHERE clause.
if let Some(selection) = &s.selection {
let ecx = &ExprContext {
qcx,
name: "WHERE clause",
scope: &from_scope,
relation_type: &qcx.relation_type(&relation_expr),
allow_aggregates: false,
allow_subqueries: true,
};
let expr = plan_expr(ecx, &selection, Some(ScalarType::Bool))?;
let typ = ecx.column_type(&expr);
if typ.scalar_type != ScalarType::Bool && typ.scalar_type != ScalarType::Unknown {
bail!(
"WHERE clause must have boolean type, not {:?}",
typ.scalar_type
);
}
relation_expr = relation_expr.filter(vec![expr]);
}
// Step 3. Handle GROUP BY clause.
let (group_scope, select_all_mapping) = {
// gather group columns
let ecx = &ExprContext {
qcx,
name: "GROUP BY clause",
scope: &from_scope,
relation_type: &qcx.relation_type(&relation_expr),
allow_aggregates: false,
allow_subqueries: true,
};
let mut group_key = vec![];
let mut group_exprs = vec![];
let mut group_scope = Scope::empty(Some(qcx.outer_scope.clone()));
let mut select_all_mapping = BTreeMap::new();
for group_expr in &s.group_by {
let (expr, maybe_name) =
plan_expr_or_col_index(ecx, group_expr, Some(ScalarType::String), "GROUP BY")?;
let new_column = group_key.len();
// repeated exprs in GROUP BY confuse name resolution later, and dropping them doesn't change the result
if group_exprs
.iter()
.find(|existing_
```
<Overlap Ratio: 0.9751191106405506>

---

--- 33 --
Question ID: d6da04f2ad54b77b73638ecff4dd44a9e9641e40_21
Original Code:
```
fn test_sub_without_overflow() {
        let mut vm = VM::new();
        vm.registers.v[1] = 150;
        vm.registers.v[2] = 100;
        vm.registers.v[0xF] = 4;
        vm.registers.program_counter = 0x200;

        vm.sub(1, 2);

        assert_eq!(vm.registers.v[1], 50);
        assert_eq!(vm.registers.v[2], 100);
        assert_eq!(vm.registers.v[0xF], 1);
        assert_eq!(vm.registers.program_counter, 0x202);
    }
```


Overlapping Code:
```
b_without_overflow() {
let mut vm = VM::new();
vm.registers.v[1] = 150;
vm.registers.v[2] = 100;
vm.registers.v[0xF] = 4;
vm.registers.program_counter = 0x200;
vm.sub(1, 2);
assert_eq!(vm.registers.v[1], 50);
assert_eq!(vm.registers.v[2], 100);
assert_eq!(vm.registers.v[0xF], 1);
assert_eq!(vm.registers.program_counter, 0x202);
}
```
<Overlap Ratio: 0.9706744868035191>

---

--- 34 --
Question ID: 0590099249d796094a169a4df930df285e65c447_0
Original Code:
```
pub fn file_to_lines(path: &str) -> Vec<String> {
    let path = Path::new(path);
    let file = File::open(&path).unwrap();
    let lines = io::BufReader::new(file).lines();
    let mut str_lines: Vec<String> = vec![];

    for line in lines {
        if let Ok(line) = line {
            str_lines.push(line);
        };
    }
    str_lines
}
```


Overlapping Code:
```
<String> {
let path = Path::new(path);
let file = File::open(&path).unwrap();
let lines = io::BufReader::new(file).lines();
let mut str_lines: Vec<String> = vec![];
for line in lines {
if let Ok(line)
```
<Overlap Ratio: 0.6968641114982579>

---

--- 35 --
Question ID: 3ca056d372b38f8b3c1e7c3d1f5bd313aae131be_1
Original Code:
```
fn multi_thread_load_std(b: &mut Bencher) {
    let v = Arc::new(StdAtomicImmut::new(vec![0, 1, 2]));
    let thread_count = 8;
    let barrier = Arc::new(Barrier::new(thread_count));
    for _ in 0..thread_count {
        let v = Arc::clone(&v);
        let barrier = Arc::clone(&barrier);
        thread::spawn(move || {
            while !v.load().is_empty() {}
            barrier.wait();
        });
    }
    thread::sleep(Duration::from_millis(10));
    b.iter(|| {
        test::black_box(v.load());
    });
    v.store(vec![]);
    barrier.wait();
    assert_eq!(Arc::strong_count(&v.load()), 2);
}
```


Overlapping Code:
```
ead_load_std(b: &mut Bencher) {
let v = Arc::new(StdAtomicImmut::new(vec![0, 1, 2]));
let thread_count = 8;
let barrier = Arc::new(Barrier::new(thread_count));
for _ in 0..thread_count {
let v = Arc::clone(&v);
let barrier = Arc::clone(&barrier);
thread::spawn(move || {
while !v.load().is_empty() {}
barrier.wait();
});
}
thread::sleep(Duration::from_millis(10));
b.iter(|| {
test::black_box(v.load());
});
v.store(vec![]);
barrier.wait();
assert_eq!(Arc::strong_
```
<Overlap Ratio: 0.9298597194388778>

---

--- 36 --
Question ID: fc6ad78c4d1e42f3343903b80a503255bd5a2983_0
Original Code:
```
fn get_status_change_time(metadata: &Metadata) -> Option<SystemTime> {
    use std::time::{Duration, UNIX_EPOCH};
    use std::os::unix::fs::MetadataExt;

    UNIX_EPOCH.checked_add(Duration::from_secs(metadata.ctime() as u64))
}
```


Overlapping Code:
```
 get_status_change_time(metadata: &Metadata) -> Option<SystemTime> {
use std::time::{Duration, UNIX_EPOCH};
use std::os::unix::fs::MetadataExt;
UNIX_EPOCH.checked_add(Duration::from_secs(metadata.ctim
```
<Overlap Ratio: 0.9259259259259259>

---

--- 37 --
Question ID: 9fd5c913b01e8b859e8b16479ad5cd8468e515ea_11
Original Code:
```
fn read_array<R: io::Read, A: Array<Item = Self>>(
        state: State<Bytes>,
        ty: u16,
        arr: &mut A,
        r: &mut R
    ) -> io::Result<()> {
        use std::usize;

        let self_ty = <Self as Scalar>::ty();
        if let Some((ty, rows, cols)) = Type::info(ty) {
            if ty == self_ty && rows == 1 && cols == 1 {
                let mut bytes = 0;
                let state = state.read_bytes(&mut bytes, r)?;
                let (_, scalar_bytes) = self_ty.scalar();
                if bytes % scalar_bytes == 0 {
                    let n = bytes / scalar_bytes;
                    let mut offset = 0;
                    let state = state.read_offset_instance_id(&mut offset, r)?;
                    for i in offset..(offset + n) {
                        if i > usize::MAX as u64 {
                            return Err(io::ErrorKind::Other.into());
                        }
                        while i as usize >= arr.len() {
                            arr.push(Default::default());
                        }
                        let mut scalar: Self = Default::default();
                        scalar.read(r)?;
                        arr.set(i as usize, scalar);
                    }
                    state.end_data().has_end_bytes(r)?;
                    return Ok(())
                }
            }
        }
        return Err(io::ErrorKind::InvalidData.into())
    }
```


Overlapping Code:
```
 read_array<R: io::Read, A: Array<Item = Self>>(
state: State<Bytes>,
ty: u16,
arr: &mut A,
r: &mut R
) -> io::Result<()> {
use std::usize;
let self_ty = <Self as Scalar>::ty();
if let Some((ty, rows, cols)) = Type::info(ty) {
if ty == self_ty && rows == 1 && cols == 1 {
let mut bytes = 0;
let state = state.read_bytes(&mut bytes, r)?;
let (_, scalar_bytes) = self_ty.scalar();
if bytes % scalar_bytes == 0 {
let n = bytes / scalar_bytes;
let mut offset = 0;
let state = state.read_offset_instance_id(&mut offset, r)?;
for i in offset..(offset + n) {
if i > usize::MAX as u64 {
return Err(io::ErrorKind::Other.into());
}
while i as usize >= arr.len() {
arr.push(Default::default());
}
let mut scalar: Self = Default::default();
scalar.read(r)?;
arr.set(i as usize, scalar);
}
state.end_data().has_end_bytes(r)?;
return Ok(())
}
}
}
return Err(io::ErrorKin
```
<Overlap Ratio: 0.9705215419501134>

---

--- 38 --
Question ID: 99dfcbf5c0548870980fbec0661eaaa6486405a4_1
Original Code:
```
fn type_parser(text: Span) -> IResult<Span, &str, GSError> {
    let (text, _) = multispace0(text)?;
    let (text, _) = tag("(")(text)?;
    let (text, _) = multispace0(text)?;
    let (text, _) = tag("<-")(text)?;
    let (text, _) = multispace0(text)?;
    let (text, type_name) = identifier(text)?;
    let (text, _) = multispace0(text)?;
    let (text, _) = tag(")")(text)?;
    let (text, _) = multispace0(text)?;
    Ok((text, type_name))
}
```


Overlapping Code:
```
, &str, GSError> {
let (text, _) = multispace0(text)?;
let (text, _) = tag("(")(text)?;
let (text, _) = multispace0(text)?;
let (text, _) = tag("<-")(text)?;
let (text, _) = multispace0(text)?;
let (text, type_name) = identifier(text)?;
let (text, _) = multispace0(text)?;
let (text, _) = tag(")")(text)?;
let (text, _) = multispace0(text)?;
Ok((text
```
<Overlap Ratio: 0.85995085995086>

---

--- 39 --
Question ID: fcd05303490c8be808ec77e0a51092e507f2c099_0
Original Code:
```
fn get_input() -> std::io::Result<String> {
    let mut file = File::open("08.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;

    Ok(contents)
}
```


Overlapping Code:
```
fn get_input() -> std::io::Result<String> {
let mut file = File::open("08.txt")?;
let mut contents = String::new();
file.read_to_string(&mut contents)?;
Ok(contents)
}
```
<Overlap Ratio: 1.0>

---

--- 40 --
Question ID: dec557fbd88aa369ae7364c3771e2af1b0335fd1_0
Original Code:
```
fn make_producer<'a>(
    config: &'a Config,
    reused_producers: &mut ReusedProducersMap<'a>,
    kafka_topic: KafkaTopic,
) -> Result<Producer, ServerError> {
    let (config_name, kafka_config) = config
        .kafka_config(kafka_topic)
        .context(ServerErrorKind::KafkaError)?;

    if let Some(producer) = reused_producers.get(&config_name) {
        return Ok(Arc::clone(producer));
    }

    let mut client_config = ClientConfig::new();

    for config_p in kafka_config {
        client_config.set(config_p.name.as_str(), config_p.value.as_str());
    }

    let producer = Arc::new(
        client_config
            .create_with_context(CaptureErrorContext)
            .context(ServerErrorKind::KafkaError)?,
    );

    reused_producers.insert(config_name, Arc::clone(&producer));
    Ok(producer)
}
```


Overlapping Code:
```
nfig,
reused_producers: &mut ReusedProducersMap<'a>,
kafka_topic: KafkaTopic,
) -> Result<Producer, ServerError> {
let (config_name, kafka_config) = config
.kafka_config(kafka_topic)
.context(ServerErrorKind::KafkaError)?;
if let Some(producer) = reused_producers.get(&config_name) {
return Ok(Arc::clone(producer));
}
let mut client_config = ClientConfig::new();
for config_p in kafka_config {
client_config.set(config_p.name.as_str(), config_p.value.as_str());
}
let producer = Arc::new(
client_config
.create_with_context(CaptureErrorContext)
.context(ServerErrorKind::KafkaError)?,
);
reused_producers.insert(config_name, Arc::clone(&producer));

```
<Overlap Ratio: 0.9285714285714286>

---

--- 41 --
Question ID: 3996a02b568d788a269bc90728cd0fdf9727f94f_4
Original Code:
```
fn run_tests_run_failed() {
        init();
        let plugin = RPlugin {};
        let temp = copy_test("tests/data/simple_run_fail");

        let mut run = plugin.run_tests(temp.path(), &mut vec![]).unwrap();
        assert_eq!(run.status, RunStatus::CompileFailed);
        assert!(run.test_results.is_empty());
        assert!(!run.logs.is_empty());
        let logs = run.logs.remove("compiler_output").unwrap();
        assert!(logs.contains("unexpected 'in'"))
    }
```


Overlapping Code:
```
() {
init();
let plugin = RPlugin {};
let temp = copy_test("tests/data/simple_run_fail");
let mut run = plugin.run_tests(temp.path(), &mut vec![]).unwrap();
assert_eq!(run.status, RunStatus::CompileFailed);
assert!(run.test_results.is_empty());
assert!(!run.logs.is_empty());
let logs = run.logs.remove("compiler_output").unwrap();
assert!(logs.contains("unexpec
```
<Overlap Ratio: 0.9095477386934674>

---

--- 42 --
Question ID: b39b77a7eb46da74aaa8104ef037461c1db3d62d_1
Original Code:
```
pub fn fmt_align_fraction_strings(strings: &[&str]) -> Vec<String> {
    // normalize all fractional parts
    let strings = strings.iter()
        .map(|x| normalize_fraction_part(x))
        .collect::<Vec<&str>>();

    let max = strings.iter()
        .map(|x| get_whole_part(x))
        .map(|x| x.len())
        .max()
        .unwrap();

    // create n new strings
    let mut new_strings = vec![String::new(); strings.len()];
    strings.iter().enumerate().for_each(|(index, string)| {
        let whole_part = get_whole_part(string);
        let spaces = max - whole_part.len();
        new_strings[index].push_str(&" ".repeat(spaces));
        new_strings[index].push_str(string);
    });

    // now add spaces in the end so that all are exactly same aligned, on left
    // as well as right; technically this is not really needed, but it may
    // help in some situations. Also this can be easily revoked with a right trim.
    let max = new_strings.iter().map(|s| s.len()).max().unwrap();
    for string in &mut new_strings {
        let spaces = max - string.len();
        string.push_str(&" ".repeat(spaces))
    }

    new_strings
}
```


Overlapping Code:
```
ign_fraction_strings(strings: &[&str]) -> Vec<String> {
// normalize all fractional parts
let strings = strings.iter()
.map(|x| normalize_fraction_part(x))
.collect::<Vec<&str>>();
let max = strings.iter()
.map(|x| get_whole_part(x))
.map(|x| x.len())
.max()
.unwrap();
// create n new strings
let mut new_strings = vec![String::new(); strings.len()];
strings.iter().enumerate().for_each(|(index, string)| {
let whole_part = get_whole_part(string);
let spaces = max - whole_part.len();
new_strings[index].push_str(&" ".repeat(spaces));
new_strings[index].push_str(string);
});
// now add spaces in the end so that all are exactly same aligned, on left
// as well as right; technically this is not really needed, but it may
// help in some situations. Also this can be easily revoked with a right trim.
let max = new_strings.iter().map(|s| s.len()).max().unwrap();
for string in &mut new_strings {
let spaces = max - string.len();
string.push_str(&" "
```
<Overlap Ratio: 0.9547738693467337>

---

--- 43 --
Question ID: fd8c747767a7d7ab57e24f0e01c8da640ca43a11_1
Original Code:
```
fn unknown_field() {
  let mut directory = Directory::new();
  directory.mut_unknown_fields().add_fixed32(42, 42);
  let error = verify_directory_canonical(&directory).expect_err("Want error");
  assert!(
    error.contains("unknown"),
    format!("Bad error message: {}", error)
  );
}
```


Overlapping Code:
```
eld() {
let mut directory = Directory::new();
directory.mut_unknown_fields().add_fixed32(42, 42);
let error = verify_directory_canonical(&directory).expect_err("Want error");
assert!(
error.contains("unknown"),
format!("Bad error message: {}", error)
```
<Overlap Ratio: 0.9328358208955224>

---

--- 44 --
Question ID: 41be272e8bf8ef00205d4693fece991dbaa2f42a_32
Original Code:
```
pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        private_cloud_name: &str,
        global_reach_connection_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            private_cloud_name,
            global_reach_connection_name
        );
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn delete(
operation_config: &crate::OperationConfig,
subscription_id: &str,
resource_group_name: &str,
private_cloud_name: &str,
global_reach_connection_name: &str,
) -> std::result::Result<delete::Response, delete::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.AVS/privateClouds/{}/globalReachConnections/{}",
operation_config.base_path(),
subscription_id,
resource_group_name,
private_cloud_name,
global_reach_connection_name
);
let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::DELETE);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(delete::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => Ok(delete::Response::Ok200),
http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::CloudError =
serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
Err(delete::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 45 --
Question ID: 7b988240c3d2edf85d1db4303bcc43a0fdfa1e64_3
Original Code:
```
fn parse_execute_arguments(
    execute_arguments: Pair<'_, Rule>,
) -> ParseResult<Option<ExecuteArguments>, Rule> {
    let mut execute_arguments_elements = execute_arguments.into_inner();

    let execute_argument_delimiter =
        next_match(&mut execute_arguments_elements, Rule::execute_argument_delimiter)?;
    let parsed_execute_argument_delimiter =
        parse_execute_argument_delimiter(execute_argument_delimiter)?;

    let arguments = next_match(&mut execute_arguments_elements, Rule::arguments)?;
    let parsed_arguments = ARGUMENTS_PARSER.parse_arguments(arguments)?;

    Ok(Some(ExecuteArguments {
        nonstandard_delimiter: parsed_execute_argument_delimiter,
        arguments: parsed_arguments,
    }))
}
```


Overlapping Code:
```
te_arguments(
execute_arguments: Pair<'_, Rule>,
) -> ParseResult<Option<ExecuteArguments>, Rule> {
let mut execute_arguments_elements = execute_arguments.into_inner();
let execute_argument_delimiter =
next_match(&mut execute_arguments_elements, Rule::execute_argument_delimiter)?;
let parsed_execute_argument_delimiter =
parse_execute_argument_delimiter(execute_argument_delimiter)?;
let arguments = next_match(&mut execute_arguments_elements, Rule::arguments)?;
let parsed_arguments = ARGUMENTS_PARSER.parse_arguments(arguments)?;
Ok(Some(ExecuteArguments {
nonstandard_delimiter: parsed_execute_argument_delimiter,
arguments: parsed_arguments,
}))
```
<Overlap Ratio: 0.975975975975976>

---

--- 46 --
Question ID: 8d8fadecd8509910e7928c25323c57d0b1591180_24
Original Code:
```
fn assert_create_poll_result(
        poll_id: u64,
        quorum: u8,
        end_height: u64,
        start_height: u64,
        creator: &str,
        handle_res: HandleResponse,
        deps: &mut Extern<MockStorage, MockApi, MockQuerier>,
    ) {
        assert_eq!(
            handle_res.log,
            vec![
                log("action", "create_poll"),
                log("creator", creator),
                log("poll_id", poll_id.to_string()),
                log("quorum_percentage", quorum.to_string()),
                log("end_height", end_height.to_string()),
                log("start_height", start_height.to_string()),
            ]
        );

        //confirm poll count
        let state = config_read(&deps.storage).load().unwrap();
        assert_eq!(
            state,
            State {
                denom: String::from(VOTING_TOKEN),
                owner: deps
                    .api
                    .canonical_address(&HumanAddr::from(TEST_CREATOR))
                    .unwrap(),
                poll_count: 1,
                staked_tokens: Uint128::zero(),
            }
        );
    }
```


Overlapping Code:
```
esult(
poll_id: u64,
quorum: u8,
end_height: u64,
start_height: u64,
creator: &str,
handle_res: HandleResponse,
deps: &mut Extern<MockStorage, MockApi, MockQuerier>,
) {
assert_eq!(
handle_res.log,
vec![
log("action", "create_poll"),
log("creator", creator),
log("poll_id", poll_id.to_string()),
log("quorum_percentage", quorum.to_string()),
log("end_height", end_height.to_string()),
log("start_height", start_height.to_string()),
]
);
//confirm poll count
let state = config_read(&deps.storage).load().unwrap();
assert_eq!(
state,
State {
denom: String::from(VOTING_TOKEN),
owner: deps
.api
.canonical_address(&HumanAddr::from(TEST_CREATOR))
.unwrap(),
poll_count: 1,
```
<Overlap Ratio: 0.9151846785225718>

---

--- 47 --
Question ID: f31d53b497e1ea5034a1388cecb4dfd0f3ef1182_1
Original Code:
```
fn decrease_lives(game_state : &mut GameState, game_time : GameTime) {
    let ball : &mut Ball = &mut game_state.ball;

    game_state.lives = max(game_state.lives, 1) - 1;

    if game_state.lives != 0 {
        ball.reset_position();
    }
    else {
        game_state.stage = GameStage::GameOver;
        game_state.game_over_time = game_time.real_time;
    }
}
```


Overlapping Code:
```
ameState, game_time : GameTime) {
let ball : &mut Ball = &mut game_state.ball;
game_state.lives = max(game_state.lives, 1) - 1;
if game_state.lives != 0 {
ball.reset_position();
}
else {
game_state.stage = GameStage::GameOver;
game_state.game_over_ti
```
<Overlap Ratio: 0.7911392405063291>

---

--- 48 --
Question ID: 85ed9c718ece9892d3ddd73d08cdc6a13b30538f_3
Original Code:
```
fn addThreeBytesAsOctal( mut input: Vec<u8>, bytes: &[u8] ) -> Vec<u8> {
  // &[u8] -> &str -> u8 -> write to input

  let slice: &str = from_utf8( &bytes ).unwrap();
  match u8::from_str_radix( slice, 8 ) {
    Ok( byte ) => input.push( byte ),
    _ => panic!( r"Invalid octal escape sequence: \{}{}{}",
                bytes.get( 0 ).unwrap(),
                bytes.get( 1 ).unwrap(),
                bytes.get( 2 ).unwrap() )
  }
  input
}
```


Overlapping Code:
```
ddThreeBytesAsOctal( mut input: Vec<u8>, bytes: &[u8] ) -> Vec<u8> {
// &[u8] -> &str -> u8 -> write to input
let slice: &str = from_utf8( &bytes ).unwrap();
match u8::from_str_radix( slice, 8 ) {
Ok( byte ) => input.push( byte ),
_ => panic!( r"Invalid octal escape sequence: \{}{}{}",
bytes.get( 0 ).unwrap(),
bytes.get( 1 ).unwrap(),
bytes.get( 2 
```
<Overlap Ratio: 0.9308510638297872>

---

--- 49 --
Question ID: 05860734373d40c5d5847bede6857e2a4dd82493_3
Original Code:
```
fn one_plus_one_v2() {
        let engine = RebEngine::new();
        let one = engine.integer(1);
        let two = engine.value3(&one, &CUtf8::new("+"), &one);
        assert_eq!(2, two.unbox_integer());
    }
```


Overlapping Code:
```

let engine = RebEngine::new();
let one = engine.integer(1);
let two = engine.value3(&one, &CUtf8::new("+"), &one);
assert_eq!(2, two.unbox_integer())
```
<Overlap Ratio: 0.8571428571428571>

---

--- 50 --
Question ID: 524f1f1b952081f904dad4722674f61e98cb791f_5
Original Code:
```
pub fn atan2(y: f64, x: f64) -> f64 {
    let mut r = atan2k(fabsk(y), x);

    r = if y == 0. {
        (if sign(x) == -1. { PI } else { 0. })
    } else if y.is_infinite() {
        FRAC_PI_2
            - (if x.is_infinite() {
                sign(x) * FRAC_PI_4
            } else {
                0.
            })
    } else if x.is_infinite() || (x == 0.) {
        FRAC_PI_2
            - (if x.is_infinite() {
                (sign(x) * FRAC_PI_2)
            } else {
                0.
            })
    } else {
        mulsign(r, x)
    };
    if x.is_nan() || y.is_nan() {
        f64::NAN
    } else {
        mulsign(r, y)
    }
}
```


Overlapping Code:
```
: f64, x: f64) -> f64 {
let mut r = atan2k(fabsk(y), x);
r = if y == 0. {
(if sign(x) == -1. { PI } else { 0. })
} else if y.is_infinite() {
FRAC_PI_2
- (if x.is_infinite() {
sign(x) * FRAC_PI_4
} else {
0.
})
} else if x.is_infinite() || (x == 0.) {
FRAC_PI_2
- (if x.is_infinite() {
(sign(x) * FRAC_PI_2)
} else {
0.
})
} else {
mulsign(r, x)
};
if x.is_nan() || y.is_nan() {
f64::NAN
} else {
muls
```
<Overlap Ratio: 0.936768149882904>

---

--- 51 --
Question ID: 45bf57b5947e41372a9421485098ce660065bd34_33
Original Code:
```
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
```


Overlapping Code:
```
n bindgen_test_layout___darwin_mcontext_avx512_32() {
assert_eq!(
::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
1112usize,
concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
);
assert_eq!(
::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
4usize,
concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx512_32),
"::",
stringify!(__es)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
},
12usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx512_32),
"::",
stringify!(__ss)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
},
76usize,
concat!(
"Offset of field: ",
stringify!(__darwin_mcontext_avx512_32),
"::",
stringify!(__fs)
)
);

```
<Overlap Ratio: 0.9979654120040692>

---

--- 52 --
Question ID: 1930e58121c66a8b9404a4b2df4e8c017aea6035_4
Original Code:
```
fn try_read_by_range() {
        let space = TreeObjectSpace::new();
        assert_eq!(space.try_read_by_range::<i64, _>("", 2..4), None);
        space.write::<i64>(3);
        space.write::<i64>(5);

        assert_eq!(space.try_read_by_range::<i64, _>("", 2..4), Some(3));
        assert_ne!(space.try_read_by_range::<i64, _>("", 2..4), None);

        space.write(TestStruct {
            count: 3,
            name: String::from("Tuan"),
        });
        space.write(TestStruct {
            count: 5,
            name: String::from("Duane"),
        });

        assert_eq!(
            space.try_read_by_range::<TestStruct, _>("count", 2..4),
            Some(TestStruct {
                count: 3,
                name: String::from("Tuan"),
            })
        );
        assert!(
            space
                .try_read_by_range::<TestStruct, _>("count", 2..4)
                .is_some()
        );

        space.write(CompoundStruct {
            person: TestStruct {
                count: 5,
                name: String::from("Duane"),
            },
            gpa: 3.0,
        });
        space.write(CompoundStruct {
            person: TestStruct {
                count: 3,
                name: String::from("Tuan"),
            },
            gpa: 3.5,
        });

        assert_eq!(
            space.try_read_by_range::<CompoundStruct, _>("person.count", 2..4),
            Some(CompoundStruct {
                person: TestStruct {
                    count: 3,
                    name: String::from("Tuan"),
                },
                gpa: 3.5
            })
        );
        assert!(
            space
                .try_read_by_range::<CompoundStruct, _>("person.count", 2..4)
                .is_some()
        );
    }
```


Overlapping Code:
```
et space = TreeObjectSpace::new();
assert_eq!(space.try_read_by_range::<i64, _>("", 2..4), None);
space.write::<i64>(3);
space.write::<i64>(5);
assert_eq!(space.try_read_by_range::<i64, _>("", 2..4), Some(3));
assert_ne!(space.try_read_by_range::<i64, _>("", 2..4), None);
space.write(TestStruct {
count: 3,
name: String::from("Tuan"),
});
space.write(TestStruct {
count: 5,
name: String::from("Duane"),
});
assert_eq!(
space.try_read_by_range::<TestStruct, _>("count", 2..4),
Some(TestStruct {
count: 3,
name: String::from("Tuan"),
})
);
assert!(
space
.try_read_by_range::<TestStruct, _>("count", 2..4)
.is_some()
);
space.write(CompoundStruct {
person: TestStruct {
count: 5,
name: String::from("Duane"),
},
gpa: 3.0,
});
space.write(CompoundStruct {
person: TestStruct {
count: 3,
name: String::from("Tuan"),
},
gpa: 3.5,
});
assert_eq!(
space.try_read_by_range::<CompoundStruct, _>("person.count", 2..4),
Some(CompoundStruct {
person: TestStruct {
count: 3,
name: String::from("Tuan"),
},
gpa: 3.5
})
);
assert!(
space
.try_read_by_range::<CompoundStruct, _>("person.count", 2..4)
.is_some()
);

```
<Overlap Ratio: 0.9760425909494232>

---

--- 53 --
Question ID: f58e2d5926d0996b99f5c3c7a5590c917f489ca5_2
Original Code:
```
fn test_error_parsing_custom_fields() {
        let data = "\
foo,bar,baz
Foo,1,3
";
        // ugly: Can deserialize_dow_field take a DeRecordWrap instead to add field info?
        let expected = "error parsing test.txt:2 - day of week field was not 0 or 1";

        let reader = csv::Reader::from_reader(data.as_bytes());
        let mut iter: GTFSIterator<_, Test> = GTFSIterator::new(reader, "test.txt").unwrap();

        let result = iter.next().unwrap().err().unwrap();
        assert_eq!(expected, format!("{}", result));
    }
```


Overlapping Code:
```
t data = "\
foo,bar,baz
Foo,1,3
";
// ugly: Can deserialize_dow_field take a DeRecordWrap instead to add field info?
let expected = "error parsing test.txt:2 - day of week field was not 0 or 1";
let reader = csv::Reader::from_reader(data.as_bytes());
let mut iter: GTFSIterator<_, Test> = GTFSIterator::new(reader, "test.txt").unwrap();
let result = iter.next().unwrap().err().unwrap();
assert_eq!(expected, format!("{}"
```
<Overlap Ratio: 0.8842105263157894>

---

--- 54 --
Question ID: 3d8aa3780748940ebfb8f69f7d249ae0908906f6_20
Original Code:
```
fn _build_get_attrib_request(command_handle: IndyHandle, submitter_did: Option<&str>, target_did: &str, raw: Option<&str>, hash: Option<&str>, enc: Option<&str>, cb: Option<ResponseStringCB>) -> ErrorCode {
    let submitter_did_str = opt_c_str!(submitter_did);
    let target_did = c_str!(target_did);

    let raw_str = opt_c_str!(raw);
    let hash_str = opt_c_str!(hash);
    let enc_str = opt_c_str!(enc);

    ErrorCode::from(unsafe {
        ledger::indy_build_get_attrib_request(command_handle,
                                              opt_c_ptr!(submitter_did, submitter_did_str),
                                              target_did.as_ptr(),
                                              opt_c_ptr!(raw, raw_str),
                                              opt_c_ptr!(hash, hash_str),
                                              opt_c_ptr!(enc, enc_str),
                                              cb)
    })
}
```


Overlapping Code:
```
_request(command_handle: IndyHandle, submitter_did: Option<&str>, target_did: &str, raw: Option<&str>, hash: Option<&str>, enc: Option<&str>, cb: Option<ResponseStringCB>) -> ErrorCode {
let submitter_did_str = opt_c_str!(submitter_did);
let target_did = c_str!(target_did);
let raw_str = opt_c_str!(raw);
let hash_str = opt_c_str!(hash);
let enc_str = opt_c_str!(enc);
ErrorCode::from(unsafe {
ledger::indy_build_get_attrib_request(command_handle,
opt_c_ptr!(submitter_did, submitter_did_str),
target_did.as_ptr(),
opt_c_ptr!(raw, raw_str),
opt_c_ptr!(hash, hash_str),

```
<Overlap Ratio: 0.9134615384615384>

---

--- 55 --
Question ID: 2a5b818e4a462d51d4e5bb7836092beb7232643c_1
Original Code:
```
fn create_reqwest_headers(
    headers: &Vec<String>,
) -> Result<reqwest::header::HeaderMap, Box<::std::error::Error>> {
    let mut new_headers = reqwest::header::HeaderMap::new();

    for head in headers {
        let mut split_vect: Vec<&str> = head.split(":").collect();
        let header_name = reqwest::header::HeaderName::from_bytes(split_vect[0].as_bytes())?;
        let header_value = reqwest::header::HeaderValue::from_bytes(split_vect[1].as_bytes())?;

        new_headers.insert(header_name, header_value);
    }
    Ok(new_headers)
}
```


Overlapping Code:
```

headers: &Vec<String>,
) -> Result<reqwest::header::HeaderMap, Box<::std::error::Error>> {
let mut new_headers = reqwest::header::HeaderMap::new();
for head in headers {
let mut split_vect: Vec<&str> = head.split(":").collect();
let header_name = reqwest::header::HeaderName::from_bytes(split_vect[0].as_bytes())?;
let header_value = reqwest::header::HeaderValue::from_bytes(split_vect[1].as_bytes())?;
new_headers.insert(header_name, header_value);
```
<Overlap Ratio: 0.907258064516129>

---

--- 56 --
Question ID: 0e02264fd82fb73065eaf1eae34bda43a1724784_10
Original Code:
```
fn parse_triples<E: From<TurtleError>>(
    parser: &mut TurtleParser<impl BufRead>,
    on_triple: &mut impl FnMut(Triple<'_>) -> Result<(), E>,
) -> Result<(), E> {
    // [6] 	triples 	::= 	subject predicateObjectList | blankNodePropertyList predicateObjectList?
    match parser.read.current() {
        Some(b'[') if !is_followed_by_space_and_closing_bracket(&mut parser.read)? => {
            let id = parse_blank_node_property_list(parser, on_triple)?;
            parser.triple_alloc.try_push_subject(|b| {
                b.push_str(id.as_ref());
                Ok(Subject::from(BlankNode { id: b }))
            })?;
            skip_whitespace(&mut parser.read)?;
            if parser.read.current() != Some(b'.') && parser.read.current() != Some(b'}') {
                parse_predicate_object_list(parser, on_triple)?;
            }
        }
        _ => {
            parse_subject(parser, on_triple)?;
            skip_whitespace(&mut parser.read)?;
            parse_predicate_object_list(parser, on_triple)?;
        }
    }

    parser.triple_alloc.pop_subject();
    Ok(())
}
```


Overlapping Code:
```
rom<TurtleError>>(
parser: &mut TurtleParser<impl BufRead>,
on_triple: &mut impl FnMut(Triple<'_>) -> Result<(), E>,
) -> Result<(), E> {
// [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
match parser.read.current() {
Some(b'[') if !is_followed_by_space_and_closing_bracket(&mut parser.read)? => {
let id = parse_blank_node_property_list(parser, on_triple)?;
parser.triple_alloc.try_push_subject(|b| {
b.push_str(id.as_ref());
Ok(Subject::from(BlankNode { id: b }))
})?;
skip_whitespace(&mut parser.read)?;
if parser.read.current() != Some(b'.') && parser.read.current() != Some(b'}') {
parse_predicate_object_list(parser, on_triple)?;
}
}
_ => {
parse_subject(parser, on_triple)?;
skip_whitespace(&mut parser.read)?;
parse_predicate_object_list(parser, on_triple)?;
}
}
parser.triple_alloc.pop_subject();
Ok(
```
<Overlap Ratio: 0.9703534777651083>

---

--- 57 --
Question ID: 87bace40d95a766d815e6538c887f3bd27ea21f7_2
Original Code:
```
fn session_forward_stdin() {
        let mut session: Session<MockWindow> = Session::new(WINSZ);
        let (first, _) = session.new_window().unwrap();
        let (second, _) = session.new_window().unwrap();

        session.select_window(second);
        assert_eq!(session.selected_window_idx(), Some(second));
        session.receive_stdin(b"Hello").unwrap();

        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;
        assert!(recv.try_next().is_err(), "other window received byte");
        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;
        for byte in b"Hello" {
            assert_eq!(recv.try_next().unwrap(), Some(*byte), "failed to recv byte");
        }
        assert!(recv.try_next().is_err(), "recv too many bytes");

        session.select_window(first);
        session.receive_stdin(b"World").unwrap();

        let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;
        for byte in b"World" {
            assert_eq!(recv.try_next().unwrap(), Some(*byte), "failed to recv byte");
        }
        assert!(recv.try_next().is_err(), "recv too many bytes");
        let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;
        assert!(recv.try_next().is_err(), "other window received byte");
    }
```


Overlapping Code:
```
_stdin() {
let mut session: Session<MockWindow> = Session::new(WINSZ);
let (first, _) = session.new_window().unwrap();
let (second, _) = session.new_window().unwrap();
session.select_window(second);
assert_eq!(session.selected_window_idx(), Some(second));
session.receive_stdin(b"Hello").unwrap();
let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;
assert!(recv.try_next().is_err(), "other window received byte");
let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;
for byte in b"Hello" {
assert_eq!(recv.try_next().unwrap(), Some(*byte), "failed to recv byte");
}
assert!(recv.try_next().is_err(), "recv too many bytes");
session.select_window(first);
session.receive_stdin(b"World").unwrap();
let recv = &mut session.windows.get_mut(&first).unwrap().stdin_channel.1;
for byte in b"World" {
assert_eq!(recv.try_next().unwrap(), Some(*byte), "failed to recv byte");
}
assert!(recv.try_next().is_err(), "recv too many bytes");
let recv = &mut session.windows.get_mut(&second).unwrap().stdin_channel.1;
assert!(recv.try_next().is_err(), "other window recei
```
<Overlap Ratio: 0.9725906277630415>

---

--- 58 --
Question ID: bc62f4da116dbfeb2acadacb60d0b2a1a380ab26_0
Original Code:
```
pub fn lookup(code: &str) -> Option<&'static LanguageInfo> {
    debug!("language::lookup {}", code);
    assert!(
        code.len() == 2 || code.len() == 3,
        "language code must be either 2, or 3, characters long."
    );
    match code.len() {
        3 => match LANGUAGES.get(code) {
            Some(v) => Some(v),
            None => None,
        },
        2 => match LOOKUP.get(code) {
            Some(v) => {
                debug!("language::lookup {} -> {}", code, v);
                lookup(v)
            }
            None => None,
        },
        _ => None,
    }
}
```


Overlapping Code:
```
 LanguageInfo> {
debug!("language::lookup {}", code);
assert!(
code.len() == 2 || code.len() == 3,
"language code must be either 2, or 3, characters long."
);
match code.len() {
3 => match LANGUAGES.get(code) {
Some(v) => Some(v),
None => None,
},
2 => match LOOKUP.get(code) {
Some(v) => {
debug!("language::lookup {} -> {}", code, v);
lookup(v)
}
N
```
<Overlap Ratio: 0.8254716981132075>

---

--- 59 --
Question ID: 536aef5f082d0783eb75594c9d42c7bff10a4397_1
Original Code:
```
pub(crate) fn create_batch(signer: &Signer, transaction: Transaction) -> Batch {
    // Construct BatchHeader
    let mut batch_header = BatchHeader::new();
    // set signer public key
    let public_key = signer
        .get_public_key()
        .expect("Unable to get public key")
        .as_hex();
    let transaction_ids = vec![transaction.clone()]
        .iter()
        .map(|trans| String::from(trans.get_header_signature()))
        .collect();
    batch_header.set_transaction_ids(RepeatedField::from_vec(transaction_ids));
    batch_header.set_signer_public_key(public_key);

    // Construct Batch
    let batch_header_bytes = batch_header
        .write_to_bytes()
        .expect("Error converting batch header to bytes");
    let signature = signer
        .sign(&batch_header_bytes)
        .expect("Error signing the batch header");
    let mut batch = Batch::new();
    batch.set_header_signature(signature);
    batch.set_header(batch_header_bytes);
    batch.set_transactions(RepeatedField::from_vec(vec![transaction]));
    batch
}
```


Overlapping Code:
```
(signer: &Signer, transaction: Transaction) -> Batch {
// Construct BatchHeader
let mut batch_header = BatchHeader::new();
// set signer public key
let public_key = signer
.get_public_key()
.expect("Unable to get public key")
.as_hex();
let transaction_ids = vec![transaction.clone()]
.iter()
.map(|trans| String::from(trans.get_header_signature()))
.collect();
batch_header.set_transaction_ids(RepeatedField::from_vec(transaction_ids));
batch_header.set_signer_public_key(public_key);
// Construct Batch
let batch_header_bytes = batch_header
.write_to_bytes()
.expect("Error converting batch header to bytes");
let signature = signer
.sign(&batch_header_bytes)
.expect("Error signing the batch header");
let mut batch = Batch::new();
batch.set_header_signature(signature);
batch.set_header(batch_header_bytes);
batch.set_transactions(RepeatedField::from_vec(vec!
```
<Overlap Ratio: 0.9452354874041621>

---

--- 60 --
Question ID: c6b861b282fbccbc0bcd5e5afd4592250621131a_1
Original Code:
```
fn share_from_u8_slice_works() {
        let bytes = [1, 2, 3];
        let share = Share::from(&bytes[..]);
        assert_eq!(share.x, GF256(1));
        assert_eq!(share.y, vec![GF256(2), GF256(3)]);
    }
```


Overlapping Code:
```
m_u8_slice_works() {
let bytes = [1, 2, 3];
let share = Share::from(&bytes[..]);
assert_eq!(share.x, GF256(1));
assert_eq!(share.y, vec![GF256(2), GF256(
```
<Overlap Ratio: 0.8895348837209303>

---

--- 61 --
Question ID: 3d46be9cadb53c64b97ee5ea210ca153b317f178_0
Original Code:
```
fn statfs_call() {
        check_statfs("/tmp");
        check_statfs("/dev");
        check_statfs("/run");
        check_statfs("/");
    }
```


Overlapping Code:
```
) {
check_statfs("/tmp");
check_statfs("/dev");
ch
```
<Overlap Ratio: 0.47619047619047616>

---

--- 62 --
Question ID: 317cff68db696221fd9b33fbc79da81ce8cce1ce_1
Original Code:
```
fn with_nothing() {
        let words = vec![];
        let map = abbrev(&words);

        assert!(map.is_empty());
    }
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 63 --
Question ID: 0a9cb98cf636d83c0e9b3f90a37fa1e1bf944679_2
Original Code:
```
fn select_string(items: &[String], default: usize) -> UIResult<usize> {
    // Add an option to return from the selection menu.
    let mut select = Select::new();
    for item in items {
        select.item(&item);
    }

    // Add an option to return without selecting an index
    // TODO: This should be optional, somehow. Could use a separate function?
    select.item("(Return)");

    let index = select.default(default).interact()?;

    if index < items.len() {
        Ok(index)
    } else {
        Err(UIErrorKind::Abort)
    }
}
```


Overlapping Code:
```
&[String], default: usize) -> UIResult<usize> {
// Add an option to return from the selection menu.
let mut select = Select::new();
for item in items {
select.item(&item);
}
// Add an option to return without selecting an index
// TODO: This should be optional, somehow. Could use a separate function?
select.item("(Return)");
let index = select.default(default).interact()?;
if index < items.len() {
```
<Overlap Ratio: 0.8492569002123143>

---

--- 64 --
Question ID: 2976c40b2e4add1ef6c832ab97ae9705d039cb04_5
Original Code:
```
fn test_uniprot_cask_bovin() {
        let entry = UniProtKB {
            database: Database::SwissProt,
            identifier: "P02668".to_string(),
            entry_name: "CASK_BOVIN".to_string(),
            protein_name: "Kappa-casein".to_string(),
            organism_name: "Bos taurus".to_string(),
            organism_identifier: "9913".to_string(),
            gene_name: Some("CSN3".to_string()),
            protein_existence: ProteinExistence::ExperimentalEvidenceProtein,
            sequence_version: "1".to_string(),
        };
        let test_header =
            ">sp|P02668|CASK_BOVIN Kappa-casein OS=Bos taurus OX=9913 GN=CSN3 PE=1 SV=1".as_bytes();
        assert_eq!(uniprotkb(test_header).unwrap(), entry)
    }
```


Overlapping Code:
```
n() {
let entry = UniProtKB {
database: Database::SwissProt,
identifier: "P02668".to_string(),
entry_name: "CASK_BOVIN".to_string(),
protein_name: "Kappa-casein".to_string(),
organism_name: "Bos taurus".to_string(),
organism_identifier: "9913".to_string(),
gene_name: Some("CSN3".to_string()),
protein_existence: ProteinExistence::ExperimentalEvidenceProtein,
sequence_version: "1".to_string(),
};
let test_header =
">sp|P02668|CASK_BOVIN Kappa-casein OS=Bos taurus OX=9913 GN=CSN3 PE=1 SV=1".as_bytes();
assert_eq!(uniprotkb(test_header).unwrap(), e
```
<Overlap Ratio: 0.9450171821305842>

---

--- 65 --
Question ID: 33f7c609ec8dbc44e870594fb88e7f3a553f8966_1
Original Code:
```
fn test_basic_fault_tolerance() {
    // A configuration with 4 validators should tolerate single node failure.
    let (mut env, client_proxy) = setup_swarm_and_client_proxy(4, 1);
    // kill the first validator
    env.validator_swarm.kill_node(0);
    // run the script for the smoke test by submitting requests to the second validator
    test_smoke_script(client_proxy);
}
```


Overlapping Code:
```
st_basic_fault_tolerance() {
// A configuration with 4 validators should tolerate single node failure.
let (mut env, client_proxy) = setup_swarm_and_client_proxy(4, 1);
// kill the first validator
env.validator_swarm.kill_node(0);
// run the script for the smoke test by submitting requests to the second validator
test_smoke_script(client_proxy)
```
<Overlap Ratio: 0.9774011299435028>

---

--- 66 --
Question ID: a6f149c9ca62b1df3e2b3ff99125c7ffcde62cf6_0
Original Code:
```
fn test_categorize_bookings() {
        //given
        let bookings = generate_test_bookings();
        let rules = generate_test_rules();

        //when
        let categorized_bookings = categorize_bookings(bookings, &rules);

        //then
        let categories = categorized_bookings
            .into_iter()
            .map(|booking| booking.category)
            .collect_vec();

        assert!(categories.contains(&"Multiple Matches".to_owned()));
        assert!(categories.contains(&"Andere Ausgaben".to_owned()));
        assert!(categories.contains(&"Warmmiete".to_owned()));
    }
```


Overlapping Code:
```
st_categorize_bookings() {
//given
let bookings = generate_test_bookings();
let rules = generate_test_rules();
//when
let categorized_bookings = categorize_bookings(bookings, &rules);
//then
let categories = categorized_bookings
.into_iter()
.map(|booking| booking.category)
.collect_vec();
assert!(categories.contains(&"Multiple Matches".to_owned()));
assert!(categories.contains(&"Andere Ausgaben".to_owned()));
assert!(categories.contains(&"Warmmi
```
<Overlap Ratio: 0.9473684210526315>

---

--- 67 --
Question ID: 17b229ba0da0e6feb3f30d7b840a29d54de9fde6_0
Original Code:
```
fn main() {
    let points = include_str!("input.txt").lines().map(|line| {
        let nums: Vec<_> = line
            .split(|c| c == '<' || c == ',' || c == '>' || c == '=')
            .filter_map(|n| n.parse::<i32>().ok())
            .collect();
        (Vec3::new(nums[0], nums[1], nums[2]), nums[3])
    });
    let strong_point = points.clone().max_by_key(|p| p.1).unwrap();
    let center = strong_point.0;
    let range = strong_point.1;

    println!(
        "{:?}",
        points
            .filter(|p| Vec3::distance(&p.0, &center) <= range)
            .count()
    );
}
```


Overlapping Code:
```
{
let points = include_str!("input.txt").lines().map(|line| {
let nums: Vec<_> = line
.split(|c| c == '<' || c == ',' || c == '>' || c == '=')
.filter_map(|n| n.parse::<i32>().ok())
.collect();
(Vec3::new(nums[0], nums[1], nums[2]), nums[3])
});
let strong_point = points.clone().max_by_key(|p| p.1).unwrap();
let center = strong_point.0;
let range = strong_point.1;
println!(
"{:?}",
points
.filter(|p| Vec3::distance(&p.0, &center) <= range)
.count
```
<Overlap Ratio: 0.9635974304068522>

---

--- 68 --
Question ID: 4ed46b47ff05c500927cb8a6912a113988143ea4_4
Original Code:
```
fn into_vec_ok() -> Result<()> {
        let x: Vec<Result<()>> = vec![Ok(()), Ok(())];

        let y: Result<Vec<()>> = x.into_iter().bcollect();

        assert!(y.is_ok());

        Ok(())
    }
```


Overlapping Code:
```
ec_ok() -> Result<()> {
let x: Vec<Result<()>> = vec![Ok(()), Ok(())];
let y: Result<Vec<()>> = x.into_iter().bcollect();
assert!(y.is_ok());
Ok(())
}
```
<Overlap Ratio: 0.9433962264150944>

---

--- 69 --
Question ID: 1991061eef27150f53894ae41cc1429fa310d664_0
Original Code:
```
pub async fn run(port: u16, memtable: Arc<RwLock<Memtable>>) {
    let addr = SocketAddr::from(([127, 0, 0, 1], port));

    println!("Listening on {}", addr);

    let serve_future =
        Server::bind(&addr).serve(make_service_fn(move |_| {
            let cloned_memtable = memtable.clone();
            async move {
                Ok::<_, hyper::Error>(service_fn(move |req| router(cloned_memtable.clone(), req)))
            }
        }));

    // Wait for the server to complete serving or exit with an error.
    // If an error occurred, print it to stderr.
    if let Err(e) = serve_future.await {
        eprintln!("server error: {}", e);
    }
}
```


Overlapping Code:
```
run(port: u16, memtable: Arc<RwLock<Memtable>>) {
let addr = SocketAddr::from(([127, 0, 0, 1], port));
println!("Listening on {}", addr);
let serve_future =
Server::bind(&addr).serve(make_service_fn(move |_| {
let cloned_memtable = memtable.clone();
async move {
Ok::<_, hyper::Error>(service_fn(move |req| router(cloned_memtable.clone(), req)))
}
}));
// Wait for the server to complete serving or exit with an error.
// If an error occurred, print it to stderr.
if let Err(e) = serve_future.await {
eprintln!("server error: {}
```
<Overlap Ratio: 0.9582577132486388>

---

--- 70 --
Question ID: 4cb44c3e9bbaf7828d4d6aed2083f377e083a8ff_33
Original Code:
```
fn error_reference_loop_implementation_function_between_modules_indirect() {
    let third = r#"
use crate::Call;

struct Third { value: u8 }

impl Third {
    pub fn call() -> u8 { Call::call() }
}
"#;

    let second = r#"
mod third;

struct Second { value: u8 }

impl Second {
    pub fn call() -> u8 { third::Third::call() }
}
"#;

    let first = r#"
mod second;

struct First { value: u8 }

impl First {
    pub fn call() -> u8 { second::Second::call() }
}
"#;

    let entry = r#"
mod first;

struct Call { value: u8 }

impl Call {
    pub fn call() -> u8 { self::first::First::Call() }
}

fn main() -> u8 { Call { value: 42 }.call() }
"#;

    let expected = Err(Error::Semantic(SemanticError::Scope(
        ScopeError::ReferenceLoop {
            location: Location::test(7, 5),
        },
    )));
    let result = crate::semantic::tests::compile_entry_with_dependencies(
        entry,
        vec![(
            "first".to_owned(),
            Source::test(
                first,
                PathBuf::from("first.zn"),
                vec![(
                    "second".to_owned(),
                    Source::test(
                        second,
                        PathBuf::from("first/second.zn"),
                        vec![(
                            "third".to_owned(),
                            Source::test(
                                third,
                                PathBuf::from("first/second/third.zn"),
                                HashMap::new(),
                            )
                            .expect(zinc_const::panic::TEST_DATA_VALID),
                        )]
                        .into_iter()
                        .collect::<HashMap<String, Source>>(),
                    )
                    .expect(zinc_const::panic::TEST_DATA_VALID),
                )]
                .into_iter()
                .collect::<HashMap<String, Source>>(),
            )
            .expect(zinc_const::panic::TEST_DATA_VALID),
        )]
        .into_iter()
        .collect::<HashMap<String, Source>>(),
    );

    assert_eq!(result, expected);
}
```


Overlapping Code:
```
lementation_function_between_modules_indirect() {
let third = r#"
use crate::Call;
struct Third { value: u8 }
impl Third {
pub fn call() -> u8 { Call::call() }
}
"#;
let second = r#"
mod third;
struct Second { value: u8 }
impl Second {
pub fn call() -> u8 { third::Third::call() }
}
"#;
let first = r#"
mod second;
struct First { value: u8 }
impl First {
pub fn call() -> u8 { second::Second::call() }
}
"#;
let entry = r#"
mod first;
struct Call { value: u8 }
impl Call {
pub fn call() -> u8 { self::first::First::Call() }
}
fn main() -> u8 { Call { value: 42 }.call() }
"#;
let expected = Err(Error::Semantic(SemanticError::Scope(
ScopeError::ReferenceLoop {
location: Location::test(7, 5),
},
)));
let result = crate::semantic::tests::compile_entry_with_dependencies(
entry,
vec![(
"first".to_owned(),
Source::test(
first,
PathBuf::from("first.zn"),
vec![(
"second".to_owned(),
Source::test(
second,
PathBuf::from("first/second.zn"),
vec![(
"third".to_owned(),
Source::test(
third,
PathBuf::from("first/second/third.zn"),
HashMap::new(),
)
.expect(zinc_const::panic::TEST_DATA_VALID),
)]
.into_iter()
.collect::<HashMap<String, Source>>(),
)
.expect(zinc_const::panic::TEST_DATA_VALID),
)]
.into_iter()
.collect::<HashMap<String, Source>>(),
)
.expect(zinc_const::panic::TEST_DATA_VALID),
)]
.into_iter()
.collect::<HashMap<String, Source>>(),
);
assert_eq!(result, expected);

```
<Overlap Ratio: 0.9801136363636364>

---

--- 71 --
Question ID: fc5e6e319a1544d07c2486f8536d6696f920fe8c_4
Original Code:
```
async fn test_notify_on_change() {
        let data1 = LightData { illuminance: 10.0 };
        let data2 = LightData { illuminance: 15.0 };

        let (light_sender, light_receiver) = unbounded::<LightData>();

        let (notifier_sender, mut notifier_receiver) = unbounded::<SettingType>();

        let data: Arc<RwLock<LightData>> = Arc::new(RwLock::new(data1));

        let aborter =
            notify_on_change(light_receiver, Arc::new(RwLock::new(Some(notifier_sender))), data)
                .await;

        light_sender.unbounded_send(data2).unwrap();

        assert_eq!(notifier_receiver.next().await.unwrap(), SettingType::LightSensor);

        let next = notifier_receiver.try_next();
        if let Ok(_) = next {
            panic!("Only one change should have happened")
        };

        aborter.abort();

        let sleep_duration = zx::Duration::from_millis(5);
        fasync::Timer::new(sleep_duration.after_now()).await;
        assert_eq!(light_sender.is_closed(), true);
    }
```


Overlapping Code:
```
hange() {
let data1 = LightData { illuminance: 10.0 };
let data2 = LightData { illuminance: 15.0 };
let (light_sender, light_receiver) = unbounded::<LightData>();
let (notifier_sender, mut notifier_receiver) = unbounded::<SettingType>();
let data: Arc<RwLock<LightData>> = Arc::new(RwLock::new(data1));
let aborter =
notify_on_change(light_receiver, Arc::new(RwLock::new(Some(notifier_sender))), data)
.await;
light_sender.unbounded_send(data2).unwrap();
assert_eq!(notifier_receiver.next().await.unwrap(), SettingType::LightSensor);
let next = notifier_receiver.try_next();
if let Ok(_) = next {
panic!("Only one change should have happened")
};
aborter.abort();
let sleep_duration = zx::Duration::from_millis(5);
fasync::Timer::new(sleep_duration.after_now()).await;
assert_eq!(light_sender.is_clos
```
<Overlap Ratio: 0.9535160905840286>

---

--- 72 --
Question ID: 2c25046f8a938d688e5173e9f517bd93b2b9eeb2_6
Original Code:
```
pub extern "C" fn muentry_alloc_large(
    mutator: *mut Mutator,
    size: usize,
    align: usize,
) -> ObjectReference {
    let m = mutator_ref(mutator);
    let res = m.lo.alloc(size, align);
    unsafe { res.to_object_reference() }
}
```


Overlapping Code:
```
xtern "C" fn muentry_alloc_large(
mutator: *mut Mutator,
size: usize,
align: usize,
) -> ObjectReference {
let m = mutator_ref(mutator);
let res = m.lo.alloc(size, align);
unsafe { res.to_object_refer
```
<Overlap Ratio: 0.9302325581395349>

---

--- 73 --
Question ID: 7209a9a1cf034fbaa1a7e1c8822820cc115c3197_48
Original Code:
```
pub async fn list_metrics_average(
        operation_config: &crate::OperationConfig,
        service_name: &str,
        metric_name: &str,
        group_name: &str,
    ) -> std::result::Result<models::Metrics, list_metrics_average::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/providers/Microsoft.ADHybridHealthService/services/{}/metrics/{}/groups/{}/average",
            operation_config.base_path(),
            service_name,
            metric_name,
            group_name
        );
        let mut url = url::Url::parse(url_str).map_err(list_metrics_average::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(list_metrics_average::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(list_metrics_average::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(list_metrics_average::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::Metrics = serde_json::from_slice(rsp_body)
                    .map_err(|source| list_metrics_average::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                Err(list_metrics_average::Error::UnexpectedResponse {
                    status_code,
                    body: rsp_body.clone(),
                })
            }
        }
    }
```


Overlapping Code:
```
_metrics_average(
operation_config: &crate::OperationConfig,
service_name: &str,
metric_name: &str,
group_name: &str,
) -> std::result::Result<models::Metrics, list_metrics_average::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/providers/Microsoft.ADHybridHealthService/services/{}/metrics/{}/groups/{}/average",
operation_config.base_path(),
service_name,
metric_name,
group_name
);
let mut url = url::Url::parse(url_str).map_err(list_metrics_average::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::GET);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(list_metrics_average::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(list_metrics_average::Error::BuildRequestError)?;
let rsp = http_client
.execute_request(req)
.await
.map_err(list_metrics_average::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::Metrics = serde_json::from_slice(rsp_body)
.map_err(|source| list_metrics_average::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
Err(list_metrics_average::Error::UnexpectedResponse {
status_code,
body: rsp_body.clone(),
})
}
}
}
```
<Overlap Ratio: 0.9903737259343148>

---

--- 74 --
Question ID: 077543156117a60cab3077fec32714ae6f939d88_5
Original Code:
```
async fn rename_dir_should_return_success_if_renamed_directory() {
        let root = tempfile::tempdir().unwrap();
        let mut fsm = FileSystemManager::new();

        let origin = root.as_ref().join("origin");
        fs::create_dir(origin.as_path()).await.unwrap();

        let destination = root.as_ref().join("destination");

        match fsm.rename_dir(origin, destination).await {
            Ok(_) => (),
            x => panic!("Unexpected result: {:?}", x),
        }
    }
```


Overlapping Code:
```
n rename_dir_should_return_success_if_renamed_directory() {
let root = tempfile::tempdir().unwrap();
let mut fsm = FileSystemManager::new();
let origin = root.as_ref().join("origin");
fs::create_dir(origin.as_path()).await.unwrap();
let destination = root.as_ref().join("destination");
match fsm.rename_dir(origin, destination).await {
Ok(_) => (),
x => panic!("Unexpected result: {:?}", x),
}
}
```
<Overlap Ratio: 0.9825870646766169>

---

--- 75 --
Question ID: a589569c4a9fd60dec9a6441ab9ec8a9d358d990_3
Original Code:
```
fn output_files(gcds: &Vec<Integer>, vulns: &Vec<String>, infile: &String) -> std::io::Result<()> {
    println!("Writing to files...");
    let gcdfilename = infile.clone() + ".gcd";
    let vulfilename = infile.clone() + ".vuln";
    println!("GCD Filename: {}\nVulnerable Moduli Filename: {}", gcdfilename, vulfilename);
    
    let gcdfile = File::create(gcdfilename)?;
    let mut gcdfile = LineWriter::new(gcdfile);
    let vulfile = File::create(vulfilename)?;
    let mut vulfile = LineWriter::new(vulfile);
    
    for (gcd, vuln) in gcds.iter().zip(vulns.iter()) {
        gcdfile.write_all((gcd.to_string_radix(16) + "\n").as_bytes())?;
        vulfile.write_all((vuln.clone() + "\n").as_bytes())?;
    }

    gcdfile.flush()?;
    vulfile.flush()?;
    println!("All done! Phew!");
    Ok(())
}
```


Overlapping Code:
```
lns: &Vec<String>, infile: &String) -> std::io::Result<()> {
println!("Writing to files...");
let gcdfilename = infile.clone() + ".gcd";
let vulfilename = infile.clone() + ".vuln";
println!("GCD Filename: {}\nVulnerable Moduli Filename: {}", gcdfilename, vulfilename);

let gcdfile = File::create(gcdfilename)?;
let mut gcdfile = LineWriter::new(gcdfile);
let vulfile = File::create(vulfilename)?;
let mut vulfile = LineWriter::new(vulfile);

for (gcd, vuln) in gcds.iter().zip(vulns.iter()) {
gcdfile.write_all((gcd.to_string_radix(16) + "\n").as_bytes())?;
vulfile.write_all((vuln.clone() + "\n").as_bytes())?;
}
gcdfile.flush()?;
vulfile.flush()?;
```
<Overlap Ratio: 0.8940852819807428>

---

--- 76 --
Question ID: 195874657dd67acbd631d23ffc9598c6fe2849d8_18
Original Code:
```
fn main() -> Result<(), scalgoproto::Error> {
    let mut args = std::env::args();
    args.next();
    let test = args.next().expect("Missing test");
    let file = args.next().expect("Missig file");

    match test.as_str() {
        "out_default" => test_out_default(&file)?,
        "in_default" => test_in_default(&file)?,
        "out" => test_out(&file)?,
        "in" => test_in(&file)?,
        "out_complex" => test_out_complex(&file)?,
        "in_complex" => test_in_complex(&file)?,
        "in_complex3" => test_in_complex3(&file)?,
        "out_complex2" => test_out_complex2(&file)?,
        "in_complex2" => test_in_complex2(&file)?,
        "out_inplace" => test_out_inplace(&file)?,
        "in_inplace" => test_in_inplace(&file)?,
        "out_extend1" => test_out_extend1(&file)?,
        "in_extend1" => test_in_extend1(&file)?,
        "out_extend2" => test_out_extend2(&file)?,
        "in_extend2" => test_in_extend2(&file)?,
        "out_union" => test_out_union(&file)?,
        "in_union" => test_in_union(&file)?,
        _ => {
            panic!("Unknown test");
        }
    }

    Ok(())
}
```


Overlapping Code:
```
:Error> {
let mut args = std::env::args();
args.next();
let test = args.next().expect("Missing test");
let file = args.next().expect("Missig file");
match test.as_str() {
"out_default" => test_out_default(&file)?,
"in_default" => test_in_default(&file)?,
"out" => test_out(&file)?,
"in" => test_in(&file)?,
"out_complex" => test_out_complex(&file)?,
"in_complex" => test_in_complex(&file)?,
"in_complex3" => test_in_complex3(&file)?,
"out_complex2" => test_out_complex2(&file)?,
"in_complex2" => test_in_complex2(&file)?,
"out_inplace" => test_out_inplace(&file)?,
"in_inplace" => test_in_inplace(&file)?,
"out_extend1" => test_out_extend1(&file)?,
"in_extend1" => test_in_extend1(&file)?,
"out_extend2" => test_out_extend2(&file)?,
"in_extend2" => test_in_extend2(&file)?,
"out_union" => test_out_union(&file)?,
"in_union" => test_in_union(&file)?,

```
<Overlap Ratio: 0.9149623250807319>

---

--- 77 --
Question ID: a73c4f4e5cf0b4ee29ba1d79c7c8c09f883b78cf_10
Original Code:
```
fn impl_deserial(ast: &syn::DeriveInput) -> syn::Result<TokenStream> {
    let data_name = &ast.ident;

    let span = ast.span();

    let read_ident = format_ident!("__R", span = span);

    let (impl_generics, ty_generics, where_clauses) = ast.generics.split_for_impl();

    let source_ident = Ident::new("________________source", Span::call_site());

    let body_tokens = match ast.data {
        syn::Data::Struct(ref data) => {
            let mut names = proc_macro2::TokenStream::new();
            let mut field_tokens = proc_macro2::TokenStream::new();
            let return_tokens = match data.fields {
                syn::Fields::Named(_) => {
                    for field in data.fields.iter() {
                        let field_ident = field.ident.clone().unwrap(); // safe since named fields.
                        field_tokens.extend(impl_deserial_field(
                            field,
                            &field_ident,
                            &source_ident,
                        ));
                        names.extend(quote!(#field_ident,))
                    }
                    quote!(Ok(#data_name{#names}))
                }
                syn::Fields::Unnamed(_) => {
                    for (i, f) in data.fields.iter().enumerate() {
                        let field_ident = format_ident!("x_{}", i);
                        field_tokens.extend(impl_deserial_field(f, &field_ident, &source_ident));
                        names.extend(quote!(#field_ident,))
                    }
                    quote!(Ok(#data_name(#names)))
                }
                _ => quote!(Ok(#data_name{})),
            };
            quote! {
                #field_tokens
                #return_tokens
            }
        }
        syn::Data::Enum(ref data) => {
            let mut matches_tokens = proc_macro2::TokenStream::new();
            let source = Ident::new("________________source", Span::call_site());
            let size = if data.variants.len() <= 256 {
                format_ident!("u8")
            } else if data.variants.len() <= 256 * 256 {
                format_ident!("u16")
            } else {
                return Err(syn::Error::new(
                    ast.span(),
                    "[derive(Deserial)]: Too many variants. Maximum 65536 are supported.",
                ));
            };
            for (i, variant) in data.variants.iter().enumerate() {
                let (field_names, pattern) = match variant.fields {
                    syn::Fields::Named(_) => {
                        let field_names: Vec<_> = variant
                            .fields
                            .iter()
                            .map(|field| field.ident.clone().unwrap())
                            .collect();
                        (field_names.clone(), quote! { {#(#field_names),*} })
                    }
                    syn::Fields::Unnamed(_) => {
                        let field_names: Vec<_> = variant
                            .fields
                            .iter()
                            .enumerate()
                            .map(|(i, _)| format_ident!("x_{}", i))
                            .collect();
                        (field_names.clone(), quote! { ( #(#field_names),* ) })
                    }
                    syn::Fields::Unit => (Vec::new(), proc_macro2::TokenStream::new()),
                };

                let field_tokens: proc_macro2::TokenStream = field_names
                    .iter()
                    .zip(variant.fields.iter())
                    .map(|(name, field)| impl_deserial_field(field, name, &source))
                    .collect::<syn::Result<proc_macro2::TokenStream>>()?;
                let idx_lit = syn::LitInt::new(i.to_string().as_str(), Span::call_site());
                let variant_ident = &variant.ident;
                matches_tokens.extend(quote! {
                    #idx_lit => {
                        #field_tokens
                        Ok(#data_name::#variant_ident#pattern)
                    },
                })
            }
            quote! {
                let idx = #size::deserial(#source)?;
                match idx {
                    #matches_tokens
                    _ => Err(Default::default())
                }
            }
        }
        _ => unimplemented!("#[derive(Deserial)] is not implemented for union."),
    };
    let gen = quote! {
        #[automatically_derived]
        impl #impl_generics Deserial for #data_name #ty_generics #where_clauses {
            fn deserial<#read_ident: Read>(#source_ident: &mut #read_ident) -> ParseResult<Self> {
                #body_tokens
            }
        }
    };
    Ok(gen.into())
}
```


Overlapping Code:
```
pl_deserial(ast: &syn::DeriveInput) -> syn::Result<TokenStream> {
let data_name = &ast.ident;
let span = ast.span();
let read_ident = format_ident!("__R", span = span);
let (impl_generics, ty_generics, where_clauses) = ast.generics.split_for_impl();
let source_ident = Ident::new("________________source", Span::call_site());
let body_tokens = match ast.data {
syn::Data::Struct(ref data) => {
let mut names = proc_macro2::TokenStream::new();
let mut field_tokens = proc_macro2::TokenStream::new();
let return_tokens = match data.fields {
syn::Fields::Named(_) => {
for field in data.fields.iter() {
let field_ident = field.ident.clone().unwrap(); // safe since named fields.
field_tokens.extend(impl_deserial_field(
field,
&field_ident,
&source_ident,
));
names.extend(quote!(#field_ident,))
}
quote!(Ok(#data_name{#names}))
}
syn::Fields::Unnamed(_) => {
for (i, f) in data.fields.iter().enumerate() {
let field_ident = format_ident!("x_{}", i);
field_tokens.extend(impl_deserial_field(f, &field_ident, &source_ident));
names.extend(quote!(#field_ident,))
}
quote!(Ok(#data_name(#names)))
}
_ => quote!(Ok(#data_name{})),
};
quote! {
#field_tokens
#return_tokens
}
}
syn::Data::Enum(ref data) => {
let mut matches_tokens = proc_macro2::TokenStream::new();
let source = Ident::new("________________source", Span::call_site());
let size = if data.variants.len() <= 256 {
format_ident!("u8")
} else if data.variants.len() <= 256 * 256 {
format_ident!("u16")
} else {
return Err(syn::Error::new(
ast.span(),
"[derive(Deserial)]: Too many variants. Maximum 65536 are supported.",
));
};
for (i, variant) in data.variants.iter().enumerate() {
let (field_names, pattern) = matc
```
<Overlap Ratio: 0.9916963226571768>

---

--- 78 --
Question ID: ea8735d3ac575c1d83d4fdc7748ffa7833302ff3_4
Original Code:
```
fn gen_retry_list(res: &RawTestResults) -> String {
    use std::fmt::Write;

    let mut out = String::new();

    let regressed_crates = res
        .crates
        .iter()
        .filter(|crate_res| crate_res.res == Comparison::Regressed)
        .map(|crate_res| &crate_res.krate);

    for krate in regressed_crates {
        match krate {
            Crate::Registry(details) => writeln!(out, "{}", details.name).unwrap(),
            Crate::GitHub(repo) => writeln!(out, "{}/{}", repo.org, repo.name).unwrap(),
            Crate::Local(_) | Crate::Git(_) | Crate::Path(_) => {}
        }
    }

    out
}
```


Overlapping Code:
```
 &RawTestResults) -> String {
use std::fmt::Write;
let mut out = String::new();
let regressed_crates = res
.crates
.iter()
.filter(|crate_res| crate_res.res == Comparison::Regressed)
.map(|crate_res| &crate_res.krate);
for krate in regressed_crates {
match krate {
Crate::Registry(details) => writeln!(out, "{}", details.name).unwrap(),
Crate::GitHub(repo) => writeln!(out, "{}/{}", repo.org, repo.name).unwrap(),
Crate::Local(_) | Crate::Git(_) | Cr
```
<Overlap Ratio: 0.9>

---

--- 79 --
Question ID: ed4f3e56fc96f1e3be0d9609cf06066243b68581_1
Original Code:
```
fn render_readme_package_list(database: &Database) -> Result<String> {
    let mut body = String::new();

    let mut packages: Vec<database::Package> = database.query_package(None)?;
    packages
        .sort_by(|a, b| (&a.group, &a.name, &b.version).cmp(&((&b.group, &b.name, &a.version))));
    packages.dedup_by(|a, b| (&a.group, &a.name).eq(&(&b.group, &b.name)));
    // packages.sort_by(|a, b| b.version.cmp(&a.version));

    for package in packages {
        let user_name = database.query_user(package.user_id)?.unwrap().name;
        let package_link = if let Some(url) = package.homepage.or(package.repository) {
            format!(
                "[`{}/{} {}`]({})",
                package.group, package.name, package.version, url
            )
        } else {
            format!("`{}/{} {}`", package.group, package.name, package.version)
        };
        let package_description = if let Some(description) = package.description {
            format!(" *{}* ", description)
        } else {
            format!(" ")
        };
        writeln!(
            &mut body,
            "- {}{}[@{}]({})",
            package_link,
            package_description,
            &user_name,
            github::url::user_profile(&user_name)
        )
        .unwrap();
    }

    Ok(body)
}
```


Overlapping Code:
```
e_package_list(database: &Database) -> Result<String> {
let mut body = String::new();
let mut packages: Vec<database::Package> = database.query_package(None)?;
packages
.sort_by(|a, b| (&a.group, &a.name, &b.version).cmp(&((&b.group, &b.name, &a.version))));
packages.dedup_by(|a, b| (&a.group, &a.name).eq(&(&b.group, &b.name)));
// packages.sort_by(|a, b| b.version.cmp(&a.version));
for package in packages {
let user_name = database.query_user(package.user_id)?.unwrap().name;
let package_link = if let Some(url) = package.homepage.or(package.repository) {
format!(
"[`{}/{} {}`]({})",
package.group, package.name, package.version, url
)
} else {
format!("`{}/{} {}`", package.group, package.name, package.version)
};
let package_description = if let Some(description) = package.description {
format!(" *{}* ", description)
} else {
format!(" ")
};
writeln!(
&mut body,
"- {}{}[@{}]({})",
package_link,
package_description,
&user_name,
github::url::user_profile(&user_name)
)
.unwrap();
}
Ok(body
```
<Overlap Ratio: 0.9823182711198428>

---

--- 80 --
Question ID: 9918ffddd344af87248d73ef2499aa742c3d2484_13
Original Code:
```
fn nonintersecting_quorums_in_broken() {
        let fbas = Fbas::from_json_file(Path::new("test_data/broken.json"));

        let expected = Some(vec![bitset![3, 10], bitset![4, 6]]);
        let actual = find_nonintersecting_quorums(&fbas);

        assert_eq!(expected, actual);
    }
```


Overlapping Code:
```
ing_quorums_in_broken() {
let fbas = Fbas::from_json_file(Path::new("test_data/broken.json"));
let expected = Some(vec![bitset![3, 10], bitset![4, 6]]);
let actual = find_nonintersecting_quorums(&fbas);
assert_eq!(expected, actual);

```
<Overlap Ratio: 0.9357429718875502>

---

--- 81 --
Question ID: d86e9a5334b449ce47e35f00c7245dcd8a241d55_10
Original Code:
```
pub extern fn vcx_credential_release(handle: u32) -> u32 {
    info!("vcx_credential_release >>>");

    let source_id = credential::get_source_id(handle).unwrap_or_default();
    match credential::release(handle) {
        Ok(_) => trace!("vcx_credential_release(handle: {}, rc: {}), source_id: {:?}",
                       handle, error_string(0), source_id),
        Err(e) => error!("vcx_credential_release(handle: {}, rc: {}), source_id: {:?}",
                         handle, error_string(e.to_error_code()), source_id),
    };
    error::SUCCESS.code_num
}
```


Overlapping Code:
```
fn vcx_credential_release(handle: u32) -> u32 {
info!("vcx_credential_release >>>");
let source_id = credential::get_source_id(handle).unwrap_or_default();
match credential::release(handle) {
Ok(_) => trace!("vcx_credential_release(handle: {}, rc: {}), source_id: {:?}",
handle, error_string(0), source_id),
Err(e) => error!("vcx_credential_release(handle: {}, rc: {}), source_id: {:?}",
handle, error_string(e.to_error_code()), source_id),
};
error::SUCCESS.code_num

```
<Overlap Ratio: 0.975>

---

--- 82 --
Question ID: a0fb9c965c575c4711bf9568c3013f75f3d14af8_1
Original Code:
```
fn generate_macos_bindings() {
    let bindings = bindgen::Builder::default()
        .header("./src/macos/bindings.h")
        .whitelist_function("_dyld_.*")
        .whitelist_type("mach_header.*")
        .whitelist_type("load_command.*")
        .whitelist_type("segment_command.*")
        .whitelist_var("MH_MAGIC.*")
        .whitelist_var("LC_SEGMENT.*")
        .generate()
        .expect("Should generate macOS FFI bindings OK");

    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    bindings
        .write_to_file(out_path.join("macos_bindings.rs"))
        .expect("Should write macos_bindings.rs OK");
}
```


Overlapping Code:
```
bindings() {
let bindings = bindgen::Builder::default()
.header("./src/macos/bindings.h")
.whitelist_function("_dyld_.*")
.whitelist_type("mach_header.*")
.whitelist_type("load_command.*")
.whitelist_type("segment_command.*")
.whitelist_var("MH_MAGIC.*")
.whitelist_var("LC_SEGMENT.*")
.generate()
.expect("Should generate macOS FFI bindings OK");
let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
bindings
.write_to_file(out_path.join("macos_bindings.rs"))
.expect("Should write macos_bindings.rs OK");
```
<Overlap Ratio: 0.9624765478424016>

---

--- 83 --
Question ID: 34946611d14328ca306a0c075bb69003942cb86f_0
Original Code:
```
fn load_json() {
        let json = r#"
        {
            "description": "Expected description",
            "metadata": [
                {
                    "label": "size",
                    "value": "53 MB"
                },
                {
                    "label": "colors",
                    "value": ["red", "green", "blue"]
                },
                {
                    "label": "quality",
                    "value": [{"@value": "high", "@language": "en"}]
                }
            ]
        }"#;
        let actual: Meta = serde_json::from_str(json).unwrap();
        assert_eq!(actual.description, Some("Expected description".to_owned()));
        assert_eq!(actual.metadata[0], Metadata::key_value("size", "53 MB"));
        assert_eq!(
            actual.metadata[1],
            Metadata::list(
                "colors",
                vec!["red".to_owned(), "green".to_owned(), "blue".to_owned()]
            )
        );
        assert_eq!(
            actual.metadata[2],
            Metadata::localized("quality", vec![LocalizedValue::new("high", "en")])
        );
    }
```


Overlapping Code:
```
description": "Expected description",
"metadata": [
{
"label": "size",
"value": "53 MB"
},
{
"label": "colors",
"value": ["red", "green", "blue"]
},
{
"label": "quality",
"value": [{"@value": "high", "@language": "en"}]
}
]
}"#;
let actual: Meta = serde_json::from_str(json).unwrap();
assert_eq!(actual.description, Some("Expected description".to_owned()));
assert_eq!(actual.metadata[0], Metadata::key_value("size", "53 MB"));
assert_eq!(
actual.metadata[1],
Metadata::list(
"colors",
vec!["red".to_owned(), "green".to_owned(), "blue".to_owned()]
)
);
assert_eq!(
actual.metadata[2],
Metadata::localized("quality", vec![LocalizedValue::new("high", "
```
<Overlap Ratio: 0.9339080459770115>

---

--- 84 --
Question ID: 3aa039a0205741105e001eb14b832d797b1f7f82_6
Original Code:
```
fn get_param_key_value(dir: &str, file: &str) -> Result<HashMap<String, String>> {
    let mut m = HashMap::new();
    let p = format!("{}/{}", dir, file);

    for l in fs::read_to_string(p.as_str())?.lines() {
        let t: Vec<&str> = l.split(' ').collect();
        if t.len() != 2 {
            continue;
        }

        m.insert(t[0].to_string(), t[1].to_string());
    }

    Ok(m)
}
```


Overlapping Code:
```
, file: &str) -> Result<HashMap<String, String>> {
let mut m = HashMap::new();
let p = format!("{}/{}", dir, file);
for l in fs::read_to_string(p.as_str())?.lines() {
let t: Vec<&str> = l.split(' ').collect();
if t.len() != 2 {
continue;
}
m.insert(t
```
<Overlap Ratio: 0.764525993883792>

---

--- 85 --
Question ID: 01c450b324884e2d4835f52af116502be77ad513_0
Original Code:
```
pub fn apply_filter(bpf_filter: BpfProgramRef) -> std::result::Result<(), InstallationError> {
    // If the program is empty, don't install the filter.
    if bpf_filter.is_empty() {
        return Ok(());
    }

    // If the program length is greater than the limit allowed by the kernel,
    // fail quickly. Otherwise, `prctl` will give a more cryptic error code.
    if bpf_filter.len() > BPF_MAX_LEN {
        return Err(InstallationError::FilterTooLarge);
    }

    unsafe {
        {
            let rc = libc::prctl(libc::PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
            if rc != 0 {
                return Err(InstallationError::Prctl(*libc::__errno_location()));
            }
        }

        let bpf_prog = sock_fprog {
            len: bpf_filter.len() as u16,
            filter: bpf_filter.as_ptr(),
        };
        let bpf_prog_ptr = &bpf_prog as *const sock_fprog;
        {
            let rc = libc::prctl(
                libc::PR_SET_SECCOMP,
                libc::SECCOMP_MODE_FILTER,
                bpf_prog_ptr,
            );
            if rc != 0 {
                return Err(InstallationError::Prctl(*libc::__errno_location()));
            }
        }
    }

    Ok(())
}
```


Overlapping Code:
```
ter(bpf_filter: BpfProgramRef) -> std::result::Result<(), InstallationError> {
// If the program is empty, don't install the filter.
if bpf_filter.is_empty() {
return Ok(());
}
// If the program length is greater than the limit allowed by the kernel,
// fail quickly. Otherwise, `prctl` will give a more cryptic error code.
if bpf_filter.len() > BPF_MAX_LEN {
return Err(InstallationError::FilterTooLarge);
}
unsafe {
{
let rc = libc::prctl(libc::PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
if rc != 0 {
return Err(InstallationError::Prctl(*libc::__errno_location()));
}
}
let bpf_prog = sock_fprog {
len: bpf_filter.len() as u16,
filter: bpf_filter.as_ptr(),
};
let bpf_prog_ptr = &bpf_prog as *const sock_fprog;
{
let rc = libc::prctl(
libc::PR_SET_SECCOMP,
libc::SECCOMP_MODE_FILTER,
bpf_prog_ptr,
);
if rc != 0 {
return Err(InstallationError::Prctl(*libc::__errno_locat
```
<Overlap Ratio: 0.9567627494456763>

---

--- 86 --
Question ID: debf3aaf9becab8529d7c1c1e2273dbb753ec3a5_21
Original Code:
```
fn transactions_can_be_used_across_sub_databases<'a, S, X, E>(
    env: &'a X,
    store_a: &S,
    store_b: &S,
) -> Result<(), E>
where
    S: TrieStore<Vec<u8>, Vec<u8>>,
    X: TransactionSource<'a, Handle = S::Handle>,
    S::Error: From<X::Error>,
    E: From<S::Error> + From<X::Error> + From<types::bytesrepr::Error>,
{
    let data = super::create_data();
    let TestData(ref leaf_1_hash, ref leaf_1) = data[0];
    let TestData(ref leaf_2_hash, ref leaf_2) = data[1];

    {
        let mut write_txn = env.create_read_write_txn()?;
        store_a.put(&mut write_txn, leaf_1_hash, leaf_1)?;
        store_b.put(&mut write_txn, leaf_2_hash, leaf_2)?;
        write_txn.commit()?;
    }

    {
        let read_txn = env.create_read_txn()?;
        let result = store_a.get(&read_txn, leaf_1_hash)?;
        assert_eq!(result, Some(leaf_1.to_owned()));
        let result = store_b.get(&read_txn, leaf_2_hash)?;
        assert_eq!(result, Some(leaf_2.to_owned()));
        read_txn.commit()?;
    }

    Ok(())
}
```


Overlapping Code:
```
_across_sub_databases<'a, S, X, E>(
env: &'a X,
store_a: &S,
store_b: &S,
) -> Result<(), E>
where
S: TrieStore<Vec<u8>, Vec<u8>>,
X: TransactionSource<'a, Handle = S::Handle>,
S::Error: From<X::Error>,
E: From<S::Error> + From<X::Error> + From<types::bytesrepr::Error>,
{
let data = super::create_data();
let TestData(ref leaf_1_hash, ref leaf_1) = data[0];
let TestData(ref leaf_2_hash, ref leaf_2) = data[1];
{
let mut write_txn = env.create_read_write_txn()?;
store_a.put(&mut write_txn, leaf_1_hash, leaf_1)?;
store_b.put(&mut write_txn, leaf_2_hash, leaf_2)?;
write_txn.commit()?;
}
{
let read_txn = env.create_read_txn()?;
let result = store_a.get(&read_txn, leaf_1_hash)?;
assert_eq!(result, Some(leaf_1.to_owned()));
let result = store_b.get(&read_txn, leaf_2_hash)?;
assert_eq!(result, Some(leaf_2.to_owned()));
read_txn.commit()?;
}
Ok(())
```
<Overlap Ratio: 0.9670079635949943>

---

--- 87 --
Question ID: c2d8bc782facadf12bbcce78f65f207c27226f82_11
Original Code:
```
fn test_diff_none() {
  let (one, two) = ("test_diff_none_1", "test_diff_none_2");
  let mut con = std::net::TcpStream::connect(get_redis_url()).expect("connection");
  execute(&mut con, SetCommand::Add(one, Arity::One("one"))).expect("executed");
  execute(&mut con, SetCommand::Add(two, Arity::One("two"))).expect("executed");
  execute(&mut con, SetCommand::Add(two, Arity::One("one"))).expect("executed");
  let result = execute(&mut con, SetCommand::Diff::<_, &str>(Arity::Many(vec![one, two]))).expect("executed");
  execute(&mut con, Command::Del::<_, &str>(Arity::One(one))).expect("executed");
  execute(&mut con, Command::Del::<_, &str>(Arity::One(two))).expect("executed");
  assert_eq!(result, Response::Array(vec![]));
}
```


Overlapping Code:
```
) = ("test_diff_none_1", "test_diff_none_2");
let mut con = std::net::TcpStream::connect(get_redis_url()).expect("connection");
execute(&mut con, SetCommand::Add(one, Arity::One("one"))).expect("executed");
execute(&mut con, SetCommand::Add(two, Arity::One("two"))).expect("executed");
execute(&mut con, SetCommand::Add(two, Arity::One("one"))).expect("executed");
let result = execute(&mut con, SetCommand::Diff::<_, &str>(Arity::Many(vec![one, two]))).expect("executed");
execute(&mut con, Command::Del::<_, &str>(Arity::One(one))).expect("executed");
execute(&mut con, Command::Del::<_, &str>(Arity::One(two))).expect("executed");
assert_eq!(result, Response::Array(v
```
<Overlap Ratio: 0.9370629370629371>

---

--- 88 --
Question ID: aa63833f6517ba9e68bc10395dbf87eba8352503_0
Original Code:
```
pub async fn send_ping<S>(mut stream: S) -> io::Result<(S, Duration)>
where
    S: AsyncRead + AsyncWrite + Unpin
{
    let payload: [u8; PING_SIZE] = thread_rng().sample(distributions::Standard);
    log::debug!("Preparing ping payload {:?}", payload);
    stream.write_all(&payload).await?;
    stream.flush().await?;
    let started = Instant::now();
    let mut recv_payload = [0u8; PING_SIZE];
    log::debug!("Awaiting pong for {:?}", payload);
    stream.read_exact(&mut recv_payload).await?;
    if recv_payload == payload {
        Ok((stream, started.elapsed()))
    } else {
        Err(io::Error::new(io::ErrorKind::InvalidData, "Ping payload mismatch"))
    }
}
```


Overlapping Code:
```
S>(mut stream: S) -> io::Result<(S, Duration)>
where
S: AsyncRead + AsyncWrite + Unpin
{
let payload: [u8; PING_SIZE] = thread_rng().sample(distributions::Standard);
log::debug!("Preparing ping payload {:?}", payload);
stream.write_all(&payload).await?;
stream.flush().await?;
let started = Instant::now();
let mut recv_payload = [0u8; PING_SIZE];
log::debug!("Awaiting pong for {:?}", payload);
stream.read_exact(&mut recv_payload).await?;
if recv_payload == payload {
Ok((stream, started.elapsed()))
} else {
Err(io::Error::new(io::ErrorKind::InvalidData, "Ping payl
```
<Overlap Ratio: 0.9311475409836065>

---

--- 89 --
Question ID: 865c5bccaf2cdeb98a4bb42827dbd136bcefa4c7_15
Original Code:
```
fn op_mkdir_sync(
  state: &mut OpState,
  args: Value,
  _zero_copy: &mut [ZeroCopyBuf],
) -> Result<Value, AnyError> {
  let args: MkdirArgs = serde_json::from_value(args)?;
  let path = Path::new(&args.path).to_path_buf();
  let mode = args.mode.unwrap_or(0o777) & 0o777;
  state.borrow::<Permissions>().check_write(&path)?;
  debug!("op_mkdir {} {:o} {}", path.display(), mode, args.recursive);
  let mut builder = std::fs::DirBuilder::new();
  builder.recursive(args.recursive);
  #[cfg(unix)]
  {
    use std::os::unix::fs::DirBuilderExt;
    builder.mode(mode);
  }
  builder.create(path)?;
  Ok(json!({}))
}
```


Overlapping Code:
```
c(
state: &mut OpState,
args: Value,
_zero_copy: &mut [ZeroCopyBuf],
) -> Result<Value, AnyError> {
let args: MkdirArgs = serde_json::from_value(args)?;
let path = Path::new(&args.path).to_path_buf();
let mode = args.mode.unwrap_or(0o777) & 0o777;
state.borrow::<Permissions>().check_write(&path)?;
debug!("op_mkdir {} {:o} {}", path.display(), mode, args.recursive);
let mut builder = std::fs::DirBuilder::new();
builder.recursive(args.recursive);
#[cfg(unix)]
{
use std::os::unix::fs::DirBuilderExt;
builder.mode(mode);
}
builder.create(path)?;
Ok(json!({}))
}
```
<Overlap Ratio: 0.9740034662045061>

---

--- 90 --
Question ID: a5df90a6da461ddf854634bd30388390f3510e87_0
Original Code:
```
pub fn reload_config(app_state: &Arc<RwLock<AppState>>) {
    let old_config = app_state.read().config.clone();
    let new_config = Config::read(&app_state.read().config_path);
    app_state.write().config = new_config.clone();

    for task in new_config.tasks.keys() {
        if !old_config.tasks.contains_key(task) {
            app_state.write().tasks.insert(task.to_owned(), Arc::new(RwLock::new(TaskState::new(task))));
        }
    }
    send_message(&app_state.read().events, Event::UpdateConfig);
}
```


Overlapping Code:
```
ppState>>) {
let old_config = app_state.read().config.clone();
let new_config = Config::read(&app_state.read().config_path);
app_state.write().config = new_config.clone();
for task in new_config.tasks.keys() {
if !old_config.tasks.contains_key(task) {
app_state.write().tasks.insert(task.to_owned(), Arc::new(RwLock::new(TaskState::new(task))));
}
}
send_message(&app_state.read().events, Event::Upda
```
<Overlap Ratio: 0.87527352297593>

---

--- 91 --
Question ID: f3f9622398e35a764ac99187b4628e6faac1b02b_5
Original Code:
```
fn all_benches_batch_remove_then_add(c: &mut Criterion) {
    bench_batch_addition_removal_smt(
        c,
        "almost empty tree - remove then add batch",
        (1 << BENCH_HEIGHT as usize) / 10,
        true,
    );
    bench_batch_addition_removal_smt(
        c,
        "half full tree - remove then add batch",
        (1 << BENCH_HEIGHT as usize) / 2,
        true,
    );
    bench_batch_addition_removal_smt(
        c,
        "almost full tree - remove then add batch",
        (9 * (1 << BENCH_HEIGHT as usize)) / 10,
        true,
    );
}
```


Overlapping Code:
```
nches_batch_remove_then_add(c: &mut Criterion) {
bench_batch_addition_removal_smt(
c,
"almost empty tree - remove then add batch",
(1 << BENCH_HEIGHT as usize) / 10,
true,
);
bench_batch_addition_removal_smt(
c,
"half full tree - remove then add batch",
(1 << BENCH_HEIGHT as usize) / 2,
true,
);
bench_batch_addition_removal_smt(
c,
"almost full tree - remove then add batch",
(9 * (1 << BENCH_HEIGH
```
<Overlap Ratio: 0.91324200913242>

---

--- 92 --
Question ID: 5977d053b57db8f8b1825db7da2e083b4c98bdf1_5
Original Code:
```
fn load_file_yields_correct_pixel_channel_count() {
    let result = tex_atlas::load_file(SAMPLE_DATA).unwrap().multi_atlas;
    let expected = multi_atlas();
    for page_name in result.page_names() {
        let result_page = result.by_page_name(page_name).unwrap();
        let expected_page = expected.by_page_name(page_name).unwrap();

        assert_eq!(result_page.channel_count, expected_page.channel_count);
    }
}
```


Overlapping Code:
```
fn load_file_yields_correct_pixel_channel_count() {
let result = tex_atlas::load_file(SAMPLE_DATA).unwrap().multi_atlas;
let expected = multi_atlas();
for page_name in result.page_names() {
let result_page = result.by_page_name(page_name).unwrap();
let expected_page = expected.by_page_name(page_name).unwrap();
assert_eq!(result_page.channel_count, 
```
<Overlap Ratio: 0.9138381201044387>

---

--- 93 --
Question ID: 4de5d4efcf4916b2324e1dc1497ca441069da132_0
Original Code:
```
pub unsafe fn datetime_set(
    year: c_int,
    month: c_int,
    day: c_int,
    hour: c_int,
    minute: c_int,
    second: c_int,
) -> c_int {
    let mut time: libc::tm = mem::zeroed();
    time.tm_year = year - 1900;
    time.tm_mon = month - 1;
    time.tm_mday = day;
    time.tm_hour = hour;
    time.tm_min = minute;
    time.tm_sec = second;
    if time.tm_year < 0 {
        time.tm_year = 0;
    }
    let t: time_t = mktime(&mut time);
    if t == -1 {
        return -1;
    }
    let tv: timeval = timeval {
        tv_sec: t,
        tv_usec: 0,
    };
    if settimeofday(&tv, ptr::null()) == -1 {
        if Error::last_os_error().kind() == ErrorKind::PermissionDenied {
            return -2;
        } else {
            return -3;
        }
    };
    0
}
```


Overlapping Code:
```
et(
year: c_int,
month: c_int,
day: c_int,
hour: c_int,
minute: c_int,
second: c_int,
) -> c_int {
let mut time: libc::tm = mem::zeroed();
time.tm_year = year - 1900;
time.tm_mon = month - 1;
time.tm_mday = day;
time.tm_hour = hour;
time.tm_min = minute;
time.tm_sec = second;
if time.tm_year < 0 {
time.tm_year = 0;
}
let t: time_t = mktime(&mut time);
if t == -1 {
return -1;
}
let tv: timeval = timeval {
tv_sec: t,
tv_usec: 0,
};
if settimeofday(&tv, ptr::null()) == -1 {
if Error::last_os_error().kind() == ErrorKind::PermissionDenied {
return -2;
} else {

```
<Overlap Ratio: 0.9289256198347108>

---

--- 94 --
Question ID: de7e5924959c374c850f9b9254c62b6fbe9ac8da_0
Original Code:
```
fn anoncreds_works_for_single_issuer_single_prover() {
        Setup::empty();

        //1. Create Issuer wallet, gets wallet handle
        let (issuer_wallet_handle, issuer_wallet_config) = wallet::create_and_open_default_wallet("anoncreds_works_for_single_issuer_single_prover").unwrap();

        //2. Create Prover wallet, gets wallet handle
        let (prover_wallet_handle, prover_wallet_config) = wallet::create_and_open_default_wallet("anoncreds_works_for_single_issuer_single_prover").unwrap();

        //3. Issuer creates Schema and Credential Definition
        let (schema_id, schema_json, cred_def_id, cred_def_json) = anoncreds::multi_steps_issuer_preparation(issuer_wallet_handle,
                                                                                                             ISSUER_DID,
                                                                                                             GVT_SCHEMA_NAME,
                                                                                                             GVT_SCHEMA_ATTRIBUTES);

        //4. Prover creates Master Secret
        anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();

        //5. Issuance credential for Prover
        anoncreds::multi_steps_create_credential(COMMON_MASTER_SECRET,
                                                 prover_wallet_handle,
                                                 issuer_wallet_handle,
                                                 CREDENTIAL1_ID,
                                                 &anoncreds::gvt_credential_values_json(),
                                                 &cred_def_id,
                                                 &cred_def_json);

        //6. Proof request
        let nonce = anoncreds::generate_nonce().unwrap();
        let proof_req_json = json!({
                                       "nonce": nonce,
                                       "name":"proof_req_1",
                                       "version":"0.1",
                                       "requested_attributes":{
                                            "attr1_referent":{
                                                "name":"name"
                                            },
                                            "attr2_referent":{
                                                "name":"sex"
                                            },
                                            "attr3_referent":{"name":"phone"}
                                       },
                                       "requested_predicates":{
                                            "predicate1_referent":{"name":"age","p_type":">=","p_value":18}
                                       }
                                    }).to_string();

        //7. Prover gets Credentials for Proof Request
        let credentials_json = anoncreds::prover_get_credentials_for_proof_req(prover_wallet_handle, &proof_req_json).unwrap();
        let credential = anoncreds::get_credential_for_attr_referent(&credentials_json, "attr1_referent");

        //8. Prover creates Proof
        let self_attested_value = "8-800-300";
        let requested_credentials_json = format!(r#"{{
                                                  "self_attested_attributes":{{"attr3_referent":"{}"}},
                                                  "requested_attributes":{{
                                                        "attr1_referent":{{ "cred_id":"{}", "revealed":true }},
                                                        "attr2_referent":{{ "cred_id":"{}", "revealed":false }}
                                                  }},
                                                  "requested_predicates":{{
                                                        "predicate1_referent":{{ "cred_id":"{}" }}
                                                  }}
                                                }}"#, self_attested_value, credential.referent, credential.referent, credential.referent);

        let schemas_json = json!({schema_id: serde_json::from_str::<Schema>(&schema_json).unwrap()}).to_string();
        let cred_defs_json = json!({cred_def_id: serde_json::from_str::<CredentialDefinition>(&cred_def_json).unwrap()}).to_string();
        let rev_states_json = json!({}).to_string();

        let proof_json = anoncreds::prover_create_proof(prover_wallet_handle,
                                                        &proof_req_json,
                                                        &requested_credentials_json,
                                                        COMMON_MASTER_SECRET,
                                                        &schemas_json,
                                                        &cred_defs_json,
                                                        &rev_states_json).unwrap();

        let proof: Proof = serde_json::from_str(&proof_json).unwrap();

        //9. Verifier verifies proof
        assert_eq!("Alex", proof.requested_proof.revealed_attrs.get("attr1_referent").unwrap().raw);
        assert_eq!(0, proof.requested_proof.unrevealed_attrs.get("attr2_referent").unwrap().sub_proof_index);
        assert_eq!(self_attested_value, proof.requested_proof.self_attested_attrs.get("attr3_referent").unwrap());

        let rev_reg_defs_json = json!({}).to_string();
        let rev_regs_json = json!({}).to_string();

        let valid = anoncreds::verifier_verify_proof(&proof_req_json,
                                                     &proof_json,
                                                     &schemas_json,
                                                     &cred_defs_json,
                                                     &rev_reg_defs_json,
                                                     &rev_regs_json).unwrap();
        assert!(valid);

        wallet::close_and_delete_wallet(issuer_wallet_handle, &issuer_wallet_config).unwrap();
        wallet::close_and_delete_wallet(prover_wallet_handle, &prover_wallet_config).unwrap();
    }
```


Overlapping Code:
```
ds_works_for_single_issuer_single_prover() {
Setup::empty();
//1. Create Issuer wallet, gets wallet handle
let (issuer_wallet_handle, issuer_wallet_config) = wallet::create_and_open_default_wallet("anoncreds_works_for_single_issuer_single_prover").unwrap();
//2. Create Prover wallet, gets wallet handle
let (prover_wallet_handle, prover_wallet_config) = wallet::create_and_open_default_wallet("anoncreds_works_for_single_issuer_single_prover").unwrap();
//3. Issuer creates Schema and Credential Definition
let (schema_id, schema_json, cred_def_id, cred_def_json) = anoncreds::multi_steps_issuer_preparation(issuer_wallet_handle,
ISSUER_DID,
GVT_SCHEMA_NAME,
GVT_SCHEMA_ATTRIBUTES);
//4. Prover creates Master Secret
anoncreds::prover_create_master_secret(prover_wallet_handle, COMMON_MASTER_SECRET).unwrap();
//5. Issuance credential for Prover
anoncreds::multi_steps_create_credential(COMMON_MASTER_SECRET,
prover_wallet_handle,
issuer_wallet_handle,
CREDENTIAL1_ID,
&anoncreds::gvt_credential_values_json(),
&cred_def_id,
&cred_def_json);
//6. Proof request
let nonce = anoncreds::generate_nonce().unwrap();
let proof_req_json = json!({
"nonce": nonce,
"name":"proof_req_1",
"version":"0.1",
"requested_attributes":{
"attr1_referent":{
"name":"name"
},

```
<Overlap Ratio: 0.9661798616448886>

---

--- 95 --
Question ID: 7f557e340bbc8caa4ae4983f9a1ffcbf60c55928_0
Original Code:
```
pub(crate) fn const_field<'tcx>(
    tcx: TyCtxt<'tcx>,
    param_env: ty::ParamEnv<'tcx>,
    variant: Option<VariantIdx>,
    field: mir::Field,
    value: &'tcx ty::Const<'tcx>,
) -> ConstValue<'tcx> {
    trace!("const_field: {:?}, {:?}", field, value);
    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);
    // get the operand again
    let op = ecx.eval_const_to_op(value, None).unwrap();
    // downcast
    let down = match variant {
        None => op,
        Some(variant) => ecx.operand_downcast(op, variant).unwrap(),
    };
    // then project
    let field = ecx.operand_field(down, field.index()).unwrap();
    // and finally move back to the const world, always normalizing because
    // this is not called for statics.
    op_to_const(&ecx, field)
}
```


Overlapping Code:
```
e) fn const_field<'tcx>(
tcx: TyCtxt<'tcx>,
param_env: ty::ParamEnv<'tcx>,
variant: Option<VariantIdx>,
field: mir::Field,
value: &'tcx ty::Const<'tcx>,
) -> ConstValue<'tcx> {
trace!("const_field: {:?}, {:?}", field, value);
let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);
// get the operand again
let op = ecx.eval_const_to_op(value, None).unwrap();
// downcast
let down = match variant {
None => op,
Some(variant) => ecx.operand_downcast(op, variant).unwrap(),
};
// then project
let field = ecx.operand_field(down, field.index()).unwrap();
// and finally move back to the const world, always normalizing because
// this is not called for statics.
op_to_const(&ecx,
```
<Overlap Ratio: 0.9754335260115607>

---

--- 96 --
Question ID: 99767cca585400c697da62c19bc41eb694ddee56_0
Original Code:
```
pub fn deserialize() {
        let stream_json = "{\"infoHash\":\"07a9de9750158471c3302e4e95edb1107f980fa6\",\"fileIdx\":1,\"title\":\"test stream\"}";
        let stream: Stream = serde_json::from_str(&stream_json).unwrap();
        assert_eq!(
            stream,
            Stream {
                title: Some("test stream".into()),
                thumbnail: None,
                subtitles: Default::default(),
                behavior_hints: Default::default(),
                source: StreamSource::Torrent {
                    info_hash: [
                        0x07, 0xa9, 0xde, 0x97, 0x50, 0x15, 0x84, 0x71, 0xc3, 0x30, 0x2e, 0x4e,
                        0x95, 0xed, 0xb1, 0x10, 0x7f, 0x98, 0x0f, 0xa6
                    ],
                    file_idx: Some(1),
                }
            }
        )
    }
```


Overlapping Code:
```
 {
let stream_json = "{\"infoHash\":\"07a9de9750158471c3302e4e95edb1107f980fa6\",\"fileIdx\":1,\"title\":\"test stream\"}";
let stream: Stream = serde_json::from_str(&stream_json).unwrap();
assert_eq!(
stream,
Stream {
title: Some("test stream".into()),
thumbnail: None,
subtitles: Default::default(),
behavior_hints: Default::default(),
source: StreamSource::Torrent {
info_hash: [
0x07, 0xa9, 0xde, 0x97, 0x50, 0x15, 0x84, 0x71, 0xc3, 0x30, 0x2e, 0x4e,
0x95, 0xed, 0xb1, 0x10, 0x7f, 0x98, 0x0f, 0xa
```
<Overlap Ratio: 0.9074410163339383>

---

--- 97 --
Question ID: c1a310764c91ca1631bbc6335c1e727cc6dcd2a1_18
Original Code:
```
fn parse_int_float_str() {
    let realm = Realm::create();
    let mut engine = Interpreter::new(realm);

    assert_eq!(&forward(&mut engine, "parseInt(\"100.5\")"), "NaN");
}
```


Overlapping Code:
```
() {
let realm = Realm::create();
let mut engine = Interpreter::new(realm);
assert_eq!(&forward(&mut engine, "parseInt(\
```
<Overlap Ratio: 0.7317073170731707>

---

--- 98 --
Question ID: 113040ce8788a67a5081fee45d7aaef46ef743d8_1
Original Code:
```
pub async fn main(matches: &clap::ArgMatches<'_>) -> Result<(), failure::Error> {
    use crate::model::config::Config;

    let config = matches.value_of("config").unwrap();
    let mut cfg_fi = File::open(&config).unwrap();
    let mut cfg_by = Vec::new();
    cfg_fi.read_to_end(&mut cfg_by).unwrap();
    let config: Config = toml::de::from_slice(&cfg_by).unwrap();

    // let control_socket = matches.value_of_os("control-socket").unwrap();
    // let control_socket = Path::new(control_socket).to_owned();
    let mount_point = matches.value_of_os("mount-point").unwrap();
    let mount_point = Path::new(mount_point).to_owned();

    let states = build_storage_engine_states(&config).unwrap();

    let mut fs_impl = FilesystemImplMutable {
        storage_backend: states.storage_engine,
        content_info: states.content_info_manager,
        vfs: Vfs {
            inodes: Default::default(),
            inode_seq: 3,
        },
    };
    fs_impl.vfs.inodes.insert(
        1,
        FileEntry {
            info_hash_owner_counter: 1,
            inode: 1,
            size: 0,
            data: FileEntryData::Dir(Directory {
                parent: 1,
                child_inodes: Default::default(),
            }),
        },
    );
    for t in states.path_to_torrent.values() {
        if let Err(err) = fs_impl.add_torrent(t) {
            event!(
                Level::ERROR,
                "{}:{}: failed to add torrent: {}",
                file!(),
                line!(),
                err
            );
        }
        event!(Level::INFO, "added {:?} to filesystem", t.info_hash);
    }

    event!(
        Level::INFO,
        "mounting with {} known inodes",
        fs_impl.vfs.inodes.len()
    );

    tokio::task::spawn_blocking(move || {
        let options = ["-o", "ro", "-o", "fsname=magnetite"]
            .iter()
            .map(|o| o.as_ref())
            .collect::<Vec<&OsStr>>();

        let fs_impl = FilesystemImpl {
            mutable: Arc::new(Mutex::new(fs_impl)),
        };

        fuse::mount(fs_impl, &mount_point, &options).unwrap();
    })
    .await?;

    Ok(())
}
```


Overlapping Code:
```
ync fn main(matches: &clap::ArgMatches<'_>) -> Result<(), failure::Error> {
use crate::model::config::Config;
let config = matches.value_of("config").unwrap();
let mut cfg_fi = File::open(&config).unwrap();
let mut cfg_by = Vec::new();
cfg_fi.read_to_end(&mut cfg_by).unwrap();
let config: Config = toml::de::from_slice(&cfg_by).unwrap();
// let control_socket = matches.value_of_os("control-socket").unwrap();
// let control_socket = Path::new(control_socket).to_owned();
let mount_point = matches.value_of_os("mount-point").unwrap();
let mount_point = Path::new(mount_point).to_owned();
let states = build_storage_engine_states(&config).unwrap();
let mut fs_impl = FilesystemImplMutable {
storage_backend: states.storage_engine,
content_info: states.content_info_manager,
vfs: Vfs {
inodes: Default::default(),
inode_seq: 3,
},
};
fs_impl.vfs.inodes.insert(
1,
FileEntry {
info_hash_owner_counter: 1,
inode: 1,
size: 0,
data: FileEntryData::Dir(Directory {
parent: 1,
child_inodes: Default::default(),
}),
},
);
for t in states.path_to_torrent.values() {
if let Err(err) = fs_impl.add_torrent(t) {
event!(
Level::ERROR,
"{}:{}: failed to add torrent: {}",
file!(),
line!(),
err
);
}
event!(Level::INFO, "added {:?} to filesystem", t.info_hash);
}
event!(
Level::INFO,
"mounting with {} known inodes",
fs_impl.vfs.inodes.len()
);
tokio::task::spawn_blocking(move || {
let options = ["-o", "ro", "-o", "fsname=magnetite"]
.iter()
.map(|o| o.as_ref())
.collect::<Vec<&OsStr>>();
let fs_impl = FilesystemImpl {
mutable: Arc::new(Mutex::new(fs_impl)),
};
fuse::mount(fs_impl, &mount_point, &options).unwrap();
})
.await?;
Ok(
```
<Overlap Ratio: 0.9932639314145744>

---

--- 99 --
Question ID: ba8eafbbc9189bc8b50af16030a21b28079e843c_0
Original Code:
```
fn process_pattern<'a>(lines: impl Iterator<Item=&'a str>) -> TreePattern {
    let mut peekable_lines = lines.peekable();
    let row_width = peekable_lines.peek().unwrap().len();
    let tree_index_rows: Vec<HashSet<usize>> = peekable_lines.map(|line| 
        line.char_indices().filter_map(|(idx, space)| {
            if space == TREE { Some(idx) }
            else { None }
        }).collect()
    ).collect();

    TreePattern { tree_index_rows, row_width }
}
```


Overlapping Code:
```
pattern<'a>(lines: impl Iterator<Item=&'a str>) -> TreePattern {
let mut peekable_lines = lines.peekable();
let row_width = peekable_lines.peek().unwrap().len();
let tree_index_rows: Vec<HashSet<usize>> = peekable_lines.map(|line| 
line.char_indices().filter_map(|(idx, space)| {
if space == TREE { Some(idx) }
else { None }
}).collect()
).collect();
```
<Overlap Ratio: 0.8620689655172413>

---

--- 100 --
Question ID: 310cc916e5f0219818b9a9a024731a78f12a3ae8_1
Original Code:
```
pub fn flush_storage(storage: &mut Storage, buffer: KVBuffer) -> std::io::Result<()> {
    let tx = storage.get_or_create_tx();
    for ((col, key), value) in buffer.into_iter() {
        if let Some(val) = &value {
            tx.put(col, &key, val);
        } else {
            tx.delete(col, &key);
        }
    }
    storage.persist_write()
}
```


Overlapping Code:
```
e(storage: &mut Storage, buffer: KVBuffer) -> std::io::Result<()> {
let tx = storage.get_or_create_tx();
for ((col, key), value) in buffer.into_iter() {
if let Some(val) = &value {
tx.put(col, &key, val);
} else {
tx.delete(col, &key);
}
}
storage.pe
```
<Overlap Ratio: 0.8802816901408451>

---

--- 101 --
Question ID: ec60b2ed1f1309bbff6f421e55178a3b848a5e98_2
Original Code:
```
fn take_losing_turn() {
        let mut game = Game {
            board: vec![0; 25],
            size: 5,
            state: GameState::Continue(1),
        };
        game.board[0] = 1;
        game.board[20] = 1;

        game.take_turn(1);
        assert_eq!(GameState::Lose, game.state);
    }
```


Overlapping Code:
```
 {
let mut game = Game {
board: vec![0; 25],
size: 5,
state: GameState::Continue(1),
};
game.board[0] = 1;
game.board[20] = 1;
game.take_turn(1);
assert
```
<Overlap Ratio: 0.7272727272727273>

---

--- 102 --
Question ID: f47d38847bc8cd54ec6fc56c4fe3713205164d4b_2
Original Code:
```
fn test_sidewinder() {
        let width = 50_usize;
        let height = 50_usize;
        for _i in 0..10000 {
            let mut grid = Grid::new(height, width);
            grid.sidewinder(None);

            assert!(maze_is_perfect(&grid));
        }
    }
```


Overlapping Code:
```
 50_usize;
let height = 50_usize;
for _i in 0..10000 {
let mut grid = Grid::new(height, width);
grid.sidewinder(None);
assert!(maze_is_perfect(&grid));
```
<Overlap Ratio: 0.798941798941799>

---

--- 103 --
Question ID: 3b56425eaf37555db1d5565d434f7de1ca61b166_2
Original Code:
```
fn decode_byte_short() {
        let enc = Encoder::from_hex("");
        let mut dec = enc.as_decoder();
        assert!(dec.decode_byte().is_none());
    }
```


Overlapping Code:
```
{
let enc = Encoder::from_hex("");
let mut dec = enc.as_decoder();
assert!(dec.decode_byte().is_none
```
<Overlap Ratio: 0.7751937984496124>

---

--- 104 --
Question ID: 5286d674984a2d668f57d2d8044bdf7ce46bd44e_1
Original Code:
```
fn next_pos<F>(pos: i32, result_events: &[Rc<SweepEvent<F>>], processed: &mut HashSet<i32>, orig_index: i32) -> i32
where
    F: Float,
{
    let p = result_events[pos as usize].point;
    let mut new_pos = pos + 1;
    let length = result_events.len() as i32;
    let mut p1 = if new_pos < length {
        result_events[new_pos as usize].point
    } else {
        p
    };

    while new_pos < length && p == p1 {
        if !processed.contains(&new_pos) {
            return new_pos;
        } else {
            new_pos += 1;
        }
        if new_pos < length {
            p1 = result_events[new_pos as usize].point;
        }
    }

    new_pos = pos - 1;

    while processed.contains(&new_pos) && new_pos >= orig_index as i32 {
        new_pos -= 1;
    }
    new_pos
}
```


Overlapping Code:
```
ext_pos<F>(pos: i32, result_events: &[Rc<SweepEvent<F>>], processed: &mut HashSet<i32>, orig_index: i32) -> i32
where
F: Float,
{
let p = result_events[pos as usize].point;
let mut new_pos = pos + 1;
let length = result_events.len() as i32;
let mut p1 = if new_pos < length {
result_events[new_pos as usize].point
} else {
p
};
while new_pos < length && p == p1 {
if !processed.contains(&new_pos) {
return new_pos;
} else {
new_pos += 1;
}
if new_pos < length {
p1 = result_events[new_pos as usize].point;
}
}
new_pos = pos - 1;
while processed.contains(&new_pos) && new_pos >= orig_index as i32 {
ne
```
<Overlap Ratio: 0.9569377990430622>

---

--- 105 --
Question ID: f30a3d3e230c2bd76483305c5568d339dbc94463_0
Original Code:
```
fn test_getrlimit() {
    let lim = rustix::process::getrlimit(Resource::Stack);
    assert_ne!(lim.current, Some(0));
    assert_ne!(lim.maximum, Some(0));
}
```


Overlapping Code:
```
n test_getrlimit() {
let lim = rustix::process::getrlimit(Resource::Stack);
assert_ne!(lim.current, 
```
<Overlap Ratio: 0.684931506849315>

---

--- 106 --
Question ID: f25638d9067771249a900548652c42387f4bada2_6
Original Code:
```
fn test_tile_next() {
        assert_eq!(t("1m").next(), t("2m"));
        assert_eq!(t("3p").next(), t("4p"));
        assert_eq!(t("5s").next(), t("6s"));
        assert_eq!(t("1z").next(), t("2z"));
        assert_eq!(t("6z").next(), t("7z"));
    }
```


Overlapping Code:
```
_tile_next() {
assert_eq!(t("1m").next(), t("2m"));
assert_eq!(t("3p").next(), t("4p"));
assert_eq!(t("5s").next(), t("6s"));
assert_eq!(t("1z").next(), t("2z"));
assert_eq!(t("6z").next(), t("7z"));

```
<Overlap Ratio: 0.9615384615384616>

---

--- 107 --
Question ID: e7d7b502848317667755dcd4eb696832bf81644b_2
Original Code:
```
fn settings_box() -> gtk::Box {
    let b = gtk::Box::new(gtk::Orientation::Vertical, 12);
    b.set_margin_start(12);
    b.set_margin_end(12);
    b
}
```


Overlapping Code:
```
() -> gtk::Box {
let b = gtk::Box::new(gtk::Orientation::Vertical, 12);
b.set_margin_start(12);
b.se
```
<Overlap Ratio: 0.7352941176470589>

---

--- 108 --
Question ID: acb80b20fd9b318a89bf6ee92e1bf91c92ce0e90_0
Original Code:
```
async fn round_trip_client(payload: &[u8], port: u16) -> anyhow::Result<()> {
    let (mut reader, mut writer) = ws_connect(port).await.context("Connect")?.into_erased_split();
    let write_fut = write_payload(&mut writer, payload).map(|res| res.context("Write payload"));
    let read_fut = read_assert_payload(&mut reader, payload).map(|res| res.context("Assert payload"));
    tokio::try_join!(write_fut, read_fut)?;
    writer.shutdown().await.context("Shutdown operation")?;
    Ok(())
}
```


Overlapping Code:
```
rip_client(payload: &[u8], port: u16) -> anyhow::Result<()> {
let (mut reader, mut writer) = ws_connect(port).await.context("Connect")?.into_erased_split();
let write_fut = write_payload(&mut writer, payload).map(|res| res.context("Write payload"));
let read_fut = read_assert_payload(&mut reader, payload).map(|res| res.context("Assert payload"));
tokio::try_join!(write_fut, read_fut)?;
writer.shutdown().await.context("Shutdown operation")?;
Ok(()
```
<Overlap Ratio: 0.9594882729211087>

---

--- 109 --
Question ID: 94918172b440365c4024fa325e96d422712b7d9d_2
Original Code:
```
fn test_add_vector() {
    let p = Point3::new(1.0, 2.0, 3.0);
    let r = Vec3::new(2.0, 2.0, 2.0);

    assert_eq!(p + r, Point3::new(3.0, 4.0, 5.0));
  }
```


Overlapping Code:
```
add_vector() {
let p = Point3::new(1.0, 2.0, 3.0);
let r = Vec3::new(2.0, 2.0, 2.0);
assert_eq!(p + 
```
<Overlap Ratio: 0.7092198581560284>

---

--- 110 --
Question ID: f6599a6e0e0c2f05481fa8dc4f1d8630b599deb2_2
Original Code:
```
fn histogram_from_categories(vals: &Vec<String>) -> (Vec<(String, usize)>, Option<f32>, Option<f32>, Option<f32>, f32) {
    let ret: Vec<(String, usize)> = vals.iter()
        .sorted()
        .group_by(|e| (**e).to_owned())
        .into_iter()
        .map(|(k, group_k)| (k, group_k.count()))
        .sorted_by(|(_, i), (_, j)| i.cmp(j))
        .collect();
    let total = ret.iter().fold(0.0, |t, (_s, x)| t + *x as f32);
    (ret, None, None, None, total)
}
```


Overlapping Code:
```
g>) -> (Vec<(String, usize)>, Option<f32>, Option<f32>, Option<f32>, f32) {
let ret: Vec<(String, usize)> = vals.iter()
.sorted()
.group_by(|e| (**e).to_owned())
.into_iter()
.map(|(k, group_k)| (k, group_k.count()))
.sorted_by(|(_, i), (_, j)| i.cmp(j))
.collect();
let total = ret.iter().fold(0.0, |t, (_s, x)| t + *x as f32);
(ret, None, None, Non
```
<Overlap Ratio: 0.8620689655172413>

---

--- 111 --
Question ID: 7eccdf0c15b0f08a4c6966cd78842acd695182b9_0
Original Code:
```
fn buffer_extend(&mut self, len: usize) -> Result<&mut [u8], Error> {
        let pos = self.as_ref().len();
        let end = pos + len;
        self.buffer_resize(end)?;
        Ok(&mut self.as_mut()[pos..end])
    }
```


Overlapping Code:
```
Result<&mut [u8], Error> {
let pos = self.as_ref().len();
let end = pos + len;
self.buffer_resize(en
```
<Overlap Ratio: 0.5494505494505495>

---

--- 112 --
Question ID: 32308decbf7c9a16eaf72aeafae4a2116235fee3_5
Original Code:
```
fn test_temp_dir() {
        let tmpdir = user::temp_dir("foo").unwrap();
        assert_eq!(tmpdir.exists(), true);
        assert!(sys::remove_all(&tmpdir).is_ok());
        assert_eq!(tmpdir.exists(), false);
    }
```


Overlapping Code:
```
temp_dir("foo").unwrap();
assert_eq!(tmpdir.exists(), true);
assert!(sys::remove_all(&tmpdir).is_ok());
assert_eq!(tmpdir.exists(), false
```
<Overlap Ratio: 0.7569060773480663>

---

--- 113 --
Question ID: 94076d324b7a312413af2bf95e86ece18511af88_0
Original Code:
```
fn main() -> Result<(), pa::Error> {
    println!("blocking sine wave");
    println!(
        "sample_rate: {}, msecs: {}, freq: {}",
        SAMPLE_RATE, MSECS, FREQ
    );
    println!("buffer size: {}, buffers: {}", BUFFER_SIZE, BUFFERS);
    println!(
        "last buffer nominal size: {}",
        BUFFER_SIZE * (BUFFERS + 1) - FRAMES
    );

    // Set up the stream.
    let pa = pa::PortAudio::new()?;
    let settings = pa.default_output_stream_settings(
        1, // 1 channel
        SAMPLE_RATE as f64,
        BUFFER_SIZE as u32,
    )?;
    let mut stream = pa.open_blocking_stream(settings)?;
    stream.start()?;

    // State for the sine generator.
    let mut angle: f32 = 0.0;

    // Bump the state forward by the given number of frames.
    let advance_state = |angle: &mut f32, advance| {
        *angle += advance as f32 * 2.0 * PI * FREQ / SAMPLE_RATE;
        while *angle >= 2.0 * PI {
            *angle -= 2.0 * PI;
        }
        assert!(*angle >= 0.0 && *angle < 2.0 * PI);
    };

    // Write all the frames.
    let mut written = 0;
    while written < FRAMES {
        let status = stream.write(BUFFER_SIZE as u32, |buffer| {
            assert_eq!(buffer.len(), BUFFER_SIZE);
            for sample in buffer.iter_mut() {
                *sample = 0.8 * angle.sin();
                advance_state(&mut angle, 1);
            }
        });

        // On underflow, do not panic, but skip ahead to the
        // next buffer.
        match status {
            Ok(_) => (),
            Err(pa::Error::OutputUnderflowed) => {
                eprintln!("underflow: written = {}", written);
                advance_state(&mut angle, BUFFER_SIZE);
            }
            _ => {
                status?;
            }
        }

        // Advance to next buffer.
        written += BUFFER_SIZE;
    }

    // Tear down the stream.
    stream.stop()?;
    stream.close()?;
    Ok(())
}
```


Overlapping Code:
```
 -> Result<(), pa::Error> {
println!("blocking sine wave");
println!(
"sample_rate: {}, msecs: {}, freq: {}",
SAMPLE_RATE, MSECS, FREQ
);
println!("buffer size: {}, buffers: {}", BUFFER_SIZE, BUFFERS);
println!(
"last buffer nominal size: {}",
BUFFER_SIZE * (BUFFERS + 1) - FRAMES
);
// Set up the stream.
let pa = pa::PortAudio::new()?;
let settings = pa.default_output_stream_settings(
1, // 1 channel
SAMPLE_RATE as f64,
BUFFER_SIZE as u32,
)?;
let mut stream = pa.open_blocking_stream(settings)?;
stream.start()?;
// State for the sine generator.
let mut angle: f32 = 0.0;
// Bump the state forward by the given number of frames.
let advance_state = |angle: &mut f32, advance| {
*angle += advance as f32 * 2.0 * PI * FREQ / SAMPLE_RATE;
while *angle >= 2.0 * PI {
*angle -= 2.0 * PI;
}
assert!(*angle >= 0.0 && *angle < 2.0 * PI);
};
// Write all the frames.
let mut written = 0;
while written < FRAMES {
let status = stream.write(BUFFER_SIZE as u32, |buffer| {
assert_eq!(buffer.len(), BUFFER_SIZE);
for sample in buffer.iter_mut() {
*sample = 0.8 * angle.sin();
advance_state(&mut angle, 1);
}
});
// On underflow, do not panic, but skip ahead to the
// next buffer.
match status {
Ok(_) => (),
Err(pa::Error::OutputUnderflowed) => {
eprintln!("underflow: written = {}", written);
advance_state(&mut angle, BUFFER_SIZE);
}
_ => {
status?;
}
}
// Advance to next buffer.
written += BUFFER_SIZE;
}
// Tear down the stream.
stream.stop()?;
stream.
```
<Overlap Ratio: 0.9817197020988491>

---

--- 114 --
Question ID: 375493a91064b17b938127e3f2b8852364b25a77_1
Original Code:
```
pub fn test() -> RrResult<()> {
    let output = Command::new("cargo")
        .arg("test")
        .output()?;

    check_output(&output)?;
    Ok(())
}
```


Overlapping Code:
```
-> RrResult<()> {
let output = Command::new("cargo")
.arg("test")
.output()?;
check_output(&output)?;
Ok((
```
<Overlap Ratio: 0.8548387096774194>

---

--- 115 --
Question ID: a9c2d6e2f1cb5c737398e9dd04a1fff8534a01e2_0
Original Code:
```
fn json() -> serde_json::Result<()> {
        assert!(serde_json::from_str::<IpLocationService>("-1").is_err());

        let json = "[1,2]";
        let e1: Vec<IpLocationService> = serde_json::from_str(json)?;
        assert_eq!(
            e1,
            vec![IpLocationService::Ip2Location, IpLocationService::Neustar]
        );
        assert_eq!(serde_json::to_string(&e1)?, json);

        Ok(())
    }
```


Overlapping Code:
```
fn json() -> serde_json::Result<()> {
assert!(serde_json::from_str::<IpLocationService>("-1").is_err());
let json = "[1,2]";
let e1: Vec<IpLocationService> = serde_json::from_str(json)?;
assert_eq!(
e1,
vec![IpLocationService::Ip2Location, IpLocationService::Neustar]
);
assert_eq!(serde_json::to_string(&e1)?, json);
Ok(())
}
```
<Overlap Ratio: 1.0>

---

--- 116 --
Question ID: e7dbfb99a370bb801aa52bcdcce1fecf1606026c_1
Original Code:
```
pub async fn bridge<TRng>(xors: Xors<TRng>, clear_stream: TcpStream, clear_stream_name: String, encrypted_stream: TcpStream, encrypted_stream_name: String) where
TRng: CryptoRng + RngCore + Clone + Any {

    let write_future = task::spawn(run_bridge_loop(
        xors.write_xor,
        clear_stream.clone(),
        clear_stream_name.clone(),
        encrypted_stream.clone(),
        encrypted_stream_name.clone()));

    let read_future = task::spawn(run_bridge_loop(
        xors.read_xor,
        encrypted_stream.clone(),
        encrypted_stream_name.clone(),
        clear_stream.clone(),
        clear_stream_name.clone()));

    match select(write_future, read_future).await {
        Either::Left(r) => match r.0 {
            Ok(()) => {
                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Write, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;
            },
            Err(err) => {
                shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Both, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;
                log::error!("{} -> {} ended in error: {}", clear_stream_name, encrypted_stream_name, err);
            }
        },
        Either::Right(r) => match r.0 {
            Ok(()) => {
                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Write, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;
            },
            Err(err) => {
                shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;
                log::error!("{} -> {} ended in error: {}", encrypted_stream_name, clear_stream_name, err);
            }
        },
    };
}
```


Overlapping Code:
```
n bridge<TRng>(xors: Xors<TRng>, clear_stream: TcpStream, clear_stream_name: String, encrypted_stream: TcpStream, encrypted_stream_name: String) where
TRng: CryptoRng + RngCore + Clone + Any {
let write_future = task::spawn(run_bridge_loop(
xors.write_xor,
clear_stream.clone(),
clear_stream_name.clone(),
encrypted_stream.clone(),
encrypted_stream_name.clone()));
let read_future = task::spawn(run_bridge_loop(
xors.read_xor,
encrypted_stream.clone(),
encrypted_stream_name.clone(),
clear_stream.clone(),
clear_stream_name.clone()));
match select(write_future, read_future).await {
Either::Left(r) => match r.0 {
Ok(()) => {
shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Write, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;
},
Err(err) => {
shutdown_both(clear_stream, clear_stream_name.clone(), Shutdown::Both, encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both).await;
log::error!("{} -> {} ended in error: {}", clear_stream_name, encrypted_stream_name, err);
}
},
Either::Right(r) => match r.0 {
Ok(()) => {
shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Write, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;
},
Err(err) => {
shutdown_both(encrypted_stream, encrypted_stream_name.clone(), Shutdown::Both, clear_stream, clear_stream_name.clone(), Shutdown::Both).await;
log::error!("{} -> {} ended in error: {}", encrypted_stream_name, clear_stre
```
<Overlap Ratio: 0.9764309764309764>

---

--- 117 --
Question ID: d3608c0dff2e07fabd9c1227d9667486d71be599_0
Original Code:
```
async fn exec_cmd_to_sleep_without_limit() {
        let app = RetryApp::<TestE, TestS> {
            state: State::ExecuteCommand(TestE {
                output: Box::new(|| Ok(Exit::new(1))),
            }),
            count: None,
        };

        let next = app.handle().await;

        assert!(match &next {
            Transition::Next(a) => match a.state {
                State::Sleep(_) => true,
                _ => false,
            },
            _ => false,
        });
    }
```


Overlapping Code:
```
c fn exec_cmd_to_sleep_without_limit() {
let app = RetryApp::<TestE, TestS> {
state: State::ExecuteCommand(TestE {
output: Box::new(|| Ok(Exit::new(1))),
}),
count: None,
};
let next = app.handle().await;
assert!(match &next {
Transition::Next(a) => match a.state {
State::Sleep(_) => true,
_ => false,
},
_ => false,
}
```
<Overlap Ratio: 0.9755351681957186>

---

--- 118 --
Question ID: 0334f617d2ed1adf468721f8fa69216e5aff3cc4_8
Original Code:
```
pub fn inc<T: CpuRegister, U: CpuBus>(operand: Word, register: &mut T, bus: &mut U) {
  let computed = bus.read(operand) as i8 +1;
  register
    .update_status_negative_by(computed as Data)
    .update_status_zero_by(computed as Data);
  bus.write(operand, computed as Data)
}
```


Overlapping Code:
```
: CpuRegister, U: CpuBus>(operand: Word, register: &mut T, bus: &mut U) {
let computed = bus.read(operand) as i8 +1;
register
.update_status_negative_by(computed as Data)
.update_status_zero_by(computed as Data);
bus.write(operand, computed as Data)

```
<Overlap Ratio: 0.9505703422053232>

---

--- 119 --
Question ID: 47236b1fbcbd9d978773b10e5314f7fa6a9b586d_4
Original Code:
```
fn test_accessor() {
    assert_eq!(Foo::hoge(), "hoge");
    assert_eq!(Foo::piyo(), "piyo");
    assert_eq!(accessor_name!(Foo::hoge), "hoge");
}
```


Overlapping Code:
```
q!(Foo::hoge(), "hoge");
assert_eq!(Foo::piyo(), "piyo");
assert_eq!(accessor_name!(Foo::hoge), "hog
```
<Overlap Ratio: 0.7407407407407407>

---

--- 120 --
Question ID: e1a2afa1286ebedb732dbf8cbb2c5b57fa3c8ce4_2
Original Code:
```
pub fn gru(vs: &super::var_store::Path, in_dim: i64, hidden_dim: i64, c: RNNConfig) -> GRU {
    let num_directions = if c.bidirectional { 2 } else { 1 };
    let gate_dim = 3 * hidden_dim;
    let mut flat_weights = vec![];
    for layer_idx in 0..c.num_layers {
        for direction_idx in 0..num_directions {
            let in_dim = if layer_idx == 0 {
                in_dim
            } else {
                hidden_dim * num_directions
            };
            let suffix = if direction_idx == 1 { "_reverse" } else { "" };
            let w_ih = vs.kaiming_uniform(
                &format!("weight_ih_l{}{}", layer_idx, suffix),
                &[gate_dim, in_dim],
            );
            let w_hh = vs.kaiming_uniform(
                &format!("weight_hh_l{}{}", layer_idx, suffix),
                &[gate_dim, hidden_dim],
            );
            flat_weights.push(w_ih);
            flat_weights.push(w_hh);
            if c.has_biases {
                let b_ih = vs.zeros(&format!("bias_ih_l{}{}", layer_idx, suffix), &[gate_dim]);
                let b_hh = vs.zeros(&format!("bias_hh_l{}{}", layer_idx, suffix), &[gate_dim]);
                flat_weights.push(b_ih);
                flat_weights.push(b_hh);
            }
        }
    }
    if vs.device().is_cuda() && crate::Cuda::cudnn_is_available() {
        let _ = Tensor::internal_cudnn_rnn_flatten_weight(
            &flat_weights,
            4,
            in_dim,
            3, /* 3 for GRU see rnn.cpp in pytorch */
            hidden_dim,
            c.num_layers,
            c.batch_first,
            c.bidirectional,
        );
    }
    GRU {
        flat_weights,
        hidden_dim,
        config: c,
        device: vs.device(),
    }
}
```


Overlapping Code:
```
r_store::Path, in_dim: i64, hidden_dim: i64, c: RNNConfig) -> GRU {
let num_directions = if c.bidirectional { 2 } else { 1 };
let gate_dim = 3 * hidden_dim;
let mut flat_weights = vec![];
for layer_idx in 0..c.num_layers {
for direction_idx in 0..num_directions {
let in_dim = if layer_idx == 0 {
in_dim
} else {
hidden_dim * num_directions
};
let suffix = if direction_idx == 1 { "_reverse" } else { "" };
let w_ih = vs.kaiming_uniform(
&format!("weight_ih_l{}{}", layer_idx, suffix),
&[gate_dim, in_dim],
);
let w_hh = vs.kaiming_uniform(
&format!("weight_hh_l{}{}", layer_idx, suffix),
&[gate_dim, hidden_dim],
);
flat_weights.push(w_ih);
flat_weights.push(w_hh);
if c.has_biases {
let b_ih = vs.zeros(&format!("bias_ih_l{}{}", layer_idx, suffix), &[gate_dim]);
let b_hh = vs.zeros(&format!("bias_hh_l{}{}", layer_idx, suffix), &[gate_dim]);
flat_weights.push(b_ih);
flat_weights.push(b_hh);
}
}
}
if vs.device().is_cuda() && crate::Cuda::cudnn_is_available() {
let _ = Tensor::internal_cudnn_rnn_flatten_weight(
&flat_weights,
4,
in_dim,
3, /* 3 for GRU see rnn.cpp in pytorch */
hidden_dim,
c.num_layers,
c.batch_first,
c.bidirectional,
);
}
GRU {
flat_weights,
hidden_dim,
config: c,
device: vs.device()
```
<Overlap Ratio: 0.9757869249394673>

---

--- 121 --
Question ID: 3bfdcd49f9728d45b839c3c9bfffd7ac8fc962e9_3
Original Code:
```
pub fn rotation_y(radians: f64) -> Matrix4 {
    let mut new_mat = Matrix4::identity();
    new_mat[0][0] = Float(radians.cos());
    new_mat[0][2] = Float(radians.sin());
    new_mat[2][0] = Float(-radians.sin());
    new_mat[2][2] = Float(radians.cos());
    new_mat
}
```


Overlapping Code:
```
ns: f64) -> Matrix4 {
let mut new_mat = Matrix4::identity();
new_mat[0][0] = Float(radians.cos());
new_mat[0][2] = Float(radians.sin());
new_mat[2][0] = Float(-radians.sin());
new_mat[2][2] = Float(radians.cos(
```
<Overlap Ratio: 0.8536585365853658>

---

--- 122 --
Question ID: 3087206e07a80507111e7ffe863394e5cde07c18_2
Original Code:
```
pub(crate) fn preadv2(
    fd: BorrowedFd<'_>,
    bufs: &mut [IoSliceMut<'_>],
    pos: u64,
    flags: ReadWriteFlags,
) -> io::Result<usize> {
    let (bufs_addr, bufs_len) = slice(&bufs[..cmp::min(bufs.len(), max_iov())]);

    #[cfg(target_pointer_width = "32")]
    unsafe {
        ret_usize(syscall6(
            nr(__NR_preadv2),
            borrowed_fd(fd),
            bufs_addr,
            bufs_len,
            hi(pos),
            lo(pos),
            c_uint(flags.bits()),
        ))
    }
    #[cfg(target_pointer_width = "64")]
    unsafe {
        ret_usize(syscall5(
            nr(__NR_preadv2),
            borrowed_fd(fd),
            bufs_addr,
            bufs_len,
            loff_t_from_u64(pos),
            c_uint(flags.bits()),
        ))
    }
}
```


Overlapping Code:
```
ub(crate) fn preadv2(
fd: BorrowedFd<'_>,
bufs: &mut [IoSliceMut<'_>],
pos: u64,
flags: ReadWriteFlags,
) -> io::Result<usize> {
let (bufs_addr, bufs_len) = slice(&bufs[..cmp::min(bufs.len(), max_iov())]);
#[cfg(target_pointer_width = "32")]
unsafe {
ret_usize(syscall6(
nr(__NR_preadv2),
borrowed_fd(fd),
bufs_addr,
bufs_len,
hi(pos),
lo(pos),
c_uint(flags.bits()),
))
}
#[cfg(target_pointer_width = "64")]
unsafe {
ret_usize(syscall5(
nr(__NR_preadv2),
borrowed_fd(fd),
bufs_addr,
bufs_len,
loff_t_from_u64(pos),
c_uint(flags.bits
```
<Overlap Ratio: 0.9779411764705882>

---

--- 123 --
Question ID: c9603396af00fd0155cf24f07311d8da119e1a01_2
Original Code:
```
pub fn debug_game<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {
    let resource: GameStateReference = match args[0].decode() {
        Err(_) => return Ok((error(), bad_reference()).encode(env)),
        Ok(r) => r,
    };

    let game_state = match resource.0.try_lock() {
        Err(_) => return Ok((error(), lock_fail()).encode(env)),
        Ok(guard) => guard,
    };

    Ok((ok(), serde_json::to_string(&*game_state).unwrap()).encode(env))
}
```


Overlapping Code:
```
pub fn debug_game<'a>(env: Env<'a>, args: &[Term<'a>]) -> Result<Term<'a>, Error> {
let resource: GameStateReference = match args[0].decode() {
Err(_) => return Ok((error(), bad_reference()).encode(env)),
Ok(r) => r,
};
let game_state = match resource.0.try_lock() {
Err(_) => return Ok((error(), lock_fail()).encode(env)),
Ok(guard) => guard,
};
Ok((ok(), serde_json::to_string(&*game_state).unwrap(
```
<Overlap Ratio: 0.9592326139088729>

---

--- 124 --
Question ID: fe35eadc50e83f0737806f78602fbd77b0a8e5a3_3
Original Code:
```
async fn presigned_url_is_valid() {
        let aws_credentials = aws_credentials().await;
        let url = generate_presigned_url(&aws_credentials, "foobar", None, None).unwrap();

        // We try to make the call to the pre-signed URL and it should succeed with 200
        let client = reqwest::Client::new();
        let response = client
            .get(&url)
            .header("x-k8s-aws-id", "foobar")
            .send()
            .await
            .unwrap();
        assert!(response.status().is_success());
    }
```


Overlapping Code:
```
et aws_credentials = aws_credentials().await;
let url = generate_presigned_url(&aws_credentials, "foobar", None, None).unwrap();
// We try to make the call to the pre-signed URL and it should succeed with 200
let client = reqwest::Client::new();
let response = client
.get(&url)
.header("x-k8s-aws-id", "foobar")
.send()
.await
.unwrap();
assert!(response.status().is_success());
}
```
<Overlap Ratio: 0.9114832535885168>

---

--- 125 --
Question ID: 3abc27595315290123361fc74b3923d80d4cc5f7_1
Original Code:
```
fn rom_bank_switching_zero() {
        let mut mbc = MBC5::new(&[]);
        mbc.write_rom(0x2000, 0);
        assert_eq!(mbc.rom_bank(), 0);
    }
```


Overlapping Code:
```
switching_zero() {
let mut mbc = MBC5::new(&[]);
mbc.write_rom(0x2000, 0);
assert_eq!(mbc.rom_bank()
```
<Overlap Ratio: 0.8403361344537815>

---

--- 126 --
Question ID: 0e89c1b2d1c5e343ab62fa81c01e1dcb7ccb7918_5
Original Code:
```
fn test_run_ldx_imm() {
    let mut b = MockBus::new();
    let mut r = Register::new();
    r.set_PC(0x80);
    b.memory[0x80] = 0xA2;
    b.memory[0x81] = 0xFF;
    run(&mut r ,&mut b, &mut false);
    assert_eq!(r.get_X(), 0xFF)
  }
```


Overlapping Code:
```
n_ldx_imm() {
let mut b = MockBus::new();
let mut r = Register::new();
r.set_PC(0x80);
b.memory[0x80] = 0xA2;
b.memory[0x81] = 0xFF;
run(&mut r ,&mut b, &mut false);
assert_eq!(r.get_
```
<Overlap Ratio: 0.8926829268292683>

---

--- 127 --
Question ID: 14c0b56b1253a93b9b138316f07553e5dd34580d_0
Original Code:
```
pub fn test_with_data(attr: TokenStream, item: TokenStream) -> TokenStream {
    let function = syn::parse_macro_input!(item as ItemFn);
    let source = syn::parse_macro_input!(attr as Expr);
    test_with_data_impl(function, &source).into()
}
```


Overlapping Code:
```
(attr: TokenStream, item: TokenStream) -> TokenStream {
let function = syn::parse_macro_input!(item as ItemFn);
let source = syn::parse_macro_input!(attr as Expr);
test_wit
```
<Overlap Ratio: 0.7413793103448276>

---

--- 128 --
Question ID: 127e757263ba1bc29f653736130c32acc1767e8f_3
Original Code:
```
fn start_send_past_cap() {
    let mut t1 = task::spawn(());
    let mut t2 = task::spawn(());
    let mut t3 = task::spawn(());

    let (mut tx1, mut rx) = mpsc::channel(1);
    let mut tx2 = tx1.clone();

    assert_ok!(tx1.try_send(()));

    t1.enter(|cx, _| {
        assert_pending!(tx1.poll_ready(cx));
    });

    t2.enter(|cx, _| {
        assert_pending!(tx2.poll_ready(cx));
    });

    drop(tx1);

    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));
    assert!(val.is_some());

    assert!(t2.is_woken());
    assert!(!t1.is_woken());

    drop(tx2);

    let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));
    assert!(val.is_none());
}
```


Overlapping Code:
```
() {
let mut t1 = task::spawn(());
let mut t2 = task::spawn(());
let mut t3 = task::spawn(());
let (mut tx1, mut rx) = mpsc::channel(1);
let mut tx2 = tx1.clone();
assert_ok!(tx1.try_send(()));
t1.enter(|cx, _| {
assert_pending!(tx1.poll_ready(cx));
});
t2.enter(|cx, _| {
assert_pending!(tx2.poll_ready(cx));
});
drop(tx1);
let val = t3.enter(|cx, _| assert_ready!(rx.poll_recv(cx)));
assert!(val.is_some());
assert!(t2.is_woken());
assert!(!t1.is_woken());
drop(tx2);
let val = t3.enter(|cx, _| assert_ready!(rx.poll
```
<Overlap Ratio: 0.8961937716262975>

---

--- 129 --
Question ID: cb54cbbdf614ba38d218811de5528a5f00b5179b_0
Original Code:
```
fn test_angular_converter_from_dms_to_radian() {
        let conv = AngularConverter::new(187.625, AngularUnit::DMS);
        let res = conv.convert(AngularUnit::Radian);

        assert!(res.is_ok());
        let res = res.unwrap();
        assert!(is_close(3.274_674, res.scalar()));
        assert_eq!(&AngularUnit::Radian, res.unit());
    }
```


Overlapping Code:
```
n test_angular_converter_from_dms_to_radian() {
let conv = AngularConverter::new(187.625, AngularUnit::DMS);
let res = conv.convert(AngularUnit::Radian);
assert!(res.is_ok());
let res = res.unwrap();
assert!(is_close(3.274_674, res.scalar()));
assert
```
<Overlap Ratio: 0.8561643835616438>

---

--- 130 --
Question ID: beb69f9080d408564948685850a6a8d0ac107ee1_6
Original Code:
```
fn prefs_messaging() {
        let pants = build_pants();

        match tokio_test::block_on(pants.prefs_messaging()) {
            Ok(response) => println!("Response to prefs_messaging is: {:#?}", response),
            Err(e) => panic!("An error ocurred: {}", e),
        };
    }
```


Overlapping Code:
```
s_messaging() {
let pants = build_pants();
match tokio_test::block_on(pants.prefs_messaging()) {
Ok(response) => println!("Response to prefs_messaging is: {:#?}", response),
Err(e) => panic!("An error ocurred: {}", e),
};

```
<Overlap Ratio: 0.9652173913043478>

---

--- 131 --
Question ID: f3b29f7af5592a86eb8162081a5ed8cc14da1f3e_42
Original Code:
```
pub async fn delete(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        network_manager_name: &str,
        configuration_name: &str,
        rule_collection_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Network/networkManagers/{}/securityUserConfigurations/{}/ruleCollections/{}" , operation_config . base_path () , subscription_id , resource_group_name , network_manager_name , configuration_name , rule_collection_name) ;
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn delete(
operation_config: &crate::OperationConfig,
subscription_id: &str,
resource_group_name: &str,
network_manager_name: &str,
configuration_name: &str,
rule_collection_name: &str,
) -> std::result::Result<delete::Response, delete::Error> {
let http_client = operation_config.http_client();
let url_str = & format ! ("{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Network/networkManagers/{}/securityUserConfigurations/{}/ruleCollections/{}" , operation_config . base_path () , subscription_id , resource_group_name , network_manager_name , configuration_name , rule_collection_name) ;
let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::DELETE);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(delete::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => Ok(delete::Response::Ok200),
http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::CloudError =
serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
Err(delete::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 132 --
Question ID: f4f2bdee3209a0fbbf373c53ad5ea7497c0b3882_6
Original Code:
```
pub fn setup_client(uri: &MobilecoindUri, logger: &Logger) -> MobilecoindApiClient {
    let env = Arc::new(
        EnvBuilder::new()
            .name_prefix("gRPC-mobilecoind-tests")
            .build(),
    );
    let ch = ChannelBuilder::new(env).connect_to_uri(uri, logger);
    MobilecoindApiClient::new(ch)
}
```


Overlapping Code:
```
 logger: &Logger) -> MobilecoindApiClient {
let env = Arc::new(
EnvBuilder::new()
.name_prefix("gRPC-mobilecoind-tests")
.build(),
);
let ch = ChannelBuilder::new(env).connect_to_uri(uri, logger);
Mob
```
<Overlap Ratio: 0.7434944237918215>

---

--- 133 --
Question ID: d1690e4a393b78e39d79bd99061eab7595c2d2ec_167
Original Code:
```
fn integer_float_greater_than_other() {
        let mut instructions = InstructionSetBuilder::new();
        instructions.start_expression("main");

        instructions.put(ExpressionValue::integer(20)).unwrap();
        instructions.put(ExpressionValue::float(10.0)).unwrap();
        instructions.perform_greater_than_or_equal_comparison();

        instructions.end_expression();

        let mut expression_runtime = ExpressionRuntime::new(&instructions);

        let result = expression_runtime.execute("main").unwrap();

        assert_eq!(result.as_symbol().unwrap(), expression_runtime.true_value);
    }
```


Overlapping Code:
```
ger_float_greater_than_other() {
let mut instructions = InstructionSetBuilder::new();
instructions.start_expression("main");
instructions.put(ExpressionValue::integer(20)).unwrap();
instructions.put(ExpressionValue::float(10.0)).unwrap();
instructions.perform_greater_than_or_equal_comparison();
instructions.end_expression();
let mut expression_runtime = ExpressionRuntime::new(&instructions);
let result = expression_runtime.execute("main").unwrap();
assert_eq!(result.as_symbol().unwrap(), expression_runtime.true_value);
}
```
<Overlap Ratio: 0.9868667917448405>

---

--- 134 --
Question ID: 4d4debbb8219d618ce0dad2dfac8439d6f6e6dc7_28
Original Code:
```
fn get_sr_paths(target_dir: &Path) -> Vec<PathBuf> {
    let mut sr_paths = Vec::new();

    let walker = globwalk::GlobWalkerBuilder::from_patterns(target_dir, &[".sr"])
        .max_depth(100)
        .follow_links(false)
        .sort_by(path_cmp)
        .build()
        .expect("Could not build globwalk directory walker.")
        .into_iter()
        .filter_map(Result::ok);

    for sr_file in walker {
        sr_paths.push(sr_file.path().to_path_buf());
    }

    sr_paths
}
```


Overlapping Code:
```
fn get_sr_paths(target_dir: &Path) -> Vec<PathBuf> {
let mut sr_paths = Vec::new();
let walker = globwalk::GlobWalkerBuilder::from_patterns(target_dir, &[".sr"])
.max_depth(100)
.follow_links(false)
.sort_by(path_cmp)
.build()
.expect("Could not build globwalk directory walker.")
.into_iter()
.filter_map(Result::ok);
for sr_file in walker {
sr_paths.push(sr_file.path().to_path_buf());
}
sr_paths
}
```
<Overlap Ratio: 1.0>

---

--- 135 --
Question ID: 82070af704513251627f4b5ee54d804f155f7d4d_0
Original Code:
```
fn main() {
    println!("Enter the chars you want to have at the beginning of the address and the amount of addresses you want to generate, in millions");
    println!("For example write \"Test 3\" to search for an address that has the chars from \"Test\" at the beginning and generate 3 million addresses to find such an address");
    println!(
        "Upper and lower case is ignored, output will look like this if an address was found:"
    );
    println!("Found address TesTsEhMde7MmxvZxch9kWJgVtsrnL4ua4qoexAe51gi with seed FYrwHApFHSXMeuR6bovqomGgfrvtLmb7NtR62qfnRfSd");

    let user_input = get_user_input();
    println!(
        "Searching for {} in {} million addresses...",
        user_input[0], user_input[1]
    );
    println!("Abort with Ctrl+C");

    let time_start = Instant::now();
    let threads = 8;
    let total_addresses = user_input[1].parse::<usize>().unwrap() * 1000000;
    let amount = total_addresses / threads;

    let beginning = user_input[0].to_ascii_uppercase();
    let arc_beginning = std::sync::Arc::new(beginning);

    let mut pool = vec![];
    for _ in 0..threads {
        let s = arc_beginning.clone();
        pool.push(thread::spawn(move || find_address(s, amount)));
    }
    for worker in pool {
        worker.join().unwrap();
    }
    println!("Done after {:.2?}", time_start.elapsed());
}
```


Overlapping Code:
```
 chars you want to have at the beginning of the address and the amount of addresses you want to generate, in millions");
println!("For example write \"Test 3\" to search for an address that has the chars from \"Test\" at the beginning and generate 3 million addresses to find such an address");
println!(
"Upper and lower case is ignored, output will look like this if an address was found:"
);
println!("Found address TesTsEhMde7MmxvZxch9kWJgVtsrnL4ua4qoexAe51gi with seed FYrwHApFHSXMeuR6bovqomGgfrvtLmb7NtR62qfnRfSd");
let user_input = get_user_input();
println!(
"Searching for {} in {} million addresses...",
user_input[0], user_input[1]
);
println!("Abort with Ctrl+C");
let time_start = Instant::now();
let threads = 8;
let total_addresses = user_input[1].parse::<usize>().unwrap() * 1000000;
let amount = total_addresses / threads;
let beginning = user_input[0].to_ascii_uppercase();
let arc_beginning = std::sync::Arc::new(beginning);
let mut pool = vec![];
for _ in 0..threads {
let s = arc_beginning.clone();
pool.push(thread::spawn(move || find_address(s, amount)));
}
for worker in pool {
worker.join().unwrap();
}
println!("Done after {
```
<Overlap Ratio: 0.9480626545754328>

---

--- 136 --
Question ID: c22f47f48cb8222fd049be9f83196b0bea3aed08_2
Original Code:
```
fn clear_components(&mut self) -> result::Result<(), ClearComponentsError> {
        let mut err = ClearComponentsError::new();
        for type_id in self.components_attached().iter() {
            if let Err(e) = self
                .component_manager()
                .delete_component_by_id(&self, type_id)
            {
                err.push(e);
            }
        }

        self.components_attached_mut().clear();

        if err.len() > 0 {
            Err(err)
        } else {
            Ok(())
        }
    }
```


Overlapping Code:
```
sult::Result<(), ClearComponentsError> {
let mut err = ClearComponentsError::new();
for type_id in self.components_attached().iter() {
if let Err(e) = self
.component_manager()
.delete_component_by_id(&self, type_id)
{
err.push(e);
}
}
self.components_attached_mut().clear();
if err.len() > 0 {
Err(e
```
<Overlap Ratio: 0.8356545961002786>

---

--- 137 --
Question ID: 435e4f4feb6a349eda4478dc1f78333e18e5fbb3_3
Original Code:
```
fn get_gradiants(blurred : &GrayImage, data : Arc<GrayImage>) -> Vec<(f64, f64)> {
    let dims = blurred.dimensions();
    let mut pool = simple_parallel::Pool::new(NUM_THREADS);
    let dims = (dims.0 as usize , dims.1 as usize);
    let CHUNK_SIZE = dims.0 * dims.1/ NUM_THREADS;
    scope(|scope|{
        pool.map(scope, blurred.chunks(CHUNK_SIZE).enumerate().zip(rpt(data)), |((thread_num, chunk), data)|{
            chunk.into_iter().enumerate().map(|(i, _)|{
                let x : i64 = ((CHUNK_SIZE * thread_num + i) % dims.0 ) as i64;
                let y : i64 = ((CHUNK_SIZE * thread_num + i) / dims.0 ) as i64;
                let mut gx = 0f64;
                let mut gy = 0f64;
                for c in -1..2 {
                    for r in -1..2 {
                        let (x, y) = (x + c, y + r);
                        if (x > 0) && (x < dims.0 as i64) && (y > 0) && (y < dims.1 as i64) {
                            let r = (r + 1) as usize;
                            let c = (c + 1) as usize;
                            let GX_FACTOR = GX[r][c];
                            let GY_FACTOR = GY[r][c];
                            let p = data[(x as u32, y as u32)];
                            gx = gx + GX_FACTOR * p[0] as f64;
                            gy = gy + GY_FACTOR * p[0] as f64;
                        }
                    }
                }

                let g = util::gradiant(gx,gy);
                let angle = (gy).atan2(gx).to_degrees() + 180.0;
                if util::round_angle(angle).is_nan() {
                    println!("{}, {} -> {}", gy, gx, util::round_angle(angle));
                }
                (g, util::round_angle(angle))
            }).collect::<Vec<(f64, f64)>>()
        }).flat_map(|x| x.into_iter()).collect()
    })
}
```


Overlapping Code:
```
get_gradiants(blurred : &GrayImage, data : Arc<GrayImage>) -> Vec<(f64, f64)> {
let dims = blurred.dimensions();
let mut pool = simple_parallel::Pool::new(NUM_THREADS);
let dims = (dims.0 as usize , dims.1 as usize);
let CHUNK_SIZE = dims.0 * dims.1/ NUM_THREADS;
scope(|scope|{
pool.map(scope, blurred.chunks(CHUNK_SIZE).enumerate().zip(rpt(data)), |((thread_num, chunk), data)|{
chunk.into_iter().enumerate().map(|(i, _)|{
let x : i64 = ((CHUNK_SIZE * thread_num + i) % dims.0 ) as i64;
let y : i64 = ((CHUNK_SIZE * thread_num + i) / dims.0 ) as i64;
let mut gx = 0f64;
let mut gy = 0f64;
for c in -1..2 {
for r in -1..2 {
let (x, y) = (x + c, y + r);
if (x > 0) && (x < dims.0 as i64) && (y > 0) && (y < dims.1 as i64) {
let r = (r + 1) as usize;
let c = (c + 1) as usize;
let GX_FACTOR = GX[r][c];
let GY_FACTOR = GY[r][c];
let p = data[(x as u32, y as u32)];
gx = gx + GX_FACTOR * p[0] as f64;
gy = gy + GY_FACTOR * p[0] as f64;
}
}
}
let g = util::gradiant(gx,gy);
let angle = (gy).atan2(gx).to_degrees() + 180.0;
if util::round_angle(angle).is_nan() {
println!("{}, {} -> {}", gy, gx, util::round_angle(angle));
}
(g, util::round_angle(angle))
}).collect::<Vec<(f64, f64)>>()
}).flat_map(|x| x
```
<Overlap Ratio: 0.974817221770918>

---

--- 138 --
Question ID: e6354108f1a5237cf4e7de0edc49ee39e922dbb1_0
Original Code:
```
pub fn get_source_walker(config: &Config) -> impl Iterator<Item = DirEntry> {
    let root = config.root();
    let target = config.target_dir();

    let walker = WalkDir::new(&root).into_iter();
    walker
        .filter_entry(move |e| is_coverable_file_path(e.path(), &root, &target))
        .filter_map(|e| e.ok())
        .filter(|e| is_source_file(e))
}
```


Overlapping Code:
```
 fn get_source_walker(config: &Config) -> impl Iterator<Item = DirEntry> {
let root = config.root();
let target = config.target_dir();
let walker = WalkDir::new(&root).into_iter();
walker
.filter_entry(move |e| is_coverable_file_path(e.path(), &root, &target))
.filter_map(|e| e.ok())
.filter(|e| is_
```
<Overlap Ratio: 0.9375>

---

--- 139 --
Question ID: 6c04827b6e07d59df5ffb7cf16bbc97e1dbb54ba_0
Original Code:
```
fn main() {
    let input = 939601;
    let mut board = vec![3, 7];
    let mut elfo = 0;
    let mut twinkels = 1;

    let mut score;
    let mut print_count = 10;

    for _ in 0..input + 10 {
        score = board[elfo] + board[twinkels];

        let mut digits = vec![];
        if score >= 10 {
            digits.push(score / 10);
            score %= 10;
        }
        digits.push(score);

        for digit in digits {
            board.push(digit);
            if board.len() > input {
                print_count -= 1;
                print!("{}", board[board.len() - 1]);
                if print_count == 0 {
                    break;
                }
            }
        }

        if board.len() > input {
            print_count -= 1;
            print!("{}", board[board.len() - 1]);
            if print_count == 0 {
                break;
            }
        }

        elfo = (elfo + board[elfo] + 1) % board.len();
        twinkels = (twinkels + board[twinkels] + 1) % board.len();
    }
}
```


Overlapping Code:
```
fn main() {
let input = 939601;
let mut board = vec![3, 7];
let mut elfo = 0;
let mut twinkels = 1;
let mut score;
let mut print_count = 10;
for _ in 0..input + 10 {
score = board[elfo] + board[twinkels];
let mut digits = vec![];
if score >= 10 {
digits.push(score / 10);
score %= 10;
}
digits.push(score);
for digit in digits {
board.push(digit);
if board.len() > input {
print_count -= 1;
print!("{}", board[board.len() - 1]);
if print_count == 0 {
break;
}
}
}
if board.len() > input {
print_count -= 1;
print!("{}", board[board.len() - 1]);
if print_count == 0 {
break;
}
}
elfo = (elfo + board[elfo] + 1) % board.len();
twinkels = (twinkels + bo
```
<Overlap Ratio: 0.9461426491994177>

---

--- 140 --
Question ID: 2d76a0f507fb07674d7b808d897fa38cd3734408_1
Original Code:
```
fn encrypt_always_returns_constant_length_byte_array_for_4_byte_input_with_authenticated_encryption(
        ) {
            let (_, sk1) = gen_encrypt_keypair();
            let (pk2, _) = gen_encrypt_keypair();
            let enc_ctx = EncryptContext::authenticated(sk1.shared_secret(&pk2));

            for size in &[0u32, 25000, DEFAULT_MAX_PAYLOAD_SIZE as u32, MAX_U32] {
                let encrypted = unwrap!(enc_ctx.encrypt(&size));
                assert_that!(&encrypted, len(ENCRYPTED_U32_LEN));
            }
        }
```


Overlapping Code:
```
t_always_returns_constant_length_byte_array_for_4_byte_input_with_authenticated_encryption(
) {
let (_, sk1) = gen_encrypt_keypair();
let (pk2, _) = gen_encrypt_keypair();
let enc_ctx = EncryptContext::authenticated(sk1.shared_secret(&pk2));
for size in &[0u32, 25000, DEFAULT_MAX_PAYLOAD_SIZE as u32, MAX_U32] {
let encrypted = unwrap!(enc_ctx.encrypt(&size));
assert_that!(&encrypted, len(ENCRYPTED_U32_LEN)
```
<Overlap Ratio: 0.964622641509434>

---

--- 141 --
Question ID: 5492ce4ad7930821249d1f335880ca34bf0881d1_4
Original Code:
```
pub fn validate_port(input: String) -> bool {
    // Check for digits
    lazy_static! {
        static ref RE_IP: Regex = Regex::new(r"^(\d*)$").unwrap();
    }
    // Shortes "0" = 1, longest "65534" =
    if input.is_empty() || input.len() > 5 {
        log("Port length invalid".to_string(), LOG_STDERR);
        return false;
    }
    //Check regex
    if RE_IP.is_match(&input) {
        // Parse if only digits
        let value: i32 = input.parse().unwrap();
        // Check range from 0 to 65534
        value < 65535 && value > 0
    } else {
        false
    }
}
```


Overlapping Code:
```
g) -> bool {
// Check for digits
lazy_static! {
static ref RE_IP: Regex = Regex::new(r"^(\d*)$").unwrap();
}
// Shortes "0" = 1, longest "65534" =
if input.is_empty() || input.len() > 5 {
log("Port length invalid".to_string(), LOG_STDERR);
return false;
}
//Check regex
if RE_IP.is_match(&input) {
// Parse if only digits
let value: i32 = input.parse().unwrap();
// Check range from 0 to 65534
value 
```
<Overlap Ratio: 0.847457627118644>

---

--- 142 --
Question ID: 9af7d4769d7c68e805ac826101567da7e99b3c17_10
Original Code:
```
fn convert_tracker_mode(
    rawkeys: &HashMap<String, Vec<u8>>,
    label: &str,
) -> Result<TrackerOperationMode, VEError> {
    let raw = rawkeys
        .get(label)
        .ok_or_else(|| VEError::MissingField(label.into()))?;
    let cleaned = from_utf8(raw)
        .map_err(|e| VEError::Parse(format!("Failed to parse {} from {:?} - {}", label, &raw, e)))?
        .parse::<usize>()?;
    Ok(TrackerOperationMode::from_repr(cleaned).unwrap_or(TrackerOperationMode::Off))
}
```


Overlapping Code:
```
(
rawkeys: &HashMap<String, Vec<u8>>,
label: &str,
) -> Result<TrackerOperationMode, VEError> {
let raw = rawkeys
.get(label)
.ok_or_else(|| VEError::MissingField(label.into()))?;
let cleaned = from_utf8(raw)
.map_err(|e| VEError::Parse(format!("Failed to parse {} from {:?} - {}", label, &raw, e)))?
.parse::<usize>()?;
Ok(TrackerOperationMode::from_repr(cleaned).unwrap_or(TrackerOperationMode::Off
```
<Overlap Ratio: 0.936768149882904>

---

--- 143 --
Question ID: b736d88346fa2c54323eb41b0316cdb5f4af0069_0
Original Code:
```
fn main() {
    let on_lock = |ready: bool| {
        if !ready {
            println!("waiting for apt and dpkg lock to be available")
        }
    };

    let on_ready = || println!("Now ready to use apt");
    wait_for_apt_locks(3000, on_lock, on_ready);
}
```


Overlapping Code:
```
 |ready: bool| {
if !ready {
println!("waiting for apt and dpkg lock to be available")
}
};
let on_ready = || println!("Now ready to use apt");
wait_f
```
<Overlap Ratio: 0.6976744186046512>

---

--- 144 --
Question ID: 2a0795c121d8c9a18f56c74abd8b7ef5a982cf3c_0
Original Code:
```
fn test_json_options() {
        {
            let json_options: JsonObjectOptions = (STORED | TEXT).into();
            assert!(json_options.is_stored());
            assert!(json_options.is_indexed());
        }
        {
            let json_options: JsonObjectOptions = TEXT.into();
            assert!(!json_options.is_stored());
            assert!(json_options.is_indexed());
        }
        {
            let json_options: JsonObjectOptions = STORED.into();
            assert!(json_options.is_stored());
            assert!(!json_options.is_indexed());
        }
    }
```


Overlapping Code:
```
options() {
{
let json_options: JsonObjectOptions = (STORED | TEXT).into();
assert!(json_options.is_stored());
assert!(json_options.is_indexed());
}
{
let json_options: JsonObjectOptions = TEXT.into();
assert!(!json_options.is_stored());
assert!(json_options.is_indexed());
}
{
let json_options: JsonObjectOptions = STORED.into();
assert!(json_options.is_stored());
assert!(!json_options.is_indexed());
}
}
```
<Overlap Ratio: 0.9689737470167065>

---

--- 145 --
Question ID: 4bc307d018ac0d8c8acb83eeb8239039239cdee7_41
Original Code:
```
fn error_overflow_subtraction_signed_negative() {
    let input = r#"
fn main() {
    let value = -42 - 100 as i8;
}
"#;

    let expected = Err(Error::Semantic(SemanticError::Element(
        ElementError::Constant(ConstantError::Integer(
            IntegerConstantError::OverflowSubtraction {
                location: Location::test(3, 18),
                value: BigInt::from(-142),
                r#type: Type::integer(Some(Location::default()), true, zinc_const::bitlength::BYTE)
                    .to_string(),
            },
        )),
    )));

    let result = crate::semantic::tests::compile_entry(input);

    assert_eq!(result, expected);
}
```


Overlapping Code:
```
ow_subtraction_signed_negative() {
let input = r#"
fn main() {
let value = -42 - 100 as i8;
}
"#;
let expected = Err(Error::Semantic(SemanticError::Element(
ElementError::Constant(ConstantError::Integer(
IntegerConstantError::OverflowSubtraction {
location: Location::test(3, 18),
value: BigInt::from(-142),
r#type: Type::integer(Some(Location::default()), true, zinc_const::bitlength::BYTE)
.to_string(),
},
)),
)));
let result = crate::semantic::tests::compile_entry(input);
assert_eq!(result, expected);
}
```
<Overlap Ratio: 0.97131931166348>

---

--- 146 --
Question ID: b9ff2cf5e460e2568ada2a3711a22814d685b671_20
Original Code:
```
pub fn draw_shaded_circle() {
    let canvas_pixels = 500;

    let mut shape_list = ShapeList::new();

    let mut material = Material::new();
    material.color = Color::from_hex("19647E");
    let shape = Sphere::new_with_material(material, &mut shape_list);

    let light = Light::point_light(&point(-10.0, 10.0, -10.0), &Color::new(1.0, 1.0, 1.0));

    let wall_z = 10.0;
    let wall_size = 7.0;

    let pixel_size = wall_size / canvas_pixels as f64;
    let half = wall_size / 2.0;

    let ray_origin = point(0.0, 0.0, -5.0);
    let canvas = &mut Canvas::new(canvas_pixels, canvas_pixels);

    // Each row of pixels
    for y in 0..canvas_pixels {
        // World y coordinate top = +half and bottom = -half
        let world_y = half - pixel_size * y as f64;

        // Each col of pixels
        for x in 0..canvas_pixels {
            // World x coordinate left = -half and right = +half
            let world_x = -half + pixel_size * x as f64;

            // the point on the wall that the ray will target
            let position = point(world_x, world_y, wall_z);

            let ray = Ray::new(ray_origin, (position - ray_origin).normalize());
            let xs = shape.intersects(&ray, &mut shape_list);
            let hit = hit(xs);
            if hit != None {
                let point = &ray.position(hit.as_ref().unwrap().t.value());
                let normal = shape::normal_at(hit.as_ref().unwrap().object.clone(), *point, &mut shape_list);
                let eye = -&ray.direction;
                let object = hit.as_ref().unwrap().object.clone();

                let color = Light::lighting(&object.material(), Some(object), None, &light, point, None, &eye, &normal, false, None);
                canvas.write_pixel(x, y, &color);
            }
        }
    }
    file::write_to_file(canvas.to_ppm(), String::from("shaded_circle.ppm"))
}
```


Overlapping Code:
```
xels = 500;
let mut shape_list = ShapeList::new();
let mut material = Material::new();
material.color = Color::from_hex("19647E");
let shape = Sphere::new_with_material(material, &mut shape_list);
let light = Light::point_light(&point(-10.0, 10.0, -10.0), &Color::new(1.0, 1.0, 1.0));
let wall_z = 10.0;
let wall_size = 7.0;
let pixel_size = wall_size / canvas_pixels as f64;
let half = wall_size / 2.0;
let ray_origin = point(0.0, 0.0, -5.0);
let canvas = &mut Canvas::new(canvas_pixels, canvas_pixels);
// Each row of pixels
for y in 0..canvas_pixels {
// World y coordinate top = +half and bottom = -half
let world_y = half - pixel_size * y as f64;
// Each col of pixels
for x in 0..canvas_pixels {
// World x coordinate left = -half and right = +half
let world_x = -half + pixel_size * x as f64;
// the point on the wall that the ray will target
let position = point(world_x, world_y, wall_z);
let ray = Ray::new(ray_origin, (position - ray_origin).normalize());
let xs = shape.intersects(&ray, &mut shape_list);
let hit = hit(xs);
if hit != None {
let point = &ray.position(hit.as_ref().unwrap().t.value());
let normal = shape::normal_at(hit.as_ref().unwrap().object.clone(), *point, &mut shape_list);
let eye = -&ray.direction;
let object = hit.as_ref().unwrap().object.clone();
let color = Light::lighting(&object.material(), Some(object), None, &light, point, None, &eye, &normal, false, None);
canvas.write_pixel(x, y, &color);
}
}
}
file::write_to_file(canvas.to_ppm(), String::from("shaded
```
<Overlap Ratio: 0.9621552277100706>

---

--- 147 --
Question ID: cfaa057bd35dba2c18daa5014834a8d12586166a_3
Original Code:
```
fn should_return_ok_of_none_when_block_results_has_no_account_event() {
            let block_results = BlockResults {
                height: Height::default().increment(),
                results: Results {
                    deliver_tx: Some(vec![DeliverTx {
                        events: vec![Event {
                            event_type: TendermintEventType::ValidTransactions.to_string(),
                            attributes: vec![Attribute {
                                key: TendermintEventKey::TxId.to_base64_string(),
                                value: "MDc2NmQ0ZTFjMDkxMjRhZjlhZWI0YTdlZDk5ZDgxNjU0YTg0NDczZjEzMzk0OGNlYTA1MGRhYTE3ZmYwZTdmZg==".to_owned(),
                            }],
                        }],
                    }]),
                    end_block: None,
                },
            };

            let target_account = StakedStateAddress::from(
                RedeemAddress::from_str("0x0e7c045110b8dbf29765047380898919c5cb56f4").unwrap(),
            );
            let result = block_results.contains_account(&target_account);
            assert!(result.is_ok());
            assert_eq!(false, result.unwrap());
        }
```


Overlapping Code:
```
ok_of_none_when_block_results_has_no_account_event() {
let block_results = BlockResults {
height: Height::default().increment(),
results: Results {
deliver_tx: Some(vec![DeliverTx {
events: vec![Event {
event_type: TendermintEventType::ValidTransactions.to_string(),
attributes: vec![Attribute {
key: TendermintEventKey::TxId.to_base64_string(),
value: "MDc2NmQ0ZTFjMDkxMjRhZjlhZWI0YTdlZDk5ZDgxNjU0YTg0NDczZjEzMzk0OGNlYTA1MGRhYTE3ZmYwZTdmZg==".to_owned(),
}],
}],
}]),
end_block: None,
},
};
let target_account = StakedStateAddress::from(
RedeemAddress::from_str("0x0e7c045110b8dbf29765047380898919c5cb56f4").unwrap(),
);
let result = block_results.contains_account(&target_account);
assert!(result.is_ok());
assert_eq!(false, result.unwrap()
```
<Overlap Ratio: 0.9724770642201835>

---

--- 148 --
Question ID: 715abef18639025ecc91ad4eef818720c9f862e7_2
Original Code:
```
fn test_valid_password() {
        assert_eq!(Some("abcde"), valid_password_old_policy(1, 3, 'a', "abcde"));
        assert_eq!(None, valid_password_old_policy(1, 3, 'b', "cdefg"));
        assert_eq!(Some("ccccccccc"), valid_password_old_policy(2, 9, 'c', "ccccccccc"));
    }
```


Overlapping Code:
```
sert_eq!(None, valid_password_old_policy(1, 3, 'b'
```
<Overlap Ratio: 0.20080321285140562>

---

--- 149 --
Question ID: 4fb08bb8f5eeb5cdb8e1e954d4f82ebaa9179e58_0
Original Code:
```
fn mac_to_u64(mac: &MacAddress) -> Result<u64, Error> {
    let mac_bytes = mac.as_bytes();

    let padded = vec![
        0,
        0,
        mac_bytes[0],
        mac_bytes[1],
        mac_bytes[2],
        mac_bytes[3],
        mac_bytes[4],
        mac_bytes[5],
    ];

    let mut padded_mac = &padded[..8];
    let mac_num = padded_mac.read_u64::<NetworkEndian>().context(format!(
        "could not read_u64 from padded MAC byte array: {:?}",
        padded_mac
    ))?;
    Ok(mac_num)
}
```


Overlapping Code:
```
mac: &MacAddress) -> Result<u64, Error> {
let mac_bytes = mac.as_bytes();
let padded = vec![
0,
0,
mac_bytes[0],
mac_bytes[1],
mac_bytes[2],
mac_bytes[3],
mac_bytes[4],
mac_bytes[5],
];
let mut padded_mac = &padded[..8];
let mac_num = padded_mac.read_u64::<NetworkEndian>().context(format!(
"could not read_u64 from padded MAC byte array: {:?}",
padd
```
<Overlap Ratio: 0.8997429305912596>

---

--- 150 --
Question ID: b19658b8e0f532901ab2a663ce3826d0ede3475a_3
Original Code:
```
fn handle_large_slice() {
        let stadium = Stadium::with_capacity(NonZeroUsize::new(10).unwrap());

        let slice: &[u64] = &[1000; 100];
        let big_slice = stadium.store_slice(slice);

        assert_eq!(&*big_slice, slice);
    }
```


Overlapping Code:
```
ium = Stadium::with_capacity(NonZeroUsize::new(10).unwrap());
let slice: &[u64] = &[1000; 100];
let big_slice = stadium.store_slice(slice);
assert_eq!(&*big_slice, 
```
<Overlap Ratio: 0.7922705314009661>

---

--- 151 --
Question ID: 02704e40c6a83ae2cae2f20eeca4199dda28e947_0
Original Code:
```
fn ignite_client_start_with_config() {
    setup();

    let mut cfg = ClientConfiguration::new();
    cfg.set_endpoints("127.0.0.1:10800").unwrap();

    run_async(
        async {
            let mut node = start_test_node("default.xml").await.unwrap();

            IgniteClient::start(cfg).await.unwrap();

            node.stop().unwrap();
        },
    );
}
```


Overlapping Code:
```
() {
setup();
let mut cfg = ClientConfiguration::new();
cfg.set_endpoints("127.0.0.1:10800").unwrap();
run_async(
async {
let mut node = start_test_node("default.xml").await.unwrap();
IgniteClient::start(cfg).await.unwrap();
node.stop().unwrap();
},

```
<Overlap Ratio: 0.8680555555555556>

---

--- 152 --
Question ID: d9ee3bc90fb8c60e7053fba4d19d4490501bcd5e_0
Original Code:
```
fn install_sh(
    builder: &Builder<'_>,
    package: &str,
    name: &str,
    stage: u32,
    host: Option<TargetSelection>,
) {
    builder.info(&format!("Install {} stage{} ({:?})", package, stage, host));

    let prefix_default = PathBuf::from("/usr/local");
    let sysconfdir_default = PathBuf::from("/etc");
    let datadir_default = PathBuf::from("share");
    let docdir_default = datadir_default.join("doc/rust");
    let libdir_default = PathBuf::from("lib");
    let mandir_default = datadir_default.join("man");
    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {
        fs::create_dir_all(p)
            .unwrap_or_else(|err| panic!("could not create {}: {}", p.display(), err));
        fs::canonicalize(p)
            .unwrap_or_else(|err| panic!("could not canonicalize {}: {}", p.display(), err))
    });
    let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);
    let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);
    let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);
    let bindir = &builder.config.bindir;
    let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);
    let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);

    let sysconfdir = prefix.join(sysconfdir);
    let datadir = prefix.join(datadir);
    let docdir = prefix.join(docdir);
    let bindir = prefix.join(bindir);
    let libdir = prefix.join(libdir);
    let mandir = prefix.join(mandir);

    let destdir = env::var_os("DESTDIR").map(PathBuf::from);

    let prefix = add_destdir(&prefix, &destdir);
    let sysconfdir = add_destdir(&sysconfdir, &destdir);
    let datadir = add_destdir(&datadir, &destdir);
    let docdir = add_destdir(&docdir, &destdir);
    let bindir = add_destdir(&bindir, &destdir);
    let libdir = add_destdir(&libdir, &destdir);
    let mandir = add_destdir(&mandir, &destdir);

    let empty_dir = builder.out.join("tmp/empty_dir");

    t!(fs::create_dir_all(&empty_dir));
    let package_name = if let Some(host) = host {
        format!("{}-{}", pkgname(builder, name), host.triple)
    } else {
        pkgname(builder, name)
    };

    let mut cmd = Command::new("sh");
    cmd.current_dir(&empty_dir)
        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join("install.sh")))
        .arg(format!("--prefix={}", sanitize_sh(&prefix)))
        .arg(format!("--sysconfdir={}", sanitize_sh(&sysconfdir)))
        .arg(format!("--datadir={}", sanitize_sh(&datadir)))
        .arg(format!("--docdir={}", sanitize_sh(&docdir)))
        .arg(format!("--bindir={}", sanitize_sh(&bindir)))
        .arg(format!("--libdir={}", sanitize_sh(&libdir)))
        .arg(format!("--mandir={}", sanitize_sh(&mandir)))
        .arg("--disable-ldconfig");
    builder.run(&mut cmd);
    t!(fs::remove_dir_all(&empty_dir));
}
```


Overlapping Code:
```
install_sh(
builder: &Builder<'_>,
package: &str,
name: &str,
stage: u32,
host: Option<TargetSelection>,
) {
builder.info(&format!("Install {} stage{} ({:?})", package, stage, host));
let prefix_default = PathBuf::from("/usr/local");
let sysconfdir_default = PathBuf::from("/etc");
let datadir_default = PathBuf::from("share");
let docdir_default = datadir_default.join("doc/rust");
let libdir_default = PathBuf::from("lib");
let mandir_default = datadir_default.join("man");
let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {
fs::create_dir_all(p)
.unwrap_or_else(|err| panic!("could not create {}: {}", p.display(), err));
fs::canonicalize(p)
.unwrap_or_else(|err| panic!("could not canonicalize {}: {}", p.display(), err))
});
let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);
let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);
let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);
let bindir = &builder.config.bindir;
let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);
let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);
let sysconfdir = prefix.join(sysconfdir);
let datadir = prefix.join(datadir);
let docdir = prefix.join(docdir);
let bindir = prefix.join(bindir);
let libdir = prefix.join(libdir);
let mandir = prefix.join(mandir);
let destdir = env::var_os("DESTDIR").map(PathBuf::from);
let prefix = add_destdir(&prefix, &destdir);
let sysconfdir = add_destdir(&sysconfdir, &destdir);
let datadir = add_destdir(&datadir, &destdir);
let docdir = add_destdir(&docdir, &destdir);
let bindir = add_destdir(&bindir, &destdir);
let libdir = add_destdir(&libdir, &destdir);
let mandir = add_destdir(&mandir, &destdir);
let empty_dir = builder.out.join("tmp/empty_dir");
t!(fs::create_dir_all(&empty_dir));
let package_name = if let Some(host) = host {
format!("{}-{}", pkgname(builder, name), host.triple)
} else {
pkgname(builder, name)
};
let mut cmd = Command::new("sh");
cmd.current_dir(&empty_dir)
.arg(sanitize_sh(&tmpdir(builder).join(&package_name).join("install.sh")))
.arg(format!("--prefix={}", sanitize_sh(&prefix)))
.arg(format!("--sysconfdir={}", sanitize_sh(&sysconfdir)))
.arg(fo
```
<Overlap Ratio: 0.9982142857142857>

---

--- 153 --
Question ID: da3b95d8d95994b47c73597b093d8bfa4dd07519_0
Original Code:
```
pub async fn get_collection() -> Result<(Collection, bool), UserError> {
    let config: ConfVars = match get_conf_vars() {
        Ok(config) => config,
        _ => {
            println!("Impossible to see this, if you are here something is seriously wrong with this code...");
            return Err(UserError {
                error_type: UserErrorType::InternalError,
                cause: None,
                message: Some(
                    "No clue what you did to get here... :) | pls contact me...".to_string(),
                ),
            });
        }
    };
    let client = Client::with_uri_str(
        &format!(
            "mongodb+srv://{}:{}@{}/{}?retryWrites=true&w=majority",
            config.db_user, config.db_password, config.db_server, config.db_database
        )[..],
    )
    .await?;
    let database: Database = client.database("atw");
    let connected: bool;
    match database.run_command(doc! {"ping": 1}, None).await {
        Ok(_x) => {
            println!("Connected successfully to database ...");
            connected = true;
        }
        _ => {
            println!("Could not establish connection to database, please check credentials and try again");
            connected = false;
        }
    }
    let collection: Collection = database.collection("questions");
    return Ok((collection, connected));
}
```


Overlapping Code:
```
b async fn get_collection() -> Result<(Collection, bool), UserError> {
let config: ConfVars = match get_conf_vars() {
Ok(config) => config,
_ => {
println!("Impossible to see this, if you are here something is seriously wrong with this code...");
return Err(UserError {
error_type: UserErrorType::InternalError,
cause: None,
message: Some(
"No clue what you did to get here... :) | pls contact me...".to_string(),
),
});
}
};
let client = Client::with_uri_str(
&format!(
"mongodb+srv://{}:{}@{}/{}?retryWrites=true&w=majority",
config.db_user, config.db_password, config.db_server, config.db_database
)[..],
)
.await?;
let database: Database = client.database("atw");
let connected: bool;
match database.run_command(doc! {"ping": 1}, None).await {
Ok(_x) => {
println!("Connected successfully to database ...");
connected = true;
}
_ => {
println!("Could not establish connection to database, please check credentials and try again");
connected = false;
}
}
let collection: Collection = database.collection("questions");
return Ok((collection, connec
```
<Overlap Ratio: 0.9905660377358491>

---

--- 154 --
Question ID: 9626ca6cfb761352da5176bace1b356e51853881_3
Original Code:
```
fn get_field_iref1() -> VM {
    let vm = VM::new();

    typedef!    ((vm) int64         = mu_int(64));
    typedef!    ((vm) ref_int64     = mu_ref(int64));
    typedef!    ((vm) iref_int64    = mu_iref(int64));
    typedef!    ((vm) mystruct      = mu_struct(int64, int64, ref_int64));
    typedef!    ((vm) ref_mystruct  = mu_ref(mystruct));
    typedef!    ((vm) iref_mystruct = mu_iref(mystruct));

    funcsig!    ((vm) sig = (ref_mystruct) -> (iref_int64));
    funcdecl!   ((vm) <sig> get_field_iref1);

    funcdef!    ((vm) <sig> get_field_iref1 VERSION get_field_iref1_v1);

    block!      ((vm, get_field_iref1_v1) blk_entry);
    ssa!        ((vm, get_field_iref1_v1) <ref_mystruct> x);

    ssa!        ((vm, get_field_iref1_v1) <iref_mystruct> x_);
    inst!       ((vm, get_field_iref1_v1) blk_entry_get_iref:
        x_ = GETIREF x
    );

    ssa!        ((vm, get_field_iref1_v1) <iref_int64> ret);
    inst!       ((vm, get_field_iref1_v1) blk_entry_get_field_iref1:
        ret = GETFIELDIREF x_ (is_ptr: false, index: 1)
    );

    inst!       ((vm, get_field_iref1_v1) blk_entry_ret:
        RET (ret)
    );

    define_block!   ((vm, get_field_iref1_v1) blk_entry(x) {
        blk_entry_get_iref, blk_entry_get_field_iref1, blk_entry_ret
    });

    define_func_ver!((vm) get_field_iref1_v1 (entry: blk_entry) {blk_entry});

    vm
}
```


Overlapping Code:
```
() -> VM {
let vm = VM::new();
typedef! ((vm) int64 = mu_int(64));
typedef! ((vm) ref_int64 = mu_ref(int64));
typedef! ((vm) iref_int64 = mu_iref(int64));
typedef! ((vm) mystruct = mu_struct(int64, int64, ref_int64));
typedef! ((vm) ref_mystruct = mu_ref(mystruct));
typedef! ((vm) iref_mystruct = mu_iref(mystruct));
funcsig! ((vm) sig = (ref_mystruct) -> (iref_int64));
funcdecl! ((vm) <sig> get_field_iref1);
funcdef! ((vm) <sig> get_field_iref1 VERSION get_field_iref1_v1);
block! ((vm, get_field_iref1_v1) blk_entry);
ssa! ((vm, get_field_iref1_v1) <ref_mystruct> x);
ssa! ((vm, get_field_iref1_v1) <iref_mystruct> x_);
inst! ((vm, get_field_iref1_v1) blk_entry_get_iref:
x_ = GETIREF x
);
ssa! ((vm, get_field_iref1_v1) <iref_int64> ret);
inst! ((vm, get_field_iref1_v1) blk_entry_get_field_iref1:
ret = GETFIELDIREF x_ (is_ptr: false, index: 1)
);
inst! ((vm, get_field_iref1_v1) blk_entry_ret:
RET (ret)
);
define_block! ((vm, get_field_iref1_v1) blk_entry(x) {
blk_entry_get_iref, blk_entry_get_field_iref1, blk_entry_ret
});
define_func_ver!((vm) get_field_iref1_v1 (entry: blk_entry) {blk_entry})
```
<Overlap Ratio: 0.9787798408488063>

---

--- 155 --
Question ID: 84e1d0d1670aff82560e05159db64a924e781719_0
Original Code:
```
fn package_created_correctly() {
        let pkg = Package::new(
            "Python",
            "3.8",
            "https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz",
            "tar.xz",
            "Python-3.8.0.tar.xz",
            "make",
            "Python-3.8.0",
        )
        .unwrap();

        assert_eq!(pkg.name, String::from("Python"));
        assert_eq!(pkg.version, String::from("3.8"));
        assert_eq!(
            pkg.url,
            String::from("https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz")
        );
        let mut f_type = None;
        if let FileTypes::TarXz = pkg.file_type {
            f_type = Some("tar.xz");
        };
        assert_eq!(f_type.unwrap(), String::from("tar.xz"));
        assert_eq!(pkg.file, String::from("Python-3.8.0.tar.xz"));
        assert_eq!(pkg.install_target, String::from("Python-3.8.0"));
    }
```


Overlapping Code:
```
package_created_correctly() {
let pkg = Package::new(
"Python",
"3.8",
"https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz",
"tar.xz",
"Python-3.8.0.tar.xz",
"make",
"Python-3.8.0",
)
.unwrap();
assert_eq!(pkg.name, String::from("Python"));
assert_eq!(pkg.version, String::from("3.8"));
assert_eq!(
pkg.url,
String::from("https://www.python.org/ftp/python/3.8.0/Python-3.8.0.tar.xz")
);
let mut f_type = None;
if let FileTypes::TarXz = pkg.file_type {
f_type = Some("tar.xz");
};
assert_eq!(f_type.unwrap(), String::from("tar.xz"));
assert_eq!(pkg.file, String::from("Python-3.8.0.tar.xz"));
assert_eq!(pkg.install_target, String::from("Pyth
```
<Overlap Ratio: 0.974512743628186>

---

--- 156 --
Question ID: 9b32525383c276e69e721bcae92f142fa88731fc_6
Original Code:
```
fn test_get_least_entry() {
    let mut cache = LruCache::<usize, &str>::new(3, 60);

    cache.put(1, "one");
    cache.put(2, "two");
    cache.put(3, "three");

    let cache_head = cache.get(&1);
    assert_eq!(cache_head, Some(&"one"));
    let mut iter = cache.storage.iter();
    assert!(if let Some(item) = iter.next() {
        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 0 }
            && item.prev().is_null()
            && item.next() == Pointer::InternalPointer { slab: 0, pos: 2 }
    } else {
        false
    });
    assert!(if let Some(item) = iter.next() {
        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 2 }
            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 0 }
            && item.next() == Pointer::InternalPointer { slab: 0, pos: 1 }
    } else {
        false
    });
    assert!(if let Some(item) = iter.next() {
        item.ptr() == Pointer::InternalPointer { slab: 0, pos: 1 }
            && item.prev() == Pointer::InternalPointer { slab: 0, pos: 2 }
            && item.next().is_null()
    } else {
        false
    });
    assert!(iter.next().is_none());
}
```


Overlapping Code:
```
entry() {
let mut cache = LruCache::<usize, &str>::new(3, 60);
cache.put(1, "one");
cache.put(2, "two");
cache.put(3, "three");
let cache_head = cache.get(&1);
assert_eq!(cache_head, Some(&"one"));
let mut iter = cache.storage.iter();
assert!(if let Some(item) = iter.next() {
item.ptr() == Pointer::InternalPointer { slab: 0, pos: 0 }
&& item.prev().is_null()
&& item.next() == Pointer::InternalPointer { slab: 0, pos: 2 }
} else {
false
});
assert!(if let Some(item) = iter.next() {
item.ptr() == Pointer::InternalPointer { slab: 0, pos: 2 }
&& item.prev() == Pointer::InternalPointer { slab: 0, pos: 0 }
&& item.next() == Pointer::InternalPointer { slab: 0, pos: 1 }
} else {
false
});
assert!(if let Some(item) = iter.next() {
item.ptr() == Pointer::InternalPointer { slab: 0, pos: 1 }
&& item.prev() == Pointer::InternalPointer { slab: 0, pos: 2 }
&& item.next().is_null()
} else {
false
});
assert!(iter.next().is_none(
```
<Overlap Ratio: 0.9757383966244726>

---

--- 157 --
Question ID: 70a37d1c0571f6c3accfbb97552c384895700dd0_4
Original Code:
```
fn t_compute_alm_infeasibility() {
        let (tolerance, nx, n1, n2, lbfgs_mem) = (1e-6, 5, 4, 0, 3);
        let panoc_cache = PANOCCache::new(nx, tolerance, lbfgs_mem);
        let mut alm_cache = AlmCache::new(panoc_cache, n1, n2);
        let psi = void_parameteric_cost;
        let d_psi = void_parameteric_gradient;
        let f1 = Some(void_mapping);
        let set_c = Some(Ball2::new(None, 1.0));
        let bounds = Ball2::new(None, 10.0);
        let set_y = Some(Ball2::new(None, 2.0));
        let alm_problem = AlmProblem::new(bounds, set_c, set_y, psi, d_psi, f1, NO_MAPPING, n1, n2);
        // Set y0 = [2, 3, 4, 10]
        let mut alm_optimizer = AlmOptimizer::new(&mut alm_cache, alm_problem)
            .with_initial_penalty(10.0)
            .with_initial_lagrange_multipliers(&vec![2., 3., 4., 10.]);
        {
            let cache = &mut alm_optimizer.alm_cache;
            // Set y1 = [10, 20, 11, 100]
            if let Some(y_plus) = &mut cache.y_plus {
                y_plus.copy_from_slice(&vec![10., 20., 11., 100.]);
            }
        }
        assert!(alm_optimizer.compute_alm_infeasibility().is_ok());
        unit_test_utils::assert_nearly_equal(
            92.2062904578641,
            alm_optimizer.alm_cache.delta_y_norm_plus,
            1e-10,
            1e-12,
            "delta_y_plus is wrong",
        );
    }
```


Overlapping Code:
```
() {
let (tolerance, nx, n1, n2, lbfgs_mem) = (1e-6, 5, 4, 0, 3);
let panoc_cache = PANOCCache::new(nx, tolerance, lbfgs_mem);
let mut alm_cache = AlmCache::new(panoc_cache, n1, n2);
let psi = void_parameteric_cost;
let d_psi = void_parameteric_gradient;
let f1 = Some(void_mapping);
let set_c = Some(Ball2::new(None, 1.0));
let bounds = Ball2::new(None, 10.0);
let set_y = Some(Ball2::new(None, 2.0));
let alm_problem = AlmProblem::new(bounds, set_c, set_y, psi, d_psi, f1, NO_MAPPING, n1, n2);
// Set y0 = [2, 3, 4, 10]
let mut alm_optimizer = AlmOptimizer::new(&mut alm_cache, alm_problem)
.with_initial_penalty(10.0)
.with_initial_lagrange_multipliers(&vec![2., 3., 4., 10.]);
{
let cache = &mut alm_optimizer.alm_cache;
// Set y1 = [10, 20, 11, 100]
if let Some(y_plus) = &mut cache.y_plus {
y_plus.copy_from_slice(&vec![10., 20., 11., 100.]);
}
}
assert!(alm_optimizer.compute_alm_infeasibility().is_ok());
unit_test_utils::assert_nearly_equal(
92.2062904578641,
alm_optimizer.alm_cache.delta_y_norm_plus,
1e
```
<Overlap Ratio: 0.9345622119815669>

---

--- 158 --
Question ID: 654867df8315d99617244af63ec9b2c11da581f4_28
Original Code:
```
fn grid_insert_column() {
        let mut grid = Grid::from_rows(vec![vec![2],
                                            vec![5],
                                            vec![8]]);

        assert_eq!(grid.capacity(), size!(1, 3));

        // Test inserting a column the very beginning.
        grid.insert_column(0, vec![1, 4, 7]);

        assert_eq!(grid.size(), size!(2, 3));
        assert_eq!(grid[coord!(0, 0)], 1);
        assert_eq!(grid[coord!(0, 1)], 4);
        assert_eq!(grid[coord!(0, 2)], 7);

        assert_eq!(grid.capacity(), size!(2, 3));

        // Test inserting a column at the very end
        grid.insert_column(2, vec![3, 6, 9]);

        assert_eq!(grid.size(), size!(3, 3));
        assert_eq!(grid[coord!(2, 0)], 3);
        assert_eq!(grid[coord!(2, 1)], 6);
        assert_eq!(grid[coord!(2, 2)], 9);

        assert_eq!(grid.capacity(), size!(3, 3));

        assert_eq!(grid[coord!(1, 0)], 2);
        assert_eq!(grid[coord!(1, 1)], 5);
        assert_eq!(grid[coord!(1, 2)], 8);
    }
```


Overlapping Code:
```
d = Grid::from_rows(vec![vec![2],
vec![5],
vec![8]]);
assert_eq!(grid.capacity(), size!(1, 3));
// Test inserting a column the very beginning.
grid.insert_column(0, vec![1, 4, 7]);
assert_eq!(grid.size(), size!(2, 3));
assert_eq!(grid[coord!(0, 0)], 1);
assert_eq!(grid[coord!(0, 1)], 4);
assert_eq!(grid[coord!(0, 2)], 7);
assert_eq!(grid.capacity(), size!(2, 3));
// Test inserting a column at the very end
grid.insert_column(2, vec![3, 6, 9]);
assert_eq!(grid.size(), size!(3, 3));
assert_eq!(grid[coord!(2, 0)], 3);
assert_eq!(grid[coord!(2, 1)], 6);
assert_eq!(grid[coord!(2, 2)], 9);
assert_eq!(grid.capacity(), size!(3, 3));
assert_eq!(grid[coord!(1, 0)], 2);
assert_eq!(grid[coord!(1, 1)], 5);
assert_eq!(grid[coord!(
```
<Overlap Ratio: 0.9354838709677419>

---

--- 159 --
Question ID: 91271359992952c355f0c48a18187b49f634eebe_53
Original Code:
```
fn bindgen_test_layout_alt_CResourceErrorEvent() {
    assert_eq!(
        ::std::mem::size_of::<alt_CResourceErrorEvent>(),
        24usize,
        concat!("Size of: ", stringify!(alt_CResourceErrorEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<alt_CResourceErrorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(alt_CResourceErrorEvent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).vtable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_CResourceErrorEvent),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_CResourceErrorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).cancelled as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_CResourceErrorEvent),
            "::",
            stringify!(cancelled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).resource as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(alt_CResourceErrorEvent),
            "::",
            stringify!(resource)
        )
    );
}
```


Overlapping Code:
```
lt_CResourceErrorEvent() {
assert_eq!(
::std::mem::size_of::<alt_CResourceErrorEvent>(),
24usize,
concat!("Size of: ", stringify!(alt_CResourceErrorEvent))
);
assert_eq!(
::std::mem::align_of::<alt_CResourceErrorEvent>(),
8usize,
concat!("Alignment of ", stringify!(alt_CResourceErrorEvent))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).vtable as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(alt_CResourceErrorEvent),
"::",
stringify!(vtable)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<alt_CResourceErrorEvent>())).type_ as *const _ as usize },
8usize,
concat!(
"Offset of field: ",
stringify!(alt_CResourceErrorEvent),
"::",
stringify!(type_)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<alt_CResourceErrorEvent>())).cancelled as *const _ as usize
},
12usize,
concat!(
"Offset of field: ",
stringify!(alt_CResourceErrorEvent),
"::",
stringify!(cancelled)
)
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<alt_CResourceErrorEvent>())).resource as *const _ as usize
},
16usize,
concat!(
"Offset of field: ",
stringify!(alt_CResourceErrorEvent),
"::",

```
<Overlap Ratio: 0.9562607204116638>

---

--- 160 --
Question ID: 862035a31be220b2f967be4209df3b38139b18f4_1
Original Code:
```
fn gen_columns(options: Options) {
    verify_columns(&options);
    let columns = gen_columns_vec(&options);
    let reply = Reply::ListColumns(columns);
    let serialized = serialize(&reply, Infinite).unwrap();

    let peer_reply = PeerReply::Response(0, Ok(Some(serialized)));
    let peer_serialized = serialize(&peer_reply, Infinite).unwrap();

    write(&options.output, &peer_serialized);
}
```


Overlapping Code:
```
ptions: Options) {
verify_columns(&options);
let columns = gen_columns_vec(&options);
let reply = Reply::ListColumns(columns);
let serialized = serialize(&reply, Infinite).unwrap();
let peer_reply = PeerReply::Response(0, Ok(Some(serialized)));
let peer_serialized = serialize(&peer_reply, Infinite).unwrap();
write(&options.output, &peer_serialized);
}
```
<Overlap Ratio: 0.9566395663956639>

---

--- 161 --
Question ID: d7d3695b841947b65b593e809ddeb154937c534f_0
Original Code:
```
pub fn diskread(start_lba: u32, sectors: u32) -> Result<(), BIOError> {
    let mut param_region = MemoryRegion::new(((INIT_SEG << 4) + 0x6100) as u64, 16);
    let param = param_region.as_mut_slice::<u32>(0, 4);
    // save start_lba and sectors
    param[0] = start_lba;
    param[1] = sectors;
//loop {}
    unsafe {
        llvm_asm!("start:");
        scratch_push!();
        preserved_push!();
        
        llvm_asm!("cli");

        // save return address and stack pointer
        llvm_asm!("movl $$continue, %eax":"={eax}"(param[2]));
        llvm_asm!("movl %esp, %eax":"={eax}"(param[3]));
        
        // setup gdt & idt
        llvm_asm!("
            movl  $$GDT16, %eax
            movl  %eax, (GDTR16+2)
            lgdt  GDTR16
            lidt IDTR16"
         :::
        );
        // set up new stack for real mode 0x07C0:0xFFF0
        llvm_asm!("
            movl $$0xFFF0, %eax
            movl %eax, %esp
            movl %eax, %ebp"
         :::"eax"
        );
        // setup segment
        llvm_asm!("
            movw  $$0x18, %ax
            movw  %ax, %ds
            movw  %ax, %es
            movw  %ax, %fs
            movw  %ax, %gs
            movw  %ax, %ss"
        );

        // goto real mode
        llvm_asm!("jmp  $$0x10, $$0xDD10");

        // return point
        llvm_asm!("
          continue:
            sti"
        );
        preserved_pop!();
        scratch_pop!();
        llvm_asm!("end:")
    }
    //loop {}
    if param[0] == 1 {
        Ok(())
    } else {
        Err(BIOError::IOError)
    }
}
```


Overlapping Code:
```
read(start_lba: u32, sectors: u32) -> Result<(), BIOError> {
let mut param_region = MemoryRegion::new(((INIT_SEG << 4) + 0x6100) as u64, 16);
let param = param_region.as_mut_slice::<u32>(0, 4);
// save start_lba and sectors
param[0] = start_lba;
param[1] = sectors;
//loop {}
unsafe {
llvm_asm!("start:");
scratch_push!();
preserved_push!();

llvm_asm!("cli");
// save return address and stack pointer
llvm_asm!("movl $$continue, %eax":"={eax}"(param[2]));
llvm_asm!("movl %esp, %eax":"={eax}"(param[3]));

// setup gdt & idt
llvm_asm!("
movl $$GDT16, %eax
movl %eax, (GDTR16+2)
lgdt GDTR16
lidt IDTR16"
:::
);
// set up new stack for real mode 0x07C0:0xFFF0
llvm_asm!("
movl $$0xFFF0, %eax
movl %eax, %esp
movl %eax, %ebp"
:::"eax"
);
// setup segment
llvm_asm!("
movw $$0x18, %ax
movw %ax, %ds
movw %ax, %es
movw %ax, %fs
movw %ax, %gs
movw %ax, %ss"
);
// goto real mode
llvm_asm!("jmp $$0x10, $$0xDD10");
// return point
llvm_asm!("
continue:
sti"
);
preserved_pop!();
scratch_pop!();
llvm_asm!("end:")
}
//loop {}
if param[0] == 1 {
Ok(())
} els
```
<Overlap Ratio: 0.9624197983501375>

---

--- 162 --
Question ID: db20bcf4643175c89522cfcad15dd73d361c2e77_0
Original Code:
```
pub async fn ws_index(r: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {
  debug!("{:?}", r);
  let res = ws::start(WebSocket::new(), &r, stream);
  debug!("{:?}", res);
  res
}
```


Overlapping Code:
```
ync fn ws_index(r: HttpRequest, stream: web::Payload) -> Result<HttpResponse, Error> {
debug!("{:?}", r);
let res = ws::start(WebSocket::n
```
<Overlap Ratio: 0.7301587301587301>

---

--- 163 --
Question ID: 5d997087933b43733a3d66523c90a6d04f21c85f_4
Original Code:
```
fn start() {
        let (_, remote, chan) = setup_request_test();

        let request: &[u8] = &[
            0xFA, 0xCE, 0xBA, 0xD0, // transaction id
            0x02, 0x30, 0x00, 0x00, // start
        ];

        let response_size = mem::size_of::<(AudioCommandHeader, StartResponse)>();

        let r = Request::decode(request);
        if let Ok(Request::Start { mut responder }) = r {
            responder.0.set_channel(chan);

            assert!(responder.reply(zx::Status::OK, 27).is_ok());

            let expected: &[u8] = &[
                0xFA, 0xCE, 0xBA, 0xD0, // transaction id
                0x02, 0x30, 0x00, 0x00, // start
                0x00, 0x00, 0x00, 0x00, // ZX_OK
                0x00, 0x00, 0x00, 0x00, // padding
                27, 0x00, 0x00, 0x00, // Started at 27
                0x00, 0x00, 0x00, 0x00,
            ];

            expect_channel_recv(&remote, response_size, expected);
        } else {
            panic!("Expected Start but got {:?}", r);
        }
    }
```


Overlapping Code:
```
 (_, remote, chan) = setup_request_test();
let request: &[u8] = &[
0xFA, 0xCE, 0xBA, 0xD0, // transaction id
0x02, 0x30, 0x00, 0x00, // start
];
let response_size = mem::size_of::<(AudioCommandHeader, StartResponse)>();
let r = Request::decode(request);
if let Ok(Request::Start { mut responder }) = r {
responder.0.set_channel(chan);
assert!(responder.reply(zx::Status::OK, 27).is_ok());
let expected: &[u8] = &[
0xFA, 0xCE, 0xBA, 0xD0, // transaction id
0x02, 0x30, 0x00, 0x00, // start
0x00, 0x00, 0x00, 0x00, // ZX_OK
0x00, 0x00, 0x00, 0x00, // padding
27, 0x00, 0x00, 0x00, // Started at 27
0x00, 0x00, 0x00, 0x00,
];
expect_channel_recv(&remote, response_size, expected);
} else {
panic!("Expected Start but got {:?}", r);
```
<Overlap Ratio: 0.9732620320855615>

---

--- 164 --
Question ID: bf7c64adab8e49291f4a1d82a774bbea7a114b2a_2
Original Code:
```
fn init_map(world: &mut World, sprites: &[SpriteRender], dimensions: &ScreenDimensions) {
    let file = File::open(&Path::new("assets/tilemaps/1-1.tmx")).unwrap();
    let reader = BufReader::new(file);
    // let map = parse(reader).unwrap();

    for (i, sprite) in sprites.iter().enumerate() {
        // Center around center of window
        let x = (i as f32 - 1.) * 100. + dimensions.width() * 0.5;
        let y = (i as f32 - 1.) * 100. + dimensions.height() * 0.5;
        let mut transform = Transform::default();
        transform.set_translation_xyz(x, y, 0.);

        world
            .create_entity()
            .with(sprite.clone())
            .with(transform)
            .build();
    }
}
```


Overlapping Code:
```
prites: &[SpriteRender], dimensions: &ScreenDimensions) {
let file = File::open(&Path::new("assets/tilemaps/1-1.tmx")).unwrap();
let reader = BufReader::new(file);
// let map = parse(reader).unwrap();
for (i, sprite) in sprites.iter().enumerate() {
// Center around center of window
let x = (i as f32 - 1.) * 100. + dimensions.width() * 0.5;
let y = (i as f32 - 1.) * 100. + dimensions.height() * 0.5;
let mut transform = Transform::default();
transform.set_translation_xyz(x, y, 0.);
world
.create_entity()
.with(sprite.clone())
.with(transform)
.build();
}
}
```
<Overlap Ratio: 0.9459459459459459>

---

--- 165 --
Question ID: f974a1c32645636e2c2e4f5c45a0bc19fa4744a1_1
Original Code:
```
pub fn default_alternative_prompt() -> BlockProducer {
    let id = vec![
        BlockProducer::Username(crate::block::Username::new()),
        BlockProducer::Hostname(crate::block::Hostname::new()),
    ];
    let id = BlockProducer::Separated(crate::block::Separated::new(id).with_separator("@"));
    let path = BlockProducer::WorkingDirectory(
        crate::block::WorkingDirectory::new().with_prefix(""),
    );
    let info = vec![
        id,
        path,
        BlockProducer::Elapsed(crate::block::Elapsed::new().with_prefix("")),
        BlockProducer::ExitCode(
            crate::block::ExitCode::new().with_style(crate::color::CRIMSON).with_prefix("")
        ),
    ];
    let separated = crate::block::Separated::new(info);
    let producer = BlockProducer::Sequence(crate::block::Sequence(vec![
        BlockProducer::Separated(separated),
        BlockProducer::Newline(crate::block::Newline),
        BlockProducer::ExitStatusSymbol(
            crate::block::ExitStatusSymbol::new("")
                .with_style(crate::color::DODGERBLUE)
                .with_error_style(crate::color::CRIMSON),
        ),
        BlockProducer::Space(crate::block::Space),
    ]));
    BlockProducer::Styled(crate::block::Styled::new(producer).with_style(
            Style::new().with_fg(crate::color::TEAL),
    ))
}
```


Overlapping Code:
```
ternative_prompt() -> BlockProducer {
let id = vec![
BlockProducer::Username(crate::block::Username::new()),
BlockProducer::Hostname(crate::block::Hostname::new()),
];
let id = BlockProducer::Separated(crate::block::Separated::new(id).with_separator("@"));
let path = BlockProducer::WorkingDirectory(
crate::block::WorkingDirectory::new().with_prefix(""),
);
let info = vec![
id,
path,
BlockProducer::Elapsed(crate::block::Elapsed::new().with_prefix("")),
BlockProducer::ExitCode(
crate::block::ExitCode::new().with_style(crate::color::CRIMSON).with_prefix("")
),
];
let separated = crate::block::Separated::new(info);
let producer = BlockProducer::Sequence(crate::block::Sequence(vec![
BlockProducer::Separated(separated),
BlockProducer::Newline(crate::block::Newline),
BlockProducer::ExitStatusSymbol(
crate::block::ExitStatusSymbol::new("")
.with_style(crate::color::DODGERBLUE)
.with_error_style(crate::color::CRIMSON),
),
BlockProducer::Space(crate::block::Space),
]));
BlockProducer::Styled(crate::block::Styled::new(producer).with_style(
Styl
```
<Overlap Ratio: 0.9467989179440938>

---

--- 166 --
Question ID: 06a709739f18bb1172822e63adabd91f21901a5b_3
Original Code:
```
fn basic_transfer_between_actors(
        sender_balance: u64,
        recipient_balance: u64,
        replica_count: u8,
    ) -> Result<Option<()>> {
        // --- Filter ---
        if 0 == sender_balance || 2 >= replica_count {
            return Ok(None);
        }

        // --- Arrange ---
        let section_count = 2;
        let sender_index = 0;
        let recipient_index = 1;
        let recipient_final = sender_balance + recipient_balance;
        let section_configs = vec![vec![sender_balance], vec![recipient_balance]];
        let Network {
            mut actors,
            mut sections,
            ..
        } = setup_new_network(section_count, replica_count, section_configs)?;
        let mut sender_section = sections.remove(0);
        let mut recipient_section = sections.remove(0);
        let mut sender = actors.remove(0);
        let mut recipient = actors.remove(0);

        // --- Act ---
        // 1. Init transfer at Sender Actor.
        let transfer = init_transfer(&mut sender, recipient.actor.id())?;
        // 2. Validate at Sender Replicas.
        let debit_proof = validate_at_sender_replicas(transfer, &mut sender)?
            .ok_or(Error::SenderValidationFailed)?;
        // 3. Register at Sender Replicas.
        register_at_debiting_replicas(&debit_proof, &mut sender_section)?;
        // 4. Propagate to Recipient Replicas.
        let events =
            propagate_to_crediting_replicas(debit_proof.credit_proof(), &mut recipient_section);
        // 5. Synch at Recipient Actor.
        synch(&mut recipient)?;

        // --- Assert ---
        // Actor and Replicas have the correct balance.
        assert_balance(sender, Token::zero());
        assert_balance(recipient, Token::from_nano(recipient_final));
        Ok(Some(()))
    }
```


Overlapping Code:
```
ansfer_between_actors(
sender_balance: u64,
recipient_balance: u64,
replica_count: u8,
) -> Result<Option<()>> {
// --- Filter ---
if 0 == sender_balance || 2 >= replica_count {
return Ok(None);
}
// --- Arrange ---
let section_count = 2;
let sender_index = 0;
let recipient_index = 1;
let recipient_final = sender_balance + recipient_balance;
let section_configs = vec![vec![sender_balance], vec![recipient_balance]];
let Network {
mut actors,
mut sections,
..
} = setup_new_network(section_count, replica_count, section_configs)?;
let mut sender_section = sections.remove(0);
let mut recipient_section = sections.remove(0);
let mut sender = actors.remove(0);
let mut recipient = actors.remove(0);
// --- Act ---
// 1. Init transfer at Sender Actor.
let transfer = init_transfer(&mut sender, recipient.actor.id())?;
// 2. Validate at Sender Replicas.
let debit_proof = validate_at_sender_replicas(transfer, &mut sender)?
.ok_or(Error::SenderValidationFailed)?;
// 3. Register at Sender Replicas.
register_at_debiting_replicas(&debit_proof, &mut sender_section)?;
// 4. Propagate to Recipient Replicas.
let events =
propagate_to_crediting_replicas(debit_proof.credit_proof(), &mut recipient_section);
// 5. Synch at Recipient Actor.
synch(&mut recipient)?;
// --- Assert ---
// Actor and Replicas have the correct balance.
assert_balance(sender, Token::zero());
assert_balance(recipient, Token::from_nano(recipient_final));
Ok(
```
<Overlap Ratio: 0.9848171152518979>

---

--- 167 --
Question ID: c98dcadf2bc4e73f23b41cb7a7f7b606a779e521_0
Original Code:
```
pub fn init(context: &PyContext) {
    let ref generator_type = context.generator_type;
    context.set_attr(
        &generator_type,
        "__iter__",
        context.new_rustfunc(generator_iter),
    );
    context.set_attr(
        &generator_type,
        "__next__",
        context.new_rustfunc(generator_next),
    );
    context.set_attr(
        &generator_type,
        "send",
        context.new_rustfunc(generator_send),
    );
}
```


Overlapping Code:
```
ref generator_type = context.generator_type;
context.set_attr(
&generator_type,
"__iter__",
context.new_rustfunc(generator_iter),
);
context.set_attr(
&generator_type,
"__next__",
context.new_rustfunc(generator_next),
);
context.set_attr(
&generator_type,
"send",
context.new_rustfunc(generator_send)
```
<Overlap Ratio: 0.8695652173913043>

---

--- 168 --
Question ID: d94aca502561db75c6fa50a0cec3d5f9cda5d900_2
Original Code:
```
fn rename_basic() -> anyhow::Result<()> {
    let tmp = tempdir().unwrap();
    let tmpp = tmp.path();
    let mut note_data = NoteData::default();
    edit(
        EditNoteOptions { name: "bob".into() },
        tmp.path(),
        &mut note_data,
        MockEditor {},
    )?;
    // Add a dir tag
    tag_dir(
        TagDirOptions {
            name: "bob".into(),
            add_dir_tag: Some(tmpp.into()),
            remove_dir_tag: None,
        },
        tmpp,
        &mut note_data,
    )?;
    rename(
        RenameNoteOptions {
            name: "bob".into(),
            new_name: "bob2".into(),
        },
        tmp.path(),
        &mut note_data,
    )?;
    let mut b = NoteData::default();
    b.set_dir_tag(Some("bob2"), tmpp.into());

    assert_eq!(b, note_data);
    assert_eq!(files_in_dir(&tmp.path()), vec!["bob2.md"]);
    Ok(())
}
```


Overlapping Code:
```
fn rename_basic() -> anyhow::Result<()> {
let tmp = tempdir().unwrap();
let tmpp = tmp.path();
let mut note_data = NoteData::default();
edit(
EditNoteOptions { name: "bob".into() },
tmp.path(),
&mut note_data,
MockEditor {},
)?;
// Add a dir tag
tag_dir(
TagDirOptions {
name: "bob".into(),
add_dir_tag: Some(tmpp.into()),
remove_dir_tag: None,
},
tmpp,
&mut note_data,
)?;
rename(
RenameNoteOptions {
name: "bob".into(),
new_name: "bob2".into(),
},
tmp.path(),
&mut note_data,
)?;
let mut b = NoteData::default();
b.set_dir_tag(Some("bob2"), tmpp.into());
assert_eq!(b, note_data);
assert_eq!(files_in_dir(&tmp.path()), ve
```
<Overlap Ratio: 0.9629057187017002>

---

--- 169 --
Question ID: 44ad0129cdca67f9d6cd7cb20b61d7c23ba8944e_2
Original Code:
```
fn invalid_type() {
        let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n".to_string();
        assert_eq!(tag_is_valid(&cs).unwrap(), false);

        let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n\
                  type\tcommit\n\n"
            .to_string();
        assert_eq!(tag_is_valid(&cs).unwrap(), false);

        let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n\
                  tpye commit\n"
            .to_string();
        assert_eq!(tag_is_valid(&cs).unwrap(), false);
    }
```


Overlapping Code:
```

let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n".to_string();
assert_eq!(tag_is_valid(&cs).unwrap(), false);
let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n\
type\tcommit\n\n"
.to_string();
assert_eq!(tag_is_valid(&cs).unwrap(), false);
let cs = "object be9bfa841874ccc9f2ef7c48d0c76226f89b7189\n\
tpye commit\n"
.to_string();
assert_eq!(tag_is_valid(&cs).unwrap(), false);
}
```
<Overlap Ratio: 0.954653937947494>

---

--- 170 --
Question ID: cca470ffd0202f2319badd9066feb0fc30bd27c6_0
Original Code:
```
fn generate_id(length: usize) -> String {
    thread_local!(static KEYGEN: RefCell<gpw::PasswordGenerator> = RefCell::new(gpw::PasswordGenerator::default()));

    // removed 0/o, i/1/l, u/v as they are too similar. with 4 char this gives us >700'000 unique ids
    const CHARSET: &[u8] = b"abcdefghjkmnpqrstwxyz23456789";

    (0..length)
        .map(|_| {
            let idx = thread_rng().gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect::<String>()
}
```


Overlapping Code:
```
d(length: usize) -> String {
thread_local!(static KEYGEN: RefCell<gpw::PasswordGenerator> = RefCell::new(gpw::PasswordGenerator::default()));
// removed 0/o, i/1/l, u/v as they are too similar. with 4 char this gives us >700'000 unique ids
const CHARSET: &[u8] = b"abcdefghjkmnpqrstwxyz23456789";
(0..length)
.map(|_| {
let idx = thread_rng().gen_range(0..CHARSET.len());
CHARSET[idx] as char
})
.collec
```
<Overlap Ratio: 0.9350348027842227>

---

--- 171 --
Question ID: 8e75ec91ae6cfa026d9457ae1c8ca940ebb822f0_17
Original Code:
```
fn bench_encode(bencher: &mut test::Bencher) {
            let s = testutils::KOREAN_TEXT;
            bencher.bytes = s.len() as u64;
            bencher.iter(|| {
                test::black_box({
                    UTF8Encoding.encode(s, EncoderTrap::Strict)
                })
            })
        }
```


Overlapping Code:
```
fn bench_encode(bencher: &mut test::Bencher) {
let s = testutils::KOREAN_TEXT;
bencher.bytes = s.len() as u64;
bencher.iter(|| {
test::black_box({
UTF8Encoding.encode(s, EncoderTrap::Strict)
})
```
<Overlap Ratio: 0.9747474747474747>

---

--- 172 --
Question ID: 36cc440f5f94818fef36063cb5a8a6642e02b2d7_2
Original Code:
```
fn produces_predictable_results_one_d6_parsed_with_disadvantage_equals_two() {
        let rng = rand_pcg::Pcg64Mcg::seed_from_u64(SEED);
        let dice = Roll::from_str("1d6 d").expect("No error parsing dice");
        let result = dice.roll_from_rng(rng);
        let expected = vec![DiceSetResults::new(
            vec![RollResult::new(vec![2], Some(vec![6]), 2)],
            2,
        )];
        assert_eq!(result, expected);
    }
```


Overlapping Code:
```
redictable_results_one_d6_parsed_with_disadvantage_equals_two() {
let rng = rand_pcg::Pcg64Mcg::seed_from_u64(SEED);
let dice = Roll::from_str("1d6 d").expect("No error parsing dice");
let result = dice.roll_from_rng(rng);
let expected = vec![DiceSetResults::new(
vec![RollResult::new(vec![2], Some(vec![6])
```
<Overlap Ratio: 0.8410958904109589>

---

--- 173 --
Question ID: 257e6edd8ba7b8e6953e6f9f6097bd7c7a3635a3_1
Original Code:
```
fn parse_file(
    path: &Path,
    io: &dyn WitxIo,
    root: &Path,
    validator: &mut DocValidation,
    definitions: &mut Vec<Definition>,
    parsed: &mut HashSet<PathBuf>,
) -> Result<(), WitxError> {
    let path = io.canonicalize(&root.join(path))?;
    if !parsed.insert(path.clone()) {
        return Ok(());
    }
    let input = io.fgets(&path)?;

    let adjust_err = |mut error: wast::Error| {
        error.set_path(&path);
        error.set_text(&input);
        WitxError::Parse(error)
    };
    let buf = wast::parser::ParseBuffer::new(&input).map_err(adjust_err)?;
    let doc = wast::parser::parse::<TopLevelDocument>(&buf).map_err(adjust_err)?;

    for t in doc.items {
        match t.item {
            TopLevelSyntax::Decl(d) => {
                validator
                    .scope(&input, &path)
                    .validate_decl(&d, &t.comments, definitions)
                    .map_err(WitxError::Validation)?;
            }
            TopLevelSyntax::Use(u) => {
                parse_file(u.as_ref(), io, root, validator, definitions, parsed)?;
            }
        }
    }

    Ok(())
}
```


Overlapping Code:
```
se_file(
path: &Path,
io: &dyn WitxIo,
root: &Path,
validator: &mut DocValidation,
definitions: &mut Vec<Definition>,
parsed: &mut HashSet<PathBuf>,
) -> Result<(), WitxError> {
let path = io.canonicalize(&root.join(path))?;
if !parsed.insert(path.clone()) {
return Ok(());
}
let input = io.fgets(&path)?;
let adjust_err = |mut error: wast::Error| {
error.set_path(&path);
error.set_text(&input);
WitxError::Parse(error)
};
let buf = wast::parser::ParseBuffer::new(&input).map_err(adjust_err)?;
let doc = wast::parser::parse::<TopLevelDocument>(&buf).map_err(adjust_err)?;
for t in doc.items {
match t.item {
TopLevelSyntax::Decl(d) => {
validator
.scope(&input, &path)
.validate_decl(&d, &t.comments, definitions)
.map_err(WitxError::Validation)?;
}
TopLevelSyntax::Use(u) => {
parse_file(u.as_ref(), io, root, validator, definitions, parsed)?;
}
}

```
<Overlap Ratio: 0.9815242494226328>

---

--- 174 --
Question ID: 03e2be904c3bc8931993d545a0c442e18fb84232_0
Original Code:
```
fn get_ld_search_dirs() -> Vec<String> {
    // We need to extract from `ld --verbose` all the search paths.
    // For example `ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\n'` returns the following:
    // ```
    // SEARCH_DIR("=/usr/local/lib/aarch64-linux-gnu")
    // SEARCH_DIR("=/lib/aarch64-linux-gnu")
    // SEARCH_DIR("=/usr/lib/aarch64-linux-gnu")
    // SEARCH_DIR("=/usr/local/lib")
    // SEARCH_DIR("=/lib")
    // SEARCH_DIR("=/usr/lib")
    // SEARCH_DIR("=/usr/aarch64-linux-gnu/lib")
    // ```
    let cmd = r#"
        ld --verbose | grep -oP '(?<=SEARCH_DIR\(\"=)[^"]+(?=\"\);)'
    "#;

    Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .output()
        .ok()
        .and_then(|output| {
            if output.status.success() {
                return Some(output.stdout);
            }
            None
        })
        .and_then(|stdout_bytes| String::from_utf8(stdout_bytes).ok())
        .map_or(vec![], |stdout| {
            stdout.lines().map(|item| item.to_string()).collect()
        })
}
```


Overlapping Code:
```
rch_dirs() -> Vec<String> {
// We need to extract from `ld --verbose` all the search paths.
// For example `ld --verbose | grep SEARCH_DIR | tr -s ' ;' '\n'` returns the following:
// ```
// SEARCH_DIR("=/usr/local/lib/aarch64-linux-gnu")
// SEARCH_DIR("=/lib/aarch64-linux-gnu")
// SEARCH_DIR("=/usr/lib/aarch64-linux-gnu")
// SEARCH_DIR("=/usr/local/lib")
// SEARCH_DIR("=/lib")
// SEARCH_DIR("=/usr/lib")
// SEARCH_DIR("=/usr/aarch64-linux-gnu/lib")
// ```
let cmd = r#"
ld --verbose | grep -oP '(?<=SEARCH_DIR\(\"=)[^"]+(?=\"\);)'
"#;
Command::new("sh")
.arg("-c")
.arg(cmd)
.output()
.ok()
.and_then(|output| {
if output.status.success() {
return Some(output.stdout);
}
None
})
.and_then(|stdout_bytes| String::from_utf8(stdout_bytes).ok())
.map_or(vec![], |stdout| {
stdout.lines().map(|item| i
```
<Overlap Ratio: 0.9478672985781991>

---

--- 175 --
Question ID: 0951ed0507a489ccf48578ccf666a4f4d0fb455e_15
Original Code:
```
fn memchr_unalign_words_ascii(b: &mut Bencher) {
    let words = &*WORDS_ASCII;
    let pat = b'a';
    b.iter(|| {
        words.iter().map(|w|
            memchr_unalign(pat, w.as_bytes()).unwrap_or(0)
        ).sum::<usize>()
    });
    b.bytes = words.iter().map(|w| w.len() as u64).sum::<u64>()
}
```


Overlapping Code:
```
unalign_words_ascii(b: &mut Bencher) {
let words = &*WORDS_ASCII;
let pat = b'a';
b.iter(|| {
words.iter().map(|w|
memchr_unalign(pat, w.as_bytes()).unwrap_or(0)
).sum::<usize>()
});
b.bytes = words.iter().map(|w| w.len() as u64).sum::<u64>()
```
<Overlap Ratio: 0.952755905511811>

---

--- 176 --
Question ID: f37a273ed626f0978738e190fd043f8d593d27cb_3
Original Code:
```
pub fn parse_stmt(tokens: &[Token]) -> (Option<Stmt>, &[Token]) {
    if let Some(&Token::Keyword(Keyword::Break)) = tokens.get(0) {
        return (Some(Stmt::Break), &tokens[1..]);
    }

    match parse_returnstmt(tokens) {
        (Some(s), remain) => return (Some(Stmt::Return(s)), remain),
        _ => (),
    }
    match parse_ifstmt(tokens) {
        (Some(s), remain) => return (Some(Stmt::If(s)), remain),
        _ => (),
    }

    match parse_whilestmt(tokens) {
        (Some(s), remain) => return (Some(Stmt::While(s)), remain),
        _ => (),
    }

    match parse_assignstmt(tokens) {
        (Some(s), remain) => return (Some(Stmt::Assign(s)), remain),
        _ => (),
    }

    match parse_declstmt(tokens) {
        (Some(s), remain) => return (Some(Stmt::Decl(s)), remain),
        _ => (),
    }

    match parse_expr(tokens) {
        (Some(e), remain) => return (Some(Stmt::Expr(e)), remain),
        _ => (),
    }

    (None, tokens)
}
```


Overlapping Code:
```
]) -> (Option<Stmt>, &[Token]) {
if let Some(&Token::Keyword(Keyword::Break)) = tokens.get(0) {
return (Some(Stmt::Break), &tokens[1..]);
}
match parse_returnstmt(tokens) {
(Some(s), remain) => return (Some(Stmt::Return(s)), remain),
_ => (),
}
match parse_ifstmt(tokens) {
(Some(s), remain) => return (Some(Stmt::If(s)), remain),
_ => (),
}
match parse_whilestmt(tokens) {
(Some(s), remain) => return (Some(Stmt::While(s)), remain),
_ => (),
}
match parse_assignstmt(tokens) {
(Some(s), remain) => return (Some(Stmt::Assign(s)), remain),
_ => (),
}
match parse_declstmt(tokens) {
(Some(s), remain) => return (Some(Stmt::Decl(s)), remain),
_ => (),
}
match parse_expr(tokens) {
(Some(e), remain) => return (Some(Stmt::Expr(e)), remain),
_ => (),
}
(N
```
<Overlap Ratio: 0.9410288582183187>

---

--- 177 --
Question ID: 1213a07d1721fd569530d4817ce8547700f95d30_10
Original Code:
```
fn test_salt_from_hex_odd_length() {
        let hex = "a83e8f932";

        let err = Salt::from_hex(&hex).unwrap_err();

        assert_eq!(SaltFromStrError::InvalidHexLength, err);
    }
```


Overlapping Code:
```
m_hex_odd_length() {
let hex = "a83e8f932";
let err = Salt::from_hex(&hex).unwrap_err();
assert_eq!(SaltFromStrError::In
```
<Overlap Ratio: 0.7547169811320755>

---

--- 178 --
Question ID: 4bc2be147005de2b36cddf8d20a314bd4db118e5_1
Original Code:
```
pub fn render() -> Result<()> {
  let config = config::get_config()?;
  let vars = config.vars();

  for (remote_name, render_to) in config.templates().iter() {
    render_template(config.dest(remote_name), render_to, &vars)?;
  }

  Ok(())
}
```


Overlapping Code:
```
) -> Result<()> {
let config = config::get_config()?;
let vars = config.vars();
for (remote_name, render_to) in config.templates().iter() {
render_template(config.dest(remote_name), render_to, &vars)?;
```
<Overlap Ratio: 0.8893805309734514>

---

--- 179 --
Question ID: 1a3e4ca9ab27ca0c6129c9f532c59062007b597d_0
Original Code:
```
pub fn initialize(
    program_id: &Pubkey,
    token_program_id: &Pubkey,
    swap_pubkey: &Pubkey,
    authority_pubkey: &Pubkey,
    token_a_pubkey: &Pubkey,
    token_b_pubkey: &Pubkey,
    pool_pubkey: &Pubkey,
    user_output_pubkey: &Pubkey,
    fee: Fee,
) -> Result<Instruction, ProgramError> {
    let data = SwapInstruction::Initialize(fee).serialize()?;

    let accounts = vec![
        AccountMeta::new(*swap_pubkey, true),
        AccountMeta::new(*authority_pubkey, false),
        AccountMeta::new(*token_a_pubkey, false),
        AccountMeta::new(*token_b_pubkey, false),
        AccountMeta::new(*pool_pubkey, false),
        AccountMeta::new(*user_output_pubkey, false),
        AccountMeta::new(*token_program_id, false),
    ];

    Ok(Instruction {
        program_id: *program_id,
        accounts,
        data,
    })
}
```


Overlapping Code:
```
ogram_id: &Pubkey,
token_program_id: &Pubkey,
swap_pubkey: &Pubkey,
authority_pubkey: &Pubkey,
token_a_pubkey: &Pubkey,
token_b_pubkey: &Pubkey,
pool_pubkey: &Pubkey,
user_output_pubkey: &Pubkey,
fee: Fee,
) -> Result<Instruction, ProgramError> {
let data = SwapInstruction::Initialize(fee).serialize()?;
let accounts = vec![
AccountMeta::new(*swap_pubkey, true),
AccountMeta::new(*authority_pubkey, false),
AccountMeta::new(*token_a_pubkey, false),
AccountMeta::new(*token_b_pubkey, false),
AccountMeta::new(*pool_pubkey, false),
AccountMeta::new(*user_output_pubkey, false),
AccountMeta::new(*token_program_id, false),
];
Ok(Instruction {
program_id: *program_id,
accounts,
data,
})
}
```
<Overlap Ratio: 0.9702970297029703>

---

--- 180 --
Question ID: 496d03aa691db875aa6d6a23f7747f7aaf5057d7_0
Original Code:
```
pub fn test_interface_writes_messages() {
        let mut interface = TestInterface::new(VecDeque::new());
        assert_eq!(interface.written, String::new());
        interface.write("foo");
        assert_eq!(interface.written, "foo");
        interface.write(" bar");
        assert_eq!(interface.written, "foo bar");
    }
```


Overlapping Code:
```
 fn test_interface_writes_messages() {
let mut interface = TestInterface::new(VecDeque::new());
assert_eq!(interface.written, String::new());
interface.write("foo");
assert_eq!(interface.written, "foo");
interface.write(" bar");
assert_eq!(interface.
```
<Overlap Ratio: 0.9090909090909091>

---

--- 181 --
Question ID: a09c08bbc1ac3358c30c069b564486afa149a899_0
Original Code:
```
fn fr_validator_requires_min_len_of_15() {
        let validator = super::validator::france::FranceValidator;
        assert_eq!(false, validator.validate_id("123"));
        assert_eq!(false, validator.validate_id("123 456 789 0"));
    }
```


Overlapping Code:
```
_15() {
let validator = super::validator::france::FranceValidator;
assert_eq!(false, validator.validate_id("123"));
assert_eq!(false, validator.validate_i
```
<Overlap Ratio: 0.7298578199052133>

---

--- 182 --
Question ID: 34b345b5688d6ed0d6f0732c4efadb7e3f764f3e_0
Original Code:
```
fn test_fq() {
    use crate::fields::tests::*;

    field_test::<_, Fq, FqGadget>();
    frobenius_tests::<Fq, Fq, FqGadget>(13);
    equ_verdict_fp_gadget_test::<Fq>();
    even_odd_fp_gadget_test::<Fq>();
    from_bits_fp_gadget_test::<Fq>();
    bit_fp_gadgets_test::<Fq>();
}
```


Overlapping Code:
```
n test_fq() {
use crate::fields::tests::*;
field_test::<_, Fq, FqGadget>();
frobenius_tests::<Fq, Fq, FqGadget>(13);
equ_verdict_fp_gadget_test::<Fq>();
even_odd_fp_gadget_test::<Fq>();
from_bits_fp_gadget_test::<Fq>();
bit_fp_gadgets_test::<Fq>();
}
```
<Overlap Ratio: 0.9960159362549801>

---

--- 183 --
Question ID: 64e920c37246352da58debe1839a44a5db497903_0
Original Code:
```
fn main() {
    use std::io::Write;

    //setup resource
    let mut res = winres::WindowsResource::new();
    res.set_manifest_file("./manifest.xml");
    res.compile().unwrap();
}
```


Overlapping Code:
```
e std::io::Write;
//setup resource
let mut res = winres::WindowsResource::new();
res.set_manifest_fi
```
<Overlap Ratio: 0.6211180124223602>

---

--- 184 --
Question ID: 4c664f96cd5e66433faf89b8d7b582913d0ee8d4_1
Original Code:
```
fn test_include2() {
        let mut p = Lexer::<Context<TestIncludeLocator>>::new(
            concat!(
                "#include <path2>\n",
                "#define test1 foo\n",
                "#define test2 bar(456)\n",
            )
            .as_bytes(),
        );
        p.consume_all();
        assert_eq!(eval!("test1", p), "123 ");
        assert_eq!(eval!("test2", p), "123 456 ");
    }
```


Overlapping Code:
```
n test_include2() {
let mut p = Lexer::<Context<TestIncludeLocator>>::new(
concat!(
"#include <path2>\n",
"#define test1 foo\n",
"#define test2 bar(456)\n",
)
.as_bytes(),
);
p.consume_all();
assert_eq!(eval!("test1", p), "123 ");
assert_eq!(eval!("t
```
<Overlap Ratio: 0.9057971014492754>

---

--- 185 --
Question ID: 50f2872a18d6a38ccd20c1ce6a8c4f691f8a87c3_18
Original Code:
```
pub async fn query_activity_runs(
        operation_config: &crate::OperationConfig,
        pipeline_name: &str,
        run_id: &str,
        filter_parameters: &models::RunFilterParameters,
    ) -> std::result::Result<models::ActivityRunsQueryResponse, query_activity_runs::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/pipelines/{}/pipelineruns/{}/queryActivityruns",
            operation_config.base_path(),
            pipeline_name,
            run_id
        );
        let mut url = url::Url::parse(url_str).map_err(query_activity_runs::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::POST);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(query_activity_runs::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        req_builder = req_builder.header("content-type", "application/json");
        let req_body = azure_core::to_json(filter_parameters).map_err(query_activity_runs::Error::SerializeError)?;
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(query_activity_runs::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(query_activity_runs::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ActivityRunsQueryResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
                    .map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(query_activity_runs::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
 query_activity_runs(
operation_config: &crate::OperationConfig,
pipeline_name: &str,
run_id: &str,
filter_parameters: &models::RunFilterParameters,
) -> std::result::Result<models::ActivityRunsQueryResponse, query_activity_runs::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/pipelines/{}/pipelineruns/{}/queryActivityruns",
operation_config.base_path(),
pipeline_name,
run_id
);
let mut url = url::Url::parse(url_str).map_err(query_activity_runs::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::POST);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(query_activity_runs::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
req_builder = req_builder.header("content-type", "application/json");
let req_body = azure_core::to_json(filter_parameters).map_err(query_activity_runs::Error::SerializeError)?;
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(query_activity_runs::Error::BuildRequestError)?;
let rsp = http_client
.execute_request(req)
.await
.map_err(query_activity_runs::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::ActivityRunsQueryResponse = serde_json::from_slice(rsp_body)
.map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::CloudError = serde_json::from_slice(rsp_body)
.map_err(|source| query_activity_runs::Error::DeserializeError(source, rsp_body.clone()))?;
Err(query_activit
```
<Overlap Ratio: 0.9779338014042126>

---

--- 186 --
Question ID: 159d70690da0a890d797b0ebbb4212e7b1ab6462_0
Original Code:
```
pub fn generate_rust_modules(out_dir: &Path) -> CrateResult {
    let api_defs_root = concat!(env!("CARGO_MANIFEST_DIR"), "/methods");
    let entries = std::fs::read_dir(api_defs_root)?;
    let mut api = Api::default();

    for entry in entries {
        let entry = entry?;
        if !entry.file_type()?.is_file() {
            continue;
        }

        // https://doc.rust-lang.org/cargo/reference/build-scripts.html
        println!("cargo:rerun-if-changed={}", entry.path().to_string_lossy());

        let contents = std::fs::read_to_string(entry.path())?;
        eprintln!("Merging {}", entry.path().file_name().unwrap().to_string_lossy());
        let api_fragment: Api = toml::from_str(&contents)?;

        merge(&mut api, api_fragment);
    }

    validate(&api);

    rust_crate::generate_rust_crate(out_dir, &api)?;

    eprintln!("ok: definitions generated");

    Ok(())
}
```


Overlapping Code:
```
es(out_dir: &Path) -> CrateResult {
let api_defs_root = concat!(env!("CARGO_MANIFEST_DIR"), "/methods");
let entries = std::fs::read_dir(api_defs_root)?;
let mut api = Api::default();
for entry in entries {
let entry = entry?;
if !entry.file_type()?.is_file() {
continue;
}
// https://doc.rust-lang.org/cargo/reference/build-scripts.html
println!("cargo:rerun-if-changed={}", entry.path().to_string_lossy());
let contents = std::fs::read_to_string(entry.path())?;
eprintln!("Merging {}", entry.path().file_name().unwrap().to_string_lossy());
let api_fragment: Api = toml::from_str(&contents)?;
merge(&mut api, api_fragment);
}
validate(&api);
rust_crate::generate_rust_crate(out_dir, &api)?;
eprintln
```
<Overlap Ratio: 0.9138381201044387>

---

--- 187 --
Question ID: 0f833ac7da86190578bfb623643bd61aad9703cb_9
Original Code:
```
fn test_sub_integer() -> Result<(), Error> {
        let mut vm = VM::test_vm(2);
        vm.stack[1] = CompoundValue::SimpleValue(Value::Integer(1));
        vm.stack[0] = CompoundValue::SimpleValue(Value::Integer(2));
        vm.execute_instruction(create_instruction(InstructionType::Minus))?;
        assert_eq!(vm.sp, 1);
        assert_eq!(vm.stack[0], CompoundValue::SimpleValue(Value::Integer(1)));
        Ok(())
    }
```


Overlapping Code:
```
er() -> Result<(), Error> {
let mut vm = VM::test_vm(2);
vm.stack[1] = CompoundValue::SimpleValue(Value::Integer(1));
vm.stack[0] = CompoundValue::SimpleValue(Value::Integer(2));
vm.execute_instruction(create_instruction(InstructionType::Minus))?;
assert_eq!(vm.sp, 1);
assert_eq!(vm.stack[0], CompoundValue::SimpleValue(Value::Integer(1)));

```
<Overlap Ratio: 0.9318801089918256>

---

--- 188 --
Question ID: 659ec4d3c1188e5cebd895d328d759425bd5e3d3_1
Original Code:
```
fn multi_gaussian_dist(x_v: & DVector<f64>, mean_v: & DVector<f64>, std_d_mat: & DMatrix<f64>) -> f64 {
    let n_dim: usize = mean_v.nrows();

    let x_minus_mean = x_v - mean_v;

    let mut std_d_mat_cp = DMatrix::from_diagonal_element(n_dim, n_dim, 1.0);
    std_d_mat_cp.copy_from(std_d_mat);

    let std_d_mat_inv = match std_d_mat_cp.try_inverse() {
        Some(mat_inv) => mat_inv,
        None => panic!("Not regular matrix!"),
    };

    let mut in_exp = 0.0;
    let quad_form = x_minus_mean.transpose() * std_d_mat_inv * x_minus_mean;
    for &i in quad_form.iter() {in_exp = (-0.5) * i; break;}

    let det: f64 = std_d_mat.determinant();

    let base :f64 = (2.0 * PI).sqrt().powi(n_dim as i32) * det.sqrt();

    let density: f64 = (1.0_f64.exp()).powf(in_exp) / base;

    density
}
```


Overlapping Code:
```
ian_dist(x_v: & DVector<f64>, mean_v: & DVector<f64>, std_d_mat: & DMatrix<f64>) -> f64 {
let n_dim: usize = mean_v.nrows();
let x_minus_mean = x_v - mean_v;
let mut std_d_mat_cp = DMatrix::from_diagonal_element(n_dim, n_dim, 1.0);
std_d_mat_cp.copy_from(std_d_mat);
let std_d_mat_inv = match std_d_mat_cp.try_inverse() {
Some(mat_inv) => mat_inv,
None => panic!("Not regular matrix!"),
};
let mut in_exp = 0.0;
let quad_form = x_minus_mean.transpose() * std_d_mat_inv * x_minus_mean;
for &i in quad_form.iter() {in_exp = (-0.5) * i; break;}
let det: f64 = std_d_mat.determinant();
let base :f64 = (2.0 * PI).sqrt().powi(n_dim as i32) * det.sqrt();
let density: f64 = (1.0_f64.exp()).powf(in_exp) / b
```
<Overlap Ratio: 0.9615384615384616>

---

--- 189 --
Question ID: 25795b5ed67ca5cc3a91e86b08509ed222e02ddd_6
Original Code:
```
fn test_checker_digest_file_block_algo() {
    let mut ext_table = digest_ext_table::DigestExtTable::default();
    let pypi_file_path = Path::new("tests/fixtures/files/pypi.tar.gz");
    let correct_md5 = "fe7daf822f1d36d1bd37ac41cf5817e7".to_string();

    ext_table.block(digest_ext_table::DigestAlgo::Md5);
    assert_eq!(false, ext_table.is_md5("gz".to_string()));

    match checker::digest_file(&ext_table, &pypi_file_path) {
        Some(shas) => {
            println!("failed to block using MD5 algo for Pypi files");
            assert!(false);
        }
        None => assert!(true),
    };
}
```


Overlapping Code:
```
lgo() {
let mut ext_table = digest_ext_table::DigestExtTable::default();
let pypi_file_path = Path::new("tests/fixtures/files/pypi.tar.gz");
let correct_md5 = "fe7daf822f1d36d1bd37ac41cf5817e7".to_string();
ext_table.block(digest_ext_table::DigestAlgo::Md5);
assert_eq!(false, ext_table.is_md5("gz".to_string()));
match checker::digest_file(&ext_table, &pypi_file_path) {
Some(shas) => {
println!("failed to block using MD5 algo for Pypi files");
ass
```
<Overlap Ratio: 0.8538899430740038>

---

--- 190 --
Question ID: 730344198d26fb3588e47d36a33d118c8f38cb34_1
Original Code:
```
fn sign_tx(tx: TransactionView, key: &Privkey) -> TransactionView {
    const SIGNATURE_SIZE: usize = 65;

    let witnesses_len = tx.witnesses().len();
    let tx_hash = tx.hash();
    let mut signed_witnesses: Vec<packed::Bytes> = Vec::new();
    let mut blake2b = new_blake2b();
    let mut message = [0u8; 32];
    blake2b.update(&tx_hash.raw_data());
    // digest the first witness
    let witness = WitnessArgs::default();
    let zero_lock: Bytes = {
        let mut buf = Vec::new();
        buf.resize(SIGNATURE_SIZE, 0);
        buf.into()
    };
    let witness_for_digest = witness
        .clone()
        .as_builder()
        .lock(Some(zero_lock).pack())
        .build();
    let witness_len = witness_for_digest.as_bytes().len() as u64;
    blake2b.update(&witness_len.to_le_bytes());
    blake2b.update(&witness_for_digest.as_bytes());
    (1..witnesses_len).for_each(|n| {
        let witness = tx.witnesses().get(n).unwrap();
        let witness_len = witness.raw_data().len() as u64;
        blake2b.update(&witness_len.to_le_bytes());
        blake2b.update(&witness.raw_data());
    });
    blake2b.finalize(&mut message);
    let message = H256::from(message);
    let sig = key.sign_recoverable(&message).expect("sign");
    signed_witnesses.push(
        witness
            .as_builder()
            .lock(Some(Bytes::from(sig.serialize())).pack())
            .build()
            .as_bytes()
            .pack(),
    );
    for i in 1..witnesses_len {
        signed_witnesses.push(tx.witnesses().get(i).unwrap());
    }
    tx.as_advanced_builder()
        .set_witnesses(signed_witnesses)
        .build()
}
```


Overlapping Code:
```
n sign_tx(tx: TransactionView, key: &Privkey) -> TransactionView {
const SIGNATURE_SIZE: usize = 65;
let witnesses_len = tx.witnesses().len();
let tx_hash = tx.hash();
let mut signed_witnesses: Vec<packed::Bytes> = Vec::new();
let mut blake2b = new_blake2b();
let mut message = [0u8; 32];
blake2b.update(&tx_hash.raw_data());
// digest the first witness
let witness = WitnessArgs::default();
let zero_lock: Bytes = {
let mut buf = Vec::new();
buf.resize(SIGNATURE_SIZE, 0);
buf.into()
};
let witness_for_digest = witness
.clone()
.as_builder()
.lock(Some(zero_lock).pack())
.build();
let witness_len = witness_for_digest.as_bytes().len() as u64;
blake2b.update(&witness_len.to_le_bytes());
blake2b.update(&witness_for_digest.as_bytes());
(1..witnesses_len).for_each(|n| {
let witness = tx.witnesses().get(n).unwrap();
let witness_len = witness.raw_data().len() as u64;
blake2b.update(&witness_len.to_le_bytes());
blake2b.update(&witness.raw_data());
});
blake2b.finalize(&mut message);
let message = H256::from(message);
let sig = key.sign_recoverable(&message).expect("sign");
signed_witnesses.push(
witness
.as_builder()
.lock(Some(Bytes::from(sig.serialize())).pack())
.build()
.as_bytes()
.pack(),
);
for i in 1..witnesses_len {
signed_witnesses.push(tx.witnesses().get(i).unwrap());
}
tx.as_advanced_builder()
.set_witnesses(signed_witnesses)
.build()

```
<Overlap Ratio: 0.9985283296541575>

---

--- 191 --
Question ID: f4c1ebf3f00004d0795c5c6cb8096be693eeebe6_1
Original Code:
```
async fn quit(ctx: &Context, msg: &Message) -> CommandResult {
    let data = ctx.data.read().await;

    if let Some(manager) = data.get::<ShardManagerContainer>() {
        msg.reply(ctx, "Shutting down!").await?;
        manager.lock().await.shutdown_all().await;
    } else {
        msg.reply(ctx, "There was a problem getting the shard manager")
            .await?;
        return Ok(());
    }

    Ok(())
}
```


Overlapping Code:
```
t(ctx: &Context, msg: &Message) -> CommandResult {
let data = ctx.data.read().await;
if let Some(manager) = data.get::<ShardManagerContainer>() {
msg.reply(ctx, "Shutting down!").await?;
manager.lock().await.shutdown_all().await;
} else {
msg.reply(ctx, "There was a problem getting the shard manager")
.await?;
return Ok(());
}
Ok((
```
<Overlap Ratio: 0.9541547277936963>

---

--- 192 --
Question ID: 1deff9684a140abedbe5d1da5facb0f7bba1486f_1
Original Code:
```
fn scan_block_for_eq(cx: &LateContext<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {
    let mut eq = SpanlessEq::new(cx);
    let mut eq = eq.inter_expr();
    let mut moved_locals = Vec::new();

    let start_end_eq = block
        .stmts
        .iter()
        .enumerate()
        .find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))
        .map_or(block.stmts.len(), |(i, _)| i);

    // Walk backwards through the final expression/statements so long as their hashes are equal. Note
    // `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block
    // to match those in other blocks. e.g. If each block ends with the following the hash value will be
    // the same even though each `x` binding will have a different `HirId`:
    //     let x = foo();
    //     x + 50
    let expr_hash_eq = if let Some(e) = block.expr {
        let hash = hash_expr(cx, e);
        blocks
            .iter()
            .all(|b| b.expr.map_or(false, |e| hash_expr(cx, e) == hash))
    } else {
        blocks.iter().all(|b| b.expr.is_none())
    };
    if !expr_hash_eq {
        return BlockEq {
            start_end_eq,
            end_begin_eq: None,
            moved_locals,
        };
    }
    let end_search_start = block.stmts[start_end_eq..]
        .iter()
        .rev()
        .enumerate()
        .find(|&(offset, stmt)| {
            let hash = hash_stmt(cx, stmt);
            blocks.iter().any(|b| {
                b.stmts
                    // the bounds check will catch the underflow
                    .get(b.stmts.len().wrapping_sub(offset + 1))
                    .map_or(true, |s| hash != hash_stmt(cx, s))
            })
        })
        .map_or(block.stmts.len() - start_end_eq, |(i, _)| i);

    let moved_locals_at_start = moved_locals.len();
    let mut i = end_search_start;
    let end_begin_eq = block.stmts[block.stmts.len() - end_search_start..]
        .iter()
        .zip(iter::repeat_with(move || {
            let x = i;
            i -= 1;
            x
        }))
        .fold(end_search_start, |init, (stmt, offset)| {
            if eq_stmts(
                stmt,
                blocks,
                |b| b.stmts.get(b.stmts.len() - offset),
                &mut eq,
                &mut moved_locals,
            ) {
                init
            } else {
                // Clear out all locals seen at the end so far. None of them can be moved.
                let stmts = &blocks[0].stmts;
                for stmt in &stmts[stmts.len() - init..=stmts.len() - offset] {
                    if let StmtKind::Local(l) = stmt.kind {
                        l.pat.each_binding_or_first(&mut |_, id, _, _| {
                            eq.locals.remove(&id);
                        });
                    }
                }
                moved_locals.truncate(moved_locals_at_start);
                offset - 1
            }
        });
    if let Some(e) = block.expr {
        for block in blocks {
            if block.expr.map_or(false, |expr| !eq.eq_expr(expr, e)) {
                moved_locals.truncate(moved_locals_at_start);
                return BlockEq {
                    start_end_eq,
                    end_begin_eq: None,
                    moved_locals,
                };
            }
        }
    }

    BlockEq {
        start_end_eq,
        end_begin_eq: Some(end_begin_eq),
        moved_locals,
    }
}
```


Overlapping Code:
```
<'_>, _conds: &[&Expr<'_>], block: &Block<'_>, blocks: &[&Block<'_>]) -> BlockEq {
let mut eq = SpanlessEq::new(cx);
let mut eq = eq.inter_expr();
let mut moved_locals = Vec::new();
let start_end_eq = block
.stmts
.iter()
.enumerate()
.find(|&(i, stmt)| !eq_stmts(stmt, blocks, |b| b.stmts.get(i), &mut eq, &mut moved_locals))
.map_or(block.stmts.len(), |(i, _)| i);
// Walk backwards through the final expression/statements so long as their hashes are equal. Note
// `SpanlessHash` treats all local references as equal allowing locals declared earlier in the block
// to match those in other blocks. e.g. If each block ends with the following the hash value will be
// the same even though each `x` binding will have a different `HirId`:
// let x = foo();
// x + 50
let expr_hash_eq = if let Some(e) = block.expr {
let hash = hash_expr(cx, e);
blocks
.iter()
.all(|b| b.expr.map_or(false, |e| hash_expr(cx, e) == hash))
} else {
blocks.iter().all(|b| b.expr.is_none())
};
if !expr_hash_eq {
return BlockEq {
start_end_eq,
end_begin_eq: None,
moved_locals,
};
}
let end_search_start = block.stmts[start_end_eq..]
.iter()
.rev()
.enumerate()
.find(|&(offset, stmt)| {
let hash = hash_stmt(cx, stmt);
blocks.iter().any(|b| {
b.stmts
// the bounds check will catch the underflow
.get(b.stmts.len().wrapping_sub(offset + 1))
.map_or(true, |s| hash != hash_stmt(cx, s))
})
})
.map_or(block.stmts.len() - start_end_eq, |(i, _)| i);
let moved_locals_at_start = moved_locals.len();
let mut i = end_search_start;
let end_begin_eq = block.stmts[block.stmts.len() - end_search_start..]
.iter()
.zip(iter::repeat_with(move || {
let x = i;
i -= 1;
x
}))
.fold(end_search_start, |init, (stmt, offset)| {
if eq_stmts(
stmt,
blocks,
|b| b.stmts.get(b.stmts.len() - offset),
&mut eq,
&mut moved_locals,
) {
init
} else {
// Clear out all locals seen at the end so far
```
<Overlap Ratio: 0.9757383966244726>

---

--- 193 --
Question ID: 155365430052eb4ba4596e5d22c7aef1ed2b0670_1
Original Code:
```
fn start_udp_thread(udp_addr: &str, sender: Sender<ServerMessage>) -> JoinHandle<()> {
    println!("[udp] Starting UDP server at {}", udp_addr);
    let socket = UdpSocket::bind(udp_addr).expect("[udp] Unable to create UDP socket!");

    thread::spawn(move || loop {
        let mut buf = [0; MAX_PACKET_SIZE];
        let (len, source) = socket.recv_from(&mut buf).unwrap();
        // println!("[udp] recv {} B", len);

        let slice = &(buf)[0..len];

        let message = ServerMessage::Binary {
            ip: source.ip(),
            data: slice.to_owned(),
        };

        sender
            .send(message)
            .expect("[udp] Packet receiver gone. Exiting thread.");
    })
}
```


Overlapping Code:
```
t_udp_thread(udp_addr: &str, sender: Sender<ServerMessage>) -> JoinHandle<()> {
println!("[udp] Starting UDP server at {}", udp_addr);
let socket = UdpSocket::bind(udp_addr).expect("[udp] Unable to create UDP socket!");
thread::spawn(move || loop {
let mut buf = [0; MAX_PACKET_SIZE];
let (len, source) = socket.recv_from(&mut buf).unwrap();
// println!("[udp] recv {} B", len);
let slice = &(buf)[0..len];
let message = ServerMessage::Binary {
ip: source.ip(),
data: slice.to_owned(),
};
sender
.send(message)
.expect("[udp] Packet receiver gone. Ex
```
<Overlap Ratio: 0.9515570934256056>

---

--- 194 --
Question ID: 47bb5d497aadfaf65504194eb55eb364a0fbaa96_0
Original Code:
```
pub fn pretty_print(ast: Block) -> String {
    // Start indent level at -1 so the block representing the top chunk isn't indented
    let mut writer = StringWriter::new(-1);
    ast.print(&mut writer);
    return writer.buf;
}
```


Overlapping Code:
```
ty_print(ast: Block) -> String {
// Start indent level at -1 so the block representing the top chunk isn't indented
let mut writer = StringWriter::new(-1);
ast.print(&mut writer);
return writer.buf;
}
```
<Overlap Ratio: 0.9478672985781991>

---

--- 195 --
Question ID: 426553cbaf283768b0505666ad164b8410887b5b_3
Original Code:
```
fn make_rows_query_result(rows_num: usize) -> QueryResult {
        let mut res = make_not_rows_query_result();
        res.rows = Some(make_rows(rows_num));
        res
    }
```


Overlapping Code:
```
) -> QueryResult {
let mut res = make_not_rows_query_result();
res.rows = Some(make_rows(rows_num));
res

```
<Overlap Ratio: 0.7142857142857143>

---

--- 196 --
Question ID: 8a4950eb324ae19844fbcc58b2d2ce721ea65aef_0
Original Code:
```
pub fn load() -> Templates<'static> {
    let mut hb = Handlebars::new();

    hb.register_template_file("layout", "templates/_layout.handlebars")
        .expect("register layout");
    hb.register_template_file("index", "templates/index.handlebars")
        .expect("register index");
    hb.register_template_file("dashboard", "templates/dashboard.handlebars")
        .expect("register dashboard");

    Templates { hb }
}
```


Overlapping Code:
```
lates<'static> {
let mut hb = Handlebars::new();
hb.register_template_file("layout", "templates/_layout.handlebars")
.expect("register layout");
hb.register_template_file("index", "templates/index.handlebars")
.expect("register index");
hb.register_template_file("dashboard", "templates/dashboard.handlebars")
.expect("register dashboard");
Templates
```
<Overlap Ratio: 0.9210526315789473>

---

--- 197 --
Question ID: 0b91ab6d8a99f812d9dd46487d32a82685a9a436_3
Original Code:
```
fn vector_sub() {
	let v = Vector3::fill(3.2);
	let v2 = Vector3 { x: 1.0, y: 32.0, z: 2.0 };
	let res = Vector3 {x: 2.2, y: -28.8, z: 1.2};
	assert_eq!(v - v2, res);
}
```


Overlapping Code:
```
let v = Vector3::fill(3.2);
let v2 = Vector3 { x: 1.0, y: 32.0, z: 2.0 };
let res = Vector3 {x: 2.2, y: -28.8, z: 1.2};
assert_e
```
<Overlap Ratio: 0.7804878048780488>

---

--- 198 --
Question ID: e7728e99feaced6ce2286e7cd7dd14e7216273ad_5
Original Code:
```
fn test_struct() {
    #[derive(PartialEq, Debug, Serialize, Deserialize)]
    struct TestStruct {
        int_field: u8,
        string_field: String,
        bool_field: bool,
    }

    test_roundtrip(TestStruct {
        int_field: 42,
        string_field: String::from("foo"),
        bool_field: false,
    });
}
```


Overlapping Code:
```
_struct() {
#[derive(PartialEq, Debug, Serialize, Deserialize)]
struct TestStruct {
int_field: u8,
string_field: String,
bool_field: bool,
}
test_roundtrip(TestStruct {
int_field: 42,
string_field: St
```
<Overlap Ratio: 0.8>

---

--- 199 --
Question ID: f9778364422044466a50e9d53c1dc70d0a36c152_1
Original Code:
```
pub fn format_event(request: &CsmlRequest) -> Result<Event, EngineError> {
    let step_limit = request.step_limit;
    let json_event = json!(request);

    let content_type = match json_event["payload"]["content_type"].as_str() {
        Some(content_type) => content_type.to_string(),
        None => {
            return Err(EngineError::Interpreter(
                "no content_type in event payload".to_owned(),
            ))
        }
    };
    let content = json_event["payload"]["content"].to_owned();

    let content_value = get_event_content(&content_type, &content)?;

    Ok(Event {
        content_type,
        content_value,
        content,
        ttl_duration: json_event["ttl_duration"].as_i64(),
        low_data_mode: json_event["low_data_mode"].as_bool(),
        step_limit,
        secure: json_event["payload"]["secure"].as_bool().unwrap_or(false),
    })
}
```


Overlapping Code:
```
 fn format_event(request: &CsmlRequest) -> Result<Event, EngineError> {
let step_limit = request.step_limit;
let json_event = json!(request);
let content_type = match json_event["payload"]["content_type"].as_str() {
Some(content_type) => content_type.to_string(),
None => {
return Err(EngineError::Interpreter(
"no content_type in event payload".to_owned(),
))
}
};
let content = json_event["payload"]["content"].to_owned();
let content_value = get_event_content(&content_type, &content)?;
Ok(Event {
content_type,
content_value,
content,
ttl_duration: json_event["ttl_duration"].as_i64(),
low_data_mode: json_event["low_data_mode"].as_bool(),
step_limit,
secure: json_event["payload"]["secure"].as_b
```
<Overlap Ratio: 0.957592339261286>

---

--- 200 --
Question ID: bb61e8d5a5c9814a2f692ff8a873011c91a2471b_2
Original Code:
```
fn it_returns_false_when_first_queue_is_expired() {
                let mut conf = SocketConfig::default();
                conf.msg_drop_priority = 2;
                conf.max_msg_age_secs = 10;
                let mut queue = VecDeque::new();
                let queued_at = Instant::now().sub(Duration::from_secs(100));
                queue.push_back((queued_at, vec![1, 2, 3]));

                let retain = is_queue_valid(2, &queue, &conf);

                assert!(!retain);
            }
```


Overlapping Code:
```
queue_is_expired() {
let mut conf = SocketConfig::default();
conf.msg_drop_priority = 2;
conf.max_msg_age_secs = 10;
let mut queue = VecDeque::new();
let queued_at = Instant::now().sub(Duration::from_secs(100));
queue.push_back((queued_at, vec![1, 2, 3]));
let retain = is_queue_valid(2, &queue, &conf);
assert!(
```
<Overlap Ratio: 0.8813559322033898>

---

--- 201 --
Question ID: acc1509cd17cfa153df2c3bab0cb054033a4514a_2
Original Code:
```
fn count_bags(
    lines: &[&str],
    color: &str,
    direction: Direction,
    traverse_graph: fn(NodeIndex, &BagGraph) -> anyhow::Result<u64>,
) -> anyhow::Result<u64> {
    // build rules
    let rules = lines
        .iter()
        .map(|rule| parse_rule(*rule))
        .filter_map(Result::ok)
        .collect::<Vec<_>>();

    // build the graph, then traverse it
    let graph = build_graph(&rules, direction)?;
    let node_index = graph
        .node_indices()
        .find(|index| graph[*index].color == color)
        .expect("Node not found");

    Ok(traverse_graph(node_index, &graph)?)
}
```


Overlapping Code:
```
direction: Direction,
traverse_graph: fn(NodeIndex, &BagGraph) -> anyhow::Result<u64>,
) -> anyhow::Result<u64> {
// build rules
let rules = lines
.iter()
.map(|rule| parse_rule(*rule))
.filter_map(Result::ok)
.collect::<Vec<_>>();
// build the graph, then traverse it
let graph = build_graph(&rules, direction)?;
let node_index = graph
.node_indices()
.find(|index| graph[*index].color == color)
.expect("Node not found");
Ok(traverse_graph(node_ind
```
<Overlap Ratio: 0.8840864440078585>

---

--- 202 --
Question ID: 95d93e3810ae0d32dee62d3381b1713f7e428fde_32
Original Code:
```
fn invalid_input_in_null_with_unexpected_end_of_input() {
    let input = r#"{
        "key": n"#;
    let err: ParseDiag = parse_node_err!(input);

    assert_err!(err, JsonParseErrorDetail::UnexpectedEoi {..});
}
```


Overlapping Code:
```
put_in_null_with_unexpected_end_of_input() {
let input = r#"{
"key": n"#;
let err: ParseDiag = parse_node_err!(input);
assert_err!(err, JsonParseErrorDetail::Unexpect
```
<Overlap Ratio: 0.8601036269430051>

---

--- 203 --
Question ID: 9ae7426d18ea491c251c84423079064641640467_0
Original Code:
```
fn test_make_slice() {
    const BUF: &[u8] = &[0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0xca, 0xfe];
    let s0 = make_slice!(BUF, 1, 2);
    let s1 = make_slice!(BUF, 3, 2);
    let s2 = make_slice!(BUF, 5, 2);
    assert_eq!(s0, &[0xad, 0xbe]);
    assert_eq!(s1, &[0xef, 0xba]);
    assert_eq!(s2, &[0xbe, 0xca]);
}
```


Overlapping Code:
```
const BUF: &[u8] = &[0xde, 0xad, 0xbe, 0xef, 0xba, 0xbe, 0xca, 0xfe];
let s0 = make_slice!(BUF, 1, 2);
let s1 = make_slice!(BUF, 3, 2);
let s2 = make_slice!(BUF, 5, 2);
assert_eq!(s0, &[0xad, 0xbe]);
assert_eq!(s1, &[0xef, 0xba]);
assert_eq!(s2, &[0x
```
<Overlap Ratio: 0.8741258741258742>

---

--- 204 --
Question ID: f76339f5613494bc65221331245b35603fbcbfe8_0
Original Code:
```
fn main() {
    let mut vida_goku = 1000;
    let recursos = Arc::new(Mutex::new(vida_goku));

    for cell in 1..5 {
        let mutex = recursos.clone();
        thread::spawn(move || {
          let mut vida_goku = mutex.lock().expect("Goku se defendeu atravs do lock");
          *vida_goku -= cell * 50;
      }).join().expect("Unio dos golpes falhou");
    }
    thread::sleep(Duration::new(2, 0));
    vida_goku = *recursos.lock().unwrap();
    println!("A vida de Goku apos os ataque: {}", vida_goku);
}
```


Overlapping Code:
```
t mut vida_goku = 1000;
let recursos = Arc::new(Mutex::new(vida_goku));
for cell in 1..5 {
let mutex = recursos.clone();
thread::spawn(move || {
let mut vida_goku = mutex.lock().expect("Goku se defendeu atravs do lock");
*vida_goku -= cell * 50;
}).join().expect("Unio dos golpes falhou");
}
thread::sleep(Duration::new(2, 0));
vida_goku = *recursos.lock().unwrap();
println!("A vida de Goku apos o
```
<Overlap Ratio: 0.9049773755656109>

---

--- 205 --
Question ID: f000ff15acdef3d14518700b93d4e9b8a049273f_0
Original Code:
```
unsafe fn next_test_constructor_counter() -> u64 {
  let res = TEST_CONSTRUCTOR_COUNTER;
  TEST_CONSTRUCTOR_COUNTER += 1;
  res
}
```


Overlapping Code:
```
nter() -> u64 {
let res = TEST_CONSTRUCTOR_COUNTER
```
<Overlap Ratio: 0.4065040650406504>

---

--- 206 --
Question ID: d95862217fc3082ff8159cc4424b31f9b7645c45_13
Original Code:
```
fn new_seed(rng: &mut StdRng) -> [u8; 32] {
    let mut seed = [0; 32];
    for i in 0..32 {
        seed[i] = rng.gen::<u8>();
    }
    seed
}
```


Overlapping Code:
```
8; 32] {
let mut seed = [0; 32];
for i in 0..32 {
seed[i] = 
```
<Overlap Ratio: 0.5>

---

--- 207 --
Question ID: c9619233bc98c90cf2e068779830f681f5d7e195_0
Original Code:
```
pub fn optimize_obj(obj: &mut ir::Object) -> bool{
    blocks::flat_to_blocks_obj(obj);

    memory::trim_array_lengths_obj(obj);

    let mut progress = false;
    loop {
        let mut p = false;
        p |= memory::copy_propagation_obj(obj);
        p |= algebraic::algebraic_reduce_obj(obj);
        p |= constant::constant_fold_obj(obj);
        p |= blocks::clear_dead_blocks_obj(obj);
        p |= dead_code::dead_code_obj(obj);
        p |= dead_code::remove_nops_obj(obj);
        p |= blocks::peephole_select_obj(obj);

        if p {
            progress = true;
        } else {
            break;
        }
    }

    blocks::remove_trivial_jumps_obj(obj);
    blocks::blocks_to_flat_obj(obj);

    progress
}
```


Overlapping Code:
```
:Object) -> bool{
blocks::flat_to_blocks_obj(obj);
memory::trim_array_lengths_obj(obj);
let mut progress = false;
loop {
let mut p = false;
p |= memory::copy_propagation_obj(obj);
p |= algebraic::algebraic_reduce_obj(obj);
p |= constant::constant_fold_obj(obj);
p |= blocks::clear_dead_blocks_obj(obj);
p |= dead_code::dead_code_obj(obj);
p |= dead_code::remove_nops_obj(obj);
p |= blocks::peephole_select_obj(obj);
if p {
progress = true;
} else {
break;
}
}
blocks::remove_trivial_jumps_obj(obj);
b
```
<Overlap Ratio: 0.8695652173913043>

---

--- 208 --
Question ID: dee4790211cb9d439272aee714df70f4aeb4a1d7_2
Original Code:
```
pub fn get_scores_for_user(
    conn: &PgConnection,
    user_id: i64,
    mode: i16,
) -> Result<(Vec<Map>, Vec<DBScore>), diesel::result::Error> {
    use schema::{maps, scores};

    let scores: Vec<DBScore> = scores::table
        .filter(
            scores::dsl::user_id
                .eq(user_id)
                .and(scores::dsl::mode.eq(mode)),
        )
        .order_by(scores::dsl::performance_rating.desc())
        .load(conn)?;
    let all_map_ids: Vec<i64> = scores.iter().map(|score| score.map_id).collect();

    let maps: Vec<Map> = maps::table
        .filter(maps::dsl::id.eq_any(all_map_ids))
        .load(conn)?;

    Ok((maps, scores))
}
```


Overlapping Code:
```
r_user(
conn: &PgConnection,
user_id: i64,
mode: i16,
) -> Result<(Vec<Map>, Vec<DBScore>), diesel::result::Error> {
use schema::{maps, scores};
let scores: Vec<DBScore> = scores::table
.filter(
scores::dsl::user_id
.eq(user_id)
.and(scores::dsl::mode.eq(mode)),
)
.order_by(scores::dsl::performance_rating.desc())
.load(conn)?;
let all_map_ids: Vec<i64> = scores.iter().map(|score| score.map_id).collect();
let maps: Vec<Map> = maps::table
.filter(maps::dsl::id.eq_any(all_map_ids))
.load(conn)?;
Ok
```
<Overlap Ratio: 0.929368029739777>

---

--- 209 --
Question ID: 9576b435cabfbb8be880b325ec7f0f9b19b2c5ca_0
Original Code:
```
fn main() {
    let matches = App::new("MEFF-Music")
        .version("0.1.0")
        .arg(
            Arg::with_name("own-name")
                .short("n")
                .takes_value(true)
                .required(true)
                .index(1),
        )
        .arg(
            Arg::with_name("port")
                .short("p")
                .takes_value(true)
                .required(false)
                .index(2),
        )
        .arg(
            Arg::with_name("ip-address")
                .short("ip")
                .takes_value(true)
                .required(false)
                .index(3),
        )
        .get_matches();
    let name = matches.value_of("own-name").unwrap_or("Fridolin");
    let port = matches.value_of("port").unwrap_or("34521");
    if matches.is_present("ip-address") {
        // TODO: Join existing p2p network on given ip address
        let addr;
        match matches.value_of("ip-address") {
            Some(ip) => {
                addr = match ip.parse::<SocketAddr>() {
                    Ok(socket_addr) => socket_addr,
                    Err(_) => {
                        //  error!("Could not parse ip address of remote Peer");
                        return;
                    }
                }
            }
            None => {
                //  error!("Could not parse ip-address");
                return;
            }
        }
        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };
        let appl_rc = Arc::new(Mutex::new(appl.clone()));
        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), Some(addr)) {
            Ok(p) => p,
            Err(e) => {
                println!("{}", e);
                return;
            } // error!("Could not join network {:?}", e);
        };
        startup(peer, appl_rc);
    } else {
        let appl = Application { is_playing: Arc::new(Mutex::new(false)) };
        let appl_rc = Arc::new(Mutex::new(appl.clone()));
        let peer = match start(Box::new(appl), name.to_string(), port.to_string(), None ) {
            Ok(p) => p,
            Err(e) => {
                println!("{}", e);
                return;
            } // error!("Could not join network {:?}", e);
        };
        startup(peer, appl_rc);
    }
}
```


Overlapping Code:
```
et matches = App::new("MEFF-Music")
.version("0.1.0")
.arg(
Arg::with_name("own-name")
.short("n")
.takes_value(true)
.required(true)
.index(1),
)
.arg(
Arg::with_name("port")
.short("p")
.takes_value(true)
.required(false)
.index(2),
)
.arg(
Arg::with_name("ip-address")
.short("ip")
.takes_value(true)
.required(false)
.index(3),
)
.get_matches();
let name = matches.value_of("own-name").unwrap_or("Fridolin");
let port = matches.value_of("port").unwrap_or("34521");
if matches.is_present("ip-address") {
// TODO: Join existing p2p network on given ip address
let addr;
match matches.value_of("ip-address") {
Some(ip) => {
addr = match ip.parse::<SocketAddr>() {
Ok(socket_addr) => socket_addr,
Err(_) => {
// error!("Could not parse ip address of remote Peer");
return;
}
}
}
None => {
// error!("Could not parse ip-address");
return;
}
}
let appl = Application { is_playing: Arc::new(Mutex::new(false)) };
let appl_rc = Arc::new(Mutex::new(appl.clone()));
let peer = match start(Box::new(appl), name.to_string(), port.to_string(), Some(addr)) {
Ok(p) => p,
Err(e) => {
println!("{}", e);
return;
} // error!("Could not join network {:?}", e);
};
startup(peer, appl_rc);
} else {
let appl = Application { is_playing: Arc::new(Mutex::new(false)) };
let appl_rc = Arc::new(Mutex::new(appl.clone()));
let peer = match start(Box::new(appl), name.to_string(), port.to_string(), None ) {
Ok(p) => p,
Err(e) => {
println!("{}", e);
return;
} // error!("Could not join network {:?}", e);
};
startup(peer, 
```
<Overlap Ratio: 0.9829619921363041>

---

--- 210 --
Question ID: 8fd46e8b247a93919db134dc8214aee6fd5d69be_0
Original Code:
```
fn from_struct(ast: &syn::DeriveInput, payload: &syn::DataStruct) -> TokenStream {
    let mut about_prog = String::new();
    for attr in ast.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {
        match attr {
            syn::Meta::NameValue(value) => if value.path.is_ident("doc") {
                if let syn::Lit::Str(ref text) = value.lit {
                    about_prog.push_str(&text.value());
                    about_prog.push_str("\n");
                }
            } else {
            },
            _ => (),
        }
    }

    about_prog.pop();

    let mut options = Vec::new();
    let mut arguments = Vec::new();

    options.push(Opt {
        arg: Argument {
            field_name: "_".to_owned(),
            name: "help".to_owned(),
            desc: "Prints this help information".to_owned(),
            required: false,
            is_optional: false,
            default: None,
        },
        short: Some("h".to_owned()),
        long: "help".to_owned(),
        typ: OptValueType::Help,
    });

    let mut multi_argument = None;

    for field in payload.fields.iter() {
        let field_name = field.ident.as_ref().unwrap().to_string();
        let name = field.ident.as_ref().unwrap().to_string().trim_matches(|ch| !char::is_alphanumeric(ch)).to_owned();
        let mut desc = String::new();
        let mut short = None;
        let mut long = None;
        let mut required = false;

        let (is_optional, typ) = match field.ty {
            syn::Type::Path(ref ty) => {
                let ty = ty.path.segments.last().expect("To have at least one segment");

                if ty.ident == "Option" {
                    let ty = match &ty.arguments {
                        syn::PathArguments::AngleBracketed(ref args) => match args.args.len() {
                            0 => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option is without type arguments. Fix it").to_compile_error().into(),
                            1 => match args.args.first().unwrap() {
                                syn::GenericArgument::Type(syn::Type::Path(ty)) => parse_segment(ty.path.segments.last().expect("To have at least one segment")),
                                _ => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option should have type argument, but got some other shite. Fix it").to_compile_error().into(),
                            },
                            _ => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option has too many type arguments. Fix it").to_compile_error().into()
                        },
                        syn::PathArguments::None => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option is without type arguments. Fix it").to_compile_error().into(),
                        syn::PathArguments::Parenthesized(_) => return syn::Error::new_spanned(&ty.ident, "Oi, mate, you got wrong brackets for your Option . Fix it").to_compile_error().into(),
                    };

                    (true, ty)
                } else {
                    (false, parse_segment(ty))
                }
            },
            _ => (false, OptValueType::Value),
        };

        if is_optional && typ == OptValueType::MultiValue {
            return syn::Error::new_spanned(field, "Option<Vec<_>> makes no sense. Just use plain Vec<_>").to_compile_error().into();
        }

        let mut default = None;

        for attr in field.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {
            match attr {
                syn::Meta::NameValue(value) => if value.path.is_ident("doc") {
                    if let syn::Lit::Str(ref text) = value.lit {
                        desc.push_str(&text.value());
                        desc.push_str(" ");
                    }
                },
                syn::Meta::List(value) => if value.path.is_ident("arg") {
                    for value_attr in value.nested.iter() {
                        match value_attr {
                            syn::NestedMeta::Meta(value_attr) => {
                                match value_attr {
                                    syn::Meta::Path(value_attr) => if value_attr.is_ident("short") {
                                        short = Some(format!("{}", name.chars().next().unwrap()).to_lowercase());
                                    } else if value_attr.is_ident("long") {
                                        long = Some(name.to_lowercase());
                                    } else if value_attr.is_ident("default_value") {
                                        default = Some(DEFAULT_INIT.to_owned());
                                    } else if value_attr.is_ident("required") {
                                        if typ != OptValueType::Bool {
                                            required = true
                                        } else {
                                            return syn::Error::new_spanned(value_attr, INVALID_REQUIRED_BOOL).to_compile_error().into();
                                        }
                                    },
                                    syn::Meta::NameValue(value_attr) => if value_attr.path.is_ident("short") {
                                        if let syn::Lit::Str(ref text) = value_attr.lit {
                                            let value_attr_text = text.value();

                                            if value_attr_text.contains(ARG_INVALID_CHARS) {
                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();
                                            }

                                            short = Some(value_attr_text);
                                        } else {
                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();
                                        }
                                    } else if value_attr.path.is_ident("long") {
                                        if let syn::Lit::Str(ref text) = value_attr.lit {
                                            let value_attr_text = text.value();

                                            if value_attr_text.contains(ARG_INVALID_CHARS) {
                                                return syn::Error::new_spanned(value_attr.lit.clone(), ARG_NAME_SPACE_ERROR).to_compile_error().into();
                                            }

                                            long = Some(value_attr_text)
                                        } else {
                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();
                                        }
                                    } else if value_attr.path.is_ident("default_value") {
                                        if let syn::Lit::Str(ref text) = value_attr.lit {
                                            default = Some(text.value());
                                        } else {
                                            return syn::Error::new_spanned(value_attr.path.clone(), INVALID_ARG_TYPE_STRING).to_compile_error().into();
                                        }
                                    } else {
                                        return syn::Error::new_spanned(value_attr.path.clone(), UNKNOWN_ARG_ATTR).to_compile_error().into();
                                    }
                                    _ => {
                                    },
                                }
                            },
                            syn::NestedMeta::Lit(_) => (),
                        }
                    }
                },
                _ => (),
            }
        }

        desc.pop();

        if required && default.is_some() {
            return syn::Error::new_spanned(field.ident.clone(), "Marked as required, but default value is provided?").to_compile_error().into();
        } else if is_optional && default.is_some() {
            return syn::Error::new_spanned(field.ident.clone(), "Optional, but default value is provided?").to_compile_error().into();
        } else if !required && !is_optional && default.is_none() {
            default = Some(DEFAULT_INIT.to_owned());
        }

        if short.is_none() && long.is_none() {
            if typ == OptValueType::MultiValue {
                if multi_argument.is_some() {
                    return syn::Error::new_spanned(field.ident.clone(), "Second argument collection. There can be only one").to_compile_error().into();
                }

                multi_argument = Some(Argument {
                    field_name,
                    name,
                    desc,
                    required,
                    is_optional,
                    default,
                });

            } else {
                arguments.push(Argument {
                    field_name,
                    name,
                    desc,
                    required,
                    is_optional,
                    default,
                })
            }

        } else {
            let long = match long {
                Some(long) => long,
                None => name.clone()
            };

            options.push(Opt {
                arg: Argument {
                    field_name,
                    name,
                    desc,
                    required,
                    is_optional,
                    default,
                },
                short,
                long,
                typ
            })
        }
    }

    let (impl_gen, type_gen, where_clause) = ast.generics.split_for_impl();

    let help_msg = {
        use std::io::Write;
        use tabwriter::TabWriter;

        let mut tw = TabWriter::new(vec![]);

        let _ = write!(tw, "{}

USAGE:", about_prog);

        if !options.is_empty() {
            let _ = write!(tw, " [OPTIONS]");
        }

        for argument in arguments.iter() {
            let _ = if argument.required {
                write!(tw, " <{}>", argument.name)
            } else {
                write!(tw, " [{}]", argument.name)
            };
        }

        if let Some(argument) = multi_argument.as_ref() {
            let _ = if argument.required {
                write!(tw, " <{}>...", argument.name)
            } else {
                write!(tw, " [{}]...", argument.name)
            };
        }

        if !options.is_empty() {
            let _ = write!(tw, "\n\nOPTIONS:\n");
        }

        for option in options.iter() {
            let _ = write!(tw, "\t");
            if let Some(short) = option.short.as_ref() {
                let _ = write!(tw, "-{},", short);
            }
            let _ = write!(tw, "\t");

            let _ = write!(tw, "--{}", option.long);

            let _ = match option.typ {
                OptValueType::MultiValue => write!(tw, " <{}>...", option.arg.name),
                OptValueType::Value => write!(tw, " <{}>", option.arg.name),
                _ => Ok(()),
            };

            let _ = write!(tw, "\t{}\n", option.arg.desc);
        }

        if !arguments.is_empty() || multi_argument.is_some() {
            let _ = write!(tw, "\nARGS:\n");
        }

        for argument in arguments.iter() {
            let _ = if argument.required {
                writeln!(tw, "\t<{}>\t{}", argument.name, argument.desc)
            } else {
                writeln!(tw, "\t[{}]\t{}", argument.name, argument.desc)
            };
        }

        if let Some(argument) = multi_argument.as_ref() {
            let _ = writeln!(tw, "\t<{}>...\t{}", argument.name, argument.desc);
        }

        let _ = tw.flush();

        String::from_utf8(tw.into_inner().unwrap()).unwrap()
    };

    use quote::quote;

    let mut result = String::new();
    let _ = writeln!(result, "{} {} for {}{} {{", quote!(impl#impl_gen), PARSER_TRAIT, ast.ident, quote!(#type_gen #where_clause));
    let _ = writeln!(result, "{}const HELP: &'static str = \"{}\";", TAB, help_msg);

    let _ = writeln!(result, "{}fn from_args<'a, T: IntoIterator<Item = &'a str>>(_args_: T) -> Result<Self, arg::ParseError<'a>> {{", TAB);

    for option in options.iter() {
        if option.arg.field_name == "_" {
            continue;
        }

        let _ = match option.typ {
            OptValueType::MultiValue => writeln!(result, "{0}{0}let mut {1} = Vec::new();", TAB, option.arg.field_name),
            OptValueType::Bool => writeln!(result, "{0}{0}let mut {1} = false;", TAB, option.arg.field_name),
            _ => writeln!(result, "{0}{0}let mut {1} = None;", TAB, option.arg.field_name),
        };
    }

    for argument in arguments.iter() {
        let _ = writeln!(result, "{0}{0}let mut {1} = None;", TAB, argument.field_name);
    }

    if let Some(argument) = multi_argument.as_ref() {
        let _ = writeln!(result, "{0}{0}let mut {1} = Vec::new();", TAB, argument.field_name);
    }

    let _ = writeln!(result, "{0}{0}let mut _args_ = _args_.into_iter();\n", TAB);
    let _ = writeln!(result, "{0}{0}while let Some(_arg_) = _args_.next() {{", TAB);

    //options
    let _ = writeln!(result, "{0}{0}{0}if let Some(_arg_) = _arg_.strip_prefix('-') {{", TAB);
    let _ = writeln!(result, "{0}{0}{0}{0}match _arg_ {{", TAB);
    let _ = writeln!(result, "{0}{0}{0}{0}{0}\"h\" | \"-help\" => return Err(arg::ParseError::HelpRequested(Self::HELP)),", TAB);

    for option in options.iter() {
        if option.arg.field_name == "_" {
            continue;
        }

        let _ = write!(result, "{0}{0}{0}{0}{0}", TAB);

        if let Some(short) = option.short.as_ref() {
            let _ = write!(result, "\"{}\" | ", short);
        }

        let _ = write!(result, "\"-{}\" => ", option.long);

        let _ = match option.typ {
            OptValueType::Help => panic!("Option Help is invalid here. Bug report it"),
            OptValueType::Bool => write!(result, "{0} = !{0},", option.arg.field_name),
            OptValueType::Value => write!(result, "match _args_.next() {{
{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{
{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2} = Some(value),
{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\"{3}\", _next_arg_)),
{0}{0}{0}{0}{0}{0}}},
{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\"{3}\")),
{0}{0}{0}{0}{0}}}", TAB, FROM_FN, option.arg.field_name, option.arg.name),
            OptValueType::MultiValue => write!(result, "match _args_.next() {{
{0}{0}{0}{0}{0}{0}Some(_next_arg_) => match {1}(_next_arg_) {{
{0}{0}{0}{0}{0}{0}{0}Ok(value) => {2}.push(value),
{0}{0}{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidFlagValue(\"{3}\", _next_arg_)),
{0}{0}{0}{0}{0}{0}}},
{0}{0}{0}{0}{0}{0}None => return Err(arg::ParseError::MissingValue(\"{3}\")),
{0}{0}{0}{0}{0}}}", TAB, FROM_FN, option.arg.field_name, option.arg.name),
        };
        let _ = writeln!(result, "");
    }
    let _ = writeln!(result, "{0}{0}{0}{0}{0}_ => return Err(arg::ParseError::UnknownFlag(_arg_)),", TAB);

    let _ = writeln!(result, "{0}{0}{0}{0}}}", TAB);
    //rest args
    for arg in arguments.iter() {
        let _ = writeln!(result, "{0}{0}{0}}} else if {1}.is_none() {{", TAB, arg.field_name);
        let _ = writeln!(result, "{0}{0}{0}{0}match {1}(_arg_) {{", TAB, FROM_FN);
        let _ = writeln!(result, "{0}{0}{0}{0}{0}Ok(_res_) => {1} = Some(_res_),", TAB, arg.field_name);
        let _ = writeln!(result, "{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\"{1}\", _arg_)),", TAB, arg.field_name);
        let _ = writeln!(result, "{0}{0}{0}{0}}}", TAB);
    }
    //too many args?
    let _ = writeln!(result, "{0}{0}{0}}} else {{", TAB);

    if let Some(arg) = multi_argument.as_ref() {
        let _ = writeln!(result, "{0}{0}{0}{0}match {1}(_arg_) {{", TAB, FROM_FN);
        let _ = writeln!(result, "{0}{0}{0}{0}{0}Ok(_res_) => {1}.push(_res_),", TAB, arg.field_name);
        let _ = writeln!(result, "{0}{0}{0}{0}{0}Err(_) => return Err(arg::ParseError::InvalidArgValue(\"{1}\", _arg_)),", TAB, arg.field_name);
        let _ = writeln!(result, "{0}{0}{0}{0}}}", TAB);
    } else {
        let _ = writeln!(result, "{0}{0}{0}{0} return Err(arg::ParseError::TooManyArgs);", TAB);
    }
    let _ = writeln!(result, "{0}{0}{0}}}", TAB);
    //exit args

    let _ = writeln!(result, "{0}{0}}}", TAB);

    //Set defaults
    for option in options.iter() {
        if option.arg.field_name == "_" {
            continue;
        }

        let _ = match option.typ {
            OptValueType::MultiValue => Ok(()),
            OptValueType::Bool => Ok(()),
            _ => match option.arg.default {
                Some(ref default) => writeln!(result, "{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};", TAB, option.arg.field_name, default),
                None => match option.arg.is_optional {
                    true => Ok(()),
                    false => writeln!(result, "{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\"{2}\")) }};", TAB, option.arg.field_name, option.arg.name),
                },
            },
        };
    }

    for arg in arguments.iter() {
        let _ = match arg.default {
            Some(ref default) => writeln!(result, "{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ {2} }};", TAB, arg.field_name, default),
            None => match arg.is_optional {
                true => Ok(()),
                false => writeln!(result, "{0}{0}let {1} = if let Some(value) = {1} {{ value }} else {{ return Err(arg::ParseError::RequiredArgMissing(\"{2}\")) }};", TAB, arg.field_name, arg.name),
            }
        };
    }

    //Fill result
    let _ = writeln!(result, "{0}{0}Ok(Self {{", TAB);

    for option in options.iter() {
        if option.arg.field_name == "_" {
            continue;
        }

        let _ = if option.arg.is_optional && option.typ == OptValueType::Bool {
            writeln!(result, "{0}{0}{0}{1}: Some({1}),", TAB, option.arg.field_name)
        } else {
            writeln!(result, "{0}{0}{0}{1},", TAB, option.arg.field_name)
        };
    }

    for arg in arguments.iter() {
        let _ = writeln!(result, "{0}{0}{0}{1},", TAB, arg.field_name);
    }

    if let Some(arg) = multi_argument.as_ref() {
        let _ = writeln!(result, "{0}{0}{0}{1},", TAB, arg.field_name);
    }

    let _ = writeln!(result, "{0}{0}}})", TAB);

    //Exit fn
    let _ = writeln!(result, "{}}}", TAB);

    let _ = writeln!(result, "}}");

    result.parse().expect("To parse generated code")
}
```


Overlapping Code:
```
iveInput, payload: &syn::DataStruct) -> TokenStream {
let mut about_prog = String::new();
for attr in ast.attrs.iter().filter_map(|attr| attr.parse_meta().ok()) {
match attr {
syn::Meta::NameValue(value) => if value.path.is_ident("doc") {
if let syn::Lit::Str(ref text) = value.lit {
about_prog.push_str(&text.value());
about_prog.push_str("\n");
}
} else {
},
_ => (),
}
}
about_prog.pop();
let mut options = Vec::new();
let mut arguments = Vec::new();
options.push(Opt {
arg: Argument {
field_name: "_".to_owned(),
name: "help".to_owned(),
desc: "Prints this help information".to_owned(),
required: false,
is_optional: false,
default: None,
},
short: Some("h".to_owned()),
long: "help".to_owned(),
typ: OptValueType::Help,
});
let mut multi_argument = None;
for field in payload.fields.iter() {
let field_name = field.ident.as_ref().unwrap().to_string();
let name = field.ident.as_ref().unwrap().to_string().trim_matches(|ch| !char::is_alphanumeric(ch)).to_owned();
let mut desc = String::new();
let mut short = None;
let mut long = None;
let mut required = false;
let (is_optional, typ) = match field.ty {
syn::Type::Path(ref ty) => {
let ty = ty.path.segments.last().expect("To have at least one segment");
if ty.ident == "Option" {
let ty = match &ty.arguments {
syn::PathArguments::AngleBracketed(ref args) => match args.args.len() {
0 => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option is without type arguments. Fix it").to_compile_error().into(),
1 => match args.args.first().unwrap() {
syn::GenericArgument::Type(syn::Type::Path(ty)) => parse_segment(ty.path.segments.last().expect("To have at least one segment")),
_ => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Option should have type argument, but got some other shite. Fix it").to_compile_error().into(),
},
_ => return syn::Error::new_spanned(&ty.ident, "Oi, mate, Op
```
<Overlap Ratio: 0.9846072186836518>

---

--- 211 --
Question ID: b08cee8d4cec59b2262025caabf2a8459d42fa86_7
Original Code:
```
fn test_decimal_separator() {
        let value = 12345.6789;
        let opt = HumanizeOptions::builder().decimal_separator("_").build();
        assert_eq!(value.humanize(&opt), "12_35K".to_owned());
    }
```


Overlapping Code:
```
ue = 12345.6789;
let opt = HumanizeOptions::builder().decimal_separator("_").build();
assert_eq!(val
```
<Overlap Ratio: 0.5586592178770949>

---

--- 212 --
Question ID: 5f9d49cf2a7c6ac8c6616f9095fce308430a93a7_5
Original Code:
```
fn error_cannot_return_value() {
    let input = r#"
#[test]
fn test() -> u8 {
    require(true);
    42
}

fn main() {
    let value = test();
}
"#;

    let expected = Err(Error::Semantic(SemanticError::Element(ElementError::Type(
        TypeError::Function(FunctionError::Test(TestFunctionError::CannotReturnValue {
            location: Location::test(3, 1),
            function: "test".to_owned(),
        })),
    ))));

    let result = crate::semantic::tests::compile_entry(input);

    assert_eq!(result, expected);
}
```


Overlapping Code:
```
not_return_value() {
let input = r#"
#[test]
fn test() -> u8 {
require(true);
42
}
fn main() {
let value = test();
}
"#;
let expected = Err(Error::Semantic(SemanticError::Element(ElementError::Type(
TypeError::Function(FunctionError::Test(TestFunctionError::CannotReturnValue {
location: Location::test(3, 1),
function: "test".to_owned(),
})),
))));
let result = crate::semantic::tests::compile_entry(input);
assert_eq!(result, expected);
}
```
<Overlap Ratio: 0.9734513274336283>

---

--- 213 --
Question ID: f10930d029c57cb4dbb180e719e5438b2b069303_3
Original Code:
```
fn impl_struct(
    name: syn::Ident,
    vis: syn::Visibility,
    data: syn::DataStruct,
    derive: Vec<syn::Ident>,
) -> TokenStream {
    let mut field_names = Vec::new();
    let mut member_names = Vec::new();
    let mut field_types = Vec::new();
    let mut unnamed_count: u32 = 0;
    for field in data.fields.iter() {
        if let Some(ref x) = field.ident {
            field_names.push(to_camel_case(x));
            member_names.push(syn::Member::Named(x.clone()));
            field_types.push(field.ty.clone());
        } else {
            let ident = format_ident!("{}", get_name(unnamed_count));
            field_names.push(ident);
            member_names.push(to_tuple_index(unnamed_count));
            unnamed_count += 1;
            field_types.push(field.ty.clone());
        }
    }
    let patch_name = format_ident!("{}Patch", name);
    let patch_error_name = format_ident!("{}PatchError", name);
    let mod_name = format_ident!("__{}_mod", to_snake_case(&name));

    let derive_tag = quote! {
        #[derive(#(#derive,)*)]
    };

    let stream = quote! {
        #derive_tag
        #vis enum #patch_name {
            #(#field_names (<#field_types as Patchable>::Patch),)*
        }
        #vis enum #patch_error_name {
            #(#field_names (<#field_types as Patchable>::Error),)*
        }

        mod #mod_name{
            use std::fmt;
            use super::#patch_error_name;

            impl fmt::Display for #patch_error_name{
                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{
                    match *self{
                        #(#patch_error_name::#field_names(ref x) => {
                            write!(fmt, "within `#name.#field_names` => {}",x)
                        })*
                    }
                }
            }
        }

        impl Patchable for #name{
            type Patch = Vec<#patch_name>;
            type Error = #patch_error_name;

            fn produce(&self, other: &Self) -> Option<Self::Patch>{
                let mut res = Vec::new();
                #(if let Some(x) = self.#member_names.produce(&other.#member_names) {
                    res.push(#patch_name::#field_names(x));
                })*
                if res.len() == 0{
                    None
                }else{
                    Some(res)
                }
            }

            fn apply(&mut self, patch: Self::Patch) -> Result<(),Self::Error>{
                for p in patch {
                    match p{
                        #(#patch_name::#field_names(x) => {
                            self.#member_names.apply(x).map_err(#patch_error_name::#field_names)?;
                        })*
                    }
                }
                Ok(())
            }
        }
    };
    proc_macro::TokenStream::from(stream)
}
```


Overlapping Code:
```
name: syn::Ident,
vis: syn::Visibility,
data: syn::DataStruct,
derive: Vec<syn::Ident>,
) -> TokenStream {
let mut field_names = Vec::new();
let mut member_names = Vec::new();
let mut field_types = Vec::new();
let mut unnamed_count: u32 = 0;
for field in data.fields.iter() {
if let Some(ref x) = field.ident {
field_names.push(to_camel_case(x));
member_names.push(syn::Member::Named(x.clone()));
field_types.push(field.ty.clone());
} else {
let ident = format_ident!("{}", get_name(unnamed_count));
field_names.push(ident);
member_names.push(to_tuple_index(unnamed_count));
unnamed_count += 1;
field_types.push(field.ty.clone());
}
}
let patch_name = format_ident!("{}Patch", name);
let patch_error_name = format_ident!("{}PatchError", name);
let mod_name = format_ident!("__{}_mod", to_snake_case(&name));
let derive_tag = quote! {
#[derive(#(#derive,)*)]
};
let stream = quote! {
#derive_tag
#vis enum #patch_name {
#(#field_names (<#field_types as Patchable>::Patch),)*
}
#vis enum #patch_error_name {
#(#field_names (<#field_types as Patchable>::Error),)*
}
mod #mod_name{
use std::fmt;
use super::#patch_error_name;
impl fmt::Display for #patch_error_name{
fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result{
match *self{
#(#patch_error_name::#field_names(ref x) => {
write!(fmt, "within `#name.#field_names` => {}",x)
})*
}
}
}
}
impl Patchable for #name{
type Patch = Vec<#patch_name>;
type Error = #patch_error_name;
fn produce(&self, other: &Self) -> Option<Self::Patch>{
let mut res = Vec::new();
#(if let Some(x) = self.#member_names.produce(&other.#member_names) {
res.push(#patch_name::#field_names(x));
})*
if res.len() == 0{
None
}else{
Some(res)
}
}
fn apply(&mut self, patch: Self::Patch) -> Result<(),Self::Error>{
for p in pat
```
<Overlap Ratio: 0.9887005649717514>

---

--- 214 --
Question ID: 72955ae8fcabf4d79ddb12dffc0291a2366cfd9a_0
Original Code:
```
async fn get_highest_role(member: Arc<Member>, ctx: Context) -> Result<i64, Box<dyn Error + Send + Sync>> {
    let roles = ctx.http.roles(member.guild_id).await?;
    let roles = {
        let mut map = HashMap::new();
        for role in roles.iter() {
            map.insert(role.id, role.clone());
        }

        map
    };

    let mut pos = -1;
    for role in member.roles.iter() {
        if let Some(role) = roles.get(role) {
            if role.position > pos { pos = role.position }
        }
    }

    Ok(pos)
}
```


Overlapping Code:
```
er: Arc<Member>, ctx: Context) -> Result<i64, Box<dyn Error + Send + Sync>> {
let roles = ctx.http.roles(member.guild_id).await?;
let roles = {
let mut map = HashMap::new();
for role in roles.iter() {
map.insert(role.id, role.clone());
}
map
};
let mut pos = -1;
for role in member.roles.iter() {
if let Some(role) = roles.get(role) {
if role.positio
```
<Overlap Ratio: 0.8235294117647058>

---

--- 215 --
Question ID: 8e11e181147c744687c5a3d27ceb882e495bc0ce_3
Original Code:
```
fn decode_footer_deser() {
    let mut message = p!(Message, "message_footer_1");

    assert_eq!(
        message.embeds.remove(0).footer.unwrap().text,
        "2005-09-26 - 2013-09-26"
    );

    p!(Message, "message_footer_2");
}
```


Overlapping Code:
```
_deser() {
let mut message = p!(Message, "message_footer_1");
assert_eq!(
message.embeds.remove(0).footer.unwrap().text,
"2005-09-26 - 2013-09-26"
);
p!(Message, "message_footer_
```
<Overlap Ratio: 0.89>

---

--- 216 --
Question ID: 1ee3254fb2902b809a045af1a11a6654ab97c1d8_0
Original Code:
```
pub fn register(callsite: &'static dyn Callsite) {
    let mut registry = REGISTRY.lock().unwrap();
    registry.rebuild_callsite_interest(callsite);
    registry.callsites.push(callsite);
}
```


Overlapping Code:
```
pub fn register(callsite: &'static dyn Callsite) {
let mut registry = REGISTRY.lock().unwrap();
registry.rebuild_callsite_interest(callsite);
registry
```
<Overlap Ratio: 0.8426966292134831>

---

--- 217 --
Question ID: 98a03b76f858f57830553b494984ec682beb500c_3
Original Code:
```
fn test_tc_aggregation_keep_last_only() {
    ::libra_logger::Logger::new().environment_only(true).init();

    let (signers, validator) = random_validator_verifier(4, Some(2), false);
    let mut pending_votes = PendingVotes::new();

    let li1 = random_ledger_info();
    let vote_round_1 = random_vote_data(1);
    let mut vote_round_1_author_0 = Vote::new(vote_round_1, signers[0].author(), li1, &signers[0]);
    let timeout = vote_round_1_author_0.timeout();
    let signature = timeout.sign(&signers[0]);
    vote_round_1_author_0.add_timeout_signature(signature);

    // first time a new vote is added the result is VoteAdded
    assert_eq!(
        pending_votes.insert_vote(&vote_round_1_author_0, &validator),
        VoteReceptionResult::VoteAdded(1)
    );

    // A vote for round 2 overrides the previous vote
    let li2 = random_ledger_info();
    let vote_round_2 = random_vote_data(2);
    let mut vote_round_2_author_0 = Vote::new(vote_round_2, signers[0].author(), li2, &signers[0]);
    let timeout = vote_round_2_author_0.timeout();
    let signature = timeout.sign(&signers[0]);
    vote_round_2_author_0.add_timeout_signature(signature);
    assert_eq!(
        pending_votes.insert_vote(&vote_round_2_author_0, &validator),
        VoteReceptionResult::VoteAdded(1)
    );

    // a new vote for round 1 cannot form a TC
    let li3 = random_ledger_info();
    let vote3_round_1 = random_vote_data(1);
    let mut vote3_round_1_author_1 =
        Vote::new(vote3_round_1, signers[1].author(), li3, &signers[1]);
    let timeout = vote3_round_1_author_1.timeout();
    let signature = timeout.sign(&signers[1]);
    vote3_round_1_author_1.add_timeout_signature(signature);
    assert_eq!(
        pending_votes.insert_vote(&vote3_round_1_author_1, &validator),
        VoteReceptionResult::VoteAdded(1)
    );

    // a new vote for round 2 should form a TC
    let li4 = random_ledger_info();
    let vote4_round_2 = random_vote_data(2);
    let mut vote4_round_2_author_1 =
        Vote::new(vote4_round_2, signers[1].author(), li4, &signers[1]);
    let timeout = vote4_round_2_author_1.timeout();
    let signature = timeout.sign(&signers[1]);
    vote4_round_2_author_1.add_timeout_signature(signature);
    match pending_votes.insert_vote(&vote4_round_2_author_1, &validator) {
        VoteReceptionResult::NewTimeoutCertificate(tc) => {
            assert!(validator.check_voting_power(tc.signatures().keys()).is_ok());
        }
        _ => {
            panic!("No TC formed.");
        }
    };
}
```


Overlapping Code:
```
ly() {
::libra_logger::Logger::new().environment_only(true).init();
let (signers, validator) = random_validator_verifier(4, Some(2), false);
let mut pending_votes = PendingVotes::new();
let li1 = random_ledger_info();
let vote_round_1 = random_vote_data(1);
let mut vote_round_1_author_0 = Vote::new(vote_round_1, signers[0].author(), li1, &signers[0]);
let timeout = vote_round_1_author_0.timeout();
let signature = timeout.sign(&signers[0]);
vote_round_1_author_0.add_timeout_signature(signature);
// first time a new vote is added the result is VoteAdded
assert_eq!(
pending_votes.insert_vote(&vote_round_1_author_0, &validator),
VoteReceptionResult::VoteAdded(1)
);
// A vote for round 2 overrides the previous vote
let li2 = random_ledger_info();
let vote_round_2 = random_vote_data(2);
let mut vote_round_2_author_0 = Vote::new(vote_round_2, signers[0].author(), li2, &signers[0]);
let timeout = vote_round_2_author_0.timeout();
let signature = timeout.sign(&signers[0]);
vote_round_2_author_0.add_timeout_signature(signature);
assert_eq!(
pending_votes.insert_vote(&vote_round_2_author_0, &validator),
VoteReceptionResult::VoteAdded(1)
);
// a new vote for round 1 cannot form a TC
let li3 = random_ledger_info();
let vote3_round_1 = random_vote_data(1);
let mut vote3_round_1_author_1 =
Vote::new(vote3_round_1, signers[1].author(), li3, &signers[1]);
let timeout = vote3_round_1_author_1.timeout();
let signature = timeout.sign(&signers[1]);
vote3_round_1_author_1.add_timeout_signature(signature);
assert_eq!(
pending_votes.insert_vote(&vote3_round_1_author_1, &validator),
VoteReceptionResult::VoteAdded(1)
);
// a new vote for round 2 should form a TC
let li4 = random_ledger_info();
let vote4_round_2 = random_vote_data(2);
let mut vote4_round_2_author_1 =
Vote::new(vote4_round_2, signers[1].author(), li4, &signers[1]);
let timeout = vote4_round_2_author_1.timeout();
let signature = timeout.sign(&signers[1]);
vote4_round_2_author_1.add_timeout_signature(signature);
match pending_votes.insert_vote(&vote4_round_2_author_1, &validator) {
VoteReceptionResult::NewTimeoutCertificate(tc) => {
assert!(validator.check_voting_power(tc.signatures().keys()).is_ok());
}
_ => {
pan
```
<Overlap Ratio: 0.9820547330641544>

---

--- 218 --
Question ID: 78e1922a871dec3605dc670bcfa1786cab8a8741_3
Original Code:
```
fn solve(input: &str) -> (usize, usize) {
    let g = SimpleGrid::create_from(input);

    // prepare and run the simulation using the adjacency rules
    let (mut seats, adjacency_map) = adjacency_map(&g);
    run_simulation(&mut seats, &adjacency_map, 4);
    let occupied_adj = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();

    // prepare and run the simulation using the visibility rules
    let (mut seats, visibility_map) = visibility_map(&g);
    run_simulation(&mut seats, &visibility_map, 5);
    let occupied_vis = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();

    (occupied_adj, occupied_vis)
}
```


Overlapping Code:
```
{
let g = SimpleGrid::create_from(input);
// prepare and run the simulation using the adjacency rules
let (mut seats, adjacency_map) = adjacency_map(&g);
run_simulation(&mut seats, &adjacency_map, 4);
let occupied_adj = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();
// prepare and run the simulation using the visibility rules
let (mut seats, visibility_map) = visibility_map(&g);
run_simulation(&mut seats, &visibility_map, 5);
let occupied_vis = seats.iter().filter(|s| **s == Place::OccupiedSeat).count();
(occupied_adj, occupied_vi
```
<Overlap Ratio: 0.9259259259259259>

---

--- 219 --
Question ID: 41fe300c7ff809a844807c8a62763858d244809a_0
Original Code:
```
pub fn libra_LibraAccountResource_from_safe(
    blob: AccountStateBlob,
) -> Result<LibraAccountResource, LibraStatus> {
    clear_error();
    if let Ok(account_state) = AccountState::try_from(&blob) {
        if let Ok(Some(account_resource)) = account_state.get_account_resource() {
            if let Ok(Some(balance_resource)) = account_state.get_balance_resource() {
                let mut authentication_key = [0u8; ED25519_PUBLIC_KEY_LENGTH];
                authentication_key.copy_from_slice(account_resource.authentication_key());

                let sent_events = LibraEventHandle {
                    count: account_resource.sent_events().count(),
                    key: account_resource.sent_events().key().into(),
                };
                let received_events = LibraEventHandle {
                    count: account_resource.received_events().count(),
                    key: account_resource.received_events().key().into(),
                };

                return Ok(LibraAccountResource {
                    balance: balance_resource.coin(),
                    sequence: account_resource.sequence_number(),
                    delegated_key_rotation_capability: account_resource
                        .delegated_key_rotation_capability(),
                    delegated_withdrawal_capability: account_resource
                        .delegated_withdrawal_capability(),
                    sent_events,
                    received_events,
                    authentication_key,
                });
            }
        }
    }
    update_last_error(format!(
        "Error deserializing account state blob: {:?}",
        blob
    ));
    Err(LibraStatus::InvalidArgument)
}
```


Overlapping Code:
```
b fn libra_LibraAccountResource_from_safe(
blob: AccountStateBlob,
) -> Result<LibraAccountResource, LibraStatus> {
clear_error();
if let Ok(account_state) = AccountState::try_from(&blob) {
if let Ok(Some(account_resource)) = account_state.get_account_resource() {
if let Ok(Some(balance_resource)) = account_state.get_balance_resource() {
let mut authentication_key = [0u8; ED25519_PUBLIC_KEY_LENGTH];
authentication_key.copy_from_slice(account_resource.authentication_key());
let sent_events = LibraEventHandle {
count: account_resource.sent_events().count(),
key: account_resource.sent_events().key().into(),
};
let received_events = LibraEventHandle {
count: account_resource.received_events().count(),
key: account_resource.received_events().key().into(),
};
return Ok(LibraAccountResource {
balance: balance_resource.coin(),
sequence: account_resource.sequence_number(),
delegated_key_rotation_capability: account_resource
.delegated_key_rotation_capability(),
delegated_withdrawal_capability: account_resource
.delegated_withdrawal_capability(),
sent_events,
received_events,
authentication_key,
});
}
}
}
update_last_error(format!(
"Error deserializing account state blob: {:?}",
blob
));
Err
```
<Overlap Ratio: 0.9724473257698542>

---

--- 220 --
Question ID: 841825a3f0220ff7d076fda53cc84e105c1de042_0
Original Code:
```
fn github_hook(req: HttpRequest, body: String) -> FutureResponse<&'static str> {
    let data = middleware::validate(&req, body.as_bytes())
        .and_then(|_| serde_json::from_str(body.as_str()).map_err(ErrorBadRequest));
    let response = |data: GithubHookData| match (&data.issue, &data.action) {
        (&Some(ref i), &Some(ref action)) if action == "opened" => {
            let full_name = data.repository.full_name.clone();
            let number = i.number;
            let cloned = i.clone();
            let jira_code = get_param(full_name.as_str(), "jira-project-key");
            let jira_issue_type = get_param(full_name.as_str(), "jira-issue-type-id")
                .unwrap_or(JIRA_ISSUE_ID_DEFAULT.clone());
            github::close_issue(&full_name, number)
                .map_err(Error::from)
                .and_then(move |_| future::ok(jira_code).and_then(move |e| e.map(|code|
                    jira::open_issue(
                        code,
                        cloned.title.clone(),
                        cloned.body.clone(),
                        jira_issue_type,
                    )
                )))
                .map(|e| e.and_then(|k| k))
                .and_then(move |e| {
                    let comment = if let (Some(ref jira_issue), Some(api)) = (e, &*JIRA_API) {
                        format!("{}\n[Jira]: {}browse/{}", *COMMENT, *api, jira_issue.key)
                    } else {
                        COMMENT.clone()
                    };
                    github::comment_issue(&full_name, number, comment).map_err(Error::from)
                })
                .map(|_| "")
                .responder()
        }
        _ => futures::finished("").responder()
    };
    futures::done(data).and_then(response).responder()
}
```


Overlapping Code:
```
req: HttpRequest, body: String) -> FutureResponse<&'static str> {
let data = middleware::validate(&req, body.as_bytes())
.and_then(|_| serde_json::from_str(body.as_str()).map_err(ErrorBadRequest));
let response = |data: GithubHookData| match (&data.issue, &data.action) {
(&Some(ref i), &Some(ref action)) if action == "opened" => {
let full_name = data.repository.full_name.clone();
let number = i.number;
let cloned = i.clone();
let jira_code = get_param(full_name.as_str(), "jira-project-key");
let jira_issue_type = get_param(full_name.as_str(), "jira-issue-type-id")
.unwrap_or(JIRA_ISSUE_ID_DEFAULT.clone());
github::close_issue(&full_name, number)
.map_err(Error::from)
.and_then(move |_| future::ok(jira_code).and_then(move |e| e.map(|code|
jira::open_issue(
code,
cloned.title.clone(),
cloned.body.clone(),
jira_issue_type,
)
)))
.map(|e| e.and_then(|k| k))
.and_then(move |e| {
let comment = if let (Some(ref jira_issue), Some(api)) = (e, &*JIRA_API) {
format!("{}\n[Jira]: {}browse/{}", *COMMENT, *api, jira_issue.key)
} else {
COMMENT.clone()
};
github::comment_issue(&full_name, number, comment).map_err(Error::from)
})
.map(|_| "")
.responder()
}
_ => futures::finished("").responder()
};
futures::done(data).and_then(response).responde
```
<Overlap Ratio: 0.984251968503937>

---

--- 221 --
Question ID: c15966f183f430907c8bbdb89d55eae8b1ea391a_0
Original Code:
```
pub fn init() {
    extern "C" {
        fn trap_entry();
    }
    // Set the exception vector address
    cp0::ebase::write_u32(trap_entry as u32);
    println!("Set ebase = {:x}", trap_entry as u32);

    let mut status = cp0::status::read();
    // Enable IPI
    status.enable_soft_int0();
    status.enable_soft_int1();
    // Enable clock interrupt
    status.enable_hard_int5();
    // Enable serial interrupt
    #[cfg(feature = "board_thinpad")]
    status.enable_hard_int0();

    cp0::status::write(status);
    info!("interrupt: init end");
}
```


Overlapping Code:
```
n init() {
extern "C" {
fn trap_entry();
}
// Set the exception vector address
cp0::ebase::write_u32(trap_entry as u32);
println!("Set ebase = {:x}", trap_entry as u32);
let mut status = cp0::status::read();
// Enable IPI
status.enable_soft_int0();
status.enable_soft_int1();
// Enable clock interrupt
status.enable_hard_int5();
// Enable serial interrupt
#[cfg(feature = "board_thinpad")]
status.enable_hard_int0();
cp0::status::write(status);
info!("interrupt: i
```
<Overlap Ratio: 0.9646569646569647>

---

--- 222 --
Question ID: 2b705743da96c4959e1e3738566afdb2bd9ab8d9_2
Original Code:
```
pub(crate) fn get_claims_output(claims: GetClaimsResponse) -> CommandOutput {
    let mut map = HashMap::new();
    map.insert("claims".to_string(), json!(claims));
    CommandOutput::new(claims_table(claims), map)
}
```


Overlapping Code:
```
etClaimsResponse) -> CommandOutput {
let mut map = HashMap::new();
map.insert("claims".to_string(), json!(claims));
CommandOutput::new(claims_table(cl
```
<Overlap Ratio: 0.7352941176470589>

---

--- 223 --
Question ID: 7baa3902119c9564687939545f6435bfd9a95b93_13
Original Code:
```
pub unsafe extern fn Java_com_nativesigner_EthkeyBridge_ethkeyEthSign(env: JNIEnv, _: JClass, data: JString) -> jstring {
    let data: String = env.get_string(data).expect("Invalid seed").into();
    let hex = data.from_hex().unwrap();
    let message = format!("\x19Ethereum Signed Message:\n{}", hex.len()).into_bytes();
    let mut res: [u8; 32] = [0; 32];
    let mut keccak = Keccak::new_keccak256();
    keccak.update(&message);
    keccak.update(&hex);
    keccak.finalize(&mut res);
    env.new_string(res.to_hex()).expect("Could not create java string").into_inner()
  }
```


Overlapping Code:
```
ub unsafe extern fn Java_com_nativesigner_EthkeyBridge_ethkeyEthSign(env: JNIEnv, _: JClass, data: JString) -> jstring {
let data: String = env.get_string(data).expect("Invalid seed").into();
let hex = data.from_hex().unwrap();
let message = format!("\x19Ethereum Signed Message:\n{}", hex.len()).into_bytes();
let mut res: [u8; 32] = [0; 32];
let mut keccak = Keccak::new_keccak256();
keccak.update(&message);
keccak.update(&hex);
keccak.finalize(&mut res);
env.new_string(res.to_hex()).expect("Could not create java string").into_inner()
}
```
<Overlap Ratio: 0.9981549815498155>

---

--- 224 --
Question ID: 16da93b7c0c56e8daf2f7bfd9019f1ffe2f1fd82_8
Original Code:
```
async fn _check_software_update() -> hbb_common::ResultType<()> {
    sleep(3.).await;

    let rendezvous_server = socket_client::get_target_addr(&get_rendezvous_server(1_000).await)?;
    let mut socket =
        socket_client::new_udp(Config::get_any_listen_addr(), RENDEZVOUS_TIMEOUT).await?;

    let mut msg_out = RendezvousMessage::new();
    msg_out.set_software_update(SoftwareUpdate {
        url: crate::VERSION.to_owned(),
        ..Default::default()
    });
    socket.send(&msg_out, rendezvous_server).await?;
    use hbb_common::protobuf::Message;
    if let Some(Ok((bytes, _))) = socket.next_timeout(30_000).await {
        if let Ok(msg_in) = RendezvousMessage::parse_from_bytes(&bytes) {
            if let Some(rendezvous_message::Union::software_update(su)) = msg_in.union {
                let version = hbb_common::get_version_from_url(&su.url);
                if get_version_number(&version) > get_version_number(crate::VERSION) {
                    *SOFTWARE_UPDATE_URL.lock().unwrap() = su.url;
                }
            }
        }
    }
    Ok(())
}
```


Overlapping Code:
```
date() -> hbb_common::ResultType<()> {
sleep(3.).await;
let rendezvous_server = socket_client::get_target_addr(&get_rendezvous_server(1_000).await)?;
let mut socket =
socket_client::new_udp(Config::get_any_listen_addr(), RENDEZVOUS_TIMEOUT).await?;
let mut msg_out = RendezvousMessage::new();
msg_out.set_software_update(SoftwareUpdate {
url: crate::VERSION.to_owned(),
..Default::default()
});
socket.send(&msg_out, rendezvous_server).await?;
use hbb_common::protobuf::Message;
if let Some(Ok((bytes, _))) = socket.next_timeout(30_000).await {
if let Ok(msg_in) = RendezvousMessage::parse_from_bytes(&bytes) {
if let Some(rendezvous_message::Union::software_update(su)) = msg_in.union {
let version = hbb_common::get_version_from_url(&su.url);
if get_version_number(&version) > get_version_number(crate::VERSION) {
*SOFTWARE_UPDATE_URL.lock().unwrap
```
<Overlap Ratio: 0.9381898454746137>

---

--- 225 --
Question ID: 2f1a92a4bb6b1233b02b72bac79594797b690120_1
Original Code:
```
pub fn poll_messages(sqs: &dyn Sqs, opt: &Opt) -> Result<Vec<Message>> {
    let queue_url = resolve_queue_url(sqs, opt)?;
    let request = ReceiveMessageRequest {
        queue_url: queue_url.clone(),
        wait_time_seconds: Some(20),
        ..Default::default()
    };
    let messages = sqs
        .receive_message(request)
        .sync()
        .with_context(|| PollingMessage {
            queue_url: queue_url.clone(),
        })?
        .messages
        .unwrap_or_else(Vec::new);
    Ok(messages)
}
```


Overlapping Code:
```
 poll_messages(sqs: &dyn Sqs, opt: &Opt) -> Result<Vec<Message>> {
let queue_url = resolve_queue_url(sqs, opt)?;
let request = ReceiveMessageRequest {
queue_url: queue_url.clone(),
wait_time_seconds: Some(20),
..Default::default()
};
let messages = sqs
.receive_message(request)
.sync()
.with_context(|| PollingMessage {
queue_url: queue_url.clone(),
})?
.messages
.unwrap_or_else(Vec::new);
Ok(messa
```
<Overlap Ratio: 0.970873786407767>

---

--- 226 --
Question ID: bc89e9e9e326b85be9632e14d15e420ea8bd26a0_0
Original Code:
```
pub fn version_text() -> String
{
    let version_c = unsafe { ll::Pa_GetVersionText() };
    let version_s = String::from_utf8_lossy(unsafe { CStr::from_ptr(version_c).to_bytes() });
    version_s.into_owned()
}
```


Overlapping Code:
```
pub fn version_text() -> String
{
let version_c = unsafe { ll::Pa_GetVersionText() };
let version_s = String::from_utf8_lossy(unsafe { CStr::from_ptr(version_c).to_bytes() });
version_s.into_owned()
}
```
<Overlap Ratio: 1.0>

---

--- 227 --
Question ID: 9772642bfbdc99d2ae3e94efb752408466f8e2b0_1
Original Code:
```
fn get_time_plateau() {
        let values = [1.0, 2.0, 2.0, 3.0].to_vec();
        let grid = [4.0, 5.0, 6.0, 7.0].to_vec();
        let spline = MonotoneCubicSpline::new(values, grid).unwrap();
        assert_eq!(spline.get_time(2.0), None);
    }
```


Overlapping Code:
```
_time_plateau() {
let values = [1.0, 2.0, 2.0, 3.0].to_vec();
let grid = [4.0, 5.0, 6.0, 7.0].to_vec();
let spline = MonotoneCubicSpline::new(values, grid).unwrap();
assert_eq!(spline.get_time(2.0), N
```
<Overlap Ratio: 0.9389671361502347>

---

--- 228 --
Question ID: 86d11859319c0071fd4e82037bbf2051984ed409_30
Original Code:
```
pub async fn get_capabilities(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        location: &str,
    ) -> std::result::Result<models::CapabilitiesResult, get_capabilities::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/subscriptions/{}/providers/Microsoft.HDInsight/locations/{}/capabilities",
            operation_config.base_path(),
            subscription_id,
            location
        );
        let mut url = url::Url::parse(url_str).map_err(get_capabilities::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get_capabilities::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get_capabilities::Error::BuildRequestError)?;
        let rsp = http_client
            .execute_request(req)
            .await
            .map_err(get_capabilities::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::CapabilitiesResult = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::ErrorResponse = serde_json::from_slice(rsp_body)
                    .map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get_capabilities::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
es(
operation_config: &crate::OperationConfig,
subscription_id: &str,
location: &str,
) -> std::result::Result<models::CapabilitiesResult, get_capabilities::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/subscriptions/{}/providers/Microsoft.HDInsight/locations/{}/capabilities",
operation_config.base_path(),
subscription_id,
location
);
let mut url = url::Url::parse(url_str).map_err(get_capabilities::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::GET);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(get_capabilities::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(get_capabilities::Error::BuildRequestError)?;
let rsp = http_client
.execute_request(req)
.await
.map_err(get_capabilities::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::CapabilitiesResult = serde_json::from_slice(rsp_body)
.map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::ErrorResponse = serde_json::from_slice(rsp_body)
.map_err(|source| get_capabilities::Error::DeserializeError(source, rsp_body.clone()))?;
Err(get_capabilities::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 0.9855460385438972>

---

--- 229 --
Question ID: a3f678cb64c0d4b79077f4e87ebabae14aad1a08_13
Original Code:
```
fn test_get_boot_id() -> Result<()> {
        let output = std::process::Command::new("journalctl")
            .arg("--list-boots")
            .output()
            .context("Failed to run journalctl --list-boots")?;

        if !output.status.success() {
            return Err(anyhow!("journalctl command filed: {:?}", output));
        }

        let stdout =
            std::str::from_utf8(&output.stdout).context("Failed to convert stdout to str")?;

        for line in stdout.lines() {
            let line = line.trim();
            println!("line: '{}'", line);
            if line.starts_with("0 ") {
                let (_, line) = line.split_once(" ").context("boot entry had no space")?;
                let (boot_id, _) = line
                    .split_once(" ")
                    .context("second half of boot entry has no space")?;

                assert_eq!(get_boot_id().context("Failed to get boot id")?, boot_id,);

                return Ok(());
            }
        }

        Err(anyhow!("Unable to find bootid from journalctl: {}", stdout))
    }
```


Overlapping Code:
```
test_get_boot_id() -> Result<()> {
let output = std::process::Command::new("journalctl")
.arg("--list-boots")
.output()
.context("Failed to run journalctl --list-boots")?;
if !output.status.success() {
return Err(anyhow!("journalctl command filed: {:?}", output));
}
let stdout =
std::str::from_utf8(&output.stdout).context("Failed to convert stdout to str")?;
for line in stdout.lines() {
let line = line.trim();
println!("line: '{}'", line);
if line.starts_with("0 ") {
let (_, line) = line.split_once(" ").context("boot entry had no space")?;
let (boot_id, _) = line
.split_once(" ")
.context("second half of boot entry has no space")?;
assert_eq!(get_boot_id().context("Failed to get boot id")?, boot_id,);
return Ok(());
}
}
Err(anyhow!("Unable to find bootid from journalctl: {}", stdout
```
<Overlap Ratio: 0.99125>

---

--- 230 --
Question ID: 643b923dc58756132022016e5b5e7cb8cbd18248_0
Original Code:
```
pub fn main() {
    let counter = Arc::from(Mutex::from(0));

    let mut server = AIOServer::new("0.0.0.0:7878".parse().unwrap(), move |_request| {
        let lock = counter.clone();
        let mut counter = lock.lock().unwrap();

        let body = counter.to_string();
        *counter += 1;

        ResponseBuilder::empty_200()
            .body(body.as_bytes())
            .content_type("text/plain")
            .build()
            .unwrap()
    });

    server.start();
}
```


Overlapping Code:
```
ain() {
let counter = Arc::from(Mutex::from(0));
let mut server = AIOServer::new("0.0.0.0:7878".parse().unwrap(), move |_request| {
let lock = counter.clone();
let mut counter = lock.lock().unwrap();
let body = counter.to_string();
*counter += 1;
ResponseBuilder::empty_200()
.body(body.as_bytes())
.content_type("text/plain")
.build()
.unwrap()
});
server.start();
}
```
<Overlap Ratio: 0.9786666666666667>

---

--- 231 --
Question ID: 6d44e30fb7977f64abac6ae0231baffce769296b_1
Original Code:
```
fn overwriting_insert_cancels_original() {
        let (mut reso_tx, reso_rx) = mpsc::channel(2);
        let (make0_tx, make0_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();
        let (make1_tx, make1_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();

        let mut discover = task::spawn(Discover::new(Dx(reso_rx), Svc(vec![make1_rx, make0_rx])));
        assert_pending!(discover.poll_next(), "ready without updates");

        let addr = SocketAddr::from(([127, 0, 0, 1], 80));
        reso_tx.try_send(Change::Insert(addr, ())).ok().unwrap();
        assert_pending!(discover.poll_next(), "ready without service being made");
        assert_eq!(
            discover.make_futures.futures.len(),
            1,
            "must be only one pending make"
        );
        assert_eq!(
            discover.make_futures.cancelations.len(),
            1,
            "no pending cancelation"
        );

        reso_tx
            .try_send(Change::Insert(addr, ()))
            .ok()
            .expect("update must be sent");
        assert_pending!(discover.poll_next(), "ready without service being made");
        assert_eq!(
            discover.make_futures.futures.len(),
            1,
            "must be only one pending make"
        );
        assert_eq!(
            discover.make_futures.cancelations.len(),
            1,
            "no pending cancelation"
        );

        make0_tx
            .send(Svc(vec![]))
            .expect_err("receiver must have been dropped");

        let (rsp1_tx, rsp1_rx) = oneshot::channel();
        make1_tx
            .send(Svc(vec![rsp1_rx]))
            .expect("make must receive service");
        match assert_ready!(discover.poll_next())
            .expect("discover stream mustn't end")
            .expect("discover can't fail")
        {
            Change::Remove(..) => panic!("unexpected remove"),
            Change::Insert(a, svc) => {
                assert_eq!(a, addr);
                let mut svc = mock::Spawn::new(svc);
                assert_ready_ok!(svc.poll_ready());
                let mut fut = task::spawn(svc.call(()));
                assert_pending!(fut.poll());
                rsp1_tx.send(1).unwrap();
                assert_eq!(assert_ready_ok!(fut.poll()), 1);
            }
        }
        assert!(
            discover.make_futures.cancelations.is_empty(),
            "cancelation remains"
        );
    }
```


Overlapping Code:
```
els_original() {
let (mut reso_tx, reso_rx) = mpsc::channel(2);
let (make0_tx, make0_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();
let (make1_tx, make1_rx) = oneshot::channel::<Svc<oneshot::Receiver<usize>>>();
let mut discover = task::spawn(Discover::new(Dx(reso_rx), Svc(vec![make1_rx, make0_rx])));
assert_pending!(discover.poll_next(), "ready without updates");
let addr = SocketAddr::from(([127, 0, 0, 1], 80));
reso_tx.try_send(Change::Insert(addr, ())).ok().unwrap();
assert_pending!(discover.poll_next(), "ready without service being made");
assert_eq!(
discover.make_futures.futures.len(),
1,
"must be only one pending make"
);
assert_eq!(
discover.make_futures.cancelations.len(),
1,
"no pending cancelation"
);
reso_tx
.try_send(Change::Insert(addr, ()))
.ok()
.expect("update must be sent");
assert_pending!(discover.poll_next(), "ready without service being made");
assert_eq!(
discover.make_futures.futures.len(),
1,
"must be only one pending make"
);
assert_eq!(
discover.make_futures.cancelations.len(),
1,
"no pending cancelation"
);
make0_tx
.send(Svc(vec![]))
.expect_err("receiver must have been dropped");
let (rsp1_tx, rsp1_rx) = oneshot::channel();
make1_tx
.send(Svc(vec![rsp1_rx]))
.expect("make must receive service");
match assert_ready!(discover.poll_next())
.expect("discover stream mustn't end")
.expect("discover can't fail")
{
Change::Remove(..) => panic!("unexpected remove"),
Change::Insert(a, svc) => {
assert_eq!(a, addr);
let mut svc = mock::Spawn::new(svc);
assert_ready_ok!(svc.poll_ready());
let mut fut = task::spawn(svc.call(()));
assert_pending!(fut.poll());
rsp1_tx.send(1).unwrap();
assert_eq!(assert_ready_ok!(fut.poll()), 1);
}
}
assert!(
discover.make_futures.cancelations.is_empty(),
"cancelation remains"
);
```
<Overlap Ratio: 0.9844271412680756>

---

--- 232 --
Question ID: c99abd8418188c8f19084063d7317e1236f02481_0
Original Code:
```
fn test_exchange_local_cluster() {
    solana_logger::setup();

    const NUM_NODES: usize = 1;

    let mut config = Config::default();
    config.identity = Keypair::new();
    config.duration = Duration::from_secs(1);
    config.fund_amount = 100_000;
    config.threads = 1;
    config.transfer_delay = 20; // 15
    config.batch_size = 100; // 1000;
    config.chunk_size = 10; // 200;
    config.account_groups = 1; // 10;
    let Config {
        fund_amount,
        batch_size,
        account_groups,
        ..
    } = config;
    let accounts_in_groups = batch_size * account_groups;

    let cluster = LocalCluster::new(&ClusterConfig {
        node_stakes: vec![100_000; NUM_NODES],
        cluster_lamports: 100_000_000_000_000,
        validator_configs: vec![ValidatorConfig::default(); NUM_NODES],
        native_instruction_processors: [solana_exchange_program!()].to_vec(),
        ..ClusterConfig::default()
    });

    let faucet_keypair = Keypair::new();
    cluster.transfer(
        &cluster.funding_keypair,
        &faucet_keypair.pubkey(),
        2_000_000_000_000,
    );

    let (addr_sender, addr_receiver) = channel();
    run_local_faucet(faucet_keypair, addr_sender, Some(1_000_000_000_000));
    let faucet_addr = addr_receiver.recv_timeout(Duration::from_secs(2)).unwrap();

    info!("Connecting to the cluster");
    let (nodes, _) =
        discover_cluster(&cluster.entry_point_info.gossip, NUM_NODES).unwrap_or_else(|err| {
            error!("Failed to discover {} nodes: {:?}", NUM_NODES, err);
            exit(1);
        });

    let (client, num_clients) = get_multi_client(&nodes);

    info!("clients: {}", num_clients);
    assert!(num_clients >= NUM_NODES);

    const NUM_SIGNERS: u64 = 2;
    airdrop_lamports(
        &client,
        &faucet_addr,
        &config.identity,
        fund_amount * (accounts_in_groups + 1) as u64 * NUM_SIGNERS,
    );

    do_bench_exchange(vec![client], config);
}
```


Overlapping Code:
```
e_local_cluster() {
solana_logger::setup();
const NUM_NODES: usize = 1;
let mut config = Config::default();
config.identity = Keypair::new();
config.duration = Duration::from_secs(1);
config.fund_amount = 100_000;
config.threads = 1;
config.transfer_delay = 20; // 15
config.batch_size = 100; // 1000;
config.chunk_size = 10; // 200;
config.account_groups = 1; // 10;
let Config {
fund_amount,
batch_size,
account_groups,
..
} = config;
let accounts_in_groups = batch_size * account_groups;
let cluster = LocalCluster::new(&ClusterConfig {
node_stakes: vec![100_000; NUM_NODES],
cluster_lamports: 100_000_000_000_000,
validator_configs: vec![ValidatorConfig::default(); NUM_NODES],
native_instruction_processors: [solana_exchange_program!()].to_vec(),
..ClusterConfig::default()
});
let faucet_keypair = Keypair::new();
cluster.transfer(
&cluster.funding_keypair,
&faucet_keypair.pubkey(),
2_000_000_000_000,
);
let (addr_sender, addr_receiver) = channel();
run_local_faucet(faucet_keypair, addr_sender, Some(1_000_000_000_000));
let faucet_addr = addr_receiver.recv_timeout(Duration::from_secs(2)).unwrap();
info!("Connecting to the cluster");
let (nodes, _) =
discover_cluster(&cluster.entry_point_info.gossip, NUM_NODES).unwrap_or_else(|err| {
error!("Failed to discover {} nodes: {:?}", NUM_NODES, err);
exit(1);
});
let (client, num_clients) = get_multi_client(&nodes);
info!("clients: {}", num_clients);
assert!(num_clients >= NUM_NODES);
const NUM_SIGNERS: u64 = 2;
airdrop_lamports(
&client,
&faucet_addr,
&config.identity,
fund_amount * (accounts_in_groups + 1) as u64 * NUM_SIGNERS,
);
do_b
```
<Overlap Ratio: 0.9679370840895342>

---

--- 233 --
Question ID: fce0772a0a7905475a77d33819d2513a777217be_0
Original Code:
```
fn with_deps() {
    if !cargo_test_support::is_nightly() {
        return;
    }

    Package::new("bar", "0.0.1").publish();

    let p = project()
        .file(
            "Cargo.toml",
            r#"
                [package]
                name = "test"
                version = "0.0.0"

                [dependencies]
                bar = "*"

                [profile.release]
                lto = true
            "#,
        )
        .file("src/main.rs", "extern crate bar; fn main() {}")
        .build();
    p.cargo("build -v --release")
        .with_stderr_contains("[..]`rustc[..]--crate-name bar[..]-Clinker-plugin-lto[..]`")
        .with_stderr_contains("[..]`rustc[..]--crate-name test[..]-C lto[..]`")
        .run();
}
```


Overlapping Code:
```
() {
if !cargo_test_support::is_nightly() {
return;
}
Package::new("bar", "0.0.1").publish();
let p = project()
.file(
"Cargo.toml",
r#"
[package]
name = "test"
version = "0.0.0"
[dependencies]
bar = "*"
[profile.release]
lto = true
"#,
)
.file("src/main.rs", "extern crate bar; fn main() {}")
.build();
p.cargo("build -v --release")
.with_stderr_contains("[..]`rustc[..]--crate-name bar[..]-Clinker-plugin-lto[..]`")
.with_stderr_contains("[..]`rustc[..]--crate-name test[..]-C lto[..]
```
<Overlap Ratio: 0.9510763209393346>

---

--- 234 --
Question ID: 2e0077dc429ff52d794f204d90700dcbf97629cc_11
Original Code:
```
fn dir_to_symlink2file() {
            let id = function_name!();

            prepare_test(id).unwrap();
            mkdir(id, "d1").unwrap();
            mkfile(id, "f1").unwrap();
            mklink(id, "f1", "lf1").unwrap();

            let dry_run = false;
            let sources: Vec<PathBuf> = vec![mkpathbuf(id, "d1")];
            let dests: Vec<String> = vec![mkpathstring(id, "lf1")];
            let num_errors = move_files(&sources, &dests, dry_run, false, false, None);

            assert_eq!(num_errors, 1);
            assert!(mkpathbuf(id, "d1").is_dir());
            assert!(mkpathbuf(id, "f1").is_file());
        }
```


Overlapping Code:
```
() {
let id = function_name!();
prepare_test(id).unwrap();
mkdir(id, "d1").unwrap();
mkfile(id, "f1").unwrap();
mklink(id, "f1", "lf1").unwrap();
let dry_run = false;
let sources: Vec<PathBuf> = vec![mkpathbuf(id, "d1")];
let dests: Vec<String> = vec![mkpathstring(id, "lf1")];
let num_errors = move_files(&sources, &dests, dry_run, false, false, None);
assert_eq!(num_errors, 1);
assert!(mkpathbuf(id, "d1").is_dir
```
<Overlap Ratio: 0.8592132505175983>

---

--- 235 --
Question ID: 69d79862ae718ec94527537ad649cafd3f6b37bd_0
Original Code:
```
fn test_default() {
        let default = Packet::default();
        assert_eq!(default.length, 0);
        assert_eq!(default.window, None);
        assert_eq!(default.timestamp, Duration::default());
        assert_eq!(default.flag_list, BTreeSet::default());
        assert_eq!(default.network_protocol, 0);
        assert_eq!(default.network_payload_length, None);
        assert_eq!(default.network_header_length, None);
        assert_eq!(default.position, 0);
    }
```


Overlapping Code:
```
 Packet::default();
assert_eq!(default.length, 0);
assert_eq!(default.window, None);
assert_eq!(default.timestamp, Duration::default());
assert_eq!(default.flag_list, BTreeSet::default());
assert_eq!(default.network_protocol, 0);
assert_eq!(default.network_payload_length, None);
assert_eq!(default.network_header_length, None);
assert_eq!(default.po
```
<Overlap Ratio: 0.8838383838383839>

---

--- 236 --
Question ID: c22d1b390ddb37673011d48115f7eff877e8e036_0
Original Code:
```
async fn retrieve_secret() -> ashpd::Result<Vec<u8>> {
    let proxy = secret::SecretProxy::new().await?;

    let (mut x1, x2) = std::os::unix::net::UnixStream::pair().unwrap();
    proxy.retrieve_secret(&x2).await?;
    drop(x2);
    let mut buf = Vec::new();
    x1.read_to_end(&mut buf)?;

    Ok(buf)
}
```


Overlapping Code:
```
ieve_secret() -> ashpd::Result<Vec<u8>> {
let proxy = secret::SecretProxy::new().await?;
let (mut x1, x2) = std::os::unix::net::UnixStream::pair().unwrap();
proxy.retrieve_secret(&x2).await?;
drop(x2);
let mut buf = Vec::new();
x1.read_to_end(&mut bu
```
<Overlap Ratio: 0.9025270758122743>

---

--- 237 --
Question ID: a3a5ca7f1d9478030df1a39c22d53d4ee7be032c_6
Original Code:
```
fn it_pushes_buffer_to_the_read_queue() {
                let mut read_buf: VecDeque<Vec<u8>> = VecDeque::new();

                let _ = handle_recv_res(Ok(vec![1, 2, 3]), &mut read_buf);

                assert_eq!(read_buf[0], vec![1, 2, 3]);
            }
```


Overlapping Code:
```
 {
let mut read_buf: VecDeque<Vec<u8>> = VecDeque::new();
let _ = handle_recv_res(Ok(vec![1, 2, 3]), &mut read_buf);
assert_eq!(read_buf[0], vec![1, 2
```
<Overlap Ratio: 0.7614213197969543>

---

--- 238 --
Question ID: c6c013b8a8496fc871b61771bf9a35c2086851e6_5
Original Code:
```
pub(crate) async fn add_item<A>(request: Request<AppData<A>>) -> tide::Result<Response>
where
    A: Authentication + Clone + Send + Sync + 'static,
{
    #[derive(Deserialize)]
    struct Q {
        internal_list_id: String,
        problem_id: String,
    }
    let (query, conn, _) = request.post_unpack::<Q>().await?;
    conn.add_item(&query.internal_list_id, &query.problem_id)?;
    let response = Response::ok().body_json(&serde_json::json!({}))?;
    Ok(response)
}
```


Overlapping Code:
```
b(crate) async fn add_item<A>(request: Request<AppData<A>>) -> tide::Result<Response>
where
A: Authentication + Clone + Send + Sync + 'static,
{
#[derive(Deserialize)]
struct Q {
internal_list_id: String,
problem_id: String,
}
let (query, conn, _) = request.post_unpack::<Q>().await?;
conn.add_item(&query.internal_list_id, &query.problem_id)?;
let response = Response::ok().body_json(&serde_json::json!({}))?;
Ok(response)

```
<Overlap Ratio: 0.9929742388758782>

---

--- 239 --
Question ID: 9f9b27c2e456cf11cbf1d4c220fbb713b5da6596_0
Original Code:
```
fn main () {

    let start = ::std::time::Instant::now();

    let send = Arc::new(Mutex::new(0));
    let send2 = send.clone();

    let inspect = ::std::env::args().find(|x| x == "inspect").is_some();

    timely::execute_from_args(std::env::args(), move |root| {

        let send = send.clone();

        // used to partition graph loading
        let index = root.index();
        let peers = root.peers();

        let plan_filename = std::env::args().nth(3).unwrap();
        let plan = count_vertex_labeled_query_plan::read_plan(&plan_filename);

        // handles to input and probe, but also both indices so we can compact them.
        let (mut input, forward_probe, reverse_probe, probe, handles) = root.dataflow::<u32,_,_>(|builder| {

            // Please see triangles for more information on "graph" and dG.
            let (graph, dG) = builder.new_input::<((u32, u32), i32)>();
            //let dG_init = dG.map(|((src,dst),wgt)| (vec![src,dst],wgt));
            // Our query is K3 = A(x,y) B(x,z) C(y,z): triangles..

            let (graph_index, handles) = GraphStreamIndex::from(Vec::new().to_stream(builder), dG, |k| k as u64, |k| k as u64);

            let mut probe = ProbeHandle::new();

            plan.track_motif(&graph_index, &mut probe, send);

            (graph, graph_index.forward.handle , graph_index.reverse.handle, probe, handles)
        });

        // load fragment of input graph into memory to avoid io while running.
        let filename = std::env::args().nth(1).unwrap();
        let graph = GraphMMap::new(&filename);

        let nodes = graph.nodes();
        let mut edges = Vec::new();

        for node in 0 .. graph.nodes() {
            if node % peers == index {
                edges.push(graph.edges(node).to_vec());
            }
        }

        drop(graph);

        // synchronize with other workers.
        let prev = input.time().clone();
        input.advance_to(prev.inner + 1);
        root.step_while(|| probe.less_than(input.time()));

        // number of nodes introduced at a time
        let batch: usize = std::env::args().nth(2).unwrap().parse().unwrap();

        // start the experiment!
        let start = ::std::time::Instant::now();
        let mut batch_start = ::std::time::Instant::now();
        let mut batch_mid: std::time::Instant;
        let mut batch_end: std::time::Instant;
        for node in 0 .. nodes {

            // introduce the node if it is this worker's responsibility
            if node % peers == index {
                for &edge in &edges[node / peers] {
                    if node as u32 != edge{
                        input.send(((node as u32, edge), 1));
                    }
                }
            }

            // if at a batch boundary, advance time and do work.
            if node % batch == (batch - 1) {
                let prev = input.time().clone();
                input.advance_to(prev.inner + 1);

                root.step_while(|| forward_probe.less_than(inputQ.time()) ||reverse_probe.less_than(inputQ.time()));
                batch_mid = ::std::time::Instant::now();

                root.step_while(|| probe.less_than(input.time()));
                batch_end = ::std::time::Instant::now();

                println!("After io: {:?}", batch_mid.duration_since(batch_start));
                println!("After batch: {:?}", batch_end.duration_since(batch_start));

                batch_start = ::std::time::Instant::now();
                // merge all of the indices we maintain.
                handles.merge_to(&prev);


            }
        }

        input.close();
        while root.step() { }

        if inspect {
            println!("worker {} elapsed: {:?}", index, start.elapsed());
        }

    }).unwrap();

    let total = if let Ok(lock) = send2.lock() {
        *lock
    }
    else { 0 };

    if inspect {
        println!("elapsed: {:?}\ttotal triangles at this process: {:?}", start.elapsed(), total);
    }
}
```


Overlapping Code:
```
in () {
let start = ::std::time::Instant::now();
let send = Arc::new(Mutex::new(0));
let send2 = send.clone();
let inspect = ::std::env::args().find(|x| x == "inspect").is_some();
timely::execute_from_args(std::env::args(), move |root| {
let send = send.clone();
// used to partition graph loading
let index = root.index();
let peers = root.peers();
let plan_filename = std::env::args().nth(3).unwrap();
let plan = count_vertex_labeled_query_plan::read_plan(&plan_filename);
// handles to input and probe, but also both indices so we can compact them.
let (mut input, forward_probe, reverse_probe, probe, handles) = root.dataflow::<u32,_,_>(|builder| {
// Please see triangles for more information on "graph" and dG.
let (graph, dG) = builder.new_input::<((u32, u32), i32)>();
//let dG_init = dG.map(|((src,dst),wgt)| (vec![src,dst],wgt));
// Our query is K3 = A(x,y) B(x,z) C(y,z): triangles..
let (graph_index, handles) = GraphStreamIndex::from(Vec::new().to_stream(builder), dG, |k| k as u64, |k| k as u64);
let mut probe = ProbeHandle::new();
plan.track_motif(&graph_index, &mut probe, send);
(graph, graph_index.forward.handle , graph_index.reverse.handle, probe, handles)
});
// load fragment of input graph into memory to avoid io while running.
let filename = std::env::args().nth(1).unwrap();
let graph = GraphMMap::new(&filename);
let nodes = graph.nodes();
let mut edges = Vec::new();
for node in 0 .. graph.nodes() {
if node % peers == index {
edges.push(graph.edges(node).to_vec());
}
}
drop(graph);
// synchronize with other workers.
let prev = input.time().clone();
input.advance_to(prev.inner + 1);
root.step_while(|| probe.less_than(input.time()));
// number of nodes introduced at a time
let batch: usize = std::env::args().nth(2).unwrap().parse().unwrap();
// start the experiment!
let start = ::std::time::Instant::now();
let mut batch_start = ::std::time::Instant::now();
let mut batch_mid: std::time::Instant;
let mut batch_end: std::time::Instant;
for node in 0 .. nodes {
// introduce the node if it is this worker's responsibility
if no
```
<Overlap Ratio: 0.9975798644724104>

---

--- 240 --
Question ID: b9c203f0b0253606b8cc6eb3e34c618fb7426327_6
Original Code:
```
async fn consume_from_queues_should_be_ok() {
    let client = new_client(3, 10);
    let pairs = [
        (new_queue("rustqueue1"), b"hello1"),
        (new_queue("rustqueue2"), b"hello2"),
    ];
    let mut last_job_id = String::from("");
    // Firstly, publish 4 messages
    for (queue, msg) in pairs.iter() {
        let _ret = client
            .publish(String::from(queue), "".to_string(), msg.to_vec(), 0, 1, 0)
            .await
            .map(|(job_id, _request_id)| {
                last_job_id = job_id.clone();
            })
            .map_err(|e| {
                println!("err: {:#?}", e);
                assert!(false, "should succeed");
            });
    }

    println!("last job id: {:#?}", last_job_id);
    let mut queues = pairs
        .iter()
        .map(|(queue, _msg)| queue.clone())
        .collect::<Vec<String>>();
    // Reverse queue vector
    queues.reverse();
    let _ret = client
        .consume_from_queues(queues, 10, 1)
        .await
        .map(|jobs| {
            let job = &jobs[0];
            let decoded_message = &decode(job.data.clone()).unwrap()[..];
            assert_eq!(b"hello2", decoded_message, "message content should match");
        })
        .map_err(|e| {
            println!("err: {:#?}", e);
            assert!(false, "should succeed");
        });
}
```


Overlapping Code:
```
es_should_be_ok() {
let client = new_client(3, 10);
let pairs = [
(new_queue("rustqueue1"), b"hello1"),
(new_queue("rustqueue2"), b"hello2"),
];
let mut last_job_id = String::from("");
// Firstly, publish 4 messages
for (queue, msg) in pairs.iter() {
let _ret = client
.publish(String::from(queue), "".to_string(), msg.to_vec(), 0, 1, 0)
.await
.map(|(job_id, _request_id)| {
last_job_id = job_id.clone();
})
.map_err(|e| {
println!("err: {:#?}", e);
assert!(false, "should succeed");
});
}
println!("last job id: {:#?}", last_job_id);
let mut queues = pairs
.iter()
.map(|(queue, _msg)| queue.clone())
.collect::<Vec<String>>();
// Reverse queue vector
queues.reverse();
let _ret = client
.consume_from_queues(queues, 10, 1)
.await
.map(|jobs| {
let job = &jobs[0];
let decoded_message = &decode(job.data.clone()).unwrap()[..];
assert_eq!(b"hello2", decoded_message, "message content should match");
})
.map_err(|e| {
println!("err: {:#?}", e);
assert!(false, "should succeed");
});

```
<Overlap Ratio: 0.973293768545994>

---

--- 241 --
Question ID: cfbd8611df1a82b1527afff643ee2da12766a721_0
Original Code:
```
pub fn builder_from_image_view<T>(image: &T) -> wgpu::TextureBuilder
where
    T: image::GenericImageView,
    T::Pixel: Pixel,
{
    let (width, height) = image.dimensions();
    let format = <T::Pixel as Pixel>::TEXTURE_FORMAT;
    wgpu::TextureBuilder::new()
        .size([width, height])
        .format(format)
}
```


Overlapping Code:
```
rom_image_view<T>(image: &T) -> wgpu::TextureBuilder
where
T: image::GenericImageView,
T::Pixel: Pixel,
{
let (width, height) = image.dimensions();
let format = <T::Pixel as Pixel>::TEXTURE_FORMAT;
wgpu::TextureBuilder::new()
.size([width, height])
.
```
<Overlap Ratio: 0.8865248226950354>

---

--- 242 --
Question ID: 818ad2ea6f5b99878c825b782daa13bf632c8773_4
Original Code:
```
async fn api_server_publish_dummy() {
    let prover_timeout = time::Duration::from_secs(1);
    let rounds_interval = time::Duration::from_secs(10);
    let addr = spawn_server(prover_timeout, rounds_interval).await;

    let client = reqwest::Client::new();
    let res = client
        .post(&format!("http://{}/publish", &addr))
        .json(&client::PublishReq {
            block: 1,
            proof: EncodedProofPlonk::default(),
        })
        .send()
        .await
        .expect("failed to send publish request");

    assert_eq!(res.status(), reqwest::StatusCode::OK);
}
```


Overlapping Code:
```
async fn api_server_publish_dummy() {
let prover_timeout = time::Duration::from_secs(1);
let rounds_interval = time::Duration::from_secs(10);
let addr = spawn_server(prover_timeout, rounds_interval).await;
let client = reqwest::Client::new();
let res = client
.post(&format!("http://{}/publish", &addr))
.json(&client::PublishReq {
block: 1,
proof: EncodedProofPlonk::default(),
})
.send()
.await
.expect("failed to send publish request");
assert_eq!(res.status(), reqwest::StatusCode::OK);

```
<Overlap Ratio: 0.9979674796747967>

---

--- 243 --
Question ID: 1e70aaf4c4126e8dc5e222de9a8bc0272cfe5f00_26
Original Code:
```
fn when_i_pop_a_node_off_the_frontier_for_which_multiple_copies_have_been_added_then_i_retrieve_the_one_with_longest_path(){
        let pe = Arc::new(PartialAssignment::SingleExtension {
            decision: Decision {variable: Variable(0), value: 4},
            parent: Arc::new(PartialAssignment::Empty) });

        let pf = Arc::new(PartialAssignment::SingleExtension {
            decision: Decision {variable: Variable(1), value: 5},
            parent: Arc::new(PartialAssignment::Empty) });

        let ne = FrontierNode{
            state: Arc::new(5),
            path: Arc::clone(&pe),
            lp_len: 4,
            ub: 5
        };
        let nf = FrontierNode{
            state: Arc::new(5),
            path: Arc::clone(&pf),
            lp_len: 5,
            ub: 5
        };

        let mut frontier = empty_frontier();
        frontier.push(ne);
        frontier.push(nf.clone());

        assert_eq!(frontier.pop(), Some(nf));
    }
```


Overlapping Code:
```
ff_the_frontier_for_which_multiple_copies_have_been_added_then_i_retrieve_the_one_with_longest_path(){
let pe = Arc::new(PartialAssignment::SingleExtension {
decision: Decision {variable: Variable(0), value: 4},
parent: Arc::new(PartialAssignment::Empty) });
let pf = Arc::new(PartialAssignment::SingleExtension {
decision: Decision {variable: Variable(1), value: 5},
parent: Arc::new(PartialAssignment::Empty) });
let ne = FrontierNode{
state: Arc::new(5),
path: Arc::clone(&pe),
lp_len: 4,
ub: 5
};
let nf = FrontierNode{
state: Arc::new(5),
path: Arc::clone(&pf),
lp_len: 5,
ub: 5
};
let mut frontier = empty_frontier();
frontier.push(ne);
frontier.push(nf.clone());
assert_eq!(frontier.pop(), Som
```
<Overlap Ratio: 0.957592339261286>

---

--- 244 --
Question ID: eb4a7f0cf16db2c4d6993b96097381694a859e9d_43
Original Code:
```
fn test_match_repetition_13() {
        // r"A{,3}"
        let re = Re::new(rep!(sym![sgl!('A')], None, Some(3)));
        assert!(!re.is_match("AAAA"));
    }
```


Overlapping Code:
```
A{,3}"
let re = Re::new(rep!(sym![sgl!('A')], None, Some(3)))
```
<Overlap Ratio: 0.4621212121212121>

---

--- 245 --
Question ID: 90ebf681387d823b30b2b9bbbe1f69d372064d4c_0
Original Code:
```
fn main() {
    use std::io::Read;
    let mut log = String::new();
    std::io::stdin().read_to_string(&mut log).unwrap();
    let profile: data::Profile<AnyMetadata> = log.parse().unwrap();
    let events = IntervalTranslator::run(&profile);
    serde_json::to_writer(std::io::stdout(), &events).unwrap();
}
```


Overlapping Code:
```
fn main() {
use std::io::Read;
let mut log = String::new();
std::io::stdin().read_to_string(&mut log).unwrap();
let profile: data::Profile<AnyMetadata> = log.parse().unwrap();
let events = IntervalTranslator::run(&profile);
serde_json::to_writer(std::io::stdout(), &events).unwrap
```
<Overlap Ratio: 0.9824561403508771>

---

--- 246 --
Question ID: 12b26aafa5ab2a08f5e787850541b93ead0996b2_1
Original Code:
```
fn join2() {
    let (c1, p1) = oneshot::channel::<i32>();
    let (c2, p2) = oneshot::channel::<i32>();
    let (tx, rx) = mpsc::channel();
    run(future::try_join(p1, p2).map_ok(move |v| tx.send(v).unwrap()));
    assert!(rx.try_recv().is_err());
    c1.send(1).unwrap();
    assert!(rx.try_recv().is_err());
    c2.send(2).unwrap();
    assert_eq!(rx.recv(), Ok((1, 2)));
    assert!(rx.recv().is_err());
}
```


Overlapping Code:
```
) {
let (c1, p1) = oneshot::channel::<i32>();
let (c2, p2) = oneshot::channel::<i32>();
let (tx, rx) = mpsc::channel();
run(future::try_join(p1, p2).map_ok(move |v| tx.send(v).unwrap()));
assert!(rx.try_recv().is_err());
c1.send(1).unwrap();
assert!(rx.try_recv().is_err());
c2.send(2).unwrap();
assert_eq!(rx.recv(), Ok((1, 2)));
assert!(rx.recv().is_err());

```
<Overlap Ratio: 0.972972972972973>

---

--- 247 --
Question ID: 32ebf28a490bb53048432bc3da7d5c9a52d6abae_2
Original Code:
```
fn when_the_problem_is_solved_best_lb_is_best_value() {
        let problem = Knapsack {
            capacity: 50,
            profit  : vec![60, 100, 120],
            weight  : vec![10,  20,  30]
        };
        let mdd        = mdd_builder(&problem, KPRelax).into_deep();
        let mut solver = ParallelSolver::new(mdd);
        let _ = solver.maximize();
        assert_eq!(220, solver.best_lower_bound());
    }
```


Overlapping Code:
```
n when_the_problem_is_solved_best_lb_is_best_value() {
let problem = Knapsack {
capacity: 50,
profit : vec![60, 100, 120],
weight : vec![10, 20, 30]
};
let mdd = mdd_builder(&problem, KPRelax).into_deep();
let mut solver = ParallelSolver::new(mdd);
let _ = solver.maximize();
assert_eq!(220, solver
```
<Overlap Ratio: 0.9254658385093167>

---

--- 248 --
Question ID: a3e1cc779be440c1ba82f2dd31af7e55ab36bb91_0
Original Code:
```
fn main() -> Result<(), Error> {
    let event_loop = EventLoop::new();
    let mut world = Context::new();
    let cpus = num_cpus::get();
    let mut deepness: f64 = 0.0;
    if (world.height % cpus as u32) != 0 {
        println!("WARNING: HardCoded resolution height({}) should be divisable by the number of threads:{}",world.height,cpus)
    }

    let window = {
        let size =
            LogicalSize::new(world.width as f64, world.height as f64).to_physical::<f64>(1.0);
        WindowBuilder::new()
            .with_title("Rusty Mandelbrot")
            .with_inner_size(size)
            .with_min_inner_size(size)
            .with_resizable(false)
            .build(&event_loop)
            .unwrap()
    };

    let mut pixels = {
        let surface = Surface::create(&window);
        let surface_texture = SurfaceTexture::new(world.width, world.height, surface);
        Pixels::new(world.width, world.height, surface_texture)?
    };

    event_loop.run(move |event, _, control_flow| {
        *control_flow = ControlFlow::Wait;

        match event {
            Event::WindowEvent {
                event: WindowEvent::CloseRequested,
                ..
            } => *control_flow = ControlFlow::Exit,
            Event::WindowEvent {
                event: WindowEvent::CursorMoved { position, .. },
                ..
            } => match world.left_button {
                ButtonState::JustPressed => {
                    world.coordenate_clicked.x = position.x;
                    world.coordenate_clicked.y = position.y;
                    world.left_button = ButtonState::Pressed;
                }
                ButtonState::Pressed => {
                    world.delta.x = world.k_x * (position.x - world.coordenate_clicked.x);
                    world.delta.y = world.k_y * (world.coordenate_clicked.y - position.y);
                    window.request_redraw();
                }
                _ => (),
            },
            Event::WindowEvent {
                event: WindowEvent::MouseInput { state, button, .. },
                ..
            } => {
                if button == winit::event::MouseButton::Left {
                    if state == winit::event::ElementState::Pressed {
                        world.left_button = ButtonState::JustPressed;
                    } else {
                        world.left_button = ButtonState::Releassed;
                        world.up_left = Point {
                            x: world.up_left.x - world.delta.x,
                            y: world.up_left.y - world.delta.y,
                        };
                        world.down_right = Point {
                            x: world.down_right.x - world.delta.x,
                            y: world.down_right.y - world.delta.y,
                        };
                        window.request_redraw();
                    }
                }
            }
            Event::WindowEvent {
                event: WindowEvent::MouseWheel { delta, .. },
                ..
            } => {
                let width_excursion = (world.down_right.x - world.up_left.x) / world.zoom_factor;
                let height_excursion = (world.up_left.y - world.down_right.y) / world.zoom_factor;

                if delta == winit::event::MouseScrollDelta::LineDelta(0.0, 1.0) {
                    deepness = width_excursion / world.zoom_factor;
                    world.up_left = Point {
                        x: world.up_left.x + width_excursion / world.zoom_factor,
                        y: world.up_left.y - height_excursion / world.zoom_factor,
                    };
                    world.down_right = Point {
                        x: world.down_right.x - height_excursion / world.zoom_factor,
                        y: world.down_right.y + height_excursion / world.zoom_factor,
                    };
                } else {
                    deepness = width_excursion * world.zoom_factor;
                    world.up_left = Point {
                        x: world.up_left.x - width_excursion * world.zoom_factor,
                        y: world.up_left.y + height_excursion * world.zoom_factor,
                    };
                    world.down_right = Point {
                        x: world.down_right.x + height_excursion * world.zoom_factor,
                        y: world.down_right.y - height_excursion * world.zoom_factor,
                    };
                }
                world.k_x = (world.down_right.x - world.up_left.x) / (world.width as f64);
                world.k_y = (world.up_left.y - world.down_right.y) / (world.width as f64);
                println!("Deepness: {}", deepness);
                window.request_redraw();
            }
            Event::RedrawRequested(_) => {
                let start = Instant::now();
                if world.left_button == ButtonState::Pressed {
                    let snapshot_up_left = Point {
                        x: world.up_left.x - world.delta.x,
                        y: world.up_left.y - world.delta.y,
                    };
                    let snapshot_donw_right = Point {
                        x: world.down_right.x - world.delta.x,
                        y: world.down_right.y - world.delta.y,
                    };

                    world.parallel_draw_low_res(
                        pixels.get_frame(),
                        snapshot_up_left,
                        snapshot_donw_right,
                        cpus as u32,
                    );
                } else {
                    world.parallel_draw(pixels.get_frame(), cpus as u32);
                }
                let duration = start.elapsed();
                pixels.render();
                println!("Frame time: {:?}", duration);
            }
            _ => (),
        }
    });
}
```


Overlapping Code:
```
main() -> Result<(), Error> {
let event_loop = EventLoop::new();
let mut world = Context::new();
let cpus = num_cpus::get();
let mut deepness: f64 = 0.0;
if (world.height % cpus as u32) != 0 {
println!("WARNING: HardCoded resolution height({}) should be divisable by the number of threads:{}",world.height,cpus)
}
let window = {
let size =
LogicalSize::new(world.width as f64, world.height as f64).to_physical::<f64>(1.0);
WindowBuilder::new()
.with_title("Rusty Mandelbrot")
.with_inner_size(size)
.with_min_inner_size(size)
.with_resizable(false)
.build(&event_loop)
.unwrap()
};
let mut pixels = {
let surface = Surface::create(&window);
let surface_texture = SurfaceTexture::new(world.width, world.height, surface);
Pixels::new(world.width, world.height, surface_texture)?
};
event_loop.run(move |event, _, control_flow| {
*control_flow = ControlFlow::Wait;
match event {
Event::WindowEvent {
event: WindowEvent::CloseRequested,
..
} => *control_flow = ControlFlow::Exit,
Event::WindowEvent {
event: WindowEvent::CursorMoved { position, .. },
..
} => match world.left_button {
ButtonState::JustPressed => {
world.coordenate_clicked.x = position.x;
world.coordenate_clicked.y = position.y;
world.left_button = ButtonState::Pressed;
}
ButtonState::Pressed => {
world.delta.x = world.k_x * (position.x - world.coordenate_clicked.x);
world.delta.y = world.k_y * (world.coordenate_clicked.y - position.y);
window.request_redraw();
}
_ => (),
},
Event::WindowEvent {
event: WindowEvent::MouseInput { state, button, .. },
..
} => {
if button == winit::event::MouseButton::Left {
if state == winit::event::ElementState::Pressed {
world.left_button = ButtonState::JustPressed;
} else {
world.left_button = ButtonState::Releassed;
world.up_left = Poin
```
<Overlap Ratio: 0.987549518958687>

---

--- 249 --
Question ID: 35c25f8a0913567c1d2b5889c5a5ed641666c27b_0
Original Code:
```
fn point_add_sub() {
        let p0 = super::Point::origin();

        assert_eq!(0, p0.x);
        assert_eq!(0, p0.y);

        let p1 = p(1, -1);

        assert_eq!(1, p1.x);
        assert_eq!(-1, p1.y);

        let p2 = p1.add(1, 2);

        assert_eq!(2, p2.x);
        assert_eq!(1, p2.y);

        let p2 = p2 + p2;

        assert_eq!(4, p2.x);
        assert_eq!(2, p2.y);

        let p2 = p2 - p1;

        assert_eq!(3, p2.x);
        assert_eq!(3, p2.y);
    }
```


Overlapping Code:
```
 p0 = super::Point::origin();
assert_eq!(0, p0.x);
assert_eq!(0, p0.y);
let p1 = p(1, -1);
assert_eq!(1, p1.x);
assert_eq!(-1, p1.y);
let p2 = p1.add(1, 2);
assert_eq!(2, p2.x);
assert_eq!(1, p2.y);
let p2 = p2 + p2;
assert_eq!(4, p2.x);
assert_eq!(2, p2.y);
let p2 = p2 - p1;
assert_eq!(3, p2.x);
as
```
<Overlap Ratio: 0.872093023255814>

---

--- 250 --
Question ID: 0b596157697b3f80ac1442fdec27367b058934db_4
Original Code:
```
fn test_part1() {
        let input = "\
            ..##.........##.........##.........##.........##.........##.......  --->\n\
            #...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\n\
            .#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\n\
            ..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\n\
            .#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\n\
            ..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  --->\n\
            .#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\n\
            .#........#.#........#.#........#.#........#.#........#.#........#\n\
            #.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...\n\
            #...##....##...##....##...##....##...##....##...##....##...##....#\n\
            .#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\n\
            ";
        let expected_output = "\
            ..##.........##.........##.........##.........##.........##.......  --->\n\
            #..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\n\
            .#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\n\
            ..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\n\
            .#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\n\
            ..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  --->\n\
            .#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\n\
            .#........#.#........X.#........#.#........#.#........#.#........#\n\
            #.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...\n\
            #...##....##...##....##...#X....##...##....##...##....##...##....#\n\
            .#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  --->\n\
            ";

        let output = solve(mk_input(false, input)).unwrap();

        assert_eq!(expected_output.to_string(), output.runs[0].rendered);
        assert_eq!(7, output.product);
    }
```


Overlapping Code:
```
t = "\
..##.........##.........##.........##.........##.........##....... --->\n\
#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\n\
.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\n\
..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\n\
.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\n\
..#.##.......#.##.......#.##.......#.##.......#.##.......#.##..... --->\n\
.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\n\
.#........#.#........#.#........#.#........#.#........#.#........#\n\
#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...\n\
#...##....##...##....##...##....##...##....##...##....##...##....#\n\
.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.# --->\n\
";
let expected_output = "\
..##.........##.........##.........##.........##.........##....... --->\n\
#..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..\n\
.#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.\n\
..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#\n\
.#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.\n\
..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##..... --->\n\
.#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#\n\
.#........#.#........X.#........#.#........#.#........#.#........#\n\
#.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...\n\
#...##....##...##....##...#X....##...##....##...##....##...##....#\n\
.#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.# --->\n\
";
let output = solve(mk_input(false, input)).unwrap();
assert_eq!(expected_output.to_string(), output.runs[
```
<Overlap Ratio: 0.9596638655462185>

---

--- 251 --
Question ID: f2f6d6c35e246d108a6225776f3b04f86b19240e_0
Original Code:
```
fn main() {
    let args: Vec<String> = env::args().collect();
    let usage = format!("Usage: {} <input>", args[0]);

    if args.len() != 2 {
        println!("Wrong argument count.");
        println!("{}", usage);
        return;
    }

    let input: String = match args[1].parse() {
        Ok(num) => num,
        Err(_) => {
            println!("Not a String.");
            println!("{}", usage);
            return;
        }
    };

    let mut output = String::new();
    let mut chars = input.chars().peekable();
    while let Some(c) = chars.next() {
        // Copy anything that's not a letter.
        if !c.is_ascii_alphabetic() {
            output.push(c);
            continue;
        }

        // Build a suffix depending on if we found a vowel or a consonant. If
        // that's a vowel, copy it. For words beginning with an uppercase
        // consonant, remember that we have to start the "pig-latin word" with
        // an uppercase letter.
        let lowercase_c = c.to_ascii_lowercase();
        let mut uppercase_consonant = false;
        let suffix = if let 'a' | 'e' | 'i' | 'o' | 'u' = lowercase_c {
            output.push(c);
            String::from("-hay")
        } else {
            uppercase_consonant = c != lowercase_c;
            format!("-{}ay", lowercase_c)
        };

        // Copy the rest of the word and append the suffix.
        while let Some(&c) = chars.peek() {
            if !c.is_ascii_alphabetic() {
                break;
            }
            chars.next();
            if uppercase_consonant {
                output.push(c.to_ascii_uppercase());
                uppercase_consonant = false;
            } else {
                output.push(c);
            }
        }
        output += &suffix;
    }
    println!("{}", output);
}
```


Overlapping Code:
```
fn main() {
let args: Vec<String> = env::args().collect();
let usage = format!("Usage: {} <input>", args[0]);
if args.len() != 2 {
println!("Wrong argument count.");
println!("{}", usage);
return;
}
let input: String = match args[1].parse() {
Ok(num) => num,
Err(_) => {
println!("Not a String.");
println!("{}", usage);
return;
}
};
let mut output = String::new();
let mut chars = input.chars().peekable();
while let Some(c) = chars.next() {
// Copy anything that's not a letter.
if !c.is_ascii_alphabetic() {
output.push(c);
continue;
}
// Build a suffix depending on if we found a vowel or a consonant. If
// that's a vowel, copy it. For words beginning with an uppercase
// consonant, remember that we have to start the "pig-latin word" with
// an uppercase letter.
let lowercase_c = c.to_ascii_lowercase();
let mut uppercase_consonant = false;
let suffix = if let 'a' | 'e' | 'i' | 'o' | 'u' = lowercase_c {
output.push(c);
String::from("-hay")
} else {
uppercase_consonant = c != lowercase_c;
format!("-{}ay", lowercase_c)
};
// Copy the rest of the word and append the suffix.
while let Some(&c) = chars.peek() {
if !c.is_ascii_alphabetic() {
break;
}
chars.next();
if uppercase_consonant {
output.push(c.to_ascii_uppercase());
uppercase_consonant = false;
} else {
output.push(c);
}
}
output += &suffix;
}
printl
```
<Overlap Ratio: 0.9858103061986557>

---

--- 252 --
Question ID: da59c534a3163c9bd36b0aa327759dc9a387ef39_0
Original Code:
```
pub fn with_repo<F>(file_contents: &str, file: &str, callback: F)
    where
        F: Fn(&Repository, &str),
    {
        let dir = tempfile::Builder::new()
            .prefix("testgitrepo")
            .tempdir()
            .expect("can't create tmp dir");

        let repo = Repository::init(&dir).expect("can't initialise repository");

        let path = dir.path().join(file);
        path.parent().map(|parent| fs::create_dir_all(&parent));
        fs::File::create(path)
            .and_then(|mut file| file.write_all(file_contents.as_bytes()))
            .expect("can't write file contents");

        let time = Time::new(123_456_789, 0);
        let sig = Signature::new("Foo McBarson", "foo.mcbarson@iamarealboy.net", &time)
            .expect("couldn't create signature for commit");

        let commit_oid = repo
            .index()
            .and_then(|mut index| {
                index
                    .add_path(Path::new(file))
                    .expect("can't add file to index");

                index
                    .write_tree()
                    .and_then(|tid| repo.find_tree(tid))
                    .and_then(|tree| {
                        repo.commit(Some("HEAD"), &sig, &sig, "Initial commit", &tree, &[])
                    })
            })
            .expect("can't do first commit");

        let commit = repo
            .find_object(commit_oid, None)
            .expect("Could not find first commit.");
        repo.tag("this-is-a-tag", &commit, &sig, "This is a tag.", false)
            .expect("Could not create tag.");

        let commit_sha = format!("{}", commit_oid);

        callback(&repo, &commit_sha);
        dir.close().expect("couldn't close the dir");
    }
```


Overlapping Code:
```
le: &str, callback: F)
where
F: Fn(&Repository, &str),
{
let dir = tempfile::Builder::new()
.prefix("testgitrepo")
.tempdir()
.expect("can't create tmp dir");
let repo = Repository::init(&dir).expect("can't initialise repository");
let path = dir.path().join(file);
path.parent().map(|parent| fs::create_dir_all(&parent));
fs::File::create(path)
.and_then(|mut file| file.write_all(file_contents.as_bytes()))
.expect("can't write file contents");
let time = Time::new(123_456_789, 0);
let sig = Signaldn't create signature for commit");
let commit_oid = repo
.index()
.and_then(|mut index| {
index
.add_path(Path::new(file))
.expect("can't add file to index");
index
.write_tree()
.and_then(|tid| repo.find_tree(tid))
.and_then(|tree| {
repo.commit(Some("HEAD"), &sig, &sig, "Initial commit", &tree, &[])
})
})
.expect("can't do first commit");
let commit = repo
.find_object(commit_oid, None)
.expect("Could not find first commit.");
repo.tag("this-is-a-tag", &commit, &sig, "This is a tag.", false)
.expect("Could not create tag.");
let commit_sha = format!("{}", commit_oid);
callback(&repo, &commit_sha);
dir.close().expect("couldn't close the di
```
<Overlap Ratio: 0.9012539184952978>

---

--- 253 --
Question ID: 3ea494108ae1e12fec175111c3d63bc66fabc03c_3
Original Code:
```
pub fn line_start_utf8_byte_offsets_raw(text: &str) -> Vec<usize> {
    let mut offsets = vec![0];
    offsets.append(
        &mut text
            .bytes()
            .enumerate()
            .filter(|(_, it)| it == &b'\n')
            .map(|(index, _)| index + 1)
            .collect(),
    );
    offsets
}
```


Overlapping Code:
```
tf8_byte_offsets_raw(text: &str) -> Vec<usize> {
let mut offsets = vec![0];
offsets.append(
&mut text
.bytes()
.enumerate()
.filter(|(_, it)| it == &b'\n')
.map(|(index, _)| index + 1)
.collect(),
);

```
<Overlap Ratio: 0.8771929824561403>

---

--- 254 --
Question ID: 72e1d1a09cb6ef662fb4daabc3898a177b2d86d8_1
Original Code:
```
pub extern "C" fn lkm_api_debug(this_module: usize) {
    let module = get_module(this_module);
    module.lock.lock();
    println!(
        "[LKM] Current module info: name={} version={} api_version={}\nref_count={} dep_count={}",
        module.info.name,
        module.info.version,
        module.info.api_version,
        Arc::strong_count(&module.using_counts),
        module.used_counts
    );
}
```


Overlapping Code:
```
km_api_debug(this_module: usize) {
let module = get_module(this_module);
module.lock.lock();
println!(
"[LKM] Current module info: name={} version={} api_version={}\nref_count={} dep_count={}",
module.info.name,
module.info.version,
module.info.api_version,
Arc::strong_count(&module.using_counts),
m
```
<Overlap Ratio: 0.8797653958944281>

---

--- 255 --
Question ID: abc597115d931393fe9f8cdf6f615d6e2b70ef55_0
Original Code:
```
fn main() {
    debug!("executing; cmd=albino-gen; args={}", os::args());

    let mut opts = vec!();
    let cmd = GenerateCommand::new("gen",
                                "[-s syntax] [-o output] [file]",
                                &mut opts, CommandBody);
    cmd.exec();
}
```


Overlapping Code:
```
o-gen; args={}", os::args());
let mut opts = vec!();
let cmd = GenerateCommand::new("gen",
"[-s syntax] [-o output] [file]",
&mut opts, CommandBody);
cmd.e
```
<Overlap Ratio: 0.7635467980295566>

---

--- 256 --
Question ID: 0a338848af549c370b2f659be4d9b94fe98b0e62_8
Original Code:
```
fn test_parse_negation() -> Result<(), String> {
        let input = String::from("int main() { return -1; }");
        let tokens = lexer::lex(&input)?;
        let ast = parse(tokens)?;
        assert_display_snapshot!(ast);
        Ok(())
    }
```


Overlapping Code:
```
_negation() -> Result<(), String> {
let input = String::from("int main() { return -1; }");
let tokens = lexer::lex(&input)?;
let ast = parse(tokens)?;
assert_display_snapshot!(ast);
Ok(()
```
<Overlap Ratio: 0.9211822660098522>

---

--- 257 --
Question ID: bdbb1559e3345747dd5df3cab78aa3ddf706f28a_0
Original Code:
```
async fn fetch(url: &str) -> Result<JsValue, JsValue> {
    let window = web_sys::window().expect("window should exist");
    let resp = JsFuture::from(window.fetch_with_str(url)).await?;
    let resp: Response = resp.dyn_into().expect("failed to convert response");

    JsFuture::from(resp.text()?).await
}
```


Overlapping Code:
```
 Result<JsValue, JsValue> {
let window = web_sys::window().expect("window should exist");
let resp = JsFuture::from(window.fetch_with_str(url)).await?;
let resp: Response = resp.dyn_into().expect("failed to convert response");
JsFuture::from(resp.tex
```
<Overlap Ratio: 0.8591065292096219>

---

--- 258 --
Question ID: ca5a4db29deff36bfc93b6731d0b4191b0b92f4b_3
Original Code:
```
pub fn put_in_memory(input: &[u8]) -> *mut u8 {
    let bytes_length = input.len() as u32;
    let mut bytes = to_bytes(&bytes_length);
    bytes.extend_from_slice(input);
    let ptr = bytes.as_mut_ptr();
    #[cfg(feature = "std")]
    ::std::mem::forget(bytes);
    #[cfg(not(feature = "std"))]
    core::mem::forget(bytes);
    ptr
}
```


Overlapping Code:
```
 put_in_memory(input: &[u8]) -> *mut u8 {
let bytes_length = input.len() as u32;
let mut bytes = to_bytes(&bytes_length);
bytes.extend_from_slice(input);
let ptr = bytes.as_mut_ptr();
#[cfg(feature = "std")]
::std::mem::forget(bytes);
#[cfg(not(feature = "std"))]
core::mem::forg
```
<Overlap Ratio: 0.9269102990033222>

---

--- 259 --
Question ID: b581d1eb07e3b93f9e0d7ce65b17b2bd1f7554ac_0
Original Code:
```
fn generate_cookie() -> [u8; 16] {
    let mut rand = OsRng::new().unwrap();
    let mut cookie: [u8; 16] = [0; 16];
    rand.try_fill(&mut cookie).unwrap();
    cookie
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 260 --
Question ID: 3961a0edac9c4d3a2fd997d41c0751f467697244_40
Original Code:
```
pub fn e29_29_29_write(newval: u64) {
    // bits 29..29
    let val = reg_rawrd();
    reg_rawwr(val & !(0x1 << 29) | ((newval & 0x1) << 29));
}
```


Overlapping Code:
```
_write(newval: u64) {
// bits 29..29
let val = reg_rawrd();
reg_rawwr(val & !(0x1 << 29) | ((newval & 0x1)
```
<Overlap Ratio: 0.7969924812030075>

---

--- 261 --
Question ID: d95dd70278fa85917675234c0873306aae2a5311_0
Original Code:
```
fn k_neighs_to_color_pattern(
    k_neighs: &[(SignedCoord2D, MapId)],
    outside_color: image::Rgba<u8>,
    source_maps: &[ImageBuffer<'_>],
    pattern: &mut ColorPattern,
    is_wrap_mode: bool,
) {
    pattern.0.resize(k_neighs.len() * 4, 0);
    let mut i = 0;

    let wrap_dim = (
        source_maps[0].dimensions().0 as i32,
        source_maps[0].dimensions().1 as i32,
    );

    for (n_coord, n_map) in k_neighs {
        let coord = if is_wrap_mode {
            n_coord.wrap(wrap_dim)
        } else {
            *n_coord
        };

        let end = i + 4;

        //check if he haven't gone outside the possible bounds
        if source_maps[n_map.0 as usize].is_in_bounds(coord) {
            pattern.0[i..end].copy_from_slice(
                &(source_maps[n_map.0 as usize])
                    .get_pixel(coord.x as u32, coord.y as u32)
                    .0[..4],
            )
        } else {
            // if we have gone out of bounds, then just fill as outside color
            pattern.0[i..end].copy_from_slice(&outside_color.0[..]);
        }

        i = end;
    }
}
```


Overlapping Code:
```
k_neighs: &[(SignedCoord2D, MapId)],
outside_color: image::Rgba<u8>,
source_maps: &[ImageBuffer<'_>],
pattern: &mut ColorPattern,
is_wrap_mode: bool,
) {
pattern.0.resize(k_neighs.len() * 4, 0);
let mut i = 0;
let wrap_dim = (
source_maps[0].dimensions().0 as i32,
source_maps[0].dimensions().1 as i32,
);
for (n_coord, n_map) in k_neighs {
let coord = if is_wrap_mode {
n_coord.wrap(wrap_dim)
} else {
*n_coord
};
let end = i + 4;
//check if he haven't gone outside the possible bounds
if source_maps[n_map.0 as usize].is_in_bounds(coord) {
pattern.0[i..end].copy_from_slice(
&(source_maps[n_map.0 as usize])
.get_pixel(coord.x as u32, coord.y as u32)
.0[..4],
)
} else {
// if we have gone out of bounds, then just fill as outside color
pattern.0[i..end].copy_from
```
<Overlap Ratio: 0.9119047619047619>

---

--- 262 --
Question ID: eda2cabe8ce35831fb8145103a09875819b7480f_97
Original Code:
```
fn parse_mv10() {
        let mut m = Parser::new("[mvl2l100,5,1,left]");
        assert_eq!(
            m.next(),
            Some(Ok(Value::MovingText(
                MovingTextMode::Linear(2),
                MovingTextDirection::Left,
                100,
                5,
                1,
                "left".into()
            )))
        );
        assert_eq!(m.next(), None);
    }
```


Overlapping Code:
```
w("[mvl2l100,5,1,left]");
assert_eq!(
m.next(),
Some(Ok(Value::MovingText(
MovingTextMode::Linear(2),
MovingTextDirection::Left,
100,
5,
1,
"left".int
```
<Overlap Ratio: 0.6521739130434783>

---

--- 263 --
Question ID: 89e4fa6ddbb83b75c88c2a34aded477bc0967a8d_5
Original Code:
```
fn parse_panic() {
        let line = "8 10 abc".to_string();
        let (v1, v2, _): (usize, usize, f32) = parse_weighted_edge(line);
        assert_eq!(v1, 8);
        assert_eq!(v2, 10);
    }
```


Overlapping Code:
```
g();
let (v1, v2, _): (usize, usize, f32) = parse_weighted_edge(line);
assert_eq!(v1, 8);
assert_eq!(v2, 10)
```
<Overlap Ratio: 0.675>

---

--- 264 --
Question ID: 1899237223e6bf0e0c2b2613f2863e9d0541b46f_0
Original Code:
```
fn main() {
    let args: Vec<String> = env::args().skip(1).collect();
    let arguments = unwrap_or_exit(Arguments::parse(args));

    // Sets a local variable to the value of the command line argument
    // with the same name as the variable.
    macro_rules! arg_var {
        ($name:ident, $default:expr) => (
            let $name = unwrap_or_exit(arguments.value(stringify!($name), $default));
        );
        ($name:ident, $default:expr, $min:expr, $max:expr) => (
            arg_var!($name, $default);
            if !($min <= $name && $name <= $max) {
                exit!("Invalid value '{}' for argument '{}': Value must be between {} and {}.",
                        $name, stringify!($name), $min, $max);
            }
        );
    }

    // Seed value for random number generation
    arg_var!(seed, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32);

    // Linear speed of the model along its path, in blocks/second
    arg_var!(speed, 30.0, 0.0, 1000.0);
    // Animation frames per second
    arg_var!(fps, 30.0, 0.1, 600.0);

    // Coloration gradient of the model, from its spine (`0`) to its outline (`1`)
    arg_var!(gradient, Gradient(vec![
        (0.4, Color::new(1.0, 1.0, 1.0)),
        (0.6, Color::new(0.15, 0.15, 0.7)),
        (1.0, Color::new(0.3, 0.1, 0.3)),
    ]));

    // Use 24-bit RGB terminal colors (`true`) or the 256-color palette (`false`)
    arg_var!(true_color, true);

    // Dimensions of the arena, in blocks
    arg_var!(width, 60, 1, 500);
    arg_var!(height, 40, 1, 500);
    if height % 2 != 0 {
        exit!("Invalid height '{}': Height must be a multiple of 2.", height);
    }

    // Minimum and maximum length of the model, in blocks.
    // The program will animate between the two for a "creeping" motion.
    let length_range = unwrap_or_exit(arguments.value("length", Range::new(10.0, 20.0)));
    if !(1.0 <= length_range.from && length_range.to <= 1000.0) {
        exit!("Invalid length '{} to {}': Length must be between 1 and 1000.", length_range.from, length_range.to);
    }

    // Coefficients of the function determining the model's thickness,
    // in blocks.
    //
    // The function has the form
    //
    // ```
    // f(o, t) = a + b * sin(PI * (c * o + d * t + e)) + ...
    // ```
    //
    // where `o` is the offset (between `0` and `1`) from the head
    // of the model to its tail, and `t` is the time in seconds
    // since the program was started.
    let coefficients = unwrap_or_exit(arguments.values("thickness", vec![4.0, 1.0, 3.5, 0.0, 0.0]));
    if coefficients.len() % 4 != 1 {
        exit!("Invalid thickness specification: There must be 1, or 5, or 9, ... coefficients; {} were supplied.",
                coefficients.len());
    }

    let thickness = |offset: f64, time: f64| {
        assert!(0.0 <= offset && offset <= 1.0);
        let mut thickness = coefficients[0];
        for i in 0..((coefficients.len() - 1) / 4) {
            thickness += coefficients[4 * i + 1] * (
                PI * (
                    (coefficients[4 * i + 2] * offset) +
                    (coefficients[4 * i + 3] * time) +
                    coefficients[4 * i + 4]
                )
            ).sin();
        }
        thickness
    };

    // Calculate upper bound for value of thickness function
    let mut max_thickness = coefficients[0];
    for i in 0..((coefficients.len() - 1) / 4) {
        max_thickness += coefficients[4 * i + 1].abs();
    }
    if !(0.5 <= max_thickness && max_thickness <= 1000.0) {
        exit!("Invalid thickness specification: Maximum thickness is {}; must be between 0.5 and 1000.", max_thickness);
    }

    let max_padding = 0.8 * ((min!(width, height) as f64) / 2.0);
    // Minimum distance between the path and the boundary of the arena, in blocks
    arg_var!(padding, min!(max_thickness, max_padding), 0.0, max_padding);

    let max_radius = 0.8 * (((min!(width, height) as f64) / 2.0) - padding);
    // Minimum and maximum radius of the arcs comprising the path, in blocks
    let radius_range = unwrap_or_exit(arguments.value("radius",
            Range::new(min!(1.2 * max_thickness, max_radius), max_radius)));
    if !(0.5 <= radius_range.from && radius_range.to <= max_radius) {
        exit!("Invalid radius '{} to {}': For the configured width, height, and padding, \
                radius must be between 0.5 and {}.", radius_range.from, radius_range.to, max_radius);
    }

    // The dimensions of the arena must be such that it is always possible
    // to generate a new arc that is tangential to the last arc in the path
    // and whose radius lies within the permitted range (see `Path` for details).
    // In the worst case, an arc of the maximum permitted radius is placed
    // at the center of the arena, minimizing the available space for the next arc,
    // which must be at least the minimum radius specified above.
    let min_size = (2.0 * radius_range.to) + (4.0 * radius_range.from) + (2.0 * padding);
    if (width as f64) < min_size && (height as f64) < min_size {
        exit!("Insufficient arena size for path generation: For the configured radius and padding, \
                either width or height must be at least {}.", min_size);
    }

    let mut path = Path {
        random: Random(seed),
        x_range: Range::new(padding, (width as f64) - padding),
        y_range: Range::new(padding, (height as f64) - padding),
        radius_range,
        start_position: 0.0,
        arcs: VecDeque::new(),
    };

    let mut last_position = 0.0;
    let mut path_range = Range::new(0.0, length_range.from);
    let mut expand_path = true;

    let start_time = Instant::now();

    // Rendering loop
    loop {
        let time = seconds(start_time.elapsed());

        let position = speed * time;

        if length_range.to > length_range.from {
            // "Creeping" motion
            let mut delta = position - last_position;
            last_position = position;

            while delta > 0.0 {
                let length = path_range.to - path_range.from;

                let max_delta = if expand_path {
                    length_range.to - length
                } else {
                    length - length_range.from
                };

                let actual_delta = min!(delta, max_delta);

                if expand_path {
                    path_range.to += actual_delta;
                } else {
                    path_range.from += actual_delta;
                }

                if delta >= max_delta {
                    expand_path = !expand_path;
                }

                delta -= actual_delta;
            }
        } else {
            // Linear motion
            path_range.from = position;
            path_range.to = path_range.from + length_range.from;
        }

        let model = Model::new(
            path.generate(path_range.from, path_range.to),
            |offset| thickness(offset, time),
            max_thickness,
        );

        let canvas = rasterize(&model, &gradient, width, height);
        let output = render(&canvas, true_color);

        // Hide cursor while printing canvas to avoid flickering
        print!("\x1B[?25l{}\x1B[?25h\n", output);

        // Sleep to compensate for difference between rendering time and frame time
        let sleep_time = (1.0 / fps) - (seconds(start_time.elapsed()) - time);
        if sleep_time > 0.0 {
            thread::sleep(Duration::new(sleep_time.trunc() as u64, (sleep_time.fract() * 1_000_000_000.0) as u32));
        }

        // Move cursor up to enable drawing of next frame over the current one
        print!("\x1B[{}A", height / 2);
    }
}
```


Overlapping Code:
```
fn main() {
let args: Vec<String> = env::args().skip(1).collect();
let arguments = unwrap_or_exit(Arguments::parse(args));
// Sets a local variable to the value of the command line argument
// with the same name as the variable.
macro_rules! arg_var {
($name:ident, $default:expr) => (
let $name = unwrap_or_exit(arguments.value(stringify!($name), $default));
);
($name:ident, $default:expr, $min:expr, $max:expr) => (
arg_var!($name, $default);
if !($min <= $name && $name <= $max) {
exit!("Invalid value '{}' for argument '{}': Value must be between {} and {}.",
$name, stringify!($name), $min, $max);
}
);
}
// Seed value for random number generation
arg_var!(seed, SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs() as u32);
// Linear speed of the model along its path, in blocks/second
arg_var!(speed, 30.0, 0.0, 1000.0);
// Animation frames per second
arg_var!(fps, 30.0, 0.1, 600.0);
// Coloration gradient of the model, from its spine (`0`) to its outline (`1`)
arg_var!(gradient, Gradient(vec![
(0.4, Color::new(1.0, 1.0, 1.0)),
(0.6, Color::new(0.15, 0.15, 0.7)),
(1.0, Color::new(0.3, 0.1, 0.3)),
]));
// Use 24-bit RGB terminal colors (`true`) or the 256-color palette (`false`)
arg_var!(true_color, true);
// Dimensions of the arena, in blocks
arg_var!(width, 60, 1, 500);
arg_var!(height, 40, 1, 500);
if height % 2 != 0 {
exit!("Invalid height '{}': Height must be a multiple of 2.", height);
}
// Minimum and maximum length of the model, in blocks.
// The program will animate between the two for a "creeping" motion.
let length_range = unwrap_or_exit(arguments.value("length", Range::new(10.0, 20.0)));
if !(1.0 <= length_range.from && length_range.to <= 1000.0) {
exit!("Invalid length '{} to {}': Length must be between 1 and 1000.", length_range.from, length_range.to);
}
// Coefficients of the function determining the model's thickness,
// in blocks.
//
// The function has the form
//
// ```
// f(o, t) = a + b * sin(PI * (c * o + d * t + e)) + ...
// ```
//
// where `o` is the offset (between `0` and `1`) from the head
// of the model to its tail, and `t` is the time in seconds
// since t
```
<Overlap Ratio: 0.9806451612903225>

---

--- 265 --
Question ID: 812f36c89c4559955aca02adfcdf70fe9153a5d7_0
Original Code:
```
unsafe fn transform(chaining_value: &[u32; 8], block: &[u8], block_len: usize, counter: u64, flags: u32) -> [u8; DIGEST_LEN] {
    debug_assert!(block.len() == BLOCK_LEN);
    
    let t0   = 0i32;
    let t1   = 0i32;
    let blen = block_len as u32 as i32;

    let mut va = _mm_setr_epi32(0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32);
    let mut vb = _mm_setr_epi32(0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32);
    let mut vc = va.clone();
    let mut vd = _mm_setr_epi32(t0, t1, blen, flags as i32);

    let w = _mm256_load_si256(block.as_ptr().add( 0) as *const __m256i);
    let w0 = _mm256_extract_epi32::<0>(w);
    let w1 = _mm256_extract_epi32::<1>(w);
    let w2 = _mm256_extract_epi32::<2>(w);
    let w3 = _mm256_extract_epi32::<3>(w);
    let w4 = _mm256_extract_epi32::<4>(w);
    let w5 = _mm256_extract_epi32::<5>(w);
    let w6 = _mm256_extract_epi32::<6>(w);
    let w7 = _mm256_extract_epi32::<7>(w);
    drop(w);

    let w = _mm256_load_si256(block.as_ptr().add(32) as *const __m256i);
    let w8  = _mm256_extract_epi32::<0>(w);
    let w9  = _mm256_extract_epi32::<1>(w);
    let w10 = _mm256_extract_epi32::<2>(w);
    let w11 = _mm256_extract_epi32::<3>(w);
    let w12 = _mm256_extract_epi32::<4>(w);
    let w13 = _mm256_extract_epi32::<5>(w);
    let w14 = _mm256_extract_epi32::<6>(w);
    let w15 = _mm256_extract_epi32::<7>(w);
    drop(w);

    let mut vmx: __m128i;
    let mut vmy: __m128i;

    // VG!(va, vb, vc, vd,  w0, w2, w4, w6,  w1, w3, w5, w7,  );

    // Round-1
    vmx = _mm_setr_epi32(w0, w2, w4, w6);
    vmy = _mm_setr_epi32(w1, w3, w5, w7);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w8, w10, w12, w14);
    vmy = _mm_setr_epi32(w9, w11, w13, w15);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-2
    vmx = _mm_setr_epi32(w2, w3, w7, w4);
    vmy = _mm_setr_epi32(w6, w10, w0, w13);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w1, w12, w9, w15);
    vmy = _mm_setr_epi32(w11, w5, w14, w8);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-3
    vmx = _mm_setr_epi32(w3, w10, w13, w7);
    vmy = _mm_setr_epi32(w4, w12, w2, w14);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w6, w9, w11, w8);
    vmy = _mm_setr_epi32(w5, w0, w15, w1);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-4
    vmx = _mm_setr_epi32(w10, w12, w14, w13);
    vmy = _mm_setr_epi32(w7, w9, w3, w15);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w4, w11, w5, w1);
    vmy = _mm_setr_epi32(w0, w2, w8, w6);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-5
    vmx = _mm_setr_epi32(w12, w9, w15, w14);
    vmy = _mm_setr_epi32(w13, w11, w10, w8);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w7, w5, w0, w6);
    vmy = _mm_setr_epi32(w2, w3, w1, w4);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-6
    vmx = _mm_setr_epi32(w9, w11, w8, w15);
    vmy = _mm_setr_epi32(w14, w5, w12, w1);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w13, w0, w2, w4);
    vmy = _mm_setr_epi32(w3, w10, w6, w7);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // Round-7
    vmx = _mm_setr_epi32(w11, w5, w1, w8);
    vmy = _mm_setr_epi32(w15, w0, w9, w6);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vmx = _mm_setr_epi32(w14, w2, w3, w7);
    vmy = _mm_setr_epi32(w10, w12, w4, w13);
    VG!(va, vb, vc, vd, vmx, vmy);
    vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
    vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
    vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)

    // let mut lo = _mm256_setr_m128i(va, vb);
    // let mut hi = _mm256_setr_m128i(vc, vd);
    // 
    // lo = _mm256_xor_si256(lo, hi);
    // hi = _mm256_xor_si256(hi, 
    //         _mm256_setr_epi32(
    //             0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32, 
    //             0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32,
    //         ),
    // );
    // 
    // let mut v = [0u32; 16];
    // _mm256_storeu_si256(v.as_mut_ptr() as *mut __m256i, lo);
    // _mm256_storeu_si256(v.as_mut_ptr().add(8) as *mut __m256i, hi);
    // 
    // v

    let mut out = [0u8; DIGEST_LEN];

    let mut lo = _mm256_setr_m128i(va, vb);
    let mut hi = _mm256_setr_m128i(vc, vd);

    lo = _mm256_xor_si256(lo, hi);
    _mm256_storeu_si256(out.as_mut_ptr() as *mut __m256i, lo);

    out
}
```


Overlapping Code:
```
; 8], block: &[u8], block_len: usize, counter: u64, flags: u32) -> [u8; DIGEST_LEN] {
debug_assert!(block.len() == BLOCK_LEN);

let t0 = 0i32;
let t1 = 0i32;
let blen = block_len as u32 as i32;
let mut va = _mm_setr_epi32(0x6A09E667u32 as i32, 0xBB67AE85u32 as i32, 0x3C6EF372u32 as i32, 0xA54FF53Au32 as i32);
let mut vb = _mm_setr_epi32(0x510E527Fu32 as i32, 0x9B05688Cu32 as i32, 0x1F83D9ABu32 as i32, 0x5BE0CD19u32 as i32);
let mut vc = va.clone();
let mut vd = _mm_setr_epi32(t0, t1, blen, flags as i32);
let w = _mm256_load_si256(block.as_ptr().add( 0) as *const __m256i);
let w0 = _mm256_extract_epi32::<0>(w);
let w1 = _mm256_extract_epi32::<1>(w);
let w2 = _mm256_extract_epi32::<2>(w);
let w3 = _mm256_extract_epi32::<3>(w);
let w4 = _mm256_extract_epi32::<4>(w);
let w5 = _mm256_extract_epi32::<5>(w);
let w6 = _mm256_extract_epi32::<6>(w);
let w7 = _mm256_extract_epi32::<7>(w);
drop(w);
let w = _mm256_load_si256(block.as_ptr().add(32) as *const __m256i);
let w8 = _mm256_extract_epi32::<0>(w);
let w9 = _mm256_extract_epi32::<1>(w);
let w10 = _mm256_extract_epi32::<2>(w);
let w11 = _mm256_extract_epi32::<3>(w);
let w12 = _mm256_extract_epi32::<4>(w);
let w13 = _mm256_extract_epi32::<5>(w);
let w14 = _mm256_extract_epi32::<6>(w);
let w15 = _mm256_extract_epi32::<7>(w);
drop(w);
let mut vmx: __m128i;
let mut vmy: __m128i;
// VG!(va, vb, vc, vd, w0, w2, w4, w6, w1, w3, w5, w7, );
// Round-1
vmx = _mm_setr_epi32(w0, w2, w4, w6);
vmy = _mm_setr_epi32(w1, w3, w5, w7);
VG!(va, vb, vc, vd, vmx, vmy);
vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
vd = _mm_shuffle_epi32(vd, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
vmx = _mm_setr_epi32(w8, w10, w12, w14);
vmy = _mm_setr_epi32(w9, w11, w13, w15);
VG!(va, vb, vc, vd, vmx, vmy);
vb = _mm_shuffle_epi32(vb, 0b_10_01_00_11); // _MM_SHUFFLE(2, 1, 0, 3)
vc = _mm_shuffle_epi32(vc, 0b_01_00_11_10); // _MM_SHUFFLE(1, 0, 3, 2)
vd = _mm_shuffle_epi32(vd, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2, 1)
// Round-2
vmx = _mm_setr_epi32(w2, w3, w7, w4);
vmy = _mm_setr_epi32(w6, w10, w0, w13);
VG!(va, vb, vc, vd, vmx, vmy);
vb = _mm_shuffle_epi32(vb, 0b_00_11_10_01); // _MM_SHUFFLE(0, 3, 2
```
<Overlap Ratio: 0.9816031537450722>

---

--- 266 --
Question ID: 3d3797949f684fc281ec9df1444c22b47e0158a7_2
Original Code:
```
fn fill_zoneplate(
    data: &mut [u8],
    width: u32,
    height: u32,
    frames: u32,
    t: f64,
    cx2: f64,
    cy2: f64,
    cxt: f64,
    cyt: f64,
    ct: f64,
) {
    let cx = width as i32 / 2;
    let cy = height as i32 / 2;

    let f = frames as f64;
    let h = height as f64;
    let w = width as f64;

    // originally: x=(i/W), y=(j/H) both in [0,1]
    // phi = cx2 * x^2*W + cy2*y^2*H + cxt*x*t*F*F/2 + cyt*y*t*F*F/2 + ct*t*F

    let mut index = 0;
    let ctt = ct * frames as f64 * t;

    for j in -cy..cy {
        let cy2y2 = cy2 * (j * j) as f64 / h;
        let cytyt = cyt * (j as f64 / h) * (t * f * f / 2.0);
        for i in -cx..cx {
            let mut phi: f64 = cy2y2 + cytyt + ctt;
            if cx2 != 0.0 {
                let cx2x2 = cx2 * (i * i) as f64 / w;
                phi += cx2x2;
            }
            if cxt != 0.0 {
                let cxtxt = cxt * (i as f64 / w) * (t * f * f / 2.0);
                phi += cxtxt;
            }

            phi = phi * PI;

            // inline trig calculation - <f64>.cos()
            // let c = (phi.cos() * 126.0 + 127.0) as u8;

            // Use the COSINE_LOOKUP (Quantized) table
            let abs_phi = if phi < 0.0 { -phi } else { phi };
            let i_phi = ((Q as f64 * abs_phi / (2.0 * PI)).floor()) as usize % Q;
            let c = COSINE_LOOKUP[i_phi];

            //  rust'ish color
            // data[index + 0] = c;
            // data[index + 1] = c / 2;
            // data[index + 2] = 0;
            // data[index + 3] = 255;

            data[index + 0] = c;
            data[index + 1] = c;
            data[index + 2] = c;
            // data[index + 3] = 255; // set in allocation (255_u8)
            index += 4;
        }
    }
}
```


Overlapping Code:
```
fn fill_zoneplate(
data: &mut [u8],
width: u32,
height: u32,
frames: u32,
t: f64,
cx2: f64,
cy2: f64,
cxt: f64,
cyt: f64,
ct: f64,
) {
let cx = width as i32 / 2;
let cy = height as i32 / 2;
let f = frames as f64;
let h = height as f64;
let w = width as f64;
// originally: x=(i/W), y=(j/H) both in [0,1]
// phi = cx2 * x^2*W + cy2*y^2*H + cxt*x*t*F*F/2 + cyt*y*t*F*F/2 + ct*t*F
let mut index = 0;
let ctt = ct * frames as f64 * t;
for j in -cy..cy {
let cy2y2 = cy2 * (j * j) as f64 / h;
let cytyt = cyt * (j as f64 / h) * (t * f * f / 2.0);
for i in -cx..cx {
let mut phi: f64 = cy2y2 + cytyt + ctt;
if cx2 != 0.0 {
let cx2x2 = cx2 * (i * i) as f64 / w;
phi += cx2x2;
}
if cxt != 0.0 {
let cxtxt = cxt * (i as f64 / w) * (t * f * f / 2.0);
phi += cxtxt;
}
phi = phi * PI;
// inline trig calculation - <f64>.cos()
// let c = (phi.cos() * 126.0 + 127.0) as u8;
// Use the COSINE_LOOKUP (Quantized) table
let abs_phi = if phi < 0.0 { -phi } else { phi };
let i_phi = ((Q as f64 * abs_phi / (2.0 * PI)).floor()) as usize % Q;
let c = COSINE_LOOKUP[i_phi];
// rust'ish color
// data[index + 0] = c;
// data[index + 1] = c / 2;
// data[index + 2] = 0;
// data[index + 3] = 255;
data[index + 0] = c;
data[index + 1] = c;
data[index + 2] = c;
// data[index + 3] = 255; // set in allocation (255_u8)
index +=
```
<Overlap Ratio: 0.9931245225362872>

---

--- 267 --
Question ID: 5bcfe78371064597e2f1a7135e136797931b2073_0
Original Code:
```
pub fn index(input: &str, base: &str, ignore_body: bool) -> Result<(), std::io::Error> {
    let file_index: Vec<_> = WalkDir::new(input).into_iter().collect();
    let file_index_len = file_index.len();

    let items: Vec<Vec<u8>> = file_index
        .into_par_iter()
        .enumerate()
        .map(|(i, entry)| {
            let file_path = entry.expect("Couldn't read file, aborting...");
            let mut new_item: Vec<u8> = Vec::new();

            if file_path
                .path()
                .extension()
                .unwrap_or(std::ffi::OsStr::new(""))
                == "html"
            {
                // parse html document, convert it so it can be query-selectored-ed
                let html = Html::parse_document(
                    read_to_string(file_path.path())
                        .expect("Failed to read file!")
                        .as_str(),
                );

                let title_selector =
                    Selector::parse("head title").expect("Failed to read HTML title, aborting...");
                let title: Vec<_> = html
                    .select(&title_selector)
                    .next()
                    .expect("Failed to get HTML title, aborting...")
                    .text()
                    .collect();

                let mut body_text = String::new();
                if ignore_body == false {
                    let body_selector = Selector::parse("body,body *")
                        .expect("Failed to read HTML body, aborting...");
                    let body_elements: Vec<_> = html.select(&body_selector).collect();

                    for element in body_elements.iter() {
                        let element_text: Vec<_> = element.text().collect();
                        if element_text.len() != 0 {
                            body_text.push_str(element_text[0]);
                        }
                    }
                }

                new_item = to_vec_pretty(
                    &Item::new(
                        title[0],
                        &format!(
                            "{}/{}",
                            base,
                            file_path
                                .path()
                                .strip_prefix("./")
                                .unwrap_or(file_path.path())
                                .display()
                        )[..],
                        match body_text.len() {
                            0 => None,
                            _ => Some(body_text),
                        },
                    )
                    .expect("Failed to parse URL."),
                )
                .expect("Failed to index file.");
            }

            if new_item.len() > 0 && i != file_index_len - 1 {
                [new_item, ",".as_bytes().to_vec()].concat()
            } else {
                new_item
            }
        })
        .collect();

    let idx = Index { items };

    let output_file = File::create("index.json").expect("Failed to generate index file!");
    let mut stream = BufWriter::new(output_file);

    stream.write(&"[".as_bytes()).unwrap();
    for i in 0..idx.items.len() {
        stream.write(&idx.items[i]).unwrap();
    }
    stream.write(&"]".as_bytes()).unwrap();

    stream.flush()
}
```


Overlapping Code:
```
: &str, ignore_body: bool) -> Result<(), std::io::Error> {
let file_index: Vec<_> = WalkDir::new(input).into_iter().collect();
let file_index_len = file_index.len();
let items: Vec<Vec<u8>> = file_index
.into_par_iter()
.enumerate()
.map(|(i, entry)| {
let file_path = entry.expect("Couldn't read file, aborting...");
let mut new_item: Vec<u8> = Vec::new();
if file_path
.path()
.extension()
.unwrap_or(std::ffi::OsStr::new(""))
== "html"
{
// parse html document, convert it so it can be query-selectored-ed
let html = Html::parse_document(
read_to_string(file_path.path())
.expect("Failed to read file!")
.as_str(),
);
let title_selector =
Selector::parse("head title").expect("Failed to read HTML title, aborting...");
let title: Vec<_> = html
.select(&title_selector)
.next()
.expect("Failed to get HTML title, aborting...")
.text()
.collect();
let mut body_text = String::new();
if ignore_body == false {
let body_selector = Selector::parse("body,body *")
.expect("Failed to read HTML body, aborting...");
let body_elements: Vec<_> = html.select(&body_selector).collect();
for element in body_elements.iter() {
let element_text: Vec<_> = element.text().collect();
if element_text.len() != 0 {
body_text.push_str(element_text[0]);
}
}
}
new_item = to_vec_pretty(
&Item::new(
title[0],
&format!(
"{}/{}",
base,
file_path
.path()
.strip_prefix("./")
.unwrap_or(file_path.path())
.display()
)[..],
m
```
<Overlap Ratio: 0.9641873278236914>

---

--- 268 --
Question ID: 6c8b777cd28da371d38c70147322697079db1af8_2
Original Code:
```
fn inverted_dashed() {
    assert_eq!(ColorAttribute::from_str("no-bold"), Ok(ColorAttribute::NoBold));
    assert_eq!(ColorAttribute::from_str("no-dim"), Ok(ColorAttribute::NoDim));
    assert_eq!(ColorAttribute::from_str("no-ul"), Ok(ColorAttribute::NoUl));
    assert_eq!(ColorAttribute::from_str("no-blink"), Ok(ColorAttribute::NoBlink));
    assert_eq!(ColorAttribute::from_str("no-reverse"), Ok(ColorAttribute::NoReverse));
    assert_eq!(ColorAttribute::from_str("no-italic"), Ok(ColorAttribute::NoItalic));
    assert_eq!(ColorAttribute::from_str("no-strike"), Ok(ColorAttribute::NoStrike));
}
```


Overlapping Code:
```
ed_dashed() {
assert_eq!(ColorAttribute::from_str("no-bold"), Ok(ColorAttribute::NoBold));
assert_eq!(ColorAttribute::from_str("no-dim"), Ok(ColorAttribute::NoDim));
assert_eq!(ColorAttribute::from_str("no-ul"), Ok(ColorAttribute::NoUl));
assert_eq!(ColorAttribute::from_str("no-blink"), Ok(ColorAttribute::NoBlink));
assert_eq!(ColorAttribute::from_str("no-reverse"), Ok(ColorAttribute::NoReverse));
assert_eq!(ColorAttribute::from_str("no-italic"), Ok(ColorAttribute::NoItalic));
assert_eq!(ColorAttribute::from_str("no-strike"), Ok(ColorAttribute::NoStrike))
```
<Overlap Ratio: 0.9790575916230366>

---

--- 269 --
Question ID: 01172475354df749ec1a58f3a232d7a5ac9dcc9e_5
Original Code:
```
fn test_import() {
    check_valid_contract(
        r#"
    (module
    (type (;0;) (func))
    (func (;0;))
    (export "invoke" (func 0))
    )
    "#,
    );

    // only import runtime function is valid
    check_invalid_contract(
        r#"
    (module
    (type (;0;) (func))
    (import "env" "add" (func (type 0)))
    (func (;1;))
    (export "invoke" (func 0))
    )
    "#,
    );

    // only import from `env` is valid
    check_invalid_contract(
        r#"
    (module
    (type (;0;) (func))
    (import "othermodule" "add" (func (type 0)))
    (func (;1;))
    (export "invoke" (func 0))
    )
    "#,
    );
}
```


Overlapping Code:
```
test_import() {
check_valid_contract(
r#"
(module
(type (;0;) (func))
(func (;0;))
(export "invoke" (func 0))
)
"#,
);
// only import runtime function is valid
check_invalid_contract(
r#"
(module
(type (;0;) (func))
(import "env" "add" (func (type 0)))
(func (;1;))
(export "invoke" (func 0))
)
"#,
);
// only import from `env` is valid
check_invalid_contract(
r#"
(module
(type (;0;) (func))
(import "othermodule" "add" (func (type 0)))
(func (;1;))
(export "invoke" (func 0))
)
"#,
)
```
<Overlap Ratio: 0.9877800407331976>

---

--- 270 --
Question ID: 5bd7dd325a3f42cc36d54f7d84f6d54d0c589ff7_1
Original Code:
```
fn total_up(input: &String) -> usize {
    let mut total = 0;
    for number in input.lines() {
        total += match number.trim().parse::<usize>() {
            Ok(number) => number,
            _ => continue,
        }
    }
    total
}
```


Overlapping Code:
```
tal_up(input: &String) -> usize {
let mut total = 0;
for number in input.lines() {
total += match number.trim().parse::<usize>() {
Ok(number) => numbe
```
<Overlap Ratio: 0.8152173913043478>

---

--- 271 --
Question ID: 97a8d2fc760a0e13a678d47172bf2d9ebf3dc0d6_0
Original Code:
```
fn debug_impl() {
    #[id]
    struct FooId(String);

    static_assertions::assert_impl_all!(FooId: Debug);
}
```


Overlapping Code:
```
d]
struct FooId(String);
static_assertions::assert_impl
```
<Overlap Ratio: 0.5612244897959183>

---

--- 272 --
Question ID: f890906438d887dd1cf10bd56de8bc224216d572_2
Original Code:
```
fn test_eval_result_new_dump_items() {
    let dump_items = DumpItems::default();
    let res = StoreEvalResult::new_dump_items(&dump_items);
    assert!(res.is_ok());

    let result = res.unwrap();

    match result {
        StoreEvalResult::DumpItems(result) => assert_eq!(result, dump_items),
        _ => panic!("invalid variant"),
    }
}
```


Overlapping Code:
```
let dump_items = DumpItems::default();
let res = StoreEvalResult::new_dump_items(&dump_items);
assert!(res.is_ok());
let result = res.unwrap();
match result {
StoreEvalResult::DumpItems(result) => assert_eq!(result, dump_items),
_ => panic!("invalid 
```
<Overlap Ratio: 0.8250825082508251>

---

--- 273 --
Question ID: b46e919bab86ce56f6aef393ba3e10addd1cd98d_4
Original Code:
```
pub fn mkdtemp() -> io::Result<PathBuf> {
    let temp_path;
    {
        let temp = mktemp::Temp::new_dir()?;
        temp_path = temp.to_path_buf();
        temp.release();
    }
    Ok(temp_path)
}
```


Overlapping Code:
```
o::Result<PathBuf> {
let temp_path;
{
let temp = mktemp::Temp::new_dir()?;
temp_path = temp.to_path_buf();
temp.
```
<Overlap Ratio: 0.6956521739130435>

---

--- 274 --
Question ID: be6d94a55f2f641746fad8009f7428e4e3705a5f_0
Original Code:
```
pub fn setup(
    mut commands: Commands,
    asset_server: ResMut<AssetServer>,
    mut atlases: ResMut<Assets<TextureAtlas>>,
    textures: ResMut<Assets<Texture>>,
) {
    let icon_handle = asset_server.load(assets::LOADING).unwrap();
    let icon_tex = textures.get(&icon_handle).unwrap();
    let atlas = load_spritesheet(icon_handle, icon_tex.size, Vec2::new(16.0, 16.0), Vec2::new(0.0, 0.0));
    let atlas_handle = atlases.add(atlas);

    commands
        .spawn(SpriteSheetComponents {
            texture_atlas: atlas_handle,
            transform: Transform::from_scale(1.0),
            ..Default::default()
        }).with_bundle((AnimSprite::new(1.0 / 12.0), LoadingScreen))
    ;
    println!("loading screen up!");
}
```


Overlapping Code:
```
b fn setup(
mut commands: Commands,
asset_server: ResMut<AssetServer>,
mut atlases: ResMut<Assets<TextureAtlas>>,
textures: ResMut<Assets<Texture>>,
) {
let icon_handle = asset_server.load(assets::LOADING).unwrap();
let icon_tex = textures.get(&icon_handle).unwrap();
let atlas = load_spritesheet(icon_handle, icon_tex.size, Vec2::new(16.0, 16.0), Vec2::new(0.0, 0.0));
let atlas_handle = atlases.add(atlas);
commands
.spawn(SpriteSheetComponents {
texture_atlas: atlas_handle,
transform: Transform::from_scale(1.0),
..Default::default()
}).with_bundle((AnimSprite::new(1.0 / 12.0), LoadingScreen))
;
println!("l
```
<Overlap Ratio: 0.9622641509433962>

---

--- 275 --
Question ID: 5fc3fcbc481bd8f38b28174bf6c6713146c44534_6
Original Code:
```
fn test_pool_send_revoc_reg_def_def_requests(pool: TestPool) {
        let identity = helpers::new_ledger_identity(&pool, Some(String::from("TRUSTEE")));

        let schema = helpers::schema::default_schema(&identity.did);
        let (_schema_id, schema_seq_no) = helpers::schema::publish(&identity, &pool, &schema);

        let cred_def = helpers::cred_def::build(&identity.did, schema_seq_no);
        let cred_def_id = helpers::cred_def::publish(&identity, &pool, cred_def);

        let revoc_reg_def = helpers::revoc_reg::build(&identity.did, &cred_def_id);
        let revoc_reg_id = revoc_reg_def.id.clone();

        // Send Revocation Registry Definition
        let mut revoc_reg_def = pool
            .request_builder()
            .build_revoc_reg_def_request(
                &identity.did,
                RevocationRegistryDefinition::RevocationRegistryDefinitionV1(revoc_reg_def),
            )
            .unwrap();

        let revoc_reg_def_response =
            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_def).unwrap();

        // Get Revocation Registry Definition
        let get_revoc_reg_def_request = pool
            .request_builder()
            .build_get_revoc_reg_def_request(None, &revoc_reg_id)
            .unwrap();

        let response = pool
            .send_request_with_retries(&get_revoc_reg_def_request, &revoc_reg_def_response)
            .unwrap();
        assert_eq!(
            json!(helpers::revoc_reg::build(&identity.did, &cred_def_id)),
            helpers::get_response_data(&response).unwrap()
        );

        // Send Revocation Registry Entry
        let mut revoc_reg_delta_request = pool
            .request_builder()
            .build_revoc_reg_entry_request(
                &identity.did,
                &revoc_reg_id,
                &REVOC_DEF_TYPE,
                revoc_reg_delta(),
            )
            .unwrap();

        let revoc_reg_entry_response =
            helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_delta_request).unwrap();

        _get_revocation_registry_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);
        _get_revocation_registry_delta_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);
    }
```


Overlapping Code:
```
voc_reg_def_def_requests(pool: TestPool) {
let identity = helpers::new_ledger_identity(&pool, Some(String::from("TRUSTEE")));
let schema = helpers::schema::default_schema(&identity.did);
let (_schema_id, schema_seq_no) = helpers::schema::publish(&identity, &pool, &schema);
let cred_def = helpers::cred_def::build(&identity.did, schema_seq_no);
let cred_def_id = helpers::cred_def::publish(&identity, &pool, cred_def);
let revoc_reg_def = helpers::revoc_reg::build(&identity.did, &cred_def_id);
let revoc_reg_id = revoc_reg_def.id.clone();
// Send Revocation Registry Definition
let mut revoc_reg_def = pool
.request_builder()
.build_revoc_reg_def_request(
&identity.did,
RevocationRegistryDefinition::RevocationRegistryDefinitionV1(revoc_reg_def),
)
.unwrap();
let revoc_reg_def_response =
helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_def).unwrap();
// Get Revocation Registry Definition
let get_revoc_reg_def_request = pool
.request_builder()
.build_get_revoc_reg_def_request(None, &revoc_reg_id)
.unwrap();
let response = pool
.send_request_with_retries(&get_revoc_reg_def_request, &revoc_reg_def_response)
.unwrap();
assert_eq!(
json!(helpers::revoc_reg::build(&identity.did, &cred_def_id)),
helpers::get_response_data(&response).unwrap()
);
// Send Revocation Registry Entry
let mut revoc_reg_delta_request = pool
.request_builder()
.build_revoc_reg_entry_request(
&identity.did,
&revoc_reg_id,
&REVOC_DEF_TYPE,
revoc_reg_delta(),
)
.unwrap();
let revoc_reg_entry_response =
helpers::sign_and_send_request(&identity, &pool, &mut revoc_reg_delta_request).unwrap();
_get_revocation_registry_cases(&pool, &revoc_reg_id, &revoc_reg_entry_response);
_get_revocation_registry_delta_cases(&pool, &revoc_reg_id, &revoc_reg_entry_respo
```
<Overlap Ratio: 0.9848058525604952>

---

--- 276 --
Question ID: 03201f2b2afd5dfeb31262c5c1a7609fc1ea1597_0
Original Code:
```
fn read_file(file_name: &str) -> std::io::Result<[u8; AVAILABLE_MEMORY]> {
    let mut f = File::open(file_name)?;
    let mut memory = [0; AVAILABLE_MEMORY];
    f.read_exact(&mut memory)?;
    Ok(memory)
}
```


Overlapping Code:
```
_file(file_name: &str) -> std::io::Result<[u8; AVAILABLE_MEMORY]> {
let mut f = File::open(file_name)?;
let mut memory = [0; AVAILABLE_MEMORY];
f.read
```
<Overlap Ratio: 0.7853403141361257>

---

--- 277 --
Question ID: 714cc595eff48deb7a8fe66630a0b2ec594d73d0_3
Original Code:
```
fn argfile_build_fails_if_arg_contains_newline() {
        let mut cmd = ProcessBuilder::new("echo");
        cmd.arg("foo\n");
        let err = cmd.build_command_with_argfile().unwrap_err();
        assert_eq!(
            err.to_string(),
            "argument for argfile contains newlines: `foo\n`"
        );
    }
```


Overlapping Code:
```
ls_if_arg_contains_newline() {
let mut cmd = ProcessBuilder::new("echo");
cmd.arg("foo\n");
let err = cmd.build_command_with_argfile().unwrap_err();
assert_eq!(
err.to_string(),
"argument for argfile co
```
<Overlap Ratio: 0.8015873015873016>

---

--- 278 --
Question ID: f21cd6bd27999d5a412fbd51eaee0dbae21db4e9_18
Original Code:
```
fn sla_hl_carry() {
    let mut gb = GB::new();
    let addr = 0xC000;
    gb.set_hl(addr);
    gb.mem_write(addr, 0b11001100);
    gb.set_cy(0);
    gb.shift_mem(&GB::sla);
    assert_eq!(gb.mem_read(addr), 0b10011000);
    assert_eq!(gb.get_cy(), 1);
}
```


Overlapping Code:
```
rry() {
let mut gb = GB::new();
let addr = 0xC000;
gb.set_hl(addr);
gb.mem_write(addr, 0b11001100);
gb.set_cy(0);
gb.shift_mem(&GB::sla);
assert_eq!(gb.mem_read(addr), 0b10011000);
assert_eq!(gb.get_cy(), 
```
<Overlap Ratio: 0.9234234234234234>

---

--- 279 --
Question ID: a7d785f3d9c0036eede0f2eda57b603734bb6a26_2
Original Code:
```
fn lla_ecef_lla() {
    println!("");
    println!("lla:   {:?}", *TEST_LLA);
    println!("ecef:  {:?}", *TEST_ECEF);
    let ecef2 = lla_to_ecef(&*TEST_LLA);
    let lla2  = ecef_to_lla(&ecef2);
    println!("ecef2: {:?}", ecef2);
    println!("lla2:  {:?}", lla2);
    assert_eq!(*TEST_LLA, lla2);
}
```


Overlapping Code:
```
lla_ecef_lla() {
println!("");
println!("lla: {:?}", *TEST_LLA);
println!("ecef: {:?}", *TEST_ECEF);
let ecef2 = lla_to_ecef(&*TEST_LLA);
let lla2 = ecef_to_lla(&ecef2);
println!("ecef2: {:?}", ecef2);
println!("lla2: {:?}", lla2);
assert_eq!(*TEST_L
```
<Overlap Ratio: 0.9433962264150944>

---

--- 280 --
Question ID: 0562c4f89b1ec791019977a5891f3e5a0953d5f8_0
Original Code:
```
fn main() {
    let mut buf = [0; 65535];
    let mut out = [0; MAX_DATAGRAM_SIZE];

    env_logger::builder()
        .default_format_timestamp_nanos(true)
        .init();

    // Parse CLI parameters.
    let docopt = docopt::Docopt::new(USAGE).unwrap();
    let conn_args = CommonArgs::with_docopt(&docopt);
    let args = ClientArgs::with_docopt(&docopt);

    // Setup the event loop.
    let poll = mio::Poll::new().unwrap();
    let mut events = mio::Events::with_capacity(1024);

    // We'll only connect to the first server provided in URL list.
    let connect_url = &args.urls[0];

    // Resolve server address.
    let peer_addr = connect_url.to_socket_addrs().unwrap().next().unwrap();

    // Bind to INADDR_ANY or IN6ADDR_ANY depending on the IP family of the
    // server address. This is needed on macOS and BSD variants that don't
    // support binding to IN6ADDR_ANY for both v4 and v6.
    let bind_addr = match peer_addr {
        std::net::SocketAddr::V4(_) => "0.0.0.0:0",
        std::net::SocketAddr::V6(_) => "[::]:0",
    };

    // Create the UDP socket backing the QUIC connection, and register it with
    // the event loop.
    let socket = std::net::UdpSocket::bind(bind_addr).unwrap();
    socket.connect(peer_addr).unwrap();

    let socket = mio::net::UdpSocket::from_socket(socket).unwrap();
    poll.register(
        &socket,
        mio::Token(0),
        mio::Ready::readable(),
        mio::PollOpt::edge(),
    )
    .unwrap();

    // Create the configuration for the QUIC connection.
    let mut config = quiche::Config::new(args.version).unwrap();

    config.verify_peer(!args.no_verify);

    config.set_application_protos(&conn_args.alpns).unwrap();

    config.set_max_idle_timeout(30000);
    config.set_max_udp_payload_size(MAX_DATAGRAM_SIZE as u64);
    config.set_initial_max_data(conn_args.max_data);
    config.set_initial_max_stream_data_bidi_local(conn_args.max_stream_data);
    config.set_initial_max_stream_data_bidi_remote(conn_args.max_stream_data);
    config.set_initial_max_stream_data_uni(conn_args.max_stream_data);
    config.set_initial_max_streams_bidi(conn_args.max_streams_bidi);
    config.set_initial_max_streams_uni(conn_args.max_streams_uni);
    config.set_disable_active_migration(true);

    let mut keylog = None;

    if let Some(keylog_path) = std::env::var_os("SSLKEYLOGFILE") {
        let file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(keylog_path)
            .unwrap();

        keylog = Some(file);

        config.log_keys();
    }

    if conn_args.no_grease {
        config.grease(false);
    }

    config
        .set_cc_algorithm_name(&conn_args.cc_algorithm)
        .unwrap();

    if conn_args.disable_hystart {
        config.enable_hystart(false);
    }

    if conn_args.dgrams_enabled {
        config.enable_dgram(true, 1000, 1000);
    }

    let mut http_conn: Option<Box<dyn HttpConn>> = None;
    let mut siduck_conn: Option<SiDuckConn> = None;
    let mut webtrans_conn: Option<WebTransConn> = None;

    let mut app_proto_selected = false;

    // Generate a random source connection ID for the connection.
    let mut scid = [0; quiche::MAX_CONN_ID_LEN];
    SystemRandom::new().fill(&mut scid[..]).unwrap();

    // Create a QUIC connection and initiate handshake.
    let mut conn =
        quiche::connect(connect_url.domain(), &scid, &mut config).unwrap();

    if let Some(keylog) = &mut keylog {
        if let Ok(keylog) = keylog.try_clone() {
            conn.set_keylog(Box::new(keylog));
        }
    }

    // Only bother with qlog if the user specified it.
    #[cfg(feature = "qlog")]
    {
        if let Some(dir) = std::env::var_os("QLOGDIR") {
            let id = hex_dump(&scid);
            let writer = make_qlog_writer(&dir, "client", &id);

            conn.set_qlog(
                std::boxed::Box::new(writer),
                "quiche-client qlog".to_string(),
                format!("{} id={}", "quiche-client qlog", id),
            );
        }
    }

    info!(
        "connecting to {:} from {:} with scid {}",
        peer_addr,
        socket.local_addr().unwrap(),
        hex_dump(&scid)
    );

    let write = conn.send(&mut out).expect("initial send failed");

    while let Err(e) = socket.send(&out[..write]) {
        if e.kind() == std::io::ErrorKind::WouldBlock {
            trace!("send() would block");
            continue;
        }

        panic!("send() failed: {:?}", e);
    }

    trace!("written {}", write);

    let app_data_start = std::time::Instant::now();

    let mut pkt_count = 0;

    loop {
        poll.poll(&mut events, conn.timeout()).unwrap();

        // Read incoming UDP packets from the socket and feed them to quiche,
        // until there are no more packets to read.
        'read: loop {
            // If the event loop reported no events, it means that the timeout
            // has expired, so handle it without attempting to read packets. We
            // will then proceed with the send loop.
            if events.is_empty() {
                trace!("timed out");

                conn.on_timeout();

                break 'read;
            }

            let len = match socket.recv(&mut buf) {
                Ok(v) => v,

                Err(e) => {
                    // There are no more UDP packets to read, so end the read
                    // loop.
                    if e.kind() == std::io::ErrorKind::WouldBlock {
                        trace!("recv() would block");
                        break 'read;
                    }

                    panic!("recv() failed: {:?}", e);
                },
            };

            trace!("got {} bytes", len);

            if let Some(target_path) = conn_args.dump_packet_path.as_ref() {
                let path = format!("{}/{}.pkt", target_path, pkt_count);

                if let Ok(f) = std::fs::File::create(&path) {
                    let mut f = std::io::BufWriter::new(f);
                    f.write_all(&buf[..len]).ok();
                }
            }

            pkt_count += 1;

            // Process potentially coalesced packets.
            let read = match conn.recv(&mut buf[..len]) {
                Ok(v) => v,

                Err(e) => {
                    error!("recv failed: {:?}", e);
                    continue 'read;
                },
            };

            trace!("processed {} bytes", read);
        }

        trace!("done reading");

        if conn.is_closed() {
            info!("connection closed, {:?}", conn.stats());

            if let Some(h_conn) = http_conn {
                h_conn.report_incomplete(&app_data_start);
            }

            if let Some(si_conn) = siduck_conn {
                si_conn.report_incomplete(&app_data_start);
            }

            break;
        }

        // Create a new application protocol session once the QUIC connection is
        // established.
        if conn.is_established() && !app_proto_selected {
            // At this stage the ALPN negotiation succeeded and selected a
            // single application protocol name. We'll use this to construct
            // the correct type of HttpConn but `application_proto()`
            // returns a slice, so we have to convert it to a str in order
            // to compare to our lists of protocols. We `unwrap()` because
            // we need the value and if something fails at this stage, there
            // is not much anyone can do to recover.

            let app_proto = conn.application_proto();
            let app_proto = &std::str::from_utf8(&app_proto).unwrap();

            if alpns::HTTP_09.contains(app_proto) {
                http_conn =
                    Some(Http09Conn::with_urls(&args.urls, args.reqs_cardinal));

                app_proto_selected = true;
            } else if alpns::HTTP_3.contains(app_proto) {
                let dgram_sender = if conn_args.dgrams_enabled {
                    Some(Http3DgramSender::new(
                        conn_args.dgram_count,
                        conn_args.dgram_data.clone(),
                        0,
                    ))
                } else {
                    None
                };

                http_conn = Some(Http3Conn::with_urls(
                    &mut conn,
                    &args.urls,
                    args.reqs_cardinal,
                    &args.req_headers,
                    &args.body,
                    &args.method,
                    args.dump_json,
                    dgram_sender,
                ));

                app_proto_selected = true;
            } else if alpns::SIDUCK.contains(app_proto) {
                siduck_conn = Some(SiDuckConn::new(
                    conn_args.dgram_count,
                    conn_args.dgram_data.clone(),
                ));

                app_proto_selected = true;
            } else if alpns::QUICTRANSPORT.contains(app_proto) {
                webtrans_conn = Some(WebTransConn::with_url(
                    args.urls[0].clone(),
                    conn_args.dgram_count,
                    conn_args.dgram_data.clone(),
                ));

                app_proto_selected = true;
            }
        }

        // If we have an HTTP connection, first issue the requests then
        // process received data.
        if let Some(h_conn) = http_conn.as_mut() {
            h_conn.send_requests(&mut conn, &args.dump_response_path);
            h_conn.handle_responses(&mut conn, &mut buf, &app_data_start);
        }

        // If we have a siduck connection, first issue the quacks then
        // process received data.
        if let Some(si_conn) = siduck_conn.as_mut() {
            si_conn.send_quacks(&mut conn);
            si_conn.handle_quack_acks(&mut conn, &mut buf, &app_data_start);
        }

        // If we have a webtransport connection, first issue stuff then process
        // receeived data.
        if let Some(webtrans_conn) = webtrans_conn.as_mut() {
            webtrans_conn.send_client_indication(&mut conn);
            webtrans_conn.send_datagrams(&mut conn);
            webtrans_conn.send_honks(&mut conn);
            webtrans_conn.handle_dgram_echoes(
                &mut conn,
                &mut buf,
                &app_data_start,
            );
            webtrans_conn.handle_responses(&mut conn, &mut buf, &app_data_start);
        }

        // Generate outgoing QUIC packets and send them on the UDP socket, until
        // quiche reports that there are no more packets to be sent.
        loop {
            let write = match conn.send(&mut out) {
                Ok(v) => v,

                Err(quiche::Error::Done) => {
                    trace!("done writing");
                    break;
                },

                Err(e) => {
                    error!("send failed: {:?}", e);

                    conn.close(false, 0x1, b"fail").ok();
                    break;
                },
            };

            if let Err(e) = socket.send(&out[..write]) {
                if e.kind() == std::io::ErrorKind::WouldBlock {
                    trace!("send() would block");
                    break;
                }

                panic!("send() failed: {:?}", e);
            }

            trace!("written {}", write);
        }

        if conn.is_closed() {
            info!("connection closed, {:?}", conn.stats());

            if let Some(h_conn) = http_conn {
                h_conn.report_incomplete(&app_data_start);
            }

            break;
        }
    }
}
```


Overlapping Code:
```
 main() {
let mut buf = [0; 65535];
let mut out = [0; MAX_DATAGRAM_SIZE];
env_logger::builder()
.default_format_timestamp_nanos(true)
.init();
// Parse CLI parameters.
let docopt = docopt::Docopt::new(USAGE).unwrap();
let conn_args = CommonArgs::with_docopt(&docopt);
let args = ClientArgs::with_docopt(&docopt);
// Setup the event loop.
let poll = mio::Poll::new().unwrap();
let mut events = mio::Events::with_capacity(1024);
// We'll only connect to the first server provided in URL list.
let connect_url = &args.urls[0];
// Resolve server address.
let peer_addr = connect_url.to_socket_addrs().unwrap().next().unwrap();
// Bind to INADDR_ANY or IN6ADDR_ANY depending on the IP family of the
// server address. This is needed on macOS and BSD variants that don't
// support binding to IN6ADDR_ANY for both v4 and v6.
let bind_addr = match peer_addr {
std::net::SocketAddr::V4(_) => "0.0.0.0:0",
std::net::SocketAddr::V6(_) => "[::]:0",
};
// Create the UDP socket backing the QUIC connection, and register it with
// the event loop.
let socket = std::net::UdpSocket::bind(bind_addr).unwrap();
socket.connect(peer_addr).unwrap();
let socket = mio::net::UdpSocket::from_socket(socket).unwrap();
poll.register(
&socket,
mio::Token(0),
mio::Ready::readable(),
mio::PollOpt::edge(),
)
.unwrap();
// Create the configuration for the QUIC connection.
let mut config = quiche::Config::new(args.version).unwrap();
config.verify_peer(!args.no_verify);
config.set_application_protos(&conn_args.alpns).unwrap();
config.set_max_idle_timeout(30000);
config.set_max_udp_payload_size(MAX_DATAGRAM_SIZE as u64);
config.set_initial_max_data(conn_args.max_data);
config.set_initial_max_stream_data_bidi_local(conn_args.max_stream_data);
config.set_initial_max_stream_data_bidi_remote(conn_args.max_stream_data);
config.set_initial_max_stream_data_uni(conn_args.max_stream_data);
config.set_initial_max_streams_bidi(conn_args.max_streams_bidi);
config.set_initial_max_streams_uni(conn_args.max_streams_uni);
config.set_disable_active_migration(true);
let mut keylog = None;
if let Some(keylog_path) = std::env::var_os("SSLKEYLOGFILE") {
let file = std::fs::OpenOptions::new()
.create(true)
.append(true)
.open(keylog_path
```
<Overlap Ratio: 0.9986400725294651>

---

--- 281 --
Question ID: 429d41722b6d0fb98edc10ab90f3adccacd8e751_4
Original Code:
```
pub fn instr_branch_subroutine_byte
    <T: VAXBus>
    (cpu: &mut VAXCPU<T>, _cycle_count: &mut Cycles)
    -> Result<(), Error>
{
    let displ = read_data::<u8, T>(cpu)?;
    push(cpu, cpu.regfile.get_pc())?;
    jump_with_byte_displacement(cpu, displ);
    Ok(())
}
```


Overlapping Code:
```
instr_branch_subroutine_byte
<T: VAXBus>
(cpu: &mut VAXCPU<T>, _cycle_count: &mut Cycles)
-> Result<(), Error>
{
let displ = read_data::<u8, T>(cpu)?;
push(cpu, cpu.regfile.get_pc())?;
jump_with_byte_
```
<Overlap Ratio: 0.8298755186721992>

---

--- 282 --
Question ID: 5f93ce57b3f820ff6e951b817fd18b7956deca2a_14
Original Code:
```
fn test_read_default_header() -> Result<()> {
        let mut proto_header = proto::Header::default();
        proto_header.set_num_docs(17);
        proto_header.set_num_postings_lists(1234);

        let buffer = header_to_buf(&proto_header)?;

        let mut input = CodedInputStream::from_bytes(&buffer);
        let header = Header::from_stream(&mut input)?;
        assert_eq!(header.protobuf_header, proto_header);
        assert_eq!(header.num_documents, 17);
        assert_eq!(header.num_postings_lists, 1234);
        Ok(())
    }
```


Overlapping Code:
```
Result<()> {
let mut proto_header = proto::Header::default();
proto_header.set_num_docs(17);
proto_header.set_num_postings_lists(1234);
let buffer = header_to_buf(&proto_header)?;
let mut input = CodedInputStream::from_bytes(&buffer);
let header = Header::from_stream(&mut input)?;
assert_eq!(header.protobuf_header, proto_header);
assert_eq!(header.num_documents, 17);
assert_eq!(header.num_postings
```
<Overlap Ratio: 0.8771929824561403>

---

--- 283 --
Question ID: 48623c43b4c2865a58a5fc6d05b2564c92c075e0_2
Original Code:
```
fn test_update_value() {
        let mut val = Value::Object(serde_json::Map::new());

        update_nested_value(&mut val, &["x", "y", "z"], "xx");

        insta::assert_json_snapshot!(val, @r###"
       {
         "x": {
           "y": {
             "z": "xx"
           }
         }
       }
        "###);

        update_nested_value(&mut val, &["x", "y", "k"], "kk");
        update_nested_value(&mut val, &["w", ""], "w");
        update_nested_value(&mut val, &["z1"], "val1");
        insta::assert_json_snapshot!(val, @r###"
       {
         "w": {
           "": "w"
         },
         "x": {
           "y": {
             "k": "kk",
             "z": "xx"
           }
         },
         "z1": "val1"
       }
        "###);
    }
```


Overlapping Code:
```
pdate_value() {
let mut val = Value::Object(serde_json::Map::new());
update_nested_value(&mut val, &["x", "y", "z"], "xx");
insta::assert_json_snapshot!(val, @r###"
{
 "x": {
 "y": {
 "z": "xx"
 }
 }
}
"###);
update_nested_value(&mut val, &["x", "y", "k"], "kk");
update_nested_value(&mut val, &["w", ""], "w");
update_nested_value(&mut val, &["z1"], "val1");
insta::assert_json_snapshot!(val, @r###"
{
 "w": {
 "": "w"
 },
 "x": {
 "y": {
 "k": "kk",
 "z": "xx"
 }
 },
 "z1": "val1
```
<Overlap Ratio: 0.9578544061302682>

---

--- 284 --
Question ID: 811539c937bf292e3f12a0cd8284cc05e2d69526_9
Original Code:
```
fn test_mode_and_permissions() {
        use std::os::unix::fs::{symlink, PermissionsExt};
        use std::fs::{set_permissions, Permissions};

        let dir = tempdir().unwrap();

        let unavailable_dir_path = dir.path().join("unavailable");
        let unavailable_file_path = unavailable_dir_path.join("file");
        let readonly_path = dir.path().join("readonly.txt");
        let symlink_path = dir.path().join("writeonly.txt");
        create_dir(&unavailable_dir_path).unwrap();
        write(&unavailable_file_path, "foo").unwrap();
        write(&readonly_path, "foo").unwrap();
        symlink(&readonly_path, &symlink_path).unwrap();

        set_permissions(&unavailable_dir_path, Permissions::from_mode(0o000)).unwrap();
        set_permissions(&readonly_path, Permissions::from_mode(0o444)).unwrap();

        let mut session = session::test::Fake::new();
        assert!(handle(&mut session, Request { root: PathBuf::from(dir.path()) }).is_ok());

        let mut entries = entries_from_session_response(&session);
        entries.sort_by(|a, b| a.path.cmp(&b.path));
        assert_eq!(entries.len(), 4);
        assert_eq!(entries[2].mode, Some(0o040000));
        assert_eq!(entries[1].mode, Some(0o100444));
        // Drop mode bits because symlinks have actual modes on some unix systems.
        assert_eq!(entries[3].mode.unwrap() & 0o120000, 0o120000);
    }
```


Overlapping Code:
```
 std::os::unix::fs::{symlink, PermissionsExt};
use std::fs::{set_permissions, Permissions};
let dir = tempdir().unwrap();
let unavailable_dir_path = dir.path().join("unavailable");
let unavailable_file_path = unavailable_dir_path.join("file");
let readonly_path = dir.path().join("readonly.txt");
let symlink_path = dir.path().join("writeonly.txt");
create_dir(&unavailable_dir_path).unwrap();
write(&unavailable_file_path, "foo").unwrap();
write(&readonly_path, "foo").unwrap();
symlink(&readonly_path, &symlink_path).unwrap();
set_permissions(&unavailable_dir_path, Permissions::from_mode(0o000)).unwrap();
set_permissions(&readonly_path, Permissions::from_mode(0o444)).unwrap();
let mut session = session::test::Fake::new();
assert!(handle(&mut session, Request { root: PathBuf::from(dir.path()) }).is_ok());
let mut entries = entries_from_session_response(&session);
entries.sort_by(|a, b| a.path.cmp(&b.path));
assert_eq!(entries.len(), 4);
assert_eq!(entries[2].mode, Some(0o040000));
assert_eq!(entries[1].mode, Some(0o100444));
// Drop mode bits because symlinks have actual modes on some unix systems.
assert_eq!(entries[3].mode.unwrap() & 0o1200
```
<Overlap Ratio: 0.9569179784589892>

---

--- 285 --
Question ID: d3fd36c14dbc79aaae7d0ed2023e0bd4206daa79_0
Original Code:
```
fn test_index_of_hit() {
        let cache = mock_cache();
        assert_eq!(cache.index_of(1), Some(0));
        assert_eq!(cache.index_of(2), Some(1));
    }
```


Overlapping Code:
```
t() {
let cache = mock_cache();
assert_eq!(cache.index_of(1), Some(0));
assert_eq!(cache.index_of(2)
```
<Overlap Ratio: 0.7575757575757576>

---

--- 286 --
Question ID: f4f362a9c0691983634a5909192b4c0ad764335c_1
Original Code:
```
fn test_evolution() {
        // Let's create an evolution machine
        let mut machine = Machine::new(&pokemon_op_sys);

        // You have a Charmander
        let my_creature = Charmander;

        // Put the Charmander into the machine
        let result = machine.operate(&Item::Value(my_creature)).unwrap();

        // There should obviously be a Charmander in the machine
        assert_eq!(result, &Charmander);
        // And there should be nothing else in the machine
        assert_eq!(machine.stack_length(), 1);

        // Let's make it evolute!
        let result = machine.operate(&Item::Operator(Evolute)).unwrap();

        // Charmander should have turned into Charmaleon!
        assert_eq!(result, &Charmaleon);
        // And again there should be only 1 creature in the machine
        assert_eq!(machine.stack_length(), 1);

        // Let's evolute it again
        let result = machine.operate(&Item::Operator(Evolute)).unwrap();

        // Meet our blazing Charizard!
        assert_eq!(result, &Charizard);

        // What if we try to evolute Charizard?
        let result = machine.operate(&Item::Operator(Evolute)).unwrap();

        // Good try... but it should still be a Charizard
        assert_eq!(result, &Charizard);

        // Ok, we already got Charizard, let's just close the machine and make sure we don't leave
        // any creature behind
        machine.operate(&Item::Operator(Close));
        assert_eq!(machine.stack_length(), 0);
    }
```


Overlapping Code:
```
lution machine
let mut machine = Machine::new(&pokemon_op_sys);
// You have a Charmander
let my_creature = Charmander;
// Put the Charmander into the machine
let result = machine.operate(&Item::Value(my_creature)).unwrap();
// There should obviously be a Charmander in the machine
assert_eq!(result, &Charmander);
// And there should be nothing else in the machine
assert_eq!(machine.stack_length(), 1);
// Let's make it evolute!
let result = machine.operate(&Item::Operator(Evolute)).unwrap();
// Charmander should have turned into Charmaleon!
assert_eq!(result, &Charmaleon);
// And again there should be only 1 creature in the machine
assert_eq!(machine.stack_length(), 1);
// Let's evolute it again
let result = machine.operate(&Item::Operator(Evolute)).unwrap();
// Meet our blazing Charizard!
assert_eq!(result, &Charizard);
// What if we try to evolute Charizard?
let result = machine.operate(&Item::Operator(Evolute)).unwrap();
// Good try... but it should still be a Charizard
assert_eq!(result, &Charizard);
// Ok, we already got Charizard, let's just close the machine and make sure we don't leave
// any creature behind
machine.operate(&Item::Operator(Close));
assert_eq!(machine.stack_le
```
<Overlap Ratio: 0.954653937947494>

---

--- 287 --
Question ID: b044cac608377e976431436a46c3f1bd6a931f52_1
Original Code:
```
pub fn load_random_spheres(num_spheres: u16) -> (Vec<Object>, Vec<Light>) {
    let mut objects = vec![];
    let mut lights = vec![];

    // ground plane
    let phong = MaterialType::new_phong(1.0, 0.0, 0.2);
    let color = TextureType::new_flat(Color::grayscale(0.3));
    let object = Object::new_quad(
        (-100.0, 0.0, 10.0).into(),
        (10.0, 0.0, 10.0).into(),
        (10.0, 0.0, -10.0).into(),
        (-100.0, 0.0, -10.0).into(),
        Material::new(phong, color),
    );
    objects.push(object);

    // back plane
    let back_pos = -8.0;
    let height = 4.;
    let phong = MaterialType::new_phong(1.0, 0.0, 1.0);
    let color = TextureType::new_flat(Color::blue() * Color::grayscale(0.5));
    let object = Object::new_quad(
        (10.0, -1.0, back_pos).into(),
        (10.0, height, back_pos).into(),
        (-10.0, height, back_pos).into(),
        (-10.0, -1.0, back_pos).into(),
        Material::new(phong, color),
    );
    objects.push(object);

    let mut rng = StdRng::seed_from_u64(248);
    for _ in 0..num_spheres {
        let phong = MaterialType::new_phong(1.0, 0.0, 1.0);
        let r: f32 = rng.gen_range(0.5, 1.);
        let g: f32 = rng.gen_range(0.5, 1.);
        let b: f32 = rng.gen_range(0.5, 1.);
        let color = TextureType::new_flat(Color::rgb(r, g, b));

        let x: f32 = rng.gen_range(-4., 4.0);
        let y: f32 = rng.gen_range(0.1, 2.5);
        let z: f32 = rng.gen_range(-6., 3.5);
        let r: f32 = rng.gen_range(0.05, 0.15);

        let object = Object::new_sphere((x, y, z).into(), r, Material::new(phong, color));
        objects.push(object);
    }

    // add some reflective spheres in the middle
    let mut add_sphere = |point, color| {
        let phong = MaterialType::new_phong(1.0, 0.6, 1.0);
        let mirror = MaterialType::Reflective;
        let object = Object::new_sphere(
            point,
            0.5,
            Material::new(
                MaterialType::Composition(vec![(mirror, 0.6), (phong, 0.4)]),
                TextureType::new_flat(color),
            ),
        );
        objects.push(object);
    };
    add_sphere((0., 0.5, 0.).into(), Color::red());
    add_sphere((1.5, 0.5, 0.5).into(), Color::blue());
    add_sphere((-1.5, 0.5, -0.5).into(), Color::yellow());

    let light = Light::new_point((1.0, 2.0, 2.5).into(), Color::white());
    lights.push(light);
    let light = Light::new_point((-2.0, 2.0, 1.).into(), Color::white());
    lights.push(light);
    let light = Light::new_ambient(Color::grayscale(0.2));
    lights.push(light);
    let light = Light::new_directional((-0.2, -1., -0.9).into(), Color::grayscale(0.3));
    lights.push(light);

    (objects, lights)
}
```


Overlapping Code:
```
s: u16) -> (Vec<Object>, Vec<Light>) {
let mut objects = vec![];
let mut lights = vec![];
// ground plane
let phong = MaterialType::new_phong(1.0, 0.0, 0.2);
let color = TextureType::new_flat(Color::grayscale(0.3));
let object = Object::new_quad(
(-100.0, 0.0, 10.0).into(),
(10.0, 0.0, 10.0).into(),
(10.0, 0.0, -10.0).into(),
(-100.0, 0.0, -10.0).into(),
Material::new(phong, color),
);
objects.push(object);
// back plane
let back_pos = -8.0;
let height = 4.;
let phong = MaterialType::new_phong(1.0, 0.0, 1.0);
let color = TextureType::new_flat(Color::blue() * Color::grayscale(0.5));
let object = Object::new_quad(
(10.0, -1.0, back_pos).into(),
(10.0, height, back_pos).into(),
(-10.0, height, back_pos).into(),
(-10.0, -1.0, back_pos).into(),
Material::new(phong, color),
);
objects.push(object);
let mut rng = StdRng::seed_from_u64(248);
for _ in 0..num_spheres {
let phong = MaterialType::new_phong(1.0, 0.0, 1.0);
let r: f32 = rng.gen_range(0.5, 1.);
let g: f32 = rng.gen_range(0.5, 1.);
let b: f32 = rng.gen_range(0.5, 1.);
let color = TextureType::new_flat(Color::rgb(r, g, b));
let x: f32 = rng.gen_range(-4., 4.0);
let y: f32 = rng.gen_range(0.1, 2.5);
let z: f32 = rng.gen_range(-6., 3.5);
let r: f32 = rng.gen_range(0.05, 0.15);
let object = Object::new_sphere((x, y, z).into(), r, Material::new(phong, color));
objects.push(object);
}
// add some reflective spheres in the middle
let mut add_sphere = |point, color| {
let phong = MaterialType::new_phong(1.0, 0.6, 1.0);
let mirror = MaterialType::Reflective;
let object = Object::new_sphere(
point,
0.5,
Material::new(
MaterialType::Composition(vec![(mirror, 0.6), (phong, 0.4)]),
TextureType::new_flat(color),
),
);
objects.push(object);
};
add_sphere((0., 0.5, 0.).into(), Color::red());
add_sphere((1.5, 0.5, 0.5).into(), Color::blue());
add_sphere((-1.5, 0.5, -0.5).into(), Color::yellow());
let light = Light::new_point((1.0, 2.0, 2.5).into(), Color::white());
lights.push(light);
let light = Light::new_point((-2.0, 2.0, 1.).in
```
<Overlap Ratio: 0.9601536245799328>

---

--- 288 --
Question ID: e61f023b0999b0ade1044e47506d5757090f0ac5_1
Original Code:
```
pub fn root_search<'de, T>(key: &str, candidate: &'de str) -> Result<T, Error> where T: Deserialize<'de> {
    if key.is_empty() {
        return Error::json("The searched key can't be empty");
    }

    //get candidate slice starting at the first character of the value
    let value_begin = {
        let mut quoted_key = String::with_capacity(key.len() + 2);
        quoted_key.push('"');
        quoted_key.push_str(key);
        quoted_key.push('"');

        let mut iter = candidate.chars();
        let mut key_iter = quoted_key.chars();
        let mut prev_index = 0;
        let mut nesting_level = 0;
        let mut key_end = None;

        while key_end.is_none() {
            if nesting_level < 0 {
                return Error::json("Incorrectly formatted JSON string");
            }

            if let Some(next) = iter.next() {
                if next == '{' || next == '[' {
                    nesting_level += 1
                } else if next == '}' || next == ']' {
                    nesting_level -= 1
                }

                if nesting_level == 1 {
                    if let Some(key_next) = key_iter.next() {
                        if next != key_next {
                            key_iter = quoted_key.chars();
                        }
                    } else {
                        key_end = Some(prev_index + 1);
                        break;
                    }
                }

                prev_index += 1;
            } else {
                return Error::json("Could not find key in candidate");
            }
        }

        if key_end.is_none() {
            return Error::json("Could not find key in candidate");
        }

        match candidate[key_end.unwrap()..].find(|c: char| c.is_numeric() || c == '"') {
            Some(i) => &candidate[key_end.unwrap() + i..],
            None => return Error::json("Could not find value in candidate")
        }
    };

    let mut iter = value_begin.chars();
    let mut prev_index = 0;
    let mut nesting_level = 0;
    let mut value = None;

    while value.is_none() {
        if let Some(next) = iter.next() {
            if next == '{' || next == '[' {
                nesting_level += 1
            } else if next == '}' || next == ']' {
                nesting_level -= 1
            }

            if next == ',' || (nesting_level == -1 && next == '}') { //reached the end of the json value/string
                value = Some(&value_begin[..prev_index]);
            }

            prev_index += 1;
        } else {
            return Error::json("Unexpected end of string");
        }
    }

    if let Some(value) = value {
        return match serde_json::from_str(value) {
            Ok(value) => Ok(value),
            Err(e) => Error::json(e)
        };
    }

    Error::json("An error occurred while searching for key")
}
```


Overlapping Code:
```
ub fn root_search<'de, T>(key: &str, candidate: &'de str) -> Result<T, Error> where T: Deserialize<'de> {
if key.is_empty() {
return Error::json("The searched key can't be empty");
}
//get candidate slice starting at the first character of the value
let value_begin = {
let mut quoted_key = String::with_capacity(key.len() + 2);
quoted_key.push('"');
quoted_key.push_str(key);
quoted_key.push('"');
let mut iter = candidate.chars();
let mut key_iter = quoted_key.chars();
let mut prev_index = 0;
let mut nesting_level = 0;
let mut key_end = None;
while key_end.is_none() {
if nesting_level < 0 {
return Error::json("Incorrectly formatted JSON string");
}
if let Some(next) = iter.next() {
if next == '{' || next == '[' {
nesting_level += 1
} else if next == '}' || next == ']' {
nesting_level -= 1
}
if nesting_level == 1 {
if let Some(key_next) = key_iter.next() {
if next != key_next {
key_iter = quoted_key.chars();
}
} else {
key_end = Some(prev_index + 1);
break;
}
}
prev_index += 1;
} else {
return Error::json("Could not find key in candidate");
}
}
if key_end.is_none() {
return Error::json("Could not find key in candidate");
}
match candidate[key_end.unwrap()..].find(|c: char| c.is_numeric() || c == '"') {
Some(i) => &candidate[key_end.unwrap() + i..],
None => return Error::json("Could not find value in candidate")
}
};
let mut iter = value_begin.chars();
let mut prev_index = 0;
let mut nesting_level = 0;
let mut value = None;
while value.is_none() {
if let Some(next) = iter.next() {
if next == '{' || next == '[' {
nesting_level += 1
} else if next == '}' || next == ']' {
nesting_level -= 1
}
if next == ',' || (nesting_level == -1 && next == '}') { //reached the end of the json value/string
value = Some(&value_begin[..prev_inde
```
<Overlap Ratio: 0.9971509971509972>

---

--- 289 --
Question ID: 78a8d2f96d989b8321463b46b92fe7c8a260d4f7_0
Original Code:
```
fn main() {
    // instantiating analyzer opts
    let analyzer_opts = AnalyzerOpts {
        Name: String::from("rust"),
        AnalysisConfigPath: String::from("/toolbox/analysis_config.json"),
        FileFinderRegex: String::from("\\.rs$"),
        CodePath: String::from("/Users/sidntrivedi012/Code/cap"),
        ResultPath: String::from("/toolbox/analysis_results.json"),
    };

    // rustup update
    let output = Command::new("rustup")
        .args(&["update"])
        .current_dir(&analyzer_opts.CodePath)
        .output()
        .expect("ls command failed to start");

    println!("status: {}", output.status);
    io::stdout().write_all(&output.stdout).unwrap();
    io::stderr().write_all(&output.stderr).unwrap();

    assert!(output.status.success());

    // installing clippy
    let output = Command::new("rustup")
        .args(&["component", "add", "clippy"])
        .current_dir(&analyzer_opts.CodePath)
        .output()
        .expect("ls command failed to start");

    println!("status: {}", output.status);
    io::stdout().write_all(&output.stdout).unwrap();
    io::stderr().write_all(&output.stderr).unwrap();

    // running clippy and getting data in json format
    let output = Command::new("cargo")
        .args(&[
            "clippy",
            "--message-format",
            "json",
            "--",
            "-W",
            "clippy::all",
        ])
        .current_dir(&analyzer_opts.CodePath)
        .output()
        .expect("clippy failed to work");

    // io::stdout().write_all(&output.stdout).unwrap();
    io::stderr().write_all(&output.stderr).unwrap();

    // write the output to a file
    let mut buffer = File::create("foo.txt").unwrap();
    buffer.write_all(&output.stdout);
    // reading the clippy out line by line
    let mut v = Vec::new();
    // counting lines to prevent parsing the last 3 objects (they are useless)
    let lines_count: usize = count_lines(std::fs::File::open("foo.txt").unwrap()).unwrap();
    let mut count: usize = 0;

    // iterating throughout the file of clippy data and finding the useful stuff
    // and dumping into the analyzer object
    if let Ok(lines) = read_lines("./foo.txt") {
        for line in lines {
            count = count + 1;
            if count == lines_count - 3 {
                break;
            }

            if let Ok(ip) = line {
                // println!("{}", ip);
                if ip.starts_with("{\"reason\":\"compiler-message\"") {
                    let _res: Report = serde_json::from_str(&ip).unwrap();
                    // println!("{} hello", _res.message.code.code);
                    if _res.reason == "compiler-message" {
                        // and make an array of objects
                        v.push(_res)
                    }
                }
            }
        }
    }

    let mut buffer = File::create("results.json").unwrap();
    let mut result_output = serde_json::to_string_pretty(&v).unwrap();

    // writing the output to a file
    buffer
        .write_all(&result_output.as_bytes())
        .expect("Writing the analysis result failed");

    // DEPENDENCY CALCULATION
    // command - cargo tree --prefix depth | grep -c '^[[:space:]]*1' | wc -l
    // counting direct dependencies
    let mut deps_index = Command::new("cargo")
        .args(&["tree", "--prefix", "depth"])
        .current_dir(&analyzer_opts.CodePath)
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to run cargo command to calc direct deps");

    // we won't need deps_index anymore.
    let deps_index_output = deps_index.stdout.expect("Failed to run cargo command");

    let direct_deps = Command::new("grep")
        .args(&["-c", "^[[:space:]]*1"])
        .stdin(Stdio::from(deps_index_output))
        .stdout(Stdio::piped())
        .current_dir(&analyzer_opts.CodePath)
        .spawn()
        .expect("grepping failed to work");

    let mut direct_deps_output = direct_deps.stdout.expect("Failed again");
    // let mut total_deps_output = total_deps.stdout.expect("Total deps stdout failed.");
    let mut direct_deps_op = String::new();
    // let mut total_deps_op = String::new();
    direct_deps_output
        .read_to_string(&mut direct_deps_op)
        .unwrap();
    // total_deps_output
    //     .read_to_string(&mut total_deps_op)
    //     .unwrap();
    println!("***********");
    // println!("Total dependencies = {}", &total_deps_op);
    println!("Number of direct deps = {}", &direct_deps_op);
}
```


Overlapping Code:
```

// instantiating analyzer opts
let analyzer_opts = AnalyzerOpts {
Name: String::from("rust"),
AnalysisConfigPath: String::from("/toolbox/analysis_config.json"),
FileFinderRegex: String::from("\\.rs$"),
CodePath: String::from("/Users/sidntrivedi012/Code/cap"),
ResultPath: String::from("/toolbox/analysis_results.json"),
};
// rustup update
let output = Command::new("rustup")
.args(&["update"])
.current_dir(&analyzer_opts.CodePath)
.output()
.expect("ls command failed to start");
println!("status: {}", output.status);
io::stdout().write_all(&output.stdout).unwrap();
io::stderr().write_all(&output.stderr).unwrap();
assert!(output.status.success());
// installing clippy
let output = Command::new("rustup")
.args(&["component", "add", "clippy"])
.current_dir(&analyzer_opts.CodePath)
.output()
.expect("ls command failed to start");
println!("status: {}", output.status);
io::stdout().write_all(&output.stdout).unwrap();
io::stderr().write_all(&output.stderr).unwrap();
// running clippy and getting data in json format
let output = Command::new("cargo")
.args(&[
"clippy",
"--message-format",
"json",
"--",
"-W",
"clippy::all",
])
.current_dir(&analyzer_opts.CodePath)
.output()
.expect("clippy failed to work");
// io::stdout().write_all(&output.stdout).unwrap();
io::stderr().write_all(&output.stderr).unwrap();
// write the output to a file
let mut buffer = File::create("foo.txt").unwrap();
buffer.write_all(&output.stdout);
// reading the clippy out line by line
let mut v = Vec::new();
// counting lines to prevent parsing the last 3 objects (they are useless)
let lines_count: usize = count_lines(std::fs::File::open("foo.txt").unwrap()).unwrap();
let mut count: usize = 0;
// iterating throughout the file of clippy data and finding the useful stuff
// and dumping into the analyzer object
if let Ok(lines) = read_lines("./foo.txt") {
for line in lines {
count = count + 1;
if count == lines_count - 3 {
break;
}
if let Ok(ip) = line {
// println!("{}", ip);
if ip.starts_with("{\"reason
```
<Overlap Ratio: 0.9813542688910697>

---

--- 290 --
Question ID: 3578a8e8be320e2e4b7f711611462efd8b2bee33_0
Original Code:
```
fn create_random_filename(dir: &Path) -> PathBuf {
    let mut filename = [0; FILENAME_LEN];
    rand::thread_rng().fill_bytes(&mut filename);
    dir.join(hex::encode(filename))
}
```


Overlapping Code:
```
ilename(dir: &Path) -> PathBuf {
let mut filename = [0; FILENAME_LEN];
rand::thread_rng().fill_bytes(&mut filename);
dir.join(hex::encode(filename))
}
```
<Overlap Ratio: 0.8928571428571429>

---

--- 291 --
Question ID: e4014ad2ef49b9f8842aa1a116997512e34450ee_0
Original Code:
```
fn test_match() {
        let event: Box<Event> = Box::new(A);

        let mut n: usize = 0;
        match_event!(event:
            A => n += 1,
            A => n += 1,
            B => assert!(false),
            C => assert!(false),
        );

        assert!(n == 2);
    }
```


Overlapping Code:
```
x::new(A);
let mut n: usize = 0;
match_event!(event:
A => n += 1,
A => n += 1,
B => assert!(false),

```
<Overlap Ratio: 0.5376344086021505>

---

--- 292 --
Question ID: eae1227b582379cf3931a0bdc1d191a1375469e6_0
Original Code:
```
pub fn init(
    ipfs_path: &Path,
    bits: NonZeroU16,
    mut profiles: Vec<Profile>,
) -> Result<String, InitializationError> {
    use multibase::Base::Base64Pad;
    use prost::Message;
    use std::fs::OpenOptions;
    use std::io::{BufWriter, Write};

    match profiles.len() {
        0 => profiles.push(Profile::Default),
        1 => {}
        _ => unimplemented!("Multiple profiles are currently unsupported!"),
    };

    let bits = bits.get();

    if !(2048..=16 * 1024).contains(&bits) {
        // Ring won't accept less than a 2048 bit key.
        return Err(InitializationError::InvalidRsaKeyLength(bits));
    }

    let pk = openssl::rsa::Rsa::generate(bits as u32)
        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;

    // sadly the pkcs8 to der functions are not yet exposed via the nicer interface
    // https://github.com/sfackler/rust-openssl/issues/880
    let pkcs8 = openssl::pkey::PKey::from_rsa(pk.clone())
        .and_then(|pk| pk.private_key_to_pem_pkcs8())
        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;

    let mut pkcs8 = pem_to_der(&pkcs8);

    let kp = ipfs::Keypair::rsa_from_pkcs8(&mut pkcs8)
        .expect("Failed to turn pkcs#8 into libp2p::identity::Keypair");

    let peer_id = kp.public().to_peer_id().to_string();

    // TODO: this part could be PR'd to rust-libp2p as they already have some public key
    // import/export but probably not if ring does not support these required conversions.

    let pkcs1 = pk
        .private_key_to_der()
        .map_err(|e| InitializationError::KeyGeneration(Box::new(e)))?;

    let key_desc = keys_proto::PrivateKey {
        r#type: keys_proto::KeyType::Rsa as i32,
        data: pkcs1,
    };

    let private_key = {
        let mut buf = Vec::with_capacity(key_desc.encoded_len());
        key_desc
            .encode(&mut buf)
            .map_err(InitializationError::PrivateKeyEncodingFailed)?;
        buf
    };

    let private_key = Base64Pad.encode(&private_key);

    let api_addr = match profiles[0] {
        Profile::Test => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(0u16)),
        Profile::Default => multiaddr!(Ip4([127, 0, 0, 1]), Tcp(4004u16)),
    };

    let config_contents = CompatibleConfigFile {
        identity: Identity {
            peer_id: peer_id.clone(),
            private_key,
        },
        addresses: Addresses {
            swarm: vec!["/ip4/127.0.0.1/tcp/0".parse().unwrap()],
            api: api_addr,
        },
    };

    let config_path = ipfs_path.join("config");

    let config_file = fs::create_dir_all(&ipfs_path)
        .map_err(InitializationError::DirectoryCreationFailed)
        .and_then(|_| {
            OpenOptions::new()
                .write(true)
                .create_new(true)
                .open(&config_path)
                .map_err(InitializationError::ConfigCreationFailed)
        })?;

    let mut writer = BufWriter::new(config_file);

    serde_json::to_writer_pretty(&mut writer, &config_contents)
        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;

    writer
        .flush()
        .map_err(|e| InitializationError::ConfigWritingFailed(Box::new(e)))?;

    Ok(peer_id)
}
```


Overlapping Code:
```
use std::fs::OpenOptions;
use std::io::{BufWriter, Write};ey {
r#type: keys_proto::KeyType::Rsa as i32,
data
```
<Overlap Ratio: 0.05101558809636278>

---

--- 293 --
Question ID: 4851154e3a4d1a8c37f052f71a12d696c4f561f9_1
Original Code:
```
pub fn latest_version_fuzzy(
    name: &str,
    source_id: SourceId,
    version_req: VersionReq,
    allow_prerelease: bool,
) -> DargoResult<Option<(String, Version)>> {
    if let Some(version) = latest_version(name, source_id, version_req.clone(), allow_prerelease)? {
        return Ok(Some((name.to_string(), version)));
    }

    let mut name = name.to_string();
    let positions: Vec<usize> = name
        .bytes()
        .enumerate()
        .filter(|(_, item)| *item == b'-' || *item == b'_')
        .map(|(index, _)| index)
        .collect::<Vec<_>>();
    match positions.len() {
        0 => return Ok(None),
        1..=127 => {}
        _ => return Err(format_err!("crate name contain too many '-' or '_'")),
    }

    for mask in 0..u128::pow(2, positions.len() as u32) {
        positions.iter().enumerate().for_each(|(index, item)| {
            #[allow(unsafe_code)]
            unsafe {
                name.as_bytes_mut()[*item] = match (mask >> index) & 1 {
                    0 => b'_',
                    1 => b'-',
                    _ => unreachable!(),
                }
            };
        });
        if let Some(version) =
            latest_version(&name, source_id, version_req.clone(), allow_prerelease)?
        {
            return Ok(Some((name, version)));
        }
    }

    Ok(None)
}
```


Overlapping Code:
```
 &str,
source_id: SourceId,
version_req: VersionReq,
allow_prerelease: bool,
) -> DargoResult<Option<(String, Version)>> {
if let Some(version) = latest_version(name, source_id, version_req.clone(), allow_prerelease)? {
return Ok(Some((name.to_string(), version)));
}
let mut name = name.to_string();
let positions: Vec<usize> = name
.bytes()
.enumerate()
.filter(|(_, item)| *item == b'-' || *item == b'_')
.map(|(index, _)| index)
.collect::<Vec<_>>();
match positions.len() {
0 => return Ok(None),
1..=127 => {}
_ => return Err(format_err!("crate name contain too many '-' or '_'")),
}
for mask in 0..u128::pow(2, positions.len() as u32) {
positions.iter().enumerate().for_each(|(index, item)| {
#[allow(unsafe_code)]
unsafe {
name.as_bytes_mut()[*item] = match (mask >> index) & 1 {
0 => b'_',
1 => b'-',
_ => unreachable!(),
}
};
});
if let Some(version) =
latest_version(&name, source_id, version_req.clone(), allow_prerelease)?
{
return Ok(Som
```
<Overlap Ratio: 0.9322865554465162>

---

--- 294 --
Question ID: e62e21c4291d8580cfe49d3f73df509411f2e1b3_0
Original Code:
```
fn glsl_compiler_options_has_default() {
    let compiler_options = glsl::CompilerOptions::default();
    assert_eq!(compiler_options.vertex.invert_y, false);
    assert_eq!(compiler_options.vertex.transform_clip_space, false);
}
```


Overlapping Code:
```
piler_options_has_default() {
let compiler_options = glsl::CompilerOptions::default();
assert_eq!(compiler_options.vertex.invert_y, false);
assert_eq!(compiler_options.vertex.transform_clip_space, fal
```
<Overlap Ratio: 0.9216589861751152>

---

--- 295 --
Question ID: 85718803d8cbe5d92c3b56bf3d3d9e18c1bac244_0
Original Code:
```
fn get_public_key() {
    let core = test_core_with_account();
    let account = core.get_account().unwrap();

    let result =
        api_service::request(&account, GetPublicKeyRequest { username: account.username.clone() })
            .unwrap()
            .key;
    assert_eq!(result, account.public_key());
}
```


Overlapping Code:
```
 get_public_key() {
let core = test_core_with_account();
let account = core.get_account().unwrap();
let result =
api_service::request(&account, GetPublicKeyRequest { username: account.username.clone() })
.unwrap()
.key;
assert_eq!(result, account.pub
```
<Overlap Ratio: 0.9433962264150944>

---

--- 296 --
Question ID: c2c03b030e425445ac11f1c3ff7d2f895cfe7571_2
Original Code:
```
fn part2(input: &(Vec<u32>, Vec<Board>)) -> u32 {
    let (rnd, mut boards) = input.clone();
    let mut winning_board = Vec::new();
    for &n in rnd.iter() {
        let mut winers = Vec::new();
        for (id, b) in boards.iter_mut().enumerate() {
            let set = update_board(b, n);
            if check_vicotry(set, b) {
                winers.push(id);
            }
        }
        winers.iter().rev().for_each(|&id| {
            let b = boards.remove(id);
            let score = compute_score(&b, n);
            winning_board.push(score);
        })
    }
    *winning_board.last().expect("No one won!")
}
```


Overlapping Code:
```
2>, Vec<Board>)) -> u32 {
let (rnd, mut boards) = input.clone();
let mut winning_board = Vec::new();
for &n in rnd.iter() {
let mut winers = Vec::new();
for (id, b) in boards.iter_mut().enumerate() {
let set = update_board(b, n);
if check_vicotry(set, b) {
winers.push(id);
}
}
winers.iter().rev().for_each(|&id| {
let b = boards.remove(id);
let score = compute_score(&b, n);
winning_board.push(score);
})
}
*winning_board.last().expect("No one won!"
```
<Overlap Ratio: 0.9433962264150944>

---

--- 297 --
Question ID: 37860bbce24be581e99cbef37a3061d9a9423a1f_3
Original Code:
```
fn as_deref_cow_box_str_borrowed() {
        let tmp = Box::from("bar");
        let input: Cow<Box<str>> = Cow::Borrowed(&tmp);
        let output: Cow<str> = as_deref_cow(input);

        assert!(matches!(output, Cow::Borrowed(_)));
        assert_eq!(output, "bar");
    }
```


Overlapping Code:
```
mp = Box::from("bar");
let input: Cow<Box<str>> = Cow::Borrowed(&tmp);
let output: Cow<str> = as_deref_cow(input);
assert!(matches!(output, Cow::Borrowed
```
<Overlap Ratio: 0.6652173913043479>

---

--- 298 --
Question ID: 382a1ed431703e0a3e85583574917dc47b1f2aa2_0
Original Code:
```
async fn check_add_documents_with_primary_key_param() {
    let mut server = common::Server::with_uid("movies");

    // 1 - Create the index with no primary_key

    let body = json!({
        "uid": "movies",
    });
    let (response, status_code) = server.create_index(body).await;
    assert_eq!(status_code, 201);
    assert_eq!(response["primaryKey"], json!(null));

    // 2 - Add documents

    let body = json!([{
      "title": "Test",
      "comment": "comment test"
    }]);

    let url = "/indexes/movies/documents?primaryKey=title";
    let (response, status_code) = server.post_request(&url, body).await;
    eprintln!("{:#?}", response);
    assert_eq!(status_code, 202);
    let update_id = response["updateId"].as_u64().unwrap();
    server.wait_update_id(update_id).await;

    // 3 - Check update success

    let (response, status_code) = server.get_update_status(update_id).await;
    assert_eq!(status_code, 200);
    assert_eq!(response["status"], "processed");
}
```


Overlapping Code:
```
h_primary_key_param() {
let mut server = common::Server::with_uid("movies");
// 1 - Create the index with no primary_key
let body = json!({
"uid": "movies",
});
let (response, status_code) = server.create_index(body).await;
assert_eq!(status_code, 201);
assert_eq!(response["primaryKey"], json!(null));
// 2 - Add documents
let body = json!([{
"title": "Test",
"comment": "comment test"
}]);
let url = "/indexes/movies/documents?primaryKey=title";
let (response, status_code) = server.post_request(&url, body).await;
eprintln!("{:#?}", response);
assert_eq!(status_code, 202);
let update_id = response["updateId"].as_u64().unwrap();
server.wait_update_id(update_id).await;
// 3 - Check update success
let (response, status_code) = server.get_update_status(update_id).await;
assert_eq!(status_code, 200);
assert_eq!(response["status"], "processed"
```
<Overlap Ratio: 0.9591836734693877>

---

--- 299 --
Question ID: fb3c2a80f57eac3c9e182aba268833366b9795da_0
Original Code:
```
pub fn apply(weights: &[[(([b64; 8], [b64; 8]), u32); 64]; 4], input: &[b64; 8]) -> [b64; 4] {
    let mut target = [b64(0); 4];
    for w in 0..4 {
        for b in 0..64 {
            let sign = masked_hamming_dist(input, &weights[w][b].0) > weights[w][b].1;
            target[w].set_bit_in_place(b, sign);
        }
    }
    target
}
```


Overlapping Code:
```
s: &[[(([b64; 8], [b64; 8]), u32); 64]; 4], input: &[b64; 8]) -> [b64; 4] {
let mut target = [b64(0); 4];
for w in 0..4 {
for b in 0..64 {
let sign = masked_hamming_dist(input, &weights[w][b].0) > weights[w][b].1;
target[w].set_bit_in_place(b, sign);
```
<Overlap Ratio: 0.8865248226950354>

---

--- 300 --
Question ID: f96689d9fe0baeefae8f3df677f31d76ee06b14e_1
Original Code:
```
fn parse_wire(s: &str) -> Wire {
    let mut horiz = Vec::new();
    let mut vert = Vec::new();
    let mut y = 0;
    let mut x = 0;
    let mut total_length = 0;

    for seg in s.split(',') {
        let dir = seg.chars().next().unwrap();
        let length: i32 = seg[1..].parse().expect("can't parse integer");

        let old_y = y;
        let old_x = x;
        let old_length = total_length;

        total_length += length;

        match dir {
            'U' => {
                y -= length;
                vert.push((x, y, old_y, total_length, -1));
            }
            'D' => {
                y += length;
                vert.push((x, old_y, y, old_length, 1));
            }
            'L' => {
                x -= length;
                horiz.push((y, x, old_x, total_length, -1));
            }
            'R' => {
                x += length;
                horiz.push((y, old_x, x, old_length, 1));
            }
            _ => panic!("Unknown direction {} of {}", dir, seg),
        }
    }
    (horiz, vert)
}
```


Overlapping Code:
```

let mut horiz = Vec::new();
let mut vert = Vec::new();
let mut y = 0;
let mut x = 0;
let mut total_length = 0;
for seg in s.split(',') {
let dir = seg.chars().next().unwrap();
let length: i32 = seg[1..].parse().expect("can't parse integer");
let old_y = y;
let old_x = x;
let old_length = total_length;
total_length += length;
match dir {
'U' => {
y -= length;
vert.push((x, y, old_y, total_length, -1));
}
'D' => {
y += length;
vert.push((x, old_y, y, old_length, 1));
}
'L' => {
x -= length;
horiz.push((y, x, old_x, total_length, -1));
}
'R' => {
x += length;
horiz.push((y, old_x, x, old_length, 1));
}
_ => panic!("Unknown direction {} of {}", 
```
<Overlap Ratio: 0.9129213483146067>

---

--- 301 --
Question ID: f80c6b4ebb0991825a6a7bd67624779b98009564_4
Original Code:
```
fn bench_update_depth4(bench: &mut Bencher) {
    static mut TEST_HUNK: [u8; 256*1024*1024] = [0; 256*1024*1024];
    let slab = Slab::new(unsafe { Block::from_slice(&mut TEST_HUNK) }, 4096);
    let pool = &Pool::new(&slab);

    bench_update!(bench, pool, 1 << 20);
}
```


Overlapping Code:
```
n bench_update_depth4(bench: &mut Bencher) {
static mut TEST_HUNK: [u8; 256*1024*1024] = [0; 256*1024*1024];
let slab = Slab::new(unsafe { Block::from_slice(&mut TEST_HUNK) }, 4096);
let pool = &Pool::new(&slab);
bench_update!(bench, pool, 1 << 20);

```
<Overlap Ratio: 0.9920634920634921>

---

--- 302 --
Question ID: 30a7f586689cb6caa74ef86e2e08e067ec229f1c_0
Original Code:
```
fn has_cmd(cmd: &str) -> bool {
    let cmd = format!("{}{}", cmd, env::consts::EXE_SUFFIX);
    let path = env::var_os("PATH").unwrap_or_default();
    env::split_paths(&path)
        .map(|p| p.join(&cmd))
        .any(|p| p.exists())
}
```


Overlapping Code:
```
 has_cmd(cmd: &str) -> bool {
let cmd = format!("{}{}", cmd, env::consts::EXE_SUFFIX);
let path = env::var_os("PATH").unwrap_or_default();
env::split_paths(&path)
.map(|p| p.join(&cmd))
.any(|p| p.exi
```
<Overlap Ratio: 0.9523809523809523>

---

--- 303 --
Question ID: 90b6936df788397fc5d6af5f3593e71e3edc2b4a_228
Original Code:
```
pub async fn delete(
        operation_config: &crate::OperationConfig,
        network_resource_name: &str,
    ) -> std::result::Result<delete::Response, delete::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!("{}/Resources/Networks/{}", operation_config.base_path(), network_resource_name);
        let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::DELETE);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(delete::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => Ok(delete::Response::Ok200),
            http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
            http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(delete::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn delete(
operation_config: &crate::OperationConfig,
network_resource_name: &str,
) -> std::result::Result<delete::Response, delete::Error> {
let http_client = operation_config.http_client();
let url_str = &format!("{}/Resources/Networks/{}", operation_config.base_path(), network_resource_name);
let mut url = url::Url::parse(url_str).map_err(delete::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::DELETE);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(delete::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(delete::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(delete::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => Ok(delete::Response::Ok200),
http::StatusCode::ACCEPTED => Ok(delete::Response::Accepted202),
http::StatusCode::NO_CONTENT => Ok(delete::Response::NoContent204),
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::FabricError =
serde_json::from_slice(rsp_body).map_err(|source| delete::Error::DeserializeError(source, rsp_body.clone()))?;
Err(delete::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 304 --
Question ID: 96e0cdf28795914d09d8687e1ce841c73a6d5d6b_3
Original Code:
```
pub fn compress_xof(
    cv: &[Word; 8],
    block: &[u8; BLOCK_LEN],
    block_len: u8,
    offset: u64,
    flags: u8,
) -> [u8; 64] {
    let state = compress_inner(cv, block, block_len, offset, flags);
    let mut output = [0u8; 64];
    for i in 0..8 {
        output[i * 4..][..4].copy_from_slice(&(state[i] ^ state[i + 8]).to_le_bytes());
    }
    for i in 8..16 {
        output[i * 4..][..4].copy_from_slice(&(state[i] ^ cv[i - 8]).to_le_bytes());
    }
    output
}
```


Overlapping Code:
```
Word; 8],
block: &[u8; BLOCK_LEN],
block_len: u8,
offset: u64,
flags: u8,
) -> [u8; 64] {
let state = compress_inner(cv, block, block_len, offset, flags);
let mut output = [0u8; 64];
for i in 0..8 {
output[i * 4..][..4].copy_from_slice(&(state[i] ^ state[i + 8]).to_le_bytes());
}
for i in 8..16 {
output[i * 4..][..4].copy_from_slice(&(state[i] ^ cv[i 
```
<Overlap Ratio: 0.8567961165048543>

---

--- 305 --
Question ID: 4bafbac85b82b48627cb5e5d752ebe33d43c9991_6
Original Code:
```
fn test_merge_uint_max(mut x: IncrementOnlyUintProp, y: IncrementOnlyUintProp) {
        init_test_env();
        x.merge_property(&y);
        assert_eq!(x.clone(), std::cmp::max(x, y));
    }
```


Overlapping Code:
```
: IncrementOnlyUintProp, y: IncrementOnlyUintProp) {
init_test_env();
x.merge_property(&y);
assert_eq!(x.clone(), std::cmp:
```
<Overlap Ratio: 0.7454545454545455>

---

--- 306 --
Question ID: 2bf348d25487b4251a1de16083e19907a7e81be9_6
Original Code:
```
fn format_count_internal<T>(count: T, zero: &str) -> String
where
    T: num::ToPrimitive,
{
    let format_count_helper = |count: u64, zeroes: u32, suffix: &str| -> Option<String> {
        let unit: u64 = 10_u64.pow(zeroes);

        if (count as f64 / unit as f64) < 99.95 {
            Some(format!(
                "{:.1}{}",
                (count as f64 / unit as f64).max(0.1),
                suffix
            ))
        } else if (count as f64 / unit as f64) < 1000.0 {
            Some(format!("{:.0}{}", count as f64 / unit as f64, suffix))
        } else {
            None
        }
    };

    let count = count.to_u64().unwrap();

    if count == 0 {
        zero.to_string()
    } else if count < 1000 {
        format!("{}", count)
    } else {
        format_count_helper(count, 3, "k")
            .or_else(|| format_count_helper(count, 6, "m"))
            .or_else(|| format_count_helper(count, 9, "g"))
            .or_else(|| format_count_helper(count, 12, "p"))
            .or_else(|| format_count_helper(count, 15, "e"))
            .unwrap_or_else(|| "INF".into())
    }
}
```


Overlapping Code:
```
 zero: &str) -> String
where
T: num::ToPrimitive,
{
let format_count_helper = |count: u64, zeroes: u32, suffix: &str| -> Option<String> {
let unit: u64 = 10_u64.pow(zeroes);
if (count as f64 / unit as f64) < 99.95 {
Some(format!(
"{:.1}{}",
(count as f64 / unit as f64).max(0.1),
suffix
))
} else if (count as f64 / unit as f64) < 1000.0 {
Some(format!("{:.0}{}", count as f64 / unit as f64, suffix))
} else {
None
}
};
let count = count.to_u64().unwrap();
if count == 0 {
zero.to_string()
} else if count < 1000 {
format!("{}", count)
} else {
format_count_helper(count, 3, "k")
.or_else(|| format_count_helper(count, 6, "m"))
.or_else(|| format_count_helper(count, 9, "g"))
.or_else(|| format_count_helper(count, 12, "p"))
.or_else(|| format_count_helper(count, 15, "e"))
.unwrap_or_else(|| "INF".i
```
<Overlap Ratio: 0.9445100354191264>

---

--- 307 --
Question ID: ab9a84dc67ec85ee5af20790dc20a79849447df0_0
Original Code:
```
fn main() {
    let matches = App::new("pdb-harvester")
        .version("1.0")
        .author("Orhan B. <orhanbalci@gmail.com>")
        .about("Harvests odb files online and transforms them")
        .subcommand(
            SubCommand::with_name("download")
                .about("Downloads pdb files from ncsb")
                .version("1.0")
                .author("Orhan B. <orhanbalci@gmail.com>")
                .arg(
                    Arg::with_name("count")
                        .short("c")
                        .help("Number of files to be downloaded"),
                ),
        )
        .subcommand(
            SubCommand::with_name("extract")
                .about("Extracts parts of files and stores them in other files")
                .version("1.0")
                .arg(
                    Arg::with_name("tag")
                        .short("d")
                        .help("Which tags will be extracted"),
                ),
        )
        .get_matches();

    if matches.is_present("download") {
        download_command();
    }

    if matches.is_present("extract") {}
}
```


Overlapping Code:
```
")
.about("Harvests odb files online and transforms them")
.subcommand(
SubCommand::with_name("download")
.about("Downloads pdb files from ncsb")
.ver::with_name("count")
.short("c")
.help("Number of files to be downloaded"),
),
)
.subcommand(
SubCommand::with_name("extract")
.about("Extracts parts of files and stores them in other files")
.version("1.0")
.arg(
Arg::with_name("tag")
.short("d")
.help("Which tags will be extracted"),
),
)
.get_matches();
if matches.is_present("download") {
download_command();
}
if matches.is_present("extract") {
```
<Overlap Ratio: 0.7586206896551724>

---

--- 308 --
Question ID: 544a63ec876f81d9453cedfde72d9d6d583a51e9_36
Original Code:
```
pub async fn get(
        operation_config: &crate::OperationConfig,
        subscription_id: &str,
        resource_group_name: &str,
        gallery_name: &str,
        select: Option<&str>,
    ) -> std::result::Result<models::Gallery, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Compute/galleries/{}",
            operation_config.base_path(),
            subscription_id,
            resource_group_name,
            gallery_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        if let Some(select) = select {
            url.query_pairs_mut().append_pair("$select", select);
        }
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::Gallery =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::CloudError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn get(
operation_config: &crate::OperationConfig,
subscription_id: &str,
resource_group_name: &str,
gallery_name: &str,
select: Option<&str>,
) -> std::result::Result<models::Gallery, get::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Compute/galleries/{}",
operation_config.base_path(),
subscription_id,
resource_group_name,
gallery_name
);
let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::GET);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(get::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
if let Some(select) = select {
url.query_pairs_mut().append_pair("$select", select);
}
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::Gallery =
serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::CloudError =
serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
Err(get::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 309 --
Question ID: 13686ca21e0d7b6115c0bd2d364a4da0a2c26e7e_22
Original Code:
```
pub fn get_rest_message_log_command(host: &str) -> Command {
    let mut command = get_jcli_command();
    command
        .arg("rest")
        .arg("v0")
        .arg("message")
        .arg("logs")
        .arg("--host")
        .arg(&host);
    command
}
```


Overlapping Code:
```
_message_log_command(host: &str) -> Command {
let mut command = get_jcli_command();
command
.arg("rest")
.arg("v0")
.arg("message")
.arg("logs")
.arg(
```
<Overlap Ratio: 0.7614213197969543>

---

--- 310 --
Question ID: 84118592c564c37e68a3625889149946e8e9d8ec_0
Original Code:
```
fn main() {
    // Parse args.
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <config file>", args[0]);
        std::process::exit(1);
    }
    let file_name = &args[1];

    // Load config.
    let file = File::open(file_name).expect("failed to open config");
    let reader = BufReader::new(file);
    let realm = config::Realm::from_reader(reader).unwrap();

    for svc in realm.services {
        println!("{:?}", svc);
    }
}
```


Overlapping Code:
```
rse args.
let args: Vec<String> = env::args().collect();
if args.len() < 2 {
eprintln!("Usage: {} <config file>", args[0]);
std::process::exit(1);
}
let file_name = &args[1];
// Load config.
let file = File::open(file_name).expect("failed to open config");
let reader = BufReader::new(file);
let realm = config::Realm::from_reader(reader).unwrap();
for svc in realm.services {
println!("{:?}", svc);

```
<Overlap Ratio: 0.9523809523809523>

---

--- 311 --
Question ID: 4f523374d95bdb6a4051fcc807ce4d02a5d3a681_1
Original Code:
```
fn hook_macro() {
        let dest = setup(unsafe { add_one_before::len() });

        let hook = unsafe { add_one_before::copy_to(dest) };

        for _ in 0..2 {
            unsafe { hook.hook(square) };

            assert!(unsafe { hook.target() } == square);
            assert_eq!(square(4), 16);
            assert_eq!(square(5), 25);

            unsafe { hook.toggle() };

            assert!(unsafe { hook.target() } == square);
            assert_eq!(square(4), 25);
            assert_eq!(square(5), 36);
            assert_eq!(unsafe { hook.trampoline() }(4), 16);
            assert_eq!(unsafe { hook.trampoline() }(5), 25);

            unsafe { hook.toggle() };

            assert!(unsafe { hook.target() } == square);
            assert_eq!(square(4), 16);
            assert_eq!(square(5), 25);

            unsafe { hook.unhook() };

            assert_eq!(square(4), 16);
            assert_eq!(square(5), 25);
        }
    }
```


Overlapping Code:
```
up(unsafe { add_one_before::len() });
let hook = unsafe { add_one_before::copy_to(dest) };
for _ in 0..2 {
unsafe { hook.hook(square) };
assert!(unsafe { hook.target() } == square);
assert_eq!(square(4), 16);
assert_eq!(square(5), 25);
unsafe { hook.toggle() };
assert!(unsafe { hook.target() } == square);
assert_eq!(square(4), 25);
assert_eq!(square(5), 36);
assert_eq!(unsafe { hook.trampoline() }(4), 16);
assert_eq!(unsafe { hook.trampoline() }(5), 25);
unsafe { hook.toggle() };
assert!(unsafe { hook.target() } == square);
assert_eq!(square(4), 16);
assert_eq!(square(5), 25);
unsafe { hook.unhook() };
assert_eq!(square(4), 16);
assert_eq!(square(5), 25);

```
<Overlap Ratio: 0.949928469241774>

---

--- 312 --
Question ID: 9d224e9aad3ff84318a5246cad46fd1bd91914d9_11
Original Code:
```
fn test_raw_annotation_aligned() {
    let dl = DisplayList::from(vec![DisplayLine::Raw(DisplayRawLine::Annotation {
        annotation: Annotation {
            annotation_type: DisplayAnnotationType::Error,
            id: Some("E0001".to_string()),
            label: vec![DisplayTextFragment {
                content: String::from("This is an error"),
                style: DisplayTextStyle::Regular,
            }],
        },
        source_aligned: true,
        continuation: false,
    })]);

    let dlf = DisplayListFormatter::new(false, false);

    assert_eq!(dlf.format(&dl), " = error[E0001]: This is an error");
}
```


Overlapping Code:
```
ion_aligned() {
let dl = DisplayList::from(vec![DisplayLine::Raw(DisplayRawLine::Annotation {
annotation: Annotation {
annotation_type: DisplayAnnotationType::Error,
id: Some("E0001".to_string()),
label: vec![DisplayTextFragment {
content: String::from("This is an error"),
style: DisplayTextStyle::Regular,
}],
},
source_aligned: true,
continuation: false,
})]);
let dlf = DisplayListFormatter::new(false, false);
assert_eq!(dlf.format(&dl), " = err
```
<Overlap Ratio: 0.8982035928143712>

---

--- 313 --
Question ID: 2e4e2eee00e584d2429df7e1c6ac746c0896b2d1_0
Original Code:
```
pub fn main() {
    let mut sys = actix::System::new("HttpServerClient");

    let mut clients = ClientMap::new();
    // Register a dummy client instance
    let client = Client::public(
        "LocalClient",                                     // Client id
        "http://localhost:8021/endpoint".parse().unwrap(), // Redirection url
        "default".parse().unwrap(),
    ); // Allowed client scope
    clients.register_client(client);

    // Authorization tokens are 16 byte random keys to a memory hash map.
    let authorizer = AuthMap::new(RandomGenerator::new(16));

    // Bearer tokens are also random generated but 256-bit tokens, since they live longer and this
    // example is somewhat paranoid.
    //
    // We could also use a `TokenSigner::ephemeral` here to create signed tokens which can be read
    // and parsed by anyone, but not maliciously created. However, they can not be revoked and thus
    // don't offer even longer lived refresh tokens.
    let issuer = TokenMap::new(RandomGenerator::new(16));

    let scopes = vec!["default".parse().unwrap()].into_boxed_slice();
    // Emulate static initialization for complex type
    let scopes: &'static _ = Box::leak(scopes);

    let state = State {
        registrar: AsActor(clients).start(),
        authorizer: AsActor(authorizer).start(),
        issuer: AsActor(issuer).start(),
        scopes,
    };

    // Create the main server instance
    server::new(move || {
        App::with_state(state.clone())
            .middleware(Logger::default())
            .resource("/authorize", |r| {
                r.get().a(|req: &HttpRequest<State>| {
                    let state = req.state().clone();
                    req.oauth2()
                        .and_then(|request| {
                            authorization(
                                state.registrar,
                                state.authorizer,
                                FnSolicitor(|_: &mut _, grant: &_| in_progress_response(grant)),
                                request,
                                OAuthResponse::default(),
                            )
                        })
                        .map(|response| response.get_or_consent_with(consent_form))
                        .map_err(OAuthFailure::from)
                });
                r.post().a(|req: &HttpRequest<State>| {
                    let state = req.state().clone();
                    let allowed = req.query_string().contains("allow");
                    req.oauth2()
                        .and_then(move |request| {
                            authorization(
                                state.registrar,
                                state.authorizer,
                                FnSolicitor(move |_: &mut _, grant: &_| {
                                    consent_decision(allowed, grant)
                                }),
                                request,
                                OAuthResponse::default(),
                            )
                        })
                        .map(OAuthResponse::unwrap)
                        .map_err(OAuthFailure::from)
                });
            })
            .resource("/token", |r| {
                r.post().a(|req: &HttpRequest<State>| {
                    let state = req.state().clone();
                    req.oauth2()
                        .and_then(|request| {
                            access_token(
                                state.registrar,
                                state.authorizer,
                                state.issuer,
                                request,
                                OAuthResponse::default(),
                            )
                        })
                        .map(OAuthResponse::unwrap)
                        .map_err(OAuthFailure::from)
                })
            })
            .resource("/refresh", |r| {
                r.post().a(|req: &HttpRequest<State>| {
                    let state = req.state().clone();
                    req.oauth2()
                        .and_then(|request| {
                            refresh(
                                state.registrar,
                                state.issuer,
                                request,
                                OAuthResponse::default(),
                            )
                        })
                        .map(OAuthResponse::unwrap)
                        .map_err(OAuthFailure::from)
                })
            })
            .resource("/", |r| {
                r.get().a(|req: &HttpRequest<State>| {
                    let state = req.state().clone();
                    req.oauth2()
                        .map_err(ResourceProtection::Error)
                        .and_then(|request| {
                            resource(
                                state.issuer,
                                state.scopes,
                                request,
                                OAuthResponse::default(),
                            )
                        })
                        // Any accepted grant is good enough.
                        .map(|_grant| {
                            HttpResponse::Ok()
                                .content_type("text/plain")
                                .body("HELLO BILL ")
                        })
                        .or_else(|result| match result {
                            ResourceProtection::Respond(response) => {
                                let mut response = response.unwrap();
                                response.set_body(DENY_TEXT);
                                Ok(response)
                            }
                            ResourceProtection::Error(err) => Err(OAuthFailure::from(err)),
                        })
                })
            })
    })
    .bind("0.0.0.0:8020")
    .expect("Failed to bind to socket")
    .start();

    server::new(support::dummy_client)
        .bind("0.0.0.0:8021")
        .expect("Failed to start dummy client")
        .start();

    // Start, then open in browser, don't care about this finishing.
    let _: Result<(), ()> = sys.block_on(future::lazy(|| {
        let _ = thread::spawn(support::open_in_browser);
        future::ok(())
    }));

    // Run the rest of the system.
    let _ = sys.run();
}
```


Overlapping Code:
```
ctix::System::new("HttpServerClient");
let mut clients = ClientMap::new();
// Register a dummy client instance
let client = Client::public(
"LocalClient", // Client id
"http://localhost:8021/endpoint".parse().unwrap(), // Redirection url
"default".parse().unwrap(),
); // Allowed client scope
clients.register_client(client);
// Authorization tokens are 16 byte random keys to a memory hash map.
let authorizer = AuthMap::new(RandomGenerator::new(16));
// Bearer tokens are also random generated but 256-bit tokens, since they live longer and this
// example is somewhat paranoid.
//
// We could also use a `TokenSigner::ephemeral` here to create signed tokens which can be read
// and parsed by anyone, but not maliciously created. However, they can not be revoked and thus
// don't offer even longer lived refresh tokens.
let issuer = TokenMap::new(RandomGenerator::new(16));
let scopes = vec!["default".parse().unwrap()].into_boxed_slice();
// Emulate static initialization for complex type
let scopes: &'static _ = Box::leak(scopes);
let state = State {
registrar: AsActor(clients).start(),
authorizer: AsActor(authorizer).start(),
issuer: AsActor(issuer).start(),
scopes,
};
// Create the main server instance
server::new(move || {
App::with_state(state.clone())
.middleware(Logger::default())
.resource("/authorize", |r| {
r.get().a(|req: &HttpRequest<State>| {
let state = req.state().clone();
req.oauth2()
.and_then(|request| {
authorization(
state.registrar,
state.authorizer,
FnSolicitor(|_: &mut _, grant: &_| in_progress_response(grant)),
request,
OAuthResponse::default(),
)
})
.map(|response| response.get_or_consent_with(consent_form))
.map_err(OAuthFailure::from)
});
r.post().a(|req: &HttpRequest<State>| {
let state = req.state().clone();
let allowed = req.query_string().contains("
```
<Overlap Ratio: 0.9787928221859706>

---

--- 314 --
Question ID: 0d385749b1bd8f6191152aaf95ada3052fa2fce4_0
Original Code:
```
fn approx_derivate<T: Copy>(cost: &impl Cost<T>, prediction: f64, truth: T) -> f64 {
        let epsilon = 0.00001;
        let f_plus_epsilon = cost.cost(prediction + epsilon, truth);
        let f_minus_epsilon = cost.cost(prediction - epsilon, truth);
        println!(
            "f_x_plus_epsilon: {}, f_x_minus_epsilon:: {}",
            f_plus_epsilon, f_minus_epsilon
        );
        (f_plus_epsilon - f_minus_epsilon) / (2.0 * epsilon)
    }
```


Overlapping Code:
```
ivate<T: Copy>(cost: &impl Cost<T>, prediction: f64, truth: T) -> f64 {
let epsilon = 0.00001;
let f_plus_epsilon = cost.cost(prediction + epsilon, truth);
let f_minus_epsilon = cost.cost(prediction - epsilon, truth);
println!(
"f_x_plus_epsilon: {}, f_x_minus_epsilon:: {}",
f_plus_epsilon, f_minus_epsilon
);
(f_plus_epsilon - f_minus_epsilon) / (2
```
<Overlap Ratio: 0.9259259259259259>

---

--- 315 --
Question ID: 991abc68fc1bdcdf03c433f0c42ff7a2a97cdd8e_0
Original Code:
```
pub fn analyze(repository: &git2::Repository) -> Result<BranchStatus, git2::Error> {
    let head = match repository.head() {
        Ok(h) => h,
        Err(_e) => {
            return Ok(BranchStatus {
                name: "detached".to_string(),
                local: None,
                upstream: None,
            })
        }
    };

    let branch_name = head.name().unwrap();

    let hr_name = if branch_name == "refs/heads/master" {
        ""
    } else {
        head.shorthand().unwrap()
    };

    let local = repository
        .find_branch("master", git2::BranchType::Local)
        .and_then(|master: git2::Branch| {
            repository.graph_ahead_behind(head.target().unwrap(), master.get().target().unwrap())
        })
        .ok();

    let upstream = repository
        .branch_upstream_name(branch_name)
        .ok()
        .and_then(|bname_buf: git2::Buf| bname_buf.as_str().map(|s| s.to_string()))
        .and_then(|bname| {
            repository
                .graph_ahead_behind(
                    head.target().unwrap(),
                    repository.refname_to_id(&bname).unwrap(),
                )
                .ok()
        });

    Ok(BranchStatus {
        name: hr_name.to_string(),
        local,
        upstream,
    })
}
```


Overlapping Code:
```
ub fn analyze(repository: &git2::Repository) -> Result<BranchStatus, git2::Error> {
let head = match repository.head() {
Ok(h) => h,
Err(_e) => {
return Ok(BranchStatus {
name: "detached".to_string(),
local: None,
upstream: None,
})
}
};
let branch_name = head.name().unwrap();
let hr_name = if branch_name == "refs/heads/master" {
""
} else {
head.shorthand().unwrap()
};
let local = repository
.find_branch("master", git2::BranchType::Local)
.and_then(|master: git2::Branch| {
repository.graph_ahead_behind(head.target().unwrap(), master.get().target().unwrap())
})
.ok();
let upstream = repository
.branch_upstream_name(branch_name)
.ok()
.and_then(|bname_buf: git2::Buf| bname_buf.as_str().map(|s| s.to_string()))
.and_then(|bname| {
repository
.graph_ahead_behind(
head.target().unwrap(),
repository.refname_to_id(&bname).unwrap(),
)
.ok()
});
Ok(BranchStatus {
name: hr_name.to_string(),
local
```
<Overlap Ratio: 0.9814612868047983>

---

--- 316 --
Question ID: 4274fa997a0abddad5fdba435f65220f5aaf14c4_0
Original Code:
```
fn f() -> isize {
    let mut x: isize;
    while 1 == 1 { x = 10; }
    return x; //~ ERROR use of possibly uninitialized variable: `x`
}
```


Overlapping Code:
```
fn f() -> isize {
let mut x: isize;
while 1 == 1 { x = 10; }
return x; //~ ERROR use of possibly uninitialized variable: `
```
<Overlap Ratio: 0.9682539682539683>

---

--- 317 --
Question ID: 688e72049589907b30b8055c4ce17ed68d95cad1_0
Original Code:
```
fn test_error_kind_wo_arg() {
    #[derive(Debug, Error)]
    enum E {
        #[error_kind("custom")]
        Custom,
    }

    assert_eq!(E::Custom.to_string().as_str(), "custom");
}
```


Overlapping Code:
```
arg() {
#[derive(Debug, Error)]
enum E {
#[error_kind("custom")]
Custom,
}
assert_eq!(E::Custom.to_s
```
<Overlap Ratio: 0.6578947368421053>

---

--- 318 --
Question ID: 90b6936df788397fc5d6af5f3593e71e3edc2b4a_230
Original Code:
```
pub async fn get(
        operation_config: &crate::OperationConfig,
        application_resource_name: &str,
    ) -> std::result::Result<models::ApplicationResourceDescription, get::Error> {
        let http_client = operation_config.http_client();
        let url_str = &format!(
            "{}/Resources/Applications/{}",
            operation_config.base_path(),
            application_resource_name
        );
        let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
        let mut req_builder = http::request::Builder::new();
        req_builder = req_builder.method(http::Method::GET);
        if let Some(token_credential) = operation_config.token_credential() {
            let token_response = token_credential
                .get_token(operation_config.token_credential_resource())
                .await
                .map_err(get::Error::GetTokenError)?;
            req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
        }
        url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
        let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
        req_builder = req_builder.uri(url.as_str());
        let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
        let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
        match rsp.status() {
            http::StatusCode::OK => {
                let rsp_body = rsp.body();
                let rsp_value: models::ApplicationResourceDescription =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Ok(rsp_value)
            }
            status_code => {
                let rsp_body = rsp.body();
                let rsp_value: models::FabricError =
                    serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
                Err(get::Error::DefaultResponse {
                    status_code,
                    value: rsp_value,
                })
            }
        }
    }
```


Overlapping Code:
```
pub async fn get(
operation_config: &crate::OperationConfig,
application_resource_name: &str,
) -> std::result::Result<models::ApplicationResourceDescription, get::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/Resources/Applications/{}",
operation_config.base_path(),
application_resource_name
);
let mut url = url::Url::parse(url_str).map_err(get::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::GET);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(get::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
let req_body = bytes::Bytes::from_static(azure_core::EMPTY_BODY);
req_builder = req_builder.uri(url.as_str());
let req = req_builder.body(req_body).map_err(get::Error::BuildRequestError)?;
let rsp = http_client.execute_request(req).await.map_err(get::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::ApplicationResourceDescription =
serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
let rsp_value: models::FabricError =
serde_json::from_slice(rsp_body).map_err(|source| get::Error::DeserializeError(source, rsp_body.clone()))?;
Err(get::Error::DefaultResponse {
status_code,
value: rsp_value,
})
}
}
}
```
<Overlap Ratio: 1.0>

---

--- 319 --
Question ID: e19ee678d407c34b2970d249b036274abf46995f_3
Original Code:
```
fn input_files_content_to_digest(context: Context, args: Vec<Value>) -> NodeFuture<Value> {
  let file_values = externs::project_multi(&args[0], "dependencies");
  let digests: Vec<_> = file_values
    .iter()
    .map(|file| {
      let filename = externs::project_str(&file, "path");
      let path: PathBuf = filename.into();
      let bytes = bytes::Bytes::from(externs::project_bytes(&file, "content"));
      let is_executable = externs::project_bool(&file, "is_executable");

      let store = context.core.store();
      async move {
        let digest = store.store_file_bytes(bytes, true).await?;
        let snapshot = store
          .snapshot_of_one_file(path, digest, is_executable)
          .await?;
        let res: Result<_, String> = Ok(snapshot.digest);
        res
      }
    })
    .collect();

  Box::pin(async move {
    let digests = future03::try_join_all(digests).await?;
    let digest = store::Snapshot::merge_directories(context.core.store(), digests).await?;
    let res: Result<_, String> = Ok(Snapshot::store_directory(&context.core, &digest));
    res
  })
  .compat()
  .map_err(|err: String| throw(&err))
  .to_boxed()
}
```


Overlapping Code:
```
files_content_to_digest(context: Context, args: Vec<Value>) -> NodeFuture<Value> {
let file_values = externs::project_multi(&args[0], "dependencies");
let digests: Vec<_> = file_values
.iter()
.map(|file| {
let filename = externs::project_str(&file, "path");
let path: PathBuf = filename.into();
let bytes = bytes::Bytes::from(externs::project_bytes(&file, "content"));
let is_executable = externs::project_bool(&file, "is_executable");
let store = context.core.store();
async move {
let digest = store.store_file_bytes(bytes, true).await?;
let snapshot = store
.snapshot_of_one_file(path, digest, is_executable)
.await?;
let res: Result<_, String> = Ok(snapshot.digest);
res
}
})
.collect();
Box::pin(async move {
let digests = future03::try_join_all(digests).await?;
let digest = store::Snapshot::merge_directories(context.core.store(), digests).await?;
let res: Result<_, String> = Ok(Snapshot::store_directory(&context.core, &digest));
res
})
.compat()
.map_err(|err: String| throw(&err))
.to_box
```
<Overlap Ratio: 0.9852216748768473>

---

--- 320 --
Question ID: 709fec4c126c877efca901b594fa18a4c24bcd42_1
Original Code:
```
fn main() {
    let input_data: Vec<u32> = vec![0, 20, 7, 16, 1, 18, 15];
    let last_spoken_word = play_game(&input_data, 30000000);
    println!("Last spoken word: {}", last_spoken_word);
}
```


Overlapping Code:
```
n main() {
let input_data: Vec<u32> = vec![0, 20, 7, 16, 1, 18, 15];
let last_spoken_word = play_game(&input_data, 30000000);
println!("Last spoken wo
```
<Overlap Ratio: 0.8333333333333334>

---

--- 321 --
Question ID: 2f410f3d3514bd4ff3b9ffbc7eaee1b9d1938f83_0
Original Code:
```
fn main() -> Result<(), String> {
    env_logger::init();

    let args: Vec<String> = env::args().collect();
    match if args.len() > 1 { Some(&args[1]) } else { None } {
        Some(filename) => load_file(Path::new(filename)),
        None => repl(),
    }?;

    Ok(())
}
```


Overlapping Code:
```
n main() -> Result<(), String> {
env_logger::init();
let args: Vec<String> = env::args().collect();
match if args.len() > 1 { Some(&args[1]) } else { None } {
Some(filename) => load_file(Path::new(fil
```
<Overlap Ratio: 0.8403361344537815>

---

--- 322 --
Question ID: c4ad96a4e0b62e626c3149faf453d8b1b59465e2_15
Original Code:
```
fn test_parse_select1() {
    let binary_operators = BinaryOperators::new();
    let unary_operators = UnaryOperators::new();

    let mut parser = Parser::from_plain_tokens(
        &binary_operators,
        &unary_operators,
        vec![
            Token::Keyword(Keyword::Select),
            Token::Identifier("x".to_string()),
            Token::Keyword(Keyword::From),
            Token::Identifier("test".to_string()),
            Token::End
        ]
    );

    let tree = parser.parse().unwrap();

    assert_eq!(
        ParserOperationTree::Select {
            location: Default::default(),
            projections: vec![(None, ParserExpressionTreeData::ColumnAccess("x".to_owned()).with_location(Default::default()))],
            from: ("test".to_string(), None),
            filter: None,
            group_by: None,
            having: None,
            join: None
        },
        tree
    );
}
```


Overlapping Code:
```
() {
let binary_operators = BinaryOperators::new();
let unary_operators = UnaryOperators::new();
let mut parser = Parser::from_plain_tokens(
&binary_operators,
&unary_operators,
vec![
Token::Keyword(Keyword::Select),
Token::Identifier("x".to_string()),
Token::Keyword(Keyword::From),
Token::Identifier("test".to_string()),
Token::End
]
);
let tree = parser.parse().unwrap();
assert_eq!(
ParserOperationTree::Select {
location: Default::default(),
projections: vec![(None, ParserExpressionTreeData::ColumnAccess("x".to_owned()).with_location(Default::default()))],
from: ("test".to_string(), None),
filter: None,
group_by: None,
having: None,
join: None
},
tree
```
<Overlap Ratio: 0.9620991253644315>

---

--- 323 --
Question ID: c2a9e41d38d20412f29645384be77fbf4fc5263f_4
Original Code:
```
async fn test_modify_policies_api() {
        let m = DefaultModel::from_file("examples/rbac_model.conf")
            .await
            .unwrap();

        let adapter = FileAdapter::new("examples/rbac_policy.csv");
        let mut e = Enforcer::new(m, adapter).await.unwrap();

        assert_eq!(
            vec![
                vec!["alice", "data1", "read"],
                vec!["bob", "data2", "write"],
                vec!["data2_admin", "data2", "read"],
                vec!["data2_admin", "data2", "write"],
            ],
            sort_unstable(e.get_policy())
        );

        e.remove_policies(vec![
            vec!["alice", "data1", "read"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec!["bob", "data2", "write"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
        ])
        .await
        .unwrap();
        e.remove_policies(vec![vec!["alice", "data1", "read"]
            .iter()
            .map(|s| s.to_string())
            .collect()])
            .await
            .unwrap();
        assert_eq!(
            false,
            e.has_policy(
                vec!["alice", "data1", "read"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            false,
            e.has_policy(
                vec!["bob", "data2", "write"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            true,
            e.has_policy(
                vec!["data2_admin", "data2", "read"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            true,
            e.has_policy(
                vec!["data2_admin", "data2", "write"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        e.add_policies(vec![vec!["eve", "data3", "read"]
            .iter()
            .map(|s| s.to_string())
            .collect()])
            .await
            .unwrap();
        e.add_policies(vec![
            vec!["eve", "data3", "read"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec!["eve", "data3", "read"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
        ])
        .await
        .unwrap();
        assert_eq!(
            false,
            e.has_policy(
                vec!["alice", "data1", "read"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            false,
            e.has_policy(
                vec!["bob", "data2", "write"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            true,
            e.has_policy(
                vec!["eve", "data3", "read"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            true,
            e.has_policy(
                vec!["data2_admin", "data2", "read"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );
        assert_eq!(
            true,
            e.has_policy(
                vec!["data2_admin", "data2", "write"]
                    .iter()
                    .map(|s| s.to_string())
                    .collect()
            )
        );

        let named_policy = vec!["eve".to_string(), "data3".to_string(), "read".to_string()];
        e.remove_named_policies("p", vec![named_policy.clone()])
            .await
            .unwrap();
        e.add_named_policies("p", vec![named_policy.clone()])
            .await
            .unwrap();

        assert_eq!(
            vec![
                vec!["data2_admin", "data2", "read"],
                vec!["data2_admin", "data2", "write"],
                vec!["eve", "data3", "read"],
            ],
            sort_unstable(e.get_policy())
        );

        e.remove_filtered_policy(1, vec!["data2"].iter().map(|s| s.to_string()).collect())
            .await
            .unwrap();
        assert_eq!(vec![vec!["eve", "data3", "read"],], e.get_policy());
    }
```


Overlapping Code:
```
s_api() {
let m = DefaultModel::from_file("examples/rbac_model.conf")
.await
.unwrap();
let adapter = FileAdapter::new("examples/rbac_policy.csv");
let mut e = Enforcer::new(m, adapter).await.unwrap();
assert_eq!(
vec![
vec!["alice", "data1", "read"],
vec!["bob", "data2", "write"],
vec!["data2_admin", "data2", "read"],
vec!["data2_admin", "data2", "write"],
],
sort_unstable(e.get_policy())
);
e.remove_policies(vec![
vec!["alice", "data1", "read"]
.iter()
.map(|s| s.to_string())
.collect(),
vec!["bob", "data2", "write"]
.iter()
.map(|s| s.to_string())
.collect(),
])
.await
.unwrap();
e.remove_policies(vec![vec!["alice", "data1", "read"]
.iter()
.map(|s| s.to_string())
.collect()])
.await
.unwrap();
assert_eq!(
false,
e.has_policy(
vec!["alice", "data1", "read"]
.iter()
.map(|s| s.to_string())
.collect()
)
);
assert_eq!(
false,
e.has_policy(
vec!["bob", "data2", "write"]
.iter()
.map(|s| s.to_string())
.collect()
)
);
assert_eq!(
true,
e.has_policy(
vec!["data2_admin", "data2", "read"]
.iter()
.map(|s| s.to_string())
.collect()
)
);
assert_eq!(
true,
e.has_policy(
vec!["data2_admin", "data2", "write"]
.iter()
.map(|s| s.to_string())
.collect()
)
);
e.add_policies(vec![vec!["eve", "data3", "read"]
.iter()
.map(|s| s.to_string())
.collect()])
.await
.unwrap();
e.add_policies(vec![
vec!["eve", "data3", "read"]
.iter()
.map(|s| s.to_string())
.collect(),
vec!["eve", "data3", "read"]

```
<Overlap Ratio: 0.975609756097561>

---

--- 324 --
Question ID: 6ed4e282800b650c55fea495709831deaa8f303a_1
Original Code:
```
fn test_array_out_of_range() {
  let _array = val!(["string", 45]);
  assert_eq!(_array[3], Val::Undef);
  assert_eq!(_array[0], Val::Str("string".into()));

}
```


Overlapping Code:
```
e() {
let _array = val!(["string", 45]);
assert_eq!(_array[3], Val::Undef);
assert_eq!(_array[0], Va
```
<Overlap Ratio: 0.6578947368421053>

---

--- 325 --
Question ID: 35e67874667ba915a65f0521157201b4621d6f1c_0
Original Code:
```
fn ordered() {
            let options = EncOptionSet::new(vec![
                EncOption::HideMeta,
                EncOption::Fast,
                EncOption::PadSize,
            ]);
            let mut options_iter = options.iter();
            assert_eq!(options_iter.next(), Some(&EncOption::Fast));
            assert_eq!(options_iter.next(), Some(&EncOption::HideMeta));
            assert_eq!(options_iter.next(), Some(&EncOption::PadSize));
        }
```


Overlapping Code:
```
s = EncOptionSet::new(vec![
EncOption::HideMeta,
EncOption::Fast,
EncOption::PadSize,
]);
let mut options_iter = options.iter();
assert_eq!(options_iter.next(), Some(&EncOption::Fast));
assert_eq!(options_iter.next(), Some(&EncOption::HideMeta));
assert_eq!(options_iter.next(), Some(&EncOption::PadS
```
<Overlap Ratio: 0.9009009009009009>

---

--- 326 --
Question ID: d37b0fe54b3361e47bfda2bcfdda3c4955aec490_0
Original Code:
```
pub(crate) fn keypair_signing_ok<A: AsymmetricKey + SigningAlgorithm>(
        input: (KeyPair<A>, Vec<u8>),
    ) -> bool
    where
        <A as AsymmetricKey>::PubAlg: VerificationAlgorithm,
    {
        let (sk, pk) = input.0.into_keys();
        let data = input.1;

        let signature = sk.sign(&data);
        signature.verify(&pk, &data) == Verification::Success
    }
```


Overlapping Code:
```
fn keypair_signing_ok<A: AsymmetricKey + SigningAlgorithm>(
input: (KeyPair<A>, Vec<u8>),
) -> bool
where
<A as AsymmetricKey>::PubAlg: VerificationAlgorithm,
{
let (sk, pk) = input.0.into_keys();
let data = input.1;
let signature = sk.sign(&data);
signature.verify(&pk, &data) == Verification::Succe
```
<Overlap Ratio: 0.9523809523809523>

---

--- 327 --
Question ID: 3bba89cc0000c2071e29b960b0c9464964d35ebc_0
Original Code:
```
fn info_with_compiled_source() {
  let _g = util::http_server();
  let module_path = "http://127.0.0.1:4545/cli/tests/048_media_types_jsx.ts";
  let t = TempDir::new().expect("tempdir fail");

  let mut deno = util::deno_cmd()
    .env("DENO_DIR", t.path())
    .current_dir(util::root_path())
    .arg("cache")
    .arg(&module_path)
    .spawn()
    .expect("failed to spawn script");
  let status = deno.wait().expect("failed to wait for the child process");
  assert!(status.success());

  let output = util::deno_cmd()
    .env("DENO_DIR", t.path())
    .env("NO_COLOR", "1")
    .current_dir(util::root_path())
    .arg("info")
    .arg(&module_path)
    .output()
    .expect("failed to spawn script");

  let str_output = std::str::from_utf8(&output.stdout).unwrap().trim();
  eprintln!("{}", str_output);
  // check the output of the test.ts program.
  assert!(str_output.contains("emit: "));
  assert_eq!(output.stderr, b"");
}
```


Overlapping Code:
```
_with_compiled_source() {
let _g = util::http_server();
let module_path = "http://127.0.0.1:4545/cli/tests/048_media_types_jsx.ts";
let t = TempDir::new().expect("tempdir fail");
let mut deno = util::deno_cmd()
.env("DENO_DIR", t.path())
.current_dir(util::root_path())
.arg("cache")
.arg(&module_path)
.spawn()
.expect("failed to spawn script");
let status = deno.wait().expect("failed to wait for the child process");
assert!(status.success());
let output = util::deno_cmd()
.env("DENO_DIR", t.path())
.env("NO_COLOR", "1")
.current_dir(util::root_path())
.arg("info")
.arg(&module_path)
.output()
.expect("failed to spawn script");
let str_output = std::str::from_utf8(&output.stdout).unwrap().trim();
eprintln!("{}", str_output);
// check the output of the test.ts program.
assert!(str_output.contains("emit: "));
assert_eq!(output.stderr, b"");

```
<Overlap Ratio: 0.9906759906759907>

---

--- 328 --
Question ID: 6b1a2a90288e389127e6ba06a661e5314aca06b8_0
Original Code:
```
fn allocate_for_10_sec(c: &mut Criterion<BytesAllocated>) {
    let mut group = c.benchmark_group("allocate multi thread for 10 sec");
    group.sample_size(10);
    group.warm_up_time(Duration::from_secs(1));
    for threads in 0..3 {
        group.throughput(Throughput::Elements(1 << threads));
        group.bench_with_input(
            BenchmarkId::new("lrmalloc-rs", 1 << threads),
            &(1 << threads as usize),
            |b, &size| {
                b.iter_custom(|_iters| {
                    let mut vec = Vec::with_capacity(size);
                    let output = BytesAllocated;
                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));
                    for _ in 0..size {
                        let b = bytes_allocated.clone();
                        vec.push(thread::spawn(move || {
                            let mut temp = Vec::with_capacity(10000);

                            let start = Instant::now();
                            while start.elapsed().as_secs() < 10 {
                                temp.push(AutoPtr::new(0usize));
                                let mut guard = b.lock().unwrap();
                                *guard += 8;
                            }
                        }));
                    }
                    for join in vec {
                        join.join().unwrap();
                    }
                    let ret = (*bytes_allocated.lock().unwrap()).clone();
                    output.end(ret)
                });
            },
        );
    }
    for threads in 0..3 {
        group.throughput(Throughput::Elements(1 << threads));
        group.bench_with_input(
            BenchmarkId::new("native", 1 << threads),
            &(1 << threads as usize),
            |b, &size| {
                let ptrs = Arc::new(Mutex::new(Vec::new()));
                b.iter_custom(|_iters| {
                    let mut vec = Vec::with_capacity(size);
                    let output = BytesAllocated;
                    let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));
                    for _ in 0..size {
                        let clone = ptrs.clone();
                        let b = bytes_allocated.clone();
                        vec.push(thread::spawn(move || {
                            let mut temp = Vec::with_capacity(10000);

                            let start = Instant::now();
                            while start.elapsed().as_secs() < 10 {
                                temp.push(Box::new(0usize));
                                let mut guard = b.lock().unwrap();
                                *guard += 8;
                            }
                            clone.lock().unwrap().extend(temp)
                        }));
                    }
                    for join in vec {
                        join.join().unwrap();
                    }
                    let ret = (*bytes_allocated.lock().unwrap()).clone();
                    output.end(ret)
                });
            },
        );
    }
}
```


Overlapping Code:
```
or_10_sec(c: &mut Criterion<BytesAllocated>) {
let mut group = c.benchmark_group("allocate multi thread for 10 sec");
group.sample_size(10);
group.warm_up_time(Duration::from_secs(1));
for threads in 0..3 {
group.throughput(Throughput::Elements(1 << threads));
group.bench_with_input(
BenchmarkId::new("lrmalloc-rs", 1 << threads),
&(1 << threads as usize),
|b, &size| {
b.iter_custom(|_iters| {
let mut vec = Vec::with_capacity(size);
let output = BytesAllocated;
let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));
for _ in 0..size {
let b = bytes_allocated.clone();
vec.push(thread::spawn(move || {
let mut temp = Vec::with_capacity(10000);
let start = Instant::now();
while start.elapsed().as_secs() < 10 {
temp.push(AutoPtr::new(0usize));
let mut guard = b.lock().unwrap();
*guard += 8;
}
}));
}
for join in vec {
join.join().unwrap();
}
let ret = (*bytes_allocated.lock().unwrap()).clone();
output.end(ret)
});
},
);
}
for threads in 0..3 {
group.throughput(Throughput::Elements(1 << threads));
group.bench_with_input(
BenchmarkId::new("native", 1 << threads),
&(1 << threads as usize),
|b, &size| {
let ptrs = Arc::new(Mutex::new(Vec::new()));
b.iter_custom(|_iters| {
let mut vec = Vec::with_capacity(size);
let output = BytesAllocated;
let bytes_allocated = Arc::new(Mutex::new(BytesAllocated::start(&output)));
for _ in 0..size {
let clone = ptrs.clone();
let b = bytes_allocated.clone();
vec.push(thread::spawn(move || {
let mut temp = Vec::with_capacity(10000);
let start = Instant::now();
while start.elapsed().as_s
```
<Overlap Ratio: 0.9916932907348243>

---

--- 329 --
Question ID: b7e1e239e00b119af94973d6f3b870dd3997375c_38
Original Code:
```
fn opcode_ld_f_vx() {
        let mut chip = Chip::default();

        chip.registers[2] = 6;
        chip.ld_f_vx(2);

        assert_eq!(chip.i, (chip.registers[2] * CHARACTER_SIZE as u8) as u16);
    }
```


Overlapping Code:
```
 {
let mut chip = Chip::default();
chip.registers[2] = 6;
chip.ld_f_vx(2);
assert_eq!(chip.i, (chip.registers[2] * C
```
<Overlap Ratio: 0.6987951807228916>

---

--- 330 --
Question ID: 92c73223280ce2b740f9f98dfa60a10b1d2c21dd_2
Original Code:
```
pub fn write_test_file(len: usize) -> (TempDir, PathBuf, Vec<u8>) {
    use ::std::fs;
    let dir = TempDir::new().unwrap();
    let pth = NamedTempFile::new_in(dir.path()).unwrap().path().to_owned();
    let big = generate_test_file_content_for_test(len);
    fs::write(&pth, &big).unwrap();
    (dir, pth, big)
}
```


Overlapping Code:
```
empDir, PathBuf, Vec<u8>) {
use ::std::fs;
let dir = TempDir::new().unwrap();
let pth = NamedTempFile::new_in(dir.path()).unwrap().path().to_owned();
let big = generate_test_file_content_for_test(len);
fs::write(&pth, &big).unwrap();
(dir, pth, big)

```
<Overlap Ratio: 0.8591065292096219>

---

--- 331 --
Question ID: 7392e796f420ee773a24d88ffc85f80979640067_0
Original Code:
```
fn discover_plugins<P: AsRef<Path>>(base_dir: P) -> Result<Vec<Plugin>, Error> {
    use std::fs;
    use std::io::Read;

    #[derive(Deserialize)]
    struct Manifest {
        triggers: Vec<CallbackTrigger>,
        enabled: bool,
    }

    let base_dir = base_dir.as_ref();
    debug!("discovering plugins in {}", base_dir.display());
    if !base_dir.exists() {
        return Err(format_err!(
            "plugins directory {} not found",
            base_dir.display()
        ));
    }

    let dir = fs::read_dir(base_dir)
        .map_err(|e| format_err!("failed to open plugins directory: {}", e))?;

    trace!("discovering toml manifest files");
    let toml_file_paths = dir
        .flat_map(|r| match r {
            Ok(entry) => Some(entry),
            Err(e) => {
                warn!(
                    "failed to read item in the directory {}: {}",
                    base_dir.display(),
                    e
                );
                None
            }
        })
        .map(|d| d.path().to_path_buf())
        .filter(|path| path.extension().map(|e| e == "toml").unwrap_or(false));

    let mut plugins = Vec::new();
    for toml_file_path in toml_file_paths {
        let toml = toml_file_path
            .to_str()
            .expect("non-unicode paths are not supported");
        let plugin = toml.trim_right_matches(".toml");

        debug!("probing manifest({}) and plugin({})", toml, plugin);

        // This block may throw errors, but we don't want to trow from the function
        // in-place lambda will catch 'em all!
        let result = || -> Result<Manifest, Error> {
            let mut toml_file = fs::File::open(toml)?;
            let mut contents = String::new();
            toml_file.read_to_string(&mut contents)?;
            Ok(toml::from_str(&contents)?)
        }();

        let manifest = match result {
            Ok(manifest) => manifest,
            Err(e) => {
                warn!("failed to process plugin manifest at {}: {}", toml, e);
                continue;
            }
        };

        // Check that plugin file exists
        if !Path::new(plugin).exists() {
            warn!(
                "plugin manifest found at {}, but there's no plugin file at {}",
                toml, plugin
            );
            continue;
        }

        // Skip loading disabled plugins
        if !manifest.enabled {
            warn!("plugin {} is disabled, skipping", plugin);
            continue;
        }

        for trigger in manifest.triggers {
            plugins.push(Plugin {
                trigger,
                path: PathBuf::from(plugin),
            })
        }
    }

    Ok(plugins)
}
```


Overlapping Code:
```
scover_plugins<P: AsRef<Path>>(base_dir: P) -> Result<Vec<Plugin>, Error> {
use std::fs;
use std::io::Read;
#[derive(Deserialize)]
struct Manifest {
triggers: Vec<CallbackTrigger>,
enabled: bool,
}
let base_dir = base_dir.as_ref();
debug!("discovering plugins in {}", base_dir.display());
if !base_dir.exists() {
return Err(format_err!(
"plugins directory {} not found",
base_dir.display()
));
}
let dir = fs::read_dir(base_dir)
.map_err(|e| format_err!("failed to open plugins directory: {}", e))?;
trace!("discovering toml manifest files");
let toml_file_paths = dir
.flat_map(|r| match r {
Ok(entry) => Some(entry),
Err(e) => {
warn!(
"failed to read item in the directory {}: {}",
base_dir.display(),
e
);
None
}
})
.map(|d| d.path().to_path_buf())
.filter(|path| path.extension().map(|e| e == "toml").unwrap_or(false));
let mut plugins = Vec::new();
for toml_file_path in toml_file_paths {
let toml = toml_file_path
.to_str()
.expect("non-unicode paths are not supported");
let plugin = toml.trim_right_matches(".toml");
debug!("probing manifest({}) and plugin({})", toml, plugin);
// This block may throw errors, but we don't want to trow from the function
// in-place lambda will catch 'em all!
let result = || -> Result<Manifest, Error> {
let mut toml_file = fs::File::open(toml)?;
let mut contents = String::new();
toml_file.read_to_string(&mut contents)?;
Ok(toml::from_str(&contents)?)
}();
let manifest = match result {
Ok(manifest) => manifest,
Err(e) => {
warn!("failed to process plugin manifest at {}: {}", toml, e);
continue;
}
};
// Check that plugin file exists
if !Path::new(plugin).exists() {
warn!(
"plugin manifest found at {}, but there's no plugin file at {}",
toml, plugin
);
continue;
}
// Skip loading disabled plugins
if !manifest.enabled {
warn!("plugin {} is disabled, 
```
<Overlap Ratio: 0.9803921568627451>

---

--- 332 --
Question ID: 5bcfae6b0fb9e21d768d8c08bcfd046d8f5475b3_2
Original Code:
```
fn regexp_builder_with_escaped_non_ascii_chars(test_cases: Vec<&str>, expected_output: &str) {
        let regexp = RegExpBuilder::from(&test_cases)
            .with_escaped_non_ascii_chars(false)
            .build();
        test_if_regexp_is_correct(regexp, expected_output);
        test_if_regexp_matches_test_cases(expected_output, test_cases);
    }
```


Overlapping Code:
```
caped_non_ascii_chars(test_cases: Vec<&str>, expected_output: &str) {
let regexp = RegExpBuilder::from(&test_cases)
.with_escaped_non_ascii_chars(false)
.build();
test_if_regexp_is_correct(regexp, expected_output);
test_if_regexp_matches_test_cases(expected_output, test_cases);
}
```
<Overlap Ratio: 0.9180327868852459>

---

--- 333 --
Question ID: 319d241ba710f1536ec13495d411ac51c407e1ae_0
Original Code:
```
fn main() -> Result<(), ParseIntError> {
    let (stats_tx, stats_rx) = unbounded::<stats::Bucket>();
    let cmd = args::Cmd::new();

    let mut client = udp::Client::new(stats_tx.clone());
    let mut server = udp::Server::new(stats_tx.clone());
    let mut stats = stats::Stats::new(stats_rx);

    let mode = cmd.init(&mut client, &mut server, &mut stats)?;

    match mode {
        0 => {
            println!("cput server mode enabled");
            thread::spawn(move || server.start());
        }
        1 => {
            println!("cput client mode enabled");
            thread::spawn(move || client.start());
        }
        _ => {
            println!("cput loopback mode enabled");
            thread::spawn(move || server.start());
            thread::spawn(move || client.start());
        }
    };

    stats.start().unwrap();

    Ok(())
}
```


Overlapping Code:
```
{
let (stats_tx, stats_rx) = unbounded::<stats::Bucket>();
let cmd = args::Cmd::new();
let mut client = udp::Client::new(stats_tx.clone());
let mut server = udp::Server::new(stats_tx.clone());
let mut stats = stats::Stats::new(stats_rx);
let mode = cmd.init(&mut client, &mut server, &mut stats)?;
match mode {
0 => {
println!("cput server mode enabled");
thread::spawn(move || server.start());
}
1 => {
println!("cput client mode enabled");
thread::spawn(move || client.start());
}
_ => {
println!("cput loopback mode enabled");
thread::spawn(move || server.start());
thread::spawn(move || client.st
```
<Overlap Ratio: 0.8771929824561403>

---

--- 334 --
Question ID: 94b5fabe04d18a5f810706d7eb2d68f8ab5d8b8c_0
Original Code:
```
pub extern "C" fn _start(boot_info: &'static BootInfo) -> ! {
    arch_init(boot_info);

    println!(
        "{} {} on {} {}",
        version_info::OPERATING_SYSTEM_NAME,
        version_info::VERSION_STRING,
        version_info::PROCESSOR_NAME,
        version_info::MACHINE_NAME
    );
    println!("The system is coming up.");
    kalloc::init();
    timer::register_timer(timer::TICKS_PER_SECOND / 2, false, Box::new(|| {
        print!(".")
    })).unwrap();
    timer::register_timer(timer::TICKS_PER_SECOND * 4, true, Box::new(|| {
        print!("!")
    })).unwrap();

    loop {
        spin_loop_hint();
    }
}
```


Overlapping Code:
```
pub extern "C" fn _start(boot_info: &'static BootInfo) -> ! {
arch_init(boot_info);
println!(
"{} {} on {} {}",
version_info::OPERATING_SYSTEM_NAME,
version_info::VERSION_STRING,
version_info::PROCESSOR_NAME,
version_info::MACHINE_NAME
);
println!("The system is coming up.");
kalloc::init();
timer::register_timer(timer::TICKS_PER_SECOND / 2, false, Box::new(|| {
print!(".")
})).unwrap();
timer::register_timer(timer::TICKS_PER_SECOND * 4, true, Box::new(|| {
print!("!")
})).unwrap();
loop {
```
<Overlap Ratio: 0.9573643410852714>

---

--- 335 --
Question ID: deedddd296c95549d8c8d5421f9b150db4820830_0
Original Code:
```
fn get_canvas_and_display() -> (Canvas<'static>, Display) {
        let canvas = Canvas::new(100, 100);
        assert!(canvas.is_ok(), "{:?}", canvas.err());
        let canvas_ok = canvas.unwrap();
        let display = Display::new(InitOptions{canvas: Some(&canvas_ok),
                                               ..InitOptions::default()});
        assert!(display.is_ok(), "{:?}", display.err());
        (canvas_ok, display.unwrap())
    }
```


Overlapping Code:
```
 Display) {
let canvas = Canvas::new(100, 100);
assert!(canvas.is_ok(), "{:?}", canvas.err());
let canvas_ok = canvas.unwrap();
let display = Display::new(InitOptions{canvas: Some(&canvas_ok),
..InitOptions::default()});
assert!(display.is_ok(), "{:?}", display.err());
(canvas_ok, display.unwrap())

```
<Overlap Ratio: 0.8595988538681948>

---

--- 336 --
Question ID: 754e17eea7b90f3609e13e49901cf843b4a96d0c_7
Original Code:
```
fn parse_masked_ipv6_strings() {
    const FE80_ONE_10: &str = "fe80::1/10";
    const LOCALHOST_128: &str = "::/128";
    const FFFF_AAAA_16: &str = "ffff::aaaa/16";

    let net: MaskedIpv6 = FE80_ONE_10.parse().unwrap();
    assert_eq!(format!("{}", net), FE80_ONE_10);
    assert_eq!(net.mask.len(), 10);
    let net: MaskedIpv6 = LOCALHOST_128.parse().unwrap();
    assert_eq!(format!("{}", net), LOCALHOST_128);
    assert_eq!(net.mask.len(), 128);
    let net: MaskedIpv6 = FFFF_AAAA_16.parse().unwrap();
    assert_eq!(format!("{}", net), FFFF_AAAA_16);
    assert_eq!(net.mask.len(), 16);
}
```


Overlapping Code:
```
ings() {
const FE80_ONE_10: &str = "fe80::1/10";
const LOCALHOST_128: &str = "::/128";
const FFFF_AAAA_16: &str = "ffff::aaaa/16";
let net: MaskedIpv6 = FE80_ONE_10.parse().unwrap();
assert_eq!(format!("{}", net), FE80_ONE_10);
assert_eq!(net.mask.len(), 10);
let net: MaskedIpv6 = LOCALHOST_128.parse().unwrap();
assert_eq!(format!("{}", net), LOCALHOST_128);
assert_eq!(net.mask.len(), 128);
let net: MaskedIpv6 = FFFF_AAAA_16.parse().unwrap();
assert_eq!(format!("{}", net), FFFF_AAAA_16);
assert_
```
<Overlap Ratio: 0.9090909090909091>

---

--- 337 --
Question ID: cf88d730f7b68a3d650705d734139cd2ec730ff8_2
Original Code:
```
fn kill_input() {
    let input = Path::new(&env::current_dir().unwrap()).join("INPUT");
    if input.is_dir() {
        fs::remove_dir_all(&input).unwrap();
    }
    assert_eq!(input.is_dir(), false);
}
```


Overlapping Code:
```
nv::current_dir().unwrap()).join("INPUT");
if input.is_dir() {
fs::remove_dir_all(&input).unwrap();

```
<Overlap Ratio: 0.5555555555555556>

---

--- 338 --
Question ID: 1f3f96a32f4d4b1c131dc03cdf777618848d0f0c_1
Original Code:
```
fn process_child_output<R>(
    directive: Directive,
    context: &OutputContext,
    read: R,
    tx_write: AsyncSender<WriteChannel>,
) -> Result<()>
where
    R: io::Read + Send,
{
    enter!(
        span,
        always_span!("child.stream", kind = %directive.span_display())
    );
    trace!("Processing child output stream");

    let mut lines = 0u64;
    let mut bytes = 0u64;

    let buffer = io::BufReader::new(read);
    let mut sink = RecordInterface::new_sink(tx_write.sink_map_err(CrateError::from));

    buffer
        .for_byte_line(|line| {
            let utf8 = String::from_utf8_lossy(line);

            block_on(sink.send(data(context, directive, &utf8).done_unchecked()))
                //Ugly workaround for closure's io::Error requirement,
                //Round trips from our local error into io::Error and back
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))
                .map(|o| {
                    lines += 1;
                    bytes += line.len() as u64;
                    o
                })
                .and(Ok(true))
        })
        .map(|_| {
            if bytes > 0 {
                debug!(lines, bytes, "Finished child stream")
            }
        })
        .map_err(|e| e.into())
}
```


Overlapping Code:
```
>(
directive: Directive,
context: &OutputContext,
read: R,
tx_write: AsyncSender<WriteChannel>,
) -> Result<()>
where
R: io::Read + Send,
{
enter!(
span,
always_span!("child.stream", kind = %directive.span_display())
);
trace!("Processing child output stream");
let mut lines = 0u64;
let mut bytes = 0u64;
let buffer = io::BufReader::new(read);
let mut sink = RecordInterface::new_sink(tx_write.sink_map_err(CrateError::from));
buffer
.for_byte_line(|line| {
let utf8 = String::from_utf8_lossy(line);
block_on(sink.send(data(context, directive, &utf8).done_unchecked()))
//Ugly workaround for closure's io::Error requirement,
//Round trips from our local error into io::Error and back
.map_err(|e| io::Error::new(io::ErrorKind::Other, e))
.map(|o| {
lines += 1;
bytes += line.len() as u64;
o
})
.and(Ok(true))
})
.map(|_| {
if bytes > 0 {
debug!(lines, bytes, "Finished child stream")
}
})
.map_err(|
```
<Overlap Ratio: 0.9584664536741214>

---

--- 339 --
Question ID: 48755ae4c16411914f3cbd7820f618a8718b1ce0_2
Original Code:
```
fn test_range_inclusive() {
    let mut r = RangeInclusive::new(1i8, 2);
    assert_eq!(r.next(), Some(1));
    assert_eq!(r.next(), Some(2));
    assert_eq!(r.next(), None);

    r = RangeInclusive::new(127i8, 127);
    assert_eq!(r.next(), Some(127));
    assert_eq!(r.next(), None);

    r = RangeInclusive::new(-128i8, -128);
    assert_eq!(r.next_back(), Some(-128));
    assert_eq!(r.next_back(), None);

    // degenerate
    r = RangeInclusive::new(1, -1);
    assert_eq!(r.size_hint(), (0, Some(0)));
    assert_eq!(r.next(), None);
}
```


Overlapping Code:
```
_inclusive() {
let mut r = RangeInclusive::new(1i8, 2);
assert_eq!(r.next(), Some(1));
assert_eq!(r.next(), Some(2));
assert_eq!(r.next(), None);
r = RangeInclusive::new(127i8, 127);
assert_eq!(r.next(), Some(127));
assert_eq!(r.next(), None);
r = RangeInclusive::new(-128i8, -128);
assert_eq!(r.next_back(), Some(-128));
assert_eq!(r.next_back(), None);
// degenerate
r = RangeInclusive::new(1, -1);
assert_eq!(r.size_hint(), (0, Some(0)));
assert_eq!(r.nex
```
<Overlap Ratio: 0.9462809917355371>

---

--- 340 --
Question ID: 6e7799b4e39a5ea34926c9e1935bd9f63932f2ee_2
Original Code:
```
fn test_float_iterator_count() {
        assert_eq!(FloatIterator::new_with_step(-1.0, 1.0, 0.1).count(), 20);
        assert_eq!(FloatIterator::new_with_step(-2.0, 0.0, 0.5).count(), 4);
        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.75).count(), 4);
        assert_eq!(FloatIterator::new_with_step(-2.0, 1.75, 0.66667).count(), 6);
        assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.33333).count(), 9);
    }
```


Overlapping Code:
```
test_float_iterator_count() {
assert_eq!(FloatIterator::new_with_step(-1.0, 1.0, 0.1).count(), 20);
assert_eq!(FloatIterator::new_with_step(-2.0, 0.0, 0.5).count(), 4);
assert_eq!(FloatIterator::new_with_step(-2.0, 1.0, 0.75).count(), 4);
assert_eq!(FloatIterator::new_with_step(-2.0, 1.75, 0.66667).count(), 6);
assert_eq!(FloatIterator::new_with_st
```
<Overlap Ratio: 0.8974358974358975>

---

--- 341 --
Question ID: f1de0530e7ddf1e2d560b6098a3e1049fe5496a7_3
Original Code:
```
async fn test_overwrite_data() {
        let partition_cols = vec!["modified".to_string()];
        let mut table = create_initialized_table(&partition_cols).await;
        assert_eq!(table.version, 0);

        let transaction = get_transaction(table.table_uri.clone(), 0, SaveMode::Overwrite);
        let session_ctx = SessionContext::new();
        let task_ctx = session_ctx.task_ctx();

        let _ = collect(transaction.clone(), task_ctx.clone())
            .await
            .unwrap();
        table.update().await.unwrap();
        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);
        assert_eq!(table.version, 1);

        let transaction = get_transaction(table.table_uri.clone(), 1, SaveMode::Overwrite);
        let _ = collect(transaction.clone(), task_ctx).await.unwrap();
        table.update().await.unwrap();
        assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);
        assert_eq!(table.version, 2);
    }
```


Overlapping Code:
```
est_overwrite_data() {
let partition_cols = vec!["modified".to_string()];
let mut table = create_initialized_table(&partition_cols).await;
assert_eq!(table.version, 0);
let transaction = get_transaction(table.table_uri.clone(), 0, SaveMode::Overwrite);
let session_ctx = SessionContext::new();
let task_ctx = session_ctx.task_ctx();
let _ = collect(transaction.clone(), task_ctx.clone())
.await
.unwrap();
table.update().await.unwrap();
assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);
assert_eq!(table.version, 1);
let transaction = get_transaction(table.table_uri.clone(), 1, SaveMode::Overwrite);
let _ = collect(transaction.clone(), task_ctx).await.unwrap();
table.update().await.unwrap();
assert_eq!(table.get_file_uris().collect::<Vec<_>>().len(), 2);
assert_eq!(table.version, 2
```
<Overlap Ratio: 0.9828009828009828>

---

--- 342 --
Question ID: 6d6017573603d469698c5278c79502c5f9833975_4
Original Code:
```
fn delete_twice() {
        let mut world = World::new();

        let e = world.create_entity().build();

        world.delete_entity(e).unwrap();
        assert!(world.entities().delete(e).is_err());
    }
```


Overlapping Code:
```
lete_twice() {
let mut world = World::new();
let e = world.create_entity().build();
world.delete_entity(e).unwrap();
assert!(world.entities().delete(e
```
<Overlap Ratio: 0.8875739644970414>

---

--- 343 --
Question ID: 5f14129104d731d773f38090ea2af93123c90cb1_0
Original Code:
```
fn get_options() -> Options {
    let kdf_options: ScryptKDFOptions = Default::default();
    let mut opts = Options::new();
    opts.optopt(
        "i",
        "iterations",
        &format!(
            "set the number of required iterations (default: {})",
            kdf_options.iterations
        ),
        "ITER",
    );
    opts.optopt(
        "n",
        "workFactor",
        &format!("set the work factor (default: {})", kdf_options.n),
        "N",
    );
    opts.optopt(
        "r",
        "blocksize",
        &format!("set the blocksize parameter (default: {})", kdf_options.r),
        "R",
    );
    opts.optopt(
        "p",
        "parallel",
        &format!("set the parallelization parameter (default: {})", kdf_options.p),
        "P",
    );
    opts.optopt(
        "k",
        "keysize",
        &format!("set the length of the derived (default: {})", kdf_options.keysize),
        "SIZE",
    );
    opts.optflag("t", "test", "print test vectors");
    opts.optflag("h", "help", "print this help menu");
    opts.optflag("v", "version", "print version information");

    opts
}
```


Overlapping Code:
```
 Options {
let kdf_options: ScryptKDFOptions = Default::default();
let mut opts = Options::new();
opts.optopt(
"i",
"iterations",
&format!(
"set the number of required iterations (default: {})",
kdf_options.iterations
),
"ITER",
);
opts.optopt(
"n",
"workFactor",
&format!("set the work factor (default: {})", kdf_options.n),
"N",
);
opts.optopt(
"r",
"blocksize",
&format!("set the blocksize parameter (default: {})", kdf_options.r),
"R",
);
opts.optopt(
"p",
"parallel",
&format!("set the parallelization parameter (default: {})", kdf_options.p),
"P",
);
opts.optopt(
"k",
"keysize",
&format!("set the length of the derived (default: {})", kdf_options.keysize),
"SIZE",
);
opts.optflag("t", "test", "print test vectors");
opts.optflag("h", "help", "print this help menu");
opts.optflag("v", "version", "print versio
```
<Overlap Ratio: 0.9511059371362048>

---

--- 344 --
Question ID: b10dfb238fb0a19786f0768489ec9eef949ec872_6
Original Code:
```
fn iter_collect_backwards() {
        let mut list: List<i32> = List::new();
        list.push(3);
        list.push(2);
        list.push(1);

        let mut it = list.iter();
        assert_eq!(it.next(), Some(&1));
        assert_eq!(it.next(), Some(&2));
        assert_eq!(it.next(), Some(&3));
        assert_eq!(it.next(), None);

        // Ensure the data is still there.
        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3]);
    }
```


Overlapping Code:
```
ect_backwards() {
let mut list: List<i32> = List::new();
list.push(3);
list.push(2);
list.push(1);
let mut it = list.iter();
assert_eq!(it.next(), Some(&1));
assert_eq!(it.next(), Some(&2));
assert_eq!(it.next(), Some(&3));
assert_eq!(it.next(), None);
// Ensure the data is still there.
assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3]
```
<Overlap Ratio: 0.9562841530054644>

---

--- 345 --
Question ID: 8da842d9a7ccd51097a379d4dd91a7f6af8c32f5_23
Original Code:
```
pub unsafe extern "C" fn yarray_iter_next(iterator: *mut ArrayIter) -> *mut YOutput {
    assert!(!iterator.is_null());

    let iter = iterator.as_mut().unwrap();
    if let Some(v) = iter.next() {
        let out = YOutput::from(v);
        Box::into_raw(Box::new(out))
    } else {
        std::ptr::null_mut()
    }
}
```


Overlapping Code:
```
rn "C" fn yarray_iter_next(iterator: *mut ArrayIter) -> *mut YOutput {
assert!(!iterator.is_null());
let iter = iterator.as_mut().unwrap();
if let Some(v) = iter.next() {
let out = YOutput::from(v);
Box::into_raw(Box::new(out))
} else {
std::ptr::nul
```
<Overlap Ratio: 0.9057971014492754>

---

--- 346 --
Question ID: b8b95c19692c50b7c43ca18799f2a5027deb90ab_9
Original Code:
```
pub async fn download_and_display_offers(
    network_str: Option<String>,
    maker_address: Option<String>,
) {
    let mut rpc_network: Option<(Client, Network)> = None;

    let maker_addresses = if let Some(maker_addr) = maker_address {
        vec![MakerAddress::Tor {
            address: maker_addr,
        }]
    } else {
        let network = match get_bitcoin_rpc() {
            Ok((rpc, network)) => {
                rpc_network = Some((rpc, network));
                network
            }
            Err(error) => {
                if let Some(net_str) = network_str {
                    str_to_bitcoin_network(net_str.as_str())
                } else {
                    panic!(
                        "network string not provided, and error connecting to bitcoin node: {:?}",
                        error
                    );
                }
            }
        };
        get_advertised_maker_addresses(network)
            .await
            .expect("unable to sync maker addresses from directory servers")
    };
    let offers_addresses = sync_offerbook_with_addresses(maker_addresses.clone()).await;
    let mut addresses_offers_map = HashMap::new();
    for offer_address in offers_addresses.iter() {
        let address_str = match &offer_address.address {
            MakerAddress::Clearnet { address } => address,
            MakerAddress::Tor { address } => address,
        };
        addresses_offers_map.insert(address_str, offer_address);
    }

    println!(
        "{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}",
        "n",
        "maker address",
        "max size",
        "min size",
        "abs fee",
        "amt rel fee",
        "time rel fee",
        "minlocktime",
        "fidelity bond value",
    );
    let block_count = rpc_network
        .as_ref()
        .map(|(rpc, _)| rpc.get_block_count().unwrap())
        .unwrap_or(0);
    let median_time = rpc_network
        .as_ref()
        .map(|(rpc, _)| rpc.get_blockchain_info().unwrap().median_time)
        .unwrap_or(0);

    for (ii, address) in maker_addresses.iter().enumerate() {
        let address_str = match &address {
            MakerAddress::Clearnet { address } => address,
            MakerAddress::Tor { address } => address,
        };
        if let Some(offer_address) = addresses_offers_map.get(&address_str) {
            let o = &offer_address.offer;
            let fidelity_bond_value_str = if rpc_network.is_some() {
                let (rpc, network) = rpc_network.as_ref().unwrap();
                let onion_hostname = if *network != Network::Regtest {
                    address_str
                } else {
                    REGTEST_DUMMY_ONION_HOSTNAME
                };
                let txo_data = o
                    .fidelity_bond_proof
                    .verify_and_get_txo(&rpc, block_count, onion_hostname)
                    .unwrap();
                let value = o
                    .fidelity_bond_proof
                    .calculate_fidelity_bond_value(&rpc, block_count, &txo_data, median_time)
                    .unwrap();
                format!("{:.4e}", value)
            } else {
                String::from("unknown")
            };

            println!(
                "{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}",
                ii,
                address_str,
                o.max_size,
                o.min_size,
                o.absolute_fee_sat,
                o.amount_relative_fee_ppb,
                o.time_relative_fee_ppb,
                o.minimum_locktime,
                fidelity_bond_value_str
            );
        } else {
            println!("{:<3} {:<70} UNREACHABLE", ii, address_str);
        }
    }
}
```


Overlapping Code:
```
offers(
network_str: Option<String>,
maker_address: Option<String>,
) {
let mut rpc_network: Option<(Client, Network)> = None;
let maker_addresses = if let Some(maker_addr) = maker_address {
vec![MakerAddress::Tor {
address: maker_addr,
}]
} else {
let network = match get_bitcoin_rpc() {
Ok((rpc, network)) => {
rpc_network = Some((rpc, network));
network
}
Err(error) => {
if let Some(net_str) = network_str {
str_to_bitcoin_network(net_str.as_str())
} else {
panic!(
"network string not provided, and error connecting to bitcoin node: {:?}",
error
);
}
}
};
get_advertised_maker_addresses(network)
.await
.expect("unable to sync maker addresses from directory servers")
};
let offers_addresses = sync_offerbook_with_addresses(maker_addresses.clone()).await;
let mut addresses_offers_map = HashMap::new();
for offer_address in offers_addresses.iter() {
let address_str = match &offer_address.address {
MakerAddress::Clearnet { address } => address,
MakerAddress::Tor { address } => address,
};
addresses_offers_map.insert(address_str, offer_address);
}
println!(
"{:<3} {:<70} {:<12} {:<12} {:<12} {:<12} {:<12} {:<12} {:<19}",
"n",
"maker address",
"max size",
"min size",
"abs fee",
"amt rel fee",
"time rel fee",
"minlocktime",
"fidelity bond value",
);
let block_count = rpc_network
.as_ref()
.map(|(rpc, _)| rpc.get_block_count().unwrap())
.unwrap_or(0);
let median_time = rpc_network
.as_ref()
.map(|(rpc, _)| rpc.get_blockchain_info().unwrap().median_time)
.unwrap_or(0);
for (ii, address) in maker_addresses.iter().enumerate() {
let address_str = match &address {
MakerAddress::Clearnet { address } => address,
MakerAddress::Tor { address } => address,
};
if let Some(offer_address) = addresses_offers_map.get(&address_str) {
let o = &offer_address.offer;
let fidelity_bond_value_str = if r
```
<Overlap Ratio: 0.967741935483871>

---

--- 347 --
Question ID: 7fa28a5dba5e22a5347cc52f57cafb812f339909_6
Original Code:
```
fn test_abstract_unix_stream() {
        let name = generate_random_abstract_addr();

        let listener = unix_stream_abstract_bind(&name).unwrap();

        let mut remote = unix_stream_abstract_connect(&name).unwrap();
        let (mut client, _addr) = listener.accept().unwrap();

        let mut prefixed_name = OsString::from("\0");
        prefixed_name.push(name);

        assert_eq!(
            get_unix_listener_raw_sockname(&listener).unwrap(),
            prefixed_name,
        );

        assert_eq!(
            get_unix_stream_raw_sockname(&remote).unwrap(),
            OsString::new(),
        );
        assert_eq!(
            get_unix_stream_raw_peername(&remote).unwrap(),
            prefixed_name,
        );

        assert_eq!(
            get_unix_stream_raw_sockname(&client).unwrap(),
            prefixed_name,
        );
        assert_eq!(
            get_unix_stream_raw_peername(&client).unwrap(),
            OsString::new(),
        );

        let mut data = Vec::new();
        data.resize(10, 0);

        client.write_all(&[0, 1, 2, 3]).unwrap();
        assert_eq!(remote.read(&mut data).unwrap(), 4);
        assert_eq!(data[..4], [0, 1, 2, 3]);

        remote.write_all(&[0, 1, 2, 3]).unwrap();
        assert_eq!(client.read(&mut data).unwrap(), 4);
        assert_eq!(data[..4], [0, 1, 2, 3]);
    }
```


Overlapping Code:
```
nerate_random_abstract_addr();
let listener = unix_stream_abstract_bind(&name).unwrap();
let mut remote = unix_stream_abstract_connect(&name).unwrap();
let (mut client, _addr) = listener.accept().unwrap();
let mut prefixed_name = OsString::from("\0");
prefixed_name.push(name);
assert_eq!(
get_unix_listener_raw_sockname(&listener).unwrap(),
prefixed_name,
);
assert_eq!(
get_unix_stream_raw_sockname(&remote).unwrap(),
OsString::new(),
);
assert_eq!(
get_unix_stream_raw_peername(&remote).unwrap(),
prefixed_name,
);
assert_eq!(
get_unix_stream_raw_sockname(&client).unwrap(),
prefixed_name,
);
assert_eq!(
get_unix_stream_raw_peername(&client).unwrap(),
OsString::new(),
);
let mut data = Vec::new();
data.resize(10, 0);
client.write_all(&[0, 1, 2, 3]).unwrap();
assert_eq!(remote.read(&mut data).unwrap(), 4);
assert_eq!(data[..4], [0, 1, 2, 3]);
remote.write_all(&[0, 1, 2, 3]).unwrap();
assert_eq!(client.read(&mut data).unwrap(), 4);
assert_eq!(data[..4], [0, 1, 2, 3]);

```
<Overlap Ratio: 0.9541015625>

---

--- 348 --
Question ID: f5b69259f35cd2b94ebfaa0e7718268cdd889d00_1
Original Code:
```
pub fn pathconf<P: AsRef<ffi::OsStr>>(path: P, name: Int) -> Option<Long> {
    let c_path = ffi::CString::new(path.as_ref().as_bytes()).ok()?;

    let val = unsafe { libc::pathconf(c_path.as_ptr(), name) };

    if val >= 0 {
        Some(val)
    } else {
        None
    }
}
```


Overlapping Code:
```
f<P: AsRef<ffi::OsStr>>(path: P, name: Int) -> Option<Long> {
let c_path = ffi::CString::new(path.as_ref().as_bytes()).ok()?;
let val = unsafe { libc::pathconf(c_path.as_ptr(), name) };
if val >= 0 {

```
<Overlap Ratio: 0.8298755186721992>

---

--- 349 --
Question ID: 3e24e349f9fab0f9572e82396936ce22ca87c8a7_2
Original Code:
```
async fn update(
    uuid: web::Path<String>,
    post: web::Json<PostRequest>,
    db_pool: web::Data<DbPool>,
) -> impl Responder {
    let uuid_;
    match Uuid::parse_str(uuid.as_str()) {
        Ok(u) => uuid_ = u,
        Err(_) => return HttpResponse::BadRequest().body("Invalid Post ID"),
    }
    let result = Post::update(uuid_, post.into_inner(), db_pool.get_ref()).await;
    match result {
        Ok(post) => HttpResponse::Ok().json(post),
        _ => HttpResponse::BadRequest().body("Post not found"),
    }
}
```


Overlapping Code:
```
h<String>,
post: web::Json<PostRequest>,
db_pool: web::Data<DbPool>,
) -> impl Responder {
let uuid_;
match Uuid::parse_str(uuid.as_str()) {
Ok(u) => uuid_ = u,
Err(_) => return HttpResponse::BadRequest().body("Invalid Post ID"),
}
let result = Post::update(uuid_, post.into_inner(), db_pool.get_ref()).await;
match result {
Ok(post) => HttpResponse::Ok().json(post),
_ => HttpResponse::BadRequest().
```
<Overlap Ratio: 0.8733624454148472>

---

--- 350 --
Question ID: 0c30ef963a29b9de24edc4ae4170076b2d60e040_8
Original Code:
```
async fn verify_valid_message_duplicate_account_name() {
    let (_db, connector, mut api, injector) = new_env().await;
    let mut stream = api.ws_at("/api/account_status").await.unwrap();

    // Insert judgement requests.
    connector.inject(alice_judgement_request()).await;
    // Note: Bob specified the same Matrix handle as Alice.
    connector
        .inject(WatcherMessage::new_judgement_request({
            let mut req = JudgementRequest::bob();
            req.accounts
                .entry(AccountType::Matrix)
                .and_modify(|e| *e = "@alice:matrix.org".to_string());
            req
        }))
        .await;

    let states = connector.inserted_states().await;
    let mut alice = states[0].clone();
    let mut bob = states[1].clone();

    // Subscribe to endpoint.
    stream.send(IdentityContext::alice().to_ws()).await.unwrap();

    // Check current state.
    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
    assert_eq!(
        resp,
        JsonResult::Ok(ResponseAccountState::with_no_notifications(alice.clone()))
    );

    // Send valid message.
    injector
        .send(ExternalMessage {
            origin: ExternalMessageType::Matrix("@alice:matrix.org".to_string()),
            id: MessageId::from(0u32),
            timestamp: Timestamp::now(),
            values: alice
                .get_field(&F::ALICE_MATRIX())
                .expected_message()
                .to_message_parts(),
        })
        .await;

    // Email account of Alice is now verified
    alice
        .get_field_mut(&F::ALICE_MATRIX())
        .expected_message_mut()
        .set_verified();

    // The expected message (field verified successfully).
    let expected = ResponseAccountState {
        state: alice.clone().into(),
        notifications: vec![NotificationMessage::FieldVerified {
            context: alice.context.clone(),
            field: F::ALICE_MATRIX(),
        }],
    };

    // Check response
    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
    assert_eq!(resp, JsonResult::Ok(expected));

    // Other judgement states must be unaffected (Bob), but will receive a "failed attempt".
    stream.send(IdentityContext::bob().to_ws()).await.unwrap();

    *bob.get_field_mut(&F::ALICE_MATRIX()).failed_attempts_mut() = 1;

    let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
    assert_eq!(
        resp,
        JsonResult::Ok(ResponseAccountState::with_no_notifications(bob.clone()))
    );

    // Empty stream.
    assert!(stream.next().now_or_never().is_none());
}
```


Overlapping Code:
```
age_duplicate_account_name() {
let (_db, connector, mut api, injector) = new_env().await;
let mut stream = api.ws_at("/api/account_status").await.unwrap();
// Insert judgement requests.
connector.inject(alice_judgement_request()).await;
// Note: Bob specified the same Matrix handle as Alice.
connector
.inject(WatcherMessage::new_judgement_request({
let mut req = JudgementRequest::bob();
req.accounts
.entry(AccountType::Matrix)
.and_modify(|e| *e = "@alice:matrix.org".to_string());
req
}))
.await;
let states = connector.inserted_states().await;
let mut alice = states[0].clone();
let mut bob = states[1].clone();
// Subscribe to endpoint.
stream.send(IdentityContext::alice().to_ws()).await.unwrap();
// Check current state.
let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
assert_eq!(
resp,
JsonResult::Ok(ResponseAccountState::with_no_notifications(alice.clone()))
);
// Send valid message.
injector
.send(ExternalMessage {
origin: ExternalMessageType::Matrix("@alice:matrix.org".to_string()),
id: MessageId::from(0u32),
timestamp: Timestamp::now(),
values: alice
.get_field(&F::ALICE_MATRIX())
.expected_message()
.to_message_parts(),
})
.await;
// Email account of Alice is now verified
alice
.get_field_mut(&F::ALICE_MATRIX())
.expected_message_mut()
.set_verified();
// The expected message (field verified successfully).
let expected = ResponseAccountState {
state: alice.clone().into(),
notifications: vec![NotificationMessage::FieldVerified {
context: alice.context.clone(),
field: F::ALICE_MATRIX(),
}],
};
// Check response
let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
assert_eq!(resp, JsonResult::Ok(expected));
// Other judgement states must be unaffected (Bob), but will receive a "failed attempt".
stream.send(IdentityContext::bob().to_ws()).await.unwrap();
*bob.get_field_mut(&F::ALICE_MATRIX()).failed_attempts_mut() = 1;
let resp: JsonResult<ResponseAccountState> = stream.next().await.into();
assert_eq!(
resp,
JsonResult::Ok(ResponseAccountState::
```
<Overlap Ratio: 0.98635477582846>

---

--- 351 --
Question ID: 990f96416e7b850332ecd16b9e9bac2a40c3f1f9_4
Original Code:
```
fn mix_columns(state: &[u8; 16]) -> [u8; 16] {
    let mut tmp_state: [u8; 16] = [0; 16];
    // MixColumns
    for col in 0..4 {
        let tmp = state[12 + col];
        tmp_state[12 + col] = state[col] ^ state[8 + col];
        tmp_state[8 + col] = state[4 + col] ^ state[8 + col];
        tmp_state[4 + col] = state[col];
        tmp_state[col] = tmp ^ tmp_state[12 + col];
    }
    tmp_state
}
```


Overlapping Code:
```
&[u8; 16]) -> [u8; 16] {
let mut tmp_state: [u8; 16] = [0; 16];
// MixColumns
for col in 0..4 {
let tmp = state[12 + col];
tmp_state[12 + col] = state[col] ^ state[8 + col];
tmp_state[8 + col] = state[4 + col] ^ state[8 + col];
tmp_state[4 + col] = state[col];
tmp_state[col] =
```
<Overlap Ratio: 0.8147058823529412>

---

--- 352 --
Question ID: 9b304d44d3c999562230e60592aa2f68bccc8d87_2
Original Code:
```
async fn execute_stdin(fiber: &mut Fiber) {
    let mut stdin = std::io::stdin();
    let mut source = String::new();

    if let Err(e) = stdin.read_to_string(&mut source) {
        log::error!("{}", e);
        exit::set(1);
        return;
    }

    if let Err(e) = fiber.execute(None, SourceFile::named("<stdin>", source)).await {
        log::error!("{}", e);
        exit::set(1);
    }
}
```


Overlapping Code:
```
Fiber) {
let mut stdin = std::io::stdin();
let mut source = String::new();
if let Err(e) = stdin.read_to_string(&mut source) {
log::error!("{}", e);
exit::set(1);
return;
}
if let Err(e) = fiber.execute(None, SourceFile::named("<stdin>", source)).await {
```
<Overlap Ratio: 0.7720364741641338>

---

--- 353 --
Question ID: 9ca7d9b5c1251d795bc0be19d77fbf8155a74e38_7
Original Code:
```
async fn capture_url_event_should_return_a_filled_command_event() {
        let mock_post_http_request_body = r#"
        {
            "url":"https://duckduckgo.com/"
         }"#;

        let body = Bytes::from(mock_post_http_request_body);
        let path = "/wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url".to_string();

        let expected_event = Some(CommandEvent {
            event: domain::session::SessionStatus::UrlCommand,
            session_id: "f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7".to_string(),
            url: "https://duckduckgo.com/".to_string(),
        });

        let capture_event = capture_url_event(path, &body);

        assert!(capture_event == expected_event);
    }
```


Overlapping Code:
```
n_a_filled_command_event() {
let mock_post_http_request_body = r#"
{
"url":"https://duckduckgo.com/"
}"#;
let body = Bytes::from(mock_post_http_request_body);
let path = "/wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url".to_string();
let expected_event = Some(CommandEvent {
event: domain::session::SessionStatus::UrlCommand,
session_id: "f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7".to_string(),
url: "https://duckduckgo.com/".to_string(),
});
let capture_event = capture_url_event(path, &body);
assert!(capture_event == expected_event
```
<Overlap Ratio: 0.9258620689655173>

---

--- 354 --
Question ID: 2be006f9732f7fccae11a7aae05d5e02f090aa85_7
Original Code:
```
fn newly_started() {
        trace_init();

        let message = "9";
        let name = "vector_test_newly_started";
        let label = "vector_test_label_newly_started";

        let mut rt = runtime();
        let out = source_with(&[name], None, &mut rt);

        rt.block_on_std(async move {
            let docker = docker().unwrap();

            let id = container_log_n(1, name, Some(label), message, &docker).await;
            let events = collect_n(out, 1).compat().await.ok().unwrap();
            container_remove(&id, &docker).await;

            let log = events[0].as_log();
            assert_eq!(log[&event::log_schema().message_key()], message.into());
            assert_eq!(log[&super::CONTAINER], id.into());
            assert!(log.get(&super::CREATED_AT).is_some());
            assert_eq!(log[&super::IMAGE], "busybox".into());
            assert!(log.get(&format!("label.{}", label).into()).is_some());
            assert_eq!(events[0].as_log()[&super::NAME], name.into());
            assert_eq!(
                events[0].as_log()[event::log_schema().source_type_key()],
                "docker".into()
            );
        });
    }
```


Overlapping Code:
```
nit();
let message = "9";
let name = "vector_test_newly_started";
let label = "vector_test_label_newly_started";
let mut rt = runtime();
let out = source_with(&[name], None, &mut rt);
rt.block_on_std(async move {
let docker = docker().unwrap();
let id = container_log_n(1, name, Some(label), message, &docker).await;
let events = collect_n(out, 1).compat().await.ok().unwrap();
container_remove(&id, &docker).await;
let log = events[0].as_log();
assert_eq!(log[&event::log_schema().message_key()], message.into());
assert_eq!(log[&super::CONTAINER], id.into());
assert!(log.get(&super::CREATED_AT).is_some());
assert_eq!(log[&super::IMAGE], "busybox".into());
assert!(log.get(&format!("label.{}", label).into()).is_some());
assert_eq!(events[0].as_log()[&super::NAME], name.into());
assert_eq!(
events[0].as_log()[event::log_schema().source_type_key()
```
<Overlap Ratio: 0.9392935982339956>

---

--- 355 --
Question ID: ca93521b29d4b5d20540e715c94e80681eb6986e_18
Original Code:
```
fn size_from_tuple_first_item_should_be_rows() {
        // A nonzero value is used so we test non default behavior.
        let expected_rows = 1;

        let actual = Size::from((expected_rows, 0));

        assert_eq!(expected_rows, actual.rows);
    }
```


Overlapping Code:
```
_rows() {
// A nonzero value is used so we test non default behavior.
let expected_rows = 1;
let actual = Size::from((expected_rows, 0));
assert_eq!(e
```
<Overlap Ratio: 0.6880733944954128>

---

--- 356 --
Question ID: 2dbcd10154d2cec77fa501a1abb1b55b16017288_0
Original Code:
```
pub fn occluded<B: Bitmap>(p0: Point3i, p1: Point3i, solid: &B) -> bool {
    // 3d bresenham, ripped from http://www.cobrabytes.com/index.php?topic=1150.0

    // println!("{} {}", DisplayWrap::from(p0), DisplayWrap::from(p1));

    let mut x0 = p0.x;
    let mut y0 = p0.y;
    let mut z0 = p0.z;

    let mut x1 = p1.x;
    let mut y1 = p1.y;
    let mut z1 = p1.z;

    //'steep' xy Line, make longest delta x plane
    let swap_xy = (y1 - y0).abs() > (x1 - x0).abs();
    if swap_xy {
        std::mem::swap(&mut x0, &mut y0);
        std::mem::swap(&mut x1, &mut y1);
    }

    // do same for xz
    let swap_xz = (z1 - z0).abs() > (x1 - x0).abs();
    if swap_xz {
        std::mem::swap(&mut x0, &mut z0);
        std::mem::swap(&mut x1, &mut z1);
    }

    // delta is Length in each plane
    let delta_x = (x1 - x0).abs();
    let delta_y = (y1 - y0).abs();
    let delta_z = (z1 - z0).abs();

    // drift controls when to step in 'shallow' planes
    // starting value keeps Line centred
    let mut drift_xy = delta_x / 2;
    let mut drift_xz = delta_x / 2;

    // direction of line
    let step_x = if x0 > x1 { -1 } else { 1 };
    let step_y = if y0 > y1 { -1 } else { 1 };
    let step_z = if z0 > z1 { -1 } else { 1 };

    // starting point
    let mut y = y0;
    let mut z = z0;

    // step through longest delta (which we have swapped to x)
    let mut x = x0;
    while x != x1 {
        // copy position
        let mut cx = x;
        let mut cy = y;
        let mut cz = z;

        // unswap (in reverse)
        if swap_xz {
            std::mem::swap(&mut cx, &mut cz);
        }

        if swap_xy {
            std::mem::swap(&mut cx, &mut cy);
        }

        if solid.get(Point3i::new(cx, cy, cz)) {
            // println!("stop {}", DisplayWrap::from(Point3i::new(cx, cy, cz)));
            return true;
        }
        // update progress in other planes
        drift_xy -= delta_y;
        drift_xz -= delta_z;

        // step in y plane
        if drift_xy < 0 {
            y += step_y;
            drift_xy += delta_x;
        }

        // same in z
        if drift_xz < 0 {
            z += step_z;
            drift_xz += delta_x;
        }

        x += step_x;
    }

    // return false;
    false
}
```


Overlapping Code:
```
 occluded<B: Bitmap>(p0: Point3i, p1: Point3i, solid: &B) -> bool {
// 3d bresenham, ripped from http://www.cobrabytes.com/index.php?topic=1150.0
// println!("{} {}", DisplayWrap::from(p0), DisplayWrap::from(p1));
let mut x0 = p0.x;
let mut y0 = p0.y;
let mut z0 = p0.z;
let mut x1 = p1.x;
let mut y1 = p1.y;
let mut z1 = p1.z;
//'steep' xy Line, make longest delta x plane
let swap_xy = (y1 - y0).abs() > (x1 - x0).abs();
if swap_xy {
std::mem::swap(&mut x0, &mut y0);
std::mem::swap(&mut x1, &mut y1);
}
// do same for xz
let swap_xz = (z1 - z0).abs() > (x1 - x0).abs();
if swap_xz {
std::mem::swap(&mut x0, &mut z0);
std::mem::swap(&mut x1, &mut z1);
}
// delta is Length in each plane
let delta_x = (x1 - x0).abs();
let delta_y = (y1 - y0).abs();
let delta_z = (z1 - z0).abs();
// drift controls when to step in 'shallow' planes
// starting value keeps Line centred
let mut drift_xy = delta_x / 2;
let mut drift_xz = delta_x / 2;
// direction of line
let step_x = if x0 > x1 { -1 } else { 1 };
let step_y = if y0 > y1 { -1 } else { 1 };
let step_z = if z0 > z1 { -1 } else { 1 };
// starting point
let mut y = y0;
let mut z = z0;
// step through longest delta (which we have swapped to x)
let mut x = x0;
while x != x1 {
// copy position
let mut cx = x;
let mut cy = y;
let mut cz = z;
// unswap (in reverse)
if swap_xz {
std::mem::swap(&mut cx, &mut cz);
}
if swap_xy {
std::mem::swap(&mut cx, &mut cy);
}
if solid.get(Point3i::new(cx, cy, cz)) {
// println!("stop {}", DisplayWrap::from(Point3i::new(cx, cy, cz)));
return true;
}
// update progress in other planes
drift_xy -= delta_y;
drift_xz -= delta_z;
// step in y plane
if drift_xy < 0 {
y += step_y;
drift_xy += delta_x;
}
// same in z
if drift_xz < 0 {
z += step_z;
drift_xz += delta_x;
}
x += step_x;
}
// return 
```
<Overlap Ratio: 0.9888765294771968>

---

--- 357 --
Question ID: 541258c0504077e7afd0314195800180a60c4cb2_1
Original Code:
```
async fn run(event_loop: EventLoop<()>, window: Window) {
    let surface = Surface::create(&window);
    let adapter = Adapter::request(
        &RequestAdapterOptions {
            power_preference: PowerPreference::Default,
            compatible_surface: Some(&surface),
        },
        BackendBit::PRIMARY,
    )
    .await
    .unwrap();
    let (device, queue) = adapter
        .request_device(&DeviceDescriptor {
            extensions: Extensions {
                anisotropic_filtering: false,
            },
            limits: Limits::default(),
        })
        .await;
    let mut screen_size = window.inner_size();

    let mut swap_chain_descriptor = SwapChainDescriptor {
        usage: TextureUsage::OUTPUT_ATTACHMENT,
        format: TextureFormat::Bgra8Unorm,
        width: screen_size.width,
        height: screen_size.height,
        present_mode: PresentMode::Mailbox,
    };
    let mut swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);

    let mut msaa_texture_descriptor = TextureDescriptor {
        size: Extent3d {
            width: screen_size.width,
            height: screen_size.height,
            depth: 1,
        },
        array_layer_count: 1,
        mip_level_count: 1,
        sample_count: 16,
        dimension: TextureDimension::D2,
        format: swap_chain_descriptor.format,
        usage: TextureUsage::OUTPUT_ATTACHMENT,
        label: None,
    };
    let mut msaa_texture = device
        .create_texture(&msaa_texture_descriptor)
        .create_default_view();

    let vertex_shader = include_bytes!("../metaballs_vert.spv");
    let vertex_shader = read_spirv(Cursor::new(&vertex_shader[..])).unwrap();
    let vertex_shader = device.create_shader_module(&vertex_shader);

    let fragment_shader = include_bytes!("../metaballs_frag.spv");
    let fragment_shader = read_spirv(Cursor::new(&fragment_shader[..])).unwrap();
    let fragment_shader = device.create_shader_module(&fragment_shader);

    let time = Instant::now();
    let mut time_uniform = TimeUniform {
        time: time.elapsed().as_secs_f32(),
    };
    let time_uniform_buffer = device.create_buffer_with_data(
        bytemuck::cast_slice(&[time_uniform]),
        BufferUsage::UNIFORM | BufferUsage::COPY_DST,
    );

    let mut zoom_uniform = ZoomUniform { zoom: 1.0 };
    let zoom_uniform_buffer = device.create_buffer_with_data(
        bytemuck::cast_slice(&[zoom_uniform]),
        BufferUsage::UNIFORM | BufferUsage::COPY_DST,
    );

    let mut screen_size_uniform = ScreenSizeUniform {
        screen_size: [screen_size.width as f32, screen_size.height as f32],
    };
    let screen_size_uniform_buffer = device.create_buffer_with_data(
        bytemuck::cast_slice(&[screen_size_uniform]),
        BufferUsage::UNIFORM | BufferUsage::COPY_DST,
    );

    let bind_group_layout = device.create_bind_group_layout(&BindGroupLayoutDescriptor {
        bindings: &[
            BindGroupLayoutEntry {
                binding: 0,
                visibility: ShaderStage::FRAGMENT,
                ty: BindingType::UniformBuffer { dynamic: false },
            },
            BindGroupLayoutEntry {
                binding: 1,
                visibility: ShaderStage::FRAGMENT,
                ty: BindingType::UniformBuffer { dynamic: false },
            },
            BindGroupLayoutEntry {
                binding: 2,
                visibility: ShaderStage::FRAGMENT,
                ty: BindingType::UniformBuffer { dynamic: false },
            },
        ],
        label: None,
    });
    let bind_group = device.create_bind_group(&BindGroupDescriptor {
        layout: &bind_group_layout,
        bindings: &[
            Binding {
                binding: 0,
                resource: BindingResource::Buffer {
                    buffer: &time_uniform_buffer,
                    range: 0..std::mem::size_of_val(&time_uniform) as BufferAddress,
                },
            },
            Binding {
                binding: 1,
                resource: BindingResource::Buffer {
                    buffer: &zoom_uniform_buffer,
                    range: 0..std::mem::size_of_val(&zoom_uniform) as BufferAddress,
                },
            },
            Binding {
                binding: 2,
                resource: BindingResource::Buffer {
                    buffer: &screen_size_uniform_buffer,
                    range: 0..std::mem::size_of_val(&screen_size_uniform) as BufferAddress,
                },
            },
        ],
        label: None,
    });

    let pipeline_layout = device.create_pipeline_layout(&PipelineLayoutDescriptor {
        bind_group_layouts: &[&bind_group_layout],
    });
    let pipeline = device.create_render_pipeline(&RenderPipelineDescriptor {
        layout: &pipeline_layout,
        vertex_stage: ProgrammableStageDescriptor {
            module: &vertex_shader,
            entry_point: "main",
        },
        fragment_stage: Some(ProgrammableStageDescriptor {
            module: &fragment_shader,
            entry_point: "main",
        }),
        rasterization_state: Some(RasterizationStateDescriptor {
            front_face: FrontFace::Ccw,
            cull_mode: CullMode::None,
            depth_bias: 0,
            depth_bias_slope_scale: 0.0,
            depth_bias_clamp: 0.0,
        }),
        primitive_topology: PrimitiveTopology::TriangleList,
        color_states: &[ColorStateDescriptor {
            format: swap_chain_descriptor.format,
            color_blend: BlendDescriptor::REPLACE,
            alpha_blend: BlendDescriptor::REPLACE,
            write_mask: ColorWrite::ALL,
        }],
        depth_stencil_state: None,
        vertex_state: VertexStateDescriptor {
            index_format: IndexFormat::Uint16,
            vertex_buffers: &[],
        },
        sample_count: msaa_texture_descriptor.sample_count,
        sample_mask: !0,
        alpha_to_coverage_enabled: false,
    });

    event_loop.run(move |event, _, control_flow| {
        *control_flow = ControlFlow::Poll;
        match event {
            Event::MainEventsCleared => window.request_redraw(),
            Event::WindowEvent {
                event: WindowEvent::Resized(new_size),
                ..
            } => {
                screen_size = new_size;

                swap_chain_descriptor.width = screen_size.width;
                swap_chain_descriptor.height = screen_size.height;
                swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);

                msaa_texture_descriptor.size = Extent3d {
                    width: screen_size.width,
                    height: screen_size.height,
                    depth: 1,
                };
                msaa_texture = device
                    .create_texture(&msaa_texture_descriptor)
                    .create_default_view();

                let mut encoder =
                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });
                screen_size_uniform.screen_size =
                    [screen_size.width as f32, screen_size.height as f32];
                let staging_buffer = device.create_buffer_with_data(
                    bytemuck::cast_slice(&[screen_size_uniform]),
                    BufferUsage::COPY_SRC,
                );
                encoder.copy_buffer_to_buffer(
                    &staging_buffer,
                    0,
                    &screen_size_uniform_buffer,
                    0,
                    std::mem::size_of::<ScreenSizeUniform>() as BufferAddress,
                );
                queue.submit(&[encoder.finish()]);
            }
            Event::RedrawRequested(_) => {
                let display_texture = &swap_chain.get_next_texture().unwrap().view;
                let mut encoder =
                    device.create_command_encoder(&CommandEncoderDescriptor { label: None });
                {
                    time_uniform.time = time.elapsed().as_secs_f32();
                    let staging_buffer = device.create_buffer_with_data(
                        bytemuck::cast_slice(&[time_uniform]),
                        BufferUsage::COPY_SRC,
                    );
                    encoder.copy_buffer_to_buffer(
                        &staging_buffer,
                        0,
                        &time_uniform_buffer,
                        0,
                        std::mem::size_of::<TimeUniform>() as BufferAddress,
                    );

                    let mut render_pass = encoder.begin_render_pass(&RenderPassDescriptor {
                        color_attachments: &[RenderPassColorAttachmentDescriptor {
                            attachment: &msaa_texture,
                            resolve_target: Some(display_texture),
                            load_op: LoadOp::Clear,
                            store_op: StoreOp::Store,
                            clear_color: Color::BLACK,
                        }],
                        depth_stencil_attachment: None,
                    });
                    render_pass.set_bind_group(0, &bind_group, &[]);
                    render_pass.set_pipeline(&pipeline);
                    render_pass.draw(0..6, 0..1);
                }
                queue.submit(&[encoder.finish()]);
            }
            Event::WindowEvent { event, .. } => match event {
                WindowEvent::CloseRequested => *control_flow = ControlFlow::Exit,
                WindowEvent::KeyboardInput { input, .. } => {
                    if input.state == ElementState::Pressed {
                        match input.virtual_keycode {
                            Some(VirtualKeyCode::Equals) => {
                                zoom_uniform.zoom *= 2.0;
                                let mut encoder =
                                    device.create_command_encoder(&CommandEncoderDescriptor {
                                        label: None,
                                    });
                                let staging_buffer = device.create_buffer_with_data(
                                    bytemuck::cast_slice(&[zoom_uniform]),
                                    BufferUsage::COPY_SRC,
                                );
                                encoder.copy_buffer_to_buffer(
                                    &staging_buffer,
                                    0,
                                    &zoom_uniform_buffer,
                                    0,
                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,
                                );
                                queue.submit(&[encoder.finish()]);
                            }
                            Some(VirtualKeyCode::Minus) => {
                                zoom_uniform.zoom /= 2.0;
                                if zoom_uniform.zoom < 1.0 {
                                    zoom_uniform.zoom = 1.0;
                                }
                                let mut encoder =
                                    device.create_command_encoder(&CommandEncoderDescriptor {
                                        label: None,
                                    });
                                let staging_buffer = device.create_buffer_with_data(
                                    bytemuck::cast_slice(&[zoom_uniform]),
                                    BufferUsage::COPY_SRC,
                                );
                                encoder.copy_buffer_to_buffer(
                                    &staging_buffer,
                                    0,
                                    &zoom_uniform_buffer,
                                    0,
                                    std::mem::size_of::<ZoomUniform>() as BufferAddress,
                                );
                                queue.submit(&[encoder.finish()]);
                            }
                            _ => {}
                        }
                    }
                }
                _ => {}
            },
            _ => {}
        }
    });
}
```


Overlapping Code:
```
sync fn run(event_loop: EventLoop<()>, window: Window) {
let surface = Surface::create(&window);
let adapter = Adapter::request(
&RequestAdapterOptions {
power_preference: PowerPreference::Default,
compatible_surface: Some(&surface),
},
BackendBit::PRIMARY,
)
.await
.unwrap();
let (device, queue) = adapter
.request_device(&DeviceDescriptor {
extensions: Extensions {
anisotropic_filtering: false,
},
limits: Limits::default(),
})
.await;
let mut screen_size = window.inner_size();
let mut swap_chain_descriptor = SwapChainDescriptor {
usage: TextureUsage::OUTPUT_ATTACHMENT,
format: TextureFormat::Bgra8Unorm,
width: screen_size.width,
height: screen_size.height,
present_mode: PresentMode::Mailbox,
};
let mut swap_chain = device.create_swap_chain(&surface, &swap_chain_descriptor);
let mut msaa_texture_descriptor = TextureDescriptor {
size: Extent3d {
width: screen_size.width,
height: screen_size.height,
depth: 1,
},
array_layer_count: 1,
mip_level_count: 1,
sample_count: 16,
dimension: TextureDimension::D2,
format: swap_chain_descriptor.format,
usage: TextureUsage::OUTPUT_ATTACHMENT,
label: None,
};
let mut msaa_texture = device
.create_texture(&msaa_texture_descriptor)
.create_default_view();
let vertex_shader = include_bytes!("../metaballs_vert.spv");
let vertex_shader = read_spirv(Cursor::new(&vertex_shader[..])).unwrap();
let vertex_shader = device.create_shader_module(&vertex_shader);
let fragment_shader = include_bytes!("../metaballs_frag.spv");
let fragment_shader = read_spirv(Cursor::new(&fragment_shader[..])).unwrap();
let fragment_shader = device.create_shader_module(&fragment_shader);
let time = Instant::now();
let mut time_uniform = TimeUniform {
time: time.elapsed().as_secs_f32(),
};
let time_uniform_buffer = device.create_buffer_with_data(
bytemuck::cast_slice(&[time_uniform]),
BufferUsage::UNIFORM | BufferUsage::COPY_DST,
);
let mut zoom_uniform = ZoomUniform { zoom: 1.0 };
let zoom_uniform_buffer = device.create_buffer_with_data(
bytemuck::cast_slice(&[zoom_uniform]),
BufferUsage::UNIFORM | BufferU
```
<Overlap Ratio: 0.9922292374939291>

---

--- 358 --
Question ID: fb01b7214c51652740b8248325ecb29abac26338_0
Original Code:
```
async fn _event(listeners: Listeners<Event>, event: Event) {
    let mut listeners = listeners.all().lock().await;
    let mut remove_listeners = Vec::new();

    // Take up to the last one so that we can later get the last and *move*
    // the event into the listener's channel, rather than clone it like we
    // do here.
    //
    // This avoids a clone, and for users with only 1 listener this will
    // entirely avoid cloning.
    let mut last = None;

    for (idx, (id, listener)) in listeners.iter().enumerate() {
        if idx == listeners.len() - 1 {
            last = Some(*id);

            break;
        }

        let event_type = event.event_type();

        if !listener.events.contains(event_type) {
            trace!(
                "[ShardProcessor] Listener {} doesn't want event type {:?}",
                id,
                event_type,
            );

            continue;
        }

        if !_emit_to_listener(*id, listener, event.clone()) {
            remove_listeners.push(*id);
        }
    }

    if let Some(id) = last {
        if let Some(listener) = listeners.get(&id) {
            if !_emit_to_listener(id, listener, event) {
                remove_listeners.push(id);
            }
        }
    }

    for id in &remove_listeners {
        debug!("[ShardProcessor] Removing listener {}", id);

        listeners.remove(id);
    }
}
```


Overlapping Code:
```
c fn _event(listeners: Listeners<Event>, event: Event) {
let mut listeners = listeners.all().lock().await;
let mut remove_listeners = Vec::new();
// Take up to the last one so that we can later get the last and *move*
// the event into the listener's channel, rather than clone it like we
// do here.
//
// This avoids a clone, and for users with only 1 listener this will
// entirely avoid cloning.
let mut last = None;
for (idx, (id, listener)) in listeners.iter().enumerate() {
if idx == listeners.len() - 1 {
last = Some(*id);
break;
}
let event_type = event.event_type();
if !listener.events.contains(event_type) {
trace!(
"[ShardProcessor] Listener {} doesn't want event type {:?}",
id,
event_type,
);
continue;
}
if !_emit_to_listener(*id, listener, event.clone()) {
remove_listeners.push(*id);
}
}
if let Some(id) = last {
if let Some(listener) = listeners.get(&id) {
if !_emit_to_listener(id, listener, event) {
remove_listeners.push(id);
}
}
}
for id in &remove_listeners {
debug!("[ShardProcessor] Removing listener {}", id);
listeners.rem
```
<Overlap Ratio: 0.9849906191369606>

---

--- 359 --
Question ID: c14635494da02a8f75fa1e12483eaa3aa6eb05a4_0
Original Code:
```
pub(crate) async fn local_data_helper(
    ctx: Context,
    url: Url,
    shared_args: SharedArguments<Unverified>,
    source_args: SourceArguments<Unverified>,
) -> Result<Option<BoxStream<CsvStream>>> {
    let _shared_args = shared_args.verify(GsLocator::features())?;
    let _source_args = source_args.verify(GsLocator::features())?;
    debug!("getting CSV files from {}", url);

    let file_urls = storage::ls(&ctx, &url).await?;

    let csv_streams = file_urls.and_then(move |item| {
        let url = url.clone();
        async move {
            // Stream the file from the cloud.
            let file_url = item.to_url_string();
            let name = csv_stream_name(url.as_str(), &file_url)?;
            let data = storage::download_file(&item)
                .instrument(trace_span!("stream_from_gs", stream = %name))
                .await?;

            // Assemble everything into a CSV stream.
            Ok(CsvStream {
                name: name.to_owned(),
                data,
            })
        }
        .boxed()
    });

    Ok(Some(csv_streams.boxed()))
}
```


Overlapping Code:
```
(crate) async fn local_data_helper(
ctx: Context,
url: Url,
shared_args: SharedArguments<Unverified>,
source_args: SourceArguments<Unverified>,
) -> Result<Option<BoxStream<CsvStream>>> {
let _shared_args = shared_args.verify(GsLocator::features())?;
let _source_args = source_args.verify(GsLocator::features())?;
debug!("getting CSV files from {}", url);
let file_urls = storage::ls(&ctx, &url).await?;
let csv_streams = file_urls.and_then(move |item| {
let url = url.clone();
async move {
// Stream the file from the cloud.
let file_url = item.to_url_string();
let name = csv_stream_name(url.as_str(), &file_url)?;
let data = storage::download_file(&item)
.instrument(trace_span!("stream_from_gs", stream = %name))
.await?;
// Assemble everything into a CSV stream.
Ok(CsvStream {
name: name.to_owned(),
data,
})
}
.boxed()
}
```
<Overlap Ratio: 0.9571759259259259>

---

--- 360 --
Question ID: 587de4efbea5c97b02c5aa9942f9045a64223ae0_9
Original Code:
```
fn into_weighted_edge() {
        // Test with tuple.
        assert_eq!((1, 2).into_weighted_edge(), (1, 2, f32::default()));

        // Test with triple.
        assert_eq!((1, 2, 3).into_weighted_edge(), (1, 2, 3));

        // Test with triple having edge weight as reference.
        assert_eq!((1, 2, &3).into_weighted_edge(), (1, 2, 3));

        // Test with tuple as reference.
        assert_eq!((&(1, 2)).into_weighted_edge(), (1, 2, f32::default()));

        // Test with triple as reference.
        assert_eq!((&(1, 2, 3)).into_weighted_edge(), (1, 2, 3));
    }
```


Overlapping Code:
```
ssert_eq!((1, 2).into_weighted_edge(), (1, 2, f32::default()));
// Test with triple.
assert_eq!((1, 2, 3).into_weighted_edge(), (1, 2, 3));
// Test with triple having edge weight as reference.
assert_eq!((1, 2, &3).into_weighted_edge(), (1, 2, 3));
// Test with tuple as reference.
assert_eq!((&(1, 2)).into_weighted_edge(), (1, 2, f32::default()));
// Test with triple as reference.
assert_eq!((&(1,
```
<Overlap Ratio: 0.8163265306122449>

---

--- 361 --
Question ID: 7be2eacee42da78055b3ef170b5fa91fd4bef5bd_1
Original Code:
```
fn it_has_windows_installer() {
    let windows_installer_path = get_binstall_scripts_root()
        .join("windows")
        .join("install.ps1");
    let windows_script = fs::read_to_string(&windows_installer_path)
        .expect("Could not read windows installer script");
    assert!(!windows_script.is_empty())
}
```


Overlapping Code:
```
et windows_installer_path = get_binstall_scripts_root()
.join("windows")
.join("install.ps1");
let windows_script = fs::read_to_string(&windows_installer_path)
.expect("Could not read windows installe
```
<Overlap Ratio: 0.7092198581560284>

---

--- 362 --
Question ID: f401d58f942ac67fe1a55447e3659714a798c8ff_20
Original Code:
```
pub fn sp_write(newval: u64) {
    // bits 3..3
    let val = reg_rawrd();
    reg_rawwr(val & !(0x1 << 3) | ((newval & 0x1) << 3));
}
```


Overlapping Code:
```
e(newval: u64) {
// bits 3..3
let val = reg_rawrd();
reg_rawwr(val & !(0x1 << 3) | ((newval & 0x1) << 3))
```
<Overlap Ratio: 0.860655737704918>

---

--- 363 --
Question ID: f36293d646d0388e8ab67dec3255bee342cf2802_1
Original Code:
```
fn generate_hash(server_id: &str, shared_secret: &[u8], public_key: &[u8]) -> String {
        let mut sha1 = Sha1::new();
        sha1.update(server_id.as_bytes());
        sha1.update(shared_secret);
        sha1.update(public_key);
        finish_hash(sha1)
    }
```


Overlapping Code:
```
server_id: &str, shared_secret: &[u8], public_key: &[u8]) -> String {
let mut sha1 = Sha1::new();
sha1.update(server_id.as_bytes());
sha1.update(shared_secret);
sha1.update(public_key);
finish_hash(sh
```
<Overlap Ratio: 0.9009009009009009>

---

--- 364 --
Question ID: 114bebab9763c771b32c9f9028a6f983098f6429_0
Original Code:
```
fn main() {
    let app = Server::new(|_request, mut response| {
        let motivation = templates::motivation();
        Ok(response.header("Content-Type", "text/html; charset=utf-8").body(motivation)?)
    });
 
    let host = "0.0.0.0";
    let port = get_server_port();
    let address = format!("{}:{}", host, port);

    println!("* Running on http://{}", address);
    app.listen(host, &port);
}
```


Overlapping Code:
```
 app = Server::new(|_request, mut response| {
let motivation = templates::motivation();
Ok(response.header("Content-Type", "text/html; charset=utf-8").body(motivation)?)
});

let host = "0.0.0.0";
let port = get_server_port();
let address = format!("{}:{}", host, port);
println!("* Running on http://{}", address);
app.
```
<Overlap Ratio: 0.896358543417367>

---

--- 365 --
Question ID: 7b614ef4b62ab4bfee944759a60885f347c6a719_51
Original Code:
```
pub async fn update_source_control(
    operation_config: &crate::OperationConfig,
    source_control_type: &str,
    request_message: &models::SourceControl,
) -> std::result::Result<models::SourceControl, update_source_control::Error> {
    let http_client = operation_config.http_client();
    let url_str = &format!(
        "{}/providers/Microsoft.Web/sourcecontrols/{}",
        operation_config.base_path(),
        source_control_type
    );
    let mut url = url::Url::parse(url_str).map_err(update_source_control::Error::ParseUrlError)?;
    let mut req_builder = http::request::Builder::new();
    req_builder = req_builder.method(http::Method::PUT);
    if let Some(token_credential) = operation_config.token_credential() {
        let token_response = token_credential
            .get_token(operation_config.token_credential_resource())
            .await
            .map_err(update_source_control::Error::GetTokenError)?;
        req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
    }
    url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
    req_builder = req_builder.header("content-type", "application/json");
    let req_body = azure_core::to_json(request_message).map_err(update_source_control::Error::SerializeError)?;
    req_builder = req_builder.uri(url.as_str());
    let req = req_builder
        .body(req_body)
        .map_err(update_source_control::Error::BuildRequestError)?;
    let rsp = http_client
        .execute_request(req)
        .await
        .map_err(update_source_control::Error::ExecuteRequestError)?;
    match rsp.status() {
        http::StatusCode::OK => {
            let rsp_body = rsp.body();
            let rsp_value: models::SourceControl = serde_json::from_slice(rsp_body)
                .map_err(|source| update_source_control::Error::DeserializeError(source, rsp_body.clone()))?;
            Ok(rsp_value)
        }
        status_code => {
            let rsp_body = rsp.body();
            Err(update_source_control::Error::UnexpectedResponse {
                status_code,
                body: rsp_body.clone(),
            })
        }
    }
}
```


Overlapping Code:
```
urce_control(
operation_config: &crate::OperationConfig,
source_control_type: &str,
request_message: &models::SourceControl,
) -> std::result::Result<models::SourceControl, update_source_control::Error> {
let http_client = operation_config.http_client();
let url_str = &format!(
"{}/providers/Microsoft.Web/sourcecontrols/{}",
operation_config.base_path(),
source_control_type
);
let mut url = url::Url::parse(url_str).map_err(update_source_control::Error::ParseUrlError)?;
let mut req_builder = http::request::Builder::new();
req_builder = req_builder.method(http::Method::PUT);
if let Some(token_credential) = operation_config.token_credential() {
let token_response = token_credential
.get_token(operation_config.token_credential_resource())
.await
.map_err(update_source_control::Error::GetTokenError)?;
req_builder = req_builder.header(http::header::AUTHORIZATION, format!("Bearer {}", token_response.token.secret()));
}
url.query_pairs_mut().append_pair("api-version", super::API_VERSION);
req_builder = req_builder.header("content-type", "application/json");
let req_body = azure_core::to_json(request_message).map_err(update_source_control::Error::SerializeError)?;
req_builder = req_builder.uri(url.as_str());
let req = req_builder
.body(req_body)
.map_err(update_source_control::Error::BuildRequestError)?;
let rsp = http_client
.execute_request(req)
.await
.map_err(update_source_control::Error::ExecuteRequestError)?;
match rsp.status() {
http::StatusCode::OK => {
let rsp_body = rsp.body();
let rsp_value: models::SourceControl = serde_json::from_slice(rsp_body)
.map_err(|source| update_source_control::Error::DeserializeError(source, rsp_body.clone()))?;
Ok(rsp_value)
}
status_code => {
let rsp_body = rsp.body();
Err(update_source_control::Error::UnexpectedResponse {
status_code,
body: rsp_body.clone(),
})
}
}
}
```
<Overlap Ratio: 0.9881209503239741>

---

--- 366 --
Question ID: a8f9000b36f8219f3b50c55ce44197b58c095f5a_0
Original Code:
```
async fn new_(depot: &mut Depot, res: &mut Response) {
    let mut web = depot.remove::<Context>(WEB).unwrap();

    match Tags::view_list_tag().await {
        Ok(tags_) => web.insert("tags", &tags_),
        Err(e) => tracing::info!("can't find tags with: {:?}", e),
    }

    render(res, "admin/article_new.html", &web);
}
```


Overlapping Code:
```
ot, res: &mut Response) {
let mut web = depot.remove::<Context>(WEB).unwrap();
match Tags::view_list_tag().await {
Ok(tags_) => web.insert("tags", &tags_),
Err(e) => tracing::info!("can't find tags with: {:?}", e),
}
render(res, "admin/article_new.ht
```
<Overlap Ratio: 0.8561643835616438>

---

--- 367 --
Question ID: 292d7b383856fd9f963ff32ee3fe69a51b1f2e71_4
Original Code:
```
fn chain_without_skips() {
        let n: usize = 10;
        let store = MemoryStore::open();
        let spec = MinimalEthSpec::default_spec();

        let slots: Vec<usize> = (0..n).collect();
        let blocks_and_roots = build_chain(&store, &slots, &spec);

        for source in 1..n {
            for target in 0..=source {
                let (source_root, _source_block) = &blocks_and_roots[source];
                let (target_root, target_block) = &blocks_and_roots[target];

                let (found_root, found_block) = store
                    .get_block_at_preceeding_slot(*source_root, target_block.slot)
                    .unwrap()
                    .unwrap();

                assert_eq!(found_root, *target_root);
                assert_eq!(found_block, *target_block);
            }
        }
    }
```


Overlapping Code:
```

let n: usize = 10;
let store = MemoryStore::open();
let spec = MinimalEthSpec::default_spec();
let slots: Vec<usize> = (0..n).collect();
let blocks_and_roots = build_chain(&store, &slots, &spec);
for source in 1..n {
for target in 0..=source {
let (source_root, _source_block) = &blocks_and_roots[source];
let (target_root, target_block) = &blocks_and_roots[target];
let (found_root, found_block) = store
.get_block_at_preceeding_slot(*source_root, target_block.slot)
.unwrap()
.unwrap();
assert_eq!(found_root, *target_root);
assert_eq!(found_block
```
<Overlap Ratio: 0.9181969949916527>

---

--- 368 --
Question ID: f4ea981c0063b63bca8a9d5ffc2c44aa0fbd5ad5_11
Original Code:
```
fn test_error_helpers() {
        let r: HttpResponse = ErrorBadRequest("err").into();
        assert_eq!(r.status(), StatusCode::BAD_REQUEST);

        let r: HttpResponse = ErrorUnauthorized("err").into();
        assert_eq!(r.status(), StatusCode::UNAUTHORIZED);

        let r: HttpResponse = ErrorPaymentRequired("err").into();
        assert_eq!(r.status(), StatusCode::PAYMENT_REQUIRED);

        let r: HttpResponse = ErrorForbidden("err").into();
        assert_eq!(r.status(), StatusCode::FORBIDDEN);

        let r: HttpResponse = ErrorNotFound("err").into();
        assert_eq!(r.status(), StatusCode::NOT_FOUND);

        let r: HttpResponse = ErrorMethodNotAllowed("err").into();
        assert_eq!(r.status(), StatusCode::METHOD_NOT_ALLOWED);

        let r: HttpResponse = ErrorNotAcceptable("err").into();
        assert_eq!(r.status(), StatusCode::NOT_ACCEPTABLE);

        let r: HttpResponse = ErrorProxyAuthenticationRequired("err").into();
        assert_eq!(r.status(), StatusCode::PROXY_AUTHENTICATION_REQUIRED);

        let r: HttpResponse = ErrorRequestTimeout("err").into();
        assert_eq!(r.status(), StatusCode::REQUEST_TIMEOUT);

        let r: HttpResponse = ErrorConflict("err").into();
        assert_eq!(r.status(), StatusCode::CONFLICT);

        let r: HttpResponse = ErrorGone("err").into();
        assert_eq!(r.status(), StatusCode::GONE);

        let r: HttpResponse = ErrorLengthRequired("err").into();
        assert_eq!(r.status(), StatusCode::LENGTH_REQUIRED);

        let r: HttpResponse = ErrorPreconditionFailed("err").into();
        assert_eq!(r.status(), StatusCode::PRECONDITION_FAILED);

        let r: HttpResponse = ErrorPayloadTooLarge("err").into();
        assert_eq!(r.status(), StatusCode::PAYLOAD_TOO_LARGE);

        let r: HttpResponse = ErrorUriTooLong("err").into();
        assert_eq!(r.status(), StatusCode::URI_TOO_LONG);

        let r: HttpResponse = ErrorUnsupportedMediaType("err").into();
        assert_eq!(r.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);

        let r: HttpResponse = ErrorRangeNotSatisfiable("err").into();
        assert_eq!(r.status(), StatusCode::RANGE_NOT_SATISFIABLE);

        let r: HttpResponse = ErrorExpectationFailed("err").into();
        assert_eq!(r.status(), StatusCode::EXPECTATION_FAILED);

        let r: HttpResponse = ErrorImATeapot("err").into();
        assert_eq!(r.status(), StatusCode::IM_A_TEAPOT);

        let r: HttpResponse = ErrorMisdirectedRequest("err").into();
        assert_eq!(r.status(), StatusCode::MISDIRECTED_REQUEST);

        let r: HttpResponse = ErrorUnprocessableEntity("err").into();
        assert_eq!(r.status(), StatusCode::UNPROCESSABLE_ENTITY);

        let r: HttpResponse = ErrorLocked("err").into();
        assert_eq!(r.status(), StatusCode::LOCKED);

        let r: HttpResponse = ErrorFailedDependency("err").into();
        assert_eq!(r.status(), StatusCode::FAILED_DEPENDENCY);

        let r: HttpResponse = ErrorUpgradeRequired("err").into();
        assert_eq!(r.status(), StatusCode::UPGRADE_REQUIRED);

        let r: HttpResponse = ErrorPreconditionRequired("err").into();
        assert_eq!(r.status(), StatusCode::PRECONDITION_REQUIRED);

        let r: HttpResponse = ErrorTooManyRequests("err").into();
        assert_eq!(r.status(), StatusCode::TOO_MANY_REQUESTS);

        let r: HttpResponse = ErrorRequestHeaderFieldsTooLarge("err").into();
        assert_eq!(r.status(), StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE);

        let r: HttpResponse = ErrorUnavailableForLegalReasons("err").into();
        assert_eq!(r.status(), StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS);

        let r: HttpResponse = ErrorInternalServerError("err").into();
        assert_eq!(r.status(), StatusCode::INTERNAL_SERVER_ERROR);

        let r: HttpResponse = ErrorNotImplemented("err").into();
        assert_eq!(r.status(), StatusCode::NOT_IMPLEMENTED);

        let r: HttpResponse = ErrorBadGateway("err").into();
        assert_eq!(r.status(), StatusCode::BAD_GATEWAY);

        let r: HttpResponse = ErrorServiceUnavailable("err").into();
        assert_eq!(r.status(), StatusCode::SERVICE_UNAVAILABLE);

        let r: HttpResponse = ErrorGatewayTimeout("err").into();
        assert_eq!(r.status(), StatusCode::GATEWAY_TIMEOUT);

        let r: HttpResponse = ErrorHttpVersionNotSupported("err").into();
        assert_eq!(r.status(), StatusCode::HTTP_VERSION_NOT_SUPPORTED);

        let r: HttpResponse = ErrorVariantAlsoNegotiates("err").into();
        assert_eq!(r.status(), StatusCode::VARIANT_ALSO_NEGOTIATES);

        let r: HttpResponse = ErrorInsufficientStorage("err").into();
        assert_eq!(r.status(), StatusCode::INSUFFICIENT_STORAGE);

        let r: HttpResponse = ErrorLoopDetected("err").into();
        assert_eq!(r.status(), StatusCode::LOOP_DETECTED);

        let r: HttpResponse = ErrorNotExtended("err").into();
        assert_eq!(r.status(), StatusCode::NOT_EXTENDED);

        let r: HttpResponse = ErrorNetworkAuthenticationRequired("err").into();
        assert_eq!(r.status(), StatusCode::NETWORK_AUTHENTICATION_REQUIRED);
    }
```


Overlapping Code:
```
helpers() {
let r: HttpResponse = ErrorBadRequest("err").into();
assert_eq!(r.status(), StatusCode::BAD_REQUEST);
let r: HttpResponse = ErrorUnauthorized("err").into();
assert_eq!(r.status(), StatusCode::UNAUTHORIZED);
let r: HttpResponse = ErrorPaymentRequired("err").into();
assert_eq!(r.status(), StatusCode::PAYMENT_REQUIRED);
let r: HttpResponse = ErrorForbidden("err").into();
assert_eq!(r.status(), StatusCode::FORBIDDEN);
let r: HttpResponse = ErrorNotFound("err").into();
assert_eq!(r.status(), StatusCode::NOT_FOUND);
let r: HttpResponse = ErrorMethodNotAllowed("err").into();
assert_eq!(r.status(), StatusCode::METHOD_NOT_ALLOWED);
let r: HttpResponse = ErrorNotAcceptable("err").into();
assert_eq!(r.status(), StatusCode::NOT_ACCEPTABLE);
let r: HttpResponse = ErrorProxyAuthenticationRequired("err").into();
assert_eq!(r.status(), StatusCode::PROXY_AUTHENTICATION_REQUIRED);
let r: HttpResponse = ErrorRequestTimeout("err").into();
assert_eq!(r.status(), StatusCode::REQUEST_TIMEOUT);
let r: HttpResponse = ErrorConflict("err").into();
assert_eq!(r.status(), StatusCode::CONFLICT);
let r: HttpResponse = ErrorGone("err").into();
assert_eq!(r.status(), StatusCode::GONE);
let r: HttpResponse = ErrorLengthRequired("err").into();
assert_eq!(r.status(), StatusCode::LENGTH_REQUIRED);
let r: HttpResponse = ErrorPreconditionFailed("err").into();
assert_eq!(r.status(), StatusCode::PRECONDITION_FAILED);
let r: HttpResponse = ErrorPayloadTooLarge("err").into();
assert_eq!(r.status(), StatusCode::PAYLOAD_TOO_LARGE);
let r: HttpResponse = ErrorUriTooLong("err").into();
assert_eq!(r.status(), StatusCode::URI_TOO_LONG);
let r: HttpResponse = ErrorUnsupportedMediaType("err").into();
assert_eq!(r.status(), StatusCode::UNSUPPORTED_MEDIA_TYPE);
let r: HttpResponse = ErrorRangeNotSatisfiable("err").into();
assert_eq!(r.status(), StatusCode::RANGE_NOT_SATISFIABLE);
let r: HttpResponse = ErrorExpectationFailed("err").into();
assert_eq!(r.status(), StatusCode::EXPECTATION_FAILED);
let r: HttpResponse = ErrorImATeapot("err").into();
assert_eq!(r.status(), StatusCode::IM_A_TEAPOT);
let r: HttpResponse = Er
```
<Overlap Ratio: 0.9768839574664817>

---

--- 369 --
Question ID: 1f90815901232e23886b4e9b6e8a7e53b984794b_0
Original Code:
```
fn test_irregular() {
        let epsilon = 0.0001;

        let points = vec![
            Tup { x: 12.0, y: 0.0 },
            Tup { x: 14.0, y: 0.4 },
            Tup { x: 16.0, y: 0.4 }, // this point is redundant
            Tup { x: 20.0, y: 0.4 },
            Tup { x: 30.0, y: 0.7 },
            Tup { x: 13.0, y: 0.0 }, // This point is out-of-order within the Vec, but in-order regaring x and y
            Tup { x: 40.0, y: 1.0 },
        ];
        let mut c = IrregularDynamicCurve::<f32, f32>::new(points);

        // Test x bounds
        assert_eq!(c.min_x(), 12.0);
        assert_eq!(c.max_x(), 40.0);

        // Test x outside of bounds
        assert_eq!(c.y_at_x(0.0), 0.0);
        assert_eq!(c.y_at_x(100.0), 1.0);

        // Test x equal to the actual points
        assert_approx_eq!(c.y_at_x(12.0), 0.0, epsilon);
        assert_approx_eq!(c.y_at_x(13.0), 0.0, epsilon);
        assert_approx_eq!(c.y_at_x(14.0), 0.4, epsilon);
        assert_approx_eq!(c.y_at_x(40.0), 1.0, epsilon);

        // Test arbitrary "integer" x values
        assert_approx_eq!(c.y_at_x(25.0), 0.55, epsilon);
        assert_approx_eq!(c.y_at_x(35.0), 0.85, epsilon);
    
        // Test arbitrary "float" x values
        assert_approx_eq!(c.y_at_x(13.5), 0.2, epsilon);
        assert_approx_eq!(c.y_at_x(15.5), 0.4, epsilon);
    
        // Test y queries
        assert_approx_eq!(c.x_at_y(0.0), 12.0, epsilon);
        assert_approx_eq!(c.x_at_y(1.0), 40.0, epsilon);
        assert!(c.x_at_y(0.4) >= 14.0);
        assert!(c.x_at_y(0.4) <= 20.0);
        assert_approx_eq!(c.x_at_y(0.7), 30.0, epsilon);
        
        assert_approx_eq!(c.x_at_y(0.2), 13.5, epsilon);

        c.add_point(35.0, 0.9);
        assert_approx_eq!(c.y_at_x(35.0), 0.9, epsilon);
        assert_approx_eq!(c.y_at_x(32.5), 0.8, epsilon);

        // let mut fg = Figure::new();
        // let axes = fg.axes2d();
        
        assert_eq!(c.len(), 8);
        //let c_plot = c.get_values_as_vectors();
        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption("C original"), Color("grey")]);

        c.simplify(0.0);
        assert_eq!(c.len(), 7); // should only remove the redundant point
        // TODO if the curve begins with multuple 0.0 values or ends with mutluple 0.1 
        
        //let c_plot = c.get_values_as_vectors();
        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption("C pseudo-simplified"), Color("black")]);

        c.simplify(0.1);
        assert!(c.len() < 7); // should remove at least one more point

        //let c_plot = c.get_values_as_vectors();
        // axes.lines_points(&c_plot.0, &c_plot.1, &[Caption("C simplified"), Color("red")]);

        // fg.show();
    }
```


Overlapping Code:
```
 epsilon = 0.0001;
let points = vec![
Tup { x: 12.0, y: 0.0 },
Tup { x: 14.0, y: 0.4 },
Tup { x: 16.0, y: 0.4 }, // this point is redundant
Tup { x: 20.0, y: 0.4 },
Tup { x: 30.0, y: 0.7 },
Tup { x: 13.0, y: 0.0 }, // This point is out-of-order within the Vec, but in-order regaring x and y
Tup { x: 40.0, y: 1.0 },
];
let mut c = IrregularDynamicCurve::<f32, f32>::new(points);
// Test x bounds
assert_eq!(c.min_x(), 12.0);
assert_eq!(c.max_x(), 40.0);
// Test x outside of bounds
assert_eq!(c.y_at_x(0.0), 0.0);
assert_eq!(c.y_at_x(100.0), 1.0);
// Test x equal to the actual points
assert_approx_eq!(c.y_at_x(12.0), 0.0, epsilon);
assert_approx_eq!(c.y_at_x(13.0), 0.0, epsilon);
assert_approx_eq!(c.y_at_x(14.0), 0.4, epsilon);
assert_approx_eq!(c.y_at_x(40.0), 1.0, epsilon);
// Test arbitrary "integer" x values
assert_approx_eq!(c.y_at_x(25.0), 0.55, epsilon);
assert_approx_eq!(c.y_at_x(35.0), 0.85, epsilon);

// Test arbitrary "float" x values
assert_approx_eq!(c.y_at_x(13.5), 0.2, epsilon);
assert_approx_eq!(c.y_at_x(15.5), 0.4, epsilon);

// Test y queries
assert_approx_eq!(c.x_at_y(0.0), 12.0, epsilon);
assert_approx_eq!(c.x_at_y(1.0), 40.0, epsilon);
assert!(c.x_at_y(0.4) >= 14.0);
assert!(c.x_at_y(0.4) <= 20.0);
assert_approx_eq!(c.x_at_y(0.7), 30.0, epsilon);

assert_approx_eq!(c.x_at_y(0.2), 13.5, epsilon);
c.add_point(35.0, 0.9);
assert_approx_eq!(c.y_at_x(35.0), 0.9, epsilon);
assert_approx_eq!(c.y_at_x(32.5), 0.8, epsilon);
// let mut fg = Figure::new();
// let axes = fg.axes2d();

assert_eq!(c.len(), 8);
//let c_plot = c.get_values_as_vectors();
// axes.lines_points(&c_plot.0, &c_plot.1, &[Caption("C original"), Color("grey")]);
c.simplify(0.0);
assert_eq!(c.len(), 7); // should only remove the redundant point
// TODO if the curve begins with multuple 0.0 values or ends with mutluple 0.1 

//let c_plot = c.get_values_as_vectors();
// axes.lines_points(&c_plot.0, &c_plot.1, &[Caption("C pseudo-simplified"), Color("black")]);
c.simplify(0.1);
assert!(c.len() < 
```
<Overlap Ratio: 0.9852216748768473>

---

--- 370 --
Question ID: a34e87b5fe91e1353db3e23988ce555e4e970446_1
Original Code:
```
fn test_deduplication() {
        let store = Arc::new(SqliteStore::new(":memory:").unwrap());
        let root_ref = DurableTree::create(store.clone(), NumComparator).unwrap().root;
        let index = Index::new(root_ref, store, NumComparator)
            .insert(1)
            .insert(2)
            .insert(2)
            .insert(3);

        assert_equal(index.range_from(1), 1..4)
    }
```


Overlapping Code:
```
{
let store = Arc::new(SqliteStore::new(":memory:").unwrap());
let root_ref = DurableTree::create(store.clone(), NumComparator).unwrap().root;
let index = Index::new(root_ref, store, NumComparator)
.insert(1)
.insert(2)
.insert(2)
.insert(3);
assert_eq
```
<Overlap Ratio: 0.8181818181818182>

---

--- 371 --
Question ID: 595052fe31465e8ff5b737b3569a1d9f92cd12c4_1
Original Code:
```
fn camera(distance: f32) -> ArcBall
{
  let eye = Point3::new(0.0, 0.0, distance);
  let at = Point3::origin();
  return ArcBall::new(eye, at);
}
```


Overlapping Code:
```
) -> ArcBall
{
let eye = Point3::new(0.0, 0.0, distance);
let at = Point3::origin();
return ArcBall:
```
<Overlap Ratio: 0.7194244604316546>

---

--- 372 --
Question ID: b23afc0340fb18d1a743462e609051c3d0abbc27_0
Original Code:
```
fn find_commits_in_range(repo: &Repository, start: git2::Oid, end: git2::Oid) -> Vec<Commit> {
    let mut commits: Vec<Commit> = Vec::new();
    // list recent commits
    let mut revwalk = repo.revwalk().expect("Failed to get revwalk");

    // left commit is hidden and right commit is shown.
    let range = format!("{}..{}", end, start);
    revwalk.push_range(&range[..]).expect("Failed to push range");

    for oid in revwalk {
        let oid = oid.expect("Failed to get oid");
        let commit = repo.find_commit(oid).expect("Failed to find the commit");
        commits.push(commit);
    }

    commits
}
```


Overlapping Code:
```
fn find_commits_in_range(repo: &Repository, start: git2::Oid, end: git2::Oid) -> Vec<Commit> {
let mut commits: Vec<Commit> = Vec::new();
// list recent commits
let mut revwalk = repo.revwalk().expect("Failed to get revwalk");
// left commit is hidden and right commit is shown.
let range = format!("{}..{}", end, start);
revwalk.push_range(&range[..]).expect("Failed to push range");
for oid in revwalk {
let oid = oid.expect("Failed to get oid");
let commit = repo.find_commit(oid).expect("Failed to find the commit");
commits.push(commit);
}
commi
```
<Overlap Ratio: 0.9927797833935018>

---

--- 373 --
Question ID: b277ed30c270a78437515a2b34f644a6c6eb1844_32
Original Code:
```
fn jmp_not_eq() {
        let mut mem = Memory::new(14);
        mem.set_u8(0, instruction::MOVE_LIT_REG.opcode);
        mem.set_u16(1, 0x1234);
        mem.set_u8(3, register::ACC as u8);
        mem.set_u8(4, instruction::JNE_LIT_MEM.opcode);
        mem.set_u16(5, 0x1234);
        mem.set_u16(7, 0x0);
        mem.set_u8(9, instruction::JNE_LIT_MEM.opcode);
        mem.set_u16(10, 0x12AB);
        mem.set_u16(12, 0x2);

        let mut cpu = CPU::new(Box::new(mem));
        cpu.step();
        assert_eq!(cpu.get_register(register::ACC), 0x1234);
        cpu.step();
        assert_eq!(cpu.get_register(register::IP), 0x9);
        cpu.step();
        assert_eq!(cpu.get_register(register::IP), 0x2);
    }
```


Overlapping Code:
```
emory::new(14);
mem.set_u8(0, instruction::MOVE_LIT_REG.opcode);
mem.set_u16(1, 0x1234);
mem.set_u8(3, register::ACC as u8);
mem.set_u8(4, instruction::JNE_LIT_MEM.opcode);
mem.set_u16(5, 0x1234);
mem.set_u16(7, 0x0);
mem.set_u8(9, instruction::JNE_LIT_MEM.opcode);
mem.set_u16(10, 0x12AB);
mem.set_u16(12, 0x2);
let mut cpu = CPU::new(Box::new(mem));
cpu.step();
assert_eq!(cpu.get_register(register::ACC), 0x1234);
cpu.step();
assert_eq!(cpu.get_register(register::IP), 0x9);
cpu.step();
assert_eq!(cpu.get_register(register::
```
<Overlap Ratio: 0.9214659685863874>

---

--- 374 --
Question ID: 1a7bd68e9dd578cc962b00f9049ccb88792a8a01_10
Original Code:
```
fn test_verkey_from_qualified_address() {
        let verkey = gen_random_base58_verkey();
        let address = qualified_address_from_verkey(&verkey).unwrap();
        let result = validate_address(&address);
        let verkey_extracted = result.unwrap();
        assert_eq!(verkey_extracted, verkey);
    }
```


Overlapping Code:
```
d_address() {
let verkey = gen_random_base58_verkey();
let address = qualified_address_from_verkey(&verkey).unwrap();
let result = validate_address(&address);
let verkey_extracted = result.unwrap();
asse
```
<Overlap Ratio: 0.7631578947368421>

---

--- 375 --
Question ID: 74b154db2512ce302700a7de694b2faf7d8ee6c7_4
Original Code:
```
fn after_mount(url: Url, orders: &mut impl Orders<Msg>) -> AfterMount<Model> {
    // try to rehydrate stored jwt
    orders.send_msg(Msg::Rehydrate);
    let mut m: Model = Default::default();

    // same code as `routes`
    if url.path.is_empty() {
        m.page = Pages::Home;
    }

    m.page = match url.path[0].as_ref() {
        "meals" => match url.path.get(1).as_ref() {
            Some(page) => match page.as_ref() {
                "create" => Pages::CreateMeal,
                _ => match page.parse::<Uuid>() {
                    Ok(m_id) => match url.path.get(2).as_ref() {
                        Some(i) => match i.as_ref() {
                            "edit" => Pages::EditMeal { meal_id: m_id },
                            _ => Pages::ViewSpecificMeal { meal_id: m_id },
                        },
                        None => Pages::ViewSpecificMeal { meal_id: m_id },
                    },
                    Err(_) => Pages::Meals,
                },
            },
            None => Pages::Meals,
        },
        "login" => Pages::Login,
        _ => Pages::Home,
    };

    // This duplicates requests on a new page load or refresh. Figure out why.
    // orders.send_msg(routes(url).unwrap());
    AfterMount::new(m)
}
```


Overlapping Code:
```
rl, orders: &mut impl Orders<Msg>) -> AfterMount<Model> {
// try to rehydrate stored jwt
orders.send_msg(Msg::Rehydrate);
let mut m: Model = Default::default();
// same code as `routes`
if url.path.is_empty() {
m.page = Pages::Home;
}
m.page = match url.path[0].as_ref() {
"meals" => match url.path.get(1).as_ref() {
Some(page) => match page.as_ref() {
"create" => Pages::CreateMeal,
_ => match page.parse::<Uuid>() {
Ok(m_id) => match url.path.get(2).as_ref() {
Some(i) => match i.as_ref() {
"edit" => Pages::EditMeal { meal_id: m_id },
_ => Pages::ViewSpecificMeal { meal_id: m_id },
},
None => Pages::ViewSpecificMeal { meal_id: m_id },
},
Err(_) => Pages::Meals,
},
},
None => Pages::Meals,
},
"login" => Pages::Login,
_ => Pages::Home,
};
// This duplicates requests on a new page load or refresh. Figure out why.
// orders.send_msg(routes(url).
```
<Overlap Ratio: 0.9423503325942351>

---

--- 376 --
Question ID: 80fa18313a8e7a9ec805fe85d9ad56f76fee9834_1
Original Code:
```
pub fn get_skill_name_on_skillbar(ecs: &World, index: usize) -> Option<String> {
    let skills_component = ecs.read_storage::<SkillsComponent>();
    let skills = &skills_component.grab(find_player(&ecs)).skills;
    skills.get(index).map(|s| get_current_skill_on_skillbar(ecs, s))
}
```


Overlapping Code:
```
et_skill_name_on_skillbar(ecs: &World, index: usize) -> Option<String> {
let skills_component = ecs.read_storage::<SkillsComponent>();
let skills = &skills_component.grab(find_player(&ecs)).skills;
skills.get(index).map(|s| get_current_skill_on_skill
```
<Overlap Ratio: 0.9191176470588235>

---

--- 377 --
Question ID: fa4775d1e69a995dad314f27ae74b7183b9a6144_3
Original Code:
```
fn try_from_degrees_works_with_180_as_input() {
        let degrees = 180.0;
        let radians = Radians::try_from_degrees(degrees).unwrap();
        let expected = PI;
        assert_nearly_eq!(expected, radians.value())
    }
```


Overlapping Code:
```
m_degrees_works_with_180_as_input() {
let degrees = 180.0;
let radians = Radians::try_from_degrees(degrees).unwrap();
let expected = PI;
assert_nearly
```
<Overlap Ratio: 0.7772020725388601>

---

--- 378 --
Question ID: 740b6f7e0e1fa9f5e293e0d3be76047f420fc794_47
Original Code:
```
fn insert_axis_f() {
    defmac!(test_insert_f orig, index, new => {
        let res = orig.insert_axis(Axis(index));
        assert_eq!(res, new);
        assert!(res.t().is_standard_layout());
    });

    test_insert_f!(Array0::from_shape_vec(().f(), vec![1]).unwrap(), 0, arr1(&[1]));
    assert!(::std::panic::catch_unwind(
        || Array0::from_shape_vec(().f(), vec![1]).unwrap().insert_axis(Axis(1))).is_err());

    test_insert_f!(Array1::<u8>::zeros((3).f()), 0, Array2::<u8>::zeros((1, 3)));
    test_insert_f!(Array1::<u8>::zeros((3).f()), 1, Array2::<u8>::zeros((3, 1)));
    assert!(::std::panic::catch_unwind(
        || Array1::<u8>::zeros((3).f()).insert_axis(Axis(2))).is_err());

    test_insert_f!(Array3::<u8>::zeros((3, 4, 5).f()), 1, Array4::<u8>::zeros((3, 1, 4, 5)));
    assert!(::std::panic::catch_unwind(
        || Array3::<u8>::zeros((3, 4, 5).f()).insert_axis(Axis(4))).is_err());

    test_insert_f!(ArrayD::<u8>::zeros(vec![3, 4, 5].f()), 1,
                   ArrayD::<u8>::zeros(vec![3, 1, 4, 5]));
    assert!(::std::panic::catch_unwind(
        || ArrayD::<u8>::zeros(vec![3, 4, 5].f()).insert_axis(Axis(4))).is_err());
}
```


Overlapping Code:
```
sert_axis_f() {
defmac!(test_insert_f orig, index, new => {
let res = orig.insert_axis(Axis(index));
assert_eq!(res, new);
assert!(res.t().is_standard_layout());
});
test_insert_f!(Array0::from_shape_vec(().f(), vec![1]).unwrap(), 0, arr1(&[1]));
assert!(::std::panic::catch_unwind(
|| Array0::from_shape_vec(().f(), vec![1]).unwrap().insert_axis(Axis(1))).is_err());
test_insert_f!(Array1::<u8>::zeros((3).f()), 0, Array2::<u8>::zeros((1, 3)));
test_insert_f!(Array1::<u8>::zeros((3).f()), 1, Array2::<u8>::zeros((3, 1)));
assert!(::std::panic::catch_unwind(
|| Array1::<u8>::zeros((3).f()).insert_axis(Axis(2))).is_err());
test_insert_f!(Array3::<u8>::zeros((3, 4, 5).f()), 1, Array4::<u8>::zeros((3, 1, 4, 5)));
assert!(::std::panic::catch_unwind(
|| Array3::<u8>::zeros((3, 4, 5).f()).insert_axis(Axis(4))).is_err());
test_insert_f!(ArrayD::<u8>::zeros(vec![3, 4, 5].f()), 1,
ArrayD::<u8>::zeros(vec![3, 1, 4, 5]));
assert!(::std::panic::catch_unwind(
|| ArrayD::<u8>::zeros(vec![3, 4, 5].f()).insert_axis(Axis(4))).is_err())
```
<Overlap Ratio: 0.9922854387656702>

---

--- 379 --
Question ID: b5810c4d2a6a7e1bcd3c499568e7b5fdb6c61400_0
Original Code:
```
pub extern fn cash_flow_class(cash_in: f64, cash_out: f64, reinvest_rate: f64, term: i32, year: i32) -> f64 {
  let cash: f64 = cash_in - cash_out;
  let reinvestment = 1.0 + (reinvest_rate / 100.0);
  let power: i32 = term - year;

  cash * reinvestment.powi(power.into())
}
```


Overlapping Code:
```
low_class(cash_in: f64, cash_out: f64, reinvest_rate: f64, term: i32, year: i32) -> f64 {
let cash: f64 = cash_in - cash_out;
let reinvestment = 1.0 + (reinvest_rate / 100.0);
let power: i32 = term - year;
cash * reinvestment.powi(power.into
```
<Overlap Ratio: 0.9060150375939849>

---

--- 380 --
Question ID: 8dd9ecc743b62c7ecf17d9e21c3da8039a7ec29a_0
Original Code:
```
fn iterate_once(tiles: Tiles) -> Tiles {
    let mut counter = HashMap::new();

    tiles
        .iter()
        .flat_map(|(x, y)| {
            NEIGHBORS
                .iter()
                .map(move |neigh| (x + neigh.0, y + neigh.1))
        })
        .for_each(|(x, y)| *counter.entry((x, y)).or_insert(0) += 1);

    counter
        .iter()
        .filter(|&(k, &c)| (c == 2 || (c == 1 && tiles.contains(&k))))
        .map(|(k, _)| k)
        .cloned()
        .collect()
}
```


Overlapping Code:
```

let mut counter = HashMap::new();
tiles
.iter()
.flat_map(|(x, y)| {
NEIGHBORS
.iter()
.map(move |neigh| (x + neigh.0, y + neigh.1))
})
.for_each(|(x, y)| *counter.entry((x, y)).or_insert(0) += 1);
counter
.iter()
.filter(|&(k, &c)| (c == 2 || (c == 1 && tiles.contains(&k))))
.map(|(k, _)| k)
.clon
```
<Overlap Ratio: 0.8403361344537815>

---

--- 381 --
Question ID: 82c9ecc28a696795077789f53750c33e9777ae18_0
Original Code:
```
fn no_explicit_any_test() {
    assert_lint_err::<NoExplicitAny>(
      "function foo(): any { return undefined; }",
      16,
    );
    assert_lint_err::<NoExplicitAny>(
      "function bar(): Promise<any> { return undefined; }",
      24,
    );
    assert_lint_err::<NoExplicitAny>("const a: any = {};", 9);
  }
```


Overlapping Code:
```
ert_lint_err::<NoExplicitAny>(
"function foo(): any { return undefined; }",
16,
);
assert_lint_err::<NoExplicitAny>(
"function bar(): Promise<any> { return undefined; }",
24,
);
assert_lint_err::<NoExplicitAny>("const a: an
```
<Overlap Ratio: 0.828996282527881>

---

--- 382 --
Question ID: f5e8d4f4ac2f1235aafda3a6b82f7876630db0f5_0
Original Code:
```
async fn main() -> Result<(), Box<dyn Error>> {
    let consumer_key = std::env::var("POCKET_CONSUMER_KEY")?;
    println!("consumer key: {}", consumer_key);
    let auth = PocketAuthentication::new(&consumer_key, "rustapi:finishauth");
    let state = Some(format!("{:?}", Instant::now()));
    let code = auth.request(state.as_deref()).await?;
    let url = auth.authorize_url(&code);
    println!(
        "Follow auth URL to provide access and press enter when finished: {}",
        url
    );
    let _ = io::stdin().read_line(&mut String::new());
    let user = auth.authorize(&code, state.as_deref()).await?;
    println!("username: {}", user.username);
    println!("access token: {:?}", user.access_token);
    Ok(())
}
```


Overlapping Code:
```
async fn main() -> Result<(), Box<dyn Error>> {
let consumer_key = std::env::var("POCKET_CONSUMER_KEY")?;
println!("consumer key: {}", consumer_key);
let auth = PocketAuthentication::new(&consumer_key, "rustapi:finishauth");
let state = Some(format!("{:?}", Instant::now()));
let code = auth.request(state.as_deref()).await?;
let url = auth.authorize_url(&code);
println!(
"Follow auth URL to provide access and press enter when finished: {}",
url
);
let _ = io::stdin().read_line(&mut String::new());
let user = auth.authorize(&code, state.as_deref()).await?;
println!("username: {}", user.username);
println!("access token: {:?}", user.access_token);
Ok(()
```
<Overlap Ratio: 0.9954614220877458>

---

--- 383 --
Question ID: 436299bc1ff0feb946e5eaa0307e794c5b3c4921_0
Original Code:
```
pub fn render(
    gui: &mut GuiProgram,
    frame: &wgpu::SwapChainOutput,
    device: &wgpu::Device,
) -> Vec<wgpu::CommandBuffer> {

    // Draw the tree itself
    // This function returns a list of vertices that when drawn makes up the background of the tree
    // It will also fill the text buffer with the appropriate sections - all we need to do is flush it
    let mut vertices = render_file_tree(gui);
    vertices.append(&mut super::Vertex::rect(0.0, 0.0, gui.align.win_width, 32.0, [0.0,0.0,0.0,1.0]));

    let mut encoder =
        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

    if !vertices.is_empty() {
        let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);

        let rpass_color_attachment = {
            wgpu::RenderPassColorAttachmentDescriptor {
                attachment: &frame.view,
                resolve_target: None,
                load_op: wgpu::LoadOp::Clear,
                store_op: wgpu::StoreOp::Store,
                clear_color: wgpu::Color::BLACK,
            }
        };

        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            color_attachments: &[rpass_color_attachment],
            depth_stencil_attachment: None,
        });

        rpass.set_pipeline(&gui.pipeline);
        rpass.set_bind_group(0, &gui.uniforms, &[]);
        rpass.set_vertex_buffer(0, &buffer, 0, 0);

        rpass.draw(0..vertices.len() as u32, 0..1);
    }
    let cb1 = encoder.finish();

    ////// Images
    let mut encoder =
        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

    let vertices = gui.align.image(Anchor::TopRight, 0.0, 0.0, 64.0, 32.0, 0.0, Some([0.0,588.0,128.0,64.0]));
    let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);

    let rpass_color_attachment =  {
        wgpu::RenderPassColorAttachmentDescriptor {
            attachment: &frame.view,
            resolve_target: None,
            load_op: wgpu::LoadOp::Load,
            store_op: wgpu::StoreOp::Store,
            clear_color: wgpu::Color::WHITE,
        }
    };

    {
        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            color_attachments: &[rpass_color_attachment],
            depth_stencil_attachment: None,
        });

        rpass.set_pipeline(&gui.tex_pipeline);
        rpass.set_bind_group(0, &gui.uniforms, &[]);
        rpass.set_bind_group(1, &gui.texture_bind_group, &[]);
        rpass.set_vertex_buffer(0, &buffer, 0, 0);

        rpass.draw(0..vertices.len() as u32, 0..1);
    }

    gui.state_manager.text_handler.lock().unwrap().draw("File tree", 0.0, 0.0, 32.0, f32::INFINITY, [1.0,1.0,1.0,1.0]);
    let cb2 = encoder.finish();


    ///// Render text
    let mut encoder =
        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("Text") });

    // Draw on top of previous (i.e. on the background of the tree)
    {
        let _ = encoder.begin_render_pass(
            &wgpu::RenderPassDescriptor {
                color_attachments: &[
                    wgpu::RenderPassColorAttachmentDescriptor {
                        attachment: &frame.view,
                        resolve_target: None,
                        load_op: wgpu::LoadOp::Load,
                        store_op: wgpu::StoreOp::Store,
                        clear_color: wgpu::Color::BLACK,
                    },
                ],
                depth_stencil_attachment: None,
            },
        );
    }

    gui.state_manager.text_handler.lock().unwrap().flush(&device,&mut encoder, frame, (gui.sc_desc.width,gui.sc_desc.height));

    let cb3 = encoder.finish();

    vec![cb1,cb2,cb3]
}
```


Overlapping Code:
```
r(
gui: &mut GuiProgram,
frame: &wgpu::SwapChainOutput,
device: &wgpu::Device,
) -> Vec<wgpu::CommandBuffer> {
// Draw the tree itself
// This function returns a list of vertices that when drawn makes up the background of the tree
// It will also fill the text buffer with the appropriate sections - all we need to do is flush it
let mut vertices = render_file_tree(gui);
vertices.append(&mut super::Vertex::rect(0.0, 0.0, gui.align.win_width, 32.0, [0.0,0.0,0.0,1.0]));
let mut encoder =
device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
if !vertices.is_empty() {
let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);
let rpass_color_attachment = {
wgpu::RenderPassColorAttachmentDescriptor {
attachment: &frame.view,
resolve_target: None,
load_op: wgpu::LoadOp::Clear,
store_op: wgpu::StoreOp::Store,
clear_color: wgpu::Color::BLACK,
}
};
let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
color_attachments: &[rpass_color_attachment],
depth_stencil_attachment: None,
});
rpass.set_pipeline(&gui.pipeline);
rpass.set_bind_group(0, &gui.uniforms, &[]);
rpass.set_vertex_buffer(0, &buffer, 0, 0);
rpass.draw(0..vertices.len() as u32, 0..1);
}
let cb1 = encoder.finish();
////// Images
let mut encoder =
device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });
let vertices = gui.align.image(Anchor::TopRight, 0.0, 0.0, 64.0, 32.0, 0.0, Some([0.0,588.0,128.0,64.0]));
let buffer = device.create_buffer_with_data(vertices.as_bytes(), BufferUsage::VERTEX);
let rpass_color_attachment = {
wgpu::RenderPassColorAttachmentDescriptor {
attachment: &frame.view,
resolve_target: None,
load_op: wgpu::LoadOp::Load,
store_op: wgpu::StoreOp::Store,
clear_color: wgpu::Color::WHITE,
}
};
{
let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
color_attachments: &[rpass_color_attachment],
depth_stencil_attachment: None,
});
rpass.set_pipeline(&gui.tex_pipeline);
rpass.set_bind_group(0, &gui.uniforms, &[]);
rpass.set_bind_gro
```
<Overlap Ratio: 0.9931840311587147>

---

