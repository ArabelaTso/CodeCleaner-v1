--- 0 --
Question ID: 6fb529986b88ec394adb59f08b3f73c56e47a052_106
Original Code:
```
void f106(void) {
    	int32_t x521 = -1;
	volatile int32_t x522 = INT32_MAX;
	uint16_t x523 = 1946U;
	uint32_t x524 = 63227U;
	static volatile uint32_t t106 = 53U;

    t106 = ((x521*(x522|x523))^x524);

    if (t106 != 2147546874U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x522 = INT32_MAX;
uint16_t x523 = 1946U;
uint32_t x524 = 63227U;
static volatile uint32_t t106 = 53U;
t106 = ((x521*(x522|x523))^x524);
if (t1
```
<Overlap Ratio: 0.6302521008403361>

---

--- 1 --
Question ID: 94e83d28da7a424ea28a59dd63bda175ae3b5f31_48
Original Code:
```
void f48(void) {
    	static uint32_t x233 = 3U;
	int8_t x234 = 0;
	int32_t x235 = -738526;
	static int64_t x236 = -473228154727660LL;

    t48 = ((x233*(x234^x235))==x236);

    if (t48 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d f48(void) {
static uint32_t x233 = 3U;
int8_t x234 = 0;
int32_t x235 = -738526;
static int64_t x236 = -473228154727660LL;
t48 = ((x233*(x234^x235))=
```
<Overlap Ratio: 0.7575757575757576>

---

--- 2 --
Question ID: b96e028e002a6c23a4e6f55f6335006e86e10c89_7
Original Code:
```
int
e2_trace_GrowIndexTo(E2_TRACE *tr, int ndom)
{
  void *p;
  int   status;

  if (ndom < tr->ndomalloc) return eslOK;

  ESL_RALLOC(tr->tfrom,   p, sizeof(int)*ndom);
  ESL_RALLOC(tr->tto,     p, sizeof(int)*ndom);
  ESL_RALLOC(tr->sqfrom,  p, sizeof(int)*ndom);
  ESL_RALLOC(tr->sqto,    p, sizeof(int)*ndom);
  ESL_RALLOC(tr->anfrom,  p, sizeof(int)*ndom);
  ESL_RALLOC(tr->anto,    p, sizeof(int)*ndom);
  tr->ndomalloc = ndom;
  return eslOK;
  
 ERROR:
  return status;
}
```


Overlapping Code:
```
nt
e2_trace_GrowIndexTo(E2_TRACE *tr, int ndom)
{
void *p;
int status;
if (ndom < tr->ndomalloc) return eslOK;
ESL_RALLOC(tr->tfrom, p, sizeof(int)*ndom);
ESL_RALLOC(tr->tto, p, sizeof(int)*ndom);
ESL_RALLOC(tr->sqfrom, p, sizeof(int)*ndom);
ESL_RALLOC(tr->sqto, p, sizeof(int)*ndom);
ESL_RALLOC(tr->anfrom, p, sizeof(int)*ndom);
ESL_RALLOC(tr->anto, p, sizeof(int)*ndom);
tr->ndomalloc = ndom;
return esl
```
<Overlap Ratio: 0.9331797235023042>

---

--- 3 --
Question ID: b538b99826394eb32a6f5bc27b0382779cc1eed7_12
Original Code:
```
static void biquad_init_band(struct iir_filter *filter, double fs,
    double f1, double f2, int stop)
{
    double ts = 1.0 / fs;
    double bw, f;
    double w;
    complex_d p, q;
    complex_d z, s;
    double phi;
    complex_d _z, p_lp, p_bp;
    double k, x, y;
    double wa1, wa2, wa;
    double *a = filter->a;
    double *b = filter->b;
    int n, i;

    f = sqrt(f1 * f2);
    w = 2 * M_PI * f / fs;

    /* Map to continuous-time frequencies (pre-warp) */

    wa1 = 2 * fs * tan(M_PI * f1 * ts);
    wa2 = 2 * fs * tan(M_PI * f2 * ts);

    bw = wa2 - wa1;
    wa = sqrt(wa1 * wa2);

    n = filter->sections;

    for (i = 0; i < n; i += 1) {
        phi = M_PI / 2 + M_PI * (2 * i + 1) / (n * 2);
        x = cos(phi);
        y = sin(phi);

        p_lp.re = x * bw / (wa * 2);
        p_lp.im = y * bw / (wa * 2);

        /*
         *  Map every low-pass pole to a complex conjugate
         *  pair of band-bass poles
         */

        s = p_lp;
        complex_square(&s);
        s.re = 1 - s.re;
        s.im = 0 - s.im;
        complex_sqrt(&s);
        x = p_lp.re - s.im;
        y = p_lp.im + s.re;
        p_bp.re = x * wa;
        p_bp.im = y * wa;

        /*
         *  Convert every pair from continuous (s)
         *  to discrete (z) using bilinear transform
         */

        bilinear_transform(&z, &p_bp, ts);

        x = z.re;
        y = z.im;

        /*
         *  Find denominator coefficients from
         *  the complex conjugate pair of poles
         */

        a[0] = 1;
        a[1] = -2 * x;
        a[2] = x * x + y * y;

        if (stop) {
            /* Band-stop: zeros at ω and ~ω */
            s.re = 0;
            s.im = wa;
            bilinear_transform(&z, &s, ts);
            x = z.re;
            y = z.im;

            b[0] = 1;
            b[1] = -2 * x;
            b[2] = x * x + y * y;
        } else {
            /* Band-pass: zeros at ±1 */
            b[0] = 1;
            b[1] = 0;
            b[2] = -1;
        }

        /* Scale the parameters to get unity gain in the bassband */

        if (stop) {
            /* Band-stop: unity gain at zero frequency */
            _z.re = 1;
            _z.im = 0;
        } else {
            /* Band-pass: unity gain at ω */
            _z.re = cos(w);
            _z.im = -sin(w);
        }

        p.re = b[2];
        p.im = 0;
        complex_mul(&p, &_z);
        p.re += b[1];
        complex_mul(&p, &_z);
        p.re += b[0];

        q.re = a[2];
        q.im = 0;
        complex_mul(&q, &_z);
        q.re += a[1];
        complex_mul(&q, &_z);
        q.re += 1;

        complex_div(&p, &q);

        x = p.re;
        y = p.im;
        k = 1.0 / sqrt(x * x + y * y);

        b[0] *= k;
        b[1] *= k;
        b[2] *= k;

        a += filter->sect_ord + 1;
        b += filter->sect_ord + 1;
    }

    for (i = 0; i < (n + 1) * 2; i += 1)
        filter->d[i] = 0;
}
```


Overlapping Code:
```
ilter, double fs,
double f1, double f2, int stop)
{
double ts = 1.0 / fs;
double bw, f;
double w;
complex_d p, q;
complex_d z, s;
double phi;
complex_d _z, p_lp, p_bp;
double k, x, y;
double wa1, wa2, wa;
double *a = filter->a;
double *b = filter->b;
int n, i;
f = sqrt(f1 * f2);
w = 2 * M_PI * f / fs;
/* Map to continuous-time frequencies (pre-warp) */
wa1 = 2 * fs * tan(M_PI * f1 * ts);
wa2 = 2 * fs * tan(M_PI * f2 * ts);
bw = wa2 - wa1;
wa = sqrt(wa1 * wa2);
n = filter->sections;
for (i = 0; i < n; i += 1) {
phi = M_PI / 2 + M_PI * (2 * i + 1) / (n * 2);
x = cos(phi);
y = sin(phi);
p_lp.re = x * bw / (wa * 2);
p_lp.im = y * bw / (wa * 2);
/*
* Map every low-pass pole to a complex conjugate
* pair of band-bass poles
*/
s = p_lp;
complex_square(&s);
s.re = 1 - s.re;
s.im = 0 - s.im;
complex_sqrt(&s);
x = p_lp.re - s.im;
y = p_lp.im + s.re;
p_bp.re = x * wa;
p_bp.im = y * wa;
/*
* Convert every pair from continuous (s)
* to discrete (z) using bilinear transform
*/
bilinear_transform(&z, &p_bp, ts);
x = z.re;
y = z.im;
/*
* Find denominator coefficients from
* the complex conjugate pair of poles
*/
a[0] = 1;
a[1] = -2 * x;
a[2] = x * x + y * y;
if (stop) {
/* Band-stop: zeros at ω and ~ω */
s.re = 0;
s.im = wa;
bilinear_transform(&z, &s, ts);
x = z.re;
y = z.im;
b[0] = 1;
b[1] = -2 * x;
b[2] = x * x + y * y;
} else {
/* Band-pass: zeros at ±1 */
b[0] = 1;
b[1] = 0;
b[2] = -1;
}
/* Scale the parameters to get unity gain in the bassband */
if (stop) {
/* Band-stop: unity gain at zero frequency */
_z.re = 1;
_z.im = 0;
} else {
/* Band-pass: unity gain at ω */
_z.re = cos(w);
_z.im = -sin(w);
}
p.re = b[2];
p.im = 0;
complex_mul(&p, &_z);
p.re += b[1];
complex_mul(&p, &_z);
p.
```
<Overlap Ratio: 0.9588268471517203>

---

--- 4 --
Question ID: 31bd13fedd8d19cacf5ed6c1034995c0e41f956f_1
Original Code:
```
tree_node_t*
create_tree(void)
{
  tree_node_t* tree;

  tree = get_node();
  tree->left = NULL;
  tree->summand = 0;
  tree->partial_sum = 0;

  /* need key -infty, use tree as non-NULL object ptr */
  insert( tree, NEGINFTY, (object_t*) tree );

  return ( tree );
}
```


Overlapping Code:
```
tree_node_t*
create_tree(void)
{
tree_node_t* tree;
tree = get_node();
tree->left = NULL;
tree->summand = 0;
tree->partial_sum = 0;
/* need key -infty, use tree as non-NULL object ptr */
insert( tree,
```
<Overlap Ratio: 0.8032128514056225>

---

--- 5 --
Question ID: d19efff28fff0d0cef4b778f4e2c4e9473886f84_116
Original Code:
```
void AGameCrowdAgentSkeletal::SetLighting ( )
{
	static UFunction* pFnSetLighting = NULL;

	if ( ! pFnSetLighting )
		pFnSetLighting = (UFunction*) UObject::GObjObjects()->Data[ 43301 ];

	AGameCrowdAgentSkeletal_execSetLighting_Parms SetLighting_Parms;

	this->ProcessEvent ( pFnSetLighting, &SetLighting_Parms, NULL );
}
```


Overlapping Code:
```
gentSkeletal::SetLighting ( )
{
static UFunction* pFnSetLighting = NULL;
if ( ! pFnSetLighting )
pFnSetLighting = (UFunction*) UObject::GObjObjects()->Data[ 43301 ];
AGameCrowdAgentSkeletal_execSetLighting_Parms SetLighting_Parms;
this->ProcessEvent ( pFnSetLighting, &SetLighting_Parms, NULL
```
<Overlap Ratio: 0.9329073482428115>

---

--- 6 --
Question ID: 6ead483290db2422dd12b640cf484c57243731e6_1
Original Code:
```
static int
_tool_body(pri *proci, dident *pdid, int *parity, dident *pmodule)
{
    pri		*procb;
    int		flags;
    vmcode	*code;

    flags = proci->flags;
    code = proci->code.vmc;

    if (!(flags & CODE_DEFINED))
    {
	if (flags & AUTOLOAD)
	    { Set_Bip_Error(NOT_LOADED); }
	else
	    { Set_Bip_Error(NOENTRY); }
	return 0;
    }
    if (!(flags & TOOL))
    {
	Set_Bip_Error(NO_TOOL);
	return 0;
    }
    if (PriCodeType(proci) == VMCODE)
    {
	if (DebugProc(proci))
	    procb = (pri *) *(code + DEBUG_LENGTH + 1);
	else
	    procb = (pri *) *(code + 1);
	*pdid = procb->did;
	*parity = DidArity(procb->did);
	*pmodule = procb->module_def;
    }
    else /* don't know how to get the tool body */
    {
	Set_Bip_Error(NO_TOOL);
	return 0;
    }
    return 1;
}
```


Overlapping Code:
```
 dident *pdid, int *parity, dident *pmodule)
{
pri *procb;
int flags;
vmcode *code;
flags = proci->flags;
code = proci->code.vmc;
if (!(flags & CODE_DEFINED))
{
if (flags & AUTOLOAD)
{ Set_Bip_Error(NOT_LOADED); }
else
{ Set_Bip_Error(NOENTRY); }
return 0;
}
if (!(flags & TOOL))
{
Set_Bip_Error(NO_TOOL);
return 0;
}
if (PriCodeType(proci) == VMCODE)
{
if (DebugProc(proci))
procb = (pri *) *(code + DEBUG_LENGTH + 1);
else
procb = (pri *) *(code + 1);
*pdid = procb->did;
*parity = DidArity(procb->did);
*pmodule = procb->module_def;
}
else /* don't know how to get the tool body */
{
Set_Bip_Error
```
<Overlap Ratio: 0.8995502248875562>

---

--- 7 --
Question ID: 7a21fae4e4d2b2dec4ee350161c1dd2fcc81ae45_13
Original Code:
```
void f13(void) {
    	volatile int16_t x57 = INT16_MIN;
	int8_t x58 = INT8_MIN;
	volatile int8_t x60 = -1;
	volatile int32_t t13 = 729838;

    t13 = (((x57&x58)>x59)-x60);

    if (t13 != 2) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
atile int16_t x57 = INT16_MIN;
int8_t x58 = INT8_MIN;
volatile int8_t x60 = -1;
volatile int32_t t13 = 729838;
t13 = (((x57&x58)>x59)-x60);
if (t13 != 2) 
```
<Overlap Ratio: 0.7817258883248731>

---

--- 8 --
Question ID: 667c848332fcec8dbe3b9492aebabd5d206d24cd_70
Original Code:
```
void f70(void) {
    	int8_t x281 = INT8_MAX;
	volatile int64_t x282 = -1LL;
	int8_t x283 = INT8_MIN;
	uint64_t x284 = 10282204213LLU;

    t70 = (((x281&x282)>x283)!=x284);

    if (t70 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
id) {
int8_t x281 = INT8_MAX;
volatile int64_t x282 = -1LL;
int8_t x283 = INT8_MIN;
uint64_t x284 = 10282204213LLU;
t70 = (((x281&x282)>x283)!=x284);
if (t70 != 1) { NG(); } else { ; }


```
<Overlap Ratio: 0.9393939393939394>

---

--- 9 --
Question ID: d3896fe8b7f43353afe2d19f4602ac324dcd0bf7_63
Original Code:
```
void f63(void) {
    	volatile int8_t x325 = INT8_MIN;
	int16_t x326 = -1;
	int8_t x327 = INT8_MAX;
	static int32_t t63 = -1393427;

    t63 = (x325==(x326|(x327*x328)));

    if (t63 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
3(void) {
volatile int8_t x325 = INT8_MIN;
int16_t x326 = -1;
int8_t x327 = INT8_MAX;
static int32_t t63 = -1393427;
t63 = (x325==(x326|(x327*x328)));
if (t63 != 0) { NG(); } else { ; }

```
<Overlap Ratio: 0.9538461538461539>

---

--- 10 --
Question ID: 854c3bcc997b07b4231b088a2eabd9215d8e6f42_2
Original Code:
```
void oai_nw_drv_timer(unsigned long data)
{
  //---------------------------------------------------------------------------
  struct oai_nw_drv_priv *priv=(struct oai_nw_drv_priv *)data;
  spin_lock(&priv->lock);
  (priv->timer).function=oai_nw_drv_timer;
  (priv->timer).expires=jiffies+OAI_NW_DRV_TIMER_TICK;
  (priv->timer).data=data;
  add_timer(&priv->timer);
  spin_unlock(&priv->lock);
  return;
  //  add_timer(&gpriv->timer);
  //  spin_unlock(&gpriv->lock);
}
```


Overlapping Code:
```
(unsigned long data)
{
//---------------------------------------------------------------------------
struct oai_nw_drv_priv *priv=(struct oai_nw_drv_priv *)data;
spin_lock(&priv->lock);
(priv->timer).function=oai_nw_drv_timer;
(priv->timer).expires=jiffies+OAI_NW_DRV_TIMER_TICK;
(priv->timer).data=data;
add_timer(&priv->timer);
spin_unlock(&priv->lock);
return;
// add_timer(&gpriv->timer);
// spin_unlock(&gpriv->loc
```
<Overlap Ratio: 0.9415730337078652>

---

--- 11 --
Question ID: 172bb8ebb395e127916e84ac6b36749894a485e7_130
Original Code:
```
void f130(void) {
    	int16_t x697 = 14;
	uint16_t x698 = UINT16_MAX;
	static int8_t x699 = -1;
	volatile int64_t x700 = INT64_MIN;

    t130 = ((x697*x698)&(x699!=x700));

    if (t130 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
int16_t x697 = 14;
uint16_t x698 = UINT16_MAX;
static int8_t x699 = -1;
volatile int64_t x700 = INT64_MIN;
t130 = ((x697*x698)&(x699!=x700));
```
<Overlap Ratio: 0.7575757575757576>

---

--- 12 --
Question ID: 0b77f1f02d285e0d05661bd3c096a8506569d09b_6
Original Code:
```
static int matchpattern(regex_t* pattern, const char* text, int* matchlength)
{
  int pre = *matchlength;
  while (1)
  {
    if (pattern->type == UNUSED)
    {
      return 1;
    }
    regex_t* next_pattern = getnext(pattern);
    if (next_pattern->type == QUESTIONMARK)
    {
      return matchquestion(pattern, getnext(next_pattern), text, matchlength);
    }
    else if (next_pattern->type == STAR)
    {
      return matchstar(pattern, getnext(next_pattern), text, matchlength);
    }
    else if (next_pattern->type == PLUS)
    {
      return matchplus(pattern, getnext(next_pattern), text, matchlength);
    }
    else if ((pattern->type == END) && next_pattern->type == UNUSED)
    {
      return (text[0] == '\0');
    }
/*  Branching is not working properly
    else if (pattern->type == BRANCH)
    {
      return (matchpattern(pattern, text) || matchpattern(getnext(next_pattern), text));
    }
*/
  (*matchlength)++;
    if (text[0] == '\0')
      break;
    if (!matchone(pattern, *text++))
      break;
    pattern = next_pattern;
  }

  *matchlength = pre;
  return 0;
}
```


Overlapping Code:
```
tatic int matchpattern(regex_t* pattern, const char* text, int* matchlength)
{
int pre = *matchlength;
while (1)
{
if (pattern->type == UNUSED)
{
return 1;
}
regex_t* next_pattern = getnext(pattern);
if (next_pattern->type == QUESTIONMARK)
{
return matchquestion(pattern, getnext(next_pattern), text, matchlength);
}
else if (next_pattern->type == STAR)
{
return matchstar(pattern, getnext(next_pattern), text, matchlength);
}
else if (next_pattern->type == PLUS)
{
return matchplus(pattern, getnext(next_pattern), text, matchlength);
}
else if ((pattern->type == END) && next_pattern->type == UNUSED)
{
return (text[0] == '\0');
}
/* Branching is not working properly
else if (pattern->type == BRANCH)
{
return (matchpattern(pattern, text) || matchpattern(getnext(next_pattern), text));
}
*/
(*matchlength)++;
if (text[0] == '\0')
break;
if (!matchone(pattern, *text++))
break;
pattern = next_pattern;
}
*matchlength = pre;
retur
```
<Overlap Ratio: 0.9925293489861259>

---

--- 13 --
Question ID: ba277499802dc58a6f3580679bef7e530f87b74b_3
Original Code:
```
MmsNamedVariableList
mmsServer_getNamedVariableListWithName(LinkedList namedVariableLists, const char* variableListName)
{
    MmsNamedVariableList variableList = NULL;

    LinkedList element = LinkedList_getNext(namedVariableLists);

    while (element != NULL) {
        MmsNamedVariableList varList = (MmsNamedVariableList) element->data;

        if (strcmp(MmsNamedVariableList_getName(varList), variableListName) == 0) {
            variableList = varList;
            break;
        }

        element = LinkedList_getNext(element);
    }

    return variableList;
}
```


Overlapping Code:
```
etNamedVariableListWithName(LinkedList namedVariableLists, const char* variableListName)
{
MmsNamedVariableList variableList = NULL;
LinkedList element = LinkedList_getNext(namedVariableLists);
while (element != NULL) {
MmsNamedVariableList varList = (MmsNamedVariableList) element->data;
if (strcmp(MmsNamedVariableList_getName(varList), variableListName) == 0) {
variableList = varList;
break;
}
element = LinkedList_getNext(element);
}
return vari
```
<Overlap Ratio: 0.9127789046653144>

---

--- 14 --
Question ID: 026ca8754e70a304ada197ae525631d1da03ee1b_15
Original Code:
```
VOID
USBPORT_FreeBandwidthUSB11(
    PDEVICE_OBJECT FdoDeviceObject,
    PHCD_ENDPOINT Endpoint
    )
/*++

Routine Description:

    Frees the bw reserved for a give endpoint

Arguments:

Return Value:

    FALSE if no bandwidth availble

--*/
{
    PDEVICE_EXTENSION devExt;
    ULONG period, bandwidth, scheduleOffset, i, n;

    PAGED_CODE();

    GET_DEVICE_EXT(devExt, FdoDeviceObject);
    ASSERT_FDOEXT(devExt);

    ASSERT_ENDPOINT(Endpoint);

    if (Endpoint->Parameters.TransferType == Bulk ||
        Endpoint->Parameters.TransferType == Control ||
        TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
        // these come out of our standard 10%
        return;
    }

    scheduleOffset = Endpoint->Parameters.ScheduleOffset;
    bandwidth = Endpoint->Parameters.Bandwidth;
    period = Endpoint->Parameters.Period;

    LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'frBW', scheduleOffset, bandwidth, period);

    n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;

    for (i=0; i<n; i++) {

        USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
        devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;

    }
    //for (i=sheduleOffset; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i+=period) {
    //    USBPORT_ASSERT(i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
    //    devExt->Fdo.BandwidthTable[i] += bandwidth;
    //}

    // update our bw tracking info
    if (Endpoint->Parameters.TransferType == Isochronous) {
        devExt->Fdo.AllocedIsoBW -= bandwidth;
    } else {
        USBPORT_GET_BIT_SET(period, n);
        USBPORT_ASSERT(n<6);
        devExt->Fdo.AllocedInterruptBW[n] -= bandwidth;
    }

    // update max allocated BW
    USBPORT_UpdateAllocatedBw(FdoDeviceObject);

    return;
}
```


Overlapping Code:
```
reeBandwidthUSB11(
PDEVICE_OBJECT FdoDeviceObject,
PHCD_ENDPOINT Endpoint
)
/*++
Routine Description:
Frees the bw reserved for a give endpoint
Arguments:
Return Value:
FALSE if no bandwidth availble
--*/
{
PDEVICE_EXTENSION devExt;
ULONG period, bandwidth, scheduleOffset, i, n;
PAGED_CODE();
GET_DEVICE_EXT(devExt, FdoDeviceObject);
ASSERT_FDOEXT(devExt);
ASSERT_ENDPOINT(Endpoint);
if (Endpoint->Parameters.TransferType == Bulk ||
Endpoint->Parameters.TransferType == Control ||
TEST_FLAG(Endpoint->Flags, EPFLAG_ROOTHUB)) {
// these come out of our standard 10%
return;
}
scheduleOffset = Endpoint->Parameters.ScheduleOffset;
bandwidth = Endpoint->Parameters.Bandwidth;
period = Endpoint->Parameters.Period;
LOGENTRY(NULL, FdoDeviceObject, LOG_MISC, 'frBW', scheduleOffset, bandwidth, period);
n = USBPORT_MAX_INTEP_POLLING_INTERVAL/period;
for (i=0; i<n; i++) {
USBPORT_ASSERT(n*scheduleOffset+i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
devExt->Fdo.BandwidthTable[n*scheduleOffset+i] += bandwidth;
}
//for (i=sheduleOffset; i<USBPORT_MAX_INTEP_POLLING_INTERVAL; i+=period) {
// USBPORT_ASSERT(i < USBPORT_MAX_INTEP_POLLING_INTERVAL);
// devExt->Fdo.BandwidthTable[i] += bandwidth;
//}
// update our bw tracking info
if (Endpoint->Parameters.TransferType == Isochronous) {
devExt->Fdo.AllocedIsoBW -= bandwidth;
} else {
USBPORT_GET_BIT_SET(period, n);
USBPORT_ASSERT(n<6);
devExt->Fdo.AllocedInterruptBW[n] -= bandwidth;
}
// update max allocated BW
USBPOR
```
<Overlap Ratio: 0.9598684210526316>

---

--- 15 --
Question ID: a205d5b5c2656ef0d967f1b314899f437e8b351b_4
Original Code:
```
char ** rht_keys (rht_t * ht)
{
  char ** keys = calloc (rht_count (ht) + 1, sizeof (char *));
  unsigned i = 0;
  Tcl_HashSearch search;
  Tcl_HashEntry * he;
  for (he = Tcl_FirstHashEntry (ht, & search); he; he = Tcl_NextHashEntry (& search))
    keys [i ++] = Tcl_GetHashKey (ht, he);
  return keys;
}
```


Overlapping Code:
```
har ** rht_keys (rht_t * ht)
{
char ** keys = calloc (rht_count (ht) + 1, sizeof (char *));
unsigned i = 0;
Tcl_HashSearch search;
Tcl_HashEntry * he;
for (he = Tcl_FirstHashEntry (ht, & search); he; he = Tcl_NextHashEntry (& search))
keys [i ++] = Tcl_GetHashKey (ht,
```
<Overlap Ratio: 0.9273356401384083>

---

--- 16 --
Question ID: 6b24bdf3ea388ad692b56a3dd57c7bbcbadbbda4_135
Original Code:
```
void f135(void) {
    	int32_t x541 = INT32_MAX;
	static uint64_t x542 = 647LLU;
	volatile uint16_t x543 = UINT16_MAX;
	volatile uint32_t x544 = 126011647U;
	uint64_t t135 = 86LLU;

    t135 = (x541&(x542&(x543^x544)));

    if (t135 != 512LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void f135(void) {
int32_t x541 = INT32_MAX;
static uint64_t x542 = 647LLU;
volatile uint16_t x543 = UINT16_MAX;
volatile uint32_t x544 = 126011647U;
uint64_t t135 = 86LLU;
t135 = (x541&(x542&(x543^x544)));
if (t135 != 512LLU) { NG(); } else 
```
<Overlap Ratio: 0.9678714859437751>

---

--- 17 --
Question ID: f3959a5340971528f9bb6cfdb863b5d1cb2e13ba_93
Original Code:
```
void f93(void) {
    	volatile int16_t x385 = -1;
	int64_t x386 = -125003901LL;
	static int32_t t93 = 453;

    t93 = (((x385/x386)|x387)!=x388);

    if (t93 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 -1;
int64_t x386 = -125003901LL;
static int32_t t93 = 453;
t93 = (((x385/x386)|x387)!=x388);
if (t9
```
<Overlap Ratio: 0.5847953216374269>

---

--- 18 --
Question ID: e3156152d5c8cc8a9c55186203e82f2e2b40d0ab_0
Original Code:
```
void *ts__arrayGrow(
    TsCompiler *compiler, void *ptr, size_t *cap, size_t wanted_cap, size_t item_size)
{
    size_t desired_cap = TS__MAX(wanted_cap, ARRAY_INITIAL_CAPACITY);
    desired_cap = TS__MAX(desired_cap, (*cap) * 2);
    TS_ASSERT(desired_cap > 0);
    TS_ASSERT(desired_cap > (*cap));
    TS_ASSERT(desired_cap >= wanted_cap);

    void* new_arr = ts__bumpAlloc(&compiler->alloc, item_size * desired_cap);

    if (ptr)
    {
        memcpy(new_arr, ptr, (*cap) * item_size);
    }

    *cap = desired_cap;
    return new_arr;
}
```


Overlapping Code:
```
Compiler *compiler, void *ptr, size_t *cap, size_t wanted_cap, size_t item_size)
{
size_t desired_cap = TS__MAX(wanted_cap, ARRAY_INITIAL_CAPACITY);
desired_cap = TS__MAX(desired_cap, (*cap) * 2);
TS_ASSERT(desired_cap > 0);
TS_ASSERT(desired_cap > (*cap));
TS_ASSERT(desired_cap >= wanted_cap);
void* new_arr = ts__bumpAlloc(&compiler->alloc, item_size * desired_cap);
if (ptr)
{
memcpy(new_arr, ptr, (*cap) * item_size);
}
*cap = desired_cap;
retur
```
<Overlap Ratio: 0.9278350515463918>

---

--- 19 --
Question ID: 7be8d72bc0671ffd53cc26b00809b66a0c288b11_49
Original Code:
```
void f49(void) {
    	uint32_t x421 = 1587U;
	int8_t x422 = INT8_MIN;
	uint16_t x423 = 3576U;
	uint32_t t49 = 3U;

    t49 = (x421>>(x422!=(x423%x424)));

    if (t49 != 793U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void f49(void) {
uint32_t x421 = 1587U;
int8_t x422 = INT8_MIN;
uint16_t x423 = 3576U;
uint32_t t49 = 3U;
t49 = (x421>>(x422!=(x423%x424)));
if (t49 !
```
<Overlap Ratio: 0.8287292817679558>

---

--- 20 --
Question ID: 60f2f7b00a203593b4cd14e90f7d837e2e987230_1323
Original Code:
```
SWIGSTDCALL
  Ada_xcb_glx_get_tex_level_parameteriv_unchecked (void *jarg1,

                                                   uint32_t jarg2,

                                                   uint32_t jarg3,

                                                   int32_t jarg4,

                                                   uint32_t jarg5)
  {
    xcb_glx_get_tex_level_parameteriv_cookie_t jresult;
    xcb_connection_t *arg1 = (xcb_connection_t *)0;
    xcb_glx_context_tag_t arg2;
    uint32_t arg3;
    int32_t arg4;
    uint32_t arg5;
    xcb_glx_get_tex_level_parameteriv_cookie_t result;

    arg1 = (xcb_connection_t *)jarg1;

    arg2 = (xcb_glx_context_tag_t)jarg2;

    arg3 = (uint32_t)jarg3;

    arg4 = (int32_t)jarg4;

    arg5 = (uint32_t)jarg5;

    result = xcb_glx_get_tex_level_parameteriv_unchecked (arg1, arg2, arg3,
                                                          arg4, arg5);
    {
      jresult = result;
    }

    return jresult;
  }
```


Overlapping Code:
```
L
Ada_xcb_glx_get_tex_level_parameteriv_unchecked (void *jarg1,
uint32_t jarg2,
uint32_t jarg3,
int32_t jarg4,
uint32_t jarg5)
{
xcb_glx_get_tex_level_parameteriv_cookie_t jresult;
xcb_connection_t *arg1 = (xcb_connection_t *)0;
xcb_glx_context_tag_t arg2;
uint32_t arg3;
int32_t arg4;
uint32_t arg5;
xcb_glx_get_tex_level_parameteriv_cookie_t result;
arg1 = (xcb_connection_t *)jarg1;
arg2 = (xcb_glx_context_tag_t)jarg2;
arg3 = (uint32_t)jarg3;
arg4 = (int32_t)jarg4;
arg5 = (uint32_t)jarg5;
result = xcb_glx_get_tex_level_parameteriv_unchecked (arg1, arg2, arg3,
arg4, arg5);
{
jresult = result;
}
return jresult;
```
<Overlap Ratio: 0.9808917197452229>

---

--- 21 --
Question ID: 46c82eef7c8a59345a835d767fd28fec711fcb53_148
Original Code:
```
void f148(void) {
    	int16_t x617 = INT16_MIN;
	int16_t x618 = INT16_MAX;
	volatile int64_t x619 = INT64_MIN;
	volatile int32_t t148 = 855008766;

    t148 = ((x617==(x618&x619))%x620);

    if (t148 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d) {
int16_t x617 = INT16_MIN;
int16_t x618 = INT16_MAX;
volatile int64_t x619 = INT64_MIN;
volatile int32_t t148 = 855008766;
t148 = ((x617==(x618&x619))%x620);
if (t148 != 0) { NG();
```
<Overlap Ratio: 0.863849765258216>

---

--- 22 --
Question ID: 63dc8800ac98af9f51a9579a03561dc2f1ff00b5_14
Original Code:
```
static struct enet_statistics *if_stats(netdevice_t *dev)
#endif
{

	ppp_private_area_t *ppp_priv_area = dev->priv;
	sdla_t* card;
	
	if( ppp_priv_area == NULL )
		return NULL;

	card = ppp_priv_area->card;
	return &card->wandev.stats;
}
```


Overlapping Code:
```
struct enet_statistics *if_stats(netdevice_t *dev)
#endif
{
ppp_private_area_t *ppp_priv_area = dev->priv;
sdla_t* card;

if( ppp_priv_area == NULL )
return NULL;
card = ppp_priv_area->card;
return &card->w
```
<Overlap Ratio: 0.9074889867841409>

---

--- 23 --
Question ID: 6e83aeecd928e747ee4ba95b31cf6399f66786ef_33
Original Code:
```
static int dm_test_child_ofdata(struct unit_test_state *uts)
{
	struct udevice *bus, *dev;
	int count;

	ut_assertok(uclass_first_device_err(UCLASS_TEST_BUS, &bus));
	count = 0;
	device_foreach_child_of_to_plat(dev, bus) {
		ut_assert(dev_get_flags(dev) & DM_FLAG_PLATDATA_VALID);
		ut_assert(!(dev_get_flags(dev) & DM_FLAG_ACTIVATED));
		count++;
	}
	ut_asserteq(3, count);

	return 0;
}
```


Overlapping Code:
```
tatic int dm_test_child_ofdata(struct unit_test_state *uts)
{
struct udevice *bus, *dev;
int count;
ut_assertok(uclass_first_device_err(UCLASS_TEST_BUS, &bus));
count = 0;
device_foreach_child_of_to_plat(dev, bus) {
ut_assert(dev_get_flags(dev) & DM_FLAG_PLATDATA_VALID);
ut_assert(!(dev_get_flags(dev) & DM_FLAG_ACTIVATED));
count++;
}
ut_asserteq(3
```
<Overlap Ratio: 0.9408602150537635>

---

--- 24 --
Question ID: 3036da0ca4b420c029bf83a29617a32a9fb17650_106
Original Code:
```
void f106(void) {
    	static int16_t x467 = -1;
	uint16_t x468 = 53U;
	volatile int32_t t106 = 1;

    t106 = ((x465+(x466/x467))>x468);

    if (t106 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 -1;
uint16_t x468 = 53U;
volatile int32_t t106 = 1;
t106 = ((x465+(x466/x467))>x468);
if (t106 != 0
```
<Overlap Ratio: 0.6097560975609756>

---

--- 25 --
Question ID: 003249075a400561ec34b8132e96b04f03eaba68_32
Original Code:
```
void f32(void) {
    	int16_t x137 = -101;
	volatile int64_t x138 = INT64_MAX;
	uint32_t x139 = UINT32_MAX;
	volatile int8_t x140 = INT8_MAX;
	static volatile int32_t t32 = -7032;

    t32 = ((x137%x138)==(x139%x140));

    if (t32 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
int16_t x137 = -101;
volatile int64_t x138 = INT64_MAX;
uint32_t x139 = UINT32_MAX;
volatile int8_t x140 = INT8_MAX;
static volatile int32_t t32 = -7032;
t32 = ((x137%x138)==(x139%x140));
if 
```
<Overlap Ratio: 0.8264462809917356>

---

--- 26 --
Question ID: ffc85599bce5d93ad73d49ef0fbfc7995f33621c_108
Original Code:
```
void f108(void) {
    	volatile int32_t x6045 = -3231;
	uint64_t x6046 = 6129359876919LLU;
	static volatile int32_t x6048 = -1;
	volatile int32_t t108 = 559652695;

    t108 = ((x6045<=(x6046<<x6047))==x6048);

    if (t108 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
45 = -3231;
uint64_t x6046 = 6129359876919LLU;
static volatile int32_t x6048 = -1;
volatile int32_t t108 = 559652695;
t108 = ((x6045<=(x6046<<x6047))=
```
<Overlap Ratio: 0.6382978723404256>

---

--- 27 --
Question ID: 650d66eeb7d39efb1a846c16b7405e62ea1f2c49_0
Original Code:
```
int file_size(FILE *f, size_t *size) {
    long off = ftell(f);
    if (off == -1) return -1;
    if (fseek(f, 0, SEEK_END) == -1) return -1;
    long len = ftell(f);
    if (len == -1) return -1;
    if (fseek(f, off, SEEK_SET) == -1) return -1;
    *size = (size_t) len;
    return 0;
}
```


Overlapping Code:
```
 off = ftell(f);
if (off == -1) return -1;
if (fseek(f, 0, SEEK_END) == -1) return -1;
long len = ftell(f);
if (len == -1) return -1;
if (fseek(f, off, SEEK_SET) == -1) return -1;
*size = (size_t) len
```
<Overlap Ratio: 0.78125>

---

--- 28 --
Question ID: 44e6bf14415ca519369ab1bab2934a2ce10e7d40_139
Original Code:
```
void f139(void) {
    	uint8_t x557 = 1U;
	uint64_t x558 = 261236344424517LLU;
	uint8_t x559 = UINT8_MAX;
	uint8_t x560 = 93U;

    t139 = (x557&(x558<=(x559<=x560)));

    if (t139 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
4_t x558 = 261236344424517LLU;
uint8_t x559 = UINT8_MAX;
uint8_t x560 = 93U;
t139 = (x557&(x558<=(x559<=x560)));
if (t139 != 0) { NG(); } else { ; }


```
<Overlap Ratio: 0.7772020725388601>

---

--- 29 --
Question ID: 8cb4338e5aa71a4131d28cce9d2c921b2c0783cc_3
Original Code:
```
INT_PTR CALLBACK Appletalk_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnAppleTalkInitDialog( hwnd );

            break;
        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch( pnmh->code ) {

                case PSN_APPLY: {

                    OnAppleTalkApply( hwnd );


                }

            }

            break;

        }    // end case WM_NOTIFY

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam ) ;
            WORD wButtonId   = LOWORD( wParam ) ;


            break;

        }

        default:

            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
```


Overlapping Code:
```
TR CALLBACK Appletalk_PropertiesDlgProc(
IN HWND hwnd,
IN UINT uMsg,
IN WPARAM wParam,
IN LPARAM lParam)
{
BOOL bStatus = TRUE;
switch( uMsg ) {
case WM_INITDIALOG: {
OnAppleTalkInitDialog( hwnd );
break;
}
case WM_NOTIFY: {
LPNMHDR pnmh = (LPNMHDR) lParam;
switch( pnmh->code ) {
case PSN_APPLY: {
OnAppleTalkApply( hwnd );
}
}
break;
} // end case WM_NOTIFY
case WM_COMMAND: {
WORD wNotifyCode = HIWORD( wParam ) ;
WORD wButtonId = LOWORD( wParam ) ;
break;
}
default:
bStatus = FALSE;
break;
}
return( bStatus );
```
<Overlap Ratio: 0.9865900383141762>

---

--- 30 --
Question ID: 4e30af2a07eb0f3b22537b50180f87d7a0ddca82_14
Original Code:
```
int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_HASH &&
        type != REDISMODULE_KEYTYPE_EMPTY)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Get the old field value. */
    RedisModuleString *oldval;
    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
    if (oldval) {
        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
    }
    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
    return REDISMODULE_OK;
}
```


Overlapping Code:
```
Copy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
if (argc != 4) return RedisModule_WrongArity(ctx);
RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
REDISMODULE_READ|REDISMODULE_WRITE);
int type = RedisModule_KeyType(key);
if (type != REDISMODULE_KEYTYPE_HASH &&
type != REDISMODULE_KEYTYPE_EMPTY)
{
return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
}
/* Get the old field value. */
RedisModuleString *oldval;
RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
if (oldval) {
RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
}
RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
return REDISM
```
<Overlap Ratio: 0.9727626459143969>

---

--- 31 --
Question ID: ca6f582625d30642463fd269eea974b4b8b6e2e9_38
Original Code:
```
bool
gfc_check_atan2 (gfc_expr *y, gfc_expr *x)
{
  if (!type_check (y, 0, BT_REAL))
    return false;
  if (!same_type_check (y, 0, x, 1))
    return false;

  return true;
}
```


Overlapping Code:
```
c_expr *x)
{
if (!type_check (y, 0, BT_REAL))
return false;
if (!same_type_check (y, 0, x, 1))
retur
```
<Overlap Ratio: 0.625>

---

--- 32 --
Question ID: a77418c12770cabb92fd8d371993cb011592e5df_19
Original Code:
```
static void decompress_bwlzh_block(unsigned char** ptr, const int nvals, unsigned int** vals)
{
    int bwlzh_buf_len = (int)(((unsigned int)(*ptr)[0]) | (((unsigned int)(*ptr)[1]) << 8)
                              | (((unsigned int)(*ptr)[2]) << 16) | (((unsigned int)(*ptr)[3]) << 24));
    (*ptr) += 4;
    *vals = warnmalloc(nvals * sizeof(**vals));
    bwlzh_decompress(*ptr, nvals, *vals);
    (*ptr) += bwlzh_buf_len;
}
```


Overlapping Code:
```
har** ptr, const int nvals, unsigned int** vals)
{
int bwlzh_buf_len = (int)(((unsigned int)(*ptr)[0]) | (((unsigned int)(*ptr)[1]) << 8)
| (((unsigned int)(*ptr)[2]) << 16) | (((unsigned int)(*ptr)[3]) << 24));
(*ptr) += 4;
*vals = warnmalloc(nvals * sizeof(**vals));
bwlzh_decompress(*ptr, nvals, *
```
<Overlap Ratio: 0.7936507936507936>

---

--- 33 --
Question ID: 783489be72fd659762793306aeeebc837500ed75_8
Original Code:
```
void viulite_sw_reset(VIU_Registers_t *const reg_base)
{
  uint32_t  reg_value;
  reg_value = reg_base->SCR;

  reg_value &= ~SCR_SWRESET_MASK;
  reg_base->SCR = reg_value;

  reg_value |= SCR_SWRESET_MASK;
  reg_base->SCR = reg_value;

  reg_value &= ~SCR_SWRESET_MASK;
  reg_base->SCR = reg_value;
}
```


Overlapping Code:
```
isters_t *const reg_base)
{
uint32_t reg_value;
reg_value = reg_base->SCR;
reg_value &= ~SCR_SWRESET_MASK;
reg_base->SCR = reg_value;
reg_value |= SCR_SWRESET_MASK;
reg_base->SCR = reg_value;
reg_value &= ~SCR_SWRESET_MASK;
reg_base->SCR = reg_value;
```
<Overlap Ratio: 0.8896797153024911>

---

--- 34 --
Question ID: e3118cedc98c235eb773405f91b4efd7ad51e3e2_46
Original Code:
```
void f46(void) {
    	volatile int32_t x3765 = 157068692;
	volatile int32_t x3766 = INT32_MAX;
	static uint64_t x3767 = UINT64_MAX;
	int8_t x3768 = 2;
	int32_t t46 = -121912;

    t46 = ((x3765<=x3766)<<(x3767+x3768));

    if (t46 != 2) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
t x3765 = 157068692;
volatile int32_t x3766 = INT32_MAX;
static uint64_t x3767 = UINT64_MAX;
int8_t x3768 = 2;
int32_t t46 = -121912;
t46 = ((x3765<=x3766)<<(x3767+x3768));
if (t46 != 2) { NG(); } els
```
<Overlap Ratio: 0.8264462809917356>

---

--- 35 --
Question ID: 42713b967ecb3329dce6b549faeaca87bfe0df9e_180
Original Code:
```
void f180(void) {
    	static int8_t x721 = INT8_MIN;
	int16_t x722 = INT16_MIN;
	int64_t x723 = -370LL;
	static uint64_t x724 = 756676372819220LLU;
	int32_t t180 = 1;

    t180 = (x721>(x722==(x723^x724)));

    if (t180 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
721 = INT8_MIN;
int16_t x722 = INT16_MIN;
int64_t x723 = -370LL;
static uint64_t x724 = 756676372819220LLU;
int32_t t180 = 1;
t180 = (x721>(x722==(x723^x724)));
if (t180 != 0) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8577586206896551>

---

--- 36 --
Question ID: 295c0737eb9f93ba1c356c7fe6726f397fad6c76_145
Original Code:
```
void f145(void) {
    	int64_t x679 = -36932516734LL;
	static uint16_t x680 = 227U;
	volatile int64_t t145 = -106065LL;

    t145 = (x677+(x678|(x679+x680)));

    if (t145 != -36932516503LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
nt64_t x679 = -36932516734LL;
static uint16_t x680 = 227U;
volatile int64_t t145 = -106065LL;
t145 = (x677+(x678|(x679+x680)));
if (t145 != -369325165
```
<Overlap Ratio: 0.7575757575757576>

---

--- 37 --
Question ID: c194c366472af69f47be7e03b50cd7b34cdf89df_2
Original Code:
```
bool
GSInit(void) {
	size_t i;

	GSMainLoop = 1;
	GSCoreSocket = -1;
	GSCoreThreadState = 0;
	GSRedirSocket = -1;
	GSRedirThreadState = 0;

	GSPopulateHostName();

	if (!GSPopulateProductName()) {
		perror(ANSI_COLOR_RED"[GSInit] Failed to populate the 'Server' header"
			   ANSI_COLOR_RESETLN);
		return false;
	}

	GSChildThreads = calloc(GSChildSize, sizeof(struct GSThread));
	if (GSChildThreads == NULL) {
		perror(ANSI_COLOR_RED"[GSInit] Failed to allocate"ANSI_COLOR_RESETLN);
		return false;
	}

	for (i = 0; i < GSChildSize; i++)
		GSChildThreads[i].sockfd = -1;

	GSCoreSocket = IOCreateSocket(443, 1);

	if (GSCoreSocket < 0) {
		printf(ANSI_COLOR_RED"[GSInit] Failed to create GSCoreSocket: %s"
			ANSI_COLOR_RESETLN, IOErrors[-GSCoreSocket]);
		return false;
	}

	GSRedirSocket = IOCreateSocket(80, 1);

	if (GSRedirSocket < 0) {
		printf(ANSI_COLOR_RED"[GSInit] Failed to create GSRedirSocket: %s"
			ANSI_COLOR_RESETLN, IOErrors[-GSRedirSocket]);
		return false;
	}

	return true;
}
```


Overlapping Code:
```
id) {
size_t i;
GSMainLoop = 1;
GSCoreSocket = -1;
GSCoreThreadState = 0;
GSRedirSocket = -1;
GSRedirThreadState = 0;
GSPopulateHostName();
if (!GSPopulateProductName()) {
perror(ANSI_COLOR_RED"[GSInit] Failed to populate the 'Server' header"
ANSI_COLOR_RESETLN);
return false;
}
GSChildThreads = calloc(GSChildSize, sizeof(struct GSThread));
if (GSChildThreads == NULL) {
perror(ANSI_COLOR_RED"[GSInit] Failed to allocate"ANSI_COLOR_RESETLN);
return false;
}
for (i = 0; i < GSChildSize; i++)
GSChildThreads[i].sockfd = -1;
GSCoreSocket = IOCreateSocket(443, 1);
if (GSCoreSocket < 0) {
printf(ANSI_COLOR_RED"[GSInit] Failed to create GSCoreSocket: %s"
ANSI_COLOR_RESETLN, IOErrors[-GSCoreSocket]);
return false;
}
GSRedirSocket = IOCreateSocket(80, 1);
if (GSRedirSocket < 0) {
printf(ANSI_COLOR_RED"[GSInit] Failed to create GSRedirSocket: %s"
ANSI_COLOR_RESETLN, IOErrors[-GSRedirSocket]);
return
```
<Overlap Ratio: 0.9594882729211087>

---

--- 38 --
Question ID: 6b2208e1051da968f7b94f9b07205b225f32c282_4
Original Code:
```
static
VOID
EmitJobSetup(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM
) {
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen = 0;
    BYTE jOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;

    if (pOEM->dwGeneral & FG_HAS_EMUL) {
        // Alster emulation mode setting
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = 'i';
        cmdbuf[wlen++] = 'w';
        cmdbuf[wlen++] = '0';
    }

    WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

    if (!DRVGETDRIVERSETTING(
            pdevobj, "MPFSetting", jOutput,
            sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        WARNING(("DrvGetDriverSetting(1) Failed\n"));
        pOEM->jMPFSetting = MPF_NOSET;
    } else {
        if (!strcmp(jOutput, OPT_A3)) {
            pOEM->jMPFSetting = MPF_A3;
            VERBOSE(("MPF_A3\n"));
        } else if (!strcmp(jOutput, OPT_B4)) {
            pOEM->jMPFSetting = MPF_B4;
            VERBOSE(("MPF_B4\n"));
        } else if (!strcmp(jOutput, OPT_A4)) {
            pOEM->jMPFSetting = MPF_A4;
            VERBOSE(("MPF_A4\n"));
        } else if (!strcmp(jOutput, OPT_B5)) {
            pOEM->jMPFSetting = MPF_B5;
            VERBOSE(("MPF_B5\n"));
        } else if (!strcmp(jOutput, OPT_A5)) {
            pOEM->jMPFSetting = MPF_A5;
            VERBOSE(("MPF_A5\n"));
        } else if (!strcmp(jOutput, OPT_LETTER)) {
            pOEM->jMPFSetting = MPF_LETTER;
            VERBOSE(("MPF_LETTER\n"));
        } else if (!strcmp(jOutput, OPT_POSTCARD)) {
            pOEM->jMPFSetting = MPF_POSTCARD;
            VERBOSE(("MPF_POSTCARD\n"));
        } else {
            pOEM->jMPFSetting = MPF_NOSET;
            VERBOSE(("MPF_NOSET\n"));
        }
    }
}
```


Overlapping Code:
```
,
PMYPDEV pOEM
) {
BYTE cmdbuf[CCHMAXCMDLEN];
WORD wlen = 0;
BYTE jOutput[64];
DWORD dwNeeded;
DWORD dwOptionsReturned;
if (pOEM->dwGeneral & FG_HAS_EMUL) {
// Alster emulation mode setting
cmdbuf[wlen++] = 0x1B;
cmdbuf[wlen++] = 'i';
cmdbuf[wlen++] = 'w';
cmdbuf[wlen++] = '0';
}
WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
if (!DRVGETDRIVERSETTING(
pdevobj, "MPFSetting", jOutput,
sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
WARNING(("DrvGetDriverSetting(1) Failed\n"));
pOEM->jMPFSetting = MPF_NOSET;
} else {
if (!strcmp(jOutput, OPT_A3)) {
pOEM->jMPFSetting = MPF_A3;
VERBOSE(("MPF_A3\n"));
} else if (!strcmp(jOutput, OPT_B4)) {
pOEM->jMPFSetting = MPF_B4;
VERBOSE(("MPF_B4\n"));
} else if (!strcmp(jOutput, OPT_A4)) {
pOEM->jMPFSetting = MPF_A4;
VERBOSE(("MPF_A4\n"));
} else if (!strcmp(jOutput, OPT_B5)) {
pOEM->jMPFSetting = MPF_B5;
VERBOSE(("MPF_B5\n"));
} else if (!strcmp(jOutput, OPT_A5)) {
pOEM->jMPFSetting = MPF_A5;
VERBOSE(("MPF_A5\n"));
} else if (!strcmp(jOutput, OPT_LETTER)) {
pOEM->jMPFSetting = MPF_LETTER;
VERBOSE(("MPF_LETTER\n"));
} else if (!strcmp(jOutput, OPT_POSTCARD)) {
pOEM->jMPFSetting = MPF_POSTCARD;
VERBOSE(("MPF_POSTCARD\n"));
} else {
pOEM->jMPFSetting = MPF_NOSET;
```
<Overlap Ratio: 0.9430132708821234>

---

--- 39 --
Question ID: da9d7b46e429fc9f0d6e6953d1a45a4b659f4f09_172
Original Code:
```
void f172(void) {
    	volatile uint64_t x721 = UINT64_MAX;
	int64_t x722 = INT64_MIN;
	static int64_t x724 = INT64_MIN;
	volatile uint64_t t172 = UINT64_MAX;

    t172 = (x721+(x722!=(x723&x724)));

    if (t172 != UINT64_MAX) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
nt64_t x721 = UINT64_MAX;
int64_t x722 = INT64_MIN;
static int64_t x724 = INT64_MIN;
volatile uint64_t t172 = UINT64_MAX;
t172 = (x721+(x722!=(x723&x724)));
if (t172 != UINT64_MAX) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8755364806866953>

---

--- 40 --
Question ID: 236b0c4fe6ec5cf9e4606c0c97d142e17a72a0cf_15
Original Code:
```
static __INLINE mtlk_dlist_entry_t *
mtlk_dlist_pop_front (mtlk_dlist_t *dlist)
{
  mtlk_dlist_entry_t *entry;

  ASSERT(dlist != NULL);

  if (mtlk_dlist_is_empty(dlist))
    return NULL;

  entry = dlist->head.next;

  mtlk_dlist_remove(dlist, entry);

  return entry;
}
```


Overlapping Code:
```
_dlist_entry_t *
mtlk_dlist_pop_front (mtlk_dlist_t *dlist)
{
mtlk_dlist_entry_t *entry;
ASSERT(dlist != NULL);
if (mtlk_dlist_is_empty(dlist))
return NULL;
entry = dlist->head.next;
mtlk_dlist_remove(dlist, entry);
return 
```
<Overlap Ratio: 0.8884462151394422>

---

--- 41 --
Question ID: 25f5c53716e976530f08daa66c969d715bcb0cec_3
Original Code:
```
static inline void
first_init (void)
{
  /* Initialize data structures so we can do RPCs.  */
  __mach_init ();

  RUN_HOOK (_hurd_preinit_hook, ());
}
```


Overlapping Code:
```
tic inline void
first_init (void)
{
/* Initialize data structures so we can do RPCs. */
__mach_init ();
RUN_HOOK 
```
<Overlap Ratio: 0.7902097902097902>

---

--- 42 --
Question ID: f7c43a999f32ac4c66962dad8fac5398365f4640_59
Original Code:
```
void f59(void) {
    	int32_t x305 = 13;
	int32_t x306 = 64981;
	static volatile int32_t x307 = INT32_MIN;
	volatile int64_t x308 = 176824918832LL;

    t59 = ((x305-x306)-(x307+x308));

    if (t59 != -174677500152LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x305 = 13;
int32_t x306 = 64981;
static volatile int32_t x307 = INT32_MIN;
volatile int64_t x308 = 176824918832LL;
t59 = ((x305-x306)-(x307+x308));
if (t59 != -174677500152LL) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8928571428571429>

---

--- 43 --
Question ID: cd5e5c292d6efeb17abfcc6d774970b8926e668a_185
Original Code:
```
void f186(void) {
    	int8_t x6377 = -2;
	uint8_t x6379 = 48U;
	int8_t x6380 = 1;
	int32_t t186 = 410131170;

    t186 = (x6377<=((x6378&x6379)>>x6380));

    if (t186 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
x6379 = 48U;
int8_t x6380 = 1;
int32_t t186 = 410131170;
t186 = (x6377<=((x6378&x6379)>>x6380));
if 
```
<Overlap Ratio: 0.5555555555555556>

---

--- 44 --
Question ID: 34d017801f19ea9486a2cf694166a9ba6c762d04_3
Original Code:
```
void BitImgImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotare(0fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit                                    // Bitmap data
)
{
    int            pam[10];
    WORD           siz;
    WORD           widByt;
    WORD           linCnt;

    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size
        pam[0] = WidthByte * Height;                        // Number of Data byte
        pam[1] = Width;
        pam[2] = Height;
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
    } else {                                                // There are invalid size
        widByt = WidthByte - InvLeft - InvRight;            // Width byte
        pam[0] = widByt * Height;
        if (InvRight == 0) {                                // There are no invalid size from the right edge
            pam[1] = Width - InvLeft * 8;                   // Width bit image
        } else {
            pam[1] = widByt * 8;                            // Width bit image
        }
        pam[2] = Height;                                    // Height bit image
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line
            lpBit += InvLeft;
            WRITESPOOLBUF(pdevobj, lpBit, widByt);
            lpBit += widByt;
            lpBit += InvRight;
        }
    }
    return;
}
```


Overlapping Code:
```
gImgCmd(
PDEVOBJ pdevobj, // Pointer to PDEVOBJ structure
WORD Width, // dot
WORD Height, // dot
WORD WidthByte, // byte
WORD Rotation, // rotare(0fixed)
WORD InvLeft, // Invalid size from the left edge
WORD InvRight, // Invalid size from the right edge
LPBYTE lpBit // Bitmap data
)
{
int pam[10];
WORD siz;
WORD widByt;
WORD linCnt;
if (InvLeft == 0 && InvRight == 0) { // There are no invalid size
pam[0] = WidthByte * Height; // Number of Data byte
pam[1] = Width;
pam[2] = Height;
pam[3] = Rotation;
siz = CmdStore(CmdBuf, &ImgDrw, pam);
WRITESPOOLBUF(pdevobj, CmdBuf, siz);
WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
} else { // There are invalid size
widByt = WidthByte - InvLeft - InvRight; // Width byte
pam[0] = widByt * Height;
if (InvRight == 0) { // There are no invalid size from the right edge
pam[1] = Width - InvLeft * 8; // Width bit image
} else {
pam[1] = widByt * 8; // Width bit image
}
pam[2] = Height; // Height bit image
pam[3] = Rotation;
siz = CmdStore(CmdBuf, &ImgDrw, pam);
WRITESPOOLBUF(pdevobj, CmdBuf, siz);
for (linCnt = 0; linCnt < Height; linCnt++) { // Spool bitmap data by 1 line
lpBit += InvLeft;
WRITESPOOLBUF(pdevobj, lpBit, widByt);
lpBit += widByt;
lpBit += InvR
```
<Overlap Ratio: 0.9764035801464606>

---

--- 45 --
Question ID: 0b378362d3ce18aea692db8dd36aaa76b74fe43a_1
Original Code:
```
int update_size (app_t *app) {

    int width, height;
    SDL_GetWindowSize (app->window, &width, &height);

    if (app->texture)
        SDL_DestroyTexture (app->texture);

    if (!(app->texture = SDL_CreateTexture (app->renderer,
                                            SDL_PIXELFORMAT_RGBA8888,
                                            SDL_TEXTUREACCESS_STREAMING,
                                            width,
                                            height))) {

        fprintf (stderr, "Could not create texture: %s\n", SDL_GetError ());
        return EXIT_FAILURE;
    }

    if (app->display.buffer_output)
        display_deinit (&app->display);

    display_init (&app->display, width, height, callback, app);

    app->time_init = SDL_GetTicks () / 1000.0;

    return EXIT_FAILURE;
}
```


Overlapping Code:
```
pp_t *app) {
int width, height;
SDL_GetWindowSize (app->window, &width, &height);
if (app->texture)
SDL_DestroyTexture (app->texture);
if (!(app->texture = SDL_CreateTexture (app->renderer,
SDL_PIXELFORMAT_RGBA8888,
SDL_TEXTUREACCESS_STREAMING,
width,
height))) {
fprintf (stderr, "Could not create texture: %s\n", SDL_GetError ());
return EXIT_FAILURE;
}
if (app->display.buffer_output)
display_deinit (&app->display);
display_init (&app->display, width, height, callback, app);
app->time_init = SDL_GetTicks ()
```
<Overlap Ratio: 0.9094138543516874>

---

--- 46 --
Question ID: cbd6a173daa360208486811af65ec2c31fccd1ed_98
Original Code:
```
void f98(void) {
    	int16_t x409 = INT16_MIN;
	volatile int16_t x410 = -1;
	static volatile int16_t x411 = INT16_MIN;
	int32_t x412 = INT32_MIN;
	volatile int32_t t98 = -7;

    t98 = (x409>(x410+(x411/x412)));

    if (t98 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
16_t x409 = INT16_MIN;
volatile int16_t x410 = -1;
static volatile int16_t x411 = INT16_MIN;
int32_t x412 = INT32_MIN;
volatile int32_t t98 = -7;
t98 = (x409>(x410+(x411/x412)));
if (t98 != 0) { NG();
```
<Overlap Ratio: 0.847457627118644>

---

--- 47 --
Question ID: 1763d91900b88518dd189b5baa83354292b1a1ed_183
Original Code:
```
void f183(void) {
    	uint32_t x734 = 44975U;
	static int16_t x735 = -566;
	volatile int16_t x736 = INT16_MAX;
	static uint32_t t183 = 378073U;

    t183 = (x733&(x734*(x735>x736)));

    if (t183 != 0U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
atic int16_t x735 = -566;
volatile int16_t x736 = INT16_MAX;
static uint32_t t183 = 378073U;
t183 = (x733&(x734*(x735>x736)));
if (t183 != 0U) { NG();
```
<Overlap Ratio: 0.7142857142857143>

---

--- 48 --
Question ID: 8a64c86df4ae1707a9905fc20386518cbfb2e3f9_11
Original Code:
```
void destroy_winIVRCompositor_IVRCompositor_022(void *object)
{
    TRACE("%p\n", object);
    struct __winIVRCompositor_IVRCompositor_022 *win_object = object;
    destroy_compositor_data(&win_object->user_data);
    HeapFree(GetProcessHeap(), 0, object);
}
```


Overlapping Code:
```
positor_IVRCompositor_022(void *object)
{
TRACE("%p\n", object);
struct __winIVRCompositor_IVRCompositor_022 *win_object = object;
destroy_compositor_data(&win_object->user_data);
HeapFree(GetProcessHeap(), 0, ob
```
<Overlap Ratio: 0.8760330578512396>

---

--- 49 --
Question ID: a8aa990e49488492f795b70ff90474d7dd862414_62
Original Code:
```
void f62(void) {
    	volatile uint16_t x250 = 130U;
	int8_t x251 = INT8_MIN;
	volatile int64_t x252 = INT64_MAX;
	volatile int32_t t62 = -217;

    t62 = ((x249!=x250)|(x251<=x252));

    if (t62 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
16_t x250 = 130U;
int8_t x251 = INT8_MIN;
volatile int64_t x252 = INT64_MAX;
volatile int32_t t62 = -217;
t62 = ((x249!=x250)|(x251<=x252));
if (t62 != 1) { NG(); } else { ; }


```
<Overlap Ratio: 0.8509615384615384>

---

--- 50 --
Question ID: e3e87daf90170ccb4d9d5284834ca0a95cbe4c81_1
Original Code:
```
static int LUBoundsDestroy(void *dcone){
  int info;
  LUBounds lucone=(LUBounds)dcone;
  DSDPFunctionBegin;
  LUConeValid(lucone);
  info=DSDPVecDestroy(&lucone->DYD);DSDPCHKERR(info);
  info=DSDPVecDestroy(&lucone->YD);DSDPCHKERR(info);
  info=DSDPVecDestroy(&lucone->YP);DSDPCHKERR(info);
  DSDPFREE(&dcone,&info);DSDPCHKERR(info);
  DSDPFunctionReturn(0);
}
```


Overlapping Code:
```
c int LUBoundsDestroy(void *dcone){
int info;
LUBounds lucone=(LUBounds)dcone;
DSDPFunctionBegin;
LUConeValid(lucone);
info=DSDPVecDestroy(&lucone->DYD);DSDPCHKERR(info);
info=DSDPVecDestroy(&lucone->YD);DSDPCHKERR(info);
info=DSDPVecDestroy(&lucone->YP);DSDPCHKERR(info);
DSDPFREE(&dcone,&info);DSDPCHKERR
```
<Overlap Ratio: 0.892128279883382>

---

--- 51 --
Question ID: 46bf839170f127b37e606c0371ba33dca5af6686_3
Original Code:
```
bool
test_msgs__msg__Defaults__Sequence__init(test_msgs__msg__Defaults__Sequence * array, size_t size)
{
  if (!array) {
    return false;
  }
  test_msgs__msg__Defaults * data = NULL;
  if (size) {
    data = (test_msgs__msg__Defaults *)calloc(size, sizeof(test_msgs__msg__Defaults));
    if (!data) {
      return false;
    }
    // initialize all array elements
    size_t i;
    for (i = 0; i < size; ++i) {
      bool success = test_msgs__msg__Defaults__init(&data[i]);
      if (!success) {
        break;
      }
    }
    if (i < size) {
      // if initialization failed finalize the already initialized array elements
      for (; i > 0; --i) {
        test_msgs__msg__Defaults__fini(&data[i - 1]);
      }
      free(data);
      return false;
    }
  }
  array->data = data;
  array->size = size;
  array->capacity = size;
  return true;
}
```


Overlapping Code:
```
s__Sequence__init(test_msgs__msg__Defaults__Sequence * array, size_t size)
{
if (!array) {
return false;
}
test_msgs__msg__Defaults * data = NULL;
if (size) {
data = (test_msgs__msg__Defaults *)calloc(size, sizeof(test_msgs__msg__Defaults));
if (!data) {
return false;
}
// initialize all array elements
size_t i;
for (i = 0; i < size; ++i) {
bool success = test_msgs__msg__Defaults__init(&data[i]);
if (!success) {
break;
}
}
if (i < size) {
// if initialization failed finalize the already initialized array elements
for (; i > 0; --i) {
test_msgs__msg__Defaults__fini(&data[i - 1]);
}
free(data);
return false;
}
}
array->data = data;
array->size = size;
array->capacity = size;
return true;
}
```
<Overlap Ratio: 0.9613259668508287>

---

--- 52 --
Question ID: 1e0674ce8c0708221843e5819b044cc0ae204fc4_0
Original Code:
```
int main(int argc, char *argv[]) {
  MazeType maze[N][N];
  PosType start, end;
  SElemType_Sq e;
  char Re = 'Y';

  while (Re == 'Y' || Re == 'y') {
    InitMaze(maze, &start, &end);  //初始化迷宫，包括出入口
    ShowMaze(maze);                //显示迷宫的初始状态
    MazePath(maze, start, end);    //迷宫寻路

    printf("重置？（Y/N）：");
    scanf("%c", &Re);
  }

  return 0;
}
```


Overlapping Code:
```
*argv[]) {
MazeType maze[N][N];
PosType start, end;
SElemType_Sq e;
char Re = 'Y';
while (Re == 'Y' || Re == 'y') {
InitMaze(maze, &start, &end); //初始化迷宫，包括出入口
ShowMaze(maze); //显示迷宫的初始状态
MazePath(maze, start, end); //迷宫寻路
printf("重置？（Y/N）：");
scanf(
```
<Overlap Ratio: 0.8361204013377926>

---

--- 53 --
Question ID: a4e3219456396ac5879c15765b7d6a39a9cc1de8_6
Original Code:
```
void mrb_SQLite_Sqlite3Vtab_init(mrb_state* mrb) {
  static int initialized = 0;
  if (initialized) return;
  else initialized = 1;

/* MRUBY_BINDING: pre_class_definition */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: Sqlite3Vtab::class_definition */
/* sha: 008ff32534793c07965e6f477d3690e1b0019cdaed764ebdcc40993b87d388ac */
  struct RClass* Sqlite3Vtab_class = mrb_define_class_under(mrb, SQLite_module(mrb), "Sqlite3Vtab", mrb->object_class);
  MRB_SET_INSTANCE_TT(Sqlite3Vtab_class, MRB_TT_DATA);
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: Sqlite3Vtab::pre_class_method_definitions */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: Sqlite3Vtab::class_method_definitions */
/* sha: 380df65e514f34d8365c215c81db694b054006a5657ed801c53561069a784d42 */
#if BIND_Sqlite3Vtab_INITIALIZE
  mrb_define_method(mrb, Sqlite3Vtab_class, "initialize", mrb_SQLite_Sqlite3Vtab_initialize, MRB_ARGS_NONE());
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: Sqlite3Vtab::pre_attr_definitions */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: Sqlite3Vtab::attr_definitions */
/* sha: cc4169a83f64667251676efae32065fc7fd7d3139b0a31f202486f1ea2de3220 */
  /*
   * Fields
   */
#if BIND_Sqlite3Vtab_pModule_FIELD_READER
  mrb_define_method(mrb, Sqlite3Vtab_class, "pModule", mrb_SQLite_Sqlite3Vtab_get_pModule, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_pModule_FIELD_WRITER
  mrb_define_method(mrb, Sqlite3Vtab_class, "pModule=", mrb_SQLite_Sqlite3Vtab_set_pModule, MRB_ARGS_ARG(1, 0));
#endif
#if BIND_Sqlite3Vtab_nRef_FIELD_READER
  mrb_define_method(mrb, Sqlite3Vtab_class, "nRef", mrb_SQLite_Sqlite3Vtab_get_nRef, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_nRef_FIELD_WRITER
  mrb_define_method(mrb, Sqlite3Vtab_class, "nRef=", mrb_SQLite_Sqlite3Vtab_set_nRef, MRB_ARGS_ARG(1, 0));
#endif
#if BIND_Sqlite3Vtab_zErrMsg_FIELD_READER
  mrb_define_method(mrb, Sqlite3Vtab_class, "zErrMsg", mrb_SQLite_Sqlite3Vtab_get_zErrMsg, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_zErrMsg_FIELD_WRITER
  mrb_define_method(mrb, Sqlite3Vtab_class, "zErrMsg=", mrb_SQLite_Sqlite3Vtab_set_zErrMsg, MRB_ARGS_ARG(1, 0));
#endif
/* MRUBY_BINDING_END */


/* MRUBY_BINDING: Sqlite3Vtab::post_class_definition */
/* sha: user_defined */

/* MRUBY_BINDING_END */
}
```


Overlapping Code:
```
te3Vtab_init(mrb_state* mrb) {
static int initialized = 0;
if (initialized) return;
else initialized = 1;
/* MRUBY_BINDING: pre_class_definition */
/* sha: user_defined */
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::class_definition */
/* sha: 008ff32534793c07965e6f477d3690e1b0019cdaed764ebdcc40993b87d388ac */
struct RClass* Sqlite3Vtab_class = mrb_define_class_under(mrb, SQLite_module(mrb), "Sqlite3Vtab", mrb->object_class);
MRB_SET_INSTANCE_TT(Sqlite3Vtab_class, MRB_TT_DATA);
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::pre_class_method_definitions */
/* sha: user_defined */
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::class_method_definitions */
/* sha: 380df65e514f34d8365c215c81db694b054006a5657ed801c53561069a784d42 */
#if BIND_Sqlite3Vtab_INITIALIZE
mrb_define_method(mrb, Sqlite3Vtab_class, "initialize", mrb_SQLite_Sqlite3Vtab_initialize, MRB_ARGS_NONE());
#endif
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::pre_attr_definitions */
/* sha: user_defined */
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::attr_definitions */
/* sha: cc4169a83f64667251676efae32065fc7fd7d3139b0a31f202486f1ea2de3220 */
/*
* Fields
*/
#if BIND_Sqlite3Vtab_pModule_FIELD_READER
mrb_define_method(mrb, Sqlite3Vtab_class, "pModule", mrb_SQLite_Sqlite3Vtab_get_pModule, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_pModule_FIELD_WRITER
mrb_define_method(mrb, Sqlite3Vtab_class, "pModule=", mrb_SQLite_Sqlite3Vtab_set_pModule, MRB_ARGS_ARG(1, 0));
#endif
#if BIND_Sqlite3Vtab_nRef_FIELD_READER
mrb_define_method(mrb, Sqlite3Vtab_class, "nRef", mrb_SQLite_Sqlite3Vtab_get_nRef, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_nRef_FIELD_WRITER
mrb_define_method(mrb, Sqlite3Vtab_class, "nRef=", mrb_SQLite_Sqlite3Vtab_set_nRef, MRB_ARGS_ARG(1, 0));
#endif
#if BIND_Sqlite3Vtab_zErrMsg_FIELD_READER
mrb_define_method(mrb, Sqlite3Vtab_class, "zErrMsg", mrb_SQLite_Sqlite3Vtab_get_zErrMsg, MRB_ARGS_ARG(0, 0));
#endif
#if BIND_Sqlite3Vtab_zErrMsg_FIELD_WRITER
mrb_define_method(mrb, Sqlite3Vtab_class, "zErrMsg=", mrb_SQLite_Sqlite3Vtab_set_zErrMsg, MRB_ARGS_ARG(1, 0));
#endif
/* MRUBY_BINDING_END */
/* MRUBY_BINDING: Sqlite3Vtab::post_class_definition */
/* sha: user_defined */
/* MRUBY_BINDING_END */
}
```
<Overlap Ratio: 0.9911855442926399>

---

--- 54 --
Question ID: a468ff3bcb6141c4c585863134e8a8eabe3b6293_72
Original Code:
```
void f72(void) {
    	int64_t x373 = INT64_MIN;
	int16_t x374 = INT16_MIN;
	volatile int8_t x376 = 1;
	static int64_t t72 = 270501554721197LL;

    t72 = (x373&(x374*(x375&x376)));

    if (t72 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
{
int64_t x373 = INT64_MIN;
int16_t x374 = INT16_MIN;
volatile int8_t x376 = 1;
static int64_t t72 = 270501554721197LL;
t72 = (x373&(x374*(x375&x376)));
if (t72 != 0L
```
<Overlap Ratio: 0.8019323671497585>

---

--- 55 --
Question ID: be1f22e3cef7a4ead5581ec5da7a693fd94222c3_4
Original Code:
```
void console_init(void)
{
    /* Turn on the clocks. */
    rcc->apb2enr |= RCC_APB2ENR_USART1EN;

    /* Enable TX pin (PA9) for USART output, RX pin (PA10) as input. */
    gpio_configure_pin(gpioa, 9, AFO_pushpull(_10MHz));
    gpio_configure_pin(gpioa, 10, GPI_pull_up);

    /* BAUD, 8n1. */
    usart1->brr = SYSCLK / BAUD;
    usart1->cr1 = (USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);
    usart1->cr3 = USART_CR3_DMAT;

    /* Initialise DMA1 channel 4 and its completion interrupt. */
    dma1->ch4.cpar = (uint32_t)(unsigned long)&usart1->dr;
    dma1->ifcr = DMA_IFCR_CGIF(4);
    IRQx_set_prio(DMA1_CH4_IRQ, CONSOLE_IRQ_PRI);
    IRQx_enable(DMA1_CH4_IRQ);
}
```


Overlapping Code:
```

/* Turn on the clocks. */
rcc->apb2enr |= RCC_APB2ENR_USART1EN;
/* Enable TX pin (PA9) for USART output, RX pin (PA10) as input. */
gpio_configure_pin(gpioa, 9, AFO_pushpull(_10MHz));
gpio_configure_pin(gpioa, 10, GPI_pull_up);
/* BAUD, 8n1. */
usart1->brr = SYSCLK / BAUD;
usart1->cr1 = (USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);
usart1->cr3 = USART_CR3_DMAT;
/* Initialise DMA1 channel 4 and its completion interrupt. */
dma1->ch4.cpar = (uint32_t)(unsigned long)&usart1->dr;
dma1->ifcr = DMA_IFCR_CGIF(4);
IRQx_set_prio(DMA1_CH4_IRQ, CONSOLE_IRQ_PRI);
IRQx_en
```
<Overlap Ratio: 0.9248366013071896>

---

--- 56 --
Question ID: 8422707813c3e82146aad7839d40ce8f0c0f2a6e_29
Original Code:
```
void f29(void) {
    	int64_t x121 = -1LL;
	int16_t x122 = INT16_MIN;
	uint64_t x123 = 116579606282272LLU;
	int8_t x124 = INT8_MAX;
	static volatile int32_t t29 = -603360940;

    t29 = ((x121<=x122)==(x123%x124));

    if (t29 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
t x122 = INT16_MIN;
uint64_t x123 = 116579606282272LLU;
int8_t x124 = INT8_MAX;
static volatile int32_t t29 = -603360940;
t29 = ((x121<=x122)==(x123%x
```
<Overlap Ratio: 0.6302521008403361>

---

--- 57 --
Question ID: 6c31bfff23ebb07b2c0d627fa91b595afe5f3532_188
Original Code:
```
void f188(void) {
    	int16_t x761 = -1;
	static int8_t x763 = 63;
	uint64_t x764 = 11114862LLU;
	volatile uint64_t t188 = 440311027LLU;

    t188 = (((x761==x762)%x763)+x764);

    if (t188 != 11114862LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```

int16_t x761 = -1;
static int8_t x763 = 63;
uint64_t x764 = 11114862LLU;
volatile uint64_t t188 = 440311027LLU;
t188 = (((x761==x762)%x763)+x764);
if
```
<Overlap Ratio: 0.704225352112676>

---

--- 58 --
Question ID: 28aceb0c75b52c834005703bb775b8b888278acf_193
Original Code:
```
void f193(void) {
    	int64_t x773 = -21226022998127LL;
	int64_t x774 = 1956LL;
	volatile int64_t x775 = INT64_MIN;
	int8_t x776 = 26;
	static volatile int32_t t193 = 34047637;

    t193 = (x773!=((x774^x775)^x776));

    if (t193 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 -21226022998127LL;
int64_t x774 = 1956LL;
volatile int64_t x775 = INT64_MIN;
int8_t x776 = 26;
static volatile int32_t t193 = 34047637;
t193 = (x773!=((x774^x775)^x776));
if (t193 != 1) { NG(); } else { ; }

```
<Overlap Ratio: 0.859504132231405>

---

--- 59 --
Question ID: 8fb58292157a5d64f8c3c046435ac92ba7bbb98e_16
Original Code:
```
static
globus_result_t
globus_l_xio_rate_write(
    void *                              driver_specific_handle,
    const globus_xio_iovec_t *          iovec,
    int                                 iovec_count,
    globus_xio_operation_t              op)
{
    globus_result_t                     res;
    l_xio_rate_handle_t *       handle;
    l_xio_rate_data_t *         data;
    GlobusXIOName(globus_l_xio_rate_write);

    GlobusXIORateDebugEnter();
    handle = (l_xio_rate_handle_t *) driver_specific_handle;

    if(handle->write_handle == NULL)
    {
        globus_size_t wait_for = globus_xio_operation_get_wait_for(op);
        res = globus_xio_driver_pass_write(
            op,
            (globus_xio_iovec_t *)iovec,
            iovec_count,
            wait_for,
            NULL,
            NULL);
        if(res != GLOBUS_SUCCESS)
        {
            goto error;
        }
    }
    else
    {
        data = (l_xio_rate_data_t *) globus_calloc(
            1, sizeof(l_xio_rate_data_t));
        data->op = op;
        data->iovc = iovec_count;
        data->iov = (globus_xio_iovec_t *)
            globus_calloc(iovec_count, sizeof(globus_xio_iovec_t));
        data->op_handle = handle->write_handle;
        data->op_handle->data = data;
    
        GlobusIXIOUtilTransferIovec(data->iov, iovec, iovec_count);

        globus_mutex_lock(&data->op_handle->mutex);
        {
            l_xio_rate_net_ops(data->op_handle);
        }
        globus_mutex_unlock(&data->op_handle->mutex);
    }
    GlobusXIORateDebugExit();

    return GLOBUS_SUCCESS;
error:
    return res;
}
```


Overlapping Code:
```
s_result_t
globus_l_xio_rate_write(
void * driver_specific_handle,
const globus_xio_iovec_t * iovec,
int iovec_count,
globus_xio_operation_t op)
{
globus_result_t res;
l_xio_rate_handle_t * handle;
l_xio_rate_data_t * data;
GlobusXIOName(globus_l_xio_rate_write);
GlobusXIORateDebugEnter();
handle = (l_xio_rate_handle_t *) driver_specific_handle;
if(handle->write_handle == NULL)
{
globus_size_t wait_for = globus_xio_operation_get_wait_for(op);
res = globus_xio_driver_pass_write(
op,
(globus_xio_iovec_t *)iovec,
iovec_count,
wait_for,
NULL,
NULL);
if(res != GLOBUS_SUCCESS)
{
goto error;
}
}
else
{
data = (l_xio_rate_data_t *) globus_calloc(
1, sizeof(l_xio_rate_data_t));
data->op = op;
data->iovc = iovec_count;
data->iov = (globus_xio_iovec_t *)
globus_calloc(iovec_count, sizeof(globus_xio_iovec_t));
data->op_handle = handle->write_handle;
data->op_handle->data = data;

GlobusIXIOUtilTransferIovec(data->iov, iovec, iovec_count);
globus_mutex_lock(&data->op_handle->mutex);
{
l_xio_rate_net_ops(data->op_handle);
}
globus_mutex_unlock(&data->op_handle->mutex);
}
GlobusXIORateDebugExit();
return GLOBUS_SUCCESS;
error:
retu
```
<Overlap Ratio: 0.9818181818181818>

---

--- 60 --
Question ID: 6cb2c68a2fb2881cf2de7ffc914ea39c4767fb32_4
Original Code:
```
int GetDirection16__Fiiii(int x1, int y1, int x2, int y2) {
	// address: 0xFFFFFEB8
	// size: 0x100
	auto unsigned char Dirs[16][16];
	// address: 0xFFFFFFB8
	// size: 0x5
	auto unsigned char lrtoul[5];
	// address: 0xFFFFFFC0
	// size: 0x5
	auto unsigned char urtoll[5];
	// address: 0xFFFFFFC8
	// size: 0x5
	auto unsigned char lltour[5];
	// address: 0xFFFFFFD0
	// size: 0x5
	auto unsigned char ultolr[5];
	// register: 16
	register int mx;
	// register: 3
	register int my;
	// register: 3
	register int md;
}
```


Overlapping Code:
```
t GetDirection16__Fiiii(int x1, int y1, int x2, int y2) {
// address: 0xFFFFFEB8
// size: 0x100
auto unsigned char Dirs[16][16];
// address: 0xFFFFFFB8
// size: 0x5
auto unsigned char lrtoul[5];
// address: 0xFFFFFFC0
// size: 0x5
auto unsigned char urtoll[5];
// address: 0xFFFFFFC8
// size: 0x5
auto unsigned char lltour[5];
// address: 0xFFFFFFD0
// size: 0x5
auto unsigned char ultolr[5];
// register: 16
register int mx;
// register: 3
register int my;
// register: 3
register int md;
}
```
<Overlap Ratio: 0.9959432048681541>

---

--- 61 --
Question ID: cdcd88d68640783c52bd131ff69779f1d68e99b0_5
Original Code:
```
void f5(void) {
    	static volatile uint32_t x41 = 4000289U;
	volatile int16_t x42 = INT16_MAX;
	uint8_t x43 = 2U;
	int64_t x44 = -1LL;
	uint32_t t5 = 89393U;

    t5 = ((x41*x42)<<(x43==x44));

    if (t5 != 2228450783U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
32_t x41 = 4000289U;
volatile int16_t x42 = INT16_MAX;
uint8_t x43 = 2U;
int64_t x44 = -1LL;
uint32_t t5 = 89393U;
t5 = ((x41*x42)<<(x43==x44));
if (t
```
<Overlap Ratio: 0.6607929515418502>

---

--- 62 --
Question ID: b7dee672e781a753187b52cb9c6f6a7af3642966_0
Original Code:
```
static int isum( const int n, const int ix[] ) {
    //int i, sum=0;
    //for ( i=0; i<n; i++ ) sum += ix[i];
    //return sum;
    return ofmo_isum(n, ix);
}
```


Overlapping Code:
```
//int i, sum=0;
//for ( i=0; i<n; i++ ) sum += ix[
```
<Overlap Ratio: 0.34965034965034963>

---

--- 63 --
Question ID: 1d7365dda71cafe8618a336c2ef8d9501b54be5c_156
Original Code:
```
void f156(void) {
    	int16_t x905 = INT16_MAX;
	static volatile int64_t x906 = INT64_MIN;
	uint64_t x907 = 4LLU;
	int16_t x908 = -1;
	volatile uint64_t t156 = 29206710776471LLU;

    t156 = (x905&((x906*x907)-x908));

    if (t156 != 1LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
id) {
int16_t x905 = INT16_MAX;
static volatile int64_t x906 = INT64_MIN;
uint64_t x907 = 4LLU;
int16_t x908 = -1;
volatile uint64_t t156 = 29206710776471LLU;
t156 = (x905&((x906*x907)-x908));
if (t156 != 1L
```
<Overlap Ratio: 0.8414634146341463>

---

--- 64 --
Question ID: 2f896fc6863ae9e347d35e8ddc59da2799ea1987_8
Original Code:
```
int add_item( char* packet, int client_fd )
{
	char* ptr = strtok( packet, "|" );

	// check free space
	int free_space = MARKET_MAX_SIZE - ( g_market->count_of_items * sizeof( market_item ) );

	if ( free_space <= 0 )
	{
		printf( "[-] No available space to add item!" );
		char* packet = (char*) malloc( 64 );
		memset( packet, 0, 64 );

		strcpy( packet, "item_not_added" );
		int packet_size = strlen( packet );

		int nbytes = send( client_fd, packet, packet_size, 0 );

		if ( nbytes != packet_size )
		{
			printf( "[-] Some error in clinet send!" );
			return SENDING_ERROR;
		}

		return NO_FREE_SPACE;
	}

	// find first free entry
	int new_item_idx = find_free_entry();

	if ( new_item_idx == -1 )
	{	
		char* packet = (char*) malloc( 64 );
		memset( packet, 0, 64 );

		strcpy( packet, "item_not_added" );
		int packet_size = strlen( packet );

		int nbytes = send( client_fd, packet, packet_size, 0 );

		if ( nbytes != packet_size )
		{
			printf( "[-] Some error in clinet send!" );
			return SENDING_ERROR;
		}

		printf( "[-] Cant find any free entry!" );
		return NO_FREE_SPACE;
	}

	if ( new_item_idx > g_market->max_item_id )
	{
		g_market->max_item_id = new_item_idx;
	}

	g_market->count_of_items += 1;
	g_market->chunks[ new_item_idx ].used = TRUE;

	// copy name to struct
	ptr = strtok( NULL, "|" );

	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	strcpy( g_market->chunks[ new_item_idx ].name, ptr );

	// copy description to struct
	ptr = strtok( NULL, "|" );
	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	strcpy( g_market->chunks[ new_item_idx ].description, ptr );

	// copy cost to struct
	ptr = strtok( NULL, "|" );
	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	g_market->chunks[ new_item_idx ].cost = atoi( ptr );

	// copy quality to struct
	ptr = strtok( NULL, "|" );
	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	g_market->chunks[ new_item_idx ].quality = atoi( ptr );

	// copy owner to struct
	ptr = strtok( NULL, "|" );
	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	strcpy( g_market->chunks[ new_item_idx ].owner, ptr );

	// set is archived
	ptr = strtok( NULL, "|" );
	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;
	}

	if ( atoi( ptr ) == 1 )
		g_market->chunks[ new_item_idx ].is_archived = TRUE;
	else
		g_market->chunks[ new_item_idx ].is_archived = FALSE;

	// set token
	ptr = strtok( NULL, "|" );
	g_market->chunks[ new_item_idx ].token = atoi( ptr );

	// copy password
	ptr = strtok( NULL, "|" );

	if ( ptr == NULL )
	{
		//printf( "SISGEV!!!, PACKET: %s\n", packet );
		return SENDING_ERROR;	
	}

	strcpy( g_market->chunks[ new_item_idx ].password, ptr );

	// update file on FS
	msync( (void*)g_market, MARKET_MAX_SIZE, MS_SYNC );

	// send correct code
	char* s_packet = (char*) malloc( 64 );
	memset( s_packet, 0, 64 );

	strcpy( s_packet, "item_added" );
	int packet_size = strlen( s_packet );

	int nbytes = send( client_fd, s_packet, packet_size, 0 );

	if ( nbytes != packet_size )
	{
		printf( "[-] Some error in clinet send!" );
		free( s_packet );
		return SENDING_ERROR;
	}

	free( s_packet );

	return ITEM_ADDED;
}
```


Overlapping Code:
```
tem( char* packet, int client_fd )
{
char* ptr = strtok( packet, "|" );
// check free space
int free_space = MARKET_MAX_SIZE - ( g_market->count_of_items * sizeof( market_item ) );
if ( free_space <= 0 )
{
printf( "[-] No available space to add item!" );
char* packet = (char*) malloc( 64 );
memset( packet, 0, 64 );
strcpy( packet, "item_not_added" );
int packet_size = strlen( packet );
int nbytes = send( client_fd, packet, packet_size, 0 );
if ( nbytes != packet_size )
{
printf( "[-] Some error in clinet send!" );
return SENDING_ERROR;
}
return NO_FREE_SPACE;
}
// find first free entry
int new_item_idx = find_free_entry();
if ( new_item_idx == -1 )
{ 
char* packet = (char*) malloc( 64 );
memset( packet, 0, 64 );
strcpy( packet, "item_not_added" );
int packet_size = strlen( packet );
int nbytes = send( client_fd, packet, packet_size, 0 );
if ( nbytes != packet_size )
{
printf( "[-] Some error in clinet send!" );
return SENDING_ERROR;
}
printf( "[-] Cant find any free entry!" );
return NO_FREE_SPACE;
}
if ( new_item_idx > g_market->max_item_id )
{
g_market->max_item_id = new_item_idx;
}
g_market->count_of_items += 1;
g_market->chunks[ new_item_idx ].used = TRUE;
// copy name to struct
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SENDING_ERROR;
}
strcpy( g_market->chunks[ new_item_idx ].name, ptr );
// copy description to struct
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SENDING_ERROR;
}
strcpy( g_market->chunks[ new_item_idx ].description, ptr );
// copy cost to struct
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SENDING_ERROR;
}
g_market->chunks[ new_item_idx ].cost = atoi( ptr );
// copy quality to struct
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SENDING_ERROR;
}
g_market->chunks[ new_item_idx ].quality = atoi( ptr );
// copy owner to struct
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SENDING_ERROR;
}
strcpy( g_market->chunks[ new_item_idx ].owner, ptr );
// set is archived
ptr = strtok( NULL, "|" );
if ( ptr == NULL )
{
//printf( "SISGEV!!!, PACKET: %s\n", packet );
return SEND
```
<Overlap Ratio: 0.9837745516652434>

---

--- 65 --
Question ID: ec120dc2eab18b1b8efe4ef74abb6693528717ad_78
Original Code:
```
static PyObject *__pyx_pf_6_loess_11loess_model_update(struct __pyx_obj_6_loess_loess_model *__pyx_v_self, PyObject *__pyx_v_modelargs) {
  PyObject *__pyx_v_family = NULL;
  PyObject *__pyx_v_span = NULL;
  PyObject *__pyx_v_degree = NULL;
  PyObject *__pyx_v_normalize = NULL;
  PyObject *__pyx_v_parametric = NULL;
  PyObject *__pyx_v_drop_square = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannySetupContext("update", 0);

  /* "_loess.pyx":393
 *     #........
 *     def update(self, **modelargs):
 *         family = modelargs.get('family', None)             # <<<<<<<<<<<<<<
 *         if family is not None:
 *             self.family = family
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_family, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_family = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":394
 *     def update(self, **modelargs):
 *         family = modelargs.get('family', None)
 *         if family is not None:             # <<<<<<<<<<<<<<
 *             self.family = family
 *         #
 */
  __pyx_t_2 = (__pyx_v_family != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "_loess.pyx":395
 *         family = modelargs.get('family', None)
 *         if family is not None:
 *             self.family = family             # <<<<<<<<<<<<<<
 *         #
 *         span = modelargs.get('span', None)
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_family, __pyx_v_family) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "_loess.pyx":397
 *             self.family = family
 *         #
 *         span = modelargs.get('span', None)             # <<<<<<<<<<<<<<
 *         if span is not None:
 *             self.span = span
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_span, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_span = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":398
 *         #
 *         span = modelargs.get('span', None)
 *         if span is not None:             # <<<<<<<<<<<<<<
 *             self.span = span
 *         #
 */
  __pyx_t_3 = (__pyx_v_span != Py_None);
  __pyx_t_2 = (__pyx_t_3 != 0);
  if (__pyx_t_2) {

    /* "_loess.pyx":399
 *         span = modelargs.get('span', None)
 *         if span is not None:
 *             self.span = span             # <<<<<<<<<<<<<<
 *         #
 *         degree = modelargs.get('degree', None)
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_span, __pyx_v_span) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 399; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "_loess.pyx":401
 *             self.span = span
 *         #
 *         degree = modelargs.get('degree', None)             # <<<<<<<<<<<<<<
 *         if degree is not None:
 *             self.degree = degree
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_degree, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 401; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_degree = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":402
 *         #
 *         degree = modelargs.get('degree', None)
 *         if degree is not None:             # <<<<<<<<<<<<<<
 *             self.degree = degree
 *         #
 */
  __pyx_t_2 = (__pyx_v_degree != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "_loess.pyx":403
 *         degree = modelargs.get('degree', None)
 *         if degree is not None:
 *             self.degree = degree             # <<<<<<<<<<<<<<
 *         #
 *         normalize = modelargs.get('normalize', None)
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_degree, __pyx_v_degree) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 403; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "_loess.pyx":405
 *             self.degree = degree
 *         #
 *         normalize = modelargs.get('normalize', None)             # <<<<<<<<<<<<<<
 *         if normalize is not None:
 *             self.normalize = normalize
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_normalize, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_normalize = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":406
 *         #
 *         normalize = modelargs.get('normalize', None)
 *         if normalize is not None:             # <<<<<<<<<<<<<<
 *             self.normalize = normalize
 *         #
 */
  __pyx_t_3 = (__pyx_v_normalize != Py_None);
  __pyx_t_2 = (__pyx_t_3 != 0);
  if (__pyx_t_2) {

    /* "_loess.pyx":407
 *         normalize = modelargs.get('normalize', None)
 *         if normalize is not None:
 *             self.normalize = normalize             # <<<<<<<<<<<<<<
 *         #
 *         parametric = modelargs.get('parametric', None)
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_normalize, __pyx_v_normalize) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "_loess.pyx":409
 *             self.normalize = normalize
 *         #
 *         parametric = modelargs.get('parametric', None)             # <<<<<<<<<<<<<<
 *         if parametric is not None:
 *             self.parametric_flags = parametric
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_parametric, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 409; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_parametric = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":410
 *         #
 *         parametric = modelargs.get('parametric', None)
 *         if parametric is not None:             # <<<<<<<<<<<<<<
 *             self.parametric_flags = parametric
 *         #
 */
  __pyx_t_2 = (__pyx_v_parametric != Py_None);
  __pyx_t_3 = (__pyx_t_2 != 0);
  if (__pyx_t_3) {

    /* "_loess.pyx":411
 *         parametric = modelargs.get('parametric', None)
 *         if parametric is not None:
 *             self.parametric_flags = parametric             # <<<<<<<<<<<<<<
 *         #
 *         drop_square = modelargs.get('drop_square', None)
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parametric_flags, __pyx_v_parametric) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 411; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "_loess.pyx":413
 *             self.parametric_flags = parametric
 *         #
 *         drop_square = modelargs.get('drop_square', None)             # <<<<<<<<<<<<<<
 *         if drop_square is not None:
 *             self.drop_square_flags = drop_square
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_modelargs, __pyx_n_s_drop_square, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 413; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_drop_square = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "_loess.pyx":414
 *         #
 *         drop_square = modelargs.get('drop_square', None)
 *         if drop_square is not None:             # <<<<<<<<<<<<<<
 *             self.drop_square_flags = drop_square
 *     #.........
 */
  __pyx_t_3 = (__pyx_v_drop_square != Py_None);
  __pyx_t_2 = (__pyx_t_3 != 0);
  if (__pyx_t_2) {

    /* "_loess.pyx":415
 *         drop_square = modelargs.get('drop_square', None)
 *         if drop_square is not None:
 *             self.drop_square_flags = drop_square             # <<<<<<<<<<<<<<
 *     #.........
 *     def __repr__(self):
 */
    if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_drop_square_flags, __pyx_v_drop_square) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "_loess.pyx":392
 *                 self._base.drop_square[i] = d_ndr[i]
 *     #........
 *     def update(self, **modelargs):             # <<<<<<<<<<<<<<
 *         family = modelargs.get('family', None)
 *         if family is not None:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("_loess.loess_model.update", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_family);
  __Pyx_XDECREF(__pyx_v_span);
  __Pyx_XDECREF(__pyx_v_degree);
  __Pyx_XDECREF(__pyx_v_normalize);
  __Pyx_XDECREF(__pyx_v_parametric);
  __Pyx_XDECREF(__pyx_v_drop_square);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
```


Overlapping Code:
```
e = NULL;
PyObject *__pyx_r = NULL;
__Pyx_RefNannyDeclarations
PyObject *__pyx_t_1 = NULL;
int __pyx_t_2;
int __pyx_t_3;
int __pyx_lineno = 0;
const char *__pyx_filename = NULL;
int __pyx_clineno = 0;
__Pyx_RefNannySetupContext("update", 0);
/* "/
__pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 393; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
__Pyx_GOTREF(__pyx_t_1);
__pyx_v_ != Py_None);
__pyx_t_3 = (__pyx_t_2 != 0);
if (__pyx_t_3) {
/* "
*/
if (__Pyx_PyObject_SetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_y) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 395; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
goto __pyx_L3;
}
__pyx_L3:;
/* "_/
__pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_, Py_None); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 397; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
__Pyx_GOTREF(__pyx_t_1);
__pyx_v_span = __pyx_t_1;
__pyx_t_1 = 
```
<Overlap Ratio: 0.4585456229735989>

---

--- 66 --
Question ID: 5d3b1c533c1f4280e2ef0ae4b119664eb85074cd_65
Original Code:
```
void f65(void) {
    	int32_t x395 = INT32_MIN;
	static int16_t x396 = INT16_MAX;
	volatile uint64_t t65 = 1LLU;

    t65 = ((x393%(x394*x395))*x396);

    if (t65 != 11261468142041563256LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x395 = INT32_MIN;
static int16_t x396 = INT16_MAX;
volatile uint64_t t65 = 1LLU;
t65 = ((x393%(x394*x395))*x396);
if (t65 != 11261468142041563256LLU) { NG(); } else { ; }

```
<Overlap Ratio: 0.9040404040404041>

---

--- 67 --
Question ID: fa974ae98315e5e55fd9b3b4850a7fd60135ad47_8
Original Code:
```
TaggedString *luaS_newfixedstring (char *str) {
  TaggedString *ts = luaS_new(str);
  if (ts->head.marked == 0)
    ts->head.marked = 2;  /* avoid GC */
  return ts;
}
```


Overlapping Code:
```
 *luaS_newfixedstring (char *str) {
TaggedString *ts = luaS_new(str);
if (ts->head.marked == 0)
ts->
```
<Overlap Ratio: 0.6410256410256411>

---

--- 68 --
Question ID: a102ecc7b281740e157675d9d8e2c88401bbb648_3
Original Code:
```
N_LIB_PRIVATE N_NIMCALL(NIM_BOOL, modeIsDir__L1LOhUxShkaoXfurkKTXPA)(mode_t m) {
	NIM_BOOL result;
	result = (NIM_BOOL)0;
	result = ((NI32)(m & ((NI32) 61440)) == ((NI32) 16384));
	return result;
}
```


Overlapping Code:
```
ATE N_NIMCALL(NIM_BOOL, modeIsDir__L1LOhUxShkaoXfurkKTXPA)(mode_t m) {
NIM_BOOL result;
result = (NIM_BOOL)0;
result = ((NI32)(m & ((NI32) 61440)) == ((NI32) 16384));
retur
```
<Overlap Ratio: 0.8911917098445595>

---

--- 69 --
Question ID: ecac46b9f86228ed04777ba1d859c21ec8156178_56
Original Code:
```
void f56(void) {
    	uint64_t x225 = 8541349LLU;
	static int64_t x226 = INT64_MAX;
	volatile uint32_t x228 = 32U;

    t56 = (x225&(x226!=(x227!=x228)));

    if (t56 != 1LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
uint64_t x225 = 8541349LLU;
static int64_t x226 = INT64_MAX;
volatile uint32_t x228 = 32U;
t56 = (x225&(x226!=(x227!=x228)));
if (t56 != 1LLU)
```
<Overlap Ratio: 0.819672131147541>

---

--- 70 --
Question ID: 14870111e8e9f65582c77c640e400bc4faaa0c34_3
Original Code:
```
int codec_gzip_create(int op, codec_t **piz)
{
    codec_gzip_t *iz = NULL;

    dbg_return_if (piz == NULL, ~0);

    iz = u_zalloc(sizeof(codec_gzip_t));
    dbg_err_if(iz == NULL);

    iz->codec.transform = gzip_transform;
    iz->codec.flush = gzip_flush;
    iz->codec.free = gzip_free;
    iz->action = op; 

    switch(op)
    {
    case GZIP_COMPRESS:
        iz->op = deflate;
        iz->opEnd = deflateEnd;
        dbg_err_if(deflateInit2(&iz->zstr, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
                    -MAX_WBITS, 8, Z_DEFAULT_STRATEGY));
        break;
    case GZIP_UNCOMPRESS:
        iz->op = inflate;
        iz->opEnd = inflateEnd;
        dbg_err_if(inflateInit2(&iz->zstr, -MAX_WBITS) != Z_OK);
        break;
    default:
        dbg_err_if("bad gzip op");
    }

    *piz = (codec_t*)iz;

    return 0;
err:
    U_FREE(iz);
    return ~0;
}
```


Overlapping Code:
```
dec_gzip_t *iz = NULL;
dbg_return_if (piz == NULL, ~0);
iz = u_zalloc(sizeof(codec_gzip_t));
dbg_err_if(iz == NULL);
iz->codec.transform = gzip_transform;
iz->codec.flush = gzip_flush;
iz->codec.free = gzip_free;
iz->action = op; 
switch(op)
{
case GZIP_COMPRESS:
iz->op = deflate;
iz->opEnd = deflateEnd;
dbg_err_if(deflateInit2(&iz->zstr, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
-MAX_WBITS, 8, Z_DEFAULT_STRATEGY));
break;
case GZIP_UNCOMPRESS:
iz->op = inflate;
iz->opEnd = inflateEnd;
dbg_err_if(inflateInit2(&iz->zstr, -MAX_WBITS) != Z_OK);
break;
default:
dbg_err_if("bad gzip op");
}
*piz = (codec_
```
<Overlap Ratio: 0.8633093525179856>

---

--- 71 --
Question ID: 2cd667986665007d48ac9cb503313e651e5e9e7b_4
Original Code:
```
static void func_die (void *vo)
{
    struct instance *o = vo;
    ASSERT(!o->dying)
    
    // if we're finished, die immediately
    if (o->state == STATE_FINISHED) {
        instance_free(o);
        return;
    }
    
    // set dying
    o->dying = 1;
    
    // start terminating if not already
    if (o->state == STATE_INIT) {
        start_terminating(o);
    }
}
```


Overlapping Code:
```
static void func_die (void *vo)
{
struct instance *o = vo;
ASSERT(!o->dying)

// if we're finished, die immediately
if (o->state == STATE_FINISHED) {
instance_free(o);
return;
}

// set dying
o->dying = 1;

// start terminating if not already
if (o->state == STATE_INIT) {
start_terminating(o);

```
<Overlap Ratio: 0.9899328859060402>

---

--- 72 --
Question ID: 5bb15aa79d02c6f024cb4959fe3f2a91bc24ef31_1
Original Code:
```
void f1(void) {
    	static volatile int8_t x6 = -1;
	static int32_t x7 = INT32_MAX;
	uint8_t x8 = 49U;

    t1 = ((x5^(x6>x7))+x8);

    if (t1 != 32816) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 = -1;
static int32_t x7 = INT32_MAX;
uint8_t x8 = 49U;
t1 = ((x5^(x6>x7))+x8);
if (t1 != 32816) { N
```
<Overlap Ratio: 0.6211180124223602>

---

--- 73 --
Question ID: d90c21722021698727a73342320d99dbf9f6208d_2
Original Code:
```
size_t phy_read()
{
	// streaming data and concat to ibuf
	int rdlen = read(fd, ibuf.buf + ibuf.len, BUFFER_SIZE - ibuf.len);
	
#ifdef DEBUG
	if (rdlen) {
		printf("\033[33mrcvd\t");
		for (int i = 0; i < rdlen; ++i) {
			if (i && i % 16 == 0)
				printf("\n\t");
			printf("%02x ", ibuf.buf[ibuf.len + i]);
		}
		printf("\n\033[0m");
	}
#endif

	ibuf.len += rdlen;
	return rdlen;
}
```


Overlapping Code:
```
cat to ibuf
int rdlen = read(fd, ibuf.buf + ibuf.len, BUFFER_SIZE - ibuf.len);

#ifdef DEBUG
if (rdlen) {
printf("\033[33mrcvd\t");
for (int i = 0; i < rdlen; ++i) {
if (i && i % 16 == 0)
printf("\n\t");
printf("%02x ", ibuf.buf[ibuf.len + i]);
}
printf("\n\033[0m");
}
#endif
ibuf.len += rdlen;
retu
```
<Overlap Ratio: 0.8426966292134831>

---

--- 74 --
Question ID: ee3f0cfb695788ff0a492dcb5377e5368bd16051_128
Original Code:
```
void f128(void) {
    	int8_t x617 = -1;
	uint8_t x618 = 4U;
	int32_t x619 = INT32_MIN;
	static int32_t t128 = 188;

    t128 = (((x617-x618)-x619)<=x620);

    if (t128 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
18 = 4U;
int32_t x619 = INT32_MIN;
static int32_t t128 = 188;
t128 = (((x617-x618)-x619)<=x620);
if 
```
<Overlap Ratio: 0.5524861878453039>

---

--- 75 --
Question ID: 3fd3bcc038bceef9b011769072333cc8288f75d7_1
Original Code:
```
void    ft_gui_int_label_scroll(t_tts_gui *env, t_gui_component *field)
{
    t_gui_int_label *data;
    t_list_node     *current_node;

    (void)env;
    current_node = NULL;
    data = field->data;
    if (!(*data->sector))
        *(data->sector) = data->env->data.sectors.first->content;
    else
    {
        data->env->data.sectors.iterator = data->env->data.sectors.first;
        while ((current_node = ttslist_iter(&(data->env->data.sectors))))
        {
            if (current_node->content == *(data->sector))
                break;
        }
        if (current_node)
        {
            if (field->event.e.wheel.y > 0)
            {
                current_node = current_node->next;
                if (!current_node)
                    current_node = data->env->data.sectors.first;
            }
            else
            {
                current_node = current_node->prev;
                if (!current_node)
                    current_node = data->env->data.sectors.last;
            }
            if (current_node)
                *(data->sector) = current_node->content;
        }
    }
}
```


Overlapping Code:
```
ts_gui *env, t_gui_component *field)
{
t_gui_int_label *data;
t_list_node *current_node;
(void)env;
current_node = NULL;
data = field->data;
if (!(*data->sector))
*(data->sector) = data->env->data.sectors.first->content;
else
{
data->env->data.sectors.iterator = data->env->data.sectors.first;
while ((current_node = ttslist_iter(&(data->env->data.sectors))))
{
if (current_node->content == *(data->sector))
break;
}
if (current_node)
{
if (field->event.e.wheel.y > 0)
{
current_node = current_node->next;
if (!current_node)
current_node = data->env->data.sectors.first;
}
else
{
current_node = current_node->prev;
if (!current_node)
current_node = data->env->data.sectors.last;
}
if (current_node)
*
```
<Overlap Ratio: 0.9009009009009009>

---

--- 76 --
Question ID: 6c90306ea1e75f8419771f211e543a6ea235b910_175
Original Code:
```
static int
model_crisv32_bcc_w (SIM_CPU *current_cpu, void *sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bcc_w.f
  const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
  const IDESC * UNUSED idesc = abuf->idesc;
  int cycles = 0;
  {
    int referenced = 0;
    int UNUSED insn_referenced = abuf->written;
    cycles += crisv32f_model_crisv32_u_const16 (current_cpu, idesc, 0, referenced);
  }
  {
    int referenced = 0;
    int UNUSED insn_referenced = abuf->written;
    cycles += crisv32f_model_crisv32_u_branch (current_cpu, idesc, 1, referenced);
  }
  {
    int referenced = 0;
    int UNUSED insn_referenced = abuf->written;
    INT in_Rd = -1;
    INT in_Rs = -1;
    INT out_Rd = -1;
    cycles += crisv32f_model_crisv32_u_exec (current_cpu, idesc, 2, referenced, in_Rd, in_Rs, out_Rd);
  }
  return cycles;
#undef FLD
}
```


Overlapping Code:
```
 (SIM_CPU *current_cpu, void *sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bcc_w.f
const ARGBUF * UNUSED abuf = SEM_ARGBUF ((SEM_ARG) sem_arg);
const IDESC * UNUSED idesc = abuf->idesc;
int cycles = 0;
{
int referenced = 0;
int UNUSED insn_referenced = abuf->written;
cycles += crisv32f_model_crisv32_u_const16 (current_cpu, idesc, 0, referenced);
}
{
int referenced = 0;
int UNUSED insn_referenced = abuf->written;
cycles += crisv32f_model_crisv32_u_branch (current_cpu, idesc, 1, referenced);
}
{
int referenced = 0;
int UNUSED insn_referenced = abuf->written;
INT in_Rd = -1;
INT in_Rs = -1;
INT out_Rd = -1;
cycles += crisv32f_model_crisv32_u_exec (current_cpu, idesc, 2, referenced, in_Rd, in_Rs, out_Rd);
}
return cycles;
#undef FLD
}
```
<Overlap Ratio: 0.9609882964889467>

---

--- 77 --
Question ID: cbcc06a55ae0651917694020a14fe6daeee8e92f_0
Original Code:
```
class SettingsForm : public QWidget
{
    Q_OBJECT

public:
    explicit SettingsForm(QWidget *parent = 0);
    ~SettingsForm();

    void setText(QString &text);

private:
    Ui::SettingsForm *ui;
}
```


Overlapping Code:
```
class SettingsForm : public QWidget
{
Q_OBJECT
public:
explicit SettingsForm(QWidget *parent = 0);
~SettingsForm();
void setText(QString &text);
private
```
<Overlap Ratio: 0.8587570621468926>

---

--- 78 --
Question ID: a5705a56b9234c5d31d71683e7fd7702d17624a9_0
Original Code:
```
VOID tim5_capture_ISR(u32 channel)
{	
	timout_cnt++;
	if(timout_cnt % 2){
		value1 = RTIM_CCRxGet(TIM5, channel) & 0xffff;
	}
	else{
		value2 = RTIM_CCRxGet(TIM5, channel) & 0xffff;
		timout_cnt = 0;

		if(value2 > value1)
			DBG_8195A("frequency: %d\n", 40000000/(value2 - value1));
		else
			DBG_8195A("frequency: %d\n", 40000000/(PWM_PERIOD + 1 - value1 + value2));
	}

	RTIM_INTClear(TIM5);
}
```


Overlapping Code:
```
annel)
{ 
timout_cnt++;
if(timout_cnt % 2){
value1 = RTIM_CCRxGet(TIM5, channel) & 0xffff;
}
else{
value2 = RTIM_CCRxGet(TIM5, channel) & 0xffff;
timout_cnt = 0;
if(value2 > value1)
DBG_8195A("frequency: %d\n", 40000000/(value2 - value1));
else
DBG_8195A("frequency: %d\n", 40000000/(PWM_PERIOD + 1 -
```
<Overlap Ratio: 0.8064516129032258>

---

--- 79 --
Question ID: ab78fb58a5325ef8ba9f736bcf800186886c4f7c_185
Original Code:
```
void f185(void) {
    	int8_t x6213 = -1;
	static int32_t x6214 = INT32_MIN;
	uint32_t x6215 = UINT32_MAX;
	uint16_t x6216 = 11U;

    t185 = ((x6213<=(x6214!=x6215))>>x6216);

    if (t185 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f185(void) {
int8_t x6213 = -1;
static int32_t x6214 = INT32_MIN;
uint32_t x6215 = UINT32_MAX;
uint16_t x6216 = 11U;
t185 = ((x6213<=(x6214!=x6215))>
```
<Overlap Ratio: 0.746268656716418>

---

--- 80 --
Question ID: b5c23f1adff2bfd76eecdcbe0ea620d9d4e41eee_3
Original Code:
```
int file_getInfo(id_t fid, size_t *sectors, size_t *filesz, size_t *recordsz, size_t *recordcnt)
{
	meterfs_i_devctl_t iptr;
	meterfs_o_devctl_t optr;
	int err;

	iptr.type = meterfs_info;
	iptr.id = fid;

	if ((err = hostflashsrv_devctl(&iptr, &optr)) < 0)
		return err;

	if (sectors != NULL)
		(*sectors) = optr.info.sectors;

	if (filesz != NULL)
		(*filesz) = optr.info.filesz;

	if (recordsz != NULL)
		(*recordsz) = optr.info.recordsz;

	if (recordcnt != NULL)
		(*recordcnt) = optr.info.recordcnt;

	return 0;
}
```


Overlapping Code:
```
e_getInfo(id_t fid, size_t *sectors, size_t *filesz, size_t *recordsz, size_t *recordcnt)
{
meterfs_i_devctl_t iptr;
meterfs_o_devctl_t optr;
int err;
iptr.type = meterfs_info;
iptr.id = fid;
if ((err = hostflashsrv_devctl(&iptr, &optr)) < 0)
return err;
if (sectors != NULL)
(*sectors) = optr.info.sectors;
if (filesz != NULL)
(*filesz) = optr.info.filesz;
if (recordsz != NULL)
(*recordsz) = optr.info.recordsz;
if (recordcnt != NULL)
(*recordcnt) 
```
<Overlap Ratio: 0.9164969450101833>

---

--- 81 --
Question ID: 04c387bc69ea45f11abe30b99cd924e05ec74140_1
Original Code:
```
static void
error_test1(void)
{
	void *env = sp_env();
	t( env != NULL );
	int rc = sp_error(env);
	t( rc == 0 );
	t( sp_destroy(env) == 0 );
}
```


Overlapping Code:
```
_test1(void)
{
void *env = sp_env();
t( env != NULL );
int rc = sp_error
```
<Overlap Ratio: 0.5217391304347826>

---

--- 82 --
Question ID: cff544bc8f3c838531d129f7aa2f9de0588eaf8b_159
Original Code:
```
void f159(void) {
    	uint64_t x637 = UINT64_MAX;
	int16_t x638 = 4010;
	int32_t x639 = -1;
	uint16_t x640 = 3097U;
	int32_t t159 = 172446755;

    t159 = (x637<=((x638<=x639)^x640));

    if (t159 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f159(void) {
uint64_t x637 = UINT64_MAX;
int16_t x638 = 4010;
int32_t x639 = -1;
uint16_t x640 = 3097U;
int32_t t159 = 172446755;
t159 = (x637<=((x638<=x639)^x640));
if (t159 != 0) { NG(); } else { ; }


```
<Overlap Ratio: 0.9760765550239234>

---

--- 83 --
Question ID: 4d1bc463ccc6349ae51c4105ffb8ece5f0a297fa_13
Original Code:
```
BOOLEAN
QuicHashTableExpand(
    _Inout_ QUIC_HASHTABLE* HashTable
    )
{
    //
    // Can't expand if we've reached the maximum.
    //
    if (HashTable->TableSize == MAX_HASH_TABLE_SIZE) {
        return FALSE;
    }

    if (HashTable->NumEnumerators > 0) {
        return FALSE;
    }

    QUIC_DBG_ASSERT(HashTable->TableSize < MAX_HASH_TABLE_SIZE);

    //
    // First see if increasing the table size will mean new allocations. After
    // the hash table is increased by one, the highest bucket index will be the
    // current table size, which is what we use in the calculations below
    //
    uint32_t FirstLevelIndex, SecondLevelIndex;
    QuicComputeDirIndices(
        HashTable->TableSize, &FirstLevelIndex, &SecondLevelIndex);

    //
    // Switch to the multi-dir mode in case of the only second-level directory
    // is about to be expanded.
    //

    QUIC_LIST_ENTRY* SecondLevelDir;
    QUIC_LIST_ENTRY** FirstLevelDir;
    if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {

        SecondLevelDir = (QUIC_LIST_ENTRY*)HashTable->SecondLevelDir;
        FirstLevelDir = QUIC_ALLOC_NONPAGED(sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);

        if (FirstLevelDir == NULL) {
            return FALSE;
        }

        QuicZeroMemory(FirstLevelDir,
                      sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);

        FirstLevelDir[0] = SecondLevelDir;

        HashTable->FirstLevelDir = FirstLevelDir;
    }

    QUIC_DBG_ASSERT(HashTable->FirstLevelDir != NULL);
    FirstLevelDir = HashTable->FirstLevelDir;
    SecondLevelDir = FirstLevelDir[FirstLevelIndex];

    if (SecondLevelDir == NULL) {

        //
        // Allocate second level directory.
        //
        SecondLevelDir =
            QUIC_ALLOC_NONPAGED(
                QuicComputeSecondLevelDirSize(FirstLevelIndex) * sizeof(QUIC_LIST_ENTRY));
        if (NULL == SecondLevelDir) {

            //
            // If allocation failure happened on attempt to restructure the
            // table, switch it back to direct mode.
            //

            if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {

                QUIC_DBG_ASSERT(FirstLevelIndex == 1);

                HashTable->SecondLevelDir = FirstLevelDir[0];
                QUIC_FREE(FirstLevelDir);
            }

            return FALSE;
        }

        FirstLevelDir[FirstLevelIndex] = SecondLevelDir;
    }

    HashTable->TableSize++;

    //
    // The allocations are out of the way. Now actually increase
    // the Table size and split the pivot bucket.
    //
    QUIC_LIST_ENTRY* ChainToBeSplit =
        QuicGetChainHead(HashTable, HashTable->Pivot);
    HashTable->Pivot++;

    QUIC_LIST_ENTRY* NewChain = &(SecondLevelDir[SecondLevelIndex]);
    QuicListInitializeHead(NewChain);

    if (!QuicListIsEmpty(ChainToBeSplit)) {

        QUIC_LIST_ENTRY* CurEntry = ChainToBeSplit;
        while (CurEntry->Flink != ChainToBeSplit) {

            QUIC_LIST_ENTRY* NextEntry = CurEntry->Flink;
            QUIC_HASHTABLE_ENTRY* NextHashEntry =
                QuicFlinkToHashEntry(&NextEntry->Flink);

            uint32_t BucketIndex =
                ((uint32_t)NextHashEntry->Signature) &
                ((HashTable->DivisorMask << 1) | 1);

            QUIC_DBG_ASSERT((BucketIndex == (HashTable->Pivot - 1)) ||
                   (BucketIndex == (HashTable->TableSize - 1)));

            if (BucketIndex == (HashTable->TableSize - 1)) {
                QuicListEntryRemove(NextEntry);
                QuicListInsertTail(NewChain, NextEntry);
                continue;
            }

            //
            // If the NextEntry falls in the same bucket, move on.
            //
            CurEntry = NextEntry;
        }

        if (!QuicListIsEmpty(NewChain)) {
            HashTable->NonEmptyBuckets++;
        }

        if (QuicListIsEmpty(ChainToBeSplit)) {
            QUIC_DBG_ASSERT(HashTable->NonEmptyBuckets > 0);
            HashTable->NonEmptyBuckets--;
        }
    }

    if (HashTable->Pivot == (HashTable->DivisorMask + 1)) {
        HashTable->DivisorMask = (HashTable->DivisorMask << 1) | 1;
        HashTable->Pivot = 0;

        //
        // Assert that at this point, TableSize is a power of 2.
        //
        QUIC_DBG_ASSERT(0 == (HashTable->TableSize & (HashTable->TableSize - 1)));
    }

    return TRUE;
}
```


Overlapping Code:
```
shTableExpand(
_Inout_ QUIC_HASHTABLE* HashTable
)
{
//
// Can't expand if we've reached the maximum.
//
if (HashTable->TableSize == MAX_HASH_TABLE_SIZE) {
return FALSE;
}
if (HashTable->NumEnumerators > 0) {
return FALSE;
}
QUIC_DBG_ASSERT(HashTable->TableSize < MAX_HASH_TABLE_SIZE);
//
// First see if increasing the table size will mean new allocations. After
// the hash table is increased by one, the highest bucket index will be the
// current table size, which is what we use in the calculations below
//
uint32_t FirstLevelIndex, SecondLevelIndex;
QuicComputeDirIndices(
HashTable->TableSize, &FirstLevelIndex, &SecondLevelIndex);
//
// Switch to the multi-dir mode in case of the only second-level directory
// is about to be expanded.
//
QUIC_LIST_ENTRY* SecondLevelDir;
QUIC_LIST_ENTRY** FirstLevelDir;
if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {
SecondLevelDir = (QUIC_LIST_ENTRY*)HashTable->SecondLevelDir;
FirstLevelDir = QUIC_ALLOC_NONPAGED(sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);
if (FirstLevelDir == NULL) {
return FALSE;
}
QuicZeroMemory(FirstLevelDir,
sizeof(QUIC_LIST_ENTRY*) * HT_FIRST_LEVEL_DIR_SIZE);
FirstLevelDir[0] = SecondLevelDir;
HashTable->FirstLevelDir = FirstLevelDir;
}
QUIC_DBG_ASSERT(HashTable->FirstLevelDir != NULL);
FirstLevelDir = HashTable->FirstLevelDir;
SecondLevelDir = FirstLevelDir[FirstLevelIndex];
if (SecondLevelDir == NULL) {
//
// Allocate second level directory.
//
SecondLevelDir =
QUIC_ALLOC_NONPAGED(
QuicComputeSecondLevelDirSize(FirstLevelIndex) * sizeof(QUIC_LIST_ENTRY));
if (NULL == SecondLevelDir) {
//
// If allocation failure happened on attempt to restructure the
// table, switch it back to direct mode.
//
if (HT_SECOND_LEVEL_DIR_MIN_SIZE == HashTable->TableSize) {
QUIC_DBG_ASSERT(FirstLevelIndex == 1);
HashTable->SecondLevelDir = FirstLevelDir[0];
QUIC_FREE(FirstLevelDir);
}
return FALSE;
}
FirstLevelDir[FirstLevelIndex] = SecondLevelDir;
}
HashTable->Tab
```
<Overlap Ratio: 0.9702233250620348>

---

--- 84 --
Question ID: d3854fcc03c85c901cef0586e920f5cebffffbd2_147
Original Code:
```
void f147(void) {
    	uint64_t x8058 = 33421391037LLU;
	uint32_t x8059 = UINT32_MAX;
	static uint32_t x8060 = UINT32_MAX;
	volatile uint64_t t147 = 172901721823295615LLU;

    t147 = ((x8057-x8058)>>(x8059*x8060));

    if (t147 != 9223372022291563937LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d) {
uint64_t x8058 = 33421391037LLU;
uint32_t x8059 = UINT32_MAX;
static uint32_t x8060 = UINT32_MAX;
volatile uint64_t t147 = 172901721823295615LLU;
t147 = ((x8057-x8058)>>(x8059*x8060));
if (t147 !
```
<Overlap Ratio: 0.7633587786259542>

---

--- 85 --
Question ID: 1ea354b62734788e7adeecf81c65062941794e35_12
Original Code:
```
void f12(void) {
    	uint16_t x61 = 30U;
	volatile uint64_t x62 = UINT64_MAX;
	uint64_t x63 = 203562LLU;
	volatile uint32_t x64 = UINT32_MAX;
	volatile int32_t t12 = 29;

    t12 = (x61-((x62+x63)!=x64));

    if (t12 != 29) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
uint16_t x61 = 30U;
volatile uint64_t x62 = UINT64_MAX;
uint64_t x63 = 203562LLU;
volatile uint32_t x64 = UINT32_MAX;
volatile int32_t t12 = 29;
t12 = (x61-((x62+x63)!=x64));
if (t12 != 29) {
```
<Overlap Ratio: 0.8695652173913043>

---

--- 86 --
Question ID: 2ce3d15eba4c70d2282b8bc98e7c926ee6a02a29_132
Original Code:
```
void f132(void) {
    	int64_t x1055 = -7098LL;
	int32_t t132 = -792099;

    t132 = ((x1053%(x1054>x1055))+x1056);

    if (t132 != 1101) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
32(void) {
int64_t x1055 = -7098LL;
int32_t t132 = -792099;
t132 = ((x1053%(x1054>x1055))+x1056);
if
```
<Overlap Ratio: 0.684931506849315>

---

--- 87 --
Question ID: c5f04497aaced232a18bd02f1b9628eefa3eb069_0
Original Code:
```
void create(){
	::create();
	set_name("Sturdy Boots");
	set_id(({ "boots", "leather boots", "sturdy leather boots", "sturdy boots" }));
	set_short("%^RESET%^%^ORANGE%^Mi%^BOLD%^%^BLACK%^n%^RESET%^%^ORANGE%^er's Foo%^BOLD%^%^BLACK%^t%^RESET%^%^ORANGE%^gear%^RESET%^");
	set_obvious_short("%^RESET%^%^ORANGE%^Sturdy Leather Boots%^RESET%^");
	set_long(
@AVATAR
%^RESET%^%^ORANGE%^This is a pair of sturdy and heavy leather boots.  They seem to be shaped in a squarish manner, and have a thick sole to match.  They appear to be made of a very thick leather which seems rather stiff, but quite protective.  Faint scuffmarks mar the leather in places, but any aging doesn't appear to have damaged the boots severely.%^RESET%^

AVATAR
	);
	set_weight(10);
	set_value(150);
	set_type("clothing");
	set_limbs(({ "right foot", "left foot" }));
	set_size(1);
	set_property("enchantment",1);
}
```


Overlapping Code:
```
turdy Boots");
set_id(({ "boots", "leather boots", "sturdy leather boots", "sturdy boots" }));
set_short("%^RESET%^%^ORANGE%^Mi%^BOLD%^%^BLACK%^n%^RESET%^%^ORANGE%^er's Foo%^BOLD%^%^BLACK%^t%^RESET%^%^ORANGE%^gear%^RESET%^");
set_obvious_short("%^RESET%^%^ORANGE%^Sturdy Leather Boots%^RESET%^");
set_long(
@AVATAR
%^RESET%^%^ORANGE%^This is a pair of sturdy and heavy leather boots. They seem to be shaped in a squarish manner, and have a thick sole to match. They appear to be made of a very thick leather which seems rather stiff, but quite protective. Faint scuffmarks mar the leather in places, but any aging doesn't appear to have damaged the boots severely.%^RESET%^
AVATAR
);
set_weight(10);
set_value(150);
set_type("clothing");
set_limbs(({ "right foot", "left foot" }));
set_size(1);
set_propert
```
<Overlap Ratio: 0.9317919075144508>

---

--- 88 --
Question ID: 4a645f0b0ce7a13c04d46eb9c62cf4acfdc63656_143
Original Code:
```
void f143(void) {
    	int16_t x601 = -1919;
	int8_t x602 = -3;
	uint64_t x603 = UINT64_MAX;
	static int8_t x604 = -42;

    t143 = ((x601-(x602==x603))/x604);

    if (t143 != 45) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
8_t x602 = -3;
uint64_t x603 = UINT64_MAX;
static int8_t x604 = -42;
t143 = ((x601-(x602==x603))/x60
```
<Overlap Ratio: 0.5376344086021505>

---

--- 89 --
Question ID: a0b8c47d8f4939b91917e2e5140fbf603a8f36ad_4
Original Code:
```
void build_hyper_graph_r(unsigned int R)
    {
        if( R > INT_MAX ){
            cout<<"Error:R too large"<<endl;
            exit(1);
        }    
		//every time starts from scratch
		auto counter = hyperGT.size();
		while (counter < R)BuildHypergraphNode(counter++);		
    }
```


Overlapping Code:
```
er_graph_r(unsigned int R)
{
if( R > INT_MAX ){
cout<<"Error:R too large"<<endl;
exit(1);
} 
//every time starts from scratch
auto counter = hyperGT.size();
while (counter < R)BuildHypergraphNode(coun
```
<Overlap Ratio: 0.8928571428571429>

---

--- 90 --
Question ID: 390c5db5150a1ee029a10905c402b2c13ee0c7c9_0
Original Code:
```
void uartInit()
{
	UCSR0B |= (1 << TXEN0 )|(1 << RXEN0 );	// UART Senden und empfangen einschalten
	UBRR0 = UBRR_VAL;				//Baudrate einstellen, die im Header-File definiert wurde
}
```


Overlapping Code:
```
 uartInit()
{
UCSR0B |= (1 << TXEN0 )|(1 << RXEN0 ); // UART Senden und empfangen einschalten
UBRR0 = UBRR_VAL; //Baudrate einstellen, die im Header-F
```
<Overlap Ratio: 0.8571428571428571>

---

--- 91 --
Question ID: 888558657dab409afbce5758a694193caf93d83d_0
Original Code:
```
int main(int argc, char *argv[])
{
   int l;
   int c;

  for (int k=0; k<sizeof(s)/sizeof(char *);k++) {
    s1=s[k];
   l=u8next(s1,&c);
   dbgchk(l==k+1,"Wrong length: expected %d, got %d",k+1,l);
   dbgchk(c==cp[k],"Wrong code: expected %06X, got %06X",cp[k],c);
   l=u8next_FAST(s1,&c);
   dbgchk(l==k+1,"(FAST) Wrong length: expected %d, got %d",k+1,l);
   dbgchk(c==cp[k],"(FAST) Wrong code: expected %06X, got %06X",cp[k],c);
  }

}
```


Overlapping Code:
```

{
int l;
int c;
for (int k=0; k<sizeof(s)/sizeof(char *);k++) {
s1=s[k];
l=u8next(s1,&c);
dbgchk(l==k+1,"Wrong length: expected %d, got %d",k+1,l);
dbgchk(c==cp[k],"Wrong code: expected %06X, got %06X",cp[k],c);
l=u8next_FAST(s1,&c);
dbgchk(l==k+1,"(FAST) Wrong length: expected %d, got %d",k+1,l);
dbgchk(c==cp[k],"(FAST) Wrong code: expected %06X,
```
<Overlap Ratio: 0.8620689655172413>

---

--- 92 --
Question ID: 7d8b4c9c085d8a496fdc66bd3dab6200e2dff6be_44
Original Code:
```
void f44(void) {
    	int64_t x197 = 397LL;
	int8_t x198 = 0;

    t44 = (x197&((x198/x199)/x200));

    if (t44 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
= 397LL;
int8_t x198 = 0;
t44 = (x197&((x198/x199)
```
<Overlap Ratio: 0.390625>

---

--- 93 --
Question ID: f20091ceb9d4c513b8a09423abbf54a354e1510e_165
Original Code:
```
void f165(void) {
    	int8_t x1769 = INT8_MAX;
	static volatile uint8_t x1770 = 32U;
	volatile int32_t t165 = -36401783;

    t165 = ((x1769*x1770)%(x1771/x1772));

    if (t165 != 4064) { NG(); } else { ; }
	
}
```


Overlapping Code:
```

static volatile uint8_t x1770 = 32U;
volatile int32_t t165 = -36401783;
t165 = ((x1769*x1770)%(x1771/x1772));
if (t165 != 4064) { NG(); } else { ; }

```
<Overlap Ratio: 0.7731958762886598>

---

--- 94 --
Question ID: 52eb074f39278057edcf9a4fd57314e6a3907c3c_0
Original Code:
```
void kettle_gpio_init()
{
    //led pin init
    tuya_pin_init(led1_pin, TUYA_PIN_MODE_OUT_PP_HIGH);
    tuya_pin_init(led2_pin, TUYA_PIN_MODE_OUT_PP_HIGH);
    //buzzer pin init
    tuya_pin_init(buzzer_pin, TUYA_PIN_MODE_OUT_PP_LOW);
    //relay pin init
    tuya_pin_init(relay_pin, TUYA_PIN_MODE_OUT_PP_LOW);
}
```


Overlapping Code:
```
/led pin init
tuya_pin_init(led1_pin, TUYA_PIN_MODE_OUT_PP_HIGH);
tuya_pin_init(led2_pin, TUYA_PIN_MODE_OUT_PP_HIGH);
//buzzer pin init
tuya_pin_init(buzzer_pin, TUYA_PIN_MODE_OUT_PP_LOW);
//relay pin init
tuya_pin_init(relay_pin, TUYA_PIN_MODE_OUT_P
```
<Overlap Ratio: 0.8741258741258742>

---

--- 95 --
Question ID: e3335b8a6861fbf799576a43725fcc2ebf3aefcc_59
Original Code:
```
void f59(void) {
    	static uint16_t x253 = 126U;
	uint16_t x254 = UINT16_MAX;
	volatile int16_t x255 = 1;
	static uint32_t x256 = 158329U;
	uint32_t t59 = 56350816U;

    t59 = (((x253/x254)+x255)|x256);

    if (t59 != 158329U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
nt16_t x253 = 126U;
uint16_t x254 = UINT16_MAX;
volatile int16_t x255 = 1;
static uint32_t x256 = 158329U;
uint32_t t59 = 56350816U;
t59 = (((x253/x254)+x255)|x256);
if (t59 != 158329U) { NG(); } else
```
<Overlap Ratio: 0.851063829787234>

---

--- 96 --
Question ID: 176dccadf239629710c950fd2ddc688bdd1cd21e_25
Original Code:
```
void f25(void) {
    	int8_t x121 = -1;
	uint8_t x123 = 0U;
	uint16_t x124 = 2U;
	volatile int32_t t25 = -37;

    t25 = ((x121-(x122!=x123))-x124);

    if (t25 != -4) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
= -1;
uint8_t x123 = 0U;
uint16_t x124 = 2U;
volatile int32_t t25 = -37;
t25 = ((x121-(x122!=x123))-
```
<Overlap Ratio: 0.5747126436781609>

---

--- 97 --
Question ID: e1ae4146e0578d082aadc59ebf2c6b28fc2a86f4_15
Original Code:
```
void f15(void) {
    	uint8_t x383 = 58U;
	int32_t x384 = 0;
	volatile int32_t t15 = -230009;

    t15 = (((x381!=x382)!=x383)>>x384);

    if (t15 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
uint8_t x383 = 58U;
int32_t x384 = 0;
volatile int32_t t15 = -230009;
t15 = (((x381!=x382)!=x383)>>x384);
if (t15 != 1) { NG(); } else { ; }


```
<Overlap Ratio: 0.9375>

---

--- 98 --
Question ID: 95196c93dfa00c3ab62982220cc8bcec84292d8f_11
Original Code:
```
void f11(void) {
    	static volatile uint64_t x45 = 749507480118404436LLU;
	uint32_t x46 = 11803U;
	static int32_t x47 = INT32_MAX;
	static int8_t x48 = -1;
	static volatile uint64_t t11 = 121323075143682LLU;

    t11 = (x45^(x46!=(x47<=x48)));

    if (t11 != 749507480118404437LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
c volatile uint64_t x45 = 749507480118404436LLU;
uint32_t x46 = 11803U;
static int32_t x47 = INT32_MAX;
static int8_t x48 = -1;
static volatile uint64_t t11 = 121323075143682LLU;
t11 = (x45^(x46!=(x47<=x48)));
if (t11 != 749507480118404437LLU) { NG()
```
<Overlap Ratio: 0.8650519031141869>

---

--- 99 --
Question ID: 06f37f40689bcdce12f9fbe1bd269371b28841c8_3
Original Code:
```
void SetAbsTol(double hydrol_tol, double sminn_tol, N_Vector abstol)
{
    int             i;

    /* Set absolute errors for hydrologic state variables */
#if defined(_OPENMP)
# pragma omp parallel for
#endif
    for (i = 0; i < 3 * nelem + 2 * nriver; i++)
    {
        NV_Ith(abstol, i) = (realtype)hydrol_tol;
    }

    /* Set absolute errors for nitrogen state variables */
#if defined(_OPENMP)
# pragma omp parallel for
#endif
    for (i = 3 * nelem + 2 * nriver; i < NumStateVar(); i++)
    {
        NV_Ith(abstol, i) = (realtype)sminn_tol;
    }
}
```


Overlapping Code:
```
 hydrol_tol, double sminn_tol, N_Vector abstol)
{
int i;
/* Set absolute errors for hydrologic state variables */
#if defined(_OPENMP)
# pragma omp parallel for
#endif
for (i = 0; i < 3 * nelem + 2 * nriver; i++)
{
NV_Ith(abstol, i) = (realtype)hydrol_tol;
}
/* Set absolute errors for nitrogen state variables */
#if defined(_OPENMP)
# pragma omp parallel for
#endif
for (i = 3 * nelem + 2 * nriver; i < NumStateVar(); i++)
{
NV_Ith(abstol, i) = (realtype
```
<Overlap Ratio: 0.926829268292683>

---

--- 100 --
Question ID: f76e9fcf36fac72b98ff7595c79cb660d345f095_26
Original Code:
```
void f26(void) {
    	volatile uint32_t x1677 = UINT32_MAX;
	uint32_t x1679 = UINT32_MAX;
	uint64_t x1680 = 5LLU;
	volatile uint32_t t26 = 1U;

    t26 = ((x1677<<(x1678>x1679))>>x1680);

    if (t26 != 134217727U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
volatile uint32_t x1677 = UINT32_MAX;
uint32_t x1679 = UINT32_MAX;
uint64_t x1680 = 5LLU;
volatile uint32_t t26 = 1U;
t26 = ((x1677<<(x1678>x1679))>>x1680);
if (t26 != 134217727U) { NG(); } else { ; }
```
<Overlap Ratio: 0.9090909090909091>

---

--- 101 --
Question ID: 6f3693ab432dc462d62231142a71fbb5dce1433c_20
Original Code:
```
static
corto_subscriber corto_subscribeCallback(
    void (*callback)(corto_subscriber_event*))
{
    corto_subscriber result = NULL;

    corto_subscribeRequest *request = ut_tls_get(CORTO_KEY_FLUENT);
    if (request) {
        request->callback = callback;
        ut_tls_set(CORTO_KEY_FLUENT, NULL);
        result = corto_subscribeSubscribe(request);
        corto_dealloc(request);
    }

    return result;
}
```


Overlapping Code:
```
ribeCallback(
void (*callback)(corto_subscriber_event*))
{
corto_subscriber result = NULL;
corto_subscribeRequest *request = ut_tls_get(CORTO_KEY_FLUENT);
if (request) {
request->callback = callback;
ut_tls_set(CORTO_KEY_FLUENT, NULL);
result = corto_subscribeSubscribe(request);
corto_dealloc(request);
}
return r
```
<Overlap Ratio: 0.8795518207282913>

---

--- 102 --
Question ID: 5fe1015b037f7bf90e85ccbb1f347a00399c939a_9
Original Code:
```
LRESULT
CALLBACK
TextViewProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    HDC hdc;
    TEXTMETRIC tm;
    SCROLLINFO si;
    RECT rect;
    RECT FillRect;
    UINT Pos;
    UINT End;
    INT x, y;
    INT i;
    PCTSTR TrueStart, Start, Last;
    PCTSTR p, q;
    UINT Tchars;
    CHARTYPE Char, Command;
    UINT PrevHangingIndent;
    SIZE Extent;
    PLINEATTRIBS LineAttribs;
    PLINEATTRIBS PrevLineAttribs;
    HPEN OldPen;
    HBRUSH FillBrush;
    HPEN ShadowPen;
    HPEN HighlightPen;
    PTEXTVIEW_STATE s;
    UINT LineHeight;
    PHOTLINK HotLink;
    BOOL Hot;
    RECT HotRect;
    PCTSTR UrlLink;
    PCTSTR BookmarkLink;
    PTSTR CommandBuf;
    PCTSTR Arg;
    TCHAR Href[MAX_URL];
    PTSTR AnchorKey;
    PTSTR AnchorVal;
    UINT Count;
    HKEY TempKey;
    DWORD GrowListSize;
    PCTSTR ShellArgs;
    LONG l;
    BOOL b;
    PTSTR text;
    UINT textSize;
    BOOL printableFound;
    TCHAR oneChar;

    s = (PTEXTVIEW_STATE) GetWindowLong (hwnd, GWL_USERDATA);
    if (s) {
        LineHeight = s->LineHeight;
    } else {
        LineHeight = 0;
    }

    switch (uMsg) {

    case WM_CREATE:
        for (i = 0 ; g_TagList[i].Text ; i++) {
            g_TagList[i].TextLen = TcharCount (g_TagList[i].Text);
        }

        s = (PTEXTVIEW_STATE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (TEXTVIEW_STATE));
        SetWindowLong (hwnd, GWL_USERDATA, (LONG) s);

        TempKey = OpenRegKeyStr (TEXT("HKCR\\.URL"));
        if (TempKey) {
            CloseRegKey (TempKey);
        }

        s->UrlEnabled = (TempKey != NULL);

        ZeroMemory (&si, sizeof (si));
        si.fMask = SIF_RANGE;

        s->BookmarkTable = HtAllocWithData (sizeof (DWORD));
        if (!s->BookmarkTable) {
            return -1;
        }

        // WM_SETFONT does a bunch of work, including populating the text
        SendMessage (
            hwnd,
            WM_SETFONT,
            SendMessage (GetParent (hwnd), WM_GETFONT, 0, 0),
            0
            );

        return 0;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WMX_GOTO:
        //
        // Determine if text is in bookmark table
        //

        if (!lParam) {
            return 0;
        }

        if (HtFindStringAndData (s->BookmarkTable, (PCTSTR) lParam, &Pos)) {

            PostMessage (
                hwnd,
                WM_VSCROLL,
                MAKELPARAM (SB_THUMBPOSITION, (WORD) Pos),
                (LPARAM) hwnd
                );

        }

        return 0;


    case WMX_ADDLINE:
        //
        // Init
        //

        l = GetWindowLong (hwnd, GWL_STYLE) & WS_BORDER;
        if (!l) {
            l = GetWindowLong (hwnd, GWL_EXSTYLE) & (WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE|WS_EX_CLIENTEDGE|WS_EX_STATICEDGE);
        }

        if (!s->Margin && l) {
            s->Margin = s->LineHeight / 2;
        }

        Start = (PCTSTR) lParam;

        // ignore leading space
        TrueStart = Start;

        while (_istspace (_tcsnextc (Start))) {
            Start = _tcsinc (Start);
        }

        PrevLineAttribs = NULL;
        if (s->AttribsList.End) {
            MYASSERT (s->AttribsList.End >= sizeof (LINEATTRIBS));
            PrevLineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf +
                                              s->AttribsList.End -
                                              sizeof (LINEATTRIBS)
                                              );
        }

        //
        // Copy line attributes (optional) to our Attribs list; ignore errors.
        //

        LineAttribs = (PLINEATTRIBS) GrowBuffer (&s->AttribsList, sizeof (LINEATTRIBS));
        if (!LineAttribs) {
            return 0;
        }

        //
        // Copy previous line's attributes
        //

        ZeroMemory (LineAttribs, sizeof (LINEATTRIBS));

        if (PrevLineAttribs) {
            LineAttribs->AnchorWrap    = PrevLineAttribs->AnchorWrap;
            LineAttribs->Indent        = PrevLineAttribs->Indent;
            LineAttribs->HangingIndent = PrevLineAttribs->HangingIndent;
            PrevHangingIndent = PrevLineAttribs->HangingIndent;
        } else {
            LineAttribs->Indent = s->Margin;
            LineAttribs->HangingIndent = 0;
            PrevHangingIndent = 0;
        }

        x = LineAttribs->Indent + PrevHangingIndent;

        //
        // Find the first character that does not fit on the line
        //

        Last = pFindFirstCharThatDoesNotFit (
                    s->Margin,
                    &s->List,
                    &s->AttribsList,
                    s->BookmarkTable,
                    hwnd,
                    s->hFontNormal,
                    s->hFontBold,
                    s->hFontUnderlined,
                    Start,
                    (INT) x,
                    &tm,
                    &rect,
                    LineAttribs,
                    &s->ParseState
                    );

        //
        // Update the vertical scroll bar
        //

        MYASSERT (LineHeight);

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_RANGE|SIF_PAGE;
        si.nMin = 0;
        si.nPage = rect.bottom / LineHeight;
        si.nMax = GrowListGetSize (&s->List);

        SetScrollInfo (hwnd, SB_VERT, &si, TRUE);

        //
        // Copy the string (or as much that is visible) to our
        // grow list
        //

        GrowListAppendStringAB (&s->List, Start, Last);

        //
        // Return the number of bytes copied
        //

        return Last - TrueStart;

    case WMX_ALL_LINES_PAINTED:
        //
        // Scan all the lines, returning 0 if at least one has Painted == FALSE
        //

        LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf;
        if (!LineAttribs) {
            return 1;
        }

        for (Pos = 0 ; Pos < s->AttribsList.End ; Pos += sizeof (LINEATTRIBS)) {
            LineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf + Pos);
            if (!LineAttribs->Painted) {
                return 0;
            }
        }

        return 1;

    case WM_ERASEBKGND:
        return 0;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_DOWN:
            PostMessage (hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            return 0;

        case VK_UP:
            PostMessage (hwnd, WM_VSCROLL, SB_LINEUP, 0);
            return 0;

        case VK_NEXT:
            PostMessage (hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);
            return 0;

        case VK_PRIOR:
            PostMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0);
            return 0;

        case VK_HOME:
            PostMessage (hwnd, WM_VSCROLL, SB_TOP, 0);
            return 0;

        case VK_END:
            PostMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0);
            return 0;
        }

        break;


    case WM_SETFONT:
        s->hFont = (HFONT) wParam;

        if (s->hFontNormal) {
            DeleteObject (s->hFontNormal);
            s->hFontNormal = NULL;
        }

        if (s->hFontBold) {
            DeleteObject (s->hFontBold);
            s->hFontBold = NULL;
        }

        if (s->hFontUnderlined) {
            DeleteObject (s->hFontUnderlined);
            s->hFontUnderlined = NULL;
        }

        hdc = CreateDC (TEXT("display"), NULL, NULL, NULL);
        if (hdc) {
            pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);
            s->LineHeight = tm.tmHeight;

            DeleteDC (hdc);
        } else {
            s->LineHeight = 0;
        }

        if (lParam) {
            InvalidateRect (hwnd, NULL, FALSE);
        }

        if (s->AttribsList.End == 0) {
            textSize = GetWindowTextLength (hwnd);
            text = (PTSTR) MemAllocUninit ((textSize + 1) * sizeof (TCHAR));
            GetWindowText (hwnd, text, textSize + 1);
            AddStringToTextView (hwnd, text);
            FreeMem (text);
        }

        return 0;


    case WM_MOUSEMOVE:
        //
        // Search array of hit test rectangles
        //

        x = LOWORD(lParam);
        y = HIWORD(lParam);

        HotLink = pFindHotLink (&s->HotLinkArray, x, y);

        if (HotLink) {
            SetCursor (LoadCursor (g_hInst, MAKEINTRESOURCE (IDC_OUR_HAND)));
        } else {
            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE (IDC_ARROW)));
        }

        break;

    case WM_LBUTTONDOWN:
        //
        // Search array of hit test rectangles
        //

        x = LOWORD(lParam);
        y = HIWORD(lParam);

        HotLink = pFindHotLink (&s->HotLinkArray, x, y);

        if (HotLink) {
            if (HotLink->Url[0]) {
                if (!StringIMatchTcharCount (TEXT("file:"), HotLink->Url, 5)) {
                    ShellExecute (hwnd, TEXT("open"), HotLink->Url, NULL, NULL, 0);
                } else {
                    ShellArgs = &HotLink->Url[5];
                    if (*ShellArgs == TEXT('/')) {
                        ShellArgs++;
                    }
                    if (*ShellArgs == TEXT('/')) {
                        ShellArgs++;
                    }

                    ShellArgs = ExtractArgZero (ShellArgs, Href);
                    //
                    // if we're launching the Add/Remove programs applet,
                    // warn users they'll have to restart setup (RAID # 293357)
                    //
                    b = TRUE;
                    if (!UNATTENDED() &&
                        !REPORTONLY() &&
                        !g_UIQuitSetup &&
                        pLaunchedAddRemovePrograms (ShellArgs)
                        ) {
                        if (IDYES == ResourceMessageBox (
                                        hwnd,
                                        MSG_RESTART_IF_CONTINUE_APPWIZCPL,
                                        MB_YESNO | MB_ICONQUESTION,
                                        NULL
                                        )) {
                            LOG ((LOG_INFORMATION, "User launched Add/Remove Programs applet; setup will terminate"));
                            PostMessage (GetParent (hwnd), WMX_RESTART_SETUP, FALSE, TRUE);
                        } else {
                            b = FALSE;
                        }
                    }
                    if (b) {
                        ShellExecute (hwnd, TEXT("open"), Href, ShellArgs, NULL, 0);
                    }
                }
            } else if (HotLink->Bookmark) {
                SendMessage (hwnd, WMX_GOTO, 0, (LPARAM) HotLink->Bookmark);
            }
        }

        break;

    case WM_SETTEXT:
        SendMessage (hwnd, WMX_CLEANUP, 0, 0);
        DefWindowProc (hwnd, uMsg, wParam, lParam);
        SendMessage (hwnd, WM_CREATE, 0, 0);
        return 0;

    case WM_PAINT:
        FillBrush = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));
        ShadowPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DSHADOW));
        HighlightPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DHILIGHT));

        hdc = BeginPaint (hwnd, &ps);
        pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);
        s->LineHeight = LineHeight = tm.tmHeight;
        GetClientRect (hwnd, &rect);

        //
        // Select colors
        //

        SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));
        SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));

        if (FillBrush) {
            SelectObject (hdc, FillBrush);
        }

        SelectObject (hdc, GetStockObject (NULL_PEN));

        //
        // Get scroll position
        //

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_PAGE|SIF_POS;
        GetScrollInfo (hwnd, SB_VERT, &si);

        End = (UINT) si.nPos + si.nPage + 1;
        GrowListSize = GrowListGetSize (&s->List);
        End = min (End, GrowListSize);
        y = 0;

        //
        // Select font of previous line.  Move up if anchor wrap is on.
        //

        if (si.nPos) {
            do {
                LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);
                if (LineAttribs->AnchorWrap) {
                    si.nPos--;
                    y -= LineHeight;
                } else {
                    break;
                }
            } while (si.nPos > 0);
        }

        if (si.nPos) {
            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);

            if (LineAttribs->LastCharAttribs == ATTRIB_BOLD) {
                SelectObject (hdc, s->hFontBold);
            } else if (LineAttribs->LastCharAttribs == ATTRIB_UNDERLINED) {
                SelectObject (hdc, s->hFontUnderlined);
            } else {
                SelectObject (hdc, s->hFontNormal);
            }
        } else {
            SelectObject (hdc, s->hFontNormal);
        }

        //
        // Paint!
        //

        Hot = FALSE;
        s->HotLinkArray.End = 0;
        BookmarkLink = UrlLink = NULL;

        for (Pos = (UINT) si.nPos ; Pos < End ; Pos++) {
            p = GrowListGetString (&s->List, Pos);
            printableFound = FALSE;

            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + Pos;

            //
            // Compute hanging indent using previous line
            //

            if (Pos > 0) {
                PrevLineAttribs = (PLINEATTRIBS) ((PLINEATTRIBS) s->AttribsList.Buf + Pos - 1);
                PrevHangingIndent = PrevLineAttribs->HangingIndent;
            } else {
                PrevHangingIndent = 0;
            }

            //
            // Compute starting index
            //

            if (LineAttribs) {
                x = LineAttribs->Indent + PrevHangingIndent;
                LineAttribs->Painted = TRUE;
            } else {
                x = s->Margin;
            }

            //
            // Compute blank area
            //

            if (x > 0) {
                FillRect.left = 0;
                FillRect.right = x;
                FillRect.top = y;
                FillRect.bottom = y + LineHeight;

                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
            }

            //
            // Multiline hotlink
            //

            if (Hot) {
                HotRect.left = x;
                HotRect.top = y;
            }

            //
            // Compute text block
            //

            Start = p;

            while (p) {
                q = pGetHtmlCommandOrChar (p, &Command, &Char, &CommandBuf);

                if (!Char || Command == COMMAND_WHITESPACE || Command == COMMAND_ESCAPED_CHAR) {
                    //
                    // If this is the end of of a block of text, paint it.
                    //

                    MYASSERT (Start);

                    Tchars = p - Start;

                    if (Tchars) {
                        TextOut (hdc, x, y, Start, Tchars);
                        GetTextExtentPoint32 (hdc, Start, Tchars, &Extent);

                        x += Extent.cx;
                        if (x > rect.right) {
                            break;
                        }
                    }

                    Start = q;
                    oneChar = 0;

                    if (printableFound && Command == COMMAND_WHITESPACE) {
                        oneChar = TEXT(' ');
                    } else if (Command == COMMAND_ESCAPED_CHAR) {
                        oneChar = (TCHAR) Char;
                    }

                    if (oneChar) {

                        TextOut (hdc, x, y, &oneChar, 1);
                        GetTextExtentPoint32 (hdc, &oneChar, 1, &Extent);

                        x += Extent.cx;
                        if (x > rect.right) {
                            break;
                        }
                    }

                } else {
                    printableFound = TRUE;
                }

                switch (Command) {
                case 0:
                case COMMAND_WHITESPACE:
                case COMMAND_ESCAPED_CHAR:
                    break;

                case COMMAND_ANCHOR:
                    //
                    // Does this anchor have an HREF?
                    //

                    if (CommandBuf) {
                        Arg = CommandBuf;

                        Href[0] = 0;

                        while (Href[0] == 0 && *Arg) {
                            //
                            // Search for a HREF arg
                            //

                            Count = TcharCount (Arg);
                            AnchorKey = AllocText (Count);
                            AnchorVal = AllocText (Count);

                            if (!AnchorKey || !AnchorVal) {
                                FreeText (AnchorKey);
                                FreeText (AnchorVal);
                                break;
                            }

                            pGetHtmlKeyAndValue (Arg, AnchorKey, AnchorVal);

                            if (StringIMatch (TEXT("HREF"), AnchorKey)) {
                                _tcssafecpy (Href, AnchorVal, MAX_URL);
                            }

                            FreeText (AnchorKey);
                            FreeText (AnchorVal);

                            Arg += Count + 1;
                        }

                        if (Href[0]) {
                            //
                            // Does HREF point to a bookmark?
                            //

                            BookmarkLink = UrlLink = NULL;

                            if (_tcsnextc (Href) == TEXT('#')) {
                                BookmarkLink = SkipSpace (_tcsinc (Href));
                            } else {
                                if (s->UrlEnabled) {
                                    UrlLink = Href;
                                }
                            }

                            //
                            // If either BookmarkLink or Url is non-NULL, then turn on
                            // link font and color
                            //

                            if (BookmarkLink || UrlLink) {
                                HotRect.left = x;
                                HotRect.top = y;
                                Hot = TRUE;

                                SelectObject (hdc, s->hFontUnderlined);
                                SetTextColor (hdc, GetSysColor (COLOR_HIGHLIGHT));
                            }
                        }
                    }

                    break;

                case COMMAND_BOLD:
                    SelectObject (hdc, s->hFontBold);
                    break;

                case COMMAND_UNDERLINE:
                    SelectObject (hdc, s->hFontUnderlined);
                    break;

                case COMMAND_HORZ_RULE:
                    FillRect.left = rect.left;
                    FillRect.right = rect.right;
                    FillRect.top = y;
                    FillRect.bottom = y + LineHeight;

                    Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);

                    OldPen = (HPEN) SelectObject (hdc, ShadowPen);
                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2, NULL);
                    LineTo (hdc, rect.right - 3, y + LineHeight / 2);
                    SelectObject (hdc, HighlightPen);
                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2 + 1, NULL);
                    LineTo (hdc, rect.right - 3, y + LineHeight / 2 + 1);
                    SelectObject (hdc, OldPen);

                    x = rect.right;
                    break;

                case COMMAND_ANCHOR_END:
                    SelectObject (hdc, s->hFontNormal);
                    SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));

                    if (Hot) {
                        Hot = FALSE;
                        HotRect.right = x;
                        HotRect.bottom = y + LineHeight;

                        pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);
                    }
                    break;

                case COMMAND_BOLD_END:
                case COMMAND_UNDERLINE_END:
                    SelectObject (hdc, s->hFontNormal);
                    break;
                }

                FreePathString (CommandBuf);

                p = q;
            }

            //
            // Hot link that extends to multiple lines
            //

            if (Hot) {
                HotRect.right = x;
                HotRect.bottom = y + LineHeight;
                pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);
            }

            //
            // Fill blank area to end of line
            //

            if (x < rect.right) {
                FillRect.left = x;
                FillRect.right = rect.right;
                FillRect.top = y;
                FillRect.bottom = y + LineHeight;

                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
            }

            y += LineHeight;
        }

        //
        // Fill blank area to bottom of window
        //

        if (y < rect.bottom) {
             FillRect.left = 0;
             FillRect.right = rect.right;
             FillRect.top = y;
             FillRect.bottom = rect.bottom;

             Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
        }

        //
        // Cleanup
        //

        if (FillBrush) {
            DeleteObject (FillBrush);
        }

        if (ShadowPen) {
            DeleteObject (ShadowPen);
            ShadowPen = NULL;
        }

        if (HighlightPen) {
            DeleteObject (HighlightPen);
            HighlightPen = NULL;
        }

        EndPaint (hwnd, &ps);
        return 0;

    case WM_VSCROLL:
        Pos = HIWORD (wParam);

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_ALL;
        GetScrollInfo (hwnd, SB_VERT, &si);
        i = si.nMax - (INT) si.nPage + 1;

        si.fMask = 0;

        switch (LOWORD (wParam)) {
        case SB_PAGEDOWN:
            if (si.nPos + (INT) si.nPage < i) {
                si.nPos += si.nPage;
                ScrollWindow (hwnd, 0, -((INT) LineHeight * (INT) si.nPage), NULL, NULL);
                si.fMask = SIF_POS;
                break;
            }

            // fall through!

        case SB_BOTTOM:
            if (si.nPos < i) {
                InvalidateRect (hwnd, NULL, FALSE);
                si.nPos = i;
                si.fMask = SIF_POS;
            }
            break;

        case SB_LINEDOWN:
            if (si.nPos < i) {
                si.nPos += 1;
                ScrollWindow (hwnd, 0, -((INT) LineHeight), NULL, NULL);
                si.fMask = SIF_POS;
            }

            break;

        case SB_LINEUP:
            if (si.nPos > si.nMin) {
                si.nPos -= 1;
                ScrollWindow (hwnd, 0, (INT) LineHeight, NULL, NULL);
                si.fMask = SIF_POS;
            }

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            if ((INT) Pos != si.nPos) {
                InvalidateRect (hwnd, NULL, FALSE);
                si.nPos = (INT) Pos;
                si.fMask = SIF_POS;
            }
            break;

        case SB_PAGEUP:
            if (si.nPos >= si.nMin + (INT) si.nPage) {
                si.nPos -= si.nPage;
                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPage, NULL, NULL);
                si.fMask = SIF_POS;
                break;
            }

            // fall through

        case SB_TOP:
            if (si.nPos > si.nMin) {
                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPos, NULL, NULL);
                si.nPos = si.nMin;
                si.fMask = SIF_POS;
            }
            break;
        }

        if (si.fMask) {
            SetScrollInfo (hwnd, SB_VERT, &si, TRUE);
        }
        break;

    case WM_DESTROY:
    case WMX_CLEANUP:
        if (!g_Terminated) {
            if (s) {
                if (s->hFontNormal) {
                    DeleteObject (s->hFontNormal);
                    s->hFontNormal = NULL;
                }

                if (s->hFontBold) {
                    DeleteObject (s->hFontBold);
                    s->hFontBold = NULL;
                }

                if (s->hFontUnderlined) {
                    DeleteObject (s->hFontUnderlined);
                    s->hFontUnderlined = NULL;
                }

                FreeGrowBuffer (&s->AttribsList);
                FreeGrowBuffer (&s->HotLinkArray);
                FreeGrowList (&s->List);

                if (s->BookmarkTable) {
                    HtFree (s->BookmarkTable);
                    s->BookmarkTable = NULL;
                }

                MemFree (g_hHeap, 0, s);
                SetWindowLong (hwnd, GWL_USERDATA, 0);
            }
        }
        break;

    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}
```


Overlapping Code:
```
TextViewProc (
HWND hwnd,
UINT uMsg,
WPARAM wParam,
LPARAM lParam
)
{
PAINTSTRUCT ps;
HDC hdc;
TEXTMETRIC tm;
SCROLLINFO si;
RECT rect;
RECT FillRect;
UINT Pos;
UINT End;
INT x, y;
INT i;
PCTSTR TrueStart, Start, Last;
PCTSTR p, q;
UINT Tchars;
CHARTYPE Char, Command;
UINT PrevHangingIndent;
SIZE Extent;
PLINEATTRIBS LineAttribs;
PLINEATTRIBS PrevLineAttribs;
HPEN OldPen;
HBRUSH FillBrush;
HPEN ShadowPen;
HPEN HighlightPen;
PTEXTVIEW_STATE s;
UINT LineHeight;
PHOTLINK HotLink;
BOOL Hot;
RECT HotRect;
PCTSTR UrlLink;
PCTSTR BookmarkLink;
PTSTR CommandBuf;
PCTSTR Arg;
TCHAR Href[MAX_URL];
PTSTR AnchorKey;
PTSTR AnchorVal;
UINT Count;
HKEY TempKey;
DWORD GrowListSize;
PCTSTR ShellArgs;
LONG l;
BOOL b;
PTSTR text;
UINT textSize;
BOOL printableFound;
TCHAR oneChar;
s = (PTEXTVIEW_STATE) GetWindowLong (hwnd, GWL_USERDATA);
if (s) {
LineHeight = s->LineHeight;
} else {
LineHeight = 0;
}
switch (uMsg) {
case WM_CREATE:
for (i = 0 ; g_TagList[i].Text ; i++) {
g_TagList[i].TextLen = TcharCount (g_TagList[i].Text);
}
s = (PTEXTVIEW_STATE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (TEXTVIEW_STATE));
SetWindowLong (hwnd, GWL_USERDATA, (LONG) s);
TempKey oseRegKey (TempKey);
}
s->UrlEnabled = (TempKey != NULL);
ZeroMemory (&si, sizeof (si));
si.fMask = SIF_RANGE;
s->BookmarkTable = HtAllocWithData (sizeof (DWORD));
if (!s->BookmarkTable) {
return -1;
}
// WM_SETFONT does a bunch of work, including populating the text
SendMessage (
hwnd,
WM_SETFONT,
SendMessage (GetParent (hwnd), WM_GETFONT, 0, 0),
0
);
return 0;
case WM_GETDLGCODE:
return DLGC_WANTARROWS;
case WMX_GOTO:
//
// Determine if text is in bookmark table
//
if (!lParam) {
return 0;
}
if (HtFindStringAndData (s->BookmarkTable, (PCTSTR)
```
<Overlap Ratio: 0.9432194046306505>

---

--- 103 --
Question ID: 6cd5d744139950bbdbe6c878b7d2c542ae17d46e_1
Original Code:
```
static inline void prcm_domain_disable(uint32_t domains)
{
  DEBUGASSERT((domains & PRCM_DOMAIN_RFCORE) != 0 ||
              (domains & PRCM_DOMAIN_VIMS) != 0);

  /* Disable the power domains. */
 
  if ((domains & PRCM_DOMAIN_RFCORE) != 0)
    {
      putreg32(0, TIVA_PRCM_RFCCLKG);
    }

  if ((domains & PRCM_DOMAIN_VIMS) != 0)
    {
      putreg32(0, TIVA_PRCM_VIMSCLKG);
    }
}
```


Overlapping Code:
```
ne void prcm_domain_disable(uint32_t domains)
{
DEBUGASSERT((domains & PRCM_DOMAIN_RFCORE) != 0 ||
(domains & PRCM_DOMAIN_VIMS) != 0);
/* Disable the power domains. */

if ((domains & PRCM_DOMAIN_RFCORE) != 0)
{
putreg32(0, TIVA_PRCM_RFCCLKG);
}
if ((domains & PRCM_DOMAIN_VIMS) != 0)
{
putreg32(0, T
```
<Overlap Ratio: 0.8982035928143712>

---

--- 104 --
Question ID: 51a30f9e4d2f913604d7c21896e45a12eefb3298_0
Original Code:
```
int main(int argc, char *argv[])
{
	if (argc < 2)
	{
		printf("Please provide a hostname to resolve");
		exit(1);
	}

	char *hostname = argv[1];
	char ip[100];

	hostname_to_ip(hostname, ip);
	printf("%s resolved to %s", hostname, ip);

	printf("\n");
}
```


Overlapping Code:
```
int main(int argc, char *argv[])
{
if (argc < 2)
{
printf("Please provide a hostname to resolve");
exit(1);
}
char *hostname = argv[1];
char ip[100];
hostname_to_ip(hostname, ip);
printf("%s resolved to %s", hostname, ip);
printf("\n");
}
```
<Overlap Ratio: 1.0>

---

--- 105 --
Question ID: e7851b7b24431c7eaa820af86e892de4ff563b84_124
Original Code:
```
void f124(void) {
    	int8_t x681 = INT8_MIN;
	volatile int64_t x683 = INT64_MIN;
	static uint16_t x684 = UINT16_MAX;
	volatile int32_t t124 = -991571;

    t124 = ((x681^(x682<=x683))*x684);

    if (t124 != -8388480) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d) {
int8_t x681 = INT8_MIN;
volatile int64_t x683 = INT64_MIN;
static uint16_t x684 = UINT16_MAX;
volatile int32_t t124 = -991571;
t124 = ((x681^(x682<=x683))*x684);
if (t124 != -8388480) { NG(); } e
```
<Overlap Ratio: 0.8888888888888888>

---

--- 106 --
Question ID: c8dbe11528158bacebf8a227652268657c881625_4
Original Code:
```
void bkgndBLEMeshStack_app(void)
{
  struct gecko_msg_mesh_prov_create_network_rsp_t *new_netkey_rsp;
  struct gecko_msg_mesh_prov_create_appkey_rsp_t *new_appkey_rsp;
  struct gecko_msg_mesh_prov_device_provisioned_evt_t *prov_evt;
  struct gecko_msg_mesh_config_client_get_dcd_rsp_t* get_dcd_result;
  struct gecko_msg_mesh_config_client_dcd_data_evt_t *pDCD;
  struct gecko_msg_mesh_config_client_add_appkey_rsp_t *appkey_deploy_evt;
  struct gecko_msg_mesh_config_client_bind_model_rsp_t *model_app_bind_result;
  struct gecko_msg_mesh_config_client_set_model_pub_rsp_t *model_pub_set_result;
  struct gecko_msg_mesh_config_client_add_model_sub_rsp_t *model_sub_add_result;
  uint16 result;
  uint8 idx; /* j short array index */
  int8 dev_idx; /* device */
  uint16 vendor_id;
  uint16 model_id;
  uint16 pub_address;

  /* Init local variables */
  result=0;

  /* event handling */
  struct gecko_cmd_packet *evt = gecko_wait_event();
  bool pass = mesh_bgapi_listener(evt);
  if (pass /*&& event_is_not_deprecated(evt)*/) {
    switch (BGLIB_MSG_ID(evt->header)) {
      case gecko_evt_system_boot_id:
        /* Initialize Mesh stack in Node operation mode, wait for initialized event */
        if(0 != gecko_cmd_mesh_prov_init()->result)
        {
          /* Something went wrong */
          printf("gecko_cmd_mesh_prov_init failed\n\r");
        }

        break;
      case gecko_evt_mesh_prov_initialized_id:
        new_netkey_rsp = gecko_cmd_mesh_prov_create_network(16, fixed_netkey);
        if(0 != new_netkey_rsp->result)
        {
          /* Something went wrong */
          printf("gecko_cmd_mesh_prov_create_network: failed 0x%.2x\n\r",new_netkey_rsp->result);
        }
        else
        {
          network_id=new_netkey_rsp->network_id;
          printf("Success, netkey id = %x\r\n", new_netkey_rsp->network_id);
        }
        new_appkey_rsp = gecko_cmd_mesh_prov_create_appkey(new_netkey_rsp->network_id, 16, &fixed_appkey[0]);

        if(0 != new_appkey_rsp->result)
        {
          /* Something went wrong */
          printf("gecko_cmd_mesh_prov_create_appkey: failed 0x%.2x\n\r",new_appkey_rsp->result);
        }
        else
        {
          appkey_index=new_appkey_rsp->appkey_index;
          printf("Success, appkey id = %x\r\n", new_appkey_rsp->appkey_index);
        }

        /* Networks  */
        printf("networks: 0x%x ",evt->data.evt_mesh_prov_initialized.networks);

        /* address */
        printf("address: 0x%x ",evt->data.evt_mesh_prov_initialized.address);

        /* ivi  */
        printf("ivi: 0x%lx",evt->data.evt_mesh_prov_initialized.ivi);
        printf("\n\r");

        /* Scan for unprovisioned beacons */
        result=gecko_cmd_mesh_prov_scan_unprov_beacons()->result;

        break;
      case gecko_evt_mesh_prov_unprov_beacon_id:

        /* PB-ADV only */
        if(0 == evt->data.evt_mesh_prov_unprov_beacon.bearer)
        {
          /* Get BT mesh device index */
          dev_idx = IsDevPresent( &evt->data.evt_mesh_prov_unprov_beacon.address.addr[0]);

          /* fill up btmesh device struct */
          if( 0 > dev_idx )
          {
            /* Device is not present */
            for(idx=0;idx<MAX_NUM_BTMESH_DEV;idx++)
            {
              if(   ( 0x00 == bluetooth_device_table[idx].address[0] )
                 && ( 0x00 == bluetooth_device_table[idx].address[1] )
                 && ( 0x00 == bluetooth_device_table[idx].address[2] )
                 && ( 0x00 == bluetooth_device_table[idx].address[3] )
                 && ( 0x00 == bluetooth_device_table[idx].address[4] )
                 && ( 0x00 == bluetooth_device_table[idx].address[5] )
                )
              {
                memcpy(&bluetooth_device_table[idx].address[0],&evt->data.evt_mesh_prov_unprov_beacon.address.addr[0],BLE_ADDR_LEN_BYTE);
                memcpy(&bluetooth_device_table[idx].uuid[0],&evt->data.evt_mesh_prov_unprov_beacon.uuid.data[0],BLE_MESH_UUID_LEN_BYTE);

                /* Display info banner */
                printf("URI hash: 0x%lx ",evt->data.evt_mesh_prov_unprov_beacon.uri_hash);
                printf("bearer: 0x%x ",evt->data.evt_mesh_prov_unprov_beacon.bearer);
                printf("address: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x ",bluetooth_device_table[idx].address[0],
                                                                 bluetooth_device_table[idx].address[1],
                                                                 bluetooth_device_table[idx].address[2],
                                                                 bluetooth_device_table[idx].address[3],
                                                                 bluetooth_device_table[idx].address[4],
                                                                 bluetooth_device_table[idx].address[5]);
                printf("UUID: 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x ",bluetooth_device_table[idx].uuid[0],
                                                              bluetooth_device_table[idx].uuid[1],
                                                              bluetooth_device_table[idx].uuid[2],
                                                              bluetooth_device_table[idx].uuid[3],
                                                              bluetooth_device_table[idx].uuid[4],
                                                              bluetooth_device_table[idx].uuid[5]);
                printf("address type: 0x%x",evt->data.evt_mesh_prov_unprov_beacon.address_type);
                printf("\n\r");
                break;
              }
            }
          }
        }

        break;
      /* Provisioning */
      case gecko_evt_mesh_prov_provisioning_failed_id:
        printf("provisioning failed\n\r");
        break;
      case gecko_evt_mesh_prov_device_provisioned_id:

        prov_evt = (struct gecko_msg_mesh_prov_device_provisioned_evt_t*)&(evt->data);

        provisionee_addr = prov_evt->address;
        printf("Node successfully provisioned. Address: %4.4x, ", provisionee_addr);

        printf("uuid 0x");
        for (uint8_t i = 0; i < prov_evt->uuid.len; i++) printf("%02X", prov_evt->uuid.data[i]);
        printf("\r\n");

        printf(" getting dcd ...\n\r");

        get_dcd_result = gecko_cmd_mesh_config_client_get_dcd(network_id, provisionee_addr, 0);
        if (get_dcd_result->result == 0x0181) {
          printf("."); fflush(stdout);
        } else if(get_dcd_result->result != 0x0){
          printf("gecko_cmd_mesh_config_client_get_dcd failed with result 0x%X (%d) addr %x\r\n", get_dcd_result->result, get_dcd_result->result, prov_evt->address);
        }
        else
        {
          printf("requesting DCD from the node...\r\n");
        }

        break;

      /* Config events */
      case gecko_evt_mesh_config_client_dcd_data_id:
        pDCD = (struct gecko_msg_mesh_config_client_dcd_data_evt_t *)&(evt->data);
        printf("DCD data event, received %u bytes\r\n", pDCD->data.len);

        // copy the data into one large array. the data may come in multiple smaller pieces.
        // the data is not decoded until all DCD events have been received (see below)
        if((_dcd_raw_len + pDCD->data.len) <= 256)
        {
          memcpy(&(_dcd_raw[_dcd_raw_len]), pDCD->data.data, pDCD->data.len);
          _dcd_raw_len += pDCD->data.len;
        }

        break;
      case gecko_evt_le_connection_opened_id:
        printf("LE connection opened\r\n");
        break;

      case gecko_evt_mesh_config_client_dcd_data_end_id:
        printf("DCD data end event. Decoding the data.\r\n");
        // decode the DCD content
        DCD_decode();

        // check the desired configuration settings depending on what's in the DCD
        config_check();

        appkey_deploy_evt = gecko_cmd_mesh_config_client_add_appkey(network_id, provisionee_addr, appkey_index, network_id);
        if (appkey_deploy_evt->result == 0) {
          printf("Deploying appkey to node 0x%4.4x\r\n", provisionee_addr);
        }else{
          printf("Appkey deployment failed. addr %x, error: %x\r\n", provisionee_addr, appkey_deploy_evt->result);
        }

        break;
      case gecko_evt_mesh_config_client_appkey_status_id:
        result = evt->data.evt_mesh_config_client_appkey_status.result;
        if(result == 0)
        {
          printf(" appkey added\r\n");
          /* move to next step which is binding appkey to models */

          // take the next model from the list of models to be bound with application key.
          // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys
          model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;
          vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;

          printf("APP BIND, config %d/%d:: model %4.4x key index %x\r\n", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);

          model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index
                                                                           appkey_index, vendor_id, model_id );
        }
        break;
      case gecko_evt_mesh_config_client_binding_status_id:
        result = evt->data.evt_mesh_config_client_appkey_status.result;
        if(result == bg_err_success)
        {
          printf(" bind complete\r\n");
          _sConfig.num_bind_done++;

          if(_sConfig.num_bind_done < _sConfig.num_bind)
          {
            // take the next model from the list of models to be bound with application key.
            // for simplicity, the same appkey is used for all models but it is possible to also use several appkeys
            model_id = _sConfig.bind_model[_sConfig.num_bind_done].model_id;
            vendor_id = _sConfig.bind_model[_sConfig.num_bind_done].vendor_id;

            printf("APP BIND, config %d/%d:: model %4.4x key index %x\r\n", _sConfig.num_bind_done+1, _sConfig.num_bind, model_id, appkey_index);

            model_app_bind_result = gecko_cmd_mesh_config_client_bind_model( network_id, provisionee_addr, 0, // element index
                                                                             appkey_index, vendor_id, model_id );
          }
          else
          {
            // get the next model/address pair from the configuration list:
            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;
            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;
            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];

            printf("PUB SET, config %d/%d: model %4.4x -> address %4.4x\r\n", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);

            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,
              0, /* element index */
              vendor_id,
              model_id,
              pub_address,
              appkey_index,
              0, /* friendship credential flag */
              3, /* Publication time-to-live value */
              0, /* period = NONE */
              0, /* Publication retransmission count */
              50  /* Publication retransmission interval */ );

            if (model_pub_set_result->result == 0)
            {
              printf(" waiting pub ack\r\n");
            }
          }
        }
        else
        {
          printf(" appkey bind failed with code \r\n");
        }
        break;
      case gecko_evt_mesh_config_client_model_pub_status_id:
        result = evt->data.evt_mesh_config_client_model_pub_status.result;
        if(result == bg_err_success)
        {
          printf(" pub set OK\r\n");
          _sConfig.num_pub_done++;

          if(_sConfig.num_pub_done < _sConfig.num_pub)
          {
            /* more publication settings to be done
            ** get the next model/address pair from the configuration list: */
            model_id = _sConfig.pub_model[_sConfig.num_pub_done].model_id;
            vendor_id = _sConfig.pub_model[_sConfig.num_pub_done].vendor_id;
            pub_address = _sConfig.pub_address[_sConfig.num_pub_done];

            printf("PUB SET, config %d/%d: model %4.4x -> address %4.4x\r\n", _sConfig.num_pub_done+1, _sConfig.num_pub, model_id, pub_address);

            model_pub_set_result = gecko_cmd_mesh_config_client_set_model_pub(network_id, provisionee_addr,
              0, /* element index */
              vendor_id,
              model_id,
              pub_address,
              appkey_index,
              0, /* friendship credential flag */
              3, /* Publication time-to-live value */
              0, /* period = NONE */
              0, /* Publication retransmission count */
              50  /* Publication retransmission interval */ );
          }
          else
          {
            // move to next step which is configuring subscription settings
            // get the next model/address pair from the configuration list:
            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;
            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;
            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];

            printf("SUB ADD, config %d/%d: model %4.4x -> address %4.4x\r\n", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);

            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);

            if (model_sub_add_result->result == 0x00)
            {
              printf(" waiting sub ack\r\n");
            }
          }
        }
        break;
      case gecko_evt_mesh_config_client_model_sub_status_id:
        result = evt->data.evt_mesh_config_client_model_sub_status.result;
        if(result == bg_err_success)
        {
          printf(" sub add OK\r\n");
          _sConfig.num_sub_done++;
          if(_sConfig.num_sub_done < _sConfig.num_sub)
          {
            // move to next step which is configuring subscription settings
            // get the next model/address pair from the configuration list:
            model_id = _sConfig.sub_model[_sConfig.num_sub_done].model_id;
            vendor_id = _sConfig.sub_model[_sConfig.num_sub_done].vendor_id;
            sub_address = _sConfig.sub_address[_sConfig.num_sub_done];

            printf("SUB ADD, config %d/%d: model %4.4x -> address %4.4x\r\n", _sConfig.num_sub_done+1, _sConfig.num_sub, model_id, sub_address);

            model_sub_add_result = gecko_cmd_mesh_config_client_add_model_sub(network_id, provisionee_addr, 0, vendor_id, model_id, sub_address);

            if (model_sub_add_result->result == 0x00)
            {
              printf(" waiting sub ack\r\n");
            }
          }
          else
          {
            printf("***\r\nconfiguration complete\r\n***\r\n");
          }
        }

        break;
      case gecko_evt_mesh_prov_dcd_status_id:
        printf("dcd status received\n\r");
        break;
      case gecko_evt_mesh_prov_config_status_id:
        printf("prov config status\n\r");
        break;
      case gecko_evt_le_gap_adv_timeout_id:
        /* adv timeout events silently discarded */
        break;
      default:
        printf("unhandled evt: %8.8x class %2.2x method %2.2x\r\n", (unsigned int)BGLIB_MSG_ID(evt->header),
                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 16) & 0xFF),
                                                                    (unsigned int)((BGLIB_MSG_ID(evt->header) >> 24) & 0xFF) );

        if(model_app_bind_result->result  == 0x0000)
        {
          printf(" waiting bind ack\r\n");
        }

        break;
    }
  }

  return;
}
```


Overlapping Code:
```
uct gecko_msg_mesh_prov_create_network_rsp_t *new_netkey_rsp;
struct gecko_msg_mesh_prov_create_appkey_rsp_t *new_appkey_rsp;
struct gecko_msg_mesh_prov_device_provisioned_evt_t *prov_evt;
struct gecko_msg_mesh_config_client_get_dcd_rsp_t* get_dcd_result;
struct gecko_msg_mesh_config_client_dcd_data_evt_t *pDCD;
struct gecko_msg_mesh_config_client_add_appkey_rsp_t *appkey_deploy_evt;
struct gecko_msg_mesh_config_client_bind_model_rsp_t *model_app_bind_result;
struct gecko_msg_mesh_config_client_set_model_pub_rsp_t *model_pub_set_result;
struct gecko_msg_mesh_config_client_add_model_sub_rsp_t *model_sub_add_result;
uint16 result;
uint8 idx; /* j short array index */
int8 dev_idx; /* device */
uint16 vendor_id;
uint16 model_id;
uint16 pub_address;
/* Init local variables */
result=0;
/* event handling */
struct gecko_cmd_packet *evt = gecko_wait_event();
bool pass = mesh_bgapi_listener(evt);
if (pass /*&& event_is_not_deprecated(evt)*/) {
switch (BGLIB_MSG_ID(evt->header)) {
case gecko_evt_system_boot_id:
/* Initialize Mesh stack in Node operation mode, wait for initialized event */
if(0 != gecko_cmd_mesh_prov_init()->result)
{
/* Something went wrong */
printf("gecko_cmd_mesh_prov_init failed\n\r");
}
break;
case gecko_evt_mesh_prov_initialized_id:
new_netkey_rsp = gecko_cmd_mesh_prov_create_network(16, fixed_netkey);
if(0 != new_netkey_rsp->result)
{
/* Something went wrong */
printf("gecko_cmd_mesh_prov_create_network: failed 0x%.2x\n\r",new_netkey_rsp->result);
}
else
{
network_id=new_netkey_rsp->network_id;
printf("Success, netkey id = %x\r\n", new_netkey_rsp->network_id);
}
new_appkey_rsp = gecko_cmd_mesh_prov_create_appkey(new_netkey_rsp->network_id, 16, &fixed_appkey[0]);
if(0 != new_appkey_rsp->result)
{
/* Something went wrong */
printf("gecko_cmd_mesh_prov_create_appkey: failed 0x%.2x\n\r",new_appkey_rsp->result);
}
else
{
appkey_index=new_appkey_rsp->appkey_index;
printf("Success, appkey id = %x\r\n", new_appkey_rsp->appkey_index);
}
/* Networks */
printf("networks: 0x%x ",evt->data.evt_mesh_prov_initiali
```
<Overlap Ratio: 0.9752616555661275>

---

--- 107 --
Question ID: 150218f8637bc265e15d3ada3ee02067f51b2ebf_105
Original Code:
```
void f105(void) {
    	int64_t x421 = 38524824230670LL;
	int64_t x422 = INT64_MIN;
	static volatile uint16_t x423 = UINT16_MAX;
	static int8_t x424 = -1;
	int64_t t105 = 14829LL;

    t105 = ((x421^x422)*(x423<=x424));

    if (t105 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
24824230670LL;
int64_t x422 = INT64_MIN;
static volatile uint16_t x423 = UINT16_MAX;
static int8_t x424 = -1;
int64_t t105 = 14829LL;
t105 = ((x421^x422)*(x423<=x424));
if (t105 != 0LL) { NG(); } else
```
<Overlap Ratio: 0.8163265306122449>

---

--- 108 --
Question ID: 7a777a2d33b2079c58f60afd1b107de41ca577e2_66
Original Code:
```
void f66(void) {
    	int32_t x389 = -602;
	volatile int32_t x390 = INT32_MIN;
	uint8_t x391 = 59U;
	static volatile int32_t t66 = 1635999;

    t66 = (x389^(x390|(x391*x392)));

    if (t66 != 745) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f66(void) {
int32_t x389 = -602;
volatile int32_t x390 = INT32_MIN;
uint8_t x391 = 59U;
static volatile int32_t t66 = 1635999;
t66 = (x389^(x390|(x391*x392)));
if (t66 != 745) { NG(); } else { ; }
```
<Overlap Ratio: 0.9803921568627451>

---

--- 109 --
Question ID: cfc9e595b7c4e9ba56fec4034c360bf0a9320619_3
Original Code:
```
static UShort get_UShort ( Cursor* c ) {
   UShort r;
   vg_assert(is_sane_Cursor(c));
   if (c->sli_next + sizeof(UShort) > c->sli.ioff + c->sli.szB) {
      c->barf(c->barfstr);
      /*NOTREACHED*/
      vg_assert(0);
   }
   r = ML_(img_get_UShort)(c->sli.img, c->sli_next);
   c->sli_next += sizeof(UShort);
   return r;
}
```


Overlapping Code:
```
UShort ( Cursor* c ) {
UShort r;
vg_assert(is_sane_Cursor(c));
if (c->sli_next + sizeof(UShort) > c->sli.ioff + c->sli.szB) {
c->barf(c->barfstr);
/*NOTREACHED*/
vg_assert(0);
}
r = ML_(img_get_UShort)(c->sli.img, c->sli_next);
c->sli_next += sizeof(
```
<Overlap Ratio: 0.8680555555555556>

---

--- 110 --
Question ID: 4c7aef6500104da44c4134a5b978b082b2f0450d_27
Original Code:
```
void f27(void) {
    	uint64_t x137 = 1008318355LLU;
	int32_t x138 = INT32_MIN;
	volatile uint16_t x140 = 14973U;
	volatile int32_t t27 = 7169;

    t27 = ((x137%x138)>(x139+x140));

    if (t27 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid) {
uint64_t x137 = 1008318355LLU;
int32_t x138 = INT32_MIN;
volatile uint16_t x140 = 14973U;
volatile int32_t t27 = 7169;
t27 = ((x137%x138)>(x139
```
<Overlap Ratio: 0.7281553398058253>

---

--- 111 --
Question ID: 2b9b790d125b11425e3f1a4c440ad318c8b3f60f_130
Original Code:
```
void f130(void) {
    	uint8_t x685 = UINT8_MAX;
	uint16_t x686 = UINT16_MAX;
	volatile int16_t x687 = -1;
	int16_t x688 = INT16_MAX;
	volatile int32_t t130 = 408392;

    t130 = (x685-(x686/(x687&x688)));

    if (t130 != 253) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
uint8_t x685 = UINT8_MAX;
uint16_t x686 = UINT16_MAX;
volatile int16_t x687 = -1;
int16_t x688 = INT16_MAX;
volatile int32_t t130 = 408392;
t130 = (x685-(x686/(x687&x688)));
if (t1
```
<Overlap Ratio: 0.8146551724137931>

---

--- 112 --
Question ID: bddf22711ad1d678030f8ead80871332a199bd8c_0
Original Code:
```
int main(void){
    setgid(0);
    setuid(0);
    execl("/bin/sh","sh",0, (char *)0);
    return 0;
}
```


Overlapping Code:
```
oid){
setgid(0);
setuid(0);
execl("/bin/sh","sh",0
```
<Overlap Ratio: 0.5882352941176471>

---

--- 113 --
Question ID: 8f2da2cb12af233b0eddba9d5ca666c704883cd4_18
Original Code:
```
void f18(void) {
    	volatile int8_t x173 = INT8_MAX;
	int32_t x174 = -6;
	int16_t x175 = INT16_MAX;
	int64_t x176 = INT64_MIN;
	volatile int32_t t18 = 924068;

    t18 = ((x173+x174)>>(x175/x176));

    if (t18 != 121) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
18(void) {
volatile int8_t x173 = INT8_MAX;
int32_t x174 = -6;
int16_t x175 = INT16_MAX;
int64_t x176 = INT64_MIN;
volatile int32_t t18 = 924068;
t18 = ((x173+x174)>>(x175/x176));
if (t18 != 121) { NG
```
<Overlap Ratio: 0.8888888888888888>

---

--- 114 --
Question ID: 87dc80c76f655a7caf5ea1044b8e8d4cf9bf54b6_1
Original Code:
```
void application_start(void){

    /* Initialise the WICED device without WLAN */
    wiced_core_init();
    
    /* 32 kHz clock also needed for Bluetooth */
    host_platform_init_wlan_powersave_clock();

    printf("BTstack on WICED\n");

#if 0
    // init GPIOs D0-D5 for debugging - not used
    wiced_gpio_init(D0, OUTPUT_PUSH_PULL);
    wiced_gpio_init(D1, OUTPUT_PUSH_PULL);
    wiced_gpio_init(D2, OUTPUT_PUSH_PULL);
    wiced_gpio_init(D3, OUTPUT_PUSH_PULL);
    wiced_gpio_init(D4, OUTPUT_PUSH_PULL);
    wiced_gpio_init(D5, OUTPUT_PUSH_PULL);

    wiced_gpio_output_low(D0);
    wiced_gpio_output_low(D1);
    wiced_gpio_output_low(D2);
    wiced_gpio_output_low(D3);
    wiced_gpio_output_low(D4);
    wiced_gpio_output_low(D5);
#endif

    // start with BTstack init - especially configure HCI Transport
    btstack_memory_init();
    btstack_run_loop_init(btstack_run_loop_wiced_get_instance());
    
    // enable full log output while porting
    // hci_dump_open(NULL, HCI_DUMP_STDOUT);

    // setup le device db storage -- not needed if used LE-only (-> start address == 0)
    le_device_db_wiced_dct_set_start_address(btstack_link_key_db_wiced_dct_get_storage_size());
    le_device_db_dump();
    
    // init HCI
    const btstack_uart_block_t * uart_driver = btstack_uart_block_wiced_instance();
    const hci_transport_t * transport = hci_transport_h4_instance(uart_driver);
    hci_init(transport, (void*) &hci_transport_config_uart);
    hci_set_link_key_db(btstack_link_key_db_wiced_dct_instance());
    hci_set_chipset(btstack_chipset_bcm_instance());

    // inform about BTstack state
    hci_event_callback_registration.callback = &packet_handler;
    hci_add_event_handler(&hci_event_callback_registration);

    // use WIFI Mac address + 1 for Bluetooth
    bd_addr_t dummy = { 1,2,3,4,5,6};
    sscanf_bd_addr(&wifi_mac_address[8], dummy);
    dummy[5]++;
    hci_set_bd_addr(dummy);
    
    // hand over to btstack embedded code 
    btstack_main();

    // go
    btstack_run_loop_execute();

    while (1){};
}
```


Overlapping Code:
```
d application_start(void){
/* Initialise the WICED device without WLAN */
wiced_core_init();

/* 32 kHz clock also needed for Bluetooth */
host_platform_init_wlan_powersave_clock();
printf("BTstack on WICED\n");
#if 0
// init GPIOs D0-D5 for debugging - not used
wiced_gpio_init(D0, OUTPUT_PUSH_PULL);
wiced_gpio_init(D1, OUTPUT_PUSH_PULL);
wiced_gpio_init(D2, OUTPUT_PUSH_PULL);
wiced_gpio_init(D3, OUTPUT_PUSH_PULL);
wiced_gpio_init(D4, OUTPUT_PUSH_PULL);
wiced_gpio_init(D5, OUTPUT_PUSH_PULL);
wiced_gpio_output_low(D0);
wiced_gpio_output_low(D1);
wiced_gpio_output_low(D2);
wiced_gpio_output_low(D3);
wiced_gpio_output_low(D4);
wiced_gpio_output_low(D5);
#endif
// start with BTstack init - especially configure HCI Transport
btstack_memory_init();
btstack_run_loop_init(btstack_run_loop_wiced_get_instance());

// enable full log output while porting
// hci_dump_open(NULL, HCI_DUMP_STDOUT);
// setup le device db storage -- not needed if used LE-only (-> start address == 0)
le_device_db_wiced_dct_set_start_address(btstack_link_key_db_wiced_dct_get_storage_size());
le_device_db_dump();

// init HCI
const btstack_uart_block_t * uart_driver = btstack_uart_block_wiced_instance();
const hci_transport_t * transport = hci_transport_h4_instance(uart_driver);
hci_init(transport, (void*) &hci_transport_config_uart);
hci_set_link_key_db(btstack_link_key_db_wiced_dct_instance());
hci_set_chipset(btstack_chipset_bcm_instance());
// inform about BTstack state
hci_event_callback_registration.callback = &packet_handler;
hci_add_event_handler(&hci_event_callback_registration);
// use WIFI Mac address + 1 for Bluetooth
bd_addr_t dummy = { 1,2,3,4,5,6};
sscanf_bd_addr(&wifi_mac_address[8], dummy);
dummy[5]++;
hci_set_bd_addr(dummy);

// hand over to btstack embedded code 
btstack_main();
// go
btstack_run_loop_execute();
```
<Overlap Ratio: 0.9902333152468801>

---

--- 115 --
Question ID: 6919b3afee9eeccb5e6e7811a76a30d72b95aad0_45
Original Code:
```
void f45(void) {
    	uint16_t x197 = UINT16_MAX;
	volatile int16_t x198 = INT16_MAX;
	int16_t x199 = -13942;
	int8_t x200 = -1;
	volatile int32_t t45 = -4;

    t45 = (x197|(x198*(x199/x200)));

    if (t45 != 456851455) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
uint16_t x197 = UINT16_MAX;
volatile int16_t x198 = INT16_MAX;
int16_t x199 = -13942;
int8_t x200 = -1;
volatile int32_t t45 = -4;
t45 = (x197|(x198*(x199/x200)));
if (t45 != 456851455) { NG(); } else
```
<Overlap Ratio: 0.9247787610619469>

---

--- 116 --
Question ID: 51e1d0f91d36845f6a43cf01f31a06532ee6da74_20
Original Code:
```
int LHGetMatchedVtx( LHGRAPH graph, int lhsVtx ) {
    Graph     *g;
    Vertex    *lv,*rv;

    /* Check parameters */
    g = CheckGraph(graph);
    if( NULL==g ) {
        return LH_PARAM_ERR;
    }
    if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {
        return LH_PARAM_ERR;
    }
    
    /* Get pointer to left-hand vertex */
    lv = &(g->lVtx[lhsVtx]);

    /* Find matching partner */
    rv = lv->matchedWith;
    if( rv==NULL ) {
        return LH_MATCHING_ERR;
    }
    
    /* Transform internal ID to external ID */
    return (rv->id - g->numLHSVtx);
}
```


Overlapping Code:
```
Vtx ) {
Graph *g;
Vertex *lv,*rv;
/* Check parameters */
g = CheckGraph(graph);
if( NULL==g ) {
return LH_PARAM_ERR;
}
if( lhsVtx<0 || lhsVtx>=g->numLHSVtx ) {
return LH_PARAM_ERR;
}

/* Get pointer to left-hand vertex */
lv = &(g->lVtx[lhsVtx]);
/* Find matching partner */
rv = lv->matchedWith;
if( rv==NULL ) {
return LH_MATCHING_ERR;
}

/* Transform internal ID to external ID */
return (rv->id -
```
<Overlap Ratio: 0.8695652173913043>

---

--- 117 --
Question ID: 3015d5b618cbe8ef0eaefd0ca6d542abeb73b70c_189
Original Code:
```
void f189(void) {
    	int8_t x1565 = INT8_MAX;
	volatile int8_t x1567 = INT8_MIN;
	static int8_t x1568 = -1;
	int32_t t189 = -106873853;

    t189 = (x1565%(x1566*(x1567*x1568)));

    if (t189 != 127) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
) {
int8_t x1565 = INT8_MAX;
volatile int8_t x1567 = INT8_MIN;
static int8_t x1568 = -1;
int32_t t189 = -106873853;
t189 = (x1565%(x1566*(x1567*x1568)
```
<Overlap Ratio: 0.7211538461538461>

---

--- 118 --
Question ID: 2b591f1cc2fd7198794e3c11d60d3473d6d72ff1_185
Original Code:
```
void f185(void) {
    	uint32_t x1325 = 68U;
	int16_t x1326 = 39;
	static int8_t x1327 = INT8_MIN;
	uint32_t x1328 = UINT32_MAX;
	volatile int32_t t185 = -1;

    t185 = (x1325<=(x1326>>(x1327!=x1328)));

    if (t185 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
5(void) {
uint32_t x1325 = 68U;
int16_t x1326 = 39;
static int8_t x1327 = INT8_MIN;
uint32_t x1328 = UINT32_MAX;
volatile int32_t t185 = -1;
t185 = (x1325<=(x1326>>(x1327!=x1328)));
if (t185 != 0) { N
```
<Overlap Ratio: 0.8771929824561403>

---

--- 119 --
Question ID: e253ffd55a5995414c71910bea205b39dddf0eb7_7
Original Code:
```
static FT_Error
skip_literal_string(FT_Byte **acur,
                    FT_Byte *limit) {
    FT_Byte *cur = *acur;
    FT_Int embed = 0;
    FT_Error error = FT_ERR(Invalid_File_Format);
    unsigned int i;


    while (cur < limit) {
        FT_Byte c = *cur;


        ++cur;

        if (c == '\\') {
            /* Red Book 3rd ed., section `Literal Text Strings', p. 29:     */
            /* A backslash can introduce three different types              */
            /* of escape sequences:                                         */
            /*   - a special escaped char like \r, \n, etc.                 */
            /*   - a one-, two-, or three-digit octal number                */
            /*   - none of the above in which case the backslash is ignored */

            if (cur == limit)
                /* error (or to be ignored?) */
                break;

            switch (*cur) {
                /* skip `special' escape */
                case 'n':
                case 'r':
                case 't':
                case 'b':
                case 'f':
                case '\\':
                case '(':
                case ')':
                    ++cur;
                    break;

                default:
                    /* skip octal escape or ignore backslash */
                    for (i = 0; i < 3 && cur < limit; ++i) {
                        if (!IS_OCTAL_DIGIT(*cur))
                            break;

                        ++cur;
                    }
            }
        } else if (c == '(')
            embed++;
        else if (c == ')') {
            embed--;
            if (embed == 0) {
                error = FT_Err_Ok;
                break;
            }
        }
    }

    *acur = cur;

    return error;
}
```


Overlapping Code:
```
FT_Error
skip_literal_string(FT_Byte **acur,
FT_Byte *limit) {
FT_Byte *cur = *acur;
FT_Int embed = 0;
FT_Error error = FT_ERR(Invalid_File_Format);
unsigned int i;
while (cur < limit) {
FT_Byte c = *cur;
++cur;
if (c == '\\') {
/* Red Book 3rd ed., section `Literal Text Strings', p. 29: */
/* A backslash can introduce three different types */
/* of escape sequences: */
/* - a special escaped char like \r, \n, etc. */
/* - a one-, two-, or three-digit octal number */
/* - none of the above in which case the backslash is ignored */
if (cur == limit)
/* error (or to be ignored?) */
break;
switch (*cur) {
/* skip `special' escape */
case 'n':
case 'r':
case 't':
case 'b':
case 'f':
case '\\':
case '(':
case ')':
++cur;
break;
default:
/* skip octal escape or ignore backslash */
for (i = 0; i < 3 && cur < limit; ++i) {
if (!IS_OCTAL_DIGIT(*cur))
break;
++cur;
}
}
} else if (c == '(')
embed++;
else if (c == ')') {
embed--;
if (embed == 0) {
error = FT_Err_Ok;
break;
}
}
}
*acur = cur;
retur
```
<Overlap Ratio: 0.983284169124877>

---

--- 120 --
Question ID: 499c48e7637b3a6826545fe9e89a8b61ec996cf1_44
Original Code:
```
struct UAkTVOSInitializationSettings : public UObject {
	struct FAkCommonInitializationSettingsWithSampleRate CommonSettings; // 0x28(0x68)
	struct FAkAudioSession AudioSession; // 0x90(0x0c)
	char UnknownData_9C[0x4]; // 0x9c(0x04)
	struct FAkCommunicationSettingsWithSystemInitialization CommunicationSettings; // 0xa0(0x28)
	struct FAkAdvancedInitializationSettings AdvancedSettings; // 0xc8(0x34)
	char UnknownData_FC[0x4]; // 0xfc(0x04)
}
```


Overlapping Code:
```
itializationSettings : public UObject {
struct FAkCommonInitializationSettingsWithSampleRate CommonSettings; // 0x28(0x68)
struct FAkAudioSession AudioSession; // 0x90(0x0c)
char UnknownData_9C[0x4]; // 0x9c(0x04)
struct FAkCommunicationSettingsWithSystemInitialization CommunicationSettings; // 0xa0(0x28)
struct FAkAdvancedInitializationSettings AdvancedSettings; // 0xc8(0x34)
char UnknownData_FC[0x4]; /
```
<Overlap Ratio: 0.931350114416476>

---

--- 121 --
Question ID: 5983bf2281ed68ee8f05d0ab2bd4253efd4fdbb2_4
Original Code:
```
EFI_STATUS
EFIAPI
LibGetTime (
  OUT  EFI_TIME                 *Time,
  OUT  EFI_TIME_CAPABILITIES    *Capabilities
  )
{
  EFI_STATUS                    Status;
  INT16                         TimeZone;
  UINT8                         Daylight;
  RTC_DATETIME                  DateTime;
  UINTN                         Size;
  UINT8                         Val;
  RTC_I2C_REQUEST               Req;
  UINT8                         RtcRegAddr;

  if (mI2cMaster == NULL) {
    BOOTTIME_DEBUG ((DEBUG_ERROR, "%a : I2c Master protocol is not yet installed\n", __FUNCTION__));
    return EFI_DEVICE_ERROR;
  }

  if (Time == NULL) {
    BOOTTIME_DEBUG ((DEBUG_ERROR, "Received NULL parameter\n"));
    return EFI_INVALID_PARAMETER;
  }

  RtcRegAddr = PCF85263_CENTISEC_REG_ADDR;

  Req.OperationCount = 2;

  Req.SetAddressOp.Flags = 0;
  Req.SetAddressOp.LengthInBytes = sizeof (RtcRegAddr);
  Req.SetAddressOp.Buffer = &RtcRegAddr;

  Req.GetSetDateTimeOp.Flags = I2C_FLAG_READ;
  Req.GetSetDateTimeOp.LengthInBytes = sizeof (RTC_DATETIME);
  Req.GetSetDateTimeOp.Buffer = (VOID *)&DateTime;

  Status = mI2cMaster->StartRequest (mI2cMaster, FixedPcdGet8 (PcdI2cSlaveAddress),
                                     (VOID *)&Req,
                                     NULL,  NULL);
  if (EFI_ERROR (Status)) {
    BOOTTIME_DEBUG ((DEBUG_ERROR, "RTC read error at Addr:0x%x, Status = %r\n", RtcRegAddr, Status));
    return Status;
  }

  if (DateTime.Seconds & PCF85263_SEC_BIT_OSC) {
    BOOTTIME_DEBUG ((DEBUG_ERROR, "### Warning: RTC oscillator has stopped\n"));
    /* clear the OS flag */
    Val = DateTime.Seconds & ~PCF85263_SEC_BIT_OSC;
    RtcWrite (PCF85263_SEC_REG_ADDR, Val);

    return EFI_DEVICE_ERROR;
  }

  Time->Nanosecond = BcdToDecimal8 (DateTime.CentiSeconds) * 10000000;
  Time->Second  = BcdToDecimal8 (DateTime.Seconds & MASK_SEC);
  Time->Minute  = BcdToDecimal8 (DateTime.Minutes & MASK_MIN);
  Time->Hour = BcdToDecimal8 (DateTime.Hours & MASK_HOUR);
  Time->Day = BcdToDecimal8 (DateTime.Days & MASK_DAY);
  Time->Month  = BcdToDecimal8 (DateTime.Months & MASK_MONTH);
  Time->Year = BcdToDecimal8 (DateTime.Years) +
               (BcdToDecimal8 (DateTime.Years) >= 98 ? 1900 : 2000);

  // Get the current time zone information from non-volatile storage
  Size = sizeof (TimeZone);
  Status = EfiGetVariable (
             (CHAR16 *)mTimeZoneVariableName,
             &gEfiCallerIdGuid,
             NULL,
             &Size,
             (VOID *)&TimeZone
             );

  if (EFI_ERROR (Status)) {
    ASSERT (Status != EFI_INVALID_PARAMETER);
    ASSERT (Status != EFI_BUFFER_TOO_SMALL);

    if (Status != EFI_NOT_FOUND) {
      return Status;
    }

    // The time zone variable does not exist in non-volatile storage, so create it.
    Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;
    // Store it
    Status = EfiSetVariable (
               (CHAR16 *)mTimeZoneVariableName,
               &gEfiCallerIdGuid,
               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
               Size,
               (VOID *)&(Time->TimeZone)
               );

    if (EFI_ERROR (Status)) {
      BOOTTIME_DEBUG ((DEBUG_ERROR,
        "LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\n",
        mTimeZoneVariableName,
        Status
        ));
      return Status;
    }
  } else {
    // Got the time zone
    Time->TimeZone = TimeZone;

    // Check TimeZone bounds:   -1440 to 1440 or 2047
    if (((Time->TimeZone < -1440) || (Time->TimeZone > 1440))
        && (Time->TimeZone != EFI_UNSPECIFIED_TIMEZONE)) {
      Time->TimeZone = EFI_UNSPECIFIED_TIMEZONE;
    }
  }

  // Get the current daylight information from non-volatile storage
  Size = sizeof (Daylight);
  Status = EfiGetVariable (
             (CHAR16 *)mDaylightVariableName,
             &gEfiCallerIdGuid,
             NULL,
             &Size,
             (VOID *)&Daylight
             );

  if (EFI_ERROR (Status)) {
    ASSERT (Status != EFI_INVALID_PARAMETER);
    ASSERT (Status != EFI_BUFFER_TOO_SMALL);

    if (Status != EFI_NOT_FOUND) {
      return Status;
    }

    // The daylight variable does not exist in non-volatile storage, so create it.
    Time->Daylight = 0;
    // Store it
    Status = EfiSetVariable (
               (CHAR16 *)mDaylightVariableName,
               &gEfiCallerIdGuid,
               EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
               Size,
               (VOID *)&(Time->Daylight)
               );
    if (EFI_ERROR (Status)) {
      BOOTTIME_DEBUG ((DEBUG_ERROR,
        "LibGetTime: Failed to save %s variable to non-volatile storage, Status = %d\n",
        mDaylightVariableName,
        Status
        ));
      return Status;
    }
  } else {
    // Got the daylight information
    Time->Daylight = Daylight;
  }

  return Status;
}
```


Overlapping Code:
```
EFI_STATUS
EFIAPI
LibGetTime (
OUT EFI_TIME *Time,
OUT EFI_TIME_CAPABILITIES *Capabilities
)
{
EFI_STATUS Status;
INT16 TimeZone;
UINT8 Daylight;
RTC_DATETIME DateTime;
UINTN Size;
UINT8 Val;
RTC_I2C_REQUEST Req;
UINT8 RtcRegAddr;
if (mI2cMaster == NULL) {
BOOTTIME_DEBUG ((DEBUG_ERROR, "%a : I2c Master protocol is not yet installed\n", __FUNCTION__));
return EFI_DEVICE_ERROR;
}
if (Time == NULL) {
BOOTTIME_DEBUG ((DEBUG_ERROR, "Received NULL parameter\n"));
return EFI_INVALID_PARAMETER;
}
RtcRegAddr = PCF85263_CENTISEC_REG_ADDR;
Req.OperationCount = 2;
Req.SetAddressOp.Flags = 0;
Req.SetAddressOp.LengthInBytes = sizeof (RtcRegAddr);
Req.SetAddressOp.Buffer = &RtcRegAddr;
Req.GetSetDateTimeOp.Flags = I2C_FLAG_READ;
Req.GetSetDateTimeOp.LengthInBytes = sizeof (RTC_DATETIME);
Req.GetSetDateTimeOp.Buffer = (VOID *)&DateTime;
Status = mI2cMaster->StartRequest (mI2cMaster, FixedPcdGet8 (PcdI2cSlaveAddress),
(VOID *)&Req,
NULL, NULL);
if (EFI_ERROR (Status)) {
BOOTTIME_DEBUG ((DEBUG_ERROR, "RTC read error at Addr:0x%x, Status = %r\n", RtcRegAddr, Status));
return Status;
}
if (DateTime.Seconds & PCF85263_SEC_BIT_OSC) {
BOOTTIME_DEBUG ((DEBUG_ERROR, "### Warning: RTC oscillator has stopped\n"));
/* clear the OS flag */
Val = DateTime.Seconds & ~PCF85263_SEC_BIT_OSC;
RtcWrite (PCF85263_SEC_REG_ADDR, Val);
return EFI_DEVICE_ERROR;
}
Time->Nanosecond = BcdToDecimal8 (DateTime.CentiSeconds) * 10000000;
Time->Second = BcdToDecimal8 (DateTime.Seconds & MASK_SEC);
Time->Minute = BcdToDecimal8 (DateTime.Minutes & MASK_MIN);
Time->Hour = BcdToDecimal8 (DateTime.Hours & MASK_HOUR);
Time->Day = BcdToDecimal8 (DateTime.Days & MASK_DAY);
Time->Month = BcdToDecimal8 (DateTime.Months & MASK_MONTH);
Time->Year = BcdToDecimal8 (DateTime.Years) +
(BcdToDecimal8 (DateTime.Years) >= 98 ? 1900 : 2000);
// Get the current time zone information from non-volatile storage
Size = sizeof (TimeZone);
Status = EfiGetVariable (
(CHAR16 *)mTimeZoneVariableName,
&gEfiCallerIdG
```
<Overlap Ratio: 0.9979746835443037>

---

--- 122 --
Question ID: ac4d51d5a9ea7d98040b47296fca49126879173d_2
Original Code:
```
vec4 add_vec4(vec4 vector, vec4 vector_)
{
	vector.x += vector_.x;
	vector.y += vector_.y;
	vector.z += vector_.z;
	vector.w += vector_.w;
	return vector;
}
```


Overlapping Code:
```
4 vector, vec4 vector_)
{
vector.x += vector_.x;
vector.y += vector_.y;
vector.z += vector_.z;
vecto
```
<Overlap Ratio: 0.6622516556291391>

---

--- 123 --
Question ID: 0499c9a6a1303fbee61a70d5cada12a310d0fe95_3
Original Code:
```
void f3(void) {
    	volatile int8_t x365 = INT8_MIN;
	uint8_t x366 = 2U;
	volatile int32_t x368 = INT32_MAX;
	static volatile int32_t t3 = -21;

    t3 = (((x365%x366)<<x367)*x368);

    if (t3 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
volatile int8_t x365 = INT8_MIN;
uint8_t x366 = 2U;
volatile int32_t x368 = INT32_MAX;
static volatile int32_t t3 = -21;
t3 = (((x365%x366)<<x367)*x368);
if (t
```
<Overlap Ratio: 0.8106796116504854>

---

--- 124 --
Question ID: 8d6c65a25dd54e15a2b783ace79a40bd426e7351_15
Original Code:
```
psd_int64_t
psdDescriptorValueGetInt64(const psd_descriptor_value_t *value)
{
    psd_descriptor_key_t key;
    if (psd_is_not_null(value)) {
        key = value->key;
        if (psd_likely(key == PSD_DESCRIPTOR_LARGE_INT)) {
            return value->u.lval;
        }
        else if (key == PSD_DESCRIPTOR_INT) {
            return value->u.ival;
        }
        else if (key == PSD_DESCRIPTOR_BOOL) {
            return value->u.bval ? 1 : 0;
        }
        else if (key == PSD_DESCRIPTOR_DOUBLE) {
            return (psd_int64_t) value->u.dval;
        }
        else if (key == PSD_DESCRIPTOR_UNIT_DOUBLE || key == PSD_DESCRIPTOR_UNIT_FLOAT) {
            return (psd_int64_t) value->u.uval.value;
        }
        else if (key == PSD_DESCRIPTOR_UNICODE_TEXT) {
            return (psd_int64_t) strtoll(value->u.text, 0, 10);
        }
    }
    return 0;
}
```


Overlapping Code:
```
lueGetInt64(const psd_descriptor_value_t *value)
{
psd_descriptor_key_t key;
if (psd_is_not_null(value)) {
key = value->key;
if (psd_likely(key == PSD_DESCRIPTOR_LARGE_INT)) {
return value->u.lval;
}
else if (key == PSD_DESCRIPTOR_INT) {
return value->u.ival;
}
else if (key == PSD_DESCRIPTOR_BOOL) {
return value->u.bval ? 1 : 0;
}
else if (key == PSD_DESCRIPTOR_DOUBLE) {
return (psd_int64_t) value->u.dval;
}
else if (key == PSD_DESCRIPTOR_UNIT_DOUBLE || key == PSD_DESCRIPTOR_UNIT_FLOAT) {
return (psd_int64_t) value->u.uval.value;
}
else if (key == PSD_DESCRIPTOR_UNICODE_TEXT) {
return (psd_int64_t) strtoll(value->u.text, 0, 10);
}
}
return 0;
```
<Overlap Ratio: 0.9572901325478645>

---

--- 125 --
Question ID: a2aaeb7673f00d864e86619408f93e036da9d8f7_3
Original Code:
```
int
__wt_update_alloc(WT_SESSION_IMPL *session, const WT_ITEM *value,
    WT_UPDATE **updp, size_t *sizep, u_int modify_type)
{
	WT_UPDATE *upd;

	*updp = NULL;

	/*
	 * The code paths leading here are convoluted: assert we never attempt
	 * to allocate an update structure if only intending to insert one we
	 * already have.
	 */
	WT_ASSERT(session, modify_type != WT_UPDATE_INVALID);

	/*
	 * Allocate the WT_UPDATE structure and room for the value, then copy
	 * the value into place.
	 */
	if (modify_type == WT_UPDATE_DELETED ||
	    modify_type == WT_UPDATE_RESERVED)
		WT_RET(__wt_calloc(session, 1, WT_UPDATE_SIZE, &upd));
	else {
		WT_RET(__wt_calloc(
		    session, 1, WT_UPDATE_SIZE + value->size, &upd));
		if (value->size != 0) {
			upd->size = WT_STORE_SIZE(value->size);
			memcpy(upd->data, value->data, value->size);
		}
	}
	upd->type = (uint8_t)modify_type;

	*updp = upd;
	*sizep = WT_UPDATE_MEMSIZE(upd);
	return (0);
}
```


Overlapping Code:
```
SESSION_IMPL *session, const WT_ITEM *value,
WT_UPDATE **updp, size_t *sizep, u_int modify_type)
{
WT_UPDATE *upd;
*updp = NULL;
/*
* The code paths leading here are convoluted: assert we never attempt
* to allocate an update structure if only intending to insert one we
* already have.
*/
WT_ASSERT(session, modify_type != WT_UPDATE_INVALID);
/*
* Allocate the WT_UPDATE structure and room for the value, then copy
* the value into place.
*/
if (modify_type == WT_UPDATE_DELETED ||
modify_type == WT_UPDATE_RESERVED)
WT_RET(__wt_calloc(session, 1, WT_UPDATE_SIZE, &upd));
else {
WT_RET(__wt_calloc(
session, 1, WT_UPDATE_SIZE + value->size, &upd));
if (value->size != 0) {
upd->size = WT_STORE_SIZE(value->size);
memcpy(upd->data, value->data, value->size);
}
}
upd->type = (uint8_t)modify_type;
*updp = upd;
*sizep = WT_UPDATE_MEMSIZE(upd);
return 
```
<Overlap Ratio: 0.9648127128263337>

---

--- 126 --
Question ID: 69273b5eb71da5ae2bc863b6cab123805a2d274a_12
Original Code:
```
void
cairo_surface_set_device_scale (cairo_surface_t *surface,
				double		 x_scale,
				double		 y_scale)
{
    cairo_status_t status;

    if (unlikely (surface->status))
	return;

    assert (surface->snapshot_of == NULL);

    if (unlikely (surface->finished)) {
	_cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
	return;
    }

    status = _cairo_surface_begin_modification (surface);
    if (unlikely (status)) {
	_cairo_surface_set_error (surface, status);
	return;
    }

    surface->device_transform.xx = x_scale;
    surface->device_transform.yy = y_scale;
    surface->device_transform.xy = 0.0;
    surface->device_transform.yx = 0.0;

    surface->device_transform_inverse = surface->device_transform;
    status = cairo_matrix_invert (&surface->device_transform_inverse);
    /* should always be invertible unless given pathological input */
    assert (status == CAIRO_STATUS_SUCCESS);

    _cairo_observers_notify (&surface->device_transform_observers, surface);
}
```


Overlapping Code:
```
iro_surface_set_device_scale (cairo_surface_t *surface,
double x_scale,
double y_scale)
{
cairo_status_t status;
if (unlikely (surface->status))
return;
assert (surface->snapshot_of == NULL);
if (unlikely (surface->finished)) {
_cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
return;
}
status = _cairo_surface_begin_modification (surface);
if (unlikely (status)) {
_cairo_surface_set_error (surface, status);
return;
}
surface->device_transform.xx = x_scale;
surface->device_transform.yy = y_scale;
surface->device_transform.xy = 0.0;
surface->device_transform.yx = 0.0;
surface->device_transform_inverse = surface->device_transform;
status = cairo_matrix_invert (&surface->device_transform_inverse);
/* should always be invertible unless given pathological input */
assert (status == CAIRO_STATUS_SUCCESS);
_cairo_observers_notify (&surface->device_transform_observers, surface);

```
<Overlap Ratio: 0.991332611050921>

---

--- 127 --
Question ID: fba7f8d0d146271bcb17e20d0a4ced35305bc130_5
Original Code:
```
static bool GetStackTrace(JNIEnv* env, jthrowable thrown, struct ExpandableString* dst) {
    // This function is equivalent to the following Java snippet:
    //   StringWriter sw = new StringWriter();
    //   PrintWriter pw = new PrintWriter(sw);
    //   thrown.printStackTrace(pw);
    //   String trace = sw.toString();
    //   return trace;
    jobject sw = NewStringWriter(env);
    if (sw == NULL) {
        return false;
    }

    jobject pw = NewPrintWriter(env, sw);
    if (pw == NULL) {
        (*env)->DeleteLocalRef(env, sw);
        return false;
    }

    jmethodID printStackTrace =
        FindMethod(env, "java/lang/Throwable", "printStackTrace", "(Ljava/io/PrintWriter;)V");
    (*env)->CallVoidMethod(env, thrown, printStackTrace, pw);

    jstring trace = StringWriterToString(env, sw);

    (*env)->DeleteLocalRef(env, pw);
    pw = NULL;
    (*env)->DeleteLocalRef(env, sw);
    sw = NULL;

    if (trace == NULL) {
        return false;
    }

    bool success = AppendJString(env, trace, dst);
    (*env)->DeleteLocalRef(env, trace);
    return success;
}
```


Overlapping Code:
```
ce(JNIEnv* env, jthrowable thrown, struct ExpandableString* dst) {
// This function is equivalent to the following Java snippet:
// StringWriter sw = new StringWriter();
// PrintWriter pw = new PrintWriter(sw);
// thrown.printStackTrace(pw);
// String trace = sw.toString();
// return trace;
jobject sw = NewStringWriter(env);
if (sw == NULL) {
return false;
}
jobject pw = NewPrintWriter(env, sw);
if (pw == NULL) {
(*env)->DeleteLocalRef(env, sw);
return false;
}
jmethodID printStackTrace =
FindMethod(env, "java/lang/Throwable", "printStackTrace", "(Ljava/io/PrintWriter;)V");
(*env)->CallVoidMethod(env, thrown, printStackTrace, pw);
jstring trace = StringWriterToString(env, sw);
(*env)->DeleteLocalRef(env, pw);
pw = NULL;
(*env)->DeleteLocalRef(env, sw);
sw = NULL;
if (trace == NULL) {
return false;
}
bool success = AppendJString(env, trace, dst);
(*env)->DeleteLocalRef(env, trace);
return
```
<Overlap Ratio: 0.9635974304068522>

---

--- 128 --
Question ID: d8e46f52daed3d797ce1ea3717fe89ea5ce5dae1_187
Original Code:
```
void f187(void) {
    	int8_t x751 = -1;
	volatile int16_t x752 = INT16_MIN;
	uint32_t t187 = 9991063U;

    t187 = (x749&((x750|x751)^x752));

    if (t187 != 32767U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 int16_t x752 = INT16_MIN;
uint32_t t187 = 9991063U;
t187 = (x749&((x750|x751)^x752));
if (t187 != 3
```
<Overlap Ratio: 0.5747126436781609>

---

--- 129 --
Question ID: e733bb8c00c20bb7f75a17185eca4412998b6a9b_5
Original Code:
```
static uMToken *
get_dimension (sMSCtx *c, int fSigned, int fNegate)
{
  const char *non_tt_param=NULL;
  uint64_t v_r = 0ULL, v1;
  
  if (GET_CHAR (c) == 'Q')
    {
      INC_CHAR (c);
      non_tt_param="'non-type-template-parameter";
    }
  if (GET_CHAR (c) == 0)
    {
      c->err = 2;
      return NULL;
    }
  if (GET_CHAR (c) >= '0' && GET_CHAR (c) <= '9')
    {
      uint64_t v = (uint64_t) ((GET_CHAR (c)-'0') + 1);
      INC_CHAR (c);
      return gen_dim (c->gc, eMST_dim,v, non_tt_param, fSigned, fNegate);
    }

  while (GET_CHAR (c) != '@')
    {
      if (GET_CHAR (c) == 0)
        {
          c->err = 2;
          return NULL;
        }
      if (GET_CHAR (c) < 'A' || GET_CHAR (c) > 'P')
        {
          c->err = 1;
          return NULL;
        }
      v1=(uint64_t) (GET_CHAR (c) - 'A');
      v_r = v_r*10ULL + v1;
      INC_CHAR (c);
    }
  if (GET_CHAR (c) !='@')
    {
      c->err = 1;
      return NULL;
    }
  INC_CHAR (c);
  return gen_dim (c->gc, eMST_dim,v_r, non_tt_param, fSigned, fNegate);
}
```


Overlapping Code:
```
*
get_dimension (sMSCtx *c, int fSigned, int fNegate)
{
const char *non_tt_param=NULL;
uint64_t v_r = 0ULL, v1;

if (GET_CHAR (c) == 'Q')
{
INC_CHAR (c);
non_tt_param="'non-type-template-parameter";
}
if (GET_CHAR (c) == 0)
{
c->err = 2;
return NULL;
}
if (GET_CHAR (c) >= '0' && GET_CHAR (c) <= '9')
{
uint64_t v = (uint64_t) ((GET_CHAR (c)-'0') + 1);
INC_CHAR (c);
return gen_dim (c->gc, eMST_dim,v, non_tt_param, fSigned, fNegate);
}
while (GET_CHAR (c) != '@')
{
if (GET_CHAR (c) == 0)
{
c->err = 2;
return NULL;
}
if (GET_CHAR (c) < 'A' || GET_CHAR (c) > 'P')
{
c->err = 1;
return NULL;
}
v1=(uint64_t) (GET_CHAR (c) - 'A');
v_r = v_r*10ULL + v1;
INC_CHAR (c);
}
if (GET_CHAR (c) !='@')
{
c->err = 1;
return NULL;
}
INC_CHAR (c);
return gen_dim (c->gc, eMST_dim,v_r, non_tt_param, fSigned, fNega
```
<Overlap Ratio: 0.97442143727162>

---

--- 130 --
Question ID: 797023ac9325f29a84b628dedc8af202f5ac26d2_106
Original Code:
```
void f106(void) {
    	static volatile int8_t x5593 = INT8_MAX;
	static uint8_t x5594 = 3U;
	uint64_t x5595 = 2206789LLU;
	volatile int32_t t106 = 1786383;

    t106 = (x5593<=((x5594*x5595)>>x5596));

    if (t106 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
f106(void) {
static volatile int8_t x5593 = INT8_MAX;
static uint8_t x5594 = 3U;
uint64_t x5595 = 2206789LLU;
volatile int32_t t106 = 1786383;
t106 = (x5593<=((x5594*x5595)>>x5596));
if (t106 != 1) { 
```
<Overlap Ratio: 0.8849557522123894>

---

--- 131 --
Question ID: 0ff6af2bfda58d1ba6a149b42897197309a137b8_87
Original Code:
```
void f87(void) {
    	volatile int16_t x390 = INT16_MIN;
	int64_t x391 = INT64_MAX;
	int32_t x392 = INT32_MIN;
	volatile int32_t t87 = 454;

    t87 = (((x389-x390)%x391)==x392);

    if (t87 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
x390 = INT16_MIN;
int64_t x391 = INT64_MAX;
int32_t x392 = INT32_MIN;
volatile int32_t t87 = 454;
t87 = (((x389-x390)%x391)==x392);
if (t87 != 0) { NG
```
<Overlap Ratio: 0.7389162561576355>

---

--- 132 --
Question ID: 836de5e1a29388f5934010096dea7609c6c4a70e_198
Original Code:
```
void f199(void) {
    	int8_t x1065 = 0;
	int8_t x1066 = -1;
	static uint32_t x1067 = 921U;
	uint32_t t199 = 199U;

    t199 = ((x1065+x1066)+(x1067+x1068));

    if (t199 != 927U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f199(void) {
int8_t x1065 = 0;
int8_t x1066 = -1;
static uint32_t x1067 = 921U;
uint32_t t199 = 199U;
t199 = ((x1065+x1066)+(x1067+x1068));
if (t199 
```
<Overlap Ratio: 0.8064516129032258>

---

--- 133 --
Question ID: 83f3f9f5bd51ab59c6e46215b4f7f280a9d12828_4
Original Code:
```
void setBndCnd(double* q, int cndL, int cndH, int np, int nt){
  int i;
  int pI,tI;
  int wInd, rInd;


  //printf("Running bnd cnds for %dx%d prims\n",np,nt);
#pragma omp parallel for private(i,pI,tI,wInd,rInd) shared(q,cndL,cndH,np,nt,Hp,Ha)
  for(i=0;i<2*nt;i++){
    pI=i%2;
    tI=i/2;
    wInd=pI+(np+4)*tI;
    rInd=3-pI+(np+4)*tI;
    //printf("BND: %d refs %d\n",wInd,rInd);
    if(cndL==BND_REFL){
      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];
      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
    }else if(cndL==BND_PERM){
      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];
      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
    }
    wInd=np+2+pI+(np+4)*tI;
    rInd=np+1-pI+(np+4)*tI;
    //printf("BND: %d refs %d\n",wInd,rInd);
    if(cndH==BND_REFL){
      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
      q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];
      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
    }else if(cndH==BND_PERM){
      q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
      q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];
      q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
      q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
    }
  }
}
```


Overlapping Code:
```
nd(double* q, int cndL, int cndH, int np, int nt){
int i;
int pI,tI;
int wInd, rInd;
//printf("Running bnd cnds for %dx%d prims\n",np,nt);
#pragma omp parallel for private(i,pI,tI,wInd,rInd) shared(q,cndL,cndH,np,nt,Hp,Ha)
for(i=0;i<2*nt;i++){
pI=i%2;
tI=i/2;
wInd=pI+(np+4)*tI;
rInd=3-pI+(np+4)*tI;
//printf("BND: %d refs %d\n",wInd,rInd);
if(cndL==BND_REFL){
q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];
q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
}else if(cndL==BND_PERM){
q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];
q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
}
wInd=np+2+pI+(np+4)*tI;
rInd=np+1-pI+(np+4)*tI;
//printf("BND: %d refs %d\n",wInd,rInd);
if(cndH==BND_REFL){
q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
q[wInd+(np+4)*nt*VARVX ]=-q[rInd+(np+4)*nt*VARVX ];
q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR ];
}else if(cndH==BND_PERM){
q[wInd+(np+4)*nt*VARRHO]= q[rInd+(np+4)*nt*VARRHO];
q[wInd+(np+4)*nt*VARVX ]= q[rInd+(np+4)*nt*VARVX ];
q[wInd+(np+4)*nt*VARVY ]= q[rInd+(np+4)*nt*VARVY ];
q[wInd+(np+4)*nt*VARPR ]= q[rInd+(np+4)*nt*VARPR 
```
<Overlap Ratio: 0.9854333576110706>

---

--- 134 --
Question ID: d69e8d9a3773ccdca45931172c28a8b7c7c43e5d_0
Original Code:
```
class GestureRecognition
{
public:
	//skeleton allBoneJoints[2500];
	static bool _StartScan;
	static bool recordData;
	static bool initCalib;
	static bool isCalib;
	static bool readFile;

	static char* fileName;

	static int tFrameIndex;


public:
	void gesturerecog(JointPosition &jpos);



}
```


Overlapping Code:
```
:
//skeleton allBoneJoints[2500];
static bool _StartScan;
static bool recordData;
static bool initCalib;
static bool isCalib;
static bool readFile;
static char* fileName;
static int tFrameIndex;
public:
void ge
```
<Overlap Ratio: 0.7581227436823105>

---

--- 135 --
Question ID: 9b021edbeb9054f5dc5c00ece4759f2599ec6942_10
Original Code:
```
ACMD(do_mecho) {
	char *p;

	if (!MOB_OR_IMPL(ch)) {
		send_config_msg(ch, "huh_string");
		return;
	}

	if (AFF_FLAGGED(ch, AFF_ORDERED))
		return;

	if (!*argument) {
		mob_log(ch, "mecho called with no arguments");
		return;
	}
	p = argument;
	skip_spaces(&p);

	sub_write(p, ch, TRUE, TO_ROOM);
}
```


Overlapping Code:
```
har *p;
if (!MOB_OR_IMPL(ch)) {
send_config_msg(ch, "huh_string");
return;
}
if (AFF_FLAGGED(ch, AFF_ORDERED))
return;
if (!*argument) {
mob_log(ch, "mecho called with no arguments");
return;
}
p = argument;
skip_spaces(&p);
sub_write(p, ch, TRUE, TO
```
<Overlap Ratio: 0.9025270758122743>

---

--- 136 --
Question ID: d7f0978c56ffd36dc7f5c28d3f889bcc4c08f2f0_2
Original Code:
```
static void 
dslash_fn_field_F( su3_vector *src, su3_vector *dest, 
		   int parity, fn_links_qop_t *fn){

  QOP_info_t info = {0., 0., 0, 0, 0};
  int otherparity = opposite_parity(parity);
  QOP_F3_FermionLinksAsqtad *al_F = get_F_asqtad_links(fn);
  QOP_F3_ColorVector *in = create_F_V_from_field( src, otherparity);
  QOP_F3_ColorVector *out = create_F_V_from_field( dest, parity);
  QOP_evenodd_t eo_out, eo_in;

  eo_out = milc2qop_parity(parity);
  eo_in = milc2qop_parity(otherparity);

  /* We want just dslash so we use zero mass */
  QOP_F3_asqtad_dslash(&info, al_F, 0.0, out, in, eo_out, eo_in);

  unload_F_V_to_field( dest, out, parity);

  /* Fix the normalization */
  qop_to_milc_dslash_normalization(dest, parity);

  QOP_F3_destroy_V(out);
  QOP_F3_destroy_V(in);
}
```


Overlapping Code:
```
fn_field_F( su3_vector *src, su3_vector *dest, 
int parity, fn_links_qop_t *fn){
QOP_info_t info = {0., 0., 0, 0, 0};
int otherparity = opposite_parity(parity);
QOP_F3_FermionLinksAsqtad *al_F = get_F_asqtad_links(fn);
QOP_F3_ColorVector *in = create_F_V_from_field( src, otherparity);
QOP_F3_ColorVector *out = create_F_V_from_field( dest, parity);
QOP_evenodd_t eo_out, eo_in;
eo_out = milc2qop_parity(parity);
eo_in = milc2qop_parity(otherparity);
/* We want just dslash so we use zero mass */
QOP_F3_asqtad_dslash(&info, al_F, 0.0, out, in, eo_out, eo_in);
unload_F_V_to_field( dest, out, parity);
/* Fix the normalization */
qop_to_milc_dslash_normalization(dest, parity);
QOP_F3_destroy_V(out);
```
<Overlap Ratio: 0.9408602150537635>

---

--- 137 --
Question ID: 68def6e38813550c381ab3113850826bcdf827cc_114
Original Code:
```
void f114(void) {
    	int8_t x517 = INT8_MIN;
	uint8_t x518 = 31U;
	int32_t x520 = INT32_MIN;

    t114 = (x517-(x518>(x519%x520)));

    if (t114 != -128) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
f114(void) {
int8_t x517 = INT8_MIN;
uint8_t x518 = 31U;
int32_t x520 = INT32_MIN;
t114 = (x517-(x518>(x519%x520)));
if (t114 != -128) { NG(); } else 
```
<Overlap Ratio: 0.9202453987730062>

---

--- 138 --
Question ID: 04ea4a0702073fd2459c81d9220d06a5c99fac68_1
Original Code:
```
void *fetch_freelist(freelist_handle *handle)
{
    if(is_freelist_empty(handle))
        return NULL;
    void *rt = FL->next;
    FL->next = FL->next->next;
    return rt;
}
```


Overlapping Code:
```
reelist(freelist_handle *handle)
{
if(is_freelist_empty(handle))
return NULL;
void *rt = FL->next;
F
```
<Overlap Ratio: 0.6622516556291391>

---

--- 139 --
Question ID: eeb2e88cca24f612348ecc88781f6f5d8e741b09_103
Original Code:
```
void f103(void) {
    	int16_t x421 = INT16_MIN;
	uint16_t x422 = UINT16_MAX;
	int32_t x423 = INT32_MIN;
	static uint8_t x424 = UINT8_MAX;

    t103 = (((x421%x422)==x423)>x424);

    if (t103 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
int16_t x421 = INT16_MIN;
uint16_t x422 = UINT16_MAX;
int32_t x423 = INT32_MIN;
static uint8_t x424 = UINT8_MAX;
t103 = (((x421%x422)==x423)>
```
<Overlap Ratio: 0.7352941176470589>

---

--- 140 --
Question ID: 156d65351bdaa2294012bb59dc2b1d417be421b5_0
Original Code:
```
enum class RedirectState {
    kNone,

    // The redirect decision is pending from the underlying decider.
    kRedirectDecisionPending,

    // Redirect was disallowed by the underlying decider e.g., robots rules
    // decider.
    kRedirectNotAllowedByDecider,

    // The subresource request was redirected to attempt to compress it.
    kRedirectAttempted,

    // Failed due to http response codes, net errors, and the subresource was
    // fetched from original origin.
    kRedirectFailed
  };

  static std::unique_ptr<SubresourceRedirectURLLoaderThrottle>
  MaybeCreateThrottle(const blink::WebURLRequest& request, int render_frame_id);

  SubresourceRedirectURLLoaderThrottle(int render_frame_id,
                                       bool allowed_to_redirect);
  ~SubresourceRedirectURLLoaderThrottle() override;

  SubresourceRedirectURLLoaderThrottle(
      const SubresourceRedirectURLLoaderThrottle&) = delete;
  SubresourceRedirectURLLoaderThrottle& operator=(
      const SubresourceRedirectURLLoaderThrottle&) = delete;

  // blink::URLLoaderThrottle:
  void WillStartRequest(network::ResourceRequest* request,
                        bool* defer) override;
  void WillRedirectRequest(
      net::RedirectInfo* redirect_info,
      const network::mojom::URLResponseHead& response_head,
      bool* defer,
      std::vector<std::string>* to_be_removed_request_headers,
      net::HttpRequestHeaders* modified_request_headers,
      net::HttpRequestHeaders* modified_cors_exempt_request_headers) override;
  void BeforeWillProcessResponse(
      const GURL& response_url,
      const network::mojom::URLResponseHead& response_head,
      bool* defer) override;
  void WillProcessResponse(const GURL& response_url,
                           network::mojom::URLResponseHead* response_head,
                           bool* defer) override;
  void WillOnCompleteWithError(const network::URLLoaderCompletionStatus& status,
                               bool* defer) override;
  // Overridden to do nothing as the default implementation is NOT_REACHED()
  void DetachFromCurrentSequence() override;

 private:
  friend class SubresourceRedirectPublicImageHintsDeciderAgentTest;

  // Callback to notify the decision of decider subclasses.
  void NotifyRedirectDeciderDecision(RedirectResult);

  // Start the timer for redirect fetch timeout.
  void StartRedirectTimeoutTimer();

  // Callback invoked when the redirect fetch times out.
  void OnRedirectTimeout();

  // Render frame id to get the hints agent of the render frame.
  const int render_frame_id_;

  // The current state of redirect.
  RedirectState redirect_state_ = RedirectState::kNone;

  // Timer to detect whether the response from compression server has timed out.
  std::unique_ptr<base::OneShotTimer> redirect_timeout_timer_;

  // Whether the subresource can be redirected or not and what was the reason if
  // its not eligible.
  RedirectResult redirect_result_ = RedirectResult::kUnknown;

  // Used to record the image load and compression metrics.
  base::Optional<LoginRobotsCompressionMetrics>
      login_robots_compression_metrics_;

  // Used to get a weak pointer to |this|.
  base::WeakPtrFactory<SubresourceRedirectURLLoaderThrottle> weak_ptr_factory_{
      this};
};

}
```


Overlapping Code:
```

// The redirect decision is pending from the underlying decider.
kRedirectDecisionPending,
// Redirect was disallowed by the underlying decider e.g., robots rules
// decider.
kRedirectNotAllowedByDecider,
// The subresource request was redirected to attempt to compress it.
kRedirectAttempted,
// Failed due to http response codes, net errors, and the subresource was
// fetched from original origin.
kRedirectFailed
};
static std::unique_ptr<SubresourceRedirectURLLoaderThrottle>
MaybeCreateThrottle(const blink::WebURLRequest& request, int render_frame_id);
SubresourceRedirectURLLoaderThrottle(int render_frame_id,
bool allowed_to_redirect);
~SubresourceRedirectURLLoaderThrottle() override;
SubresourceRedirectURLLoaderThrottle(
const SubresourceRedirectURLLoaderThrottle&) = delete;
SubresourceRedirectURLLoaderThrottle& operator=(
const SubresourceRedirectURLLoaderThrottle&) = delete;
// blink::URLLoaderThrottle:
void WillStartRequest(network::ResourceRequest* request,
bool* defer) override;
void WillRedirectRequest(
net::RedirectInfo* redirect_info,
const network::mojom::URLResponseHead& response_head,
bool* defer,
std::vector<std::string>* to_be_removed_request_headers,
net::HttpRequestHeaders* modified_request_headers,
net::HttpRequestHeaders* modified_cors_exempt_request_headers) override;
void BeforeWillProcessResponse(
const GURL& response_url,
const network::mojom::URLResponseHead& response_head,
bool* defer) override;
void WillProcessResponse(const GURL& response_url,
network::mojom::URLResponseHead* response_head,
bool* defer) override;
void WillOnCompleteWithError(const network::URLLoaderCompletionStatus& status,
bool* defer) override;
// Overridden to do nothing as the default implementation is NOT_REACHED()
void DetachFromCurrentSequence() override;
private:
friend class SubresourceRedirectPublicImageHintsDeciderAgentTest;
// Callback to notify the decision of decider subclasses.
void NotifyRedirectDeciderDecision(RedirectResult);
// Start the timer for redirect fetch timeout.
void StartRedirectTimeoutTimer();
// Callback invoked when the redirect fetch tim
```
<Overlap Ratio: 0.9628610729023384>

---

--- 141 --
Question ID: 3f84796cc15b02e394117d9e739887488ed4300b_1
Original Code:
```
static int l_graphics_gcShader(lua_State* state) {
  l_graphics_Shader *shader = l_graphics_toShader(state, 1);
  free(shader->referencedTextures);

  // Unref textures to allow gc'ing them
  for(int i = 0; i < shader->shader.textureUnitCount; ++i) {
    luaL_unref(state, LUA_REGISTRYINDEX, shader->referencedTextures[i]);
  }
  
  graphics_Shader_free(&shader->shader);
  return 0;
}
```


Overlapping Code:
```
int l_graphics_gcShader(lua_State* state) {
l_graphics_Shader *shader = l_graphics_toShader(state, 1);
free(shader->referencedTextures);
// Unref textures to allow gc'ing them
for(int i = 0; i < shader->shader.textureUnitCount; ++i) {
luaL_unref(state, LUA_REGISTRYINDEX, shader->referencedTextures[i]);
}

graphics_Shader_free(&shader->shader);
retu
```
<Overlap Ratio: 0.9615384615384616>

---

--- 142 --
Question ID: b186697b933688c000ae152e7e7f3c125801a582_12
Original Code:
```
static void SDSPI_DecodeCid(sdspi_card_t *card, uint8_t *rawCid)
{
    assert(card != NULL);
    assert(rawCid != NULL);

    sd_cid_t *cid       = &(card->cid);
    cid->manufacturerID = rawCid[0U];
    cid->applicationID  = (uint16_t)(((uint32_t)rawCid[1U] << 8U) | (uint32_t)(rawCid[2U]));
    (void)memcpy(cid->productName, &rawCid[3U], SD_PRODUCT_NAME_BYTES);
    cid->productVersion      = rawCid[8U];
    cid->productSerialNumber = (((uint32_t)rawCid[9U] << 24U) | ((uint32_t)rawCid[10U] << 16U) |
                                ((uint32_t)rawCid[11U] << 8U) | ((uint32_t)rawCid[12U]));
    cid->manufacturerData    = (uint16_t)((((uint32_t)rawCid[13U] & 0x0FU) << 8U) | ((uint32_t)rawCid[14U]));
}
```


Overlapping Code:
```
tic void SDSPI_DecodeCid(sdspi_card_t *card, uint8_t *rawCid)
{
assert(card != NULL);
assert(rawCid != NULL);
sd_cid_t *cid = &(card->cid);
cid->manufacturerID = rawCid[0U];
cid->applicationID = (uint16_t)(((uint32_t)rawCid[1U] << 8U) | (uint32_t)(rawCid[2U]));
(void)memcpy(cid->productName, &rawCid[3U], SD_PRODUCT_NAME_BYTES);
cid->productVersion = rawCid[8U];
cid->productSerialNumber = (((uint32_t)rawCid[9U] << 24U) | ((uint32_t)rawCid[10U] << 16U) |
((uint32_t)rawCid[11U] << 8U) | ((uint32_t)rawCid[12U]));
cid->manufacturerData = (uint16_t)((((uint32_t)rawCid[13U] & 0x0FU) << 8U) | ((uint32
```
<Overlap Ratio: 0.9646302250803859>

---

--- 143 --
Question ID: 2c40a6f97da2dcce1492714e4cc690c16714bba2_101
Original Code:
```
void f101(void) {
    	volatile int64_t x457 = -1LL;
	int32_t x458 = 22140;
	int16_t x459 = -1;
	volatile int64_t t101 = 0LL;

    t101 = ((x457+x458)*(x459!=x460));

    if (t101 != 22139LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
7 = -1LL;
int32_t x458 = 22140;
int16_t x459 = -1;
volatile int64_t t101 = 0LL;
t101 = ((x457+x458)*(x459!=x460));
if (t101 != 22139LL) { NG(); } else
```
<Overlap Ratio: 0.7614213197969543>

---

--- 144 --
Question ID: d2c576268eed60813a04199beddb3f3569d9bfbc_0
Original Code:
```
static void
viaDumpDMA(ViaCommandBuffer *cb)
{
    register CARD32 *bp = cb->buf;
    CARD32 *endp = bp + cb->pos;

    while (bp != endp) {
        if (((bp - cb->buf) & 3) == 0) {
            ErrorF("\n %04lx: ", (unsigned long)(bp - cb->buf));
        }
        ErrorF("0x%08x ", (unsigned)*bp++);
    }
    ErrorF("\n");
}
```


Overlapping Code:
```
er *cb)
{
register CARD32 *bp = cb->buf;
CARD32 *endp = bp + cb->pos;
while (bp != endp) {
if (((bp - cb->buf) & 3) == 0) {
ErrorF("\n %04lx: ", (unsigned long)(bp - cb->buf));
}
ErrorF("0x%08x ", (un
```
<Overlap Ratio: 0.7434944237918215>

---

--- 145 --
Question ID: 37c7c99b9691194017f54de12c4696940bdc515a_191
Original Code:
```
void f191(void) {
    	static uint16_t x886 = UINT16_MAX;
	static int64_t x887 = -1LL;
	volatile int32_t x888 = INT32_MIN;
	int32_t t191 = 1898666;

    t191 = ((x885-x886)!=(x887==x888));

    if (t191 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
c uint16_t x886 = UINT16_MAX;
static int64_t x887 = -1LL;
volatile int32_t x888 = INT32_MIN;
int32_t t191 = 1898666;
t191 = ((x885-x886)!=(x887==x888)
```
<Overlap Ratio: 0.7009345794392523>

---

--- 146 --
Question ID: 5e3f7f09e6e992c0991336c7567b26287abe86ca_16
Original Code:
```
void max_rez (vec_p dst_v, vec_p src_v, vec_p segd_v, int nelts,
	       int nsegs, vec_p scratch_v)
{
  int *dst, *src;
  int *segd, *segment;
  int accum;
  int nelts_here, nsegs_here, current_seg, i;

  LOG_START (max_rez, nelts);
  nelts_here = _num_here (nelts);
  dst = (int *) (Mem + dst_v);
  src = (int *) (Mem + src_v);

  if (nsegs == 1) {
    accum = INT_MIN;
    for (i = 0; i < nelts_here; i++) {
      accum = max (accum, src[i]);
    }
    MPI_Reduce (&accum, &dst[0], 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
  } else {
    /* Initialize destination vector (segment reductions) to identity */
    nsegs_here = _num_here (nsegs);
    segd = (int *) (Mem + segd_v);
    segment = SegdSegment (segd, nelts, nsegs);
    for (i = 0; i < nsegs_here; i++) {
      dst[i] = INT_MIN;
    }

    /* Initialize an accumulator for the section of segment we have
     * seen so far, and the number of that segment */
    accum = INT_MIN;
    current_seg = 0;
    /* Iterate over the segmented source vector */
    {
      /* Normally, update accum with src[x].  If we hit a segment
       * boundary, send accum to the processor/offset pair that should
       * hold the reduction of the current segment, and combine it with
       * whatever is there using OP.  If accum is the identity, do not
       * bother: this saves time, and handles the special case of the
       * first element on each processor. */
      int n_sent = 0, n_rcvd = 0;
      int space = SpaceFor (nsegs);
      int x, y, loopbound;

      for (y = 0; y < nelts_here; y += RCV_EVERY) {
	loopbound = min (nelts_here, y + RCV_EVERY);
	for (x = y; x < loopbound; x++) {
	  if (segment[x] == current_seg) {
	    accum = max (accum, src[x]);
	  } else {
	    if (accum != INT_MIN) {
	      int proc = current_seg / space;
	      int offset = current_seg - (proc * space);

	      if (proc == Self) {
		dst[offset] = max (dst[offset], accum);
	      } else {
		int posn = Send_ctr[proc]++;
		intx *buf = (intx *) Usr_send[proc];

		buf[posn].value = accum;
		buf[posn].index = offset;
	      }
	    }
	    accum = src[x];
	    current_seg = segment[x];
	  }
	}
	n_rcvd += _recv_simple (dst, max_rez_tag, _unpack_max_intx);
	for (x = 0; x < NumProcs; x++) {
	  if (Send_ctr[x] >= ((BUF_SIZE / sizeof (intx)) - RCV_EVERY)) {
	    _send_buffer (x, max_rez_tag, (Send_ctr[x] * sizeof (intx)));
	    n_sent++;
	  }
	}
      }

      /* Send out the final result from each processor */
      if (accum != INT_MIN) {
	int proc = current_seg / space;
	int offset = current_seg - (proc * space);

	if (proc == Self) {
	  dst[offset] = max (dst[offset], accum);
	} else {
	  int posn = Send_ctr[proc]++;
	  intx *buf = (intx *) Usr_send[proc];

	  buf[posn].value = accum;
	  buf[posn].index = offset;
	}
      }
      _finish_simple (dst, max_rez_tag, n_sent, n_rcvd,
		      sizeof (intx), _unpack_max_intx);
    }
  }
  LOG_STOP (max_rez, nelts);
}
```


Overlapping Code:
```
z (vec_p dst_v, vec_p src_v, vec_p segd_v, int nelts,
int nsegs, vec_p scratch_v)
{
int *dst, *src;
int *segd, *segment;
int accum;
int nelts_here, nsegs_here, current_seg, i;
LOG_START (max_rez, nelts);
nelts_here = _num_here (nelts);
dst = (int *) (Mem + dst_v);
src = (int *) (Mem + src_v);
if (nsegs == 1) {
accum = INT_MIN;
for (i = 0; i < nelts_here; i++) {
accum = max (accum, src[i]);
}
MPI_Reduce (&accum, &dst[0], 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
} else {
/* Initialize destination vector (segment reductions) to identity */
nsegs_here = _num_here (nsegs);
segd = (int *) (Mem + segd_v);
segment = SegdSegment (segd, nelts, nsegs);
for (i = 0; i < nsegs_here; i++) {
dst[i] = INT_MIN;
}
/* Initialize an accumulator for the section of segment we have
* seen so far, and the number of that segment */
accum = INT_MIN;
current_seg = 0;
/* Iterate over the segmented source vector */
{
/* Normally, update accum with src[x]. If we hit a segment
* boundary, send accum to the processor/offset pair that should
* hold the reduction of the current segment, and combine it with
* whatever is there using OP. If accum is the identity, do not
* bother: this saves time, and handles the special case of the
* first element on each processor. */
int n_sent = 0, n_rcvd = 0;
int space = SpaceFor (nsegs);
int x, y, loopbound;
for (y = 0; y < nelts_here; y += RCV_EVERY) {
loopbound = min (nelts_here, y + RCV_EVERY);
for (x = y; x < loopbound; x++) {
if (segment[x] == current_seg) {
accum = max (accum, src[x]);
} else {
if (accum != INT_MIN) {
int proc = current_seg / space;
int offset = current_seg - (proc * space);
if (proc == Self) {
dst[offset] = max (dst[offset], accum);
} else {
int posn = Send_ctr[proc]++;
intx *buf = (intx *) Usr_send[proc];
buf[posn].value = accum;
buf[posn].index = offset;
}
}
accum = src[x];
current_seg = segment[x];
}
}
n_rcvd += _recv_simple (dst, max_rez_tag, _unpack_max_intx);
for (x = 0; x < NumProcs; x++) {
if (Send_ctr[x] >= ((BUF_SIZE / sizeof (intx)) - RCV_EVERY)) {
_send_buffer (x, max_rez_tag, (Send_ctr[x] * sizeof (intx)));
n_sent++;
}
}
}
/* Send out the final result from each processor */
if (accum != INT_MIN
```
<Overlap Ratio: 0.9863636363636363>

---

--- 147 --
Question ID: ceb9e796ef6127bcf2e99f16ea67bcc884aa01db_0
Original Code:
```
int main (int argc, char *argv[])
{
    int  i;
    void sig_handler ();
    void (*istat) ();

    argv0 = "dali";
    DisplayName = NULL;
    geometry = NULL;

    for (i = 1; i < argc; ++i) {
	if (argv[i][0] == '-') {
	    switch (argv[i][1]) {
		case 'f':
		    fmode = 1;	/* read dali_drc from CWD */
		    break;
		case 'o':
		    omode = 1;	/* animate output mode */
		    break;
		case 'r':
		    rmode = 1;	/* read only mode */
		    break;
		case 'A':
		    d_apollo = 1;/* Apollo mode */
		    break;
		case 'C':
		    colormap = 0;/* don't use Colormap */
		    break;
		case 'h':
		    DisplayName = argv[++i];
		    if (!DisplayName) usage ();
		    break;
		default:
		    usage ();
	    }
	}
	else {
	    if (argv[i][0] == '=') {
		geometry = argv[i];
	    }
	    else {
		Input_cell_name = argv[i];
	    }
	}
    }

    if (Input_cell_name) {
	if (strlen (Input_cell_name) > DM_MAXNAME) {
	    PE "input name '%s' is too long\n", Input_cell_name);
	    usage ();
	}
    }

    get_gterm ();

    signal (SIGHUP, SIG_IGN);
    signal (SIGINT, SIG_IGN);
    istat = signal (SIGQUIT, SIG_IGN);
    signal (SIGTERM, sig_handler);

    if (dmInit (argv0)) exit (1);

    dmproject = dmOpenProject (DEFAULT_PROJECT, rmode ? PROJ_READ : (PROJ_READ | PROJ_WRITE));

    if (!dmproject) stop_show (1);
    if (!dmGetMetaDesignData (PROCESS, dmproject)
        || dmproject -> maskdata == NULL
        || dmproject -> maskdata -> nomasks == 0) stop_show (1);

    if (!rmode) {
	char old_path[MAXCHAR], new_path[MAXCHAR];
	sprintf (old_path, "%s/.dmrc", dmproject -> dmpath);
	sprintf (new_path, "%s/.dmrc%d", dmproject -> dmpath, (int)getpid ());
	if (link (old_path, new_path) == -1) {
	    PE "%s: no write permission: read only mode!\n", argv0);
	    rmode = 1;
	}
	unlink (new_path);
    }

    graphic_mode = 1;

    open_dalirc ();
    init_graph ();
    initwindow ();
    save_oldw (); /* there is no prev_w */
    init_txtwdw ("Starting...");
    init_colmenu ();
    init_mem ();

 /* enable interrupt catching, if not ignored */
    if (istat != SIG_IGN) signal (SIGQUIT, sig_handler);
    signal (SIGSEGV, sig_handler);

    command ();			/* let's work */
 /* function command does not return */

    return (0);
}
```


Overlapping Code:
```

{
int i;
void sig_handler ();
void (*istat) ();
argv0 = "dali";
DisplayName = NULL;
geometry = NULL;
for (i = 1; i < argc; ++i) {
if (argv[i][0] == '-') {
switch (argv[i][1]) {
case 'f':
fmode = 1; /* read dali_drc from CWD */
break;
case 'o':
omode = 1; /* animate output mode */
break;
case 'r':
rmode = 1; /* read only mode */
break;
case 'A':
d_apollo = 1;/* Apollo mode */
break;
case 'C':
colormap = 0;/* don't use Colormap */
break;
case 'h':
DisplayName = argv[++i];
if (!DisplayName) usage ();
break;
default:
usage ();
}
}
else {
if (argv[i][0] == '=') {
geometry = argv[i];
}
else {
Input_cell_name = argv[i];
}
}
}
if (Input_cell_name) {
if (strlen (Input_cell_name) > DM_MAXNAME) {
PE "input name '%s' is too long\n", Input_cell_name);
usage ();
}
}
get_gterm ();
signal (SIGHUP, SIG_IGN);
signal (SIGINT, SIG_IGN);
istat = signal (SIGQUIT, SIG_IGN);
signal (SIGTERM, sig_handler);
if (dmInit (argv0)) exit (1);
dmproject = dmOpenProject (DEFAULT_PROJECT, rmode ? PROJ_READ : (PROJ_READ | PROJ_WRITE));
if (!dmproject) stop_show (1);
if (!dmGetMetaDesignData (PROCESS, dmproject)
|| dmproject -> maskdata == NULL
|| dmproject -> maskdata -> nomasks == 0) stop_show (1);
if (!rmode) {
char old_path[MAXCHAR], new_path[MAXCHAR];
sprintf (old_path, "%s/.dmrc", dmproject -> dmpath);
sprintf (new_path, "%s/.dmrc%d", dmproject -> dmpath, (int)getpid ());
if (link (old_path, new_path) == -1) {
PE "%s: no write permission: read only mode!\n", argv0);
rmode = 1;
}
unlink (new_path);
}
graphic_mode = 1;
open_dalirc ();
init_graph ();
initwindow ();
save_oldw (); /* there is no prev_w */
init_txtwdw ("Starting...");
init_colmenu ();
init_mem ();
/* enable interrupt catching, if not ignored */
if (istat != SIG_IGN) signal (SIGQUIT, sig_handler);
signal (SIGSEGV, sig_handler);
command (); /* let's work */
/* function command does not ret
```
<Overlap Ratio: 0.9721492380451918>

---

--- 148 --
Question ID: bae03da8cf60ef82acebc0a855c78f3baca74d0f_131
Original Code:
```
void f131(void) {
    	uint64_t x556 = UINT64_MAX;
	volatile int32_t t131 = -114;

    t131 = (((x553^x554)-x555)<=x556);

    if (t131 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x556 = UINT64_MAX;
volatile int32_t t131 = -114;
t131 = (((x553^x554)-x555)<=x556);
if (t131 != 1) 
```
<Overlap Ratio: 0.6711409395973155>

---

--- 149 --
Question ID: e1e4fefdc4c7aa59b452aa31c64b3b1dc2a02c69_4
Original Code:
```
static int
globus_l_gass_cache_linktest(globus_i_gass_cache_t  *cache)
{
    char         dir[PATH_MAX];
    char         file[PATH_MAX];
    char         link1[PATH_MAX];
    char         link2[PATH_MAX];
    int          fd;
    int          rc;
    struct stat  stx;
    globus_thread_t t = globus_thread_self();

    rc = DIRECTORY_TYPE_NOLINK;

    sprintf(dir, "%s/dir-%ld-%ld",
                        cache->cache_directory_path,
                        (long) globus_libc_getpid(),
                        (long) t.dummy );
    
    sprintf(file, "%s/file", dir );
    sprintf(link1, "%s/link", dir );

    sprintf(link2, "%s/link-%ld-%ld",
            cache->cache_directory_path,
            (long) globus_libc_getpid(),
            (long) t.dummy );

    /* create test dir and file */
    rmdir(dir);
    if (mkdir( dir, GLOBUS_L_GASS_CACHE_DIR_MODE ))
       goto cleanup;

    fd = open(file, O_RDWR|O_CREAT|O_TRUNC, GLOBUS_L_GASS_CACHE_MODE_RW);
    if (fd < 0)
       goto cleanup;

    close(fd);

    /* verify n_link returns correct value */
    stx.st_nlink = 0;
    if (stat(file, &stx) || (stx.st_nlink != 1))
        goto cleanup;

    /* test (a): link in same directory */
    stx.st_nlink = 0;
    if (link(file,link1) || stat(file,&stx) || stx.st_nlink!=2)
        goto cleanup;

    rc = DIRECTORY_TYPE_FLAT;

    /* test (b): link from another directory */
    stx.st_nlink = 0;
    if (link(file,link2) || stat(file,&stx) || stx.st_nlink!=3)
        goto cleanup;

    rc = DIRECTORY_TYPE_NORMAL;
    
 cleanup:
    remove(link1);
    remove(link2);
    remove(file);
    rmdir(dir);

    return rc;
}
```


Overlapping Code:
```
est(globus_i_gass_cache_t *cache)
{
char dir[PATH_MAX];
char file[PATH_MAX];
char link1[PATH_MAX];
char link2[PATH_MAX];
int fd;
int rc;
struct stat stx;
globus_thread_t t = globus_thread_self();
rc = DIRECTORY_TYPE_NOLINK;
sprintf(dir, "%s/dir-%ld-%ld",
cache->cache_directory_path,
(long) globus_libc_getpid(),
(long) t.dummy );

sprintf(file, "%s/file", dir );
sprintf(link1, "%s/link", dir );
sprintf(link2, "%s/link-%ld-%ld",
cache->cache_directory_path,
(long) globus_libc_getpid(),
(long) t.dummy );
/* create test dir and file */
rmdir(dir);
if (mkdir( dir, GLOBUS_L_GASS_CACHE_DIR_MODE ))
goto cleanup;
fd = open(file, O_RDWR|O_CREAT|O_TRUNC, GLOBUS_L_GASS_CACHE_MODE_RW);
if (fd < 0)
goto cleanup;
close(fd);
/* verify n_link returns correct value */
stx.st_nlink = 0;
if (stat(file, &stx) || (stx.st_nlink != 1))
goto cleanup;
/* test (a): link in same directory */
stx.st_nlink = 0;
if (link(file,link1) || stat(file,&stx) || stx.st_nlink!=2)
goto cleanup;
rc = DIRECTORY_TYPE_FLAT;
/* test (b): link from another directory */
stx.st_nlink = 0;
if (link(file,link2) || stat(file,&stx) || stx.st_nlink!=3)
goto cleanup;
rc = DIRECTORY_TYPE_NORMAL;

cleanup:
remove(link1);
remove(link2);
r
```
<Overlap Ratio: 0.9426551453260016>

---

--- 150 --
Question ID: b10c0f85ac043f2e2514d2042e13aba1b4621f1f_2
Original Code:
```
static sds getDotfilePath(char *envoverride, char *dotfilename) {
    char *path = NULL;
    sds dotPath = NULL;

    /* Check the env for a dotfile override. */
    path = getenv(envoverride);
    if (path != NULL && *path != '\0') {
        if (!strcmp("/dev/null", path)) {
            return NULL;
        }

        /* If the env is set, return it. */
        dotPath = sdsnew(path);
    } else {
        char *home = getenv("HOME");
        if (home != NULL && *home != '\0') {
            /* If no override is set use $HOME/<dotfilename>. */
            dotPath = sdscatprintf(sdsempty(), "%s/%s", home, dotfilename);
        }
    }
    return dotPath;
}
```


Overlapping Code:
```
tic sds getDotfilePath(char *envoverride, char *dotfilename) {
char *path = NULL;
sds dotPath = NULL;
/* Check the env for a dotfile override. */
path = getenv(envoverride);
if (path != NULL && *path != '\0') {
if (!strcmp("/dev/null", path)) {
return NULL;
}
/* If the env is set, return it. */
dotPath = sdsnew(path);
} else {
char *home = getenv("HOME");
if (home != NULL && *home != '\0') {
/* If no override is set use $HOME/<dotfilename>. */
dotPath = sdscatprintf(sdsempty(), "%s/%s", home, dotfilename);
}
}
return 
```
<Overlap Ratio: 0.9757462686567164>

---

--- 151 --
Question ID: 8edd64c20751668ddbe3a913ea99024a33ab8d4e_51
Original Code:
```
void f51(void) {
    	uint32_t x1929 = 3U;
	static int64_t x1930 = INT64_MAX;
	int16_t x1932 = -12;
	int64_t t51 = 133127116044LL;

    t51 = (((x1929/x1930)<<x1931)+x1932);

    if (t51 != -12LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
tic int64_t x1930 = INT64_MAX;
int16_t x1932 = -12;
int64_t t51 = 133127116044LL;
t51 = (((x1929/x1930)<<x1931)+x1932);
if (t51 != -12LL) { NG(); } el
```
<Overlap Ratio: 0.7425742574257426>

---

--- 152 --
Question ID: b802ae201b00a8bc6920f60e8bca922874717f44_0
Original Code:
```
interface SASourceInfo : NSObject {

	unsigned _lineNum;
	unsigned _columnNum;
	unsigned long long _offsetIntoSegment;
	unsigned long long _length;
	NSString* _filePath;

}
```


Overlapping Code:
```
ect {
unsigned _lineNum;
unsigned _columnNum;
unsigned long long _offsetIntoSegment;
unsigned long long _length;
N
```
<Overlap Ratio: 0.6909090909090909>

---

--- 153 --
Question ID: 3a02f344b5c15fd5cd52ce9fc6cd4195358f934a_47
Original Code:
```
__DEFAULT_SVML_FN_ATTRS512
    _mm512_mask_atan_pd(__m512d param0, __mmask8 param1, __m512d param2) 
{ 
    register __m512d reg0 asm("zmm0");
    reg0 = _mm512_mask_load_pd(param0,param1, &param2);
    asm( 
         "call __vdecl_atan8 \t\n" 
        : "=v" (reg0)
        : "0" (reg0)
        : "%ymm1", "%ymm2", "%ymm3", "%ymm4", "%ymm5", "%rax", "%rcx", "%rdx", "%r8", "%r9", "%r10", "%r11"
        );
     param2 = param0;
    _mm512_mask_store_pd(&param2,param1,reg0);
    return param2;
}
```


Overlapping Code:
```
(__m512d param0, __mmask8 param1, __m512d param2) 
{ 
register __m512d reg0 asm("zmm0");
reg0 = _mm512_mask_load_pd(param0,param1, &param2);
asm( 
"call __vdecl_atan8 \t\n" 
: "=v" (reg0)
: "0" (reg0)
: "%ymm1", "%ymm2", "%ymm3", "%ymm4", "%ymm5", "%rax", "%rcx", "%rdx", "%r8", "%r9", "%r10", "%r11"
);
param2 = param0;
_mm512_mask_store_pd(&param2,param1,reg0);
return param2;
}
```
<Overlap Ratio: 0.892018779342723>

---

--- 154 --
Question ID: 8985befacafccf376c7213e5c442b2397928db45_35
Original Code:
```
void f35(void) {
    	static int32_t x213 = INT32_MAX;
	int32_t x214 = 164;

    t35 = (x213%(x214+(x215*x216)));

    if (t35 != 89) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x213 = INT32_MAX;
int32_t x214 = 164;
t35 = (x213%(x214+(x215*x216)));
if (t35 != 89) { NG()
```
<Overlap Ratio: 0.7092198581560284>

---

--- 155 --
Question ID: 7b4c618cc4311ae6150fe898dc911af42a3c927b_1
Original Code:
```
int FindItemByPoint(int x, int y)
    {
      int l=GetCount();
      for(int i=0;i<l;i++)
      {
        RECT r;
        GetItemRect(i, &r);
        if(r.left<=x && r.right>=x && r.top<=y && r.bottom>=y) return i;
      }
      return -1;
    }
```


Overlapping Code:
```
t FindItemByPoint(int x, int y)
{
int l=GetCount();
for(int i=0;i<l;i++)
{
RECT r;
GetItemRect(i, &r);
if(r.left<=x && r.right>=x && r.top<=y && r.bott
```
<Overlap Ratio: 0.8206521739130435>

---

--- 156 --
Question ID: 14a2462f6ab25a6701cdb2bd5a973c62c31cc466_0
Original Code:
```
class CSpikeProfilerModule : public ATL::CAtlDllModuleT< CSpikeProfilerModule >
{
public :
	DECLARE_LIBID(LIBID_SpikeProfilerLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_SPIKEPROFILER, "{15FA5249-D5F2-453A-A8EF-F75DFFE960FD}")
};

extern class CSpikeProfilerModule _AtlModule;
```


Overlapping Code:
```
ss CSpikeProfilerModule : public ATL::CAtlDllModuleT< CSpikeProfilerModule >
{
public :
DECLARE_LIBID(LIBID_SpikeProfilerLib)
DECLARE_REGISTRY_APPID_RESOURCEID(IDR_SPIKEPROFILER, "{15FA5249-D5F2-453A-A8EF-F75DFFE960FD}")
};
extern class CSpikeProfile
```
<Overlap Ratio: 0.9191176470588235>

---

--- 157 --
Question ID: c039a541a9582a3da5aa1355c493c1cb638b5df2_150
Original Code:
```
void f150(void) {
    	static int16_t x621 = -1;
	volatile uint64_t x622 = UINT64_MAX;
	static int16_t x623 = INT16_MAX;
	uint32_t x624 = UINT32_MAX;
	uint64_t t150 = 117257589722LLU;

    t150 = (x621^((x622/x623)&x624));

    if (t150 != 18446744073709027311LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 {
static int16_t x621 = -1;
volatile uint64_t x622 = UINT64_MAX;
static int16_t x623 = INT16_MAX;
uint32_t x624 = UINT32_MAX;
uint64_t t150 = 117257589722LLU;
t150 = (x621^((x622/x623)&x624));
if (t150 != 18446744073709027311LLU
```
<Overlap Ratio: 0.8513011152416357>

---

--- 158 --
Question ID: b2e0d8c2493e8ed55706dacd14ca4eccae1e0e53_11
Original Code:
```
static int
make_enum(struct enum_s *restrict tgt, echs_instant_t proto, rrulsp_t rr)
{
	size_t nH = 0U;
	size_t nM = 0U;
	size_t nS = 0U;
	unsigned int tmp;

	/* get all hours */
	for (bitint_iter_t Hi = 0UL;
	     (tmp = bui31_next(&Hi, rr->H), Hi);) {
		tgt->H[nH++] = (uint8_t)tmp;
	}
	if (!nH) {
		tgt->H[nH++] = (uint8_t)proto.H;
	}
	/* get all minutes */
	for (bitint_iter_t Mi = 0UL;
	     (tmp = bui63_next(&Mi, rr->M), Mi);) {
		tgt->M[nM++] = (uint8_t)tmp;
	}
	if (!nM) {
		tgt->M[nM++] = (uint8_t)proto.M;
	}
	/* get all them seconds */
	for (bitint_iter_t Si = 0UL;
	     (tmp = bui63_next(&Si, rr->S), Si);) {
		tgt->S[nS++] = (uint8_t)tmp;
	}
	if (!nS) {
		tgt->S[nS++] = (uint8_t)proto.S;
	}
	tgt->nH = nH;
	tgt->nM = nM;
	tgt->nS = nS;
	return 0;
}
```


Overlapping Code:
```
tgt, echs_instant_t proto, rrulsp_t rr)
{
size_t nH = 0U;
size_t nM = 0U;
size_t nS = 0U;
unsigned int tmp;
/* get all hours */
for (bitint_iter_t Hi = 0UL;
(tmp = bui31_next(&Hi, rr->H), Hi);) {
tgt->H[nH++] = (uint8_t)tmp;
}
if (!nH) {
tgt->H[nH++] = (uint8_t)proto.H;
}
/* get all minutes */
for (bitint_iter_t Mi = 0UL;
(tmp = bui63_next(&Mi, rr->M), Mi);) {
tgt->M[nM++] = (uint8_t)tmp;
}
if (!nM) {
tgt->M[nM++] = (uint8_t)proto.M;
}
/* get all them seconds */
for (bitint_iter_t Si = 0UL;
(tmp = bui63_next(&Si, rr->S), Si);) {
tgt->S[nS++] = (uint8_t)tmp;
}
if (!nS) {
tgt->S[nS++] = (uint8_t)proto.S;
}
tgt->nH = nH;
tgt->nM = nM;
tgt->nS = 
```
<Overlap Ratio: 0.9154929577464789>

---

--- 159 --
Question ID: ecf0d208ddc4b0234ec844d2720779ca2f143e93_29
Original Code:
```
uint32_t* xnu_pf_imm64_load_emit(uint32_t* insn_stream, uint8_t reg, uint64_t value) {

    *insn_stream++ = ((0x6940000 | (value & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));

    if ((value >> 16) & 0xFFFF) {
        *insn_stream++ = ((0x7950000 | ((value >> 16) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
    }
    if ((value >> 32) & 0xFFFF) {
        *insn_stream++ = ((0x7960000 | ((value >> 32) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
    }
    if ((value >> 48) & 0xFFFF) {
        *insn_stream++ = ((0x7970000 | ((value >> 48) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
    }

    return insn_stream;
}
```


Overlapping Code:
```
nt32_t* xnu_pf_imm64_load_emit(uint32_t* insn_stream, uint8_t reg, uint64_t value) {
*insn_stream++ = ((0x6940000 | (value & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
if ((value >> 16) & 0xFFFF) {
*insn_stream++ = ((0x7950000 | ((value >> 16) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
}
if ((value >> 32) & 0xFFFF) {
*insn_stream++ = ((0x7960000 | ((value >> 32) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
}
if ((value >> 48) & 0xFFFF) {
*insn_stream++ = ((0x7970000 | ((value >> 48) & 0xFFFF)) << 5) | ((uint32_t)(reg & 0x1f));
}
return insn_s
```
<Overlap Ratio: 0.9821428571428571>

---

--- 160 --
Question ID: bc2eb6d78305c5bcc3610f54f305dbef70e15a44_17
Original Code:
```
static inline void
pango_span_markup_init (cea708PangoSpanControl * span_control)
{
  memset (span_control, 0, sizeof (cea708PangoSpanControl));
  span_control->size = PEN_SIZE_STANDARD;
  span_control->fg_color = CEA708_COLOR_WHITE;
  span_control->bg_color = CEA708_COLOR_INVALID;
  span_control->size = PEN_SIZE_STANDARD;
  span_control->font_style = FONT_STYLE_DEFAULT;
}
```


Overlapping Code:
```
kup_init (cea708PangoSpanControl * span_control)
{
memset (span_control, 0, sizeof (cea708PangoSpanControl));
span_control->size = PEN_SIZE_STANDARD;
span_control->fg_color = CEA708_COLOR_WHITE;
span_control->bg_color = CEA708_COLOR_INVALID;
span_control->size = PEN_SIZE_STANDARD;
span_control->font
```
<Overlap Ratio: 0.8264462809917356>

---

--- 161 --
Question ID: eb348c91071718d9740114ba881b47eee4c0d6c6_8
Original Code:
```
static int route4_change(struct tcf_proto *tp, unsigned long base,
		       u32 handle,
		       struct rtattr **tca,
		       unsigned long *arg)
{
	struct route4_head *head = tp->root;
	struct route4_filter *f, *f1, **ins_f;
	struct route4_bucket *b;
	struct rtattr *opt = tca[TCA_OPTIONS-1];
	struct rtattr *tb[TCA_ROUTE4_MAX];
	unsigned h1, h2;
	int err;

	if (opt == NULL)
		return handle ? -EINVAL : 0;

	if (rtattr_parse(tb, TCA_ROUTE4_MAX, RTA_DATA(opt), RTA_PAYLOAD(opt)) < 0)
		return -EINVAL;

	if ((f = (struct route4_filter*)*arg) != NULL) {
		/* Node exists: adjust only classid */

		if (f->handle != handle && handle)
			return -EINVAL;
		if (tb[TCA_ROUTE4_CLASSID-1]) {
			unsigned long cl;

			f->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);
			cl = cls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));
			if (cl)
				tp->q->ops->cl_ops->unbind_tcf(tp->q, cl);
		}
#ifdef CONFIG_NET_CLS_POLICE
		if (tb[TCA_ROUTE4_POLICE-1]) {
			struct tcf_police *police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);

			tcf_tree_lock(tp);
			police = xchg(&f->police, police);
			tcf_tree_unlock(tp);

			tcf_police_release(police);
		}
#endif
		return 0;
	}

	/* Now more serious part... */

	if (head == NULL) {
		head = kmalloc(sizeof(struct route4_head), GFP_KERNEL);
		if (head == NULL)
			return -ENOBUFS;
		memset(head, 0, sizeof(struct route4_head));

		tcf_tree_lock(tp);
		tp->root = head;
		tcf_tree_unlock(tp);
	}

	f = kmalloc(sizeof(struct route4_filter), GFP_KERNEL);
	if (f == NULL)
		return -ENOBUFS;

	memset(f, 0, sizeof(*f));

	err = -EINVAL;
	f->handle = 0x8000;
	if (tb[TCA_ROUTE4_TO-1]) {
		if (handle&0x8000)
			goto errout;
		if (RTA_PAYLOAD(tb[TCA_ROUTE4_TO-1]) < 4)
			goto errout;
		f->id = *(u32*)RTA_DATA(tb[TCA_ROUTE4_TO-1]);
		if (f->id > 0xFF)
			goto errout;
		f->handle = f->id;
	}
	if (tb[TCA_ROUTE4_FROM-1]) {
		u32 sid;
		if (tb[TCA_ROUTE4_IIF-1])
			goto errout;
		if (RTA_PAYLOAD(tb[TCA_ROUTE4_FROM-1]) < 4)
			goto errout;
		sid = (*(u32*)RTA_DATA(tb[TCA_ROUTE4_FROM-1]));
		if (sid > 0xFF)
			goto errout;
		f->handle |= sid<<16;
		f->id |= sid<<16;
	} else if (tb[TCA_ROUTE4_IIF-1]) {
		if (RTA_PAYLOAD(tb[TCA_ROUTE4_IIF-1]) < 4)
			goto errout;
		f->iif = *(u32*)RTA_DATA(tb[TCA_ROUTE4_IIF-1]);
		if (f->iif > 0x7FFF)
			goto errout;
		f->handle |= (f->iif|0x8000)<<16;
	} else
		f->handle |= 0xFFFF<<16;

	if (handle) {
		f->handle |= handle&0x7F00;
		if (f->handle != handle)
			goto errout;
	}

	if (tb[TCA_ROUTE4_CLASSID-1]) {
		if (RTA_PAYLOAD(tb[TCA_ROUTE4_CLASSID-1]) < 4)
			goto errout;
		f->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);
	}

	h1 = to_hash(f->handle);
	if ((b = head->table[h1]) == NULL) {
		err = -ENOBUFS;
		b = kmalloc(sizeof(struct route4_bucket), GFP_KERNEL);
		if (b == NULL)
			goto errout;
		memset(b, 0, sizeof(*b));

		tcf_tree_lock(tp);
		head->table[h1] = b;
		tcf_tree_unlock(tp);
	}
	f->bkt = b;

	err = -EEXIST;
	h2 = from_hash(f->handle>>16);
	for (ins_f = &b->ht[h2]; (f1=*ins_f) != NULL; ins_f = &f1->next) {
		if (f->handle < f1->handle)
			break;
		if (f1->handle == f->handle)
			goto errout;
	}

	cls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));
#ifdef CONFIG_NET_CLS_POLICE
	if (tb[TCA_ROUTE4_POLICE-1])
		f->police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);
#endif

	f->next = f1;
	tcf_tree_lock(tp);
	*ins_f = f;
	tcf_tree_unlock(tp);

	route4_reset_fastmap(tp->q->dev, head, f->id);
	*arg = (unsigned long)f;
	return 0;

errout:
	if (f)
		kfree(f);
	return err;
}
```


Overlapping Code:
```
tatic int route4_change(struct tcf_proto *tp, unsigned long base,
u32 handle,
struct rtattr **tca,
unsigned long *arg)
{
struct route4_head *head = tp->root;
struct route4_filter *f, *f1, **ins_f;
struct route4_bucket *b;
struct rtattr *opt = tca[TCA_OPTIONS-1];
struct rtattr *tb[TCA_ROUTE4_MAX];
unsigned h1, h2;
int err;
if (opt == NULL)
return handle ? -EINVAL : 0;
if (rtattr_parse(tb, TCA_ROUTE4_MAX, RTA_DATA(opt), RTA_PAYLOAD(opt)) < 0)
return -EINVAL;
if ((f = (struct route4_filter*)*arg) != NULL) {
/* Node exists: adjust only classid */
if (f->handle != handle && handle)
return -EINVAL;
if (tb[TCA_ROUTE4_CLASSID-1]) {
unsigned long cl;
f->res.classid = *(u32*)RTA_DATA(tb[TCA_ROUTE4_CLASSID-1]);
cl = cls_set_class(tp, &f->res.class, tp->q->ops->cl_ops->bind_tcf(tp->q, base, f->res.classid));
if (cl)
tp->q->ops->cl_ops->unbind_tcf(tp->q, cl);
}
#ifdef CONFIG_NET_CLS_POLICE
if (tb[TCA_ROUTE4_POLICE-1]) {
struct tcf_police *police = tcf_police_locate(tb[TCA_ROUTE4_POLICE-1], tca[TCA_RATE-1]);
tcf_tree_lock(tp);
police = xchg(&f->police, police);
tcf_tree_unlock(tp);
tcf_police_release(police);
}
#endif
return 0;
}
/* Now more serious part... */
if (head == NULL) {
head = kmalloc(sizeof(struct route4_head), GFP_KERNEL);
if (head == NULL)
return -ENOBUFS;
memset(head, 0, sizeof(struct route4_head));
tcf_tree_lock(tp);
tp->root = head;
tcf_tree_unlock(tp);
}
f = kmalloc(sizeof(struct route4_filter), GFP_KERNEL);
if (f == NULL)
return -ENOBUFS;
memset(f, 0, sizeof(*f));
err = -EINVAL;
f->handle = 0x8000;
if (tb[TCA_ROUTE4_TO-1]) {
if (handle&0x8000)
goto errout;
if (RTA_PAYLOAD(tb[TCA_ROUTE4_TO-1]) < 4)
goto errout;
f->id = *(u32*)RTA_DATA(tb[TCA_ROUTE4_TO-1]);
if (f->id > 0xFF)
goto errout;
f->handle = f->id;
}
if (tb[TCA_ROUTE4_FROM-1]) {
u32 sid;
if (tb[TCA_ROUTE4_IIF-1])
goto errout;
if (RTA_PAYLOAD(tb[TCA_ROUTE4_FROM-1]) < 4)
goto errout;
sid = (*(u32*)RTA_DATA(tb[TCA_ROUTE4_FROM-1]));
if (sid > 0xFF)
goto errout;
f->handle |= sid<<16;
f->id |= sid<<16;
} else if (tb[TCA_ROUTE4_IIF-1]) {
if (RTA_PAYLOAD(tb[TCA_ROUTE4_IIF-1]) < 4)
goto errout;
f->iif = *(u32*)RTA_DATA(tb[TCA_ROUTE4_IIF-1]);
if (f->iif > 0x7FFF)
goto errout;
f->handle |= (f->iif|0x8000)<<16;
} else
f->handle |= 0xFFFF<<16;
if (handle) {
f->han
```
<Overlap Ratio: 0.97868638538495>

---

--- 162 --
Question ID: 05e5e41e314363d8dba2cefad8b5292443adc6be_486
Original Code:
```
hferr_t
handle_HFCUDA_cusparseCnnz ( void )
{
  hfinf( "[daemon] cusparseCnnz() [CALL]\n" );
  
  struct __attribute__((packed)) {
    uint8_t ____CAT2_BITMAP;
    cusparseHandle_t handle;
    cusparseDirection_t dirA;
    int m;
    int n;
    cusparseMatDescr_t descrA;
    const cuComplex * A;
    int lda;
    int * nnzPerRowCol;
    int * nnzTotalDevHostPtr;
  } t2d_msg_data;
  
  hfcheck( hfcuda_comm_recv( &t2d_msg_data, sizeof(t2d_msg_data) ));
  struct {
    cusparseStatus_t ____RETVAL;
    int nnzTotalDevHostPtr;
  } d2t_msg;
  d2t_msg.____RETVAL = cusparseCnnz( t2d_msg_data.handle, t2d_msg_data.dirA, t2d_msg_data.m, t2d_msg_data.n, t2d_msg_data.descrA, t2d_msg_data.A, t2d_msg_data.lda, t2d_msg_data.nnzPerRowCol, (((t2d_msg_data.____CAT2_BITMAP >> 0) & 0x1) ? &d2t_msg.nnzTotalDevHostPtr : t2d_msg_data.nnzTotalDevHostPtr) );
  
  hfcheck( hfcuda_comm_send( &d2t_msg, sizeof(d2t_msg) ));
  hfinf( "[daemon] cusparseCnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );
  
  return HFOK;
}
```


Overlapping Code:
```
ndle_HFCUDA_cusparseCnnz ( void )
{
hfinf( "[daemon] cusparseCnnz() [CALL]\n" );

struct __attribute__((packed)) {
uint8_t ____CAT2_BITMAP;
cusparseHandle_t handle;
cusparseDirection_t dirA;
int m;
int n;
cusparseMatDescr_t descrA;
const cuComplex * A;
int lda;
int * nnzPerRowCol;
int * nnzTotalDevHostPtr;
} t2d_msg_data;

hfcheck( hfcuda_comm_recv( &t2d_msg_data, sizeof(t2d_msg_data) ));
struct {
cusparseStatus_t ____RETVAL;
int nnzTotalDevHostPtr;
} d2t_msg;
d2t_msg.____RETVAL = cusparseCnnz( t2d_msg_data.handle, t2d_msg_data.dirA, t2d_msg_data.m, t2d_msg_data.n, t2d_msg_data.descrA, t2d_msg_data.A, t2d_msg_data.lda, t2d_msg_data.nnzPerRowCol, (((t2d_msg_data.____CAT2_BITMAP >> 0) & 0x1) ? &d2t_msg.nnzTotalDevHostPtr : t2d_msg_data.nnzTotalDevHostPtr) );

hfcheck( hfcuda_comm_send( &d2t_msg, sizeof(d2t_msg) ));
hfinf( "[daemon] cusparseCnnz() [DONE] status=%d\n", d2t_msg.____RETVAL );

return HFOK;
}
```
<Overlap Ratio: 0.9891891891891892>

---

--- 163 --
Question ID: 768538b1fd1915b8d19b3800188811bed72de1a5_69
Original Code:
```
bool do_ite_lookup_op(chunk_ptr op) {
    ref_mgr mgr = dmgr->rmgr;
    dword_t dest = chunk_get_dword(op, OP_HEADER_CNT);
    ref_t iref = (ref_t) chunk_get_word(op, 0+OPER_SIZE+OP_HEADER_CNT);
    ref_t tref = (ref_t) chunk_get_word(op, 1+OPER_SIZE+OP_HEADER_CNT);
    ref_t eref = (ref_t) chunk_get_word(op, 2+OPER_SIZE+OP_HEADER_CNT);
    bool negate = (bool) chunk_get_word(op, 3+OPER_SIZE+OP_HEADER_CNT);
#if RPT >= 4
    char buf1[24], buf2[24], buf3[24];
    ref_show(iref, buf1); ref_show(tref, buf2); ref_show(eref, buf3);
    char *ns = negate ? "!" : "";
    report(4, "Computing %sITE(%s, %s, %s)", ns, buf1, buf2, buf3);
#endif
    chunk_ptr ucp = ref3_encode(iref, tref, eref);
    ref_t rlook = ref_ite_lookup(mgr, ucp);
    if (!REF_IS_RECURSE(rlook)) {
	chunk_free(ucp);
	if (negate)
	    rlook = REF_NEGATE(rlook);
#if RPT >= 4
	char buf1[24];
	ref_show(rlook, buf1);
	report(4, "\tFound via lookup: %s", buf1);
#endif
	bool ok = send_ref_as_operand(dest, rlook);	
	return ok;
    }
    /* Check if pending ITE */
    word_t wk, wv;
    if (keyvalue_remove(dmgr->deferred_ite_table, (word_t) ucp, &wk, &wv)) {
	/* Add to deferred ITE table */
	chunk_ptr old_ucp = (chunk_ptr) wk;
	ilist_ptr ls = (ilist_ptr) wv;
	ilist_ptr ele = ilist_new(dest, negate);
	/* Add to list */
	ele->next = ls;
	keyvalue_insert(dmgr->deferred_ite_table, (word_t) old_ucp,
			(word_t) ele);
	chunk_free(ucp);
#if RPT >= 4
	char ibuf[24], tbuf[24], ebuf[24];
	ref_show(iref, ibuf); ref_show(tref, tbuf), ref_show(eref, ebuf);
	char *sn = negate ? "!" : "";
	word_t op_id = msg_get_dest_op_id(dest);
	unsigned agent = msg_get_dest_agent(dest);
	report(4, "\tDeferring %sITE(%s, %s, %s).  Agent %u, Op Id 0x%lx",
	       sn, ibuf, tbuf, ebuf, agent, op_id);
#endif	    
	return true;
    } else {
	/* Insert empty list as placeholder */
	ilist_ptr ls = NULL;
	keyvalue_insert(dmgr->deferred_ite_table, (word_t) ucp, (word_t) ls);
    }
    /* Must do recursion */
    size_t ivar = REF_GET_VAR(iref);
    size_t tvar = REF_GET_VAR(tref);
    size_t evar = REF_GET_VAR(eref);
    size_t var = ivar;
    if (tvar < var) { var = tvar; }
    if (evar < var) { var = evar; }
    ref_t vref = REF_VAR(var);
#if RPT >= 4
    ref_show(vref, buf1);
    report(4, "\tSplitting on variable %s", buf1);
#endif
    /* Create next operations */
    chunk_ptr sop = build_ite_store(dest, iref, tref, eref, negate);
    dword_t sdest =  msg_new_destination(sop, 3+OPER_SIZE+OP_HEADER_CNT);
    chunk_ptr rop = build_ite_recurse(sdest, vref);
    ref_t nvref, nhiref, nloref;
    bool ok = true;
    /* Fill in any known fields, and spawn retrieve operations for others */
    if (ivar == var) {
	if (ref_deref_local(iref, &nvref, &nhiref, &nloref)) {
	    op_insert_word(rop, (word_t) nhiref, 1+OPER_SIZE+OP_HEADER_CNT);
	    op_insert_word(rop, (word_t) nloref, 2+OPER_SIZE+OP_HEADER_CNT);
	} else {
	    dword_t ndest = msg_new_destination(rop, 1+OPER_SIZE+OP_HEADER_CNT);
	    ok = ok && send_retrieve(ndest, iref);
	}
    } else {
	op_insert_word(rop, (word_t) iref, 1+OPER_SIZE+OP_HEADER_CNT);
	op_insert_word(rop, (word_t) iref, 2+OPER_SIZE+OP_HEADER_CNT);
    }
    if (tvar == var) {
	if (ref_deref_local(tref, &nvref, &nhiref, &nloref)) {
	    op_insert_word(rop, (word_t) nhiref, 3+OPER_SIZE+OP_HEADER_CNT);
	    op_insert_word(rop, (word_t) nloref, 4+OPER_SIZE+OP_HEADER_CNT);
	} else {
	    dword_t ndest = msg_new_destination(rop, 3+OPER_SIZE+OP_HEADER_CNT);
	    ok = ok && send_retrieve(ndest, tref);
	}
    } else {
	op_insert_word(rop, (word_t) tref, 3+OPER_SIZE+OP_HEADER_CNT);
	op_insert_word(rop, (word_t) tref, 4+OPER_SIZE+OP_HEADER_CNT);
    }
    if (evar == var) {
	if (ref_deref_local(eref, &nvref, &nhiref, &nloref)) {
	    op_insert_word(rop, (word_t) nhiref, 5+OPER_SIZE+OP_HEADER_CNT);
	    op_insert_word(rop, (word_t) nloref, 6+OPER_SIZE+OP_HEADER_CNT);
	} else {
	    dword_t ndest = msg_new_destination(rop, 5+OPER_SIZE+OP_HEADER_CNT);
	    ok = ok && send_retrieve(ndest, eref);
	}
    } else {
	op_insert_word(rop, (word_t) eref, 5+OPER_SIZE+OP_HEADER_CNT);
	op_insert_word(rop, (word_t) eref, 6+OPER_SIZE+OP_HEADER_CNT);
    }
    ok = ok && send_op(sop);
    ok = ok && send_op(rop);
    chunk_free(sop);
    chunk_free(rop);
    return ok;
}
```


Overlapping Code:
```
nk_ptr op) {
ref_mgr mgr = dmgr->rmgr;
dword_t dest = chunk_get_dword(op, OP_HEADER_CNT);
ref_t iref = (ref_t) chunk_get_word(op, 0+OPER_SIZE+OP_HEADER_CNT);
ref_t tref = (ref_t) chunk_get_word(op, 1+OPER_SIZE+OP_HEADER_CNT);
ref_t eref = (ref_t) chunk_get_word(op, 2+OPER_SIZE+OP_HEADER_CNT);
bool negate = (bool) chunk_get_word(op, 3+OPER_SIZE+OP_HEADER_CNT);
#if RPT >= 4
char buf1[24], buf2[24], buf3[24];
ref_show(iref, buf1); ref_show(tref, buf2); ref_show(eref, buf3);
char *ns = negate ? "!" : "";
report(4, "Computing %sITE(%s, %s, %s)", ns, buf1, buf2, buf3);
#endif
chunk_ptr ucp = ref3_encode(iref, tref, eref);
ref_t rlook = ref_ite_lookup(mgr, ucp);
if (!REF_IS_RECURSE(rlook)) {
chunk_free(ucp);
if (negate)
rlook = REF_NEGATE(rlook);
#if RPT >= 4
char buf1[24];
ref_show(rlook, buf1);
report(4, "\tFound via lookup: %s", buf1);
#endif
bool ok = send_ref_as_operand(dest, rlook); 
return ok;
}
/* Check if pending ITE */
word_t wk, wv;
if (keyvalue_remove(dmgr->deferred_ite_table, (word_t) ucp, &wk, &wv)) {
/* Add to deferred ITE table */
chunk_ptr old_ucp = (chunk_ptr) wk;
ilist_ptr ls = (ilist_ptr) wv;
ilist_ptr ele = ilist_new(dest, negate);
/* Add to list */
ele->next = ls;
keyvalue_insert(dmgr->deferred_ite_table, (word_t) old_ucp,
(word_t) ele);
chunk_free(ucp);
#if RPT >= 4
char ibuf[24], tbuf[24], ebuf[24];
ref_show(iref, ibuf); ref_show(tref, tbuf), ref_show(eref, ebuf);
char *sn = negate ? "!" : "";
word_t op_id = msg_get_dest_op_id(dest);
unsigned agent = msg_get_dest_agent(dest);
report(4, "\tDeferring %sITE(%s, %s, %s). Agent %u, Op Id 0x%lx",
sn, ibuf, tbuf, ebuf, agent, op_id);
#endif 
return true;
} else {
/* Insert empty list as placeholder */
ilist_ptr ls = NULL;
keyvalue_insert(dmgr->deferred_ite_table, (word_t) ucp, (word_t) ls);
}
/* Must do recursion */
size_t ivar = REF_GET_VAR(iref);
size_t tvar = REF_GET_VAR(tref);
size_t evar = REF_GET_VAR(eref);
size_t var = ivar;
if (tvar < var) { var = tvar; }
if (evar < var) { var = evar; }
ref_t vref = REF_VAR(var);
#if RPT >= 4
ref_show(vref, buf1);
report(4, "\tSplitting on variable %s", buf1);
#endif
/* Create next operations */
chunk_ptr sop = build_ite_store(dest, iref, tref, eref, negate);
dword_t sdest = msg_new_destination(sop, 3+OPER_SIZE+OP_HEADER_CNT
```
<Overlap Ratio: 0.9762931034482759>

---

--- 164 --
Question ID: 8448dab5125c6241fb5100dabb4238e4545d6072_114
Original Code:
```
void f114(void) {
    	static int16_t x494 = INT16_MIN;
	static int64_t x495 = INT64_MIN;
	volatile int32_t x496 = INT32_MIN;
	int64_t t114 = -320099786895396LL;

    t114 = ((x493/(x494^x495))*x496);

    if (t114 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f114(void) {
static int16_t x494 = INT16_MIN;
static int64_t x495 = INT64_MIN;
volatile int32_t x496 = INT32_MIN;
int64_t t114 = -320099786895396LL;
t114 = ((x493/(x494^x495))*x496);
if (t114 != 0
```
<Overlap Ratio: 0.8771929824561403>

---

--- 165 --
Question ID: 76a544a06c0e07eef278720c044c9780ad998764_5
Original Code:
```
static void LOADBUFF(struct hle_t* hle, uint32_t UNUSED(w1), uint32_t w2)
{
    uint32_t address = get_address(hle, w2);

    if (hle->alist_audio.count == 0)
        return;

    alist_load(hle, hle->alist_audio.in, address, hle->alist_audio.count);
}
```


Overlapping Code:
```
(struct hle_t* hle, uint32_t UNUSED(w1), uint32_t w2)
{
uint32_t address = get_address(hle, w2);
if (hle->alist_audio.count == 0)
return;
alist_load(hle, hle->alist_audio.in, address, hle->alist_audio.count);
```
<Overlap Ratio: 0.9043478260869565>

---

--- 166 --
Question ID: 9f8bc1777700dc35f69ca8c66774581ac4e17945_10
Original Code:
```
void* ww_filesys_read_all(char const* file_path, size_t* const size) {
    ww_filesys_entry_t key;
    key.mp_path = file_path;

    ww_filesys_entry_t const* const elements = ww_filesys_entries.elements;
    size_t const count = ww_filesys_entries.count;
    ww_filesys_entry_t* const found = bsearch(&key, elements, count, sizeof(ww_filesys_entry_t), ww_filesys_compare);

    if (found == NULL) {
        return NULL;
    }

    if (found->size == 0) {
        // File system
        struct stat stbuf;

        if (stat(found->u.fs_path, &stbuf) != 0) {
            return NULL;
        }

        void* const buffer = malloc(stbuf.st_size);

        if (buffer == NULL) {
            return NULL;
        }

        FILE* const fp = fopen(found->u.fs_path, "rb");

        if (fp == NULL) {
            free(buffer);
            return NULL;
        }

        if (fread(buffer, 1, stbuf.st_size, fp) != stbuf.st_size) {
            fclose(fp);
            free(buffer);
            return NULL;
        }

        fclose(fp);
        *size = stbuf.st_size;
        return buffer;
    }
    else {
        // TAR entry.
        if (fseek(found->u.tar, found->offset, SEEK_SET) != 0) {
            return NULL;
        }

        void* const buffer = malloc(found->size);

        if (buffer == NULL) {
            return NULL;
        }

        if (fread(buffer, 1, found->size, found->u.tar) != found->size) {
            free(buffer);
            return NULL;
        }

        *size = found->size;
        return buffer;
    }
}
```


Overlapping Code:
```
r const* file_path, size_t* const size) {
ww_filesys_entry_t key;
key.mp_path = file_path;
ww_filesys_entry_t const* const elements = ww_filesys_entries.elements;
size_t const count = ww_filesys_entries.count;
ww_filesys_entry_t* const found = bsearch(&key, elements, count, sizeof(ww_filesys_entry_t), ww_filesys_compare);
if (found == NULL) {
return NULL;
}
if (found->size == 0) {
// File system
struct stat stbuf;
if (stat(found->u.fs_path, &stbuf) != 0) {
return NULL;
}
void* const buffer = malloc(stbuf.st_size);
if (buffer == NULL) {
return NULL;
}
FILE* const fp = fopen(found->u.fs_path, "rb");
if (fp == NULL) {
free(buffer);
return NULL;
}
if (fread(buffer, 1, stbuf.st_size, fp) != stbuf.st_size) {
fclose(fp);
free(buffer);
return NULL;
}
fclose(fp);
*size = stbuf.st_size;
return buffer;
}
else {
// TAR entry.
if (fseek(found->u.tar, found->offset, SEEK_SET) != 0) {
return NULL;
}
void* const buffer = malloc(found->size);
if (buffer == NULL) {
return NULL;
}
if (fread(buffer, 1, found->size, found->u.tar) != found->size) {
free(buffer);
return NULL;
}
*size = found->size;
return 
```
<Overlap Ratio: 0.9649122807017544>

---

--- 167 --
Question ID: 43c68f51c5ce07822b58b44de9efe7749e1c3cf9_5
Original Code:
```
int m5mols_enable_interrupt(struct v4l2_subdev *sd, u8 reg)
{
	struct m5mols_info *info = to_m5mols(sd);
	u8 mask = is_available_af(info) ? REG_INT_AF : 0;
	u8 dummy;
	int ret;

	ret = m5mols_read_u8(sd, SYSTEM_INT_FACTOR, &dummy);
	if (!ret)
		ret = m5mols_write(sd, SYSTEM_INT_ENABLE, reg & ~mask);
	return ret;
}
```


Overlapping Code:
```
2_subdev *sd, u8 reg)
{
struct m5mols_info *info = to_m5mols(sd);
u8 mask = is_available_af(info) ? REG_INT_AF : 0;
u8 dummy;
int ret;
ret = m5mols_read_u8(sd, SYSTEM_INT_FACTOR, &dummy);
if (!ret)
ret = m5mols_write(sd, SYSTEM_INT_ENABLE, reg & ~mas
```
<Overlap Ratio: 0.819672131147541>

---

--- 168 --
Question ID: 1de4dc385140fb4867d7d7d29ac0216b23cfd6d2_6
Original Code:
```
void CFireWorkDraw::stage3(void)
{
	int i,j,numdrawn= 0,c;

	for(i = 0; i < numactive; i++) {
		if(!scount[i]) continue;
		numdrawn++;

		GUGDrawPoint(SET,SMOKECOLOR,x[i],y[i]);
		x[i] += xm[i];
		y[i] += ym[i];
		xm[i] *= AIRRESISTANCE;
		ym[i] *= AIRRESISTANCE;
		ym[i] += GRAVITY;


		switch(type) {
		case 0:                          // Standard
			j = (1000-scount[i])/10;
			if(j < 0) j = 0;
			if(j > 99) j = 99;

			c = giFWColor[scolor[i]][j];
			GUGDrawPoint(SET,c,x[i],y[i]);
			scount[i]-= 6;
			if(scount[i] < 0) scount[i] = 0;
			break;
		case 1:                          // Oooo-Ahhh.
			j = (1000-scount[i])/10;
			if(j < 0) j = 0;
			if(j > 99) j = 99;

			c = giFWColor[scolor[i]][j];
			GUGDrawPoint(SET,c,x[i],y[i]);
			scount[i]-= 12;
			if(scount[i] < 0) {
				sswitch[i]++;
				if(sswitch[i] == 2) scount[i] = 0;
				else {
					scolor[i] = nextcolor[0];
					scount[i] = 940;
				}
			}
			break;
		case 2:                          // Twinkler.
			j = (1000-scount[i])/10;
			if(j < 0) j = 0;
			if(j > 99) j = 99;

			c = giFWColor[scolor[i]][j];
			GUGDrawPoint(SET,c,x[i],y[i]);

			if(sswitch[i]== 0) scount[i]-= 15;
			else {
				scount[i] -= 80;
				if(!random(10)) scount[i] = 1;
			}

			if(scount[i] < 0) {
				sswitch[i]++;
				if(sswitch[i] == 10) scount[i] = 0;
				else {
					if(scolor[i] == 6) scolor[i] = nextcolor[0];
					else scolor[i] = 6;
					scount[i] = 940;
				}
			}
			break;
		}
	}

	if(!numdrawn) stage++;
}
```


Overlapping Code:
```
stage3(void)
{
int i,j,numdrawn= 0,c;
for(i = 0; i < numactive; i++) {
if(!scount[i]) continue;
numdrawn++;
GUGDrawPoint(SET,SMOKECOLOR,x[i],y[i]);
x[i] += xm[i];
y[i] += ym[i];
xm[i] *= AIRRESISTANCE;
ym[i] *= AIRRESISTANCE;
ym[i] += GRAVITY;
switch(type) {
case 0: // Standard
j = (1000-scount[i])/10;
if(j < 0) j = 0;
if(j > 99) j = 99;
c = giFWColor[scolor[i]][j];
GUGDrawPoint(SET,c,x[i],y[i]);
scount[i]-= 6;
if(scount[i] < 0) scount[i] = 0;
break;
case 1: // Oooo-Ahhh.
j = (1000-scount[i])/10;
if(j < 0) j = 0;
if(j > 99) j = 99;
c = giFWColor[scolor[i]][j];
GUGDrawPoint(SET,c,x[i],y[i]);
scount[i]-= 12;
if(scount[i] < 0) {
sswitch[i]++;
if(sswitch[i] == 2) scount[i] = 0;
else {
scolor[i] = nextcolor[0];
scount[i] = 940;
}
}
break;
case 2: // Twinkler.
j = (1000-scount[i])/10;
if(j < 0) j = 0;
if(j > 99) j = 99;
c = giFWColor[scolor[i]][j];
GUGDrawPoint(SET,c,x[i],y[i]);
if(sswitch[i]== 0) scount[i]-= 15;
else {
scount[i] -= 80;
if(!random(10)) scount[i] = 1;
}
if(scount[i] < 0) {
sswitch[i]++;
if(sswitch[i] == 10) scount[i] = 0;
else {
if(scolor[i] == 6) scolor[i] = nextcolor[0];
else scolor[i] = 6;
scount[i] = 940;
}
}
break;
}

```
<Overlap Ratio: 0.9615384615384616>

---

--- 169 --
Question ID: f8b632edcfebc56c54a8b7517eb0495a396abc56_4
Original Code:
```
SEXP text_tokens(SEXP sx)
{
	SEXP ans, names;
	const struct utf8lite_text *text;
	struct corpus_filter *filter;
	struct tokens ctx;
	R_xlen_t i, n;
	int nprot, type_id, ntype;

	nprot = 0;

	PROTECT(sx = coerce_text(sx)); nprot++;
	text = as_text(sx, &n);
	filter = text_filter(sx);

	PROTECT(ans = allocVector(VECSXP, n)); nprot++;
	names = names_text(sx);
	setAttrib(ans, R_NamesSymbol, names);

	tokens_init(&ctx, filter);

	// add the existing types in the filter
	ntype = ctx.filter->symtab.ntype;
	for (type_id = 0; type_id < ntype; type_id++) {
		RCORPUS_CHECK_INTERRUPT(type_id);
		PROTECT(tokens_add_type(&ctx, type_id)); nprot++;
	}

	for (i = 0; i < n; i++) {
		RCORPUS_CHECK_INTERRUPT(i);
		SET_VECTOR_ELT(ans, i, tokens_scan(&ctx, &text[i]));
	}

	UNPROTECT(nprot);
	return ans;
}
```


Overlapping Code:
```
XP ans, names;
const struct utf8lite_text *text;
struct corpus_filter *filter;
struct tokens ctx;
R_xlen_t i, n;
int nprot, type_id, ntype;
nprot = 0;
PROTECT(sx = coerce_text(sx)); nprot++;
text = as_text(sx, &n);
filter = text_filter(sx);
PROTECT(ans = allocVector(VECSXP, n)); nprot++;
names = names_text(sx);
setAttrib(ans, R_NamesSymbol, names);
tokens_init(&ctx, filter);
// add the existing types in the filter
ntype = ctx.filter->symtab.ntype;
for (type_id = 0; type_id < ntype; type_id++) {
RCORPUS_CHECK_INTERRUPT(type_id);
PROTECT(tokens_add_type(&ctx, type_id)); nprot++;
}
for (i = 0; i < n; i++) {
RCORPUS_CHECK_INTERRUPT(i);
SET_VECTOR_ELT(ans, i, tokens_scan(&ctx, &text[i]));
}
UNPROTECT(nprot);
r
```
<Overlap Ratio: 0.9444444444444444>

---

--- 170 --
Question ID: 79c93f34211665714c2c2d5dee58cb1d3e4b02b0_0
Original Code:
```
extern void ora_instr(sqlite3_context  *context,
                      int               argc,
                      sqlite3_value   **argv) {
   int start = 1;
   int occ = 1;

   // checks for correct number of arguments
   _ksu_check_arg_cnt(argc, 2, 4, "instr");
   if (ksu_prm_ok(context, argc, argv, "instr",
                  KSU_PRM_TEXT, KSU_PRM_TEXT,
                  KSU_PRM_INT_NOT_0, KSU_PRM_INT_GT_0)) {
      if (argc >= 3) {
         start = sqlite3_value_int(argv[2]);
      }
      if (argc == 4) {
         occ = sqlite3_value_int(argv[3]);
      }

      //VARIABLES!!!!
      int            pos;
      int            count = 0;
      int            i;
      unsigned char *line = (unsigned char *)sqlite3_value_text(argv[0]);
      unsigned char *comp = (unsigned char *)sqlite3_value_text(argv[1]);
      int            len = strlen((char *)comp);
      //end variables...
      // Goes character by character and checks whether it matches
      // the string to match. if it does, it increments count, if
      // count=the occurrence variable, it returns position
      if (start > 0) {
         int comp2;
         int startbyte;

         startbyte = ksu_charpos_to_bytes(line, start - 1);
         if (startbyte == -1) {
            ksu_err_msg(context, KSU_ERR_INV_UTF8, "instr");
            return;
         }
         line = &(line[startbyte]);
         pos = start;
         for (i = 0; i < strlen((char *)line); i++) {
            comp2 = strncmp((char *)&(line[i]), (char *)comp, len);
            if (comp2 == 0) {
               count++;
               if (count == occ) {
                  pos = ksu_charpos_to_bytes((unsigned char *)line, pos);
                  sqlite3_result_int(context, pos);
                  return;
               }
            }
            pos++;
         }
      } else {
         unsigned char *p = &(line[strlen((char *)line) - 1 ]);
         i = 0;
         start = -1 * start;
         while ((p > line) && (i < start)) {
            _ksu_utf8_decr(p);
            i++;
         }
         if (i == start) {
            pos = p - line;
            for (i = p - line; i > 0; i--) {
               if (!strncmp((char *)&(line[i]), (char *)comp, len)) {
                  count++;
                  if (count == occ) {
                     pos = ksu_charpos_to_bytes((unsigned char *)line, pos);
                     pos++;
                     sqlite3_result_int(context, pos);
                     return;
                  }
               }
               pos--;
            }
         }
      }
      sqlite3_result_int(context, 0);
    }
}
```


Overlapping Code:
```
(sqlite3_context *context,
int argc,
sqlite3_value **argv) {
int start = 1;
int occ = 1;
// checks for correct number of arguments
_ksu_check_arg_cnt(argc, 2, 4, "instr");
if (ksu_prm_ok(context, argc, argv, "instr",
KSU_PRM_TEXT, KSU_PRM_TEXT,
KSU_PRM_INT_NOT_0, KSU_PRM_INT_GT_0)) {
if (argc >= 3) {
start = sqlite3_value_int(argv[2]);
}
if (argc == 4) {
occ = sqlite3_value_int(argv[3]);
}
//VARIABLES!!!!
int pos;
int count = 0;
int i;
unsigned char *line = (unsigned char *)sqlite3_value_text(argv[0]);
unsigned char *comp = (unsigned char *)sqlite3_value_text(argv[1]);
int len = strlen((char *)comp);
//end variables...
// Goes character by character and checks whether it matches
// the string to match. if it does, it increments count, if
// count=the occurrence variable, it returns position
if (start > 0) {
int comp2;
int startbyte;
startbyte = ksu_charpos_to_bytes(line, start - 1);
if (startbyte == -1) {
ksu_err_msg(context, KSU_ERR_INV_UTF8, "instr");
return;
}
line = &(line[startbyte]);
pos = start;
for (i = 0; i < strlen((char *)line); i++) {
comp2 = strncmp((char *)&(line[i]), (char *)comp, len);
if (comp2 == 0) {
count++;
if (count == occ) {
pos = ksu_charpos_to_bytes((unsigned char *)line, pos);
sqlite3_result_int(context, pos);
return;
}
}
pos++;
}
} else {
unsigned char *p = &(line[strlen((char *)line) - 1 ]);
i = 0;
start = -1 * start;
while ((p > line) && (i < start)) {
_ksu_utf8_decr(p);
i++;
}
if (i == start) {
pos = p - line;
for (i = p - line; i > 0; i--) {
if (!strncmp((char *)&(line[i]), (char *)comp, len)) {
count++;
if (count == occ) {
pos = ksu_charpos_to_bytes((unsigned char *)line, pos);
pos++;
sqlite3_
```
<Overlap Ratio: 0.9672131147540983>

---

--- 171 --
Question ID: 43dfe59a94f19be2a2394af9d9293bc2a3fb6c4b_21
Original Code:
```
static int
_sort_fonts(const void *data1, const void *data2)
{
   if (!data1) return 1;
   if (!data2) return -1;
   return e_util_strcmp(data1, data2);
}
```


Overlapping Code:
```
(const void *data1, const void *data2)
{
if (!data1) return 1;
if (!data2) return -1;
return e_util_
```
<Overlap Ratio: 0.6896551724137931>

---

--- 172 --
Question ID: ec1ab9a29b7db682d9e9afcb47e5c397873f8026_10
Original Code:
```
void FP_YYY_cswap(FP_YYY *a,FP_YYY *b,int d)
{
    sign32 t,c=d;
    BIG_XXX_cswap(a->g,b->g,d);

    c=~(c-1);
    t=c&((a->XES)^(b->XES));
    a->XES^=t;
    b->XES^=t;

}
```


Overlapping Code:
```
a,FP_YYY *b,int d)
{
sign32 t,c=d;
BIG_XXX_cswap(a->g,b->g,d);
c=~(c-1);
t=c&((a->XES)^(b->XES));
a->XES^=t;
b->XES^=t;

```
<Overlap Ratio: 0.8163265306122449>

---

--- 173 --
Question ID: 6c6f6e67132f72a6a811000faf20ecb7d95a8b9e_57
Original Code:
```
void f57(void) {
    	int16_t x281 = INT16_MIN;
	int64_t x282 = -254LL;
	uint16_t x284 = UINT16_MAX;
	static volatile int64_t t57 = 488302510169LL;

    t57 = (((x281+x282)-x283)%x284);

    if (t57 != 65281LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
57(void) {
int16_t x281 = INT16_MIN;
int64_t x282 = -254LL;
uint16_t x284 = UINT16_MAX;
static volatile int64_t t57 = 488302510169LL;
t57 = (((x281+x282)-x283)%x284);
if (t57 != 65281LL) { NG(); } els
```
<Overlap Ratio: 0.9259259259259259>

---

--- 174 --
Question ID: 4c2762356b241bc72254067c038f4e5cbb76ef84_25
Original Code:
```
static int
CompareISOLatin1(const char *first, const char *second)
{
    register const unsigned char *ap, *bp;

    for (ap = (const unsigned char *) first,
         bp = (const unsigned char *) second; *ap && *bp; ap++, bp++) {
        register unsigned char a, b;

        if ((a = *ap) != (b = *bp)) {
            /* try lowercasing and try again */

            if ((a >= XK_A) && (a <= XK_Z))
                a = (unsigned char) (a + (XK_a - XK_A));
            else if ((a >= XK_Agrave) && (a <= XK_Odiaeresis))
                a = (unsigned char) (a + (XK_agrave - XK_Agrave));
            else if ((a >= XK_Ooblique) && (a <= XK_Thorn))
                a = (unsigned char) (a + (XK_oslash - XK_Ooblique));

            if ((b >= XK_A) && (b <= XK_Z))
                b = (unsigned char) (b + (XK_a - XK_A));
            else if ((b >= XK_Agrave) && (b <= XK_Odiaeresis))
                b = (unsigned char) (b + (XK_agrave - XK_Agrave));
            else if ((b >= XK_Ooblique) && (b <= XK_Thorn))
                b = (unsigned char) (b + (XK_oslash - XK_Ooblique));

            if (a != b)
                break;
        }
    }
    return (((int) *bp) - ((int) *ap));
}
```


Overlapping Code:
```
char *first, const char *second)
{
register const unsigned char *ap, *bp;
for (ap = (const unsigned char *) first,
bp = (const unsigned char *) second; *ap && *bp; ap++, bp++) {
register unsigned char a, b;
if ((a = *ap) != (b = *bp)) {
/* try lowercasing and try again */
if ((a >= XK_A) && (a <= XK_Z))
a = (unsigned char) (a + (XK_a - XK_A));
else if ((a >= XK_Agrave) && (a <= XK_Odiaeresis))
a = (unsigned char) (a + (XK_agrave - XK_Agrave));
else if ((a >= XK_Ooblique) && (a <= XK_Thorn))
a = (unsigned char) (a + (XK_oslash - XK_Ooblique));
if ((b >= XK_A) && (b <= XK_Z))
b = (unsigned char) (b + (XK_a - XK_A));
else if ((b >= XK_Agrave) && (b <= XK_Odiaeresis))
b = (unsigned char) (b + (XK_agrave - XK_Agrave));
else if ((b >= XK_Ooblique) && (b <= XK_Thorn))
b = (unsigned char) (b + (XK_oslash - XK_Ooblique));
if (a != b)
break;
}
}
re
```
<Overlap Ratio: 0.9249183895538629>

---

--- 175 --
Question ID: f0cae0a08c85ed87f0e16bb3baa8b2467705e5b2_3
Original Code:
```
bool dsController_startRumble(dsController* controller, float strength, float duration)
{
	if (!controller || !controller->rumbleSupported || !controller->application ||
		!controller->application->startControllerRumbleFunc)
	{
		errno = EINVAL;
		return false;
	}

	dsApplication* application = controller->application;
	return application->startControllerRumbleFunc(application, controller, strength, duration);
}
```


Overlapping Code:
```
l dsController_startRumble(dsController* controller, float strength, float duration)
{
if (!controller || !controller->rumbleSupported || !controller->application ||
!controller->application->startControllerRumbleFunc)
{
errno = EINVAL;
return false;
}
dsApplication* application = controller->application;
return application->startControllerRumbleFunc(application, controller, strength, duration);
}
```
<Overlap Ratio: 0.9925558312655087>

---

--- 176 --
Question ID: 9740c80324cc0922e837eedbde165d8412b22328_107
Original Code:
```
void f108(void) {
    	int8_t x469 = -1;
	uint8_t x470 = 109U;
	int8_t x471 = INT8_MAX;
	uint32_t x472 = UINT32_MAX;
	uint32_t t108 = 313407U;

    t108 = (((x469==x470)+x471)-x472);

    if (t108 != 128U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
{
int8_t x469 = -1;
uint8_t x470 = 109U;
int8_t x471 = INT8_MAX;
uint32_t x472 = UINT32_MAX;
uint32_t t108 = 313407U;
t108 = (((x469==x470)+x471)-x472
```
<Overlap Ratio: 0.7142857142857143>

---

--- 177 --
Question ID: 99d96e14d14b21486675ed674b1fadc86a4fa967_30
Original Code:
```
mat4 mat4Mul(mat4 *m0, mat4 *m1) // mat4 x mat4
{
	mat4 r;

	// loops unrolled

	// row 0
	r.m[0][0] = m0->m[0][0] * m1->m[0][0]; // m0 row 0 dot m1 col 0
	r.m[0][0] += m0->m[0][1] * m1->m[1][0];
	r.m[0][0] += m0->m[0][2] * m1->m[2][0];
	r.m[0][0] += m0->m[0][3] * m1->m[3][0];

	r.m[0][1] = m0->m[0][0] * m1->m[0][1];
	r.m[0][1] += m0->m[0][1] * m1->m[1][1];
	r.m[0][1] += m0->m[0][2] * m1->m[2][1];
	r.m[0][1] += m0->m[0][3] * m1->m[3][1];

	r.m[0][2] = m0->m[0][0] * m1->m[0][2];
	r.m[0][2] += m0->m[0][1] * m1->m[1][2];
	r.m[0][2] += m0->m[0][2] * m1->m[2][2];
	r.m[0][2] += m0->m[0][3] * m1->m[3][2];

	r.m[0][3] = m0->m[0][0] * m1->m[0][3];
	r.m[0][3] += m0->m[0][1] * m1->m[1][3];
	r.m[0][3] += m0->m[0][2] * m1->m[2][3];
	r.m[0][3] += m0->m[0][3] * m1->m[3][3];

	// row 1
	r.m[1][0] = m0->m[1][0] * m1->m[0][0];
	r.m[1][0] += m0->m[1][1] * m1->m[1][0];
	r.m[1][0] += m0->m[1][2] * m1->m[2][0];
	r.m[1][0] += m0->m[1][3] * m1->m[3][0];

	r.m[1][1] = m0->m[1][0] * m1->m[0][1];
	r.m[1][1] += m0->m[1][1] * m1->m[1][1];
	r.m[1][1] += m0->m[1][2] * m1->m[2][1];
	r.m[1][1] += m0->m[1][3] * m1->m[3][1];

	r.m[1][2] = m0->m[1][0] * m1->m[0][2];
	r.m[1][2] += m0->m[1][1] * m1->m[1][2];
	r.m[1][2] += m0->m[1][2] * m1->m[2][2];
	r.m[1][2] += m0->m[1][3] * m1->m[3][2];

	r.m[1][3] = m0->m[1][0] * m1->m[0][3];
	r.m[1][3] += m0->m[1][1] * m1->m[1][3];
	r.m[1][3] += m0->m[1][2] * m1->m[2][3];
	r.m[1][3] += m0->m[1][3] * m1->m[3][3];

	// row 2
	r.m[2][0] = m0->m[2][0] * m1->m[0][0];
	r.m[2][0] += m0->m[2][1] * m1->m[1][0];
	r.m[2][0] += m0->m[2][2] * m1->m[2][0];
	r.m[2][0] += m0->m[2][3] * m1->m[3][0];

	r.m[2][1] = m0->m[2][0] * m1->m[0][1];
	r.m[2][1] += m0->m[2][1] * m1->m[1][1];
	r.m[2][1] += m0->m[2][2] * m1->m[2][1];
	r.m[2][1] += m0->m[2][3] * m1->m[3][1];

	r.m[2][2] = m0->m[2][0] * m1->m[0][2];
	r.m[2][2] += m0->m[2][1] * m1->m[1][2];
	r.m[2][2] += m0->m[2][2] * m1->m[2][2];
	r.m[2][2] += m0->m[2][3] * m1->m[3][2];

	r.m[2][3] = m0->m[2][0] * m1->m[0][3];
	r.m[2][3] += m0->m[2][1] * m1->m[1][3];
	r.m[2][3] += m0->m[2][2] * m1->m[2][3];
	r.m[2][3] += m0->m[2][3] * m1->m[3][3];

	// row 3
	r.m[3][0] = m0->m[3][0] * m1->m[0][0];
	r.m[3][0] += m0->m[3][1] * m1->m[1][0];
	r.m[3][0] += m0->m[3][2] * m1->m[2][0];
	r.m[3][0] += m0->m[3][3] * m1->m[3][0];

	r.m[3][1] = m0->m[3][0] * m1->m[0][1];
	r.m[3][1] += m0->m[3][1] * m1->m[1][1];
	r.m[3][1] += m0->m[3][2] * m1->m[2][1];
	r.m[3][1] += m0->m[3][3] * m1->m[3][1];

	r.m[3][2] = m0->m[3][0] * m1->m[0][2];
	r.m[3][2] += m0->m[3][1] * m1->m[1][2];
	r.m[3][2] += m0->m[3][2] * m1->m[2][2];
	r.m[3][2] += m0->m[3][3] * m1->m[3][2];

	r.m[3][3] = m0->m[3][0] * m1->m[0][3];
	r.m[3][3] += m0->m[3][1] * m1->m[1][3];
	r.m[3][3] += m0->m[3][2] * m1->m[2][3];
	r.m[3][3] += m0->m[3][3] * m1->m[3][3];

	return r;
}
```


Overlapping Code:
```
4 *m1) // mat4 x mat4
{
mat4 r;
// loops unrolled
// row 0
r.m[0][0] = m0->m[0][0] * m1->m[0][0]; // m0 row 0 dot m1 col 0
r.m[0][0] += m0->m[0][1] * m1->m[1][0];
r.m[0][0] += m0->m[0][2] * m1->m[2][0];
r.m[0][0] += m0->m[0][3] * m1->m[3][0];
r.m[0][1] = m0->m[0][0] * m1->m[0][1];
r.m[0][1] += m0->m[0][1] * m1->m[1][1];
r.m[0][1] += m0->m[0][2] * m1->m[2][1];
r.m[0][1] += m0->m[0][3] * m1->m[3][1];
r.m[0][2] = m0->m[0][0] * m1->m[0][2];
r.m[0][2] += m0->m[0][1] * m1->m[1][2];
r.m[0][2] += m0->m[0][2] * m1->m[2][2];
r.m[0][2] += m0->m[0][3] * m1->m[3][2];
r.m[0][3] = m0->m[0][0] * m1->m[0][3];
r.m[0][3] += m0->m[0][1] * m1->m[1][3];
r.m[0][3] += m0->m[0][2] * m1->m[2][3];
r.m[0][3] += m0->m[0][3] * m1->m[3][3];
// row 1
r.m[1][0] = m0->m[1][0] * m1->m[0][0];
r.m[1][0] += m0->m[1][1] * m1->m[1][0];
r.m[1][0] += m0->m[1][2] * m1->m[2][0];
r.m[1][0] += m0->m[1][3] * m1->m[3][0];
r.m[1][1] = m0->m[1][0] * m1->m[0][1];
r.m[1][1] += m0->m[1][1] * m1->m[1][1];
r.m[1][1] += m0->m[1][2] * m1->m[2][1];
r.m[1][1] += m0->m[1][3] * m1->m[3][1];
r.m[1][2] = m0->m[1][0] * m1->m[0][2];
r.m[1][2] += m0->m[1][1] * m1->m[1][2];
r.m[1][2] += m0->m[1][2] * m1->m[2][2];
r.m[1][2] += m0->m[1][3] * m1->m[3][2];
r.m[1][3] = m0->m[1][0] * m1->m[0][3];
r.m[1][3] += m0->m[1][1] * m1->m[1][3];
r.m[1][3] += m0->m[1][2] * m1->m[2][3];
r.m[1][3] += m0->m[1][3] * m1->m[3][3];
// row 2
r.m[2][0] = m0->m[2][0] * m1->m[0][0];
r.m[2][0] += m0->m[2][1] * m1->m[1][0];
r.m[2][0] += m0->m[2][2] * m1->m[2][0];
r.m[2][0] += m0->m[2][3] * m1->m[3][0];
r.m[2][1] = m0->m[2][0] * m1->m[0][1];
r.m[2][1] += m0->m[2][1] * m1->m[1][1];
r.m[2][1] += m0->m[2][2] * m1->m[2][1];
r.m[2][1] += m0->m[2][3] * m1->m[3][1];
r.m[2][2] = m0->m[2][0] * m1->m[0][2];
r.m[2][2] += m0->m[2][1] * m1->m[1][2];
r.m[2][2] += m0->m[2][2] * m1->m[2][2];
r.m[2][2] += m0->m[2][3] * m1->m[3][2];
r.m[2][3] = m0->m[2][0] * m1->m[0][3];
r.m[2][3] += m0->m[2][1] * m1->m[1][3];
r.m[2][3] += m0->m[2][2] * m1->m[2][3];
r.m[2][3] += m0->m[2][3] * m1->m[3][3];
// row 3
r.m[3][0] = m0->m[3][0] * m1->m[0][0];
r.m[3][0] += m0->m[3][1] * m1->m[1][0];
r.m[3][0] += m0->m[3][2] * m1->m[2][0];
r.m[3][0] += m0->m[3][3] * m1->m[3][0];
r.m[3][1] = m0->m[3][0] * m1->m[0][1];
r.m[3][1] += m0->m[3][1] * m1->m[1][1];
r.m[3][1] += m0->m[3][2] * m1->m[2][1];
r.m[3][1] += m0->m[3][3] * m1->m[3][1];
r.m[3][2] = m
```
<Overlap Ratio: 0.9714758164530798>

---

--- 178 --
Question ID: 63ade1971ca876f75261f245770ec419e0a92293_15
Original Code:
```
Datum
semver_gt(PG_FUNCTION_ARGS)
{
    semver* a = PG_GETARG_SEMVER_P(0);
    semver* b = PG_GETARG_SEMVER_P(1);
    int diff = _semver_cmp(a, b);
    PG_RETURN_BOOL(diff > 0);
}
```


Overlapping Code:
```
(PG_FUNCTION_ARGS)
{
semver* a = PG_GETARG_SEMVER_P(0);
semver* b = PG_GETARG_SEMVER_P(1);
int diff = _semver_cmp(a, b
```
<Overlap Ratio: 0.7239263803680982>

---

--- 179 --
Question ID: 3c2902c785ceea74459c306984a7302db5229df4_140
Original Code:
```
void f140(void) {
    	volatile uint32_t x4513 = UINT32_MAX;
	volatile uint32_t x4514 = 1U;
	volatile uint32_t t140 = 1867U;

    t140 = (x4513>>(x4514+(x4515>x4516)));

    if (t140 != 2147483647U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
le uint32_t x4513 = UINT32_MAX;
volatile uint32_t x4514 = 1U;
volatile uint32_t t140 = 1867U;
t140 = (x4513>>(x4514+(x4515>x4516)));
if (t140 != 2147483647U) { NG(); } else { ; }


```
<Overlap Ratio: 0.8780487804878049>

---

--- 180 --
Question ID: 14a546faa900cd2b44734f5699152ab55a526473_15
Original Code:
```
static void hal_entry_mp()
{
    // Switch to CPU-private stack
    ulong sp = get_my_cpu_init_stack_top_vaddr();
    ulong pc = (ulong)&hal_mp;

    __asm__ __volatile__ (
        // Set up stack top
        "ori    $29, %[sp], 0;"

        // Jump to target
        "jr     %[pc];"
        "nop;"
        :
        : [pc] "r" (pc), [sp] "r" (sp - 16)
        : "memory"
    );

    unreachable();
}
```


Overlapping Code:
```
tic void hal_entry_mp()
{
// Switch to CPU-private stack
ulong sp = get_my_cpu_init_stack_top_vaddr();
ulong pc = (ulong)&hal_mp;
__asm__ __volatile__ (
// Set up stack top
"ori $29, %[sp], 0;"
// Jump to target
"jr %[pc];"
"nop;"
:
: [pc] "r" (pc), [sp] "r" (sp - 16)

```
<Overlap Ratio: 0.890728476821192>

---

--- 181 --
Question ID: 19f503e3b8a36c1bad4d3337128dad3a18074946_26
Original Code:
```
void f26(void) {
    	static uint8_t x710 = UINT8_MAX;
	volatile uint32_t t26 = 1539U;

    t26 = (((x709==x710)>>x711)-x712);

    if (t26 != 4294967127U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```

static uint8_t x710 = UINT8_MAX;
volatile uint32_t t26 = 1539U;
t26 = (((x709==x710)>>x711)-x712);

```
<Overlap Ratio: 0.6134969325153374>

---

--- 182 --
Question ID: c18c4172332b1c862bed2690fc5bbe36c0770cd4_0
Original Code:
```
SCRIPTS_FUNCTION HUBShopMenuManager* CreateHUBShopMenuManager() {
	HUBShopMenuManager* script = new HUBShopMenuManager();

	INSPECTOR_STRING(script->mandoName);
	INSPECTOR_STRING(script->exitButtonName);
	INSPECTOR_STRING(script->buyButtonName);
	return script;
}
```


Overlapping Code:
```
ShopMenuManager() {
HUBShopMenuManager* script = new HUBShopMenuManager();
INSPECTOR_STRING(script->mandoName);
INSPECTOR_STRING(script->exitButtonName);
INSPECTOR_STRING(script->buyButtonName);
retur
```
<Overlap Ratio: 0.7782101167315175>

---

--- 183 --
Question ID: 290682cabf58e1966b565e40b753b1458ec5fa37_2
Original Code:
```
enum ps_status ps_keyboard_get_scancode_from_key(struct ps_passion *this,
        enum ps_keycode keycode, enum ps_scancode *scancode
)
{
        PS_CHECK(this && scancode, PS_STATUS_INVALID_ARGUMENT);

        SDL_Keycode sdl_keycode = (SDL_Keycode)keycode;
        SDL_Scancode sdl_scancode = SDL_GetScancodeFromKey(sdl_keycode);
        *scancode = (enum ps_scancode)sdl_scancode;

        return PS_STATUS_SUCCESS;
}
```


Overlapping Code:
```
ncode_from_key(struct ps_passion *this,
enum ps_keycode keycode, enum ps_scancode *scancode
)
{
PS_CHECK(this && scancode, PS_STATUS_INVALID_ARGUMENT);
SDL_Keycode sdl_keycode = (SDL_Keycode)keycode;
SDL_Scancode sdl_scancode = SDL_GetScancodeFromKey(sdl_keycode);
*scancode = (enum ps_scancode)sdl_s
```
<Overlap Ratio: 0.8108108108108109>

---

--- 184 --
Question ID: 53596e8d41e7052fae0cfc2f4fba5abc98ae2fa4_84
Original Code:
```
void f84(void) {
    	static int8_t x5169 = INT8_MAX;
	static uint64_t x5170 = UINT64_MAX;
	uint16_t x5171 = 4U;
	uint64_t t84 = 3159700689LLU;

    t84 = (((x5169+x5170)<<x5171)-x5172);

    if (t84 != 18446744069414586337LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
id) {
static int8_t x5169 = INT8_MAX;
static uint64_t x5170 = UINT64_MAX;
uint16_t x5171 = 4U;
uint64_t t84 = 3159700689LLU;
t84 = (((x5169+x5170)<<x5171)-x5172);
if (t84 != 18446744069414586337LLU) {
```
<Overlap Ratio: 0.8583690987124464>

---

--- 185 --
Question ID: 1b277ac87f71a9704308e7fafb8636cf469b5188_8
Original Code:
```
MSList *ms_list_remove_link(MSList *list, MSList *elem){
    MSList *ret;
    if (elem==list){
        ret=elem->next;
        //[iclai+] useless code
        //elem->prev=NULL;
        //elem->next=NULL;
        //[iclai-]
        if (ret!=NULL) ret->prev=NULL;
        ms_free(elem);
        return ret;
    }
    elem->prev->next=elem->next;
    if (elem->next!=NULL) elem->next->prev=elem->prev;
    //[iclai+] useless code
    //elem->next=NULL;
    //elem->prev=NULL;
    //[iclai-]
    ms_free(elem);
    return list;
}
```


Overlapping Code:
```
MSList *ms_list_remove_link(MSList *list, MSList *elem){
MSList *ret;
if (elem==list){
ret=elem->next;
//[iclai+] useless code
//elem->prev=NULL;
//elem->next=NULL;
//[iclai-]
if (ret!=NULL) ret->prev=NULL;
ms_free(elem);
return ret;
}
elem->prev->next=elem->next;
if (elem->next!=NULL) elem->next->prev=elem->prev;
//[iclai+] useless code
//elem->next=NULL;
//elem->prev=NULL;
//[iclai-]
ms_free(elem);
return l
```
<Overlap Ratio: 0.9856459330143541>

---

--- 186 --
Question ID: 4f535c2894ec852c8c34c6df806220c2408136a2_75
Original Code:
```
void f75(void) {
    	int16_t x309 = -23;
	int32_t x311 = -220;
	volatile int16_t x312 = INT16_MAX;
	volatile int32_t t75 = -1973570;

    t75 = (((x309!=x310)+x311)<=x312);

    if (t75 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x309 = -23;
int32_t x311 = -220;
volatile int16_t x312 = INT16_MAX;
volatile int32_t t75 = -1973570;
t75 = (((x309!=x310)+x311)<=x312);
if (t75 != 
```
<Overlap Ratio: 0.7575757575757576>

---

--- 187 --
Question ID: 2a69400be793d0838b4a2ea75ead42cd7b700900_51
Original Code:
```
void f51(void) {
    	uint16_t x265 = 0U;
	volatile uint64_t x266 = 1062LLU;
	int64_t x267 = INT64_MIN;
	int64_t x268 = INT64_MIN;
	uint64_t t51 = 56770405LLU;

    t51 = (x265|((x266&x267)*x268));

    if (t51 != 0LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
= 0U;
volatile uint64_t x266 = 1062LLU;
int64_t x267 = INT64_MIN;
int64_t x268 = INT64_MIN;
uint64_t t51 = 56770405LLU;
t51 = (x265|((x266&x267)*x268)
```
<Overlap Ratio: 0.6696428571428571>

---

--- 188 --
Question ID: ba5f954d126e2b144e5efdd1cfe8ab03befeccd4_189
Original Code:
```
void f189(void) {
    	int32_t x985 = INT32_MAX;
	static volatile uint16_t x986 = UINT16_MAX;
	uint32_t x987 = 2U;
	volatile uint32_t t189 = 13U;

    t189 = (x985*(x986%(x987-x988)));

    if (t189 != 0U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
85 = INT32_MAX;
static volatile uint16_t x986 = UINT16_MAX;
uint32_t x987 = 2U;
volatile uint32_t t189 = 13U;
t189 = (x985*(x986%(x987-x988)));
if (t1
```
<Overlap Ratio: 0.7109004739336493>

---

--- 189 --
Question ID: 8d59c1d96a98f2d0ec7983adbb03d80c68e1e66b_5
Original Code:
```
void iom_core_read2 (UNUSED uint iom_unit_idx, word24 addr, word36 *even, word36 *odd, UNUSED const char * ctx)
  {
#ifdef THREADZ
#ifdef lockread
    lock_mem_rd ();
#endif
#endif
#ifdef LOCKLESS
    word36 v;
    LOAD_ACQ_CORE_WORD(v, addr);
    * even = v & DMASK;
    addr++;
    LOAD_ACQ_CORE_WORD(v, addr);
    * odd = v & DMASK;
#else
    * even = M[addr ++] & DMASK;
    * odd =  M[addr]    & DMASK;
#endif
#ifdef THREADZ
#ifdef lockread
    unlock_mem ();
#endif
#endif
  }
```


Overlapping Code:
```
 iom_unit_idx, word24 addr, word36 *even, word36 *odd, UNUSED const char * ctx)
{
#ifdef THREADZ
#ifdef lockread
lock_mem_rd ();
#endif
#endif
#ifdef LOCKLESS
word36 v;
LOAD_ACQ_CORE_WORD(v, addr);
* even = v & DMASK;
addr++;
LOAD_ACQ_CORE_WORD(v, addr);
* odd = v & DMASK;
#else
* even = M[addr ++] & DMASK;
* odd = M[addr] & DMASK;
#endif
#ifdef THREADZ
#ifdef lockread
unlock_mem ();
#endif
#endif
```
<Overlap Ratio: 0.9216589861751152>

---

--- 190 --
Question ID: 18c2660c74ebf9052793955cfb8fe4525f71099e_6
Original Code:
```
HANDLE LoadAcc(
    HINSTANCE hmod,
    HANDLE    hrl)
{
    PACCELCACHE * ppacNext;
    HANDLE handle = NULL;

    if (hrl != NULL) {

        if (hrl = LOADRESOURCE(hmod, hrl)) {

            PRESOURCE_ACCEL paccel;

            if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {

                int nAccel = 0;
                int i;
                LPACCEL paccelT;

                /*
                 * Check if we've already loaded accelerators from this
                 *  same address
                 */
                RtlEnterCriticalSection(&gcsAccelCache);
                    ppacNext = FindAccResource(NULL, paccel);
                    if (*ppacNext != NULL) {
                        (*ppacNext)->dwLockCount++;
                        handle = (*ppacNext)->hAccel;
                    }
                RtlLeaveCriticalSection(&gcsAccelCache);
                /*
                 * If we found this table on the global list,
                 *  return the same handle (Win95 compat)
                 */
                if (handle != NULL) {
                    goto UnlockAndFree;
                }

                while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {

                    if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                        RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                        goto UnlockAndFree;
                    }

                    nAccel++;
                }

                if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
                    RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
                    goto UnlockAndFree;
                }

                /*
                 * Since the accelerator table is coming from a resource, each
                 * element has an extra WORD of padding which we strip here
                 * to conform with the public (and internal) ACCEL structure.
                 */
                paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));
                if (paccelT == NULL) {
                    goto UnlockAndFree;
                }
                for (i = 0; i < nAccel + 1; i++) {
                    paccelT[i] = paccel[i].accel;
                }

                handle = NtUserCreateAcceleratorTable(paccelT,
                                                      nAccel + 1);

                UserLocalFree(paccelT);

                /*
                 * Add this handle/address to the global table so
                 *  we won't load it twice.
                 */
                if (handle != NULL) {
                    AddAccResource(handle, paccel);
                }
UnlockAndFree:

                UNLOCKRESOURCE(hrl, hmod);
            }

            FREERESOURCE(hrl, hmod);
        }
    }

    return handle;
}
```


Overlapping Code:
```

PACCELCACHE * ppacNext;
HANDLE handle = NULL;
if (hrl != NULL) {
if (hrl = LOADRESOURCE(hmod, hrl)) {
PRESOURCE_ACCEL paccel;
if ((paccel = (PRESOURCE_ACCEL)LOCKRESOURCE(hrl, hmod)) != NULL) {
int nAccel = 0;
int i;
LPACCEL paccelT;
/*
* Check if we've already loaded accelerators from this
* same address
*/
RtlEnterCriticalSection(&gcsAccelCache);
ppacNext = FindAccResource(NULL, paccel);
if (*ppacNext != NULL) {
(*ppacNext)->dwLockCount++;
handle = (*ppacNext)->hAccel;
}
RtlLeaveCriticalSection(&gcsAccelCache);
/*
* If we found this table on the global list,
* return the same handle (Win95 compat)
*/
if (handle != NULL) {
goto UnlockAndFree;
}
while (!((paccel[nAccel].accel.fVirt) & FLASTKEY)) {
if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
goto UnlockAndFree;
}
nAccel++;
}
if (paccel[nAccel].accel.fVirt & ~FACCEL_VALID) {
RIPMSG0(RIP_WARNING, "LoadAcc: Invalid Parameter");
goto UnlockAndFree;
}
/*
* Since the accelerator table is coming from a resource, each
* element has an extra WORD of padding which we strip here
* to conform with the public (and internal) ACCEL structure.
*/
paccelT = UserLocalAlloc(0, sizeof(ACCEL) * (nAccel + 1));
if (paccelT == NULL) {
goto UnlockAndFree;
}
for (i = 0; i < nAccel + 1; i++) {
paccelT[i] = paccel[i].accel;
}
handle = NtUserCreateAcceleratorTable(paccelT,
nAccel + 1);
UserLocalFree(
```
<Overlap Ratio: 0.9608785175017158>

---

--- 191 --
Question ID: a921c39112856d45ce1beae5f631cf20114fe35a_0
Original Code:
```
interface BYFlowSkipController : NSObject {

	BOOL _basicFunctionalityEnabled_doNotAccessDirectly;
	FLFollowUpController* _followUpController_doNotAccessDirectly;
	id<NSObject> _wfNetworkChangeObserver;

}
```


Overlapping Code:
```
lowSkipController : NSObject {
BOOL _basicFunctionalityEnabled_doNotAccessDirectly;
FLFollowUpController* _followUpController_doNotAccessDirectly;
id<
```
<Overlap Ratio: 0.75>

---

--- 192 --
Question ID: 6a50b4c23d3e5a6502326cce3dca351a9f1ef36c_197
Original Code:
```
void f197(void) {
    	uint8_t x5065 = 1U;
	int8_t x5068 = -1;
	volatile uint32_t t197 = 11U;

    t197 = ((x5065|x5066)<<(x5067%x5068));

    if (t197 != 29U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 = 1U;
int8_t x5068 = -1;
volatile uint32_t t197 = 11U;
t197 = ((x5065|x5066)<<(x5067%x5068));
if (t
```
<Overlap Ratio: 0.6024096385542169>

---

--- 193 --
Question ID: ba858de6f2a0c731bc94a14a97ed27f186e6591c_82
Original Code:
```
static grn_obj *
proc_table_tokenize(grn_ctx *ctx, int nargs, grn_obj **args, grn_user_data *user_data)
{
  grn_obj *table_name;
  grn_obj *string;
  grn_obj *flag_names;
  grn_obj *mode_name;

  table_name = VAR(0);
  string = VAR(1);
  flag_names = VAR(2);
  mode_name = VAR(3);

  if (GRN_TEXT_LEN(table_name) == 0) {
    ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] table name is missing");
    return NULL;
  }

  if (GRN_TEXT_LEN(string) == 0) {
    ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] string is missing");
    return NULL;
  }

  {
    unsigned int flags;
    grn_obj *lexicon;

    flags = parse_tokenize_flags(ctx, flag_names);
    if (ctx->rc != GRN_SUCCESS) {
      return NULL;
    }

    lexicon = grn_ctx_get(ctx, GRN_TEXT_VALUE(table_name), GRN_TEXT_LEN(table_name));

    if (!lexicon) {
      return NULL;
    }

#define MODE_NAME_EQUAL(name)\
    (GRN_TEXT_LEN(mode_name) == strlen(name) &&\
     memcmp(GRN_TEXT_VALUE(mode_name), name, strlen(name)) == 0)

    {
      grn_obj tokens;
      GRN_VALUE_FIX_SIZE_INIT(&tokens, GRN_OBJ_VECTOR, GRN_ID_NIL);
    if (GRN_TEXT_LEN(mode_name) == 0 || MODE_NAME_EQUAL("GET")) {
      tokenize(ctx, lexicon, string, GRN_TOKEN_GET, flags, &tokens);
      output_tokens(ctx, &tokens, lexicon);
    } else if (MODE_NAME_EQUAL("ADD")) {
      tokenize(ctx, lexicon, string, GRN_TOKEN_ADD, flags, &tokens);
      output_tokens(ctx, &tokens, lexicon);
    } else {
      ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] invalid mode: <%.*s>",
          (int)GRN_TEXT_LEN(mode_name), GRN_TEXT_VALUE(mode_name));
    }
      GRN_OBJ_FIN(ctx, &tokens);
    }
#undef MODE_NAME_EQUAL

    grn_obj_unlink(ctx, lexicon);
  }

  return NULL;
}
```


Overlapping Code:
```
c_table_tokenize(grn_ctx *ctx, int nargs, grn_obj **args, grn_user_data *user_data)
{
grn_obj *table_name;
grn_obj *string;
grn_obj *flag_names;
grn_obj *mode_name;
table_name = VAR(0);
string = VAR(1);
flag_names = VAR(2);
mode_name = VAR(3);
if (GRN_TEXT_LEN(table_name) == 0) {
ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] table name is missing");
return NULL;
}
if (GRN_TEXT_LEN(string) == 0) {
ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] string is missing");
return NULL;
}
{
unsigned int flags;
grn_obj *lexicon;
flags = parse_tokenize_flags(ctx, flag_names);
if (ctx->rc != GRN_SUCCESS) {
return NULL;
}
lexicon = grn_ctx_get(ctx, GRN_TEXT_VALUE(table_name), GRN_TEXT_LEN(table_name));
if (!lexicon) {
return NULL;
}
#define MODE_NAME_EQUAL(name)\
(GRN_TEXT_LEN(mode_name) == strlen(name) &&\
memcmp(GRN_TEXT_VALUE(mode_name), name, strlen(name)) == 0)
{
grn_obj tokens;
GRN_VALUE_FIX_SIZE_INIT(&tokens, GRN_OBJ_VECTOR, GRN_ID_NIL);
if (GRN_TEXT_LEN(mode_name) == 0 || MODE_NAME_EQUAL("GET")) {
tokenize(ctx, lexicon, string, GRN_TOKEN_GET, flags, &tokens);
output_tokens(ctx, &tokens, lexicon);
} else if (MODE_NAME_EQUAL("ADD")) {
tokenize(ctx, lexicon, string, GRN_TOKEN_ADD, flags, &tokens);
output_tokens(ctx, &tokens, lexicon);
} else {
ERR(GRN_INVALID_ARGUMENT, "[table_tokenize] invalid mode: <%.*s>",
(int)GRN_TEXT_LEN(mode_name), GRN_TEXT_VALUE(mode_name));
}
GRN_OBJ_FIN(ctx, &tokens);
}
#undef MODE_NAME_EQUAL
grn_obj_unlink(ctx, le
```
<Overlap Ratio: 0.9705488621151271>

---

--- 194 --
Question ID: 7f98ae47c6f73ea64fe01a3cc3ce0a77de5aa55d_17
Original Code:
```
static void rna_Itasc_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
{
  Object *ob = (Object *)ptr->owner_id;
  bItasc *itasc = ptr->data;

  /* verify values */
  if (itasc->precision < 0.0001f) {
    itasc->precision = 0.0001f;
  }
  if (itasc->minstep < 0.001f) {
    itasc->minstep = 0.001f;
  }
  if (itasc->maxstep < itasc->minstep) {
    itasc->maxstep = itasc->minstep;
  }
  if (itasc->feedback < 0.01f) {
    itasc->feedback = 0.01f;
  }
  if (itasc->feedback > 100.0f) {
    itasc->feedback = 100.0f;
  }
  if (itasc->maxvel < 0.01f) {
    itasc->maxvel = 0.01f;
  }
  if (itasc->maxvel > 100.0f) {
    itasc->maxvel = 100.0f;
  }
  BIK_update_param(ob->pose);

  DEG_id_tag_update(&ob->id, ID_RECALC_GEOMETRY);
}
```


Overlapping Code:
```
sc_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
{
Object *ob = (Object *)ptr->owner_id;
bItasc *itasc = ptr->data;
/* verify values */
if (itasc->precision < 0.0001f) {
itasc->precision = 0.0001f;
}
if (itasc->minstep < 0.001f) {
itasc->minstep = 0.001f;
}
if (itasc->maxstep < itasc->minstep) {
itasc->maxstep = itasc->minstep;
}
if (itasc->feedback < 0.01f) {
itasc->feedback = 0.01f;
}
if (itasc->feedback > 100.0f) {
itasc->feedback = 100.0f;
}
if (itasc->maxvel < 0.01f) {
itasc->maxvel = 0.01f;
}
if (itasc->maxvel > 100.0f) {
itasc->maxvel = 100.0f;
}
BIK_update_param(ob->pose);
DEG_id_tag_update(&ob->id, ID_RECALC_GEOMETRY);
}
```
<Overlap Ratio: 0.9719350073855244>

---

--- 195 --
Question ID: 040be8b9ab2ead6709dc8234134b7803e0c30e6a_2
Original Code:
```
bool
nav_msgs__srv__GetMap_Request__Sequence__init(nav_msgs__srv__GetMap_Request__Sequence * array, size_t size)
{
  if (!array) {
    return false;
  }
  nav_msgs__srv__GetMap_Request * data = NULL;
  if (size) {
    data = (nav_msgs__srv__GetMap_Request *)calloc(size, sizeof(nav_msgs__srv__GetMap_Request));
    if (!data) {
      return false;
    }
    // initialize all array elements
    size_t i;
    for (i = 0; i < size; ++i) {
      bool success = nav_msgs__srv__GetMap_Request__init(&data[i]);
      if (!success) {
        break;
      }
    }
    if (i < size) {
      // if initialization failed finalize the already initialized array elements
      for (; i > 0; --i) {
        nav_msgs__srv__GetMap_Request__fini(&data[i - 1]);
      }
      free(data);
      return false;
    }
  }
  array->data = data;
  array->size = size;
  array->capacity = size;
  return true;
}
```


Overlapping Code:
```
l
nav_msgs__srv__GetMap_Request__Sequence__init(nav_msgs__srv__GetMap_Request__Sequence * array, size_t size)
{
if (!array) {
return false;
}
nav_msgs__srv__GetMap_Request * data = NULL;
if (size) {
data = (nav_msgs__srv__GetMap_Request *)calloc(size, sizeof(nav_msgs__srv__GetMap_Request));
if (!data) {
return false;
}
// initialize all array elements
size_t i;
for (i = 0; i < size; ++i) {
bool success = nav_msgs__srv__GetMap_Request__init(&data[i]);
if (!success) {
break;
}
}
if (i < size) {
// if initialization failed finalize the already initialized array elements
for (; i > 0; --i) {
nav_msgs__srv__GetMap_Request__fini(&data[i - 1]);
}
free(data);
return false;
}
}
array->data = data;
array->size = size;
array->capacity = size;
return true;
}
```
<Overlap Ratio: 0.9960474308300395>

---

--- 196 --
Question ID: b347f0d8a681f2050651b61e44923db8baee9640_1
Original Code:
```
void BOARD_InitDEBUG_UARTPins(void)
{
    /* Enables clock for IOCON.: enable */
    CLOCK_EnableClock(kCLOCK_Iocon);
    /* Enables clock for switch matrix.: enable */
    CLOCK_EnableClock(kCLOCK_Swm);

    const uint32_t IOCON_INDEX_PIO0_0_config = (/* Selects pull-up function */
                                                IOCON_PIO_MODE_PULLUP |
                                                /* Enable hysteresis */
                                                IOCON_PIO_HYS_EN |
                                                /* Input not invert */
                                                IOCON_PIO_INV_DI |
                                                /* Disables Open-drain function */
                                                IOCON_PIO_OD_DI);
    /* PORT1 PIN7 (coords: ) is configured as  */
    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_0, IOCON_INDEX_PIO0_0_config);

    const uint32_t IOCON_INDEX_PIO0_4_config = (/* Selects pull-up function */
                                                IOCON_PIO_MODE_PULLUP |
                                                /* Enable hysteresis */
                                                IOCON_PIO_HYS_EN |
                                                /* Input not invert */
                                                IOCON_PIO_INV_DI |
                                                /* Disables Open-drain function */
                                                IOCON_PIO_OD_DI);
    /* PORT4 PIN (coords: ) is configured as  */
    IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_4, IOCON_INDEX_PIO0_4_config);

    /* USART0_TXD connect to P0_4 */
    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_TXD, kSWM_PortPin_P0_4);

    /* USART0_RXD connect to P0_0 */
    SWM_SetMovablePinSelect(SWM0, kSWM_USART0_RXD, kSWM_PortPin_P0_0);

    /* Disable clock for switch matrix. */
    CLOCK_DisableClock(kCLOCK_Swm);
}
```


Overlapping Code:
```
EBUG_UARTPins(void)
{
/* Enables clock for IOCON.: enable */
CLOCK_EnableClock(kCLOCK_Iocon);
/* Enables clock for switch matrix.: enable */
CLOCK_EnableClock(kCLOCK_Swm);
const uint32_t IOCON_INDEX_PIO0_0_config = (/* Selects pull-up function */
IOCON_PIO_MODE_PULLUP |
/* Enable hysteresis */
IOCON_PIO_HYS_EN |
/* Input not invert */
IOCON_PIO_INV_DI |
/* Disables Open-drain function */
IOCON_PIO_OD_DI);
/* PORT1 PIN7 (coords: ) is configured as */
IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_0, IOCON_INDEX_PIO0_0_config);
const uint32_t IOCON_INDEX_PIO0_4_config = (/* Selects pull-up function */
IOCON_PIO_MODE_PULLUP |
/* Enable hysteresis */
IOCON_PIO_HYS_EN |
/* Input not invert */
IOCON_PIO_INV_DI |
/* Disables Open-drain function */
IOCON_PIO_OD_DI);
/* PORT4 PIN (coords: ) is configured as */
IOCON_PinMuxSet(IOCON, IOCON_INDEX_PIO0_4, IOCON_INDEX_PIO0_4_config);
/* USART0_TXD connect to P0_4 */
SWM_SetMovablePinSelect(SWM0, kSWM_USART0_TXD, kSWM_PortPin_P0_4);
/* USART0_RXD connect to P0_0 */
SWM_SetMovablePinSelect(SWM0, kSWM_USART0_RXD, kSWM_PortPin_P0_0);
/* Disable clock for switch matrix. */
CLOCK_DisableClock(kCLOCK_Swm);
}
```
<Overlap Ratio: 0.9862660944206009>

---

--- 197 --
Question ID: f69ba559dcacae05cdc2e510ec11c295eaaac7bc_28
Original Code:
```
static Uint32
AutoHideTimeout(void *obj, Uint32 ival, void *arg)
{
	AG_Scrollbar *sb = obj;
	int x, len;

	if ((GetPxCoords(sb, &x, &len) == -1 ||
	    len == sb->length)) {
		if (AG_WidgetVisible(sb))
			AG_WidgetHide(sb);
	} else {
		if (!AG_WidgetVisible(sb))
			AG_WidgetShow(sb);
	}
	return (ival);
}
```


Overlapping Code:
```
meout(void *obj, Uint32 ival, void *arg)
{
AG_Scrollbar *sb = obj;
int x, len;
if ((GetPxCoords(sb, &x, &len) == -1 ||
len == sb->length)) {
if (AG_WidgetVisible(sb))
AG_WidgetHide(sb);
} else {
if (!AG_WidgetVisible(sb))
AG_WidgetShow(sb);
}
return (ival);
}
```
<Overlap Ratio: 0.9151943462897526>

---

--- 198 --
Question ID: 87f600a67be5b04a85d5833828315bcc8f980033_197
Original Code:
```
void f197(void) {
    	int8_t x878 = -50;
	int64_t x879 = -1LL;
	uint64_t x880 = UINT64_MAX;
	uint64_t t197 = 18364001LLU;

    t197 = (x877|((x878/x879)-x880));

    if (t197 != 51LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
int8_t x878 = -50;
int64_t x879 = -1LL;
uint64_t x880 = UINT64_MAX;
uint64_t t197 = 18364001LLU;
t197 = (x877|((x878/x879)-x880));
if (t197 !
```
<Overlap Ratio: 0.7853403141361257>

---

--- 199 --
Question ID: 047afa7b734b5260f071edea92bda562f2e7a872_3
Original Code:
```
struct anon_struct.conflictfa2 { // DWARF DIE: fa2
    uint32_t notch_en;
    int32_t spur_freq;
}
```


Overlapping Code:
```
onflictfa2 { // DWARF DIE: fa2
uint32_t notch_en;

```
<Overlap Ratio: 0.5555555555555556>

---

--- 200 --
Question ID: 3255fb0d691712207c9cb4033372c73537e48b6b_5
Original Code:
```
int coalition_info(proc_t p, struct coalition_info_args *uap, __unused int32_t *retval)
{
	user_addr_t cidp = uap->cid;
	user_addr_t buffer = uap->buffer;
	user_addr_t bufsizep = uap->bufsize;
	user_size_t bufsize;
	uint32_t flavor = uap->flavor;
	int error;
	uint64_t cid;
	coalition_t coal;

	error = copyin(cidp, &cid, sizeof(cid));
	if (error) {
		return error;
	}

	coal = coalition_find_by_id(cid);
	if (coal == COALITION_NULL) {
		return ESRCH;
	}
	/* TODO: priv check? EPERM or ESRCH? */

	if (IS_64BIT_PROCESS(p)) {
		user64_size_t size64;
		error = copyin(bufsizep, &size64, sizeof(size64));
		bufsize = (user_size_t)size64;
	} else {
		user32_size_t size32;
		error = copyin(bufsizep, &size32, sizeof(size32));
		bufsize = (user_size_t)size32;
	}
	if (error) {
		goto bad;
	}

	switch (flavor) {
	case COALITION_INFO_RESOURCE_USAGE:
		error = coalition_info_resource_usage(coal, buffer, bufsize);
		break;
	default:
		error = EINVAL;
	}

bad:
	coalition_release(coal);
	return error;
}
```


Overlapping Code:
```
ition_info(proc_t p, struct coalition_info_args *uap, __unused int32_t *retval)
{
user_addr_t cidp = uap->cid;
user_addr_t buffer = uap->buffer;
user_addr_t bufsizep = uap->bufsize;
user_size_t bufsize;
uint32_t flavor = uap->flavor;
int error;
uint64_t cid;
coalition_t coal;
error = copyin(cidp, &cid, sizeof(cid));
if (error) {
return error;
}
coal = coalition_find_by_id(cid);
if (coal == COALITION_NULL) {
return ESRCH;
}
/* TODO: priv check? EPERM or ESRCH? */
if (IS_64BIT_PROCESS(p)) {
user64_size_t size64;
error = copyin(bufsizep, &size64, sizeof(size64));
bufsize = (user_size_t)size64;
} else {
user32_size_t size32;
error = copyin(bufsizep, &size32, sizeof(size32));
bufsize = (user_size_t)size32;
}
if (error) {
goto bad;
}
switch (flavor) {
case COALITION_INFO_RESOURCE_USAGE:
error = coalition_info_resource_usage(coal, buffer, bufsize);
break;
default:
error = EINVAL;
}
bad:
coaliti
```
<Overlap Ratio: 0.9564293304994687>

---

--- 201 --
Question ID: cfed1d97ffdd388f2448e8c1d79f9ebc28bddc3f_128
Original Code:
```
void f128(void) {
    	volatile uint16_t x749 = 85U;
	int16_t x750 = -2015;
	static volatile int64_t x751 = -1LL;
	uint8_t x752 = 14U;
	int32_t t128 = -169545;

    t128 = (((x749*x750)!=x751)-x752);

    if (t128 != -13) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int16_t x749 = 85U;
int16_t x750 = -2015;
static volatile int64_t x751 = -1LL;
uint8_t x752 = 14U;
int32_t t128 = -169545;
t128 = (((x749*x750)!=x751)
```
<Overlap Ratio: 0.6637168141592921>

---

--- 202 --
Question ID: de7dfa2345c66832f12ffb289dd466db7a57b058_22
Original Code:
```
void f22(void) {
    	volatile int16_t x90 = INT16_MIN;
	uint16_t x92 = 112U;
	int32_t t22 = 0;

    t22 = ((x89/x90)>(x91==x92));

    if (t22 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
x90 = INT16_MIN;
uint16_t x92 = 112U;
int32_t t22 = 0;
t22 = ((x89/x90)>(x91==x92));
if (t22 != 0) {
```
<Overlap Ratio: 0.6410256410256411>

---

--- 203 --
Question ID: d69457997e55a2fae4f42ced590aba9e41589e98_129
Original Code:
```
void f129(void) {
    	uint8_t x1373 = UINT8_MAX;
	volatile int16_t x1374 = INT16_MAX;
	uint16_t x1375 = 493U;
	static uint8_t x1376 = 78U;
	static volatile int32_t t129 = 0;

    t129 = (x1373<<(x1374&(x1375/x1376)));

    if (t129 != 16320) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
uint8_t x1373 = UINT8_MAX;
volatile int16_t x1374 = INT16_MAX;
uint16_t x1375 = 493U;
static uint8_t x1376 = 78U;
static volatile int32_t t129 = 0;
t129 = (x1373<<(x1374&(x1375/x1376)));
if (
```
<Overlap Ratio: 0.8097165991902834>

---

--- 204 --
Question ID: 7f94e42d49a624afdd9d5e14854d8df81b5a3616_678
Original Code:
```
void u8g2_Setup_max7219_32x8_1(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
  uint8_t tile_buf_height;
  uint8_t *buf;
  u8g2_SetupDisplay(u8g2, u8x8_d_max7219_32x8, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
  buf = u8g2_m_4_1_1(&tile_buf_height);
  u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);
}
```


Overlapping Code:
```
9_32x8_1(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
{
uint8_t tile_buf_height;
uint8_t *buf;
u8g2_SetupDisplay(u8g2, u8x8_d_max7219_32x8, u8x8_cad_empty, byte_cb, gpio_and_delay_cb);
buf = u8g2_m_4_1_1(&tile_buf_height);
u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_horizontal_right_lsb, rotation);
}
```
<Overlap Ratio: 0.9431524547803618>

---

--- 205 --
Question ID: 4c48e218be9ae138578e33a693d6a92a2dbd68f4_94
Original Code:
```
void f94(void) {
    	uint16_t x485 = 3U;
	int16_t x487 = -1;
	uint32_t x488 = 9430U;

    t94 = ((x485==x486)!=(x487*x488));

    if (t94 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
t x487 = -1;
uint32_t x488 = 9430U;
t94 = ((x485==x486)!=(x487*x488));
if (t94 != 1) { NG(); } else 
```
<Overlap Ratio: 0.6622516556291391>

---

--- 206 --
Question ID: b41900f160f07ac0a8d147d3552758d97d00eff9_10
Original Code:
```
int fs_getSize(lua_State *L) {
    struct stat st;
    char * path = fixpath(lua_tostring(L, 1));
    if (stat(path, &st) != 0) err(L, path, "No such file");
    lua_pushinteger(L, st.st_size);
    free(path);
    return 1;
}
```


Overlapping Code:
```
e *L) {
struct stat st;
char * path = fixpath(lua_tostring(L, 1));
if (stat(path, &st) != 0) err(L, path, "No such file");
lua_pushinteger(L, st.st_size);
free(path);
ret
```
<Overlap Ratio: 0.845771144278607>

---

--- 207 --
Question ID: b127f8858dc0efbc437a424036dcd18ac998af9c_0
Original Code:
```
INT32 __stdcall ListViewCompareProc(
    LONG lParam1,
    LONG lParam2,
    LONG lParamSort)
{
    unsigned long iBytes1   = (unsigned long) lParam1;
    unsigned long iBytes2   = (unsigned long) lParam2;
    int iResult             = iBytes1 - iBytes2;

    return(-iResult);
}
```


Overlapping Code:
```
ll ListViewCompareProc(
LONG lParam1,
LONG lParam2,
LONG lParamSort)
{
unsigned long iBytes1 = (unsigned long) lParam1;
unsigned long iBytes2 = (unsigned long) lParam2;
int iResult = iBytes1 - iBytes2;
return(-iR
```
<Overlap Ratio: 0.905982905982906>

---

--- 208 --
Question ID: 1150f92a15ed6b941499c95f9cae15b7315beb99_11
Original Code:
```
static void
cm_session_neg_test(void **state) {
    Sr__Msg *msg = NULL;
    uint8_t *msg_buf = NULL;
    size_t msg_size = 0;
    int fd1 = 0, fd2 = 0;
    uint32_t session_id1 = 0, session_id2 = 0;

    fd1 = cm_connect_to_server(0);

    /* try invalid version  */
    cm_version_verify_generate("invalid", &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    msg = cm_message_recv(fd1);
    assert_non_null(msg);
    assert_int_equal(msg->type, SR__MSG__MSG_TYPE__RESPONSE);
    assert_non_null(msg->response);
    assert_int_equal(msg->response->result, SR_ERR_VERSION_MISMATCH);
    assert_int_equal(msg->response->operation, SR__OPERATION__VERSION_VERIFY);
    assert_non_null(msg->response->version_verify_resp);
    assert_string_equal_bt(msg->response->version_verify_resp->soname, SR_COMPAT_VERSION);
    sr__msg__free_unpacked(msg, NULL);

    /* disconnect expected */
    msg = cm_message_recv(fd1);
    assert_null(msg);
    close(fd1);

    fd1 = cm_connect_to_server(1);

    /* try a message with NULL request  */
    msg = calloc(1, sizeof(*msg));
    assert_non_null(msg);
    sr__msg__init(msg);
    msg->type = SR__MSG__MSG_TYPE__REQUEST;
    /* send the message */
    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd1);
    /* disconnect expected */
    assert_null(msg);
    close(fd1);

    fd1 = cm_connect_to_server(1);

    /* try a message with bad session id */
    cm_session_stop_generate(999, &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd1);
    /* disconnect expected */
    assert_null(msg);
    close(fd1);

    fd1 = cm_connect_to_server(1);

    /* try a session_start request with non-existing username */
    cm_session_start_generate("non-existing-username", &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd1);
    assert_non_null(msg);
    assert_non_null(msg->response);
    assert_non_null(msg->response->session_start_resp);
    /* expect invalid user error */
    assert_int_equal(msg->response->result, SR_ERR_INVAL_USER);
    sr__msg__free_unpacked(msg, NULL);
    close(fd1);

    fd1 = cm_connect_to_server(1);
    fd2 = cm_connect_to_server(1);

    /* try to stop session via another connection */
    /* session_start request */
    cm_session_start_generate("nobody", &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd1);
    assert_non_null(msg);
    assert_non_null(msg->response);
    assert_non_null(msg->response->session_start_resp);
    session_id1 = msg->response->session_start_resp->session_id;
    sr__msg__free_unpacked(msg, NULL);
    /* stop via another connection */
    cm_session_stop_generate(session_id1, &msg_buf, &msg_size);
    cm_message_send(fd2, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd2);
    /* disconnect expected */
    assert_null(msg);
    close(fd2);

    fd2 = cm_connect_to_server(1);

    /* try sending a response */
    /* session_start request */
    cm_session_start_generate("nobody", &msg_buf, &msg_size);
    cm_message_send(fd2, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd2);
    assert_non_null(msg);
    assert_non_null(msg->response);
    assert_non_null(msg->response->session_start_resp);
    session_id2 = msg->response->session_start_resp->session_id;
    sr__msg__free_unpacked(msg, NULL);
    /* send BAD response */
    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id2, &msg);
    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);
    cm_message_send(fd2, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd2);
    /* disconnect expected */
    assert_null(msg);
    close(fd2);

    /* try to stop another session id */
    sr_gpb_req_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);
    assert_non_null(msg);
    assert_non_null(msg->request);
    assert_non_null(msg->request->session_stop_req);
    msg->request->session_stop_req->session_id = 0; /* should be invalid */
    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response - error is expected */
    msg = cm_message_recv(fd1);
    assert_non_null(msg);
    assert_non_null(msg->response);
    assert_int_not_equal(msg->response->result, SR_ERR_OK);
    assert_non_null(sr_strerror(msg->response->result));
    assert_non_null(msg->response->error);
    assert_non_null(msg->response->error->message);
    sr__msg__free_unpacked(msg, NULL);

    /* try sending a message with invalid type */
    sr_gpb_resp_alloc(NULL, SR__OPERATION__SESSION_STOP, session_id1, &msg);
    msg->type = 53;
    cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);
    cm_message_send(fd1, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd1);
    /* disconnect expected */
    assert_null(msg);
    close(fd1);

    fd2 = cm_connect_to_server(1);

    /* try not closing a connection with an open session (auto cleanup) */
    /* session_start request */
    cm_session_start_generate(NULL, &msg_buf, &msg_size);
    cm_message_send(fd2, msg_buf, msg_size);
    free(msg_buf);
    /* receive the response */
    msg = cm_message_recv(fd2);
    assert_non_null(msg);
    assert_non_null(msg->response);
    assert_non_null(msg->response->session_start_resp);
    session_id2 = msg->response->session_start_resp->session_id;
    sr__msg__free_unpacked(msg, NULL);

    cm_teardown(state);
    close(fd2);
}
```


Overlapping Code:
```

cm_session_neg_test(void **state) {
Sr__Msg *msg = NULL;
uint8_t *msg_buf = NULL;
size_t msg_size = 0;
int fd1 = 0, fd2 = 0;
uint32_t session_id1 = 0, session_id2 = 0;
fd1 = cm_connect_to_server(0);
/* try invalid version */
cm_version_verify_generate("invalid", &msg_buf, &msg_size);
cm_message_send(fd1, msg_buf, msg_size);
free(msg_buf);
msg = cm_message_recv(fd1);
assert_non_null(msg);
assert_int_equal(msg->type, SR__MSG__MSG_TYPE__RESPONSE);
assert_non_null(msg->response);
assert_int_equal(msg->response->result, SR_ERR_VERSION_MISMATCH);
assert_int_equal(msg->response->operation, SR__OPERATION__VERSION_VERIFY);
assert_non_null(msg->response->version_verify_resp);
assert_string_equal_bt(msg->response->version_verify_resp->soname, SR_COMPAT_VERSION);
sr__msg__free_unpacked(msg, NULL);
/* disconnect expected */
msg = cm_message_recv(fd1);
assert_null(msg);
close(fd1);
fd1 = cm_connect_to_server(1);
/* try a message with NULL request */
msg = calloc(1, sizeof(*msg));
assert_non_null(msg);
sr__msg__init(msg);
msg->type = SR__MSG__MSG_TYPE__REQUEST;
/* send the message */
cm_msg_pack_to_buff(msg, &msg_buf, &msg_size);
cm_message_send(fd1, msg_buf, msg_size);
free(msg_buf);
/* receive the response */
msg = cm_message_recv(fd1);
/* disconnect expected */
assert_null(msg);
close(fd1);
fd1 = cm_connect_to_server(1);
/* try a message with bad session id */
cm_session_stop_generate(999, &msg_buf, &msg_size);
cm_message_send(fd1, msg_buf, msg_size);
free(msg_buf);
/* receive the response */
msg = cm_message_recv(fd1);
/* disconnect expected */
assert_null(msg);
close(fd1);
fd1 = cm_connect_to_server(1);
/* try a session_start request with non-existing username */
cm_session_start_generate("non-existing-username", &msg_buf, &msg_size);
cm_message_send(fd1, msg_buf, msg_size);
free(msg_buf);
/* receive the response */
msg = cm_message_recv(fd1);
assert_non_null(msg);
assert_non_null(msg->response);
assert_non_null(msg->response->session_start_resp);
/* expect invalid user error */
assert_int_equal(msg->response->result, SR_ERR_INVAL_USER);
sr__msg__free_unpacked(msg, NULL);
close(fd1);
fd1 = cm_connect_to_server(1);
fd2 = cm_connect_to_server(1);
/* try to stop session via
```
<Overlap Ratio: 0.9883198562443846>

---

--- 209 --
Question ID: 1f791e41e52acaee2d311ea3bd6aef9b0bce1198_150
Original Code:
```
void f150(void) {
    	volatile int32_t x797 = 696224;
	volatile uint8_t x799 = UINT8_MAX;
	int16_t x800 = 1;
	volatile int32_t t150 = -4388;

    t150 = ((x797&x798)%(x799&x800));

    if (t150 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f150(void) {
volatile int32_t x797 = 696224;
volatile uint8_t x799 = UINT8_MAX;
int16_t x800 = 1;
volatile int32_t t150 = -4388;
t150 = ((x797&x798)%(x799&x800));
if (t150 != 0) { NG(); } else { ;
```
<Overlap Ratio: 0.970873786407767>

---

--- 210 --
Question ID: 147a41642a317d1f8393bba00c9d40eb63ac4e49_31
Original Code:
```
static int con_write_room(struct tty_struct *tty)
{
	if (tty->stopped)
		return 0;
	return 4096;		/* No limit, really; we're not buffering */
}
```


Overlapping Code:
```
atic int con_write_room(struct tty_struct *tty)
{
if (tty->stopped)
return 0;
return 4096; /* No limit, really; we're not buff
```
<Overlap Ratio: 0.9130434782608695>

---

--- 211 --
Question ID: edc9ece8f5eebcf7719745eeab2ce52a53ecdd54_996
Original Code:
```
static int
loci_validate_of_oxm_vlan_pcp_OF_VERSION_1_3(uint8_t *data, int len, int *out_len)
{
    if (len < 5) {
        return -1;
    }

    len = 5;




    *out_len = len;
    return 0;
}
```


Overlapping Code:
```
tic int
loci_validate_of_oxm_vlan_pcp_OF_VERSION_1_3(uint8_t *data, int len, int *out_len)
{
if (len < 5) {
return -1;
}
len = 5;
*out_len = len;
return 0
```
<Overlap Ratio: 0.9625>

---

--- 212 --
Question ID: ea12ecf3841f580078395ffdce36a36aa667e729_5
Original Code:
```
void tls_os_timer_stop(tls_os_timer_t *timer)
{
//    rt_kprintf("%s %d %p\r\n", __FUNCTION__, __LINE__, timer);
    rt_err_t err = rt_timer_stop(timer);
//    if(err != RT_EOK)
//        rt_kprintf("rt_timer_stop error:%d...\r\n", err);
}
```


Overlapping Code:
```
imer_t *timer)
{
// rt_kprintf("%s %d %p\r\n", __FUNCTION__, __LINE__, timer);
rt_err_t err = rt_timer_stop(timer);
// if(err != RT_EOK)
// rt_kprintf
```
<Overlap Ratio: 0.6756756756756757>

---

--- 213 --
Question ID: f62d365b8c33794fd508c3956ba5969f710ae0e6_1
Original Code:
```
LFRTM_API int
lfrtm_free(lfrtm_t *lfrtm)
{
	if(!lfrtm)
	{
		return -1;
	}

	for(unsigned idx = 0; idx < lfrtm->num; idx++)
	{
		uintptr_t pool = atomic_exchange(&lfrtm->pools[idx], 0);
		if( (pool != 0) && (pool != UINTPTR_MAX) )
		{
			free((void *)pool);
		}
	}

	free(lfrtm);
	return 0;
}
```


Overlapping Code:
```
t
lfrtm_free(lfrtm_t *lfrtm)
{
if(!lfrtm)
{
return -1;
}
for(unsigned idx = 0; idx < lfrtm->num; idx++)
{
uintptr_t pool = atomic_exchange(&lfrtm->pools[idx], 0);
if( (pool != 0) && (pool != UINTPTR_MAX) )
{
free((void *)pool);
}
}
free(lfrtm);
retur
```
<Overlap Ratio: 0.9328358208955224>

---

--- 214 --
Question ID: acbe28e0552057284b8c25ff311b48fd22db876f_42
Original Code:
```
void f42(void) {
    	int8_t x249 = 4;
	volatile int8_t x251 = INT8_MIN;
	volatile int32_t t42 = -40;

    t42 = (((x249^x250)*x251)^x252);

    if (t42 != -208385) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
{
int8_t x249 = 4;
volatile int8_t x251 = INT8_MIN;
volatile int32_t t42 = -40;
t42 = (((x249^x250)*x251)^x252);
if (t42 != -208385) { NG(); } else { 
```
<Overlap Ratio: 0.8771929824561403>

---

--- 215 --
Question ID: ed598a0f9ace4c24b6589715fc8aeea10d02e443_3
Original Code:
```
void f3(void) {
    	static volatile int16_t x17 = -1;
	uint32_t x18 = 66520U;
	static uint16_t x19 = 3118U;
	static volatile int8_t x20 = INT8_MIN;

    t3 = ((x17<=x18)^(x19+x20));

    if (t3 != 2990) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
tatic volatile int16_t x17 = -1;
uint32_t x18 = 66520U;
static uint16_t x19 = 3118U;
static volatile int8_t x20 = INT8_MIN;
t3 = ((x17<=x18)^(x19+x20)
```
<Overlap Ratio: 0.7177033492822966>

---

--- 216 --
Question ID: 52d8a159ac3e4210b24279cd50ff620fe49964a5_8
Original Code:
```
void f8(void) {
    	int8_t x37 = INT8_MAX;
	uint8_t x38 = 90U;
	int16_t x39 = 1;
	static uint32_t x40 = 23234U;
	static volatile int32_t t8 = -2106395;

    t8 = ((x37/x38)==(x39/x40));

    if (t8 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f8(void) {
int8_t x37 = INT8_MAX;
uint8_t x38 = 90U;
int16_t x39 = 1;
static uint32_t x40 = 23234U;
static volatile int32_t t8 = -2106395;
t8 = ((x37/x38)==(x39/x40));
if (t8 != 0) { NG
```
<Overlap Ratio: 0.9043062200956937>

---

--- 217 --
Question ID: 9ecec34dbb5588ba5e11f7befd5c9ec0a6cff329_195
Original Code:
```
void f195(void) {
    	int8_t x929 = -3;
	int32_t x931 = INT32_MIN;
	static int16_t x932 = INT16_MAX;
	int32_t t195 = 0;

    t195 = (((x929|x930)*x931)!=x932);

    if (t195 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
31 = INT32_MIN;
static int16_t x932 = INT16_MAX;
int32_t t195 = 0;
t195 = (((x929|x930)*x931)!=x932)
```
<Overlap Ratio: 0.5376344086021505>

---

--- 218 --
Question ID: cdca576401bf81fa2f1fdea0f5edc7685d3952fc_168
Original Code:
```
int func_391(int iParam0)
{
	int iVar0;
	
	if (PED::IS_PED_IN_ANY_VEHICLE(iParam0, true))
	{
		return 1;
	}
	else
	{
		iVar0 = TASK::GET_SCRIPT_TASK_STATUS(iParam0, -1794415470);
		if (iVar0 == 0)
		{
			return 1;
		}
	}
	return 0;
}
```


Overlapping Code:
```
 iParam0)
{
int iVar0;

if (PED::IS_PED_IN_ANY_VEHICLE(iParam0, true))
{
return 1;
}
else
{
iVar0 = TASK::GET_SCRIPT_TASK_STATUS(iParam0, -1794415470);
if (iVar0 == 0)
{
return 1;
}
}
return 0;

```
<Overlap Ratio: 0.919431279620853>

---

--- 219 --
Question ID: 3b9bb93001bde927df464b4624379ef6a52c9d6e_89
Original Code:
```
NTSTRSAFEWORKERDDI
    RtlStringExValidateDestA(
            _In_reads_opt_(cchDest) STRSAFE_PCNZCH pszDest,
            _In_ size_t cchDest,
            _In_ const size_t cchMax,
            _In_ DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;

    if (dwFlags & STRSAFE_IGNORE_NULLS)
    {
        if (((pszDest == NULL) && (cchDest != 0))   ||
                (cchDest > cchMax))
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        status = RtlStringValidateDestA(pszDest, cchDest, cchMax);
    }

    return status;
}
```


Overlapping Code:
```
EWORKERDDI
RtlStringExValidateDestA(
_In_reads_opt_(cchDest) STRSAFE_PCNZCH pszDest,
_In_ size_t cchDest,
_In_ const size_t cchMax,
_In_ DWORD dwFlags)
{
NTSTATUS status = STATUS_SUCCESS;
if (dwFlags & STRSAFE_IGNORE_NULLS)
{
if (((pszDest == NULL) && (cchDest != 0)) ||
(cchDest > cchMax))
{
status = STATUS_INVALID_PARAMETER;
}
}
else
{
status = RtlStringValidateDestA(pszDest, cchDest, cchMax);
}
retur
```
<Overlap Ratio: 0.9551886792452831>

---

--- 220 --
Question ID: cab196bb38cd4c92f6cf2c40d9df180e13789ca3_1
Original Code:
```
static void wcn36xx_set_tx_pdu(struct wcn36xx_tx_bd *bd,
			       u32 mpdu_header_len,
			       u32 len,
			       u16 tid)
{
	bd->pdu.mpdu_header_len = mpdu_header_len;
	bd->pdu.mpdu_header_off = sizeof(*bd);
	bd->pdu.mpdu_data_off = bd->pdu.mpdu_header_len +
		bd->pdu.mpdu_header_off;
	bd->pdu.mpdu_len = len;
	bd->pdu.tid = tid;
	/* Use seq number generated by mac80211 */
	bd->pdu.bd_ssn = WCN36XX_TXBD_SSN_FILL_HOST;
}
```


Overlapping Code:
```
(struct wcn36xx_tx_bd *bd,
u32 mpdu_header_len,
u32 len,
u16 tid)
{
bd->pdu.mpdu_header_len = mpdu_header_len;
bd->pdu.mpdu_header_off = sizeof(*bd);
bd->pdu.mpdu_data_off = bd->pdu.mpdu_header_len +
bd->pdu.mpdu_header_off;
bd->pdu.mpdu_len = len;
bd->pdu.tid = tid;
/* Use seq number generated by mac80211 */
bd->pdu.bd_ssn = WCN36XX_TXBD_SSN_FILL_HOST
```
<Overlap Ratio: 0.9147286821705426>

---

--- 221 --
Question ID: aafb03f076134e8bdad23b65e7838e6efd3a264b_3
Original Code:
```
void GrDestroyPath(GrPath *gp)
{
    if (gp == NULL) return;
    free(gp->pp);
    free(gp);
}
```


Overlapping Code:
```
th(GrPath *gp)
{
if (gp == NULL) return;
free(gp->
```
<Overlap Ratio: 0.6097560975609756>

---

--- 222 --
Question ID: f883de602315e1de39d913ae15afce202ca8d6be_22
Original Code:
```
void f22(void) {
    	static uint64_t x149 = 152LLU;
	int32_t x150 = INT32_MAX;
	static uint64_t x151 = 479090467LLU;
	static volatile uint64_t t22 = 7246107089468116LLU;

    t22 = ((x149==x150)/(x151/x152));

    if (t22 != 0LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d f22(void) {
static uint64_t x149 = 152LLU;
int32_t x150 = INT32_MAX;
static uint64_t x151 = 479090467LLU;
static volatile uint64_t t22 = 7246107089468116LLU;
t22 = ((x149==x150)/(x151/x1
```
<Overlap Ratio: 0.7932489451476793>

---

--- 223 --
Question ID: 64f7b09f97859fecef2ad3f944d0fa8f5427ef81_170
Original Code:
```
void f170(void) {
    	int32_t x693 = INT32_MIN;
	uint16_t x694 = UINT16_MAX;
	static int8_t x695 = INT8_MIN;
	volatile int32_t x696 = 4;
	static volatile int32_t t170 = 1;

    t170 = ((x693>(x694<=x695))/x696);

    if (t170 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
93 = INT32_MIN;
uint16_t x694 = UINT16_MAX;
static int8_t x695 = INT8_MIN;
volatile int32_t x696 = 4;
static volatile int32_t t170 = 1;
t170 = ((x693>(x694<=x695))/x696);
if (t170 != 0) { NG(); } else
```
<Overlap Ratio: 0.8438818565400844>

---

--- 224 --
Question ID: 0cb7e05c5c5aae3161e867582e8a4f227e5eb050_33
Original Code:
```
static int JSPROMISE_CREATE(
    __dbExecAsync,
    env,
    data
) {
// This function will run <bufin[1]> in <db> and save any result
// (list of tables containing rows from SELECT/pragma/etc) as serialized
// json-string in <pResult>.
/* *INDENT-OFF* */
SQLMATH_API int dbExec(sqlite3 *, Jsbaton *);
/* *INDENT-ON* */
    // init baton
    Jsbaton *baton = (Jsbaton *) data;
    // declare var
    int errcode = 0;
    sqlite3 *db = (sqlite3 *) (intptr_t) baton->argint64[0];
    // call c-function
    errcode = dbExec(db, baton);
    ASSERT_SQLITE_OK(baton, db, errcode);
  catch_error:
    return 0;
}
```


Overlapping Code:
```
cAsync,
env,
data
) {
// This function will run <bufin[1]> in <db> and save any result
// (list of tables containing rows from SELECT/pragma/etc) as serialized
// json-string in <pResult>.
/* *INDENT-OFF* */
SQLMATH_API int dbExec(sqlite3 *, Jsbaton *);
/* *INDENT-ON* */
// init baton
Jsbaton *baton = (Jsbaton *) data;
// declare var
int errcode = 0;
sqlite3 *db = (sqlite3 *) (intptr_t) baton->argint64[0];
// call c-function
errcode = dbExec(db, baton);
ASSERT_SQLITE_OK(baton, db, errcode);
catc
```
<Overlap Ratio: 0.8992805755395683>

---

--- 225 --
Question ID: 9d4a3fd63781bf437ae81bbbb9e1dfe869ec54b6_7
Original Code:
```
void MidLine(int x1, int y1, int x2, int y2)
{
	//交换两点的坐标
	if ((x1 - x2) > 0 && (y1 - y2) > 0)
	{
		int c = x1;
		x1 = x2;
		x2 = c;
		c = y1;
		y1 = y2;
		y2 = c;
	}
	if ((x1 - x2) < 0 && (y1 - y2) > 0)
	{
		int c = x1;
		x1 = x2;
		x2 = c;
		c = y1;
		y1 = y2;
		y2 = c;
	}
	float a = y1 - y2, b = x2 - x1;
	float m = -(a / b); //斜率，用于判断直线不同的情况

	//当斜率大于0，小于1的情况
	if (0 <= m && m <= 1)
	{
		float d = 2 * a + b, deta1 = 2 * a, deta2 = 2 * (a + b), x = x1, y = y1;
		while (x < x2)
		{
			SetPixel(x, y); //画坐标点
			if (d < 0)
			{
				x++, y++, d += deta2;
			}
			else
			{
				x++, d += deta1;
			}
		}
	}
	//当斜率大于1的情况
	if (m > 1)
	{
		int d = a + 2 * b, deta1 = 2 * b, deta2 = 2 * (a + b), x = x1, y = y1;
		while (y < y2)
		{
			SetPixel(x, y); //画坐标点
			if (d > 0)
			{
				y++, x++, d += deta2;
			}
			else
			{
				y++, d += deta1;
			}
		}
	}
	//当斜率小于-1的情况
	if (m <= -1)
	{
		int d = -a + 2 * b, deta1 = 2 * b, deta2 = 2 * (b - a), x = x1, y = y1;
		while (y < y2)
		{
			SetPixel(x, y); //画坐标点
			if (d < 0)
			{
				x--, y++, d += deta2;
			}
			else
			{
				y++, d += deta1;
			}
		}
	}
	//当斜率小于0大于-1的情况
	if (m > -1 && m < 0)
	{
		int a = y1 - y2, b = x2 - x1;
		int d = -2 * a + b, deta1 = -2 * a, deta2 = 2 * (b - a), x = x1, y = y1;
		while (x > x2)
		{
			SetPixel(x, y); //画坐标点
			if (d > 0)
			{
				x--, y++, d += deta2;
			}
			else
			{
				x--, d += deta1;
			}
		}
	}
}
```


Overlapping Code:
```
dLine(int x1, int y1, int x2, int y2)
{
//交换两点的坐标
if ((x1 - x2) > 0 && (y1 - y2) > 0)
{
int c = x1;
x1 = x2;
x2 = c;
c = y1;
y1 = y2;
y2 = c;
}
if ((x1 - x2) < 0 && (y1 - y2) > 0)
{
int c = x1;
x1 = x2;
x2 = c;
c = y1;
y1 = y2;
y2 = c;
}
float a = y1 - y2, b = x2 - x1;
float m = -(a / b); //斜率，用于判断直线不同的情况
//当斜率大于0，小于1的情况
if (0 <= m && m <= 1)
{
float d = 2 * a + b, deta1 = 2 * a, deta2 = 2 * (a + b), x = x1, y = y1;
while (x < x2)
{
SetPixel(x, y); //画坐标点
if (d < 0)
{
x++, y++, d += deta2;
}
else
{
x++, d += deta1;
}
}
}
//当斜率大于1的情况
if (m > 1)
{
int d = a + 2 * b, deta1 = 2 * b, deta2 = 2 * (a + b), x = x1, y = y1;
while (y < y2)
{
SetPixel(x, y); //画坐标点
if (d > 0)
{
y++, x++, d += deta2;
}
else
{
y++, d += deta1;
}
}
}
//当斜率小于-1的情况
if (m <= -1)
{
int d = -a + 2 * b, deta1 = 2 * b, deta2 = 2 * (b - a), x = x1, y = y1;
while (y < y2)
{
SetPixel(x, y); //画坐标点
if (d < 0)
{
x--, y++, d += deta2;
}
else
{
y++, d += deta1;
}
}
}
//当斜率小于0大于-1的情况
if (m > -1 && m < 0)
{
int a = y1 - y2, b = x2 - x1;
int d = -2 * a + b, deta1 = -2 * a, deta2 = 2 * (b - a), x = x1, y = y1;
while (x > x2)
{
SetPixel(x, y); //画坐标点
if (d > 0)
{
x--, y++, d += det
```
<Overlap Ratio: 0.9631490787269682>

---

--- 226 --
Question ID: 0dd11fb7c8d89b09a4748e94a8dac2496fb1f17b_0
Original Code:
```
u_int64_t	hash_sdbm(const char *str)
{
	u_int64_t		hash;
	u_int32_t		c;

	hash = 0;
	while ((c = (u_int32_t)(*str++)))
		hash = c + (hash << 6) + (hash << 16) - hash;
	return (hash);
}
```


Overlapping Code:
```
const char *str)
{
u_int64_t hash;
u_int32_t c;
hash = 0;
while ((c = (u_int32_t)(*str++)))
hash = c + (hash << 6) + (hash << 16) - hash;
return (hash);
}
```
<Overlap Ratio: 0.8850574712643678>

---

--- 227 --
Question ID: 340ff423ac0af3760594263b5f5ab400a7fe2457_1
Original Code:
```
void init(){
  ::init();
  add_action("touch_fun","touch");
  return;
}
```


Overlapping Code:
```
nit(){
::init();
add_action("touch_fun","touch");
return
```
<Overlap Ratio: 0.8615384615384616>

---

--- 228 --
Question ID: 338c634080545aabb51aaae8bbc0178dc7c28ed8_77
Original Code:
```
void f77(void) {
    	uint8_t x365 = 12U;
	int32_t x366 = INT32_MAX;
	int32_t x367 = -1;
	volatile int16_t x368 = INT16_MAX;
	volatile int32_t t77 = -3242616;

    t77 = (((x365|x366)+x367)/x368);

    if (t77 != 65538) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f77(void) {
uint8_t x365 = 12U;
int32_t x366 = INT32_MAX;
int32_t x367 = -1;
volatile int16_t x368 = INT16_MAX;
volatile int32_t t77 = -3242616;
t77 = (((x365|x366)+x367)/x368);
if (t77 != 65538) { N
```
<Overlap Ratio: 0.8928571428571429>

---

--- 229 --
Question ID: 7bf3af4936e843676abba08dcbdf4c3c545e6cf6_131
Original Code:
```
void f131(void) {
    	int32_t x665 = -1;
	uint64_t x666 = 30963550783394755LLU;
	int64_t x667 = -1LL;
	int32_t t131 = 333812;

    t131 = (x665>((x666-x667)-x668));

    if (t131 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
131(void) {
int32_t x665 = -1;
uint64_t x666 = 30963550783394755LLU;
int64_t x667 = -1LL;
int32_t t131 = 333812;
t131 = (x665>((x666-x667)-x668));
if 
```
<Overlap Ratio: 0.7853403141361257>

---

--- 230 --
Question ID: d0b1659a157603fbb1de9e19593096df15765aa3_4
Original Code:
```
static void preprocess_signed(struct aec_stream *strm)
{
    /**
       Preprocess RSI of signed samples.
    */

    uint32_t D;
    struct internal_state *state = strm->state;
    int32_t *restrict x = (int32_t *)state->data_raw;
    uint32_t *restrict d = state->data_pp;
    int32_t xmax = (int32_t)state->xmax;
    int32_t xmin = (int32_t)state->xmin;
    uint32_t rsi = strm->rsi * strm->block_size - 1;
    uint32_t m = UINT64_C(1) << (strm->bits_per_sample - 1);
    size_t i;

    state->ref = 1;
    state->ref_sample = x[0];
    d[0] = 0;
    x[0] = (x[0] ^ m) - m;

    for (i = 0; i < rsi; i++) {
        x[i + 1] = (x[i + 1] ^ m) - m;
        if (x[i + 1] < x[i]) {
            D = (uint32_t)(x[i] - x[i + 1]);
            if (D <= (uint32_t)(xmax - x[i]))
                d[i + 1] = 2 * D - 1;
            else
                d[i + 1] = xmax - x[i + 1];
        } else {
            D = (uint32_t)(x[i + 1] - x[i]);
            if (D <= (uint32_t)(x[i] - xmin))
                d[i + 1] = 2 * D;
            else
                d[i + 1] = x[i + 1] - xmin;
        }
    }
    state->uncomp_len = (strm->block_size - 1) * strm->bits_per_sample;
}
```


Overlapping Code:
```
d preprocess_signed(struct aec_stream *strm)
{
/**
Preprocess RSI of signed samples.
*/
uint32_t D;
struct internal_state *state = strm->state;
int32_t *restrict x = (int32_t *)state->data_raw;
uint32_t *restrict d = state->data_pp;
int32_t xmax = (int32_t)state->xmax;
int32_t xmin = (int32_t)state->xmin;
uint32_t rsi = strm->rsi * strm->block_size - 1;
uint32_t m = UINT64_C(1) << (strm->bits_per_sample - 1);
size_t i;
state->ref = 1;
state->ref_sample = x[0];
d[0] = 0;
x[0] = (x[0] ^ m) - m;
for (i = 0; i < rsi; i++) {
x[i + 1] = (x[i + 1] ^ m) - m;
if (x[i + 1] < x[i]) {
D = (uint32_t)(x[i] - x[i + 1]);
if (D <= (uint32_t)(xmax - x[i]))
d[i + 1] = 2 * D - 1;
else
d[i + 1] = xmax - x[i + 1];
} else {
D = (uint32_t)(x[i + 1] - x[i]);
if (D <= (uint32_t)(x[i] - xmin))
d[i + 1] = 2 * D;
else
d[i + 1] = x[i + 1] - xmin;
}
}
state->uncomp_len = (strm->block_size - 1) * str
```
<Overlap Ratio: 0.9660087719298246>

---

--- 231 --
Question ID: c2323d6b07e0c084b19c7f277d6dc50084c0e57e_132
Original Code:
```
void f132(void) {
    	uint16_t x2829 = 13U;
	uint32_t x2830 = UINT32_MAX;
	volatile uint8_t x2831 = 0U;
	int32_t x2832 = 11150;

    t132 = ((x2829^x2830)<<(x2831&x2832));

    if (t132 != 4294967282U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x2830 = UINT32_MAX;
volatile uint8_t x2831 = 0U;
int32_t x2832 = 11150;
t132 = ((x2829^x2830)<<(x2831&x2832));
if (t132 != 4294967282U) { NG(); } e
```
<Overlap Ratio: 0.7211538461538461>

---

--- 232 --
Question ID: 8422707813c3e82146aad7839d40ce8f0c0f2a6e_12
Original Code:
```
void f12(void) {
    	int64_t x49 = 640083LL;
	uint32_t x51 = UINT32_MAX;
	volatile int64_t x52 = 43763696543LL;
	static int32_t t12 = 1037;

    t12 = ((x49<=x50)==(x51%x52));

    if (t12 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void f12(void) {
int64_t x49 = 640083LL;
uint32_t x51 = UINT32_MAX;
volatile int64_t x52 = 43763696543LL;
static int32_t t12 = 1037;
t12 = ((x49<=x50)==(x51%x52));
if (t12 != 0) { NG(); } else { ; }


```
<Overlap Ratio: 0.9950248756218906>

---

--- 233 --
Question ID: a849a5bb14f09673817badc76f73d10acac97793_0
Original Code:
```
int get_VmRSS()
{
    char procinfo_buf[255];
    char *l;
    int rss = -1;

    rewind(procinfo_fh);

    while ((l = fgets(procinfo_buf, 254, procinfo_fh)) != NULL) {
	if (strstr(l, "VmRSS:") != NULL) {
	    l[16] = '\0';
	    l += 8;
	    rss = atoi(l);
	}
    }

    return rss;
}
```


Overlapping Code:
```

char procinfo_buf[255];
char *l;
int rss = -1;
rewind(procinfo_fh);
while ((l = fgets(procinfo_buf, 254, procinfo_fh)) != NULL) {
if (strstr(l, "VmRSS:") != NULL) {
l[16] = '\0';
l += 8;
rss = atoi(l
```
<Overlap Ratio: 0.8438818565400844>

---

--- 234 --
Question ID: c044c40bfeb766a45fce4fc17fada733269255f8_5
Original Code:
```
const char *get_tle_info(const char *tle_filename, const char *satellite)
{
    sat_t sat;
    read_tle(satellite, &sat);

    static char tle_info[256];
    sprintf(tle_info,
            "Satellite: %s\n"
            "Date: %s",
            satellite, date_str_long(time_to_secs(sat.tle.epoch_year,
                                                  sat.tle.epoch_day,
                                                  sat.tle.epoch_fod)));

    return tle_info;
}
```


Overlapping Code:
```
ame, const char *satellite)
{
sat_t sat;
read_tle(satellite, &sat);
static char tle_info[256];
sprintf(tle_info,
"Satellite: %s\n"
"Date: %s",
satellite, date_str_long(time_to_secs(sat.tle.epoch_year,
sat.tle.epoch_day,
sat.tle.epoch_fod)));
return t
```
<Overlap Ratio: 0.8169934640522876>

---

--- 235 --
Question ID: 0b5ebcf79bb7309f00386bea49c54c3585d1f10d_12
Original Code:
```
static inline uint8_t
msgpack_get_UINT8(msgpack_u *m)
{
	uint8_t x = *(uint8_t *)++m->p;
	++m->p;
	return x;
}
```


Overlapping Code:
```
tatic inline uint8_t
msgpack_get_UINT8(msgpack_u *m)
{
uint8_t x = *(uint8_t *)++m->p;
++m->p;
retur
```
<Overlap Ratio: 0.9345794392523364>

---

--- 236 --
Question ID: 643064d04fcda863d3abe77f82ddb98e1fc66f3b_14
Original Code:
```
int main(int argc, char** argv) {
    // input
    int iat, nat = 8;
    int atomic_number[8] = { 1, 6, 7, 8, 1, 6, 8, 7 };
    int atom_basis[8]    = { 0, 0, 0, 0, 1, 1, 1, 1 };
    int ibs, nsbs = 2;
    char *basis_name[] = {"STO-3G", "6-31G*" };
    // output
    int ncs, nao, nps, maxlqn;
    int *ushel_lqn, *ushel_tem, *ushel_atm;
    int *ushel_add, *ushel_ini;
    double *uprim_exp, *uprim_coe;

    printf("------------------- INPUT DATA ------------------------\n");
    printf("# of kind of basis set = %d\n", nsbs );
    printf("basis name list = ");
    for ( ibs=0; ibs<nsbs; ibs++ ) printf(" %s", basis_name[ibs] );
    printf("\n");
    printf("# of atom = %d\n", nat);
    printf("atomic_number[] =");
    for (iat=0; iat<nat; iat++ )
	printf("%s%2d", ( (iat%10)==0 ? "\n  " : " " ),
		atomic_number[iat] );
    if ( (nat%10) != 0 ) printf("\n");
    printf("atom_basis[] =");
    for (iat=0; iat<nat; iat++ )
	printf("%s%2d", ( (iat%10)==0 ? "\n  " : " " ),
		atom_basis[iat] );
    if ( (nat%10) != 0 ) printf("\n");
    printf("-------------------------------------------------------\n");

    if ( ofmo_get_basis_size(
		nat, nsbs, basis_name, atomic_number, atom_basis,
		&maxlqn, &ncs, &nao, &nps ) != 0 ) {
	dbg("error: Failure in ofmo_get_basis_size\n");
	return -1;
    }
    if ( ofmo_alloc_unsorted_basis(ncs, nps, &ushel_lqn, &ushel_tem,
		&ushel_atm, &ushel_add, &ushel_ini, &uprim_exp, &uprim_coe)
	    != 0 ) {
	dbg("error: Failure in memory allocation for unsorted basis\n");
	return -1;
    }
    if ( ofmo_assign_basis(
		nat, nsbs, basis_name, atomic_number, atom_basis,
		ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
		uprim_exp, uprim_coe ) != 0 ) {
	dbg("error: Failure in assignment basis parameters\n");
	return -1;
    }
    ofmo_show_unsorted_basis_params( stdout, ncs,
	    ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
	    uprim_exp, uprim_coe );
    int *shel_tem, *shel_atm, *shel_add, *shel_ini, *leading_cs, *s2u;
    double *prim_exp, *prim_coe;
    if ( ofmo_alloc_sorted_basis(maxlqn, ncs, nao, nps,
		&leading_cs, &shel_tem, &shel_atm, &shel_add, &shel_ini,
		&prim_exp, &prim_coe, &s2u ) != 0 ) {
	dbg("error: Failure in memory allocation for sorted basis\n");
	return -1;
    }
    if ( ofmo_sort_basis( maxlqn, ncs,
		ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
		uprim_exp, uprim_coe,
		leading_cs, shel_tem, shel_atm, shel_add, shel_ini,
		prim_exp, prim_coe, s2u ) != 0 ) {
	dbg("error: failure in sort basis parameters\n");
	return -1;
    }
    ofmo_show_sorted_basis_params( stdout, maxlqn, nao,
	    leading_cs, shel_tem, shel_atm, shel_add, shel_ini,
	    prim_exp, prim_coe, s2u );
    return 0;
}
```


Overlapping Code:
```

int iat, nat = 8;
int atomic_number[8] = { 1, 6, 7, 8, 1, 6, 8, 7 };
int atom_basis[8] = { 0, 0, 0, 0, 1, 1, 1, 1 };
int ibs, nsbs = 2;
char *basis_name[] = {"STO-3G", "6-31G*" };
// output
int ncs, nao, nps, maxlqn;
int *ushel_lqn, *ushel_tem, *ushel_atm;
int *ushel_add, *ushel_ini;
double *uprim_exp, *uprim_coe;
printf("------------------- INPUT DATA ------------------------\n");
printf("# of kind of basis set = %d\n", nsbs );
printf("basis name list = ");
for ( ibs=0; ibs<nsbs; ibs++ ) printf(" %s", basis_name[ibs] );
printf("\n");
printf("# of atom = %d\n", nat);
printf("atomic_number[] =");
for (iat=0; iat<nat; iat++ )
printf("%s%2d", ( (iat%10)==0 ? "\n " : " " ),
atomic_number[iat] );
if ( (nat%10) != 0 ) printf("\n");
printf("atom_basis[] =");
for (iat=0; iat<nat; iat++ )
printf("%s%2d", ( (iat%10)==0 ? "\n " : " " ),
atom_basis[iat] );
if ( (nat%10) != 0 ) printf("\n");
printf("-------------------------------------------------------\n");
if ( ofmo_get_basis_size(
nat, nsbs, basis_name, atomic_number, atom_basis,
&maxlqn, &ncs, &nao, &nps ) != 0 ) {
dbg("error: Failure in ofmo_get_basis_size\n");
return -1;
}
if ( ofmo_alloc_unsorted_basis(ncs, nps, &ushel_lqn, &ushel_tem,
&ushel_atm, &ushel_add, &ushel_ini, &uprim_exp, &uprim_coe)
!= 0 ) {
dbg("error: Failure in memory allocation for unsorted basis\n");
return -1;
}
if ( ofmo_assign_basis(
nat, nsbs, basis_name, atomic_number, atom_basis,
ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
uprim_exp, uprim_coe ) != 0 ) {
dbg("error: Failure in assignment basis parameters\n");
return -1;
}
ofmo_show_unsorted_basis_params( stdout, ncs,
ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
uprim_exp, uprim_coe );
int *shel_tem, *shel_atm, *shel_add, *shel_ini, *leading_cs, *s2u;
double *prim_exp, *prim_coe;
if ( ofmo_alloc_sorted_basis(maxlqn, ncs, nao, nps,
&leading_cs, &shel_tem, &shel_atm, &shel_add, &shel_ini,
&prim_exp, &prim_coe, &s2u ) != 0 ) {
dbg("error: Failure in memory allocation for sorted basis\n");
return -1;
}
if ( ofmo_sort_basis( maxlqn, ncs,
ushel_lqn, ushel_tem, ushel_atm, ushel_add, ushel_ini,
uprim_exp, uprim_coe,
leading_cs, shel_tem, shel_atm, shel_add, shel_ini,
prim_exp, prim_coe, s2u ) != 0 ) {
dbg("error: failure in sort b
```
<Overlap Ratio: 0.980819529206626>

---

--- 237 --
Question ID: 3e3fe85af3ecd6dca09b407fa96f9436d7ad418e_5
Original Code:
```
BOOL CALLBACK fnAbout( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam ) 
{
   char  szTemp [256] ;

   switch (wMsg)
   {
      case WM_INITDIALOG:

         wsprintf( szTemp, "%s %s - %s",
                   (LPSTR)rglpsz[IDS_VERSION], (LPSTR)szVerNum,
                   (LPSTR)__DATE__ ) ;
         SetDlgItemText (hDlg, IDD_VERSION, szTemp ) ;
         break ;

      case WM_COMMAND:
         switch ((WORD)wParam)
         {
            case IDOK:
            case IDCANCEL:
               EndDialog (hDlg, 0) ;
            break ;

            default :
               return FALSE ;
         }
         break ;

   }
   return FALSE ;
}
```


Overlapping Code:
```
BACK fnAbout( HWND hDlg, WORD wMsg, WPARAM wParam, LPARAM lParam ) 
{
char szTemp [256] ;
switch (wMsg)
{
case WM_INITDIALOG:
wsprintf( szTemp, "%s %s - %s",
(LPSTR)rglpsz[IDS_VERSION], (LPSTR)szVerNum,
(LPSTR)__DATE__ ) ;
SetDlgItemText (hDlg, IDD_VERSION, szTemp ) ;
break ;
case WM_COMMAND:
switch ((WORD)wParam)
{
case IDOK:
case IDCANCEL:
EndDialog (hDlg, 0) ;
break ;
default :
return FALSE ;
}
break ;
}
return
```
<Overlap Ratio: 0.9564220183486238>

---

--- 238 --
Question ID: 62ec30c92f6f1d904d30fce341741bdba799dbda_112
Original Code:
```
void f112(void) {
    	int32_t x449 = -47238040;
	int32_t x450 = INT32_MIN;
	volatile uint32_t x452 = 116179890U;
	volatile int32_t t112 = -17;

    t112 = ((x449>(x450&x451))==x452);

    if (t112 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
t x449 = -47238040;
int32_t x450 = INT32_MIN;
volatile uint32_t x452 = 116179890U;
volatile int32_t t112 = -17;
t112 = ((x449>(x450&x451))==x452);
if (t112 != 0) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8851674641148325>

---

--- 239 --
Question ID: 3f8db5415c0c625f2df0150f66ba9b2df8f1884e_93
Original Code:
```
struct Mat_t Mat_transl(const double x, const double y, const double z) {
	struct Mat_t matTemp;
	Mat_SetEye(&matTemp);
	Mat_SetPos(&matTemp, x, y, z);
	return matTemp;
}
```


Overlapping Code:
```
struct Mat_t Mat_transl(const double x, const double y, const double z) {
struct Mat_t matTemp;
Mat_SetEye(&matTemp);
Mat_SetPos(&matTemp, x, y, z);
r
```
<Overlap Ratio: 0.9036144578313253>

---

--- 240 --
Question ID: a9bea9522cdf221002ff056494da01bb2ad4aa22_9
Original Code:
```
struct dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,
		struct dentry *parent)
{
	struct dentry *dir = NULL, *info = NULL;
	char debugfs_name[MAX_DEBUGFS_NAME];
	struct core_inst_pair *idata = NULL;

	if (!inst) {
		dprintk(VIDC_ERR, "Invalid params, inst: %pK\n", inst);
		goto exit;
	}
	snprintf(debugfs_name, MAX_DEBUGFS_NAME, "inst_%p", inst);

	idata = kzalloc(sizeof(struct core_inst_pair), GFP_KERNEL);
	if (!idata) {
		dprintk(VIDC_ERR, "%s: Allocation failed!\n", __func__);
		goto exit;
	}

	idata->core = inst->core;
	idata->inst = inst;

	dir = debugfs_create_dir(debugfs_name, parent);
	if (!dir) {
		dprintk(VIDC_ERR, "Failed to create debugfs for msm_vidc\n");
		goto failed_create_dir;
	}

	info = debugfs_create_file("info", 0444, dir,
			idata, &inst_info_fops);
	if (!info) {
		dprintk(VIDC_ERR, "debugfs_create_file: fail\n");
		goto failed_create_file;
	}

	dir->d_inode->i_private = info->d_inode->i_private;
	inst->debug.pdata[FRAME_PROCESSING].sampling = true;
	return dir;

failed_create_file:
	debugfs_remove_recursive(dir);
	dir = NULL;
failed_create_dir:
	kfree(idata);
exit:
	return dir;
}
```


Overlapping Code:
```
dentry *msm_vidc_debugfs_init_inst(struct msm_vidc_inst *inst,
struct dentry *parent)
{
struct dentry *dir = NULL, *info = NULL;
char debugfs_name[MAX_DEBUGFS_NAME];
struct core_inst_pair *idata = NULL;
if (!inst) {
dprintk(VIDC_ERR, "Invalid params, inst: %pK\n", inst);
goto exit;
}
snprintf(debugfs_name, MAX_DEBUGFS_NAME, "inst_%p", inst);
idata = kzalloc(sizeof(struct core_inst_pair), GFP_KERNEL);
if (!idata) {
dprintk(VIDC_ERR, "%s: Allocation failed!\n", __func__);
goto exit;
}
idata->core = inst->core;
idata->inst = inst;
dir = debugfs_create_dir(debugfs_name, parent);
if (!dir) {
dprintk(VIDC_ERR, "Failed to create debugfs for msm_vidc\n");
goto failed_create_dir;
}
info = debugfs_create_file("info", 0444, dir,
idata, &inst_info_fops);
if (!info) {
dprintk(VIDC_ERR, "debugfs_create_file: fail\n");
goto failed_create_file;
}
dir->d_inode->i_private = info->d_inode->i_private;
inst->debug.pdata[FRAME_PROCESSING].sampling = true;
return dir;
failed_create_file:
debugfs_remove_recursive(dir);
dir = NULL;
failed_create_dir:
```
<Overlap Ratio: 0.9621072088724584>

---

--- 241 --
Question ID: ea4eb5b6bf6cab9078b7828a55cede351bb4c19c_3
Original Code:
```
NTSTATUS
IsoUsb_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine of the irp in the irp/urb pair
    passed down the stack for stream transfers.

    If the transfer was cancelled or the device yanked out, then we
    release resources, dump the statistics and return 
    STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can
    free the irp.

    otherwise, we reinitialize the transfers and continue recirculaiton 
    of the irps.

Arguments:

    DeviceObject - pointer to device object below us.
    Irp - I/O completion routine.
    Context - context passed to the completion routine

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      nextStack;
    PISOUSB_STREAM_OBJECT   streamObject;
    PISOUSB_TRANSFER_OBJECT transferObject;

    transferObject = (PISOUSB_TRANSFER_OBJECT) Context;
    streamObject = transferObject->StreamObject;
    deviceObject = streamObject->DeviceObject;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - begins\n"));

    ntStatus = IsoUsb_ProcessTransfer(transferObject);

    if((ntStatus == STATUS_CANCELLED) ||
       (ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {
    
        IsoUsb_DbgPrint(3, ("Isoch irp cancelled/device removed\n"));

        //
        // this is the last irp to complete with this erroneous value
        // signal an event and return STATUS_MORE_PROCESSING_REQUIRED
        //
        if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {

            KeSetEvent(&streamObject->NoPendingIrpEvent,
                       1,
                       FALSE);

            IsoUsb_DbgPrint(3, ("-----------------------------\n"));
        }

        IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete::"));
        IsoUsb_IoDecrement(deviceExtension);

        transferObject->Irp = NULL;
        IoFreeIrp(Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // otherwise circulate the irps.
    //

    IsoUsb_InitializeStreamUrb(deviceObject, transferObject);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = transferObject->Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                                IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(Irp,
                           IsoUsb_IsoIrp_Complete,
                           transferObject,
                           TRUE,
                           TRUE,
                           TRUE);

    transferObject->TimesRecycled++;

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - ends\n"));
    IsoUsb_DbgPrint(3, ("-----------------------------\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}
```


Overlapping Code:
```
_IsoIrp_Complete(
IN PDEVICE_OBJECT DeviceObject,
IN PIRP Irp,
IN PVOID Context
)
/*++

Routine Description:
This is the completion routine of the irp in the irp/urb pair
passed down the stack for stream transfers.
If the transfer was cancelled or the device yanked out, then we
release resources, dump the statistics and return 
STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can
free the irp.
otherwise, we reinitialize the transfers and continue recirculaiton 
of the irps.
Arguments:
DeviceObject - pointer to device object below us.
Irp - I/O completion routine.
Context - context passed to the completion routine
Return Value:
--*/
{
NTSTATUS ntStatus;
PDEVICE_OBJECT deviceObject;
PDEVICE_EXTENSION deviceExtension;
PIO_STACK_LOCATION nextStack;
PISOUSB_STREAM_OBJECT streamObject;
PISOUSB_TRANSFER_OBJECT transferObject;
transferObject = (PISOUSB_TRANSFER_OBJECT) Context;
streamObject = transferObject->StreamObject;
deviceObject = streamObject->DeviceObject;
deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - begins\n"));
ntStatus = IsoUsb_ProcessTransfer(transferObject);
if((ntStatus == STATUS_CANCELLED) ||
(ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {

IsoUsb_DbgPrint(3, ("Isoch irp cancelled/device removed\n"));
//
// this is the last irp to complete with this erroneous value
// signal an event and return STATUS_MORE_PROCESSING_REQUIRED
//
if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {
KeSetEvent(&streamObject->NoPendingIrpEvent,
1,
FALSE);
IsoUsb_DbgPrint(3, ("-----------------------------\n"));
}
IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete::"));
IsoUsb_IoDecrement(deviceExtension);
transferObject->Irp = NULL;
IoFreeIrp(Irp);
return STATUS_MORE_PROCESSING_REQUIRED;
}
//
// otherwise circulate the irps.
//
IsoUsb_InitializeStreamUrb(deviceObject, transferObject);
nextStack = IoGetNextIrpStackLocation(Irp);
nextStack->Parameters.Others.Argument1 = transfer
```
<Overlap Ratio: 0.9777117384843982>

---

--- 242 --
Question ID: 13aa3457ff24c0a178978581cd2d03d52f019076_2
Original Code:
```
void WDT_Handler(void)
 {
	 printf("Enter watchdog interrupt.\r");
	 /* Clear status bit to acknowledge interrupt by dummy read. */
	 wdt_get_status(WDT);
	 /* Restart the WDT counter. */
	 wdt_restart(WDT);
	 printf("The watchdog timer was restarted.\r");
	 g_b_systick_event = true;
 }
```


Overlapping Code:
```
watchdog interrupt.\r");
/* Clear status bit to acknowledge interrupt by dummy read. */
wdt_get_status(WDT);
/* Restart the WDT counter. */
wdt_restart(WDT);
printf("The watchdog timer was restarted.\r");
g_b_s
```
<Overlap Ratio: 0.7749077490774908>

---

--- 243 --
Question ID: 83cf860a92ffa3454a3d1708425f3a6dd77b570c_183
Original Code:
```
void f183(void) {
    	int16_t x734 = -1;
	static volatile uint64_t x736 = 0LLU;
	uint64_t t183 = 14794848565LLU;

    t183 = ((x733*(x734==x735))^x736);

    if (t183 != 0LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f183(void) {
int16_t x734 = -1;
static volatile uint64_t x736 = 0LLU;
uint64_t t183 = 14794848565LLU;
t183 = ((x733*(x734==x735))^x736);
if (t183 != 
```
<Overlap Ratio: 0.819672131147541>

---

--- 244 --
Question ID: 5e5023cdb314b16e133140cd748b2da26c5b1f5e_0
Original Code:
```
void f0(void) {
    	uint8_t x3 = 13U;
	int8_t x4 = -1;
	volatile uint32_t t0 = 31U;

    t0 = (((x1|x2)>>x3)/x4);

    if (t0 != 0U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
id) {
uint8_t x3 = 13U;
int8_t x4 = -1;
volatile uint32_t t0 = 31U;
t0 = (((x1|x2)>>x3)/x4);
if (t0 
```
<Overlap Ratio: 0.7142857142857143>

---

--- 245 --
Question ID: 0bd2e8bd98182b4d8936bfc698d3ca7ecba1c78d_63
Original Code:
```
void f63(void) {
    	int32_t x281 = INT32_MIN;
	int16_t x283 = -1;
	int16_t x284 = INT16_MAX;

    t63 = (x281==(x282-(x283%x284)));

    if (t63 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
3(void) {
int32_t x281 = INT32_MIN;
int16_t x283 = -1;
int16_t x284 = INT16_MAX;
t63 = (x281==(x282-(x283%x284)));
if (t63 != 0) { NG(); } else { ; }

```
<Overlap Ratio: 0.9433962264150944>

---

--- 246 --
Question ID: 63f36ed39e33e08503e1810e61c42129bf517b6b_2
Original Code:
```
static int mhi_arch_set_bus_request(struct mhi_controller *mhi_cntrl, int index)
{
	struct mhi_dev *mhi_dev = mhi_controller_get_devdata(mhi_cntrl);
	struct arch_info *arch_info = mhi_dev->arch_info;

	MHI_LOG("Setting bus request to index %d\n", index);

	if (arch_info->bus_client)
		return msm_bus_scale_client_update_request(
							arch_info->bus_client,
							index);

	/* default return success */
	return 0;
}
```


Overlapping Code:
```
equest(struct mhi_controller *mhi_cntrl, int index)
{
struct mhi_dev *mhi_dev = mhi_controller_get_devdata(mhi_cntrl);
struct arch_info *arch_info = mhi_dev->arch_info;
MHI_LOG("Setting bus request to index %d\n", index);
if (arch_info->bus_client)
return msm_bus_scale_client_update_request(
arch_info->bus_client,
index);
/* default return success 
```
<Overlap Ratio: 0.8905852417302799>

---

--- 247 --
Question ID: 55cb8d41d2797300c1561d13916513fa734f5b5a_176
Original Code:
```
void f176(void) {
    	volatile int64_t x705 = INT64_MAX;
	int8_t x706 = INT8_MAX;
	static uint32_t x707 = 427U;
	static uint64_t x708 = 7271LLU;
	static int32_t t176 = 152521;

    t176 = ((x705<=x706)>>(x707==x708));

    if (t176 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
volatile int64_t x705 = INT64_MAX;
int8_t x706 = INT8_MAX;
static uint32_t x707 = 427U;
static uint64_t x708 = 7271LLU;
static int32_t t176 = 152521;
t176 = ((x705<=x706)>>(x707==x708));
if (t176 != 0) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.9629629629629629>

---

--- 248 --
Question ID: 9ac859409b2ae871a73d916ba9e0b127adcddc6e_0
Original Code:
```
interface LinkChargerCC : ComponentControl <tGraphDataSource>
{
    unsigned int pmuPowerService;	// 128 = 0x80
    double _targetTimeCloaking;	// 136 = 0x88
    double _targetTimeCharging;	// 144 = 0x90
    double _defaultTargetTimeCloaking;	// 152 = 0x98
    double _defaultTargetTimeCharging;	// 160 = 0xa0
    double _targetTimeWirelessMatCloaking;	// 168 = 0xa8
    double _targetTimeWirelessMatCharging;	// 176 = 0xb0
    double _remainingTimeInterval;	// 184 = 0xb8
    double _remainingInitialNoCloakTime;	// 192 = 0xc0
    int _skipFirstChargeThreshold;	// 200 = 0xc8
    int _chargerType;	// 204 = 0xcc
    _Bool _currentlyCloaked;	// 208 = 0xd0
    _Bool _isOnCharger;	// 209 = 0xd1
    AggDThermalMonitor *_aggdController;	// 216 = 0xd8
    double _previousTimeStamp;	// 224 = 0xe0
}
```


Overlapping Code:
```
CC : ComponentControl <tGraphDataSource>
{
unsigned int pmuPowerService; // 128 = 0x80
double _targetTimeCloaking; // 136 = 0x88
double _targetTimeCharging; // 144 = 0x90
double _defaultTargetTimeCloaking; // 152 = 0x98
double _defaultTargetTimeCharging; // 160 = 0xa0
double _targetTimeWirelessMatCloaking; // 168 = 0xa8
double _targetTimeWirelessMatCharging; // 176 = 0xb0
double _remainingTimeInterval; // 184 = 0xb8
double _remainingInitialNoCloakTime; // 192 = 0xc0
int _skipFirstChargeThreshold; // 200 = 0xc8
int _chargerType; // 204 = 0xcc
_Bool _currentlyCloaked; // 208 = 0xd0
_Bool _isOnCharger; // 209 = 0xd1
AggDThermalMonitor *_aggdController; // 216 = 0xd8
d
```
<Overlap Ratio: 0.9156462585034013>

---

--- 249 --
Question ID: a9adc5016e99008c315407c66ec6c9e44808d396_176
Original Code:
```
void f176(void) {
    	int64_t x789 = 6798025LL;
	int16_t x790 = INT16_MIN;
	int8_t x791 = -28;
	uint64_t x792 = 3351480416874751LLU;

    t176 = (((x789+x790)>x791)==x792);

    if (t176 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void f176(void) {
int64_t x789 = 6798025LL;
int16_t x790 = INT16_MIN;
int8_t x791 = -28;
uint64_t x792 = 3351480416874751LLU;
t176 = (((x789+x790)>x79
```
<Overlap Ratio: 0.7537688442211056>

---

--- 250 --
Question ID: 2455756242f54d5032a2691aa6fc1b9a94ef8d0f_3
Original Code:
```
XrResult
oxr_space_ref_relation(struct oxr_logger *log,
                       struct oxr_session *sess,
                       XrReferenceSpaceType space,
                       XrReferenceSpaceType baseSpc,
                       XrTime time,
                       struct xrt_space_relation *out_relation)
{
	// Treat stage space as the local space.
	if (space == XR_REFERENCE_SPACE_TYPE_STAGE) {
		space = XR_REFERENCE_SPACE_TYPE_LOCAL;
	}

	// Treat stage space as the local space.
	if (baseSpc == XR_REFERENCE_SPACE_TYPE_STAGE) {
		baseSpc = XR_REFERENCE_SPACE_TYPE_LOCAL;
	}

	math_relation_reset(out_relation);

	if (space == XR_REFERENCE_SPACE_TYPE_VIEW &&
	    baseSpc == XR_REFERENCE_SPACE_TYPE_LOCAL) {
		oxr_session_get_view_pose_at(log, sess, time,
		                             &out_relation->pose);

		out_relation->relation_flags = (enum xrt_space_relation_flags)(
		    XRT_SPACE_RELATION_POSITION_VALID_BIT |
		    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |
		    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |
		    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);

	} else if (space == XR_REFERENCE_SPACE_TYPE_LOCAL &&
	           baseSpc == XR_REFERENCE_SPACE_TYPE_VIEW) {
		oxr_session_get_view_pose_at(log, sess, time,
		                             &out_relation->pose);
		math_pose_invert(&out_relation->pose, &out_relation->pose);

		out_relation->relation_flags = (enum xrt_space_relation_flags)(
		    XRT_SPACE_RELATION_POSITION_VALID_BIT |
		    XRT_SPACE_RELATION_POSITION_TRACKED_BIT |
		    XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |
		    XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);

	} else if (space == baseSpc) {
		// math_relation_reset() sets to identity.

	} else {
		out_relation->relation_flags = XRT_SPACE_RELATION_BITMASK_NONE;
		return XR_SUCCESS;
	}

	return XR_SUCCESS;
}
```


Overlapping Code:
```
sult
oxr_space_ref_relation(struct oxr_logger *log,
struct oxr_session *sess,
XrReferenceSpaceType space,
XrReferenceSpaceType baseSpc,
XrTime time,
struct xrt_space_relation *out_relation)
{
// Treat stage space as the local space.
if (space == XR_REFERENCE_SPACE_TYPE_STAGE) {
space = XR_REFERENCE_SPACE_TYPE_LOCAL;
}
// Treat stage space as the local space.
if (baseSpc == XR_REFERENCE_SPACE_TYPE_STAGE) {
baseSpc = XR_REFERENCE_SPACE_TYPE_LOCAL;
}
math_relation_reset(out_relation);
if (space == XR_REFERENCE_SPACE_TYPE_VIEW &&
baseSpc == XR_REFERENCE_SPACE_TYPE_LOCAL) {
oxr_session_get_view_pose_at(log, sess, time,
&out_relation->pose);
out_relation->relation_flags = (enum xrt_space_relation_flags)(
XRT_SPACE_RELATION_POSITION_VALID_BIT |
XRT_SPACE_RELATION_POSITION_TRACKED_BIT |
XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |
XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);
} else if (space == XR_REFERENCE_SPACE_TYPE_LOCAL &&
baseSpc == XR_REFERENCE_SPACE_TYPE_VIEW) {
oxr_session_get_view_pose_at(log, sess, time,
&out_relation->pose);
math_pose_invert(&out_relation->pose, &out_relation->pose);
out_relation->relation_flags = (enum xrt_space_relation_flags)(
XRT_SPACE_RELATION_POSITION_VALID_BIT |
XRT_SPACE_RELATION_POSITION_TRACKED_BIT |
XRT_SPACE_RELATION_ORIENTATION_VALID_BIT |
XRT_SPACE_RELATION_ORIENTATION_TRACKED_BIT);
} else if (space == baseSpc) {
// math_relation_reset() sets to identity.
} else {
out_relation->relation_flags = XRT_SPACE_RELATION_BITMASK_NONE;
return XR_SUCCESS;
```
<Overlap Ratio: 0.9823298429319371>

---

--- 251 --
Question ID: 190cfedd460e25657c7f806f0b11cceffb3daba4_158
Original Code:
```
void f158(void) {
    	int8_t x742 = INT8_MIN;
	int64_t x743 = 191373816114459836LL;
	int8_t x744 = INT8_MAX;
	volatile int32_t t158 = 17115;

    t158 = (x741>((x742-x743)/x744));

    if (t158 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
MIN;
int64_t x743 = 191373816114459836LL;
int8_t x744 = INT8_MAX;
volatile int32_t t158 = 17115;
t158 = (x741>((x742-x743)/x744));
if (t158 != 1) { NG
```
<Overlap Ratio: 0.7281553398058253>

---

--- 252 --
Question ID: 0d487ba257d795ee1fbb663515bea5ca4c82656e_0
Original Code:
```
interface HMDCentralMessageDispatcher : HMFMessageDispatcher {

	HMDMessageFilterChain* _messageFilterChain;
	HMDAdminEnforcementMessageFilter* _adminMsgFilter;
	HMFMessageDispatcher* _recvDispatcher;
	NSMutableDictionary* _remoteGateways;
	HMDSecureRemoteMessageFilter* _secureRemoteMessageFilter;
	HMFMessageDispatcher* _notificationDispatcher;
	HMDHomeManager* _homeManager;
	NSMutableArray* _relayedMessages;

}
```


Overlapping Code:
```
ntralMessageDispatcher : HMFMessageDispatcher {
HMDMessageFilterChain* _messageFilterChain;
HMDAdminEnforcementMessageFilter* _adminMsgFilter;
HMFMessageDispatcher* _recvDispatcher;
NSMutableDictionary* _remoteGateways;
HMDSecureRemoteMessageFilter* _secureRemoteMessageFilter;
HMFMessageDispatcher* _notificationDispatcher;
HMDHomeManager* _homeManager;
NSMutab
```
<Overlap Ratio: 0.8938271604938272>

---

--- 253 --
Question ID: b8c4244af7bfcdb44dc37b8e4eaa4972b177f904_110
Original Code:
```
void f110(void) {
    	volatile uint8_t x442 = UINT8_MAX;
	int16_t x443 = -1;
	int32_t x444 = INT32_MAX;
	uint64_t t110 = 17514639058404LLU;

    t110 = ((x441|x442)|(x443==x444));

    if (t110 != 493039916173690111LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f110(void) {
volatile uint8_t x442 = UINT8_MAX;
int16_t x443 = -1;
int32_t x444 = INT32_MAX;
uint64_t t110 = 17514639058404LLU;
t110 = ((x441|x442)|(x443==x444));
if (t110 != 49
```
<Overlap Ratio: 0.8008849557522124>

---

--- 254 --
Question ID: 48673116e7c77ea2910ad80a549d0f0f8c20c299_0
Original Code:
```
void * alloc_matrix(
    int m, int n, size_t elemsize, size_t *ld)
{
    *ld = divceil(m, 64/elemsize)*(64/elemsize);
    void *ptr;
#ifdef STARNEIG_ENABLE_CUDA
    if (pinning)
        cudaHostAlloc(&ptr, n*(*ld)*elemsize, cudaHostRegisterPortable);
    else
        ptr = aligned_alloc(64, n*(*ld)*elemsize);
#else
    ptr = aligned_alloc(64, n*(*ld)*elemsize);
#endif
    return ptr;
}
```


Overlapping Code:
```
_matrix(
int m, int n, size_t elemsize, size_t *ld)
{
*ld = divceil(m, 64/elemsize)*(64/elemsize);
void *ptr;
#ifdef STARNEIG_ENABLE_CUDA
if (pinning)
cudaHostAlloc(&ptr, n*(*ld)*elemsize, cudaHostRegisterPortable);
else
ptr = aligned_alloc(64, n*(*ld)*elemsize);
#else
ptr = aligned_alloc(64, n*(*ld)*
```
<Overlap Ratio: 0.8753623188405797>

---

--- 255 --
Question ID: 3c0d6f29140e92193dffb1b517eaca6b8017d1e3_0
Original Code:
```
libnet_ptag_t
libnet_build_ethernet(u_int8_t *dst, u_int8_t *src, u_int16_t type, 
u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
{
    u_int32_t n, h;
    libnet_pblock_t *p;
    struct libnet_ethernet_hdr eth_hdr;

    if (l == NULL)
    { 
        return (-1);
    } 

    /* sanity check injection type if we're not in advanced mode */
    if (l->injection_type != LIBNET_LINK &&
            !(((l->injection_type) & LIBNET_ADV_MASK)))
    {
         snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,
            "%s(): called with non-link layer wire injection primitive",
                    __func__);
        p = NULL;
        goto bad;
    }

    n = LIBNET_ETH_H + payload_s;
    h = 0;
 
    /*
     *  Find the existing protocol block if a ptag is specified, or create
     *  a new one.
     */
    p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_ETH_H);
    if (p == NULL)
    {
        return (-1);
    }

    memset(&eth_hdr, 0, sizeof(eth_hdr));
    memcpy(eth_hdr.ether_dhost, dst, ETHER_ADDR_LEN);  /* destination address */
    memcpy(eth_hdr.ether_shost, src, ETHER_ADDR_LEN);  /* source address */
    eth_hdr.ether_type = htons(type);                  /* packet type */

    n = libnet_pblock_append(l, p, (u_int8_t *)&eth_hdr, LIBNET_ETH_H);
    if (n == -1)
    {
        goto bad;
    }

    /* boilerplate payload sanity check / append macro */
    LIBNET_DO_PAYLOAD(l, p);
 
    return (ptag ? ptag : libnet_pblock_update(l, p, h, LIBNET_PBLOCK_ETH_H));
bad:
    libnet_pblock_delete(l, p);
    return (-1);
}
```


Overlapping Code:
```
tag_t
libnet_build_ethernet(u_int8_t *dst, u_int8_t *src, u_int16_t type, 
u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)
{
u_int32_t n, h;
libnet_pblock_t *p;
struct libnet_ethernet_hdr eth_hdr;
if (l == NULL)
{ 
return (-1);
} 
/* sanity check injection type if we're not in advanced mode */
if (l->injection_type != LIBNET_LINK &&
!(((l->injection_type) & LIBNET_ADV_MASK)))
{
snprintf(l->err_buf, LIBNET_ERRBUF_SIZE,
"%s(): called with non-link layer wire injection primitive",
__func__);
p = NULL;
goto bad;
}
n = LIBNET_ETH_H + payload_s;
h = 0;

/*
* Find the existing protocol block if a ptag is specified, or create
* a new one.
*/
p = libnet_pblock_probe(l, ptag, n, LIBNET_PBLOCK_ETH_H);
if (p == NULL)
{
return (-1);
}
memset(&eth_hdr, 0, sizeof(eth_hdr));
memcpy(eth_hdr.ether_dhost, dst, ETHER_ADDR_LEN); /* destination address */
memcpy(eth_hdr.ether_shost, src, ETHER_ADDR_LEN); /* source address */
eth_hdr.ether_type = htons(type); /* packet type */
n = libnet_pblock_append(l, p, (u_int8_t *)&eth_hdr, LIBNET_ETH_H);
if (n == -1)
{
goto bad;
}
/* boilerplate payload sanity check / append macro */
LIBNET_DO_PAYLOAD(l, p);

return (ptag ? ptag : libnet_pblock_update(l, p, h, LIBNET_PBLOCK_ETH_H));
bad:
libnet_pblock_delete(l, p);
return (-1);
}
```
<Overlap Ratio: 0.993841416474211>

---

--- 256 --
Question ID: 838ec3b80c3d5772f611b184063e2f3a6e0f92b6_177
Original Code:
```
void f177(void) {
    	int64_t x1369 = -1LL;
	int8_t x1370 = -1;
	int16_t x1371 = INT16_MIN;
	volatile uint64_t x1372 = UINT64_MAX;
	static int32_t t177 = -168839919;

    t177 = ((x1369==x1370)%(x1371<=x1372));

    if (t177 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f177(void) {
int64_t x1369 = -1LL;
int8_t x1370 = -1;
int16_t x1371 = INT16_MIN;
volatile uint64_t x1372 = UINT64_MAX;
static int32_t t177 = -168839919;
t177 = ((x1369==x1370)%(x1371<=x1372));
if 
```
<Overlap Ratio: 0.847457627118644>

---

--- 257 --
Question ID: 4de480d5486cbb2d0ee75b5b031842fb17a3e971_5
Original Code:
```
DWORD
DmSetValue(
    IN HDMKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD dwType,
    IN CONST BYTE *lpData,
    IN DWORD cbData
    )

/*++

Routine Description:

    This routine sets the named value for the specified
    cluster registry key.

Arguments:

    hKey - Supplies the cluster registry subkey whose value is to be set

    lpValueName - Supplies the name of the value to be set.

    dwType - Supplies the value data type

    lpData - Supplies a pointer to the value data

    cbData - Supplies the length of the value data.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{

    DWORD Status= ERROR_SUCCESS;        //initialize to success
    PDMKEY Key;
    DWORD NameLength;
    DWORD ValueNameLength;
    DWORD UpdateLength;
    PDM_SET_VALUE_UPDATE Update;
    PUCHAR Dest;


    Key = (PDMKEY)hKey;

    if (ISKEYDELETED(Key))
        return(ERROR_KEY_DELETED);

    //
    // round lengths such that pointers to the data trailing the structure are
    // aligned on the architecture's natural boundary
    //
    NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
    NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));

    ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
    ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));

    UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
                   NameLength +
                   ValueNameLength +
                   cbData;


    Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
    if (Update == NULL) {
        CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }


    Update->lpStatus = &Status;
    Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
    Update->DataOffset = Update->NameOffset + ValueNameLength;
    Update->DataLength = cbData;
    Update->Type = dwType;
    CopyMemory(Update->KeyName, Key->Name, NameLength);

    Dest = (PUCHAR)Update + Update->NameOffset;
    CopyMemory(Dest, lpValueName, ValueNameLength);

    Dest = (PUCHAR)Update + Update->DataOffset;
    CopyMemory(Dest, lpData, cbData);

    Status = GumSendUpdate(GumUpdateRegistry,
                  DmUpdateSetValue,
                  UpdateLength,
                  Update);


    LocalFree(Update);

    return(Status);

}
```


Overlapping Code:
```
etValue(
IN HDMKEY hKey,
IN LPCWSTR lpValueName,
IN DWORD dwType,
IN CONST BYTE *lpData,
IN DWORD cbData
)
/*++
Routine Description:
This routine sets the named value for the specified
cluster registry key.
Arguments:
hKey - Supplies the cluster registry subkey whose value is to be set
lpValueName - Supplies the name of the value to be set.
dwType - Supplies the value data type
lpData - Supplies a pointer to the value data
cbData - Supplies the length of the value data.
Return Value:
ERROR_SUCCESS if successful
Win32 error code otherwise
--*/
{
DWORD Status= ERROR_SUCCESS; //initialize to success
PDMKEY Key;
DWORD NameLength;
DWORD ValueNameLength;
DWORD UpdateLength;
PDM_SET_VALUE_UPDATE Update;
PUCHAR Dest;
Key = (PDMKEY)hKey;
if (ISKEYDELETED(Key))
return(ERROR_KEY_DELETED);
//
// round lengths such that pointers to the data trailing the structure are
// aligned on the architecture's natural boundary
//
NameLength = (lstrlenW(Key->Name)+1)*sizeof(WCHAR);
NameLength = ROUND_UP_COUNT( NameLength, sizeof( DWORD_PTR ));
ValueNameLength = (lstrlenW(lpValueName)+1)*sizeof(WCHAR);
ValueNameLength = ROUND_UP_COUNT( ValueNameLength, sizeof( DWORD_PTR ));
UpdateLength = sizeof(DM_SET_VALUE_UPDATE) +
NameLength +
ValueNameLength +
cbData;
Update = (PDM_SET_VALUE_UPDATE)LocalAlloc(LMEM_FIXED, UpdateLength);
if (Update == NULL) {
CL_UNEXPECTED_ERROR(ERROR_NOT_ENOUGH_MEMORY);
return(ERROR_NOT_ENOUGH_MEMORY);
}
Update->lpStatus = &Status;
Update->NameOffset = FIELD_OFFSET(DM_SET_VALUE_UPDATE, KeyName)+NameLength;
Update->DataOffset = Update->NameOffset + ValueNameLength;
Update->DataLength = cbData;
Update->Type = dwType;
CopyMemory(Update->KeyName, Key->Name, NameLength);
Dest = (PUCHAR)Update + Update->NameOffset;
CopyMemory(Dest, lpValueName, ValueNameLength);
Dest = (PUCHAR)Update + Update->DataOffset;
CopyMemory(Dest, lpData, cbData);
Status = GumSendUpdate(GumUpdateRegistry,
DmUpdateSetValue,
UpdateLength,
Update);
LocalFree(Update);
return(
```
<Overlap Ratio: 0.9904426559356136>

---

--- 258 --
Question ID: bde5180f70e7ad6ff0a98a6f9e3d62f505f3462c_33
Original Code:
```
void f33(void) {
    	uint16_t x149 = 2U;
	int8_t x150 = INT8_MIN;
	volatile int16_t x151 = INT16_MAX;
	int16_t x152 = INT16_MIN;
	int32_t t33 = -1365658;

    t33 = ((x149/x150)/(x151^x152));

    if (t33 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
f33(void) {
uint16_t x149 = 2U;
int8_t x150 = INT8_MIN;
volatile int16_t x151 = INT16_MAX;
int16_t x152 = INT16_MIN;
int32_t t33 = -1365658;
t33 = ((x149/x150)/(x151^x152));
if (t33 != 0) { NG(); } else
```
<Overlap Ratio: 0.9351851851851852>

---

--- 259 --
Question ID: 8e4ff03533d6ae23e6a41c43956fb1474045ccaa_3
Original Code:
```
uint32_t r_strcat(void) {
	char* arg1 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 1,2));
	char* arg2 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 2,2));
	strcat(arg2, arg1);
	return 0;
}
```


Overlapping Code:
```
 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 1,2));
char* arg2 = (char*)GetLinearAddress(CPU, GetArgument(CPU, 2,2));
strcat(arg2, arg1);
return 0
```
<Overlap Ratio: 0.7936507936507936>

---

--- 260 --
Question ID: 40f88bc2041db88ee4bccc6c7f9ccc2f134a62fb_9
Original Code:
```
uint32_t
validate_jwt(
    PJWT pJWT,
    PJWT_ERROR *ppError
    )
{
    uint32_t dwError = 0;
    time_t dwTime = 0;
    char *pszLWAdminGroup = NULL;
    PJWT_ERROR pError = NULL;

    if(!pJWT)
    {
        dwError = ERROR_PMD_INVALID_PARAMETER;
        BAIL_ON_PMD_ERROR(dwError);
    }

    dwError = PMDAllocateMemory(sizeof(JWT_ERROR), (void **)&pError);
    BAIL_ON_PMD_ERROR(dwError);

//flag to do quick tests with token reuse.
#ifndef PMD_TIME_INSENSITIVE
    //validate expiry date
    dwTime = time(NULL);
    if(dwTime > pJWT->pClaims->dwExpiry)
    {
        pError->nStatus= HTTP_FORBIDDEN;
        dwError = PMDAllocateStringPrintf(
                      &pError->pszError,
                      "Token expired.");
        BAIL_ON_PMD_ERROR(dwError);

        dwError = ERROR_PMD_INVALID_PARAMETER;
        BAIL_ON_PMD_ERROR(dwError);
    }
    //issued at must not be in the future
    if(dwTime > pJWT->pClaims->dwIssuedAt)
    {
        pError->nStatus = HTTP_FORBIDDEN;
        dwError = PMDAllocateStringPrintf(
                      &pError->pszError,
                      "Token issued at date is in the future.");
        BAIL_ON_PMD_ERROR(dwError);

        dwError = ERROR_PMD_INVALID_PARAMETER;
        BAIL_ON_PMD_ERROR(dwError);
    }
#endif

    //this server should be in audience
    dwError = find_in_array(pJWT->pClaims->pAudienceArray->ppszValues,
                     pJWT->pClaims->pAudienceArray->nCount,
                     JAVELIN_OAUTH_AUD);
    if(dwError == ENOENT)
    {
        pError->nStatus = HTTP_FORBIDDEN;
        dwError = PMDAllocateStringPrintf(
                      &pError->pszError,
                      "Audience does not have expected entries.");
        BAIL_ON_PMD_ERROR(dwError);

        dwError = ERROR_PMD_INVALID_PARAMETER;
    }
    BAIL_ON_PMD_ERROR(dwError);
    //must be in administrators group
    dwError = PMDAllocateStringPrintf(&pszLWAdminGroup,
                                      "%s\\%s",
                                      pJWT->pClaims->pszTenant,
                                      LW_ADMIN_GROUP_NAME);
    BAIL_ON_PMD_ERROR(dwError);
    dwError = find_in_array(pJWT->pClaims->pGroupsArray->ppszValues,
                     pJWT->pClaims->pGroupsArray->nCount,
                     pszLWAdminGroup);
    if(dwError == ENOENT)
    {
        pError->nStatus = HTTP_FORBIDDEN;
        dwError = PMDAllocateStringPrintf(
                      &pError->pszError,
                      "Not an administrators group member.");
        BAIL_ON_PMD_ERROR(dwError);

        dwError = ERROR_PMD_INVALID_PARAMETER;
    }
    BAIL_ON_PMD_ERROR(dwError);


cleanup:
    free_jwt_error(pError);
    PMD_SAFE_FREE_MEMORY(pszLWAdminGroup);
    return dwError;

error:
    if(ppError)
    {
        *ppError = pError;
        pError = NULL;
    }
    goto cleanup;
}
```


Overlapping Code:
```
 *ppError
)
{
uint32_t dwError = 0;
time_t dwTime = 0;
char *pszLWAdminGroup = NULL;
PJWT_ERROR pError = NULL;
if(!pJWT)
{
dwError = ERROR_PMD_INVALID_PARAMETER;
BAIL_ON_PMD_ERROR(dwError);
}
dwError = PMDAllocateMemory(sizeof(JWT_ERROR), (void **)&pError);
BAIL_ON_PMD_ERROR(dwError);
//flag to do quick tests with token reuse.
#ifndef PMD_TIME_INSENSITIVE
//validate expiry date
dwTime = time(NULL);
if(dwTime > pJWT->pClaims->dwExpiry)
{
pError->nStatus= HTTP_FORBIDDEN;
dwError = PMDAllocateStringPrintf(
&pError->pszError,
"Token expired.");
BAIL_ON_PMD_ERROR(dwError);
dwError = ERROR_PMD_INVALID_PARAMETER;
BAIL_ON_PMD_ERROR(dwError);
}
//issued at must not be in the future
if(dwTime > pJWT->pClaims->dwIssuedAt)
{
pError->nStatus = HTTP_FORBIDDEN;
dwError = PMDAllocateStringPrintf(
&pError->pszError,
"Token issued at date is in the future.");
BAIL_ON_PMD_ERROR(dwError);
dwError = ERROR_PMD_INVALID_PARAMETER;
BAIL_ON_PMD_ERROR(dwError);
}
#endif
//this server should be in audience
dwError = find_in_array(pJWT->pClaims->pAudienceArray->ppszValues,
pJWT->pClaims->pAudienceArray->nCount,
JAVELIN_OAUTH_AUD);
if(dwError == ENOENT)
{
pError->nStatus = HTTP_FORBIDDEN;
dwError = PMDAllocateStringPrintf(
&pError->pszError,
"Audience does not have expected entries.");
BAIL_ON_PMD_ERROR(dwError);
dwError = ERROR_PMD_INVALID_PARAMETER;
}
BAIL_ON_PMD_ERROR(dwError);
//must be in administrators group
dwError = PMDAllocateStringPrintf(&pszLWAdminGroup,
"%s\\%s",
pJWT->pClaims->pszTenant,
LW_ADMIN_GROUP_NAME);
BAIL_ON_PMD_ERROR(dwError);
dwError = find_in_array(pJWT->pClaims->pGroupsArray->ppszValues,
pJWT->pClaims->pGroupsArray->nCount,
pszLWAdminGroup);
if(dwError == ENOENT)
{
pError->nStatus = HTTP_FORBIDDEN;
dwError = PMDAllocateStringPrintf(
&pError-
```
<Overlap Ratio: 0.9592833876221498>

---

--- 261 --
Question ID: 4bf8f8c6f86b0a0b04f191d42e59e8a9adcf2bcb_0
Original Code:
```
char *neigh_strdup(const char *src) {
    char *dst = NULL;

    if (src != NULL) {
        size_t length = strlen(src);

        dst = malloc(length + 1);

        if (dst != NULL) {
            strcpy(dst, src);
        }
    }

    return dst;
}
```


Overlapping Code:
```
nst char *src) {
char *dst = NULL;
if (src != NULL) {
size_t length = strlen(src);
dst = malloc(length + 1);
if (dst != NULL) {
strcpy(dst, src);
}
}

```
<Overlap Ratio: 0.8152173913043478>

---

--- 262 --
Question ID: ae9859e0e72db0fbad569a9c9acafad091e649c0_187
Original Code:
```
void f187(void) {
    	int32_t x785 = -467568;
	uint8_t x786 = 28U;
	static int64_t x787 = INT64_MAX;
	int64_t x788 = -1LL;
	int64_t t187 = 13750736887277LL;

    t187 = (x785%(x786|(x787%x788)));

    if (t187 != -24LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x785 = -467568;
uint8_t x786 = 28U;
static int64_t x787 = INT64_MAX;
int64_t x788 = -1LL;
int64_t t187 = 13750736887277LL;
t187 = (x785%(x786|(x787%x788)));
if (t187 != -24LL) { NG(); } else {
```
<Overlap Ratio: 0.8888888888888888>

---

--- 263 --
Question ID: 838ec3b80c3d5772f611b184063e2f3a6e0f92b6_150
Original Code:
```
void f150(void) {
    	int32_t x1186 = -1;
	volatile int16_t x1187 = -2;

    t150 = ((x1185==x1186)%(x1187<=x1188));

    if (t150 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
50(void) {
int32_t x1186 = -1;
volatile int16_t x1187 = -2;
t150 = ((x1185==x1186)%(x1187<=x1188));

```
<Overlap Ratio: 0.6896551724137931>

---

--- 264 --
Question ID: be1171e30e96695f959cb06727516c2e6effca2a_0
Original Code:
```
static int Flush(lua_State *L)
    {
    cl_queue queue = checkqueue(L, 1, NULL);
    cl_int ec = cl.Flush(queue);
    CheckError(L, ec);
    return 0;
    }
```


Overlapping Code:
```
e *L)
{
cl_queue queue = checkqueue(L, 1, NULL);
cl_int ec = cl.Flush(queue);
CheckError(L, ec);
ret
```
<Overlap Ratio: 0.7518796992481203>

---

--- 265 --
Question ID: 0083de05ce6030c3589f1277b395907b8cc8bc4a_34
Original Code:
```
void f34(void) {
    	int8_t x137 = -50;
	volatile uint32_t x138 = 8045658U;
	int16_t x139 = -3;
	volatile int32_t x140 = -1;
	volatile uint32_t t34 = 1005U;

    t34 = (x137|(x138&(x139>x140)));

    if (t34 != 4294967246U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
;
volatile uint32_t x138 = 8045658U;
int16_t x139 = -3;
volatile int32_t x140 = -1;
volatile uint32_t t34 = 1005U;
t34 = (x137|(x138&(x139>x140)));
if
```
<Overlap Ratio: 0.6550218340611353>

---

--- 266 --
Question ID: aa8096589ced8926ff3e52e85256aa5587c4a477_128
Original Code:
```
void f128(void) {
    	uint16_t x2729 = UINT16_MAX;
	uint16_t x2730 = UINT16_MAX;
	static uint8_t x2731 = 5U;
	int8_t x2732 = -3;
	volatile int32_t t128 = -54612815;

    t128 = ((x2729<<(x2730%x2731))==x2732);

    if (t128 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
16_t x2729 = UINT16_MAX;
uint16_t x2730 = UINT16_MAX;
static uint8_t x2731 = 5U;
int8_t x2732 = -3;
volatile int32_t t128 = -54612815;
t128 = ((x2729<<(x2730%x2731))==x2732);
if (t128 != 0) { NG(); } 
```
<Overlap Ratio: 0.851063829787234>

---

--- 267 --
Question ID: 275a9987f4d51217f727cce21cac126d2cdee6b8_48
Original Code:
```
void f48(void) {
    	static int32_t x233 = INT32_MIN;
	static uint8_t x235 = 1U;
	int32_t t48 = 7029094;

    t48 = (x233!=((x234!=x235)-x236));

    if (t48 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
static int32_t x233 = INT32_MIN;
static uint8_t x235 = 1U;
int32_t t48 = 7029094;
t48 = (x233!=((x234!=x235)-x236));
if (t48 != 1) { NG(); } else { ; 
```
<Overlap Ratio: 0.8771929824561403>

---

--- 268 --
Question ID: 654b30b483b87d4b0ff12bcaca24f9dff393fc5b_322
Original Code:
```
void NetSendCmd__FUcUc(unsigned char bHiPri, unsigned char bCmd) {
	// address: 0xFFFFFFF0
	// size: 0x1
	auto struct TCmd cmd;
}
```


Overlapping Code:
```
oid NetSendCmd__FUcUc(unsigned char bHiPri, unsigned char bCmd) {
// address: 0xFFFFFFF0
// size: 0x1
auto struct TCmd cmd;

```
<Overlap Ratio: 0.9841269841269841>

---

--- 269 --
Question ID: bc9d0eda795251ad05e3734e3fcd0d720df0ccc9_3
Original Code:
```
static void MX_USART1_UART_Init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
    huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT|UART_ADVFEATURE_DMADISABLEONERROR_INIT;
    huart1.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
    huart1.AdvancedInit.DMADisableonRxError = UART_ADVFEATURE_DMA_DISABLEONRXERROR;

    if (HAL_UART_Init(&huart1) != HAL_OK) {
        Error_Handler();
    }
}
```


Overlapping Code:
```
static void MX_USART1_UART_Init(void)
{
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT|UART_ADVFEATURE_DMADISABLEONERROR_INIT;
huart1.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
huart1.AdvancedInit.DMADisableonRxError = UART_ADVFEATURE_DMA_DISABLEONRXERROR;
if (HAL_UART_Init(&huart1) != HAL_OK) {
Error_Handler();

```
<Overlap Ratio: 0.9959128065395095>

---

--- 270 --
Question ID: 434a171f2f7d3fe4293bd9c865b635ce67dbf438_5
Original Code:
```
static void destroy(Actor* _actor) {
  PlayerData* data = (PlayerData*)getActorData(_actor);

  SPR_releaseSprite(data->sprite);
  free(data);
}
```


Overlapping Code:
```
ctor* _actor) {
PlayerData* data = (PlayerData*)getActorData(_actor);
SPR_releaseSprite(data->sprite);
free(data);
}
```
<Overlap Ratio: 0.8467153284671532>

---

--- 271 --
Question ID: 9292252b4a76ba14305ba252856b3715acb46019_1
Original Code:
```
static VSTRING *make_822_quoted_string(VSTRING *dst, const char *local_part,
				               const char *end, int flags)
{
    const char *cp;
    int     ch;

    /*
     * Put quotes around the result, and prepend a backslash to characters
     * that need quoting when they occur in a quoted-string.
     */
    VSTRING_ADDCH(dst, '"');
    for (cp = local_part; cp < end && (ch = *(unsigned char *) cp) != 0; cp++) {
	if ((ch > 127 && !(flags & QUOTE_FLAG_8BITCLEAN))
	    || ch == '"' || ch == '\\' || ch == '\r')
	    VSTRING_ADDCH(dst, '\\');
	VSTRING_ADDCH(dst, ch);
    }
    VSTRING_ADDCH(dst, '"');
    return (dst);
}
```


Overlapping Code:
```
822_quoted_string(VSTRING *dst, const char *local_part,
const char *end, int flags)
{
const char *cp;
int ch;
/*
* Put quotes around the result, and prepend a backslash to characters
* that need quoting when they occur in a quoted-string.
*/
VSTRING_ADDCH(dst, '"');
for (cp = local_part; cp < end && (ch = *(unsigned char *) cp) != 0; cp++) {
if ((ch > 127 && !(flags & QUOTE_FLAG_8BITCLEAN))
|| ch == '"' || ch == '\\' || ch == '\r')
VSTRING_ADDCH(dst, '\\');
VSTRING_ADDCH(dst, ch);
}
VSTRING_ADDC
```
<Overlap Ratio: 0.9107468123861566>

---

--- 272 --
Question ID: 68f2dde6ea755195ed267c4e99875933248e1028_45
Original Code:
```
void f45(void) {
    	volatile int8_t x193 = INT8_MAX;
	static int16_t x194 = INT16_MIN;
	uint32_t x195 = UINT32_MAX;
	int16_t x196 = -1;
	volatile int32_t t45 = 207705838;

    t45 = (((x193|x194)==x195)-x196);

    if (t45 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
volatile int8_t x193 = INT8_MAX;
static int16_t x194 = INT16_MIN;
uint32_t x195 = UINT32_MAX;
int16_t x196 = -1;
volatile int32_t t45 = 207705838;
t45 = (((x193|x194)==x195)-x196);
if (t45 != 
```
<Overlap Ratio: 0.851063829787234>

---

--- 273 --
Question ID: 9a506ed1e55abb2dfa812f72580f371e758afec2_24
Original Code:
```
static unsigned int
tic6x_try_encode (tic6x_opcode_id id, tic6x_operand *operands,
		  unsigned int num_operands, unsigned int this_line_creg,
		  unsigned int this_line_z, unsigned int func_unit_side,
		  unsigned int func_unit_cross,
		  unsigned int func_unit_data_side, int sploop_ii,
		  expressionS **fix_exp, int *fix_pcrel,
		  bfd_reloc_code_real_type *fx_r_type, bfd_boolean *fix_adda,
		  bfd_boolean *fix_needed, bfd_boolean *ok,
		  bfd_boolean print_errors, char *str, int opc_len)
{
  const tic6x_opcode *opct;
  const tic6x_insn_format *fmt;
  unsigned int opcode_value;
  unsigned int fld;

  opct = &tic6x_opcode_table[id];
  fmt = &tic6x_insn_format_table[opct->format];
  opcode_value = fmt->cst_bits;

  for (fld = 0; fld < opct->num_fixed_fields; fld++)
    {
      if (opct->fixed_fields[fld].min_val == opct->fixed_fields[fld].max_val)
	{
	  const tic6x_insn_field *fldd;
	  fldd = tic6x_field_from_fmt (fmt, opct->fixed_fields[fld].field_id);
	  if (fldd == NULL)
	    abort ();
	  opcode_value |= opct->fixed_fields[fld].min_val << fldd->bitfields[0].low_pos;
	}
    }

  for (fld = 0; fld < opct->num_variable_fields; fld++)
    {
      const tic6x_insn_field *fldd;
      unsigned int value;
      unsigned int opno;
      unsigned int ffld;
      offsetT sign_value;
      unsigned int bits;
      unsigned int fcyc_bits;
      expressionS *expp;
      expressionS ucexp;
      tic6x_mem_ref mem;

      fldd = tic6x_field_from_fmt (fmt, opct->variable_fields[fld].field_id);
      if (fldd == NULL)
	abort ();
      opno = opct->variable_fields[fld].operand_num;
      switch (opct->variable_fields[fld].coding_method)
	{
	case tic6x_coding_ucst:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op != O_constant)
	    abort ();
	  ucexp = operands[opno].value.exp;
	unsigned_constant:
	  if (ucexp.X_add_number < 0
	      || ucexp.X_add_number >= (1 << fldd->bitfields[0].width))
	    {
	      if (print_errors)
		as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
			opc_len, str);
	      *ok = FALSE;
	      return 0;
	    }
	  value = ucexp.X_add_number;
	  break;

	case tic6x_coding_scst:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op != O_constant)
	    {
	      value = 0;
	      /* Opcode table should not permit non-constants without
		 a known relocation for them.  */
	      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)
		abort ();
	      *fix_needed = TRUE;
	      *fix_exp = &operands[opno].value.exp;
	      *fix_pcrel = 0;
	      *fx_r_type = BFD_RELOC_C6000_ABS_S16;
	      *fix_adda = FALSE;
	      break;
	    }
	  sign_value = SEXT (operands[opno].value.exp.X_add_number);
	signed_constant:
	  if (sign_value < -(1 << (fldd->bitfields[0].width - 1))
	      || (sign_value >= (1 << (fldd->bitfields[0].width - 1))))
	    {
	      if (print_errors)
		as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
			opc_len, str);
	      *ok = FALSE;
	      return 0;
	    }
	  value = sign_value + (1 << (fldd->bitfields[0].width - 1));
	  value ^= (1 << (fldd->bitfields[0].width - 1));
	  break;

	case tic6x_coding_ucst_minus_one:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op != O_constant)
	    abort ();
	  if (operands[opno].value.exp.X_add_number <= 0
	      || operands[opno].value.exp.X_add_number > (1 << fldd->bitfields[0].width))
	    {
	      if (print_errors)
		as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
			opc_len, str);
	      *ok = FALSE;
	      return 0;
	    }
	  value = operands[opno].value.exp.X_add_number - 1;
	  break;

	case tic6x_coding_scst_negate:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op != O_constant)
	    abort ();
	  sign_value = SEXT (-operands[opno].value.exp.X_add_number);
	  goto signed_constant;

	case tic6x_coding_ulcst_dpr_byte:
	case tic6x_coding_ulcst_dpr_half:
	case tic6x_coding_ulcst_dpr_word:
	  bits = tic6x_dpr_shift (opct->variable_fields[fld].coding_method);
	  switch (operands[opno].form)
	    {
	    case TIC6X_OP_EXP:
	      if (operands[opno].value.exp.X_op == O_constant)
		{
		  ucexp = operands[opno].value.exp;
		  goto unsigned_constant;
		}
	      expp = &operands[opno].value.exp;
	      break;

	    case TIC6X_OP_MEM_NOUNREG:
	      mem = operands[opno].value.mem;
	      tic6x_default_mem_ref (&mem);
	      if (mem.offset_is_reg)
		abort ();
	      if (mem.offset.exp.X_op == O_constant)
		{
		  ucexp = mem.offset.exp;
		  if (mem.scaled == tic6x_offset_unscaled)
		    {
		      if (ucexp.X_add_number & ((1 << bits) - 1))
			{
			  if (print_errors)
			    as_bad (_("offset in operand %u of '%.*s' not "
				      "divisible by %u"), opno + 1, opc_len,
				    str, 1u << bits);
			  *ok = FALSE;
			  return 0;
			}
		      ucexp.X_add_number >>= bits;
		    }
		  goto unsigned_constant;
		}
	      if (mem.scaled != tic6x_offset_unscaled)
		abort ();
	      if (operands[opno].value.mem.mod == tic6x_mem_mod_none
		  || operands[opno].value.mem.scaled != tic6x_offset_unscaled
		  || operands[opno].value.mem.offset_is_reg)
		abort ();
	      expp = &operands[opno].value.mem.offset.exp;
	      break;

	    default:
	      abort ();
	    }
	  value = 0;
	  /* Opcode table should not use this encoding without a known
	     relocation.  */
	  if (fldd->bitfields[0].low_pos != 8 || fldd->bitfields[0].width != 15)
	    abort ();
	  /* We do not check for offset divisibility here; such a
	     check is not needed at this point to encode the value,
	     and if there is eventually a problem it will be detected
	     either in md_apply_fix or at link time.  */
	  *fix_needed = TRUE;
	  *fix_exp = expp;
	  *fix_pcrel = 0;
	  *fx_r_type
	    = tic6x_dpr_reloc (opct->variable_fields[fld].coding_method);
	  if (operands[opno].form == TIC6X_OP_EXP)
	    *fix_adda = TRUE;
	  else
	    *fix_adda = FALSE;
	  break;

	case tic6x_coding_lcst_low16:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op == O_constant)
	    value = operands[opno].value.exp.X_add_number & 0xffff;
	  else
	    {
	      value = 0;
	      /* Opcode table should not use this encoding without a
		 known relocation.  */
	      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)
		abort ();
	      *fix_needed = TRUE;
	      *fix_exp = &operands[opno].value.exp;
	      *fix_pcrel = 0;
	      *fx_r_type = BFD_RELOC_C6000_ABS_L16;
	      *fix_adda = FALSE;
	    }
	  break;

	case tic6x_coding_lcst_high16:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op == O_constant)
	    value = (operands[opno].value.exp.X_add_number >> 16) & 0xffff;
	  else
	    {
	      value = 0;
	      /* Opcode table should not use this encoding without a
		 known relocation.  */
	      if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)
		abort ();
	      *fix_needed = TRUE;
	      *fix_exp = &operands[opno].value.exp;
	      *fix_pcrel = 0;
	      *fx_r_type = BFD_RELOC_C6000_ABS_H16;
	      *fix_adda = FALSE;
	    }
	  break;

	case tic6x_coding_pcrel:
	case tic6x_coding_pcrel_half:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  value = 0;
	  *fix_needed = TRUE;
	  *fix_exp = &operands[opno].value.exp;
	  *fix_pcrel = 1;
	  if (fldd->bitfields[0].low_pos == 7 && fldd->bitfields[0].width == 21)
	    *fx_r_type = BFD_RELOC_C6000_PCR_S21;
	  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 12)
	    *fx_r_type = BFD_RELOC_C6000_PCR_S12;
	  else if (fldd->bitfields[0].low_pos == 13 && fldd->bitfields[0].width == 10)
	    *fx_r_type = BFD_RELOC_C6000_PCR_S10;
	  else if (fldd->bitfields[0].low_pos == 16 && fldd->bitfields[0].width == 7)
	    *fx_r_type = BFD_RELOC_C6000_PCR_S7;
	  else
	    /* Opcode table should not use this encoding without a
	       known relocation.  */
	    abort ();
	  *fix_adda = FALSE;
	  break;

	case tic6x_coding_regpair_lsb:
	  switch (operands[opno].form)
	    {
	    case TIC6X_OP_REGPAIR:
	      value = operands[opno].value.reg.num;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case tic6x_coding_regpair_msb:
	  switch (operands[opno].form)
	    {
	    case TIC6X_OP_REGPAIR:
	      value = operands[opno].value.reg.num + 1;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case tic6x_coding_reg:
	  switch (operands[opno].form)
	    {
	    case TIC6X_OP_REG:
	    case TIC6X_OP_REGPAIR:
	      value = operands[opno].value.reg.num;
	      break;

	    case TIC6X_OP_MEM_NOUNREG:
	    case TIC6X_OP_MEM_UNREG:
	      value = operands[opno].value.mem.base_reg.num;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case tic6x_coding_areg:
	  switch (operands[opno].form)
	    {
	    case TIC6X_OP_REG:
	      value = (operands[opno].value.reg.num == 15 ? 1 : 0);
	      break;

	    case TIC6X_OP_MEM_NOUNREG:
	      value = (operands[opno].value.mem.base_reg.num == 15 ? 1 : 0);
	      break;

	    default:
	      abort ();
	    }
	  break;

	case tic6x_coding_crlo:
	  if (operands[opno].form != TIC6X_OP_CTRL)
	    abort ();
	  value = tic6x_ctrl_table[operands[opno].value.ctrl].crlo;
	  break;

	case tic6x_coding_crhi:
	  if (operands[opno].form != TIC6X_OP_CTRL)
	    abort ();
	  value = 0;
	  break;

	case tic6x_coding_reg_shift:
	  if (operands[opno].form != TIC6X_OP_REGPAIR)
	    abort ();
	  value = operands[opno].value.reg.num >> 1;
	  break;

	case tic6x_coding_mem_offset:
	  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG)
	    abort ();
	  mem = operands[opno].value.mem;
	  tic6x_default_mem_ref (&mem);
	  if (mem.offset_is_reg)
	    {
	      if (mem.scaled != tic6x_offset_scaled)
		abort ();
	      value = mem.offset.reg.num;
	    }
	  else
	    {
	      int scale;

	      if (mem.offset.exp.X_op != O_constant)
		abort ();
	      switch (mem.scaled)
		{
		case tic6x_offset_scaled:
		  scale = 1;
		  break;

		case tic6x_offset_unscaled:
		  scale = opct->operand_info[opno].size;
		  if (scale != 1 && scale != 2 && scale != 4 && scale != 8)
		    abort ();
		  break;

		default:
		  abort ();
		}
	      if (mem.offset.exp.X_add_number < 0
		  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width) * scale)
		{
		  if (print_errors)
		    as_bad (_("offset in operand %u of '%.*s' out of range"),
			    opno + 1, opc_len, str);
		  *ok = FALSE;
		  return 0;
		}
	      if (mem.offset.exp.X_add_number % scale)
		{
		  if (print_errors)
		    as_bad (_("offset in operand %u of '%.*s' not "
			      "divisible by %u"),
			    opno + 1, opc_len, str, scale);
		  *ok = FALSE;
		  return 0;
		}
	      value = mem.offset.exp.X_add_number / scale;
	    }
	  break;

	case tic6x_coding_mem_offset_noscale:
	  if (operands[opno].form != TIC6X_OP_MEM_UNREG)
	    abort ();
	  mem = operands[opno].value.mem;
	  tic6x_default_mem_ref (&mem);
	  if (mem.offset_is_reg)
	    value = mem.offset.reg.num;
	  else
	    {
	      if (mem.offset.exp.X_op != O_constant)
		abort ();
	      if (mem.offset.exp.X_add_number < 0
		  || mem.offset.exp.X_add_number >= (1 << fldd->bitfields[0].width))
		{
		  if (print_errors)
		    as_bad (_("offset in operand %u of '%.*s' out of range"),
			    opno + 1, opc_len, str);
		  *ok = FALSE;
		  return 0;
		}
	      value = mem.offset.exp.X_add_number;
	    }
	  break;

	case tic6x_coding_mem_mode:
	  if (operands[opno].form != TIC6X_OP_MEM_NOUNREG
	      && operands[opno].form != TIC6X_OP_MEM_UNREG)
	    abort ();
	  mem = operands[opno].value.mem;
	  tic6x_default_mem_ref (&mem);
	  switch (mem.mod)
	    {
	    case tic6x_mem_mod_plus:
	      value = 1;
	      break;

	    case tic6x_mem_mod_minus:
	      value = 0;
	      break;

	    case tic6x_mem_mod_preinc:
	      value = 9;
	      break;

	    case tic6x_mem_mod_predec:
	      value = 8;
	      break;

	    case tic6x_mem_mod_postinc:
	      value = 11;
	      break;

	    case tic6x_mem_mod_postdec:
	      value = 10;
	      break;

	    default:
	      abort ();
	    }
	  value += (mem.offset_is_reg ? 4 : 0);
	  break;

	case tic6x_coding_scaled:
	  if (operands[opno].form != TIC6X_OP_MEM_UNREG)
	    abort ();
	  mem = operands[opno].value.mem;
	  tic6x_default_mem_ref (&mem);
	  switch (mem.scaled)
	    {
	    case tic6x_offset_unscaled:
	      value = 0;
	      break;

	    case tic6x_offset_scaled:
	      value = 1;
	      break;

	    default:
	      abort ();
	    }
	  break;

	case tic6x_coding_spmask:
	  /* The position of such a field is hardcoded in the handling
	     of "||^".  */
	  if (fldd->bitfields[0].low_pos != 18)
	    abort ();
	  value = 0;
	  for (opno = 0; opno < num_operands; opno++)
	    {
	      unsigned int v;

	      v = tic6x_encode_spmask (operands[opno].value.func_unit.base,
				       operands[opno].value.func_unit.side);
	      if (value & v)
		{
		  if (print_errors)
		    as_bad (_("functional unit already masked for operand "
			      "%u of '%.*s'"), opno + 1, opc_len, str);
		  *ok = FALSE;
		  return 0;
		}
	      value |= v;
	    }
	  break;

	case tic6x_coding_reg_unused:
	  /* This is a placeholder; correct handling goes along with
	     resource constraint checks.  */
	  value = 0;
	  break;

	case tic6x_coding_fstg:
	case tic6x_coding_fcyc:
	  if (operands[opno].form != TIC6X_OP_EXP)
	    abort ();
	  if (operands[opno].value.exp.X_op != O_constant)
	    abort ();
	  if (!sploop_ii)
	    {
	      if (print_errors)
		as_bad (_("'%.*s' instruction not in a software "
			  "pipelined loop"),
			opc_len, str);
	      *ok = FALSE;
	      return 0;
	    }

	  if (sploop_ii <= 1)
	    fcyc_bits = 0;
	  else if (sploop_ii <= 2)
	    fcyc_bits = 1;
	  else if (sploop_ii <= 4)
	    fcyc_bits = 2;
	  else if (sploop_ii <= 8)
	    fcyc_bits = 3;
	  else if (sploop_ii <= 14)
	    fcyc_bits = 4;
	  else
	    abort ();
	  if (fcyc_bits > fldd->bitfields[0].width)
	    abort ();

	  if (opct->variable_fields[fld].coding_method == tic6x_coding_fstg)
	    {
	      int i, t;
	      if (operands[opno].value.exp.X_add_number < 0
		  || (operands[opno].value.exp.X_add_number
		      >= (1 << (fldd->bitfields[0].width - fcyc_bits))))
		{
		  if (print_errors)
		    as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
			    opc_len, str);
		  *ok = FALSE;
		  return 0;
		}
	      value = operands[opno].value.exp.X_add_number;
	      for (t = 0, i = fcyc_bits; i < fldd->bitfields[0].width; i++)
		{
		  t = (t << 1) | (value & 1);
		  value >>= 1;
		}
	      value = t << fcyc_bits;
	    }
	  else
	    {
	      if (operands[opno].value.exp.X_add_number < 0
		  || (operands[opno].value.exp.X_add_number >= sploop_ii))
		{
		  if (print_errors)
		    as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
			    opc_len, str);
		  *ok = FALSE;
		  return 0;
		}
	      value = operands[opno].value.exp.X_add_number;
	    }
	  break;

	case tic6x_coding_fu:
	  value = func_unit_side == 2 ? 1 : 0;
	  break;

	case tic6x_coding_data_fu:
	  value = func_unit_data_side == 2 ? 1 : 0;
	  break;

	case tic6x_coding_xpath:
	  value = func_unit_cross;
	  break;

	default:
	  abort ();
	}

      for (ffld = 0; ffld < opct->num_fixed_fields; ffld++)
	if ((opct->fixed_fields[ffld].field_id
	     == opct->variable_fields[fld].field_id)
	    && (value < opct->fixed_fields[ffld].min_val
		|| value > opct->fixed_fields[ffld].max_val))
	  {
	    if (print_errors)
	      as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
		      opc_len, str);
	    *ok = FALSE;
	    return 0;
	  }

      opcode_value |= value << fldd->bitfields[0].low_pos;
    }

  if (this_line_creg)
    {
      const tic6x_insn_field *creg;
      const tic6x_insn_field *z;

      creg = tic6x_field_from_fmt (fmt, tic6x_field_creg);
      if (creg == NULL)
	{
	  if (print_errors)
	    as_bad (_("instruction '%.*s' cannot be predicated"),
		    opc_len, str);
	  *ok = FALSE;
	  return 0;
	}
      z = tic6x_field_from_fmt (fmt, tic6x_field_z);
      /* If there is a creg field, there must be a z field; otherwise
	 there is an error in the format table.  */
      if (z == NULL)
	abort ();

      opcode_value |= this_line_creg << creg->bitfields[0].low_pos;
      opcode_value |= this_line_z << z->bitfields[0].low_pos;
    }

  *ok = TRUE;
  return opcode_value;
}
```


Overlapping Code:
```
(tic6x_opcode_id id, tic6x_operand *operands,
unsigned int num_operands, unsigned int this_line_creg,
unsigned int this_line_z, unsigned int func_unit_side,
unsigned int func_unit_cross,
unsigned int func_unit_data_side, int sploop_ii,
expressionS **fix_exp, int *fix_pcrel,
bfd_reloc_code_real_type *fx_r_type, bfd_boolean *fix_adda,
bfd_boolean *fix_needed, bfd_boolean *ok,
bfd_boolean print_errors, char *str, int opc_len)
{
const tic6x_opcode *opct;
const tic6x_insn_format *fmt;
unsigned int opcode_value;
unsigned int fld;
opct = &tic6x_opcode_table[id];
fmt = &tic6x_insn_format_table[opct->format];
opcode_value = fmt->cst_bits;
for (fld = 0; fld < opct->num_fixed_fields; fld++)
{
if (opct->fixed_fields[fld].min_val == opct->fixed_fields[fld].max_val)
{
const tic6x_insn_field *fldd;
fldd = tic6x_field_from_fmt (fmt, opct->fixed_fields[fld].field_id);
if (fldd == NULL)
abort ();
opcode_value |= opct->fixed_fields[fld].min_val << fldd->bitfields[0].low_pos;
}
}
for (fld = 0; fld < opct->num_variable_fields; fld++)
{
const tic6x_insn_field *fldd;
unsigned int value;
unsigned int opno;
unsigned int ffld;
offsetT sign_value;
unsigned int bits;
unsigned int fcyc_bits;
expressionS *expp;
expressionS ucexp;
tic6x_mem_ref mem;
fldd = tic6x_field_from_fmt (fmt, opct->variable_fields[fld].field_id);
if (fldd == NULL)
abort ();
opno = opct->variable_fields[fld].operand_num;
switch (opct->variable_fields[fld].coding_method)
{
case tic6x_coding_ucst:
if (operands[opno].form != TIC6X_OP_EXP)
abort ();
if (operands[opno].value.exp.X_op != O_constant)
abort ();
ucexp = operands[opno].value.exp;
unsigned_constant:
if (ucexp.X_add_number < 0
|| ucexp.X_add_number >= (1 << fldd->bitfields[0].width))
{
if (print_errors)
as_bad (_("operand %u of '%.*s' out of range"), opno + 1,
opc_len, str);
*ok = FALSE;
return 0;
}
value = ucexp.X_add_number;
break;
case tic6x_coding_scst:
if (operands[opno].form != TIC6X_OP_EXP)
abort ();
if (operands[opno].value.exp.X_op != O_constant)
{
value = 0;
/* Opcode table should not permit non-constants without
a known relocation for them. */
if (fldd->bitfields[0].low_pos != 7 || fldd->bitfields[0].width != 16)
ab
```
<Overlap Ratio: 0.9804900181488203>

---

--- 274 --
Question ID: 9080c3ab4cf94f67546cd04f0d55868d9d020151_0
Original Code:
```
static qboolean CG_ParseCharacterFile(const char *filename, clientInfo_t * ci)
{
	char           *text_p, *prev;
	int             len;
	int             i;
	char           *token;
	float           fps;
	int             skip;
	char            text[20000];
	fileHandle_t    f;

	// load the file
	len = trap_FS_FOpenFile(filename, &f, FS_READ);
	if(len <= 0)
	{
		return qfalse;
	}
	if(len >= sizeof(text) - 1)
	{
		CG_Printf("File %s too long\n", filename);
		trap_FS_FCloseFile(f);
		return qfalse;
	}
	trap_FS_Read(text, len, f);
	text[len] = 0;
	trap_FS_FCloseFile(f);

	// parse the text
	text_p = text;
	skip = 0;					// quite the compiler warning

	ci->footsteps = FOOTSTEP_STONE;
	VectorClear(ci->headOffset);
	ci->gender = GENDER_MALE;
	ci->fixedlegs = qfalse;
	ci->fixedtorso = qfalse;
	ci->firstTorsoBoneName[0] = '\0';
	ci->lastTorsoBoneName[0] = '\0';
	ci->torsoControlBoneName[0] = '\0';
	ci->neckControlBoneName[0] = '\0';
	ci->modelScale[0] = 1;
	ci->modelScale[1] = 1;
	ci->modelScale[2] = 1;

	// read optional parameters
	while(1)
	{
		prev = text_p;			// so we can unget
		token = Com_Parse(&text_p);
		if(!token[0])
		{
			break;
		}
		
		if(!Q_stricmp(token, "footsteps"))
		{
			token = Com_Parse(&text_p);
			if(!token)
			{
				break;
			}
			if(!Q_stricmp(token, "default") || !Q_stricmp(token, "normal") || !Q_stricmp(token, "stone"))
			{
				ci->footsteps = FOOTSTEP_STONE;
			}
			else if(!Q_stricmp(token, "boot"))
			{
				ci->footsteps = FOOTSTEP_BOOT;
			}
			else if(!Q_stricmp(token, "flesh"))
			{
				ci->footsteps = FOOTSTEP_FLESH;
			}
			else if(!Q_stricmp(token, "mech"))
			{
				ci->footsteps = FOOTSTEP_MECH;
			}
			else if(!Q_stricmp(token, "energy"))
			{
				ci->footsteps = FOOTSTEP_ENERGY;
			}
			else
			{
				CG_Printf("Bad footsteps parm in %s: %s\n", filename, token);
			}
			continue;
		}
		else if(!Q_stricmp(token, "headoffset"))
		{
			for(i = 0; i < 3; i++)
			{
				token = Com_Parse(&text_p);
				if(!token)
				{
					break;
				}
				ci->headOffset[i] = atof(token);
			}
			continue;
		}
		else if(!Q_stricmp(token, "sex"))
		{
			token = Com_Parse(&text_p);
			if(!token)
			{
				break;
			}
			if(token[0] == 'f' || token[0] == 'F')
			{
				ci->gender = GENDER_FEMALE;
			}
			else if(token[0] == 'n' || token[0] == 'N')
			{
				ci->gender = GENDER_NEUTER;
			}
			else
			{
				ci->gender = GENDER_MALE;
			}
			continue;
		}
		else if(!Q_stricmp(token, "fixedlegs"))
		{
			ci->fixedlegs = qtrue;
			continue;
		}
		else if(!Q_stricmp(token, "fixedtorso"))
		{
			ci->fixedtorso = qtrue;
			continue;
		}
		else if(!Q_stricmp(token, "firstTorsoBoneName"))
		{
			token = Com_Parse(&text_p);
			Q_strncpyz(ci->firstTorsoBoneName, token, sizeof(ci->firstTorsoBoneName));
			continue;
		}
		else if(!Q_stricmp(token, "lastTorsoBoneName"))
		{
			token = Com_Parse(&text_p);
			Q_strncpyz(ci->lastTorsoBoneName, token, sizeof(ci->lastTorsoBoneName));
			continue;
		}
		else if(!Q_stricmp(token, "torsoControlBoneName"))
		{
			token = Com_Parse(&text_p);
			Q_strncpyz(ci->torsoControlBoneName, token, sizeof(ci->torsoControlBoneName));
			continue;
		}
		else if(!Q_stricmp(token, "neckControlBoneName"))
		{
			token = Com_Parse(&text_p);
			Q_strncpyz(ci->neckControlBoneName, token, sizeof(ci->neckControlBoneName));
			continue;
		}
		else if(!Q_stricmp(token, "modelScale"))
		{
			for(i = 0; i < 3; i++)
			{
				token = Com_ParseExt(&text_p, qfalse);
				if(!token)
				{
					break;
				}
				ci->modelScale[i] = atof(token);
			}
			continue;
		}

		Com_Printf("unknown token '%s' is %s\n", token, filename);
	}
	
	return qtrue;
}
```


Overlapping Code:
```
e(const char *filename, clientInfo_t * ci)
{
char *text_p, *prev;
int len;
int i;
char *token;
float fps;
int skip;
char text[20000];
fileHandle_t f;
// load the file
len = trap_FS_FOpenFile(filename, &f, FS_READ);
if(len <= 0)
{
return qfalse;
}
if(len >= sizeof(text) - 1)
{
CG_Printf("File %s too long\n", filename);
trap_FS_FCloseFile(f);
return qfalse;
}
trap_FS_Read(text, len, f);
text[len] = 0;
trap_FS_FCloseFile(f);
// parse the text
text_p = text;
skip = 0; // quite the compiler warning
ci->footsteps = FOOTSTEP_STONE;
VectorClear(ci->headOffset);
ci->gender = GENDER_MALE;
ci->fixedlegs = qfalse;
ci->fixedtorso = qfalse;
ci->firstTorsoBoneName[0] = '\0';
ci->lastTorsoBoneName[0] = '\0';
ci->torsoControlBoneName[0] = '\0';
ci->neckControlBoneName[0] = '\0';
ci->modelScale[0] = 1;
ci->modelScale[1] = 1;
ci->modelScale[2] = 1;
// read optional parameters
while(1)
{
prev = text_p; // so we can unget
token = Com_Parse(&text_p);
if(!token[0])
{
break;
}

if(!Q_stricmp(token, "footsteps"))
{
token = Com_Parse(&text_p);
if(!token)
{
break;
}
if(!Q_stricmp(token, "default") || !Q_stricmp(token, "normal") || !Q_stricmp(token, "stone"))
{
ci->footsteps = FOOTSTEP_STONE;
}
else if(!Q_stricmp(token, "boot"))
{
ci->footsteps = FOOTSTEP_BOOT;
}
else if(!Q_stricmp(token, "flesh"))
{
ci->footsteps = FOOTSTEP_FLESH;
}
else if(!Q_stricmp(token, "mech"))
{
ci->footsteps = FOOTSTEP_MECH;
}
else if(!Q_stricmp(token, "energy"))
{
ci->footsteps = FOOTSTEP_ENERGY;
}
else
{
CG_Printf("Bad footsteps parm in %s: %s\n", filename, token);
}
continue;
}
else if(!Q_stricmp(token, "headoffset"))
{
for(i = 0; i < 3; i++)
{
token = Com_Parse(&text_p);
if(!token)
{
break;
}
ci->headOffset[i] = atof(token);
}
continue;
}
else if(!Q_stricmp(token, "sex"))
{
token = Com_Parse(&text_p);
if(!token)
{
break;
}
if(token[0] == 'f' || token[0] == 'F')
{
ci->gender = GENDER_FEMALE;
}
else if(token[0] == 'n' || token[0] == 'N')
{
ci->gender = GENDER_NEUTER;
}
else
{
ci->gender = GENDER_MALE;
}
continue;
}
else if(!Q_stricmp(token, "fixedlegs"))
{
ci->fixedlegs = qtrue;
continue;
}
else if(!
```
<Overlap Ratio: 0.9816470588235294>

---

--- 275 --
Question ID: b35e0edfaa1a3932fe5b7253296c693bed3ca04f_26
Original Code:
```
void f26(void) {
    	int32_t x141 = -1;
	int16_t x142 = 3707;
	static volatile int8_t x144 = INT8_MIN;
	volatile int32_t t26 = 169;

    t26 = ((x141*x142)|(x143/x144));

    if (t26 != -3707) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x141 = -1;
int16_t x142 = 3707;
static volatile int8_t x144 = INT8_MIN;
volatile int32_t t26 = 169;
t26 = ((x141*x142)|(x143/x144));
if (t26 !
```
<Overlap Ratio: 0.7537688442211056>

---

--- 276 --
Question ID: 8ce91f3311317a9f4d447921b05bbe5a370bf164_1
Original Code:
```
void DM_ENG_deleteAllSetParameterValuesFault(DM_ENG_SetParameterValuesFault** pFault)
{
   DM_ENG_SetParameterValuesFault* fault = *pFault;
   while (fault != NULL)
   {
      DM_ENG_SetParameterValuesFault* fa = fault;
      fault = fault->next;
      DM_ENG_deleteSetParameterValuesFault(fa);
   }
   *pFault = NULL;
}
```


Overlapping Code:
```
id DM_ENG_deleteAllSetParameterValuesFault(DM_ENG_SetParameterValuesFault** pFault)
{
DM_ENG_SetParameterValuesFault* fault = *pFault;
while (fault != NULL)
{
DM_ENG_SetParameterValuesFault* fa = fault;
fault = fault->next;
DM_ENG_deleteSetParameterV
```
<Overlap Ratio: 0.8710801393728222>

---

--- 277 --
Question ID: 68e666db7f84d65a85239c7ad12aa1cb8c8e270e_3
Original Code:
```
static void heap_push(heap *h, void *e) {
    if (h->size >= h->capacity) {
        h->capacity *= 2;
        h->data = (void **) realloc(h->data, (h->capacity) * sizeof(void *));
    }
    int i = h->size;
    h->data[h->size++] = e;
    if (i == 0)
        return;

    void **data = h->data;
    for (int parent; i > 0; i = parent) {
        parent = (i - 1) / 2;
        void *p = data[parent];
        if (h->compare(p, e) <= 0)
            break;
        data[i] = p;
    }
    data[i] = e;
}
```


Overlapping Code:
```
ap *h, void *e) {
if (h->size >= h->capacity) {
h->capacity *= 2;
h->data = (void **) realloc(h->data, (h->capacity) * sizeof(void *));
}
int i = h->size;
h->data[h->size++] = e;
if (i == 0)
return;
void **data = h->data;
for (int parent; i > 0; i = parent) {
parent = (i - 1) / 2;
void *p = data[parent];
if (h->compare(p, e) <= 0)
break;
data[i] = 
```
<Overlap Ratio: 0.8905852417302799>

---

--- 278 --
Question ID: 82b71c98128e90496f7ee5ec0b99d98b1974f43c_5
Original Code:
```
int
gx_pattern_cache_add_entry(gs_state *pgs, gx_device_pattern_accum *padev,
  gx_color_tile **pctile)
{	const gx_device_memory *mbits = padev->bits;
	const gx_device_memory *mmask = padev->mask;
	const gs_pattern_instance *pinst = padev->instance;
	gx_pattern_cache *pcache;
	ulong used = 0;
	gx_bitmap_id id = pinst->id;
	gx_color_tile *ctile;
	int code = ensure_pattern_cache(pgs);
	if ( code < 0 )
	  return code;
	pcache = pgs->pattern_cache;
	/*
	 * Check whether the pattern completely fills its box.
	 * If so, we can avoid the expensive masking operations
	 * when using the pattern.
	 */
	{	int y;
		for ( y = 0; y < mmask->height; y++ )
		  { const byte *row = scan_line_base(mmask, y);
		    int w;
		    for ( w = mmask->width; w > 8; w -= 8 )
		      if ( *row++ != 0xff )
			goto keep;
		    if ( (*row | (0xff >> w)) != 0xff )
		      goto keep;
		  }
		/* We don't need a mask. */
		mmask = 0;
keep:		;
	}
	if ( mbits != 0 )
	  used += gdev_mem_bitmap_size(mbits);
	if ( mmask != 0 )
	  used += gdev_mem_bitmap_size(mmask);
	ctile = &pcache->tiles[id % pcache->num_tiles];
	gx_pattern_cache_free_entry(pcache, ctile);
	while ( pcache->bits_used + used > pcache->max_bits &&
		pcache->bits_used != 0	 /* allow 1 oversized entry (?) */
	      )
	  { pcache->next = (pcache->next + 1) % pcache->num_tiles;
	    gx_pattern_cache_free_entry(pcache, &pcache->tiles[pcache->next]);
	  }
	ctile->id = id;
	ctile->depth = padev->color_info.depth;
	ctile->tiling_type = pinst->template.TilingType;
	ctile->xstep = pinst->xstep;
	ctile->ystep = pinst->ystep;
	if ( mbits != 0 )
	  make_bitmap(&ctile->bits, mbits, gs_next_ids(1));
	else
	  ctile->bits.data = 0;
	if ( mmask != 0 )
	  make_bitmap(&ctile->mask, mmask, id);
	else
	  ctile->mask.data = 0;
	ctile->is_simple = (ctile->xstep.x == int2fixed(pinst->size.x) &&
			    ctile->xstep.y == 0 &&
			    ctile->ystep.x == 0 &&
			    ctile->ystep.y == int2fixed(pinst->size.y));
	if_debug6('t',
		  "[t]is_simple? xstep=(%g,%g) ystep=(%g,%g) size=(%d,%d)\n",
		  fixed2float(ctile->xstep.x), fixed2float(ctile->xstep.y),
		  fixed2float(ctile->ystep.x), fixed2float(ctile->ystep.y),
		  pinst->size.x, pinst->size.y);
	pcache->bits_used += used;
	*pctile = ctile;
	return 0;
}
```


Overlapping Code:
```
cache_add_entry(gs_state *pgs, gx_device_pattern_accum *padev,
gx_color_tile **pctile)
{ const gx_device_memory *mbits = padev->bits;
const gx_device_memory *mmask = padev->mask;
const gs_pattern_instance *pinst = padev->instance;
gx_pattern_cache *pcache;
ulong used = 0;
gx_bitmap_id id = pinst->id;
gx_color_tile *ctile;
int code = ensure_pattern_cache(pgs);
if ( code < 0 )
return code;
pcache = pgs->pattern_cache;
/*
* Check whether the pattern completely fills its box.
* If so, we can avoid the expensive masking operations
* when using the pattern.
*/
{ int y;
for ( y = 0; y < mmask->height; y++ )
{ const byte *row = scan_line_base(mmask, y);
int w;
for ( w = mmask->width; w > 8; w -= 8 )
if ( *row++ != 0xff )
goto keep;
if ( (*row | (0xff >> w)) != 0xff )
goto keep;
}
/* We don't need a mask. */
mmask = 0;
keep: ;
}
if ( mbits != 0 )
used += gdev_mem_bitmap_size(mbits);
if ( mmask != 0 )
used += gdev_mem_bitmap_size(mmask);
ctile = &pcache->tiles[id % pcache->num_tiles];
gx_pattern_cache_free_entry(pcache, ctile);
while ( pcache->bits_used + used > pcache->max_bits &&
pcache->bits_used != 0 /* allow 1 oversized entry (?) */
)
{ pcache->next = (pcache->next + 1) % pcache->num_tiles;
gx_pattern_cache_free_entry(pcache, &pcache->tiles[pcache->next]);
}
ctile->id = id;
ctile->depth = padev->color_info.depth;
ctile->tiling_type = pinst->template.TilingType;
ctile->xstep = pinst->xstep;
ctile->ystep = pinst->ystep;
if ( mbits != 0 )
make_bitmap(&ctile->bits, mbits, gs_next_ids(1));
else
ctile->bits.data = 0;
if ( mmask != 0 )
make_bitmap(&ctile->mask, mmask, id);
else
ctile->mask.data = 0;
ctile->is_simple = (ctile->xstep.x == int2fixed(pinst->size.x) &&
ctile->xstep.y == 0 &&
ctile->ystep.x == 0 &&
ctile->ystep.y == int2fixed(pinst->size.y));
if_debug6('t',
"[t]is_simple? xstep=(%g,%g) ystep=(%g,%g) size=(%d,%d)\n",
fixed2float(ctile->xstep.x), fixed2float(ctile->xstep.y),
fixed2float(ctile->ystep.x), fixed2float(ctile->ystep.y),
pinst->size.x, pinst->size.y);
pcache->bits_used 
```
<Overlap Ratio: 0.9748062015503876>

---

--- 279 --
Question ID: 569537e6d878d25bb7c54ab5989c049f1f8494ee_157
Original Code:
```
void f158(void) {
    	uint8_t x633 = 3U;
	int16_t x634 = INT16_MIN;
	uint64_t x636 = 35969LLU;
	int32_t t158 = -4;

    t158 = (x633^((x634<=x635)==x636));

    if (t158 != 3) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d) {
uint8_t x633 = 3U;
int16_t x634 = INT16_MIN;
uint64_t x636 = 35969LLU;
int32_t t158 = -4;
t158 = (x633^((x634<=x635)==x636));
if (t158 != 3) { NG
```
<Overlap Ratio: 0.8241758241758241>

---

--- 280 --
Question ID: d657f07b5f90dac51efe3a4271eae218acb23a24_10
Original Code:
```
static void
sendtopic(char buf[])
{
	char 		msg[MSGMAX];
	unsigned int 	i;
	int 		j = 0;

	if (strncmp(buf, "/topic ", 7) == 0) {
		for (i = 7; i < strlen(buf); i++)
			msg[j++] = buf[i];
		msg[j] = '\0';
	} else if (strncmp(buf, "/t ", 3) == 0) {
		for (i = 3; i < strlen(buf); i++)
			msg[j++] = buf[i];
		msg[j] = '\0';
	} else if (strncmp(buf, "/topic", 5) == 0 || strncmp(buf, "/t", 2) == 0) {
		msg[0] = '\0';
	} else {
		success = 0;
	}
	if (success) {
		snprintf(packet, sizeof(packet), "%chtopic\001%s",
			 (int) sizeof(packet) - 1, msg);
	}
}
```


Overlapping Code:
```
ar buf[])
{
char msg[MSGMAX];
unsigned int i;
int j = 0;
if (strncmp(buf, "/topic ", 7) == 0) {
for (i = 7; i < strlen(buf); i++)
msg[j++] = buf[i];
msg[j] = '\0';
} else if (strncmp(buf, "/t ", 3) == 0) {
for (i = 3; i < strlen(buf); i++)
msg[j++] = buf[i];
msg[j] = '\0';
} else if (strncmp(buf, "/topic", 5) == 0 || strncmp(buf, "/t", 2) == 0) {
msg[0] = '\0';
} else {
success = 0;
}
if (success) {
snprintf(packet, sizeof(packet), "%chtopic\001%s",
(i
```
<Overlap Ratio: 0.8888888888888888>

---

--- 281 --
Question ID: 49470297bb39a37f2c1ed6f5a11405a0489eda14_509
Original Code:
```
static inline void hri_rtcmode1_set_EVCTRL_CMPEO2_bit(const void *const hw)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE1.EVCTRL.reg |= RTC_MODE1_EVCTRL_CMPEO2;
	RTC_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
et_EVCTRL_CMPEO2_bit(const void *const hw)
{
RTC_CRITICAL_SECTION_ENTER();
((Rtc *)hw)->MODE1.EVCTRL.reg |= RTC_MODE1_EVCTRL_CMPEO2;
RTC_CRITICAL_SECTION_LEAVE(
```
<Overlap Ratio: 0.8121827411167513>

---

--- 282 --
Question ID: 6c1c1a1bd751ff295e491b9dcc03355c7043cc27_203
Original Code:
```
static KMETHOD cevhttp_uri_parse_query_str(KonohaContext *kctx, KonohaStack *sfp)
{
	kString *uri = sfp[1].asString;
	kcevkeyvalq *headers = (kcevkeyvalq *)sfp[2].asObject;
	KReturnUnboxValue(evhttp_parse_query_str(kString_text(uri), headers->keyvalq));
}
```


Overlapping Code:
```
(KonohaContext *kctx, KonohaStack *sfp)
{
kString *uri = sfp[1].asString;
kcevkeyvalq *headers = (kcevkeyvalq *)sfp[2].asObject;
KReturnUnboxValue(evhttp_parse_query_str(kString_text(uri), headers->keyvalq)
```
<Overlap Ratio: 0.8174603174603174>

---

--- 283 --
Question ID: acaf6932b2e116454cd88e749411240c32bda844_185
Original Code:
```
void f185(void) {
    	int64_t x1641 = INT64_MIN;
	static int16_t x1642 = INT16_MIN;
	volatile uint64_t x1643 = 14760241621939LLU;
	int32_t x1644 = INT32_MAX;

    t185 = ((x1641%x1642)%(x1643>x1644));

    if (t185 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
85(void) {
int64_t x1641 = INT64_MIN;
static int16_t x1642 = INT16_MIN;
volatile uint64_t x1643 = 14760241621939LLU;
int32_t x1644 = INT32_MAX;
t185 = ((x1641%x1642)%(x1643>x1644));
if (t185 != 0LL) {
```
<Overlap Ratio: 0.8733624454148472>

---

--- 284 --
Question ID: c5814a405c20331531e44eee8d7eedfd7c5a0dc0_1
Original Code:
```
GST_START_TEST (test_default_vertex)
{
  GstGLSLStage *stage;
  GError *error = NULL;

  stage = gst_glsl_stage_new_default_vertex (context);
  fail_unless (stage != NULL);
  fail_unless (GL_VERTEX_SHADER == gst_glsl_stage_get_shader_type (stage));

  fail_unless (gst_glsl_stage_compile (stage, &error));

  gst_object_unref (stage);
}
```


Overlapping Code:
```
Stage *stage;
GError *error = NULL;
stage = gst_glsl_stage_new_default_vertex (context);
fail_unless (stage != NULL);
fail_unless (GL_VERTEX_SHADER == gst_glsl_stage_get_shader_type (stage));
fail_unless (gst_glsl_stage_compile (stage, &error));
gst_
```
<Overlap Ratio: 0.7836990595611285>

---

--- 285 --
Question ID: a52bc6b258bf5b96cdb67e9dfb3db7fb20f378df_3
Original Code:
```
inline DSCC_CRect::DSCC_CRect(
		DSCC_POINT topLeft,
		DSCC_POINT bottomRight) throw() {
		left = topLeft.x;
		top = topLeft.y;
		right = bottomRight.x;
		bottom = bottomRight.y;
	}
```


Overlapping Code:
```
ect(
DSCC_POINT topLeft,
DSCC_POINT bottomRight) throw() {
left = topLeft.x;
top = topLeft.y;
right = bottomRight.x;
bottom = bottomRight.
```
<Overlap Ratio: 0.8214285714285714>

---

--- 286 --
Question ID: 032ecb82cb6ac2ef5b5f96ec800e4050c92ede8e_193
Original Code:
```
void f193(void) {
    	volatile int32_t x789 = -1;
	volatile int64_t x790 = INT64_MIN;
	int16_t x791 = INT16_MAX;
	int16_t x792 = INT16_MIN;

    t193 = (x789|((x790^x791)%x792));

    if (t193 != -1LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
t x789 = -1;
volatile int64_t x790 = INT64_MIN;
int16_t x791 = INT16_MAX;
int16_t x792 = INT16_MIN;
t193 = (x789|((x790^x791)%x792));
if (t193 != -1LL
```
<Overlap Ratio: 0.7211538461538461>

---

--- 287 --
Question ID: 76fc558fbbe8cee5cc1ebe6fbd1af78f5fb14663_16
Original Code:
```
void f16(void) {
    	static volatile int32_t x101 = 301;
	static uint16_t x102 = UINT16_MAX;
	int64_t x103 = -147353081581LL;
	int64_t x104 = INT64_MIN;

    t16 = ((x101/(x102%x103))%x104);

    if (t16 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 volatile int32_t x101 = 301;
static uint16_t x102 = UINT16_MAX;
int64_t x103 = -147353081581LL;
int64_t x104 = INT64_MIN;
t16 = ((x101/(x102%x103))%x
```
<Overlap Ratio: 0.6880733944954128>

---

--- 288 --
Question ID: a101f91aab6e417aafd80461d16cb1beda8bb81f_3
Original Code:
```
static int
memb_gpsBitNumber_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 3)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}
```


Overlapping Code:
```
b_gpsBitNumber_constraint_1(asn_TYPE_descriptor_t *td, const void *sptr,
asn_app_constraint_failed_f *ctfailcb, void *app_key) {
long value;

if(!sptr) {
ASN__CTFAIL(app_key, td, sptr,
"%s: value not given (%s:%d)",
td->name, __FILE__, __LINE__);
return -1;
}

value = *(const long *)sptr;

if((value >= 0 && value <= 3)) {
/* Constraint check succeeded */
return 0;
} else {
ASN__CTFAIL(app_key, td, sptr,
"%s: constraint failed (%s:%d)",
td->name, __FILE__, __LINE__);
return -1;
}
}
```
<Overlap Ratio: 0.9719438877755511>

---

--- 289 --
Question ID: 59ea005d0c4bd37eff2d51f7e3d9925c14aa3618_1
Original Code:
```
int luat_spi_setup(luat_spi_t *spi)
{
	// SPI2_HOST = 1
	// SPI3_HOST = 2
	if (spi->id == 1)
	{
		spi_bus_config_t spi_config = {};
		spi_config.miso_io_num = 12;
		spi_config.mosi_io_num = 13;
		spi_config.sclk_io_num = 14;
		spi_config.quadwp_io_num = -1;
		spi_config.quadhd_io_num = -1;
		spi_config.max_transfer_sz = 0;
		ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &spi_config, 0));
	} else if (spi->id == 2)
	{
		spi_bus_config_t spi_config = {};
		spi_config.miso_io_num = 19;
		spi_config.mosi_io_num = 23;
		spi_config.sclk_io_num = 18;
		spi_config.quadwp_io_num = -1;
		spi_config.quadhd_io_num = -1;
		spi_config.max_transfer_sz = 0;
		ESP_ERROR_CHECK(spi_bus_initialize(SPI3_HOST, &spi_config, 0));
	} else
	{
		return -1;
	}
	spi_device_interface_config_t devcfg = {};
	memset(&devcfg,0,sizeof(devcfg));
	if (spi->CPHA == 0)
	{
		if (spi->CPOL == 0)
		{
			devcfg.mode = 0;
		} else if (spi->CPOL == 1)
		{
			devcfg.mode = 1;
		}
	}
	if (spi->CPHA == 1)
	{
		if (spi->CPOL == 0)
		{
			devcfg.mode = 2;
		} else if (spi->CPOL == 1)
		{
			devcfg.mode = 3;
		}
	}

	if (spi->bit_dict == 2)
	{
		devcfg.flags = SPI_DEVICE_BIT_LSBFIRST;
	}
	devcfg.cs_ena_pretrans = 1;
	devcfg.clock_speed_hz = spi->bandrate;
	luat_log_log(1, LUAT_LOG_TAG, "CS:%d\n", spi->cs);
	//默认无 值255
	if (spi->cs == 255)
		spi->cs = spi->id == 1 ? 15 : 5;
	devcfg.spics_io_num = spi->cs;
	devcfg.input_delay_ns = 0;
	devcfg.queue_size = 6;
	if (spi_bus_add_device(spi->id, &devcfg, &spi_h) != ESP_OK)
		return -1;
	gpio_set_level(spi->cs, 1);
	return 0;
}
```


Overlapping Code:
```
int luat_spi_setup(luat_spi_t *spi)
{
// SPI2_HOST = 1
// SPI3_HOST = 2
if (spi->id == 1)
{
spi_bus_config_t spi_config = {};
spi_config.miso_io_num = 12;
spi_config.mosi_io_num = 13;
spi_config.sclk_io_num = 14;
spi_config.quadwp_io_num = -1;
spi_config.quadhd_io_num = -1;
spi_config.max_transfer_sz = 0;
ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &spi_config, 0));
} else if (spi->id == 2)
{
spi_bus_config_t spi_config = {};
spi_config.miso_io_num = 19;
spi_config.mosi_io_num = 23;
spi_config.sclk_io_num = 18;
spi_config.quadwp_io_num = -1;
spi_config.quadhd_io_num = -1;
spi_config.max_transfer_sz = 0;
ESP_ERROR_CHECK(spi_bus_initialize(SPI3_HOST, &spi_config, 0));
} else
{
return -1;
}
spi_device_interface_config_t devcfg = {};
memset(&devcfg,0,sizeof(devcfg));
if (spi->CPHA == 0)
{
if (spi->CPOL == 0)
{
devcfg.mode = 0;
} else if (spi->CPOL == 1)
{
devcfg.mode = 1;
}
}
if (spi->CPHA == 1)
{
if (spi->CPOL == 0)
{
devcfg.mode = 2;
} else if (spi->CPOL == 1)
{
devcfg.mode = 3;
}
}
if (spi->bit_dict == 2)
{
devcfg.flags = SPI_DEVICE_BIT_LSBFIRST;
}
devcfg.cs_ena_pretrans = 1;
devcfg.clock_speed_hz = spi->bandrate;
luat_log_log(1, LUAT_LOG_TAG, "CS:%d\n", spi->cs);
//默认无 值255
if (spi->cs == 255)
spi->cs = spi->id == 1 ? 15 : 5;
devcfg.spics_io_num = spi->cs;
devcfg.input_delay_ns = 0;
devcfg.queue_size = 6;
if (spi_bus_add_device(spi->id, &devcfg, &spi_h) != ESP_OK)
return -1;
gpio_set_level(spi->cs, 1);
return
```
<Overlap Ratio: 0.9965253648366922>

---

--- 290 --
Question ID: 3ccad519c0c986fa686a06da6b6ee3a164ec9237_0
Original Code:
```
int terminal_writeuint64(uint64_t integer, uint8_t base)
{
  if (base < 2 || base > 36)
    return -1;

  if (integer == 0)
  {
    terminal_writechar('0');
    return 0;
  }

  char string[65];
  ptrdiff_t position = 64;

  string[position] = '\0';

  while (integer > 0)
  {
    uint8_t digit = integer % base;

    if (digit < 10)
    {
      string[--position] = '0' + digit;
    }
    else
    {
      string[--position] = 'a' + (digit - 10);
    }

    integer = integer / base;
  }

  terminal_writestring(string + position);

  return 0;
}
```


Overlapping Code:
```
teuint64(uint64_t integer, uint8_t base)
{
if (base < 2 || base > 36)
return -1;
if (integer == 0)
{
terminal_writechar('0');
return 0;
}
char string[65];
ptrdiff_t position = 64;
string[position] = '\0';
while (integer > 0)
{
uint8_t digit = integer % base;
if (digit < 10)
{
string[--position] = '0' + digit;
}
else
{
string[--position] = 'a' + (digit - 10);
}
integer = integer / base;
}
terminal_
```
<Overlap Ratio: 0.8714596949891068>

---

--- 291 --
Question ID: 71852a42faa57de31b76aff42b7d47fa5ea76831_143
Original Code:
```
void f143(void) {
    	int8_t x585 = -1;
	int8_t x586 = -1;
	int32_t t143 = 0;

    t143 = (((x585&x586)>x587)/x588);

    if (t143 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x586 = -1;
int32_t t143 = 0;
t143 = (((x585&x586)>x587)/x588);
if (t143 != 0) { NG(); } else { ; 
```
<Overlap Ratio: 0.6944444444444444>

---

--- 292 --
Question ID: 79738e013b3e5e9d509bb5ea23217bdc372ecd15_179
Original Code:
```
void f179(void) {
    	static int64_t x717 = 4040370LL;
	int16_t x719 = INT16_MIN;
	int32_t t179 = -636544292;

    t179 = ((x717<=(x718>x719))!=x720);

    if (t179 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
tatic int64_t x717 = 4040370LL;
int16_t x719 = INT16_MIN;
int32_t t179 = -636544292;
t179 = ((x717<=(x718>x719))!=x720);
if (t179 != 1) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8932584269662921>

---

--- 293 --
Question ID: 28c515b3dc20636156fe90b4a79c3e7642e8114d_16
Original Code:
```
RK_S32 PPContinuousCheck(RK_U32 value)
{

    RK_S32 ret = (RK_S32) PP_OK;
    RK_U32 first = 0;
    RK_U32 tmp = 0;

    if(value)
    {
        do
        {
            tmp = value & 1;
            if(tmp)
                ret = (RK_S32) PP_OK;
            else
                ret = (RK_S32) PP_PARAM_ERROR;

            first |= tmp;

            value = value >> 1;
            if(!tmp && !tmp && first)
                break;

        }
        while(value);
    }

    return ret;
}
```


Overlapping Code:
```
(RK_U32 value)
{
RK_S32 ret = (RK_S32) PP_OK;
RK_U32 first = 0;
RK_U32 tmp = 0;
if(value)
{
do
{
tmp = value & 1;
if(tmp)
ret = (RK_S32) PP_OK;
else
ret = (RK_S32) PP_PARAM_ERROR;
first |= tmp;
value = value >> 1;
if(!tmp && !tmp && first)
break;
}
w
```
<Overlap Ratio: 0.8278145695364238>

---

--- 294 --
Question ID: 9bce22c2efbac546b67454accd7f83d4879370fc_177
Original Code:
```
void f177(void) {
    	uint8_t x877 = 3U;
	int32_t x878 = INT32_MIN;
	int16_t x879 = -42;
	uint16_t x880 = UINT16_MAX;
	volatile int32_t t177 = 7902;

    t177 = (x877/((x878|x879)*x880));

    if (t177 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x878 = INT32_MIN;
int16_t x879 = -42;
uint16_t x880 = UINT16_MAX;
volatile int32_t t177 = 7902;
t177 = (x877/((x878|x879)*x880));
if (t177 != 0) { NG
```
<Overlap Ratio: 0.704225352112676>

---

--- 295 --
Question ID: ee1ce9ea03c55025da3a88c1bcfb6b9b69edf3f1_3
Original Code:
```
void grab(string str) {
   if(str != "kit" && str != "makeup") {
      tell_object(TP,"No grabbing that! Go for the kit.");
      return 1;
   }
   new("/realms/crystal/obj/makeup")->move(TP);
   return 1;
}
```


Overlapping Code:
```
it" && str != "makeup") {
tell_object(TP,"No grabbing that! Go for the kit.");
return 1;
}
new("/rea
```
<Overlap Ratio: 0.546448087431694>

---

--- 296 --
Question ID: 0023cda653568aee28944d42bb5c4d2a61260819_0
Original Code:
```
void
putu(FILE*pf, TCHAR c)
{
    TCHAR chr=c;

    if( REVERSE )
        chr= ( c<<8 ) + ( ( c>>8 ) &0xFF);


	fwrite((void*)&chr, 1, sizeof(TCHAR), pf);
}
```


Overlapping Code:
```
=c;
if( REVERSE )
chr= ( c<<8 ) + ( ( c>>8 ) &0xFF
```
<Overlap Ratio: 0.36764705882352944>

---

--- 297 --
Question ID: c71f6e3ca8c5b140d1cba6627962b09b758658dc_4
Original Code:
```
int fly_listen_connected(fly_event_t *e)
{
#ifdef DEBUG
	printf("WORKER: Listen socket is connected\n");
#endif
	fly_connect_t *conn;
	fly_request_t *req;

	//conn = (fly_connect_t *) e->event_data;
	conn = (fly_connect_t *) fly_event_data_get(e, __p);
	e->read_or_write = FLY_READ;
	/* event only modify (no add, no delete) */
	e->flag = FLY_MODIFY;
	e->tflag = FLY_INHERIT;
	e->eflag = 0;
	//e->event_state = (void *) EFLY_REQUEST_STATE_INIT;
	//e->event_fase = (void *) EFLY_REQUEST_FASE_INIT;
	fly_event_state_set(e, __e, EFLY_REQUEST_STATE_INIT);
	fly_event_fase_set(e, __e, EFLY_REQUEST_FASE_INIT);
	fly_event_socket(e);

	switch(FLY_CONNECT_HTTP_VERSION(conn)){
	case V1_1:
#ifdef DEBUG
	printf("WORKER: Start HTTP1.1 communication\n");
#endif
		req = fly_request_init(conn);
		if (fly_unlikely_null(req)){
			struct fly_err *__err;
			__err = fly_event_err_init(
				e, errno, FLY_ERR_ERR,
				"request init error."
			);
			fly_event_error_add(e, __err);
			return -1;
		}
		fly_event_data_set(e, __p, (void *) req);
		//e->event_data = (void *) req;

		e->fail_close = fly_request_fail_close_handler;
		FLY_EVENT_EXPIRED_END_HANDLER(e, fly_request_timeout_handler, req);
		return fly_request_event_handler(e);
	case V2:
#ifdef DEBUG
	printf("WORKER: Start HTTP2 communication\n");
#endif
		//e->event_data = (void *) conn;
		fly_event_data_set(e, __p, conn);
		FLY_EVENT_END_HANDLER(e, fly_hv2_end_handle, conn);
		FLY_EVENT_EXPIRED_HANDLER(e, fly_hv2_timeout_handle, conn);
		return fly_hv2_init_handler(e);
	default:
		FLY_NOT_COME_HERE
	}
}
```


Overlapping Code:
```
ten_connected(fly_event_t *e)
{
#ifdef DEBUG
printf("WORKER: Listen socket is connected\n");
#endif
fly_connect_t *conn;
fly_request_t *req;
//conn = (fly_connect_t *) e->event_data;
conn = (fly_connect_t *) fly_event_data_get(e, __p);
e->read_or_write = FLY_READ;
/* event only modify (no add, no delete) */
e->flag = FLY_MODIFY;
e->tflag = FLY_INHERIT;
e->eflag = 0;
//e->event_state = (void *) EFLY_REQUEST_STATE_INIT;
//e->event_fase = (void *) EFLY_REQUEST_FASE_INIT;
fly_event_state_set(e, __e, EFLY_REQUEST_STATE_INIT);
fly_event_fase_set(e, __e, EFLY_REQUEST_FASE_INIT);
fly_event_socket(e);
switch(FLY_CONNECT_HTTP_VERSION(conn)){
case V1_1:
#ifdef DEBUG
printf("WORKER: Start HTTP1.1 communication\n");
#endif
req = fly_request_init(conn);
if (fly_unlikely_null(req)){
struct fly_err *__err;
__err = fly_event_err_init(
e, errno, FLY_ERR_ERR,
"request init error."
);
fly_event_error_add(e, __err);
return -1;
}
fly_event_data_set(e, __p, (void *) req);
//e->event_data = (void *) req;
e->fail_close = fly_request_fail_close_handler;
FLY_EVENT_EXPIRED_END_HANDLER(e, fly_request_timeout_handler, req);
return fly_request_event_handler(e);
case V2:
#ifdef DEBUG
printf("WORKER: Start HTTP2 communication\n");
#endif
//e->event_data = (void *) conn;
fly_event_data_set(e, __p, conn);
FLY_EVENT_END_HANDLER(e, fly_hv2_end_handle, conn);
FLY_EVENT_EXPIRED_HANDLER(e, fly_hv2_timeout_handle, conn);
return fly_hv2_init_handler(e);
default:
FLY_N
```
<Overlap Ratio: 0.9817197020988491>

---

--- 298 --
Question ID: c39c08f483f1ceba4cbcd9602bbf4a06e950d049_11
Original Code:
```
void f11(void) {
    	volatile int8_t x46 = -1;
	int8_t x47 = -24;
	volatile int32_t x48 = INT32_MIN;
	int32_t t11 = -842;

    t11 = (((x45%x46)+x47)>x48);

    if (t11 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
;
int8_t x47 = -24;
volatile int32_t x48 = INT32_MIN;
int32_t t11 = -842;
t11 = (((x45%x46)+x47)>x48
```
<Overlap Ratio: 0.5524861878453039>

---

--- 299 --
Question ID: 11d763ae1d3315f8b8573c13bee3827f242a838d_3
Original Code:
```
extern void redirect_to(Router *router) {
    RouterStackFrame *frame = top_stack;
    do {
        PopupAndPopRouter *_router = frame->router;
        gtk_widget_destroy(_router->widget);
        gtk_widget_destroy(_router->headerBar);
        X_FREE(_router->router);
        frame = frame->pre;
    } while (frame != NULL);
    //重定向页面
    navigate_to(router);
}
```


Overlapping Code:
```
er) {
RouterStackFrame *frame = top_stack;
do {
PopupAndPopRouter *_router = frame->router;
gtk_widget_destroy(_router->widget);
gtk_widget_destroy(_router->headerBar);
X_FREE(_router->router);
frame = frame->pre;
} while (frame != NULL);
//重定向页面
nav
```
<Overlap Ratio: 0.819672131147541>

---

--- 300 --
Question ID: dec7331b40de319bbde7bb6d35dbbf2d7c7a120a_3
Original Code:
```
static void test_decode(dAT)
{
    apr_size_t elen;
    char src1[] = "%C3%80%E3%82%a2"; /* A_GRAVE KATAKANA_A as utf8 */
    unsigned char expect[6];

    AT_int_eq(apreq_decode((char *)expect, &elen, src1, sizeof(src1) -1), 
              APR_SUCCESS + APREQ_CHARSET_UTF8);
    AT_int_eq(elen, 5);
    AT_int_eq(expect[0], 0xC3);
    AT_int_eq(expect[1], 0x80);
    AT_int_eq(expect[2], 0xE3);
    AT_int_eq(expect[3], 0x82);
    AT_int_eq(expect[4], 0xA2);
}
```


Overlapping Code:
```
elen;
char src1[] = "%C3%80%E3%82%a2"; /* A_GRAVE KATAKANA_A as utf8 */
unsigned char expect[6];
AT_int_eq(apreq_decode((char *)expect, &elen, src1, sizeof(src1) -1), 
APR_SUCCESS + APREQ_CHARSET_UTF8);
AT_int_eq(elen, 5);
AT_int_eq(expect[0], 0xC3);
AT_int_eq(expect[1], 0x80);
AT_int_eq(expect[2], 0xE3);
AT_int_eq(expect[3], 0x82);
AT_int_eq(expect
```
<Overlap Ratio: 0.8645320197044335>

---

--- 301 --
Question ID: 3677bdd480e24f71a24755423a5d1fc5d8b816ef_6
Original Code:
```
static char *ucfg_string_escape(char *str)
{
	char *tmp, *res, *old_pos;

	tmp = old_pos = str;
	res = ucfg_xmalloc(1);
	*res = '\0';

	while ((tmp = strchr(tmp, '"')) != NULL) {
		int res_old_len = strlen(res) + 1;
		char *res_old_end;
		int new_len = res_old_len + (tmp - old_pos + 1) + 1;
		res = ucfg_xrealloc(res, new_len);
		res_old_end = res + strlen(res);
		strncpy(res_old_end, old_pos, tmp - old_pos + 1);
		*(res + new_len - 2) = '"';
		*(res + new_len - 1) = '\0';

		++tmp;
		old_pos = tmp;
	}

	{
		char *res_old_end;
		int new_len = strlen(res) + strlen(old_pos) + 1;
		res = ucfg_xrealloc(res, new_len);
		res_old_end = res + strlen(res);
		strcpy(res_old_end, old_pos);
	}

	return res;
}
```


Overlapping Code:
```
ng_escape(char *str)
{
char *tmp, *res, *old_pos;
tmp = old_pos = str;
res = ucfg_xmalloc(1);
*res = '\0';
while ((tmp = strchr(tmp, '"')) != NULL) {
int res_old_len = strlen(res) + 1;
char *res_old_end;
int new_len = res_old_len + (tmp - old_pos + 1) + 1;
res = ucfg_xrealloc(res, new_len);
res_old_end = res + strlen(res);
strncpy(res_old_end, old_pos, tmp - old_pos + 1);
*(res + new_len - 2) = '"';
*(res + new_len - 1) = '\0';
++tmp;
old_pos = tmp;
}
{
char *res_old_end;
int new_len = strlen(res) + strlen(old_pos) + 1;
res = ucfg_xrealloc(res, new_len);
res_old_end = res + strlen(res);
strcpy
```
<Overlap Ratio: 0.9077155824508321>

---

--- 302 --
Question ID: e06e1fcbc1de7c2ec1e14ac9875056f668698c74_166
Original Code:
```
void f166(void) {
    	uint16_t x765 = 449U;
	int16_t x766 = INT16_MIN;
	uint64_t x767 = 121163371584LLU;
	int8_t x768 = INT8_MIN;
	volatile int32_t t166 = 17917;

    t166 = (x765-(x766+(x767>x768)));

    if (t166 != 33217) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
766 = INT16_MIN;
uint64_t x767 = 121163371584LLU;
int8_t x768 = INT8_MIN;
volatile int32_t t166 = 17917;
t166 = (x765-(x766+(x767>x768)));
if (t166 !=
```
<Overlap Ratio: 0.6521739130434783>

---

--- 303 --
Question ID: 8ae5bfef6ce9d4f3765a9df958d4f94e40e91c88_80
Original Code:
```
void f80(void) {
    	uint8_t x429 = 11U;
	int16_t x430 = 6;
	volatile int32_t t80 = 41;

    t80 = ((x429*x430)!=(x431%x432));

    if (t80 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
;
int16_t x430 = 6;
volatile int32_t t80 = 41;
t80 = ((x429*x430)!=(x431%x432));
if (t80 != 1) { NG(
```
<Overlap Ratio: 0.6535947712418301>

---

--- 304 --
Question ID: 0ae14efbb8577eadb35835402c6fd84988df5651_169
Original Code:
```
void f169(void) {
    	uint32_t x1385 = 550U;
	int16_t x1386 = -1;
	volatile uint32_t t169 = 415203289U;

    t169 = (x1385<<(x1386>(x1387-x1388)));

    if (t169 != 550U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x1386 = -1;
volatile uint32_t t169 = 415203289U;
t169 = (x1385<<(x1386>(x1387-x1388)));
if (t169 !=
```
<Overlap Ratio: 0.5617977528089888>

---

--- 305 --
Question ID: da821485f0bb9d75336361b21ad5296793fd7c9f_6
Original Code:
```
x_int x_async_block(x_int fd, x_int timeout) {
  x_async_entry entry = x_async_get(fd);
  x_status status;
  if(entry) {

    /*
    ** Check if we received data before we entered the call.
    */ 

    if(entry->flags) {
      entry->flags = 0;
      entry->count--;
      return 0;
    }
   
    /*
    ** Enter the monitor.
    */
    
    status = x_monitor_eternal(&entry->monitor);

    /*
    ** Check once again if something changed while we 
    ** acquired the monitor.
    */
    
    if(entry->flags) {
      entry->flags = 0;
      x_monitor_exit(&entry->monitor);
      entry->count--;
      return 0;
    }
   
    /*
    ** Wait until we are notified by the signal handler.
    */
    
    status = x_monitor_wait(&entry->monitor, timeout);

    /*
    ** We've been notified (or a timeout has occured). 
    */

    if(status == xs_success) {
      x_monitor_exit(&entry->monitor);
    }

    if(entry->flags == 1) {
      
      /*
      ** There's new data.
      */

      loempa(LEVEL, "New data on %d\n", fd);
      
      entry->flags = 0;

      entry->count--;
      return 0;
    }
    else {

      /*
      ** Timeout.
      */
      
      loempa(LEVEL, "Timeout on %d\n", fd);
      entry->count--;
      return -1;
    }
    entry->count--;
  }
  else {
    loempa(9, "No entry for fd %d\n", fd);
    x_thread_sleep(2);
  }
  return xs_success;
}
```


Overlapping Code:
```
, x_int timeout) {
x_async_entry entry = x_async_get(fd);
x_status status;
if(entry) {
/*
** Check if we received data before we entered the call.
*/ 
if(entry->flags) {
entry->flags = 0;
entry->count--;
return 0;
}

/*
** Enter the monitor.
*/

status = x_monitor_eternal(&entry->monitor);
/*
** Check once again if something changed while we 
** acquired the monitor.
*/

if(entry->flags) {
entry->flags = 0;
x_monitor_exit(&entry->monitor);
entry->count--;
return 0;
}

/*
** Wait until we are notified by the signal handler.
*/

status = x_monitor_wait(&entry->monitor, timeout);
/*
** We've been notified (or a timeout has occured). 
*/
if(status == xs_success) {
x_monitor_exit(&entry->monitor);
}
if(entry->flags == 1) {

/*
** There's new data.
*/
loempa(LEVEL, "New data on %d\n", fd);

entry->flags = 0;
entry->count--;
return 0;
}
else {
/*
** Timeout.
*/

loempa(LEVEL, "Timeout on %d\n", fd);
entry->count--;
return -1;
}
entry->count--;
}
else {
loempa(9, "No entry for fd %d\n", fd);
x
```
<Overlap Ratio: 0.9363295880149812>

---

--- 306 --
Question ID: 112a0283d3219861dee15da0023cf483a7ab8544_19
Original Code:
```
void ds3_head_object_response_free(ds3_head_object_response* response) {
    if (response == NULL) {
        return;
    }
    if (response->blob_checksum_type != NULL) {
        g_free(response->blob_checksum_type);
    }
    if (response->metadata != NULL) {
        ds3_metadata_free(response->metadata);
    }
    if (response->blob_checksums != NULL) {
        ds3_uint64_string_map_free(response->blob_checksums);
    }

    g_free(response);
}
```


Overlapping Code:
```
t_response_free(ds3_head_object_response* response) {
if (response == NULL) {
return;
}
if (response->blob_checksum_type != NULL) {
g_free(response->blob_checksum_type);
}
if (response->metadata != NULL) {
ds3_metadata_free(response->metadata);
}
if (response->blob_checksums != NULL) {
ds3_uint64_string_map_free(response->blob_checksums);
}
g_free(
```
<Overlap Ratio: 0.9186351706036745>

---

--- 307 --
Question ID: e1fca168d0dcdc24260aa83608473b16aabcc58e_128
Original Code:
```
void f128(void) {
    	static int32_t x513 = -1004604;
	uint32_t x515 = UINT32_MAX;
	uint64_t x516 = 16178658281212569LLU;
	volatile uint64_t t128 = 121078591799929LLU;

    t128 = (x513|((x514<=x515)*x516));

    if (t128 != 18446744073709284317LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int32_t x513 = -1004604;
uint32_t x515 = UINT32_MAX;
uint64_t x516 = 16178658281212569LLU;
volatile uint64_t t128 = 121078591799929LLU;
t128 = (x513|((x514<=x515)*x516));
if (t128 != 18446744073709284
```
<Overlap Ratio: 0.78125>

---

--- 308 --
Question ID: cee00d736b2161c3a3e6097f660b354dbbab46fb_6
Original Code:
```
static status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk)
{
    status_t retCode = STATUS_SUCCESS;
    
    retCode = CLOCK_DRV_SetSystemClock(NULL,sysClk);

    return retCode;
}
```


Overlapping Code:
```
ic status_t POWER_DRV_UpdateInitClk(const sys_clk_config_t * const sysClk)
{
status_t retCode = STATUS_SUCCESS;

retCode = CLOCK_DRV_SetSystemClock(NU
```
<Overlap Ratio: 0.819672131147541>

---

--- 309 --
Question ID: 9baa7a16d1be2d6e29f3e865a79755b6ed722665_4
Original Code:
```
void
MachineCheckException(struct pt_regs *regs)
{
	unsigned long fixup, val;
#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
	u32 value2;
	int corr_ecc = 0;
	int uncorr_ecc = 0;
#endif

	if ((fixup = search_exception_table(regs->nip)) != 0) {
		regs->nip = fixup;
		val = mfspr(MCSR);
		/* Clear MCSR */
		mtspr(SPRN_MCSR, val);
		return;
	}

#if defined(CONFIG_CMD_KGDB)
	if (debugger_exception_handler && (*debugger_exception_handler)(regs))
		return;
#endif

	printf("Machine Check Exception.\n");
	printf("Caused by (from msr): ");
	printf("regs %p ", regs);

	val = get_esr();

#if !defined(CONFIG_440) && !defined(CONFIG_405EX)
	if (val& ESR_IMCP) {
		printf("Instruction");
		mtspr(ESR, val & ~ESR_IMCP);
	} else {
		printf("Data");
	}
	printf(" machine check.\n");

#elif defined(CONFIG_440) || defined(CONFIG_405EX)
	if (val& ESR_IMCP){
		printf("Instruction Synchronous Machine Check exception\n");
		mtspr(SPRN_ESR, val & ~ESR_IMCP);
	} else {
		val = mfspr(MCSR);
		if (val & MCSR_IB)
			printf("Instruction Read PLB Error\n");
#if defined(CONFIG_440)
		if (val & MCSR_DRB)
			printf("Data Read PLB Error\n");
		if (val & MCSR_DWB)
			printf("Data Write PLB Error\n");
#else
		if (val & MCSR_DB)
			printf("Data PLB Error\n");
#endif
		if (val & MCSR_TLBP)
			printf("TLB Parity Error\n");
		if (val & MCSR_ICP){
			/*flush_instruction_cache(); */
			printf("I-Cache Parity Error\n");
		}
		if (val & MCSR_DCSP)
			printf("D-Cache Search Parity Error\n");
		if (val & MCSR_DCFP)
			printf("D-Cache Flush Parity Error\n");
		if (val & MCSR_IMPE)
			printf("Machine Check exception is imprecise\n");

		/* Clear MCSR */
		mtspr(SPRN_MCSR, val);
	}

#if defined(CONFIG_DDR_ECC) && defined(CONFIG_SDRAM_PPC4xx_IBM_DDR2)
	/*
	 * Read and print ECC status register/info:
	 * The faulting address is only known upon uncorrectable ECC
	 * errors.
	 */
	mfsdram(SDRAM_ECCES, val);
	if (val & SDRAM_ECCES_CE)
		printf("ECC: Correctable error\n");
	if (val & SDRAM_ECCES_UE) {
		printf("ECC: Uncorrectable error at 0x%02x%08x\n",
		       mfdcr(SDRAM_ERRADDULL), mfdcr(SDRAM_ERRADDLLL));
	}
#endif /* CONFIG_DDR_ECC ... */

#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
	mfsdram(DDR0_00, val) ;
	printf("DDR0: DDR0_00 %lx\n", val);
	val = (val >> 16) & 0xff;
	if (val & 0x80)
		printf("DDR0: At least one interrupt active\n");
	if (val & 0x40)
		printf("DDR0: DRAM initialization complete.\n");
	if (val & 0x20) {
		printf("DDR0: Multiple uncorrectable ECC events.\n");
		uncorr_ecc = 1;
	}
	if (val & 0x10) {
		printf("DDR0: Single uncorrectable ECC event.\n");
		uncorr_ecc = 1;
	}
	if (val & 0x08) {
		printf("DDR0: Multiple correctable ECC events.\n");
		corr_ecc = 1;
	}
	if (val & 0x04) {
		printf("DDR0: Single correctable ECC event.\n");
		corr_ecc = 1;
	}
	if (val & 0x02)
		printf("Multiple accesses outside the defined"
		       " physical memory space detected\n");
	if (val & 0x01)
		printf("DDR0: Single access outside the defined"
		       " physical memory space detected.\n");

	mfsdram(DDR0_01, val);
	val = (val >> 8) & 0x7;
	switch (val ) {
	case 0:
		printf("DDR0: Write Out-of-Range command\n");
		break;
	case 1:
		printf("DDR0: Read Out-of-Range command\n");
		break;
	case 2:
		printf("DDR0: Masked write Out-of-Range command\n");
		break;
	case 4:
		printf("DDR0: Wrap write Out-of-Range command\n");
		break;
	case 5:
		printf("DDR0: Wrap read Out-of-Range command\n");
		break;
	default:
		mfsdram(DDR0_01, value2);
		printf("DDR0: No DDR0 error know 0x%lx %x\n", val, value2);
	}
	mfsdram(DDR0_23, val);
	if (((val >> 16) & 0xff) && corr_ecc)
		printf("DDR0: Syndrome for correctable ECC event 0x%lx\n",
		       (val >> 16) & 0xff);
	mfsdram(DDR0_23, val);
	if (((val >> 8) & 0xff) && uncorr_ecc)
		printf("DDR0: Syndrome for uncorrectable ECC event 0x%lx\n",
		       (val >> 8) & 0xff);
	mfsdram(DDR0_33, val);
	if (val)
		printf("DDR0: Address of command that caused an "
		       "Out-of-Range interrupt %lx\n", val);
	mfsdram(DDR0_34, val);
	if (val && uncorr_ecc)
		printf("DDR0: Address of uncorrectable ECC event %lx\n", val);
	mfsdram(DDR0_35, val);
	if (val && uncorr_ecc)
		printf("DDR0: Address of uncorrectable ECC event %lx\n", val);
	mfsdram(DDR0_36, val);
	if (val && uncorr_ecc)
		printf("DDR0: Data of uncorrectable ECC event 0x%08lx\n", val);
	mfsdram(DDR0_37, val);
	if (val && uncorr_ecc)
		printf("DDR0: Data of uncorrectable ECC event 0x%08lx\n", val);
	mfsdram(DDR0_38, val);
	if (val && corr_ecc)
		printf("DDR0: Address of correctable ECC event %lx\n", val);
	mfsdram(DDR0_39, val);
	if (val && corr_ecc)
		printf("DDR0: Address of correctable ECC event %lx\n", val);
	mfsdram(DDR0_40, val);
	if (val && corr_ecc)
		printf("DDR0: Data of correctable ECC event 0x%08lx\n", val);
	mfsdram(DDR0_41, val);
	if (val && corr_ecc)
		printf("DDR0: Data of correctable ECC event 0x%08lx\n", val);
#endif /* CONFIG_440EPX */
#endif /* CONFIG_440 */
	show_regs(regs);
	print_backtrace((unsigned long *)regs->gpr[1]);
	panic("machine check");
}
```


Overlapping Code:
```
oid
MachineCheckException(struct pt_regs *regs)
{
unsigned long fixup, val;
#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
u32 value2;
int corr_ecc = 0;
int uncorr_ecc = 0;
#endif
if ((fixup = search_exception_table(regs->nip)) != 0) {
regs->nip = fixup;
val = mfspr(MCSR);
/* Clear MCSR */
mtspr(SPRN_MCSR, val);
return;
}
#if defined(CONFIG_CMD_KGDB)
if (debugger_exception_handler && (*debugger_exception_handler)(regs))
return;
#endif
printf("Machine Check Exception.\n");
printf("Caused by (from msr): ");
printf("regs %p ", regs);
val = get_esr();
#if !defined(CONFIG_440) && !defined(CONFIG_405EX)
if (val& ESR_IMCP) {
printf("Instruction");
mtspr(ESR, val & ~ESR_IMCP);
} else {
printf("Data");
}
printf(" machine check.\n");
#elif defined(CONFIG_440) || defined(CONFIG_405EX)
if (val& ESR_IMCP){
printf("Instruction Synchronous Machine Check exception\n");
mtspr(SPRN_ESR, val & ~ESR_IMCP);
} else {
val = mfspr(MCSR);
if (val & MCSR_IB)
printf("Instruction Read PLB Error\n");
#if defined(CONFIG_440)
if (val & MCSR_DRB)
printf("Data Read PLB Error\n");
if (val & MCSR_DWB)
printf("Data Write PLB Error\n");
#else
if (val & MCSR_DB)
printf("Data PLB Error\n");
#endif
if (val & MCSR_TLBP)
printf("TLB Parity Error\n");
if (val & MCSR_ICP){
/*flush_instruction_cache(); */
printf("I-Cache Parity Error\n");
}
if (val & MCSR_DCSP)
printf("D-Cache Search Parity Error\n");
if (val & MCSR_DCFP)
printf("D-Cache Flush Parity Error\n");
if (val & MCSR_IMPE)
printf("Machine Check exception is imprecise\n");
/* Clear MCSR */
mtspr(SPRN_MCSR, val);
}
#if defined(CONFIG_DDR_ECC) && defined(CONFIG_SDRAM_PPC4xx_IBM_DDR2)
/*
* Read and print ECC status register/info:
* The faulting address is only known upon uncorrectable ECC
* errors.
*/
mfsdram(SDRAM_ECCES, val);
if (val & SDRAM_ECCES_CE)
printf("ECC: Correctable error\n");
if (val & SDRAM_ECCES_UE) {
printf("ECC: Uncorrectable error at 0x%02x%08x\n",
mfdcr(SDRAM_ERRADDULL), mfdcr(SDRAM_ERRADDLLL));
}
#endif /* CONFIG_DDR_ECC ... */
#if defined(CONFIG_440EPX) || defined(CONFIG_440GRX)
mfsdram(DDR0_00, val) ;
printf("DDR0: DDR0_00 %lx\n", val);
val = (val >> 16) & 0xff;
if (val & 0x80)
printf("DDR0: At least one interrupt active\n");
if (val & 0x40)
printf("DDR0: DRAM initialization complete.\n");
if (val & 0x20) {
printf("DDR0: Multiple uncorrectable ECC events.\n");
uncorr_ecc
```
<Overlap Ratio: 0.9987250318742031>

---

--- 310 --
Question ID: f9efc9637582639099c097b544d08428b5e0fd40_3
Original Code:
```
int ls_gui(void)
{
	int file_num;
	struct RECT t;
	int idx;

	ST->ConOut->ClearScreen(ST->ConOut);

	file_num = ls();

	t.x = 0;
	t.y = 0;
	t.w = (MAX_FILE_NAME_LEN - 1) * WIDTH_PER_CH;
	t.h = HEIGHT_PER_CH;
	for (idx = 0; idx < file_num; idx++) {
		file_list[idx].rect.x = t.x;
		file_list[idx].rect.y = t.y;
		file_list[idx].rect.w = t.w;
		file_list[idx].rect.h = t.h;
		draw_rect(file_list[idx].rect, white);
		t.x += file_list[idx].rect.w + WIDTH_PER_CH;

		file_list[idx].is_highlight = FALSE;
	}

	return file_num;
}
```


Overlapping Code:
```
_num;
struct RECT t;
int idx;
ST->ConOut->ClearScreen(ST->ConOut);
file_num = ls();
t.x = 0;
t.y = 0;
t.w = (MAX_FILE_NAME_LEN - 1) * WIDTH_PER_CH;
t.h = HEIGHT_PER_CH;
for (idx = 0; idx < file_num; idx++) {
file_list[idx].rect.x = t.x;
file_list[idx].rect.y = t.y;
file_list[idx].rect.w = t.w;
file_list[idx].rect.h = t.h;
draw_rect(file_list[idx].rect, white);
t.x += file_list[idx].rect.w + WIDTH_PER_CH;
file_list[idx].is_highlight = FALSE;
}
ret
```
<Overlap Ratio: 0.9146341463414634>

---

--- 311 --
Question ID: 0347a96adfe6f601378e47b58790e10998759cdd_194
Original Code:
```
void f194(void) {
    	static int16_t x809 = INT16_MIN;
	static volatile uint32_t x810 = 2092U;
	static int32_t x811 = -1;
	int8_t x812 = INT8_MIN;
	volatile uint32_t t194 = 75247U;

    t194 = ((x809/(x810^x811))^x812);

    if (t194 != 4294967168U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
static int16_t x809 = INT16_MIN;
static volatile uint32_t x810 = 2092U;
static int32_t x811 = -1;
int8_t x812 = INT8_MIN;
volatile uint32_t t194 = 75247U;
t194 = ((x809/(x810^x811))^x812);
if
```
<Overlap Ratio: 0.7843137254901961>

---

--- 312 --
Question ID: c64ce7a39e94680723124982cf780aff71b4ef96_1
Original Code:
```
MC_TARGET_FUNC int mc_zlogspace1xnff(const int n, double * x_r, double * x_i, const float x1_r, const float x1_i, const float x2_r, const float x2_i)
{
//!# Requires x[n] where 1 < n. Draws a logspace: generates a logarithmically spaced
//!# vector `x`, i.e n points with spacing between points being (x2-x1)/(n-1).
	int i = 1;
	double stepr, stepi, x1rd, x1id, x2rd, x2id;
	if (n > 0) {
		x1rd = mc_cast(double, x1_r);
		x1id = mc_cast(double, x1_i);
		x2rd = mc_cast(double, x2_r);
		x2id = mc_cast(double, x2_i);
		if (n < 2) {
			mc_zpow10(&x_r[0], &x_i[0], x2rd, x2id);
		} else if (n < 3) {
			mc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);
			mc_zpow10(&x_r[1], &x_i[1], x2rd, x2id);
		} else {
			mc_zsub(&stepr, &stepi, x2rd, x2id, x1rd, x1id);
			mc_zdiv(&stepr, &stepi, stepr, stepi, mc_cast(double, (n - 1)), 0.0);
			mc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);
			mc_zpow10(&x_r[(n - 1)], &x_i[(n - 1)], x2rd, x2id);
			for (; i < (n - 1); i++) {
				mc_zmul(&x_r[i], &x_i[i], mc_cast(double, i), 0.0, stepr, stepi);
				mc_zadd(&x_r[i], &x_i[i], x1rd, x1id, x_r[i], x_i[i]);
				mc_zpow10(&x_r[i], &x_i[i], x_r[i], x_i[i]);
			}
		}
		return 0;
	}
	return -1;
}
```


Overlapping Code:
```
RGET_FUNC int mc_zlogspace1xnff(const int n, double * x_r, double * x_i, const float x1_r, const float x1_i, const float x2_r, const float x2_i)
{
//!# Requires x[n] where 1 < n. Draws a logspace: generates a logarithmically spaced
//!# vector `x`, i.e n points with spacing between points being (x2-x1)/(n-1).
int i = 1;
double stepr, stepi, x1rd, x1id, x2rd, x2id;
if (n > 0) {
x1rd = mc_cast(double, x1_r);
x1id = mc_cast(double, x1_i);
x2rd = mc_cast(double, x2_r);
x2id = mc_cast(double, x2_i);
if (n < 2) {
mc_zpow10(&x_r[0], &x_i[0], x2rd, x2id);
} else if (n < 3) {
mc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);
mc_zpow10(&x_r[1], &x_i[1], x2rd, x2id);
} else {
mc_zsub(&stepr, &stepi, x2rd, x2id, x1rd, x1id);
mc_zdiv(&stepr, &stepi, stepr, stepi, mc_cast(double, (n - 1)), 0.0);
mc_zpow10(&x_r[0], &x_i[0], x1rd, x1id);
mc_zpow10(&x_r[(n - 1)], &x_i[(n - 1)], x2rd, x2id);
for (; i < (n - 1); i++) {
mc_zmul(&x_r[i], &x_i[i], mc_cast(double, i), 0.0, stepr, stepi);
mc_zadd(&x_r[i], &x_i[i], x1rd, x1id, x_r[i], x_i[i]);
mc_zpow10(&x_r[i], &x_i[i], x_r[i], x_i[i]);
}
}
return 0;
}

```
<Overlap Ratio: 0.9846014492753623>

---

--- 313 --
Question ID: 9ecaf6a1e8475de4743f551784c667b1b5e7873e_18
Original Code:
```
static int skl_platform_soc_open(struct snd_soc_component *component,
				 struct snd_pcm_substream *substream)
{
	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
	struct snd_soc_dai_link *dai_link = rtd->dai_link;

	dev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, "In %s:%s\n", __func__,
					dai_link->cpus->dai_name);

	snd_soc_set_runtime_hwparams(substream, &azx_pcm_hw);

	return 0;
}
```


Overlapping Code:
```
 skl_platform_soc_open(struct snd_soc_component *component,
struct snd_pcm_substream *substream)
{
struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
struct snd_soc_dai_link *dai_link = rtd->dai_link;
dev_dbg(asoc_rtd_to_cpu(rtd, 0)->dev, "In %s:%s\n", __func__,
dai_link->cpus->dai_name);
snd_soc_set_runtime_hwparams(substream, &az
```
<Overlap Ratio: 0.9162303664921466>

---

--- 314 --
Question ID: a934582750652266faeeb771f39732d6e881669d_51
Original Code:
```
UPB_INLINE envoy_config_cluster_v3_Cluster_EdsClusterConfig* envoy_config_cluster_v3_Cluster_EdsClusterConfig_parse_ex(const char* buf, size_t size,
                           const upb_ExtensionRegistry* extreg,
                           int options, upb_Arena* arena) {
  envoy_config_cluster_v3_Cluster_EdsClusterConfig* ret = envoy_config_cluster_v3_Cluster_EdsClusterConfig_new(arena);
  if (!ret) return NULL;
  if (upb_Decode(buf, size, ret, &envoy_config_cluster_v3_Cluster_EdsClusterConfig_msginit, extreg, options, arena) !=
      kUpb_DecodeStatus_Ok) {
    return NULL;
  }
  return ret;
}
```


Overlapping Code:
```
INLINE envoy_config_cluster_v3_Cluster_EdsClusterConfig* envoy_config_cluster_v3_Cluster_EdsClusterConfig_parse_ex(const char* buf, size_t size,
const upb_ExtensionRegistry* extreg,
int options, upb_Arena* arena) {
envoy_config_cluster_v3_Cluster_EdsClusterConfig* ret = envoy_config_cluster_v3_Cluster_EdsClusterConfig_new(arena);
if (!ret) return NULL;
if (upb_Decode(buf, size, ret, &envoy_config_cluster_v3_Cluster_EdsClusterConfig_msginit, extreg, options, arena) !=
kUpb_DecodeStatus_Ok) {
return NULL;
}
return ret;
}
```
<Overlap Ratio: 0.9924242424242424>

---

--- 315 --
Question ID: 40546866bac9817b0beb32f25d3e9fe197eee232_169
Original Code:
```
void f169(void) {
    	uint16_t x885 = UINT16_MAX;
	static int8_t x886 = -1;
	int16_t x887 = INT16_MIN;
	int8_t x888 = -1;
	int32_t t169 = -1971;

    t169 = ((x885&x886)==(x887*x888));

    if (t169 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
MAX;
static int8_t x886 = -1;
int16_t x887 = INT16_MIN;
int8_t x888 = -1;
int32_t t169 = -1971;
t169 = ((x885&x886)==(x887*x888));
if (t169 != 0) { NG
```
<Overlap Ratio: 0.7142857142857143>

---

--- 316 --
Question ID: 4896ac1414bc8d0862f28eb473d2688fb392d8a7_16
Original Code:
```
void f16(void) {
    	static int32_t x65 = INT32_MIN;
	static uint64_t x66 = 49240951543LLU;
	volatile int8_t x68 = -1;
	volatile uint64_t t16 = UINT64_MAX;

    t16 = (((x65|x66)&x67)|x68);

    if (t16 != UINT64_MAX) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 f16(void) {
static int32_t x65 = INT32_MIN;
static uint64_t x66 = 49240951543LLU;
volatile int8_t x68 = -1;
volatile uint64_t t16 = UINT64_MAX;
t16 = (((x65|x66)&x67)|x68);
if (t16 != UINT64_MAX) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.9821428571428571>

---

--- 317 --
Question ID: 4d56aa6bcfa96abea99b9d6ed0e5178a1ec6adbe_0
Original Code:
```
class boyerMoore {
    private:
        string needle;
        vector<int> gsv;

        void goodSuffixVec(const string& s, vector<int> &v);

        ssize_t crfind(const string& str, const char c, size_t pos);

    public:
        boyerMoore(const string& needle);

        bool bmC(const string& haystack);
}
```


Overlapping Code:
```
needle;
vector<int> gsv;
void goodSuffixVec(const string& s, vector<int> &v);
ssize_t crfind(const string& str, const char c, size_t pos);
public:
boyerMoore(const string& needle);
bool bmC(const stri
```
<Overlap Ratio: 0.796812749003984>

---

--- 318 --
Question ID: 9ad7cdaac9b2326c83825023a0287f7f465e4115_35
Original Code:
```
static int8_t get_wrist_gest_config(struct bmi2_wrist_gest_config *config, struct bmi2_dev *dev)
{
    /* Variable to define error */
    int8_t rslt;

    /* Array to define the feature configuration */
    uint8_t feat_config[BMI2_FEAT_SIZE_IN_BYTES] = { 0 };

    /* Variable to define the array offset */
    uint8_t idx = 0;

    /* Variable to set flag */
    uint8_t feat_found;

    /* Initialize feature configuration for wrist gesture */
    struct bmi2_feature_config wrist_gest_config = { 0, 0, 0 };

    /* Copy the feature configuration address to a local pointer */
    uint16_t *data_p = (uint16_t *) (void *)feat_config;

    /* Search for wrist gesture feature and extract its configuration details */
    feat_found = bmi2_extract_input_feat_config(&wrist_gest_config, BMI2_WRIST_GESTURE, dev);
    if (feat_found)
    {
        /* Get the configuration from the page where wrist gesture feature  resides */
        rslt = bmi2_get_feat_config(wrist_gest_config.page, feat_config, dev);
        if (rslt == BMI2_OK)
        {
            /* Define the offset in bytes for wrist gesture select */
            idx = wrist_gest_config.start_addr;

            /* Get offset in words since all the features are set in words length */
            idx = idx / 2;

            /* Get wearable arm */
            config->wearable_arm = (*(data_p + idx) & BMI2_WRIST_GEST_WEAR_ARM_MASK) >> BMI2_WRIST_GEST_WEAR_ARM_POS;

            /* Increment the offset by 1 word to get min_flick_peak */
            idx++;
            config->min_flick_peak = *(data_p + idx);

            /* Increment the offset by 1 word to get min_flick_samples */
            idx++;
            config->min_flick_samples = *(data_p + idx);

            /* Increment the offset by 1 word to get max_duration */
            idx++;
            config->max_duration = *(data_p + idx);
        }
    }
    else
    {
        rslt = BMI2_E_INVALID_SENSOR;
    }

    return rslt;
}
```


Overlapping Code:
```
 int8_t get_wrist_gest_config(struct bmi2_wrist_gest_config *config, struct bmi2_dev *dev)
{
/* Variable to define error */
int8_t rslt;
/* Array to define the feature configuration */
uint8_t feat_config[BMI2_FEAT_SIZE_IN_BYTES] = { 0 };
/* Variable to define the array offset */
uint8_t idx = 0;
/* Variable to set flag */
uint8_t feat_found;
/* Initialize feature configuration for wrist gesture */
struct bmi2_feature_config wrist_gest_config = { 0, 0, 0 };
/* Copy the feature configuration address to a local pointer */
uint16_t *data_p = (uint16_t *) (void *)feat_config;
/* Search for wrist gesture feature and extract its configuration details */
feat_found = bmi2_extract_input_feat_config(&wrist_gest_config, BMI2_WRIST_GESTURE, dev);
if (feat_found)
{
/* Get the configuration from the page where wrist gesture feature resides */
rslt = bmi2_get_feat_config(wrist_gest_config.page, feat_config, dev);
if (rslt == BMI2_OK)
{
/* Define the offset in bytes for wrist gesture select */
idx = wrist_gest_config.start_addr;
/* Get offset in words since all the features are set in words length */
idx = idx / 2;
/* Get wearable arm */
config->wearable_arm = (*(data_p + idx) & BMI2_WRIST_GEST_WEAR_ARM_MASK) >> BMI2_WRIST_GEST_WEAR_ARM_POS;
/* Increment the offset by 1 word to get min_flick_peak */
idx++;
config->min_flick_peak = *(data_p + idx);
/* Increment the offset by 1 word to get min_flick_samples */
idx++;
config->min_flick_samples = *(data_p + idx);
/* Increment the offset by 1 word to get max_duration */
idx++;
config->max_duration = *(data_p + idx);
}
}
else
{
rslt = BMI2_E_INVALID_SENSOR;
}
return rslt;
}
```
<Overlap Ratio: 0.9963325183374083>

---

--- 319 --
Question ID: ee86086fd2bd422ccc3f8c8a02b18cc3e4b86548_32
Original Code:
```
void f32(void) {
    	static int64_t x141 = INT64_MAX;
	static volatile uint16_t x142 = 319U;
	volatile uint8_t x143 = UINT8_MAX;
	int8_t x144 = INT8_MAX;

    t32 = ((x141^x142)>(x143-x144));

    if (t32 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d) {
static int64_t x141 = INT64_MAX;
static volatile uint16_t x142 = 319U;
volatile uint8_t x143 = UINT8_MAX;
int8_t x144 = INT8_MAX;
t32 = ((x141^x142)>(x143-x144));
if (t32 != 1) { NG(); } else { ; }
```
<Overlap Ratio: 0.9308755760368663>

---

--- 320 --
Question ID: c84d728ac4bad4130b09537549c645d806d003af_181
Original Code:
```
void f181(void) {
    	int64_t x753 = 43647385928585022LL;
	int32_t x754 = INT32_MIN;
	static volatile int32_t t181 = 82084139;

    t181 = (((x753<=x754)/x755)==x756);

    if (t181 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```

int64_t x753 = 43647385928585022LL;
int32_t x754 = INT32_MIN;
static volatile int32_t t181 = 82084139;
t181 = (((x753<=x754)/x755)==x756);
if (t181 !
```
<Overlap Ratio: 0.7692307692307693>

---

--- 321 --
Question ID: 52f2f5b70cdc8c08ef85ee01e263c3777a459cf9_2
Original Code:
```
static void close_open_fds(list_t *keep_fds)
{
    list_t *open_fds = unixkit_get_open_fds();
    while (!list_empty(open_fds)) {
        int fd = as_intptr(list_pop_first(open_fds));
        if (!list_get(keep_fds, as_integer(fd)))
            close(fd);
    }
    destroy_list(open_fds);
}
```


Overlapping Code:
```

{
list_t *open_fds = unixkit_get_open_fds();
while (!list_empty(open_fds)) {
int fd = as_intptr(list_pop_first(open_fds));
if (!list_get(keep_fds, as_integer(fd)))
close(fd);
}
destroy_list(open_fds)
```
<Overlap Ratio: 0.8097165991902834>

---

--- 322 --
Question ID: 2d4dc4d554dbafc31c9a5aea9f7dac0d968755f4_1
Original Code:
```
void xxxLBoxCtlHScrollMultiColumn(
    PLBIV plb,
    INT cmd,
    INT xAmt)
{
    INT iTop = plb->iTop;

    CheckLock(plb->spwnd);

    if (!plb->cMac)  return;

    switch (cmd) {
    case SB_LINEUP:
        if (plb->fRightAlign)
            goto ReallyLineDown;
ReallyLineUp:
        iTop -= plb->itemsPerColumn;
        break;
    case SB_LINEDOWN:
        if (plb->fRightAlign)
            goto ReallyLineUp;
ReallyLineDown:
        iTop += plb->itemsPerColumn;
        break;
    case SB_PAGEUP:
        if (plb->fRightAlign)
            goto ReallyPageDown;
ReallyPageUp:
        iTop -= plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_PAGEDOWN:
        if (plb->fRightAlign)
            goto ReallyPageUp;
ReallyPageDown:
        iTop += plb->itemsPerColumn * plb->numberOfColumns;
        break;
    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        if (plb->fRightAlign) {
            int  iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;

            xAmt = iCols - (xAmt + plb->numberOfColumns);
            if (xAmt<0)
                xAmt=0;
        }
        iTop = xAmt * plb->itemsPerColumn;
        break;
    case SB_TOP:
        if (plb->fRightAlign)
            goto ReallyBottom;
ReallyTop:
        iTop = 0;
        break;
    case SB_BOTTOM:
        if (plb->fRightAlign)
            goto ReallyTop;
ReallyBottom:
        iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);
        break;
    case SB_ENDSCROLL:
        plb->fSmoothScroll = TRUE;
        xxxLBShowHideScrollBars(plb);
        break;
    }

    xxxNewITop(plb, iTop);
}
```


Overlapping Code:
```
umn(
PLBIV plb,
INT cmd,
INT xAmt)
{
INT iTop = plb->iTop;
CheckLock(plb->spwnd);
if (!plb->cMac) return;
switch (cmd) {
case SB_LINEUP:
if (plb->fRightAlign)
goto ReallyLineDown;
ReallyLineUp:
iTop -= plb->itemsPerColumn;
break;
case SB_LINEDOWN:
if (plb->fRightAlign)
goto ReallyLineUp;
ReallyLineDown:
iTop += plb->itemsPerColumn;
break;
case SB_PAGEUP:
if (plb->fRightAlign)
goto ReallyPageDown;
ReallyPageUp:
iTop -= plb->itemsPerColumn * plb->numberOfColumns;
break;
case SB_PAGEDOWN:
if (plb->fRightAlign)
goto ReallyPageUp;
ReallyPageDown:
iTop += plb->itemsPerColumn * plb->numberOfColumns;
break;
case SB_THUMBTRACK:
case SB_THUMBPOSITION:
if (plb->fRightAlign) {
int iCols = plb->cMac ? ((plb->cMac-1) / plb->itemsPerColumn) + 1 : 0;
xAmt = iCols - (xAmt + plb->numberOfColumns);
if (xAmt<0)
xAmt=0;
}
iTop = xAmt * plb->itemsPerColumn;
break;
case SB_TOP:
if (plb->fRightAlign)
goto ReallyBottom;
ReallyTop:
iTop = 0;
break;
case SB_BOTTOM:
if (plb->fRightAlign)
goto ReallyTop;
ReallyBottom:
iTop = plb->cMac - 1 - ((plb->cMac - 1) % plb->itemsPerColumn);
break;
case SB_ENDSCROLL:
plb->fSmoothScroll = TRUE;
xxxLBShowHideScrollBars(plb)
```
<Overlap Ratio: 0.9465020576131687>

---

--- 323 --
Question ID: 0206466cdfea6aa10391b9f97dcf84e24341b737_2
Original Code:
```
int eloop_register_timeout(unsigned int secs, unsigned int usecs,
			   void (*handler)(void *eloop_ctx, void *timeout_ctx),
			   void *eloop_data, void *user_data)
{
	struct eloop_timeout *timeout, *tmp, *prev;

	timeout = (struct eloop_timeout *) malloc(sizeof(*timeout));
	if (timeout == NULL)
		return -1;
	os_get_time(&timeout->time);
	timeout->time.sec += secs;
	timeout->time.usec += usecs;
	while (timeout->time.usec >= 1000000) {
		timeout->time.sec++;
		timeout->time.usec -= 1000000;
	}
	timeout->eloop_data = eloop_data;
	timeout->user_data = user_data;
	timeout->handler = handler;
	timeout->next = NULL;

	if (eloop.timeout == NULL) {
		eloop.timeout = timeout;
		return 0;
	}

	prev = NULL;
	tmp = eloop.timeout;
	while (tmp != NULL) {
		if (os_time_before(&timeout->time, &tmp->time))
			break;
		prev = tmp;
		tmp = tmp->next;
	}

	if (prev == NULL) {
		timeout->next = eloop.timeout;
		eloop.timeout = timeout;
	} else {
		timeout->next = prev->next;
		prev->next = timeout;
	}

	return 0;
}
```


Overlapping Code:
```
oop_register_timeout(unsigned int secs, unsigned int usecs,
void (*handler)(void *eloop_ctx, void *timeout_ctx),
void *eloop_data, void *user_data)
{
struct eloop_timeout *timeout, *tmp, *prev;
timeout = (struct eloop_timeout *) malloc(sizeof(*timeout));
if (timeout == NULL)
return -1;
os_get_time(&timeout->time);
timeout->time.sec += secs;
timeout->time.usec += usecs;
while (timeout->time.usec >= 1000000) {
timeout->time.sec++;
timeout->time.usec -= 1000000;
}
timeout->eloop_data = eloop_data;
timeout->user_data = user_data;
timeout->handler = handler;
timeout->next = NULL;
if (eloop.timeout == NULL) {
eloop.timeout = timeout;
return 0;
}
prev = NULL;
tmp = eloop.timeout;
while (tmp != NULL) {
if (os_time_before(&timeout->time, &tmp->time))
break;
prev = tmp;
tmp = tmp->next;
}
if (prev == NULL) {
timeout->next = eloop.timeout;
eloop.timeout = timeout;
} else {
timeout->next = prev->next;
prev->next = timeout;
}
return 0;
```
<Overlap Ratio: 0.9915254237288136>

---

--- 324 --
Question ID: ca1e5d348e65a5126ac5886709aca81a0c75db6b_19
Original Code:
```
void f19(void) {
    	int32_t x193 = INT32_MIN;
	int8_t x195 = -1;
	volatile uint32_t t19 = 79543459U;

    t19 = ((x193|x194)>>(x195!=x196));

    if (t19 != 1573719099U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x195 = -1;
volatile uint32_t t19 = 79543459U;
t19 = ((x193|x194)>>(x195!=x196));
if (t19 != 15737
```
<Overlap Ratio: 0.5617977528089888>

---

--- 325 --
Question ID: daa846f1b7ac7192372928f1cf5a457fb76c1f4b_0
Original Code:
```
interface RKOrbBasicProgram : NSObject {
    NSString                    *program;
    NSString                    *path;
    NSString                    *name;
    NSInteger                   startLineNumber;
    
    RKOrbBasicProgramLoadState  loadState;
    BOOL                        executeAfterLoading;
    BOOL                        aborting;
    
    NSMutableArray              *fragments;
}
```


Overlapping Code:
```
 {
NSString *program;
NSString *path;
NSString *name;
NSInteger startLineNumber;

RKOrbBasicProgramLoadState loadState;
BOOL executeAfterLoading;
BOOL
```
<Overlap Ratio: 0.6578947368421053>

---

--- 326 --
Question ID: 0acdfd64cd446cd17239fc74a012b0ac454e55e1_122
Original Code:
```
void f122(void) {
    	int64_t x505 = -807LL;
	static uint16_t x506 = 5313U;
	volatile int8_t x508 = -1;
	int64_t t122 = 518175566126565LL;

    t122 = (x505+((x506<=x507)/x508));

    if (t122 != -808LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
atic uint16_t x506 = 5313U;
volatile int8_t x508 = -1;
int64_t t122 = 518175566126565LL;
t122 = (x505+((x506<=x507)/x508));
if (t122 != -808LL) { NG()
```
<Overlap Ratio: 0.7142857142857143>

---

--- 327 --
Question ID: 7e3713f218a79f0cbd8c1fac34f82de256dbfd3c_193
Original Code:
```
void f193(void) {
    	int8_t x841 = INT8_MAX;
	static int32_t x843 = INT32_MAX;
	uint8_t x844 = 20U;
	volatile int32_t t193 = 3;

    t193 = ((x841*(x842<=x843))+x844);

    if (t193 != 147) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
id f193(void) {
int8_t x841 = INT8_MAX;
static int32_t x843 = INT32_MAX;
uint8_t x844 = 20U;
volatile int32_t t193 = 3;
t193 = ((x841*(x842<=x843))+x8
```
<Overlap Ratio: 0.7614213197969543>

---

--- 328 --
Question ID: 8ad70c405bd6ec2824dc6b0d8ce4d00532543551_11
Original Code:
```
double binomial(int n, int k) {
	if(n==0&&k==0) return 1;
	else if(k<0) return 0;
	else if(n<0) return 1;
	else if(n==0&&k!=0) return 0;

  double numerator;
  double denominator;
  int i;
  if(k>n) return 0;
  if(k > n/2) k = n-k;
  numerator = 1.0;
  denominator = 1.0;
  for(i = n-k+1; i <= n; i++) numerator *= (double)i;
  for(i = 2; i <= k; i++) denominator *= (double)i;
  return numerator/denominator;
}
```


Overlapping Code:
```
=0) return 1;
else if(k<0) return 0;
else if(n<0) return 1;
else if(n==0&&k!=0) return 0;
double numerator;
double denominator;
int i;
if(k>n) return 0;
if(k > n/2) k = n-k;
numerator = 1.0;
denominator = 1.0;
for(i = n-k+1; i <= n; i++) numerator *= (double)i;
for(i = 2; i <= k; i++) denominator *=
```
<Overlap Ratio: 0.7772020725388601>

---

--- 329 --
Question ID: 7f0be8f56cb0ee3fc0ab97b267d248662f960a94_51
Original Code:
```
void f51(void) {
    	int64_t x242 = -554525LL;
	volatile int8_t x243 = INT8_MIN;
	volatile uint64_t x244 = UINT64_MAX;
	uint64_t t51 = 51LLU;

    t51 = (((x241^x242)-x243)^x244);

    if (t51 != 554424LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
242 = -554525LL;
volatile int8_t x243 = INT8_MIN;
volatile uint64_t x244 = UINT64_MAX;
uint64_t t51 = 51LLU;
t51 = (((x241^x242)-x243)^x244);
if (t51 
```
<Overlap Ratio: 0.704225352112676>

---

--- 330 --
Question ID: 2eb030d8336b1b0892517afcd47a821f68997a5e_5
Original Code:
```
static inline void rv40_weak_loop_filter(uint8_t *src, const int step,
                                         const int filter_p1, const int filter_q1,
                                         const int alpha, const int beta,
                                         const int lim_p0q0,
                                         const int lim_q1, const int lim_p1,
                                         const int diff_p1p0, const int diff_q1q0,
                                         const int diff_p1p2, const int diff_q1q2)
{
    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
    int t, u, diff;

    t = src[0*step] - src[-1*step];
    if(!t)
        return;
    u = (alpha * FFABS(t)) >> 7;
    if(u > 3 - (filter_p1 && filter_q1))
        return;

    t <<= 2;
    if(filter_p1 && filter_q1)
        t += src[-2*step] - src[1*step];
    diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);
    src[-1*step] = cm[src[-1*step] + diff];
    src[ 0*step] = cm[src[ 0*step] - diff];
    if(FFABS(diff_p1p2) <= beta && filter_p1){
        t = (diff_p1p0 + diff_p1p2 - diff) >> 1;
        src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];
    }
    if(FFABS(diff_q1q2) <= beta && filter_q1){
        t = (diff_q1q0 + diff_q1q2 + diff) >> 1;
        src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];
    }
}
```


Overlapping Code:
```
tatic inline void rv40_weak_loop_filter(uint8_t *src, const int step,
const int filter_p1, const int filter_q1,
const int alpha, const int beta,
const int lim_p0q0,
const int lim_q1, const int lim_p1,
const int diff_p1p0, const int diff_q1q0,
const int diff_p1p2, const int diff_q1q2)
{
uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
int t, u, diff;
t = src[0*step] - src[-1*step];
if(!t)
return;
u = (alpha * FFABS(t)) >> 7;
if(u > 3 - (filter_p1 && filter_q1))
return;
t <<= 2;
if(filter_p1 && filter_q1)
t += src[-2*step] - src[1*step];
diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);
src[-1*step] = cm[src[-1*step] + diff];
src[ 0*step] = cm[src[ 0*step] - diff];
if(FFABS(diff_p1p2) <= beta && filter_p1){
t = (diff_p1p0 + diff_p1p2 - diff) >> 1;
src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];
}
if(FFABS(diff_q1q2) <= beta && filter_q1){
t = (diff_q1q0 + diff_q1q2 + diff) >> 1;
src[ 1*step] = cm[src[ 1*step] - CLIP
```
<Overlap Ratio: 0.975583864118896>

---

--- 331 --
Question ID: 43edf436e6a7bdb9f04275753393fe42f0ef416d_19
Original Code:
```
static cJSONZJ *create_reference(cJSONZJ *item)
{
    cJSONZJ *ref = cJSONZJ_New_Item();
    if (!ref)
        return 0;
    memcpy(ref, item, sizeof(cJSONZJ));
    ref->string = 0;
    ref->type |= cJSONZJ_IsReference;
    ref->next = ref->prev = 0;
    return ref;
}
```


Overlapping Code:
```
e(cJSONZJ *item)
{
cJSONZJ *ref = cJSONZJ_New_Item();
if (!ref)
return 0;
memcpy(ref, item, sizeof(cJSONZJ));
ref->string = 0;
ref->type |= cJSONZJ_IsReference;
ref->next = ref->prev = 0;
return ref;

```
<Overlap Ratio: 0.8620689655172413>

---

--- 332 --
Question ID: f5115da34d03b0bdff89113c9a4ce5a24528b7b8_0
Original Code:
```
void knapsack(item_t list[], int n, int w){
    int maxCost[BPackSIZE + 1] = {0};
    for(int i = 0; i < n; i++){
        int weight = list[i].weight;
        int cost = list[i].value;
        for(int j = w; j - weight >= 0; --j)
            if(maxCost[j] < maxCost[j - weight] + cost)maxCost[j] = maxCost[j - weight] + cost;
    }
    printf("%d\n", maxCost[BPackSIZE]);
}
```


Overlapping Code:
```
 n, int w){
int maxCost[BPackSIZE + 1] = {0};
for(int i = 0; i < n; i++){
int weight = list[i].weight;
int cost = list[i].value;
for(int j = w; j - weight >= 0; --j)
if(maxCost[j] < maxCost[j - weight] + cost)maxCost[j] = maxCost[j - weight] + cost;
}
printf("%d\n", maxCost[
```
<Overlap Ratio: 0.8566978193146417>

---

--- 333 --
Question ID: cfe5dc9c36758b6bac2ae509a37f90073dda6552_4
Original Code:
```
uint32_t coap_message_decode(coap_message_t *       p_message,
                             const uint8_t *        p_raw_message,
                             uint16_t               message_len)
{
    NULL_PARAM_CHECK(p_message);
    NULL_PARAM_CHECK(p_raw_message);

    // Check that the raw message contains the mandatory header.
    if (message_len < 4)
    {
        return (NRF_ERROR_INVALID_LENGTH | IOT_COAP_ERR_BASE);
    }

    // Parse the content of the raw message buffer.
    uint16_t byte_index = 0;

    // Parse the 4 byte CoAP header.
    p_message->header.version   = (p_raw_message[byte_index] >> 6);
    p_message->header.type      = (coap_msg_type_t)((p_raw_message[byte_index] >> 4) & 0x03);
    p_message->header.token_len = (p_raw_message[byte_index] & 0x0F);
    byte_index++;

    p_message->header.code      = (coap_msg_code_t)p_raw_message[byte_index];
    byte_index++;

    p_message->header.id        = p_raw_message[byte_index++] << 8;
    p_message->header.id       += p_raw_message[byte_index++];

    // Parse the token, if any.
    for (uint8_t index = 0; (byte_index < message_len) && (index < p_message->header.token_len); index++)
    {
        p_message->token[index]  = p_raw_message[byte_index++];
    }

    p_message->options_count = 0;
    p_message->options_delta = 0;

    // Parse the options if any.
    while ((byte_index < message_len) && (p_raw_message[byte_index] != COAP_PAYLOAD_MARKER))
    {

        uint32_t err_code;
        uint16_t byte_count = 0;

        err_code = decode_option(&p_raw_message[byte_index], p_message, &byte_count);
        if (err_code != NRF_SUCCESS)
        {
            return err_code;
        }

        p_message->options_count += 1;

        byte_index += byte_count;
    }

    // If there any more bytes to parse this would be the payload.
    if (byte_index < message_len)
    {
        // Verify that we have a payload marker.
        if (p_raw_message[byte_index] == COAP_PAYLOAD_MARKER)
        {
            byte_index++;
        }
        else
        {
            return COAP_MESSAGE_INVALID_CONTENT;
        }

        p_message->payload_len = message_len - byte_index;
        p_message->p_payload = (uint8_t *)&p_raw_message[byte_index];
    }

    return NRF_SUCCESS;
}
```


Overlapping Code:
```
t coap_message_decode(coap_message_t * p_message,
const uint8_t * p_raw_message,
uint16_t message_len)
{
NULL_PARAM_CHECK(p_message);
NULL_PARAM_CHECK(p_raw_message);
// Check that the raw message contains the mandatory header.
if (message_len < 4)
{
return (NRF_ERROR_INVALID_LENGTH | IOT_COAP_ERR_BASE);
}
// Parse the content of the raw message buffer.
uint16_t byte_index = 0;
// Parse the 4 byte CoAP header.
p_message->header.version = (p_raw_message[byte_index] >> 6);
p_message->header.type = (coap_msg_type_t)((p_raw_message[byte_index] >> 4) & 0x03);
p_message->header.token_len = (p_raw_message[byte_index] & 0x0F);
byte_index++;
p_message->header.code = (coap_msg_code_t)p_raw_message[byte_index];
byte_index++;
p_message->header.id = p_raw_message[byte_index++] << 8;
p_message->header.id += p_raw_message[byte_index++];
// Parse the token, if any.
for (uint8_t index = 0; (byte_index < message_len) && (index < p_message->header.token_len); index++)
{
p_message->token[index] = p_raw_message[byte_index++];
}
p_message->options_count = 0;
p_message->options_delta = 0;
// Parse the options if any.
while ((byte_index < message_len) && (p_raw_message[byte_index] != COAP_PAYLOAD_MARKER))
{
uint32_t err_code;
uint16_t byte_count = 0;
err_code = decode_option(&p_raw_message[byte_index], p_message, &byte_count);
if (err_code != NRF_SUCCESS)
{
return err_code;
}
p_message->options_count += 1;
byte_index += byte_count;
}
// If there any more bytes to parse this would be the payload.
if (byte_index < message_len)
{
// Verify that we have a payload marker.
if (p_raw_message[byte_index] == COAP_PAYLOAD_MARKER)
{
byte_index++;
}
else
{
return COAP_MESSAGE_INVALID_CONTENT;
}
p_message->payload_len = message_len - byte_index;
p_message->p_payload = (uint8_t *)&p_raw_message[byte_index];
```
<Overlap Ratio: 0.9830693610049154>

---

--- 334 --
Question ID: c474992d1e3ffb771d77bd73dceca31452a7a42c_123
Original Code:
```
void f123(void) {
    	static volatile uint64_t x721 = UINT64_MAX;
	int8_t x722 = -17;
	uint8_t x723 = 6U;
	uint8_t x724 = 1U;
	volatile uint64_t t123 = 1028967006146LLU;

    t123 = ((x721-x722)%(x723*x724));

    if (t123 != 4LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
{
static volatile uint64_t x721 = UINT64_MAX;
int8_t x722 = -17;
uint8_t x723 = 6U;
uint8_t x724 = 1U;
volatile uint64_t t123 = 1028967006146LLU;
t123 = ((x721-x722)%(x723*x724));
if (t123 != 4LLU) { 
```
<Overlap Ratio: 0.8438818565400844>

---

--- 335 --
Question ID: 302d1c97374c37ceb08b170405149fa65b1e670a_23
Original Code:
```
tb_bool_t tb_oc_number_uint32_set(tb_object_ref_t object, tb_uint32_t value)
{   
    // check
    tb_oc_number_t* number = tb_oc_number_cast(object);
    tb_assert_and_check_return_val(number, tb_false);

    // init value
    number->type = TB_OC_NUMBER_TYPE_UINT32;
    number->v.u32 = value;

    // ok
    return tb_true;
}
```


Overlapping Code:
```
c_number_uint32_set(tb_object_ref_t object, tb_uint32_t value)
{ 
// check
tb_oc_number_t* number = tb_oc_number_cast(object);
tb_assert_and_check_return_val(number, tb_false);
// init value
number->type = TB_OC_NUMBER_TYPE_UINT32;
number->v.u32 = value;
// ok
return
```
<Overlap Ratio: 0.9143835616438356>

---

--- 336 --
Question ID: 1579c76f9da9718851b50c74265cba46855a50a1_37
Original Code:
```
void f37(void) {
    	uint16_t x161 = 10896U;
	static volatile int16_t x162 = INT16_MAX;
	volatile int64_t x163 = INT64_MIN;
	uint64_t x164 = UINT64_MAX;
	uint64_t t37 = 13LLU;

    t37 = (x161/(x162+(x163|x164)));

    if (t37 != 0LLU) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
16_t x161 = 10896U;
static volatile int16_t x162 = INT16_MAX;
volatile int64_t x163 = INT64_MIN;
uint64_t x164 = UINT64_MAX;
uint64_t t37 = 13LLU;
t37 = (x161/(x162+(x163|x164)));
if (t37 != 0LLU) { N
```
<Overlap Ratio: 0.8298755186721992>

---

--- 337 --
Question ID: 06b5402a2847254100fb1e1f103ec6702850f597_6
Original Code:
```
void cat9554_vddpix_en(fmc_iic_t *pInstance) {
	u8 status = 0;

	if ( !cat9554_iic_address )	{ cat9554_detect(pInstance); }

	pInstance->fpIicRead( pInstance, cat9554_iic_address, 0x01, &status, 1);
	status |= 0x04;
	pInstance->fpIicWrite( pInstance, cat9554_iic_address, 0x01, &status, 1);

}
```


Overlapping Code:
```
mc_iic_t *pInstance) {
u8 status = 0;
if ( !cat9554_iic_address ) { cat9554_detect(pInstance); }
pInstance->fpIicRead( pInstance, cat9554_iic_address, 0x01, &status, 1);
status |= 0x04;
pInstance->fpIicWrite( pInstance, cat9554_iic_address, 0x01, &status, 1);
```
<Overlap Ratio: 0.9087719298245615>

---

--- 338 --
Question ID: 3c329252e1d27d1b1dea799169afc109510cbd41_5
Original Code:
```
int main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])
{
  ffi_cif cif;
  ffi_type *args[MAX_ARGS];
  void *values[MAX_ARGS];
  char *s;
  signed char sc;
  unsigned char uc;
  signed short ss;
  unsigned short us;
  unsigned long ul;
  long long ll;
  float f;
  double d;
  long double ld;
  signed int si1;
  signed int si2;

  ffi_arg rint;
  long long rlonglong;

# if FFI_CLOSURES
  /* The closure must not be an automatic variable on
     platforms (Solaris) that forbid stack execution by default. */
  static ffi_closure cl;
#endif

  ffi_type * cl_arg_types[17];

  ffi_type ts1_type;
  ffi_type ts2_type;
  ffi_type ts3_type;
  ffi_type ts4_type;  
  ffi_type ts5_type;
  ffi_type *ts1_type_elements[4];
  ffi_type *ts2_type_elements[3];
  ffi_type *ts3_type_elements[2];
  ffi_type *ts4_type_elements[4];
  ffi_type *ts5_type_elements[3];

  ts1_type.size = 0;
  ts1_type.alignment = 0;
  ts1_type.type = FFI_TYPE_STRUCT;

  ts2_type.size = 0;
  ts2_type.alignment = 0;
  ts2_type.type = FFI_TYPE_STRUCT;

  ts3_type.size = 0;
  ts3_type.alignment = 0;
  ts3_type.type = FFI_TYPE_STRUCT;

  ts4_type.size = 0;
  ts4_type.alignment = 0;
  ts4_type.type = FFI_TYPE_STRUCT;

  ts5_type.size = 0;
  ts5_type.alignment = 0;
  ts5_type.type = FFI_TYPE_STRUCT;

  /*@-immediatetrans@*/
  ts1_type.elements = ts1_type_elements;
  ts2_type.elements = ts2_type_elements;
  ts3_type.elements = ts3_type_elements;
  ts4_type.elements = ts4_type_elements;
  ts5_type.elements = ts5_type_elements;
  /*@=immediatetrans@*/
  
  ts1_type_elements[0] = &ffi_type_uchar;
  ts1_type_elements[1] = &ffi_type_double;
  ts1_type_elements[2] = &ffi_type_uint;
  ts1_type_elements[3] = NULL;
  
  ts2_type_elements[0] = &ffi_type_double;
  ts2_type_elements[1] = &ffi_type_double;
  ts2_type_elements[2] = NULL;

  ts3_type_elements[0] = &ffi_type_sint;
  ts3_type_elements[1] = NULL;

  ts4_type_elements[0] = &ffi_type_uint;
  ts4_type_elements[1] = &ffi_type_uint;
  ts4_type_elements[2] = &ffi_type_uint;
  ts4_type_elements[3] = NULL;

  ts5_type_elements[0] = &ffi_type_schar;
  ts5_type_elements[1] = &ffi_type_schar;
  ts5_type_elements[2] = NULL;

  ul = 0;

  /* return value tests */
  {
#if defined(MIPS) /* || defined(ARM) */
    puts ("long long tests not run. This is a known bug on this architecture.");
#else
    args[0] = &ffi_type_sint64;
    values[0] = &ll;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_sint64, args) == FFI_OK);

    for (ll = 0LL; ll < 100LL; ll++)
      {
	ul++;
	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
	CHECK(rlonglong == ll);
      }

    for (ll = 55555555555000LL; ll < 55555555555100LL; ll++)
      {
	ul++;
	ffi_call(&cif, FFI_FN(return_ll), &rlonglong, values);
	CHECK(rlonglong == ll);
      }
#endif

    args[0] = &ffi_type_schar;
    values[0] = &sc;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_schar, args) == FFI_OK);

    for (sc = (signed char) -127; 
	 sc < (signed char) 127; /*@-type@*/ sc++ /*@=type@*/)
      {
	ul++;
	ffi_call(&cif, FFI_FN(return_sc), &rint, values);
	CHECK(rint == (int) sc);
      }

    args[0] = &ffi_type_uchar;
    values[0] = &uc;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_uchar, args) == FFI_OK);

    for (uc = (unsigned char) '\x00'; 
	 uc < (unsigned char) '\xff'; /*@-type@*/ uc++ /*@=type@*/)
      {
	ul++;
	ffi_call(&cif, FFI_FN(return_uc), &rint, values);
	CHECK(rint == (signed int) uc);
      }

    printf("%lu return value tests run\n", ul);
  }

#ifdef BROKEN_LONG_DOUBLE
  printf ("This architecture has broken `long double' support. No floating point\ntests have been run.\n");
#else
  /* float arg tests */
  {
    args[0] = &ffi_type_float;
    values[0] = &f;

    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_longdouble, args) == FFI_OK);

    f = 3.14159;

#if 0
  /* This is ifdef'd out for now. long double support under SunOS/gcc
     is pretty much non-existent.  You'll get the odd bus error in library
     routines like printf().  */
    printf ("%Lf\n", ldblit(f));
#endif
    ld = 666;
    ffi_call(&cif, FFI_FN(ldblit), &ld, values);

#if 0
  /* This is ifdef'd out for now. long double support under SunOS/gcc
     is pretty much non-existent.  You'll get the odd bus error in library
     routines like printf().  */
    printf ("%Lf, %Lf, %Lf, %Lf\n", ld, ldblit(f), ld - ldblit(f), LDBL_EPSILON);
#endif

    /* These are not always the same!! Check for a reasonable delta */
    /*@-realcompare@*/
    if (ld - ldblit(f) < LDBL_EPSILON)
    /*@=realcompare@*/
	puts("long double return value tests ok!");
    else
        CHECK(0);
  }

  /* float arg tests */
  {
    args[0] = &ffi_type_sint;
    values[0] = &si1;
    args[1] = &ffi_type_float;
    values[1] = &f;
    args[2] = &ffi_type_double;
    values[2] = &d;
    args[3] = &ffi_type_longdouble;
    values[3] = &ld;
    args[4] = &ffi_type_sint;
    values[4] = &si2;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
		       &ffi_type_sint, args) == FFI_OK);

    si1 = 6;
    f = 3.14159;
    d = (double)1.0/(double)3.0;
    ld = 2.71828182846L;
    si2 = 10;

    floating (si1, f, d, ld, si2);

    ffi_call(&cif, FFI_FN(floating), &rint, values);

    printf ("%d vs %d\n", rint, floating (si1, f, d, ld, si2));

    CHECK(rint == floating(si1, f, d, ld, si2));

    printf("float arg tests ok!\n");
  }
#endif

  /* strlen tests */
  {
    args[0] = &ffi_type_pointer;
    values[0] = (void*) &s;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_sint, args) == FFI_OK);

    s = "a";
    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
    CHECK(rint == 1);

    s = "1234567";
    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
    CHECK(rint == 7);

    s = "1234567890123456789012345";
    ffi_call(&cif, FFI_FN(my_strlen), &rint, values);
    CHECK(rint == 25);

    printf("strlen tests passed\n");
  }

  /* float arg tests */
  {
    args[0] = &ffi_type_float;
    values[0] = &f;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ffi_type_double, args) == FFI_OK);

    f = 3.14159;

    ffi_call(&cif, FFI_FN(dblit), &d, values);

    /* These are not always the same!! Check for a reasonable delta */
    /*@-realcompare@*/
    CHECK(d - dblit(f) < DBL_EPSILON);
    /*@=realcompare@*/

    printf("double return value tests ok!\n");
  }

  /* many arg tests */
  {
    float ff;
    float fa[13];
    
    for (ul = 0; ul < 13; ul++)
      {
	args[ul] = &ffi_type_float;
	values[ul] = &fa[ul];
	fa[ul] = (float) ul;
      }

    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 13, 
		       &ffi_type_float, args) == FFI_OK);

    /*@-usedef@*/
    ff =  many(fa[0], fa[1],
	       fa[2], fa[3],
	       fa[4], fa[5],
	       fa[6], fa[7],
	       fa[8], fa[9],
	       fa[10],fa[11],fa[12]);
    /*@=usedef@*/

    ffi_call(&cif, FFI_FN(many), &f, values);

    /*@-realcompare@*/
    if (f - ff < FLT_EPSILON)
    /*@=realcompare@*/
	printf("many arg tests ok!\n");
    else
#ifdef POWERPC
	printf("many arg tests failed!  This is a gcc bug.\n");
#else
        CHECK(0);
#endif
  }

  /* promotion tests */
  {
    args[0] = &ffi_type_schar;
    args[1] = &ffi_type_sshort;
    args[2] = &ffi_type_uchar;
    args[3] = &ffi_type_ushort;
    values[0] = &sc;
    values[1] = &ss;
    values[2] = &uc;
    values[3] = &us;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, 
		       &ffi_type_sint, args) == FFI_OK);

    us = 0;
    ul = 0;

    for (sc = (signed char) -127; 
	 sc <= (signed char) 120; /*@-type@*/ sc += 1 /*@=type@*/)
      for (ss = -30000; ss <= 30000; ss += 10000)
	for (uc = (unsigned char) 0; 
	     uc <= (unsigned char) 200; /*@-type@*/ uc += 20 /*@=type@*/)
	  for (us = 0; us <= 60000; us += 10000)
	    {
	      ul++;
	      ffi_call(&cif, FFI_FN(promotion), &rint, values);
	      CHECK(rint == (int) sc + (int) ss + (int) uc + (int) us);
	    }
    printf("%lu promotion tests run\n", ul);
  }

#ifndef X86_WIN32 /* Structures dont work on Win32 */

  /* struct tests */
  {
    test_structure_1 ts1_arg;
    /* This is a hack to get a properly aligned result buffer */
    test_structure_1 *ts1_result = 
      (test_structure_1 *) malloc (sizeof(test_structure_1));

    args[0] = &ts1_type;
    values[0] = &ts1_arg;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ts1_type, args) == FFI_OK);

    ts1_arg.uc = '\x01';
    ts1_arg.d = 3.14159;
    ts1_arg.ui = 555;

    ffi_call(&cif, FFI_FN(struct1), ts1_result, values);

    CHECK(ts1_result->ui == 556);
    CHECK(ts1_result->d == 3.14159 - 1);

    puts ("structure test 1 ok!\n");

    free (ts1_result);
  }

  /* struct tests */
  {
    test_structure_2 ts2_arg;

    /* This is a hack to get a properly aligned result buffer */
    test_structure_2 *ts2_result = 
      (test_structure_2 *) malloc (sizeof(test_structure_2));

    args[0] = &ts2_type;
    values[0] = &ts2_arg;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ts2_type, args) == FFI_OK);

    ts2_arg.d1 = 5.55;
    ts2_arg.d2 = 6.66;

    printf ("%g\n", ts2_result->d1);
    printf ("%g\n", ts2_result->d2);

    ffi_call(&cif, FFI_FN(struct2), ts2_result, values);

    printf ("%g\n", ts2_result->d1);
    printf ("%g\n", ts2_result->d2);
    
    CHECK(ts2_result->d1 == 5.55 - 1);
    CHECK(ts2_result->d2 == 6.66 - 1);

    printf("structure test 2 ok!\n");

    free (ts2_result);
  }

  /* struct tests */
  {
    int compare_value;
    test_structure_3 ts3_arg;
    test_structure_3 *ts3_result = 
      (test_structure_3 *) malloc (sizeof(test_structure_3));

    args[0] = &ts3_type;
    values[0] = &ts3_arg;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ts3_type, args) == FFI_OK);

    ts3_arg.si = -123;
    compare_value = ts3_arg.si;

    ffi_call(&cif, FFI_FN(struct3), ts3_result, values);

    printf ("%d %d\n", ts3_result->si, -(compare_value*2));

    if (ts3_result->si == -(ts3_arg.si*2))
	puts ("structure test 3 ok!");
    else
      {
	puts ("Structure test 3 found structure passing bug.");
	puts ("  Current versions of GCC are not 100% compliant with the");
	puts ("  n32 ABI.  There is a known problem related to passing");
	puts ("  small structures.  Send a bug report to the gcc maintainers.");
      }

    free (ts3_result);
  }

  /* struct tests */
  {
    test_structure_4 ts4_arg;

    /* This is a hack to get a properly aligned result buffer */
    test_structure_4 *ts4_result = 
      (test_structure_4 *) malloc (sizeof(test_structure_4));

    args[0] = &ts4_type;
    values[0] = &ts4_arg;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
		       &ts4_type, args) == FFI_OK);

    ts4_arg.ui1 = 2;
    ts4_arg.ui2 = 3;
    ts4_arg.ui3 = 4;

    ffi_call (&cif, FFI_FN(struct4), ts4_result, values);
    
    if (ts4_result->ui3 == 2U * 3U * 4U)
      puts ("structure test 4 ok!");
    else
      puts ("Structure test 4 found GCC's structure passing bug.");

    free (ts4_result);
  }

  /* struct tests */
  {
    test_structure_5 ts5_arg1, ts5_arg2;

    /* This is a hack to get a properly aligned result buffer */
    test_structure_5 *ts5_result = 
      (test_structure_5 *) malloc (sizeof(test_structure_5));

    args[0] = &ts5_type;
    args[1] = &ts5_type;
    values[0] = &ts5_arg1;
    values[1] = &ts5_arg2;
    
    /* Initialize the cif */
    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, 
		       &ts5_type, args) == FFI_OK);

    ts5_arg1.c1 = 2;
    ts5_arg1.c2 = 6;
    ts5_arg2.c1 = 5;
    ts5_arg2.c2 = 3;

    ffi_call (&cif, FFI_FN(struct5), ts5_result, values);
    
    if (ts5_result->c1 == 7 
	&& ts5_result->c2 == 3)
      puts ("structure test 5 ok!");
    else
      puts ("Structure test 5 found GCC's structure passing bug.");

    free (ts5_result);
  }

#else
  printf("Structure passing doesn't work on Win32.\n");
#endif /* X86_WIN32 */

# if FFI_CLOSURES
  /* A simple closure test */
    {
      (void) puts("\nEnter FFI_CLOSURES\n");

      cl_arg_types[0] = &ffi_type_uint64;
      cl_arg_types[1] = &ffi_type_uint;
      cl_arg_types[2] = &ffi_type_uint64;
      cl_arg_types[3] = &ffi_type_uint;
      cl_arg_types[4] = &ffi_type_sshort;
      cl_arg_types[5] = &ffi_type_uint64;
      cl_arg_types[6] = &ffi_type_uint;
      cl_arg_types[7] = &ffi_type_uint;
      cl_arg_types[8] = &ffi_type_double;
      cl_arg_types[9] = &ffi_type_uint;
      cl_arg_types[10] = &ffi_type_uint;
      cl_arg_types[11] = &ffi_type_float;
      cl_arg_types[12] = &ffi_type_uint;
      cl_arg_types[13] = &ffi_type_uint;
      cl_arg_types[14] = &ffi_type_uint;
      cl_arg_types[15] = &ffi_type_uint;
      cl_arg_types[16] = NULL;   

      /* Initialize the cif */
      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
			 &ffi_type_sint, cl_arg_types) == FFI_OK);

      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn,
			     (void *) 3 /* userdata */) == FFI_OK);
      
      CHECK((*((closure_test_type)(&cl)))
	    (1LL, 2, 3LL, 4, 127, 429LL, 7, 8, 9.5, 10, 11, 12, 13, 
	     19, 21, 1) == 680);
    }

    {

      cl_arg_types[0] = &ffi_type_float;
      cl_arg_types[1] = &ffi_type_float;
      cl_arg_types[2] = &ffi_type_float;
      cl_arg_types[3] = &ffi_type_float;
      cl_arg_types[4] = &ffi_type_sshort;
      cl_arg_types[5] = &ffi_type_float;
      cl_arg_types[6] = &ffi_type_float;
      cl_arg_types[7] = &ffi_type_uint;
      cl_arg_types[8] = &ffi_type_double;
      cl_arg_types[9] = &ffi_type_uint;
      cl_arg_types[10] = &ffi_type_uint;
      cl_arg_types[11] = &ffi_type_float;
      cl_arg_types[12] = &ffi_type_uint;
      cl_arg_types[13] = &ffi_type_uint;
      cl_arg_types[14] = &ffi_type_uint;
      cl_arg_types[15] = &ffi_type_uint;
      cl_arg_types[16] = NULL;
      
      /* Initialize the cif */
      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
			 &ffi_type_sint, cl_arg_types) == FFI_OK);

      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn1,
			     (void *) 3 /* userdata */)  == FFI_OK);
      
      CHECK((*((closure_test_type1)(&cl)))
	    (1.1, 2.2, 3.3, 4.4, 127, 5.5, 6.6, 8, 9, 10, 11, 12.0, 13,
	     19, 21, 1) == 255);
    }

    {

      cl_arg_types[0] = &ffi_type_double;
      cl_arg_types[1] = &ffi_type_double;
      cl_arg_types[2] = &ffi_type_double;
      cl_arg_types[3] = &ffi_type_double;
      cl_arg_types[4] = &ffi_type_sshort;
      cl_arg_types[5] = &ffi_type_double;
      cl_arg_types[6] = &ffi_type_double;
      cl_arg_types[7] = &ffi_type_uint;
      cl_arg_types[8] = &ffi_type_double;
      cl_arg_types[9] = &ffi_type_uint;
      cl_arg_types[10] = &ffi_type_uint;
      cl_arg_types[11] = &ffi_type_float;
      cl_arg_types[12] = &ffi_type_uint;
      cl_arg_types[13] = &ffi_type_float;
      cl_arg_types[14] = &ffi_type_uint;
      cl_arg_types[15] = &ffi_type_uint;
      cl_arg_types[16] = NULL;
      
      /* Initialize the cif */
      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
			 &ffi_type_sint, cl_arg_types) == FFI_OK);

      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn2,
			     (void *) 3 /* userdata */) == FFI_OK);

      CHECK((*((closure_test_type2)(&cl)))
	    (1, 2, 3, 4, 127, 5, 6, 8, 9, 10, 11, 12.0, 13,
	     19.0, 21, 1) == 255);

    }

    {

      cl_arg_types[0] = &ffi_type_float;
      cl_arg_types[1] = &ffi_type_float;
      cl_arg_types[2] = &ffi_type_float;
      cl_arg_types[3] = &ffi_type_float;
      cl_arg_types[4] = &ffi_type_float;
      cl_arg_types[5] = &ffi_type_float;
      cl_arg_types[6] = &ffi_type_float;
      cl_arg_types[7] = &ffi_type_float;
      cl_arg_types[8] = &ffi_type_double;
      cl_arg_types[9] = &ffi_type_uint;
      cl_arg_types[10] = &ffi_type_float;
      cl_arg_types[11] = &ffi_type_float;
      cl_arg_types[12] = &ffi_type_uint;
      cl_arg_types[13] = &ffi_type_float;
      cl_arg_types[14] = &ffi_type_float;
      cl_arg_types[15] = &ffi_type_uint;
      cl_arg_types[16] = NULL;
      
      /* Initialize the cif */
      CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 16,
			 &ffi_type_sint, cl_arg_types) == FFI_OK);

      CHECK(ffi_prep_closure(&cl, &cif, closure_test_fn3,
			     (void *) 3 /* userdata */)  == FFI_OK);
      
      CHECK((*((closure_test_type3)(&cl)))
	    (1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9, 10, 11.11, 12.0, 13,
	     19.19, 21.21, 1) == 135);
    }

    (void) puts("\nFinished FFI_CLOSURES\n");

# endif
  /* If we arrived here, all is good */
  (void) puts("\nLooks good. No surprises.\n");

  /*@-compdestroy@*/

  return 0;
}
```


Overlapping Code:
```
nt main(/*@unused@*/ int argc, /*@unused@*/ char *argv[])
{
ffi_cif cif;
ffi_type *args[MAX_ARGS];
void *values[MAX_ARGS];
char *s;
signed char sc;
unsigned char uc;
signed short ss;
unsigned short us;
unsigned long ul;
long long ll;
float f;
double d;
long double ld;
signed int si1;
signed int si2;
ffi_arg rint;
long long rlonglong;
# if FFI_CLOSURES
/* The closure must not be an automatic variable on
platforms (Solaris) that forbid stack execution by default. */
static ffi_closure cl;
#endif
ffi_type * cl_arg_types[17];
ffi_type ts1_type;
ffi_type ts2_type;
ffi_type ts3_type;
ffi_type ts4_type; 
ffi_type ts5_type;
ffi_type *ts1_type_elements[4];
ffi_type *ts2_type_elements[3];
ffi_type *ts3_type_elements[2];
ffi_type *ts4_type_elements[4];
ffi_type *ts5_type_elements[3];
ts1_type.size = 0;
ts1_type.alignment = 0;
ts1_type.type = FFI_TYPE_STRUCT;
ts2_type.size = 0;
ts2_type.alignment = 0;
ts2_type.type = FFI_TYPE_STRUCT;
ts3_type.size = 0;
ts3_type.alignment = 0;
ts3_type.type = FFI_TYPE_STRUCT;
ts4_type.size = 0;
ts4_type.alignment = 0;
ts4_type.type = FFI_TYPE_STRUCT;
ts5_type.size = 0;
ts5_type.alignment = 0;
ts5_type.type = FFI_TYPE_STRUCT;
/*@-immediatetrans@*/
ts1_type.elements = ts1_type_elements;
ts2_type.elements = ts2_type_elements;
ts3_type.elements = ts3_type_elements;
ts4_type.elements = ts4_type_elements;
ts5_type.elements = ts5_type_elements;
/*@=immediatetrans@*/

ts1_type_elements[0] = &ffi_type_uchar;
ts1_type_elements[1] = &ffi_type_double;
ts1_type_elements[2] = &ffi_type_uint;
ts1_type_elements[3] = NULL;

ts2_type_elements[0] = &ffi_type_double;
ts2_type_elements[1] = &ffi_type_double;
ts2_type_elements[2] = NULL;
ts3_type_elements[0] = &ffi_type_sint;
ts3_type_elements[1] = NULL;
ts4_type_elements[0] = &ffi_type_uint;
ts4_type_elements[1] = &ffi_type_uint;
ts4_type_elements[2] = &ffi_type_uint;
ts4_type_elements[3] = NULL;
ts5_type_elements[0] = &ffi_type_schar;
ts5_type_elements[1] = &ffi_type_schar;
ts5_type_elements[2] = NULL;
ul = 0;
/* return value tests */
{
#if defined(MIPS) /* || defined(ARM) */
puts ("long long tests not run. This is a known bug on this architecture.");
#else
args[0] = &ffi_type_sint64;
values[0] = &ll;

/* Initialize the cif */
CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, 
&ffi_type_s
```
<Overlap Ratio: 0.9891257068290561>

---

--- 339 --
Question ID: 4cd92617b4a4956d82b08a0654ba97da016ae1c8_120
Original Code:
```
void f120(void) {
    	static uint8_t x549 = 29U;
	int8_t x550 = INT8_MIN;
	uint16_t x551 = UINT16_MAX;
	int32_t x552 = 1660;
	int32_t t120 = -5946;

    t120 = (((x549+x550)%x551)!=x552);

    if (t120 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 = 29U;
int8_t x550 = INT8_MIN;
uint16_t x551 = UINT16_MAX;
int32_t x552 = 1660;
int32_t t120 = -5946;
t120 = (((x549+x550)%x551)!=x552);
if (t120 != 
```
<Overlap Ratio: 0.704225352112676>

---

--- 340 --
Question ID: 5e0a8d109307c4a0433fddd54eb58885b02a70c5_15
Original Code:
```
BYTE GetHotkeyMod(DWORD dwHotkey)
{
  //Convert modifier from HKM_GETHOTKEY to WM_HOTKEY.
  BYTE nHotkeyMod=HIBYTE(dwHotkey);
  BYTE nResultMod=0;

  if (nHotkeyMod & HOTKEYF_SHIFT)
    nResultMod|=MOD_SHIFT;
  if (nHotkeyMod & HOTKEYF_CONTROL)
    nResultMod|=MOD_CONTROL;
  if (nHotkeyMod & HOTKEYF_ALT)
    nResultMod|=MOD_ALT;
  return nResultMod;
}
```


Overlapping Code:
```
dwHotkey)
{
//Convert modifier from HKM_GETHOTKEY to WM_HOTKEY.
BYTE nHotkeyMod=HIBYTE(dwHotkey);
BYTE nResultMod=0;
if (nHotkeyMod & HOTKEYF_SHIFT)
nResultMod|=MOD_SHIFT;
if (nHotkeyMod & HOTKEYF_CONTROL)
nResultMod|=MOD_CONTROL;
if (nHotkeyMod & HOTKEYF_ALT)
nResultMod|=MOD_ALT;
return nResultMod;
```
<Overlap Ratio: 0.9202453987730062>

---

--- 341 --
Question ID: 52088ac6465f21c36a77eb8db8dc18865ce91d54_30
Original Code:
```
void *TK_Wad4_GetCacheExpandLumpNumOffs(TK_WadImage *img,
	int lump, int ofs, int wsz, int *rrofs, int *rsz)
{
	int		fraga[64];
	TK_Wad4Lump	*w4l;
	TK_Wad2Lump	*w2l;
	TK_FILE		*fd;
	byte		*tptr;
	s64 offs;
	int csz, lmp1, offs1, csz1;
	int dsz, sz1;
	void *ptr;
	int cmp;
	int i, j, k, n;
	
	cmp=TK_Wad4_GetLumpEntCmp(img, lump);
	if(cmp<0)
		return(NULL);
	
	if(cmp!=TK_W4CMP_FRAG)
	{
		*rrofs=0;
//		ptr=TK_Wad4_GetCacheLumpNum(img, lump, rsz);
		ptr=TK_Wad4_GetCacheExpandLumpNum(img, lump, ofs+wsz, rsz);
		return(ptr);
	}

	if(img->w4dir)
	{
		w4l=img->w4dir+lump;
		offs=(w4l->offs)<<6;
		csz=w4l->csize;
		dsz=w4l->dsize;
		cmp=w4l->cmp;
	}else if(img->w2dir)
	{
		w2l=img->w2dir+lump;
		offs=w2l->offs;
		csz=w2l->csize;
		dsz=w2l->dsize;
		cmp=w2l->cmp;
	}
	
	if(ofs>=dsz)
		return(NULL);

	fraga=img->lca_data[lump];
	if(!fraga)
	{
		fraga=TK_Wad4_ZMalloc(64*sizeof(int),
			TK_W4PU_CACHE, img->lca_data+lump);
		TK_Wad4_ZChangeTagEvict(fraga, TK_W4PU_CACHEDIRTY,
			TK_Wad4_LumpEvFunc, img);
		img->lca_data[lump]=fraga;

		fd=img->img_fd;
		if(fd)
		{
			tk_fseek(fd, offs, 0);
			tk_fread(fraga, 1, csz, fd);
		}else
		{
			memset(fraga, 0, 64*sizeof(int));
		}
	}
	
	n=csz>>2;
	i=0; offs1=ofs;
	while(i<n)
	{
		lmp1=fraga[i];
		if(lmp1<=0)
		{
			lmp1=TK_Wad4_AllocateNewFragLump(img);
			fraga[i]=lmp1;
		}
		sz1=TK_Wad4_GetLumpSize(img, lmp1);
		if(offs1<sz1)
			break;
		if((offs1<TK_W4_FRAGSZ) && (fraga[i+1]<=0))
			break;
		offs1-=sz1;
		i++;
	}
	
	if(i>=n)
		return(NULL);

	*rrofs=offs1;
	
	sz1=offs1+wsz;
	if(sz1>TK_W4_FRAGSZ)
		sz1=TK_W4_FRAGSZ;
	
//	ptr=TK_Wad4_GetCacheLumpNum(img, lmp1, rsz);
//	ptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, ofs1+wsz, rsz);
	ptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, sz1, rsz);
	return(ptr);
}
```


Overlapping Code:
```
TK_Wad4_GetCacheExpandLumpNumOffs(TK_WadImage *img,
int lump, int ofs, int wsz, int *rrofs, int *rsz)
{
int fraga[64];
TK_Wad4Lump *w4l;
TK_Wad2Lump *w2l;
TK_FILE *fd;
byte *tptr;
s64 offs;
int csz, lmp1, offs1, csz1;
int dsz, sz1;
void *ptr;
int cmp;
int i, j, k, n;

cmp=TK_Wad4_GetLumpEntCmp(img, lump);
if(cmp<0)
return(NULL);

if(cmp!=TK_W4CMP_FRAG)
{
*rrofs=0;
// ptr=TK_Wad4_GetCacheLumpNum(img, lump, rsz);
ptr=TK_Wad4_GetCacheExpandLumpNum(img, lump, ofs+wsz, rsz);
return(ptr);
}
if(img->w4dir)
{
w4l=img->w4dir+lump;
offs=(w4l->offs)<<6;
csz=w4l->csize;
dsz=w4l->dsize;
cmp=w4l->cmp;
}else if(img->w2dir)
{
w2l=img->w2dir+lump;
offs=w2l->offs;
csz=w2l->csize;
dsz=w2l->dsize;
cmp=w2l->cmp;
}

if(ofs>=dsz)
return(NULL);
fraga=img->lca_data[lump];
if(!fraga)
{
fraga=TK_Wad4_ZMalloc(64*sizeof(int),
TK_W4PU_CACHE, img->lca_data+lump);
TK_Wad4_ZChangeTagEvict(fraga, TK_W4PU_CACHEDIRTY,
TK_Wad4_LumpEvFunc, img);
img->lca_data[lump]=fraga;
fd=img->img_fd;
if(fd)
{
tk_fseek(fd, offs, 0);
tk_fread(fraga, 1, csz, fd);
}else
{
memset(fraga, 0, 64*sizeof(int));
}
}

n=csz>>2;
i=0; offs1=ofs;
while(i<n)
{
lmp1=fraga[i];
if(lmp1<=0)
{
lmp1=TK_Wad4_AllocateNewFragLump(img);
fraga[i]=lmp1;
}
sz1=TK_Wad4_GetLumpSize(img, lmp1);
if(offs1<sz1)
break;
if((offs1<TK_W4_FRAGSZ) && (fraga[i+1]<=0))
break;
offs1-=sz1;
i++;
}

if(i>=n)
return(NULL);
*rrofs=offs1;

sz1=offs1+wsz;
if(sz1>TK_W4_FRAGSZ)
sz1=TK_W4_FRAGSZ;

// ptr=TK_Wad4_GetCacheLumpNum(img, lmp1, rsz);
// ptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, ofs1+wsz, rsz);
ptr=TK_Wad4_GetCacheExpandLumpNum(img, lmp1, sz1, rsz);
return(ptr);
}
```
<Overlap Ratio: 0.9962640099626401>

---

--- 342 --
Question ID: c2d8c23e1a5e62cf6a349d3c0d100f28a71db008_64
Original Code:
```
void f64(void) {
    	int32_t x2001 = -1;
	static volatile int64_t x2002 = INT64_MIN;
	volatile uint8_t x2003 = 8U;
	volatile int8_t x2004 = 0;
	volatile int32_t t64 = -5;

    t64 = ((x2001>(x2002!=x2003))<<x2004);

    if (t64 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 {
int32_t x2001 = -1;
static volatile int64_t x2002 = INT64_MIN;
volatile uint8_t x2003 = 8U;
volatile int8_t x2004 = 0;
volatile int32_t t64 = -5;
t64 = ((x2001>(x2002!=x2003))<<x2004);
if (t64 != 0
```
<Overlap Ratio: 0.8368200836820083>

---

--- 343 --
Question ID: eb21b8a509d7abce736cd56822826858fe5939c9_4
Original Code:
```
FT_LOCAL_DEF(FT_Error)
cff_index_access_element(CFF_Index idx,
                         FT_UInt element,
                         FT_Byte **pbytes,
                         FT_ULong *pbyte_len) {
    FT_Error error = FT_Err_Ok;


    if (idx && idx->count > element) {
        /* compute start and end offsets */
        FT_Stream stream = idx->stream;
        FT_ULong off1, off2 = 0;


        /* load offsets from file or the offset table */
        if (!idx->offsets) {
            FT_ULong pos = element * idx->off_size;


            if (FT_STREAM_SEEK(idx->start + 3 + pos))
                goto Exit;

            off1 = cff_index_read_offset(idx, &error);
            if (error)
                goto Exit;

            if (off1 != 0) {
                do {
                    element++;
                    off2 = cff_index_read_offset(idx, &error);
                } while (off2 == 0 && element < idx->count);
            }
        } else   /* use offsets table */
        {
            off1 = idx->offsets[element];
            if (off1) {
                do {
                    element++;
                    off2 = idx->offsets[element];

                } while (off2 == 0 && element < idx->count);
            }
        }

        /* XXX: should check off2 does not exceed the end of this entry; */
        /*      at present, only truncate off2 at the end of this stream */
        if (off2 > stream->size + 1 ||
            idx->data_offset > stream->size - off2 + 1) {
            FT_ERROR(("cff_index_access_element:"
                      " offset to next entry (%d)"
                      " exceeds the end of stream (%d)\n",
                    off2, stream->size - idx->data_offset + 1));
            off2 = stream->size - idx->data_offset + 1;
        }

        /* access element */
        if (off1 && off2 > off1) {
            *pbyte_len = off2 - off1;

            if (idx->bytes) {
                /* this index was completely loaded in memory, that's easy */
                *pbytes = idx->bytes + off1 - 1;
            } else {
                /* this index is still on disk/file, access it through a frame */
                if (FT_STREAM_SEEK(idx->data_offset + off1 - 1) ||
                    FT_FRAME_EXTRACT(off2 - off1, *pbytes))
                    goto Exit;
            }
        } else {
            /* empty index element */
            *pbytes = 0;
            *pbyte_len = 0;
        }
    } else
        error = FT_THROW(Invalid_Argument);

    Exit:
    return error;
}
```


Overlapping Code:
```
)
cff_index_access_element(CFF_Index idx,
FT_UInt element,
FT_Byte **pbytes,
FT_ULong *pbyte_len) {
FT_Error error = FT_Err_Ok;
if (idx && idx->count > element) {
/* compute start and end offsets */
FT_Stream stream = idx->stream;
FT_ULong off1, off2 = 0;
/* load offsets from file or the offset table */
if (!idx->offsets) {
FT_ULong pos = element * idx->off_size;
if (FT_STREAM_SEEK(idx->start + 3 + pos))
goto Exit;
off1 = cff_index_read_offset(idx, &error);
if (error)
goto Exit;
if (off1 != 0) {
do {
element++;
off2 = cff_index_read_offset(idx, &error);
} while (off2 == 0 && element < idx->count);
}
} else /* use offsets table */
{
off1 = idx->offsets[element];
if (off1) {
do {
element++;
off2 = idx->offsets[element];
} while (off2 == 0 && element < idx->count);
}
}
/* XXX: should check off2 does not exceed the end of this entry; */
/* at present, only truncate off2 at the end of this stream */
if (off2 > stream->size + 1 ||
idx->data_offset > stream->size - off2 + 1) {
FT_ERROR(("cff_index_access_element:"
" offset to next entry (%d)"
" exceeds the end of stream (%d)\n",
off2, stream->size - idx->data_offset + 1));
off2 = stream->size - idx->data_offset + 1;
}
/* access element */
if (off1 && off2 > off1) {
*pbyte_len = off2 - off1;
if (idx->bytes) {
/* this index was completely loaded in memory, that's easy */
*pbytes = idx->bytes + off1 - 1;
} else {
/* this index is still on disk/file, access it through a frame */
if (FT_STREAM_SEEK(idx->data_offset + off1 - 1) ||
FT_FRAME_EXTRACT(off2 - off1, *pbytes))
goto Exit;
}
} else {
/* empty index element */
*pbytes = 0;
*pbyte_len = 0;
}
} els
```
<Overlap Ratio: 0.9625>

---

--- 344 --
Question ID: 264a396dca1b26e625c8c5459c7c5da151d4fafa_13
Original Code:
```
void f13(void) {
    	uint16_t x769 = 0U;
	static int64_t x770 = -3LL;
	int16_t x771 = 5;
	uint16_t x772 = 20U;
	int64_t t13 = 52116345861LL;

    t13 = (((x769%x770)^x771)<<x772);

    if (t13 != 5242880LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
atic int64_t x770 = -3LL;
int16_t x771 = 5;
uint16_t x772 = 20U;
int64_t t13 = 52116345861LL;
t13 = (((x769%x770)^x771)<<x772);
if (t13 != 5242880LL) 
```
<Overlap Ratio: 0.7075471698113207>

---

--- 345 --
Question ID: ebb5cd8b6969f6bd409b7aeab708a61d3c0b4938_0
Original Code:
```
static inline void e2fs_lock(void) {
  x_mutex_lock(mutex_e2fs_lock, x_eternal);
  if(e2fs_lock_thread != x_thread_current()) {
    x_mutex_unlock(mutex_e2fs_lock);
    x_mutex_lock(mutex_e2fs, x_eternal);
    x_mutex_lock(mutex_e2fs_lock, x_eternal);
    e2fs_lock_thread = x_thread_current();
  } 
  e2fs_lock_count++;
  x_mutex_unlock(mutex_e2fs_lock);
}
```


Overlapping Code:
```
void e2fs_lock(void) {
x_mutex_lock(mutex_e2fs_lock, x_eternal);
if(e2fs_lock_thread != x_thread_current()) {
x_mutex_unlock(mutex_e2fs_lock);
x_mutex_lock(mutex_e2fs, x_eternal);
x_mutex_lock(mutex_e2fs_lock, x_eternal);
e2fs_lock_thread = x_thread_current();
} 
e2fs_lock_count++;
x_mutex_unlock(mu
```
<Overlap Ratio: 0.9063444108761329>

---

--- 346 --
Question ID: be720f373411f7413183de86811b22c6ecb16f06_61
Original Code:
```
void f61(void) {
    	int32_t x253 = -1;
	int64_t x254 = -25563609609LL;
	int8_t x255 = 7;
	int8_t x256 = -5;
	static volatile int64_t t61 = 27261515099400519LL;

    t61 = (x253*(x254*(x255>x256)));

    if (t61 != 25563609609LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x254 = -25563609609LL;
int8_t x255 = 7;
int8_t x256 = -5;
static volatile int64_t t61 = 27261515099400519LL;
t61 = (x253*(x254*(x255>x256)));
if (t
```
<Overlap Ratio: 0.6382978723404256>

---

--- 347 --
Question ID: 9db809e035b9fea03516680bb20c66db99b53912_0
Original Code:
```
static ssize_t procfile_read(struct file *filePointer, char __user *buffer,
                             size_t buffer_length, loff_t *offset)
{
    char s[13] = "HelloWorld!\n";
    int len = sizeof(s);
    ssize_t ret = len;

    if (*offset >= len || copy_to_user(buffer, s, len)) {
        pr_info("copy_to_user failed\n");
        ret = 0;
    } else {
        pr_info("procfile read %s\n", filePointer->f_path.dentry->d_name.name);
        *offset += len;
    }

    return ret;
}
```


Overlapping Code:
```
 ssize_t procfile_read(struct file *filePointer, char __user *buffer,
size_t buffer_length, loff_t *offset)
{
char s[13] = "HelloWorld!\n";
int len = sizeof(s);
ssize_t ret = len;
if (*offset >= len || copy_to_user(buffer, s, len)) {
pr_info("copy_to_user failed\n");
ret = 0;
} else {
pr_info("procfile read %s\n", filePointer->f_path.dentry->d_name.name);
*offset += len;
}
return ret;

```
<Overlap Ratio: 0.9822784810126582>

---

--- 348 --
Question ID: e4a4ac8131e6933c65f36678aa30d2c45e03f41d_188
Original Code:
```
void f188(void) {
    	uint64_t x3954 = UINT64_MAX;
	static volatile int32_t t188 = -134670370;

    t188 = (x3953<=(x3954<<(x3955%x3956)));

    if (t188 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
MAX;
static volatile int32_t t188 = -134670370;
t188 = (x3953<=(x3954<<(x3955%x3956)));
if (t188 != 
```
<Overlap Ratio: 0.5952380952380952>

---

--- 349 --
Question ID: 75243bab0778efbcb246da2cb7727137ecbcfe48_34
Original Code:
```
static int __init rtl83xx_sw_probe(struct platform_device *pdev)
{
	int err = 0, i;
	struct rtl838x_switch_priv *priv;
	struct device *dev = &pdev->dev;
	u64 bpdu_mask;

	pr_debug("Probing RTL838X switch device\n");
	if (!pdev->dev.of_node) {
		dev_err(dev, "No DT found\n");
		return -EINVAL;
	}

	// Initialize access to RTL switch tables
	rtl_table_init();

	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	priv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);

	if (!priv->ds)
		return -ENOMEM;
	priv->ds->dev = dev;
	priv->ds->priv = priv;
	priv->ds->ops = &rtl83xx_switch_ops;
	priv->dev = dev;

	mutex_init(&priv->reg_mutex);

	priv->family_id = soc_info.family;
	priv->id = soc_info.id;
	switch(soc_info.family) {
	case RTL8380_FAMILY_ID:
		priv->ds->ops = &rtl83xx_switch_ops;
		priv->cpu_port = RTL838X_CPU_PORT;
		priv->port_mask = 0x1f;
		priv->port_width = 1;
		priv->irq_mask = 0x0FFFFFFF;
		priv->r = &rtl838x_reg;
		priv->ds->num_ports = 29;
		priv->fib_entries = 8192;
		rtl8380_get_version(priv);
		priv->n_lags = 8;
		priv->l2_bucket_size = 4;
		priv->n_pie_blocks = 12;
		priv->port_ignore = 0x1f;
		priv->n_counters = 128;
		break;
	case RTL8390_FAMILY_ID:
		priv->ds->ops = &rtl83xx_switch_ops;
		priv->cpu_port = RTL839X_CPU_PORT;
		priv->port_mask = 0x3f;
		priv->port_width = 2;
		priv->irq_mask = 0xFFFFFFFFFFFFFULL;
		priv->r = &rtl839x_reg;
		priv->ds->num_ports = 53;
		priv->fib_entries = 16384;
		rtl8390_get_version(priv);
		priv->n_lags = 16;
		priv->l2_bucket_size = 4;
		priv->n_pie_blocks = 18;
		priv->port_ignore = 0x3f;
		priv->n_counters = 1024;
		break;
	case RTL9300_FAMILY_ID:
		priv->ds->ops = &rtl930x_switch_ops;
		priv->cpu_port = RTL930X_CPU_PORT;
		priv->port_mask = 0x1f;
		priv->port_width = 1;
		priv->irq_mask = 0x0FFFFFFF;
		priv->r = &rtl930x_reg;
		priv->ds->num_ports = 29;
		priv->fib_entries = 16384;
		priv->version = RTL8390_VERSION_A;
		priv->n_lags = 16;
		sw_w32(1, RTL930X_ST_CTRL);
		priv->l2_bucket_size = 8;
		priv->n_pie_blocks = 16;
		priv->port_ignore = 0x3f;
		priv->n_counters = 2048;
		break;
	case RTL9310_FAMILY_ID:
		priv->ds->ops = &rtl930x_switch_ops;
		priv->cpu_port = RTL931X_CPU_PORT;
		priv->port_mask = 0x3f;
		priv->port_width = 2;
		priv->irq_mask = 0xFFFFFFFFFFFFFULL;
		priv->r = &rtl931x_reg;
		priv->ds->num_ports = 57;
		priv->fib_entries = 16384;
		priv->version = RTL8390_VERSION_A;
		priv->n_lags = 16;
		priv->l2_bucket_size = 8;
		break;
	}
	pr_debug("Chip version %c\n", priv->version);

	err = rtl83xx_mdio_probe(priv);
	if (err) {
		/* Probing fails the 1st time because of missing ethernet driver
		 * initialization. Use this to disable traffic in case the bootloader left if on
		 */
		return err;
	}
	err = dsa_register_switch(priv->ds);
	if (err) {
		dev_err(dev, "Error registering switch: %d\n", err);
		return err;
	}

	/*
	 * dsa_to_port returns dsa_port from the port list in
	 * dsa_switch_tree, the tree is built when the switch
	 * is registered by dsa_register_switch
	 */
	for (i = 0; i <= priv->cpu_port; i++)
		priv->ports[i].dp = dsa_to_port(priv->ds, i);

	/* Enable link and media change interrupts. Are the SERDES masks needed? */
	sw_w32_mask(0, 3, priv->r->isr_glb_src);

	priv->r->set_port_reg_le(priv->irq_mask, priv->r->isr_port_link_sts_chg);
	priv->r->set_port_reg_le(priv->irq_mask, priv->r->imr_port_link_sts_chg);

	priv->link_state_irq = platform_get_irq(pdev, 0);
	pr_info("LINK state irq: %d\n", priv->link_state_irq);
	switch (priv->family_id) {
	case RTL8380_FAMILY_ID:
		err = request_irq(priv->link_state_irq, rtl838x_switch_irq,
				IRQF_SHARED, "rtl838x-link-state", priv->ds);
		break;
	case RTL8390_FAMILY_ID:
		err = request_irq(priv->link_state_irq, rtl839x_switch_irq,
				IRQF_SHARED, "rtl839x-link-state", priv->ds);
		break;
	case RTL9300_FAMILY_ID:
		err = request_irq(priv->link_state_irq, rtl930x_switch_irq,
				IRQF_SHARED, "rtl930x-link-state", priv->ds);
		break;
	case RTL9310_FAMILY_ID:
		err = request_irq(priv->link_state_irq, rtl931x_switch_irq,
				IRQF_SHARED, "rtl931x-link-state", priv->ds);
		break;
	}
	if (err) {
		dev_err(dev, "Error setting up switch interrupt.\n");
		/* Need to free allocated switch here */
	}

	/* Enable interrupts for switch, on RTL931x, the IRQ is always on globally */
	if (soc_info.family != RTL9310_FAMILY_ID)
		sw_w32(0x1, priv->r->imr_glb);

	rtl83xx_get_l2aging(priv);

	rtl83xx_setup_qos(priv);

	priv->r->l3_setup(priv);

	/* Clear all destination ports for mirror groups */
	for (i = 0; i < 4; i++)
		priv->mirror_group_ports[i] = -1;

	/*
	 * Register netdevice event callback to catch changes in link aggregation groups
	 */
	priv->nb.notifier_call = rtl83xx_netdevice_event;
	if (register_netdevice_notifier(&priv->nb)) {
		priv->nb.notifier_call = NULL;
		dev_err(dev, "Failed to register LAG netdev notifier\n");
		goto err_register_nb;
	}

	// Initialize hash table for L3 routing
	rhltable_init(&priv->routes, &route_ht_params);

	/*
	 * Register netevent notifier callback to catch notifications about neighboring
	 * changes to update nexthop entries for L3 routing.
	 */
	priv->ne_nb.notifier_call = rtl83xx_netevent_event;
	if (register_netevent_notifier(&priv->ne_nb)) {
		priv->ne_nb.notifier_call = NULL;
		dev_err(dev, "Failed to register netevent notifier\n");
		goto err_register_ne_nb;
	}

	priv->fib_nb.notifier_call = rtl83xx_fib_event;

	/*
	 * Register Forwarding Information Base notifier to offload routes where
	 * where possible
	 * Only FIBs pointing to our own netdevs are programmed into
	 * the device, so no need to pass a callback.
	 */
	err = register_fib_notifier(&init_net, &priv->fib_nb, NULL, NULL);
	if (err)
		goto err_register_fib_nb;

	// TODO: put this into l2_setup()
	// Flood BPDUs to all ports including cpu-port
	if (soc_info.family != RTL9300_FAMILY_ID) {
		bpdu_mask = soc_info.family == RTL8380_FAMILY_ID ? 0x1FFFFFFF : 0x1FFFFFFFFFFFFF;
		priv->r->set_port_reg_be(bpdu_mask, priv->r->rma_bpdu_fld_pmask);

		// TRAP 802.1X frames (EAPOL) to the CPU-Port, bypass STP and VLANs
		sw_w32(7, priv->r->spcl_trap_eapol_ctrl);

		rtl838x_dbgfs_init(priv);
	} else {
		rtl930x_dbgfs_init(priv);
	}

	return 0;

err_register_fib_nb:
	unregister_netevent_notifier(&priv->ne_nb);
err_register_ne_nb:
	unregister_netdevice_notifier(&priv->nb);
err_register_nb:
	return err;
}
```


Overlapping Code:
```
tic int __init rtl83xx_sw_probe(struct platform_device *pdev)
{
int err = 0, i;
struct rtl838x_switch_priv *priv;
struct device *dev = &pdev->dev;
u64 bpdu_mask;
pr_debug("Probing RTL838X switch device\n");
if (!pdev->dev.of_node) {
dev_err(dev, "No DT found\n");
return -EINVAL;
}
// Initialize access to RTL switch tables
rtl_table_init();
priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
if (!priv)
return -ENOMEM;
priv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);
if (!priv->ds)
return -ENOMEM;
priv->ds->dev = dev;
priv->ds->priv = priv;
priv->ds->ops = &rtl83xx_switch_ops;
priv->dev = dev;
mutex_init(&priv->reg_mutex);
priv->family_id = soc_info.family;
priv->id = soc_info.id;
switch(soc_info.family) {
case RTL8380_FAMILY_ID:
priv->ds->ops = &rtl83xx_switch_ops;
priv->cpu_port = RTL838X_CPU_PORT;
priv->port_mask = 0x1f;
priv->port_width = 1;
priv->irq_mask = 0x0FFFFFFF;
priv->r = &rtl838x_reg;
priv->ds->num_ports = 29;
priv->fib_entries = 8192;
rtl8380_get_version(priv);
priv->n_lags = 8;
priv->l2_bucket_size = 4;
priv->n_pie_blocks = 12;
priv->port_ignore = 0x1f;
priv->n_counters = 128;
break;
case RTL8390_FAMILY_ID:
priv->ds->ops = &rtl83xx_switch_ops;
priv->cpu_port = RTL839X_CPU_PORT;
priv->port_mask = 0x3f;
priv->port_width = 2;
priv->irq_mask = 0xFFFFFFFFFFFFFULL;
priv->r = &rtl839x_reg;
priv->ds->num_ports = 53;
priv->fib_entries = 16384;
rtl8390_get_version(priv);
priv->n_lags = 16;
priv->l2_bucket_size = 4;
priv->n_pie_blocks = 18;
priv->port_ignore = 0x3f;
priv->n_counters = 1024;
break;
case RTL9300_FAMILY_ID:
priv->ds->ops = &rtl930x_switch_ops;
priv->cpu_port = RTL930X_CPU_PORT;
priv->port_mask = 0x1f;
priv->port_width = 1;
priv->irq_mask = 0x0FFFFFFF;
priv->r = &rtl930x_reg;
priv->ds->num_ports = 29;
priv->fib_entries = 16384;
priv->version = RTL8390_VERSION_A;
priv->n_lags = 16;
sw_w32(1, RTL930X_ST_CTRL);
priv->l2_bucket_size = 8;
priv->n_pie_blocks = 16;
priv->port_ignore = 0x3f;
priv->n_counters = 2048;
break;
case RTL9310_FAMILY_ID:
priv->ds->ops = &rtl930x_switch_ops;
priv->cpu_port = RTL931X_CPU_PORT;
priv->port_mask = 0x3f;
priv->port_width = 2;
priv->irq_mask = 0xFFFFFFFFFFFFFULL;
priv->r = &rtl931x_reg;
priv->ds->num_ports = 57;
priv->fib_entries = 16384;
priv->version = RTL8390_VERSION_A;
priv->n_lags = 16;
priv->l2_buck
```
<Overlap Ratio: 0.9824861170439982>

---

--- 350 --
Question ID: aa5477d5e34de2413d583f4adff74395d3baafaf_85
Original Code:
```
void f85(void) {
    	int64_t x341 = -544139046299LL;
	volatile int64_t x342 = -1LL;
	int64_t x343 = INT64_MIN;
	int16_t x344 = INT16_MIN;
	int32_t t85 = -1347;

    t85 = (((x341>x342)^x343)!=x344);

    if (t85 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x341 = -544139046299LL;
volatile int64_t x342 = -1LL;
int64_t x343 = INT64_MIN;
int16_t x344 = INT16_MIN;
int32_t t85 = -1347;
t85 = (((x341>x342)^x343)!=x344);
if (t85 != 1) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.8923766816143498>

---

--- 351 --
Question ID: f5012e1986505ca8ce82310302152eeadde7147a_6
Original Code:
```
static void centaur_get_mcr (unsigned int reg, unsigned long *base,
			     unsigned long *size, mtrr_type *type)
{
    *base = centaur_mcr[reg].high >> PAGE_SHIFT;
    *size = -(centaur_mcr[reg].low & 0xfffff000) >> PAGE_SHIFT;
    *type = MTRR_TYPE_WRCOMB;	/*  If it is there, it is write-combining  */
    if(centaur_mcr_type==1 && ((centaur_mcr[reg].low&31)&2))
    	*type = MTRR_TYPE_UNCACHABLE;
    if(centaur_mcr_type==1 && (centaur_mcr[reg].low&31)==25)
    	*type = MTRR_TYPE_WRBACK;
    if(centaur_mcr_type==0 && (centaur_mcr[reg].low&31)==31)
    	*type = MTRR_TYPE_WRBACK;
    
}
```


Overlapping Code:
```
id centaur_get_mcr (unsigned int reg, unsigned long *base,
unsigned long *size, mtrr_type *type)
{
*base = centaur_mcr[reg].high >> PAGE_SHIFT;
*size = -(centaur_mcr[reg].low & 0xfffff000) >> PAGE_SHIFT;
*type = MTRR_TYPE_WRCOMB; /* If it is there, it is write-combining */
if(centaur_mcr_type==1 && ((centaur_mcr[reg].low&31)&2))
*type = MTRR_TYPE_UNCACHABLE;
if(centaur_mcr_type==1 && (centaur_mcr[reg].low&31)==25)
*type = MTRR_TYPE_WRBACK;
if(centaur_mcr_type==0 && (centaur_mcr[reg].low&31)==31)
```
<Overlap Ratio: 0.929368029739777>

---

--- 352 --
Question ID: 055708b57380a63daa68eaff1e5bb47159ae1d83_125
Original Code:
```
void f125(void) {
    	int16_t x501 = INT16_MIN;
	volatile int64_t x502 = -12670LL;
	volatile uint8_t x503 = UINT8_MAX;
	int32_t x504 = 62286732;
	volatile int32_t t125 = -1963498;

    t125 = ((x501>x502)==(x503^x504));

    if (t125 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void f125(void) {
int16_t x501 = INT16_MIN;
volatile int64_t x502 = -12670LL;
volatile uint8_t x503 = UINT8_MAX;
int32_t x504 = 62286732;
volatile int32_t t125 = -1963498;
t125 = ((x501>x502)==(x503^x504));
if (t125 != 0) { NG(); } else { ; }

```
<Overlap Ratio: 0.9918367346938776>

---

--- 353 --
Question ID: 3590e15e5d52d9b880b5afbe50ae6091cf5fcc6e_13
Original Code:
```
int32_t msm_camera_tz_i2c_read_seq(struct msm_camera_i2c_client *client,
	uint32_t addr, uint8_t *data, uint32_t num_byte)
{
	int32_t rc = -EFAULT;
	int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);

	CDBG("Sensor=%d, MS=%d, SID=%d, CID=%d, addr=0x%08X, num=%d\n",
		sensor_id,
		client->cci_client->cci_i2c_master,
		client->cci_client->sid,
		client->cci_client->cid,
		addr,
		num_byte);

	if (sensor_id >= 0) {
		rc = msm_camera_tz_i2c_ta_cci_generic(
			client, MSM_CAMERA_TZ_CMD_CCI_READ_SEQ);
		msm_camera_tz_i2c_ta_done();
	}
	return TZ_I2C_FN_RETURN(rc,
		msm_camera_cci_i2c_read_seq, client, addr, data, num_byte);
}
```


Overlapping Code:
```
c_read_seq(struct msm_camera_i2c_client *client,
uint32_t addr, uint8_t *data, uint32_t num_byte)
{
int32_t rc = -EFAULT;
int32_t sensor_id = msm_camera_tz_i2c_ta_probe(client);
CDBG("Sensor=%d, MS=%d, SID=%d, CID=%d, addr=0x%08X, num=%d\n",
sensor_id,
client->cci_client->cci_i2c_master,
client->cci_client->sid,
client->cci_client->cid,
addr,
num_byte);
if (sensor_id >= 0) {
rc = msm_camera_tz_i2c_ta_cci_generic(
client, MSM_CAMERA_TZ_CMD_CCI_READ_SEQ);
msm_camera_tz_i2c_ta_done();
}
return TZ_I2C_FN_RETURN(rc,
msm_camera_cci_i2c_read_seq, client, addr, data, num_
```
<Overlap Ratio: 0.946843853820598>

---

--- 354 --
Question ID: 24eb4d26ffa59affc775fe27a637ab2b4d86abe5_0
Original Code:
```
class AutoShapeTransformAction : public TransformAction {
 public:
								AutoShapeTransformAction(AutoShapeState* state,
														 ShapeStroke* object,

														 const control_point* points,
														 int32 count,
	
//														 BPoint translation,
//														 double rotation,
//														 double xScale,
//														 double yScale,
														 const Transformable& t,
														 BPoint centerOffset,
	
														 const char* actionName,
														 uint32 nameIndex);

	virtual						~AutoShapeTransformAction();
	
	virtual	status_t			InitCheck();

 protected:
	virtual	status_t			_SetTransformation(CanvasView* view,
//												   BPoint translation,
//												   double rotation,
//												   double xScale,
//												   double yScale,
												   const Transformable& t,
												   BPoint centerOffset) const;

			AutoShapeState*		fState;
			ShapeStroke*		fShape;

			control_point*		fPoints;
			int32				fCount;
}
```


Overlapping Code:
```
TransformAction : public TransformAction {
public:
AutoShapeTransformAction(AutoShapeState* state,
ShapeStroke* object,
const control_point* points,
int32 count,

// BPoint translation,
// double rotation,
// double xScale,
// double yScale,
const Transformable& t,
BPoint centerOffset,

const char* actionName,
uint32 nameIndex);
virtual ~AutoShapeTransformAction();

virtual status_t InitCheck();
protected:
virtual status_t _SetTransformation(CanvasView* view,
// BPoint translation,
// double rotation,
// double xScale,
// double yScale,
const Transformable& t,
BPoint centerOffset) const;
AutoShapeState* fState;
ShapeStroke* fShape;
control_po
```
<Overlap Ratio: 0.9365994236311239>

---

--- 355 --
Question ID: 3fc0dd8425d900946344e79cc30b7ed6224b10da_90
Original Code:
```
void f90(void) {
    	int32_t x361 = 3;
	int8_t x362 = INT8_MIN;
	static uint16_t x363 = 44U;
	volatile uint8_t x364 = 10U;
	int32_t t90 = 1109;

    t90 = ((x361==x362)<=(x363==x364));

    if (t90 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
8_t x362 = INT8_MIN;
static uint16_t x363 = 44U;
volatile uint8_t x364 = 10U;
int32_t t90 = 1109;
t90 = ((x361==x362)<=(x363==x364));
if (t90 != 1) { NG(); } else { ; }


```
<Overlap Ratio: 0.8133971291866029>

---

--- 356 --
Question ID: 9e0c90da99d3036de4a4b866aaaca11f0ad99fc5_14
Original Code:
```
static inline void htt_print_tx_tid_stats_v1_tlv(const void *tag_buf,
						 struct debug_htt_stats_req *stats_req)
{
	const struct htt_tx_tid_stats_v1_tlv *htt_stats_buf = tag_buf;
	u8 *buf = stats_req->buf;
	u32 len = stats_req->buf_len;
	u32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;
	char tid_name[MAX_HTT_TID_NAME + 1] = {0};

	len += HTT_DBG_OUT(buf + len, buf_len - len, "HTT_TX_TID_STATS_V1_TLV:");
	memcpy(tid_name, &(htt_stats_buf->tid_name[0]), MAX_HTT_TID_NAME);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_name = %s ", tid_name);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "sw_peer_id = %u",
			   htt_stats_buf->sw_peer_id__tid_num & 0xFFFF);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_num = %u",
			   (htt_stats_buf->sw_peer_id__tid_num & 0xFFFF0000) >> 16);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "num_sched_pending = %u",
			   htt_stats_buf->num_sched_pending__num_ppdu_in_hwq & 0xFF);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "num_ppdu_in_hwq = %u",
			   (htt_stats_buf->num_sched_pending__num_ppdu_in_hwq &
			   0xFF00) >> 8);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_flags = 0x%x",
			   htt_stats_buf->tid_flags);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "max_qdepth_bytes = %u",
			   htt_stats_buf->max_qdepth_bytes);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "max_qdepth_n_msdus = %u",
			   htt_stats_buf->max_qdepth_n_msdus);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "rsvd = %u",
			   htt_stats_buf->rsvd);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_bytes = %u",
			   htt_stats_buf->qdepth_bytes);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_num_msdu = %u",
			   htt_stats_buf->qdepth_num_msdu);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_num_mpdu = %u",
			   htt_stats_buf->qdepth_num_mpdu);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "last_scheduled_tsmp = %u",
			   htt_stats_buf->last_scheduled_tsmp);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "pause_module_id = %u",
			   htt_stats_buf->pause_module_id);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "block_module_id = %u",
			   htt_stats_buf->block_module_id);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "allow_n_flags = 0x%x",
			   htt_stats_buf->allow_n_flags);
	len += HTT_DBG_OUT(buf + len, buf_len - len, "sendn_frms_allowed = %u\n",
			   htt_stats_buf->sendn_frms_allowed);

	if (len >= buf_len)
		buf[buf_len - 1] = 0;
	else
		buf[len] = 0;

	stats_req->buf_len = len;
}
```


Overlapping Code:
```
tx_tid_stats_v1_tlv(const void *tag_buf,
struct debug_htt_stats_req *stats_req)
{
const struct htt_tx_tid_stats_v1_tlv *htt_stats_buf = tag_buf;
u8 *buf = stats_req->buf;
u32 len = stats_req->buf_len;
u32 buf_len = ATH11K_HTT_STATS_BUF_SIZE;
char tid_name[MAX_HTT_TID_NAME + 1] = {0};
len += HTT_DBG_OUT(buf + len, buf_len - len, "HTT_TX_TID_STATS_V1_TLV:");
memcpy(tid_name, &(htt_stats_buf->tid_name[0]), MAX_HTT_TID_NAME);
len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_name = %s ", tid_name);
len += HTT_DBG_OUT(buf + len, buf_len - len, "sw_peer_id = %u",
htt_stats_buf->sw_peer_id__tid_num & 0xFFFF);
len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_num = %u",
(htt_stats_buf->sw_peer_id__tid_num & 0xFFFF0000) >> 16);
len += HTT_DBG_OUT(buf + len, buf_len - len, "num_sched_pending = %u",
htt_stats_buf->num_sched_pending__num_ppdu_in_hwq & 0xFF);
len += HTT_DBG_OUT(buf + len, buf_len - len, "num_ppdu_in_hwq = %u",
(htt_stats_buf->num_sched_pending__num_ppdu_in_hwq &
0xFF00) >> 8);
len += HTT_DBG_OUT(buf + len, buf_len - len, "tid_flags = 0x%x",
htt_stats_buf->tid_flags);
len += HTT_DBG_OUT(buf + len, buf_len - len, "max_qdepth_bytes = %u",
htt_stats_buf->max_qdepth_bytes);
len += HTT_DBG_OUT(buf + len, buf_len - len, "max_qdepth_n_msdus = %u",
htt_stats_buf->max_qdepth_n_msdus);
len += HTT_DBG_OUT(buf + len, buf_len - len, "rsvd = %u",
htt_stats_buf->rsvd);
len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_bytes = %u",
htt_stats_buf->qdepth_bytes);
len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_num_msdu = %u",
htt_stats_buf->qdepth_num_msdu);
len += HTT_DBG_OUT(buf + len, buf_len - len, "qdepth_num_mpdu = %u",
htt_stats_buf->qdepth_num_mpdu);
len += HTT_DBG_OUT(buf + len, buf_len - len, "last_scheduled_tsmp = %u",
htt_stats_buf->last_scheduled_tsmp);
len += HTT_DBG_OUT(buf + len, buf_len - len, "pause_module_id = %u",
htt_stats_buf->pause_module_id);
len += HTT_DBG_OUT(buf + len, buf_len - len, "block_module_id = %u",
htt_stats_buf->block_module_id);
len += HTT_DBG_OUT(buf + len, buf_len - len, "allow_n_flags = 0x%x",
htt_stats_buf->allow_n_flags);
len += HTT_DBG_OUT(buf + len, buf_len - len, "sendn_frms_allowed = %u\n",
htt_stats_buf->sendn_frms_allowed);
if (len >= buf_len)
buf[buf_len - 1] = 0;
else
buf[len] = 0;
stats_req->buf_len = len;
}
```
<Overlap Ratio: 0.9875053856096511>

---

--- 357 --
Question ID: f11be71af12f9083a6a63cb6e143b1243b7ff072_120
Original Code:
```
void f120(void) {
    	uint32_t x1001 = 24041976U;
	uint16_t x1002 = 1U;
	uint32_t x1003 = 29597U;
	int32_t x1004 = 711;
	volatile int32_t t120 = -31;

    t120 = (x1001<=(x1002%(x1003/x1004)));

    if (t120 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
uint32_t x1001 = 24041976U;
uint16_t x1002 = 1U;
uint32_t x1003 = 29597U;
int32_t x1004 = 711;
volatile int32_t t120 = -31;
t120 = (x1001<=(x1002%(x1003/x1004)));
if (t120 != 0) { NG(); } else
```
<Overlap Ratio: 0.91324200913242>

---

--- 358 --
Question ID: 4339c7a0a7eedd6794e309bb460a8a02e1bf07be_7
Original Code:
```
static int uart_dma_tx_init(void)
{
	dma_cfg_init(&dma_tx_cfg, &dma_tx_blk_cfg);
	dma_tx_cfg.channel_direction = MEMORY_TO_PERIPHERAL;
	dma_tx_cfg.dma_callback = dma_tx_callback;
	dma_tx_blk_cfg.dest_address = USART_DR;
	uart_dma_tx_enable();

	return 0;
}
```


Overlapping Code:
```
fg_init(&dma_tx_cfg, &dma_tx_blk_cfg);
dma_tx_cfg.channel_direction = MEMORY_TO_PERIPHERAL;
dma_tx_cfg.dma_callback = dma_tx_callback;
dma_tx_blk_cfg.dest_address = USART_DR;
uart_dma_tx_enable();
return
```
<Overlap Ratio: 0.8152610441767069>

---

--- 359 --
Question ID: 629afbef45ed6bd410d3fc664e306cf8ffc93999_25
Original Code:
```
DWORD
RemoveBootIniCancelOption (
    DWORD Request
    )
{
    HINF inf = INVALID_HANDLE_VALUE;
    PCTSTR bootIni;
    PCTSTR bootIniTmp;
    DWORD result = ERROR_SUCCESS;
    PINFLINE osLine;
    BOOL changed = FALSE;
    DWORD attribs;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    bootIni = JoinPaths (g_BootDrivePath, TEXT("boot.ini"));

    __try {
        //
        // Open boot.ini for editing
        //

        inf = OpenInfFile (bootIni);

        if (inf == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s", bootIni));
            result = GetLastError();
            __leave;
        }

        //
        // Scan boot.ini for a textmode option that has /rollback. Delete it.
        //

        osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
        if (!osLine) {
            DEBUGMSG ((DBG_ERROR, "No lines found in [Operating Systems] in %s", bootIni));
            result = ERROR_FILE_NOT_FOUND;
            __leave;
        }

        //
        // Loop until all lines with /rollback are gone
        //

        do {
            do {
                //
                // Check this line for a /rollback option
                //

                if (_tcsistr (osLine->Data, TEXT("/rollback"))) {
                    DEBUGMSG ((DBG_FILEMIG, "Found rollback option: %s", osLine->Data));
                    break;
                }

            } while (osLine = GetNextLineInSection (osLine));

            if (osLine) {
                if (!DeleteLineInInfSection (inf, osLine)) {
                    MYASSERT (FALSE);
                    break;
                }

                DEBUGMSG ((DBG_FILEMIG, "Line sucessfully removed"));
                changed = TRUE;
                osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
            }

        } while (osLine);

        //
        // If we changed the file, then write it to disk. Keep the original
        // boot.ini file in case we fail to save.
        //

        attribs = GetFileAttributes (bootIni);
        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
        MYASSERT (attribs != INVALID_ATTRIBUTES);

        bootIniTmp = JoinPaths (g_BootDrivePath, TEXT("boot.~t"));
        SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (bootIniTmp);

        if (!MoveFile (bootIni, bootIniTmp)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIni, bootIniTmp));
            result = GetLastError();
        } else {

            DEBUGMSG ((DBG_FILEMIG, "Moved %s to %s", bootIni, bootIniTmp));

            if (!SaveInfFile (inf, bootIni)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_SAVE_FAILED, bootIni));
                result = GetLastError();

                SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (bootIni);

                if (!MoveFile (bootIniTmp, bootIni)) {

                    //
                    // This should not happen, because we just successfully
                    // moved the original to the tmp; we should be able to
                    // move the temp back to the original. If we fail, the pc
                    // becomes unbootable. But what can we do?
                    //

                    LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIniTmp, bootIni));
                }
            } else {
                //
                // boot.ini was successfully updated. Remove the original copy.
                //

                DeleteFile (bootIniTmp);
                MYASSERT (result == ERROR_SUCCESS);

                DEBUGMSG ((DBG_FILEMIG, "%s was saved", bootIni));
            }
        }

        //
        // restore attributes on original if possible.
        //

        SetFileAttributes (bootIni, attribs);
        FreePathString (bootIniTmp);

        // result already set above
    }
    __finally {
        if (inf != INVALID_HANDLE_VALUE) {
            CloseInfFile (inf);
        }

        FreePathString (bootIni);
    }

    return result;

}
```


Overlapping Code:
```
otIniCancelOption (
DWORD Request
)
{
HINF inf = INVALID_HANDLE_VALUE;
PCTSTR bootIni;
PCTSTR bootIniTmp;
DWORD result = ERROR_SUCCESS;
PINFLINE osLine;
BOOL changed = FALSE;
DWORD attribs;
if (Request == REQUEST_QUERYTICKS) {
return 50;
}
if (Request != REQUEST_RUN) {
return 0;
}
bootIni = JoinPaths (g_BootDrivePath, TEXT("boot.ini"));
__try {
//
// Open boot.ini for editing
//
inf = OpenInfFile (bootIni);
if (inf == INVALID_HANDLE_VALUE) {
DEBUGMSG ((DBG_ERROR, "Can't open %s", bootIni));
result = GetLastError();
__leave;
}
//
// Scan boot.ini for a textmode option that has /rollback. Delete it.
//
osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
if (!osLine) {
DEBUGMSG ((DBG_ERROR, "No lines found in [Operating Systems] in %s", bootIni));
result = ERROR_FILE_NOT_FOUND;
__leave;
}
//
// Loop until all lines with /rollback are gone
//
do {
do {
//
// Check this line for a /rollback option
//
if (_tcsistr (osLine->Data, TEXT("/rollback"))) {
DEBUGMSG ((DBG_FILEMIG, "Found rollback option: %s", osLine->Data));
break;
}
} while (osLine = GetNextLineInSection (osLine));
if (osLine) {
if (!DeleteLineInInfSection (inf, osLine)) {
MYASSERT (FALSE);
break;
}
DEBUGMSG ((DBG_FILEMIG, "Line sucessfully removed"));
changed = TRUE;
osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
}
} while (osLine);
//
// If we changed the file, then write it to disk. Keep the original
// boot.ini file in case we fail to save.
//
attribs = GetFileAttributes (bootIni);
SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
MYASSERT (attribs != INVALID_ATTRIBUTES);
bootIniTmp = JoinPaths (g_BootDrivePath, TEXT("boot.~t"));
SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE
```
<Overlap Ratio: 0.9764503159103963>

---

--- 360 --
Question ID: ccc7532690e9eb12d04315c1484649a8834cf61d_1
Original Code:
```
int
sockets_open(void)
{
	int ipx_sock = -1;		/* IPX socket			*/
	int ax25_sock = -1;		/* AX.25 socket			*/
	int inet_sock = -1;		/* INET socket			*/
	int ddp_sock = -1;		/* Appletalk DDP socket		*/

	inet_sock=socket(AF_INET, SOCK_DGRAM, 0);
	ipx_sock=socket(AF_IPX, SOCK_DGRAM, 0);
	ax25_sock=socket(AF_AX25, SOCK_DGRAM, 0);
	ddp_sock=socket(AF_APPLETALK, SOCK_DGRAM, 0);
	/*
	 * Now pick any (exisiting) useful socket family for generic queries
	 */
	if(inet_sock!=-1)
		return inet_sock;
	if(ipx_sock!=-1)
		return ipx_sock;
	if(ax25_sock!=-1)
		return ax25_sock;
	/*
	 * If this is -1 we have no known network layers and its time to jump.
	 */
	 
	return ddp_sock;
}
```


Overlapping Code:
```
ockets_open(void)
{
int ipx_sock = -1; /* IPX socket */
int ax25_sock = -1; /* AX.25 socket */
int inet_sock = -1; /* INET socket */
int ddp_sock = -1; /* Appletalk DDP socket */
inet_sock=socket(AF_INET, SOCK_DGRAM, 0);
ipx_sock=socket(AF_IPX, SOCK_DGRAM, 0);
ax25_sock=socket(AF_AX25, SOCK_DGRAM, 0);
ddp_sock=socket(AF_APPLETALK, SOCK_DGRAM, 0);
/*
* Now pick any (exisiting) useful socket family for generic queries
*/
if(inet_sock!=-1)
return inet_sock;
if(ipx_sock!=-1)
return ipx_sock;
if(ax25_sock!=-1)
return ax25_sock;
/*
* If this is -1 we have no known network layers and its time to jump.
*/

return ddp_sock;
```
<Overlap Ratio: 0.9888712241653418>

---

--- 361 --
Question ID: df1ab562a5420312461d414544121de638f34310_39
Original Code:
```
void f39(void) {
    	int8_t x2138 = 1;
	int16_t x2139 = -3;
	int32_t t39 = 61609;

    t39 = ((x2137>>x2138)>>(x2139!=x2140));

    if (t39 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
d f39(void) {
int8_t x2138 = 1;
int16_t x2139 = -3;
int32_t t39 = 61609;
t39 = ((x2137>>x2138)>>(x2139!=x2140));
if (t39 != 0) { NG(); } else { ; }

}
```
<Overlap Ratio: 0.9803921568627451>

---

--- 362 --
Question ID: 1015a3c9f55fd05f99b28f5395b858710d6667ec_11
Original Code:
```
void FreeSeverResources(void)
{
    FreeArguments();
    FreeLocalConfig();
    FreeServerContext(g_dhcpServer);
}
```


Overlapping Code:
```
;
FreeLocalConfig();
FreeServerContext(g_dhcpServe
```
<Overlap Ratio: 0.49019607843137253>

---

--- 363 --
Question ID: 8b053aa46ec881629c7ff8d559e3ae80279b6c0a_7
Original Code:
```
void f7(void) {
    	static uint8_t x33 = 3U;
	static uint32_t x35 = 18044967U;
	int32_t t7 = -924723;

    t7 = ((x33-x34)==(x35*x36));

    if (t7 != 0) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
static uint32_t x35 = 18044967U;
int32_t t7 = -924723;
t7 = ((x33-x34)==(x35*x36));
if (t7 != 0) { N
```
<Overlap Ratio: 0.6211180124223602>

---

--- 364 --
Question ID: 0b179d1fa0c6861ab61175502d97ad6e58c36e4b_79
Original Code:
```
void f79(void) {
    	uint8_t x449 = 44U;
	int8_t x451 = INT8_MIN;
	volatile int32_t x452 = INT32_MAX;
	static volatile uint32_t t79 = 17561U;

    t79 = ((x449/x450)>>(x451>x452));

    if (t79 != 1U) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
void) {
uint8_t x449 = 44U;
int8_t x451 = INT8_MIN;
volatile int32_t x452 = INT32_MAX;
static volatile uint32_t t79 = 17561U;
t79 = ((x449/x450)>>(x45
```
<Overlap Ratio: 0.7246376811594203>

---

--- 365 --
Question ID: 8cfe1c2e4145f05ec6dba921ac0fa317a81a375b_6
Original Code:
```
void f6(void) {
    	int8_t x26 = 0;
	volatile int64_t x27 = INT64_MIN;
	volatile uint16_t x28 = UINT16_MAX;
	volatile int32_t t6 = 35688305;

    t6 = ((x25-x26)!=(x27^x28));

    if (t6 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
tile int64_t x27 = INT64_MIN;
volatile uint16_t x28 = UINT16_MAX;
volatile int32_t t6 = 35688305;
t6 = ((x25-x26)!=(x27^x28));
if (t6 != 1) { NG(); } 
```
<Overlap Ratio: 0.7537688442211056>

---

--- 366 --
Question ID: cd46a2f923125ee6c10d43af617b392edafd7962_31
Original Code:
```
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}
```


Overlapping Code:
```
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
if (unlikely(!result)) {
PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
"name '%U' is not defined", name);
#else
"name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
}
return result;
}
```
<Overlap Ratio: 1.0>

---

--- 367 --
Question ID: 73850f13992820e9083606d110aeed4477976f57_180
Original Code:
```
void f180(void) {
    	static volatile int64_t x761 = -1LL;
	volatile int8_t x762 = -6;
	static uint8_t x763 = 11U;
	static volatile int64_t t180 = 256484910072714LL;

    t180 = (x761-((x762<=x763)>x764));

    if (t180 != -2LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
oid f180(void) {
static volatile int64_t x761 = -1LL;
volatile int8_t x762 = -6;
static uint8_t x763 = 11U;
static volatile int64_t t180 = 256484910072714LL;
t180 = (x761-((x762<=x763)>x764));
if
```
<Overlap Ratio: 0.8297872340425532>

---

--- 368 --
Question ID: 000092fdf96263dc7cfeeef26d2c66e14e763a47_13
Original Code:
```
bool
sb_iscoreup(void *sbh)
{
	sb_info_t *si;
	sbconfig_t *sb;

	si = SB_INFO(sbh);
	sb = REGS2SB(si->curmap);

	return ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CLK);
}
```


Overlapping Code:
```
iscoreup(void *sbh)
{
sb_info_t *si;
sbconfig_t *sb;
si = SB_INFO(sbh);
sb = REGS2SB(si->curmap);
return ((R_SBREG(sbh, &(sb)->sbtmstatelow) & (SBTML_RESET | SBTML_REJ | SBTML_CLK)) == SBTML_CL
```
<Overlap Ratio: 0.9368932038834952>

---

--- 369 --
Question ID: 85c045f85f1cbbcc1e1177e6d31d0b20f16045be_0
Original Code:
```
void UBLEBcastScan_createTask(void)
{
    Task_Params taskParams;

    // Configure task
    Task_Params_init(&taskParams);
    taskParams.stack = ubsTaskStack;
    taskParams.stackSize = UBS_TASK_STACK_SIZE;
    taskParams.priority = UBS_TASK_PRIORITY;

    Task_construct(&ubsTask, UBLEBcastScan_taskFxn, &taskParams, NULL);

#ifdef USE_RCOSC
    RCOSC_enableCalibration();
#endif // USE_RCOSC
}
```


Overlapping Code:
```
void UBLEBcastScan_createTask(void)
{
Task_Params taskParams;
// Configure task
Task_Params_init(&taskParams);
taskParams.stack = ubsTaskStack;
taskParams.stackSize = UBS_TASK_STACK_SIZE;
taskParams.priority = UBS_TASK_PRIORITY;
Task_construct(&ubsTask, UBLEBcastScan_taskFxn, &taskParams, NULL);
#ifdef USE_RCOSC
RCOSC_enableCalibration();
#endif // USE_RC
```
<Overlap Ratio: 0.9861878453038674>

---

--- 370 --
Question ID: 0e1063164babe9c8bf9ee3421779b3dbf8061c42_6
Original Code:
```
static PyObject *__pyx_f_4pymc_12LazyFunction_7Counter_unclick(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_r;
  static char *__pyx_argnames[] = {0};
  if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "", __pyx_argnames)) return 0;
  Py_INCREF(__pyx_v_self);
  ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->count = ((struct __pyx_obj_4pymc_12LazyFunction_Counter *)__pyx_v_self)->lastcount;

  __pyx_r = Py_None; Py_INCREF(Py_None);
  Py_DECREF(__pyx_v_self);
  return __pyx_r;
}
```


Overlapping Code:
```
ck(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
PyObject *__pyx_r;
static char *__pyx_argnames[] = {0};
if (!PyArg_ParseTupleAndKeywords(__pyx_args, __pyx_kwds, "", __pyx_argnames)) return 0;
Py_INCREF(__pyx_v_self);
EF(Py_None);
Py_DECREF(__pyx_v_self);
return __pyx
```
<Overlap Ratio: 0.5488721804511278>

---

--- 371 --
Question ID: 44eb386b1926771041b54c520fca6dc8c41b3f2e_22
Original Code:
```
int chandev_add_schib_info(int irq,chandev_subchannel_info *sch)
{
	schib_t *new_schib;
	
	if((new_schib=s390_get_schib(irq)))
	{
		sch->pim=new_schib->pmcw.pim;
		memcpy(&sch->chpid,&new_schib->pmcw.chpid,sizeof(sch->chpid));
		return(0);
	}
	return(-ENODEV);
}
```


Overlapping Code:
```
subchannel_info *sch)
{
schib_t *new_schib;

if((new_schib=s390_get_schib(irq)))
{
sch->pim=new_schib->pmcw.pim;
memcpy(&sch->chpid,&new_schib->pmcw.chpid,sizeof(sch->chpid));
return(0);
}
return(-ENO
```
<Overlap Ratio: 0.8>

---

--- 372 --
Question ID: 02b2128a0726c631b38b7599bac3f72ffe5f8cd0_27
Original Code:
```
void f27(void) {
    	static int8_t x185 = INT8_MAX;
	volatile int16_t x186 = INT16_MAX;
	uint64_t x187 = UINT64_MAX;
	int32_t x188 = INT32_MIN;
	static volatile int32_t t27 = 1;

    t27 = (x185<<(x186!=(x187==x188)));

    if (t27 != 254) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
_t x185 = INT8_MAX;
volatile int16_t x186 = INT16_MAX;
uint64_t x187 = UINT64_MAX;
int32_t x188 = INT32_MIN;
static volatile int32_t t27 = 1;
t27 = (x185<<(x186!=(x187==
```
<Overlap Ratio: 0.689795918367347>

---

--- 373 --
Question ID: 275a856b61fc9138aeff88662fb16fd638aaef95_4
Original Code:
```
void app_qspi_std_write(periph_inst_handle_t hdl,uint8_t cs_sel_mask,uint8_t *data,uint32_t length)
{
    app_qspi_inst_t *inst = CONTAINER_OF(hdl, app_qspi_inst_t, inst);
    uint16_t fifo_depth = qspi_get_fifo_depth(inst);
    reg_ssi_t *reg = inst->reg;
    qspi_universal_func.clk_gate_func(inst,SET_CLK);
    qspi_universal_func.sys_stat_func(inst,QSPI_OP_START);
    qspi_std_byte_write_dma_config(reg,fifo_depth);
    qspi_std_byte_write_dma_start(reg,cs_sel_mask,data,length);
    qspi_universal_func.sys_stat_func(inst,QSPI_OP_DONE);
    qspi_universal_func.clk_gate_func(inst,CLR_CLK);
}
```


Overlapping Code:
```
 app_qspi_std_write(periph_inst_handle_t hdl,uint8_t cs_sel_mask,uint8_t *data,uint32_t length)
{
app_qspi_inst_t *inst = CONTAINER_OF(hdl, app_qspi_inst_t, inst);
uint16_t fifo_depth = qspi_get_fifo_depth(inst);
reg_ssi_t *reg = inst->reg;
qspi_universal_func.clk_gate_func(inst,SET_CLK);
qspi_universal_func.sys_stat_func(inst,QSPI_OP_START);
qspi_std_byte_write_dma_config(reg,fifo_depth);
qspi_std_byte_write_dma_start(reg,cs_sel_mask,data,length);
qspi_universal_func.sys_stat_func(inst,QSPI_OP_DONE);
qspi_universal_func.clk_gate_func(
```
<Overlap Ratio: 0.964349376114082>

---

--- 374 --
Question ID: 030b0c280f188ad3d3ce6807c485dc62b9066d03_15
Original Code:
```
void gp2x_video_RGB_setscaling(int W, int H)
{
 float escalaw,escalah;
 int bpp=(gp2x_memregs[0x28DA>>1]>>9)&0x3;

 if(gp2x_memregs[0x2800>>1]&0x100) //TV-Out
 {
   escalaw=489.0; //RGB Horiz TV (PAL, NTSC)
   if (gp2x_memregs[0x2818>>1]  == 287) //PAL
     escalah=274.0; //RGB Vert TV PAL
   else if (gp2x_memregs[0x2818>>1]  == 239) //NTSC
     escalah=331.0; //RGB Vert TV NTSC
 }
 else //LCD
 {
   escalaw=1024.0; //RGB Horiz LCD
   escalah=320.0; //RGB Vert LCD
 }

 // scale horizontal
 gp2x_memregs[0x2906>>1]=(unsigned short)((float)escalaw *(W/320.0));
 // scale vertical
 gp2x_memregl[0x2908>>2]=(unsigned long)((float)escalah *bpp *(H/240.0));
}
```


Overlapping Code:
```
iz TV (PAL, NTSC)
if (gp2x_memregs[0x2818>>1] == 287) f (gp2x_memregs[0x2818>>1] == 239) //NTSC
escalah=331.
// scale horizontal
gp2x_memregs[0x2906>>1]=(unsical
gp2x_memregl[0x2908>>2]=(unsigned long)((float)escalah *bpp *(H/240.0));
```
<Overlap Ratio: 0.37987012987012986>

---

--- 375 --
Question ID: ac980cb9aa3ea9ad14e39b883edfc98bdba3ac48_27
Original Code:
```
void f27(void) {
    	uint32_t x109 = UINT32_MAX;
	uint32_t x110 = 453942U;
	volatile uint32_t x111 = UINT32_MAX;
	static int8_t x112 = -1;
	static volatile int32_t t27 = 1;

    t27 = ((x109&(x110+x111))<=x112);

    if (t27 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
INT32_MAX;
uint32_t x110 = 453942U;
volatile uint32_t x111 = UINT32_MAX;
static int8_t x112 = -1;
static volatile int32_t t27 = 1;
t27 = ((x109&(x110+x111))<=x112);
if (t27 != 1) { NG(); } else { ; }

```
<Overlap Ratio: 0.847457627118644>

---

--- 376 --
Question ID: 805aafd11e5e9d939f33694147e5379390592157_0
Original Code:
```
void ADC_initCustom(ADC_referenceSelect reference,
        ADC_precisionSelect precision, ADC_inputSelect channel) {
    // Set registers to their reset conditions..
    ADC12CTL0 = 0;
    ADC12CTL1 = 0;
    ADC12CTL2 = 0;
    ADC12MCTL0 = 0;
    ADC12IER0 = 0;

    // Select reference voltage.
    ADC_setReference(reference);

    // Turn on ADC.
    ADC_enable();

    // Enable using sample and hold pulse mode and use clock as source.
    ADC_setSampleHold();

    // Set resolution to 10 bits. (see user guide 25.3.3)
    ADC_setPrecision(precision);

    // enable interrupt
    ADC_enableInterrupts();

    // Select analog input channel.
    ADC_setInputChannel(channel);

    // Enable ADC conversions
    ADC_enableConversion();
}
```


Overlapping Code:
```
t reference,
ADC_precisionSelect precision, ADC_inputSelect channel) {
// Set registers to their reset conditions..
ADC12CTL0 = 0;
ADC12CTL1 = 0;
ADC12CTL2 = 0;
ADC12MCTL0 = 0;
ADC12IER0 = 0;
// Select reference voltage.
ADC_setReference(reference);
// Turn on ADC.
ADC_enable();
// Enable using sample and hold pulse mode and use clock as source.
ADC_setSampleHold();
// Set resolution to 10 bits. (see user guide 25.3.3)
ADC_setPrecision(precision);
// enable interrupt
ADC_enableInterrupts();
// Select analog input channel.
ADC_setInputChannel(channel);
// Enable ADC conversions
ADC_enableConver
```
<Overlap Ratio: 0.9273570324574961>

---

--- 377 --
Question ID: 3769732de566494ff755e7a7c10d62f1bcccf46a_0
Original Code:
```
static void update_crc(unsigned short *crc, unsigned char ch)
{
	unsigned char v;
	unsigned int i;
	unsigned short flag;

	v = 1;
	for (i = 0; i < 8; i++) {
		flag = (*crc & 0x8000);
		*crc = *crc << 1;

		if (ch & v)
			*crc = *crc + 1;

		if (flag != 0)
			*crc = *crc ^ POLY;

		v = v << 1;
	}
}
```


Overlapping Code:
```
*crc, unsigned char ch)
{
unsigned char v;
unsigned int i;
unsigned short flag;
v = 1;
for (i = 0; i < 8; i++) {
flag = (*crc & 0x8000);
*crc = *crc << 1;
if (ch & v)
*crc = *crc + 1;
if (flag != 0)
*
```
<Overlap Ratio: 0.7352941176470589>

---

--- 378 --
Question ID: 8ae79584d0ab9413ec98b980b1b45613ae5f14ab_161
Original Code:
```
void f161(void) {
    	int8_t x1005 = 1;
	uint16_t x1006 = UINT16_MAX;
	uint16_t x1007 = 5962U;
	volatile int64_t x1008 = INT64_MIN;
	int64_t t161 = -8105LL;

    t161 = ((x1005/(x1006%x1007))*x1008);

    if (t161 != 0LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x1006 = UINT16_MAX;
uint16_t x1007 = 5962U;
volatile int64_t x1008 = INT64_MIN;
int64_t t161 = -8105LL;
t161 = ((x1005/(x1006%x1007))*x1008);
if (t16
```
<Overlap Ratio: 0.6607929515418502>

---

--- 379 --
Question ID: d184469f515af0f3aca312179aea8b27a1819102_186
Original Code:
```
void f186(void) {
    	static volatile int16_t x777 = -1;
	int16_t x778 = INT16_MIN;
	int32_t x780 = -1;
	int32_t t186 = 563;

    t186 = ((x777^x778)|(x779%x780));

    if (t186 != 32767) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
186(void) {
static volatile int16_t x777 = -1;
int16_t x778 = INT16_MIN;
int32_t x780 = -1;
int32_t t186 = 563;
t186 = ((x777^x778)|(x779%x780));
if (
```
<Overlap Ratio: 0.7731958762886598>

---

--- 380 --
Question ID: 369d385cd5269f3896bc976c05c341dc956f78a8_3
Original Code:
```
static double
bddCorrelationWeightsAux(
  DdManager * dd,
  DdNode * f,
  DdNode * g,
  double * prob,
  st_table * table)
{
    DdNode	*Fv, *Fnv, *G, *Gv, *Gnv;
    double	min, *pmin, min1, min2, *dummy;
    HashEntry	*entry;
    int		topF, topG, index;

    statLine(dd);
#ifdef CORREL_STATS
    num_calls++;
#endif

    /* Terminal cases: only work for BDDs. */
    if (f == g) return(1.0);
    if (f == Cudd_Not(g)) return(0.0);

    /* Standardize call using the following properties:
    **     (f EXNOR g)   = (g EXNOR f)
    **     (f' EXNOR g') = (f EXNOR g).
    */
    if (f > g) {
	DdNode *tmp = f;
	f = g; g = tmp;
    }
    if (Cudd_IsComplement(f)) {
	f = Cudd_Not(f);
	g = Cudd_Not(g);
    }
    /* From now on, f is regular. */
    
    entry = ALLOC(HashEntry,1);
    if (entry == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    entry->f = f; entry->g = g;

    /* We do not use the fact that
    ** correlation(f,g') = 1 - correlation(f,g)
    ** to minimize the risk of cancellation.
    */
    if (st_lookup(table, entry, &dummy)) {
	min = *dummy;
	FREE(entry);
	return(min);
    }

    G = Cudd_Regular(g);
    topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);
    if (topF <= topG) {
	Fv = cuddT(f); Fnv = cuddE(f);
	index = f->index;
    } else {
	Fv = Fnv = f;
	index = G->index;
    }
    if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }

    if (g != G) {
	Gv = Cudd_Not(Gv);
	Gnv = Cudd_Not(Gnv);
    }

    min1 = bddCorrelationWeightsAux(dd, Fv, Gv, prob, table) * prob[index];
    if (min1 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return((double)CUDD_OUT_OF_MEM);
    }
    min2 = bddCorrelationWeightsAux(dd, Fnv, Gnv, prob, table) * (1.0 - prob[index]); 
    if (min2 == (double)CUDD_OUT_OF_MEM) {
	FREE(entry);
	return((double)CUDD_OUT_OF_MEM);
    }
    min = (min1+min2);
    
    pmin = ALLOC(double,1);
    if (pmin == NULL) {
	dd->errorCode = CUDD_MEMORY_OUT;
	return((double)CUDD_OUT_OF_MEM);
    }
    *pmin = min;

    if (st_insert(table,(char *)entry, (char *)pmin) == ST_OUT_OF_MEM) {
	FREE(entry);
	FREE(pmin);
	return((double)CUDD_OUT_OF_MEM);
    }
    return(min);

}
```


Overlapping Code:
```
double
bddCorrelationWeightsAux(
DdManager * dd,
DdNode * f,
DdNode * g,
double * prob,
st_table * table)
{
DdNode *Fv, *Fnv, *G, *Gv, *Gnv;
double min, *pmin, min1, min2, *dummy;
HashEntry *entry;
int topF, topG, index;
statLine(dd);
#ifdef CORREL_STATS
num_calls++;
#endif
/* Terminal cases: only work for BDDs. */
if (f == g) return(1.0);
if (f == Cudd_Not(g)) return(0.0);
/* Standardize call using the following properties:
** (f EXNOR g) = (g EXNOR f)
** (f' EXNOR g') = (f EXNOR g).
*/
if (f > g) {
DdNode *tmp = f;
f = g; g = tmp;
}
if (Cudd_IsComplement(f)) {
f = Cudd_Not(f);
g = Cudd_Not(g);
}
/* From now on, f is regular. */

entry = ALLOC(HashEntry,1);
if (entry == NULL) {
dd->errorCode = CUDD_MEMORY_OUT;
return((double)CUDD_OUT_OF_MEM);
}
entry->f = f; entry->g = g;
/* We do not use the fact that
** correlation(f,g') = 1 - correlation(f,g)
** to minimize the risk of cancellation.
*/
if (st_lookup(table, entry, &dummy)) {
min = *dummy;
FREE(entry);
return(min);
}
G = Cudd_Regular(g);
topF = cuddI(dd,f->index); topG = cuddI(dd,G->index);
if (topF <= topG) {
Fv = cuddT(f); Fnv = cuddE(f);
index = f->index;
} else {
Fv = Fnv = f;
index = G->index;
}
if (topG <= topF) { Gv = cuddT(G); Gnv = cuddE(G); } else { Gv = Gnv = G; }
if (g != G) {
Gv = Cudd_Not(Gv);
Gnv = Cudd_Not(Gnv);
}
min1 = bddCorrelationWeightsAux(dd, Fv, Gv, prob, table) * prob[index];
if (min1 == (double)CUDD_OUT_OF_MEM) {
FREE(entry);
return((double)CUDD_OUT_OF_MEM);
}
min2 = bddCorrelationWeightsAux(dd, Fnv, Gnv, prob, table) * (1.0 - prob[index]); 
if (min2 == (double)CUDD_OUT_OF_MEM) {
FREE(entry);
return((double)CUDD_OUT_OF_MEM);
}
min = (min1+min2);

pmin = ALLOC(double,1);
if (pmin == NULL) {
dd->errorCode = CUDD_MEMORY_OUT;
return((double)CUDD_OUT_OF_MEM);
}
*pmin = min;
if (st_insert(table,(char *)entry, (char *)pmin) == ST_OUT_OF_MEM) {
FREE(entry);
FREE(pmin);
return((double)CUDD_OUT_OF_MEM);
}
return(min);
```
<Overlap Ratio: 0.9953295277633627>

---

--- 381 --
Question ID: 8dd55a4a6e04d0a17102c3aa67b57e473c0ce830_169
Original Code:
```
void f169(void) {
    	uint8_t x710 = 1U;
	static volatile int16_t x711 = -410;
	volatile int32_t t169 = -750826;

    t169 = (x709!=(x710+(x711%x712)));

    if (t169 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
int8_t x710 = 1U;
static volatile int16_t x711 = -410;
volatile int32_t t169 = -750826;
t169 = (x709!=(x710+(x711%x712)));
if (t169 != 1) { NG(); } el
```
<Overlap Ratio: 0.8333333333333334>

---

--- 382 --
Question ID: 61149dfe793f6210203e86e9722ccf0cd1c4cd5e_194
Original Code:
```
void f194(void) {
    	volatile int64_t x1029 = -115933LL;
	static uint32_t x1030 = 21U;
	static uint32_t x1031 = UINT32_MAX;
	static volatile uint8_t x1032 = UINT8_MAX;
	int64_t t194 = 133366559822157445LL;

    t194 = ((x1029+x1030)^(x1031+x1032));

    if (t194 != -115770LL) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
(void) {
volatile int64_t x1029 = -115933LL;
static uint32_t x1030 = 21U;
static uint32_t x1031 = UINT32_MAX;
static volatile uint8_t x1032 = UINT8_MAX;
int64_t t194 = 133366559822157445LL;
t194 = ((x1029+x1030)^(x1031+x1032));
if (t194 != -115770LL)
```
<Overlap Ratio: 0.8833922261484098>

---

--- 383 --
Question ID: 4f6f87b39e652378e664b40f7feb12d364d66d2f_99
Original Code:
```
void f99(void) {
    	int32_t x397 = -5941127;
	int64_t x398 = INT64_MIN;
	int32_t x400 = INT32_MAX;
	int32_t t99 = 5811;

    t99 = (((x397<=x398)<=x399)!=x400);

    if (t99 != 1) { NG(); } else { ; }
	
}
```


Overlapping Code:
```
 x398 = INT64_MIN;
int32_t x400 = INT32_MAX;
int32_t t99 = 5811;
t99 = (((x397<=x398)<=x399)!=x400);
if (t99 != 1) { NG(); } else
```
<Overlap Ratio: 0.6898395721925134>

---

