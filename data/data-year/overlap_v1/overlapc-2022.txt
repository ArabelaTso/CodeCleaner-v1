--- 0 --
Question ID: 0db763ca944c3901689601369d2359d69ec813d3_0
Original Code:
```
class Role {
public:
	Role(int type);
	~Role();

	void operator =(Role player);

	string getName();
	int getType();

	int getHealth_max();
	void setHealth_max(int hp_m);

	int getHealth();
	void setHealth(int hp);

	int getMagic_max();
	void setMagic_max(int mp_m);

	int getMagic();
	void setMagic(int mp);

	int getAttack();
	void setAttack(int a);

	int getDefend();
	void setDefend(int d);

	int getExp();
	void setExp(int e);
	void setExpSave(int e);
	int getLevelExp_max(int whichLevel);

	int getLevel();
	void setLevel(int l);
	void setLevelSave(int l);

	int getMoney();
	void setMoney(int m);

	int getMapId();
	void setMapId(int NewMapId);

	int getStory();
	void setStory(int s);

	Skill getSkill();
	void setSkill(Skill &newSkill);

	void addSaveGoodsToBag(int goodId,int num);

	Bag getBag();
	void showBag();
	int getBagWhichGoodsId(int whichGoods);			//得到背包里第whichGoods件物品
	int getBagWhichGoodsNum(int whichGoods);
	//显示背包
	void addGoodsToBag(int *goodsId, int* num);//加入背包,重载应对两种情况
	void addGoodsToBag(int goodsId, int num);

	bool subGoodsToBag(int goodsId, int num);	//减少背包里的物品

	void setBag(Bag bags);

	void savePlayerBag();		//用来单独保存背包
	//int** getBagSave();
	void newBag();

	void showRole();//人物属性 当前装备
	bool showSkill();//显示技能,返回是否可以使用技能

	double useSkill();		//使用技能,返回技能的攻击力加成
	void useDrug();			//使用药品

	int getWeapon();
	void setWeapon(int w);
	int getClothes();
	void setClothes(int c);

	void showEquip();//展示当前装备
	void wearEquip(int id);//穿上装备
	void removeEquip(int id);//脱下装备

	int getTaskId();
	bool getTaskIsEnd();
	void setTask(Task newTask);
	void setTaskIsEnd();
	Task getTask();
	string getTaskName();
	string getTaskDesc();
	Goods getTaskGoods();
	void setTaskGoods(Goods newTaskGoods);

private:
	string name;
	int type;
	int health_max;
	int health;
	int magic_max;
	int magic;
	int attack;
	int exp;
	//每个等级对应的最高经验值，经验值大于等于就升级
	const int levelExp_Max[29] = { 6,12,18,24,30,36,42,48,54,60,69,78,87,96,105,114,123,132,141,150,162,174,186,198,210,225,240,270,300 };
	int exp_Max;		//线性经验值，暂定为最高300
	int level;
	int defend;			//防御
	int money;
	Bag bag;			//背包
	//int bag[20];
	int mapId;			//记录玩家当前所在地
	Skill skill;		//他所拥有的技能
	int skillLevel;		//升级带来的技能升级点数
	int story = 0;//剧情节点
	int weapon = -1;//当前武器id  默认-1为无
	int clothes = -1; //当前防具id
	Task task;
				  //物品实例化
	Goods goods[24] = { 0, 1, 2, 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23 };

}
```


Overlapping Code:
```
e {
public:
Role(int type);
~Role();
void operator =(Role player);
string getName();
int getType();
int getHealth_max();
void setHealth_max(int hp_m);
int getHealth();
void setHealth(int hp);
int getMagic_max();
void setMagic_max(int mp_m);
int getMagic();
void setMagic(int mp);
int getAttack();
void setAttack(int a);
int getDefend();
void setDefend(int d);
int getExp();
void setExp(int e);
void setExpSave(int e);
int getLevelExp_max(int whichLevel);
int getLevel();
void setLevel(int l);
void setLevelSave(int l);
int getMoney();
void setMoney(int m);
int getMapId();
void setMapId(int NewMapId);
int getStory();
void setStory(int s);
Skill getSkill();
void setSkill(Skill &newSkill);
void addSaveGoodsToBag(int goodId,int num);
Bag getBag();
void showBag();
int getBagWhichGoodsId(int whichGoods); //得到背包里第whichGoods件物品
int getBagWhichGoodsNum(int whichGoods);
//显示背包
void addGoodsToBag(int *goodsId, int* num);//加入背包,重载应对两种情况
void addGoodsToBag(int goodsId, int num);
bool subGoodsToBag(int goodsId, int num); //减少背包里的物品
void setBag(Bag bags);
void savePlayerBag(); //用来单独保存背包
//int** getBagSave();
void newBag();
void showRole();//人物属性 当前装备
bool showSkill();//显示技能,返回是否可以使用技能
double useSkill(); //使用技能,返回技能的攻击力加成
void useDrug(); //使用药品
int getWeapon();
void setWeapon(int w);
int getClothes();
void setClothes(int c);
void showEquip();//展示当前装备
void wearEquip(int id);//穿上装备
void removeEquip(int id);//脱下装备
int getTaskId();
bool getTaskIsEnd();
void setTask(Task newTask);
void setTaskIsEnd();
Task getTask();
string getTaskName();
string getTaskDesc();
Goods getTaskGoods();
void setTaskGoods(Goods newTaskGoods);
private:
string name;
int type;
int health_max;
int health;
int magic_max;
int magic;
int attack;
int exp;
//每个等级对应的最高经验值，经验值大于等于就升级
const int levelExp_Max[29] = { 6,12,18,24,30,36,42,48,54,60,69,78,87,96,105,114,123,132,141,150,162,174,186,198,210,225,240,270,300 };
int exp_Max; //线性经验值，暂定为最高300
int level;
int defend; //防御
int money;
Bag bag; //背包
//int bag[20];
int mapId; //记录玩家当前所在地
Skill skill; //他所拥有的技能
int skillLevel; //升级带来的技能升级点数
int story = 0;//剧情节点
int weapon = -1;//当前武器id 默认-1为无
int clothes = -1; //当前防具id
Task task;
//物品实例化
Goods goods[24] = { 0, 1, 2, 3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,2
```
<Overlap Ratio: 0.9959928762243989>

---

--- 1 --
Question ID: b4de00b240618e58dd42710f5caf2e5b3cc73b1e_81
Original Code:
```
static grn_rc
get_identifier(grn_ctx *ctx, efs_info *q, grn_obj *name_resolve_context)
{
  const char *s;
  unsigned int len;
  grn_rc rc = GRN_SUCCESS;
  for (s = q->cur; s < q->str_end; s += len) {
    if (!(len = grn_charlen(ctx, s, q->str_end))) {
      rc = GRN_END_OF_DATA;
      goto exit;
    }
    if (grn_isspace(s, ctx->encoding)) { goto done; }
    if (len == 1) {
      switch (*s) {
      case '\0' : case '(' : case ')' : case '{' : case '}' :
      case '[' : case ']' : case ',' : case ':' : case '@' :
      case '?' : case '"' : case '*' : case '+' : case '-' :
      case '|' : case '/' : case '%' : case '!' : case '^' :
      case '&' : case '>' : case '<' : case '=' : case '~' :
        /* case '.' : */
        goto done;
        break;
      }
    }
  }
done :
  len = s - q->cur;
  switch (*q->cur) {
  case 'd' :
    if (len == 6 && !memcmp(q->cur, "delete", 6)) {
      PARSE(GRN_EXPR_TOKEN_DELETE);
      goto exit;
    }
    break;
  case 'f' :
    if (len == 5 && !memcmp(q->cur, "false", 5)) {
      grn_obj buf;
      PARSE(GRN_EXPR_TOKEN_BOOLEAN);
      GRN_BOOL_INIT(&buf, 0);
      GRN_BOOL_SET(ctx, &buf, 0);
      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
      GRN_OBJ_FIN(ctx, &buf);
      goto exit;
    }
    break;
  case 'i' :
    if (len == 2 && !memcmp(q->cur, "in", 2)) {
      PARSE(GRN_EXPR_TOKEN_IN);
      goto exit;
    }
    break;
  case 'n' :
    if (len == 4 && !memcmp(q->cur, "null", 4)) {
      grn_obj buf;
      PARSE(GRN_EXPR_TOKEN_NULL);
      GRN_VOID_INIT(&buf);
      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
      GRN_OBJ_FIN(ctx, &buf);
      goto exit;
    }
    break;
  case 't' :
    if (len == 4 && !memcmp(q->cur, "true", 4)) {
      grn_obj buf;
      PARSE(GRN_EXPR_TOKEN_BOOLEAN);
      GRN_BOOL_INIT(&buf, 0);
      GRN_BOOL_SET(ctx, &buf, 1);
      grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
      GRN_OBJ_FIN(ctx, &buf);
      goto exit;
    }
    break;
  }
  {
    grn_obj *obj;
    const char *name = q->cur;
    unsigned int name_size = s - q->cur;
    if (name_resolve_context) {
      if ((obj = grn_obj_column(ctx, name_resolve_context, name, name_size))) {
        if (obj->header.type == GRN_ACCESSOR) {
          grn_expr_take_obj(ctx, q->e, obj);
        }
        PARSE(GRN_EXPR_TOKEN_IDENTIFIER);
        grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 2);
        goto exit;
      }
    }
    if ((obj = grn_expr_get_var(ctx, q->e, name, name_size))) {
      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);
      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);
      goto exit;
    }
    if ((obj = grn_obj_column(ctx, q->table, name, name_size))) {
      if (obj->header.type == GRN_ACCESSOR) {
        grn_expr_take_obj(ctx, q->e, obj);
      }
      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);
      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 1);
      goto exit;
    }
    if ((obj = resolve_top_level_name(ctx, name, name_size))) {
      if (obj->header.type == GRN_ACCESSOR) {
        grn_expr_take_obj(ctx, q->e, obj);
      }
      PARSE(GRN_EXPR_TOKEN_IDENTIFIER);
      grn_expr_append_obj(ctx, q->e, obj, GRN_OP_PUSH, 1);
      goto exit;
    }
    if (q->flags & GRN_EXPR_SYNTAX_OUTPUT_COLUMNS) {
      PARSE(GRN_EXPR_TOKEN_NONEXISTENT_COLUMN);
    } else {
      rc = GRN_SYNTAX_ERROR;
      ERR(rc,
          "[expr][parse] unknown identifier: <%.*s>",
          (int)name_size,
          name);
    }
  }
exit :
  q->cur = s;
  return rc;
}
```


Overlapping Code:
```
r(grn_ctx *ctx, efs_info *q, grn_obj *name_resolve_context)
{
const char *s;
unsigned int len;
grn_rc rc = GRN_SUCCESS;
for (s = q->cur; s < q->str_end; s += len) {
if (!(len = grn_charlen(ctx, s, q->str_end))) {
rc = GRN_END_OF_DATA;
goto exit;
}
if (grn_isspace(s, ctx->encoding)) { goto done; }
if (len == 1) {
switch (*s) {
case '\0' : case '(' : case ')' : case '{' : case '}' :
case '[' : case ']' : case ',' : case ':' : case '@' :
case '?' : case '"' : case '*' : case '+' : case '-' :
case '|' : case '/' : case '%' : case '!' : case '^' :
case '&' : case '>' : case '<' : case '=' : case '~' :
/* case '.' : */
goto done;
break;
}
}
}
done :
len = s - q->cur;
switch (*q->cur) {
case 'd' :
if (len == 6 && !memcmp(q->cur, "delete", 6)) {
PARSE(GRN_EXPR_TOKEN_DELETE);
goto exit;
}
break;
case 'f' :
if (len == 5 && !memcmp(q->cur, "false", 5)) {
grn_obj buf;
PARSE(GRN_EXPR_TOKEN_BOOLEAN);
GRN_BOOL_INIT(&buf, 0);
GRN_BOOL_SET(ctx, &buf, 0);
grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
GRN_OBJ_FIN(ctx, &buf);
goto exit;
}
break;
case 'i' :
if (len == 2 && !memcmp(q->cur, "in", 2)) {
PARSE(GRN_EXPR_TOKEN_IN);
goto exit;
}
break;
case 'n' :
if (len == 4 && !memcmp(q->cur, "null", 4)) {
grn_obj buf;
PARSE(GRN_EXPR_TOKEN_NULL);
GRN_VOID_INIT(&buf);
grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
GRN_OBJ_FIN(ctx, &buf);
goto exit;
}
break;
case 't' :
if (len == 4 && !memcmp(q->cur, "true", 4)) {
grn_obj buf;
PARSE(GRN_EXPR_TOKEN_BOOLEAN);
GRN_BOOL_INIT(&buf, 0);
GRN_BOOL_SET(ctx, &buf, 1);
grn_expr_append_const(ctx, q->e, &buf, GRN_OP_PUSH, 1);
GRN_OBJ_FIN(ctx, &buf);
goto exit;
}
break;
}
{
grn_obj *obj;
const char *name = q->cur;
unsigned int name_size = s - q->cur;
if (name_resolve_context) {
if ((obj = grn_obj_column(ctx, name_resolve_context, name, name_size))) {
if (obj->header.type == GRN_ACCESSOR) {
grn_expr_take_obj(ctx, q->e, obj);
}
PARSE(GRN_EXPR_TOKEN_IDENTIFIER);
grn_expr_append_obj(ctx, q->e, obj, GRN_OP_GET_VALUE, 2);
goto exit;
}
}
if ((obj = grn_expr_get_var(ctx, q->e, name, name
```
<Overlap Ratio: 0.9822029822029822>

---

--- 2 --
Question ID: 11bc3281838e95a617c165e3274baf948a72359e_0
Original Code:
```
double CamState(double time, double rpm, double& CamPosition, double& CamVelocity, double& CamAcceleration)
{
  double t = time;
  //  double rpm = *param;
  double res = -0.0;
  double w, beta, hc, hcp, hcpp, mass, kspring, cfriction, phio;
  double PI = 3.14159265;
  double Rb = 0.40;
  double k1 = 0.45;
  double k2 = 0.40393320723821;
  double rho1 = 0.85;
  double rho3 = 0.15;
  double rho2 = 0.55393320723821;
  double dBetadt, tmp1;
  double beta1 = 0;
  double beta2 = 1.050328174371336;
  double beta3 = 1.22173047639603;


  // char str [80],comando[80];
  //   float f;
  //   FILE * pFile;

  //   pFile = fopen ("parameters.txt","r");
  //   rewind (pFile);
  //   fscanf (pFile, "%f", &f);
  //   fclose (pFile);
  // printf ("%f\n",f);
  //rpm=(double)(f);

  phio = PI / 2;
  //  rpm=358;

  //  printf ("%f\n",rpm);
  //  rpm=150;
  w = 2 * PI * rpm / 60;
  mass = 1.221;
  kspring = 1430.8;
  cfriction = 0;

  beta = w * t;
  beta = fmod(beta + phio, 2 * PI);

  //hc=sin(beta)-0.9;
  //hp=w*cos(beta);
  //hpp=-w*w*sin(beta);

  if (beta > PI)
  {
    beta = 2 * PI - beta;
    w = -w;
  }
  dBetadt = w;
  if (beta <= (PI / 2 - beta1))
  {
    hc = Rb;
    hcp = 0;
    hcpp = 0;
  }
  else if (beta <= (PI / 2 + beta2))
  {
    hc = -k1 * sin(beta) + rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)) ;
    hcp = (-k1 * cos(beta) + (pow(k1, 2) * sin(beta) * cos(beta)) / (rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)))) * dBetadt;
    tmp1 = pow(cos(beta - beta1), 2) - pow(sin(beta - beta1), 2) - (pow(k1 * sin(beta - beta1) * cos(beta - beta1), 2)) / (pow(rho1, 2) * (1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)));
    hcpp = (k1 * sin(beta - beta1) + (pow(k1, 2) / (rho1 * sqrt(1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)))) * tmp1) * (pow(dBetadt, 2));
  }
  else if (beta <= (PI / 2 + beta3))
  {
    hc = -k2 * cos(beta + PI / 9) + rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)) ;
    hcp = (k2 * sin(beta + PI / 9) - (pow(k2, 2) * sin(beta + PI / 9) * cos(beta + PI / 9)) / (rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)))) * dBetadt;
    tmp1 = pow(cos(beta - beta3), 2) - pow(sin(beta - beta3), 2) - (pow(k2 * sin(beta - beta3) * cos(beta - beta3), 2)) / (pow(rho3, 2) * (1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)));
    hcpp = (-k2 * sin(beta - beta3) + (pow(k2, 2) / (rho3 * sqrt(1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)))) * tmp1) * pow(dBetadt, 2);
  }
  else
  {
    hc = rho2;
    hcp = 0;
    hcpp = 0;
  }

  hc = hc - 0.3;

  CamPosition = hc;
  CamVelocity = hcp;
  CamAcceleration = hcpp;
  res = -(mass * hcpp + cfriction * hcp + kspring * hc);
  //res=0;
  return res;
}
```


Overlapping Code:
```
ime, double rpm, double& CamPosition, double& CamVelocity, double& CamAcceleration)
{
double t = time;
// double rpm = *param;
double res = -0.0;
double w, beta, hc, hcp, hcpp, mass, kspring, cfriction, phio;
double PI = 3.14159265;
double Rb = 0.40;
double k1 = 0.45;
double k2 = 0.40393320723821;
double rho1 = 0.85;
double rho3 = 0.15;
double rho2 = 0.55393320723821;
double dBetadt, tmp1;
double beta1 = 0;
double beta2 = 1.050328174371336;
double beta3 = 1.22173047639603;
// char str [80],comando[80];
// float f;
// FILE * pFile;
// pFile = fopen ("parameters.txt","r");
// rewind (pFile);
// fscanf (pFile, "%f", &f);
// fclose (pFile);
// printf ("%f\n",f);
//rpm=(double)(f);
phio = PI / 2;
// rpm=358;
// printf ("%f\n",rpm);
// rpm=150;
w = 2 * PI * rpm / 60;
mass = 1.221;
kspring = 1430.8;
cfriction = 0;
beta = w * t;
beta = fmod(beta + phio, 2 * PI);
//hc=sin(beta)-0.9;
//hp=w*cos(beta);
//hpp=-w*w*sin(beta);
if (beta > PI)
{
beta = 2 * PI - beta;
w = -w;
}
dBetadt = w;
if (beta <= (PI / 2 - beta1))
{
hc = Rb;
hcp = 0;
hcpp = 0;
}
else if (beta <= (PI / 2 + beta2))
{
hc = -k1 * sin(beta) + rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)) ;
hcp = (-k1 * cos(beta) + (pow(k1, 2) * sin(beta) * cos(beta)) / (rho1 * sqrt(1 - pow((cos(beta)) * (k1 / rho1), 2)))) * dBetadt;
tmp1 = pow(cos(beta - beta1), 2) - pow(sin(beta - beta1), 2) - (pow(k1 * sin(beta - beta1) * cos(beta - beta1), 2)) / (pow(rho1, 2) * (1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)));
hcpp = (k1 * sin(beta - beta1) + (pow(k1, 2) / (rho1 * sqrt(1 - pow((cos(beta - beta1)) * (k1 / rho1), 2)))) * tmp1) * (pow(dBetadt, 2));
}
else if (beta <= (PI / 2 + beta3))
{
hc = -k2 * cos(beta + PI / 9) + rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)) ;
hcp = (k2 * sin(beta + PI / 9) - (pow(k2, 2) * sin(beta + PI / 9) * cos(beta + PI / 9)) / (rho3 * sqrt(1 - pow((sin(beta + PI / 9)) * (k2 / rho3), 2)))) * dBetadt;
tmp1 = pow(cos(beta - beta3), 2) - pow(sin(beta - beta3), 2) - (pow(k2 * sin(beta - beta3) * cos(beta - beta3), 2)) / (pow(rho3, 2) * (1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)));
hcpp = (-k2 * sin(beta - beta3) + (pow(k2, 2) / (rho3 * sqrt(1 - pow((cos(beta - beta3)) * (k2 / rho3), 2)))) * tmp1) * pow(dBetadt, 2);
}
else
{
hc = rho2;
hcp = 
```
<Overlap Ratio: 0.9813205907906168>

---

--- 3 --
Question ID: 5fcecf3f2502e5ba3ca431657f56d45e311fba4c_10
Original Code:
```
static void
exp_generate_sneak_decoder(struct exp_list *elist) {
  struct exp *exp;
  int ofp_header = 0;

  /* Header output. */
  exp_generate_sneak_decoder_function(elist, fp_header);
  fprintf(fp_header, ";\n");

  /* ofp_header check. */
#if 0
  if (strcmp(elist->name, "ofp_header") != 0) {
    TAILQ_FOREACH(exp, &elist->tailq, entry) {
      if (exp->type == EXP_TYPE_STRUCT_DECLARATION &&
          strcmp(exp->decl.type, "ofp_header") == 0) {
        ofp_header = 1;
      }
    }
  }
#endif

  /* Source output. */
  exp_generate_sneak_decoder_function(elist, fp_source);
  fprintf(fp_source, "\n");
  fprintf(fp_source, "{\n");
  fprintf(fp_source, "  /* Size check. */\n");
  if (ofp_header == 1) {
    fprintf(fp_source,
            "  if (pbuf->plen < (sizeof(struct %s) - sizeof(struct ofp_header)))\n",
            elist->name);
  } else {
    fprintf(fp_source, "  if (pbuf->plen < sizeof(struct %s))\n", elist->name);
  }
  fprintf(fp_source, "    return LAGOPUS_RESULT_OUT_OF_RANGE;\n");
  fprintf(fp_source, "\n");

  fprintf(fp_source, "  /* Decode packet. */\n");
  TAILQ_FOREACH(exp, &elist->tailq, entry) {
    enum decl_type type;

    /* Look up declaration type. */
    type = decl_type_lookup(exp->decl.type);

    /* In case of simple declaration. */
    if (exp->type == EXP_TYPE_DECLARATION) {
      switch (type) {
        case DECL_TYPE_CHAR:
        case DECL_TYPE_UCHAR:
          fprintf(fp_source, "  DECODE_GETC");
          break;
        case DECL_TYPE_WORD:
          fprintf(fp_source, "  DECODE_GETW");
          break;
        case DECL_TYPE_LONG:
          fprintf(fp_source, "  DECODE_GETL");
          break;
        case DECL_TYPE_LLONG:
          fprintf(fp_source, "  DECODE_GETLL");
          break;
        case DECL_TYPE_UNKNOWN:
          fprintf(stderr, "Error: unknown type %s\n", exp->decl.type);
          exit (1);
          break;
      }

      /* Declaration name. */
      fprintf(fp_source, "(packet->%s);\n", exp->decl.name);
    } else if (exp->type == EXP_TYPE_STRUCT_DECLARATION) {
#if 1 /* Enable all header decode. */
      if (strcmp(exp->decl.type, "ofp_header") == 0) {
        fprintf(fp_source, "  if (%s_decode(pbuf, &packet->%s) < 0) {\n",
                exp->decl.type, exp->decl.name);
        fprintf(fp_source, "    return LAGOPUS_RESULT_OUT_OF_RANGE;\n");
        fprintf(fp_source, "  }\n");
      }
#endif
    } else if (exp->type == EXP_TYPE_ARRAY_STRUCT_DECLARATION) {

    } else {
      switch (type) {
        case DECL_TYPE_WORD:
        case DECL_TYPE_LONG:
        case DECL_TYPE_LLONG:
          fprintf(fp_source, "  for (int i = 0; i < %d; i++) {\n",
                  exp->decl.array_size);
          break;
        default:
          break;
      }

      switch (type) {
        case DECL_TYPE_WORD:
          fprintf(fp_source, "    DECODE_GETW(packet->%s[i]);\n",
                  exp->decl.name);
          break;
        case DECL_TYPE_LONG:
          fprintf(fp_source, "    DECODE_GETL(packet->%s[i]);\n",
                  exp->decl.name);
          break;
        case DECL_TYPE_LLONG:
          fprintf(fp_source, "    DECODE_GETLL(packet->%s[i]);\n",
                  exp->decl.name);
          break;
        default:
          fprintf(fp_source, "  DECODE_GET(packet->%s, %d);\n",
                  exp->decl.name, exp->decl.array_size);
          break;
      }

      switch (type) {
        case DECL_TYPE_WORD:
        case DECL_TYPE_LONG:
        case DECL_TYPE_LLONG:
          fprintf(fp_source, "  }\n");
          break;
        default:
          break;
      }
    }
  }

  fprintf(fp_source, "  DECODE_REWIND(sizeof(struct %s));\n", elist->name);
  fprintf(fp_source, "\n");
  fprintf(fp_source, "  return LAGOPUS_RESULT_OK;\n");
  fprintf(fp_source, "}\n");
}
```


Overlapping Code:
```
_list *elist) {
struct exp *exp;
int ofp_header = 0;
/* Header output. */
exp_generate_sneak_decoder_function(elist, fp_header);
fprintf(fp_header, ";\n");
/* ofp_header check. */
#if 0
if (strcmp(elist->name, "ofp_header") != 0) {
TAILQ_FOREACH(exp, &elist->tailq, entry) {
if (exp->type == EXP_TYPE_STRUCT_DECLARATION &&
strcmp(exp->decl.type, "ofp_header") == 0) {
ofp_header = 1;
}
}
}
#endif
/* Source output. */
exp_generate_sneak_decoder_function(elist, fp_source);
fprintf(fp_source, "\n");
fprintf(fp_source, "{\n");
fprintf(fp_source, " /* Size check. */\n");
if (ofp_header == 1) {
fprintf(fp_source,
" if (pbuf->plen < (sizeof(struct %s) - sizeof(struct ofp_header)))\n",
elist->name);
} else {
fprintf(fp_source, " if (pbuf->plen < sizeof(struct %s))\n", elist->name);
}
fprintf(fp_source, " return LAGOPUS_RESULT_OUT_OF_RANGE;\n");
fprintf(fp_source, "\n");
fprintf(fp_source, " /* Decode packet. */\n");
TAILQ_FOREACH(exp, &elist->tailq, entry) {
enum decl_type type;
/* Look up declaration type. */
type = decl_type_lookup(exp->decl.type);
/* In case of simple declaration. */
if (exp->type == EXP_TYPE_DECLARATION) {
switch (type) {
case DECL_TYPE_CHAR:
case DECL_TYPE_UCHAR:
fprintf(fp_source, " DECODE_GETC");
break;
case DECL_TYPE_WORD:
fprintf(fp_source, " DECODE_GETW");
break;
case DECL_TYPE_LONG:
fprintf(fp_source, " DECODE_GETL");
break;
case DECL_TYPE_LLONG:
fprintf(fp_source, " DECODE_GETLL");
break;
case DECL_TYPE_UNKNOWN:
fprintf(stderr, "Error: unknown type %s\n", exp->decl.type);
exit (1);
break;
}
/* Declaration name. */
fprintf(fp_source, "(packet->%s);\n", exp->decl.name);
} else if (exp->type == EXP_TYPE_STRUCT_DECLARATION) {
#if 1 /* Enable all header decode. */
if (strcmp(exp->decl.type, "ofp_header") == 0) {
fprintf(fp_source, " if (%s_decode(pbuf, &packet->%s) < 0) {\n",
exp->decl.type, exp->decl.name);
fprintf(fp_source, " return LAGOPUS_RESULT_OUT_OF_RANGE;\n");
fprintf(fp_source, " }\n");
}
#endif
} else if (exp->type == EXP_TYPE_ARRAY_STRUCT_DECLARATION) {
} else {
swit
```
<Overlap Ratio: 0.9712368168744008>

---

--- 4 --
Question ID: ea9284064f729254add2bb73f4cdd791b32f7f3b_56
Original Code:
```
static void test_builtin_macro_override() {
  unsigned char ram[] = { 0x39, 0x30 };
  memory_t memory;
  rc_richpresence_t* richpresence;
  char buffer[256];

  memory.ram = ram;
  memory.size = sizeof(ram);

  assert_parse_richpresence(&richpresence, buffer, "Format:Number\nFormatType=SECS\n\nDisplay:\n@Number(0x 0)");
  assert_richpresence_output(richpresence, &memory, "3h25:45");
}
```


Overlapping Code:
```
acro_override() {
unsigned char ram[] = { 0x39, 0x30 };
memory_t memory;
rc_richpresence_t* richpresence;
char buffer[256];
memory.ram = ram;
memory.size = sizeof(ram);
assert_parse_richpresence(&richpresence, buffer, "Format:Number\nFormatType=SECS\n\nDisplay:\n@Number(0x 0)");
assert_richpresence_output(richpresence, &memory, "
```
<Overlap Ratio: 0.8970189701897019>

---

--- 5 --
Question ID: 5ce709ddbeea6c6b275b62b41fd2823993eb007b_2
Original Code:
```
static void FLEXCAN_ExitFreezeMode(CAN_Type *base)
{
    /* Clear Freeze, Halt bits. */
    base->MCR &= ~CAN_MCR_HALT_MASK;
    base->MCR &= ~CAN_MCR_FRZ_MASK;

    /* Wait until the FlexCAN Module exit freeze mode. */
    while (base->MCR & CAN_MCR_FRZACK_MASK)
    {
    }
}
```


Overlapping Code:
```
e *base)
{
/* Clear Freeze, Halt bits. */
base->MCR &= ~CAN_MCR_HALT_MASK;
base->MCR &= ~CAN_MCR_FRZ_MASK;
/* Wait until the FlexCAN Module exit freeze mode. */
while (base->MCR & CAN_MCR_FRZACK_MASK)
```
<Overlap Ratio: 0.8064516129032258>

---

--- 6 --
Question ID: 7fce391818d30a183962b7888a8bfd275b10423c_24
Original Code:
```
static ssize_t fan_proc_write(struct file *file, const char __user *buf,
			      size_t count, loff_t *pos)
{
	struct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));
	char cmd[42];
	size_t len;
	int value;
	u32 hci_result;

	len = min(count, sizeof(cmd) - 1);
	if (copy_from_user(cmd, buf, len))
		return -EFAULT;
	cmd[len] = '\0';

	if (sscanf(cmd, " force_on : %i", &value) == 1 &&
	    value >= 0 && value <= 1) {
		hci_write1(dev, HCI_FAN, value, &hci_result);
		if (hci_result != HCI_SUCCESS)
			return -EIO;
		else
			dev->force_fan = value;
	} else {
		return -EINVAL;
	}

	return count;
}
```


Overlapping Code:
```
 ssize_t fan_proc_write(struct file *file, const char __user *buf,
size_t count, loff_t *pos)
{
struct toshiba_acpi_dev *dev = PDE_DATA(file_inode(file));
char cmd[42];
size_t len;
int value;
u32 hci_result;
len = min(count, sizeof(cmd) - 1);
if (copy_from_user(cmd, buf, len))
return -EFAULT;
cmd[len] = '\0';
if (sscanf(cmd, " force_on : %i", &value) == 1 &&
value >= 0 && value <= 1) {
hci_write1(dev, HCI_FAN, value, &hci_result);
if (hci_result != HCI_SUCCESS)
return -EIO;
else
dev->force_fan = value;
} else {
return -EINVAL;
}
return count;
```
<Overlap Ratio: 0.9856115107913669>

---

--- 7 --
Question ID: d2de877435fe71f8adbde74973ec065c515fceeb_20
Original Code:
```
int readOvrParams(int fd, int * a, int * b)
{
    unsigned char buf[4];

    if(a == NULL || b == NULL)
        return SB_ERROR;

    buf[0] = HOST_CMD_READ_OVRLIMIT;
    buf[1] = buf[0];

    writeData(fd, buf, 2);
    readData(fd, buf, 1);

    if(buf[0] != HOST_REPLY_OVRLIMIT)
        return SB_ERROR;

    readData(fd, buf+1, 3);

    if(((buf[0] + buf[1] + buf[2]) & 0xFF) != buf[3])
	{
		printf("got cs: %02x, read: %02x\n", (buf[0] + buf[1] + buf[2]) & 0xFF, buf[3]);
        return SB_BADCC;
	}
    *a = buf[1];
    *b = buf[2];

    return SB_OK;
}
```


Overlapping Code:
```
)
{
unsigned char buf[4];
if(a == NULL || b == NULL)
return SB_ERROR;
buf[0] = HOST_CMD_READ_OVRLIMIT;
buf[1] = buf[0];
writeData(fd, buf, 2);
readData(fd, buf, 1);
if(buf[0] != HOST_REPLY_OVRLIMIT)
return SB_ERROR;
readData(fd, buf+1, 3);
if(((buf[0] + buf[1] + buf[2]) & 0xFF) != buf[3])
{
printf("got cs: %02x, read: %02x\n", (buf[0] + buf[1] + buf[2]) & 0xFF, buf[3]);
return SB_BADCC;
}
*a = buf
```
<Overlap Ratio: 0.8421052631578947>

---

--- 8 --
Question ID: 303980b71aae26f2a750c2f1bfe96ebe1046148e_7
Original Code:
```
int v4l2_pipeline_link_notify(struct media_link *link, u32 flags,
			      unsigned int notification)
{
	struct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;
	struct media_entity *source = link->source->entity;
	struct media_entity *sink = link->sink->entity;
	int source_use;
	int sink_use;
	int ret = 0;

	source_use = pipeline_pm_use_count(source, graph);
	sink_use = pipeline_pm_use_count(sink, graph);

	if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&
	    !(flags & MEDIA_LNK_FL_ENABLED)) {
		/* Powering off entities is assumed to never fail. */
		pipeline_pm_power(source, -sink_use, graph);
		pipeline_pm_power(sink, -source_use, graph);
		return 0;
	}

	if (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&
		(flags & MEDIA_LNK_FL_ENABLED)) {

		ret = pipeline_pm_power(source, sink_use, graph);
		if (ret < 0)
			return ret;

		ret = pipeline_pm_power(sink, source_use, graph);
		if (ret < 0)
			pipeline_pm_power(source, -sink_use, graph);
	}

	return ret;
}
```


Overlapping Code:
```
pipeline_link_notify(struct media_link *link, u32 flags,
unsigned int notification)
{
struct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;
struct media_entity *source = link->source->entity;
struct media_entity *sink = link->sink->entity;
int source_use;
int sink_use;
int ret = 0;
source_use = pipeline_pm_use_count(source, graph);
sink_use = pipeline_pm_use_count(sink, graph);
if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&
!(flags & MEDIA_LNK_FL_ENABLED)) {
/* Powering off entities is assumed to never fail. */
pipeline_pm_power(source, -sink_use, graph);
pipeline_pm_power(sink, -source_use, graph);
return 0;
}
if (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&
(flags & MEDIA_LNK_FL_ENABLED)) {
ret = pipeline_pm_power(source, sink_use, graph);
if (ret < 0)
return ret;
ret = pipeline_pm_power(sink, source_use, graph);
if (ret < 0)
pipeline_pm_po
```
<Overlap Ratio: 0.9408602150537635>

---

--- 9 --
Question ID: 521dbcf903f1f23bf6febc12ef4e2886ad09be35_1
Original Code:
```
dogecoin_bool dogecoin_p2p_deser_addr(unsigned int protocol_version, dogecoin_p2p_address* addr, struct const_buffer* buf)
{
    if (protocol_version >= DOGECOIN_ADDR_TIME_VERSION) {
        if (!deser_u32(&addr->time, buf))
            return false;
    } else
        addr->time = 0;

    if (!deser_u64(&addr->services, buf))
        return false;
    if (!deser_bytes(&addr->ip, buf, 16))
        return false;
    if (!deser_u16(&addr->port, buf))
        return false;
    return true;
}
```


Overlapping Code:
```
dogecoin_p2p_deser_addr(unsigned int protocol_version, dogecoin_p2p_address* addr, struct const_buffer* buf)
{
if (protocol_version >= DOGECOIN_ADDR_TIME_VERSION) {
if (!deser_u32(&addr->time, buf))
return false;
} else
addr->time = 0;
if (!deser_u64(&addr->services, buf))
return false;
if (!deser_bytes(&addr->ip, buf, 16))
return false;
if (!deser_u16(&addr->port, buf))
return false;
return true;
```
<Overlap Ratio: 0.9615384615384616>

---

--- 10 --
Question ID: 67ac260055233eb8bfa4a5060e3a7035026602a2_5
Original Code:
```
static void setup_display(void)
{
	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
	int reg;

	enable_ipu_clock();

	reg = readl(&mxc_ccm->cs2cdr);
	/* select pll 5 clock */
	reg &= MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;
	reg &= MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK;
	writel(reg, &mxc_ccm->cs2cdr);

	imx_iomux_v3_setup_multiple_pads(backlight_pads,
					 ARRAY_SIZE(backlight_pads));
}
```


Overlapping Code:
```
static void setup_display(void)
{
struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
int reg;
enable_ipu_clock();
reg = readl(&mxc_ccm->cs2cdr);
/* select pll 5 clock */
reg &= MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;
reg &= MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK;
writel(reg, &mxc_ccm->cs2cdr);
imx_iomux_v3_setup_multiple_pads(backlight_pads,
ARRAY_SIZE(backlight_pads));
```
<Overlap Ratio: 0.9947916666666666>

---

--- 11 --
Question ID: dcd81104bed97e1239a780600c669557cbf41d60_0
Original Code:
```
static struct roots_text_input *relay_get_focusable_text_input(
		struct roots_input_method_relay *relay) {
	struct roots_text_input *text_input = NULL;
	wl_list_for_each(text_input, &relay->text_inputs, link) {
		if (text_input->pending_focused_surface) {
			return text_input;
		}
	}
	return NULL;
}
```


Overlapping Code:
```
_input *relay_get_focusable_text_input(
struct roots_input_method_relay *relay) {
struct roots_text_input *text_input = NULL;
wl_list_for_each(text_input, &relay->text_inputs, link) {
if (text_input->pending_focused_surface) {
return text_input;
}
}
return NULL;
}
```
<Overlap Ratio: 0.9166666666666666>

---

--- 12 --
Question ID: 9aee4e53711dab506f09e675eb89f14863b4dc21_0
Original Code:
```
namespace RE
{
	class TESForm;

	struct BGSWorldLocation
	{
		// members
		NiPoint3 pos;               // 00
		TESForm* cellOrWorldSpace;  // 0C
	};
	static_assert(sizeof(BGSWorldLocation) == 0x18);
}
```


Overlapping Code:
```
RE
{
class TESForm;
struct BGSWorldLocation
{
// members
NiPoint3 pos; // 00
TESForm* cellOrWorldSpace; // 0C
};
static_assert(sizeof(BGSWorldLocation
```
<Overlap Ratio: 0.8670520231213873>

---

--- 13 --
Question ID: 583aa66edb52cbbb87701a97737865d0772ff770_5
Original Code:
```
static enum rte_vhost_msg_result
extern_vhost_pre_msg_handler(int vid, void *_msg)
{
	struct vhost_user_msg *msg = _msg;
	struct spdk_vhost_session *vsession;

	vsession = vhost_session_find_by_vid(vid);
	if (vsession == NULL) {
		SPDK_ERRLOG("Received a message to unitialized session (vid %d).\n", vid);
		assert(false);
		return RTE_VHOST_MSG_RESULT_ERR;
	}

	switch (msg->request) {
	case VHOST_USER_GET_VRING_BASE:
		if (vsession->forced_polling && vsession->started) {
			/* Our queue is stopped for whatever reason, but we may still
			 * need to poll it after it's initialized again.
			 */
			g_spdk_vhost_ops.destroy_device(vid);
		}
		break;
	case VHOST_USER_SET_VRING_BASE:
	case VHOST_USER_SET_VRING_ADDR:
	case VHOST_USER_SET_VRING_NUM:
		if (vsession->forced_polling && vsession->started) {
			/* Additional queues are being initialized, so we either processed
			 * enough I/Os and are switching from SeaBIOS to the OS now, or
			 * we were never in SeaBIOS in the first place. Either way, we
			 * don't need our workaround anymore.
			 */
			g_spdk_vhost_ops.destroy_device(vid);
			vsession->forced_polling = false;
		}
		break;
	case VHOST_USER_SET_VRING_KICK:
		/* rte_vhost(after 20.08) will call new_device after one active vring is
		 * configured, we will start the session before all vrings are available,
		 * so for each new vring, if the session is started, we need to restart it
		 * again.
		 */
	case VHOST_USER_SET_VRING_CALL:
		/* rte_vhost will close the previous callfd and won't notify
		 * us about any change. This will effectively make SPDK fail
		 * to deliver any subsequent interrupts until a session is
		 * restarted. We stop the session here before closing the previous
		 * fd (so that all interrupts must have been delivered by the
		 * time the descriptor is closed) and start right after (which
		 * will make SPDK retrieve the latest, up-to-date callfd from
		 * rte_vhost.
		 */
	case VHOST_USER_SET_MEM_TABLE:
		/* rte_vhost will unmap previous memory that SPDK may still
		 * have pending DMA operations on. We can't let that happen,
		 * so stop the device before letting rte_vhost unmap anything.
		 * This will block until all pending I/Os are finished.
		 * We will start the device again from the post-processing
		 * message handler.
		 */
		if (vsession->started) {
			g_spdk_vhost_ops.destroy_device(vid);
			vsession->needs_restart = true;
		}
		break;
	case VHOST_USER_GET_CONFIG: {
		int rc = 0;

		spdk_vhost_lock();
		if (vsession->vdev->backend->vhost_get_config) {
			rc = vsession->vdev->backend->vhost_get_config(vsession->vdev,
				msg->payload.cfg.region, msg->payload.cfg.size);
			if (rc != 0) {
				msg->size = 0;
			}
		}
		spdk_vhost_unlock();

		return RTE_VHOST_MSG_RESULT_REPLY;
	}
	case VHOST_USER_SET_CONFIG: {
		int rc = 0;

		spdk_vhost_lock();
		if (vsession->vdev->backend->vhost_set_config) {
			rc = vsession->vdev->backend->vhost_set_config(vsession->vdev,
				msg->payload.cfg.region, msg->payload.cfg.offset,
				msg->payload.cfg.size, msg->payload.cfg.flags);
		}
		spdk_vhost_unlock();

		return rc == 0 ? RTE_VHOST_MSG_RESULT_OK : RTE_VHOST_MSG_RESULT_ERR;
	}
	default:
		break;
	}

	return RTE_VHOST_MSG_RESULT_NOT_HANDLED;
}
```


Overlapping Code:
```
atic enum rte_vhost_msg_result
extern_vhost_pre_msg_handler(int vid, void *_msg)
{
struct vhost_user_msg *msg = _msg;
struct spdk_vhost_session *vsession;
vsession = vhost_session_find_by_vid(vid);
if (vsession == NULL) {
SPDK_ERRLOG("Received a message to unitialized session (vid %d).\n", vid);
assert(false);
return RTE_VHOST_MSG_RESULT_ERR;
}
switch (msg->request) {
case VHOST_USER_GET_VRING_BASE:
if (vsession->forced_polling && vsession->started) {
/* Our queue is stopped for whatever reason, but we may still
* need to poll it after it's initialized again.
*/
g_spdk_vhost_ops.destroy_device(vid);
}
break;
case VHOST_USER_SET_VRING_BASE:
case VHOST_USER_SET_VRING_ADDR:
case VHOST_USER_SET_VRING_NUM:
if (vsession->forced_polling && vsession->started) {
/* Additional queues are being initialized, so we either processed
* enough I/Os and are switching from SeaBIOS to the OS now, or
* we were never in SeaBIOS in the first place. Either way, we
* don't need our workaround anymore.
*/
g_spdk_vhost_ops.destroy_device(vid);
vsession->forced_polling = false;
}
break;
case VHOST_USER_SET_VRING_KICK:
/* rte_vhost(after 20.08) will call new_device after one active vring is
* configured, we will start the session before all vrings are available,
* so for each new vring, if the session is started, we need to restart it
* again.
*/
case VHOST_USER_SET_VRING_CALL:
/* rte_vhost will close the previous callfd and won't notify
* us about any change. This will effectively make SPDK fail
* to deliver any subsequent interrupts until a session is
* restarted. We stop the session here before closing the previous
* fd (so that all interrupts must have been delivered by the
* time the descriptor is closed) and start right after (which
* will make SPDK retrieve the latest, up-to-date callfd from
* rte_vhost.
*/
case VHOST_USER_SET_MEM_TABLE:
/* rte_vhost will unmap previous memory that SPDK may still
* have pending DMA operations on. We can't let that happen,
* so stop the device before letting rte_vhost unmap anything.
* This will block until all pending I/Os are finished.
* We will start the device again from the post-processing
* message handler.
*/
if (vsession->started) {
g_spdk_vhost_ops.destroy_device(vid);
vsession->needs_restart = true;
}
break;
case VHOST_USER_GET_CONFIG: {
int rc = 0;
spdk_vhost_lock();
if (vsession-
```
<Overlap Ratio: 0.9987217724755006>

---

--- 14 --
Question ID: 9144ea0825ed07afa176b2b40cf8d55691bf0110_14
Original Code:
```
_CODE_ZCL_ static void zcl_gp_sinkTabReqParse(u8 *pData, zcl_gp_sinkTabReqCmd_t *pCmd)
{
	pCmd->options.opts = *pData++;

	if(pCmd->options.bits.appId == GP_APP_ID_SRC_ID){
		pCmd->gpdId.srcId = BUILD_U32(pData[0], pData[1], pData[2], pData[3]);
		pData += 4;
	}else if(pCmd->options.bits.appId == GP_APP_ID_GPD){
		ZB_64BIT_ADDR_COPY(pCmd->gpdId.gpdIeeeAddr, pData);
		pData += EXT_ADDR_LEN;
		pCmd->endpoint = *pData++;
	}

	if(pCmd->options.bits.reqType == REQUEST_TABLE_ENTRIES_BY_INDEX){
		pCmd->index = *pData++;
	}
}
```


Overlapping Code:
```
oid zcl_gp_sinkTabReqParse(u8 *pData, zcl_gp_sinkTabReqCmd_t *pCmd)
{
pCmd->options.opts = *pData++;
if(pCmd->options.bits.appId == GP_APP_ID_SRC_ID){
pCmd->gpdId.srcId = BUILD_U32(pData[0], pData[1], pData[2], pData[3]);
pData += 4;
}else if(pCmd->options.bits.appId == GP_APP_ID_GPD){
ZB_64BIT_ADDR_COPY(pCmd->gpdId.gpdIeeeAddr, pData);
pData += EXT_ADDR_LEN;
pCmd->endpoint = *pData++;
}
if(pCmd->options.bits.reqType == REQUEST_TABLE_ENTRIES_BY_INDEX){
pC
```
<Overlap Ratio: 0.9125248508946322>

---

--- 15 --
Question ID: 8678ec1dcbf1798ff010a7d077dad0580921042f_19
Original Code:
```
static int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req)
{
	int res = 0;

	if (!s) {
		ast_log(LOG_WARNING, "Asked to transmit to a non-existent session!\n");
		return -1;
	}

	ast_mutex_lock(&s->lock);

	SKINNY_DEVONLY(if (skinnydebug>1) ast_verb(4, "Transmitting %s to %s\n", message2str(req->e), s->device->name);)

	if ((letohl(req->len) > SKINNY_MAX_PACKET) || (letohl(req->len) < 0)) {
		ast_log(LOG_WARNING, "transmit_response: the length of the request (%d) is out of bounds (%d)\n", letohl(req->len), SKINNY_MAX_PACKET);
		ast_mutex_unlock(&s->lock);
		return -1;
	}

	memset(s->outbuf, 0, sizeof(s->outbuf));
	memcpy(s->outbuf, req, skinny_header_size);
	memcpy(s->outbuf+skinny_header_size, &req->data, letohl(req->len));

	res = write(s->fd, s->outbuf, letohl(req->len)+8);
	
	if (res != letohl(req->len)+8) {
		ast_log(LOG_WARNING, "Transmit: write only sent %d out of %d bytes: %s\n", res, letohl(req->len)+8, strerror(errno));
		if (res == -1) {
			if (skinnydebug)
				ast_log(LOG_WARNING, "Transmit: Skinny Client was lost, unregistering\n");
			skinny_unregister(NULL, s);
		}
		
	}
	
	ast_free(req);
	ast_mutex_unlock(&s->lock);
	return 1;
}
```


Overlapping Code:
```
atic int transmit_response_bysession(struct skinnysession *s, struct skinny_req *req)
{
int res = 0;
if (!s) {
ast_log(LOG_WARNING, "Asked to transmit to a non-existent session!\n");
return -1;
}
ast_mutex_lock(&s->lock);
SKINNY_DEVONLY(if (skinnydebug>1) ast_verb(4, "Transmitting %s to %s\n", message2str(req->e), s->device->name);)
if ((letohl(req->len) > SKINNY_MAX_PACKET) || (letohl(req->len) < 0)) {
ast_log(LOG_WARNING, "transmit_response: the length of the request (%d) is out of bounds (%d)\n", letohl(req->len), SKINNY_MAX_PACKET);
ast_mutex_unlock(&s->lock);
return -1;
}
memset(s->outbuf, 0, sizeof(s->outbuf));
memcpy(s->outbuf, req, skinny_header_size);
memcpy(s->outbuf+skinny_header_size, &req->data, letohl(req->len));
res = write(s->fd, s->outbuf, letohl(req->len)+8);

if (res != letohl(req->len)+8) {
ast_log(LOG_WARNING, "Transmit: write only sent %d out of %d bytes: %s\n", res, letohl(req->len)+8, strerror(errno));
if (res == -1) {
if (skinnydebug)
ast_log(LOG_WARNING, "Transmit: Skinny Client was lost, unregistering\n");
skinny_unregister(NULL, s);
}

}

ast_free(req);
as
```
<Overlap Ratio: 0.9657594381035997>

---

--- 16 --
Question ID: 30132c3957cdc3d2d76e03a5a82511d9b0a27829_9
Original Code:
```
static int jz4780_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,
			   int count)
{
	int i = -EIO;
	int ret = 0;
	struct jz4780_i2c *i2c = adap->algo_data;

	ret = jz4780_i2c_prepare(i2c);
	if (ret) {
		dev_err(&i2c->adap.dev, "I2C prepare failed\n");
		goto out;
	}

	if (msg->addr != jz4780_i2c_readw(i2c, JZ4780_I2C_TAR)) {
		ret = jz4780_i2c_set_target(i2c, msg->addr);
		if (ret)
			goto out;
	}
	for (i = 0; i < count; i++, msg++) {
		if (msg->flags & I2C_M_RD)
			ret = jz4780_i2c_xfer_read(i2c, msg->buf, msg->len,
						   count, i);
		else
			ret = jz4780_i2c_xfer_write(i2c, msg->buf, msg->len,
						    count, i);

		if (ret)
			goto out;
	}

	ret = i;

out:
	jz4780_i2c_cleanup(i2c);
	return ret;
}
```


Overlapping Code:
```
tic int jz4780_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msg,
int count)
{
int i = -EIO;
int ret = 0;
struct jz4780_i2c *i2c = adap->algo_data;
ret = jz4780_i2c_prepare(i2c);
if (ret) {
dev_err(&i2c->adap.dev, "I2C prepare failed\n");
goto out;
}
if (msg->addr != jz4780_i2c_readw(i2c, JZ4780_I2C_TAR)) {
ret = jz4780_i2c_set_target(i2c, msg->addr);
if (ret)
goto out;
}
for (i = 0; i < count; i++, msg++) {
if (msg->flags & I2C_M_RD)
ret = jz4780_i2c_xfer_read(i2c, msg->buf, msg->len,
count, i);
else
ret = jz4780_i2c_xfer_write(i2c, msg->buf, msg->len,
count, i);
if (ret)
goto out;
}
ret
```
<Overlap Ratio: 0.9202453987730062>

---

--- 17 --
Question ID: c8d4b1331293d6333e012d753b9962e85ebec760_51
Original Code:
```
JNICALL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
  jbyteArray jresult = 0 ;
  uint8_t *arg1 = (uint8_t *) 0 ;
  int *arg2 = (int *) 0 ;
  int *arg3 = (int *) 0 ;
  int *arg4 = (int *) 0 ;
  int arg5 ;
  int arg6 ;
  int arg7 ;
  float arg8 ;
  jbyte *jarr1 ;
  int temp4 ;
  uint8_t *result = 0 ;

  (void)jenv;
  (void)jcls;
  if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
  arg2 = (int *)&jarg2;
  arg3 = (int *)&jarg3;
  {
    if (!jarg4) {
      SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
      return 0;
    }
    if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
      SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
      return 0;
    }
    arg4 = &temp4;
  }
  arg5 = (int)jarg5;
  arg6 = (int)jarg6;
  arg7 = (int)jarg7;
  arg8 = (float)jarg8;
  result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
  jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
  SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
  {
    jint jvalue = (jint)temp4;
    (*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
  }
  free(arg1);



  free(result);
  return jresult;
}
```


Overlapping Code:
```
LL Java_com_google_webp_libwebpJNI_wrap_1WebPEncodeRGBA(JNIEnv *jenv, jclass jcls, jbyteArray jarg1, jint jarg2, jint jarg3, jintArray jarg4, jint jarg5, jint jarg6, jint jarg7, jfloat jarg8) {
jbyteArray jresult = 0 ;
uint8_t *arg1 = (uint8_t *) 0 ;
int *arg2 = (int *) 0 ;
int *arg3 = (int *) 0 ;
int *arg4 = (int *) 0 ;
int arg5 ;
int arg6 ;
int arg7 ;
float arg8 ;
jbyte *jarr1 ;
int temp4 ;
uint8_t *result = 0 ;
(void)jenv;
(void)jcls;
if (!SWIG_JavaArrayInUint8(jenv, &jarr1, &arg1, jarg1)) return 0;
arg2 = (int *)&jarg2;
arg3 = (int *)&jarg3;
{
if (!jarg4) {
SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "array null");
return 0;
}
if ((*jenv)->GetArrayLength(jenv, jarg4) == 0) {
SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, "Array must contain at least 1 element");
return 0;
}
arg4 = &temp4;
}
arg5 = (int)jarg5;
arg6 = (int)jarg6;
arg7 = (int)jarg7;
arg8 = (float)jarg8;
result = (uint8_t *)wrap_WebPEncodeRGBA((uint8_t const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
jresult = SWIG_JavaArrayOutUint8(jenv, result, FillMeInAsSizeCannotBeDeterminedAutomatically);
SWIG_JavaArrayArgoutUint8(jenv, jarr1, arg1, jarg1);
{
jint jvalue = (jint)temp4;
(*jenv)->SetIntArrayRegion(jenv, jarg4, 0, 1, &jvalue);
}
free(arg1);
free(result);
return jresul
```
<Overlap Ratio: 0.9930875576036866>

---

--- 18 --
Question ID: 15d34c3dbab62776e5d2ad654d489e2fe54f8033_9
Original Code:
```
static pism_data_t
fb_dev_response_get(pism_device_t *dev)
{
	struct pism_data_int *pd_int;

	(void)fb_dev_init_internal(dev);
	pd_int = &fb_fifo.pd_int;
	if (pd_int->pdi_addr >= FRAMEBUFFER_BASE &&
	    pd_int->pdi_addr < FRAMEBUFFER_BASE + FRAMEBUFFER_LENGTH)
		framebuffer_response_get(pd_int);
	if (pd_int->pdi_addr >= TOUCHSCREEN_BASE &&
	    pd_int->pdi_addr < TOUCHSCREEN_BASE + TOUCHSCREEN_LENGTH)
		touchscreen_response_get(pd_int);
	fb_fifo_empty = 0;
	return (fb_fifo);
}
```


Overlapping Code:
```
m_data_t
fb_dev_response_get(pism_device_t *dev)
{
struct pism_data_int *pd_int;
(void)fb_dev_init_internal(dev);
pd_int = &fb_fifo.pd_int;
if (pd_int->pdi_addr >= FRAMEBUFFER_BASE &&
pd_int->pdi_addr < FRAMEBUFFER_BASE + FRAMEBUFFER_LENGTH)
framebuffer_response_get(pd_int);
if (pd_int->pdi_addr >= TOUCHSCREEN_BASE &&
pd_int->pdi_addr < TOUCHSCREEN_BASE + TOUCHSCREEN_LENGTH)
touchscreen_response_get(pd_int);
fb_fifo_empty = 0;
return (fb_fifo);
}
```
<Overlap Ratio: 0.9782608695652174>

---

--- 19 --
Question ID: e5093a52359713a65bc5e87b189415cbe3bfd91c_2
Original Code:
```
int main(void)
{
  // trivial bug
  assert(false);

  struct Hardware hardware;
  struct Hardware* hw = &hardware;

  struct Firmware firmware;
  struct Firmware* fw = &firmware;

  firmware.hw = hw;
  hardware.fw = fw;

  __CPROVER_ASYNC_1: write_reg_a(hw);

  return 0;
}
```


Overlapping Code:
```
ial bug
assert(false);
struct Hardware hardware;
struct Hardware* hw = &hardware;
struct Firmware firmware;
struct Firmware* fw = &firmware;
firmware.hw = hw;
hardware.fw = fw;
__CPROVER_ASYNC_1: writ
```
<Overlap Ratio: 0.8064516129032258>

---

--- 20 --
Question ID: 611ea8bbce83f1c0c4eb27dcbb9c1bb06ea253d1_1
Original Code:
```
int* quicksort(int arr[] ,int len, int low, int high)
{
    int j;
    if (low < high)
    {
        j = partition(arr,len);
        quicksort(arr, len,low , j);
        quicksort(arr ,len , j + 1 , high);
    }
    return arr;
}
```


Overlapping Code:
```
ksort(int arr[] ,int len, int low, int high)
{
int j;
if (low < high)
{
j = partition(arr,len);
quicksort(arr, len,low , j);
quicksort(arr ,len , j + 
```
<Overlap Ratio: 0.8108108108108109>

---

--- 21 --
Question ID: 8612543ffdfd40e3b789d5bfa923203654529e6e_25
Original Code:
```
void test_IotBleSetDeviceName_While_BLE_Is_On( void )
{
    prvTestTurnOnBLE();

    prvBleTestSetDeviceProperty_Stub( prvSaveConfiguration );

    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );
    IotSemaphore_Wait_Ignore();
    prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );
    IotSemaphore_Wait_Ignore();
    TEST_ASSERT_EQUAL( eBTStatusSuccess, IotBle_SetDeviceName( CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );

    TEST_ASSERT_EQUAL( 0, strncmp( bleConfig.deviceName, CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );

    prvTestTurnOffBLE();
}
```


Overlapping Code:
```
ame_While_BLE_Is_On( void )
{
prvTestTurnOnBLE();
prvBleTestSetDeviceProperty_Stub( prvSaveConfiguration );
prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );
IotSemaphore_Wait_Ignore();
prvBleTestSetAdvData_IgnoreAndReturn( eBTStatusSuccess );
IotSemaphore_Wait_Ignore();
TEST_ASSERT_EQUAL( eBTStatusSuccess, IotBle_SetDeviceName( CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );
TEST_ASSERT_EQUAL( 0, strncmp( bleConfig.deviceName, CUSTOM_BLE_DEVICE_NAME, strlen( CUSTOM_BLE_DEVICE_NAME ) ) );
prvTestTurnOff
```
<Overlap Ratio: 0.9397163120567376>

---

--- 22 --
Question ID: 190d049927fbdd643968cb95e4448b87b87f151a_3
Original Code:
```
void xmhf_smpguest_arch_x86vmx_initialize(VCPU *vcpu, u32 unmaplapic){
  u32 eax, edx;

  //read LAPIC base address from MSR
  rdmsr(MSR_APIC_BASE, &eax, &edx);
  HALT_ON_ERRORCOND( edx == 0 ); //APIC should be below 4G

  g_vmx_lapic_base = eax & 0xFFFFF000UL;
  //printf("\nBSP(0x%02x): LAPIC base=0x%08x", vcpu->id, g_vmx_lapic_base);

  if (unmaplapic) {
    //unmap LAPIC page
    vmx_lapic_changemapping(vcpu, g_vmx_lapic_base, g_vmx_lapic_base, VMX_LAPIC_UNMAP);
  }
}
```


Overlapping Code:
```
CPU *vcpu, u32 unmaplapic){
u32 eax, edx;
//read LAPIC base address from MSR
rdmsr(MSR_APIC_BASE, &eax, &edx);
HALT_ON_ERRORCOND( edx == 0 ); //APIC should be below 4G
g_vmx_lapic_base = eax & 0xFFFFF000UL;
//printf("\nBSP(0x%02x): LAPIC base=0x%08x", vcpu->id, g_vmx_lapic_base);
if (unmaplapic) {
//unmap LAPIC page
vmx_lapic_changemapping(vcpu, g_vmx_lapic_base, g_vmx_lapic_base, VMX_LAPIC_UNMAP);

```
<Overlap Ratio: 0.8973214285714286>

---

--- 23 --
Question ID: cef2866da875a5bf04d698ce39170adc335671de_4
Original Code:
```
struct obj *toheap_env(struct obj *env_obj, struct gc_context *ctx) {
  struct env_obj *env = (struct env_obj *)env_obj;
  struct env_obj *orig_env = env;

  if (env->base.on_stack) {
    TOUCH_OBJECT(env, "toheap_env");
    struct env_obj *heap_env =
        gc_malloc(sizeof(struct env_obj) + env->len * sizeof(struct obj *));

    heap_env->base = env->base;
    heap_env->len = env->len;
    memset(&heap_env->env, 0, env->len * sizeof(struct obj *));
    env = heap_env;
  }

  for (size_t i = 0; i < env->len; i++) {
    struct obj *obj_ptr = orig_env->env[i];

    if (!obj_ptr)
      continue;

    struct ptr_toupdate_pair p = {.toupdate = &env->env[i],
                                  .on_stack = obj_ptr};
    queue_ptr_toupdate_pair_enqueue(&ctx->pointers_toupdate, p);
  }

  return (struct obj *)env;
}
```


Overlapping Code:
```
j *env_obj, struct gc_context *ctx) {
struct env_obj *env = (struct env_obj *)env_obj;
struct env_obj *orig_env = env;
if (env->base.on_stack) {
TOUCH_OBJECT(env, "toheap_env");
struct env_obj *heap_env =
gc_malloc(sizeof(struct env_obj) + env->len * sizeof(struct obj *));
heap_env->base = env->base;
heap_env->len = env->len;
memset(&heap_env->env, 0, env->len * sizeof(struct obj *));
env = heap_env;
}
for (size_t i = 0; i < env->len; i++) {
struct obj *obj_ptr = orig_env->env[i];
if (!obj_ptr)
continue;
struct ptr_toupdate_pair p = {.toupdate = &env->env[i],
.on_stack = obj_ptr};
queue_ptr_toupdate_pair_enqueue(&ctx->pointers_toupdate, p);
}
r
```
<Overlap Ratio: 0.9183098591549296>

---

--- 24 --
Question ID: 1d24af86426dae538048057a878f5ce53f22074f_7
Original Code:
```
struct dev_filter *persistent_filter_create(struct dev_types *dt,
					    struct dev_filter *real,
					    const char *file)
{
	struct pfilter *pf;
	struct dev_filter *f = NULL;
	struct stat info;

	if (!(pf = dm_zalloc(sizeof(*pf)))) {
		log_error("Allocation of persistent filter failed.");
		return NULL;
	}

	pf->dt = dt;

	if (!(pf->file = dm_strdup(file))) {
		log_error("Filename duplication for persistent filter failed.");
		goto bad;
	}

	pf->real = real;

	if (!(_init_hash(pf))) {
		log_error("Couldn't create hash table for persistent filter.");
		goto bad;
	}

	if (!(f = dm_zalloc(sizeof(*f)))) {
		log_error("Allocation of device filter for persistent filter failed.");
		goto bad;
	}

	/* Only merge cache file before dumping it if it changed externally. */
	if (!stat(pf->file, &info))
		lvm_stat_ctim(&pf->ctime, &info);

	f->passes_filter = _lookup_p;
	f->destroy = _persistent_destroy;
	f->use_count = 0;
	f->private = pf;
	f->wipe = _persistent_filter_wipe;
	f->dump = _persistent_filter_dump;

	log_debug_devs("Persistent filter initialised.");

	return f;

      bad:
	dm_free(pf->file);
	if (pf->devices)
		dm_hash_destroy(pf->devices);
	dm_free(pf);
	dm_free(f);
	return NULL;
}
```


Overlapping Code:
```
dev_filter *persistent_filter_create(struct dev_types *dt,
struct dev_filter *real,
const char *file)
{
struct pfilter *pf;
struct dev_filter *f = NULL;
struct stat info;
if (!(pf = dm_zalloc(sizeof(*pf)))) {
log_error("Allocation of persistent filter failed.");
return NULL;
}
pf->dt = dt;
if (!(pf->file = dm_strdup(file))) {
log_error("Filename duplication for persistent filter failed.");
goto bad;
}
pf->real = real;
if (!(_init_hash(pf))) {
log_error("Couldn't create hash table for persistent filter.");
goto bad;
}
if (!(f = dm_zalloc(sizeof(*f)))) {
log_error("Allocation of device filter for persistent filter failed.");
goto bad;
}
/* Only merge cache file before dumping it if it changed externally. */
if (!stat(pf->file, &info))
lvm_stat_ctim(&pf->ctime, &info);
f->passes_filter = _lookup_p;
f->destroy = _persistent_destroy;
f->use_count = 0;
f->private = pf;
f->wipe = _persistent_filter_wipe;
f->dump = _persistent_filter_dump;
log_debug_devs("Persistent filter initialised.");
return f;
bad:
dm_free(pf->file);
if (pf->devices)
dm_hash_destroy(pf->devices)
```
<Overlap Ratio: 0.9572573463935886>

---

--- 25 --
Question ID: 9a4d1bcb881d26add58c98d1fb6be69723fcac74_0
Original Code:
```
static void _rtl92e_hw_sleep(struct net_device *dev)
{
	struct r8192_priv *priv = rtllib_priv(dev);
	unsigned long flags = 0;

	spin_lock_irqsave(&priv->rf_ps_lock, flags);
	if (priv->RFChangeInProgress) {
		spin_unlock_irqrestore(&priv->rf_ps_lock, flags);
		RT_TRACE(COMP_DBG,
			 "_rtl92e_hw_sleep(): RF Change in progress!\n");
		return;
	}
	spin_unlock_irqrestore(&priv->rf_ps_lock, flags);
	RT_TRACE(COMP_DBG, "%s()============>come to sleep down\n", __func__);

	rtl92e_set_rf_state(dev, eRfSleep, RF_CHANGE_BY_PS);
}
```


Overlapping Code:
```
atic void _rtl92e_hw_sleep(struct net_device *dev)
{
struct r8192_priv *priv = rtllib_priv(dev);
unsigned long flags = 0;
spin_lock_irqsave(&priv->rf_ps_lock, flags);
if (priv->RFChangeInProgress) {
spin_unlock_irqrestore(&priv->rf_ps_lock, flags);
RT_TRACE(COMP_DBG,
"_rtl92e_hw_sleep(): RF Change in progress!\n");
return;
}
spin_unlock_irqrestore(&priv->rf_ps_lock, flags);
RT_TRACE(COMP_DBG, "%s()============>come to sleep down\n", __func__);
rtl92e_set_rf_state(dev, eRfSleep, RF_CHANGE_BY_PS);
```
<Overlap Ratio: 0.9920634920634921>

---

--- 26 --
Question ID: cf8c1bbc10aefe71a4f898727439d9c67dbe963d_1
Original Code:
```
void
ngx_postgres_wev_handler(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
    ngx_connection_t  *pgxc;

    dd("entering");

    /* just to ensure u->reinit_request always gets called for
     * upstream_next */
    u->request_sent = 1;

    pgxc = u->peer.connection;

    if (pgxc->write->timedout) {
        dd("postgres connection write timeout");

        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);

        dd("returning");
        return;
    }

    if (ngx_postgres_upstream_test_connect(pgxc) != NGX_OK) {
        dd("postgres connection is broken");

        ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);

        dd("returning");
        return;
    }

    ngx_postgres_process_events(r);

    dd("returning");
}
```


Overlapping Code:
```
wev_handler(ngx_http_request_t *r, ngx_http_upstream_t *u)
{
ngx_connection_t *pgxc;
dd("entering");
/* just to ensure u->reinit_request always gets called for
* upstream_next */
u->request_sent = 1;
pgxc = u->peer.connection;
if (pgxc->write->timedout) {
dd("postgres connection write timeout");
ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
dd("returning");
return;
}
if (ngx_postgres_upstream_test_connect(pgxc) != NGX_OK) {
dd("postgres connection is broken");
ngx_postgres_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);
dd("returning");
return;
}
ngx_postgres_process_events(r);
dd("ret
```
<Overlap Ratio: 0.9546875>

---

--- 27 --
Question ID: 4fdc309bacb04abd35854060de2a590cbe39e762_2
Original Code:
```
char *itoa(unsigned int number)
{
    static char tmp[16];
    char *ret;
    int i;
    int remaining;
    ret = &tmp[15];

    remaining = number;
    bzero(tmp, 16);
    do {
        *--ret = '0' + (number % 10);
        number = number / 10;
    } while (number != 0);
    return ret;
}
```


Overlapping Code:
```
atic char tmp[16];
char *ret;
int i;
int remaining;
ret = &tmp[15];
remaining = number;
bzero(tmp, 16);
do {
*--ret = '0' + (number % 10);
number = nu
```
<Overlap Ratio: 0.6437768240343348>

---

--- 28 --
Question ID: 8bf66fda0e26ed0ae12d74dd4c709e281c3c9221_2
Original Code:
```
static mem_inode_t *
_dir_find(mem_inode_t *dir_inode, char *filename, uint32_t *entry_offset)
{
    assert(dir_inode->d_inode.type == INODE_TYPE_DIR);

    /** Search for the filename in this directory. */
    dentry_t dentry;
    for (size_t offset = 0;
         offset < dir_inode->d_inode.size;
         offset += sizeof(dentry_t)) {
        if (inode_read(dir_inode, (char *) &dentry, offset,
                       sizeof(dentry_t)) != sizeof(dentry_t)) {
            warn("dir_find: failed to read at offset %u", offset);
            return NULL;
        }
        if (dentry.valid == 0)
            continue;

        /** If matches, get the inode. */
        if (strncmp(dentry.filename, filename, MAX_FILENAME) == 0) {
            if (entry_offset != NULL)
                *entry_offset = offset;
            return inode_get(dentry.inumber);
        }
    }

    return NULL;
}
```


Overlapping Code:
```
node_t *
_dir_find(mem_inode_t *dir_inode, char *filename, uint32_t *entry_offset)
{
assert(dir_inode->d_inode.type == INODE_TYPE_DIR);
/** Search for the filename in this directory. */
dentry_t dentry;
for (size_t offset = 0;
offset < dir_inode->d_inode.size;
offset += sizeof(dentry_t)) {
if (inode_read(dir_inode, (char *) &dentry, offset,
sizeof(dentry_t)) != sizeof(dentry_t)) {
warn("dir_find: failed to read at offset %u", offset);
return NULL;
}
if (dentry.valid == 0)
continue;
/** If matches, get the inode. */
if (strncmp(dentry.filename, filename, MAX_FILENAME) == 0) {
if (entry_offset != NULL)
*entry_offset = offset;
return inode_get(d
```
<Overlap Ratio: 0.9339080459770115>

---

--- 29 --
Question ID: fcf03d927f96bb5de77dbb55fe5c0257bf532a7a_1
Original Code:
```
DCulonglong dcbArgULongLong(DCArgs* p)
{
  DCulonglong value;
  p->reg_count.i += (p->reg_count.i & 1);         /* Skip one reg if not aligned. */
  p->stackptr += ((DCulong)p->stackptr & 4) & -4; /* 64bit values are also always aligned on stack */
#if defined(DC__Endian_LITTLE)
  value  = dcbArgUInt(p);
  value |= ((DCulonglong)dcbArgUInt(p)) << 32;
#else
  value  = ((DCulonglong)dcbArgUInt(p)) << 32;
  value |= dcbArgUInt(p);
#endif
  return value;
}
```


Overlapping Code:
```
g(DCArgs* p)
{
DCulonglong value;
p->reg_count.i += (p->reg_count.i & 1); /* Skip one reg if not aligned. */
p->stackptr += ((DCulong)p->stackptr & 4) & -4; /* 64bit values are also always aligned on stack */
#if defined(DC__Endian_LITTLE)
value = dcbArgUInt(p);
value |= ((DCulonglong)dcbArgUInt(p)) << 32;
#else
value = ((DCulonglong)dcbArgUInt(p)) << 32;
value |= dcbArgUInt(p);
#endif
return valu
```
<Overlap Ratio: 0.9302325581395349>

---

--- 30 --
Question ID: cf53170d6349a45af5bce401dc26c90aed3b756c_6
Original Code:
```
void usb_handle_config_descriptor(volatile struct usb_setup_packet *pkt) {
    uint8_t *buf = &ep0_buf[0];

    // First request will want just the config descriptor
    const struct usb_configuration_descriptor *d = dev_config.config_descriptor;
    memcpy((void *) buf, d, sizeof(struct usb_configuration_descriptor));
    buf += sizeof(struct usb_configuration_descriptor);

    // If we more than just the config descriptor copy it all
    if (pkt->wLength >= d->wTotalLength) {
        memcpy((void *) buf, dev_config.interface_descriptor, sizeof(struct usb_interface_descriptor));
        buf += sizeof(struct usb_interface_descriptor);
        const struct usb_endpoint_configuration *ep = dev_config.endpoints;

        // Copy all the endpoint descriptors starting from EP1
        for (uint i = 2; i < USB_NUM_ENDPOINTS; i++) {
            if (ep[i].descriptor) {
                memcpy((void *) buf, ep[i].descriptor, sizeof(struct usb_endpoint_descriptor));
                buf += sizeof(struct usb_endpoint_descriptor);
            }
        }

    }

    // Send data
    // Get len by working out end of buffer subtract start of buffer
    uint32_t len = (uint32_t) buf - (uint32_t) &ep0_buf[0];
    usb_start_transfer(usb_get_endpoint_configuration(EP0_IN_ADDR), &ep0_buf[0], len);
}
```


Overlapping Code:
```
onfig_descriptor(volatile struct usb_setup_packet *pkt) {
uint8_t *buf = &ep0_buf[0];
// First request will want just the config descriptor
const struct usb_configuration_descriptor *d = dev_config.config_descriptor;
memcpy((void *) buf, d, sizeof(struct usb_configuration_descriptor));
buf += sizeof(struct usb_configuration_descriptor);
// If we more than just the config descriptor copy it all
if (pkt->wLength >= d->wTotalLength) {
memcpy((void *) buf, dev_config.interface_descriptor, sizeof(struct usb_interface_descriptor));
buf += sizeof(struct usb_interface_descriptor);
const struct usb_endpoint_configuration *ep = dev_config.endpoints;
// Copy all the endpoint descriptors starting from EP1
for (uint i = 2; i < USB_NUM_ENDPOINTS; i++) {
if (ep[i].descriptor) {
memcpy((void *) buf, ep[i].descriptor, sizeof(struct usb_endpoint_descriptor));
buf += sizeof(struct usb_endpoint_descriptor);
}
}
}
// Send data
// Get len by working out end of buffer subtract start of buffer
uint32_t len = (uint32_t) buf - (uint32_t) &ep0_buf[0];
usb_start_transfer(usb_get_endpoint_configuration(EP0_IN_ADD
```
<Overlap Ratio: 0.9640980735551664>

---

--- 31 --
Question ID: 3d18f2a4e6b84408bf20e80127d89a4ea95fa713_2
Original Code:
```
void hookrw_init ( void )
{
    DEBUG("Hooking sys_read and sys_write\n");

    sys_read = (void *)sys_call_table[__NR_read];
    hijack_start(sys_read, &n_sys_read);

    sys_write = (void *)sys_call_table[__NR_write];
    hijack_start(sys_write, &n_sys_write);
}
```


Overlapping Code:
```
ng sys_read and sys_write\n");
sys_read = (void *)sys_call_table[__NR_read];
hijack_start(sys_read, &n_sys_read);
sys_write = (void *)sys_call_table[__NR_write];
hijack_start(sys_write, &n_sys_write);
```
<Overlap Ratio: 0.8264462809917356>

---

--- 32 --
Question ID: f334a343438bfbafc37dc71b45a7bdfb153fc8b1_10
Original Code:
```
static void MT6616_RDS_RetrieveGroup2(struct i2c_client *client, uint16_t *block_data, uint8_t SubType, RDSData_Struct *pstRDSData)
{
    uint8_t TextAddr, indx, indx2, space, byte0, byte1;
	uint16_t addrcnt;
	TextAddr = (uint8_t)block_data[1]&0x0F;
	
	if(pstRDSData->RDSFlag.Text_AB != ((block_data[1]&0x0010)>>4))
	{
		pstRDSData->RDSFlag.Text_AB = (block_data[1]&0x0010)>>4;
		pstRDSData->event_status |= RDS_EVENT_FLAGS;
		pstRDSData->RDSFlag.flag_status |= RDS_FLAG_TEXT_AB;
		WCN_DBG(L6|D_G2, "RT RetrieveGroup2 TextABFlag: %x --> %x\n", PreTextABFlag, pstRDSData->RDSFlag.Text_AB);
	}

	if(PreTextABFlag != pstRDSData->RDSFlag.Text_AB)
	{
		/*DDB:Some station don't send 0x0D, it just switch TextAB if it want to send next message.*/
		addrcnt = 0xFFFF>>(0x0F-indx);
		if (pstRDSData->RT_Data.isRTDisplay == 0)// && (((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)) 
		{
			WCN_DBG(L6|D_G2, "RT TextAB changed and RT has not been show.\n");
			pstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; 
			space = 0;
			for(indx = 0; indx < 64; indx++)
			{
				if(pstRDSData->RT_Data.TextData[1][indx] == 0x20)
					space++;
			}	
			if(space == 64)
				pstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);

			if (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {
				/*DDB:Why TextData[1][0] NOT TextData[2][0],  Because some station just send a message one time, and then change TextAB, send another message, SUCH As Beijing 90.0*/
				memcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[1][0]), sizeof(pstRDSData->RT_Data.TextData[3]));

				uint8_t tmp[66] = {0};
				tmp[64] = 'E';
				memcpy(tmp, pstRDSData->RT_Data.TextData[1], 64);
			
				WCN_DBG(L6|D_G2, "RT Radio text---%s\n", tmp);
				WCN_DBG(L6|D_G2, "RT set RDS_EVENT_LAST_RADIOTEXT flag, no 0x0D case.\n");
				pstRDSData->RT_Data.isRTDisplay = 1;
			}
		}
		/*DDB, end*/
	    memset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));
		memset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));
		memset(&(pstRDSData->RT_Data.TextData[2][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[2]));
		PreTextABFlag = pstRDSData->RDSFlag.Text_AB;
  		pstRDSData->RT_Data.TextLength =  0;
		pstRDSData->RT_Data.GetLength = 0;
		pstRDSData->RT_Data.Addr_Cnt = 0;
		//pstRDSData->RT_Data.isRTDisplay = 0;
	}
	
	if(!SubType) //Type A
	{
		pstRDSData->RT_Data.isTypeA = 1;
	  	if(block_data[4]&(FM_RDS_GDBK_IND_C|FM_RDS_GDBK_IND_D))
        {
  			pstRDSData->RT_Data.TextData[0][4*TextAddr] = block_data[2]>>8;
			pstRDSData->RT_Data.TextData[0][4*TextAddr+1] = block_data[2]&0xFF;
  			pstRDSData->RT_Data.TextData[0][4*TextAddr+2] = block_data[3]>>8;
			pstRDSData->RT_Data.TextData[0][4*TextAddr+3] = block_data[3]&0xFF;
			space = 0;

            for(indx = 0; indx < 4;indx++)
	  	    {
	  		    byte0 = pstRDSData->RT_Data.TextData[0][4*TextAddr+indx];
			    byte1 = pstRDSData->RT_Data.TextData[1][4*TextAddr+indx];
				if (TextAddr == 0 && indx == 0) {	//if the first block lost?
					WCN_DBG(L6|D_G2, "RT Received the first block.\n");
					pstRDSData->RT_Data.isRTDisplay = 0;
				}

				if((!(pstRDSData->event_status&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1)) //get the same byte 2 times
				{
					WCN_DBG(L7|D_G2, "RT put to TextData[2] %d 0x%x(%c)", 4*TextAddr+indx, byte0, byte0);
					space++;
					pstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = byte0;
				}
				else
				{
					WCN_DBG(L7|D_G2, "RT put to TextData[1] %d 0x%x(%c)", 4*TextAddr+indx, byte0, byte0);
					pstRDSData->RT_Data.TextData[1][4*TextAddr+indx] = byte0;
				}
			}

			if(space == 4)
			{
                addrcnt = pstRDSData->RT_Data.Addr_Cnt;
				pstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);
				//WCN_DBG(L7|D_G2, "RT RetrieveGroup2 RT addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\n", addrcnt, pstRDSData->RT_Data.Addr_Cnt);
				
				if(addrcnt == pstRDSData->RT_Data.Addr_Cnt)
				{
				    pstRDSData->RT_Data.BufCnt++;
				}
				else if(pstRDSData->RT_Data.BufCnt > 0)
				{
					pstRDSData->RT_Data.BufCnt--;
	  	        }
			}
	  	} else {
			WCN_DBG(L7|D_G2, "RT %04x %04x %04x %04x %04x CRC error.", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);
		}
	  	for(indx = 0; indx < 4; indx++)
	  	{
	  		if(pstRDSData->RT_Data.TextData[2][4*TextAddr+indx] == 0x0D)
	        {
				WCN_DBG(L6|D_G2, "RT ---buffer[2] received 0x0D.\n");
	            pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1; //Add terminate charater
				pstRDSData->RT_Data.TextData[2][4*TextAddr+indx] = '\0';
				pstRDSData->RT_Data.GetLength = 1;
	        }
			else if((4*TextAddr+indx) == 63 && pstRDSData->RT_Data.Addr_Cnt == 0xffff) //type A full data. /*add by dongbo, make sure it's TextData[2], Not TextData[1]*/
			{
				WCN_DBG(L6|D_G2, "RT ---The 63 byte received.\n");
			    pstRDSData->RT_Data.TextLength = 4*TextAddr+indx+1;  //no terminal character
				pstRDSData->RT_Data.GetLength = 1;
			}
        }
	}
	else
	{
	    //FM_DEBUG("RetrieveGroup2 Type B RT NUM: 0x%x Text: 0x%x", TextAddr, block_data[3]);
		WCN_DBG(L7|D_G2, "RT %04x %04x %04x %04x %04x", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);
		pstRDSData->RT_Data.isTypeA = 0;
		if(block_data[4]&FM_RDS_GDBK_IND_D)
		{
            pstRDSData->RT_Data.TextData[0][2*TextAddr] = block_data[3]>>8;
		    pstRDSData->RT_Data.TextData[0][2*TextAddr+1] = block_data[3]&0xFF;
			space = 0;
			
	  	    for(indx = 0; indx < 2; indx++)
	  	    {
	  	        byte0 = pstRDSData->RT_Data.TextData[0][2*TextAddr+indx];
			    byte1 = pstRDSData->RT_Data.TextData[1][2*TextAddr+indx];
				
				if((!((pstRDSData->event_status)&RDS_EVENT_LAST_RADIOTEXT))&&(byte0 == byte1))
				{
					space++;
					pstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = byte0;
				}
				else
				{
					pstRDSData->RT_Data.TextData[1][2*TextAddr+indx] = byte0;
				}
	  		}
			if(space == 2)
			{
			    addrcnt = pstRDSData->RT_Data.Addr_Cnt;
				pstRDSData->RT_Data.Addr_Cnt |= (1<<TextAddr);
				WCN_DBG(L7|D_G2, "RT RetrieveGroup2 RT B addrcnt: 0x%x, RT_Data.Addr_Cnt: 0x%x\n", addrcnt, pstRDSData->RT_Data.Addr_Cnt);
				
                if(addrcnt == pstRDSData->RT_Data.Addr_Cnt)
				{
				    pstRDSData->RT_Data.BufCnt++;
				}
				else if(pstRDSData->RT_Data.BufCnt > 0)
				{
					pstRDSData->RT_Data.BufCnt--;
				}
            }
		} else {
			WCN_DBG(L7|D_G2, "RT %04x %04x %04x %04x %04x CRC error.", block_data[0], block_data[1], block_data[2], block_data[3], block_data[4]);
		}
		
	 	for(indx = 0; indx < 2; indx++)
	  	{
	  		if((pstRDSData->RT_Data.TextData[2][2*TextAddr+indx]) == 0x0D) //0x0D=end code
	  		{
	  		    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater
				pstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\0';
				pstRDSData->RT_Data.GetLength = 1;
	  		}
			else if((2*TextAddr+indx) == 31) //full data
			{
			    pstRDSData->RT_Data.TextLength = 2*TextAddr+indx+1;  //Add terminate charater
                pstRDSData->RT_Data.TextData[2][2*TextAddr+indx] = '\0';
				pstRDSData->RT_Data.GetLength = 1;
			}
	  	}		
	}

    //Check if text is fully received
	indx = TextAddr;
	if(pstRDSData->RT_Data.GetLength == 1)
	{
		addrcnt = 0xFFFF>>(0x0F-indx);
	}
	else if(pstRDSData->RT_Data.BufCnt > 100)
	{
	    pstRDSData->RT_Data.BufCnt = 0;
	    for(indx = 15; indx >= 0; indx--)
	    {
	        addrcnt = (pstRDSData->RT_Data.Addr_Cnt)&(1<<indx);
	        if(addrcnt)
	            break;
		}
		
		//get valid radio text length
		if (pstRDSData->RT_Data.isTypeA)
		{
		    for(indx2 = 0; indx2 < 4; indx2++)
		    {
		        if(pstRDSData->RT_Data.TextData[2][4*indx+indx2] == 0x0D)
	            {
	  			    pstRDSData->RT_Data.TextLength = 4*indx+indx2+1;
					pstRDSData->RT_Data.TextData[2][4*indx+indx2] = '\0';
	            }
		    }
	    }
	    else
	    {
	        for(indx2 = 0; indx2 < 2; indx2++)
		    {
		        if(pstRDSData->RT_Data.TextData[2][2*indx+indx2] == 0x0D)
	            {
	  			    pstRDSData->RT_Data.TextLength = 2*indx+indx2+1;
					pstRDSData->RT_Data.TextData[2][2*indx+indx2] = '\0';
	            }
		    }
	        
	    }
		addrcnt = 0xFFFF>>(0x0F-indx);
	}
	else
	{
		pstRDSData->RT_Data.TextLength = 0x0F;
		addrcnt = 0xFFFF;
	}
	
    WCN_DBG(L7|D_G2, "RetrieveGroup2 RDS RT: Addr_Cnt: 0x%x Length: 0x%x addrcnt: 0x%x\n", pstRDSData->RT_Data.Addr_Cnt, pstRDSData->RT_Data.TextLength, addrcnt);

	if(((((pstRDSData->RT_Data.Addr_Cnt)&addrcnt) == addrcnt)||((TextAddr == 0x0f) && (pstRDSData->RT_Data.Addr_Cnt == 0xffff))))//&&(pstRDSData->RT_Data.isRTDisplay == 0))
	{		
		pstRDSData->RT_Data.Addr_Cnt = 0;
		//pstRDSData->RT_Data.isRTDisplay = 1;

		pstRDSData->event_status |= RDS_EVENT_LAST_RADIOTEXT; 
		space = 0;
		for(indx = 0; indx < 64; indx++)
		{
			if(pstRDSData->RT_Data.TextData[2][indx] == 0x20)
				space++;
	    }	
	    if(space == 64)
            pstRDSData->event_status &= (~RDS_EVENT_LAST_RADIOTEXT);

		memset(&(pstRDSData->RT_Data.TextData[1][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[1]));
		memset(&(pstRDSData->RT_Data.TextData[0][0]), 0x20, sizeof(pstRDSData->RT_Data.TextData[0]));

		if (pstRDSData->event_status & RDS_EVENT_LAST_RADIOTEXT) {
			memcpy(&(pstRDSData->RT_Data.TextData[3][0]), &(pstRDSData->RT_Data.TextData[2][0]), sizeof(pstRDSData->RT_Data.TextData[3]));

			uint8_t tmp[66] = {0};
			tmp[64] = 'E';
			memcpy(tmp, pstRDSData->RT_Data.TextData[3], 64);
		
			WCN_DBG(L6|D_G2, "RT Radio text---%s\n", tmp);
			WCN_DBG(L6|D_G2, "RT set RDS_EVENT_LAST_RADIOTEXT flag, +++0x0D case.\n");
			pstRDSData->RT_Data.isRTDisplay = 1;
		}
    }
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 33 --
Question ID: 0fc59ce2d25a90e8084a35dc9fe2e4480312aaf9_0
Original Code:
```
void afcreate_bufr(char *docname, int size, char *outputformat,
                   char *issTimeStr, char *fxyPath, int debuglvl, int *ier)
/*******************************************************************************
  afcreate_bufr

  This routine takes the contents of the input XML document to create a BUFR
message
  containing SIERRA, TANGO, or ZULU Hazards.

  Input parameters:
    *docname        char  XML Document String
    size            int   Length of XML document
    *outputformat   char  Output Format String used for BUFR Message filename
    *issTimeStr     char  Issue Time String - to be used as timestamp for BUFR
    *fxyPath        char  Path to FXY Descriptor Tables
    debuglvl        int   Debug Level - 0 for no debugging
                                        1 for Dump of Data_MixVal_t structure
                                       >1 for more detailed MEL-BUFR Output
  L. Hinson         01/06 Created
*******************************************************************************/
{
  xmlDocPtr doc;
  enum GFADesignator GFADesignatorType = SIERRA;
  char typeBulletin[8];
  int numberOfBulletins,i,j,num_vals;
  BUFR_Info_t bufr_info;
  Data_MixVal_t *bufr_rec;
  FXY_t *rec_fxy=0x0;
  int num_fxys;
  int vals_check=0;
  GFAByDesignatorInfo *bufr_prerec=0x0;
  char bufrfilename[MAXST];
  char dateStamp[16];
  doc = xmlReadMemory(docname,size,"noname.xml",NULL,0);
  if (doc==NULL) {
    printf("afcreate_bufr::Error in parsing document.\n");
    exit(1);
  }
  numberOfBulletins=get_number_of_nodes( doc, (xmlChar*) "//bulletin");
  for (i=0;i<numberOfBulletins;i++) {
    getInfoStrbySub(doc,"/gfaInfo","/bulletin[%d]/@type",i+1,typeBulletin);
    for(j=0;j<3;j++) {
      if (strncmp(GFADesignatorNames[j],typeBulletin,6)==0) {
        GFADesignatorType=(enum GFADesignator) j;
        break;
      }
    }
    bufr_prerec=BuildRec(doc,GFADesignatorType,&num_vals);
    buildFilenameAndDateStampFmIssTime(issTimeStr, outputformat,
                                         bufrfilename, dateStamp);
    if (debuglvl > 1) {
       BUFR_Debug(debuglvl);
       BUFR_Trace(debuglvl);
    }
    initBUFR(&bufr_info,bufrfilename,dateStamp,bufr_prerec->td);
    bufr_rec=(Data_MixVal_t *) malloc(sizeof(Data_MixVal_t) *num_vals);
    switch(GFADesignatorType) {
      case SIERRA:
        rec_fxy=loadFXYs(fxyPath,"afbufrfxy.sierra",&num_fxys);
        fill_arraySIERRA(bufr_prerec->b.sierra,bufr_rec,&vals_check);
        break;
      case TANGO:
        rec_fxy=loadFXYs(fxyPath,"afbufrfxy.tango",&num_fxys);
        fill_arrayTANGO(bufr_prerec->b.tango, bufr_rec, &vals_check);
        break;
      case ZULU:
        rec_fxy=loadFXYs(fxyPath,"afbufrfxy.zulu",&num_fxys);
        fill_arrayZULU(bufr_prerec->b.zulu, bufr_rec, &vals_check);
        break;
    }
    if (debuglvl > 0)
      printf("bufr_rec vals_check=%d \n",vals_check);
    if (vals_check!=num_vals) {
      printf("Inconsistency check on number of values loaded\n");
      printf("bufr_prerec, Number items Loaded: %d\n",num_vals);
      printf("bufr_rec, Number items Loaded: %d\n",vals_check);
      exit(1);
    }
    if (debuglvl > 0) {
      printf("Dumping bufr_rec contents...\n");
      for (i=0;i<vals_check;i++) {
        if (bufr_rec[i].Val_Type==DT_INT) {
          printf ("***DT_INT %d %d \n",i, bufr_rec[i].Val.int_number);
        }
        else if (bufr_rec[i].Val_Type==DT_STRING) {
          printf("***DT_STRING %d %s \n",i,bufr_rec[i].Val.string);
        }
        else if (bufr_rec[i].Val_Type==DT_FLOAT) {
          printf("***DT_FLOAT %d %f \n",i,bufr_rec[i].Val.ffloat);
        }
      }
    }
    if ( BUFR_Put_MixArray(bufr_rec,vals_check,rec_fxy,num_fxys)) {
      BUFR_perror(" Error on call to BUFR_Put_Array in encodeBUFR");

      exit(1);
    }
    if( BUFR_Encode( &bufr_info)) {
      BUFR_perror("Bufr_Encode error in encodeBUFR");
      BUFR_Destroy(1);
    }
    BUFR_Destroy(1);
    free(rec_fxy);
    free_prerec_items(bufr_prerec);
    free(bufr_prerec);
    /*free up all string pointers in bufr_rec*/
    free_strings(bufr_rec,vals_check);
    free(bufr_rec);
    xmlFreeDoc(doc);
  }
}
```


Overlapping Code:
```
e_bufr(char *docname, int size, char *outputformat,
char *issTimeStr, char *fxyPath, int debuglvl, int *ier)
/*******************************************************************************
afcreate_bufr
This routine takes the contents of the input XML document to create a BUFR
message
containing SIERRA, TANGO, or ZULU Hazards.
Input parameters:
*docname char XML Document String
size int Length of XML document
*outputformat char Output Format String used for BUFR Message filename
*issTimeStr char Issue Time String - to be used as timestamp for BUFR
*fxyPath char Path to FXY Descriptor Tables
debuglvl int Debug Level - 0 for no debugging
1 for Dump of Data_MixVal_t stru01/06 Created
*******************************************************************************/
{
xmlDocPtr doc;
enum GFADesignator GFADesignatorType = SIERRA;
char typeBulletin[8];
int numberOfBulletins,i,j,num_vals;
BUFR_Info_t bufr_info;
Data_MixVal_t *bufr_rec;
FXY_t *rec_fxy=0x0;
int num_fxys;
int vals_check=0;
GFAByDesignatorInfo *bufr_prerec=0x0;
char bufrfilename[MAXST];
char dateStamp[16];
doc = xmlReadMemory(docname,size,"noname.xml",NULL,0);
if (doc==NULL) {
printf("afcreate_bufr::Error in parsing document.\n");
exit(1);
}
numberOfBulletins=get_number_of_nodes( doc, (xmlChar*) "//bulletin");
for (i=0;i<numberOfBulletins;i++) {
getInfoStrbySub(doc,"/gfaInfo","/bulletin[%d]/@type",i+1,typeBulletin);
for(j=0;j<3;j++) {
if (strncmp(GFADesignatorNames[j],typeBulletin,6)==0) {
GFADesignatorType=(enum GFADesignator) j;
break;
}
}
bufr_prerec=BuildRec(doc,GFADesignatorType,&num_vals);
buildFilenameAndDateStampFmIssTime(issTimeStr, outputformat,
bufrfilename, dateStamp);
if (debuglvl > 1) {
BUFR_Debug(debuglvl);
BUFR_Trace(debuglvl);
}
initBUFR(&bufr_info,bufrfilename,dateStamp,bufr_prerec->td);
bufr_rec=(Data_MixVal_t *) malloc(sizeof(Data_MixVal_t) *num_vals);
switch(GFADesignatorType) {
case SIERRA:
rec_fxy=loadFXYs(fxyPath,"afbufrfxy.sierra",&num_fxys);
fill_arraySIERRA(bufr_prerec->b.sierra,bufr_rec,&vals_check);
break;
ca
```
<Overlap Ratio: 0.9647786768205616>

---

--- 34 --
Question ID: 2f2fb6b6adbafdc2abefc39fdbea04247c42ee39_6
Original Code:
```
static int
update_bootinfo (struct devinfo_context *ctx)
{
	uint32_t *crcptr;
	struct device_info *info;
	ssize_t n, cnt;
	int idx;

	if (ctx == NULL) {
		fprintf(stderr, "error: invalid context provided for update\n");
		return -1;
	}
	if (ctx->readonly) {
		fprintf(stderr, "error: update requested for read-only context\n");
		return -1;
	}
	/*
	 * Invalid current index -> initialize
	 */
	if (ctx->current < 0 || ctx->current > 1)
		idx = 0;
	else
		idx = 1 - ctx->current;

	info = (struct device_info *) ctx->infobuf[idx];
	crcptr = (uint32_t *) &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE + EXTENSION_SIZE - sizeof(uint32_t)];
	memset(info, 0, DEVINFO_BLOCK_SIZE);
	memcpy(info->magic, DEVICE_MAGIC, sizeof(info->magic));
	info->devinfo_version = DEVINFO_VERSION_CURRENT;
	info->flags = ctx->curinfo.flags;
	info->failed_boots = ctx->curinfo.failed_boots;
	info->sernum = ctx->curinfo.sernum + 1;
	info->ext_sectors = EXTENSION_SECTOR_COUNT;
	if (pack_vars(ctx, idx) < 0)
		return -1;
	info->crcsum = crc32(0, ctx->infobuf[idx], DEVINFO_BLOCK_SIZE);
	*crcptr = crc32(0, &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE], EXTENSION_SIZE-sizeof(uint32_t));

	if (lseek(ctx->fd, devinfo_offset[idx], SEEK_END) < 0) {
		perror(devinfo_dev);
		set_bootdev_writeable_status(devinfo_dev, false);
		return -1;
	}
	for (n = 0; n < DEVINFO_BLOCK_SIZE; n += cnt) {
		cnt = write(ctx->fd, ctx->infobuf[idx] + n, DEVINFO_BLOCK_SIZE-n);
		if (cnt < 0) {
			perror(devinfo_dev);
			set_bootdev_writeable_status(devinfo_dev, false);
			return -1;
		}
	}
	if (lseek(ctx->fd, extension_offset[idx], SEEK_END) < 0) {
		perror(devinfo_dev);
		set_bootdev_writeable_status(devinfo_dev, false);
		return -1;
	}
	for (n = 0; n < EXTENSION_SIZE; n += cnt) {
		cnt = write(ctx->fd, ctx->infobuf[idx] + DEVINFO_BLOCK_SIZE + n, EXTENSION_SIZE-n);
		if (cnt < 0) {
			perror(devinfo_dev);
			set_bootdev_writeable_status(devinfo_dev, false);
			return -1;
		}
	}

	return 0;

}
```


Overlapping Code:
```
(struct devinfo_context *ctx)
{
uint32_t *crcptr;
struct device_info *info;
ssize_t n, cnt;
int idx;
if (ctx == NULL) {
fprintf(stderr, "error: invalid context provided for update\n");
return -1;
}
if (ctx->readonly) {
fprintf(stderr, "error: update requested for read-only context\n");
return -1;
}
/*
* Invalid current index -> initialize
*/
if (ctx->current < 0 || ctx->current > 1)
idx = 0;
else
idx = 1 - ctx->current;
info = (struct device_info *) ctx->infobuf[idx];
crcptr = (uint32_t *) &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE + EXTENSION_SIZE - sizeof(uint32_t)];
memset(info, 0, DEVINFO_BLOCK_SIZE);
memcpy(info->magic, DEVICE_MAGIC, sizeof(info->magic));
info->devinfo_version = DEVINFO_VERSION_CURRENT;
info->flags = ctx->curinfo.flags;
info->failed_boots = ctx->curinfo.failed_boots;
info->sernum = ctx->curinfo.sernum + 1;
info->ext_sectors = EXTENSION_SECTOR_COUNT;
if (pack_vars(ctx, idx) < 0)
return -1;
info->crcsum = crc32(0, ctx->infobuf[idx], DEVINFO_BLOCK_SIZE);
*crcptr = crc32(0, &ctx->infobuf[idx][DEVINFO_BLOCK_SIZE], EXTENSION_SIZE-sizeof(uint32_t));
if (lseek(ctx->fd, devinfo_offset[idx], SEEK_END) < 0) {
perror(devinfo_dev);
set_bootdev_writeable_status(devinfo_dev, false);
return -1;
}
for (n = 0; n < DEVINFO_BLOCK_SIZE; n += cnt) {
cnt = write(ctx->fd, ctx->infobuf[idx] + n, DEVINFO_BLOCK_SIZE-n);
if (cnt < 0) {
perror(devinfo_dev);
set_bootdev_writeable_status(devinfo_dev, false);
return -1;
}
}
if (lseek(ctx->fd, extension_offset[idx], SEEK_END) < 0) {
perror(devinfo_dev);
set_bootdev_writeable_status(devinfo_dev, false);
return -1;
}
for (n = 0; n < EXTENSION_SIZE; n += cnt) {
cnt = write(ctx->fd, ctx->infobuf[idx] + DEVINFO_BLOCK_SIZE + n, EXTENSION_SIZE-n);
if (cnt < 0) {
perror(devinfo_dev);
set_bootdev_writeable_status(devinfo_dev, false);
return -1;
```
<Overlap Ratio: 0.9766684753119913>

---

--- 35 --
Question ID: 761d670bad27e2e427dbe4e2e5222f5214ebf4ee_17
Original Code:
```
static void mdss_dsi_parse_trigger(struct device_node *np, char *trigger,
		char *trigger_key)
{
	const char *data;

	*trigger = DSI_CMD_TRIGGER_SW;
	data = of_get_property(np, trigger_key, NULL);
	if (data) {
		if (!strcmp(data, "none"))
			*trigger = DSI_CMD_TRIGGER_NONE;
		else if (!strcmp(data, "trigger_te"))
			*trigger = DSI_CMD_TRIGGER_TE;
		else if (!strcmp(data, "trigger_sw_seof"))
			*trigger = DSI_CMD_TRIGGER_SW_SEOF;
		else if (!strcmp(data, "trigger_sw_te"))
			*trigger = DSI_CMD_TRIGGER_SW_TE;
	}
}
```


Overlapping Code:
```
i_parse_trigger(struct device_node *np, char *trigger,
char *trigger_key)
{
const char *data;
*trigger = DSI_CMD_TRIGGER_SW;
data = of_get_property(np, trigger_key, NULL);
if (data) {
if (!strcmp(data, "none"))
*trigger = DSI_CMD_TRIGGER_NONE;
else if (!strcmp(data, "trigger_te"))
*trigger = DSI_CMD_TRIGGER_TE;
else if (!strcmp(data, "trigger_sw_seof"))
*trigger = DSI_CMD_TRIGGER_SW_SEOF;
else if (!strcmp(data, "trigger_sw_te"))
*trigger = DSI_CMD_TR
```
<Overlap Ratio: 0.9284253578732107>

---

--- 36 --
Question ID: 12fd0a5fc91adde9d23f341e7ebd42a90636f9e3_5
Original Code:
```
void unhide_dependencies(struct data_node *deps)
{
	struct module_node *mod_node = (struct module_node *)deps->data;
	unhide_module(mod_node->mod, mod_node->mod_next);
	kfree(mod_node);
}
```


Overlapping Code:
```
nhide_dependencies(struct data_node *deps)
{
struct module_node *mod_node = (struct module_node *)deps->data;
unhide_module(mod_node->mod, mod_node->m
```
<Overlap Ratio: 0.8152173913043478>

---

--- 37 --
Question ID: 1a624eec4bec18680a7870c1237ac4c5c0466dff_1
Original Code:
```
static int cmd_setup_device(int argc, char* argv[]) {
  char * free_loop = loopdev_find_unused();

  printf("Loop device: %s\n", free_loop);

  if(loopdev_setup_device(argv[0], atoi(argv[1]), free_loop)) {
    fprintf(stderr, "Failed to associate loop device (%s) to file (%s).\n", free_loop, argv[0]);
    goto error;
  }

  free(free_loop);

  return 0;

  error:
    free(free_loop);
    return 1;
}
```


Overlapping Code:
```
_setup_device(int argc, char* argv[]) {
char * free_loop = loopdev_find_unused();
printf("Loop device: %s\n", free_loop);
if(loopdev_setup_device(argv[0], atoi(argv[1]), free_loop)) {
fprintf(stderr, "Failed to associate loop device (%s) to file (%s).\n", free_loop, argv[0]);
goto error;
}
free(free_loop);
return 0;
error:
free(free_loop);
return 1
```
<Overlap Ratio: 0.9536784741144414>

---

--- 38 --
Question ID: e85f6b042954bef829a04519eaa1b227abc6f3d0_10
Original Code:
```
extern void icmpttlexceeded6(struct Fs *f, struct Ipifc *ifc, struct block *bp)
{
	struct block *nbp;
	struct IPICMP *np;
	struct ip6hdr *p;
	int osz = BLEN(bp);
	int sz = MIN(sizeof(struct IPICMP) + osz, v6MINTU);
	struct Proto *icmp = f->t2p[ICMPv6];
	Icmppriv6 *ipriv = icmp->priv;

	p = (struct ip6hdr *)bp->rp;

	if (isv6mcast(p->src))
		return;

	nbp = newIPICMP(sz);
	np = (struct IPICMP *)nbp->rp;

	if (ipv6anylocal(ifc, np->src)) {
		netlog(f, Logicmp, "send icmpttlexceeded6 -> s%I d%I\n", p->src,
			   p->dst);
	} else {
		netlog(f, Logicmp, "icmpttlexceeded6 fail -> s%I d%I\n", p->src,
			   p->dst);
		return;
	}

	memmove(np->dst, p->src, IPaddrlen);
	np->type = TimeExceedV6;
	np->code = 0;
	memmove(nbp->rp + sizeof(struct IPICMP), bp->rp,
			sz - sizeof(struct IPICMP));
	set_cksum(nbp);
	np->ttl = HOP_LIMIT;
	np->vcf[0] = 0x06 << 4;
	ipriv->out[TimeExceedV6]++;
	ipoput6(f, nbp, 0, MAXTTL, DFLTTOS, NULL);
}
```


Overlapping Code:
```
ern void icmpttlexceeded6(struct Fs *f, struct Ipifc *ifc, struct block *bp)
{
struct block *nbp;
struct IPICMP *np;
struct ip6hdr *p;
int osz = BLEN(bp);
int sz = MIN(sizeof(struct IPICMP) + osz, v6MINTU);
struct Proto *icmp = f->t2p[ICMPv6];
Icmppriv6 *ipriv = icmp->priv;
p = (struct ip6hdr *)bp->rp;
if (isv6mcast(p->src))
return;
nbp = newIPICMP(sz);
np = (struct IPICMP *)nbp->rp;
if (ipv6anylocal(ifc, np->src)) {
netlog(f, Logicmp, "send icmpttlexceeded6 -> s%I d%I\n", p->src,
p->dst);
} else {
netlog(f, Logicmp, "icmpttlexceeded6 fail -> s%I d%I\n", p->src,
p->dst);
return;
}
memmove(np->dst, p->src, IPaddrlen);
np->type = TimeExceedV6;
np->code = 0;
memmove(nbp->rp + sizeof(struct IPICMP), bp->rp,
sz - sizeof(struct IPICMP));
set_cksum(nbp);
np->ttl = HOP_LIMIT;
np->vcf[0] = 0x06 << 4;
ipriv->out[TimeExceedV6]++;
ipoput6(f, nbp, 0, MAXTTL, DFL
```
<Overlap Ratio: 0.9806378132118451>

---

--- 39 --
Question ID: 00589654985084cd135dce9b946cc82b4d517e2a_1
Original Code:
```
JNICALL 
Java_org_openafs_jafs_Server_getServerInfo (JNIEnv *env, jclass cls, 
					       jlong cellHandle, jstring jname, 
					       jobject server) {

  const char *name;
  afs_status_t ast;
  afs_serverEntry_t servEntry;

  if( jname != NULL ) {
    name = (*env)->GetStringUTFChars(env, jname, 0);
    if( !name ) {
	throwAFSException( env, JAFSADMNOMEM );
	return;    
    }
  } else {
    name = NULL;
  }

  // get the server entry
  if ( !afsclient_AFSServerGet( (void *) cellHandle, name, 
				&servEntry, &ast ) ) {
    if( name != NULL ) {
      (*env)->ReleaseStringUTFChars(env, jname, name);
    }
    throwAFSException( env, ast );
    return;
  }

  fillServerInfo( env, cellHandle, server, servEntry );

  if( name != NULL ) {
    (*env)->ReleaseStringUTFChars(env, jname, name);
  }

}
```


Overlapping Code:
```
erver_getServerInfo (JNIEnv *env, jclass cls, 
jlong cellHandle, jstring jname, 
jobject server) {
const char *name;
afs_status_t ast;
afs_serverEntry_t servEntry;
if( jname != NULL ) {
name = (*env)->GetStringUTFChars(env, jname, 0);
if( !name ) {
throwAFSException( env, JAFSADMNOMEM );
return; 
}
} else {
name = NULL;
}
// get the server entry
if ( !afsclient_AFSServerGet( (void *) cellHandle, name, 
&servEntry, &ast ) ) {
if( name != NULL ) {
(*env)->ReleaseStringUTFChars(env, jname, name);
}
throwAFSException( env, ast );
return;
}
fillServerInfo( env, cellHandle, server, servEntry );
if( name != NULL ) {
(*env)->ReleaseStringUTFChars(env, jname, name);
}
}
```
<Overlap Ratio: 0.9543509272467903>

---

--- 40 --
Question ID: 369f69aa446473482c4061d3a49e9d036fd85bc2_1
Original Code:
```
__DEVICE__ float noise (in float2 _st) {
    float2 i = _floor(_st);
    float2 f = fract_f2(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + to_float2(1.0f, 0.0f));
    float c = random(i + to_float2(0.0f, 1.0f));
    float d = random(i + to_float2(1.0f, 1.0f));

    float2 u = f * f * (3.0f - 2.0f * f);

    return _mix(a, b, u.x) +
           (c - a)* u.y * (1.0f - u.x) +
           (d - b) * u.x * u.y;
}
```


Overlapping Code:
```
EVICE__ float noise (in float2 _st) {
float2 i = _floor(_st);
float2 f = fract_f2(_st);
// Four corners in 2D of a tile
float a = random(i);
float b = random(i + to_float2(1.0f, 0.0f));
float c = random(i + to_float2(0.0f, 1.0f));
float d = random(i + to_float2(1.0f, 1.0f));
float2 u = f * f * (3.0f - 2.0f * f);
return _mix(a, b, u.x) +
(c - a)* u.
```
<Overlap Ratio: 0.8883248730964467>

---

--- 41 --
Question ID: 0a77734b3c2ffab22ad3a19eade874ec28113b89_74
Original Code:
```
VG_API_ENTRY vgSetPaint(
   VGPaint vg_handle,
   VGbitfield paint_modes) VG_API_EXIT
{
   CLIENT_THREAD_STATE_T *thread = CLIENT_GET_THREAD_STATE();
   VG_CLIENT_STATE_T *state = VG_GET_CLIENT_STATE(thread);
   if (!state) {
      return;
   }

   if (!is_paint_modes(paint_modes)) {
      set_error(VG_ILLEGAL_ARGUMENT_ERROR);
      return;
   }

   platform_mutex_acquire(&state->shared_state->mutex);
   if ((vg_handle != VG_INVALID_HANDLE) &&
      !lookup_object(state, vg_handle, VG_CLIENT_OBJECT_TYPE_PAINT)) {
      set_error(VG_BAD_HANDLE_ERROR);
      platform_mutex_release(&state->shared_state->mutex);
      return;
   }
   platform_mutex_release(&state->shared_state->mutex);

   if (((paint_modes & VG_FILL_PATH) && (state->fill_paint != vg_handle)) ||
      ((paint_modes & VG_STROKE_PATH) && (state->stroke_paint != vg_handle))) {
      if (paint_modes & VG_FILL_PATH) {
         state->fill_paint = vg_handle;
      }
      if (paint_modes & VG_STROKE_PATH) {
         state->stroke_paint = vg_handle;
      }
      RPC_CALL2(vgSetPaint_impl,
                thread,
                VGSETPAINT_ID,
                RPC_HANDLE(vg_handle),
                RPC_BITFIELD(paint_modes));
   }
}
```


Overlapping Code:
```
handle,
VGbitfield paint_modes) VG_API_EXIT
{
CLIENT_THREAD_STATE_T *thread = CLIENT_GET_THREAD_STATE();
VG_CLIENT_STATE_T *state = VG_GET_CLIENT_STATE(thread);
if (!state) {
return;
}
if (!is_paint_modes(paint_modes)) {
set_error(VG_ILLEGAL_ARGUMENT_ERROR);
return;
}
platform_mutex_acquire(&state->shared_state->mutex);
if ((vg_handle != VG_INVALID_HANDLE) &&
!lookup_object(state, vg_handle, VG_CLIENT_OBJECT_TYPE_PAINT)) {
set_error(VG_BAD_HANDLE_ERROR);
platform_mutex_release(&state->shared_state->mutex);
return;
}
platform_mutex_release(&state->shared_state->mutex);
if (((paint_modes & VG_FILL_PATH) && (state->fill_paint != vg_handle)) ||
((paint_modes & VG_STROKE_PATH) && (state->stroke_paint != vg_handle))) {
if (paint_modes & VG_FILL_PATH) {
state->fill_paint = vg_handle;
}
if (paint_modes & VG_STROKE_PATH) {
state->stroke_paint = vg_handle;
}
RPC_CALL2(vgSetPaint_impl,
thread,
VGSETPAINT_ID,
RPC_HANDLE(vg_handle),
RPC_BITFIELD(pain
```
<Overlap Ratio: 0.9500499500499501>

---

--- 42 --
Question ID: 8828ad23a67ea055658bce426031230854cf7bac_0
Original Code:
```
class EcalPerEvtLaserAnalyzer : public edm::EDAnalyzer {
public:
  explicit EcalPerEvtLaserAnalyzer(const edm::ParameterSet &iConfig);
  ~EcalPerEvtLaserAnalyzer() override;

  void analyze(const edm::Event &e, const edm::EventSetup &c) override;
  void beginJob() override;
  void endJob() override;

  enum VarCol { iBlue, iRed, nColor };

private:
  int iEvent;

  // Framework parameters

  unsigned int _nsamples;
  unsigned int _presample;
  unsigned int _firstsample;
  unsigned int _lastsample;
  unsigned int _samplemin;
  unsigned int _samplemax;
  unsigned int _nsamplesPN;
  unsigned int _presamplePN;
  unsigned int _firstsamplePN;
  unsigned int _lastsamplePN;
  unsigned int _timingcutlow;
  unsigned int _timingcuthigh;
  unsigned int _niter;
  int _fedid;
  unsigned int _tower;
  unsigned int _channel;
  std::string _ecalPart;

  std::string resdir_;
  std::string refalphabeta_;
  std::string digiCollection_;
  std::string digiPNCollection_;
  std::string digiProducer_;
  std::string eventHeaderCollection_;
  std::string eventHeaderProducer_;

  // Output file names

  std::string alphafile;
  std::string ADCfile;
  std::string APDfile;
  std::string resfile;

  //  Define geometrical constants
  //  Default values correspond to "EB" geometry (1700 crystals)

  unsigned int nCrys;
  unsigned int nTT;
  unsigned int nSides;

  int IsFileCreated;

  // Define number of channels (68 or 1700) for alpha and beta calculation

  unsigned int nCh;

  // Identify run type

  int runType;
  int runNum;
  int dccID;
  int fedID;
  int lightside;

  int channelNumber;

  std::vector<int> colors;

  // Temporary root files and trees
  TFile *matacqFile;
  TTree *matacqTree;

  TFile *ADCFile;
  TTree *ADCtrees;

  TFile *APDFile;
  TTree *header[2];
  TTree *APDtrees;

  int doesRefFileExist;
  int IsThereDataADC[nColor];
  int IsHeaderFilled[nColor];

  double ttMat, peakMat, peak;
  int evtMat, colMat;

  // Declaration of leaves types for temporary trees

  int phi, eta;
  int event;
  int color;
  double adc[10];
  int adcG[10];
  double tt;
  double ttrig;
  double pn0, pn1;
  double pn[50];
  double apdAmpl;
  double apdTime;
  double pnAmpl;
}
```


Overlapping Code:
```
tLaserAnalyzer : public edm::EDAnalyzer {
public:
explicit EcalPerEvtLaserAnalyzer(const edm::ParameterSet &iConfig);
~EcalPerEvtLaserAnalyzer() override;
void analyze(const edm::Event &e, const edm::EventSetup &c) override;
void beginJob() override;
void endJob() override;
enum VarCol { iBlue, iRed, nColor };
private:
int iEvent;
// Framework parameters
unsigned int _nsamples;
unsigned int _presample;
unsigned int _firstsample;
unsigned int _lastsample;
unsigned int _samplemin;
unsigned int _samplemax;
unsigned int _nsamplesPN;
unsigned int _presamplePN;
unsigned int _firstsamplePN;
unsigned int _lastsamplePN;
unsigned int _timingcutlow;
unsigned int _timingcuthigh;
unsigned int _niter;
int _fedid;
unsigned int _tower;
unsigned int _channel;
std::string _ecalPart;
std::string resdir_;
std::string refalphabeta_;
std::string digiCollection_;
std::string digiPNCollection_;
std::string digiProducer_;
std::string eventHeaderCollection_;
std::string eventHeaderProducer_;
// Output file names
std::string alphafile;
std::string ADCfile;
std::string APDfile;
std::string resfile;
// Define geometrical constants
// Default values correspond to "EB" geometry (1700 crystals)
unsigned int nCrys;
unsigned int nTT;
unsigned int nSides;
int IsFileCreated;
// Define number of channels (68 or 1700) for alpha and beta calculation
unsigned int nCh;
// Identify run type
int runType;
int runNum;
int dccID;
int fedID;
int lightside;
int channelNumber;
std::vector<int> colors;
// Temporary root files and trees
TFile *matacqFile;
TTree *matacqTree;
TFile *ADCFile;
TTree *ADCtrees;
TFile *APDFile;
TTree *header[2];
TTree *APDtrees;
int doesRefFileExist;
int IsThereDataADC[nColor];
int IsHeaderFilled[nColor];
double ttMat, peakMat, peak;
int evtMat, colMat;
// Declaration of leaves types for temporary trees
int phi, eta;
int event;
int color;
double adc[10];
int adcG[10];
double tt;
double ttrig;
double pn0, pn1;
double pn[50];
double apdAmpl;
```
<Overlap Ratio: 0.975975975975976>

---

--- 43 --
Question ID: fdc97807f90662bcdf1385ca1d546734a08b92db_82
Original Code:
```
static void init_fixtures(void)
{
	dfix_empty.init = ptu_dfix_init;
	dfix_empty.fini = ptu_dfix_fini;

	dfix_indir = dfix_empty;
	dfix_indir.header = ptu_dfix_header_indir;

	dfix_cond = dfix_empty;
	dfix_cond.header = ptu_dfix_header_cond;

	dfix_event = dfix_empty;
	dfix_event.header = ptu_dfix_header_event;

	dfix_event_psb = dfix_empty;
	dfix_event_psb.header = ptu_dfix_header_event_psb;
}
```


Overlapping Code:
```
t_fixtures(void)
{
dfix_empty.init = ptu_dfix_init;
dfix_empty.fini = ptu_dfix_fini;
dfix_indir = dfix_empty;
dfix_indir.header = ptu_dfix_header_indir;
dfix_cond = dfix_empty;
dfix_cond.header = ptu_dfix_header_cond;
dfix_event = dfix_empty;
dfix_event.header = ptu_dfix_header_event;
dfix_event_psb = dfix_empty;
dfix_event_psb.header = ptu_dfix_he
```
<Overlap Ratio: 0.9162303664921466>

---

--- 44 --
Question ID: f0153c099b331ea049fed500630a4902bc96e43f_7
Original Code:
```
static int
ProcSecurityGenerateAuthorization(client)
    ClientPtr client;
{
    REQUEST(xSecurityGenerateAuthorizationReq);
    int len;			/* request length in CARD32s*/
    Bool removeAuth = FALSE;	/* if bailout, call RemoveAuthorization? */
    SecurityAuthorizationPtr pAuth = NULL;  /* auth we are creating */
    int err;			/* error to return from this function */
    int status;			/* return value from os functions */
    XID authId;			/* authorization ID assigned by os layer */
    xSecurityGenerateAuthorizationReply rep; /* reply struct */
    unsigned int trustLevel;    /* trust level of new auth */
    XID group;			/* group of new auth */
    CARD32 timeout;		/* timeout of new auth */
    CARD32 *values;		/* list of supplied attributes */
    char *protoname;		/* auth proto name sent in request */
    char *protodata;		/* auth proto data sent in request */
    unsigned int authdata_len;  /* # bytes of generated auth data */
    char *pAuthdata;		/* generated auth data */
    Mask eventMask;		/* what events on this auth does client want */

    /* paranoia: this "can't happen" because this extension is hidden
     * from untrusted clients, but just in case...
     */
    if (client->trustLevel != XSecurityClientTrusted)
	return BadRequest;

    /* check request length */

    REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
    len = SIZEOF(xSecurityGenerateAuthorizationReq) >> 2;
    len += (stuff->nbytesAuthProto + (unsigned)3) >> 2;
    len += (stuff->nbytesAuthData  + (unsigned)3) >> 2;
    values = ((CARD32 *)stuff) + len;
    len += Ones(stuff->valueMask);
    if (client->req_len != len)
	return BadLength;

    /* check valuemask */
    if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)
    {
	client->errorValue = stuff->valueMask;
	return BadValue;
    }

    /* check timeout */
    timeout = 60;
    if (stuff->valueMask & XSecurityTimeout)
    {
	timeout = *values++;
    }

    /* check trustLevel */
    trustLevel = XSecurityClientUntrusted;
    if (stuff->valueMask & XSecurityTrustLevel)
    {
	trustLevel = *values++;
	if (trustLevel != XSecurityClientTrusted &&
	    trustLevel != XSecurityClientUntrusted)
	{
	    client->errorValue = trustLevel;
	    return BadValue;
	}
    }

    /* check group */
    group = None;
    if (stuff->valueMask & XSecurityGroup)
    {
	group = *values++;
	if (SecurityValidateGroupCallback)
	{
	    SecurityValidateGroupInfoRec vgi;
	    vgi.group = group;
	    vgi.valid = FALSE;
	    CallCallbacks(&SecurityValidateGroupCallback, (pointer)&vgi);

	    /* if nobody said they recognized it, it's an error */

	    if (!vgi.valid)
	    {
		client->errorValue = group;
		return BadValue;
	    }
	}
    }

    /* check event mask */
    eventMask = 0;
    if (stuff->valueMask & XSecurityEventMask)
    {
	eventMask = *values++;
	if (eventMask & ~XSecurityAllEventMasks)
	{
	    client->errorValue = eventMask;
	    return BadValue;
	}
    }

    protoname = (char *)&stuff[1];
    protodata = protoname + ((stuff->nbytesAuthProto + (unsigned)3) >> 2);

    /* call os layer to generate the authorization */

    authId = GenerateAuthorization(stuff->nbytesAuthProto, protoname,
				   stuff->nbytesAuthData,  protodata,
				   &authdata_len, &pAuthdata);
    if ((XID) ~0L == authId)
    {
	err = SecurityErrorBase + XSecurityBadAuthorizationProtocol;
	goto bailout;
    }

    /* now that we've added the auth, remember to remove it if we have to
     * abort the request for some reason (like allocation failure)
     */
    removeAuth = TRUE;

    /* associate additional information with this auth ID */

    pAuth = (SecurityAuthorizationPtr)xalloc(sizeof(SecurityAuthorizationRec));
    if (!pAuth)
    {
	err = BadAlloc;
	goto bailout;
    }

    /* fill in the auth fields */

    pAuth->id = authId;
    pAuth->timeout = timeout;
    pAuth->group = group;
    pAuth->trustLevel = trustLevel;
    pAuth->refcnt = 0;	/* the auth was just created; nobody's using it yet */
    pAuth->secondsRemaining = 0;
    pAuth->timer = NULL;
    pAuth->eventClients = NULL;

    /* handle event selection */
    if (eventMask)
    {
	err = SecurityEventSelectForAuthorization(pAuth, client, eventMask);
	if (err != Success)
	    goto bailout;
    }

    if (!AddResource(authId, SecurityAuthorizationResType, pAuth))
    {
	err = BadAlloc;
	goto bailout;
    }

    /* start the timer ticking */

    if (pAuth->timeout != 0)
	SecurityStartAuthorizationTimer(pAuth);

    /* tell client the auth id and data */

    rep.type = X_Reply;
    rep.length = (authdata_len + 3) >> 2;
    rep.sequenceNumber = client->sequence;
    rep.authId = authId;
    rep.dataLength = authdata_len;

    if (client->swapped)
    {
	register char n;
    	swapl(&rep.length, n);
    	swaps(&rep.sequenceNumber, n);
    	swapl(&rep.authId, n);
    	swaps(&rep.dataLength, n);
    }

    WriteToClient(client, SIZEOF(xSecurityGenerateAuthorizationReply),
		  (char *)&rep);
    WriteToClient(client, authdata_len, pAuthdata);

    SecurityAudit("client %d generated authorization %d trust %d timeout %d group %d events %d\n",
		  client->index, pAuth->id, pAuth->trustLevel, pAuth->timeout,
		  pAuth->group, eventMask);

    /* the request succeeded; don't call RemoveAuthorization or free pAuth */

    removeAuth = FALSE;
    pAuth = NULL;
    err = client->noClientException;

bailout:
    if (removeAuth)
	RemoveAuthorization(stuff->nbytesAuthProto, protoname,
			    authdata_len, pAuthdata);
    if (pAuth) xfree(pAuth);
    return err;

}
```


Overlapping Code:
```
static int
ProcSecurityGenerateAuthorization(client)
ClientPtr client;
{
REQUEST(xSecurityGenerateAuthorizationReq);
int len; /* request length in CARD32s*/
Bool removeAuth = FALSE; /* if bailout, call RemoveAuthorization? */
SecurityAuthorizationPtr pAuth = NULL; /* auth we are creating */
int err; /* error to return from this function */
int status; /* return value from os functions */
XID authId; /* authorization ID assigned by os layer */
xSecurityGenerateAuthorizationReply rep; /* reply struct */
unsigned int trustLevel; /* trust level of new auth */
XID group; /* group of new auth */
CARD32 timeout; /* timeout of new auth */
CARD32 *values; /* list of supplied attributes */
char *protoname; /* auth proto name sent in request */
char *protodata; /* auth proto data sent in request */
unsigned int authdata_len; /* # bytes of generated auth data */
char *pAuthdata; /* generated auth data */
Mask eventMask; /* what events on this auth does client want */
/* paranoia: this "can't happen" because this extension is hidden
* from untrusted clients, but just in case...
*/
if (client->trustLevel != XSecurityClientTrusted)
return BadRequest;
/* check request length */
REQUEST_AT_LEAST_SIZE(xSecurityGenerateAuthorizationReq);
len = SIZEOF(xSecurityGenerateAuthorizationReq) >> 2;
len += (stuff->nbytesAuthProto + (unsigned)3) >> 2;
len += (stuff->nbytesAuthData + (unsigned)3) >> 2;
values = ((CARD32 *)stuff) + len;
len += Ones(stuff->valueMask);
if (client->req_len != len)
return BadLength;
/* check valuemask */
if (stuff->valueMask & ~XSecurityAllAuthorizationAttributes)
{
client->errorValue = stuff->valueMask;
return BadValue;
}
/* check timeout */
timeout = 60;
if (stuff->valueMask & XSecurityTimeout)
{
timeout = *values++;
}
/* check trustLevel */
trustLevel = XSecurityClientUntrusted;
if (stuff->valueMask & XSecurityTrustLevel)
{
trustLevel = *values++;
if (trustLevel != XSecurityClientTrusted &&
trustLevel != XSecurityClientUntrusted)
{
client->errorValue = trustLevel;
return BadValue;
}
}
/* check group */
group = None;
if (stuff->valueMask & XSecurityGroup)
{
group = *values++;
if (SecurityValidateGroupCallback)
{
SecurityValidateGroupInfoRec vgi;
vgi.group = gro
```
<Overlap Ratio: 0.9869896814715119>

---

--- 45 --
Question ID: bbe2b0cd148a1ee1cf15394ea0ed4a7c5d84bd9a_21
Original Code:
```
platform_result_t platform_ethernet_start( void )
{
    et_info_t*     et    = &et_instance;
    wiced_mutex_t* mutex = &et->op_mutex;

    if ( !PLATFORM_FEATURE_ENAB( GMAC ) )
    {
        return PLATFORM_UNSUPPORTED;
    }

    WICED_ETHERNET_CHECK_AND_RET( et->etc != NULL, PLATFORM_ERROR );
    WICED_ETHERNET_CHECK_AND_RET( et->started == WICED_FALSE, PLATFORM_ERROR );

    WICED_ETHERNET_CHECK_AND_RET( wiced_rtos_register_timed_event( &et->wd_event, WICED_ETHERNET_WATCHDOG_THREAD,
        &ethernet_watchdog_event, et->cfg->wd_period_ms, et ) == WICED_SUCCESS, PLATFORM_ERROR );

    wiced_rtos_lock_mutex( mutex );

    et->etc->linkstate = FALSE; /* force watchdog to report if linkstate is up now */
    et->started = WICED_TRUE;
    platform_irq_enable_irq( GMAC_ExtIRQn );

    wiced_rtos_unlock_mutex( mutex );

    return PLATFORM_SUCCESS;
}
```


Overlapping Code:
```
 platform_ethernet_start( void )
{
et_info_t* et = &et_instance;
wiced_mutex_t* mutex = &et->op_mutex;
if ( !PLATFORM_FEATURE_ENAB( GMAC ) )
{
return PLATFORM_UNSUPPORTED;
}
WICED_ETHERNET_CHECK_AND_RET( et->etc != NULL, PLATFORM_ERROR );
WICED_ETHERNET_CHECK_AND_RET( et->started == WICED_FALSE, PLATFORM_ERROR );
WICED_ETHERNET_CHECK_AND_RET( wiced_rtos_register_timed_event( &et->wd_event, WICED_ETHERNET_WATCHDOG_THREAD,
&ethernet_watchdog_event, et->cfg->wd_period_ms, et ) == WICED_SUCCESS, PLATFORM_ERROR );
wiced_rtos_lock_mutex( mutex );
et->etc->linkstate = FALSE; /* force watchdog to report if linkstate is up now */
et->started = WICED_TRUE;
platform_irq_enable_irq( GMAC_ExtIRQn );
wiced_rtos_unlock_mutex( mutex );
return PLATFORM_SUCC
```
<Overlap Ratio: 0.9702457956015524>

---

--- 46 --
Question ID: a8da05331d743355f21e9d71e9dd0931f1c3a26a_4
Original Code:
```
void print_ingame_header(uint32_t score, bool game_over)
{
    clear_screen_area(&glibContext,
                      0,
                      SL_MEMLCD_DISPLAY_WIDTH - 1,
                      0,
                      INGAME_HEADER_DELIMITER);

    // print header delimiter
    GLIB_drawLineH(&glibContext, 0,
                   INGAME_HEADER_DELIMITER - 1,
                   SL_MEMLCD_DISPLAY_WIDTH - 1);

    // print game over if present
    if (game_over) {
      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNormal8x8);
      GLIB_drawStringOnLine(&glibContext,
                            "Game Over",
                            0,
                            GLIB_ALIGN_LEFT,
                            1,
                            1,
                            true);
      GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNarrow6x8);
    }

    // print score
    char score_str[sizeof(uint32_t)*8+1];
    sprintf(score_str, "%d", (int)score);
    GLIB_drawStringOnLine(&glibContext,
                          score_str,
                          0,
                          GLIB_ALIGN_RIGHT,
                          -1,
                          1,
                          true);

    DMD_updateDisplay();
}
```


Overlapping Code:
```
ool game_over)
{
clear_screen_area(&glibContext,
0,
SL_MEMLCD_DISPLAY_WIDTH - 1,
0,
INGAME_HEADER_DELIMITER);
// print header delimiter
GLIB_drawLineH(&glibContext, 0,
INGAME_HEADER_DELIMITER - 1,
SL_MEMLCD_DISPLAY_WIDTH - 1);
// print game over if present
if (game_over) {
GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNormal8x8);
GLIB_drawStringOnLine(&glibContext,
"Game Over",
0,
GLIB_ALIGN_LEFT,
1,
1,
true);
GLIB_setFont(&glibContext, (GLIB_Font_t *) &GLIB_FontNarrow6x8);
}
// print score
char score_str[sizeof(uint32_t)*8+1];
sprintf(score_str, "%d", (int)score);
GLIB_drawStringOnLine(&glibContext,
score_str,
0,
GLIB_ALIGN_RIGHT,
-1,
```
<Overlap Ratio: 0.896551724137931>

---

--- 47 --
Question ID: 851d46b398c475265ed2f5dd288fe0b5efeedada_12
Original Code:
```
static int wifi_debug(int argc, char *argv[])
{
    int i;
    int result = 0;
    
    const struct wifi_cmd_des *run_cmd = OS_NULL;

    if (argc < 3)
    {
        wifi_debug_help(0, OS_NULL);
        return 0;
    }

    for (i = 0; i < sizeof(debug_tab) / sizeof(debug_tab[0]); i++)
    {
        if (strcmp(debug_tab[i].cmd, argv[2]) == 0)
        {
            run_cmd = &debug_tab[i];
            break;
        }
    }

    if (run_cmd == OS_NULL)
    {
        wifi_debug_help(0, OS_NULL);
        return 0;
    }

    if (run_cmd->fun != OS_NULL)
    {
        result = run_cmd->fun(argc - 2, &argv[2]);
    }

    if (result)
    {
        wifi_debug_help(argc - 2, &argv[2]);
    }
    return 0;
}
```


Overlapping Code:
```
(int argc, char *argv[])
{
int i;
int result = 0;

const struct wifi_cmd_des *run_cmd = OS_NULL;
if (argc < 3)
{
wifi_debug_help(0, OS_NULL);
return 0;
}
for (i = 0; i < sizeof(debug_tab) / sizeof(debug_tab[0]); i++)
{
if (strcmp(debug_tab[i].cmd, argv[2]) == 0)
{
run_cmd = &debug_tab[i];
break;
}
}
if (run_cmd == OS_NULL)
{
wifi_debug_help(0, OS_NULL);
return 0;
}
if (run_cmd->fun != OS_NULL)
{
result = run_cmd->fun(argc - 2, &argv[2]);
}
if (result)
{
wifi_debug_help(argc - 2, &argv[2]);
}
ret
```
<Overlap Ratio: 0.945179584120983>

---

--- 48 --
Question ID: 85c4eba59d334db6c43fdcdcb31f9549ad99734f_1
Original Code:
```
static inline void gpio_set_interrupt_risc1(GPIO_PinTypeDef pin, GPIO_PolTypeDef falling)
{
	unsigned char	bit = pin & 0xff;
	BM_SET(reg_gpio_irq_risc1_en(pin), bit);
	reg_irq_mask |= FLD_IRQ_GPIO_RISC1_EN;
	if(falling){
		BM_SET(reg_gpio_pol(pin), bit);
	}else{
		BM_CLR(reg_gpio_pol(pin), bit);
	}
}
```


Overlapping Code:
```
c inline void gpio_set_interrupt_risc1(GPIO_PinTypeDef pin, GPIO_PolTypeDef falling)
{
unsigned char bit = pin & 0xff;
BM_SET(reg_gpio_irq_risc1_en(pin), bit);
reg_irq_mask |= FLD_IRQ_GPIO_RISC1_EN;
if(falling){
BM_SET(reg_gpio_pol(pin), bit);
}else{
BM_CLR(reg_gpio_pol(pin), bit);
}

```
<Overlap Ratio: 0.979381443298969>

---

--- 49 --
Question ID: b5dc6d7c6b2d3d183735f59b13c1de25071b8eea_731
Original Code:
```
int snd_ctl_elem_tlv_write(snd_ctl_t * ctl, const snd_ctl_elem_id_t * id, const unsigned int * tlv) {
    snd_ctl_elem_tlv_write_INDEXED packed_data;
    packed_data.func = snd_ctl_elem_tlv_write_INDEX;
    packed_data.args.a1 = (snd_ctl_t *)ctl;
    packed_data.args.a2 = (snd_ctl_elem_id_t *)id;
    packed_data.args.a3 = (unsigned int *)tlv;
    int ret;
    syscall(SYS_proxy, (void *)&packed_data, &ret);
    return ret;
}
```


Overlapping Code:
```
t * ctl, const snd_ctl_elem_id_t * id, const unsigned int * tlv) {
snd_ctl_elem_tlv_write_INDEXED packed_data;
packed_data.func = snd_ctl_elem_tlv_write_INDEX;
packed_data.args.a1 = (snd_ctl_t *)ctl;
packed_data.args.a2 = (snd_ctl_elem_id_t *)id;
packed_data.args.a3 = (unsigned int *)tlv;
int ret;
syscall(SYS_proxy, (void *)&packed_data, &ret);
return ret;
}
```
<Overlap Ratio: 0.9113924050632911>

---

--- 50 --
Question ID: 38f25cb921dc154a1aebdafa0c46a15e9c7f95ff_0
Original Code:
```
namespace nasoq {
#ifdef CHOLROWMOD
#include "cholmod_utils.h"
 //using namespace nasoq_cholmod;
#endif

/*
 * Class for passing setting to a QP solver. It is a superset of all
 * important input parameters of a QP solver.
 */
 struct QPSettings {
  double eps; // one threshold for all
  double eps_primal, eps_dual, eps_slack, eps_nn; // If thresholds are requested per KKT conditions
  double diag_perturb;
  int batch_size;
  double eps_rel;
  int scaling;
  double zero_thresh;
  int inner_iter_ref;
  int outer_iter_ref;
  int max_iter;
  double stop_tol;
  int max_iter_nas;
  std::string nasoq_variant;

  QPSettings();
 };

 enum nasoq_mode {
  Fixed = 0, AUTO, Tuned, PREDET
 };
 enum nasoq_status {
  Optimal = 1, Inaccurate = 2, NotConverged = 3, Infeasible=0, NotFinished=4
 };

 struct nasoq_config {
  int inner_iter, outer_iter;
  double pert_diag, stop_tol;

  nasoq_config(int a, int b, double c, double d);;
 };

/*
* min 0.5*xHx + qx s.t. Ax=a and Bx≤b
*/
 struct Nasoq {
  std::string sol_name;
  int hessian_size, eq_const_size, ineq_const_size;
  CSC *H, *HT, *A, *AT, *B, *BT;

  double *q, *a, *b;
  int n_active;
  double diag_perturb, zero_thresh, eps_abs, eps_rel;
  double primal_obj, dual_obj, objective;
  double non_negativity_infn, complementarity_infn;
  int inner_iter_ref, outer_iter_ref, max_iter;
  double stop_tol;

/// Symbolic info
  int *eTree; //skkt_size
  int *col2const, *const2col;
  int *used_const;

/// Super KKT
  CSC *sKKT, *sKKTt;
  double *sKKTrhs;
  int *etree;
  int *pinv;
  int *col2sup;
  size_t skkt_col;

  int scaling;
  double *D, *E, *F, *Dinv, *Einv, *Finv;
  double c, cinv;

  double *rec_length;

  double *dual_vars, *dual_vars_eq; //size of ineq_const_size
  double *primal_vars;
//double *x0; // Initial solution, warm-start
  double *kkt_solution, *lagrange_mult, *lagrange_mult_eq, *descent;
  std::vector<int> active_set;
  int *as0;// Initial active set, warm-start
  int is_converged; // 0/1
  int num_iter, max_iter_nas;
  int used_constraints, num_active; //
  int auto_reg_en;
  int warm_start;
  int batch_size;
  double *workspace;
  double qp_scalar, inv_qp_scalar;
  nasoq_mode variant;
  nasoq_status ret_val;
  SolverSettings *ss;

/// Profiling
  qp_info *qi;
  double *dual_FB_a, *dual_FB_b, *dual_FB;
  double *primal_FB_a, *primal_FB_b, *primal_FB;
  double lag_res, cons_sat_norm;

#ifdef CHOLROWMOD
  cholmod_factor *L ;
  cholmod_sparse *kkt;
  CSC *kkt_updated;
  cholmod_common Common, *cm;
  size_t k_size;
#endif

  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,
        size_t B_row, size_t B_col, int *Bp, int *Bi,
        double *Bx, double *b_ineq);

  Nasoq(size_t H_size, int *Hp, int *Hi, double *Hx, double *q_in,
        size_t A_size1, size_t A_size2, int *Ap, int *Ai, double *Ax,
        double *a_eq,
        size_t B_size1, size_t B_size2, int *Bp, int *Bi, double *Bx,
        double *b_ineq);

  ~Nasoq();

/*
* Setting default setting for QP
*/
  void default_setting();

#ifdef CHOLROWMOD
  int symbolic_QP_cholmod(){
   int status =  0;
   transpose_unsym(B->nrow,B->ncol,B->p,B->i,B->x,
                   BT->nrow,BT->ncol,BT->p,BT->i,BT->x);
   BT->nzmax=B->nzmax;
   //print_csc("BT:\n",BT->ncol,BT->p,BT->i,BT->x);
   //build_super_kkt();
   //Creates a new solver instance
   if(A->nrow>0){
    transpose_unsym(A->nrow,A->ncol,A->p,A->i,A->x,
                    AT->nrow,AT->ncol,AT->p,AT->i,AT->x);
    AT->nzmax=A->nzmax;
   }

   /*ss->ldl_variant =4;
   ss->ldl_update_variant=2;
   ss->solver_mode = 1;
   ss->req_ref_iter=outer_iter_ref;
   if(outer_iter_ref>0 && inner_iter_ref ==0){
    ss->max_inner_iter = 1; // will be wrong if it is zero
   }else{
    ss->max_inner_iter = inner_iter_ref;
   }*/

   size_t total_nnz = H->nzmax + B->nzmax;
   double min_v,max_v;
   //max_min_spmat(H->ncol, H->p, H->i, H->x,max_v,min_v);
   //setting perturbation
   if(auto_reg_en==2){
    double H_norm2 = norm_sparse_int(H->ncol, H->p, H->i, H->x, -1, 2);
    auto_perturbation2(H->ncol, total_nnz,H_norm2, max_v-min_v,
                       B->nrow, B->nrow/double(H->ncol), eps_abs,
                       diag_perturb,
                       outer_iter_ref,inner_iter_ref,stop_tol);
   } else if(auto_reg_en==1){
    determine_iterations(total_nnz, eps_abs,outer_iter_ref,inner_iter_ref);
    stop_tol = 1e-15;
   }
    diag_perturb = pow(10, -6);
   /*ss->tol_abs = ss->tol_rel = stop_tol;
   ss->req_ref_iter = outer_iter_ref ;
   ss->max_inner_iter = inner_iter_ref ;
   ss->diag_perturb=diag_perturb;*/
   zero_thresh = diag_perturb;
   //status = analyze_kkt();
   //ss->symbolic_analysis();
   k_size = H->ncol + B->nrow + A->nrow;
   skkt_col = k_size;
   sKKTrhs = new double[k_size]();
   kkt_solution = new double[k_size]();
   //diag_perturb = pow(10, -6);

   descent = kkt_solution;
   lagrange_mult_eq = kkt_solution + H->ncol;
   lagrange_mult = kkt_solution + H->ncol + A->nrow;
   //sKKT = ss->A_ord;

   return status;
  }
```


Overlapping Code:
```
 nasoq {
#ifdef CHOLROWMOD
#include "cholmod_utils.h"
//using namespace nasoq_cholmod;
#endif
/*
* Class for passing setting to a QP solver. It is a superset of all
* important input parameters of a QP solver.
*/
struct QPSettings {
double eps; // one threshold for all
double eps_primal, eps_dual, eps_slack, eps_nn; // If thresholds are requested per KKT conditions
double diag_perturb;
int batch_size;
double eps_rel;
int scaling;
double zero_thresh;
int inner_iter_ref;
int outer_iter_ref;
int max_iter;
double stop_tol;
int max_iter_nas;
std::string nasoq_variant;
QPSettings();
};
enum nasoq_mode {
Fixed = 0, AUTO, Tuned, PREDET
};
enum nasoq_status {
Optimal = 1, Inaccurate = 2, NotConverged = 3, Infeasible=0, NotFinished=4
};
struct nasoq_config {
int inner_iter, outer_iter;
double pert_diag, stop_tol;
nasoq_config(int a, int b, double c, double d);;
};
/*
* min 0.5*xHx + qx s.t. Ax=a and Bx≤b
*/
struct Nasoq {
std::string sol_name;
int hessian_size, eq_const_size, ineq_const_size;
CSC *H, *HT, *A, *AT, *B, *BT;
double *q, *a, *b;
int n_active;
double diag_perturb, zero_thresh, eps_abs, eps_rel;
double primal_obj, dual_obj, objective;
double non_negativity_infn, complementarity_infn;
int inner_iter_ref, outer_iter_ref, max_iter;
double stop_tol;
/// Symbolic info
int *eTree; //skkt_size
int *col2const, *const2col;
int *used_const;
/// Super KKT
CSC *sKKT, *sKKTt;
double *sKKTrhs;
int *etree;
int *pinv;
int *col2sup;
size_t skkt_col;
int scaling;
double *D, *E, *F, *Dinv, *Einv, *Finv;
double c, cinv;
double *rec_length;
double *dual_vars, *dual_vars_eq; //size of ineq_const_size
double *primal_vars;
//double *x0; // Initial solution, warm-start
double *kkt_solution, *lagrange_mult, *lagrange_mult_eq, *descent;
std::vector<int> active_set;
int *as0;// Initial active set, warm-start
int is_converged; // 0/1
int num_iter, max_iter_nas;
int used_constraints, num_active; //
int auto_reg_en;
int warm_start;
int batch_size;
double *workspace;
double qp_scalar, inv_qp_scalar;
nasoq_mode variant;
nasoq_status ret_val;
SolverSettings *ss;
/// Profiling
qp_info *qi;
double *dual_FB_a, *dual_FB_b, *dual_FB;
double *primal_FB_a, *primal_FB_b, *primal_FB;
double lag_res, cons_sat_norm;
#ifdef CHOLROWMOD
cholmod_factor *L ;
cholmod_sparse *kkt;
CSC *kkt_updated;
cholmod_common Common, *cm;
s
```
<Overlap Ratio: 0.9914456800684346>

---

--- 51 --
Question ID: c4cd0dcf37267cf27fd75ed3c543bf88c6333110_1
Original Code:
```
void gdb_service_start(void)
{
    struct netconn *gdb_netconn;
    err_t err;

	gdb_netconn = netconn_new(NETCONN_TCP);
    if (!gdb_netconn)
    {
        return;
    }

	err = netconn_bind(gdb_netconn, IP_ADDR_ANY, 3333);
    if (err != ERR_OK)
    {
        netconn_delete(gdb_netconn);
        return;
    }

	err = netconn_listen(gdb_netconn);
    if (err != ERR_OK)
    {
        netconn_delete(gdb_netconn);
        return;
    }

    thread_new(&gdb_thread, gdb_stack, sizeof(gdb_stack), gdb_mainloop, gdb_netconn);
}
```


Overlapping Code:
```
{
struct netconn *gdb_netconn;
err_t err;
gdb_netconn = netconn_new(NETCONN_TCP);
if (!gdb_netconn)
{
return;
}
err = netconn_bind(gdb_netconn, IP_ADDR_ANY, 3333);
if (err != ERR_OK)
{
netconn_delete(gdb_netconn);
return;
}
err = netconn_listen(gdb_netconn);
if (err != ERR_OK)
{
netconn_delete(gdb_netconn);
return;
}
thread_new(&gdb_thread, gdb_stack, sizeof(gdb_stack), gdb_mainloop, gdb_netconn);
```
<Overlap Ratio: 0.9280742459396751>

---

--- 52 --
Question ID: 36ded5c10d2c79af3592d043fc53d34a4f7728f7_9
Original Code:
```
static void init_pointdensityrangedata(PointDensity *pd, PointDensityRangeData *pdr, 
	float *density, float *vec, float *age, struct CurveMapping *density_curve, float velscale)
{
	pdr->squared_radius = pd->radius*pd->radius;
	pdr->density = density;
	pdr->point_data = pd->point_data;
	pdr->falloff_type = pd->falloff_type;
	pdr->vec = vec;
	pdr->age = age;
	pdr->softness = pd->falloff_softness;
	pdr->noise_influence = pd->noise_influence;
	pdr->point_data_used = point_data_used(pd);
	pdr->offset = (pdr->point_data_used & POINT_DATA_VEL)?pd->totpoints*3:0;
	pdr->density_curve = density_curve;
	pdr->velscale = velscale;
}
```


Overlapping Code:
```
static void init_pointdensityrangedata(PointDensity *pd, PointDensityRangeData *pdr, 
float *density, float *vec, float *age, struct CurveMapping *density_curve, float velscale)
{
pdr->squared_radius = pd->radius*pd->radius;
pdr->density = density;
pdr->point_data = pd->point_data;
pdr->falloff_type = pd->falloff_type;
pdr->vec = vec;
pdr->age = age;
pdr->softness = pd->falloff_softness;
pdr->noise_influence = pd->noise_influence;
pdr->point_data_used = point_data_used(pd);
pdr->offset = (pdr->point_data_used & POINT_DATA_VEL)?pd->totpoints*3:0;
pdr->density_curve = density_curve;
pdr->velscale
```
<Overlap Ratio: 0.9772357723577236>

---

--- 53 --
Question ID: 7fa60f5b7ae408b39461107954d561bc303926af_8
Original Code:
```
static void pio_irq_enable(struct pxa_ep *ep)
{
	struct pxa_udc *udc = ep->dev;
	int index = EPIDX(ep);
	u32 udcicr0 = udc_readl(udc, UDCICR0);
	u32 udcicr1 = udc_readl(udc, UDCICR1);

	if (index < 16)
		udc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));
	else
		udc_writel(udc, UDCICR1, udcicr1 | (3 << ((index - 16) * 2)));
}
```


Overlapping Code:
```
able(struct pxa_ep *ep)
{
struct pxa_udc *udc = ep->dev;
int index = EPIDX(ep);
u32 udcicr0 = udc_readl(udc, UDCICR0);
u32 udcicr1 = udc_readl(udc, UDCICR1);
if (index < 16)
udc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));
else
udc_writel(udc, UDCICR1, u
```
<Overlap Ratio: 0.8130841121495327>

---

--- 54 --
Question ID: 30ed51a11ec34df78071e32e67190ad3ef5cc7e9_27
Original Code:
```
static struct str
sys_x11_clipboard_get(struct arena *a) {
  struct str ret;
  ret = arena_str(a, &sys, str(x11.clip.data, x11.clip.len));
  return ret;
}
```


Overlapping Code:
```
pboard_get(struct arena *a) {
struct str ret;
ret = arena_str(a, &sys, str(x11.clip.data, x11.clip.l
```
<Overlap Ratio: 0.6756756756756757>

---

--- 55 --
Question ID: ec82bf3c4ff97d82840d7b524e4004229fe2935d_42
Original Code:
```
static void blackenFn(WrenVM* vm, ObjFn* fn)
{
  // Mark the constants.
  wrenGrayBuffer(vm, &fn->constants);

  // Keep track of how much memory is still in use.
  vm->bytesAllocated += sizeof(ObjFn);
  vm->bytesAllocated += sizeof(uint8_t) * fn->code.capacity;
  vm->bytesAllocated += sizeof(Value) * fn->constants.capacity;
  
  // The debug line number buffer.
  vm->bytesAllocated += sizeof(int) * fn->code.capacity;
  // TODO: What about the function name?
}
```


Overlapping Code:
```
)
{
// Mark the constants.
wrenGrayBuffer(vm, &fn->constants);
// Keep track of how much memory is still in use.
vm->bytesAllocated += sizeof(ObjFn);
vm->bytesAllocated += sizeof(uint8_t) * fn->code.capacity;
vm->bytesAllocated += sizeof(Value) * fn->constants.capacity;

// The debug line number buffer.
vm->bytesAllocated += sizeof(int) * fn->code.capacity;
// TODO: What about the function name?
}
```
<Overlap Ratio: 0.9029345372460497>

---

--- 56 --
Question ID: 9e1142b8b91b4b5b71197115a20260e92844aa08_15
Original Code:
```
static int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)
{
	struct usb_ss_cap_descriptor *ss;

	ss = (struct usb_ss_cap_descriptor *) buf;

	if (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {
		ERROR(tdev, "bogus superspeed device capability descriptor length\n");
		return 0;
	}

	/*
	 * only bit[1] of bmAttributes is used for LTM and others are
	 * reserved
	 */
	if (ss->bmAttributes & ~0x02) {	/* reserved == 0 */
		ERROR(tdev, "reserved bits set in bmAttributes\n");
		return 0;
	}

	/* bits[0:3] of wSpeedSupported is used and others are reserved */
	if (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {	/* reserved == 0 */
		ERROR(tdev, "reserved bits set in wSpeedSupported\n");
		return 0;
	}

	return 1;
}
```


Overlapping Code:
```
tic int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)
{
struct usb_ss_cap_descriptor *ss;
ss = (struct usb_ss_cap_descriptor *) buf;
if (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {
ERROR(tdev, "bogus superspeed device capability descriptor length\n");
return 0;
}
/*
* only bit[1] of bmAttributes is used for LTM and others are
* reserved
*/
if (ss->bmAttributes & ~0x02) { /* reserved == 0 */
ERROR(tdev, "reserved bits set in bmAttributes\n");
return 0;
}
/* bits[0:3] of wSpeedSupported is used and others are reserved */
if (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) { /* reserved == 0 */
ERROR(tdev, "reserved bits set in wSpeedSupported\n");
r
```
<Overlap Ratio: 0.9629629629629629>

---

--- 57 --
Question ID: 05a5eedb8f3bf62ab891fb060945ca66f61499d1_1
Original Code:
```
uint64_t rdtsc() {
  uint64_t a, d;
  asm volatile("mfence");
#if USE_RDTSCP
  asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
#else
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
#endif
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
}
```


Overlapping Code:
```
4_t rdtsc() {
uint64_t a, d;
asm volatile("mfence");
#if USE_RDTSCP
asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
#else
asm volatile("rdtsc" : "=a"(a), "=d"(d));
#endif
a = (d << 32) | a;
asm volatile("mfence");
return a;
}
```
<Overlap Ratio: 0.9786324786324786>

---

--- 58 --
Question ID: 0d0f85874c1b37365ef46b5fcddd947e08fbd818_10
Original Code:
```
void pbox_dec2on(shape *dshape)		
{
  dec2power(dshape->pwr);
  if (dshape->pwrf) dec2pwrf(dshape->pwrf);
#ifndef NVPSG
  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); 
  dec2on();
#else
  dec2on();
  dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); 
#endif
}
```


Overlapping Code:
```
ox_dec2on(shape *dshape) 
{
dec2power(dshape->pwr);
if (dshape->pwrf) dec2pwrf(dshape->pwrf);
#ifndef NVPSG
dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); 
dec2on();
#else
dec2on();
dec2prgon(dshape->name, 1.0/dshape->dmf, dshape->dres); 
#e
```
<Overlap Ratio: 0.9505703422053232>

---

--- 59 --
Question ID: 36ff9541c518337e461f309f9ed9269e7c3801ef_0
Original Code:
```
int
main(int argc, const char **argv) {
  int i, ret;
  const char *me;
  char *argv0 = NULL, *err;
  hestParm *hparm;
  airArray *mop;

  me = argv[0];
  /* no harm done in making sure we're sane */
  if (!nrrdSanity()) {
    fprintf(stderr, "******************************************\n");
    fprintf(stderr, "******************************************\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "  %s: nrrd sanity check FAILED.\n", me);
    fprintf(stderr, "\n");
    fprintf(stderr, "  This means that either nrrd can't work on this "
            "platform, or (more likely)\n");
    fprintf(stderr, "  there was an error in the compilation options "
            "and variable definitions\n");
    fprintf(stderr, "  for Teem.\n");
    fprintf(stderr, "\n");
    fprintf(stderr, "  %s\n", err = biffGetDone(NRRD));
    fprintf(stderr, "\n");
    fprintf(stderr, "******************************************\n");
    fprintf(stderr, "******************************************\n");
    free(err);
    return 1;
  }

  mop = airMopNew();
  hparm = hestParmNew();
  airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
  hparm->elideSingleEnumType = AIR_TRUE;
  hparm->elideSingleOtherType = AIR_TRUE;
  hparm->elideSingleOtherDefault = AIR_FALSE;
  hparm->elideSingleNonExistFloatDefault = AIR_TRUE;
  hparm->elideMultipleNonExistFloatDefault = AIR_TRUE;
  hparm->elideSingleEmptyStringDefault = AIR_TRUE;
  hparm->elideMultipleEmptyStringDefault = AIR_TRUE;
  hparm->cleverPluralizeOtherY = AIR_TRUE;
  hparm->columns = 78;

  /* if there are no arguments, then we give general usage information */
  if (1 >= argc) {
    baneGkmsUsage(GKMS, hparm);
    airMopError(mop);
    exit(1);
  }
  /* else, we should see if they're asking for a command we know about */  
  /* baneGkmsCmdList[] is NULL-terminated */
  for (i=0; baneGkmsCmdList[i]; i++) {
    if (!strcmp(argv[1], baneGkmsCmdList[i]->name))
      break;
  }
  if (baneGkmsCmdList[i]) {
    /* yes, we have that command */
    /* initialize variables used by the various commands */
    argv0 = AIR_CAST(char*, malloc(strlen(GKMS) + strlen(argv[1]) + 2));
    airMopMem(mop, &argv0, airMopAlways);
    sprintf(argv0, "%s %s", GKMS, argv[1]);

    /* run the individual unu program, saving its exit status */
    ret = baneGkmsCmdList[i]->main(argc-2, argv+2, argv0, hparm);
    if (1 == ret) {
      airMopAdd(mop, err=biffGetDone(BANE), airFree, airMopAlways);
      fprintf(stderr, "%s: error:\n%s", argv0, err);
    } else if (2 == ret) {
      /* gkms command has already handled printing error messages */
      ret = 1;
    }
  } else {
    fprintf(stderr, "%s: unrecognized command: \"%s\"; type \"%s\" for "
            "complete list\n", me, argv[1], me);
    ret = 1;
  }

  airMopDone(mop, ret);
  return ret;
}
```


Overlapping Code:
```

int i, ret;
const char *me;
char *argv0 = NULL, *err;
hestParm *hparm;
airArray *mop;
me = argv[0];
/* no harm done in making sure we're sane */
if (!nrrdSanity()) {
fprintf(stderr, "******************************************\n");
fprintf(stderr, "******************************************\n");
fprintf(stderr, "\n");
fprintf(stderr, " %s: nrrd sanity check FAILED.\n", me);
fprintf(stderr, "\n");
fprintf(stderr, " This means that either nrrd can't work on this "
"platform, or (more likely)\n");
fprintf(stderr, " there was an error in the compilation options "
"and variable definitions\n");
fprintf(stderr, " for Teem.\n");
fprintf(stderr, "\n");
fprintf(stderr, " %s\n", err = biffGetDone(NRRD));
fprintf(stderr, "\n");
fprintf(stderr, "******************************************\n");
fprintf(stderr, "******************************************\n");
free(err);
return 1;
}
mop = airMopNew();
hparm = hestParmNew();
airMopAdd(mop, hparm, (airMopper)hestParmFree, airMopAlways);
hparm->elideSingleEnumType = AIR_TRUE;
hparm->elideSingleOtherType = AIR_TRUE;
hparm->elideSingleOtherDefault = AIR_FALSE;
hparm->elideSingleNonExistFloatDefault = AIR_TRUE;
hparm->elideMultipleNonExistFloatDefault = AIR_TRUE;
hparm->elideSingleEmptyStringDefault = AIR_TRUE;
hparm->elideMultipleEmptyStringDefault = AIR_TRUE;
hparm->cleverPluralizeOtherY = AIR_TRUE;
hparm->columns = 78;
/* if there are no arguments, then we give general usage information */
if (1 >= argc) {
baneGkmsUsage(GKMS, hparm);
airMopError(mop);
exit(1);
}
/* else, we should see if they're asking for a command we know about */ 
/* baneGkmsCmdList[] is NULL-terminated */
for (i=0; baneGkmsCmdList[i]; i++) {
if (!strcmp(argv[1], baneGkmsCmdList[i]->name))
break;
}
if (baneGkmsCmdList[i]) {
/* yes, we have that command */
/* initialize variables used by the various commands */
argv0 = AIR_CAST(char*, malloc(strlen(GKMS) + strlen(argv[1]) + 2));
airMopMem(mop, &argv0, airMopAlways);
sprintf(argv0, "%s %s", GKMS, argv[1]);
/* run the individual unu program, saving its exit status */
ret = baneGkmsCmdList[i]->main(argc-2, argv+2, argv0, hparm);
if (1 == ret) {
airMopAdd(mop, err=biffGetDone(BANE), airFree, airMopAlways);
fprintf(stderr, "%s: error
```
<Overlap Ratio: 0.9740773286467487>

---

--- 60 --
Question ID: 04df6a01db950a2bbb8dff70c3d952f6f33473ed_10
Original Code:
```
static void brcm_stingray_hsls_tzpcprot_init(void)
{
	unsigned int val;
	uintptr_t tzpcdecprot_base = HSLS_TZPC_BASE;

	VERBOSE("hsls tzpcprot init start\n");

	/* Treat third-party masters as non-secured */
	val = 0;
	val |= BIT(6); /* SDIO1 */
	val |= BIT(5); /* SDIO0 */
	val |= BIT(0); /* AMAC */
	mmio_write_32(tzpcdecprot_base + 0x810, val);

	/* Print TZPC decode status registers */
	VERBOSE(" - tzpcdecprot0=0x%x\n",
		mmio_read_32(tzpcdecprot_base + 0x800));

	VERBOSE(" - tzpcdecprot1=0x%x\n",
		mmio_read_32(tzpcdecprot_base + 0x80c));

	INFO("hsls tzpcprot init done\n");
}
```


Overlapping Code:
```
void brcm_stingray_hsls_tzpcprot_init(void)
{
unsigned int val;
uintptr_t tzpcdecprot_base = HSLS_TZPC_BASE;
VERBOSE("hsls tzpcprot init start\n");
/* Treat third-party masters as non-secured */
val = 0;
val |= BIT(6); /* SDIO1 */
val |= BIT(5); /* SDIO0 */
val |= BIT(0); /* AMAC */
mmio_write_32(tzpcdecprot_base + 0x810, val);
/* Print TZPC decode status registers */
VERBOSE(" - tzpcdecprot0=0x%x\n",
mmio_read_32(tzpcdecprot_base + 0x800));
VERBOSE(" - tzpcdecprot1=0x%x\n",
mmio_read_32(tzpcdecprot_base + 0x80c));
INFO("hsls tzpcprot init done
```
<Overlap Ratio: 0.975177304964539>

---

--- 61 --
Question ID: c83c621847d1d80daec3e33d101ef45040b91c89_2
Original Code:
```
inline void assign( DenseVector<VT,TF>& lhs, const Band& rhs )
   {
      using blaze::row;
      using blaze::column;

      BLAZE_FUNCTION_TRACE;

      BLAZE_INTERNAL_ASSERT( (~lhs).size() == rhs.size(), "Invalid vector sizes" );

      LT A( serial( rhs.operand().leftOperand()  ) );
      RT B( serial( rhs.operand().rightOperand() ) );

      const size_t n( rhs.size() );
      for( size_t i=0UL; i<n; ++i ) {
         (~lhs)[i] = row( A, rhs.row()+i, unchecked ) * column( B, rhs.column()+i, unchecked );
      }
   }
```


Overlapping Code:
```
ssign( DenseVector<VT,TF>& lhs, const Band& rhs )
{
using blaze::row;
using blaze::column;
BLAZE_FUNCTION_TRACE;
BLAZE_INTERNAL_ASSERT( (~lhs).size() == rhs.size(), "Invalid vector sizes" );
LT A( serial( rhs.operand().leftOperand() ) );
RT B( serial( rhs.operand().rightOperand() ) );
const size_t n( rhs.size() );
for( size_t i=0UL; i<n; ++i ) {
(~lhs)[i] = row( A, rhs.row()+i, unchecked ) * column( B, rhs.column()+i, unchecked );
}
}
```
<Overlap Ratio: 0.9711751662971175>

---

--- 62 --
Question ID: 977c8f9a07a2194322deada32da2afd0481d50ad_15
Original Code:
```
static int nmk_gpio_init_irq(struct nmk_gpio_chip *nmk_chip)
{
	unsigned int first_irq;
	int i;

	first_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);
	for (i = first_irq; i < first_irq + NMK_GPIO_PER_CHIP; i++) {
		set_irq_chip(i, &nmk_gpio_irq_chip);
		set_irq_handler(i, handle_edge_irq);
		set_irq_flags(i, IRQF_VALID);
		set_irq_chip_data(i, nmk_chip);
		set_irq_type(i, IRQ_TYPE_EDGE_FALLING);
	}
	set_irq_chained_handler(nmk_chip->parent_irq, nmk_gpio_irq_handler);
	set_irq_data(nmk_chip->parent_irq, nmk_chip);
	return 0;
}
```


Overlapping Code:
```
atic int nmk_gpio_init_irq(struct nmk_gpio_chip *nmk_chip)
{
unsigned int first_irq;
int i;
first_irq = NOMADIK_GPIO_TO_IRQ(nmk_chip->chip.base);
for (i = first_irq; i < first_irq + NMK_GPIO_PER_CHIP; i++) {
set_irq_chip(i, &nmk_gpio_irq_chip);
set_irq_handler(i, handle_edge_irq);
set_irq_flags(i, IRQF_VALID);
set_irq_chip_data(i, nmk_chip);
set_irq_type(i, IRQ_TYPE_EDGE_FALLING);
}
set_irq_chained_handler(nmk_chip->parent_irq, nmk_gpio_irq_handler);
set_irq_data(nmk_chip->parent_irq, nmk_chip);
return 0
```
<Overlap Ratio: 0.9902723735408561>

---

--- 63 --
Question ID: 56ad885762aec692d4e27f5426fde4dffabfd8f0_2
Original Code:
```
int vms_copy(char *vms1,char *vms2,COP_PARAM *cop_param)
{
    int     bFailIfExists   = FALSE;
    int     nError          = 0;
    char    dos1[MAX_TOKEN];
    char    dos2[MAX_TOKEN];
    char    vms0[MAX_TOKEN];
    char    directory1[_MAX_PATH];
    char    directory2[_MAX_PATH];
    char    drive1[_MAX_DRIVE];
    char    dir1[_MAX_DIR];
    char    file1[_MAX_FNAME];
    char    ext1[_MAX_EXT];
    char    drive2[_MAX_DRIVE];
    char    dir2[_MAX_DIR];
    char    file2[_MAX_FNAME];
    char    ext2[_MAX_EXT];
    size_t  i = 0;
    int    retcod = DCL_OK;

    *dos1 = 0; *drive1 = 0; *dir1 = 0; *file1 = 0; *ext1 =0; *directory1 = 0;
    *dos2 = 0; *drive2 = 0; *dir2 = 0; *file2 = 0; *ext2 =0; *directory2 = 0;

    cvfs_vms_to_dos(vms1,dos1,(int *)&i);
    _splitpath(dos1,drive1,dir1,file1,ext1);
    cvfs_vms_to_dos(vms2,dos2,(int *)&i);
    if (isdir(dos2) && dos2[strlen(dos2)-1] != SLASH_CHR)
            strcat(dos2,SLASH_STR);
    if (dos1[strlen(dos1)-1] == SLASH_CHR)
        dos1[strlen(dos1)-1] = '\0';
    if (!cvfs_check_device(dos2)) {
        _splitpath(dos2,drive2,dir2,file2,ext2);
        if (!*file2)
            strcpy(file2,file1);
        if (*file2 == '*')
            strcpy(file2,file1);
        if (!*ext2)
            strcpy(ext2,ext1);
        if (strncmp(ext2,".*",2)==0)
            strcpy(ext2,ext1);
        for (i = 0;i < strlen(file2); i++)
            if (file2[i] == '?') file2[i] = file1[i];
        for (i = 0;i < strlen(ext2); i++)
            if (ext2[i] == '?') ext2[i] = ext1[i];
        _makepath(dos2,drive2,dir2,file2,ext2);
        cvfs_dos_to_vms(dos2,vms2);

        if (cop_param->fnew) {
            if (filetstamp(dos1) <= filetstamp(dos2)) {
                goto exit_label;
            }
        }
    }

    _makepath(directory1,drive1,dir1,NULL,NULL);
    if (SUBDIR) {
        for(i = 1; i < strlen(dir1) && dir1[i] != SLASH_CHR; i++) ;
        if (dir1[i] == SLASH_CHR) i++;
        strcat(dir2, &dir1[i]);
        _makepath(dos2,drive2,dir2,file2,ext2);
    }
    _makepath(directory2,drive2,dir2,NULL,NULL);

    bFailIfExists = cop_param->replace ? FALSE : TRUE;
    
    (void)_mkdir(directory2);
    if (*file2) {
        nError = filecopy(dos1, dos2, bFailIfExists);
    }
    
    if (nError) {
        (void)dcl_printf(dcl[D].SYS_OUTPUT,"%s: %s\n",vms1,strerror(errno));
        _STATUS = nError;
        _SEVERITY = 2;
        retcod = DCL_ERROR;
    }
    else {
        cop_param->file_copied++;
        if (cop_param->log) {
            cvfs_dos_to_vms(dos2,vms0);
            (void)dcl_printf(dcl[D].SYS_OUTPUT,"%s copied to %s.\n",vms1,vms0);
        }
    }

exit_label:
    return(retcod);
}
```


Overlapping Code:
```
nt vms_copy(char *vms1,char *vms2,COP_PARAM *cop_param)
{
int bFailIfExists = FALSE;
int nError = 0;
char dos1[MAX_TOKEN];
char dos2[MAX_TOKEN];
char vms0[MAX_TOKEN];
char directory1[_MAX_PATH];
char directory2[_MAX_PATH];
char drive1[_MAX_DRIVE];
char dir1[_MAX_DIR];
char file1[_MAX_FNAME];
char ext1[_MAX_EXT];
char drive2[_MAX_DRIVE];
char dir2[_MAX_DIR];
char file2[_MAX_FNAME];
char ext2[_MAX_EXT];
size_t i = 0;
int retcod = DCL_OK;
*dos1 = 0; *drive1 = 0; *dir1 = 0; *file1 = 0; *ext1 =0; *directory1 = 0;
*dos2 = 0; *drive2 = 0; *dir2 = 0; *file2 = 0; *ext2 =0; *directory2 = 0;
cvfs_vms_to_dos(vms1,dos1,(int *)&i);
_splitpath(dos1,drive1,dir1,file1,ext1);
cvfs_vms_to_dos(vms2,dos2,(int *)&i);
if (isdir(dos2) && dos2[strlen(dos2)-1] != SLASH_CHR)
strcat(dos2,SLASH_STR);
if (dos1[strlen(dos1)-1] == SLASH_CHR)
dos1[strlen(dos1)-1] = '\0';
if (!cvfs_check_device(dos2)) {
_splitpath(dos2,drive2,dir2,file2,ext2);
if (!*file2)
strcpy(file2,file1);
if (*file2 == '*')
strcpy(file2,file1);
if (!*ext2)
strcpy(ext2,ext1);
if (strncmp(ext2,".*",2)==0)
strcpy(ext2,ext1);
for (i = 0;i < strlen(file2); i++)
if (file2[i] == '?') file2[i] = file1[i];
for (i = 0;i < strlen(ext2); i++)
if (ext2[i] == '?') ext2[i] = ext1[i];
_makepath(dos2,drive2,dir2,file2,ext2);
cvfs_dos_to_vms(dos2,vms2);
if (cop_param->fnew) {
if (filetstamp(dos1) <= filetstamp(dos2)) {
goto exit_label;
}
}
}
_makepath(directory1,drive1,dir1,NULL,NULL);
if (SUBDIR) {
for(i = 1; i < strlen(dir1) && dir1[i] != SLASH_CHR; i++) ;
if (dir1[i] == SLASH_CHR) i++;
strcat(dir2, &dir1[i]);
_makepath(dos2,drive2,dir2,file2,ext2);
}
_makepath(directory2,drive2,dir2,NULL,NULL);
bFailIfExists = cop_param->replace ? FALSE : TRUE;

(void)_mkdir(directory2);
if (*file2) {
nError = filecopy(dos1, dos2, bFailIfExists);
}

if (nError) {
(void)dcl_printf(dcl[D].SYS_OUTPUT,"%s: %s\n",vms1,strerror(errno));
_STATUS = nError;
_SEVERITY = 
```
<Overlap Ratio: 0.9906152241918665>

---

--- 64 --
Question ID: 154551f22c3aeadf7002e3f870bece372aa67a80_13
Original Code:
```
void Sin_AddLump (int lumpnum, void *data, int len, int size, int maxsize)
{
	sin_lump_t *lump;
	int totallength;

	totallength = len*size;

	if (len > maxsize)
		Error ("Sin_WriteBSPFile: exceeded max size for lump %d size %d > maxsize %d\n", lumpnum, len, maxsize );

	lump = &sin_header->lumps[lumpnum];
	
	lump->fileofs = LittleLong( ftell(sin_wadfile) );
	lump->filelen = LittleLong(totallength);
	SafeWrite (sin_wadfile, data, (totallength+3)&~3);
}
```


Overlapping Code:
```
t len, int size, int maxsize)
{
sin_lump_t *lump;
int totallength;
totallength = len*size;
if (len > maxsize)
Error ("Sin_WriteBSPFile: exceeded max size for lump %d size %d > maxsize %d\n", lumpnum, len, maxsize );
lump = &sin_header->lumps[lumpnum];

lump->fileofs = LittleLong( ftell(sin_wadfile) );
lump->filelen = LittleLong(totallength);
SafeWr
```
<Overlap Ratio: 0.7936507936507936>

---

--- 65 --
Question ID: 83431b559034ba5c869ca57192d94aba0a4c3c40_13
Original Code:
```
static xrt_result_t
multi_compositor_layer_begin(struct xrt_compositor *xc,
                             int64_t frame_id,
                             uint64_t display_time_ns,
                             enum xrt_blend_mode env_blend_mode)
{
	struct multi_compositor *mc = multi_compositor(xc);

	assert(mc->progress.num_layers == 0);
	U_ZERO(&mc->progress);

	mc->progress.active = true;
	mc->progress.display_time_ns = display_time_ns;
	mc->progress.env_blend_mode = env_blend_mode;

	return XRT_SUCCESS;
}
```


Overlapping Code:
```
_result_t
multi_compositor_layer_begin(struct xrt_compositor *xc,
int64_t frame_id,
uint64_t display_time_ns,
enum xrt_blend_mode env_blend_mode)
{
struct multi_compositor *mc = multi_compositor(xc);
assert(mc->progress.num_layers == 0);
U_ZERO(&mc->progress);
mc->progress.active = true;
mc->progress.display_time_ns = display_time_ns;
mc->progress.env_blend_mode = env_blend_mode;
return XRT_SUCCESS;
}
```
<Overlap Ratio: 0.9758454106280193>

---

--- 66 --
Question ID: 67a5f779f37878094cd05174d16f4de26f743551_0
Original Code:
```
class CoolDownManager : public cocos2d::Ref
{
public:
	CoolDownManager();
	~CoolDownManager();

	void coolDown(Button* target, float cd, const  std::function<void()>& callback = nullptr);

	void pause();
	void resume();	

	// don't call this function manually.
	void update(float dt);

	void cleanup(void);

	bool hasTheBtn( Button* btn);
private:

	cocos2d::Scheduler* scheduler;

	cocos2d::Vector<Button*> waitings;

	std::map<Button*, std::function<void()> > callFun;
}
```


Overlapping Code:
```
cos2d::Ref
{
public:
CoolDownManager();
~CoolDownManager();
void coolDown(Button* target, float cd, const std::function<void()>& callback = nullptr);
void pause();
void resume(); 
// don't call this function manually.
void update(float dt);
void cleanup(void);
bool hasTheBtn( Button* btn);
private:
cocos2d::Scheduler* scheduler;
cocos2d::Vector<Button*> waitings;
std::map<Button*, std::function<vo
```
<Overlap Ratio: 0.8869179600886918>

---

--- 67 --
Question ID: e937223d5d2cbc4ef41129d413aeb4c27d55fdf7_0
Original Code:
```
void board_spifi_initialize(void)
{
  irqstate_t flags = enter_critical_section();
  uint32_t regval;

  flags = enter_critical_section();

  /* Initial frequency is set by boot ROM in IDIVE */

  /* Pin configuration */

  lpc43_pin_config(PINCONF_SPIFI_CS);
  lpc43_pin_config(PINCONF_SPIFI_MISO);
  lpc43_pin_config(PINCONF_SPIFI_MOSI);
  lpc43_pin_config(PINCONF_SPIFI_SCK);
  lpc43_pin_config(PINCONF_SPIFI_SIO2);
  lpc43_pin_config(PINCONF_SPIFI_SIO3);

  /* Initialize LPCSPIFILIB library, reset the interface */

  spifiInit(LPC43_SPIFI_CTRL, true);

  /* Register the family for the device */

  spifiRegisterFamily(spifi_REG_FAMILY_CommonCommandSet);

  /* Initialize and detect a device and get device context */

  SPIFI_HANDLE_T *pSpifi = spifiInitDevice(&lmem, sizeof(lmem),
                                           LPC43_SPIFI_CTRL,
                                           LPC43_LOCSRAM_SPIFI_BASE);

  /* Enable quad.  If not supported it will be ignored */

  spifiDevSetOpts(pSpifi, SPIFI_OPT_USE_QUAD, true);

  /* Enter memMode */

  spifiDevSetMemMode(pSpifi, true);

  /* Configure divider as the input to the SPIFI */

  regval  = getreg32(LPC43_BASE_SPIFI_CLK);
  regval &= ~BASE_SPIFI_CLK_CLKSEL_MASK;
  regval |= BASE_SPIFI_CLKSEL_IDIVE;
  putreg32(regval, LPC43_BASE_SPIFI_CLK);

  regval  = getreg32(LPC43_IDIVE_CTRL);
  regval &= ~(IDIVE_CTRL_CLKSEL_MASK | IDIVE_CTRL_IDIV_MASK);
  regval |= BASE_SPIFI_CLKSEL_PLL1 | IDIVE_CTRL_AUTOBLOCK |
            IDIVE_CTRL_IDIV(SPIFI_DEVICE_REQUENCY_DIVIDER);
  putreg32(regval, LPC43_IDIVE_CTRL);

  leave_critical_section(flags);
}
```


Overlapping Code:
```
ard_spifi_initialize(void)
{
irqstate_t flags = enter_critical_section();
uint32_t regval;
flags = enter_critical_section();
/* Initial frequency is set by boot ROM in IDIVE */
/* Pin configuration */
lpc43_pin_config(PINCONF_SPIFI_CS);
lpc43_pin_config(PINCONF_SPIFI_MISO);
lpc43_pin_config(PINCONF_SPIFI_MOSI);
lpc43_pin_config(PINCONF_SPIFI_SCK);
lpc43_pin_config(PINCONF_SPIFI_SIO2);
lpc43_pin_config(PINCONF_SPIFI_SIO3);
/* Initialize LPCSPIFILIB library, reset the interface */
spifiInit(LPC43_SPIFI_CTRL, true);
/* Register the family for the device */
spifiRegisterFamily(spifi_REG_FAMILY_CommonCommandSet);
/* Initialize and detect a device and get device context */
SPIFI_HANDLE_T *pSpifi = spifiInitDevice(&lmem, sizeof(lmem),
LPC43_SPIFI_CTRL,
LPC43_LOCSRAM_SPIFI_BASE);
/* Enable quad. If not supported it will be ignored */
spifiDevSetOpts(pSpifi, SPIFI_OPT_USE_QUAD, true);
/* Enter memMode */
spifiDevSetMemMode(pSpifi, true);
/* Configure divider as the input to the SPIFI */
regval = getreg32(LPC43_BASE_SPIFI_CLK);
regval &= ~BASE_SPIFI_CLK_CLKSEL_MASK;
regval |= BASE_SPIFI_CLKSEL_IDIVE;
putreg32(regval, LPC43_BASE_SPIFI_CLK);
regval = getreg32(LPC43_IDIVE_CTRL);
regval &= ~(IDIVE_CTRL_CLKSEL_MASK | IDIVE_CTRL_IDIV_MASK);
regval |= BASE_SPIFI_CLKSEL_PLL1 | IDIVE_CTRL_AUTOBLOCK |
IDIVE_CTRL_IDIV(SPIFI_DEVICE_REQUENCY_DIVIDER);
putreg32(regval, LPC43_IDIVE_CTRL);
leave_critical_
```
<Overlap Ratio: 0.9831697054698457>

---

--- 68 --
Question ID: aa1e8f49adcc27c4b077c6a347efe8ce3c103514_8
Original Code:
```
void guac_terminal_scrollbar_set_value(guac_terminal_scrollbar* scrollbar,
        int value) {

    /* Fit value within bounds */
    if (value > scrollbar->max)
        value = scrollbar->max;
    else if (value < scrollbar->min)
        value = scrollbar->min;

    /* Update value */
    scrollbar->value = value;

}
```


Overlapping Code:
```
terminal_scrollbar_set_value(guac_terminal_scrollbar* scrollbar,
int value) {
/* Fit value within bounds */
if (value > scrollbar->max)
value = scrollbar->max;
else if (value < scrollbar->min)
value = scrollbar->min;
/* Update va
```
<Overlap Ratio: 0.8388278388278388>

---

--- 69 --
Question ID: 5ed574a21718b3a426a0c4823e43e0807f8f198a_3
Original Code:
```
void socket_ConnectThread(void *argument)
{
    osiThreadSetFPUEnabled(true); //线程使能FPU
    int32_t retcode;
    while(true)
    {
        if(socket_conSignal)
        {
            retcode = fibo_sock_connect(tempsocketid, &tempaddr); //最大阻塞36s
            socket_conSignal = 0;
            if(retcode != 0)
            {
                fibo_sock_close(tempsocketid);
                data_getData()->isSocketConnect = 0;
                LOG_ERROR("socket connect failed: %d", retcode);
            }
            else
            {
                data_getData()->isSocketConnect = 1;
                LOG_DEBUG("socket connect success :%d", tempsocketid);
                retcode = fibo_sock_lwip_fcntl(tempsocketid, F_SETFL, fibo_sock_lwip_fcntl(tempsocketid, F_GETFL, 0) | O_NONBLOCK);
                if(retcode != 0)
                {
                    fibo_sock_close(tempsocketid);
                    LOG_ERROR("socket set fcntl failed: %d", retcode);
                    return;
                }
                g_socket.socket_id = tempsocketid; //正式connect成功
            }
        }
        fibo_taskSleep(500);
    }
    fibo_thread_delete();
}
```


Overlapping Code:
```
_ConnectThread(void *argument)
{
osiThreadSetFPUEnabled(true); //线程使能FPU
int32_t retcode;
while(true)
{
if(socket_conSignal)
{
retcode = fibo_sock_connect(tempsocketid, &tempaddr); //最大阻塞36s
socket_conSignal = 0;
if(retcode != 0)
{
fibo_sock_close(tempsocketid);
data_getData()->isSocketConnect = 0;
LOG_ERROR("socket connect failed: %d", retcode);
}
else
{
data_getData()->isSocketConnect = 1;
LOG_DEBUG("socket connect success :%d", tempsocketid);
retcode = fibo_sock_lwip_fcntl(tempsocketid, F_SETFL, fibo_sock_lwip_fcntl(tempsocketid, F_GETFL, 0) | O_NONBLOCK);
if(retcode != 0)
{
fibo_sock_close(tempsocketid);
LOG_ERROR("socket set fcntl failed: %d", retcode);
return;
}
g_socket.socket_id = tempsocketid; //正式connect成功
}
}
fibo_taskSleep(500);
```
<Overlap Ratio: 0.9529860228716646>

---

--- 70 --
Question ID: fda5c8a68681f39acf5db19081a90755f94819ce_13
Original Code:
```
int32_t bt_host_store_link_key(struct bt_hci_evt_link_key_notify *link_key_notify) {
    int32_t ret = -1;
    uint32_t index = bt_host_link_keys.index;
    for (uint32_t i = 0; i < ARRAY_SIZE(bt_host_link_keys.link_keys); i++) {
        if (memcmp((void *)&link_key_notify->bdaddr, (void *)&bt_host_link_keys.link_keys[i].bdaddr, sizeof(link_key_notify->bdaddr)) == 0) {
            index = i;
        }
    }
    memcpy((void *)&bt_host_link_keys.link_keys[index], (void *)link_key_notify, sizeof(bt_host_link_keys.link_keys[0]));
    if (index == bt_host_link_keys.index) {
        bt_host_link_keys.index++;
        bt_host_link_keys.index &= 0xF;
    }
    ret = bt_host_store_keys_on_file(&bt_host_link_keys);
    return ret;
}
```


Overlapping Code:
```
(struct bt_hci_evt_link_key_notify *link_key_notify) {
int32_t ret = -1;
uint32_t index = bt_host_link_keys.index;
for (uint32_t i = 0; i < ARRAY_SIZE(bt_host_link_keys.link_keys); i++) {
if (memcmp((void *)&link_key_notify->bdaddr, (void *)&bt_host_link_keys.link_keys[i].bdaddr, sizeof(link_key_notify->bdaddr)) == 0) {
index = i;
}
}
memcpy((void *)&bt_host_link_keys.link_keys[index], (void *)link_key_notify, sizeof(bt_host_link_keys.link_keys[0]));
if (index == bt_host_link_keys.index) {
bt_host_link_keys.index++;
bt_host_link_keys.index &= 0xF;
}
ret = bt_host_store_keys_on_file(&bt_host_link_keys);
return
```
<Overlap Ratio: 0.9433384379785605>

---

--- 71 --
Question ID: 8c6ca9bc2d19477669e05c93f4293cd134420f9a_4
Original Code:
```
static int countTombStones(HashTable* pHashTable)
{
    int i, count;

    for (count = i = 0; i < pHashTable->tableSize; i++) {
        if (pHashTable->pEntries[i].data == HASH_TOMBSTONE)
            count++;
    }
    return count;
}
```


Overlapping Code:
```
c int countTombStones(HashTable* pHashTable)
{
int i, count;
for (count = i = 0; i < pHashTable->tableSize; i++) {
if (pHashTable->pEntries[i].data == HASH_TOMBSTONE)
count++;

```
<Overlap Ratio: 0.8888888888888888>

---

--- 72 --
Question ID: d7ba155cd489d5528ac8b7d0643b7e5f883869d5_3
Original Code:
```
static inline size_t sbp_u64_encode(sbp_encode_ctx_t *ctx, const u64 *v) {
  if (!SBP_CAN_PACK(ctx, u64)) {
    return false;
  }
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000000000ff) >> (8U * 0U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000000000ff00) >> (8U * 1U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000000000ff0000) >> (8U * 2U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000ff000000) >> (8U * 3U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000ff00000000) >> (8U * 4U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000ff0000000000) >> (8U * 5U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00ff000000000000) >> (8U * 6U));
  ctx->buf[ctx->offset++] = (uint8_t)((*v & 0xff00000000000000) >> (8U * 7U));
  return true;
}
```


Overlapping Code:
```
(sbp_encode_ctx_t *ctx, const u64 *v) {
if (!SBP_CAN_PACK(ctx, u64)) {
return false;
}
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000000000ff) >> (8U * 0U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000000000ff00) >> (8U * 1U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000000000ff0000) >> (8U * 2U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00000000ff000000) >> (8U * 3U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x000000ff00000000) >> (8U * 4U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x0000ff0000000000) >> (8U * 5U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0x00ff000000000000) >> (8U * 6U));
ctx->buf[ctx->offset++] = (uint8_t)((*v & 0xff00000000000000) >> (8U * 7U)
```
<Overlap Ratio: 0.9308510638297872>

---

--- 73 --
Question ID: 2fcf87ce73fc84dec90a6aaf189a09c16407c65d_25
Original Code:
```
virtual int serialize(char **buf, size_t *buf_siz,
			const int allow_realloc, size_t *nargs, va_list_t &ap) {
    if (use_generic()) {
      generic_t gen_arg = pop_generic(nargs, ap);
      return serialize(buf, buf_siz, allow_realloc,
		       (YggGeneric*)(gen_arg.obj));
    }
    va_list_t ap_copy = copy_va_list(ap);
    update_from_serialization_args(nargs, ap_copy);
    if (nargs_exp() != *nargs) {
      ygglog_throw_error("MetaschemaType::serialize: %d arguments expected, but %d provided.",
			 nargs_exp(), *nargs);
    }
    rapidjson::StringBuffer body_buf;
    rapidjson::Writer<rapidjson::StringBuffer> body_writer(body_buf);
    bool out = encode_data_wrap(&body_writer, nargs, ap);
    if (!(out)) {
      return -1;
    }
    if (*nargs != 0) {
      ygglog_error("MetaschemaType::serialize: %d arguments were not used.", *nargs);
      return -1;
    }
    // Copy message to buffer
    return copy_to_buffer(body_buf.GetString(), body_buf.GetSize(),
			  buf, *buf_siz, allow_realloc);
  }
```


Overlapping Code:
```
l int serialize(char **buf, size_t *buf_siz,
const int allow_realloc, size_t *nargs, va_list_t &ap) {
if (use_generic()) {
generic_t gen_arg = pop_generic(nargs, ap);
return serialize(buf, buf_siz, allow_realloc,
(YggGeneric*)(gen_arg.obj));
}
va_list_t ap_copy = copy_va_list(ap);
update_from_serialization_args(nargs, ap_copy);
if (nargs_exp() != *nargs) {
ygglog_throw_error("MetaschemaType::serialize: %d arguments expected, but %d provided.",
nargs_exp(), *nargs);
}
rapidjson::StringBuffer body_buf;
rapidjson::Writer<rapidjson::StringBuffer> body_writer(body_buf);
bool out = encode_data_wrap(&body_writer, nargs, ap);
if (!(out)) {
return -1;
}
if (*nargs != 0) {
ygglog_error("MetaschemaType::serialize: %d arguments were not used.", *nargs);
return -1;
}
// Copy message to buffer
return copy_to_buffer(body_buf.GetString(), body_buf.GetSize(),
buf, *buf_siz, allow_realloc
```
<Overlap Ratio: 0.9888017917133258>

---

--- 74 --
Question ID: 5a591ba9e98cd9f691fd1ea62d63b1c675387443_0
Original Code:
```
class Mapper
{
public:
    Mapper();
    ~Mapper();

public:
    static int StringToFormat(const std::string& format);
    void SetIFilter(int ifilter);

    void SphPointFromImg(const Image& img, int format, const Vec2f& sphPoints, Vec1d& pixels);

private:
    void SphToCart(const cv::Point2f& in, cv::Point3f& out);  // Spherical coordinates to Cartesian coordinates
    void CartToRect(const Image& img, const cv::Point3f& in, cv::Point2f& out);
    void CartToCube(const Image& img, const cv::Point3f& in, cv::Point2f& out, int& faceIdx);
    std::vector<Image> ExtractCubeFace(const Image& cmp);

    unsigned char IFilterNearest(const Image& img, const cv::Point2f& in);
    void InitLanczosCoef();
    double IFilterLanczos(const cv::Mat& img, const cv::Point2d& in) const;

private:
    float Clamp(float v, float low, float high);

private:
    int m_ifilter;
    std::vector<double> m_lanczosCoef;
}
```


Overlapping Code:
```
r();
public:
static int StringToFormat(const std::string& format);
void SetIFilter(int ifilter);
void SphPointFromImg(const Image& img, int format, const Vec2f& sphPoints, Vec1d& pixels);
private:
void SphToCart(const cv::Point2f& in, cv::Point3f& out); // Spherical coordinates to Cartesian coordinates
void CartToRect(const Image& img, const cv::Point3f& in, cv::Point2f& out);
void CartToCube(const Image& img, const cv::Point3f& in, cv::Point2f& out, int& faceIdx);
std::vector<Image> ExtractCubeFace(const Image& cmp);
unsigned char IFilterNearest(const Image& img, const cv::Point2f& in);
void InitLanczosCoef();
double IFilterLanczos(const cv::Mat& img, const cv::Point2d& in) const;
private:
float Clamp(float v, float low, float high);
private:
int m_ifilter;
std::vector<double> m_lanczosCo
```
<Overlap Ratio: 0.9478672985781991>

---

--- 75 --
Question ID: 9dea548dc72f70aba40e4fe3b33f7dae29e8572d_0
Original Code:
```
void gmx_omp_check_thread_affinity(FILE *fplog, const t_commrec *cr,
                                   gmx_hw_opt_t *hw_opt)
{
    gmx_bool bKmpAffinitySet, bGompCpuAffinitySet;
    char    *kmp_env, *gomp_env;

    /* no need to worry if internal thread pinning is turned off */
    if (hw_opt->thread_affinity == threadaffOFF)
    {
        return;
    }

#if defined(GMX_OPENMP)

    /* We assume that the affinity setting is available on all platforms
     * gcc supports. Even if this is not the case (e.g. Mac OS) the user
     * will only get a warning.*/
    bGompCpuAffinitySet = FALSE;
    gomp_env            = NULL;
#if defined(__GNUC__)
    gomp_env            = getenv("GOMP_CPU_AFFINITY");
    bGompCpuAffinitySet = (gomp_env != NULL);
#endif /* __GNUC__ */

    bKmpAffinitySet = FALSE;
#if defined(__INTEL_COMPILER)
    kmp_env         = getenv("KMP_AFFINITY");
    bKmpAffinitySet = (kmp_env != NULL);

    /* disable Intel OpenMP affinity if neither KMP_AFFINITY nor
     * GOMP_CPU_AFFINITY is set (Intel uses the GNU env. var as well) */
    if (!bKmpAffinitySet && !bGompCpuAffinitySet)
    {
        int retval;

#ifdef _MSC_VER
        /* Windows not POSIX */
        retval = _putenv_s("KMP_AFFINITY", "disabled");
#else
        /* POSIX */
        retval = setenv("KMP_AFFINITY", "disabled", 0);
#endif  /* _MSC_VER */

        if (debug)
        {
            fprintf(debug, "Disabling Intel OpenMP affinity by setting the KMP_AFFINITY=disabled env. var.\n");
        }

        if (retval != 0)
        {
            gmx_warning("Disabling Intel OpenMp affinity setting failed!");
        }
    }

    /* turn off internal pinning KMP_AFFINITY != "disabled" */
    if (bKmpAffinitySet && (gmx_strncasecmp(kmp_env, "disabled", 8) != 0))
    {
        /* TODO: with -pin auto we should only warn when using all cores */
        md_print_warn(cr, fplog,
                      "NOTE: KMP_AFFINITY set, will turn off %s internal affinity\n"
                      "      setting as the two can conflict and cause performance degradation.\n"
                      "      To keep using the %s internal affinity setting, set the\n"
                      "      KMP_AFFINITY=disabled environment variable.",
                      ShortProgram(), ShortProgram());

        hw_opt->thread_affinity = threadaffOFF;
    }
#endif /* __INTEL_COMPILER */

#if defined(__INTEL_COMPILER) || defined(__GNUC__)
    /* turn off internal pinning f GOMP_CPU_AFFINITY is set & non-empty */
    if (bGompCpuAffinitySet && gomp_env != NULL && gomp_env != '\0')
    {
        /* TODO: with -pin auto we should only warn when using all cores */
        md_print_warn(cr, fplog,
                      "NOTE: GOMP_CPU_AFFINITY set, will turn off %s internal affinity\n"
                      "      setting as the two can conflict and cause performance degradation.\n"
                      "      To keep using the %s internal affinity setting, unset the\n"
                      "      GOMP_CPU_AFFINITY environment variable.",
                      ShortProgram(), ShortProgram());

        hw_opt->thread_affinity = threadaffOFF;
    }
#endif /* __INTEL_COMPILER || __GNUC__ */

#endif /* GMX_OPENMP */
}
```


Overlapping Code:
```
mp_check_thread_affinity(FILE *fplog, const t_commrec *cr,
gmx_hw_opt_t *hw_opt)
{
gmx_bool bKmpAffinitySet, bGompCpuAffinitySet;
char *kmp_env, *gomp_env;
/* no need to worry if internal thread pinning is turned off */
if (hw_opt->thread_affinity == threadaffOFF)
{
return;
}
#if defined(GMX_OPENMP)
/* We assume that the affinity setting is available on all platforms
* gcc supports. Even if this is not the case (e.g. Mac OS) the user
* will only get a warning.*/
bGompCpuAffinitySet = FALSE;
gomp_env = NULL;
#if defined(__GNUC__)
gomp_env = getenv("GOMP_CPU_AFFINITY");
bGompCpuAffinitySet = (gomp_env != NULL);
#endif /* __GNUC__ */
bKmpAffinitySet = FALSE;
#if defined(__INTEL_COMPILER)
kmp_env = getenv("KMP_AFFINITY");
bKmpAffinitySet = (kmp_env != NULL);
/* disable Intel OpenMP affinity if neither KMP_AFFINITY nor
* GOMP_CPU_AFFINITY is set (Intel uses the GNU env. var as well) */
if (!bKmpAffinitySet && !bGompCpuAffinitySet)
{
int retval;
#ifdef _MSC_VER
/* Windows not POSIX */
retval = _putenv_s("KMP_AFFINITY", "disabled");
#else
/* POSIX */
retval = setenv("KMP_AFFINITY", "disabled", 0);
#endif /* _MSC_VER */
if (debug)
{
fprintf(debug, "Disabling Intel OpenMP affinity by setting the KMP_AFFINITY=disabled env. var.\n");
}
if (retval != 0)
{
gmx_warning("Disabling Intel OpenMp affinity setting failed!");
}
}
/* turn off internal pinning KMP_AFFINITY != "disabled" */
if (bKmpAffinitySet && (gmx_strncasecmp(kmp_env, "disabled", 8) != 0))
{
/* TODO: with -pin auto we should only warn when using all cores */
md_print_warn(cr, fplog,
"NOTE: KMP_AFFINITY set, will turn off %s internal affinity\n"
" setting as the two can conflict and cause performance degradation.\n"
" To keep using the %s internal affinity setting, set the\n"
" KMP_AFFINITY=disabled environment variable.",
ShortProgram(), ShortProgram());
hw_opt->thread_affinity = threadaffOFF;
}
#endif /* __INTEL_COMPILER */
#if defined(__INTEL_COMPILER) || defined(__GNUC__)
/* turn off internal pinning f GOMP_CPU_AFFINITY is set & non-empty */

```
<Overlap Ratio: 0.9946051986267779>

---

--- 76 --
Question ID: 800b894733b1d4d38493918ac049f48c8973aa48_6
Original Code:
```
static config_item *game_configure(const game_params *params)
{
    config_item *ret;
    char buf[80];
    
    ret = snewn(7, config_item);
    
    ret[0].name = "Width";
    ret[0].type = C_STRING;
    sprintf(buf, "%d", params->w);
    ret[0].u.string.sval = dupstr(buf);
    
    ret[1].name = "Height";
    ret[1].type = C_STRING;
    sprintf(buf, "%d", params->h);
    ret[1].u.string.sval = dupstr(buf);
    
    ret[2].name = "Always show start and end points";
    ret[2].type = C_BOOLEAN;
    ret[2].u.boolean.bval = !params->removeends;
    
    ret[3].name = "Symmetrical clues";
    ret[3].type = C_BOOLEAN;
    ret[3].u.boolean.bval = params->symmetrical;

    ret[4].name = "Grid type";
    ret[4].type = C_CHOICES;
    ret[4].u.choices.choicenames = MODELIST(CONFIG);
    ret[4].u.choices.selected = params->mode;

    ret[5].name = "Difficulty";
    ret[5].type = C_CHOICES;
    ret[5].u.choices.choicenames = DIFFLIST(CONFIG);
    ret[5].u.choices.selected = params->diff;
    
    ret[6].name = NULL;
    ret[6].type = C_END;
    
    return ret;
}
```


Overlapping Code:
```
static config_item *game_configure(const game_params *params)
{
config_item *ret;
char buf[80];

ret = snewn(7, config_item);

ret[0].name = "Width";
ret[0].type = C_STRING;
sprintf(buf, "%d", params->w);
ret[0].u.string.sval = dupstr(buf);

ret[1].name = "Height";
ret[1].type = C_STRING;
sprintf(buf, "%d", params->h);
ret[1].u.string.sval = dupstr(buf);

ret[2].name = "Always show start and end points";
ret[2].type = C_BOOLEAN;
ret[2].u.boolean.bval = !params->removeends;

ret[3].name = "Symmetrical clues";
ret[3].type = C_BOOLEAN;
ret[3].u.boolean.bval = params->symmetrical;
ret[4].name = "Grid type";
ret[4].type = C_CHOICES;
ret[4].u.choices.choicenames = MODELIST(CONFIG);
ret[4].u.choices.selected = params->mode;
ret[5].name = "Difficulty";
ret[5].type = C_CHOICES;
ret[5].u.choices.choicenames = DIFFLIST(CONFIG);
ret[5].u.choices.selected = params->diff;

ret[6].name = NULL;
ret[6].type = C_E
```
<Overlap Ratio: 0.9805825242718447>

---

--- 77 --
Question ID: c6e789c41ffb687b8d0f30012e9b3c2459edb11f_6
Original Code:
```
void progress_update ()
{
  static uint64_t counter = 0;  // counter to perform one step
  static int progress = 1;      // steps taken
  static char progressBar[21] = "===================="; // progress done
  static char progressBlank[21] = "--------------------"; // progress open

  if (glbl_verboseMode && !glbl_endlessMode)
  {
    counter++;
    if (counter == glbl_progressStep)
    {
      counter = 0;
      if (glbl_simulatedAttMode)
      {
        printf ("\r<%s%s> %3i %% created (%.1f %% cracked)", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress, glbl_crackedRatio * 100);
      }
      else
      {
        printf ("\r<%s%s> %3i %% created", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress);
      }
      progress++;
    }
  }
}
```


Overlapping Code:
```
id progress_update ()
{
static uint64_t counter = 0; // counter to perform one step
static int progress = 1; // steps taken
static char progressBar[21] = "===================="; // progress done
static char progressBlank[21] = "--------------------"; // progress open
if (glbl_verboseMode && !glbl_endlessMode)
{
counter++;
if (counter == glbl_progressStep)
{
counter = 0;
if (glbl_simulatedAttMode)
{
printf ("\r<%s%s> %3i %% created (%.1f %% cracked)", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), progress, glbl_crackedRatio * 100);
}
else
{
printf ("\r<%s%s> %3i %% created", progressBar + (20 - (int) (progress / 5)), progressBlank + (int) (progress / 5), pro
```
<Overlap Ratio: 0.9602194787379973>

---

--- 78 --
Question ID: 3a8ab63c2865dcb937fe0d930336646bf6f37532_20
Original Code:
```
int CheckParm (char *check)
{
	int             i;

	for (i = 1;i<myargc;i++)
	{
		if ( !Q_strcasecmp(check, myargv[i]) )
			return i;
	}

	return 0;
}
```


Overlapping Code:
```
ckParm (char *check)
{
int i;
for (i = 1;i<myargc;i++)
{
if ( !Q_strcasecmp(check, myargv[i]) )
return i;
}
return
```
<Overlap Ratio: 0.9047619047619048>

---

--- 79 --
Question ID: f5f104b73879169634ca864353ce8f598439ca5d_2
Original Code:
```
void config_entity_set_value(ConfigEntity *entity, char *key, char *value) {
	// Add a new key-value pair to the entity

	if (entity->keyValuePairs == NULL) {
		entity->keyValuePairs = list_new(free);
	}

	ConfigKeyValuePair *kv = calloc(1, sizeof(ConfigKeyValuePair));
	kv->key = strdup(key);
	kv->value = strdup(value);

	list_insert_after(entity->keyValuePairs, list_tail(entity->keyValuePairs), kv);
}
```


Overlapping Code:
```
e(ConfigEntity *entity, char *key, char *value) {
// Add a new key-value pair to the entity
if (entity->keyValuePairs == NULL) {
entity->keyValuePairs = list_new(free);
}
ConfigKeyValuePair *kv = calloc(1, sizeof(ConfigKeyValuePair));
kv->key = strdup(key);
kv->value = strdup(value);
list_insert_after(entity->keyValuePairs, list_tail(entity->keyVal
```
<Overlap Ratio: 0.8905852417302799>

---

--- 80 --
Question ID: 9c95873d0dba32f4c5b67bd482fa1ae39d3b826f_3
Original Code:
```
signed long
_kcl_fence_wait_timeout(struct dma_fence *fence, bool intr, signed long timeout)
{
	signed long ret;

	if (WARN_ON(timeout < 0))
		return -EINVAL;

	/*
	 * Modifications [2017-03-29] (c) [2017]
	 * Advanced Micro Devices, Inc.
	 */
	trace_kcl_fence_wait_start(fence);
	if (fence->ops->wait)
		ret = fence->ops->wait(fence, intr, timeout);
	else
		ret = _kcl_fence_default_wait(fence, intr, timeout);
	trace_kcl_fence_wait_end(fence);
	return ret;
}
```


Overlapping Code:
```
g
_kcl_fence_wait_timeout(struct dma_fence *fence, bool intr, signed long timeout)
{
signed long ret;
if (WARN_ON(timeout < 0))
return -EINVAL;
/*
* Modifications [2017-03-29] (c) [2017]
* Advanced Micro Devices, Inc.
*/
trace_kcl_fence_wait_start(fence);
if (fence->ops->wait)
ret = fence->ops->wait(fence, intr, timeout);
else
ret = _kcl_fence_default_wait(fence, intr, timeout);
trace_kcl_fence_wa
```
<Overlap Ratio: 0.91324200913242>

---

--- 81 --
Question ID: 313054a860cdfc6cf366ec38d7c419c197e1a215_0
Original Code:
```
int
main(
    int   argc,
    char* argv[]
    )
{
    DWORD dwError = 0;
    BOOLEAN bShutdown = FALSE;
    PLW_SHARE_MIGRATION_CONTEXT pContext = NULL;

    if (argc == 2 && (!strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")))
    {
        ShowUsage();
        goto cleanup;
    }

    if (argc < 5)
    {
        dwError = ERROR_BAD_ARGUMENTS;
        BAIL_ON_LW_TASK_ERROR(dwError);
    }

    dwError = LwTaskMigrateInit();
    BAIL_ON_LW_TASK_ERROR(dwError);

    bShutdown = TRUE;

    dwError = LwTaskMigrateCreateContext(
                    argv[3], /* User name   */
                    argv[4], /* Password    */
                    &pContext);
    BAIL_ON_LW_TASK_ERROR(dwError);

    dwError = LwTaskMigrateShareA(
                    pContext,
                    argv[1], /* Server name */
                    argv[2], /* Share name  */
                    0        /* Flags       */
                    );
    BAIL_ON_LW_TASK_ERROR(dwError);

cleanup:

    if (pContext)
    {
        LwTaskMigrateCloseContext(pContext);
    }

    if (bShutdown)
    {
        LwTaskMigrateShutdown();
    }

    return dwError;

error:

    switch (dwError)
    {
        case ERROR_BAD_ARGUMENTS:

            ShowUsage();

            break;

        default:

            fprintf(stderr, "Error migrating share. Code %u\n", dwError);

            break;
    }

    goto cleanup;
}
```


Overlapping Code:
```
t
main(
int argc,
char* argv[]
)
{
DWORD dwError = 0;
BOOLEAN bShutdown = FALSE;
PLW_SHARE_MIGRATION_CONTEXT pContext = NULL;
if (argc == 2 && (!strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")))
{
ShowUsage();
goto cleanup;
}
if (argc < 5)
{
dwError = ERROR_BAD_ARGUMENTS;
BAIL_ON_LW_TASK_ERROR(dwError);
}
dwError = LwTaskMigrateInit();
BAIL_ON_LW_TASK_ERROR(dwError);
bShutdown = TRUE;
dwError = LwTaskMigrateCreateContext(
argv[3], /* User name */
argv[4], /* Password */
&pContext);
BAIL_ON_LW_TASK_ERROR(dwError);
dwError = LwTaskMigrateShareA(
pContext,
argv[1], /* Server name */
argv[2], /* Share name */
0 /* Flags */
);
BAIL_ON_LW_TASK_ERROR(dwError);
cleanup:
if (pContext)
{
LwTaskMigrateCloseContext(pContext);
}
if (bShutdown)
{
LwTaskMigrateShutdown();
}
return dwError;
error:
switch (dwError)
{
case ERROR_BAD_ARGUMENTS:
ShowUsage();
break;
default:
fprintf(stderr, "Error migrating share
```
<Overlap Ratio: 0.9478623566214807>

---

--- 82 --
Question ID: 21e45b94981a3d6e289cb7a2fd99268f0b20a834_19
Original Code:
```
static int data_raw_string_is(data_raw_t *dat, char *key)
{
    char *cx;
    int pos;

    if (dat->type != rawtyp_Str)
        gli_fatal_error("data: Need str");

    for (pos=0, cx=key; *cx && pos<dat->count; pos++, cx++) {
        if (dat->str[pos] != (glui32)(*cx))
            break;
    }

    if (*cx == '\0' && pos == dat->count)
        return TRUE;
    else
        return FALSE;
}
```


Overlapping Code:
```
 int data_raw_string_is(data_raw_t *dat, char *key)
{
char *cx;
int pos;
if (dat->type != rawtyp_Str)
gli_fatal_error("data: Need str");
for (pos=0, cx=key; *cx && pos<dat->count; pos++, cx++) {
if (dat->str[pos] != (glui32)(*cx))
break;
}
if (*cx == '\0' && pos == dat->count)
return TRUE;
else
return FALSE
```
<Overlap Ratio: 0.9716088328075709>

---

--- 83 --
Question ID: 963290318e6c58dcad19442d22b9247cf51783c5_12
Original Code:
```
static int ble_cmd_gatt_notify_change_by_uuid(int argc, char *argv[])
{
    uint16_t conn_handle;
    uint32_t uuidint;
    rw007_ble_uuid_t uuid;
    int rc;
    int value;
    int uuidlen;

    if (argc < 5)
    {
        rt_kprintf("argc < 5\n");
        return -1;
    }

    conn_handle = atoi(argv[2]);

    uuidlen = strlen(argv[3]);

    if (4 == uuidlen) {
        uuid.type = BLE_UUID_TYPE_16;
        sscanf(argv[3], "%x", &uuidint);
        uuid.uuid.uuid16 = uuidint & 0xFFFFu;
    }
    else if (8 == uuidlen) {
        uuid.type = BLE_UUID_TYPE_32;
        sscanf(argv[3], "%x", &uuidint);
        uuid.uuid.uuid32 = uuidint & 0xFFFFFFFFu;
    }
    else if (32 == uuidlen) {
        int i;

        uuid.type = BLE_UUID_TYPE_128;
        for (i = 0; i < 16; i++) {
            sscanf(&argv[3][i * 2], "%02x", &uuidint);
            uuid.uuid.uuid128[15 - i] = uuidint & 0xFFu;
        }
    }
    else {
        rt_kprintf("uuid:%s input error\n", argv[3]);
        return -1;
    }

    value = atoi(argv[4]);
    rt_kprintf("notifychange conn_hanle:%d uuid:%s value:%02x\n", conn_handle, argv[3], value);

    rc = rw007_ble_gatt_notify_change_by_uuid(conn_handle, &uuid, value);

    rt_kprintf("notifychange rc:%d\n", rc);
    return rc;
}
```


Overlapping Code:
```
e_by_uuid(int argc, char *argv[])
{
uint16_t conn_handle;
uint32_t uuidint;
rw007_ble_uuid_t uuid;
int rc;
int value;
int uuidlen;
if (argc < 5)
{
rt_kprintf("argc < 5\n");
return -1;
}
conn_handle = atoi(argv[2]);
uuidlen = strlen(argv[3]);
if (4 == uuidlen) {
uuid.type = BLE_UUID_TYPE_16;
sscanf(argv[3], "%x", &uuidint);
uuid.uuid.uuid16 = uuidint & 0xFFFFu;
}
else if (8 == uuidlen) {
uuid.type = BLE_UUID_TYPE_32;
sscanf(argv[3], "%x", &uuidint);
uuid.uuid.uuid32 = uuidint & 0xFFFFFFFFu;
}
else if (32 == uuidlen) {
int i;
uuid.type = BLE_UUID_TYPE_128;
for (i = 0; i < 16; i++) {
sscanf(&argv[3][i * 2], "%02x", &uuidint);
uuid.uuid.uuid128[15 - i] = uuidint & 0xFFu;
}
}
else {
rt_kprintf("uuid:%s input error\n", argv[3]);
return -1;
}
value = atoi(argv[4]);
rt_kprintf("notifychange conn_hanle:%d uuid:%s value:%02x\n", conn_handle, argv[3], value);
rc = rw007_ble_gatt_notify_change_by_uuid(conn_handle, &uuid, value);
rt_kprintf("notifyc
```
<Overlap Ratio: 0.9322865554465162>

---

--- 84 --
Question ID: 4fa9bedd1bae9f48715ba2377a00f10e439cf58f_2
Original Code:
```
static inline void VP8YuvToRgba4444KeepA(uint8_t y, uint8_t u, uint8_t v,
                                         uint8_t* const argb) {
  const int r_off = VP8kVToR[v];
  const int g_off = (VP8kVToG[v] + VP8kUToG[u]) >> YUV_FIX;
  const int b_off = VP8kUToB[u];
  // Don't update Aplha (last 4 bits of argb[1])
  argb[0] = ((VP8kClip4Bits[y + r_off - YUV_RANGE_MIN] << 4) |
             VP8kClip4Bits[y + g_off - YUV_RANGE_MIN]);
  argb[1] = (argb[1] & 0x0f) | (VP8kClip4Bits[y + b_off - YUV_RANGE_MIN] << 4);
}
```


Overlapping Code:
```
A(uint8_t y, uint8_t u, uint8_t v,
uint8_t* const argb) {
const int r_off = VP8kVToR[v];
const int g_off = (VP8kVToG[v] + VP8kUToG[u]) >> YUV_FIX;
const int b_off = VP8kUToB[u];
// Don't update Aplha (last 4 bits of argb[1])
argb[0] = ((VP8kClip4Bits[y + r_off - YUV_RANGE_MIN] << 4) |
VP8kClip4Bits[y + g_off - YUV_RANGE_MIN]);
argb[1] = (argb[1] & 0x0f) | (VP8kClip4Bits[y + b_off - YUV_RANGE_MIN] 
```
<Overlap Ratio: 0.8948545861297539>

---

--- 85 --
Question ID: 6dc2b57f62bc4fbe83ad330a835fcfd890aed5ee_25
Original Code:
```
void hfs_bnode_free(struct hfs_bnode *node)
{
	//int i;

	//for (i = 0; i < node->tree->pages_per_bnode; i++)
	//	if (node->page[i])
	//		page_cache_release(node->page[i]);
	kfree(node);
}
```


Overlapping Code:
```
e)
{
//int i;
//for (i = 0; i < node->tree->pages_per_bnode; i++)
// if (node->page[i])
// page_cache_release(node->page[i]);
kfree(node)
```
<Overlap Ratio: 0.7569060773480663>

---

--- 86 --
Question ID: 5cc3ad585d405237047065d52451c61638fae716_98
Original Code:
```
static D3DCOLOR WINAPI d3drm_frame3_GetSceneBackground(IDirect3DRMFrame3 *iface)
{
    struct d3drm_frame *frame = impl_from_IDirect3DRMFrame3(iface);

    TRACE("iface %p.\n", iface);

    return frame->scenebackground;
}
```


Overlapping Code:
```
NAPI d3drm_frame3_GetSceneBackground(IDirect3DRMFrame3 *iface)
{
struct d3drm_frame *frame = impl_from_IDirect3DRMFrame3(iface);
TRACE("iface %p.\n", iface);
return frame
```
<Overlap Ratio: 0.8173076923076923>

---

--- 87 --
Question ID: 7f4241bfb9c437dcadf63f21913f803cccfdbae7_14
Original Code:
```
static int orc_reset_scsi_bus(ORC_HCS * pHCB)
{				/* I need Host Control Block Information */
	ULONG flags;

	spin_lock_irqsave(&(pHCB->BitAllocFlagLock), flags);

	initAFlag(pHCB);
	/* reset scsi bus */
	ORC_WR(pHCB->HCS_Base + ORC_HCTRL, SCSIRST);
	if (waitSCSIRSTdone(pHCB) == 0) {
		spin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);
		return FAILED;
	} else {
		spin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);
		return SUCCESS;
	}
}
```


Overlapping Code:
```
pHCB)
{ /* I need Host Control Block Information */
ULONG flags;
spin_lock_irqsave(&(pHCB->BitAllocFlagLock), flags);
initAFlag(pHCB);
/* reset scsi bus */
ORC_WR(pHCB->HCS_Base + ORC_HCTRL, SCSIRST);
if (waitSCSIRSTdone(pHCB) == 0) {
spin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);
return FAILED;
} else {
spin_unlock_irqrestore(&(pHCB->BitAllocFlagLock), flags);
return 
```
<Overlap Ratio: 0.880184331797235>

---

--- 88 --
Question ID: d21e1284604f6a2e391ce37c8a6c85a1b06c91ca_44
Original Code:
```
static int setup_clone(struct request *clone, struct request *rq,
		       struct dm_rq_target_io *tio)
{
	int r;

	if (dm_rq_is_flush_request(rq)) {
		blk_rq_init(NULL, clone);
		clone->cmd_type = REQ_TYPE_FS;
		clone->cmd_flags |= (REQ_HARDBARRIER | WRITE);
	} else {
		r = blk_rq_prep_clone(clone, rq, tio->md->bs, GFP_ATOMIC,
				      dm_rq_bio_constructor, tio);
		if (r)
			return r;

		clone->cmd = rq->cmd;
		clone->cmd_len = rq->cmd_len;
		clone->sense = rq->sense;
		clone->buffer = rq->buffer;
	}

	clone->end_io = end_clone_request;
	clone->end_io_data = tio;

	return 0;
}
```


Overlapping Code:
```
(struct request *clone, struct request *rq,
struct dm_rq_target_io *tio)
{
int r;
if (dm_rq_is_flush_request(rq)) {
blk_rq_init(NULL, clone);
clone->cmd_type = REQ_TYPE_FS;
clone->cmd_flags |= (REQ_HARDBARRIER | WRITE);
} else {
r = blk_rq_prep_clone(clone, rq, tio->md->bs, GFP_ATOMIC,
dm_rq_bio_constructor, tio);
if (r)
return r;
clone->cmd = rq->cmd;
clone->cmd_len = rq->cmd_len;
clone->sense = rq->sense;
clone->buffer = rq->buffer;
}
clone->end_io = end_clone_request;
clone->end_io_data = tio
```
<Overlap Ratio: 0.9345794392523364>

---

--- 89 --
Question ID: 004c42274e48705a997822a46e743ce9087f7b91_24
Original Code:
```
static struct mlxsw_sp_fid *mlxsw_sp_fid_lookup(struct mlxsw_sp *mlxsw_sp,
						enum mlxsw_sp_fid_type type,
						const void *arg)
{
	struct mlxsw_sp_fid_family *fid_family;
	struct mlxsw_sp_fid *fid;

	fid_family = mlxsw_sp->fid_core->fid_family_arr[type];
	list_for_each_entry(fid, &fid_family->fids_list, list) {
		if (!fid->fid_family->ops->compare(fid, arg))
			continue;
		refcount_inc(&fid->ref_count);
		return fid;
	}

	return NULL;
}
```


Overlapping Code:
```
ic struct mlxsw_sp_fid *mlxsw_sp_fid_lookup(struct mlxsw_sp *mlxsw_sp,
enum mlxsw_sp_fid_type type,
const void *arg)
{
struct mlxsw_sp_fid_family *fid_family;
struct mlxsw_sp_fid *fid;
fid_family = mlxsw_sp->fid_core->fid_family_arr[type];
list_for_each_entry(fid, &fid_family->fids_list, list) {
if (!fid->fid_family->ops->compare(fid, arg))
continue;
refcount_inc(&fid->ref_count);
return fid;
}
re
```
<Overlap Ratio: 0.9615384615384616>

---

--- 90 --
Question ID: 63cd605b6abd6f155280daca22791bafd53a1cfb_2
Original Code:
```
int board_phy_config(struct phy_device *phydev)
{
	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);

	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);

	if (phydev->drv->config)
		phydev->drv->config(phydev);

	return 0;
}
```


Overlapping Code:
```
int board_phy_config(struct phy_device *phydev)
{
phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
if (phydev->drv->config)
phydev->drv->config(phydev);
return 0;
}
```
<Overlap Ratio: 1.0>

---

--- 91 --
Question ID: a8307d55c70eaadc99e03aba65cef24d71668121_0
Original Code:
```
static int __init imx_phycore_init(void)
{
	int ret;

	if (!machine_is_pcm043() && !machine_is_pca100())
		/* return happy. We might run on a totally different machine */
		return 0;

	imx_phycore_snd_device = platform_device_alloc("soc-audio", -1);
	if (!imx_phycore_snd_device)
		return -ENOMEM;

	imx_phycore_dai_ac97[0].cpu_dai = &imx_ssi_pcm_dai[0];

	platform_set_drvdata(imx_phycore_snd_device, &imx_phycore_snd_devdata);
	imx_phycore_snd_devdata.dev = &imx_phycore_snd_device->dev;
	ret = platform_device_add(imx_phycore_snd_device);

	if (ret) {
		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
		platform_device_put(imx_phycore_snd_device);
	}

	return ret;
}
```


Overlapping Code:
```
tatic int __init imx_phycore_init(void)
{
int ret;
if (!machine_is_pcm043() && !machine_is_pca100())
/* return happy. We might run on a totally different machine */
return 0;
imx_phycore_snd_device = platform_device_alloc("soc-audio", -1);
if (!imx_phycore_snd_device)
return -ENOMEM;
imx_phycore_dai_ac97[0].cpu_dai = &imx_ssi_pcm_dai[0];
platform_set_drvdata(imx_phycore_snd_device, &imx_phycore_snd_devdata);
imx_phycore_snd_devdata.dev = &imx_phycore_snd_device->dev;
ret = platform_device_add(imx_phycore_snd_device);
if (ret) {
printk(KERN_ERR "ASoC: Platform device allocation failed\n");
platform_device_put(imx_phycore_snd_device);
}
return 
```
<Overlap Ratio: 0.989345509893455>

---

--- 92 --
Question ID: 89c63dbc75c5371dfc23a384a317e06219cf2614_1
Original Code:
```
FBCALL FBTHREAD *fb_ThreadCreate( FB_THREADPROC proc, void *param, ssize_t stack_size )
{
	NTSTATUS status;
	FBTHREAD *thread;
	FBTHREADINFO *info;

	thread = (FBTHREAD *)malloc( sizeof( FBTHREAD ) );
	if( thread == NULL ) {
		return NULL;
	}

	info = (FBTHREADINFO *)malloc( sizeof( FBTHREADINFO ) );
	if( info == NULL ) {
		free( thread );
		return NULL;
	}

	info->proc = proc;
	info->param = param;
	info->thread = thread;
	thread->flags = 0;

	status = PsCreateSystemThreadEx( &thread->id, /* ThreadHandle */
	                                 0,           /* ThreadExtraSize */
	                                 /* stack_size??? */ 65536,       /* KernelStackSize */
	                                 0,           /* TlsDataSize */
	                                 NULL,        /* ThreadId */
	                                 info,        /* StartContext1 */
	                                 NULL,        /* StartContext2 */
	                                 FALSE,       /* CreateSuspended */
	                                 FALSE,       /* DebugStack */
	                                 threadproc); /* StartRoutine */

	if( status != STATUS_SUCCESS ) {
		free( thread );
		free( info );
		return NULL;
	}

	return thread;
}
```


Overlapping Code:
```
ThreadCreate( FB_THREADPROC proc, void *param, ssize_t stack_size )
{
NTSTATUS status;
FBTHREAD *thread;
FBTHREADINFO *info;
thread = (FBTHREAD *)malloc( sizeof( FBTHREAD ) );
if( thread == NULL ) {
return NULL;
}
info = (FBTHREADINFO *)malloc( sizeof( FBTHREADINFO ) );
if( info == NULL ) {
free( thread );
return NULL;
}
info->proc = proc;
info->param = param;
info->thread = thread;
thread->flags = 0;
status = PsCreateSystemThreadEx( &thread->id, /* ThreadHandle */
0, /* ThreadExtraSize */
/* stack_size??? */ 65536, /* KernelStackSize */
0, /* TlsDataSize */
NULL, /* ThreadId */
info, /* StartContext1 */
NULL, /* StartContext2 */
FALSE, /* CreateSuspended */
FALSE, /* DebugStack */
threadproc); /* StartRoutine */
if( status != STATUS_SUCCESS ) {
free( thread );
free( info );
return NULL;
}
return thread;
```
<Overlap Ratio: 0.973715651135006>

---

--- 93 --
Question ID: 9e3f455c80da14c39e378d8b8ba9eea241191ecd_0
Original Code:
```
const char *repeatTypeName(u8 type) {
    switch ((enum RepeatType)type) {
    case REPEAT_RING:
        return "RING";
    case REPEAT_FIRST:
        return "FIRST";
    case REPEAT_LAST:
        return "LAST";
    case REPEAT_RANGE:
        return "RANGE";
    case REPEAT_BITMAP:
        return "BITMAP";
    case REPEAT_SPARSE_OPTIMAL_P:
        return "SPARSE_OPTIMAL_P";
    case REPEAT_TRAILER:
        return "TRAILER";
    case REPEAT_ALWAYS:
        return "ALWAYS";
    }
    assert(0);
    return "UNKNOWN";
}
```


Overlapping Code:
```
e) {
switch ((enum RepeatType)type) {
case REPEAT_RING:
return "RING";
case REPEAT_FIRST:
return "FIRST";
case REPEAT_LAST:
return "LAST";
case REPEAT_RANGE:
return "RANGE";
case REPEAT_BITMAP:
return "BITMAP";
case REPEAT_SPARSE_OPTIMAL_P:
return "SPARSE_OPTIMAL_P";
case REPEAT_TRAILER:
return "TRAILER";
case REPEAT_ALWAYS:
return "ALWAYS";
}
asse
```
<Overlap Ratio: 0.8557457212713936>

---

--- 94 --
Question ID: dc184261603664763c05aff15a93a7b540674da9_0
Original Code:
```
int
main(int argc, char *argv[])
{
    int       i, driver = DB_PDB;
    double    time;
    int       cycle;
    int       show_all_errors = FALSE;

    for (i=1; i<argc; i++) {
        if (!strncmp(argv[i], "DB_PDB", 6)) {
            driver = StringToDriver(argv[i]);
        } else if (!strncmp(argv[i], "DB_HDF5", 7)) {
            driver = StringToDriver(argv[i]);
        } else if (!strcmp(argv[i], "hzip")) {
            DBSetCompression("METHOD=HZIP");
            driver = DB_HDF5;
        } else if (!strcmp(argv[i], "fpzip")) {
            DBSetCompression("METHOD=FPZIP");
            driver = DB_HDF5;
        } else if (!strcmp(argv[i], "zfp")) {
            char msg[256];
            double rate = strtod(argv[++i],0);
            snprintf(msg, sizeof(msg), "METHOD=ZFP RATE=%g", rate);
            DBSetCompression(msg);
            driver = DB_HDF5;
        } else if (!strcmp(argv[i], "show-all-errors")) {
            show_all_errors = 1;
	} else if (argv[i][0] != '\0') {
            fprintf(stderr, "%s: ignored argument `%s'\n", argv[0], argv[i]);
        }
    }

    if (show_all_errors) DBShowErrors(DB_ALL_AND_DRVR, 0);

    for (i = 0; i < NT + 1; i++)
    {
        time = T0 + ((double)i / (double)NT) * DT;
        cycle = i * 10;
        SWriteFile (time, cycle, driver);
    }

    DBSetCompression(0);
    CleanupDriverStuff();
    return 0;
}
```


Overlapping Code:
```
[])
{
int i, driver = DB_PDB;
double time;
int cycle;
int show_all_errors = FALSE;
for (i=1; i<argc; i++) {
if (!strncmp(argv[i], "DB_PDB", 6)) {
driver = StringToDriver(argv[i]);
} else if (!strncmp(argv[i], "DB_HDF5", 7)) {
driver = StringToDriver(argv[i]);
} else if (!strcmp(argv[i], "hzip")) {
DBSetCompression("METHOD=HZIP");
driver = DB_HDF5;
} else if (!strcmp(argv[i], "fpzip")) {
DBSetCompression("METHOD=FPZIP");
driver = DB_HDF5;
} else if (!strcmp(argv[i], "zfp")) {
char msg[256];
double rate = strtod(argv[++i],0);
snprintf(msg, sizeof(msg), "METHOD=ZFP RATE=%g", rate);
DBSetCompression(msg);
driver = DB_HDF5;
} else if (!strcmp(argv[i], "show-all-errors")) {
show_all_errors = 1;
} else if (argv[i][0] != '\0') {
fprintf(stderr, "%s: ignored argument `%s'\n", argv[0], argv[i]);
}
}
if (show_all_errors) DBShowErrors(DB_ALL_AND_DRVR, 0);
for (i = 0; i < NT + 1; i++)
{
time = T0 + ((double)i / (double)NT) * DT;
cycle = i * 10;
SWriteFile (time, cycle, driver);
}
DBSetCompression(0
```
<Overlap Ratio: 0.9389671361502347>

---

--- 95 --
Question ID: b6c546f1879525b5e321dce924f62786657bd8c7_342
Original Code:
```
int vehicle_rt_dl1_mk3_measure_time_4_pack(
    uint8_t *dst_p,
    const struct vehicle_rt_dl1_mk3_measure_time_4_t *src_p,
    size_t size)
{
    if (size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u32(src_p->measured_time_4, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->measured_time_4, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->measured_time_4, 16u, 0xffu);

    return (3);
}
```


Overlapping Code:
```
hicle_rt_dl1_mk3_measure_time_4_pack(
uint8_t *dst_p,
const struct vehicle_rt_dl1_mk3_measure_time_4_t *src_p,
size_t size)
{
if (size < 3u) {
return (-EINVAL);
}
memset(&dst_p[0], 0, 3);
dst_p[0] |= pack_left_shift_u32(src_p->measured_time_4, 0u, 0xffu);
dst_p[1] |= pack_right_shift_u32(src_p->measured_time_4, 8u, 0xffu);
dst_p[2] |= pack_right_shift_u32(src_p->measured_time_4, 16u, 0xffu);
retur
```
<Overlap Ratio: 0.966183574879227>

---

--- 96 --
Question ID: d336276769d4f6a40f34014279d12a46fa43731e_28
Original Code:
```
STATIC_OVL int
try_disarm(ttmp, force_failure)
struct trap *ttmp;
boolean force_failure;
{
	struct monst *mtmp = m_at(ttmp->tx,ttmp->ty);
	int ttype = ttmp->ttyp;
	boolean under_u = (!u.dx && !u.dy);
	boolean holdingtrap = (ttype == BEAR_TRAP || ttype == WEB);
	
	/* Test for monster first, monsters are displayed instead of trap. */
	if (mtmp && (!mtmp->mtrapped || !holdingtrap)) {
		pline("%s is in the way.", Monnam(mtmp));
		return 0;
	}
	/* We might be forced to move onto the trap's location. */
	if (sobj_at(BOULDER, ttmp->tx, ttmp->ty)
				&& !Passes_walls && !under_u) {
		There("is a boulder in your way.");
		return 0;
	}
	/* duplicate tight-space checks from test_move */
	if (u.dx && u.dy &&
	    bad_rock(youmonst.data,u.ux,ttmp->ty) &&
	    bad_rock(youmonst.data,ttmp->tx,u.uy)) {
	    if ((invent && (inv_weight() + weight_cap() > 600)) ||
		bigmonst(youmonst.data)) {
		/* don't allow untrap if they can't get thru to it */
		You("are unable to reach the %s!",
		    defsyms[trap_to_defsym(ttype)].explanation);
		return 0;
	    }
	}
	/* untrappable traps are located on the ground. */
	if (!can_reach_floor()) {
#ifdef STEED
		if (u.usteed && P_SKILL(P_RIDING) < P_BASIC)
			You("aren't skilled enough to reach from %s.",
				mon_nam(u.usteed));
		else
#endif
		You("are unable to reach the %s!",
			defsyms[trap_to_defsym(ttype)].explanation);
		return 0;
	}

	/* Will our hero succeed? */
	if (force_failure || untrap_prob(ttmp)) {
		if (rnl(5)) {
		    pline("Whoops...");
		    if (mtmp) {		/* must be a trap that holds monsters */
			if (ttype == BEAR_TRAP) {
			    if (mtmp->mtame) abuse_dog(mtmp);
			    if ((mtmp->mhp -= rnd(4)) <= 0) killed(mtmp);
			} else if (ttype == WEB) {
			    if (!webmaker(youmonst.data)) {
				struct trap *ttmp2 = maketrap(u.ux, u.uy, WEB);
				if (ttmp2) {
				    pline_The("webbing sticks to you. You're caught too!");
				    dotrap(ttmp2, NOWEBMSG);
#ifdef STEED
				    if (u.usteed && u.utrap) {
					/* you, not steed, are trapped */
					dismount_steed(DISMOUNT_FELL);
				    }
#endif
				}
			    } else
				pline("%s remains entangled.", Monnam(mtmp));
			}
		    } else if (under_u) {
			dotrap(ttmp, 0);
		    } else {
			move_into_trap(ttmp);
		    }
		} else {
		    pline("%s %s is difficult to %s.",
			  ttmp->madeby_u ? "Your" : under_u ? "This" : "That",
			  defsyms[trap_to_defsym(ttype)].explanation,
			  (ttype == WEB) ? "remove" : "disarm");
		}
		return 1;
	}
	return 2;
}
```


Overlapping Code:
```
struct trap *ttmp;
boolean force_failure;
{
struct monst *mtmp = m_at(ttmp->tx,ttmp->ty);
int ttype = ttmp->ttyp;
boolean under_u = (!u.dx && !u.dy);
boolean holdingtrap = (ttype == BEAR_TRAP || ttype == WEB);

/* Test for monster first, monsters are displayed instead of trap. */
if (mtmp && (!mtmp->mtrapped || !holdingtrap)) {
pline("%s is in the way.", Monnam(mtmp));
return 0;
}
/* We might be forced to move onto the trap's location. */
if (sobj_at(BOULDER, ttmp->tx, ttmp->ty)
&& !Passes_walls && !under_u) {
There("is a boulder in your way.");
return 0;
}
/* duplicate tight-space checks from test_move */
if (u.dx && u.dy &&
bad_rock(youmonst.data,u.ux,ttmp->ty) &&
bad_rock(youmonst.data,ttmp->tx,u.uy)) {
if ((invent && (inv_weight() + weight_cap() > 600)) ||
bigmonst(youmonst.data)) {
/* don't allow untrap if they can't get thru to it */
You("are unable to reach the %s!",
defsyms[trap_to_defsym(ttype)].explanation);
return 0;
}
}
/* untrappable traps are located on the ground. */
if (!can_reach_floor()) {
#ifdef STEED
if (u.usteed && P_SKILL(P_RIDING) < P_BASIC)
You("aren't skilled enough to reach from %s.",
mon_nam(u.usteed));
else
#endif
You("are unable to reach the %s!",
defsyms[trap_to_defsym(ttype)].explanation);
return 0;
}
/* Will our hero succeed? */
if (force_failure || untrap_prob(ttmp)) {
if (rnl(5)) {
pline("Whoops...");
if (mtmp) { /* must be a trap that holds monsters */
if (ttype == BEAR_TRAP) {
if (mtmp->mtame) abuse_dog(mtmp);
if ((mtmp->mhp -= rnd(4)) <= 0) killed(mtmp);
} else if (ttype == WEB) {
if (!webmaker(youmonst.data)) {
struct trap *ttmp2 = maketrap(u.ux, u.uy, WEB);
if (ttmp2) {
pline_The("webbing sticks to you. You're caught too!");
dotrap(ttmp2, NOWEBMSG);
#ifdef STEED
if (u.usteed && u.utrap) {
/* you, not steed, are trapped */
dismount_steed(DISMOUNT_FELL);
}
#endif
}
} else
pline("%s remains entangled.", Monnam(mtmp));
}
} else if (under_u) {
dotrap(ttmp, 0);
} else {
move_into_trap(ttmp);
}
} else {
pline("%s %s is difficult to %s.",
ttmp->madeby_u ? "Your" : under_u ? "This" : "That",
defsyms[trap_to_defsym(ttype)].explanation,
(ttype == WEB) ? "remove" : "disarm");
}
return 1;
}
```
<Overlap Ratio: 0.9733273056057866>

---

--- 97 --
Question ID: b8d336cf6e3d78126ba13ebe752a046b794bbe49_4
Original Code:
```
static void _plog_strncat_attribute(char *buffer, size_t n, const plog_attribute_data_t *data)
{
#define ATTR_TEXT_MAX 65
    char  text[ATTR_TEXT_MAX + 1];
    char *text_ptr = text;

    text[0] = '\0';

    if ((uint64_t) 1 << data->attribute_type & VALID_UINT_ATTRS) {
        sprintf(text, "%"PRIu64, data->value.uint_val);
    } else if ((uint64_t) 1 << data->attribute_type & (VALID_STRING_ATTRS | VALID_TRACE_ATTRS)) {
        text_ptr = data->value.string_val;
    } else if ((uint64_t) 1 << data->attribute_type & VALID_REF_ATTRS) {
        _plog_strncat_id(text, ATTR_TEXT_MAX, &data->value.ref_val);
    }

    strncat(buffer, text_ptr, n);
}
```


Overlapping Code:
```
ar *buffer, size_t n, const plog_attribute_data_t *data)
{
#define ATTR_TEXT_MAX 65
char text[ATTR_TEXT_MAX + 1];
char *text_ptr = text;
text[0] = '\0';
if ((uint64_t) 1 << data->attribute_type & VALID_UINT_ATTRS) {
sprintf(text, "%"PRIu64, data->value.uint_val);
} else if ((uint64_t) 1 << data->attribute_type & (VALID_STRING_ATTRS | VALID_TRACE_ATTRS)) {
text_ptr = data->value.string_val;
} else if ((uint64_t) 1 << data->attribute_type & VALID_REF_ATTRS) {
_plog_strncat_id(text, ATTR_TEXT_MAX, &data->value.ref_val);
}
strncat(buffer, text_ptr,
```
<Overlap Ratio: 0.9259259259259259>

---

--- 98 --
Question ID: 6c4131666ff81ab4673d2d4f32ba427d6a6c8f70_307
Original Code:
```
static uint64_t
kblgt3__compute_l3_cache__gti_write_throughput__read(struct brw_context *brw,
                                                     const struct brw_perf_query_info *query,
                                                     uint64_t *accumulator)
{
   /* RPN equation: C 7 READ 64 UMUL */
   uint64_t tmp0 = accumulator[query->c_offset + 7];
   uint64_t tmp1 = tmp0 * 64;

   return tmp1;
}
```


Overlapping Code:
```
mpute_l3_cache__gti_write_throughput__read(struct brw_context *brw,
const struct brw_perf_query_info *query,
uint64_t *accumulator)
{
/* RPN equation: C 7 READ 64 UMUL */
uint64_t tmp0 = accumulator[query->c_offset + 7];
uint64_t tmp1 = tmp0 * 64;
return tmp1;
}
```
<Overlap Ratio: 0.9097222222222222>

---

--- 99 --
Question ID: 29f2a2b76c71e80348a4399f3171c44f3b818e17_5
Original Code:
```
DFL_FUNC uint64_t uint64_t_avx2_gather_dfl_glob_load(unsigned char* obj, unsigned char* ptr, unsigned long field_off, unsigned long field_size) { 
    // set the index vector to 0,1,2,3 "little" endian
    // so that 0 is in index[0:31], ecc
    __m256i index = _mm256_setr_epi64x(0*DFL_STRIDE, 1*DFL_STRIDE, 2*DFL_STRIDE, 3*DFL_STRIDE);
    __m256i res   = _mm256_setzero_si256();

    __m256i target    = _mm256_set1_epi64x((unsigned long) ptr);
    __m256i increment = _mm256_set1_epi64x(4*DFL_STRIDE);

    unsigned long cache_off = ((unsigned long) ptr) & (DFL_STRIDE-1uL);

    unsigned char* aligned_obj = (unsigned char*)(((unsigned long)obj + field_off) & ~(DFL_STRIDE - 1));

    field_size += (((unsigned long)obj + field_off) - (unsigned long)aligned_obj);
    field_size = ((field_size + 4*DFL_STRIDE - 1) / (4*DFL_STRIDE)) * 4*DFL_STRIDE;
    unsigned char* _end =  aligned_obj + field_size;

    DEBUG("GLOB AVX2 LOAD: %p - size: %lu - ptr: %p - sizeof: %lu\n", obj, field_size, ptr, sizeof(unsigned long));

    // initialize the current avx ptrs for each iteration
    __m256i current = _mm256_set1_epi64x((unsigned long) aligned_obj + cache_off);
    current  = _mm256_add_epi64(current, index);

    for(volatile unsigned char* _ptr = aligned_obj + cache_off; _ptr < _end; _ptr = _ptr + 4*DFL_STRIDE) {
        // the mask will select which value will get actually loaded
        __m256i mask = _mm256_cmpeq_epi64(target, current);
        current = _mm256_add_epi64(current, increment);
        __m256i loaded = _mm256_i64gather_epi64(_ptr, index, 1);
        res = _mm256_blendv_epi8(res, loaded, mask);
    }
    return mm256_hadd_to_64(res);
}
```


Overlapping Code:
```
2_gather_dfl_glob_load(unsigned char* obj, unsigned char* ptr, unsigned long field_off, unsigned long field_size) { 
// set the index vector to 0,1,2,3 "little" endian
// so that 0 is in index[0:31], ecc
__m256i index = _mm256_setr_epi64x(0*DFL_STRIDE, 1*DFL_STRIDE, 2*DFL_STRIDE, 3*DFL_STRIDE);
__m256i res = _mm256_setzero_si256();
__m256i target = _mm256_set1_epi64x((unsigned long) ptr);
__m256i increment = _mm256_set1_epi64x(4*DFL_STRIDE);
unsigned long cache_off = ((unsigned long) ptr) & (DFL_STRIDE-1uL);
unsigned char* aligned_obj = (unsigned char*)(((unsigned long)obj + field_off) & ~(DFL_STRIDE - 1));
field_size += (((unsigned long)obj + field_off) - (unsigned long)aligned_obj);
field_size = ((field_size + 4*DFL_STRIDE - 1) / (4*DFL_STRIDE)) * 4*DFL_STRIDE;
unsigned char* _end = aligned_obj + field_size;
DEBUG("GLOB AVX2 LOAD: %p - size: %lu - ptr: %p - sizeof: %lu\n", obj, field_size, ptr, sizeof(unsigned long));
// initialize the current avx ptrs for each iteration
__m256i current = _mm256_set1_epi64x((unsigned long) aligned_obj + cache_off);
current = _mm256_add_epi64(current, index);
for(volatile unsigned char* _ptr = aligned_obj + cache_off; _ptr < _end; _ptr = _ptr + 4*DFL_STRIDE) {
// the mask will select which value will get actually loaded
__m256i mask = _mm256_cmpeq_epi64(target, current);
current = _mm256_add_epi64(current, increment);
__m256i loaded = _mm256_i64gather_epi64(_ptr, index, 1);
res = _mm256_blendv_epi8(res, loaded, mask);
}
return mm256_ha
```
<Overlap Ratio: 0.9701298701298702>

---

--- 100 --
Question ID: f61df6f906d47708ec40ee63fea897f3952f8d9c_10
Original Code:
```
void BIG_384_29_fromBytesLen(BIG_384_29 a, char *b, int s)
{
    int i, len = s;
    BIG_384_29_zero(a);

    if (len > MODBYTES_384_29) len = MODBYTES_384_29;
    for (i = 0; i < len; i++)
    {
        BIG_384_29_fshl(a, 8);
        a[0] += (int)(unsigned char)b[i];
    }
#ifdef DEBUG_NORM
    a[MPV_384_29] = 1;
    a[MNV_384_29] = 0;
#endif
}
```


Overlapping Code:
```
fromBytesLen(BIG_384_29 a, char *b, int s)
{
int i, len = s;
BIG_384_29_zero(a);
if (len > MODBYTES_384_29) len = MODBYTES_384_29;
for (i = 0; i < len; i++)
{
BIG_384_29_fshl(a, 8);
a[0] += (int)(unsigned char)b[i];
}
#ifdef DEBUG_NORM
a[MPV_384_29] 
```
<Overlap Ratio: 0.8389261744966443>

---

--- 101 --
Question ID: d0452b58f888f4c8a5f95ffb89d1ae55f278b4ee_0
Original Code:
```
static void
printflags(U2 flags, int type)
{
	static struct {
		char *s;
		U2 flag;
		int type;
	} flagstab[] = {
		{"ACC_PUBLIC",       0x0001, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_PRIVATE",      0x0002,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_PROTECTED",    0x0004,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_STATIC",       0x0008,              TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_FINAL",        0x0010, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_SUPER",        0x0020, TYPE_CLASS                                         },
		{"ACC_SYNCHRONIZED", 0x0020,                           TYPE_METHOD              },
		{"ACC_VOLATILE",     0x0040,              TYPE_FIELD                            },
		{"ACC_BRIDGE",       0x0040,                           TYPE_METHOD              },
		{"ACC_TRANSIENT",    0x0080,              TYPE_FIELD                            },
		{"ACC_VARARGS",      0x0080,                           TYPE_METHOD              },
		{"ACC_NATIVE",       0x0100,                           TYPE_METHOD              },
		{"ACC_INTERFACE",    0x0200, TYPE_CLASS                            | TYPE_INNER },
		{"ACC_ABSTRACT",     0x0400, TYPE_CLASS              | TYPE_METHOD | TYPE_INNER },
		{"ACC_STRICT",       0x0800,                           TYPE_METHOD              },
		{"ACC_SYNTHETIC",    0x1000, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
		{"ACC_ANNOTATION",   0x2000, TYPE_CLASS                            | TYPE_INNER },
		{"ACC_ENUM",         0x4000, TYPE_CLASS | TYPE_FIELD               | TYPE_INNER }
	};
	int p = 0;      /* whether a flag was printed */
	size_t i;

	printf("flags: (0x%04X) ", flags);
	for (i = 0; i < LEN(flagstab); i++) {
		if (flags & flagstab[i].flag && flagstab[i].type & type) {
			if (p)
				printf(", ");
			printf("%s", flagstab[i].s);
			p = 1;
		}
	}
	putchar('\n');
}
```


Overlapping Code:
```
tatic struct {
char *s;
U2 flag;
int type;
} flagstab[] = {
{"ACC_PUBLIC", 0x0001, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_PRIVATE", 0x0002, TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_PROTECTED", 0x0004, TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_STATIC", 0x0008, TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_FINAL", 0x0010, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_SUPER", 0x0020, TYPE_CLASS },
{"ACC_SYNCHRONIZED", 0x0020, TYPE_METHOD },
{"ACC_VOLATILE", 0x0040, TYPE_FIELD },
{"ACC_BRIDGE", 0x0040, TYPE_METHOD },
{"ACC_TRANSIENT", 0x0080, TYPE_FIELD },
{"ACC_VARARGS", 0x0080, TYPE_METHOD },
{"ACC_NATIVE", 0x0100, TYPE_METHOD },
{"ACC_INTERFACE", 0x0200, TYPE_CLASS | TYPE_INNER },
{"ACC_ABSTRACT", 0x0400, TYPE_CLASS | TYPE_METHOD | TYPE_INNER },
{"ACC_STRICT", 0x0800, TYPE_METHOD },
{"ACC_SYNTHETIC", 0x1000, TYPE_CLASS | TYPE_FIELD | TYPE_METHOD | TYPE_INNER },
{"ACC_ANNOTATION", 0x2000, TYPE_CLASS | TYPE_INNER },
{"ACC_ENUM", 0x4000, TYPE_CLASS | TYPE_FIELD | TYPE_INNER }
};
int p = 0; /* whether a flag was printed */
size_t i;
printf("flags: (0x%04X) ", flags);
for (i = 0; i < LEN(flagstab); i++) {
if (flags & flagstab[i].flag && flagstab[i].type & type) {
if (p)
printf(", ");
printf("%s", flagstab[i].s);
p = 1;
}
}
putchar('\n');
}
```
<Overlap Ratio: 0.9658246656760773>

---

--- 102 --
Question ID: 681c6a441320e2a985c973416c4ef5a1fe21dd1c_1
Original Code:
```
static OSStatus     audioCallback (void                            *inRefCon,
                                   AudioUnitRenderActionFlags      *ioActionFlags,
                                   const AudioTimeStamp            *inTimeStamp,
                                   UInt32                          inBusNumber,
                                   UInt32                          inNumberFrames,
                                   AudioBufferList                 *ioData)
{
    SDL_AudioDevice *this = (SDL_AudioDevice *)inRefCon;
    UInt32 remaining, len;
    AudioBuffer *abuf;
    void *ptr;
    UInt32 i;

    /* Only do anything if audio is enabled and not paused */
    if ( ! this->enabled || this->paused ) {
        for (i = 0; i < ioData->mNumberBuffers; i++) {
            abuf = &ioData->mBuffers[i];
            SDL_memset(abuf->mData, this->spec.silence, abuf->mDataByteSize);
        }
        return 0;
    }
    
    /* No SDL conversion should be needed here, ever, since we accept
       any input format in OpenAudio, and leave the conversion to CoreAudio.
     */
    /*
    assert(!this->convert.needed);
    assert(this->spec.channels == ioData->mNumberChannels);
     */

    for (i = 0; i < ioData->mNumberBuffers; i++) {
        abuf = &ioData->mBuffers[i];
        remaining = abuf->mDataByteSize;
        ptr = abuf->mData;
        while (remaining > 0) {
            if (bufferOffset >= bufferSize) {
                /* Generate the data */
                SDL_memset(buffer, this->spec.silence, bufferSize);
                SDL_mutexP(this->mixer_lock);
                (*this->spec.callback)(this->spec.userdata,
                            buffer, bufferSize);
                SDL_mutexV(this->mixer_lock);
                bufferOffset = 0;
            }
        
            len = bufferSize - bufferOffset;
            if (len > remaining)
                len = remaining;
            SDL_memcpy(ptr, (char *)buffer + bufferOffset, len);
            ptr = (char *)ptr + len;
            remaining -= len;
            bufferOffset += len;
        }
    }

    return 0;
}
```


Overlapping Code:
```
Status audioCallback (void *inRefCon,
AudioUnitRenderActionFlags *ioActionFlags,
const AudioTimeStamp *inTimeStamp,
UInt32 inBusNumber,
UInt32 inNumberFrames,
AudioBufferList *ioData)
{
SDL_AudioDevice *this = (SDL_AudioDevice *)inRefCon;
UInt32 remaining, len;
AudioBuffer *abuf;
void *ptr;
UInt32 i;
/* Only do anything if audio is enabled and not paused */
if ( ! this->enabled || this->paused ) {
for (i = 0; i < ioData->mNumberBuffers; i++) {
abuf = &ioData->mBuffers[i];
SDL_memset(abuf->mData, this->spec.silence, abuf->mDataByteSize);
}
return 0;
}

/* No SDL conversion should be needed here, ever, since we accept
any input format in OpenAudio, and leave the conversion to CoreAudio.
*/
/*
assert(!this->convert.needed);
assert(this->spec.channels == ioData->mNumberChannels);
*/
for (i = 0; i < ioData->mNumberBuffers; i++) {
abuf = &ioData->mBuffers[i];
remaining = abuf->mDataByteSize;
ptr = abuf->mData;
while (remaining > 0) {
if (bufferOffset >= bufferSize) {
/* Generate the data */
SDL_memset(buffer, this->spec.silence, bufferSize);
SDL_mutexP(this->mixer_lock);
(*this->spec.callback)(this->spec.userdata,
buffer, bufferSize);
SDL_mutexV(this->mixer_lock);
bufferOffset = 0;
}

len = bufferSize - bufferOffset;
if (len > remaining)
len = remaining;
SDL_memcpy(ptr, (char *)buffer + bufferOffset, len);
ptr = (char *)ptr + len;
remaining -= len;
bufferOffset += len;
}
}
return 0;

```
<Overlap Ratio: 0.9929078014184397>

---

--- 103 --
Question ID: b796717562bfbab3e01408f27470e15550478e69_0
Original Code:
```
void
mpz_lcm_ui (mpz_ptr r, mpz_srcptr u, mpir_ui v)
{
  mp_size_t      usize;
  mp_srcptr      up;
  mp_ptr         rp;
  mpir_ui         g;
  mp_limb_t      c;

#if BITS_PER_UI > GMP_NUMB_BITS  /* avoid warnings about shift amount */
  if (v > GMP_NUMB_MAX)
    {
      mpz_t vz;
      mp_limb_t vlimbs[2];
      vlimbs[0] = v & GMP_NUMB_MASK;
      vlimbs[1] = v >> GMP_NUMB_BITS;
      PTR(vz) = vlimbs;
      SIZ(vz) = 2;
      mpz_lcm (r, u, vz);
      return;
    }
#endif

  /* result zero if either operand zero */
  usize = SIZ(u);
  if (usize == 0 || v == 0)
    {
      SIZ(r) = 0;
      return;
    }
  usize = ABS(usize);

  MPZ_REALLOC (r, usize+1);

  up = PTR(u);
  g = (mpir_ui) mpn_gcd_1 (up, usize, (mp_limb_t) v);
  v /= g;

  rp = PTR(r);
  c = mpn_mul_1 (rp, up, usize, (mp_limb_t) v);
  rp[usize] = c;
  usize += (c != 0);
  SIZ(r) = usize;
}
```


Overlapping Code:
```
ui v)
{
mp_size_t usize;
mp_srcptr up;
mp_ptr rp;
mpir_ui g;
mp_limb_t c;
#if BITS_PER_UI > GMP_NUMB_BITS /* avoid warnings about shift amount */
if (v > GMP_NUMB_MAX)
{
mpz_t vz;
mp_limb_t vlimbs[2];
vlimbs[0] = v & GMP_NUMB_MASK;
vlimbs[1] = v >> GMP_NUMB_BITS;
PTR(vz) = vlimbs;
SIZ(vz) = 2;
mpz_lcm (r, u, vz);
return;
}
#endif
/* result zero if either operand zero */
usize = SIZ(u);
if (usize == 0 || v == 0)
{
SIZ(r) = 0;
return;
}
usize = ABS(usize);
MPZ_REALLOC (r, usize+1);
up = PTR(u);
g = (mpir_ui) mpn_gcd_1 (up, usize, (mp_limb_t) v);
v /= g;
rp = PTR(r);
c = mpn_mul_1 (rp, up, usize, (mp_limb_t) v);
rp[usize] = c;
usize += (c != 0);
SIZ(r) = usize;

```
<Overlap Ratio: 0.9328671328671329>

---

--- 104 --
Question ID: 7a0b0daf128a40f13dc3715c88b0211ff932cf80_48
Original Code:
```
static uint32_t calc_checksum(KOS_OBJ_ID obj)
{
    CHECKSUMMED_OPAQUE *opaque = (CHECKSUMMED_OPAQUE *)OBJPTR(OPAQUE, obj);
    uint8_t            *ptr    = &opaque->data[0];
    uint8_t            *end;
    uint32_t            size;
    uint32_t            checksum = ~0U;

    size = kos_get_object_size(opaque->header) - sizeof(CHECKSUMMED_OPAQUE) + 1;
    end  = ptr + size;

    do {
        const uint32_t b = *(ptr++);
        checksum -= b;
    } while (ptr != end);

    return checksum;
}
```


Overlapping Code:
```
t32_t calc_checksum(KOS_OBJ_ID obj)
{
CHECKSUMMED_OPAQUE *opaque = (CHECKSUMMED_OPAQUE *)OBJPTR(OPAQUE, obj);
uint8_t *ptr = &opaque->data[0];
uint8_t *end;
uint32_t size;
uint32_t checksum = ~0U;
size = kos_get_object_size(opaque->header) - sizeof(CHECKSUMMED_OPAQUE) + 1;
end = ptr + size;
do {
const uint32_t b = *(ptr++);
checksum -= b;
} while (
```
<Overlap Ratio: 0.8951406649616368>

---

--- 105 --
Question ID: 3a4fc751018ab55c16c07b9fd757022fd64eabc8_7
Original Code:
```
static void event_net_change(void *arg)
{
	sys_mqtt_t *s = arg;

	if (a_network_is_up()) {
		if (s->mqtt_connected) {
			s->mqtt_connected = WICED_FALSE;
			mqtt_app_close(s);
		}

		if (mqtt_app_open(s) == WICED_SUCCESS) {
			s->mqtt_connected = WICED_TRUE;
		} else {
			uint32_t tout = MQTT_RECONNECT_TIMEOUT +
				((uint32_t)rand() % MQTT_RECONNECT_RANDOM_WINDOW);
			wiced_log_msg(WLF_DEF, WICED_LOG_INFO, "Retry after %d ms\n", tout);
			a_eventloop_register_timer(s->evt, &s->retry_timer_node,
						   mqtt_retry_cb, tout, s);
		}
	} else {
		a_eventloop_deregister_timer(s->evt, &s->retry_timer_node);
		if (s->mqtt_connected) {
			s->mqtt_connected = WICED_FALSE;
			mqtt_app_close(s);
		}
	}

	if (s->net_event_cb)
		(*s->net_event_cb)(a_network_is_up(), s->mqtt_connected, s->arg);
}
```


Overlapping Code:
```
static void event_net_change(void *arg)
{
sys_mqtt_t *s = arg;
if (a_network_is_up()) {
if (s->mqtt_connected) {
s->mqtt_connected = WICED_FALSE;
mqtt_app_close(s);
}
if (mqtt_app_open(s) == WICED_SUCCESS) {
s->mqtt_connected = WICED_TRUE;
} else {
uint32_t tout = MQTT_RECONNECT_TIMEOUT +
((uint32_t)rand() % MQTT_RECONNECT_RANDOM_WINDOW);
wiced_log_msg(WLF_DEF, WICED_LOG_INFO, "Retry after %d ms\n", tout);
a_eventloop_register_timer(s->evt, &s->retry_timer_node,
mqtt_retry_cb, tout, s);
}
} else {
a_eventloop_deregister_timer(s->evt, &s->retry_timer_node);
if (s->mqtt_connected) {
s->mqtt_connected = WICED_FALSE;
mqtt_app_close(s);
}
}
if (s->net_event_cb)
(*s->net_event_cb)(a_network_is_up(
```
<Overlap Ratio: 0.9562841530054644>

---

--- 106 --
Question ID: a49645ae86bf99e5cda68b101fefd162f7f6fac6_0
Original Code:
```
static unsigned int radix_tree_descend(exploit_context* pCtx, const struct radix_tree_node *parent,
            struct radix_tree_node **nodep, unsigned long index)
{
    unsigned int offset = 0;
    void **entry = NULL;
    struct radix_tree_node node_in = {0};

    kernel_read(pCtx, (uint64_t)parent, (char*)&node_in, sizeof(node_in));
    offset = (index >> node_in.shift) & RADIX_TREE_MAP_MASK;

    entry = node_in.slots[offset];

    *nodep = (void *)entry;
    return offset;
}
```


Overlapping Code:
```
gned int radix_tree_descend(exploit_context* pCtx, const struct radix_tree_node *parent,
struct radix_tree_node **nodep, unsigned long index)
{
unsigned int offset = 0;
void **entry = NULL;
struct radix_tree_node node_in = {0};
kernel_read(pCtx, (uint64_t)parent, (char*)&node_in, sizeof(node_in));
offset = (index >> node_in.shift) & RADIX_TREE_MAP_MASK;
entry = node_in.slots[offset];
*nodep = (void *)entry;
return offset
```
<Overlap Ratio: 0.9680365296803652>

---

--- 107 --
Question ID: 443274b42fd955c69d69988da21e08da3f9d6c9c_3
Original Code:
```
inline PDBResidue *PDBChain:: 
FindResidue(const char *str) const
{
  // Find residue matching string
  PDBResidue *residue = NULL;
  if (FindAny(str, &residue, NULL, PDB_RESIDUE) == PDB_RESIDUE) return residue;
  else return NULL;
}
```


Overlapping Code:
```
:: 
FindResidue(const char *str) const
{
// Find residue matching string
PDBResidue *residue = NULL;
if (FindAny(str, &residue, NULL, PDB_RESIDUE) == PDB_RESIDUE) return residue;
else return 
```
<Overlap Ratio: 0.8488888888888889>

---

--- 108 --
Question ID: 206b812b6e7bf34b78a74a32e4cafdb0ea1a1c91_1
Original Code:
```
static int ramfs_write(int fd, int from_pid, fsinfo_t* info,
		const void* buf, int size, int offset, void* p) {
	(void)fd;
	(void)from_pid;
	(void)p;

	if(offset < 0)
		offset = 0;
	if(size <= 0)
		return size;

	char* data = (char*)info->data;
	data = (char*)realloc(data, size + offset);
	memcpy(data+offset, buf, size);
	info->data = (uint32_t)data;
	info->size = size+offset;
	vfs_set(info);
	return size;
}
```


Overlapping Code:
```
tic int ramfs_write(int fd, int from_pid, fsinfo_t* info,
const void* buf, int size, int offset, void* p) {
(void)fd;
(void)from_pid;
(void)p;
if(offset < 0)
offset = 0;
if(size <= 0)
return size;
char* data = (char*)info->data;
data = (char*)realloc(data, size + offset);
memcpy(data+offset, buf, size);
info->data = (uint32_t)data;
info->size = siz
```
<Overlap Ratio: 0.8928571428571429>

---

--- 109 --
Question ID: a22b4392100d0a6a7e74c2e38a35b1fbaa91beae_6
Original Code:
```
DIGIT_T spDivide(DIGIT_T *q, DIGIT_T *r, const DIGIT_T u[2], DIGIT_T v) {    /*	Computes quotient q = u / v, remainder r = u mod v
		where u is a double digit
		and q, v, r are single precision digits.
		Returns high digit of quotient (max value is 1)
		CAUTION: Assumes normalised such that v1 >= b/2
		where b is size of HALF_DIGIT
		i.e. the most significant bit of v should be one

		In terms of half-digits in Knuth notation:
		(q2q1q0) = (u4u3u2u1u0) / (v1v0)
		(r1r0) = (u4u3u2u1u0) mod (v1v0)
		for m = 2, n = 2 where u4 = 0
		q2 is either 0 or 1.
		We set q = (q1q0) and return q2 as "overflow"
	*/
    DIGIT_T qhat, rhat, t, v0, v1, u0, u1, u2, u3;
    DIGIT_T uu[2], q2;

    /* Check for normalisation */
    if (!(v & HIBITMASK)) {    /* Stop if assert is working, else return error */
        assert(v & HIBITMASK);
        *q = *r = 0;
        return MAX_DIGIT;
    }

    /* Split up into half-digits */
    v0 = LOHALF(v);
    v1 = HIHALF(v);
    u0 = LOHALF(u[0]);
    u1 = HIHALF(u[0]);
    u2 = LOHALF(u[1]);
    u3 = HIHALF(u[1]);

    /* Do three rounds of Knuth Algorithm D Vol 2 p272 */

    /*	ROUND 1. Set j = 2 and calculate q2 */
    /*	Estimate qhat = (u4u3)/v1  = 0 or 1
        then set (u4u3u2) -= qhat(v1v0)
        where u4 = 0.
    */
/* [Replaced in Version 2] -->
	qhat = u3 / v1;
	if (qhat > 0)
	{
		rhat = u3 - qhat * v1;
		t = TOHIGH(rhat) | u2;
		if (qhat * v0 > t)
			qhat--;
	}
<-- */
    qhat = (u3 < v1 ? 0 : 1);
    if (qhat > 0) {    /* qhat is one, so no need to mult */
        rhat = u3 - v1;
        /* t = r.b + u2 */
        t = TOHIGH(rhat) | u2;
        if (v0 > t)
            qhat--;
    }

    uu[1] = 0;        /* (u4) */
    uu[0] = u[1];    /* (u3u2) */
    if (qhat > 0) {
        /* (u4u3u2) -= qhat(v1v0) where u4 = 0 */
        spMultSub(uu, qhat, v1, v0);
        if (HIHALF(uu[1]) != 0) {    /* Add back */
            qhat--;
            uu[0] += v;
            uu[1] = 0;
        }
    }
    q2 = qhat;

    /*	ROUND 2. Set j = 1 and calculate q1 */
    /*	Estimate qhat = (u3u2) / v1
        then set (u3u2u1) -= qhat(v1v0)
    */
    t = uu[0];
    qhat = t / v1;
    rhat = t - qhat * v1;
    /* Test on v0 */
    t = TOHIGH(rhat) | u1;
    if ((qhat == B) || (qhat * v0 > t)) {
        qhat--;
        rhat += v1;
        t = TOHIGH(rhat) | u1;
        if ((rhat < B) && (qhat * v0 > t))
            qhat--;
    }

    /*	Multiply and subtract
        (u3u2u1)' = (u3u2u1) - qhat(v1v0)
    */
    uu[1] = HIHALF(uu[0]);    /* (0u3) */
    uu[0] = TOHIGH(LOHALF(uu[0])) | u1;    /* (u2u1) */
    spMultSub(uu, qhat, v1, v0);
    if (HIHALF(uu[1]) != 0) {    /* Add back */
        qhat--;
        uu[0] += v;
        uu[1] = 0;
    }

    /* q1 = qhat */
    *q = TOHIGH(qhat);

    /* ROUND 3. Set j = 0 and calculate q0 */
    /*	Estimate qhat = (u2u1) / v1
        then set (u2u1u0) -= qhat(v1v0)
    */
    t = uu[0];
    qhat = t / v1;
    rhat = t - qhat * v1;
    /* Test on v0 */
    t = TOHIGH(rhat) | u0;
    if ((qhat == B) || (qhat * v0 > t)) {
        qhat--;
        rhat += v1;
        t = TOHIGH(rhat) | u0;
        if ((rhat < B) && (qhat * v0 > t))
            qhat--;
    }

    /*	Multiply and subtract
        (u2u1u0)" = (u2u1u0)' - qhat(v1v0)
    */
    uu[1] = HIHALF(uu[0]);    /* (0u2) */
    uu[0] = TOHIGH(LOHALF(uu[0])) | u0;    /* (u1u0) */
    spMultSub(uu, qhat, v1, v0);
    if (HIHALF(uu[1]) != 0) {    /* Add back */
        qhat--;
        uu[0] += v;
        uu[1] = 0;
    }

    /* q0 = qhat */
    *q |= LOHALF(qhat);

    /* Remainder is in (u1u0) i.e. uu[0] */
    *r = uu[0];
    return q2;
}
```


Overlapping Code:
```
_T spDivide(DIGIT_T *q, DIGIT_T *r, const DIGIT_T u[2], DIGIT_T v) { /* Computes quotient q = u / v, remainder r = u mod v
where u is a double digit
and q, v, r are single precision digits.
Returns high digit of quotient (max value is 1)
CAUTION: Assumes normalised such that v1 >= b/2
where b is size of HALF_DIGIT
i.e. the most significant bit of v should be one
In terms of half-digits in Knuth notation:
(q2q1q0) = (u4u3u2u1u0) / (v1v0)
(r1r0) = (u4u3u2u1u0) mod (v1v0)
for m = 2, n = 2 where u4 = 0
q2 is either 0 or 1.
We set q = (q1q0) and return q2 as "overflow"
*/
DIGIT_T qhat, rhat, t, v0, v1, u0, u1, u2, u3;
DIGIT_T uu[2], q2;
/* Check for normalisation */
if (!(v & HIBITMASK)) { /* Stop if assert is working, else return error */
assert(v & HIBITMASK);
*q = *r = 0;
return MAX_DIGIT;
}
/* Split up into half-digits */
v0 = LOHALF(v);
v1 = HIHALF(v);
u0 = LOHALF(u[0]);
u1 = HIHALF(u[0]);
u2 = LOHALF(u[1]);
u3 = HIHALF(u[1]);
/* Do three rounds of Knuth Algorithm D Vol 2 p272 */
/* ROUND 1. Set j = 2 and calculate q2 */
/* Estimate qhat = (u4u3)/v1 = 0 or 1
then set (u4u3u2) -= qhat(v1v0)
where u4 = 0.
*/
/* [Replaced in Version 2] -->
qhat = u3 / v1;
if (qhat > 0)
{
rhat = u3 - qhat * v1;
t = TOHIGH(rhat) | u2;
if (qhat * v0 > t)
qhat--;
}
<-- */
qhat = (u3 < v1 ? 0 : 1);
if (qhat > 0) { /* qhat is one, so no need to mult */
rhat = u3 - v1;
/* t = r.b + u2 */
t = TOHIGH(rhat) | u2;
if (v0 > t)
qhat--;
}
uu[1] = 0; /* (u4) */
uu[0] = u[1]; /* (u3u2) */
if (qhat > 0) {
/* (u4u3u2) -= qhat(v1v0) where u4 = 0 */
spMultSub(uu, qhat, v1, v0);
if (HIHALF(uu[1]) != 0) { /* Add back */
qhat--;
uu[0] += v;
uu[1] = 0;
}
}
q2 = qhat;
/* ROUND 2. Set j = 1 and calculate q1 */
/* Estimate qhat = (u3u2) / v1
then set (u3u2u1) -= qhat(v1v0)
*/
t = uu[0];
qhat = t / v1;
rhat = t - qhat * v1;
/* Test on v0 */
t = TOHIGH(rhat) | u1;
if ((qhat == B) || (qhat * v0 > t)) {
qhat--;
rhat += v1;
t = TOHIGH(rhat) | u1;
if ((rhat < B) && (qhat * v0 > t))
qhat--;
}
/* Multiply and 
```
<Overlap Ratio: 0.9964947421131698>

---

--- 110 --
Question ID: 648a37aad7b3d5980e7a1291debeb8b4b9a4005e_2
Original Code:
```
unsigned short int  dev_timer_clr_int( void )
{
  TIM2->SR &= ~TIM_SR_UIF; /* clear update interrupt */

  return  0;
}
```


Overlapping Code:
```
short int dev_timer_clr_int( void )
{
TIM2->SR &= ~TIM_SR_UIF; /* clear update interrupt */
return 0
```
<Overlap Ratio: 0.8928571428571429>

---

--- 111 --
Question ID: 0c03bfc52b4bf8cfecfc305e0c57afc3049e4d2e_4
Original Code:
```
VPVOID LocalLock16(HANDLE hMem)
{
    WORD    h16;
    LONG    retval;

    if (HIWORD(hMem) == 0) {
        WOW32ASSERT(HIWORD(hMem) != 0);
        return (VPVOID)0;
    }

    h16 = LOWORD(hMem);
    retval = (VPVOID)hMem;

    if (h16 & LA_MOVEABLE) {
        PLOCALHANDLEENTRY plhe;

        GETVDMPTR(hMem, sizeof(*plhe), plhe);

        if (plhe->lhe_flags & LHE_DISCARDED) {
            goto LOCK1;
        }

        plhe->lhe_count++;
        if (!plhe->lhe_count)
            plhe->lhe_count--;

LOCK1:
        LOW(retval) = plhe->lhe_address;
        FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);
        FREEVDMPTR(plhe);
    }

    if (LOWORD(retval) == 0)
        retval = 0;

    return retval;
}
```


Overlapping Code:
```
calLock16(HANDLE hMem)
{
WORD h16;
LONG retval;
if (HIWORD(hMem) == 0) {
WOW32ASSERT(HIWORD(hMem) != 0);
return (VPVOID)0;
}
h16 = LOWORD(hMem);
retval = (VPVOID)hMem;
if (h16 & LA_MOVEABLE) {
PLOCALHANDLEENTRY plhe;
GETVDMPTR(hMem, sizeof(*plhe), plhe);
if (plhe->lhe_flags & LHE_DISCARDED) {
goto LOCK1;
}
plhe->lhe_count++;
if (!plhe->lhe_count)
plhe->lhe_count--;
LOCK1:
LOW(retval) = plhe->lhe_address;
FLUSHVDMPTR((ULONG)hMem, sizeof(*plhe), plhe);
FREEVDMPTR(plhe);
}
if (LOWORD(retval) == 0)

```
<Overlap Ratio: 0.931098696461825>

---

--- 112 --
Question ID: 37be5fc44c8bc4e6074c8e135b50c33776935c9e_1
Original Code:
```
PUBLIC void do_kcall2(void)
{
	int coreid = 0;
	int ret = -ENOSYS;

	semaphore_down(&syssem);

		/* Sweeps the cores in a circular fashion. */
		for (int i = 0; i < CORES_NUM; i++)
		{
			if (sysboard[sys_next_coreid].pending)
			{
				coreid = sys_next_coreid;
				sys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;

				break;
			}

			sys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;
		}

		/* Invalid system call number. */
		if (sysboard[coreid].syscall_nr >= NR_SYSCALLS)
		{
			ret = -EINVAL;
			goto out;
		}

		/* Parse system call number. */
		switch (sysboard[coreid].syscall_nr)
		{
			case NR_shutdown:
				ret = kernel_shutdown();
				break;

			case NR__exit:
				kernel_exit((int)(long) sysboard[coreid].arg0);
				break;

			case NR_write:
				ret = kernel_write(
					(int)(long) sysboard[coreid].arg0,
					(const char *)(long) sysboard[coreid].arg1,
					(size_t)(long) sysboard[coreid].arg2
				);
				break;

#if (THREAD_MAX > 1)

			case NR_thread_create:
				ret = kernel_thread_create(
					(int *)(long) sysboard[coreid].arg0,
					(void *(*)(void *))(long) sysboard[coreid].arg1,
					(void *)(long) sysboard[coreid].arg2
				);
				break;

			case NR_wakeup:
				ret = kernel_wakeup(
					(int)(long) sysboard[coreid].arg0
				);
				break;

#endif

			case NR_sigctl:
				ret = kernel_sigctl(
					(int)(long) sysboard[coreid].arg0,
					(struct ksigaction *)(long) sysboard[coreid].arg1
				);
				break;

			case NR_node_get_num:
				ret = kernel_node_get_num();
				break;

			case NR_cluster_get_num:
				ret = kernel_cluster_get_num();
				break;

#if __TARGET_HAS_SYNC
			case NR_sync_create:
				ret = kernel_sync_create(
					(const int *)(long) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1,
					(int) sysboard[coreid].arg2
				);
				break;

			case NR_sync_open:
				ret = kernel_sync_open(
					(const int *)(long) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1,
					(int) sysboard[coreid].arg2
				);
				break;

			case NR_sync_unlink:
				ret = kernel_sync_unlink(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_sync_close:
				ret = kernel_sync_close(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_sync_signal:
				ret = kernel_sync_signal(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_sync_ioctl:
				ret = kernel_sync_ioctl(
					(int) sysboard[coreid].arg0,
					(unsigned) sysboard[coreid].arg1,
					(va_list *) sysboard[coreid].arg2
				);
				break;
#endif /* __TARGET_HAS_SYNC */

#if __TARGET_HAS_MAILBOX
			case NR_mailbox_create:
				ret = kernel_mailbox_create(
					(int) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1
				);
				break;

			case NR_mailbox_open:
				ret = kernel_mailbox_open(
					(int) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1
				);
				break;

			case NR_mailbox_unlink:
				ret = kernel_mailbox_unlink(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_mailbox_close:
				ret = kernel_mailbox_close(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_mailbox_aread:
				ret = kernel_mailbox_aread(
					(int) sysboard[coreid].arg0,
					(void *)(long) sysboard[coreid].arg1,
					(size_t) sysboard[coreid].arg2
				);
				break;

			case NR_mailbox_awrite:
				ret = kernel_mailbox_awrite(
					(int) sysboard[coreid].arg0,
					(const void *)(long) sysboard[coreid].arg1,
					(size_t) sysboard[coreid].arg2
				);
				break;

			case NR_mailbox_ioctl:
				ret = kernel_mailbox_ioctl(
					(int) sysboard[coreid].arg0,
					(unsigned) sysboard[coreid].arg1,
					(va_list *) sysboard[coreid].arg2
				);
				break;
#endif /* __TARGET_HAS_MAILBOX */

#if __TARGET_HAS_PORTAL
			case NR_portal_create:
				ret = kernel_portal_create(
					(int) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1
				);
				break;

			case NR_portal_allow:
				ret = kernel_portal_allow(
					(int) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1,
					(int) sysboard[coreid].arg2
				);
				break;

			case NR_portal_open:
				ret = kernel_portal_open(
					(int) sysboard[coreid].arg0,
					(int) sysboard[coreid].arg1,
					(int) sysboard[coreid].arg2
				);
				break;

			case NR_portal_unlink:
				ret = kernel_portal_unlink(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_portal_close:
				ret = kernel_portal_close(
					(int) sysboard[coreid].arg0
				);
				break;

			case NR_portal_aread:
				ret = kernel_portal_aread(
					(int) sysboard[coreid].arg0,
					(void *)(long) sysboard[coreid].arg1,
					(size_t) sysboard[coreid].arg2
				);
				break;

			case NR_portal_awrite:
				ret = kernel_portal_awrite(
					(int) sysboard[coreid].arg0,
					(const void *)(long) sysboard[coreid].arg1,
					(size_t) sysboard[coreid].arg2
				);
				break;

			case NR_portal_ioctl:
				ret = kernel_portal_ioctl(
					(int) sysboard[coreid].arg0,
					(unsigned) sysboard[coreid].arg1,
					(va_list *) sysboard[coreid].arg2
				);
				break;
#endif /* __TARGET_HAS_PORTAL */

		case NR_stats:
			kernel_stats(
				(uint64_t *) sysboard[coreid].arg0,
				(int) sysboard[coreid].arg1
			);
			break;

		case NR_frame_alloc:
			ret = kernel_frame_alloc();
			break;

		case NR_frame_free:
			ret = kernel_frame_free(
				(vaddr_t) sysboard[coreid].arg0
			);
			break;

		case NR_upage_alloc:
			ret = kernel_upage_alloc(
				(vaddr_t) sysboard[coreid].arg0
			);
			break;

		case NR_upage_free:
			ret = kernel_upage_free(
				(vaddr_t) sysboard[coreid].arg0
			);
			break;

		case NR_upage_map:
			ret = kernel_upage_map(
				(vaddr_t) sysboard[coreid].arg0,
				(frame_t) sysboard[coreid].arg1
			);
			break;

		case NR_upage_unmap:
			ret = kernel_upage_unmap(
				(vaddr_t) sysboard[coreid].arg0
			);
			break;

		case NR_upage_link:
			ret = kernel_upage_link(
				(vaddr_t) sysboard[coreid].arg0,
				(vaddr_t) sysboard[coreid].arg1
			);
			break;

#if (THREAD_MAX > 1)

		case NR_excp_ctrl:
			ret = kernel_excp_ctrl(
				(int) sysboard[coreid].arg0,
				(int) sysboard[coreid].arg1
			);
			break;

		case NR_excp_resume:
			ret = kernel_excp_resume();
			break;

#endif

			default:
				break;
		}

	out:

		sysboard[coreid].pending = 0;
		sysboard[coreid].ret = ret;

	semaphore_up(&sysboard[coreid].syssem);
}
```


Overlapping Code:
```
l2(void)
{
int coreid = 0;
int ret = -ENOSYS;
semaphore_down(&syssem);
/* Sweeps the cores in a circular fashion. */
for (int i = 0; i < CORES_NUM; i++)
{
if (sysboard[sys_next_coreid].pending)
{
coreid = sys_next_coreid;
sys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;
break;
}
sys_next_coreid = (sys_next_coreid + 1) % CORES_NUM;
}
/* Invalid system call number. */
if (sysboard[coreid].syscall_nr >= NR_SYSCALLS)
{
ret = -EINVAL;
goto out;
}
/* Parse system call number. */
switch (sysboard[coreid].syscall_nr)
{
case NR_shutdown:
ret = kernel_shutdown();
break;
case NR__exit:
kernel_exit((int)(long) sysboard[coreid].arg0);
break;
case NR_write:
ret = kernel_write(
(int)(long) sysboard[coreid].arg0,
(const char *)(long) sysboard[coreid].arg1,
(size_t)(long) sysboard[coreid].arg2
);
break;
#if (THREAD_MAX > 1)
case NR_thread_create:
ret = kernel_thread_create(
(int *)(long) sysboard[coreid].arg0,
(void *(*)(void *))(long) sysboard[coreid].arg1,
(void *)(long) sysboard[coreid].arg2
);
break;
case NR_wakeup:
ret = kernel_wakeup(
(int)(long) sysboard[coreid].arg0
);
break;
#endif
case NR_sigctl:
ret = kernel_sigctl(
(int)(long) sysboard[coreid].arg0,
(struct ksigaction *)(long) sysboard[coreid].arg1
);
break;
case NR_node_get_num:
ret = kernel_node_get_num();
break;
case NR_cluster_get_num:
ret = kernel_cluster_get_num();
break;
#if __TARGET_HAS_SYNC
case NR_sync_create:
ret = kernel_sync_create(
(const int *)(long) sysboard[coreid].arg0,
(int) sysboard[coreid].arg1,
(int) sysboard[coreid].arg2
);
break;
case NR_sync_open:
ret = kernel_sync_open(
(const int *)(long) sysboard[coreid].arg0,
(int) sysboard[coreid].arg1,
(int) sysboard[coreid].arg2
);
break;
case NR_sync_unlink:
ret = kernel_sync_unlink(
(int) sysboard[coreid].arg0
);
break;
case NR_sync_close:
ret = kernel_sync_close(
(int) sysboard[coreid].arg0
);
break;
case NR_sync_signal:
ret = kernel_sync_signal(
(int) sysboard[coreid].arg0
);
break;
case NR_sync_ioctl:
ret = kernel_sync_ioctl(
(int) sysboard[coreid].arg0,
(unsigned) sysboard[coreid].arg1,
(va_list *) sysboard[coreid].arg2
);
break;
#endif /* __TA
```
<Overlap Ratio: 0.9887005649717514>

---

--- 113 --
Question ID: dcd7fb5b9fb24ab21190d2769cb1238db1fdbc13_7
Original Code:
```
static int qcom_vadc_scale_hw_calib_therm(
				const struct vadc_prescale_ratio *prescale,
				const struct adc5_data *data,
				u16 adc_code, int *result_mdec)
{
	int voltage;

	voltage = qcom_vadc_scale_code_voltage_factor(adc_code,
				prescale, data, 1000);

	/* Map voltage to temperature from look-up table */
	return qcom_vadc_map_voltage_temp(adcmap_100k_104ef_104fb_1875_vref,
				 ARRAY_SIZE(adcmap_100k_104ef_104fb_1875_vref),
				 voltage, result_mdec);
}
```


Overlapping Code:
```
int qcom_vadc_scale_hw_calib_therm(
const struct vadc_prescale_ratio *prescale,
const struct adc5_data *data,
u16 adc_code, int *result_mdec)
{
int voltage;
voltage = qcom_vadc_scale_code_voltage_factor(adc_code,
prescale, data, 1000);
/* Map voltage to temperature from look-up table */
return qcom_vadc_map_voltage_temp(adcmap_100k_104ef_104fb_1875_vref,
ARRAY_SIZE(adcmap_100k_104ef_104fb_1875_vref),
voltage, result_mdec);

```
<Overlap Ratio: 0.9816091954022989>

---

--- 114 --
Question ID: 81afab2cfb91db15d880e8d80295023ae54cf673_17
Original Code:
```
SshNdisPacket SSH_PACKET_POOL_API 
ssh_packet_clone(SshInterceptor interceptor,
                 SshPacketPool pool,
                 SshInterceptorProtocol protocol,
                 SshNativeNetDataPacket src,
                 Boolean copy_data)
{
  SshMediaHeader media_hdr;
  SshNdisPacket packet;
  SshNdisBuffer buff_chain;
  SshUInt32 total_len;
  SshUInt32 bytes_copied = 0;
  void *media_info;
  SshUInt32 media_info_len;

  SSH_ASSERT(interceptor != NULL);
  SSH_ASSERT(pool != NULL);
  SSH_ASSERT(src != NULL);

  /* Query source packet len */
  NdisQueryPacket(src, NULL, NULL, NULL, &total_len);

  /* Allocate new packet for copying */
  packet = (SshNdisPacket)ssh_net_packet_alloc(interceptor, pool, total_len);
  if (packet == NULL)
    {
      SSH_DEBUG(SSH_D_FAIL, 
                ("Error: ssh_packet_clone(): "
                 "Cannot allocate destination packet[len=%d]",
                 total_len));
      return NULL;  
    }

  buff_chain = (SshNdisBuffer)ssh_buffer_chain_alloc(interceptor, pool, 
                                                     total_len,
                                                     &packet->data_space, 
                                                     &packet->backfill_space);
  if (buff_chain == NULL)
    {
      SSH_DEBUG(SSH_D_FAIL, ("Out of buffer pool!"));
      ssh_packet_free((SshNetDataPacket)packet, pool);
      return NULL;
    }

  if (copy_data) 
    {
 copy_packet:
      SSH_RESET_PACKET((SshNetDataPacket)packet, 
                       (SshNetDataBuffer)buff_chain);

      /* Copy packet contents */
      NdisCopyFromPacketToPacket(packet->np, 0, total_len, 
                                 src, 0, &bytes_copied);
      if (bytes_copied != total_len)
        {
          SSH_DEBUG(SSH_D_FAIL, 
                    ("Packet[0x%p, %d, %d] copy failed",
                     packet, total_len, bytes_copied));
          ssh_packet_free((SshNetDataPacket)packet, pool);
          return NULL;
        }
      packet->f.flags.packet_copied = 1;
    }
  else
    {
      SshNdisBufferHeader prev = NULL;
      NDIS_BUFFER *ndis_buf;
      unsigned char *buf_addr;
      UINT buf_len;
      UINT pkt_len;

      SSH_RESET_PACKET((SshNetDataPacket)packet, NULL);

      packet->buff = (SshNetDataBuffer)buff_chain;
      /* Copy buffer descriptors (so we don't need to revert changes in
         original packet before returning it back to miniport/protocol). */
      NdisGetFirstBufferFromPacketSafe(src, &ndis_buf, &buf_addr,  &buf_len, 
                                       &pkt_len, NormalPagePriority);      
      if (ndis_buf == NULL)
        {
          ssh_packet_free((SshNetDataPacket)packet, pool);
          return NULL;
        }

      while (ndis_buf)
        {
          SshNdisBufferHeader buf_hdr;
          NDIS_STATUS status;

          NdisQueryBufferSafe(ndis_buf, &buf_addr, &buf_len, 
                              NormalPagePriority);
          if (buf_addr == NULL)
            {
              ssh_packet_free((SshNetDataPacket)packet, pool);
              return NULL;
            }

          /* Skip zero-length buffers */
          if (buf_len > 0)
            {
              if (packet->clone_buffers_in_use 
                                      == SSH_CLONE_BUF_DESCRIPTORS_PER_PACKET)
                goto copy_packet;

              buf_hdr = &packet->clone_buffers[packet->clone_buffers_in_use];

              SSH_ASSERT(buf_hdr->nb == NULL);
              NdisCopyBuffer(&status, &buf_hdr->nb, pool->buffer_list_context, 
                             ndis_buf, 0, ndis_buf->ByteCount);
              if (status != NDIS_STATUS_SUCCESS)
                {
                  ssh_packet_free((SshNetDataPacket)packet, pool);
                  return NULL;
                }

              SSH_ASSERT(buf_hdr->nb->Next == NULL);

              buf_hdr->total_size = ndis_buf->ByteCount;
              buf_hdr->data_len = buf_hdr->total_size;
              buf_hdr->offset = 0;
#ifndef _WIN32_WCE
              SSH_NB_DESCRIPTOR(buf_hdr->nb) = buf_hdr;
#endif /* _WIN32_WCE */

              buf_hdr->prev = prev;
              buf_hdr->next = NULL;
              if (prev)
                prev->next = buf_hdr;
              prev = buf_hdr;

              NdisChainBufferAtBack(packet->np, buf_hdr->nb);

              packet->clone_buffers_in_use++;
            }

          NdisGetNextBuffer(ndis_buf, &ndis_buf);
        }

      packet->buf_chain_backfill = packet->backfill_space;
      packet->buf_chain_data_space = packet->data_space;
      packet->backfill_space = 0;
      packet->data_space = pkt_len;

      /* Force-update packet counts */
      NdisRecalculatePacketCounts(packet->np);
      NdisQueryPacket(packet->np, NULL, NULL, NULL, &pkt_len);
    }

  /* Set OOB information */
  RtlCopyMemory(NDIS_OOB_DATA_FROM_PACKET(packet->np),
                NDIS_OOB_DATA_FROM_PACKET(src),
                sizeof(NDIS_PACKET_OOB_DATA));

  /* Set media specific information */
  NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(src, &media_info, &media_info_len);
  NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(packet->np, 
                                      media_info, media_info_len);

  /* Copy IEEE802.1p priority value */
  NDIS_PER_PACKET_INFO_FROM_PACKET(packet->np, Ieee8021pPriority) =
    NDIS_PER_PACKET_INFO_FROM_PACKET(src, Ieee8021pPriority);

  /* Copy packet flags */
  NdisSetPacketFlags(packet->np, NdisGetPacketFlags(src));

  /* Set packet header size */
  NDIS_SET_PACKET_HEADER_SIZE(packet->np, 
                              NDIS_GET_PACKET_HEADER_SIZE(src));

  packet->packet_len = total_len;

  ssh_packet_query_media_header(packet->np, &media_hdr);
  if (media_hdr != NULL)
    {
      if (protocol == SSH_PROTOCOL_ETHERNET)
        {
          if (SSH_ETHER_IS_MULTICAST(media_hdr->dst))
            packet->ip.flags |= SSH_PACKET_MEDIABCAST;
        }
      packet->eth_type = SSH_GET_16BIT(media_hdr->type);
    }

  return packet;
}
```


Overlapping Code:
```
SSH_PACKET_POOL_API 
ssh_packet_clone(SshInterceptor interceptor,
SshPacketPool pool,
SshInterceptorProtocol protocol,
SshNativeNetDataPacket src,
Boolean copy_data)
{
SshMediaHeader media_hdr;
SshNdisPacket packet;
SshNdisBuffer buff_chain;
SshUInt32 total_len;
SshUInt32 bytes_copied = 0;
void *media_info;
SshUInt32 media_info_len;
SSH_ASSERT(interceptor != NULL);
SSH_ASSERT(pool != NULL);
SSH_ASSERT(src != NULL);
/* Query source packet len */
NdisQueryPacket(src, NULL, NULL, NULL, &total_len);
/* Allocate new packet for copying */
packet = (SshNdisPacket)ssh_net_packet_alloc(interceptor, pool, total_len);
if (packet == NULL)
{
SSH_DEBUG(SSH_D_FAIL, 
("Error: ssh_packet_clone(): "
"Cannot allocate destination packet[len=%d]",
total_len));
return NULL; 
}
buff_chain = (SshNdisBuffer)ssh_buffer_chain_alloc(interceptor, pool, 
total_len,
&packet->data_space, 
&packet->backfill_space);
if (buff_chain == NULL)
{
SSH_DEBUG(SSH_D_FAIL, ("Out of buffer pool!"));
ssh_packet_free((SshNetDataPacket)packet, pool);
return NULL;
}
if (copy_data) 
{
copy_packet:
SSH_RESET_PACKET((SshNetDataPacket)packet, 
(SshNetDataBuffer)buff_chain);
/* Copy packet contents */
NdisCopyFromPacketToPacket(packet->np, 0, total_len, 
src, 0, &bytes_copied);
if (bytes_copied != total_len)
{
SSH_DEBUG(SSH_D_FAIL, 
("Packet[0x%p, %d, %d] copy failed",
packet, total_len, bytes_copied));
ssh_packet_free((SshNetDataPacket)packet, pool);
return NULL;
}
packet->f.flags.packet_copied = 1;
}
else
{
SshNdisBufferHeader prev = NULL;
NDIS_BUFFER *ndis_buf;
unsigned char *buf_addr;
UINT buf_len;
UINT pkt_len;
SSH_RESET_PACKET((SshNetDataPacket)packet, NULL);
packet->buff = (SshNetDataBuffer)buff_chain;
/* Copy buffer descriptors (so we don't need to revert changes in
original packet before returning it back to miniport/protocol). */
NdisGetFirstBufferFromPacketSafe
```
<Overlap Ratio: 0.9840425531914894>

---

--- 115 --
Question ID: 6c9c8501562aeba79d73e12ac5a41ed4eae6678d_9
Original Code:
```
static int test_linkable(struct dentry *h_root)
{
	struct inode *h_dir = d_inode(h_root);

	if (h_dir->i_op->link)
		return 0;

	pr_err("%pd (%s) doesn't support link(2), use noplink and rw+nolwh\n",
	       h_root, au_sbtype(h_root->d_sb));
	return -ENOSYS;
}
```


Overlapping Code:
```
c int test_linkable(struct dentry *h_root)
{
struct inode *h_dir = d_inode(h_root);
if (h_dir->i_op->link)
return 0;
pr_err("%pd (%s) doesn't support link(2), use noplink and rw+nolwh\n",
h_root, au_s
```
<Overlap Ratio: 0.819672131147541>

---

--- 116 --
Question ID: c8a02cd10b4fb285c7c9f2c39fc1c20b2981a4b6_5
Original Code:
```
REAL PrintTorsionEnergyStatus(int nr,char *string,int TorsionType,REAL *parms,REAL Phi)
{
  REAL U,CosPhi,CosPhi2;

  CosPhi=cos(Phi);
  CosPhi2=SQR(CosPhi);
  switch(TorsionType)
  {
    case HARMONIC_DIHEDRAL:
      // (1/2)*p_0*(phi-p_1)^2
      // ===============================================
      // p_0/k_B [K/rad^2]
      // p_1     [degrees]
      // potential defined in terms of 'phi' and therefore contains a singularity
      // the sign of the angle-phi is positive if (Rab x Rbc) x (Rbc x Rcd) is in the
      // same direction as Rbc, and negative otherwise
      Phi-=parms[1];
      Phi-=NINT(Phi/(2.0*M_PI))*2.0*M_PI;
      U=0.5*parms[0]*SQR(Phi);
      fprintf(OutputFilePtr[CurrentSystem],"%4d HARMONIC_DIHEDRAL %s, p_0/k_B=%8.5f [K/rad^2],  p_1=%8.5f [A], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*RAD2DEG,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case HARMONIC_COSINE_DIHEDRAL:
      // (1/2)*p_0*(cos(phi)-cos(p_1))^2
      // ===============================================
      // p_0/k_B [K]
      // p_1     [degrees]
      U=0.5*parms[0]*SQR(CosPhi-cos(parms[1]));
      fprintf(OutputFilePtr[CurrentSystem],"%4d HARMONIC_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [degrees], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                acos(parms[1])*RAD2DEG,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case THREE_COSINE_DIHEDRAL:
      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
      // ========================================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);
      fprintf(OutputFilePtr[CurrentSystem],"%4d THREE_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case MM3_DIHEDRAL:
      // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
      // ========================================================================
      // p_0     [kcal/mol]
      // p_1     [kcal/mol]
      // p_2     [kcal/mol]
      U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);
      fprintf(OutputFilePtr[CurrentSystem],"%4d MM3_DIHEDRAL %s, p_0=%8.5f [kcal/mol], p_1=%8.5f [kcal/mol], p_2=%8.5f [kcal/mol], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]/KCAL_PER_MOL_TO_ENERGY,
                parms[1]/KCAL_PER_MOL_TO_ENERGY,
                parms[2]/KCAL_PER_MOL_TO_ENERGY,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case CVFF_BLOCKED_DIHEDRAL:
      //
      // ========================================================================
      // p_0     [rad]
      // p_1     [K]
      // p_2     [-]
      // p_3     [rad]
      // p_4     [rad]
      U=0;
      break;
    case CFF_DIHEDRAL:
      // p_0*(1-cos(phi))+p_1*(1-cos(2*phi))+p_2*(1-cos(3*phi))
      // ======================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      U=parms[0]*(1.0-CosPhi)+2.0*parms[1]*(1.0-CosPhi2)+parms[2]*(1.0+3.0*CosPhi-4.0*CosPhi*CosPhi2);
      fprintf(OutputFilePtr[CurrentSystem],"%4d CFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case CFF_DIHEDRAL2:
      // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))
      // ======================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      U=parms[0]*(1.0+CosPhi)+parms[2]+CosPhi*(-3.0*parms[2]+2.0*CosPhi*(parms[1]+2.0*parms[2]*CosPhi));
      fprintf(OutputFilePtr[CurrentSystem],"%4d CFF_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case SIX_COSINE_DIHEDRAL:
      // Prod_i=0^5 p_i*cos(phi)^i
      // =========================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      // p_3/k_B [K]
      // p_4/k_B [K]
      // p_5/k_B [K]
      // the Ryckaert-Bellemans potentials is often used for alkanes, the use implies exclusion of VDW-interactions
      // between the first and last atoms of the dihedral, and Phi'=Phi-pi is defined accoording to the
      // polymer convention Phi'(trans)=0.
      U=parms[0]-parms[1]*CosPhi+parms[2]*CosPhi2-parms[3]*CosPhi*CosPhi2+
             parms[4]*SQR(CosPhi2)-parms[5]*SQR(CosPhi2)*CosPhi;
      fprintf(OutputFilePtr[CurrentSystem],"%4d SIX_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                parms[3]*ENERGY_TO_KELVIN,
                parms[4]*ENERGY_TO_KELVIN,
                parms[5]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case TRAPPE_DIHEDRAL:
      // p_0[0]+p_1*(1+cos(phi))+p_2*(1-cos(2*phi))+p_3*(1+cos(3*phi))
      // =============================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      // p_3/k_B [K]
      U=parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi));
      fprintf(OutputFilePtr[CurrentSystem],"%4d TRAPPE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                parms[3]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case CVFF_DIHEDRAL:
      // p_0*(1+cos(p_1*phi-p_2))
      // ========================
      // p_0/k_B [K]
      // p_1     [-]
      // p_2     [degrees]
      U=parms[0]*(1.0+cos(parms[1]*Phi-parms[2]));
      fprintf(OutputFilePtr[CurrentSystem],"%4d CVFF_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [-], p_2=%8.5f [degrees], "
                                           "Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1],
                parms[2]*RAD2DEG,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case OPLS_DIHEDRAL:
      // (1/2)p_0[0]+(1/2)p_1*(1+cos(phi))+(1/2)p_2*(1-cos(2*phi))+(1/2)p_3*(1+cos(3*phi))
      // =================================================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      // p_3/k_B [K]
      U=0.5*(parms[0]+(1.0+CosPhi)*(parms[1]+parms[3]-2.0*(CosPhi-1.0)*(parms[2]-2.0*parms[3]*CosPhi)));
      fprintf(OutputFilePtr[CurrentSystem],"%4d OPLS_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "p_3/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                parms[3]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case FOURIER_SERIES_DIHEDRAL:
      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
      // (1/2)p_3*(1-cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
      // =======================================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      // p_3/k_B [K]
      // p_4/k_B [K]
      // p_5/k_B [K]
      U=0.5*(parms[0]+2.0*parms[1]+parms[2]+parms[4]+2.0*parms[5]+(parms[0]-3.0*parms[2]+5.0*parms[4])*CosPhi-
             2.0*(parms[1]-4.0*parms[3]+9.0*parms[5])*CosPhi2+4.0*(parms[2]-5.0*parms[4])*CosPhi2*CosPhi-
             8.0*(parms[3]-6.0*parms[5])*SQR(CosPhi2)+16.0*parms[4]*SQR(CosPhi2)*CosPhi-32.0*parms[5]*CUBE(CosPhi2));
      fprintf(OutputFilePtr[CurrentSystem],"%4d FOURIER_SERIES_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                parms[3]*ENERGY_TO_KELVIN,
                parms[4]*ENERGY_TO_KELVIN,
                parms[5]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    case FOURIER_SERIES_DIHEDRAL2:
      // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
      // (1/2)p_3*(1+cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
      // =======================================================================
      // p_0/k_B [K]
      // p_1/k_B [K]
      // p_2/k_B [K]
      // p_3/k_B [K]
      // p_4/k_B [K]
      // p_5/k_B [K]
      U=0.5*(parms[2]+2.0*parms[3]+parms[4]-3.0*parms[2]*CosPhi+5.0*parms[4]*CosPhi+parms[0]*(1.0+CosPhi)+
        2.0*(parms[1]-parms[1]*CosPhi2+CosPhi2*(parms[5]*SQR(3.0-4.0*CosPhi2)+4.0*parms[3]*(CosPhi2-1.0)+
        2.0*CosPhi*(parms[2]+parms[4]*(4.0*CosPhi2-5.0)))));
      fprintf(OutputFilePtr[CurrentSystem],"%4d FOURIER_SERIES_DIHEDRAL2 %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
                                           "p_3/k_B=%8.5f [K], p_4/k_B=%8.5f [K], p_5/k_B=%8.5f [K], Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
                nr,
                string,
                parms[0]*ENERGY_TO_KELVIN,
                parms[1]*ENERGY_TO_KELVIN,
                parms[2]*ENERGY_TO_KELVIN,
                parms[3]*ENERGY_TO_KELVIN,
                parms[4]*ENERGY_TO_KELVIN,
                parms[5]*ENERGY_TO_KELVIN,
                Phi*RAD2DEG,
                U*ENERGY_TO_KELVIN,
                U*ENERGY_TO_KJ_PER_MOL,
                U*ENERGY_TO_KCAL_PER_MOL);
      break;
    default:
      fprintf(stderr, "Undefined Torsion potential in routine 'CalculateFrameworkTorsionEnergy' ('framework_energy.c')\n");
      exit(0);
      break;
  }
  return U;
}
```


Overlapping Code:
```
TorsionEnergyStatus(int nr,char *string,int TorsionType,REAL *parms,REAL Phi)
{
REAL U,CosPhi,CosPhi2;
CosPhi=cos(Phi);
CosPhi2=SQR(CosPhi);
switch(TorsionType)
{
case HARMONIC_DIHEDRAL:
// (1/2)*p_0*(phi-p_1)^2
// ===============================================
// p_0/k_B [K/rad^2]
// p_1 [degrees]
// potential defined in terms of 'phi' and therefore contains a singularity
// the sign of the angle-phi is positive if (Rab x Rbc) x (Rbc x Rcd) is in the
// same direction as Rbc, and negative otherwise
Phi-=parms[1];
Phi-=NINT(Phi/(2.0*M_PI))*2.0*M_PI;
U=0.5*parms[0]*SQR(Phi);
fprintf(OutputFilePtr[CurrentSystem],"%4d HARMONIC_DIHEDRAL %s, p_0/k_B=%8.5f [K/rad^2], p_1=%8.5f [A], "
"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
nr,
string,
parms[0]*ENERGY_TO_KELVIN,
parms[1]*RAD2DEG,
Phi*RAD2DEG,
U*ENERGY_TO_KELVIN,
U*ENERGY_TO_KJ_PER_MOL,
U*ENERGY_TO_KCAL_PER_MOL);
break;
case HARMONIC_COSINE_DIHEDRAL:
// (1/2)*p_0*(cos(phi)-cos(p_1))^2
// ===============================================
// p_0/k_B [K]
// p_1 [degrees]
U=0.5*parms[0]*SQR(CosPhi-cos(parms[1]));
fprintf(OutputFilePtr[CurrentSystem],"%4d HARMONIC_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1=%8.5f [degrees], "
"Phi: %8.5f [degrees], Energy: %8.5f [K] %8.5f [kJ/mol] %8.5f [kcal/mol]\n",
nr,
string,
parms[0]*ENERGY_TO_KELVIN,
acos(parms[1])*RAD2DEG,
Phi*RAD2DEG,
U*ENERGY_TO_KELVIN,
U*ENERGY_TO_KJ_PER_MOL,
U*ENERGY_TO_KCAL_PER_MOL);
break;
case THREE_COSINE_DIHEDRAL:
// (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
// ========================================================================
// p_0/k_B [K]
// p_1/k_B [K]
// p_2/k_B [K]
U=0.5*parms[0]*(1.0+CosPhi)+parms[1]*(1.0-CosPhi2)+0.5*parms[2]*(1.0-3.0*CosPhi+4.0*CosPhi*CosPhi2);
fprintf(OutputFilePtr[CurrentSystem],"%4d THREE_COSINE_DIHEDRAL %s, p_0/k_B=%8.5f [K], p_1/k_B=%8.5f [K], p_2/k_B=%8.5f [K], "
"Phi:
```
<Overlap Ratio: 0.9896157840083074>

---

--- 117 --
Question ID: 2c142e3bf5c05c4e55643c27556f9201c807ae37_7
Original Code:
```
EffEntry* effNameToPtr(const char* name) {
	EffEntry* entry;
	int i;

	for (i = 0; i < wp->numEntries; i++) {
		entry = &wp->entries[i];
		if (entry->flags && !strcmp(name, entry->name)) {
			break;
		}
	}
	if (i < wp->numEntries) { //found a match
		return entry;
	}
	else {
		return NULL;
	}
}
```


Overlapping Code:
```
fEntry* entry;
int i;
for (i = 0; i < wp->numEntries; i++) {
entry = &wp->entries[i];
if (entry->flags && !strcmp(name, entry->name)) {
break;
}
}
if (i < wp->numEntries) { //found a match
return entr
```
<Overlap Ratio: 0.7326007326007326>

---

--- 118 --
Question ID: 25d50bf3432ac48e1dbe6b74b075846523227d3e_7
Original Code:
```
int Fraig_NodeVecPushUniqueOrderByLevel( Fraig_NodeVec_t * p, Fraig_Node_t * pNode )
{
    int i;
    for ( i = 0; i < p->nSize; i++ )
        if ( p->pArray[i] == pNode )
            return 1;
    Fraig_NodeVecPushOrderByLevel( p, pNode );
    return 0;
}
```


Overlapping Code:
```
hUniqueOrderByLevel( Fraig_NodeVec_t * p, Fraig_Node_t * pNode )
{
int i;
for ( i = 0; i < p->nSize; i++ )
if ( p->pArray[i] == pNode )
return 1;
Fraig_NodeVecPushOrderByLevel( p, pNode );
return 0;
}
```
<Overlap Ratio: 0.9090909090909091>

---

--- 119 --
Question ID: a99e4d7e89c2eb3a1a38024b50f3c3d0ccdbfe4e_8
Original Code:
```
static void
check_simple(struct sol_fbp_graph *g)
{
    struct sol_fbp_node *a, *b;

    ASSERT_INT_EQ(g->nodes.len, 2);

    a = find_node(g, "a");
    ASSERT(a);

    b = find_node(g, "b");
    ASSERT(b);

    ASSERT_INT_EQ(a->in_ports.len, 0);
    ASSERT_INT_EQ(a->out_ports.len, 1);
    ASSERT_INT_EQ(b->in_ports.len, 1);
    ASSERT_INT_EQ(b->out_ports.len, 0);

    ASSERT(find_out_port(a, "OUT"));
    ASSERT(find_in_port(b, "IN"));

    ASSERT_INT_EQ(g->conns.len, 1);

    ASSERT(find_conn(g, "a", "OUT", "IN", "b"));
}
```


Overlapping Code:
```
 sol_fbp_graph *g)
{
struct sol_fbp_node *a, *b;
ASSERT_INT_EQ(g->nodes.len, 2);
a = find_node(g, "a");
ASSERT(a);
b = find_node(g, "b");
ASSERT(b);
ASSERT_INT_EQ(a->in_ports.len, 0);
ASSERT_INT_EQ(a->out_ports.len, 1);
ASSERT_INT_EQ(b->in_ports.len, 1);
ASSERT_INT_EQ(b->out_ports.len, 0);
ASSERT(find_out_port(a, "OUT"));
ASSERT(find_in_port(b, "IN"));
ASSERT_INT_EQ(g->conns.len, 1);
ASSERT(find_conn(g
```
<Overlap Ratio: 0.8728448275862069>

---

--- 120 --
Question ID: eaba584e98c31b83de79046f9ddc8e34f44ce284_2
Original Code:
```
int ldap_passwd_s(LDAP *ld, struct berval *user, struct berval *oldpw,
                  struct berval *newpw, struct berval *newpasswd,
                  LDAPControl **sctrls, LDAPControl **cctrls) {
  int rc;
  int msgid;
  LDAPMessage *res;

  rc = ldap_passwd(ld, user, oldpw, newpw, sctrls, cctrls, &msgid);
  if (rc != LDAP_SUCCESS) {
    return rc;
  }

  if (ldap_result(ld, msgid, LDAP_MSG_ALL, (struct timeval *)NULL, &res) ==
          -1 ||
      !res) {
    return ld->ld_errno;
  }

  rc = ldap_parse_passwd(ld, res, newpasswd);
  if (rc != LDAP_SUCCESS) {
    ldap_msgfree(res);
    return rc;
  }

  return (ldap_result2error(ld, res, 1));
}
```


Overlapping Code:
```
P *ld, struct berval *user, struct berval *oldpw,
struct berval *newpw, struct berval *newpasswd,
LDAPControl **sctrls, LDAPControl **cctrls) {
int rc;
int msgid;
LDAPMessage *res;
rc = ldap_passwd(ld, user, oldpw, newpw, sctrls, cctrls, &msgid);
if (rc != LDAP_SUCCESS) {
return rc;
}
if (ldap_result(ld, msgid, LDAP_MSG_ALL, (struct timeval *)NULL, &res) ==
-1 ||
!res) {
return ld->ld_errno;
}
rc = ldap_parse_passwd(ld, res, newpasswd);
if (rc != LDAP_SUCCESS) {
ldap_msgfree(res);
return rc;
}
return (ldap_result2error(ld, re
```
<Overlap Ratio: 0.946524064171123>

---

--- 121 --
Question ID: 03e4375e05566bd7136eaa437425d7c0dc31ad07_18
Original Code:
```
int PSMSettDHCPV4RecordValues(PCOSA_DML_LAN_MANAGEMENT pNewCfg,ULONG instancenum)//LNT_EMU
{
        int retPsmSet = CCSP_SUCCESS;
        char param_name[256] = {0};
        char param_value[256] = {0};
        _ansc_sprintf(param_value, "%d.%d.%d.%d",
            pNewCfg->LanIPAddress.Dot[0], pNewCfg->LanIPAddress.Dot[1], pNewCfg->LanIPAddress.Dot[2], pNewCfg->LanIPAddress.Dot[3]);
         _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_IPROUTERS);
        _ansc_sprintf(param_value, "%d.%d.%d.%d",
            pNewCfg->LanSubnetMask.Dot[0], pNewCfg->LanSubnetMask.Dot[1],pNewCfg->LanSubnetMask.Dot[2],pNewCfg->LanSubnetMask.Dot[3]);
        _PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_SUBNETMASK);
        return 0;
}
```


Overlapping Code:
```
A_DML_LAN_MANAGEMENT pNewCfg,ULONG instancenum)//LNT_EMU
{
int retPsmSet = CCSP_SUCCESS;
char param_name[256] = {0};
char param_value[256] = {0};
_ansc_sprintf(param_value, "%d.%d.%d.%d",
pNewCfg->LanIPAddress.Dot[0], pNewCfg->LanIPAddress.Dot[1], pNewCfg->LanIPAddress.Dot[2], pNewCfg->LanIPAddress.Dot[3]);
_PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_IPROUTERS);
_ansc_sprintf(param_value, "%d.%d.%d.%d",
pNewCfg->LanSubnetMask.Dot[0], pNewCfg->LanSubnetMask.Dot[1],pNewCfg->LanSubnetMask.Dot[2],pNewCfg->LanSubnetMask.Dot[3]);
_PSM_WRITE_PARAM(PSM_DHCPV4_SERVER_POOL_
```
<Overlap Ratio: 0.907051282051282>

---

--- 122 --
Question ID: 32f4451880b461c14bfdd0bd03e5fe4706d48819_4
Original Code:
```
static inline uint16_t fp_fold(uint64_t sum64)
{
    uint32_t sum32;

    /* now fold */
    sum64 = (u32)sum64 + (sum64 >> 32); /* could have overflow on bit 32 */
    sum32 = sum64 + (sum64 >> 32);    /* add the overflow */
    sum32 = (u16)sum32 + (sum32 >> 16); /* could have overflow on bit 16 */
    return ~((u16)sum32 + (u16)(sum32 >> 16)); /* add the overflow */
}
```


Overlapping Code:
```
fold(uint64_t sum64)
{
uint32_t sum32;
/* now fold */
sum64 = (u32)sum64 + (sum64 >> 32); /* could have overflow on bit 32 */
sum32 = sum64 + (sum64 >> 32); /* add the overflow */
sum32 = (u16)sum32 + (sum32 >> 16); /* could have overflow on bit 16 */
return ~((u16)sum32 + (u16)(sum32 >> 16)); /* add t
```
<Overlap Ratio: 0.8782608695652174>

---

--- 123 --
Question ID: 59eb1169f5a4e54c213cf5dd2a2d328614b3fd66_16
Original Code:
```
static void VecDT_Save(RedisModuleIO *rdb, void *value){
    VecDT* vDT = value;

    RedisModule_SaveString(rdb, vDT->keyName);
    RedisModule_SaveStringBuffer(rdb, (char*)&HOLDER_VEC(vDT->holder, vDT->index), sizeof(float) * VEC_SIZE);
}
```


Overlapping Code:
```
cDT_Save(RedisModuleIO *rdb, void *value){
VecDT* vDT = value;
RedisModule_SaveString(rdb, vDT->keyName);
RedisModule_SaveStringBuffer(rdb, (char*)&HOLDER_VEC(vDT->holder, vDT->index), sizeof(float) *
```
<Overlap Ratio: 0.8810572687224669>

---

--- 124 --
Question ID: 65f8d457dbffee199a82478c5016c3509ae76f18_9
Original Code:
```
static void outflush()

#endif
{
    char           *buf;
    int             got;
    uint            len;

    /* if (bufidx - buf > 0) */
	for (buf = bufstart; len = bufidx - buf;) {
	    if ((got = write(archivefd, buf, MIN(len, blocksize))) > 0) {
		buf += got;
	    } else if (got < 0) {
		next(AR_WRITE);
	    }
	}
    bufend = (bufidx = bufstart) + blocksize;
}
```


Overlapping Code:
```
 void outflush()
#endif
{
char *buf;
int got;
uint len;
/* if (bufidx - buf > 0) */
for (buf = bufstart; len = bufidx - buf;) {
if ((got = write(archivefd, buf, MIN(len, blocksize))) > 0) {
buf += got;
} else if (got < 0) {
next(AR_WRITE);
}
}
bufend
```
<Overlap Ratio: 0.8532423208191127>

---

--- 125 --
Question ID: 50984a3707680c1746868bcc4693c920145f81c7_56
Original Code:
```
JNICALL Java_com_virgilsecurity_crypto_phe_PheJNI_uokmsWrapRotation_1new__ (JNIEnv *jenv, jobject jobj) {
    jlong c_ctx = 0;
    *(vsce_uokms_wrap_rotation_t **)&c_ctx = vsce_uokms_wrap_rotation_new();
    return c_ctx;
}
```


Overlapping Code:
```
JNICALL Java_com_virgilsecurity_crypto_phe_PheJNI_uokmsWrapRotation_1new__ (JNIEnv *jenv, jobject jobj) {
jlong c_ctx = 0;
*(vsce_uokms_wrap_rotation_t **)&c_ctx = vsce_uokms_wrap_rotatio
```
<Overlap Ratio: 0.8862559241706162>

---

--- 126 --
Question ID: 1119414f65a6df1bc9e3cfd8bfa7a25dc35398aa_4
Original Code:
```
void bftraversal(int adj[MAX][MAX], int n, int state[], int queue[], int front, int rear)
{
	int v;
	for (v=0;v<n;v++)
		state[v]=initial;
	printf("Enter starting vertex for bfs: ");
	scanf("%d",&v);
	bfs(v,adj,n,state,queue,front,rear);
	/* // Add code to print all vertices (unreachable from starting vertex)
	for (v=0;v<n;v++)
	{
		if (state[v]==initial)
			bfs(v,adj,n,state,queue,front,rear);
	}
	*/
}
```


Overlapping Code:
```
], int n, int state[], int queue[], int front, int rear)
{
int v;
for (v=0;v<n;v++)
state[v]=initial;
printf("Enter starting vertex for bfs: ");
scanf("%d",&v);
bfs(v,adj,n,state,queue,front,rear);
/* // Add code to print all vertices (unreachable from starting vertex)
for (v=0;v<n;v++)
{
if (state[v]==initial)
bfs(v,adj,n,state,queue,front,rear);

```
<Overlap Ratio: 0.8997429305912596>

---

--- 127 --
Question ID: 36df6c7d7681661367e8b641b1afe9a66416636d_2
Original Code:
```
int32_t ATCmd_okResult(void)
{    
    ATCmd_Event_t eventMsg;
    
    eventMsg.callback = NULL;
    eventMsg.args = (void *)(ATCmd_okStr);
    ATCmd_signalEvent(&eventMsg);
    return 0;
}
```


Overlapping Code:
```
TCmd_okResult(void)
{ 
ATCmd_Event_t eventMsg;

eventMsg.callback = NULL;
eventMsg.args = (void *)(ATCmd_okStr);
ATCmd_signalEvent(&eventMsg);
return 
```
<Overlap Ratio: 0.9202453987730062>

---

--- 128 --
Question ID: 4a246631931890fc4ff13200e636e185a81012f1_0
Original Code:
```
namespace bn
{
    /**
     * @brief To be part of a intrusive_list, values must inherit this class.
     *
     * @ingroup intrusive_list
     */
    class intrusive_list_node_type;

    /**
     * @brief Intrusive list implementation.
     *
     * @tparam Type Element type (it must inherit intrusive_list_node_type class).
     *
     * @ingroup intrusive_list
     */
    template<class Type>
    class intrusive_list;
}
```


Overlapping Code:
```

/**
* @brief To be part of a intrusive_list, values must inherit this class.
*
* @ingroup intrusive_list
*/
class intrusive_list_node_type;
/**
* @brief Intrusive list implementation.
*
* @tparam Type Element type (it must inherit intrusive_list_node_type class).
*
* @ingroup intrusive_list
*/
template<class Type>
class intrusive_list;

```
<Overlap Ratio: 0.9576271186440678>

---

--- 129 --
Question ID: 3629ff296da2639c9f78f666545beff5872e0421_93
Original Code:
```
static inline VALUE
vm_getivar(VALUE obj, ID id, IVC ic, struct rb_call_cache *cc, int is_attr)
{

    VALUE val = ((VALUE)RUBY_Qundef);

    if ((((VALUE)(obj) & RUBY_IMMEDIATE_MASK) || !!(((VALUE)(obj) & (VALUE)~((VALUE)RUBY_Qnil)) == 0))) {

    }
    else if ((__builtin_expect(!!(is_attr ? (cc->aux.index > 0) : (ic->ic_serial == (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial))), 1))) {



        st_index_t index = !is_attr ? ic->index : (cc->aux.index - 1);

        ((void)0);

        if ((__builtin_expect(!!((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT), 1)) &&
            (__builtin_expect(!!(index < ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv)), 1))) {
            val = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr)[index];
        }
        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {
            struct gen_ivtbl *ivtbl;

            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1)) &&
                (__builtin_expect(!!(index < ivtbl->numiv), 1))) {
                val = ivtbl->ivptr[index];
            }
        }
        goto ret;
    }
    else {
        struct st_table *iv_index_tbl;
        st_index_t numiv;
        VALUE *ivptr;

        st_data_t index;

        if ((int)(((struct RBasic*)(obj))->flags & RUBY_T_MASK) == RUBY_T_OBJECT) {
            iv_index_tbl = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl) : ((struct RObject*)(obj))->as.heap.iv_index_tbl);
            numiv = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ROBJECT_EMBED_LEN_MAX : ((struct RObject*)(obj))->as.heap.numiv);
            ivptr = ((((struct RBasic*)(obj))->flags & ROBJECT_EMBED) ? ((struct RObject*)(obj))->as.ary : ((struct RObject*)(obj))->as.heap.ivptr);

          fill:
     if (iv_index_tbl) {
  if (rb_st_lookup(iv_index_tbl, id, &index)) {
                    if (!is_attr) {
                        ic->index = index;
                        ic->ic_serial = (((struct RClass*)(((struct RBasic*)(obj))->klass))->class_serial);
                    }
                    else {
                        cc->aux.index = (int)index + 1;
                    }

                    if (index < numiv) {
                        val = ivptr[index];
      }
  }
     }
 }
        else if ((((struct RBasic*)(obj))->flags&(((VALUE)RUBY_FL_EXIVAR)))) {
            struct gen_ivtbl *ivtbl;

            if ((__builtin_expect(!!(rb_st_lookup(rb_ivar_generic_ivtbl(), (st_data_t)obj, (st_data_t *)&ivtbl)), 1))) {
                numiv = ivtbl->numiv;
                ivptr = ivtbl->ivptr;
                iv_index_tbl = ((((struct RClass*)(rb_obj_class(obj)))->ptr)->iv_index_tbl);
                goto fill;
            }
        }
        else {

            goto general_path;
        }

      ret:
        if ((__builtin_expect(!!(val != ((VALUE)RUBY_Qundef)), 1))) {
            return val;
        }
        else {
            if (!is_attr && !(((VALUE)((*rb_ruby_verbose_ptr())) & (VALUE)~((VALUE)RUBY_Qnil)) == 0)) {
                rb_warning("instance variable %""l""i" "\v"" not initialized", rb_id_quote_unprintable(id));
            }
            return ((VALUE)RUBY_Qnil);
        }
    }
  general_path:

    ((void)0);

    if (is_attr) {
        return rb_attr_get(obj, id);
    }
    else {
        return rb_ivar_get(obj, id);
    }
}
```


Overlapping Code:
```
tbl->numiv), 1))) {
val = ivtbl->ivptr[index];
}
}
```
<Overlap Ratio: 0.0246669955599408>

---

--- 130 --
Question ID: 7f8079ba2a17dac5dfdf1140f52c2102fa7a9aca_1
Original Code:
```
int main(int argc, char **argv) {
  // MU_RUN_TEST(testTagFunc);
  RedisModule_Alloc = malloc;
  RedisModule_Calloc = calloc;
  RedisModule_Realloc = realloc;
  RedisModule_Free = free;
  IndexAlias_InitGlobal();
  MU_RUN_TEST(testCommandMux);

  MU_REPORT();
  return minunit_status;
}
```


Overlapping Code:
```
argc, char **argv) {
// MU_RUN_TEST(testTagFunc);
RedisModule_Alloc = malloc;
RedisModule_Calloc = calloc;
RedisModule_Realloc = realloc;
RedisModule_Free = free;
IndexAlias_InitGlobal();
MU_RUN_TEST(testCommandMux);
MU_REPORT();
return minunit_statu
```
<Overlap Ratio: 0.9363295880149812>

---

--- 131 --
Question ID: 66060a326c76398976637abbff57c7fcc3be2a11_26
Original Code:
```
int Si3226x_EnableInterrupts (proslicChanType_ptr pProslic){
    WriteReg (pProHW,pProslic->channel,IRQEN1,Si3226x_General_Configuration.irqen1);
    WriteReg (pProHW,pProslic->channel,IRQEN2,Si3226x_General_Configuration.irqen2);
    WriteReg (pProHW,pProslic->channel,IRQEN3,Si3226x_General_Configuration.irqen3);
    WriteReg (pProHW,pProslic->channel,IRQEN4,Si3226x_General_Configuration.irqen4);
    return 0;
}
```


Overlapping Code:
```
EnableInterrupts (proslicChanType_ptr pProslic){
WriteReg (pProHW,pProslic->channel,IRQEN1,Si3226x_General_Configuration.irqen1);
WriteReg (pProHW,pProslic->channel,IRQEN2,Si3226x_General_Configuration.irqen2);
WriteReg (pProHW,pProslic->channel,IRQEN3,Si3226x_General_Configuration.irqen3);
WriteReg (pProHW,pProslic->channel,IRQEN4,Si3226x_General_Conf
```
<Overlap Ratio: 0.8939393939393939>

---

--- 132 --
Question ID: 1e5ee7244aa46abbd6ec20ac61f040543d1abcbe_17
Original Code:
```
static uint32_t parse_shift_expr(struct lex_ctx_t *ctx, struct cmd_option_t *const_list)
{
    uint32_t v = parse_term_expr(ctx, const_list);
    while(ctx->lexem.type == LEX_LSHIFT)
    {
        next(ctx, true);
        v <<= parse_term_expr(ctx, const_list);
    }
    return v;
}
```


Overlapping Code:
```
nt32_t parse_shift_expr(struct lex_ctx_t *ctx, struct cmd_option_t *const_list)
{
uint32_t v = parse_term_expr(ctx, const_list);
while(ctx->lexem.type == LEX_LSHIFT)
{
next(ctx, true);
v <<= parse_ter
```
<Overlap Ratio: 0.8097165991902834>

---

--- 133 --
Question ID: 6cd7d0740005954ed37f33617298faee60816386_4
Original Code:
```
static void __init test_copy(void)
{
	DECLARE_BITMAP(bmap1, 1024);
	DECLARE_BITMAP(bmap2, 1024);

	bitmap_zero(bmap1, 1024);
	bitmap_zero(bmap2, 1024);

	/* single-word bitmaps */
	bitmap_set(bmap1, 0, 19);
	bitmap_copy(bmap2, bmap1, 23);
	expect_eq_pbl("0-18", bmap2, 1024);

	bitmap_set(bmap2, 0, 23);
	bitmap_copy(bmap2, bmap1, 23);
	expect_eq_pbl("0-18", bmap2, 1024);

	/* multi-word bitmaps */
	bitmap_set(bmap1, 0, 109);
	bitmap_copy(bmap2, bmap1, 1024);
	expect_eq_pbl("0-108", bmap2, 1024);

	bitmap_fill(bmap2, 1024);
	bitmap_copy(bmap2, bmap1, 1024);
	expect_eq_pbl("0-108", bmap2, 1024);

	/* the following tests assume a 32- or 64-bit arch (even 128b
	 * if we care)
	 */

	bitmap_fill(bmap2, 1024);
	bitmap_copy(bmap2, bmap1, 109);  /* ... but 0-padded til word length */
	expect_eq_pbl("0-108,128-1023", bmap2, 1024);

	bitmap_fill(bmap2, 1024);
	bitmap_copy(bmap2, bmap1, 97);  /* ... but aligned on word length */
	expect_eq_pbl("0-108,128-1023", bmap2, 1024);
}
```


Overlapping Code:
```
 void __init test_copy(void)
{
DECLARE_BITMAP(bmap1, 1024);
DECLARE_BITMAP(bmap2, 1024);
bitmap_zero(bmap1, 1024);
bitmap_zero(bmap2, 1024);
/* single-word bitmaps */
bitmap_set(bmap1, 0, 19);
bitmap_copy(bmap2, bmap1, 23);
expect_eq_pbl("0-18", bmap2, 1024);
bitmap_set(bmap2, 0, 23);
bitmap_copy(bmap2, bmap1, 23);
expect_eq_pbl("0-18", bmap2, 1024);
/* multi-word bitmaps */
bitmap_set(bmap1, 0, 109);
bitmap_copy(bmap2, bmap1, 1024);
expect_eq_pbl("0-108", bmap2, 1024);
bitmap_fill(bmap2, 1024);
bitmap_copy(bmap2, bmap1, 1024);
expect_eq_pbl("0-108", bmap2, 1024);
/* the following tests assume a 32- or 64-bit arch (even 128b
* if we care)
*/
bitmap_fill(bmap2, 1024);
bitmap_copy(bmap2, bmap1, 109); /* ... but 0-padded til word length */
expect_eq_pbl("0-108,128-1023", bmap2, 1024);
bitmap_fill(bmap2, 1024);
bitmap_copy(bmap2, bmap1, 97); /* ... but aligned on word length */
expect_eq_pbl("0-108,128-1023", bmap2, 1024)
```
<Overlap Ratio: 0.9904255319148936>

---

--- 134 --
Question ID: cf42e96b4f44c3879419e1fe162327cfc743ab91_0
Original Code:
```
static int _find_upper(int ch)  {


	int low = 0;
	int high = CAPS_LEN -1;
	int middle;

	while( low <= high )
	{
		middle = ( low  + high ) / 2;

		if( ch < caps_table[ middle][0] ) {
			high = middle - 1; //search low end of array
		} else if ( caps_table[middle][0] < ch) {
			low = middle + 1; //search high end of array
		} else {
			return caps_table[middle][1];
		}
	}

	return ch;
}
```


Overlapping Code:
```
ch) {
int low = 0;
int high = CAPS_LEN -1;
int middle;
while( low <= high )
{
middle = ( low + high ) / 2;
if( ch < caps_table[ middle][0] ) {
high = middle - 1; //search low end of array
} else if ( caps_table[middle][0] < ch) {
low = middle + 1; //search high end of array
} else {
return caps_table[middle][1];
}
}
return 
```
<Overlap Ratio: 0.9103641456582633>

---

--- 135 --
Question ID: d0391bcaed60a9de64d09807a1b66695f2155787_11
Original Code:
```
static void
_HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx,
    uint32_t tmp32[static restrict 72], uint8_t ihash[static restrict 32])
{

	/* Finish the inner SHA256 operation. */
	_SHA256_Final(ihash, &ctx->ictx, tmp32);

	/* Feed the inner hash to the outer SHA256 operation. */
	_SHA256_Update(&ctx->octx, ihash, 32, tmp32);

	/* Finish the outer SHA256 operation. */
	_SHA256_Final(digest, &ctx->octx, tmp32);
}
```


Overlapping Code:
```
static void
_HMAC_SHA256_Final(uint8_t digest[32], HMAC_SHA256_CTX * ctx,
uint32_t tmp32[static restrict 72], uint8_t ihash[static restrict 32])
{
/* Finish the inner SHA256 operation. */
_SHA256_Final(ihash, &ctx->ictx, tmp32);
/* Feed the inner hash to the outer SHA256 operation. */
_SHA256_Update(&ctx->octx, ihash, 32, tmp32);
/* Finish the outer SHA256 operation. */
_SHA256_Final(digest, &ctx->octx, t
```
<Overlap Ratio: 0.9807692307692307>

---

--- 136 --
Question ID: 1e939300fa0ed3ea4f66f806e31d7c9db5679e41_4
Original Code:
```
static int __init
acpi_parse_lapic_addr_ovr (acpi_table_entry_header *header)
{
	struct acpi_table_lapic_addr_ovr *lapic;

	lapic = (struct acpi_table_lapic_addr_ovr *) header;
	if (!lapic)
		return -EINVAL;

	acpi_table_print_madt_entry(header);

	if (lapic->address) {
		iounmap((void *) ipi_base_addr);
		ipi_base_addr = (unsigned long) ioremap(lapic->address, 0);
	}
	return 0;
}
```


Overlapping Code:
```
atic int __init
acpi_parse_lapic_addr_ovr (acpi_table_entry_header *header)
{
struct acpi_table_lapic_addr_ovr *lapic;
lapic = (struct acpi_table_lapic_addr_ovr *) header;
if (!lapic)
return -EINVAL;
acpi_table_print_madt_entry(header);
if (lapic->address) {
iounmap((void *) ipi_base_addr);
ipi_base_addr = (unsigned long) ioremap(lapic->address, 0);
}
return 0;

```
<Overlap Ratio: 0.9918256130790191>

---

--- 137 --
Question ID: f7d8adca84f47de9d9cc21a4fb67892e094cfa0f_79
Original Code:
```
static guint16
de_rr_vgcs_tar_mode_ind(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)
{
    guint32	curr_offset;

    curr_offset = offset;

    proto_tree_add_item(tree, hf_gsm_a_rr_target_mode, tvb, curr_offset, 1, FALSE);
    proto_tree_add_item(tree, hf_gsm_a_rr_group_cipher_key_number, tvb, curr_offset, 1, FALSE);
    curr_offset = curr_offset + 1;

    return(curr_offset - offset);
}
```


Overlapping Code:
```
(tvbuff_t *tvb, proto_tree *tree, guint32 offset, guint len _U_, gchar *add_string _U_, int string_len _U_)
{
guint32 curr_offset;
curr_offset = offset;
proto_tree_add_item(tree, hf_gsm_a_rr_target_mode, tvb, curr_offset, 1, FALSE);
proto_tree_add_item(tree, hf_gsm_a_rr_group_cipher_key_number, tvb, curr_offset, 1, FALSE);
curr_offset = curr_offset + 1;
return(curr_offset - offset);
```
<Overlap Ratio: 0.9058823529411765>

---

--- 138 --
Question ID: ac4e2de5d06f5e28cb45a554d9ad759392df799a_1
Original Code:
```
const char* GetModStringID(const int id)
{
	int i = 0;
	for(i = 0; i < (sizeof(g_IDs)/sizeof(g_IDs[0])); i++){
		if(g_IDs[i].number == id){
			return g_IDs[i].string;
		}
	}
	return NULL;
}
```


Overlapping Code:
```
har* GetModStringID(const int id)
{
int i = 0;
for(i = 0; i < (sizeof(g_IDs)/sizeof(g_IDs[0])); i++){
if(g_IDs[i].number == id){
return g_IDs[i].strin
```
<Overlap Ratio: 0.8426966292134831>

---

--- 139 --
Question ID: ea56b263a773d97c16ffa067bfa35320f5c9039b_2
Original Code:
```
static void loraWriteReg(uint16_t addr, uint8_t *buf, uint32_t len)
{
    uint32_t err_code;
    uint8_t m_tx_buf; /**< TX buffer. */
    uint8_t m_rx_buf; /**< RX buffer. */

    loraWaitOnBusy();
    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_LOW);

    atcmd_printf("writereg=0x%x\r\n", addr);

    m_tx_buf = 0x0D; //Write reg
    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
    //atcmd_printf("err_code=0x%x\r\n", err_code);

    m_tx_buf = (addr & 0xFF00) >> 8;
    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
    //atcmd_printf("err_code=0x%x\r\n", err_code);

    m_tx_buf = (addr & 0x00FF);
    err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
    //atcmd_printf("err_code=0x%x\r\n", err_code);

    //m_tx_buf = 0;
    //err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);

    m_rx_buf = 0;
    for (int i = 0; i < len; i++)
    {
        m_tx_buf = *(buf + i);
        err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
        atcmd_printf("m_tx_buf=0x%x\r\n", m_tx_buf);
    }

    atcmd_printf("=====\r\n");

    udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_HIGH);
    loraWaitOnBusy();
}
```


Overlapping Code:
```
Reg(uint16_t addr, uint8_t *buf, uint32_t len)
{
uint32_t err_code;
uint8_t m_tx_buf; /**< TX buffer. */
uint8_t m_rx_buf; /**< RX buffer. */
loraWaitOnBusy();
udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_LOW);
atcmd_printf("writereg=0x%x\r\n", addr);
m_tx_buf = 0x0D; //Write reg
err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
//atcmd_printf("err_code=0x%x\r\n", err_code);
m_tx_buf = (addr & 0xFF00) >> 8;
err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
//atcmd_printf("err_code=0x%x\r\n", err_code);
m_tx_buf = (addr & 0x00FF);
err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
//atcmd_printf("err_code=0x%x\r\n", err_code);
//m_tx_buf = 0;
//err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
m_rx_buf = 0;
for (int i = 0; i < len; i++)
{
m_tx_buf = *(buf + i);
err_code = udrv_spimst_trx((udrv_spimst_port)LORA_IO_SPI_PORT, (uint8_t *)&m_tx_buf, 1, (uint8_t *)&m_rx_buf, 1, 0);
atcmd_printf("m_tx_buf=0x%x\r\n", m_tx_buf);
}
atcmd_printf("=====\r\n");
udrv_gpio_set_logic(42 /*NSS*/, GPIO_LOGIC_HIGH);
loraWaitOnBusy(
```
<Overlap Ratio: 0.9810174639331815>

---

--- 140 --
Question ID: 46b5da551db35711ad529639cf0ddf4f7abaaba0_10
Original Code:
```
static void
nvc0_blit_set_dst(struct nvc0_context *nvc0,
                  struct pipe_resource *res, unsigned level, unsigned layer)
{
   struct pipe_context *pipe = &nvc0->base.pipe;
   struct pipe_surface templ;

   if (util_format_is_depth_or_stencil(res->format))
      templ.format = nvc0_blit_zeta_to_colour_format(res->format);
   else
      templ.format = res->format;

   templ.usage = PIPE_USAGE_STREAM;
   templ.u.tex.level = level;
   templ.u.tex.first_layer = templ.u.tex.last_layer = layer;

   nvc0->framebuffer.cbufs[0] = nvc0_miptree_surface_new(pipe, res, &templ);
   nvc0->framebuffer.nr_cbufs = 1;
   nvc0->framebuffer.zsbuf = NULL;
   nvc0->framebuffer.width = nvc0->framebuffer.cbufs[0]->width;
   nvc0->framebuffer.height = nvc0->framebuffer.cbufs[0]->height;
}
```


Overlapping Code:
```
ruct nvc0_context *nvc0,
struct pipe_resource *res, unsigned level, unsigned layer)
{
struct pipe_context *pipe = &nvc0->base.pipe;
struct pipe_surface templ;
if (util_format_is_depth_or_stencil(res->format))
templ.format = nvc0_blit_zeta_to_colour_format(res->format);
else
templ.format = res->format;
templ.usage = PIPE_USAGE_STREAM;
templ.u.tex.level = level;
templ.u.tex.first_layer = templ.u.tex.last_layer = layer;
nvc0->framebuffer.cbufs[0] = nvc0_miptree_surface_new(pipe, res, &templ);
nvc0->framebuffer.nr_cbufs = 1;
nvc0->framebuffer.zsbuf = NULL;
nvc0->framebuffer.width = nvc0->framebuffer.cbufs[0]->width;
nvc0->framebuffer.height = nvc0->framebuffer.cbufs[
```
<Overlap Ratio: 0.9371508379888268>

---

--- 141 --
Question ID: a246d4d64b8b0c2f58c06b5fbe0b67c50314c015_20
Original Code:
```
static int mt9v022_s_mbus_config(struct v4l2_subdev *sd,
				 const struct v4l2_mbus_config *cfg)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
	struct mt9v022 *mt9v022 = to_mt9v022(client);
	unsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);
	unsigned int bps = soc_mbus_get_fmtdesc(mt9v022->fmt->code)->bits_per_sample;
	int ret;
	u16 pixclk = 0;

	if (ssdd->set_bus_param) {
		ret = ssdd->set_bus_param(ssdd, 1 << (bps - 1));
		if (ret)
			return ret;
	} else if (bps != 10) {
		/*
		 * Without board specific bus width settings we only support the
		 * sensors native bus width
		 */
		return -EINVAL;
	}

	if (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)
		pixclk |= 0x10;

	if (!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH))
		pixclk |= 0x1;

	if (!(flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH))
		pixclk |= 0x2;

	ret = reg_write(client, mt9v022->reg->pixclk_fv_lv, pixclk);
	if (ret < 0)
		return ret;

	if (!(flags & V4L2_MBUS_MASTER))
		mt9v022->chip_control &= ~0x8;

	ret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);
	if (ret < 0)
		return ret;

	dev_dbg(&client->dev, "Calculated pixclk 0x%x, chip control 0x%x\n",
		pixclk, mt9v022->chip_control);

	return 0;
}
```


Overlapping Code:
```
s_mbus_config(struct v4l2_subdev *sd,
const struct v4l2_mbus_config *cfg)
{
struct i2c_client *client = v4l2_get_subdevdata(sd);
struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
struct mt9v022 *mt9v022 = to_mt9v022(client);
unsigned long flags = soc_camera_apply_board_flags(ssdd, cfg);
unsigned int bps = soc_mbus_get_fmtdesc(mt9v022->fmt->code)->bits_per_sample;
int ret;
u16 pixclk = 0;
if (ssdd->set_bus_param) {
ret = ssdd->set_bus_param(ssdd, 1 << (bps - 1));
if (ret)
return ret;
} else if (bps != 10) {
/*
* Without board specific bus width settings we only support the
* sensors native bus width
*/
return -EINVAL;
}
if (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)
pixclk |= 0x10;
if (!(flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH))
pixclk |= 0x1;
if (!(flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH))
pixclk |= 0x2;
ret = reg_write(client, mt9v022->reg->pixclk_fv_lv, pixclk);
if (ret < 0)
return ret;
if (!(flags & V4L2_MBUS_MASTER))
mt9v022->chip_control &= ~0x8;
ret = reg_write(client, MT9V022_CHIP_CONTROL, mt9v022->chip_control);
if (ret < 0)
return ret;
dev_dbg(&client->dev, "Calculated pixclk 0x%x, chip control 0x%x\n",
pixclk, mt9v022->chip_control);
retur
```
<Overlap Ratio: 0.9791666666666666>

---

--- 142 --
Question ID: 82855af1a9c6fb71bcc45539ab563867e17eeecb_3
Original Code:
```
void i2c_dir_fill_inode(struct inode *inode, int fill)
{
	int i;
	struct i2c_client *client;

#ifdef DEBUG
	if (!inode) {
		printk("i2c-proc.o: Warning: inode NULL in fill_inode()\n");
		return;
	}
#endif				/* def DEBUG */

	for (i = 0; i < SENSORS_ENTRY_MAX; i++)
		if (i2c_clients[i]
		    && (i2c_inodes[i] == inode->i_ino)) break;
#ifdef DEBUG
	if (i == SENSORS_ENTRY_MAX) {
		printk
		    ("i2c-proc.o: Warning: inode (%ld) not found in fill_inode()\n",
		     inode->i_ino);
		return;
	}
#endif				/* def DEBUG */
	client = i2c_clients[i];
	if (fill)
		client->driver->inc_use(client);
	else
		client->driver->dec_use(client);
}
```


Overlapping Code:
```
ode(struct inode *inode, int fill)
{
int i;
struct i2c_client *client;
#ifdef DEBUG
if (!inode) {
printk("i2c-proc.o: Warning: inode NULL in fill_inode()\n");
return;
}
#endif /* def DEBUG */
for (i = 0; i < SENSORS_ENTRY_MAX; i++)
if (i2c_clients[i]
&& (i2c_inodes[i] == inode->i_ino)) break;
#ifdef DEBUG
if (i == SENSORS_ENTRY_MAX) {
printk
("i2c-proc.o: Warning: inode (%ld) not found in fill_inode()\n",
inode->i_ino);
return;
}
#endif /* def DEBUG */
client = i2c_clients[i];
if (fill)
client->driver->inc_use(client);
else
client->driver->dec_
```
<Overlap Ratio: 0.9417808219178082>

---

--- 143 --
Question ID: 8d9976707e822ca4b0b3575c523acea3055ff1e6_19
Original Code:
```
bool downsampleBamChunkReadWithVcfEntrySubstringsViaFullReadLengthLikelihood(int64_t intendedDepth,
                                                                             stList *chunkVcfEntries,
                                                                             stList *inputReads,
                                                                             stList *maintainedReads,
                                                                             stList *discardedReads) {

    // calculate depth, generate bcrwhs list
    int64_t totalVcfEntries = 0;

    int *readLengths = st_calloc(stList_length(inputReads), sizeof(int));
    int *readFullLengths = st_calloc(stList_length(inputReads), sizeof(int));

    for (int64_t i = 0; i < stList_length(inputReads); i++) {
        BamChunkRead *bcr = stList_get(inputReads, i);
        BamChunkReadVcfEntrySubstrings *bcrves = bcr->bamChunkReadVcfEntrySubstrings;
        assert(bcrves != NULL);
        totalVcfEntries += (int) stList_length(bcrves->vcfEntries);
        readLengths[i] = (int) stList_length(bcrves->vcfEntries);
        // give reads a pseudocount
        readFullLengths[i] = (int) bcr->fullReadLength;
    }
    int64_t chunkSize = stList_length(chunkVcfEntries);
    double averageDepth = 1.0 * totalVcfEntries / chunkSize;

    // do we need to downsample?
    if (averageDepth < intendedDepth) {
        free(readLengths);
        free(readFullLengths);
        return FALSE;
    }
    char *logIdentifier = getLogIdentifier();

    // is there something wrong with this chunk?
    if (chunkSize == 0 || totalVcfEntries == 0) {
        st_logInfo(" %s Downsampling all reads in chunk with %"PRId64" reads (%"PRId64" incoming filtered), as it has %"PRId64" spanned variants (chunk has %"PRId64")\n",
                   logIdentifier, stList_length(inputReads), stList_length(discardedReads), totalVcfEntries, chunkSize);

        // "filter" everything and return
        for (int64_t i = 0; i < stList_length(inputReads); i++) {
            stList_append(discardedReads, stList_get(inputReads, i));
        }
        free(readLengths);
        free(readFullLengths);
        free(logIdentifier);
        return TRUE;
    }

    // we do need to downsample
    st_logInfo(" %s Downsampling chunk with %"PRId64" reads via spanned variant count with average depth %.2fx to %dx.\n",
               logIdentifier, stList_length(inputReads), averageDepth, intendedDepth);

    // get likelihood of keeping each read
    double *probs = computeReadProbsByLengthAndSecondMetric(readLengths, readFullLengths,
                                                            (int) stList_length(inputReads),
                                                            intendedDepth, (int) chunkSize);

    // keep some ratio of reads
    int64_t totalKeptVariants = 0;
    for (int64_t i = 0; i < stList_length(inputReads); i++) {
        BamChunkRead *bcr = stList_get(inputReads, i);
        if (st_random() < probs[i]) {
            stList_append(maintainedReads, stList_get(inputReads, i));
            totalKeptVariants += stList_length(bcr->bamChunkReadVcfEntrySubstrings->readSubstrings);
        } else {
            stList_append(discardedReads, stList_get(inputReads, i));
        }
    }
    st_logInfo(" %s Downsampled chunk via spanned variant count with to average depth %.2fx (expected %dx)\n",
               logIdentifier, 1.0 * totalKeptVariants / chunkSize, intendedDepth);

    free(probs);
    free(readLengths);
    free(readFullLengths);
    free(logIdentifier);
    return TRUE;
}
```


Overlapping Code:
```
unkReadWithVcfEntrySubstringsViaFullReadLengthLikelihood(int64_t intendedDepth,
stList *chunkVcfEntries,
stList *inputReads,
stList *maintainedReads,
stList *discardedReads) {
// calculate depth, generate bcrwhs list
int64_t totalVcfEntries = 0;
int *readLengths = st_calloc(stList_length(inputReads), sizeof(int));
int *readFullLengths = st_calloc(stList_length(inputReads), sizeof(int));
for (int64_t i = 0; i < stList_length(inputReads); i++) {
BamChunkRead *bcr = stList_get(inputReads, i);
BamChunkReadVcfEntrySubstrings *bcrves = bcr->bamChunkReadVcfEntrySubstrings;
assert(bcrves != NULL);
totalVcfEntries += (int) stList_length(bcrves->vcfEntries);
readLengths[i] = (int) stList_length(bcrves->vcfEntries);
// give reads a pseudocount
readFullLengths[i] = (int) bcr->fullReadLength;
}
int64_t chunkSize = stList_length(chunkVcfEntries);
double averageDepth = 1.0 * totalVcfEntries / chunkSize;
// do we need to downsample?
if (averageDepth < intendedDepth) {
free(readLengths);
free(readFullLengths);
return FALSE;
}
char *logIdentifier = getLogIdentifier();
// is there something wrong with this chunk?
if (chunkSize == 0 || totalVcfEntries == 0) {
st_logInfo(" %s Downsampling all reads in chunk with %"PRId64" reads (%"PRId64" incoming filtered), as it has %"PRId64" spanned variants (chunk has %"PRId64")\n",
logIdentifier, stList_length(inputReads), stList_length(discardedReads), totalVcfEntries, chunkSize);
// "filter" everything and return
for (int64_t i = 0; i < stList_length(inputReads); i++) {
stList_append(discardedReads, stList_get(inputReads, i));
}
free(readLengths);
free(readFullLengths);
free(logIdentifier);
return TRUE;
}
// we do need to downsample
st_logInfo(" %s Downsampling chunk with %"PRId64" reads via spanned variant count with average depth %.2fx to %dx.\n",
logIdentifier, stList_length(inputReads), averageDepth, intendedDepth)
```
<Overlap Ratio: 0.9739583333333334>

---

--- 144 --
Question ID: 581e6e55dc290f2fb40c38a484160f44a36c07c5_0
Original Code:
```
namespace PlayFab
{
    typedef std::shared_ptr<void> SharedVoidPointer;

    struct HttpRequest // TODO: Rename to CallRequestContainer to match other sdks
    {
        HttpRequest(std::string method, std::string url);
        ~HttpRequest();

        void SetBody(std::string body);
        void CompressBody(int level = -1);
        int GetCompressionLevel() const;

        void SetResultCallback(SharedVoidPointer callback);
        SharedVoidPointer GetResultCallback() const;

        void SetErrorCallback(ErrorCallback callback);
        ErrorCallback GetErrorCallback() const;

        void SetUserData(void* data);
        void* GetUserData() const;

        void AcceptGZip(bool accept = true);
        bool GetAcceptGZip() const;

        void SetHeader(std::string key, std::string value);
        bool GetHeader(size_t index, std::string& header) const;
        size_t GetHeaderCount() const;

        void AppendToResponse(std::string text);
        std::string GetReponse() const;

        bool mAcceptGZip;
        int mCompression;
        std::string mUrl;
        cocos2d::network::HttpRequest::Type mMethod;
        std::string mBody;
        std::vector<std::string> mHeaders;

        SharedVoidPointer mResultCallbackFunc = nullptr;
        ErrorCallback mErrorCallback;
        void* mUserData;

        std::string mResponse;
    };

}
```


Overlapping Code:
```
tr<void> SharedVoidPointer;
struct HttpRequest // TODO: Rename to CallRequestContainer to match other sdks
{
HttpRequest(std::string method, std::string url);
~HttpRequest();
void SetBody(std::string body);
void CompressBody(int level = -1);
int GetCompressionLevel() const;
void SetResultCallback(SharedVoidPointer callback);
SharedVoidPointer GetResultCallback() const;
void SetErrorCallback(ErrorCallback callback);
ErrorCallback GetErrorCallback() const;
void SetUserData(void* data);
void* GetUserData() const;
void AcceptGZip(bool accept = true);
bool GetAcceptGZip() const;
void SetHeader(std::string key, std::string value);
bool GetHeader(size_t index, std::string& header) const;
size_t GetHeaderCount() const;
void AppendToResponse(std::string text);
std::string GetReponse() const;
bool mAcceptGZip;
int mCompression;
std::string mUrl;
cocos2d::network::HttpRequest::Type mMethod;
std::string mBody;
std::vector<std::string> mHeaders;
SharedVoidPointer mResultCallbackFunc = nullptr;
ErrorCallback mErrorCallback;
void* mUserData;
std::st
```
<Overlap Ratio: 0.9450945094509451>

---

--- 145 --
Question ID: 367388fdc486484202e4bb550420bdcda31a8fdf_7
Original Code:
```
static int wm8983_set_bias_level(struct snd_soc_codec *codec,
				 enum snd_soc_bias_level level)
{
	int ret;

	switch (level) {
	case SND_SOC_BIAS_ON:
	case SND_SOC_BIAS_PREPARE:
		/* VMID at 100k */
		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
				    WM8983_VMIDSEL_MASK,
				    1 << WM8983_VMIDSEL_SHIFT);
		break;
	case SND_SOC_BIAS_STANDBY:
		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
			ret = snd_soc_cache_sync(codec);
			if (ret < 0) {
				dev_err(codec->dev, "Failed to sync cache: %d\n", ret);
				return ret;
			}
			/* enable anti-pop features */
			snd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,
					    WM8983_POBCTRL_MASK | WM8983_DELEN_MASK,
					    WM8983_POBCTRL | WM8983_DELEN);
			/* enable thermal shutdown */
			snd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,
					    WM8983_TSDEN_MASK, WM8983_TSDEN);
			/* enable BIASEN */
			snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
					    WM8983_BIASEN_MASK, WM8983_BIASEN);
			/* VMID at 100k */
			snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
					    WM8983_VMIDSEL_MASK,
					    1 << WM8983_VMIDSEL_SHIFT);
			msleep(250);
			/* disable anti-pop features */
			snd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,
					    WM8983_POBCTRL_MASK |
					    WM8983_DELEN_MASK, 0);
		}

		/* VMID at 500k */
		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
				    WM8983_VMIDSEL_MASK,
				    2 << WM8983_VMIDSEL_SHIFT);
		break;
	case SND_SOC_BIAS_OFF:
		/* disable thermal shutdown */
		snd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,
				    WM8983_TSDEN_MASK, 0);
		/* disable VMIDSEL and BIASEN */
		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
				    WM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,
				    0);
		/* wait for VMID to discharge */
		msleep(100);
		snd_soc_write(codec, WM8983_POWER_MANAGEMENT_1, 0);
		snd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, 0);
		snd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, 0);
		break;
	}

	codec->dapm.bias_level = level;
	return 0;
}
```


Overlapping Code:
```
_set_bias_level(struct snd_soc_codec *codec,
enum snd_soc_bias_level level)
{
int ret;
switch (level) {
case SND_SOC_BIAS_ON:
case SND_SOC_BIAS_PREPARE:
/* VMID at 100k */
snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
WM8983_VMIDSEL_MASK,
1 << WM8983_VMIDSEL_SHIFT);
break;
case SND_SOC_BIAS_STANDBY:
if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
ret = snd_soc_cache_sync(codec);
if (ret < 0) {
dev_err(codec->dev, "Failed to sync cache: %d\n", ret);
return ret;
}
/* enable anti-pop features */
snd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,
WM8983_POBCTRL_MASK | WM8983_DELEN_MASK,
WM8983_POBCTRL | WM8983_DELEN);
/* enable thermal shutdown */
snd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,
WM8983_TSDEN_MASK, WM8983_TSDEN);
/* enable BIASEN */
snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
WM8983_BIASEN_MASK, WM8983_BIASEN);
/* VMID at 100k */
snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
WM8983_VMIDSEL_MASK,
1 << WM8983_VMIDSEL_SHIFT);
msleep(250);
/* disable anti-pop features */
snd_soc_update_bits(codec, WM8983_OUT4_TO_ADC,
WM8983_POBCTRL_MASK |
WM8983_DELEN_MASK, 0);
}
/* VMID at 500k */
snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
WM8983_VMIDSEL_MASK,
2 << WM8983_VMIDSEL_SHIFT);
break;
case SND_SOC_BIAS_OFF:
/* disable thermal shutdown */
snd_soc_update_bits(codec, WM8983_OUTPUT_CTRL,
WM8983_TSDEN_MASK, 0);
/* disable VMIDSEL and BIASEN */
snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,
WM8983_VMIDSEL_MASK | WM8983_BIASEN_MASK,
0);
/* wait for VMID to discharge */
msleep(100);
snd_soc_write(codec, WM8983_POWER_MANAGEMENT_1, 0);
snd_soc_write(codec, WM8983_POWER_MANAGEMENT_2, 0);
snd_soc_write(codec, WM8983_POWER_MANAGEMENT_3, 0);
break;
}
codec->dapm.bias_level = level;
return 0;
}
```
<Overlap Ratio: 0.9903791737408036>

---

--- 146 --
Question ID: e40b8fb60a8a6f5b3da8439e855e8cb7e356ca59_55
Original Code:
```
static inline void hri_pio_set_ABCDSR_P7_bit(const void *const hw, uint8_t index)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= PIO_ABCDSR_P7;
	PIO_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
id hri_pio_set_ABCDSR_P7_bit(const void *const hw, uint8_t index)
{
PIO_CRITICAL_SECTION_ENTER();
((Pio *)hw)->PIO_ABCDSR[index] |= PIO_ABCDSR_P7;
PIO
```
<Overlap Ratio: 0.7731958762886598>

---

--- 147 --
Question ID: 9b42c8b80a5859ea887602c240a9824e10e40697_2
Original Code:
```
static inline unsigned int
num_online_cpus(void)
{
    long nprocs;

    nprocs = sysconf(_SC_NPROCESSORS_ONLN);

    assert(nprocs > 0);

    return nprocs < 1 ? 1 : nprocs;
}
```


Overlapping Code:
```
signed int
num_online_cpus(void)
{
long nprocs;
nprocs = sysconf(_SC_NPROCESSORS_ONLN);
assert(nprocs > 0);
return nprocs < 1 ? 1 : 
```
<Overlap Ratio: 0.8407643312101911>

---

--- 148 --
Question ID: 48520eb771941244e16c71f5213c3ae70318abb7_65
Original Code:
```
static int LZ4F_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize)
{
    (void)dictStart; (void)dictSize;
    return LZ4_decompress_safe (source, dest, compressedSize, maxDecompressedSize);
}
```


Overlapping Code:
```
 LZ4F_decompress_safe (const char* source, char* dest, int compressedSize, int maxDecompressedSize, const char* dictStart, int dictSize)
{
(void)dictStart; (void)dictSize;
return LZ4_decompress_safe (source, dest, compressedSize, maxDecompressedSize)
```
<Overlap Ratio: 0.9505703422053232>

---

--- 149 --
Question ID: 1795741c4ba3d01d8a06ad719710ed61dc48da9c_14
Original Code:
```
OP(_051) { int tmp; H6280_CYCLES(7); RD_IDY; EOR;		   }
```


Overlapping Code:
```
OP(_051) { int tmp; H6280_CYCLES(7); RD_IDY; EOR; 
```
<Overlap Ratio: 0.9803921568627451>

---

--- 150 --
Question ID: c10f9f0a30fe4b851d0f0a061a6aa4d2b264b78f_12
Original Code:
```
int
computeFieldOffsets(fields, class)
  fieldList	*fields;
  int		 class;
{
	int	 offset;
	int	 bitOffset;
	field	*aField;

	if (class > 1)
		offset = objectBase;
	else
		offset = 0;
	if (fields == NULL)
		return(offset);

	bitOffset = 0;
	while (fields != NULL) {
		aField = fields->field;
		aField->offset = offset + (bitOffset << 14);

		if (class == -1)
			objectBase = offset;

		switch (aField->type) {
		Case FIELD_ENTITY:
			offset += 6 * aField->dimension;

		Case FIELD_AVAID:
		case FIELD_BIN31:
		case FIELD_OBJID:
		case FIELD_REGID:
		case FIELD_FATWORD:
			offset += 4 * aField->dimension;

		Case FIELD_BIN15:
		case FIELD_WORDS:
			offset += 2 * aField->dimension;

		Case FIELD_BYTE:
		case FIELD_CHARACTER:
			offset += aField->dimension;

		Case FIELD_VARSTRING:
			offset += aField->dimension + 2;

		Case FIELD_BIT:
			bitOffset += aField->dimension;
			if (bitOffset > 15) {
				offset += 2 * (bitOffset >> 4);
				bitOffset -= (bitOffset & ~0xF);
			}
		}

		if (aField->type != FIELD_BIT && bitOffset > 0) {
			bitOffset = 0;
			offset += 2;
		} else if (aField->type != FIELD_CHARACTER &&
			   aField->type != FIELD_BYTE && (offset & 1) == 1)
			++offset;

		fields = fields->nextField;
	}
	if (bitOffset > 0)
		offset += 2;
	return(offset);
}
```


Overlapping Code:
```
 class)
fieldList *fields;
int class;
{
int offset;
int bitOffset;
field *aField;
if (class > 1)
offset = objectBase;
else
offset = 0;
if (fields == NULL)
return(offset);
bitOffset = 0;
while (fields != NULL) {
aField = fields->field;
aField->offset = offset + (bitOffset << 14);
if (class == -1)
objectBase = offset;
switch (aField->type) {
Case FIELD_ENTITY:
offset += 6 * aField->dimension;
Case FIELD_AVAID:
case FIELD_BIN31:
case FIELD_OBJID:
case FIELD_REGID:
case FIELD_FATWORD:
offset += 4 * aField->dimension;
Case FIELD_BIN15:
case FIELD_WORDS:
offset += 2 * aField->dimension;
Case FIELD_BYTE:
case FIELD_CHARACTER:
offset += aField->dimension;
Case FIELD_VARSTRING:
offset += aField->dimension + 2;
Case FIELD_BIT:
bitOffset += aField->dimension;
if (bitOffset > 15) {
offset += 2 * (bitOffset >> 4);
bitOffset -= (bitOffset & ~0xF);
}
}
if (aField->type != FIELD_BIT && bitOffset > 0) {
bitOffset = 0;
offset += 2;
} else if (aField->type != FIELD_CHARACTER &&
aField->type != FIELD_BYTE && (offset & 1) == 1)
++offset;
fields = fields->nextField;
}
if (bitOffset > 0)
offset += 2;
retur
```
<Overlap Ratio: 0.9623797025371829>

---

--- 151 --
Question ID: 883d73f52ef85083062edeb0cc500e67fdc19ea1_8
Original Code:
```
static void example_coap_server_thread(void *para){
  while(wifi_is_ready_to_transceive(RTW_STA_INTERFACE) != RTW_SUCCESS){
    printf("Wait for WIFI connection ...\n");
    vTaskDelay(1000);
  }
  printf("\nCoAP Server Example starts...\n");
  
  coap_context_t *ctx;
  struct timeval tv, *timeout;
  coap_tick_t now,obs_start,obs_wait;
  coap_queue_t *nextpdu;
  coap_log_t log_level = LOG_WARNING;
  
  coap_set_log_level(log_level);
  
  clock_offset = xTaskGetTickCount();
    
  ctx = get_context(SERVER_HOST, SERVER_PORT);
  if (!ctx)
  {
    printf("\n [COAP_SERVER]get_context failed \n");
    goto exit;
  }
  
  init_resources(ctx);
  
  coap_ticks(&obs_start);
  while (!quit)
  {    
    nextpdu = coap_peek_next(ctx);
    
    coap_ticks(&now);
    while (nextpdu && nextpdu->t <= now - ctx->sendqueue_basetime)
    {
      coap_retransmit(ctx, coap_pop_next(ctx));
      nextpdu = coap_peek_next(ctx);
    }

    if (nextpdu && nextpdu->t <= COAP_RESOURCE_CHECK_TIME)
    {
      /* set timeout if there is a pdu to send before our automatic timeout occurs */
      tv.tv_usec = ((nextpdu->t) % COAP_TICKS_PER_SECOND) * 1000000 / COAP_TICKS_PER_SECOND;
      tv.tv_sec = (nextpdu->t) / COAP_TICKS_PER_SECOND;
      timeout = &tv;
    }
    else
    {
      tv.tv_usec = 0;
      tv.tv_sec = COAP_RESOURCE_CHECK_TIME;
      timeout = &tv;
    }
    
    coap_dispatch(ctx, (const char*)&response); /* and dispatch PDUs from receivequeue */

    coap_ticks(&obs_wait);
    if((obs_wait-obs_start)/COAP_TICKS_PER_SECOND > (timeout->tv_sec + timeout->tv_usec/10000)){
        coap_ticks(&obs_start);
        if (time_resource)
        {
            time_resource->dirty = 1;
        }
    }
#ifndef WITHOUT_ASYNC
    /* check if we have to send asynchronous responses */
    check_async(ctx, now);
#endif /* WITHOUT_ASYNC */
    
#ifndef WITHOUT_OBSERVE
    /* check if we have to send observe notifications */
    coap_check_notify(ctx);
#endif /* WITHOUT_OBSERVE */
  }
  
exit:
  coap_free_context(ctx); 
  printf("\nCoAP Server Example end.\n");
  
  vTaskDelete(NULL);
}
```


Overlapping Code:
```
coap_server_thread(void *para){
while(wifi_is_ready_to_transceive(RTW_STA_INTERFACE) != RTW_SUCCESS){
printf("Wait for WIFI connection ...\n");
vTaskDelay(1000);
}
printf("\nCoAP Server Example starts...\n");

coap_context_t *ctx;
struct timeval tv, *timeout;
coap_tick_t now,obs_start,obs_wait;
coap_queue_t *nextpdu;
coap_log_t log_level = LOG_WARNING;

coap_set_log_level(log_level);

clock_offset = xTaskGetTickCount();

ctx = get_context(SERVER_HOST, SERVER_PORT);
if (!ctx)
{
printf("\n [COAP_SERVER]get_context failed \n");
goto exit;
}

init_resources(ctx);

coap_ticks(&obs_start);
while (!quit)
{ 
nextpdu = coap_peek_next(ctx);

coap_ticks(&now);
while (nextpdu && nextpdu->t <= now - ctx->sendqueue_basetime)
{
coap_retransmit(ctx, coap_pop_next(ctx));
nextpdu = coap_peek_next(ctx);
}
if (nextpdu && nextpdu->t <= COAP_RESOURCE_CHECK_TIME)
{
/* set timeout if there is a pdu to send before our automatic timeout occurs */
tv.tv_usec = ((nextpdu->t) % COAP_TICKS_PER_SECOND) * 1000000 / COAP_TICKS_PER_SECOND;
tv.tv_sec = (nextpdu->t) / COAP_TICKS_PER_SECOND;
timeout = &tv;
}
else
{
tv.tv_usec = 0;
tv.tv_sec = COAP_RESOURCE_CHECK_TIME;
timeout = &tv;
}

coap_dispatch(ctx, (const char*)&response); /* and dispatch PDUs from receivequeue */
coap_ticks(&obs_wait);
if((obs_wait-obs_start)/COAP_TICKS_PER_SECOND > (timeout->tv_sec + timeout->tv_usec/10000)){
coap_ticks(&obs_start);
if (time_resource)
{
time_resource->dirty = 1;
}
}
#ifndef WITHOUT_ASYNC
/* check if we have to send asynchronous responses */
check_async(ctx, now);
#endif /* WITHOUT_ASYNC */

#ifndef WITHOUT_OBSERVE
/* check if we have to send observe notifications */
coap_check_notify(ctx);
#endif /* WITHOUT_OBSERVE */
}

exit:
coap_free_context(ctx); 
printf("\nCoAP
```
<Overlap Ratio: 0.9631260319207485>

---

--- 152 --
Question ID: 409d18bedbba6fa78a52855b88fc3ee9b10a020a_1
Original Code:
```
void dt_reg_init(struct dt_reg *reg, u32 nr_address_cells, u32 nr_size_cells)
{
	memset(reg, 0, sizeof(struct dt_reg));
	reg->nr_address_cells = nr_address_cells;
	reg->nr_size_cells = nr_size_cells;
}
```


Overlapping Code:
```
init(struct dt_reg *reg, u32 nr_address_cells, u32 nr_size_cells)
{
memset(reg, 0, sizeof(struct dt_reg));
reg->nr_address_cells = nr_address_cells;
r
```
<Overlap Ratio: 0.7575757575757576>

---

--- 153 --
Question ID: 364ea6b22d9833381c621707e1c6392557ef36e8_16
Original Code:
```
int wdata_read_cycle(wdata_metadata *md, const char *varname, int cycle, void *data)
{
    int ierr;
    wdata_variable var;
    ierr = wdata_get_variable(md, varname, &var);
    if (ierr > 0)
        return 10 + ierr;

    return wdata_load_datablock(md, &var, cycle, data);
}
```


Overlapping Code:
```
ata_metadata *md, const char *varname, int cycle, void *data)
{
int ierr;
wdata_variable var;
ierr = wdata_get_variable(md, varname, &var);
if (ierr > 0)
return 10 + ierr;
return wdata_load_datablock(
```
<Overlap Ratio: 0.8064516129032258>

---

--- 154 --
Question ID: 995b31ece6b8604fe93242f2402fdfb0ae91cdf0_17
Original Code:
```
WRITE_HANDLER( m72_port02_w )
{
	if (offset != 0)
	{
		if (data) log_cb(RETRO_LOG_DEBUG, LOGPRE "write %02x to port 03\n",data);
		return;
	}
	if (data & 0xe0) log_cb(RETRO_LOG_DEBUG, LOGPRE "write %02x to port 02\n",data);

	/* bits 0/1 are coin counters */
	coin_counter_w(0,data & 0x01);
	coin_counter_w(1,data & 0x02);

	/* bit 2 is flip screen (handled both by software and hardware) */
	flip_screen_set(((data & 0x04) >> 2) ^ (~readinputport(5) & 1));

	/* bit 3 is display disable */
	video_off = data & 0x08;

	/* bit 4 resets sound CPU (active low) */
	if (data & 0x10)
		cpu_set_reset_line(1,CLEAR_LINE);
	else
		cpu_set_reset_line(1,ASSERT_LINE);

	/* bit 5 = "bank"? */
}
```


Overlapping Code:
```
2_port02_w )
{
if (offset != 0)
{
if (data) log_cb(RETRO_LOG_DEBUG, LOGPRE "write %02x to port 03\n",data);
return;
}
if (data & 0xe0) log_cb(RETRO_LOG_DEBUG, LOGPRE "write %02x to port 02\n",data);
/* bits 0/1 are coin counters */
coin_counter_w(0,data & 0x01);
coin_counter_w(1,data & 0x02);
/* bit 2 is flip screen (handled both by software and hardware) */
flip_screen_set(((data & 0x04) >> 2) ^ (~readinputport(5) & 1));
/* bit 3 is display disable */
video_off = data & 0x08;
/* bit 4 resets sound CPU (active low) */
if (data & 0x10)
cpu_set_reset_line(1,CLEAR_LINE);
else
cpu_set_reset_line(1,ASSERT_LINE);

```
<Overlap Ratio: 0.9389312977099237>

---

--- 155 --
Question ID: 7cc5793872a3905c6c2fc71677c3f716c45eab99_9
Original Code:
```
static int usbdk_get_device_descriptor(struct libusb_device *dev, unsigned char *buffer, int *host_endian)
{
	struct usbdk_device_priv *priv = _usbdk_device_priv(dev);

	memcpy(buffer, &priv->info.DeviceDescriptor, DEVICE_DESC_LENGTH);
	*host_endian = 0;

	return LIBUSB_SUCCESS;
}
```


Overlapping Code:
```
bdk_get_device_descriptor(struct libusb_device *dev, unsigned char *buffer, int *host_endian)
{
struct usbdk_device_priv *priv = _usbdk_device_priv(dev);
memcpy(buffer, &priv->info.DeviceDescriptor, DEVICE_DESC_LENGTH);
*host_endian = 0;
return LIBUSB_
```
<Overlap Ratio: 0.9163636363636364>

---

--- 156 --
Question ID: a93ad6d1e7d052818bad970e6163171cf95f43d0_13
Original Code:
```
int
btc_hdpriv_import(btc_hdnode_t *node,
                  const uint8_t *data,
                  const btc_network_t *network) {
  uint32_t prefix = btc_read32be(data + 0);
  int type = find_prefix(network->key.xprvkey, prefix);

  if (type < 0)
    return 0;

  node->type = (enum btc_bip32_type)type;
  node->depth = data[4];
  node->parent = btc_read32be(data + 5);
  node->index = btc_read32be(data + 9);

  memcpy(node->chain, data + 13, 32);

  if (data[45] != 0)
    return 0;

  memcpy(node->seckey, data + 46, 32);

  if (btc_read32le(data + 78) != btc_checksum(data, 78))
    return 0;

  if (!btc_ecdsa_pubkey_create(node->pubkey, node->seckey, 1))
    return 0;

  return 1;
}
```


Overlapping Code:
```
nt
btc_hdpriv_import(btc_hdnode_t *node,
const uint8_t *data,
const btc_network_t *network) {
uint32_t prefix = btc_read32be(data + 0);
int type = find_prefix(network->key.xprvkey, prefix);
if (type < 0)
return 0;
node->type = (enum btc_bip32_type)type;
node->depth = data[4];
node->parent = btc_read32be(data + 5);
node->index = btc_read32be(data + 9);
memcpy(node->chain, data + 13, 32);
if (data[45] != 0)
return 0;
memcpy(node->seckey, data + 46, 32);
if (btc_read32le(data + 78) != btc_checksum(data, 78))
return 0;
if (!btc_ecdsa_pubkey_create(node->pu
```
<Overlap Ratio: 0.9238410596026491>

---

--- 157 --
Question ID: 187f654c4a0e5de9becf9d1f938e6468320e87a3_25
Original Code:
```
int processx_c_pollable_from_connection(
  processx_pollable_t *pollable,
  processx_connection_t *ccon) {

  pollable->pre_poll_func = processx_i_pre_poll_func_connection;
  pollable->object = ccon;
  pollable->free = 0;
  pollable->fds = R_NilValue;
  return 0;
}
```


Overlapping Code:
```
ocessx_c_pollable_from_connection(
processx_pollable_t *pollable,
processx_connection_t *ccon) {
pollable->pre_poll_func = processx_i_pre_poll_func_connection;
pollable->object = ccon;
pollable->free = 0;
pollable->fds =
```
<Overlap Ratio: 0.88>

---

--- 158 --
Question ID: a9704c3da1922d8b2f2f4c68258a2a027b0b3c2f_0
Original Code:
```
static void PrintSymbolForAddress(DWORD64 addr) {
  /*
   * Code adapted from Chromium's stack_trace_win.cc, in turn adapted
   * from an MSDN example:
   * http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx
   */
  ULONG64 buffer[(sizeof(SYMBOL_INFO) +
                  MAX_SYMBOL_NAME_LENGTH * sizeof(wchar_t) +
                  sizeof(ULONG64) - 1) /
                 sizeof(ULONG64)];
  DWORD64 sym_displacement = 0;
  PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;
  BOOL has_symbol;
  memset(buffer, 0, sizeof(buffer));

  SymInitialize(GetCurrentProcess(), NULL, TRUE);

  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);
  symbol->MaxNameLen = MAX_SYMBOL_NAME_LENGTH - 1;
  has_symbol = SymFromAddr(GetCurrentProcess(),
                           addr, &sym_displacement, symbol);
  if (has_symbol) {
    fprintf(stderr, "%s + 0x%x\n", symbol->Name, sym_displacement);
  } else {
    fprintf(stderr, "<no symbol>\n");
  }
}
```


Overlapping Code:
```
ess(DWORD64 addr) {
/*
* Code adapted from Chromium's stack_trace_win.cc, in turn adapted
* from an MSDN example:
* http://msdn.microsoft.com/en-us/library/ms680578(VS.85).aspx
*/
ULONG64 buffer[(sizeof(SYMBOL_INFO) +
MAX_SYMBOL_NAME_LENGTH * sizeof(wchar_t) +
sizeof(ULONG64) - 1) /
sizeof(ULONG64)];
DWORD64 sym_displacement = 0;
PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;
BOOL has_symbol;
memset(buffer, 0, sizeof(buffer));
SymInitialize(GetCurrentProcess(), NULL, TRUE);
symbol->SizeOfStruct = sizeof(SYMBOL_INFO);
symbol->MaxNameLen = MAX_SYMBOL_NAME_LENGTH - 1;
has_symbol = SymFromAddr(GetCurrentProcess(),
addr, &sym_displacement, symbol);
if (has_symbol) {
fprintf(stderr, "%s + 0x%x\n", symbol->Name, sym_displacement);
} else {
fprintf(s
```
<Overlap Ratio: 0.9282178217821783>

---

--- 159 --
Question ID: 288e1e0afdae3d99c95df37a36059f596509f395_9
Original Code:
```
static inline SchedInfo*
adamant_IVE_read(AdamantRuntime *runtime, guint reg, guint distance)
{
  /* The basic idea here is to follow the dependence chain for reg
     back runtime->config->opti.unroll_factor many links.  That node
     will act as our input dependence rather than the tail of the
     dependence chain (since all intervening nodes could be folded). */
  AdamantIVENode *node;
  guint i;

  if(reg > runtime->opti->induction_vars->len)
    adamant_IVE_reset(runtime, reg, 0, 0, 0);

  g_assert(reg < runtime->opti->induction_vars->len);

  node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);
  if(node == NULL) {
    adamant_IVE_reset(runtime, reg, 0, 0, 0);
    node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);
    g_assert(node != NULL);
  }

  for(i = 1; node->parent != NULL && i < distance; i++, node = node->parent);
  return &node->sched_info;
}
```


Overlapping Code:
```
(AdamantRuntime *runtime, guint reg, guint distance)
{
/* The basic idea here is to follow the dependence chain for reg
back runtime->config->opti.unroll_factor many links. That node
will act as our input dependence rather than the tail of the
dependence chain (since all intervening nodes could be folded). */
AdamantIVENode *node;
guint i;
if(reg > runtime->opti->induction_vars->len)
adamant_IVE_reset(runtime, reg, 0, 0, 0);
g_assert(reg < runtime->opti->induction_vars->len);
node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);
if(node == NULL) {
adamant_IVE_reset(runtime, reg, 0, 0, 0);
node = g_array_index(runtime->opti->induction_vars, AdamantIVENode*, reg);
g_assert(node != NULL);
}
for(i = 1; node->parent != NULL && i < distance; i++, node = node->parent);
return
```
<Overlap Ratio: 0.9280742459396751>

---

--- 160 --
Question ID: 58ae6bd675ec8fe3e4fcf4fbdb1f789e036ea1fe_36
Original Code:
```
int proposalPool_proposal_add(RLO_proposal_state* pools, RLO_proposal_state* pp_in) {//add new, or merge value
    if(!pools || !pp_in)
        return -1;

    int i = 0;
    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {//exists, merge
        if(pools[i].pid == pp_in->pid) {
            printf("Function %s:%u - find proposal, pid = %d , index = %d\n", __func__, __LINE__, pp_in->pid, i);
            pools[i] = *pp_in;
            printf("Function %s:%u - confirm in array, pid = %d , index = %d\n", __func__, __LINE__, pools[i].pid, i);
            return i;
        }
    }

    // id not found, add new one.
    for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {
        if(pools[i].pid == -1) {//first available
            pools[i]= *pp_in;
//            printf("Function %s:%u - pp added, confirm in array, pid = %d , index = %d\n", __func__, __LINE__, pools[i].pid, i);
            return i;
        }
    }

    if(i == PROPOSAL_POOL_SIZE - 1) //no empty pool for use.
        return -1;

    return -2;
}
```


Overlapping Code:
```
osal_add(RLO_proposal_state* pools, RLO_proposal_state* pp_in) {//add new, or merge value
if(!pools || !pp_in)
return -1;
int i = 0;
for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {//exists, merge
if(pools[i].pid == pp_in->pid) {
printf("Function %s:%u - find proposal, pid = %d , index = %d\n", __func__, __LINE__, pp_in->pid, i);
pools[i] = *pp_in;
printf("Function %s:%u - confirm in array, pid = %d , index = %d\n", __func__, __LINE__, pools[i].pid, i);
return i;
}
}
// id not found, add new one.
for(i = 0; i <= PROPOSAL_POOL_SIZE - 1; i++) {
if(pools[i].pid == -1) {//first available
pools[i]= *pp_in;
// printf("Function %s:%u - pp added, confirm in array, pid = %d , index = %d\n", __func__, __LINE__, pools[i].pid, i);
return i;
}
}
if(i == PROPOSAL_POOL_SIZE - 1) //no empty pool for use.
retur
```
<Overlap Ratio: 0.9536817102137767>

---

--- 161 --
Question ID: b8b6daf5a507656f03fb9c81ae80390d8cab8b5c_3
Original Code:
```
static inline char *strnWtoU( const WCHAR *str, DWORD in_len, DWORD *out_len )
{
    char *ret = NULL;
    *out_len = 0;
    if (str)
    {
        DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );
        if ((ret = malloc( len + 1 )))
        {
            WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );
            ret[len] = 0;
            *out_len = len;
        }
    }
    return ret;
}
```


Overlapping Code:
```
WORD in_len, DWORD *out_len )
{
char *ret = NULL;
*out_len = 0;
if (str)
{
DWORD len = WideCharToMultiByte( CP_UTF8, 0, str, in_len, NULL, 0, NULL, NULL );
if ((ret = malloc( len + 1 )))
{
WideCharToMultiByte( CP_UTF8, 0, str, in_len, ret, len, NULL, NULL );
ret[len] = 0;
*out_len = len;
}
}
return 
```
<Overlap Ratio: 0.8450704225352113>

---

--- 162 --
Question ID: 499ab030666202302d4272e2ba09a79fa59caa11_11
Original Code:
```
intE find_upper_bound_wing(std::vector<intE> &eIds, std::vector<intE> &tipVal, intE nEdgesRem)
{
    parallel_unstable_sort_kv_increasing(eIds, tipVal);
    intE ub = 0;
    if (nEdgesRem > 10*NUM_THREADS)
    {
        intE BS = (nEdgesRem-1)/NUM_THREADS + 1;
        #pragma omp parallel num_threads(NUM_THREADS) reduction (max:ub)
        {
            unsigned tid = omp_get_thread_num();
            intE start = tid*BS;
            intE end = std::min(nEdgesRem, start+BS);
            for (intE i = end-1; i>=start; i--)
            {
                intE currSupp = tipVal[eIds[i]];
                intE numEdgesWithHigherSupp = nEdgesRem - i;
                if (numEdgesWithHigherSupp >= currSupp)
                {
                    ub = std::max(ub, currSupp);
                    break;
                }
                else
                    ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);
            }
        }
    }
    else
    {
        for (intE i=nEdgesRem-1; i>=0; i--)
        {
            intE currSupp = tipVal[eIds[i]];
            intE numEdgesWithHigherSupp = nEdgesRem - i;
            if (numEdgesWithHigherSupp >= currSupp)
            {
                ub = std::max(ub, currSupp);
                break;
            }
            else
                ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);
        }
    }
    return ub;
}
```


Overlapping Code:
```
ector<intE> &eIds, std::vector<intE> &tipVal, intE nEdgesRem)
{
parallel_unstable_sort_kv_increasing(eIds, tipVal);
intE ub = 0;
if (nEdgesRem > 10*NUM_THREADS)
{
intE BS = (nEdgesRem-1)/NUM_THREADS + 1;
#pragma omp parallel num_threads(NUM_THREADS) reduction (max:ub)
{
unsigned tid = omp_get_thread_num();
intE start = tid*BS;
intE end = std::min(nEdgesRem, start+BS);
for (intE i = end-1; i>=start; i--)
{
intE currSupp = tipVal[eIds[i]];
intE numEdgesWithHigherSupp = nEdgesRem - i;
if (numEdgesWithHigherSupp >= currSupp)
{
ub = std::max(ub, currSupp);
break;
}
else
ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);
}
}
}
else
{
for (intE i=nEdgesRem-1; i>=0; i--)
{
intE currSupp = tipVal[eIds[i]];
intE numEdgesWithHigherSupp = nEdgesRem - i;
if (numEdgesWithHigherSupp >= currSupp)
{
ub = std::max(ub, currSupp);
break;
}
else
ub = std::max(std::min(currSupp, numEdgesWithHigherSupp), ub);
}
}
return ub
```
<Overlap Ratio: 0.9625390218522373>

---

--- 163 --
Question ID: 9aa9c505b90ee129b87eb49761c7dd63813e5d26_16
Original Code:
```
int ili9341_vcom_ctrl_2(const ili9341_t *dev, ili9341_vcom_ctrl_2_t config)
{
    uint8_t data[1] = { 0 };
    data[0] = *(uint8_t*)&config ;
    return _sendCommandData(dev, ILI9341_VCOM_CTR_2, data, sizeof(data));
}
```


Overlapping Code:
```
 ili9341_vcom_ctrl_2(const ili9341_t *dev, ili9341_vcom_ctrl_2_t config)
{
uint8_t data[1] = { 0 };
data[0] = *(uint8_t*)&config ;
return _sendCommandData(dev, ILI9341_V
```
<Overlap Ratio: 0.824390243902439>

---

--- 164 --
Question ID: cc5bdb8c54d62da69e3cebfec86d776382383f91_7
Original Code:
```
char *make_HLSL_swizzle_string(char *swiz_str, const size_t strsize,
                               const int swizzle, const int writemask)
{
    size_t i = 0;
    if ( (!no_swizzle(swizzle)) || (!writemask_xyzw(writemask)) )
    {
        const int writemask0 = (writemask >> 0) & 0x1;
        const int writemask1 = (writemask >> 1) & 0x1;
        const int writemask2 = (writemask >> 2) & 0x1;
        const int writemask3 = (writemask >> 3) & 0x1;

        const int swizzle_x = (swizzle >> 0) & 0x3;
        const int swizzle_y = (swizzle >> 2) & 0x3;
        const int swizzle_z = (swizzle >> 4) & 0x3;
        const int swizzle_w = (swizzle >> 6) & 0x3;

        swiz_str[i++] = '.';
        if (writemask0) swiz_str[i++] = swizzle_channels[swizzle_x];
        if (writemask1) swiz_str[i++] = swizzle_channels[swizzle_y];
        if (writemask2) swiz_str[i++] = swizzle_channels[swizzle_z];
        if (writemask3) swiz_str[i++] = swizzle_channels[swizzle_w];
    } // if
    assert(i < strsize);
    swiz_str[i] = '\0';
    return swiz_str;
}
```


Overlapping Code:
```
swizzle_string(char *swiz_str, const size_t strsize,
const int swizzle, const int writemask)
{
size_t i = 0;
if ( (!no_swizzle(swizzle)) || (!writemask_xyzw(writemask)) )
{
const int writemask0 = (writemask >> 0) & 0x1;
const int writemask1 = (writemask >> 1) & 0x1;
const int writemask2 = (writemask >> 2) & 0x1;
const int writemask3 = (writemask >> 3) & 0x1;
const int swizzle_x = (swizzle >> 0) & 0x3;
const int swizzle_y = (swizzle >> 2) & 0x3;
const int swizzle_z = (swizzle >> 4) & 0x3;
const int swizzle_w = (swizzle >> 6) & 0x3;
swiz_str[i++] = '.';
if (writemask0) swiz_str[i++] = swizzle_channels[swizzle_x];
if (writemask1) swiz_str[i++] = swizzle_channels[swizzle_y];
if (writemask2) swiz_str[i++] = swizzle_channels[swizzle_z];
if (writemask3) swiz_str[i++] = swizzle_channels[swizzle_w];
} // if
assert(i < strsize);
swiz_str[i] = '\0';
return swiz_
```
<Overlap Ratio: 0.9751412429378531>

---

--- 165 --
Question ID: 55659107bcb7be7a60b7d09bd5dd794e25538735_0
Original Code:
```
char* parse_ld_trace_line_path(const char* line) {
    char* path = NULL;
    const char* path_start = strstr(line, "=> ");
    if (path_start != NULL) {
        path_start += 3;
    } else {
        path_start = line;
        while (path_start != NULL && isspace(*path_start))
            path_start++;
    }

    char* path_end = strstr(path_start, " (");

    if (path_end != NULL)
        path = strndup(path_start, path_end - path_start);
    else
        path = strdup(path_start);


    return path;
}
```


Overlapping Code:
```
ine_path(const char* line) {
char* path = NULL;
const char* path_start = strstr(line, "=> ");
if (path_start != NULL) {
path_start += 3;
} else {
path_start = line;
while (path_start != NULL && isspace(*path_start))
path_start++;
}
char* path_end = strstr(path_start, " (");
if (path_end != NULL)
path = strndup(path_start, path_end - path_start);
else
path = strdup(path_start);
return path;
}
```
<Overlap Ratio: 0.9471153846153846>

---

--- 166 --
Question ID: c5cb490c535d78eae6648fb330a59363f2a052ed_4
Original Code:
```
static int64_t  func_28(int32_t  p_29, int64_t  p_30, int8_t  p_31, uint16_t  p_32)
{ 
    int64_t l_256 = 0x6E68338B46DE65A4LL;
    int32_t l_270 = 3L;
    int8_t l_275 = 0L;
    for (g_233 = 0; (g_233 <= 2); g_233 += 1)
    { 
        int32_t l_255 = (-7L);
        int32_t l_269[1];
        int i;
        for (i = 0; i < 1; i++)
            l_269[i] = 0x4A06BE4AL;
        p_29 = (safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(0x6587CEBA9940DB3FLL, ((safe_div_func_int16_t_s_s(0x7F1AL, 65529UL)) >= 0x7BL))), 7)), 0x5A23L));
        l_255 = g_236[g_233];
        if (g_236[0])
            continue;
        l_256 = (-1L);
        g_65 = p_29;
        l_270 = (safe_sub_func_int32_t_s_s((~(0xE7B200155B8B4CAALL <= 4L)), ((((p_30 = (~((safe_div_func_int64_t_s_s(((safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((l_255 = (safe_mul_func_uint8_t_u_u(0x37L, 0x2EL))), 8)), g_119[1])) , l_256), g_141[2])) >= 0x4AD5A420L))) == l_256) & 0x57C4L) || l_269[0])));
    }
    for (g_234 = 2; (g_234 >= 0); g_234 -= 1)
    { 
        uint64_t l_272 = 0UL;
        int32_t l_276 = 1L;
        int32_t l_277 = 0xEFA478FCL;
        ++l_272;
        g_278--;
        l_276 ^= g_231;
        g_63 = (g_66 > (safe_mod_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_u((l_272 ^ (safe_rshift_func_uint16_t_u_s(p_30, 14))), g_77)) , 0x9ED6L), p_30)));
        if (l_276)
            break;
        return l_270;
    }
    return p_32;
}
```


Overlapping Code:
```
4_t func_28(int32_t p_29, int64_t p_30, int8_t p_31, uint16_t p_32)
{ 
int64_t l_256 = 0x6E68338B46DE65A4LL;
int32_t l_270 = 3L;
int8_t l_275 = 0L;
for (g_233 = 0; (g_233 <= 2); g_233 += 1)
{ 
int32_t l_255 = (-7L);
int32_t l_269[1];
int i;
for (i = 0; i < 1; i++)
l_269[i] = 0x4A06BE4AL;
p_29 = (safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(0x6587CEBA9940DB3FLL, ((safe_div_func_int16_t_s_s(0x7F1AL, 65529UL)) >= 0x7BL))), 7)), 0x5A23L));
l_255 = g_236[g_233];
if (g_236[0])
continue;
l_256 = (-1L);
g_65 = p_29;
l_270 = (safe_sub_func_int32_t_s_s((~(0xE7B200155B8B4CAALL <= 4L)), ((((p_30 = (~((safe_div_func_int64_t_s_s(((safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s((l_255 = (safe_mul_func_uint8_t_u_u(0x37L, 0x2EL))), 8)), g_119[1])) , l_256), g_141[2])) >= 0x4AD5A420L))) == l_256) & 0x57C4L) || l_269[0])));
}
for (g_234 = 2; (g_234 >= 0); g_234 -= 1)
{ 
uint64_t l_272 = 0UL;
int32_t l_276 = 1L;
int32_t l_277 = 0xEFA478FCL;
++l_272;
g_278--;
l_276 ^= g_231;
g_63 = (g_66 > (safe_mod_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_u((l_272 ^ (safe_rshift_func_uint16_t_u_s(p_30, 14))), g_77)) , 0x9ED6L), p_30)));
if (l_276)
break;
return l_
```
<Overlap Ratio: 0.974025974025974>

---

--- 167 --
Question ID: 6cdfc653c29733e70d0663aff50997e53e695fb4_28
Original Code:
```
int
ipsec_updatereplay(u_int32_t seq, struct secasvar *sav)
{
	char buf[128];
	struct secreplay *replay;
	u_int32_t diff;
	int fr;
	u_int32_t wsizeb;	/* Constant: bits of window size. */
	int frlast;		/* Constant: last frame. */

	IPSEC_ASSERT(sav != NULL, ("Null SA"));
	IPSEC_ASSERT(sav->replay != NULL, ("Null replay state"));

	replay = sav->replay;

	if (replay->wsize == 0)
		goto ok;	/* No need to check replay. */

	/* Constant. */
	frlast = replay->wsize - 1;
	wsizeb = replay->wsize << 3;

	/* Sequence number of 0 is invalid. */
	if (seq == 0)
		return (1);

	/* First time. */
	if (replay->count == 0) {
		replay->lastseq = seq;
		bzero(replay->bitmap, replay->wsize);
		(replay->bitmap)[frlast] = 1;
		goto ok;
	}

	if (seq > replay->lastseq) {
		/* seq is larger than lastseq. */
		diff = seq - replay->lastseq;

		/* New larger sequence number. */
		if (diff < wsizeb) {
			/* In window. */
			/* Set bit for this packet. */
			vshiftl(replay->bitmap, diff, replay->wsize);
			(replay->bitmap)[frlast] |= 1;
		} else {
			/* This packet has a "way larger". */
			bzero(replay->bitmap, replay->wsize);
			(replay->bitmap)[frlast] = 1;
		}
		replay->lastseq = seq;

		/* Larger is good. */
	} else {
		/* seq is equal or less than lastseq. */
		diff = replay->lastseq - seq;

		/* Over range to check, i.e. too old or wrapped. */
		if (diff >= wsizeb)
			return (1);

		fr = frlast - diff / 8;

		/* This packet already seen? */
		if ((replay->bitmap)[fr] & (1 << (diff % 8)))
			return (1);

		/* Mark as seen. */
		(replay->bitmap)[fr] |= (1 << (diff % 8));

		/* Out of order but good. */
	}

ok:
	if (replay->count == ~0) {

		/* Set overflow flag. */
		replay->overflow++;

		/* Don't increment, no more packets accepted. */
		if ((sav->flags & SADB_X_EXT_CYCSEQ) == 0)
			return (1);

		ipseclog((LOG_WARNING, "%s: replay counter made %d cycle. %s\n",
		    __func__, replay->overflow,
		    ipsec_logsastr(sav, buf, sizeof(buf))));
	}

	replay->count++;

	return (0);
}
```


Overlapping Code:
```
int
ipsec_updatereplay(u_int32_t seq, struct secasvar *sav)
{
char buf[128];
struct secreplay *replay;
u_int32_t diff;
int fr;
u_int32_t wsizeb; /* Constant: bits of window size. */
int frlast; /* Constant: last frame. */
IPSEC_ASSERT(sav != NULL, ("Null SA"));
IPSEC_ASSERT(sav->replay != NULL, ("Null replay state"));
replay = sav->replay;
if (replay->wsize == 0)
goto ok; /* No need to check replay. */
/* Constant. */
frlast = replay->wsize - 1;
wsizeb = replay->wsize << 3;
/* Sequence number of 0 is invalid. */
if (seq == 0)
return (1);
/* First time. */
if (replay->count == 0) {
replay->lastseq = seq;
bzero(replay->bitmap, replay->wsize);
(replay->bitmap)[frlast] = 1;
goto ok;
}
if (seq > replay->lastseq) {
/* seq is larger than lastseq. */
diff = seq - replay->lastseq;
/* New larger sequence number. */
if (diff < wsizeb) {
/* In window. */
/* Set bit for this packet. */
vshiftl(replay->bitmap, diff, replay->wsize);
(replay->bitmap)[frlast] |= 1;
} else {
/* This packet has a "way larger". */
bzero(replay->bitmap, replay->wsize);
(replay->bitmap)[frlast] = 1;
}
replay->lastseq = seq;
/* Larger is good. */
} else {
/* seq is equal or less than lastseq. */
diff = replay->lastseq - seq;
/* Over range to check, i.e. too old or wrapped. */
if (diff >= wsizeb)
return (1);
fr = frlast - diff / 8;
/* This packet already seen? */
if ((replay->bitmap)[fr] & (1 << (diff % 8)))
return (1);
/* Mark as seen. */
(replay->bitmap)[fr] |= (1 << (diff % 8));
/* Out of order but good. */
}
ok:
if (replay->count == ~0) {
/* Set overflow flag. */
replay->overflow++;
/* Don't increment, no more packets accepted. */
if ((sav->flags & SADB_X_EXT_CYCSEQ) == 0)
return (1);
ipseclog((LOG_WARNING, "%s: replay counter made %d cycle. %s\n",
__func__, replay->overflow,
ipsec_logsastr(sav, buf, sizeo
```
<Overlap Ratio: 0.9766684753119913>

---

--- 168 --
Question ID: 30fe68b20d3f326bf07ad6496707ba7f7392a899_0
Original Code:
```
TICK_COUNTER_HANDLE tickcounter_create(void)
{
    TICK_COUNTER_INSTANCE* result = (TICK_COUNTER_INSTANCE*)malloc(sizeof(TICK_COUNTER_INSTANCE));
    if (result != NULL)
    {
        if (!QueryPerformanceFrequency(&result->perf_freqency))
        {
            result->backup_time_value = time(NULL);
            if (result->backup_time_value == INVALID_TIME_VALUE)
            {
                LogError("tickcounter failed: time return INVALID_TIME.");
                free(result);
                result = NULL;
            }
            else
            {
                result->current_ms = 0;
            }
        }
        else
        {
            if (!QueryPerformanceCounter(&result->last_perf_counter))
            {
                LogError("tickcounter failed: QueryPerformanceCounter failed %d.", GetLastError());
                free(result);
                result = NULL;
            }
            else
            {
                result->backup_time_value = INVALID_TIME_VALUE;
                result->current_ms = 0;
            }
        }
    }
    return result;
}
```


Overlapping Code:
```
NTER_HANDLE tickcounter_create(void)
{
TICK_COUNTER_INSTANCE* result = (TICK_COUNTER_INSTANCE*)malloc(sizeof(TICK_COUNTER_INSTANCE));
if (result != NULL)
{
if (!QueryPerformanceFrequency(&result->perf_freqency))
{
result->backup_time_value = time(NULL);
if (result->backup_time_value == INVALID_TIME_VALUE)
{
LogError("tickcounter failed: time return INVALID_TIME.");
free(result);
result = NULL;
}
else
{
result->current_ms = 0;
}
}
else
{
if (!QueryPerformanceCounter(&result->last_perf_counter))
{
LogError("tickcounter failed: QueryPerformanceCounter failed %d.", GetLastError());
free(result);
result = NULL;
}
else
{
result->backup_time_value = INVALID_TIME_VALUE;
result->current_ms = 0;
}
}
}
return res
```
<Overlap Ratio: 0.9806896551724138>

---

--- 169 --
Question ID: 2c010c0702f1f256c9a66733b7c3a76da9917230_31
Original Code:
```
UINT  _nx_smtp_rsp_rset(NX_SMTP_CLIENT *client_ptr)
{

UINT  status;


    /* Get server response to RSET command.  */
    status =  _nx_smtp_utility_read_server_code(client_ptr, NX_SMTP_ENVELOPE_TIMEOUT, NX_TRUE);

    /* Check for error.  */
    if (status != NX_SUCCESS)
    {

        /* Return error status.  */
        return(status);
    }

    /* Did the session receive the 250 OK from the server?  */  
    if (client_ptr -> nx_smtp_client_reply_code_status != NX_SMTP_CODE_OK_TO_CONTINUE)
    {

        /* Yes, set the session state to QUIT.  */
        client_ptr -> nx_smtp_client_rsp_state = NX_SMTP_CLIENT_STATE_QUIT;            
        /* Indicate mail cannot be sent. */
        client_ptr -> nx_smtp_client_mail_status = NX_SMTP_SERVER_ERROR_CODE_RECEIVED;
    }
    else
    {

        /* Yes, session accepted the RSET command with the 250 code.  
           Reset session state back to MAIL.  */
        client_ptr -> nx_smtp_client_rsp_state =  NX_SMTP_CLIENT_STATE_MAIL;

    }

    /* Return successful session status.  */
    return NX_SUCCESS;
}
```


Overlapping Code:
```
et(NX_SMTP_CLIENT *client_ptr)
{
UINT status;
/* Get server response to RSET command. */
status = _nx_smtp_utility_read_server_code(client_ptr, NX_SMTP_ENVELOPE_TIMEOUT, NX_TRUE);
/* Check for error. */
if (status != NX_SUCCESS)
{
/* Return error status. */
return(status);
}
/* Did the session receive the 250 OK from the server? */ 
if (client_ptr -> nx_smtp_client_reply_code_status != NX_SMTP_CODE_OK_TO_CONTINUE)
{
/* Yes, set the session state to QUIT. */
client_ptr -> nx_smtp_client_rsp_state = NX_SMTP_CLIENT_STATE_QUIT; 
/* Indicate mail cannot be sent. */
client_ptr -> nx_smtp_client_mail_status = NX_SMTP_SERVER_ERROR_CODE_RECEIVED;
}
else
{
/* Yes, session accepted the RSET command with the 250 code. 
Reset session state back to MAIL. */
client_ptr -> nx_smtp_client_rsp_state = NX_SMTP_CLIENT_STATE_MAIL;
}
/* Return successful session status. */
return NX_SUCCES
```
<Overlap Ratio: 0.9734513274336283>

---

--- 170 --
Question ID: e94a56f5e8ba92c1046832a257da99b7946e9743_7
Original Code:
```
int main(void)
{
    test_reduce_1();

    test_multx_1();
    test_multx_2();
    test_multx_3();

    test_swap_1();

    test_clmul_1();
    test_clmul_2();
    return 0;
}
```


Overlapping Code:
```
x_1();
test_multx_2();
test_multx_3();
test_swap_1
```
<Overlap Ratio: 0.35714285714285715>

---

--- 171 --
Question ID: 9e972d183f2be89cc321b15202f5c14a758601d0_19
Original Code:
```
void TtsIPv6AcceptThread(THREAD *thread, void *param)
{
	TTS *tts = (TTS *)param;
	// Validate arguments
	if (tts == NULL || param == NULL)
	{
		return;
	}

	TtsAcceptProc(tts, tts->ListenSocketV6);
}
```


Overlapping Code:
```
hread(THREAD *thread, void *param)
{
TTS *tts = (TTS *)param;
// Validate arguments
if (tts == NULL || param == NULL)
{
return;
}
TtsAcceptProc(tts, t
```
<Overlap Ratio: 0.7853403141361257>

---

--- 172 --
Question ID: 8683f853c4e1ce2ed06aea4dd74aab3e46a52a68_18
Original Code:
```
void loopFrontEnd(void)
{
  loopVolumeSource();                 //Check if volume source(SD/U disk) insert

  loopToast();

  loopReminderClear();                //If there is a message in the status bar, timed clear

  loopVolumeReminderClear();

  loopBusySignClear();                //Busy Indicator clear

  loopTemperatureStatus();

#ifdef FIL_RUNOUT_PIN
  loopFrontEndFILRunoutDetect();
#endif

  loopPopup();
}
```


Overlapping Code:
```
)
{
loopVolumeSource(); //Check if volume source(SD/U disk) insert
loopToast();
loopReminderClear(); //If there is a message in the status bar, timed clear
loopVolumeReminderClear();
loopBusySignClear(); //Busy Indicator clear
loopTemperatureStatus();
#ifdef FIL_RUNOUT_PIN
loopFrontEndFILRunoutDetec
```
<Overlap Ratio: 0.8620689655172413>

---

--- 173 --
Question ID: 43ff170ff1c242df694b6c5d6ec74ca3aba7b16a_0
Original Code:
```
static int zynqmp_sha_init_tfm(struct crypto_shash *hash)
{
	const char *fallback_driver_name = crypto_shash_alg_name(hash);
	struct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);
	struct shash_alg *alg = crypto_shash_alg(hash);
	struct crypto_shash *fallback_tfm;
	struct zynqmp_sha_drv_ctx *drv_ctx;

	drv_ctx = container_of(alg, struct zynqmp_sha_drv_ctx, sha3_384);
	tfm_ctx->dev = drv_ctx->dev;

	/* Allocate a fallback and abort if it failed. */
	fallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,
					  CRYPTO_ALG_NEED_FALLBACK);
	if (IS_ERR(fallback_tfm))
		return PTR_ERR(fallback_tfm);

	tfm_ctx->fbk_tfm = fallback_tfm;
	hash->descsize += crypto_shash_descsize(tfm_ctx->fbk_tfm);

	return 0;
}
```


Overlapping Code:
```
uct crypto_shash *hash)
{
const char *fallback_driver_name = crypto_shash_alg_name(hash);
struct zynqmp_sha_tfm_ctx *tfm_ctx = crypto_shash_ctx(hash);
struct shash_alg *alg = crypto_shash_alg(hash);
struct crypto_shash *fallback_tfm;
struct zynqmp_sha_drv_ctx *drv_ctx;
drv_ctx = container_of(alg, struct zynqmp_sha_drv_ctx, sha3_384);
tfm_ctx->dev = drv_ctx->dev;
/* Allocate a fallback and abort if it failed. */
fallback_tfm = crypto_alloc_shash(fallback_driver_name, 0,
CRYPTO_ALG_NEED_FALLBACK);
if (IS_ERR(fallback_tfm))
return PTR_ERR(fallback_tfm);
tfm_ctx->fbk_tfm = fallback_tfm;
hash->descsize += crypto_shash_descsize(tfm_ctx->fbk_tfm);
r
```
<Overlap Ratio: 0.9365994236311239>

---

--- 174 --
Question ID: f68f4647184c5005f132d0d82734ee360dd78f17_5
Original Code:
```
static void
nk_eve_scissor(EVE_HalContext *phost, float x, float y, float w, float h)
{
    Ft_Esd_Rect16 rect;
    rect.X = (int)x;
    rect.Y = (int)y;
    rect.Width = (int)(w + 1);
    rect.Height = (int)(h + 1);
    Esd_Dl_Scissor_Adjust(rect, eve.scissor);
}
```


Overlapping Code:
```
atic void
nk_eve_scissor(EVE_HalContext *phost, float x, float y, float w, float h)
{
Ft_Esd_Rect16 rect;
rect.X = (int)x;
rect.Y = (int)y;
rect.Width = (int)(w + 1);
rect.Height = (int)(h + 1);
Esd_D
```
<Overlap Ratio: 0.8333333333333334>

---

--- 175 --
Question ID: 30221701614c599d380229c69b83558537c69de8_11
Original Code:
```
int mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,
	    int (*rules_dump)(struct net *net,
			      struct notifier_block *nb),
	    struct mr_table *(*mr_iter)(struct net *net,
					struct mr_table *mrt),
	    rwlock_t *mrt_lock)
{
	struct mr_table *mrt;
	int err;

	err = rules_dump(net, nb);
	if (err)
		return err;

	for (mrt = mr_iter(net, NULL); mrt; mrt = mr_iter(net, mrt)) {
		struct vif_device *v = &mrt->vif_table[0];
		struct mr_mfc *mfc;
		int vifi;

		/* Notifiy on table VIF entries */
		read_lock(mrt_lock);
		for (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {
			if (!v->dev)
				continue;

			mr_call_vif_notifier(nb, net, family,
					     FIB_EVENT_VIF_ADD,
					     v, vifi, mrt->id);
		}
		read_unlock(mrt_lock);

		/* Notify on table MFC entries */
		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
			mr_call_mfc_notifier(nb, net, family,
					     FIB_EVENT_ENTRY_ADD,
					     mfc, mrt->id);
	}

	return 0;
}
```


Overlapping Code:
```
t net *net, struct notifier_block *nb, unsigned short family,
int (*rules_dump)(struct net *net,
struct notifier_block *nb),
struct mr_table *(*mr_iter)(struct net *net,
struct mr_table *mrt),
rwlock_t *mrt_lock)
{
struct mr_table *mrt;
int err;
err = rules_dump(net, nb);
if (err)
return err;
for (mrt = mr_iter(net, NULL); mrt; mrt = mr_iter(net, mrt)) {
struct vif_device *v = &mrt->vif_table[0];
struct mr_mfc *mfc;
int vifi;
/* Notifiy on table VIF entries */
read_lock(mrt_lock);
for (vifi = 0; vifi < mrt->maxvif; vifi++, v++) {
if (!v->dev)
continue;
mr_call_vif_notifier(nb, net, family,
FIB_EVENT_VIF_ADD,
v, vifi, mrt->id);
}
read_unlock(mrt_lock);
/* Notify on table MFC entries */
list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
mr_call_mfc_notifier(nb, net, family,
FIB_EVENT_E
```
<Overlap Ratio: 0.935672514619883>

---

--- 176 --
Question ID: bdcf0f0ae7f6d8f0f28db91e764eaa6ef976a7aa_14
Original Code:
```
int pa__get_n_used(pa_module *m) {
    struct userdata *u;

    pa_assert(m);
    pa_assert_se(u = m->userdata);

    return pa_sink_linked_by(u->sink);
}
```


Overlapping Code:
```
ed(pa_module *m) {
struct userdata *u;
pa_assert(m);
pa_assert_se(u = m->userdata);
return pa_sink_linked_by(u->sink);
}
```
<Overlap Ratio: 0.8823529411764706>

---

--- 177 --
Question ID: 148268cc6dc829abb05c48b605f1306ccfb6d6a5_26
Original Code:
```
int sam_hdr_remove_line_id(sam_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {
    sam_hrecs_t *hrecs;
    if (!bh || !type)
        return -1;

    if (!(hrecs = bh->hrecs)) {
        if (sam_hdr_fill_hrecs(bh) != 0)
            return -1;
        hrecs = bh->hrecs;
    }

    if (!strncmp(type, "PG", 2)) {
        hts_log_warning("Removing PG lines is not supported!");
        return -1;
    }

    sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
    if (!type_found)
        return 0;

    int ret = sam_hrecs_remove_line(hrecs, type, type_found);
    if (ret == 0) {
        if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
            return -1;

        if (hrecs->dirty)
            redact_header_text(bh);
    }

    return ret;
}
```


Overlapping Code:
```
_hdr_t *bh, const char *type, const char *ID_key, const char *ID_value) {
sam_hrecs_t *hrecs;
if (!bh || !type)
return -1;
if (!(hrecs = bh->hrecs)) {
if (sam_hdr_fill_hrecs(bh) != 0)
return -1;
hrecs = bh->hrecs;
}
if (!strncmp(type, "PG", 2)) {
hts_log_warning("Removing PG lines is not supported!");
return -1;
}
sam_hrec_type_t *type_found = sam_hrecs_find_type_id(hrecs, type, ID_key, ID_value);
if (!type_found)
return 0;
int ret = sam_hrecs_remove_line(hrecs, type, type_found);
if (ret == 0) {
if (hrecs->refs_changed >= 0 && rebuild_target_arrays(bh) != 0)
return -1;
if (hrecs->dirty)
redact_heade
```
<Overlap Ratio: 0.9141566265060241>

---

--- 178 --
Question ID: 9effcf55ef60167a71aefc773ff3946952f6fef0_24
Original Code:
```
static int virtio_ccw_online(struct ccw_device *cdev)
{
	int ret;
	struct virtio_ccw_device *vcdev;

	vcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);
	if (!vcdev) {
		dev_warn(&cdev->dev, "Could not get memory for virtio\n");
		ret = -ENOMEM;
		goto out_free;
	}
	vcdev->config_block = kzalloc(sizeof(*vcdev->config_block),
				   GFP_DMA | GFP_KERNEL);
	if (!vcdev->config_block) {
		ret = -ENOMEM;
		goto out_free;
	}
	vcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);
	if (!vcdev->status) {
		ret = -ENOMEM;
		goto out_free;
	}

	vcdev->vdev.dev.parent = &cdev->dev;
	vcdev->vdev.dev.release = virtio_ccw_release_dev;
	vcdev->vdev.config = &virtio_ccw_config_ops;
	vcdev->cdev = cdev;
	init_waitqueue_head(&vcdev->wait_q);
	INIT_LIST_HEAD(&vcdev->virtqueues);
	spin_lock_init(&vcdev->lock);

	dev_set_drvdata(&cdev->dev, vcdev);
	vcdev->vdev.id.vendor = cdev->id.cu_type;
	vcdev->vdev.id.device = cdev->id.cu_model;
	ret = register_virtio_device(&vcdev->vdev);
	if (ret) {
		dev_warn(&cdev->dev, "Failed to register virtio device: %d\n",
			 ret);
		goto out_put;
	}
	return 0;
out_put:
	dev_set_drvdata(&cdev->dev, NULL);
	put_device(&vcdev->vdev.dev);
	return ret;
out_free:
	if (vcdev) {
		kfree(vcdev->status);
		kfree(vcdev->config_block);
	}
	kfree(vcdev);
	return ret;
}
```


Overlapping Code:
```
tatic int virtio_ccw_online(struct ccw_device *cdev)
{
int ret;
struct virtio_ccw_device *vcdev;
vcdev = kzalloc(sizeof(*vcdev), GFP_KERNEL);
if (!vcdev) {
dev_warn(&cdev->dev, "Could not get memory for virtio\n");
ret = -ENOMEM;
goto out_free;
}
vcdev->config_block = kzalloc(sizeof(*vcdev->config_block),
GFP_DMA | GFP_KERNEL);
if (!vcdev->config_block) {
ret = -ENOMEM;
goto out_free;
}
vcdev->status = kzalloc(sizeof(*vcdev->status), GFP_DMA | GFP_KERNEL);
if (!vcdev->status) {
ret = -ENOMEM;
goto out_free;
}
vcdev->vdev.dev.parent = &cdev->dev;
vcdev->vdev.dev.release = virtio_ccw_release_dev;
vcdev->vdev.config = &virtio_ccw_config_ops;
vcdev->cdev = cdev;
init_waitqueue_head(&vcdev->wait_q);
INIT_LIST_HEAD(&vcdev->virtqueues);
spin_lock_init(&vcdev->lock);
dev_set_drvdata(&cdev->dev, vcdev);
vcdev->vdev.id.vendor = cdev->id.cu_type;
vcdev->vdev.id.device = cdev->id.cu_model;
ret = register_virtio_device(&vcdev->vdev);
if (ret) {
dev_warn(&cdev->dev, "Failed to register virtio device: %d\n",
ret);
goto out_put;
}
return 0;
out_put:
dev_set_drvdata(&cdev->dev, NULL);
put_device(&vcdev->vdev.dev);
return ret;
out_free:
if (vcdev) {
kfree(vcdev->status);
kfree(vcdev->config_block);
}
```
<Overlap Ratio: 0.9764227642276423>

---

--- 179 --
Question ID: 23a140f487dd2a523d5a176370c750be5e8f0458_0
Original Code:
```
S16 RlcLiRguBndCfm(Pst *pst,SuId suId,uint8_t status)
{
   uint16_t      event;     /* Event */
   uint16_t      cause;     /* Cause */
   RlcRguSapCb   *rguSap;   /* RGU SAP Control Block */
   RlcCb         *tRlcCb;

#if (ERRCLASS & ERRCLS_INT_PAR)
   if (pst->dstInst >= MAX_RLC_INSTANCES)
   {
      return  (RFAILED);
   }
#endif
   tRlcCb = RLC_GET_RLCCB(pst->dstInst);

   DU_LOG("\nDEBUG  -->  RLC UL : RlcLiRguBndCfm(suId(%d), status(%d)", suId, status);

#if (ERRCLASS & ERRCLS_INT_PAR)
   if (tRlcCb->init.cfgDone != TRUE)
   {
      DU_LOG("\nERROR  -->  RLC UL : General configuration not done");
      
      RLC_SEND_SAPID_ALARM(tRlcCb,suId,LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_STATE);

      return RFAILED;
   }

   if ((suId >= tRlcCb->genCfg.maxRguSaps) || (suId < 0))
   {
      DU_LOG("\nERROR  -->  RLC UL : Invalid suId");
      
      RLC_SEND_SAPID_ALARM(tRlcCb,suId, LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_SUID);

      return RFAILED;
   }
#endif /* ERRCLASS & ERRCLS_INT_PAR */

   rguSap = (tRlcCb->genCfg.rlcMode == LKW_RLC_MODE_DL) ?
            &(tRlcCb->u.dlCb->rguDlSap[suId]) : &(tRlcCb->u.ulCb->rguUlSap[suId]);

   DU_LOG("\nDEBUG  -->  RLC UL : RlcLiRguBndCfm: For RGU SAP state=%d", rguSap->state);

   switch (rguSap->state)
   {
      case RLC_SAP_BINDING:
      {
         rlcStopTmr (tRlcCb,(PTR)rguSap, EVENT_RLC_WAIT_BNDCFM);

         rguSap->retryCnt = 0;
          
         if (status == CM_BND_OK)
         {
            rguSap->state = RLC_SAP_BND;
            event = LCM_EVENT_BND_OK;
            cause = LKW_CAUSE_SAP_BNDENB;
         }
         else
         {
            rguSap->state = RLC_SAP_CFG;
            event = LCM_EVENT_BND_FAIL;
            cause = LKW_CAUSE_UNKNOWN;
         }

         break;
      }
      default:
         event = LKW_EVENT_RGU_BND_CFM;
         cause = LCM_CAUSE_INV_STATE;
         break;
   }

   /* Send an alarm with proper event and cause */
   RLC_SEND_SAPID_ALARM(tRlcCb, suId, event, cause);

   return (ROK);
}
```


Overlapping Code:
```
dCfm(Pst *pst,SuId suId,uint8_t status)
{
uint16_t event; /* Event */
uint16_t cause; /* Cause */
RlcRguSapCb *rguSap; /* RGU SAP Control Block */
RlcCb *tRlcCb;
#if (ERRCLASS & ERRCLS_INT_PAR)
if (pst->dstInst >= MAX_RLC_INSTANCES)
{
return (RFAILED);
}
#endif
tRlcCb = RLC_GET_RLCCB(pst->dstInst);
DU_LOG("\nDEBUG --> RLC UL : RlcLiRguBndCfm(suId(%d), status(%d)", suId, status);
#if (ERRCLASS & ERRCLS_INT_PAR)
if (tRlcCb->init.cfgDone != TRUE)
{
DU_LOG("\nERROR --> RLC UL : General configuration not done");

RLC_SEND_SAPID_ALARM(tRlcCb,suId,LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_STATE);
return RFAILED;
}
if ((suId >= tRlcCb->genCfg.maxRguSaps) || (suId < 0))
{
DU_LOG("\nERROR --> RLC UL : Invalid suId");

RLC_SEND_SAPID_ALARM(tRlcCb,suId, LKW_EVENT_LI_BND_CFM, LCM_CAUSE_INV_SUID);
return RFAILED;
}
#endif /* ERRCLASS & ERRCLS_INT_PAR */
rguSap = (tRlcCb->genCfg.rlcMode == LKW_RLC_MODE_DL) ?
&(tRlcCb->u.dlCb->rguDlSap[suId]) : &(tRlcCb->u.ulCb->rguUlSap[suId]);
DU_LOG("\nDEBUG --> RLC UL : RlcLiRguBndCfm: For RGU SAP state=%d", rguSap->state);
switch (rguSap->state)
{
case RLC_SAP_BINDING:
{
rlcStopTmr (tRlcCb,(PTR)rguSap, EVENT_RLC_WAIT_BNDCFM);
rguSap->retryCnt = 0;

if (status == CM_BND_OK)
{
rguSap->state = RLC_SAP_BND;
event = LCM_EVENT_BND_OK;
cause = LKW_CAUSE_SAP_BNDENB;
}
else
{
rguSap->state = RLC_SAP_CFG;
event = LCM_EVENT_BND_FAIL;
cause = LKW_CAUSE_UNKNOWN;
}
break;
}
default:
event = LKW_EVENT_RGU_BND_CFM;
cause = LCM_CAUSE_INV_STATE;
break;
}
/* Send an alarm with proper event and cause */
RLC_SEND_SAPID_ALARM(tRlcCb, suId, eve
```
<Overlap Ratio: 0.9744548286604361>

---

--- 180 --
Question ID: 886d9dd91572940bb3c45e0c165a8e814af6e3b3_460
Original Code:
```
class linebuffer_hls_stream_PackedStencil_int32_t_3_3___to_hls_stream_PackedStencil_int32_t_1_1___bnds_16_16 {
public:
PackedStencil_int32_t_1_1_ lb_read();
void lb_write(const PackedStencil_int32_t_3_3_& stencil);
bool has_valid_data();
}
```


Overlapping Code:
```
class linebuffer_hls_stream_PackedStencil_int32_t_3_3___to_hls_stream_PackedStencil_int32_t_1_1___bnds_16_16 {
public:
PackedStencil_int32_t_1_1_ lb_read();
void lb_write(const PackedStencil_int32_t_3_3_& stencil);
bool has_valid_data();
}
```
<Overlap Ratio: 1.0>

---

--- 181 --
Question ID: 107bc159e2e5d78baf6e082366fab5782f294df5_0
Original Code:
```
inline bool CaselessStringLessThanIgnoreSlashes( const char * const &lhs, const char * const &rhs )	
{ 
	const char *pa = lhs;
	const char *pb = rhs;
	while ( *pa && *pb )
	{
		char a = *pa;
		char b = *pb;
		
		// Check for dir slashes.
		if ( a == '/' || a == '\\' )
		{
			if ( b != '/' && b != '\\' )
				return ('/' < b);
		}
		else
		{
			if ( a >= 'a' && a <= 'z' )
				a = 'A' + (a - 'a');
			
			if ( b >= 'a' && b <= 'z' )
				b = 'A' + (b - 'a');
				
			if ( a > b )
				return false;
			else if ( a < b )
				return true;
		}
		++pa;
		++pb;
	}
	
	// Filenames also must be the same length.
	if ( *pa != *pb )
	{
		// If pa shorter than pb then it's "less"
		return ( !*pa );
	}

	return false;
}
```


Overlapping Code:
```
ine bool CaselessStringLessThanIgnoreSlashes( const char * const &lhs, const char * const &rhs ) 
{ 
const char *pa = lhs;
const char *pb = rhs;
while ( *pa && *pb )
{
char a = *pa;
char b = *pb;

// Check for dir slashes.
if ( a == '/' || a == '\\' )
{
if ( b != '/' && b != '\\' )
return ('/' < b);
}
else
{
if ( a >= 'a' && a <= 'z' )
a = 'A' + (a - 'a');

if ( b >= 'a' && b <= 'z' )
b = 'A' + (b - 'a');

if ( a > b )
return false;
else if ( a < b )
return true;
}
++pa;
++pb;
}

// Filenames also must be the same length.
if ( *pa != *pb )
{
// If pa shorter than pb then it's "less"
return ( !
```
<Overlap Ratio: 0.9569377990430622>

---

--- 182 --
Question ID: d769c3e8fd36e4fab326bf3b070644089f4fa0d1_1
Original Code:
```
int main(void)
{
	USART_Printf_Init(115200);
	printf("SystemClk:%d\r\n",SystemCoreClock);
		
	One_Pulse_Init( 200, 48000-1, 100 );	
	
	while(1);
}
```


Overlapping Code:
```
int main(void)
{
USART_Printf_Init(115200);
printf("SystemClk:%d\r\n",SystemCoreClock);

One_Pulse_Init( 200, 48000-1, 100
```
<Overlap Ratio: 0.8776978417266187>

---

--- 183 --
Question ID: 806cc9aa58d0ce76dcee6162b896cfdd6cfe2e71_0
Original Code:
```
namespace gpu3d {


/**  Defines the different states for a memory request entry.  */
enum MemReqState
{
    MRS_READY,      /**<  The memory request can be processed.  */
    MRS_WAITING,    /**<  The memory request is waiting for the memory module response.  */
    MRS_MEMORY,     /**<  The memory request is going to GPU memory.  */
    MRS_TRANSMITING /**<  The memory request is being transmited to a GPU unit.  */
};

/***  This defines the GPU unit source of the memory transaction request.  */
enum GPUUnit
{
    COMMANDPROCESSOR = 0,   /**<  Command Processor unit.  */
    STREAMERFETCH,          /**<  Streamer Fetch unit.  */
    STREAMERLOADER,         /**<  Streamer Loader unit.  */
    ZSTENCILTEST,           /**<  Z Stencil Test unit.  */
    COLORWRITE,             /**<  Color Write unit.  */
    DACB,                   /**<  DAC unit.  */
    TEXTUREUNIT,            /**<  Texture Unit.  */
    MEMORYMODULE,           /**<  Memory modules buses (channels), not used in Version 2 */
    SYSTEM,                 /**<  System memory bus.  */
    LASTGPUBUS              /**<  Marks the last GPU bus entry.  */
};

/**
 * Defines the memory controller state.
 */
enum MemState
{
    MS_NONE         = 0x00, /**<  Does not accept any request.  */
    MS_READ_ACCEPT  = 0x01, /**<  Read requests can be issued.  */
    MS_WRITE_ACCEPT = 0x02, /**<  Write data can be sent to the Memory Controller.  */
    MS_BOTH         = 0x03  /**<  Accepts read requests and write data transactions.  */
};

/*
 * This defines the different types of memory transactions.
 */
enum MemTransCom
{
    MT_READ_REQ,    /**<  Read request from GPU memory.  */
    MT_READ_DATA,   /**<  Read data from GPU memory.  */
    MT_WRITE_DATA,  /**<  Write data to GPU memory.  */
    MT_PRELOAD_DATA,/**<  Preload data into GPU memory.  */
    MT_STATE        /**<  Carries the current state of the memory controller.  */
};



/***  Maximum size of a memory transaction.  */
const u32bit MAX_TRANSACTION_SIZE = 64;

/**
 *  Defines the mask to get the offset for a transaction
 *  offset.
 */
const u32bit TRANSACTION_OFFSET_MASK = (MAX_TRANSACTION_SIZE - 1);

/**  Write mask size.  */
const u32bit WRITE_MASK_SIZE = (MAX_TRANSACTION_SIZE >> 2);

/***  Maximum number of memory transaction ids availables.  */
static const u32bit MAX_MEMORY_TICKETS = 256;


}
```


Overlapping Code:
```

/** Defines the different states for a memory request entry. */
enum MemReqState
{
MRS_READY, /**< The memory request can be processed. */
MRS_WAITING, /**< The memory request is waiting for the memory module response. */
MRS_MEMORY, /**< The memory request is going to GPU memory. */
MRS_TRANSMITING /**< The memory request is being transmited to a GPU unit. */
};
/*** This defines the GPU unit source of the memory transaction request. */
enum GPUUnit
{
COMMANDPROCESSOR = 0, /**< Command Processor unit. */
STREAMERFETCH, /**< Streamer Fetch unit. */
STREAMERLOADER, /**< Streamer Loader unit. */
ZSTENCILTEST, /**< Z Stencil Test unit. */
COLORWRITE, /**< Color Write unit. */
DACB, /**< DAC unit. */
TEXTUREUNIT, /**< Texture Unit. */
MEMORYMODULE, /**< Memory modules buses (channels), not used in Version 2 */
SYSTEM, /**< System memory bus. */
LASTGPUBUS /**< Marks the last GPU bus entry. */
};
/**
* Defines the memory controller state.
*/
enum MemState
{
MS_NONE = 0x00, /**< Does not accept any request. */
MS_READ_ACCEPT = 0x01, /**< Read requests can be issued. */
MS_WRITE_ACCEPT = 0x02, /**< Write data can be sent to the Memory Controller. */
MS_BOTH = 0x03 /**< Accepts read requests and write data transactions. */
};
/*
* This defines the different types of memory transactions.
*/
enum MemTransCom
{
MT_READ_REQ, /**< Read request from GPU memory. */
MT_READ_DATA, /**< Read data from GPU memory. */
MT_WRITE_DATA, /**< Write data to GPU memory. */
MT_PRELOAD_DATA,/**< Preload data into GPU memory. */
MT_STATE /**< Carries the current state of the memory controller. */
};
/*** Maximum size of a memory transaction. */
const u32bit MAX_TRANSACTION_SIZE = 64;
/**
* Defines the mask to get the offset for a transaction
* offset.
*/
const u32bit TRANSACTION_OFFSET_MASK = (MAX_TRANSACTION_SIZE - 1);
/** Write mask size. */
const u32bit WRITE_MASK_SIZE = (MAX_TRANSACTION_SIZE >> 2);
/*** Maximum number of memory transaction ids availables. */
static const u32bit MAX_MEMORY_T
```
<Overlap Ratio: 0.984251968503937>

---

--- 184 --
Question ID: a6d25d49bf956f8ce1390a402559e396125bfb88_3
Original Code:
```
int scp_bootloader_transfer(void *image, unsigned int image_size)
{
	uintptr_t offset = (uintptr_t)image - MHU_SECURE_BASE;
	uintptr_t end = offset + image_size;
	uint32_t response;

	mhu_secure_init();

	/* Initiate communications with SCP */
	do {
		cmd_start_payload *cmd_start = scp_boot_message_start();
		cmd_start->image_size = image_size;

		scp_boot_message_send(BOOT_CMD_START, sizeof(*cmd_start));

		response = scp_boot_message_wait(0);

		scp_boot_message_end();
	} while (response != BOOT_CMD_ACK);

	/* Transfer image to SCP a block at a time */
	uint32_t sequence_num = 1;
	size_t size;
	while ((size = end - offset) != 0) {
		if (size > BOOT_DATA_MAX_SIZE)
			size = BOOT_DATA_MAX_SIZE;
		while (!transfer_block(sequence_num, offset, size))
			; /* Retry forever */
		offset += size;
		sequence_num++;
	}

	/* Wait for SCP to signal it's ready */
	return scpi_wait_ready();
}
```


Overlapping Code:
```
p_bootloader_transfer(void *image, unsigned int image_size)
{
uintptr_t offset = (uintptr_t)image - MHU_SECURE_BASE;
uintptr_t end = offset + image_size;
uint32_t response;
mhu_secure_init();
/* Initiate communications with SCP */
do {
cmd_start_payload *cmd_start = scp_boot_message_start();
cmd_start->image_size = image_size;
scp_boot_message_send(BOOT_CMD_START, sizeof(*cmd_start));
response = scp_boot_message_wait(0);
scp_boot_message_end();
} while (response != BOOT_CMD_ACK);
/* Transfer image to SCP a block at a time */
uint32_t sequence_num = 1;
size_t size;
while ((size = end - offset) != 0) {
if (size > BOOT_DATA_MAX_SIZE)
size = BOOT_DATA_MAX_SIZE;
while (!transfer_block(sequence_num, offset, size))
; /* Retry forever */
offset += size;
sequence_num++;
}
/* Wait for SCP to signal it's ready */
return scpi_wait_rea
```
<Overlap Ratio: 0.9846517119244392>

---

--- 185 --
Question ID: 6ae29c45e11a2651b7933af7d325483988f55ccd_2
Original Code:
```
Bool 
S3V_I2CInit(ScrnInfoPtr pScrn)
{
    S3VPtr ps3v = S3VPTR(pScrn);
    I2CBusPtr I2CPtr;


    I2CPtr = xf86CreateI2CBusRec();
    if(!I2CPtr) return FALSE;

    ps3v->I2C = I2CPtr;

    I2CPtr->BusName    = "I2C bus";
    I2CPtr->scrnIndex  = pScrn->scrnIndex;
    I2CPtr->I2CPutBits = s3v_I2CPutBits;
    I2CPtr->I2CGetBits = s3v_I2CGetBits;

    if (!xf86I2CBusInit(I2CPtr))
      return FALSE;

    return TRUE;
}
```


Overlapping Code:
```
t(ScrnInfoPtr pScrn)
{
S3VPtr ps3v = S3VPTR(pScrn);
I2CBusPtr I2CPtr;
I2CPtr = xf86CreateI2CBusRec();
if(!I2CPtr) return FALSE;
ps3v->I2C = I2CPtr;
I2CPtr->BusName = "I2C bus";
I2CPtr->scrnIndex = pScrn->scrnIndex;
I2CPtr->I2CPutBits = s3v_I2CPutBits;
I2CPtr->I2CGetBits = s3v_I2CGetBits;
if (!xf86I2CBusInit(I2CPtr))
return FALSE;
return TRUE;

```
<Overlap Ratio: 0.9530386740331491>

---

--- 186 --
Question ID: 4dd34f7d87912abc165633f8bfc09a0b99e3162b_0
Original Code:
```
ssize_t pka_queue_get_memsize(uint32_t size)
{
    ssize_t q_size;

    // size must be a power of 2
    if ((!POWEROF2(size)) || (size > PKA_QUEUE_MASK_SIZE ))
    {
        PKA_DEBUG(PKA_QUEUE, "Requested size %u is invalid, must be "
                       "power of 2, and do not exceed the size limit %u\n",
                        size, PKA_QUEUE_MASK_SIZE);
        return -EINVAL;
    }

    q_size = sizeof(pka_queue_t) + size;
    q_size = PKA_ALIGN(q_size, PKA_CACHE_LINE_SIZE);

    return q_size;
}
```


Overlapping Code:
```
ssize_t q_size;
// size must be a power of 2
if ((!POWEROF2(size)) || (size > PKA_QUEUE_MASK_SIZE ))
{
PKA_DEBUG(PKA_QUEUE, "Requested size %u is invalid, must be "
"power of 2, and do not exceed the size limit %u\n",
size, PKA_QUEUE_MASK_SIZE);
return -EINVAL;
}
q_size = sizeof(pka_queue_t) + size;
q_size = PKA_ALIGN(q_size, PKA_CACHE_LINE_SIZE);

```
<Overlap Ratio: 0.847457627118644>

---

--- 187 --
Question ID: 6502d56384e96c34deac300dc880a010a2a531d1_23
Original Code:
```
static void lst(void)
{
		R.opcode.b.l &= 0xf7;		/* Must ignore next ARP */
		GETDATA(0,0);
		R.ALU.w.l &= (~INTM_FLAG);
		R.STR0 &= INTM_FLAG;
		R.STR0 |= R.ALU.w.l;		/* Must not affect INTM */
		R.STR0 |= 0x0400;
}
```


Overlapping Code:
```

{
R.opcode.b.l &= 0xf7; /* Must ignore next ARP */
GETDATA(0,0);
R.ALU.w.l &= (~INTM_FLAG);
R.STR0 &= INTM_FLAG;
R.STR0 |= R.ALU.w.l; /* Must not affect INTM */
R.STR0 |
```
<Overlap Ratio: 0.8415841584158416>

---

--- 188 --
Question ID: 3b56106e0a9f0fcecbea7a4961f78254d35150b4_0
Original Code:
```
namespace Selas
{
    struct ImageBasedLightResourceData;
    struct BuildProcessorContext;

    //=============================================================================================================================
    Error BakeImageBasedLight(BuildProcessorContext* context, ImageBasedLightResourceData* data);
}
```


Overlapping Code:
```
namespace Selas
{
struct ImageBasedLightResourceData;
struct BuildProcessorContext;
//=============================================================================================================================
Error BakeImageBasedLight(BuildProcessorContext* context, ImageBasedL
```
<Overlap Ratio: 0.9153094462540716>

---

--- 189 --
Question ID: 8617da86f17de245981526b84aaefc4718fc2c3a_240
Original Code:
```
void DaoException_Init( DaoException *self, DaoProcess *proc, const char *summary, DaoValue *dat )
{
	DaoVmCode *vmc = proc->activeCode;
	DaoRoutine *rout = proc->activeRoutine;
	DaoStackFrame *frame = proc->topFrame->prev;
	int line, id = (int) (vmc - proc->topFrame->active->codes);

	if( rout == NULL ) return;

	line = rout->defLine;
	if( proc->topFrame->active == proc->topFrame->prev ){
		DaoRoutine *rout2 = proc->topFrame->prev->routine;
		/*
		// proc->activeCode could be a dummy code set by:
		//   DaoProcess_InterceptReturnValue();
		// So always use the entry index whenever possible.
		*/
		id = proc->topFrame->prev->entry;
		if( rout2->body && id && id <= rout2->body->vmCodes->size ){
			line = rout2->body->annotCodes->items.pVmc[id-1]->line;
		}
	}else{
		id = (int) (vmc - proc->topFrame->active->codes);
		if( id < 0 || id > 0xffff ) id = 0; /* Not the precise location, but a safe one; */
		if( vmc && id < rout->body->vmCodes->size ){
			line = rout->body->annotCodes->items.pVmc[id]->line;
		}
	}

	if( summary && summary[0] != 0 ) DString_SetChars( self->info, summary );
	GC_Assign( & self->data, dat );

	DList_Clear( self->callers );
	DList_Clear( self->lines );
	DList_Append( self->callers, proc->topFrame->routine );
	DList_Append( self->lines, (daoint) (line<<16)|id );
	while( frame && frame != proc->startFrame->prev  && frame->routine ){
		DaoRoutineBody *body = frame->routine->body;
		if( self->callers->size >= 5 ) break;
		if( frame->entry ){
			/* deferred anonymous function may have been pushed but not executed: */
			line = body ? body->annotCodes->items.pVmc[ frame->entry - 1 ]->line : 0;
			DList_Append( self->callers, frame->routine );
			DList_Append( self->lines, (daoint) (line<<16)|(frame->entry - 1) );
		}
		frame = frame->prev;
	}
}
```


Overlapping Code:
```
tion *self, DaoProcess *proc, const char *summary, DaoValue *dat )
{
DaoVmCode *vmc = proc->activeCode;
DaoRoutine *rout = proc->activeRoutine;
DaoStackFrame *frame = proc->topFrame->prev;
int line, id = (int) (vmc - proc->topFrame->active->codes);
if( rout == NULL ) return;
line = rout->defLine;
if( proc->topFrame->active == proc->topFrame->prev ){
DaoRoutine *rout2 = proc->topFrame->prev->routine;
/*
// proc->activeCode could be a dummy code set by:
// DaoProcess_InterceptReturnValue();
// So always use the entry index whenever possible.
*/
id = proc->topFrame->prev->entry;
if( rout2->body && id && id <= rout2->body->vmCodes->size ){
line = rout2->body->annotCodes->items.pVmc[id-1]->line;
}
}else{
id = (int) (vmc - proc->topFrame->active->codes);
if( id < 0 || id > 0xffff ) id = 0; /* Not the precise location, but a safe one; */
if( vmc && id < rout->body->vmCodes->size ){
line = rout->body->annotCodes->items.pVmc[id]->line;
}
}
if( summary && summary[0] != 0 ) DString_SetChars( self->info, summary );
GC_Assign( & self->data, dat );
DList_Clear( self->callers );
DList_Clear( self->lines );
DList_Append( self->callers, proc->topFrame->routine );
DList_Append( self->lines, (daoint) (line<<16)|id );
while( frame && frame != proc->startFrame->prev && frame->routine ){
DaoRoutineBody *body = frame->routine->body;
if( self->callers->size >= 5 ) break;
if( frame->entry ){
/* deferred anonymous function may have been pushed but not executed: */
line = body ? body->annotCodes->items.pVmc[ frame->entry - 1 ]->line : 0;
DList_Append( self->callers, frame->routine );
DList_Append( self->lines, (daoint) (line<<16)|(frame->entry - 1) );
}
frame = fram
```
<Overlap Ratio: 0.9742840444184687>

---

--- 190 --
Question ID: db5ed9ffd3363435481145591b680ed05330c2a0_108
Original Code:
```
inline ::TST::Deprecated_TableStrokeArchive* Deprecated_StrokePresetDataArchive::mutable_deprecated_vertical_stroke() {
  ::TST::Deprecated_TableStrokeArchive* _msg = _internal_mutable_deprecated_vertical_stroke();
  // @@protoc_insertion_point(field_mutable:TST.Deprecated_StrokePresetDataArchive.deprecated_vertical_stroke)
  return _msg;
}
```


Overlapping Code:
```
ine ::TST::Deprecated_TableStrokeArchive* Deprecated_StrokePresetDataArchive::mutable_deprecated_vertical_stroke() {
::TST::Deprecated_TableStrokeArchive* _msg = _internal_mutable_deprecated_vertical_stroke();
// @@protoc_insertion_point(field_mutable:TST.Deprecated_StrokePresetDataArchive.deprecated_vertical_stroke)

```
<Overlap Ratio: 0.9494047619047619>

---

--- 191 --
Question ID: d0ae4392a976e900cb608e727bce42c8c4a3b334_13
Original Code:
```
ALT_STATUS_CODE alt_dma_event_int_select(ALT_DMA_EVENT_t evt_num,
                                         ALT_DMA_EVENT_SELECT_t opt)
{
    // Validate evt_num
    switch (evt_num)
    {
    case ALT_DMA_EVENT_0:
    case ALT_DMA_EVENT_1:
    case ALT_DMA_EVENT_2:
    case ALT_DMA_EVENT_3:
    case ALT_DMA_EVENT_4:
    case ALT_DMA_EVENT_5:
    case ALT_DMA_EVENT_6:
    case ALT_DMA_EVENT_7:
    case ALT_DMA_EVENT_ABORT:
        break;
    default:
        return ALT_E_BAD_ARG;
    }

    // For information on INTEN, see PL330, section 3.3.3.

    switch (opt)
    {
    case ALT_DMA_EVENT_SELECT_SEND_EVT:
        alt_clrbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);
        break;
    case ALT_DMA_EVENT_SELECT_SIG_IRQ:
        alt_setbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);
        break;
    default:
        return ALT_E_BAD_ARG;
    }

    return ALT_E_SUCCESS;
}
```


Overlapping Code:
```
E alt_dma_event_int_select(ALT_DMA_EVENT_t evt_num,
ALT_DMA_EVENT_SELECT_t opt)
{
// Validate evt_num
switch (evt_num)
{
case ALT_DMA_EVENT_0:
case ALT_DMA_EVENT_1:
case ALT_DMA_EVENT_2:
case ALT_DMA_EVENT_3:
case ALT_DMA_EVENT_4:
case ALT_DMA_EVENT_5:
case ALT_DMA_EVENT_6:
case ALT_DMA_EVENT_7:
case ALT_DMA_EVENT_ABORT:
break;
default:
return ALT_E_BAD_ARG;
}
// For information on INTEN, see PL330, section 3.3.3.
switch (opt)
{
case ALT_DMA_EVENT_SELECT_SEND_EVT:
alt_clrbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);
break;
case ALT_DMA_EVENT_SELECT_SIG_IRQ:
alt_setbits_word(ALT_DMA_INTEN_ADDR(ALT_DMASECURE_ADDR), 1 << evt_num);
break;
default:
return ALT_E_BAD_ARG;
}
return ALT_E_
```
<Overlap Ratio: 0.9672131147540983>

---

--- 192 --
Question ID: ee8117fa968bfd16fe38d3e960abb33dd73bef0b_1
Original Code:
```
extern inline int
__gai_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),
			    void *arg)
{
  pthread_attr_t attr;

  /* Make sure the thread is created detached.  */
  pthread_attr_init (&attr);
  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);

  /* The helper thread needs only very little resources.  */
  (void) pthread_attr_setstacksize (&attr, 0x10000);

  /* Block all signals in the helper thread.  To do this thoroughly we
     temporarily have to block all signals here.  */
  sigset_t ss;
  sigset_t oss;
  sigfillset (&ss);
  sigprocmask(SIG_SETMASK, &ss, &oss);

  int ret = pthread_create (threadp, &attr, tf, arg);

  /* Restore the signal mask.  */
  sigprocmask(SIG_SETMASK, &oss, NULL);

  (void) pthread_attr_destroy (&attr);
  return ret;
}
```


Overlapping Code:
```
_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),
void *arg)
{
pthread_attr_t attr;
/* Make sure the thread is created detached. */
pthread_attr_init (&attr);
pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
/* The helper thread needs only very little resources. */
(void) pthread_attr_setstacksize (&attr, 0x10000);
/* Block all signals in the helper thread. To do this thoroughly we
temporarily have to block all signals here. */
sigset_t ss;
sigset_t oss;
sigfillset (&ss);
sigprocmask(SIG_SETMASK, &ss, &oss);
int ret = pthread_create (threadp, &attr, tf, arg);
/* Restore the signal mask. */
sigprocmask(SIG_SETMASK, &oss, NULL);
(void) pthread_attr_destroy (&attr);
return ret;
}
```
<Overlap Ratio: 0.96875>

---

--- 193 --
Question ID: c0d9c9bd97eb3fa5a324959b98747680fc9c9294_14
Original Code:
```
static void test_pack_GOPHER_LOCATION_ATTRIBUTE_TYPEW(void)
{
    /* GOPHER_LOCATION_ATTRIBUTE_TYPEW */
    TEST_TYPE_SIZE   (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)
    TEST_TYPE_ALIGN  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)
    TEST_FIELD_SIZE  (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)
    TEST_FIELD_ALIGN (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)
    TEST_FIELD_OFFSET(GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 0)
}
```


Overlapping Code:
```
atic void test_pack_GOPHER_LOCATION_ATTRIBUTE_TYPEW(void)
{
/* GOPHER_LOCATION_ATTRIBUTE_TYPEW */
TEST_TYPE_SIZE (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)
TEST_TYPE_ALIGN (GOPHER_LOCATION_ATTRIBUTE_TYPEW, 8)
TEST_FIELD_SIZE (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)
TEST_FIELD_ALIGN (GOPHER_LOCATION_ATTRIBUTE_TYPEW, Location, 8)
TEST_FIELD_OFFSET(GOPHER_LOCATION_ATTRIBUTE_T
```
<Overlap Ratio: 0.9445843828715366>

---

--- 194 --
Question ID: 8ad3ba01506f2d09a580efb1d0a472cf389b5a6f_0
Original Code:
```
int main(int argc, char *argv[]) {

    // 諸々の変数を定義
    int i, data_count, transition_count;
    FILE *fp;
    char file_name[50];
    strcpy(file_name, argv[1]);
    Csv csv[DATA_MAX];

    // csvファイルを読み込む．読み込めないとエラーを書き込み（エラーが起こったファイルを特定するため）
    if ((fp = fopen(file_name, "r")) == NULL) {
        fprintf(stderr, "%s\n", "error: cant't read file.");
        return -1;
    }

    // データ数を数える
    i = 0;
    while (fscanf(fp, "%lf, %lf, %lf", &csv[i].x, &csv[i].y, &csv[i].t) != EOF) {
        i++;
    }
    data_count = i;

    // ファイルをクローズする
    fclose(fp);

    // 遷移回数格納用の変数の初期化
    int transition_count_of_into_front = 0, transition_count_of_into_plan = 0, transition_count_of_into_right_side = 0;

    // 視線がオブジェクト内に存在して，尚且つ，前の視線が違うオブジェクト上にあった場合にカウント
    for (i = 1; i < data_count; i++) {

        if (((FRONT_VIEW_LEFT < csv[i].x) && (csv[i].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i].y) && (csv[i].y < FRONT_VIEW_BOTTOM))) 
            if (!(((FRONT_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < FRONT_VIEW_BOTTOM)))) 
                transition_count_of_into_front++;
        
        if (((PLAN_VIEW_LEFT < csv[i].x) && (csv[i].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i].y) && (csv[i].y < PLAN_VIEW_BOTTOM))) 
            if (!(((PLAN_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < PLAN_VIEW_BOTTOM))))
                transition_count_of_into_plan++;
        
        if (((RIGHT_SIDE_VIEW_LEFT < csv[i].x) && (csv[i].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i].y) && (csv[i].y < RIGHT_SIDE_VIEW_BOTTOM)))
            if ((((RIGHT_SIDE_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < RIGHT_SIDE_VIEW_BOTTOM))))
                transition_count_of_into_right_side++;
    }

    // 総遷移回数を導出
    transition_count = transition_count_of_into_front + transition_count_of_into_plan + transition_count_of_into_right_side;

    FILE *resfp;
    char res_file_name[50];
    strcpy(res_file_name, argv[2]);
    resfp = fopen(res_file_name, "w");
    fprintf(resfp, "transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count\n");
    fprintf(resfp, "%d,%d,%d,%d\n",transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count);

    fclose(resfp);

    // データ出力
    /*
    for (i = 0; i < data_count; i++) {
        printf("%.2f, %.2f, %.2f\n", csv[i].x, csv[i].y, csv[i].t);
    }
    */
    printf("the number of data: %d\n", data_count);
    printf("the number of transition into frnot: %d\n", transition_count_of_into_front);
    printf("the number of transition into plan: %d\n", transition_count_of_into_plan);
    printf("the number of transition into right side: %d\n", transition_count_of_into_right_side);
    printf("the number of transition: %d\n", transition_count);

    return 1;
}
```


Overlapping Code:
```
nt main(int argc, char *argv[]) {
// 諸々の変数を定義
int i, data_count, transition_count;
FILE *fp;
char file_name[50];
strcpy(file_name, argv[1]);
Csv csv[DATA_MAX];
// csvファイルを読み込む．読み込めないとエラーを書き込み（エラーが起こったファイルを特定するため）
if ((fp = fopen(file_name, "r")) == NULL) {
fprintf(stderr, "%s\n", "error: cant't read file.");
return -1;
}
// データ数を数える
i = 0;
while (fscanf(fp, "%lf, %lf, %lf", &csv[i].x, &csv[i].y, &csv[i].t) != EOF) {
i++;
}
data_count = i;
// ファイルをクローズする
fclose(fp);
// 遷移回数格納用の変数の初期化
int transition_count_of_into_front = 0, transition_count_of_into_plan = 0, transition_count_of_into_right_side = 0;
// 視線がオブジェクト内に存在して，尚且つ，前の視線が違うオブジェクト上にあった場合にカウント
for (i = 1; i < data_count; i++) {
if (((FRONT_VIEW_LEFT < csv[i].x) && (csv[i].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i].y) && (csv[i].y < FRONT_VIEW_BOTTOM))) 
if (!(((FRONT_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < FRONT_VIEW_RIGHT)) && ((FRONT_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < FRONT_VIEW_BOTTOM)))) 
transition_count_of_into_front++;

if (((PLAN_VIEW_LEFT < csv[i].x) && (csv[i].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i].y) && (csv[i].y < PLAN_VIEW_BOTTOM))) 
if (!(((PLAN_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < PLAN_VIEW_RIGHT)) && ((PLAN_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < PLAN_VIEW_BOTTOM))))
transition_count_of_into_plan++;

if (((RIGHT_SIDE_VIEW_LEFT < csv[i].x) && (csv[i].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i].y) && (csv[i].y < RIGHT_SIDE_VIEW_BOTTOM)))
if ((((RIGHT_SIDE_VIEW_LEFT < csv[i-1].x) && (csv[i-1].x < RIGHT_SIDE_VIEW_RIGHT)) && ((RIGHT_SIDE_VIEW_TOP < csv[i-1].y) && (csv[i-1].y < RIGHT_SIDE_VIEW_BOTTOM))))
transition_count_of_into_right_side++;
}
// 総遷移回数を導出
transition_count = transition_count_of_into_front + transition_count_of_into_plan + transition_count_of_into_right_side;
FILE *resfp;
char res_file_name[50];
strcpy(res_file_name, argv[2]);
resfp = fopen(res_file_name, "w");
fprintf(resfp, "transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count\n");
fprintf(resfp, "%d,%d,%d,%d\n",transition_count_of_into_front,transition_count_of_into_plan,transition_count_of_into_right_side,transition_count);

```
<Overlap Ratio: 0.9932279909706546>

---

--- 195 --
Question ID: d2ed32a3236fc07742579275c0fbb70032ea28f9_167
Original Code:
```
static inline void hri_pm_set_APBBMASK_NVMCTRL_bit(const void *const hw)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBMASK.reg |= PM_APBBMASK_NVMCTRL;
	PM_CRITICAL_SECTION_LEAVE();
}
```


Overlapping Code:
```
ine void hri_pm_set_APBBMASK_NVMCTRL_bit(const void *const hw)
{
PM_CRITICAL_SECTION_ENTER();
((Pm *)hw)->APBBMASK.reg |= PM_APBBMASK_NVMCTRL;
PM_CRITICAL_SE
```
<Overlap Ratio: 0.8579234972677595>

---

--- 196 --
Question ID: 583acd4f3c34a0d2535d7a45a0426db50a6e7cb8_80
Original Code:
```
__attribute__((always_inline)) static inline int32_t __QSUB( int32_t op1, int32_t op2)
{
  int32_t result;

  __asm volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
  return(result);
}
```


Overlapping Code:
```
_attribute__((always_inline)) static inline int32_t __QSUB( int32_t op1, int32_t op2)
{
int32_t result;
__asm volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
return(result);
}
```
<Overlap Ratio: 0.9949494949494949>

---

--- 197 --
Question ID: 4edbeff7bbf46c6f8a91d4c37a6feba1a7d45a50_3
Original Code:
```
static float IO_FLOAT(void)
{
    union { float f; uint32 ui32; } cvt;
    cvt.ui32 = readle32();
    return cvt.f;
}
```


Overlapping Code:
```
atic float IO_FLOAT(void)
{
union { float f; uint32 ui32; } cvt;
cvt.ui32 = readle32();
return cvt.f
```
<Overlap Ratio: 0.9523809523809523>

---

--- 198 --
Question ID: 4fd9cba745566b0594dd690568ff8889d3d21c76_4
Original Code:
```
void C_covMatern3_2_hao(const double *dist, const int n,  const int d, const double *param, double* ans) {
  
  double scaling_factor = sqrt(3.);
  double s;
  for (int i = 0; i < n; i++) {
	  s = 0;
	  for (int k = 0; k < d; k++) {
		  s += SQUARE(dist[k + i * d]) * param[k];
  	  }
  	  s = sqrt(s) * scaling_factor;
	  ans[i] = exp(-s) * (1.0 + s);
  }
}
```


Overlapping Code:
```
2_hao(const double *dist, const int n, const int d, const double *param, double* ans) {

double scaling_factor = sqrt(3.);
double s;
for (int i = 0; i < n; i++) {
s = 0;
for (int k = 0; k < d; k++) {
s += SQUARE(dist[k + i * d]) * param[k];
}
s = sqrt(s) * scaling_factor;
ans[i] = exp(-s) * (1.0 + s
```
<Overlap Ratio: 0.9259259259259259>

---

--- 199 --
Question ID: 1db4b0b3287a8b8ac3362eec14771ebbf776f394_37
Original Code:
```
void ceph_fill_file_time(struct inode *inode, int issued,
			 u64 time_warp_seq, struct timespec *ctime,
			 struct timespec *mtime, struct timespec *atime)
{
	struct ceph_inode_info *ci = ceph_inode(inode);
	int warn = 0;

	if (issued & (CEPH_CAP_FILE_EXCL|
		      CEPH_CAP_FILE_WR|
		      CEPH_CAP_FILE_BUFFER|
		      CEPH_CAP_AUTH_EXCL|
		      CEPH_CAP_XATTR_EXCL)) {
		if (timespec_compare(ctime, &inode->i_ctime) > 0) {
			dout("ctime %ld.%09ld -> %ld.%09ld inc w/ cap\n",
			     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
			     ctime->tv_sec, ctime->tv_nsec);
			inode->i_ctime = *ctime;
		}
		if (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {
			/* the MDS did a utimes() */
			dout("mtime %ld.%09ld -> %ld.%09ld "
			     "tw %d -> %d\n",
			     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
			     mtime->tv_sec, mtime->tv_nsec,
			     ci->i_time_warp_seq, (int)time_warp_seq);

			inode->i_mtime = *mtime;
			inode->i_atime = *atime;
			ci->i_time_warp_seq = time_warp_seq;
		} else if (time_warp_seq == ci->i_time_warp_seq) {
			/* nobody did utimes(); take the max */
			if (timespec_compare(mtime, &inode->i_mtime) > 0) {
				dout("mtime %ld.%09ld -> %ld.%09ld inc\n",
				     inode->i_mtime.tv_sec,
				     inode->i_mtime.tv_nsec,
				     mtime->tv_sec, mtime->tv_nsec);
				inode->i_mtime = *mtime;
			}
			if (timespec_compare(atime, &inode->i_atime) > 0) {
				dout("atime %ld.%09ld -> %ld.%09ld inc\n",
				     inode->i_atime.tv_sec,
				     inode->i_atime.tv_nsec,
				     atime->tv_sec, atime->tv_nsec);
				inode->i_atime = *atime;
			}
		} else if (issued & CEPH_CAP_FILE_EXCL) {
			/* we did a utimes(); ignore mds values */
		} else {
			warn = 1;
		}
	} else {
		/* we have no write|excl caps; whatever the MDS says is true */
		if (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {
			inode->i_ctime = *ctime;
			inode->i_mtime = *mtime;
			inode->i_atime = *atime;
			ci->i_time_warp_seq = time_warp_seq;
		} else {
			warn = 1;
		}
	}
	if (warn) /* time_warp_seq shouldn't go backwards */
		dout("%p mds time_warp_seq %llu < %u\n",
		     inode, time_warp_seq, ci->i_time_warp_seq);
}
```


Overlapping Code:
```
void ceph_fill_file_time(struct inode *inode, int issued,
u64 time_warp_seq, struct timespec *ctime,
struct timespec *mtime, struct timespec *atime)
{
struct ceph_inode_info *ci = ceph_inode(inode);
int warn = 0;
if (issued & (CEPH_CAP_FILE_EXCL|
CEPH_CAP_FILE_WR|
CEPH_CAP_FILE_BUFFER|
CEPH_CAP_AUTH_EXCL|
CEPH_CAP_XATTR_EXCL)) {
if (timespec_compare(ctime, &inode->i_ctime) > 0) {
dout("ctime %ld.%09ld -> %ld.%09ld inc w/ cap\n",
inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
ctime->tv_sec, ctime->tv_nsec);
inode->i_ctime = *ctime;
}
if (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {
/* the MDS did a utimes() */
dout("mtime %ld.%09ld -> %ld.%09ld "
"tw %d -> %d\n",
inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
mtime->tv_sec, mtime->tv_nsec,
ci->i_time_warp_seq, (int)time_warp_seq);
inode->i_mtime = *mtime;
inode->i_atime = *atime;
ci->i_time_warp_seq = time_warp_seq;
} else if (time_warp_seq == ci->i_time_warp_seq) {
/* nobody did utimes(); take the max */
if (timespec_compare(mtime, &inode->i_mtime) > 0) {
dout("mtime %ld.%09ld -> %ld.%09ld inc\n",
inode->i_mtime.tv_sec,
inode->i_mtime.tv_nsec,
mtime->tv_sec, mtime->tv_nsec);
inode->i_mtime = *mtime;
}
if (timespec_compare(atime, &inode->i_atime) > 0) {
dout("atime %ld.%09ld -> %ld.%09ld inc\n",
inode->i_atime.tv_sec,
inode->i_atime.tv_nsec,
atime->tv_sec, atime->tv_nsec);
inode->i_atime = *atime;
}
} else if (issued & CEPH_CAP_FILE_EXCL) {
/* we did a utimes(); ignore mds values */
} else {
warn = 1;
}
} else {
/* we have no write|excl caps; whatever the MDS says is true */
if (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {
inode->i_ctime = *ctime;
inode->i_mtime = *mtime;
inode->i_atime = *atime;
ci->i_time_warp_seq = time_warp_seq;
} else {
warn = 1;
}
}
if (warn) /* time_warp_seq shouldn't go backwards */
dout("%p mds time_warp_seq %llu < %u\n",
inode, time_warp_seq, ci->i_time_warp_seq);

```
<Overlap Ratio: 0.9994725738396625>

---

--- 200 --
Question ID: d201c1523d57df5268805e01098a44d64a201306_25
Original Code:
```
int net_service_lookup(char *service)
{
  struct servent *se;
  se = getservbyname(service, NULL);
  if (se != NULL)
    return ntohs(se->s_port);
  else
    return 0;
}
```


Overlapping Code:
```
ce)
{
struct servent *se;
se = getservbyname(service, NULL);
if (se != NULL)
return ntohs(se->s_port);
else
re
```
<Overlap Ratio: 0.7189542483660131>

---

--- 201 --
Question ID: 11aa2ae6d63a23732e5a1d6532138d358c6bf0e9_0
Original Code:
```
static int
vips_foreign_save_csv_build( VipsObject *object )
{
	VipsForeignSave *save = (VipsForeignSave *) object;
	VipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;

	if( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )->
		build( object ) )
		return( -1 );

	if( vips__csv_write( save->ready, csv->filename, csv->separator ) )
		return( -1 );

	return( 0 );
}
```


Overlapping Code:
```
 int
vips_foreign_save_csv_build( VipsObject *object )
{
VipsForeignSave *save = (VipsForeignSave *) object;
VipsForeignSaveCsv *csv = (VipsForeignSaveCsv *) object;
if( VIPS_OBJECT_CLASS( vips_foreign_save_csv_parent_class )->
build( object ) )
return( -1 );
if( vips__csv_write( save->ready, csv->filename, csv->separator ) )
return( -1 );
return( 
```
<Overlap Ratio: 0.9668508287292817>

---

--- 202 --
Question ID: 1764ef509e93df97c64712092fbbc19609044400_8
Original Code:
```
double * rosen2dHess(double * x, void * args)
{
    assert(args == NULL);
    
    double * hess = calloc_double(2 * 2);
    hess[0] = 2.0 + 100.0 * 2.0 * ( -2.0 * (x[1] - pow(x[0],2.0)) ) * ( -2.0 * x[0] * (-2.0 * x[0]));
    hess[1] = 100.0 * 2.0 * x[1]; //d / dy ( df / dx)
    hess[2] = 100.0 * 2.0 * (-2.0 * x[0]); // d / dx (df / dy)
    hess[3] = 100.0 * 2.0;
    return hess;
}
```


Overlapping Code:
```
dHess(double * x, void * args)
{
assert(args == NULL);

double * hess = calloc_double(2 * 2);
hess[0] = 2.0 + 100.0 * 2.0 * ( -2.0 * (x[1] - pow(x[0],2.0)) ) * ( -2.0 * x[0] * (-2.0 * x[0]));
hess[1] = 100.0 * 2.0 * x[1]; //d / dy ( df / dx)
hess[2] = 100.0 * 2.0 * (-2.0 * x[0]); // d / dx (df / dy)
```
<Overlap Ratio: 0.8498583569405099>

---

--- 203 --
Question ID: 49758901196d6577f060fd566c4ce6ae41eac99d_21
Original Code:
```
void g2dSetCoordXYRelative(float x, float y)
{
    float inc_x = x;
    float inc_y = y;

    if (rctx.cur_obj.rot_cos != 1.f)
    {
        inc_x = -rctx.cur_obj.rot_sin*y + rctx.cur_obj.rot_cos*x;
        inc_y =  rctx.cur_obj.rot_cos*y + rctx.cur_obj.rot_sin*x;
    }

    rctx.cur_obj.x += inc_x * global_scale;
    rctx.cur_obj.y += inc_y * global_scale;
}
```


Overlapping Code:
```
dSetCoordXYRelative(float x, float y)
{
float inc_x = x;
float inc_y = y;
if (rctx.cur_obj.rot_cos != 1.f)
{
inc_x = -rctx.cur_obj.rot_sin*y + rctx.cur_obj.rot_cos*x;
inc_y = rctx.cur_obj.rot_cos*y + rctx.cur_obj.rot_sin*x;
}
rctx.cur_obj.x += inc_x * global_scale;
rctx.cur_obj.y += inc_y * 
```
<Overlap Ratio: 0.9299363057324841>

---

--- 204 --
Question ID: 6aa035aa0476432604c14d9530d43f27b50b128c_0
Original Code:
```
class RangeWrapper : public Nan::ObjectWrap {
public:
  static void init();
  static v8::Local<v8::Value> from_range(Range);
  static optional<Range> range_from_js(v8::Local<v8::Value>);

private:
  explicit RangeWrapper(Range);

  static void construct(const Nan::FunctionCallbackInfo<v8::Value> &);
  static void get_start(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);
  static void get_end(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);

  Range range;
}
```


Overlapping Code:
```
Wrapper : public Nan::ObjectWrap {
public:
static void init();
static v8::Local<v8::Value> from_range(Range);
static optional<Range> range_from_js(v8::Local<v8::Value>);
private:
explicit RangeWrapper(Range);
static void construct(const Nan::FunctionCallbackInfo<v8::Value> &);
static void get_start(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);
static void get_end(v8::Local<v8::String>, const Nan::PropertyCallbackInfo<v8::Value> &);
Range range
```
<Overlap Ratio: 0.9711340206185567>

---

--- 205 --
Question ID: 133cb3aa9245c163e388267e8cd2484fe5f42277_0
Original Code:
```
LLUV_IMPL_SAFE(lluv_fs_event_create){
  lluv_loop_t   *loop   = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
  lluv_handle_t *handle = lluv_handle_create(L, UV_FS_EVENT, safe_flag | INHERITE_FLAGS(loop));
  int err = uv_fs_event_init(loop->handle, LLUV_H(handle, uv_fs_event_t));
  if(err < 0){
    lluv_handle_cleanup(L, handle, -1);
    return lluv_fail(L, safe_flag | loop->flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
  }
  return 1;
}
```


Overlapping Code:
```

lluv_loop_t *loop = lluv_opt_loop_ex(L, 1, LLUV_FLAG_OPEN);
lluv_handle_t *handle = lluv_handle_create(L, UV_FS_EVENT, safe_flag | INHERITE_FLAGS(loop));
int err = uv_fs_event_init(loop->handle, LLUV_H(handle, uv_fs_event_t));
if(err < 0){
lluv_handle_cleanup(L, handle, -1);
return lluv_fail(L, safe_flag | loop->flags, LLUV_ERR_UV, (uv_errno_t)err, NULL);
}
return 1;
```
<Overlap Ratio: 0.9046454767726161>

---

--- 206 --
Question ID: 335b564cda044e705a7e9dd113fea50fb297f12f_0
Original Code:
```
int
osip_message_set_header (osip_message_t * sip, const char *hname,
			 const char *hvalue)
{
  osip_header_t *h;
  int i;

  if (hname == NULL)
    return -1;

  i = osip_header_init (&h);
  if (i != 0)
    return -1;

  h->hname = (char *) osip_malloc (strlen (hname) + 1);

  if (h->hname == NULL)
    {
      osip_header_free (h);
      return -1;
    }
  osip_strncpy (h->hname, hname, strlen (hname));
  osip_clrspace (h->hname);

  if (hvalue != NULL)
    {				/* some headers can be null ("subject:") */
      h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);
      if (h->hvalue == NULL)
	{
	  osip_header_free (h);
	  return -1;
	}
      osip_strncpy (h->hvalue, hvalue, strlen (hvalue));
      osip_clrspace (h->hvalue);
    }
  else
    h->hvalue = NULL;
  sip->message_property = 2;
  osip_list_add (sip->headers, h, -1);
  return 0;			/* ok */
}
```


Overlapping Code:
```
message_set_header (osip_message_t * sip, const char *hname,
const char *hvalue)
{
osip_header_t *h;
int i;
if (hname == NULL)
return -1;
i = osip_header_init (&h);
if (i != 0)
return -1;
h->hname = (char *) osip_malloc (strlen (hname) + 1);
if (h->hname == NULL)
{
osip_header_free (h);
return -1;
}
osip_strncpy (h->hname, hname, strlen (hname));
osip_clrspace (h->hname);
if (hvalue != NULL)
{ /* some headers can be null ("subject:") */
h->hvalue = (char *) osip_malloc (strlen (hvalue) + 1);
if (h->hvalue == NULL)
{
osip_header_free (h);
return -1;
}
osip_strncpy (h->hvalue, hvalue, strlen (hvalue));
osip_clrspace (h->hvalue);
}
else
h->hvalue = NULL;
sip->message_property = 2;
osip_list_add (sip->headers, h, -1);
return 0
```
<Overlap Ratio: 0.9721115537848606>

---

--- 207 --
Question ID: 7603cb9ead1dc2d03e57f80bb9b2e39880ee204e_3
Original Code:
```
static int crypto_stm32_ecb_encrypt(struct cipher_ctx *ctx,
				    struct cipher_pkt *pkt)
{
	int ret;

	/* For security reasons, ECB mode should not be used to encrypt
	 * more than one block. Use CBC mode instead.
	 */
	if (pkt->in_len > 16) {
		LOG_ERR("Cannot encrypt more than 1 block");
		return -EINVAL;
	}

	ret = do_encrypt(ctx, pkt->in_buf, pkt->in_len, pkt->out_buf);
	if (ret == 0) {
		pkt->out_len = 16;
	}

	return ret;
}
```


Overlapping Code:
```
stm32_ecb_encrypt(struct cipher_ctx *ctx,
struct cipher_pkt *pkt)
{
int ret;
/* For security reasons, ECB mode should not be used to encrypt
* more than one block. Use CBC mode instead.
*/
if (pkt->in_len > 16) {
LOG_ERR("Cannot encrypt more than 1 block");
return -EINVAL;
}
ret = do_encrypt(ctx, pkt->in_buf, pkt->in_len, pkt->out_buf);
if (ret == 0) {
pkt->out_len = 16;
}
```
<Overlap Ratio: 0.9213759213759214>

---

--- 208 --
Question ID: 134699eb794873fb79330a4c065ffab535eb07b7_1
Original Code:
```
class StageSetup : public QDialog
{
    Q_OBJECT
public:
    explicit StageSetup(AppState *appState, QWidget *parent = 0);
    virtual ~StageSetup();

    virtual void keyPressEvent(QKeyEvent *e);

signals:

public slots:
    virtual void accept();
    virtual void reject();
    void onInitialized();
    void onFailed();
    void onStageStarted();
    void onStageFinished();
    void onInitStageFinished();
    void onGoToLimStageFinished();
    void onGoToPosStageFinished();
    void onCurrPosChanged(int pos);
    void onLowerLimChanged(int lim);
    void onUpperLimChanged(int lim);

private slots:
    void onInitButtonReleased();
    void onStopButtonReleased();
    void onInitComboboxCurrentIndexChanged(int index);
    void onPosRefComboboxCurrentIndexChanged(int index);
    void onGoUpLimButtonReleased();
    void onGoLowLimButtonReleased();
    void onMeasGoButtonReleased();
    void onCalGoButtonReleased();

private:
    QPushButton *initButton;
    QPushButton *goUpLimButton;
    QPushButton *goLowLimButton;
    QPushButton *stopButton;
    QGroupBox *posGroupBox;
    QComboBox *posRefComboBox;
    QLabel *upperLimitLabel;
    QLabel *lowerLimitLabel;
    QLabel *currPosLabel;
    QGroupBox *initGroupBox;
    QComboBox *initComboBox;
    QSpinBox *rangeSpinBox;
    QGroupBox *measGroupBox;
    QSpinBox *measPosSpinBox;
    QComboBox *measRefComboBox;
//    QComboBox *measInitComboBox;
    QPushButton *measGoButton;
    QGroupBox *calGroupBox;
    QSpinBox *calPosSpinBox;
    QComboBox *calRefComboBox;
//    QComboBox *calInitComboBox;
    QPushButton *calGoButton;
    QDialogButtonBox *dialogButtonBox;

    AppState *appState_;
    StageControl *stageControl_;
    StageControlTraits::Params *params_;
    StageTasks::Initialize *initStage;
    StageTasks::GoToLimWaitList *goToLimStage;
    StageTasks::GoToPos *goToPosStage;

    int absoluteLowerLim;
    int absoluteUpperLim;
    int absoluteCurrPos;
}
```


Overlapping Code:
```
ialog
{
Q_OBJECT
public:
explicit StageSetup(AppState *appState, QWidget *parent = 0);
virtual ~StageSetup();
virtual void keyPressEvent(QKeyEvent *e);
signals:
public slots:
virtual void accept();
virtual void reject();
void onInitialized();
void onFailed();
void onStageStarted();
void onStageFinished();
void onInitStageFinished();
void onGoToLimStageFinished();
void onGoToPosStageFinished();
void onCurrPosChanged(int pos);
void onLowerLimChanged(int lim);
void onUpperLimChanged(int lim);
private slots:
void onInitButtonReleased();
void onStopButtonReleased();
void onInitComboboxCurrentIndexChanged(int index);
void onPosRefComboboxCurrentIndexChanged(int index);
void onGoUpLimButtonReleased();
void onGoLowLimButtonReleased();
void onMeasGoButtonReleased();
void onCalGoButtonReleased();
private:
QPushButton *initButton;
QPushButton *goUpLimButton;
QPushButton *goLowLimButton;
QPushButton *stopButton;
QGroupBox *posGroupBox;
QComboBox *posRefComboBox;
QLabel *upperLimitLabel;
QLabel *lowerLimitLabel;
QLabel *currPosLabel;
QGroupBox *initGroupBox;
QComboBox *initComboBox;
QSpinBox *rangeSpinBox;
QGroupBox *measGroupBox;
QSpinBox *measPosSpinBox;
QComboBox *measRefComboBox;
// QComboBox *measInitComboBox;
QPushButton *measGoButton;
QGroupBox *calGroupBox;
QSpinBox *calPosSpinBox;
QComboBox *calRefComboBox;
// QComboBox *calInitComboBox;
QPushButton *calGoButton;
QDialogButtonBox *dialogButtonBox;
AppState *appState_;
StageControl *stageControl_;
StageControlTraits::Params *params_;
StageTasks::Initialize *initStage;
StageTasks::GoToLimWaitList *goToLimStage;
StageTasks::GoToPos *goToPosStage;
int absoluteLowerLim;
int absolut
```
<Overlap Ratio: 0.9643483343074225>

---

--- 209 --
Question ID: c5eea1e477ed4a9680cd584ee6a35964a89dd10e_8
Original Code:
```
static void memcpy_wide_bus_read_int(int *a_buf, MARS_WIDE_BUS_TYPE *a,
                                            size_t offset_byte,
                                            size_t size_byte) {
#pragma HLS inline self
  const size_t data_width = sizeof(int);
  const size_t bus_width = BUS_WIDTH;
  const size_t num_elements = bus_width / data_width;
  size_t buf_size = size_byte / data_width;
  size_t offset = offset_byte / data_width;
  size_t head_align = offset & (num_elements - 1);
  size_t new_offset = offset + buf_size;
  size_t tail_align = (new_offset - 1) & (num_elements - 1);
  size_t start = offset / num_elements;
  size_t end = (offset + buf_size + num_elements - 1) / num_elements;
  //MARS_WIDE_BUS_TYPE *a_offset = a + start;
  size_t i, j;
  int len = end - start;
  assert(len <= buf_size / num_elements + 2);
  assert(len >= buf_size / num_elements);
  if (1 == len) {
#ifdef __cplusplus
    MARS_WIDE_BUS_TYPE tmp(a[start]);
#else
    MARS_WIDE_BUS_TYPE tmp = a[start];
#endif
    for (j = 0; j < num_elements; ++j) {
       if (j < head_align || j > tail_align)
         continue;
        a_buf[j - head_align] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
    }
    return;
  }

  for (i = 0; i < len; ++i) {
#pragma HLS pipeline
#ifdef __cplusplus
    MARS_WIDE_BUS_TYPE tmp(a[i + start]);
#else
    MARS_WIDE_BUS_TYPE tmp = a[i + start];
#endif
    if (head_align == 0) {
      for (j = 0; j < num_elements; ++j) {
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 0] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 1) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 1)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 1] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 2) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 2)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 2] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 3) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 3)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 3] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 4) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 4)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 4] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 5) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 5)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 5] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 6) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 6)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 6] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 7) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 7)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 7] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 8) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 8)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 8] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 9) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 9)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 9] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 10) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 10)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 10] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 11) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 11)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 11] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 12) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 12)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 12] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 13) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 13)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 13] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else if (head_align == 14) {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 14)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 14] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }

    else {
      for (j = 0; j < num_elements; ++j) {
        if (i == 0 && j < 15)
          continue;
        if (i == end - start - 1 && j > tail_align)
          continue;
        a_buf[i * num_elements + j - 15] =
            tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
      }
    }
  }
}
```


Overlapping Code:
```
mcpy_wide_bus_read_int(int *a_buf, MARS_WIDE_BUS_TYPE *a,
size_t offset_byte,
size_t size_byte) {
#pragma HLS inline self
const size_t data_width = sizeof(int);
const size_t bus_width = BUS_WIDTH;
const size_t num_elements = bus_width / data_width;
size_t buf_size = size_byte / data_width;
size_t offset = offset_byte / data_width;
size_t head_align = offset & (num_elements - 1);
size_t new_offset = offset + buf_size;
size_t tail_align = (new_offset - 1) & (num_elements - 1);
size_t start = offset / num_elements;
size_t end = (offset + buf_size + num_elements - 1) / num_elements;
//MARS_WIDE_BUS_TYPE *a_offset = a + start;
size_t i, j;
int len = end - start;
assert(len <= buf_size / num_elements + 2);
assert(len >= buf_size / num_elements);
if (1 == len) {
#ifdef __cplusplus
MARS_WIDE_BUS_TYPE tmp(a[start]);
#else
MARS_WIDE_BUS_TYPE tmp = a[start];
#endif
for (j = 0; j < num_elements; ++j) {
if (j < head_align || j > tail_align)
continue;
a_buf[j - head_align] =
tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
}
return;
}
for (i = 0; i < len; ++i) {
#pragma HLS pipeline
#ifdef __cplusplus
MARS_WIDE_BUS_TYPE tmp(a[i + start]);
#else
MARS_WIDE_BUS_TYPE tmp = a[i + start];
#endif
if (head_align == 0) {
for (j = 0; j < num_elements; ++j) {
if (i == end - start - 1 && j > tail_align)
continue;
a_buf[i * num_elements + j - 0] =
tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
}
}
else if (head_align == 1) {
for (j = 0; j < num_elements; ++j) {
if (i == 0 && j < 1)
continue;
if (i == end - start - 1 && j > tail_align)
continue;
a_buf[i * num_elements + j - 1] =
tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
}
}
else if (head_align == 2) {
for (j = 0; j < num_elements; ++j) {
if (i == 0 && j < 2)
continue;
if (i == end - start - 1 && j > tail_align)
continue;
a_buf[i * num_elements + j - 2] =
tmp2(((j + 1) * data_width * 8 - 1), (j * data_width * 8));
}
}
else if (head_align == 3) {
for (j = 0; j < num_elements; ++j) {
if (i == 0 && j < 3)
continue;
if (i == end - start - 1 && j > tai
```
<Overlap Ratio: 0.9922367782629792>

---

--- 210 --
Question ID: 5cff95c5783657160ba1123b0e3d7ed72bb88dd2_13
Original Code:
```
int wps_send_eap_identity_rsp(u8 id)
{
    struct wps_sm *sm = gWpsSm;
    struct wpabuf *eap_buf = NULL;
    u8 bssid[6];
    u8 *buf = NULL;
    int len;
    int ret = ESP_OK;

    wpa_printf(MSG_DEBUG, "wps send eapol id rsp");
    eap_buf = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IDENTITY, sm->identity_len,
                            EAP_CODE_RESPONSE, id);
    if (!eap_buf) {
        ret = ESP_FAIL;
        goto _err;
    }

    ret = esp_wifi_get_assoc_bssid_internal(bssid);
    if (ret != 0) {
        wpa_printf(MSG_ERROR, "bssid is empty!");
        return ESP_FAIL;
    }

    wpabuf_put_data(eap_buf, sm->identity, sm->identity_len);

    buf = wps_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAP_PACKET, wpabuf_head_u8(eap_buf), wpabuf_len(eap_buf), (size_t *)&len, NULL);
    if (!buf) {
        ret = ESP_ERR_NO_MEM;
        goto _err;
    }

    ret = wps_sm_ether_send(sm, bssid, ETH_P_EAPOL, buf, len);
    if (ret) {
        ret = ESP_FAIL;
        goto _err;
    }

_err:
    wps_sm_free_eapol(buf);
    wpabuf_free(eap_buf);
    return ret;
}
```


Overlapping Code:
```
_rsp(u8 id)
{
struct wps_sm *sm = gWpsSm;
struct wpabuf *eap_buf = NULL;
u8 bssid[6];
u8 *buf = NULL;
int len;
int ret = ESP_OK;
wpa_printf(MSG_DEBUG, "wps send eapol id rsp");
eap_buf = eap_msg_alloc(EAP_VENDOR_IETF, EAP_TYPE_IDENTITY, sm->identity_len,
EAP_CODE_RESPONSE, id);
if (!eap_buf) {
ret = ESP_FAIL;
goto _err;
}
ret = esp_wifi_get_assoc_bssid_internal(bssid);
if (ret != 0) {
wpa_printf(MSG_ERROR, "bssid is empty!");
return ESP_FAIL;
}
wpabuf_put_data(eap_buf, sm->identity, sm->identity_len);
buf = wps_sm_alloc_eapol(sm, IEEE802_1X_TYPE_EAP_PACKET, wpabuf_head_u8(eap_buf), wpabuf_len(eap_buf), (size_t *)&len, NULL);
if (!buf) {
ret = ESP_ERR_NO_MEM;
goto _err;
}
ret = wps_sm_ether_send(sm, bssid, ETH_P_EAPOL, buf, len);
if (ret) {
ret = ESP_FAIL;
goto _err;
}
_err:
wps_sm_free_eap
```
<Overlap Ratio: 0.9205983889528193>

---

--- 211 --
Question ID: c547d019512306e53bdbd200dc65427432bf17ff_0
Original Code:
```
void create(){
   ::create();

   set_long(::query_long()+"\n%^C247%^To the South you can see stairs leading down.%^CRST%^\n");

set_exits(([
"south" : WHITE"8",
"southwest" : WHITE"10",
"southeast" : WHITE"14",

]));


}
```


Overlapping Code:
```
void create(){
::create();
set_long(::query_long()+"\n%^C247%^To the South you can see stairs leading down.%^CRST%^\n");
set_exits(([
"south" : WHITE"8",
"southwest" : WHITE"10",
"southeast" : WHITE"14",
]));
}
```
<Overlap Ratio: 1.0>

---

--- 212 --
Question ID: 7f3dcc028fadbd7b804583469b7c480736d89f77_6
Original Code:
```
void* list_pop_node(list_t* list, node_t* node)
{
  void* element;
  
  if (!node) {
    return (NULL);
  }
  element = node->element;
  list_remove_node(list, node);
  return (element);
}
```


Overlapping Code:
```
e(list_t* list, node_t* node)
{
void* element;

if (!node) {
return (NULL);
}
element = node->element;
list_remove_node(list, node);
return (element);
```
<Overlap Ratio: 0.8823529411764706>

---

--- 213 --
Question ID: 1c3ce67a283e259a2edc25fedbfaa303a04db6f2_0
Original Code:
```
static intptr_t i_lchar(intptr_t s, intptr_t n, intptr_t c)
{
    char* p = (char*)(s<<SHIFT);
    p[n] = c;
	return c;
}
```


Overlapping Code:
```
, intptr_t c)
{
char* p = (char*)(s<<SHIFT);
p[n] 
```
<Overlap Ratio: 0.44642857142857145>

---

--- 214 --
Question ID: 0b7f7a02b65ce6926d64aa8575f3cc9d7ec0a35f_15
Original Code:
```
uint8_t ListValidAlarmCodes(uint16_t DeviceId) {
	uint8_t DeviceIndex;
	pAuthorizedCodes codes;
	uint8_t i;
	uint8_t AlarmCodeCount = 0;

	if ((DeviceIndex = FindDeviceId(DeviceId)) == MAX_DEVICES) {
		return(0);
	}

	// make sure it's a keypad or swipe device
	if (Devices[DeviceIndex].Type != DEVICE_KEYPAD && Devices[DeviceIndex].Type != DEVICE_SWIPE) {
		return(0);
	}

	// make a copy of the device's valid codes
	if (!Devices[DeviceIndex].Attributes) {
		SendBytes((unsigned char *)&AlarmCodeCount, 1);
		SendResp(RESP_SUCCESS, NULL);
		return(1);
	}
	if ((codes = (pAuthorizedCodes)calloc(sizeof(AuthorizedCodes))) == NULL) {
		return(0);
	}
	memcpy(codes, Devices[DeviceIndex].Attributes, sizeof(AuthorizedCodes));
	SortCodes(codes);

	// once through to get a count of codes we'll be sending
	for (i = 0; i < MAX_USERS; i++) {
		if (codes->AccessCodes[i][0] == '\0') {
			continue;
		}
		AlarmCodeCount++;
	}

	// Send the count
	SendBytes((unsigned char *)&AlarmCodeCount, 1);

	// Send the codes
	for (i = 0; i < MAX_USERS; i++) {
		if (codes->AccessCodes[i][0] == '\0') {
			continue;
		}
		SendBytes((unsigned char *)&codes->AccessCodes[i], 32);
	}

	SendResp(RESP_SUCCESS, NULL);

	free(codes);

	return(1);
}
```


Overlapping Code:
```
ValidAlarmCodes(uint16_t DeviceId) {
uint8_t DeviceIndex;
pAuthorizedCodes codes;
uint8_t i;
uint8_t AlarmCodeCount = 0;
if ((DeviceIndex = FindDeviceId(DeviceId)) == MAX_DEVICES) {
return(0);
}
// make sure it's a keypad or swipe device
if (Devices[DeviceIndex].Type != DEVICE_KEYPAD && Devices[DeviceIndex].Type != DEVICE_SWIPE) {
return(0);
}
// make a copy of the device's valid codes
if (!Devices[DeviceIndex].Attributes) {
SendBytes((unsigned char *)&AlarmCodeCount, 1);
SendResp(RESP_SUCCESS, NULL);
return(1);
}
if ((codes = (pAuthorizedCodes)calloc(sizeof(AuthorizedCodes))) == NULL) {
return(0);
}
memcpy(codes, Devices[DeviceIndex].Attributes, sizeof(AuthorizedCodes));
SortCodes(codes);
// once through to get a count of codes we'll be sending
for (i = 0; i < MAX_USERS; i++) {
if (codes->AccessCodes[i][0] == '\0') {
continue;
}
AlarmCodeCount++;
}
// Send the count
SendBytes((unsigned char *)&AlarmCodeCount, 1);
// Send the codes
for (i = 0; i < MAX_USERS; i++) {
if (codes->AccessCodes[i][0] == '\0') {
continue;
}
SendBytes((unsigned char *)&codes->AccessCodes[i], 32);
}
SendResp(R
```
<Overlap Ratio: 0.9507346585998271>

---

--- 215 --
Question ID: 9e04e3e4d4d52cb91650a121bb5d1f7e485bbd81_28
Original Code:
```
static void ucp_worker_init_guess_atomics(ucp_worker_h worker)
{
    uint64_t accumulated_flags = 0;
    ucp_rsc_index_t iface_id;

    for (iface_id = 0; iface_id < worker->num_ifaces; ++iface_id) {
        accumulated_flags |= worker->ifaces[iface_id].attr.cap.flags;
    }

    if (accumulated_flags & UCT_IFACE_FLAG_ATOMIC_DEVICE) {
        ucp_worker_init_device_atomics(worker);
    } else {
        ucp_worker_init_cpu_atomics(worker);
    }
}
```


Overlapping Code:
```
id ucp_worker_init_guess_atomics(ucp_worker_h worker)
{
uint64_t accumulated_flags = 0;
ucp_rsc_index_t iface_id;
for (iface_id = 0; iface_id < worker->num_ifaces; ++iface_id) {
accumulated_flags |= worker->ifaces[iface_id].attr.cap.flags;
}
if (accumulated_flags & UCT_IFACE_FLAG_ATOMIC_DEVICE) {
ucp_worker_init_device_atomics(worker);
} else {
ucp_worker_init_cpu_atomics(worker);
}
```
<Overlap Ratio: 0.9722222222222222>

---

--- 216 --
Question ID: 49ec5b94c71f958868711ebc048cd068c3fbec23_6
Original Code:
```
pci_power_t intel_mid_pci_get_power_state(struct pci_dev *pdev)
{
	struct mid_pwr *pwr = midpwr;
	int id, reg, bit;
	u32 power;

	if (!pwr || !pwr->available)
		return PCI_UNKNOWN;

	id = intel_mid_pwr_get_lss_id(pdev);
	if (id < 0)
		return PCI_UNKNOWN;

	reg = (id * LSS_PWS_BITS) / 32;
	bit = (id * LSS_PWS_BITS) % 32;
	power = mid_pwr_get_state(pwr, reg);
	return (__force pci_power_t)((power >> bit) & 3);
}
```


Overlapping Code:
```
_t intel_mid_pci_get_power_state(struct pci_dev *pdev)
{
struct mid_pwr *pwr = midpwr;
int id, reg, bit;
u32 power;
if (!pwr || !pwr->available)
return PCI_UNKNOWN;
id = intel_mid_pwr_get_lss_id(pdev);
if (id < 0)
return PCI_UNKNOWN;
reg = (id * LSS_PWS_BITS) / 32;
bit = (id * LSS_PWS_BITS) % 32;
power = mid_pwr_get_state(pwr, reg);
return (__force
```
<Overlap Ratio: 0.8860759493670886>

---

--- 217 --
Question ID: 04f691d127b4bb9547da3c0865746e2fb4777fcb_50
Original Code:
```
static int wavelan_get_wap(struct net_device *dev,
			   struct iw_request_info *info,
			   union iwreq_data *wrqu,
			   char *extra)
{
	/* Should get the real McCoy instead of own Ethernet address */
	memcpy(wrqu->ap_addr.sa_data, dev->dev_addr, WAVELAN_ADDR_SIZE);
	wrqu->ap_addr.sa_family = ARPHRD_ETHER;

	return -EOPNOTSUPP;
}
```


Overlapping Code:
```
n_get_wap(struct net_device *dev,
struct iw_request_info *info,
union iwreq_data *wrqu,
char *extra)
{
/* Should get the real McCoy instead of own Ethernet address */
memcpy(wrqu->ap_addr.sa_data, dev->dev_addr, WAVELAN_ADDR_SIZE);
wrqu->ap_addr.sa_f
```
<Overlap Ratio: 0.8064516129032258>

---

--- 218 --
Question ID: 3ad3f9f4f73f718f0da29610fff7e6542840d729_0
Original Code:
```
class DefaultWindowBehaviour : public WindowBehaviour {
public:
								DefaultWindowBehaviour(Window* window);
	virtual						~DefaultWindowBehaviour();

	virtual	bool				MouseDown(BMessage* message, BPoint where,
									int32 lastHitRegion, int32& clickCount,
									int32& _hitRegion);
	virtual	void				MouseUp(BMessage* message, BPoint where);
	virtual	void				MouseMoved(BMessage *message, BPoint where,
									bool isFake);

	virtual	void				ModifiersChanged(int32 modifiers);

protected:
	virtual bool				AlterDeltaForSnap(Window* window, BPoint& delta,
									bigtime_t now);
private:
			enum Action {
				ACTION_NONE,
				ACTION_ZOOM,
				ACTION_CLOSE,
				ACTION_MINIMIZE,
				ACTION_TAB,
				ACTION_DRAG,
				ACTION_SLIDE_TAB,
				ACTION_RESIZE,
				ACTION_RESIZE_BORDER
			};

			enum {
				// 1 for the "natural" resize border, -1 for the opposite, so
				// multiplying the movement delta by that value results in the
				// size change.
				LEFT	= -1,
				TOP		= -1,
				NONE	= 0,
				RIGHT	= 1,
				BOTTOM	= 1
			};

			struct State;
			struct MouseTrackingState;
			struct DragState;
			struct ResizeState;
			struct SlideTabState;
			struct ResizeBorderState;
			struct DecoratorButtonState;
			struct ManageWindowState;

			// to keep gcc 2 happy
			friend struct State;
			friend struct MouseTrackingState;
			friend struct DragState;
			friend struct ResizeState;
			friend struct SlideTabState;
			friend struct ResizeBorderState;
			friend struct DecoratorButtonState;
			friend struct ManageWindowState;

private:
			bool				_IsWindowModifier(int32 modifiers) const;
			Decorator::Region	_RegionFor(const BMessage* message,
									int32& tab) const;

			void				_SetBorderHighlights(int8 horizontal,
									int8 vertical, bool active);

			ServerCursor*		_ResizeCursorFor(int8 horizontal,
									int8 vertical);
			void				_SetResizeCursor(int8 horizontal,
									int8 vertical);
			void				_ResetResizeCursor();
	static	void				_ComputeResizeDirection(float x, float y,
									int8& _horizontal, int8& _vertical);

			void				_NextState(State* state);

protected:
			Window*				fWindow;
			Desktop*			fDesktop;
			State*				fState;
			int32				fLastModifiers;

			MagneticBorder		fMagneticBorder;
}
```


Overlapping Code:
```
indowBehaviour {
public:
DefaultWindowBehaviour(Window* window);
virtual ~DefaultWindowBehaviour();
virtual bool MouseDown(BMessage* message, BPoint where,
int32 lastHitRegion, int32& clickCount,
int32& _hitRegion);
virtual void MouseUp(BMessage* message, BPoint where);
virtual void MouseMoved(BMessage *message, BPoint where,
bool isFake);
virtual void ModifiersChanged(int32 modifiers);
protected:
virtual bool AlterDeltaForSnap(Window* window, BPoint& delta,
bigtime_t now);
private:
enum Action {
ACTION_NONE,
ACTION_ZOOM,
ACTION_CLOSE,
ACTION_MINIMIZE,
ACTION_TAB,
ACTION_DRAG,
ACTION_SLIDE_TAB,
ACTION_RESIZE,
ACTION_RESIZE_BORDER
};
enum {
// 1 for the "natural" resize border, -1 for the opposite, so
// multiplying the movement delta by that value results in the
// size change.
LEFT = -1,
TOP = -1,
NONE = 0,
RIGHT = 1,
BOTTOM = 1
};
struct State;
struct MouseTrackingState;
struct DragState;
struct ResizeState;
struct SlideTabState;
struct ResizeBorderState;
struct DecoratorButtonState;
struct ManageWindowState;
// to keep gcc 2 happy
friend struct State;
friend struct MouseTrackingState;
friend struct DragState;
friend struct ResizeState;
friend struct SlideTabState;
friend struct ResizeBorderState;
friend struct DecoratorButtonState;
friend struct ManageWindowState;
private:
bool _IsWindowModifier(int32 modifiers) const;
Decorator::Region _RegionFor(const BMessage* message,
int32& tab) const;
void _SetBorderHighlights(int8 horizontal,
int8 vertical, bool active);
ServerCursor* _ResizeCursorFor(int8 horizontal,
int8 vertical);
void _SetResizeCursor(int8 horizontal,
int8 vertical);
void _ResetResizeCursor();
static void _ComputeResizeDirection(float x, float y,
int8& _horizontal, int8& _vertical);
void _NextState(State* state);
protected:
Window* fWindow;
Desktop* fDesktop;
State* fState;
int32 fLastModifiers;
MagneticB
```
<Overlap Ratio: 0.967067433350758>

---

--- 219 --
Question ID: 3c272f95a015c2d9d74989056af9a9921a492cc8_0
Original Code:
```
int main() {
  char *buf = (char *)mmap(0, 100000, PROT_READ | PROT_WRITE,
                           MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  assert(buf);
  munmap(buf, 100000);
}
```


Overlapping Code:
```
= (char *)mmap(0, 100000, PROT_READ | PROT_WRITE,
MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
assert(buf);

```
<Overlap Ratio: 0.6896551724137931>

---

--- 220 --
Question ID: ca4248aed6902fef56f2716e004067dbc8bfb8b3_2
Original Code:
```
static void r600_vce_get_buffer(struct pipe_resource *resource,
				struct pb_buffer **handle,
				struct radeon_surf **surface)
{
	struct r600_texture *res = (struct r600_texture *)resource;

	if (handle)
		*handle = res->resource.buf;

	if (surface)
		*surface = &res->surface;
}
```


Overlapping Code:
```
 r600_vce_get_buffer(struct pipe_resource *resource,
struct pb_buffer **handle,
struct radeon_surf **surface)
{
struct r600_texture *res = (struct r600_texture *)resource;
if (handle)
*handle = res->resource.buf
```
<Overlap Ratio: 0.7992424242424242>

---

--- 221 --
Question ID: d346eea2a1567304e4cbde99d396206482ed54cd_1
Original Code:
```
static void timer_load(void) {
	FILE* f = fopen(ctx->get_datafile(), "r");

	struct timer t = {};
	intmax_t expiry;
	time_t now = time(0);

	int fck = 0;
	while((fck = fscanf(f, "%ms %ms %" SCNiMAX " %m[^\n]", &t.chan, &t.id, &expiry, &t.msg)) >= 3) {
		if(expiry <= now) {
			timer_free(&t);
		} else {
			t.expiry = expiry;
			sb_push(timers, t);
		}
	}

	fclose(f);
}
```


Overlapping Code:
```
c void timer_load(void) {
FILE* f = fopen(ctx->get_datafile(), "r");
struct timer t = {};
intmax_t expiry;
time_t now = time(0);
int fck = 0;
while((fck = fscanf(f, "%ms %ms %" SCNiMAX " %m[^\n]", &t.chan, &t.id, &expiry, &t.msg)) >= 3) {
if(expiry <= now) {
timer_free(&t);
} else {
t.expiry = expir
```
<Overlap Ratio: 0.872093023255814>

---

--- 222 --
Question ID: 9d09e9fd8e182edece0445d7c990b708588ae400_5
Original Code:
```
void CARDvUpdateBasicTopRate(void *pDeviceHandler)
{
PSDevice    pDevice = (PSDevice) pDeviceHandler;
BYTE byTopOFDM = RATE_24M, byTopCCK = RATE_1M;
BYTE ii;

     //Determines the highest basic rate.
     for (ii = RATE_54M; ii >= RATE_6M; ii --) {
         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {
             byTopOFDM = ii;
             break;
         }
     }
     pDevice->byTopOFDMBasicRate = byTopOFDM;

     for (ii = RATE_11M;; ii --) {
         if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {
             byTopCCK = ii;
             break;
         }
         if (ii == RATE_1M)
            break;
     }
     pDevice->byTopCCKBasicRate = byTopCCK;
 }
```


Overlapping Code:
```
CARDvUpdateBasicTopRate(void *pDeviceHandler)
{
PSDevice pDevice = (PSDevice) pDeviceHandler;
BYTE byTopOFDM = RATE_24M, byTopCCK = RATE_1M;
BYTE ii;
//Determines the highest basic rate.
for (ii = RATE_54M; ii >= RATE_6M; ii --) {
if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {
byTopOFDM = ii;
break;
}
}
pDevice->byTopOFDMBasicRate = byTopOFDM;
for (ii = RATE_11M;; ii --) {
if ( (pDevice->wBasicRate) & ((WORD)(1<<ii)) ) {
byTopCCK = ii;
break;
}
if (ii == RATE_1M)
break;
}
pDevice->byTopCCKBasicRate = byTopC
```
<Overlap Ratio: 0.9809160305343512>

---

--- 223 --
Question ID: 383e283121a0a4d5bbe7628a169f96677366e245_4
Original Code:
```
int
tr_dhtInit (tr_session *ss)
{
    tr_variant benc;
    int rc;
    bool have_id = false;
    char * dat_file;
    uint8_t * nodes = NULL, * nodes6 = NULL;
    const uint8_t * raw;
    size_t len, len6;
    struct bootstrap_closure * cl;

    if (session) /* already initialized */
        return -1;

    tr_logAddNamedDbg ("DHT", "Initializing DHT");

    if (tr_env_key_exists ("TR_DHT_VERBOSE"))
        dht_debug = stderr;

    dat_file = tr_buildPath (ss->configDir, "dht.dat", NULL);
    rc = tr_variantFromFile (&benc, TR_VARIANT_FMT_BENC, dat_file, NULL) ? 0 : -1;
    tr_free (dat_file);
    if (rc == 0) {
        have_id = tr_variantDictFindRaw (&benc, TR_KEY_id, &raw, &len);
        if (have_id && len==20)
            memcpy (myid, raw, len);
        if (ss->udp_socket != TR_BAD_SOCKET &&
            tr_variantDictFindRaw (&benc, TR_KEY_nodes, &raw, &len) && ! (len%6)) {
                nodes = tr_memdup (raw, len);
        }
        if (ss->udp6_socket != TR_BAD_SOCKET &&
            tr_variantDictFindRaw (&benc, TR_KEY_nodes6, &raw, &len6) && ! (len6%18)) {
            nodes6 = tr_memdup (raw, len6);
        }
        tr_variantFree (&benc);
    }

    if (nodes == NULL)
        len = 0;
    if (nodes6 == NULL)
        len6 = 0;

    if (have_id)
        tr_logAddNamedInfo ("DHT", "Reusing old id");
    else {
        /* Note that DHT ids need to be distributed uniformly,
         * so it should be something truly random. */
        tr_logAddNamedInfo ("DHT", "Generating new id");
        tr_rand_buffer (myid, 20);
    }

    rc = dht_init (ss->udp_socket, ss->udp6_socket, myid, NULL);
    if (rc < 0)
        goto fail;

    session = ss;

    cl = tr_new (struct bootstrap_closure, 1);
    cl->session = session;
    cl->nodes = nodes;
    cl->nodes6 = nodes6;
    cl->len = len;
    cl->len6 = len6;
    tr_threadNew (dht_bootstrap, cl);

    dht_timer = evtimer_new (session->event_base, timer_callback, session);
    tr_timerAdd (dht_timer, 0, tr_rand_int_weak (1000000));

    tr_logAddNamedDbg ("DHT", "DHT initialized");

    return 1;

 fail:
    tr_logAddNamedDbg ("DHT", "DHT initialization failed (errno = %d)", errno);
    session = NULL;
    return -1;
}
```


Overlapping Code:
```
t benc;
int rc;
bool have_id = false;
char * dat_file;
uint8_t * nodes = NULL, * nodes6 = NULL;
const uint8_t * raw;
size_t len, len6;
struct bootstrap_closure * cl;
if (session) /* already initialized */
return -1;
tr_logAddNamedDbg ("DHT", "Initializing DHT");
if (tr_env_key_exists ("TR_DHT_VERBOSE"))
dht_debug = stderr;
dat_file = tr_buildPath (ss->configDir, "dht.dat", NULL);
rc = tr_variantFromFile (&benc, TR_VARIANT_FMT_BENC, dat_file, NULL) ? 0 : -1;
tr_free (dat_file);
if (rc == 0) {
have_id = tr_variantDictFindRaw (&benc, TR_KEY_id, &raw, &len);
if (have_id && len==20)
memcpy (myid, raw, len);
if (ss->udp_socket != TR_BAD_SOCKET &&
tr_variantDictFindRaw (&benc, TR_KEY_nodes, &raw, &len) && ! (len%6)) {
nodes = tr_memdup (raw, len);
}
if (ss->udp6_socket != TR_BAD_SOCKET &&
tr_variantDictFindRaw (&benc, TR_KEY_nodes6, &raw, &len6) && ! (len6%18)) {
nodes6 = tr_memdup (raw, len6);
}
tr_variantFree (&benc);
}
if (nodes == NULL)
len = 0;
if (nodes6 == NULL)
len6 = 0;
if (have_id)
tr_logAddNamedInfo ("DHT", "Reusing old id");
else {
/* Note that DHT ids need to be distributed uniformly,
* so it should be something truly random. */
tr_logAddNamedInfo ("DHT", "Generating new id");
tr_rand_buffer (myid, 20);
}
rc = dht_init (ss->udp_socket, ss->udp6_socket, myid, NULL);
if (rc < 0)
goto fail;
session = ss;
cl = tr_new (struct bootstrap_closure, 1);
cl->session = session;
cl->nodes = nodes;
cl->nodes6 = nodes6;
cl->len = len;
cl->len6 = len6;
tr_threadNew (dht_bootstrap, cl);
dht_timer = evtimer_new (session->event_base, timer_callback, session);
tr_timerAdd (dht_timer, 0, tr_rand_int_weak (1000000));
tr_logAddNamedDbg ("DHT", "DHT initialized");
return 1;
fail:
tr_logAddNamedDbg ("DHT", "DHT initialization failed (errno
```
<Overlap Ratio: 0.9521218715995647>

---

--- 224 --
Question ID: 97fbab78f01e25d53e03944d258948154eb55da1_0
Original Code:
```
int zpicscale(sbuf,data,mp,mptype,sclat,sclon,nl,ns,pbuf,line,samp)
double *sbuf;		/* input SPICE buffer */
float  *data;           /* input 40-word geometry buffer for PPROJ call */
MP      mp;		/* Pointer to map projection data */
int     mptype;         /* Map projection type */
double  sclat,sclon;	/* spacecraft latitude/longitude */
int     nl,ns;		/* size of input image */
float  *pbuf;		/* output buffer */
double *line,*samp;	/* output coordinates at which scale applies */
{

   double  fl,oal,oas,scale;
   float  srange;
   double scrange,sunrange;	/* spacecraft and sun range from targ center */
   double vsc[3],vsun[3];	/* spacecraft and solar vectors */
   double om[3][3];		/* tranformation from target to camera coords */
   double ra,rb,rc;	/* radii for triaxial ellipse */
   double re,rp;	/* equatorial and polar radius */
   double pcl,pcs;	/* line,rsamp of planet center */
   double rnl,rns;	/* number of lines and samples in image */
   double rsamp,rline;
   double rlat,rlon,rlat2,rlon2;
   double p[3],na,noraz,sunaz,scaz,sunlat,sunlon;
   double hscale,vscale,hscale_pc,vscale_pc;
   double lora;		/* longitude of semi-major axis (unknown) */
   double gcr;		/* geocentric radius */
   double x,y,z,d;
   int    inc,ind,ind1,ind2,ind3,ind4;
   int    ibeg,iend,i,use_pc;
   char   projection[mpMAX_KEYWD_LENGTH];
   char   direction[mpMAX_KEYWD_LENGTH];
	   /*  INITIALIZE VARIABLES */
   for (i=0; i<6; i++) *(pbuf+i) = -999.0; 
   hscale = 1.0e+20;		/* initialize as invalid scale */
   vscale = 1.0e+20;
   rnl = (double) nl; 
   rns = (double) ns; 

   if (mptype!=7 && mptype!=8) {
      ind = mpGetValues(mp,"MAP_PROJECTION_TYPE",projection,"");   
      if (strncmp(projection,"POINT_PERSPECTIVE",17)==0) {
         mptype = 16;
         mpMpo2Buf(mp,data);
         sclat = data[30];
         sclon = data[31];
      }
   }
	/* If image is map projected, compute scale at center of image */
   if (mptype != 7 && mptype != 8 && mptype != 16) {
      ind = mpGetValues(mp,"A_AXIS_RADIUS",&ra,"");   
      if (ind != mpSUCCESS) goto ERROR1;
      ind = mpGetValues(mp,"B_AXIS_RADIUS",&rb,"");   
      if (ind != mpSUCCESS) goto ERROR1;
      ind = mpGetValues(mp,"C_AXIS_RADIUS",&rc,"");   
      if (ind != mpSUCCESS) goto ERROR1;
      ind = mpGetValues(mp,"POSITIVE_LONGITUDE_DIRECTION",direction,"");
      *line = (double) nl/2.0;		/* line,samp at center of image */
      *samp = (double) ns/2.0;
      rline = (double) *line; 
      rsamp = (double) *samp;
      ind = mpxy2ll(mp,rline,rsamp,&rlat,&rlon,1);
      if (ind != mpSUCCESS) goto ERROR2;
      if (strncmp(direction,"WEST",4)==0) rlon=360.-rlon;
      ind = mpxy2ll(mp,rline,rsamp+1.0,&rlat2,&rlon2,1);
      if (ind == mpSUCCESS) {
         if (strncmp(direction,"WEST",4)==0) rlon2=360.-rlon2;
         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&hscale);
         pbuf[0] = (float) hscale;
      }
      ind = mpxy2ll(mp,rline+1.0,rsamp,&rlat2,&rlon2,1);
      if (ind == mpSUCCESS) {
         if (strncmp(direction,"WEST",4)==0) rlon2=360.-rlon2;
         picscal3(rlat,rlon,rlat2,rlon2,ra,rb,rc,&vscale);
         pbuf[1]=(float) vscale;
      }
      return ind;
   }

/* Here if mptype=7, 8, or 16 (image or object space).  Geometric camera
   distortions will be ignored (image is treated as object-space frame). */

   zmve(8,9,(sbuf+58),om,1,1);
   zmve(8,3,(sbuf+21),vsc,1,1);
   ra = *(sbuf+12);
   rb = *(sbuf+13);
   rc = *(sbuf+14);
   fl = data[26];
   oal = data[27];
   oas = data[28];
   scale = data[29];
   re = (double) data[25];		/* equitorial radius (km) */
   rp = (double) data[24];		/* polar radius */
	/* See if all four corners are on the target body... */
   ind1 = psxy2ll(data,1.,1.,&rlat,&rlon,&srange);  /* upper left corner */
   ind2 = psxy2ll(data,1.,rns,&rlat,&rlon,&srange); /* upper right corner */
   ind3 = psxy2ll(data,rnl,1.,&rlat,&rlon,&srange); /* lower left corner */
   ind4 = psxy2ll(data,rnl,rns,&rlat,&rlon,&srange);/* lower right corner */
   use_pc = 0; 
	/* If all 4 corners are on planet, image is high-resolution */
	/* compute scale at center of image */
   if (ind1==1 && ind2==1 && ind3==1 && ind4==1) { 
      *line = (double) nl/2.0;		/* line,samp at center of image */
      *samp = (double) ns/2.0;
      rline = (double) *line; 
      rsamp = (double) *samp;
      ind1 = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);
      ind2 = psxy2ll(data,rline,rsamp+1.,&rlat2,&rlon2,&srange);
      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&hscale); 
      ind3 = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange);
      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); 
      goto COMPUTE_AZIMUTHS;
   }
	/* Here if 4 corners not on planet (low-resolution image */
	/* Calculate scale at planet center */
   ind = psll2xy(data,sclat,sclon,&pcl,&pcs);
   if (ind != 1) return ind;
   ind = psxy2ll(data,pcl,pcs+0.1,&rlat2,&rlon2,&srange);
   if (ind != 1) return ind;
   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&hscale_pc);	/* horizontal scale */
   hscale_pc*=10.0; /* To accomodate for pcl+0.1 */
   ind = psxy2ll(data,pcl+0.1,pcs,&rlat2,&rlon2,&srange);
   if (ind != 1) return ind;
   picscal2(sclat,sclon,rlat2,rlon2,re,rp,&vscale_pc); 	/* vertical scale */
   vscale_pc*=10.0; /* To accomodate for pcl+0.1 */
   use_pc = 1;
	/* If PC is in the image, use scale at PC */
   if (pcl>0 && pcs>0 && pcl<=rnl && pcs<rns) goto COMPUTE_AZIMUTHS;
	/* If the target is smaller than the width of image, use scale at PC */
   if (1000.*re/hscale > rnl) goto COMPUTE_AZIMUTHS;

	/* Search margin of image for point on planet with the
	   largest scale */
   inc = 20;			/* margin search increment is 20 pixels */
   if (pcl < pcs) {		/* top or right margin */
      if (pcl < rns-pcs) {	/* top margin */
         *line = 1; 
         if (pcs < 1.0) {	/* top-left corner */
            ibeg = 1; 
            iend = 1; 
         } 
         else if (pcs > rns) {  /* top-right corner */
            ibeg = ns; 
            iend = ns; 
         } 
         else {			/* entire top margin */
            ibeg = 1; 
            iend = ns; 
         } 
             /* Search for smallest scale along margin */
         rline = 1.0;
         for (i=ibeg; i<=iend; i+=inc) { 
             rsamp = (double) i; 
             ind = picscal1(data,rline,rsamp,re,rp,&hscale);
             if (ind == 1) *samp = i;
         } 
      }

      else {			/* Right margin */
         *samp = ns;
         if (pcl < 1.0) {	/* top-right corner */
            ibeg = 1; 
            iend = 1; 
         } 
         else if (pcl > rnl) {	/* bottom-right corner */
            ibeg = nl; 
            iend = nl; 
         } 
         else { 		/* entire right margin */
            ibeg = 1; 
            iend = nl; 
         } 

            /* Search for smallest scale along margin */
         rsamp = rns;
         for (i=ibeg; i<=iend; i+=inc) { 
            rline = (double) i; 
            ind = picscal1(data,rline,rsamp,re,rp,&hscale);
            if (ind == 1) *line = i;
         } 
      } 
   }

   else {                     /* left or bottom margins */
       if (pcs < rnl-pcl) {   /* left margin */
          *samp = 1; 
          if (pcl < 1.0) {        /* top-left corner */
             ibeg = 1; 
             iend = 1; 
          }
          else if (pcl > rnl) {    /* bottom-left corner */
             ibeg = nl; 
             iend = nl; 
          }
          else { 
             ibeg = 1; 
             iend = nl; 
          } 
                    /* search for smallest scale along margin */
          rsamp = 1.0;
          for (i=ibeg; i<=iend; i+=inc) { 
             rline = (double) i; 
             ind = picscal1(data,rline,rsamp,re,rp,&hscale);
             if (ind == 1) *line = i; 
          } 
       }
       else { 
           *line = nl; 
           if (pcs < 1.0) {         /* bottom-left corner */
              ibeg = 1; 
              iend = 1; 
           } 
           else if (pcs > rns) {  /* bottom-right corner */
               ibeg = ns; 
               iend = ns; 
           } 
           else { 
               ibeg = 1; 
               iend = ns; 
           } 

                   /* search for smallest scale along margin */
           rline = rnl;
           for (i=ibeg; i<=iend; i+=inc) { 
              rsamp =(double) i; 
              ind = picscal1(data,rline,rsamp,re,rp,&hscale);
              if(ind == 1) *samp = i;
           } 
        } 
     } 

   if (hscale < 1.0e+20) {
      rline = (double) *line; 
      rsamp = (double) *samp; 
      ind = psxy2ll(data,rline,rsamp,&rlat,&rlon,&srange);
      if (ind != 1) return ind;
      ind = psxy2ll(data,rline+1.,rsamp,&rlat2,&rlon2,&srange); 
      if (ind != 1) return ind;
      picscal2(rlat,rlon,rlat2,rlon2,re,rp,&vscale); 
      use_pc = 0;
   }

COMPUTE_AZIMUTHS:
   if (use_pc==1) {
      *line = pcl; 
      *samp = pcs; 
      hscale = hscale_pc;
      vscale = vscale_pc;
      zvmessage("Picture scale calculated at target center","");
   }
   *(pbuf+0) = (float) hscale;	/* horizontal scale in meters/pixel */
   *(pbuf+1) = (float) vscale;  /* vertical scale in meters/pixel */

	/* Compute north angle */
   na = atan2(om[2][1],om[2][0])*zdpr();
   if (na < 0.) na=na+360.;
   *(pbuf+2) =(float) na;

	/* Compute vector to surface point */
   rline = *line;
   rsamp = *samp;
   if (use_pc==1) {
      rline = pcl; 
      rsamp = pcs; 
   }
   ind = zellipse_inv(om,vsc,fl,oal,oas,scale,ra,rb,rc,rline,rsamp,p);

	/* Compute solar vector */
   sunrange = *(sbuf+24);		/* sun distance to target center */
   sunlat = *(sbuf+27)*zrpd();		/* Subsolar geocentric latitude */
   sunlon = (360.0 - *(sbuf+28))*zrpd(); /* Subsolar east longitude */
   vsun[0] = sunrange*cos(sunlat)*cos(sunlon);
   vsun[1] = sunrange*cos(sunlat)*sin(sunlon);
   vsun[2] = sunrange*sin(sunlat);

   zazimuth(om,p,vsc,vsun,ra,rb,rc,use_pc,&noraz,&scaz,&sunaz);
   *(pbuf+3) = (float) sunaz;
   *(pbuf+4) = (float) scaz;
   *(pbuf+5) = srange;
   *(pbuf+6) =(float) noraz;

	/* Compute lat,lon at surface point */
   x = p[0];
   y = p[1];
   z = p[2];
   d = sqrt(x*x + y*y);
   rlat = atan2(z,d)*zdpr();
   rlon = - atan2(y,x)*zdpr();
   if (rlon < 0.) rlon=rlon+360.;
   *(pbuf+7) = (float) rlat;
   *(pbuf+8) = (float) rlon;
   return ind;

ERROR1:
   zvmessage("***Error calling mpGetValues","PICSCALE");
   return ind;   

ERROR2:
   zvmessage("***Error calling mpxy2ll","PICSCALE");
   return ind;
}
```


Overlapping Code:
```
ype,sclat,sclon,nl,ns,pbuf,line,samp)
double *sbuf; /* input SPICE buffer */
float *data; /* input 40-word geometry buffer for PPROJ call */
MP mp; /* Pointer to map projection data */
int mptype; /* Map projection type */
double sclat,sclon; /* spacecraft latitude/longitude */
int nl,ns; /* size of input image */
float *pbuf; /* output buffer */
double *line,*samp; /* output coordinates at which scale applies */
{
double fl,oal,oas,scale;
float srange;
double scrange,sunrange; /* spacecraft and sun range from targ center */
double vsc[3],vsun[3]; /* spacecraft and solar vectors */
double om[3][3]; /* tranformation from target to camera coords */
double ra,rb,rc; /* radii for triaxial ellipse */
double re,rp; /* equatorial and polar radius */
double pcl,pcs; /* line,rsamp of planet center */
double rnl,rns; /* number of lines and samples in image */
double rsamp,rline;
double rlat,rlon,rlat2,rlon2;
double p[3],na,noraz,sunaz,scaz,sunlat,sunlon;
double hscale,vscale,hscale_pc,vscale_pc;
double lora; /* longitude of semi-major axis (unknown) */
double gcr; /* geocentric radius */
double x,y,z,d;
int inc,ind,ind1,ind2,ind3,ind4;
int ibeg,iend,i,use_pc;
char projection[mpMAX_KEYWD_LENGTH];
char direction[mpMAX_KEYWD_LENGTH];
/* INITIALIZE VARIABLES */
for (i=0; i<6; i++) *(pbuf+i) = -999.0; 
hscale = 1.0e+20; /* initialize as invalid scale */
vscale = 1.0e+20;
rnl = (double) nl; 
rns = (double) ns; 
if (mptype!=7 && mptype!=8) {
ind = mpGetValues(mp,"MAP_PROJECTION_TYPE",projection,""); 
if (strncmp(projection,"POINT_PERSPECTIVE",17)==0) {
mptype = 16;
mpMpo2Buf(mp,data);
sclat = data[30];
sclon = data[31];
}
}
/* If image is map projected, compute scale at center of image */
if (mptype != 7 && mptype != 8 && mptype != 16) {
ind = mpGetValues(mp,"A_AXIS_RADIUS",&ra,""); 
if (ind != mpSUCCESS) goto ERROR1;
ind = mpGetValues(mp,"B_AXIS_RADIUS",&rb,""); 
if (ind != mpSUCCESS) goto ERROR1;
ind = mpGetValues(mp,"C_AXIS_RADIUS",&rc,""); 
if (ind != mpSUCCESS) goto ERROR1;
ind = mpGetValues(mp,"POSITIVE_LONGITUDE_DIRECTION",direction,"");
*line = (double) nl/2.0; /* line,samp at center of image */
*samp = (double) ns/2.0;
rline = (double) *line; 
rsamp =
```
<Overlap Ratio: 0.9806654676258992>

---

--- 225 --
Question ID: 9915603ed10babaeac41daefa89ed1479b0b3faf_13
Original Code:
```
static void ipa_shutdown(struct platform_device *pdev)
{
	int ret;

	ret = ipa_remove(pdev);
	if (ret)
		dev_err(&pdev->dev, "shutdown: remove returned %d\n", ret);
}
```


Overlapping Code:
```
hutdown(struct platform_device *pdev)
{
int ret;
ret = ipa_remove(pdev);
if (ret)
dev_err(&pdev->dev, "shutdown: remove returned 
```
<Overlap Ratio: 0.80625>

---

--- 226 --
Question ID: cfc6cb9e42715caf453e6d578171494a783ad3c9_4
Original Code:
```
static int SCPreallocMessage(SCMessageQueue *mq, uint32_t length, SCMsgHdr **hdr_ptr, uint8_t **msg_ptr, void **msg_handle)
{
    int rval;

    pthread_mutex_lock(&mq->mutex);
    rval = RBMQ_ReserveMsg(mq->queue, length, (void **) hdr_ptr, msg_ptr, msg_handle);
    pthread_mutex_unlock(&mq->mutex);

    return rval;
}
```


Overlapping Code:
```
SCMessageQueue *mq, uint32_t length, SCMsgHdr **hdr_ptr, uint8_t **msg_ptr, void **msg_handle)
{
int rval;
pthread_mutex_lock(&mq->mutex);
rval = RBMQ_ReserveMsg(mq->queue, length, (void **) hdr_ptr, msg_ptr, msg_handle);
pthread_mutex_unlock(&mq->mutex);
return
```
<Overlap Ratio: 0.8762541806020067>

---

--- 227 --
Question ID: c0024a474648ca8c0d9e73d4675da9c6de8d9796_2
Original Code:
```
int tc_overflow_v(struct ut_suite *suite, struct ut_tcase *tcase)
{
    for (size_t i = ARRAY_SIZE(test_out1) - 1; i >= ARRAY_SIZE(out1); i--) {
        ut_assert_msg(test_out1[i] == CANARY,
                      "p_xcorr_f32() Test 1: Output buffer overflow. Canary overwritten. Last index: %d\n",
                      (unsigned int) i);
    }

    for (size_t i = ARRAY_SIZE(test_out2) - 1; i >= ARRAY_SIZE(out2); i--) {
        ut_assert_msg(test_out2[i] == CANARY,
                      "p_xcorr_f32() Test 2: Output buffer overflow. Canary overwritten. Last index: %d\n",
                      (unsigned int) i);
    }

    return 0;
}
```


Overlapping Code:
```
_v(struct ut_suite *suite, struct ut_tcase *tcase)
{
for (size_t i = ARRAY_SIZE(test_out1) - 1; i >= ARRAY_SIZE(out1); i--) {
ut_assert_msg(test_out1[i] == CANARY,
"p_xcorr_f32() Test 1: Output buffer overflow. Canary overwritten. Last index: %d\n",
(unsigned int) i);
}
for (size_t i = ARRAY_SIZE(test_out2) - 1; i >= ARRAY_SIZE(out2); i--) {
ut_assert_msg(test_out2[i] == CANARY,
"p_xcorr_f32() Test 2: Output buffer overflow. Canary overwritten. Last index: %d\n",
(unsigned int) i);
```
<Overlap Ratio: 0.9436893203883495>

---

--- 228 --
Question ID: 6f5eb3f69598643f7c3f92d3ab4ebf0efe9a57bd_8
Original Code:
```
BOOTLOADER_SECTION void
submit_request_new() {

  uint8_t sreg;
  sreg = SREG;
  cli();
  uint8_t key[32];
  load_key(key);
  char *DEFAULT_URL = "http://localhost:8008";
  submit_checkRequest("testID", key, DEFAULT_URL);
  SREG = sreg;
}
```


Overlapping Code:
```
w() {
uint8_t sreg;
sreg = SREG;
cli();
uint8_t key[32];
load_key(key);
char *DEFAULT_URL = "http://localhost:8008";
submit_checkRequest("testID", key
```
<Overlap Ratio: 0.6787330316742082>

---

--- 229 --
Question ID: b0ea68767e5829ac2c890a445204664cf46e333f_23
Original Code:
```
INLINE static void
calc_phase (OPLL_SLOT * slot, e_int32 lfo)
{
  if (slot->patch->PM)
    slot->phase += (slot->dphase * lfo) >> PM_AMP_BITS;
  else
    slot->phase += slot->dphase;

  slot->phase &= (DP_WIDTH - 1);

  slot->pgout = HIGHBITS (slot->phase, DP_BASE_BITS);
}
```


Overlapping Code:
```
INE static void
calc_phase (OPLL_SLOT * slot, e_int32 lfo)
{
if (slot->patch->PM)
slot->phase += (slot->dphase * lfo) >> PM_AMP_BITS;
else
slot->phase += slot->dphase;
slot->phase &= (DP_WIDTH - 1);
slot->pgout = HIGHBITS (slot->phase, DP_BASE_BITS);

```
<Overlap Ratio: 0.984313725490196>

---

--- 230 --
Question ID: 149cf3c2abe4f09ef9e258d34cca68c8b05a47ba_2
Original Code:
```
static void NandWriteAddress5B(void)
	{
		FLASH_ALE = 1;			// Address latch enable
	    NandWriteRaw(0);HSPSPWait(); 	// Only write zeros
	    NandWriteRaw(0);HSPSPWait(); 	// to these two bytes
	    NandWriteRaw(AddBytes[0]);HSPSPWait(); //  The next 3 bytes
	    NandWriteRaw(AddBytes[1]);HSPSPWait();//	are the page and
	    NandWriteRaw(AddBytes[2]);			//	block addresses
		FLASH_ALE = 0;			// Address latch disable
		return;
	}
```


Overlapping Code:
```
d)
{
FLASH_ALE = 1; // Address latch enable
NandWriteRaw(0);HSPSPWait(); // Only write zeros
NandWriteRaw(0);HSPSPWait(); // to these two bytes
NandWriteRaw(AddBytes[0]);HSPSPWait(); // The next 3 bytes
NandWriteRaw(AddBytes[1]);HSPSPWait();// are the page and
NandWriteRaw(AddBytes[2]); // block addresses
FLASH_ALE = 0; // Address latch disable
return;
}
```
<Overlap Ratio: 0.9128205128205128>

---

--- 231 --
Question ID: 9affd652287053c3b3b31a5178199d3cb973e52e_22
Original Code:
```
static struct segment *
gsc_getentry(struct gen_sc *gsc, double x)
{
	struct segment	*new, *prev, *s;

	prev = NULL;
	LIST_FOREACH(s, gsc, _next) {
		if (s->x == x)
			return (s);	/* matching entry found */
		else if (s->x < x)
			prev = s;
		else
			break;
	}

	/* we have to create a new entry */
	if ((new = calloc(1, sizeof(struct segment))) == NULL)
		return (NULL);

	new->x = x;
	if (x == INFINITY || s == NULL)
		new->d = 0;
	else if (s->x == INFINITY)
		new->d = INFINITY;
	else
		new->d = s->x - x;
	if (prev == NULL) {
		/* insert the new entry at the head of the list */
		new->y = 0;
		new->m = 0;
		LIST_INSERT_HEAD(gsc, new, _next);
	} else {
		/*
		 * the start point intersects with the segment pointed by
		 * prev.  divide prev into 2 segments
		 */
		if (x == INFINITY) {
			prev->d = INFINITY;
			if (prev->m == 0)
				new->y = prev->y;
			else
				new->y = INFINITY;
		} else {
			prev->d = x - prev->x;
			new->y = prev->d * prev->m + prev->y;
		}
		new->m = prev->m;
		LIST_INSERT_AFTER(prev, new, _next);
	}
	return (new);
}
```


Overlapping Code:
```
truct segment *
gsc_getentry(struct gen_sc *gsc, double x)
{
struct segment *new, *prev, *s;
prev = NULL;
LIST_FOREACH(s, gsc, _next) {
if (s->x == x)
return (s); /* matching entry found */
else if (s->x < x)
prev = s;
else
break;
}
/* we have to create a new entry */
if ((new = calloc(1, sizeof(struct segment))) == NULL)
return (NULL);
new->x = x;
if (x == INFINITY || s == NULL)
new->d = 0;
else if (s->x == INFINITY)
new->d = INFINITY;
else
new->d = s->x - x;
if (prev == NULL) {
/* insert the new entry at the head of the list */
new->y = 0;
new->m = 0;
LIST_INSERT_HEAD(gsc, new, _next);
} else {
/*
* the start point intersects with the segment pointed by
* prev. divide prev into 2 segments
*/
if (x == INFINITY) {
prev->d = INFINITY;
if (prev->m == 0)
new->y = prev->y;
else
new->y = INFINITY;
} else {
prev->d = x - prev->x;
new->y = prev->d * prev->m + prev->y;
}
new->m = prev->m;
LIST_INSERT_AFTER
```
<Overlap Ratio: 0.952928870292887>

---

--- 232 --
Question ID: 824d1f91334573edc0dfc8285409900603e09a3e_3
Original Code:
```
void close(file_t *file)
{
    free(file->name);
    free(file->content);
    free(file);
}
```


Overlapping Code:
```
e)
{
free(file->name);
free(file->content);
free(f
```
<Overlap Ratio: 0.6329113924050633>

---

--- 233 --
Question ID: c0d9c9bd97eb3fa5a324959b98747680fc9c9294_202
Original Code:
```
static void test_pack_URL_COMPONENTSA(void)
{
    /* URL_COMPONENTSA */
    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwStructSize, 4)
    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwStructSize, 4)
    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwStructSize, 0)
    TEST_FIELD_SIZE  (URL_COMPONENTSA, lpszScheme, 4)
    TEST_FIELD_ALIGN (URL_COMPONENTSA, lpszScheme, 4)
    TEST_FIELD_OFFSET(URL_COMPONENTSA, lpszScheme, 4)
    TEST_FIELD_SIZE  (URL_COMPONENTSA, dwSchemeLength, 4)
    TEST_FIELD_ALIGN (URL_COMPONENTSA, dwSchemeLength, 4)
    TEST_FIELD_OFFSET(URL_COMPONENTSA, dwSchemeLength, 8)
}
```


Overlapping Code:
```
TSA(void)
{
/* URL_COMPONENTSA */
TEST_FIELD_SIZE (URL_COMPONENTSA, dwStructSize, 4)
TEST_FIELD_ALIGN (URL_COMPONENTSA, dwStructSize, 4)
TEST_FIELD_OFFSET(URL_COMPONENTSA, dwStructSize, 0)
TEST_FIELD_SIZE (URL_COMPONENTSA, lpszScheme, 4)
TEST_FIELD_ALIGN (URL_COMPONENTSA, lpszScheme, 4)
TEST_FIELD_OFFSET(URL_COMPONENTSA, lpszScheme, 4)
TEST_FIELD_SIZE (URL_COMPONENTSA, dwSchemeLength, 4)
TEST_FIELD_ALIGN (URL_COMPONENTSA, dwSchemeLength, 4)
TEST_FIELD_OFFSET(URL_COMPONENTSA, dwSchemeLength, 8)
}
```
<Overlap Ratio: 0.9363295880149812>

---

--- 234 --
Question ID: 84398799ebc5e1ae4b1a951459f3e627929aa94c_0
Original Code:
```
class CBreakShipController: public CShipController {

    public:
        CBreakShipController( CShip* ship );
        ~CBreakShipController();

        void run();

        bool done();

    private:
        bool mDone;

}
```


Overlapping Code:
```
ntroller {
public:
CBreakShipController( CShip* ship );
~CBreakShipController();
void run();
bool do
```
<Overlap Ratio: 0.5882352941176471>

---

--- 235 --
Question ID: 15f9b7c9e4d38e93a52864a953e12d4172602797_24
Original Code:
```
static int ntb_setup_bwd_msix(struct ntb_device *ndev, int msix_entries)
{
	struct pci_dev *pdev = ndev->pdev;
	struct msix_entry *msix;
	int rc, i;

	msix_entries = pci_enable_msix_range(pdev, ndev->msix_entries,
					     1, msix_entries);
	if (msix_entries < 0)
		return msix_entries;

	for (i = 0; i < msix_entries; i++) {
		msix = &ndev->msix_entries[i];
		WARN_ON(!msix->vector);

		rc = request_irq(msix->vector, bwd_callback_msix_irq, 0,
				 "ntb-callback-msix", &ndev->db_cb[i]);
		if (rc)
			goto err;
	}

	ndev->num_msix = msix_entries;
	ndev->max_cbs = msix_entries;

	return 0;

err:
	while (--i >= 0)
		free_irq(msix->vector, &ndev->db_cb[i]);

	pci_disable_msix(pdev);
	ndev->num_msix = 0;

	return rc;
}
```


Overlapping Code:
```
struct ntb_device *ndev, int msix_entries)
{
struct pci_dev *pdev = ndev->pdev;
struct msix_entry *msix;
int rc, i;
msix_entries = pci_enable_msix_range(pdev, ndev->msix_entries,
1, msix_entries);
if (msix_entries < 0)
return msix_entries;
for (i = 0; i < msix_entries; i++) {
msix = &ndev->msix_entries[i];
WARN_ON(!msix->vector);
rc = request_irq(msix->vector, bwd_callback_msix_irq, 0,
"ntb-callback-msix", &ndev->db_cb[i]);
if (rc)
goto err;
}
ndev->num_msix = msix_entries;
ndev->max_cbs = msix_entries;
return 0;
err:
while (--i >= 0)
free_irq(msix->vector, &ndev->db_cb[i]);
pci_disable_msix(pdev);
ndev->num_msix = 0;
return 
```
<Overlap Ratio: 0.9476047904191617>

---

--- 236 --
Question ID: 3ea9dec685a63b8aaa1d801248944203c00eacc1_264
Original Code:
```
uint64_t sys_name_to_handle_at(uint64_t dfd, uint64_t name, uint64_t handle,
                               uint64_t mnt_id, uint64_t flag) {
  /// TODO: entire syscall
  DEBUG("Call to stubbed syscall (name_to_handle_at)\n");
  return -1;
}
```


Overlapping Code:
```
64_t sys_name_to_handle_at(uint64_t dfd, uint64_t name, uint64_t handle,
uint64_t mnt_id, uint64_t flag) {
/// TODO: entire syscall
DEBUG("Call to stubbed syscall (name_to_handle_at)\n");
return -1;
}
```
<Overlap Ratio: 0.9803921568627451>

---

--- 237 --
Question ID: 7f3e3983b781d72af83b0fc47006b1a2ff34078c_14
Original Code:
```
static int mt7601u_submit_rx(struct mt7601u_dev *dev)
{
	int i, ret;

	for (i = 0; i < dev->rx_q.entries; i++) {
		ret = mt7601u_submit_rx_buf(dev, &dev->rx_q.e[i], GFP_KERNEL);
		if (ret)
			return ret;
	}

	return 0;
}
```


Overlapping Code:
```
mt7601u_submit_rx(struct mt7601u_dev *dev)
{
int i, ret;
for (i = 0; i < dev->rx_q.entries; i++) {
ret = mt7601u_submit_rx_buf(dev, &dev->rx_q.e[i], GFP_KERNEL);
if (ret)
return ret
```
<Overlap Ratio: 0.8743961352657005>

---

--- 238 --
Question ID: 68aecd43c1c7efbee3e56fd36af99e5168a2f403_5
Original Code:
```
void pf_autonomousadcs_attitudemodetargettrackinglinear_list_test(bool verbose)
{
  printf(" * list of pf_autonomousadcs_attitudemodetargettrackinglinear: ");
  if (verbose)
    printf("\n");
  printf("OK\n");
}
```


Overlapping Code:
```
void pf_autonomousadcs_attitudemodetargettrackinglinear_list_test(bool verbose)
{
printf(" * list of pf_autonomousadcs_attitudemodetargettrackinglinear: ");
if (verbose)
printf("\n");
printf("OK\n");
}
```
<Overlap Ratio: 1.0>

---

--- 239 --
Question ID: f071678d15eca065c3ace06d695fef19ac9cb468_0
Original Code:
```
int
main(int argc, char *argv[])
{
    LongBowRunner *testRunner = LONGBOW_TEST_RUNNER_CREATE(Example1);
    int status = longBowMain(argc, argv, testRunner, NULL);
    longBowTestRunner_Destroy(&testRunner);

    exit(status);
}
```


Overlapping Code:
```
int
main(int argc, char *argv[])
{
LongBowRunner *testRunner = LONGBOW_TEST_RUNNER_CREATE(Example1);
int status = longBowMain(argc, argv, testRunner, NULL);
longBowTestRunner_Destroy(&testRunner);
exit(status);

```
<Overlap Ratio: 0.9952830188679245>

---

--- 240 --
Question ID: 8f7fdc830ac7ae79486fcf4856c1a0e8324f4f68_0
Original Code:
```
void setup(void) {
   add_area(AREA);
   add_area(FAIRYLAND_AREA);
   set_light(1);
   set_short("On a path in Darkwood");
   set_long("You are on a twisty path in the legendary Darkwood. " +
            "You feel lucky to still be alive.");

   add_exit("north", FAIRYLAND_ROOMS + "/darkwood3.c");
   add_exit("south", FAIRYLAND_ROOMS + "/darkwood4.c");
   add_exit("east", FAIRYLAND_ROOMS + "/dw_path3.c");
   add_exit("west", FAIRYLAND_ROOMS + "/dw_path5.c");

   add_item("path", "The path is becoming more and more faint. Best hope you do not lose it.");
   add_item("darkwood", "The forest gets more evil now, and light is frequently blocked by the trees.");
}
```


Overlapping Code:
```
d setup(void) {
add_area(AREA);
add_area(FAIRYLAND_AREA);
set_light(1);
set_short("On a path in Darkwood");
set_long("You are on a twisty path in the legendary Darkwood. " +
"You feel lucky to still be alive.");
add_exit("north", FAIRYLAND_ROOMS + "/darkwood3.c");
add_exit("south", FAIRYLAND_ROOMS + "/darkwood4.c");
add_exit("east", FAIRYLAND_ROOMS + "/dw_path3.c");
add_exit("west", FAIRYLAND_ROOMS + "/dw_path5.c");
add_item("path", "The path is becoming more and more faint. Best hope you do not lose it.");
add_item("darkwood", "The forest gets more evil now, and light is frequently blocked by
```
<Overlap Ratio: 0.9693053311793215>

---

--- 241 --
Question ID: 82bd00af5cc3841ba6cd44ef51024b5792ba09b5_9
Original Code:
```
static int __init lart_flash_init (void)
{
   int result;
   memset (&mtd,0,sizeof (mtd));
   printk ("MTD driver for LART. Written by Abraham vd Merwe <abraham@2d3d.co.za>\n");
   printk ("%s: Probing for 28F160x3 flash on LART...\n",module_name);
   if (!flash_probe ())
	 {
		printk (KERN_WARNING "%s: Found no LART compatible flash device\n",module_name);
		return (-ENXIO);
	 }
   printk ("%s: This looks like a LART board to me.\n",module_name);
   mtd.name = module_name;
   mtd.type = MTD_NORFLASH;
   mtd.writesize = 1;
   mtd.writebufsize = 4;
   mtd.flags = MTD_CAP_NORFLASH;
   mtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;
   mtd.erasesize = FLASH_BLOCKSIZE_MAIN;
   mtd.numeraseregions = ARRAY_SIZE(erase_regions);
   mtd.eraseregions = erase_regions;
   mtd._erase = flash_erase;
   mtd._read = flash_read;
   mtd._write = flash_write;
   mtd.owner = THIS_MODULE;

#ifdef LART_DEBUG
   printk (KERN_DEBUG
		   "mtd.name = %s\n"
		   "mtd.size = 0x%.8x (%uM)\n"
		   "mtd.erasesize = 0x%.8x (%uK)\n"
		   "mtd.numeraseregions = %d\n",
		   mtd.name,
		   mtd.size,mtd.size / (1024*1024),
		   mtd.erasesize,mtd.erasesize / 1024,
		   mtd.numeraseregions);

   if (mtd.numeraseregions)
	 for (result = 0; result < mtd.numeraseregions; result++)
	   printk (KERN_DEBUG
			   "\n\n"
			   "mtd.eraseregions[%d].offset = 0x%.8x\n"
			   "mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
			   "mtd.eraseregions[%d].numblocks = %d\n",
			   result,mtd.eraseregions[result].offset,
			   result,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,
			   result,mtd.eraseregions[result].numblocks);

   printk ("\npartitions = %d\n", ARRAY_SIZE(lart_partitions));

   for (result = 0; result < ARRAY_SIZE(lart_partitions); result++)
	 printk (KERN_DEBUG
			 "\n\n"
			 "lart_partitions[%d].name = %s\n"
			 "lart_partitions[%d].offset = 0x%.8x\n"
			 "lart_partitions[%d].size = 0x%.8x (%uK)\n",
			 result,lart_partitions[result].name,
			 result,lart_partitions[result].offset,
			 result,lart_partitions[result].size,lart_partitions[result].size / 1024);
#endif

   result = mtd_device_register(&mtd, lart_partitions,
                                ARRAY_SIZE(lart_partitions));

   return (result);
}
```


Overlapping Code:
```
init lart_flash_init (void)
{
int result;
memset (&mtd,0,sizeof (mtd));
printk ("MTD driver for LARTobing for 28F160x3 flash on LART...\n",module_name);
if (!flash_probe ())
{
printk (KERN_WARNING "%s: Found no LART compatible flash device\n",module_name);
return (-ENXIO);
}
printk ("%s: This looks like a LART board to me.\n",module_name);
mtd.name = module_name;
mtd.type = MTD_NORFLASH;
mtd.writesize = 1;
mtd.writebufsize = 4;
mtd.flags = MTD_CAP_NORFLASH;
mtd.size = FLASH_BLOCKSIZE_PARAM * FLASH_NUMBLOCKS_16m_PARAM + FLASH_BLOCKSIZE_MAIN * FLASH_NUMBLOCKS_16m_MAIN;
mtd.erasesize = FLASH_BLOCKSIZE_MAIN;
mtd.numeraseregions = ARRAY_SIZE(erase_regions);
mtd.eraseregions = erase_regions;
mtd._erase = flash_erase;
mtd._read = flash_read;
mtd._write = flash_write;
mtd.owner = THIS_MODULE;
#ifdef LART_DEBUG
printk (KERN_DEBUG
"mtd.name = %s\n"
"mtd.size = 0x%.8x (%uM)\n"
"mtd.erasesize = 0x%.8x (%uK)\n"
"mtd.numeraseregions = %d\n",
mtd.name,
mtd.size,mtd.size / (1024*1024),
mtd.erasesize,mtd.erasesize / 1024,
mtd.numeraseregions);
if (mtd.numeraseregions)
for (result = 0; result < mtd.numeraseregions; result++)
printk (KERN_DEBUG
"\n\n"
"mtd.eraseregions[%d].offset = 0x%.8x\n"
"mtd.eraseregions[%d].erasesize = 0x%.8x (%uK)\n"
"mtd.eraseregions[%d].numblocks = %d\n",
result,mtd.eraseregions[result].offset,
result,mtd.eraseregions[result].erasesize,mtd.eraseregions[result].erasesize / 1024,
result,mtd.eraseregions[result].numblocks);
printk ("\npartitions = %d\n", ARRAY_SIZE(lart_partitions));
for (result = 0; result < ARRAY_SIZE(lart_partitions); result++)
printk (KERN_DEBUG
"\n\n"
"lart_partitions[%d].name = %s\n"
"lart_partitions[%d].offset = 0x%.8x\n"
"lart_partitions[%d].size = 0x%.8x (%uK)\n",
result,lart_partitions[result].name,
result,lart_partitions[result].offset,
result,lart_partitions[result].size,lart_partitions[result].size / 1024);
#endif
result = mtd_device_register(&mtd, lart_partitions,
ARRAY_SIZE(lart_pa
```
<Overlap Ratio: 0.9447674418604651>

---

--- 242 --
Question ID: d0c6ec75a3c719f64cb19f6a42cb91b2c7c2af34_5
Original Code:
```
static struct drm_framebuffer *vbox_user_framebuffer_create(
		struct drm_device *dev,
		struct drm_file *filp,
		const struct drm_mode_fb_cmd2 *mode_cmd)
{
	struct drm_gem_object *obj;
	struct vbox_framebuffer *vbox_fb;
	int ret = -ENOMEM;

	obj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);
	if (!obj)
		return ERR_PTR(-ENOENT);

	vbox_fb = kzalloc(sizeof(*vbox_fb), GFP_KERNEL);
	if (!vbox_fb)
		goto err_unref_obj;

	ret = vbox_framebuffer_init(dev, vbox_fb, mode_cmd, obj);
	if (ret)
		goto err_free_vbox_fb;

	return &vbox_fb->base;

err_free_vbox_fb:
	kfree(vbox_fb);
err_unref_obj:
	drm_gem_object_unreference_unlocked(obj);
	return ERR_PTR(ret);
}
```


Overlapping Code:
```
r *vbox_user_framebuffer_create(
struct drm_device *dev,
struct drm_file *filp,
const struct drm_mode_fb_cmd2 *mode_cmd)
{
struct drm_gem_object *obj;
struct vbox_framebuffer *vbox_fb;
int ret = -ENOMEM;
obj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);
if (!obj)
return ERR_PTR(-ENOENT);
vbox_fb = kzalloc(sizeof(*vbox_fb), GFP_KERNEL);
if (!vbox_fb)
goto err_unref_obj;
ret = vbox_framebuffer_init(dev, vbox_fb, mode_cmd, obj);
if (ret)
goto err_free_vbox_fb;
return &vbox_fb->base;
err_free_vbox_fb:
kfree(vbox_fb);
err_unref_obj:
drm_gem_object_unreference_unlocked(obj);
return ERR_PTR(ret);

```
<Overlap Ratio: 0.9541864139020537>

---

--- 243 --
Question ID: 0395e1bc12b6e28bb8931b2107eb5ca0b13881fe_0
Original Code:
```
int
unsetenv(const char* name)
{
  int r;
  char* p = malloc(strlen(name) + 2);
  if (!p) return -1;
  strcpy(p, name);
  strcat(p, "=");
  r = _putenv(p);
  free(p);
  return r;
}
```


Overlapping Code:
```

{
int r;
char* p = malloc(strlen(name) + 2);
if (!p) return -1;
strcpy(p, name);
strcat(p, "=");
r 
```
<Overlap Ratio: 0.6097560975609756>

---

--- 244 --
Question ID: 7f80c9713b0cf46eb43a46bb6cfe0b43fd79e8fb_9
Original Code:
```
static int bpf_object__elf_init(struct bpf_object *obj)
{
	int err = 0;
	GElf_Ehdr *ep;

	if (obj_elf_valid(obj)) {
		pr_warning("elf init: internal error\n");
		return -LIBBPF_ERRNO__LIBELF;
	}

	if (obj->efile.obj_buf_sz > 0) {
		/*
		 * obj_buf should have been validated by
		 * bpf_object__open_buffer().
		 */
		obj->efile.elf = elf_memory(obj->efile.obj_buf,
					    obj->efile.obj_buf_sz);
	} else {
		obj->efile.fd = open(obj->path, O_RDONLY);
		if (obj->efile.fd < 0) {
			char errmsg[STRERR_BUFSIZE], *cp;

			err = -errno;
			cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
			pr_warning("failed to open %s: %s\n", obj->path, cp);
			return err;
		}

		obj->efile.elf = elf_begin(obj->efile.fd,
					   LIBBPF_ELF_C_READ_MMAP, NULL);
	}

	if (!obj->efile.elf) {
		pr_warning("failed to open %s as ELF file\n", obj->path);
		err = -LIBBPF_ERRNO__LIBELF;
		goto errout;
	}

	if (!gelf_getehdr(obj->efile.elf, &obj->efile.ehdr)) {
		pr_warning("failed to get EHDR from %s\n", obj->path);
		err = -LIBBPF_ERRNO__FORMAT;
		goto errout;
	}
	ep = &obj->efile.ehdr;

	/* Old LLVM set e_machine to EM_NONE */
	if (ep->e_type != ET_REL ||
	    (ep->e_machine && ep->e_machine != EM_BPF)) {
		pr_warning("%s is not an eBPF object file\n", obj->path);
		err = -LIBBPF_ERRNO__FORMAT;
		goto errout;
	}

	return 0;
errout:
	bpf_object__elf_finish(obj);
	return err;
}
```


Overlapping Code:
```
_elf_init(struct bpf_object *obj)
{
int err = 0;
GElf_Ehdr *ep;
if (obj_elf_valid(obj)) {
pr_warning("elf init: internal error\n");
return -LIBBPF_ERRNO__LIBELF;
}
if (obj->efile.obj_buf_sz > 0) {
/*
* obj_buf should have been validated by
* bpf_object__open_buffer().
*/
obj->efile.elf = elf_memory(obj->efile.obj_buf,
obj->efile.obj_buf_sz);
} else {
obj->efile.fd = open(obj->path, O_RDONLY);
if (obj->efile.fd < 0) {
char errmsg[STRERR_BUFSIZE], *cp;
err = -errno;
cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
pr_warning("failed to open %s: %s\n", obj->path, cp);
return err;
}
obj->efile.elf = elf_begin(obj->efile.fd,
LIBBPF_ELF_C_READ_MMAP, NULL);
}
if (!obj->efile.elf) {
pr_warning("failed to open %s as ELF file\n", obj->path);
err = -LIBBPF_ERRNO__LIBELF;
goto errout;
}
if (!gelf_getehdr(obj->efile.elf, &obj->efile.ehdr)) {
pr_warning("failed to get EHDR from %s\n", obj->path);
err = -LIBBPF_ERRNO__FORMAT;
goto errout;
}
ep = &obj->efile.ehdr;
/* Old LLVM set e_machine to EM_NONE */
if (ep->e_type != ET_REL ||
(ep->e_machine && ep->e_machine != EM_BPF)) {
pr_warning("%s is not an eBPF object file\n", obj->path);
err = -LIBBPF_ERRNO__FORMAT;
goto errout;
}
return 0;
errout:
```
<Overlap Ratio: 0.9486166007905138>

---

--- 245 --
Question ID: 6cfa598c36e593ae541ee899a9d99018dd9082e4_4
Original Code:
```
static int set_sampler_gain(int gain, void *param)
{
    if (gain < 1 || gain > 200) {
        return -1;
    }

    sampler_gain = gain;

    return 0;
}
```


Overlapping Code:
```
gain(int gain, void *param)
{
if (gain < 1 || gain > 200) {
return -1;
}
sampler_gain = gain;
return
```
<Overlap Ratio: 0.78125>

---

--- 246 --
Question ID: 6ceb4de1f0f85ce8f468f4fa0710ea0d26594591_8
Original Code:
```
void smk_hid_usb_init()
{
    usbd_hid_add_interface(&hid_class, &hid_intf_kb);
    usbd_interface_add_endpoint(&hid_intf_kb, &hid_kb_in_ep);
    usbd_hid_callback_register(hid_intf_kb.intf_num,keyboard_led_cb,NULL,kb_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,smk_configured_callback);
    usbd_hid_report_descriptor_register(hid_intf_kb.intf_num, hid_keyboard_report_desc, HID_KEYBOARD_REPORT_DESC_SIZE);

    usbd_hid_add_interface(&hid_class, &hid_intf_data);
    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_in_ep);
    usbd_interface_add_endpoint(&hid_intf_data, &hid_data_out_ep);
    usbd_hid_report_descriptor_register(hid_intf_data.intf_num, hid_data_report_desc, HID_DATA_REPORT_DESC_SIZE);

    usbd_hid_add_interface(&hid_class, &hid_intf_nkro);
    usbd_interface_add_endpoint(&hid_intf_nkro, &hid_nkro_in_ep);
    usbd_hid_callback_register(hid_intf_nkro.intf_num,keyboard_led_cb,NULL,nkro_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,NULL);
    usbd_hid_report_descriptor_register(hid_intf_nkro.intf_num, hid_nkro_report_desc, HID_NKRO_REPORT_DESC_SIZE);

    hid_data_protocol_init();

    // Set daemon task to handle keyscan periodically
    hid_timer = xTimerCreate(
            "hid report timer",                              // pcTimerName
            pdMS_TO_TICKS(1), // xTimerPeriodInTicks
            pdTRUE,                                             // uxAutoReload
            xTaskGetCurrentTaskHandle(),                        // pvTimerID
            smk_hidreport_update                          // pxCallbackFunction
    );

    // Start timer
    xTimerStart(
            hid_timer,       // xTimer
            portMAX_DELAY // xTicksToWait
    );

}
```


Overlapping Code:
```
init()
{
usbd_hid_add_interface(&hid_class, &hid_intf_kb);
usbd_interface_add_endpoint(&hid_intf_kb, &hid_kb_in_ep);
usbd_hid_callback_register(hid_intf_kb.intf_num,keyboard_led_cb,NULL,kb_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,smk_configured_callback);
usbd_hid_report_descriptor_register(hid_intf_kb.intf_num, hid_keyboard_report_desc, HID_KEYBOARD_REPORT_DESC_SIZE);
usbd_hid_add_interface(&hid_class, &hid_intf_data);
usbd_interface_add_endpoint(&hid_intf_data, &hid_data_in_ep);
usbd_interface_add_endpoint(&hid_intf_data, &hid_data_out_ep);
usbd_hid_report_descriptor_register(hid_intf_data.intf_num, hid_data_report_desc, HID_DATA_REPORT_DESC_SIZE);
usbd_hid_add_interface(&hid_class, &hid_intf_nkro);
usbd_interface_add_endpoint(&hid_intf_nkro, &hid_nkro_in_ep);
usbd_hid_callback_register(hid_intf_nkro.intf_num,keyboard_led_cb,NULL,nkro_set_idle_callback,NULL,NULL,kb_set_protocol_callback,smk_reset_callback,NULL);
usbd_hid_report_descriptor_register(hid_intf_nkro.intf_num, hid_nkro_report_desc, HID_NKRO_REPORT_DESC_SIZE);
hid_data_protocol_init();
// Set daemon task to handle keyscan periodically
hid_timer = xTimerCreate(
"hid report timer", // pcTimerName
pdMS_TO_TICKS(1), // xTimerPeriodInTicks
pdTRUE, // uxAutoReload
xTaskGetCurrentTaskHandle(), // pvTimerID
smk_hidreport_update // pxCallbackFunction
);
// Start timer
xTimerStart(
hid_timer, // xTimer
portMAX_DELAY 
```
<Overlap Ratio: 0.9746401644962303>

---

--- 247 --
Question ID: 5dbed81eb340ffac294e47db30c46251da294323_37
Original Code:
```
void fun_eval(char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)
{
	if (!fn_range_check(((FUN *)fargs[-1])->name, nfargs, 1, 2, buff, bufc))
	{
		return;
	}

	if (nfargs == 1)
	{
		char *str = fargs[0];
		exec(buff, bufc, player, caller, cause, EV_EVAL | EV_FCHECK, &str, (char **)NULL, 0);
		return;
	}

	perform_get(buff, bufc, player, caller, cause, fargs, nfargs, cargs, ncargs);
}
```


Overlapping Code:
```
d fun_eval(char *buff, char **bufc, dbref player, dbref caller, dbref cause, char *fargs[], int nfargs, char *cargs[], int ncargs)
{
if (!fn_range_check(((FUN *)fargs[-1])->name, nfargs, 1, 2, buff, bufc))
{
return;
}
if (nfargs == 1)
{
char *str = fargs[0];
exec(buff, bufc, player, caller, cause, EV_EVAL | EV_FCHECK, &str, (char **)NULL, 0);
return;
}
perform_get(buff, bufc, player, caller, cause, fargs, nfargs, cargs, ncargs
```
<Overlap Ratio: 0.9839816933638444>

---

--- 248 --
Question ID: c7810d8e96a88efd460ca3a8ffb25975afb5cd67_11
Original Code:
```
chars IO_toString_d ( int x )
{                             // variante do printf( )
  chars buffer = IO_new_chars ( STR_SIZE+1 );
  sprintf ( buffer, "%d", x );
  return  ( buffer );
}
```


Overlapping Code:
```

{ // variante do printf( )
chars buffer = IO_new_chars ( STR_SIZE+1 );
sprintf ( buffer, "%d", x );
return ( buffer );
}
```
<Overlap Ratio: 0.8066666666666666>

---

--- 249 --
Question ID: bed4cbbc9b46a4cd831e842bbb442e7aae76bf46_2
Original Code:
```
void _endthreadex(unsigned retval)
{
    char * env;
    struct THREAD *thd;
    int i;

    thd = _getthreaddata();
    env = thd->t_envptr;
    if (env != 0)
        _free_crt (env);

    for (i = 0; i < THREADMAX; i++) 
    {
        if (__thdtbl[i] == thd)
        {
            __thdtbl[i] = 0;
            break;
        }
    }
    _free_crt (thd);
    ExitThread (retval);
}
```


Overlapping Code:
```
threadex(unsigned retval)
{
char * env;
struct THREAD *thd;
int i;
thd = _getthreaddata();
env = thd->t_envptr;
if (env != 0)
_free_crt (env);
for (i = 0; i < THREADMAX; i++) 
{
if (__thdtbl[i] == thd)
{
__thdtbl[i] = 0;
break;
}
}
_free_crt (thd);
E
```
<Overlap Ratio: 0.8928571428571429>

---

--- 250 --
Question ID: d8dcc9678735a11a2887fc2e14ed671bbd7c66d3_0
Original Code:
```
void SystemInit(void)
{
  uint32_t i,nCount,nValue,nAddress,nChecksum;
  
  nCount = *(__IO uint32_t *)NVR_REGINFOCOUNT1;
  nChecksum = nCount;
  nChecksum = ~nChecksum;
  if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+4))
  {
    nCount = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET);
    nChecksum = nCount;
    nChecksum = ~nChecksum;
    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+4))
    {
      while(1);
    }
  }
  
  for(i=0; i<nCount; i++)
  {
    nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+8+i*12);
    nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+12+i*12);
    nChecksum = nAddress + nValue;
    nChecksum = ~nChecksum;
    if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+16+i*12))
    {
      nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+8+i*12);
      nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+12+i*12);
      nChecksum = nAddress + nValue;
      nChecksum = ~nChecksum;
      if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+16+i*12))
      {
        while(1);
      }
    }
    if((nAddress>=0x40014800) && (nAddress<=0x40015000))
    {
      RTC_WriteRegisters(nAddress, &nValue, 1);
    }
    else
    {
      *(__IO uint32_t *)(nAddress) = nValue;
    }
  }
}
```


Overlapping Code:
```
e,nAddress,nChecksum;

nCount = *(__IO uint32_t *)NVR_REGINFOCOUNT1;
nChecksum = nCount;
nChecksum = ~nChecksum;
if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+4))
{
nCount = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET);
nChecksum = nCount;
nChecksum = ~nChecksum;
if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+4))
{
while(1);
}
}

for(i=0; i<nCount; i++)
{
nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+8+i*12);
nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+12+i*12);
nChecksum = nAddress + nValue;
nChecksum = ~nChecksum;
if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+16+i*12))
{
nAddress = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+8+i*12);
nValue = *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+12+i*12);
nChecksum = nAddress + nValue;
nChecksum = ~nChecksum;
if(nChecksum != *(__IO uint32_t *)(NVR_REGINFOCOUNT1+NVR_REGINFOBAKOFFSET+16+i*12))
{
while(1);
}
}
if((nAddress>=0x40014800) && (nAddress<=0x40015000))
{
RTC_WriteRegisters(nAddress, &nValue, 1);
}
el
```
<Overlap Ratio: 0.9162303664921466>

---

--- 251 --
Question ID: b8b09b497ac1655421e82237a1c44dbb703e4cbc_7
Original Code:
```
int RLE4CmprLine(char *src, char *dst, int n)
   {
   int i,count=2/*,absolute=1*/;
   BYTE c;
   char *t=dst/*,*tmp*/;

   c = (BYTE)*src;

   for (i=1;i<n;i++)
       {
       if ((BYTE)src[i]==c)
           {

           if (count >= 0xFE)  /* make sure the repeat counter does not */
               {               /* overflow. Flush the buffer if needed  */
               *t++ = count;
               *t++ = c;
               count= 2;       /* reset repeat counter */
               }
           else
               count+=2;       /* increment the repeat counter */

           continue;
           }
       else
           {
           if (count > 2)      /* write out repeated run if any */
               {
               *t++ = count;
               *t++ = c;
               count= 2;       /* reset repeat counter */
               c = (BYTE)src[i];
               continue;
               }

           *t++ = 2;
           *t++ = c;
           c = (BYTE)src[i];
           }
       }

   if (count>2)        /* write out repeated run if any */
       {
       *t++ = count;
       *t++ = c;
       }
   else
       {
       *t++=2;
       *t++=c;
       }

   *t++ = 0;   /* end-of-line record */
   *t++ = 0;

   return (int)(t-dst);
   }
```


Overlapping Code:
```
mprLine(char *src, char *dst, int n)
{
int i,count=2/*,absolute=1*/;
BYTE c;
char *t=dst/*,*tmp*/;
c = (BYTE)*src;
for (i=1;i<n;i++)
{
if ((BYTE)src[i]==c)
{
if (count >= 0xFE) /* make sure the repeat counter does not */
{ /* overflow. Flush the buffer if needed */
*t++ = count;
*t++ = c;
count= 2; /* reset repeat counter */
}
else
count+=2; /* increment the repeat counter */
continue;
}
else
{
if (count > 2) /* write out repeated run if any */
{
*t++ = count;
*t++ = c;
count= 2; /* reset repeat counter */
c = (BYTE)src[i];
continue;
}
*t++ = 2;
*t++ = c;
c = (BYTE)src[i];
}
}
if (count>2) /* write out repeated run if any */
{
*t++ = count;
*t++ = c;
}
else
{
*t++=2;
*t++=c;
}
*t++ = 0; /* end-of-line rec
```
<Overlap Ratio: 0.937007874015748>

---

--- 252 --
Question ID: 53ebabf42472224ee1dee0eeea5e8f7879c4739c_83
Original Code:
```
static void scarlett2_notify_input_other(
	struct usb_mixer_interface *mixer)
{
	struct snd_card *card = mixer->chip->card;
	struct scarlett2_data *private = mixer->private_data;
	const struct scarlett2_device_info *info = private->info;
	int i;

	private->input_other_updated = 1;

	for (i = 0; i < info->level_input_count; i++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
			       &private->level_ctls[i]->id);
	for (i = 0; i < info->pad_input_count; i++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
			       &private->pad_ctls[i]->id);
	for (i = 0; i < info->air_input_count; i++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
			       &private->air_ctls[i]->id);
	for (i = 0; i < info->phantom_count; i++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
			       &private->phantom_ctls[i]->id);
}
```


Overlapping Code:
```
_input_other(
struct usb_mixer_interface *mixer)
{
struct snd_card *card = mixer->chip->card;
struct scarlett2_data *private = mixer->private_data;
const struct scarlett2_device_info *info = private->info;
int i;
private->input_other_updated = 1;
for (i = 0; i < info->level_input_count; i++)
snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
&private->level_ctls[i]->id);
for (i = 0; i < info->pad_input_count; i++)
snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
&private->pad_ctls[i]->id);
for (i = 0; i < info->air_input_count; i++)
snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
&private->air_ctls[i]->id);
for (i = 0; i < info->phantom_count; i++)
snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,
&private
```
<Overlap Ratio: 0.9308093994778068>

---

--- 253 --
Question ID: 23963e9ef99b6c5865a9b907b3abd5b6ae63f87b_0
Original Code:
```
namespace dlib
{

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                                   Simple matrix utilities 
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    const matrix_exp diag (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a column vector R that contains the elements from the diagonal 
              of m in the order R(0)==m(0,0), R(1)==m(1,1), R(2)==m(2,2) and so on.
    !*/

    template <typename EXP>
    struct diag_exp
    {
        /*!
            WHAT THIS OBJECT REPRESENTS
                This struct allows you to determine the type of matrix expression 
                object returned from the diag() function.  An example makes its
                use clear:

                template <typename EXP>
                void do_something( const matrix_exp<EXP>& mat)
                {
                    // d is a matrix expression that aliases mat.
                    typename diag_exp<EXP>::type d = diag(mat);

                    // Print the diagonal of mat.  So we see that by using
                    // diag_exp we can save the object returned by diag() in
                    // a local variable.    
                    cout << d << endl;

                    // Note that you can only save the return value of diag() to
                    // a local variable if the argument to diag() has a lifetime
                    // beyond the diag() expression.  The example shown above is
                    // OK but the following would result in undefined behavior:
                    typename diag_exp<EXP>::type bad = diag(mat + mat);
                }
        !*/
        typedef type_of_expression_returned_by_diag type;
    };

// ----------------------------------------------------------------------------------------

    const matrix_exp diagm (
        const matrix_exp& m
    );
    /*!
        requires
            - is_vector(m) == true
              (i.e. m is a row or column matrix)
        ensures
            - returns a square matrix M such that:
                - diag(M) == m
                - non diagonal elements of M are 0
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp trans (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns the transpose of the matrix m
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_type::type dot (
        const matrix_exp& m1,
        const matrix_exp& m2
    );
    /*!
        requires
            - is_vector(m1) == true
            - is_vector(m2) == true
            - m1.size() == m2.size()
            - m1.size() > 0
        ensures
            - returns the dot product between m1 and m2. That is, this function 
              computes and returns the sum, for all i, of m1(i)*m2(i).
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp lowerm (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the lower triangular part of m.  That is:
                    - if (r >= c) then
                        - M(r,c) == m(r,c)
                    - else
                        - M(r,c) == 0
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp lowerm (
        const matrix_exp& m,
        const matrix_exp::type scalar_value
    );
    /*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the lower triangular part of m except that the diagonal has
                  been set to scalar_value.  That is:
                    - if (r > c) then
                        - M(r,c) == m(r,c)
                    - else if (r == c) then
                        - M(r,c) == scalar_value 
                    - else
                        - M(r,c) == 0
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp upperm (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the upper triangular part of m.  That is:
                    - if (r <= c) then
                        - M(r,c) == m(r,c)
                    - else
                        - M(r,c) == 0
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp upperm (
        const matrix_exp& m,
        const matrix_exp::type scalar_value
    );
    /*!
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is the upper triangular part of m except that the diagonal has
                  been set to scalar_value.  That is:
                    - if (r < c) then
                        - M(r,c) == m(r,c)
                    - else if (r == c) then
                        - M(r,c) == scalar_value 
                    - else
                        - M(r,c) == 0
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp make_symmetric (
        const matrix_exp& m
    );
    /*!
        requires
            - m.nr() == m.nc()
              (i.e. m must be a square matrix)
        ensures
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - M is a symmetric matrix, that is, M == trans(M) and
                  it is constructed from the lower triangular part of m.  Specifically,
                  we have:
                    - lowerm(M) == lowerm(m)
                    - upperm(M) == trans(lowerm(m))
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T, 
        long NR, 
        long NC, 
        T val
        >
    const matrix_exp uniform_matrix (
    );
    /*!
        requires
            - NR > 0 && NC > 0
        ensures
            - returns an NR by NC matrix with elements of type T and all set to val.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T,
        long NR, 
        long NC
        >
    const matrix_exp uniform_matrix (
        const T& val
    );
    /*!
        requires
            - NR > 0 && NC > 0
        ensures
            - returns an NR by NC matrix with elements of type T and all set to val.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T
        >
    const matrix_exp uniform_matrix (
        long nr,
        long nc,
        const T& val
    );
    /*!
        requires
            - nr >= 0 && nc >= 0
        ensures
            - returns an nr by nc matrix with elements of type T and all set to val.
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp ones_matrix (
        const matrix_exp& mat
    );
    /*!
        requires
            - mat.nr() >= 0 && mat.nc() >= 0
        ensures
            - Let T denote the type of element in mat. Then this function
              returns uniform_matrix<T>(mat.nr(), mat.nc(), 1)
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T
        >
    const matrix_exp ones_matrix (
        long nr,
        long nc
    );
    /*!
        requires
            - nr >= 0 && nc >= 0
        ensures
            - returns uniform_matrix<T>(nr, nc, 1)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp zeros_matrix (
        const matrix_exp& mat
    );
    /*!
        requires
            - mat.nr() >= 0 && mat.nc() >= 0
        ensures
            - Let T denote the type of element in mat. Then this function
              returns uniform_matrix<T>(mat.nr(), mat.nc(), 0)
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T
        >
    const matrix_exp zeros_matrix (
        long nr,
        long nc
    );
    /*!
        requires
            - nr >= 0 && nc >= 0
        ensures
            - returns uniform_matrix<T>(nr, nc, 0)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp identity_matrix (
        const matrix_exp& mat
    );
    /*!
        requires
            - mat.nr() == mat.nc()
        ensures
            - returns an identity matrix with the same dimensions as mat and
              containing the same type of elements as mat.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T
        >
    const matrix_exp identity_matrix (
        long N
    );
    /*!
        requires
            - N > 0
        ensures
            - returns an N by N identity matrix with elements of type T.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T, 
        long N
        >
    const matrix_exp identity_matrix (
    );
    /*!
        requires
            - N > 0
        ensures
            - returns an N by N identity matrix with elements of type T.
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp linspace (
        double start,
        double end,
        long num
    );
    /*!
        requires
            - num >= 0
        ensures
            - returns a matrix M such that:
                - M::type == double 
                - is_row_vector(M) == true
                - M.size() == num
                - M == a row vector with num linearly spaced values beginning with start
                  and stopping with end.  
                - M(num-1) == end 
                - if (num > 1) then
                    - M(0) == start
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp logspace (
        double start,
        double end,
        long num
    );
    /*!
        requires
            - num >= 0
        ensures
            - returns a matrix M such that:
                - M::type == double 
                - is_row_vector(M) == true
                - M.size() == num
                - M == a row vector with num logarithmically spaced values beginning with 
                  10^start and stopping with 10^end.  
                  (i.e. M == pow(10, linspace(start, end, num)))
                - M(num-1) == 10^end
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp linpiece (
        const double val,
        const matrix_exp& joints
    );
    /*!
        requires
            - is_vector(joints) == true
            - joints.size() >= 2
            - for all valid i < j:
                - joints(i) < joints(j)
        ensures
            - linpiece() is useful for creating piecewise linear functions of val.  For
              example, if w is a parameter vector then you can represent a piecewise linear
              function of val as: f(val) = dot(w, linpiece(val, linspace(0,100,5))).  In
              this case, f(val) is piecewise linear on the intervals [0,25], [25,50],
              [50,75], [75,100].  Moreover, w(i) defines the derivative of f(val) in the
              i-th interval.  Finally, outside the interval [0,100] f(val) has a derivative
              of zero and f(0) == 0.
            - To be precise, this function returns a column vector L such that:
                - L.size() == joints.size()-1
                - is_col_vector(L) == true
                - L contains the same type of elements as joints.
                - for all valid i:
                - if (joints(i) < val)
                    - L(i) == min(val,joints(i+1)) - joints(i)
                - else
                    - L(i) == 0
    !*/

// ----------------------------------------------------------------------------------------

    template <
        long R,
        long C
        >
    const matrix_exp rotate (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                  R( (r+R)%m.nr() , (c+C)%m.nc() ) == m(r,c)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp fliplr (
        const matrix_exp& m
    );
    /*!
        ensures
            - flips the matrix m from left to right and returns the result.  
              I.e. reverses the order of the columns.
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - for all valid r and c:
                  M(r,c) == m(r, m.nc()-c-1)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp flipud (
        const matrix_exp& m
    );
    /*!
        ensures
            - flips the matrix m from up to down and returns the result.  
              I.e. reverses the order of the rows.
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - for all valid r and c:
                  M(r,c) == m(m.nr()-r-1, c)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp flip (
        const matrix_exp& m
    );
    /*!
        ensures
            - flips the matrix m from up to down and left to right and returns the 
              result.  I.e. returns flipud(fliplr(m)).
            - returns a matrix M such that:
                - M::type == the same type that was in m
                - M has the same dimensions as m
                - for all valid r and c:
                  M(r,c) == m(m.nr()-r-1, m.nc()-c-1)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp reshape (
        const matrix_exp& m,
        long rows,
        long cols
    );
    /*!
        requires
            - m.size() == rows*cols
            - rows > 0
            - cols > 0
        ensures
            - returns a matrix M such that: 
                - M.nr() == rows
                - M.nc() == cols
                - M.size() == m.size()
                - for all valid r and c:
                    - let IDX = r*cols + c
                    - M(r,c) == m(IDX/m.nc(), IDX%m.nc())

            - i.e. The matrix m is reshaped into a new matrix of rows by cols
              dimension.  Additionally, the elements of m are laid into M in row major 
              order.
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp reshape_to_column_vector (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix M such that: 
                - is_col_vector(M) == true
                - M.size() == m.size()
                - for all valid r and c:
                    - m(r,c) == M(r*m.nc() + c)

            - i.e. The matrix m is reshaped into a column vector.  Note that
              the elements are pulled out in row major order.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        long R,
        long C
        >
    const matrix_exp removerc (
        const matrix_exp& m
    );
    /*!
        requires
            - m.nr() > R >= 0
            - m.nc() > C >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() - 1
                - M == m with its R row and C column removed
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp removerc (
        const matrix_exp& m,
        long R,
        long C
    );
    /*!
        requires
            - m.nr() > R >= 0
            - m.nc() > C >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() - 1
                - M == m with its R row and C column removed
    !*/

// ----------------------------------------------------------------------------------------

    template <
        long R
        >
    const matrix_exp remove_row (
        const matrix_exp& m
    );
    /*!
        requires
            - m.nr() > R >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() 
                - M == m with its R row removed
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp remove_row (
        const matrix_exp& m,
        long R
    );
    /*!
        requires
            - m.nr() > R >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() - 1
                - M.nc() == m.nc() 
                - M == m with its R row removed
    !*/

// ----------------------------------------------------------------------------------------

    template <
        long C
        >
    const matrix_exp remove_col (
        const matrix_exp& m
    );
    /*!
        requires
            - m.nc() > C >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() 
                - M.nc() == m.nc() - 1 
                - M == m with its C column removed
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp remove_col (
        const matrix_exp& m,
        long C
    );
    /*!
        requires
            - m.nc() > C >= 0
        ensures
            - returns a matrix M such that:
                - M.nr() == m.nr() 
                - M.nc() == m.nc() - 1 
                - M == m with its C column removed
    !*/

// ----------------------------------------------------------------------------------------

    template <
       typename target_type
       >
    const matrix_exp matrix_cast (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix R where for all valid r and c:
              R(r,c) == static_cast<target_type>(m(r,c))
              also, R has the same dimensions as m.
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T,
        long NR,
        long NC,
        typename MM,
        typename U,
        typename L
        >
    void set_all_elements (
        matrix<T,NR,NC,MM,L>& m,
        U value
    );
    /*!
        ensures
            - for all valid r and c:
              m(r,c) == value
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::matrix_type tmp (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a temporary matrix object that is a copy of m. 
              (This allows you to easily force a matrix_exp to fully evaluate)
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename T, 
        long NR, 
        long NC, 
        typename MM, 
        typename L
        >
    uint32 hash (
        const matrix<T,NR,NC,MM,L>& item,
        uint32 seed = 0
    );
    /*!
        requires
            - T is a standard layout type (e.g. a POD type like int, float, 
              or a simple struct).
        ensures
            - returns a 32bit hash of the data stored in item.  
            - Each value of seed results in a different hash function being used.  
              (e.g. hash(item,0) should generally not be equal to hash(item,1))
            - uses the murmur_hash3() routine to compute the actual hash.
            - Note that if the memory layout of the elements in item change between
              hardware platforms then hash() will give different outputs.  If you want
              hash() to always give the same output for the same input then you must 
              ensure that elements of item always have the same layout in memory.
              Typically this means using fixed width types and performing byte swapping
              to account for endianness before passing item to hash().
    !*/

// ----------------------------------------------------------------------------------------

    // if matrix_exp contains non-complex types (e.g. float, double)
    bool equal (
        const matrix_exp& a,
        const matrix_exp& b,
        const matrix_exp::type epsilon = 100*std::numeric_limits<matrix_exp::type>::epsilon()
    );
    /*!
        ensures
            - if (a and b don't have the same dimensions) then
                - returns false
            - else if (there exists an r and c such that abs(a(r,c)-b(r,c)) > epsilon) then
                - returns false
            - else
                - returns true
    !*/

// ----------------------------------------------------------------------------------------

    // if matrix_exp contains std::complex types 
    bool equal (
        const matrix_exp& a,
        const matrix_exp& b,
        const matrix_exp::type::value_type epsilon = 100*std::numeric_limits<matrix_exp::type::value_type>::epsilon()
    );
    /*!
        ensures
            - if (a and b don't have the same dimensions) then
                - returns false
            - else if (there exists an r and c such that abs(real(a(r,c)-b(r,c))) > epsilon 
              or abs(imag(a(r,c)-b(r,c))) > epsilon) then
                - returns false
            - else
                - returns true
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp pointwise_multiply (
        const matrix_exp& a,
        const matrix_exp& b 
    );
    /*!
        requires
            - a.nr() == b.nr()
            - a.nc() == b.nc()
            - a and b both contain the same type of element (one or both
              can also be of type std::complex so long as the underlying type
              in them is the same)
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R has the same dimensions as a and b. 
                - for all valid r and c:
                  R(r,c) == a(r,c) * b(r,c)
    !*/

    const matrix_exp pointwise_multiply (
        const matrix_exp& a,
        const matrix_exp& b,
        const matrix_exp& c 
    );
    /*!
        performs pointwise_multiply(a,pointwise_multiply(b,c));
    !*/

    const matrix_exp pointwise_multiply (
        const matrix_exp& a,
        const matrix_exp& b,
        const matrix_exp& c,
        const matrix_exp& d 
    );
    /*!
        performs pointwise_multiply(pointwise_multiply(a,b),pointwise_multiply(c,d));
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp join_rows (
        const matrix_exp& a,
        const matrix_exp& b 
    );
    /*!
        requires
            - a.nr() == b.nr() || a.size() == 0 || b.size() == 0
            - a and b both contain the same type of element
        ensures
            - This function joins two matrices together by concatenating their rows.
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() == b.nr()
                - R.nc() == a.nc() + b.nc()
                - for all valid r and c:
                    - if (c < a.nc()) then
                        - R(r,c) == a(r,c) 
                    - else
                        - R(r,c) == b(r, c-a.nc()) 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp join_cols (
        const matrix_exp& a,
        const matrix_exp& b 
    );
    /*!
        requires
            - a.nc() == b.nc() || a.size() == 0 || b.size() == 0
            - a and b both contain the same type of element
        ensures
            - This function joins two matrices together by concatenating their columns.
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() + b.nr()
                - R.nc() == a.nc() == b.nc()
                - for all valid r and c:
                    - if (r < a.nr()) then
                        - R(r,c) == a(r,c) 
                    - else
                        - R(r,c) == b(r-a.nr(), c) 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp tensor_product (
        const matrix_exp& a,
        const matrix_exp& b 
    );
    /*!
        requires
            - a and b both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in a and b.
                - R.nr() == a.nr() * b.nr()  
                - R.nc() == a.nc() * b.nc()  
                - for all valid r and c:
                  R(r,c) == a(r/b.nr(), c/b.nc()) * b(r%b.nr(), c%b.nc())
                - I.e. R is the tensor product of matrix a with matrix b
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp cartesian_product (
        const matrix_exp& A,
        const matrix_exp& B 
    );
    /*!
        requires
            - A and B both contain the same type of element
        ensures
            - Think of A and B as sets of column vectors.  Then this function 
              returns a matrix that contains a set of column vectors that is
              the Cartesian product of the sets A and B.  That is, the resulting
              matrix contains every possible combination of vectors from both A and
              B.
            - returns a matrix R such that:
                - R::type == the same type that was in A and B.
                - R.nr() == A.nr() + B.nr()  
                - R.nc() == A.nc() * B.nc()  
                - Each column of R is the concatenation of a column vector
                  from A with a column vector from B.  
                - for all valid r and c:
                    - if (r < A.nr()) then
                        - R(r,c) == A(r, c/B.nc())
                    - else
                        - R(r,c) == B(r-A.nr(), c%B.nc())
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp scale_columns (
        const matrix_exp& m,
        const matrix_exp& v
    );
    /*!
        requires
            - is_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m and v.
                - R has the same dimensions as m. 
                - for all valid r and c:
                  R(r,c) == m(r,c) * v(c)
                - i.e. R is the result of multiplying each of m's columns by
                  the corresponding scalar in v.

            - Note that this function is identical to the expression m*diagm(v).  
              That is, the * operator is overloaded for this case and will invoke
              scale_columns() automatically as appropriate.
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp scale_rows (
        const matrix_exp& m,
        const matrix_exp& v
    );
    /*!
        requires
            - is_vector(v) == true
            - v.size() == m.nr()
            - m and v both contain the same type of element
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m and v.
                - R has the same dimensions as m. 
                - for all valid r and c:
                  R(r,c) == m(r,c) * v(r)
                - i.e. R is the result of multiplying each of m's rows by
                  the corresponding scalar in v.

            - Note that this function is identical to the expression diagm(v)*m.  
              That is, the * operator is overloaded for this case and will invoke
              scale_rows() automatically as appropriate.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename T>
    void sort_columns (
        matrix<T>& m,
        matrix<T>& v
    );
    /*!
        requires
            - is_col_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - the dimensions for m and v are not changed
            - sorts the columns of m according to the values in v.
              i.e. 
                - #v == the contents of v but in sorted order according to
                  operator<.  So smaller elements come first.
                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)
                - colm(#m,new(i)) == colm(m,i) 
    !*/

// ----------------------------------------------------------------------------------------

    template <typename T>
    void rsort_columns (
        matrix<T>& m,
        matrix<T>& v
    );
    /*!
        requires
            - is_col_vector(v) == true
            - v.size() == m.nc()
            - m and v both contain the same type of element
        ensures
            - the dimensions for m and v are not changed
            - sorts the columns of m according to the values in v.
              i.e. 
                - #v == the contents of v but in sorted order according to
                  operator>.  So larger elements come first.
                - Let #v(new(i)) == v(i) (i.e. new(i) is the index element i moved to)
                - colm(#m,new(i)) == colm(m,i) 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type length_squared (
        const matrix_exp& m
    );
    /*!
        requires
            - is_vector(m) == true
        ensures
            - returns sum(squared(m))
              (i.e. returns the square of the length of the vector m)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type length (
        const matrix_exp& m
    );
    /*!
        requires
            - is_vector(m) == true
        ensures
            - returns sqrt(sum(squared(m)))
              (i.e. returns the length of the vector m)
            - if (m contains integer valued elements) then  
                - The return type is a double that represents the length.  Therefore, the
                  return value of length() is always represented using a floating point
                  type. 
    !*/

// ----------------------------------------------------------------------------------------

    bool is_row_vector (
        const matrix_exp& m
    );
    /*!
        ensures
            - if (m.nr() == 1) then
                - return true
            - else
                - returns false
    !*/

    bool is_col_vector (
        const matrix_exp& m
    );
    /*!
        ensures
            - if (m.nc() == 1) then
                - return true
            - else
                - returns false
    !*/

    bool is_vector (
        const matrix_exp& m
    );
    /*!
        ensures
            - if (is_row_vector(m) || is_col_vector(m)) then
                - return true
            - else
                - returns false
    !*/

// ----------------------------------------------------------------------------------------

    bool is_finite (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns true if all the values in m are finite values and also not any kind
              of NaN value.
    !*/

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                      Thresholding relational operators 
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator< (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) < s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator< (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s < m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator<= (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) <= s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator<= (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s <= m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator> (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) > s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator> (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s > m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator>= (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) >= s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator>= (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s >= m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator== (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) == s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator== (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s == m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator!= (
        const matrix_exp& m,
        const S& s
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (m(r,c) != s) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename S>
    const matrix_exp operator!= (
        const S& s,
        const matrix_exp& m
    );
    /*!
        requires
            - is_built_in_scalar_type<S>::value == true 
            - is_built_in_scalar_type<matrix_exp::type>::value == true
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m.
                - R has the same dimensions as m. 
                - for all valid r and c:
                    - if (s != m(r,c)) then
                        - R(r,c) == 1
                    - else
                        - R(r,c) == 0
                - i.e. R is a binary matrix of all 1s or 0s.
    !*/

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                              Statistics
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    const matrix_exp::type min (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns the value of the smallest element of m.  If m contains complex
              elements then the element returned is the one with the smallest norm
              according to std::norm().
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type max (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns the value of the biggest element of m.  If m contains complex
              elements then the element returned is the one with the largest norm
              according to std::norm().
    !*/

// ----------------------------------------------------------------------------------------

    void find_min_and_max (
        const matrix_exp& m,
        matrix_exp::type& min_val,
        matrix_exp::type& max_val
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - #min_val == min(m)
            - #max_val == max(m)
            - This function computes both the min and max in just one pass
              over the elements of the matrix m.
    !*/

// ----------------------------------------------------------------------------------------

    long index_of_max (
        const matrix_exp& m
    );
    /*!
        requires
            - is_vector(m) == true
            - m.size() > 0 
        ensures
            - returns the index of the largest element in m.  
              (i.e. m(index_of_max(m)) == max(m))
    !*/

// ----------------------------------------------------------------------------------------

    long index_of_min (
        const matrix_exp& m
    );
    /*!
        requires
            - is_vector(m) == true
            - m.size() > 0 
        ensures
            - returns the index of the smallest element in m.  
              (i.e. m(index_of_min(m)) == min(m))
    !*/

// ----------------------------------------------------------------------------------------

    point max_point (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns the location of the maximum element of the array, that is, if the
              returned point is P then it will be the case that: m(P.y(),P.x()) == max(m).
    !*/

// ----------------------------------------------------------------------------------------

    dlib::vector<double,2> max_point_interpolated (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - Like max_point(), this function finds the location in m with the largest
              value.  However, we additionally use some quadratic interpolation to find the
              location of the maximum point with sub-pixel accuracy.  Therefore, the
              returned point is equal to max_point(m) + some small sub-pixel delta.
    !*/

// ----------------------------------------------------------------------------------------

    point min_point (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns the location of the minimum element of the array, that is, if the
              returned point is P then it will be the case that: m(P.y(),P.x()) == min(m).
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type sum (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns the sum of all elements in m
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp sum_rows (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns a row matrix that contains the sum of all the rows in m. 
            - returns a matrix M such that
                - M::type == the same type that was in m
                - M.nr() == 1
                - M.nc() == m.nc()
                - for all valid i:
                    - M(i) == sum(colm(m,i)) 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp sum_cols (
        const matrix_exp& m
    );
    /*!
        requires
            - m.size() > 0
        ensures
            - returns a column matrix that contains the sum of all the columns in m. 
            - returns a matrix M such that
                - M::type == the same type that was in m
                - M.nr() == m.nr() 
                - M.nc() == 1
                - for all valid i:
                    - M(i) == sum(rowm(m,i)) 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type prod (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns the results of multiplying all elements of m together. 
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type mean (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns the mean of all elements in m. 
              (i.e. returns sum(m)/(m.nr()*m.nc()))
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type variance (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns the unbiased sample variance of all elements in m 
              (i.e. 1.0/(m.nr()*m.nc() - 1)*(sum of all pow(m(i,j) - mean(m),2)))
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp::type stddev (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns sqrt(variance(m))
    !*/

// ----------------------------------------------------------------------------------------

    const matrix covariance (
        const matrix_exp& m
    );
    /*!
        requires
            - matrix_exp::type == a dlib::matrix object
            - is_col_vector(m) == true
            - m.size() > 1
            - for all valid i, j:
                - is_col_vector(m(i)) == true 
                - m(i).size() > 0
                - m(i).size() == m(j).size() 
                - i.e. m contains only column vectors and all the column vectors
                  have the same non-zero length
        ensures
            - returns the unbiased sample covariance matrix for the set of samples
              in m.  
              (i.e. 1.0/(m.nr()-1)*(sum of all (m(i) - mean(m))*trans(m(i) - mean(m))))
            - the returned matrix will contain elements of type matrix_exp::type::type.
            - the returned matrix will have m(0).nr() rows and columns.
    !*/

// ----------------------------------------------------------------------------------------

    template <typename rand_gen>
    const matrix<double> randm( 
        long nr,
        long nc,
        rand_gen& rnd
    );
    /*!
        requires
            - nr >= 0
            - nc >= 0
            - rand_gen == an object that implements the rand/rand_float_abstract.h interface
        ensures
            - generates a random matrix using the given rnd random number generator
            - returns a matrix M such that
                - M::type == double
                - M.nr() == nr
                - M.nc() == nc
                - for all valid i, j:
                    - M(i,j) == a random number such that 0 <= M(i,j) < 1
    !*/

// ----------------------------------------------------------------------------------------

    inline const matrix<double> randm( 
        long nr,
        long nc
    );
    /*!
        requires
            - nr >= 0
            - nc >= 0
        ensures
            - generates a random matrix using std::rand() 
            - returns a matrix M such that
                - M::type == double
                - M.nr() == nr
                - M.nc() == nc
                - for all valid i, j:
                    - M(i,j) == a random number such that 0 <= M(i,j) < 1
    !*/

// ----------------------------------------------------------------------------------------

    inline const matrix_exp gaussian_randm (
        long nr,
        long nc,
        unsigned long seed = 0
    );
    /*!
        requires
            - nr >= 0
            - nc >= 0
        ensures
            - returns a matrix with its values filled with 0 mean unit variance Gaussian
              random numbers.  
            - Each setting of the seed results in a different random matrix.
            - The returned matrix is lazily evaluated using the expression templates
              technique.  This means that the returned matrix doesn't take up any memory
              and is only an expression template.  The values themselves are computed on
              demand using the gaussian_random_hash() routine.  
            - returns a matrix M such that
                - M::type == double
                - M.nr() == nr
                - M.nc() == nc
                - for all valid i, j:
                    - M(i,j) == gaussian_random_hash(i,j,seed) 
    !*/

// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
//                                 Pixel and Image Utilities
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------

    template <
        typename T,
        typename P
        >
    const matrix<T,pixel_traits<P>::num,1> pixel_to_vector (
        const P& pixel
    );
    /*!
        requires
            - pixel_traits<P> must be defined
        ensures
            - returns a matrix M such that:
                - M::type == T
                - M::NC == 1 
                - M::NR == pixel_traits<P>::num
                - if (pixel_traits<P>::grayscale) then
                    - M(0) == pixel 
                - if (pixel_traits<P>::rgb) then
                    - M(0) == pixel.red 
                    - M(1) == pixel.green 
                    - M(2) == pixel.blue 
                - if (pixel_traits<P>::hsi) then
                    - M(0) == pixel.h 
                    - M(1) == pixel.s 
                    - M(2) == pixel.i 
    !*/

// ----------------------------------------------------------------------------------------

    template <
        typename P
        >
    void vector_to_pixel (
        P& pixel,
        const matrix_exp& vector 
    );
    /*!
        requires
            - vector::NR == pixel_traits<P>::num
            - vector::NC == 1 
              (i.e. you have to use a statically dimensioned vector)
        ensures
            - if (pixel_traits<P>::grayscale) then
                - pixel == M(0) 
            - if (pixel_traits<P>::rgb) then
                - pixel.red   == M(0)  
                - pixel.green == M(1) 
                - pixel.blue  == M(2)  
            - if (pixel_traits<P>::hsi) then
                - pixel.h == M(0)
                - pixel.s == M(1)
                - pixel.i == M(2)
    !*/

// ----------------------------------------------------------------------------------------

    template <
        long lower,
        long upper 
        >
    const matrix_exp clamp (
        const matrix_exp& m
    );
    /*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) > upper) then
                        - R(r,c) == upper
                    - else if (m(r,c) < lower) then
                        - R(r,c) == lower
                    - else
                        - R(r,c) == m(r,c)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp clamp (
        const matrix_exp& m,
        const matrix_exp::type& lower,
        const matrix_exp::type& upper
    );
    /*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) > upper) then
                        - R(r,c) == upper
                    - else if (m(r,c) < lower) then
                        - R(r,c) == lower
                    - else
                        - R(r,c) == m(r,c)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp clamp (
        const matrix_exp& m,
        const matrix_exp& lower,
        const matrix_exp& upper
    );
    /*!
        requires
            - m.nr() == lower.nr()
            - m.nc() == lower.nc()
            - m.nr() == upper.nr()
            - m.nc() == upper.nc()
            - m, lower, and upper all contain the same type of elements. 
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) > upper(r,c)) then
                        - R(r,c) == upper(r,c)
                    - else if (m(r,c) < lower(r,c)) then
                        - R(r,c) == lower(r,c)
                    - else
                        - R(r,c) == m(r,c)
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp lowerbound (
        const matrix_exp& m,
        const matrix_exp::type& thresh 
    );
    /*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) >= thresh) then
                        - R(r,c) == m(r,c)
                    - else
                        - R(r,c) == thresh
    !*/

// ----------------------------------------------------------------------------------------

    const matrix_exp upperbound (
        const matrix_exp& m,
        const matrix_exp::type& thresh 
    );
    /*!
        ensures
            - returns a matrix R such that:
                - R::type == the same type that was in m
                - R has the same dimensions as m
                - for all valid r and c:
                    - if (m(r,c) <= thresh) then
                        - R(r,c) == m(r,c)
                    - else
                        - R(r,c) == thresh
    !*/

// ----------------------------------------------------------------------------------------

}
```


Overlapping Code:
```
namespace dlib
{
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
// Simple matrix utilities 
// ----------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------
const matrix_exp diag (
const matrix_exp& m
);
/*!
ensures
- returns a column vector R that contains the elements from the diagonal 
of m in the order R(0)==m(0,0), R(1)==m(1,1), R(2)==m(2,2) and so on.
!*/
template <typename EXP>
struct diag_exp
{
/*!
WHAT THIS OBJECT REPRESENTS
This struct allows you to determine the type of matrix expression 
object returned from the diag() function. An example makes its
use clear:
template <typename EXP>
void do_something( const matrix_exp<EXP>& mat)
{
// d is a matrix expression that aliases mat.
typename diag_exp<EXP>::type d = diag(mat);
// Print the diagonal of mat. So we see that by using
// diag_exp we can save the object returned by diag() in
// a local variable. 
cout << d << endl;
// Note that you can only save the return value of diag() to
// a local variable if the argument to diag() has a lifetime
// beyond the diag() expression. The example shown above is
// OK but the following would result in undefined behavior:
typename diag_exp<EXP>::type bad = diag(mat + mat);
}
!*/
typedef type_of_expression_returned_by_diag type;
};
// ----------------------------------------------------------------------------------------
const matrix_exp diagm (
const matrix_exp& m
);
/*!
requires
- is_vector(m) == true
(i.e. m is a row or column matrix)
ensures
- returns a square matrix M such that:
- diag(M) == m
- non diagonal elements of M are 0
!*/
// --------------------------------------------------------------------------------
```
<Overlap Ratio: 1.0>

---

--- 254 --
Question ID: 09e7d28b0f3f4bf6a5159a0101ef99b8f0807a03_9
Original Code:
```
uint8_t duProcUlCcchInd(UlCcchIndInfo *ulCcchIndInfo)
{

   uint8_t ret = ROK;
   int32_t gnbDuUeF1apId = 0;

   gnbDuUeF1apId = genGnbDuUeF1apId(ulCcchIndInfo->cellId);
   
   if(gnbDuUeF1apId == -1)
   {
      DU_LOG("ERROR  --> DU_APP : duProcUlCcchInd(): Received cellId[%d] does not exist", ulCcchIndInfo->cellId);
      return RFAILED;
   }

   /* Store Ue mapping */
   duCb.ueCcchCtxt[duCb.numUe].gnbDuUeF1apId = (uint32_t)gnbDuUeF1apId;
   duCb.ueCcchCtxt[duCb.numUe].crnti         = ulCcchIndInfo->crnti;
   duCb.ueCcchCtxt[duCb.numUe].cellId        = ulCcchIndInfo->cellId;

   duCb.numUe++;

   ret = (BuildAndSendInitialRrcMsgTransfer(gnbDuUeF1apId, ulCcchIndInfo->crnti, ulCcchIndInfo->ulCcchMsgLen,
	    ulCcchIndInfo->ulCcchMsg));
   if(ret != ROK)
   {
      DU_LOG("\nERROR  -->  DU_APP : BuildAndSendInitialRrcMsgTransfer failed");
   }

   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo->ulCcchMsg, ulCcchIndInfo->ulCcchMsgLen);
   DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo, sizeof(UlCcchIndInfo));

   return ret;

}
```


Overlapping Code:
```
CcchInd(UlCcchIndInfo *ulCcchIndInfo)
{
uint8_t ret = ROK;
int32_t gnbDuUeF1apId = 0;
gnbDuUeF1apId = genGnbDuUeF1apId(ulCcchIndInfo->cellId);

if(gnbDuUeF1apId == -1)
{
DU_LOG("ERROR --> DU_APP : duProcUlCcchInd(): Received cellId[%d] does not exist", ulCcchIndInfo->cellId);
return RFAILED;
}
/* Store Ue mapping */
duCb.ueCcchCtxt[duCb.numUe].gnbDuUeF1apId = (uint32_t)gnbDuUeF1apId;
duCb.ueCcchCtxt[duCb.numUe].crnti = ulCcchIndInfo->crnti;
duCb.ueCcchCtxt[duCb.numUe].cellId = ulCcchIndInfo->cellId;
duCb.numUe++;
ret = (BuildAndSendInitialRrcMsgTransfer(gnbDuUeF1apId, ulCcchIndInfo->crnti, ulCcchIndInfo->ulCcchMsgLen,
ulCcchIndInfo->ulCcchMsg));
if(ret != ROK)
{
DU_LOG("\nERROR --> DU_APP : BuildAndSendInitialRrcMsgTransfer failed");
}
DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo->ulCcchMsg, ulCcchIndInfo->ulCcchMsgLen);
DU_FREE_SHRABL_BUF(MAC_MEM_REGION, MAC_POOL, ulCcchIndInfo, sizeof(UlCcchIndInf
```
<Overlap Ratio: 0.9645833333333333>

---

--- 255 --
Question ID: e9996462c3f817cb23890d71b9eac7e364e02cda_9
Original Code:
```
struct SpaceSalvo{

    int n;
    //Vec3d pos,vel;
    ProjectileType* shotType;
    // derived properties
    double speed;     // [m/s],   299792458 m/s for laser
    //double Energy;
    double scatter0;  //
    double delay;

    inline double timeToTarget(double dist){ return dist/speed; }
    double getSpread(double dist, double aDelta, double& t ){
        double tof = timeToTarget( dist );
        t   = delay + tof;
        double scatter = scatter0*dist  +  aDelta*t*t*0.5;
        //printf( "getSpread : t %g(tof %g, t0 %g)[s] scatter %g(d %g ,d^2 %g)[m] \n",  t, tof, delay,      scatter, scatter0*dist, aDelta*t*t*0.5 );
        return scatter;
    }
```


Overlapping Code:
```

ProjectileType* shotType;
// derived properties
double speed; // [m/s], 299792458 m/s for laser
//double Energy;
double scatter0; //
double delay;
inline double timeToTarget(double dist){ return dist/speed; }
double getSpread(double dist, double aDelta, double& t ){
double tof = timeToTarget( dist );
t = delay + tof;
double scatter = scatter0*dist + aDelta*t*t*0.5;
//printf( "getSpread : t %g(tof %g, t0 %g)[s] scatter %g(d %g ,d^2 %g)[m] \n", t, tof, delay, scatter, scatter0*dist, aDelta*t*t*0.
```
<Overlap Ratio: 0.8865248226950354>

---

--- 256 --
Question ID: e7ce7abf4636068b9615275526c4722fe782f4b0_1
Original Code:
```
class DecagonES2_Cond : public Variable {
 public:
    /**
     * @brief Construct a new DecagonES2_Cond object.
     *
     * @param parentSense The parent DecagonES2 providing the result values.
     * @param uuid A universally unique identifier (UUID or GUID) for the
     * variable; optional with the default value of an empty string.
     * @param varCode A short code to help identify the variable in files;
     * optional with a default value of "ES2Cond".
     */
    explicit DecagonES2_Cond(DecagonES2* parentSense, const char* uuid = "",
                             const char* varCode = ES2_COND_DEFAULT_CODE)
        : Variable(parentSense, (const uint8_t)ES2_COND_VAR_NUM,
                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,
                   ES2_COND_UNIT_NAME, varCode, uuid) {}
    /**
     * @brief Construct a new DecagonES2_Cond object.
     *
     * @note This must be tied with a parent DecagonES2 before it can be used.
     */
    DecagonES2_Cond()
        : Variable((const uint8_t)ES2_COND_VAR_NUM,
                   (uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,
                   ES2_COND_UNIT_NAME, ES2_COND_DEFAULT_CODE) {}
    /**
     * @brief Destroy the DecagonES2_Cond object - no action needed.
     */
    ~DecagonES2_Cond() {}
}
```


Overlapping Code:
```
nd : public Variable {
public:
/**
* @brief Construct a new DecagonES2_Cond object.
*
* @param parentSense The parent DecagonES2 providing the result values.
* @param uuid A universally unique identifier (UUID or GUID) for the
* variable; optional with the default value of an empty string.
* @param varCode A short code to help identify the variable in files;
* optional with a default value of "ES2Cond".
*/
explicit DecagonES2_Cond(DecagonES2* parentSense, const char* uuid = "",
const char* varCode = ES2_COND_DEFAULT_CODE)
: Variable(parentSense, (const uint8_t)ES2_COND_VAR_NUM,
(uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,
ES2_COND_UNIT_NAME, varCode, uuid) {}
/**
* @brief Construct a new DecagonES2_Cond object.
*
* @note This must be tied with a parent DecagonES2 before it can be used.
*/
DecagonES2_Cond()
: Variable((const uint8_t)ES2_COND_VAR_NUM,
(uint8_t)ES2_COND_RESOLUTION, ES2_COND_VAR_NAME,
ES2_COND_UNIT_NAME, ES2_COND_DEFAULT_CODE) {}
/**
* @brief Destroy the DecagonES2_Cond object - no action neede
```
<Overlap Ratio: 0.9553072625698324>

---

--- 257 --
Question ID: 2ee9ca7a194a90438de0ebca2dbcf2509eda4768_0
Original Code:
```
class WebHistoryServiceFactory : public BrowserContextKeyedServiceFactory {
 public:
  // Get the singleton instance of the factory.
  static WebHistoryServiceFactory* GetInstance();

  // Get the WebHistoryService for |profile|, creating one if needed.
  static history::WebHistoryService* GetForProfile(Profile* profile);

  WebHistoryServiceFactory(const WebHistoryServiceFactory&) = delete;
  WebHistoryServiceFactory& operator=(const WebHistoryServiceFactory&) = delete;

 protected:
  // Overridden from BrowserContextKeyedServiceFactory.
  KeyedService* BuildServiceInstanceFor(
      content::BrowserContext* context) const override;

 private:
  friend struct base::DefaultSingletonTraits<WebHistoryServiceFactory>;

  WebHistoryServiceFactory();
  ~WebHistoryServiceFactory() override;
}
```


Overlapping Code:
```
ServiceFactory : public BrowserContextKeyedServiceFactory {
public:
// Get the singleton instance of the factory.
static WebHistoryServiceFactory* GetInstance();
// Get the WebHistoryService for |profile|, creating one if needed.
static history::WebHistoryService* GetForProfile(Profile* profile);
WebHistoryServiceFactory(const WebHistoryServiceFactory&) = delete;
WebHistoryServiceFactory& operator=(const WebHistoryServiceFactory&) = delete;
protected:
// Overridden from BrowserContextKeyedServiceFactory.
KeyedService* BuildServiceInstanceFor(
content::BrowserContext* context) const override;
private:
friend struct base::DefaultSingletonTraits<WebHistoryServiceFactory>;
WebHistoryServiceFactory();
~WebHistoryServiceFactory() o
```
<Overlap Ratio: 0.9658344283837057>

---

--- 258 --
Question ID: e0b8bb7e849387069c81697f48cd76138e681886_79
Original Code:
```
int r1fgkf_f(int *ido, int *ip, int *l1, int *
	idl1, float *cc, float *c1, float *c2, int *in1, float *ch, float *ch2,
	 int *in2, float *wa)
{
    /* System generated locals */
    int ch_dim1, ch_dim2, ch_dim3, ch_offset, cc_dim1, cc_dim2, cc_dim3,
	    cc_offset, c1_dim1, c1_dim2, c1_dim3, c1_offset, c2_dim1, c2_dim2,
	     c2_offset, ch2_dim1, ch2_dim2, ch2_offset, i__1, i__2, i__3;

    /* Builtin functions */

    /* Local variables */
     int i__, j, k, l, j2, ic, jc, lc, ik, is;
     float dc2, ai1, ai2, ar1, ar2, ds2;
     int nbd;
     float dcp, arg, dsp, tpi, ar1h, ar2h;
     int idp2, ipp2, idij, ipph;


    /* Parameter adjustments */
    --wa;
    c2_dim1 = *in1;
    c2_dim2 = *idl1;
    c2_offset = 1 + c2_dim1 * (1 + c2_dim2);
    c2 -= c2_offset;
    c1_dim1 = *in1;
    c1_dim2 = *ido;
    c1_dim3 = *l1;
    c1_offset = 1 + c1_dim1 * (1 + c1_dim2 * (1 + c1_dim3));
    c1 -= c1_offset;
    cc_dim1 = *in1;
    cc_dim2 = *ido;
    cc_dim3 = *ip;
    cc_offset = 1 + cc_dim1 * (1 + cc_dim2 * (1 + cc_dim3));
    cc -= cc_offset;
    ch2_dim1 = *in2;
    ch2_dim2 = *idl1;
    ch2_offset = 1 + ch2_dim1 * (1 + ch2_dim2);
    ch2 -= ch2_offset;
    ch_dim1 = *in2;
    ch_dim2 = *ido;
    ch_dim3 = *l1;
    ch_offset = 1 + ch_dim1 * (1 + ch_dim2 * (1 + ch_dim3));
    ch -= ch_offset;

    /* Function Body */
    tpi = atanf(1.0f) * 8.0f;
    arg = tpi / (float) (*ip);
    dcp = cosf(arg);
    dsp = sinf(arg);
    ipph = (*ip + 1) / 2;
    ipp2 = *ip + 2;
    idp2 = *ido + 2;
    nbd = (*ido - 1) / 2;
    if (*ido == 1) {
	goto L119;
    }
    i__1 = *idl1;
    for (ik = 1; ik <= i__1; ++ik) {
	ch2[(ik + ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) * c2_dim1 + 1]
		;
/* L101: */
    }
    i__1 = *ip;
    for (j = 2; j <= i__1; ++j) {
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    ch[((k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] = c1[((k + j *
		     c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1];
/* L102: */
	}
/* L103: */
    }
    if (nbd > *l1) {
	goto L107;
    }
    is = -(*ido);
    i__1 = *ip;
    for (j = 2; j <= i__1; ++j) {
	is += *ido;
	idij = is;
	i__2 = *ido;
	for (i__ = 3; i__ <= i__2; i__ += 2) {
	    idij += 2;
	    i__3 = *l1;
	    for (k = 1; k <= i__3; ++k) {
		ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =
			wa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *
			c1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j
			* c1_dim3) * c1_dim2) * c1_dim1 + 1];
		ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[
			idij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *
			c1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *
			c1_dim3) * c1_dim2) * c1_dim1 + 1];
/* L104: */
	    }
/* L105: */
	}
/* L106: */
    }
    goto L111;
L107:
    is = -(*ido);
    i__1 = *ip;
    for (j = 2; j <= i__1; ++j) {
	is += *ido;
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    idij = is;
	    i__3 = *ido;
	    for (i__ = 3; i__ <= i__3; i__ += 2) {
		idij += 2;
		ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =
			wa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *
			c1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j
			* c1_dim3) * c1_dim2) * c1_dim1 + 1];
		ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] = wa[
			idij - 1] * c1[(i__ + (k + j * c1_dim3) * c1_dim2) *
			c1_dim1 + 1] - wa[idij] * c1[(i__ - 1 + (k + j *
			c1_dim3) * c1_dim2) * c1_dim1 + 1];
/* L108: */
	    }
/* L109: */
	}
/* L110: */
    }
L111:
    if (nbd < *l1) {
	goto L115;
    }
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    i__3 = *ido;
	    for (i__ = 3; i__ <= i__3; i__ += 2) {
		c1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =
			ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1
			+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *
			ch_dim1 + 1];
		c1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =
			ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
		c1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(
			i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +
			ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			;
		c1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(
			i__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			 - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1];
/* L112: */
	    }
/* L113: */
	}
/* L114: */
    }
    goto L121;
L115:
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	i__2 = *ido;
	for (i__ = 3; i__ <= i__2; i__ += 2) {
	    i__3 = *l1;
	    for (k = 1; k <= i__3; ++k) {
		c1[(i__ - 1 + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] =
			ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1
			+ 1] + ch[(i__ - 1 + (k + jc * ch_dim3) * ch_dim2) *
			ch_dim1 + 1];
		c1[(i__ - 1 + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] =
			ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			- ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
		c1[(i__ + (k + j * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(
			i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] +
			ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			;
		c1[(i__ + (k + jc * c1_dim3) * c1_dim2) * c1_dim1 + 1] = ch[(
			i__ - 1 + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			 - ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1];
/* L116: */
	    }
/* L117: */
	}
/* L118: */
    }
    goto L121;
L119:
    i__1 = *idl1;
    for (ik = 1; ik <= i__1; ++ik) {
	c2[(ik + c2_dim2) * c2_dim1 + 1] = ch2[(ik + ch2_dim2) * ch2_dim1 + 1]
		;
/* L120: */
    }
L121:
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    c1[((k + j * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k + j *
		     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] + ch[((k + jc *
		    ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];
	    c1[((k + jc * c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1] = ch[((k +
		    jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] - ch[((k + j *
		     ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];
/* L122: */
	}
/* L123: */
    }

    ar1 = 1.0f;
    ai1 = 0.0f;
    i__1 = ipph;
    for (l = 2; l <= i__1; ++l) {
	lc = ipp2 - l;
	ar1h = dcp * ar1 - dsp * ai1;
	ai1 = dcp * ai1 + dsp * ar1;
	ar1 = ar1h;
	i__2 = *idl1;
	for (ik = 1; ik <= i__2; ++ik) {
	    ch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) *
		    c2_dim1 + 1] + ar1 * c2[(ik + (c2_dim2 << 1)) * c2_dim1 +
		    1];
	    ch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] = ai1 * c2[(ik + *ip *
		    c2_dim2) * c2_dim1 + 1];
/* L124: */
	}
	dc2 = ar1;
	ds2 = ai1;
	ar2 = ar1;
	ai2 = ai1;
	i__2 = ipph;
	for (j = 3; j <= i__2; ++j) {
	    jc = ipp2 - j;
	    ar2h = dc2 * ar2 - ds2 * ai2;
	    ai2 = dc2 * ai2 + ds2 * ar2;
	    ar2 = ar2h;
	    i__3 = *idl1;
	    for (ik = 1; ik <= i__3; ++ik) {
		ch2[(ik + l * ch2_dim2) * ch2_dim1 + 1] += ar2 * c2[(ik + j *
			c2_dim2) * c2_dim1 + 1];
		ch2[(ik + lc * ch2_dim2) * ch2_dim1 + 1] += ai2 * c2[(ik + jc
			* c2_dim2) * c2_dim1 + 1];
/* L125: */
	    }
/* L126: */
	}
/* L127: */
    }
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	i__2 = *idl1;
	for (ik = 1; ik <= i__2; ++ik) {
	    ch2[(ik + ch2_dim2) * ch2_dim1 + 1] += c2[(ik + j * c2_dim2) *
		    c2_dim1 + 1];
/* L128: */
	}
/* L129: */
    }

    if (*ido < *l1) {
	goto L132;
    }
    i__1 = *l1;
    for (k = 1; k <= i__1; ++k) {
	i__2 = *ido;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +
		    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];
/* L130: */
	}
/* L131: */
    }
    goto L135;
L132:
    i__1 = *ido;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    cc[(i__ + (k * cc_dim3 + 1) * cc_dim2) * cc_dim1 + 1] = ch[(i__ +
		    (k + ch_dim3) * ch_dim2) * ch_dim1 + 1];
/* L133: */
	}
/* L134: */
    }
L135:
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	j2 = j + j;
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    cc[(*ido + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] = ch[(
		    (k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];
	    cc[((j2 - 1 + k * cc_dim3) * cc_dim2 + 1) * cc_dim1 + 1] = ch[((k
		    + jc * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1];
/* L136: */
	}
/* L137: */
    }
    if (*ido == 1) {
	return 0;
    }
    if (nbd < *l1) {
	goto L141;
    }
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	j2 = j + j;
	i__2 = *l1;
	for (k = 1; k <= i__2; ++k) {
	    i__3 = *ido;
	    for (i__ = 3; i__ <= i__3; i__ += 2) {
		ic = idp2 - i__;
		cc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]
			 = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *
			ch_dim2) * ch_dim1 + 1];
		cc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]
			= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *
			ch_dim2) * ch_dim1 + 1];
		cc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =
			ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
		cc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =
			ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			 - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
/* L138: */
	    }
/* L139: */
	}
/* L140: */
    }
    return 0;
L141:
    i__1 = ipph;
    for (j = 2; j <= i__1; ++j) {
	jc = ipp2 - j;
	j2 = j + j;
	i__2 = *ido;
	for (i__ = 3; i__ <= i__2; i__ += 2) {
	    ic = idp2 - i__;
	    i__3 = *l1;
	    for (k = 1; k <= i__3; ++k) {
		cc[(i__ - 1 + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]
			 = ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1] + ch[(i__ - 1 + (k + jc * ch_dim3) *
			ch_dim2) * ch_dim1 + 1];
		cc[(ic - 1 + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1]
			= ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) *
			ch_dim1 + 1] - ch[(i__ - 1 + (k + jc * ch_dim3) *
			ch_dim2) * ch_dim1 + 1];
		cc[(i__ + (j2 - 1 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =
			ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			+ ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
		cc[(ic + (j2 - 2 + k * cc_dim3) * cc_dim2) * cc_dim1 + 1] =
			ch[(i__ + (k + jc * ch_dim3) * ch_dim2) * ch_dim1 + 1]
			 - ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 +
			1];
/* L142: */
	    }
/* L143: */
	}
/* L144: */
    }
    return 0;
}
```


Overlapping Code:
```
*l1, int *
idl1, float *cc, float *c1, float *c2, int *in1, float *ch, float *ch2,
int *in2, float *wa)
{
/* System generated locals */
int ch_dim1, ch_dim2, ch_dim3, ch_offset, cc_dim1, cc_dim2, cc_dim3,
cc_offset, c1_dim1, c1_dim2, c1_dim3, c1_offset, c2_dim1, c2_dim2,
c2_offset, ch2_dim1, ch2_dim2, ch2_offset, i__1, i__2, i__3;
/* Builtin functions */
/* Local variables */
int i__, j, k, l, j2, ic, jc, lc, ik, is;
float dc2, ai1, ai2, ar1, ar2, ds2;
int nbd;
float dcp, arg, dsp, tpi, ar1h, ar2h;
int idp2, ipp2, idij, ipph;
/* Parameter adjustments */
--wa;
c2_dim1 = *in1;
c2_dim2 = *idl1;
c2_offset = 1 + c2_dim1 * (1 + c2_dim2);
c2 -= c2_offset;
c1_dim1 = *in1;
c1_dim2 = *ido;
c1_dim3 = *l1;
c1_offset = 1 + c1_dim1 * (1 + c1_dim2 * (1 + c1_dim3));
c1 -= c1_offset;
cc_dim1 = *in1;
cc_dim2 = *ido;
cc_dim3 = *ip;
cc_offset = 1 + cc_dim1 * (1 + cc_dim2 * (1 + cc_dim3));
cc -= cc_offset;
ch2_dim1 = *in2;
ch2_dim2 = *idl1;
ch2_offset = 1 + ch2_dim1 * (1 + ch2_dim2);
ch2 -= ch2_offset;
ch_dim1 = *in2;
ch_dim2 = *ido;
ch_dim3 = *l1;
ch_offset = 1 + ch_dim1 * (1 + ch_dim2 * (1 + ch_dim3));
ch -= ch_offset;
/* Function Body */
tpi = atanf(1.0f) * 8.0f;
arg = tpi / (float) (*ip);
dcp = cosf(arg);
dsp = sinf(arg);
ipph = (*ip + 1) / 2;
ipp2 = *ip + 2;
idp2 = *ido + 2;
nbd = (*ido - 1) / 2;
if (*ido == 1) {
goto L119;
}
i__1 = *idl1;
for (ik = 1; ik <= i__1; ++ik) {
ch2[(ik + ch2_dim2) * ch2_dim1 + 1] = c2[(ik + c2_dim2) * c2_dim1 + 1]
;
/* L101: */
}
i__1 = *ip;
for (j = 2; j <= i__1; ++j) {
i__2 = *l1;
for (k = 1; k <= i__2; ++k) {
ch[((k + j * ch_dim3) * ch_dim2 + 1) * ch_dim1 + 1] = c1[((k + j *
c1_dim3) * c1_dim2 + 1) * c1_dim1 + 1];
/* L102: */
}
/* L103: */
}
if (nbd > *l1) {
goto L107;
}
is = -(*ido);
i__1 = *ip;
for (j = 2; j <= i__1; ++j) {
is += *ido;
idij = is;
i__2 = *ido;
for (i__ = 3; i__ <= i__2; i__ += 2) {
idij += 2;
i__3 = *l1;
for (k = 1; k <= i__3; ++k) {
ch[(i__ - 1 + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1] =
wa[idij - 1] * c1[(i__ - 1 + (k + j * c1_dim3) *
c1_dim2) * c1_dim1 + 1] + wa[idij] * c1[(i__ + (k + j
* c1_dim3) * c1_dim2) * c1_dim1 + 1];
ch[(i__ + (k + j * ch_dim3) * ch_dim2) * ch_dim1 + 1]
```
<Overlap Ratio: 0.9808656036446469>

---

--- 259 --
Question ID: 7f77db5d12789fce8a012bb0b3048f1a9c82558f_0
Original Code:
```
static void srr_dqp_index_advc(struct bdc *bdc, u32 srr_num)
{
	struct srr *srr;

	srr = &bdc->srr;
	dev_dbg_ratelimited(bdc->dev, "srr->dqp_index:%d\n", srr->dqp_index);
	srr->dqp_index++;
	/* rollback to 0 if we are past the last */
	if (srr->dqp_index == NUM_SR_ENTRIES)
		srr->dqp_index = 0;
}
```


Overlapping Code:
```
u32 srr_num)
{
struct srr *srr;
srr = &bdc->srr;
dev_dbg_ratelimited(bdc->dev, "srr->dqp_index:%d\n", srr->dqp_index);
srr->dqp_index++;
/* rollback to 0 if we are past the last */
if (srr->dqp_index 
```
<Overlap Ratio: 0.6944444444444444>

---

--- 260 --
Question ID: f0e9048cd1e615ea355e4c8f6ea91cc9027f4eb1_0
Original Code:
```
void
lws_tls_err_describe(void)
{
	char buf[128];
	unsigned long l;

	do {
		l = ERR_get_error();
		if (!l)
			break;
		ERR_error_string_n(l, buf, sizeof(buf));
		lwsl_info("   openssl error: %s\n", buf);
	} while (l);
	lwsl_info("\n");
}
```


Overlapping Code:
```
];
unsigned long l;
do {
l = ERR_get_error();
if (!l)
break;
ERR_error_string_n(l, buf, sizeof(buf));
lwsl_info(" openssl error: %s\n", buf);
} while 
```
<Overlap Ratio: 0.684931506849315>

---

--- 261 --
Question ID: 7654c82cd3852f8c1cbd58044a7a9cc01f543e82_18
Original Code:
```
static int strdupped_cmp(const void *a, const void *b)
{
    char *c = *(char**)a;
    char *d = *(char**)b;

    return strcmp(c, d);
}
```


Overlapping Code:
```
tic int strdupped_cmp(const void *a, const void *b)
{
char *c = *(char**)a;
char *d = *(char**)b;
re
```
<Overlap Ratio: 0.8130081300813008>

---

--- 262 --
Question ID: d22f4d10413fece73cd4bf5f0427e6ac34eac4e8_10
Original Code:
```
static int tegra_spi_start_dma_based_transfer(
		struct tegra_spi_data *tspi, struct spi_transfer *t)
{
	u32 val;
	unsigned int len;
	int ret = 0;
	u8 dma_burst;
	struct dma_slave_config dma_sconfig = {0};

	val = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);
	tegra_spi_writel(tspi, val, SPI_DMA_BLK);

	if (tspi->is_packed)
		len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
					4) * 4;
	else
		len = tspi->curr_dma_words * 4;

	/* Set attention level based on length of transfer */
	if (len & 0xF) {
		val |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;
		dma_burst = 1;
	} else if (((len) >> 4) & 0x1) {
		val |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;
		dma_burst = 4;
	} else {
		val |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;
		dma_burst = 8;
	}

	if (!tspi->soc_data->has_intr_mask_reg) {
		if (tspi->cur_direction & DATA_DIR_TX)
			val |= SPI_IE_TX;

		if (tspi->cur_direction & DATA_DIR_RX)
			val |= SPI_IE_RX;
	}

	tegra_spi_writel(tspi, val, SPI_DMA_CTL);
	tspi->dma_control_reg = val;

	dma_sconfig.device_fc = true;
	if (tspi->cur_direction & DATA_DIR_TX) {
		dma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;
		dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
		dma_sconfig.dst_maxburst = dma_burst;
		ret = dmaengine_slave_config(tspi->tx_dma_chan, &dma_sconfig);
		if (ret < 0) {
			dev_err(tspi->dev,
				"DMA slave config failed: %d\n", ret);
			return ret;
		}

		tegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);
		ret = tegra_spi_start_tx_dma(tspi, len);
		if (ret < 0) {
			dev_err(tspi->dev,
				"Starting tx dma failed, err %d\n", ret);
			return ret;
		}
	}

	if (tspi->cur_direction & DATA_DIR_RX) {
		dma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;
		dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
		dma_sconfig.src_maxburst = dma_burst;
		ret = dmaengine_slave_config(tspi->rx_dma_chan, &dma_sconfig);
		if (ret < 0) {
			dev_err(tspi->dev,
				"DMA slave config failed: %d\n", ret);
			return ret;
		}

		/* Make the dma buffer to read by dma */
		dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
				tspi->dma_buf_size, DMA_FROM_DEVICE);

		ret = tegra_spi_start_rx_dma(tspi, len);
		if (ret < 0) {
			dev_err(tspi->dev,
				"Starting rx dma failed, err %d\n", ret);
			if (tspi->cur_direction & DATA_DIR_TX)
				dmaengine_terminate_all(tspi->tx_dma_chan);
			return ret;
		}
	}
	tspi->is_curr_dma_xfer = true;
	tspi->dma_control_reg = val;

	val |= SPI_DMA_EN;
	tegra_spi_writel(tspi, val, SPI_DMA_CTL);
	return ret;
}
```


Overlapping Code:
```
tatic int tegra_spi_start_dma_based_transfer(
struct tegra_spi_data *tspi, struct spi_transfer *t)
{
u32 val;
unsigned int len;
int ret = 0;
u8 dma_burst;
struct dma_slave_config dma_sconfig = {0};
val = SPI_DMA_BLK_SET(tspi->curr_dma_words - 1);
tegra_spi_writel(tspi, val, SPI_DMA_BLK);
if (tspi->is_packed)
len = DIV_ROUND_UP(tspi->curr_dma_words * tspi->bytes_per_word,
4) * 4;
else
len = tspi->curr_dma_words * 4;
/* Set attention level based on length of transfer */
if (len & 0xF) {
val |= SPI_TX_TRIG_1 | SPI_RX_TRIG_1;
dma_burst = 1;
} else if (((len) >> 4) & 0x1) {
val |= SPI_TX_TRIG_4 | SPI_RX_TRIG_4;
dma_burst = 4;
} else {
val |= SPI_TX_TRIG_8 | SPI_RX_TRIG_8;
dma_burst = 8;
}
if (!tspi->soc_data->has_intr_mask_reg) {
if (tspi->cur_direction & DATA_DIR_TX)
val |= SPI_IE_TX;
if (tspi->cur_direction & DATA_DIR_RX)
val |= SPI_IE_RX;
}
tegra_spi_writel(tspi, val, SPI_DMA_CTL);
tspi->dma_control_reg = val;
dma_sconfig.device_fc = true;
if (tspi->cur_direction & DATA_DIR_TX) {
dma_sconfig.dst_addr = tspi->phys + SPI_TX_FIFO;
dma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
dma_sconfig.dst_maxburst = dma_burst;
ret = dmaengine_slave_config(tspi->tx_dma_chan, &dma_sconfig);
if (ret < 0) {
dev_err(tspi->dev,
"DMA slave config failed: %d\n", ret);
return ret;
}
tegra_spi_copy_client_txbuf_to_spi_txbuf(tspi, t);
ret = tegra_spi_start_tx_dma(tspi, len);
if (ret < 0) {
dev_err(tspi->dev,
"Starting tx dma failed, err %d\n", ret);
return ret;
}
}
if (tspi->cur_direction & DATA_DIR_RX) {
dma_sconfig.src_addr = tspi->phys + SPI_RX_FIFO;
dma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
dma_sconfig.src_maxburst = dma_burst;
ret = dmaengine_slave_config(tspi->rx_dma_chan, &dma_sconfig);
if (ret < 0) {
dev_err(tspi->dev,
"DMA slave config failed: %d\n", ret);
return ret;
}
/* Make the dma buffer to read by dma */
dma_sync_single_for_device(tspi->dev, tspi->rx_dma_phys,
tspi->dma_buf_size, DMA_FROM_DEVICE);
ret = tegra_spi_start_rx_dma(tspi, len);
if (ret < 0) {
dev_err(tspi->dev,
"Starting rx dma failed, err %d\n", ret);
if (tspi->cur_direction & DATA_DIR_TX)
dmaengine_terminate_all(tspi->tx_dma_chan);
return ret;
}
}
tspi->is_curr_dma_xfer = true;
tspi->dma_control_reg = val;
val |= SPI_DMA_EN;
tegra_spi_writel(tspi, val, SPI_DMA_CTL
```
<Overlap Ratio: 0.9925861317051897>

---

--- 263 --
Question ID: 6192e4dce7f50f5188691999a83a09336c742eac_0
Original Code:
```
void insertBlind(const TypeID &id, Type obj)
  {
    HashItem *item = new HashItem(id, obj);
    item->next( _table[hash(id)] );
    _table[hash(id)] = item;
    _numElements++;
  }
```


Overlapping Code:
```
peID &id, Type obj)
{
HashItem *item = new HashItem(id, obj);
item->next( _table[hash(id)] );
_table
```
<Overlap Ratio: 0.6211180124223602>

---

--- 264 --
Question ID: 3e48183360b39b649783216ac1a862953b500294_1
Original Code:
```
static void recovery_image_observer_pcr_test_init_null (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	struct pcr_store store;
	uint8_t num_pcr_measurements[] = {6, 6};
	struct recovery_image_observer_pcr observer;
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&store, num_pcr_measurements, sizeof (num_pcr_measurements));
	CuAssertIntEquals (test, 0, status);

	status = recovery_image_observer_pcr_init (NULL, &hash.base, &store, PCR_MEASUREMENT (0, 0));
	CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);

	status = recovery_image_observer_pcr_init (&observer, NULL, &store, PCR_MEASUREMENT (0, 0));
	CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);

	status = recovery_image_observer_pcr_init (&observer, &hash.base, NULL, PCR_MEASUREMENT (0, 0));
	CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);

	pcr_store_release (&store);
	HASH_TESTING_ENGINE_RELEASE (&hash);
}
```


Overlapping Code:
```
erver_pcr_test_init_null (CuTest *test)
{
HASH_TESTING_ENGINE hash;
struct pcr_store store;
uint8_t num_pcr_measurements[] = {6, 6};
struct recovery_image_observer_pcr observer;
int status;
TEST_START;
status = HASH_TESTING_ENGINE_INIT (&hash);
CuAssertIntEquals (test, 0, status);
status = pcr_store_init (&store, num_pcr_measurements, sizeof (num_pcr_measurements));
CuAssertIntEquals (test, 0, status);
status = recovery_image_observer_pcr_init (NULL, &hash.base, &store, PCR_MEASUREMENT (0, 0));
CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);
status = recovery_image_observer_pcr_init (&observer, NULL, &store, PCR_MEASUREMENT (0, 0));
CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);
status = recovery_image_observer_pcr_init (&observer, &hash.base, NULL, PCR_MEASUREMENT (0, 0));
CuAssertIntEquals (test, RECOVERY_IMAGE_OBSERVER_INVALID_ARGUMENT, status);
pcr_store_release (&store);
HASH_TESTING_ENGINE_RELEASE (&hash);
}
```
<Overlap Ratio: 0.9704142011834319>

---

--- 265 --
Question ID: e1ea28dc0ab3d77af54eb173ec5383a2d1acfe3b_7
Original Code:
```
void obj_read_data(struct object *obj, size_t start, size_t len, void *ptr)
{
	start += OBJ_NULLPAGE_SIZE;
	assert(start < OBJ_MAXSIZE && start + len <= OBJ_MAXSIZE && len < OBJ_MAXSIZE);
	void *addr = (char *)obj_get_kaddr(obj) + start;
	memcpy(ptr, addr, len);
	obj_release_kaddr(obj);
}
```


Overlapping Code:
```
void obj_read_data(struct object *obj, size_t start, size_t len, void *ptr)
{
start += OBJ_NULLPAGE_SIZE;
assert(start < OBJ_MAXSIZE && start + len <= OBJ_MAXSIZE && len < OBJ_MAXSIZE);
void *addr = (char *)obj_get_kaddr(obj) + start;

```
<Overlap Ratio: 0.8274647887323944>

---

--- 266 --
Question ID: 15bb3296d3667296758fe057fcdfccf0f874c873_204
Original Code:
```
static void FMPI_Group_excl(MPI_Fint *group, MPI_Fint *n, MPI_Fint *ranks, MPI_Fint *newgroup, MPI_Fint *ierr)
{
#ifdef DEBUG_MPI
	int debug_rank;
	PMPI_Comm_rank(MPI_COMM_WORLD, &debug_rank);
	printf("[DEBUG][RANK:%d] Start MPI_Group_excl()\n", debug_rank);
#endif
	call_start(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);
	pmpi_group_excl_(group, n, ranks, newgroup, ierr);
    call_end(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);
#ifdef DEBUG_MPI
	printf("[DEBUG][RANK:%d] End MPI_Group_excl()\n", debug_rank);
#endif
}
```


Overlapping Code:
```
_Group_excl(MPI_Fint *group, MPI_Fint *n, MPI_Fint *ranks, MPI_Fint *newgroup, MPI_Fint *ierr)
{
#ifdef DEBUG_MPI
int debug_rank;
PMPI_Comm_rank(MPI_COMM_WORLD, &debug_rank);
printf("[DEBUG][RANK:%d] Start MPI_Group_excl()\n", debug_rank);
#endif
call_start(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);
pmpi_group_excl_(group, n, ranks, newgroup, ierr);
call_end(__MPI_GROUP_EXCL, MPI_COMM_WORLD, MPI_NONE);
#ifdef DEBUG_MPI
printf("[DEBUG][RANK:%d] End MPI_Group_
```
<Overlap Ratio: 0.90625>

---

--- 267 --
Question ID: 33a1236db798561b21873901e7fbdbd7dcd0ed17_16
Original Code:
```
INLINE void OPM_OperatorPhase6(opm_t* const chip)
{
    //uint32_t slot = (chip->cycles + 27) & 31;
    chip->op_atten = chip->op_logsin[2] + (chip->eg_out[1] << 2);
    if (chip->op_atten & 4096)
    {
        chip->op_atten = 4095;
    }
}
```


Overlapping Code:
```
hase6(opm_t* const chip)
{
//uint32_t slot = (chip->cycles + 27) & 31;
chip->op_atten = chip->op_logsin[2] + (chip->eg_out[1] << 2);
if (chip->op_atte
```
<Overlap Ratio: 0.704225352112676>

---

--- 268 --
Question ID: ef547420ae3d38f1d803a742cf1c9935a929f98b_3
Original Code:
```
uint32_t get_uart_clock(uint32_t instance)
{
    // LPUART1 clock has been configured to 20MHz in clock_configure
    uint32_t lpuart_clock = 20000000UL;

    return lpuart_clock;
}
```


Overlapping Code:
```
int32_t get_uart_clock(uint32_t instance)
{
// LPUART1 clock has been configured to 20MHz in clock_configure
uint32_t lpuart_clock = 20000000UL;
return l
```
<Overlap Ratio: 0.9107142857142857>

---

--- 269 --
Question ID: 7000115bb64b2c3dd3a846d2d4ac6055d9dfab3d_1
Original Code:
```
void NOINLINE check_equal32(void *vgot, void *vexpected, void *vexpected_orig,
                            int mask, char *banner) {
  int i;
  V512 *got = (V512 *)vgot;
  V512 *expected = (V512 *)vexpected;
  V512 *orig = (V512 *)vexpected_orig;

  for (i = 0; i < 16; i++) {
    int ans = (mask & (1 << i)) ? expected->u32[i] : orig->u32[i];
    if (got->u32[i] != ans) {
      printf("ERROR: %s failed -- 0x%0.8x != 0x%0.8x at element [%d]\n",
             banner ? banner : "", got->u32[i], ans, i);
      n_errs++;
      break;
    }
  }
}
```


Overlapping Code:
```
d NOINLINE check_equal32(void *vgot, void *vexpected, void *vexpected_orig,
int mask, char *banner) {
int i;
V512 *got = (V512 *)vgot;
V512 *expected = (V512 *)vexpected;
V512 *orig = (V512 *)vexpected_orig;
for (i = 0; i < 16; i++) {
int ans = (mask & (1 << i)) ? expected->u32[i] : orig->u32[i];
if (got->u32[i] != ans) {
printf("ERROR: %s failed -- 0x%0.8x != 0x%0.8x at element [%d]\n",
banner ? banner : "", got->u
```
<Overlap Ratio: 0.9108695652173913>

---

--- 270 --
Question ID: d734f53c54e815ba4c2698c042f853429deb3600_9
Original Code:
```
trble_result_e rtw_ble_client_read_connected_device_list(trble_connected_list* out_connected_list)
{ 
    if (out_connected_list == NULL)
    {
        return TRBLE_FAIL;
    }
    
    memset(out_connected_list, 0, sizeof(trble_connected_list));
    for(uint16_t i = 0; i < ble_app_link_table_size; i++)
    {
        if(ble_app_link_table[i].conn_state == GAP_CONN_STATE_CONNECTED)
        {
            out_connected_list->connected_count++;
            out_connected_list->conn_handle[i] =  ble_app_link_table[i].conn_id;
        }
    }
    return TRBLE_SUCCESS; 
}
```


Overlapping Code:
```
ble_result_e rtw_ble_client_read_connected_device_list(trble_connected_list* out_connected_list)
{ 
if (out_connected_list == NULL)
{
return TRBLE_FAIL;
}

memset(out_connected_list, 0, sizeof(trble_connected_list));
for(uint16_t i = 0; i < ble_app_link_table_size; i++)
{
if(ble_app_link_table[i].conn_state == GAP_CONN_STATE_CONNECTED)
{
out_connected_list->connected_count++;
out_connected_list->conn_handle[i] = ble_app_link_table[i].conn_id;
}
}
return 
```
<Overlap Ratio: 0.960167714884696>

---

--- 271 --
Question ID: 96cc99fedcc35d4da86afc3b2c18ae40cba78a08_3
Original Code:
```
static inline const char *parse_hex_uint64(const char *buf, size_t len, uint64_t *value, int *status)
{
    buf = parse_hex_integer(buf, len, value, status);
    if (*status == PARSE_INTEGER_SIGNED) {
        *status = PARSE_INTEGER_UNDERFLOW;
        return 0;
    }
    return buf;
}
```


Overlapping Code:
```
arse_hex_uint64(const char *buf, size_t len, uint64_t *value, int *status)
{
buf = parse_hex_integer(buf, len, value, status);
if (*status == PARSE_INTEGER_SIGNED) {
*status = PARSE_INTEGER_UNDERFLOW;
ret
```
<Overlap Ratio: 0.8063241106719368>

---

--- 272 --
Question ID: fc979b203074aa7d050c4d94b74129233d2365fa_6
Original Code:
```
BOOL
CheckBufferSize(
    HWND hDlg,
    UINT Item,
    LPLINKDATA pld,
    INT i
    )
/*++

    Checks to make sure the buffer size is not smaller than the window size

    Returns: TRUE if preview window should be updated
             FALSE if not

--*/
{
    BOOL fRet = FALSE;

    if (!pld)
     return fRet;

    switch (Item)
    {

    case IDC_CNSL_SCRBUF_WIDTHSCROLL:
    case IDC_CNSL_SCRBUF_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.X > i)
            {
                pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_WIDTH,
                               pld->cpd.lpConsole->dwWindowSize.X,
                               TRUE
                              );

                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_SCRBUF_HEIGHTSCROLL:
    case IDC_CNSL_SCRBUF_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwWindowSize.Y > i)
            {
                pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_WINDOW_HEIGHT,
                               pld->cpd.lpConsole->dwWindowSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }
        break;

    case IDC_CNSL_WINDOW_WIDTHSCROLL:
    case IDC_CNSL_WINDOW_WIDTH:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_WIDTH,
                               pld->cpd.lpConsole->dwScreenBufferSize.X,
                               TRUE
                              );
                fRet = TRUE;
            }

        }
        break;

    case IDC_CNSL_WINDOW_HEIGHTSCROLL:
    case IDC_CNSL_WINDOW_HEIGHT:
        if (i >= 1)
        {
            pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
            if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)
            {
                pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
                SetDlgItemInt( hDlg,
                               IDC_CNSL_SCRBUF_HEIGHT,
                               pld->cpd.lpConsole->dwScreenBufferSize.Y,
                               TRUE
                              );
                fRet = TRUE;
            }
        }

    }

    return fRet;

}
```


Overlapping Code:
```
D hDlg,
UINT Item,
LPLINKDATA pld,
INT i
)
/*++
Checks to make sure the buffer size is not smaller than the window size
Returns: TRUE if preview window should be updated
FALSE if not
--*/
{
BOOL fRet = FALSE;
if (!pld)
return fRet;
switch (Item)
{
case IDC_CNSL_SCRBUF_WIDTHSCROLL:
case IDC_CNSL_SCRBUF_WIDTH:
if (i >= 1)
{
pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
if (pld->cpd.lpConsole->dwWindowSize.X > i)
{
pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
SetDlgItemInt( hDlg,
IDC_CNSL_WINDOW_WIDTH,
pld->cpd.lpConsole->dwWindowSize.X,
TRUE
);
fRet = TRUE;
}
}
break;
case IDC_CNSL_SCRBUF_HEIGHTSCROLL:
case IDC_CNSL_SCRBUF_HEIGHT:
if (i >= 1)
{
pld->cpd.lpConsole->dwScreenBufferSize.Y = (SHORT) i;
if (pld->cpd.lpConsole->dwWindowSize.Y > i)
{
pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
SetDlgItemInt( hDlg,
IDC_CNSL_WINDOW_HEIGHT,
pld->cpd.lpConsole->dwWindowSize.Y,
TRUE
);
fRet = TRUE;
}
}
break;
case IDC_CNSL_WINDOW_WIDTHSCROLL:
case IDC_CNSL_WINDOW_WIDTH:
if (i >= 1)
{
pld->cpd.lpConsole->dwWindowSize.X = (SHORT) i;
if (pld->cpd.lpConsole->dwScreenBufferSize.X < i)
{
pld->cpd.lpConsole->dwScreenBufferSize.X = (SHORT) i;
SetDlgItemInt( hDlg,
IDC_CNSL_SCRBUF_WIDTH,
pld->cpd.lpConsole->dwScreenBufferSize.X,
TRUE
);
fRet = TRUE;
}
}
break;
case IDC_CNSL_WINDOW_HEIGHTSCROLL:
case IDC_CNSL_WINDOW_HEIGHT:
if (i >= 1)
{
pld->cpd.lpConsole->dwWindowSize.Y = (SHORT) i;
if (pld->cpd.lpConsole->dwScreenBufferSize.Y < i)
{
pld->cp
```
<Overlap Ratio: 0.9811320754716981>

---

--- 273 --
Question ID: 801daf4ab44dd9aaff62906624d0182e120a9444_13
Original Code:
```
GtkWidget *
gtr_message_log_window_new (GtkWindow * parent, TrCore * core)
{
  GtkWidget * win;
  GtkWidget * vbox;
  GtkWidget * toolbar;
  GtkWidget * w;
  GtkWidget * view;
  GtkToolItem * item;
  struct MsgData * data;

  data = g_new0 (struct MsgData, 1);
  data->core = core;

  win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_window_set_transient_for (GTK_WINDOW (win), parent);
  gtk_window_set_title (GTK_WINDOW (win), _("Message Log"));
  gtk_window_set_default_size (GTK_WINDOW (win), 560, 350);
  gtk_window_set_role (GTK_WINDOW (win), "message-log");
  vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);

  /**
  ***  toolbar
  **/

  toolbar = gtk_toolbar_new ();
  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_BOTH_HORIZ);
  gtk_style_context_add_class (gtk_widget_get_style_context (toolbar),
                               GTK_STYLE_CLASS_PRIMARY_TOOLBAR);

  item = gtk_tool_button_new_from_stock (GTK_STOCK_SAVE_AS);
  g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
  g_signal_connect (item, "clicked", G_CALLBACK (onSaveRequest), data);
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  item = gtk_tool_button_new_from_stock (GTK_STOCK_CLEAR);
  g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
  g_signal_connect (item, "clicked", G_CALLBACK (onClearRequest), data);
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  item = gtk_separator_tool_item_new ();
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  item = gtk_toggle_tool_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);
  g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
  g_signal_connect (item, "toggled", G_CALLBACK (onPauseToggled), data);
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  item = gtk_separator_tool_item_new ();
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  w = gtk_label_new (_("Level"));
  gtk_misc_set_padding (GTK_MISC (w), GUI_PAD, 0);
  item = gtk_tool_item_new ();
  gtk_container_add (GTK_CONTAINER (item), w);
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  w = debug_level_combo_new ();
  g_signal_connect (w, "changed", G_CALLBACK (level_combo_changed_cb), data);
  item = gtk_tool_item_new ();
  gtk_container_add (GTK_CONTAINER (item), w);
  gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);

  gtk_box_pack_start (GTK_BOX (vbox), toolbar, FALSE, FALSE, 0);

  /**
  ***  messages
  **/

  data->store = gtk_list_store_new (N_COLUMNS,
                                    G_TYPE_UINT,       /* sequence */
                                    G_TYPE_POINTER,    /* category */
                                    G_TYPE_POINTER,    /* message */
                                    G_TYPE_POINTER);   /* struct tr_log_message */

  addMessages (data->store, myHead);
  onRefresh (data); /* much faster to populate *before* it has listeners */

  data->filter = gtk_tree_model_filter_new (GTK_TREE_MODEL (data->store), NULL);
  data->sort = gtk_tree_model_sort_new_with_model (data->filter);
  g_object_unref (data->filter);
  gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (data->sort),
                                        COL_SEQUENCE,
                                        GTK_SORT_ASCENDING);
  data->maxLevel = gtr_pref_int_get (TR_KEY_message_level);
  gtk_tree_model_filter_set_visible_func (GTK_TREE_MODEL_FILTER (data->filter),
                                          isRowVisible, data, NULL);


  view = gtk_tree_view_new_with_model (data->sort);
  g_object_unref (data->sort);
  g_signal_connect (view, "button-release-event",
                    G_CALLBACK (on_tree_view_button_released), NULL);
  data->view = GTK_TREE_VIEW (view);
  gtk_tree_view_set_rules_hint (data->view, TRUE);
  appendColumn (data->view, COL_SEQUENCE);
  appendColumn (data->view, COL_NAME);
  appendColumn (data->view, COL_MESSAGE);
  w = gtk_scrolled_window_new (NULL, NULL);
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (w),
                                  GTK_POLICY_AUTOMATIC,
                                  GTK_POLICY_AUTOMATIC);
  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (w),
                                       GTK_SHADOW_IN);
  gtk_container_add (GTK_CONTAINER (w), view);
  gtk_box_pack_start (GTK_BOX (vbox), w, TRUE, TRUE, 0);
  gtk_container_add (GTK_CONTAINER (win), vbox);

  data->refresh_tag = gdk_threads_add_timeout_seconds (SECONDARY_WINDOW_REFRESH_INTERVAL_SECONDS, onRefresh, data);
  g_object_weak_ref (G_OBJECT (win), onWindowDestroyed, data);

  scroll_to_bottom (data);
  gtk_widget_show_all (win);
  return win;
}
```


Overlapping Code:
```
ssage_log_window_new (GtkWindow * parent, TrCore * core)
{
GtkWidget * win;
GtkWidget * vbox;
GtkWidget * toolbar;
GtkWidget * w;
GtkWidget * view;
GtkToolItem * item;
struct MsgData * data;
data = g_new0 (struct MsgData, 1);
data->core = core;
win = gtk_window_new (GTK_WINDOW_TOPLEVEL);
gtk_window_set_transient_for (GTK_WINDOW (win), parent);
gtk_window_set_title (GTK_WINDOW (win), _("Message Log"));
gtk_window_set_default_size (GTK_WINDOW (win), 560, 350);
gtk_window_set_role (GTK_WINDOW (win), "message-log");
vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
/**
*** toolbar
**/
toolbar = gtk_toolbar_new ();
gtk_toolbar_set_style (GTK_TOOLBAR (toolbar), GTK_TOOLBAR_BOTH_HORIZ);
gtk_style_context_add_class (gtk_widget_get_style_context (toolbar),
GTK_STYLE_CLASS_PRIMARY_TOOLBAR);
item = gtk_tool_button_new_from_stock (GTK_STOCK_SAVE_AS);
g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
g_signal_connect (item, "clicked", G_CALLBACK (onSaveRequest), data);
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
item = gtk_tool_button_new_from_stock (GTK_STOCK_CLEAR);
g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
g_signal_connect (item, "clicked", G_CALLBACK (onClearRequest), data);
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
item = gtk_separator_tool_item_new ();
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
item = gtk_toggle_tool_button_new_from_stock (GTK_STOCK_MEDIA_PAUSE);
g_object_set (G_OBJECT (item), "is-important", TRUE, NULL);
g_signal_connect (item, "toggled", G_CALLBACK (onPauseToggled), data);
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
item = gtk_separator_tool_item_new ();
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
w = gtk_label_new (_("Level"));
gtk_misc_set_padding (GTK_MISC (w), GUI_PAD, 0);
item = gtk_tool_item_new ();
gtk_container_add (GTK_CONTAINER (item), w);
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
w = debug_level_combo_new ();
g_signal_connect (w, "changed", G_CALLBACK (level_combo_changed_cb), data);
item = gtk_tool_item_new ();
gtk_container_add (GTK_CONTAINER (item), w);
gtk_toolbar_insert (GTK_TOOLBAR (toolbar), item, -1);
gtk_box_pack_start (GTK_BOX (vbox), toolbar, FALSE, FALSE, 0);
/**
*** messages
**/
data->store = gtk_list_store_new (N
```
<Overlap Ratio: 0.986159169550173>

---

--- 274 --
Question ID: afb95d67121a0995b2f7cd3ecf29df0d92f9d0e1_7
Original Code:
```
int EC_KEY_print(BIO *bp, const EC_KEY *x, int off)
	{
	unsigned char *buffer=NULL;
	size_t	buf_len=0, i;
	int     ret=0, reason=ERR_R_BIO_LIB;
	BIGNUM  *pub_key=NULL, *order=NULL;
	BN_CTX  *ctx=NULL;
	const EC_GROUP *group;
	const EC_POINT *public_key;
	const BIGNUM *priv_key;
 
	if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)
		{
		reason = ERR_R_PASSED_NULL_PARAMETER;
		goto err;
		}

	public_key = EC_KEY_get0_public_key(x);
	if ((pub_key = EC_POINT_point2bn(group, public_key,
		EC_KEY_get_conv_form(x), NULL, ctx)) == NULL)
		{
		reason = ERR_R_EC_LIB;
		goto err;
		}

	buf_len = (size_t)BN_num_bytes(pub_key);
	priv_key = EC_KEY_get0_private_key(x);
	if (priv_key != NULL)
		{
		if ((i = (size_t)BN_num_bytes(priv_key)) > buf_len)
			buf_len = i;
		}

	buf_len += 10;
	if ((buffer = OPENSSL_malloc(buf_len)) == NULL)
		{
		reason = ERR_R_MALLOC_FAILURE;
		goto err;
		}

	if (priv_key != NULL)
		{
		if (!BIO_indent(bp, off, 128))
			goto err;
		if ((order = BN_new()) == NULL)
			goto err;
		if (!EC_GROUP_get_order(group, order, NULL))
			goto err;
		if (BIO_printf(bp, "Private-Key: (%d bit)\n", 
			BN_num_bits(order)) <= 0) goto err;
		}
  
	if ((priv_key != NULL) && !print(bp, "priv:", priv_key, 
		buffer, off))
		goto err;
	if ((pub_key != NULL) && !print(bp, "pub: ", pub_key,
		buffer, off))
		goto err;
	if (!ECPKParameters_print(bp, group, off))
		goto err;
	ret=1;
err:
	if (!ret)
 		ECerr(EC_F_EC_KEY_PRINT, reason);
	if (pub_key) 
		BN_free(pub_key);
	if (order)
		BN_free(order);
	if (ctx)
		BN_CTX_free(ctx);
	if (buffer != NULL)
		OPENSSL_free(buffer);
	return(ret);
	}
```


Overlapping Code:
```
nt(BIO *bp, const EC_KEY *x, int off)
{
unsigned char *buffer=NULL;
size_t buf_len=0, i;
int ret=0, reason=ERR_R_BIO_LIB;
BIGNUM *pub_key=NULL, *order=NULL;
BN_CTX *ctx=NULL;
const EC_GROUP *group;
const EC_POINT *public_key;
const BIGNUM *priv_key;

if (x == NULL || (group = EC_KEY_get0_group(x)) == NULL)
{
reason = ERR_R_PASSED_NULL_PARAMETER;
goto err;
}
public_key = EC_KEY_get0_public_key(x);
if ((pub_key = EC_POINT_point2bn(group, public_key,
EC_KEY_get_conv_form(x), NULL, ctx)) == NULL)
{
reason = ERR_R_EC_LIB;
goto err;
}
buf_len = (size_t)BN_num_bytes(pub_key);
priv_key = EC_KEY_get0_private_key(x);
if (priv_key != NULL)
{
if ((i = (size_t)BN_num_bytes(priv_key)) > buf_len)
buf_len = i;
}
buf_len += 10;
if ((buffer = OPENSSL_malloc(buf_len)) == NULL)
{
reason = ERR_R_MALLOC_FAILURE;
goto err;
}
if (priv_key != NULL)
{
if (!BIO_indent(bp, off, 128))
goto err;
if ((order = BN_new()) == NULL)
goto err;
if (!EC_GROUP_get_order(group, order, NULL))
goto err;
if (BIO_printf(bp, "Private-Key: (%d bit)\n", 
BN_num_bits(order)) <= 0) goto err;
}

if ((priv_key != NULL) && !print(bp, "priv:", priv_key, 
buffer, off))
goto err;
if ((pub_key != NULL) && !print(bp, "pub: ", pub_key,
buffer, off))
goto err;
if (!ECPKParameters_print(bp, group, off))
goto err;
ret=1;
err:
if (!ret)
ECerr(EC_F_EC_KEY_PRINT, reason);
if (pub_key) 
BN_free(pub_key);
if (order)
BN_free(order);
if (ctx)
BN_CTX_free(ctx);
if (buffer != NULL)
OPENSSL_free(buffer);
re
```
<Overlap Ratio: 0.9825033647375505>

---

--- 275 --
Question ID: 648509c95ef66e09e1ff8055746543880639c0c2_8
Original Code:
```
static void inline do_trap(int trapnr, int signr, char *str, int vm86,
			   struct pt_regs * regs, long error_code, siginfo_t *info)
{
	if (regs->eflags & VM_MASK) {
		if (vm86)
			goto vm86_trap;
		else
			goto trap_signal;
	}

	if (!(regs->xcs & 3))
		goto kernel_trap;

	trap_signal: {
		struct task_struct *tsk = current;
		tsk->thread.error_code = error_code;
		tsk->thread.trap_no = trapnr;
		if (info)
			force_sig_info(signr, info, tsk);
		else
			force_sig(signr, tsk);
		return;
	}

	kernel_trap: {
		unsigned long fixup = search_exception_table(regs->eip);
		if (fixup)
			regs->eip = fixup;
		else	
			die(str, regs, error_code);
		return;
	}

	vm86_trap: {
		int ret = handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr);
		if (ret) goto trap_signal;
		return;
	}
}
```


Overlapping Code:
```
_trap(int trapnr, int signr, char *str, int vm86,
struct pt_regs * regs, long error_code, siginfo_t *info)
{
if (regs->eflags & VM_MASK) {
if (vm86)
goto vm86_trap;
else
goto trap_signal;
}
if (!(regs->xcs & 3))
goto kernel_trap;
trap_signal: {
struct task_struct *tsk = current;
tsk->thread.error_code = error_code;
tsk->thread.trap_no = trapnr;
if (info)
force_sig_info(signr, info, tsk);
else
force_sig(signr, tsk);
return;
}
kernel_trap: {
unsigned long fixup = search_exception_table(regs->eip);
if (fixup)
regs->eip = fixup;
else 
die(str, regs, error_code);
return;
}
vm86_trap: {
int ret = handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr);
if (ret) goto trap_signal;
return;
```
<Overlap Ratio: 0.9657064471879286>

---

--- 276 --
Question ID: d6670c30bc7f8d1576a0a74cded7e902823c4440_7
Original Code:
```
void
p448_weak_reduce (
    p448_t *a
) {
    uint64_t mask = (1ull<<56) - 1;
    uint64_t tmp = a->limb[7] >> 56;
    int i;
    a->limb[4] += tmp;
    for (i=7; i>0; i--) {
        a->limb[i] = (a->limb[i] & mask) + (a->limb[i-1]>>56);
    }
    a->limb[0] = (a->limb[0] & mask) + tmp;
}
```


Overlapping Code:
```
48_weak_reduce (
p448_t *a
) {
uint64_t mask = (1ull<<56) - 1;
uint64_t tmp = a->limb[7] >> 56;
int i;
a->limb[4] += tmp;
for (i=7; i>0; i--) {
a->limb[i] = (a->limb[i] & mask) + (a->limb[i-1]>>56);
}
a->limb[0] = (a->limb[0] & mask) + tmp;
}
```
<Overlap Ratio: 0.9718875502008032>

---

--- 277 --
Question ID: aae22a07ed4387375fe1f9c81882dd6acfe6856c_5
Original Code:
```
void osRtxThreadListSort (os_thread_t *thread) {
  os_object_t *object;
  os_thread_t *thread0;

  // Search for object
  thread0 = thread;
  while (thread0->id == osRtxIdThread) {
    thread0 = thread0->thread_prev;
    if (thread0 == NULL) { 
      return;
    }
  }
  object = (os_object_t *)thread0;

  osRtxThreadListRemove(thread);
  osRtxThreadListPut(object, thread);
}
```


Overlapping Code:
```
Sort (os_thread_t *thread) {
os_object_t *object;
os_thread_t *thread0;
// Search for object
thread0 = thread;
while (thread0->id == osRtxIdThread) {
thread0 = thread0->thread_prev;
if (thread0 == NULL) { 
return;
}
}
object = (os_object_t *)thread0;
osRtxThreadListRemove(thread);
osRtxThreadListPut
```
<Overlap Ratio: 0.8849557522123894>

---

--- 278 --
Question ID: ed56841d301fbbdb7b5ac425d6dc4d9f540e2004_0
Original Code:
```
void
xqc_test_id_hash()
{
    xqc_id_hash_table_t hash_tab;
    xqc_id_hash_init(&hash_tab, xqc_default_allocator, 100);

    xqc_id_hash_element_t e1 = {1, "hello"};
    xqc_id_hash_add(&hash_tab, e1);

    xqc_id_hash_element_t e2 = {3, "world"};
    xqc_id_hash_add(&hash_tab, e2);

    xqc_id_hash_element_t e3 = {5, "!"};
    xqc_id_hash_add(&hash_tab, e3);

    char *p1 = xqc_id_hash_find(&hash_tab, 3);
    CU_ASSERT(p1 != NULL);

    void *p2 = xqc_id_hash_find(&hash_tab, 4);
    CU_ASSERT(p2 == NULL);

    int ret = xqc_id_hash_delete(&hash_tab, 3);
    CU_ASSERT(ret == XQC_OK);

    void *p3 = xqc_id_hash_find(&hash_tab, 3);
    CU_ASSERT(p3 == NULL);

    ret = xqc_id_hash_delete(&hash_tab, 4);
    CU_ASSERT(ret != XQC_OK);


    xqc_id_hash_release(&hash_tab);
}
```


Overlapping Code:
```
able_t hash_tab;
xqc_id_hash_init(&hash_tab, xqc_default_allocator, 100);
xqc_id_hash_element_t e1 = {1, "hello"};
xqc_id_hash_add(&hash_tab, e1);
xqc_id_hash_element_t e2 = {3, "world"};
xqc_id_hash_add(&hash_tab, e2);
xqc_id_hash_element_t e3 = {5, "!"};
xqc_id_hash_add(&hash_tab, e3);
char *p1 = xqc_id_hash_find(&hash_tab, 3);
CU_ASSERT(p1 != NULL);
void *p2 = xqc_id_hash_find(&hash_tab, 4);
CU_ASSERT(p2 == NULL);
int ret = xqc_id_hash_delete(&hash_tab, 3);
CU_ASSERT(ret == XQC_OK);
void *p3 = xqc_id_hash_find(&hash_tab, 3);
CU_ASSERT(p3 == NULL);
ret = xqc_id_hash_delete(&hash_tab, 4);
CU_ASSERT(ret != XQC_OK);
xqc_id_hash_release(&hash_t
```
<Overlap Ratio: 0.935251798561151>

---

--- 279 --
Question ID: 3d05c51675fd421e2326362d54f3058964fd8563_64
Original Code:
```
static int n_div_eq(__isl_keep isl_basic_map *bmap)
{
	int i;
	isl_size total, n_div;

	if (!bmap)
		return -1;

	if (bmap->n_eq == 0)
		return 0;

	total = isl_basic_map_dim(bmap, isl_dim_all);
	n_div = isl_basic_map_dim(bmap, isl_dim_div);
	if (total < 0 || n_div < 0)
		return -1;
	total -= n_div;

	for (i = 0; i < bmap->n_eq; ++i)
		if (isl_seq_first_non_zero(bmap->eq[i] + 1 + total,
					    n_div) == -1)
			return i;

	return bmap->n_eq;
}
```


Overlapping Code:
```
(__isl_keep isl_basic_map *bmap)
{
int i;
isl_size total, n_div;
if (!bmap)
return -1;
if (bmap->n_eq == 0)
return 0;
total = isl_basic_map_dim(bmap, isl_dim_all);
n_div = isl_basic_map_dim(bmap, isl_dim_div);
if (total < 0 || n_div < 0)
return -1;
total -= n_div;
for (i = 0; i < bmap->n_eq; ++i)
if (isl_seq_first_non_zero(bmap->eq[i] + 1 + total,

```
<Overlap Ratio: 0.847457627118644>

---

--- 280 --
Question ID: 647a22baaeb86ca37e6d50b641069ade6552a1df_7
Original Code:
```
static void bmw_LoopShellWalker_visitLoop(BMWalker *walker, BMLoop *l)
{
  BMwLoopShellWalker *shellWalk = NULL;

  if (BLI_gset_haskey(walker->visit_set, l)) {
    return;
  }

  if (!bmw_mask_check_face(walker, l->f)) {
    return;
  }

  shellWalk = BMW_state_add(walker);
  shellWalk->curloop = l;
  BLI_gset_insert(walker->visit_set, l);
}
```


Overlapping Code:
```
Loop(BMWalker *walker, BMLoop *l)
{
BMwLoopShellWalker *shellWalk = NULL;
if (BLI_gset_haskey(walker->visit_set, l)) {
return;
}
if (!bmw_mask_check_face(walker, l->f)) {
return;
}
shellWalk = BMW_state_add(walker);
shellWalk->curloop = l;
BLI_gset_i
```
<Overlap Ratio: 0.7886435331230284>

---

--- 281 --
Question ID: e2d2b3a4b86803b049c9113328660db55f4dc66a_1
Original Code:
```
struct dyn_array *
dyn_array_create(size_t elm_size, intmax_t chunk, intmax_t start_elm_count, bool zeroize)
{
    struct dyn_array *ret;		/* Created dynamic array to return */
    intmax_t number_of_bytes;		/* Total number of bytes occupied by the initialized array */

    /*
     * Check preconditions (firewall) - sanity check args
     */
    if (elm_size <= 0) {
	err(58, __func__, "elm_size must be > 0: %ju", (uintmax_t)elm_size);
	not_reached();
    }
    if (chunk <= 0) {
	err(59, __func__, "chunk must be > 0: %jd", chunk);
	not_reached();
    }
    if (start_elm_count <= 0) {
	err(60, __func__, "start_elm_count must be > 0: %jd", start_elm_count);
	not_reached();
    }

    /*
     * Allocate new dynamic array
     */
    errno = 0;			/* pre-clear errno for errp() */
    ret = calloc(1, sizeof(struct dyn_array));
    if (ret == NULL) {
	errp(61, __func__, "cannot calloc %ju bytes for a struct dyn_array",
			   (uintmax_t)sizeof(struct dyn_array));
	not_reached();
    }

    /*
     * Initialize empty dynamic array
     * Start with a dynamic array with allocated enough chunks to hold at least start_elm_count elements
     */
    ret->elm_size = elm_size;
    ret->zeroize = zeroize;
    /* Allocated array is empty */
    ret->count = 0;
    /* Allocate a number of elements multiple of chunk */
    ret->allocated = chunk * ((start_elm_count + (chunk - 1)) / chunk);
    ret->chunk = chunk;

    /*
     * determine the size of the allocated area
     */
    /* +chunk for guard chunk */
    number_of_bytes = (ret->allocated+chunk) * elm_size;

    errno = 0;			/* pre-clear errno for errp() */
    ret->data = malloc((size_t)number_of_bytes);
    if (ret->data == NULL) {
	/* +chunk for guard chunk */
	errp(62, __func__, "cannot malloc of %jd elements of %ju bytes each for dyn_array->data",
			   (ret->allocated+chunk), (uintmax_t)elm_size);
	not_reached();
    }

    /*
     * Zeroize allocated data
     */
    if (ret->zeroize == true) {
	memset(ret->data, 0, number_of_bytes);
    }

    /*
     * Return newly allocated array
     */
    dbg(DBG_VVHIGH, "%s(%ju, %jd, %jd, %s): initialized empty dynamic array, allocated: %jd elements of size: %ju",
		    __func__, (uintmax_t)elm_size, chunk, start_elm_count,
		    booltostr(zeroize),
		    dyn_array_alloced(ret), (uintmax_t)ret->elm_size);
    return ret;
}
```


Overlapping Code:
```
reate(size_t elm_size, intmax_t chunk, intmax_t start_elm_count, bool zeroize)
{
struct dyn_array *ret; /* Created dynamic array to return */
intmax_t number_of_bytes; /* Total number of bytes occupied by the initialized array */
/*
* Check preconditions (firewall) - sanity check args
*/
if (elm_size <= 0) {
err(58, __func__, "elm_size must be > 0: %ju", (uintmax_t)elm_size);
not_reached();
}
if (chunk <= 0) {
err(59, __func__, "chunk must be > 0: %jd", chunk);
not_reached();
}
if (start_elm_count <= 0) {
err(60, __func__, "start_elm_count must be > 0: %jd", start_elm_count);
not_reached();
}
/*
* Allocate new dynamic array
*/
errno = 0; /* pre-clear errno for errp() */
ret = calloc(1, sizeof(struct dyn_array));
if (ret == NULL) {
errp(61, __func__, "cannot calloc %ju bytes for a struct dyn_array",
(uintmax_t)sizeof(struct dyn_array));
not_reached();
}
/*
* Initialize empty dynamic array
* Start with a dynamic array with allocated enough chunks to hold at least start_elm_count elements
*/
ret->elm_size = elm_size;
ret->zeroize = zeroize;
/* Allocated array is empty */
ret->count = 0;
/* Allocate a number of elements multiple of chunk */
ret->allocated = chunk * ((start_elm_count + (chunk - 1)) / chunk);
ret->chunk = chunk;
/*
* determine the size of the allocated area
*/
/* +chunk for guard chunk */
number_of_bytes = (ret->allocated+chunk) * elm_size;
errno = 0; /* pre-clear errno for errp() */
ret->data = malloc((size_t)number_of_bytes);
if (ret->data == NULL) {
/* +chunk for guard chunk */
errp(62, __func__, "cannot malloc of %jd elements of %ju bytes each for dyn_array->data",
(ret->allocated+chunk), (uintmax_t)elm_size);
not_reached();
}
/*
* Zeroize allocated data
*/
if (ret->zeroize == true) {
memset(ret->data, 0, number_of_bytes);
}
/*
* Return newly allocated array
*/
dbg(DBG_VVHIGH, "%s(%ju, %jd, %jd, %s): initialized empty dynamic array, allocated: %jd elements of size: %ju",
__func__, (uintmax_t)elm_size, chunk, start_elm_count,
booltostr(zeroize),
dyn_array_alloced(ret), (uintmax_t)ret->elm_size);
retur
```
<Overlap Ratio: 0.9818007662835249>

---

--- 282 --
Question ID: 365d759e54ae8a20e9a7ab584d0051febd60aca0_0
Original Code:
```
char* iupdrvLocaleInfo(void)
{
  CPINFOEXA info;
  GetCPInfoExA(CP_ACP, 0, &info);
  return iupStrReturnStr(info.CodePageName);
}
```


Overlapping Code:
```
drvLocaleInfo(void)
{
CPINFOEXA info;
GetCPInfoExA(CP_ACP, 0, &info);
return iupStrReturnStr(info.Co
```
<Overlap Ratio: 0.8130081300813008>

---

--- 283 --
Question ID: d99c4bf6d21bb55e87e615a6555555881994225f_2
Original Code:
```
int lsh_com_err_proc (LPSTR whoami, long code,
                              LPSTR fmt, va_list args)
{
    int retval;
    HWND hOldFocus;
    char buf[1024], *cp;
    WORD mbformat = MB_OK | MB_ICONEXCLAMATION;

    cp = buf;
    memset(buf, '\0', sizeof(buf));
    cp[0] = '\0';

    if (code)
    {
        err_describe(buf, code);
        while (*cp)
            cp++;
    }

    if (fmt)
    {
        if (fmt[0] == '%' && fmt[1] == 'b')
	{
            fmt += 2;
            mbformat = va_arg(args, WORD);
            /* if the first arg is a %b, we use it for the message
               box MB_??? flags. */
	}
        if (code)
	{
            *cp++ = '\n';
            *cp++ = '\n';
	}
        wvsprintfA((LPSTR)cp, fmt, args);
    }
    hOldFocus = GetFocus();
    retval = MessageBoxA(/*GetRootParent(hOldFocus)*/NULL, buf, whoami,
                        mbformat | MB_ICONHAND | MB_TASKMODAL);
    SetFocus(hOldFocus);
    return retval;
}
```


Overlapping Code:
```
om_err_proc (LPSTR whoami, long code,
LPSTR fmt, va_list args)
{
int retval;
HWND hOldFocus;
char buf[1024], *cp;
WORD mbformat = MB_OK | MB_ICONEXCLAMATION;
cp = buf;
memset(buf, '\0', sizeof(buf));
cp[0] = '\0';
if (code)
{
err_describe(buf, code);
while (*cp)
cp++;
}
if (fmt)
{
if (fmt[0] == '%' && fmt[1] == 'b')
{
fmt += 2;
mbformat = va_arg(args, WORD);
/* if the first arg is a %b, we use it for the message
box MB_??? flags. */
}
if (code)
{
*cp++ = '\n';
*cp++ = '\n';
}
wvsprintfA((LPSTR)cp, fmt, args);
}
hOldFocus = GetFocus();
retval = MessageBoxA(/*GetRootParent(hOldFocus)*/NULL, buf, whoami,
mbformat | MB_ICONHAND | MB_TASKMODAL);
SetFocus(hOldFocus);
retur
```
<Overlap Ratio: 0.9712230215827338>

---

--- 284 --
Question ID: 905ae77855e8eb677a4215a98d0822fd8711d22c_0
Original Code:
```
class BankAction : public InventoryAction
{
    public:
        BankAction(PlayerbotAI* botAI) : InventoryAction(botAI, "bank") { }

        bool Execute(Event event) override;

    private:
        bool ExecuteBank(std::string const text, Unit* bank);
        void ListItems();
        bool Withdraw(uint32 itemid);
        bool Deposit(Item* pItem);
        Item* FindItemInBank(uint32 ItemId);
}
```


Overlapping Code:
```
ic:
BankAction(PlayerbotAI* botAI) : InventoryAction(botAI, "bank") { }
bool Execute(Event event) override;
private:
bool ExecuteBank(std::string const text, Unit* bank);
void ListItems();
bool Withdraw(uint32 itemid);
bool Deposit(Item* pItem);
Item* FindItemInBank(uint3
```
<Overlap Ratio: 0.8192771084337349>

---

--- 285 --
Question ID: 1b44bba515039f323b69b64c6f870027c3529b03_1
Original Code:
```
void test_extensions_v1beta1_deployment(int include_optional) {
    extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_1 = instantiate_extensions_v1beta1_deployment(include_optional);

	cJSON* jsonextensions_v1beta1_deployment_1 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_1);
	printf("extensions_v1beta1_deployment :\n%s\n", cJSON_Print(jsonextensions_v1beta1_deployment_1));
	extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_parseFromJSON(jsonextensions_v1beta1_deployment_1);
	cJSON* jsonextensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_2);
	printf("repeating extensions_v1beta1_deployment:\n%s\n", cJSON_Print(jsonextensions_v1beta1_deployment_2));
}
```


Overlapping Code:
```
eta1_deployment(int include_optional) {
extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_1 = instantiate_extensions_v1beta1_deployment(include_optional);
cJSON* jsonextensions_v1beta1_deployment_1 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_1);
printf("extensions_v1beta1_deployment :\n%s\n", cJSON_Print(jsonextensions_v1beta1_deployment_1));
extensions_v1beta1_deployment_t* extensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_parseFromJSON(jsonextensions_v1beta1_deployment_1);
cJSON* jsonextensions_v1beta1_deployment_2 = extensions_v1beta1_deployment_convertToJSON(extensions_v1beta1_deployment_2);
printf("repeating extensions_v1beta1_deployment:\n%s\n", cJSON_Print(jsonextensions_v1beta1_deployment_
```
<Overlap Ratio: 0.9622641509433962>

---

--- 286 --
Question ID: 0c59deb5a8420feeaff1acbf22ad6823bbf91d2f_0
Original Code:
```
void Bluetooth_Stack_Task(void)
{
	if (USB_HostState != HOST_STATE_Configured)
	  Bluetooth_HCIProcessingState = Bluetooth_Init;
		
	Bluetooth_ProcessHCICommands();
	Bluetooth_ProcessACLPackets();
}
```


Overlapping Code:
```
h_Stack_Task(void)
{
if (USB_HostState != HOST_STATE_Configured)
Bluetooth_HCIProcessingState = Bluetooth_Init;

Bluetooth_ProcessHCICommands();
Bluetooth_ProcessACLPackets();

```
<Overlap Ratio: 0.9263157894736842>

---

--- 287 --
Question ID: dbb8d9de5b798425b8cd4d0a4d271f8501ce76aa_2
Original Code:
```
always_inline void *
vlib_physmem_at_offset (vlib_main_t * vm, vlib_physmem_region_index_t idx,
			uword offset)
{
  vlib_physmem_region_t *pr = vlib_physmem_get_region (vm, idx);
  ASSERT (offset < pr->size);
  return uword_to_pointer (pointer_to_uword (pr->mem) + offset, void *);
}
```


Overlapping Code:
```
vlib_physmem_at_offset (vlib_main_t * vm, vlib_physmem_region_index_t idx,
uword offset)
{
vlib_physmem_region_t *pr = vlib_physmem_get_region (vm, idx);
ASSERT (offset < pr->size);
return uword_to_pointer (pointer_to_uword (pr->mem) + offset, void *
```
<Overlap Ratio: 0.9090909090909091>

---

--- 288 --
Question ID: 4946f0b6a7e6830f68f582798b28740cc788610e_25
Original Code:
```
static inline void
vn_decode_VkPipelineTessellationStateCreateInfo_temp(struct vn_cs_decoder *dec, VkPipelineTessellationStateCreateInfo *val)
{
    VkStructureType stype;
    vn_decode_VkStructureType(dec, &stype);
    if (stype != VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
        vn_cs_decoder_set_fatal(dec);

    val->sType = stype;
    val->pNext = vn_decode_VkPipelineTessellationStateCreateInfo_pnext_temp(dec);
    vn_decode_VkPipelineTessellationStateCreateInfo_self_temp(dec, val);
}
```


Overlapping Code:
```
static inline void
vn_decode_VkPipelineTessellationStateCreateInfo_temp(struct vn_cs_decoder *dec, VkPipelineTessellationStateCreateInfo *val)
{
VkStructureType stype;
vn_decode_VkStructureType(dec, &stype);
if (stype != VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO)
vn_cs_decoder_set_fatal(dec);
val->sType = stype;
val->pNext = vn_decode_VkPipelineTessellationStateCreateInfo_pnext_temp(dec);
vn_decode_VkPipelineTessellationStateCreateInfo_self_temp(dec, val)
```
<Overlap Ratio: 0.9937238493723849>

---

--- 289 --
Question ID: 325f0fb3fd16aee145893c24472611faf8aaff35_15
Original Code:
```
static void Test_cascade_five_timers(nlTestSuite *inSuite, void *inContext)
{
    BaseType_t wait_result;
    timer_test_info2_t test_info1;
    timer_test_info2_t test_info2;
    timer_test_info2_t test_info3;
    timer_test_info2_t test_info4;
    timer_test_info2_t test_info5;
    nl_swtimer_t timer1;
    nl_swtimer_t timer2;
    nl_swtimer_t timer3;
    nl_swtimer_t timer4;
    nl_swtimer_t timer5;
    nl_swtimer_t *timer_list1[1];
    uint32_t timer_delays1[1];
    timer_test_info2_t *timer_infos1[1];
    nl_swtimer_t *timer_list2[3];
    uint32_t timer_delays2[3];
    timer_test_info2_t *timer_infos2[3];

    if (s_test_with_tick_count_near_wrap)
    {
        AdjustTickCount(nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_50_MS));
    }

    // test five one shot timers where timer1 starts timer2 from
    // it's timer function, and timer2 starts timer3, timer4, and
    // timer5 from it's timer function.
    // timer1 has a timeout of 100MS
    // timer2 has a timeout of 500MS
    // timer3 has a timeout of 1000MS
    // timer4 has a timeout of 1000MS
    // timer5 has a timeout of 2000MS
    printf("%s: start. test takes about 3 seconds...\n", __func__);
    ulTaskNotifyTake(pdTRUE, 0); // clear any old notifications
    memset(&test_info1, 0, sizeof(test_info1));
    memset(&test_info2, 0, sizeof(test_info2));
    memset(&test_info3, 0, sizeof(test_info3));
    memset(&test_info4, 0, sizeof(test_info4));
    memset(&test_info5, 0, sizeof(test_info5));
    nl_swtimer_init(&timer1, cascade_timer_test, &test_info1);
    nl_swtimer_init(&timer2, cascade_timer_test, &test_info2);
    nl_swtimer_init(&timer3, cascade_timer_test, &test_info3);
    nl_swtimer_init(&timer4, cascade_timer_test, &test_info4);
    nl_swtimer_init(&timer5, cascade_timer_test, &test_info5);
    test_info1.test_suite = inSuite;
    test_info1.num_timers = 1;
    timer_list1[0] = &timer2;
    timer_delays1[0] = TIMER_TEST_DELAY_500_MS;
    timer_infos1[0] = &test_info2;
    test_info1.timers = timer_list1;
    test_info1.timer_infos = timer_infos1;
    test_info1.timer_delays = timer_delays1;

    test_info2.test_suite = inSuite;
    test_info2.num_timers = 3;
    timer_list2[0] = &timer3;
    timer_list2[1] = &timer4;
    timer_list2[2] = &timer5;
    timer_delays2[0] = TIMER_TEST_DELAY_1000_MS;
    timer_delays2[1] = TIMER_TEST_DELAY_1000_MS;
    timer_delays2[2] = TIMER_TEST_DELAY_2000_MS;
    timer_infos2[0] = &test_info3;
    timer_infos2[1] = &test_info4;
    timer_infos2[2] = &test_info5;
    test_info2.timers = timer_list2;
    test_info2.timer_infos = timer_infos2;
    test_info2.timer_delays = timer_delays2;

    test_info3.test_suite = inSuite;
    test_info4.test_suite = inSuite;
    test_info5.test_suite = inSuite;
    test_info5.notifyTaskHandle = xTaskGetCurrentTaskHandle();

    test_info1.expectedRunTimeMin = xTaskGetTickCount() + nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_100_MS);
    test_info1.expectedRunTimeMax = test_info1.expectedRunTimeMin + TIMING_ERROR_TOLERANCE_TICKS;
    nl_swtimer_start(&timer1, TIMER_TEST_DELAY_100_MS);
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1));
    // delay until we expect everything to have been run.  since
    // restarting a timer from within itself isn't quite the same
    // as true periodic, because of the extra tick added to the
    // each start, we have to wait a bit longer than 10 seconds
    wait_result = ulTaskNotifyTake(pdTRUE, nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_5000_MS));
    NL_TEST_ASSERT(inSuite, wait_result != 0); // assert did not timeout
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer1) == false);
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer2) == false);
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer3) == false);
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer4) == false);
    NL_TEST_ASSERT(inSuite, nl_swtimer_is_active(&timer5) == false);
    NL_TEST_ASSERT(inSuite, test_info1.count == 1);
    NL_TEST_ASSERT(inSuite, test_info2.count == 1);
    NL_TEST_ASSERT(inSuite, test_info3.count == 1);
    NL_TEST_ASSERT(inSuite, test_info4.count == 1);
    NL_TEST_ASSERT(inSuite, test_info5.count == 1);

    // cleanup just in case of failure before we run next test, else
    // our stack timer structure will corrupt the nl_swtimer implementation
    (void)nl_swtimer_cancel(&timer1);
    (void)nl_swtimer_cancel(&timer2);
    (void)nl_swtimer_cancel(&timer3);
    (void)nl_swtimer_cancel(&timer4);
    (void)nl_swtimer_cancel(&timer5);
}
```


Overlapping Code:
```
ade_five_timers(nlTestSuite *inSuite, void *inContext)
{
BaseType_t wait_result;
timer_test_info2_t test_info1;
timer_test_info2_t test_info2;
timer_test_info2_t test_info3;
timer_test_info2_t test_info4;
timer_test_info2_t test_info5;
nl_swtimer_t timer1;
nl_swtimer_t timer2;
nl_swtimer_t timer3;
nl_swtimer_t timer4;
nl_swtimer_t timer5;
nl_swtimer_t *timer_list1[1];
uint32_t timer_delays1[1];
timer_test_info2_t *timer_infos1[1];
nl_swtimer_t *timer_list2[3];
uint32_t timer_delays2[3];
timer_test_info2_t *timer_infos2[3];
if (s_test_with_tick_count_near_wrap)
{
AdjustTickCount(nl_time_ms_to_delay_time_native(TIMER_TEST_DELAY_50_MS));
}
// test five one shot timers where timer1 starts timer2 from
// it's timer function, and timer2 starts timer3, timer4, and
// timer5 from it's timer function.
// timer1 has a timeout of 100MS
// timer2 has a timeout of 500MS
// timer3 has a timeout of 1000MS
// timer4 has a timeout of 1000MS
// timer5 has a timeout of 2000MS
printf("%s: start. test takes about 3 seconds...\n", __func__);
ulTaskNotifyTake(pdTRUE, 0); // clear any old notifications
memset(&test_info1, 0, sizeof(test_info1));
memset(&test_info2, 0, sizeof(test_info2));
memset(&test_info3, 0, sizeof(test_info3));
memset(&test_info4, 0, sizeof(test_info4));
memset(&test_info5, 0, sizeof(test_info5));
nl_swtimer_init(&timer1, cascade_timer_test, &test_info1);
nl_swtimer_init(&timer2, cascade_timer_test, &test_info2);
nl_swtimer_init(&timer3, cascade_timer_test, &test_info3);
nl_swtimer_init(&timer4, cascade_timer_test, &test_info4);
nl_swtimer_init(&timer5, cascade_timer_test, &test_info5);
test_info1.test_suite = inSuite;
test_info1.num_timers = 1;
timer_list1[0] = &timer2;
timer_delays1[0] = TIMER_TEST_DELAY_500_MS;
timer_infos1[0] = &test_info2;
test_info1.timers = timer_list1;
test_info1.timer_infos = timer_infos1;
test_info1.timer_delays = timer_delays1;
test_info2.test_suite = inSuite;
test_info2.num_timers = 3;
timer_list2[0] = &timer3;
timer_list2[1] = &timer4;
timer_list2[2] = &timer5;
timer_delays2[0] = TIMER_TEST_DELAY_1000_MS;
timer_delays2[1] = TIMER_TEST_DELAY_1000_MS;
timer_delays2[2] = TIMER_TEST_DELAY_2000_MS;
timer_infos2[0] = &test_info3;
timer_infos
```
<Overlap Ratio: 0.9769094138543517>

---

--- 290 --
Question ID: 4215725b243072b5b6b93b519abaab307629e7dd_3
Original Code:
```
static mRosSizeType get_arglen(mRosEncodeArgType *arg)
{
	mRosSizeType len = 0;
	mRosSizeType i;
	for (i = 0; i < arg->args_char; i++) {
		len += strlen(arg->argv[i]) + 1;
	}
	for (i = 0; i < arg->args_int; i++) {
		len += get_digit(arg->argi[i]) + 1;
	}
	return len;
}
```


Overlapping Code:
```
pe *arg)
{
mRosSizeType len = 0;
mRosSizeType i;
for (i = 0; i < arg->args_char; i++) {
len += strlen(arg->argv[i]) + 1;
}
for (i = 0; i < arg->args_int; i++) {
len += get_digit(arg->argi[i]) + 1;
}
r
```
<Overlap Ratio: 0.7751937984496124>

---

--- 291 --
Question ID: 2ed47c658c9fcbe7f9392f164baac9bcb8bf73ec_11
Original Code:
```
int TaskLocalNewton_Solve(SUNNonlinearSolver NLS,
                          N_Vector y0, N_Vector ycor,
                          N_Vector w, double tol,
                          booleantype callLSetup, void* mem)
{
  /* local variables */
  MPI_Comm comm;
  int solve_status, recover, nonrecover;

  /* check that the inputs are non-null */
  if ((NLS  == NULL) ||
      (y0   == NULL) ||
      (ycor == NULL) ||
      (w    == NULL) ||
      (mem  == NULL))
    return SUN_NLS_MEM_NULL;

  /* shortcuts */
  comm = GET_NLS_CONTENT(NLS)->comm;

  /* each tasks solves the local nonlinear system */
  solve_status = SUNNonlinSolSolve(LOCAL_NLS(NLS),
                                   N_VGetLocalVector_MPIPlusX(y0),
                                   N_VGetLocalVector_MPIPlusX(ycor),
                                   N_VGetLocalVector_MPIPlusX(w),
                                   tol, callLSetup, mem);

  /* if any process had a nonrecoverable failure, return it */
  MPI_Allreduce(&solve_status, &nonrecover, 1, MPI_INT, MPI_MIN, comm);
  if (nonrecover < 0) return nonrecover;

  /* check if any process has a recoverable convergence failure */
  MPI_Allreduce(&solve_status, &recover, 1, MPI_INT, MPI_MAX, comm);
  if (recover == SUN_NLS_CONV_RECVR) GET_NLS_CONTENT(NLS)->ncnf++;

  /* return success (recover == 0) or a recoverable error code (recover > 0) */
  return recover;
}
```


Overlapping Code:
```
 TaskLocalNewton_Solve(SUNNonlinearSolver NLS,
N_Vector y0, N_Vector ycor,
N_Vector w, double tol,
booleantype callLSetup, void* mem)
{
/* local variables */
MPI_Comm comm;
int solve_status, recover, nonrecover;
/* check that the inputs are non-null */
if ((NLS == NULL) ||
(y0 == NULL) ||
(ycor == NULL) ||
(w == NULL) ||
(mem == NULL))
return SUN_NLS_MEM_NULL;
/* shortcuts */
comm = GET_NLS_CONTENT(NLS)->comm;
/* each tasks solves the local nonlinear system */
solve_status = SUNNonlinSolSolve(LOCAL_NLS(NLS),
N_VGetLocalVector_MPIPlusX(y0),
N_VGetLocalVector_MPIPlusX(ycor),
N_VGetLocalVector_MPIPlusX(w),
tol, callLSetup, mem);
/* if any process had a nonrecoverable failure, return it */
MPI_Allreduce(&solve_status, &nonrecover, 1, MPI_INT, MPI_MIN, comm);
if (nonrecover < 0) return nonrecover;
/* check if any process has a recoverable convergence failure */
MPI_Allreduce(&solve_status, &recover, 1, MPI_INT, MPI_MAX, comm);
if (recover == SUN_NLS_CONV_RECVR) GET_NLS_CONTENT(NLS)->ncnf++;
/* return success (recover == 0) or a recoverable error code (recover > 0) */
retur
```
<Overlap Ratio: 0.986351228389445>

---

--- 292 --
Question ID: 6576afb09c5bb247db9429cbb728ce0ea48e2d15_0
Original Code:
```
void power_init(void)
{
    /* Configure GPA6 as input and wait a short while */
    GPIOA_DIR &= ~(1<<6);

    udelay(10);

    /* Value of GPA6 determines PMU chip type */
    if (GPIOA & (1<<6))
    {
        pmu = PCF50635;

        pcf50635_init();
        
        /* Clear pending interrupts from pcf50635 */
        unsigned char data[5]; /* 0 = INT1, 1 = INT2, 2 = INT3, ... 4 = INT5 */
        pcf50635_read_multiple(PCF5063X_REG_INT1, data, 5);
    }
    else
    {
        pmu = PCF50606;

        /* Configure GPA6 for output (backlight enable) */
        GPIOA_DIR |= (1<<6);

        pcf50606_init();

        /* Clear pending interrupts */
        unsigned char data[3]; /* 0 = INT1, 1 = INT2, 2 = INT3 */
        pcf50606_read_multiple(0x02, data, 3);
    }

#ifndef BOOTLOADER
        IEN |= EXT3_IRQ_MASK;   /* Unmask EXT3 */
#endif
}
```


Overlapping Code:
```
 power_init(void)
{
/* Configure GPA6 as input and wait a short while */
GPIOA_DIR &= ~(1<<6);
udelay(10);
/* Value of GPA6 determines PMU chip type */
if (GPIOA & (1<<6))
{
pmu = PCF50635;
pcf50635_init();

/* Clear pending interrupts from pcf50635 */
unsigned char data[5]; /* 0 = INT1, 1 = INT2, 2 = INT3, ... 4 = INT5 */
pcf50635_read_multiple(PCF5063X_REG_INT1, data, 5);
}
else
{
pmu = PCF50606;
/* Configure GPA6 for output (backlight enable) */
GPIOA_DIR |= (1<<6);
pcf50606_init();
/* Clear pending interrupts */
unsigned char data[3]; /* 0 = INT1, 1 = INT2, 2 = INT3 */
pcf50606_read_multiple(0x02, data, 3);
}
#ifndef BOOTLOADER
IEN |= EXT
```
<Overlap Ratio: 0.9393063583815029>

---

--- 293 --
Question ID: 053259a02326bb61023ec6d1eef92febc8d166c4_25
Original Code:
```
void func_65(var uParam0)
{
	*uParam0 = 0;
	uParam0->f_1 = 0;
	uParam0->f_2 = 0;
	uParam0->f_3 = 0;
	uParam0->f_4 = 0;
	uParam0->f_5 = 0;
	uParam0->f_6 = 0;
	uParam0->f_7 = 0;
	uParam0->f_8 = 0;
	uParam0->f_9 = 0;
	uParam0->f_10 = 0;
	uParam0->f_11 = 0;
	uParam0->f_12 = 0;
}
```


Overlapping Code:
```
(var uParam0)
{
*uParam0 = 0;
uParam0->f_1 = 0;
uParam0->f_2 = 0;
uParam0->f_3 = 0;
uParam0->f_4 = 0;
uParam0->f_5 = 0;
uParam0->f_6 = 0;
uParam0->f_7 = 0;
uParam0->f_8 = 0;
uParam0->f_9 = 0;
uParam0->f_10 = 0;
uParam0->f_11 = 0;
uParam0->f_12 = 0;
}
```
<Overlap Ratio: 0.9541984732824428>

---

--- 294 --
Question ID: 7ee4055bf91401857d7901c2de68cecbdce77bbc_14
Original Code:
```
static int sensor_irq(void *ctx)
{
    if (g_dvp_finish_flag == 1)
    {
        dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 0);
    }

    // sensor_t *sensor = ctx;
    if (dvp_get_interrupt(DVP_STS_FRAME_FINISH))
    { //frame end
        dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH);
        g_dvp_finish_flag = 1;
    }
    else
    {                               //frame start
        if (g_dvp_finish_flag == 0) //only we finish the convert, do transmit again
            dvp_start_convert();    //so we need deal img ontime, or skip one framebefore next
        dvp_clear_interrupt(DVP_STS_FRAME_START);
    }
    //rt_kprintf("D\n");
    return 0;
}
```


Overlapping Code:
```
tic int sensor_irq(void *ctx)
{
if (g_dvp_finish_flag == 1)
{
dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 0);
}
// sensor_t *sensor = ctx;
if (dvp_get_interrupt(DVP_STS_FRAME_FINISH))
{ //frame end
dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH);
g_dvp_finish_flag = 1;
}
else
{ //frame start
if (g_dvp_finish_flag == 0) //only we finish the convert, do transmit again
dvp_start_convert(); //so we need deal img ontime, or skip one framebefore next
dvp_clear_interrupt(DVP_STS_FRAME_START);
}
//rt_kprin
```
<Overlap Ratio: 0.9565217391304348>

---

--- 295 --
Question ID: d0f50d2a22c740e8272b75d8d68f43e89a1fdc6d_20
Original Code:
```
void
owcty_global_init   (run_t *run, wctx_t *ctx)
{
    ctx->global = RTmallocZero (sizeof(alg_global_t));
    size_t len = state_info_serialize_int_size (ctx->state);
    ctx->global->stack = dfs_stack_create (len);
    ctx->global->in_stack = dfs_stack_create (len);
    ctx->global->out_stack = dfs_stack_create (len);

    lb_local_init (run->shared->lb, ctx->id, ctx); // Barrier
    (void) run;
}
```


Overlapping Code:
```
al_init (run_t *run, wctx_t *ctx)
{
ctx->global = RTmallocZero (sizeof(alg_global_t));
size_t len = state_info_serialize_int_size (ctx->state);
ctx->global->stack = dfs_stack_create (len);
ctx->global->in_stack = dfs_stack_create (len);
ctx->global->out_stack = dfs_stack_create (len);
lb_local_init (run->shared->lb, ctx->id, ct
```
<Overlap Ratio: 0.8844086021505376>

---

--- 296 --
Question ID: 89c99532d5bbf2e5fad532d8cb917a6848595dd6_0
Original Code:
```
int
dsnode_bmod (
	    const int  jcol,	  /* in */
	    const int  jsupno,    /* in */
	    const int  fsupc,     /* in */
	    double     *dense,    /* in */
	    double     *tempv,    /* working array */
	    GlobalLU_t *Glu,      /* modified */
	    SuperLUStat_t *stat   /* output */
	    )
{
#ifdef USE_VENDOR_BLAS
#ifdef _CRAY
    _fcd ftcs1 = _cptofcd("L", strlen("L")),
	 ftcs2 = _cptofcd("N", strlen("N")),
	 ftcs3 = _cptofcd("U", strlen("U"));
#endif
    int            incx = 1, incy = 1;
    double         alpha = -1.0, beta = 1.0;
#endif

    int            luptr, nsupc, nsupr, nrow;
    int            isub, irow, i, iptr; 
    register int   ufirst, nextlu;
    int            *lsub, *xlsub;
    double         *lusup;
    int            *xlusup;
    flops_t *ops = stat->ops;

    lsub    = Glu->lsub;
    xlsub   = Glu->xlsub;
    lusup   = Glu->lusup;
    xlusup  = Glu->xlusup;

    nextlu = xlusup[jcol];
    
    /*
     *	Process the supernodal portion of L\U[*,j]
     */
    for (isub = xlsub[fsupc]; isub < xlsub[fsupc+1]; isub++) {
  	irow = lsub[isub];
	lusup[nextlu] = dense[irow];
	dense[irow] = 0;
	++nextlu;
    }

    xlusup[jcol + 1] = nextlu;	/* Initialize xlusup for next column */
    
    if ( fsupc < jcol ) {

	luptr = xlusup[fsupc];
	nsupr = xlsub[fsupc+1] - xlsub[fsupc];
	nsupc = jcol - fsupc;	/* Excluding jcol */
	ufirst = xlusup[jcol];	/* Points to the beginning of column
				   jcol in supernode L\U(jsupno). */
	nrow = nsupr - nsupc;

	ops[TRSV] += nsupc * (nsupc - 1);
	ops[GEMV] += 2 * nrow * nsupc;

#ifdef USE_VENDOR_BLAS
#ifdef _CRAY
	STRSV( ftcs1, ftcs2, ftcs3, &nsupc, &lusup[luptr], &nsupr, 
	      &lusup[ufirst], &incx );
	SGEMV( ftcs2, &nrow, &nsupc, &alpha, &lusup[luptr+nsupc], &nsupr, 
		&lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );
#else
        hypre_F90_NAME_BLAS(dtrsv,DTRSV)("L","N","U",&nsupc,&lusup[luptr],
              &nsupr, &lusup[ufirst], &incx );
        hypre_F90_NAME_BLAS(dgemv,DGEMV)("N",&nrow,&nsupc,&alpha,
                &lusup[luptr+nsupc], &nsupr,
                &lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );
#endif
#else
	sludlsolve ( nsupr, nsupc, &lusup[luptr], &lusup[ufirst] );
	sludmatvec ( nsupr, nrow, nsupc, &lusup[luptr+nsupc], 
			&lusup[ufirst], &tempv[0] );

        /* Scatter tempv[*] into lusup[*] */
	iptr = ufirst + nsupc;
	for (i = 0; i < nrow; i++) {
	    lusup[iptr++] -= tempv[i];
	    tempv[i] = 0.0;
	}
#endif

    }

    return 0;
}
```


Overlapping Code:
```
int
dsnode_bmod (
const int jcol, /* in */
const int jsupno, /* in */
const int fsupc, /* in */
double *dense, /* in */
double *tempv, /* working array */
GlobalLU_t *Glu, /* modified */
SuperLUStat_t *stat /* output */
)
{
#ifdef USE_VENDOR_BLAS
#ifdef _CRAY
_fcd ftcs1 = _cptofcd("L", strlen("L")),
ftcs2 = _cptofcd("N", strlen("N")),
ftcs3 = _cptofcd("U", strlen("U"));
#endif
int incx = 1, incy = 1;
double alpha = -1.0, beta = 1.0;
#endif
int luptr, nsupc, nsupr, nrow;
int isub, irow, i, iptr; 
register int ufirst, nextlu;
int *lsub, *xlsub;
double *lusup;
int *xlusup;
flops_t *ops = stat->ops;
lsub = Glu->lsub;
xlsub = Glu->xlsub;
lusup = Glu->lusup;
xlusup = Glu->xlusup;
nextlu = xlusup[jcol];

/*
* Process the supernodal portion of L\U[*,j]
*/
for (isub = xlsub[fsupc]; isub < xlsub[fsupc+1]; isub++) {
irow = lsub[isub];
lusup[nextlu] = dense[irow];
dense[irow] = 0;
++nextlu;
}
xlusup[jcol + 1] = nextlu; /* Initialize xlusup for next column */

if ( fsupc < jcol ) {
luptr = xlusup[fsupc];
nsupr = xlsub[fsupc+1] - xlsub[fsupc];
nsupc = jcol - fsupc; /* Excluding jcol */
ufirst = xlusup[jcol]; /* Points to the beginning of column
jcol in supernode L\U(jsupno). */
nrow = nsupr - nsupc;
ops[TRSV] += nsupc * (nsupc - 1);
ops[GEMV] += 2 * nrow * nsupc;
#ifdef USE_VENDOR_BLAS
#ifdef _CRAY
STRSV( ftcs1, ftcs2, ftcs3, &nsupc, &lusup[luptr], &nsupr, 
&lusup[ufirst], &incx );
SGEMV( ftcs2, &nrow, &nsupc, &alpha, &lusup[luptr+nsupc], &nsupr, 
&lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );
#else
hypre_F90_NAME_BLAS(dtrsv,DTRSV)("L","N","U",&nsupc,&lusup[luptr],
&nsupr, &lusup[ufirst], &incx );
hypre_F90_NAME_BLAS(dgemv,DGEMV)("N",&nrow,&nsupc,&alpha,
&lusup[luptr+nsupc], &nsupr,
&lusup[ufirst], &incx, &beta, &lusup[ufirst+nsupc], &incy );
#endif
#else
sludlsolve ( nsupr, nsupc, &lusup[luptr], &lusup[ufirst] );
sludmatvec ( nsupr, nrow, nsupc, &lusup[luptr+nsupc], 
&lusup[ufirst], &tempv[0] );
/* Scatter tempv[*] into lusup[*] */
iptr = ufirst + nsupc;
for (i = 0; i < nrow; i++) {
lusup[iptr++] -= tempv[i];
temp
```
<Overlap Ratio: 0.9836852207293666>

---

--- 297 --
Question ID: fdb0b4a3dbe5bef9cf7a9f226a93f3479c2e870c_49
Original Code:
```
static int
mch_call_shell_fork(
    char_u *cmd,
    int options) /* SHELL_*, see vim.h */
{
  int tmode = cur_tmode;
  pid_t pid;
  pid_t wpid = 0;
  pid_t wait_pid = 0;
#ifdef HAVE_UNION_WAIT
  union wait status;
#else
  int status = -1;
#endif
  int retval = -1;
  char **argv = NULL;
  char_u *tofree1 = NULL;
  char_u *tofree2 = NULL;
  int i;
  int pty_master_fd = -1; /* for pty's */
  int fd_toshell[2];      /* for pipes */
  int fd_fromshell[2];
  int pipe_error = FALSE;
  int did_settmode = FALSE; /* settmode(TMODE_RAW) called */

  if (options & SHELL_COOKED)
    settmode(TMODE_COOK); /* set to normal mode */

  if (build_argv(cmd, &argv, &tofree1, &tofree2) == FAIL)
    goto error;

  /*
     * For the GUI, when writing the output into the buffer and when reading
     * input from the buffer: Try using a pseudo-tty to get the stdin/stdout
     * of the executed command into the Vim window.  Or use a pipe.
     */
  if ((options & (SHELL_READ | SHELL_WRITE)))
  {
    pipe_error = (pipe(fd_toshell) < 0);
    if (!pipe_error) /* pipe create OK */
    {
      pipe_error = (pipe(fd_fromshell) < 0);
      if (pipe_error) /* pipe create failed */
      {
        close(fd_toshell[0]);
        close(fd_toshell[1]);
      }
    }
    if (pipe_error)
    {
      msg_puts(_("\nCannot create pipes\n"));
    }
  }

  if (!pipe_error) /* pty or pipe opened or not used */
  {
    SIGSET_DECL(curset)

#ifdef __BEOS__
    beos_cleanup_read_thread();
#endif

    BLOCK_SIGNALS(&curset);
    pid = fork(); /* maybe we should use vfork() */
    if (pid == -1)
    {
      UNBLOCK_SIGNALS(&curset);

      msg_puts(_("\nCannot fork\n"));
      if ((options & (SHELL_READ | SHELL_WRITE)))
      {

        close(fd_toshell[0]);
        close(fd_toshell[1]);
        close(fd_fromshell[0]);
        close(fd_fromshell[1]);
      }
    }
    else if (pid == 0) /* child */
    {
      reset_signals(); /* handle signals normally */
      UNBLOCK_SIGNALS(&curset);

#ifdef FEAT_JOB_CHANNEL
      if (ch_log_active())
        /* close the log file in the child */
        ch_logfile((char_u *)"", (char_u *)"");
#endif

      if (!show_shell_mess || (options & SHELL_EXPAND))
      {
        int fd;

        /*
		 * Don't want to show any message from the shell.  Can't just
		 * close stdout and stderr though, because some systems will
		 * break if you try to write to them after that, so we must
		 * use dup() to replace them with something else -- webb
		 * Connect stdin to /dev/null too, so ":n `cat`" doesn't hang,
		 * waiting for input.
		 */
        fd = open("/dev/null", O_RDWR | O_EXTRA, 0);
        fclose(stdin);
        fclose(stdout);
        fclose(stderr);

        /*
		 * If any of these open()'s and dup()'s fail, we just continue
		 * anyway.  It's not fatal, and on most systems it will make
		 * no difference at all.  On a few it will cause the execvp()
		 * to exit with a non-zero status even when the completion
		 * could be done, which is nothing too serious.  If the open()
		 * or dup() failed we'd just do the same thing ourselves
		 * anyway -- webb
		 */
        if (fd >= 0)
        {
          vim_ignored = dup(fd); /* To replace stdin  (fd 0) */
          vim_ignored = dup(fd); /* To replace stdout (fd 1) */
          vim_ignored = dup(fd); /* To replace stderr (fd 2) */

          /* Don't need this now that we've duplicated it */
          close(fd);
        }
      }
      else if ((options & (SHELL_READ | SHELL_WRITE)))
      {

#ifdef HAVE_SETSID
        /* Create our own process group, so that the child and all its
		 * children can be kill()ed.  Don't do this when using pipes,
		 * because stdin is not a tty, we would lose /dev/tty. */
        if (p_stmp)
        {
          (void)setsid();
#if defined(SIGHUP)
          /* When doing "!xterm&" and 'shell' is bash: the shell
		     * will exit and send SIGHUP to all processes in its
		     * group, killing the just started process.  Ignore SIGHUP
		     * to avoid that. (suggested by Simon Schubert)
		     */
          signal(SIGHUP, SIG_IGN);
#endif
        }
#endif
        set_default_child_environment(FALSE);

        /*
		 * stderr is only redirected when using the GUI, so that a
		 * program like gpg can still access the terminal to get a
		 * passphrase using stderr.
		 */

        /* set up stdin for the child */
        close(fd_toshell[1]);
        close(0);
        vim_ignored = dup(fd_toshell[0]);
        close(fd_toshell[0]);

        /* set up stdout for the child */
        close(fd_fromshell[0]);
        close(1);
        vim_ignored = dup(fd_fromshell[1]);
        close(fd_fromshell[1]);
      }

      /*
	     * There is no type cast for the argv, because the type may be
	     * different on different machines. This may cause a warning
	     * message with strict compilers, don't worry about it.
	     * Call _exit() instead of exit() to avoid closing the connection
	     * to the X server (esp. with GTK, which uses atexit()).
	     */
      execvp(argv[0], argv);
      _exit(EXEC_FAILED); /* exec failed, return failure code */
    }
    else /* parent */
    {
      /*
	     * While child is running, ignore terminating signals.
	     * Do catch CTRL-C, so that "got_int" is set.
	     */
      catch_signals(SIG_IGN, SIG_ERR);
      catch_int_signal();
      UNBLOCK_SIGNALS(&curset);
#ifdef FEAT_JOB_CHANNEL
      ++dont_check_job_ended;
#endif
      /*
	     * For the GUI we redirect stdin, stdout and stderr to our window.
	     * This is also used to pipe stdin/stdout to/from the external
	     * command.
	     */
      if ((options & (SHELL_READ | SHELL_WRITE)))
      {
#define BUFLEN 100 /* length for buffer, pseudo tty limit is 128 */
        char_u buffer[BUFLEN + 1];
        int buffer_off = 0;        /* valid bytes in buffer[] */
        char_u ta_buf[BUFLEN + 1]; /* TypeAHead */
        int ta_len = 0;            /* valid bytes in ta_buf[] */
        int len;
        int p_more_save;
        int old_State;
        int c;
        int toshell_fd;
        int fromshell_fd;
        garray_T ga;
        int noread_cnt;
#ifdef ELAPSED_FUNC
        elapsed_T start_tv;
#endif

        close(fd_toshell[0]);
        close(fd_fromshell[1]);
        toshell_fd = fd_toshell[1];
        fromshell_fd = fd_fromshell[0];

        /*
		 * Write to the child if there are typed characters.
		 * Read from the child if there are characters available.
		 *   Repeat the reading a few times if more characters are
		 *   available. Need to check for typed keys now and then, but
		 *   not too often (delays when no chars are available).
		 * This loop is quit if no characters can be read from the pty
		 * (WaitForChar detected special condition), or there are no
		 * characters available and the child has exited.
		 * Only check if the child has exited when there is no more
		 * output. The child may exit before all the output has
		 * been printed.
		 *
		 * Currently this busy loops!
		 * This can probably dead-lock when the write blocks!
		 */
        p_more_save = p_more;
        p_more = FALSE;
        old_State = State;
        State = EXTERNCMD; /* don't redraw at window resize */

        if ((options & SHELL_WRITE) && toshell_fd >= 0)
        {
          /* Fork a process that will write the lines to the
		     * external program. */
          if ((wpid = fork()) == -1)
          {
            msg_puts(_("\nCannot fork\n"));
          }
          else if (wpid == 0) /* child */
          {
            linenr_T lnum = curbuf->b_op_start.lnum;
            int written = 0;
            char_u *lp = ml_get(lnum);
            size_t l;

            close(fromshell_fd);
            for (;;)
            {
              l = STRLEN(lp + written);
              if (l == 0)
                len = 0;
              else if (lp[written] == NL)
                /* NL -> NUL translation */
                len = write(toshell_fd, "", (size_t)1);
              else
              {
                char_u *s = vim_strchr(lp + written, NL);

                len = write(toshell_fd, (char *)lp + written,
                            s == NULL ? l
                                      : (size_t)(s - (lp + written)));
              }
              if (len == (int)l)
              {
                /* Finished a line, add a NL, unless this line
				 * should not have one. */
                if (lnum != curbuf->b_op_end.lnum || (!curbuf->b_p_bin && curbuf->b_p_fixeol) || (lnum != curbuf->b_no_eol_lnum && (lnum != curbuf->b_ml.ml_line_count || curbuf->b_p_eol)))
                  vim_ignored = write(toshell_fd, "\n",
                                      (size_t)1);
                ++lnum;
                if (lnum > curbuf->b_op_end.lnum)
                {
                  /* finished all the lines, close pipe */
                  close(toshell_fd);
                  toshell_fd = -1;
                  break;
                }
                lp = ml_get(lnum);
                written = 0;
              }
              else if (len > 0)
                written += len;
            }
            _exit(0);
          }
          else /* parent */
          {
            close(toshell_fd);
            toshell_fd = -1;
          }
        }

        if (options & SHELL_READ)
          ga_init2(&ga, 1, BUFLEN);

        noread_cnt = 0;
#ifdef ELAPSED_FUNC
        ELAPSED_INIT(start_tv);
#endif
        for (;;)
        {
          /*
		     * Check if keys have been typed, write them to the child
		     * if there are any.
		     * Don't do this if we are expanding wild cards (would eat
		     * typeahead).
		     * Don't do this when filtering and terminal is in cooked
		     * mode, the shell command will handle the I/O.  Avoids
		     * that a typed password is echoed for ssh or gpg command.
		     * Don't get characters when the child has already
		     * finished (wait_pid == 0).
		     * Don't read characters unless we didn't get output for a
		     * while (noread_cnt > 4), avoids that ":r !ls" eats
		     * typeahead.
		     */
          len = 0;
          if (!(options & SHELL_EXPAND) && ((options & (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) != (SHELL_READ | SHELL_WRITE | SHELL_COOKED)) &&
              wait_pid == 0 && (ta_len > 0 || noread_cnt > 4))
          {
            if (ta_len == 0)
            {
              /* Get extra characters when we don't have any.
			   * Reset the counter and timer. */
              noread_cnt = 0;
#ifdef ELAPSED_FUNC
              ELAPSED_INIT(start_tv);
#endif
              len = ui_inchar(ta_buf, BUFLEN, 10L, 0);
            }
            if (ta_len > 0 || len > 0)
            {
              /*
			 * For pipes:
			 * Check for CTRL-C: send interrupt signal to child.
			 * Check for CTRL-D: EOF, close pipe to child.
			 */
              if (len == 1 && (pty_master_fd < 0 || cmd != NULL))
              {
                /*
			     * Send SIGINT to the child's group or all
			     * processes in our group.
			     */
                may_send_sigint(ta_buf[ta_len], pid, wpid);

                if (pty_master_fd < 0 && toshell_fd >= 0 && ta_buf[ta_len] == Ctrl_D)
                {
                  close(toshell_fd);
                  toshell_fd = -1;
                }
              }

              /* replace K_BS by <BS> and K_DEL by <DEL> */
              for (i = ta_len; i < ta_len + len; ++i)
              {
                if (ta_buf[i] == CSI && len - i > 2)
                {
                  c = TERMCAP2KEY(ta_buf[i + 1], ta_buf[i + 2]);
                  if (c == K_DEL || c == K_KDEL || c == K_BS)
                  {
                    mch_memmove(ta_buf + i + 1, ta_buf + i + 3,
                                (size_t)(len - i - 2));
                    if (c == K_DEL || c == K_KDEL)
                      ta_buf[i] = DEL;
                    else
                      ta_buf[i] = Ctrl_H;
                    len -= 2;
                  }
                }
                else if (ta_buf[i] == '\r')
                  ta_buf[i] = '\n';
                if (has_mbyte)
                  i += (*mb_ptr2len_len)(ta_buf + i,
                                         ta_len + len - i) -
                       1;
              }

              /*
			 * For pipes: echo the typed characters.
			 * For a pty this does not seem to work.
			 */
              if (pty_master_fd < 0)
              {
                for (i = ta_len; i < ta_len + len; ++i)
                {
                  if (ta_buf[i] == '\n' || ta_buf[i] == '\b')
                    msg_putchar(ta_buf[i]);
                  else if (has_mbyte)
                  {
                    int l = (*mb_ptr2len)(ta_buf + i);

                    msg_outtrans_len(ta_buf + i, l);
                    i += l - 1;
                  }
                  else
                    msg_outtrans_len(ta_buf + i, 1);
                }
                windgoto(msg_row, msg_col);
              }

              ta_len += len;

              /*
			 * Write the characters to the child, unless EOF has
			 * been typed for pipes.  Write one character at a
			 * time, to avoid losing too much typeahead.
			 * When writing buffer lines, drop the typed
			 * characters (only check for CTRL-C).
			 */
              if (options & SHELL_WRITE)
                ta_len = 0;
              else if (toshell_fd >= 0)
              {
                len = write(toshell_fd, (char *)ta_buf, (size_t)1);
                if (len > 0)
                {
                  ta_len -= len;
                  mch_memmove(ta_buf, ta_buf + len, ta_len);
                }
              }
            }
          }

          if (got_int)
          {
            /* CTRL-C sends a signal to the child, we ignore it
			 * ourselves */
#ifdef HAVE_SETSID
            kill(-pid, SIGINT);
#else
            kill(0, SIGINT);
#endif
            if (wpid > 0)
              kill(wpid, SIGINT);
            got_int = FALSE;
          }

          /*
		     * Check if the child has any characters to be printed.
		     * Read them and write them to our window.	Repeat this as
		     * long as there is something to do, avoid the 10ms wait
		     * for mch_inchar(), or sending typeahead characters to
		     * the external process.
		     * TODO: This should handle escape sequences, compatible
		     * to some terminal (vt52?).
		     */
          ++noread_cnt;
          while (RealWaitForChar(fromshell_fd, 10L, NULL, NULL))
          {
            len = read_eintr(fromshell_fd, buffer + buffer_off, (size_t)(BUFLEN - buffer_off));
            if (len <= 0) /* end of file or error */
              goto finished;

            noread_cnt = 0;
            if (options & SHELL_READ)
            {
              /* Do NUL -> NL translation, append NL separated
			     * lines to the current buffer. */
              for (i = 0; i < len; ++i)
              {
                if (buffer[i] == NL)
                  append_ga_line(&ga);
                else if (buffer[i] == NUL)
                  ga_append(&ga, NL);
                else
                  ga_append(&ga, buffer[i]);
              }
            }
            else if (has_mbyte)
            {
              int l;
              char_u *p;

              len += buffer_off;
              buffer[len] = NUL;

              /* Check if the last character in buffer[] is
			     * incomplete, keep these bytes for the next
			     * round. */
              for (p = buffer; p < buffer + len; p += l)
              {
                l = MB_CPTR2LEN(p);
                if (l == 0)
                  l = 1; /* NUL byte? */
                else if (MB_BYTE2LEN(*p) != l)
                  break;
              }
              if (p == buffer) /* no complete character */
              {
                /* avoid getting stuck at an illegal byte */
                if (len >= 12)
                  ++p;
                else
                {
                  buffer_off = len;
                  continue;
                }
              }
              c = *p;
              *p = NUL;
              msg_puts((char *)buffer);
              if (p < buffer + len)
              {
                *p = c;
                buffer_off = (buffer + len) - p;
                mch_memmove(buffer, p, buffer_off);
                continue;
              }
              buffer_off = 0;
            }
            else
            {
              buffer[len] = NUL;
              msg_puts((char *)buffer);
            }

            windgoto(msg_row, msg_col);
            cursor_on();
            if (got_int)
              break;

#ifdef ELAPSED_FUNC
            if (wait_pid == 0)
            {
              long msec = ELAPSED_FUNC(start_tv);

              /* Avoid that we keep looping here without
			     * checking for a CTRL-C for a long time.  Don't
			     * break out too often to avoid losing typeahead. */
              if (msec > 2000)
              {
                noread_cnt = 5;
                break;
              }
            }
#endif
          }

          /* If we already detected the child has finished, continue
		     * reading output for a short while.  Some text may be
		     * buffered. */
          if (wait_pid == pid)
          {
            if (noread_cnt < 5)
              continue;
            break;
          }

          /*
		     * Check if the child still exists, before checking for
		     * typed characters (otherwise we would lose typeahead).
		     */
#ifdef __NeXT__
          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);
#else
          wait_pid = waitpid(pid, &status, WNOHANG);
#endif
          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))
          {
            /* Don't break the loop yet, try reading more
			 * characters from "fromshell_fd" first.  When using
			 * pipes there might still be something to read and
			 * then we'll break the loop at the "break" above. */
            wait_pid = pid;
          }
          else
            wait_pid = 0;

#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)
          /* Handle any X events, e.g. serving the clipboard. */
          clip_update();
#endif
        }
      finished:
        p_more = p_more_save;
        if (options & SHELL_READ)
        {
          if (ga.ga_len > 0)
          {
            append_ga_line(&ga);
            /* remember that the NL was missing */
            curbuf->b_no_eol_lnum = curwin->w_cursor.lnum;
          }
          else
            curbuf->b_no_eol_lnum = 0;
          ga_clear(&ga);
        }

        /*
		 * Give all typeahead that wasn't used back to ui_inchar().
		 */
        if (ta_len)
          ui_inchar_undo(ta_buf, ta_len);
        State = old_State;
        if (toshell_fd >= 0)
          close(toshell_fd);
        close(fromshell_fd);
      }
#if defined(FEAT_XCLIPBOARD) && defined(FEAT_X11)
      else
      {
        long delay_msec = 1;

        /*
		 * Similar to the loop above, but only handle X events, no
		 * I/O.
		 */
        for (;;)
        {
          if (got_int)
          {
            /* CTRL-C sends a signal to the child, we ignore it
			 * ourselves */
#ifdef HAVE_SETSID
            kill(-pid, SIGINT);
#else
            kill(0, SIGINT);
#endif
            got_int = FALSE;
          }
#ifdef __NeXT__
          wait_pid = wait4(pid, &status, WNOHANG, (struct rusage *)0);
#else
          wait_pid = waitpid(pid, &status, WNOHANG);
#endif
          if ((wait_pid == (pid_t)-1 && errno == ECHILD) || (wait_pid == pid && WIFEXITED(status)))
          {
            wait_pid = pid;
            break;
          }

          /* Handle any X events, e.g. serving the clipboard. */
          clip_update();

          /* Wait for 1 to 10 msec. 1 is faster but gives the child
		     * less time. */
          mch_delay(delay_msec, TRUE);
          if (++delay_msec > 10)
            delay_msec = 10;
        }
      }
#endif

      /*
	     * Wait until our child has exited.
	     * Ignore wait() returning pids of other children and returning
	     * because of some signal like SIGWINCH.
	     * Don't wait if wait_pid was already set above, indicating the
	     * child already exited.
	     */
      if (wait_pid != pid)
        wait_pid = wait4pid(pid, &status);

      /* Make sure the child that writes to the external program is
	     * dead. */
      if (wpid > 0)
      {
        kill(wpid, SIGKILL);
        wait4pid(wpid, NULL);
      }

#ifdef FEAT_JOB_CHANNEL
      --dont_check_job_ended;
#endif

      /*
	     * Set to raw mode right now, otherwise a CTRL-C after
	     * catch_signals() will kill Vim.
	     */
      if (tmode == TMODE_RAW)
        settmode(TMODE_RAW);
      did_settmode = TRUE;
      set_signals();

      if (WIFEXITED(status))
      {
        /* LINTED avoid "bitwise operation on signed value" */
        retval = WEXITSTATUS(status);
        if (retval != 0 && !emsg_silent)
        {
          if (retval == EXEC_FAILED)
          {
            msg_puts(_("\nCannot execute shell "));
            msg_outtrans(p_sh);
            msg_putchar('\n');
          }
          else if (!(options & SHELL_SILENT))
          {
            msg_puts(_("\nshell returned "));
            msg_outnum((long)retval);
            msg_putchar('\n');
          }
        }
      }
      else
        msg_puts(_("\nCommand terminated\n"));
    }
  }

error:
  if (!did_settmode)
    if (tmode == TMODE_RAW)
      settmode(TMODE_RAW); /* set to raw mode */
  vim_free(argv);
  vim_free(tofree1);
  vim_free(tofree2);

  return retval;
}
```


Overlapping Code:
```
 *cmd,
int options) /* SHELL_*, see vim.h */
{
int tmode = cur_tmode;
pid_t pid;
pid_t wpid = 0;
pid_t wait_pid = 0;
#ifdef HAVE_UNION_WAIT
union wait status;
#else
int status = -1;
#endif
int retval = -1;
char **argv = NULL;
char_u *tofree1 = NULL;
char_u *tofree2 = NULL;
int i;
int pty_master_fd = -1; /* for pty's */
int fd_toshell[2]; /* for pipes */
int fd_fromshell[2];
int pipe_error = FALSE;
int did_settmode = FALSE; /* settmode(TMODE_RAW) called */
if (options & SHELL_COOKED)
settmode(TMODE_COOK); /* set to normal mode */
if (build_argv(cmd, &argv, &tofree1, &tofree2) == FAIL)
goto error;
/*
* For the GUI, when writing the output into the buffer and when reading
* input from the buffer: Try using a pseudo-tty to get the stdin/stdout
* of the executed command into the Vim window. Or use a pipe.
*/
if ((options & (SHELL_READ | SHELL_WRITE)))
{
pipe_error = (pipe(fd_toshell) < 0);
if (!pipe_error) /* pipe create OK */
{
pipe_error = (pipe(fd_fromshell) < 0);
if (pipe_error) /* pipe create failed */
{
close(fd_toshell[0]);
close(fd_toshell[1]);
}
}
if (pipe_error)
{
msg_puts(_("\nCannot create pipes\n"));
}
}
if (!pipe_error) /* pty or pipe opened or not used */
{
SIGSET_DECL(curset)
#ifdef __BEOS__
beos_cleanup_read_thread();
#endif
BLOCK_SIGNALS(&curset);
pid = fork(); /* maybe we should use vfork() */
if (pid == -1)
{
UNBLOCK_SIGNALS(&curset);
msg_puts(_("\nCannot fork\n"));
if ((options & (SHELL_READ | SHELL_WRITE)))
{
close(fd_toshell[0]);
close(fd_toshell[1]);
close(fd_fromshell[0]);
close(fd_fromshell[1]);
}
}
else if (pid == 0) /* child */
{
reset_signals(); /* handle signals normally */
UNBLOCK_SIGNALS(&curset);
#ifdef FEAT_JOB_CHANNEL
if (ch_log_active())
/* close the log file in the child */
ch_logfile((char_u *)"", (char_u *)"");
#endif
if (!show_shell_mess || (options & SHELL_EXPAND))
{
int fd;
/*
* Don't want to show any message from the shell. Can't just
* close stdout and stderr though, because some systems will
* break if you try to write to them after that, so we must
* use dup() to replace them with something else -- webb
* Connect stdin to /dev/nu
```
<Overlap Ratio: 0.9804469273743017>

---

--- 298 --
Question ID: ba767b0ba6a7947b320418455e7332dd9cf0a6cc_12
Original Code:
```
static void ax_setmulti(sc)
	struct ax_softc		*sc;
{
	struct ifnet		*ifp;
	int			h = 0;
	u_int32_t		hashes[2] = { 0, 0 };
	struct ifmultiaddr	*ifma;
	u_int32_t		rxfilt;

	ifp = &sc->arpcom.ac_if;

	rxfilt = CSR_READ_4(sc, AX_NETCFG);

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		rxfilt |= AX_NETCFG_RX_ALLMULTI;
		CSR_WRITE_4(sc, AX_NETCFG, rxfilt);
		return;
	} else
		rxfilt &= ~AX_NETCFG_RX_ALLMULTI;

	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);
	CSR_WRITE_4(sc, AX_FILTDATA, 0);
	CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);
	CSR_WRITE_4(sc, AX_FILTDATA, 0);

	/* now program new ones */
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
				ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = ax_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
	}

	CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);
	CSR_WRITE_4(sc, AX_FILTDATA, hashes[0]);
	CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);
	CSR_WRITE_4(sc, AX_FILTDATA, hashes[1]);
	CSR_WRITE_4(sc, AX_NETCFG, rxfilt);

	return;
}
```


Overlapping Code:
```
(sc)
struct ax_softc *sc;
{
struct ifnet *ifp;
int h = 0;
u_int32_t hashes[2] = { 0, 0 };
struct ifmultiaddr *ifma;
u_int32_t rxfilt;
ifp = &sc->arpcom.ac_if;
rxfilt = CSR_READ_4(sc, AX_NETCFG);
if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
rxfilt |= AX_NETCFG_RX_ALLMULTI;
CSR_WRITE_4(sc, AX_NETCFG, rxfilt);
return;
} else
rxfilt &= ~AX_NETCFG_RX_ALLMULTI;
/* first, zot all the existing hash bits */
CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);
CSR_WRITE_4(sc, AX_FILTDATA, 0);
CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);
CSR_WRITE_4(sc, AX_FILTDATA, 0);
/* now program new ones */
for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
ifma = ifma->ifma_link.le_next) {
if (ifma->ifma_addr->sa_family != AF_LINK)
continue;
h = ax_calchash(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
if (h < 32)
hashes[0] |= (1 << h);
else
hashes[1] |= (1 << (h - 32));
}
CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR0);
CSR_WRITE_4(sc, AX_FILTDATA, hashes[0]);
CSR_WRITE_4(sc, AX_FILTIDX, AX_FILTIDX_MAR1);
CSR_WRITE_4(sc, AX_FILTDATA, hashes[1]);
CSR_WRITE_4(sc, AX_NETCFG, rxfilt);
return;

```
<Overlap Ratio: 0.978742249778565>

---

--- 299 --
Question ID: d07f88bd6be5a69ce5235f8570193f1a2f7cda6b_7
Original Code:
```
eType findWithDuplicates(eType v) {
    kType vKey = hashStruct.getKey(v);
    intT h = firstIndex(vKey);
    eType c = TA[h];
    while (1) {
      if (c == empty) {
	return empty;
      } else if (!hashStruct.cmp(vKey,hashStruct.getKey(c))) {
	intT* vCoordinates = (intT *)v.first;
	intT* cCoordinates = (intT *)c.first;
	long i = 0;
	for(;i<g_dim;i++) {
	  if(vCoordinates[i] != cCoordinates[i])
	    break;
	}
	if(i == g_dim) {
	  // never reach here
	  return c;
	}
      }
      h = incrementIndex(h);
      c = TA[h];
    }
  }
```


Overlapping Code:
```
hDuplicates(eType v) {
kType vKey = hashStruct.getKey(v);
intT h = firstIndex(vKey);
eType c = TA[h];
while (1) {
if (c == empty) {
return empty;
} else if (!hashStruct.cmp(vKey,hashStruct.getKey(c))) {
intT* vCoordinates = (intT *)v.first;
intT* cCoordinates = (intT *)c.first;
long i = 0;
for(;i<g_dim;i++) {
if(vCoordinates[i] != cCoordinates[i])
break;
}
if(i == g_dim) {
// never reach here
retu
```
<Overlap Ratio: 0.8695652173913043>

---

--- 300 --
Question ID: 787a9bf8b624a39c223c912d92f4770953fb9d2d_8
Original Code:
```
void Delay100ms() {
  unsigned char i, j, k;

  i = 10;
  j = 153;
  k = 44;
  do {
    do {
      while (--k) {};
    } while (--j);
  } while (--i);
}
```


Overlapping Code:
```
;
i = 10;
j = 153;
k = 44;
do {
do {
while (--k) {};
} while (--j);
} while 
```
<Overlap Ratio: 0.608>

---

--- 301 --
Question ID: 8f8a74aa0650db15ac8a348b715127ca832c0e8e_0
Original Code:
```
char *get_file_content(const char *filename) {
  char *buffer = NULL;
  long length;

  FILE *f = fopen(filename, "rb");
  if (f) {
    fseek(f, 0, SEEK_END);
    length = ftell(f);
    fseek(f, 0, SEEK_SET);
    buffer = malloc(length + 1);
    if (buffer) {
      size_t n = fread(buffer, 1, length, f);
      if (n != length) {
        free(buffer);
        return NULL;
      }
      buffer[length] = 0;
    }
    fclose(f);
  }
  return buffer;
}
```


Overlapping Code:
```
char *filename) {
char *buffer = NULL;
long length;
FILE *f = fopen(filename, "rb");
if (f) {
fseek(f, 0, SEEK_END);
length = ftell(f);
fseek(f, 0, SEEK_SET);
buffer = malloc(length + 1);
if (buffer) {
size_t n = fread(buffer, 1, length, f);
if (n != length) {
free(buffer);
return NULL;
}
buffer[length] =
```
<Overlap Ratio: 0.827027027027027>

---

--- 302 --
Question ID: 12efbf5c1165cfa12162c496a35b49392e0dfb2a_0
Original Code:
```
double mc_update(double delta_theta_m_star, double delta_theta_m, double Ts)
{
    // Run through motion controller block diagram
    double delta_theta_m_error = delta_theta_m_star - delta_theta_m;
    delta_theta_m_error_acc += delta_theta_m_error;
    delta_theta_m_error_acc_acc += delta_theta_m_error_acc;

    // Calculate commanded torque
    double term1 = (Ba / Ts * delta_theta_m_error);
    double term2 = (Ksa * delta_theta_m_error_acc);
    double term3 = (Kisa * Ts * delta_theta_m_error_acc_acc);
    double Tem_SFB_star = term1 + term2 + term3;

    return Tem_SFB_star;
}
```


Overlapping Code:
```
le mc_update(double delta_theta_m_star, double delta_theta_m, double Ts)
{
// Run through motion controller block diagram
double delta_theta_m_error = delta_theta_m_star - delta_theta_m;
delta_theta_m_error_acc += delta_theta_m_error;
delta_theta_m_error_acc_acc += delta_theta_m_error_acc;
// Calculate commanded torque
double term1 = (Ba / Ts * delta_theta_m_error);
double term2 = (Ksa * delta_theta_m_error_acc);
double term3 = (Kisa * Ts * delta_theta_m_error_acc_acc);
double Tem_SFB_star = term1 + term2 + term3;
```
<Overlap Ratio: 0.9505494505494505>

---

--- 303 --
Question ID: f8cef715651a42063216dc3b76c716ee89e4dc42_486
Original Code:
```
void test_cil_gen_category_currnull_neg(CuTest *tc) {
	char *line[] = {"(", "category", "c0", ")", NULL};

	struct cil_tree *test_tree;
	gen_test_tree(&test_tree, line);

	struct cil_db *test_db;
	cil_db_init(&test_db);

	struct cil_tree_node *test_ast_node;
	cil_tree_node_init(&test_ast_node);

	test_ast_node->parent = test_db->ast->root;
	test_ast_node->line = 1;

	int rc = cil_gen_category(test_db, NULL, test_ast_node);
	CuAssertIntEquals(tc, SEPOL_ERR, rc);
}
```


Overlapping Code:
```
n_category_currnull_neg(CuTest *tc) {
char *line[] = {"(", "category", "c0", ")", NULL};
struct cil_tree *test_tree;
gen_test_tree(&test_tree, line);
struct cil_db *test_db;
cil_db_init(&test_db);
struct cil_tree_node *test_ast_node;
cil_tree_node_init(&test_ast_node);
test_ast_node->parent = test_db->ast->root;
test_ast_node->line = 1;
int rc = cil_gen_category(test_db, NULL, test_ast_node);
CuAssertIntEquals(tc, SEPOL_ERR, rc);
}
```
<Overlap Ratio: 0.9645232815964523>

---

--- 304 --
Question ID: e7a98ba1c3f68b50b1d95217e4b8c85956e1e93d_7
Original Code:
```
bool BKE_autotrack_context_step(AutoTrackContext *context)
{
  const int frame_delta = context->backwards ? -1 : 1;
  context->step_ok = false;

  TaskParallelSettings settings;
  BLI_parallel_range_settings_defaults(&settings);
  settings.use_threading = (context->num_tracks > 1);
  BLI_task_parallel_range(0, context->num_tracks, context, autotrack_context_step_cb, &settings);

  /* Advance the frame. */
  BLI_spin_lock(&context->spin_lock);
  context->user.framenr += frame_delta;
  BLI_spin_unlock(&context->spin_lock);
  return context->step_ok;
}
```


Overlapping Code:
```
context_step(AutoTrackContext *context)
{
const int frame_delta = context->backwards ? -1 : 1;
context->step_ok = false;
TaskParallelSettings settings;
BLI_parallel_range_settings_defaults(&settings);
settings.use_threading = (context->num_tracks > 1);
BLI_task_parallel_range(0, context->num_tracks, context, autotrack_context_step_cb, &settings);
/* Advance the frame. */
BLI_spin_lock(&context->spin_lock);
context->user.framenr += frame_delta;
BLI_spin_unlock(&context->spin_lock);
return context
```
<Overlap Ratio: 0.9416195856873822>

---

--- 305 --
Question ID: 6cfd14103a65f135b7307f74243a608fc8eb4e23_9
Original Code:
```
int javaBindClass(lua_State *L) {
    int top;
    const char *className;
    jstring javaClassName;
    jobject classInstance;
    JNIEnv *javaEnv;

    top = lua_gettop(L);

    if (top != 1) {
        luaL_error(
                L, "Error. Function javaBindClass received %d arguments, expected 1.",
                top);
    }

    /* Gets the JNI Environment */
    javaEnv = checkEnv(L);

    /* get the string parameter */
    className = luaL_checkstring(L, 1);

    javaClassName = (*javaEnv)->NewStringUTF(javaEnv, className);

    classInstance = (*javaEnv)->CallStaticObjectMethod(
            javaEnv, luajava_api_class, bind_class_method, javaClassName);

    (*javaEnv)->DeleteLocalRef(javaEnv, javaClassName);
    checkError(javaEnv, L);

    /* pushes new object into lua stack */
    pushJavaObject(L, classInstance);
    (*javaEnv)->DeleteLocalRef(javaEnv, classInstance);
    return 1;
}
```


Overlapping Code:
```
javaBindClass(lua_State *L) {
int top;
const char *className;
jstring javaClassName;
jobject classInstance;
JNIEnv *javaEnv;
top = lua_gettop(L);
if (top != 1) {
luaL_error(
L, "Error. Function javaBindClass received %d arguments, expected 1.",
top);
}
/* Gets the JNI Environment */
javaEnv = checkEnv(L);
/* get the string parameter */
className = luaL_checkstring(L, 1);
javaClassName = (*javaEnv)->NewStringUTF(javaEnv, className);
classInstance = (*javaEnv)->CallStaticObjectMethod(
javaEnv, luajava_api_class, bind_class_method, javaClassName);
(*javaEnv)->DeleteLocalRef(javaEnv, javaClassName);
checkError(javaEnv, L);
/* pushes new object into lua stack */
pushJavaObject(L, classInstance);
(*javaEnv)->DeleteLocalRef(javaEnv, classInstance)
```
<Overlap Ratio: 0.9778357235984355>

---

--- 306 --
Question ID: 149a72dc1074dd8a92f47541ad49f4f009b30466_0
Original Code:
```
int main()
{
    int exited = 0;
    int user = USER;

    init_movies();
    printf("========= Movie Rental Service v0.1 =========\n");
    printf("   . . . Initializing the inventory . . .\n");
    printf("         (movie info from IMDb.com)\n");
    printf("=============================================\n");


    while (!exited) {
        if (user == USER)
            exited = run_user_mode(&user);
        else if(user == ADMIN)
        {
            if (run_admin_mode(&user) < 0)
                exited = 1;
        }
        else if(user == DEBUG)
            run_debug_mode(&user);

        if (!exited)
            printf("\n");
    }
    printf("Bye!\n");
}
```


Overlapping Code:
```
()
{
int exited = 0;
int user = USER;
init_movies();
printf("========= Movie Rental Service v0.1 =========\n");
printf(" . . . Initializing the inventory . . .\n");
printf(" (movie info from IMDb.com)\n");
printf("=============================================\n");
while (!exited) {
if (user == USER)
exited = run_user_mode(&user);
else if(user == ADMIN)
{
if (run_admin_mode(&user) < 0)
exited = 1;
}
else if(user == DEBUG)
run_debug_mode(&user);
if
```
<Overlap Ratio: 0.8928571428571429>

---

--- 307 --
Question ID: 13a4c17f8fb7428bdddbbf219d5607a39603fbd7_16
Original Code:
```
void initBaxNames(BaxData *b, char *fname)
  {
// set pointer from fname to b->fullname
    b->fullName = fname;

    char *c;
    int epos;

    c = strrchr(fname, '/');
    if (c != NULL)
      b->shortNameBeg = c - fname + 1;
    else
      b->shortNameBeg = 0;

    epos = strlen(fname);

    if ((epos >= 9) && ((strcasecmp(fname + (epos - 9), ".1.bax.h5") == 0) || (strcasecmp(fname + (epos - 9), ".2.bax.h5") == 0) || (strcasecmp(fname + (epos - 9), ".3.bax.h5") == 0)))
      b->shortNameEnd = epos - 9;
    else
      b->shortNameEnd = epos;
  }
```


Overlapping Code:
```
BaxNames(BaxData *b, char *fname)
{
// set pointer from fname to b->fullname
b->fullName = fname;
char *c;
int epos;
c = strrchr(fname, '/');
if (c != NULL)
b->shortNameBeg = c - fname + 1;
else
b->shortNameBeg = 0;
epos = strlen(fname);
if ((epos >= 9) && ((strcasecmp(fname + (epos - 9), ".1.bax.h5") == 0) || (strcasecmp(fname + (epos - 9), ".2.bax.h5") == 0) || (strcasecmp(fname + (epos - 9), ".3.bax.h5") == 0)))
b->shortNameEnd = epos - 9;
els
```
<Overlap Ratio: 0.9259259259259259>

---

--- 308 --
Question ID: 9659fcaa34ed5001f973f62ed600aebc4e314885_3
Original Code:
```
static int pci200_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
	const size_t size = sizeof(sync_serial_settings);
	sync_serial_settings new_line;
	sync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;
	port_t *port = dev_to_port(dev);

#ifdef DEBUG_RINGS
	if (cmd == SIOCDEVPRIVATE) {
		sca_dump_rings(dev);
		return 0;
	}
#endif
	if (cmd != SIOCWANDEV)
		return hdlc_ioctl(dev, ifr, cmd);

	switch(ifr->ifr_settings.type) {
	case IF_GET_IFACE:
		ifr->ifr_settings.type = IF_IFACE_V35;
		if (ifr->ifr_settings.size < size) {
			ifr->ifr_settings.size = size; /* data size wanted */
			return -ENOBUFS;
		}
		if (copy_to_user(line, &port->settings, size))
			return -EFAULT;
		return 0;

	case IF_IFACE_V35:
	case IF_IFACE_SYNC_SERIAL:
		if (!capable(CAP_NET_ADMIN))
			return -EPERM;

		if (copy_from_user(&new_line, line, size))
			return -EFAULT;

		if (new_line.clock_type != CLOCK_EXT &&
		    new_line.clock_type != CLOCK_TXFROMRX &&
		    new_line.clock_type != CLOCK_INT &&
		    new_line.clock_type != CLOCK_TXINT)
			return -EINVAL;	/* No such clock setting */

		if (new_line.loopback != 0 && new_line.loopback != 1)
			return -EINVAL;

		memcpy(&port->settings, &new_line, size); /* Update settings */
		pci200_set_iface(port);
		sca_flush(port->card);
		return 0;

	default:
		return hdlc_ioctl(dev, ifr, cmd);
	}
}
```


Overlapping Code:
```
00_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
{
const size_t size = sizeof(sync_serial_settings);
sync_serial_settings new_line;
sync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;
port_t *port = dev_to_port(dev);
#ifdef DEBUG_RINGS
if (cmd == SIOCDEVPRIVATE) {
sca_dump_rings(dev);
return 0;
}
#endif
if (cmd != SIOCWANDEV)
return hdlc_ioctl(dev, ifr, cmd);
switch(ifr->ifr_settings.type) {
case IF_GET_IFACE:
ifr->ifr_settings.type = IF_IFACE_V35;
if (ifr->ifr_settings.size < size) {
ifr->ifr_settings.size = size; /* data size wanted */
return -ENOBUFS;
}
if (copy_to_user(line, &port->settings, size))
return -EFAULT;
return 0;
case IF_IFACE_V35:
case IF_IFACE_SYNC_SERIAL:
if (!capable(CAP_NET_ADMIN))
return -EPERM;
if (copy_from_user(&new_line, line, size))
return -EFAULT;
if (new_line.clock_type != CLOCK_EXT &&
new_line.clock_type != CLOCK_TXFROMRX &&
new_line.clock_type != CLOCK_INT &&
new_line.clock_type != CLOCK_TXINT)
return -EINVAL; /* No such clock setting */
if (new_line.loopback != 0 && new_line.loopback != 1)
return -EINVAL;
memcpy(&port->settings, &new_line, size); /* Update settings */
pci200_set_iface(port);
sca_flush(port->card);
return 0;
default:
return hdlc_ioctl(dev, ifr, cmd);
}
}
```
<Overlap Ratio: 0.9881235154394299>

---

--- 309 --
Question ID: 75bb0e1f4f78fa338d3d57bdd7f9a074ff9f32a4_1
Original Code:
```
static inline __attribute__((always_inline))
void core_enqueue_to_q_spent(struct seq_admission_core_state *core,
		struct fp_ring *queue_spent, struct fp_mempool *bin_mempool,
		uint16_t src, uint16_t dst, uint32_t metric)
{
	/* add to status->new_demands */
	enqueue_bin(core->spent_bin, src, dst, 0, metric);

	if (unlikely(bin_size(core->spent_bin) == SMALL_BIN_SIZE)) {
		adm_log_q_spent_flush_bin_full(&core->stat);
		core_flush_q_spent(core, queue_spent, bin_mempool);
	}
}
```


Overlapping Code:
```
static inline __attribute__((always_inline))
void core_enqueue_to_q_spent(struct seq_admission_core_state *core,
struct fp_ring *queue_spent, struct fp_mempool *bin_mempool,
uint16_t src, uint16_t dst, uint32_t metric)
{
/* add to status->new_demands */
enqueue_bin(core->spent_bin, src, dst, 0, metric);
if (unlikely(bin_size(core->spent_bin) == SMALL_BIN_SIZE)) {
adm_log_q_spent_flush_bin_full(&core->stat);
core_flush_q_spent(core, queue_spent, bin
```
<Overlap Ratio: 0.9699570815450643>

---

--- 310 --
Question ID: 1f78d5108175fa60bf869fde5486b5c3f282c4c3_6
Original Code:
```
XcursorBool
XcursorSetTheme (Display *dpy, const char *theme)
{
    XcursorDisplayInfo	*info = _XcursorGetDisplayInfo (dpy);
    char		*copy;

    if (!info)
	return XcursorFalse;

    if (!theme)
	theme = info->theme_from_config;

    if (theme)
    {
	copy = malloc (strlen (theme) + 1);
	if (!copy)
	    return XcursorFalse;
	strcpy (copy, theme);
    }
    else
	copy = 0;
    if (info->theme)
	free (info->theme);
    info->theme = copy;
    return XcursorTrue;
}
```


Overlapping Code:
```
onst char *theme)
{
XcursorDisplayInfo *info = _XcursorGetDisplayInfo (dpy);
char *copy;
if (!info)
return XcursorFalse;
if (!theme)
theme = info->theme_from_config;
if (theme)
{
copy = malloc (strlen (theme) + 1);
if (!copy)
return XcursorFalse;
strcpy (copy, theme);
}
else
copy = 0;
if (info->theme)
free (info->theme);
info->theme = copy;
return 
```
<Overlap Ratio: 0.8578431372549019>

---

--- 311 --
Question ID: 56659d30f3fcb68f60460290a6be7431f34d0ddc_6
Original Code:
```
int main (int argc, char **argv)
{

    double Info [UMFPACK_INFO], Control [UMFPACK_CONTROL], *Ax, *Cx, *Lx, *Ux,
	*W, t [2], *Dx, rnorm, *Rb, *y, *Rs, my_t, *Aval ;
    int *Ap, *Ai, *Cp, *Ci, row, col, p, lnz, unz, nr, nc, *Lp, *Li, *Ui, *Up,
	*P, *Q, *Lj, i, j, k, anz, nfr, nchains, *Qinit, fnpiv, lnz1, unz1, nz1,
	status, *Front_npivcol, *Front_parent, *Chain_start, *Wi, *Pinit, n1,
	*Chain_maxrows, *Chain_maxcols, *Front_1strow, *Front_leftmostdesc,
	nzud, do_recip, *Arow, *Acol ;
    void *Symbolic, *Numeric ;

    int n, nz;
    double *b, *x, *r ;

    /* ---------------------------------------------------------------------- */
    /* initializations */
    /* ---------------------------------------------------------------------- */

    umfpack_tic (t) ;

    printf ("\nUMFPACK V%d.%d (%s) demo: _di_ version\n",
	    UMFPACK_MAIN_VERSION, UMFPACK_SUB_VERSION, UMFPACK_DATE) ;

    /* get the default control parameters */
    umfpack_di_defaults (Control) ;

    // Try no re-ordering to preserve L shape of the matrix
    /* Control [UMFPACK_ORDERING] = UMFPACK_ORDERING_NONE ; */
    // no iterative refinement, only single solve
    Control [UMFPACK_IRSTEP] = 0;

    /* change the default print level for this demo */
    /* (otherwise, nothing will print) */
    Control [UMFPACK_PRL] = 6 ;

    /* print the license agreement */
    umfpack_di_report_status (Control, UMFPACK_OK) ;
    Control [UMFPACK_PRL] = 5 ;

    /* print the control parameters */
    umfpack_di_report_control (Control) ;

    /* read matrix */
      // args
    int nrequired_args = 4;
    if (argc != nrequired_args){
        fprintf(stderr, "improper arguments");
        exit(1);
    }
    /** parse arguments */
    int iarg = 1;
    char* strpathA = argv[iarg];    iarg++;
    int nthreads = atoi(argv[iarg]);    iarg++;
    int n_solve_iter = atoi(argv[iarg]);    iarg++;
    assert(nrequired_args == iarg);
    
    FILE *fp= fopen(strpathA, "r");
    problem *Prob= get_problem(fp, 0);
    
    n= (int) Prob->A->n;
    nz= (int) Prob->A->nzmax;
    b= Prob->b;
    x= Prob->x;
    r= Prob->resid;
    Arow = Prob->Arow;
    Acol = Prob->Acol;
    Aval = Prob->Aval;

    printf("# non-zeroes: %d\n", nz);

    printf("%d, %d, %f\n", Arow[0], Acol[0], Aval[0]);
    printf("%d, %d, %f\n", Arow[nz], Acol[nz], Aval[nz]);
    /* status = umfpack_di_report_triplet (n, n, nz, Arow, Acol, Aval, Control) ; */
    /* if (status < 0) */
    /* { */
    /*   umfpack_di_report_status (Control, status) ; */
    /*   error ("umfpack_di_report_triplet failed") ; */
    /* } */

    /* convert to column form */
    nz1 = MAX (nz,1) ;	/* ensure arrays are not of size zero. */
    Ap = (int *) malloc ((n+1) * sizeof (int)) ;
    Ai = (int *) malloc (nz1 * sizeof (int)) ;
    Ax = (double *) malloc (nz1 * sizeof (double)) ;
    if (!Ap || !Ai || !Ax)
    {
	error ("out of memory") ;
    }

    status = umfpack_di_triplet_to_col (n, n, nz, Arow, Acol, Aval,
	Ap, Ai, Ax, (int *) NULL) ;
    if (status < 0)
    {
	umfpack_di_report_status (Control, status) ;
	error ("umfpack_di_triplet_to_col failed") ;
    }

    /* for (i = 0 ; i < n + 1 ; i++) Ap[i] = (int) Prob->A->p[i]; */
    /* for (i = 0 ; i < nz; i++) Ai[i] = (int) Prob->A->i[i]; */
    /* for (i = 0 ; i < nz; i++) Ax[i] = Prob->A->x[i]; */
    if PRINT {
      for (i = 0 ; i < n + 1 ; i++) printf("\n Ap[%d]: %d, ", i, Ap[i]);
      for (i = 0 ; i < nz ; i++) printf("\n Ai[%d]: %d, ", i, Ai[i]);
      for (i = 0 ; i < nz ; i++) printf("\n Ax[%d]: %lf, ", i, Ax[i]);
    }
    
    printf("Ap[0] : %d\n", Ap[0]);
    printf("Ap[n] : %d\n", Ap[n]);
    assert (Ap[0] == 0);
    assert (Ap[n] >= 0);
    for (i = 1 ; i < n + 1 ; i++) {
      assert ( Ap[i] >= Ap[i-1] );
      for (j = Ap [ i-1 ] ; j < Ap [ i ] ; j++) {
        assert (Ai [ j ] < n);
        if ( Ai[ j ] < i-1 ) {
          printf("Ai[j]: %d,i: %d", Ai[j], i-1 ); error( "Not an L marix" ) ;
        }
      }
      for (j = Ap [ i-1 ] + 1 ; j < Ap [ i ] ; j++) {
        if ( Ai [ j ] == Ai [ j-1 ] ) {
          printf("Ai[j]: %d, Ai[j-1]: %d", Ai[j], Ai[j-1] ); error( "Duplicates" ) ;
        }
      }
    }
    /* for (i = 0 ; i < nz ; i++) */
    /* { */ 
    /*   if ( Ai[i] < i ) {printf("Ai[i]: %d,i: %d", Ai[i], i ); error( "Not an L marix" ) ; } */
    /* } // L matrix */
    /* Ap= Prob->A->p; */
    /* Ai= Prob->A->i; */
    /* Ax= Prob->A->x; */

    rhs (x, b, n) ;                             /* compute right-hand side */


    /* ---------------------------------------------------------------------- */
    /* symbolic factorization */
    /* ---------------------------------------------------------------------- */

    printf("Here\n");
    status = umfpack_di_symbolic (n, n, Ap, Ai, Ax, &Symbolic,
	Control, Info) ;
    if (status < 0)
    {
      umfpack_di_report_info (Control, Info) ;
      umfpack_di_report_status (Control, status) ;
      printf ("umfpack_di_symbolic failed, error code: %d", status) ;
      error ("umfpack_di_symbolic failed") ;
    }
    printf("symbolic done\n");

    /* ---------------------------------------------------------------------- */
    /* numeric factorization */
    /* ---------------------------------------------------------------------- */

    status = umfpack_di_numeric (Ap, Ai, Ax, Symbolic, &Numeric,
	Control, Info) ;
    if (status < 0)
    {
	umfpack_di_report_info (Control, Info) ;
	umfpack_di_report_status (Control, status) ;
	error ("umfpack_di_numeric failed") ;
    }

    if PRINT {
      /* print the numeric factorization */
      printf ("\nNumeric factorization of A: ") ;
      (void) umfpack_di_report_numeric (Numeric, Control) ;
    }

    if (umfpack_di_get_lunz (&lnz, &unz, &nr, &nc, &nzud, Numeric) < 0)
    {
      error ("umfpack_di_get_lunz failed") ;
    }

    printf("LU factor statistics: lnz: %d, unz: %d, nr: %d, nc: %d, n: %d, nzud: %d\n", lnz, unz, nr, nc, n, nzud);

    /* ---------------------------------------------------------------------- */
    /* solve Ax=b */
    /* ---------------------------------------------------------------------- */
    double tot_time=0.;
  my_t = tic () ;
    for (i = 0 ; i < n_solve_iter ; i++) {
      status = umfpack_di_solve (UMFPACK_A, Ap, Ai, Ax, x, b,
        Numeric, Control, Info) ;
      tot_time += Info[UMFPACK_SOLVE_TIME];
    }
  my_t= toc(my_t);
 
    umfpack_di_report_info (Control, Info) ;
    /* umfpack_di_report_status (Control, status) ; */
    if (status < 0)
    {
	error ("umfpack_di_solve failed") ;
    }
    printf ("\nx (solution of Ax=b): ") ;
    (void) umfpack_di_report_vector (MIN(10, n), x, Control) ;
    rnorm = resid (FALSE, n, Ap, Ai, Ax, x, b, r) ;
    printf ("maxnorm of residual: %g\n\n", rnorm) ;

  printf("\n UMFPACK_Info, iterative refinement steps take, %f, iterative refinement steps attempted + 1, %f , flops, %8.9f, time, %8.9f, avg reported time (seconds), %8.9f\n", Info[UMFPACK_IR_TAKEN], Info[UMFPACK_IR_ATTEMPTED] + 1, Info[UMFPACK_SOLVE_FLOPS], Info[UMFPACK_SOLVE_TIME], tot_time/n_solve_iter);
  /* printf ("\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual: %g\n", n_solve_iter, my_t, rnorm) ; */
  printf ("\n n_solve_iter : %d, solve_time (seconds), %8.9f, residual, %g, flops, %g\n", n_solve_iter, tot_time, rnorm, Info[UMFPACK_SOLVE_FLOPS]) ;
  free_problem(Prob);
  return 0;
}
```


Overlapping Code:
```
c, char **argv)
{
double Info [UMFPACK_INFO], Control [UMFPACK_CONTROL], *Ax, *Cx, *Lx, *Ux,
*W, t [2], *Dx, rnorm, *Rb, *y, *Rs, my_t, *Aval ;
int *Ap, *Ai, *Cp, *Ci, row, col, p, lnz, unz, nr, nc, *Lp, *Li, *Ui, *Up,
*P, *Q, *Lj, i, j, k, anz, nfr, nchains, *Qinit, fnpiv, lnz1, unz1, nz1,
status, *Front_npivcol, *Front_parent, *Chain_start, *Wi, *Pinit, n1,
*Chain_maxrows, *Chain_maxcols, *Front_1strow, *Front_leftmostdesc,
nzud, do_recip, *Arow, *Acol ;
void *Symbolic, *Numeric ;
int n, nz;
double *b, *x, *r ;
/* ---------------------------------------------------------------------- */
/* initializations */
/* ---------------------------------------------------------------------- */
umfpack_tic (t) ;
printf ("\nUMFPACK V%d.%d (%s) demo: _di_ version\n",
UMFPACK_MAIN_VERSION, UMFPACK_SUB_VERSION, UMFPACK_DATE) ;
/* get the default control parameters */
umfpack_di_defaults (Control) ;
// Try no re-ordering to preserve L shape of the matrix
/* Control [UMFPACK_ORDERING] = UMFPACK_ORDERING_NONE ; */
// no iterative refinement, only single solve
Control [UMFPACK_IRSTEP] = 0;
/* change the default print level for this demo */
/* (otherwise, nothing will print) */
Control [UMFPACK_PRL] = 6 ;
/* print the license agreement */
umfpack_di_report_status (Control, UMFPACK_OK) ;
Control [UMFPACK_PRL] = 5 ;
/* print the control parameters */
umfpack_di_report_control (Control) ;
/* read matrix */
// args
int nrequired_args = 4;
if (argc != nrequired_args){
fprintf(stderr, "improper arguments");
exit(1);
}
/** parse arguments */
int iarg = 1;
char* strpathA = argv[iarg]; iarg++;
int nthreads = atoi(argv[iarg]); iarg++;
int n_solve_iter = atoi(argv[iarg]); iarg++;
assert(nrequired_args == iarg);

FILE *fp= fopen(strpathA, "r");
problem *Prob= get_problem(fp, 0);

n= (int) Prob->A->n;
nz= (int) Prob->A->nzmax;
b= Prob->b;
x= Prob->x;
r= Prob->resid;
Arow = Prob->Arow;
Acol = Prob->Acol;
Aval = Prob->Aval;
printf("# non-zeroes: %d\n", nz);
printf("%d, %d, %f\n", Arow[0], Acol[0], Aval[0]);
printf("%d, %d, %f\n", Arow[nz], Acol[nz], Aval[nz]);
/* status = umfpack_di_report_triplet (n, n, nz, Arow, Acol, Aval, Control) ; */
/* if (status < 0) */
/* { */
/* umfpack_di_report_status (Cont
```
<Overlap Ratio: 0.9896907216494846>

---

--- 312 --
Question ID: a350872cd5cd50d2158bda2d1c9c723172b21e10_5
Original Code:
```
struct tm *localtime_r(const time_t *timep, struct tm *tm)
{
   struct tm *ltm;

   static pthread_mutex_t mutex;
   static int first = 1;

   if (first) {
      pthread_mutex_init(&mutex, NULL);
      first = 0;
   }

   P(mutex);

   ltm = localtime(timep);
   if (ltm)
      memcpy(tm, ltm, sizeof(struct tm));

   V(mutex);

   return ltm ? tm : NULL;
}
```


Overlapping Code:
```
struct tm *localtime_r(const time_t *timep, struct tm *tm)
{
struct tm *ltm;
static pthread_mutex_t mutex;
static int first = 1;
if (first) {
pthread_mutex_init(&mutex, NULL);
first = 0;
}
P(mutex);
ltm = localtime(timep);
if (ltm)
memcpy(tm, ltm, sizeof(struct tm));
V(mutex);
return 
```
<Overlap Ratio: 0.9405940594059405>

---

--- 313 --
Question ID: 968699c220483927480a1192fbb3e6d470a4a602_16
Original Code:
```
static inline void convert_VkGeometryTrianglesNV_win_to_host(const VkGeometryTrianglesNV *in, VkGeometryTrianglesNV_host *out)
{
    if (!in) return;

    out->sType = in->sType;
    out->pNext = in->pNext;
    out->vertexData = in->vertexData;
    out->vertexOffset = in->vertexOffset;
    out->vertexCount = in->vertexCount;
    out->vertexStride = in->vertexStride;
    out->vertexFormat = in->vertexFormat;
    out->indexData = in->indexData;
    out->indexOffset = in->indexOffset;
    out->indexCount = in->indexCount;
    out->indexType = in->indexType;
    out->transformData = in->transformData;
    out->transformOffset = in->transformOffset;
}
```


Overlapping Code:
```
 convert_VkGeometryTrianglesNV_win_to_host(const VkGeometryTrianglesNV *in, VkGeometryTrianglesNV_host *out)
{
if (!in) return;
out->sType = in->sType;
out->pNext = in->pNext;
out->vertexData = in->vertexData;
out->vertexOffset = in->vertexOffset;
out->vertexCount = in->vertexCount;
out->vertexStride = in->vertexStride;
out->vertexFormat = in->vertexFormat;
out->indexData = in->indexData;
out->indexOffset = in->indexOffset;
out->indexCount = in->indexCount;
out->indexType = in->indexType;
out->transformData = in->transformData;
out->transformOffset = in->transformOffset;

```
<Overlap Ratio: 0.9681742043551089>

---

--- 314 --
Question ID: 415cfc30a4f6bc334dbd2ae41596e666b641748f_1
Original Code:
```
MM_API int mm_manage_fd(int new_fd, char* back, int manage, void* impl){
	backend* b = backend_match(back);
	size_t u;

	if(!b){
		LOGPF("Unknown backend %s registered for managed fd", back);
		return 1;
	}

	//find exact match
	for(u = 0; u < fds.n; u++){
		if(fds.fd[u].fd == new_fd && fds.fd[u].backend == b){
			fds.fd[u].impl = impl;
			if(!manage){
				fds.fd[u].fd = -1;
				fds.fd[u].backend = NULL;
				fds.fd[u].impl = NULL;
				fd_set_dirty = 1;
			}
			return 0;
		}
	}

	if(!manage){
		return 0;
	}

	//find free slot
	for(u = 0; u < fds.n; u++){
		if(fds.fd[u].fd < 0){
			break;
		}
	}
	//if necessary expand
	if(u == fds.n){
		fds.fd = realloc(fds.fd, (fds.n + 1) * sizeof(managed_fd));
		if(!fds.fd){
			free(fds.signaled);
			fds.signaled = NULL;
			fds.n = 0;
			LOG("Failed to allocate memory");
			return 1;
		}

		fds.signaled = realloc(fds.signaled, (fds.n + 1) * sizeof(managed_fd));
		if(!fds.signaled){
			LOG("Failed to allocate memory");
			free(fds.fd);
			fds.fd = NULL;
			fds.n = 0;
			return 1;
		}
		fds.n++;
	}

	//store new fd
	fds.fd[u].fd = new_fd;
	fds.fd[u].backend = b;
	fds.fd[u].impl = impl;
	fd_set_dirty = 1;
	return 0;
}
```


Overlapping Code:
```
MM_API int mm_manage_fd(int new_fd, char* back, int manage, void* impl){
backend* b = backend_match(back);
size_t u;
if(!b){
LOGPF("Unknown backend %s registered for managed fd", back);
return 1;
}
//find exact match
for(u = 0; u < fds.n; u++){
if(fds.fd[u].fd == new_fd && fds.fd[u].backend == b){
fds.fd[u].impl = impl;
if(!manage){
fds.fd[u].fd = -1;
fds.fd[u].backend = NULL;
fds.fd[u].impl = NULL;
fd_set_dirty = 1;
}
return 0;
}
}
if(!manage){
return 0;
}
//find free slot
for(u = 0; u < fds.n; u++){
if(fds.fd[u].fd < 0){
break;
}
}
//if necessary expand
if(u == fds.n){
fds.fd = realloc(fds.fd, (fds.n + 1) * sizeof(managed_fd));
if(!fds.fd){
free(fds.signaled);
fds.signaled = NULL;
fds.n = 0;
LOG("Failed to allocate memory");
return 1;
}
fds.signaled = realloc(fds.signaled, (fds.n + 1) * sizeof(managed_fd));
if(!fds.signaled){
LOG("Failed to allocate memory");
free(fds.fd);
fds.fd = NULL;
fds.n = 0;
return 1;
}
fds.n++;
}
//store new fd
fds.fd[u].fd = new_fd;
fds.fd[u].backend = b;
fds.fd
```
<Overlap Ratio: 0.9561904761904761>

---

--- 315 --
Question ID: a2cb8597de1c93bb53b665642848d99f4788f17c_0
Original Code:
```
namespace sba
{
  /// Let's try templated versions

  template <int N>
    class jacobiBPCG 
    {
    public:
      jacobiBPCG() { residual = 0.0; };
      int doBPCG(int iters, double tol,
                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
                 VectorXd &x,
                 VectorXd &b,
                 bool abstol = false,
                 bool verbose = false
                 );

      // uses internal linear storage for Hessian
      int doBPCG2(int iters, double tol,
                 vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
                 vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
                 VectorXd &x,
                 VectorXd &b,
                 bool abstol = false,
                 bool verbose = false
                 );

      double residual;

    private:
      void mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
               vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
               const VectorXd &vin,
               VectorXd &vout);
 
      // uses internal linear storage
      void mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
                const VectorXd &vin,
                VectorXd &vout);
 
      void mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
              VectorXd &vin,
              VectorXd &vout);

      vector<int> vcind, vrind;
      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > vcols;
    };

  template <int N>
    void jacobiBPCG<N>::mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
                        vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
                        const VectorXd &vin,
                        VectorXd &vout)
    {
    // loop over all entries
      if (cols.size() > 0)
        for (int i=0; i<(int)cols.size(); i++)
          {
            vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering

            map<int,Matrix<double,N,N>, less<int>, 
              aligned_allocator<Matrix<double,N,N> > > &col = cols[i];
            if (col.size() > 0)
              {
                typename map<int,Matrix<double,N,N>, less<int>, // need "typename" here, barf
                  aligned_allocator<Matrix<double,N,N > > >::iterator it;
                for (it = col.begin(); it != col.end(); it++)
                  {
                    int ri = (*it).first; // get row index
                    const Matrix<double,N,N> &M = (*it).second; // matrix
                    vout.segment<N>(i*N)  += M.transpose()*vin.segment<N>(ri*N);
                    vout.segment<N>(ri*N) += M*vin.segment<N>(i*N);
                  }
              }
          }
    }

  //
  // matrix-vector multiply with linear storage
  //

  template <int N>
    void jacobiBPCG<N>::mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
                             const VectorXd &vin,
                             VectorXd &vout)
    {
      // linear storage for matrices
      // loop over off-diag entries
      if (diag.size() > 0)
        for (int i=0; i<(int)diag.size(); i++)
          vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering

      for (int i=0; i<(int)vcind.size(); i++)
        {
          int ri = vrind[i];
          int ii = vcind[i];
          const Matrix<double,N,N> &M = vcols[i];
          vout.segment<N>(ri*N) += M*vin.segment<N>(ii*N);
          vout.segment<N>(ii*N) += M.transpose()*vin.segment<N>(ri*N);
        }
    }




  template <int N>
    void jacobiBPCG<N>::mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
            VectorXd &vin,
            VectorXd &vout)
    {
      // loop over diag entries
      for (int i=0; i<(int)diag.size(); i++)
        vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N);
    }


  template <int N>
    int jacobiBPCG<N>::doBPCG(int iters, double tol,
	    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
	    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
	    VectorXd &x,
	    VectorXd &b,
	    bool abstol,
	    bool verbose)
    {
      // set up local vars
      VectorXd r,d,q,s;
      int n = diag.size();
      int n6 = n*N;
      r.setZero(n6);
      d.setZero(n6);
      q.setZero(n6);
      s.setZero(n6);

      // set up Jacobi preconditioner
      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;
      J.resize(n);
      for (int i=0; i<n; i++)
        J[i] = diag[i].inverse();

      int i;
      r = b;
      mD(J,r,d);
      double dn = r.dot(d);
      double d0 = tol*dn;
      if (abstol)               // change tolerances
        {
          if (residual > d0) d0 = residual;
        }

      for (i=0; i<iters; i++)
        {
          if (verbose && 0)
            cout << "[BPCG] residual[" << i << "]: " << dn << " < " << d0 << endl;
          if (dn < d0) break;	// done
          mMV(diag,cols,d,q);
          double a = dn / d.dot(q);
          x += a*d;
          // TODO: reset residual here every 50 iterations
          r -= a*q;
          mD(J,r,s);
          double dold = dn;
          dn = r.dot(s);
          double ba = dn / dold;
          d = s + ba*d;
        }

  
      if (verbose)
        cout << "[BPCG] residual[" << i << "]: " << dn << endl;
      residual = dn/2.0;
      return i;
    }


  // uses internal linear storage for Hessian
  template <int N>
    int jacobiBPCG<N>::doBPCG2(int iters, double tol,
	    vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
	    vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
	    VectorXd &x,
	    VectorXd &b,
	    bool abstol,
	    bool verbose)
    {
      // set up local vars
      VectorXd r,d,q,s;
      int n = diag.size();
      int n6 = n*N;
      r.setZero(n6);
      d.setZero(n6);
      q.setZero(n6);
      s.setZero(n6);

      vcind.clear();
      vrind.clear();
      vcols.clear();

      // set up alternate rep for sparse matrix
      for (int i=0; i<(int)cols.size(); i++)
        {
          map<int,Matrix<double,N,N>, less<int>, 
            aligned_allocator<Matrix<double,N,N> > > &col = cols[i];
          if (col.size() > 0)
            {
              typename map<int,Matrix<double,N,N>, less<int>, 
                aligned_allocator<Matrix<double,N,N> > >::iterator it;
              for (it = col.begin(); it != col.end(); it++)
                {
                  int ri = (*it).first; // get row index
                  vrind.push_back(ri);
                  vcind.push_back(i);
                  vcols.push_back((*it).second);
                }
            }
        }

      // set up Jacobi preconditioner
      vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > J;
      J.resize(n);
      for (int i=0; i<n; i++)
        J[i] = diag[i].inverse();

      int i;
      r = b;
      mD(J,r,d);
      double dn = r.dot(d);
      double d0 = tol*dn;
      if (abstol)               // change tolerances
        {
          if (residual > d0) d0 = residual;
        }

      for (i=0; i<iters; i++)
        {
          if (verbose && 0)
            cout << "[BPCG] residual[" << i << "]: " << dn << " < " << d0 << endl;
          if (dn < d0) break;	// done
          mMV2(diag,d,q);
          double a = dn / d.dot(q);
          x += a*d;
          // TODO: reset residual here every 50 iterations
          r -= a*q;
          mD(J,r,s);
          double dold = dn;
          dn = r.dot(s);
          double ba = dn / dold;
          d = s + ba*d;
        }

  
      if (verbose)
        cout << "[BPCG] residual[" << i << "]: " << dn << endl;
      residual = dn/2.0;
      return i;
    }


#if 0
//
// matrix multiply of compressed column storage + diagonal blocks by a vector
//

void
mMV(vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,
    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,
    const VectorXd &vin,
    VectorXd &vout);

//
// jacobi-preconditioned block conjugate gradient
// returns number of iterations

int
bpcg_jacobi(int iters, double tol,
	    vector< Matrix<double,6,6>, aligned_allocator<Matrix<double,6,6> > > &diag,
	    vector< map<int,Matrix<double,6,6>, less<int>, aligned_allocator<Matrix<double,6,6> > > > &cols,
	    VectorXd &x,
	    VectorXd &b,
	    bool abstol = false,
	    bool verbose = false
         );

int
bpcg_jacobi_dense(int iters, double tol,
		  MatrixXd &M,
		  VectorXd &x,
		  VectorXd &b);

//
// jacobi-preconditioned block conjugate gradient
// returns number of iterations

int
bpcg_jacobi3(int iters, double tol,
	    vector< Matrix<double,3,3>, aligned_allocator<Matrix<double,3,3> > > &diag,
	    vector< map<int,Matrix<double,3,3>, less<int>, aligned_allocator<Matrix<double,3,3> > > > &cols,
	    VectorXd &x,
	    VectorXd &b,
	    bool abstol = false,
	    bool verbose = false
         );

int
bpcg_jacobi_dense3(int iters, double tol,
		  MatrixXd &M,
		  VectorXd &x,
		  VectorXd &b);

#endif

}
```


Overlapping Code:
```
ersions
template <int N>
class jacobiBPCG 
{
public:
jacobiBPCG() { residual = 0.0; };
int doBPCG(int iters, double tol,
vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
VectorXd &x,
VectorXd &b,
bool abstol = false,
bool verbose = false
);
// uses internal linear storage for Hessian
int doBPCG2(int iters, double tol,
vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
VectorXd &x,
VectorXd &b,
bool abstol = false,
bool verbose = false
);
double residual;
private:
void mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
const VectorXd &vin,
VectorXd &vout);

// uses internal linear storage
void mMV2(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
const VectorXd &vin,
VectorXd &vout);

void mD(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
VectorXd &vin,
VectorXd &vout);
vector<int> vcind, vrind;
vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > vcols;
};
template <int N>
void jacobiBPCG<N>::mMV(vector< Matrix<double,N,N>, aligned_allocator<Matrix<double,N,N> > > &diag,
vector< map<int,Matrix<double,N,N>, less<int>, aligned_allocator<Matrix<double,N,N> > > > &cols,
const VectorXd &vin,
VectorXd &vout)
{
// loop over all entries
if (cols.size() > 0)
for (int i=0; i<(int)cols.size(); i++)
{
vout.segment<N>(i*N) = diag[i]*vin.segment<N>(i*N); // only works with cols ordering
map<int,Matrix<double,N,N>, less<int>, 
aligned_allocator<Matrix<double,N,N> > > &col = cols[i];
if (col.size() 
```
<Overlap Ratio: 0.9762532981530343>

---

--- 316 --
Question ID: 33b0c8d530440318e4514195f5db8ac277f21115_9
Original Code:
```
static
sync_cell_t*
sync_array_find_thread(
/*===================*/
				/* out: pointer to cell or NULL
				if not found */
	sync_array_t*	arr,	/* in: wait array */
	os_thread_id_t	thread)	/* in: thread id */
{
	ulint		i;
	sync_cell_t*	cell;

	for (i = 0; i < arr->n_cells; i++) {

		cell = sync_array_get_nth_cell(arr, i);

		if (cell->wait_object != NULL
		    && os_thread_eq(cell->thread, thread)) {

			return(cell);	/* Found */
		}
	}

	return(NULL);	/* Not found */
}
```


Overlapping Code:
```
ync_cell_t*
sync_array_find_thread(
/*===================*/
/* out: pointer to cell or NULL
if not found */
sync_array_t* arr, /* in: wait array */
os_thread_id_t thread) /* in: thread id */
{
ulint i;
sync_cell_t* cell;
for (i = 0; i < arr->n_cells; i++) {
cell = sync_array_get_nth_cell(arr, i);
if (cell->wait_object != NULL
&& os_thread_eq(cell->thread, thread)) {
return(cell); /* Found */
}
}
return(NULL); /* Not found *
```
<Overlap Ratio: 0.9748858447488584>

---

--- 317 --
Question ID: 172cc980858d45910c99837ea1f8727cf3bd043a_8
Original Code:
```
void xor (char *str1, char *str2) {
  
  unsigned long int i;

  if (strlen(str1) != strlen(str2)) {
    printf("Error: xor operation does not support different string lengths.\n");
    exit(0);
  }

  for (i = 0; i < strlen(str1); i++) {
    if (str1[i] == str2[i]) {
      output[i] = '0';
    }
    else output[i] = '1';
  }
  output[i] = '\0';
}
```


Overlapping Code:
```
or (char *str1, char *str2) {

unsigned long int i;
if (strlen(str1) != strlen(str2)) {
printf("Error: xor operation does not support different string lengths.\n");
exit(0);
}
for (i = 0; i < strlen(str1); i++) {
if (str1[i] == str2[i]) {
output[i] = '0';
}
else output[i] = '1';
}
output[i] = '\0';

```
<Overlap Ratio: 0.9771986970684039>

---

--- 318 --
Question ID: 3ed3d8feaa49dee26144ea253bddf90ca12dc510_1
Original Code:
```
static void print_other_info(const struct exfat_super_block* sb)
{
	printf("First sector              %10"PRIu64"\n",
			le64_to_cpu(sb->sector_start));
	printf("FAT first sector          %10u\n",
			le32_to_cpu(sb->fat_sector_start));
	printf("FAT sectors count         %10u\n",
			le32_to_cpu(sb->fat_sector_count));
	printf("First cluster sector      %10u\n",
			le32_to_cpu(sb->cluster_sector_start));
	printf("Root directory cluster    %10u\n",
			le32_to_cpu(sb->rootdir_cluster));
	printf("Volume state                  0x%04hx\n",
			le16_to_cpu(sb->volume_state));
	printf("FATs count                %10hhu\n",
			sb->fat_count);
	printf("Drive number                    0x%02hhx\n",
			sb->drive_no);
	printf("Allocated space           %9hhu%%\n",
			sb->allocated_percent);
}
```


Overlapping Code:
```
 struct exfat_super_block* sb)
{
printf("First sector %10"PRIu64"\n",
le64_to_cpu(sb->sector_start));
printf("FAT first sector %10u\n",
le32_to_cpu(sb->fat_sector_start));
printf("FAT sectors count %10u\n",
le32_to_cpu(sb->fat_sector_count));
printf("First cluster sector %10u\n",
le32_to_cpu(sb->cluster_sector_start));
printf("Root directory cluster %10u\n",
le32_to_cpu(sb->rootdir_cluster));
printf("Volume state 0x%04hx\n",
le16_to_cpu(sb->volume_state));
printf("FATs count %10hhu\n",
sb->fat_count);
printf("Drive number 0x%02hhx\n",
sb->drive_no);
printf("Allocated space %9hhu%%\n",
sb->allo
```
<Overlap Ratio: 0.9216589861751152>

---

--- 319 --
Question ID: ec741a128f004dbcf676495fce59b2763366e11e_8
Original Code:
```
TEST test_zinterstore() {
	rliteContext *context = rliteConnect(":memory:", 0);

	rliteReply* reply;
	char* argv[100] = {"ZADD", "key1", "1", "one", "2", "two", "3", "three", NULL};
	size_t argvlen[100];

	reply = rliteCommandArgv(context, populateArgvlen(argv, argvlen), argv, argvlen);
	rliteFreeReplyObject(reply);

	char *argv2[100] = {"ZADD", "key2", "1", "one", "2", "two", NULL};
	reply = rliteCommandArgv(context, populateArgvlen(argv2, argvlen), argv2, argvlen);
	rliteFreeReplyObject(reply);

	char *argv3[100] = {"ZINTERSTORE", "out", "2", "key1", "key2", NULL};
	reply = rliteCommandArgv(context, populateArgvlen(argv3, argvlen), argv3, argvlen);
	EXPECT_REPLY_INTEGER(reply, 2);
	rliteFreeReplyObject(reply);

	rliteFree(context);
	PASS();
}
```


Overlapping Code:
```
re() {
rliteContext *context = rliteConnect(":memory:", 0);
rliteReply* reply;
char* argv[100] = {"ZADD", "key1", "1", "one", "2", "two", "3", "three", NULL};
size_t argvlen[100];
reply = rliteCommandArgv(context, populateArgvlen(argv, argvlen), argv, argvlen);
rliteFreeReplyObject(reply);
char *argv2[100] = {"ZADD", "key2", "1", "one", "2", "two", NULL};
reply = rliteCommandArgv(context, populateArgvlen(argv2, argvlen), argv2, argvlen);
rliteFreeReplyObject(reply);
char *argv3[100] = {"ZINTERSTORE", "out", "2", "key1", "key2", NULL};
reply = rliteCommandArgv(context, populateArgvlen(argv3, argvlen), argv3, argvlen);
EXPECT_REPLY_INTEGER(reply, 2);
rliteFreeReplyObject(reply);
rliteFree(context);
PASS();

```
<Overlap Ratio: 0.9727520435967303>

---

--- 320 --
Question ID: af497e52e9312f4a4917ecacad0ed224392e73d0_0
Original Code:
```
void draw_test (int id, ps_context* gc)
{
    ps_color col = {0, 0, 1, 1};
    ps_color sol = {1, 0, 0, 1};
    ps_rect cr = {2.7f , 3.4f, 272.4f, 261.3f};
    ps_point s = {50.1f, 50.3f};
    ps_point e = {200.7f, 50.3f};

    ps_point p[3] = {{100,100},{200, 300},{ 300, 40}};
    ps_point cp = {128, 128};
    ps_point sc = {10, 228};
    ps_rect br = {50, 50, 120, 100};

    ps_set_line_width(gc, 1);
    ps_set_stroke_color(gc, &sol);

//    ps_set_line_dash(gc, dashs[0].s, dashs[0].d, 4);
    ps_set_source_color(gc, &col);
    ps_arc (gc, &cp, 10 , 0, 6.28f, True);
    ps_stroke(gc);

//    ps_set_line_dash(gc, dashs[1].s, dashs[1].d, 4);
    ps_tangent_arc(gc, &br, 0, 1.254f);
    ps_stroke(gc);
    ps_move_to(gc, &sc);
    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);

    ps_arc (gc, &cp, 100 , 0.785f, 3.140f, False);
    
    ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);
    
//    ps_set_line_dash(gc, dashs[2].s, dashs[2].d, 4);
    ps_quad_curve_to(gc, &p[1], &p[2]);
    ps_stroke(gc);

//    ps_set_line_dash(gc, dashs[3].s, dashs[3].d, 4);
    ps_rectangle(gc, &cr);
    ps_rounded_rect(gc, &gt, 45.2f, 35.2f, 25.2f, 25.2f, 35.2f, 55.2f, 65.2f, 85.2f);
    ps_ellipse(gc, &gr);
    ps_stroke(gc);

//    ps_reset_line_dash(gc);
    ps_move_to(gc, &s);
    ps_line_to(gc, &e);
    ps_stroke(gc);
}
```


Overlapping Code:
```
t* gc)
{
ps_color col = {0, 0, 1, 1};
ps_color sol = {1, 0, 0, 1};
ps_rect cr = {2.7f , 3.4f, 272.4f, 261.3f};
ps_point s = {50.1f, 50.3f};
ps_point e = {200.7f, 50.3f};
ps_point p[3] = {{100,100},{200, 300},{ 300, 40}};
ps_point cp = {128, 128};
ps_point sc = {10, 228};
ps_rect br = {50, 50, 120, 100};
ps_set_line_width(gc, 1);
ps_set_stroke_color(gc, &sol);
// ps_set_line_dash(gc, dashs[0].s, dashs[0].d, 4);
ps_set_source_color(gc, &col);
ps_arc (gc, &cp, 10 , 0, 6.28f, True);
ps_stroke(gc);
// ps_set_line_dash(gc, dashs[1].s, dashs[1].d, 4);
ps_tangent_arc(gc, &br, 0, 1.254f);
ps_stroke(gc);
ps_move_to(gc, &sc);
ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);
ps_arc (gc, &cp, 100 , 0.785f, 3.140f, False);

ps_bezier_curve_to(gc, &p[0], &p[1], &p[2]);

// ps_set_line_dash(gc, dashs[2].s, dashs[2].d, 4);
ps_quad_curve_to(gc, &p[1], &p[2]);
ps_stroke(gc);
// ps_set_line_dash(gc, dashs[3].s, dashs[3].d, 4);
ps_rectangle(gc, &cr);
ps_rounded_rect(gc, &gt, 45.2f, 35.2f, 25.2f, 25.2f, 35.2f, 55.2f, 65.2f, 85.2f);
ps_ellipse(gc, &gr);
ps_stroke(gc);
// ps_reset_line_dash(gc);
ps_move_to(gc, 
```
<Overlap Ratio: 0.9369676320272572>

---

--- 321 --
Question ID: 2472b3a28a4d65f1aec7de94421a072dba2c9025_4
Original Code:
```
sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
	sljit_s32 arg_types)
{
	struct sljit_jump *jump;
	sljit_ins ins = NOP;

	CHECK_ERROR_PTR();
	CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));

	jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
	PTR_FAIL_IF(!jump);
	set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);

	if (type & SLJIT_CALL_RETURN)
		PTR_FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));

	PTR_FAIL_IF(call_with_args(compiler, arg_types, &ins));

	SLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);

	if (!(type & SLJIT_CALL_RETURN)) {
		jump->flags |= IS_JAL | IS_CALL;
		PTR_FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));
	} else
		PTR_FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));

	jump->addr = compiler->size;
	PTR_FAIL_IF(push_inst(compiler, ins, UNMOVABLE_INS));

	/* Maximum number of instructions required for generating a constant. */
	compiler->size += 6;
	return jump;
}
```


Overlapping Code:
```
sljit_jump* sljit_emit_call(struct sljit_compiler *compiler, sljit_s32 type,
sljit_s32 arg_types)
{
struct sljit_jump *jump;
sljit_ins ins = NOP;
CHECK_ERROR_PTR();
CHECK_PTR(check_sljit_emit_call(compiler, type, arg_types));
jump = (struct sljit_jump*)ensure_abuf(compiler, sizeof(struct sljit_jump));
PTR_FAIL_IF(!jump);
set_jump(jump, compiler, type & SLJIT_REWRITABLE_JUMP);
if (type & SLJIT_CALL_RETURN)
PTR_FAIL_IF(emit_stack_frame_release(compiler, 0, &ins));
PTR_FAIL_IF(call_with_args(compiler, arg_types, &ins));
SLJIT_ASSERT(DR(PIC_ADDR_REG) == 25 && PIC_ADDR_REG == TMP_REG2);
if (!(type & SLJIT_CALL_RETURN)) {
jump->flags |= IS_JAL | IS_CALL;
PTR_FAIL_IF(push_inst(compiler, JALR | S(PIC_ADDR_REG) | DA(RETURN_ADDR_REG), UNMOVABLE_INS));
} else
PTR_FAIL_IF(push_inst(compiler, JR | S(PIC_ADDR_REG), UNMOVABLE_INS));
jump->addr = compiler->size;
PTR_FAIL_IF(push_inst(compiler, ins, UNMOVABLE_INS));
/* Maximum number of instructions required for generating a constant. */
compiler->size += 6;
ret
```
<Overlap Ratio: 0.9892262487757101>

---

--- 322 --
Question ID: 9efe2897e0d5cacb3908d65938f5a07c61c992f9_14
Original Code:
```
static BOOL fastpath_recv_input_event_scancode(rdpFastPath* fastpath, wStream* s, BYTE eventFlags)
{
	UINT16 flags;
	UINT16 code;

	if (Stream_GetRemainingLength(s) < 1)
		return FALSE;

	Stream_Read_UINT8(s, code); /* keyCode (1 byte) */

	flags = 0;

	if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_RELEASE))
		flags |= KBD_FLAGS_RELEASE;
	else
		flags |= KBD_FLAGS_DOWN;

	if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_EXTENDED))
		flags |= KBD_FLAGS_EXTENDED;

	IFCALL(fastpath->rdp->input->KeyboardEvent, fastpath->rdp->input, flags, code);

	return TRUE;
}
```


Overlapping Code:
```
tic BOOL fastpath_recv_input_event_scancode(rdpFastPath* fastpath, wStream* s, BYTE eventFlags)
{
UINT16 flags;
UINT16 code;
if (Stream_GetRemainingLength(s) < 1)
return FALSE;
Stream_Read_UINT8(s, code); /* keyCode (1 byte) */
flags = 0;
if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_RELEASE))
flags |= KBD_FLAGS_RELEASE;
else
flags |= KBD_FLAGS_DOWN;
if ((eventFlags & FASTPATH_INPUT_KBDFLAGS_EXTENDED))
flags |= KBD_FLAGS_EXTENDED;
IFCALL(fastpath->rdp->input->KeyboardEvent, fastpath->rdp->input, flags, code);
return TRU
```
<Overlap Ratio: 0.9867424242424242>

---

--- 323 --
Question ID: 48e848931811ca7acb55a0fa8e086dc14fb2c89d_3
Original Code:
```
ACPI_STATUS
AcpiOsEnterSleep(
    UINT8                   SleepState,
    UINT32                  RegaValue,
    UINT32                  RegbValue)
{
   ACPI_FUNCTION_TRACE(__FUNC__);
   printk("ACPI sleep: %u, 0x%x, 0x%x\n", SleepState, RegaValue, RegaValue);
   return_ACPI_STATUS(AE_OK);
}
```


Overlapping Code:
```
terSleep(
UINT8 SleepState,
UINT32 RegaValue,
UINT32 RegbValue)
{
ACPI_FUNCTION_TRACE(__FUNC__);
printk("ACPI sleep: %u, 0x%x, 0x%x\n", SleepState, RegaV
```
<Overlap Ratio: 0.6986301369863014>

---

--- 324 --
Question ID: 35c1ebf88bec10504cd8fc974da690c3e75f5e4c_6
Original Code:
```
off_t VFS_Truncate(int FD, off_t Size)
{
	tVFS_Handle	*h = VFS_GetHandle(FD);
	if(!h) {
		errno = EBADF;
		return -1;
	}
	
	if( !h->Node->Type->Truncate)
	{
		Log_Notice("VFS", "Nodetype '%s' doesn't have a Truncate method", h->Node->Type->TypeName);
		errno = ENOTIMPL;
		return -1;	
	}
	
	return h->Node->Type->Truncate(h->Node, Size);
}
```


Overlapping Code:
```
(int FD, off_t Size)
{
tVFS_Handle *h = VFS_GetHandle(FD);
if(!h) {
errno = EBADF;
return -1;
}

if( !h->Node->Type->Truncate)
{
Log_Notice("VFS", "Nodetype '%s' doesn't have a Truncate method", h->Node->Type->TypeName);
errno = ENOTIMPL;
return -1; 
}

return h->Node->Type->Truncate(h->Node, Size);
```
<Overlap Ratio: 0.9375>

---

--- 325 --
Question ID: ad46be12731eced24db8f0e5d9e4f32f9bc9b16f_6
Original Code:
```
static inline void RENAME(rgb24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
{
	int i;
        assert(src1==src2);
	for(i=0; i<width; i++)
	{
		int r= src1[6*i + 0] + src1[6*i + 3];
		int g= src1[6*i + 1] + src1[6*i + 4];
		int b= src1[6*i + 2] + src1[6*i + 5];

		dstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;
		dstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SHIFT+1)) + 128;
	}
}
```


Overlapping Code:
```
atic inline void RENAME(rgb24ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)
{
int i;
assert(src1==src2);
for(i=0; i<width; i++)
{
int r= src1[6*i + 0] + src1[6*i + 3];
int g= src1[6*i + 1] + src1[6*i + 4];
int b= src1[6*i + 2] + src1[6*i + 5];
dstU[i]= ((RU*r + GU*g + BU*b)>>(RGB2YUV_SHIFT+1)) + 128;
dstV[i]= ((RV*r + GV*g + BV*b)>>(RGB2YUV_SH
```
<Overlap Ratio: 0.9493670886075949>

---

--- 326 --
Question ID: 8daa935f7dc29f9d3ff5901755a2a9f1d94511af_2
Original Code:
```
static cairo_test_status_t
draw_clip (cairo_t *cr, int width, int height)
{
    cairo_surface_t *surface;

    surface = cairo_image_surface_create_for_data ((unsigned char *) data,
						   CAIRO_FORMAT_RGB24, 4, 4, 16);

    cairo_test_paint_checkered (cr);

    cairo_rectangle (cr, 10.5, 10.5, 11, 11);
    cairo_clip (cr);

    cairo_scale (cr, 4, 4);

    cairo_set_source_surface (cr, surface, 2 , 2);
    cairo_pattern_set_filter (cairo_get_source (cr), CAIRO_FILTER_NEAREST);
    cairo_paint_with_alpha (cr, 0.5);

    cairo_surface_finish (surface); /* data will go out of scope */
    cairo_surface_destroy (surface);

    return CAIRO_TEST_SUCCESS;
}
```


Overlapping Code:
```
cairo_t *cr, int width, int height)
{
cairo_surface_t *surface;
surface = cairo_image_surface_create_for_data ((unsigned char *) data,
CAIRO_FORMAT_RGB24, 4, 4, 16);
cairo_test_paint_checkered (cr);
cairo_rectangle (cr, 10.5, 10.5, 11, 11);
cairo_clip (cr);
cairo_scale (cr, 4, 4);
cairo_set_source_surface (cr, surface, 2 , 2);
cairo_pattern_set_filter (cairo_get_source (cr), CAIRO_FILTER_NEAREST);
cairo_paint_with_alpha (cr, 0.5);
cairo_surface_finish (surface); /* data will go out of scope */
cairo_surface_destroy (surface);
return CAIRO_TEST_SUCCESS
```
<Overlap Ratio: 0.931438127090301>

---

--- 327 --
Question ID: 5c510267237f6c02f5175550e6f236ecb66f42bd_0
Original Code:
```
class Branches {
public:
	Branches(void) { }
	~Branches(void) { }
	const Branch *operator[](const std::string &ID) const;
	Branch *operator[](const std::string &ID);
	const Branch *get_by_name(const std::string &Name) const;
	Branch *get_by_name(const std::string &Name);
	int AddBranch(Branch *);
protected:
	std::map<std::string,Branch *> ID_to_Branch;
}
```


Overlapping Code:
```
ranches {
public:
Branches(void) { }
~Branches(void) { }
const Branch *operator[](const std::string &ID) const;
Branch *operator[](const std::string &ID);
const Branch *get_by_name(const std::string &Name) const;
Branch *get_by_name(const std::string &Name);
int AddBranch(Branch *);
protected:
std::
```
<Overlap Ratio: 0.8620689655172413>

---

--- 328 --
Question ID: 43f623d6a7570dd05d968e7c9f12fa191b1b1d9d_91
Original Code:
```
static srpl_state_t
srpl_send_candidates_response_send_action(srpl_connection_t *srpl_connection, srpl_event_t *event)
{
    REQUIRE_SRPL_EVENT_NULL(srpl_connection, event);
    REQUIRE_SRPL_INSTANCE(srpl_connection);
    STATE_ANNOUNCE_NO_EVENTS(srpl_connection);

    srpl_send_candidates_message_send(srpl_connection, true);
    // When the server has sent its candidate response, it's immediately ready to send a "send candidate" message
    // When the client has sent its candidate response, the database synchronization is done on the client.
    if (srpl_connection->is_server) {
        return srpl_state_send_candidates_send;
    } else {
        srpl_connection->database_synchronized = true;
        return srpl_state_ready;
    }
}
```


Overlapping Code:
```
l_send_candidates_response_send_action(srpl_connection_t *srpl_connection, srpl_event_t *event)
{
REQUIRE_SRPL_EVENT_NULL(srpl_connection, event);
REQUIRE_SRPL_INSTANCE(srpl_connection);
STATE_ANNOUNCE_NO_EVENTS(srpl_connection);
srpl_send_candidates_message_send(srpl_connection, true);
// When the server has sent its candidate response, it's immediately ready to send a "send candidate" message
// When the client has sent its candidate response, the database synchronization is done on the client.
if (srpl_connection->is_server) {
return srpl_state_send_candidates_send;
} else {
srpl_connection->database_synchronized = true;
return srpl_state_
```
<Overlap Ratio: 0.9516837481698389>

---

--- 329 --
Question ID: a64a89a0719c5f7c1e9a37a1e50a63d99054ae16_0
Original Code:
```
class MT_Vector3
{
public:
    explicit MT_Vector3() {}
    template <typename T>
    explicit MT_Vector3(const T *v) { setValue(v); }
```


Overlapping Code:
```
r3() {}
template <typename T>
explicit MT_Vector3(
```
<Overlap Ratio: 0.4098360655737705>

---

--- 330 --
Question ID: 0efa7dc6ffc67bb4ee0b8477bc744231299631b5_0
Original Code:
```
BOOL	EdBBar_Init (void)
{
    char	myButtonBarWindowClassName [256];
    char	myRaisedFrameWindowClassName [256];
    int		myResult;
    WNDCLASSEX	myWindowClass, myRaisedFrameClass;

    // Get the background brush
    stBackgroundBrush = GetSysColorBrush (COLOR_BTNFACE);
    if (stBackgroundBrush == NULL)	  
    {
    	EdFail_Warn (IDS_CREATEBRUSHFAIL, __FILE__, __LINE__, GetLastError ());
    	return FALSE;
    }

    stButtonFont = (HFONT) GetStockObject (DEFAULT_GUI_FONT);

    // Get the class name
    EdGUI_LoadString (IDS_BBAR_WINDOW_NAME, myButtonBarWindowClassName, 
	sizeof (myButtonBarWindowClassName));
		     
    //
    // Register the status window class
    //
    myWindowClass.cbSize = 	  sizeof (myWindowClass);
    // Set window class to redraw when window size changes
    myWindowClass.style = 	  CS_HREDRAW | CS_VREDRAW;
    // Procedure to be called with messages for this window class
    myWindowClass.lpfnWndProc =   MyButtonBarWindowProcedure;
    // The extra space in class struct
    myWindowClass.cbClsExtra = 	  0;
    // The extra space in window struct for the pointer to text data
    // and editor window
    myWindowClass.cbWndExtra = 	  WINDOW_EXTRA_MEMORY;
    // The application's handle
    myWindowClass.hInstance = 	  gProgram.applicationInstance;
    // Set the icon for this window class
    myWindowClass.hIcon = 	  NULL;
    // Set the cursor for this window class
    myWindowClass.hCursor = 	  LoadCursor (NULL, IDC_ARROW);
    // Set the background colour for this window
    myWindowClass.hbrBackground = stBackgroundBrush;
    // Set the menu for this window class
    myWindowClass.lpszMenuName =  NULL;
    // Name of the window class
    myWindowClass.lpszClassName = myButtonBarWindowClassName; 
    // Set the icon for this class.
    myWindowClass.hIconSm = 	  NULL;
    
    myResult = RegisterClassEx (&myWindowClass);
    if (myResult == 0)
    {
    	EdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, 
    			  GetLastError ());
    	return FALSE;
    }
    
    // Get the class name
    EdGUI_LoadString (IDS_RAISED_FRAME_WINDOW_NAME, myRaisedFrameWindowClassName, 
	sizeof (myRaisedFrameWindowClassName));
		     
    /************************************/
    /* Register the raised window class */
    /************************************/
    myRaisedFrameClass.cbSize =        sizeof (myRaisedFrameClass);
    // Set window class to redraw when window size changes
    myRaisedFrameClass.style =	       CS_HREDRAW | CS_VREDRAW;
    // Procedure to be called with messages for this window class
    myRaisedFrameClass.lpfnWndProc =   MyRaisedFrameWindowProcedure;
    // The extra space in class struct
    myRaisedFrameClass.cbClsExtra =    0;
    // The extra space in window struct
    myRaisedFrameClass.cbWndExtra =    0;
    // The application's handle
    myRaisedFrameClass.hInstance =     gProgram.applicationInstance;
    // Set the icon for this window class
    myRaisedFrameClass.hIcon =	       NULL;
    // Set the cursor for this window class
    myRaisedFrameClass.hCursor =       LoadCursor (NULL, IDC_ARROW);
    // Set the background colour for this window
    myRaisedFrameClass.hbrBackground = stBackgroundBrush;
    // Set the menu for this window class
    myRaisedFrameClass.lpszMenuName =  NULL;
    // Name of the window class
    myRaisedFrameClass.lpszClassName = myRaisedFrameWindowClassName; 
    // Set the icon for this class.
    myRaisedFrameClass.hIconSm =       NULL;
    
    myResult = RegisterClassEx (&myRaisedFrameClass);
    if (myResult == 0)
    {
    	EdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, 
    			  GetLastError ());
    	return FALSE;
    }

    // Load the resource containing all the button positions    
    if (!EdGUI_LoadResource (NULL, TOP_BUTTON_DATA, &stButtonBarData, 
    			     sizeof (ButtonBarData)))
    {
    	return FALSE;
    }    			     
    return TRUE;
}
```


Overlapping Code:
```
_Init (void)
{
char myButtonBarWindowClassName [256];
char myRaisedFrameWindowClassName [256];
int myResult;
WNDCLASSEX myWindowClass, myRaisedFrameClass;
// Get the background brush
stBackgroundBrush = GetSysColorBrush (COLOR_BTNFACE);
if (stBackgroundBrush == NULL) 
{
EdFail_Warn (IDS_CREATEBRUSHFAIL, __FILE__, __LINE__, GetLastError ());
return FALSE;
}
stButtonFont = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
// Get the class name
EdGUI_LoadString (IDS_BBAR_WINDOW_NAME, myButtonBarWindowClassName, 
sizeof (myButtonBarWindowClassName));

//
// Register the status window class
//
myWindowClass.cbSize = sizeof (myWindowClass);
// Set window class to redraw when window size changes
myWindowClass.style = CS_HREDRAW | CS_VREDRAW;
// Procedure to be called with messages for this window class
myWindowClass.lpfnWndProc = MyButtonBarWindowProcedure;
// The extra space in class struct
myWindowClass.cbClsExtra = 0;
// The extra space in window struct for the pointer to text data
// and editor window
myWindowClass.cbWndExtra = WINDOW_EXTRA_MEMORY;
// The application's handle
myWindowClass.hInstance = gProgram.applicationInstance;
// Set the icon for this window class
myWindowClass.hIcon = NULL;
// Set the cursor for this window class
myWindowClass.hCursor = LoadCursor (NULL, IDC_ARROW);
// Set the background colour for this window
myWindowClass.hbrBackground = stBackgroundBrush;
// Set the menu for this window class
myWindowClass.lpszMenuName = NULL;
// Name of the window class
myWindowClass.lpszClassName = myButtonBarWindowClassName; 
// Set the icon for this class.
myWindowClass.hIconSm = NULL;

myResult = RegisterClassEx (&myWindowClass);
if (myResult == 0)
{
EdFail_Warn (IDS_REGISTERCLASSFAIL, __FILE__, __LINE__, 
GetLastError ());
return FALSE;
}

// Get the class name
EdGUI_LoadString (IDS_RAISED_FRAME_WINDOW_NAME, myRaisedFrameWindowClassName, 
sizeof (myRaisedFrameWindowClassName));

/************************************/
/* Register the raised window class */
/************************************/
myRaisedFrameClass.cbSize = sizeof (myRaisedFrameClass);
// Set window cl
```
<Overlap Ratio: 0.9836524988323213>

---

--- 331 --
Question ID: 2c8f2f259ff44d18eee9a8c38868283d25b47adf_1
Original Code:
```
int main(int argc, char*argv[]) {
    srand( time(NULL) );

    // options
    float phase_offset = M_PI / 4.0f;   // phase offset
    float frequency_offset = 0.3f;      // frequency offset
    float pll_bandwidth = 0.01f;        // PLL bandwidth
    float zeta = 1/sqrtf(2.0f);         // PLL damping factor
    float K = 1000.0f;                  // PLL loop gain
    unsigned int n=512;                 // number of iterations

    int dopt;
    while ((dopt = getopt(argc,argv,"uhb:z:K:n:p:f:")) != EOF) {
        switch (dopt) {
        case 'u':
        case 'h':   usage();    return 0;
        case 'b':   pll_bandwidth = atof(optarg);   break;
        case 'z':   zeta = atof(optarg);            break;
        case 'K':   K = atof(optarg);               break;
        case 'n':   n = atoi(optarg);               break;
        case 'p':   phase_offset = atof(optarg);    break;
        case 'f':   frequency_offset= atof(optarg); break;
        default:
            exit(1);
        }
    }
    unsigned int d=n/32;      // print every "d" lines

    // validate input
    if (pll_bandwidth <= 0.0f) {
        fprintf(stderr,"error: bandwidth must be greater than 0\n");
        exit(1);
    } else if (zeta <= 0.0f) {
        fprintf(stderr,"error: damping factor must be greater than 0\n");
        exit(1);
    } else if (K <= 0.0f) {
        fprintf(stderr,"error: loop gain must be greater than 0\n");
        exit(1);
    }

    // data arrays
    float complex x[n];         // input complex sinusoid
    float complex y[n];         // output complex sinusoid
    float phase_error[n];       // output phase error

    // generate PLL filter
    float b[3];
    float a[3];
    iirdes_pll_active_lag(pll_bandwidth, zeta, K, b, a);
    iirfilt_rrrf pll = iirfilt_rrrf_create(b,3,a,3);
    iirfilt_rrrf_print(pll);

    unsigned int i;
    float phi;
    for (i=0; i<n; i++) {
        phi = phase_offset + i*frequency_offset;
        x[i] = cexpf(_Complex_I*phi);
    }

    // run loop
    float theta = 0.0f;
    y[0] = 1.0f;
    for (i=0; i<n; i++) {

        // generate complex sinusoid
        y[i] = cexpf(_Complex_I*theta);

        // compute phase error
        phase_error[i] = cargf(x[i]*conjf(y[i]));

        // update pll
        iirfilt_rrrf_execute(pll, phase_error[i], &theta);

        // print phase error
        if ((i)%d == 0 || i==n-1 || i==0)
            printf("%4u : phase error = %12.8f\n", i, phase_error[i]);
    }

    // destroy filter object
    iirfilt_rrrf_destroy(pll);

    // write output file
    FILE * fid = fopen(OUTPUT_FILENAME,"w");
    fprintf(fid,"%% %s : auto-generated file\n", OUTPUT_FILENAME);
    fprintf(fid,"clear all;\n");
    fprintf(fid,"close all;\n");
    fprintf(fid,"n = %u;\n", n);
    fprintf(fid,"x = zeros(1,n);\n");
    fprintf(fid,"y = zeros(1,n);\n");
    for (i=0; i<n; i++) {
        fprintf(fid,"x(%4u) = %12.4e + j*%12.4e;\n", i+1, crealf(x[i]), cimagf(x[i]));
        fprintf(fid,"y(%4u) = %12.4e + j*%12.4e;\n", i+1, crealf(y[i]), cimagf(y[i]));
        fprintf(fid,"e(%4u) = %12.4e;\n", i+1, phase_error[i]);
    }
    fprintf(fid,"t=0:(n-1);\n");
    fprintf(fid,"figure;\n");
    fprintf(fid,"subplot(2,1,1);\n");
    fprintf(fid,"  plot(t,real(x),t,real(y));\n");
    fprintf(fid,"  xlabel('time');\n");
    fprintf(fid,"  ylabel('real');\n");
    fprintf(fid,"subplot(2,1,2);\n");
    fprintf(fid,"  plot(t,imag(x),t,imag(y));\n");
    fprintf(fid,"  xlabel('time');\n");
    fprintf(fid,"  ylabel('imag');\n");

    fprintf(fid,"figure;\n");
    fprintf(fid,"plot(t,e);\n");
    fprintf(fid,"xlabel('time');\n");
    fprintf(fid,"ylabel('phase error');\n");
    fprintf(fid,"grid on;\n");

    fclose(fid);
    printf("results written to %s.\n",OUTPUT_FILENAME);

    printf("done.\n");
    return 0;
}
```


Overlapping Code:
```
in(int argc, char*argv[]) {
srand( time(NULL) );
// options
float phase_offset = M_PI / 4.0f; // phase offset
float frequency_offset = 0.3f; // frequency offset
float pll_bandwidth = 0.01f; // PLL bandwidth
float zeta = 1/sqrtf(2.0f); // PLL damping factor
float K = 1000.0f; // PLL loop gain
unsigned int n=512; // number of iterations
int dopt;
while ((dopt = getopt(argc,argv,"uhb:z:K:n:p:f:")) != EOF) {
switch (dopt) {
case 'u':
case 'h': usage(); return 0;
case 'b': pll_bandwidth = atof(optarg); break;
case 'z': zeta = atof(optarg); break;
case 'K': K = atof(optarg); break;
case 'n': n = atoi(optarg); break;
case 'p': phase_offset = atof(optarg); break;
case 'f': frequency_offset= atof(optarg); break;
default:
exit(1);
}
}
unsigned int d=n/32; // print every "d" lines
// validate input
if (pll_bandwidth <= 0.0f) {
fprintf(stderr,"error: bandwidth must be greater than 0\n");
exit(1);
} else if (zeta <= 0.0f) {
fprintf(stderr,"error: damping factor must be greater than 0\n");
exit(1);
} else if (K <= 0.0f) {
fprintf(stderr,"error: loop gain must be greater than 0\n");
exit(1);
}
// data arrays
float complex x[n]; // input complex sinusoid
float complex y[n]; // output complex sinusoid
float phase_error[n]; // output phase error
// generate PLL filter
float b[3];
float a[3];
iirdes_pll_active_lag(pll_bandwidth, zeta, K, b, a);
iirfilt_rrrf pll = iirfilt_rrrf_create(b,3,a,3);
iirfilt_rrrf_print(pll);
unsigned int i;
float phi;
for (i=0; i<n; i++) {
phi = phase_offset + i*frequency_offset;
x[i] = cexpf(_Complex_I*phi);
}
// run loop
float theta = 0.0f;
y[0] = 1.0f;
for (i=0; i<n; i++) {
// generate complex sinusoid
y[i] = cexpf(_Complex_I*theta);
// compute phase error
phase_error[i] = cargf(x[i]*conjf(y[i]));
// update pll
iirfilt_rrrf_execute(pll, phase_error[i], &theta);
// print phase error
if ((i)%d == 0 || i==n-1 || i==0)
printf("%4u : phase error = %12.8f\n", i, phase_error[i]);
}
// destroy filter object

```
<Overlap Ratio: 0.9953893442622951>

---

--- 332 --
Question ID: 50f9220017eb2fbe308508f766a1f98da5c7c8c0_18
Original Code:
```
static int
ActivateOper(graphPtr, interp, argc, argv)
    Graph *graphPtr;		/* Graph widget */
    Tcl_Interp *interp;		/* Interpreter to report errors to */
    int argc;			/* Number of element names */
    char **argv;		/* List of element names */
{
    Element *elemPtr;
    register int i;
    int *activeArr;
    int numActiveIndices;

    if (Blt_GetElement(graphPtr, argv[3], &elemPtr) != TCL_OK) {
	return TCL_ERROR;	/* Can't find named element */
    }
    elemPtr->flags |= ELEM_ACTIVE;

    activeArr = NULL;
    numActiveIndices = -1;
    if (argc > 4) {
	register int *activePtr;

	numActiveIndices = argc - 4;
	activeArr = (int *)ckalloc(sizeof(int) * numActiveIndices);
	if (activeArr == NULL) {
	    Panic("can't allocate active element index array");
	}
	activePtr = activeArr;
	for (i = 4; i < argc; i++) {
	    if (GetIndex(interp, elemPtr, argv[i], activePtr) != TCL_OK) {
		return TCL_ERROR;
	    }
	    activePtr++;
	}
    }
    if (elemPtr->activeIndexArr != NULL) {
	ckfree((char *)elemPtr->activeIndexArr);
    }
    elemPtr->numActiveIndices = numActiveIndices;
    elemPtr->activeIndexArr = activeArr;
    Blt_RedrawGraph(graphPtr);
    return TCL_OK;
}
```


Overlapping Code:
```
Oper(graphPtr, interp, argc, argv)
Graph *graphPtr; /* Graph widget */
Tcl_Interp *interp; /* Interpreter to report errors to */
int argc; /* Number of element names */
char **argv; /* List of element names */
{
Element *elemPtr;
register int i;
int *activeArr;
int numActiveIndices;
if (Blt_GetElement(graphPtr, argv[3], &elemPtr) != TCL_OK) {
return TCL_ERROR; /* Can't find named element */
}
elemPtr->flags |= ELEM_ACTIVE;
activeArr = NULL;
numActiveIndices = -1;
if (argc > 4) {
register int *activePtr;
numActiveIndices = argc - 4;
activeArr = (int *)ckalloc(sizeof(int) * numActiveIndices);
if (activeArr == NULL) {
Panic("can't allocate active element index array");
}
activePtr = activeArr;
for (i = 4; i < argc; i++) {
if (GetIndex(interp, elemPtr, argv[i], activePtr) != TCL_OK) {
return TCL_ERROR;
}
activePtr++;
}
}
if (elemPtr->activeIndexArr != NULL) {
ckfree((char *)elemPtr->activeIndexArr);
}
elemPtr->numActiveIndices = numActiveIndices;
elemPtr->activeIndexArr = activeArr;
Blt_RedrawGraph
```
<Overlap Ratio: 0.9554924242424242>

---

--- 333 --
Question ID: 5cdea3f1e7afc2095e4923f26ed0e83e098260e7_1
Original Code:
```
void InitialTimer(void)
{
    /*�ر�ʱ��*/
    TR0  = OFF;
	TR1  = OFF;
	
    /*T0 T1 ģʽ����*/
    TMOD = 0x11;              //��ʱ��0��ʽ1��16λ���� ,��ʱ��1 ��ʽ1 16������ʽ
	SetTimer0(_us(560));
	SetTimer1(_ms(5));
    SetTimer3(0);
	SetTimer4(0);

	/*T0 T1�жϿ���*/
    ET0  = OFF;           //TO�ж�����
    ET1  = ON;		     //T1�ж�����

	/*��ʱ��/��������������*/ 
    TR0  = OFF;
	TR1  = ON;
}
```


Overlapping Code:
```
 InitialTimer(void)
{
/*�ر�ʱ��*/
TR0 = OFF;
TR1 = OFF;

/*T0 T1 ģʽ����*/
TMOD = 0x11; //��ʱ��0��ʽ1��16λ���� ,��ʱ��1 ��ʽ1 16������ʽ
SetTimer0(_us(560));
SetTimer1(_ms(5));
SetTimer3(0);
SetTimer4(0);
/*T0 T1�жϿ���*/
ET0 = OFF; //TO�ж�����
ET1 = ON; //T1�ж�����
/*��ʱ��/��������������*/ 
TR0 = OFF;
TR1
```
<Overlap Ratio: 0.9615384615384616>

---

--- 334 --
Question ID: 35aa95b5e0fa351da62b57a02765d0b91be24050_1
Original Code:
```
CVoid SetVector( CVec4f vec ) { m_vector.x = vec.x; m_vector.y = vec.y; m_vector.z = vec.z; m_vector.w = vec.w; }
```


Overlapping Code:
```
4f vec ) { m_vector.x = vec.x; m_vector.y = vec.y;
```
<Overlap Ratio: 0.4424778761061947>

---

--- 335 --
Question ID: c32cfa22c53cd688da78cf38b800dd4dcad143e1_73
Original Code:
```
void GameOver_Draw(void)
{
	Playing_Draw();

	Color edgeColor = ColorAlpha(BLACK, 0.9f);
	Color centerColor = ColorAlpha(BLACK, 0.1f);
	DrawRectangleGradientV(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2, edgeColor, centerColor);
	DrawRectangleGradientV(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2, centerColor, edgeColor);
	
	//DrawRectangleVCentered(screenCenter, Vec2(300, 100), BLACK);
	//DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y - 20, 40, RED);

	DrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(400, 340), GRAY);
	DrawCircleV(screenCenter, 200, GRAY);
	DrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(380, 320), DARKGRAY);
	DrawCircleV(screenCenter, 190, DARKGRAY);

	DrawTextCentered("Magus Maximillius", screenCenter.x, screenCenter.y - 40, 40, GRAY);

	const char *suffix = "";
	bool isTeen = deathCount > 10 && deathCount <= 20;
	if (isTeen)
		suffix = "th";
	else
	{
		switch (deathCount % 10)
		{
			case 0: suffix = "th"; break;
			case 1: suffix = "st"; break;
			case 2: suffix = "nd"; break;
			case 3: suffix = "rd"; break;
			case 4:
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				suffix = "th"; break;
		}
	}

	char text[256];
	snprintf(text, sizeof text, "The %d%s", deathCount, suffix);
	DrawTextCentered(text, screenCenter.x, screenCenter.y + 10, 40, GRAY);

	DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y + 100, 40, RED);
	DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y + 102, 40, RED);

	Rectangle rR = Rect(360, 660, 40, 40);
	Vector2 cR = RectangleCenter(rR);
	if (inputMode == INPUT_MODE_KEYBOARD_AND_MOUSE)
	{
		DrawRectangleLinesEx(rR, 4, GRAY);
		DrawTextCentered("R", cR.x, cR.y, 28, GRAY);
	}
	else if (inputMode == INPUT_MODE_CONTROLLER)
	{
		DrawRing(cR, 24, 28, 0, 360, 64, Grayscale(0.2f));
		DrawRing(cR, 20, 24, 0, 360, 64, GRAY);
		DrawTextCentered("Y", cR.x, cR.y, 32, GRAY);
	}
	DrawText("Restart", 420, 665, 28, GRAY);
}
```


Overlapping Code:
```
oid)
{
Playing_Draw();
Color edgeColor = ColorAlpha(BLACK, 0.9f);
Color centerColor = ColorAlpha(BLACK, 0.1f);
DrawRectangleGradientV(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2, edgeColor, centerColor);
DrawRectangleGradientV(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2, centerColor, edgeColor);

//DrawRectangleVCentered(screenCenter, Vec2(300, 100), BLACK);
//DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y - 20, 40, RED);
DrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(400, 340), GRAY);
DrawCircleV(screenCenter, 200, GRAY);
DrawRectangleVCentered(Vec2(screenCenter.x, screenCenter.y + 160), Vec2(380, 320), DARKGRAY);
DrawCircleV(screenCenter, 190, DARKscreenCenter.y - 40, 40, GRAY);
const char *suffix = "";
bool isTeen = deathCount > 10 && deathCount <= 20;
if (isTeen)
suffix = "th";
else
{
switch (deathCount % 10)
{
case 0: suffix = "th"; break;
case 1: suffix = "st"; break;
case 2: suffix = "nd"; break;
case 3: suffix = "rd"; break;
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
suffix = "th"; break;
}
}
char text[256];
snprintf(text, sizeof text, "The %d%s", deathCount, suffix);
DrawTextCentered(text, screenCenter.x, screenCenter.y + 10, 40, GRAY);
DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y + 100, 40, RED);
DrawTextCentered("YOU DIED", screenCenter.x, screenCenter.y + 102, 40, RED);
Rectangle rR = Rect(360, 660, 40, 40);
Vector2 cR = RectangleCenter(rR);
if (inputMode == INPUT_MODE_KEYBOARD_AND_MOUSE)
{
DrawRectangleLinesEx(rR, 4, GRAY);
DrawTextCentered("R", cR.x, cR.y, 28, GRAY);
}
else if (inputMode == INPUT_MODE_CONTROLLER)
{
DrawRing(cR, 24, 28, 0, 360, 64, Grayscale(0.2f));
DrawRing(cR, 20, 24, 0, 360, 64, GRAY);
DrawTextCentered("Y", cR.x, cR.y, 32, GRAY
```
<Overlap Ratio: 0.9318423855165069>

---

--- 336 --
Question ID: 31537c291d835ccea4546264aa4c0efa9b303b8b_1
Original Code:
```
static cleri_node_t * keyword__parse(
        cleri_parse_t * pr,
        cleri_node_t * parent,
        cleri_t * cl_obj,
        cleri_rule_store_t * rule __attribute__((unused)))
{
    ssize_t match_len;
    cleri_node_t * node = NULL;
    const char * str = parent->str + parent->len;

    if ((match_len = cleri__kwcache_match(pr, str)) < 0)
    {
        pr->is_valid = -1; /* error occurred */
        return NULL;
    }

    if (match_len == (ssize_t) cl_obj->via.keyword->len &&
       (
           strncmp(cl_obj->via.keyword->keyword, str, match_len) == 0 ||
           (
               cl_obj->via.keyword->ign_case &&
               strncasecmp(cl_obj->via.keyword->keyword, str, match_len) == 0
           )
       ))
    {
        if ((node = cleri__node_new(cl_obj, str, match_len)) != NULL)
        {
            parent->len += node->len;
            cleri__children_add(&parent->children, node);
        }
    }
    else
    {
        /* Update expecting */
        if (cleri__expecting_update(pr->expecting, cl_obj, str) == -1)
        {
            /* error occurred, node is already NULL */
            pr->is_valid = -1;
        }
    }
    return node;
}
```


Overlapping Code:
```
keyword__parse(
cleri_parse_t * pr,
cleri_node_t * parent,
cleri_t * cl_obj,
cleri_rule_store_t * rule __attribute__((unused)))
{
ssize_t match_len;
cleri_node_t * node = NULL;
const char * str = parent->str + parent->len;
if ((match_len = cleri__kwcache_match(pr, str)) < 0)
{
pr->is_valid = -1; /* error occurred */
return NULL;
}
if (match_len == (ssize_t) cl_obj->via.keyword->len &&
(
strncmp(cl_obj->via.keyword->keyword, str, match_len) == 0 ||
(
cl_obj->via.keyword->ign_case &&
strncasecmp(cl_obj->via.keyword->keyword, str, match_len) == 0
)
))
{
if ((node = cleri__node_new(cl_obj, str, match_len)) != NULL)
{
parent->len += node->len;
cleri__children_add(&parent->children, node);
}
}
else
{
/* Update expecting */
if (cleri__expecting_update(pr->expecting, cl_obj, str) == -1)
{
/* error occurred, node is already NULL */
pr->is_valid = -1;
```
<Overlap Ratio: 0.9541387024608501>

---

--- 337 --
Question ID: 7f50cb4ac97bcc72cbb91857626c04307a7ea9f3_84
Original Code:
```
static HRESULT WINAPI HTMLStyle_get_paddingTop(IHTMLStyle *iface, VARIANT *p)
{
    HTMLStyle *This = impl_from_IHTMLStyle(iface);

    TRACE("(%p)->(%p)\n", This, p);

    return get_style_property_var(&This->css_style, STYLEID_PADDING_TOP, p);
}
```


Overlapping Code:
```
ic HRESULT WINAPI HTMLStyle_get_paddingTop(IHTMLStyle *iface, VARIANT *p)
{
HTMLStyle *This = impl_from_IHTMLStyle(iface);
TRACE("(%p)->(%p)\n", This, p);
return get_style_property_var(&This->css_style, STYLEID_PADDI
```
<Overlap Ratio: 0.927038626609442>

---

--- 338 --
Question ID: 9e4d7e66baf3f2d4273e3e42b2fb1efc884d202e_7
Original Code:
```
void next_change() {
    int now, next, tot;
    string str;

    now = query_hour(time())*60 + query_minutes(time());
    switch(__TimeOfDay) {
        case "night":
            str = "sunrise";
            break;
        case "dawn":
            str = "morning";
            break;
        case "day":
            str = "twilight";
            break;
        case "twilight":
            str = "sunset";
            break;
    }
    next = (60*__Almanac[str][0]) + __Almanac[str][1];
    if(next > now) tot = next-now;
    else {
        now = (1200)-now;
        tot = next + now;
    }
    __Events[file_name(this_object())] =
      (["time":time()+(20*tot),"function":"change_sky","args":({}),"regular":0]);
}
```


Overlapping Code:
```
ot;
string str;
now = query_hour(time())*60 + query_minutes(time());
switch(__TimeOfDay) {
case "night":
str = "sunrise";
break;
case "dawn":
str = "morning";
break;
case "day":
str = "twilight";
break;
case "twilight":
str = "sunset";
break;
}
next = (60*__Almanac[str][0]) + __Almanac[str][1];
if(next > now) tot = next-now;
else {
now = (1200)-now;
tot = next + now;
}
__Events[file_name(this_object())] =
(["time":time()+(20*tot),"function":"chan
```
<Overlap Ratio: 0.8604206500956023>

---

--- 339 --
Question ID: 72b616439f9d250a23706d1e8aa2791b30c838b2_0
Original Code:
```
static __rte_always_inline uint16_t
otx2_ssogws_dual_get_work(struct otx2_ssogws_state *ws,
			  struct otx2_ssogws_state *ws_pair,
			  struct rte_event *ev, const uint32_t flags,
			  const void * const lookup_mem,
			  struct otx2_timesync_info * const tstamp)
{
	const uint64_t set_gw = BIT_ULL(16) | 1;
	union otx2_sso_event event;
	uint64_t tstamp_ptr;
	uint64_t get_work1;
	uint64_t mbuf;

	if (flags & NIX_RX_OFFLOAD_PTYPE_F)
		rte_prefetch_non_temporal(lookup_mem);
#ifdef RTE_ARCH_ARM64
	asm volatile(
			"rty%=:	                             \n"
			"        ldr %[tag], [%[tag_loc]]    \n"
			"        ldr %[wqp], [%[wqp_loc]]    \n"
			"        tbnz %[tag], 63, rty%=      \n"
			"done%=: str %[gw], [%[pong]]        \n"
			"        dmb ld                      \n"
			"        prfm pldl1keep, [%[wqp], #8]\n"
			"        sub %[mbuf], %[wqp], #0x80  \n"
			"        prfm pldl1keep, [%[mbuf]]   \n"
			: [tag] "=&r" (event.get_work0),
			  [wqp] "=&r" (get_work1),
			  [mbuf] "=&r" (mbuf)
			: [tag_loc] "r" (ws->tag_op),
			  [wqp_loc] "r" (ws->wqp_op),
			  [gw] "r" (set_gw),
			  [pong] "r" (ws_pair->getwrk_op)
			);
#else
	event.get_work0 = otx2_read64(ws->tag_op);
	while ((BIT_ULL(63)) & event.get_work0)
		event.get_work0 = otx2_read64(ws->tag_op);
	get_work1 = otx2_read64(ws->wqp_op);
	otx2_write64(set_gw, ws_pair->getwrk_op);

	rte_prefetch0((const void *)get_work1);
	mbuf = (uint64_t)((char *)get_work1 - sizeof(struct rte_mbuf));
	rte_prefetch0((const void *)mbuf);
#endif
	event.get_work0 = (event.get_work0 & (0x3ull << 32)) << 6 |
		(event.get_work0 & (0x3FFull << 36)) << 4 |
		(event.get_work0 & 0xffffffff);

	if (event.sched_type != SSO_TT_EMPTY) {
		if ((flags & NIX_RX_OFFLOAD_SECURITY_F) &&
		    (event.event_type == RTE_EVENT_TYPE_CRYPTODEV)) {
			get_work1 = otx2_handle_crypto_event(get_work1);
		} else if (event.event_type == RTE_EVENT_TYPE_ETHDEV) {
			uint8_t port = event.sub_event_type;

			event.sub_event_type = 0;
			otx2_wqe_to_mbuf(get_work1, mbuf, port,
					 event.flow_id, flags, lookup_mem);
			/* Extracting tstamp, if PTP enabled. CGX will prepend
			 * the timestamp at starting of packet data and it can
			 * be derieved from WQE 9 dword which corresponds to SG
			 * iova.
			 * rte_pktmbuf_mtod_offset can be used for this purpose
			 * but it brings down the performance as it reads
			 * mbuf->buf_addr which is not part of cache in general
			 * fast path.
			 */
			tstamp_ptr = *(uint64_t *)(((struct nix_wqe_hdr_s *)
						     get_work1) +
						     OTX2_SSO_WQE_SG_PTR);
			otx2_nix_mbuf_to_tstamp((struct rte_mbuf *)mbuf, tstamp,
						flags, (uint64_t *)tstamp_ptr);
			get_work1 = mbuf;
		}
	}

	ev->event = event.get_work0;
	ev->u64 = get_work1;

	return !!get_work1;
}
```


Overlapping Code:
```
tic __rte_always_inline uint16_t
otx2_ssogws_dual_get_work(struct otx2_ssogws_state *ws,
struct otx2_ssogws_state *ws_pair,
struct rte_event *ev, const uint32_t flags,
const void * const lookup_mem,
struct otx2_timesync_info * const tstamp)
{
const uint64_t set_gw = BIT_ULL(16) | 1;
union otx2_sso_event event;
uint64_t tstamp_ptr;
uint64_t get_work1;
uint64_t mbuf;
if (flags & NIX_RX_OFFLOAD_PTYPE_F)
rte_prefetch_non_temporal(lookup_mem);
#ifdef RTE_ARCH_ARM64
asm volatile(
"rty%=: \n"
" ldr %[tag], [%[tag_loc]] \n"
" ldr %[wqp], [%[wqp_loc]] \n"
" tbnz %[tag], 63, rty%= \n"
"done%=: str %[gw], [%[pong]] \n"
" dmb ld \n"
" prfm pldl1keep, [%[wqp], #8]\n"
" sub %[mbuf], %[wqp], #0x80 \n"
" prfm pldl1keep, [%[mbuf]] \n"
: [tag] "=&r" (event.get_work0),
[wqp] "=&r" (get_work1),
[mbuf] "=&r" (mbuf)
: [tag_loc] "r" (ws->tag_op),
[wqp_loc] "r" (ws->wqp_op),
[gw] "r" (set_gw),
[pong] "r" (ws_pair->getwrk_op)
);
#else
event.get_work0 = otx2_read64(ws->tag_op);
while ((BIT_ULL(63)) & event.get_work0)
event.get_work0 = otx2_read64(ws->tag_op);
get_work1 = otx2_read64(ws->wqp_op);
otx2_write64(set_gw, ws_pair->getwrk_op);
rte_prefetch0((const void *)get_work1);
mbuf = (uint64_t)((char *)get_work1 - sizeof(struct rte_mbuf));
rte_prefetch0((const void *)mbuf);
#endif
event.get_work0 = (event.get_work0 & (0x3ull << 32)) << 6 |
(event.get_work0 & (0x3FFull << 36)) << 4 |
(event.get_work0 & 0xffffffff);
if (event.sched_type != SSO_TT_EMPTY) {
if ((flags & NIX_RX_OFFLOAD_SECURITY_F) &&
(event.event_type == RTE_EVENT_TYPE_CRYPTODEV)) {
get_work1 = otx2_handle_crypto_event(get_work1);
} else if (event.event_type == RTE_EVENT_TYPE_ETHDEV) {
uint8_t port = event.sub_event_type;
event.sub_event_type = 0;
otx2_wqe_to_mbuf(get_work1, mbuf, port,
event.flow_id, flags, lookup_mem);
/* Extracting tstamp, if PTP enabled. CGX will prepend
* the timestamp at starting of packet data and it can
* be derieved from WQE 9 dword which corresponds to SG
* iova.
* rte_pktmbuf_mtod_offset can be used for this purpose
* but it brings down the performance as it reads
* mbuf->buf_addr which is not part of cache in general
* fast path.
*/
tstamp_ptr = *(uint64_t *)(((struct nix_wqe_hd
```
<Overlap Ratio: 0.9940720474236207>

---

--- 340 --
Question ID: 8254d2c68cc5daced7f7051d75c33a44571915ed_7
Original Code:
```
static void c3dhall5_i2c_write ( c3dhall5_t *ctx, uint8_t reg, uint8_t *data_buf, uint8_t len )
{
   uint8_t tx_buf[ 256 ];
    uint8_t cnt;
    
    tx_buf[ 0 ] = reg;

    for ( cnt = 1; cnt <= len; cnt++ )
    {
        tx_buf[ cnt ] = data_buf[ cnt - 1 ]; 
    }

    i2c_master_write( &ctx->i2c, tx_buf, len + 1 ); 
}
```


Overlapping Code:
```
static void c3dhall5_i2c_write ( c3dhall5_t *ctx, uint8_t reg, uint8_t *data_buf, uint8_t len )
{
uint8_t tx_buf[ 256 ];
uint8_t cnt;

tx_buf[ 0 ] = reg;
for ( cnt = 1; cnt <= len; cnt++ )
{
tx_buf[ cnt ] = data_buf[ cnt - 1 ]; 
}
i2c_master_write( &ctx->i2c, tx_buf, len + 1 ); 
}
```
<Overlap Ratio: 1.0>

---

--- 341 --
Question ID: b5dbbfbbdd770d96fbefbd245e3dd2fe9be9f13e_21
Original Code:
```
static int
json_encode_network_credentials(const struct dpp_network *network, struct json_object **jcredentials)
{
    int ret;
    json_object *credentials = json_object_new_array();
    if (!credentials) {
        zlog_error("failed to allocate json array for network credentials");
        return -ENOMEM;
    }

    struct json_object *jcredential;
    struct dpp_network_credential *credential;
    list_for_each_entry (credential, &network->credentials, list) {
        ret = json_encode_network_credential(credential, &jcredential);
        if (ret < 0) {
            zlog_error("failed to encode network credential for json network object (%d)", ret);
            goto fail;
        }

        ret = json_object_array_add(credentials, jcredential);
        if (ret < 0) {
            zlog_error("failed to add network credential to json credentials array (%d)", ret);
            json_object_put(jcredential);
            goto fail;
        }
    }

    *jcredentials = credentials;
out:
    return ret;
fail:
    json_object_put(credentials);
    goto out;
}
```


Overlapping Code:
```
(const struct dpp_network *network, struct json_object **jcredentials)
{
int ret;
json_object *credentials = json_object_new_array();
if (!credentials) {
zlog_error("failed to allocate json array for network credentials");
return -ENOMEM;
}
struct json_object *jcredential;
struct dpp_network_credential *credential;
list_for_each_entry (credential, &network->credentials, list) {
ret = json_encode_network_credential(credential, &jcredential);
if (ret < 0) {
zlog_error("failed to encode network credential for json network object (%d)", ret);
goto fail;
}
ret = json_object_array_add(credentials, jcredential);
if (ret < 0) {
zlog_error("failed to add network credential to json credentials array (%d)", ret);
json_object_put(jcredential);
goto fail;
}
}
*jcredentials = credentials;
out:
return ret;
fail:
json_object_put(credentials);
goto out;
}
```
<Overlap Ratio: 0.952914798206278>

---

--- 342 --
Question ID: d09205b5744bd3518e987809e77a7261fa464316_3
Original Code:
```
static void mesh_calc_eigen_matrix(const MVert *verts,
                                   const float (*vcos)[3],
                                   const int numverts,
                                   float r_mat[4][4])
{
  float center[3], covmat[3][3];
  float eigen_val[3], eigen_vec[3][3];
  float(*cos)[3] = NULL;

  bool eigen_success;
  int i;

  if (verts) {
    const MVert *mv;
    float(*co)[3];

    cos = MEM_mallocN(sizeof(*cos) * (size_t)numverts, __func__);
    for (i = 0, co = cos, mv = verts; i < numverts; i++, co++, mv++) {
      copy_v3_v3(*co, mv->co);
    }
    /* TODO(sergey): For until we officially drop all compilers which
     * doesn't handle casting correct we use workaround to avoid explicit
     * cast here.
     */
    vcos = (void *)cos;
  }
  unit_m4(r_mat);

  /* Note: here we apply sample correction to covariance matrix, since we consider the vertices
   *       as a sample of the whole 'surface' population of our mesh. */
  BLI_covariance_m3_v3n(vcos, numverts, true, covmat, center);

  if (cos) {
    MEM_freeN(cos);
  }

  eigen_success = BLI_eigen_solve_selfadjoint_m3((const float(*)[3])covmat, eigen_val, eigen_vec);
  BLI_assert(eigen_success);
  UNUSED_VARS_NDEBUG(eigen_success);

  /* Special handling of cases where some eigen values are (nearly) identical. */
  if (compare_ff_relative(eigen_val[0], eigen_val[1], FLT_EPSILON, 64)) {
    if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {
      /* No preferred direction, that set of vertices has a spherical average,
       * so we simply returned scaled/translated identity matrix (with no rotation). */
      unit_m3(eigen_vec);
    }
    else {
      /* Ellipsoid defined by eigen values/vectors has a spherical section,
       * we can only define one axis from eigen_vec[2] (two others computed eigen vecs
       * are not so nice for us here, they tend to 'randomly' rotate around valid one).
       * Note that eigen vectors as returned by BLI_eigen_solve_selfadjoint_m3() are normalized. */
      ortho_basis_v3v3_v3(eigen_vec[0], eigen_vec[1], eigen_vec[2]);
    }
  }
  else if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {
    /* Same as above, but with eigen_vec[1] as valid axis. */
    ortho_basis_v3v3_v3(eigen_vec[2], eigen_vec[0], eigen_vec[1]);
  }
  else if (compare_ff_relative(eigen_val[1], eigen_val[2], FLT_EPSILON, 64)) {
    /* Same as above, but with eigen_vec[0] as valid axis. */
    ortho_basis_v3v3_v3(eigen_vec[1], eigen_vec[2], eigen_vec[0]);
  }

  for (i = 0; i < 3; i++) {
    float evi = eigen_val[i];

    /* Protect against 1D/2D degenerated cases! */
    /* Note: not sure why we need square root of eigen values here
     * (which are equivalent to singular values, as far as I have understood),
     * but it seems to heavily reduce (if not completely nullify)
     * the error due to non-uniform scalings... */
    evi = (evi < 1e-6f && evi > -1e-6f) ? ((evi < 0.0f) ? -1e-3f : 1e-3f) : sqrtf_signed(evi);
    mul_v3_fl(eigen_vec[i], evi);
  }

  copy_m4_m3(r_mat, eigen_vec);
  copy_v3_v3(r_mat[3], center);
}
```


Overlapping Code:
```
_eigen_matrix(const MVert *verts,
const float (*vcos)[3],
const int numverts,
float r_mat[4][4])
{
float center[3], covmat[3][3];
float eigen_val[3], eigen_vec[3][3];
float(*cos)[3] = NULL;
bool eigen_success;
int i;
if (verts) {
const MVert *mv;
float(*co)[3];
cos = MEM_mallocN(sizeof(*cos) * (size_t)numverts, __func__);
for (i = 0, co = cos, mv = verts; i < numverts; i++, co++, mv++) {
copy_v3_v3(*co, mv->co);
}
/* TODO(sergey): For until we officially drop all compilers which
* doesn't handle casting correct we use workaround to avoid explicit
* cast here.
*/
vcos = (void *)cos;
}
unit_m4(r_mat);
/* Note: here we apply sample correction to covariance matrix, since we consider the vertices
* as a sample of the whole 'surface' population of our mesh. */
BLI_covariance_m3_v3n(vcos, numverts, true, covmat, center);
if (cos) {
MEM_freeN(cos);
}
eigen_success = BLI_eigen_solve_selfadjoint_m3((const float(*)[3])covmat, eigen_val, eigen_vec);
BLI_assert(eigen_success);
UNUSED_VARS_NDEBUG(eigen_success);
/* Special handling of cases where some eigen values are (nearly) identical. */
if (compare_ff_relative(eigen_val[0], eigen_val[1], FLT_EPSILON, 64)) {
if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {
/* No preferred direction, that set of vertices has a spherical average,
* so we simply returned scaled/translated identity matrix (with no rotation). */
unit_m3(eigen_vec);
}
else {
/* Ellipsoid defined by eigen values/vectors has a spherical section,
* we can only define one axis from eigen_vec[2] (two others computed eigen vecs
* are not so nice for us here, they tend to 'randomly' rotate around valid one).
* Note that eigen vectors as returned by BLI_eigen_solve_selfadjoint_m3() are normalized. */
ortho_basis_v3v3_v3(eigen_vec[0], eigen_vec[1], eigen_vec[2]);
}
}
else if (compare_ff_relative(eigen_val[0], eigen_val[2], FLT_EPSILON, 64)) {
/* Same as above, but with eigen_vec[1] as valid axis. */
ortho_basis_v3v3_v3(eigen_vec[2], eigen_vec[0], eigen_vec[1]);
}
else if (compare_ff_relative(eigen_val[1], eigen_val[2], FLT_EPSILON, 64)) {
/* Same as above, but with eigen_vec[0] as valid axis. */
ort
```
<Overlap Ratio: 0.9777171441564347>

---

--- 343 --
Question ID: 89c42ae9353f9e3ebe56f2ae40d58707c6662eaf_0
Original Code:
```
interface _SYQuiescenceObserver : NSObject {
    NSObject<OS_dispatch_group> * _allocationGroup;
    NSMutableSet * _allocations;
    NSPointerArray * _quiescenceQueues;
}
```


Overlapping Code:
```
Object {
NSObject<OS_dispatch_group> * _allocationGroup;
NSMutableSet * _allocations;
NSPointerArray
```
<Overlap Ratio: 0.6289308176100629>

---

--- 344 --
Question ID: 26b74c2f94968de7f56ead9227fe46751c6b67b6_0
Original Code:
```
static int __init sh7724_devices_setup(void)
{
	platform_resource_setup_memory(&vpu_device, "vpu", 2 << 20);
	platform_resource_setup_memory(&veu0_device, "veu0", 2 << 20);
	platform_resource_setup_memory(&veu1_device, "veu1", 2 << 20);
	platform_resource_setup_memory(&jpu_device,  "jpu",  2 << 20);
	platform_resource_setup_memory(&spu0_device, "spu0", 2 << 20);
	platform_resource_setup_memory(&spu1_device, "spu1", 2 << 20);

	return platform_add_devices(sh7724_devices,
				    ARRAY_SIZE(sh7724_devices));
}
```


Overlapping Code:
```
 __init sh7724_devices_setup(void)
{
platform_resource_setup_memory(&vpu_device, "vpu", 2 << 20);
platform_resource_setup_memory(&veu0_device, "veu0", 2 << 20);
platform_resource_setup_memory(&veu1_device, "veu1", 2 << 20);
platform_resource_setup_memory(&jpu_device, "jpu", 2 << 20);
platform_resource_setup_memory(&spu0_device, "spu0", 2 << 20);
platform_resource_setup_memory(&spu1_device, "spu1", 2 << 20);
return platform_add_devices(sh7724_devices,
ARRAY_SIZE(sh7724_dev
```
<Overlap Ratio: 0.9616161616161616>

---

--- 345 --
Question ID: 1e54ca985a3589d6ccbca5ca9dc98f1394152203_11
Original Code:
```
void *ui_get_system_icon ( int n )
{
    if (n <= 0){ return NULL; }

    // See: window.h
    switch (n){

    case 1: return (void *) shared_buffer_app_icon;       break;
    case 2: return (void *) shared_buffer_file_icon;      break;
    case 3: return (void *) shared_buffer_folder_icon;    break;
    case 4: return (void *) shared_buffer_terminal_icon;  break;
    case 5: return (void *) shared_buffer_cursor_icon;    break;
    // ...
    };

    return NULL;
}
```


Overlapping Code:
```
ystem_icon ( int n )
{
if (n <= 0){ return NULL; }
// See: window.h
switch (n){
case 1: return (void *) shared_buffer_app_icon; break;
case 2: return (void *) shared_buffer_file_icon; break;
case 3: return (void *) shared_buffer_folder_icon; break;
case 4: return (void *) shared_buffer_terminal_icon; break;
case 5: return (void *) shared_buffer_cur
```
<Overlap Ratio: 0.8641975308641975>

---

--- 346 --
Question ID: 8d543266af504d97e999e1e9a57dda0e4ea9581a_9
Original Code:
```
int wfaSetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
	dutCmdResponse_t *setEncrypResp = &wfaDutAgentData.gGenericResp;

	FILE *file,*tmpfd;
	char string[256],Interfacename[64], pfile[128], intfile[128];

	DPRINT_INFOL(WFA_OUT, "Entering wfaSetEncryptionZeroConfig ...\n"); 

	sprintf(pfile, "%s\\Temp\\tmp.xml", wtsPath);
	sprintf(wfaDutAgentData.gCmdStr, "del /F /Q %s", pfile);
	DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", wfaDutAgentData.gCmdStr);
	system(wfaDutAgentData.gCmdStr);

	file = fopen(pfile, "w+");
	if(file==NULL) 
	{
		DPRINT_ERR(WFA_ERR, "Error: can't create file.\n");
		setEncrypResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		return WFA_FAILURE;
	}
	else 
	{
		sprintf(wfaDutAgentData.gCmdStr,"<?xml version=\"1.0\"?>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<SSIDConfig>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t<SSID>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t</SSID>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t</SSIDConfig>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<connectionType>ESS</connectionType>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t<MSM>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t<security>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<authEncryption>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<authentication>open</authentication>\n");
		fputs(wfaDutAgentData.gCmdStr, file);

		if(setEncryp->encpType == 1)
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<encryption>WEP</encryption>\n");
		else
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<encryption>none</encryption>\n");

		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t\t\t</authEncryption>\n");
		fputs(wfaDutAgentData.gCmdStr, file);

		if(setEncryp->encpType == 1)
		{
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t\t<sharedKey>\n");
			fputs(wfaDutAgentData.gCmdStr, file);
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t\t\t<keyType>networkKey</keyType>\n");
			fputs(wfaDutAgentData.gCmdStr, file);
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t\t\t<protected>false</protected>\n");
			fputs(wfaDutAgentData.gCmdStr, file);
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t\t\t<keyMaterial>%s</keyMaterial>\n",setEncryp->keys[0]);
			fputs(wfaDutAgentData.gCmdStr, file);
			sprintf(wfaDutAgentData.gCmdStr,"\t\t\t\t</sharedKey>\n");
			fputs(wfaDutAgentData.gCmdStr, file);
		}

		sprintf(wfaDutAgentData.gCmdStr,"\t\t</security>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"\t</MSM>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
		sprintf(wfaDutAgentData.gCmdStr,"</WLANProfile>\n");
		fputs(wfaDutAgentData.gCmdStr, file);
	}
	fclose(file);

	sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", wtsPath);
	tmpfd = fopen(intfile, "r");
	if(tmpfd == NULL)
	{
		DPRINT_ERR(WFA_ERR, "Error opening the interface file \n");
		setEncrypResp->status = STATUS_ERROR;
		wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
		*respLen = WFA_TLV_HDR_LEN + 4;

		return WFA_FAILURE;
	}
	else
	{
		for(;;)
		{
			if(fgets(string, 256, tmpfd) == NULL)
				break; 
		}
		fclose(tmpfd);

		if(strncmp(string, "IFNAME", 6) == 0)
		{
			char *str;
			str = strtok(string, "\"");
			str = strtok(NULL, "\"");
			if(str != NULL)
			{
				strcpy(&Interfacename[0],str);
			}
		}
	}

	sprintf(wfaDutAgentData.gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all", pfile,&Interfacename[0]);

	DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", wfaDutAgentData.gCmdStr);
	system(wfaDutAgentData.gCmdStr);

	setEncrypResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	DPRINT_INFOL(WFA_OUT, "Completing ...\n");
	return WFA_SUCCESS;
}
```


Overlapping Code:
```
SetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
dutCmdResponse_t *setEncrypResp = &wfaDutAgentData.gGenericResp;
FILE *file,*tmpfd;
char string[256],Interfacename[64], pfile[128], intfile[128];
DPRINT_INFOL(WFA_OUT, "Entering wfaSetEncryptionZeroConfig ...\n"); 
sprintf(pfile, "%s\\Temp\\tmp.xml", wtsPath);
sprintf(wfaDutAgentData.gCmdStr, "del /F /Q %s", pfile);
DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", wfaDutAgentData.gCmdStr);
system(wfaDutAgentData.gCmdStr);
file = fopen(pfile, "w+");
if(file==NULL) 
{
DPRINT_ERR(WFA_ERR, "Error: can't create file.\n");
setEncrypResp->status = STATUS_ERROR;
wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
*respLen = WFA_TLV_HDR_LEN + 4;
return WFA_FAILURE;
}
else 
{
sprintf(wfaDutAgentData.gCmdStr,"<?xml version=\"1.0\"?>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<SSIDConfig>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t<SSID>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t</SSID>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t</SSIDConfig>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<connectionType>ESS</connectionType>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t<MSM>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t<security>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<authEncryption>\n");
fputs(wfaDutAgentData.gCmdStr, file);
sprintf(wfaDutAgentData.gCmdStr,"\t\t\t<authentication>
```
<Overlap Ratio: 0.9940577249575552>

---

--- 347 --
Question ID: d2623747b489a90116a9876c89fd9fd289966f9e_10
Original Code:
```
static void fhci_usb_free(void *lld)
{
	struct fhci_usb *usb = lld;
	struct fhci_hcd *fhci;

	if (usb) {
		fhci = usb->fhci;
		fhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);
		fhci_ep0_free(usb);
		kfree(usb->actual_frame);
		kfree(usb);
	}
}
```


Overlapping Code:
```

{
struct fhci_usb *usb = lld;
struct fhci_hcd *fhci;
if (usb) {
fhci = usb->fhci;
fhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);
fhci_ep0_free(u
```
<Overlap Ratio: 0.646551724137931>

---

--- 348 --
Question ID: 9e7b342880f8953d28f7cd2f82e7b327dfacdf71_1
Original Code:
```
static
DWORD
PrintToRegFile(
    IN FILE* fp,
    IN PCSTR pszKeyName,
    IN OPTIONAL PCSTR pszSddlCString,
    IN REG_DATA_TYPE dataType,
    IN PCSTR pszValueName,
    IN REG_DATA_TYPE type,
    IN BOOLEAN bDefault,
    IN PVOID value,
    IN DWORD dwValueLen,
    OUT PREG_DATA_TYPE pPrevType
    )
{
    PSTR dumpString = NULL;
    DWORD dumpStringLen = 0;
    PSTR pszStart = NULL;
    PSTR pszEnd = NULL;
    PSTR pszComment = bDefault ? "#" : "";

    RegExportEntry(pszKeyName,
                   pszSddlCString,
                   dataType,
                   pszValueName,
                   type,
                   value,
                   dwValueLen,
                   &dumpString,
                   &dumpStringLen);

   if (dumpStringLen > 0 && dumpString)
   {
       switch (type)
       {
           case REG_KEY:
               fprintf(fp, "\r\n%s%.*s\r\n", 
                       pszComment, dumpStringLen, dumpString);
               break;

           case REG_MULTI_SZ:
               pszStart = dumpString;
               pszEnd = strchr(pszStart, '\n');
               while (pszEnd)
               {
                   fprintf(fp, "%s%.*s\r\n", 
                           pszComment, (int) (pszEnd-pszStart), pszStart);
                   pszStart = pszEnd+1;
                   pszEnd = strchr(pszStart, '\n');
               }
               if (pszStart && *pszStart)
               {
                   fprintf(fp, "%s%s\r\n", 
                           pszComment, pszStart);
               }
               break;

           case REG_PLAIN_TEXT:
               if (*pPrevType && *pPrevType != type)
               {
                   printf("\n");
               }
               fprintf(fp, "%s%*s ", pszComment, dwValueLen, (PCHAR) value);
               break;

           default:
               fprintf(fp, "%s%.*s\r\n", pszComment, dumpStringLen, dumpString);
               break;
       }
   }
   fflush(stdout);
   *pPrevType = type;

   if (dumpString)
   {
       RegMemoryFree(dumpString);
       dumpString = NULL;
   }

   return 0;
}
```


Overlapping Code:
```
ic
DWORD
PrintToRegFile(
IN FILE* fp,
IN PCSTR pszKeyName,
IN OPTIONAL PCSTR pszSddlCString,
IN REG_DATA_TYPE dataType,
IN PCSTR pszValueName,
IN REG_DATA_TYPE type,
IN BOOLEAN bDefault,
IN PVOID value,
IN DWORD dwValueLen,
OUT PREG_DATA_TYPE pPrevType
)
{
PSTR dumpString = NULL;
DWORD dumpStringLen = 0;
PSTR pszStart = NULL;
PSTR pszEnd = NULL;
PSTR pszComment = bDefault ? "#" : "";
RegExportEntry(pszKeyName,
pszSddlCString,
dataType,
pszValueName,
type,
value,
dwValueLen,
&dumpString,
&dumpStringLen);
if (dumpStringLen > 0 && dumpString)
{
switch (type)
{
case REG_KEY:
fprintf(fp, "\r\n%s%.*s\r\n", 
pszComment, dumpStringLen, dumpString);
break;
case REG_MULTI_SZ:
pszStart = dumpString;
pszEnd = strchr(pszStart, '\n');
while (pszEnd)
{
fprintf(fp, "%s%.*s\r\n", 
pszComment, (int) (pszEnd-pszStart), pszStart);
pszStart = pszEnd+1;
pszEnd = strchr(pszStart, '\n');
}
if (pszStart && *pszStart)
{
fprintf(fp, "%s%s\r\n", 
pszComment, pszStart);
}
break;
case REG_PLAIN_TEXT:
if (*pPrevType && *pPrevType != type)
{
printf("\n");
}
fprintf(fp, "%s%*s ", pszComment, dwValueLen, (PCHAR) value);
break;
default:
fprintf(fp, "%s%.*s\r\n", pszComment, dumpStringLen, dumpString);
break;
}
}
fflush(stdout);
*pPrevType = type;
if (dumpString)
{
RegMemoryFree(dumpString);
dumpString = NULL;
}
re
```
<Overlap Ratio: 0.9900990099009901>

---

--- 349 --
Question ID: 108d6a71c5c5a6577a8a0a6293df3522c00bb605_14
Original Code:
```
struct apartment * apartment_get_current_or_mta(void)
{
    struct apartment *apt = com_get_current_apt();
    if (apt)
    {
        apartment_addref(apt);
        return apt;
    }
    return apartment_get_mta();
}
```


Overlapping Code:
```
artment * apartment_get_current_or_mta(void)
{
struct apartment *apt = com_get_current_apt();
if (apt)
{
apartment_addref(apt);
return apt;
}
return a
```
<Overlap Ratio: 0.8333333333333334>

---

--- 350 --
Question ID: d270d42351e8ad95b2c520d8697dacdb30d633bc_0
Original Code:
```
static void copy_flags(BIO *bio)
{
    int flags;
    BIO *next = BIO_next(bio);

    flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
    BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
    BIO_set_flags(bio, flags);
}
```


Overlapping Code:
```
BIO *bio)
{
int flags;
BIO *next = BIO_next(bio);
flags = BIO_test_flags(next, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
BIO_clear_flags(bio, BIO_FLAGS_SHOULD_RETRY | BIO_FLAGS_RWS);
BIO_set_flags(bio,
```
<Overlap Ratio: 0.8583690987124464>

---

--- 351 --
Question ID: 53fca1f05a5c3e62f8307af96ea2e635f368a4b7_13
Original Code:
```
const struct Nif *ledc_nif_get_nif(const char *nifname)
{
    if (strcmp("ledc:timer_config/1", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_timer_config_nif;
    }
    if (strcmp("ledc:channel_config/1", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_channel_config_nif;
    }
    if (strcmp("ledc:fade_func_install/1", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_fade_func_install_nif;
    }
    if (strcmp("ledc:fade_func_uninstall/0", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_fade_func_uninstall_nif;
    }
    if (strcmp("ledc:set_fade_with_time/4", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_set_fade_with_time_nif;
    }
    if (strcmp("ledc:set_fade_with_step/5", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_set_fade_with_step_nif;
    }
    if (strcmp("ledc:fade_start/3", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_fade_start_nif;
    }
    if (strcmp("ledc:get_duty/2", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_get_duty_nif;
    }
    if (strcmp("ledc:set_duty/3", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_set_duty_nif;
    }
    if (strcmp("ledc:update_duty/2", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_update_duty_nif;
    }
    if (strcmp("ledc:get_freq/2", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_get_freq_nif;
    }
    if (strcmp("ledc:set_freq/3", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_set_freq_nif;
    }
    if (strcmp("ledc:stop/3", nifname) == 0) {
        TRACE("Resolved platform nif %s ...\n", nifname);
        return &ledc_stop_nif;
    }
    return NULL;
}
```


Overlapping Code:
```
f(const char *nifname)
{
if (strcmp("ledc:timer_config/1", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_timer_config_nif;
}
if (strcmp("ledc:channel_config/1", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_channel_config_nif;
}
if (strcmp("ledc:fade_func_install/1", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_fade_func_install_nif;
}
if (strcmp("ledc:fade_func_uninstall/0", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_fade_func_uninstall_nif;
}
if (strcmp("ledc:set_fade_with_time/4", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_set_fade_with_time_nif;
}
if (strcmp("ledc:set_fade_with_step/5", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_set_fade_with_step_nif;
}
if (strcmp("ledc:fade_start/3", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_fade_start_nif;
}
if (strcmp("ledc:get_duty/2", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_get_duty_nif;
}
if (strcmp("ledc:set_duty/3", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_set_duty_nif;
}
if (strcmp("ledc:update_duty/2", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_update_duty_nif;
}
if (strcmp("ledc:get_freq/2", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_get_freq_nif;
}
if (strcmp("ledc:set_freq/3", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &ledc_set_freq_nif;
}
if (strcmp("ledc:stop/3", nifname) == 0) {
TRACE("Resolved platform nif %s ...\n", nifname);
return &le
```
<Overlap Ratio: 0.9657836644591612>

---

--- 352 --
Question ID: 9e4408e16499f77245cc97e399f4522aeda068ad_1
Original Code:
```
static int _do_def_check(struct config_def_tree_spec *spec,
			 struct dm_config_tree *cft,
			 struct cft_check_handle **cft_check_handle)
{
	struct cft_check_handle *handle;

	if (!(handle = get_config_tree_check_handle(spec->cmd, cft)))
		return 0;

	handle->force_check = 1;
	handle->suppress_messages = 1;

	if (spec->type == CFG_DEF_TREE_DIFF) {
		if (!handle->check_diff)
			handle->skip_if_checked = 0;
		handle->check_diff = 1;
	} else {
		handle->skip_if_checked = 1;
		handle->check_diff = 0;
	}

	handle->ignoreunsupported = spec->ignoreunsupported;
	handle->ignoreadvanced = spec->ignoreadvanced;

	config_def_check(handle);
	*cft_check_handle = handle;

	return 1;
}
```


Overlapping Code:
```
eck(struct config_def_tree_spec *spec,
struct dm_config_tree *cft,
struct cft_check_handle **cft_check_handle)
{
struct cft_check_handle *handle;
if (!(handle = get_config_tree_check_handle(spec->cmd, cft)))
return 0;
handle->force_check = 1;
handle->suppress_messages = 1;
if (spec->type == CFG_DEF_TREE_DIFF) {
if (!handle->check_diff)
handle->skip_if_checked = 0;
handle->check_diff = 1;
} else {
handle->skip_if_checked = 1;
handle->check_diff = 0;
}
handle->ignoreunsupported = spec->ignoreunsupported;
handle->ignoreadvanced = spec->ignoreadvanced;
config_def_check(handle);
*cft_check_handle =
```
<Overlap Ratio: 0.9360374414976599>

---

--- 353 --
Question ID: c6b68d3a26216b4d8a980d7c9607ae02b23e637e_2
Original Code:
```
void CurveInterpolation4(MImagePoint *pt1,MImagePoint *pt2,int type,float d11,float d12,MMatrix *mat,MImageCurve *curve)
{
    float x1,y1,x2,y2;
    curve->type=type;
    if(type==MORN_CURVE_X) {x1=pt1->x;y1=pt1->y;x2=pt2->x;y2=pt2->y;}
    else                   {x1=pt1->y;y1=pt1->x;x2=pt2->y;y2=pt2->x;}
    curve->v1=*pt1;curve->v2=*pt2;
    curve->curve = curve_interpolation;
    
    mMatrixRedefine(mat,4,5);float **data=mat->data;
    data[0][0]=1;data[0][1]=x1;data[0][2]=x1*x1;data[0][3]=x1*x1*x1;data[0][4]=0-y1;
    data[1][0]=1;data[1][1]=x2;data[1][2]=x2*x2;data[1][3]=x2*x2*x2;data[1][4]=0-y2;
    data[2][0]=0;data[2][1]= 1;data[2][2]= 2*x1;data[2][3]= 3*x1*x1;data[2][4]=0-d11;
    data[3][0]=0;data[3][1]= 0;data[3][2]= 2   ;data[3][3]= 6*x1   ;data[3][4]=0-d12;
    mLinearEquation(mat,curve->para);
}
```


Overlapping Code:
```
ImagePoint *pt2,int type,float d11,float d12,MMatrix *mat,MImageCurve *curve)
{
float x1,y1,x2,y2;
curve->type=type;
if(type==MORN_CURVE_X) {x1=pt1->x;y1=pt1->y;x2=pt2->x;y2=pt2->y;}
else {x1=pt1->y;y1=pt1->x;x2=pt2->y;y2=pt2->x;}
curve->v1=*pt1;curve->v2=*pt2;
curve->curve = curve_interpolation;

mMatrixRedefine(mat,4,5);float **data=mat->data;
data[0][0]=1;data[0][1]=x1;data[0][2]=x1*x1;data[0][3]=x1*x1*x1;data[0][4]=0-y1;
data[1][0]=1;data[1][1]=x2;data[1][2]=x2*x2;data[1][3]=x2*x2*x2;data[1][4]=0-y2;
data[2][0]=0;data[2][1]= 1;data[2][2]= 2*x1;data[2][3]= 3*x1*x1;data[2][4]=0-d11;
data[3][0]=0;data[3][1]= 0;data[3][2]= 2 ;data[3][3]= 6*x1 ;data[3][4]=0-d12;
mLinearEquation(mat,curve->par
```
<Overlap Ratio: 0.9358288770053476>

---

--- 354 --
Question ID: 90a9c92eb6ebb6f3b409bed27e1f1e0f6df13b25_0
Original Code:
```
interface EditImageTextBgView : UIView
{
    double _maxWidth;
    NSMutableArray *_backgroundRects;
    UIColor *_textBgColor;
    double _scale;
    double _cornerRadius;
}
```


Overlapping Code:
```
w
{
double _maxWidth;
NSMutableArray *_backgroundRects;
UIColor *_textBgColor;
double _scale;
double 
```
<Overlap Ratio: 0.6558441558441559>

---

--- 355 --
Question ID: 6541816868ed186ed44d0daed3d9aadd313dda23_9
Original Code:
```
extern __inline__ void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
	unsigned long flags;

	save_flags(flags);
	cli();
	__skb_insert(old, newsk);
	restore_flags(flags);
}
```


Overlapping Code:
```
ine__ void skb_insert(struct sk_buff *old, struct sk_buff *newsk)
{
unsigned long flags;
save_flags(flags);
cli();
__skb_insert(old, newsk);
restore_f
```
<Overlap Ratio: 0.8522727272727273>

---

--- 356 --
Question ID: b38756623040a50d9e62930dd540e36501b71d97_8
Original Code:
```
NTSTATUS KDispatchClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information=0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
```


Overlapping Code:
```
patchClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
Irp->IoStatus.Status = STATUS_SUCCESS;
Irp->IoStatus.Information=0;
IoCompleteRequest(Irp, IO_NO_INCREMENT);
return STATUS_SUCCESS;
}
```
<Overlap Ratio: 0.9362745098039216>

---

--- 357 --
Question ID: 12c67cafd3b8d794fd878a7e1ac8eab6438cbeaf_293
Original Code:
```
static PyObject *Qt_EnterMovies(PyObject *_self, PyObject *_args)
{
	PyObject *_res = NULL;
	OSErr _err;
	if (!PyArg_ParseTuple(_args, ""))
		return NULL;
	_err = EnterMovies();
	if (_err != noErr) return PyMac_Error(_err);
	Py_INCREF(Py_None);
	_res = Py_None;
	return _res;
}
```


Overlapping Code:
```
tatic PyObject *Qt_EnterMovies(PyObject *_self, PyObject *_args)
{
PyObject *_res = NULL;
OSErr _err;
if (!PyArg_ParseTuple(_args, ""))
return NULL;
_err = EnterMovies();
if (_err != noErr) return PyMac_Error(_err);
Py_INCREF(Py_None);
_res = Py_None;
return _res;
}
```
<Overlap Ratio: 0.9962546816479401>

---

--- 358 --
Question ID: e523da4b448072e3b7422d26c4f2ee524bc20574_4
Original Code:
```
static void start_encoding( void )
{   low = 0;                                    /* Full code range.         */
    high = Top_value;
    bits_to_follow = 0;                         /* No bits to follow next.  */
}
```


Overlapping Code:
```
 = 0; /* Full code range. */
high = Top_value;
bits_to_follow = 0; /* No bits 
```
<Overlap Ratio: 0.5652173913043478>

---

--- 359 --
Question ID: 3e8e03e4caee9bf8e065c966a1fd63b3a9583bde_0
Original Code:
```
const T item{static_cast<T>(value)};
    /** In case of vec<> the static_cast calls an appropriate constructor, so
     *  all elements of the vector are initialized to the value given
     */
    result[i] = item;
    *iteratorPtr = item;
  }
```


Overlapping Code:
```
ic_cast<T>(value)};
/** In case of vec<> the static_cast calls an appropriate constructor, so
* all elements of the vector are initialized to the value given
*/
result[i] = item;
*iteratorPtr = item;

```
<Overlap Ratio: 0.9174311926605505>

---

--- 360 --
Question ID: c65448eb3e839a5c6b0e612f182d0e1143e6e2e9_97
Original Code:
```
static PyObject *Qd_OpenPoly(PyObject *_self, PyObject *_args)
{
	PyObject *_res = NULL;
	PolyHandle _rv;
	if (!PyArg_ParseTuple(_args, ""))
		return NULL;
	_rv = OpenPoly();
	_res = Py_BuildValue("O&",
	                     ResObj_New, _rv);
	return _res;
}
```


Overlapping Code:
```
yObject *Qd_OpenPoly(PyObject *_self, PyObject *_args)
{
PyObject *_res = NULL;
PolyHandle _rv;
if (!PyArg_ParseTuple(_args, ""))
return NULL;
_rv = OpenPoly();
_res = Py_BuildValue("O&",
ResObj_New, _rv);
return _res;
}
```
<Overlap Ratio: 0.9649122807017544>

---

--- 361 --
Question ID: 09ba3ffb82de7f9438a0ad27c93a7445344a4ffd_3
Original Code:
```
void readargs(int argc, char *const argv[])
{
    /* Wrong usage. */
    if (argc < 3)
    {
        fprintf(stderr, "Usage: %s <remote.ipv4> <remote.port>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    args.remote.ipv4 = argv[1];
    sscanf(argv[2], "%" SCNu16, &args.remote.port);
}
```


Overlapping Code:
```
d readargs(int argc, char *const argv[])
{
/* Wrong usage. */
if (argc < 3)
{
fprintf(stderr, "Usage: %s <remote.ipv4> <remote.port>\n", argv[0]);
exit(EXIT_FAILURE);
}
args.remote.ipv4 = argv[1];
ssc
```
<Overlap Ratio: 0.8032128514056225>

---

--- 362 --
Question ID: 9eff40876ed2ed2cd2eaf7064983bcd983c20ad2_17
Original Code:
```
int rdpei_add_contact(RdpeiClientContext* context, RDPINPUT_CONTACT_DATA* contact)
{
	RDPINPUT_CONTACT_POINT* contactPoint;
	RDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*) context->handle;

	EnterCriticalSection(&rdpei->lock);

	contactPoint = (RDPINPUT_CONTACT_POINT*) &rdpei->contactPoints[contact->contactId];
	CopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));
	contactPoint->dirty = TRUE;

	SetEvent(rdpei->event);

	LeaveCriticalSection(&rdpei->lock);

	return 1;
}
```


Overlapping Code:
```
ntext, RDPINPUT_CONTACT_DATA* contact)
{
RDPINPUT_CONTACT_POINT* contactPoint;
RDPEI_PLUGIN* rdpei = (RDPEI_PLUGIN*) context->handle;
EnterCriticalSection(&rdpei->lock);
contactPoint = (RDPINPUT_CONTACT_POINT*) &rdpei->contactPoints[contact->contactId];
CopyMemory(&(contactPoint->data), contact, sizeof(RDPINPUT_CONTACT_DATA));
contactPoint->dirty = TRUE;
SetEvent(rdpei->event);
LeaveCriticalSection(&rdpei->lock);
return 
```
<Overlap Ratio: 0.8983050847457628>

---

--- 363 --
Question ID: f05e68d693b29d59f5ac61009f4031f50a391f02_2
Original Code:
```
string find_highest_level_class(object who)
{
    string *myClasses, highclass;
    int lev = 0, x, clev;
    if(!objectp(who)) return "fail";
    myClasses = who->query_classes();
    for(x = 0;x < sizeof(myClasses);x++)
    {
        clev = (int)who->query_class_level(myClasses[x]);
        if(lev > clev) continue;
        else
        {
            lev = clev;
            highclass = myClasses[x];
            continue;
        }
    }
    if(!stringp(highclass)) return "fail";
    return highclass;

}
```


Overlapping Code:
```
ind_highest_level_class(object who)
{
string *myClasses, highclass;
int lev = 0, x, clev;
if(!objectp(who)) return "fail";
myClasses = who->query_classes();
for(x = 0;x < sizeof(myClasses);x++)
{
clev = (int)who->query_class_level(myClasses[x]);
if(lev > clev) continue;
else
{
lev = clev;
highclass = myClasses[x];
continue;
}
}
if(!stringp(highclas
```
<Overlap Ratio: 0.8838383838383839>

---

--- 364 --
Question ID: 5c4f2822f01ba76df480884fc4b7b1ffe90f65af_11
Original Code:
```
void vm_page_more_fictitious(void)
{
	register vm_page_t m;
	int i;

	for (i = 0; i < vm_page_fictitious_quantum; i++) {
		m = (vm_page_t) zalloc(vm_page_zone);
		if (m == VM_PAGE_NULL)
			panic("vm_page_more_fictitious");

		vm_page_init(m, vm_page_fictitious_addr);
		m->fictitious = TRUE;
		vm_page_release_fictitious(m);
	}
}
```


Overlapping Code:
```
ore_fictitious(void)
{
register vm_page_t m;
int i;
for (i = 0; i < vm_page_fictitious_quantum; i++) {
m = (vm_page_t) zalloc(vm_page_zone);
if (m == VM_PAGE_NULL)
panic("vm_page_more_fictitious");
vm_page_init(m, vm_page_fictitious_addr);
m->fictitious = TRUE;
vm_page_release_fict
```
<Overlap Ratio: 0.9096774193548387>

---

--- 365 --
Question ID: a134504fbd856ebe3b707251f43e6b35d9df4494_1
Original Code:
```
void print_entry(
    char *entry_name,
    PVFS_handle handle,
    PVFS_fs_id fs_id)
{
    PVFS_object_ref pinode_refn;
    PVFS_credential credentials;
    PVFS_sysresp_getattr getattr_response;

    memset(&getattr_response,0, sizeof(PVFS_sysresp_getattr));

    PVFS_util_gen_credential_defaults(&credentials);
    
    pinode_refn.handle = handle;
    pinode_refn.fs_id = fs_id;

    if (PVFS_sys_getattr(pinode_refn, PVFS_ATTR_SYS_ALL,
                         &credentials, &getattr_response, NULL))
    {
        fprintf(stderr,"Failed to get attributes on handle 0x%08llx "
                "(fs_id is %d)\n",llu(handle),fs_id);
        return;
    }
    print_entry_attr(entry_name, &getattr_response.attr);
}
```


Overlapping Code:
```
ry_name,
PVFS_handle handle,
PVFS_fs_id fs_id)
{
PVFS_object_ref pinode_refn;
PVFS_credential credentials;
PVFS_sysresp_getattr getattr_response;
memset(&getattr_response,0, sizeof(PVFS_sysresp_getattr));
PVFS_util_gen_credential_defaults(&credentials);

pinode_refn.handle = handle;
pinode_refn.fs_id = fs_id;
if (PVFS_sys_getattr(pinode_refn, PVFS_ATTR_SYS_ALL,
&credentials, &getattr_response, NULL))
{
fprintf(stderr,"Failed to get attributes on handle 0x%08llx "
"(fs_id is %d)\n",llu(handle),fs_id);
return;
}
print_entry_attr(entry_name, &geta
```
<Overlap Ratio: 0.919732441471572>

---

--- 366 --
Question ID: 5e663a62dd6fc9ad3b09570386d376b277c2fca7_25
Original Code:
```
static int
acc100_queue_intr_disable(struct rte_bbdev *dev, uint16_t queue_id)
{
	struct acc100_queue *q = dev->data->queues[queue_id].queue_private;

	if (dev->intr_handle->type != RTE_INTR_HANDLE_VFIO_MSI &&
			dev->intr_handle->type != RTE_INTR_HANDLE_UIO)
		return -ENOTSUP;

	q->irq_enable = 0;
	return 0;
}
```


Overlapping Code:
```
_intr_disable(struct rte_bbdev *dev, uint16_t queue_id)
{
struct acc100_queue *q = dev->data->queues[queue_id].queue_private;
if (dev->intr_handle->type != RTE_INTR_HANDLE_VFIO_MSI &&
dev->intr_handle->type != RTE_INTR_HANDLE_UIO)
return -ENOTSUP;
q->i
```
<Overlap Ratio: 0.8372093023255814>

---

--- 367 --
Question ID: 3439e09eb7817d28463b3e602b8e92569340c98a_8
Original Code:
```
int
tcpprep_set_min_mask(tcpprep_t *ctx, int value)
{
    assert(ctx);
    ctx->options->min_mask = value;
    return 0;
}
```


Overlapping Code:
```
*ctx, int value)
{
assert(ctx);
ctx->options->min_
```
<Overlap Ratio: 0.45454545454545453>

---

--- 368 --
Question ID: d36e38df4afd0b4ec0d9c497a13f9e0fa8ca11c0_87
Original Code:
```
void
lock_print_info_all_transactions(
/*=============================*/
	FILE*	file)	/* in: file where to print */
{
	lock_t*	lock;
	ulint	space;
	ulint	page_no;
	ibool	load_page_first = TRUE;
	ulint	nth_trx		= 0;
	ulint	nth_lock	= 0;
	ulint	i;
	mtr_t	mtr;
	trx_t*	trx;

	fprintf(file, "LIST OF TRANSACTIONS FOR EACH SESSION:\n");

	/* First print info on non-active transactions */

	trx = UT_LIST_GET_FIRST(trx_sys->mysql_trx_list);

	while (trx) {
		if (trx->conc_state == TRX_NOT_STARTED) {
			fputs("---", file);
			trx_print(file, trx, 600);
		}

		trx = UT_LIST_GET_NEXT(mysql_trx_list, trx);
	}

loop:
	trx = UT_LIST_GET_FIRST(trx_sys->trx_list);

	i = 0;

	/* Since we temporarily release the kernel mutex when
	reading a database page in below, variable trx may be
	obsolete now and we must loop through the trx list to
	get probably the same trx, or some other trx. */

	while (trx && (i < nth_trx)) {
		trx = UT_LIST_GET_NEXT(trx_list, trx);
		i++;
	}

	if (trx == NULL) {
		lock_mutex_exit_kernel();

		ut_ad(lock_validate());

		return;
	}

	if (nth_lock == 0) {
		fputs("---", file);
		trx_print(file, trx, 600);

		if (trx->read_view) {
			fprintf(file,
				"Trx read view will not see trx with"
				" id >= %lu %lu, sees < %lu %lu\n",
				(ulong) ut_dulint_get_high(
					trx->read_view->low_limit_id),
				(ulong) ut_dulint_get_low(
					trx->read_view->low_limit_id),
				(ulong) ut_dulint_get_high(
					trx->read_view->up_limit_id),
				(ulong) ut_dulint_get_low(
					trx->read_view->up_limit_id));
		}

		if (trx->que_state == TRX_QUE_LOCK_WAIT) {
			fprintf(file,
				"------- TRX HAS BEEN WAITING %lu SEC"
				" FOR THIS LOCK TO BE GRANTED:\n",
				(ulong) difftime(time(NULL),
						 trx->wait_started));

			if (lock_get_type(trx->wait_lock) == LOCK_REC) {
				lock_rec_print(file, trx->wait_lock);
			} else {
				lock_table_print(file, trx->wait_lock);
			}

			fputs("------------------\n", file);
		}
	}

	if (!srv_print_innodb_lock_monitor) {
		nth_trx++;
		goto loop;
	}

	i = 0;

	/* Look at the note about the trx loop above why we loop here:
	lock may be an obsolete pointer now. */

	lock = UT_LIST_GET_FIRST(trx->trx_locks);

	while (lock && (i < nth_lock)) {
		lock = UT_LIST_GET_NEXT(trx_locks, lock);
		i++;
	}

	if (lock == NULL) {
		nth_trx++;
		nth_lock = 0;

		goto loop;
	}

	if (lock_get_type(lock) == LOCK_REC) {
		space = lock->un_member.rec_lock.space;
		page_no = lock->un_member.rec_lock.page_no;

		if (load_page_first) {
			lock_mutex_exit_kernel();

			mtr_start(&mtr);

			buf_page_get_with_no_latch(space, page_no, &mtr);

			mtr_commit(&mtr);

			load_page_first = FALSE;

			lock_mutex_enter_kernel();

			goto loop;
		}

		lock_rec_print(file, lock);
	} else {
		ut_ad(lock_get_type(lock) & LOCK_TABLE);

		lock_table_print(file, lock);
	}

	load_page_first = TRUE;

	nth_lock++;

	if (nth_lock >= 10) {
		fputs("10 LOCKS PRINTED FOR THIS TRX:"
		      " SUPPRESSING FURTHER PRINTS\n",
		      file);

		nth_trx++;
		nth_lock = 0;

		goto loop;
	}

	goto loop;
}
```


Overlapping Code:
```
k_print_info_all_transactions(
/*=============================*/
FILE* file) /* in: file where to print */
{
lock_t* lock;
ulint space;
ulint page_no;
ibool load_page_first = TRUE;
ulint nth_trx = 0;
ulint nth_lock = 0;
ulint i;
mtr_t mtr;
trx_t* trx;
fprintf(file, "LIST OF TRANSACTIONS FOR EACH SESSION:\n");
/* First print info on non-active transactions */
trx = UT_LIST_GET_FIRST(trx_sys->mysql_trx_list);
while (trx) {
if (trx->conc_state == TRX_NOT_STARTED) {
fputs("---", file);
trx_print(file, trx, 600);
}
trx = UT_LIST_GET_NEXT(mysql_trx_list, trx);
}
loop:
trx = UT_LIST_GET_FIRST(trx_sys->trx_list);
i = 0;
/* Since we temporarily release the kernel mutex when
reading a database page in below, variable trx may be
obsolete now and we must loop through the trx list to
get probably the same trx, or some other trx. */
while (trx && (i < nth_trx)) {
trx = UT_LIST_GET_NEXT(trx_list, trx);
i++;
}
if (trx == NULL) {
lock_mutex_exit_kernel();
ut_ad(lock_validate());
return;
}
if (nth_lock == 0) {
fputs("---", file);
trx_print(file, trx, 600);
if (trx->read_view) {
fprintf(file,
"Trx read view will not see trx with"
" id >= %lu %lu, sees < %lu %lu\n",
(ulong) ut_dulint_get_high(
trx->read_view->low_limit_id),
(ulong) ut_dulint_get_low(
trx->read_view->low_limit_id),
(ulong) ut_dulint_get_high(
trx->read_view->up_limit_id),
(ulong) ut_dulint_get_low(
trx->read_view->up_limit_id));
}
if (trx->que_state == TRX_QUE_LOCK_WAIT) {
fprintf(file,
"------- TRX HAS BEEN WAITING %lu SEC"
" FOR THIS LOCK TO BE GRANTED:\n",
(ulong) difftime(time(NULL),
trx->wait_started));
if (lock_get_type(trx->wait_lock) == LOCK_REC) {
lock_rec_print(file, trx->wait_lock);
} else {
lock_table_print(file, trx->wait_lock);
}
fputs("------------------\n", file);
}
}
if (!srv_print_innodb_lock_monitor) {
nth_trx++;
goto loop;
}
i = 0;
/* Look at the note about the trx loop above why we loop here:
lock may be an obsolete pointer now. */
lock = UT_LIST_GET_FIRST(trx->trx_locks);
while (lock && (i < nth_lock)) {
lock = UT_LIST_GET_NEXT(trx_locks, lock);
i++;
}
if (lock == NULL) {
nth_trx++;
nth_lock = 0;
goto loop;
}
if (lock_get_type(lock) == LOCK_REC) {
space = lock->un_member.rec_lock.space;
page_no = lock->un_member.rec_lock.page_no;
if (load_page_firs
```
<Overlap Ratio: 0.9855769230769231>

---

--- 369 --
Question ID: 4a6c8d33098885c2ff9e2850533b9e7f5c5dd79f_0
Original Code:
```
void log_message(char *str, unsigned short len)
{
	char * str_ptr = str;

//	if(!sys_setting.enable_log)
//		return;
	if(len == 0)
		return;

	while(len){
		uart0_writeb(*str_ptr);
		len--;
		str_ptr++;
	}
}
```


Overlapping Code:
```
 short len)
{
char * str_ptr = str;
// if(!sys_setting.enable_log)
// return;
if(len == 0)
return;
while(len){
uart0_writeb(*str_ptr);
len--;
str_ptr+
```
<Overlap Ratio: 0.78125>

---

--- 370 --
Question ID: e316a1cf5487932214030b9a7927749c6c40b286_3
Original Code:
```
int doreader(key, type, child)
int type, child;
long key;
{
	int i, size;
	int id;

	if ((id = msgget(key, 0)) < 0) {
		tst_resm(TFAIL|TERRNO,
			 "Msgget error in reader of child group %d",
			 child);
		tst_exit();
	}
	if (id != tid) {
		tst_resm(TFAIL,
			 "Message queue mismatch in reader of child group %d for message queue id %d",
			 child, id);
		tst_exit();
	}
	for (i = 0; i < nreps; i++) {
		if ((size = msgrcv(id, &buffer, 100, type, 0)) < 0) {
			tst_resm(TFAIL|TERRNO,
				 "Msgrcv error in child %d, read # = %d",
				 (i + 1), child);
			tst_exit();
		}
		if (buffer.type != type) {
			tst_resm(TFAIL,
				 "Size mismatch in child %d, read # = %d",
				 child, (i + 1));
			tst_resm(TFAIL,
				 "\tfor message size got  %d expected  %d",
				 size, buffer.data.len);
			tst_exit();
		}
		if (buffer.data.len + 1 != size) {
			tst_resm(TFAIL,
				 "Size mismatch in child %d, read # = %d, size = %d, expected = %d",
				 child, (i + 1), buffer.data.len, size);
			tst_exit();
		}
		if (verify(buffer.data.pbytes, (key % 255), size - 1, child)) {
			tst_resm(TFAIL, "in child %d read # = %d,key =  %lx",
				 child, (i + 1), key);
			tst_exit();
		}
		key++;
	}
	exit(PASS);
}
```


Overlapping Code:
```
 type, child)
int type, child;
long key;
{
int i, size;
int id;
if ((id = msgget(key, 0)) < 0) {
tst_resm(TFAIL|TERRNO,
"Msgget error in reader of child group %d",
child);
tst_exit();
}
if (id != tid) {
tst_resm(TFAIL,
"Message queue mismatch in reader of child group %d for message queue id %d",
child, id);
tst_exit();
}
for (i = 0; i < nreps; i++) {
if ((size = msgrcv(id, &buffer, 100, type, 0)) < 0) {
tst_resm(TFAIL|TERRNO,
"Msgrcv error in child %d, read # = %d",
(i + 1), child);
tst_exit();
}
if (buffer.type != type) {
tst_resm(TFAIL,
"Size mismatch in child %d, read # = %d",
child, (i + 1));
tst_resm(TFAIL,
"\tfor message size got %d expected %d",
size, buffer.data.len);
tst_exit();
}
if (buffer.data.len + 1 != size) {
tst_resm(TFAIL,
"Size mismatch in child %d, read # = %d, size = %d, expected = %d",
child, (i + 1), buffer.data.len, size);
tst_exit();
}
if (verify(buffer.data.pbytes, (key % 255), size - 1, child)) {
tst_resm(TFAIL, "in child %d read # = %d,key = %lx",
child, (i +
```
<Overlap Ratio: 0.9398496240601504>

---

--- 371 --
Question ID: a447a2173efd236064b5c4d21b56e7dd735a0061_11
Original Code:
```
INLINE void set_sl_rr(FM_SLOT *SLOT,int v,signed int *dr_table)
{
    SLOT->SL = SL_TABLE[(v>>4)];
    SLOT->RR = &dr_table[((v&0x0f)<<2)|2];
    SLOT->evsr = SLOT->RR[SLOT->ksr];
    if( SLOT->evm == ENV_MOD_RR ) SLOT->evs = SLOT->evsr;
}
```


Overlapping Code:
```
NLINE void set_sl_rr(FM_SLOT *SLOT,int v,signed int *dr_table)
{
SLOT->SL = SL_TABLE[(v>>4)];
SLOT->RR = &dr_table[((v&0x0f)<<2)|2];
SLOT->evsr = SLOT->RR[SLOT->ksr];
if( SLOT->evm == ENV_MOD_RR ) SLO
```
<Overlap Ratio: 0.8968609865470852>

---

--- 372 --
Question ID: 82da462cdb51d2e69937533700f2cac5690b487f_9
Original Code:
```
TEST(uper_c_source_d_all_present)
{
    uint8_t encoded[10];
    struct uper_c_source_d_t decoded;

    /* Encode. */
    decoded.length = 1;
    decoded.elements[0].a.b.choice = uper_c_source_d_a_b_choice_c_e;
    decoded.elements[0].a.b.value.c = 0;
    decoded.elements[0].a.e.length = 3;
    decoded.elements[0].g.h = uper_c_source_d_g_h_j_e;
    decoded.elements[0].g.l.length = 2;
    decoded.elements[0].g.l.buf[0] = 0x54;
    decoded.elements[0].g.l.buf[1] = 0x55;
    decoded.elements[0].m.is_n_present = true;
    decoded.elements[0].m.n = false;
    decoded.elements[0].m.o = 2;
    decoded.elements[0].m.is_p_present = true;
    memset(&decoded.elements[0].m.p.q.buf[0],
           3,
           sizeof(decoded.elements[0].m.p.q.buf));
    decoded.elements[0].m.p.is_r_present = true;
    decoded.elements[0].m.p.r = true;
    decoded.elements[0].m.s = true;

    ASSERT_EQ(uper_c_source_d_encode(&encoded[0],
                                     sizeof(encoded),
                                     &decoded), sizeof(encoded));
    ASSERT_MEMORY_EQ(&encoded[0],
                     "\x00\xaa\x2a\xfa\x40\xc0\xc0\xc0\xc0\xf0",
                     sizeof(encoded));

    /* Decode. */
    memset(&decoded, 0, sizeof(decoded));
    ASSERT_EQ(uper_c_source_d_decode(&decoded,
                                     &encoded[0],
                                     sizeof(encoded)), sizeof(encoded));

    ASSERT_EQ(decoded.length, 1);
    ASSERT_EQ(decoded.elements[0].a.b.choice, uper_c_source_d_a_b_choice_c_e);
    ASSERT_EQ(decoded.elements[0].a.b.value.c, 0);
    ASSERT_EQ(decoded.elements[0].a.e.length, 3);
    ASSERT_EQ(decoded.elements[0].g.h, uper_c_source_d_g_h_j_e);
    ASSERT_EQ(decoded.elements[0].g.l.length, 2);
    ASSERT_EQ(decoded.elements[0].g.l.buf[0], 0x54);
    ASSERT_EQ(decoded.elements[0].g.l.buf[1], 0x55);
    ASSERT_TRUE(decoded.elements[0].m.is_n_present);
    ASSERT_EQ(decoded.elements[0].m.n, false);
    ASSERT_EQ(decoded.elements[0].m.o, 2);
    ASSERT_TRUE(decoded.elements[0].m.is_p_present);
    ASSERT_MEMORY_EQ(&decoded.elements[0].m.p.q.buf[0],
                     "\x03\x03\x03\x03\x03",
                     sizeof(decoded.elements[0].m.p.q.buf));
    ASSERT_TRUE(decoded.elements[0].m.p.is_r_present);
    ASSERT_EQ(decoded.elements[0].m.p.r, true);
    ASSERT_EQ(decoded.elements[0].m.s, true);
}
```


Overlapping Code:
```
T(uper_c_source_d_all_present)
{
uint8_t encoded[10];
struct uper_c_source_d_t decoded;
/* Encode. */
decoded.length = 1;
decoded.elements[0].a.b.choice = uper_c_source_d_a_b_choice_c_e;
decoded.elements[0].a.b.value.c = 0;
decoded.elements[0].a.e.length = 3;
decoded.elements[0].g.h = uper_c_source_d_g_h_j_e;
decoded.elements[0].g.l.length = 2;
decoded.elements[0].g.l.buf[0] = 0x54;
decoded.elements[0].g.l.buf[1] = 0x55;
decoded.elements[0].m.is_n_present = true;
decoded.elements[0].m.n = false;
decoded.elements[0].m.o = 2;
decoded.elements[0].m.is_p_present = true;
memset(&decoded.elements[0].m.p.q.buf[0],
3,
sizeof(decoded.elements[0].m.p.q.buf));
decoded.elements[0].m.p.is_r_present = true;
decoded.elements[0].m.p.r = true;
decoded.elements[0].m.s = true;
ASSERT_EQ(uper_c_source_d_encode(&encoded[0],
sizeof(encoded),
&decoded), sizeof(encoded));
ASSERT_MEMORY_EQ(&encoded[0],
"\x00\xaa\x2a\xfa\x40\xc0\xc0\xc0\xc0\xf0",
sizeof(encoded));
/* Decode. */
memset(&decoded, 0, sizeof(decoded));
ASSERT_EQ(uper_c_source_d_decode(&decoded,
&encoded[0],
sizeof(encoded)), sizeof(encoded));
ASSERT_EQ(decoded.length, 1);
ASSERT_EQ(decoded.elements[0].a.b.choice, uper_c_source_d_a_b_choice_c_e);
ASSERT_EQ(decoded.elements[0].a.b.value.c, 0);
ASSERT_EQ(decoded.elements[0].a.e.length, 3);
ASSERT_EQ(decoded.elements[0].g.h, uper_c_source_d_g_h_j_e);
ASSERT_EQ(decoded.elements[0].g.l.length, 2);
ASSERT_EQ(decoded.elements[0].g.l.buf[0], 0x54);
ASSERT_EQ(decoded.elements[0].g.l.buf[1], 0x55);
ASSERT_TRUE(decoded.elements[0].m.is_n_present);
ASSERT_EQ(decoded.elements[0].m.n, false);
ASSERT_EQ(decoded.elements[0].m.o, 2);
ASSERT_TRUE(decoded.elements[0].m.is_p_present);
ASSERT_MEMORY_EQ(&decoded.elements[0].m.p.q.buf[0],
"\x03\x03\x03\x03\x03",
sizeof(decoded.elements[0].m.p.q.buf));
ASSERT_TRUE(decoded.elements[0].m.p.is_r_present);
ASSERT_EQ(decoded.elements[0].m.p.r, true);
ASSERT_EQ(decoded.e
```
<Overlap Ratio: 0.986060918946825>

---

--- 373 --
Question ID: 7bd53967a04c9edc4a72d0f06521b5cef7e321ae_0
Original Code:
```
void
SetNetTrace (register char *file)
{
  if (NetTrace && NetTrace != stdout)
    fclose (NetTrace);
  if (file && (strcmp (file, "-") != 0))
    {
      NetTrace = fopen (file, "w");
      if (NetTrace)
	{
	  strncpy ((char *) NetTraceFile, file, sizeof (NetTraceFile));
	  NetTraceFile[sizeof (NetTraceFile) - 1] = 0;
	  return;
	}
      fprintf (stderr, "Cannot open %s.\n", file);
    }
  NetTrace = stdout;
  strcpy ((char *) NetTraceFile, "(standard output)");
}
```


Overlapping Code:
```

SetNetTrace (register char *file)
{
if (NetTrace && NetTrace != stdout)
fclose (NetTrace);
if (file && (strcmp (file, "-") != 0))
{
NetTrace = fopen (file, "w");
if (NetTrace)
{
strncpy ((char *) NetTraceFile, file, sizeof (NetTraceFile));
NetTraceFile[sizeof (NetTraceFile) - 1] = 0;
return;
}
fprintf (stderr, "Cannot open %s.\n", file);
}
NetTrace = stdout;
strcpy ((char *) NetTraceFile, "(stand
```
<Overlap Ratio: 0.9523809523809523>

---

--- 374 --
Question ID: d59b4d153dd3a9335d2e865174ebfae325960992_16
Original Code:
```
decl *decl_impl(decl *const d, enum decl_impl_flags flags)
{
	decl *i;

	assert(type_is(d->ref, type_func));

	for(i = d; i; i = i->proto)
		if(i->bits.func.code)
			return i;

	for(i = d; i; i = i->impl)
		if(i->bits.func.code)
			return i;

	if(flags & DECL_INCLUDE_ALIAS){
		decl *alias = decl_alias(d, d);

		if(type_is(alias->ref, type_func) && alias->bits.func.code)
			return alias;
	}

	return d;
}
```


Overlapping Code:
```
decl *const d, enum decl_impl_flags flags)
{
decl *i;
assert(type_is(d->ref, type_func));
for(i = d; i; i = i->proto)
if(i->bits.func.code)
return i;
for(i = d; i; i = i->impl)
if(i->bits.func.code)
return i;
if(flags & DECL_INCLUDE_ALIAS){
decl *alias = decl_alias(d, d);
if(type_is(alias->ref, type_func) && alias->bits.func.code)
```
<Overlap Ratio: 0.8829787234042553>

---

--- 375 --
Question ID: 914a5204fa270f692f4b80ed641d7c4f9d9011e3_1
Original Code:
```
int __sem_down_timed(semaphore_t* sem, char* file, int line, u32 timeout) {
    sem_down_timed_called++;
    last_timeout = timeout;
    return 0;
}
```


Overlapping Code:
```
 __sem_down_timed(semaphore_t* sem, char* file, int line, u32 timeout) {
sem_down_timed_called++;
last_
```
<Overlap Ratio: 0.7573529411764706>

---

--- 376 --
Question ID: 2bef69f6ec53d10418a5d563db3ae021677cfd94_5
Original Code:
```
void init() {
  nextid = 1;
  bids = new_list();
  asks = new_list();
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 377 --
Question ID: 7248c8f9ee3c68eea49963a9eb7771caf2ff98e8_2
Original Code:
```
static void node_composit_exec_dilateerode(void *UNUSED(data), bNode *node, bNodeStack **in, bNodeStack **out)
{
	/* stack order in: mask */
	/* stack order out: mask */
	if(out[0]->hasoutput==0) 
		return;
	
	/* input no image? then only color operation */
	if(in[0]->data==NULL) {
		out[0]->vec[0] = out[0]->vec[1] = out[0]->vec[2] = 0.0f;
		out[0]->vec[3] = 0.0f;
	}
	else {
		/* make output size of input image */
		CompBuf *cbuf= typecheck_compbuf(in[0]->data, CB_VAL);
		CompBuf *stackbuf= dupalloc_compbuf(cbuf);
		short i;
		
		if (node->custom2 > 0) { // positive, dilate
			for (i = 0; i < node->custom2; i++)
				morpho_dilate(stackbuf);
		} else if (node->custom2 < 0) { // negative, erode
			for (i = 0; i > node->custom2; i--)
				morpho_erode(stackbuf);
		}
		
		if(cbuf!=in[0]->data)
			free_compbuf(cbuf);
		
		out[0]->data= stackbuf;
	}
}
```


Overlapping Code:
```
d node_composit_exec_dilateerode(void *UNUSED(data), bNode *node, bNodeStack **in, bNodeStack **out)
{
/* stack order in: mask */
/* stack order out: mask */
if(out[0]->hasoutput==0) 
return;

/* input no image? then only color operation */
if(in[0]->data==NULL) {
out[0]->vec[0] = out[0]->vec[1] = out[0]->vec[2] = 0.0f;
out[0]->vec[3] = 0.0f;
}
else {
/* make output size of input image */
CompBuf *cbuf= typecheck_compbuf(in[0]->data, CB_VAL);
CompBuf *stackbuf= dupalloc_compbuf(cbuf);
short i;

if (node->custom2 > 0) { // positive, dilate
for (i = 0; i < node->custom2; i++)
morpho_dilate(stackbuf);
} else if (node->custom2 < 0) { // negative, erode
for (i = 0; i > node->custom2; i--)
morpho_erode(stackbuf);
}

if(cbuf!=in[0]->data)
free_com
```
<Overlap Ratio: 0.9375>

---

--- 378 --
Question ID: 7e3aeb6df37db00265bec7e47a3f7331c0de9d87_15
Original Code:
```
DWORD
MemCacheClearExistingObjectKeys(
    IN PMEM_DB_CONNECTION pConn,
    IN PLSA_SECURITY_OBJECT pObject
    )
{
    DWORD dwError = 0;
    PSTR pszKey = NULL;
    PLW_DLINKED_LIST pListEntry = NULL;

    if (!LW_IS_NULL_OR_EMPTY_STR(pObject->pszDN))
    {
        dwError = MemCacheRemoveObjectByHashKey(
                        pConn,
                        pConn->pDNToSecurityObject,
                        pObject->pszDN);
        BAIL_ON_LSA_ERROR(dwError);
    }

    dwError = LwAllocateStringPrintf(
                    &pszKey,
                    "%s\\%s",
                    pObject->pszNetbiosDomainName ?
                        pObject->pszNetbiosDomainName : "",
                    pObject->pszSamAccountName ?
                        pObject->pszSamAccountName : "");
    BAIL_ON_LSA_ERROR(dwError);

    dwError = MemCacheRemoveObjectByHashKey(
                    pConn,
                    pConn->pNT4ToSecurityObject,
                    pszKey);
    BAIL_ON_LSA_ERROR(dwError);

    dwError = MemCacheRemoveObjectByHashKey(
                    pConn,
                    pConn->pSIDToSecurityObject,
                    pObject->pszObjectSid);
    BAIL_ON_LSA_ERROR(dwError);

    if (pObject->type == LSA_OBJECT_TYPE_USER)
    {
        if (pObject->enabled)
        {
            dwError = LwHashGetValue(
                            pConn->pUIDToSecurityObject,
                            (PVOID)(size_t)pObject->userInfo.uid,
                            (PVOID*)&pListEntry);
            if (dwError == ERROR_NOT_FOUND)
            {
                // The key does not exist
                dwError = 0;
            }
            else
            {
                char oldTimeBuf[128] = { 0 };
                char newTimeBuf[128] = { 0 };
                struct tm oldTmBuf = { 0 };
                struct tm newTmBuf = { 0 };
                PLSA_SECURITY_OBJECT pDuplicateObject = NULL;

                BAIL_ON_LSA_ERROR(dwError);

                pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;
                localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);
                localtime_r(&pObject->version.tLastUpdated, &newTmBuf);
                strftime(
                        oldTimeBuf,
                        sizeof(oldTimeBuf),
                        "%Y/%m/%d %H:%M:%S",
                        &oldTmBuf);
                strftime(
                        newTimeBuf,
                        sizeof(newTimeBuf),
                        "%Y/%m/%d %H:%M:%S",
                        &newTmBuf);

                LSA_LOG_ERROR("Conflict discovered for UID %d. User %s\\%s had this UID at time %s, but now (%s) user %s\\%s has the UID. Please check that these users are not currently conflicting in Active Directory. This could also happen (safely) if the UIDs were swapped between these users.",
                            (int)pObject->userInfo.uid,
                            LSA_SAFE_LOG_STRING(
                                pDuplicateObject->pszNetbiosDomainName),
                            LSA_SAFE_LOG_STRING(
                                pDuplicateObject->pszSamAccountName),
                            oldTimeBuf,
                            newTimeBuf,
                            LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),
                            LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));
                LsaSrvLogUserIDConflictEvent(
                    (int)pObject->userInfo.uid,
                    gpszADProviderName,
                    LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);

            }

            dwError = MemCacheRemoveObjectByHashKey(
                            pConn,
                            pConn->pUIDToSecurityObject,
                            (PVOID)(size_t)pObject->userInfo.uid);
            BAIL_ON_LSA_ERROR(dwError);

            dwError = MemCacheRemoveObjectByHashKey(
                            pConn,
                            pConn->pUserAliasToSecurityObject,
                            pObject->userInfo.pszAliasName);
            BAIL_ON_LSA_ERROR(dwError);
        }

        dwError = MemCacheRemoveObjectByHashKey(
                        pConn,
                        pConn->pUPNToSecurityObject,
                        pObject->userInfo.pszUPN);
        BAIL_ON_LSA_ERROR(dwError);
    }
    else if (pObject->enabled && pObject->type == LSA_OBJECT_TYPE_GROUP)
    {
        dwError = LwHashGetValue(
                        pConn->pGIDToSecurityObject,
                        (PVOID)(size_t)pObject->groupInfo.gid,
                        (PVOID*)&pListEntry);
        if (dwError == ERROR_NOT_FOUND)
        {
            // The key does not exist
            dwError = 0;
        }
        else
        {
            char oldTimeBuf[128] = { 0 };
            char newTimeBuf[128] = { 0 };
            struct tm oldTmBuf = { 0 };
            struct tm newTmBuf = { 0 };
            PLSA_SECURITY_OBJECT pDuplicateObject = NULL;

            BAIL_ON_LSA_ERROR(dwError);

            pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;
            localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);
            localtime_r(&pObject->version.tLastUpdated, &newTmBuf);
            strftime(
                    oldTimeBuf,
                    sizeof(oldTimeBuf),
                    "%Y/%m/%d %H:%M:%S",
                    &oldTmBuf);
            strftime(
                    newTimeBuf,
                    sizeof(newTimeBuf),
                    "%Y/%m/%d %H:%M:%S",
                    &newTmBuf);

            LSA_LOG_ERROR("Conflict discovered for GID %d. Group %s\\%s had this GID at time %s, but now (%s) group %s\\%s has the GID. Please check that these groups are not currently conflicting in Active Directory. This could also happen (safely) if the GIDs were swapped between these groups.",
                        (int)pObject->groupInfo.gid,
                        LSA_SAFE_LOG_STRING(
                            pDuplicateObject->pszNetbiosDomainName),
                        LSA_SAFE_LOG_STRING(
                            pDuplicateObject->pszSamAccountName),
                        oldTimeBuf,
                        newTimeBuf,
                        LSA_SAFE_LOG_STRING(pObject->pszNetbiosDomainName),
                        LSA_SAFE_LOG_STRING(pObject->pszSamAccountName));
            LsaSrvLogUserGIDConflictEvent(
                (int)pObject->userInfo.gid,
                gpszADProviderName,
                LSASS_EVENT_WARNING_CONFIGURATION_ID_CONFLICT);
        }
        dwError = MemCacheRemoveObjectByHashKey(
                        pConn,
                        pConn->pGIDToSecurityObject,
                        (PVOID)(size_t)pObject->groupInfo.gid);
        BAIL_ON_LSA_ERROR(dwError);

        dwError = MemCacheRemoveObjectByHashKey(
                        pConn,
                        pConn->pGroupAliasToSecurityObject,
                        pObject->groupInfo.pszAliasName);
        BAIL_ON_LSA_ERROR(dwError);
    }

cleanup:
    LW_SAFE_FREE_STRING(pszKey);
    return dwError;

error:
    goto cleanup;
}
```


Overlapping Code:
```
bjectKeys(
IN PMEM_DB_CONNECTION pConn,
IN PLSA_SECURITY_OBJECT pObject
)
{
DWORD dwError = 0;
PSTR pszKey = NULL;
PLW_DLINKED_LIST pListEntry = NULL;
if (!LW_IS_NULL_OR_EMPTY_STR(pObject->pszDN))
{
dwError = MemCacheRemoveObjectByHashKey(
pConn,
pConn->pDNToSecurityObject,
pObject->pszDN);
BAIL_ON_LSA_ERROR(dwError);
}
dwError = LwAllocateStringPrintf(
&pszKey,
"%s\\%s",
pObject->pszNetbiosDomainName ?
pObject->pszNetbiosDomainName : "",
pObject->pszSamAccountName ?
pObject->pszSamAccountName : "");
BAIL_ON_LSA_ERROR(dwError);
dwError = MemCacheRemoveObjectByHashKey(
pConn,
pConn->pNT4ToSecurityObject,
pszKey);
BAIL_ON_LSA_ERROR(dwError);
dwError = MemCacheRemoveObjectByHashKey(
pConn,
pConn->pSIDToSecurityObject,
pObject->pszObjectSid);
BAIL_ON_LSA_ERROR(dwError);
if (pObject->type == LSA_OBJECT_TYPE_USER)
{
if (pObject->enabled)
{
dwError = LwHashGetValue(
pConn->pUIDToSecurityObject,
(PVOID)(size_t)pObject->userInfo.uid,
(PVOID*)&pListEntry);
if (dwError == ERROR_NOT_FOUND)
{
// The key does not exist
dwError = 0;
}
else
{
char oldTimeBuf[128] = { 0 };
char newTimeBuf[128] = { 0 };
struct tm oldTmBuf = { 0 };
struct tm newTmBuf = { 0 };
PLSA_SECURITY_OBJECT pDuplicateObject = NULL;
BAIL_ON_LSA_ERROR(dwError);
pDuplicateObject = (PLSA_SECURITY_OBJECT)pListEntry->pItem;
localtime_r(&pDuplicateObject->version.tLastUpdated, &oldTmBuf);
localtime_r(&pObject->version.tLastUpdated, &newTmBuf);
strftime(
oldTimeBuf,
sizeof(oldTimeBuf),
"%Y/%m/%d %H:%M:%S",
&oldTmBuf);
strftime(
n
```
<Overlap Ratio: 0.962772785622593>

---

--- 379 --
Question ID: d6979e11a67b2b1f73feeb3bbda5394d6dd66827_12
Original Code:
```
int sun4i_csi_dma_register(struct sun4i_csi *csi, int irq)
{
	struct vb2_queue *q = &csi->queue;
	int ret;
	int i;

	spin_lock_init(&csi->qlock);
	mutex_init(&csi->lock);

	INIT_LIST_HEAD(&csi->buf_list);
	for (i = 0; i < CSI_MAX_BUFFER; i++)
		csi->current_buf[i] = NULL;

	q->min_buffers_needed = 3;
	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
	q->io_modes = VB2_MMAP;
	q->lock = &csi->lock;
	q->drv_priv = csi;
	q->buf_struct_size = sizeof(struct sun4i_csi_buffer);
	q->ops = &sun4i_csi_qops;
	q->mem_ops = &vb2_dma_contig_memops;
	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
	q->dev = csi->dev;

	ret = vb2_queue_init(q);
	if (ret < 0) {
		dev_err(csi->dev, "failed to initialize VB2 queue\n");
		goto err_free_mutex;
	}

	ret = v4l2_device_register(csi->dev, &csi->v4l);
	if (ret) {
		dev_err(csi->dev, "Couldn't register the v4l2 device\n");
		goto err_free_queue;
	}

	ret = devm_request_irq(csi->dev, irq, sun4i_csi_irq, 0,
			       dev_name(csi->dev), csi);
	if (ret) {
		dev_err(csi->dev, "Couldn't register our interrupt\n");
		goto err_unregister_device;
	}

	return 0;

err_unregister_device:
	v4l2_device_unregister(&csi->v4l);

err_free_queue:
	vb2_queue_release(q);

err_free_mutex:
	mutex_destroy(&csi->lock);
	return ret;
}
```


Overlapping Code:
```
sun4i_csi *csi, int irq)
{
struct vb2_queue *q = &csi->queue;
int ret;
int i;
spin_lock_init(&csi->qlock);
mutex_init(&csi->lock);
INIT_LIST_HEAD(&csi->buf_list);
for (i = 0; i < CSI_MAX_BUFFER; i++)
csi->current_buf[i] = NULL;
q->min_buffers_needed = 3;
q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
q->io_modes = VB2_MMAP;
q->lock = &csi->lock;
q->drv_priv = csi;
q->buf_struct_size = sizeof(struct sun4i_csi_buffer);
q->ops = &sun4i_csi_qops;
q->mem_ops = &vb2_dma_contig_memops;
q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
q->dev = csi->dev;
ret = vb2_queue_init(q);
if (ret < 0) {
dev_err(csi->dev, "failed to initialize VB2 queue\n");
goto err_free_mutex;
}
ret = v4l2_device_register(csi->dev, &csi->v4l);
if (ret) {
dev_err(csi->dev, "Couldn't register the v4l2 device\n");
goto err_free_queue;
}
ret = devm_request_irq(csi->dev, irq, sun4i_csi_irq, 0,
dev_name(csi->dev), csi);
if (ret) {
dev_err(csi->dev, "Couldn't register our interrupt\n");
goto err_unregister_device;
}
return 0;
err_unregister_device:
v4l2_device_unregister(&csi->v4l);
err_free_queue:
vb2_queue_release(q);
err_free_mutex:
mutex_destroy(&csi->lock);
retur
```
<Overlap Ratio: 0.964765100671141>

---

--- 380 --
Question ID: 4631b1d39bb41beaf01fccdd9655a57304ee9323_3
Original Code:
```
void intel_mid_msgbus_write32_raw(u32 cmd, u32 data)
{
	unsigned long irq_flags;

	spin_lock_irqsave(&msgbus_lock, irq_flags);
	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
	pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
	spin_unlock_irqrestore(&msgbus_lock, irq_flags);
}
```


Overlapping Code:
```
gbus_write32_raw(u32 cmd, u32 data)
{
unsigned long irq_flags;
spin_lock_irqsave(&msgbus_lock, irq_flags);
pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_DATA_REG, data);
pci_write_config_dword(pci_root, PCI_ROOT_MSGBUS_CTRL_REG, cmd);
spin_unlock_irqrestore(&msgb
```
<Overlap Ratio: 0.8721311475409836>

---

--- 381 --
Question ID: f7a94fe582b2e0450878ee787e2f298247757661_2
Original Code:
```
static void vnode_server_delclient(vnode_cliententry_t *client)
{
#ifdef DEBUG
  WARNX("deleting client for fds %d %d", client->clientfd, client->msgio.fd);
#endif

  TAILQ_REMOVE(&client->server->clientlisthead, client, entries);
  vnode_msgiostop(&client->msgio);
  close(client->clientfd);
  memset(client, 0, sizeof(*client));
  free(client);

  return;
}
```


Overlapping Code:
```
ntry_t *client)
{
#ifdef DEBUG
WARNX("deleting client for fds %d %d", client->clientfd, client->msgio.fd);
#endif
TAILQ_REMOVE(&client->server->clientlisthead, client, entries);
vnode_msgiostop(&client->msgio);
close(client->clientfd);
memset(client,
```
<Overlap Ratio: 0.7288629737609329>

---

--- 382 --
Question ID: ca8b23f8c525e7b0c1f510ca8f647d607f537b12_2
Original Code:
```
static void mmp_sspa_rx_enable(struct ssp_device *sspa)
{
	unsigned int sspa_sp;

	sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
	sspa_sp |= SSPA_SP_S_EN;
	sspa_sp |= SSPA_SP_WEN;
	mmp_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
}
```


Overlapping Code:
```
d mmp_sspa_rx_enable(struct ssp_device *sspa)
{
unsigned int sspa_sp;
sspa_sp = mmp_sspa_read_reg(sspa, SSPA_RXSP);
sspa_sp |= SSPA_SP_S_EN;
sspa_sp |= SSPA_SP_WEN;
mmp_sspa_write_reg(sspa, SSPA_RXSP,
```
<Overlap Ratio: 0.9009009009009009>

---

--- 383 --
Question ID: fa9582e015dba7bedaff9ad6ce18dc7539a4d376_3
Original Code:
```
int hweight64(uint64_t w)
{
	w = w - ((w >> 1) & 0x5555555555555555ull);
	w = (w & 0x3333333333333333ull) + ((w >> 2) & 0x3333333333333333ull);
	w = (w + (w >> 4)) & 0x0F0F0F0F0F0F0F0Full;
	w = (w + (w >> 8));
	w = (w + (w >> 16));
	return (w + (w >> 32)) & 0x00000000000000FFull;
}
```


Overlapping Code:
```
t hweight64(uint64_t w)
{
w = w - ((w >> 1) & 0x5555555555555555ull);
w = (w & 0x3333333333333333ull) + ((w >> 2) & 0x3333333333333333ull);
w = (w + (w >> 4)) & 0x0F0F0F0F0F0F0F0Full;
w = (w + (w >> 8));
w = (w + (w >> 16));
return (w + (w >> 32)) & 
```
<Overlap Ratio: 0.9057971014492754>

---

