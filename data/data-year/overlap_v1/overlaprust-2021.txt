--- 0 --
Question ID: 81c6311b6b1edd46ffab1fc1e85edcf717111bd8_0
Original Code:
```
async fn it_returns_safe_illustrations() {
    common::setup();
    let client = PixivClient::new();

    for id in SAFE_ILLUSTRATION_IDS {
        let illustration = client.illustration(id).await.unwrap();
        assert_eq!(illustration.id, *id);
        assert!(illustration.title.len() > 0);
        assert!(illustration.tags.tags.len() > 0);
        assert_eq!(illustration.age_restrict, 0);
    }
}
```


Overlapping Code:
```
urns_safe_illustrations() {
common::setup();
let client = PixivClient::new();
for id in SAFE_ILLUSTRATION_IDS {
let illustration = client.illustration(id).await.unwrap();
assert_eq!(illustration.id, *id);
assert!(illustration.title.len() > 0);
assert!(illustration.tags.tags.len() > 0);
assert_eq!(il
```
<Overlap Ratio: 0.8645533141210374>

---

--- 1 --
Question ID: b372998d3f05bbefc82598963ffe98842b1da74b_0
Original Code:
```
fn round_trip_data() {
        let instance = TestCase::new_with_output(
            "foo",
            "bar",
            &TestResult::success(),
            Cow::Borrowed("standard output"),
            Cow::Borrowed("standard error"),
            Duration::milliseconds(123456789),
        );
        assert_eq!(instance.name(), "foo");
        assert_eq!(instance.class(), "bar");
        assert_eq!(instance.result(), &TestResult::success());
        assert_eq!(instance.stdout(), "standard output");
        assert_eq!(instance.stderr(), "standard error");
    }
```


Overlapping Code:
```
stCase::new_with_output(
"foo",
"bar",
&TestResult::success(),
Cow::Borrowed("standard output"),
Cow::Borrowed("standard error"),
Duration::milliseconds(123456789),
);
assert_eq!(instance.name(), "foo");
assert_eq!(instance.class(), "bar");
assert_eq!(instance.result(), &TestResult::success());
assert_eq!(instance.stdout(), "standard output");
asse
```
<Overlap Ratio: 0.8027522935779816>

---

--- 2 --
Question ID: 2d7445fb25ed1c4ffb9e3497149f409456199d89_0
Original Code:
```
pub fn handler(classes: &mut Classes, rl: &mut Editor<()>) -> bool {
    let mut will_write = true;
    let mut help = HashMap::<&str, (Option<&str>, &str, Option<&str>)>::new();

    println!();

    let late = classes.late();

    if late.len() > 0 {
        println!("You have some late assignments!\n\n{}\n", late.join("\n"));
    }

    help.insert("add", (Some("<class> <date> <name...>"), "Adds a dated assignment to a class.\n\nDates should be formatted as 'd-m-y'.\nExample: 31-1-2021", Some("a")));
    help.insert("all", (None, "Displays assignments across all classes.", None));
    help.insert("clean", (Some("<class>"), "Removes all completed assignments from a class.", None));
    help.insert("complete", (Some("<class> <index>"), "Moves an assignment to a class's completed list.", Some("c")));
    help.insert("create", (Some("<id> <period> <name...>"), "Creates a class with metadata.", None));
    help.insert("delete", (Some("<id>"), "Deletes a class, including all of its assignments.", None));
    help.insert("encode", (None, "Displays encoded class data.", None));
    help.insert("help", (Some("(<command>)"), "Displays help info for a command.\nIf no command is supplied, displays all commands.", Some("h")));
    help.insert("info", (Some("(<id>)"), "Displays class info and assignments.\nIf no ID is supplied, displays all class info.", Some("i")));
    help.insert("klog", (Some("<avg> (<path>)"), "Displays assignment data in klog format.\nThis is particularly useful for keeping track of\nassignments you've completed with date and time.\n\nThe 'avg' argument is how many hours on average\nyou'd expect to complete the assignments in.\nYou can modify these values after writing.\n\nOptionally specify a path to write to.\n'.klg' is automatically appended to the path.\n\nLearn more about klog at: https://klog.jotaen.net", None));
    help.insert("list", (Some("(<sort>)"), "Lists all classes by ID and name.\nYou can sort classes by id, name and period (default).", Some("ls, l")));
    help.insert("modify", (Some("<id> <property> <value...>"), "Modifies class metadata by input.\nClass ID cannot be modified.", Some("mod, m")));
    help.insert("panic", (None, "Prevents writing to config upon exiting the program.\nThis is useful if you've made an irreversible mistake while editing.", None));
    help.insert("quit", (None, "Exits the program.", Some("q")));
    help.insert("remove", (Some("<id> <index>"), "Removes an assignment without completing it.", Some("r")));
    help.insert("write", (None, "Writes encoded classes to the config file.\nThis is done automatically upon exit.", Some("w")));

    loop {
        match input(rl) {
            Some(args) => {
                //println!("{:#?}", args);
                match args.command.as_str() {
                    "add" | "a" => {
                        if args.check(3, true) {
                            match classes.get_class(&args) {
                                Ok(c) => {
                                    match Assignment::parse_date(args.list[1].as_str()) {
                                        Ok(d) => {
                                            c.add_assignment(args.input_from(2), d);
                                            println!("\n{}", c.display_info());
                                        }
                                        Err(e) => err(e)
                                    }
                                },
                                Err(e) => err(e)
                            }  
                        }
                    }
                    "all" => {
                        println!("\n{}", classes.display_all_combined());
                    }
                    "clean" => {
                        if args.check(1, true) {
                            match classes.get_class(&args) {
                                Ok(c) => {
                                    c.completed.clear();
                                    println!("\n{}", c.display_info());
                                },
                                Err(e) => err(e)
                            }
                        }
                    }
                    "complete" | "c" => {
                        if args.check(2, true) {
                            match classes.get_class(&args) {
                                Ok(c) => {
                                    match to_int(&args.list[1]) {
                                        Some(n) => {
                                            match c.complete_assignment(n) {
                                                Ok(_) => println!("\n{}", c.display_info()),
                                                Err(e) => err(e)
                                            }
                                        }
                                        None => ()
                                    }
                                },
                                Err(e) => err(e)
                            }  
                        }
                    }
                    "create" => {
                        if args.check(3, true) {
                            let id = args.list[0].to_lowercase();

                            if classes.map.contains_key(&id) {
                                err(format!("Class ID '{}' already exists", id));
                            } else {
                                match to_int(&args.list[1]) {
                                    Some(n) => {
                                        classes.add_class_data(id.clone(), args.input_from(2), n);
                                        success(format!("created class '{}'", id));
                                    }
                                    None => ()
                                }
                            }  
                        }
                    }
                    "delete" => {
                        if args.check(1, true) {
                            match classes.remove_class(&args.list[0]) {
                                Ok(c) => success(format!("deleted class '{}'", c.name)),
                                Err(e) => err(e)
                            }
                        }
                    }
                    "encode" => {
                        println!("\n{}", classes.encode());
                    }
                    "help" | "h" => {
                        if args.check(1, false) {
                            if help.contains_key(&args.list[0].as_str()) {
                                let data = help.get(&args.list[0].as_str()).unwrap();

                                let arg_str = match data.0 {
                                    Some(s) => String::from(s),
                                    None => String::new()
                                };

                                println!("\n{}\n\n{}{}",
                                    Class::str_property("Syntax", &format!("{} {}", args.list[0], arg_str)),
                                    
                                    data.1,

                                    if data.2.is_some() { 
                                        format!("\n\n{}", Class::str_property("Aliases", &data.2.unwrap().to_string())) 
                                    } else { 
                                        String::new()
                                    }
                                );
                            } else {
                                err(format!("Command '{}' not found", args.list[0]));
                            }
                        } else {
                            let mut sorted_keys = help.keys().collect::<Vec<&&str>>();

                            sorted_keys.sort();
                            
                            let lines = sorted_keys
                                .iter()
                                .map(|k| {
                                    let l = help.get(*k).unwrap().1.split("\n").collect::<Vec<&str>>()[0];
                                    Class::info_property(k, &l.to_string(), Green.bold())
                                })
                                .collect::<Vec<String>>();
                                
                            println!("\n{}", lines.join("\n"));
                        }
                    }
                    "info" | "i" => {
                        if args.check(1, false) {
                            match classes.get_class(&args) {
                                Ok(c) => println!("\n{}", c.display_info()),
                                Err(e) => err(e)
                            }
                        } else {
                            println!("\n{}", classes.display_all_info());
                        }
                    }
                    "klog" => {
                        if args.check(1, true) {
                            match to_int(&args.list[0]) {
                                Some(n) => {
                                    let data = classes.klog(n);
                                    
                                    if args.check(2, false) {
                                        let mut path = PathBuf::from(args.list[1].clone());
                                        path.set_extension("klg");

                                        classes.write(path, data);
                                    } else {
                                        println!("\n{}", data);
                                    }
                                }
                                None => ()
                            }
                        }
                    }
                    "list" | "ls" | "l" => {
                        use SortingMethod::*;

                        let by_period: Option<SortingMethod> = if args.check(1, false) {
                            match args.list[0].to_lowercase().as_str() {
                                "id" => Some(ID),
                                "name" => Some(Name),
                                "period" => Some(Period),
                                _ => None
                            }
                        } else { 
                            Some(Period)
                        };

                        match by_period {
                            Some(v) => println!("\n{}", classes.display_list(v)),
                            None => err(format!("Invalid sorting method '{}'", args.list[0]))
                        }
                    }
                    "modify" | "mod" | "m" => {
                        if args.check(3, true) {
                            match classes.get_class(&args) {
                                Ok(c) => {
                                    match c.modify(args.list[1].clone(), args.input_from(2)) {
                                        Ok(_) => success(format!("modified '{}'", c.name)),
                                        Err(e) => err(e)
                                    }
                                },
                                Err(e) => err(e)
                            }
                        }
                    }
                    "panic" => {
                        will_write = false;
                        success(String::from("prevented write on shutdown. None of the changes made during this session will be saved.\nTo view the encoded version of the changes you've made, run 'encode'."));
                    }
                    "quit" | "q" => {
                        print!("Exiting... ");
                        break;
                    }
                    "remove" | "r" => {
                        if args.check(2, true) {
                            match classes.get_class(&args) {
                                Ok(c) => {
                                    match to_int(&args.list[1]) {
                                        Some(n) => {
                                            match c.remove_assignment(n) {
                                                Ok(_) => println!("\n{}", c.display_info()),
                                                Err(e) => err(e)
                                            }
                                        }
                                        None => ()
                                    }
                                },
                                Err(e) => err(e)
                            }  
                        }
                    }
                    "write" | "w" => {
                        write_config(&classes);
                    }
                    _ => err(format!("Unrecognized command '{}'. Run 'help' for a list of commands.", args.command))
                }

                println!();
            }
            None => { 
                print!("Exiting... ");
                break;
            }
        }
    }

    will_write
}
```


Overlapping Code:
```
n handler(classes: &mut Classes, rl: &mut Editor<()>) -> bool {
let mut will_write = true;
let mut help = HashMap::<&str, (Option<&str>, &str, Option<&str>)>::new();
println!();
let late = classes.late();
if late.len() > 0 {
println!("You have some late assignments!\n\n{}\n", late.join("\n"));
}
help.insert("add", (Some("<class> <date> <name...>"), "Adds a dated assignment to a class.\n\nDates should be formatted as 'd-m-y'.\nExample: 31-1-2021", Some("a")));
help.insert("all", (None, "Displays assignments across all classes.", None));
help.insert("clean", (Some("<class>"), "Removes all completed assignments from a class.", None));
help.insert("complete", (Some("<class> <index>"), "Moves an assignment to a class's completed list.", Some("c")));
help.insert("create", (Some("<id> <period> <name...>"), "Creates a class with metadata.", None));
help.insert("delete", (Some("<id>"), "Deletes a class, including all of its assignments.", None));
help.insert("encode", (None, "Displays encoded class data.", None));
help.insert("help", (Some("(<command>)"), "Displays help info for a command.\nIf no command is supplied, displays all commands.", Some("h")));
help.insert("info", (Some("(<id>)"), "Displays class info and assignments.\nIf no ID is supplied, displays all class info.", Some("i")));
help.insert("klog", (Some("<avg> (<path>)"), "Displays assignment data in klog format.\nThis is particularly useful for keeping track of\nassignments you've completed with date and time.\n\nThe 'avg' argument is how many hours on average\nyou'd expect to complete the assignments in.\nYou can modify these values after writing.\n\nOptionally specify a path to write to.\n'.klg' is automatically appended to the path.\n\nLearn more about klog at: https://klog.jotaen.net", None));
help.insert("list", (Some("(<sort>)"), "Lists all classes by ID and name.\nYou can sort classes by id, name and period (default).", Some("ls, l")));
help.insert("modify", (Some("<id> <property> <value...>"), "Modifies class metadata by input.\nClass ID cannot be modified.", Some("mod, m")));
help.insert("panic", (None, "Prevents writing to config upon exiting the program.\nThis is useful if you've made an irreversible mistake while editing.", None));
help.insert("quit", (None, "Exits the program.", Some("q")));
help.insert("remove", (Some("<id> <index>"), "Remov
```
<Overlap Ratio: 0.9779442363712026>

---

--- 3 --
Question ID: da744eb06693d9613fa7caeb5923caa230ccc25f_0
Original Code:
```
fn main() -> Result<()> {
    //Dump {}.run()?;
    let opts = Opts::parse();

    let hid = hidapi::HidApi::new()?;
    let mut dev = GloriousDevice::open_first(&hid)?;
    dev.send_msg(0x02, 1)?;

    match opts.cmd {
        Command::Dump(dump) => dump.run(&mut dev),
        Command::Button(b) => b.run(&mut dev),
        Command::Rgb { rgbcmd } => rgbcmd.run(&mut dev),
        Command::Dpi(dpi) => dpi.run(&mut dev),
        Command::Macro(macro_) => macro_.run(&mut dev),
    }
}
```


Overlapping Code:
```
 {}.run()?;
let opts = Opts::parse();
let hid = hidapi::HidApi::new()?;
let mut dev = GloriousDevice::open_first(&hid)?;
dev.send_msg(0x02, 1)?;
match opts.cmd {
Command::Dump(dump) => dump.run(&mut dev),
Command::Button(b) => b.run(&mut dev),
Command::Rgb { rgbcmd } => rgbcmd.run(&mut dev),
Command::Dpi(dpi) => dpi.run(&mut dev),
Command::Macro(ma
```
<Overlap Ratio: 0.8413461538461539>

---

--- 4 --
Question ID: a95cf80310f651db51e693f6d74328b88baa4781_0
Original Code:
```
pub(crate) fn is_each_value_valid(date: &str) -> bool {

    let max_day_number = 31;
    let max_month_number = 12;
    let min_year_number = 1000;
    let max_year_number = 9999;


    let string_parts = date.split('-');

    if string_parts.count() != 3 { return false; }

    let string_parts = date.split('-');

    let mut count_numbers = 0;

    for part in string_parts {
        let parsed_value = part.parse::<u16>();

        if part.parse::<u16>().is_err() { return false; }
        
        count_numbers += 1;

        let value = parsed_value.unwrap();

        if count_numbers == 1 && value > max_day_number { return false; }
        if count_numbers == 2 && value > max_month_number { return false; }
        if count_numbers == 3 && (value < min_year_number || value > max_year_number) { return false; }
    }

    
    true
}
```


Overlapping Code:
```
str) -> bool {
let max_day_number = 31;
let max_month_number = 12;
let min_year_number = 1000;
let max_year_number = 9999;
let string_parts = date.split('-');
if string_parts.count() != 3 { return false; }
let string_parts = date.split('-');
let mut count_numbers = 0;
for part in string_parts {
let parsed_value = part.parse::<u16>();
if part.parse::<u16>().is_err() { return false; }

count_numbers += 1;
let value = parsed_value.unwrap();
if count_numbers == 1 && value > max_day_number { return false; }
if count_numbers == 2 && value > max_month_number { return false; }
if count_numbers == 3 && (value < min_year_number || value > max_year_numb
```
<Overlap Ratio: 0.9002770083102493>

---

--- 5 --
Question ID: 6ae9adfcdbb7b211818a1d238e9eec94778570c2_2
Original Code:
```
fn load_auth_provider(args: &clap::ArgMatches) -> Result<HeaderV4AuthorisationProvider, IoError> {
    let access_tokens = args.value_of("access_tokens").unwrap();
    let access_tokens = AccessToken::load_from(access_tokens)?;
    Ok(HeaderV4AuthorisationProvider::new(access_tokens))
}
```


Overlapping Code:
```
ches) -> Result<HeaderV4AuthorisationProvider, IoError> {
let access_tokens = args.value_of("access_tokens").unwrap();
let access_tokens = AccessToken::load_from(access_tokens)?;
Ok(HeaderV4Authorisat
```
<Overlap Ratio: 0.7272727272727273>

---

--- 6 --
Question ID: a3e3ffb5ec74feae6a7d14ee883823b7a182ebdb_0
Original Code:
```
pub fn path<'a>(
    network: &'a Network<Node>,
    a: &str,
    b: &str,
    algorithm: &dyn Fn(&Network<Node>, Node, Node) -> io::Result<Vec<Node>>,
) -> io::Result<Vec<Node>> {
    let opt_goal = network.get(b);
    let opt_start = network.get(a);
    if opt_goal.is_none() || opt_start.is_none() {
        Err(Error::new(
            ErrorKind::Other,
            "Start or Goal path does not exist in Network",
        ))
    } else {
        algorithm(&network, opt_start.unwrap(), opt_goal.unwrap())
    }
}
```


Overlapping Code:
```

network: &'a Network<Node>,
a: &str,
b: &str,
algorithm: &dyn Fn(&Network<Node>, Node, Node) -> io::Result<Vec<Node>>,
) -> io::Result<Vec<Node>> {
let opt_goal = network.get(b);
let opt_start = network.get(a);
if opt_goal.is_none() || opt_start.is_none() {
Err(Error::new(
ErrorKind::Other,
"Start or Goal path does not exist in Network",
))
} else {
algorithm(&network, opt_start.unwrap(), opt_goa
```
<Overlap Ratio: 0.9280742459396751>

---

--- 7 --
Question ID: 7797a8763e556064e5c587a9fe55e0102cd24eb2_0
Original Code:
```
async fn ws_index(
    req: HttpRequest,
    stream: web::Payload,
    data: Data<Mutex<AppState>>,
) -> Result<HttpResponse, Error> {
    let mut res = ws::handshake(&req)?;

    let (user, is_new) = req
        .cookie("session_id")
        .and_then(|cookie| Uuid::from_str(cookie.value()).ok())
        .and_then(|uuid| data.lock().unwrap().user_with_session_id(uuid.as_u128()))
        .map_or_else(
            /* no such user. create new */
            || (data.lock().unwrap().create_user(), true),
            /* existing user */
            |u| (u, false),
        );

    if is_new {
        println!(
            "User created with user id {} and session id {}",
            &user.id, &user.session_id
        );

        res.cookie(
            Cookie::build("session_id", &Uuid::from_u128(user.session_id).to_string())
                .http_only(true)
                .secure(false)
                .same_site(SameSite::Strict)
                .finish(),
        );
    }

    Ok(res.streaming(WebsocketContext::create(WebSocket::new(user, data), stream)))
}
```


Overlapping Code:
```
async fn ws_index(
req: HttpRequest,
stream: web::Payload,
data: Data<Mutex<AppState>>,
) -> Result<HttpResponse, Error> {
let mut res = ws::handshake(&req)?;
let (user, is_new) = req
.cookie("session_id")
.and_then(|cookie| Uuid::from_str(cookie.value()).ok())
.and_then(|uuid| data.lock().unwrap().user_with_session_id(uuid.as_u128()))
.map_or_else(
/* no such user. create new */
|| (data.lock().unwrap().create_user(), true),
/* existing user */
|u| (u, false),
);
if is_new {
println!(
"User created with user id {} and session id {}",
&user.id, &user.session_id
);
res.cookie(
Cookie::build("session_id", &Uuid::from_u128(user.session_id).to_string())
.http_only(true)
.secure(false)
.same_site(SameSite::Strict)
.finish(),
);
}
Ok(res.streaming(WebsocketContext::create(WebSocket::new(user, da
```
<Overlap Ratio: 0.9803921568627451>

---

--- 8 --
Question ID: 1854d6486215672df4496b4002b9967f22073a2b_4
Original Code:
```
fn test_md5() {
        assert_eq!(md5(b""), hex("d41d8cd98f00b204e9800998ecf8427e").unwrap());
        assert_eq!(md5(b"a"), hex("0cc175b9c0f1b6a831c399e269772661").unwrap());
        assert_eq!(
            md5(b"abc"),
            hex("900150983cd24fb0d6963f7d28e17f72").unwrap()
        );
        assert_eq!(
            md5(b"message digest"),
            hex("f96b697d7cb7938d525a2f31aaf161d0").unwrap()
        );
        assert_eq!(
            md5(b"abcdefghijklmnopqrstuvwxyz"),
            hex("c3fcd3d76192e4007dfb496cca67e13b").unwrap()
        );
        assert_eq!(
            md5(b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
            hex("d174ab98d277d9f5a5611c2c9f419d9f").unwrap()
        );
        assert_eq!(
            md5(b"12345678901234567890123456789012345678901\
                234567890123456789012345678901234567890"),
            hex("57edf4a22be3c955ac49da2e2107b67a").unwrap()
        );
    }
```


Overlapping Code:
```
_eq!(md5(b""), hex("d41d8cd98f00b204e9800998ecf8427e").unwrap());
assert_eq!(md5(b"a"), hex("0cc175b9c0f1b6a831c399e269772661").unwrap());
assert_eq!(
md5(b"abc"),
hex("900150983cd24fb0d6963f7d28e17f72").unwrap()
);
assert_eq!(
md5(b"message digest"),
hex("f96b697d7cb7938d525a2f31aaf161d0").unwrap()
);
assert_eq!(
md5(b"abcdefghijklmnopqrstuvwxyz"),
hex("c3fcd3d76192e4007dfb496cca67e13b").unwrap()
);
assert_eq!(
md5(b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"),
hex("d174ab98d277d9f5a5611c2c9f419d9f").unwrap()
);
assert_eq!(
md5(b"12345678901234567890123456789012345678901\
234567890123456789012345678901234567890"),
hex("5
```
<Overlap Ratio: 0.9040333796940194>

---

--- 9 --
Question ID: eaeb3416666044774f759822997b409f44227516_0
Original Code:
```
fn test_server() -> GameServer {
        // Address for player 0
        let channel: (
            channel::AddressSender<Websocket>,
            channel::AddressReceiver<Websocket>,
        ) = channel::channel(1024);
        let addr0 = Addr::new(channel.0);

        // Address for player 1
        let channel: (
            channel::AddressSender<Websocket>,
            channel::AddressReceiver<Websocket>,
        ) = channel::channel(1024);
        let addr1 = Addr::new(channel.0);

        let mut server = GameServer::new();

        server.clients.push(addr0);
        server.clients.push(addr1);

        server
    }
```


Overlapping Code:
```
meServer {
// Address for player 0
let channel: (
channel::AddressSender<Websocket>,
channel::AddressReceiver<Websocket>,
) = channel::channel(1024);
let addr0 = Addr::new(channel.0);
// Address for player 1
let channel: (
channel::AddressSender<Websocket>,
channel::AddressReceiver<Websocket>,
) = channel::channel(1024);
let addr1 = Addr::new(channel.0);
let mut server = GameServer::new();
server.clients.push(addr0);
server.clients.push(addr1);
s
```
<Overlap Ratio: 0.9394572025052192>

---

--- 10 --
Question ID: 7c6165af0d0a7f61daff2541209e362ada3c9073_7
Original Code:
```
fn parse_formals(formals: PoolPtr) -> Result<Formals, String> {
    let mut values = Vec::new();
    let mut formal = formals;
    loop {
        if let Some(dt) = get_define_target(formal) {
            return Ok(Formals {
                values,
                rest: Some(dt),
            });
        } else {
            match &*formal {
                Value::EmptyList => return Ok(Formals { values, rest: None }),
                Value::Pair(car, cdr) => {
                    if let Some(dt) = get_define_target(car.get()) {
                        values.push(dt);
                        formal = cdr.get();
                    } else {
                        return Err(format!("malformed formals: {}.", formals.pretty_print()));
                    }
                }
                _ => {
                    return Err(format!("malformed formals: {}.", formals.pretty_print()));
                }
            }
        }
    }
}
```


Overlapping Code:
```
mals(formals: PoolPtr) -> Result<Formals, String> {
let mut values = Vec::new();
let mut formal = formals;
loop {
if let Some(dt) = get_define_target(formal) {
return Ok(Formals {
values,
rest: Some(dt),
});
} else {
match &*formal {
Value::EmptyList => return Ok(Formals { values, rest: None }),
Value::Pair(car, cdr) => {
if let Some(dt) = get_define_target(car.get()) {
values.push(dt);
formal = cdr.get();
} else {
return Err(format!("malformed formals: {}.", formals.pretty_print()));
}
}
_ => {
return Err(format!("malformed formals: {}.", form
```
<Overlap Ratio: 0.927487352445194>

---

--- 11 --
Question ID: a7a5442331ae2d8bbe663446be1feef4bf49b590_1
Original Code:
```
pub(crate) fn recipe_count_until_this_score_appears<T: AsRef<str>>(score: T) -> usize {
    let digits = score
        .as_ref()
        .chars()
        .filter(|c| c.is_numeric())
        .map(|c| c.to_digit(10).unwrap() as usize)
        .collect::<Vec<usize>>();
    let mut list = vec![3, 7];
    let mut first = 0;
    let mut second = 1;

    let mut matched_digits = 0;
    loop {
        let sum = list[first] + list[second];
        if sum < 10 {
            list.push(sum);
        } else {
            list.push(sum / 10);
            if sum / 10 == digits[matched_digits] {
                matched_digits += 1;
                // Stop if we reached the goal with only the first of 2 new digits
                if matched_digits == digits.len() {
                    break;
                }
            } else if matched_digits > 0 {
                matched_digits = 0;
            }
            list.push(sum % 10);
        }
        // This also works for the sum < 10 part
        if sum % 10 == digits[matched_digits] {
            matched_digits += 1;
        } else if matched_digits > 0 {
            matched_digits = 0;
            // The following is when only the second of 2 new digits matches
            if sum % 10 == digits[matched_digits] {
                matched_digits += 1;
            } else {
                matched_digits = 0;
            }
        }
        if matched_digits == digits.len() {
            break;
        }
        first = (first + 1 + list[first]) % list.len();
        second = (second + 1 + list[second]) % list.len();
    }
    list.len() - digits.len()
}
```


Overlapping Code:
```
count_until_this_score_appears<T: AsRef<str>>(score: T) -> usize {
let digits = score
.as_ref()
.chars()
.filter(|c| c.is_numeric())
.map(|c| c.to_digit(10).unwrap() as usize)
.collect::<Vec<usize>>();
let mut list = vec![3, 7];
let mut first = 0;
let mut second = 1;
let mut matched_digits = 0;
loop {
let sum = list[first] + list[second];
if sum < 10 {
list.push(sum);
} else {
list.push(sum / 10);
if sum / 10 == digits[matched_digits] {
matched_digits += 1;
// Stop if we reached the goal with only the first of 2 new digits
if matched_digits == digits.len() {
break;
}
} else if matched_digits > 0 {
matched_digits = 0;
}
list.push(sum % 10);
}
// This also works for the sum < 10 part
if sum % 10 == digits[matched_digits] {
matched_digits += 1;
} else if matched_digits > 0 {
matched_digits = 0;
// The following is when only the second of 2 new digits matches
if sum % 10 == digits[matched_digits] {
matched_digits += 1;
} else {
matched_digits = 0;
}
}
if matched_digits == digits.len() {
break;
}
first = (first + 1 + list[first]) % list.len();
second = (second + 1 + list[second]) % list.l
```
<Overlap Ratio: 0.9515570934256056>

---

--- 12 --
Question ID: 9be353eaf9cb85e5438acd001f82a58479b6c888_2
Original Code:
```
fn discovery_returns_level_1_puzzles_when_in_level_0() -> TmouResult<()> {
    let inventory = vec![item("puzzles", 0, "puzzles-0")];

    // checkpoint with puzzles
    let node_contents = vec![item("puzzles", 1, "puzzles-1")];

    let expected_inventory = vec![
        item("puzzles", 0, "puzzles-0"),
        item("puzzles", 1, "puzzles-1"),
    ];

    let evt = dis::discover_node(Utc::now(), &inventory, &node_contents)?;
    assert_eq!(evt.event, dis::EventType::PuzzlesFound);
    assert_eq!(evt.updated_inventory, expected_inventory);
    assert_eq!(
        evt.newly_discovered_items,
        vec![item("puzzles", 1, "puzzles-1")]
    );
    Ok(())
}
```


Overlapping Code:
```
n_in_level_0() -> TmouResult<()> {
let inventory = vec![item("puzzles", 0, "puzzles-0")];
// checkpoint with puzzles
let node_contents = vec![item("puzzles", 1, "puzzles-1")];
let expected_inventory = vec![
item("puzzles", 0, "puzzles-0"),
item("puzzles", 1, "puzzles-1"),
];
let evt = dis::discover_node(Utc::now(), &inventory, &node_contents)?;
assert_eq!(evt.event, dis::EventType::PuzzlesFound);
assert_eq!(evt.updated_inventory, expected_inventory);
assert_eq!(
evt.newly_discovered_items,
vec![item
```
<Overlap Ratio: 0.863013698630137>

---

--- 13 --
Question ID: 2a798cf0d656cd1e1f597e3f89a802b00d9fcb21_1
Original Code:
```
fn write_u8s() {
        let mut a = AdapterU8::new(MockDevice::new());
        a.set_dcx_data_mode();
        let mut seq = mockall::Sequence::new();
        a.w.mock().expect_write_data()
            .with(eq(0x34))
            .times(1)
            .in_sequence(&mut seq);
        a.w.mock().expect_write_data()
            .with(eq(0x56))
            .times(1)
            .in_sequence(&mut seq);
        a.w.mock().expect_write_data()
            .with(eq(0x12))
            .times(1)
            .in_sequence(&mut seq);
        block_on(a.write_u8s(&[0x34, 0x56, 0x12]));
    }
```


Overlapping Code:
```
 mut a = AdapterU8::new(MockDevice::new());
a.set_dcx_data_mode();
let mut seq = mockall::Sequence::new();
a.w.mock().expect_write_data()
.with(eq(0x34))
.times(1)
.in_sequence(&mut seq);
a.w.mock().expect_write_data()
.with(eq(0x56))
.times(1)
.in_sequence(&mut seq);
a.w.mock().expect_write_data()
.with(eq(0x12))
.times(1)
.in_sequence(&mut seq);
block_on(a.
```
<Overlap Ratio: 0.8698795180722891>

---

--- 14 --
Question ID: 28fca27b0ea7eb3787bb9d4b3c2277b216ae22e6_1
Original Code:
```
fn sync_bin_size() {
    // should have a size of 4 words
    let word_size = core::mem::size_of::<usize>();
    let sync_bin_size = core::mem::size_of::<SBin>();
    assert_eq!(word_size * 4, sync_bin_size);
    assert_eq!(core::mem::size_of::<Bin>(), sync_bin_size);
}
```


Overlapping Code:
```
in_size() {
// should have a size of 4 words
let word_size = core::mem::size_of::<usize>();
let sync_bin_size = core::mem::size_of::<SBin>();
assert_eq!(word_size * 4, sync_bin_size);
assert_eq!(core::mem::siz
```
<Overlap Ratio: 0.836>

---

--- 15 --
Question ID: 8e1925c4296709eba228d33141458c50add3fc60_0
Original Code:
```
async fn main() -> anyhow::Result<()> {
    init_tracing();

    let polling_period = CliArgs::from_args().period.into();

    let rest_url = format!("https://{}", CliArgs::from_args().rest);
    let rest_cli = rest_client::ActixRestClient::new(&rest_url)?;

    let kube_client = kube::Client::try_default().await?;
    let namespace = "mayastor";

    // Validate that our "CRD" is up to date?

    // Manage the MayastorNode CR
    let nodes_api: Api<MayastorNode> =
        Api::namespaced(kube_client.clone(), namespace);

    loop {
        // Poll for kubernetes nodes and rest nodes
        // Reconcile from rest into kubernetes
        if let Err(error) = polling_work(&nodes_api, rest_cli.v0()).await {
            error!("Error while polling: {}", error);
        }

        // Sleep till the next poll
        tokio::time::delay_for(polling_period).await;
    }
}
```


Overlapping Code:
```
t<()> {
init_tracing();
let polling_period = CliArgs::from_args().period.into();
let rest_url = format!("https://{}", CliArgs::from_args().rest);
let rest_cli = rest_client::ActixRestClient::new(&rest_url)?;
let kube_client = kube::Client::try_default().await?;
let namespace = "mayastor";
// Validate that our "CRD" is up to date?
// Manage the MayastorNode CR
let nodes_api: Api<MayastorNode> =
Api::namespaced(kube_client.clone(), namespace);
loop {
// Poll for kubernetes nodes and rest nodes
// Reconcile from rest into kubernetes
if let Err(error) = polling_work(&nodes_api, rest_cli.v0()).await {
error!("Error while polling: {}", error);
}
// Sleep till the next poll
tokio::time::delay_for(p
```
<Overlap Ratio: 0.9247027741083224>

---

--- 16 --
Question ID: 39909517ca920507369d0a764e5d99a89423a8d1_14
Original Code:
```
fn test_basic_model_without_users() {
        let mut m = Model::new();
        m.load_model("examples/basic_without_users_model.conf");

        let adapter = FileAdapter::new("examples/basic_without_users_policy.csv");
        let e = Enforcer::new(m, adapter);

        assert!(e.enforce(vec!["data1", "read"]));
        assert!(!e.enforce(vec!["data1", "write"]));
        assert!(!e.enforce(vec!["data2", "read"]));
        assert!(e.enforce(vec!["data2", "write"]));
    }
```


Overlapping Code:
```
hout_users() {
let mut m = Model::new();
m.load_model("examples/basic_without_users_model.conf");
let adapter = FileAdapter::new("examples/basic_without_users_policy.csv");
let e = Enforcer::new(m, adapter);
assert!(e.enforce(vec!["data1", "read"]));
assert!(!e.enforce(vec!["data1", "write"]));
assert!(!e.enforce(vec!["data2", "read"]));
assert!(e.
```
<Overlap Ratio: 0.8578431372549019>

---

--- 17 --
Question ID: cd3f80bae1ccaf9711897ca2602de8a69cf92ea7_0
Original Code:
```
pub fn spawn_handle<F>(fut: F) -> FutureHandle
where
    F: Future<Output = ()> + 'static
{
    let (fut, handle) = abortable(fut);

    spawn_local(async move {
        let _ = fut.await;
    });

    FutureHandle { inner: handle }
}
```


Overlapping Code:
```
 -> FutureHandle
where
F: Future<Output = ()> + 'static
{
let (fut, handle) = abortable(fut);
spawn_local(async move {
let _ = fut.await;
});
FutureHa
```
<Overlap Ratio: 0.7352941176470589>

---

--- 18 --
Question ID: 232dfda793151cd6d1550bbef06be3edac9264d4_17
Original Code:
```
fn difference_3d() {
        let cube1 = SFCGeometry::new(
            "
            SOLID((((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),\
            ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\
            ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),\
            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\
            ((1 1 1, 1 0 1, 1 0 0, 1 1 0, 1 1 1)),\
            ((1 1 1, 1 1 0, 0 1 0, 0 1 1, 1 1 1))))",
        )
        .unwrap();
        let cube2 = SFCGeometry::new(
            "
            SOLID((((0 0 0.5, 0 1 0.5, 1 1 0.5, 1 0 0.5, 0 0 0.5)),\
            ((0 0 0.5, 0 0 1, 0 1 1, 0 1 0.5, 0 0 0.5)),\
            ((0 0 0.5, 1 0 0.5, 1 0 1, 0 0 1, 0 0 0.5)),\
            ((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\
            ((1 1 1, 1 0 1, 1 0 0.5, 1 1 0.5, 1 1 1)),\
            ((1 1 1, 1 1 0.5, 0 1 0.5, 0 1 1, 1 1 1))))",
        )
        .unwrap();
        let diff = cube1.difference_3d(&cube2).unwrap();
        assert_eq!(diff.is_valid().unwrap(), true);
        assert_ulps_eq!(diff.volume().unwrap(), 0.5);
    }
```


Overlapping Code:
```
) {
let cube1 = SFCGeometry::new(
"
SOLID((((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),\
((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),\
((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),\
((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\
((1 1 1, 1 0 1, 1 0 0, 1 1 0, 1 1 1)),\
((1 1 1, 1 1 0, 0 1 0, 0 1 1, 1 1 1))))",
)
.unwrap();
let cube2 = SFCGeometry::new(
"
SOLID((((0 0 0.5, 0 1 0.5, 1 1 0.5, 1 0 0.5, 0 0 0.5)),\
((0 0 0.5, 0 0 1, 0 1 1, 0 1 0.5, 0 0 0.5)),\
((0 0 0.5, 1 0 0.5, 1 0 1, 0 0 1, 0 0 0.5)),\
((1 1 1, 0 1 1, 0 0 1, 1 0 1, 1 1 1)),\
((1 1 1, 1 0 1, 1 0 0.5, 1 1 0.5, 1 1 1)),\
((1 1 1, 1 1 0.5, 0 1 0.5, 0 1 1, 1 1 1))))",
)
.unwrap();
let diff = cube1.difference_3d(&cube2).unwrap();
assert_eq!(diff.is_valid().unwrap(), true);
assert_ulps_eq!(diff.volume().unwrap(), 0.5
```
<Overlap Ratio: 0.9730423620025674>

---

--- 19 --
Question ID: cbbb0f5b20d079806b678d1e3d1b100d76814f2c_11
Original Code:
```
pub async fn recommend_categories(state: Data<AppState>) -> Result<impl Responder, AppError> {
    let sublog = state.log.new(o!("handler" => "recommend_categories"));
    let client: Client = get_client(state.pool.clone(), sublog.clone()).await?;
    db::hot_categories(&client)
        .await
        .map(|cate| ResultResponse::normal(cate))
        .map_err(log_error(sublog))
}
```


Overlapping Code:
```
b async fn recommend_categories(state: Data<AppState>) -> Result<impl Responder, AppError> {
let sublog = state.log.new(o!("handler" => "recommend_categories"));
let client: Client = get_client(state.pool.clone(), sublog.clone()).await?;
db::hot_categories(&client)
.await
.map(|cate| ResultResponse::normal(cate))

```
<Overlap Ratio: 0.9104046242774566>

---

--- 20 --
Question ID: 2e5ea2ac7ebca3fec182d20864725ccd94e1fe27_0
Original Code:
```
fn derive_unit(item: &DeriveInput, _: &DataStruct) -> syn::Result<TokenStream> {
    let ident = &item.ident;

    let code = quote! {
        impl ::btmgmt_packet_helper::pack::Pack for #ident {
            fn pack<W>(&self, _: &mut W) -> ::btmgmt_packet_helper::pack::Result<()> where W: ::std::io::Write {
                Ok(())
            }
        }
    };
    Ok(code)
}
```


Overlapping Code:
```
_unit(item: &DeriveInput, _: &DataStruct) -> syn::Result<TokenStream> {
let ident = &item.ident;
let code = quote! {
impl ::btmgmt_packet_helper::pack::Pack for #ident {
fn pack<W>(&self, _: &mut W) -> ::btmgmt_packet_helper::pack::Result<()> where W: ::std::io::Write {
Ok(())
}
}
};
Ok(co
```
<Overlap Ratio: 0.9539473684210527>

---

--- 21 --
Question ID: f8f03feb0bd0074061944d3854948d0c07e30df0_3
Original Code:
```
pub(crate) fn create(agent: &Agent) -> HashMap<String, Value> {
    let mut module = HashMap::new();
    module.insert(
        "createTimeout".to_string(),
        Value::new_builtin_function(agent, create_timeout, false),
    );
    module.insert(
        "createInterval".to_string(),
        Value::new_builtin_function(agent, create_interval, false),
    );

    module
}
```


Overlapping Code:
```
) fn create(agent: &Agent) -> HashMap<String, Value> {
let mut module = HashMap::new();
module.insert(
"createTimeout".to_string(),
Value::new_builtin_function(agent, create_timeout, false),
);
module.insert(
"createInterval".to_string(),
Value::new_builtin_function(agent, create_interval, false),
);
mod
```
<Overlap Ratio: 0.9561128526645768>

---

--- 22 --
Question ID: 53146e12435182e27ab84d64a0dd96f326f65e3a_3
Original Code:
```
fn integration_test_opt_in() {
        // PRECONDITIONS:
        //   - The BTC Parachain status in the Security component MUST be `RUNNING:0`.
        //   - A Vault with id `vaultId` MUST be registered.
        //   - The Vault MUST NOT be opted in.
        // POSTCONDITION: The Vault MUST be allowed to receive nominated collateral.
        test_with(|_| {
            assert_noop!(
                Call::Nomination(NominationCall::set_nomination_enabled(true)).dispatch(origin_of(account_of(CAROL))),
                DispatchError::BadOrigin
            );
            let mut nomination_enabled = true;
            assert_ok!(
                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))
                    .dispatch(<Runtime as frame_system::Config>::Origin::root())
            );
            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);
            nomination_enabled = false;
            assert_ok!(
                Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))
                    .dispatch(<Runtime as frame_system::Config>::Origin::root())
            );
            assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);
        })
    }
```


Overlapping Code:
```
_opt_in() {
// PRECONDITIONS:
// - The BTC Parachain status in the Security component MUST be `RUNNING:0`.
// - A Vault with id `vaultId` MUST be registered.
// - The Vault MUST NOT be opted in.
// POSTCONDITION: The Vault MUST be allowed to receive nominated collateral.
test_with(|_| {
assert_noop!(
Call::Nomination(NominationCall::set_nomination_enabled(true)).dispatch(origin_of(account_of(CAROL))),
DispatchError::BadOrigin
);
let mut nomination_enabled = true;
assert_ok!(
Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))
.dispatch(<Runtime as frame_system::Config>::Origin::root())
);
assert_eq!(NominationPallet::is_nomination_enabled(), nomination_enabled);
nomination_enabled = false;
assert_ok!(
Call::Nomination(NominationCall::set_nomination_enabled(nomination_enabled))
.dispatch(<Runtime as frame_system::Config>::Origin::root())
);
assert_eq!(NominationPallet::is_nomination_enabled(), nominati
```
<Overlap Ratio: 0.963076923076923>

---

--- 23 --
Question ID: 74d5adaef7242d1689e13c9f16854704d534c808_4
Original Code:
```
fn websocket() {
        let counter = AtomicUsize::new(0);
        let mock = MockData::new();
        let mut proto = PureProto::new(mock.clone(),
            &Config::new().inflight_request_limit(1).done(),
            MockWs { websockets: &counter });
        proto.process().unwrap();
        mock.add_input("GET /chat HTTP/1.1\r\n\
            Host: server.example.com\r\n\
            Upgrade: websocket\r\n\
            Connection: Upgrade\r\n\
            Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\n\
            Sec-WebSocket-Protocol: chat, superchat\r\n\
            Sec-WebSocket-Version: 13\r\n\
            Origin: http://example.com\r\n\r\n");
        proto.process().unwrap();
        // counts as a request and as a websocket
        assert_eq!(counter.load(Ordering::SeqCst), 2);
    }
```


Overlapping Code:
```
{
let counter = AtomicUsize::new(0);
let mock = MockData::new();
let mut proto = PureProto::new(mock.clone(),
&Config::new().inflight_request_limit(1).done(),
MockWs { websockets: &counter });
proto.process().unwrap();
mock.add_input("GET /chat HTTP/1.1\r\n\
Host: server.example.com\r\n\
Upgrade: websocket\r\n\
Connection: Upgrade\r\n\
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\r\nrotocol: chat, superchat\r\n\
Sec-WebSocket-Version: 13\r\n\
Origin: http://example.com\r\n\r\n");
proto.process().unwrap();
// counts as a request and as a websocket
assert_eq!(counter.load(Ordering:
```
<Overlap Ratio: 0.9256329113924051>

---

--- 24 --
Question ID: e6c02ad05eeca0f370510452e04d754f2ab11ce7_0
Original Code:
```
async fn test_client() {
        env_logger::try_init().ok();
        let client = ClientBuilder::<NodeTemplateRuntime>::new()
            .build()
            .await
            .unwrap();
        let signer = PairSigner::new(AccountKeyring::Alice.pair());
        let to = AccountKeyring::Bob.to_account_id().into();
        client
            .transfer_and_watch(&signer, &to, 10_000)
            .await
            .unwrap();
    }
```


Overlapping Code:
```
ok();
let client = ClientBuilder::<NodeTemplateRuntime>::new()
.build()
.await
.unwrap();
let signer = PairSigner::new(AccountKeyring::Alice.pair());
let to = AccountKeyring::Bob.to_account_id().into();
client
.transfer_and_watch(&signer, &to, 10_000
```
<Overlap Ratio: 0.7836990595611285>

---

--- 25 --
Question ID: 7f4954d74021dbde904b450c6b66c7681dc2fc65_2
Original Code:
```
pub fn broadcast(x: Rc<RefCell<Variable>>, shape: Vec<usize>) -> Rc<RefCell<Variable>> {
    let output = Rc::new(RefCell::new(Variable::new(shape.clone())));
    let function = Box::new(Broadcast { shape });
    let cg_function = Rc::new(RefCell::new(CgFunction::new(
        vec![x],
        vec![output.clone()],
        function,
    )));
    cg_function.borrow_mut().forward();
    output.borrow_mut().set_parent(cg_function);
    output
}
```


Overlapping Code:
```
Cell<Variable>>, shape: Vec<usize>) -> Rc<RefCell<Variable>> {
let output = Rc::new(RefCell::new(Variable::new(shape.clone())));
let function = Box::new(Broadcast { shape });
let cg_function = Rc::new(RefCell::new(CgFunction::new(
vec![x],
vec![output.clone()],
function,
)));
cg_function.borrow_mut().forward();
output.borrow_mut().set_parent(cg_function);
output

```
<Overlap Ratio: 0.9311224489795918>

---

--- 26 --
Question ID: 876d93c097493fe92d439172028103d6eb585a4d_0
Original Code:
```
pub fn is_multiple_of(a: &Float, b: &Float) -> bool {
    if a.is_infinite() || b.is_infinite() { return false; }
    let c = Float::with_val(a.prec(),a).remainder(b);
    if c == 0 {
        let d = Float::with_val(a.prec(), a/b);
        return d.is_integer();
    }
    return false;
}
```


Overlapping Code:
```
ltiple_of(a: &Float, b: &Float) -> bool {
if a.is_infinite() || b.is_infinite() { return false; }
let c = Float::with_val(a.prec(),a).remainder(b);
if c == 0 {
let d = Float::with_val(a.prec(), a/b);

```
<Overlap Ratio: 0.7936507936507936>

---

--- 27 --
Question ID: 2b3fc09cc7f9bd69b77b67df6c96b887959fa8dc_0
Original Code:
```
fn func_donate_thunk(ctx: &ScFuncContext) {
	ctx.log("donatewithfeedback.funcDonate");
	let f = DonateContext {
		params: ImmutableDonateParams { proxy: params_proxy() },
		state: MutableDonateWithFeedbackState { proxy: state_proxy() },
	};
	func_donate(ctx, &f);
	ctx.log("donatewithfeedback.funcDonate ok");
}
```


Overlapping Code:
```
fn func_donate_thunk(ctx: &ScFuncContext) {
ctx.log("donatewithfeedback.funcDonate");
let f = DonateContext {
params: ImmutableDonateParams { proxy: params_proxy() },
state: MutableDonateWithFeedbackState { proxy: state_proxy() },
};
func_donate(ctx, &f);
ctx.log("donatewithfeedback.funcDonate ok");
```
<Overlap Ratio: 0.9933774834437086>

---

--- 28 --
Question ID: 7e936c7d59bc1581235ce46e34b0a29e2d6b7e73_26
Original Code:
```
fn nested() {
        let mut rt = rt();
        let tokens = [
            Ident(rt.intern_string("hugo")),
            Dot,
            Ident(rt.intern_string("name")),
            Dot,
            Ident(rt.intern_string("print")),
            ParenO,
            ParenC,
        ]
        .map(token)
        .into();
        let alloc = Bump::new();
        let ast = parse_call(tokens, &alloc);
        insta::assert_debug_snapshot!(ast);
    }
```


Overlapping Code:
```
ted() {
let mut rt = rt();
let tokens = [
Ident(rt.intern_string("hugo")),
Dot,
Ident(rt.intern_string("name")),
Dot,
Ident(rt.intern_string("print")),
ParenO,
ParenC,
]
.map(token)
.into();
let alloc = Bump::new();
let ast = parse_call(tokens, &alloc);
insta::assert_debug_snapshot!(ast);
```
<Overlap Ratio: 0.9730639730639731>

---

--- 29 --
Question ID: 265cc3220ff865a85103c9eb644e97399a472475_0
Original Code:
```
fn get_colored_circles (center_to_center: i32, small_radius: i32, colors: Vec<[u8; 4]>) -> Vec<Circle> {
    let positions = position_circle_set(center_to_center);
    let mut out: Vec<Circle> = Vec::with_capacity(19);
// no checking is done here for positions.len() == 19 and colors.len() == 19;
// however, no other length is expected.
    for (i, position) in positions.iter().enumerate() {
        let new = Circle {
            x_center: position.x_center,
            y_center: position.y_center,
            radius: small_radius,
            rgba_color: colors[i],
        };
        out.push(new);
    }
    out
}
```


Overlapping Code:
```
(center_to_center: i32, small_radius: i32, colors: Vec<[u8; 4]>) -> Vec<Circle> {
let positions = position_circle_set(center_to_center);
let mut out: Vec<Circle> = Vec::with_capacity(19);
// no checking is done here for positions.len() == 19 and colors.len() == 19;
// however, no other length is expected.
for (i, position) in positions.iter().enumerate() {
let new = Circle {
x_center: position.x_center,
y_center: position.y_center,
radius: small_radius,
rgba_color: colors[i],
};
out.push(new);
}
```
<Overlap Ratio: 0.945179584120983>

---

--- 30 --
Question ID: 4e29030d1670739438df0b803c52e72867833db3_22
Original Code:
```
fn test_multi_over_capacity() {
        let mut map = populate_hashmap();

        let mut buffer = [null_mut(); 3];
        let mut wrapper = map.multi_mut(&mut buffer);
        
        let _one = wrapper.get_mut("key_one").unwrap();
        let _two = wrapper.get_mut("key_two").unwrap();
        let _three = wrapper.get_mut("key_three").unwrap();
        let _four = wrapper.get_mut("key_four").unwrap();
    }
```


Overlapping Code:
```
() {
let mut map = populate_hashmap();
let mut buffer = [null_mut(); 3];
let mut wrapper = map.multi_mut(&mut buffer);

let _one = wrapper.get_mut("key_one").unwrap();
let _two = wrapper.get_mut("key_two").unwrap();
let _three = wrapper.get_mut("key_three").unwrap();
let _four = wrapper.get_mut("key_four").unwrap
```
<Overlap Ratio: 0.9075144508670521>

---

--- 31 --
Question ID: a08cf8345499a40e511d31aba13072a0c198e2fa_14
Original Code:
```
fn token_option_cannot_be_empty() {
            let matches = SupRun::clap().get_matches_from_safe(vec!["run",
                                                                    "--event-stream-application",
                                                                    "MY_APP",
                                                                    "--event-stream-environment",
                                                                    "MY_ENV",
                                                                    "--event-stream-token",
                                                                    "",
                                                                    "--event-stream-url",
                                                                    "127.0.0.1:4222",]);
            assert!(matches.is_err());
            let error = matches.unwrap_err();
            assert_eq!(error.kind, clap::ErrorKind::ValueValidation);
        }
```


Overlapping Code:
```
ption_cannot_be_empty() {
let matches = SupRun::clap().get_matches_from_safe(vec!["run",
"--event-stream-application",
"MY_APP",
"--event-stream-environment",
"MY_ENV",
"--event-stream-token",
"",
"--event-stream-url",
"127.0.0.1:4222",]);
assert!(matches.is_err());
let error = matches.unwrap_err();
assert_eq!(error.kind, clap::ErrorKind::ValueValida
```
<Overlap Ratio: 0.9513513513513514>

---

--- 32 --
Question ID: 226cf81ec27c1d8692fac7953d04fa88855973c1_0
Original Code:
```
pub fn spawn(commands: &mut Commands, style: &Style) -> Entity {
    let mut entity = None;
    commands.with_children(|parent| {
        parent
            .spawn(NodeBundle {
                style: ui::Style {
                    flex_direction: FlexDirection::ColumnReverse,
                    position: Rect {
                        left: Val::Undefined,
                        top: Val::Px(0.0), // We use this for vertical scrolling
                        bottom: Val::Undefined,
                        right: Val::Undefined,
                    },
                    size: Size {
                        width: Val::Percent(100.),
                        height: Val::Undefined, // Height will grow as needed
                    },
                    flex_shrink: 0.,
                    padding: Rect {
                        left: Val::Px(4.0),
                        right: Val::Px(4.0),
                        top: Val::Px(0.0),
                        bottom: Val::Px(0.0),
                    },
                    ..Default::default()
                },
                material: style.color_background.clone(),
                ..Default::default()
            })
            .with(Children::default())
            .with(SceneList {
                style: style.clone(),
            })
            .with(DebugIgnore)
            .with_children(|parent| {
                parent
                    .spawn(ButtonBundle::default())
                    .with(SaveSceneButton)
                    .with(DebugIgnore)
                    .with_children(|parent| {
                        parent
                            .spawn(TextBundle {
                                text: Text::with_section(
                                    "Save",
                                    TextStyle {
                                        font: style.font.clone(),
                                        font_size: style.font_size,
                                        color: Color::BLACK,
                                    },
                                    TextAlignment::default(),
                                ),
                                focus_policy: FocusPolicy::Pass,
                                ..Default::default()
                            })
                            .with(DebugIgnore);
                    });
            });
        entity = Some(parent.current_entity().unwrap());
    });
    entity.unwrap()
}
```


Overlapping Code:
```
commands: &mut Commands, style: &Style) -> Entity {
let mut entity = None;
commands.with_children(|parent| {
parent
.spawn(NodeBundle {
style: ui::Style {
flex_direction: FlexDirection::ColumnReverse,
position: Rect {
left: Val::Undefined,
top: Val::Px(0.0), // We use this for vertical scrolling
bottom: Val::Undefined,
right: Val::Undefined,
},
size: Size {
width: Val::Percent(100.),
height: Val::Undefined, // Height will grow as needed
},
flex_shrink: 0.,
padding: Rect {
left: Val::Px(4.0),
right: Val::Px(4.0),
top: Val::Px(0.0),
bottom: Val::Px(0.0),
},
..Default::default()
},
material: style.color_background.clone(),
..Default::default()
})
.with(Children::default())
.with(SceneList {
style: style.clone(),
})
.with(DebugIgnore)
.with_children(|parent| {
parent
.spawn(ButtonBundle::default())
.with(SaveSceneButton)
.with(DebugIgnore)
.with_children(|parent| {
parent
.spawn(TextBundle {
text: Text::with_section(
"Save",
TextStyle {
font: style.font.clone(),
font_size: style.font_size,
color: Color::BLACK,
},
TextAlignment::default(),
),
focus_policy: FocusPolicy::Pass,
..Default::default()
})
.with(DebugIgnore);
});
});
entity = Some(parent.current_entity().unwrap());
});
entity.unwrap
```
<Overlap Ratio: 0.986088379705401>

---

--- 33 --
Question ID: 6fe2bffcce32dd12d561bfd8a5a333df30fe509e_8
Original Code:
```
fn test_unstake_without_stake() {
    let mut deps = mock_dependencies(&[]);
    let env = mock_env();
    let instantiate_msg = InstantiateMsg {
        owner: Addr::unchecked("owner0000"),
        nft_contract_addr: Addr::unchecked("internnft0000"),
        terrand_addr: Addr::unchecked("terrand0000"),
        stamina_constant: 1,
        exp_constant: 1,
    };

    let info = mock_info("addr0000", &[]);

    let _instantiate_res =
        instantiate(deps.as_mut(), mock_env(), info.clone(), instantiate_msg).unwrap();

    let unstake_res = withdraw_nft(deps.as_mut(), env, info, "0".to_string());

    match unstake_res {
        Err(ContractError::NoStakedToken {}) => (),
        _ => panic!("Must return no staked token error"),
    }
}
```


Overlapping Code:
```
e() {
let mut deps = mock_dependencies(&[]);
let env = mock_env();
let instantiate_msg = InstantiateMsg {
owner: Addr::unchecked("owner0000"),
nft_contract_addr: Addr::unchecked("internnft0000"),
terrand_addr: Addr::unchecked("terrand0000"),
stamina_constant: 1,
exp_constant: 1,
};
let info = mock_info("addr0000", &[]);
let _instantiate_res =
instantiate(deps.as_mut(), mock_env(), info.clone(), instantiate_msg).unwrap();
let unstake_res = withdraw_nft(deps.as_mut(), env, info, "0".to_string());
match unstake_res {
Err(ContractError::NoStakedToken {}) => (),
_ => pa
```
<Overlap Ratio: 0.8852713178294573>

---

--- 34 --
Question ID: d0fbba2b54ba8e63349a4714db4433485305c83e_1
Original Code:
```
fn protocol_number_to_string() {
        assert_eq!("TCP", ProtocolNumbers::Tcp.to_string());
        assert_eq!("UDP", ProtocolNumbers::Udp.to_string());
        assert_eq!("IPv6 Route", ProtocolNumbers::Ipv6Route.to_string());
        assert_eq!("ICMPv6", ProtocolNumbers::Icmpv6.to_string());
        assert_eq!("0x00", ProtocolNumber::new(0).to_string());
    }
```


Overlapping Code:
```
o_string() {
assert_eq!("TCP", ProtocolNumbers::Tcp.to_string());
assert_eq!("UDP", ProtocolNumbers::Udp.to_string());
assert_eq!("IPv6 Route", ProtocolNumbers::Ipv6Route.to_string());
assert_eq!("ICMPv6", ProtocolNumbers::Icmpv6.to_string());
assert_eq!("0x00", ProtocolNumber::new(0).to_string());

```
<Overlap Ratio: 0.9345794392523364>

---

--- 35 --
Question ID: a2361ff584d090eae64e33f4ce6e3bf3fe247310_0
Original Code:
```
pub fn initialize_paging(frame_alloctor: &mut impl FrameAllocator<Size4KiB>) -> PageTables {
    let physical_offset = VirtAddr::new(0x00);
    let old_table = {
        let frame = control::Cr3::read().0;
        let ptr: *const PageTable = (physical_offset + frame.start_address().as_u64()).as_ptr();

        unsafe {
            &*ptr
        }
    };

    let new_frame = frame_alloctor.allocate_frame().unwrap();
    let new_table = {
        let ptr: *mut PageTable = (physical_offset + new_frame.start_address().as_u64()).as_mut_ptr();

        unsafe {
            ptr.write(PageTable::new());

            &mut *ptr
        }
    };

    new_table[0] = old_table[0].clone();

    let boot_page_table = unsafe {
        control::Cr3::write(new_frame, control::Cr3Flags::empty());
        OffsetPageTable::new(&mut *new_table, physical_offset)
    };

    let (kernel_page_table, kernel_level_four_frame) = {
        let frame = frame_alloctor.allocate_frame().expect("No unused frames are available for allocation.");
        log::info!("Created a new page table for the System Kernel at: {:#?}", &frame);

        let address = physical_offset + frame.start_address().as_u64();

        let ptr =  address.as_mut_ptr();
        unsafe {
            *ptr = PageTable::new()
        };

        let level_four_table = unsafe {
            &mut *ptr
        };

        (
            unsafe {
                OffsetPageTable::new(level_four_table, physical_offset)
            },
            frame
        )
    };

    PageTables {
        boot_page_table,
        kernel_page_table,
        kernel_level_four_frame
    }
}
```


Overlapping Code:
```
 impl FrameAllocator<Size4KiB>) -> PageTables {
let physical_offset = VirtAddr::new(0x00);
let old_table = {
let frame = control::Cr3::read().0;
let ptr: *const PageTable = (physical_offset + frame.start_address().as_u64()).as_ptr();
unsafe {
&*ptr
}
};
let new_frame = frame_alloctor.allocate_frame().unwrap();
let new_table = {
let ptr: *mut PageTable = (physical_offset + new_frame.start_address().as_u64()).as_mut_ptr();
unsafe {
ptr.write(PageTable::new());
&mut *ptr
}
};
new_table[0] = old_table[0].clone();
let boot_page_table = unsafe {
control::Cr3::write(new_frame, control::Cr3Flags::empty());
OffsetPageTable::new(&mut *new_table, physical_offset)
};
let (kernel_page_table, kernel_level_four_frame) = {
let frame = frame_alloctor.allocate_frame().expect("No unused frames are available for allocation.");
log::info!("Created a new page table for the System Kernel at: {:#?}", &frame);
let address = physical_offset + frame.start_address().as_u64();
let ptr = address.as_mut_ptr();
unsafe {
*ptr = PageTable::new()
};
let level_four_table = unsafe {
&mut *ptr
};
(
unsafe {
OffsetPageTable::new(level_four_table, physical_offset)
},
frame
)
};
PageTables {
boot_page_table,
kernel_page_t
```
<Overlap Ratio: 0.9389671361502347>

---

--- 36 --
Question ID: e6d58775c43459dfd4d37f11d0ed6bc9767659e5_0
Original Code:
```
fn test(u: &mut Unstructured) -> arbitrary::Result<()> {
    let mut pb = RowProblem::default();
    let vars = u
        .arbitrary_iter::<ColData>()?
        .map(|cd| {
            let cd = cd?;
            Ok(pb.add_column_with_integrality(cd.val, cd.range, cd.integrality))
        })
        .collect::<Result<Vec<_>, _>>()?;

    let num_rows = u.arbitrary::<u8>()? as usize;

    for _ in 0..num_rows {
        let range = u.arbitrary::<Range<f64>>()?;
        pb.add_row(
            range,
            &[
                (*u.choose(&vars)?, u.arbitrary()?),
                (*u.choose(&vars)?, u.arbitrary()?),
                (*u.choose(&vars)?, u.arbitrary()?),
            ],
        );
    }
    if let Ok(solved) = pb
        .try_optimise(*u.choose(&[Sense::Maximise, Sense::Minimise])?)
        .and_then(|p| p.try_solve())
    {
        let solution = solved.get_solution();
        // The expected solution is x=0  y=6  z=0.5
        assert_eq!(solution.columns().len(), vars.len());
        // All the constraints are at their maximum
        assert_eq!(solution.rows().len(), num_rows);
    }
    Ok(())
}
```


Overlapping Code:
```
est(u: &mut Unstructured) -> arbitrary::Result<()> {
let mut pb = RowProblem::default();
let vars = u
.arbitrary_iter::<ColData>()?
.map(|cd| {
let cd = cd?;
Ok(pb.add_column_with_integrality(cd.val, cd.range, cd.integrality))
})
.collect::<Result<Vec<_>, _>>()?;
let num_rows = u.arbitrary::<u8>()? as usize;
for _ in 0..num_rows {
let range = u.arbitrary::<Range<f64>>()?;
pb.add_row(
range,
&[
(*u.choose(&vars)?, u.arbitrary()?),
(*u.choose(&vars)?, u.arbitrary()?),
(*u.choose(&vars)?, u.arbitrary()?),
],
);
}
if let Ok(solved) = pb
.try_optimise(*u.choose(&[Sense::Maximise, Sense::Minimise])?)
.and_then(|p| p.try_solve())
{
let solution = solved.get_solution();
// The expected solution is x=0 y=6 z=0.5
assert_eq!(solution.columns().len(), vars.len());
// All the constraints are at their maximum
assert_eq!(solution.rows().len(), num_rows)
```
<Overlap Ratio: 0.9815242494226328>

---

--- 37 --
Question ID: 613ded8caed4064aaef38bcdcec40e2873e708e6_13
Original Code:
```
fn jacobson_rank(b: &mut Bencher) {
        let (v, mut rng) = test_vector();
        let mut bv: BitVector<u64> = BitVector::new();
        let mut last_v = 0;
        for val  in v {
            for _ in  last_v..val {
                bv.push_bit(false);
            }
            bv.push_bit(true);
            last_v = val;
        }
        let r = JacobsonRank::new(bv);
        b.iter(|| {
            for _ in 0..super::TRIALS {
                black_box(r.rank1(rng.gen_range(0, SIZE)));
            }
        })
    }
```


Overlapping Code:
```
n jacobson_rank(b: &mut Bencher) {
let (v, mut rng) = test_vector();
let mut bv: BitVector<u64> = BitVector::new();
let mut last_v = 0;
for val in v {
for _ in last_v..val {
bv.push_bit(false);
}
bv.push_bit(true);
last_v = val;
}
let r = JacobsonRank::new(bv);
b.iter(|| {
for _ in 0..super::TRIALS {
black_box(r.rank1(rng.gen_range(0, SIZE)));
}
})
```
<Overlap Ratio: 0.9915014164305949>

---

--- 38 --
Question ID: ee23bceb61999618b90fa59c426d25d22c6d6bf1_0
Original Code:
```
fn assign_fractional_seconds(
    fractional: &str,
    mut setter: FractionalSecondSetter,
) -> FractionalSecondSetter {
    let number_of_digits = fractional.len();
    // If the precision is less than or equal to nanoseconds...
    if number_of_digits <= 9 {
        // Convert the number to nanoseconds and make a note of its original precision.
        let power = 9 - number_of_digits;
        let nanoseconds =
            trim_zeros_expect_u32(fractional, "fractional seconds") * 10u32.pow(power as u32);
        setter = setter.with_nanoseconds_and_precision(nanoseconds, number_of_digits as u32);
    } else {
        // Otherwise, the number's precision is great enough that we'll need to construct a Decimal
        // to store it without loss of fidelity.
        let coefficient =
            BigUint::from_str(fractional).expect("parsing fractional seconds as BigUint failed");
        let mut digit_count = 1i64;
        let mut tmp_coefficient = coefficient.clone();
        let ten = BigUint::from(10u32);
        while tmp_coefficient > ten {
            tmp_coefficient.div_assign(&ten);
            digit_count += 1;
        }
        let decimal = Decimal::new(coefficient, -1 * digit_count);
        setter = setter.with_fractional_seconds(decimal);
    }
    setter
}
```


Overlapping Code:
```
l_seconds(
fractional: &str,
mut setter: FractionalSecondSetter,
) -> FractionalSecondSetter {
let number_of_digits = fractional.len();
// If the precision is less than or equal to nanoseconds...
if number_of_digits <= 9 {
// Convert the number to nanoseconds and make a note of its original precision.
let power = 9 - number_of_digits;
let nanoseconds =
trim_zeros_expect_u32(fractional, "fractional seconds") * 10u32.pow(power as u32);
setter = setter.with_nanoseconds_and_precision(nanoseconds, number_of_digits as u32);
} else {
// Otherwise, the number's precision is great enough that we'll need to construct a Decimal
// to store it without loss of fidelity.
let coefficient =
BigUint::from_str(fractional).expect("parsing fractional seconds as BigUint failed");
let mut digit_count = 1i64;
let mut tmp_coefficient = coefficient.clone();
let ten = BigUint::from(10u32);
while tmp_coefficient > ten {
tmp_coefficient.div_assign(&ten);
digit_count += 1;
}
let decimal = Decimal::new(coefficient, -1 * digit_count);
setter = setter.with_fractiona
```
<Overlap Ratio: 0.9554140127388535>

---

--- 39 --
Question ID: 6f749aa54c976e488f9ecf357e07439a9aceb563_0
Original Code:
```
fn emit_mu_types(suffix: &str, vm: &VM) {
    create_emit_directory(vm);

    let mut file_path = path::PathBuf::new();
    file_path.push(&vm.vm_options.flag_aot_emit_dir);
    file_path.push("___types".to_string() + suffix + ".uir");
    let mut file = match File::create(file_path.as_path()) {
        Err(why) => {
            panic!(
                "couldn't create mu types file {}: {}",
                file_path.to_str().unwrap(),
                why
            )
        }
        Ok(file) => file
    };

    {
        use ast::types::*;

        let ty_guard = vm.types().read().unwrap();
        let struct_map = STRUCT_TAG_MAP.read().unwrap();
        let hybrid_map = HYBRID_TAG_MAP.read().unwrap();

        for ty in ty_guard.values() {
            if ty.is_struct() {
                write!(file, ".typedef {} = ", ty.hdr).unwrap();

                let struct_ty = struct_map
                    .get(&ty.get_struct_hybrid_tag().unwrap())
                    .unwrap();
                writeln!(file, "{}", struct_ty).unwrap();
                writeln!(file, "\n\t/*{}*/", vm.get_backend_type_info(ty.id())).unwrap();
            } else if ty.is_hybrid() {
                write!(file, ".typedef {} = ", ty.hdr).unwrap();
                let hybrid_ty = hybrid_map
                    .get(&ty.get_struct_hybrid_tag().unwrap())
                    .unwrap();
                writeln!(file, "{}", hybrid_ty).unwrap();
                writeln!(file, "\n\t/*{}*/", vm.get_backend_type_info(ty.id())).unwrap();
            } else {
                // we only care about struct
            }
        }
    }
}
```


Overlapping Code:
```
&str, vm: &VM) {
create_emit_directory(vm);
let mut file_path = path::PathBuf::new();
file_path.push(&vm.vm_options.flag_aot_emit_dir);
file_path.push("___types".to_string() + suffix + ".uir");
let mut file = match File::create(file_path.as_path()) {
Err(why) => {
panic!(
"couldn't create mu types file {}: {}",
file_path.to_str().unwrap(),
why
)
}
Ok(file) => file
};
{
use ast::types::*;
let ty_guard = vm.types().read().unwrap();
let struct_map = STRUCT_TAG_MAP.read().unwrap();
let hybrid_map = HYBRID_TAG_MAP.read().unwrap();
for ty in ty_guard.values() {
if ty.is_struct() {
write!(file, ".typedef {} = ", ty.hdr).unwrap();
let struct_ty = struct_map
.get(&ty.get_struct_hybrid_tag().unwrap())
.unwrap();
writeln!(file, "{}", struct_ty).unwrap();
writeln!(file, "\n\t/*{}*/", vm.get_backend_type_info(ty.id())).unwrap();
} else if ty.is_hybrid() {
write!(file, ".typedef {} = ", ty.hdr).unwrap();
let hybrid_ty = hybrid_map
.get(&ty.get_struct_hybrid_tag().unwrap())
.unwrap();
writeln!(file, "{}", hybrid_ty).unwrap();
writeln!(file, "\n\t/*{}*/", vm.get_backend_type_info(ty.id())).unwrap();
} else {
// we only car
```
<Overlap Ratio: 0.9598633646456021>

---

--- 40 --
Question ID: df41f7bdb989c76875a16473396f0a1bb7600126_0
Original Code:
```
fn setup(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut texture_atlases: ResMut<Assets<TextureAtlas>>,
) {
    let texture_handle = asset_server.load("circle.png");
    let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 32.0), 1, 1);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);
    commands.spawn(OrthographicCameraBundle::new_2d());

    let mut rng = rand::thread_rng();
    for _ in 0..1000 {
        let x = rng.gen_range(-500.0..500.0);
        let y = rng.gen_range(-500.0..500.0);
        commands.spawn(sprite_batch::BatchedSpriteBundle::new(
            texture_atlas_handle.clone(),
            0,
            Transform::from_translation(Vec3::new(x, y, 0.0)),
        ));
    }
}
```


Overlapping Code:
```
fn setup(
mut commands: Commands,
asset_server: Res<AssetServer>,
mut texture_atlases: ResMut<Assets<TextureAtlas>>,
) {
let texture_handle = asset_server.load("circle.png");
let texture_atlas = TextureAtlas::from_grid(texture_handle, Vec2::new(32.0, 32.0), 1, 1);
let texture_atlas_handle = texture_atlases.add(texture_atlas);
commands.spawn(OrthographicCameraBundle::new_2d());
let mut rng = rand::thread_rng();
for _ in 0..1000 {
let x = rng.gen_range(-500.0..500.0);
let y = rng.gen_range(-500.0..500.0);
commands.spawn(sprite_batch::BatchedSpriteBundle::new(
texture_atlas_handle.clone(),
0,
Transform::from_translation(Vec3::new(x, y, 0.0)),

```
<Overlap Ratio: 0.9893129770992366>

---

--- 41 --
Question ID: 2e07316562a67cdc60c0e202fc10c482fe4481e9_7
Original Code:
```
pub fn get_total_duration(
    start: chrono::DateTime<chrono::Utc>,
    end: chrono::DateTime<chrono::Utc>,
) -> Result<chrono::Duration, Error> {
    let repo = get_repo()?;

    let mut total_duration = chrono::Duration::seconds(0);

    for task in repo.list_tasks()?.values() {
        total_duration = total_duration.add(task.duration_between(start, end));
    }

    Ok(total_duration)
}
```


Overlapping Code:
```
tart: chrono::DateTime<chrono::Utc>,
end: chrono::DateTime<chrono::Utc>,
) -> Result<chrono::Duration, Error> {
let repo = get_repo()?;
let mut total_duration = chrono::Duration::seconds(0);
for task in repo.list_tasks()?.values() {
total_duration = total_duration.add(task.duration_between(start, end));
}
Ok(total_dur
```
<Overlap Ratio: 0.8985915492957747>

---

--- 42 --
Question ID: ad7fc4c92fb99953502143eca5e5134c7fe99c12_0
Original Code:
```
fn test_timestamp() -> Result<(), Box<EvalAltResult>> {
    let engine = Engine::new();

    assert_eq!(engine.eval::<String>("type_of(timestamp())")?, "timestamp");

    #[cfg(not(feature = "no_float"))]
    assert!(
        engine.eval::<FLOAT>(
            r#"
                let time = timestamp();
                let x = 10_000;
                while x > 0 { x -= 1; }
                elapsed(time)
    "#
        )? < 10.0
    );

    #[cfg(feature = "no_float")]
    assert!(
        engine.eval::<INT>(
            r#"
                let time = timestamp();
                let x = 10_000;
                while x > 0 { x -= 1; }
                elapsed(time)
    "#
        )? < 10
    );

    assert!(engine.eval::<bool>(
        r"
            let time1 = timestamp();
            for x in range(0, 10000) {}
            let time2 = timestamp();
            time1 <= time2
        "
    )?);

    Ok(())
}
```


Overlapping Code:
```
() -> Result<(), Box<EvalAltResult>> {
let engine = Engine::new();
assert_eq!(engine.eval::<String>("type_of(timestamp())")?, "timestamp");
#[cfg(not(feature = "no_float"))]
assert!(
engine.eval::<FLOAT>(
r#"
let time = timestamp();
let x = 10_000;
while x > 0 { x -= 1; }
elapsed(time)
"#
)? < 10.0
);
#[cfg(feature = "no_float")]
assert!(
engine.eval::<INT>(
r#"
let time = timestamp();
let x = 10_000;
while x > 0 { x -= 1; }
elapsed(time)
"#
)? < 10
);
assert!(engine.eval::<bool>(
r"
let time1 = timestamp();
for x in range(0, 10000) {}
let time2
```
<Overlap Ratio: 0.8973941368078175>

---

--- 43 --
Question ID: d3cb1caf0f4985c176855d204e8bcd8abc4de32e_9
Original Code:
```
fn generic_example_struct2() {
    let arg = GenericExampleStruct {
        a: 123 as i32,
        b: 456 as i32,
    };

    let expected_ast = ASTNode::from(ASTAggregate {
        context: b"genfoo2",
        name: b"GenericExampleStruct".to_vec(),
        elems: vec![
            ASTNode::from(ASTPrimitive {
                context: b"a",
                type_name: b"int",
                data: 123u32.to_le_bytes().to_vec(),
            }),
            ASTNode::from(ASTPrimitive {
                context: b"b",
                type_name: b"int",
                data: 456u32.to_le_bytes().to_vec(),
            }),
        ],
        is_completed: true,
    });
    digestible_test_case_ast("genfoo2", &arg, expected_ast.clone());
    assert_eq!(
        arg.digest32::<MerlinTranscript>(b"genfoo2"),
        [
            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,
            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198
        ]
    );

    let arg2 = GenericExampleStruct {
        a: Some(123 as i32),
        b: Some(456 as i32),
    };

    digestible_test_case_ast("genfoo2", &arg2, expected_ast);
    assert_eq!(
        arg2.digest32::<MerlinTranscript>(b"genfoo2"),
        [
            27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,
            238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198
        ]
    );
}
```


Overlapping Code:
```
e_struct2() {
let arg = GenericExampleStruct {
a: 123 as i32,
b: 456 as i32,
};
let expected_ast = ASTNode::from(ASTAggregate {
context: b"genfoo2",
name: b"GenericExampleStruct".to_vec(),
elems: vec![
ASTNode::from(ASTPrimitive {
context: b"a",
type_name: b"int",
data: 123u32.to_le_bytes().to_vec(),
}),
ASTNode::from(ASTPrimitive {
context: b"b",
type_name: b"int",
data: 456u32.to_le_bytes().to_vec(),
}),
],
is_completed: true,
});
digestible_test_case_ast("genfoo2", &arg, expected_ast.clone());
assert_eq!(
arg.digest32::<MerlinTranscript>(b"genfoo2"),
[
27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,
238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 217, 198
]
);
let arg2 = GenericExampleStruct {
a: Some(123 as i32),
b: Some(456 as i32),
};
digestible_test_case_ast("genfoo2", &arg2, expected_ast);
assert_eq!(
arg2.digest32::<MerlinTranscript>(b"genfoo2"),
[
27, 164, 2, 106, 152, 28, 209, 36, 245, 234, 252, 175, 99, 43, 159, 210, 187, 204, 78,
238, 220, 43, 143, 239, 232, 89, 245, 87, 170, 14, 
```
<Overlap Ratio: 0.9704251386321626>

---

--- 44 --
Question ID: b52cb94f11dc694822e57050c8da63c984116cbb_1
Original Code:
```
pub fn start_stored<'a>(conf_paths: &[&str], lock: &'a ProcLock, filter: LevelFilter) -> Proc<'a> {
    build_stored();

    let mut proc = lock.lock().unwrap();
    let processes = if let Some(proc) = &mut *proc {
        proc.clone()
    } else {
        let mut processes = Vec::with_capacity(conf_paths.len());

        for conf_path in conf_paths {
            let mut child = Command::new(env!("CARGO_BIN_EXE_stored"));

            let capturing_output = if filter == LevelFilter::Off {
                child.stderr(Stdio::null()).stdout(Stdio::null());
                false
            } else {
                child
                    .stderr(Stdio::piped())
                    .stdout(Stdio::piped())
                    .env("LOG_LEVEL", filter.to_string());
                if filter >= LevelFilter::Debug {
                    // Gets a little noisy otherwise.
                    child.env("LOG_TARGET", "stored");
                }
                true
            };

            let mut child = child
                .stdin(Stdio::null())
                .arg(conf_path)
                .spawn()
                .map(|inner| ChildCommand { inner })
                .expect("unable to start server");

            if capturing_output {
                let stdout = Receiver::from(child.inner.stdout.take().unwrap());
                stdout.set_nonblocking(true).unwrap();
                STDOUT.lock().unwrap().push(Some(stdout));

                let stderr = Receiver::from(child.inner.stderr.take().unwrap());
                stderr.set_nonblocking(true).unwrap();
                STDERR.lock().unwrap().push(Some(stderr));

                match &mut *RELAY.lock().unwrap() {
                    relay @ None => {
                        let poll = Poll::new().unwrap();
                        let new_waker = Waker::new(poll.registry(), NEW_PROCESS).unwrap();
                        let handle = thread::spawn(move || relay_process_output(poll));
                        // Ensure it will add the new output.
                        new_waker.wake().unwrap();
                        let handle = WaitHandle {
                            handle: Some(handle),
                        };
                        *relay = Some((new_waker, handle));
                    }
                    Some((waker, ..)) => waker.wake().unwrap(),
                }
            }

            processes.push(child);
        }

        // Give the processes some time to start and sync up.
        if conf_paths.len() == 1 {
            sleep(Duration::from_millis(200));
        } else {
            sleep(Duration::from_millis(processes.len() as u64 * 300));
        }

        let processes = Arc::new(processes.into_boxed_slice());
        proc.replace(processes.clone());
        processes
    };
    Proc { lock, processes }
}
```


Overlapping Code:
```
 fn start_stored<'a>(conf_paths: &[&str], lock: &'a ProcLock, filter: LevelFilter) -> Proc<'a> {
build_stored();
let mut proc = lock.lock().unwrap();
let processes = if let Some(proc) = &mut *proc {
proc.clone()
} else {
let mut processes = Vec::with_capacity(conf_paths.len());
for conf_path in conf_paths {
let mut child = Command::new(env!("CARGO_BIN_EXE_stored"));
let capturing_output = if filter == LevelFilter::Off {
child.stderr(Stdio::null()).stdout(Stdio::null());
false
} else {
child
.stderr(Stdio::piped())
.stdout(Stdio::piped())
.env("LOG_LEVEL", filter.to_string());
if filter >= LevelFilter::Debug {
// Gets a little noisy otherwise.
child.env("LOG_TARGET", "stored");
}
true
};
let mut child = child
.stdin(Stdio::null())
.arg(conf_path)
.spawn()
.map(|inner| ChildCommand { inner })
.expect("unable to start server");
if capturing_output {
let stdout = Receiver::from(child.inner.stdout.take().unwrap());
stdout.set_nonblocking(true).unwrap();
STDOUT.lock().unwrap().push(Some(stdout));
let stderr = Receiver::from(child.inner.stderr.take().unwrap());
stderr.set_nonblocking(true).unwrap();
STDERR.lock().unwrap().push(Some(stderr));
match &mut *RELAY.lock().unwrap() {
relay @ None => {
let poll = Poll::new().unwrap();
let new_waker = Waker::new(poll.registry(), NEW_PROCESS).unwrap();
let handle = thread::spawn(move || relay_process_output(poll));
// Ensure it will add the new output.
new_waker.wake().unwrap();
let handle = WaitHandle {
handle: Some(handle),
};
*relay = Some((new_waker, handle));
}
Some((waker, ..)) => waker.wake().unwrap(),
}
}
processes.push(child);
}
// Give the processes some time to start and sync up
```
<Overlap Ratio: 0.9975816203143894>

---

--- 45 --
Question ID: 0bbfcbabf56ddedfc277662426ff2a2a09e31612_8
Original Code:
```
fn test_compare_backward() {
        let compare = |east, north| {
            let a = backward_ref(Point3035::new(east, north));
            let b = backward(Point3035::new(east, north));
            assert_approx_eq(a.coords.0, b.coords.0, 1e-6);
            assert_approx_eq(a.coords.1, b.coords.1, 1e-6);
        };
        compare(3962799.45, 2999718.85);
        compare(3963799.45, 2998718.85);
    }
```


Overlapping Code:
```
mpare = |east, north| {
let a = backward_ref(Point3035::new(east, north));
let b = backward(Point3035::new(east, north));
assert_approx_eq(a.coords.0, b.coords.0, 1e-6);
assert_approx_eq(a.coords.1, b.coords.1, 1e-6);
};
compare(3962799.45, 2999718.8
```
<Overlap Ratio: 0.7739938080495357>

---

--- 46 --
Question ID: 9db605c1484379e94b041d4898aad9d9e67107f0_2
Original Code:
```
unsafe fn perform_impl(
    request: *const u8,
    request_length: i32,
    response: *mut u8,
    response_length: i32,
) -> Result<i32> {
    let request_data = std::slice::from_raw_parts(request, request_length as usize);
    let game_request = GameRequest::decode(request_data)?;
    let command_list = requests::perform_action(game_request)?;
    let mut out = std::slice::from_raw_parts_mut(response, response_length as usize);
    command_list.encode(&mut out)?;
    Ok(command_list.encoded_len() as i32)
}
```


Overlapping Code:
```
st: *const u8,
request_length: i32,
response: *mut u8,
response_length: i32,
) -> Result<i32> {
let request_data = std::slice::from_raw_parts(request, request_length as usize);
let game_request = GameRequest::decode(request_data)?;
let command_list = requests::perform_action(game_request)?;
let mut out = std::slice::from_raw_parts_mut(response, response_length as usize);
command_list.encode(&mut out)?
```
<Overlap Ratio: 0.8523206751054853>

---

--- 47 --
Question ID: b644796625e67076767bdf93763db5546cc90c1b_33
Original Code:
```
pub fn rtr_32<T: Core>(core: &mut T) -> Result<Cycles> {
    let new_ccr = core.pop_16();
    let new_pc = core.pop_32();
    core.jump(new_pc);
    core.ccr_to_flags(new_ccr);
    Ok(Cycles(20))
}
```


Overlapping Code:
```
) -> Result<Cycles> {
let new_ccr = core.pop_16();
let new_pc = core.pop_32();
core.jump(new_pc);
co
```
<Overlap Ratio: 0.5649717514124294>

---

--- 48 --
Question ID: 84101b5d04fcf51b77186f65bc58668bbf6c2c4e_36
Original Code:
```
fn chunk_response_iterator_across_pages() {
        let config = helper_create_config(5);
        let page_creator = PageCreator::new();
        let db = util::database::temp().unwrap();
        assert!(create_page_template(&config).is_ok());

        let request = Request::new(
            "p1", // package_id
            vec![Channel::new(
                // channels
                "cache_c1_r2",
                1e6,
            )],
            10,    // start
            19,    // end
            10,    // chunk_size
            false, // use_cache
        );

        let response = request.get_response(&config);

        let page = Page {
            path: path!(&*TEMP_DIR, "p1", "cache_c1_r2", "5", "2"; extension => "bin"),
            start: 0,
            end: 0,
            size: 5,
            id: 2,
        };
        let key = page_key(
            request.package_id(),
            request.channels[0].id(),
            config.page_size(),
            page.id,
        );
        db.upsert_page(&database::PageRecord::new(
            key,
            false,
            true,
            config.page_size() as i64,
        ))
        .unwrap();
        let page2 = Page {
            path: path!(&*TEMP_DIR, "p1", "cache_c1_r2", "5", "3"; extension => "bin"),
            start: 0,
            end: 0,
            size: 5,
            id: 3,
        };
        let key = page_key(
            request.package_id(),
            request.channels[0].id(),
            config.page_size(),
            page2.id,
        );
        db.upsert_page(&database::PageRecord::new(
            key,
            false,
            true,
            config.page_size() as i64,
        ))
        .unwrap();

        let data: [f64; 10] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];

        assert!(page.write(&page_creator, &config, 0, &data[0..5]).is_ok());
        assert!(page2.write(&page_creator, &config, 0, &data[5..10]).is_ok());

        let mut iter = response.owned_chunk_response_iter(db);

        let mut chunk = ChunkResponse::new();
        chunk.set_channels(RepeatedField::from_vec(Vec::new()));
        chunk.channels.push(proto::create_channel_chunk(
            String::from("cache_c1_r2"),
            vec![
                proto::create_datum(10, 0.0),
                proto::create_datum(11, 1.0),
                proto::create_datum(12, 2.0),
                proto::create_datum(13, 3.0),
                proto::create_datum(14, 4.0),
                proto::create_datum(15, 5.0),
                proto::create_datum(16, 6.0),
                proto::create_datum(17, 7.0),
                proto::create_datum(18, 8.0),
                proto::create_datum(19, 9.0),
            ],
        ));

        assert_eq!(helper_convert_chunk(&iter.next().unwrap().unwrap()), chunk);
        assert!(iter.next().is_none());
    }
```


Overlapping Code:
```
terator_across_pages() {
let config = helper_create_config(5);
let page_creator = PageCreator::new();
let db = util::database::temp().unwrap();
assert!(create_page_template(&config).is_ok());
let request = Request::new(
"p1", // package_id
vec![Channel::new(
// channels
"cache_c1_r2",
1e6,
)],
10, // start
19, // end
10, // chunk_size
false, // use_cache
);
let response = request.get_response(&config);
let page = Page {
path: path!(&*TEMP_DIR, "p1", "cache_c1_r2", "5", "2"; extension => "bin"),
start: 0,
end: 0,
size: 5,
id: 2,
};
let key = page_key(
request.package_id(),
request.channels[0].id(),
config.page_size(),
page.id,
);
db.upsert_page(&database::PageRecord::new(
key,
false,
true,
config.page_size() as i64,
))
.unwrap();
let page2 = Page {
path: path!(&*TEMP_DIR, "p1", "cache_c1_r2", "5", "3"; extension => "bin"),
start: 0,
end: 0,
size: 5,
id: 3,
};
let key = page_key(
request.package_id(),
request.channels[0].id(),
config.page_size(),
page2.id,
);
db.upsert_page(&database::PageRecord::new(
key,
false,
true,
config.page_size() as i64,
))
.unwrap();
let data: [f64; 10] = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
assert!(page.write(&page_creator, &config, 0, &data[0..5]).is_ok());
assert!(page2.write(&page_creator, &config, 0, &data[5..10]).is_ok());
let mut iter = response.owned_chunk_response_iter(db);
let mut chunk = ChunkResponse::new();
chunk.set_channels(RepeatedField::from_vec(Vec::new()));
chunk.channels.push(proto::create_channel_chunk(
String::from("cache_c1_r2"),
vec![
proto::create_datum(10, 0.0),
proto::create_datum(11, 1.0),
proto::create_datum(12, 2.0),
proto::create_datum(13, 3.0),
proto::create_datum(1
```
<Overlap Ratio: 0.9811209439528024>

---

--- 49 --
Question ID: 9c1c5f7dc7aec65b223ee08ce83976aa8406b267_0
Original Code:
```
fn rountrip_basic() {
        let from_keypair = Keypair::gen_keypair();
        let format = format::Basic {
            pwhash: PWHash::argon2id13_default(),
        };
        let password = b"passsword";
        let wallet = Wallet::encrypt(&from_keypair, password, Format::Basic(format))
            .expect("wallet creation");
        let to_keypair = wallet.decrypt(password).expect("wallet to keypair");
        assert_eq!(from_keypair, to_keypair);
    }
```


Overlapping Code:
```
let from_keypair = Keypair::gen_keypair();
let format = format::Basic {
pwhash: PWHash::argon2id13_det wallet = Wallet::encrypt(&from_keypair, password, Format::Basic(format))
.expect("wallet creation");
let to_keypair = wallet.decrypt(password).expect("wallet to keypair");
assert_eq!(from_keypair, to_keyp
```
<Overlap Ratio: 0.8100263852242744>

---

--- 50 --
Question ID: 61bd17c47b1075379112034e748e6260ca2c3604_33
Original Code:
```
pub(crate) fn __reduce31<
        'err,
        'input,
        'v,
    >(
        input: &'input str,
        errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>,
        validator: &'v mut VariableValidator<'input>,
        __lookahead_start: Option<&usize>,
        __symbols: &mut alloc::vec::Vec<(usize,__Symbol<'input>,usize)>,
        _: core::marker::PhantomData<(&'err (), &'input (), &'v ())>,
    ) -> (usize, usize)
    {
        // CallInstrValue = InitPeerId => ActionFn(28);
        let __sym0 = __pop_Variant0(__symbols);
        let __start = __sym0.0.clone();
        let __end = __sym0.2.clone();
        let __nt = super::__action28::<>(input, errors, validator, __sym0);
        __symbols.push((__start, __Symbol::Variant13(__nt), __end));
        (1, 10)
    }
```


Overlapping Code:
```
<
'err,
'input,
'v,
>(
input: &'input str,
errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, ParserError>>,
validator: &'v mut VariableValidator<'input>,
__lookahead_start: Option<&usize>,
__symbols: &mut alloc::vec::Vec<(usize,__Symbol<'input>,usize)>,
_: core::marker::PhantomData<(&'err (), &'input (), &'v ())>,
) -> (usize, usize)
{
// CallInstrValue = InitPeerId => ActionFn(28);
let __sym0 = __pop_Variant0(__symbols);
let __start = __sym0.0.clone();
let __end = __sym0.2.clone();
let __nt = super::__action28::<>(input, errors, validator, __sym0);
__symbols.push((__start, __Symbol::Variant13(__nt), __end));
(1,
```
<Overlap Ratio: 0.9544072948328267>

---

--- 51 --
Question ID: c240406724e617c2807b34cce868240a68adda52_1
Original Code:
```
fn check_datarate(hex: &str, datarate: f32) {
        let vht = Vht::from_hex(hex);
        let users: Vec<_> = vht.users().into();
        let datarates: Vec<_> = users
            .into_iter()
            .map(|o| o.map(|u| u.to_mbps()).flatten().map(|r| r.unwrap()))
            .collect();
        assert_eq!(datarates, vec![Some(datarate), None, None, None]);
    }
```


Overlapping Code:
```
 f32) {
let vht = Vht::from_hex(hex);
let users: Vec<_> = vht.users().into();
let datarates: Vec<_> = users
.into_iter()
.map(|o| o.map(|u| u.to_mbps()).flatten().map(|r| r.unwrap()))
.collect();
assert_eq!(datarates, vec![Some(datarate), None, None,
```
<Overlap Ratio: 0.8389261744966443>

---

--- 52 --
Question ID: c4001d92813efe98b1ad1f35333b7754bae617b4_0
Original Code:
```
async fn test_download_file() {
        let mut client = TgClient::new(&Config {
            max_download_queue_size: 1,
            log_download_state_secs_interval: 100,
            log_verbosity_level: 0,
            encryption_key: "",
            database_directory: "",
            api_id: 0,
            api_hash: "",
            phone_number: "",
        });
        client.api = Box::new(MockedApi);

        client.download_file(1).await;
        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        client.download_file(1).await;
        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        client.download_file(2).await;
        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        let (sender, receiver) = mpsc::channel(1);
        let chann = Arc::new(AsyncMutex::new(sender));
        let download_finished_handler =
            get_update_file_handler(chann, client.download_queue.clone());
        let eapi = EventApi::new(Api::default());

        download_finished_handler((
            &eapi,
            &UpdateFile::builder()
                .file(
                    File::builder()
                        .local(LocalFile::builder().is_downloading_completed(false).build()),
                )
                .build(),
        ));

        // no changes
        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        download_finished_handler((
            &eapi,
            &UpdateFile::builder()
                .file(
                    File::builder()
                        .id(10)
                        .local(LocalFile::builder().is_downloading_completed(true).build()),
                )
                .build(),
        ));

        // no changes: file not in progress
        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        download_finished_handler((
            &eapi,
            &UpdateFile::builder()
                .file(
                    File::builder()
                        .id(1)
                        .local(LocalFile::builder().is_downloading_completed(true).build()),
                )
                .build(),
        ));
        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![2]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![1]
        );

        download_finished_handler((
            &eapi,
            &UpdateFile::builder()
                .file(
                    File::builder()
                        .id(1)
                        .local(LocalFile::builder().is_downloading_completed(true).build()),
                )
                .build(),
        ));
        assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![2]
        );

        client.download_file(3).await;
        client.download_file(4).await;
        client.download_file(5).await;

        download_finished_handler((
            &eapi,
            &UpdateFile::builder()
                .file(
                    File::builder()
                        .id(2)
                        .local(LocalFile::builder().is_downloading_completed(true).build()),
                )
                .build(),
        ));

        assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![4, 5]);
        assert_eq!(
            client.download_queue.lock().unwrap().in_progress(),
            &vec![3]
        );
    }
```


Overlapping Code:
```
oad_file() {
let mut client = TgClient::new(&Config {
max_download_queue_size: 1,
log_download_state_secs_interval: 100,
log_verbosity_level: 0,
encryption_key: "",
database_directory: "",
api_id: 0,
api_hash: "",
phone_number: "",
});
client.api = Box::new(MockedApi);
client.download_file(1).await;
assert_eq!(client.download_queue.lock().unwrap().queue().len(), 0);
assert_eq!(
client.download_queue.lock().unwrap().in_progress(),
&vec![1]
);
client.download_file(1).await;
assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1]);
assert_eq!(
client.download_queue.lock().unwrap().in_progress(),
&vec![1]
);
client.download_file(2).await;
assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
assert_eq!(
client.download_queue.lock().unwrap().in_progress(),
&vec![1]
);
let (sender, receiver) = mpsc::channel(1);
let chann = Arc::new(AsyncMutex::new(sender));
let download_finished_handler =
get_update_file_handler(chann, client.download_queue.clone());
let eapi = EventApi::new(Api::default());
download_finished_handler((
&eapi,
&UpdateFile::builder()
.file(
File::builder()
.local(LocalFile::builder().is_downloading_completed(false).build()),
)
.build(),
));
// no changes
assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
assert_eq!(
client.download_queue.lock().unwrap().in_progress(),
&vec![1]
);
download_finished_handler((
&eapi,
&UpdateFile::builder()
.file(
File::builder()
.id(10)
.local(LocalFile::builder().is_downloading_completed(true).build()),
)
.build(),
));
// no changes: file not in progress
assert_eq!(client.download_queue.lock().unwrap().queue(), &vec![1, 2]);
assert_eq!(
client.download_queue.lock().unwrap().in_progress(),
&vec![1]
);
download_fin
```
<Overlap Ratio: 0.9891428571428571>

---

--- 53 --
Question ID: 8afc5fd03c125c114bbce45535e8420c52319003_1
Original Code:
```
fn is_filtered(
    ii: &IterInfo,
    current_day: u64,
    properties: &RRuleProperties,
) -> Result<bool, RRuleError> {
    // TODO break this up into parts because this is unmaintainable.

    let by_month: bool = !properties.by_month.is_empty()
        && !properties
            .by_month
            .contains(&ii.month_mask()[current_day as usize]);

    let by_week_no: bool = !properties.by_week_no.is_empty()
        && (ii.week_no_mask().unwrap()[current_day as usize]) == 0;

    let by_weekday_every_week_only = properties
        .by_weekday
        .iter()
        .filter_map(|by_weekday| match by_weekday {
            // Filter out only `Every` occurrences.
            NWeekday::Every(weekday) => Some(weekday.num_days_from_monday() as i16),
            NWeekday::Nth(_number, _weekday) => None,
        })
        .collect::<Vec<_>>();
    let by_weekday: bool = !by_weekday_every_week_only.is_empty()
        && !includes(
            &by_weekday_every_week_only,
            &(ii.weekday_mask()[current_day as usize] as i16),
        );

    let neg_weekday_mask: bool = ii.neg_weekday_mask().is_some()
        && !ii.neg_weekday_mask().unwrap().is_empty()
        && (ii.neg_weekday_mask().unwrap()[current_day as usize]) == 0;

    // Can only be set to true if feature flag is set.
    let by_easter: bool = if cfg!(feature = "by-easter") {
        properties.by_easter.is_some()
            && !(includes(ii.easter_mask().unwrap(), &(current_day as isize)))
    } else {
        false
    };

    let by_month_day: bool = (!properties.by_month_day.is_empty()
        || !properties.by_n_month_day.is_empty())
        && !includes(
            &properties.by_month_day,
            &(ii.month_day_mask()[current_day as usize]),
        )
        && !includes(
            &properties.by_n_month_day,
            &(ii.neg_month_day_mask()[current_day as usize]),
        );

    let by_year_day: bool = !properties.by_year_day.is_empty()
        && ((current_day < ii.year_len().unwrap() as u64
            && !includes(&properties.by_year_day, &(current_day as i16 + 1))
            && !includes(
                &properties.by_year_day,
                &(current_day as i16 - ii.year_len().unwrap() as i16),
            ))
            || (current_day >= ii.year_len().unwrap() as u64
                && !includes(
                    &properties.by_year_day,
                    &(current_day as i16 + 1 - ii.year_len().unwrap() as i16),
                )
                && !includes(
                    &properties.by_year_day,
                    &(current_day as i16
                        - ii.next_year_len().unwrap() as i16
                        - ii.year_len().unwrap() as i16),
                )));
    Ok(by_month
        || by_week_no
        || by_weekday
        || neg_weekday_mask
        || by_easter
        || by_month_day
        || by_year_day)
}
```


Overlapping Code:
```
&IterInfo,
current_day: u64,
properties: &RRuleProperties,
) -> Result<bool, RRuleError> {
// TODO break this up into parts because this is unmaintainable.
let by_month: bool = !properties.by_month.is_empty()
&& !properties
.by_month
.contains(&ii.month_mask()[current_day as usize]);
let by_week_no: bool = !properties.by_week_no.is_empty()
&& (ii.week_no_mask().unwrap()[current_day as usize]) == 0;
let by_weekday_every_week_only = properties
.by_weekday
.iter()
.filter_map(|by_weekday| match by_weekday {
// Filter out only `Every` occurrences.
NWeekday::Every(weekday) => Some(weekday.num_days_from_monday() as i16),
NWeekday::Nth(_number, _weekday) => None,
})
.collect::<Vec<_>>();
let by_weekday: bool = !by_weekday_every_week_only.is_empty()
&& !includes(
&by_weekday_every_week_only,
&(ii.weekday_mask()[current_day as usize] as i16),
);
let neg_weekday_mask: bool = ii.neg_weekday_mask().is_some()
&& !ii.neg_weekday_mask().unwrap().is_empty()
&& (ii.neg_weekday_mask().unwrap()[current_day as usize]) == 0;
// Can only be set to true if feature flag is set.
let by_easter: bool = if cfg!(feature = "by-easter") {
properties.by_easter.is_some()
&& !(includes(ii.easter_mask().unwrap(), &(current_day as isize)))
} else {
false
};
let by_month_day: bool = (!properties.by_month_day.is_empty()
|| !properties.by_n_month_day.is_empty())
&& !includes(
&properties.by_month_day,
&(ii.month_day_mask()[current_day as usize]),
)
&& !includes(
&properties.by_n_month_day,
&(ii.neg_month_day_mask()[current_day as usize]),
);
let by_year_day: bool = !properties.by_year_day.is_empty()
&& ((current_day < ii.year_len().unwrap() as u64
&& !includes(&properties.by_year_day, &(current_day as i16 + 1))
&& !includes(
&properties.by_year_day,
&(current_day as i16 - ii.year_len().unwrap() as i16),
))
|| (current_day >= ii.year_len().unwrap() as u64
&& !includes(
&properties.by_year_day,
&(current_day
```
<Overlap Ratio: 0.9659379766141332>

---

--- 54 --
Question ID: 10f6c0bb84f13c937bfcd2d15caa9bb7a1ab69f5_6
Original Code:
```
fn name_tables_mirroring() {
        let mut emu = mock_emu_horizontal();
        emu.name_tables[0x0305] = 0x66;
        let mut bus = borrow_ppu_bus!(emu);

        emu.ppu.write(&mut bus, 0x2000, 0b0);

        emu.ppu.write(&mut bus, 0x2006, 0x63); // 0x6305 -> 0x2305
        emu.ppu.write(&mut bus, 0x2006, 0x05);

        emu.ppu.read(&mut bus, 0x2007);
        assert_eq!(emu.ppu.read(&mut bus, 0x2007), 0x66);
    }
```


Overlapping Code:
```
s_mirroring() {
let mut emu = mock_emu_horizontal();
emu.name_tables[0x0305] = 0x66;
let mut bus = borrow_ppu_bus!(emu);
emu.ppu.write(&mut bus, 0x2000, 0b0);
emu.ppu.write(&mut bus, 0x2006, 0x63); // 0x6305 -> 0x2305
emu.ppu.write(&mut bus, 0x2006, 0x05);
emu.ppu.read(&mut bus, 0x2007);
assert_eq!(emu.ppu.read(&mut bus, 0x2007), 0x66);
```
<Overlap Ratio: 0.9575070821529745>

---

--- 55 --
Question ID: b299af364153005aefc827c5c50dea5d0a6f7c44_0
Original Code:
```
fn main() {
    let input = fs::read_to_string("input.txt").expect("Error reading input.txt");

    let food = Food::from_str(&input).unwrap();

    println!(
        "How many times do any of those ingredients appear? {}",
        food.get_safe_count(),
    );

    println!(
        "What is your canonical dangerous ingredient list? {}",
        food.get_canonical_dangerous_ingredients(),
    );
}
```


Overlapping Code:
```
n main() {
let input = fs::read_to_string("input.txt").expect("Error reading input.txt");
let food = Food::from_str(&input).unwrap();
println!(
"How many times do any of those ingredients appear? {}",
food.get_safe_count(),
);
println!(
"What is your canonical dangerous ingredient list? {}",
food.get_canonical_dangerous_ingredient
```
<Overlap Ratio: 0.9707602339181286>

---

--- 56 --
Question ID: 901595a7bbe434dc174cef7f75fa9977d9dc48b6_0
Original Code:
```
pub fn test() -> Result<()> {
    let mut renderer = Renderer::new();
    renderer.test()?;

    Ok(())
}
```


Overlapping Code:
```
 mut renderer = Renderer::new();
renderer.test()?;
```
<Overlap Ratio: 0.5434782608695652>

---

--- 57 --
Question ID: 274f4e4e8a1f7761e9d1175b4436b1bafe05a11e_0
Original Code:
```
fn input_style_tailwind_grid() -> InputStyle{
    let minor_height = "h-6";
    let major_height = "h-10";
    InputStyle {
        label: (
            style! {},
            class![
                "w-auto",
                "text-right",
                "box-border"
                , "pt-2 pb-2 pl-2",
                major_height
            ],
        ),
        input:  (
            style! {},
            class!["border-solid border-2 border-gray-400 focus:border-yellow-500 w-full outline-none", "p-2", major_height],
        ),
        guidance:   (
                style! {},
                class!["w-auto text-sm text-right text-gray-600", minor_height],
            ),
        label_and_guidance:(
            style! {},
            class!["flex flex-col col-start-1 col-end-1"],
        ),
        validation_position:(
            style! {},
            class!["flex flex-col"],
        ),
        input_and_validation:  (
            style! {},
            class![
                   "col-start-3",
                    "col-end-4",
                    // tailwind.config.js
                    //
                    // module.exports = {
                    //     theme: {
                    //       extend: {
                    //         gridTemplateColumns: {
                    //           // Simple 16 column grid
                    //   +       'form': ' 1fr 1em 2fr',
                    //         }
                    //       }
                    //     }
                    //   }
                    ],
        ),
        validation_errors:   (
            style! {
            },
            class!["w-auto text-sm text-right text-red-600", minor_height],
        ),
 
        invalid_input: ( style!{},class![
            "border-solid border-2 border-red-400"
        ]),

        container   :(
            style! {St::GridTemplateColumns => "1fr 0.5em 2fr"},
            class!["grid grid-flow-row-dense row-gap-1 col-gap-1 p-4"],
        ),
    }
}
```


Overlapping Code:
```
nd_grid() -> InputStyle{
let minor_height = "h-6";
let major_height = "h-10";
InputStyle {
label: (
style! {},
class![
"w-auto",
"text-right",
"box-border"
, "pt-2 pb-2 pl-2",
major_height
],
),
input: (
style! {},
class!["border-solid border-2 border-gray-400 focus:border-yellow-500 w-full outline-none", "p-2", major_height],
),
guidance: (
style! {},
class!["w-auto text-sm text-right text-gray-600", minor_height],
),
label_and_guidance:(
style! {},
class!["flex flex-col col-start-1 col-end-1"],
),
validation_position:(
style! {},
class!["flex flex-col"],
),
input_and_validation: (
style! {},
class![
"col-start-3",
"col-end-4",
// tailwind.config.js
//
// module.exports = {
// theme: {
// extend: {
// gridTemplateColumns: {
// // Simple 16 column grid
// + 'form': ' 1fr 1em 2fr',
// }
// }
// }
// }
],
),
validation_errors: (
style! {
},
class!["w-auto text-sm text-right text-red-600", minor_height],
),

invalid_input: ( style!{},class![
"border-solid border-2 border-red-400"
]),
container :(
style! {St::GridTemplateColumns => "1fr 0.5em 2fr"},
class!["grid grid-flow-row-dense row-g
```
<Overlap Ratio: 0.9573542210617929>

---

--- 58 --
Question ID: d7b5ce6bf507c784ac5ea5fdf736c7677069e7ec_0
Original Code:
```
fn check() {
        let mut pool: SyncPool<[u8; 32]> = SyncPool::with_size(12);

        for _ in 0..32 {
            let ary = pool.get();
            assert_eq!(ary.len(), 32);
            pool.put(ary);
        }

        assert!(pool.len() > 0);
    }
```


Overlapping Code:
```
 mut pool: SyncPool<[u8; 32]> = SyncPool::with_size(12);
for _ in 0..32 {
let ary = pool.get();
assert_eq!(ary.len(), 32);
pool.put(ary);
}
assert!(po
```
<Overlap Ratio: 0.8241758241758241>

---

--- 59 --
Question ID: be54b322e89d117a290068007a7da1bcbcfb74aa_5
Original Code:
```
pub fn perpendicular_bisector(p1: &Multivector, p2: &Multivector) -> Multivector {
    let p1 = p1.normalized();
    let p2 = p2.normalized();

    let midpoint = midpoint(&p1, &p2);
    let line_between = p1.join(&p2);

    orthogonal(&midpoint, &line_between)
}
```


Overlapping Code:
```
r(p1: &Multivector, p2: &Multivector) -> Multivector {
let p1 = p1.normalized();
let p2 = p2.normalized();
let midpoint = midpoint(&p1, &p2);
let line_between = p1.join(&p2);
orthogonal(&midpoint, &li
```
<Overlap Ratio: 0.8298755186721992>

---

--- 60 --
Question ID: 020acb8f778b98099a1f61c29d6c6b844e020097_0
Original Code:
```
fn find_best_stream_config(device: &cpal::Device) -> Result<cpal::SupportedStreamConfig, Error> {
    let default_config = device.default_output_config()
        .context("failed to retrieve default audio stream  config")?;

    // If the default config has all properties we certainly want, we
    // immediately take it.
    if default_config.channels() == 2 && default_config.sample_format() == SampleFormat::F32 {
        return Ok(default_config);
    }

    // Otherwise, we have to search through all other configs to find one.
    let mut supported_configs = device.supported_output_configs()
        .context("could not retrieve supported configs from audio device")?
        .filter(|config| config.channels() == 2)
        .collect::<Vec<_>>();

    if supported_configs.is_empty() {
        bail!("your default audio device does not support stereo");
    }

    debug!("Supported stereo audio config ranges: {:#?}", supported_configs);

    // Sort by sample format as we prefer `f32` samples.
    supported_configs.sort_by_key(|config| config.sample_format().sample_size());
    let candidate = supported_configs.pop().unwrap();

    let default_sample_rate = default_config.sample_rate();
    let supported_sample_rates = candidate.min_sample_rate()..candidate.max_sample_rate();

    for sample_rate in &[default_sample_rate, SampleRate(44100), SampleRate(48000)] {
        if supported_sample_rates.contains(sample_rate) {
            return Ok(candidate.with_sample_rate(default_sample_rate));
        }
    }

    Err(format_err!("could not find a stereo audio stream config with an expected sample rate"))
}
```


Overlapping Code:
```
l::Device) -> Result<cpal::SupportedStreamConfig, Error> {
let default_config = device.default_output_config()
.context("failed to retrieve default audio stream config")?;
// If the default config has all properties we certainly want, we
// immediately take it.
if default_config.channels() == 2 && default_config.sample_format() == SampleFormat::F32 {
return Ok(default_config);
}
// Otherwise, we have to search through all other configs to find one.
let mut supported_configs = device.supported_output_configs()
.context("could not retrieve supported configs from audio device")?
.filter(|config| config.channels() == 2)
.collect::<Vec<_>>();
if supported_configs.is_empty() {
bail!("your default audio device does not support stereo");
}
debug!("Supported stereo audio config ranges: {:#?}", supported_configs);
// Sort by sample format as we prefer `f32` samples.
supported_configs.sort_by_key(|config| config.sample_format().sample_size());
let candidate = supported_configs.pop().unwrap();
let default_sample_rate = default_config.sample_rate();
let supported_sample_rates = candidate.min_sample_rate()..candidate.max_sample_rate();
for sample_rate in &[default_sample_rate, SampleRate(44100), SampleRate(48000)] {
if supported_sample_rates.contains(sample_rate) {
return Ok(candidate.with_sample_rate(default_sample_rate));
}
}
Err(format_err!("could not find a stereo audio stream config wit
```
<Overlap Ratio: 0.9530292716133424>

---

--- 61 --
Question ID: 94f97bf6e490a678dfe1faa198de6c5a7be2c099_0
Original Code:
```
fn main() {
    let att = DataType::INT;
    let att2 = DataType::INT;
    assert_eq!(att, att2);
    print!("A");
    print!("B");
    println!("C");
    print!("D");
}
```


Overlapping Code:
```
t2 = DataType::INT;
assert_eq!(att, att2);
print!(
```
<Overlap Ratio: 0.3546099290780142>

---

--- 62 --
Question ID: c7ede2142c618cfc3b5701899ed3a38cef74804b_21
Original Code:
```
fn get_boolean() {
        let jvm = JVM.lock().unwrap();
        let env = jvm.attach_current_thread().unwrap();

        let boolean = Object::new_boolean_object(&env, true).unwrap();
        let value = boolean.get_boolean().unwrap();

        assert_eq!(true, value);
    }
```


Overlapping Code:
```
() {
let jvm = JVM.lock().unwrap();
let env = jvm.attach_current_thread().unwrap();
let boolean = Object::new_boolean_object(&env, true).unwrap();
let value = boolean.get_boolean().unwrap();
assert_eq
```
<Overlap Ratio: 0.8658008658008658>

---

--- 63 --
Question ID: ca58661d0ee5543b6957342daa3e5bc870a956d7_7
Original Code:
```
pub fn multiple_two_sum(xs: &[f64]) -> (f64, f64) {
        let (mut r0, mut r1) = (*xs.get(0).unwrap_or(&0.), 0.);
        for &x in xs.iter() {
            let (s, e) = two_sum(r0, x);
            r0 = s;
            r1 += e;
        }
        (r0, r1)
    }
```


Overlapping Code:
```
e_two_sum(xs: &[f64]) -> (f64, f64) {
let (mut r0, mut r1) = (*xs.get(0).unwrap_or(&0.), 0.);
for &x in xs.iter() {
let (s, e) = two_sum(r0, x);
r0 = 
```
<Overlap Ratio: 0.7978723404255319>

---

--- 64 --
Question ID: 3e370f719b850b7f0224ce4b7075057418a987d3_8
Original Code:
```
fn cc_compile(target_env: Environment) {
    let root = env::current_dir().unwrap().join("PhysX/physx");

    let ccenv = target_env;

    let mut ctx = Context {
        builder: cc::Build::new(),
        root,
        env: ccenv,
        includes: Vec::with_capacity(1000),
    };

    add_common(&mut ctx);

    // Add the sources and includes for each major physx component
    fastxml(&mut ctx);
    task(&mut ctx);
    foundation(&mut ctx);
    lowlevel(&mut ctx);
    lowlevelaabb(&mut ctx);
    lowleveldynamics(&mut ctx);
    vehicle(&mut ctx);
    extensions(&mut ctx);
    physxcharacterkinematic(&mut ctx);
    common(&mut ctx);
    geomutils(&mut ctx);
    cooking(&mut ctx);
    pvd(&mut ctx);
    physx(&mut ctx);
    scenequery(&mut ctx);
    simulationcontroller(&mut ctx);

    ctx.includes.push(ctx.root.join("source/pvd/include"));

    // Strip out duplicate include paths, C++ already has it hard enough as it is
    ctx.includes.sort();
    ctx.includes.dedup();

    for dir in ctx.includes {
        ctx.builder.include(dir);
    }

    ctx.builder.compile("physx");
}
```


Overlapping Code:
```
{
let root = env::current_dir().unwrap().join("PhysX/physx");
let ccenv = target_env;
let mut ctx = Context {
builder: cc::Build::new(),
root,
env: ccenv,
includes: Vec::with_capacity(1000),
};
add_common(&mut ctx);
// Add the sources and includes for each major physx component
fastxml(&mut ctx);
task(&mut ctx);
foundation(&mut ctx);
lowlevel(&mut ctx);
lowlevelaabb(&mut ctx);
lowleveldynamics(&mut ctx);
vehicle(&mut ctx);
extensions(&mut ctx);
physxcharacterkinematic(&mut ctx);
common(&mut ctx);
geomutils(&mut ctx);
cooking(&mut ctx);
pvd(&mut ctx);
physx(&mut ctx);
scenequery(&mut ctx);
simulationcontroller(&mut ctx);
ctx.includes.push(ctx.root.join("source/pvd/include"));
// Strip out duplicate include paths, C++ already has it hard enough as it is
ctx.includes.sort();
ctx.includes.dedup();
for dir in ctx.includes {
ctx.builder.include
```
<Overlap Ratio: 0.9149623250807319>

---

--- 65 --
Question ID: af364db3b5951c6f44dd477bc6da9885f136d0e0_1
Original Code:
```
fn find_target_profile_dir(dir: PathBuf) -> Option<PathBuf> {
    //out dir looks like ...\plctag-rs\target\debug\build\XXXXX
    //profile dir looks like ...\plctag-rs\target\debug\
    let mut dir = dir;
    loop {
        if let Some(p) = dir.parent() {
            let buf = p.to_path_buf();
            if buf.ends_with("build") {
                return Some(buf.parent().unwrap().to_path_buf());
            }
            dir = buf;
        } else {
            return None;
        }
    }
}
```


Overlapping Code:
```
le_dir(dir: PathBuf) -> Option<PathBuf> {
//out dir looks like ...\plctag-rs\target\debug\build\XXXXX
//profile dir looks like ...\plctag-rs\target\debug\
let mut dir = dir;
loop {
if let Some(p) = dir.parent() {
let buf = p.to_path_buf();
if buf.ends_with("build") {
return Some(buf.parent().unwrap().to_path_buf());
}
dir = buf;
} else {
return Non
```
<Overlap Ratio: 0.9259259259259259>

---

--- 66 --
Question ID: 38efdbd359a5c1199b149f45932d73e986995b52_0
Original Code:
```
fn hash_string(ctx: CallContext) -> Result<JsString> {
  let s = ctx.get::<JsString>(0)?.into_utf8()?;
  let s = s.as_slice();
  let res = xxh3_64(s);
  let res_str = format!("{:016x}", res);
  return ctx.env.create_string_from_std(res_str);
}
```


Overlapping Code:
```
string(ctx: CallContext) -> Result<JsString> {
let s = ctx.get::<JsString>(0)?.into_utf8()?;
let s = s.as_slice();
let res = xxh3_64(s);
let res_str = format!("{:016x}", res);
return ctx.env.create_string_
```
<Overlap Ratio: 0.8798283261802575>

---

--- 67 --
Question ID: a4880c41513b5b92bcf98ea4ca8a35339d525dc5_0
Original Code:
```
pub fn inventory_item_reveal_system(
    mut inventory_query: Query<&mut Inventory>,
    mut object_query: Query<(&Object, &mut Visible, &mut Collider, &Handle<Map>)>,
    game: Res<Game>,
) {
    let mut do_reveal = false;
    let mut total_gems = 0;
    for inventory in inventory_query.iter_mut() {
        total_gems += inventory.num_gems;
    }
    if total_gems >= 4 {
        do_reveal = true;
    }
    if do_reveal {
        for (object, mut visible, mut collider, map_handle) in object_query.iter_mut() {
            // only reveal if it's invisible
            if visible.is_visible {
                continue;
            }
            if total_gems >= 8 && object.name.starts_with("load:") {
                // show hidden portals when you have enough gems
                visible.is_visible = true;
                collider.insert_behavior(ColliderBehavior::Load { path: object.name[5..].to_string() });
                // clear inventory for new map
                for mut items in inventory_query.iter_mut() {
                    items.num_gems = 0;
                }
            }

            if object.name == "biggem" && *map_handle == game.current_map {
                visible.is_visible = true;
                collider.behaviors.clear();
                collider.insert_behavior(ColliderBehavior::Collect);
                collider.insert_behavior(ColliderBehavior::Dialogue(
                    DialogueSpec {
                        node_name: "collectedBigGem".to_string(),
                        ui_type: crate::core::game::DialogueUiType::Notice,
                        auto_display: true,
                }));
            }
        }
    }
}
```


Overlapping Code:
```
ry_query: Query<&mut Inventory>,
mut object_query: Query<(&Object, &mut Visible, &mut Collider, &Handle<Map>)>,
game: Res<Game>,
) {
let mut do_reveal = false;
let mut total_gems = 0;
for inventory in inventory_query.iter_mut() {
total_gems += inventory.num_gems;
}
if total_gems >= 4 {
do_reveal = true;
}
if do_reveal {
for (object, mut visible, mut collider, map_handle) in object_query.iter_mut() {
// only reveal if it's invisible
if visible.is_visible {
continue;
}
if total_gems >= 8 && object.name.starts_with("load:") {
// show hidden portals when you have enough gems
visible.is_visible = true;
collider.insert_behavior(ColliderBehavior::Load { path: object.name[5..].to_string() });
// clear inventory for new map
for mut items in inventory_query.iter_mut() {
items.num_gems = 0;
}
}
if object.name == "biggem" && *map_handle == game.current_map {
visible.is_visible = true;
collider.behaviors.clear();
collider.insert_behavior(ColliderBehavior::Collect);
collider.insert_behavior(ColliderBehavior::Dialogue(
DialogueSpec {
node_name: "collectedBigGem".to_string(),
ui_type: crate::core::game::DialogueUiType::Notice,
auto_display: true,
}
```
<Overlap Ratio: 0.9511993382961125>

---

--- 68 --
Question ID: 6c11c4d7c052cc34184bb63dd07cc9105ac089fe_0
Original Code:
```
pub fn parse_mac(cx: &ExtCtxt, mac: &ast::Mac) -> P<ast::Expr> {
    let tts = quoted::parse(&mac.node.tts, false, &cx.parse_sess());
    let rdr = transcribe::transcribe(&cx.parse_sess().span_diagnostic, None, tts);

    let mut parser = Parser::new(
        cx.parse_sess(),
        rdr.clone(),
        None,
        false);

    let expr = panictry!(parser.parse_expr());
    panictry!(parser.expect(&Token::Eof));

    expr
}
```


Overlapping Code:
```
-> P<ast::Expr> {
let tts = quoted::parse(&mac.node.tts, false, &cx.parse_sess());
let rdr = transcribe::transcribe(&cx.parse_sess().span_diagnostic, None, tts);
let mut parser = Parser::new(
cx.parse_sess(),
rdr.clone(),
None,
false);
let expr = panictry!(parser.parse_expr());
panictry!(parser.expec
```
<Overlap Ratio: 0.8113207547169812>

---

--- 69 --
Question ID: 69a77231ebcd47efafab8fb6ba15288776b6efdd_1
Original Code:
```
fn sequence<'a, T>(token_stream: &mut Peekable<T>) -> Result<Ast<'a>, Error<'a>>
    where T: Iterator<Item=Token<'a>>
{
    let mut seq: Vec<Ast> = vec![];

    loop {
        seq.push(
            match token_stream.peek() {
                Some(&Token::Literal(text)) => { token_stream.next(); Ast::Literal(text) },
                Some(&Token::Interpolation(_)) => {
                    match token_stream.next() {
                        Some(Token::Interpolation(name)) => Ast::Interpolation(name),
                        _ => panic!("Outer match should guarantee match in inner match"),
                    }
                },
                Some(&Token::UnescapedInterpolation(_)) => {
                    match token_stream.next() {
                        Some(Token::UnescapedInterpolation(name)) => Ast::UnescapedInterpolation(name),
                        _ => panic!("Outer match should guarantee match in inner match"),
                    }
                },
                Some(&Token::SectionOpener(..)) => section(token_stream)?,
                Some(&Token::PartialInclude(..)) => {
                    match token_stream.next() {
                        Some(Token::PartialInclude(partial_name, root)) => {
                            Ast::PartialInclude { partial_name, root }
                        },
                        _ => panic!("Outer match should guarantee match in inner match"),
                    }
                },
                _ => break
            }
        )
    }

    Ok(Ast::Sequence(seq))
}
```


Overlapping Code:
```
'a, T>(token_stream: &mut Peekable<T>) -> Result<Ast<'a>, Error<'a>>
where T: Iterator<Item=Token<'a>>
{
let mut seq: Vec<Ast> = vec![];
loop {
seq.push(
match token_stream.peek() {
Some(&Token::Literal(text)) => { token_stream.next(); Ast::Literal(text) },
Some(&Token::Interpolation(_)) => {
match token_stream.next() {
Some(Token::Interpolation(name)) => Ast::Interpolation(name),
_ => panic!("Outer match should guarantee match in inner match"),
}
},
Some(&Token::UnescapedInterpolation(_)) => {
match token_stream.next() {
Some(Token::UnescapedInterpolation(name)) => Ast::UnescapedInterpolation(name),
_ => panic!("Outer match should guarantee match in inner match"),
}
},
Some(&Token::SectionOpener(..)) => section(token_stream)?,
Some(&Token::PartialInclude(..)) => {
match token_stream.next() {
Some(Token::PartialInclude(partial_name, root)) => {
Ast::PartialInclude { partial_name, root }
},
_ => panic!("Outer match should guarantee match in inner match"),
}
},
_ => br
```
<Overlap Ratio: 0.9552093476144109>

---

--- 70 --
Question ID: 00ea53dac1e39ffc5382be4fb0a44d1632aa4112_0
Original Code:
```
fn get_h_prime_fn(x: f32, y: f32) -> f32 {
    let mut hue_angle;

    if x == 0.0 && y == 0.0 {
        return 0.0;
    }

    hue_angle = radians_to_degrees(x.atan2(y));

    if hue_angle < 0.0 {
        hue_angle += 360.0;
    }

    hue_angle
}
```


Overlapping Code:
```
fn(x: f32, y: f32) -> f32 {
let mut hue_angle;
if x == 0.0 && y == 0.0 {
return 0.0;
}
hue_angle = radians_to_degrees(x.atan2(y));
if hue_angle < 0.0 {
hue_angle += 360.0;
}
hue_an
```
<Overlap Ratio: 0.9>

---

--- 71 --
Question ID: 529a550eb02314c93c29164bfd5b27c3e7a4dc64_2
Original Code:
```
fn test_get_devnode() {
        let _ = env_logger::builder().is_test(true).try_init();

        let mut mock_query = MockEnvVarQuery::new();
        const MOCK_DEVICE_PATH: &str = "/dev/video0";

        mock_query
            .expect_get_env_var()
            .times(1)
            .withf(move |name: &str| name == UDEV_DEVNODE_LABEL_ID)
            .returning(move |_| Ok(MOCK_DEVICE_PATH.to_string()));

        assert_eq!(MOCK_DEVICE_PATH.to_string(), get_video_devnode(&mock_query));
    }
```


Overlapping Code:
```
st_get_devnode() {
let _ = env_logger::builder().is_test(true).try_init();
let mut mock_query = MockEnvVarQuery::new();
const MOCK_DEVICE_PATH: &str = "/dev/video0";
mock_query
.expect_get_env_var()
.times(1)
.withf(move |name: &str| name == UDEV_DEVNODE_LABEL_ID)
.returning(move |_| Ok(MOCK_DEVICE_PATH.to_string()));
assert_eq!(MOCK_DEVICE_PATH.to
```
<Overlap Ratio: 0.875>

---

--- 72 --
Question ID: c002ff2ef77014699c7bcf47aab99a0ac3e98876_0
Original Code:
```
fn test_katakana_katsuyou1() {
        let expected = "なんちゃッテ".to_string();
        let actual = OnaraPattern::katakana_katsuyou("なんちゃって".to_string(), 2);
        assert_eq!(actual, expected)
    }
```


Overlapping Code:
```
なんちゃッテ".to_string();
let actual = OnaraPattern::katakana_katsuyou("なんちゃって".to_string(), 2);
assert_e
```
<Overlap Ratio: 0.591715976331361>

---

--- 73 --
Question ID: 7d20cd547842c8e4548e1de1262f93f13c5abd53_0
Original Code:
```
fn it_adds_junit_test_for_java_files() {
  let examples_path = helper::get_examples_path().join("java/junit");
  let sample_path = Path::new("src/main/java/com/example/FooBar.java");

  unit::run(&examples_path, &sample_path, "junit").unwrap();

  let generated_path = examples_path.join("src/test/java/com/example/FooBarTest.java");
  let expected_path = examples_path.join("src/test.expected/java/com/example/FooBarTest.java");

  compare_files(&generated_path, &expected_path);

  let generated_pom_xml = examples_path.join("pom.xml");
  let expected_pom_xml = examples_path.join("pom.expected.xml");

  compare_files(&generated_pom_xml, &expected_pom_xml);
}
```


Overlapping Code:
```
dds_junit_test_for_java_files() {
let examples_path = helper::get_examples_path().join("java/junit");
let sample_path = Path::new("src/main/java/com/example/FooBar.java");
unit::run(&examples_path, &sample_path, "junit").unwrap();
let generated_path = examples_path.join("src/test/java/com/example/FooBarTest.java");
let expected_path = examples_path.join("src/test.expected/java/com/example/FooBarTest.java");
compare_files(&generated_path, &expected_path);
let generated_pom_xml = examples_path.join("pom.xml");
let expected_pom_xml = examples_path.join("pom.expected.xml");
compare_files(&generate
```
<Overlap Ratio: 0.9389671361502347>

---

--- 74 --
Question ID: 504b3a2f1e97e04e41b11f7ee666e22bf59f3cb6_3
Original Code:
```
pub fn serialize_ntp_packet(pack: NtpPacket) -> Vec<u8> {
    let mut buff = Cursor::new(Vec::new());
    buff.write_all(&serialize_header(pack.header))
        .expect("buffer write failed; can't serialize NtpPacket");
    buff.write_all(&serialize_extensions(pack.exts))
        .expect("buffer write failed; can't serialize NtpPacket");
    buff.into_inner()
}
```


Overlapping Code:
```
et(pack: NtpPacket) -> Vec<u8> {
let mut buff = Cursor::new(Vec::new());
buff.write_all(&serialize_header(pack.header))
.expect("buffer write failed; can't serialize NtpPacket");
buff.write_all(&serialize_extensions(pack.exts))
.expect("buffer write failed; can't serialize NtpPacket");
buff.into_inn
```
<Overlap Ratio: 0.9063444108761329>

---

--- 75 --
Question ID: afcb31291c6c5d54f3c25dddbdb964b276defc7a_1
Original Code:
```
async fn fetch(
    client: &reqwest::Client,
    url: &str,
    path_buf: PathBuf,
    problem: Oj,
) -> Result<(), Box<dyn std::error::Error>> {
    use io::ErrorKind::{NotFound, PermissionDenied};

    if path_buf.exists() {
        return Ok(());
    }

    let client = match problem {
        Yukicoder(_) => client.get(url).bearer_auth(yukitoken()),
        Aoj(_) => client.get(url),
    };
    let content = client.send().await?.text().await?;

    if content == "/* This is a single file for multiple testcases. serial should be 1. */"{
        Err(Box::new(io::Error::new(NotFound, "no more cases")))
    } else if content.starts_with("/* Test case #") && content.ends_with(" is not available. */") {
        Err(Box::new(io::Error::new(PermissionDenied, "not available")))
    } else {
        let mut file = std::fs::File::create(&path_buf)?;
        file.write_all(content.as_bytes())?;
        eprintln!("save to {:#?}", file);
        Ok(())
    }
}
```


Overlapping Code:
```
client: &reqwest::Client,
url: &str,
path_buf: PathBuf,
problem: Oj,
) -> Result<(), Box<dyn std::error::Error>> {
use io::ErrorKind::{NotFound, PermissionDenied};
if path_buf.exists() {
return Ok(());
}
let client = match problem {
Yukicoder(_) => client.get(url).bearer_auth(yukitoken()),
Aoj(_) => client.get(url),
};
let content = client.send().await?.text().await?;
if content == "/* This is a single file for multiple testcases. serial should be 1. */"{
Err(Box::new(io::Error::new(NotFound, "no more cases")))
} else if content.starts_with("/* Test case #") && content.ends_with(" is not available. */") {
Err(Box::new(io::Error::new(PermissionDenied, "not available")))
} else {
let mut file = std::fs::File::create(&path_buf)?;
file.write_all(content.as_bytes())?;
eprintln!("save to {:#?}",
```
<Overlap Ratio: 0.9592326139088729>

---

--- 76 --
Question ID: 5e8f70c197e68ac52808a5518905c713dba8e4b8_2
Original Code:
```
fn main() {
    let total_time_start = time::Instant::now();
    let stdout = std::io::stdout();
    let mut stdout_handle = stdout.lock();
    writeln!(stdout_handle, "AoC 2021 Day 1").unwrap();
    writeln!(stdout_handle, "----------------------------------\n").unwrap();

    // Read all lines of input.txt
    let read_time_start = time::Instant::now();
    //let input = fs::read_to_string("example.txt").expect("Unable to read file");
    let input = fs::read_to_string("input.txt").expect("Unable to read file");
    let read_time = read_time_start.elapsed();
    let convert_time_start = time::Instant::now();
    let lines = input
        .lines()
        .map(|line| line.trim().parse::<usize>().unwrap())
        .collect::<Vec<usize>>();
    let convert_time = convert_time_start.elapsed();

    let part1_time_start = time::Instant::now();
    let part1_answer = part1(&lines);
    let part1_time = part1_time_start.elapsed();
    writeln!(stdout_handle, "Part 1 Answer: {}", part1_answer).unwrap();

    writeln!(stdout_handle, "\n----------------------------------\n").unwrap();

    let part2_time = time::Instant::now();
    let part2_answer = part2(&lines);
    let part2_time = part2_time.elapsed();
    writeln!(stdout_handle, "Part 2 Answer: {}", part2_answer).unwrap();

    writeln!(stdout_handle, "\n----------------------------------\n").unwrap();

    writeln!(stdout_handle, "Read time: {:?}", read_time).unwrap();
    writeln!(stdout_handle, "Convert time: {:?}", convert_time).unwrap();
    writeln!(stdout_handle, "Part 1 time: {:?}", part1_time).unwrap();
    writeln!(stdout_handle, "Part 2 time: {:?}", part2_time).unwrap();

    let total_time = total_time_start.elapsed();
    writeln!(stdout_handle, "Total time: {:?}", total_time).unwrap();
}
```


Overlapping Code:
```
al_time_start = time::Instant::now();
let stdout = std::io::stdout();
let mut stdout_handle = stdout.lock();
writeln!(stdout_handle, "AoC 2021 Day 1").unwrap();
writeln!(stdout_handle, "----------------------------------\n").unwrap();
// Read all lines of input.txt
let read_time_start = time::Instant::now();
//let input = fs::read_to_string("example.txt").expect("Unable to read file");
let input = fs::read_to_string("input.txt").expect("Unable to read file");
let read_time = read_time_start.elapsed();
let convert_time_start = time::Instant::now();
let lines = input
.lines()
.map(|line| line.trim().parse::<usize>().unwrap())
.collect::<Vec<usize>>();
let convert_time = convert_time_start.elapsed();
let part1_time_start = time::Instant::now();
let part1_answer = part1(&lines);
let part1_time = part1_time_start.elapsed();
writeln!(stdout_handle, "Part 1 Answer: {}", part1_answer).unwrap();
writeln!(stdout_handle, "\n----------------------------------\n").unwrap();
let part2_time = time::Instant::now();
let part2_answer = part2(&lines);
let part2_time = part2_time.elapsed();
writeln!(stdout_handle, "Part 2 Answer: {}", part2_answer).unwrap();
writeln!(stdout_handle, "\n----------------------------------\n").unwrap();
writeln!(stdout_handle, "Read time: {:?}", read_time).unwrap();
writeln!(stdout_handle, "Convert time: {:?}", convert_time).unwrap();
writeln!(stdout_handle, "Part 1 time: {:?}", part1_time).unwrap();
writeln!(stdout_handle, "Part 2 time: {:?}", part2_time).unwrap();
let total_time = total_time_start.elapsed();
writeln!(stdout_handle, "Total time: {:?}", total_time
```
<Overlap Ratio: 0.9803921568627451>

---

--- 77 --
Question ID: 4d5860bbc6fd8de447d1119974c6f2ee66687673_0
Original Code:
```
fn prepare_format_args<T>(tag: &str, buf: &mut MallocDataBlock<T>) -> (CString, *mut T, c_int) {
	let (p, _, cap) = unsafe {buf.raw_parts()};
	let cap = cap as c_int;
	let tag = CString::new(tag).unwrap();
	(tag, p, cap)		
}
```


Overlapping Code:
```
f: &mut MallocDataBlock<T>) -> (CString, *mut T, c_int) {
let (p, _, cap) = unsafe {buf.raw_parts()};
let cap = cap as c_int;
let tag = CString::new(t
```
<Overlap Ratio: 0.684931506849315>

---

--- 78 --
Question ID: 62dbc2743d826d9e409ade507c8534a613c3bc7f_0
Original Code:
```
fn merkle_crh_sprout(left: [u8; 32], right: [u8; 32]) -> [u8; 32] {
    let mut other_block = [0u8; 64];
    other_block[..32].copy_from_slice(&left[..]);
    other_block[32..].copy_from_slice(&right[..]);

    // H256: Sha256 initial state
    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/consts.rs#L170
    let mut state = [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
        0x5be0cd19,
    ];
    sha2::compress256(&mut state, &[GenericArray::clone_from_slice(&other_block)]);

    // Yes, sha256 does big endian here.
    // https://github.com/RustCrypto/hashes/blob/master/sha2/src/sha256.rs#L40
    let mut derived_bytes = [0u8; 32];
    BigEndian::write_u32_into(&state, &mut derived_bytes);

    derived_bytes
}
```


Overlapping Code:
```
u8; 32], right: [u8; 32]) -> [u8; 32] {
let mut other_block = [0u8; 64];
other_block[..32].copy_from_slice(&left[..]);
other_block[32..].copy_from_slice(&right[..]);
// H256: Sha256 initial state
// https://github.com/RustCrypto/hashes/blob/master/sha2/src/consts.rs#L170
let mut state = [
0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab,
0x5be0cd19,
];
sha2::compress256(&mut state, &[GenericArray::clone_from_slice(&other_block)]);
// Yes, sha256 does big endian here.
// https://github.com/RustCrypto/hashes/blob/master/sha2/src/sha256.rs#L40
let mut derived_bytes = [0u8; 32];
BigEndian::write_u32_into(&state, &mut de
```
<Overlap Ratio: 0.9201680672268907>

---

--- 79 --
Question ID: 38f004ecd3af0fa6170d6f741acf46d21ffa31fe_0
Original Code:
```
fn main () -> ! {

    let dp = pac::Peripherals::take().unwrap();

    let mut flash = dp.FLASH.constrain();
    let rcc = dp.RCC.constrain();
    let _clocks = rcc
        .cfgr
        .use_hse(8.mhz())       // esternal (quartz) oscillator
        .sysclk(72.mhz())      
        .freeze(&mut flash.acr);

    let mut cp = Peripherals::take().unwrap();
    cp.DWT.enable_cycle_counter();
    let mut m = Measure::new();
    m.measure();

    loop {}
}
```


Overlapping Code:
```
() -> ! {
let dp = pac::Peripherals::take().unwrap();
let mut flash = dp.FLASH.constrain();
let rcc = dp.RCC.constrain();
let _clocks = rcc
.cfgr
.use_hse(8.mhz()) // esternal (quartz) oscillator
.sysclk(72.mhz()) 
.freeze(&mut flash.acr);
let mut cp = Peripherals::take().unwrap();
cp.DWT.enable_cycle_counter();
let mut m = Measure::ne
```
<Overlap Ratio: 0.9059139784946236>

---

--- 80 --
Question ID: 51f6f71058bc121f2553e2b39179a7c152781fee_2
Original Code:
```
pub(crate) fn build_bundle() -> Bundle {
        let bundle_value = json!({
          "SignedEntryTimestamp": "MEUCIDBGJijj2FqU25yRWzlEWHqE64XKwUvychBs1bSM1PaKAiEAwcR2u81c42TLBk3lWJqhtB7SnM7Lh0OYEl6Bfa7ZA4s=",
          "Payload": {
            "body": "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoicmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJlNzgwMWRlOTM1NTEyZTIyYjIzN2M3YjU3ZTQyY2E0ZDIwZTIxMzRiZGYxYjk4Zjk3NmM4ZjU1ZDljZmU0MDY3In19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FVUNJR3FXU2N6N3M5YVAyc0dYTkZLZXFpdnczQjZrUFJzNTZBSVRJSG52ZDVpZ0FpRUExa3piYVYyWTV5UEU4MUVOOTJOVUZPbDMxTExKU3Z3c2pGUTA3bTJYcWFBPSIsImZvcm1hdCI6Ing1MDkiLCJwdWJsaWNLZXkiOnsiY29udGVudCI6IkxTMHRMUzFDUlVkSlRpQkRSVkpVU1VaSlEwRlVSUzB0TFMwdENrMUpTVU5rZWtORFFXWjVaMEYzU1VKQlowbFVRU3RRYzJGTGFtRkZXbkZ1TjBsWk9UUmlNV1V2YWtwdWFYcEJTMEpuWjNGb2EycFBVRkZSUkVGNlFYRUtUVkpWZDBWM1dVUldVVkZMUlhkNGVtRlhaSHBrUnpsNVdsTTFhMXBZV1hoRlZFRlFRbWRPVmtKQlRWUkRTRTV3V2pOT01HSXpTbXhOUWpSWVJGUkplQXBOVkVGNVRVUkJNMDFxVlhoT2JHOVlSRlJKZUUxVVFYbE5SRUV6VGtSVmVFNVdiM2RCUkVKYVRVSk5SMEo1Y1VkVFRUUTVRV2RGUjBORGNVZFRUVFE1Q2tGM1JVaEJNRWxCUWtsT1pYZFJRbE14WmpSQmJVNUpSVTVrVEN0VkwwaEtiM1JOVTAwM1drNXVhMVJ1V1dWbWVIZFdPVlJGY25CMmJrRmFNQ3RFZWt3S2VXWkJRVlpoWlVwMFMycEdkbUpQVkdJNFJqRjVhRXBHVlRCWVdTdFNhV3BuWjBWd1RVbEpRa3BVUVU5Q1owNVdTRkU0UWtGbU9FVkNRVTFEUWpSQmR3cEZkMWxFVmxJd2JFSkJkM2REWjFsSlMzZFpRa0pSVlVoQmQwMTNSRUZaUkZaU01GUkJVVWd2UWtGSmQwRkVRV1JDWjA1V1NGRTBSVVpuVVZWTlpqRlNDazFOYzNGT1JrSnlWMko0T0cxU1RtUjRUMnRGUlZsemQwaDNXVVJXVWpCcVFrSm5kMFp2UVZWNVRWVmtRVVZIWVVwRGEzbFZVMVJ5UkdFMVN6ZFZiMGNLTUN0M2QyZFpNRWREUTNOSFFWRlZSa0ozUlVKQ1NVZEJUVWcwZDJaQldVbExkMWxDUWxGVlNFMUJTMGRqUjJnd1pFaEJOa3g1T1hkamJXd3lXVmhTYkFwWk1rVjBXVEk1ZFdSSFZuVmtRekF5VFVST2JWcFVaR3hPZVRCM1RVUkJkMHhVU1hsTmFtTjBXVzFaTTA1VE1XMU9SMWt4V2xSbmQxcEVTVFZPVkZGMUNtTXpVblpqYlVadVdsTTFibUl5T1c1aVIxWm9ZMGRzZWt4dFRuWmlVemxxV1ZSTk1sbFVSbXhQVkZsNVRrUkthVTlYV21wWmFrVXdUbWs1YWxsVE5Xb0tZMjVSZDBsQldVUldVakJTUVZGSUwwSkNXWGRHU1VWVFdtMTRhR1J0YkhaUlIwNW9Zek5TYkdKSGVIQk1iVEZzVFVGdlIwTkRjVWRUVFRRNVFrRk5SQXBCTW10QlRVZFpRMDFSUXpOWk1uVnNVRlJ6VUcxT1V6UmplbUZMWldwbE1FSnVUMUZJZWpWbE5rNUNXREJDY1hnNVdHTmhLM1F5YTA5cE1UZHpiM0JqQ2k5MkwzaElNWGhNZFZCdlEwMVJSRXRPUkRSWGFraG1TM0ZZV0U5bFZYWmFPVUU1TmtSeGNrVjNSMkZ4UjAxMGJrbDFUalJLZWxwWllWVk1Xbko0T1djS2IxaHhjVzh2UXpsUmJrOUlWSFJ2UFFvdExTMHRMVVZPUkNCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2c9PSJ9fX19",
            "integratedTime": 1634714717,
            "logIndex": 783607,
            "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d"
          }
        });
        let bundle: Bundle = serde_json::from_value(bundle_value).expect("Cannot parse bundle");
        bundle
    }
```


Overlapping Code:
```
MEUCIDBGJijj2FqU25yRWzlEWHqE64XKwUvychBs1bSM1PaKAiad": {
"body": "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoicmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJlNzgwMWRlOTM1NTEyZTIyYjIzN2M3YjU3ZTQyY2E0ZDIwZTIxMzRiZGYxYjk4Zjk3NmM4ZjU1ZDljZmU0MDY3In19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FVUNJR3FXU2N6N3M5YVAyc0dYTkZLZXFpdnczQjZrUFJzNTZBSVRJSG52ZDVpZ0FpRUExa3piYVYyWTV5UEU4MUVOOTJOVUZPbDMxTExKU3Z3c2pGUTA3bTJYcWFBPSIsImZvcm1hdCI6Ing1MDkiLCJwdWJsaWNLZXkiOnsiY29udGVudCI6IkxTMHRMUzFDUlVkSlRpQkRSVkpVU1VaSlEwRlVSUzB0TFMwdENrMUpTVU5rZWtORFFXWjVaMEYzU1VKQlowbFVRU3RRYzJGTGFtRkZXbkZ1TjBsWk9UUmlNV1V2YWtwdWFYcEJTMEpuWjNGb2EycFBVRkZSUkVGNlFYRUtUVkpWZDBWM1dVUldVVkZMUlhkNGVtRlhaSHBrUnpsNVdsTTFhMXBZV1hoRlZFRlFRbWRPVmtKQlRWUkRTRTV3V2pOT01HSXpTbXhOUWpSWVJGUkplQXBOVkVGNVRVUkJNMDFxVlhoT2JHOVlSRlJKZUUxVVFYbE5SRUV6VGtSVmVFNVdiM2RCUkVKYVRVSk5SMEo1Y1VkVFRUUTVRV2RGUjBORGNVZFRUVFE1Q2tGM1JVaEJNRWxCUWtsT1pYZFJRbE14WmpSQmJVNUpSVTVrVEN0VkwwaEtiM1JOVTAwM1drNXVhMVJ1V1dWbWVIZFdPVlJGY25CMmJrRmFNQ3RFZWt3S2VXWkJRVlpoWlVwMFMycEdkbUpQVkdJNFJqRjVhRXBHVlRCWVdTdFNhV3BuWjBWd1RVbEpRa3BVUVU5Q1owNVdTRkU0UWtGbU9FVkNRVTFEUWpSQmR3cEZkMWxFVmxJd2JFSkJkM2REWjFsSlMzZFpRa0pSVlVoQmQwMTNSRUZaUkZaU01GUkJVVWd2UWtGSmQwRkVRV1JDWjA1V1NGRTBSVVpuVVZWTlpqRlNDazFOYzNGT1JrSnlWMko0T0cxU1RtUjRUMnRGUlZsemQwaDNXVVJXVWpCcVFrSm5kMFp2UVZWNVRWVmtRVVZIWVVwRGEzbFZVMVJ5UkdFMVN6ZFZiMGNLTUN0M2QyZFpNRWREUTNOSFFWRlZSa0ozUlVKQ1NVZEJUVWcwZDJaQldVbExkMWxDUWxGVlNFMUJTMGRqUjJnd1pFaEJOa3g1T1hkamJXd3lXVmhTYkFwWk1rVjBXVEk1ZFdSSFZuVmtRekF5VFVST2JWcFVaR3hPZVRCM1RVUkJkMHhVU1hsTmFtTjBXVzFaTTA1VE1XMU9SMWt4V2xSbmQxcEVTVFZPVkZGMUNtTXpVblpqYlVadVdsTTFibUl5T1c1aVIxWm9ZMGRzZWt4dFRuWmlVemxxV1ZSTk1sbFVSbXhQVkZsNVRrUkthVTlYV21wWmFrVXdUbWs1YWxsVE5Xb0tZMjVSZDBsQldVUldVakJTUVZGSUwwSkNXWGRHU1VWVFdtMTRhR1J0YkhaUlIwNW9Zek5TYkdKSGVIQk1iVEZzVFVGdlIwTkRjVWRUVFRRNVFrRk5SQXBCTW10QlRVZFpRMDFSUXpOWk1uVnNVRlJ6VUcxT1V6UmplbUZMWldwbE1FSnVUMUZJZWpWbE5rNUNXREJDY1hnNVdHTmhLM1F5YTA5cE1UZHpiM0JqQ2k5MkwzaElNWGhNZFZCdlEwMVJSRXRPUkRSWGFraG1TM0ZZV0U5bFZYWmFPVUU1TmtSeGNrVjNSMkZ4UjAxMGJrbDFUalJLZWxwWllWVk1Xbko0T1djS2IxaHhjVzh2UXpsUmJrOUlWSFJ2UFFvdExTMHRMVVZPUkN"logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d"

```
<Overlap Ratio: 0.8992537313432836>

---

--- 81 --
Question ID: 700443df51d3eb1116a72193e2afe42d350cad2f_2
Original Code:
```
fn root_defaults() {
    let config = r#"
        {
            "services": {
                "foo": {
                    "uris": [
                        "http://foo1.com"
                    ]
                }
            },
            "security": {
                "ca-file": "/foo/bar"
            },
            "proxy": {
                "type": "http",
                "host-and-port": "localhost:1234",
                "credentials": {
                    "username": "admin",
                    "password": "palantir"
                }
            },
            "connect-timeout": "11 seconds",
            "read-timeout": "3 minutes"
        }
    "#;
    let config = serde_json::from_str::<ServicesConfig>(config).unwrap();
    let expected = ServiceConfig::builder()
        .uris(vec!["http://foo1.com".parse().unwrap()])
        .security(
            SecurityConfig::builder()
                .ca_file(Some("/foo/bar".into()))
                .build(),
        )
        .proxy(ProxyConfig::Http(
            HttpProxyConfig::builder()
                .host_and_port(HostAndPort::new("localhost", 1234))
                .credentials(Some(BasicCredentials::new("admin", "palantir")))
                .build(),
        ))
        .connect_timeout(Duration::from_secs(11))
        .read_timeout(Duration::from_secs(3 * 60))
        .build();
    assert_eq!(config.merged_service("foo"), Some(expected));
}
```


Overlapping Code:
```
aults() {
let config = r#"
{
"services": {
"foo": {
"uris": [
"http://foo1.com"
]
}
},
"security": {
"ca-file": "/foo/bar"
},
"proxy": {
"type": "http",
"host-and-port": "localhost:1234",
"credentials": {
"username": "admin",
"password": "
}
},
"connect-timeout": "11 seconds",
"read-timeout": "3 minutes"
}
"#;
let config = serde_json::from_str::<ServicesConfig>(config).unwrap();
let expected = ServiceConfig::builder()
.uris(vec!["http://foo1.com".parse().unwrap()])
.security(
SecurityConfig::builder()
.ca_file(Some("/foo/bar".into()))
.build(),
)
.proxy(ProxyConfig::Http(
HttpProxyConfig::builder()
.host_and_port(HostAndPort::new("localhost", 1234))
.credentials(Some(BasicCredentials::new("admin", "palantir")))
.builconnect_timeout(Duration::from_secs(11))
.read_timeout(Duration::from_secs(3 * 60))
.build();
assert_eq!(config.merged_service("foo"), Some(expected))
```
<Overlap Ratio: 0.9647577092511013>

---

--- 82 --
Question ID: 38677133e56d19bae2e14bb835693327c2c691ca_7
Original Code:
```
fn test_simpleslicedeserializer_simpledeserializer_read_fail() {
    let s: [u8; 8] = [0, 3, 0, 0, 0, 0, 0, 0];

    let mut v = SimpleSliceDeserializer::new(&s[..2]);
    assert!(matches!(v.read(3), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);

    let mut v = SimpleSliceDeserializer::new(&s[..0]);
    assert!(matches!(v.read_u8(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_i8(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);

    let mut v = SimpleSliceDeserializer::new(&s[..1]);
    assert!(matches!(v.read_u16(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_i16(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);

    let mut v = SimpleSliceDeserializer::new(&s[..3]);
    assert!(matches!(v.read_u32(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_i32(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_f32(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);

    let mut v = SimpleSliceDeserializer::new(&s[..7]);
    assert!(matches!(v.read_u64(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_i64(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);
    assert!(matches!(v.read_f64(), Err(ErrorKind::UnableToRead)));
    assert_eq!(v.offset, 0);
    assert_eq!(v.data_offset, 0);

    let mut v = SimpleSliceDeserializer::new(&s[..4]);
    assert!(matches!(v.read_byte_array(), Err(ErrorKind::UnableToRead)));
}
```


Overlapping Code:
```
n test_simpleslicedeserializer_simpledeserializer_read_fail() {
let s: [u8; 8] = [0, 3, 0, 0, 0, 0, 0, 0];
let mut v = SimpleSliceDeserializer::new(&s[..2]);
assert!(matches!(v.read(3), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
let mut v = SimpleSliceDeserializer::new(&s[..0]);
assert!(matches!(v.read_u8(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_i8(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
let mut v = SimpleSliceDeserializer::new(&s[..1]);
assert!(matches!(v.read_u16(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_i16(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
let mut v = SimpleSliceDeserializer::new(&s[..3]);
assert!(matches!(v.read_u32(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_i32(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_f32(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
let mut v = SimpleSliceDeserializer::new(&s[..7]);
assert!(matches!(v.read_u64(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_i64(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
assert!(matches!(v.read_f64(), Err(ErrorKind::UnableToRead)));
assert_eq!(v.offset, 0);
assert_eq!(v.data_offset, 0);
let mut v = SimpleSliceDeserializer::new(&s[..4]);
assert!(matches!(v.read_byte_array(), Err(Er
```
<Overlap Ratio: 0.984251968503937>

---

--- 83 --
Question ID: 0783cd99c82f9d5bc7af11bdd3aa10223062e13f_2
Original Code:
```
fn is_empty_after_entity_created_and_destroyed() {
        let mut state = State::new();
        let e = state.create_entity();
        state.destroy_entity(e).unwrap();
        assert!(state.is_empty());
    }
```


Overlapping Code:
```
y_after_entity_created_and_destroyed() {
let mut state = State::new();
let e = state.create_entity();
state.destroy_entity(e).unwrap();
assert!(state.is_empt
```
<Overlap Ratio: 0.9022988505747126>

---

--- 84 --
Question ID: 48af2f1ade1104e61a8b202d5b6e268fb3f33361_2
Original Code:
```
pub fn divergent_series(x:f64, max_n:u64) -> f64{
    //starts off iteration zero.
    let mut nfact_xn = 1.0;
    let mut sum = nfact_xn;
    let mut diff = std::f64::INFINITY;
    let mut first_sum = sum;
    for n in 1..max_n{
        nfact_xn *= (n as f64 / x);
        //nfact_xn /= x;
        let last_sum = sum;
        sum += nfact_xn;
        //creates a "U" of precision to approximation, so we need to figure out when we're "out" of the U
        //see https://en.wikipedia.org/wiki/Asymptotic_expansion#:~:text=In%20mathematics%2C%20an%20asymptotic%20expansion,the%20function%20tends%20towards%20a
        let new_diff = (last_sum - sum).abs();
        if new_diff > diff{
            sum = first_sum;
            break;
        }else{
            first_sum = last_sum;
            diff = new_diff;
        }
    }
    (x.exp()/x)*sum
}
```


Overlapping Code:
```
x:f64, max_n:u64) -> f64{
//starts off iteration zero.
let mut nfact_xn = 1.0;
let mut sum = nfact_xn;
let mut diff = std::f64::INFINITY;
let mut first_sum = sum;
for n in 1..max_n{
nfact_xn *= (n as f64 / x);
//nfact_xn /= x;
let last_sum = sum;
sum += nfact_xn;
//creates a "U" of precision to approximation, so we need to figure out when we're "out" of the U
//see https://en.wikipedia.org/wiki/Asymptotic_expansion#:~:text=In%20mathematics%2C%20an%20asymptotic%20expansion,the%20function%20tends%20towards%20a
let new_diff = (last_sum - sum).abs();
if new_diff > diff{
sum = first_sum;
break;
}else{
first_sum = last_sum;
diff = new_diff;
}
}
(x.
```
<Overlap Ratio: 0.9447674418604651>

---

--- 85 --
Question ID: c42663ce2baad22a3e42592fea65be13c225c596_1
Original Code:
```
fn page_param_parsing() {
        let assert_error =
            |query, msg| assert_pagination_error(PaginationOptions::builder(), query, msg);

        assert_error("page=", "cannot parse integer from empty string");
        assert_error("page=not_a_number", "invalid digit found in string");
        assert_error("page=1.0", "invalid digit found in string");
        assert_error("page=0", "page indexing starts from 1, page 0 is invalid");

        let pagination = PaginationOptions::builder()
            .gather(&mut mock("page=5"))
            .unwrap();
        assert_eq!(Page::Numeric(5), pagination.page);
    }
```


Overlapping Code:
```
 {
let assert_error =
|query, msg| assert_pagination_error(PaginationOptions::builder(), query, msg);
assert_error("page=", "cannot parse integer from empty string");
assert_error("page=not_a_number", "invalid digit found in string");
assert_error("page=1.0", "invalid digit found in string");
assert_error("page=0", "page indexing starts from 1, page 0 is invalid");
let pagination = PaginationOptions::builder()
.gather(&mut mock("page=5"))
.unwrap();
assert_eq!(Page::Numeric(5), pagination.page);
```
<Overlap Ratio: 0.9523809523809523>

---

--- 86 --
Question ID: b07023b71a56934605aaa17a851b26f9e189f423_3
Original Code:
```
fn build_sample_flags(is_sync: bool) -> SampleFlags {
    let mut flags = SampleFlags::default();
    if is_sync {
        flags.sample_depends_on = 2;
    } else {
        flags.sample_is_non_sync_sample = true;
    }
    flags
}
```


Overlapping Code:
```
n build_sample_flags(is_sync: bool) -> SampleFlags {
let mut flags = SampleFlags::default();
if is_sync {
flags.sample_depends_on = 2;
} else {
flags.
```
<Overlap Ratio: 0.7731958762886598>

---

--- 87 --
Question ID: 76ef5465b6b52dd4e9b1cf90c2416cf75368a392_15
Original Code:
```
fn id_is_optional() {
        let raw_schema = r#"{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "description": "A product from Acme's catalog",
    "type": "object",
    "properties": {
        "productId": {
        "description": "The unique identifier for a product",
        "type": "integer"
        }
    },
    "required": [ "productId" ]
    }"#;

        let schema = Schema::try_from(raw_schema).unwrap();
        println!("{:#?}", schema);
        assert!(schema.id().is_none());
    }
```


Overlapping Code:
```
n id_is_optional() {
let raw_schema = r#"{
"$schema": "http://json-schema.org/draft-07/schema#",
"description": "A product from Acme's catalog",
"type": "object",
"properties": {
"productId": {
"description": "The unique identifier for a product",
"type": "integer"
}
},
"required": [ "productId" ]
}"#;
let schema = Schema::try_from(raw_schema).unwrap();
println!("{:#?}", schema);
assert!(schema.id
```
<Overlap Ratio: 0.9592326139088729>

---

--- 88 --
Question ID: 860761981e824b15d26b3f1f5db5aa7158f8fc89_0
Original Code:
```
async fn get_rooms() {
        let agent = ureq::builder().user_agent(USER_AGENT).build();

        let res = agent.get(&format!("{}/Room", SERVER)).call().unwrap();

        println!("{:#?}", res);

        let res: Vec<Room> = validate_response(res).await.unwrap();
        println!("{:?}", res);
    }
```


Overlapping Code:
```
rooms() {
let agent = ureq::builder().user_agent(USER_AGENT).build();
let res = agent.get(&format!("{}/Room", SERVER)).call().unwrap();
println!("{:#?}", res);
let res: Vec<Room> = validate_response(r
```
<Overlap Ratio: 0.7782101167315175>

---

--- 89 --
Question ID: 665b453d1cdccb60e9103b94359f09cf45078b78_2
Original Code:
```
fn literal() {
        let tpl = String::from("Simple template string");
        let tpl = parse(tpl).unwrap();
        let rendered = render(&tpl, &HashMap::new(), &HashMap::new()).unwrap();
        assert_eq!(rendered, tpl.tpl_str);
    }
```


Overlapping Code:
```
fn literal() {
let tpl = String::from("Simple template string");
let tpl = parse(tpl).unwrap();
let rendered = render(&tpl, &HashMap::new(), &HashMap::new()).unwrap();
assert_eq!(rendered
```
<Overlap Ratio: 0.9166666666666666>

---

--- 90 --
Question ID: 3e4ede6600567cafb4db41b978141eab404570a5_0
Original Code:
```
fn meta() -> MetaOrAttrs {
        let mut meta = MetaOrAttrs::new();
        meta.insert("foo".into(), 123.into());
        meta.insert("bar".into(), "qwe".into());
        meta
    }
```


Overlapping Code:
```
ta() -> MetaOrAttrs {
let mut meta = MetaOrAttrs::new();
meta.insert("foo".into(), 123.into());
meta.insert("bar".into(), "qwe".in
```
<Overlap Ratio: 0.8783783783783784>

---

--- 91 --
Question ID: f248a70c67031bad228df7a3994e529f4513a8c0_3
Original Code:
```
fn playback_to_plughw_mmap() {
    use crate::pcm::*;
    use crate::{ValueOr, Direction};
    use std::ffi::CString;

    let pcm = PCM::open(&*CString::new("plughw:1").unwrap(), Direction::Playback, false).unwrap();
    let hwp = HwParams::any(&pcm).unwrap();
    hwp.set_channels(2).unwrap();
    hwp.set_rate(44100, ValueOr::Nearest).unwrap();
    hwp.set_format(Format::s16()).unwrap();
    hwp.set_access(Access::MMapInterleaved).unwrap();
    pcm.hw_params(&hwp).unwrap();
    let mut m = pcm.direct_mmap_playback::<i16>().unwrap();

    assert_eq!(m.status().state(), State::Prepared);
    assert_eq!(m.appl_ptr(), 0);
    assert_eq!(m.hw_ptr(), 0);

    println!("{:?}", m);
    let mut i = (0..(m.buffer_size() * 2)).map(|i|
        (((i / 2) as f32 * 2.0 * ::std::f32::consts::PI / 128.0).sin() * 8192.0) as i16);
    m.write(&mut i);
    assert_eq!(m.appl_ptr(), m.buffer_size());

    pcm.start().unwrap();
    pcm.drain().unwrap();
    assert_eq!(m.appl_ptr(), m.buffer_size());
    assert!(m.hw_ptr() >= m.buffer_size());
}
```


Overlapping Code:
```
_mmap() {
use crate::pcm::*;
use crate::{ValueOr, Direction};
use std::ffi::CString;
let pcm = PCM::open(&*CString::new("plughw:1").unwrap(), Direction::Playback, false).unwrap();
let hwp = HwParams::any(&pcm).unwrap();
hwp.set_channels(2).unwrap();
hwp.set_rate(44100, ValueOr::Nearest).unwrap();
hwp.set_format(Format::s16()).unwrap();
hwp.set_access(Access::MMapInterleaved).unwrap();
pcm.hw_params(&hwp).unwrap();
let mut m = pcm.direct_mmap_playback::<i16>().unwrap();
assert_eq!(m.status().state(), State::Prepared);
assert_eq!(m.appl_ptr(), 0);
assert_eq!(m.hw_ptr(), 0);
println!("{:?}", m);
let mut i = (0..(m.buffer_size() * 2)).map(|i|
(((i / 2) as f32 * 2.0 * ::std::f32::consts::PI / 128.0).sin() * 8192.0) as i16);
m.write(&mut i);
assert_eq!(m.appl_ptr(), m.buffer_size());
pcm.start().unwrap();
pcm.drain().unwrap();
assert_eq!(m.appl_ptr(), m.buffer_size());
assert!(m.hw_ptr() >= m.
```
<Overlap Ratio: 0.9594882729211087>

---

--- 92 --
Question ID: 8c4ca7c6186e282c993f45a0b6af9b8ba6240c83_126
Original Code:
```
fn c102_l136_action_invoke(result_object: &ResultObject) {
    println!("Executing function {}", "c102_l136_action_invoke");
    let func_index = match result_object.module.info.exports.get("i32.trunc_u_f64") {
        Some(&Export::Function(index)) => index,
        _ => panic!("Function not found"),
    };
    let invoke_fn: fn(f64, &Instance) -> i32 = get_instance_function!(result_object.instance, func_index);
    let result = invoke_fn(-0.9999999999999999 as f64, &result_object.instance);
    assert_eq!(result, 0 as i32);
}
```


Overlapping Code:
```
6_action_invoke(result_object: &ResultObject) {
println!("Executing function {}", "c102_l136_action_invoke");
let func_index = match result_object.module.info.exports.get("i32.trunc_u_f64") {
Some(&Export::Function(index)) => index,
_ => panic!("Function not found"),
};
let invoke_fn: fn(f64, &Instance) -> i32 = get_instance_function!(result_object.instance, func_index);
let result = invoke_fn(-0.9999999999999999 as f64, &result_object.instance);
assert_eq!(result, 0 as i32);
}
```
<Overlap Ratio: 0.9776876267748479>

---

--- 93 --
Question ID: b557cd7190e4e6ed1950b802a5c17f2b276185c1_2
Original Code:
```
fn extract_ir_lengths(ir: &[bool], n_taps: usize, expected: Option<&[usize]>)
    -> Result<Vec<usize>>
{
    // Find all `10` patterns which indicate potential IR start positions.
    let starts = ir.windows(2)
                   .enumerate()
                   .filter(|(_, w)| w[0] && !w[1])
                   .map(|(i, _)| i)
                   .collect::<Vec<usize>>();
    log::trace!("Possible IR start positions: {:?}", starts);

    if n_taps == 0 {
        log::error!("Cannot scan IR without at least one TAP");
        Err(Error::InvalidIR)
    } else if n_taps > starts.len() {
        // We must have at least as many `10` patterns as TAPs.
        log::error!("Fewer IRs detected than TAPs");
        Err(Error::InvalidIR)
    } else if starts[0] != 0 {
        // The chain must begin with a possible start location.
        log::error!("IR chain does not begin with a valid start pattern");
        Err(Error::InvalidIR)
    } else if let Some(expected) = expected {
        // If expected lengths are available, verify and return them.
        if expected.len() != n_taps {
            log::error!("Number of provided IR lengths ({}) does not match \
                         number of detected TAPs ({})", expected.len(), n_taps);
            Err(Error::InvalidIR)
        } else if expected.iter().sum::<usize>() != ir.len() {
            log::error!("Sum of provided IR lengths ({}) does not match \
                         length of IR scan ({} bits)",
                         expected.iter().sum::<usize>(), ir.len());
            Err(Error::InvalidIR)
        } else {
            let exp_starts = expected.iter()
                                     .scan(0, |a, &x| { let b = *a; *a += x; Some(b) })
                                     .collect::<Vec<usize>>();
            log::trace!("Provided IR start positions: {:?}", exp_starts);
            let unsupported = exp_starts.iter().filter(|s| !starts.contains(s)).count();
            if unsupported > 0 {
                log::error!("Provided IR lengths imply an IR start position \
                             which is not supported by the IR scan");
                Err(Error::InvalidIR)
            } else {
                log::debug!("Verified provided IR lengths against IR scan");
                Ok(starts_to_lens(&exp_starts, ir.len()))
            }
        }
    } else if n_taps == 1 {
        // If there's only one TAP, this is easy.
        log::info!("Only one TAP detected, IR length {}", ir.len());
        Ok(vec![ir.len()])
    } else if n_taps == starts.len() {
        // If the number of possible starts matches the number of TAPs,
        // we can unambiguously find all lengths.
        let irlens = starts_to_lens(&starts, ir.len());
        log::info!("IR lengths are unambiguous: {:?}", irlens);
        Ok(irlens)
    } else {
        log::error!("IR lengths are ambiguous and must be specified with --ir-lengths.");
        Err(Error::InvalidIR)
    }
}
```


Overlapping Code:
```
l], n_taps: usize, expected: Option<&[usize]>)
-> Result<Vec<usize>>
{
// Find all `10` patterns which indicate potential IR start positions.
let starts = ir.windows(2)
.enumerate()
.filter(|(_, w)| w[0] && !w[1])
.map(|(i, _)| i)
.collect::<Vec<usize>>();
log::trace!("Possible IR start positions: {:?}", starts);
if n_taps == 0 {
log::error!("Cannot scan IR without at least one TAP");
Err(Error::InvalidIR)
} else if n_taps > starts.len() {
// We must have at least as many `10` patterns as TAPs.
log::error!("Fewer IRs detected than TAPs");
Err(Error::InvalidIR)
} else if starts[0] != 0 {
// The chain must begin with a possible start location.
log::error!("IR chain does not begin with a valid start pattern");
Err(Error::InvalidIR)
} else if let Some(expected) = expected {
// If expected lengths are available, verify and return them.
if expected.len() != n_taps {
log::error!("Number of provided IR lengths ({}) does not match \
number of detected TAPs ({})", expected.len(), n_taps);
Err(Error::InvalidIR)
} else if expected.iter().sum::<usize>() != ir.len() {
log::error!("Sum of provided IR lengths ({}) does not match \
length of IR scan ({} bits)",
expected.iter().sum::<usize>(), ir.len());
Err(Error::InvalidIR)
} else {
let exp_starts = expected.iter()
.scan(0, |a, &x| { let b = *a; *a += x; Some(b) })
.collect::<Vec<usize>>();
log::trace!("Provided IR start positions: {:?}", exp_starts);
let unsupported = exp_starts.iter().filter(|s| !starts.contains(s)).count();
if unsupported > 0 {
log::error!("Provided IR lengths imply an IR start position \
which is not supported by the IR scan");
Err(Error::InvalidIR)
} else {
log::debug!("Verified provided IR lengths against IR scan");
Ok(starts_to_lens(&exp_starts, ir.len()))
}
}
} else if n_taps == 1 {
// If there's only one TAP, this is easy.
log::info!("Only one TAP detected, I
```
<Overlap Ratio: 0.9716386554621849>

---

--- 94 --
Question ID: 206f08add486ad6919aac8b62b8b7a65ed5ea455_4
Original Code:
```
fn rocfl(path: impl AsRef<Path>, command: &str) -> Command {
    let mut rocfl = Command::cargo_bin("rocfl").unwrap();
    rocfl
        .arg("-S")
        .arg("-r")
        .arg(path.as_ref().to_string_lossy().as_ref())
        .arg(command);
    rocfl
}
```


Overlapping Code:
```
command: &str) -> Command {
let mut rocfl = Command::cargo_bin("rocfl").unwrap();
rocfl
.arg("-S")
.arg("-r")
.arg(path.as_ref().to_string_lossy().as_
```
<Overlap Ratio: 0.7075471698113207>

---

--- 95 --
Question ID: c5b695c239fa08a25f26f9b9d67d23af0b1b272f_0
Original Code:
```
fn main() -> Result<(), Infallible> {
    // Set up the window.
    let output_settings = OutputSettingsBuilder::new().scale(3).build();
    let mut window = Window::new("Interactive TextBox demonstration", &output_settings);

    let text = "  Hello, World!\n  \
        Lorem Ipsum is simply dummy text of the printing and typesetting industry.   \
        Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when \
        an unknown printer took a galley of type and scrambled it to make a type specimen book.";

    let character_style = MonoTextStyleBuilder::new()
        .font(&FONT_6X10)
        .text_color(Rgb888::WHITE)
        .background_color(Rgb888::CSS_STEEL_BLUE)
        .build();

    // Create a simulated display.
    let mut display = SimulatorDisplay::new(Size::new(255, 140));

    // Create bounding boxes
    let bounds = Rectangle::new(Point::zero(), Size::new(255, 140));

    // Create and draw the text boxes.
    TextBox::with_textbox_style(
        text,
        bounds.resized(Size::new(128, 255), AnchorPoint::TopLeft),
        character_style,
        TextBoxStyleBuilder::default().build(),
    )
    .draw(&mut display)?;

    TextBox::with_textbox_style(
        text,
        bounds.resized(Size::new(128, 255), AnchorPoint::TopRight),
        character_style,
        TextBoxStyleBuilder::default()
            .leading_spaces(false)
            .trailing_spaces(true)
            .build(),
    )
    .draw(&mut display)?;

    // Update the window.
    window.show_static(&display);

    Ok(())
}
```


Overlapping Code:
```
n main() -> Result<(), Infallible> {
// Set up the window.
let output_settings = OutputSettingsBuilder::new().scale(3).build();
let mut window = Window::new("Interactive TextBox demonstration", &output_settings);
let text = " Hello, World!\n \
Lorem Ipsum is simply dummy text of the printing and typesetting industry. \
Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when \
an unknown printer took a galley of type and scrambled it to make a type specimen book.";
let character_style = MonoTextStyleBuilder::new()
.font(&FONT_6X10)
.text_color(Rgb888::WHITE)
.background_color(Rgb888::CSS_STEEL_BLUE)
.build();
// Create a simulated display.
let mut display = SimulatorDisplay::new(Size::new(255, 140));
// Create bounding boxes
let bounds = Rectangle::new(Point::zero(), Size::new(255, 140));
// Create and draw the text boxes.
TextBox::with_textbox_style(
text,
bounds.resized(Size::new(128, 255), AnchorPoint::TopLeft),
character_style,
TextBoxStyleBuilder::default().build(),
)
.draw(&mut display)?;
TextBox::with_textbox_style(
text,
bounds.resized(Size::new(128, 255), AnchorPoint::TopRight),
character_style,
TextBoxStyleBuilder::default()
.leading_spaces(false)
.trailing_spaces(true)
.build(),
)
.draw(&mut display)?;
// Update the window.
win
```
<Overlap Ratio: 0.9727272727272728>

---

--- 96 --
Question ID: e0f3e655bef40366141efe0de68d0f17ebf46306_2
Original Code:
```
fn scaffold_sbt() {
        let mut filename = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        filename.push("tests/data/v5.sbt.json");

        let sbt = MHBT::from_path(filename).expect("Loading error");

        let new_sbt: MHBT = scaffold(sbt.leaves());
        assert_eq!(new_sbt.leaves().len(), 7);
    }
```


Overlapping Code:
```
 {
let mut filename = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
filename.push("tests/data/v5.sbt.json");
let sbt = MHBT::from_path(filename).expect("Loading error");
let new_sbt: MHBT = scaffold(sbt.leaves());
assert_eq!(new_sbt.leaves().len(
```
<Overlap Ratio: 0.9067164179104478>

---

--- 97 --
Question ID: a47906b3d37d872c524b954dcaeccf0bee6abf46_0
Original Code:
```
pub(crate) fn make_module(vm: &VirtualMachine) -> PyObjectRef {
    use crate::signal::NSIG;
    use _signal::{SIG_DFL, SIG_ERR, SIG_IGN};

    let module = _signal::make_module(vm);

    let sig_dfl = vm.new_pyobj(SIG_DFL as u8);
    let sig_ign = vm.new_pyobj(SIG_IGN as u8);

    for signum in 1..NSIG {
        let handler = unsafe { libc::signal(signum as i32, SIG_IGN) };
        if handler != SIG_ERR {
            unsafe { libc::signal(signum as i32, handler) };
        }
        let py_handler = if handler == SIG_DFL {
            Some(sig_dfl.clone())
        } else if handler == SIG_IGN {
            Some(sig_ign.clone())
        } else {
            None
        };
        vm.signal_handlers.as_deref().unwrap().borrow_mut()[signum] = py_handler;
    }

    let int_handler = module
        .clone()
        .get_attr("default_int_handler", vm)
        .expect("_signal does not have this attr?");
    _signal::signal(libc::SIGINT, int_handler, vm).expect("Failed to set sigint handler");

    module
}
```


Overlapping Code:
```
pub(crate) fn make_module(vm: &VirtualMachine) -> PyObjectRef {
use crate::signal::NSIG;
use _signal::{SIG_DFL, SIG_ERR, SIG_IGN};
let module = _signal::make_module(vm);
let sig_dfl = vm.new_pyobj(SIG_DFL as u8);
let sig_ign = vm.new_pyobj(SIG_IGN as u8);
for signum in 1..NSIG {
let handler = unsafe { libc::signal(signum as i32, SIG_IGN) };
if handler != SIG_ERR {
unsafe { libc::signal(signum as i32, handler) };
}
let py_handler = if handler == SIG_DFL {
Some(sig_dfl.clone())
} else if handler == SIG_IGN {
Some(sig_ign.clone())
} else {
None
};
vm.signal_handlers.as_deref().unwrap().borrow_mut()[signum] = py_handler;
}
let int_handler = module
.clone()
.get_attr("default_int_handler", vm)
.expect("_signal does not have this attr?");
_signal::signal(libc::SIGINT, int_handler, vm).expect("Failed to 
```
<Overlap Ratio: 0.964200477326969>

---

--- 98 --
Question ID: f3068e5da33e1d3431320c12b862ec0fb90d610c_5
Original Code:
```
fn test_empty_section() {
        let x = r#"read      |     write
pages per bulk r/w     rpcs  % cum % |  rpcs        % cum %
"#;

        let result = section().parse(x);

        assert_eq!(
            result,
            Ok((
                BrwStats {
                    name: "pages".to_string(),
                    unit: "rpcs".to_string(),
                    buckets: vec![],
                },
                "",
            ))
        );
    }
```


Overlapping Code:
```
ion() {
let x = r#"read | write
pages per bulk r/w rpcs % cum % | rpcs % cum %
"#;
let result = section().parse(x);
assert_eq!(
result,
Ok((
BrwStats {
name: "pages".to_string(),
unit: "rpcs".to_string(),
buckets: vec!
```
<Overlap Ratio: 0.8582677165354331>

---

--- 99 --
Question ID: cd3812cfe0410eac4dfe421ab66d7563874e40f0_0
Original Code:
```
async fn stream<T>(
    modio: Modio,
    route: Route,
    filter: Filter,
) -> Result<(impl Stream<Item = Result<Page<T>>>, (u32, u32))>
where
    T: DeserializeOwned + Send,
{
    struct State {
        offset: u32,
        limit: u32,
        remaining: u32,
    }
    let list = modio
        .request(route)
        .query(&filter)
        .send::<List<T>>()
        .await?;

    let state = State {
        offset: list.offset,
        limit: list.limit,
        remaining: list.total - list.count,
    };
    let initial = (modio, route, filter, state);
    let stats = (list.total, list.limit);
    if list.total == 0 {
        return Ok((Either::Left(stream::empty()), stats));
    }

    let first = stream::once(async { Ok::<_, crate::Error>(Page(list)) });

    let others = stream::try_unfold(initial, |(modio, route, filter, state)| async move {
        if let State { remaining: 0, .. } = state {
            return Ok(None);
        }
        let filter = filter.offset((state.offset + state.limit) as usize);
        let remaining = state.remaining;

        let list = modio
            .request(route)
            .query(&filter)
            .send::<List<T>>()
            .await?;

        let state = (
            modio,
            route,
            filter,
            State {
                offset: list.offset,
                limit: list.limit,
                remaining: remaining - list.count,
            },
        );

        Ok(Some((Page(list), state)))
    });

    Ok((Either::Right(first.chain(others)), stats))
}
```


Overlapping Code:
```
ilter: Filter,
) -> Result<(impl Stream<Item = Result<Page<T>>>, (u32, u32))>
where
T: DeserializeOwned + Send,
{
struct State {
offset: u32,
limit: u32,
remaining: u32,
}
let list = modio
.request(route)
.query(&filter)
.send::<List<T>>()
.await?;
let state = State {
offset: list.offset,
limit: list.limit,
remaining: list.total - list.count,
};
let initial = (modio, route, filter, state);
let stats = (list.total, list.limit);
if list.total == 0 {
return Ok((Either::Left(stream::empty()), stats));
}
let first = stream::once(async { Ok::<_, crate::Error>(Page(list)) });
let others = stream::try_unfold(initial, |(modio, route, filter, state)| async move {
if let State { remaining: 0, .. } = state {
return Ok(None);
}
let filter = filter.offset((state.offset + state.limit) as usize);
let remaining = state.remaining;
let list = modio
.request(route)
.query(&filter)
.send::<List<T>>()
.await?;
let state = (
modio,
route,
filter,
State {
offset: list.offset,
limit: list.limit,
remaining: remaining - list.count,
},
);
Ok(Some((Page(list), state)))
});
Ok((Either::Right(first.chain(others)),
```
<Overlap Ratio: 0.9490940465918896>

---

--- 100 --
Question ID: ade5775c9437e909b53da93284089648b0da1c52_1
Original Code:
```
pub(crate) fn peek_end(iter: &mut TokenStream) -> bool {
    let idx = iter.idx;
    let end = if consume_block(iter, Block::RParen)
        || (consume_comma(iter) && consume_block(iter, Block::RParen))
    {
        true
    } else {
        false
    };
    iter.idx = idx;
    end
}
```


Overlapping Code:
```
d(iter: &mut TokenStream) -> bool {
let idx = iter.idx;
let end = if consume_block(iter, Block::RParen)
|| (consume_comma(iter) && consume_block(iter, Block::RParen))
{
true
} else {
false
};
iter.idx
```
<Overlap Ratio: 0.8547008547008547>

---

--- 101 --
Question ID: 82b7a8c3841632f4e510c79b3dbea6edeab19146_7
Original Code:
```
fn sign_and_recover_public_works_with_zeroed_messages() {
		let keypair = Random.generate();
		let signature = sign(keypair.secret(), &Message::zero()).unwrap();
		let zero_message = Message::zero();
		assert_eq!(keypair.public(), &recover(&signature, &zero_message).unwrap());
	}
```


Overlapping Code:
```
lic_works_with_zeroed_messages() {
let keypair = Random.generate();
let signature = sign(keypair.secret(), &Message::zero()).unwrap();
let zero_message = Message::zero();
assert_eq!(keypair.public(), &r
```
<Overlap Ratio: 0.7453874538745388>

---

--- 102 --
Question ID: 38409800021e145a5e47388004182a1a04ab3ee4_0
Original Code:
```
pub fn get_version(path: impl AsRef<Path>) -> Result<Version, Error> {
    let cargo_toml_content = fs::read_to_string(path.as_ref())?;
    let doc = cargo_toml_content.parse::<Document>()?;
    let item: &Item = &doc["package"]["version"];

    // This should be the case for valid Cargo.toml files.
    if let Some(s) = item.as_str() {
        Ok(Version::parse(s)?)
    } else {
        Err(Error::InvalidFieldType {
            field: "version".to_string(),
            ty: "string".to_string(),
        })
    }
}
```


Overlapping Code:
```
 -> Result<Version, Error> {
let cargo_toml_content = fs::read_to_string(path.as_ref())?;
let doc = cargo_toml_content.parse::<Document>()?;
let item: &Item = &doc["package"]["version"];
// This should be the case for valid Cargo.toml files.
if let Some(s) = item.as_str() {
Ok(Version::parse(s)?)
} else {
Err(Error::InvalidFieldType {
field: "versi
```
<Overlap Ratio: 0.7936507936507936>

---

--- 103 --
Question ID: 9d9eaca1de084d626b979fb0d78977e95bb2968d_5
Original Code:
```
fn get_first_child_name_ns(node: &libxml::tree::Node, name: &str, ns: &str) -> Option<libxml::tree::Node> {
    let mut found_node = None;
    for child in node.get_child_elements() {
        if let Some(child_ns) = child.get_namespace() {
            if child_ns.get_href() != ns {
                continue;
            }
        } else {
            continue;
        }

        if child.get_name() == name {
            found_node = Some(child.clone());
            break;
        }
    }
    found_node
}
```


Overlapping Code:
```
t_child_name_ns(node: &libxml::tree::Node, name: &str, ns: &str) -> Option<libxml::tree::Node> {
let mut found_node = None;
for child in node.get_child_elements() {
if let Some(child_ns) = child.get_namespace() {
if child_ns.get_href() != ns {
continue;
}
} else {
continue;
}
if child.get_name() == name {
found_node = Some(child.clone());
break;
}

```
<Overlap Ratio: 0.9333333333333333>

---

--- 104 --
Question ID: 95778c540c831a7d750f745440297bf357d08f39_1
Original Code:
```
fn artist_menu(artist: &ArtistLink) -> Menu<AppState> {
    let mut menu = Menu::empty();

    menu = menu.entry(
        MenuItem::new(
            LocalizedString::new("menu-item-copy-link").with_placeholder("Copy Link to Artist"),
        )
        .command(cmd::COPY.with(artist.url())),
    );

    menu
}
```


Overlapping Code:
```
 -> Menu<AppState> {
let mut menu = Menu::empty();
menu = menu.entry(
MenuItem::new(
LocalizedString::new("menu-item-copy-link").with_placeholder("Copy Link to Artist"),
)
.command(cmd::COPY.with(arti
```
<Overlap Ratio: 0.78125>

---

--- 105 --
Question ID: bfd81c99c7cd09423ebe9148c404f5012d9be215_6
Original Code:
```
pub fn type_generics_constrint() {
    let source = r#"
        type Foo = number
        type Bar<T extends Foo> = { a: T[] }
    "#;

    let spec = TestSpec {
        source,
        exports: vec![],
        imports: vec![],
        scope: TestScope {
            type_bindings: vec!["Foo", "Bar"],
            inner: vec![
                TestScope::default(),
                TestScope {
                    type_bindings: vec!["T"],
                    type_references: vec!["Foo", "T"],
                    ..Default::default()
                },
            ],
            ..Default::default()
        },
    };

    run_test(spec);
}
```


Overlapping Code:
```
nerics_constrint() {
let source = r#"
type Foo = number
type Bar<T extends Foo> = { a: T[] }
"#;
let spec = TestSpec {
source,
exports: vec![],
imports: vec![],
scope: TestScope {
type_bindings: vec!["Foo", "Bar"],
inner: vec![
TestScope::default(),
TestScope {
type_bindings: vec!["T"],
type_references: vec!["Foo", "T"],
..Default::default()
},
],
..Default::default()
},
};
run_test(spec);

```
<Overlap Ratio: 0.9632352941176471>

---

--- 106 --
Question ID: 01d90edbc54795059169112dd4262ef2e1618593_5
Original Code:
```
pub fn parallel_binary_search<T, F, G>(mut f: F, q: usize, ok: T, err: T) -> Vec<T>
where
    T: Bisect,
    F: FnMut(&[T]) -> G,
    G: Fn(usize) -> bool,
{
    let mut ok = vec![ok; q];
    let mut err = vec![err; q];
    while !ok.iter().zip(&err).all(|(ok, err)| ok.section_end(err)) {
        let m: Vec<_> = ok.iter().zip(&err).map(|(ok, err)| ok.halve(err)).collect();
        let g = f(&m);
        for (i, m) in m.into_iter().enumerate() {
            if g(i) {
                ok[i] = m;
            } else {
                err[i] = m;
            }
        }
    }
    ok
}
```


Overlapping Code:
```
arch<T, F, G>(mut f: F, q: usize, ok: T, err: T) -> Vec<T>
where
T: Bisect,
F: FnMut(&[T]) -> G,
G: Fn(usize) -> bool,
{
let mut ok = vec![ok; q];
let mut err = vec![err; q];
while !ok.iter().zip(&err).all(|(ok, err)| ok.section_end(err)) {
let m: Vec<_> = ok.iter().zip(&err).map(|(ok, err)| ok.halve(err)).collect();
let g = f(&m);
for (i, m) in m.into_iter().enumerate() {
if g(i) {
ok[i] = m;
} e
```
<Overlap Ratio: 0.8830022075055187>

---

--- 107 --
Question ID: e0d1ce9539528d06be2f2b8b239112b6d9e6ee9c_1
Original Code:
```
fn send() -> Result<(), RMError> {
    let config = AppConfig::read()?;

    let mut db = DB::new()?;
    let stories = db.get_highest_scoring_stories()?;
    let stories_markup = Story::render_list(&stories);

    let email = make_email_message(&stories_markup, &config);
    let mailer = make_mailer(&config);

    info!("Sending newsletter");
    mailer.send(&email)?;

    info!("Cleaning up database");
    db.mark_highest_scoring_stories()?;

    info!("Done!");
    Ok(())
}
```


Overlapping Code:
```
 Result<(), RMError> {
let config = AppConfig::read()?;
let mut db = DB::new()?;
let stories = db.get_highest_scoring_stories()?;
let stories_markup = Story::render_list(&stories);
let email = make_email_message(&stories_markup, &config);
let mailer = make_mailer(&config);
info!("Sending newsletter");
mailer.send(&email)?;
info!("Cleaning up database");
db.mark_highest
```
<Overlap Ratio: 0.866822429906542>

---

--- 108 --
Question ID: 5451323731edaa563b71764afe73291e9b6ee11b_1
Original Code:
```
fn test_ffi() {
        let outer = vec![
            [4.0, 1.0],
            [5.0, 2.0],
            [5.0, 3.0],
            [4.0, 4.0],
            [3.0, 4.0],
            [2.0, 3.0],
            [2.0, 2.0],
            [3.0, 1.0],
            [4.0, 1.0],
        ];
        let inners = vec![
            vec![[3.5, 3.5], [4.4, 2.0], [2.6, 2.0], [3.5, 3.5]],
            vec![[4.0, 3.0], [4.0, 3.2], [4.5, 3.2], [4.0, 3.0]],
        ];

        let res = polylabel_ffi(outer, inners, 0.1);
        assert_eq!(res, (3.125, 2.875, 0.8838834764831844));
    }
```


Overlapping Code:
```

[4.0, 1.0],
[5.0, 2.0],
[5.0, 3.0],
[4.0, 4.0],
[3.0, 4.0],
[2.0, 3.0],
[2.0, 2.0],
[3.0, 1.0],
[4.0, 1.0],
];
let inners = vec![
vec![[3.5, 3.5], [4.4, 2.0], [2.6, 2.0], [3.5, 3.5]],
vec![[4.0, 3.0], [4.0, 3.2], [4.5, 3.2], [4.0, 3.0]],
];
let res = polylabel_ffi(outer, inners, 0.1);
assert_eq!(res, (3.12
```
<Overlap Ratio: 0.8235294117647058>

---

--- 109 --
Question ID: 14fddacb342df1033d738190f7de22ae672564e0_3
Original Code:
```
fn peerv6_compact_transform() {
        let peer = Peer::V6(Peerv6 {
            peer_id: "ABCDEFGHIJKLMNOPQRST".to_string(),
            ip: Ipv6Addr::new(
                0x2001, 0x0db8, 0x85a3, 0x0000, 0x0000, 0x8a2e, 0x0370, 0x7334,
            ),
            port: 6681,
            last_announced: Instant::now(),
        });

        let mut localhost_port_byte_string = vec![];
        let localhost_decimal = 42540766452641154071740215577757643572 as u128;
        let port = 6681 as u16;
        localhost_port_byte_string.put_slice(&localhost_decimal.to_be_bytes());
        localhost_port_byte_string.put_slice(&port.to_be_bytes());

        let compact_rep_byte_string = peer.compact();

        assert_eq!(compact_rep_byte_string, localhost_port_byte_string.to_vec());
    }
```


Overlapping Code:
```
_transform() {
let peer = Peer::V6(Peerv6 {
peer_id: "ABCDEFGHIJKLMNOPQRST".to_string(),
ip: Ipv6Addr::new(
0x2001, 0x0db8, 0x85a3, 0x0000, 0x0000, 0x8a2e, 0x0370, 0x7334,
),
port: 6681,
last_announced: Instant::now(),
});
let mut localhost_port_byte_string = vec![];
let localhost_decimal = 42540766452641154071740215577757643572 as u128;
let port = 6681 as u16;
localhost_port_byte_string.put_slice(&localhost_decimal.to_be_bytes());
localhost_port_byte_string.put_slice(&port.to_be_bytes());
let compact_rep_byte_string = peer.compact();
assert_eq!(compact_rep_byte_string, localhost_port_byte_str
```
<Overlap Ratio: 0.9478672985781991>

---

--- 110 --
Question ID: 2a925af2179677fd6200844fb688979a5f90ec7f_0
Original Code:
```
pub fn solve() -> util::Result<()> {
    let (mut p1, mut p2, mut hashes) = (0, 0, vec![]);
    for x in 0usize..128 {
        let mut lengths: Vec<_> = format!("{}-{}", INPUT, x)
            .bytes()
            .map(|b| b as usize)
            .collect();
        lengths.extend_from_slice(&[17, 31, 73, 47, 23]);
        let k = util::tie_knots(&lengths, 64);
        let h = util::knot_hash(&k);
        p1 += h.count_ones();
        hashes.push(h);
    }
    let mut grid: HashSet<(i8, i8)> = HashSet::new();

    for (y, h) in hashes.iter().enumerate() {
        for x in 0..=127i8 {
            if h & (1 << x) != 0 {
                grid.insert((x, y as i8));
            }
        }
    }

    while !grid.is_empty() {
        let coord = *grid.iter().next().expect("len>0 but no entries");
        remove_group(coord, &mut grid);
        p2 += 1;
    }

    writeln!(io::stdout(), "Day 14 Part 1: {}\nDay 14 Part 2: {}", p1, p2)?;
    Ok(())
}
```


Overlapping Code:
```
n solve() -> util::Result<()> {
let (mut p1, mut p2, mut hashes) = (0, 0, vec![]);
for x in 0usize..128 {
let mut lengths: Vec<_> = format!("{}-{}", INPUT, x)
.bytes()
.map(|b| b as usize)
.collect();
lengths.extend_from_slice(&[17, 31, 73, 47, 23]);
let k = util::tie_knots(&lengths, 64);
let h = util::knot_hash(&k);
p1 += h.count_ones();
hashes.push(h);
}
let mut grid: HashSet<(i8, i8)> = HashSet::new();
for (y, h) in hashes.iter().enumerate() {
for x in 0..=127i8 {
if h & (1 << x) != 0 {
grid.insert((x, y as i8));
}
}
}
while !grid.is_empty() {
let coord = *grid.iter().next().expect("len>0 but no entries");
remove_group(coord, &mut grid);
p2 += 1;
}
writeln!(io::stdout(), "Day 14 Part 1: {}\nDay 14 Part 2: {}", p1, p2)?;
Ok(()
```
<Overlap Ratio: 0.9892761394101877>

---

--- 111 --
Question ID: efa3e506cba735b860040230e5b566e8ff96b2f2_3
Original Code:
```
fn cmd_reindex1() -> Result<i32> {
    let bc1 = Blockchain::new2()?;
    let utxo_set = UTXOSet { blockchain: bc1 };


    utxo_set.reindex()?;
    utxo_set.count_transactions1()
}
```


Overlapping Code:
```
<i32> {
let bc1 = Blockchain::new2()?;
let utxo_set = UTXOSet { blockchain: bc1 };
utxo_set.reindex(
```
<Overlap Ratio: 0.6134969325153374>

---

--- 112 --
Question ID: f247b81871ac7fc8b3cd28ed6adc77546b140f9e_3
Original Code:
```
pub fn relationship_map<G, T>(graph: &G, node_subset: &mut NodeSubset, mapper: &T)
where
    G: Graph + Sync + ?Sized,
    T: RelationshipMapper + Sync + ?Sized,
{
    let subset_size = node_subset.subset_count();

    let degrees = if node_subset.is_dense() {
        par_vec(node_subset.node_count(), |node_id| {
            if node_subset.contains(node_id) {
                graph.out_degree(node_id)
            } else {
                0
            }
        })
    } else {
        par_vec(subset_size, |i| {
            let node_id = node_subset.node(i);
            graph.out_degree(node_id)
        })
    };

    let out_degrees = degrees.par_iter().sum::<usize>();

    if out_degrees > graph.threshold() {
        node_subset.to_dense();
        relationship_map_dense(graph, node_subset, mapper)
    } else {
        relationship_map_sparse(graph, node_subset, degrees, mapper)
    }
}
```


Overlapping Code:
```
nship_map<G, T>(graph: &G, node_subset: &mut NodeSubset, mapper: &T)
where
G: Graph + Sync + ?Sized,
T: RelationshipMapper + Sync + ?Sized,
{
let subset_size = node_subset.subset_count();
let degrees = if node_subset.is_dense() {
par_vec(node_subset.node_count(), |node_id| {
if node_subset.contains(node_id) {
graph.out_degree(node_id)
} else {
0
}
})
} else {
par_vec(subset_size, |i| {
let node_id = node_subset.node(i);
graph.out_degree(node_id)
})
};
let out_degrees = degrees.par_iter().sum::<usize>();
if out_degrees > graph.threshold() {
node_subset.to_dense();
relationship_map_dense(graph, node_subset, mapper)
} else {
relationship_map_spa
```
<Overlap Ratio: 0.9180790960451978>

---

--- 113 --
Question ID: 5db25372330da5eb6299618faca33db715307ad6_15
Original Code:
```
fn with_project_tools() {
            let expected = "⚡️ Currently active tools:

    Node: v12.2.0 (current @ ~/path/to/project.json)
    npm: v6.13.1 (current @ ~/path/to/project.json)
    Yarn: v1.16.0 (current @ ~/path/to/project.json)
    Tool binaries available:
        create-react-app (current @ ~/path/to/project.json)
        tsc, tsserver (default)

See options for more detailed reports by running `volta list --help`.";

            let runtime = Some(Box::new(Node {
                source: Source::Project(PROJECT_PATH.clone()),
                version: NODE_12.clone(),
            }));
            let package_managers = vec![
                PackageManager {
                    kind: PackageManagerKind::Npm,
                    source: Source::Project(PROJECT_PATH.clone()),
                    version: NPM_VERSION.clone(),
                },
                PackageManager {
                    kind: PackageManagerKind::Yarn,
                    source: Source::Project(PROJECT_PATH.clone()),
                    version: YARN_VERSION.clone(),
                },
            ];
            let packages = vec![
                Package::Project {
                    name: "create-react-app".to_string(),
                    path: PROJECT_PATH.clone(),
                    tools: vec!["create-react-app".to_string()],
                },
                Package::Default {
                    details: PackageDetails {
                        name: "typescript".to_string(),
                        version: Version::from((3, 4, 3)),
                    },
                    node: NODE_12.clone(),
                    tools: vec!["tsc".to_string(), "tsserver".to_string()],
                },
            ];

            assert_eq!(
                display_active(&runtime, &package_managers, &packages),
                expected
            );
        }
```


Overlapping Code:
```
ect_tools() {
let expected = "⚡️ Currently active tools:
Node: v12.2.0 (current @ ~/path/to/project.json)
npm: v6.13.1 (current @ ~/path/to/project.json)
Yarn: v1.16.0 (current @ ~/path/to/project.json)
Tool binaries available:
create-react-app (current @ ~/path/to/project.json)
tsc, tsserver (default)
See options for more detailed reports by running `volta list --help`.";
let runtime = Some(Box::new(Node {
source: Source::Project(PROJECT_PATH.clone()),
version: NODE_12.clone(),
}));
let package_managers = vec![
PackageManager {
kind: PackageManagerKind::Npm,
source: Source::Project(PROJECT_PATH.clone()),
version: NPM_VERSION.clone(),
},
PackageManager {
kind: PackageManagerKind::Yarn,
source: Source::Project(PROJECT_PATH.clone()),
version: YARN_VERSION.clone(),
},
];
let packages = vec![
Package::Project {
name: "create-react-app".to_string(),
path: PROJECT_PATH.clone(),
tools: vec!["create-react-app".to_string()],
},
Package::Default {
details: PackageDetails {
name: "typescript".to_string(),
version: Version::from((3, 4, 3)),
},
node: NODE_12.clone(),
tools: vec!["tsc".to_string(), "tsserver".to_string()],
},
];
assert_eq!(
display_active(&runtime, &package_managers, &packages),
expected
);
```
<Overlap Ratio: 0.9885807504078303>

---

--- 114 --
Question ID: 4e62a8d5e22b8d2ac16ea49e74ef2668cc132869_3
Original Code:
```
fn verify_disk_state(disk: &Box<Disk>, files: &Vec<RandomFile>) -> io::Result<()> {
    // Validate disk image
    disk.validate().unwrap();
    // Confirm blocks free
    let total_data_blocks = disk.disk_format()?.total_data_blocks();
    let blocks_written: usize = files.iter().map(|f| f.blocks()).sum();
    let expected_blocks_free = total_data_blocks - blocks_written;
    assert_eq!(disk.blocks_free().unwrap(), expected_blocks_free);
    Ok(())
}
```


Overlapping Code:
```
disk_state(disk: &Box<Disk>, files: &Vec<RandomFile>) -> io::Result<()> {
// Validate disk image
disk.validate().unwrap();
// Confirm blocks free
let total_data_blocks = disk.disk_format()?.total_data_blocks();
let blocks_written: usize = files.iter().map(|f| f.blocks()).sum();
let expected_blocks_free = total_data_blocks - blocks_written;
assert_eq!(disk.blocks_free().unwrap(), expected_blocks_fr
```
<Overlap Ratio: 0.9456264775413712>

---

--- 115 --
Question ID: 7f92dedc1d0e24f99ebf71a33338209e33fbc65a_6
Original Code:
```
fn verify_txn_accepts_genesis_write_set() {
    let test_env = TestEnvironment::empty();
    assert_eq!(test_env.get_version(), 0);

    proptest!(|(txn in SignedTransaction::genesis_strategy())| {
        test_env.verify_txn(txn).expect("genesis write set txns should verify correctly");
    });
}
```


Overlapping Code:
```

let test_env = TestEnvironment::empty();
assert_eq!(test_env.get_version(), 0);
proptest!(|(txn in SignedTransaction::genesis_strategy())| {
test_env.verify_txn(txn).expect("genesis write set txns sh
```
<Overlap Ratio: 0.7326007326007326>

---

--- 116 --
Question ID: 1b9bfc0736b7f25dfa4689128cef9acd38efbe50_0
Original Code:
```
fn hit<'a>(ray: &Ray, sphere: &'a Sphere) -> Option<Intersection<'a>> {
    // At this stage, shapes always returned ordered hits, so we can use the first.
    //
    sphere.intersections(ray).get(0).cloned()
}
```


Overlapping Code:
```
e: &'a Sphere) -> Option<Intersection<'a>> {
// At this stage, shapes always returned ordered hits, so we can use the first.
//
sphere.intersections(ray).get(0)
```
<Overlap Ratio: 0.8080808080808081>

---

--- 117 --
Question ID: 255f7b95564c275c2702684ece4be16257e3b926_1
Original Code:
```
fn main() {
    let opts: Opts = Opts::parse();
    let groups = art(opts);
    let mut document = base_a4_landscape("white");
    for g in groups {
        document = document.add(g);
    }
    svg::save("image.svg", &document).unwrap();
}
```


Overlapping Code:
```
fn main() {
let opts: Opts = Opts::parse();
let groups = art(opts);
let mut document = base_a4_landscape("white");
for g in groups {
document = document.add(g);
}
svg::save("image.svg", &document).unwrap();
}
```
<Overlap Ratio: 1.0>

---

--- 118 --
Question ID: e90f5904a90ec85620ffa34a5ae5a806d4edd92f_12
Original Code:
```
fn get_name_index(ctx: CallContext) -> Result<JsNumber> {
    let this: JsObject = ctx.this_unchecked();
    let source_map_instance: &SourceMap = ctx.env.unwrap(&this)?;

    let name = ctx.get::<JsString>(0)?.into_utf8()?;
    let name_index = source_map_instance.get_name_index(name.as_str()?);

    match name_index {
        Some(i) => ctx.env.create_uint32(i),
        None => ctx.env.create_int32(-1),
    }
}
```


Overlapping Code:
```
et_name_index(ctx: CallContext) -> Result<JsNumber> {
let this: JsObject = ctx.this_unchecked();
let source_map_instance: &SourceMap = ctx.env.unwrap(&this)?;
let name = ctx.get::<JsString>(0)?.into_utf8()?;
let name_index = source_map_instance.get_name_index(name.as_str()?);
match name_index {
Some(i) => ctx.env.create_uint32(i),
None => ctx.env.c
```
<Overlap Ratio: 0.9358288770053476>

---

--- 119 --
Question ID: 98be397a5e8ba4ec44074a32de20214fc0f05ab3_2
Original Code:
```
async fn authenticate() {
        let (mut tor, mock_state) = setup_test().await;

        tor.authenticate(&Authentication::None).await.unwrap();
        let mut req = mock_state.take_requests().await;
        assert_eq!(req.len(), 1);
        assert_eq!(req.remove(0), "AUTHENTICATE");

        tor.authenticate(&Authentication::HashedPassword("ab\"cde".to_string()))
            .await
            .unwrap();
        let mut req = mock_state.take_requests().await;
        assert_eq!(req.len(), 1);
        assert_eq!(req.remove(0), "AUTHENTICATE \"ab\\\"cde\"");

        tor.authenticate(&Authentication::Cookie("NOTACTUALLYHEXENCODED".to_string()))
            .await
            .unwrap();
        let mut req = mock_state.take_requests().await;
        assert_eq!(req.len(), 1);
        assert_eq!(req.remove(0), "AUTHENTICATE NOTACTUALLYHEXENCODED");
    }
```


Overlapping Code:
```
uthenticate() {
let (mut tor, mock_state) = setup_test().await;
tor.authenticate(&Authentication::None).await.unwrap();
let mut req = mock_state.take_requests().await;
assert_eq!(req.len(), 1);
assert_eq!(req.remove(0), "AUTHENTICATE");
tor.authentict
.unwrap();
let mut req = mock_state.take_requests().await;
assert_eq!(req.len(), 1);
assert_eq!(req.remove(0), "AUTHENTICATE \"ab\\\"cde\"");
tor.authenticate(&Authentication::Cookie("NOTACTUALLYHEXENCODED".to_string()))
.await
.unwrap();
let mut req = mock_state.take_requests().await;
assert_eq!(req.len(), 1);
assert_eq!(req.remove(0), "AUTHENTICATE NOTACTUALLYHEXENCODED")
```
<Overlap Ratio: 0.8895184135977338>

---

--- 120 --
Question ID: 1b22b01dd4b0436efa827c27eba18ae0778f41eb_0
Original Code:
```
pub fn get_aeroway_geo_tile(props: &GeoTileProperties, geometry: Geometry) -> GeoTile {
    let aeroway_type_str = props["aeroway"].as_str().unwrap();
    let aeroway_type = extract_type_from_string!(aeroway_type_str<props> => AerowayType [Aerodrome, Apron, Gate, Hangar, Helipad, Heliport, Navigationaid, Runway, Spaceport, Taxiway, Terminal, Windsock, Unclassified]);
    geotile_from_properties!(geometry<props> => Aeroway<aeroway_type> [name, description, iata, icao, operator, surface]);
}
```


Overlapping Code:
```
_geo_tile(props: &GeoTileProperties, geometry: Geometry) -> GeoTile {
let aeroway_type_str = props["aeroway"].as_str().unwrap();
let aeroway_type = extract_type_from_string!(aeroway_type_str<props> => AerowayType [Aerodrome, Apron, Gate, Hangar, Helipad, Heliport, Navigationaid, Runway, Spaceport, Taxiway, Terminal, Windsock, Unclassified]);
geotile_from_properties!(geometry<props> => Aeroway<aeroway_type> [name, desc
```
<Overlap Ratio: 0.8734439834024896>

---

--- 121 --
Question ID: 18f412fe2747ac45608388c89bcffd58268ebd8a_1
Original Code:
```
pub fn reduce_lower(value: f64, min: f64, y: f64, control: f64) -> f64 {
	let divisor = control - 1.0;
	let factor = (control - y.min(control)) / divisor;

	math::lerp_precise(value, min, factor)
}
```


Overlapping Code:
```
, min: f64, y: f64, control: f64) -> f64 {
let divisor = control - 1.0;
let factor = (control - y.min(control)) / divisor;
math::lerp_precise(value, m
```
<Overlap Ratio: 0.7772020725388601>

---

--- 122 --
Question ID: d3e24b2e8db00b6f5c8dfe99fc0bbb30a1f9b561_0
Original Code:
```
fn parse_relocation<Elf: FileHeader>(
    header: &Elf,
    endian: Elf::Endian,
    reloc: Elf::Rela,
    implicit_addend: bool,
) -> Relocation {
    let mut encoding = RelocationEncoding::Generic;
    let is_mips64el = header.is_mips64el(endian);
    let (kind, size) = match header.e_machine(endian) {
        elf::EM_AARCH64 => match reloc.r_type(endian, false) {
            elf::R_AARCH64_ABS64 => (RelocationKind::Absolute, 64),
            elf::R_AARCH64_ABS32 => (RelocationKind::Absolute, 32),
            elf::R_AARCH64_ABS16 => (RelocationKind::Absolute, 16),
            elf::R_AARCH64_PREL64 => (RelocationKind::Relative, 64),
            elf::R_AARCH64_PREL32 => (RelocationKind::Relative, 32),
            elf::R_AARCH64_PREL16 => (RelocationKind::Relative, 16),
            elf::R_AARCH64_CALL26 => {
                encoding = RelocationEncoding::AArch64Call;
                (RelocationKind::PltRelative, 26)
            }
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_ARM => match reloc.r_type(endian, false) {
            elf::R_ARM_ABS32 => (RelocationKind::Absolute, 32),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_AVR => match reloc.r_type(endian, false) {
            elf::R_AVR_32 => (RelocationKind::Absolute, 32),
            elf::R_AVR_16 => (RelocationKind::Absolute, 16),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_BPF => match reloc.r_type(endian, false) {
            elf::R_BPF_64_64 => (RelocationKind::Absolute, 64),
            elf::R_BPF_64_32 => (RelocationKind::Absolute, 32),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_386 => match reloc.r_type(endian, false) {
            elf::R_386_32 => (RelocationKind::Absolute, 32),
            elf::R_386_PC32 => (RelocationKind::Relative, 32),
            elf::R_386_GOT32 => (RelocationKind::Got, 32),
            elf::R_386_PLT32 => (RelocationKind::PltRelative, 32),
            elf::R_386_GOTOFF => (RelocationKind::GotBaseOffset, 32),
            elf::R_386_GOTPC => (RelocationKind::GotBaseRelative, 32),
            elf::R_386_16 => (RelocationKind::Absolute, 16),
            elf::R_386_PC16 => (RelocationKind::Relative, 16),
            elf::R_386_8 => (RelocationKind::Absolute, 8),
            elf::R_386_PC8 => (RelocationKind::Relative, 8),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_X86_64 => match reloc.r_type(endian, false) {
            elf::R_X86_64_64 => (RelocationKind::Absolute, 64),
            elf::R_X86_64_PC32 => (RelocationKind::Relative, 32),
            elf::R_X86_64_GOT32 => (RelocationKind::Got, 32),
            elf::R_X86_64_PLT32 => (RelocationKind::PltRelative, 32),
            elf::R_X86_64_GOTPCREL => (RelocationKind::GotRelative, 32),
            elf::R_X86_64_32 => (RelocationKind::Absolute, 32),
            elf::R_X86_64_32S => {
                encoding = RelocationEncoding::X86Signed;
                (RelocationKind::Absolute, 32)
            }
            elf::R_X86_64_16 => (RelocationKind::Absolute, 16),
            elf::R_X86_64_PC16 => (RelocationKind::Relative, 16),
            elf::R_X86_64_8 => (RelocationKind::Absolute, 8),
            elf::R_X86_64_PC8 => (RelocationKind::Relative, 8),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_HEXAGON => match reloc.r_type(endian, false) {
            elf::R_HEX_32 => (RelocationKind::Absolute, 32),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_MIPS => match reloc.r_type(endian, is_mips64el) {
            elf::R_MIPS_16 => (RelocationKind::Absolute, 16),
            elf::R_MIPS_32 => (RelocationKind::Absolute, 32),
            elf::R_MIPS_64 => (RelocationKind::Absolute, 64),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_MSP430 => match reloc.r_type(endian, false) {
            elf::R_MSP430_32 => (RelocationKind::Absolute, 32),
            elf::R_MSP430_16_BYTE => (RelocationKind::Absolute, 16),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_PPC => match reloc.r_type(endian, false) {
            elf::R_PPC_ADDR32 => (RelocationKind::Absolute, 32),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_PPC64 => match reloc.r_type(endian, false) {
            elf::R_PPC64_ADDR32 => (RelocationKind::Absolute, 32),
            elf::R_PPC64_ADDR64 => (RelocationKind::Absolute, 64),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_RISCV => match reloc.r_type(endian, false) {
            elf::R_RISCV_32 => (RelocationKind::Absolute, 32),
            elf::R_RISCV_64 => (RelocationKind::Absolute, 64),
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_S390 => match reloc.r_type(endian, false) {
            elf::R_390_8 => (RelocationKind::Absolute, 8),
            elf::R_390_16 => (RelocationKind::Absolute, 16),
            elf::R_390_32 => (RelocationKind::Absolute, 32),
            elf::R_390_64 => (RelocationKind::Absolute, 64),
            elf::R_390_PC16 => (RelocationKind::Relative, 16),
            elf::R_390_PC32 => (RelocationKind::Relative, 32),
            elf::R_390_PC64 => (RelocationKind::Relative, 64),
            elf::R_390_PC16DBL => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::Relative, 16)
            }
            elf::R_390_PC32DBL => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::Relative, 32)
            }
            elf::R_390_PLT16DBL => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::PltRelative, 16)
            }
            elf::R_390_PLT32DBL => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::PltRelative, 32)
            }
            elf::R_390_GOT16 => (RelocationKind::Got, 16),
            elf::R_390_GOT32 => (RelocationKind::Got, 32),
            elf::R_390_GOT64 => (RelocationKind::Got, 64),
            elf::R_390_GOTENT => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::GotRelative, 32)
            }
            elf::R_390_GOTOFF16 => (RelocationKind::GotBaseOffset, 16),
            elf::R_390_GOTOFF32 => (RelocationKind::GotBaseOffset, 32),
            elf::R_390_GOTOFF64 => (RelocationKind::GotBaseOffset, 64),
            elf::R_390_GOTPC => (RelocationKind::GotBaseRelative, 64),
            elf::R_390_GOTPCDBL => {
                encoding = RelocationEncoding::S390xDbl;
                (RelocationKind::GotBaseRelative, 32)
            }
            r_type => (RelocationKind::Elf(r_type), 0),
        },
        elf::EM_SPARC | elf::EM_SPARC32PLUS | elf::EM_SPARCV9 => {
            match reloc.r_type(endian, false) {
                elf::R_SPARC_32 | elf::R_SPARC_UA32 => (RelocationKind::Absolute, 32),
                elf::R_SPARC_64 | elf::R_SPARC_UA64 => (RelocationKind::Absolute, 64),
                r_type => (RelocationKind::Elf(r_type), 0),
            }
        }
        _ => (RelocationKind::Elf(reloc.r_type(endian, false)), 0),
    };
    let sym = reloc.r_sym(endian, is_mips64el) as usize;
    let target = if sym == 0 {
        RelocationTarget::Absolute
    } else {
        RelocationTarget::Symbol(SymbolIndex(sym))
    };
    Relocation {
        kind,
        encoding,
        size,
        target,
        addend: reloc.r_addend(endian).into(),
        implicit_addend,
    }
}
```


Overlapping Code:
```
lf,
endian: Elf::Endian,
reloc: Elf::Rela,
implicit_addend: bool,
) -> Relocation {
let mut encoding = RelocationEncoding::Generic;
let is_mips64el = header.is_mips64el(endian);
let (kind, size) = match header.e_machine(endian) {
elf::EM_AARCH64 => match reloc.r_type(endian, false) {
elf::R_AARCH64_ABS64 => (RelocationKind::Absolute, 64),
elf::R_AARCH64_ABS32 => (RelocationKind::Absolute, 32),
elf::R_AARCH64_ABS16 => (RelocationKind::Absolute, 16),
elf::R_AARCH64_PREL64 => (RelocationKind::Relative, 64),
elf::R_AARCH64_PREL32 => (RelocationKind::Relative, 32),
elf::R_AARCH64_PREL16 => (RelocationKind::Relative, 16),
elf::R_AARCH64_CALL26 => {
encoding = RelocationEncoding::AArch64Call;
(RelocationKind::PltRelative, 26)
}
r_type => (RelocationKind::Elf(r_type), 0),
},
elf::EM_ARM => match reloc.r_type(endian, false) {
elf::R_ARM_ABS32 => (RelocationKind::Absolute, 32),
r_type => (RelocationKind::Elf(r_type), 0),
},
elf::EM_AVR => match reloc.r_type(endian, false) {
elf::R_AVR_32 => (RelocationKind::Absolute, 32),
elf::R_AVR_16 => (RelocationKind::Absolute, 16),
r_type => (RelocationKind::Elf(r_type), 0),
},
elf::EM_BPF => match reloc.r_type(endian, false) {
elf::R_BPF_64_64 => (RelocationKind::Absolute, 64),
elf::R_BPF_64_32 => (RelocationKind::Absolute, 32),
r_type => (RelocationKind::Elf(r_type), 0),
},
elf::EM_386 => match reloc.r_type(endian, false) {
elf::R_386_32 => (RelocationKind::Absolute, 32),
elf::R_386_PC32 => (RelocationKind::Relative, 32),
elf::R_386_GOT32 => (RelocationKind::Got, 32),
elf::R_386_PLT32 => (RelocationKind::PltRelative, 32),
elf::R_386_GOTOFF => (RelocationKind::GotBaseOffset, 32),
elf::R_386_GOTPC => (RelocationKind::GotBaseRelative, 32),
elf::R_386_16 => (RelocationKind::Absolute, 16),
elf::R_386_PC16 => (RelocationKind::Relative, 16),
elf::R_386_8 => (RelocationKind::Absolute, 8),
elf::R_386_PC8 => (RelocationKind::Relative, 8),
r_type => (RelocationKind::Elf(r_type), 0),
},
elf::EM_X86_64 => match relo
```
<Overlap Ratio: 0.9761786600496278>

---

--- 123 --
Question ID: 2d290308d0196d9f5c61c976a3e2e3711bbb74c1_8
Original Code:
```
fn test_readreader_new() {
    let mut sample: [u8; 10] = [0; 10];
    fill_sample(&mut sample);
    let mut mem_reader = std::io::Cursor::new(&sample);
    let mut reader = ReadReader::new(&mut mem_reader);
    match reader.read() {
        Ok(v) => assert_eq!(v, 0),
        _ => panic!("Unexpected error!"),
    }
}
```


Overlapping Code:
```
r_new() {
let mut sample: [u8; 10] = [0; 10];
fill_sample(&mut sample);
let mut mem_reader = std::io::Cursor::new(&sample);
let mut reader = ReadReader::new(&mut mem_reader);
match reader.read() {
Ok(v) => assert_eq!(v, 0),
_ => panic!("Unexpected er
```
<Overlap Ratio: 0.8992805755395683>

---

--- 124 --
Question ID: e5877840d427d14ead6edf829d36c4d5a130ee60_21
Original Code:
```
fn to_bytes_unspec() {
        let header = Header::new(
            Version::Two,
            Command::Local,
            Protocol::Unspecified,
            vec![],
            Addresses::None,
        );
        let mut output: Vec<u8> = Vec::with_capacity(PREFIX.len());

        output.extend_from_slice(PREFIX);
        output.push(0x20);
        output.push(0x00);
        output.extend(&[0, 0]);

        assert_eq!(to_bytes(header), Ok(output));
    }
```


Overlapping Code:
```
 = Header::new(
Version::Two,
Command::Local,
Protocol::Unspecified,
vec![],
Addresses::None,
);
let mut output: Vec<u8> = Vec::with_capacity(PREFIX.len());
output.extend_from_slice(PREFIX);
output.push(0x20);
output.push(0x00);
output.extend(&[0, 0]
```
<Overlap Ratio: 0.7598784194528876>

---

--- 125 --
Question ID: e4a3c74aeda420cb7cd19c8e11a7c90d1c2b9d1f_18
Original Code:
```
extern "x86-interrupt" fn timer_interrupt_handler(_frame: InterruptStackFrame) {
    crate::time::pit_tick();
    // might not be initialized yet
    if let Some(exc) = crate::task::executor::GLOBAL_EXECUTOR.get() {
        exc.sleep_tick_set();
    }

    match LOCAL_APIC.lock().as_mut() {
        Some(apic) => unsafe { apic.end_of_interrupt() },
        None => unsafe { PICS.lock().notify_end_of_interrupt(InterruptIndex::Timer.as_u8()); }
    }
}
```


Overlapping Code:
```
 "x86-interrupt" fn timer_interrupt_handler(_frame: InterruptStackFrame) {
crate::time::pit_tick();
// might not be initialized yet
if let Some(exc) = crate::task::executor::GLOBAL_EXECUTOR.get() {
exc.sleep_tick_set();
}
match LOCAL_APIC.lock().as_mut() {
Some(apic) => unsafe { apic.end_of_interrupt() },
None => unsafe { PICS.lock().notify_end_of_interrupt(InterruptIndex::Timer.as_u8()
```
<Overlap Ratio: 0.9652605459057072>

---

--- 126 --
Question ID: c964fbd0ebbd95a38a4784b7af429894f461fec3_0
Original Code:
```
pub fn encode_vox(map: &Array3<VoxColor>) -> DotVoxData {
    let global_extent = *map.extent();
    let local_extent = global_extent - global_extent.minimum;
    let shape = local_extent.shape;

    // VOX coordinates are limited to u8.
    assert!(shape <= PointN([std::u8::MAX as i32; 3]));

    let size = dot_vox::Size {
        x: shape.x() as u32,
        y: shape.y() as u32,
        z: shape.z() as u32,
    };

    let mut voxels = Vec::new();
    for p in local_extent.iter_points() {
        if let VoxColor::Color(i) = map.get(&Local(p)) {
            voxels.push(dot_vox::Voxel {
                x: p.x() as u8,
                y: p.y() as u8,
                z: p.z() as u8,
                i,
            });
        }
    }

    let model = dot_vox::Model { size, voxels };

    DotVoxData {
        version: 150,
        models: vec![model],
        palette: Vec::new(),
        materials: Vec::new(),
    }
}
```


Overlapping Code:
```
olor>) -> DotVoxData {
let global_extent = *map.extent();
let local_extent = global_extent - global_extent.minimum;
let shape = local_extent.shape;
// VOX coordinates are limited to u8.
assert!(shape <= PointN([std::u8::MAX as i32; 3]));
let size = dot_vox::Size {
x: shape.x() as u32,
y: shape.y() as u32,
z: shape.z() as u32,
};
let mut voxels = Vec::new();
for p in local_extent.iter_points() {
if let VoxColor::Color(i) = map.get(&Local(p)) {
voxels.push(dot_vox::Voxel {
x: p.x() as u8,
y: p.y() as u8,
z: p.z() as u8,
i,
});
}
}
let model = dot_vox::Model { size, voxels };
DotVoxData {
version: 150,
models: vec![model],
palette: Vec::new(),
materials: Ve
```
<Overlap Ratio: 0.9323943661971831>

---

--- 127 --
Question ID: f8f1435b8cbe7ea0bc554a80558fe8be4cd58671_2
Original Code:
```
fn try_lock_conflict_addr<P: AsRef<Path>>(path: P) -> File {
    let f = File::create(path.as_ref()).unwrap_or_else(|e| {
        fatal!(
            "failed to create dagger at {}: {}",
            path.as_ref().display(),
            e
        )
    });

    if f.try_lock_exclusive().is_err() {
        fatal!(
            "{} already in use, maybe another instance is Constrained with this address.",
            path.as_ref().file_name().unwrap().to_str().unwrap()
        );
    }
    f
}
```


Overlapping Code:
```
k_conflict_addr<P: AsRef<Path>>(path: P) -> File {
let f = File::create(path.as_ref()).unwrap_or_else(|e| {
fatal!(
"failed to create dagger at {}: {}",
path.as_ref().display(),
e
)
});
if f.try_lock_exclusive().is_err() {
fatal!(
"{} already in use, maybe another instance is Constrained with this address.",
path.as_ref().file_name().unwrap().to_str().unwrap()
);
```
<Overlap Ratio: 0.958005249343832>

---

--- 128 --
Question ID: cd84618250aae6bd88ab87616c4eba24790d237b_0
Original Code:
```
pub(crate) fn parse_hdel(mut iter: Iter<Vec<u8>>) -> HDEL {
    let key = iter.next().unwrap();
    let mut fields = Vec::new();
    while let Some(field) = iter.next() {
        fields.push(field.as_slice());
    }
    HDEL { key, fields }
}
```


Overlapping Code:
```
l(mut iter: Iter<Vec<u8>>) -> HDEL {
let key = iter.next().unwrap();
let mut fields = Vec::new();
while let Some(field) = iter.next() {
fields.push(fi
```
<Overlap Ratio: 0.7009345794392523>

---

--- 129 --
Question ID: 280909d27d1b477ada1859382bed40a6c210a1f2_1
Original Code:
```
fn test_interval_compare() {
            use std::cmp::Ordering;
            {
                let iv = Interval::<i32>::bounded(1, 10, Vec::new());
                use std::cmp::Ordering;
                assert!(iv.compare_elem(&0) == Ordering::Greater);
                assert!(iv.compare_elem(&2) == Ordering::Equal);
                assert!(iv.compare_elem(&11) == Ordering::Less);
            }
            {
                let iv = Interval::<i32>::with_lower_bound(1, Vec::new());
                assert!(iv.compare_elem(&0) == Ordering::Greater);
                // Not sure this should be equal
                assert!(iv.compare_elem(&1) == Ordering::Equal);
                assert!(iv.compare_elem(&2) == Ordering::Less);
            }
        }
```


Overlapping Code:
```
{
use std::cmp::Ordering;
{
let iv = Interval::<i32>::bounded(1, 10, Vec::new());
use std::cmp::Ordering;
assert!(iv.compare_elem(&0) == Ordering::Greater);
assert!(iv.compare_elem(&2) == Ordering::Equal);
assert!(iv.compare_elem(&11) == Ordering::Less);
}
{
let iv = Interval::<i32>::with_lower_bound(1, Vec::new());
assert!(iv.compare_elem(&0) == Ordering::Greater);
// Not sure this should be equal
assert!(iv.compare_elem(&1) == Ordering::Equal);
assert!(iv.compare_elem(&2) == Ordering::Less);
}
```
<Overlap Ratio: 0.945179584120983>

---

--- 130 --
Question ID: 9cabdbe62a0e4864d1edf0d4817383797db3064e_0
Original Code:
```
pub fn update_table_circuit<F, O>(
    circuit: &mut F,
    evaluator_table: impl encoded::LazilyEncodedTable<
        F,
        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
        Error = anyhow::Error,
    >,
    last_upd_table: encoded::IndexColumns<<F as Fancy>::Item>,
    r: impl encoded::LazilyEncodedTable<
        F,
        Item = (
            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
            BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
        ),
        Error = anyhow::Error,
    >,
    receiver: encoded::Receiver<<F as Fancy>::Item>,
    evaluator_loc_share: encoded::LocationShare<<F as Fancy>::Item>,
    mut output_builder: O,
) -> Result<O::Output>
where
    F: Fancy + FancyInput<Item = <F as Fancy>::Item>,
    O: OutputBuilder<
        F,
        Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
        Error = anyhow::Error,
    >,
{
    {
        // Check pre-conditions
        let evaluator_table_size = evaluator_table.size();
        let last_upd_table_size = last_upd_table.size();
        let r_size = r.size();

        ensure!(
            evaluator_table_size.m == last_upd_table_size,
            "evaluator table and last upd tables are differently sized (evaluator table size = {:?}, last upd tables size = {})",
            evaluator_table_size, last_upd_table_size
        );
        ensure!(
            evaluator_table_size == r_size,
            "evaluator table and r table are differently sized (evaluator table size = {:?}, r size = {:?})",
            evaluator_table_size, r_size
        )
    }

    let size = evaluator_table.size();

    let receiver = circuit
        .bytes_xor(&receiver.gb, &receiver.ev)
        .context("construct receiver wires")?;

    let joint_tables = last_upd_table
        .join()
        .zip(evaluator_table.rows_iter())
        .zip(r.rows_iter());
    for (i, (((last_upd_gb, last_upd_ev), mut loc_row), mut blinding_row)) in
        joint_tables.enumerate()
    {
        let index = circuit
            .bytes_xor(last_upd_gb, last_upd_ev)
            .context("construct last_upd_index")?;
        for j in 0..size.l {
            let prev_loc = loc_row
                .next_item(circuit)
                .context("retrieve next item")?
                .context("internal: unexpected end of row")?;
            let (r_gb, r_ev) = blinding_row
                .next_item(circuit)
                .context("retrieve next blinding")?
                .context("internal: unexpected end of row (blindings)")?;

            let i_bundle = circuit
                .bytes_constant(&ByteArray::new((i as u16).to_be_bytes()))
                .context("convert i to wires")?;
            let j_bundle = circuit
                .bytes_constant(&ByteArray::new((j as u16).to_be_bytes()))
                .context("convert j to wires")?;
            let condition_a = circuit
                .bytes_eq(&i_bundle, &receiver)
                .context("construct condition_a")?;
            let condition_b = circuit
                .bytes_eq(&j_bundle, &index)
                .context("construct condition_b")?;
            let condition = circuit
                .and(&condition_a, &condition_b)
                .map_err(|e| anyhow!("construct condition: {}", e))?;

            let maybe_overridden = circuit
                .bytes_mux(&condition, &prev_loc, &evaluator_loc_share)
                .context("construct maybe_overridden")?;
            let r = circuit.bytes_xor(&r_gb, &r_ev).context("construct r")?;
            let new_value = circuit
                .bytes_xor(&maybe_overridden, &r)
                .context("construct new_value")?;

            output_builder
                .process_next(circuit, &new_value)
                .context("not processed by output_builder")?;
        }
    }
    output_builder.finish()
}
```


Overlapping Code:
```
te_table_circuit<F, O>(
circuit: &mut F,
evaluator_table: impl encoded::LazilyEncodedTable<
F,
Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
Error = anyhow::Error,
>,
last_upd_table: encoded::IndexColumns<<F as Fancy>::Item>,
r: impl encoded::LazilyEncodedTable<
F,
Item = (
BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
),
Error = anyhow::Error,
>,
receiver: encoded::Receiver<<F as Fancy>::Item>,
evaluator_loc_share: encoded::LocationShare<<F as Fancy>::Item>,
mut output_builder: O,
) -> Result<O::Output>
where
F: Fancy + FancyInput<Item = <F as Fancy>::Item>,
O: OutputBuilder<
F,
Item = BytesBundle<<F as Fancy>::Item, LOCATION_BYTES>,
Error = anyhow::Error,
>,
{
{
// Check pre-conditions
let evaluator_table_size = evaluator_table.size();
let last_upd_table_size = last_upd_table.size();
let r_size = r.size();
ensure!(
evaluator_table_size.m == last_upd_table_size,
"evaluator table and last upd tables are differently sized (evaluator table size = {:?}, last upd tables size = {})",
evaluator_table_size, last_upd_table_size
);
ensure!(
evaluator_table_size == r_size,
"evaluator table and r table are differently sized (evaluator table size = {:?}, r size = {:?})",
evaluator_table_size, r_size
)
}
let size = evaluator_table.size();
let receiver = circuit
.bytes_xor(&receiver.gb, &receiver.ev)
.context("construct receiver wires")?;
let joint_tables = last_upd_table
.join()
.zip(evaluator_table.rows_iter())
.zip(r.rows_iter());
for (i, (((last_upd_gb, last_upd_ev), mut loc_row), mut blinding_row)) in
joint_tables.enumerate()
{
let index = circuit
.bytes_xor(last_upd_gb, last_upd_ev)
.context("construct last_upd_index")?;
for j in 0..size.l {
let prev_loc = loc_row
.next_item(circuit)
.context("retrieve next item")?
.context("internal: unexpected end of row")?;
let (r_gb, r_ev) = blinding_row
.next_item(circuit)
.context("retrieve next blinding")?
.context("interna
```
<Overlap Ratio: 0.989345509893455>

---

--- 131 --
Question ID: 6dc9a3d2205df6a78355851fd18812b967628c17_2
Original Code:
```
fn get_parents(input: &[Vec<String>], child: String) -> Vec<String> {
    let parents = |x: Vec<String>| {
        x.iter()
            .rev()
            .cloned()
            .skip_while(|y| *y != child)
            .skip(1)
            .collect::<Vec<_>>()
    };
    let mut result = Vec::new();
    for line in input {
        let mut current_parents = parents(line.clone());
        if !current_parents.is_empty() {
            result.push(current_parents.pop().unwrap());
        }
    }
    result
}
```


Overlapping Code:
```
tring>], child: String) -> Vec<String> {
let parents = |x: Vec<String>| {
x.iter()
.rev()
.cloned()
.skip_while(|y| *y != child)
.skip(1)
.collect::<Vec<_>>()
};
let mut result = Vec::new();
for line in input {
let mut current_parents = parents(line.clone());
if !current_parents.is_empty() {
result.push(current_parents.pop().unwrap());
}
}
result
}
```
<Overlap Ratio: 0.9234828496042217>

---

--- 132 --
Question ID: bb8bfcc7febbd2c47007d23c0f5930e8fe23b867_38
Original Code:
```
pub fn softplus<T: Into<Variable>>(x: T) -> Function {
    let xv = x.into();
    let xpayload: VariableInner = xv.borrow().payload;
    let payload = unsafe {
        let mut error_p: *mut i8 = ptr::null_mut();
        let payload = cpp!([xpayload as "Variable", mut error_p as "char*"] -> FunctionInner as "FunctionPtr" {
            try {
                return Softplus(xpayload);
            } catch (std::exception& e) {
                auto what = e.what();
                error_p = new char[strlen(what)+1];
                strcpy(error_p, what);
                return nullptr;
            }
        });
        if !error_p.is_null() {
             let msg = CStr::from_ptr(error_p).to_str().unwrap();
             panic!("{}", msg);
        }
        payload
    };
    Function {payload}
}
```


Overlapping Code:
```
pub fn softplus<T: Into<Variable>>(x: T) -> Function {
let xv = x.into();
let xpayload: VariableInner = xv.borrow().payload;
let payload = unsafe {
let mut error_p: *mut i8 = ptr::null_mut();
let payload = cpp!([xpayload as "Variable", mut error_p as "char*"] -> FunctionInner as "FunctionPtr" {
try {
return Softplus(xpayload);
} catch (std::exception& e) {
auto what = e.what();
error_p = new char[strlen(what)+1];
strcpy(error_p, what);
return nullptr;
}
});
if !error_p.is_null() {
let msg = CStr::from_ptr(error_p).to_str().unwrap();
panic!("{}", msg);
}
payload
};
Function {payload}
}
```
<Overlap Ratio: 1.0>

---

--- 133 --
Question ID: b562eb5c3b4a82e52f846ee182e8f7e0dff024ad_0
Original Code:
```
async fn it_gets_a_character() {
        let data = "{ \"id\": 1, \"name\": \"John Doe\", \"status\": \"Alive\", \"species\": \"Human\", \"type\": \"\", \"gender\": \"Male\", \"origin\": { \"name\": \"\", \"url\": \"\" }, \"location\": { \"name\": \"\", \"url\": \"\" }, \"image\": \"mock.jpeg\", \"episode\": [], \"url\": \"mock.mock\", \"created\": \"mock\" }";

        let _m = mock("GET", "/api/character/1")
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(data)
            .create();

        let mut expected = character::Character::default();
        expected.id = 1;
        expected.name = "John Doe".to_string();
        expected.status = "Alive".to_string();
        expected.character_type = "".to_string();
        expected.gender = "Male".to_string();
        expected.image = "mock.jpeg".to_string();
        expected.url = "mock.mock".to_string();
        expected.created = "mock".to_string();
        expected.species = "Human".to_string();

        let req = character::get(1).await;
        match req {
            Ok(c) => {
                assert_eq!(c, expected)
            }
            Err(e) => {
                println!("request error: {:?}", e);
                panic!("request failed");
            }
        }
    }
```


Overlapping Code:
```
\", \"type\": \"\", \"gender\": \"Male\", \"origin\": { \"name\": \"\", \"url\": \"\" }, \"location\": { \"name\": \"\", \"url\": \"\" }, \"image\": \"mock.jpeg\", \"episode\": [], \"url\": \"mock.mock\", \"created\": \"mock\" }";
let _m = mock("GET", "/api/character/1")
.with_status(200)
.with_header("content-type", "application/json")
.with_body(data)
.create();
let mut expected = character::Character::default();
expected.id = 1;
expected.name to_string();
expected.character_type = "".to_string();
expected.gender = "Male".to_string();
expected.image = "mock.jpeg".to_string();
expected.url = "mock.mock".to_string();
expected.created = "mock".to_string();
expected.species = "Human".to_string();
let req = character::get(1).await;
match req {
Ok(c) => {
assert_eq!(c, expected)
}
Err(e) => {
println!("request error: {:?}", e);
panic!("reques
```
<Overlap Ratio: 0.814176245210728>

---

--- 134 --
Question ID: 6e33c3e19a2967459a839994df5d700eb8fdbde5_0
Original Code:
```
fn main() unsafe {
    let i = ~@1;
    let j = ~@2;
    let rc1 = refcount(*i);
    let j = i;
    let rc2 = refcount(*i);
    error!("rc1: %u rc2: %u", rc1, rc2);
    assert rc1 + 1u == rc2;
}
```


Overlapping Code:
```
 i = ~@1;
let j = ~@2;
let rc1 = refcount(*i);
let j = i;
let rc2 = refcount(*i);
error!("rc1: %u rc
```
<Overlap Ratio: 0.6024096385542169>

---

--- 135 --
Question ID: ea10c8bcf011c08141369fab482a1c92882c15f5_1
Original Code:
```
pub fn generate_NS_trick<'a, 'b>(
    original_packet: &ndp::NeighborSolicitPacket<'a>,
    src_addr: &Ipv6Addr,
    dst_addr: &Ipv6Addr,
) -> Option<Icmpv6Packet<'b>> {
    let pkt_buf: Vec<u8> =
        vec![0; original_packet.packet_size() + Icmpv6Packet::minimum_packet_size()];
    let mut ret = match MutableIcmpv6Packet::owned(pkt_buf) {
        Some(v) => v,
        None => return None,
    };
    // update the option field if needed
    // convert it into a icmp echo request
    ret.set_icmpv6_type(Icmpv6Types::EchoRequest);
    ret.set_payload(original_packet.packet());
    //
    let csum = pnet::util::ipv6_checksum(
        ret.packet(),
        1,
        &[],
        src_addr,
        dst_addr,
        pnet::packet::ip::IpNextHeaderProtocols::Icmpv6,
    );
    ret.set_checksum(csum);

    Some(ret.consume_to_immutable())
}
```


Overlapping Code:
```
, 'b>(
original_packet: &ndp::NeighborSolicitPacket<'a>,
src_addr: &Ipv6Addr,
dst_addr: &Ipv6Addr,
) -> Option<Icmpv6Packet<'b>> {
let pkt_buf: Vec<u8> =
vec![0; original_packet.packet_size() + Icmpv6Packet::minimum_packet_size()];
let mut ret = match MutableIcmpv6Packet::owned(pkt_buf) {
Some(v) => v,
None => return None,
};
// update the option field if needed
// convert it into a icmp echo request
ret.set_icmpv6_type(Icmpv6Types::EchoRequest);
ret.set_payload(original_packet.packet());
//
let csum = pnet::util::ipv6_checksum(
ret.packet(),
1,
&[],
src_addr,
dst_addr,
pnet::packet::ip::IpNextHeaderProtocols::Icmpv6,
);
ret.set_checksum(csum);
Some(ret.consume_to
```
<Overlap Ratio: 0.9411764705882353>

---

--- 136 --
Question ID: cb10447cf716fdc3671bf2eecb5086e45814d483_5
Original Code:
```
fn default_plane() {
        let o = Object::default_plane();

        assert_relative_eq!(o.transform, Transform::default());
        assert_relative_eq!(o.material, Material::default());
        assert_relative_eq!(o.shape, Shape::Plane(Plane));
    }
```


Overlapping Code:
```
ect::default_plane();
assert_relative_eq!(o.transform, Transform::default());
assert_relative_eq!(o.material, Material::default());
assert_relative_eq!(o.shape, 
```
<Overlap Ratio: 0.7453703703703703>

---

--- 137 --
Question ID: 03d660c5420b4599a5f2aece38f200b596a7bf9a_43
Original Code:
```
fn execute_state_machine_returns_304_if_non_match_star_exists_and_is_a_head_or_get() {
  let mut context = WebmachineContext {
    request: WebmachineRequest {
      method: "HEAD".to_string(),
      headers: hashmap! {
        "If-None-Match".to_string() => vec![h!("*")]
      },
      ..WebmachineRequest::default()
    },
    ..WebmachineContext::default()
  };
  let resource = WebmachineResource {
    resource_exists: callback(&|_, _| true),
    allowed_methods: vec!["HEAD"],
    ..WebmachineResource::default()
  };
  execute_state_machine(&mut context, &resource);
  expect(context.response.status).to(be_equal_to(304));
}
```


Overlapping Code:
```
ute_state_machine_returns_304_if_non_match_star_exists_and_is_a_head_or_get() {
let mut context = WebmachineContext {
request: WebmachineRequest {
method: "HEAD".to_string(),
headers: hashmap! {
"If-None-Match".to_string() => vec![h!("*")]
},
..WebmachineRequest::default()
},
..WebmachineContext::default()
};
let resource = WebmachineResource {
resource_exists: callback(&|_, _| true),
allowed_methods: vec!["HEAD"],
..WebmachineResource::default()
};
execute_state_machine(&mut context, &resource);
expect(context.response.status).to(be_equal_to(
```
<Overlap Ratio: 0.973404255319149>

---

--- 138 --
Question ID: 978be39012e1ca76564e01a7765b90975267bed7_1
Original Code:
```
fn main () {
    // Use clap for command-line argument parsing.
    let matches = App::new("owl")
        .author("Alex Eubanks <endeavor@rainbowsandpwnies.com>")
        .about("ROP Gadget Finder")
        .arg(Arg::with_name("filter")
            .short("f")
            .value_name("filter")
            .help("Filter rop gadgets by substring"))
        .arg(Arg::with_name("program")
            .required(true)
            .index(1))
        .get_matches();

    // Read in our program.
    let filename = matches.value_of("program").unwrap();
    let path = Path::new(&filename);
    let mut fd = File::open(path).unwrap();

    let mut data = Vec::new();
    fd.read_to_end(&mut data).unwrap();
    
    // Parse the file with Elf.
    match goblin::Object::parse(&data).unwrap() {
        goblin::Object::Elf(elf) => {
            do_elf(&data, &elf, matches.value_of("filter"));
        },
        _ => println!("Unsupported file format")
    }
}
```


Overlapping Code:
```
 () {
// Use clap for command-line argument parsinith_name("filter")
.short("f")
.value_name("filter")
.help("Filter rop gadgets by substring"))
.arg(Arg::with_name("program")
.required(true)
.index(1))
.get_matches();
// Read in our program.
let filename = matches.value_of("program").unwrap();
let path = Path::new(&filename);
let mut fd = File::open(path).unwrap();
let mut data = Vec::new();
fd.read_to_end(&mut data).unwrap();

// Parse the file with Elf.
match goblin::Object::parse(&data).unwrap() {
goblin::Object::Elf(elf) => {
do_elf(&data, &elf, matches.value_of("filter"));
},
_ => printl
```
<Overlap Ratio: 0.7802340702210663>

---

--- 139 --
Question ID: bd3ae9ec775032fdf42a7d05096c325724816f72_0
Original Code:
```
fn build_guardian_set(length: usize) -> GuardianSetInfo {
        let mut addresses: Vec<GuardianAddress> = Vec::with_capacity(length);
        for _ in 0..length {
            addresses.push(GuardianAddress {
                bytes: vec![].into(),
            });
        }

        GuardianSetInfo {
            addresses,
            expiration_time: 0,
        }
    }
```


Overlapping Code:
```
an_set(length: usize) -> GuardianSetInfo {
let mut addresses: Vec<GuardianAddress> = Vec::with_capacity(length);
for _ in 0..length {
addresses.push(GuardianAddress {
bytes: vec![].into(),
});
}
GuardianSetInfo {
addresses,
e
```
<Overlap Ratio: 0.8587786259541985>

---

--- 140 --
Question ID: 854b5212e7f41872f5f78bae53add1d8165a6486_48
Original Code:
```
fn should_2_e6_contains_n_3_4_5_6() {
    let range = Range::init("(2,6]");
    let range_2 = Range::init("{3,4,5,6}");
    assert_eq!(range.range_contains(&range_2), true);
}
```


Overlapping Code:
```
_e6_contains_n_3_4_5_6() {
let range = Range::init("(2,6]");
let range_2 = Range::init("{3,4,5,6}");
assert_eq!(range.range_contains(&range_2), true);
```
<Overlap Ratio: 0.9202453987730062>

---

--- 141 --
Question ID: dc15ab4f40ac819b848723059039889769581e6a_0
Original Code:
```
fn default_logger() {
    use std::sync::Once;
    use tracing_subscriber::prelude::*;
    use tracing_subscriber::{fmt, EnvFilter};
    static START: Once = Once::new();
    START.call_once(|| {
        let fmt_layer = fmt::layer().with_target(false);
        let filter_layer = EnvFilter::try_from_default_env()
            .or_else(|_| EnvFilter::try_new("debug"))
            .unwrap();

        tracing_subscriber::registry()
            .with(fmt_layer)
            .with(filter_layer)
            .init();
    });
}
```


Overlapping Code:
```
ult_logger() {
use std::sync::Once;
use tracing_subscriber::prelude::*;
use tracing_subscriber::{fmt, EnvFilter};
static START: Once = Once::new();
START.call_once(|| {
let fmt_layer = fmt::layer().with_target(false);
let filter_layer = EnvFilter::try_from_default_env()
.or_else(|_| EnvFilter::try_new("debug"))
.unwrap();
tracing_subscriber::registry()
.with(fmt_layer)
.with(filter_layer)
.init();
```
<Overlap Ratio: 0.9685230024213075>

---

--- 142 --
Question ID: f1cd11120a491962bbd301a9efa607a0b4aee9a8_3
Original Code:
```
fn test_auto() {
    let trace = false;
    test_file("./tests/data/builtins.gos", trace);
    test_file("./tests/data/const0.gos", trace);
    test_file("./tests/data/const1.gos", trace);
    test_file("./tests/data/constdecl.gos", trace);
    test_file("./tests/data/conversions.gos", trace);
    test_file("./tests/data/conversions2.gos", trace);
    test_file("./tests/data/cycles.gos", trace);
    test_file("./tests/data/cycles1.gos", trace);
    test_file("./tests/data/cycles2.gos", trace);
    test_file("./tests/data/cycles3.gos", trace);
    test_file("./tests/data/cycles4.gos", trace);
    test_file("./tests/data/cycles5.gos", trace);
    test_file("./tests/data/decls0.src", trace);
    test_file("./tests/data/decls1.src", trace);
    test_file("./tests/data/decls2", trace);
    test_file("./tests/data/decls3.src", trace);
    test_file("./tests/data/decls4.src", trace);
    test_file("./tests/data/decls5.src", trace);
    test_file("./tests/data/errors.src", trace);
    test_file("./tests/data/expr0.src", trace);
    test_file("./tests/data/expr2.src", trace);
    test_file("./tests/data/expr3.src", trace);
    test_file("./tests/data/gotos.src", trace);
    test_file("./tests/data/importdecl0", trace);
    test_file("./tests/data/importdecl1", trace);

    test_file("./tests/data/init0.src", trace);
    test_file("./tests/data/init1.src", trace);
    test_file("./tests/data/init2.src", trace);

    test_file("./tests/data/issues.src", trace);
    test_file("./tests/data/labels.src", trace);
    test_file("./tests/data/methodsets.src", trace);
    test_file("./tests/data/shifts.src", trace);
    test_file("./tests/data/stmt0.src", trace);
    test_file("./tests/data/stmt1.src", trace);
    test_file("./tests/data/vardecl.src", trace);
}
```


Overlapping Code:
```
t_auto() {
let trace = false;
test_file("./tests/data/builtins.gos", trace);
test_file("./tests/data/const0.gos", trace);
test_file("./tests/data/const1.gos", trace);
test_file("./tests/data/constdecl.gos", trace);
test_file("./tests/data/conversions.gos", trace);
test_file("./tests/data/conversions2.gos", trace);
test_file("./tests/data/cycles.gos", trace);
test_file("./tests/data/cycles1.gos", trace);
test_file("./tests/data/cycles2.gos", trace);
test_file("./tests/data/cycles3.gos", trace);
test_file("./tests/data/cycles4.gos", trace);
test_file("./tests/data/cycles5.gos", trace);
test_file("./tests/data/decls0.src", trace);
test_file("./tests/data/decls1.src", trace);
test_file("./tests/data/decls2", trace);
test_file("./tests/data/decls3.src", trace);
test_file("./tests/data/decls4.src", trace);
test_file("./tests/data/decls5.src", trace);
test_file("./tests/data/errors.src", trace);
test_file("./tests/data/expr0.src", trace);
test_file("./tests/data/expr2.src", trace);
test_file("./tests/data/expr3.src", trace);
test_file("./tests/data/gotos.src", trace);
test_file("./tests/data/importdecl0", trace);
test_file("./tests/data/importdecl1", trace);
test_file("./tests/data/init0.src", trace);
test_file("./tests/data/init1.src", trace);
test_file("./tests/data/init2.src", trace);
test_file("./tests/data/issues.src", trace);
test_file("./tests/data/labels.src", trace);
test_file("./tests/data/methodsets.src", trace);
test_file("./tests/data/shifts.src", trace);
test_file("./tests/data/stmt0.src", trace);
test_file("./tests/data/stmt1.src", trace);
test_file("./tests/data/va
```
<Overlap Ratio: 0.9834050399508297>

---

--- 143 --
Question ID: 4e7ae383ca222b011940b511f5525d9e54488a4e_0
Original Code:
```
fn run_build(project: String, database: &MysqlConnection) -> Result<(), Box<dyn Error>> {
    println!("Building '{}'", project);
    let project_path = format!("data/projects/{}", project);
    let path = Path::new(&project_path);

    let project_id = get_project_id(database, &project);

    if path.exists() && path.is_dir() {
        let settings_file_path = format!("{}/.drovah", project_path);
        let ci_settings_file = Path::new(&settings_file_path);
        let settings_string = fs::read_to_string(ci_settings_file)?;
        let ci_config: CIConfig = toml::from_str(&settings_string)?;

        if run_commands(
            ci_config.build.commands,
            &project_path,
            ci_config.archive.is_some(),
        ) {
            println!("Success! '{}' has been built.", project);

            if let Some(files) = ci_config.archive {
                if archive_files(
                    files.files,
                    project_id.unwrap(),
                    database,
                    files.append_buildnumber,
                ) {
                    println!("Successfully archived files for '{}'", project);

                    if let Some(post_archive) = ci_config.postarchive {
                        if run_commands(post_archive.commands, &project_path, false) {
                            println!("Successfully ran post-archive commands for '{}'", project);
                        } else {
                            println!(
                                "Error occurred running post-archive commands for '{}'",
                                project
                            );
                        }
                    }
                } else {
                    println!("Failed to archive files for '{}'", project);
                }
            } else {
                save_project_build_data(project, "passing".to_owned(), database, vec![]);
            }
        } else {
            println!("'{}' has failed to build.", project);
            save_project_build_data(project, "failing".to_owned(), database, vec![]);
        }
    }
    Ok(())
}
```


Overlapping Code:
```
fn run_build(project: String, database: &MysqlConnection) -> Result<(), Box<dyn Error>> {
println!("Building '{}'", project);
let project_path = format!("data/projects/{}", project);
let path = Path::new(&project_path);
let project_id = get_project_id(database, &project);
if path.exists() && path.is_dir() {
let settings_file_path = format!("{}/.drovah", project_path);
let ci_settings_file = Path::new(&settings_file_path);
let settings_string = fs::read_to_string(ci_settings_file)?;
let ci_config: CIConfig = toml::from_str(&settings_string)?;
if run_commands(
ci_config.build.commands,
&project_path,
ci_config.archive.is_some(),
) {
println!("Success! '{}' has been built.", project);
if let Some(files) = ci_config.archive {
if archive_files(
files.files,
project_id.unwrap(),
database,
files.append_buildnumber,
) {
println!("Successfully archived files for '{}'", project);
if let Some(post_archive) = ci_config.postarchive {
if run_commands(post_archive.commands, &project_path, false) {
println!("Successfully ran post-archive commands for '{}'", project);
} else {
println!(
"Error occurred running post-archive commands for '{}'",
project
);
}
}
} else {
println!("Failed to archive files for '{}'", project);
}
} else {
save_project_build_data(project, "passing".to_owned(), database, vec![]);
}
} else {
println!("'{}' has failed to build.", project);
save_project_build_data(project, "failing".to_owned(), database, vec![]);
}
}
Ok(()
```
<Overlap Ratio: 0.9979353062629044>

---

--- 144 --
Question ID: 051d6e3067c3cb429fe5956ee53ade84e86afc2e_0
Original Code:
```
pub fn estimated_memory_cost(mempool: &Mempool) -> usize {
    let txbytes: usize = mempool.items().map(|item| item.tx.encoded_length()).sum();

    let utxoproofsbytes: usize = mempool
        .items()
        .flat_map(|i| i.proofs.iter().map(|p| utreexo_proof_memory_cost(p)))
        .sum();
    txbytes + utxoproofsbytes
}
```


Overlapping Code:
```
mory_cost(mempool: &Mempool) -> usize {
let txbytes: usize = mempool.items().map(|item| item.tx.encoded_length()).sum();
let utxoproofsbytes: usize = mempool
.items()
.flat_map(|i| i.proofs.iter().map(|p| utreexo_proof_memory_cost(p)))
.sum();
txbyte
```
<Overlap Ratio: 0.8620689655172413>

---

--- 145 --
Question ID: aeed588aa4dac4e4d7e6deba038bd6f6df9fe88c_1
Original Code:
```
fn decode_header_map<R>(reader: &mut R) -> Result<HashMap<String, Vec<u8>>, AvrowErr>
where
    R: Read,
{
    let count: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;
    let count = count as usize;
    let mut map = HashMap::with_capacity(count);

    for _ in 0..count {
        let key = decode_string(reader)?;
        let val = decode_bytes(reader)?;
        map.insert(key, val);
    }

    let _map_end: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;

    Ok(map)
}
```


Overlapping Code:
```
_map<R>(reader: &mut R) -> Result<HashMap<String, Vec<u8>>, AvrowErr>
where
R: Read,
{
let count: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)?;
let count = count as usize;
let mut map = HashMap::with_capacity(count);
for _ in 0..count {
let key = decode_string(reader)?;
let val = decode_bytes(reader)?;
map.insert(key, val);
}
let _map_end: i64 = reader.read_varint().map_err(AvrowErr::DecodeFailed)
```
<Overlap Ratio: 0.9367945823927766>

---

--- 146 --
Question ID: bfef59a6a5403c8fd4eab2e86a080864783f711a_4
Original Code:
```
fn get_bytes(tryte: Tryte) -> Vec<u8> {
        let mut bytes = vec![];
        tryte.write_bytes(&mut bytes).unwrap();
        bytes
    }
```


Overlapping Code:
```
{
let mut bytes = vec![];
tryte.write_bytes(&mut b
```
<Overlap Ratio: 0.45045045045045046>

---

--- 147 --
Question ID: ee4d532b06074860ee78a6a033ea1c4abfd2ec28_4
Original Code:
```
fn try_read_up_to() {
            let src = b"1234567890";
            let mut buf = TryVec::new();
            super::try_read_up_to(&mut src.as_ref(), 5, &mut buf).unwrap();
            assert_eq!(buf.len(), 5);
            assert_eq!(buf, b"12345".as_ref());
        }
```


Overlapping Code:
```
 src = b"1234567890";
let mut buf = TryVec::new();
super::try_read_up_to(&mut src.as_ref(), 5, &mut buf).unwrap();
assert_eq!(buf.len(), 5);
assert_eq!(buf, 
```
<Overlap Ratio: 0.7733990147783252>

---

--- 148 --
Question ID: 6db7056050c55aa14331f1f251ee136d62c93889_0
Original Code:
```
pub fn iso3_to_gd(iso: &na::Isometry3<f64>) -> Transform {
    let origin = Vector3::new(
        iso.translation.x as f32,
        iso.translation.y as f32,
        iso.translation.z as f32,
    );
    let r = iso.rotation.to_rotation_matrix();
    let basis = Basis::from_elements([
        Vector3::new(r[(0, 0)] as f32, r[(0, 1)] as f32, r[(0, 2)] as f32),
        Vector3::new(r[(1, 0)] as f32, r[(1, 1)] as f32, r[(1, 2)] as f32),
        Vector3::new(r[(2, 0)] as f32, r[(2, 1)] as f32, r[(2, 2)] as f32),
    ]);
    Transform { origin, basis }
}
```


Overlapping Code:
```
etry3<f64>) -> Transform {
let origin = Vector3::new(
iso.translation.x as f32,
iso.translation.y as f32,
iso.translation.z as f32,
);
let r = iso.rotation.to_rotation_matrix();
let basis = Basis::from_elements([
Vector3::new(r[(0, 0)] as f32, r[(0, 1)] as f32, r[(0, 2)] as f32),
Vector3::new(r[(1, 0)] as f32, r[(1, 1)] as f32, r[(1, 2)] as f32),
Vector3::new(r[(2, 0)] as f32, r[(2, 1)] as f32, r[(2, 2)] as f32),
]);
Transform { origin, basis }
}
```
<Overlap Ratio: 0.9336099585062241>

---

--- 149 --
Question ID: 0fa43e5aba425d2178f55950eeb61438ed26794e_0
Original Code:
```
fn main() -> Result<()>{
    let mut input = String::new();
    io::stdin().read_to_string(&mut input)?;

    let points = input.lines().
        map(|l| l.parse()).collect::<Result<Vec<Point>>>()?;

    let n = points.len();
    let mut connections: Vec<usize> = (0..n).collect();

    for i in 0..n {
        for j in 0..n {
            if find(i, &mut connections) == find(j, &mut connections) {
                continue;
            }
            if points[i].is_same_constellation(&points[j]) {
                union(i, j, &mut connections)
            }
        }
    }

    let mut constellation = HashSet::new();
    for &i in &connections {
        if !constellation.contains(&i) {
            constellation.insert(i);
        }
    }

    println!("part1 answer: {:?}", constellation.len());

    Ok(())
}
```


Overlapping Code:
```
fn main() -> Result<()>{
let mut input = String::new();
io::stdin().read_to_string(&mut input)?;
let points = input.lines().
map(|l| l.parse()).collect::<Result<Vec<Point>>>()?;
let n = points.len();
let mut connections: Vec<usize> = (0..n).collect();
for i in 0..n {
for j in 0..n {
if find(i, &mut connections) == find(j, &mut connections) {
continue;
}
if points[i].is_same_constellation(&points[j]) {
union(i, j, &mut connections)
}
}
}
let mut constellation = HashSet::new();
for &i in &connections {
if !constellation.contains(&i) {
constellation.insert(i);
}
}
println!("part1 answer: {
```
<Overlap Ratio: 0.9427662957074722>

---

--- 150 --
Question ID: e2bcfc9ebe017c50971403200ef32ade67ce5c25_1
Original Code:
```
fn output_human(json: &str) -> Result<()> {
    let result: CollectionsResult = serde_json::from_str(json).chain_err(|| "JSON parsing failed")?;
    msgln(format!("Found {} collection(s) matching the search parameters:", result.collections.len()));

    let mut tw = TabWriter::new(vec![]);
    for c in result.collections {
        let visibility = if c.public {
            "public"
        } else {
            "private"
        };
        let _ = write!(&mut tw, "* {}:\t'{}'\t[{}]\n", c.id, c.name, visibility);
    }
    tw.flush().unwrap();//.chain_err("|| Failed to create output table");
    let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();
    msgln(written);

    Ok(())
}
```


Overlapping Code:
```
n output_human(json: &str) -> Result<()> {
let result: CollectionsResult = serde_json::from_str(json).chain_err(|| "JSON parsing failed")?;
msgln(format!("Found {} collection(s) matching the search parameters:", result.collections.len()));
let mut tw = TabWriter::new(vec![]);
for c in result.collections {
let visibility = if c.public {
"public"
} else {
"private"
};
let _ = write!(&mut tw, "* {}:\t'{}'\t[{}]\n", c.id, c.name, visibility);
}
tw.flush().unwrap();//.chain_err("|| Failed to create output table");
let written = String::from_utf8(tw.into_inner().unwrap()).unwrap();

```
<Overlap Ratio: 0.9588815789473685>

---

--- 151 --
Question ID: c1efd2a6e176a4d02f2e9319a256d5ffc6a25ec7_1
Original Code:
```
fn shape_for_elementwise_op(sh1: &[usize], sh2: &[usize]) -> Vec<usize> {
    let mut out_sh = vec![0usize; max(sh2.len(), sh1.len())];
    if sh1.len() == sh2.len() {
        for i in 0..sh1.len() {
            out_sh[i] = max(sh1[i], sh2[i]);
        }
    } else if sh1.len() > sh2.len() {
        assert!(false);
    } else if sh2.len() > sh1.len() {
        assert!(false);
    }
    out_sh
}
```


Overlapping Code:
```
mentwise_op(sh1: &[usize], sh2: &[usize]) -> Vec<usize> {
let mut out_sh = vec![0usize; max(sh2.len(), sh1.len())];
if sh1.len() == sh2.len() {
for i in 0..sh1.len() {
out_sh[i] = max(sh1[i], sh2[i]);
}
} else if sh1.len() > sh2.len() {
assert!(false);
} else if sh2.len() > sh1.len() {
assert!(false
```
<Overlap Ratio: 0.9118541033434651>

---

--- 152 --
Question ID: 7f295859d1d471d7215f0134ff7abc90e7dcd288_15
Original Code:
```
fn generalized_time_tests() {
        check_spec(
            &Utc.ymd(1992, 5, 21).and_hms(0, 0, 0),
            "19920521000000Z".to_string(),
        );
        check_spec(
            &Utc.ymd(1992, 6, 22).and_hms(12, 34, 21),
            "19920622123421Z".to_string(),
        );
        check_spec(
            &Utc.ymd(1992, 7, 22).and_hms_milli(13, 21, 00, 300),
            "19920722132100.3Z".to_string(),
        );
    }
```


Overlapping Code:
```
generalized_time_tests() {
check_spec(
&Utc.ymd(1992, 5, 21).and_hms(0, 0, 0),
"19920521000000Z".to_string(),
);
check_spec(
&Utc.ymd(1992, 6, 22).and_hms(12, 34, 21),
"19920622123421Z".to_string(),
);
check_spec(
&Utc.ymd(1992, 7, 22).and_hms_milli(13, 21, 00, 300),
"19920722132100.3Z".to_string(),
```
<Overlap Ratio: 0.974025974025974>

---

--- 153 --
Question ID: 62f0337902ca1df73aa81d261548ac7a673c2c73_0
Original Code:
```
fn init_mod(py: Python, m: &PyModule) -> PyResult<()> {
    m.add_class::<PyQStore>()?;
    m.add_class::<PyQStoreNode>()?;
//    #[pyfn(m, "sum_as_string")]
//    // pyo3 aware function. All of our python interface could be declared in a separate module.
//    // Note that the `#[pyfn()]` annotation automatically converts the arguments from
//    // Python objects to Rust values; and the Rust return value back into a Python object.
//    fn sum_as_string_py(a:i64, b:i64) -> PyResult<String> {
//        let out = sum_as_string(a, b);
//        Ok(out)
//    }

    Ok(())
}
```


Overlapping Code:
```
od(py: Python, m: &PyModule) -> PyResult<()> {
m.add_class::<PyQStore>()?;
m.add_class::<PyQStoreNode>()?;
// #[pyfn(m, "sum_as_string")]
// // pyo3 aware function. All of our python interface could be declared in a separate module.
// // Note that the `#[pyfn()]` annotation automatically converts the arguments from
// // Python objects to Rust values; and the Rust return value back into a Python object.
// fn sum_as_string_py(a:i64, b:i64) -> PyResult<String> {
// let out = sum_as_string(a, b);
// 
```
<Overlap Ratio: 0.9438202247191011>

---

--- 154 --
Question ID: 0420284c693ed7d9ea54f69af006283ff3017923_1
Original Code:
```
fn decode_one() {
    let input = ":foo!bar@baz PRIVMSG #test :this is a test\r\n:local.host PING :1234\r\n";
    let (next, _msg) = super::decode_one(input).unwrap();
    assert!(next > 0);

    // this should be the last message
    let (next, _msg) = super::decode_one(&input[next..]).unwrap();
    assert_eq!(next, 0);

    // try with a bad element at the end
    let input = ":foo!bar@baz PRIVMSG #test :this is a test\r\n:local.host PING :1234\r\nfoo";
    {
        let (next, _msg) = super::decode_one(input).unwrap();
        assert!(next > 0);

        let input = &input[next..];
        let (next, _msg) = super::decode_one(&input).unwrap();
        assert!(next > 0);

        // last one should be an error
        let input = &input[next..];
        super::decode_one(&input).unwrap_err();
    }
}
```


Overlapping Code:
```
ode_one() {
let input = ":foo!bar@baz PRIVMSG #test :this is a test\r\n:local.host PING :1234\r\n";
let (next, _msg) = super::decode_one(input).unwrap();
assert!(next > 0);
// this should be the last message
let (next, _msg) = super::decode_one(&input[next..]).unwrap();
assert_eq!(next, 0);
// try with a bad element at the end
let input = ":foo!bar@baz PRIVMSG #test :this is a test\r\n:local.host PING :1234\r\nfoo";
{
let (next, _msg) = super::decode_one(input).unwrap();
assert!(next > 0);
let input = &input[next..];
let (next, _msg) = super::decode_one(&input).unwrap();
assert!(next > 0);
// last one should be an error
let input = &input[nex
```
<Overlap Ratio: 0.9219858156028369>

---

--- 155 --
Question ID: 9249644d514494de999031f3fc67949e9dc3e447_0
Original Code:
```
fn main() {
    // ANCHOR: here
    let mut s = String::from("hola");

    {
        let r1 = &mut s;
    } // r1 sale del alcance aqui, por lo que podemos hacer una referencia nueva sin problemas.

    let r2 = &mut s;
    // ANCHOR_END: here
}
```


Overlapping Code:
```
fn main() {
// ANCHOR: here
let mut s = String::from("hola");
{
let r1 = &mut s;
} // r1 sale del alcance aqui, por lo que podemos hacer una referencia nueva sin problemas.
let r2 = &mut s;
// ANCHOR_
```
<Overlap Ratio: 0.9478672985781991>

---

--- 156 --
Question ID: c84149e09857d3bda75ba75990ddd96ca9ab52e0_0
Original Code:
```
fn read_vp8_chunk(chunk: &mut RiffChunk) -> Result<VP8Metadata> {
    let r = chunk.contents();

    let mut hdr = [0u8; 3];
    try!(r.read_exact(&mut hdr).map_err(if_eof!(std, "when reading VP8 frame header")));

    let mut result = VP8Metadata {
        version_number: 0,
        show_frame: false,
        first_partition_len: 0,
        frame: VP8Frame::Inter
    };

    // bits of first three bytes:
    //    xxxsvvvf xxxxxxxx xxxxxxxx
    // where
    //    f  --  frame type, 0 is key frame, 1 is interframe
    //    v  --  version number
    //    s  --  show frame flag, 1 is display, 0 is don't display
    //    x  --  size of first data partition in bytes

    let key_frame = hdr[0] & 1 == 0;
    result.version_number = (hdr[0] >> 1) & 7;
    result.show_frame = (hdr[0] >> 4) & 1 == 1;
    result.first_partition_len = ((hdr[0] >> 5) as u32) | 
                                 ((hdr[1] as u32) << 3) | 
                                 ((hdr[2] as u32) << 11);

    if key_frame {
        let mut hdr = [0u8; 7];
        try!(r.read_exact(&mut hdr).map_err(if_eof!(std, "when reading VP8 key frame header")));

        // check magic value
        if &hdr[..3] != &[0x9d, 0x01, 0x2a] {
            return Err(invalid_format!("VP8 key frame magic code is invalid: {:?}", &hdr[..3]));
        }

        // bits of next four bytes:
        //    wwwwwwww xxwwwwww hhhhhhhh yyhhhhhh
        // where
        //    x  --  horizontal scale
        //    w  --  width
        //    y  --  vertical scale
        //    h  --  height

        let width  = ((hdr[4] & 0x3f) as u32) << 8 | hdr[3] as u32;
        let height = ((hdr[6] & 0x3f) as u32) << 8 | hdr[5] as u32;
        let x_scale = hdr[4] >> 6;
        let y_scale = hdr[6] >> 6;

        result.frame = VP8Frame::Key {
            dimensions: (width, height).into(),
            x_scale: x_scale,
            y_scale: y_scale
        };
    }

    Ok(result)
}
```


Overlapping Code:
```
fn read_vp8_chunk(chunk: &mut RiffChunk) -> Result<VP8Metadata> {
let r = chunk.contents();
let mut hdr = [0u8; 3];
try!(r.read_exact(&mut hdr).map_err(if_eof!(std, "when reading VP8 frame header")));
let mut result = VP8Metadata {
version_number: 0,
show_frame: false,
first_partition_len: 0,
frame: VP8Frame::Inter
};
// bits of first three bytes:
// xxxsvvvf xxxxxxxx xxxxxxxx
// where
// f -- frame type, 0 is key frame, 1 is interframe
// v -- version number
// s -- show frame flag, 1 is display, 0 is don't display
// x -- size of first data partition in bytes
let key_frame = hdr[0] & 1 == 0;
result.version_number = (hdr[0] >> 1) & 7;
result.show_frame = (hdr[0] >> 4) & 1 == 1;
result.first_partition_len = ((hdr[0] >> 5) as u32) | 
((hdr[1] as u32) << 3) | 
((hdr[2] as u32) << 11);
if key_frame {
let mut hdr = [0u8; 7];
try!(r.read_exact(&mut hdr).map_err(if_eof!(std, "when reading VP8 key frame header")));
// check magic value
if &hdr[..3] != &[0x9d, 0x01, 0x2a] {
return Err(invalid_format!("VP8 key frame magic code is invalid: {:?}", &hdr[..3]));
}
// bits of next four bytes:
// wwwwwwww xxwwwwww hhhhhhhh yyhhhhhh
// where
// x -- horizontal scale
// w -- width
// y -- vertical scale
// h -- height
let width = ((hdr[4] & 0x3f) as u32) << 8 | hdr[3] as u32;
let height = ((hdr[6] & 0x3f) as u32) << 8 | hdr[5] as u32;
let x_scale = hdr[4] >> 6;
let y_scale = hdr[6] >> 6;
result.frame = VP8Frame::Key {
dimensions: (width, height).into(),
x_scale: x_scale,
y_scale: y_scale
};
}
```
<Overlap Ratio: 0.991407799074686>

---

--- 157 --
Question ID: 8c093c23edd679f86ea412bfd9b822feb1720421_2
Original Code:
```
pub async fn endorsing_rights(
    req: Request<Body>,
    params: Params,
    query: Query,
    env: Arc<RpcServiceEnvironment>,
) -> ServiceResult {
    let chain_id_param = required_param!(params, "chain_id")?;
    let chain_id = parse_chain_id(chain_id_param, &env)?;
    let block_hash =
        parse_block_hash_or_fail!(&chain_id, required_param!(params, "block_id")?, &env);

    let level = query.get_str("level");
    let cycle = query.get_str("cycle");
    let delegate = query.get_str("delegate");
    let has_all = query.contains_key("all");

    // get RPC response and unpack it from RpcResponseData enum
    match services::protocol::check_and_get_endorsing_rights(
        &chain_id,
        &block_hash,
        level,
        delegate,
        cycle,
        has_all,
        &env,
    )
    .await
    {
        Ok(Some(rights)) => result_to_json_response(Ok(Some(rights)), env.log()),
        Ok(None) => {
            let res: Result<Option<String>, RpcServiceError> = Ok(None);
            result_to_json_response(res, env.log())
        }
        Err(RightsError::UnsupportedProtocolError { .. }) => {
            // fallback, if protocol is not supported, we trigger rpc protocol router
            result_to_json_response(
                services::protocol::call_protocol_rpc(
                    chain_id_param,
                    chain_id,
                    block_hash,
                    create_rpc_request(req).await?,
                    &env,
                ),
                env.log(),
            )
        }
        Err(RightsError::ServiceError { reason }) => {
            slog::warn!(env.log(), "Failed to execute RPC function for endorsing rights"; "reason" => format!("{:?}", &reason));
            handle_rpc_service_error(RpcServiceError::UnexpectedError {
                reason: format!("{}", reason),
            })
        }
    }
}
```


Overlapping Code:
```
ub async fn endorsing_rights(
req: Request<Body>,
params: Params,
query: Query,
env: Arc<RpcServiceEnvironment>,
) -> ServiceResult {
let chain_id_param = required_param!(params, "chain_id")?;
let chain_id = parse_chain_id(chain_id_param, &env)?;
let block_hash =
parse_block_hash_or_fail!(&chain_id, required_param!(params, "block_id")?, &env);
let level = query.get_str("level");
let cycle = query.get_str("cycle");
let delegate = query.get_str("delegate");
let has_all = query.contains_key("all");
// get RPC response and unpack it from RpcResponseData enum
match services::protocol::check_and_get_endorsing_rights(
&chain_id,
&block_hash,
level,
delegate,
cycle,
has_all,
&env,
)
.await
{
Ok(Some(rights)) => result_to_json_response(Ok(Some(rights)), env.log()),
Ok(None) => {
let res: Result<Option<String>, RpcServiceError> = Ok(None);
result_to_json_response(res, env.log())
}
Err(RightsError::UnsupportedProtocolError { .. }) => {
// fallback, if protocol is not supported, we trigger rpc protocol router
result_to_json_response(
services::protocol::call_protocol_rpc(
chain_id_param,
chain_id,
block_hash,
create_rpc_request(req).await?,
&env,
),
env.log(),
)
}
Err(RightsError::ServiceError { reason }) => {
slog::warn!(env.log(), "Failed to execute RPC function for endorsing rights"; "reason" => format!("{:?}", &reason));
handle_rpc_service_error(RpcServiceError::UnexpectedError {
reason: format!("{}", 
```
<Overlap Ratio: 0.9874564459930314>

---

--- 158 --
Question ID: f7764a7b910883eaa0ac2a9d732419667b2bb020_3
Original Code:
```
fn grid_grid_bounds() {
        let mut nodes = Vec::new();
        nodes.push(Node {
            latitude: 10.0,
            longitude: 30.0,
            rank: 0,
        });
        nodes.push(Node {
            latitude: 20.0,
            longitude: 30.0,
            rank: 0,
        });
        nodes.push(Node {
            latitude: 10.0,
            longitude: 40.0,
            rank: 0,
        });
        nodes.push(Node {
            latitude: 20.0,
            longitude: 40.0,
            rank: 0,
        });

        let grid_bounds: GridBounds = get_min_max(&nodes);

        assert_eq!(grid_bounds.lat_min, 10.0);
        assert_eq!(grid_bounds.lat_max, 20.0);
        assert_eq!(grid_bounds.lng_min, 30.0);
        assert_eq!(grid_bounds.lng_max, 40.0);
    }
```


Overlapping Code:
```
t mut nodes = Vec::new();
nodes.push(Node {
latitude: 10.0,
longitude: 30.0,
rank: 0,
});
nodes.push(Node {
latitude: 20.0,
longitude: 30.0,
rank: 0,
});
nodes.push(Node {
latitude: 10.0,
longitude: 40.0,
rank: 0,
});
nodes.push(Node {
latitude: 20.0,
longitude: 40.0,
rank: 0,
});
let grid_bounds: GridBounds = get_min_max(&nodes);
assert_eq!(grid_bounds.lat_min, 10.0);
assert_eq!(grid_bounds.lat_max, 20.0);
assert_eq!(grid_bounds.lng_min, 30.0);
assert_eq!(grid_
```
<Overlap Ratio: 0.9031007751937985>

---

--- 159 --
Question ID: 7b0bb9ed158bbb76cfde4efc321f42d88a7bd85e_4
Original Code:
```
fn build_config(env: &Environment) -> Result<app_state::Config, environment::Error> {
    let encryption_key = environment::lookup(env, "ENCRYPTION_KEY")?;
    let server = build_server_config(env)?;
    let cookie = build_cookie_config(env)?;
    let site_key = build_site_key_config(env)?;
    let quota_nano = build_site_quota_limits_nano(env)?;

    Ok(app_state::Config{
        encryption_key,
        server,
        cookie,
        site_key,
        site: site::Config{
            quota_nano,
        }
    })
}
```


Overlapping Code:
```
fn build_config(env: &Environment) -> Result<app_state::Config, environment::Error> {
let encryption_key = environment::lookup(env, "ENCRYPTION_KEY")?;
let server = build_server_config(env)?;
let cookie = build_cookie_config(env)?;
let site_key = build_site_key_config(env)?;
let quota_nano = build_site_quota_limits_nano(env)?;
Ok(app_state::Config{
encryption_key,
server,
cookie,
site_key,
site: s
```
<Overlap Ratio: 0.9280742459396751>

---

--- 160 --
Question ID: 07860db15f5e56d63b2e5be5b6bed234e91a5132_12
Original Code:
```
pub fn draw_tile_and_tokens_at<'a, T>(
    hex: &Hex,
    ctx: &Context,
    map: &Map,
    addr: &HexAddress,
    tile: &Tile,
    radians: f64,
    tokens: T,
) where
    T: IntoIterator<Item = (&'a TokenSpace, &'a Token)>,
{
    let m = map.prepare_to_draw(*addr, hex, ctx);
    // Retrieve the original tile's rotation, which has been applied.
    let orig_rotn =
        map.hex_state(*addr).map(|hs| hs.radians()).unwrap_or(0.0);
    // Apply this additional rotation to the specified tile.
    ctx.rotate(radians);
    // Account for the effective rotation (i.e., the combination of the
    // original tile and the specified tile) so that it can be corrected for
    // by `token.draw()`, below.
    let token_rotn = radians + orig_rotn;
    tile.draw(ctx, hex);
    for (token_space, token) in tokens.into_iter() {
        if tile.define_token_space(token_space, hex, ctx) {
            let tok_name = map.try_token_name(token);
            if let Some(name) = tok_name {
                // NOTE: `token_rotn` is the rotation (in radians) that will
                // be *reversed* when drawing the token.
                token.draw(hex, ctx, name, token_rotn);
            } else {
                debug!("Invalid token for this map: {:?}", token);
            }
        } else {
            debug!("Tile {} has no {:?}", tile.name, token_space);
        }
    }
    ctx.set_matrix(m);
}
```


Overlapping Code:
```
&Hex,
ctx: &Context,
map: &Map,
addr: &HexAddress,
tile: &Tile,
radians: f64,
tokens: T,
) where
T: IntoIterator<Item = (&'a TokenSpace, &'a Token)>,
{
let m = map.prepare_to_draw(*addr, hex, ctx);
// Retrieve the original tile's rotation, which has been applied.
let orig_rotn =
map.hex_state(*addr).map(|hs| hs.radians()).unwrap_or(0.0);
// Apply this additional rotation to the specified tile.
ctx.rotate(radians);
// Account for the effective rotation (i.e., the combination of the
// original tile and the specified tile) so that it can be corrected for
// by `token.draw()`, below.
let token_rotn = radians + orig_rotn;
tile.draw(ctx, hex);
for (token_space, token) in tokens.into_iter() {
if tile.define_token_space(token_space, hex, ctx) {
let tok_name = map.try_token_name(token);
if let Some(name) = tok_name {
// NOTE: `token_rotn` is the rotation (in radians) that will
// be *reversed* when drawing the token.
token.draw(hex, ctx, name, token_rotn);
} else {
debug!("Invalid token for this map: {:?}", token);
}
} else {
debug!("Tile {} has no {:?}", tile.name, token_space);
}
}
ctx.set
```
<Overlap Ratio: 0.9507346585998271>

---

--- 161 --
Question ID: 4a17270a6ca08e799560301be797cdc5deca6f39_3
Original Code:
```
fn parse_script<'a, A: Allocator>(
    tokens: &mut TokenStream,
    allocator: A,
) -> Result<Block<A>, ParseError> {
    // TODO: shebang
    let block = parse_block_open(tokens, allocator)?;
    if tokens.matches(Token::EOF) {
        Ok(block)
    } else {
        Err(PureParseError::Generic(b"Unconsumed tokens!").into())
    }
}
```


Overlapping Code:
```
 A: Allocator>(
tokens: &mut TokenStream,
allocator: A,
) -> Result<Block<A>, ParseError> {
// TODO: shebang
let block = parse_block_open(tokens, allocator)?;
if tokens.matches(Token::EOF) {
Ok(block)
} else {
Err(PureParseError::Generic(b"Unconsumed tok
```
<Overlap Ratio: 0.872852233676976>

---

--- 162 --
Question ID: 636ed3f6c8e51d96ce3f60346b3eed1fd0474a66_4
Original Code:
```
fn different_values() {
        let zero: Result<Enum, _> = 0u8.try_into();
        assert_eq!(zero, Ok(Enum::Zero));

        let one: Result<Enum, _> = 1u8.try_into();
        assert_eq!(one, Ok(Enum::One));

        let two: Result<Enum, _> = 2u8.try_into();
        assert_eq!(two, Ok(Enum::Two));

        let three: Result<Enum, _> = 3u8.try_into();
        assert_eq!(
            three.unwrap_err().to_string(),
            "No discriminant in enum `Enum` matches the value `3`",
        );

        let four: Result<Enum, _> = 4u8.try_into();
        assert_eq!(four, Ok(Enum::Four));

        let five: Result<Enum, _> = 5u8.try_into();
        assert_eq!(five, Ok(Enum::Five));

        let six: Result<Enum, _> = 6u8.try_into();
        assert_eq!(six, Ok(Enum::Six));

        let seven: Result<Enum, _> = 7u8.try_into();
        assert_eq!(seven, Ok(Enum::Seven));
    }
```


Overlapping Code:
```

let zero: Result<Enum, _> = 0u8.try_into();
assert_eq!(zero, Ok(Enum::Zero));
let one: Result<Enum, _> = 1u8.try_into();
assert_eq!(one, Ok(Enum::One));
let two: Result<Enum, _> = 2u8.try_into();
assert_eq!(two, Ok(Enum::Two));
let three: Result<Enum, _> = 3u8.try_into();
assert_eq!(
three.unwrap_err().to_string(),
"No discriminant in enum `Enum` matches the value `3`",
);
let four: Result<Enum, _> = 4u8.try_into();
assert_eq!(four, Ok(Enum::Four));
let five: Result<Enum, _> = 5u8.try_into();
assert_eq!(five, Ok(Enum::Five));
let six: Result<Enum, _> = 6u8.try_into();
assert_eq!(six, Ok(Enum::Six));
let seven: Result<Enum, _> = 7u8.try_into();
assert_eq!(sev
```
<Overlap Ratio: 0.9354838709677419>

---

--- 163 --
Question ID: 7deeef71cc89b58cf4e426c3c9041064e054a51b_3
Original Code:
```
fn fmt_menu(xml: &roxmltree::Document, id: u32) -> String {
    let mut pretty  = String::new();
    let node = xml.get_node(roxmltree::NodeId::from(id)).unwrap();
    let mut descr:Vec<&str> = Vec::new();
    pretty.push_str(node.attribute("title").unwrap());
    pretty.push(':'); 
    for child in node.children(){
      if child.tag_name().name().to_lowercase() == "category" {
        let title = child.attributes()[0].value();
        if title.to_lowercase().contains("sex:"){ 
            //add Gender to the name
          pretty.push_str(title.trim_start_matches("Sex:"));
        }
        else if title.to_lowercase().contains("all"){
            //do nothing
        }
        else {
         descr.push(title);
          }
    }
    }
    for item in descr {
        pretty.push('\t');
        pretty.push_str("     ");
        pretty.push_str(item);
    }
    pretty
}
```


Overlapping Code:
```
roxmltree::Document, id: u32) -> String {
let mut pretty = String::new();
let node = xml.get_node(roxmltree::NodeId::from(id)).unwrap();
let mut descr:Vec<&str> = Vec::new();
pretty.push_str(node.attribute("title").unwrap());
pretty.push(':'); 
for child in node.children(){
if child.tag_name().name().to_lowercase() == "category" {
let title = child.attributes()[0].value();
if title.to_lowercase().contains("sex:"){ 
//add Gender to the name
pretty.push_str(title.trim_start_matches("Sex:"));
}
else if title.to_lowercase().contains("all"){
//do nothing
}
else {
descr.push(title);
}
}
}
for item in descr {
pretty.push('\t');
pretty.push_str(" ");
```
<Overlap Ratio: 0.9259259259259259>

---

--- 164 --
Question ID: dfb84c7df22927b61c9f53a3426a088b29dd1890_0
Original Code:
```
fn id3v2() {
    let meta = mp3_metadata::read_from_file("assets/id3v2.mp3").expect("File error");
    assert_eq!(meta.optional_info[0].position, 0);
    assert_eq!(meta.optional_info[0].major_version, 4);
    assert_eq!(meta.optional_info[0].minor_version, 0);
    assert_eq!(meta.optional_info[0].album_movie_show, Some("éàµ£ø§".to_owned()));
    assert_eq!(meta.optional_info[0].bpm, None);
    assert_eq!(meta.optional_info[0].composers,
               vec!("not Mozart".to_owned(), "not Beethoven".to_owned()));
    assert_eq!(meta.optional_info[0].content_type,
               vec!(mp3_metadata::Genre::InstrumentalPop));
    assert_eq!(meta.optional_info[0].copyright, Some("Is there?".to_owned()));
    assert_eq!(meta.optional_info[0].date, None);
    assert_eq!(meta.optional_info[0].playlist_delay, None);
    assert_eq!(meta.optional_info[0].encoded_by, Some("some website...".to_owned()));
    assert_eq!(meta.optional_info[0].text_writers.len(), 0);
    assert_eq!(meta.optional_info[0].file_type, None);
    assert_eq!(meta.optional_info[0].time, None);
    assert_eq!(meta.optional_info[0].content_group_description, None);
    assert_eq!(meta.optional_info[0].subtitle_refinement_description, None);
    assert_eq!(meta.optional_info[0].title,
               Some("This is a wonderful title isn't it?".to_owned()));
    assert_eq!(meta.optional_info[0].performers,
               vec!("Someone".to_owned(), "Someone else".to_owned()));
    assert_eq!(meta.optional_info[0].band,
               Some("I like artists! But who to choose? So many of them...".to_owned()));
    assert_eq!(meta.optional_info[0].track_number, Some("01".to_owned()));

    assert_eq!(meta.tag, Some(mp3_metadata::AudioTag {
        title: "This is a wonderful title isn'".to_owned(),
        artist: "Someone/Someone else          ".to_owned(),
        album: "".to_owned(),
        year: 2015,
        comment: "Some random comment because ".to_owned(),
        genre: mp3_metadata::Genre::Other,
    }));
}
```


Overlapping Code:
```
file("assets/id3v2.mp3").expect("File error");
assert_eq!(meta.optional_info[0].position, 0);
assert_eq!(meta.optional_info[0].major_version, 4);
assert_eq!(meta.optional_info[0].minor_version, 0);
assert_eq!(meta.optional_info[0].album_movie_show, Some("éàµ£ø§".to_owned()));
assert_eq!(meta.optional_info[0].bpm, None);
assert_eq!(meta.optional_info[0].composers,
vec!("not Mozart".to_owned(), "not Beethoven".to_owned()));
assert_eq!(meta.optional_info[0].content_type,
vec!(mp3_metadata::Genre::InstrumentalPop));
assert_eq!(meta.optional_info[0].copyright, Some("Is there?".to_owned()));
assert_eq!(meta.optional_info[0].date, None);
assert_eq!(meta.optional_info[0].playlist_delay, None);
assert_eq!(meta.optional_info[0].encoded_by, Some("some website...".to_owned()));
assert_eq!(meta.optional_info[0].text_writers.len(), 0);
assert_eq!(meta.optional_info[0].file_type, None);
assert_eq!(meta.optional_info[0].time, None);
assert_eq!(meta.optional_info[0].content_group_description, None);
assert_eq!(meta.optional_info[0].subtitle_refinement_description, None);
assert_eq!(meta.optional_info[0].title,
Some("This is a wonderful title isn't it?".to_owned()));
assert_eq!(meta.optional_info[0].performers,
vec!("Someone".to_owned(), "Someone else".to_owned()));
assert_eq!(meta.optional_info[0].band,
Some("I like artists! But who to choose? So many of them...".to_owned()));
assert_eq!(meta.optional_info[0].track_number, Some("01".to_owned()));
assert_eq!(meta.tag, Some(mp3_metadata::AudioTag {
title: "This is a wonderful title isn'".to_owned(),
artist: "Someone/Someone else ".to_owned(),
album: "".to_owned(),
year: 2015,
comment: "Some random comment because ".to_owned(),
genre: mp3_me
```
<Overlap Ratio: 0.9572072072072072>

---

--- 165 --
Question ID: 68fe9419da1524be6091cd178d665446e7ff9910_0
Original Code:
```
fn escape_html() {
    assert_eq!(voca_rs::escape::escape_html(""), "");
    assert_eq!(
        voca_rs::escape::escape_html("<>&\"'`"),
        "&lt;&gt;&amp;&quot;&#x27;&#x60;"
    );
    assert_eq!(
        voca_rs::escape::escape_html(voca_rs::utils::PUNCTUATION),
        "!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\]^_&#x60;{|}~"
    );
    assert_eq!(
        voca_rs::escape::escape_html("<p>wonderful world</p>"),
        "&lt;p&gt;wonderful world&lt;/p&gt;"
    );
    assert_eq!(voca_rs::escape::escape_html("<span>"), "&lt;span&gt;");
    assert_eq!(
        voca_rs::escape::escape_html("<p>wonderful<span>world<span/></p>"),
        "&lt;p&gt;wonderful&lt;span&gt;world&lt;span/&gt;&lt;/p&gt;"
    );
}
```


Overlapping Code:
```
() {
assert_eq!(voca_rs::escape::escape_html(""), "");
assert_eq!(
voca_rs::escape::escape_html("<>&\"'`"),
"&lt;&gt;&amp;&quot;&#x27;&#x60;"
);
assert_eq!(
voca_rs::escape::escape_html(voca_rs::utils::PUNCTUATION),
"!&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\\]^_&#x60;{|}~"
);
assert_eq!(
voca_rs::escape::escape_html("<p>wonderful world</p>"),
"&lt;p&gt;wonderful world&lt;/p&gt;"
);
assert_eq!(voca_rs::escape::escape_html("<span>"), "&lt;span&gt;");
assert_eq!(
voca_rs::escape::escape_html("<p>wonderful<span>world<span/></p>"),
"&lt;p&gt;wonderful&lt;span&gt;world&lt;span/
```
<Overlap Ratio: 0.9447154471544715>

---

--- 166 --
Question ID: 98b78798b06d517e7d04aeb527fd40be71817175_0
Original Code:
```
fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    let ret;
    unsafe {
        llvm_asm!("ecall"
            : "={x10}" (ret)
            : "{x10}" (arg0), "{x11}" (arg1), "{x12}" (arg2), "{x17}" (which)
            : "memory"
            : "volatile");
    }
    ret
}
```


Overlapping Code:
```
all(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
let ret;
unsafe {
llvm_asm!("ecall"
: "={x10}" (ret)
: "{x10}" (arg0), "{x11}" (arg1), "{x12}" (arg2), "{x17}" (which)
: "memory"
: "volatile")
```
<Overlap Ratio: 0.9254385964912281>

---

--- 167 --
Question ID: bd9c0e4350219e9f6799c1fb4668f1ef90536ff9_0
Original Code:
```
fn test_sha256() {
        let input = b"";
        let expected =
            hex::decode("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
                .unwrap();

        let res = SHA256::run(input, 60, &new_context()).unwrap().1;
        assert_eq!(res, expected);
    }
```


Overlapping Code:
```
 test_sha256() {
let input = b"";
let expected =
hex::decode("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
.unwrap();
let res = SHA256::run(input, 60, &new_context()).unwrap().1;
```
<Overlap Ratio: 0.8658008658008658>

---

--- 168 --
Question ID: 9128872d4c1280936f110d8ef9d339fad5aa240e_1
Original Code:
```
fn parse_object_name() -> Result<(), ParserError> {
        let dialect = crate::ansi::AnsiDialect::default();
        let name = Parser::new_with_sql(&dialect, "foo.bar")?.parse_object_name()?;
        assert_eq!(name, ObjectName(vec![Ident::new("foo"), Ident::new("bar")]));
        Ok(())
    }
```


Overlapping Code:
```
e() -> Result<(), ParserError> {
let dialect = crate::ansi::AnsiDialect::default();
let name = Parser::new_with_sql(&dialect, "foo.bar")?.parse_object_name()?;
assert_eq!(name, ObjectName(vec![Ident::new("foo"), Ident::new("
```
<Overlap Ratio: 0.8582375478927203>

---

--- 169 --
Question ID: 7f31ef83455df4262a10bf3f3f0987f417506575_0
Original Code:
```
fn never() {
    let mut never = Never::new();
    let _subscription = never.subscribe_error(
        |_x: u8| panic!("never observable should not produce a value"),
        || panic!("never observable should not complete"),
        |_err: ()| panic!("never observable should not fail")
    );

    // Without something like a message loop, the observable cannot suddenly
    // start pushing values, so if it did not produce anything here, it never
    // will.
}
```


Overlapping Code:
```
 = Never::new();
let _subscription = never.subscribe_error(
|_x: u8| panic!("never observable should not produce a value"),
|| panic!("never observable should not complete"),
|_err: ()| panic!("never observable should not fail")
);
// Without something like a message loop, the observable cannot suddenly
// start pushing values, so if it did not pro
```
<Overlap Ratio: 0.8433734939759037>

---

--- 170 --
Question ID: 4d23d4dedb3898a9aba7aaddc082db0d4af63142_1
Original Code:
```
fn validate_endpoint(
    endpoint: &ConnectionEndpoint,
    strict: bool,
) -> Result<(IpAddr, u16), InvariantCheckError> {
    if endpoint.protocol() != Protocol::Http1
        && endpoint.protocol() != Protocol::Http1Tls13
        && endpoint.protocol() != Protocol::P2p1Tls13
    {
        return Err(InvariantCheckError {
            msg: format!(
                "Endpoint protocol is not supported: {:?}",
                endpoint.protocol
            ),
            source: None,
        });
    }

    let ip: IpAddr = endpoint
        .ip_addr
        .parse::<IpAddr>()
        .map_err(|e| InvariantCheckError {
            msg: format!("Failed to parse IP address: {:?}", endpoint.ip_addr),
            source: Some(Box::new(e)),
        })?;

    let port = u16::try_from(endpoint.port).map_err(|e| InvariantCheckError {
        msg: format!("Failed to parse port: {:?}", endpoint.port),
        source: Some(Box::new(e)),
    })?;

    if ip.is_unspecified() {
        return Err(InvariantCheckError {
            msg: format!("IP Address {:?} is unspecified", ip),
            source: None,
        });
    }

    if let IpAddr::V4(ipv4) = ip {
        if ipv4.is_broadcast() {
            return Err(InvariantCheckError {
                msg: format!("IP Address {:?} is a broadcast address", ip),
                source: None,
            });
        }

        if ipv4.is_multicast() {
            return Err(InvariantCheckError {
                msg: format!("IP Address {:?} is a multicast address", ip),
                source: None,
            });
        }
    } else if let IpAddr::V6(ipv6) = ip {
        let multicast_addr_and_mask = Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0);
        if mask_ipv6(ipv6, multicast_addr_and_mask) == multicast_addr_and_mask {
            return Err(InvariantCheckError {
                msg: format!("IP Address {:?} is a multicast address", ip),
                source: None,
            });
        }
    }

    if strict {
        if ip.is_loopback() {
            return Err(InvariantCheckError {
                msg: format!("IP Address {:?} is the loopback address", ip),
                source: None,
            });
        }

        if let IpAddr::V4(ipv4) = ip {
            if ipv4.is_private() {
                return Err(InvariantCheckError {
                    msg: format!("IP Address {:?} is a private address", ip),
                    source: None,
                });
            }
            if ipv4.is_link_local() {
                return Err(InvariantCheckError {
                    msg: format!("IP Address {:?} is a link local address", ip),
                    source: None,
                });
            }
            for (addr, mask, res_type) in &IPV4_STRICT_CHECKS {
                if mask_ipv4(ipv4, *mask) == *addr {
                    return Err(InvariantCheckError {
                        msg: format!("IP Address {:?} is not allowed ({})", ip, res_type),
                        source: None,
                    });
                }
            }
        } else if let IpAddr::V6(ipv6) = ip {
            for (addr, mask, res_type) in &IPV6_STRICT_CHECKS {
                if mask_ipv6(ipv6, *mask) == *addr {
                    return Err(InvariantCheckError {
                        msg: format!("IP Address {:?} is not allowed ({})", ip, res_type),
                        source: None,
                    });
                }
            }
        }
    }

    Ok((ip, port))
}
```


Overlapping Code:
```
nnectionEndpoint,
strict: bool,
) -> Result<(IpAddr, u16), InvariantCheckError> {
if endpoint.protocol() != Protocol::Http1
&& endpoint.protocol() != Protocol::Http1Tls13
&& endpoint.protocol() != Protocol::P2p1Tls13
{
return Err(InvariantCheckError {
msg: format!(
"Endpoint protocol is not supported: {:?}",
endpoint.protocol
),
source: None,
});
}
let ip: IpAddr = endpoint
.ip_addr
.parse::<IpAddr>()
.map_err(|e| InvariantCheckError {
msg: format!("Failed to parse IP address: {:?}", endpoint.ip_addr),
source: Some(Box::new(e)),
})?;
let port = u16::try_from(endpoint.port).map_err(|e| InvariantCheckError {
msg: format!("Failed to parse port: {:?}", endpoint.port),
source: Some(Box::new(e)),
})?;
if ip.is_unspecified() {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is unspecified", ip),
source: None,
});
}
if let IpAddr::V4(ipv4) = ip {
if ipv4.is_broadcast() {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is a broadcast address", ip),
source: None,
});
}
if ipv4.is_multicast() {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is a multicast address", ip),
source: None,
});
}
} else if let IpAddr::V6(ipv6) = ip {
let multicast_addr_and_mask = Ipv6Addr::new(0xff00, 0, 0, 0, 0, 0, 0, 0);
if mask_ipv6(ipv6, multicast_addr_and_mask) == multicast_addr_and_mask {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is a multicast address", ip),
source: None,
});
}
}
if strict {
if ip.is_loopback() {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is the loopback address", ip),
source: None,
});
}
if let IpAddr::V4(ipv4) = ip {
if ipv4.is_private() {
return Err(InvariantCheckError {
msg: format!("IP Address {:?} is a private address", ip),
source: None,
});
}
if ipv4.
```
<Overlap Ratio: 0.9729580573951435>

---

--- 171 --
Question ID: 66f4adf594e0743d9ab9ff27d4c5bf767504cf99_1
Original Code:
```
fn test_complex_log() {
        let s1 = Complex::new(f64x2::new(1.5, 0.0), f64x2::new(10.0, 0.0));
        let gt = Complex::new(
            f64x2::new(2.3137103974614557, -1.1772777930167866e-16),
            f64x2::new(1.4219063791853994, -4.7442629531916207e-17),
        );
        assert_complex_close(s1.ln(), gt, 1e-30);
    }
```


Overlapping Code:
```
test_complex_log() {
let s1 = Complex::new(f64x2::new(1.5, 0.0), f64x2::new(10.0, 0.0));
let gt = Complex::new(
f64x2::new(2.3137103974614557, -1.1772777930167866e-16),
f64x2::new(1.4219063791853994, -4.7442629531916207e-17),
);
assert_complex_close(
```
<Overlap Ratio: 0.9090909090909091>

---

--- 172 --
Question ID: eeeb98e665da8cb818d373ba14cf1c265bab8cc9_5
Original Code:
```
fn NewDirectory(task: &Task, msrc: &Arc<QMutex<MountSource>>) -> Inode {
    let iops = Dir::New(task, BTreeMap::new(), &ROOT_OWNER, &FilePermissions::FromMode(FileMode(0o0555)));

    let deviceId = PROC_DEVICE.lock().id.DeviceID();
    let inodeId = PROC_DEVICE.lock().NextIno();

    let stableAttr = StableAttr {
        Type: InodeType::Directory,
        DeviceId: deviceId,
        InodeId: inodeId,
        BlockSize: MemoryDef::PAGE_SIZE as i64,
        DeviceFileMajor: 0,
        DeviceFileMinor: 0,
    };

    let inodeInternal = InodeIntern {
        InodeOp: Arc::new(iops),
        StableAttr: stableAttr,
        LockCtx: LockCtx::default(),
        MountSource: msrc.clone(),
        Overlay: None,
        ..Default::default()
    };

    return Inode(Arc::new(QMutex::new(inodeInternal)))
}
```


Overlapping Code:
```
irectory(task: &Task, msrc: &Arc<QMutex<MountSource>>) -> Inode {
let iops = Dir::New(task, BTreeMap::new(), &ROOT_OWNER, &FilePermissions::FromMode(FileMode(0o0555)));
let deviceId = PROC_DEVICE.lock().id.DeviceID();
let inodeId = PROC_DEVICE.lock().NextIno();
let stableAttr = StableAttr {
Type: InodeType::Directory,
DeviceId: deviceId,
InodeId: inodeId,
BlockSize: MemoryDef::PAGE_SIZE as i64,
DeviceFileMajor: 0,
DeviceFileMinor: 0,
};
let inodeInternal = InodeIntern {
InodeOp: Arc::new(iops),
StableAttr: stableAttr,
LockCtx: LockCtx::default(),
MountSource: msrc.clone(),
Overlay: None,
..Default::default()
};
return Inode(Arc::new(QMutex::new(inodeInternal)))
}
```
<Overlap Ratio: 0.9896755162241888>

---

--- 173 --
Question ID: d6d4374dfb1e4e0d8327fa35114f450e9b1e0bb2_1
Original Code:
```
fn extract_first_name_owned<'a>(
    entity: StrEntity,
    expected_last_name: impl Into<BooStr<'a>>,
) -> Str {
    assert_eq!(entity.last_name.deref(), expected_last_name.into().deref());
    // Convert a Boo (BooStr in this case) into owned (`NewStr` is the implementation used to
    // convert "&str" to "Str" if `first_name` is borrowed).
    entity.first_name.into_owned_with::<NewStr>()
}
```


Overlapping Code:
```
first_name_owned<'a>(
entity: StrEntity,
expected_last_name: impl Into<BooStr<'a>>,
) -> Str {
assert_eq!(entity.last_name.deref(), expected_last_name.into().deref());
// Convert a Boo (BooStr in this case) into owned (`NewStr` is the implementation used to
// convert "&str" to "Str" if `first_name` is borrowed).
entity.first_name.into_owned_with::
```
<Overlap Ratio: 0.938337801608579>

---

--- 174 --
Question ID: 817780f800b9c164339cc9b59c20b35eb047b77d_16
Original Code:
```
fn with_less_arguments() {
            let (output, _) = execute();
            let stderr = output.stderr.str();

            assert_in!(
                stderr,
                "
                  |
                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]
                  |                     ^^
                "
                .unindent()
            );

            assert_in!(
                stderr,
                "
                  |
                4 | #[rstest(a, b, case(42), case(1, 2), case(43))]
                  |                                           ^^
                "
                .unindent()
            );
        }
```


Overlapping Code:
```
utput, _) = execute();
let stderr = output.stderr.str();
assert_in!(
stderr,
"
|
4 | #[rstest(a, b, case(42), case(1, 2), case(43))]
| ^^
"
.unindent()
);
assert_in!(
stderr,
"
|
4 | #[rstest(a, b, case(42), 
```
<Overlap Ratio: 0.7247386759581882>

---

--- 175 --
Question ID: 1262a6640cc8f605bd84f0df1f64eca2df723402_0
Original Code:
```
fn contract_map() -> ContractMap<TxContext> {
	let mut contract_map = ContractMap::new();
	contract_map.register_contract(
		"file:../output/adder.wasm",
		Box::new(|context| Box::new(AdderImpl::new(context))),
	);
	contract_map
}
```


Overlapping Code:
```
 contract_map() -> ContractMap<TxContext> {
let mut contract_map = ContractMap::new();
contract_map.register_contract(
"file:../output/adder.wasm",
Box::new(|context| Box::new(AdderImpl::new(context))),
)
```
<Overlap Ratio: 0.918918918918919>

---

--- 176 --
Question ID: 3a92454c466f60efe00cd40ce6e865efd262048e_1
Original Code:
```
fn try_insert(&self, db: &Database) -> Result<String, Box<dyn Error>> where Self: Serialize {
        let coll = (*db).collection(Self::collection_name());
        let new_doc = self.as_document();
        coll.insert_one(new_doc, None)?;
        return Ok(String::from(self.primary_key()));
    }
```


Overlapping Code:
```
sert(&self, db: &Database) -> Result<String, Box<dyn Error>> where Self: Serialize {
let coll = (*db).collection(Self::collection_name());
let new_doc = self.as_document();
coll.insert_one(new_doc, None)?
```
<Overlap Ratio: 0.7816091954022989>

---

--- 177 --
Question ID: 4809de7cfd3f4e35906d20f2904d9bfa89006d43_0
Original Code:
```
pub fn repeated_n_times(a: Vec<i32>) -> i32 {
    let mut set = HashSet::new();
    for i in a {
        if !set.insert(i) {
            return i;
        }
    }
    0
}
```


Overlapping Code:
```
pub fn repeated_n_times(a: Vec<i32>) -> i32 {
let mut set = HashSet::new();
for i in a {
if !set.insert(i) {
return i;

```
<Overlap Ratio: 0.9444444444444444>

---

--- 178 --
Question ID: 2b26791328df611b04961851144db368422b2df3_4
Original Code:
```
fn dangling_pointer() -> *const i32 {
    let b = Box::new((42, 42)); // make it bigger than the alignment, so that there is some "room" after this pointer
    &b.0 as *const i32
}
```


Overlapping Code:
```
ngling_pointer() -> *const i32 {
let b = Box::new((42, 42)); // make it bigger than the alignment, so that there is some "room" after this pointer
&b.
```
<Overlap Ratio: 0.872093023255814>

---

--- 179 --
Question ID: 1dc16dd0389b1d1542151b952581da3beaef42d5_1
Original Code:
```
fn fdcan1_tx_isr() {
    let fdcan = &sync::acquire_hw(&SHARED_DEVICE).fdcan;
    let get_idx = fdcan.txefs.read().efgi().bits();
    // Safety: Upstream: not restricted to enum or range in stm32-rs. But since we're using the
    // value retrieved from the get index it's fine.
    fdcan.txefa.modify(|_, w| unsafe { w.efai().bits(get_idx) });

    // TODO(blakely): Actually check for Tx errors
    // Ack the Tx interrupts
    fdcan.ir.modify(|_, w| w.tfe().set_bit().tefn().set_bit());
}
```


Overlapping Code:
```
() {
let fdcan = &sync::acquire_hw(&SHARED_DEVICE).fdcan;
let get_idx = fdcan.txefs.read().efgi().bits();
// Safety: Upstream: not restricted to enum or range in stm32-rs. But since we're using the
// value retrieved from the get index it's fine.
fdcan.txefa.modify(|_, w| unsafe { w.efai().bits(get_idx) });
// TODO(blakely): Actually check for Tx errors
// Ack the Tx interrupts
fdcan.ir.modify(|_,
```
<Overlap Ratio: 0.8733624454148472>

---

--- 180 --
Question ID: 810afef4f529224fac1df2091573646701493152_0
Original Code:
```
pub fn replace_slashes<P: AsRef<Path>>(path: P) -> PathBuf {
    #[cfg(target_os = "windows")]
    {
        if path.as_ref().is_absolute() {
            // Absolute Windows paths are incompatible with other operating systems so
            // don't bother here and return existing path as owned.
            path.as_ref().to_owned()
        } else {
            // Replace all \ to /. This is needed because on macos or linux \ is a valid symbol in
            // file name, and not separator (except linux which understand both variants).
            let mut os_str = std::ffi::OsString::new();
            let count = path.as_ref().components().count();
            for (i, component) in path.as_ref().components().enumerate() {
                os_str.push(component.as_os_str());
                if i != count - 1 {
                    os_str.push("/");
                }
            }
            PathBuf::from(os_str)
        }
    }

    #[cfg(not(target_os = "windows"))]
    {
        path.as_ref().to_owned()
    }
}
```


Overlapping Code:
```
<P: AsRef<Path>>(path: P) -> PathBuf {
#[cfg(target_os = "windows")]
{
if path.as_ref().is_absolute() {
// Absolute Windows paths are incompatible with other operating systems so
// don't bother here and return existing path as owned.
path.as_ref().to_owned()
} else {
// Replace all \ to /. This is needed because on macos or linux \ is a valid symbol in
// file name, and not separator (except linux which understand both variants).
let mut os_str = std::ffi::OsString::new();
let count = path.as_ref().components().count();
for (i, component) in path.as_ref().components().enumerate() {
os_str.push(component.as_os_str());
if i != count - 1 {
os_str.push("/");
}
}
PathBuf::from(os_str)
}
}
#[cfg(not(target_os = "windows"))]
{
path.as_ref().to_ow
```
<Overlap Ratio: 0.9603072983354674>

---

--- 181 --
Question ID: 1c2e8260d9172082429920ff429bbeba4a4d24d3_0
Original Code:
```
fn test_erc1155_deploy() {
    let t = Token::deployed();
    assert_eq!(t.name(), token_cfg::NAME);
    assert_eq!(t.symbol(), token_cfg::SYMBOL);

 
    
}
```


Overlapping Code:
```
155_deploy() {
let t = Token::deployed();
assert_eq!(t.name(), token_cfg::NAME);
assert_eq!(t.symbol(), tok
```
<Overlap Ratio: 0.7697841726618705>

---

--- 182 --
Question ID: 4e967138d8e6d96ef46aeea0f9f8bacf30bc9ac5_2
Original Code:
```
fn test_vector3_rotate_y() {
        let a = Vec3(3.0, 0.5, 0.5);

        let rotated = a.rotate_y(90.0);
        assert_approx_eq!(rotated.0, 0.5, ASSERT_MARGIN);
        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);
        assert_approx_eq!(rotated.2, -3.0, ASSERT_MARGIN);

        let rotated = a.rotate_y(-90.0);
        assert_approx_eq!(rotated.0, -0.5, ASSERT_MARGIN);
        assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);
        assert_approx_eq!(rotated.2, 3.0, ASSERT_MARGIN);
    }
```


Overlapping Code:
```
3.0, 0.5, 0.5);
let rotated = a.rotate_y(90.0);
assert_approx_eq!(rotated.0, 0.5, ASSERT_MARGIN);
assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);
assert_approx_eq!(rotated.2, -3.0, ASSERT_MARGIN);
let rotated = a.rotate_y(-90.0);
assert_approx_eq!(rotated.0, -0.5, ASSERT_MARGIN);
assert_approx_eq!(rotated.1, 0.5, ASSERT_MARGIN);
assert_approx_eq!
```
<Overlap Ratio: 0.8215962441314554>

---

--- 183 --
Question ID: ec16a4034ffdcd26392de50e60e497bab5c9d470_18
Original Code:
```
fn unrecognized_message() {
            let buffer = [];
            let mut decoder = MessageDecoder::default();

            decoder.next_stage(None).expect("proceed to the next stage");
            decoder.next_stage(Some(&[b'A'])).expect("proceed to the next stage");
            decoder
                .next_stage(Some(&LEN.to_be_bytes()))
                .expect("proceed to the next stage");

            assert_eq!(
                decoder.next_stage(Some(&buffer)),
                Err(MessageFormatError::from(
                    MessageFormatErrorKind::UnsupportedFrontendMessage('A')
                ))
            );
        }
```


Overlapping Code:
```
buffer = [];
let mut decoder = MessageDecoder::default();
decoder.next_stage(None).expect("proceed to the next stage");
decoder.next_stage(Some(&[b'A'])).expect("proceed to the next stage");
decoder
.next_stage(Some(&LEN.to_be_bytes()))
.expect("proceed to the next stage");
assert_eq!(
decoder.next_stage(Some(&buffer)),
Err(MessageFormatError::from(
MessageFormatErrorKind::UnsupportedFrontendMessage('A
```
<Overlap Ratio: 0.9060402684563759>

---

--- 184 --
Question ID: 2200788ed2620f6d693f556bc2b57826240231eb_5
Original Code:
```
fn add_and_focus_webview<T, B>(window_index: u32, uri: Option<T>, buffer_config: Option<B>)
    where B: BrowserConfiguration,
          T: Into<String> {
    let store = _WKUserContentExtensionStore::default_store();
    let ref config = super::UI.engine.config;
    let uri = uri.map(|u| u.into()).unwrap_or(String::new());
    let mut private_browsing = config.use_private_browsing(&uri);
    let mut use_plugins = config.use_plugins(&uri);
    let mut skip_content_filter = config.skip_content_filter(&uri);
    let mut use_js = config.use_javascript(&uri);
    if let Some(buffer_config) = buffer_config {
        private_browsing = buffer_config.use_private_browsing(&uri);
        use_plugins = buffer_config.use_plugins(&uri);
        skip_content_filter = buffer_config.skip_content_filter(&uri);
        use_js = buffer_config.use_javascript(&uri);
    }
    let block = ConcreteBlock::new(move |filter: Id, err: Id| {
        if let Some(window) = window_for_index(window_index) {
            let container = subview(&window, WindowArea::WebView);
            let subviews = container.subviews().unwrap();
            for index in 0 .. subviews.count() {
                if let Some(view) = subviews.get::<NSView>(index) {
                    view.set_hidden(true);
                }
            }
            let config = WKWebViewConfiguration::new().autorelease();
            if private_browsing {
                info!("blocking data storage in buffer");
                config.set_website_data_store(WKWebsiteDataStore::nonpersistent_store());
            }
            info!("setting plugins option to {}", use_plugins);
            config.preferences().set_plugins_enabled(use_plugins);
            info!("setting js option to {}", use_js);
            config.preferences().set_javascript_enabled(use_js);
            if let Some(filter) = _WKUserContentFilter::from_ptr(filter) {
                config.user_content_controller().add_user_content_filter(filter);
            } else if err != nil {
                log_error_description(err);
            }
            let webview = WKWebView::new(CGRect::zero(), config).autorelease();
            webview.set_navigation_delegate(WebViewHistoryDelegate::new());
            webview.set_custom_user_agent(&default_user_agent());
            let webview_view = webview.coerce::<NSView>().unwrap();
            webview_view.disable_translates_autoresizing_mask_into_constraints();
            container.add_subview(&webview_view);
            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Top, &container, NSLayoutAttribute::Top));
            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Bottom, &container, NSLayoutAttribute::Bottom));
            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Left, &container, NSLayoutAttribute::Left));
            container.add_constraint(NSLayoutConstraint::bind(&webview_view, NSLayoutAttribute::Right, &container, NSLayoutAttribute::Right));
            if !uri.is_empty() {
                webview.load_request(super::create_request(&uri));
            }
        }
    });
    if skip_content_filter {
        let block = block.copy();
        unsafe { block.call((nil, nil)); }
    } else {
        store.lookup_content_extension("filter", &block.copy());
    }
}
```


Overlapping Code:
```
dow_index: u32, uri: Option<T>, buffer_config: Option<B>)
where B: BrowserConfiguration,
T: Into<String> {
let store = _WKUserContentExtensionStore::default_store();
let ref config = super::UI.engine.config;
let uri = uri.map(|u| u.into()).unwrap_or(String::new());
let mut private_browsing = config.use_private_browsing(&uri);
let mut use_plugins = config.use_plugins(&uri);
let mut skip_content_filter = config.skip_content_filter(&uri);
let mut use_js = config.use_javascript(&uri);
if let Some(buffer_config) = buffer_config {
private_browsing = buffer_config.use_private_browsing(&uri);
use_plugins = buffer_config.use_plugins(&uri);
skip_content_filter = buffer_config.skip_content_filter(&uri);
use_js = buffer_config.use_javascript(&uri);
}
let block = ConcreteBlock::new(move |filter: Id, err: Id| {
if let Some(window) = window_for_index(window_index) {
let container = subview(&window, WindowArea::WebView);
let subviews = container.subviews().unwrap();
for index in 0 .. subviews.count() {
if let Some(view) = subviews.get::<NSView>(index) {
view.set_hidden(true);
}
}
let config = WKWebViewConfiguration::new().autorelease();
if private_browsing {
info!("blocking data storage in buffer");
config.set_website_data_store(WKWebsiteDataStore::nonpersistent_store());
}
info!("setting plugins option to {}", use_plugins);
config.preferences().set_plugins_enabled(use_plugins);
info!("setting js option to {}", use_js);
config.preferences().set_javascript_enabled(use_js);
if let Some(filter) = _WKUserContentFilter::from_ptr(filter) {
config.user_content_controller().add_user_content_filter(filter);
} else if err != nil {
log_error_description(err);
}
let webview = WKWebView::new(CGRect::zero(), config).autorelease();
webview.set_navigation_delegate(WebViewHistoryDelegate::new());
webview.set_custom_user_agent(&default_user_agent());
let webview_view = webview.coerce::<NSView>().unwrap();
webview_view.disable_translates_autoresizing_mask_into_constraints();
container.add_subview(&we
```
<Overlap Ratio: 0.9775171065493646>

---

--- 185 --
Question ID: 0ad7f8a2323bb4a25eb0e8fbfaffa23a29e7588b_0
Original Code:
```
fn rrule_and_exrule() {
    let mut set = RRuleSet::default();

    let properties1 = RRuleProperties {
        freq: Frequency::Yearly,
        count: Some(6),
        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),
        by_weekday: vec![NWeekday::Every(Weekday::Tue), NWeekday::Every(Weekday::Thu)],
        by_hour: vec![9],
        by_minute: vec![0],
        by_second: vec![0],
        ..Default::default()
    };
    let rrule = RRule::new(properties1).unwrap();
    set.rrule(rrule);
    let properties2 = RRuleProperties {
        freq: Frequency::Yearly,
        count: Some(3),
        dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),
        by_weekday: vec![NWeekday::Every(Weekday::Thu)],
        by_hour: vec![9],
        by_minute: vec![0],
        by_second: vec![0],
        ..Default::default()
    };
    let exrule = RRule::new(properties2).unwrap();
    set.exrule(exrule);

    test_recurring_rrule_set(
        set,
        &[
            ymd_hms(1997, 9, 2, 9, 0, 0),
            ymd_hms(1997, 9, 9, 9, 0, 0),
            ymd_hms(1997, 9, 16, 9, 0, 0),
        ],
    );
}
```


Overlapping Code:
```
{
let mut set = RRuleSet::default();
let properties1 = RRuleProperties {
freq: Frequency::Yearly,
count: Some(6),
dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),
by_weekday: vec![NWeekday::Every(Weekday::Tue), NWeekday::Every(Weekday::Thu)],
by_hour: vec![9],
by_minute: vec![0],
by_second: vec![0],
..Default::default()
};
let rrule = RRule::new(properties1).unwrap();
set.rrule(rrule);
let properties2 = RRuleProperties {
freq: Frequency::Yearly,
count: Some(3),
dt_start: UTC.ymd(1997, 9, 2).and_hms(9, 0, 0),
by_weekday: vec![NWeekday::Every(Weekday::Thu)],
by_hour: vec![9],
by_minute: vec![0],
by_second: vec![0],
..Default::default()
};
let exrule = RRule::new(properties2).unwrap();
set.exrule(exrule);
test_recurring_rrule_set(
set,
&[
ymd_hms(1997, 9, 2, 9, 0, 0),
ymd_hms(1997, 9, 9, 9, 0, 0),
ymd_hms(1997, 9, 16, 9, 0, 0),
],
);
}
```
<Overlap Ratio: 0.9745664739884393>

---

--- 186 --
Question ID: 5a0f3405fa55b1352b084e2eb9f6b11d7be30d7b_4
Original Code:
```
fn remove_should_remove_empty_value_nested_in_table() {
        let mut inner = toml::value::Table::new();
        inner.insert(
            String::from("key"),
            toml::Value::Table(toml::value::Table::new()),
        );

        let mut outer = toml::value::Table::new();
        outer.insert(String::from("inner"), toml::Value::Table(inner));

        let mut value = toml::Value::Table(outer);
        remove(&mut value);

        let empty_table = toml::Value::Table(toml::value::Table::new());
        assert_eq!(value, empty_table);
    }
```


Overlapping Code:
```
ed_in_table() {
let mut inner = toml::value::Table::new();
inner.insert(
String::from("key"),
toml::Value::Table(toml::value::Table::new()),
);
let mut outer = toml::value::Table::new();
outer.insert(String::from("inner"), toml::Value::Table(inner));
let mut value = toml::Value::Table(outer);
remove(&mut value);
let empty_table = toml::Value::Table(toml::value::Table::new());
assert_eq!(value, emp
```
<Overlap Ratio: 0.8849557522123894>

---

--- 187 --
Question ID: ef651b75cf5fbbbc8568091dc8d277df24d00ef1_0
Original Code:
```
fn count_gc_content(dna: &String) -> u32 {
        let mut gc_content: u32 = 0;
        for i in dna.chars() {
            match i {
                'G' | 'g'  => gc_content += 1,
                'C' | 'c' => gc_content += 1,
                _ => (), 
            };
        }
        gc_content
    }
```


Overlapping Code:
```
{
let mut gc_content: u32 = 0;
for i in dna.chars() {
match i {
'G' | 'g' => gc_content += 1,
'C' | 'c' => gc_content += 1,
_ => (), 
};
}
gc_content

```
<Overlap Ratio: 0.78125>

---

--- 188 --
Question ID: c3091368183bf9cfc7deeb2d56dcedc89f220b57_0
Original Code:
```
fn it_works() {
    let builder = SqlSessionFactoryBuilder::build();
    let mut session = builder.open_session();
    let res = select_one!(session, "UserDao.queryUserInfoById", 1u64).unwrap();
    println!("{:?}", res);
}
```


Overlapping Code:
```
SessionFactoryBuilder::build();
let mut session = builder.open_session();
let res = select_one!(session, "UserDao.queryUserInfoById", 1u64).unwrap();

```
<Overlap Ratio: 0.7246376811594203>

---

--- 189 --
Question ID: f8b2bf043358764b4e30c185e1999f58b9e1ae30_0
Original Code:
```
async fn test_list_typefaces() {
    test_list_typefaces_empty_request_gets_all().await.unwrap();
    test_list_typefaces_no_results_after_last_page().await.unwrap();
    test_list_typefaces_paginates().await.unwrap();
    test_list_typefaces_no_results_found().await.unwrap();
    test_list_typefaces_by_name().await.unwrap();
    test_list_typefaces_by_alias().await.unwrap();
    test_list_typefaces_by_name_ignores_case().await.unwrap();
    test_list_typefaces_by_name_substring().await.unwrap();
    test_list_typefaces_by_slant_range().await.unwrap();
    test_list_typefaces_by_slant_range_is_inclusive().await.unwrap();
    test_list_typefaces_by_weight_range().await.unwrap();
    test_list_typefaces_by_weight_range_is_inclusive().await.unwrap();
    test_list_typefaces_by_width_range().await.unwrap();
    test_list_typefaces_by_width_range_is_inclusive().await.unwrap();
    test_list_typefaces_by_language().await.unwrap();
    test_list_typefaces_by_code_point().await.unwrap();
    test_list_typefaces_by_generic_family().await.unwrap();
}
```


Overlapping Code:
```
t_list_typefaces() {
test_list_typefaces_empty_request_gets_all().await.unwrap();
test_list_typefaces_no_results_after_last_page().await.unwrap();
test_list_typefaces_paginates().await.unwrap();
test_list_typefaces_no_results_found().await.unwrap();
test_list_typefaces_by_name().await.unwrap();
test_list_typefaces_by_alias().await.unwrap();
test_list_typefaces_by_name_ignores_case().await.unwrap();
test_list_typefaces_by_name_substring().await.unwrap();
test_list_typefaces_by_slant_range().await.unwrap();
test_list_typefaces_by_slant_range_is_inclusive().await.unwrap();
test_list_typefaces_by_weight_range().await.unwrap();
test_list_typefaces_by_weight_range_is_inclusive().await.unwrap();
test_list_typefaces_by_width_range().await.unwrap();
test_list_typefaces_by_width_range_is_inclusive().await.unwrap();
test_list_typefaces_by_language().await.unwrap();
test_list_typefaces_by_code_point().await.unwrap();
test_list_typefaces_by_generic_
```
<Overlap Ratio: 0.9615384615384616>

---

--- 190 --
Question ID: 7d9d79394ea454de3a509f3f9264551996d96f98_11
Original Code:
```
fn test_8xy2() {
        let mut chip = Chip8::new(&sdl2::init().unwrap());

        chip.v[1] = 0xFF;
        chip.v[2] = 0x0F;
        chip.run_op_code(0x8122);
        assert_eq!(chip.v[1], 0x0F);
        assert_eq!(chip.pc, 0x202);
    }
```


Overlapping Code:
```
est_8xy2() {
let mut chip = Chip8::new(&sdl2::init().unwrap());
chip.v[1] = 0xFF;
chip.v[2] = 0x0F;
chip.run_op_code(0x8122);
assert_eq!(chip.v[1], 0x
```
<Overlap Ratio: 0.7978723404255319>

---

--- 191 --
Question ID: ea196c04010a3701eeb7409e2ddee5fddfd07b74_0
Original Code:
```
fn main() -> Result<()> {
    let opts: Opts = Opts::parse();
    let mut input = String::new();
    File::open(opts.input)?.read_to_string(&mut input)?;
    let numbers = input
        .split(',')
        .filter_map(|n| match n.trim() {
            "" => None,
            n => Some(u32::from_str(n)),
        })
        .collect::<std::result::Result<Vec<_>, _>>()?;
    let (target, score) = optimize(&numbers, opts.expensive);
    println!("Best target is {} with a fuel cost of {}", target, score);
    Ok(())
}
```


Overlapping Code:
```
fn main() -> Result<()> {
let opts: Opts = Opts::parse();
let mut input = String::new();
File::open(opts.input)?.read_to_string(&mut input)?;
let numbers = input
.split(',')
.filter_map(|n| match n.trim() {
"" => None,
n => Some(u32::from_str(n)),
})
.collect::<std::result::Result<Vec<_>, _>>()?;
let (target, score) = optimize(&numbers, opts.expensive);
println!("Best target is {} with a fuel cost of {}", target, score);

```
<Overlap Ratio: 0.9815242494226328>

---

--- 192 --
Question ID: cfa731e3c86c3770c63368a4bc87291f0058e60b_0
Original Code:
```
pub fn flipgame(fronts: Vec<i32>, backs: Vec<i32>) -> i32 {
    let n = fronts.len();
    let mut hs = HashSet::new();
    let mut res = i32::MAX;
    for i in 0..n {
        if fronts[i] == backs[i] {
            hs.insert(fronts[i]);
        }
    }
    for i in 0..n {
        if !hs.contains(&fronts[i]) {
            res = res.min(fronts[i]);
        }
        if !hs.contains(&backs[i]) {
            res = res.min(backs[i]);
        }
    }
    if res == i32::MAX {
        0
    } else {
        res
    }
}
```


Overlapping Code:
```
: Vec<i32>, backs: Vec<i32>) -> i32 {
let n = fronts.len();
let mut hs = HashSet::new();
let mut res = i32::MAX;
for i in 0..n {
if fronts[i] == backs[i] {
hs.insert(fronts[i]);
}
}
for i in 0..n {
if !hs.contains(&fronts[i]) {
res = res.min(fronts[i]);
}
if !hs.contains(&backs[i]) {
res = res.min(backs[i]);
}
}
if res == i32::MAX {
0
} else {
res

```
<Overlap Ratio: 0.9333333333333333>

---

--- 193 --
Question ID: cfab3bec9b2a338d3090f711b11015e75d5e4555_71
Original Code:
```
pub fn XMVectorFloor(V: FXMVECTOR) -> XMVECTOR {
    #[cfg(_XM_NO_INTRINSICS_)]
    unsafe {
        let Result = XMVECTORF32 {
            f: [
                floorf(V.vector4_f32[0]),
                floorf(V.vector4_f32[1]),
                floorf(V.vector4_f32[2]),
                floorf(V.vector4_f32[3])
            ]
        };
        return Result.v;
    }

    #[cfg(_XM_ARM_NEON_INTRINSICS_)]
    {
        unimplemented!()
    }

    #[cfg(_XM_SSE4_INTRINSICS_)]
    unsafe {
        return _mm_floor_ps(V);
    }

    #[cfg(all(not(_XM_SSE4_INTRINSICS_), _XM_SSE_INTRINSICS_))]
    unsafe {
        // To handle NAN, INF and numbers greater than 8388608, use masking
        let mut vTest: __m128i = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask.m128i());
        vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction.m128i());
        // Truncate
        let vInt: __m128i = _mm_cvttps_epi32(V);
        let mut vResult: XMVECTOR = _mm_cvtepi32_ps(vInt);
        let mut vLarger: __m128 = _mm_cmpgt_ps(vResult, V);
        // 0 -> 0, 0xffffffff -> -1.0f
        vLarger = _mm_cvtepi32_ps(_mm_castps_si128(vLarger));
        vResult = _mm_add_ps(vResult, vLarger);
        // All numbers less than 8388608 will use the round to int
        vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));
        // All others, use the ORIGINAL value
        vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));
        vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));
        return vResult;
    }
}
```


Overlapping Code:
```
 FXMVECTOR) -> XMVECTOR {
#[cfg(_XM_NO_INTRINSICS_)]
unsafe {
let Result = XMVECTORF32 {
f: [
floorf(V.vector4_f32[0]),
floorf(V.vector4_f32[1]),
floorf(V.vector4_f32[2]),
floorf(V.vector4_f32[3])
]
};
return Result.v;
}
#[cfg(_XM_ARM_NEON_INTRINSICS_)]
{
unimplemented!()
}
#[cfg(_XM_SSE4_INTRINSICS_)]
unsafe {
return _mm_floor_ps(V);
}
#[cfg(all(not(_XM_SSE4_INTRINSICS_), _XM_SSE_INTRINSICS_))]
unsafe {
// To handle NAN, INF and numbers greater than 8388608, use masking
let mut vTest: __m128i = _mm_and_si128(_mm_castps_si128(V), g_XMAbsMask.m128i());
vTest = _mm_cmplt_epi32(vTest, g_XMNoFraction.m128i());
// Truncate
let vInt: __m128i = _mm_cvttps_epi32(V);
let mut vResult: XMVECTOR = _mm_cvtepi32_ps(vInt);
let mut vLarger: __m128 = _mm_cmpgt_ps(vResult, V);
// 0 -> 0, 0xffffffff -> -1.0f
vLarger = _mm_cvtepi32_ps(_mm_castps_si128(vLarger));
vResult = _mm_add_ps(vResult, vLarger);
// All numbers less than 8388608 will use the round to int
vResult = _mm_and_ps(vResult, _mm_castsi128_ps(vTest));
// All others, use the ORIGINAL value
vTest = _mm_andnot_si128(vTest, _mm_castps_si128(V));
vResult = _mm_or_ps(vResult, _mm_castsi128_ps(vTest));
return vResult;
}
}
```
<Overlap Ratio: 0.9808173477898249>

---

--- 194 --
Question ID: 37f6c251f7454fede9b55291317f4daaf7093e18_7
Original Code:
```
pub unsafe fn parse_8_chars(s: &[u8]) -> Result<u32, Pie> {
    debug_assert!(s.len() >= 8);
    const MASK_HI: u64 = 0xf0f0f0f0f0f0f0f0u64;
    const ASCII_ZEROS: u64 = 0x3030303030303030u64;

    let chunk = unsafe {
        let ptr = s.as_ptr();
        debug_assert!(ptr as usize % core::mem::size_of::<u64>() == 0);
        //        (if ptr as usize % core::mem::size_of::<u64>() == 0 {
        *(ptr as *const u64)
        // } else {
        //     panic!("swoops8");

        //     core::ptr::read_unaligned(ptr as *const u64)
        // })
         ^ ASCII_ZEROS
    };

    let valid = (chunk & MASK_HI)
        | (chunk.wrapping_add(0x7676767676767676u64) & 0x8080808080808080u64)
        == 0;

    // 1-byte mask trick (works on 4 pairs of single digits)
    let lower_digits = ((chunk & 0x0f000f000f000f00) >> 8) * 10; //Compiler does *8 + *2
    let upper_digits = chunk & 0x000f000f000f000f;
    let chunk = lower_digits + upper_digits;

    // 2-byte mask trick (works on 2 pairs of two digits)
    let lower_digits = ((chunk & 0x00ff000000ff0000) >> 16) * 100; //TODO: decompose * 100 to shifts
    let upper_digits = chunk & 0x000000ff000000ff;
    let chunk = lower_digits + upper_digits;

    // 4-byte mask trick (works on a pair of four digits)
    let lower_digits = (((chunk & 0x0000ffff00000000) >> 32) * 10000) as u32;
    let upper_digits = chunk as u32;

    //We do this before the if shaving 300ps.
    let chunk = lower_digits + upper_digits;

    if likely!(valid) {
        Ok(chunk) //u32 can guarantee to contain 9 digits.
    } else {
        Err(Pie {
            kind: IntErrorKind::InvalidDigit,
        })
    }
}
```


Overlapping Code:
```
b unsafe fn parse_8_chars(s: &[u8]) -> Result<u32, Pie> {
debug_assert!(s.len() >= 8);
const MASK_HI: u64 = 0xf0f0f0f0f0f0f0f0u64;
const ASCII_ZEROS: u64 = 0x3030303030303030u64;
let chunk = unsafe {
let ptr = s.as_ptr();
debug_assert!(ptr as usize % core::mem::size_of::<u64>() == 0);
// (if ptr as usize % core::mem::size_of::<u64>() == 0 {
*(ptr as *const u64)
// } else {
// panic!("swoops8");
// core::ptr::read_unaligned(ptr as *const u64)
// })
^ ASCII_ZEROS
};
let valid = (chunk & MASK_HI)
| (chunk.wrapping_add(0x7676767676767676u64) & 0x8080808080808080u64)
== 0;
// 1-byte mask trick (works on 4 pairs of single digits)
let lower_digits = ((chunk & 0x0f000f000f000f00) >> 8) * 10; //Compiler does *8 + *2
let upper_digits = chunk & 0x000f000f000f000f;
let chunk = lower_digits + upper_digits;
// 2-byte mask trick (works on 2 pairs of two digits)
let lower_digits = ((chunk & 0x00ff000000ff0000) >> 16) * 100; //TODO: decompose * 100 to shifts
let upper_digits = chunk & 0x000000ff000000ff;
let chunk = lower_digits + upper_digits;
// 4-byte mask trick (works on a pair of four digits)
let lower_digits = (((chunk & 0x0000ffff00000000) >> 32) * 10000) as u32;
let upper_digits = chunk as u32;
//We do this before the if shaving 300ps.
let chunk = lower_digits + upper_digits;
if likely!(valid) {
Ok(chunk) //u32 can guarantee to contain 9 digits.
} else {
Err(Pie {
kind: IntErrorKind::InvalidDigi
```
<Overlap Ratio: 0.9922535211267606>

---

--- 195 --
Question ID: 83e7c2ed442eb0b75773fc2447722f1f1e61d632_5
Original Code:
```
fn test_parse_limit() {
        let yaml = load_yaml!("cli.yml");
        let app = App::from_yaml(yaml);

        // Testing a valid limit value
        let matches = app.get_matches_from(vec!["cub", "ls", "-l", "42"]);
        let subcommand = matches.subcommand_matches("ls").unwrap();
        let limit = parse_limit(subcommand);

        match limit {
            Limit::FINITE(val) => assert_eq!(val, 42),
            Limit::INFINITE => {}
        }
    }
```


Overlapping Code:
```
n test_parse_limit() {
let yaml = load_yaml!("cli.yml");
let app = App::from_yaml(yaml);
// Testing a valid limit value
let matches = app.get_matches_from(vec!["cub", "ls", "-l", "42"]);
let subcommand = matches.subcommand_matches("ls").unwrap();
let limit = parse_limit(subcommand);
match limit {
Limit::FINITE(val) => assert_eq!(val, 42),
Limit::IN
```
<Overlap Ratio: 0.9536784741144414>

---

--- 196 --
Question ID: a5b63dcdbcff36110b8bffdeaacf982609e365cc_0
Original Code:
```
fn can_convert_between_document_and_card() {
        let card = Card {
            id: Uuid::new_v4(),
            name: "test card".to_owned(),
            description: "test description".to_owned(),
            image_uri: "https://localhost/test_uri.png".to_owned(),
            stat_base: StatsI {
                physical: 24,
                mental: 12,
                tactical: 19,
            },
            stat_multiplier: StatsF {
                physical: 2.0,
                mental: 0.9,
                tactical: 0.5,
            },
        };

        let card_clone = card.clone();
        let mut doc: Document = card_clone.into();
        doc.name = format!("parent_path/{}", card.id.to_string());

        let card_from_doc: Card = doc.try_into().unwrap();

        assert_eq!(card, card_from_doc);
    }
```


Overlapping Code:
```
ent_and_card() {
let card = Card {
id: Uuid::new_ved(),
description: "test description".to_owned(),
image_uri: "https://localhost/test_uri.png".to_owned(),
stat_base: StatsI {
physical: 24,
mental: 12,
tactical: 19,
},
stat_multiplier: StatsF {
physical: 2.0,
mental: 0.9,
tactical: 0.5,
},
};
let card_clone = card.clone();
let mut doc: Document = card_clone.into();
doc.name = format!("parent_path/{}", card.id.to_string());
let card_from_doc: Card = doc.try_into().unwrap
```
<Overlap Ratio: 0.8330404217926186>

---

--- 197 --
Question ID: 2fa1192c84ae3a79653c24debd50b5f53db84dba_2
Original Code:
```
fn select(array: &mut [isize], left: usize, right: usize, k: usize) -> isize {
    let mut pivot_index;
    let (mut left, mut right) = (left, right);
    loop {
        if left == right {
            return array[left];
        }
        pivot_index = thread_rng().gen_range(left, right);
        pivot_index = partition(array, left, right, pivot_index);
        if pivot_index == k {
            return array[k];
        } else if pivot_index < k {
            left = pivot_index + 1;
        } else {
            right = pivot_index - 1;
        }
    }
}
```


Overlapping Code:
```
isize], left: usize, right: usize, k: usize) -> isize {
let mut pivot_index;
let (mut left, mut right) = (left, right);
loop {
if left == right {
return array[left];
}
pivot_index = thread_rng().gen_range(left, right);
pivot_index = partition(array, left, right, pivot_index);
if pivot_index == k {
return array[k];
} else if pivot_index < k {
left = pivot_index + 1;
} else {
right = pivot_index - 1
```
<Overlap Ratio: 0.9302325581395349>

---

--- 198 --
Question ID: a94f068c27303d2b256fd2ab7da51e2c0b43988c_11
Original Code:
```
fn msb_bits_to_byte(bits: &[bool]) -> u8 {
    // bits is encoded msb -> lsb
    debug_assert_eq!(8, bits.len());
    let mut result: u8 = 0;
    let mut mask: u8 = 0x80; // msb set
    for i in 0..bits.len() {
        if bits[i] {
            result |= mask;
        }
        if i < bits.len() - 1 {
            mask >>= 1;
        }
    }
    result
}
```


Overlapping Code:
```
 msb_bits_to_byte(bits: &[bool]) -> u8 {
// bits is encoded msb -> lsb
debug_assert_eq!(8, bits.len());
let mut result: u8 = 0;
let mut mask: u8 = 0x80; // msb set
for i in 0..bits.len() {
if bits[i] {
result |= mask;
}
if i < bits.len() - 1 {
mask >
```
<Overlap Ratio: 0.9259259259259259>

---

--- 199 --
Question ID: ad67a6ebc1a1f64a2205137dae49b6d6ed24b739_6
Original Code:
```
fn basic2() {
        // data from yorgos's e-mail
        let subject = Subject{
            name: String::from("subj01"),
            prices: Matrix::from_slice(3, 3, &[
                2.0, 2.0, 3.0,
                5.0, 5.0, 1.0,
                3.0, 4.0, 2.0,
            ]),
            amounts: Matrix::from_slice(3, 3, &[
                10.0, 20.0,  5.0,
                 7.0,  2.0, 10.0,
                 8.0, 12.0,  7.0,
            ]),
        };

        let resp = super::run(DummyLogger, subject).unwrap();

        assert_eq!(resp.name, "subj01");
        assert_eq!(resp.violations, &[
        ]);
        assert_eq!(resp.warp_strict, 0);
        assert_eq!(resp.warp_nonstrict, 0);
        assert_eq!(resp.hm_garp.lower, 0);
        assert_eq!(resp.hm_garp.upper, 0);
        assert_eq!(resp.hm_sarp.lower, 0);
        assert_eq!(resp.hm_sarp.upper, 0);
        assert_eq!(resp.hm_warp_strict.lower, 0);
        assert_eq!(resp.hm_warp_strict.upper, 0);
        assert_eq!(resp.hm_warp_nonstrict.lower, 0);
        assert_eq!(resp.hm_warp_nonstrict.upper, 0);
    }
```


Overlapping Code:
```
m yorgos's e-mail
let subject = Subject{
name: String::from("subj01"),
prices: Matrix::from_slice(3, 3, &[
2.0, 2.0, 3.0,
5.0, 5.0, 1.0,
3.0, 4.0, 2.0,
]),
amounts: Matrix::from_slice(3, 3, &[
10.0, 20.0, 5.0,
7.0, 2.0, 10.0,
8.0, 12.0, 7.0,
]),
};
let resp = super::run(DummyLogger, subject).unwrap();
assert_eq!(resp.name, "subj01");
assert_eq!(resp.violations, &[
]);
assert_eq!(resp.warp_strict, 0);
assert_eq!(resp.warp_nonstrict, 0);
assert_eq!(resp.hm_garp.lower, 0);
assert_eq!(resp.hm_garp.upper, 0);
assert_eq!(resp.hm_sarp.lower, 0);
assert_eq!(resp.hm_sarp.upper, 0);
assert_eq!(resp.hm_warp_strict.lower, 0);
assert_eq!(resp.hm_warp_strict.upper, 0);
assert_eq!(resp.hm_warp_nonstrict.lower, 0);
assert_eq!(resp.hm_warp_nonstrict.upper, 
```
<Overlap Ratio: 0.9615384615384616>

---

--- 200 --
Question ID: d09f675f991e64158fc6e8bfbe83af84a12bb44d_5
Original Code:
```
fn counter_generate_workloads() {
        let path = PathBuf::from_str("tests/data").unwrap();
        let counter = Counter::new(path.clone());

        let result = counter.generate_workloads(1, 3);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![3]);

        let result = counter.generate_workloads(3, 3);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![1, 1, 1]);

        let result = counter.generate_workloads(2, 3);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), vec![2, 1]);
    }
```


Overlapping Code:
```
rkloads() {
let path = PathBuf::from_str("tests/data").unwrap();
let counter = Counter::new(path.clone());
let result = counter.generate_workloads(1, 3);
assert!(result.is_ok());
assert_eq!(result.unwrap(), vec![3]);
let result = counter.generate_workloads(3, 3);
assert!(result.is_ok());
assert_eq!(result.unwrap(), vec![1, 1, 1]);
let result = counter.generate_workloads(2, 3);
assert!(result.is_ok());
assert_eq!(result.unwrap(), 
```
<Overlap Ratio: 0.9232409381663113>

---

--- 201 --
Question ID: fe81453e31e723184bd61c26dc4381983d5078be_2
Original Code:
```
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        return;
    }

    let filename = &args[1];
    let file = File::open(filename).unwrap_or_else(|_| panic!("Failed to open file {}", filename));
    let mut reader = BufReader::new(file);

    let mut new_math_sum = 0;
    let mut advanced_math_sum = 0;

    let mut line = String::new();
    loop {
        let bytes = reader
            .read_line(&mut line)
            .unwrap_or_else(|_| panic!("Failed to read line"));
        if bytes == 0 {
            break;
        }

        {
            let (value, _) = evaluate_expression(false, line.trim());
            new_math_sum += value;
        }
        {
            let (value, _) = evaluate_expression(true, line.trim());
            advanced_math_sum += value;
        }

        line.clear();
    }

    println!("New math sum: {}", new_math_sum);
    println!("Advanced math sum: {}", advanced_math_sum);
}
```


Overlapping Code:
```
fn main() {
let args: Vec<String> = env::args().collect();
if args.len() != 2 {
return;
}
let filename = &args[1];
let file = File::open(filename).unwrap_or_else(|_| panic!("Failed to open file {}", filename));
let mut reader = BufReader::new(file);
let mut new_math_sum = 0;
let mut advanced_math_sum = 0;
let mut line = String::new();
loop {
let bytes = reader
.read_line(&mut line)
.unwrap_or_else(|_| panic!("Failed to read line"));
if bytes == 0 {
break;
}
{
let (value, _) = evaluate_expression(false, line.trim());
new_math_sum += value;
}
{
let (value, _) = evaluate_expression(true, line.trim());
advanced_math_sum += value;
}
line.clear();
}
println!("New math sum: {}", new_math_sum);
println!("Advanced math sum: {}", 
```
<Overlap Ratio: 0.9720372836218375>

---

--- 202 --
Question ID: 4a45f54d3eac01a9fe0a62d4551ff90e7db04ecc_6
Original Code:
```
fn render_world_ch7(name: &str) {
    // World
    let mut world = HittableList {
        objects: Vec::new(),
    };

    world.add(Sphere {
        center: Point3::new(0.0, 0.0, -1.0),
        radius: 0.5,
    });
    world.add(Sphere {
        center: Point3::new(0.0, -100.5, -1.0),
        radius: 100.0,
    });

    // Camera
    let cam = Camera::new(RATIO);

    // create image buffer
    let mut imgbuf = ImageBuffer::new(WIDTH, HEIGHT);

    // Iterate over the coordinates and pixels of the image
    let len = WIDTH as u64 * HEIGHT as u64;
    let bar = ProgressBar::new(len);
    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
        bar.inc(1);

        let mut c = Color::zero();
        for _s in 0..SAMPLES_PER_PIXEL {
            let u = (x as f64 + random_double()) / (WIDTH as f64 - 1f64);
            let v = ((HEIGHT - y) as f64 + random_double()) / (HEIGHT as f64 - 1f64);

            let r = cam.get_ray(u, v);

            c += ray_color_world(&r, &world);
        }

        *pixel = Rgb(c.to_u8_avg(SAMPLES_PER_PIXEL));
    }
    bar.finish();

    // write the generated image (format is deduced based on extension)
    imgbuf.save(name).unwrap();
}
```


Overlapping Code:
```
der_world_ch7(name: &str) {
// World
let mut world = HittableList {
objects: Vec::new(),
};
world.add(Sphere {
center: Point3::new(0.0, 0.0, -1.0),
radius: 0.5,
});
world.add(Sphere {
center: Point3::new(0.0, -100.5, -1.0),
radius: 100.0,
});
// Camera
let cam = Camera::new(RATIO);
// create image buffer
let mut imgbuf = ImageBuffer::new(WIDTH, HEIGHT);
// Iterate over the coordinates and pixels of the image
let len = WIDTH as u64 * HEIGHT as u64;
let bar = ProgressBar::new(len);
for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {
bar.inc(1);
let mut c = Color::zero();
for _s in 0..SAMPLES_PER_PIXEL {
let u = (x as f64 + random_double()) / (WIDTH as f64 - 1f64);
let v = ((HEIGHT - y) as f64 + random_double()) / (HEIGHT as f64 - 1f64);
let r = cam.get_ray(u, v);
c += ray_color_world(&r, &world);
}
*pixel = Rgb(c.to_u8_avg(SAMPLES_PER_PIXEL));
}
bar.finish();
// write the generated image (format is deduced based on extension)
imgbuf.save(name).unwrap(
```
<Overlap Ratio: 0.9897330595482546>

---

--- 203 --
Question ID: 7fee3e7b85ab0adffe92126a30a634a5c76cb944_59
Original Code:
```
fn bitxor_false() {
        let mut p1 = Imp::new(true);
        p1 ^= false;
        assert_eq!(p1, true);
    }
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 204 --
Question ID: 50fae912484e2bdb5819e7c2d4409a3c8263f600_20
Original Code:
```
fn test_get_input_radix() {
        let mut calculator = Calculator::new();
        calculator.get_input_radix().unwrap();
        assert_eq!(calculator.stack.len(), 1);
        assert_eq!(
            *calculator.stack.back().unwrap(),
            StackValue::Number(BigInt::from(calculator.input_radix))
        );
    }
```


Overlapping Code:
```
t_radix() {
let mut calculator = Calculator::new();
calculator.get_input_radix().unwrap();
assert_eq!(calculator.stack.len(), 1);
assert_eq!(
*calculator.stack.back().unwrap(),
StackValue::Number(BigI
```
<Overlap Ratio: 0.7874015748031497>

---

--- 205 --
Question ID: a3664442ef97a1196d2e155a5051043b13f2f50f_3
Original Code:
```
fn order_by1() {
        let expected = vec![2, 3, 4, 5, 6];
        let actual = vec![4, 3, 2, 5, 6];
        assert_eq!(actual.order_by(&|a: i32, b: i32| a < b), expected);
    }
```


Overlapping Code:
```
ted = vec![2, 3, 4, 5, 6];
let actual = vec![4, 3, 2, 5, 6];
assert_eq!(actual.order_by(&|a: i32, b:
```
<Overlap Ratio: 0.6578947368421053>

---

--- 206 --
Question ID: c22c89dbf384bf15f4c9122e54ff069cc0d78ef3_1
Original Code:
```
fn get_configs_provider() -> Vec<(Config, String)> {
        let config_without_countries = Config {
            http: false,
            https: true,
            ipv4: false,
            ipv6: true,
            countries: None,
        };

        let countries = Some(vec!["France".to_string()]);

        let full_config = Config {
            http: true,
            https: true,
            ipv4: true,
            ipv6: true,
            countries,
        };

        vec![
            (
                config_without_countries,
                "https://www.archlinux.org/mirrorlist/?&ip_version=6&protocol=https".to_string(),
            ),
            (full_config, "https://www.archlinux.org/mirrorlist/?&ip_version=4&ip_version=6&protocol=http&protocol=https&country=FR".to_string()),
        ]
    }
```


Overlapping Code:
```
ider() -> Vec<(Config, String)> {
let config_without_countries = Config {
http: false,
https: true,
ipv4: false,
ipv6: true,
countries: None,
};
let countries = Some(vec!["France".to_string()]);
let full_config = Config {
http: true,
https: true,
ipv4: true,
ipv6: true,
countries,
};
vec![
(
config_without_countries,
"https://www.archlinux.org/mirrorlist/?&ip_version=6&protocol=https".to_string(),
),
(full_config, "https://www.archlinux.org/mirrorlist/?&ip_version=4&ip_version=6&protocol=http&pr
```
<Overlap Ratio: 0.8912655971479501>

---

--- 207 --
Question ID: e86f7b57e357b4740b074e035d192a2456380471_61
Original Code:
```
fn it_can_decode_binary_literal_16_rsub_operation() {
        let raw_opcode: &[u8] = &[0xd1, 0x2f, 0xFF, 0x00];
        let mut d: ByteCodeDecoder<_, LittleEndian> = ByteCodeDecoder::new(raw_opcode);

        let opcode = d.nth(0).unwrap();

        assert_eq!("rsub-int v15, v2, #255", opcode.to_string());
        assert!(matches!(
            opcode,
            ByteCode::BinaryLit16(_, dest, src, lit) if dest == 15 &&  src == 2 && lit == 255));
    }
```


Overlapping Code:
```
ub_operation() {
let raw_opcode: &[u8] = &[0xd1, 0x2f, 0xFF, 0x00];
let mut d: ByteCodeDecoder<_, LittleEndian> = ByteCodeDecoder::new(raw_opcode);
let opcode = d.nth(0).unwrap();
assert_eq!("rsub-int v15, v2, #255", opcode.to_string());
assert!(matches!(
opcode,
ByteCode::BinaryLit16(_, dest, src, lit) if dest == 15 && src == 2 && lit == 255)
```
<Overlap Ratio: 0.8937823834196891>

---

--- 208 --
Question ID: d4c3e1026d97040aae8578f639e702323531ab9a_0
Original Code:
```
fn print_stats(mut times: Vec<u32>) {
    times.sort();

    let p50 = times.len() as f64 * 0.5;
    let p95 = times.len() as f64 * 0.95;
    let p99 = times.len() as f64 * 0.99;
    let p999 = times.len() as f64 * 0.999;

    println!("Stats (ns): p50: {} p95: {} p99: {} p999: {} max: {}",
        times[p50 as usize],
        times[p95 as usize],
        times[p99 as usize],
        times[p999 as usize],
        times.last().unwrap(),
    );
}
```


Overlapping Code:
```
ec<u32>) {
times.sort();
let p50 = times.len() as f64 * 0.5;
let p95 = times.len() as f64 * 0.95;
let p99 = times.len() as f64 * 0.99;
let p999 = times.len() as f64 * 0.999;
println!("Stats (ns): p50: {} p95: {} p99: {} p999: {} max: {}",
times[p50 as usize],
times[p95 as usize],
times[p99 as usize],
times[p999 as usize],
times.last().unwrap(),
);

```
<Overlap Ratio: 0.9259259259259259>

---

--- 209 --
Question ID: 7037f8077078b8613cd4aa62b86ed8bfeceed43d_3
Original Code:
```
pub fn print_nbits(data: &[u8], nbits: usize) -> Result<String, std::fmt::Error> {
    let mut result = String::new();
    write!(&mut result, "[")?;
    for i in 0..nbits {
        let byte = i / 8;
        let bit = i % 8;
        let num = if 0 != (data[byte] & (1 << bit)) { 1 } else { 0 };
        write!(&mut result, "{}", num)?;
    }

    write!(&mut result, "]")?;
    Ok(result)
}
```


Overlapping Code:
```
ze) -> Result<String, std::fmt::Error> {
let mut result = String::new();
write!(&mut result, "[")?;
for i in 0..nbits {
let byte = i / 8;
let bit = i % 8;
let num = if 0 != (data[byte] & (1 << bit)) { 1 } else { 0 };
write!(&mut result, "{}", num)?;

```
<Overlap Ratio: 0.7507507507507507>

---

--- 210 --
Question ID: 12c68000f059d750bdc7054c06e8fb0224a2c7a4_2
Original Code:
```
fn degrees_to_radian() { 
        let deg = 80_f32; 
        let rad = to_radian(deg); 
       
        assert_eq!(1.3962634, rad);
    }
```


Overlapping Code:
```
ees_to_radian() { 
let deg = 80_f32; 
let rad = to
```
<Overlap Ratio: 0.49019607843137253>

---

--- 211 --
Question ID: 49278ae5fa082a0b1a4df4b0ae9866d15f63d8eb_5
Original Code:
```
fn output(path: &str) {
    let input = fs::read_to_string(&path).unwrap();

    let (part_1, part_2) = solve(&input);

    println!("File: {}", path);
    println!("  Part 1: {}", part_1);
    println!("  Part 2: {}", part_2);
}
```


Overlapping Code:
```
utput(path: &str) {
let input = fs::read_to_string(&path).unwrap();
let (part_1, part_2) = solve(&input);
println!("File: {}", path);
println!(" Part 1: {}", part_1);
println!(" Part 2: {}", part
```
<Overlap Ratio: 0.9512195121951219>

---

--- 212 --
Question ID: e5a76389b61719df43177b3dded0b880a2eac13c_2
Original Code:
```
pub fn direct_step_single(
    in_slice: &[f32],
    out_slice: &mut [f32],
    out_stride: usize,
    out_sample: usize,
    n: usize,
    sinc_table: &[f32],
) {
    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
    {
        if is_x86_feature_detected!("avx") {
            unsafe {
                avx_wrapper::direct_step_single(
                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,
                );
            }
            return;
        }

        if is_x86_feature_detected!("sse3") {
            unsafe {
                sse3_wrapper::direct_step_single(
                    in_slice, out_slice, out_stride, out_sample, n, sinc_table,
                );
            }
            return;
        }
    }

    super::native::direct_step_single(
        in_slice, out_slice, out_stride, out_sample, n, sinc_table,
    );
}
```


Overlapping Code:
```
tep_single(
in_slice: &[f32],
out_slice: &mut [f32],
out_stride: usize,
out_sample: usize,
n: usize,
sinc_table: &[f32],
) {
#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
{
if is_x86_feature_detected!("avx") {
unsafe {
avx_wrapper::direct_step_single(
in_slice, out_slice, out_stride, out_sample, n, sinc_table,
);
}
return;
}
if is_x86_feature_detected!("sse3") {
unsafe {
sse3_wrapper::direct_step_single(
in_slice, out_slice, out_stride, out_sample, n, sinc_table,
);
}
return;
}
}
super::native::direct_step_single(
in_slice, out_slice, out_stride, out_sample, n, sinc_
```
<Overlap Ratio: 0.9573770491803278>

---

--- 213 --
Question ID: e0b60a12d2909abda96d306c330eef5008dd0b1c_6
Original Code:
```
pub fn get_image_openshift_io_api_group(
) -> Result<(http::Request<Vec<u8>>, fn(http::StatusCode) -> k8s_openapi::ResponseBody<GetImageOpenshiftIoAPIGroupResponse>), k8s_openapi::RequestError> {
    let __url = "/apis/image.openshift.io/".to_owned();

    let __request = http::Request::get(__url);
    let __body = vec![];
    match __request.body(__body) {
        Ok(request) => Ok((request, k8s_openapi::ResponseBody::new)),
        Err(err) => Err(k8s_openapi::RequestError::Http(err)),
    }
}
```


Overlapping Code:
```
shift_io_api_group(
) -> Result<(http::Request<Vec<u8>>, fn(http::StatusCode) -> k8s_openapi::ResponseBody<GetImageOpenshiftIoAPIGroupResponse>), k8s_openapi::RequestError> {
let __url = "/apis/image.openshift.io/".to_owned();
let __request = http::Request::get(__url);
let __body = vec![];
match __request.body(__body) {
Ok(request) => Ok((request, k8s_openapi::ResponseBody::new)),
Err(err) => Err(k8s_openapi::RequestError::Http(err)),
}
}
```
<Overlap Ratio: 0.9546436285097192>

---

--- 214 --
Question ID: 68b79f81bf936e0d4cf9d1c85e1d5feadc5e37c8_1
Original Code:
```
fn one_time_password_build_request() {
        let base_url = Url::parse("https://YOUR_DOMAIN").unwrap();
        let authentication = AuthenicationMethod::OAuth2Token(String::from("some_awesome_token"));
        let mfa = Api::init(base_url, authentication);
        let parameters = mfa::one_time_password::RequestParameters {
            grant_type: String::from("some_awesome_grant_type"),
            client_id: String::from("some_awesome_client_id"),
            client_secret: None,
            mfa_token: String::from("some_awesome_mfa_token"),
            otp: String::from("some_awesome_otp"),
        };
        let request = mfa.verify_with_otp(parameters).build().unwrap();
        let test_url = String::from("https://your_domain/oauth/token");
        let test_body = String::from(
            "grant_type=some_awesome_grant_type&\
            client_id=some_awesome_client_id&\
            mfa_token=some_awesome_mfa_token&\
            otp=some_awesome_otp",
        );
        assert_eq!(request.method().as_str(), reqwest::Method::POST);
        assert_eq!(request.url().as_str(), test_url);
        assert_eq!(request.headers().len(), 1);
        assert_eq!(
            request.body().unwrap().as_bytes().unwrap(),
            test_body.as_bytes(),
        );
    }
```


Overlapping Code:
```
ild_request() {
let base_url = Url::parse("https://YOUR_DOMAIN").unwrap();
let authentication = AuthenicationMethod::OAuth2Token(String::from("some_awesome_token"));
let mfa = Api::init(base_url, authentication);
let parameters = mfa::one_time_password::RequestParameters {
grant_type: String::from("some_awesome_grant_type"),
client_id: String::from("some_awesome_client_id"),
client_secret: None,
mfa_token: String::from("some_awesome_mfa_token"),
otp: String::from("some_awesome_otp"),
};
let request = mfa.verify_with_otp(parameters).build().unwrap();
let test_url = String::from("https://your_domain/oauth/token");
let test_body = String::from(
"grant_type=some_awesome_grant_type&\
client_id=some_awesome_client_id&\
mfa_token=some_awesome_mfa_token&\
otp=some_awesome_otp",
);
assert_eq!(request.method().as_str(), reqwest::Method::POST);
assert_eq!(request.url().as_str(), test_url);
assert_eq!(request.headers().len(), 1);
assert_eq!(
request.body().unwrap().as_bytes().unwrap(),
test_body.as_bytes(),
);

```
<Overlap Ratio: 0.976878612716763>

---

--- 215 --
Question ID: 301dc60c2f8048798447213759b50c5234c7b0c7_1
Original Code:
```
fn write_body(multi: &mut Multipart<Request<Streaming>>) -> hyper::Result<()> {
    let mut binary = "Hello world from binary!".as_bytes();

    multi.write_text("text", "Hello, world!")?;
    multi.write_file("file", "lorem_ipsum.txt")?;
    // &[u8] impl Read
    multi
        .write_stream("binary", &mut binary, None, None)
        .and(Ok(()))
}
```


Overlapping Code:
```
lti: &mut Multipart<Request<Streaming>>) -> hyper::Result<()> {
let mut binary = "Hello world from binary!".as_bytes();
multi.write_text("text", "Hello, world!")?;
multi.write_file("file", "lorem_ipsum.txt")?;
// &[u8] impl Read
multi
.write_stream("binary", &mut binary, None, None)
.and(Ok
```
<Overlap Ratio: 0.9267515923566879>

---

--- 216 --
Question ID: 5e3e9f81f7d7869cfd97b15642efacb7cb144fcb_0
Original Code:
```
pub fn get_part_one(input: &str) -> isize {
    let target = target::target(input.trim()).unwrap();

    let max_ys_on_target = get_max_ys_on_target(target);

    *max_ys_on_target.iter().max().unwrap()
}
```


Overlapping Code:
```
str) -> isize {
let target = target::target(input.trim()).unwrap();
let max_ys_on_target = get_max_ys_on_target(target);
*max_ys_on_target.iter().max(
```
<Overlap Ratio: 0.7894736842105263>

---

--- 217 --
Question ID: b37510c572dd0fb1209d0493fad1b9440cda272c_2
Original Code:
```
fn test_n_triples_plain_literal_node_formatting() {
        let formatter = NTriplesFormatter::new();
        let node = Node::LiteralNode {
            literal: "literal".to_string(),
            data_type: None,
            language: None,
        };

        assert_eq!(formatter.format_node(&node), "\"literal\"".to_string());
    }
```


Overlapping Code:
```
e_formatting() {
let formatter = NTriplesFormatter::new();
let node = Node::LiteralNode {
literal: "literal".to_string(),
data_type: None,
language: None,
};
assert_eq!(formatter.format_node(&node), "\"literal
```
<Overlap Ratio: 0.7946768060836502>

---

--- 218 --
Question ID: 483c33e770ea13fd7193c63dfa55bf751fc2b58b_2
Original Code:
```
fn player_collides_with_enemy_above() {
    let mut game = TestableGame::from_strings(vec![
        ".E..",
        ".@..",
        "...."
    ]);

    game.input.simulate_move(Up);
    game.verify_next_tiles(vec![
        ".E..",
        ".@..",
        "...."
    ]);
}
```


Overlapping Code:
```
() {
let mut game = TestableGame::from_strings(vec![
".E..",
".@..",
"...."
]);
game.input.simulate_move(Up);
game.verify_next_tiles(vec![
".E..",
".@..",
".
```
<Overlap Ratio: 0.7772277227722773>

---

--- 219 --
Question ID: 6fd57cd09e234b7cef7f65292f3deaaf316c4592_0
Original Code:
```
fn main() {
    let x = 5;
    let _y = fn~(move x) -> int {
        let _z = fn~(move x) -> int { x }; //~ ERROR moving out of captured outer variable in a heap closure
        22
    }
```


Overlapping Code:
```

let _y = fn~(move x) -> int {
let _z = fn~(move x) -> int { x }; //~ ERROR moving out of captured o
```
<Overlap Ratio: 0.6329113924050633>

---

--- 220 --
Question ID: bca57f521e6c4f57941ddb223bcba60dfbb799e0_0
Original Code:
```
async fn test_get_by_id(db: &Db) {
        assert_eq!(db.get_by_id(1).await.unwrap().text, "one".to_string());
        assert_eq!(db.get_by_id(2).await.unwrap().text, "two".to_string());
        assert_eq!(db.get_by_id(3).await.unwrap().text, "three".to_string());
    }
```


Overlapping Code:
```
_eq!(db.get_by_id(1).await.unwrap().text, "one".to_string());
assert_eq!(db.get_by_id(2).await.unwrap().text, "two".to_string());
assert_eq!(db.get_by_id(3).await.unwrap().text, "three".to_string());

```
<Overlap Ratio: 0.8264462809917356>

---

--- 221 --
Question ID: 7573b812027883906f99703dcf3c5aa2f4438055_0
Original Code:
```
pub(crate) fn parse_nodes(
    nodes_iterator: Option<
        ItersWrapper<
            Result<(usize, (String, Option<Vec<String>>))>,
            impl Iterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,
            impl ParallelIterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,
        >,
    >,
    nodes_number: Option<NodeT>,
    node_types_vocabulary: Option<Vocabulary<NodeTypeT>>,
    node_list_is_correct: bool,
    numeric_node_ids: bool,
    numeric_node_list_node_type_ids: bool,
    minimum_node_ids: Option<NodeT>,
    skip_node_types_if_unavailable: Option<bool>,
) -> Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>)> {
    let skip_node_types_if_unavailable = skip_node_types_if_unavailable.unwrap_or(false);
    if !numeric_node_ids && minimum_node_ids.is_some() {
        return Err(
            "Giving the minimum id is not meaningfull when numeric_ids is false.".to_string(),
        );
    }

    if nodes_iterator.is_none() && node_types_vocabulary.is_some() {
        return Err(
            "Node types vocabulary was provided but no nodes iterator was given.".to_string(),
        );
    }

    let has_node_types = node_types_vocabulary.is_some();

    if !has_node_types && !skip_node_types_if_unavailable && numeric_node_list_node_type_ids {
        return Err(concat!(
            "The numeric node list node type IDs parameter does not make sense ",
            "in the context where the node types have not been provided.\n",
            "If the node types within the nodes list are numeric, simply use ",
            "the numeric node types ids parameter."
        )
        .to_string());
    }

    let node_types_method = match (
        has_node_types,
        node_types_vocabulary
            .as_ref()
            .map_or(true, |x| x.is_empty()),
        node_list_is_correct,
        numeric_node_list_node_type_ids,
    ) {
        (false, _, _, _) => NodeTypeParser::ignore,
        (true, true, true, false) => NodeTypeParser::parse_strings_unchecked,
        (true, true, false, false) => NodeTypeParser::parse_strings,
        (true, false, true, false) => NodeTypeParser::get_unchecked,
        (true, false, false, false) => NodeTypeParser::get,
        (true, _, true, true) => NodeTypeParser::to_numeric_unchecked,
        (true, _, false, true) => NodeTypeParser::to_numeric,
    };
    let node_types_vocabulary = node_types_vocabulary.unwrap_or(Vocabulary::new());

    let mut node_type_parser = NodeTypeParser::new(node_types_vocabulary);
    let nodes_iterator: Option<
        ItersWrapper<Result<(usize, (String, Option<Vec<NodeTypeT>>))>, _, _>,
    > = nodes_iterator
        .map(|ni| ni.method_caller(node_types_method, node_types_method, &mut node_type_parser));

    let (nodes_vocabulary, node_types_ids, node_types_vocabulary) = match (
        nodes_iterator,
        nodes_number,
        numeric_node_ids,
        minimum_node_ids,
        node_list_is_correct,
    ) {
        // When the nodes iterator was provided, and the node IDs are expected
        // NOT to be numeric and a minimum node ID is therefore meaningless.
        // Note that this is the use case when the node list is ASSUMED TO BE CORRECT
        // and the total number of nodes is known and provided.
        (Some(ni), Some(nodes_number), false, None, true) => {
            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =
                if has_node_types {
                    // If there are node types we need to collect them.
                    // We cannot use the unzip utility because in this context
                    // since we need to use a ParallellIterator,
                    // note that it is NOT an IndexedParallellIterator.
                    // Since we know the number of nodes and the node list
                    // is provided as correct, it is possible to pre-allocate the vectors
                    // and populate them with a foreach.
                    let node_names = ThreadDataRaceAware {
                        value: std::cell::UnsafeCell::new(vec![
                            "".to_owned();
                            nodes_number as usize
                        ]),
                    };
                    let node_types_ids = ThreadDataRaceAware {
                        value: std::cell::UnsafeCell::new(vec![None; nodes_number as usize]),
                    };
                    ni.for_each(|line| unsafe {
                        // We can unwrap because the user tells us that this is surely
                        // a correct node list.
                        let (line_number, (node_name, node_type_ids)) = line.unwrap();
                        (*node_names.value.get())[line_number] = node_name;
                        (*node_types_ids.value.get())[line_number] = node_type_ids;
                    });
                    let node_type_ids = node_types_ids.value.into_inner();
                    (node_names.value.into_inner(), optionify!(node_type_ids))
                } else {
                    let node_names = ThreadDataRaceAware {
                        value: std::cell::UnsafeCell::new(vec![
                            "".to_owned();
                            nodes_number as usize
                        ]),
                    };
                    ni.for_each(|line| unsafe {
                        // We can unwrap because the user tells us that this is surely
                        // a correct node list.
                        let (line_number, (node_name, _)) = line.unwrap();
                        (*node_names.value.get())[line_number] = node_name;
                    });
                    (node_names.value.into_inner(), None)
                };
            let mut node_type_vocabulary = node_type_parser.into_inner();
            if node_type_vocabulary.is_empty() {
                node_type_vocabulary.build()?;
            }

            Ok::<_, String>((
                Vocabulary::from_reverse_map(node_names)?,
                node_types_ids,
                Some(node_type_vocabulary),
            ))
        }
        // When the nodes iterator was provided, and the node IDs are expected
        // NOT to be numeric and a minimum node ID is therefore meaningless.
        // Note that this is the use case when it is not known if the node list is
        // correct and how many nodes are inside it.
        (Some(ni), _, false, None, _) => {
            let (node_names, node_types_ids): (Vec<String>, Option<Vec<Option<Vec<NodeTypeT>>>>) =
                if has_node_types {
                    // If there are node types we need to collect them.
                    // We need to use the unzip utility because in this context we do not
                    // know the number of the nodes and we need to use a ParallellIterator,
                    // note that it is NOT an IndexedParallellIterator.
                    let (node_names, node_types_ids) = match ni
                        .map(|line| line.map(|(_, node_and_node_type)| node_and_node_type))
                    {
                        ItersWrapper::Parallel(ni_par) => ni_par
                            .collect::<Result<(Vec<String>, Vec<Option<Vec<NodeTypeT>>>)>>()?,
                        ItersWrapper::Sequential(ni_seq) => {
                            let mut node_names = Vec::new();
                            let mut node_types_ids = Vec::new();
                            for line in ni_seq {
                                let (node_name, node_type_ids) = line?;
                                node_names.push(node_name);
                                node_types_ids.push(node_type_ids);
                            }
                            (node_names, node_types_ids)
                        }
                    };

                    (node_names, optionify!(node_types_ids))
                } else {
                    (
                        ni.map(|x| x.map(|(_, (name, _))| name))
                            .collect::<Result<Vec<String>>>()?,
                        None,
                    )
                };
            let mut node_type_vocabulary = node_type_parser.into_inner();
            if node_type_vocabulary.is_empty() {
                node_type_vocabulary.build()?;
            }

            Ok::<_, String>((
                Vocabulary::from_reverse_map(node_names)?,
                node_types_ids,
                Some(node_type_vocabulary),
            ))
        }
        // When the node iterator was provided, and the nodes number is not known
        // and the node IDs are expected to be numeric.
        (Some(ni), maybe_nodes_number, true, _, _) => {
            // In case the node types are expected to exist.
            let (min, max) = if has_node_types {
                return Err(concat!(
                    "This case is not supported. You cannot have a nodes iterator of numeric node ids with node types.",
                    " This would require to sort the csv and thus it requires a higher memory peak.",
                    " If you want to load it just set numeric_node_ids to false and load them as strings.",
                ).to_string());
            } else {
                // Alternatively we can focus exclusively on the
                // node IDs, which being numeric boil down to collecting
                // the minimum and the maximum value.
                let (mut min, mut max, actual_nodes_number): (NodeT, NodeT, NodeT) = ni
                    .map(|line| match line {
                        Ok((line_number, (node_name, _))) => match node_name.parse::<NodeT>() {
                            Ok(node_id) => Ok(node_id),
                            Err(_) => Err(format!(
                                concat!(
                                    "While parsing the provided node list, ",
                                    "the node ID {:?} was found and it is not ",
                                    "possible to convert it to an integer as was requested.\n",
                                    "Specifically the line with the error is {}."
                                ),
                                node_name, line_number
                            )),
                        },
                        Err(e) => Err(e),
                    })
                    .map(|maybe_node_id: Result<NodeT>| {
                        maybe_node_id.map(|node_id| (node_id, node_id, 1))
                    })
                    .reduce(
                        || Ok((NodeT::MAX, 0 as NodeT, 0)),
                        |line1: Result<(NodeT, NodeT, NodeT)>,
                         line2: Result<(NodeT, NodeT, NodeT)>| match (
                            line1, line2,
                        ) {
                            (Ok((min1, max1, count1)), Ok((min2, max2, count2))) => {
                                Ok((min1.min(min2), max1.max(max2), count1 + count2))
                            }
                            (Err(e), _) => Err(e),
                            (_, Err(e)) => Err(e),
                        },
                    )?;

                if actual_nodes_number == 0 {
                    min = 0;
                    max = 0;
                }

                if let Some(nn) = maybe_nodes_number {
                    if nn != max - min {
                        return Err(format!(
                                "The given nodes number '{}' is different from the actual nodes number '{}'.",
                                nn, actual_nodes_number,
                            ));
                    }
                }

                (min, max)
            };
            let minimum_node_ids = minimum_node_ids.unwrap_or(min);

            if min < minimum_node_ids {
                return Err(format!(
                    concat!(
                        "The given minimum id {:?} is higher ",
                        "than the minimum id found in the iterator {:?}."
                    ),
                    minimum_node_ids, min
                ));
            }

            let mut node_type_vocabulary = node_type_parser.into_inner();
            if node_type_vocabulary.is_empty() {
                node_type_vocabulary.build()?;
            }

            Ok((
                Vocabulary::from_range(min.min(minimum_node_ids)..(max + 1)),
                None,
                Some(node_type_vocabulary),
            ))
        }
        (None, Some(ntn), true, None, _) => Ok((Vocabulary::from_range(0..ntn), None, None)),
        (None, Some(ntn), true, Some(min_val), _) => {
            let max = match min_val.checked_add(ntn){
                Some(max) => Ok(max),
                None => Err(format!(
                    concat!(
                        "To compute the maximum node type, it is needed to sum ",
                        "the minimum node type ID `{}` to the provided number of node types `{}`, ",
                        "but this would lead to an overflow, that is a value higher than the maximum U32."
                    ),
                    min_val, ntn
                ))
            }?;
            Ok((Vocabulary::from_range(min_val..max), None, None))
        }
        (None, None, true, _, _) => {
            let min = minimum_node_ids.unwrap_or(0);
            Ok((Vocabulary::from_range(min..min), None, None))
        }
        (None, Some(ntn), false, None, _) => {
            Ok((Vocabulary::with_capacity(ntn as usize), None, None))
        }
        (None, None, false, None, _) => Ok((Vocabulary::new(), None, None)),
        // TODO! improve error
        _ => unreachable!("All other cases must be explicitly handled."),
    }?;

    // Executing self-consistency check for the node type IDs
    if node_types_ids.as_ref().map_or(false, |node_types_ids| {
        nodes_vocabulary.len() != node_types_ids.len()
    }) {
        panic!(
            concat!(
                "The length of the nodes vocabulary is {}, ",
                "while the length of the node type IDs vector is {}."
            ),
            nodes_vocabulary.len(),
            node_types_ids.unwrap().len()
        );
    }

    Ok((
        nodes_vocabulary,
        NodeTypeVocabulary::from_option_structs(node_types_ids, node_types_vocabulary),
    ))
}
```


Overlapping Code:
```
ub(crate) fn parse_nodes(
nodes_iterator: Option<
ItersWrapper<
Result<(usize, (String, Option<Vec<String>>))>,
impl Iterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,
impl ParallelIterator<Item = Result<(usize, (String, Option<Vec<String>>))>>,
>,
>,
nodes_number: Option<NodeT>,
node_types_vocabulary: Option<Vocabulary<NodeTypeT>>,
node_list_is_correct: bool,
numeric_node_ids: bool,
numeric_node_list_node_type_ids: bool,
minimum_node_ids: Option<NodeT>,
skip_node_types_if_unavailable: Option<bool>,
) -> Result<(Vocabulary<NodeT>, Option<NodeTypeVocabulary>)> {
let skip_node_types_if_unavailable = skip_node_types_if_unavailable.unwrap_or(false);
if !numeric_node_ids && minimum_node_ids.is_some() {
return Err(
"Giving the minimum id is not meaningfull when numeric_ids is false.".to_string(),
);
}
if nodes_iterator.is_none() && node_types_vocabulary.is_some() {
return Err(
"Node types vocabulary was provided but no nodes iterator was given.".to_string(),
);
}
let has_node_types = node_types_vocabulary.is_some();
if !has_node_types && !skip_node_types_if_unavailable && numeric_node_list_node_type_ids {
return Err(concat!(
"The numeric node list node type IDs parameter does not make sense ",
"in the context where the node types have not been provided.\n",
"If the node types within the nodes list are numeric, simply use ",
"the numeric node types ids parameter."
)
.to_string());
}
let node_types_method = match (
has_node_types,
node_types_vocabulary
.as_ref()
.map_or(true, |x| x.is_empty()),
node_list_is_correct,
numeric_node_list_node_type_ids,
) {
(false, _, _, _) => NodeTypeParser::ignore,
(true, true, true, false) => NodeTypeParser::parse_strings_unchecked,
(true, true, false, false) => NodeTypeParser::parse_strings,
(true, false, true, false) => NodeTypeParser::get_unchecked,
(true, false, false, false) => NodeTypeParser::get,
(true, _, true, true) => NodeTypeParser::to_numeric_unchecked,
(true, _, false, true) => NodeTypeParser::to_numeric,
};
let node_types_vocabulary = node_types_vocabulary.unwrap_or(Vocabulary::new());
let mut node_type_parser = 
```
<Overlap Ratio: 0.9933774834437086>

---

--- 222 --
Question ID: 0fb12cd5cb6e2b0b0f9b7978bb0aa7b2cc922f51_9
Original Code:
```
fn save_new_todo_saves() -> Result<(), Box<dyn std::error::Error>> {
        let storage = Rc::new(MockStorage::new().with_inbox("* Inbox\n** one"));
        let mut todos = Inbox::load(storage)?;

        save_new_reminder(&mut todos, "two")?;

        assert_eq!("one\ntwo", todos.reminders());
        Ok(())
    }
```


Overlapping Code:
```
es() -> Result<(), Box<dyn std::error::Error>> {
let storage = Rc::new(MockStorage::new().with_inbox("* Inbox\n** one"));
let mut todos = Inbox::load(storage)?;
save_new_reminder(&mut todos, "two")?;
ass
```
<Overlap Ratio: 0.7490774907749077>

---

--- 223 --
Question ID: f5e40706ee9a570e9d2c950b70d658b4e594819c_1
Original Code:
```
fn unique_directive() {
    let dml = r#"
        model Test {
            id Int @id
            unique String @unique
        }
    "#;

    let schema = parse(dml);
    let test_model = schema.assert_has_model("Test");

    test_model
        .assert_has_field("id")
        .assert_base_type(&PrismaType::Int)
        .assert_is_unique(false)
        .assert_is_id(true);
    test_model
        .assert_has_field("unique")
        .assert_base_type(&PrismaType::String)
        .assert_is_unique(true);
}
```


Overlapping Code:
```
unique_directive() {
let dml = r#"
model Test {
id Int @id
unique String @unique
}
"#;
let schema = parse(dml);
let test_model = schema.assert_has_model("Test");
test_model
.assert_has_field("id")
.assert_base_type(&PrismaType::Int)
.assert_is_unique(false)
.assert_is_id(true);
test_model
.assert_has_field("unique")
.assert_base_type(&PrismaType::String)
.assert_
```
<Overlap Ratio: 0.9455958549222798>

---

--- 224 --
Question ID: 1358f340c5aec7a699671f9f4d1cb84502ffa41c_0
Original Code:
```
async fn timer_task(mut t: r2r::Timer) -> Result<(), Box<dyn std::error::Error>> {
    let mut x: i32 = 0;
    loop {
        let elapsed = t.tick().await?;
        println!(
            "timer called ({}), {}us since last call",
            x,
            elapsed.as_micros()
        );

        x += 1;
        if x == 10 {
            break;
        }
    }
    Ok(())
}
```


Overlapping Code:
```
r) -> Result<(), Box<dyn std::error::Error>> {
let mut x: i32 = 0;
loop {
let elapsed = t.tick().await?;
println!(
"timer called ({}), {}us since last call",
x,
elapsed.as_micros()
);
x += 1;
if x == 10 {

```
<Overlap Ratio: 0.7884615384615384>

---

--- 225 --
Question ID: d2378e1a488efdc112b6ce611b92832d6e0f7f7e_0
Original Code:
```
fn bindgen_test_layout___wasi_prestat_t() {
        assert_eq!(
            ::std::mem::size_of::<__wasi_prestat_t>(),
            16usize,
            concat!("Size of: ", stringify!(__wasi_prestat_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__wasi_prestat_t>(),
            8usize,
            concat!("Alignment of ", stringify!(__wasi_prestat_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).pr_type as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__wasi_prestat_t),
                "::",
                stringify!(pr_type)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).u as *const _ as usize },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__wasi_prestat_t),
                "::",
                stringify!(u)
            )
        );
    }
```


Overlapping Code:
```
 bindgen_test_layout___wasi_prestat_t() {
assert_eq!(
::std::mem::size_of::<__wasi_prestat_t>(),
16usize,
concat!("Size of: ", stringify!(__wasi_prestat_t))
);
assert_eq!(
::std::mem::align_of::<__wasi_prestat_t>(),
8usize,
concat!("Alignment of ", stringify!(__wasi_prestat_t))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).pr_type as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(__wasi_prestat_t),
"::",
stringify!(pr_type)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<__wasi_prestat_t>())).u as *const _ as usize },
8usize,
concat!(
"Offset of field: ",
stringify!(__wasi_prestat_t),
"::",
stringify!(u)
)
);
}
```
<Overlap Ratio: 0.9970014992503748>

---

--- 226 --
Question ID: b9020ae65c255fa607fb0c9e4d367c8629c19f01_4
Original Code:
```
fn builds_action_with_millisecond_delay() {
        let mut data_hash = RCHash::new();
        data_hash.insert(k("sequence"), k("ctrl+shift+t"));
        data_hash.insert(k("delay_ms"), RawConfig::Integer(20));

        let action = build_action_key_sequence(Some(&RawConfig::Hash(data_hash)))
            .ok().unwrap();

        assert_eq!(action, Action::KeySequence {
            sequence: "ctrl+shift+t".to_string(),
            count: 1,
            delay: Some(20_000)
        })
    }
```


Overlapping Code:
```
ction_with_millisecond_delay() {
let mut data_hash = RCHash::new();
data_hash.insert(k("sequence"), k("ctrl+shift+t"));
data_hash.insert(k("delay_ms"), RawConfig::Integer(20));
let action = build_action_key_sequence(Some(&RawConfig::Hash(data_hash)))
.ok().unwrap();
assert_eq!(action, Action::KeySequence {
sequence: "ctrl+shift+t".to_string(),
coun
```
<Overlap Ratio: 0.8951406649616368>

---

--- 227 --
Question ID: b3b8bea9c7e31edc3c98dd2360ee30b8729e95c9_4
Original Code:
```
fn mutate_int(val_old: u64, fmt: &IntFmt, range: Option<(u64, u64)>, align: u64) -> u64 {
    let mut mutated = false;
    let mut rng = thread_rng();
    let mut val_new = val_old;
    if rng.gen_ratio(1, 10) {
        val_new = MAGIC64.choose(&mut rng).unwrap() + (val_old & 1);
        if val_new != val_old {
            mutated = true;
        }
    }
    if rng.gen_ratio(3, 10) {
        let (val, _) = if rng.gen() {
            val_new.overflowing_sub(rng.gen_range(1..=32))
        } else {
            val_new.overflowing_add(rng.gen_range(1..=32))
        };
        val_new = val;
    }
    if !mutated || rng.gen_ratio(1, 100) {
        val_new = gen_integer(fmt.bitfield_len, range, align);
    }

    val_new
}
```


Overlapping Code:
```
 mutate_int(val_old: u64, fmt: &IntFmt, range: Option<(u64, u64)>, align: u64) -> u64 {
let mut mutated = false;
let mut rng = thread_rng();
let mut val_new = val_old;
if rng.gen_ratio(1, 10) {
val_new = MAGIC64.choose(&mut rng).unwrap() + (val_old & 1);
if val_new != val_old {
mutated = true;
}
}
if rng.gen_ratio(3, 10) {
let (val, _) = if rng.gen() {
val_new.overflowing_sub(rng.gen_range(1..=32))
} else {
val_new.overflowing_add(rng.gen_range(1..=32))
};
val_new = val;
}
if !mutated || rng.gen_ratio(1, 100) {
val_new = gen_integer(fmt.bitfiel
```
<Overlap Ratio: 0.9401709401709402>

---

--- 228 --
Question ID: 724e611de9e88635228c56c6186dfa0e2e2d1560_8
Original Code:
```
fn read_bytes_size<R: Read>(reader: &mut R, size: &usize) -> Result<Vec<u8>> {
    let mut data = vec![0; *size];
    reader.read(&mut data)?;
    Ok(data)
}
```


Overlapping Code:
```
ad>(reader: &mut R, size: &usize) -> Result<Vec<u8>> {
let mut data = vec![0; *size];
reader.read(&m
```
<Overlap Ratio: 0.6896551724137931>

---

--- 229 --
Question ID: 53efe21788eeaf56062fb222670962e5a54f5467_0
Original Code:
```
fn factory_valid_config_all() {
        let factory = CaptureBytesFactory::new(&logger());
        let mut map = Mapping::new();
        map.insert(
            Value::String("strategy".into()),
            Value::String("SUFFIX".into()),
        );
        map.insert(
            Value::String("metadataKey".into()),
            Value::String(TOKEN_KEY.into()),
        );
        map.insert(Value::String("size".into()), Value::Number(3.into()));
        map.insert(Value::String("remove".into()), Value::Bool(true));

        let filter = factory
            .create_filter(CreateFilterArgs::fixed(
                Registry::default(),
                Some(&Value::Mapping(map)),
            ))
            .unwrap();
        assert_end_strategy(filter.as_ref(), TOKEN_KEY, true);
    }
```


Overlapping Code:
```
valid_config_all() {
let factory = CaptureBytesFactory::new(&logger());
let mut map = Mapping::new();
map.insert(
Value::String("strategy".into()),
Value::String("SUFFIX".into()),
);
map.insert(
Value::String("metadataKey".into()),
Value::String(TOKEN_KEY.into()),
);
map.insert(Value::String("size".into()), Value::Number(3.into()));
map.insert(Value::String("remove".into()), Value::Bool(true));
let filter = factory
.create_filter(CreateFilterArgs::fixed(
Registry::default(),
Some(&Value::Mapping(map)),
))
.unwrap();
assert_end_strategy(filter.as_ref(), TOKEN_
```
<Overlap Ratio: 0.9592529711375212>

---

--- 230 --
Question ID: 1982e9fbc04224ee1068bd61c4efe94786b13bc0_0
Original Code:
```
fn new_chars() {
        let mut n = NormalizedString::from("élégant");
        n.nfd();
        assert_eq!(
            &n.alignments,
            &[
                (0, 1),
                (0, 1),
                (1, 2),
                (2, 3),
                (2, 3),
                (3, 4),
                (4, 5),
                (5, 6),
                (6, 7)
            ]
        );
    }
```


Overlapping Code:
```
new_chars() {
let mut n = NormalizedString::from("élégant");
n.nfd();
assert_eq!(
&n.alignments,
&[
(0, 1),
(0, 1),
(1, 2),
(2, 3),
(2, 3),
(3, 4),
(4, 5),
(5, 6),
(6, 7
```
<Overlap Ratio: 0.9388888888888889>

---

--- 231 --
Question ID: 0ce8a819ffd6928eda270bc23f40636abe313de7_16
Original Code:
```
fn should_get_valid_state_with_endpoint_correctly() {
        let expected_endpoint = WORKING_ENDPOINT;
        let expected_tx_hash = get_valid_tx_hash_h256().unwrap();
        let result = get_valid_state_with_endpoint().unwrap();
        assert!(result.tx_hash == expected_tx_hash);
        match State::get_endpoint_from_state(&result) {
            Ok(endpoint) => assert!(endpoint == expected_endpoint),
            _ => panic!("Intial w/ endpoint should have endpoint set!"),
        }
        match State::get_block_from_state(&result) {
            Err(AppError::Custom(e)) => assert!(e == get_not_in_state_err("block")),
            _ => panic!("Intial state should not have endpoint set!"),
        }
    }
```


Overlapping Code:
```
e_err("block")),
_ => panic!("Intial state should 
```
<Overlap Ratio: 0.08319467554076539>

---

--- 232 --
Question ID: f0a57e604081ba64b0a61c5d811dc6e7584082eb_0
Original Code:
```
pub fn include_template<P: AsRef<Path>>(path: P, map: &BTreeMap<String, String>) -> String {
    let mut lines = Vec::new();
    for (key, value) in map.iter() {
        lines.push(format!("#define ${} {}\n", key, value));
    }
    lines.push(format!("#include <{}>\n", path.as_ref()));
    for (key, _) in map.iter() {
        lines.push(format!("#undef ${}\n", key));
    }
    lines.join("")
}
```


Overlapping Code:
```
mplate<P: AsRef<Path>>(path: P, map: &BTreeMap<String, String>) -> String {
let mut lines = Vec::new();
for (key, value) in map.iter() {
lines.push(format!("#define ${} {}\n", key, value));
}
lines.push(format!("#include <{}>\n", path.as_ref()));
for (key, _) in map.iter() {
lines.push(format!("#und
```
<Overlap Ratio: 0.8498583569405099>

---

--- 233 --
Question ID: 147e8e1729a174bd5ca7fc70d48cfb068f55c894_0
Original Code:
```
pub fn lookup_ipv4(host: &str, port: u16) -> SocketAddr {
    use std::net::ToSocketAddrs;

    let addrs = (host, port).to_socket_addrs().unwrap();
    for addr in addrs {
        if let SocketAddr::V4(_) = addr {
            return addr;
        }
    }

    unreachable!("Cannot lookup address");
}
```


Overlapping Code:
```
 fn lookup_ipv4(host: &str, port: u16) -> SocketAddr {
use std::net::ToSocketAddrs;
let addrs = (host, port).to_socket_addrs().unwrap();
for addr in addrs {
if let SocketAddr::V4(_) = addr {
return addr;
}
}
unreachable!("Cannot lookup address")
```
<Overlap Ratio: 0.9760956175298805>

---

--- 234 --
Question ID: 3a1627c3740bd6635b55bcc8ac25be63b498c7a4_1
Original Code:
```
fn test_symbol() {
            let mut base = DaoBase::default();

            base.set_symbol("https://example.com/logo.jpg".to_string());

            let dbg_msg = format!("logo is {}", base.get_symbol());
            ink_env::debug_println!("{}", &dbg_msg );

            assert_eq!(base.get_symbol(), "https://example.com/logo.jpg");
        }
```


Overlapping Code:
```
et mut base = DaoBase::default();
base.set_symbol("https://example.com/logo.jpg".to_string());
let dbg_msg = format!("logo is {}", base.get_symbol());
ink_env::debug_println!("{}", &dbg_msg );
assert_eq!(base.get_symbol(), "https://example.com/logo.j
```
<Overlap Ratio: 0.9025270758122743>

---

--- 235 --
Question ID: 7f4f6473047865375c547654cd910ddac3edf87b_3
Original Code:
```
fn get_test_data_dir() -> String {

        let path_to_current_dir = file_system::get_current_dir()
            .ok()
            .expect("Failed read current directory.");
        let path = Path::new(&path_to_current_dir)
                                    .parent().unwrap() // libs
                                    .parent().unwrap() // conf_robber
                                    .join("test_data");

        return file_system::path_to_str(path.as_path());
    }
```


Overlapping Code:
```
tring {
let path_to_current_dir = file_system::get_current_dir()
.ok()
.expect("Failed read current directory.");
let path = Path::new(&path_to_current_dir)
.parent().unwrap() // libs
.parent().unwrap() // conf_robber
.join("test_data");
return file_system::path_to_str(p
```
<Overlap Ratio: 0.8603174603174604>

---

--- 236 --
Question ID: e4428ccbf8f776c6cb43e287fdb921f61ccea7a5_1
Original Code:
```
pub fn encrypt(i_data:String,i_key:String) -> ENCRYPTED {

    let key = GenericArray::clone_from_slice(i_key.as_bytes());
    let aead = Aes256Gcm::new(key);

    let my_data = i_data.as_bytes();

    let mut iv: [u8; 12] = [0; 12];
    let mut rng = thread_rng();
    rng.fill(&mut iv);

    let nonce = GenericArray::from_slice(&iv); // 96-bits; unique per message
    let ciphertext = aead.encrypt(nonce, my_data.as_ref()).expect("encryption failure!");

    return ENCRYPTED {
        nonce:iv.to_vec(),
        cipher:ciphertext
    };

}
```


Overlapping Code:
```
 fn encrypt(i_data:String,i_key:String) -> ENCRYPTED {
let key = GenericArray::clone_from_slice(i_key.as_bytes());
let aead = Aes256Gcm::new(key);
let my_data = i_data.as_bytes();
let mut iv: [u8; 12] = [0; 12];
let mut rng = thread_rng();
rng.fill(&mut iv);
let nonce = GenericArray::from_slice(&iv); // 96-bits; unique per message
let ciphertext = aead.encrypt(nonce, my_data.as_ref()).expect("encryption failure!");
return ENCRYPTED {
nonce:iv.to_vec(),
cipher:ciphertext
```
<Overlap Ratio: 0.983402489626556>

---

--- 237 --
Question ID: 82dd60367204e367a7d25fdd1f3bb8fcc86b01f0_0
Original Code:
```
fn main() {
    println!("cargo:rerun-if-changed=templates/dashboard.html");
    let mut f = File::create(PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("dashboard.rs"))
        .unwrap();
    f.write_all(
        format!(
            r#"
#[derive(Template)]
#[template(escape = "html", source = {:?}, ext = "html")]
struct Dashboard<'a> {{
    subnet_type: ic_registry_subnet_type::SubnetType,
    http_config: &'a ic_config::http_handler::Config,

    height: Height,
    replicated_state: &'a ic_replicated_state::replicated_state::ReplicatedState,
    canisters: &'a Vec<&'a ic_replicated_state::CanisterState>,
    cow_memory_manager_enabled: bool,
}}
    "#,
            std::fs::read_to_string("templates/dashboard.html").unwrap()
        )
        .as_bytes(),
    )
    .unwrap();
}
```


Overlapping Code:
```
in() {
println!("cargo:rerun-if-changed=templates/dashboard.html");
let mut f = File::create(PathBuf::from(std::env::var("OUT_DIR").unwrap()).join("dashboard.rs"))
.unwrap();
f.write_all(
format!(
r#"
#[derive(Template)]
#[template(escape = "html", source = {:?}, ext = "html")]
struct Dashboard<'a> {{
subnet_type: ic_registry_subnet_type::SubnetType,
http_config: &'a ic_config::http_handler::Config,
height: Height,
replicated_state: &'a ic_replicated_state::replicated_state::ReplicatedState,
canisters: &'a Vec<&'a ic_replicated_state::CanisterState>,
cow_memory_manager_enabled: bool,
}}
"#,
std::fs::read_to_string("templates/dashboard.html").
```
<Overlap Ratio: 0.937950937950938>

---

--- 238 --
Question ID: e9e65a6f4ce3164a316e8c939c6cc7aaa78b308d_4
Original Code:
```
fn next_u64(&mut self) -> u64 {
        let mut bytes = [0; 8];
        self.fill_bytes(&mut bytes);
        u64::from_ne_bytes(bytes)
    }
```


Overlapping Code:
```
fn next_u64(&mut self) -> u64 {
let mut bytes = [0; 8];
self.fill_bytes(&mu
```
<Overlap Ratio: 0.6696428571428571>

---

--- 239 --
Question ID: c525b8e5c7385c032a982a8a99fa6d9d1ff26e82_7
Original Code:
```
fn size_hint() {
        assert_eq!(Lowercase::with_slice(b"").size_hint(), (0, Some(0)));
        assert_eq!(Lowercase::with_slice(b"abc, xyz").size_hint(), (8, Some(8)));
        assert_eq!(
            Lowercase::with_slice(b"abc, \xFF\xFE, xyz").size_hint(),
            (12, Some(12))
        );
        assert_eq!(
            Lowercase::with_slice("�".as_bytes()).size_hint(),
            (3, Some(3))
        );
        assert_eq!(
            Lowercase::with_slice("Έτος".as_bytes()).size_hint(),
            (8, Some(8))
        );
        assert_eq!(
            Lowercase::with_slice("ZȺȾ".as_bytes()).size_hint(),
            (5, Some(5))
        );

        let mut utf8_with_invalid_bytes = b"\xFF\xFE".to_vec();
        utf8_with_invalid_bytes.extend_from_slice("Έτος".as_bytes());
        assert_eq!(
            Lowercase::with_slice(&utf8_with_invalid_bytes).size_hint(),
            (10, Some(10))
        );
    }
```


Overlapping Code:
```
sert_eq!(Lowercase::with_slice(b"").size_hint(), (0, Some(0)));
assert_eq!(Lowercase::with_slice(b"abc, xyz").size_hint(), (8, Some(8)));
assert_eq!(
Lowercase::with_slice(b"abc, \xFF\xFE, xyz").size_hint(),
(12, Some(12))
);
assert_eq!(
Lowercase::with_slice("�".as_bytes()).size_hint(),
(3, Some(3))
);
assert_eq!(
Lowercase::with_slice("Έτος".as_bytes()).size_hint(),
(8, Some(8))
);
assert_eq!(
Lowercase::with_slice("ZȺȾ".as_bytes()).size_hint(),
(5, Some(5))
);
let mut utf8_with_invalid_bytes = b"\xFF\xFE".to_vec();
utf8_with_invalid_bytes.extend_from_slice("Έτος".as_bytes());
assert_eq!(
Lowercase::with_slice(&utf8_with_invalid_bytes).size_hint(),
(10, Some(10))

```
<Overlap Ratio: 0.9670014347202296>

---

--- 240 --
Question ID: 611e3b67dfe2fd2e8a97b87da3f14ed2843d3b20_5
Original Code:
```
fn test_23() {
        let input = String::from(
            r#"         A
         A
  #######.#########
  #######.........#
  #######.#######.#
  #######.#######.#
  #######.#######.#
  #####  B    ###.#
BC...##  C    ###.#
  ##.##       ###.#
  ##...DE  F  ###.#
  #####    G  ###.#
  #########.#####.#
DE..#######...###.#
  #.#########.###.#
FG..#########.....#
  ###########.#####
             Z
             Z       "#,
        );
        let maze = get_maze(&input);
        assert_eq!(23, breadth_first_search(&maze));
    }
```


Overlapping Code:
```
put = String::from(
r#" A
A
#######.#########
#######.........#
#######.#######.#
#######.#######.#
#######.#######.#
##### B ###.#
BC...## C ###.#
##.## ###.#
##...DE F ###.#
##### G ###.#
#########.#####.#
DE..#######...###.#
#.#########.###.#
FG..#########.....#
###########.#####
Z
Z "#,
);
let maze = get_maze(&input);
assert_eq!(23, breadth_first_search(
```
<Overlap Ratio: 0.9207161125319693>

---

--- 241 --
Question ID: 100dfcea2b00c219f692e497961c37bec7d1e394_5
Original Code:
```
fn get_parameter(&self, name: &str) -> Option<Parameter> {
        let lock = internal::get_entity(self);
        let entity = lock.read().unwrap();
        entity.get_parameter(name)
    }
```


Overlapping Code:
```
fn get_parameter(&self, name: &str) -> Option<Parameter> {
let lock = internal::get_entity(self);
let entity = lock.read().unwrap();
enti
```
<Overlap Ratio: 0.8509316770186336>

---

--- 242 --
Question ID: a0ea26127e38f9f4f2dcaa48bb5cc17f930e4fef_9
Original Code:
```
fn formatted_with_crop_2() {
        let stop_words = fst::Set::default();
        let mut config = AnalyzerConfig::default();
        config.stop_words(&stop_words);
        let analyzer = Analyzer::new(config);
        let formatter = Formatter::new(&analyzer, (String::from("<em>"), String::from("</em>")));

        let mut fields = FieldsIdsMap::new();
        let title = fields.insert("title").unwrap();
        let author = fields.insert("author").unwrap();

        let mut buf = Vec::new();
        let mut obkv = obkv::KvWriter::new(&mut buf);
        obkv.insert(
            title,
            Value::String("Harry Potter and the Half-Blood Prince".into())
                .to_string()
                .as_bytes(),
        )
        .unwrap();
        obkv.finish().unwrap();
        obkv = obkv::KvWriter::new(&mut buf);
        obkv.insert(
            author,
            Value::String("J. K. Rowling".into()).to_string().as_bytes(),
        )
        .unwrap();
        obkv.finish().unwrap();

        let obkv = obkv::KvReader::new(&buf);

        let mut formatted_options = BTreeMap::new();
        formatted_options.insert(
            title,
            FormatOptions {
                highlight: false,
                crop: Some(2),
            },
        );
        formatted_options.insert(
            author,
            FormatOptions {
                highlight: false,
                crop: None,
            },
        );

        let mut matching_words = BTreeMap::new();
        matching_words.insert("potter", Some(6));

        let value = format_fields(
            &fields,
            obkv,
            &formatter,
            &matching_words,
            &formatted_options,
        )
        .unwrap();

        assert_eq!(value["title"], "Harry Potter and");
        assert_eq!(value["author"], "J. K. Rowling");
    }
```


Overlapping Code:
```
ted_with_crop_2() {
let stop_words = fst::Set::default();
let mut config = AnalyzerConfig::default();
config.stop_words(&stop_words);
let analyzer = Analyzer::new(config);
let formatter = Formatter::new(&analyzer, (String::from("<em>"), String::from("</em>")));
let mut fields = FieldsIdsMap::new();
let title = fields.insert("title").unwrap();
let author = fields.insert("author").unwrap();
let mut buf = Vec::new();
let mut obkv = obkv::KvWriter::new(&mut buf);
obkv.insert(
title,
Value::String("Harry Potter and the Half-Blood Prince".into())
.to_string()
.as_bytes(),
)
.unwrap();
obkv.finish().unwrap();
obkv = obkv::KvWriter::new(&mut buf);
obkv.insert(
author,
Value::String(to_string().as_bytes(),
)
.unwrap();
obkv.finish().unwrap();
let obkv = obkv::KvReader::new(&buf);
let mut formatted_options = BTreeMap::new();
formatted_options.insert(
title,
FormatOptions {
highlight: false,
crop: Some(2),
},
);
formatted_options.insert(
author,
FormatOptions {
highlight: false,
crop: None,
},
);
let mut matching_words = BTreeMap::new();
matching_words.insert("potter", Some(6));
let value = format_fields(
&fields,
obkv,
&formatter,
&matching_words,
&formatted_options,
)
.unwrap();
assert_eq!(value["title"], "Harry Potter and
```
<Overlap Ratio: 0.9362186788154897>

---

--- 243 --
Question ID: c2549b3aa9691b4954e9b0646df9c09e9f610afa_0
Original Code:
```
async fn main() -> Result<(), Error> {
    fuchsia_syslog::init_with_tags(&["overnet_debug_proxy"])?;

    let mut fs = ServiceFs::new_local();
    let mut svc_dir = fs.dir("svc");
    svc_dir.add_fidl_service(IncomingService::NewDeviceProxy);
    fs.take_and_serve_directory_handle()?;

    let root_resource =
        fuchsia_component::client::connect_to_service::<RootResourceMarker>()?.get().await?;

    let (tx_write, rx_write) = mpsc::channel(0);
    let (tx_read, rx_read) = mpsc::channel(0);

    let reader = &Mutex::new(Some(rx_read));

    let r = future::try_join3(
        Task::blocking(reader_task(tx_read, root_resource)),
        Task::blocking(writer_task(rx_write)),
        async move {
            fs.for_each_concurrent(None, move |IncomingService::NewDeviceProxy(requests)| {
                let tx_write = tx_write.clone();
                requests.for_each_concurrent(None, move |request| {
                    let tx_write = tx_write.clone();
                    async move {
                        match request {
                            Ok(request) => {
                                if let Some(mut r) = reader.lock().await.take() {
                                    run_safe(request, &mut tx_write.clone(), &mut r).await;
                                    *reader.lock().await = Some(r);
                                } else {
                                    log::warn!("Failed to acquire root resource (already taken)")
                                }
                            }
                            Err(e) => log::warn!("Bad incoming request: {:?}", e),
                        }
                    }
                })
            })
            .await;
            Ok(())
        },
    )
    .map_ok(drop)
    .await;

    if let Err(e) = &r {
        log::error!("main loop failed: {:?}", e);
    }

    r
}
```


Overlapping Code:
```
async fn main() -> Result<(), Error> {
fuchsia_syslog::init_with_tags(&["overnet_debug_proxy"])?;
let mut fs = ServiceFs::new_local();
let mut svc_dir = fs.dir("svc");
svc_dir.add_fidl_service(IncomingService::NewDeviceProxy);
fs.take_and_serve_directory_handle()?;
let root_resource =
fuchsia_component::client::connect_to_service::<RootResourceMarker>()?.get().await?;
let (tx_write, rx_write) = mpsc::channel(0);
let (tx_read, rx_read) = mpsc::channel(0);
let reader = &Mutex::new(Some(rx_read));
let r = future::try_join3(
Task::blocking(reader_task(tx_read, root_resource)),
Task::blocking(writer_task(rx_write)),
async move {
fs.for_each_concurrent(None, move |IncomingService::NewDeviceProxy(requests)| {
let tx_write = tx_write.clone();
requests.for_each_concurrent(None, move |request| {
let tx_write = tx_write.clone();
async move {
match request {
Ok(request) => {
if let Some(mut r) = reader.lock().await.take() {
run_safe(request, &mut tx_write.clone(), &mut r).await;
*reader.lock().await = Some(r);
} else {
log::warn!("Failed to acquire root resource (already taken)")
}
}
Err(e) => log::warn!("Bad incoming request: {:?}", e),
}
}
})
})
.await;
Ok(())
},
)
.map_ok(drop)
.await;
if let Err(e) = &r {
log::error!("ma
```
<Overlap Ratio: 0.9746835443037974>

---

--- 244 --
Question ID: 046dd0113b44fa2be30ea213dbd7e7a01b05830f_0
Original Code:
```
fn test_world_gen_default() {
    let config = WorldConfig::default();
    let world = World::generate(config).unwrap();
    // Default config uses a random seed each time, so we want to log the
    // config to make sure we can reproduce the failure
    assert_eq!(
        world.tiles().len(),
        30301,
        "Default config failed: {:?}",
        config
    );
}
```


Overlapping Code:
```
ig = WorldConfig::default();
let world = World::generate(config).unwrap();
// Default config uses a random seed each time, so we want to log the
// config to make sure we can reproduce the failure
assert_eq!(
world.tiles().len(),
30301,
"Default conf
```
<Overlap Ratio: 0.7886435331230284>

---

--- 245 --
Question ID: 9651cd5dfbaf8dca11f6c123dfa4ce82d53b80bf_0
Original Code:
```
fn get_combination(numbers: &Vec<u32>, length: usize) -> u32 {
    for combination in numbers.iter().combinations(length) {
        if combination.iter().map(|number| *number).sum::<u32>() == 2020 {
            return combination.iter().fold(1, |acc, &number| acc * (*number));
        }
    };
    panic!("Numbers not found");
}
```


Overlapping Code:
```
mbers: &Vec<u32>, length: usize) -> u32 {
for combination in numbers.iter().combinations(length) {
if combination.iter().map(|number| *number).sum::<u32>() == 2020 {
return combination.iter().fold(1, |acc, &number| acc * (*number));
}
};
panic!("Numb
```
<Overlap Ratio: 0.8650519031141869>

---

--- 246 --
Question ID: 9a262f90165c22522bcd1431d381db509df51a6e_1
Original Code:
```
fn parse_operation_definition(
    pair: Pair<Rule>,
    pc: &mut PositionCalculator,
) -> Result<Positioned<OperationDefinition>> {
    debug_assert_eq!(pair.as_rule(), Rule::operation_definition);

    let pos = pc.step(&pair);
    let pair = exactly_one(pair.into_inner());
    Ok(Positioned::new(
        match pair.as_rule() {
            Rule::named_operation_definition => parse_named_operation_definition(pair, pc)?,
            Rule::selection_set => OperationDefinition {
                ty: OperationType::Query,
                name: None,
                variable_definitions: Vec::new(),
                directives: Vec::new(),
                selection_set: parse_selection_set(pair, pc)?,
            },
            _ => unreachable!(),
        },
        pos,
    ))
}
```


Overlapping Code:
```
efinition(
pair: Pair<Rule>,
pc: &mut PositionCalculator,
) -> Result<Positioned<OperationDefinition>> {
debug_assert_eq!(pair.as_rule(), Rule::operation_definition);
let pos = pc.step(&pair);
let pair = exactly_one(pair.into_inner());
Ok(Positioned::new(
match pair.as_rule() {
Rule::named_operation_definition => parse_named_operation_definition(pair, pc)?,
Rule::selection_set => OperationDefinition {
ty: OperationType::Query,
name: None,
variable_definitions: Vec::new(),
directives: Vec::new(),
selection_set: parse_selection_set(pair, pc)?,
},
_ => unreac
```
<Overlap Ratio: 0.9304635761589404>

---

--- 247 --
Question ID: 27a4d1fda92c2326af29d430ae646027e5f1e064_8
Original Code:
```
fn sorting() {
        let elems = vec!['a', 'b', 'e', 'g', 'f'];
        let perm = permutation::sort(&elems[..]);
        println!("{:?}", perm);
        assert_eq!(perm, Permutation::from_vec(vec![0, 1, 2, 4, 3]));
    }
```


Overlapping Code:
```
 elems = vec!['a', 'b', 'e', 'g', 'f'];
let perm = permutation::sort(&elems[..]);
println!("{:?}", perm);
assert_eq!(perm, Permutation::from_vec(vec![
```
<Overlap Ratio: 0.8021390374331551>

---

--- 248 --
Question ID: 687a8d4fd76d113071183b6338c2a949aec154a4_65
Original Code:
```
fn test_opcode_0X85() {
    let mem = Rc::new(RefCell::new(FakeMemory::new()));
    let reg = Register::new_from_debug_string(
        "register { a: 13, b: 6, c: 0, d: 0, e: 0, f: 0, h: 156, l: 19, pc: 7634, sp: 50100 }",
    );
    mem.borrow_mut().fake_data(7634, 111);
    let mut cpu = CPU::new(mem, false);
    cpu.set_reg(reg);
    cpu.op_0x85();
    assert_eq!(
        format!("{:?}", cpu.get_reg_snapshot()).to_lowercase(),
        "register { a: 32, b: 6, c: 0, d: 0, e: 0, f: 32, h: 156, l: 19, pc: 7634, sp: 50100 }"
    );
}
```


Overlapping Code:
```
e_0X85() {
let mem = Rc::new(RefCell::new(FakeMemory::new()));
let reg = Register::new_from_debug_string(
"register { a: 13, b: 6, c: 0, d: 0, e: 0, f: 0, h: 156, l: 19, pc: 7634, sp: 50100 }",
);
mem.borrow_mut().fake_data(7634, 111);
let mut cpu = CPU::new(mem, false);
cpu.set_reg(reg);
cpu.op_0x85();
assert_eq!(
format!("{:?}", cpu.get_reg_snapshot()).to_lowercase(),
"register { a: 32, b: 6, c: 0, d: 0, e: 0, f: 32, h: 156, l: 19, pc: 7634, sp
```
<Overlap Ratio: 0.9414225941422594>

---

--- 249 --
Question ID: 81dd3e7ece39bfa1cbf6f7529d465808da1700bf_11
Original Code:
```
pub async fn generate_address(
    snapshot_path: &Path,
    account_index: usize,
    address_index: usize,
    internal: bool,
) -> Result<Address> {
    let mut runtime = actor_runtime().lock().await;
    check_snapshot(&mut runtime, &snapshot_path, None).await?;
    load_private_data_actor(&mut runtime, snapshot_path, None).await?;

    let chain = Chain::from_u32_hardened(vec![
        44,
        4218,
        account_index.try_into()?,
        internal as u32,
        address_index.try_into()?,
    ]);

    let derived_location = derive(&mut runtime, chain).await?;
    let public_key = get_public_key(&mut runtime, derived_location).await?;

    // Hash the public key to get the address
    let hash = Blake2b256::digest(&public_key);

    let ed25519_address = Ed25519Address::new(hash.try_into().unwrap());
    let address = Address::Ed25519(ed25519_address);
    Ok(address)
}
```


Overlapping Code:
```
shot_path: &Path,
account_index: usize,
address_index: usize,
internal: bool,
) -> Result<Address> {
let mut runtime = actor_runtime().lock().await;
check_snapshot(&mut runtime, &snapshot_path, None).await?;
load_private_data_actor(&mut runtime, snapshot_path, None).await?;
let chain = Chain::from_u32_hardened(vec![
44,
4218,
account_index.try_into()?,
internal as u32,
address_index.try_into()?,
]);
let derived_location = derive(&mut runtime, chain).await?;
let public_key = get_public_key(&mut runtime, derived_location).await?;
// Hash the public key to get the address
let hash = Blake2b256::digest(&public_key);
let ed25519_address = Ed25519Address::new(hash.try_into().unwrap());
let address = Address::Ed25519(ed25519_address);
Ok(address)

```
<Overlap Ratio: 0.9541984732824428>

---

--- 250 --
Question ID: 9402ec57e65b4be9eb02b08d16ec4f1cdad4e394_1
Original Code:
```
pub(crate) fn validate_buildid(s: &str) -> Result<()> {
    // None of this supports non-ASCII
    if let Some(c) = s.chars().find(|c| !c.is_ascii()) {
        bail!("Invalid non-ASCII character {} in buildid", c);
    }
    // Validating the first character is alphanumeric shuts down potential
    // special characters like `-` and `.` etc.
    match s.chars().next() {
        Some(c) => {
            if !c.is_ascii_alphanumeric() {
                bail!("Invalid alphanumeric character {} in buildid", c);
            }
        }
        None => {
            bail!("Invalid empty buildid");
        }
    }
    Ok(())
}
```


Overlapping Code:
```
crate) fn validate_buildid(s: &str) -> Result<()> {
// None of this supports non-ASCII
if let Some(c) = s.chars().find(|c| !c.is_ascii()) {
bail!("Invalid non-ASCII character {} in buildid", c);
}
// Validating the first character is alphanumeric shuts down potential
// special characters like `-` and `.` etc.
match s.chars().next() {
Some(c) => {
if !c.is_ascii_alphanumeric() {
bail!("Invalid alphanumeric character {} in buildid", c);
}
}
None =
```
<Overlap Ratio: 0.896414342629482>

---

--- 251 --
Question ID: 647b877cb76d8d9dc71190b5be30d2b7f7d9acfd_21
Original Code:
```
fn test_invalid_sub_rr() {
    // FIXME: Is this only testing that at least one of the statements panics?
    lower(&[ SubRR(RAX, EAX) ]);
    lower(&[ SubRR(EAX, AH) ]);
  }
```


Overlapping Code:
```
valid_sub_rr() {
// FIXME: Is this only testing that at least one of the statements panics?
lower(&[ SubRR(RAX, EAX) ]);
lower(&[ SubRR(EAX, AH) ]);
}
```
<Overlap Ratio: 0.9375>

---

--- 252 --
Question ID: 0b8f38ea404908995727b6433d03b872e26a724a_3
Original Code:
```
fn it_works_with_trinary() {
    let base3 = BaseCustom::<u8>::new(b"ABC");
    assert_eq!(base3.decimal(b"ABC"), 5);
    assert_eq!(base3.gen(123), b"BBBCA");
  }
```


Overlapping Code:
```
base3 = BaseCustom::<u8>::new(b"ABC");
assert_eq!(base3.decimal(b"ABC"), 5);
assert_eq!(base3.gen(12
```
<Overlap Ratio: 0.6711409395973155>

---

--- 253 --
Question ID: c19755dbc5444266c8a6d06099cb2cb48be742fb_0
Original Code:
```
fn init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {
        ctx.device.RCC.ahbenr.modify(|_, w| w.dma1en().enabled());
        let mut rcc = ctx.device.RCC.constrain();
        let mut flash = ctx.device.FLASH.constrain();
        let clocks = rcc.cfgr.freeze(&mut flash.acr);
        let mut gpioc = ctx.device.GPIOC.split(&mut rcc.ahb);
        let pins = (
            gpioc
                .pc4
                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),
            gpioc
                .pc5
                .into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),
        );
        let serial = Serial::new(ctx.device.USART1, pins, 9600.Bd(), clocks, &mut rcc.apb2);
        let (tx, rx) = serial.split();
        let mut dma1 = ctx.device.DMA1.split(&mut rcc.ahb);
        dma1.ch4.listen(Event::TransferComplete);
        dma1.ch5.listen(Event::TransferComplete);
        (
            Shared {
                send: Some(TxTransfer::Idle(ctx.local.tx_buf, dma1.ch4, tx)),
            },
            Local {
                recv: Some(rx.read_exact(ctx.local.rx_buf, dma1.ch5)),
            },
            init::Monotonics(),
        )
    }
```


Overlapping Code:
```
 init(ctx: init::Context) -> (Shared, Local, init::Monotonics) {
ctx.device.RCC.ahbenr.modify(|_, w| w.dma1en().enabled());
let mut rcc = ctx.device.RCC.constrain();
let mut flash = ctx.device.FLASH.constrain();
let clocks = rcc.cfgr.freeze(&mut flash.acr);
let mut gpioc = ctx.device.GPIOC.split(&mut rcc.ahb);
let pins = (
gpioc
.pc4
.into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),
gpioc
.pc5
.into_af7_push_pull(&mut gpioc.moder, &mut gpioc.otyper, &mut gpioc.afrl),
);
let serial = Serial::new(ctx.device.USART1, pins, 9600.Bd(), clocks, &mut rcc.apb2);
let (tx, rx) = serial.split();
let mut dma1 = ctx.device.DMA1.split(&mut rcc.ahb);
dma1.ch4.listen(Event::TransferComplete);
dma1.ch5.listen(Event::TransferComplete);
(
Shared {
send: Some(TxTransfer::Idle(ctx.local.tx_buf, dma1.ch4, tx)),
},
Local {
recv: Some(rx.read_exact(ctx.local.rx_buf, dma1.ch5)),

```
<Overlap Ratio: 0.969532100108814>

---

--- 254 --
Question ID: 2c11d78663f532c49fe25cdcfe77a27a391aa51d_6
Original Code:
```
fn test_next_simplest_language() {
        let mut rng = thread_rng();
        let raw = raw::Language {
            entries: vec![
                prod_symbols("A", &["hello", "space", "world"]),
                prod_literals("hello", &["hello"]),
                prod_literals("space", &[" "]),
                prod_literals("world", &["world"]),
            ],
        };
        let language = Language::from_raw(&raw).unwrap();
        let a = language.token_by_name("A").unwrap();
        let r = language.expand(&[a], &mut rng).unwrap();
        assert_eq!("hello world", r);
    }
```


Overlapping Code:
```
t_language() {
let mut rng = thread_rng();
let raw = raw::Language {
entries: vec![
prod_symbols("A", &["hello", "space", "world"]),
prod_literals("hello", &["hello"]),
prod_literals("space", &[" "]),
prod_literals("world", &["world"]),
],
};
let language = Language::from_raw(&raw).unwrap();
let a = language.token_by_name("A").unwrap();
let r = language.expand(&[a], &mut rng).
```
<Overlap Ratio: 0.8613636363636363>

---

--- 255 --
Question ID: 4f7a0731bc428da40525927d8abddf150731ea59_46
Original Code:
```
fn succeeds_with_escape_option(test_cases: Vec<&str>, expected_output: &str) {
            let regexp = RegExpBuilder::from(&test_cases)
                .with_conversion_of(&[Feature::NonDigit])
                .with_escaping_of_non_ascii_chars(false)
                .build();
            test_if_regexp_is_correct(regexp, expected_output, &test_cases);
            test_if_regexp_matches_test_cases(expected_output, test_cases);
        }
```


Overlapping Code:
```
n succeeds_with_escape_option(test_cases: Vec<&str>, expected_output: &str) {
let regexp = RegExpBuilder::from(&test_cases)
.with_conversion_of(&[Feature::NonDigit])
.with_escaping_of_non_ascii_chars(false)
.build();
test_if_regexp_is_correct(regexp, expected_output, &test_cases);
test_if_regexp_matches_test_cases(expected_output, test_cases);
}
```
<Overlap Ratio: 0.9971264367816092>

---

--- 256 --
Question ID: 4740afff127d4d61ddf21744fc6fd03f091510bc_5
Original Code:
```
fn parse_paint_1() {
    let doc = Document::from_str(
"<svg xmlns='http://www.w3.org/2000/svg'>
    <radialGradient id='rg1'/>
    <rect fill='url(#rg1)'/>
</svg>").unwrap();

    let child = doc.root().first_child().unwrap();
    let rg = child.children().nth(0).unwrap();
    let rect = child.children().nth(1).unwrap();

    assert_eq!(rg.is_used(), true);
    assert_eq!(rect.attributes().get_value(AId::Fill).unwrap(), &AttributeValue::Paint(rg, None));
}
```


Overlapping Code:
```
 {
let doc = Document::from_str(
"<svg xmlns='http://www.w3.org/2000/svg'>
<radialGradient id='rg1'/>
<rect fill='url(#rg1)'/>
</svg>").unwrap();
let child = doc.root().first_child().unwrap();
let rg = child.children().nth(0).unwrap();
let rect = child.children().nth(1).unwrap();
assert_eq!(rg.is_used(), true);
assert_eq!(rect.attributes().get_value(AId::Fill).unwrap(), &AttributeValue::Paint(rg, 
```
<Overlap Ratio: 0.936768149882904>

---

--- 257 --
Question ID: 984aeded2839855438f53fc26fe6fdf1ef4b8e08_0
Original Code:
```
pub fn parse(file: &str) -> Makefile {
    // rule line with deps
    // https://www.gnu.org/software/make/manual/html_node/Rule-Syntax.html#Rule-Syntax
    let rule = Regex::new("^([a-zA-Z-_]+):(.*)?").unwrap();
    // rule body lines, intended by tabs
    let rule_body = Regex::new("^\t+(.*)").unwrap();

    // http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles
    // variables come in the forms =, :=, ::=, +=, and ?=
    let var = Regex::new("^([a-zA-Z-_]+)\\s*(=|:=|::=|\\+=|\\?=)(.*)").unwrap();

    // special .-prefixed vars
    let special_var = Regex::new("^\\.([a-zA-Z-_]+):(.*)").unwrap();

    let mut makefile = Makefile::new();
    for (i, line) in file.lines().filter(|l| !l.is_empty() && !l.starts_with('#')).enumerate() {
        if let Some(rule) = rule.captures(line) {
            if let Some(target) = rule.at(1) {
                let deps = rule.at(2)
                    .map(|d| {
                        d.trim()
                            .split(" ")
                            .filter(|d| !d.is_empty())
                            .map(|d| d.to_owned())
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or(vec![]);
                makefile.add_rule(Rule {
                    target: target.to_owned(),
                    dependencies: deps,
                    line: i,
                    ..Default::default()
                })
            }
        } else if let Some(body) = rule_body.captures(line) {
            if let Some(bod) = body.at(1) {
                makefile.rule_line(bod.trim().to_owned());
            }
        } else if let Some(var) = var.captures(line) {
            if let (Some(k), Some(b), Some(v)) = (var.at(1), var.at(2), var.at(3)) {
                let (key, value) = (k.to_owned(), v.trim().to_owned());
                let v = match b {
                        "=" => Var::Eq(key, value, i),
                        ":=" => Var::ColonEq(key, value, i),
                        "::=" => Var::DoubleColonEq(key, value, i),
                        "+=" => Var::PlusEq(key, value, i),
                        "?=" => Var::QuestionEq(key, value, i),
                        _ => unreachable!()
                };
                makefile.add_var(v);
            }
        } else if let Some(var) = special_var.captures(line) {
            if let (Some(k), Some(v)) = (var.at(1), var.at(2)) {
                let v = Var::Special(k.to_owned(), v.trim().to_owned(), i);
                makefile.add_var(v);
            }
        } else {
            println!("unparsed line! '{}''", line)
        }
    }
    makefile
}
```


Overlapping Code:
```
) -> Makefile {
// rule line with deps
// https://www.gnu.org/software/make/manual/html_node/Rule-Syntax.html#Rule-Syntax
let rule = Regex::new("^([a-zA-Z-_]+):(.*)?").unwrap();
// rule body lines, intended by tabs
let rule_body = Regex::new("^\t+(.*)").unwrap();
// http://www.gnu.org/software/make/manual/make.html#Reading-Makefiles
// variables come in the forms =, :=, ::=, +=, and ?=
let var = Regex::new("^([a-zA-Z-_]+)\\s*(=|:=|::=|\\+=|\\?=)(.*)").unwrap();
// special .-prefixed vars
let special_var = Regex::new("^\\.([a-zA-Z-_]+):(.*)").unwrap();
let mut makefile = Makefile::new();
for (i, line) in file.lines().filter(|l| !l.is_empty() && !l.starts_with('#')).enumerate() {
if let Some(rule) = rule.captures(line) {
if let Some(target) = rule.at(1) {
let deps = rule.at(2)
.map(|d| {
d.trim()
.split(" ")
.filter(|d| !d.is_empty())
.map(|d| d.to_owned())
.collect::<Vec<_>>()
})
.unwrap_or(vec![]);
makefile.add_rule(Rule {
target: target.to_owned(),
dependencies: deps,
line: i,
..Default::default()
})
}
} else if let Some(body) = rule_body.captures(line) {
if let Some(bod) = body.at(1) {
makefile.rule_line(bod.trim().to_owned());
}
} else if let Some(var) = var.captures(line) {
if let (Some(k), Some(b), Some(v)) = (var.at(1), var.at(2), var.at(3)) {
let (key, value) = (k.to_owned(), v.trim().to_owned());
let v = match b {
"=" => Var::Eq(key, value, i),
":=" => Var::ColonEq(key, value, i),
"::=" => Var::DoubleColonEq(key, value, i),
"+=" => Var::PlusEq(key, value, i),
"?=" => Var::QuestionEq(key, value, i),
_ => unreachable!()
};
makefile.add_var(v);
}
} else if let Some(var) = special_var.captures(line) {
if let (Some(k), Some(v)) = (var.at(1), var.at(2)) {
let v = Var::S
```
<Overlap Ratio: 0.9615384615384616>

---

--- 258 --
Question ID: 1cdc03430c8bdba3a976d3fa3ba603e52359b910_5
Original Code:
```
fn gen_tuple_n_impl_size(ctx: &Ctx, size: usize, item_names: &[Ident]) -> TokenStream {
    let tuple_name = format_ident!("Tuple{}", size);

    let nts = &ctx.nts[0..size];

    let tks = quote! {
        pub trait #tuple_name: Tuple {
            #(type #item_names;)*
        }
        impl<#(#nts),*> #tuple_name for (#(#nts),*) {
            #(type #item_names = #nts;)*
        }
    };
    tks
}
```


Overlapping Code:
```
ple_n_impl_size(ctx: &Ctx, size: usize, item_names: &[Ident]) -> TokenStream {
let tuple_name = format_ident!("Tuple{}", size);
let nts = &ctx.nts[0..size];
let tks = quote! {
pub trait #tuple_name: Tuple {
#(type #item_names;)*
}
impl<#(#nts),*> #tuple_name for (#(#nts),*) {
#(type #item_names = #n
```
<Overlap Ratio: 0.9230769230769231>

---

--- 259 --
Question ID: c3ee27846fb65d6ca3f263da3cddd453c14728a6_841
Original Code:
```
fn test_word_automatic() {
    let regex = generate_regex("automatic");
    let matcher = Regex::new(&regex).unwrap();
    assert!(matcher.is_match("অটোমেটিক"));
}
```


Overlapping Code:
```
) {
let regex = generate_regex("automatic");
let matcher = Regex::new(&regex).unwrap();
assert!(matcher.is_match("
```
<Overlap Ratio: 0.7549668874172185>

---

--- 260 --
Question ID: a0fe8c3db7140816c5ddb7578ab0a6163d191027_2
Original Code:
```
fn part_1(input: &TParsed) -> usize {
  let mut i = input.to_owned();
  i.retain(|(f, t)| f.x == t.x || f.y == t.y);
  count_overlapping(&i)
}
```


Overlapping Code:
```
 = input.to_owned();
i.retain(|(f, t)| f.x == t.x 
```
<Overlap Ratio: 0.36764705882352944>

---

--- 261 --
Question ID: 8655321cf0a47b83e7cd094735b141fad56c379d_2
Original Code:
```
pub fn mint(account: &AccountInfo) -> Result<Pubkey, ProgramError> {
        let bytes = account.try_borrow_data()?;
        let mut mint_bytes = [0u8; 32];
        mint_bytes.copy_from_slice(&bytes[..32]);
        Ok(Pubkey::new_from_array(mint_bytes))
    }
```


Overlapping Code:
```
account: &AccountInfo) -> Result<Pubkey, ProgramError> {
let bytes = account.try_borrow_data()?;
let mut mint_bytes = [0u8; 32];
mint_bytes.copy_from_slice(&bytes[..32]);
Ok(Pubke
```
<Overlap Ratio: 0.8026905829596412>

---

--- 262 --
Question ID: f1fd5c7f962441840dc0f5f7e99356acf6e5c0ef_7
Original Code:
```
pub fn print_argv() -> Result<(), ()> {
	let args = env::args();

	// Prints each argument on a separate line
	for (i, argument) in args.enumerate() {
		println!("argument[{}] = {}", i, argument);
	}

	Ok(())
}
```


Overlapping Code:
```
print_argv() -> Result<(), ()> {
let args = env::args();
// Prints each argument on a separate line
for (i, argument) in args.enumerate() {
println!("argument[{}] = {}", i, argument);
}
Ok(()
```
<Overlap Ratio: 0.9502487562189055>

---

--- 263 --
Question ID: a838f1775648dcbbe84dc17020b4c9c9203a7257_0
Original Code:
```
fn center(val: &String, width: usize) -> String {
    if val.len() >= width {
        return val.to_owned();
    }
    let diff = width - val.len();
    let end = diff / 2;
    let start = diff - end;
    [" ".repeat(start), val.to_owned(), " ".repeat(end)]
        .concat()
        .to_owned()
}
```


Overlapping Code:
```
 String {
if val.len() >= width {
return val.to_owned();
}
let diff = width - val.len();
let end = diff / 2;
let start = diff - end;
[" ".repeat(start), val.to_owned(), " ".repeat(end)]
.concat()
.to_
```
<Overlap Ratio: 0.8032128514056225>

---

--- 264 --
Question ID: 7614b7ee5b1ee1087b369fb9593e3e759b518639_11
Original Code:
```
fn rpc_protocol() {
    ::libra_logger::try_init_for_testing();

    let listener_peer_id = PeerId::random();
    let dialer_peer_id = PeerId::random();
    let protocol_id = b"/get_blocks/1.0.0";
    let req_data = b"hello";
    let res_data = b"goodbye";

    let mut rt = Runtime::new().unwrap();

    let (dialer_substream, listener_substream) = MemorySocket::new_pair();

    // Set up the dialer Rpc protocol actor
    let (mut dialer_rpc_tx, dialer_rpc_rx) = channel::new_test(8);
    let (_, dialer_peer_notifs_rx) = channel::new_test(8);
    let (dialer_peer_reqs_tx, mut dialer_peer_reqs_rx) = channel::new_test(8);
    let dialer_peer_reqs_tx = PeerHandle::new(
        listener_peer_id,
        Multiaddr::from_str("/ip6/::1/tcp/8080").unwrap(),
        dialer_peer_reqs_tx,
    );
    let (rpc_handler_tx, _) = channel::new_test(8);
    let dialer_rpc = Rpc::new(
        rt.handle().clone(),
        dialer_peer_reqs_tx,
        dialer_rpc_rx,
        dialer_peer_notifs_rx,
        rpc_handler_tx,
        Duration::from_millis(500),
        10,
        10,
    );

    // Fake the dialer NetworkProvider
    let f_dialer_network = async move {
        let (res_tx, res_rx) = oneshot::channel();

        let req = OutboundRpcRequest {
            protocol: ProtocolId::from_static(protocol_id),
            data: Bytes::from_static(req_data),
            res_tx,
            timeout: Duration::from_secs(1),
        };

        // Tell Rpc to send an rpc request
        dialer_rpc_tx.send(RpcRequest::SendRpc(req)).await.unwrap();

        // Fulfill the open substream request
        match dialer_peer_reqs_rx.next().await.unwrap() {
            PeerRequest::OpenSubstream(protocol, substream_tx) => {
                assert_eq!(protocol.as_ref(), protocol_id);
                substream_tx.send(Ok(dialer_substream)).unwrap();
            }
            _ => {
                unreachable!();
            }
        }

        // Check the rpc response data
        let data = res_rx.await.unwrap().unwrap();
        assert_eq!(data.as_ref(), res_data);
    };

    // Set up the listener Rpc protocol actor
    let (_, listener_rpc_reqs_rx) = channel::new_test(8);
    let (mut listener_peer_notifs_tx, listener_peer_notifs_rx) = channel::new_test(8);
    let (listener_peer_reqs_tx, _) = channel::new_test(8);
    let listener_peer_reqs_tx = PeerHandle::new(
        dialer_peer_id,
        Multiaddr::from_str("/ip6/::1/tcp/8081").unwrap(),
        listener_peer_reqs_tx,
    );
    let (listener_rpc_notifs_tx, mut listener_rpc_notifs_rx) = channel::new_test(8);
    let listener_rpc = Rpc::new(
        rt.handle().clone(),
        listener_peer_reqs_tx,
        listener_rpc_reqs_rx,
        listener_peer_notifs_rx,
        listener_rpc_notifs_tx,
        Duration::from_millis(500),
        10,
        10,
    );

    // Fake the listener NetworkProvider
    let f_listener_network = async move {
        // Notify Rpc of a new inbound substream

        listener_peer_notifs_tx
            .send(PeerNotification::NewSubstream(
                dialer_peer_id,
                NegotiatedSubstream {
                    protocol: ProtocolId::from_static(protocol_id),
                    substream: listener_substream,
                },
            ))
            .await
            .unwrap();

        // Handle the inbound rpc request
        match listener_rpc_notifs_rx.next().await.unwrap() {
            RpcNotification::RecvRpc(req) => {
                assert_eq!(req.protocol.as_ref(), protocol_id);
                assert_eq!(req.data.as_ref(), req_data);
                req.res_tx.send(Ok(Bytes::from_static(res_data))).unwrap();
            }
        }
    };

    let f = join4(
        f_listener_network,
        listener_rpc.start(),
        f_dialer_network,
        dialer_rpc.start(),
    );
    rt.block_on(f);
}
```


Overlapping Code:
```
{
::libra_logger::try_init_for_testing();
let listener_peer_id = PeerId::random();
let dialer_peer_id = PeerId::random();
let protocol_id = b"/get_blocks/1.0.0";
let req_data = b"hello";
let res_data = b"goodbye";
let mut rt = Runtime::new().unwrap();
let (dialer_substream, listener_substream) = MemorySocket::new_pair();
// Set up the dialer Rpc protocol actor
let (mut dialer_rpc_tx, dialer_rpc_rx) = channel::new_test(8);
let (_, dialer_peer_notifs_rx) = channel::new_test(8);
let (dialer_peer_reqs_tx, mut dialer_peer_reqs_rx) = channel::new_test(8);
let dialer_peer_reqs_tx = PeerHandle::new(
listener_peer_id,
Multiaddr::from_str("/ip6/::1/tcp/8080").unwrap(),
dialer_peer_reqs_tx,
);
let (rpc_handler_tx, _) = channel::new_test(8);
let dialer_rpc = Rpc::new(
rt.handle().clone(),
dialer_peer_reqs_tx,
dialer_rpc_rx,
dialer_peer_notifs_rx,
rpc_handler_tx,
Duration::from_millis(500),
10,
10,
);
// Fake the dialer NetworkProvider
let f_dialer_network = async move {
let (res_tx, res_rx) = oneshot::channel();
let req = OutboundRpcRequest {
protocol: ProtocolId::from_static(protocol_id),
data: Bytes::from_static(req_data),
res_tx,
timeout: Duration::from_secs(1),
};
// Tell Rpc to send an rpc request
dialer_rpc_tx.send(RpcRequest::SendRpc(req)).await.unwrap();
// Fulfill the open substream request
match dialer_peer_reqs_rx.next().await.unwrap() {
PeerRequest::OpenSubstream(protocol, substream_tx) => {
assert_eq!(protocol.as_ref(), protocol_id);
substream_tx.send(Ok(dialer_substream)).unwrap();
}
_ => {
unreachable!();
}
}
// Check the rpc response data
let data = res_rx.await.unwrap().unwrap();
assert_eq!(data.as_ref(), res_data);
};
// Set up the listener Rpc protocol actor
let (_, listener_rpc_reqs_rx) = channel::new_test(8);
let (mut listener_peer_notifs_tx, listener_peer_notifs_rx) = channel::new_test(8);
let (listener_peer_reqs_tx, _) = channel::new_test(8);
let listener_peer_reqs_tx = PeerHandle::new(
dialer_peer_id,
Multiaddr::from_str("/ip6/::1/tcp/8081").unwrap(),
listener_peer_reqs_t
```
<Overlap Ratio: 0.9887310142087212>

---

--- 265 --
Question ID: 005a1dabb89dacad4f9fde1bc1ea687065a751e4_1
Original Code:
```
pub async fn check_clean(allow_dirty: bool) -> Result<()> {
    // Figure out state of the repo.
    let repo = Repository::discover(".").expect("unable to find repository");
    let mut options = StatusOptions::new();
    options
        .include_untracked(true)
        .include_ignored(false)
        .include_unmodified(false)
        .exclude_submodules(true)
        .sort_case_insensitively(true);
    let statuses = repo
        .statuses(Some(&mut options))
        .expect("unable to list repository changes");

    // Determine if the repo is clean or not.
    let clean = statuses.iter().next().is_none();
    if clean {
        return Ok(());
    }

    // Warn if the user --allow-dirty or fail if not.
    if allow_dirty {
        eprintln!("Not all changes are committed to git but --allow-dirty was set.");
        return Ok(());
    }
    let error = anyhow::anyhow!("Not all changes are committed to git");
    ReleaseCheck::failed(error)
}
```


Overlapping Code:
```
sync fn check_clean(allow_dirty: bool) -> Result<()> {
// Figure out state of the repo.
let repo = Repository::discover(".").expect("unable to find repository");
let mut options = StatusOptions::new();
options
.include_untracked(true)
.include_ignored(false)
.include_unmodified(false)
.exclude_submodules(true)
.sort_case_insensitively(true);
let statuses = repo
.statuses(Some(&mut options))
.expect("unable to list repository changes");
// Determine if the repo is clean or not.
let clean = statuses.iter().next().is_none();
if clean {
return Ok(());
}
// Warn if the user --allow-dirty or fail if not.
if allow_dirty {
eprintln!("Not all changes are committed to git but --allow-dirty was set.");
return Ok(());
}
let error = anyhow::anyhow!("Not all changes are committed to git");
ReleaseCheck:
```
<Overlap Ratio: 0.97442143727162>

---

--- 266 --
Question ID: 551cc919ab7fddba8b8585d311fcc7c20c0777e7_0
Original Code:
```
fn unpack_files(directory: &Path, replace_path: &str) {
    use tar::{Builder, Header, Archive};

    let mut builder = Builder::new(Vec::new());
    for &(name, data) in FILES {
        let data = data.replace("PATH", replace_path);
        let mut header = Header::new_gnu();
        header.set_path(name).unwrap();
        header.set_size(data.len() as u64);
        header.set_cksum();
        builder.append(&header, data.as_bytes()).unwrap();
    }

    let archive: &[u8] = &builder.into_inner().unwrap();
    Archive::new(archive).unpack(directory)
        .expect("Can't unpack test crate");
}
```


Overlapping Code:
```
directory: &Path, replace_path: &str) {
use tar::{Builder, Header, Archive};
let mut builder = Builder::new(Vec::new());
for &(name, data) in FILES {
let data = data.replace("PATH", replace_path);
let mut header = Header::new_gnu();
header.set_path(name).unwrap();
header.set_size(data.len() as u64);
header.set_cksum();
builder.append(&header, data.as_bytes()).unwrap();
}
let archive: &[u8] = &builder.into_inner().unwrap();
Archive::new(archive).unpack(directory)
.expect("Can't unpack test crate"
```
<Overlap Ratio: 0.9615384615384616>

---

--- 267 --
Question ID: 54024b9093e75a208399f2dcc50e7cc066a971f7_1
Original Code:
```
async fn prepare_amqp_chan(conn: &Connection) -> Channel {
    let chan = conn
        .create_channel()
        .await
        .expect("unable to create channel");
    chan.exchange_declare(
        "test",
        ExchangeKind::Topic,
        ExchangeDeclareOptions {
            durable: true,
            ..Default::default()
        },
        Default::default(),
    )
    .await
    .expect("unable to declare exchange");
    chan.queue_declare(
        "test_queue",
        QueueDeclareOptions {
            exclusive: true,
            ..Default::default()
        },
        Default::default(),
    )
    .await
    .expect("unable to create queue");
    chan.queue_bind(
        "test_queue",
        "test",
        "#",
        QueueBindOptions::default(),
        Default::default(),
    )
    .await
    .expect("unable to bind queue to exchange");
    chan
}
```


Overlapping Code:
```
Connection) -> Channel {
let chan = conn
.create_channel()
.await
.expect("unable to create channel");
chan.exchange_declare(
"test",
ExchangeKind::Topic,
ExchangeDeclareOptions {
durable: true,
..Default::default()
},
Default::default(),
)
.await
.expect("unable to declare exchange");
chan.queue_declare(
"test_queue",
QueueDeclareOptions {
exclusive: true,
..Default::default()
},
Default::default(),
)
.await
.expect("unable to create queue");
chan.queue_bind(
"test_queue",
"test",
"#",
QueueBindOptions::default(),
Default::default(),
)
.await
.expect("unable to bind queue to exchange");
chan

```
<Overlap Ratio: 0.9448818897637795>

---

--- 268 --
Question ID: b979e82bfcd8d6891b34c6a52fa9a5baf0c5bd1f_1
Original Code:
```
fn test_enum() {
    let u = E::Unit;
    let expected = vec![0, 0, 0, 0];
    assert_eq!(to_bytes(&u).unwrap(), expected);
    is_same(u);

    let n = E::Newtype(1);
    let expected = vec![1, 0, 0, 0, 1, 0];
    assert_eq!(to_bytes(&n).unwrap(), expected);
    is_same(n);

    let t = E::Tuple(1, 2);
    let expected = vec![2, 0, 0, 0, 1, 0, 2, 0];
    assert_eq!(to_bytes(&t).unwrap(), expected);
    is_same(t);

    let s = E::Struct { a: 1 };
    let expected = vec![3, 0, 0, 0, 1, 0, 0, 0];
    assert_eq!(to_bytes(&s).unwrap(), expected);
    is_same(s);
}
```


Overlapping Code:
```
nit;
let expected = vec![0, 0, 0, 0];
assert_eq!(to_bytes(&u).unwrap(), expected);
is_same(u);
let n = E::Newtype(1);
let expected = vec![1, 0, 0, 0, 1, 0];
assert_eq!(to_bytes(&n).unwrap(), expected);
is_same(n);
let t = E::Tuple(1, 2);
let expected = vec![2, 0, 0, 0, 1, 0, 2, 0];
assert_eq!(to_bytes(&t).unwrap(), expected);
is_same(t);
let s = E::Struct { a: 1 };
let expected = vec![3, 0, 0, 0, 1, 0, 0, 0];
assert_eq!(to_bytes(&s).unwrap(), expected);
is_same(s);

```
<Overlap Ratio: 0.94>

---

--- 269 --
Question ID: e646e26bddb9e80f2a86726ce71efb592188ff01_1
Original Code:
```
fn main() {
    println!("{}", read_file("src/main.rs").unwrap()); // this line succeeds
    println!("{}", read_file("src/failure.rs").unwrap()); // this line fails
}
```


Overlapping Code:
```
println!("{}", read_file("src/main.rs").unwrap()); // this line succeeds
println!("{}", read_file("src/failure.rs").unwrap()); // this l
```
<Overlap Ratio: 0.8553459119496856>

---

--- 270 --
Question ID: 9f9cce082e3c13f4983c739e059ae55557c18e76_1
Original Code:
```
fn from_path(path: &str) -> PyResult<Vec<Map>> {
    let mut maps = Vec::new();

    let inner_maps = rsprocmaps::from_path(Path::new(path)).map_err(ProcmapsError)?;
    for map in inner_maps {
        maps.push(Map {
            inner: map.map_err(ProcmapsError)?,
        })
    }

    Ok(maps)
}
```


Overlapping Code:
```
h: &str) -> PyResult<Vec<Map>> {
let mut maps = Vec::new();
let inner_maps = rsprocmaps::from_path(Path::new(path)).map_err(ProcmapsError)?;
for map in inner_maps {
maps.push(Map {
inner: map.map_err(ProcmapsError)?,
})
}

```
<Overlap Ratio: 0.8951612903225806>

---

--- 271 --
Question ID: 64bf087a54cd3678f6105ed1daa8342f1a3c3a92_1
Original Code:
```
fn load_and_execute(prog: &[Command]) -> VirtualMachine {
        let mut vm = VirtualMachine::new();
        vm.load(prog);

        for _ in 0..100 {
            vm.tick();
        }

        vm
    }
```


Overlapping Code:
```
og: &[Command]) -> VirtualMachine {
let mut vm = VirtualMachine::new();
vm.load(prog);
for _ in 0..1
```
<Overlap Ratio: 0.6944444444444444>

---

--- 272 --
Question ID: a8aedec168acbb2036abd6251d5b65493521da8e_4
Original Code:
```
fn load_configuration(args: &ArgMatches<'_>) -> Result<config::Config, Error> {
    let mut cfg = load_configuration_file(args)?;
    // Override global.chain via command-line or environment.
    if let Some(chain) = args.value_of("chain") {
        cfg.general.chain = chain.to_string();
    }

    // Override global.data_dir via command-line or environment.
    if let Some(data_dir) = args.value_of_os("data-dir") {
        cfg.general.data_dir = PathBuf::from(data_dir);
    }

    // Override global.consistency_check via command-line.
    if args.is_present("recover") {
        cfg.general.consistency_check = ConsistencyCheck::LoadChain;
    }
    // Override global.consistency_check via command-line.
    if args.is_present("force-check") {
        if args.is_present("recover") {
            error!("--force-check is set, ignoring --recover")
        }
        cfg.general.consistency_check = ConsistencyCheck::Full;
    }

    // Override network.endpoint via command-line or environment.
    if let Some(endpoint) = args.value_of("node-endpoint") {
        cfg.network.endpoint = endpoint.to_string();
    }

    if cfg.network.endpoint != "" {
        SocketAddr::from_str(&cfg.network.endpoint).map_err(|e| {
            format_err!("Invalid network.endpoint '{}': {}", cfg.network.endpoint, e)
        })?;
    }

    // Override network.advertised_endpoint via command-line or environment.
    if let Some(network_endpoint) = args.value_of("advertised-endpoint") {
        cfg.network.advertised_endpoint = network_endpoint.to_string();
    }
    if cfg.network.advertised_endpoint != "" {
        SocketAddr::from_str(&cfg.network.advertised_endpoint).map_err(|e| {
            format_err!(
                "Invalid network.advertised_endpoint '{}': {}",
                cfg.network.advertised_endpoint,
                e
            )
        })?;
    }

    // Use default SRV record for the chain
    if cfg.general.chain != "dev" && cfg.network.seed_pool == "" {
        cfg.network.seed_pool =
            format!("_stegos._tcp.{}.stegos.com", cfg.general.chain).to_string();
    }

    if args.is_present("no-network") {
        cfg.network.min_connections = 0;
        cfg.network.max_connections = 0;
        cfg.network.readiness_threshold = 0;
        cfg.network.seed_pool = String::from("");
    }

    // Override global.prometheus_endpoint via command-line or environment.
    if let Some(prometheus_endpoint) = args.value_of("prometheus-endpoint") {
        cfg.general.prometheus_endpoint = prometheus_endpoint.to_string();
    }
    if cfg.general.prometheus_endpoint != "" {
        SocketAddr::from_str(&cfg.general.prometheus_endpoint).map_err(|e| {
            format_err!(
                "Invalid prometheus_endpoint '{}': {}",
                cfg.general.prometheus_endpoint,
                e
            )
        })?;
    }

    // Override global.api_endpoint via command-line or environment.
    if let Some(api_endpoint) = args.value_of("api-endpoint") {
        cfg.general.api_endpoint = api_endpoint.to_string();
    } else if cfg.general.api_endpoint != "" {
        SocketAddr::from_str(&cfg.general.api_endpoint).map_err(|e| {
            format_err!(
                "Invalid api_endpoint '{}': {}",
                &cfg.general.api_endpoint,
                e
            )
        })?;
    }

    // Disable [node] sections.
    if cfg.general.chain == "mainnet" && cfg.node != Default::default() {
        return Err(format_err!(
            "Can't override [node] options for {}",
            cfg.general.chain
        ));
    }

    if cfg.general.chain != "mainnet" {
        enable_debug();
    }

    Ok(cfg)
}
```


Overlapping Code:
```
s: &ArgMatches<'_>) -> Result<config::Config, Error> {
let mut cfg = load_configuration_file(args)?;
// Override global.chain via command-line or environment.
if let Some(chain) = args.value_of("chain") {
cfg.general.chain = chain.to_string();
}
// Override global.data_dir via command-line or environment.
if let Some(data_dir) = args.value_of_os("data-dir") {
cfg.general.data_dir = PathBuf::from(data_dir);
}
// Override global.consistency_check via command-line.
if args.is_present("recover") {
cfg.general.consistency_check = ConsistencyCheck::LoadChain;
}
// Override global.consistency_check via command-line.
if args.is_present("force-check") {
if args.is_present("recover") {
error!("--force-check is set, ignoring --recover")
}
cfg.general.consistency_check = ConsistencyCheck::Full;
}
// Override network.endpoint via command-line or environment.
if let Some(endpoint) = args.value_of("node-endpoint") {
cfg.network.endpoint = endpoint.to_string();
}
if cfg.network.endpoint != "" {
SocketAddr::from_str(&cfg.network.endpoint).map_err(|e| {
format_err!("Invalid network.endpoint '{}': {}", cfg.network.endpoint, e)
})?;
}
// Override network.advertised_endpoint via command-line or environment.
if let Some(network_endpoint) = args.value_of("advertised-endpoint") {
cfg.network.advertised_endpoint = network_endpoint.to_string();
}
if cfg.network.advertised_endpoint != "" {
SocketAddr::from_str(&cfg.network.advertised_endpoint).map_err(|e| {
format_err!(
"Invalid network.advertised_endpoint '{}': {}",
cfg.network.advertised_endpoint,
e
)
})?;
}
// Use default SRV record for the chain
if cfg.general.chain != "dev" && cfg.network.seed_pool == "" {
cfg.network.seed_pool =
format!("_stegos._tcp.{}.stegos.com", cfg.general.chain).to_string();
}
if args.is_present("no-network") {
cfg.network.min_connections = 0;
cfg.network.max_connections = 0;
cfg.network.readiness_threshold = 0;
cfg.network.seed_pool = String::from("");
}
// Override global.prometheus_endpoint via command-line or environment.
if let Some(prometheus_endpoint) = ar
```
<Overlap Ratio: 0.9674374705049552>

---

--- 273 --
Question ID: cfeb560bafebf06ebe74ada56ea1d989e5186467_6
Original Code:
```
fn eval_cons(x: Object, xs: Object, env: &mut Env, backtrace: &mut Backtrace) -> Result<Object> {
    use Object::*;
    let xs = evaluate(xs, env, backtrace)?;
    match xs {
        List(xs) => Ok(List(vec![Cons("::".into()), evaluate(x, env, backtrace)?, List(xs)])),
        _ => Err(EvalError::new(format!("Cons error: {:?}", xs), backtrace.clone()))
    }
}
```


Overlapping Code:
```
bject, env: &mut Env, backtrace: &mut Backtrace) -> Result<Object> {
use Object::*;
let xs = evaluate(xs, env, backtrace)?;
match xs {
List(xs) => Ok(List(vec![Cons("::".into()), evaluate(x, env, backtrace)?, List(xs)])),
_ => Err(EvalError::new(format!("Cons err
```
<Overlap Ratio: 0.7945619335347432>

---

--- 274 --
Question ID: 4e2824d986e6d827234318dfe6bb12f7ed91a1be_10
Original Code:
```
fn test_parse_header() -> Result<(), VCFError> {
    let mut simple1_vcf = BufReader::new(&include_bytes!("../../testfiles/simple1.vcf")[..]);

    let (line_count, unprocessed_line, header) = parse_header(&mut simple1_vcf)?;
    assert_eq!(line_count, 20);
    assert_eq!(unprocessed_line, None);

    assert_eq!(
        header.samples,
        vec![
            b"ERP001775_HiSeq2000_SAMEA1531955-1".to_vec(),
            b"ERP001775_HiSeq2000_SAMEA1531955-2".to_vec()
        ]
    );

    let expected_items = vec![
            VCFHeaderLine {
                line: b"##fileformat=VCFv4.2\n".to_vec(),
                contents: VCFHeaderContent::FileFormat(VCFVersion::Vcf4_2)
            },
            VCFHeaderLine {
                line: b"##FILTER=<ID=PASS,Description=\"All filters passed\">\n".to_vec(),
                contents: VCFHeaderContent::FILTER{
                    id: b"PASS".to_vec(),
                    description: b"All filters passed".to_vec()
                }
            },
            VCFHeaderLine {
                line: b"##ALT=<ID=NON_REF,Description=\"Represents any possible alternative allele at this location\">\n".to_vec(),
                contents: VCFHeaderContent::ALT{
                    id: b"NON_REF".to_vec(),
                    description: b"Represents any possible alternative allele at this location".to_vec()
                }
            },
            VCFHeaderLine {
                line: b"##FILTER=<ID=LowQual,Description=\"Low quality\">\n".to_vec(),
                contents: VCFHeaderContent::FILTER{
                    id: b"LowQual".to_vec(),
                    description: b"Low quality".to_vec()
                }
            },
            VCFHeaderLine {
                line: b"##FORMAT=<ID=AD,Number=R,Type=Integer,Description=\"Allelic depths for the ref and alt alleles in the order listed\">\n".to_vec(),
                contents: VCFHeaderContent::FORMAT{
                    id: b"AD".to_vec(),
                    number: Number::Reference,
                    value_type: ValueType::Integer,
                    description: b"Allelic depths for the ref and alt alleles in the order listed".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Approximate read depth (reads with MQ=255 or with bad mates are filtered)\">\n".to_vec(),
                contents: VCFHeaderContent::FORMAT{
                    id: b"DP".to_vec(),
                    number: Number::Number(1),
                    value_type: ValueType::Integer,
                    description: b"Approximate read depth (reads with MQ=255 or with bad mates are filtered)".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">\n".to_vec(),
                contents: VCFHeaderContent::FORMAT{
                    id: b"GT".to_vec(),
                    number: Number::Number(1),
                    value_type: ValueType::String,
                    description: b"Genotype".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##GATKCommandLine=<ID=HaplotypeCaller,CommandLine=\"HaplotypeCaller  --contamination-fraction-to-filter 0.0 --emit-ref-confidence GVCF --output ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.g.vcf.gz --intervals /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/1101158470/0020-scattered.interval_list --input /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/-929370236/ERP001775_HiSeq2000_SAMEA1531955-1.hs37d5.bam --reference /cromwell-executions/VariantCall/6f09e738-2160-49dd-8287-ff8ef9368d27/call-HaplotypeCaller/shard-20/inputs/865204270/hs37d5.fa  --use-new-qual-calculator true --use-old-qual-calculator false --annotate-with-num-discovered-alleles false --heterozygosity 0.001 --indel-heterozygosity 1.25E-4 --heterozygosity-stdev 0.01 --standard-min-confidence-threshold-for-calling 30.0 --max-alternate-alleles 6 --max-genotype-count 1024 --sample-ploidy 2 --num-reference-samples-if-no-call 0 --genotyping-mode DISCOVERY --genotype-filtered-alleles false --output-mode EMIT_VARIANTS_ONLY --all-site-pls false --gvcf-gq-bands 1 --gvcf-gq-bands 2 --gvcf-gq-bands 3 --gvcf-gq-bands 4 --gvcf-gq-bands 5 --gvcf-gq-bands 6 --gvcf-gq-bands 7 --gvcf-gq-bands 8 --gvcf-gq-bands 9 --gvcf-gq-bands 10 --gvcf-gq-bands 11 --gvcf-gq-bands 12 --gvcf-gq-bands 13 --gvcf-gq-bands 14 --gvcf-gq-bands 15 --gvcf-gq-bands 16 --gvcf-gq-bands 17 --gvcf-gq-bands 18 --gvcf-gq-bands 19 --gvcf-gq-bands 20 --gvcf-gq-bands 21 --gvcf-gq-bands 22 --gvcf-gq-bands 23 --gvcf-gq-bands 24 --gvcf-gq-bands 25 --gvcf-gq-bands 26 --gvcf-gq-bands 27 --gvcf-gq-bands 28 --gvcf-gq-bands 29 --gvcf-gq-bands 30 --gvcf-gq-bands 31 --gvcf-gq-bands 32 --gvcf-gq-bands 33 --gvcf-gq-bands 34 --gvcf-gq-bands 35 --gvcf-gq-bands 36 --gvcf-gq-bands 37 --gvcf-gq-bands 38 --gvcf-gq-bands 39 --gvcf-gq-bands 40 --gvcf-gq-bands 41 --gvcf-gq-bands 42 --gvcf-gq-bands 43 --gvcf-gq-bands 44 --gvcf-gq-bands 45 --gvcf-gq-bands 46 --gvcf-gq-bands 47 --gvcf-gq-bands 48 --gvcf-gq-bands 49 --gvcf-gq-bands 50 --gvcf-gq-bands 51 --gvcf-gq-bands 52 --gvcf-gq-bands 53 --gvcf-gq-bands 54 --gvcf-gq-bands 55 --gvcf-gq-bands 56 --gvcf-gq-bands 57 --gvcf-gq-bands 58 --gvcf-gq-bands 59 --gvcf-gq-bands 60 --gvcf-gq-bands 70 --gvcf-gq-bands 80 --gvcf-gq-bands 90 --gvcf-gq-bands 99 --floor-blocks false --indel-size-to-eliminate-in-ref-model 10 --use-alleles-trigger false --disable-optimizations false --just-determine-active-regions false --dont-genotype false --do-not-run-physical-phasing false --use-filtered-reads-for-annotations false --correct-overlapping-quality false --adaptive-pruning false --do-not-recover-dangling-branches false --recover-dangling-heads false --consensus false --dont-trim-active-regions false --max-disc-ar-extension 25 --max-gga-ar-extension 300 --padding-around-indels 150 --padding-around-snps 20 --kmer-size 10 --kmer-size 25 --dont-increase-kmer-sizes-for-cycles false --allow-non-unique-kmers-in-ref false --num-pruning-samples 1 --min-dangling-branch-length 4 --recover-all-dangling-branches false --max-num-haplotypes-in-population 128 --min-pruning 2 --adaptive-pruning-initial-error-rate 0.001 --pruning-lod-threshold 2.302585092994046 --max-unpruned-variants 100 --debug-assembly false --debug-graph-transformations false --capture-assembly-failure-bam false --error-correct-reads false --kmer-length-for-read-error-correction 25 --min-observations-for-kmer-to-be-solid 20 --likelihood-calculation-engine PairHMM --base-quality-score-threshold 18 --pair-hmm-gap-continuation-penalty 10 --pair-hmm-implementation FASTEST_AVAILABLE --pcr-indel-model CONSERVATIVE --phred-scaled-global-read-mismapping-rate 45 --native-pair-hmm-threads 4 --native-pair-hmm-use-double-precision false --bam-writer-type CALLED_HAPLOTYPES --dont-use-soft-clipped-bases false --min-base-quality-score 10 --smith-waterman JAVA --max-mnp-distance 0 --min-assembly-region-size 50 --max-assembly-region-size 300 --assembly-region-padding 100 --max-reads-per-alignment-start 50 --active-probability-threshold 0.002 --max-prob-propagation-distance 50 --force-active false --interval-set-rule UNION --interval-padding 0 --interval-exclusion-padding 0 --interval-merging-rule ALL --read-validation-stringency SILENT --seconds-between-progress-updates 10.0 --disable-sequence-dictionary-validation false --create-output-bam-index true --create-output-bam-md5 false --create-output-variant-index true --create-output-variant-md5 false --lenient false --add-output-sam-program-record true --add-output-vcf-command-line true --cloud-prefetch-buffer 40 --cloud-index-prefetch-buffer -1 --disable-bam-index-caching false --sites-only-vcf-output false --help false --version false --showHidden false --verbosity INFO --QUIET false --use-jdk-deflater false --use-jdk-inflater false --gcs-max-retries 20 --gcs-project-for-requester-pays  --disable-tool-default-read-filters false --minimum-mapping-quality 20 --disable-tool-default-annotations false --enable-all-annotations false --allow-old-rms-mapping-quality-annotation-data false\",Version=\"4.1.3.0\",Date=\"October 3, 2019 5:19:41 PM UTC\">\n".to_vec(),
                contents: VCFHeaderContent::Other
            },
            VCFHeaderLine {
                line: b"##INFO=<ID=AC,Number=A,Type=Integer,Description=\"Allele count in genotypes, for each ALT allele, in the same order as listed\">\n".to_vec(),
                contents: VCFHeaderContent::INFO{
                    id: b"AC".to_vec(),
                    number: Number::Allele,
                    value_type: ValueType::Integer,
                    description: b"Allele count in genotypes, for each ALT allele, in the same order as listed".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency, for each ALT allele, in the same order as listed\">\n".to_vec(),
                contents: VCFHeaderContent::INFO{
                    id: b"AF".to_vec(),
                    number: Number::Allele,
                    value_type: ValueType::Float,
                    description: b"Allele Frequency, for each ALT allele, in the same order as listed".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##INFO=<ID=AN,Number=1,Type=Integer,Description=\"Total number of alleles in called genotypes\">\n".to_vec(),
                contents: VCFHeaderContent::INFO{
                    id: b"AN".to_vec(),
                    number: Number::Number(1),
                    value_type: ValueType::Integer,
                    description: b"Total number of alleles in called genotypes".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Approximate read depth; some reads may have been filtered\">\n".to_vec(),
                contents: VCFHeaderContent::INFO{
                    id: b"DP".to_vec(),
                    number: Number::Number(1),
                    value_type: ValueType::Integer,
                    description: b"Approximate read depth; some reads may have been filtered".to_vec(),
                    source: None,
                    version: None,
                }
            },
            VCFHeaderLine {
                line: b"##contig=<ID=13,length=115169878>\n".to_vec(),
                contents: VCFHeaderContent::Contig {
                    id: b"13".to_vec(),
                    length: Some(115169878),
                }
            },
            VCFHeaderLine {
                line: b"##contig=<ID=14,length=107349540>\n".to_vec(),
                contents: VCFHeaderContent::Contig {
                    id: b"14".to_vec(),
                    length: Some(107349540),
                }
            },
            VCFHeaderLine {
                line: b"##source=CombineGVCFs\n".to_vec(),
                contents: VCFHeaderContent::Other
            },
            VCFHeaderLine {
                line: b"##source=GenotypeGVCFs\n".to_vec(),
                contents: VCFHeaderContent::Other
            },
            VCFHeaderLine {
                line: b"##source=HaplotypeCaller\n".to_vec(),
                contents: VCFHeaderContent::Other
            },
            VCFHeaderLine {
                line: b"##bcftools_viewVersion=1.9+htslib-1.9\n".to_vec(),
                contents: VCFHeaderContent::Other
            },
            VCFHeaderLine {
                line: b"##bcftools_viewCommand=view -O z -o /tmp/NA12878-subset.vcf.gz -r 13:32889150-32975410,17:41194315-41277931 NA12878_comparison.genotyped.vcf.gz; Date=Sat Mar  7 20:29:56 2020\n".to_vec(),
                contents: VCFHeaderContent::Other
            }
        ];

    for (x, y) in expected_items.iter().zip(header.items.iter()) {
        assert_eq!(x, y);
    }
    assert_eq!(expected_items.len(), header.items.len());

    assert_eq!(
        header.info(b"AC"),
        Some(VCFHeaderInfoFormat {
            id: b"AC",
            number: &Number::Allele,
            value_type: &ValueType::Integer,
            description:
                b"Allele count in genotypes, for each ALT allele, in the same order as listed",
            source: None,
            version: None,
        })
    );

    assert_eq!(header.info(b"XX"), None);
    assert_eq!(header.info_key.len(), 4);

    assert_eq!(
        header.format(b"AD"),
        Some(VCFHeaderInfoFormat {
            id: b"AD",
            number: &Number::Reference,
            value_type: &ValueType::Integer,
            description: b"Allelic depths for the ref and alt alleles in the order listed",
            source: None,
            version: None,
        })
    );
    assert_eq!(header.format(b"AC"), None);
    assert_eq!(header.format_key.len(), 3);
    assert_eq!(
        header
            .format_list()
            .map(|x| -> &[u8] { &x })
            .collect::<HashSet<&[u8]>>(),
        [&b"AD"[..], &b"DP"[..], &b"GT"[..]]
            .iter()
            .cloned()
            .collect::<HashSet<&[u8]>>()
    );

    assert_eq!(
        header.filter(b"LowQual"),
        Some(VCFHeaderFilterAlt {
            id: b"LowQual",
            description: b"Low quality",
        })
    );
    assert_eq!(header.filter(b"AC"), None);
    assert_eq!(header.filter_key.len(), 2);
    assert_eq!(
        header
            .filter_list()
            .map(|x| -> &[u8] { &x })
            .collect::<HashSet<&[u8]>>(),
        [&b"PASS"[..], &b"LowQual"[..]]
            .iter()
            .cloned()
            .collect::<HashSet<&[u8]>>()
    );

    assert_eq!(header.alt(b"DEL"), None);
    assert_eq!(header.alt_key.len(), 1);
    assert_eq!(
        header
            .alt_list()
            .map(|x| -> &[u8] { &x })
            .collect::<HashSet<&[u8]>>(),
        [&b"NON_REF"[..]]
            .iter()
            .cloned()
            .collect::<HashSet<&[u8]>>()
    );
    assert_eq!(
        header.alt(b"NON_REF"),
        Some(VCFHeaderFilterAlt {
            id: b"NON_REF",
            description: b"Represents any possible alternative allele at this location",
        })
    );

    Ok(())
}
```


Overlapping Code:
```
"##FILTER=<ID=PASS,Description=\"All filters passed\">\n".##ALT=<ID=NON_REF,Description=\"Represents any possible alternative allele at this location\">\n"Represents any possible alternative allele at this location"}
},
VCFHeaderLine {
line: b"##FILTER=<ID=LowQual,##FORMAT=<ID=AD,Number=R,Type=Integer,Description=\"Allelic depths for the ref and alt alleles in the order listed\">"Allelic depths for the ref and alt alleles in the order listed""##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Approximate read depth (reads with MQ=255 or with bad ma
```
<Overlap Ratio: 0.3162393162393162>

---

--- 275 --
Question ID: a5a86739eb86fbc35e209641a008e5e7e3b0c001_13
Original Code:
```
fn test_standalone_short_works_with_verbatim_casing() {
    #[derive(Clap, Debug, PartialEq)]
    struct Opt {
        #[clap(rename_all = "verbatim", short)]
        _foo: bool,
    }

    assert_eq!(Opt { _foo: true }, Opt::parse_from(&["test", "-_"]));
}
```


Overlapping Code:
```
short_works_with_verbatim_casing() {
#[derive(Clap, Debug, PartialEq)]
struct Opt {
#[clap(rename_all = "verbatim", short)]
_foo: bool,
}
assert_eq!(Opt { _foo: true }, Opt::parse_from(&["test", "-_"]
```
<Overlap Ratio: 0.8928571428571429>

---

--- 276 --
Question ID: 90ca9c3f0e8ab30e8928ef9fbff03ef338536d3e_5
Original Code:
```
async fn get_put_large_value() {
        let (_tmpdir, values) = test_init().await;
 
        const SIZE: usize = 1_000_000;
        let mut builder = values.make_batch().await;

        let mut data = vec![];
        data.resize(SIZE, 'a' as u8);

        let value = String::from_utf8(data).unwrap();

        let e = crate::get_encoder();
        let vid = builder.add_value(e.serialize(&value).unwrap()).await;

        builder.finish().await.unwrap();

        let result = values.get::<String>(vid).await.unwrap();
        assert_eq!(result, value);
    }
```


Overlapping Code:
```
c fn get_put_large_value() {
let (_tmpdir, values) = test_init().await;

const SIZE: usize = 1_000_000;
let mut builder = values.make_batch().await;
let mut data = vec![];
data.resize(SIZE, 'a' as u8);
let value = String::from_utf8(data).unwrap();
let e = crate::get_encoder();
let vid = builder.add_value(e.serialize(&value).unwrap()).await;
builder.finish().await.unwrap();
let result = values.get::<String>(vid).await.unwrap();
assert_eq!(result, 
```
<Overlap Ratio: 0.9719222462203023>

---

--- 277 --
Question ID: 811b87b3c4d69c493f9e3c49d2c798539bc4d965_7
Original Code:
```
fn test_rotation_path_minutely() {
        let r = Rotation::MINUTELY;
        let mock_now = Utc.ymd(2020, 2, 1).and_hms(10, 3, 1);
        let path = r.join_date("MyApplication.log", &mock_now);
        assert_eq!("MyApplication.log.2020-02-01-10-03", path);
    }
```


Overlapping Code:
```
_rotation_path_minutely() {
let r = Rotation::MINUTELY;
let mock_now = Utc.ymd(2020, 2, 1).and_hms(10, 3, 1);
let path = r.join_date("MyApplication.log", &mock_now);
assert_eq!("MyApplication.log.2020
```
<Overlap Ratio: 0.8695652173913043>

---

--- 278 --
Question ID: 58e9fc8797ce5798864390deed20cffb0f64b42d_20
Original Code:
```
fn given_cfd_expires_within_23hours_then_rollover() {
        // --|----|-------------------------------------------------|--> time
        //   ct   1h                                                24h
        // --|----|<--------------------rollover------------------->|--
        //        now

        let cfd = Cfd::dummy_open(BitMexPriceEventId::with_20_digits(
            datetime!(2021-11-19 10:00:00).assume_utc(),
        ));

        let result = cfd.can_auto_rollover_taker(datetime!(2021-11-18 11:00:00).assume_utc());

        assert!(result.is_ok());
    }
```


Overlapping Code:
```
hen_rollover() {
// --|----|-------------------------------------------------|--> time
// ct 1h 24h
// --|----|<--------------------rollover------------------->|--
// now
let cfd = Cfd::dummy_open(BitMexPriceEventId::with_20_digits(
datetime!(2021-11-19 10:00:00).assume_utc(),
));
let result = cfd.can_auto_rollover_taker(datetime!(2021-11-18 11:00:00).assume_utc());
assert!(result.is_ok());
```
<Overlap Ratio: 0.9097222222222222>

---

--- 279 --
Question ID: 4cad3e9d062b9fb20922a460bc31f39de51d65bd_0
Original Code:
```
fn parse_message(msg: Message) -> Fallible<WebsocketEvent> {
    let bin = match msg {
        Message::Text(msg) => return Ok(WebsocketEvent::Text(msg)),
        Message::Binary(b) => b,
        Message::Pong(b) => b,
        Message::Ping(b) => b,
        Message::Close(..) => return Err(failure::format_err!("Socket closed")),
    };

    let mut d = GzDecoder::new(&*bin);
    let mut s = String::new();
    d.read_to_string(&mut s).unwrap();

    trace!("Incoming websocket message {:?}", s);

    let message: WebsocketEvent = from_str(&s)?;

    Ok(message)
}
```


Overlapping Code:
```
> Fallible<WebsocketEvent> {
let bin = match msg {
Message::Text(msg) => return Ok(WebsocketEvent::Text(msg)),
Message::Binary(b) => b,
Message::Pong(b) => b,
Message::Ping(b) => b,
Message::Close(..) => return Err(failure::format_err!("Socket closed")),
};
let mut d = GzDecoder::new(&*bin);
let mut s = String::new();
d.read_to_string(&mut s).unwrap();
trace!("Incoming websocket message {:?}", s);
let message: WebsocketEvent = from_str(&s)?;
Ok(m
```
<Overlap Ratio: 0.9164969450101833>

---

--- 280 --
Question ID: 56a2724ed7b658a2fc5a24d70231115f289387c1_2
Original Code:
```
fn next_starting_with(start: &str, current_word: &str) -> Option<&'static str> {
        let words = Self::starting_with(start);
        let position = words.iter().position(|word| word == &current_word)?;

        // if the last word cycle back to the first word in the list
        let position = if position == (words.len() - 1) {
            0
        } else {
            position
        };

        Some(*words.get(position + 1)?)
    }
```


Overlapping Code:
```
d: &str) -> Option<&'static str> {
let words = Self::starting_with(start);
let position = words.iter().position(|word| word == &current_word)?;
// if the last word cycle back to the first word in the list
let position = if position == (words.len() - 1) {
0
} else {
position
};
Some(*words.get(positi
```
<Overlap Ratio: 0.8403361344537815>

---

--- 281 --
Question ID: 1ecca08e58d4310286b9f074f34dbe6ccd1d62f2_3
Original Code:
```
fn should_trim_start() -> Result {
    assert_eq!(trim_start_regexp("  abc  ", "\\s")?, "abc  ");
    assert_eq!(trim_start_regexp("\t\t\tabc\t\t", "\\t")?, "abc\t\t");
    assert_eq!(trim_start_regexp("\n\nabc\t\t", "\n")?, "abc\t\t");
    assert_eq!(trim_start_regexp("\n\n\n", "\n")?, "");

    Ok(())
  }
```


Overlapping Code:
```
trim_start_regexp(" abc ", "\\s")?, "abc ");
assert_eq!(trim_start_regexp("\t\t\tabc\t\t", "\\t")?, "abc\t\t");
assert_eq!(trim_start_regexp("\n\nabc\t\t", "\n")?, "abc\t\t");
assert_eq!(trim_start_re
```
<Overlap Ratio: 0.7092198581560284>

---

--- 282 --
Question ID: f2ddeeea0ca361e6353a3481cdb7393a13d7d2d2_3
Original Code:
```
fn test_timeout_search() {
        let result = search(
            Raid::new(346, 0, 4, false, 4, 0), // 5* Cradily, Den 166,
            0xbb810e6006a2a035,
            FrameFilter::new()
                .set_shiny(ShinyFilter::Square)
                .set_ability(AbilityFilter::Hidden)
                .set_gender(GenderFilter::Male)
                .set_ivs(
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                    Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
                ),
        )
        .unwrap();
        assert_eq!(result.1.ivs, IVs(31, 31, 31, 31, 31, 31));
        assert_eq!(result.1.shiny, Shininess::Square);
        assert_eq!(result.1.gender, Gender::Male);
        assert_eq!(result.1.ability, Ability::Hidden);
    }
```


Overlapping Code:
```
aid::new(346, 0, 4, false, 4, 0), // 5* Cradily, Den 166,
0xbb810e6006a2a035,
FrameFilter::new()
.set_shiny(ShinyFilter::Square)
.set_ability(AbilityFilter::Hidden)
.set_gender(GenderFilter::Male)
.set_ivs(
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
Some(SingleIVFilter::new_at_least(IVJudgment::Best)),
),
)
.unwrap();
assert_eq!(result.1.ivs, IVs(31, 31, 31, 31, 31, 31));
assert_eq!(result.1.shiny, Shininess::Square);
assert_eq!(result.1.gender, Gender::Male);
assert_e
```
<Overlap Ratio: 0.8871989860583016>

---

--- 283 --
Question ID: 99c7fbd9415c282254c081e2b59b48efa948cb98_0
Original Code:
```
fn loc_is_adjacent_to_other() {
        let loc = Loc::new(1, 1);
        assert!(loc.is_adjacent_to(&Loc::new(1, 0)));
        assert!(loc.is_adjacent_to(&Loc::new(1, 2)));
        assert!(loc.is_adjacent_to(&Loc::new(0, 1)));
        assert!(loc.is_adjacent_to(&Loc::new(2, 1)));
        assert!(!loc.is_adjacent_to(&Loc::new(1, 1)));
        assert!(!loc.is_adjacent_to(&Loc::new(0, 0)));
        assert!(!loc.is_adjacent_to(&Loc::new(0, 2)));
        assert!(!loc.is_adjacent_to(&Loc::new(2, 0)));
        assert!(!loc.is_adjacent_to(&Loc::new(2, 2)));
    }
```


Overlapping Code:
```
 loc = Loc::new(1, 1);
assert!(loc.is_adjacent_to(&Loc::new(1, 0)));
assert!(loc.is_adjacent_to(&Loc::new(1, 2)));
assert!(loc.is_adjacent_to(&Loc::new(0, 1)));
assert!(loc.is_adjacent_to(&Loc::new(2, 1)));
assert!(!loc.is_adjacent_to(&Loc::new(1, 1)));
assert!(!loc.is_adjacent_to(&Loc::new(0, 0)));
assert!(!loc.is_adjacent_to(&Loc::new(0, 2)));
assert!(!loc.is_adjacent_to(&Loc::new(2, 0)));
asser
```
<Overlap Ratio: 0.8368200836820083>

---

--- 284 --
Question ID: f99a31db839445f7bcf25ba7325e077cd1b80683_1
Original Code:
```
fn test_dirichlet_with_param() {
        let alpha = 0.5f64;
        let size = 2;
        let d = Dirichlet::new_with_param(alpha, size);
        let mut rng = crate::test::rng(221);
        let samples = d.sample(&mut rng);
        let _: Vec<f64> = samples
            .into_iter()
            .map(|x| {
                assert!(x > 0.0);
                x
            })
            .collect();
    }
```


Overlapping Code:
```
n test_dirichlet_with_param() {
let alpha = 0.5f64;
let size = 2;
let d = Dirichlet::new_with_param(alpha, size);
let mut rng = crate::test::rng(221);
let samples = d.sample(&mut rng);
let _: Vec<f64> = samples
.into_iter()
.map(|x| {
assert!(x > 0.0);
x
})
.c
```
<Overlap Ratio: 0.9558823529411765>

---

--- 285 --
Question ID: 29ac1c5997a292d330ffa57ed701a5277bcfd236_3
Original Code:
```
fn can_split_page_content_valid() {
        let content = r#"
+++
title = "Title"
description = "hey there"
date = 2002-10-12
+++
Hello
"#;
        let (front_matter, content) = split_page_content(Path::new(""), content).unwrap();
        assert_eq!(content, "Hello\n");
        assert_eq!(front_matter.title.unwrap(), "Title");
    }
```


Overlapping Code:
```
_valid() {
let content = r#"
+++
title = "Title"
description = "hey there"
date = 2002-10-12
+++
Hello
"#;
let (front_matter, content) = split_page_content(Path::new(""), content).unwrap();
assert_eq!(content, "Hello\n");
assert_eq!(front_matter.title.unwrap(), "Title");
}
```
<Overlap Ratio: 0.9161073825503355>

---

--- 286 --
Question ID: bef9179308cd458936bd6720221775ad753b505c_0
Original Code:
```
fn out<S:Into<String>>(label: &str, msg: S, color: color::Color) -> std::io::Result<()> {
  let mut out = term::stdout().unwrap();
  try!(out.reset());
  try!(out.fg(color));
  try!(write!(&mut std::io::stdout(), "{:>12}", format!("Capgun {}", label)));
  try!(out.reset());
  try!(write!(&mut std::io::stdout(), " {}\n", msg.into()));
  try!(out.flush());
  Ok(())
}
```


Overlapping Code:
```
Into<String>>(label: &str, msg: S, color: color::Color) -> std::io::Result<()> {
let mut out = term::stdout().unwrap();
try!(out.reset());
try!(out.fg(color));
try!(write!(&mut std::io::stdout(), "{:>12}", format!("Capgun {}", label)));
try!(out.reset());
try!(write!(&mut std::io::stdout(), " {}\n",
```
<Overlap Ratio: 0.8547008547008547>

---

--- 287 --
Question ID: 762aa01f3ef3d031f4c0a13efa036e7f3a6d910b_4
Original Code:
```
pub fn view_headers(tab: &Tab, col_span: usize) -> Vec<Node<Msg>> {
    let tuple_toggle = th![
        el_key(&format!("tuple-toggle")),
        attrs![At::Scope => "row"],
        style![St::TextAlign => "center", St::VerticalAlign => "middle"],
        "(1 2 3)"
    ];
    let select_all = th![
        el_key(&format!("select-all-rows")),
        attrs![At::Scope => "row"],
        style![St::TextAlign => "center", St::VerticalAlign => "middle"],
        "[ ]"
    ];
    let add_column = td![
        el_key(&format!("add-column")),
        attrs![At::Scope => "row", At::RowSpan => 2],
        style![St::TextAlign => "center", St::VerticalAlign => "middle"],
        "+"
    ];
    let empty = th![
        el_key(&format!("empty")),
        attrs![At::Scope => "column", At::ColSpan => col_span.to_string() ],
        "⠀"
    ];

    if tab.columns().len() == 0 {
        return vec![
            tr![tuple_toggle.clone(), empty.clone(), add_column.clone(),],
            tr![select_all.clone(), empty],
        ];
    }

    vec![
        tr![
            el_key(&format!("column-names")),
            tuple_toggle,
            tab.columns().iter().enumerate().map(|(index, column_id)| {
                th![
                    el_key(&format!("column-name-{}", column_id)),
                    attrs![At::Scope => "column"],
                    match tab.headers().get(column_id) {
                        Some(header) => match header.name() {
                            Some(name) => name.to_owned(),
                            None => nameless(index),
                        },
                        None => "ERROR".to_owned(),
                    }
                ]
            }),
            add_column,
        ],
        tr![
            el_key(&format!("column-data-types")),
            select_all,
            tab.columns().iter().map(|column_id| {
                th![
                    el_key(&format!("column-data-type-{}", column_id)),
                    attrs![At::Scope => "column"],
                    match tab.headers().get(column_id) {
                        Some(header) => header.data_type().to_html(),
                        None => DataType::Text.to_html(),
                    }
                ]
            }),
        ],
    ]
}
```


Overlapping Code:
```
b, col_span: usize) -> Vec<Node<Msg>> {
let tuple_toggle = th![
el_key(&format!("tuple-toggle")),
attrs![At::Scope => "row"],
style![St::TextAlign => "center", St::VerticalAlign => "middle"],
"(1 2 3)"
];
let select_all = th![
el_key(&format!("select-all-rows")),
attrs![At::Scope => "row"],
style![St::TextAlign => "center", St::VerticalAlign => "middle"],
"[ ]"
];
let add_column = td![
el_key(&format!("add-column")),
attrs![At::Scope => "row", At::RowSpan => 2],
style![St::TextAlign => "center", St::VerticalAlign => "middle"],
"+"
];
let empty = th![
el_key(&format!("empty")),
attrs![At::Scope => "column", At::ColSpan => col_span.to_string() ],
"⠀"
];
if tab.columns().len() == 0 {
return vec![
tr![tuple_toggle.clone(), empty.clone(), add_column.clone(),],
tr![select_all.clone(), empty],
];
}
vec![
tr![
el_key(&format!("column-names")),
tuple_toggle,
tab.columns().iter().enumerate().map(|(index, column_id)| {
th![
el_key(&format!("column-name-{}", column_id)),
attrs![At::Scope => "column"],
match tab.headers().get(column_id) {
Some(header) => match header.name() {
Some(name) => name.to_owned(),
None => nameless(index),
},
None => "ERROR".to_owned(),
}
]
}),
add_column,
],
tr![
el_key(&format!("column-data-types")),
select_all,
tab.columns().iter().map(|column_id| {
th![
el_key(&format!("column-data-type-{}", column_id)),
attrs![At::Scope => "column"],
match tab.headers().get(column_id) {
Some(header) => header.data_type().to_html(),
None => DataType::Text.to_html(),
}
]
}),
],
```
<Overlap Ratio: 0.97911227154047>

---

--- 288 --
Question ID: fb964d18883a9093e4e56394c0e78f018cbc0cac_0
Original Code:
```
fn main() {
    let lena = get_lena().expect("Couldn't load lena");

    // Create transformation matrix
    let x = 0.5 * (lena.cols() as f64) - 0.5;
    let y = 0.5 * (lena.rows() as f64) - 0.5;
    let trans = rotate_around_centre(FRAC_PI_4, (x, y)).dot(&scale(0.7, 0.7));

    let transformed = lena
        .transform(trans.view(), None)
        .expect("Transform failed");

    // save
    let path = Path::new("transformed_lena.png");
    let file = File::create(path).expect("Couldn't create output file");
    let ref mut w = BufWriter::new(file);

    let mut encoder = png::Encoder::new(w, transformed.cols() as u32, transformed.rows() as u32);
    encoder.set_color(png::ColorType::RGB);
    encoder.set_depth(png::BitDepth::Eight);

    println!(
        "Writing image with resolution {}x{}",
        transformed.cols(),
        transformed.rows()
    );

    let mut writer = encoder.write_header().expect("Failed to write file header");
    if let Some(data) = transformed.data.view().to_slice() {
        writer
            .write_image_data(data)
            .expect("Failed to write image data");
    } else {
        println!("Failed to get image slice");
    }
}
```


Overlapping Code:
```
 {
let lena = get_lena().expect("Couldn't load lena");
// Create transformation matrix
let x = 0.5 * (lena.cols() as f64) - 0.5;
let y = 0.5 * (lena.rows() as f64) - 0.5;
let trans = rotate_around_centre(FRAC_PI_4, (x, y)).dot(&scale(0.7, 0.7));
let transformed = lena
.transform(trans.view(), None)
.expect("Transform failed");
// save
let path = Path::new("transformed_lena.png");
let file = File::create(path).expect("Couldn't create output file");
let ref mut w = BufWriter::new(file);
let mut encoder = png::Encoder::new(w, transformed.cols() as u32, transformed.rows() as u32);
encoder.set_color(png::ColorType::RGB);
encoder.set_depth(png::BitDepth::Eight);
println!(
"Writing image with resolution {}x{}",
transformed.cols(),
transformed.rows()
);
let mut writer = encoder.write_header().expect("Failed to write file header");
if let Some(data) = transformed.data.view().to_slice() {
writer
.write_image_data(data)
.expect("Failed to write image data");
} else {
println!("Failed to get image
```
<Overlap Ratio: 0.9784735812133072>

---

--- 289 --
Question ID: 4afeb688cb231288408e9ae9d2d4728cb9cabc02_0
Original Code:
```
pub(crate) fn load_ssl() -> Result<SslAcceptorBuilder> {
    let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;
    builder.set_private_key_file("ssl_keys/server.pem", SslFiletype::PEM)?;
    builder.set_certificate_chain_file("ssl_keys/crt.pem")?;
    Ok(builder)
}
```


Overlapping Code:
```
cceptorBuilder> {
let mut builder = SslAcceptor::mozilla_intermediate(SslMethod::tls())?;
builder.set_private_key_file("ssl_keys/server.pem", SslFiletype::PEM)?;
builder.set_certificate_chain_file("ssl_k
```
<Overlap Ratio: 0.7490774907749077>

---

--- 290 --
Question ID: bf2d8cdac64eb055d052bdea920faeebf5f0011b_10
Original Code:
```
fn sub() {
        assert_relative_eq!(
            Vector::new(3.0, 2.0, 1.0) - Vector::new(5.0, 6.0, 7.0),
            Vector::new(-2.0, -4.0, -6.0)
        );

        assert_relative_eq!(
            Vector::new(0.0, 0.0, 0.0) - Vector::new(1.0, -2.0, 3.0),
            Vector::new(-1.0, 2.0, -3.0)
        );

        assert_relative_eq!(
            Vector::new(0.5, 1.5, 2.8) - &Vector::new(1.0, 1.0, 0.0),
            Vector::new(-0.5, 0.5, 2.8)
        );

        assert_relative_eq!(
            &Vector::new(-4.1, 0.21, 8.5) - Vector::new(1.2, 0.01, 2.0),
            Vector::new(-5.3, 0.2, 6.5)
        );

        assert_relative_eq!(
            &Vector::new(1.0, 2.0, 3.0) - &Vector::new(2.0, 1.0, 0.0),
            Vector::new(-1.0, 1.0, 3.0)
        );
    }
```


Overlapping Code:
```
w(3.0, 2.0, 1.0) - Vector::new(5.0, 6.0, 7.0),
Vector::new(-2.0, -4.0, -6.0)
);
assert_relative_eq!(
Vector::new(0.0, 0.0, 0.0) - Vector::new(1.0, -2.0, 3.0),
Vector::new(-1.0, 2.0, -3.0)
);
assert_relative_eq!(
Vector::new(0.5, 1.5, 2.8) - &Vector::new(1.0, 1.0, 0.0),
Vector::new(-0.5, 0.5, 2.8)
);
assert_relative_eq!(
&Vector::new(-4.1, 0.21, 8.5) - Vector::new(1.2, 0.01, 2.0),
Vector::new(-5.3, 0.2, 6.5)
);
assert_relative_eq!(
&Vector::new(1.0, 2.0, 3.0) - &Vector::new(2.0, 1.0, 0.0),
Vector
```
<Overlap Ratio: 0.8802816901408451>

---

--- 291 --
Question ID: f9cff1da0060b096947f20d7571f5d66435ec14d_3
Original Code:
```
pub fn flip_vertical<T: Pixel>(src: &Image<T>) -> Image<T> {
    let mut dst = Image::new(src.width(), src.height());
    for h in 0..src.height() {
        for (a, b) in dst.row_mut(src.height() - h - 1).iter_mut().zip(src.row(h)) {
            *a = *b;
        }
    }
    dst
}
```


Overlapping Code:
```
>(src: &Image<T>) -> Image<T> {
let mut dst = Image::new(src.width(), src.height());
for h in 0..src.height() {
for (a, b) in dst.row_mut(src.height() - h - 1).iter_mut().zip(src.row(h)) {
*a = *b;
}

```
<Overlap Ratio: 0.847457627118644>

---

--- 292 --
Question ID: c2479d9e3377377f8cd568468a7f713c938c0a28_1
Original Code:
```
async fn load_bvs<'a, 'b>(bytes: &'a [u8], load_context: &'a mut LoadContext<'b>) -> Result<()> {
	let now = Instant::now();

	let assets = read_bvs(bytes).await?;

	let textures: Vec<_> = assets
		.textures
		.into_iter()
		.enumerate()
		.map(|(i, tex)| load_context.set_labeled_asset(&format!("Tex{}", i), LoadedAsset::new(tex)))
		.collect();

	let bvs_path = load_context.path().to_str().unwrap().to_string();

	let mut meshes = vec![];
	for (name, primitives) in assets.meshes {
		let mut primitive_handles = vec![];
		for (i, (mesh, material)) in primitives.into_iter().enumerate() {
			let mesh = load_context.set_labeled_asset(&format!("{}-Primitive{}", name, i), LoadedAsset::new(mesh));
			let (mat, lazy) = cvt_standard_material(bvs_path.clone(), &material, &textures);
			let material = load_context.set_labeled_asset(&format!("{}-Material{}", name, i), LoadedAsset::new(mat));
			primitive_handles.push((mesh, material, lazy));
		}
		meshes.push(primitive_handles);
	}

	let mut world = World::default();
	world.spawn().insert(LazyTextures { bvs_path: bvs_path.clone(), texcount: textures.len() });

	let nodes = assets.nodes;
	world.spawn().insert_bundle((Transform::identity(), GlobalTransform::identity())).with_children(|parent| {
		for node in nodes {
			if let Some(meshi) = node.meshi {
				for (mesh, material, lazy) in meshes[meshi].clone() {
					parent
						.spawn_bundle(PbrBundle { mesh, material, transform: node.transform, ..Default::default() })
						.insert(lazy);
				}
			}
		}
	});
	load_context.set_labeled_asset("Scene0", LoadedAsset::new(Scene::new(world)));

	println!("bvs {}", now.elapsed().as_secs_f64());

	Ok(())
}
```


Overlapping Code:
```
'b>(bytes: &'a [u8], load_context: &'a mut LoadContext<'b>) -> Result<()> {
let now = Instant::now();
let assets = read_bvs(bytes).await?;
let textures: Vec<_> = assets
.textures
.into_iter()
.enumerate()
.map(|(i, tex)| load_context.set_labeled_asset(&format!("Tex{}", i), LoadedAsset::new(tex)))
.collect();
let bvs_path = load_context.path().to_str().unwrap().to_string();
let mut meshes = vec![];
for (name, primitives) in assets.meshes {
let mut primitive_handles = vec![];
for (i, (mesh, material)) in primitives.into_iter().enumerate() {
let mesh = load_context.set_labeled_asset(&format!("{}-Primitive{}", name, i), LoadedAsset::new(mesh));
let (mat, lazy) = cvt_standard_material(bvs_path.clone(), &material, &textures);
let material = load_context.set_labeled_asset(&format!("{}-Material{}", name, i), LoadedAsset::new(mat));
primitive_handles.push((mesh, material, lazy));
}
meshes.push(primitive_handles);
}
let mut world = World::default();
world.spawn().insert(LazyTextures { bvs_path: bvs_path.clone(), texcount: textures.len() });
let nodes = assets.nodes;
world.spawn().insert_bundle((Transform::identity(), GlobalTransform::identity())).with_children(|parent| {
for node in nodes {
if let Some(meshi) = node.meshi {
for (mesh, material, lazy) in meshes[meshi].clone() {
parent
.spawn_bundle(PbrBundle { mesh, material, transform: node.transform, ..Default::default() })
.insert(lazy);
}
}
}
});
load_context.set_labeled_asset("Scene0", LoadedAsset::new(Scene::new(world)));
println!("bvs
```
<Overlap Ratio: 0.9579885423297263>

---

--- 293 --
Question ID: 90737d3a430e73372d49b9255b1a071d04c431ce_10
Original Code:
```
fn get_inbound_ruleset_details<T: HerokuApiClient>(api_client: &T) {
    let space_id = "123";
    let ruleset_id = "123";
    let space = &space::InboundRulesetDetails::new(space_id, ruleset_id);
    let response = api_client.request(space);

    print_response(response);
}
```


Overlapping Code:
```
_details<T: HerokuApiClient>(api_client: &T) {
let space_id = "123";
let ruleset_id = "123";
let space = &space::InboundRulesetDetails::new(space_id, ruleset_id);
let response = api_client.request(space);
print_response(response);

```
<Overlap Ratio: 0.9094488188976378>

---

--- 294 --
Question ID: 74fcd7fafc603ce8fb8012fc53f0eee8d41b3d80_2
Original Code:
```
fn best_asteroids_example_three() {
        let input = "\
#.#...#.#.
.###....#.
.#....#...
##.#.#.#.#
....#.#.#.
.##..###.#
..#...##..
..##....##
......#...
.####.###.";

        let map = Map::parse_map(input);
        assert_eq!(map.find_best_asteroid(), Some((Point(1, 2), 35)))
    }
```


Overlapping Code:
```
ree() {
let input = "\
#.#...#.#.
.###....#.
.#....#...
##.#.#.#.#
....#.#.#.
.##..###.#
..#...##..
..##....##
......#...
.####.###.";
let map = Map::parse_map(input);
assert_eq!(map.find_best_asteroi
```
<Overlap Ratio: 0.7722007722007722>

---

--- 295 --
Question ID: 1cabd56d2d18368ee0fa1f80d4ec95d3b159a436_1
Original Code:
```
async fn accept_connection(
    stream: TcpStream,
    peer_map: Arc<Mutex<HashMap<String, UnboundedSender<Message>>>>,
) {
    let addr = stream
        .peer_addr()
        .expect("connected streams should have a peer address");
    println!("Peer address: {}", addr);
    let local_addr = format!("{:?}", stream.local_addr());

    let ws_stream = tokio_tungstenite::accept_async(stream)
        .await
        .expect("Error during the websocket handshake occurred");

    println!("New WebSocket connection: {}", addr);

    let (tx, rx) = unbounded();
    peer_map.lock().unwrap().insert(local_addr.clone(), tx);
    let mut client_id = None;

    let (outgoing, incoming) = ws_stream.split();

    let broadcast_incoming = incoming.try_for_each(|msg| {
        println!("{:?}", msg);
        if let Message::Text(text) = msg {
            let mut peers = peer_map.lock().unwrap();
            if client_id.is_none() {
                let tx = peers.remove(&local_addr).unwrap();
                peers.insert(text.clone(), tx);
                println!("{} registered.", text);
                client_id = Some(text);
            } else {
                //转发消息
                if let Ok(Value::Object(map)) = serde_json::from_str::<Value>(&text) {
                    if let Some(Value::String(target)) = map.get("target") {
                        if let Some(tx) = peers.get_mut(target) {
                            let msg = Message::Binary(vec![
                                get_as_u8(&map, "r"),
                                get_as_u8(&map, "g"),
                                get_as_u8(&map, "b"),
                            ]);
                            println!("send {:?} to {}", msg, target);
                            tx.unbounded_send(msg).unwrap();
                        }
                    }
                }
            }
        }
        future::ok(())
    });

    let receive_from_others = rx.map(Ok).forward(outgoing);

    pin_mut!(broadcast_incoming, receive_from_others);
    future::select(broadcast_incoming, receive_from_others).await;

    println!("{:?} disconnected", client_id);
    if let Some(client_id) = client_id {
        peer_map.lock().unwrap().remove(&client_id);
    }
}
```


Overlapping Code:
```
accept_connection(
stream: TcpStream,
peer_map: Arc<Mutex<HashMap<String, UnboundedSender<Message>>>>,
) {
let addr = stream
.peer_addr()
.expect("connected streams should have a peer address");
println!("Peer address: {}", addr);
let local_addr = format!("{:?}", stream.local_addr());
let ws_stream = tokio_tungstenite::accept_async(stream)
.await
.expect("Error during the websocket handshake occurred");
println!("New WebSocket connection: {}", addr);
let (tx, rx) = unbounded();
peer_map.lock().unwrap().insert(local_addr.clone(), tx);
let mut client_id = None;
let (outgoing, incoming) = ws_stream.split();
let broadcast_incoming = incoming.try_for_each(|msg| {
println!("{:?}", msg);
if let Message::Text(text) = msg {
let mut peers = peer_map.lock().unwrap();
if client_id.is_none() {
let tx = peers.remove(&local_addr).unwrap();
peers.insert(text.clone(), tx);
println!("{} registered.", text);
client_id = Some(text);
} else {
//转发消息
if let Ok(Value::Object(map)) = serde_json::from_str::<Value>(&text) {
if let Some(Value::String(target)) = map.get("target") {
if let Some(tx) = peers.get_mut(target) {
let msg = Message::Binary(vec![
get_as_u8(&map, "r"),
get_as_u8(&map, "g"),
get_as_u8(&map, "b"),
]);
println!("send {:?} to {}", msg, target);
tx.unbounded_send(msg).unwrap();
}
}
}
}
}
future::ok(())
});
let receive_from_others = rx.map(Ok).forward(outgoing);
pin_mut!(broadcast_incoming, receive_from_others);
future::select(broadcast_incoming, receive_from_others).await;
println!("{:?} disconnected", client_id);
if let Some(client_id) = client_id {
peer_map.lock().unwrap().remove(
```
<Overlap Ratio: 0.9846153846153847>

---

--- 296 --
Question ID: e651dc1361ac8e20e4ca80ec309dc43550ff7700_1
Original Code:
```
fn get_last_present_count(&self) -> Result<UINT, MethodError> {
        let mut count = 0;
        let hr = unsafe { self.as_winapi().GetLastPresentCount(&mut count) };
        MethodError::check("IDirect3DSwapChain9Ex::GetLastPresentCount", hr)?;
        Ok(count)
    }
```


Overlapping Code:
```
elf) -> Result<UINT, MethodError> {
let mut count = 0;
let hr = unsafe { self.as_winapi().GetLastPresentCount(&mut count) };
MethodError::check("IDirect3DSwapChain9Ex::GetLastPresentCount", hr)?;
Ok(c
```
<Overlap Ratio: 0.851063829787234>

---

--- 297 --
Question ID: 5a68a94951885d440ff1e2aa9d37f6728f507942_499
Original Code:
```
fn __action454<
    'input,
>(
    input: &'input str,
    __0: (usize, &'input str, usize),
) -> Expression
{
    let __start0 = __0.2.clone();
    let __end0 = __0.2.clone();
    let __temp0 = __action227(
        input,
        &__start0,
        &__end0,
    );
    let __temp0 = (__start0, __temp0, __end0);
    __action345(
        input,
        __0,
        __temp0,
    )
}
```


Overlapping Code:
```
<
'input,
>(
input: &'input str,
__0: (usize, &'input str, usize),
) -> Expression
{
let __start0 = __0.2.clone();
let __end0 = __0.2.clone();
let __temp0 = __action227(
input,
&__start0,
&__end0,
);
let __temp0 = (__start0, __temp0, __end0);
__action345(
input,
__0,
__temp0,
)
```
<Overlap Ratio: 0.9455782312925171>

---

--- 298 --
Question ID: d5f7914aa6c2ec9a0fe708bf4d43d61423d24ebe_15
Original Code:
```
pub async fn location_update_address_by_id_json(
     path: web::Path<i32>
   , data: web::Json<Option<String>>
   , pool: web::Data<DbPool>
  ) -> Result<HttpResponse,actix_web::Error> {

    let conn = pool.get().expect("couldn't get db connection from pool");

    let id = *path;
    // use web::block to offload blocking Diesel code without blocking server thread
    web::block(move || location_update_address_by_id(data.as_deref(), id, &conn))
        .await
        .map_err(|e| {
            eprintln!("{}", e);
            HttpResponse::InternalServerError().finish()
        })?;

    location_address_by_id_json(path,pool).await
}
```


Overlapping Code:
```
ss_by_id_json(
path: web::Path<i32>
, data: web::Json<Option<String>>
, pool: web::Data<DbPool>
) -> Result<HttpResponse,actix_web::Error> {
let conn = pool.get().expect("couldn't get db connection from pool");
let id = *path;
// use web::block to offload blocking Diesel code without blocking server thread
web::block(move || location_update_address_by_id(data.as_deref(), id, &conn))
.await
.map_err(|e| {
eprintln!("{}", e);
HttpResponse::InternalServerError().finish()
})?;
location_address_by_id
```
<Overlap Ratio: 0.8960573476702509>

---

--- 299 --
Question ID: 03d04b810d9d8171b72291c9178095bf04f065dd_1
Original Code:
```
fn connects_matrix__neg(from: Syllable, to: Syllable, from_i: u8, to_i: u8) {
        assert_eq!(from.jnext.bits(), from_i);
        assert_eq!(to.jprevious.bits(), to_i);
        assert!(!from.connects(&to));
    }
```


Overlapping Code:
```
 Syllable, from_i: u8, to_i: u8) {
assert_eq!(from.jnext.bits(), from_i);
assert_eq!(to.jprevious.bits(), to_i
```
<Overlap Ratio: 0.5882352941176471>

---

--- 300 --
Question ID: 1ea14478987993f91371bf19ab20b740001ae85f_0
Original Code:
```
pub fn parse_video_information(html: &str) -> Result<VideoInformation> {
    let document = Html::parse_document(html);

    let video_id = try_select_attribute(&document, &ID_SELECTOR, "content")?;
    let url = try_select_attribute(&document, &URL_SELECTOR, "href")?;
    let author = try_select_attribute(&document, &CHANNEL_SELECTOR, "content")?;
    let title = try_select_attribute(&document, &TITLE_SELECTOR, "content")?;
    let thumbnail = try_select_attribute(&document, &THUMBNAIL_SELECTOR, "content").ok();

    Ok(VideoInformation {
        id: video_id.to_string(),
        url: url.to_string(),
        title: title.to_string(),
        uploader: author.to_string(),
        thumbnail: thumbnail.map(|s| s.to_string()),
    })
}
```


Overlapping Code:
```
rse_video_information(html: &str) -> Result<VideoInformation> {
let document = Html::parse_document(html);
let video_id = try_select_attribute(&document, &ID_SELECTOR, "content")?;
let url = try_select_attribute(&document, &URL_SELECTOR, "href")?;
let author = try_select_attribute(&document, &CHANNEL_SELECTOR, "content")?;
let title = try_select_attribute(&document, &TITLE_SELECTOR, "content")?;
let thumbnail = try_select_attribute(&document, &THUMBNAIL_SELECTOR, "content").ok();
Ok(VideoInformation {
id: video_id.to_string(),
url: url.to_string(),
title: title.to_string(),
uploader: author.to_string(),
thumbnail: thumbnail.map(|s| s.to_strin
```
<Overlap Ratio: 0.9715994020926756>

---

--- 301 --
Question ID: 9344eb8fa3ae39ba4da49b746909260eabdd6dc2_7
Original Code:
```
fn make_system_notifications_adjustment_row() -> impl Widget<TomataState> {
    let description_label = Label::new("Use system notifications:");
    let switch = Switch::new();
    let switch = LensWrap::new(switch, Settings::system_notifications_are_enabled);
    let switch = LensWrap::new(switch, TomataState::settings);
    Flex::row()
        .with_child(description_label)
        .with_flex_child(Align::right(switch), 1.0)
}
```


Overlapping Code:
```
tment_row() -> impl Widget<TomataState> {
let description_label = Label::new("Use system notifications:");
let switch = Switch::new();
let switch = LensWrap::new(switch, Settings::system_notifications_are_enabled);
let switch = LensWrap::new(switch, TomataState::settings);
Flex::row()
.with_child(description_label)
.with_flex_child(Align::right(switch), 1.0)
}
```
<Overlap Ratio: 0.9141414141414141>

---

--- 302 --
Question ID: 7d16ae909a3f7f8de4d4c26522585bc28700c01e_12
Original Code:
```
fn send_low_mtu() {
    let mut server = OpenSSLServer::new_rsa(9110);
    server.run();

    server.client()
        .mtu(128)
        .expect("Ciphers common between both SSL end points")
        .go();
}
```


Overlapping Code:
```
Server::new_rsa(9110);
server.run();
server.client()
.mtu(128)
.expect("Ciphers common between both 
```
<Overlap Ratio: 0.591715976331361>

---

--- 303 --
Question ID: bc16bef8b5259cd706f1d32c6c92af27a34bed17_3
Original Code:
```
async fn run_loop(client: &mut Client, config: Config) -> anyhow::Result<()> {
    let (mqtt_sender, mqtt_receiver) = mpsc::unbounded_channel();
    let (mqtt_event_sender, _) = broadcast::channel(10);
    let (state_sender, state_receiver) = mpsc::unbounded_channel();

    let mut mqtt_worker = MqttWorker::new(client, mqtt_receiver, mqtt_event_sender.clone());
    let mut hass_discovery_worker = HomeAssistantWorker::new(mqtt_sender.clone());
    let mut state = State::new(mqtt_sender.clone(), state_receiver);
    let mut idle_module = IdleModule::new(state_sender.clone());
    let mut backlight_module = if let Some(backlight) = config.modules.backlight {
        get_backlight_module(state_sender.clone(), mqtt_event_sender.subscribe(), backlight)
    }else {
        Box::new(EmptyWorker) as Box<dyn LocalWorker>
    };
    let mut notifications_module = NotificationsModule::new(mqtt_event_sender.subscribe(), mqtt_sender);
    let mut sensors_module = SensorsModule::new(state_sender.clone());

    tokio::try_join!(
        mqtt_worker.run(&config),
        hass_discovery_worker.run(&config),
        state.run(&config),
        idle_module.run(&config),
        backlight_module.run(&config),
        notifications_module.run(&config),
        sensors_module.run(&config),
    )?;

    Ok(())
}
```


Overlapping Code:
```
onfig) -> anyhow::Result<()> {
let (mqtt_sender, mqtt_receiver) = mpsc::unbounded_channel();
let (mqtt_event_sender, _) = broadcast::channel(10);
let (state_sender, state_receiver) = mpsc::unbounded_channel();
let mut mqtt_worker = MqttWorker::new(client, mqtt_receiver, mqtt_event_sender.clone());
let mut hass_discovery_worker = HomeAssistantWorker::new(mqtt_sender.clone());
let mut state = State::new(mqtt_sender.clone(), state_receiver);
let mut idle_module = IdleModule::new(state_sender.clone());
let mut backlight_module = if let Some(backlight) = config.modules.backlight {
get_backlight_module(state_sender.clone(), mqtt_event_sender.subscribe(), backlight)
}else {
Box::new(EmptyWorker) as Box<dyn LocalWorker>
};
let mut notifications_module = NotificationsModule::new(mqtt_event_sender.subscribe(), mqtt_sender);
let mut sensors_module = SensorsModule::new(state_sender.clone());
tokio::try_join!(
mqtt_worker.run(&config),
hass_discovery_worker.run(&config),
state.run(&config),
idle_module.run(&config),
backlight_module.run(&config),
notifications_module.run(&config),
sensors_module.
```
<Overlap Ratio: 0.9369676320272572>

---

--- 304 --
Question ID: a5dea9d5fea1f6f8165a1665f74f310adddbb7f4_1
Original Code:
```
fn pattern_to_number(pattern: &str, alphabet: &[char]) -> Result<usize, Error> {
    let num_alphabets = alphabet.len();
    let alphabet_map: HashMap<char, char> = alphabet
        .iter()
        .enumerate()
        .map(|(n, c)| {
            (
                *c,
                char::from_digit(n as u32, num_alphabets as u32)
                    .unwrap()
                    .to_ascii_uppercase(),
            )
        })
        .collect();
    Ok(RadixNum::from_str(
        &pattern
            .chars()
            .map(|c| alphabet_map[&c])
            .collect::<String>(),
        num_alphabets,
    )?
        .as_decimal()?)
}
```


Overlapping Code:
```
, alphabet: &[char]) -> Result<usize, Error> {
let num_alphabets = alphabet.len();
let alphabet_map: HashMap<char, char> = alphabet
.iter()
.enumerate()
.map(|(n, c)| {
(
*c,
char::from_digit(n as u32, num_alphabets as u32)
.unwrap()
.to_ascii_uppercase(),
)
})
.collect();
Ok(RadixNum::from_str(
&pattern
.chars()
.map(|c| alphabet_map[&c])
.collect
```
<Overlap Ratio: 0.8083140877598153>

---

--- 305 --
Question ID: 7fd46080a235e03361e873a3167fb0002f882258_0
Original Code:
```
pub unsafe fn create_vertex_array_object() -> GLuint {
    let vertices: [f32; 180] = [
         -0.5, -0.5, -0.5,  0.0, 0.0,
          0.5, -0.5, -0.5,  1.0, 0.0,
          0.5,  0.5, -0.5,  1.0, 1.0,
          0.5,  0.5, -0.5,  1.0, 1.0,
         -0.5,  0.5, -0.5,  0.0, 1.0,
         -0.5, -0.5, -0.5,  0.0, 0.0,

         -0.5, -0.5,  0.5,  0.0, 0.0,
          0.5, -0.5,  0.5,  1.0, 0.0,
          0.5,  0.5,  0.5,  1.0, 1.0,
          0.5,  0.5,  0.5,  1.0, 1.0,
         -0.5,  0.5,  0.5,  0.0, 1.0,
         -0.5, -0.5,  0.5,  0.0, 0.0,

         -0.5,  0.5,  0.5,  1.0, 0.0,
         -0.5,  0.5, -0.5,  1.0, 1.0,
         -0.5, -0.5, -0.5,  0.0, 1.0,
         -0.5, -0.5, -0.5,  0.0, 1.0,
         -0.5, -0.5,  0.5,  0.0, 0.0,
         -0.5,  0.5,  0.5,  1.0, 0.0,

          0.5,  0.5,  0.5,  1.0, 0.0,
          0.5,  0.5, -0.5,  1.0, 1.0,
          0.5, -0.5, -0.5,  0.0, 1.0,
          0.5, -0.5, -0.5,  0.0, 1.0,
          0.5, -0.5,  0.5,  0.0, 0.0,
          0.5,  0.5,  0.5,  1.0, 0.0,

         -0.5, -0.5, -0.5,  0.0, 1.0,
          0.5, -0.5, -0.5,  1.0, 1.0,
          0.5, -0.5,  0.5,  1.0, 0.0,
          0.5, -0.5,  0.5,  1.0, 0.0,
         -0.5, -0.5,  0.5,  0.0, 0.0,
         -0.5, -0.5, -0.5,  0.0, 1.0,

         -0.5,  0.5, -0.5,  0.0, 1.0,
          0.5,  0.5, -0.5,  1.0, 1.0,
          0.5,  0.5,  0.5,  1.0, 0.0,
          0.5,  0.5,  0.5,  1.0, 0.0,
         -0.5,  0.5,  0.5,  0.0, 0.0,
         -0.5,  0.5, -0.5,  0.0, 1.0
    ];

    let (mut vbo, mut vao) = (0, 0);
    gl::GenVertexArrays(1, &mut vao);
    gl::GenBuffers(1, &mut vbo);

    gl::BindVertexArray(vao);

    gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
    gl::BufferData(
        gl::ARRAY_BUFFER,
        (vertices.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,
        &vertices[0] as *const f32 as *const c_void,
        gl::STATIC_DRAW,
    );

    let stride = 5 * mem::size_of::<GLfloat>() as GLsizei;
    // position attribute
    gl::VertexAttribPointer(0, 3, gl::FLOAT, gl::FALSE, stride, ptr::null());
    gl::EnableVertexAttribArray(0);
    // texture coord attribute
    gl::VertexAttribPointer(
        1,
        2,
        gl::FLOAT,
        gl::FALSE,
        stride,
        (3 * mem::size_of::<GLfloat>()) as *const c_void,
    );
    gl::EnableVertexAttribArray(1);

    return vao;
}
```


Overlapping Code:
```
_vertex_array_object() -> GLuint {
let vertices: [f32; 180] = [
-0.5, -0.5, -0.5, 0.0, 0.0,
0.5, -0.5, -0.5, 1.0, 0.0,
0.5, 0.5, -0.5, 1.0, 1.0,
0.5, 0.5, -0.5, 1.0, 1.0,
-0.5, 0.5, -0.5, 0.0, 1.0,
-0.5, -0.5, -0.5, 0.0, 0.0,
-0.5, -0.5, 0.5, 0.0, 0.0,
0.5, -0.5, 0.5, 1.0, 0.0,
0.5, 0.5, 0.5, 1.0, 1.0,
0.5, 0.5, 0.5, 1.0, 1.0,
-0.5, 0.5, 0.5, 0.0, 1.0,
-0.5, -0.5, 0.5, 0.0, 0.0,
-0.5, 0.5, 0.5, 1.0, 0.0,
-0.5, 0.5, -0.5, 1.0, 1.0,
-0.5, -0.5, -0.5, 0.0, 1.0,
-0.5, -0.5, -0.5, 0.0, 1.0,
-0.5, -0.5, 0.5, 0.0, 0.0,
-0.5, 0.5, 0.5, 1.0, 0.0,
0.5, 0.5, 0.5, 1.0, 0.0,
0.5, 0.5, -0.5, 1.0, 1.0,
0.5, -0.5, -0.5, 0.0, 1.0,
0.5, -0.5, -0.5, 0.0, 1.0,
0.5, -0.5, 0.5, 0.0, 0.0,
0.5, 0.5, 0.5, 1.0, 0.0,
-0.5, -0.5, -0.5, 0.0, 1.0,
0.5, -0.5, -0.5, 1.0, 1.0,
0.5, -0.5, 0.5, 1.0, 0.0,
0.5, -0.5, 0.5, 1.0, 0.0,
-0.5, -0.5, 0.5, 0.0, 0.0,
-0.5, -0.5, -0.5, 0.0, 1.0,
-0.5, 0.5, -0.5, 0.0, 1.0,
0.5, 0.5, -0.5, 1.0, 1.0,
0.5, 0.5, 0.5, 1.0, 0.0,
0.5, 0.5, 0.5, 1.0, 0.0,
-0.5, 0.5, 0.5, 0.0, 0.0,
-0.5, 0.5, -0.5, 0.0, 1.0
];
let (mut vbo, mut vao) = (0, 0);
gl::GenVertexArrays(1, &mut vao);
gl::GenBuffers(1, &mut vbo);
gl::BindVertexArray(vao);
gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
gl::BufferData(
gl::ARRAY_BUFFER,
(vertices.len() * mem::size_of::<GLfloat>()) as GLsizeiptr,
&vertices[0] as *const f32 as *const c_void,
gl::STATIC_DRAW,
);
let stride = 5 * mem::size_of::<GLfloat>() as GLsizei;
// position attribute
gl::VertexAttribPointer(0, 3, gl::FLOAT, gl::FALSE, stride, ptr::null());
gl::EnableVertexAttribArray(0);
// texture coord attribute
gl::VertexAttribPointer(
1,
2,
gl::FLOAT,
gl::FALSE,
stride,
(3 * mem::size_of::<GLfloat>()) as *const c_void,
);
gl::EnableVertexAttribArray(1);
retu
```
<Overlap Ratio: 0.9832272990167727>

---

--- 306 --
Question ID: 4c8b5e3ed9c0b342b6c70f4a8d73064e20a3ef4a_4
Original Code:
```
fn test_get_data_ok() {
        // prepare
        let test_ok = create_test_config();

        // launch test and check result
        match get_data(&test_ok) {
            // TODO: better test here
            Ok(data) => assert_ne!(data["stats"]["user_count"], 0),
            Err(e) => panic!(e),
        }
    }
```


Overlapping Code:
```
() {
// prepare
let test_ok = create_test_config();
// launch test and check result
match get_data(&test_ok) {
// TODO: better test here
Ok(data) => assert_ne!(data["stats"]["user_count"], 0),
Err(e) => 
```
<Overlap Ratio: 0.8601694915254238>

---

--- 307 --
Question ID: 167bfa131b24aa234d655fab9eea8d6f38a1c8dd_0
Original Code:
```
fn test_it() -> Result<(), String> {

        //tag::report-testdata[]
        let vec1 = vec![
            199,
            200,
            208,
            210,
            200,
            207,
            240,
            269,
            260,
            263
        ];
        //end::report-testdata[] 

        //tag::test-calculate-increases[]
        assert_eq!(calculate_increases(&vec1).unwrap(), 7);
        //end::test-calculate-increases[]
        
        //tag::test-calculate-window[]
        let vec2 = calculate_window(&vec1).unwrap();
        assert_eq!(calculate_increases(&vec2).unwrap(), 5);
        //end::test-calculate-window[]

        Ok(())
    }
```


Overlapping Code:
```
 -> Result<(), String> {
//tag::report-testdata[]
let vec1 = vec![
199,
200,
208,
210,
200,
207,
240,
269,
260,
263
];
//end::report-testdata[] 
//tag::test-calculate-increases[]
assert_eq!(calculate_increases(&vec1).unwrap(), 7);
//end::test-calculate-increases[]

//tag::test-calculate-window[]
let vec2 = calculate_window(&vec1).unwrap();
assert_eq!(calculate_increases(&vec2).unwrap(), 5);
//end:
```
<Overlap Ratio: 0.898876404494382>

---

--- 308 --
Question ID: 848e89ba564c377dee99981595d960e969b2b111_1
Original Code:
```
fn pseudo_element_style(
    _which: WhichPseudoElement,
    _element: NodeId,
    _element_style: &ComputedValues,
    _context: &Context,
) -> Option<Arc<ComputedValues>> {
    // FIXME: run the cascade, then return None for `content: normal` or `content: none`
    // https://drafts.csswg.org/css2/generate.html#content
    None
}
```


Overlapping Code:
```

_which: WhichPseudoElement,
_element: NodeId,
_element_style: &ComputedValues,
_context: &Context,
) -> Option<Arc<ComputedValues>> {
// FIXME: run the cascade, then return None for `content: normal` or `content: none`
// https://drafts.csswg.org/cs
```
<Overlap Ratio: 0.819672131147541>

---

--- 309 --
Question ID: a13d280ea3f136730edd34ac4eda6f2718fabe94_0
Original Code:
```
fn spawn_rayto_point(&self, p2: &Point3f) -> Ray {
        let o = offset_ray_origin(&self.p(), &self.p_error(), &self.n(), &(*p2 - self.p()));
        let d = *p2 - self.p();

        Ray::new(&o, &d, 1.0 - SHADOW_EPSILON, self.time(), self.get_medium_vec(&d), None)
    }
```


Overlapping Code:
```
wn_rayto_point(&self, p2: &Point3f) -> Ray {
let o = offset_ray_origin(&self.p(), &self.p_error(), &self.n(), &(*p2 - self.p()));
let d = *p2 - self.p();
Ray::new(&o, &d, 1.0 - SHADOW_EPSILON, self.time(), self.get_medium_
```
<Overlap Ratio: 0.9098360655737705>

---

--- 310 --
Question ID: c73d8822d7b3e13fe4df61de9075755154e39cac_1
Original Code:
```
pub fn circular_tuple_windows<I, T>(iter: I) -> CircularTupleWindows<I, T>
    where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,
          T: TupleCollect + Clone,
          T::Item: Clone
{
    let len = iter.len();
    let iter = tuple_windows(iter.cycle()).take(len);

    CircularTupleWindows {
        iter,
        phantom_data: PhantomData{}
    }
}
```


Overlapping Code:
```
CircularTupleWindows<I, T>
where I: Iterator<Item = T::Item> + Clone + ExactSizeIterator,
T: TupleCollect + Clone,
T::Item: Clone
{
let len = iter.len();
let iter = tuple_windows(iter.cycle()).take(len);
CircularTupleWindows {
iter,
phantom_data: Pha
```
<Overlap Ratio: 0.8012820512820513>

---

--- 311 --
Question ID: e0dfd43e1ffda46aaadebcdd7fdca1f8011858a4_1
Original Code:
```
fn addi() {
    let word: u32 = 0x12358513;

    let instruction = decode(word).unwrap();

    assert_eq!(*instruction.op(), Op::Addi);
    assert_eq!(*instruction.rd(), Register::A0);
    assert_eq!(*instruction.rs1(), Register::A1);
    assert_eq!(instruction.immediate(), 0x123);
}
```


Overlapping Code:
```
;
let instruction = decode(word).unwrap();
assert_eq!(*instruction.op(), Op::Addi);
assert_eq!(*instruction.rd(), Register::A0);
assert_eq!(*instruction.rs1(), Register::A1);
assert_eq!(instruction.immediate
```
<Overlap Ratio: 0.8023255813953488>

---

--- 312 --
Question ID: c9ad3df0013ccf4e8849203fdec35bc95055d7d3_0
Original Code:
```
pub fn parser(tokens: TokenStream) -> TokenStream {
    use std::io::Read;
    use std::str::FromStr;
    let mut file = format(proc_macro2::TokenStream::from(tokens));
    let _ = file.pop();
    let root = env!("CARGO_MANIFEST_DIR");
    let file = format!("{}/../src/{}", root, &file[1..]);
    println!("{}", file);
    let mut file = std::fs::File::open(&file).expect("Unable to open file");
    let mut src = String::new();
    file.read_to_string(&mut src).expect("Unable to read file");
    let syntax = TokenStream::from_str(&src).expect("Unable to parse file");
    parse(syntax)
}
```


Overlapping Code:
```
TokenStream) -> TokenStream {
use std::io::Read;
use std::str::FromStr;
let mut file = format(proc_macro2::TokenStream::from(tokens));
let _ = file.pop();
let root = env!("CARGO_MANIFEST_DIR");
let file = format!("{}/../src/{}", root, &file[1..]);
println!("{}", file);
let mut file = std::fs::File::open(&file).expect("Unable to open file");
let mut src = String::new();
file.read_to_string(&mut src).expect("Unable to read file");
let syntax = TokenStream::from_str(&src).expect("Unable to parse fi
```
<Overlap Ratio: 0.9208103130755064>

---

--- 313 --
Question ID: b3be688e3f9079e7e5780ba86fb433a6b2eb77e5_71
Original Code:
```
fn brow_cap_remote() {
        let mut ch_op = ChromeOptions::new();
        ch_op.add_args(vec!["--headless","--window-size=500,1000"]);
        ch_op.add_mobile_emulation(MobileDevice::standard_device("Nexus 6"));
        let mut c = Capabilities::new(BrowserName::Chrome, "linux");
        c.set_chrome_options(ch_op);
        let mut br = Browser::start_remote_session_with_capabilities(c,"192.168.1.67","4444").unwrap();
        br.open("https://vk.com").unwrap();
        br.open("https://github.com").unwrap();
        let link = br.get_link().unwrap();
        assert!(link.contains("hub"));
        br.close_browser().unwrap();
    }
```


Overlapping Code:
```
t mut ch_op = ChromeOptions::new();
ch_op.add_args(vec!["--headless","--window-size=500,1000"]);
ch_op.add_mobile_emulation(MobileDevice::standard_device("Nexus 6"));
let mut c = Capabilities::new(BrowserName::Chrome, "linux");
c.set_chrome_options(ch_op);
let mut br = Browser::start_remote_session_with_capabilities(c,"192.168.1.67","4444").unwrap();
br.open("https://vk.com").unwrap();
br.open("https://github.com").unwrap();
let link = br.get_link().unwrap();
assert!(link.contains("hub"));
br.cl
```
<Overlap Ratio: 0.9090909090909091>

---

--- 314 --
Question ID: 9d2190c763e84333cf2077c6c68424f35afd1af1_284
Original Code:
```
fn bindgen_test_layout_ble_opt_t() {
    assert_eq!(
        ::core::mem::size_of::<ble_opt_t>(),
        8usize,
        concat!("Size of: ", stringify!(ble_opt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ble_opt_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ble_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).common_opt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_opt_t),
            "::",
            stringify!(common_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ble_opt_t>())).gap_opt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ble_opt_t),
            "::",
            stringify!(gap_opt)
        )
    );
}
```


Overlapping Code:
```
ndgen_test_layout_ble_opt_t() {
assert_eq!(
::core::mem::size_of::<ble_opt_t>(),
8usize,
concat!("Size of: ", stringify!(ble_opt_t))
);
assert_eq!(
::core::mem::align_of::<ble_opt_t>(),
4usize,
concat!("Alignment of ", stringify!(ble_opt_t))
);
assert_eq!(
unsafe { &(*(::core::ptr::null::<ble_opt_t>())).common_opt as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(ble_opt_t),
"::",
stringify!(common_opt)
)
);
assert_eq!(
unsafe { &(*(::core::ptr::null::<ble_opt_t>())).gap_opt as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(ble_opt_t),
"::",
string
```
<Overlap Ratio: 0.96>

---

--- 315 --
Question ID: 030b292def66396e54e16589379f12b870634539_1
Original Code:
```
fn foo(c: foo::Context) {
        static mut STATE: bool = false;

        gpio::set_out_xor(if *STATE { gpio::RED } else { 0 });
        *STATE = !*STATE;

        c.schedule.foo(c.scheduled + Duration::from_secs(1)).ok();
    }
```


Overlapping Code:
```
E: bool = false;
gpio::set_out_xor(if *STATE { gpio::RED } else { 0 });
*STATE = !*STATE;
c.schedule.foo(c.scheduled + Duration::from_secs(1)).ok();
}
```
<Overlap Ratio: 0.7853403141361257>

---

--- 316 --
Question ID: a1ee9c5339e44a345a945f02fc233658c7c9a685_0
Original Code:
```
pub fn parse_binary(input: &[u8]) -> Result<Module, ParseError> {
    let mut builder = Module::builder();

    let (input, _) = tuple((tag(PREAMBLE), tag(VERSION)))(input)?;

    let (input, custom_sections) =
        parse_custom_section(input).map_err(|_| ParseError::InvalidBinary)?;
    builder.set_custom_sections(ModuleSection::Custom, custom_sections);

    let (input, types) = parse_type_section(input)?;
    builder.set_function_types(types);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Type, custom_sections);

    let (input, imports) = parse_import_section(input)?;
    builder.set_imports(imports);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Import, custom_sections);

    let (input, signatures) = parse_function_section(input)?;

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Function, custom_sections);

    let (input, tables) = parse_table_section(input)?;
    builder.set_tables(tables);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Table, custom_sections);

    let (input, memories) = parse_memory_section(input)?;
    builder.set_memories(memories);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Memory, custom_sections);

    let (input, globals) = parse_global_section(input)?;
    builder.set_globals(globals);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Global, custom_sections);

    let (input, exports) = parse_export_section(input)?;
    builder.set_exports(exports);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Export, custom_sections);

    let (input, start) = parse_start_section(input)?;
    builder.set_start(start);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Start, custom_sections);

    let (input, elements) = parse_element_section(input)?;
    builder.set_elements(elements);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Element, custom_sections);

    let (input, data_count) = parse_data_count_section(input)?;
    builder.set_data_count(data_count);

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::DataCount, custom_sections);

    let (input, codes) = parse_code_section(input)?;

    validate_function_counts(codes.as_ref(), signatures.as_ref())?;

    builder.set_functions(zip_functions(signatures, codes));

    let (input, custom_sections) = parse_custom_section(input)?;
    builder.set_custom_sections(ModuleSection::Code, custom_sections);

    let (input, data) = parse_data_section(input)?;
    builder.set_data(data);

    let (_, custom_sections) = all_consuming(parse_custom_section)(input)?;
    builder.set_custom_sections(ModuleSection::Data, custom_sections);

    Ok(builder.build())
}
```


Overlapping Code:
```
le, ParseError> {
let mut builder = Module::builder();
let (input, _) = tuple((tag(PREAMBLE), tag(VERSION)))(input)?;
let (input, custom_sections) =
parse_custom_section(input).map_err(|_| ParseError::InvalidBinary)?;
builder.set_custom_sections(ModuleSection::Custom, custom_sections);
let (input, types) = parse_type_section(input)?;
builder.set_function_types(types);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Type, custom_sections);
let (input, imports) = parse_import_section(input)?;
builder.set_imports(imports);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Import, custom_sections);
let (input, signatures) = parse_function_section(input)?;
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Function, custom_sections);
let (input, tables) = parse_table_section(input)?;
builder.set_tables(tables);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Table, custom_sections);
let (input, memories) = parse_memory_section(input)?;
builder.set_memories(memories);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Memory, custom_sections);
let (input, globals) = parse_global_section(input)?;
builder.set_globals(globals);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Global, custom_sections);
let (input, exports) = parse_export_section(input)?;
builder.set_exports(exports);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Export, custom_sections);
let (input, start) = parse_start_section(input)?;
builder.set_start(start);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Start, custom_sections);
let (input, elements) = parse_element_section(input)?;
builder.set_elements(elements);
let (input, custom_sections) = parse_custom_section(input)?;
builder.set_custom_sections(ModuleSection::Element, custom_sections);
let (input, data_count) = parse_data_count_section(input)?;
builder.set_dat
```
<Overlap Ratio: 0.9757155247181266>

---

--- 317 --
Question ID: 465b02dd931a87a7d6e06b0c9451298db0f6d3b2_0
Original Code:
```
pub fn register_debug_actions(context: &AgentContext) {
    debug!(context.logger, "Registering debug actions");
    ACTIONS::register_reserved(Fail {});
    ACTIONS::register_reserved(Progress {});
    ACTIONS::register_reserved(Success {});
}
```


Overlapping Code:
```
tContext) {
debug!(context.logger, "Registering debug actions");
ACTIONS::register_reserved(Fail {});
ACTIONS::register_reserved(Progress {});
ACTIONS
```
<Overlap Ratio: 0.6578947368421053>

---

--- 318 --
Question ID: b125a8aec733d1c1ee2d51141f705f91e5291b26_1
Original Code:
```
pub async fn create_store_builder_single_conn(
    mut conn: sqlx::PgConnection,
    read_config: BasiliqStoreConfig,
) -> Result<BasiliqStoreBuilder, BasiliqError> {
    info!("Scanning the database...");
    let mut builder = BasiliqStoreBuilder::new(BasiliqDbScannedTable::scan_db(&mut conn).await?);
    builder.basiliq_config_merge(&read_config)?;
    Ok(builder)
}
```


Overlapping Code:
```
onn(
mut conn: sqlx::PgConnection,
read_config: BasiliqStoreConfig,
) -> Result<BasiliqStoreBuilder, BasiliqError> {
info!("Scanning the database...");
let mut builder = BasiliqStoreBuilder::new(BasiliqDbScannedTable::scan_db(&mut conn).await?);
builder.basiliq_config_merge(&read_config)?;
Ok(builde
```
<Overlap Ratio: 0.8670520231213873>

---

--- 319 --
Question ID: e44b15a42bde104a0af919003d7108077e10781b_55
Original Code:
```
fn backwards_sqrt() {
        let a = Tensor::new(vec![3.0], &[1]).unwrap();

        let b = a.sqrt().unwrap();

        b.backward();

        assert!(
            (b.derivative == RefCell::new(vec![1.0])
                && (a.derivative == RefCell::new(vec![0.5 * ((3.0 as f32).powf(-0.5))])))
        )
    }
```


Overlapping Code:
```
s_sqrt() {
let a = Tensor::new(vec![3.0], &[1]).unwrap();
let b = a.sqrt().unwrap();
b.backward();
assert!(
(b.derivative == RefCell::new(vec![1.0])
&& (a.derivative == RefCell::new(vec![0.5 * ((3.0 a
```
<Overlap Ratio: 0.8438818565400844>

---

--- 320 --
Question ID: 3034f6791edee6c5f8a62aa256066c1f6d0411b6_0
Original Code:
```
fn ion_hash_string() {
    let value = IonValue::String("Hola".to_string());

    let hash = IonHash::digest::<Sha256>(&value);

    println!("Resulting hash: {:X?}", hash);

    assert_eq!(b"\x39\xc4\xf3\x56\x39\xf5\xf2\xa5\x83\xc5\xe4\x39\x43\xc2\x06\x79\x92\xe5\x5e\xd2\xaa\x31\x90\x34\x28\x76\x56\x6c\xbf\xf6\x2e\xe0", &hash[..]);
}
```


Overlapping Code:
```
hash_string() {
let value = IonValue::String("Hola".to_string());
let hash = IonHash::digest::<Sha256>(&value);
println!("Resulting hash: {:X?}", hash);
assert_eq!(b"\x39\xc4\xf3\x56\x39\xf5\xf2\xa5\x83\xc5\xe4\x39\x43\xc2\x06\x79\x92\xe5\x5e\xd2\xaa\x31\x90\x34\x28\x76\x56\x6c\xbf\xf6\x2e\xe0", &ha
```
<Overlap Ratio: 0.9463722397476341>

---

--- 321 --
Question ID: da68d7029c23d0b5673233c79d3b20e9295990c0_0
Original Code:
```
pub fn run<'a>(args: &ArgMatches<'a>, interfaces: &Interfaces) -> Result<()> {
    let command = args.subcommand_matches(super::COMMAND).unwrap();
    let command = command.subcommand_matches(COMMAND).unwrap();
    let name = command.value_of("election").unwrap();
    if !command.is_present("take-responsibility") {
        return Err(ErrorKind::TakeResponsibility.into());
    }

    let logger = interfaces.logger();
    let admin = coordinator_admin(args, logger.clone())?;
    let election = admin
        .election(name)
        .with_context(|_| ErrorKind::CoordinatorElectionLookup(name.to_string()))?;
    let stepped_down = election
        .step_down()
        .with_context(|_| ErrorKind::CoordinatorElectionStepDown(name.to_string()))?;
    if stepped_down {
        info!(logger, "Stepped down election"; "election" => name);
    } else {
        info!(logger, "No need to step down election"; "election" => name);
    }

    Ok(())
}
```


Overlapping Code:
```
pub fn run<'a>(args: &ArgMatches<'a>, interfaces: &Interfaces) -> Result<()> {
let command = args.subcommand_matches(super::COMMAND).unwrap();
let command = command.subcommand_matches(COMMAND).unwrap();
let name = command.value_of("election").unwrap();
if !command.is_present("take-responsibility") {
return Err(ErrorKind::TakeResponsibility.into());
}
let logger = interfaces.logger();
let admin = coordinator_admin(args, logger.clone())?;
let election = admin
.election(name)
.with_context(|_| ErrorKind::CoordinatorElectionLookup(name.to_string()))?;
let stepped_down = election
.step_down()
.with_context(|_| ErrorKind::CoordinatorElectionStepDown(name.to_string()))?;
if stepped_down {
info!(logger, "Stepped down election"; "election" => name);
} else {
info!(logger, "No need to step down election"; "election" => 
```
<Overlap Ratio: 0.9797136038186157>

---

--- 322 --
Question ID: c3eb62013709a27ab3bd4ad90f60814caa58ee5a_1
Original Code:
```
fn test_audio_tags() {
    let stream = parse_full_1s_audio();

    // stream_info block
    let info = stream.stream_info();
    assert_eq!(info.min_block_size, 4608);
    assert_eq!(info.max_block_size, 4608);
    assert_eq!(info.min_frame_size, 798);
    assert_eq!(info.max_frame_size, 1317);
    assert_eq!(info.sample_rate, 44100);
    assert_eq!(info.channels, 1);
    assert_eq!(info.bits_per_sample, 16);
    assert_eq!(info.total_samples, 44100);
    assert_eq!(info.md5_signature, [0xee, 0xc1, 0xef, 0x02, 0x73, 0xe8, 0xc0, 0x26, 0x1e, 0x52, 0x15, 0x9f, 0xc2, 0x13, 0x67, 0xb0]);

    for (i, block) in stream.blocks.iter().enumerate().skip(1) {
        // assert_eq!(block.length, block.data.len());
        match &block.data {
            MetadataBlockData::SeekTable(table) => {
                assert_eq!(i, 1);
                // assert_eq!(block.is_last, false);
                // assert_eq!(block.length, 18);
                assert_eq!(table.seek_points.len(), 1);
                assert_eq!(table.seek_points[0].sample_number, 0);
                assert_eq!(table.seek_points[0].stream_offset, 0);
                assert_eq!(table.seek_points[0].frame_samples, 4608);
            }
            MetadataBlockData::Comment(comment) => {
                assert_eq!(i, 2);
                // assert_eq!(block.is_last, false);
                // assert_eq!(block.length, 163);
                assert_eq!(comment.vendor_string, "Lavf58.45.100");
                assert_eq!(comment.len(), 8);
                let map = comment.to_map();
                assert_eq!(map["TITLE"].value(), "TRACK ONE");
                assert_eq!(map["ALBUM"].value(), "TestAlbum");
                assert_eq!(map["DATE"].value(), "2021-01-24");
                assert_eq!(map["TRACKNUMBER"].value(), "1");
                assert_eq!(map["TRACKTOTAL"].value(), "1");
                assert_eq!(map["DISCNUMBER"].value(), "1");
                assert_eq!(map["DISCTOTAL"].value(), "1");
            }
            MetadataBlockData::Picture(picture) => {
                assert_eq!(i, 3);
                // assert_eq!(block.is_last, false);
                // assert_eq!(block.length, 2006);
                assert!(matches!(picture.picture_type, PictureType::CoverFront));
                assert_eq!(picture.mime_type, "image/png");
                assert_eq!(picture.description, "");
                assert_eq!(picture.width, 640);
                assert_eq!(picture.height, 480);
                assert_eq!(picture.depth, 24);
                assert_eq!(picture.colors, 0);
                assert!(!picture.color_indexed());
                assert_eq!(picture.data.len(), 1965);

                let mut file = File::open("../assets/1s-cover.png").expect("Failed to open cover file.");
                let mut data = Vec::new();
                file.read_to_end(&mut data).expect("Failed to read test cover.");
                assert_eq!(&data, &picture.data);
            }
            MetadataBlockData::Padding(len) => {
                assert_eq!(i, 4);
                assert_eq!(*len, 6043);
                // assert_eq!(block.is_last, true);
                // assert_eq!(block.length, 6043);
            }
            _ => panic!("Invalid block.")
        }
    }
}
```


Overlapping Code:
```
fn test_audio_tags() {
let stream = parse_full_1s_audio();
// stream_info block
let info = stream.stream_info();
assert_eq!(info.min_block_size, 4608);
assert_eq!(info.max_block_size, 4608);
assert_eq!(info.min_frame_size, 798);
assert_eq!(info.max_frame_size, 1317);
assert_eq!(info.sample_rate, 44100);
assert_eq!(info.channels, 1);
assert_eq!(info.bits_per_sample, 16);
assert_eq!(info.total_samples, 44100);
assert_eq!(info.md5_signature, [0xee, 0xc1, 0xef, 0x02, 0x73, 0xe8, 0xc0, 0x26, 0x1e, 0x52, 0x15, 0x9f, 0xc2, 0x13, 0x67, 0xb0]);
for (i, block) in stream.blocks.iter().enumerate().skip(1) {
// assert_eq!(block.length, block.data.len());
match &block.data {
MetadataBlockData::SeekTable(table) => {
assert_eq!(i, 1);
// assert_eq!(block.is_last, false);
// assert_eq!(block.length, 18);
assert_eq!(table.seek_points.len(), 1);
assert_eq!(table.seek_points[0].sample_number, 0);
assert_eq!(table.seek_points[0].stream_offset, 0);
assert_eq!(table.seek_points[0].frame_samples, 4608);
}
MetadataBlockData::Comment(comment) => {
assert_eq!(i, 2);
// assert_eq!(block.is_last, false);
// assert_eq!(block.length, 163);
assert_eq!(comment.vendor_string, "Lavf58.45.100");
assert_eq!(comment.len(), 8);
let map = comment.to_map();
assert_eq!(map["TITLE"].value(), "TRACK ONE");
assert_eq!(map["ALBUM"].value(), "TestAlbum");
assert_eq!(map["DATE"].value(), "2021-01-24");
assert_eq!(map["TRACKNUMBER"].value(), "1");
assert_eq!(map["TRACKTOTAL"].value(), "1");
assert_eq!(map["DISCNUMBER"].value(), "1");
assert_eq!(map["DISCTOTAL"].value(), "1");
}
MetadataBlockData::Picture(picture) => {
assert_eq!(i, 3);
// assert_eq!(block.is_last, false);
// assert_eq!(block.length, 2006);
assert!(matches!(picture.picture_type, PictureType::CoverFront));
assert_eq!(picture.mime_type, "image/png");
assert_eq!(picture.description, "");
assert_eq!(picture.width, 640);
assert_eq!(picture.height, 480);
a
```
<Overlap Ratio: 0.9973753280839895>

---

--- 323 --
Question ID: d19d24448c5c0236fa9d47abdc42259e81b4351e_0
Original Code:
```
fn regex_rule_with_matching_file() {
        let rule = RegexRule { rule: Regex::new("match").unwrap() };
        let file = PathBuf::from("./is/a/match.txt");
        let is_match = rule.file_matches_rule(&file, &dummy_map_file_context());
        assert_eq!(is_match, true);
    }
```


Overlapping Code:
```
hing_file() {
let rule = RegexRule { rule: Regex::new("match").unwrap() };
let file = PathBuf::from("./is/a/match.txt");
let is_match = rule.file_matches_rule(&file, &dummy_map_file_context());
assert
```
<Overlap Ratio: 0.8130081300813008>

---

--- 324 --
Question ID: 05cd2d9a8f302abc8a302a14422d323b64dc8939_95
Original Code:
```
fn bindgen_test_layout_DhKey() {
    assert_eq!(
        ::std::mem::size_of::<DhKey>(),
        56usize,
        concat!("Size of: ", stringify!(DhKey))
    );
    assert_eq!(
        ::std::mem::align_of::<DhKey>(),
        8usize,
        concat!("Alignment of ", stringify!(DhKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DhKey>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DhKey), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DhKey>())).g as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(DhKey), "::", stringify!(g))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DhKey>())).heap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DhKey),
            "::",
            stringify!(heap)
        )
    );
}
```


Overlapping Code:
```
q!(
::std::mem::size_of::<DhKey>(),
56usize,
concat!("Size of: ", stringify!(DhKey))
);
assert_eq!(
::std::mem::align_of::<DhKey>(),
8usize,
concat!("Alignment of ", stringify!(DhKey))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<DhKey>())).p as *const _ as usize },
0usize,
concat!("Offset of field: ", stringify!(DhKey), "::", stringify!(p))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<DhKey>())).g as *const _ as usize },
24usize,
concat!("Offset of field: ", stringify!(DhKey), "::", stringify!(g))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<DhKey>())).heap as *const _ as usize },
48usize,
concat!(
"Offset of field: ",
stringify!(DhKey
```
<Overlap Ratio: 0.8990318118948825>

---

--- 325 --
Question ID: 1f804aa0648eb34d98326784a68d9ce6b913e9d2_2
Original Code:
```
pub async fn insert_bano_item(
    bano_id: &str,
    item_id: &str,
    context: &gql::Context,
) -> Result<Item, error::Error> {
    // FIXME This should be a transaction grouping both actions
    let item = sqlx::query_as("INSERT INTO main.env_bano_item (id) VALUES ($1) RETURNING *")
        .bind(item_id)
        .fetch_one(&context.pool)
        .await
        .context(error::DBError {
            details: format!("Could not insert BANO item {}", item_id),
        })?;
    let conn = context.pool.acquire().await.context(error::DBError {
        details: "Could not get conn",
    })?;
    // FIXME should not use this method to build a query.
    sqlx::query(&format!(
        "INSERT INTO main.env_bano_map VALUES ('{}', '{}')",
        bano_id, item_id
    ))
    .execute(conn)
    .await
    .context(error::DBError {
        details: "Could not retrieve BANO item",
    })?;
    Ok(item)
}
```


Overlapping Code:
```
nsert_bano_item(
bano_id: &str,
item_id: &str,
context: &gql::Context,
) -> Result<Item, error::Error> {
// FIXME This should be a transaction grouping both actions
let item = sqlx::query_as("INSERT INTO main.env_bano_item (id) VALUES ($1) RETURNING *")
.bind(item_id)
.fetch_one(&context.pool)
.await
.context(error::DBError {
details: format!("Could not insert BANO item {}", item_id),
})?;
let conn = context.pool.acquire().await.context(error::DBError {
details: "Could not get conn",
})?;
// FIXME should not use this method to build a query.
sqlx::query(&format!(
"INSERT INTO main.env_bano_map VALUES ('{}', '{}')",
bano_id, item_id
))
.execute(conn)
.await
.context(error::DBError {
details: "Could not retrieve BANO
```
<Overlap Ratio: 0.9513797634691196>

---

--- 326 --
Question ID: c174ec8e6f2d9b3befe86246f2d267ecb0dd1645_0
Original Code:
```
unsafe fn read_ss_family(storage: *const sockaddr_storage) -> u16 {
    // Assert that we know the layout of `sockaddr`.
    let _ = libc::sockaddr {
        #[cfg(any(
            target_os = "netbsd",
            target_os = "macos",
            target_os = "ios",
            target_os = "freebsd",
            target_os = "openbsd"
        ))]
        sa_len: 0_u8,
        #[cfg(any(
            target_os = "netbsd",
            target_os = "macos",
            target_os = "ios",
            target_os = "freebsd",
            target_os = "openbsd"
        ))]
        sa_family: 0_u8,
        #[cfg(not(any(
            target_os = "netbsd",
            target_os = "macos",
            target_os = "ios",
            target_os = "freebsd",
            target_os = "openbsd"
        )))]
        sa_family: 0_u16,
        sa_data: [0; 14],
    };

    (*storage.cast::<sockaddr_header>()).ss_family.into()
}
```


Overlapping Code:
```
amily(storage: *const sockaddr_storage) -> u16 {
// Assert that we know the layout of `sockaddr`.
let _ = libc::sockaddr {
#[cfg(any(
target_os = "netbsd",
target_os = "macos",
target_os = "ios",
target_os = "freebsd",
target_os = "openbsd"
))]
sa_len: 0_u8,
#[cfg(any(
target_os = "netbsd",
target_os = "macos",
target_os = "ios",
target_os = "freebsd",
target_os = "openbsd"
))]
sa_family: 0_u8,
#[cfg(not(any(
target_os = "netbsd",
target_os = "macos",
target_os = "ios",
target_os = "freebsd",
target_os = "openbsd"
)))]
sa_family: 0_u16,
sa_data: [0; 14],
};
(*storage.cast::<sockaddr_header>()).ss_fami
```
<Overlap Ratio: 0.9529780564263323>

---

--- 327 --
Question ID: 5d5d00ddc0c10459b3e34a3e06ce068937083bba_0
Original Code:
```
pub fn get_opts() -> Options {
    let mut opts = Options::new();
    opts.optflag("h", "help", "print this help text");
    opts.optflag("v", "verbose", "print debug info on each instruction");
    opts
}
```


Overlapping Code:
```
opts() -> Options {
let mut opts = Options::new();
opts.optflag("h", "help", "print this help text");
opts.optflag("v", "verbose", "pr
```
<Overlap Ratio: 0.708994708994709>

---

--- 328 --
Question ID: b36722b21e81135bcdc4bfeca1e7c66536ff78ca_1
Original Code:
```
fn assert_valid_url_dyno_stop() {
        let app_id = "123xyz";
        let dyno_id = "xyz123";
        let response = util::get_client().request(&dynos::DynoActionStop {
            app_id: app_id,
            dyno_id: dyno_id,
        });
        let endpoint = format!(
            "{}{}{}{}{}",
            "apps/", app_id, "/dynos/", dyno_id, "/actions/stop"
        );
        assert_valid_url(response, endpoint)
    }
```


Overlapping Code:
```
top() {
let app_id = "123xyz";
let dyno_id = "xyz123";
let response = util::get_client().request(&dynos::DynoActionStop {
app_id: app_id,
dyno_id: dyno_id,
});
let endpoint = format!(
"{}{}{}{}{}",
"apps/", app_id, "/dynos/", dyno_id, "/actions/stop"
```
<Overlap Ratio: 0.7861635220125787>

---

--- 329 --
Question ID: 3935794c13e3dc1d875fc5619ca9a9e4a97e31b4_0
Original Code:
```
fn imaginary_units() {
    type Qi = Quaternion<i32>;
    assert_eq!(Qi::i() * Qi::i(), -Qi::one());
    assert_eq!(Qi::j() * Qi::j(), -Qi::one());
    assert_eq!(Qi::k() * Qi::k(), -Qi::one());
    assert_eq!(Qi::i() * Qi::j() * Qi::k(), -Qi::one());

    assert_eq!(Qi::i() * Qi::j(), Qi::k());
    assert_eq!(Qi::j() * Qi::k(), Qi::i());
    assert_eq!(Qi::k() * Qi::i(), Qi::j());

    assert_eq!(Qi::j() * Qi::i(), -Qi::k());
    assert_eq!(Qi::k() * Qi::j(), -Qi::i());
    assert_eq!(Qi::i() * Qi::k(), -Qi::j());
}
```


Overlapping Code:
```
32>;
assert_eq!(Qi::i() * Qi::i(), -Qi::one());
assert_eq!(Qi::j() * Qi::j(), -Qi::one());
assert_eq!(Qi::k() * Qi::k(), -Qi::one());
assert_eq!(Qi::i() * Qi::j() * Qi::k(), -Qi::one());
assert_eq!(Qi::i() * Qi::j(), Qi::k());
assert_eq!(Qi::j() * Qi::k(), Qi::i());
assert_eq!(Qi::k() * Qi::i(), Qi::j());
assert_eq!(Qi::j() * Qi::i(), -Qi::k());
assert_eq!(Qi::k() * Qi::j(), -Qi::i());
assert_eq!(
```
<Overlap Ratio: 0.8403361344537815>

---

--- 330 --
Question ID: 81eb41f999bbf956413f7dc13997085e2fca3606_16
Original Code:
```
fn history_tree_is_updated_for_network_upgrade(
    network: Network,
    network_upgrade: NetworkUpgrade,
) -> Result<()> {
    let blocks = match network {
        Network::Mainnet => &*zebra_test::vectors::MAINNET_BLOCKS,
        Network::Testnet => &*zebra_test::vectors::TESTNET_BLOCKS,
    };
    let height = network_upgrade.activation_height(network).unwrap().0;

    let prev_block = Arc::new(
        blocks
            .get(&(height - 1))
            .expect("test vector exists")
            .zcash_deserialize_into::<Block>()
            .expect("block is structurally valid"),
    );

    let mut state = NonFinalizedState::new(network);
    let finalized_state = FinalizedState::new(&Config::ephemeral(), network);

    state
        .commit_new_chain(prev_block.clone().prepare(), &finalized_state)
        .unwrap();

    let chain = state.best_chain().unwrap();
    if network_upgrade == NetworkUpgrade::Heartwood {
        assert!(
            chain.history_tree.as_ref().is_none(),
            "history tree must not exist yet"
        );
    } else {
        assert!(
            chain.history_tree.as_ref().is_some(),
            "history tree must already exist"
        );
    }

    // The Heartwood activation block has an all-zero commitment
    let activation_block = prev_block.make_fake_child().set_block_commitment([0u8; 32]);

    state
        .commit_block(activation_block.clone().prepare(), &finalized_state)
        .unwrap();

    let chain = state.best_chain().unwrap();
    assert!(
        chain.history_tree.as_ref().is_some(),
        "history tree must have been (re)created"
    );
    assert_eq!(
        chain.history_tree.as_ref().as_ref().unwrap().size(),
        1,
        "history tree must have a single node"
    );

    // To fix the commitment in the next block we must recreate the history tree
    let tree = NonEmptyHistoryTree::from_block(
        Network::Mainnet,
        activation_block.clone(),
        &chain.sapling_note_commitment_tree.root(),
        &chain.orchard_note_commitment_tree.root(),
    )
    .unwrap();

    let next_block = activation_block
        .make_fake_child()
        .set_block_commitment(tree.hash().into());

    state
        .commit_block(next_block.prepare(), &finalized_state)
        .unwrap();

    assert!(
        state.best_chain().unwrap().history_tree.as_ref().is_some(),
        "history tree must still exist"
    );

    Ok(())
}
```


Overlapping Code:
```
dated_for_network_upgrade(
network: Network,
network_upgrade: NetworkUpgrade,
) -> Result<()> {
let blocks = match network {
Network::Mainnet => &*zebra_test::vectors::MAINNET_BLOCKS,
Network::Testnet => &*zebra_test::vectors::TESTNET_BLOCKS,
};
let height = network_upgrade.activation_height(network).unwrap().0;
let prev_block = Arc::new(
blocks
.get(&(height - 1))
.expect("test vector exists")
.zcash_deserialize_into::<Block>()
.expect("block is structurally valid"),
);
let mut state = NonFinalizedState::new(network);
let finalized_state = FinalizedState::new(&Config::ephemeral(), network);
state
.commit_new_chain(prev_block.clone().prepare(), &finalized_state)
.unwrap();
let chain = state.best_chain().unwrap();
if network_upgrade == NetworkUpgrade::Heartwood {
assert!(
chain.history_tree.as_ref().is_none(),
"history tree must not exist yet"
);
} else {
assert!(
chain.history_tree.as_ref().is_some(),
"history tree must already exist"
);
}
// The Heartwood activation block has an all-zero commitment
let activation_block = prev_block.make_fake_child().set_block_commitment([0u8; 32]);
state
.commit_block(activation_block.clone().prepare(), &finalized_state)
.unwrap();
let chain = state.best_chain().unwrap();
assert!(
chain.history_tree.as_ref().is_some(),
"history tree must have been (re)created"
);
assert_eq!(
chain.history_tree.as_ref().as_ref().unwrap().size(),
1,
"history tree must have a single node"
);
// To fix the commitment in the next block we must recreate the history tree
let tree = NonEmptyHistoryTree::from_block(
Network::Mainnet,
activation_block.clone(),
&chain.sapling_note_commitment_tree.root(),
&chain.orchard_note_commitment_tree.root(),
)
.unwrap();
let next_block = activation_block
.make_fake_child()
.set_block_commitment(tree.hash().into());
state
.commit_block(next_block.prepare(), &finalized_state)
.unwrap();
assert!(
state.best_chain().unwrap().history_tree.as_ref().is_some(),
"history tree mus
```
<Overlap Ratio: 0.9764646970455684>

---

--- 331 --
Question ID: b9732bed1d93ee151e2c4b7884050ce29803a61c_2
Original Code:
```
fn lanczos_cgamma(z: C64) -> C64 {
    let p = [
        0.99999999999980993, 676.5203681218851, -1259.1392167224028,
        771.32342877765313, -176.61502916214059, 12.507343278686905,
        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
    ];
    let z = z - 1.0;
    let mut y = C64 {re: p[0], im: 0.0};
    y += p[1]/(z + 1.0); y += p[2]/(z + 2.0);
    y += p[3]/(z + 3.0); y += p[4]/(z + 4.0);
    y += p[5]/(z + 5.0); y += p[6]/(z + 6.0);
    y += p[7]/(z + 7.0); y += p[8]/(z + 8.0);
    let t = z + 7.5;
    SQRT_2PI*t.powc(z + 0.5)*(-t).exp()*y
}
```


Overlapping Code:
```
os_cgamma(z: C64) -> C64 {
let p = [
0.99999999999980993, 676.5203681218851, -1259.1392167224028,
771.32342877765313, -176.61502916214059, 12.507343278686905,
-0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
];
let z = z - 1.0;
let mut y = C64 {re: p[0], im: 0.0};
y += p[1]/(z + 1.0); y += p[2]/(z + 2.0);
y += p[3]/(z + 3.0); y += p[4]/(z + 4.0);
y += p[5]/(z + 5.0); y += p[6]/(z + 6.0);
y += p[7]/(z + 7.0); y += p[8]/(z + 8.0);
let t = z + 7.5;
SQRT_2PI*t.powc(z + 0.5)*(-t).ex
```
<Overlap Ratio: 0.970873786407767>

---

--- 332 --
Question ID: 1d16805294dec2b89573b4fabacd0b817a33103a_4
Original Code:
```
fn parse_derive_attr(reg: &Registry,
                     nested: Vec<NestedMetaItem>)
                     -> (Vec<Ident>, Option<Attribute>) {
    let mut derives = Vec::new();

    let remaining: Vec<_> = nested.into_iter()
        .flat_map(|meta| {
            let word = match meta {
                NestedMetaItem::MetaItem(MetaItem::Word(word)) => word,
                _ => return Some(meta),
            };
            if reg.derives.contains_key(word.as_ref()) {
                derives.push(word);
                None
            } else {
                Some(NestedMetaItem::MetaItem(MetaItem::Word(word)))
            }
        })
        .collect();

    let attr = if remaining.is_empty() {
        // Elide an empty #[derive()]
        None
    } else {
        Some(Attribute {
            style: AttrStyle::Outer,
            value: MetaItem::List("derive".into(), remaining),
            is_sugared_doc: false,
        })
    };

    (derives, attr)
}
```


Overlapping Code:
```
,
nested: Vec<NestedMetaItem>)
-> (Vec<Ident>, Option<Attribute>) {
let mut derives = Vec::new();
let remaining: Vec<_> = nested.into_iter()
.flat_map(|meta| {
let word = match meta {
NestedMetaItem::MetaItem(MetaItem::Word(word)) => word,
_ => return Some(meta),
};
if reg.derives.contains_key(word.as_ref()) {
derives.push(word);
None
} else {
Some(NestedMetaItem::MetaItem(MetaItem::Word(word)))
}
})
.collect();
let attr = if remaining.is_empty() {
// Elide an empty #[derive()]
None
} else {
Some(Attribute {
style: AttrStyle::Outer,
value: MetaItem::List("derive".into(), remaining),
is_sugared
```
<Overlap Ratio: 0.8941877794336811>

---

--- 333 --
Question ID: b8b64c9753da0dc4e7b62b705112d08d2f219ee8_0
Original Code:
```
fn main() -> Result<(), Box<dyn Error + Sync + Send>> {
    eprintln!("Server starting...");

    let (connection, io_threads) = Connection::stdio();
    eprintln!("Created connection");

    // Run the server and wait for the two threads to end (typically by trigger LSP Exit event).
    let server_capabilities = serde_json::to_value(&ServerCapabilities::default()).unwrap();
    eprintln!("Server Capabilities: {:?}", server_capabilities);

    let initialize_params = connection.initialize(server_capabilities)?;

    eprintln!("Calling main loop");
    main_loop(&connection, initialize_params)?;
    io_threads.join()?;

    eprintln!("Shutting down server");

    Ok(())
}
```


Overlapping Code:
```
fn main() -> Result<(), Box<dyn Error + Sync + Send>> {
eprintln!("Server starting...");
let (connection, io_threads) = Connection::stdio();
eprintln!("Created connection");
// Run the server and wait for the two threads to end (typically by trigger LSP Exit event).
let server_capabilities = serde_json::to_value(&ServerCapabilities::default()).unwrap();
eprintln!("Server Capabilities: {:?}", server_capabilities);
let initialize_params = connection.initialize(server_capabilities)?;
eprintln!("Calling main loop");
main_loop(&connection, initialize_params)?;
io_threads.join()?;
eprintln!("Shutting down server");
Ok
```
<Overlap Ratio: 0.9904>

---

--- 334 --
Question ID: b6bc1c6ba0faaad1ae0cdc3eea42429aea859bce_1
Original Code:
```
pub fn request_to_string(name: &str, args: Vec<Value>) -> Result<String> {
    let mut writer = Writer::new(Vec::new());

    writer
        .write(br#"<?xml version="1.0" encoding="utf-8"?>"#)
        .map_err(error::EncodingError::from)?;

    writer.write_start_tag(b"methodCall")?;
    writer.write_tag(b"methodName", name)?;

    writer.write_start_tag(b"params")?;
    for value in args {
        writer.write_start_tag(b"param")?;

        let deserializer = value::Deserializer::from_value(value);
        let serializer = ValueSerializer::new(&mut writer);
        transcode(deserializer, serializer)?;

        writer.write_end_tag(b"param")?;
    }
    writer.write_end_tag(b"params")?;
    writer.write_end_tag(b"methodCall")?;

    Ok(String::from_utf8(writer.into_inner()).map_err(error::EncodingError::from)?)
}
```


Overlapping Code:
```
ame: &str, args: Vec<Value>) -> Result<String> {
let mut writer = Writer::new(Vec::new());
writer
.write(br#"<?xml version="1.0" encoding="utf-8"?>"#)
.map_err(error::EncodingError::from)?;
writer.write_start_tag(b"methodCall")?;
writer.write_tag(b"methodName", name)?;
writer.write_start_tag(b"params")?;
for value in args {
writer.write_start_tag(b"param")?;
let deserializer = value::Deserializer::from_value(value);
let serializer = ValueSerializer::new(&mut writer);
transcode(deserializer, serializer)?;
writer.write_end_tag(b"param")?;
}
writer.write_end_tag(b"params")?;
writer.write_end_tag(b"methodCall")?;
Ok(String::from_utf8(writer.into_inner()).map_err(error::EncodingError:
```
<Overlap Ratio: 0.9502762430939227>

---

--- 335 --
Question ID: 25f8048433302668dcb5b989a761ed830bd01c31_0
Original Code:
```
fn run() -> Result<(), Error> {
    let opt = Opt::from_args();

    if let Some(path) = &opt.log_dir {
        if !path.is_dir() {
            eprintln!("Expect a directory for logging graphs");
            return Err(Error::from(ErrorKind::InvalidInput));
        }
    }

    env_logger::init();

    let (log_tx, log_rx) = sync::channel(1000);
    let (graph_tx, graph_rx) = sync::channel(10);
    let (_stream_tx, stream_rx) = sync::channel(10);

    let secrets_pat = [r".*\.secret$", r".*\.kvmi$"];
    let secrets = RegexSet::new(&secrets_pat).unwrap();
    let constructor = task::spawn(graph::construct(log_rx, graph_tx, secrets));

    let consumer = task::spawn(consume::consume(graph_rx, opt.log_dir.clone(), stream_rx));

    task::block_on(async {
        let mut subscribe = Box::pin(rpc::subscribe(&opt.addr, log_tx)).fuse();
        let mut consumer = consumer.fuse();
        loop {
            select! {
                res = consumer => {
                    if let Err(e) = res {
                        break Err(e);
                    }
                }
                res = subscribe => {
                    if let Err(e) = res {
                        break Err(e);
                    }
                }
                complete => break Ok(()),
            }
        }
    })?;
    task::block_on(async { constructor.await });
    Ok(())
}
```


Overlapping Code:
```
fn run() -> Result<(), Error> {
let opt = Opt::from_args();
if let Some(path) = &opt.log_dir {
if !path.is_dir() {
eprintln!("Expect a directory for logging graphs");
return Err(Error::from(ErrorKind::InvalidInput));
}
}
env_logger::init();
let (log_tx, log_rx) = sync::channel(1000);
let (graph_tx, graph_rx) = sync::channel(10);
let (_stream_tx, stream_rx) = sync::channel(10);
let secrets_pat = [r".*\.secret$", r".*\.kvmi$"];
let secrets = RegexSet::new(&secrets_pat).unwrap();
let constructor = task::spawn(graph::construct(log_rx, graph_tx, secrets));
let consumer = task::spawn(consume::consume(graph_rx, opt.log_dir.clone(), stream_rx));
task::block_on(async {
let mut subscribe = Box::pin(rpc::subscribe(&opt.addr, log_tx)).fuse();
let mut consumer = consumer.fuse();
loop {
select! {
res = consumer => {
if let Err(e) = res {
break Err(e);
}
}
res = subscribe => {
if let Err(e) = res {
break Err(e);
}
}
complete => break Ok(()),
}
}
})?;
task::block_on(async { constructor.await });
Ok(())

```
<Overlap Ratio: 0.9990029910269193>

---

--- 336 --
Question ID: ad061bb2e83d69c1a356f286feb48ee1a994c11a_0
Original Code:
```
fn bench(f: fn()) {
    let t0 = time::Instant::now();
    let ret = f();
    println!("time used {:?}", time::Instant::now().duration_since(t0));

    ret
}
```


Overlapping Code:
```
fn bench(f: fn()) {
let t0 = time::Instant::now();
let ret = f();
println!("time used {:?}", time::Instant::now().duration_since(t0));

```
<Overlap Ratio: 0.9642857142857143>

---

--- 337 --
Question ID: 2b81f2131d8504856126fad66bc1e79d8171f5de_59
Original Code:
```
fn bindgen_test_layout_TfLiteTransposeParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteTransposeParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteTransposeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteTransposeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteTransposeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteTransposeParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTransposeParams),
            "::",
            stringify!(placeholder)
        )
    );
}
```


Overlapping Code:
```
nsposeParams() {
assert_eq!(
::std::mem::size_of::<TfLiteTransposeParams>(),
1usize,
concat!("Size of: ", stringify!(TfLiteTransposeParams))
);
assert_eq!(
::std::mem::align_of::<TfLiteTransposeParams>(),
1usize,
concat!("Alignment of ", stringify!(TfLiteTransposeParams))
);
assert_eq!(
unsafe {
&(*(::std::ptr::null::<TfLiteTransposeParams>())).placeholder as *const _ as usize
},
0usize,
concat!(
"Offset of field: ",
stringify!(TfLiteTransposePar
```
<Overlap Ratio: 0.8587786259541985>

---

--- 338 --
Question ID: 2ab7e515eb92df9e8370278f8feae066968e7db9_0
Original Code:
```
pub async fn get_current_status_for_polling(
    simulator: SharedSimulator,
    config: SharedConfig,
) -> Result<impl warp::Reply, Infallible> {
    let simulator = simulator.lock().await;
    let config = config.lock().await;
    let slot = if simulator.beacon_chain.slot == 0 {
        None
    } else {
        Some(simulator.beacon_chain.slot - 1)
    };
    Ok(warp::reply::json(&CurrentStatusForPolling {
        slot,
        config: config.config.clone(),
    }))
}
```


Overlapping Code:
```
et_current_status_for_polling(
simulator: SharedSimulator,
config: SharedConfig,
) -> Result<impl warp::Reply, Infallible> {
let simulator = simulator.lock().await;
let config = config.lock().await;
let slot = if simulator.beacon_chain.slot == 0 {
None
} else {
Some(simulator.beacon_chain.slot - 1)
};
Ok(warp::reply::json(&CurrentStatusForPolling {
```
<Overlap Ratio: 0.85995085995086>

---

--- 339 --
Question ID: c359822c4208f26f9df6d2291b14c60a51e29691_0
Original Code:
```
fn inet_ip() {
        let mut p = ProviderInfo::new()
            .name("inet-ip.info")
            .ptype(ProviderInfoType::IPv4)
            .protocol(ProviderInfoProtocol::HttpPlane)
            .url("http://inet-ip.info/ip")
            .create();
        p.set_timeout(2000);
        let addr = p.get_addr().unwrap();
        assert!(addr.v4addr.is_some());
        assert!(!addr.v4addr.unwrap().is_private());
    }
```


Overlapping Code:
```
)
.name("inet-ip.info")
.ptype(ProviderInfoType::IPv4)
.protocol(ProviderInfoProtocol::HttpPlane)
.url("http://inet-ip.info/ip")
.create();
p.set_timeout(2000);
let addr = p.get_addr().unwrap();
assert!(addr.v4addr.is_some());
assert!(!addr.v4addr.unwrap().is_private
```
<Overlap Ratio: 0.839622641509434>

---

--- 340 --
Question ID: de95b5085e7a583b5227cf5bd274aadf138586dc_9
Original Code:
```
pub fn __state11<
        'input,
        __TOKENS: Iterator<Item=Result<(usize, (usize, &'input str), usize),__ParseError<usize,(usize, &'input str),()>>>,
    >(
        input: &'input str,
        __lookbehind: Option<usize>,
        __tokens: &mut __TOKENS,
        __sym0: &mut Option<&'input str>,
        __sym1: &mut Option<i32>,
        __sym2: &mut Option<&'input str>,
    ) -> Result<(Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>), __ParseError<usize,(usize, &'input str),()>>
    {
        let mut __result: (Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>);
        let __lookahead = match __tokens.next() {
            Some(Ok(v)) => Some(v),
            None => None,
            Some(Err(e)) => return Err(e),
        };
        match __lookahead {
            Some((_, (0, _), _)) => {
                let __sym0 = __sym0.take().unwrap();
                let __sym1 = __sym1.take().unwrap();
                let __sym2 = __sym2.take().unwrap();
                let __nt = super::__action2(input, __sym0, __sym1, __sym2);
                return Ok((__lookbehind, __lookahead, __Nonterminal::Term(__nt)));
            }
            _ => {
                return Err(__ParseError::UnrecognizedToken {
                    token: __lookahead,
                    expected: vec![],
                });
            }
        }
    }
```


Overlapping Code:
```
tate11<
'input,
__TOKENS: Iterator<Item=Result<(usize, (usize, &'input str), usize),__ParseError<usize,(usize, &'input str),()>>>,
>(
input: &'input str,
__lookbehind: Option<usize>,
__tokens: &mut __TOKENS,
__sym0: &mut Option<&'input str>,
__sym1: &mut Option<i32>,
__sym2: &mut Option<&'input str>,
) -> Result<(Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>), __ParseError<usize,(usize, &'input str),()>>
{
let mut __result: (Option<usize>, Option<(usize, (usize, &'input str), usize)>, __Nonterminal<>);
let __lookahead = match __tokens.next() {
Some(Ok(v)) => Some(v),
None => None,
Some(Err(e)) => return Err(e),
};
match __lookahead {
Some((_, (0, _), _)) => {
let __sym0 = __sym0.take().unwrap();
let __sym1 = __sym1.take().unwrap();
let __sym2 = __sym2.take().unwrap();
let __nt = super::__action2(input, __sym0, __sym1, __sym2);
return Ok((__lookbehind, __lookahead, __Nonterminal::Term(__nt)));
}
_ => {
return Err(__ParseError::UnrecognizedToken {
token: __lookahead,
expected: vec![],
});
}
}
}
```
<Overlap Ratio: 0.9904580152671756>

---

--- 341 --
Question ID: a0144a5298eba24b3d2cc94f0e6d562473c00d08_0
Original Code:
```
fn extract_html_tag(
    tags: &mut Vec<(String, Range<usize>)>,
    text: &str,
    range: &Range<usize>,
    start_pos: usize,
    iter: &mut Peekable<CharIndices<'_>>,
    f: &impl Fn(&str, &Range<usize>),
) {
    let mut tag_name = String::new();
    let mut is_closing = false;
    let mut prev_pos = start_pos;

    loop {
        let (pos, c) = match iter.peek() {
            Some((pos, c)) => (*pos, *c),
            // In case we reached the of the doc comment, we want to check that it's an
            // unclosed HTML tag. For example "/// <h3".
            None => (prev_pos, '\0'),
        };
        prev_pos = pos;
        // Checking if this is a closing tag (like `</a>` for `<a>`).
        if c == '/' && tag_name.is_empty() {
            is_closing = true;
        } else if c.is_ascii_alphanumeric() {
            tag_name.push(c);
        } else {
            if !tag_name.is_empty() {
                let mut r = Range { start: range.start + start_pos, end: range.start + pos };
                if c == '>' {
                    // In case we have a tag without attribute, we can consider the span to
                    // refer to it fully.
                    r.end += 1;
                }
                if is_closing {
                    // In case we have "</div >" or even "</div         >".
                    if c != '>' {
                        if !c.is_whitespace() {
                            // It seems like it's not a valid HTML tag.
                            break;
                        }
                        let mut found = false;
                        for (new_pos, c) in text[pos..].char_indices() {
                            if !c.is_whitespace() {
                                if c == '>' {
                                    r.end = range.start + new_pos + 1;
                                    found = true;
                                }
                                break;
                            }
                        }
                        if !found {
                            break;
                        }
                    }
                    drop_tag(tags, tag_name, r, f);
                } else {
                    tags.push((tag_name, r));
                }
            }
            break;
        }
        iter.next();
    }
}
```


Overlapping Code:
```
(
tags: &mut Vec<(String, Range<usize>)>,
text: &str,
range: &Range<usize>,
start_pos: usize,
iter: &mut Peekable<CharIndices<'_>>,
f: &impl Fn(&str, &Range<usize>),
) {
let mut tag_name = String::new();
let mut is_closing = false;
let mut prev_pos = start_pos;
loop {
let (pos, c) = match iter.peek() {
Some((pos, c)) => (*pos, *c),
// In case we reached the of the doc comment, we want to check that it's an
// unclosed HTML tag. For example "/// <h3".
None => (prev_pos, '\0'),
};
prev_pos = pos;
// Checking if this is a closing tag (like `</a>` for `<a>`).
if c == '/' && tag_name.is_empty() {
is_closing = true;
} else if c.is_ascii_alphanumeric() {
tag_name.push(c);
} else {
if !tag_name.is_empty() {
let mut r = Range { start: range.start + start_pos, end: range.start + pos };
if c == '>' {
// In case we have a tag without attribute, we can consider the span to
// refer to it fully.
r.end += 1;
}
if is_closing {
// In case we have "</div >" or even "</div >".
if c != '>' {
if !c.is_whitespace() {
// It seems like it's not a valid HTML tag.
break;
}
let mut found = false;
for (new_pos, c) in text[pos..].char_indices() {
if !c.is_whitespace() {
if c == '>' {
r.end = range.start + new_pos + 1;
found = true;
}
break;
}
}
if !found {
break;
}
}
drop_tag(tags, tag_name, r, f);
} else {
tags.push((tag_name, 
```
<Overlap Ratio: 0.9614264919941776>

---

--- 342 --
Question ID: ceb6035bbfb0d690a3018df797bedb38865bc265_0
Original Code:
```
pub fn run(args: Args) {
	let tangram_path = std::env::current_dir().unwrap();
	let dist_path = tangram_path.join("dist");

	eprintln!("clean and create release directory");
	let release_path = dist_path.join("release");
	clean_and_create(&release_path);

	eprintln!("tangram_cli");
	for target in [
		Target::X8664UnknownLinuxGnu,
		Target::AArch64UnknownLinuxGnu,
		Target::X8664UnknownLinuxMusl,
		Target::AArch64UnknownLinuxMusl,
		Target::X8664AppleDarwin,
		Target::AArch64AppleDarwin,
		Target::X8664PcWindowsMsvc,
		Target::X8664PcWindowsGnu,
	] {
		let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
		let tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);
		let output_path =
			release_path.join(format!("tangram_cli_{}_{}.tar.gz", args.version, target));
		let inputs = vec![(
			tangram_cli_path.clone(),
			PathBuf::from(tangram_cli_file_name),
		)];
		tar(inputs, &output_path);
	}

	eprintln!("deb");
	#[allow(clippy::single_element_loop)]
	for target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {
		// Create the deb directory.
		let deb_path = dist_path.join("deb");
		clean_and_create(&deb_path);
		// Create /usr/bin in the deb directory.
		let bin_path = deb_path.join("usr").join("bin");
		std::fs::create_dir_all(&bin_path).unwrap();
		// Copy the tangram cli to the deb's /usr/bin.
		let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
		let tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);
		std::fs::copy(tangram_cli_path, bin_path.join(tangram_cli_file_name)).unwrap();
		// Create the control file.
		let debian_path = deb_path.join("DEBIAN");
		std::fs::create_dir_all(&debian_path).unwrap();
		let control_path = debian_path.join("control");
		let architecture = match target {
			Target::X8664UnknownLinuxGnu => "amd64",
			Target::AArch64UnknownLinuxGnu => "arm64",
			_ => unreachable!(),
		};
		let control = formatdoc!(
			r#"
				Package: tangram
				Architecture: {}
				Version: {}
				Maintainer: Tangram <root@tangram.dev>
				Homepage: https://www.tangram.dev
				Description: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.
			"#,
			architecture,
			args.version,
		);
		std::fs::write(&control_path, &control).unwrap();
		// Run dpkg-deb
		let deb_file_name = format!("tangram_{}_{}.deb", args.version, architecture);
		let deb_output_path = release_path.join(&deb_file_name);
		cmd!("dpkg-deb", "--build", &deb_path, &deb_output_path)
			.run()
			.unwrap();
		std::fs::remove_dir_all(&deb_path).unwrap();
	}

	eprintln!("rpm");
	#[allow(clippy::single_element_loop)]
	for target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {
		// Create the rpm directory.
		let rpm_path = dist_path.join("rpm");
		clean_and_create(&rpm_path);
		for subdir in ["BUILD", "BUILDROOT", "RPMS", "SOURCES", "SPECS", "SRPMS"] {
			std::fs::create_dir(rpm_path.join(subdir)).unwrap();
		}
		// Make the tar.
		let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
		let tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);
		let tangram_path_in_tar = PathBuf::from(format!("tangram-{}/tangram", args.version));
		let sources_path = rpm_path.join("SOURCES");
		let tar_path = sources_path.join("tangram.tar.gz");
		tar(vec![(tangram_cli_path, tangram_path_in_tar)], &tar_path);
		// Write the spec file.
		let spec = formatdoc!(
			r#"
				%global __strip true

				Name: tangram
				Version: {}
				Release: 1
				Summary: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.
				License: MIT
				Source0: tangram.tar.gz

				%description
				%summary

				%prep
				%setup -q

				%install
				mkdir -p %buildroot/usr/bin
				install -m 755 tangram %buildroot/usr/bin/tangram

				%files
				%attr(0755, root, root) /usr/bin/tangram
			"#,
			args.version,
		);
		let spec_path = rpm_path.join("SPECS/tangram.spec");
		std::fs::write(&spec_path, spec).unwrap();
		// Run rpmbuild.
		let target = match target {
			Target::X8664UnknownLinuxGnu => "x86_64",
			Target::AArch64UnknownLinuxGnu => "aarch64",
			_ => unreachable!(),
		};
		cmd!(
			"rpmbuild",
			"-D",
			format!("_topdir {}", rpm_path.display()),
			"--target",
			target,
			"-bb",
			spec_path,
		)
		.run()
		.unwrap();
		// Move the rpm to the release directory.
		let src_rpm_file_name = format!("tangram-{}-1.{}.rpm", args.version, target);
		let dst_rpm_file_name = format!("tangram_{}_{}.rpm", args.version, target);
		std::fs::copy(
			rpm_path.join("RPMS").join(target).join(&src_rpm_file_name),
			release_path.join(&dst_rpm_file_name),
		)
		.unwrap();
		std::fs::remove_dir_all(rpm_path).unwrap();
	}

	eprintln!("container");
	let dockerfile_path = tangram_path.join("Dockerfile");
	let target = Target::X8664UnknownLinuxMusl;
	let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
	let tangram_cli_path = dist_path
		.strip_prefix(&tangram_path)
		.unwrap()
		.join(target.as_str())
		.join(tangram_cli_file_name);
	let dockerfile = formatdoc!(
		r#"
			FROM docker.io/alpine
			WORKDIR /
			COPY {} .
			ENTRYPOINT ["/tangram"]
		"#,
		tangram_cli_path.display(),
	);
	std::fs::write(&dockerfile_path, &dockerfile).unwrap();
	let tag = format!("docker.io/tangramdotdev/tangram:{}", args.version);
	cmd!("docker", "build", "-t", tag, &tangram_path)
		.run()
		.unwrap();
	std::fs::remove_file(&dockerfile_path).unwrap();

	eprintln!("libtangram");
	for target in [
		Target::X8664UnknownLinuxGnu,
		Target::AArch64UnknownLinuxGnu,
		Target::X8664UnknownLinuxMusl,
		Target::AArch64UnknownLinuxMusl,
		Target::X8664AppleDarwin,
		Target::AArch64AppleDarwin,
		Target::X8664PcWindowsMsvc,
		Target::X8664PcWindowsGnu,
	] {
		let target_file_names = TargetFileNames::for_target(target);
		let target_path = dist_path.join(target.as_str());
		let output_path =
			release_path.join(format!("libtangram_{}_{}.tar.gz", args.version, target));
		let inputs = vec![
			(
				target_path.join(target_file_names.tangram_h_file_name),
				PathBuf::from(target_file_names.tangram_h_file_name),
			),
			(
				target_path.join(target_file_names.libtangram_dynamic_file_name),
				PathBuf::from(target_file_names.libtangram_dynamic_file_name),
			),
			(
				target_path.join(target_file_names.libtangram_static_file_name),
				PathBuf::from(target_file_names.libtangram_static_file_name),
			),
		];
		tar(inputs, &output_path);
	}
}
```


Overlapping Code:
```
n run(args: Args) {
let tangram_path = std::env::current_dir().unwrap();
let dist_path = tangram_path.join("dist");
eprintln!("clean and create release directory");
let release_path = dist_path.join("release");
clean_and_create(&release_path);
eprintln!("tangram_cli");
for target in [
Target::X8664UnknownLinuxGnu,
Target::AArch64UnknownLinuxGnu,
Target::X8664UnknownLinuxMusl,
Target::AArch64UnknownLinuxMusl,
Target::X8664AppleDarwin,
Target::AArch64AppleDarwin,
Target::X8664PcWindowsMsvc,
Target::X8664PcWindowsGnu,
] {
let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
let tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);
let output_path =
release_path.join(format!("tangram_cli_{}_{}.tar.gz", args.version, target));
let inputs = vec![(
tangram_cli_path.clone(),
PathBuf::from(tangram_cli_file_name),
)];
tar(inputs, &output_path);
}
eprintln!("deb");
#[allow(clippy::single_element_loop)]
for target in [Target::X8664UnknownLinuxGnu, Target::AArch64UnknownLinuxGnu] {
// Create the deb directory.
let deb_path = dist_path.join("deb");
clean_and_create(&deb_path);
// Create /usr/bin in the deb directory.
let bin_path = deb_path.join("usr").join("bin");
std::fs::create_dir_all(&bin_path).unwrap();
// Copy the tangram cli to the deb's /usr/bin.
let tangram_cli_file_name = TargetFileNames::for_target(target).tangram_cli_file_name;
let tangram_cli_path = dist_path.join(target.as_str()).join(tangram_cli_file_name);
std::fs::copy(tangram_cli_path, bin_path.join(tangram_cli_file_name)).unwrap();
// Create the control file.
let debian_path = deb_path.join("DEBIAN");
std::fs::create_dir_all(&debian_path).unwrap();
let control_path = debian_path.join("control");
let architecture = match target {
Target::X8664UnknownLinuxGnu => "amd64",
Target::AArch64UnknownLinuxGnu => "arm64",
_ => unreachable!(),
};
let control = formatdoc!(
r#"
Package: tangram
Architecture: {}
Verspage: https://www.tangram.dev
Description: Tangram makes it easy for programmers to train, deploy, and monitor machine learning models.
"#,
architecture,
args.version,
);
std::fs::write(&control_path, &control).unwrap();
// Run dpkg-deb
let deb_file_name = format!("tangram_{}_{}.deb", args.version, architec
```
<Overlap Ratio: 0.9575911789652247>

---

--- 343 --
Question ID: 571ee8216cf55e877a124a634afc4513dff59c41_2
Original Code:
```
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
```


Overlapping Code:
```
 bindgen_test_layout_lldiv_t() {
assert_eq!(
::std::mem::size_of::<lldiv_t>(),
16usize,
concat!("Size of: ", stringify!(lldiv_t))
);
assert_eq!(
::std::mem::align_of::<lldiv_t>(),
8usize,
concat!("Alignment of ", stringify!(lldiv_t))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(lldiv_t),
"::",
stringify!(quot)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
8usize,
concat!(
"Offset of field: ",
stringify!(lldiv_t),
"::",
stringify!(rem)
)
);
}
```
<Overlap Ratio: 0.9965753424657534>

---

--- 344 --
Question ID: 86ed672fbc4757daa501d3250935362095976981_0
Original Code:
```
pub async fn add_comment(
    configuration: &configuration::Configuration,
    params: AddCommentParams,
) -> Result<models::Comment, Error<AddCommentError>> {
    // unbox the parameters
    let issue_id_or_key = params.issue_id_or_key;
    let request_body = params.request_body;
    let expand = params.expand;

    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/rest/api/3/issue/{issueIdOrKey}/comment",
        configuration.base_path,
        issueIdOrKey = crate::gen::apis::urlencode(issue_id_or_key)
    );
    let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());

    if let Some(ref local_var_str) = expand {
        local_var_req_builder =
            local_var_req_builder.query(&[("expand", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    if let Some(ref local_var_auth_conf) = configuration.basic_auth {
        local_var_req_builder = local_var_req_builder.basic_auth(
            local_var_auth_conf.0.to_owned(),
            local_var_auth_conf.1.to_owned(),
        );
    };
    local_var_req_builder = local_var_req_builder.json(&request_body);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AddCommentError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
```


Overlapping Code:
```
nc fn add_comment(
configuration: &configuration::Configuration,
params: AddCommentParams,
) -> Result<models::Comment, Error<AddCommentError>> {
// unbox the parameters
let issue_id_or_key = params.issue_id_or_key;
let request_body = params.request_body;
let expand = params.expand;
let local_var_client = &configuration.client;
let local_var_uri_str = format!(
"{}/rest/api/3/issue/{issueIdOrKey}/comment",
configuration.base_path,
issueIdOrKey = crate::gen::apis::urlencode(issue_id_or_key)
);
let mut local_var_req_builder = local_var_client.post(local_var_uri_str.as_str());
if let Some(ref local_var_str) = expand {
local_var_req_builder =
local_var_req_builder.query(&[("expand", &local_var_str.to_string())]);
}
if let Some(ref local_var_user_agent) = configuration.user_agent {
local_var_req_builder =
local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
}
if let Some(ref local_var_token) = configuration.oauth_access_token {
local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
};
if let Some(ref local_var_auth_conf) = configuration.basic_auth {
local_var_req_builder = local_var_req_builder.basic_auth(
local_var_auth_conf.0.to_owned(),
local_var_auth_conf.1.to_owned(),
);
};
local_var_req_builder = local_var_req_builder.json(&request_body);
let local_var_req = local_var_req_builder.build()?;
let local_var_resp = local_var_client.execute(local_var_req).await?;
let local_var_status = local_var_resp.status();
let local_var_content = local_var_resp.text().await?;
if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
serde_json::from_str(&local_var_content).map_err(Error::from)
} else {
let local_var_entity: Option<AddCommentError> =
serde_json::from_str(&local_var_content).ok();
let local_var_error = ResponseContent {
status: local_var_status,
content: local_var_content,
entity: local_var_entity,
};
Err(Error::ResponseError(local_var_error))
}
}
```
<Overlap Ratio: 0.9964503042596349>

---

--- 345 --
Question ID: 9839f2334dc25c063b473f3bf7fe88e11d0faf85_0
Original Code:
```
pub fn main(input: &str) -> Result<(usize, usize), String> {
    let bytes: Vec<_> = input.trim_end().as_bytes().chunks(2)
        .map(|slice| {
            let hi = (slice[0] as char).to_digit(16).expect("invalid digit") as u8;
            let lo = if slice.len() > 1 {
                (slice[1] as char).to_digit(16).expect("invalid digit") as u8
            } else {
                0
            };
            hi << 4 | lo
        })
        .collect();
    let mut bits = BitsIter::new(bytes);
    
    let mut messages = Vec::new();
    while !bits.is_empty() {
        messages.push(Message::parse(&mut bits));
    }
    let part1 = messages
        .iter()
        .map(|m| m.versions_sum() as usize)
        .sum::<usize>();

    assert_eq!(messages.len(), 1);
    let part2 = messages[0].result_value();
    Ok((part1, part2))
}
```


Overlapping Code:
```
fn main(input: &str) -> Result<(usize, usize), String> {
let bytes: Vec<_> = input.trim_end().as_bytes().chunks(2)
.map(|slice| {
let hi = (slice[0] as char).to_digit(16).expect("invalid digit") as u8;
let lo = if slice.len() > 1 {
(slice[1] as char).to_digit(16).expect("invalid digit") as u8
} else {
0
};
hi << 4 | lo
})
.collect();
let mut bits = BitsIter::new(bytes);

let mut messages = Vec::new();
while !bits.is_empty() {
messages.push(Message::parse(&mut bits));
}
let part1 = messages
.iter()
.map(|m| m.versions_sum() as usize)
.sum::<usize>();
assert_eq!(messages.len(), 1);
let part2 = messages[0].result_value
```
<Overlap Ratio: 0.956989247311828>

---

--- 346 --
Question ID: ad677d67fa83715cad9a52ff82aa39df32bfa494_0
Original Code:
```
fn group_by_get_indices(
        &self,
        block: &DataBlock,
        column_names: &[String],
    ) -> Result<GroupIndices<Self::HashKey>> {
        // Table for <group_key, (indices, keys) >
        let mut group_indices = GroupIndices::<Self::HashKey>::default();
        // 1. Get group by columns.
        let mut group_columns = Vec::with_capacity(column_names.len());
        {
            for col in column_names {
                group_columns.push(block.try_column_by_name(col)?);
            }
        }

        // 2. Build serialized keys
        let group_keys = self.build_keys(&group_columns, block.num_rows())?;
        // 2. Make group with indices.
        {
            for (row, group_key) in group_keys.iter().enumerate().take(block.num_rows()) {
                match group_indices.get_mut(group_key) {
                    None => {
                        let mut group_values = Vec::with_capacity(group_columns.len());
                        for col in &group_columns {
                            group_values.push(col.try_get(row)?);
                        }
                        group_indices.insert(group_key.clone(), (vec![row as u32], group_values));
                    }
                    Some((v, _)) => {
                        v.push(row as u32);
                    }
                }
            }
        }

        Ok(group_indices)
    }
```


Overlapping Code:
```
 group_by_get_indices(
&self,
block: &DataBlock,
column_names: &[String],
) -> Result<GroupIndices<Self::HashKey>> {
// Table for <group_key, (indices, keys) >
let mut group_indices = GroupIndices::<Self::HashKey>::default();
// 1. Get group by columns.
let mut group_columns = Vec::with_capacity(column_names.len());
{
for col in column_names {
group_columns.push(block.try_column_by_name(col)?);
}
}
// 2. Build serialized keys
let group_keys = self.build_keys(&group_columns, block.num_rows())?;
// 2. Make group with indices.
{
for (row, group_key) in group_keys.iter().enumerate().take(block.num_rows()) {
match group_indices.get_mut(group_key) {
None => {
let mut group_values = Vec::with_capacity(group_columns.len());
for col in &group_columns {
group_values.push(col.try_get(row)?);
}
group_indices.insert(group_key.clone(), (vec![row as u32], group_values));
}
Some((v, _)) => {
v.push(row as u32);
}
}
```
<Overlap Ratio: 0.9722814498933902>

---

--- 347 --
Question ID: 860e4a9f12c1d2733ac8fe0c1e341ae5ee5988bb_0
Original Code:
```
pub fn imul_power<T>(x: &mut T, radix: u32, n: u32)
    where T: CloneableVecLike<Limb>
{
    use super::large::KARATSUBA_CUTOFF;

    let small_powers = get_small_powers(radix);
    let large_powers = get_large_powers(radix);

    if n == 0 {
        // No exponent, just return.
        // The 0-index of the large powers is `2^0`, which is 1, so we want
        // to make sure we don't take that path with a literal 0.
        return;
    }

    // We want to use the asymptotically faster algorithm if we're going
    // to be using Karabatsu multiplication sometime during the result,
    // otherwise, just use exponentiation by squaring.
    let bit_length = 32 - n.leading_zeros().as_usize();
    debug_assert!(bit_length != 0 && bit_length <= large_powers.len());
    if x.len() + large_powers[bit_length-1].len() < 2*KARATSUBA_CUTOFF {
        // We can use iterative small powers to make this faster for the
        // easy cases.

        // Multiply by the largest small power until n < step.
        let step = small_powers.len() - 1;
        let power = small_powers[step];
        let mut n = n.as_usize();
        while n >= step {
            imul(x, power);
            n -= step;
        }

        // Multiply by the remainder.
        imul(x, small_powers[n]);
    } else {
        // In theory, this code should be asymptotically a lot faster,
        // in practice, our small::imul seems to be the limiting step,
        // and large imul is slow as well.

        // Multiply by higher order powers.
        let mut idx: usize = 0;
        let mut bit: usize = 1;
        let mut n = n.as_usize();
        while n != 0 {
            if n & bit != 0 {
                debug_assert!(idx < large_powers.len());
                large::imul(x, large_powers[idx]);
                n ^= bit;
            }
            idx += 1;
            bit <<= 1;
        }
    }
}
```


Overlapping Code:
```
: &mut T, radix: u32, n: u32)
where T: CloneableVecLike<Limb>
{
use super::large::KARATSUBA_CUTOFF;
let small_powers = get_small_powers(radix);
let large_powers = get_large_powers(radix);
if n == 0 {
// No exponent, just return.
// The 0-index of the large powers is `2^0`, which is 1, so we want
// to make sure we don't take that path with a literal 0.
return;
}
// We want to use the asymptotically faster algorithm if we're going
// to be using Karabatsu multiplication sometime during the result,
// otherwise, just use exponentiation by squaring.
let bit_length = 32 - n.leading_zeros().as_usize();
debug_assert!(bit_length != 0 && bit_length <= large_powers.len());
if x.len() + large_powers[bit_length-1].len() < 2*KARATSUBA_CUTOFF {
// We can use iterative small powers to make this faster for the
// easy cases.
// Multiply by the largest small power until n < step.
let step = small_powers.len() - 1;
let power = small_powers[step];
let mut n = n.as_usize();
while n >= step {
imul(x, power);
n -= step;
}
// Multiply by the remainder.
imul(x, small_powers[n]);
} else {
// In theory, this code should be asymptotically a lot faster,
// in practice, our small::imul seems to be the limiting step,
// and large imul is slow as well.
// Multiply by higher order powers.
let mut idx: usize = 0;
let mut bit: usize = 1;
let mut n = n.as_usize();
while n != 0 {
if n & bit != 0 {
debug_assert!(idx < large_powers.len());
large::imul(x, large_powers[idx]);
n ^= bit;
}
idx += 1;
bit <<= 1;
}
}
}
```
<Overlap Ratio: 0.985545335085414>

---

--- 348 --
Question ID: 0651ab0dc08f3f2d1b5d25023fff11df1c0a25ee_26
Original Code:
```
pub fn get_scaling(out: &mut Vec3, mat: &Mat4) -> Vec3 {
    let mut vec_1: Vec3 = [0_f32; 3];
    vec_1[0] = mat[0]; // m11
    vec_1[1] = mat[1]; // m12
    vec_1[2] = mat[2]; // m13
    
    let mut vec_2: Vec3 = [0_f32; 3];
    vec_2[0] = mat[4]; // m21
    vec_2[1] = mat[5]; // m22
    vec_2[2] = mat[6]; // m23
    
    let mut vec_3: Vec3 = [0_f32; 3];
    vec_3[0] = mat[8]; // m31
    vec_3[1] = mat[9]; // m32
    vec_3[2] = mat[10]; // m33

    out[0] = hypot(&vec_1);
    out[1] = hypot(&vec_2);
    out[2] = hypot(&vec_3);

    *out
}
```


Overlapping Code:
```
ut Vec3, mat: &Mat4) -> Vec3 {
let mut vec_1: Vec3 = [0_f32; 3];
vec_1[0] = mat[0]; // m11
vec_1[1] = mat[1]; // m12
vec_1[2] = mat[2]; // m13

let mut vec_2: Vec3 = [0_f32; 3];
vec_2[0] = mat[4]; // m21
vec_2[1] = mat[5]; // m22
vec_2[2] = mat[6]; // m23

let mut vec_3: Vec3 = [0_f32; 3];
vec_3[0] = mat[8]; // m31
vec_3[1] = mat[9]; // m32
vec_3[2] = mat[10]; // m33
out[0] = hypot(&vec_1);
out[1]
```
<Overlap Ratio: 0.8438818565400844>

---

--- 349 --
Question ID: 86574efccd9c60520dc9c5b5f55b843f33903315_0
Original Code:
```
fn test_display() {
        check_display!(U8, 7);
        check_display!(U16, 707);
        check_display!(U32, 70707);
        check_display!(U64, 7070707);
        check_display!(Usize, 707070707);
    }
```


Overlapping Code:
```
_display!(U16, 707);
check_display!(U32, 70707);
check_display!(U64, 7070707);
check_display!(Usize,
```
<Overlap Ratio: 0.6172839506172839>

---

--- 350 --
Question ID: 0b8dd0539077de18bf9818291fd1c1c98e8ab743_4
Original Code:
```
fn test_marginal_zero_twosample() {
        let union = setup(2);
        let zero_likelihoods = zero_likelihoods();
        let (allelefreq_likelihoods, marginal) = union.marginal(&zero_likelihoods, &union.prior);
        println!("{:?} {}", allelefreq_likelihoods, marginal);
        for p in allelefreq_likelihoods {
            assert!(eq(p, 0.0));
        }
    }
```


Overlapping Code:
```
sample() {
let union = setup(2);
let zero_likelihoods = zero_likelihoods();
let (allelefreq_likelihoods, marginal) = union.marginal(&zero_likelihoods, &union.prior);
println!("{:?} {}", allelefreq_likelihoods, marginal);
for p in allelefreq_likelihoo
```
<Overlap Ratio: 0.8223684210526315>

---

--- 351 --
Question ID: 0a2a425f8c7ab0f667c6d55705bdfd8c4be3d356_7
Original Code:
```
fn test_get_save_resource_quota() {
        let ctx = SecurityContext::new("myorg", "myid");
        let ds = DefaultDataSource::new();
        let locator = RepositoryLocator::new(&ds);
        let pm = locator.new_persistence_manager();
        pm.clear();
        let realm = pm.realm_repository.create(&ctx, &SecurityRealm::new("myrealm", None)).unwrap();

        let resource = pm.new_resource_with(&ctx, &realm, "report").unwrap();
        let loaded = pm.resource_repository.get(&ctx, "myrealm", resource.id.as_str()).unwrap();
        assert_eq!(format!("{:?}", resource), format!("{:?}", loaded));

        let org = pm.org_repository.create(&ctx, &Organization::new("", None, "myorg", "url", None)).unwrap();

        let policy = pm.license_policy_repository.create(&ctx, &LicensePolicy::new("", org.id.as_str(), "default-policy", Some("desc".to_string()), Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();

        let _ = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new("", resource.id.as_str(), policy.id.as_str(), "", 2, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();

        let instance = pm.resource_instance_repository._create(&ctx, &ResourceInstance::new("", resource.id.as_str(), "22", "", "refid", "INFLIGHT", Some("blah".to_string()))).unwrap();

        let loaded = pm.resource_instance_repository.get(&ctx, instance.id.as_str()).unwrap();
        assert_eq!(format!("{:?}", instance), format!("{:?}", loaded));

        let quota = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new("", resource.id.as_str(), "22", "", 22, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();
        let loaded = pm.resource_quota_repository.get(&ctx, quota.id.as_str()).unwrap();
        assert_eq!(format!("{:?}", quota), format!("{:?}", loaded));
    }
```


Overlapping Code:
```
est_get_save_resource_quota() {
let ctx = SecurityContext::new("myorg", "myid");
let ds = DefaultDataSource::new();
let locator = RepositoryLocator::new(&ds);
let pm = locator.new_persistence_manager();
pm.clear();
let realm = pm.realm_repository.create(&ctx, &SecurityRealm::new("myrealm", None)).unwrap();
let resource = pm.new_resource_with(&ctx, &realm, "report").unwrap();
let loaded = pm.resource_repository.get(&ctx, "myrealm", resource.id.as_str()).unwrap();
assert_eq!(format!("{:?}", resource), format!("{:?}", loaded));
let org = pm.org_repository.create(&ctx, &Organization::new("", None, "myorg", "url", None)).unwrap();
let policy = pm.license_policy_repository.create(&ctx, &LicensePolicy::new("", org.id.as_str(), "default-policy", Some("desc".to_string()), Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();
let _ = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new("", resource.id.as_str(), policy.id.as_str(), "", 2, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();
let instance = pm.resource_instance_repository._create(&ctx, &ResourceInstance::new("", resource.id.as_str(), "22", "", "refid", "INFLIGHT", Some("blah".to_string()))).unwrap();
let loaded = pm.resource_instance_repository.get(&ctx, instance.id.as_str()).unwrap();
assert_eq!(format!("{:?}", instance), format!("{:?}", loaded));
let quota = pm.resource_quota_repository.create(&ctx, &ResourceQuota::new("", resource.id.as_str(), "22", "", 22, Utc::now().naive_utc(), NaiveDate::from_ymd(2100, 1, 1).and_hms(0, 0, 0))).unwrap();
let loaded = pm.resource_quota_repository.get(&ctx, quota.id.as_str()).unwrap();
assert_eq!(format!("{:?}
```
<Overlap Ratio: 0.9758897818599311>

---

--- 352 --
Question ID: 7e55261a1248777eef0aae82a8393788fc023fde_0
Original Code:
```
pub(super) fn handle_prev_state<'i>(
    tetraplet: &RSecurityTetraplet,
    output: &CallOutputValue<'i>,
    prev_result: CallResult,
    trace_pos: usize,
    exec_ctx: &mut ExecutionCtx<'i>,
    trace_ctx: &mut TraceHandler,
) -> ExecutionResult<bool> {
    use CallResult::*;

    let result = match &prev_result {
        // this call was failed on one of the previous executions,
        // here it's needed to bubble this special error up
        CallServiceFailed(ret_code, err_msg) => {
            exec_ctx.subtree_complete = false;
            exec_err!(ExecutionError::LocalServiceError(*ret_code, err_msg.clone()))
        }
        RequestSentBy(Sender::PeerIdWithCallId { peer_id, call_id })
            if peer_id.as_str() == exec_ctx.current_peer_id.as_str() =>
        {
            // call results are identified by call_id that is saved in data
            match exec_ctx.call_results.remove(call_id) {
                Some(call_result) => {
                    update_state_with_service_result(tetraplet, output, call_result, exec_ctx, trace_ctx)?;
                    return Ok(false);
                }
                // result hasn't been prepared yet
                None => {
                    exec_ctx.subtree_complete = false;
                    Ok(false)
                }
            }
        }
        RequestSentBy(..) => {
            // check whether current node can execute this call
            let is_current_peer = tetraplet.borrow().triplet.peer_pk.as_str() == exec_ctx.current_peer_id.as_str();
            if is_current_peer {
                // if this peer could execute this call early return and
                return Ok(true);
            }

            exec_ctx.subtree_complete = false;
            Ok(false)
        }
        // this instruction's been already executed
        Executed(value) => {
            set_result_from_value(value.clone(), tetraplet.clone(), trace_pos, output, exec_ctx)?;

            exec_ctx.subtree_complete = true;
            Ok(false)
        }
    };

    trace_ctx.meet_call_end(prev_result);
    result
}
```


Overlapping Code:
```
per) fn handle_prev_state<'i>(
tetraplet: &RSecurityTetraplet,
output: &CallOutputValue<'i>,
prev_result: CallResult,
trace_pos: usize,
exec_ctx: &mut ExecutionCtx<'i>,
trace_ctx: &mut TraceHandler,
) -> ExecutionResult<bool> {
use CallResult::*;
let result = match &prev_result {
// this call was failed on one of the previous executions,
// here it's needed to bubble this special error up
CallServiceFailed(ret_code, err_msg) => {
exec_ctx.subtree_complete = false;
exec_err!(ExecutionError::LocalServiceError(*ret_code, err_msg.clone()))
}
RequestSentBy(Sender::PeerIdWithCallId { peer_id, call_id })
if peer_id.as_str() == exec_ctx.current_peer_id.as_str() =>
{
// call results are identified by call_id that is saved in data
match exec_ctx.call_results.remove(call_id) {
Some(call_result) => {
update_state_with_service_result(tetraplet, output, call_result, exec_ctx, trace_ctx)?;
return Ok(false);
}
// result hasn't been prepared yet
None => {
exec_ctx.subtree_complete = false;
Ok(false)
}
}
}
RequestSentBy(..) => {
// check whether current node can execute this call
let is_current_peer = tetraplet.borrow().triplet.peer_pk.as_str() == exec_ctx.current_peer_id.as_str();
if is_current_peer {
// if this peer could execute this call early return and
return Ok(true);
}
exec_ctx.subtree_complete = false;
Ok(false)
}
// this instruction's been already executed
Executed(value) => {
set_result_from_value(value.clone(), tetraplet.clone(), trace_pos, output, exec_ctx)?;
exec_ctx.subtree_complete = true;
Ok(false)
}
};
trace_ctx.meet_call_en
```
<Overlap Ratio: 0.9810126582278481>

---

--- 353 --
Question ID: 204423cefd0862560f3654e60e0bb8c5b60d4e02_5
Original Code:
```
fn test_sin_cos() -> Result<()> {
    let mut g = Graph::new();
    let x0: f32 = 1.234;
    let x = g.scalar("x", x0)?;
    let s = g.sin(x);
    let ss = g.square(s);
    let c = g.cos(x);
    let cc = g.square(c);
    let z = g.add(ss, cc);
    abs_diff_eq!(g.eval_value(z)?.as_scalar()?, 1.0);
    g.eval_deriv(z)?;
    abs_diff_eq!(g.get_deriv(x)?.as_scalar()?, 0.0);
    Ok(())
}
```


Overlapping Code:
```
t_sin_cos() -> Result<()> {
let mut g = Graph::new();
let x0: f32 = 1.234;
let x = g.scalar("x", x0)?;
let s = g.sin(x);
let ss = g.square(s);
let c = g.cos(x);
let cc = g.square(c);
let z = g.add(ss, cc);
abs_diff_eq!(g.eval_value(z)?.as_scalar()?, 1.0);
g.eval_deriv(z)?;
abs_diff_eq!(g.get_deriv(x)?.as_scalar()?, 0.0);
Ok(())
}
```
<Overlap Ratio: 0.9821958456973294>

---

--- 354 --
Question ID: 9005f5b6d8e80f147425223a20183d539e4077b4_0
Original Code:
```
unsafe fn find_key_partition_sse2(skiplist: &[u32; SKIP_LEN], key: &MortonKey) -> usize {
    let key = key.0 as i32;
    let keys4 = _mm_set_epi32(key, key, key, key);

    let [s0, s1, s2, s3, s4, s5, s6, s7]: [i32; SKIP_LEN] = mem::transmute(*skiplist);
    let skiplist_a: __m128i = _mm_set_epi32(s0, s1, s2, s3);
    let skiplist_b: __m128i = _mm_set_epi32(s4, s5, s6, s7);

    // set every 32 bits to 0xFFFF if key < skip else sets it to 0x0000
    let results_a: __m128i = _mm_cmpgt_epi32(keys4, skiplist_a);
    let results_b: __m128i = _mm_cmpgt_epi32(keys4, skiplist_b);

    // create a mask from the most significant bit of each 8bit element
    let mask_a: i32 = _mm_movemask_epi8(results_a);
    let mask_b: i32 = _mm_movemask_epi8(results_b);

    // count the number of bits set to 1
    let index: i32 = _popcnt32(mask_a) + _popcnt32(mask_b);
    // because the mask was created from 8 bit wide items every key in skip list is counted
    // 4 times.
    index as usize / 4
}
```


Overlapping Code:
```
kiplist: &[u32; SKIP_LEN], key: &MortonKey) -> usize {
let key = key.0 as i32;
let keys4 = _mm_set_epi32(key, key, key, key);
let [s0, s1, s2, s3, s4, s5, s6, s7]: [i32; SKIP_LEN] = mem::transmute(*skiplist);
let skiplist_a: __m128i = _mm_set_epi32(s0, s1, s2, s3);
let skiplist_b: __m128i = _mm_set_epi32(s4, s5, s6, s7);
// set every 32 bits to 0xFFFF if key < skip else sets it to 0x0000
let results_a: __m128i = _mm_cmpgt_epi32(keys4, skiplist_a);
let results_b: __m128i = _mm_cmpgt_epi32(keys4, skiplist_b);
// create a mask from the most significant bit of each 8bit element
let mask_a: i32 = _mm_movemask_epi8(results_a);
let mask_b: i32 = _mm_movemask_epi8(results_b);
// count the number of bits set to 1
let index: i32 = _popcnt32(mask_a) + _popcnt32(mask_b);
// because the mask was created from 8 bit wide items every key in skip list is 
```
<Overlap Ratio: 0.918918918918919>

---

--- 355 --
Question ID: a0a4a475ff7313100cc6712a2adc4428df6c9b7e_0
Original Code:
```
fn tangram(py: Python, m: &PyModule) -> PyResult<()> {
	m.add_class::<LoadModelOptions>()?;
	m.add_class::<Model>()?;
	m.add_class::<PredictOptions>()?;
	m.add_class::<RegressionPredictOutput>()?;
	m.add_class::<BinaryClassificationPredictOutput>()?;
	m.add_class::<MulticlassClassificationPredictOutput>()?;
	m.add_class::<FeatureContributions>()?;
	m.add_class::<IdentityFeatureContribution>()?;
	m.add_class::<NormalizedFeatureContribution>()?;
	m.add_class::<OneHotEncodedFeatureContribution>()?;
	m.add_class::<BagOfWordsFeatureContribution>()?;
	m.add_class::<BagOfWordsCosineSimilarityFeatureContribution>()?;
	m.add_class::<WordEmbeddingFeatureContribution>()?;
	m.add("PredictInput", predict_input(py)?)?;
	m.add("PredictOutput", predict_output(py)?)?;
	m.add("FeatureContributionEntry", feature_contribution_entry(py)?)?;
	m.add("NGram", ngram(py)?)?;
	Ok(())
}
```


Overlapping Code:
```
(py: Python, m: &PyModule) -> PyResult<()> {
m.add_class::<LoadModelOptions>()?;
m.add_class::<Model>()?;
m.add_class::<PredictOptions>()?;
m.add_class::<RegressionPredictOutput>()?;
m.add_class::<BinaryClassificationPredictOutput>()?;
m.add_class::<MulticlassClassificationPredictOutput>()?;
m.add_class::<FeatureContributions>()?;
m.add_class::<IdentityFeatureContribution>()?;
m.add_class::<NormalizedFeatureContribution>()?;
m.add_class::<OneHotEncodedFeatureContribution>()?;
m.add_class::<BagOfWordsFeatureContribution>()?;
m.add_class::<BagOfWordsCosineSimilarityFeatureContribution>()?;
m.add_class::<WordEmbeddingFeatureContribution>()?;
m.add("PredictInput", predict_input(py)?)?;
m.add("PredictOutput", predict_output(py)?)?;
m.add("FeatureContributionEntry", feature_contribution_entry(py)?)?;
m.add("NGram", 
```
<Overlap Ratio: 0.9624853458382181>

---

--- 356 --
Question ID: 9e5b8a7d4d282a3f6376882d0af334b036b442c6_0
Original Code:
```
fn new_with_existing_path() {
        let directory = TempDir::new().unwrap();
        let repository = Repository::new(directory.into_path());

        assert!(repository.is_ok())
    }
```


Overlapping Code:
```
() {
let directory = TempDir::new().unwrap();
let repository = Repository::new(directory.into_path()
```
<Overlap Ratio: 0.6369426751592356>

---

--- 357 --
Question ID: e913ff3b57e18c9f8c91e7000124039928661733_3
Original Code:
```
fn atlas_basic() {
    let mut atlas = AtlasAllocator::new(size2(1000, 1000));

    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;
    assert!(atlas.allocate(size2(1, 1)).is_none());

    atlas.deallocate(full);

    let a = atlas.allocate(size2(10, 10)).unwrap().0;
    let b = atlas.allocate(size2(50, 30)).unwrap().0;
    let c = atlas.allocate(size2(12, 45)).unwrap().0;
    let d = atlas.allocate(size2(60, 45)).unwrap().0;
    let e = atlas.allocate(size2(1, 1)).unwrap().0;
    let f = atlas.allocate(size2(128, 128)).unwrap().0;
    let g = atlas.allocate(size2(256, 256)).unwrap().0;

    atlas.deallocate(b);
    atlas.deallocate(f);
    atlas.deallocate(c);
    atlas.deallocate(e);
    let h = atlas.allocate(size2(500, 200)).unwrap().0;
    atlas.deallocate(a);
    let i = atlas.allocate(size2(500, 200)).unwrap().0;
    atlas.deallocate(g);
    atlas.deallocate(h);
    atlas.deallocate(d);
    atlas.deallocate(i);

    let full = atlas.allocate(size2(1000, 1000)).unwrap().0;
    assert!(atlas.allocate(size2(1, 1)).is_none());
    atlas.deallocate(full);
}
```


Overlapping Code:
```

let mut atlas = AtlasAllocator::new(size2(1000, 1000));
let full = atlas.allocate(size2(1000, 1000)).unwrap().0;
assert!(atlas.allocate(size2(1, 1)).is_none());
atlas.deallocate(full);
let a = atlas.allocate(size2(10, 10)).unwrap().0;
let b = atlas.allocate(size2(50, 30)).unwrap().0;
let c = atlas.allocate(size2(12, 45)).unwrap().0;
let d = atlas.allocate(size2(60, 45)).unwrap().0;
let e = atlas.allocate(size2(1, 1)).unwrap().0;
let f = atlas.allocate(size2(128, 128)).unwrap().0;
let g = atlas.allocate(size2(256, 256)).unwrap().0;
atlas.deallocate(b);
atlas.deallocate(f);
atlas.deallocate(c);
atlas.deallocate(e);
let h = atlas.allocate(size2(500, 200)).unwrap().0;
atlas.deallocate(a);
let i = atlas.allocate(size2(500, 200)).unwrap().0;
atlas.deallocate(g);
atlas.deallocate(h);
atlas.deallocate(d);
atlas.deallocate(i);
let full = atlas.allocate(size2(1000, 1000)).unwrap().0;
assert!(atlas.allocate(size2(1, 1)).is_none());
atlas.deallocate(full
```
<Overlap Ratio: 0.9775280898876404>

---

--- 358 --
Question ID: 2966d50cd5041c46dd20ba88abe999dae708056f_4
Original Code:
```
fn consume_value(input: &[u8]) -> IResult<&[u8], String> {
    // use many1(consume_line) because many0 always returns true and causes a separated list error.
    let (input, chars) = separated_list0(many1(consume_line), many0(one_char_in_value))(input)?;
    Ok((input, chars.into_iter().flatten().collect::<String>()))
}
```


Overlapping Code:
```
put: &[u8]) -> IResult<&[u8], String> {
// use many1(consume_line) because many0 always returns true and causes a separated list error.
let (input, chars) = separated_list0(many1(consume_line), many0(one_char_in_value))(input)?;
Ok((input, chars.into_iter().flatten()
```
<Overlap Ratio: 0.8612903225806452>

---

--- 359 --
Question ID: 632a7b7123a5f5b5b6a80f8cccc5257a0dceb4b9_0
Original Code:
```
pub fn app(app: &App) -> parse::Result<()> {
    // in single-core context no static should use the `#[global]` attribute
    if app.cores == 1 {
        let main = &app.mains[0];
        for (name, static_) in main
            .init
            .iter()
            .flat_map(|init| &init.statics)
            .chain(main.idle.iter().flat_map(|idle| &idle.statics))
            .chain(app.tasks.values().flat_map(|task| &task.statics))
        {
            if static_.global {
                return Err(parse::Error::new(
                    name.span(),
                    "statics can NOT be marked as `#[global]` in single-core applications",
                ));
            }
        }
    }

    for (name, static_) in app.tasks.values().flat_map(|task| &task.statics) {
        if static_.global {
            return Err(parse::Error::new(
                name.span(),
                "statics within a `#[task]` can NOT be marked as `#[global]`",
            ));
        }
    }

    // Check that all referenced resources have been declared and that `static mut` resources are
    // *not* shared between cores
    let mut mut_resources = HashMap::new();
    for (core, name) in
        app.mains
            .iter()
            .zip(0..)
            .flat_map(move |(main, core)| {
                main.init
                    .iter()
                    .flat_map(move |init| init.args.resources.iter().map(move |res| (core, res)))
                    .chain(main.idle.iter().flat_map(move |idle| {
                        idle.args.resources.iter().map(move |res| (core, res))
                    }))
            })
            .chain(app.interrupts.values().flat_map(|interrupt| {
                let core = interrupt.args.core;
                interrupt.args.resources.iter().map(move |res| (core, res))
            }))
            .chain(app.tasks.values().flat_map(|task| {
                let core = task.args.core;
                task.args.resources.iter().map(move |res| (core, res))
            }))
    {
        let span = name.span();
        if let Some(res) = app.resources.get(name) {
            if res.mutability.is_some() {
                match mut_resources.entry(name) {
                    Entry::Occupied(entry) => {
                        if *entry.get() != core {
                            return Err(parse::Error::new(
                                span,
                                "`static mut` resources can NOT be accessed from different cores",
                            ));
                        }
                    }
                    Entry::Vacant(entry) => {
                        entry.insert(core);
                    }
                }
            }
        } else {
            return Err(parse::Error::new(
                span,
                "this resource has NOT been declared",
            ));
        }
    }

    for init in app.mains.iter().filter_map(|main| main.init.as_ref()) {
        // Check that late resources have not been assigned to `init`
        for res in &init.args.resources {
            if app.resources.get(res).unwrap().expr.is_none() {
                return Err(parse::Error::new(
                    res.span(),
                    "late resources can NOT be assigned to `init`",
                ));
            }
        }
    }

    // Check that all late resources are covered by `init::LateResources`
    let mut late_resources = app
        .resources
        .iter()
        .filter_map(|(name, res)| if res.expr.is_none() { Some(name) } else { None })
        .collect::<HashSet<_>>();
    if !late_resources.is_empty() {
        if app.cores == 1 {
            // the only core will initialize all late resources
        } else {
            // this core will initialize the "rest" of late resources
            let mut rest = None;

            let mut initialized = HashMap::new();
            for (core, init) in app.mains.iter().enumerate().filter_map(|(i, main)| {
                if let Some(init) = main.init.as_ref() {
                    if init.returns_late_resources {
                        Some((i, init))
                    } else {
                        None
                    }
                } else {
                    None
                }
            }) {
                if !init.args.late.is_empty() {
                    for res in &init.args.late {
                        if !late_resources.contains(&res) {
                            return Err(parse::Error::new(
                                res.span(),
                                "this is not a late resource",
                            ));
                        }

                        if let Some(other) = initialized.get(res) {
                            return Err(parse::Error::new(
                                res.span(),
                                &format!("this resource will be initialized by core {}", other),
                            ));
                        } else {
                            late_resources.remove(res);
                            initialized.insert(res, core);
                        }
                    }
                } else if let Some(rest) = rest {
                    return Err(parse::Error::new(
                        Span::call_site(),
                        &format!(
                            "unclear how initialization of late resources is split between \
                             cores {} and {}",
                            rest, core,
                        ),
                    ));
                } else {
                    rest = Some(core);
                }
            }

            if let Some(res) = late_resources.iter().next() {
                if rest.is_none() {
                    return Err(parse::Error::new(
                        res.span(),
                        "this resource is not being initialized",
                    ));
                }
            }
        }
    }

    // Check that all referenced tasks have been declared
    for task in app
        .mains
        .iter()
        .flat_map(|main| {
            main.init
                .iter()
                .flat_map(|init| &init.args.spawn)
                .chain(main.idle.iter().flat_map(|idle| &idle.args.spawn))
        })
        .chain(
            app.interrupts
                .values()
                .flat_map(|interrupt| &interrupt.args.spawn),
        )
        .chain(app.tasks.values().flat_map(|task| &task.args.spawn))
    {
        if !app.tasks.contains_key(task) {
            return Err(parse::Error::new(
                task.span(),
                "this task has NOT been declared",
            ));
        }
    }

    // Check that there are enough dispatchers to handle all priority levels
    for core in 0..app.cores {
        let ndispatchers = app
            .tasks
            .values()
            .filter_map(|task| {
                if task.args.core == core {
                    Some(task.args.priority)
                } else {
                    None
                }
            })
            .collect::<HashSet<_>>()
            .len();

        let used_sgis = app
            .interrupts
            .keys()
            .filter(|name| {
                let name = name.to_string();

                name.starts_with("SG")
                    && name[2..].parse::<u8>().map(|n| n < NSGIS).unwrap_or(false)
            })
            .count();

        if ndispatchers + usize::from(used_sgis) > usize::from(NSGIS) {
            return Err(parse::Error::new(
                Span::call_site(),
                "Not enough free Software-Generated Interrupts (SGI) to \
                 dispatch all task priorities",
            ));
        }
    }

    Ok(())
}
```


Overlapping Code:
```
: &App) -> parse::Result<()> {
// in single-core context no static should use the `#[global]` attribute
if app.cores == 1 {
let main = &app.mains[0];
for (name, static_) in main
.init
.iter()
.flat_map(|init| &init.statics)
.chain(main.idle.iter().flat_map(|idle| &idle.statics))
.chain(app.tasks.values().flat_map(|task| &task.statics))
{
if static_.global {
return Err(parse::Error::new(
name.span(),
"statics can NOT be marked as `#[global]` in single-core applications",
));
}
}
}
for (name, static_) in app.tasks.values().flat_map(|task| &task.statics) {
if static_.global {
return Err(parse::Error::new(
name.span(),
"statics within a `#[task]` can NOT be marked as `#[global]`",
));
}
}
// Check that all referenced resources have been declared and that `static mut` resources are
// *not* shared between cores
let mut mut_resources = HashMap::new();
for (core, name) in
app.mains
.iter()
.zip(0..)
.flat_map(move |(main, core)| {
main.init
.iter()
.flat_map(move |init| init.args.resources.iter().map(move |res| (core, res)))
.chain(main.idle.iter().flat_map(move |idle| {
idle.args.resources.iter().map(move |res| (core, res))
}))
})
.chain(app.interrupts.values().flat_map(|interrupt| {
let core = interrupt.args.core;
interrupt.args.resources.iter().map(move |res| (core, res))
}))
.chain(app.tasks.values().flat_map(|task| {
let core = task.args.core;
task.args.resources.iter().map(move |res| (core, res))
}))
{
let span = name.span();
if let Some(res) = app.resources.get(name) {
if res.mutability.is_some() {
match mut_resources.entry(name) {
Entry::Occupied(entry) => {
if *entry.get() != core {
return Err(parse::Error::new(
span,
"`static mut` resources can NOT be accessed from dif
```
<Overlap Ratio: 0.9837962962962963>

---

--- 360 --
Question ID: 7dd41a55ce1c74937639b8b4e7e38443fc76af10_1
Original Code:
```
pub fn split<S: Session, D1: Into<Vec<u8>>, D2: Into<Vec<u8>>>(
    stream: TcpStream,
    session: S,
    read_buf_cfg: BufCfg<D1>,
    write_buf_cfg: BufCfg<D2>,
) -> (ReadHalf<S>, WriteHalf<S>) {
    assert!(!session.is_handshaking());

    let shared = Arc::new(Shared {
        stream,
        session: Mutex::new(session),
    });

    let read_half = ReadHalf {
        shared: shared.clone(),
        buf: Buffer::build_from(read_buf_cfg),
    };

    let write_half = WriteHalf {
        shared,
        buf: Buffer::build_from(write_buf_cfg),
    };

    (read_half, write_half)
}
```


Overlapping Code:
```
D2: Into<Vec<u8>>>(
stream: TcpStream,
session: S,
read_buf_cfg: BufCfg<D1>,
write_buf_cfg: BufCfg<D2>,
) -> (ReadHalf<S>, WriteHalf<S>) {
assert!(!session.is_handshaking());
let shared = Arc::new(Shared {
stream,
session: Mutex::new(session),
});
let read_half = ReadHalf {
shared: shared.clone(),
buf: Buffer::build_from(read_buf_cfg),
};
let write_half = WriteHalf {
shared,
buf: Buffer::build_fro
```
<Overlap Ratio: 0.8163265306122449>

---

--- 361 --
Question ID: 0fc960e37e0993078e0d7aa34f598bc9c55ac668_0
Original Code:
```
fn test_garbling(b: &Bundler, inp: &[u128], should_be: &[u128]) {
        let c = b.borrow_builder().borrow_circ();
        let (gb, ev) = garble(&c);
        println!("number of ciphertexts: {}", ev.size());
        let enc_inp = b.encode(inp);
        assert_eq!(b.decode(&c.eval(&enc_inp)), should_be);
        let xs = gb.encode(&enc_inp);
        let ys = ev.eval(c, &xs);
        assert_eq!(b.decode(&gb.decode(&ys)), should_be);
    }
```


Overlapping Code:
```
should_be: &[u128]) {
let c = b.borrow_builder().borrow_circ();
let (gb, ev) = garble(&c);
println!("number of ciphertexts: {}", ev.size());
let enc_inp = b.encode(inp);
assert_eq!(b.decode(&c.eval(&enc_inp)), should_be);
let xs = gb.encode(&enc_inp);
let ys = ev.eval(c, &xs);
assert_eq!(b.decode(&g
```
<Overlap Ratio: 0.8042895442359249>

---

--- 362 --
Question ID: 8fbd63582788474dbc94e0582dac8286cb21466b_7
Original Code:
```
fn from_nested_fn_application() {
        let env = Default::default();
        let iter = 'a'..='z';

        // (((\x -> (\y -> x + y)) 3) 4)
        let x = Expr::Variable("x".to_string());
        let y = Expr::Variable("y".to_string());
        let plus_expr = Expr::Plus(Box::new(x), Box::new(y));
        let inner_fn_expr = Expr::Lambda("y".to_string(), Box::new(plus_expr));
        let outer_fn_expr = Expr::Lambda("x".to_string(), Box::new(inner_fn_expr));
        let inner_apply_expr =
            Expr::Application(Box::new(outer_fn_expr), Box::new(Expr::Integer(3)));
        let outer_apply_expr =
            Expr::Application(Box::new(inner_apply_expr), Box::new(Expr::Integer(4)));

        let result = infer(env, iter, outer_apply_expr);
        assert!(result.is_ok());

        let (_env, _iter, t) = result.unwrap();
        assert_eq!(Type::Integer, t);
    }
```


Overlapping Code:
```
ested_fn_application() {
let env = Default::default();
let iter = 'a'..='z';
// (((\x -> (\y -> x + y)) 3) 4)
let x = Expr::Variable("x".to_string());
let y = Expr::Variable("y".to_string());
let plus_expr = Expr::Plus(Box::new(x), Box::new(y));
let inner_fn_expr = Expr::Lambda("y".to_string(), Box::new(plus_expr));
let outer_fn_expr = Expr::Lambda("x".to_string(), Box::new(inner_fn_expr));
let inner_apply_expr =
Expr::Application(Box::new(outer_fn_expr), Box::new(Expr::Integer(3)));
let outer_apply_expr =
Expr::Application(Box::new(inner_apply_expr), Box::new(Expr::Integer(4)));
let result = infer(env, iter, outer_apply_expr);
assert!(result.is_ok());
let (_env, _iter, t) = result.unwrap();
assert_eq!(Type::Integer, 
```
<Overlap Ratio: 0.9811066126855601>

---

--- 363 --
Question ID: c5fb082f6c1c020ced5a2b2ba571a8f1e84af913_2
Original Code:
```
fn main() {
    unsafe { pinmux_init() };

    log_init();

    info!("Hello World");

    TSEC.init();

    bring_up_sors();

    let mut argument0 = 0;
    let mut argument1 = 0;
    let res = execute_tsec_fw(&*FALCON_FW, 0, &mut argument0, &mut argument1);

    info!("{:?}", res);
    info!("argument0: 0x{:x}", argument0);
    info!("argument1: 0x{:x}", argument1);

    TSEC.finalize();
}
```


Overlapping Code:
```
{ pinmux_init() };
log_init();
info!("Hello World");
TSEC.init();
bring_up_sors();
let mut argument0 = 0;
let mut argument1 = 0;
let res = execute_tsec_fw(&*FALCON_FW, 0, &mut argument0, &mut argument1);
info!("{:?}", res);
info!("argument0: 0x{:x}", argument0);
info!("argument1: 0x{:x}", argument1);
```
<Overlap Ratio: 0.887905604719764>

---

--- 364 --
Question ID: b563d050d34868c77a1a89289a4a572ac873715a_5
Original Code:
```
fn chained_comparisons_with_larger_context() {
    let input = "x == 3 && 1 + 2 > x.abs() == 3 && T";
    let err = binary_expr::<FieldGrammar, Complete>(InputSpan::new(input)).unwrap_err();
    let err = match err {
        NomErr::Failure(err) => err,
        _ => panic!("Unexpected error: {:?}", err),
    };
    assert_matches!(err.kind(), ErrorKind::ChainedComparison);
    assert_eq!(*err.span().fragment(), "1 + 2 > x.abs() == 3");
}
```


Overlapping Code:
```
d_comparisons_with_larger_context() {
let input = "x == 3 && 1 + 2 > x.abs() == 3 && T";
let err = binary_expr::<FieldGrammar, Complete>(InputSpan::new(input)).unwrap_err();
let err = match err {
NomErr::Failure(err) => err,
_ => panic!("Unexpected error: {:?}", err),
};
assert_matches!(err.kind(), ErrorKind::ChainedComparison);
assert_eq!(*err.spa
```
<Overlap Ratio: 0.8728179551122195>

---

--- 365 --
Question ID: fb13b451b9de6398312d51d0ec2fc8e4dbb931f8_1
Original Code:
```
fn test_part_one() {
        let input = r#"#######
#.G...#
#...EG#
#.#.#G#
#..G#E#
#.....#
#######"#;

        let mut cave = Cave::from_str(&input).unwrap();

        assert_eq!(27_730, cave.get_outcome());
    }
```


Overlapping Code:
```
ne() {
let input = r#"#######
#.G...#
#...EG#
#.#.#G#
#..G#E#
#.....#
#######"#;
let mut cave = Cave::from_str(&input).unwrap();
assert_eq!(27_730, ca
```
<Overlap Ratio: 0.8152173913043478>

---

--- 366 --
Question ID: a36b87cc4d19effefcd8ce0c9a1f9d7eb3a239fe_0
Original Code:
```
pub fn module_doc(module: DbItem<&RustModule>, database: &DatabaseClient) -> Result<String> {
    let mut output = String::new();

    match module.item.kind {
        RustModuleKind::Special(kind) => match kind {
            RustSpecialModuleKind::CrateRoot => {
                let doc_item = database.find_doc_for(&module.id)?;
                if let Some(doc_item) = &doc_item {
                    write!(output, "{}", doc_item.item.html)?;
                }
                writeln!(
                    output,
                    "This crate was generated by `ritual`.
                    See [README](https://github.com/rust-qt/ritual) for more information.\n"
                )?;
            }
            RustSpecialModuleKind::Ffi => {
                write!(output, "Functions provided by the C++ wrapper library")?;
            }
            RustSpecialModuleKind::Ops => {
                write!(output, "Functions that provide access to C++ operators")?;
            }
            RustSpecialModuleKind::SizedTypes => {
                write!(
                    output,
                    "Types with the same size and alignment as corresponding C++ types"
                )?;
            }
        },
        RustModuleKind::CppNamespace { .. } => {
            let cpp_item = database
                .source_cpp_item(&module.id)?
                .ok_or_else(|| err_msg("source cpp item not found"))?
                .item
                .as_namespace_ref()
                .ok_or_else(|| err_msg("invalid source cpp item type"))?;

            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());
            write!(output, "C++ namespace: {}", cpp_path_text)?;
        }
        RustModuleKind::CppNestedTypes { .. } => {
            let cpp_item = database
                .source_cpp_item(&module.id)?
                .ok_or_else(|| err_msg("source cpp item not found"))?
                .item
                .as_type_ref()
                .ok_or_else(|| err_msg("invalid source cpp item type"))?;

            let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());
            write!(output, "C++ type: {}", cpp_path_text)?;
        }
    };
    Ok(output)
}
```


Overlapping Code:
```
module_doc(module: DbItem<&RustModule>, database: &DatabaseClient) -> Result<String> {
let mut output = String::new();
match module.item.kind {
RustModuleKind::Special(kind) => match kind {
RustSpecialModuleKind::CrateRoot => {
let doc_item = database.find_doc_for(&module.id)?;
if let Some(doc_item) = &doc_item {
write!(output, "{}", doc_item.item.html)?;
}
writeln!(
output,
"This crate was generated by `ritual`.
See [README](https://github.com/rust-qt/ritual) for more information.\n"
)?;
}
RustSpecialModuleKind::Ffi => {
write!(output, "Functions provided by the C++ wrapper library")?;
}
RustSpecialModuleKind::Ops => {
write!(output, "Functions that provide access to C++ operators")?;
}
RustSpecialModuleKind::SizedTypes => {
write!(
output,
"Types with the same size and alignment as corresponding C++ types"
)?;
}
},
RustModuleKind::CppNamespace { .. } => {
let cpp_item = database
.source_cpp_item(&module.id)?
.ok_or_else(|| err_msg("source cpp item not found"))?
.item
.as_namespace_ref()
.ok_or_else(|| err_msg("invalid source cpp item type"))?;
let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());
write!(output, "C++ namespace: {}", cpp_path_text)?;
}
RustModuleKind::CppNestedTypes { .. } => {
let cpp_item = database
.source_cpp_item(&module.id)?
.ok_or_else(|| err_msg("source cpp item not found"))?
.item
.as_type_ref()
.ok_or_else(|| err_msg("invalid source cpp item type"))?;
let cpp_path_text = wrap_inline_cpp_code(&cpp_item.path.to_cpp_pseudo_code());
write!(output, "C++ type: {}", cpp_path_text)?;

```
<Overlap Ratio: 0.9847812301838935>

---

--- 367 --
Question ID: b0de9a620a833c48304e5ef6e6069bc9b3d0a515_5
Original Code:
```
fn cancel_pledge(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    contract_info: ContractInfo,
    id: String,
) -> Result<Response<ProvenanceMsg>, ContractError> {
    // locate the pledge
    let mut pledge = load_pledge(deps.storage, id.as_bytes())?;

    // only pledges that are in the "PROPOSED" or "ACCEPTED" states can be cancelled
    let remove_assets_from_escrow = true;
    let mut remove_advance_from_escrow = false;
    match pledge.state {
        PledgeState::Proposed => {}
        PledgeState::Accepted => {
            remove_advance_from_escrow = true;
        }
        _ => {
            return Err(ContractError::StateError {
                error:
                    "Unable to cancel pledge: Pledge is not in the 'proposed' or 'accepted' state."
                        .into(),
            })
        }
    }

    // ensure the contract has privs on the escrow marker
    let querier = ProvenanceQuerier::new(&deps.querier);
    let escrow_marker =
        querier.get_marker_by_address(contract_info.facility.escrow_marker.clone())?;
    if !marker_has_grant(
        escrow_marker.clone(),
        AccessGrant {
            address: env.contract.address,
            permissions: vec![MarkerAccess::Transfer, MarkerAccess::Withdraw],
        },
    ) {
        return Err(ContractError::MissingEscrowMarkerGrant {});
    }

    // messages to include in transaction
    let mut messages = Vec::new();

    // remove the advance from escrow back to the warehouse account
    if remove_advance_from_escrow {
        // withdraw advance funds from the escrow marker account to the warehouse
        messages.push(withdraw_coins(
            escrow_marker.denom,
            pledge.total_advance.into(),
            contract_info.facility.stablecoin_denom.clone(),
            contract_info.facility.warehouse,
        )?);
    }

    // remove the assets (asset marker) from escrow
    if remove_assets_from_escrow {
        let asset_marker = querier.get_marker_by_denom(pledge.asset_marker_denom.clone())?;

        // transfer the asset marker back to the marker supply
        messages.push(transfer_marker_coins(
            1,
            pledge.asset_marker_denom.clone(),
            asset_marker.address,
            contract_info.facility.originator,
        )?);

        // cancel the asset marker
        messages.push(cancel_marker(pledge.asset_marker_denom.clone())?);

        // destroy the asset marker
        messages.push(destroy_marker(pledge.asset_marker_denom.clone())?);
    }

    // update the pledge
    pledge.state = PledgeState::Cancelled;
    save_pledge(deps.storage, &pledge.id.as_bytes(), &pledge)?;

    // remove the assets from the inventory
    remove_assets(deps.storage, &pledge.assets)?;

    Ok(Response::new()
        .add_messages(messages)
        .add_attribute("action", "cancel_pledge")
        .set_data(to_binary(&pledge)?))
}
```


Overlapping Code:
```
e(
deps: DepsMut,
env: Env,
_info: MessageInfo,
contract_info: ContractInfo,
id: String,
) -> Result<Response<ProvenanceMsg>, ContractError> {
// locate the pledge
let mut pledge = load_pledge(deps.storage, id.as_bytes())?;
// only pledges that are in the "PROPOSED" or "ACCEPTED" states can be cancelled
let remove_assets_from_escrow = true;
let mut remove_advance_from_escrow = false;
match pledge.state {
PledgeState::Proposed => {}
PledgeState::Accepted => {
remove_advance_from_escrow = true;
}
_ => {
return Err(ContractError::StateError {
error:
"Unable to cancel pledge: Pledge is not in the 'proposed' or 'accepted' state."
.into(),
})
}
}
// ensure the contract has privs on the escrow marker
let querier = ProvenanceQuerier::new(&deps.querier);
let escrow_marker =
querier.get_marker_by_address(contract_info.facility.escrow_marker.clone())?;
if !marker_has_grant(
escrow_marker.clone(),
AccessGrant {
address: env.contract.address,
permissions: vec![MarkerAccess::Transfer, MarkerAccess::Withdraw],
},
) {
return Err(ContractError::MissingEscrowMarkerGrant {});
}
// messages to include in transaction
let mut messages = Vec::new();
// remove the advance from escrow back to the warehouse account
if remove_advance_from_escrow {
// withdraw advance funds from the escrow marker account to the warehouse
messages.push(withdraw_coins(
escrow_marker.denom,
pledge.total_advance.into(),
contract_info.facility.stablecoin_denom.clone(),
contract_info.facility.warehouse,
)?);
}
// remove the assets (asset marker) from escrow
if remove_assets_from_escrow {
let asset_marker = querier.get_marker_by_denom(pledge.asset_marker_denom.clone())?;
// transfer the asset marker back to the marker supply
messages.push(transfer_marker_coins(
1,
pledge.asset_marker_denom.clone(),
asset_marker.address,
contract_info.facility.originator,
)?);
// cancel the asset marker
messages.push(cancel_marker(pledge.asset_marker_denom.clone())?);
// destroy the asset mark
```
<Overlap Ratio: 0.9755854509217738>

---

--- 368 --
Question ID: 34b32829b1c114138ede140210591eeacaee1049_31
Original Code:
```
fn bindgen_test_layout__jl_methtable_t() {
    assert_eq!(
        ::std::mem::size_of::<_jl_methtable_t>(),
        80usize,
        concat!("Size of: ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_jl_methtable_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_jl_methtable_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(defs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(max_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(kwsorter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(backedges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(writelock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).offs as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(offs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).frozen as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_jl_methtable_t),
            "::",
            stringify!(frozen)
        )
    );
}
```


Overlapping Code:
```
ndgen_test_layout__jl_methtable_t() {
assert_eq!(
::std::mem::size_of::<_jl_methtable_t>(),
80usize,
concat!("Size of: ", stringify!(_jl_methtable_t))
);
assert_eq!(
::std::mem::align_of::<_jl_methtable_t>(),
8usize,
concat!("Alignment of ", stringify!(_jl_methtable_t))
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).name as *const _ as usize },
0usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(name)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).defs as *const _ as usize },
8usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(defs)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).cache as *const _ as usize },
16usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(cache)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).max_args as *const _ as usize },
24usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(max_args)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).kwsorter as *const _ as usize },
32usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(kwsorter)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).module as *const _ as usize },
40usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(module)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).backedges as *const _ as usize },
48usize,
concat!(
"Offset of field: ",
stringify!(_jl_methtable_t),
"::",
stringify!(backedges)
)
);
assert_eq!(
unsafe { &(*(::std::ptr::null::<_jl_methtable_t>())).writelock as *const _ as usize },
56usize,
concat!(
"Offset of field: ",
```
<Overlap Ratio: 0.9971846846846847>

---

--- 369 --
Question ID: f1f50c44e1a3b9cb77c15e35f587e14ce4738774_0
Original Code:
```
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    if msg.unit_price == Uint128::new(0) {
        return Err(ContractError::InvalidUnitPrice {});
    }

    if msg.max_tokens == 0 {
        return Err(ContractError::InvalidMaxTokens {});
    }

    let config = Config {
        cw721_address: None,
        cw20_address: msg.cw20_address,
        unit_price: msg.unit_price,
        max_tokens: msg.max_tokens,
        owner: info.sender,
        name: msg.name.clone(),
        symbol: msg.symbol.clone(),
        token_uri: msg.token_uri.clone(),
        extension: msg.extension.clone(),
        unused_token_id: 0,
    };

    CONFIG.save(deps.storage, &config)?;

    let sub_msg: Vec<SubMsg> = vec![SubMsg {
        msg: WasmMsg::Instantiate {
            code_id: msg.token_code_id,
            msg: to_binary(&Cw721InstantiateMsg {
                name: msg.name.clone(),
                symbol: msg.symbol,
                minter: env.contract.address.to_string(),
            })?,
            funds: vec![],
            admin: None,
            label: String::from("Instantiate Limited Edition NFT"),
        }
        .into(),
        id: INSTANTIATE_TOKEN_REPLY_ID,
        gas_limit: None,
        reply_on: ReplyOn::Success,
    }];

    Ok(Response::new().add_submessages(sub_msg))
}
```


Overlapping Code:
```
pub fn instantiate(
deps: DepsMut,
env: Env,
info: MessageInfo,
msg: InstantiateMsg,
) -> Result<Response, ContractError> {
set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;
if msg.unit_price == Uint128::new(0) {
return Err(ContractError::InvalidUnitPrice {});
}
if msg.max_tokens == 0 {
return Err(ContractError::InvalidMaxTokens {});
}
let config = Config {
cw721_address: None,
cw20_address: msg.cw20_address,
unit_price: msg.unit_price,
max_tokens: msg.max_tokens,
owner: info.sender,
name: msg.name.clone(),
symbol: msg.symbol.clone(),
token_uri: msg.token_uri.clone(),
extension: msg.extension.clone(),
unused_token_id: 0,
};
CONFIG.save(deps.storage, &config)?;
let sub_msg: Vec<SubMsg> = vec![SubMsg {
msg: WasmMsg::Instantiate {
code_id: msg.token_code_id,
msg: to_binary(&Cw721InstantiateMsg {
name: msg.name.clone(),
symbol: msg.symbol,
minter: env.contract.address.to_string(),
})?,
funds: vec![],
admin: None,
label: String::from("Instantiate Limited Edition NFT"),
}
.into(),
id: INSTANTIATE_TOKEN_REPLY_ID,
gas_limit: None,
reply_on: ReplyOn::Success,
}];
Ok(Response::new().add_submessages(sub_m
```
<Overlap Ratio: 0.9947229551451188>

---

--- 370 --
Question ID: 3356c633d3d77bd0502bb673e8b4615208c04dc3_1
Original Code:
```
fn find_test_2() {
    let string = ByteStr::from_slice(b"0123456789 0123456789");
    assert_eq!(string.find(b'5'), Some(5));
    assert_eq!(string.rfind(b'5'), Some(17));
}
```


Overlapping Code:
```
d_test_2() {
let string = ByteStr::from_slice(b"0123456789 0123456789");
assert_eq!(string.find(b'5'), Some(5));
assert_eq!(string.rfind(b'5'), Some(1
```
<Overlap Ratio: 0.9259259259259259>

---

--- 371 --
Question ID: 8e9ce975aaa522a6355fe99d60baa602d78a9c76_7
Original Code:
```
fn test_bash_parser_exit() {
        let (core, _): (ShellCore, UserStream) = ShellCore::new(None, 32, Box::new(Bash::new()));
        let parser: Bash = Bash::new();
        //Simple case
        let mut input: VecDeque<String> = parser.readline(&String::from("0")).unwrap();
        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));
        assert_eq!(input.len(), 0); //Should be empty
        //Simple case
        let mut input: VecDeque<String> = parser.readline(&String::from("128")).unwrap();
        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(128));
        assert_eq!(input.len(), 0); //Should be empty
        //Bad case
        let mut input: VecDeque<String> = parser.readline(&String::from("foobar")).unwrap();
        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(2));
        assert_eq!(input.len(), 0); //Should be empty
        //No arg
        let mut input: VecDeque<String> = VecDeque::new();
        assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));
        assert_eq!(input.len(), 0); //Should be empty
    }
```


Overlapping Code:
```
it() {
let (core, _): (ShellCore, UserStream) = ShellCore::new(None, 32, Box::new(Bash::new()));
let parser: Bash = Bash::new();
//Simple case
let mut input: VecDeque<String> = parser.readline(&String::from("0")).unwrap();
assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));
assert_eq!(input.len(), 0); //Should be empty
//Simple case
let mut input: VecDeque<String> = parser.readline(&String::from("128")).unwrap();
assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(128));
assert_eq!(input.len(), 0); //Should be empty
//Bad case
let mut input: VecDeque<String> = parser.readline(&String::from("foobar")).unwrap();
assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(2));
assert_eq!(input.len(), 0); //Should be empty
//No arg
let mut input: VecDeque<String> = VecDeque::new();
assert_eq!(parser.parse_exit(&mut input).unwrap(), ShellStatement::Exit(0));
assert_eq!(input.len(), 0); //Should be empty

```
<Overlap Ratio: 0.9768145161290323>

---

--- 372 --
Question ID: c0c2ab67e382e0194906e80c4955867a84636b7c_1
Original Code:
```
fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {
    if adt_def.is_struct() {
        if let Some(variant) = adt_def.variants.iter().next() {
            return Some(variant);
        }
    }

    if adt_def.is_enum() {
        let pat_ident = last_path_segment(qpath).ident;
        for variant in &adt_def.variants {
            if variant.ident == pat_ident {
                return Some(variant);
            }
        }
    }

    None
}
```


Overlapping Code:
```
>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {
if adt_def.is_struct() {
if let Some(variant) = adt_def.variants.iter().next() {
return Some(variant);
}
}
if adt_def.is_enum() {
let pat_ident = last_path_segment(qpath).ident;
for variant in &adt_def.variants {
if variant.ident == pat_ident {
return So
```
<Overlap Ratio: 0.8852459016393442>

---

--- 373 --
Question ID: d9eda8e10a392702a5c2464d513be2b36c1e5394_2
Original Code:
```
fn join<T: Iterator<Item = String>>(start: &str, sep: &str, end: &str, strings: T) -> String {
    let mut res = String::new();
    res.push_str(start);
    for (i, s) in strings.enumerate() {
        if i > 0 {
            res.push_str(sep);
        }
        res.push_str(&s);
    }
    res.push_str(end);
    res
}
```


Overlapping Code:
```
art: &str, sep: &str, end: &str, strings: T) -> String {
let mut res = String::new();
res.push_str(start);
for (i, s) in strings.enumerate() {
if i > 0 {
res.push_str(sep);
}
res.push_str(&s);
}
res.push_str(end);
res
}
```
<Overlap Ratio: 0.8521400778210116>

---

--- 374 --
Question ID: d9978a75a3e525617b622bf31ea91bcc1ebf1088_14
Original Code:
```
fn test_failing() {
        let mut at = ArrayStump::new_explicit(|a: &f64, b: &f64| a.partial_cmp(b).unwrap(), 16);
        #[rustfmt::skip]
        let vals = vec![0.6994135560499647, 0.15138991083383901, 0.17989509662598502, 0.22855960374503625, 0.7394173591733456, 0.8606810583068278, 0.025843624735059523, 0.1416162372765526, 0.9789425643425963, 0.6312677864630949, 0.34678659888024466, 0.7876614416763924, 0.6260871506068197, 0.34733559592131624, 0.5722923635764159, 0.14416998787798063, 0.839158671060864, 0.2621428817535354, 0.9334439919690996, 0.016414089291711065, 0.8795903741012259, 0.051958655798298614, 0.8313985552845266, 0.026928982020677505, 0.779969564116276, 0.6437306675337413, 0.03822809941255523, 0.777911020749552, 0.4639770428538855, 0.7039388191038694, 0.31363729764551374, 0.8111651227165783, 0.5174339383176408, 0.49384841003283086, 0.5214549475595969, 0.0823716635367353, 0.7310183483079477, 0.6196297749276181, 0.6226877845880779, 0.8987550167723078, 0.9536731852226494, 0.2719858776118911, 0.837006810218081, 0.7570466272336563, 0.9649096907962248, 0.09547804495341239, 0.26299769639555115, 0.6883529379785718, 0.23545125345269502, 0.5611223421257663, 0.81145380876482, 0.7821846165410649, 0.8385374221326543, 0.2287909449815878, 0.9938012642875733, 0.30515950398348823, 0.021945251189301795, 0.7456118789178752, 0.24917873250483202, 0.19461925257672297, 0.08596890658908873, 0.8208413553993631, 0.2799020116906893, 0.622583855342935, 0.3406868767224045, 0.7125811318179431, 0.8171813899535424, 0.9875530622413784, 0.8124194427320398, 0.27890169087536465, 0.4582999489551358, 0.8170130026270258, 0.1116683852975886, 0.9523649049789342, 0.1626401579175366, 0.7006463636943299, 0.5396656897339597, 0.73824000529768, 0.8975902131523751, 0.3138666758196337, 0.959190654990596, 0.6786382471256971, 0.8807317907186307, 0.9923109213923168, 0.7704353170122445, 0.20331717853087872, 0.9191784945915048, 0.3458975102965529, 0.44567705127366397, 0.08758863415076357, 0.8940937525362007, 0.2046747373689708, 0.1540080303289173, 0.8088614347095653, 0.09821866105193844, 0.050284880746519045, 0.9585396829998039, 0.35100273069739263, 0.8263845327940142, 0.6305932414080216];
        for (i, x) in vals.iter().enumerate() {
            at.insert(*x);
            let mut expected = vals[0 .. i + 1].to_vec();
            expected.sort_by(|a, b| a.partial_cmp(b).unwrap());
            assert_eq!(at.collect(), expected);
        }
    }
```


Overlapping Code:
```
4416998787798063, 0.839158671060864, 0.26214288175.sort_by(|a, b| a.partial_cmp(b).unwrap());
assert_eq!(
```
<Overlap Ratio: 0.04451038575667656>

---

--- 375 --
Question ID: 39dbd4abdfdd2a2751c87dd4d1cb76f099479085_1
Original Code:
```
async fn get_matching_stream(ctx: &Ctx, user: &User) -> Option<Livestream> {
    let data = ctx.data.read().await;
    let streams = data.get::<StreamIndex>().unwrap().borrow();

    let matching_stream = streams
        .iter()
        .map(|(_, s)| s)
        .find(|s| s.state == StreamState::Live && s.streamer == *user);

    matching_stream.cloned()
}
```


Overlapping Code:
```
 &Ctx, user: &User) -> Option<Livestream> {
let data = ctx.data.read().await;
let streams = data.get::<StreamIndex>().unwrap().borrow();
let matching_stream = streams
.iter()
.map(|(_, s)| s)
.find(|s| s.state == StreamState::Live && s.streamer == *u
```
<Overlap Ratio: 0.7936507936507936>

---

--- 376 --
Question ID: c6de237a8345276d108f0e535b47e3f9844c6e4c_0
Original Code:
```
async fn to_file_stream(
    mut stream: impl Stream<Item = IoResult> + Unpin,
    logger: slog::Logger,
) -> Result<impl Stream<Item = IoResult>> {
    let path = format!(
        "/mnt/cache/{}",
        FILE_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
    );
    let mut file = FileWrapper::open(&path).await?;
    while let Some(v) = stream.next().await {
        let v = v?;
        file.as_mut().write_all(&v).await?;
    }
    Ok(file.into_bytes_stream(logger).await?)
}
```


Overlapping Code:
```
am<Item = IoResult> + Unpin,
logger: slog::Logger,
) -> Result<impl Stream<Item = IoResult>> {
let path = format!(
"/mnt/cache/{}",
FILE_ID.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
);
let mut file = FileWrapper::open(&path).await?;
while let Some(v) = stream.next().await {
let v = v?;
file.as_mut().write_all(&v).await?;
}
Ok(file.into_byte
```
<Overlap Ratio: 0.8293838862559242>

---

--- 377 --
Question ID: 037795e145eb026fdc4889fb5aa7f8a97951fbd3_2
Original Code:
```
fn part2(input: &str) {

    let (dots, ins) = parse_input(&input);

    let mut paper = Paper{dots};

    paper.run(&ins);
    paper.show();
}
```


Overlapping Code:
```
str) {
let (dots, ins) = parse_input(&input);
let mut paper = Paper{dots};
paper.run(&ins);
paper.show()
```
<Overlap Ratio: 0.8387096774193549>

---

--- 378 --
Question ID: fb1899d1f4ff3356fca34160763acb03902e9783_0
Original Code:
```
pub fn new_salt() -> error::Result<Vec<u8>> {
    const SALT_SIZE: usize = 16;
    let mut salt = vec![0u8; SALT_SIZE];
    let rng = rand::SystemRandom::new();
    rng.fill(&mut salt)?;
    Ok(salt)
}
```


Overlapping Code:
```
 {
const SALT_SIZE: usize = 16;
let mut salt = vec![0u8; SALT_SIZE];
let rng = rand::SystemRandom::new();
rng.fill(&m
```
<Overlap Ratio: 0.6464088397790055>

---

--- 379 --
Question ID: ea0850b98c76acce3979694f0423bba9fb7604b7_1
Original Code:
```
fn test_string_writer_markdown() {
        let mut writer = StringWriter::markdown();
        writer.spacing(2);
        assert_eq!(writer.write(), "\n\n");

        let mut writer = StringWriter::markdown();
        writer.title("Hello world");
        writer.spacing(2);
        assert_eq!(writer.write(), "# Hello world\n\n\n");

        let mut writer = StringWriter::markdown();
        writer.title("TITLE");
        let variant = variant!("basic", "Basic Notes", true);
        writer.variant_header(&variant);
        writer.release_note(&variant, "ticket", "description", "issue");
        writer.variant_footer();
        assert_eq!(
            writer.write(),
            "# TITLE\n\n## Basic Notes\n\n- ticket: description issue\n"
        );
    }
```


Overlapping Code:
```
ut writer = StringWriter::markdown();
writer.spacing(2);
assert_eq!(writer.write(), "\n\n");
let mut writer = StringWriter::markdown();
writer.title("Hello world");
writer.spacing(2);
assert_eq!(writer.write(), "# Hello world\n\n\n");
let mut writer = StringWriter::markdown();
writer.title("TITLE");
let variant = variant!("basic", "Basic Notes", true);
writer.variant_header(&variant);
writer.release_note(&variant, "ticket", "description", "issue");
writer.variant_footer();
assert_eq!(
writer.write(),
"# TITLE\n\n## Basic Notes\n\n- ticket: desc
```
<Overlap Ratio: 0.900163666121113>

---

--- 380 --
Question ID: 3d2259d8a01be262eb3f081d00e29db146116d2c_1
Original Code:
```
fn load_thread_state() {
        let init_epoch = Epoch::with_epoch(128);
        let thread_state = ThreadState::new(init_epoch);
        let (epoch, state) = thread_state.load(Relaxed);

        assert_eq!(init_epoch, epoch);
        assert_eq!(state, Inactive);
    }
```


Overlapping Code:
```
ad_thread_state() {
let init_epoch = Epoch::with_epoch(128);
let thread_state = ThreadState::new(init_epoch);
let (epoch, state) = thread_state.load(Relaxed);
assert_eq!(init_epoch, epoch);
assert_eq!
```
<Overlap Ratio: 0.8888888888888888>

---

--- 381 --
Question ID: c23cb8d2c2cb35a845ab5abacffa70c1c9f7ca1d_2
Original Code:
```
fn pack_unpack_valid() {
    let message = MessageBuilder::<Miner>::new()
        .with_network_id(0)
        .with_parents(rand_parents())
        .finish()
        .unwrap();
    let packed_message = message.pack_new();

    assert_eq!(packed_message.len(), message.packed_len());
    assert_eq!(message, Packable::unpack(&mut packed_message.as_slice()).unwrap());
}
```


Overlapping Code:
```

let message = MessageBuilder::<Miner>::new()
.with_network_id(0)
.with_parents(rand_parents())
.finish()
.unwrap();
let packed_message = message.pack_new();
assert_eq!(packed_message.len(), message.packed_len());
assert_eq!(message, Packable::unpack
```
<Overlap Ratio: 0.7836990595611285>

---

--- 382 --
Question ID: 7382dcf7370d2f4b38588e9c78fdbf8dae7467b3_3
Original Code:
```
fn transfer_multi() {
    let mut token = Oep5TokenInstance;
    let owner = Address::zero();
    build_runtime().witness(&[owner]);
    assert_eq!(token.initialize(&owner), true);
    let alice = Address::repeat_byte(1);
    let bob = Address::repeat_byte(2);
    let token_id_1 = token.query_token_id_by_index(U128::new(1));
    let token_id_2 = token.query_token_id_by_index(U128::new(2));
    assert_eq!(token.owner_of(token_id_1.clone()), owner);
    assert_eq!(token.owner_of(token_id_2.clone()), owner);
    let states = [(alice.clone(), token_id_1.clone()), (bob.clone(), token_id_2.clone())];
    assert_eq!(token.transfer_multi(&states), true);
    assert_eq!(token.owner_of(token_id_1.clone()), alice);
    assert_eq!(token.owner_of(token_id_2.clone()), bob);
}
```


Overlapping Code:
```
ut token = Oep5TokenInstance;
let owner = Address::zero();
build_runtime().witness(&[owner]);
assert_eq!(token.initialize(&owner), true);
let alice = Address::repeat_byte(1);
let bob = Address::repeat_byte(2);
let token_id_1 = token.query_token_id_by_index(U128::new(1));
let token_id_2 = token.query_token_id_by_index(U128::new(2));
assert_eq!(token.owner_of(token_id_1.clone()), owner);
assert_eq!(token.owner_of(token_id_2.clone()), owner);
let states = [(alice.clone(), token_id_1.clone()), (bob.clone(), token_id_2.clone())];
assert_eq!(token.transfer_multi(&states), true);
assert_eq!(token.owner_of(token_id_1.clone()), alice);
assert_eq!(token.owne
```
<Overlap Ratio: 0.9162011173184358>

---

--- 383 --
Question ID: 6cd867972cf90c801674188782b1405551f0c319_25
Original Code:
```
fn vector_bitand_int_broadcast() {
        let a = vector![1, 2, 3, 4, 5];
        let b = 2;

        let exp = vector![1 & 2, 2 & 2, 3 & 2, 4 & 2, 5 & 2];

        // Allocating new memory
        let c = &a & &b;
        assert_eq!(c, exp);

        // Allocating new memory
        let c = &a & b;
        assert_eq!(c, exp);

        // Reusing memory
        let c = a.clone() & &b;
        assert_eq!(c, exp);

        // Reusing memory
        let c = a & b;
        assert_eq!(c, exp);
    }
```


Overlapping Code:
```
ector_bitand_int_broadcast() {
let a = vector![1, 2, 3, 4, 5];
let b = 2;
let exp = vector![1 & 2, 2 & 2, 3 & 2, 4 & 2, 5 & 2];
// Allocating new memory
let c = &a & &b;
assert_eq!(c, exp);
// Allocating new memory
let c = &a & b;
assert_eq!(c, exp);
// Reusing memory
let c = a.clone() & &b;
assert_eq!(c, exp);
// Reusing memory
let c = a & b;
assert_eq!(c, exp)
```
<Overlap Ratio: 0.9811320754716981>

---

