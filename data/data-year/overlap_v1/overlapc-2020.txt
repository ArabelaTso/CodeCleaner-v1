--- 0 --
Question ID: 962df4ff500ca40ef6efeeca4166c9dcad999718_97
Original Code:
```
int
fop_vnevent(vnode_t *vp, vnevent_t vnevent, vnode_t *dvp, char *fnm,
    caller_context_t *ct)
{
	int	err;

	err = (*(vp)->v_op->vop_vnevent)(vp, vnevent, dvp, fnm, ct);
	VOPSTATS_UPDATE(vp, vnevent);
	return (err);
}
```


Overlapping Code:
```
t *vp, vnevent_t vnevent, vnode_t *dvp, char *fnm,
caller_context_t *ct)
{
int err;
err = (*(vp)->v_op->vop_vnevent)(vp, vnevent, dvp, fnm, ct);
VOPSTATS_UPDATE(vp, vnevent)
```
<Overlap Ratio: 0.8160377358490566>

---

--- 1 --
Question ID: 3e9531dd0000363a9c5796243a30a1ed9a5f3bef_7
Original Code:
```
static ssize_t adis16240_write_16bit(struct device *dev,
		struct device_attribute *attr,
		const char *buf,
		size_t len)
{
	struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
	int ret;
	long val;

	ret = strict_strtol(buf, 10, &val);
	if (ret)
		goto error_ret;
	ret = adis16240_spi_write_reg_16(dev, this_attr->address, val);

error_ret:
	return ret ? ret : len;
}
```


Overlapping Code:
```
e_t adis16240_write_16bit(struct device *dev,
struct device_attribute *attr,
const char *buf,
size_t len)
{
struct iio_dev_attr *this_attr = to_iio_dev_attr(attr);
int ret;
long val;
ret = strict_strtol(buf, 10, &val);
if (ret)
goto error_ret;
ret = adis16240_spi_write_reg_16(dev, this_attr->address, val);
error_ret:
return ret ? ret : len;
```
<Overlap Ratio: 0.9633802816901409>

---

--- 2 --
Question ID: 7058bd0b35192cb210685de9ec3f10c1758108f8_0
Original Code:
```
static double solve2(int N, vector<int> A) {
        int K = int(A.size());
        if (N > K)
            return 0.0;

        sort(A.begin(), A.end(), greater<int>());
        if (N == K)
            return A.back();

        long long left = accumulate(A.begin() + N, A.end(), 0ll);
        A.resize(N);

        int cnt = 1;
        while (A.size() > 1) {
            long long gap = 1ll * (A[A.size() - 2] - A.back()) * cnt;
            if (left <= gap)
                break;

            left -= gap;
            A.pop_back();
            cnt++;
        }

        return A.back() + (1.0 * left / cnt);
    }
```


Overlapping Code:
```
e solve2(int N, vector<int> A) {
int K = int(A.size());
if (N > K)
return 0.0;
sort(A.begin(), A.end(), greater<int>());
if (N == K)
return A.back();
long long left = accumulate(A.begin() + N, A.end(), 0ll);
A.resize(N);
int cnt = 1;
while (A.size() > 1) {
long long gap = 1ll * (A[A.size() - 2] - A.back()) * cnt;
if (left <= gap)
break;
left -= gap;
A.pop_back();
cnt++;
}
return A.back() + (1.0 * 
```
<Overlap Ratio: 0.9389671361502347>

---

--- 3 --
Question ID: 93eca487086214dd83c0ca0a98aa47b421a9470e_17
Original Code:
```
void
init_desctbls(void)
{
	uint_t vec;
	user_desc_t *gdt;

	/*
	 * Setup and install our GDT.
	 */
	gdt = init_gdt();

	/*
	 * Store static pa of gdt to speed up pa_to_ma() translations
	 * on lwp context switches.
	 */
	ASSERT(IS_P2ALIGNED((uintptr_t)gdt, PAGESIZE));
	CPU->cpu_gdt = gdt;
	CPU->cpu_m.mcpu_gdtpa = pfn_to_pa(va_to_pfn(gdt));

	/*
	 * Setup and install our IDT.
	 */
#if !defined(__lint)
	ASSERT(NIDT * sizeof (*idt0) <= PAGESIZE);
#endif
	idt0 = (gate_desc_t *)BOP_ALLOC(bootops, (caddr_t)IDT_VA,
	    PAGESIZE, PAGESIZE);
	bzero(idt0, PAGESIZE);
	init_idt(idt0);
	for (vec = 0; vec < NIDT; vec++)
		xen_idt_write(&idt0[vec], vec);

	CPU->cpu_idt = idt0;

	/*
	 * set default kernel stack
	 */
	xen_stack_switch(KDS_SEL,
	    (ulong_t)&dblfault_stack0[sizeof (dblfault_stack0)]);

	xen_init_callbacks();

	init_ldt();
}
```


Overlapping Code:
```
ser_desc_t *gdt;
/*
* Setup and install our GDT.
*/
gdt = init_gdt();
/*
* Store static pa of gdt to speed up pa_to_ma() translations
* on lwp context switches.
*/
ASSERT(IS_P2ALIGNED((uintptr_t)gdt, PAGESIZE));
CPU->cpu_gdt = gdt;
CPU->cpu_m.mcpu_gdtpa = pfn_to_pa(va_to_pfn(gdt));
/*
* Setup and install our IDT.
*/
#if !defined(__lint)
ASSERT(NIDT * sizeof (*idt0) <= PAGESIZE);
#endif
idt0 = (gate_desc_t *)BOP_ALLOC(bootops, (caddr_t)IDT_VA,
PAGESIZE, PAGESIZE);
bzero(idt0, PAGESIZE);
init_idt(idt0);
for (vec = 0; vec < NIDT; vec++)
xen_idt_write(&idt0[vec], vec);
CPU->cpu_idt = idt0;
/*
* set default kernel stack
*/
xen_stack_switch(KDS_SEL,
(ulong_t)&dblfault_stack0[sizeof (dblfault_stack0
```
<Overlap Ratio: 0.8975672215108835>

---

--- 4 --
Question ID: 94cf9dce0ea01623b6073c99f547d80e37133037_4
Original Code:
```
void ssao_destroy(struct ssao* s)
{
    free(s->kernel);
    glDeleteTextures(1, &s->gl.noise_tex);
    glDeleteTextures(1, &s->gl.ao_ctex);
    glDeleteTextures(1, &s->gl.blur_ctex);
    glDeleteFramebuffers(1, &s->gl.ao_fbo);
    glDeleteFramebuffers(1, &s->gl.blur_fbo);
}
```


Overlapping Code:
```
oy(struct ssao* s)
{
free(s->kernel);
glDeleteTextures(1, &s->gl.noise_tex);
glDeleteTextures(1, &s->gl.ao_ctex);
glDeleteTextures(1, &s->gl.blur_ctex);
glDeleteFramebuffers(1, &s->gl.ao_fbo);
glDelet
```
<Overlap Ratio: 0.796812749003984>

---

--- 5 --
Question ID: d2a36491f9ae91204426ba39fdcec2b107c6ebe7_21
Original Code:
```
s32 act_grabbed(struct MarioState *m) {
    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {
        s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;

        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
#ifdef VERSION_SH
        queue_rumble_data(5, 60);
#endif

        return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,
                                thrown);
    }

    set_mario_animation(m, MARIO_ANIM_BEING_GRABBED);
    return FALSE;
}
```


Overlapping Code:
```
truct MarioState *m) {
if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {
s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;
m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
#ifdef VERSION_SH
queue_rumble_data(5, 60);
#endif
return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,
thrown);
}
set_mario_animation(m, MARIO_ANIM_BEING_GRABBED);
return FAL
```
<Overlap Ratio: 0.9551020408163265>

---

--- 6 --
Question ID: 8de761e9ead6f595f0feaa03296d29b47fda5a0b_14
Original Code:
```
flea_err_e THR_flea_mpi_t__add_in_place_ignore_sign(
  flea_mpi_t*       p_in_out,
  const flea_mpi_t* p_b
)
{
  flea_uword_t carry = 0;
  flea_mpi_ulen_t i;

  FLEA_THR_BEG_FUNC();
  if(p_in_out->m_nb_alloc_words < p_b->m_nb_used_words)
  {
    FLEA_THROW("error: addition result mpi too small to hold result value", FLEA_ERR_BUFF_TOO_SMALL);
  }
  // prepare result for expansion
  memset(
    &p_in_out->m_words[p_in_out->m_nb_used_words],
    0,
    sizeof(p_in_out->m_words[0]) * (p_in_out->m_nb_alloc_words - p_in_out->m_nb_used_words)
  );
  // from here on we can process the words of b
  for(i = 0; i < p_b->m_nb_used_words; i++)
  {
    flea_dbl_uword_t carry_res;
    carry_res = ((flea_dbl_uword_t) p_in_out->m_words[i]) + p_b->m_words[i] + carry;

    p_in_out->m_words[i] = ((flea_uword_t) carry_res);

    carry = carry_res >> (sizeof(flea_uword_t) * 8);
  }
  // handle remaining borrow (because a is not smaller than b, there must be
  // another word in a if there is a borrow pending after processing the highest word of b)
  while(carry) // maximally two iterations
  {
    flea_uword_t orig_word = 0;
    flea_dbl_uword_t carry_res;
    if(i >= p_in_out->m_nb_used_words)
    {
      if(i >= p_in_out->m_nb_alloc_words)
      {
        FLEA_THROW("addition result too large", FLEA_ERR_BUFF_TOO_SMALL);
      }
    }
    else
    {
      orig_word = p_in_out->m_words[i];
    }
    carry_res = ((flea_dbl_uword_t) orig_word) + carry;
    p_in_out->m_words[i] = ((flea_uword_t) carry_res);

    carry = carry_res >> (sizeof(flea_uword_t) * 8);
    i++;
  }
  flea_mpi_t__set_used_words(p_in_out);
  FLEA_THR_FIN_SEC();
}
```


Overlapping Code:
```
lea_err_e THR_flea_mpi_t__add_in_place_ignore_sign(
flea_mpi_t* p_in_out,
const flea_mpi_t* p_b
)
{
flea_uword_t carry = 0;
flea_mpi_ulen_t i;
FLEA_THR_BEG_FUNC();
if(p_in_out->m_nb_alloc_words < p_b->m_nb_used_words)
{
FLEA_THROW("error: addition result mpi too small to hold result value", FLEA_ERR_BUFF_TOO_SMALL);
}
// prepare result for expansion
memset(
&p_in_out->m_words[p_in_out->m_nb_used_words],
0,
sizeof(p_in_out->m_words[0]) * (p_in_out->m_nb_alloc_words - p_in_out->m_nb_used_words)
);
// from here on we can process the words of b
for(i = 0; i < p_b->m_nb_used_words; i++)
{
flea_dbl_uword_t carry_res;
carry_res = ((flea_dbl_uword_t) p_in_out->m_words[i]) + p_b->m_words[i] + carry;
p_in_out->m_words[i] = ((flea_uword_t) carry_res);
carry = carry_res >> (sizeof(flea_uword_t) * 8);
}
// handle remaining borrow (because a is not smaller than b, there must be
// another word in a if there is a borrow pending after processing the highest word of b)
while(carry) // maximally two iterations
{
flea_uword_t orig_word = 0;
flea_dbl_uword_t carry_res;
if(i >= p_in_out->m_nb_used_words)
{
if(i >= p_in_out->m_nb_alloc_words)
{
FLEA_THROW("addition result too large", FLEA_ERR_BUFF_TOO_SMALL);
}
}
else
{
orig_word = p_in_out->m_words[i];
}
carry_res = ((flea_dbl_uword_t) orig_word) + carry;
p_in_out->m_words[i] = ((flea_uword_t) carry_res);
carry = carry_res >> (sizeof(flea_uword_t) * 8);
i++;
}
flea_mpi_t__set_used_words(p_in
```
<Overlap Ratio: 0.9803122878479293>

---

--- 7 --
Question ID: d275bb1820f321ce82600cecbc807ceee3495fcc_13
Original Code:
```
static inline unsigned __hip_ds_swizzle_N(unsigned int src) {
    union { int i; unsigned u; float f; } tmp; tmp.u = src;
#if defined(__HCC__)
    tmp.i = __llvm_amdgcn_ds_swizzle(tmp.i, pattern);
#else
    tmp.i = __builtin_amdgcn_ds_swizzle(tmp.i, pattern);
#endif
    return tmp.u;
}
```


Overlapping Code:
```
 __hip_ds_swizzle_N(unsigned int src) {
union { int i; unsigned u; float f; } tmp; tmp.u = src;
#if defined(__HCC__)
tmp.i = __llvm_amdgcn_ds_swizzle(tmp.i, pattern);
#else
tmp.i = __builtin_amdgcn_ds_swizzle(tmp.i, patter
```
<Overlap Ratio: 0.8222222222222222>

---

--- 8 --
Question ID: c8677bd81988b79068dd778f289b0cc50f8402cf_5
Original Code:
```
static inline int
fetch16 (unw_addr_space_t as, unw_accessors_t *a,
	 unw_word_t *addr, int16_t *valp, void *arg)
{
  unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;
  int ret;

  assert ((off & 0x1) == 0);

  *addr += 2;

  ret = (*a->access_mem) (as, aligned_addr, &val, 0, arg);

#if __BYTE_ORDER == __LITTLE_ENDIAN
  val >>= 8*off;
#else
  val >>= 8*(WSIZE - 2 - off);
#endif
  *valp = val & 0xffff;
  return ret;
}
```


Overlapping Code:
```
tch16 (unw_addr_space_t as, unw_accessors_t *a,
unw_word_t *addr, int16_t *valp, void *arg)
{
unw_word_t val, aligned_addr = *addr & -WSIZE, off = *addr - aligned_addr;
int ret;
assert ((off & 0x1) == 0);
*addr += 2;
ret = (*a->access_mem) (as, aligned_addr, &val, 0, arg);
#if __BYTE_ORDER == __LITTLE_ENDIAN
val >>= 8*off;
#else
val >>= 8*(WSIZE - 2 - off);
#endif
*valp = val & 0xffff;
return ret;
```
<Overlap Ratio: 0.9478672985781991>

---

--- 9 --
Question ID: 9060ba0a7fa88a0a4dbb338ca3e46c7b404d3550_270
Original Code:
```
static void a_1434(int a_F1){ /* listfillblock+>a */
int a_L2;int a_L3;int a_L4;int a_P[2];
if(!a_1431()){ goto a_G3;}
a_1423(a_F1);return;
a_G3:a_L4=0;a_L3=0;
a_1012(2106125219);
a_G5:if(a_1417(1454739076)){ goto a_G5;}
if(!a_1430(a_P)){ goto a_G9;}a_L2=a_P[0];
a_1015(a_L2);
a_G8:__incr(a_L4); goto a_G5;
a_G9:if(!a_1262(a_P)){ goto a_G13;}a_L2=a_P[0];
a_1272(a_L2);
a_1017(a_L2); goto a_G8;
a_G13:if(!__equal(a_L4,0)){ goto a_G16;}
a_P[0]=2093833888;a_P[1]=a_F1;a_1108(2,a_P+0);
a_1269();return;
a_G16:if(!a_1417(1454739064)){ goto a_G21;}
if(!__equal(a_L3,0)){ goto a_G20;}
a_L3=1;
a_1012(2106125250); goto a_G5;
a_G20:a_P[0]=2093833841;a_P[1]=a_F1;a_1108(2,a_P+0); goto a_G5;
a_G21:a_1264(1454739070);
a_1012(2106125139);return;
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 10 --
Question ID: 2cf794aac94e0405a850f99d2521e0f233d4cde6_8
Original Code:
```
METHODDEF(void)
finish_pass_master (j_compress_ptr cinfo)
{
  my_master_ptr master = (my_master_ptr) cinfo->master;

  /* The entropy coder always needs an end-of-pass call,
   * either to analyze statistics or to flush its output buffer.
   */
  (*cinfo->entropy->finish_pass) (cinfo);

  /* Update state for next pass */
  switch (master->pass_type) {
  case main_pass:
    /* next pass is either output of scan 0 (after optimization)
     * or output of scan 1 (if no optimization).
     */
    master->pass_type = output_pass;
    if (! cinfo->optimize_coding)
      master->scan_number++;
    break;
  case huff_opt_pass:
    /* next pass is always output of current scan */
    master->pass_type = output_pass;
    break;
  case output_pass:
    /* next pass is either optimization or output of next scan */
    if (cinfo->optimize_coding)
      master->pass_type = huff_opt_pass;
    master->scan_number++;
    break;
  }

  master->pass_number++;
}
```


Overlapping Code:
```
aster (j_compress_ptr cinfo)
{
my_master_ptr master = (my_master_ptr) cinfo->master;
/* The entropy coder always needs an end-of-pass call,
* either to analyze statistics or to flush its output buffer.
*/
(*cinfo->entropy->finish_pass) (cinfo);
/* Update state for next pass */
switch (master->pass_type) {
case main_pass:
/* next pass is either output of scan 0 (after optimization)
* or output of scan 1 (if no optimization).
*/
master->pass_type = output_pass;
if (! cinfo->optimize_coding)
master->scan_number++;
break;
case huff_opt_pass:
/* next pass is always output of current scan */
master->pass_type = output_pass;
break;
case output_pass:
/* next pass is either optimization or output of next scan */
if (cinfo->optimize_coding)
master->pass_type = huff_opt_pass;
master->scan_number++;
break;
}
master->pass_nu
```
<Overlap Ratio: 0.9558652729384437>

---

--- 11 --
Question ID: bd6bd06fc15f7dde697aae351a85d1b6f29bb388_0
Original Code:
```
static void set_do_address(asn1_ctx_t* actx, gboolean do_address)
{
    p1_address_ctx_t* ctx;

    if (actx->subtree.tree_ctx == NULL) {
        actx->subtree.tree_ctx = wmem_new0(wmem_packet_scope(), p1_address_ctx_t);
    }

    ctx = (p1_address_ctx_t*)actx->subtree.tree_ctx;
    ctx->do_address = do_address;
}
```


Overlapping Code:
```
sn1_ctx_t* actx, gboolean do_address)
{
p1_address_ctx_t* ctx;
if (actx->subtree.tree_ctx == NULL) {
actx->subtree.tree_ctx = wmem_new0(wmem_packet_scope(), p1_address_ctx_t);
}
ctx = (p1_address_ctx_t*)actx->subtree.tree_ctx;
ctx->do_address = do_ad
```
<Overlap Ratio: 0.8741258741258742>

---

--- 12 --
Question ID: bd366ecb746b7221cae82928009f6943dcc88831_0
Original Code:
```
class d912pxy_thread_lock
{
public:
	d912pxy_thread_lock();	
	~d912pxy_thread_lock();
	
	UINT32 TryHold();
	void Hold();
	void Release();
	void Init();

	LONG LockedAdd(LONG val);
	void LockedSet(LONG val);

	void WaitHold(LONG cond);
	void HoldWait(LONG cond);

	LONG SpinOnce(LONG cond);

	LONG Add(LONG val);
	void Wait(LONG cond);
	UINT WaitTimeout(LONG cond, DWORD ms);	

	LONG GetValue();
	void SetValue(LONG val);
	void SetValueAsync(LONG val);

	void ResetLock();
	
private:	
	CRITICAL_SECTION cs;
	LONG spinLock;

}
```


Overlapping Code:
```
d_lock(); 
~d912pxy_thread_lock();

UINT32 TryHold();
void Hold();
void Release();
void Init();
LONG LockedAdd(LONG val);
void LockedSet(LONG val);
void WaitHold(LONG cond);
void HoldWait(LONG cond);
LONG SpinOnce(LONG cond);
LONG Add(LONG val);
void Wait(LONG cond);
UINT WaitTimeout(LONG cond, DWORD ms); 
LONG GetValue();
void SetValue(LONG val);
void SetValueAsync(LONG val);
void ResetLock();

p
```
<Overlap Ratio: 0.8080808080808081>

---

--- 13 --
Question ID: 2cd2fee8976fb9835e8b4ea5a9b0abe540c66ba7_1
Original Code:
```
static void pm_io_space_update(PIIX4PMState *s)
{
    PCIDevice *d = PCI_DEVICE(s);

    s->io_base = le32_to_cpu(*(uint32_t *)(d->config + 0x40));
    s->io_base &= 0xffc0;

    memory_region_transaction_begin();
    memory_region_set_enabled(&s->io, d->config[0x80] & 1);
    memory_region_set_address(&s->io, s->io_base);
    memory_region_transaction_commit();
}
```


Overlapping Code:
```
static void pm_io_space_update(PIIX4PMState *s)
{
PCIDevice *d = PCI_DEVICE(s);
s->io_base = le32_to_cpu(*(uint32_t *)(d->config + 0x40));
s->io_base &= 0xffc0;
memory_region_transaction_begin();
memory_region_set_enabled(&s->io, d->config[0x80] & 1);
memory_region_set_address(&s->io, s->io_base);
memo
```
<Overlap Ratio: 0.9017857142857143>

---

--- 14 --
Question ID: 1daad5eb4bc8b24d2cf0187f3b1aa1d653cb9e92_3
Original Code:
```
void  USBD_MSC_OS_CommSignalPend (CPU_INT08U   class_nbr,
                                  CPU_INT32U   timeout,
                                  USBD_ERR    *p_err)
{
    OS_EVENT  *p_comm_sem;
    INT8U      os_err;
    INT32U     timeout_ticks;


    p_comm_sem    = USBD_MSC_OS_TaskSemTbl[class_nbr];
    timeout_ticks = ((((INT32U)timeout * OS_TICKS_PER_SEC) + 1000u - 1u) / 1000u);

    OSSemPend(p_comm_sem, timeout_ticks, &os_err);

    switch (os_err) {
        case OS_ERR_NONE:
            *p_err = USBD_ERR_NONE;
             break;

        case OS_ERR_TIMEOUT:
            *p_err = USBD_ERR_OS_TIMEOUT;
             break;

        case OS_ERR_PEND_ABORT:
            *p_err = USBD_ERR_OS_ABORT;
             break;

        case OS_ERR_EVENT_TYPE:
        case OS_ERR_PEND_ISR:
        case OS_ERR_PEVENT_NULL:
        case OS_ERR_PEND_LOCKED:
        default:
            *p_err = USBD_ERR_OS_FAIL;
             break;
    }
}
```


Overlapping Code:
```
gnalPend (CPU_INT08U class_nbr,
CPU_INT32U timeout,
USBD_ERR *p_err)
{
OS_EVENT *p_comm_sem;
INT8U os_err;
INT32U timeout_ticks;
p_comm_sem = USBD_MSC_OS_TaskSemTbl[class_nbr];
timeout_ticks = ((((INT32U)timeout * OS_TICKS_PER_SEC) + 1000u - 1u) / 1000u);
OSSemPend(p_comm_sem, timeout_ticks, &os_err);
switch (os_err) {
case OS_ERR_NONE:
*p_err = USBD_ERR_NONE;
break;
case OS_ERR_TIMEOUT:
*p_err = USBD_ERR_OS_TIMEOUT;
break;
case OS_ERR_PEND_ABORT:
*p_err = USBD_ERR_OS_ABORT;
break;
case OS_ERR_EVENT_TYPE:
case OS_ERR_PEND_ISR:
case OS_ERR_PEVENT_NULL:
case OS_ERR_PEND_LOCKED:
default:
*p_err = USBD_ERR_OS_FAIL;
break;
}
```
<Overlap Ratio: 0.9616564417177914>

---

--- 15 --
Question ID: 838aa96404ee8ca4b013669ee0f18675ad610edb_22
Original Code:
```
static int Draw_Mesh_shader_material(Mesh_t *mesh,const int texindex, struct Projector_s **projectors,const int numProjectors,  struct SkinObject_s *skinobj)
{
  // error check
  vidCheckError();
  LUX_DEBUGASSERT(mesh);

  _dset_default(mesh);
  _dset_shadermat_override_prep(texindex);
  _dset_shader_prep(mesh);
  _dset_lock(mesh);
  _dset_initmesh(mesh);

  _dset_multipass_start
    _dset_mat_pass_start();
    _dset_fog_start();
    Draw_Mesh_simple(mesh);

    _dset_mat_pass_end();
    _dset_fog_end();
  _dset_multipass_end;

  _dset_unlock();
  _dset_shader_end();
  _dset_resetmesh(mesh);

  vidCheckError();
  return l_DrawData.numPasses;
}
```


Overlapping Code:
```
c int Draw_Mesh_shader_material(Mesh_t *mesh,const int texindex, struct Projector_s **projectors,const int numProjectors, struct SkinObject_s *skinobj)
{
// error check
vidCheckError();
LUX_DEBUGASSERT(mesh);
_dset_default(mesh);
_dset_shadermat_override_prep(texindex);
_dset_shader_prep(mesh);
_dset_lock(mesh);
_dset_initmesh(mesh);
_dset_multipass_start
_dset_mat_pass_start();
_dset_fog_start();
Draw_Mesh_simple(mesh);
_dset_mat_pass_end();
_dset_fog_end();
_dset_multipass_end;
_dset_unlock();
_dset_shader_end();
_dset_resetmesh(mesh);
vidCheckError();
return l_DrawData.numPasses;
```
<Overlap Ratio: 0.988255033557047>

---

--- 16 --
Question ID: 0b4626439480805abbcb48521bc28c3f3f83af84_446
Original Code:
```
void GH_USB_set_RXCSRH_W_PERI_ISO(U8 data)
{
    m_usb_rxcsrh_w_peri.bitc.iso = data;
    *(volatile U8 *)REG_USB_RXCSRH_W_PERI = m_usb_rxcsrh_w_peri.all;
    #if GH_USB_ENABLE_DEBUG_PRINT
    GH_USB_DEBUG_PRINT_FUNCTION( "WRREG(0x%08x,0x%08x); \\\\ [GH_USB_set_RXCSRH_W_PERI_ISO] <-- 0x%08x\n",
                        REG_USB_RXCSRH_W_PERI,m_usb_rxcsrh_w_peri.all,m_usb_rxcsrh_w_peri.all);
    #endif
}
```


Overlapping Code:
```
t_RXCSRH_W_PERI_ISO(U8 data)
{
m_usb_rxcsrh_w_peri.bitc.iso = data;
*(volatile U8 *)REG_USB_RXCSRH_W_PERI = m_usb_rxcsrh_w_peri.all;
#if GH_USB_ENABLE_DEBUG_PRINT
GH_USB_DEBUG_PRINT_FUNCTION( "WRREG(0x%08x,0x%08x); \\\\ [GH_USB_set_RXCSRH_W_PERI_ISO] <-- 0x%08x\n",
REG_USB_RXCSRH_W_PERI,m_usb_rxcsrh_w_peri.all,m_usb_rxcsrh_w_peri.all);
#endif
}
```
<Overlap Ratio: 0.9611111111111111>

---

--- 17 --
Question ID: d18844dfed35e8806c7ae0fc0edb034dcb56d5e0_17
Original Code:
```
inline static  result_t CascadesRouterM$SubControl$init(void){
#line 63
  unsigned char result;
#line 63

#line 63
  result = CascadesEngineM$StdControl$init();
#line 63
  result = rcombine(result, NeighborMgmtM$StdControl$init());
#line 63

#line 63
  return result;
#line 63
}
```


Overlapping Code:
```
CascadesRouterM$SubControl$init(void){
#line 63
unsigned char result;
#line 63
#line 63
result = CascadesEngineM$StdControl$init();
#line 63
result = rcombine(result, NeighborMgmtM$StdControl$init());
#line 63
#line 63
return result;
#line 63
```
<Overlap Ratio: 0.9063670411985019>

---

--- 18 --
Question ID: e67d7935622bb4f056d840f586958924ebf9c56c_96
Original Code:
```
static enum ndr_err_code ndr_push_svcctl_EnumServicesStatusW(struct ndr_push *ndr, int flags, const struct svcctl_EnumServicesStatusW *r)
{
	if (flags & NDR_IN) {
		if (r->in.handle == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_policy_handle(ndr, NDR_SCALARS, r->in.handle));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.type));
		NDR_CHECK(ndr_push_svcctl_ServiceState(ndr, NDR_SCALARS, r->in.state));
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.offered));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->in.resume_handle));
		if (r->in.resume_handle) {
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->in.resume_handle));
		}
	}
	if (flags & NDR_OUT) {
		if (r->out.service == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.offered));
		NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.service, r->in.offered));
		if (r->out.needed == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.needed));
		if (r->out.services_returned == NULL) {
			return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
		}
		NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.services_returned));
		NDR_CHECK(ndr_push_unique_ptr(ndr, r->out.resume_handle));
		if (r->out.resume_handle) {
			NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.resume_handle));
		}
		NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->out.result));
	}
	return NDR_ERR_SUCCESS;
}
```


Overlapping Code:
```
tic enum ndr_err_code ndr_push_svcctl_EnumServicesStatusW(struct ndr_push *ndr, int flags, const struct svcctl_EnumServicesStatusW *r)
{
if (flags & NDR_IN) {
if (r->in.handle == NULL) {
return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
}
NDR_CHECK(ndr_push_policy_handle(ndr, NDR_SCALARS, r->in.handle));
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.type));
NDR_CHECK(ndr_push_svcctl_ServiceState(ndr, NDR_SCALARS, r->in.state));
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, r->in.offered));
NDR_CHECK(ndr_push_unique_ptr(ndr, r->in.resume_handle));
if (r->in.resume_handle) {
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->in.resume_handle));
}
}
if (flags & NDR_OUT) {
if (r->out.service == NULL) {
return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
}
NDR_CHECK(ndr_push_uint3264(ndr, NDR_SCALARS, r->in.offered));
NDR_CHECK(ndr_push_array_uint8(ndr, NDR_SCALARS, r->out.service, r->in.offered));
if (r->out.needed == NULL) {
return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
}
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.needed));
if (r->out.services_returned == NULL) {
return ndr_push_error(ndr, NDR_ERR_INVALID_POINTER, "NULL [ref] pointer");
}
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.services_returned));
NDR_CHECK(ndr_push_unique_ptr(ndr, r->out.resume_handle));
if (r->out.resume_handle) {
NDR_CHECK(ndr_push_uint32(ndr, NDR_SCALARS, *r->out.resume_handle));
}
NDR_CHECK(ndr_push_WERROR(ndr, NDR_SCALARS, r->out.result));
}
return NDR_ERR_SUCCESS;
}
```
<Overlap Ratio: 0.9980781550288277>

---

--- 19 --
Question ID: 9608218928255e3b098d7f7f0565f3c3fa4c236d_1
Original Code:
```
static int local_create_fifo(FAR const char *path)
{
	int ret;

	/* Create the client-to-server FIFO if it does not already exist. */

	if (!local_fifo_exists(path)) {
		ret = mkfifo(path, 0644);
		if (ret < 0) {
			int errcode = get_errno();
			DEBUGASSERT(errcode > 0);

			ndbg("ERROR: Failed to create FIFO %s: %d\n", path, errcode);
			return -errcode;
		}
	}

	/* The FIFO (or some character driver) exists at PATH or we successfully
	 * created the FIFO at that location.
	 */

	return OK;
}
```


Overlapping Code:
```
ar *path)
{
int ret;
/* Create the client-to-server FIFO if it does not already exist. */
if (!local_fifo_exists(path)) {
ret = mkfifo(path, 0644);
if (ret < 0) {
int errcode = get_errno();
DEBUGASSERT(errcode > 0);
ndbg("ERROR: Failed to create FIFO %s: %d\n", path, errcode);
return -errcode;
}
}
/* The FIFO (or some character driver) exists at PATH or we successfully
* created the FIFO at that l
```
<Overlap Ratio: 0.8602150537634409>

---

--- 20 --
Question ID: c895079831f0f0f7db91d740d9f42fea0831f39a_2
Original Code:
```
static inline int vote(voters_t *const restrict voters)
{
  const int k = voters->k;
  double *const restrict tally = voters->dists;
  int *const restrict votes = voters->labels;
  int group;
  
  memset(tally, 0, k*sizeof(*tally));
  SAFE_FOR_SIMD
  for (int i=0; i<k; i++)
    tally[votes[i]-1] += 1.0;
  
  group = 0;
  
  for (int i=1; i<k; i++)
  {
    if (tally[i] > tally[group])
      group = i;
  }
  
  return group+1;
}
```


Overlapping Code:
```
rict voters)
{
const int k = voters->k;
double *const restrict tally = voters->dists;
int *const restrict votes = voters->labels;
int group;

memset(tally, 0, k*sizeof(*tally));
SAFE_FOR_SIMD
for (int i=0; i<k; i++)
tally[votes[i]-1] += 1.0;

group = 0;

for (int i=1; i<k; i++)
{
if (tally[i] > tall
```
<Overlap Ratio: 0.78125>

---

--- 21 --
Question ID: f60ba63f7fda7db5e3a2a94ec2a87e7438c1dbe2_2
Original Code:
```
inline SxComplex8 SxVector3<Complex8>::minval () const
{
   SX_EXIT; // complex numbers do not have minval
   return SxComplex8 ();
}
```


Overlapping Code:
```
 SxComplex8 SxVector3<Complex8>::minval () const
{
SX_EXIT; // complex numbers do not have minval
return SxCo
```
<Overlap Ratio: 0.8582677165354331>

---

--- 22 --
Question ID: ae34556f143f414fb8417601975f8ab9c80edff6_14
Original Code:
```
void
pcache_grow_map(pollcache_t *pcp, int fd)
{
	int  	newsize;
	ulong_t	*newmap;

	/*
	 * grow to nearest multiple of POLLMAPCHUNK, assuming POLLMAPCHUNK is
	 * power of 2.
	 */
	newsize = (fd + POLLMAPCHUNK) & ~(POLLMAPCHUNK - 1);
	newmap = kmem_zalloc((newsize / BT_NBIPUL) * sizeof (ulong_t),
	    KM_SLEEP);
	/*
	 * don't want pollwakeup to set a bit while growing the bitmap.
	 */
	ASSERT(mutex_owned(&pcp->pc_lock) == 0);
	mutex_enter(&pcp->pc_lock);
	bcopy(pcp->pc_bitmap, newmap,
	    (pcp->pc_mapsize / BT_NBIPUL) * sizeof (ulong_t));
	kmem_free(pcp->pc_bitmap,
	    (pcp->pc_mapsize /BT_NBIPUL) * sizeof (ulong_t));
	pcp->pc_bitmap = newmap;
	pcp->pc_mapsize = newsize;
	mutex_exit(&pcp->pc_lock);
}
```


Overlapping Code:
```
row_map(pollcache_t *pcp, int fd)
{
int newsize;
ulong_t *newmap;
/*
* grow to nearest multiple of POLLMAPCHUNK, assuming POLLMAPCHUNK is
* power of 2.
*/
newsize = (fd + POLLMAPCHUNK) & ~(POLLMAPCHUNK - 1);
newmap = kmem_zalloc((newsize / BT_NBIPUL) * sizeof (ulong_t),
KM_SLEEP);
/*
* don't want pollwakeup to set a bit while growing the bitmap.
*/
ASSERT(mutex_owned(&pcp->pc_lock) == 0);
mutex_enter(&pcp->pc_lock);
bcopy(pcp->pc_bitmap, newmap,
(pcp->pc_mapsize / BT_NBIPUL) * sizeof (ulong_t));
kmem_free(pcp->pc_bitmap,
(pcp->pc_mapsize /BT_NBIPUL) * sizeof (ulong_t));
pcp->pc_bitmap = newmap;
pcp->pc_mapsize = newsize;
mutex_exit(&pcp->pc_l
```
<Overlap Ratio: 0.9701492537313433>

---

--- 23 --
Question ID: df32173c13834578c11e55c786e2bafa580afec2_12
Original Code:
```
int32_t
get_fid(uint32_t inode, uint8_t *buf, uint64_t off)
{
	struct file_id *fid;

	/* LINTED */
	fid = (struct file_id *)buf;
	if ((read_file(inode, buf, sizeof (struct file_id), off)) != 0) {
		return (1);
	}

	if (ud_verify_tag(udh, &fid->fid_tag, UD_FILE_ID_DESC, 0, 0, 1) != 0) {
		(void) fprintf(stdout,
			gettext("file_id tag does not verify off %llx\n"),
			off);
		return (1);
	}

	if ((read_file(inode, buf, FID_LEN(fid), off)) != 0) {
		return (1);
	}

	return (0);
}
```


Overlapping Code:
```
_t inode, uint8_t *buf, uint64_t off)
{
struct file_id *fid;
/* LINTED */
fid = (struct file_id *)buf;
if ((read_file(inode, buf, sizeof (struct file_id), off)) != 0) {
return (1);
}
if (ud_verify_tag(udh, &fid->fid_tag, UD_FILE_ID_DESC, 0, 0, 1) != 0) {
(void) fprintf(stdout,
gettext("file_id tag does not verify off %llx\n"),
off);
return (1);
}
if ((read_file(inode, buf, FID_LEN(fid), off)) != 0
```
<Overlap Ratio: 0.8830022075055187>

---

--- 24 --
Question ID: 1b76a6a0fab632e5453f879499d0bc1a0ce242fc_14
Original Code:
```
static void
free_box_tree(BoxNode *n)
{
   PixelList *p,*pp;
   if (n->l) free_box_tree(n->l);
   if (n->r) free_box_tree(n->r);
   for (p=n->head[0];p;p=pp) {
      pp=p->next[0];
      free(p);
   }
   free(n);
}
```


Overlapping Code:
```
ic void
free_box_tree(BoxNode *n)
{
PixelList *p,*pp;
if (n->l) free_box_tree(n->l);
if (n->r) free_box_tree(n->r);
for (p=n->head[0];p;p=pp) {
pp=p->
```
<Overlap Ratio: 0.8152173913043478>

---

--- 25 --
Question ID: 8d33e546fd74f67ede4aef6ff2dcb3a78a01fe26_6
Original Code:
```
static errcode_t free_gdp_blocks(ext2_filsys fs,
				 ext2fs_block_bitmap reserve_blocks,
				 ext2_filsys old_fs,
				 dgrp_t group)
{
	blk64_t	blk;
	int	j;
	dgrp_t	i;
	ext2fs_block_bitmap bg_map = NULL;
	errcode_t retval = 0;
	dgrp_t count = old_fs->group_desc_count - fs->group_desc_count;

	/* If bigalloc, don't free metadata living in the same cluster */
	if (EXT2FS_CLUSTER_RATIO(fs) > 1) {
		retval = ext2fs_allocate_block_bitmap(fs, "bgdata", &bg_map);
		if (retval)
			goto out;

		retval = mark_table_blocks(fs, bg_map);
		if (retval)
			goto out;
	}

	for (i = group; i < group + count; i++) {
		blk = ext2fs_block_bitmap_loc(old_fs, i);
		if (blk &&
		    (blk < ext2fs_blocks_count(fs->super)) &&
		    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {
			ext2fs_block_alloc_stats2(fs, blk, -1);
			ext2fs_mark_block_bitmap2(reserve_blocks, blk);
		}

		blk = ext2fs_inode_bitmap_loc(old_fs, i);
		if (blk &&
		    (blk < ext2fs_blocks_count(fs->super)) &&
		    !(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {
			ext2fs_block_alloc_stats2(fs, blk, -1);
			ext2fs_mark_block_bitmap2(reserve_blocks, blk);
		}

		blk = ext2fs_inode_table_loc(old_fs, i);
		for (j = 0;
		     j < fs->inode_blocks_per_group; j++, blk++) {
			if (blk >= ext2fs_blocks_count(fs->super) ||
			    (bg_map && ext2fs_test_block_bitmap2(bg_map, blk)))
				continue;
			ext2fs_block_alloc_stats2(fs, blk, -1);
			ext2fs_mark_block_bitmap2(reserve_blocks, blk);
		}
	}

out:
	if (bg_map)
		ext2fs_free_block_bitmap(bg_map);
	return retval;
}
```


Overlapping Code:
```
dp_blocks(ext2_filsys fs,
ext2fs_block_bitmap reserve_blocks,
ext2_filsys old_fs,
dgrp_t group)
{
blk64_t blk;
int j;
dgrp_t i;
ext2fs_block_bitmap bg_map = NULL;
errcode_t retval = 0;
dgrp_t count = old_fs->group_desc_count - fs->group_desc_count;
/* If bigalloc, don't free metadata living in the same cluster */
if (EXT2FS_CLUSTER_RATIO(fs) > 1) {
retval = ext2fs_allocate_block_bitmap(fs, "bgdata", &bg_map);
if (retval)
goto out;
retval = mark_table_blocks(fs, bg_map);
if (retval)
goto out;
}
for (i = group; i < group + count; i++) {
blk = ext2fs_block_bitmap_loc(old_fs, i);
if (blk &&
(blk < ext2fs_blocks_count(fs->super)) &&
!(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {
ext2fs_block_alloc_stats2(fs, blk, -1);
ext2fs_mark_block_bitmap2(reserve_blocks, blk);
}
blk = ext2fs_inode_bitmap_loc(old_fs, i);
if (blk &&
(blk < ext2fs_blocks_count(fs->super)) &&
!(bg_map && ext2fs_test_block_bitmap2(bg_map, blk))) {
ext2fs_block_alloc_stats2(fs, blk, -1);
ext2fs_mark_block_bitmap2(reserve_blocks, blk);
}
blk = ext2fs_inode_table_loc(old_fs, i);
for (j = 0;
j < fs->inode_blocks_per_group; j++, blk++) {
if (blk >= ext2fs_blocks_count(fs->super) ||
(bg_map && ext2fs_test_block_bitmap2(bg_map, blk)))
continue;
ext2fs_block_alloc_stats2(fs, blk, -1);
ext2fs_mark_block_bitmap2(reserve_blocks, blk);
}
}
out:
if (bg_map)
ext2fs_free_bl
```
<Overlap Ratio: 0.9581263307310149>

---

--- 26 --
Question ID: 74a7249955b4a4a18371fe01b7f6c42f33f16646_200
Original Code:
```
int func_365(int iParam0, var uParam1, bool bParam2, int iParam3, bool bParam4, bool bParam5)
{
	int iVar0;
	int iVar1;
	var uVar2;
	
	if (bParam2)
	{
		if (!bParam4)
		{
		}
		Global_2097152[func_191() /*10931*/].f_6175.f_1274 = unk_0x5A002C4821A13338();
	}
	if (!bParam4)
	{
	}
	iVar1 = func_383(1411, iParam0);
	func_17(iVar1, uParam1->f_137, iParam3, 1);
	if (!bParam4)
	{
	}
	iVar1 = func_383(1412, iParam0);
	func_17(iVar1, uParam1->f_138, iParam3, 1);
	if (!bParam4)
	{
	}
	if (func_382(iParam0))
	{
	}
	else
	{
		iVar1 = func_383(1413, iParam0);
		func_17(iVar1, *uParam1, iParam3, 1);
		iVar0 = 0;
		while (iVar0 < 49)
		{
			if (iVar0 < 25)
			{
				iVar1 = (func_383(1414, iParam0) + iVar0);
				func_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);
			}
			else
			{
				iVar1 = (func_381(iParam0) + (iVar0 - 25));
				func_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);
			}
			iVar0++;
		}
		iVar0 = 0;
		iVar0 = 0;
		while (iVar0 < 2)
		{
			iVar1 = (func_383(1439, iParam0) + iVar0);
			func_17(iVar1, uParam1->f_59[iVar0], iParam3, 1);
			iVar0++;
		}
	}
	iVar1 = func_383(1441, iParam0);
	func_17(iVar1, uParam1->f_62, iParam3, 1);
	iVar1 = func_383(1442, iParam0);
	func_17(iVar1, uParam1->f_63, iParam3, 1);
	iVar1 = func_383(1443, iParam0);
	func_17(iVar1, uParam1->f_64, iParam3, 1);
	if (func_382(iParam0))
	{
		if (!bParam4)
		{
		}
	}
	else
	{
		iVar1 = func_383(1444, iParam0);
		func_17(iVar1, uParam1->f_65, iParam3, 1);
	}
	iVar1 = func_383(1445, iParam0);
	func_17(iVar1, uParam1->f_67, iParam3, 1);
	if (func_382(iParam0))
	{
		if (!bParam4)
		{
		}
	}
	else
	{
		iVar1 = func_383(1446, iParam0);
		func_17(iVar1, uParam1->f_68, iParam3, 1);
	}
	iVar1 = func_383(1447, iParam0);
	func_17(iVar1, uParam1->f_69, iParam3, 1);
	iVar1 = func_383(1448, iParam0);
	func_17(iVar1, uParam1->f_70, -1, 1);
	iVar1 = func_383(1449, iParam0);
	func_17(iVar1, uParam1->f_71, iParam3, 1);
	iVar1 = func_383(1450, iParam0);
	func_17(iVar1, uParam1->f_72, iParam3, 1);
	iVar1 = func_383(1451, iParam0);
	func_17(iVar1, uParam1->f_73, iParam3, 1);
	iVar1 = func_383(1452, iParam0);
	func_17(iVar1, uParam1->f_5, iParam3, 1);
	iVar1 = func_383(1453, iParam0);
	func_17(iVar1, uParam1->f_6, iParam3, 1);
	iVar1 = func_383(1454, iParam0);
	func_17(iVar1, uParam1->f_7, iParam3, 1);
	iVar1 = func_383(1455, iParam0);
	func_17(iVar1, uParam1->f_8, iParam3, 1);
	if (func_382(iParam0))
	{
		if (!bParam4)
		{
		}
	}
	else
	{
		iVar1 = func_383(3880, iParam0);
		func_17(iVar1, uParam1->f_74, iParam3, 1);
		iVar1 = func_383(3881, iParam0);
		func_17(iVar1, uParam1->f_75, iParam3, 1);
		iVar1 = func_383(3882, iParam0);
		func_17(iVar1, uParam1->f_76, iParam3, 1);
		iVar1 = func_380(iParam0);
		func_17(iVar1, uParam1->f_97, iParam3, 1);
		iVar1 = func_379(iParam0);
		func_17(iVar1, uParam1->f_99, iParam3, 1);
		iVar1 = func_368(iParam0);
		func_17(iVar1, uParam1->f_98, iParam3, 1);
	}
	uVar2 = Global_2097152[func_191() /*10931*/].f_6175.f_1274;
	if (bParam5)
	{
		uVar2 = unk_0x5A002C4821A13338();
	}
	func_131(1628, uVar2, iParam3, 1, 0);
	if (!bParam4)
	{
	}
	func_131(func_367(1, iParam0), uParam1->f_102, iParam3, 1, 0);
	if (!bParam4)
	{
	}
	func_131(func_367(2, iParam0), uParam1->f_103, iParam3, 1, 0);
	if (!bParam4)
	{
	}
	func_131(func_367(3, iParam0), uParam1->f_104, iParam3, 1, 0);
	if (!bParam4)
	{
	}
	func_131(func_367(4, iParam0), uParam1->f_66, iParam3, 1, 0);
	func_131(func_367(5, iParam0), uParam1->f_77, iParam3, 1, 0);
	if (!bParam4)
	{
	}
	func_131(func_367(7, iParam0), uParam1->f_139, iParam3, 1, 0);
	if (!func_382(iParam0))
	{
		if (!unk_0x7BCC91F3C1CF24E8(&(uParam1->f_1)))
		{
			func_366(func_367(6, iParam0), &(uParam1->f_1), iParam3);
			if (!bParam4)
			{
			}
		}
		else if (!bParam4)
		{
		}
	}
	if (!bParam4)
	{
	}
	return 1;
}
```


Overlapping Code:
```
int func_365(int iParam0, var uParam1, bool bParam2, int iParam3, bool bParam4, bool bParam5)
{
int iVar0;
int iVar1;
var uVar2;

if (bParam2)
{
if (!bParam4)
{
}
Global_2097152[func_191() /*10931*/].f_6175.f_1274 = unk_0x5A002C4821A13338();
}
if (!bParam4)
{
}
iVar1 = func_383(1411, iParam0);
func_17(iVar1, uParam1->f_137, iParam3, 1);
if (!bParam4)
{
}
iVar1 = func_383(1412, iParam0);
func_17(iVar1, uParam1->f_138, iParam3, 1);
if (!bParam4)
{
}
if (func_382(iParam0))
{
}
else
{
iVar1 = func_383(1413, iParam0);
func_17(iVar1, *uParam1, iParam3, 1);
iVar0 = 0;
while (iVar0 < 49)
{
if (iVar0 < 25)
{
iVar1 = (func_383(1414, iParam0) + iVar0);
func_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);
}
else
{
iVar1 = (func_381(iParam0) + (iVar0 - 25));
func_17(iVar1, uParam1->f_9[iVar0], iParam3, 1);
}
iVar0++;
}
iVar0 = 0;
iVar0 = 0;
while (iVar0 < 2)
{
iVar1 = (func_383(1439, iParam0) + iVar0);
func_17(iVar1, uParam1->f_59[iVar0], iParam3, 1);
iVar0++;
}
}
iVar1 = func_383(1441, iParam0);
func_17(iVar1, uParam1->f_62, iParam3, 1);
iVar1 = func_383(1442, iParam0);
func_17(iVar1, uParam1->f_63, iParam3, 1);
iVar1 = func_383(1443, iParam0);
func_17(iVar1, uParam1->f_64, iParam3, 1);
if (func_382(iParam0))
{
if (!bParam4)
{
}
}
else
{
iVar1 = func_383(1444, iParam0);
func_17(iVar1, uParam1->f_65, iParam3, 1);
}
iVar1 = func_383(1445, iParam0);
func_17(iVar1, uParam1->f_67, iParam3, 1);
if (func_382(iParam0))
{
if (!bParam4)
{
}
}
else
{
iVar1 = func_383(1446, iParam0);
func_17(iVar1, uParam1->f_68, iParam3, 1);
}
iVar1 = func_383(1447, iParam0);
func_17(iVar1, uParam1->f_69, iParam3, 1);
iVar1 = func_383(1448, iParam0);
func_17(iVar1, uParam1->f_70, -1, 1);
iVar1 = func_383(1449, iParam0);
func_17(iVar1, uParam1->f_71, iParam3, 1);
iVar1 = func_383(1450, iParam0);
func_17(iVar1, uParam1->f_72, iParam3, 1);
iVar1 = func_383(1451, iParam0);
func_17(iVar1, uParam1->f_73, iParam3, 1);
iVar1 = func_383(1452, iParam0);
func_17(iVar1, uParam1->f_5, iParam3, 1);
iVar1 = func_383(1453, iParam0);
func_17(iVar1, uParam1->f_6, iParam3, 1);
iVar1 = func_383(1454, iParam0);
func_17(iVar1, uParam1->f_7, iParam3, 1);
iVar1 = func_383(1455, iParam0);
func_17(iVar1, uParam1->f_8, iParam3, 1);
if (func_382(iParam0))
{
if (!bParam4)
{
}
}
else
{
iVar1 = func_383(3880, iParam0);
func_17(iVar1,
```
<Overlap Ratio: 0.9896729776247849>

---

--- 27 --
Question ID: 96d8d2c833d9db6e7bb048dc46bc8b2c31642c25_17
Original Code:
```
static inline int cpq_get_attention_status (struct controller *ctrl, struct slot *slot)
{
	u8 hp_slot;

	if (slot == NULL)
		return 1;

	hp_slot = slot->device - ctrl->slot_device_offset;

	return read_amber_LED (ctrl, hp_slot);
}
```


Overlapping Code:
```
tatic inline int cpq_get_attention_status (struct controller *ctrl, struct slot *slot)
{
u8 hp_slot;
if (slot == NULL)
return 1;
hp_slot = slot->device - ctrl->slot_device_offset;
return read_amber_LE
```
<Overlap Ratio: 0.9049773755656109>

---

--- 28 --
Question ID: 1ff9e892e20084d18321c9a9831ecb335b9a5a07_1
Original Code:
```
static void VS_CC
write_planar(img_hnd_t *ih, int n, VSFrameRef **dst, VSCore *core,
             const VSAPI *vsapi)
{
    uint8_t *srcp = ih->image_buff;

    for (int i = 0, num = ih->src[n].format->numPlanes; i < num; i++) {
        int row_size = vsapi->getFrameWidth(dst[0], i) *
                       ih->src[n].format->bytesPerSample;
        row_size = (row_size + ih->row_adjust) & (~ih->row_adjust);
        int height = vsapi->getFrameHeight(dst[0], i);
        bit_blt(dst[0], i, vsapi, srcp, row_size, height);
        srcp += row_size * height;
    }
    
    if (ih->enable_alpha) {
        set_dummy_alpha(ih, n, dst[1], core, vsapi);
    }
}
```


Overlapping Code:
```
img_hnd_t *ih, int n, VSFrameRef **dst, VSCore *core,
const VSAPI *vsapi)
{
uint8_t *srcp = ih->image_buff;
for (int i = 0, num = ih->src[n].format->numPlanes; i < num; i++) {
int row_size = vsapi->getFrameWidth(dst[0], i) *
ih->src[n].format->bytesPerSample;
row_size = (row_size + ih->row_adjust) & (~ih->row_adjust);
int height = vsapi->getFrameHeight(dst[0], i);
bit_blt(dst[0], i, vsapi, srcp, row_size, height);
srcp += row_size * height;
}

if (ih->enable_alpha) {
set_dummy_alpha(ih, n, dst[1], core, vs
```
<Overlap Ratio: 0.9274047186932849>

---

--- 29 --
Question ID: 5dfd0f3b2942556e9f29eedfb3cfee75037da1f9_6
Original Code:
```
BOOL
CpuInfoDisplayGroups(
    __in PCPUINFO_CONTEXT CpuInfoContext
    )
{
    PYORI_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Entry;
    DWORD CurrentOffset = 0;
    WORD GroupIndex;

    Entry = CpuInfoContext->ProcInfo;

    while (Entry != NULL) {

        if (Entry->Relationship == YoriProcessorRelationGroup) {
            for (GroupIndex = 0; GroupIndex < Entry->u.Group.MaximumGroupCount; GroupIndex++) {
                YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T("Group %i\n"), GroupIndex);
                CpuInfoDisplayProcessorMask(GroupIndex, Entry->u.Group.GroupInfo[GroupIndex].ActiveProcessorMask);

            }
            YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T("\n"));
        }

        CurrentOffset += Entry->SizeInBytes;
        if (CurrentOffset >= CpuInfoContext->BytesInBuffer) {
            break;
        }
        Entry = YoriLibAddToPointer(CpuInfoContext->ProcInfo, CurrentOffset);
    }

    return TRUE;
}
```


Overlapping Code:
```
OOL
CpuInfoDisplayGroups(
__in PCPUINFO_CONTEXT CpuInfoContext
)
{
PYORI_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Entry;
DWORD CurrentOffset = 0;
WORD GroupIndex;
Entry = CpuInfoContext->ProcInfo;
while (Entry != NULL) {
if (Entry->Relationship == YoriProcessorRelationGroup) {
for (GroupIndex = 0; GroupIndex < Entry->u.Group.MaximumGroupCount; GroupIndex++) {
YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T("Group %i\n"), GroupIndex);
CpuInfoDisplayProcessorMask(GroupIndex, Entry->u.Group.GroupInfo[GroupIndex].ActiveProcessorMask);
}
YoriLibOutput(YORI_LIB_OUTPUT_STDOUT, _T("\n"));
}
CurrentOffset += Entry->SizeInBytes;
if (CurrentOffset >= CpuInfoContext->BytesInBuffer) {
break;
}
Entry = YoriLibAddToPointer(CpuInfoContext->ProcInfo, CurrentOffset);
}
return
```
<Overlap Ratio: 0.988296488946684>

---

--- 30 --
Question ID: 999a69941b5a759a6074fbc8f7474eee4f955074_3
Original Code:
```
void push_next_indice(
    Encoder_State *st,           /* i/o: encoder state structure */
    unsigned short value,        /* i  : value of the quantized indice */
    short nb_bits       /* i  : number of bits used to quantize the indice */
)
{

    /* store the values in the list */
    st->ind_list[st->next_ind].value   = value;
    st->ind_list[st->next_ind].nb_bits = nb_bits;
    st->next_ind++;

    /* update the total number of bits already written */
    st->nb_bits_tot += nb_bits;

    return;
}
```


Overlapping Code:
```
ush_next_indice(
Encoder_State *st, /* i/o: encoder state structure */
unsigned short value, /* i : value of the quantized indice */
short nb_bits /* i : number of bits used to quantize the indice */
)
{
/* store the values in the list */
st->ind_list[st->next_ind].value = value;
st->ind_list[st->next_ind].nb_bits = nb_bits;
st->next_ind++;
/* update the total number of bits already written */
st->nb_bits_tot +
```
<Overlap Ratio: 0.9409090909090909>

---

--- 31 --
Question ID: eacf553d68478d3e8b35d7593967e89071755c3e_0
Original Code:
```
int main()
{
    int arr[3][4] = {{1, 2, 3, 4}, {2, 4, 6, 8}, {1, 3, 5, 7}};

    int *brr[3];

    int **crr;

    printf("Printing 2D Array From Stack\n");

    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 4; j++)
        {
            printf("%d ", arr[i][j]);
        }

        printf("\n");
    }

    printf("\n");

    brr[0] = (int *) malloc(4 * sizeof(int));

    brr[1] = (int *) malloc(4 * sizeof(int));

    brr[2] = (int *) malloc(4 * sizeof(int));

    printf("Printing 2D Array From Heap Using Single Pointer\n");

    int brrCounter = 0;

    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 4; j++)
        {
            brr[i][j] = ++brrCounter;

            printf("%d ", brr[i][j]);
        }

        printf("\n");
    }

    printf("\n");

    crr = (int **) malloc(3 * sizeof(int *));

    crr[0] = (int *) malloc(4 * sizeof(int));

    crr[1] = (int *) malloc(4 * sizeof(int));

    crr[2] = (int *) malloc(4 * sizeof(int));

    printf("Printing 2D Array From Heap Using Double Pointer\n");

    int crrCounter = 0;

    for(int i = 0; i < 3; i++)
    {
        for(int j = 0; j < 4; j++)
        {
            crr[i][j] = ++crrCounter;

            printf("%d ", crr[i][j]);
        }

        printf("\n");
    }

    return 0;
}
```


Overlapping Code:
```
[3][4] = {{1, 2, 3, 4}, {2, 4, 6, 8}, {1, 3, 5, 7}};
int *brr[3];
int **crr;
printf("Printing 2D Array From Stack\n");
for(int i = 0; i < 3; i++)
{
for(int j = 0; j < 4; j++)
{
printf("%d ", arr[i][j]);
}
printf("\n");
}
printf("\n");
brr[0] = (int *) malloc(4 * sizeof(int));
brr[1] = (int *) malloc(4 * sizeof(int));
brr[2] = (int *) malloc(4 * sizeof(int));
printf("Printing 2D Array From Heap Using Single Pointer\n");
int brrCounter = 0;
for(int i = 0; i < 3; i++)
{
for(int j = 0; j < 4; j++)
{
brr[i][j] = ++brrCounter;
printf("%d ", brr[i][j]);
}
printf("\n");
}
printf("\n");
crr = (int **) malloc(3 * sizeof(int *));
crr[0] = (int *) malloc(4 * sizeof(int));
crr[1] = (int *) malloc(4 * sizeof(int));
crr[2] = (int *) malloc(4 * sizeof(int));
printf("Printing 2D Array From Heap Using Double Pointer\n");
int crrCounter = 0;
for(int i = 0; i < 3; i++)
{
for(int j = 0; j < 4; j++)
{
crr[i][j] = ++crrCounter;
printf("%d ", crr[i][j]);
}
pri
```
<Overlap Ratio: 0.9557344064386318>

---

--- 32 --
Question ID: e771159fbef6dbfb7a5b3f4ce599cbcc89d98a09_146
Original Code:
```
static void
dissect_zcl_gp_proxy_sink_table_request(proto_tree *tree, tvbuff_t *tvb, guint *offset)
{
    /* get Options field */
    guint8 options = tvb_get_guint8(tvb, *offset);
    guint8 app_id, req_type;
    static const int * n_options[] = {
        &hf_zbee_zcl_proxy_sink_tbl_req_fld_app_id,
        &hf_zbee_zcl_proxy_sink_tbl_req_fld_req_type,
        NULL
    };

    proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_proxy_sink_tbl_req_options,
                           ett_zbee_zcl_proxy_sink_tbl_req_options, n_options, ENC_NA);
    *offset += 1;
    app_id = options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_APP_ID;
    req_type = (options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE) >>
        ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE_SHIFT;
    if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_GPD_ID) {
        /* Include GPD ID and/or Endpoint */
        if (app_id == ZBEE_ZCL_GP_APP_ID_DEFAULT) {
            /* App_id = 000: GPD SRC ID only */
            proto_tree_add_item(tree, hf_zbee_gp_src_id, tvb, *offset, 4, ENC_LITTLE_ENDIAN);
            *offset += 4;
        }
        else if (app_id == ZBEE_ZCL_GP_APP_ID_ZGP) {
            /* App_id = 010: MAC address + Endoint */
            proto_tree_add_item(tree, hf_zbee_gp_ieee, tvb, *offset, 8, ENC_LITTLE_ENDIAN);
            *offset += 8;
            proto_tree_add_item(tree, hf_zbee_gp_endpoint, tvb, *offset, 1, ENC_NA);
            *offset += 1;
        }
    }
    else if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_INDEX) {
        /* Include index only */
        proto_tree_add_item(tree, hf_zbee_zcl_proxy_sink_tbl_req_index, tvb, *offset, 1, ENC_NA);
        *offset += 1;
    }
}
```


Overlapping Code:
```
proxy_sink_table_request(proto_tree *tree, tvbuff_t *tvb, guint *offset)
{
/* get Options field */
guint8 options = tvb_get_guint8(tvb, *offset);
guint8 app_id, req_type;
static const int * n_options[] = {
&hf_zbee_zcl_proxy_sink_tbl_req_fld_app_id,
&hf_zbee_zcl_proxy_sink_tbl_req_fld_req_type,
NULL
};
proto_tree_add_bitmask(tree, tvb, *offset, hf_zbee_zcl_proxy_sink_tbl_req_options,
ett_zbee_zcl_proxy_sink_tbl_req_options, n_options, ENC_NA);
*offset += 1;
app_id = options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_APP_ID;
req_type = (options & ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE) >>
ZBEE_ZCL_GP_PROXY_SINK_TBL_REQ_CMD_REQ_TYPE_SHIFT;
if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_GPD_ID) {
/* Include GPD ID and/or Endpoint */
if (app_id == ZBEE_ZCL_GP_APP_ID_DEFAULT) {
/* App_id = 000: GPD SRC ID only */
proto_tree_add_item(tree, hf_zbee_gp_src_id, tvb, *offset, 4, ENC_LITTLE_ENDIAN);
*offset += 4;
}
else if (app_id == ZBEE_ZCL_GP_APP_ID_ZGP) {
/* App_id = 010: MAC address + Endoint */
proto_tree_add_item(tree, hf_zbee_gp_ieee, tvb, *offset, 8, ENC_LITTLE_ENDIAN);
*offset += 8;
proto_tree_add_item(tree, hf_zbee_gp_endpoint, tvb, *offset, 1, ENC_NA);
*offset += 1;
}
}
else if (req_type == ZBEE_ZCL_GP_PROXY_SINK_TABLE_REQ_CMD_REQUSET_BY_INDEX) {
/* Include index only */
proto_tree_add_item(tree, hf_zbee_zcl_proxy_sink_tbl_req_index, tvb, *offset, 1, ENC_NA);
*
```
<Overlap Ratio: 0.9702009702009702>

---

--- 33 --
Question ID: d938df5dc082df131cc884b27858250c65d25c91_0
Original Code:
```
class VtkImageFlipWrap : public VtkImageResliceWrap
{
	public:
		using Nan::ObjectWrap::Wrap;
		static void Init(v8::Local<v8::Object> exports);
		static void InitPtpl();
		static void ConstructorGetter(
			v8::Local<v8::String> property,
			const Nan::PropertyCallbackInfo<v8::Value>& info);

		VtkImageFlipWrap(vtkSmartPointer<vtkImageFlip>);
		VtkImageFlipWrap();
		~VtkImageFlipWrap( );
		static Nan::Persistent<v8::FunctionTemplate> ptpl;

	private:
		static void New(const Nan::FunctionCallbackInfo<v8::Value>& info);

		static void FlipAboutOriginOff(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void FlipAboutOriginOn(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void GetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void GetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void GetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void GetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void PreserveImageExtentOff(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void PreserveImageExtentOn(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void SetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void SetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void SetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);
		static void SetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);

#ifdef VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF
		VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF
#endif
}
```


Overlapping Code:
```
ublic VtkImageResliceWrap
{
public:
using Nan::ObjectWrap::Wrap;
static void Init(v8::Local<v8::Object> exports);
static void InitPtpl();
static void ConstructorGetter(
v8::Local<v8::String> property,
const Nan::PropertyCallbackInfo<v8::Value>& info);
VtkImageFlipWrap(vtkSmartPointer<vtkImageFlip>);
VtkImageFlipWrap();
~VtkImageFlipWrap( );
static Nan::Persistent<v8::FunctionTemplate> ptpl;
private:
static void New(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void FlipAboutOriginOff(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void FlipAboutOriginOn(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void GetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void GetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void GetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void GetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void NewInstance(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void PreserveImageExtentOff(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void PreserveImageExtentOn(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void SafeDownCast(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void SetFilteredAxes(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void SetFilteredAxis(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void SetFlipAboutOrigin(const Nan::FunctionCallbackInfo<v8::Value>& info);
static void SetPreserveImageExtent(const Nan::FunctionCallbackInfo<v8::Value>& info);
#ifdef VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF
VTK_NODE_PLUS_VTKIMAGEFLIPWRAP_CLASSDEF
#endif
```
<Overlap Ratio: 0.9837962962962963>

---

--- 34 --
Question ID: 723cc96c22a5511876188623b3319166030d8749_7
Original Code:
```
int
prom_getprop(pnode_t nodeid, caddr_t name, caddr_t value)
{
	int len, rv;
	cell_t ci[8];

	/*
	 * This function assumes the buffer is large enough to
	 * hold the result, so in 1275 mode, we pass in the length
	 * of the property as the length of the buffer, since we
	 * have no way of knowing the size of the buffer. Pre-1275
	 * OpenBoot(tm) PROMs did not have a bounded getprop.
	 *
	 * Note that we ignore the "length" result of the service.
	 */

	if ((len = prom_getproplen(nodeid, name)) <= 0)
		return (len);

	ci[0] = p1275_ptr2cell("getprop");	/* Service name */
	ci[1] = (cell_t)4;			/* #argument cells */
	ci[2] = (cell_t)0;			/* #result cells */
	ci[3] = p1275_phandle2cell((phandle_t)nodeid);	/* Arg1: package */
	ci[4] = p1275_ptr2cell(name);		/* Arg2: property name */
	ci[5] = p1275_ptr2cell(value);		/* Arg3: buffer address */
	ci[6] = len;				/* Arg4: buf len (assumed) */

	promif_preprom();
	rv = p1275_cif_handler(&ci);
	promif_postprom();

	if (rv != 0)
		return (-1);
	return (len);				/* Return known length */
}
```


Overlapping Code:
```
de_t nodeid, caddr_t name, caddr_t value)
{
int len, rv;
cell_t ci[8];
/*
* This function assumes the buffer is large enough to
* hold the result, so in 1275 mode, we pass in the length
* of the property as the length of the buffer, since we
* have no way of knowing the size of the buffer. Pre-1275
* OpenBoot(tm) PROMs did not have a bounded getprop.
*
* Note that we ignore the "length" result of the service.
*/
if ((len = prom_getproplen(nodeid, name)) <= 0)
return (len);
ci[0] = p1275_ptr2cell("getprop"); /* Service name */
ci[1] = (cell_t)4; /* #argument cells */
ci[2] = (cell_t)0; /* #result cells */
ci[3] = p1275_phandle2cell((phandle_t)nodeid); /* Arg1: package */
ci[4] = p1275_ptr2cell(name); /* Arg2: property name */
ci[5] = p1275_ptr2cell(value); /* Arg3: buffer address */
ci[6] = len; /* Arg4: buf len (assumed) */
promif_preprom();
rv = p1275_cif_handler(&ci);
promif_postprom();
if (rv != 0)
return (-1);
return (len); /* Retur
```
<Overlap Ratio: 0.9605662285136501>

---

--- 35 --
Question ID: 717413d8c99f0881c185605a09283a66fceb927e_47
Original Code:
```
int bgcp_match (void *cx, const char *topic_name, const char *type_name)
{
	SR_CX		*cp = (SR_CX *) cx;
	SR_NOTIFY_DATA	*anp;
	SR_NOTIFY	*np;

	LIST_FOREACH (cp->notifications, anp) {
		np = anp->notification;
		if (!nmatch (str_ptr (np->topic), topic_name, 0) &&
		    !nmatch (str_ptr (np->type), type_name, 0))
			return (1);
	}
	return (0);
}
```


Overlapping Code:
```
 bgcp_match (void *cx, const char *topic_name, const char *type_name)
{
SR_CX *cp = (SR_CX *) cx;
SR_NOTIFY_DATA *anp;
SR_NOTIFY *np;
LIST_FOREACH (cp->notifications, anp) {
np = anp->notification;
if (!nmatch (str_ptr (np->topic), topic_name, 0) &&
!nmatch (str_ptr (np->type), type_name, 0))
return
```
<Overlap Ratio: 0.9259259259259259>

---

--- 36 --
Question ID: de6c79bda84aab2efa6518cb3eda5e0ec9799f16_39
Original Code:
```
void
bus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)
{
	if (t == NULL) {
		strlcat(buf, "<NULL>", len);
		return;
	}
	buf[0] = '\0';
	if (t->parent)
		bus_space_render_tag(t->parent, buf, len);

	strlcat(buf, "/", len);
	strlcat(buf, t->name, len);
}
```


Overlapping Code:
```
d
bus_space_render_tag(bus_space_tag_t t, char* buf, size_t len)
{
if (t == NULL) {
strlcat(buf, "<NULL>", len);
return;
}
buf[0] = '\0';
if (t->parent)
bus_space_render_tag(t->parent, buf, len);
strl
```
<Overlap Ratio: 0.7936507936507936>

---

--- 37 --
Question ID: 23836bfcc5b5fd26390fa1ba240355a1cd416b90_0
Original Code:
```
class il2cpp_binding_internal : public il2cpp_binding {
public:
	il2cpp_binding_internal(const il2cpp_context &ctx);
	~il2cpp_binding_internal();

	void setupHooks();

	const il2cpp_context &mCtx;
	std::vector<HookCall> mHooks;
	std::unordered_map<std::string, size_t> mHooksByMethodName;
	std::unordered_map<uint64_t, size_t> mHooksByInvocation;

	uint64_t mFnId;
	std::vector<void *> mBuffers;
	void *mCurrentPtr;
}
```


Overlapping Code:
```
l : public il2cpp_binding {
public:
il2cpp_binding_internal(const il2cpp_context &ctx);
~il2cpp_binding_internal();
void setupHooks();
const il2cpp_context &mCtx;
std::vector<HookCall> mHooks;
std::unordered_map<std::string, size_t> mHooksByMethodName;
std::unordered_map<uint64_t, size_t> mHooksByInvocation;
uint64_t mFnId;
std::vector<void *> mBuf
```
<Overlap Ratio: 0.8663366336633663>

---

--- 38 --
Question ID: 34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_238
Original Code:
```
rbool_t smIPT_isC3(const RKH_SM_T* sma, RKH_EVT_T* pe)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_smIPT_isC3_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_smIPT_isC3);
  cmock_call_instance = (CMOCK_smIPT_isC3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_isC3_CallInstance);
  Mock.smIPT_isC3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_isC3_CallInstance);
  if (Mock.smIPT_isC3_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.smIPT_isC3_FinalReturn;
    memcpy(&Mock.smIPT_isC3_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(rbool_t));
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_sma)
  {
    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_sma);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_sma, sma, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pe)
  {
    UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_pe);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pe, pe, cmock_line, CMockStringMismatch);
  }
  if (Mock.smIPT_isC3_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.smIPT_isC3_CallbackFunctionPointer(sma, pe, Mock.smIPT_isC3_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}
```


Overlapping Code:
```
const RKH_SM_T* sma, RKH_EVT_T* pe)
{
UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
CMOCK_smIPT_isC3_CALL_INSTANCE* cmock_call_instance;
UNITY_SET_DETAIL(CMockString_smIPT_isC3);
cmock_call_instance = (CMOCK_smIPT_isC3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_isC3_CallInstance);
Mock.smIPT_isC3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_isC3_CallInstance);
if (Mock.smIPT_isC3_IgnoreBool)
{
UNITY_CLR_DETAILS();
if (cmock_call_instance == NULL)
return Mock.smIPT_isC3_FinalReturn;
memcpy(&Mock.smIPT_isC3_FinalReturn, &cmock_call_instance->ReturnVal, sizeof(rbool_t));
return cmock_call_instance->ReturnVal;
}
UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
cmock_line = cmock_call_instance->LineNumber;
if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
if (!cmock_call_instance->IgnoreArg_sma)
{
UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_sma);
UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_sma, sma, cmock_line, CMockStringMismatch);
}
if (!cmock_call_instance->IgnoreArg_pe)
{
UNITY_SET_DETAILS(CMockString_smIPT_isC3,CMockString_pe);
UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_pe, pe, cmock_line, CMockStringMismatch);
}
if (Mock.smIPT_isC3_CallbackFunctionPointer != NULL)
{
cmock_call_instance->ReturnVal = Mock.smIPT_isC3_CallbackFunctionPointer(sma, pe, Mock.smIPT_isC3_CallbackCalls++);
}
UNITY_CLR_DETAILS();
return cmock_call_instance->ReturnVal;

```
<Overlap Ratio: 0.9877450980392157>

---

--- 39 --
Question ID: 02bf33dffefbfc4a2c1fa36563c60265fed0803a_4
Original Code:
```
void i2c_write(I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len)
{
    uint8_t i2cBuffer[len + 1];
    int i;

    i2cBuffer[0] = address | 0x00;
    memcpy(&i2cBuffer[1], data, len);

    if (!StartTransfer(i2c_id, FALSE))
    {
        return;
    }
    for (i = 0; i < len + 1; i++)
    {
        if (!TransmitOneByte(i2c_id, i2cBuffer[i]))
        {
            break;
        }
    }

    StopTransfer(i2c_id);
}
```


Overlapping Code:
```
I2C_MODULE i2c_id, uint8_t address, uint8_t *data, int len)
{
uint8_t i2cBuffer[len + 1];
int i;
i2cBuffer[0] = address | 0x00;
memcpy(&i2cBuffer[1], data, len);
if (!StartTransfer(i2c_id, FALSE))
{
return;
}
for (i = 0; i < len + 1; i++)
{
if (!TransmitOneByte(i2c_id, i2cBuffer[i]))
{
break;
}
}
StopTra
```
<Overlap Ratio: 0.9077380952380952>

---

--- 40 --
Question ID: c1969597dd911de7c2382f1af190a983a881bc94_0
Original Code:
```
TSS2_RC Tss2_Sys_CreateLoaded_Prepare(
    TSS2_SYS_CONTEXT *sysContext,
    TPMI_RH_HIERARCHY parentHandle,
    const TPM2B_SENSITIVE_CREATE *inSensitive,
    const TPM2B_TEMPLATE *inPublic)
{
    _TSS2_SYS_CONTEXT_BLOB *ctx = syscontext_cast(sysContext);
    TSS2_RC rval;

    if (!ctx)
        return TSS2_SYS_RC_BAD_REFERENCE;

    if (!inPublic)
        return TSS2_SYS_RC_BAD_REFERENCE;

    rval = CommonPreparePrologue(ctx, TPM2_CC_CreateLoaded);
    if (rval)
        return rval;

    rval = Tss2_MU_UINT32_Marshal(parentHandle, ctx->cmdBuffer,
                          ctx->maxCmdSize,
                          &ctx->nextData);
    if (rval)
        return rval;

    if (!inSensitive) {
        ctx->decryptNull = 1;

        rval = Tss2_MU_UINT16_Marshal(0, ctx->cmdBuffer,
                                      ctx->maxCmdSize,
                                      &ctx->nextData);
    } else {
        rval = Tss2_MU_TPM2B_SENSITIVE_CREATE_Marshal(inSensitive,
                                                      ctx->cmdBuffer,
                                                      ctx->maxCmdSize,
                                                      &ctx->nextData);
    }

    if (rval)
        return rval;

    rval = Tss2_MU_TPM2B_TEMPLATE_Marshal(inPublic, ctx->cmdBuffer,
                                          ctx->maxCmdSize,
                                          &ctx->nextData);
    if (rval)
        return rval;

    ctx->decryptAllowed = 1;
    ctx->encryptAllowed = 1;
    ctx->authAllowed = 1;

    rval = CommonPrepareEpilogue(ctx);
    return rval;
}
```


Overlapping Code:
```
Sys_CreateLoaded_Prepare(
TSS2_SYS_CONTEXT *sysContext,
TPMI_RH_HIERARCHY parentHandle,
const TPM2B_SENSITIVE_CREATE *inSensitive,
const TPM2B_TEMPLATE *inPublic)
{
_TSS2_SYS_CONTEXT_BLOB *ctx = syscontext_cast(sysContext);
TSS2_RC rval;
if (!ctx)
return TSS2_SYS_RC_BAD_REFERENCE;
if (!inPublic)
return TSS2_SYS_RC_BAD_REFERENCE;
rval = CommonPreparePrologue(ctx, TPM2_CC_CreateLoaded);
if (rval)
return rval;
rval = Tss2_MU_UINT32_Marshal(parentHandle, ctx->cmdBuffer,
ctx->maxCmdSize,
&ctx->nextData);
if (rval)
return rval;
if (!inSensitive) {
ctx->decryptNull = 1;
rval = Tss2_MU_UINT16_Marshal(0, ctx->cmdBuffer,
ctx->maxCmdSize,
&ctx->nextData);
} else {
rval = Tss2_MU_TPM2B_SENSITIVE_CREATE_Marshal(inSensitive,
ctx->cmdBuffer,
ctx->maxCmdSize,
&ctx->nextData);
}
if (rval)
return rval;
rval = Tss2_MU_TPM2B_TEMPLATE_Marshal(inPublic, ctx->cmdBuffer,
ctx->maxCmdSize,
&ctx->nextData);
if (rval)
return rval;
ctx->decryptAllowed = 1;
ctx->encryptAllowed = 1;
ctx->authAllowed = 1;
rval = CommonPrepareEpilog
```
<Overlap Ratio: 0.9657469077069457>

---

--- 41 --
Question ID: 95eb22e0722facfcbd64dd95905a715a76876465_3
Original Code:
```
void reg_msg_init(struct public_params *pub, struct register_msg *msg)
{
   element_init_G1(msg->M, pub->p);
   element_init_G1(msg->R, pub->p);
   element_init_Zr(msg->rg, pub->p);
   element_init_Zr(msg->rZ, pub->p);
}
```


Overlapping Code:
```
ic_params *pub, struct register_msg *msg)
{
element_init_G1(msg->M, pub->p);
element_init_G1(msg->R, pub->p);
element_init_Zr(msg->rg, pub->p);
elemen
```
<Overlap Ratio: 0.7211538461538461>

---

--- 42 --
Question ID: 977f383e2aec238e4fce3e4e80bde38a6e5f2645_1
Original Code:
```
void test_gcm_encrypt_decrypt(void){
  unsigned char* key        = NULL;
  unsigned char* plaintext  = NULL;
  unsigned char* ciphertext = NULL;
  unsigned char* decrypt    = NULL;

  int key_len = 16;
  size_t plaintext_len = 16;
  size_t ciphertext_len = 0;
  size_t decrypt_len = 0;
  
  key = calloc(key_len, 1);
  plaintext = calloc(plaintext_len, 1);
  
  CU_ASSERT(aes_gcm_encrypt(key, key_len, plaintext, plaintext_len, &ciphertext, &ciphertext_len, false) == 0);
  CU_ASSERT(ciphertext_len = plaintext_len + GCM_IV_LEN + GCM_TAG_LEN);
  CU_ASSERT(aes_gcm_decrypt(key, key_len, ciphertext, ciphertext_len, &decrypt, &decrypt_len, false) == 0);
  CU_ASSERT(decrypt_len == plaintext_len);
  CU_ASSERT(memcmp(plaintext, decrypt, plaintext_len) == 0);


  free(decrypt);
  free(key);
  free(plaintext);
  free(ciphertext);
  return;
}
```


Overlapping Code:
```
ned char* key = NULL;
unsigned char* plaintext = NULL;
unsigned char* ciphertext = NULL;
unsigned char* decrypt = NULL;
int key_len = 16;
size_t plaintext_len = 16;
size_t ciphertext_len = 0;
size_t decrypt_len = 0;

key = calloc(key_len, 1);
plaintext = calloc(plaintext_len, 1);

CU_ASSERT(aes_gcm_encrypt(key, key_len, plaintext, plaintext_len, &ciphertext, &ciphertext_len, false) == 0);
CU_ASSERT(ciphertext_len = plaintext_len + GCM_IV_LEN + GCM_TAG_LEN);
CU_ASSERT(aes_gcm_decrypt(key, key_len, ciphertext, ciphertext_len, &decrypt, &decrypt_len, false) == 0);
CU_ASSERT(decrypt_len == plaintext_len);
CU_ASSERT(memcmp(plaintext, decrypt, plaintext_len) == 0);
free(decrypt);
free(key);
free(plaintext)
```
<Overlap Ratio: 0.908974358974359>

---

--- 43 --
Question ID: b115d1bfb1fd74fd8882385529f2f2ef2035cdba_38
Original Code:
```
ins* lookfor_inst ( mc88110* mc, unsigned int oc_deci )
{
    int left = 0;
    int right = mc->n_insts - 3;
    while( left <= right )
    {
        int medium = (left + right) / 2;
        if ( (unsigned)mc->insts[medium].oc.deci < oc_deci )
        {
            left = medium + 1;
        }
        else if ( (unsigned)mc->insts[medium].oc.deci > oc_deci )
        {
            right = medium - 1;
        }
        else
        {
            return mc->insts + medium;
        }
    }
    return mc->insts + (mc->n_insts - 2);
}
```


Overlapping Code:
```
 ( mc88110* mc, unsigned int oc_deci )
{
int left = 0;
int right = mc->n_insts - 3;
while( left <= right )
{
int medium = (left + right) / 2;
if ( (unsigned)mc->insts[medium].oc.deci < oc_deci )
{
left = medium + 1;
}
else if ( (unsigned)mc->insts[medium].oc.deci > oc_deci )
{
right = medium - 1;
}
else
{
return mc->insts + medium;
}
}
return mc->i
```
<Overlap Ratio: 0.8883248730964467>

---

--- 44 --
Question ID: 3c172dd6a0c7a61bb18cdf670091b3cce16b27e9_100
Original Code:
```
void bdrv_detach_aio_context(BlockDriverState *bs)
{
    BdrvAioNotifier *baf;

    if (!bs->drv) {
        return;
    }

    QLIST_FOREACH(baf, &bs->aio_notifiers, list) {
        baf->detach_aio_context(baf->opaque);
    }

    if (bs->throttle_state) {
        throttle_timers_detach_aio_context(&bs->throttle_timers);
    }
    if (bs->drv->bdrv_detach_aio_context) {
        bs->drv->bdrv_detach_aio_context(bs);
    }
    if (bs->file) {
        bdrv_detach_aio_context(bs->file->bs);
    }
    if (bs->backing) {
        bdrv_detach_aio_context(bs->backing->bs);
    }

    bs->aio_context = NULL;
}
```


Overlapping Code:
```
ach_aio_context(BlockDriverState *bs)
{
BdrvAioNotifier *baf;
if (!bs->drv) {
return;
}
QLIST_FOREACH(baf, &bs->aio_notifiers, list) {
baf->detach_aio_context(baf->opaque);
}
if (bs->throttle_state) {
throttle_timers_detach_aio_context(&bs->throttle_timers);
}
if (bs->drv->bdrv_detach_aio_context) {
bs->drv->bdrv_detach_aio_context(bs);
}
if (bs->file) {
bdrv_detach_aio_context(bs->file->bs);
}
if (bs->backing) {
bdrv_detach_aio_context(bs->backi
```
<Overlap Ratio: 0.9018036072144289>

---

--- 45 --
Question ID: 7bc9bc3ead6ecad9c4a3a03446bd70e330208f69_28
Original Code:
```
void SetTrayY(TrayType *tp, const char *str)
{
   Assert(tp);
   Assert(str);
   tp->requestedY = atoi(str);
}
```


Overlapping Code:
```
t char *str)
{
Assert(tp);
Assert(str);
tp->requestedY = at
```
<Overlap Ratio: 0.5841584158415841>

---

--- 46 --
Question ID: 9ea90cfb78f627708f2583e9f3c960bcac597732_0
Original Code:
```
char *_str(){
	char *p = calloc(1, 30);
	strcpy(p, "test update");
	return p;
}
```


Overlapping Code:
```
*p = calloc(1, 30);
strcpy(p, "test update");
retu
```
<Overlap Ratio: 0.6578947368421053>

---

--- 47 --
Question ID: 433d7a0a80c344f4274a5302ccd7e0ba6b61b4dd_13
Original Code:
```
int bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
{
	struct bttv *btv = i2c_get_adapdata(i2c_adap);
	int retval = 0;
	int i;

	if (i2c_debug)
		printk("bt-i2c:");
	btwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);
	for (i = 0 ; i < num; i++) {
		if (msgs[i].flags & I2C_M_RD) {
			/* read */
			retval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);
			if (retval < 0)
				goto err;
		} else {
			/* write */
			retval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);
			if (retval < 0)
				goto err;
		}
	}
	return num;

 err:
	return retval;
}
```


Overlapping Code:
```
bttv_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
{
struct bttv *btv = i2c_get_adapdata(i2c_adap);
int retval = 0;
int i;
if (i2c_debug)
printk("bt-i2c:");
btwrite(BT848_INT_I2CDONE|BT848_INT_RACK, BT848_INT_STAT);
for (i = 0 ; i < num; i++) {
if (msgs[i].flags & I2C_M_RD) {
/* read */
retval = bttv_i2c_readbytes(btv, &msgs[i], i+1 == num);
if (retval < 0)
goto err;
} else {
/* write */
retval = bttv_i2c_sendbytes(btv, &msgs[i], i+1 == num);
if (retval < 0)
goto err;
}
}
r
```
<Overlap Ratio: 0.9332096474953617>

---

--- 48 --
Question ID: 0488a512034bd6654ad3b0615fe4dc1619905a64_0
Original Code:
```
TypeStateEntry *CreateMINMAXState(SmurfManager *SM, DdNode *pMINMAXBDD) {
  MINMAXStateEntry *pMINMAXState = NULL;
  
  if((SM->uTempList1.nLength >= functionTypeLimits[FN_TYPE_MINMAX]) && isMINMAX(SM->dd, pMINMAXBDD, &SM->uTempList1)) {
    Cudd_Ref(pMINMAXBDD);
    
    //Build MINMAX state
    uintmax_t nNumBDDVars = SM->uTempList1.nLength;
    uintmax_t nNumElts = SM->uTempList1.pList[nNumBDDVars-1]+1;
    assert(nNumElts > 0);

    uint8_t ret = check_SmurfStatesTableSize(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));
    if(ret != NO_ERROR) {assert(0); return NULL;}
    
    pMINMAXState = (MINMAXStateEntry *)SM->pSmurfStatesTableTail;
    chomp_SmurfStatesTable(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));
    sbsat_stats[STAT_MINMAX_STATES_BUILT]+=1;
    sbsat_stats[STAT_STATES_BUILT]+=1;
    
    pMINMAXState->type             = FN_MINMAX;
    pMINMAXState->visited          = 0;
    pMINMAXState->nNumVariables    = nNumElts;
    pMINMAXState->nNumBDDVariables = nNumBDDVars;
    pMINMAXState->nMin             = getMIN(SM->dd, pMINMAXBDD, nNumBDDVars);
    pMINMAXState->nMax             = getMAX(SM->dd, pMINMAXBDD);
    pMINMAXState->bExists          = (uint8_t *)(pMINMAXState+1);
    pMINMAXState->pMINMAXBDD       = pMINMAXBDD;
    
    assert(pMINMAXState->nMin <= pMINMAXState->nMax);

    uintmax_t nBDDVar = 0;
    for(uintmax_t nVbleIndex = 0; nVbleIndex < nNumElts; nVbleIndex++) {
      if(nVbleIndex == SM->uTempList1.pList[nBDDVar]) {
	//Variable is in the BDD
	pMINMAXState->bExists[nVbleIndex] = 1;
	nBDDVar++;
      } else {
	//Variable is not in the BDD
	pMINMAXState->bExists[nVbleIndex] = 0;
      }
    }
    assert(nBDDVar == nNumBDDVars);
  }
  
  //Leaf node, just return
  return (TypeStateEntry *)pMINMAXState;
}
```


Overlapping Code:
```
er *SM, DdNode *pMINMAXBDD) {
MINMAXStateEntry *pMINMAXState = NULL;

if((SM->uTempList1.nLength >= functionTypeLimits[FN_TYPE_MINMAX]) && isMINMAX(SM->dd, pMINMAXBDD, &SM->uTempList1)) {
Cudd_Ref(pMINMAXBDD);

//Build MINMAX state
uintmax_t nNumBDDVars = SM->uTempList1.nLength;
uintmax_t nNumElts = SM->uTempList1.pList[nNumBDDVars-1]+1;
assert(nNumElts > 0);
uint8_t ret = check_SmurfStatesTableSize(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));
if(ret != NO_ERROR) {assert(0); return NULL;}

pMINMAXState = (MINMAXStateEntry *)SM->pSmurfStatesTableTail;
chomp_SmurfStatesTable(SM, (uintmax_t)sizeof(MINMAXStateEntry) + (sizeof(uint8_t) * nNumElts));
sbsat_stats[STAT_MINMAX_STATES_BUILT]+=1;
sbsat_stats[STAT_STATES_BUILT]+=1;

pMINMAXState->type = FN_MINMAX;
pMINMAXState->visited = 0;
pMINMAXState->nNumVariables = nNumElts;
pMINMAXState->nNumBDDVariables = nNumBDDVars;
pMINMAXState->nMin = getMIN(SM->dd, pMINMAXBDD, nNumBDDVars);
pMINMAXState->nMax = getMAX(SM->dd, pMINMAXBDD);
pMINMAXState->bExists = (uint8_t *)(pMINMAXState+1);
pMINMAXState->pMINMAXBDD = pMINMAXBDD;

assert(pMINMAXState->nMin <= pMINMAXState->nMax);
uintmax_t nBDDVar = 0;
for(uintmax_t nVbleIndex = 0; nVbleIndex < nNumElts; nVbleIndex++) {
if(nVbleIndex == SM->uTempList1.pList[nBDDVar]) {
//Variable is in the BDD
pMINMAXState->bExists[nVbleIndex] = 1;
nBDDVar++;
} else {
//Variable is not in the BDD
pMINMAXState->bExists[nVbleIndex] = 0;
}
}
assert(nBDDVar == nNumBDDVars);
}

//Leaf node, just return
return (TypeStateEntry *)pMINMAXSt
```
<Overlap Ratio: 0.96875>

---

--- 49 --
Question ID: 8838d512c14a7c5ec33e226bb650fc7a31dddc41_0
Original Code:
```
class InfoSQL {
   public:
      /**
       * Constructs new SQL connection.
       */
      InfoSQL();


      /**
       * Destructor, dissconnects from SQL.
       */
      ~InfoSQL();

   bool setupDatabaseConnection();
   bool checkDatabaseConnection(int maxNbrTries = 1);

      /**
       *   @name Get- and delete- functions for trafficdisturbances.
       */
      //@{
        /**
         *  Adds a number of trafficdisturbances from a vector to the
         *  database.
         *  @param distVect  The vector with disturbances.
         *  @param firstPacket True if it's the first disturbances that
         *                     is sent with this situationID.
         *  @return True if the adding was okey, otherwise false.
         */
      bool addDisturbance(DisturbanceElement* distElem);

      /**
       *  Removes the disturbances with a situationID
       *  and elementID.

       *  @param disturbanceID      The disturbance ID.
       *  @param situationReference The situationReference string.
       *  @param supplier           A string identifying a supplier.
       *  @param removeAll          Whether all disturbances from the
       *                            supplier should be removed.
       *  @param toBeKept           A list of situationReference strings
       *                            specifying which disturbances
       *                            should not be removed if removeAll
       *                            is set.
       *  @return True if the delete was OK, otherwise false.
       */
   bool deleteDisturbances(DisturbanceElement::DisturbanceID disturbanceID,
                              const MC2String& situationReference,
                              const MC2String& supplier,
                              bool removeAll,
                              vector<MC2String>& toBeKept);

      /**
       *  Updates the disturbances with a situationID and a elementID.
       *  @param type  The new disturbance type.
       *  @param severity The new severity.
       *  @param startTime The new disturbance start time.
       *  @param endTime The new disturbance end time.
       *  @param creationTime The time of the update, the new
       *                      creation time.
       *  @param comment The new disturbance comment.
       *  @param situationID The situationID of the updated disturbance.
       *  @param elementID The elementID of the updated disturbance.
       *  @return True if the updating was okey, otherwise false.
       */
      bool updateDisturbance(uint32 disturbanceID,
                             TrafficDataTypes::disturbanceType type,
                             TrafficDataTypes::severity severity,
                             uint32 startTime,
                             uint32 endTime,
                             uint32 costFactor,
                             MC2String text);

      /*
       *  Returns all disturbances within a given bounding box from
       *  the database.
       *  @param bbox  The MC2BoundingBox.
       *  @param distVect A reference to a vector, where the function
       *                  inserts all the disturbances.
       *  @return True if the loading was okey, otherwise false.
       */
      bool getDisturbancesWithinBBox(const MC2BoundingBox& bbox,
                                     vector<DisturbanceElement*> &distVect);

   /**
       *  Returns all disturbances within a given bounding box from
       *  the database.
       *  @param bbox  The MC2BoundingBox.
       *  @param distVect A reference to a vector, where the function
       *                  inserts all the disturbances.
       *  @return True if the loading was okey, otherwise false.
       */
      bool getDisturbancesWithinRadius(int32 latitude,
                                       int32 longitude,
                                       uint32 distance,
                                       vector<DisturbanceElement*> &distVect);

      /**
       *  Returns all disturbances from a specified supplier.
       *  @param distVect Output parameter. The found disturbances are
       *                  push_back:ed into the vector.
       *  @param supplier The string identifying the supplier.
       */
      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,
                                       const MC2String& supplier );
      /**
       *  Returns all disturbances from a specified supplier, except
       *  certain specified disturbances.
       *  @param distVect Output parameter. The found disturbances are
       *                  push_back:ed into the vector.
       *  @param supplier The string identifying the supplier.
       *  @param toBeKept A list of situationReference strings identifying
       *                  situations that should not be inserted into
       *                  <code>distVect</code>.
       */
      void getDisturbancesForSupplier( vector<DisturbanceElement*> &distVect,
                                       const MC2String& supplier,
                                       const vector<MC2String>& toBeKept );


      /**
       * Removes disturbances with end time less than time.
       * @return true if operation successfull, false otherwise.
       */
      bool deleteOldDisturbances();


      /**
       *   Get the disturbance with the given ID.
       *   @return The found disturbance or NULL if not found.
       */
      DisturbanceElement* getDisturbance(uint32 disturbanceID);

      /**
       *   Get the disturbance with the given situationReference
       *   @return The found disturbance or NULL if not found.
       */
      DisturbanceElement* getDisturbance(const MC2String& situationReference);

private:
      /**
       *   Get the disturbance with the given situationReference and
       *   disturbanceID. If disturbanceID is equal to MAX_UINT32 it
       *   is not considered.  If situationReference is equal to the
       *   empty string it is not considered.
       *   @return The found disturbance or NULL if not found.
       */
   DisturbanceElement* getDisturbance(DisturbanceElement::DisturbanceID disturbanceID,
                                      const MC2String& situationReference);
public:

      /**
       *  Returns the coordinates of one or two TMC points in the database.
       *  @param firstLocationCode The primary TMC point.
       *  @param secondLocationCode The secondary TMC-point.
       *  @param extent The extent.
       *  @param direction The direction.
       *  @param country The country
       *  @param latitude The vector with lats.
       *  @param longitude The vector with longs.
       *  @return True if the point(s) were successfully found.
       */
      bool getTMCCoords(MC2String firstLocation,
                        MC2String secondLocation,
                        int32 extent,
                        TrafficDataTypes::direction direction,
                        vector< pair<int32, int32> > &firstCoords,
                        vector< pair<int32, int32> > &secondCoords);

   private:
   /**
    * Extract the first DisturbanceElement from a SQL answer.
    * @param sqlQuery A SQL query already containing the answer.
    *                 When the function returns it will have advanced
    *                 to the first line that does not belong with the
    *                 disturbance.
    * @param disturbances Output parameter for the extracted disturbances.
    */
   void extractDisturbances(SQLQuery& sqlQuery,
                           map<uint32,DisturbanceElement*>& disturbances);

      /**
       *   Do a SQL query. Copied from UserModule/UserProcessor
       *   @param sqlQuery Pointer to the SQLQuery to use
       *   @param query The query string
       *   @param whereTag Set this to a constant string which
       *                   identifies the callee
       *   @return True if successful, false otherwise
       */
      //@{
      bool doQuery(SQLQuery* sqlQuery,
                   const std::ostringstream& stream,
                   const char* whereTag);

      bool doQuery(SQLQuery* sqlQuery, const MC2String& str,
                   const char* whereTag);

      bool doQuery(SQLQuery* sqlQuery, const char* query,
                   const char* whereTag);
      //@}

      /**
       *   Adds a table to the internal table vectors. Copied from
       *   UserModule/UserProcessor
       *   @param name The name of the table
       *   @param createQuery The SQL query that creates the query
       *   @param extraQuery Any additional query to run after creation of
       *                     table (such as index creation)
       */
      void addTable(const MC2String& name, const MC2String& createQuery,
                    const MC2String& extraQuery = "");

      /**
       *   Initializes the table vectors. Copied from UserModule/UserProcessor
       *   @return The number of tables, 0 if something went wrong
       */
      size_t initTables();

      /**
       *   Checks database for required tables. Tries to create tables.
       *   @return true if successfull
       */
      bool initialCheckDatabase();

      /**
       * Returns an unused id in a table.
       * @param tableName The name of the table
       * @param colName   The name of the id column
       * @return Returns an unused id. 0 if error.
       */
      uint32 getNewUniqueID(const char* tableName, const char* colName);

      /**
       *   The database connection
       */
      CharEncSQLConn* m_sqlConnection;

   /**
    * Struct that encapsulates the data stored by calls to addTable.
    */
   struct TableData {
      /**
       * Constructor.
       * @param name The name of the table.
       * @param createQuery The query used to create the table if it
       *                    doesn't exist.
       * @param extraQuery Extra query run after a successful create
       *                   query.
       */
      TableData(const MC2String& name,
                const MC2String& createQuery,
                const MC2String& extraQuery) :
         name(name), createQuery(createQuery), extraQuery(extraQuery)
      {}
      /** The table name. */
      MC2String name;
      /** The query to create the table. */
      MC2String createQuery;
      /** Any extra query. */
      MC2String extraQuery;
   };
   /** Typedef of container to store TableData structs in. */
   typedef std::vector<TableData> tableCont_t;
   /** Data about the needed tables. */
   tableCont_t m_tableData;
}
```


Overlapping Code:
```
c:
/**
* Constructs new SQL connection.
*/
InfoSQL();
/**
* Destructor, dissconnects from SQL.
*/
~InfoSQL();
bool setupDatabaseConnection();
bool checkDatabaseConnection(int maxNbrTries = 1);
/**
* @name Get- and delete- functions for trafficdisturbances.
*/
//@{
/**
* Adds a number of trafficdisturbances from a vector to the
* database.
* @param distVect The vector with disturbances.
* @param firstPacket True if it's the first disturbances that
* is sent with this situationID.
* @return True if the adding was okey, otherwise false.
*/
bool addDisturbance(DisturbanceElement* distElem);
/**
* Removes the disturbances with a situationID
* and elementID.
* @param disturbanceID The disturbance ID.
* @param situationReference The situationReference string.
* @param supplier A string identifying a supplier.
* @param removeAll Whether all disturbances from the
* supplier should be removed.
* @param toBeKept A list of situationReference strings
* specifying which disturbances
* should not be removed if removeAll
* is set.
* @return True if the delete was OK, otherwise false.
*/
bool deleteDisturbances(DisturbanceElement::DisturbanceID disturbanceID,
const MC2String& situationReference,
const MC2String& supplier,
bool removeAll,
vector<MC2String>& toBeKept);
/**
* Updates the disturbances with a situationID and a elementID.
* @param type The new disturbance type.
* @param severity The new severity.
* @param startTime The new disturbance start time.
* @param endTime The new disturbance end time.
* @param creationTime The time of the update, the new
* creation time.
* @param comment The new disturbance comment.
* @param situationID The situationID of the updated disturbance.
* @param elementID The elementID of the updated disturba
```
<Overlap Ratio: 0.9641873278236914>

---

--- 50 --
Question ID: 85226f2030c4ea5aa1cfa19ded9cdff16a3b75e0_0
Original Code:
```
interface SXComponentScrollPosition : SXScrollPosition {

	NSString* _componentIdentifier;
	double _relativePageOffset;
	double _canvasWidth;

}
```


Overlapping Code:
```
tScrollPosition : SXScrollPosition {
NSString* _componentIdentifier;
double _relativePageOffset;
double _can
```
<Overlap Ratio: 0.7769784172661871>

---

--- 51 --
Question ID: 70f4a8c8db38e473a6d492cf0a27e4333166ecd4_27
Original Code:
```
void GH_UART1_set_FCR_TX_Empty_Trigger(U8 data)
{
    m_uart1_fcr.bitc.tx_empty_trigger = data;
    *(volatile U32 *)REG_UART1_FCR = m_uart1_fcr.all;
    #if GH_UART1_ENABLE_DEBUG_PRINT
    GH_UART1_DEBUG_PRINT_FUNCTION( "WRREG(0x%08x,0x%08x); \\\\ [GH_UART1_set_FCR_TX_Empty_Trigger] <-- 0x%08x\n",
                        REG_UART1_FCR,m_uart1_fcr.all,m_uart1_fcr.all);
    #endif
}
```


Overlapping Code:
```
 GH_UART1_set_FCR_TX_Empty_Trigger(U8 data)
{
m_uart1_fcr.bitc.tx_empty_trigger = data;
*(volatile U32 *)REG_UART1_FCR = m_uart1_fcr.all;
#if GH_UART1_ENABLE_DEBUG_PRINT
GH_UART1_DEBUG_PRINT_FUNCTION( "WRREG(0x%08x,0x%08x); \\\\ [GH_UART1_set_FCR_TX_Empty_Trigger] <-- 0x%08x\n",
REG_UART1_FCR,m_uart1_fcr.all,m_uart1_fcr.all);
#endif

```
<Overlap Ratio: 0.9852941176470589>

---

--- 52 --
Question ID: 9e773ff14a12ede8cf195c57430978627878503b_5
Original Code:
```
esp_dispatcher_handle_t esp_dispatcher_create(esp_dispatcher_config_t *cfg)
{
    AUDIO_NULL_CHECK(TAG, cfg, return NULL);
    esp_dispatcher_handle_t impl = audio_calloc(1, sizeof(esp_dispatcher_t));
    AUDIO_MEM_CHECK(TAG, impl, return NULL);
    impl->result_que = xQueueCreate(1, sizeof(action_result_t));
    AUDIO_MEM_CHECK(TAG, impl->result_que, goto _failed;);
    impl->exe_que = xQueueCreate(ESP_DISPATCHER_EVENT_SIZE, sizeof(esp_dispatcher_info_t));
    AUDIO_MEM_CHECK(TAG, impl->exe_que, goto _failed;);
    impl->mutex = mutex_create();
    AUDIO_MEM_CHECK(TAG, impl->mutex, goto _failed;);
    STAILQ_INIT(&impl->exe_list);
    ESP_LOGE(TAG, "exe first list: %p", STAILQ_FIRST(&impl->exe_list));

    if (pdPASS != xTaskCreatePinnedToCore(dispatcher_event_task,
                                          "esp_dispatcher",
                                          cfg->task_stack,
                                          impl,
                                          cfg->task_prio,
                                          &impl->task_handle,
                                          cfg->task_core)) {
        ESP_LOGE(TAG, "Create task failed on %s", __func__);
        goto _failed;
    }
    return impl;
_failed:
    if (impl->result_que) {
        vQueueDelete(impl->result_que);
        impl->result_que = NULL;
    }
    if (impl->exe_que) {
        vQueueDelete(impl->exe_que);
        impl->exe_que = NULL;
    }
    if (impl->mutex) {
        mutex_destroy(impl->mutex);
        impl->mutex = NULL;
    }
    audio_free(impl);
    impl = NULL;
    return impl;
}
```


Overlapping Code:
```
_dispatcher_handle_t esp_dispatcher_create(esp_dispatcher_config_t *cfg)
{
AUDIO_NULL_CHECK(TAG, cfg, return NULL);
esp_dispatcher_handle_t impl = audio_calloc(1, sizeof(esp_dispatcher_t));
AUDIO_MEM_CHECK(TAG, impl, return NULL);
impl->result_que = xQueueCreate(1, sizeof(action_result_t));
AUDIO_MEM_CHECK(TAG, impl->result_que, goto _failed;);
impl->exe_que = xQueueCreate(ESP_DISPATCHER_EVENT_SIZE, sizeof(esp_dispatcher_info_t));
AUDIO_MEM_CHECK(TAG, impl->exe_que, goto _failed;);
impl->mutex = mutex_create();
AUDIO_MEM_CHECK(TAG, impl->mutex, goto _failed;);
STAILQ_INIT(&impl->exe_list);
ESP_LOGE(TAG, "exe first list: %p", STAILQ_FIRST(&impl->exe_list));
if (pdPASS != xTaskCreatePinnedToCore(dispatcher_event_task,
"esp_dispatcher",
cfg->task_stack,
impl,
cfg->task_prio,
&impl->task_handle,
cfg->task_core)) {
ESP_LOGE(TAG, "Create task failed on %s", __func__);
goto _failed;
}
return impl;
_failed:
if (impl->result_que) {
vQueueDelete(impl->result_que);
impl->result_que = NULL;
}
if (impl->exe_que) {
vQueueDelete(impl->exe_que);
impl->exe_que = NULL;
}
if (impl->mutex) {
mutex_destroy(impl->mutex);
impl->mutex = NULL;
}
audio_free(impl);
impl = NULL;
return
```
<Overlap Ratio: 0.9907329401853412>

---

--- 53 --
Question ID: 21edb0b3a842755d49ee060da137a469580d7757_0
Original Code:
```
int calInitSerial(char *dev) {

  /* Open up the serial port */
  int fd = open(dev, O_NONBLOCK);

  if (fd <= 0) {
    perror("open serial");
    return(-1);
  }

  tcgetattr(fd, &ios_saved);
  ios_current = ios_saved;

  cfmakeraw(&ios_current);

  /* Set the baud rate */

  cfsetispeed(&ios_current, B2400);  
  cfsetospeed(&ios_current, B2400);
  
  /* Set the data bits and remove the parity */
  ios_current.c_cflag &= ~(CSIZE | PARENB);
  ios_current.c_cflag |= CS8;

  ios_current.c_cc[VMIN] = 3;
  ios_current.c_cc[VTIME] = 1;

  tcsetattr(fd, TCSANOW, &ios_current);
  tcflush(fd, TCIOFLUSH);
  
  return(fd);
}
```


Overlapping Code:
```
 the serial port */
int fd = open(dev, O_NONBLOCK);
if (fd <= 0) {
perror("open serial");
return(-1);
}
tcgetattr(fd, &ios_saved);
ios_current = ios_saved;
cfmakeraw(&ios_current);
/* Set the baud rate */
cfsetispeed(&ios_current, B2400); 
cfsetospeed(&ios_current, B2400);

/* Set the data bits and remove the parity */
ios_current.c_cflag &= ~(CSIZE | PARENB);
ios_current.c_cflag |= CS8;
ios_current.c_cc[VMIN] = 3;
ios_current.c_cc[VTIME] = 1;
tcsetattr(fd, TCSANOW, &ios_current);
tcflush(fd, TC
```
<Overlap Ratio: 0.8849557522123894>

---

--- 54 --
Question ID: 53f99301fb6b3c1782bd568d7798c8cdf94db142_1
Original Code:
```
ssize_t vsnprintfrr(char *out, size_t outsz, const char *fmt, va_list ap)
{
	struct fbuf fbb = { .buf = out, .pos = out, .len = outsz - 1, };
	struct fbuf *fb = (out && outsz) ? &fbb : NULL;
	ssize_t ret;

	ret = vbprintfrr(fb, fmt, ap);
	if (fb)
		fb->pos[0] = '\0';
	return ret;
}
```


Overlapping Code:
```
ssize_t vsnprintfrr(char *out, size_t outsz, const char *fmt, va_list ap)
{
struct fbuf fbb = { .buf = out, .pos = out, .len = outsz - 1, };
struct fbuf *fb = (out && outsz) ? &fbb : NULL;
ssize_t ret;
ret = vbprintfrr(fb, fmt, ap);
if (fb)
fb->pos[0
```
<Overlap Ratio: 0.9157509157509157>

---

--- 55 --
Question ID: ca9e4756d9da32a93377996158d234ba218cb1c3_0
Original Code:
```
interface MPSGraphExecutionDescriptor : NSObject {

	BOOL _waitUntilCompleted;
	/*^block*/id _scheduledHandler;
	/*^block*/id _completionHandler;
	MPSGraphExecutable* _executable;

}
```


Overlapping Code:
```
GraphExecutionDescriptor : NSObject {
BOOL _waitUntilCompleted;
/*^block*/id _scheduledHandler;
/*^block*/id _completionHandler;
MPSGraphExecutable* _
```
<Overlap Ratio: 0.8522727272727273>

---

--- 56 --
Question ID: 36530c136fba8eeb361dbda7b8055f5439b39b0e_9
Original Code:
```
primFun(primEnRange) {                  /* derived range for enum type     */
    eval(primArg(1));                   /* :: (a,a) -> [a]                 */
    updapRoot(ap(nameEnFrTo,primArg(3)),primArg(2));
}
```


Overlapping Code:
```
 derived range for enum type */
eval(primArg(1)); /* :: (a,a) -> [a] */
updapRoot(ap(nameEnFrTo,prim
```
<Overlap Ratio: 0.6802721088435374>

---

--- 57 --
Question ID: 9e67f816f2b8e29c647d60577b1716b4bb9948e0_1
Original Code:
```
void updateTimers() {
    static clock_t lastUser = 0;
    clock_t curr;
    curr        = clock();
    userElapsed = curr - lastUser;
    lastUser    = curr;
}
```


Overlapping Code:
```
User = 0;
clock_t curr;
curr = clock();
userElapse
```
<Overlap Ratio: 0.38461538461538464>

---

--- 58 --
Question ID: 3c39e2b8b54758a414f470b4eda4ba423ce4dea6_8
Original Code:
```
static int
add_uuid(char *keyname, TSS_UUID *uu)
{
	FILE *fp = NULL;
	char fname[MAXPATHLEN];
	char idstr[BUFSIZ];
	uuid_t uuid;
	char *p = get_tpm_keystore_path();

	if (p == NULL)
		return (-1);

	tss_uuid_convert_from(uu, uuid);

	if (uuid_is_null(uuid))
		return (-1);

	uuid_unparse(uuid, idstr);

	(void) snprintf(fname, sizeof (fname),
	    "%s/%s", p, TPMTOK_UUID_INDEX_FILENAME);

	fp = fopen(fname, "a");
	if (fp == NULL)
		return (-1);

	(void) fprintf(fp, "%s %s\n", keyname, idstr);
	(void) fclose(fp);

	return (0);
}
```


Overlapping Code:
```
TSS_UUID *uu)
{
FILE *fp = NULL;
char fname[MAXPATHLEN];
char idstr[BUFSIZ];
uuid_t uuid;
char *p = get_tpm_keystore_path();
if (p == NULL)
return (-1);
tss_uuid_convert_from(uu, uuid);
if (uuid_is_null(uuid))
return (-1);
uuid_unparse(uuid, idstr);
(void) snprintf(fname, sizeof (fname),
"%s/%s", p, TPMTOK_UUID_INDEX_FILENAME);
fp = fopen(fname, "a");
if (fp == NULL)
return (-1);
(void) fprintf(fp, "%s %s\n", keyname, idstr);
(void) fclose(fp);
r
```
<Overlap Ratio: 0.9054325955734407>

---

--- 59 --
Question ID: 643f4a2b85468613b9279ddf6eadb10c5fcd77c6_5
Original Code:
```
uint8_t* hex2bin(const char *hexstr, size_t *size)
{
  size_t hexstr_len = strlen(hexstr);
  size_t bytes_len = hexstr_len / 2;

  uint8_t* bytes = (uint8_t*)malloc(bytes_len);
  int count = 0;
  const char* pos = hexstr;

  for (count = 0; count < bytes_len; count++)
  {
    sscanf(pos, "%2hhx", &bytes[count]);
    pos += 2;
  }

  if (size != NULL)
  {
    *size = bytes_len;
  }

  return bytes;
}
```


Overlapping Code:
```
 hex2bin(const char *hexstr, size_t *size)
{
size_t hexstr_len = strlen(hexstr);
size_t bytes_len = hexstr_len / 2;
uint8_t* bytes = (uint8_t*)malloc(bytes_len);
int count = 0;
const char* pos = hexstr;
for (count = 0; count < bytes_len; count++)
{
sscanf(pos, "%2hhx", &bytes[count]);
pos += 2;
}
if (size != NULL)
{
*size = bytes_len;
}
return byte
```
<Overlap Ratio: 0.9668508287292817>

---

--- 60 --
Question ID: d6ba104358a3ba67e3699c641433a8b609a07502_5
Original Code:
```
void show_ospf_neighbors (uii_connection_t *uii) {
  ospf_interface_t *ospf_interface;
  ospf_neighbor_t *neighbor;


  uii_add_bulk_output (uii, "%-15s %-8s %-15s   %s\r\n", 
		       "Neighbor ID", "State", "Address", "Interface");
  
  LL_Iterate (OSPF.ll_ospf_interfaces, ospf_interface) {
    
    LL_Iterate (ospf_interface->ll_neighbors, neighbor) {
      uii_add_bulk_output (uii, "%-15s %-8s %-15s   %s\r\n", 
			   long_inet_ntoa (neighbor->neighbor_id), 
			   ospf_states[neighbor->state],
			   prefix_toa (neighbor->prefix),
			   ospf_interface->interface->name);
    }
  }
  uii_send_bulk_data (uii); 
}
```


Overlapping Code:
```
ii_connection_t *uii) {
ospf_interface_t *ospf_interface;
ospf_neighbor_t *neighbor;
uii_add_bulk_output (uii, "%-15s %-8s %-15s %s\r\n", 
"Neighbor ID", "State", "Address", "Interface");

LL_Iterate (OSPF.ll_ospf_interfaces, ospf_interface) {

LL_Iterate (ospf_interface->ll_neighbors, neighbor) {
uii_add_bulk_output (uii, "%-15s %-8s %-15s %s\r\n", 
long_inet_ntoa (neighbor->neighbor_id), 
ospf_states[neighbor->state],
prefix_toa (neighbor->prefix),
ospf_interface->interface->name);
}
}
uii_sen
```
<Overlap Ratio: 0.9124087591240876>

---

--- 61 --
Question ID: 3e52235862a4390096b4cd7dac925bd99235a160_10
Original Code:
```
void* VG_(HT_Next)(VgHashTable *table)
{
   Int i;
   vg_assert(table);
   /* See long comment on HT_Next prototype in pub_tool_hashtable.h.
      In short if this fails, it means the caller tried to modify the
      table whilst iterating over it, which is a bug. */
   vg_assert(table->iterOK);

   if (table->iterNode && table->iterNode->next) {
      table->iterNode = table->iterNode->next;
      return table->iterNode;
   }

   for (i = table->iterChain; i < table->n_chains; i++) {
      if (table->chains[i]) {
         table->iterNode  = table->chains[i];
         table->iterChain = i + 1;  // Next chain to be traversed
         return table->iterNode;
      }
   }
   return NULL;
}
```


Overlapping Code:
```
ashTable *table)
{
Int i;
vg_assert(table);
/* See long comment on HT_Next prototype in pub_tool_hashtable.h.
In short if this fails, it means the caller tried to modify the
table whilst iterating over it, which is a bug. */
vg_assert(table->iterOK);
if (table->iterNode && table->iterNode->next) {
table->iterNode = table->iterNode->next;
return table->iterNode;
}
for (i = table->iterChain; i < table->n_chains; i++) {
if (table->chains[i]) {
table->iterNode = table->chains[i];
table->iterChain = i + 1; // Next chain to be traversed
return table->iter
```
<Overlap Ratio: 0.9234608985024958>

---

--- 62 --
Question ID: 56353b08ef28c654869b54f8c505099b1fef3bd7_2
Original Code:
```
INT32 IGD_get_SpecificPortMapping_entry(INOUT struct action_event *event)
{
    struct device_and_service_index *pIndex = NULL;
    CHAR internalPort[MAX_NUM_TO_STR_LEN], leaseTime[MAX_NUM_TO_STR_LEN];
    IGD_PortMapping_Entry portmapEntry;
    PORT_MAP_INDEX portmapIndex;
    struct in_addr addr;
    INT32 ret;

    PAL_XML2S_TABLE tableSpecPorMap[] = {
        {PM_SET[REMOTE_HOST],    PAL_XML2S_STRING, XML2S_MSIZE(PORT_MAP_INDEX, remoteHost),  NULL, MASK_OF_INDEX_REMOTE_HOST},
        {PM_SET[EXTERNAL_PORT], PAL_XML2S_UINT16,  XML2S_MSIZE(PORT_MAP_INDEX, externalPort), NULL, MASK_OF_INDEX_EXTERNAL_PORT},
        {PM_SET[PROTOCOL],         PAL_XML2S_STRING,  XML2S_MSIZE(PORT_MAP_INDEX, pmProtocol),  NULL, MASK_OF_INDEX_PROTOCOL},
        XML2S_TABLE_END
    };
    pal_string_pair response[PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM] = {
        { PM_SET[INTERNAL_PORT] ,                     NULL },
        { PM_SET[INTERNAL_CLIENT] ,                  NULL },
        { PM_SET[ENABLED] ,                               NULL },
        { PM_SET[PORTMAPPING_DESCRIPTION] , NULL },
        { PM_SET[LEASE_DURATION] ,                  NULL }
    };
    
    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, "ENTER %s...", __func__);

    if (!event || !(event->request)) 
    {
        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_WARNING, "Input parameter error");

        ret = IGD_GENERAL_ERROR;
        return ret;
    }

    pIndex = (struct device_and_service_index *)(event->service->private);
    if (NULL == pIndex) {
        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "pIndex is NULL");

        ret = PAL_UPNP_SOAP_E_ACTION_FAILED;
        event->request->error_code = ret;
        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_ACTION_FAILED), PAL_UPNP_LINE_SIZE);

        return ret;
    }
    
    bzero(&portmapIndex, sizeof(portmapIndex));
    ret = PAL_xml2s_process(event->request->action_request, tableSpecPorMap, &portmapIndex);

    if (ret < 0){
        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "PAL_xml2s_process error");

        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;
        event->request->error_code = ret;
        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);
    } else if ((portmapIndex.remoteHost != NULL)
                &&(0 == inet_pton(AF_INET, portmapIndex.remoteHost, &addr))){ 
        PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, "remoteHost format error: x.x.x.x");

        ret = PAL_UPNP_SOAP_E_INVALID_ARGS;
        event->request->error_code = ret;
        strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);
    } else {
        bzero(&portmapEntry, sizeof(portmapEntry));
        if(portmapIndex.remoteHost != NULL)
        {
            strncpy(portmapEntry.remoteHost, portmapIndex.remoteHost, IPV4_ADDR_LEN);
        }
        portmapEntry.externalPort = portmapIndex.externalPort;
        if(portmapIndex.pmProtocol != NULL)
        {
            strncpy(portmapEntry.protocol, portmapIndex.pmProtocol, PORT_MAP_PROTOCOL_LEN);
        }

        ret = IGD_pii_get_portmapping_entry_specific(pIndex->wan_device_index,
                                 pIndex->wan_connection_device_index,
                                 pIndex->wan_connection_service_index,
                                 (strcmp(WAN_IP_CONNECTION_SERVICE_TYPE,event->service->type) == 0) ? SERVICETYPE_IP : SERVICETYPE_PPP,
                                 &portmapEntry);
        if(ret == 0)
        {
            event->request->error_code = PAL_UPNP_E_SUCCESS;

            snprintf(internalPort, MAX_NUM_TO_STR_LEN, "%d", portmapEntry.internalPort);
            response[INTERNAL_PORT - PORTMAP_INDEX_FIELD_NUM].value = internalPort;

            response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.internalClient);

            if(portmapEntry.enabled == BOOL_TRUE)
            {
                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = "1";
            } else {
                response[ENABLED - PORTMAP_INDEX_FIELD_NUM].value = "0";
            }
            
            response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value = strdup(portmapEntry.description);

            snprintf(leaseTime, MAX_NUM_TO_STR_LEN, "%d", portmapEntry.leaseTime);
            response[LEASE_DURATION - PORTMAP_INDEX_FIELD_NUM].value = leaseTime;
            
            ret = PAL_upnp_make_action(&(event->request->action_result), event->request->action_name, event->service->type, 
                                            PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM, response, PAL_UPNP_ACTION_RESPONSE);
            if(ret != PAL_UPNP_E_SUCCESS)
            {
                PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "PAL_upnp_make_action error");

                event->request->error_code = ret;
                event->request->action_result = NULL;
            }
            
            if(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value)
            {
                free(response[INTERNAL_CLIENT - PORTMAP_INDEX_FIELD_NUM].value);
            }
            if(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value)
            {
                free(response[PORTMAPPING_DESCRIPTION - PORTMAP_INDEX_FIELD_NUM].value);
            }
            
        } else {
            PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "IGD_pii_get_portmapping_entry_specific error");

            ret = NO_SUCH_ENTRY_IN_ARRAY;
            event->request->error_code = ret;
            strncpy(event->request->error_str, NO_SUCH_ENTRY_IN_ARRAY_STR, sizeof(NO_SUCH_ENTRY_IN_ARRAY_STR)+1);
        }
        
        PAL_xml2s_free(&portmapIndex, tableSpecPorMap);
    }

    PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, "EXIT %s...", __func__);

    return ret;
}
```


Overlapping Code:
```
_SpecificPortMapping_entry(INOUT struct action_event *event)
{
struct device_and_service_index *pIndex = NULL;
CHAR internalPort[MAX_NUM_TO_STR_LEN], leaseTime[MAX_NUM_TO_STR_LEN];
IGD_PortMapping_Entry portmapEntry;
PORT_MAP_INDEX portmapIndex;
struct in_addr addr;
INT32 ret;
PAL_XML2S_TABLE tableSpecPorMap[] = {
{PM_SET[REMOTE_HOST], PAL_XML2S_STRING, XML2S_MSIZE(PORT_MAP_INDEX, remoteHost), NULL, MASK_OF_INDEX_REMOTE_HOST},
{PM_SET[EXTERNAL_PORT], PAL_XML2S_UINT16, XML2S_MSIZE(PORT_MAP_INDEX, externalPort), NULL, MASK_OF_INDEX_EXTERNAL_PORT},
{PM_SET[PROTOCOL], PAL_XML2S_STRING, XML2S_MSIZE(PORT_MAP_INDEX, pmProtocol), NULL, MASK_OF_INDEX_PROTOCOL},
XML2S_TABLE_END
};
pal_string_pair response[PORTMAP_ENTRY_FIELD_NUM - PORTMAP_INDEX_FIELD_NUM] = {
{ PM_SET[INTERNAL_PORT] , NULL },
{ PM_SET[INTERNAL_CLIENT] , NULL },
{ PM_SET[ENABLED] , NULL },
{ PM_SET[PORTMAPPING_DESCRIPTION] , NULL },
{ PM_SET[LEASE_DURATION] , NULL }
};

PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_DEBUG, "ENTER %s...", __func__);
if (!event || !(event->request)) 
{
PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_WARNING, "Input parameter error");
ret = IGD_GENERAL_ERROR;
return ret;
}
pIndex = (struct device_and_service_index *)(event->service->private);
if (NULL == pIndex) {
PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "pIndex is NULL");
ret = PAL_UPNP_SOAP_E_ACTION_FAILED;
event->request->error_code = ret;
strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_ACTION_FAILED), PAL_UPNP_LINE_SIZE);
return ret;
}

bzero(&portmapIndex, sizeof(portmapIndex));
ret = PAL_xml2s_process(event->request->action_request, tableSpecPorMap, &portmapIndex);
if (ret < 0){
PAL_LOG(WAN_CONNECTION_DEVICE_LOG_NAME, PAL_LOG_LEVEL_FAILURE, "PAL_xml2s_process error");
ret = PAL_UPNP_SOAP_E_INVALID_ARGS;
event->request->error_code = ret;
strncpy(event->request->error_str, PAL_upnp_get_error_message(PAL_UPNP_SOAP_E_INVALID_ARGS), PAL_UPNP_LINE_SIZE);
} else if ((portmapIndex.remoteHost != NULL)
&&(0 == inet_pto
```
<Overlap Ratio: 0.9724857685009488>

---

--- 63 --
Question ID: bcefe12c85aa5cab1fb3f3a2222dd4f570b15a6d_22
Original Code:
```
JNICALL
Java_hdf_hdf5lib_H5_H5DreadVL
    (JNIEnv *env, jclass clss, jlong dataset_id, jlong mem_type_id, jlong mem_space_id,
          jlong file_space_id, jlong xfer_plist_id, jobjectArray buf)
{
    H5T_class_t type_class;
    htri_t      isStr = 0;
    htri_t      isVlenStr = 0;
    htri_t      isComplex = 0;
    htri_t      isComplex2 = 0;
    hid_t       nested_tid = H5I_INVALID_HID;
    herr_t      status = FAIL;

    UNUSED(clss);

    if (NULL == buf)
        H5_NULL_ARGUMENT_ERROR(ENVONLY, "H5DreadVL: read buffer is NULL");

    if ((isStr = H5Tdetect_class((hid_t)mem_type_id, H5T_STRING)) < 0)
        H5_LIBRARY_ERROR(ENVONLY);

    if ((type_class = H5Tget_class((hid_t)mem_type_id)) < 0)
        H5_LIBRARY_ERROR(ENVONLY);

    if (type_class == H5T_COMPOUND) {
        unsigned i;
        int      num_members;

        if ((num_members = H5Tget_nmembers(mem_type_id)) < 0)
            H5_LIBRARY_ERROR(ENVONLY);

        for (i = 0; i < (unsigned) num_members; i++) {
            if ((nested_tid = H5Tget_member_type((hid_t)mem_type_id, i)) < 0)
                H5_LIBRARY_ERROR(ENVONLY);

            if ((isComplex = H5Tdetect_class((hid_t)nested_tid, H5T_COMPOUND)) < 0)
                H5_LIBRARY_ERROR(ENVONLY);

            if ((isComplex2 = H5Tdetect_class((hid_t)nested_tid, H5T_VLEN)) < 0)
                H5_LIBRARY_ERROR(ENVONLY);

            isComplex = isComplex || isComplex2;

            if (H5Tclose(nested_tid) < 0)
                H5_LIBRARY_ERROR(ENVONLY);
            nested_tid = H5I_INVALID_HID;
        }
    }
    else if (type_class == H5T_VLEN) {
        isVlenStr = 1; /* Strings created by H5Tvlen_create(H5T_C_S1) */
    }

    if (!isStr || isComplex || isVlenStr) {
        if ((status = H5DreadVL_asstr(env, (hid_t)dataset_id, (hid_t)mem_type_id,
                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)
            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);
    }
    else if (isStr) {
        if ((status = H5DreadVL_str(env, (hid_t)dataset_id, (hid_t)mem_type_id,
                (hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)
            CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);
    }

done:
    if (nested_tid >= 0)
        H5Tclose(nested_tid);

    return (jint)status;
}
```


Overlapping Code:
```
L
(JNIEnv *env, jclass clss, jlong dataset_id, jlong mem_type_id, jlong mem_space_id,
jlong file_space_id, jlong xfer_plist_id, jobjectArray buf)
{
H5T_class_t type_class;
htri_t isStr = 0;
htri_t isVlenStr = 0;
htri_t isComplex = 0;
htri_t isComplex2 = 0;
hid_t nested_tid = H5I_INVALID_HID;
herr_t status = FAIL;
UNUSED(clss);
if (NULL == buf)
H5_NULL_ARGUMENT_ERROR(ENVONLY, "H5DreadVL: read buffer is NULL");
if ((isStr = H5Tdetect_class((hid_t)mem_type_id, H5T_STRING)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
if ((type_class = H5Tget_class((hid_t)mem_type_id)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
if (type_class == H5T_COMPOUND) {
unsigned i;
int num_members;
if ((num_members = H5Tget_nmembers(mem_type_id)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
for (i = 0; i < (unsigned) num_members; i++) {
if ((nested_tid = H5Tget_member_type((hid_t)mem_type_id, i)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
if ((isComplex = H5Tdetect_class((hid_t)nested_tid, H5T_COMPOUND)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
if ((isComplex2 = H5Tdetect_class((hid_t)nested_tid, H5T_VLEN)) < 0)
H5_LIBRARY_ERROR(ENVONLY);
isComplex = isComplex || isComplex2;
if (H5Tclose(nested_tid) < 0)
H5_LIBRARY_ERROR(ENVONLY);
nested_tid = H5I_INVALID_HID;
}
}
else if (type_class == H5T_VLEN) {
isVlenStr = 1; /* Strings created by H5Tvlen_create(H5T_C_S1) */
}
if (!isStr || isComplex || isVlenStr) {
if ((status = H5DreadVL_asstr(env, (hid_t)dataset_id, (hid_t)mem_type_id,
(hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)
CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);
}
else if (isStr) {
if ((status = H5DreadVL_str(env, (hid_t)dataset_id, (hid_t)mem_type_id,
(hid_t)mem_space_id, (hid_t)file_space_id, (hid_t)xfer_plist_id, buf)) < 0)
CHECK_JNI_EXCEPTION(ENVONLY, JNI_FALSE);
}
done:
if (nested_tid >= 0)
H5Tclose(nested_tid);
return (ji
```
<Overlap Ratio: 0.9740400216333153>

---

--- 64 --
Question ID: 36039b9fd05a764265a177ddc6da1df28ac69f54_38
Original Code:
```
static void compileTryExcept(Compiler* c, JStarStmt* s) {
    bool hasExcept = !vecEmpty(&s->as.tryStmt.excs);
    bool hasEnsure = s->as.tryStmt.ensure != NULL;
    int numHandlers = (hasExcept ? 1 : 0) + (hasEnsure ? 1 : 0);

    TryExcept tryBlock;
    enterTryBlock(c, &tryBlock, numHandlers);

    if(c->tryDepth > MAX_TRY_DEPTH) {
        error(c, s->line, "Exceeded max number of nested try blocks: %d.", MAX_TRY_DEPTH);
    }

    size_t ensSetup = 0, excSetup = 0;

    if(hasEnsure) {
        ensSetup = emitBytecode(c, OP_SETUP_ENSURE, s->line);
        emitShort(c, 0, 0);
    }

    if(hasExcept) {
        excSetup = emitBytecode(c, OP_SETUP_EXCEPT, s->line);
        emitShort(c, 0, 0);
    }

    compileStatement(c, s->as.tryStmt.block);

    if(hasExcept) {
        emitBytecode(c, OP_POP_HANDLER, s->line);
    }

    if(hasEnsure) {
        emitBytecode(c, OP_POP_HANDLER, s->line);
        // Reached end of try block during normal execution flow, set exception and unwind
        // cause to null to signal the ensure handler that no exception was raised
        emitBytecode(c, OP_NULL, s->line);
        emitBytecode(c, OP_NULL, s->line);
    }

    enterScope(c);

    JStarIdentifier exc = createIdentifier(".exception");
    declareVar(c, &exc, 0);
    defineVar(c, &exc, 0);

    JStarIdentifier cause = createIdentifier(".cause");
    declareVar(c, &cause, 0);
    defineVar(c, &cause, 0);

    if(hasExcept) {
        size_t excJmp = emitBytecode(c, OP_JUMP, 0);
        emitShort(c, 0, 0);

        setJumpTo(c, excSetup, getCurrentAddr(c), s->line);
        compileExcepts(c, &s->as.tryStmt.excs, 0);

        if(hasEnsure) {
            emitBytecode(c, OP_POP_HANDLER, 0);
        } else {
            emitBytecode(c, OP_END_HANDLER, 0);
            exitScope(c);
        }

        setJumpTo(c, excJmp, getCurrentAddr(c), 0);
    }

    if(hasEnsure) {
        setJumpTo(c, ensSetup, getCurrentAddr(c), s->line);
        compileStatement(c, s->as.tryStmt.ensure);
        emitBytecode(c, OP_END_HANDLER, 0);
        exitScope(c);
    }

    exitTryBlock(c, numHandlers);
}
```


Overlapping Code:
```
mt* s) {
bool hasExcept = !vecEmpty(&s->as.tryStmt.excs);
bool hasEnsure = s->as.tryStmt.ensure != NULL;
int numHandlers = (hasExcept ? 1 : 0) + (hasEnsure ? 1 : 0);
TryExcept tryBlock;
enterTryBlock(c, &tryBlock, numHandlers);
if(c->tryDepth > MAX_TRY_DEPTH) {
error(c, s->line, "Exceeded max number of nested try blocks: %d.", MAX_TRY_DEPTH);
}
size_t ensSetup = 0, excSetup = 0;
if(hasEnsure) {
ensSetup = emitBytecode(c, OP_SETUP_ENSURE, s->line);
emitShort(c, 0, 0);
}
if(hasExcept) {
excSetup = emitBytecode(c, OP_SETUP_EXCEPT, s->line);
emitShort(c, 0, 0);
}
compileStatement(c, s->as.tryStmt.block);
if(hasExcept) {
emitBytecode(c, OP_POP_HANDLER, s->line);
}
if(hasEnsure) {
emitBytecode(c, OP_POP_HANDLER, s->line);
// Reached end of try block during normal execution flow, set exception and unwind
// cause to null to signal the ensure handler that no exception was raised
emitBytecode(c, OP_NULL, s->line);
emitBytecode(c, OP_NULL, s->line);
}
enterScope(c);
JStarIdentifier exc = createIdentifier(".exception");
declareVar(c, &exc, 0);
defineVar(c, &exc, 0);
JStarIdentifier cause = createIdentifier(".cause");
declareVar(c, &cause, 0);
defineVar(c, &cause, 0);
if(hasExcept) {
size_t excJmp = emitBytecode(c, OP_JUMP, 0);
emitShort(c, 0, 0);
setJumpTo(c, excSetup, getCurrentAddr(c), s->line);
compileExcepts(c, &s->as.tryStmt.excs, 0);
if(hasEnsure) {
emitBytecode(c, OP_POP_HANDLER, 0);
} else {
emitBytecode(c, OP_END_HANDLER, 0);
exitScope(c);
}
setJumpTo(c, excJmp, getCurrentAddr(c), 0);
}
if(hasEnsure) {
setJumpTo(c, ensSetup, getCurrentAddr(c), s->line);
compileStatement(c, s->as.tryStmt.ensure);
emitBytecode(c, OP_END_HANDLER, 0);
exitScope(c);
}
exitTryBlock(c, numHandlers
```
<Overlap Ratio: 0.9697661152310325>

---

--- 65 --
Question ID: aca3a427f1d7e0a0022f835887d1461defcee09f_10
Original Code:
```
struct value *
lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,
				 const char *func_name, SCM *except_scmp)
{
  lazy_string_smob *ls_smob;
  struct value *value = NULL;

  gdb_assert (lsscm_is_lazy_string (string));

  ls_smob = (lazy_string_smob *) SCM_SMOB_DATA (string);

  if (ls_smob->address == 0)
    {
      *except_scmp
	= gdbscm_make_out_of_range_error (func_name, arg_pos, string,
					 _("cannot create a value from NULL"));
      return NULL;
    }

  try
    {
      struct type *type = tyscm_scm_to_type (ls_smob->type);
      struct type *realtype = check_typedef (type);

      switch (realtype->code ())
	{
	case TYPE_CODE_PTR:
	  /* If a length is specified we need to convert this to an array
	     of the specified size.  */
	  if (ls_smob->length != -1)
	    {
	      /* PR 20786: There's no way to specify an array of length zero.
		 Record a length of [0,-1] which is how Ada does it.  Anything
		 we do is broken, but this one possible solution.  */
	      type = lookup_array_range_type (TYPE_TARGET_TYPE (realtype),
					      0, ls_smob->length - 1);
	      value = value_at_lazy (type, ls_smob->address);
	    }
	  else
	    value = value_from_pointer (type, ls_smob->address);
	  break;
	default:
	  value = value_at_lazy (type, ls_smob->address);
	  break;
	}
    }
  catch (const gdb_exception &except)
    {
      *except_scmp = gdbscm_scm_from_gdb_exception (unpack (except));
      return NULL;
    }

  return value;
}
```


Overlapping Code:
```
struct value *
lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,
const char *func_name, SCM *except_scmp)
{
lazy_string_smob *ls_smob;
struct value *value = NULL;
gdb_assert (lsscm_is_lazy_string (string));
ls_smob = (lazy_string_smob *) SCM_SMOB_DATA (string);
if (ls_smob->address == 0)
{
*except_scmp
= gdbscm_make_out_of_range_error (func_name, arg_pos, string,
_("cannot create a value from NULL"));
return NULL;
}
try
{
struct type *type = tyscm_scm_to_type (ls_smob->type);
struct type *realtype = check_typedef (type);
switch (realtype->code ())
{
case TYPE_CODE_PTR:
/* If a length is specified we need to convert this to an array
of the specified size. */
if (ls_smob->length != -1)
{
/* PR 20786: There's no way to specify an array of length zero.
Record a length of [0,-1] which is how Ada does it. Anything
we do is broken, but this one possible solution. */
type = lookup_array_range_type (TYPE_TARGET_TYPE (realtype),
0, ls_smob->length - 1);
value = value_at_lazy (type, ls_smob->address);
}
else
value = value_from_pointer (type, ls_smob->address);
break;
default:
value = value_at_lazy (type, ls_smob->address);
break;
}
}
catch (const gdb_exception &except)
{
*except_scmp = gdbscm_scm_from_gdb_exception (unpack (except));
```
<Overlap Ratio: 0.975800156128025>

---

--- 66 --
Question ID: 1b83500774415b77d7992633b11af900c7be6997_0
Original Code:
```
static tap_packet_status
frame_seq_analysis_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)
{
	seq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;
	seq_analysis_item_t *sai = sequence_analysis_create_sai_with_addresses(pinfo, sainfo);

	if (!sai)
		return TAP_PACKET_DONT_REDRAW;

	sai->frame_number = pinfo->num;

	sequence_analysis_use_color_filter(pinfo, sai);

	sai->port_src=pinfo->srcport;
	sai->port_dst=pinfo->destport;

	sequence_analysis_use_col_info_as_label_comment(pinfo, sai);

	sai->line_style = 1;
	sai->conv_num = 0;
	sai->display = TRUE;

	g_queue_push_tail(sainfo->items, sai);

	return TAP_PACKET_REDRAW;
}
```


Overlapping Code:
```
q_analysis_packet( void *ptr, packet_info *pinfo, epan_dissect_t *edt _U_, const void *dummy _U_)
{
seq_analysis_info_t *sainfo = (seq_analysis_info_t *) ptr;
seq_analysis_item_t *sai = sequence_analysis_create_sai_with_addresses(pinfo, sainfo);
if (!sai)
return TAP_PACKET_DONT_REDRAW;
sai->frame_number = pinfo->num;
sequence_analysis_use_color_filter(pinfo, sai);
sai->port_src=pinfo->srcport;
sai->port_dst=pinfo->destport;
sequence_analysis_use_col_info_as_label_comment(pinfo, sai);
sai->line_style = 1;
sai->conv_num = 0;
sai->display = TRUE;
g_queue_push_tail(sainfo->items, sai);
return TAP_
```
<Overlap Ratio: 0.9244992295839753>

---

--- 67 --
Question ID: ba8ff10153bcc656d6e1b1b6da7e9fd4f37720e4_12
Original Code:
```
static int intel_i830_remove_entries(struct agp_memory *mem,off_t pg_start,
				int type)
{
	int i;

	global_cache_flush();

	if (pg_start < intel_i830_private.gtt_entries) {
		printk (KERN_INFO PFX "Trying to disable local/stolen memory\n");
		return (-EINVAL);
	}

	for (i = pg_start; i < (mem->page_count + pg_start); i++)
		OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);

	global_cache_flush();

	agp_bridge->driver->tlb_flush(mem);

	return (0);
}
```


Overlapping Code:
```
static int intel_i830_remove_entries(struct agp_memory *mem,off_t pg_start,
int type)
{
int i;
global_cache_flush();
if (pg_start < intel_i830_private.gtt_entries) {
printk (KERN_INFO PFX "Trying to disable local/stolen memory\n");
return (-EINVAL);
}
for (i = pg_start; i < (mem->page_count + pg_start); i++)
OUTREG32(intel_i830_private.registers,I810_PTE_BASE + (i * 4),agp_bridge->scratch_page);
global_cache_flush();
agp_bridge->driver->tlb_flush(mem);
return 
```
<Overlap Ratio: 0.9872340425531915>

---

--- 68 --
Question ID: 2e2d6c34c08ca648b6bc7347e61fddbc34bb3497_48
Original Code:
```
static inline h5_err_t
hdf5_get_mdc_property (
        hid_t fapl_id,
        H5AC_cache_config_t *config
        ) {
	HDF5_WRAPPER_ENTER (h5_err_t,
			    "fapl_id=%lld, config=%p",
			    (long long int)fapl_id, config);
	if (H5Pget_mdc_config (fapl_id, config) < 0)
		H5_RETURN_ERROR (
			H5_ERR_HDF5,
			"%s",
			"Cannot get metadata cache configuration in"
			" the file access property list.");
	H5_RETURN (H5_SUCCESS);
}
```


Overlapping Code:
```
d_t fapl_id,
H5AC_cache_config_t *config
) {
HDF5_WRAPPER_ENTER (h5_err_t,
"fapl_id=%lld, config=%p",
(long long int)fapl_id, config);
if (H5Pget_mdc_config (fapl_id, config) < 0)
H5_RETURN_ERROR (
H5_ERR_HDF5,
"%s",
"Cannot get metadata cache configuration in"
" the file access property list.");
H5_RETURN (H5_SUCCESS);
}
```
<Overlap Ratio: 0.8682795698924731>

---

--- 69 --
Question ID: d51cbb2beba3e1167f5be994f5891f433adb4b3e_3
Original Code:
```
void ReleaseAllRestartPoints( void )
{
    RESTART *   Object;
    RESTART *   NextUsedObject;

    if( !ENABLE_RESTART ) return;

    Object = FirstRestartUsed;

    while( Object != NULL )
    {
        NextUsedObject = Object->NextUsed;
        KillUsedRestartPoint( Object );
        Object = NextUsedObject;
    }
}
```


Overlapping Code:
```
tartPoints( void )
{
RESTART * Object;
RESTART * NextUsedObject;
if( !ENABLE_RESTART ) return;
Object = FirstRestartUsed;
while( Object != NULL )
{
NextUsedObject = Object->NextUsed;
KillUsedRestartPo
```
<Overlap Ratio: 0.7662835249042146>

---

--- 70 --
Question ID: 8dcb978e0e2274b9b184740e87e3522987396b64_16
Original Code:
```
int
hc_sock_reset(hc_sock_t * s)
{
    s->roff = s->woff = 0;
    s->remaining = 0;
     return 0;
}
```


Overlapping Code:
```
ck_reset(hc_sock_t * s)
{
s->roff = s->woff = 0;
s
```
<Overlap Ratio: 0.5747126436781609>

---

--- 71 --
Question ID: 9adc95cd0c96468f8f3a4b469a790afff6d28649_0
Original Code:
```
int fflush(FILE *fp)
{
	int ret = 0;
	size_t i = 0;
	/* fflush(NULL) flushes all fd */
	if (fp == NULL) {
		for (fp = stdout; i < FOPEN_MAX; ++fp, ++i) {
			if (fp->buf != NULL) {
				ret = __flushbuf(EOF, fp);
			}
		}
	}
	else if (fp->write == 1) {
		ret = __flushbuf(EOF, fp);
	}

	fp->len = BUFSIZ;
	if (fp->unbuf == 1)
		fp->len = 1;
	return ret;
}
```


Overlapping Code:
```
*fp)
{
int ret = 0;
size_t i = 0;
/* fflush(NULL) flushes all fd */
if (fp == NULL) {
for (fp = stdout; i < FOPEN_MAX; ++fp, ++i) {
if (fp->buf != NULL) {
ret = __flushbuf(EOF, fp);
}
}
}
else if (fp->write == 1) {
ret = __flushbuf(EOF, fp);
}
fp->len = BUFSIZ;
if (fp->unbuf == 1)
fp->len = 1;
retur
```
<Overlap Ratio: 0.9259259259259259>

---

--- 72 --
Question ID: b4954c0f4caee8423cf00319c933de9c5c1cee7b_4
Original Code:
```
void gl_transform_vb( GLcontext *ctx, GLboolean firstPartToDo, GLboolean allDone )
{
  struct vertex_buffer *VB = ctx->VB;
#ifdef MITS
  struct sched_param sparam1, sparam2, mparams;
#endif

#ifdef PROFILE
  GLdouble t0 = gl_time();
#endif

  ASSERT( VB->Count>0 );

#ifdef PROFILE
  ctx->VertexTime += gl_time() - t0;
  ctx->VertexCount += VB->Count - VB->Start;
#endif
  
  if ((ctx->Texture.Enabled || ctx->RenderMode==GL_FEEDBACK) &&
      ctx->NewTextureMatrix)
    gl_analyze_texture_matrix(ctx);

  if (ctx->Driver.RasterSetup && VB->Start) {
      (*ctx->Driver.RasterSetup)( ctx, 0, VB->Start );
  }

#ifdef MITS

  if (VB->Count > 72) {

    if( firsttime ) {

      int policy;
     

      if( !getuid() ) {
	policy = SCHED_FIFO;
      }
      else {
	policy = SCHED_OTHER;
      }


      mparams.sched_priority = sched_get_priority_max(policy) - 1;
      sched_setscheduler(0, policy, &mparams);

      sparam1.sched_priority = sched_get_priority_max(policy);
      sparam2.sched_priority = sched_get_priority_max(policy);


      sem_init( &tDone1, 0, 0);
      sem_init( &tDone2, 0, 0);	    


      /* Set up threads with OTHER policy and maximum priority */
      pthread_attr_init( &attr1 );
      pthread_attr_setscope( &attr1, PTHREAD_SCOPE_SYSTEM);
      pthread_attr_setschedpolicy( &attr1, policy );
      pthread_attr_setdetachstate( &attr1, PTHREAD_CREATE_DETACHED);
      pthread_attr_setschedparam( &attr1, &sparam1 );

      pthread_attr_init( &attr2 );
      pthread_attr_setscope( &attr2, PTHREAD_SCOPE_SYSTEM);
      pthread_attr_setschedpolicy( &attr2, policy );
      pthread_attr_setdetachstate( &attr2, PTHREAD_CREATE_DETACHED);
      pthread_attr_setschedparam( &attr2, &sparam2 );

      set1.thread_sem = &tDone1;
      set2.thread_sem = &tDone2;

      pthread_create( &thread1, &attr1, gl_transform_vb_range_scheduler, &set1);
      pthread_create( &thread2, &attr2, gl_transform_vb_range_scheduler, &set2); 
      firsttime = 0;

    } /* end if */


    set1.ctx = ctx;
    set1.start = VB->Start;
    set1.count = VB->Start + (VB->Count-VB->Start)/2;
    set1.firstPartToDo = firstPartToDo;


    set2.ctx = ctx;
    set2.start = VB->Start + (VB->Count - VB->Start)/2;
    set2.count = VB->Count;
    set2.firstPartToDo = firstPartToDo;
    
    set1.tsync = set2.tsync = 0;


    /* Wake the vertex buffer processing threads */
    sem_post( &tDone1 );
    sem_post( &tDone2 );
    sched_yield();


    /* Spin until both are done */
    while( !set1.tsync && !set2.tsync);


  }
  else {


    gl_transform_vb_range( ctx, VB->Start, VB->Count,
			 &VB->ClipOrMask, &VB->ClipAndMask,
			 firstPartToDo );

  } /* end if */

#else

    gl_transform_vb_range( ctx, VB->Start, VB->Count,
			 &VB->ClipOrMask, &VB->ClipAndMask,
			 firstPartToDo );

#endif

  if (VB->ClipAndMask) {
    gl_reset_vb( ctx, allDone );
    return;
  }


#ifdef PROFILE
  ctx->VertexTime += gl_time() - t0;
  ctx->VertexCount += VB->Count - VB->Start;
#endif

  /*
   * Now we're ready to rasterize the Vertex Buffer!!!
   *
   * If the device driver can't rasterize the vertex buffer then we'll
   * do it ourselves.
   */
  if (!ctx->Driver.RenderVB || !(*ctx->Driver.RenderVB)(ctx,allDone)) {
    gl_render_vb( ctx, allDone );
  }
}
```


Overlapping Code:
```
ransform_vb( GLcontext *ctx, GLboolean firstPartToDo, GLboolean allDone )
{
struct vertex_buffer *VB = ctx->VB;
#ifdef MITS
struct sched_param sparam1, sparam2, mparams;
#endif
#ifdef PROFILE
GLdouble t0 = gl_time();
#endif
ASSERT( VB->Count>0 );
#ifdef PROFILE
ctx->VertexTime += gl_time() - t0;
ctx->VertexCount += VB->Count - VB->Start;
#endif

if ((ctx->Texture.Enabled || ctx->RenderMode==GL_FEEDBACK) &&
ctx->NewTextureMatrix)
gl_analyze_texture_matrix(ctx);
if (ctx->Driver.RasterSetup && VB->Start) {
(*ctx->Driver.RasterSetup)( ctx, 0, VB->Start );
}
#ifdef MITS
if (VB->Count > 72) {
if( firsttime ) {
int policy;

if( !getuid() ) {
policy = SCHED_FIFO;
}
else {
policy = SCHED_OTHER;
}
mparams.sched_priority = sched_get_priority_max(policy) - 1;
sched_setscheduler(0, policy, &mparams);
sparam1.sched_priority = sched_get_priority_max(policy);
sparam2.sched_priority = sched_get_priority_max(policy);
sem_init( &tDone1, 0, 0);
sem_init( &tDone2, 0, 0); 
/* Set up threads with OTHER policy and maximum priority */
pthread_attr_init( &attr1 );
pthread_attr_setscope( &attr1, PTHREAD_SCOPE_SYSTEM);
pthread_attr_setschedpolicy( &attr1, policy );
pthread_attr_setdetachstate( &attr1, PTHREAD_CREATE_DETACHED);
pthread_attr_setschedparam( &attr1, &sparam1 );
pthread_attr_init( &attr2 );
pthread_attr_setscope( &attr2, PTHREAD_SCOPE_SYSTEM);
pthread_attr_setschedpolicy( &attr2, policy );
pthread_attr_setdetachstate( &attr2, PTHREAD_CREATE_DETACHED);
pthread_attr_setschedparam( &attr2, &sparam2 );
set1.thread_sem = &tDone1;
set2.thread_sem = &tDone2;
pthread_create( &thread1, &attr1, gl_transform_vb_range_scheduler, &set1);
pthread_create( &thread2, &attr2, gl_transform_vb_range_scheduler, &set2); 
firsttime = 0;
} /* end if */
set1.ctx = ctx;
set1.start = VB->Start;
set1.count = VB->Start + (VB->Count-VB->Start)/2;
set1.firstPartToDo = firstPartToDo;
set2.ctx = ctx;
set2.start = VB->Start + (VB->Count - VB->Start)/2;
set2.count = VB->Count;
set2.firstPartToDo = firstPartToDo;

set1.tsync = set2.tsync = 0;
/* Wake the vertex buffer processing threads */
sem_post( &tDone1 );
sem_post( &tDone2 );
sched_yield();
/* Spin until both
```
<Overlap Ratio: 0.9826325411334552>

---

--- 73 --
Question ID: d410b604d44f4612a87d05e26ed7352ca65fbd52_14
Original Code:
```
void DeleteCountdownDigits( void )
{
    DeleteDigit( &Min1Digit[ 0 ] );
    DeleteDigit( &Min0Digit[ 0 ] );
    DeleteSeperatorDigit( &Bit0Digit[ 0 ] );
    DeleteDigit( &Sec1Digit[ 0 ] );
    DeleteDigit( &Sec0Digit[ 0 ] );
    DeleteSeperatorDigit( &Bit1Digit[ 0 ] );
    DeleteDigit( &Hun1Digit[ 0 ] );
    DeleteDigit( &Hun0Digit[ 0 ] );
}
```


Overlapping Code:
```
untdownDigits( void )
{
DeleteDigit( &Min1Digit[ 0 ] );
DeleteDigit( &Min0Digit[ 0 ] );
DeleteSeperatorDigit( &Bit0Digit[ 0 ] );
DeleteDigit( &Sec1Digit[ 0 ] );
DeleteDigit( &Sec0Digit[ 0 ] );
DeleteSeperatorDigit( &Bit1Digit[ 0 ] );
DeleteDigit( &Hu
```
<Overlap Ratio: 0.8012820512820513>

---

--- 74 --
Question ID: 5ea979eb6ba3d15d39c72d2e1641ef3e5cc26c8f_12
Original Code:
```
static void
  vl_api_tap_inject_enable_disable_t_handler
  (vl_api_tap_inject_enable_disable_t * mp)
{
  printf("[tap-inject API] %s\n", __func__);
  vl_api_tap_inject_enable_disable_reply_t * rmp;
  cplane_netdev_main_t * mmp = cplane_netdev_get_main();

  int rv = 0;
  clib_error_t * err = tap_inject_enable_disable_all_interfaces (mp->is_enable ? 1 : 0);
  if (err) {
    tap_inject_enable_disable_all_interfaces (0);
    rv = -1;
  }

  REPLY_MACRO (VL_API_TAP_INJECT_ENABLE_DISABLE_REPLY);
}
```


Overlapping Code:
```
atic void
vl_api_tap_inject_enable_disable_t_handler
(vl_api_tap_inject_enable_disable_t * mp)
{
printf("[tap-inject API] %s\n", __func__);
vl_api_tap_inject_enable_disable_reply_t * rmp;
cplane_netdev_main_t * mmp = cplane_netdev_get_main();
int rv = 0;
clib_error_t * err = tap_inject_enable_disable_all_interfaces (mp->is_enable ? 1 : 0);
if (err) {
tap_inject_enable_disable_all_interfaces (0);
rv = -1;
}
REPLY_MACRO (VL_API_TAP_INJECT_ENABLE_DI
```
<Overlap Ratio: 0.9635974304068522>

---

--- 75 --
Question ID: 590899c31767f2f5a9a6fa68732167a57010e38b_51
Original Code:
```
static VALUE
gl_EvalCoord1dv(obj,arg1)
VALUE obj,arg1;
{
	GLdouble params[1] = {0.0};
	Check_Type(arg1,T_ARRAY);
	ary2cdbl(arg1,params,1);
	glEvalCoord1dv(params);
	CHECK_GLERROR_FROM("glEvalCoord1dv");
	return Qnil;
}
```


Overlapping Code:
```
static VALUE
gl_EvalCoord1dv(obj,arg1)
VALUE obj,arg1;
{
GLdouble params[1] = {0.0};
Check_Type(arg1,T_ARRAY);
ary2cdbl(arg1,params,1);
glEvalCoord1dv(params);
CHECK_GLERROR_FROM("glEvalCoord1dv");
re
```
<Overlap Ratio: 0.9433962264150944>

---

--- 76 --
Question ID: ac2a4f2af01c11d48c58f157698c38a36a9dc324_2
Original Code:
```
void midi_send_aftertouch(u8 index, u8 value){
	u8 midi_note = layout_get_midi_note(index);
	hal_send_midi(USBMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);
	hal_send_midi(DINMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);
}
```


Overlapping Code:
```
h(u8 index, u8 value){
u8 midi_note = layout_get_midi_note(index);
hal_send_midi(USBMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value);
hal_send_midi(DINMIDI, (POLYAFTERTOUCH + (current_midi_channel - 1)) | 0, midi_note, value
```
<Overlap Ratio: 0.8992805755395683>

---

--- 77 --
Question ID: 9e3e5f4468276476bd6c04456d96a1884a35d042_4
Original Code:
```
void initializeCrc()
{
    LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE);
    LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE);
    LL_CRC_SetPolynomialCoef(CRC, LL_CRC_DEFAULT_CRC32_POLY);
    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);
    LL_CRC_SetInitialData(CRC, LL_CRC_DEFAULT_CRC_INITVALUE);

    LL_CRC_SetPolynomialCoef(CRC, LINE_SENSOR_CRC_POLYNOMIAL);
    LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);
}
```


Overlapping Code:
```
rc()
{
LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE);
LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE);
LL_CRC_SetPolynomialCoef(CRC, LL_CRC_DEFAULT_CRC32_POLY);
LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);
LL_CRC_SetInitialData(CRC, LL_CRC_DEFAULT_CRC_INITVALUE);
LL_CRC_SetPolynomialCoef(CRC, LINE_SENSOR_CRC_POLYNOMIAL);
LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_32B);
```
<Overlap Ratio: 0.958997722095672>

---

--- 78 --
Question ID: 187a6c648eb470a31fb911bfa98305b4a5a78dd7_6
Original Code:
```
static struct S0  func_52(struct S0  p_53, struct S1 * p_54, struct S1 * p_55, struct S1 * p_56, struct S1  p_57)
{ /* block id: 101 */
    uint8_t l_227 = 3UL;
    int32_t *l_228 = &g_214;
    const struct S3 l_229 = {-12834,3,624,-6,8,31570,34,35,4,446};
    struct S1 l_234 = {0x7CBEL,65531UL};
    int8_t *l_255 = &g_253;
    int32_t l_280 = 0xE149A9F4L;
    int32_t l_281 = 3L;
    int32_t l_318 = (-2L);
    int32_t l_320 = 0xFA7069FDL;
    int32_t l_322[1][1];
    int32_t l_383[6] = {1L,1L,1L,1L,1L,1L};
    struct S5 *l_427 = &g_69;
    int16_t **l_492 = (void*)0;
    uint16_t l_548 = 1UL;
    int8_t l_581 = 0x33L;
    int16_t ***l_597 = &l_492;
    uint32_t l_646 = 0UL;
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 1; j++)
            l_322[i][j] = 0L;
    }
    if ((((*l_228) = l_227) <= ((l_229 , (&p_57 != (void*)0)) == p_53.f2)))
    { /* block id: 103 */
        for (g_94 = 8; (g_94 > 31); g_94 = safe_add_func_uint16_t_u_u(g_94, 2))
        { /* block id: 106 */
            if (p_57.f1)
                break;
        }
    }
    else
    { /* block id: 109 */
        int16_t *l_247 = &g_109;
        int16_t * const l_249 = (void*)0;
        int32_t l_250 = (-1L);
        int32_t l_272 = 0L;
        int32_t l_275 = 0L;
        int32_t l_329 = 0x121242E4L;
        struct S0 l_363 = {175,9,31,37};
        int32_t l_374 = 0x9A027F3BL;
        uint32_t l_391 = 0xCD74C835L;
        uint32_t ***l_400 = &g_345;
        uint32_t *l_409 = (void*)0;
        int32_t *l_410 = &l_280;
        const uint16_t l_411 = 0x43A9L;
        int32_t *l_412 = &l_250;
        struct S5 l_415[5][8] = {{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}},{{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{65534UL,65532UL,{5369,2,486,12,0,13875,95,41,123,1543},0xC4F27E92L},{1UL,0x3AC6L,{-12171,2,112,-9,2,32314,79,-30,68,750},-6L}}};
        uint32_t l_544 = 4294967293UL;
        uint32_t l_582 = 0xA0A9C2C1L;
        int32_t l_621[4] = {0xC353EE67L,0xC353EE67L,0xC353EE67L,0xC353EE67L};
        int16_t ***l_630 = &l_492;
        struct S3 l_639 = {-32711,-2,123,13,10,14313,101,-44,-66,6352};
        struct S1 *l_645 = &l_234;
        int i, j;
        for (l_227 = (-14); (l_227 <= 46); l_227++)
        { /* block id: 112 */
            struct S0 *l_236 = &g_153;
            struct S0 **l_235 = &l_236;
            struct S0 **l_237 = (void*)0;
            struct S0 *l_239[4][5] = {{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153},{&g_153,(void*)0,&g_153,&g_153,&g_153},{(void*)0,&g_153,(void*)0,&g_153,&g_153}};
            struct S0 **l_238 = &l_239[2][1];
            int32_t l_244 = 3L;
            int16_t **l_248 = &l_247;
            int32_t l_305 = 0xFBD691C8L;
            int32_t l_323 = (-5L);
            int32_t l_326[3][3][10] = {{{0x1F4B9C93L,8L,8L,0x1F4B9C93L,0x349389C5L,5L,0x73619E2BL,(-1L),(-1L),1L},{0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L,8L,0x73619E2BL,(-1L),(-1L)},{(-1L),1L,(-1L),0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L}},{{1L,1L,0xDEF5D37AL,0x7A2AB3D7L,0x7A2AB3D7L,0xDEF5D37AL,1L,1L,0x1F4B9C93L,5L},{(-1L),(-1L),0x73619E2BL,1L,0L,0x7A2AB3D7L,(-1L),5L,(-1L),0x7A2AB3D7L},{0xFDE84D4DL,0L,0x73619E2BL,0L,0xFDE84D4DL,5L,0x1F4B9C93L,1L,1L,0xDEF5D37AL}},{{0x1F4B9C93L,0x71D502BBL,0xDEF5D37AL,5L,(-1L),0x349389C5L,0x349389C5L,(-1L),5L,0xDEF5D37AL},{5L,5L,(-1L),0xDEF5D37AL,0xFDE84D4DL,(-1L),(-1L),0x73619E2BL,8L,0x7A2AB3D7L},{0x73619E2BL,(-1L),(-1L),1L,0L,1L,(-1L),(-1L),0x73619E2BL,5L}}};
            int32_t *l_373 = &l_329;
            int32_t *l_378 = &l_323;
            int32_t *l_379 = &l_275;
            int32_t *l_380 = &l_280;
            int32_t *l_381[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int32_t l_382 = 0x5FE0C3B8L;
            uint16_t l_384 = 1UL;
            uint8_t l_388[10][1][2] = {{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}},{{0x82L,0xB0L}},{{0xB0L,0x5FL}},{{0xB0L,0x5FL}},{{0xB0L,0xB0L}},{{0x82L,0x82L}}};
            int i, j, k;
            if ((((p_53.f0 == (func_17(l_234, (((*l_238) = ((*l_235) = &p_53)) != &p_53)) , g_113.f8)) < (safe_rshift_func_uint16_t_u_s((((((safe_add_func_uint8_t_u_u(l_244, ((safe_mul_func_int8_t_s_s((250UL != (+((((*l_248) = l_247) != l_249) ^ p_53.f2))), (*l_228))) || p_53.f2))) , (*l_228)) , 0xC7L) || l_250) | p_53.f3), g_113.f3))) == l_250))
            { /* block id: 116 */
                int32_t l_251 = 0xAE49ED9AL;
                int8_t *l_254 = &g_253;
                for (g_69.f0 = 0; (g_69.f0 <= 8); g_69.f0 += 1)
                { /* block id: 119 */
                    uint16_t *l_262 = (void*)0;
                    uint16_t *l_263 = &l_234.f0;
                    int16_t *l_273[5];
                    int i;
                    for (i = 0; i < 5; i++)
                        l_273[i] = &g_274;
                    if (l_251)
                        break;
                    (*l_228) |= ((0x2AL | (g_252 == (l_255 = l_254))) , (p_53 , (safe_add_func_uint16_t_u_u((safe_div_func_int16_t_s_s((l_275 ^= (p_53 , ((safe_div_func_int32_t_s_s((((*l_263) = 0x18A4L) | ((((g_109 = (l_272 &= (safe_mul_func_uint16_t_u_u(((safe_sub_func_uint8_t_u_u(((-1L) || (!((safe_mul_func_uint8_t_u_u((safe_mod_func_int16_t_s_s((-7L), (5UL && 251UL))), l_250)) ^ l_244))), 7UL)) || l_251), 0L)))) != 0UL) , (void*)0) != &l_229)), p_57.f1)) > (*g_252)))), p_57.f1)), 0x5575L))));
                    if (l_251)
                        break;
                    p_53.f0 = ((safe_rshift_func_int8_t_s_s((*g_252), p_53.f2)) , (0UL || (*l_228)));
                }
            }
            else
            { /* block id: 130 */
                int32_t *l_278 = &l_250;
                int32_t *l_279[8][4] = {{&l_244,(void*)0,(void*)0,(void*)0},{(void*)0,&l_272,&l_275,&l_244},{(void*)0,&l_250,&l_250,(void*)0},{(void*)0,(void*)0,&l_275,&g_214},{(void*)0,(void*)0,(void*)0,&l_244},{&l_244,&l_250,&l_244,&l_244},{(void*)0,(void*)0,(void*)0,&g_214},{&l_275,(void*)0,(void*)0,(void*)0}};
                uint8_t l_282 = 253UL;
                uint16_t *l_289[6] = {&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0,&g_43[6][6][2].f0};
                struct S0 *l_300[7] = {&g_153,&g_153,&g_153,&g_153,&g_153,&g_153,&g_153};
                uint8_t *l_303 = &g_94;
                uint32_t l_304 = 0x5DECD937L;
                int32_t l_328 = 0L;
                uint32_t **l_333 = (void*)0;
                struct S5 l_358 = {65526UL,65535UL,{-17020,-3,129,6,9,5641,116,6,16,3716},0x87A08BDBL};
                int i, j;
                ++l_282;
                if ((((((safe_mul_func_int16_t_s_s((l_244 = (safe_add_func_int8_t_s_s(((((--g_69.f0) || l_244) & (g_43[6][6][2].f1 = p_53.f2)) ^ ((**l_248) |= (g_274 = p_57.f1))), (*g_252)))), (safe_div_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u(g_182.f9, 0)), ((*l_303) = ((p_53.f1 && ((safe_lshift_func_uint8_t_u_s((safe_sub_func_uint32_t_u_u((l_300[0] == (*l_235)), ((*l_228) = ((safe_sub_func_int8_t_s_s(0x3CL, 1L)) | p_57.f1)))), 5)) <= l_250)) | g_113.f0)))))) | g_69.f3) || p_53.f0) , l_304) != l_305))
                { /* block id: 139 */
                    struct S4 *l_308 = &g_138;
                    int32_t l_315 = 1L;
                    int32_t l_316 = 0xC4D5F313L;
                    int32_t l_317 = 0x579CAB94L;
                    int32_t l_325 = 0L;
                    int32_t l_327[4][3][8] = {{{0x030C2675L,3L,0xE8FD32BEL,0xFF4CD6DDL,(-1L),1L,1L,1L},{3L,(-10L),0x51BD3FEEL,1L,(-10L),0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L},{0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL,3L,0x3D1CCB86L,1L}},{{0x3D1CCB86L,0x3ADFECCFL,0x57BA0327L,0xFF4CD6DDL,0xFF4CD6DDL,0x57BA0327L,0x3ADFECCFL,0x3D1CCB86L},{0xFDD9E36FL,0x5D09D952L,0x51BD3FEEL,0xDE5CFD58L,(-1L),(-1L),0xE8FD32BEL,0x57BA0327L},{0L,1L,(-1L),0x8A8F9135L,0xDE5CFD58L,(-1L),0xDE5CFD58L,0x8A8F9135L}},{{0x3ADFECCFL,0x5D09D952L,0x3ADFECCFL,0x51BD3FEEL,(-1L),0x57BA0327L,1L,0xFDD9E36FL},{0x8A8F9135L,0x3ADFECCFL,0xDE5CFD58L,0xE8FD32BEL,0L,3L,(-1L),(-1L)},{0x8A8F9135L,(-1L),0x3D1CCB86L,0x3D1CCB86L,(-1L),0x8A8F9135L,0x5D09D952L,(-10L)}},{{0x3ADFECCFL,1L,3L,0x5D09D952L,0xDE5CFD58L,0x030C2675L,0xFDD9E36FL,0xFF4CD6DDL},{0L,(-10L),0x030C2675L,0x5D09D952L,(-1L),0x5D09D952L,0x030C2675L,(-10L)},{0xFDD9E36FL,(-1L),0xE8FD32BEL,0x3D1CCB86L,0xFF4CD6DDL,0x51BD3FEEL,0L,(-1L)}}};
                    int i, j, k;
                    for (p_57.f0 = (-21); (p_57.f0 < 48); ++p_57.f0)
                    { /* block id: 142 */
                        struct S4 **l_309 = &l_308;
                        (*l_309) = l_308;
                        return g_153;
                    }
                    if (l_305)
                        break;
                    for (l_305 = (-25); (l_305 < 11); l_305 = safe_add_func_int16_t_s_s(l_305, 1))
                    { /* block id: 149 */
                        int8_t l_312 = 0xE5L;
                        int32_t l_313 = 1L;
                        int32_t l_314 = 0xB566A646L;
                        int32_t l_319 = 1L;
                        int32_t l_321 = 3L;
                        int32_t l_324[4];
                        uint16_t l_330 = 0xFA7FL;
                        int i;
                        for (i = 0; i < 4; i++)
                            l_324[i] = 0x82E92E31L;
                        l_330--;
                    }
                    for (l_244 = 0; (l_244 <= 3); l_244 += 1)
                    { /* block id: 154 */
                        uint32_t ***l_334 = &l_333;
                        int32_t l_347 = 0xF0677D09L;
                        struct S2 **l_350 = &g_348;
                        int i, j;
                        (*l_334) = l_333;
                        p_53.f0 = (247UL & (safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u((p_57.f1 = ((&l_239[l_244][(l_244 + 1)] == &l_239[l_244][l_244]) < (~(((((*l_228) && p_57.f0) ^ (safe_lshift_func_int16_t_s_s((+(*l_278)), (((((((((((l_315 > ((g_345 == (void*)0) , g_113.f6)) < g_69.f2.f3) >= p_53.f0) , l_326[1][0][2]) || 1UL) != (*g_252)) && (*g_252)) >= p_57.f0) >= 65532UL) , 0x41F066B9L) || p_57.f1)))) ^ l_347) < l_305)))), p_53.f2)), p_53.f3)), g_138.f0.f2)), 15)));
                        (*l_350) = g_348;
                    }
                }
                else
                { /* block id: 160 */
                    struct S3 **l_351 = &g_112;
                    struct S3 *l_354 = &g_138.f0;
                    struct S3 **l_353[1];
                    int i;
                    for (i = 0; i < 1; i++)
                        l_353[i] = &l_354;
                    g_356 = (g_355 = (g_352 = ((*l_351) = (void*)0)));
                    if (l_329)
                        continue;
                }
                (*l_228) = (l_358 , ((*l_278) = p_53.f0));
                (*l_228) ^= (g_69.f1 <= (p_57.f1 || (*g_252)));
            }
            for (l_318 = 0; (l_318 <= (-8)); --l_318)
            { /* block id: 173 */
                uint16_t l_367[3];
                int32_t *l_372 = &g_214;
                int i;
                for (i = 0; i < 3; i++)
                    l_367[i] = 65527UL;
                for (l_234.f1 = (-8); (l_234.f1 >= 26); ++l_234.f1)
                { /* block id: 176 */
                    (*l_228) = (l_275 > (*g_252));
                    return l_363;
                }
                l_244 = (*l_228);
                for (l_234.f1 = 3; (l_234.f1 <= 8); l_234.f1 += 1)
                { /* block id: 183 */
                    uint16_t l_375 = 0x71EFL;
                    for (l_244 = 0; (l_244 <= 8); l_244 += 1)
                    { /* block id: 186 */
                        return g_153;
                    }
                    for (g_84 = 8; (g_84 >= 0); g_84 -= 1)
                    { /* block id: 191 */
                        int32_t *l_364 = &l_329;
                        int32_t *l_365 = (void*)0;
                        int32_t *l_366[1];
                        int32_t **l_370 = &l_366[0];
                        int32_t **l_371 = (void*)0;
                        int i;
                        for (i = 0; i < 1; i++)
                            l_366[i] = (void*)0;
                        l_367[1]++;
                        g_151[4] = (l_373 = (l_372 = ((*l_370) = &g_214)));
                        --l_375;
                    }
                }
            }
            l_384++;
            for (g_94 = 2; (g_94 <= 7); g_94 += 1)
            { /* block id: 204 */
                int16_t l_387[1][8];
                int i, j;
                for (i = 0; i < 1; i++)
                {
                    for (j = 0; j < 8; j++)
                        l_387[i][j] = 1L;
                }
                l_388[6][0][1]--;
                (*l_380) = l_387[0][0];
            }
        }
        if (((*l_412) = ((((p_53.f3 = ((*l_228) = (p_53.f1 = l_391))) || ((*l_410) ^= (safe_rshift_func_int16_t_s_u((((p_53.f3 <= (((safe_sub_func_uint8_t_u_u((safe_mul_func_int16_t_s_s((-2L), (safe_lshift_func_uint16_t_u_u((l_374 != 65530UL), 13)))), ((*l_255) = ((((*l_400) = &g_346[3][1][3]) != (g_401 = &g_346[0][2][2])) <= (l_272 ^= (safe_sub_func_uint8_t_u_u((((safe_sub_func_uint32_t_u_u((((safe_unary_minus_func_uint16_t_u(((safe_lshift_func_int16_t_s_u(((((*l_228) && ((*g_252) | 2UL)) , p_53.f1) != g_69.f0), 9)) > (-5L)))) >= p_53.f0) > (*l_228)), (*l_228))) >= (*l_228)) , (*l_228)), 1UL))))))) | 65528UL) | p_57.f1)) <= 1L) < g_182.f0), l_275)))) > l_411) , p_53.f3)))
        { /* block id: 218 */
            uint8_t l_443[8] = {0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL,0x1DL};
            uint32_t *l_451 = &g_131;
            int32_t l_504[3][5] = {{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)},{(-1L),(-1L),1L,1L,(-1L)}};
            struct S4 *l_574 = &g_518[1];
            int16_t ***l_595 = &l_492;
            int16_t l_620 = (-6L);
            uint8_t l_622 = 0x8BL;
            uint32_t *l_636 = &g_494[2];
            uint16_t l_644 = 0x655EL;
            int i, j;
            if ((((safe_mul_func_uint8_t_u_u(p_53.f2, ((l_415[1][6] , ((*l_228) = (((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_int8_t_s(p_53.f2)), 0xEFL)) >= ((safe_sub_func_uint8_t_u_u((safe_div_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((7UL < (((*g_75) = l_427) == (void*)0)), ((safe_div_func_uint8_t_u_u(((safe_div_func_uint32_t_u_u((((safe_lshift_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(p_53.f2, (g_113.f5 && 255UL))), g_94)) >= 0x48L) , 0x0A836DACL), p_53.f1)) | g_349.f0), (*l_228))) , 4L))), g_111.f4)), p_53.f1)), (*g_252))) || p_53.f1)) , 0xA8E3F1E3L))) ^ 0x4A00F90DL))) ^ 0x7BL) < 0x4F381AB7L))
            { /* block id: 221 */
                struct S1 l_450 = {0x958CL,0UL};
                int8_t l_468[8][4][2] = {{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}},{{1L,0x38L},{0x38L,1L},{0x38L,0x38L},{1L,0x38L}},{{0x38L,1L},{0x38L,0x38L},{1L,0x38L},{0x38L,1L}},{{0x38L,0x38L},{1L,0x38L},{0x38L,1L},{0x38L,0x38L}}};
                int32_t l_476 = (-1L);
                int16_t ***l_493 = &l_492;
                int32_t l_503 = (-3L);
                struct S4 *l_520 = &g_521[4][0][0];
                const struct S3 l_529 = {2366,0,1008,2,10,12108,126,-23,-15,1054};
                int32_t *l_575 = &l_476;
                int32_t *l_576 = &l_503;
                int32_t *l_577 = &l_374;
                int32_t *l_578 = &l_281;
                int32_t *l_579 = &l_476;
                int32_t *l_580[7];
                int i, j, k;
                for (i = 0; i < 7; i++)
                    l_580[i] = &l_250;
                if ((safe_unary_minus_func_int8_t_s((safe_div_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s((safe_div_func_int8_t_s_s(p_53.f3, l_443[6])), ((((*l_247) = ((*g_42) , (p_53.f3 && (*l_412)))) >= (safe_div_func_uint8_t_u_u(9UL, 1UL))) <= p_57.f0))) > (safe_sub_func_int32_t_s_s((safe_add_func_uint8_t_u_u((((l_451 = (func_17(l_450, l_450.f0) , (*g_345))) != (**l_400)) == (*l_410)), (*l_228))), (*l_228)))) < l_443[6]), g_357.f9)))))
                { /* block id: 224 */
                    int8_t l_457[7];
                    int i;
                    for (i = 0; i < 7; i++)
                        l_457[i] = 0xE6L;
                    for (g_349.f5 = 15; (g_349.f5 == (-25)); --g_349.f5)
                    { /* block id: 227 */
                        uint16_t l_460[9] = {0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L,0x13E5L,1UL,0x13E5L};
                        uint16_t *l_463 = &l_450.f1;
                        int i;
                        (*l_412) |= ((p_53.f3 & ((*l_247) = 0xA57DL)) & (*l_228));
                        if (p_53.f0)
                            break;
                        p_53.f0 = ((!((safe_unary_minus_func_uint32_t_u(((safe_mod_func_int32_t_s_s(((*l_410) = (-2L)), ((*l_228) &= p_53.f3))) ^ l_457[0]))) || (((g_153.f0 >= (+(safe_div_func_uint32_t_u_u(p_53.f2, (((l_460[8] , (safe_lshift_func_uint16_t_u_u(p_53.f2, 15))) ^ (((*l_463) = g_111.f6) , (((0x2BB8L < p_53.f2) ^ p_53.f0) > 4294967295UL))) , p_53.f0))))) && l_457[0]) <= 0x1EL))) == p_53.f3);
                        (*g_42) = (*p_54);
                    }
                }
                else
                { /* block id: 237 */
                    uint8_t l_477 = 0x96L;
                    for (l_450.f0 = 0; (l_450.f0 != 42); l_450.f0 = safe_add_func_int16_t_s_s(l_450.f0, 2))
                    { /* block id: 240 */
                        int32_t l_466[6] = {0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L,0x1655F412L};
                        int32_t *l_467 = (void*)0;
                        int32_t *l_469 = (void*)0;
                        int32_t *l_470 = &l_466[5];
                        int32_t *l_471 = &l_322[0][0];
                        int32_t *l_472 = &l_320;
                        int32_t *l_473 = &l_272;
                        int32_t *l_474 = &l_374;
                        int32_t *l_475[8][1] = {{&l_320},{&l_281},{&l_281},{&l_322[0][0]},{&l_320},{&l_320},{&l_322[0][0]},{&l_320}};
                        int i, j;
                        l_477--;
                        return g_153;
                    }
                }
                if (((*l_228) |= (((g_494[2] = (!((safe_rshift_func_int16_t_s_s(((*l_247) = ((void*)0 == &g_23)), 6)) == (safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_u((((p_53.f1 = (*l_412)) > (*l_410)) && (safe_add_func_uint8_t_u_u(((safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u((g_274 = (&g_76 != (((*g_252) , (((*l_493) = l_492) != (void*)0)) , &g_76))), p_53.f1)), g_111.f7)) | l_450.f0), p_57.f0))), g_111.f5)) , 1L), p_53.f0))))) > l_468[7][3][0]) || 1L)))
                { /* block id: 251 */
                    struct S3 *l_497[9][10][2] = {{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}},{{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113}},{{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0}},{{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182}},{{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182}},{{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0}},{{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113}},{{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111},{&g_138.f0,(void*)0},{&g_111,&g_182},{&g_111,&g_113},{(void*)0,&g_113},{&g_111,&g_182},{&g_111,(void*)0},{&g_138.f0,&g_111}}};
                    int32_t l_505 = 0x3BBE76C4L;
                    uint8_t l_506 = 6UL;
                    int i, j, k;
                    (*l_410) |= ((*l_412) = p_53.f0);
                    for (l_374 = (-26); (l_374 == 16); l_374 = safe_add_func_int16_t_s_s(l_374, 4))
                    { /* block id: 256 */
                        struct S3 **l_498 = &l_497[8][7][0];
                        (*l_498) = l_497[8][9][0];
                    }
                    for (p_57.f0 = 0; (p_57.f0 != 45); p_57.f0 = safe_add_func_uint8_t_u_u(p_57.f0, 7))
                    { /* block id: 261 */
                        int32_t **l_501 = &l_412;
                        int32_t *l_502[1];
                        int i;
                        for (i = 0; i < 1; i++)
                            l_502[i] = &l_281;
                        (*l_501) = &l_281;
                        l_506++;
                    }
                }
                else
                { /* block id: 265 */
                    struct S4 *l_516 = &g_138;
                    struct S4 **l_515 = &l_516;
                    struct S4 **l_519 = (void*)0;
                    uint16_t *l_523 = (void*)0;
                    uint16_t *l_524 = &l_450.f0;
                    int32_t l_547 = 2L;
                    struct S5 *l_566 = (void*)0;
                    p_53.f0 = (((safe_div_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(((*l_524) = (+(l_504[1][2] || (g_138 , (((*l_410) = (safe_add_func_int8_t_s_s((*g_252), ((l_520 = (g_517 = ((*l_515) = &g_138))) == ((*g_348) , &g_521[4][0][0]))))) >= (safe_unary_minus_func_int16_t_s((g_113.f9 < ((g_69.f2.f4 ^ (~p_57.f0)) <= p_53.f3))))))))), 0x3F82L)), 1L)) || 8L) != p_53.f1);
                    for (g_85 = 0; (g_85 <= 2); g_85 += 1)
                    { /* block id: 274 */
                        uint32_t *l_532 = &g_494[3];
                        int32_t l_535 = (-6L);
                        uint16_t *l_545 = &g_43[6][6][2].f1;
                        uint16_t l_546 = 65532UL;
                        struct S2 **l_551 = &g_348;
                        int32_t *l_567 = &l_503;
                        (*l_412) = ((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint32_t_u_u(((g_153 , ((l_529 , (((*l_545) = (safe_sub_func_int8_t_s_s(((((+(--(*l_532))) , ((*g_517) , (l_535 | ((g_182.f8 , (((((safe_add_func_uint8_t_u_u((safe_div_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_504[0][1], p_53.f3)), (safe_lshift_func_uint8_t_u_u((((*l_524) = p_57.f0) <= (*l_228)), 1)))), 0x9CL)) > 0x6DCC9F64L) || l_544) >= (*g_252)) > 4UL)) >= 4294967295UL)))) <= g_138.f0.f6) < 5UL), 0xB6L))) == l_546)) | 0xC305L)) , l_529.f8), l_547)), (*g_252))) || l_548);
                        (*l_412) &= (safe_add_func_int32_t_s_s(p_53.f3, (0xFA528CD4L <= ((((*p_56) = (*g_42)) , &l_228) == (void*)0))));
                        (*l_551) = &g_349;
                        (*l_567) ^= ((*l_228) > (safe_lshift_func_uint16_t_u_s(((safe_add_func_int32_t_s_s(p_57.f1, (((((g_153 , ((((*l_410) &= p_53.f3) ^ 4294967295UL) > (safe_mul_func_int16_t_s_s(p_57.f1, 5UL)))) <= ((safe_mul_func_uint16_t_u_u((safe_mul_func_uint8_t_u_u((safe_add_func_int16_t_s_s((((((255UL != (~(4294967294UL == 0UL))) , (void*)0) == l_566) , g_69.f3) ^ l_504[2][3]), g_274)), 0x5DL)), g_111.f6)) == l_535)) & 8UL) && p_53.f2) | (*l_412)))) || p_53.f0), 3)));
                    }
                    (*l_412) = (((g_274 |= 0L) == g_349.f1) && (safe_lshift_func_int8_t_s_s(0L, (safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((void*)0 != l_574), (l_234 , l_529.f8))), 12)))));
                }
                l_582++;
            }
            else
            { /* block id: 289 */
                uint32_t l_606[6];
                int32_t l_609 = 0x40AE2A13L;
                int32_t *l_610 = &l_504[1][3];
                int32_t *l_611 = &l_318;
                int32_t *l_612 = &g_84;
                int32_t *l_613 = &l_609;
                int32_t *l_614 = (void*)0;
                int32_t *l_615 = &l_504[1][2];
                int32_t l_616 = 0x99467C25L;
                int32_t *l_617 = &l_322[0][0];
                int32_t *l_618[5];
                int16_t l_619 = 8L;
                int i;
                for (i = 0; i < 6; i++)
                    l_606[i] = 0x997170ADL;
                for (i = 0; i < 5; i++)
                    l_618[i] = &l_616;
                for (g_131 = (-27); (g_131 == 22); g_131++)
                { /* block id: 292 */
                    for (l_318 = 2; (l_318 >= 0); l_318 -= 1)
                    { /* block id: 295 */
                        (*l_410) = ((*l_228) = p_57.f1);
                    }
                }
                for (p_57.f0 = 3; (p_57.f0 <= 8); p_57.f0 += 1)
                { /* block id: 302 */
                    int32_t *l_600 = (void*)0;
                    int32_t *l_602 = &l_504[2][0];
                    int32_t *l_603 = &l_320;
                    int32_t *l_604 = &l_281;
                    int32_t *l_605[9][2] = {{(void*)0,&l_329},{(void*)0,(void*)0},{&l_329,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329},{&l_329,&l_280},{&l_329,&l_329},{&l_280,&l_329}};
                    int i, j;
                    for (l_250 = 0; (l_250 <= 8); l_250 += 1)
                    { /* block id: 305 */
                        struct S3 l_594[7] = {{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899},{-9867,4,834,0,10,12828,54,32,17,4899}};
                        int16_t ****l_596[10] = {&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595,&l_595};
                        uint16_t *l_598 = &l_415[1][6].f0;
                        int i;
                        (*l_410) |= ((safe_add_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((((safe_unary_minus_func_int8_t_s((((&g_356 == &g_112) & (safe_mod_func_uint8_t_u_u((249UL >= (l_594[6] , (p_53.f1 != ((*l_598) = ((l_597 = l_595) == (void*)0))))), (*g_252)))) <= ((void*)0 == l_451)))) != g_599) != p_57.f0), 2UL)), (-1L))) != (*l_228));
                    }
                    l_606[2]--;
                }
                l_622++;
            }
            for (l_582 = 0; (l_582 > 11); l_582 = safe_add_func_int16_t_s_s(l_582, 7))
            { /* block id: 316 */
                struct S3 **l_627 = &g_356;
                (*l_627) = &g_113;
            }
            (*l_410) |= (safe_sub_func_uint32_t_u_u(p_53.f1, (l_630 != ((g_599 = (safe_add_func_int32_t_s_s((*l_228), (safe_div_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u(((*l_636) |= 1UL))), (safe_add_func_int8_t_s_s((*g_252), (g_153 , 0x7DL)))))))) , l_595))));
            g_151[2] = &l_374;
        }
        else
        { /* block id: 323 */
            if (l_646)
            { /* block id: 324 */
                return p_53;
            }
            else
            { /* block id: 326 */
                struct S0 l_647[3][6][8] = {{{{-136,13,28,56},{145,13,26,9},{25,0,13,51},{-81,8,14,33},{-140,15,5,35},{-129,10,27,47},{124,4,0,104},{121,11,4,41}},{{30,12,15,71},{-136,13,28,56},{-55,14,13,73},{-148,11,29,18},{25,0,13,51},{-61,5,20,10},{66,11,28,12},{174,14,3,98}},{{110,4,20,75},{-150,13,15,70},{-141,10,31,71},{47,14,31,82},{-116,6,24,66},{95,3,18,52},{-81,14,25,100},{29,12,13,108}},{{-61,5,20,10},{-114,12,30,14},{-23,5,25,53},{172,13,28,120},{29,2,12,91},{174,14,3,98},{174,14,3,98},{29,2,12,91}},{{-23,5,25,53},{56,4,31,53},{56,4,31,53},{-23,5,25,53},{59,9,19,14},{30,12,15,71},{-61,5,20,10},{-118,2,9,105}},{{124,4,0,104},{47,14,31,82},{154,4,1,112},{-129,10,27,47},{-150,13,15,70},{-140,15,5,35},{172,13,28,120},{74,8,2,48}}},{{{-0,14,5,119},{47,14,31,82},{145,13,26,9},{-150,12,27,48},{174,14,3,98},{30,12,15,71},{-134,5,10,54},{154,4,1,112}},{{-97,7,20,120},{56,4,31,53},{-81,14,25,100},{-19,5,8,89},{-134,10,28,16},{174,14,3,98},{-112,11,31,77},{-149,15,5,23}},{{-140,15,5,35},{-114,12,30,14},{-116,6,24,66},{101,10,31,13},{95,1,23,52},{95,3,18,52},{-129,10,27,47},{172,13,28,120}},{{59,6,30,38},{-150,13,15,70},{59,9,19,14},{124,4,0,104},{152,6,21,93},{-61,5,20,10},{-141,10,31,71},{56,4,31,53}},{{-148,11,29,18},{-136,13,28,56},{-39,7,30,57},{-150,13,15,70},{29,12,13,108},{-129,10,27,47},{-114,12,30,14},{-141,10,31,71}},{{42,8,21,80},{145,13,26,9},{-81,8,14,33},{130,13,14,91},{-81,8,14,33},{145,13,26,9},{42,8,21,80},{-86,15,8,7}}},{{{25,0,13,51},{128,3,7,9},{59,6,30,38},{95,1,23,52},{154,4,1,112},{74,8,2,48},{45,11,4,116},{-116,6,24,66}},{{59,9,19,14},{101,10,31,13},{-118,2,9,105},{-136,13,28,56},{154,4,1,112},{-112,11,31,77},{110,4,20,75},{130,13,14,91}},{{25,0,13,51},{9,13,20,103},{-134,10,28,16},{-116,6,24,66},{-81,8,14,33},{161,6,7,45},{83,12,31,120},{-134,5,10,54}},{{42,8,21,80},{110,4,20,75},{-129,10,27,47},{34,6,31,81},{29,12,13,108},{95,1,23,52},{-46,5,11,42},{145,13,26,9}},{{-148,11,29,18},{-39,7,30,57},{30,12,15,71},{29,2,12,91},{152,6,21,93},{101,10,31,13},{154,4,1,112},{-19,5,8,89}},{{59,6,30,38},{-118,2,9,105},{42,8,21,80},{66,11,28,12},{95,1,23,52},{-136,13,28,56},{-140,15,5,35},{161,6,7,45}}}};
                int i, j, k;
                return l_647[1][1][5];
            }
        }
        for (l_329 = 0; (l_329 != (-25)); l_329--)
        { /* block id: 332 */
            struct S1 **l_650[10] = {&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645,&l_645};
            int i;
            p_56 = &g_43[1][0][0];
        }
        return l_363;
    }
    for (g_69.f3 = 6; (g_69.f3 <= (-1)); --g_69.f3)
    { /* block id: 339 */
        const int32_t *l_653 = &l_322[0][0];
        const int32_t **l_654 = &l_653;
        (*l_654) = ((*l_427) , l_653);
    }
    return g_153;
}
```


Overlapping Code:
```
int i, j;
for (i = 0; i < 1; i++)
{
for (j = 0; j < 1; j+
```
<Overlap Ratio: 0.02590909090909091>

---

--- 79 --
Question ID: 46d0a55ff309b8e6439399dedf2b614ed04ff924_5
Original Code:
```
static HippoReadInfo mp3_read_data(void* user_data, void* dest, uint32_t max_output_bytes,
                                    uint32_t native_sample_rate) {
    struct ReplayerData* data = (struct ReplayerData*)user_data;

    uint16_t samples_to_read = hippo_min(max_output_bytes / 8, FRAME_SIZE);

	drmp3_read_pcm_frames_f32(&data->song, samples_to_read, (float*)dest);

    HippoReadInfo t = {
    	data->song.sampleRate,
        samples_to_read,
        data->song.channels,
        HippoOutputType_f32,
    };

    return t;
}
```


Overlapping Code:
```
HippoReadInfo mp3_read_data(void* user_data, void* dest, uint32_t max_output_bytes,
uint32_t native_sample_rate) {
struct ReplayerData* data = (struct ReplayerData*)user_data;
uint16_t samples_to_read = hippo_min(max_output_bytes / 8, FRAME_SIZE);
drmp3_read_pcm_frames_f32(&data->song, samples_to_read, (float*)dest);
HippoReadInfo t = {
data->song.sampleRate,
samples_to_read,
data->song.channels,

```
<Overlap Ratio: 0.9049773755656109>

---

--- 80 --
Question ID: 7050b26ad17e4b2ae03081afc00b84ca1f5bc9df_0
Original Code:
```
static bool api_epm_Insert(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct epm_Insert *r;

	call = &ndr_table_epmapper.calls[NDR_EPM_INSERT];

	r = talloc(talloc_tos(), struct epm_Insert);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r, NULL);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_IN_DEBUG(epm_Insert, r);
	}

	r->out.result = _epm_Insert(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLEVEL >= 10) {
		NDR_PRINT_OUT_DEBUG(epm_Insert, r);
	}

	push = ndr_push_init_ctx(r, NULL);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
```


Overlapping Code:
```
(pipes_struct *p)
{
const struct ndr_interface_call *call;
struct ndr_pull *pull;
struct ndr_push *push;
enum ndr_err_code ndr_err;
DATA_BLOB blob;
struct epm_Insert *r;
call = &ndr_table_epmapper.calls[NDR_EPM_INSERT];
r = talloc(talloc_tos(), struct epm_Insert);
if (r == NULL) {
return false;
}
if (!prs_data_blob(&p->in_data.data, &blob, r)) {
talloc_free(r);
return false;
}
pull = ndr_pull_init_blob(&blob, r, NULL);
if (pull == NULL) {
talloc_free(r);
return false;
}
pull->flags |= LIBNDR_FLAG_REF_ALLOC;
ndr_err = call->ndr_pull(pull, NDR_IN, r);
if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
talloc_free(r);
return false;
}
if (DEBUGLEVEL >= 10) {
NDR_PRINT_IN_DEBUG(epm_Insert, r);
}
r->out.result = _epm_Insert(p, r);
if (p->rng_fault_state) {
talloc_free(r);
/* Return true here, srv_pipe_hnd.c will take care */
return true;
}
if (DEBUGLEVEL >= 10) {
NDR_PRINT_OUT_DEBUG(epm_Insert, r);
}
push = ndr_push_init_ctx(r, NULL);
if (push == NULL) {
talloc_free(r);
return false;
}
ndr_err = call->ndr_push(push, NDR_OUT, r);
if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
talloc_free(r);
return false;
}
blob = ndr_push_blob(push);
if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
talloc_free(r);
return false;
}
talloc_free(r);
return true;
}
```
<Overlap Ratio: 0.9801678108314263>

---

--- 81 --
Question ID: e1fa1c3e409967b56975ae65d4b39d032bd80380_0
Original Code:
```
bool is_valid_name(const char *name) {
    int len = 0;
    while (*name) {
        char ch = *name;
        if (++len < 32 && ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch == '_'))) {
            name++;
            continue;
        }
        return false;
    }
    return len > 0 && name[0] != '_';
}
```


Overlapping Code:
```
lid_name(const char *name) {
int len = 0;
while (*name) {
char ch = *name;
if (++len < 32 && ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch == '_'))) {
name++;
continue;
}
return false;

```
<Overlap Ratio: 0.8097165991902834>

---

--- 82 --
Question ID: 87e7aae510c986e652e839c0bff7c2b8a12bb3b0_5
Original Code:
```
char *get_tail(const char *code, char *rcode) {
  char *quot;
  unsigned code_len;

  code_len = strlen(code);

  memset(rcode, 0, 2);
  if ((quot = strchr(code, '\''))) {
    rcode[0] = *(quot - 1);
  } else {
    rcode[0] = code[code_len - 1];
  }

  return rcode;
}
```


Overlapping Code:
```
et_tail(const char *code, char *rcode) {
char *quot;
unsigned code_len;
code_len = strlen(code);
memset(rcode, 0, 2);
if ((quot = strchr(code, '\''))) {
rcode[0] = *(quot - 1);
} else {
rcode[0] = cod
```
<Overlap Ratio: 0.8298755186721992>

---

--- 83 --
Question ID: f4dd81e4dc7e5773cc51877a9dd7294d9d792af8_68
Original Code:
```
Int32 TarsOutputStream_writeVectorCharBuffer(TarsOutputStream * os, const char* buff, uint32_t len, uint8_t tag)
{
	Int32 ret;
	DataHead *hh;

	//DataHead_setType(os->_h, eSimpleList);
	// DataHead_setTag(os->_h, tag);

	//ret = DataHead_writeTo(os->_h, os);
	ret = DataHead_setAndWriteTo(os->_h, eSimpleList, tag, os);
	if (TARS_SUCCESS != ret)	return ret;

	hh = DataHead_new();
	if (!hh) return TARS_MALLOC_ERROR;

	//DataHead_setType(hh, eChar);
	//DataHead_setTag(hh, 0);

	//ret = DataHead_writeTo(hh, os);
	ret = DataHead_setAndWriteTo(hh, eChar, 0, os);
	DataHead_del(&hh);

	if (TARS_SUCCESS != ret)	return ret;

	ret = TarsOutputStream_writeInt32(os, len, 0);
	if (TARS_SUCCESS != ret)	return ret;

	return TarsOutputStream_writeBuf(os, buff, len);
}
```


Overlapping Code:
```
Stream_writeVectorCharBuffer(TarsOutputStream * os, const char* buff, uint32_t len, uint8_t tag)
{
Int32 ret;
DataHead *hh;
//DataHead_setType(os->_h, eSimpleList);
// DataHead_setTag(os->_h, tag);
//ret = DataHead_writeTo(os->_h, os);
ret = DataHead_setAndWriteTo(os->_h, eSimpleList, tag, os);
if (TARS_SUCCESS != ret) return ret;
hh = DataHead_new();
if (!hh) return TARS_MALLOC_ERROR;
//DataHead_setType(hh, eChar);
//DataHead_setTag(hh, 0);
//ret = DataHead_writeTo(hh, os);
ret = DataHead_setAndWriteTo(hh, eChar, 0, os);
DataHead_del(&hh);
if (TARS_SUCCESS != ret) return ret;
ret = TarsOutputStream_writeInt32(os, len, 0);
if (TARS_SUCCESS != ret) return ret;
return TarsOutputStream_writeBuf(os, 
```
<Overlap Ratio: 0.9604904632152589>

---

--- 84 --
Question ID: 3f69319c82b474f40d5bc0574695e1994597035e_8
Original Code:
```
void program_unistr_mat(program_t *program, const char *name, mat4x4 m) {
    program_use(program);
    GLint loc = glGetUniformLocation(program->id, name);
    UNI_KILL(loc, name);
    glUniformMatrix4fv(loc, 1, GL_FALSE, m[0]);
}
```


Overlapping Code:
```
_mat(program_t *program, const char *name, mat4x4 m) {
program_use(program);
GLint loc = glGetUniformLocation(program->id, name);
UNI_KILL(loc, name);
glUniformMatrix4fv(loc, 1, G
```
<Overlap Ratio: 0.8325581395348837>

---

--- 85 --
Question ID: 313e4b53faf172ec451a88fe90249707ccad0de2_2
Original Code:
```
i32_t kernel_color_print(char *str, u8_t color){
	/*
	 *
	 */
	boxfill8(binfo->vram, binfo->scrnx, BLACK,
		   length << 3, input_y + (indent << 4), (length << 3)+(strlen(str) << 3), (input_y + (indent << 4)+16));

	/*
	 *
	 */
	putfonts8_asc(binfo->vram, binfo->scrnx, length << 3, input_y + (indent << 4), color, str);

	length += strlen(str);

	return 1;
}
```


Overlapping Code:
```
or){
/*
*
*/
boxfill8(binfo->vram, binfo->scrnx, BLACK,
length << 3, input_y + (indent << 4), (length << 3)+(strlen(str) << 3), (input_y + (indent << 4)+16));
/*
*
*/
putfonts8_asc(binfo->vram, binfo->scrnx, length << 3, input_y + (indent << 4), color, str);
length += strlen(str);
return
```
<Overlap Ratio: 0.8595988538681948>

---

--- 86 --
Question ID: 270f0b67955f229728b2670123d284dd9d45697b_0
Original Code:
```
namespace Sys {
	int currentColor = c_white;
	int circleSmoothness = 75;
	void* defaultFont = GLUT_BITMAP_TIMES_ROMAN_24;
}
```


Overlapping Code:
```
e Sys {
int currentColor = c_white;
int circleSmoothness = 75;
void* defaultFont = GLUT_BITMAP_TIMES
```
<Overlap Ratio: 0.8333333333333334>

---

--- 87 --
Question ID: 6370deedc023aaf563b991fac53e4e66246f69c6_5
Original Code:
```
inline bool ScannerContext::Stream::ReadBoolean(bool* b, Status* status) {
  uint8_t* val;
  RETURN_IF_FALSE(ReadBytes(1, &val, status));
  *b = (*val != 0);
  return true;
}
```


Overlapping Code:
```
nline bool ScannerContext::Stream::ReadBoolean(bool* b, Status* status) {
uint8_t* val;
RETURN_IF_FALSE(ReadBytes(1, &val, status));
*b = (*val != 0);
return tru
```
<Overlap Ratio: 0.9698795180722891>

---

--- 88 --
Question ID: d4bf505ed16c3ea3d3e840ed8e9a052f8b2a6a6f_6
Original Code:
```
static __inline__ int
AG_WidgetMapSurfaceNODUP(void *obj, AG_Surface *su)
{
	AG_Widget *wid = (AG_Widget *)obj;
	int name;

	AG_ObjectLock(wid);
	if ((name = AG_WidgetMapSurface(wid, su)) != -1) {
		wid->surfaceFlags[name] |= AG_WIDGET_SURFACE_NODUP;
	}
	AG_ObjectUnlock(wid);
	return (name);
}
```


Overlapping Code:
```
__ int
AG_WidgetMapSurfaceNODUP(void *obj, AG_Surface *su)
{
AG_Widget *wid = (AG_Widget *)obj;
int name;
AG_ObjectLock(wid);
if ((name = AG_WidgetMapSurface(wid, su)) != -1) {
wid->surfaceFlags[name] |= AG_WIDGET_SURFACE_NODUP;
}
AG_ObjectUnlock(wid
```
<Overlap Ratio: 0.8802816901408451>

---

--- 89 --
Question ID: 96007633ad39b2e266fbc66c34e9eaf40a72ed1e_33
Original Code:
```
int megasas_wait_for_outstanding_fusion(struct megasas_instance *instance,
					int iotimeout, int *convert)
{
	int i, outstanding, retval = 0, hb_seconds_missed = 0;
	u32 fw_state;

	for (i = 0; i < resetwaittime; i++) {
		/* Check if firmware is in fault state */
		fw_state = instance->instancet->read_fw_status_reg(
			instance->reg_set) & MFI_STATE_MASK;
		if (fw_state == MFI_STATE_FAULT) {
			dev_warn(&instance->pdev->dev, "Found FW in FAULT state,"
			       " will reset adapter scsi%d.\n",
				instance->host->host_no);
			retval = 1;
			goto out;
		}
		/* If SR-IOV VF mode & heartbeat timeout, don't wait */
		if (instance->requestorId && !iotimeout) {
			retval = 1;
			goto out;
		}

		/* If SR-IOV VF mode & I/O timeout, check for HB timeout */
		if (instance->requestorId && iotimeout) {
			if (instance->hb_host_mem->HB.fwCounter !=
			    instance->hb_host_mem->HB.driverCounter) {
				instance->hb_host_mem->HB.driverCounter =
					instance->hb_host_mem->HB.fwCounter;
				hb_seconds_missed = 0;
			} else {
				hb_seconds_missed++;
				if (hb_seconds_missed ==
				    (MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {
					dev_warn(&instance->pdev->dev, "SR-IOV:"
					       " Heartbeat never completed "
					       " while polling during I/O "
					       " timeout handling for "
					       "scsi%d.\n",
					       instance->host->host_no);
					       *convert = 1;
					       retval = 1;
					       goto out;
				}
			}
		}

		outstanding = atomic_read(&instance->fw_outstanding);
		if (!outstanding)
			goto out;

		if (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {
			dev_notice(&instance->pdev->dev, "[%2d]waiting for %d "
			       "commands to complete for scsi%d\n", i,
			       outstanding, instance->host->host_no);
			megasas_complete_cmd_dpc_fusion(
				(unsigned long)instance);
		}
		msleep(1000);
	}

	if (atomic_read(&instance->fw_outstanding)) {
		dev_err(&instance->pdev->dev, "pending commands remain after waiting, "
		       "will reset adapter scsi%d.\n",
		       instance->host->host_no);
		*convert = 1;
		retval = 1;
	}
out:
	return retval;
}
```


Overlapping Code:
```
gasas_wait_for_outstanding_fusion(struct megasas_instance *instance,
int iotimeout, int *convert)
{
int i, outstanding, retval = 0, hb_seconds_missed = 0;
u32 fw_state;
for (i = 0; i < resetwaittime; i++) {
/* Check if firmware is in fault state */
fw_state = instance->instancet->read_fw_status_reg(
instance->reg_set) & MFI_STATE_MASK;
if (fw_state == MFI_STATE_FAULT) {
dev_warn(&instance->pdev->dev, "Found FW in FAULT state,"
" will reset adapter scsi%d.\n",
instance->host->host_no);
retval = 1;
goto out;
}
/* If SR-IOV VF mode & heartbeat timeout, don't wait */
if (instance->requestorId && !iotimeout) {
retval = 1;
goto out;
}
/* If SR-IOV VF mode & I/O timeout, check for HB timeout */
if (instance->requestorId && iotimeout) {
if (instance->hb_host_mem->HB.fwCounter !=
instance->hb_host_mem->HB.driverCounter) {
instance->hb_host_mem->HB.driverCounter =
instance->hb_host_mem->HB.fwCounter;
hb_seconds_missed = 0;
} else {
hb_seconds_missed++;
if (hb_seconds_missed ==
(MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF/HZ)) {
dev_warn(&instance->pdev->dev, "SR-IOV:"
" Heartbeat never completed "
" while polling during I/O "
" timeout handling for "
"scsi%d.\n",
instance->host->host_no);
*convert = 1;
retval = 1;
goto out;
}
}
}
outstanding = atomic_read(&instance->fw_outstanding);
if (!outstanding)
goto out;
if (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {
dev_notice(&instance->pdev->dev, "[%2d]waiting for %d "
"commands to complete for scsi%d\n", i,
outstanding, instance->host->host_no);
megasas_complete_cmd_dpc_fusion(
(unsigned long)instance);
}
msleep(1000);
}
if (atomic_read(&instance->fw_outstanding)) {
dev_err(&instance->pdev->dev, "pending commands remain after waiting, "
"will reset adapter scsi%d.\n",
instance->host->host_no);
*con
```
<Overlap Ratio: 0.971682398667407>

---

--- 90 --
Question ID: a14187605f5e477549b11143d5da129c55aec9b0_7
Original Code:
```
static struct at_state_t *at_state_from_cid(struct cardstate *cs, int cid)
{
	struct at_state_t *at_state;
	int i;
	unsigned long flags;

	if (cid == 0)
		return &cs->at_state;

	for (i = 0; i < cs->channels; ++i)
		if (cid == cs->bcs[i].at_state.cid)
			return &cs->bcs[i].at_state;

	spin_lock_irqsave(&cs->lock, flags);

	list_for_each_entry(at_state, &cs->temp_at_states, list)
		if (cid == at_state->cid) {
			spin_unlock_irqrestore(&cs->lock, flags);
			return at_state;
		}

	spin_unlock_irqrestore(&cs->lock, flags);

	return NULL;
}
```


Overlapping Code:
```
atic struct at_state_t *at_state_from_cid(struct cardstate *cs, int cid)
{
struct at_state_t *at_state;
int i;
unsigned long flags;
if (cid == 0)
return &cs->at_state;
for (i = 0; i < cs->channels; ++i)
if (cid == cs->bcs[i].at_state.cid)
return &cs->bcs[i].at_state;
spin_lock_irqsave(&cs->lock, flags);
list_for_each_entry(at_state, &cs->temp_at_states, list)
if (cid == at_state->cid) {
spin_unlock_irqrestore(&cs->lock, flags);
return at_state;
}
spin_unlock_irqrestore(&cs->lock, flags);
return 
```
<Overlap Ratio: 0.9823182711198428>

---

--- 91 --
Question ID: 82c8dbbc226b8607fd2d468b80230bde45c85467_0
Original Code:
```
class Serial
{
    private:
        USART_TypeDef* m_usart;
        Pin m_rxPin;
        Pin m_txPin;
        DmaChannel* m_dmaTxChannel;
        uint32_t m_bauds;

    public:
        Serial(USART_TypeDef* usart, Bank* bank, uint8_t rx, uint8_t tx, gpioPinSetting settings, uint32_t bauds) : m_usart(usart), m_rxPin(bank, rx, settings), m_txPin(bank, tx, settings), m_bauds(bauds) { }

        void serialSetup();
        void enableDmaTx(DMA_TypeDef* periph, DMA_Channel_TypeDef* channel);
        void print(const char* str, size_t len);
        void startDmaTx(char* address, size_t length);
        void clearDmaRegisters();
}
```


Overlapping Code:
```
SART_TypeDef* m_usart;
Pin m_rxPin;
Pin m_txPin;
DmaChannel* m_dmaTxChannel;
uint32_t m_bauds;
public:
Serial(USART_TypeDef* usart, Bank* bank, uint8_t rx, uint8_t tx, gpioPinSetting settings, uint32_t bauds) : m_usart(usart), m_rxPin(bank, rx, settings), m_txPin(bank, tx, settings), m_bauds(bauds) { }
void serialSetup();
void enableDmaTx(DMA_TypeDef* periph, DMA_Channel_TypeDef* channel);
void print(const char* str, size_t len);
void startDmaTx(char* address, size_t length);
void clearDmaRegist
```
<Overlap Ratio: 0.9380863039399625>

---

--- 92 --
Question ID: ed90302e9880aa43f62fb398a613a7a2232f4792_363
Original Code:
```
static inline VmathMatrix4 vmathM4MakeOrthographic_V(
    float left, float right, float bottom, float top, float zNear, float zFar)
{
    VmathMatrix4 result;
    vmathM4MakeOrthographic(&result, left, right, bottom, top, zNear, zFar);
    return result;
}
```


Overlapping Code:
```
atic inline VmathMatrix4 vmathM4MakeOrthographic_V(
float left, float right, float bottom, float top, float zNear, float zFar)
{
VmathMatrix4 result;
vmathM4MakeOrthographic(&result, left, right, bottom, top, zNear, zFar);
return result;
```
<Overlap Ratio: 0.983402489626556>

---

--- 93 --
Question ID: 307259e10a319785c9ef9274f80d2ddda83728e3_4
Original Code:
```
void uart0_send_uint32_hex(uint32_t number)
{
    char buf[9];
    uint32_to_cstring(number, buf, 16, 8);
    uart0_send_cstring(buf);
}
```


Overlapping Code:
```
x(uint32_t number)
{
char buf[9];
uint32_to_cstrin
```
<Overlap Ratio: 0.4032258064516129>

---

--- 94 --
Question ID: 2d794af3064d9b04f63e394ed9a792ae47a44a2c_5
Original Code:
```
bool obj_equals(obj* left, obj* right)
{
    // handle case where either or both are null
    if (left == NULL && right == NULL) return true; // both null means both equal
    else if (left == NULL || right == NULL)
        return false; // left or right only null means not equal

    // if the objects are of different type, then not equal
    if (left->type != right->type) { return false; }

    switch (left->type)
    {
        // case UIntNTuple_t: return tuple_equals(left->data, right->data);
        // case Dictionary_t: return dict_equals((dict*)left->data, (dict*)right->data);
        case Set_t: return set_equals((set*)left->data, (set*)right->data);
        case CharSet_t: return charset_equals(left->data, right->data);
        case Slot_t: return slot_equals(left->data, right->data);
        case MetaAST_t: return metaast_equals(left->data, right->data);
        case Slice_t: return slice_equals(left->data, right->data);
        case CRFClusterNode_t: return crf_cluster_node_equals(left->data, right->data);
        case CRFLabelNode_t: return crf_label_node_equals(left->data, right->data);
        case CRFActionHead_t: return crf_action_head_equals(left->data, right->data);
        case BSRHead_t: return bsr_head_equals(left->data, right->data);
        case Descriptor_t: return desc_equals(left->data, right->data);
        // case FSet_t: return fset_equals(left->data, right->data);
        default: return obj_compare(left, right) == 0;
    }

    // TODO->make this call equals directly for sets/dictionaries, as compare will be inefficient
}
```


Overlapping Code:
```
bool obj_equals(obj* left, obj* right)
{
// handle case where either or both are null
if (left == NULL && right == NULL) return true; // both null means both equal
else if (left == NULL || right == NULL)
return false; // left or right only null means not equal
// if the objects are of different type, then not equal
if (left->type != right->type) { return false; }
switch (left->type)
{
// case UIntNTuple_t: return tuple_equals(left->data, right->data);
// case Dictionary_t: return dict_equals((dict*)left->data, (dict*)right->data);
case Set_t: return set_equals((set*)left->data, (set*)right->data);
case CharSet_t: return charset_equals(left->data, right->data);
case Slot_t: return slot_equals(left->data, right->data);
case MetaAST_t: return metaast_equals(left->data, right->data);
case Slice_t: return slice_equals(left->data, right->data);
case CRFClusterNode_t: return crf_cluster_node_equals(left->data, right->data);
case CRFLabelNode_t: return crf_label_node_equals(left->data, right->data);
case CRFActionHead_t: return crf_action_head_equals(left->data, right->data);
case BSRHead_t: return bsr_head_equals(left->data, right->data);
case Descriptor_t: return desc_equals(left->data, right->data);
// case FSet_t: return fset_equals(left->data, right->data);
default: return obj_compare(left, right) == 0;
}
// TODO->make this call equals directly for sets/dictionaries, as compare wi
```
<Overlap Ratio: 0.9866102889358703>

---

--- 95 --
Question ID: aff1bb744bec7f30b36df8e9f2c1114893321408_23
Original Code:
```
int func_45(int iParam0)
{
	int iVar0;
	
	if (!unk_0x3D70CCF2C9B362CD(Local_85.f_3[iParam0 /*5*/].f_1))
	{
		return 0;
	}
	iVar0 = unk_0x3C6C6327BA564AEE(Local_85.f_3[iParam0 /*5*/].f_1);
	if (unk_0xA59F96B50B97E63C(iVar0, 0))
	{
		return 0;
	}
	if (!unk_0xAA5B806352173DEA(iVar0))
	{
		return 0;
	}
	return 1;
}
```


Overlapping Code:
```
)
{
int iVar0;

if (!unk_0x3D70CCF2C9B362CD(Local_85.f_3[iParam0 /*5*/].f_1))
{
return 0;
}
iVar0 = unk_0x3C6C6327BA564AEE(Local_85.f_3[iParam0 /*5*/].f_1);
if (unk_0xA59F96B50B97E63C(iVar0, 0))
{
return 0;
}
if (!unk_0xAA5B806352173DEA(iVar0))
{
return 0;
}
return 1;
```
<Overlap Ratio: 0.9146757679180887>

---

--- 96 --
Question ID: 2dc0924bb129a6c94913a4ff18116565386017b9_0
Original Code:
```
struct GenericList *reverseGenericList(struct GenericList *curr) {
    if (!curr)
        return NULL;

    struct GenericList *prev = NULL, *next = NULL;
    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}
```


Overlapping Code:
```
ct GenericList *curr) {
if (!curr)
return NULL;
struct GenericList *prev = NULL, *next = NULL;
while (curr != NULL) {
next = curr->next;
curr->next = prev;
prev = curr;
curr = next;
}
return prev;
}
```
<Overlap Ratio: 0.8215767634854771>

---

--- 97 --
Question ID: c18adaba347eff15cd60d9dbdf6a823c47827fd4_11
Original Code:
```
static int
hme_get_oldvpd_props(dev_info_t *dip, int vpd_base)
{
	struct hme *hmep;
	int vpd_start, vpd_len, kw_start, kw_len, kw_ptr;
	char kw_namestr[3];
	char kw_fieldstr[256];
	int i;

	hmep = ddi_get_driver_private(dip);

	vpd_start = vpd_base;

	if ((GET_ROM8(&hmep->hme_romp[vpd_start]) & 0xff) != 0x90) {
		return (1); /* error */
	} else {
		vpd_len = 9;
	}

	/* Get local-mac-address */
	kw_start = vpd_start + 3; /* Location of 1st keyword */
	kw_ptr = kw_start;
	while ((kw_ptr - kw_start) < vpd_len) { /* Get all keywords */
		kw_namestr[0] = GET_ROM8(&hmep->hme_romp[kw_ptr]);
		kw_namestr[1] = GET_ROM8(&hmep->hme_romp[kw_ptr+1]);
		kw_namestr[2] = '\0';
		kw_len = (int)(GET_ROM8(&hmep->hme_romp[kw_ptr+2]) & 0xff);
		for (i = 0, kw_ptr += 3; i < kw_len; i++)
			kw_fieldstr[i] = GET_ROM8(&hmep->hme_romp[kw_ptr+i]);
		kw_fieldstr[i] = '\0';
		if (hme_create_prop_from_kw(dip, kw_namestr, kw_fieldstr)) {
			return (DDI_FAILURE);
		}
		kw_ptr += kw_len;
	} /* next keyword */

	if (ddi_prop_create(DDI_DEV_T_NONE, dip, DDI_PROP_CANSLEEP, "model",
	    "SUNW,cheerio", strlen("SUNW,cheerio")+1) != DDI_SUCCESS) {
		return (DDI_FAILURE);
	}
	return (0);
}
```


Overlapping Code:
```
oldvpd_props(dev_info_t *dip, int vpd_base)
{
struct hme *hmep;
int vpd_start, vpd_len, kw_start, kw_len, kw_ptr;
char kw_namestr[3];
char kw_fieldstr[256];
int i;
hmep = ddi_get_driver_private(dip);
vpd_start = vpd_base;
if ((GET_ROM8(&hmep->hme_romp[vpd_start]) & 0xff) != 0x90) {
return (1); /* error */
} else {
vpd_len = 9;
}
/* Get local-mac-address */
kw_start = vpd_start + 3; /* Location of 1st keyword */
kw_ptr = kw_start;
while ((kw_ptr - kw_start) < vpd_len) { /* Get all keywords */
kw_namestr[0] = GET_ROM8(&hmep->hme_romp[kw_ptr]);
kw_namestr[1] = GET_ROM8(&hmep->hme_romp[kw_ptr+1]);
kw_namestr[2] = '\0';
kw_len = (int)(GET_ROM8(&hmep->hme_romp[kw_ptr+2]) & 0xff);
for (i = 0, kw_ptr += 3; i < kw_len; i++)
kw_fieldstr[i] = GET_ROM8(&hmep->hme_romp[kw_ptr+i]);
kw_fieldstr[i] = '\0';
if (hme_create_prop_from_kw(dip, kw_namestr, kw_fieldstr)) {
return (DDI_FAILURE);
}
kw_ptr += kw_len;
} /* next keyword */
if (ddi_prop_create(DDI_DEV_T_NONE, dip, DDI_PROP_CANSLEEP, "model",
"SUNW,cheerio", strlen("SUNW,cheerio")+1) != DDI_SUCCES
```
<Overlap Ratio: 0.9450945094509451>

---

--- 98 --
Question ID: 50294e07e60ca3fdc609ae6eaae73866d884b854_16
Original Code:
```
int split_indel_map(cigar32_t **res_cigar, int *res_len, int *res_m,
                    uint8_t *read_seq, int read_len, uint8_t *ref_seq, int ref_len, 
                    int ref_offset,
                    lamsa_aln_para *AP,
                    uint32_t **hash_num, uint64_t ***hash_node)
{
    int hash_len = AP->hash_len, key_len = AP->hash_key_len, hash_size = AP->hash_size;

	int32_t *hash_pos = (int32_t*)malloc(ref_len * sizeof(int32_t)); int **hash_node_num;
	init_hash(ref_seq, ref_len, hash_len, hash_num, hash_node, &hash_node_num, &hash_pos, key_len, hash_size);

	int res;
	res = hash_split_map(res_cigar, res_len, res_m, ref_seq, ref_len, ref_offset, read_seq, read_len, AP, *hash_num, *hash_node, hash_node_num, hash_pos, 1, 1);

	free(hash_pos);
	int i; for (i = 0; i < hash_size; ++i) free(hash_node_num[i]);
	free(hash_node_num);
	return res;
}
```


Overlapping Code:
```
lit_indel_map(cigar32_t **res_cigar, int *res_len, int *res_m,
uint8_t *read_seq, int read_len, uint8_t *ref_seq, int ref_len, 
int ref_offset,
lamsa_aln_para *AP,
uint32_t **hash_num, uint64_t ***hash_node)
{
int hash_len = AP->hash_len, key_len = AP->hash_key_len, hash_size = AP->hash_size;
int32_t *hash_pos = (int32_t*)malloc(ref_len * sizeof(int32_t)); int **hash_node_num;
init_hash(ref_seq, ref_len, hash_len, hash_num, hash_node, &hash_node_num, &hash_pos, key_len, hash_size);
int res;
res = hash_split_map(res_cigar, res_len, res_m, ref_seq, ref_len, ref_offset, read_seq, read_len, AP, *hash_num, *hash_node, hash_node_num, hash_pos, 1, 1);
free(hash_pos);
int i; for (i = 0; i < hash_size; ++i) free(hash_node_num[i]);
free(hash_node_num);
return res
```
<Overlap Ratio: 0.9883419689119171>

---

--- 99 --
Question ID: 410fd374357d756e78842e630ac6ec03b0caecf7_6
Original Code:
```
int serial_complete(int handle,uint32_t timeout)
{
    int size;
    utils_timer_t timer;
    serial_t *s;

    s =(serial_t *)handle;	 

    if (s->init == false){
        log_error("serial handle:%d not open.\r\n",handle);
        return -1;
    } 
    utils_timer_init(&timer,timeout,false);

    do {
        size = circle_buffer_used_size(&s->send);
        if (size != 0) {
            osDelay(1);
        }
    } while (utils_timer_value(&timer) > 0 && size != 0);

    return size;
}
```


Overlapping Code:
```
 handle,uint32_t timeout)
{
int size;
utils_timer_t timer;
serial_t *s;
s =(serial_t *)handle; 
if (s->init == false){
log_error("serial handle:%d not open.\r\n",handle);
return -1;
} 
utils_timer_init(&timer,timeout,false);
do {
size = circle_buffer_used_size(&s->send);
if (size != 0) {
osDelay(1);
}
} while (utils_timer_value(&timer) > 0 && size != 0);
return 
```
<Overlap Ratio: 0.9238578680203046>

---

--- 100 --
Question ID: ed46be8ca1e0c08b5f8d96b25424857487775ddb_16
Original Code:
```
static ngx_int_t
ngx_http_enhanced_memcached_process_request_set(ngx_http_request_t *r)
{
  ngx_http_enhanced_memcached_ctx_t  *ctx;

  ctx = ngx_http_get_module_ctx(r, ngx_http_enhanced_memcached_module);

  if (ctx->key_status != READY) {
    return ngx_http_enhanced_memcached_process_key(r);
  }

  return ngx_http_enhanced_memcached_process_request_return_string(r, "set", (u_char *) "STORED", sizeof("STORED") - 1, 409, "NOT_STORED", sizeof("NOT_STORED") - 1);
}
```


Overlapping Code:
```
tatic ngx_int_t
ngx_http_enhanced_memcached_process_request_set(ngx_http_request_t *r)
{
ngx_http_enhanced_memcached_ctx_t *ctx;
ctx = ngx_http_get_module_ctx(r, ngx_http_enhanced_memcached_module);
if (ctx->key_status != READY) {
return ngx_http_enhanced_memcached_process_key(r);
}
return ngx_http_enhanced_memcached_process_request_return_string(r, "set", (u_char *) "STORED", sizeof("STORED") - 1, 
```
<Overlap Ratio: 0.8933333333333333>

---

--- 101 --
Question ID: 9a9ec2f35448226043552e85455249304b8617ce_0
Original Code:
```
Snake *snakesInit()
{
    Snake *ret;
    if (!(ret = (Snake *)malloc(sizeof(Snake)))) {
        return NULL;
    }
    ret->head    = NULL;
    ret->newhead = NULL;
    ret->next    = NULL;
    return ret;
}
```


Overlapping Code:
```
Snake *ret;
if (!(ret = (Snake *)malloc(sizeof(Snake)))) {
return NULL;
}
ret->head = NULL;
ret->new
```
<Overlap Ratio: 0.6024096385542169>

---

--- 102 --
Question ID: 673a71fdced3f532dac77ae1566689e059650efd_3
Original Code:
```
API_RESULT cli_modelc_light_xyl_default_set(UINT32 argc, UCHAR * argv[])
{
    API_RESULT retval;
    int  choice;
    MS_LIGHT_XYL_DEFAULT_SET_STRUCT  param;

    CONSOLE_OUT
    (">> Send Light Xyl Default Set\n");

    if (3 == argc)
    {
        choice = CLI_strtoi(argv[0], CLI_strlen(argv[0]), 16);
        param.lightness = (UINT16)choice;
        CONSOLE_OUT("Lightness (16-bit in HEX): 0x%04X\n", param.lightness);

        choice = CLI_strtoi(argv[1], CLI_strlen(argv[1]), 16);
        param.xyl_x = (UINT16)choice;
        CONSOLE_OUT("xyL x (16-bit in HEX): 0x%04X\n", param.xyl_x);

        choice = CLI_strtoi(argv[2], CLI_strlen(argv[2]), 16);
        param.xyl_y = (UINT16)choice;
        CONSOLE_OUT("xyL y (16-bit in HEX): 0x%04X\n", param.xyl_y);
    }

    retval = MS_light_xyl_default_set(&param);

    CONSOLE_OUT
    ("retval = 0x%04X\n", retval);

    return retval;
}
```


Overlapping Code:
```
default_set(UINT32 argc, UCHAR * argv[])
{
API_RESULT retval;
int choice;
MS_LIGHT_XYL_DEFAULT_SET_STRUCT param;
CONSOLE_OUT
(">> Send Light Xyl Default Set\n");
if (3 == argc)
{
choice = CLI_strtoi(argv[0], CLI_strlen(argv[0]), 16);
param.lightness = (UINT16)choice;
CONSOLE_OUT("Lightness (16-bit in HEX): 0x%04X\n", param.lightness);
choice = CLI_strtoi(argv[1], CLI_strlen(argv[1]), 16);
param.xyl_x = (UINT16)choice;
CONSOLE_OUT("xyL x (16-bit in HEX): 0x%04X\n", param.xyl_x);
choice = CLI_strtoi(argv[2], CLI_strlen(argv[2]), 16);
param.xyl_y = (UINT16)choice;
CONSOLE_OUT("xyL y (16-bit in HEX): 0x%04X\n", param.xyl_y);
}
retval = MS_light_xyl_default_set(&param);
CONSOLE_OUT
("retval = 0x%04X\n", retval);
return retval;
}
```
<Overlap Ratio: 0.9581699346405229>

---

--- 103 --
Question ID: 0ca8bbc17e13f351cfdafa7072b5542063af3e12_12
Original Code:
```
static struct inode *
nfs3_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,
		 int flags)
{
	struct nfs_fh		fhandle;
	struct nfs_fattr	fattr;
	struct nfs_fattr	dir_attr;
	struct nfs3_createargs	arg = {
		.fh		= NFS_FH(dir),
		.name		= name->name,
		.len		= name->len,
		.sattr		= sattr,
	};
	struct nfs3_diropres	res = {
		.dir_attr	= &dir_attr,
		.fh		= &fhandle,
		.fattr		= &fattr
	};
	int			status;

	dprintk("NFS call  create %s\n", name->name);
	arg.createmode = NFS3_CREATE_UNCHECKED;
	if (flags & O_EXCL) {
		arg.createmode  = NFS3_CREATE_EXCLUSIVE;
		arg.verifier[0] = jiffies;
		arg.verifier[1] = current->pid;
	}

again:
	dir_attr.valid = 0;
	fattr.valid = 0;
	status = rpc_call(NFS_CLIENT(dir), NFS3PROC_CREATE, &arg, &res, 0);
	nfs_refresh_inode(dir, &dir_attr);

	/* If the server doesn't support the exclusive creation semantics,
	 * try again with simple 'guarded' mode. */
	if (status == NFSERR_NOTSUPP) {
		switch (arg.createmode) {
			case NFS3_CREATE_EXCLUSIVE:
				arg.createmode = NFS3_CREATE_GUARDED;
				break;

			case NFS3_CREATE_GUARDED:
				arg.createmode = NFS3_CREATE_UNCHECKED;
				break;

			case NFS3_CREATE_UNCHECKED:
				goto exit;
		}
		goto again;
	}

exit:
	dprintk("NFS reply create: %d\n", status);

	if (status != 0)
		goto out;
	if (fhandle.size == 0 || !(fattr.valid & NFS_ATTR_FATTR)) {
		status = nfs3_proc_lookup(dir, name, &fhandle, &fattr);
		if (status != 0)
			goto out;
	}

	/* When we created the file with exclusive semantics, make
	 * sure we set the attributes afterwards. */
	if (arg.createmode == NFS3_CREATE_EXCLUSIVE) {
		struct nfs3_sattrargs	arg = {
			.fh		= &fhandle,
			.sattr		= sattr,
		};
		dprintk("NFS call  setattr (post-create)\n");

		/* Note: we could use a guarded setattr here, but I'm
		 * not sure this buys us anything (and I'd have
		 * to revamp the NFSv3 XDR code) */
		fattr.valid = 0;
		status = rpc_call(NFS_CLIENT(dir), NFS3PROC_SETATTR,
						&arg, &fattr, 0);
		dprintk("NFS reply setattr (post-create): %d\n", status);
	}
	if (status == 0) {
		struct inode *inode;
		inode = nfs_fhget(dir->i_sb, &fhandle, &fattr);
		if (inode)
			return inode;
		status = -ENOMEM;
	}
out:
	return ERR_PTR(status);
}
```


Overlapping Code:
```

nfs3_proc_create(struct inode *dir, struct qstr *name, struct iattr *sattr,
int flags)
{
struct nfs_fh fhandle;
struct nfs_fattr fattr;
struct nfs_fattr dir_attr;
struct nfs3_createargs arg = {
.fh = NFS_FH(dir),
.name = name->name,
.len = name->len,
.sattr = sattr,
};
struct nfs3_diropres res = {
.dir_attr = &dir_attr,
.fh = &fhandle,
.fattr = &fattr
};
int status;
dprintk("NFS call create %s\n", name->name);
arg.createmode = NFS3_CREATE_UNCHECKED;
if (flags & O_EXCL) {
arg.createmode = NFS3_CREATE_EXCLUSIVE;
arg.verifier[0] = jiffies;
arg.verifier[1] = current->pid;
}
again:
dir_attr.valid = 0;
fattr.valid = 0;
status = rpc_call(NFS_CLIENT(dir), NFS3PROC_CREATE, &arg, &res, 0);
nfs_refresh_inode(dir, &dir_attr);
/* If the server doesn't support the exclusive creation semantics,
* try again with simple 'guarded' mode. */
if (status == NFSERR_NOTSUPP) {
switch (arg.createmode) {
case NFS3_CREATE_EXCLUSIVE:
arg.createmode = NFS3_CREATE_GUARDED;
break;
case NFS3_CREATE_GUARDED:
arg.createmode = NFS3_CREATE_UNCHECKED;
break;
case NFS3_CREATE_UNCHECKED:
goto exit;
}
goto again;
}
exit:
dprintk("NFS reply create: %d\n", status);
if (status != 0)
goto out;
if (fhandle.size == 0 || !(fattr.valid & NFS_ATTR_FATTR)) {
status = nfs3_proc_lookup(dir, name, &fhandle, &fattr);
if (status != 0)
goto out;
}
/* When we created the file with exclusive semantics, make
* sure we set the attributes afterwards. */
if (arg.createmode == NFS3_CREATE_EXCLUSIVE) {
struct nfs3_sattrargs arg = {
.fh = &fhandle,
.sattr = sattr,
};
dprintk("NFS call setattr (post-create)\n");
/* Note: we could use a guarded setattr here, but I'm
* not sure this buys us anything (and I'd have
* to revamp the NFSv3 XDR code) */
fattr.valid = 0;
status = rpc_call(NFS_CLIENT(dir), NFS3PROC_SETATTR,
&arg, &fattr, 0);
dprintk("NFS reply setattr (post-create): %d\n", status);
}
if (status == 0) {
struct inode *inode;
inode = nfs_fhget(dir->i_sb, &fhandle, &fattr);
if (inode)
return inode;
status = -ENOMEM;
}
out:
ret
```
<Overlap Ratio: 0.9789525208027411>

---

--- 104 --
Question ID: 7f497e2a2ff47035706db774f54a963cff35afae_4
Original Code:
```
static void containsAPI(WrenVM* vm)
{
  insert(vm);
  
  wrenEnsureSlots(vm, 1);
  wrenSetSlotString(vm, 1, "England");

  bool result = wrenGetMapContainsKey(vm, 0, 1);
  wrenSetSlotBool(vm, 0, result);
}
```


Overlapping Code:
```
vm);

wrenEnsureSlots(vm, 1);
wrenSetSlotString(vm, 1, "England");
bool result = wrenGetMapContainsKey(vm, 0, 1);
wrenSetSlotBool(vm, 0, re
```
<Overlap Ratio: 0.7239583333333334>

---

--- 105 --
Question ID: b20716700009f4c612b392955b4b7711defc3489_186
Original Code:
```
SWIGINTERN PyObject *_wrap_svn_repos_verify_fs2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
  PyObject *resultobj = 0;
  svn_repos_t *arg1 = (svn_repos_t *) 0 ;
  svn_revnum_t arg2 ;
  svn_revnum_t arg3 ;
  svn_repos_notify_func_t arg4 = (svn_repos_notify_func_t) 0 ;
  void *arg5 = (void *) 0 ;
  svn_cancel_func_t arg6 = (svn_cancel_func_t) 0 ;
  void *arg7 = (void *) 0 ;
  apr_pool_t *arg8 = (apr_pool_t *) 0 ;
  apr_pool_t *_global_pool = NULL ;
  PyObject *_global_py_pool = NULL ;
  PyObject * obj0 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  PyObject * obj4 = 0 ;
  PyObject * obj5 = 0 ;
  PyObject * obj6 = 0 ;
  PyObject * obj7 = 0 ;
  svn_error_t *result = 0 ;
  
  if (svn_swig_py_get_pool_arg(args, SWIGTYPE_p_apr_pool_t,
      &_global_py_pool, &_global_pool))
  SWIG_fail;
  arg8 = _global_pool;
  if (!PyArg_ParseTuple(args,(char *)"OOOOOOO|O:svn_repos_verify_fs2",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
  {
    arg1 = (svn_repos_t *)svn_swig_MustGetPtr(obj0, SWIGTYPE_p_svn_repos_t, svn_argnum_obj0);
    if (PyErr_Occurred()) {
      SWIG_fail;
    }
  }
  {
    arg2 = (svn_revnum_t)SWIG_As_long (obj1);
    if (SWIG_arg_fail(svn_argnum_obj1)) {
      SWIG_fail;
    }
  }
  {
    arg3 = (svn_revnum_t)SWIG_As_long (obj2);
    if (SWIG_arg_fail(svn_argnum_obj2)) {
      SWIG_fail;
    }
  }
  {
    svn_repos_notify_func_t * tmp =
    svn_swig_MustGetPtr(obj3, SWIGTYPE_p_p_f_p_void_p_q_const__struct_svn_repos_notify_t_p_apr_pool_t__void, svn_argnum_obj3);
    if (tmp == NULL || PyErr_Occurred()) {
      SWIG_fail;
    }
    arg4 = *tmp;
  }
  {
    if (obj4 == Py_None) {
      arg5 = NULL;
    } else if (SWIG_ConvertPtr(obj4, (void **) &arg5, 0, 0) == -1) {
      arg5 = (void *) obj4;
      PyErr_Clear();
    }
  }
  {
    svn_cancel_func_t * tmp =
    svn_swig_MustGetPtr(obj5, SWIGTYPE_p_p_f_p_void__p_svn_error_t, svn_argnum_obj5);
    if (tmp == NULL || PyErr_Occurred()) {
      SWIG_fail;
    }
    arg6 = *tmp;
  }
  {
    if (obj6 == Py_None) {
      arg7 = NULL;
    } else if (SWIG_ConvertPtr(obj6, (void **) &arg7, 0, 0) == -1) {
      arg7 = (void *) obj6;
      PyErr_Clear();
    }
  }
  if (obj7) {
    /* Verify that the user supplied a valid pool */
    if (obj7 != Py_None && obj7 != _global_py_pool) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(SWIGTYPE_p_apr_pool_t), obj7);
      SWIG_arg_fail(svn_argnum_obj7);
      SWIG_fail;
    }
  }
  {
    svn_swig_py_release_py_lock();
    
    result = (svn_error_t *)svn_repos_verify_fs2(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8);
    
    svn_swig_py_acquire_py_lock();
    
  }
  {
    if (result != NULL) {
      if (result->apr_err != SVN_ERR_SWIG_PY_EXCEPTION_SET)
      svn_swig_py_svn_exception(result);
      else
      svn_error_clear(result);
      SWIG_fail;
    }
    Py_INCREF(Py_None);
    resultobj = Py_None;
  }
  {
    Py_XDECREF(_global_py_pool);
  }
  return resultobj;
fail:
  {
    Py_XDECREF(_global_py_pool);
  }
  return NULL;
}
```


Overlapping Code:
```
p_svn_repos_verify_fs2(PyObject *SWIGUNUSEDPARM(self), PyObject *args) {
PyObject *resultobj = 0;
svn_repos_t *arg1 = (svn_repos_t *) 0 ;
svn_revnum_t arg2 ;
svn_revnum_t arg3 ;
svn_repos_notify_func_t arg4 = (svn_repos_notify_func_t) 0 ;
void *arg5 = (void *) 0 ;
svn_cancel_func_t arg6 = (svn_cancel_func_t) 0 ;
void *arg7 = (void *) 0 ;
apr_pool_t *arg8 = (apr_pool_t *) 0 ;
apr_pool_t *_global_pool = NULL ;
PyObject *_global_py_pool = NULL ;
PyObject * obj0 = 0 ;
PyObject * obj1 = 0 ;
PyObject * obj2 = 0 ;
PyObject * obj3 = 0 ;
PyObject * obj4 = 0 ;
PyObject * obj5 = 0 ;
PyObject * obj6 = 0 ;
PyObject * obj7 = 0 ;
svn_error_t *result = 0 ;

if (svn_swig_py_get_pool_arg(args, SWIGTYPE_p_apr_pool_t,
&_global_py_pool, &_global_pool))
SWIG_fail;
arg8 = _global_pool;
if (!PyArg_ParseTuple(args,(char *)"OOOOOOO|O:svn_repos_verify_fs2",&obj0,&obj1,&obj2,&obj3,&obj4,&obj5,&obj6,&obj7)) SWIG_fail;
{
arg1 = (svn_repos_t *)svn_swig_MustGetPtr(obj0, SWIGTYPE_p_svn_repos_t, svn_argnum_obj0);
if (PyErr_Occurred()) {
SWIG_fail;
}
}
{
arg2 = (svn_revnum_t)SWIG_As_long (obj1);
if (SWIG_arg_fail(svn_argnum_obj1)) {
SWIG_fail;
}
}
{
arg3 = (svn_revnum_t)SWIG_As_long (obj2);
if (SWIG_arg_fail(svn_argnum_obj2)) {
SWIG_fail;
}
}
{
svn_repos_notify_func_t * tmp =
svn_swig_MustGetPtr(obj3, SWIGTYPE_p_p_f_p_void_p_q_const__struct_svn_repos_notify_t_p_apr_pool_t__void, svn_argnum_obj3);
if (tmp == NULL || PyErr_Occurred()) {
SWIG_fail;
}
arg4 = *tmp;
}
{
if (obj4 == Py_None) {
arg5 = NULL;
} else if (SWIG_ConvertPtr(obj4, (void **) &arg5, 0, 0) == -1) {
arg5 = (void *) obj4;
PyErr_Clear();
}
}
{
svn_cancel_func_t * tmp =
svn_swig_MustGetPtr(obj5, SWIGTYPE_p_p_f_p_void__p_svn_error_t, svn_argnum_obj5);
if (tmp == NULL || PyErr_Occurred()) {
SWIG_fail;
}
arg6 = *tmp;
}
{
if (obj6 == Py_None) {
arg7 = NULL;
} else if (SWIG_ConvertPtr(obj6, (void **) &arg7, 0, 0) == -1) {
arg7 = (void *) obj6;
PyErr_Clear();
}
}
if (obj7) {
/* Verify that the user supplied a valid pool */
if (obj7 != Py_None && obj7 != _global_py_pool) {
SWIG_Python_TypeError(SWIG_TypePrettyName(SWIGTYPE_p_apr_pool_t), obj7);
SWIG_arg_fail(svn_argnum_obj7);
SWIG_fail;
}
}
{
svn_swig_py_release_py_lock();
```
<Overlap Ratio: 0.9886621315192744>

---

--- 106 --
Question ID: cf22026f08b6e47c9fb5fb70e26a4bf4f7d71cb3_165
Original Code:
```
GH_INLINE U8   GH_DEBUG_AUC_get_USBP_CTRL_compdistune(void)
{
    GH_DEBUG_AUC_USBP_CTRL_S tmp_value;
    U32 value = (*(volatile U32 *)REG_DEBUG_AUC_USBP_CTRL);

    tmp_value.all = value;
    #if GH_DEBUG_AUC_ENABLE_DEBUG_PRINT
    GH_DEBUG_AUC_DEBUG_PRINT_FUNCTION( "value = RDREG(0x%08x); \\\\ [GH_DEBUG_AUC_get_USBP_CTRL_compdistune] --> 0x%08x\n",
                        REG_DEBUG_AUC_USBP_CTRL,value);
    #endif
    return tmp_value.bitc.compdistune;
}
```


Overlapping Code:
```
USBP_CTRL_compdistune(void)
{
GH_DEBUG_AUC_USBP_CTRL_S tmp_value;
U32 value = (*(volatile U32 *)REG_DEBUG_AUC_USBP_CTRL);
tmp_value.all = value;
#if GH_DEBUG_AUC_ENABLE_DEBUG_PRINT
GH_DEBUG_AUC_DEBUG_PRINT_FUNCTION( "value = RDREG(0x%08x); \\\\ [GH_DEBUG_AUC_get_USBP_CTRL_compdistune] --> 0x%08x\n",
REG_DEBUG_AUC_USBP_CTRL,value);
#endif
return tmp_value.bitc.comp
```
<Overlap Ratio: 0.9014778325123153>

---

--- 107 --
Question ID: 49b7f22cf75146dba461a045461584f30a48ea88_1
Original Code:
```
int
dtrace_handle_drop(dtrace_hdl_t *dtp, dtrace_handle_drop_f *hdlr, void *arg)
{
	if (dtp->dt_drophdlr != NULL)
		return (dt_set_errno(dtp, EALREADY));

	dtp->dt_drophdlr = hdlr;
	dtp->dt_droparg = arg;

	return (0);
}
```


Overlapping Code:
```
le_drop(dtrace_hdl_t *dtp, dtrace_handle_drop_f *hdlr, void *arg)
{
if (dtp->dt_drophdlr != NULL)
return (dt_set_errno(dtp, EALREADY));
dtp->dt_drophd
```
<Overlap Ratio: 0.7075471698113207>

---

--- 108 --
Question ID: 2f43f279e2ad3c80cfcdfdff19ff1dd48bc7c956_1
Original Code:
```
static int cmp_pt(const void* a, const void* b)
{
    const Point* pa = (const Point*)a;
    const Point* pb = (const Point*)b;
    int d = pa->y - pb->y;
    return d ? d : (int)(pa->x - pb->x);
}
```


Overlapping Code:
```
_pt(const void* a, const void* b)
{
const Point* pa = (const Point*)a;
const Point* pb = (const Point*)b;
int d = pa->y - pb->y;
return d ? d : (int)(
```
<Overlap Ratio: 0.8287292817679558>

---

--- 109 --
Question ID: 34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_137
Original Code:
```
void smI5_nS0_CMockExpect(UNITY_LINE_TYPE cmock_line, SmInitialPseudoTest* const me)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smI5_nS0_CALL_INSTANCE));
  CMOCK_smI5_nS0_CALL_INSTANCE* cmock_call_instance = (CMOCK_smI5_nS0_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.smI5_nS0_CallInstance = CMock_Guts_MemChain(Mock.smI5_nS0_CallInstance, cmock_guts_index);
  Mock.smI5_nS0_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_smI5_nS0(cmock_call_instance, me);
  UNITY_CLR_DETAILS();
}
```


Overlapping Code:
```
0_CMockExpect(UNITY_LINE_TYPE cmock_line, SmInitialPseudoTest* const me)
{
CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_smI5_nS0_CALL_INSTANCE));
CMOCK_smI5_nS0_CALL_INSTANCE* cmock_call_instance = (CMOCK_smI5_nS0_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
Mock.smI5_nS0_CallInstance = CMock_Guts_MemChain(Mock.smI5_nS0_CallInstance, cmock_guts_index);
Mock.smI5_nS0_IgnoreBool = (int)0;
cmock_call_instance->LineNumber = cmock_line;
cmock_call_instance->CallOrder = ++GlobalExpectCount;
CMockExpectParameters_smI5_nS0(cmock_call_instance, me);
UNITY_CLR_DETAIL
```
<Overlap Ratio: 0.9765625>

---

--- 110 --
Question ID: 36f22233b58c1753a4c8371c2c97487cfa25ee99_65
Original Code:
```
void func_170()
{
	int iVar0;
	var uVar1;
	var uVar2;
	
	if (unk_0xCE990E643CD9D0E5(iLocal_122, 9))
	{
		if (unk_0xCE990E643CD9D0E5(iLocal_122, 8))
		{
			if (func_68(unk_0x460153A63B9477BC(), 1) || func_70() >= func_69())
			{
				func_90();
				return;
			}
			func_151(2, 224, 1);
			if (unk_0x1BD7199394D7F19A(2, 224))
			{
				iVar0 = iLocal_128;
				func_90();
				if (iVar0 == 0 && !func_64(unk_0x460153A63B9477BC()))
				{
					func_326();
				}
				else
				{
					func_324();
				}
				if (!func_62(unk_0x460153A63B9477BC()))
				{
					func_216(0, iVar0);
				}
				if (func_62(unk_0x460153A63B9477BC()))
				{
					unk_0xBE20AB8238688965(&iLocal_122, 10);
				}
			}
		}
	}
	if (unk_0xCE990E643CD9D0E5(iLocal_122, 10))
	{
		if (func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0) != 1)
		{
			if (func_74(unk_0x460153A63B9477BC()))
			{
				uVar1 = func_172();
				func_171("GB_BECOMEB", uVar1, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
			}
			else if (func_62(unk_0x460153A63B9477BC()))
			{
				uVar2 = func_172();
				if (func_64(unk_0x460153A63B9477BC()))
				{
					func_171("GB_BECOMEC", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
				}
				else
				{
					func_171("GB_BECOME", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
				}
			}
			unk_0xD2459066EA58CE43(&iLocal_122, 10);
		}
	}
}
```


Overlapping Code:
```
ar uVar2;

if (unk_0xCE990E643CD9D0E5(iLocal_122, 9))
{
if (unk_0xCE990E643CD9D0E5(iLocal_122, 8))
{
if (func_68(unk_0x460153A63B9477BC(), 1) || func_70() >= func_69())
{
func_90();
return;
}
func_151(2, 224, 1);
if (unk_0x1BD7199394D7F19A(2, 224))
{
iVar0 = iLocal_128;
func_90();
if (iVar0 == 0 && !func_64(unk_0x460153A63B9477BC()))
{
func_326();
}
else
{
func_324();
}
if (!func_62(unk_0x460153A63B9477BC()))
{
func_216(0, iVar0);
}
if (func_62(unk_0x460153A63B9477BC()))
{
unk_0xBE20AB8238688965(&iLocal_122, 10);
}
}
}
}
if (unk_0xCE990E643CD9D0E5(iLocal_122, 10))
{
if (func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0) != 1)
{
if (func_74(unk_0x460153A63B9477BC()))
{
uVar1 = func_172();
func_171("GB_BECOMEB", uVar1, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
}
else if (func_62(unk_0x460153A63B9477BC()))
{
uVar2 = func_172();
if (func_64(unk_0x460153A63B9477BC()))
{
func_171("GB_BECOMEC", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
}
else
{
func_171("GB_BECOME", uVar2, func_182(unk_0x460153A63B9477BC(), -2, 0, 0, 0), -1, 1);
}
}
unk_0xD2459066EA58CE43(&
```
<Overlap Ratio: 0.945829750644884>

---

--- 111 --
Question ID: ca4fbedf8fded10a6f240d075f22a9162c273f3c_0
Original Code:
```
static int
connect_tcp_ip(const char *host, int display)
{
	uint16_t port = libaxl_get_tcp_port(display);
	int fd;

	abort(); /* XXX */

	setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &(int){1}, sizeof(int));
	setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &(int){1}, sizeof(int));

	return -1;
}
```


Overlapping Code:
```
onst char *host, int display)
{
uint16_t port = libaxl_get_tcp_port(display);
int fd;
abort(); /* XXX */
setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &(int){1}, sizeof(int));
setsockopt(fd, SOL_SOCKET, SO_KEEPA
```
<Overlap Ratio: 0.7463768115942029>

---

--- 112 --
Question ID: 2013dc830e83b495362ba0c06aa44b17c37d556f_2
Original Code:
```
static int vrtimer_cb(timer_comp_t *tcomp, void *data) {
    vrtimer_comp_t *vrt = (vrtimer_comp_t *) data;
    vrtimer_t *pos;
    vrtimer_t *tmp;

    abstick_t curticks;
    if (vrt->hrtimer->ops.get_value(vrt->hrtimer, &curticks) < 0) {
        error_async("Failed to read hrtimer value");
        return -1;
    }

    irqctx_t ctx;
    spinlock_acquire(&vrt->lock, &ctx);

    list_for_each_entry_safe(pos, tmp, &vrt->timers, list) {
        if (curticks >= pos->abs_ticks) {
            insane_async("vrtimer id=0x%p abs_ticks=%lu expired", pos, (uint32_t) pos->abs_ticks);

            // Execute timer callback
            if (pos->cb(vrt, pos->data) < 0) {
                error_async("Error while executing vrtimer callback at 0x%p", pos->cb);
            }

            list_del_init(&pos->list);
            if (pos->periodic) {
                pos->abs_ticks = curticks + pos->ticks;
                add_vrtimer_sorted_locked(vrt, pos);
            } else {
                free(pos);
            }
        } else {
            break;
        }
    }

    update_expiration_locked(vrt);

    spinlock_release(&vrt->lock, &ctx);

    return 0;
}
```


Overlapping Code:
```
d *data) {
vrtimer_comp_t *vrt = (vrtimer_comp_t *) data;
vrtimer_t *pos;
vrtimer_t *tmp;
abstick_t curticks;
if (vrt->hrtimer->ops.get_value(vrt->hrtimer, &curticks) < 0) {
error_async("Failed to read hrtimer value");
return -1;
}
irqctx_t ctx;
spinlock_acquire(&vrt->lock, &ctx);
list_for_each_entry_safe(pos, tmp, &vrt->timers, list) {
if (curticks >= pos->abs_ticks) {
insane_async("vrtimer id=0x%p abs_ticks=%lu expired", pos, (uint32_t) pos->abs_ticks);
// Execute timer callback
if (pos->cb(vrt, pos->data) < 0) {
error_async("Error while executing vrtimer callback at 0x%p", pos->cb);
}
list_del_init(&pos->list);
if (pos->periodic) {
pos->abs_ticks = curticks + pos->ticks;
add_vrtimer_sorted_locked(vrt, pos);
} else {
free(pos);
}
} else {
break;
}
}
update_expiration_locked(vrt);
spinloc
```
<Overlap Ratio: 0.9029345372460497>

---

--- 113 --
Question ID: 306be2ff0d815abd3a0fa87c00f3887dac0327d3_0
Original Code:
```
int main(int argc, char *argv[]) {
	FILE *fp;
	int a, b[600];
	unsigned i, n;
	char c;

	if (argc != 2) {
		printf("Usage: %s [FILE]\n", argv[0]);
		return 1;
	}
	fp = fopen(*++argv, "r");
	do {
		c = getc(fp);
	} while (c != ',' && c != EOF);
	while (fscanf(fp, "%d", &a) != EOF) {
		b[0] = a;
		n = 1;
		while (getc(fp) == ';' && getc(fp) == ' ') {
			do {
				c = getc(fp);
			} while (c != ',' && c != EOF);
			if (fscanf(fp, "%d", &b[n++]) == EOF)
				goto fail_eof;
		}
		qsort(&b, n, sizeof(int), cmpint);
		for (i = n - 1; i > 0; i--) {
			b[i] -= b[i - 1];
		}
		printf("%d", b[0]);
		for (i = 1; i < n; i++) {
			printf(",%d", b[i]);
		}
		printf("\n");
		do {
			c = getc(fp);
		} while (c != ',' && c != EOF);
	}
	return 0;
fail_eof:
	printf("unexpected end of input\n");
	return EXIT_FAILURE;
}
```


Overlapping Code:
```
nt argc, char *argv[]) {
FILE *fp;
int a, b[600];
unsigned i, n;
char c;
if (argc != 2) {
printf("Usage: %s [FILE]\n", argv[0]);
return 1;
}
fp = fopen(*++argv, "r");
do {
c = getc(fp);
} while (c != ',' && c != EOF);
while (fscanf(fp, "%d", &a) != EOF) {
b[0] = a;
n = 1;
while (getc(fp) == ';' && getc(fp) == ' ') {
do {
c = getc(fp);
} while (c != ',' && c != EOF);
if (fscanf(fp, "%d", &b[n++]) == EOF)
goto fail_eof;
}
qsort(&b, n, sizeof(int), cmpint);
for (i = n - 1; i > 0; i--) {
b[i] -= b[i - 1];
}
printf("%d", b[0]);
for (i = 1; i < n; i++) {
printf(",%d", b[i]);
}
printf("\n");
do {
c = getc(fp);
} while (c != ',' && c != EOF);
}
return 0;
fail_eof:
printf("unexpected end of input\n");
return E
```
<Overlap Ratio: 0.9673024523160763>

---

--- 114 --
Question ID: d7887cef2c685941b35246436d6ef3aa6893e8ee_4
Original Code:
```
int main(int argc, char **argv) {
	int c, whitespace_flag = 0;
	size_t blocklen_min = 4, start = 0, end = -1;
	while((c = getopt(argc, argv, "wi:s:e:a:")) != -1) switch(c) {
		case 'w': whitespace_flag = 1; break;
		case 'i': blocklen_min = atoi(optarg); break;
		case 's': start = atoi(optarg); break;
		case 'e': end = atoi(optarg); break;
		case 'a': atime = atoi(optarg); break;
		default: return usage(argv[0]);
	}
	if(!argv[optind]) return usage(argv[0]);
	FILE *f = argv[optind][0] == '-' && !argv[optind][1] ? stdin : fopen(argv[optind], "r");
	if(!f) {
		perror("fopen");
		return 1;
	}
	stdout_is_tty = isatty(fileno(stdout));
	struct sortitem { int dupes; int lineno; };
	tglist(unsigned) hashlist;
	tglist(char*) strlist;
	typedef tglist(struct sortitem) sortitem_list; /* we need a named type to prevent pointer type mismatch warnings */
	hbmap(int, sortitem_list*, 1024) dupes;
	tglist_init(&hashlist);
	tglist_init(&strlist);
	hbmap_init(&dupes, intcmp, inthash);
	char buf[1024];
	size_t i = 0;
	while(fgets(buf, sizeof buf, f)) {
		++i;
		if(i - 1 < start) continue;
		if(end != (size_t) -1 && i >= end) break;
		char *p = buf, *q = strrchr(p, '\n');
		if(q) *q = 0;
		if(whitespace_flag) while(isspace(*p)) p++;
		unsigned hash = string_hash(p);
		tglist_add(&hashlist, hash);
		tglist_add(&strlist, strdup(p));
		assert(tglist_getsize(&strlist) == i - start);
		assert(tglist_getsize(&strlist) == tglist_getsize(&hashlist));
		assert(!strcmp(p, tglist_get(&strlist, i-start-1)));
	}
	size_t linecount = tglist_getsize(&hashlist);
	size_t bl;
	nl = linecount;

	if(atime) {
		signal(SIGALRM, sigh);
		alarm(atime);
	}

	//for(bl = blocklen_max; bl >= blocklen_min; bl--) {
	for(bl = blocklen_min; bl < blocklen_min+1; bl++) {
		for(i = 0; i < linecount; ) {
			hbmap_iter hi;
			int dupe_count = 0, longest_dupe = 0;
			size_t j, h, last_dupe = 0;
			for(j = i + bl; j + bl < linecount; ) {
#define HL(X) tglist_get(&hashlist, X)
#define SL(X) tglist_get(&strlist, X)
				for(h = 0; h < bl; ++h) {
					if(!line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))
						break;
				}
				if(h == bl) {
					/* look if the dupe is actually longer */
					while(j+h < linecount && i+h < j && line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))
						h++;
					sortitem_list* dlist = 0;
					hi = hbmap_find(&dupes, i);

					if(hi == (hbmap_iter) -1)
						dlist = tglist_new();
					else
						dlist = hbmap_getval(&dupes, hi);

					struct sortitem tmp = {.dupes = h, .lineno = j};
					tglist_insert_sorted(dlist, tmp, sortitem_cmp);

					if(hi == (hbmap_iter) -1)
						hbmap_insert(&dupes, i, dlist);

					last_dupe = j;
					if(h > longest_dupe) longest_dupe = h;
					++dupe_count;

				}
				j+= h ? h : 1;
			}
			i += dupe_count ? longest_dupe : 1;
			cl = i;
		}
	}
	hbmap_iter hi;
	sortitem_list si_list;
	tglist_init(&si_list);
	hbmap_foreach(&dupes, hi) {
		int longest = 0;
		sortitem_list*dlist = hbmap_getval(&dupes, hi);
		tglist_foreach(dlist, i) {
			struct sortitem *si = &tglist_get(dlist, i);
			if(si->dupes > longest) longest = si->dupes;
		}
		assert(longest == tglist_get(dlist, 0).dupes);
		struct sortitem si = {.dupes = longest, .lineno = hbmap_getkey(&dupes, hi)};
		tglist_insert_sorted(&si_list, si, sortitem_cmp);
	}
	for(i = 0; i < tglist_getsize(&si_list); i++) {
		struct sortitem *si = &tglist_get(&si_list, i);
		hi = hbmap_find(&dupes, si->lineno);
		sortitem_list *dlist = hbmap_getval(&dupes, hi);
		int j, cnt = 0;
		tglist_foreach(dlist, j) {
			if(tglist_get(dlist, j).dupes < si->dupes) break;
			++cnt;
		}
		if(neednl && stdout_is_tty) {
			dprintf(2, "\n");
			neednl = 0;
		}
		printf("[DUP] %d lines at %d: %d dupes (", si->dupes, (int) start + si->lineno, cnt);
		for(j = 0; j < cnt; ++j)
			printf("%d%s", (int) start + tglist_get(dlist, j).lineno, j == cnt -1 ? ")\n" : ", ");
		for(j = 0; j < si->dupes; j++)
			printf("%s\n", tglist_get(&strlist, si->lineno+j));
	}
	if(f != stdin) fclose(f);
	if(neednl) dprintf(2, "\n");
	return 0;
}
```


Overlapping Code:
```
c, char **argv) {
int c, whitespace_flag = 0;
size_t blocklen_min = 4, start = 0, end = -1;
while((c = getopt(argc, argv, "wi:s:e:a:")) != -1) switch(c) {
case 'w': whitespace_flag = 1; break;
case 'i': blocklen_min = atoi(optarg); break;
case 's': start = atoi(optarg); break;
case 'e': end = atoi(optarg); break;
case 'a': atime = atoi(optarg); break;
default: return usage(argv[0]);
}
if(!argv[optind]) return usage(argv[0]);
FILE *f = argv[optind][0] == '-' && !argv[optind][1] ? stdin : fopen(argv[optind], "r");
if(!f) {
perror("fopen");
return 1;
}
stdout_is_tty = isatty(fileno(stdout));
struct sortitem { int dupes; int lineno; };
tglist(unsigned) hashlist;
tglist(char*) strlist;
typedef tglist(struct sortitem) sortitem_list; /* we need a named type to prevent pointer type mismatch warnings */
hbmap(int, sortitem_list*, 1024) dupes;
tglist_init(&hashlist);
tglist_init(&strlist);
hbmap_init(&dupes, intcmp, inthash);
char buf[1024];
size_t i = 0;
while(fgets(buf, sizeof buf, f)) {
++i;
if(i - 1 < start) continue;
if(end != (size_t) -1 && i >= end) break;
char *p = buf, *q = strrchr(p, '\n');
if(q) *q = 0;
if(whitespace_flag) while(isspace(*p)) p++;
unsigned hash = string_hash(p);
tglist_add(&hashlist, hash);
tglist_add(&strlist, strdup(p));
assert(tglist_getsize(&strlist) == i - start);
assert(tglist_getsize(&strlist) == tglist_getsize(&hashlist));
assert(!strcmp(p, tglist_get(&strlist, i-start-1)));
}
size_t linecount = tglist_getsize(&hashlist);
size_t bl;
nl = linecount;
if(atime) {
signal(SIGALRM, sigh);
alarm(atime);
}
//for(bl = blocklen_max; bl >= blocklen_min; bl--) {
for(bl = blocklen_min; bl < blocklen_min+1; bl++) {
for(i = 0; i < linecount; ) {
hbmap_iter hi;
int dupe_count = 0, longest_dupe = 0;
size_t j, h, last_dupe = 0;
for(j = i + bl; j + bl < linecount; ) {
#define HL(X) tglist_get(&hashlist, X)
#define SL(X) tglist_get(&strlist, X)
for(h = 0; h < bl; ++h) {
if(!line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))
break;
}
if(h == bl) {
/* look if the dupe is actually longer */
while(j+h < linecount && i+h < j && line_equal(HL(i+h), SL(i+h), HL(j+h), SL(j+h)))
h++;
sortitem_list* dlist = 0;
hi = hbmap_find(&dupes, i);
if(hi == (hbmap_iter) -1)
dlist 
```
<Overlap Ratio: 0.9713024282560706>

---

--- 115 --
Question ID: 2c8fdfef0d7590d0dd22db3c662f3c7fc9b833a6_3
Original Code:
```
errval_t lmp_endpoint_create_in_slot(size_t buflen, struct capref dest,
                                     struct lmp_endpoint **retep)
{
    struct lmp_endpoint *ep = NULL;
    errval_t err;

    // We increase buflen by 1 here to accomodate for in-kernel sentinel word
    buflen++;

    err = lmp_endpoint_alloc(buflen, &ep);
    if (err_is_fail(err)) {
        return err;
    }

    assert(ep != NULL);
    if (retep != NULL) {
        *retep = ep;
    }

    uintptr_t epoffset = (uintptr_t)&ep->k - (uintptr_t)curdispatcher();

    // mint new badged cap from our existing reply endpoint
    return cap_mint(dest, cap_selfep, epoffset, buflen);
}
```


Overlapping Code:
```
_endpoint_create_in_slot(size_t buflen, struct capref dest,
struct lmp_endpoint **retep)
{
struct lmp_endpoint *ep = NULL;
errval_t err;
// We increase buflen by 1 here to accomodate for in-kernel sentinel word
buflen++;
err = lmp_endpoint_alloc(buflen, &ep);
if (err_is_fail(err)) {
return err;
}
assert(ep != NULL);
if (retep != NULL) {
*retep = ep;
}
uintptr_t epoffset = (uintptr_t)&ep->k - (uintptr_t)curdispatcher();
// mint new badged cap from our existing reply endpoint
return cap_mint(dest, cap_selfep, epoffs
```
<Overlap Ratio: 0.9522935779816514>

---

--- 116 --
Question ID: f227261283585d094b7418f31229359ac17e44ef_0
Original Code:
```
void main()
{
 int a[10],min,max,n;
 printf("enter size of array\n");
 scanf("%d",&n);
 printf("enter array elements\n");
 for(int i=0;i<n;i++)
 {
  scanf("%d",&a[i]);
 }
 minmax(a,n,&min,&max);
  printf("min=%d and max=%d\n", min,max);
}
```


Overlapping Code:
```
min,max,n;
printf("enter size of array\n");
scanf("%d",&n);
printf("enter array elements\n");
for(int i=0;i<n;i++)
{
scanf("%d",&a[i]);
}
minmax(a,n,&min,&max);
printf("min=%d and max=%d\n", min,max);
```
<Overlap Ratio: 0.8849557522123894>

---

--- 117 --
Question ID: 2ccbee50cb69171062e84c9a1b36baf7e31be2f8_2
Original Code:
```
int userdiff_config(const char *k, const char *v)
{
	struct userdiff_driver *drv;
	const char *name, *type;
	int namelen;

	if (parse_config_key(k, "diff", &name, &namelen, &type) || !name)
		return 0;

	drv = userdiff_find_by_namelen(name, namelen);
	if (!drv) {
		ALLOC_GROW(drivers, ndrivers+1, drivers_alloc);
		drv = &drivers[ndrivers++];
		memset(drv, 0, sizeof(*drv));
		drv->name = xmemdupz(name, namelen);
		drv->binary = -1;
	}

	if (!strcmp(type, "funcname"))
		return parse_funcname(&drv->funcname, k, v, 0);
	if (!strcmp(type, "xfuncname"))
		return parse_funcname(&drv->funcname, k, v, REG_EXTENDED);
	if (!strcmp(type, "binary"))
		return parse_tristate(&drv->binary, k, v);
	if (!strcmp(type, "command"))
		return git_config_string(&drv->external, k, v);
	if (!strcmp(type, "textconv"))
		return git_config_string(&drv->textconv, k, v);
	if (!strcmp(type, "cachetextconv"))
		return parse_bool(&drv->textconv_want_cache, k, v);
	if (!strcmp(type, "wordregex"))
		return git_config_string(&drv->word_regex, k, v);

	return 0;
}
```


Overlapping Code:
```
r *k, const char *v)
{
struct userdiff_driver *drv;
const char *name, *type;
int namelen;
if (parse_config_key(k, "diff", &name, &namelen, &type) || !name)
return 0;
drv = userdiff_find_by_namelen(name, namelen);
if (!drv) {
ALLOC_GROW(drivers, ndrivers+1, drivers_alloc);
drv = &drivers[ndrivers++];
memset(drv, 0, sizeof(*drv));
drv->name = xmemdupz(name, namelen);
drv->binary = -1;
}
if (!strcmp(type, "funcname"))
return parse_funcname(&drv->funcname, k, v, 0);
if (!strcmp(type, "xfuncname"))
return parse_funcname(&drv->funcname, k, v, REG_EXTENDED);
if (!strcmp(type, "binary"))
return parse_tristate(&drv->binary, k, v);
if (!strcmp(type, "command"))
return git_config_string(&drv->external, k, v);
if (!strcmp(type, "textconv"))
return git_config_string(&drv->textconv, k, v);
if (!strcmp(type, "cachetextconv"))
return parse_bool(&drv->textconv_want_cache, k, v);
if (!strcmp(type, "wordregex"))
return git_config_string(&drv->word_regex, 
```
<Overlap Ratio: 0.9528585757271816>

---

--- 118 --
Question ID: 5ef2f4e9c9d2995460918eab82a4377154b7dac8_2
Original Code:
```
h2o_t h2o_new_px(double p, double x)
{
	h2o_t ret;
	enum h2o_region region = h2o_region_px(p, x);

	switch (region)
	{
		case H2O_REGION_OUT_OF_RANGE:
			break;
		case H2O_REGION4:
			ret._arg1 = h2o_region4_T_p(p);
			ret._arg2 = x;
			break;
		default:
			assert(not_reached);
	}
	ret.region = region;

	return ret;
}
```


Overlapping Code:
```
e x)
{
h2o_t ret;
enum h2o_region region = h2o_region_px(p, x);
switch (region)
{
case H2O_REGION_OUT_OF_RANGE:
break;
case H2O_REGION4:
ret._arg1 = h2o_region4_T_p(p);
ret._arg2 = x;
break;
default:
assert(not_reached);
}
ret.region = region;
return
```
<Overlap Ratio: 0.8650519031141869>

---

--- 119 --
Question ID: 65513d0308003398acbc48328e651b2a314e53e0_100
Original Code:
```
void UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL(struct UPnPService *service,void (*CallbackPtr)(struct UPnPService*,int,void*,char*), void* user, char* ReqEncoding, char* ReqCompression, char* ReqResolution)
{
	int headerLength;
	char *headerBuffer;
	char *SoapBodyTemplate;
	char* buffer;
	int bufferLength;
	char* IP;
	unsigned short Port;
	char* Path;
	struct sockaddr_in addr;
	struct InvokeStruct *invoke_data = (struct InvokeStruct*)MALLOC(sizeof(struct InvokeStruct));
	
	if(service==NULL)
	{
		FREE(invoke_data);
		return;
	}
	buffer = (char*)MALLOC((int)strlen(service->ServiceType)+(int)strlen(ReqEncoding)+(int)strlen(ReqCompression)+(int)strlen(ReqResolution)+369);
	SoapBodyTemplate = "%sGetImagePresentationURL xmlns:u=\"%s\"><ReqEncoding>%s</ReqEncoding><ReqCompression>%s</ReqCompression><ReqResolution>%s</ReqResolution></u:GetImagePresentationURL%s";
	bufferLength = sprintf(buffer,SoapBodyTemplate,UPNPCP_SOAP_BodyHead,service->ServiceType, ReqEncoding, ReqCompression, ReqResolution,UPNPCP_SOAP_BodyTail);
	
	UPnPAddRef(service->Parent);
	ILibParseUri(service->ControlURL,&IP,&Port,&Path);
	
	headerBuffer = (char*)MALLOC(178 + (int)strlen(Path) + (int)strlen(IP) + (int)strlen(service->ServiceType));
	headerLength = sprintf(headerBuffer,UPNPCP_SOAP_Header,Path,IP,Port,service->ServiceType,"GetImagePresentationURL",bufferLength);
	
	memset((char *)&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = inet_addr(IP);
	addr.sin_port = htons(Port);
	
	invoke_data->CallbackPtr = CallbackPtr;
	invoke_data->User = user;
	ILibAddRequest_DirectEx(((struct UPnPCP*)service->Parent->CP)->HTTP, headerBuffer,headerLength,buffer,bufferLength,&addr, &UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL_Sink,service, invoke_data);	
	
	FREE(IP);
	FREE(Path);
}
```


Overlapping Code:
```
void UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL(struct UPnPService *service,void (*CallbackPtr)(struct UPnPService*,int,void*,char*), void* user, char* ReqEncoding, char* ReqCompression, char* ReqResolution)
{
int headerLength;
char *headerBuffer;
char *SoapBodyTemplate;
char* buffer;
int bufferLength;
char* IP;
unsigned short Port;
char* Path;
struct sockaddr_in addr;
struct InvokeStruct *invoke_data = (struct InvokeStruct*)MALLOC(sizeof(struct InvokeStruct));

if(service==NULL)
{
FREE(invoke_data);
return;
}
buffer = (char*)MALLOC((int)strlen(service->ServiceType)+(int)strlen(ReqEncoding)+(int)strlen(ReqCompression)+(int)strlen(ReqResolution)+369);
SoapBodyTemplate = "%sGetImagePresentationURL xmlns:u=\"%s\"><ReqEncoding>%s</ReqEncoding><ReqCompression>%s</ReqCompression><ReqResolution>%s</ReqResolution></u:GetImagePresentationURL%s";
bufferLength = sprintf(buffer,SoapBodyTemplate,UPNPCP_SOAP_BodyHead,service->ServiceType, ReqEncoding, ReqCompression, ReqResolution,UPNPCP_SOAP_BodyTail);

UPnPAddRef(service->Parent);
ILibParseUri(service->ControlURL,&IP,&Port,&Path);

headerBuffer = (char*)MALLOC(178 + (int)strlen(Path) + (int)strlen(IP) + (int)strlen(service->ServiceType));
headerLength = sprintf(headerBuffer,UPNPCP_SOAP_Header,Path,IP,Port,service->ServiceType,"GetImagePresentationURL",bufferLength);

memset((char *)&addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_addr.s_addr = inet_addr(IP);
addr.sin_port = htons(Port);

invoke_data->CallbackPtr = CallbackPtr;
invoke_data->User = user;
ILibAddRequest_DirectEx(((struct UPnPCP*)service->Parent->CP)->HTTP, headerBuffer,headerLength,buffer,bufferLength,&addr, &UPnPInvoke_DigitalSecurityCameraStillImage_GetImagePresentationURL_Sink,service, invoke_data); 

FREE(IP);
FREE(Path);

```
<Overlap Ratio: 0.9994428969359331>

---

--- 120 --
Question ID: c0691f2959983dfc610c0cdf55e0c1da6f60c4e7_2
Original Code:
```
void linkedListRemove(struct LinkedListNode* node) {
    node->next->prev = node->prev;
    node->prev->next = node->next;
    free(node);
}
```


Overlapping Code:
```
dListRemove(struct LinkedListNode* node) {
node->next->prev = node->prev;
node->prev->next = node->next;

```
<Overlap Ratio: 0.8203125>

---

--- 121 --
Question ID: f578896bece271678209febd3701e4c76f33b7fd_16
Original Code:
```
int
posix_spawnattr_getflags(
	const posix_spawnattr_t *attr,
	short *flags)
{
	spawn_attr_t *sap = attr->__spawn_attrp;

	if (sap == NULL)
		return (EINVAL);

	*flags = sap->sa_psflags;
	return (0);
}
```


Overlapping Code:
```
_spawnattr_t *attr,
short *flags)
{
spawn_attr_t *sap = attr->__spawn_attrp;
if (sap == NULL)
return (EINVAL);
*flags = sap->sa_psflags;
return (0);
}
```
<Overlap Ratio: 0.7853403141361257>

---

--- 122 --
Question ID: 9b397418e51039d234ab999c52e3425c9d1b888a_11
Original Code:
```
static int row_get_ioprio_class_to_serve(struct row_data *rd, int force)
{
	int i;
	int ret = IOPRIO_CLASS_NONE;

	if (!rd->nr_reqs[READ] && !rd->nr_reqs[WRITE]) {
		row_log(rd->dispatch_queue, "No more requests in scheduler");
		goto check_idling;
	}

	/* First, go over the high priority queues */
	for (i = 0; i < ROWQ_REG_PRIO_IDX; i++) {
		if (!list_empty(&rd->row_queues[i].fifo)) {
			if (hrtimer_active(&rd->rd_idle_data.hr_timer)) {
				if (hrtimer_try_to_cancel(
					&rd->rd_idle_data.hr_timer) >= 0) {
					row_log(rd->dispatch_queue,
					"Canceling delayed work on %d. RT pending",
					     rd->rd_idle_data.idling_queue_idx);
					rd->rd_idle_data.idling_queue_idx =
						ROWQ_MAX_PRIO;
				}
			}

			if (row_regular_req_pending(rd) &&
			    (rd->reg_prio_starvation.starvation_counter >=
			     rd->reg_prio_starvation.starvation_limit))
				ret = IOPRIO_CLASS_BE;
			else if (row_low_req_pending(rd) &&
			    (rd->low_prio_starvation.starvation_counter >=
			     rd->low_prio_starvation.starvation_limit))
				ret = IOPRIO_CLASS_IDLE;
			else
				ret = IOPRIO_CLASS_RT;

			goto done;
		}
	}

	/*
	 * At the moment idling is implemented only for READ queues.
	 * If enabled on WRITE, this needs updating
	 */
	if (hrtimer_active(&rd->rd_idle_data.hr_timer)) {
		row_log(rd->dispatch_queue, "Delayed work pending. Exiting");
		goto done;
	}
check_idling:
	/* Check for (high priority) idling and enable if needed */
	for (i = 0; i < ROWQ_REG_PRIO_IDX && !force; i++) {
		if (rd->row_queues[i].idle_data.begin_idling &&
		    row_queues_def[i].idling_enabled)
			goto initiate_idling;
	}

	/* Regular priority queues */
	for (i = ROWQ_REG_PRIO_IDX; i < ROWQ_LOW_PRIO_IDX; i++) {
		if (list_empty(&rd->row_queues[i].fifo)) {
			/* We can idle only if this is not a forced dispatch */
			if (rd->row_queues[i].idle_data.begin_idling &&
			    !force && row_queues_def[i].idling_enabled)
				goto initiate_idling;
		} else {
			if (row_low_req_pending(rd) &&
			    (rd->low_prio_starvation.starvation_counter >=
			     rd->low_prio_starvation.starvation_limit))
				ret = IOPRIO_CLASS_IDLE;
			else
				ret = IOPRIO_CLASS_BE;
			goto done;
		}
	}

	if (rd->nr_reqs[READ] || rd->nr_reqs[WRITE])
		ret = IOPRIO_CLASS_IDLE;
	goto done;

initiate_idling:
	hrtimer_start(&rd->rd_idle_data.hr_timer,
		ktime_set(0, rd->rd_idle_data.idle_time_ms * NSEC_PER_MSEC),
		HRTIMER_MODE_REL);

	rd->rd_idle_data.idling_queue_idx = i;
	row_log_rowq(rd, i, "Scheduled delayed work on %d. exiting", i);

done:
	return ret;
}
```


Overlapping Code:
```
truct row_data *rd, int force)
{
int i;
int ret = IOPRIO_CLASS_NONE;
if (!rd->nr_reqs[READ] && !rd->nr_reqs[WRITE]) {
row_log(rd->dispatch_queue, "No more requests in scheduler");
goto check_idling;
}
/* First, go over the high priority queues */
for (i = 0; i < ROWQ_REG_PRIO_IDX; i++) {
if (!list_empty(&rd->row_queues[i].fifo)) {
if (hrtimer_active(&rd->rd_idle_data.hr_timer)) {
if (hrtimer_try_to_cancel(
&rd->rd_idle_data.hr_timer) >= 0) {
row_log(rd->dispatch_queue,
"Canceling delayed work on %d. RT pending",
rd->rd_idle_data.idling_queue_idx);
rd->rd_idle_data.idling_queue_idx =
ROWQ_MAX_PRIO;
}
}
if (row_regular_req_pending(rd) &&
(rd->reg_prio_starvation.starvation_counter >=
rd->reg_prio_starvation.starvation_limit))
ret = IOPRIO_CLASS_BE;
else if (row_low_req_pending(rd) &&
(rd->low_prio_starvation.starvation_counter >=
rd->low_prio_starvation.starvation_limit))
ret = IOPRIO_CLASS_IDLE;
else
ret = IOPRIO_CLASS_RT;
goto done;
}
}
/*
* At the moment idling is implemented only for READ queues.
* If enabled on WRITE, this needs updating
*/
if (hrtimer_active(&rd->rd_idle_data.hr_timer)) {
row_log(rd->dispatch_queue, "Delayed work pending. Exiting");
goto done;
}
check_idling:
/* Check for (high priority) idling and enable if needed */
for (i = 0; i < ROWQ_REG_PRIO_IDX && !force; i++) {
if (rd->row_queues[i].idle_data.begin_idling &&
row_queues_def[i].idling_enabled)
goto initiate_idling;
}
/* Regular priority queues */
for (i = ROWQ_REG_PRIO_IDX; i < ROWQ_LOW_PRIO_IDX; i++) {
if (list_empty(&rd->row_queues[i].fifo)) {
/* We can idle only if this is not a forced dispatch */
if (rd->row_queues[i].idle_data.begin_idling &&
!force && row_queues_def[i].idling_enabled)
goto initiate_idling;
} else {
if (row_low_req_pending(rd) &&
(rd->low_prio_starvation.starvation_counter >=
rd->low_prio_starvation.starvation_limit))
ret = IOPRIO_CLASS_IDLE;
else
ret = IOPRIO_CLASS_BE;
goto done;
}
}
if (rd->nr_reqs[READ] || rd->nr_reqs[WRITE])
ret = IOPRIO_CLASS_IDLE;
goto done;
initiate_idling:
hrtimer_start(&rd->rd_idle_data.hr_timer,
ktime_set(0, rd->rd_idle_data.idle_time_ms * NSEC_PER_MSEC),
HRTIMER_MODE_REL);
rd->rd_idle_data.idling_queue_idx = i;
row_log_rowq(rd, i, "Sche
```
<Overlap Ratio: 0.967032967032967>

---

--- 123 --
Question ID: 83edeb93a81a76f71face01a04777e84e0f293f2_23
Original Code:
```
__STATIC_INLINE void pulseDirectionalPriority(void)
{
  COEX_Req_t combinedReqState = coexCfg.combinedRequestState; // Local non-volatile flavor avoids warnings
  bool highPriority = ((combinedReqState & COEX_REQ_HIPRI) != 0U);
  bool setRequest = ((combinedReqState & COEX_REQ_ON) != 0U);

  // DP priority possible
  // Not in Direction PRIORITY bypass?
  if ((COEX_HAL_GetDpPulseWidth() != 0)
      // coexUpdateReqIsr() triggered by REQUEST changing, not PWM changing?
      && (setRequest != getGpioOut(reqHandle, false))
      // PRIORITY changing requiring a new priority pulse?
      && (highPriority && !getGpioOut(priHandle, false))) {
    COEX_ClearRequestAndPriority(); // then deaasert all PTA signals
  }
}
```


Overlapping Code:
```
_INLINE void pulseDirectionalPriority(void)
{
COEX_Req_t combinedReqState = coexCfg.combinedRequestState; // Local non-volatile flavor avoids warnings
bool highPriority = ((combinedReqState & COEX_REQ_HIPRI) != 0U);
bool setRequest = ((combinedReqState & COEX_REQ_ON) != 0U);
// DP priority possible
// Not in Direction PRIORITY bypass?
if ((COEX_HAL_GetDpPulseWidth() != 0)
// coexUpdateReqIsr() triggered by REQUEST changing, not PWM changing?
&& (setRequest != getGpioOut(reqHandle, false))
// PRIORITY changing requiring a new priority pulse?
&& (highPriority && !getGpioOut(priHandle, false))) {
COEX_ClearRequestAndPriority(); // then deaasert 
```
<Overlap Ratio: 0.9601181683899557>

---

--- 124 --
Question ID: 4a7e4ea4dd35fd76a57727326ee4a1e5494699e7_0
Original Code:
```
void * sst_read_self_stat(sst_proc_stat * pstat)
{
	const int num_stats = 52;
	void * ret = NULL;
	FILE * fself = fopen(pself("stat"), "r");
	
	if (fself)
	{
		int stats = fscanf(fself, fmt_str_stat, &(pstat->pid),
			pstat->comm, &(pstat->state), &(pstat->ppid), &(pstat->pgrp),
			&(pstat->session), &(pstat->tty_nr), &(pstat->tpgid),
			&(pstat->flags), &(pstat->minflt), &(pstat->cminflt),
			&(pstat->majflt), &(pstat->cmajflt), &(pstat->utime),
			&(pstat->stime), &(pstat->cutime), &(pstat->cstime),
			&(pstat->priority), &(pstat->nice), &(pstat->num_threads),
			&(pstat->itrealvalue), &(pstat->starttime), &(pstat->vsize),
			&(pstat->rss), &(pstat->rsslim), &(pstat->startcode),
			&(pstat->endcode), &(pstat->startstack), &(pstat->kstkesp),
			&(pstat->kstkeip), &(pstat->signal), &(pstat->blocked),
			&(pstat->sigignore), &(pstat->sigcatch), &(pstat->wchan),
			&(pstat->nswap), &(pstat->cnswap), &(pstat->exit_signal),
			&(pstat->processor), &(pstat->rt_priority), &(pstat->policy),
			&(pstat->delayacct_blkio_ticks), &(pstat->guest_time),
			&(pstat->cguest_time), &(pstat->start_data), &(pstat->end_data),
			&(pstat->start_brk), &(pstat->arg_start), &(pstat->arg_end),
			&(pstat->env_start), &(pstat->env_end), &(pstat->exit_code)
		);
		
		fclose(fself);
		if (num_stats == stats)
			ret = pstat;
	}
	
	return ret;
}
```


Overlapping Code:
```
)
{
const int num_stats = 52;
void * ret = NULL;
FILE * fself = fopen(pself("stat"), "r");

if (fself)
{
int stats = fscanf(fself, fmt_str_stat, &(pstat->pid),
pstat->comm, &(pstat->state), &(pstat->ppid), &(pstat->pgrp),
&(pstat->session), &(pstat->tty_nr), &(pstat->tpgid),
&(pstat->flags), &(pstat->minflt), &(pstat->cminflt),
&(pstat->majflt), &(pstat->cmajflt), &(pstat->utime),
&(pstat->stime), &(pstat->cutime), &(pstat->cstime),
&(pstat->priority), &(pstat->nice), &(pstat->num_threads),
&(pstat->itrealvalue), &(pstat->starttime), &(pstat->vsize),
&(pstat->rss), &(pstat->rsslim), &(pstat->startcode),
&(pstat->endcode), &(pstat->startstack), &(pstat->kstkesp),
&(pstat->kstkeip), &(pstat->signal), &(pstat->blocked),
&(pstat->sigignore), &(pstat->sigcatch), &(pstat->wchan),
&(pstat->nswap), &(pstat->cnswap), &(pstat->exit_signal),
&(pstat->processor), &(pstat->rt_priority), &(pstat->policy),
&(pstat->delayacct_blkio_ticks), &(pstat->guest_time),
&(pstat->cguest_time), &(pstat->start_data), &(pstat->end_data),
&(pstat->start_brk), &(pstat->arg_start), &(pstat->arg_end),
&(pstat->env_start), &(pstat->env_end), &(pstat->exit_code)
);

fclose(fself);
if (num_stats == stats)
ret = pstat
```
<Overlap Ratio: 0.9486166007905138>

---

--- 125 --
Question ID: 81247c269ad3acb4c4abce2f4b3f283c500b92a3_0
Original Code:
```
double	leaf_conductance_APAR_curve(	double	APAR,
									double	APAR_coef) 	
{
	/*--------------------------------------------------------------*/
	/*	Local function declaration									*/
	/*--------------------------------------------------------------*/
	/*--------------------------------------------------------------*/
	/*	Local variable definition.									*/
	/*--------------------------------------------------------------*/
	double	m_APAR;
	/*--------------------------------------------------------------*/
	/*	Estimate multiplier on stomatal_conductance_max to get	*/
	/*	mean stratum conductance reduction 			*/
	/*	APAR was the only factor.				*/
	/*--------------------------------------------------------------*/
	m_APAR = ( APAR * APAR_coef ) / ( 1.0 + APAR * APAR_coef );
	return(m_APAR);
}
```


Overlapping Code:
```
nce_APAR_curve( double APAR,
double APAR_coef) 
{
/*--------------------------------------------------------------*/
/* Local function declaration */
/*--------------------------------------------------------------*/
/*--------------------------------------------------------------*/
/* Local variable definition. */
/*--------------------------------------------------------------*/
double m_APAR;
/*--------------------------------------------------------------*/
/* Estimate multiplier on stomatal_conductance_max to get */
/* mean stratum conductance reduction */
/* APAR was the only factor. */
/*--------------------------------------------------------------*/
m_APAR = ( APAR * APAR_coef ) / (
```
<Overlap Ratio: 0.9162303664921466>

---

--- 126 --
Question ID: a2797098d444f0923f2788224f1978bf14994167_3
Original Code:
```
static struct rb_mjit_unit *
get_from_list(struct rb_mjit_unit_list *list)
{
    struct rb_mjit_unit *unit = NULL, *next, *best = NULL;

    /* Find iseq with max total_calls */
    list_for_each_safe(&list->head, unit, next, unode) {
        if (unit->iseq == NULL) { /* ISeq is GCed. */
            remove_from_list(unit, list);
            free_unit(unit);
            continue;
        }

        if (best == NULL || best->iseq->body->total_calls < unit->iseq->body->total_calls) {
            best = unit;
        }
    }
    if (best) {
        remove_from_list(best, list);
    }
    return best;
}
```


Overlapping Code:
```
ic struct rb_mjit_unit *
get_from_list(struct rb_mjit_unit_list *list)
{
struct rb_mjit_unit *unit = NULL, *next, *best = NULL;
/* Find iseq with max total_calls */
list_for_each_safe(&list->head, unit, next, unode) {
if (unit->iseq == NULL) { /* ISeq is GCed. */
remove_from_list(unit, list);
free_unit(unit);
continue;
}
if (best == NULL || best->iseq->body->total_calls < unit->iseq->body->total_calls) {
best = unit;
}
}
if (best) {
remove_from_list(best,
```
<Overlap Ratio: 0.9425051334702259>

---

--- 127 --
Question ID: efefdffdc23aea4d05ed9b5258b7f2287063ff1d_3
Original Code:
```
int ndpi_flowv6_flow_hash(u_int8_t l4_proto, struct ndpi_in6_addr *src_ip, struct ndpi_in6_addr *dst_ip,
                          u_int16_t src_port, u_int16_t dst_port,
                          u_int8_t icmp_type, u_int8_t icmp_code,
                          u_char *hash_buf, u_int8_t hash_buf_len)
{
    u_int8_t comm_buf[40] = { 0 };
    u_int16_t off = 0;
    u_int16_t seed = 0;
    struct ndpi_in6_addr *ip_a_ptr, *ip_b_ptr;
    u_int16_t port_a, port_b;
    int icmp_one_way = 0;

    switch(l4_proto) {
    case IPPROTO_ICMPV6:
        src_port = icmp_type;
        dst_port = ndpi_community_id_icmp_type_to_code_v6(icmp_type, icmp_code, &icmp_one_way);
        break;
    case IPPROTO_SCTP:
    case IPPROTO_UDP:
    case IPPROTO_TCP:
        /* src/dst port ok */
        break;
    default:
        src_port = dst_port = 0;
        break;
    }

    /* Convert tuple to NBO */
    src_port = htons(src_port);
    dst_port = htons(dst_port);

    if(icmp_one_way || ndpi_community_id_peer_v6_is_less_than(src_ip, dst_ip, src_port, dst_port)) {
        ip_a_ptr = src_ip, ip_b_ptr = dst_ip;
        port_a = src_port, port_b = dst_port;
    } else {
        ip_a_ptr = dst_ip, ip_b_ptr = src_ip;
        port_a = dst_port, port_b = src_port;
    }

    /* Seed */
    off = ndpi_community_id_buf_copy(&comm_buf[off], &seed, sizeof(seed));

    /* Source and destination IPs */
    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_a_ptr, sizeof(struct ndpi_in6_addr));
    off += ndpi_community_id_buf_copy(&comm_buf[off], ip_b_ptr, sizeof(struct ndpi_in6_addr));

    return ndpi_community_id_finalize_and_compute_hash(comm_buf, off,l4_proto, port_a, port_b, (char*)hash_buf, hash_buf_len);
}
```


Overlapping Code:
```
nt ndpi_flowv6_flow_hash(u_int8_t l4_proto, struct ndpi_in6_addr *src_ip, struct ndpi_in6_addr *dst_ip,
u_int16_t src_port, u_int16_t dst_port,
u_int8_t icmp_type, u_int8_t icmp_code,
u_char *hash_buf, u_int8_t hash_buf_len)
{
u_int8_t comm_buf[40] = { 0 };
u_int16_t off = 0;
u_int16_t seed = 0;
struct ndpi_in6_addr *ip_a_ptr, *ip_b_ptr;
u_int16_t port_a, port_b;
int icmp_one_way = 0;
switch(l4_proto) {
case IPPROTO_ICMPV6:
src_port = icmp_type;
dst_port = ndpi_community_id_icmp_type_to_code_v6(icmp_type, icmp_code, &icmp_one_way);
break;
case IPPROTO_SCTP:
case IPPROTO_UDP:
case IPPROTO_TCP:
/* src/dst port ok */
break;
default:
src_port = dst_port = 0;
break;
}
/* Convert tuple to NBO */
src_port = htons(src_port);
dst_port = htons(dst_port);
if(icmp_one_way || ndpi_community_id_peer_v6_is_less_than(src_ip, dst_ip, src_port, dst_port)) {
ip_a_ptr = src_ip, ip_b_ptr = dst_ip;
port_a = src_port, port_b = dst_port;
} else {
ip_a_ptr = dst_ip, ip_b_ptr = src_ip;
port_a = dst_port, port_b = src_port;
}
/* Seed */
off = ndpi_community_id_buf_copy(&comm_buf[off], &seed, sizeof(seed));
/* Source and destination IPs */
off += ndpi_community_id_buf_copy(&comm_buf[off], ip_a_ptr, sizeof(struct ndpi_in6_addr));
off += ndpi_community_id_buf_copy(&comm_buf[off], ip_b_ptr, sizeof(struct ndpi_in6_addr));
return ndpi_community_id_finalize_and_compute_hash(comm_buf, off,l4_proto, port_a, port_
```
<Overlap Ratio: 0.9742519137091162>

---

--- 128 --
Question ID: bc28e1de3ac64b8634bbbfd471bd2bbf59e4a4c3_34
Original Code:
```
int camera_agent_set_auto_exposure(sensor_index_t sensor_index,u8 onoff)
{
	u16 OpCode = ISPCMD_BASIC_SET_AUTOEXPOSURE;
	u32 cmd;
	u8 buf[3] = {0};
	int errorcode;

	print_debug("Enter Function:%s=[%s]", __func__, onoff?"off":"on");
	cmd = misp_construct_opcode(OpCode,SET_CMD,sizeof(buf));
	sensor_index = remap_sensor_index(sensor_index);

	buf[0] = onoff;
	buf[1] = onoff;
	buf[2] = onoff;

	errorcode = misp_exec_cmd(cmd,buf);
	if (errorcode) {
		print_error("%s fail, error code = %d", __func__, errorcode);
		return -1;
	}
	return 0;
}
```


Overlapping Code:
```
_agent_set_auto_exposure(sensor_index_t sensor_index,u8 onoff)
{
u16 OpCode = ISPCMD_BASIC_SET_AUTOEXPOSURE;
u32 cmd;
u8 buf[3] = {0};
int errorcode;
print_debug("Enter Function:%s=[%s]", __func__, onoff?"off":"on");
cmd = misp_construct_opcode(OpCode,SET_CMD,sizeof(buf));
sensor_index = remap_sensor_index(sensor_index);
buf[0] = onoff;
buf[1] = onoff;
buf[2] = onoff;
errorcode = misp_exec_cmd(cmd,buf);
if (errorcode) {
print_error("%s fail, error code = %d", __func__, errorcode);
return -1;
}
return 0;

```
<Overlap Ratio: 0.9788461538461538>

---

--- 129 --
Question ID: 7403d537586849fbd6e35d78027d21e9e791944c_11
Original Code:
```
static int r_viewport_height_index_xl(lua_State *L)
{
    R_Viewport *self = R_CPPCAST(R_Viewport *, XL_checkutype(L, 1, "R_Viewport"));
    int RETVAL;
    RETVAL = self->h;
    XL_pushint(L, RETVAL);
    return 1;
}
```


Overlapping Code:
```
iewport_height_index_xl(lua_State *L)
{
R_Viewport *self = R_CPPCAST(R_Viewport *, XL_checkutype(L, 1, "R_Viewport"));
int RETVAL;
RETVAL = self->h;
XL_pushint(L, RETVAL);
return 1;
```
<Overlap Ratio: 0.9187817258883249>

---

--- 130 --
Question ID: 685c4514e7472e2887ba06ef14caa4562691234c_11
Original Code:
```
gceSTATUS
gcoOS_QueryVideoMemory(
    IN gcoOS Os,
    OUT gctPHYS_ADDR * InternalAddress,
    OUT gctSIZE_T * InternalSize,
    OUT gctPHYS_ADDR * ExternalAddress,
    OUT gctSIZE_T * ExternalSize,
    OUT gctPHYS_ADDR * ContiguousAddress,
    OUT gctSIZE_T * ContiguousSize
    )
{
    gceSTATUS status;
    gcsHAL_INTERFACE iface;

    gcmHEADER();

        /* Call kernel HAL to query video memory. */
    iface.command = gcvHAL_QUERY_VIDEO_MEMORY;

        /* Call kernel service. */
    gcmONERROR(gcoOS_DeviceControl(gcvNULL,
            IOCTL_GCHAL_INTERFACE,
                                   &iface, gcmSIZEOF(iface),
                                   &iface, gcmSIZEOF(iface)));

        if (InternalAddress != gcvNULL)
        {
            /* Verify arguments. */
            gcmVERIFY_ARGUMENT(InternalSize != gcvNULL);

            /* Save internal memory size. */
        *InternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.internalPhysical);
        *InternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.internalSize;
        }

        if (ExternalAddress != gcvNULL)
        {
            /* Verify arguments. */
            gcmVERIFY_ARGUMENT(ExternalSize != gcvNULL);

            /* Save external memory size. */
        *ExternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.externalPhysical);
        *ExternalSize    = (gctSIZE_T) iface.u.QueryVideoMemory.externalSize;
        }

        if (ContiguousAddress != gcvNULL)
        {
            /* Verify arguments. */
            gcmVERIFY_ARGUMENT(ContiguousSize != gcvNULL);

            /* Save contiguous memory size. */
        *ContiguousAddress = gcmINT2PTR(iface.u.QueryVideoMemory.contiguousPhysical);
        *ContiguousSize    = (gctSIZE_T) iface.u.QueryVideoMemory.contiguousSize;
        }

    /* Success. */
    gcmFOOTER_ARG("*InternalAddress=0x%08x *InternalSize=%lu "
                  "*ExternalAddress=0x%08x *ExternalSize=%lu "
                  "*ContiguousAddress=0x%08x *ContiguousSize=%lu",
                  gcmOPT_VALUE(InternalAddress), gcmOPT_VALUE(InternalSize),
                  gcmOPT_VALUE(ExternalAddress), gcmOPT_VALUE(ExternalSize),
                  gcmOPT_VALUE(ContiguousAddress),
                  gcmOPT_VALUE(ContiguousSize));
    return gcvSTATUS_OK;

OnError:
    /* Return the status. */
    gcmFOOTER();
    return status;
}
```


Overlapping Code:
```
gceSTATUS
gcoOS_QueryVideoMemory(
IN gcoOS Os,
OUT gctPHYS_ADDR * InternalAddress,
OUT gctSIZE_T * InternalSize,
OUT gctPHYS_ADDR * ExternalAddress,
OUT gctSIZE_T * ExternalSize,
OUT gctPHYS_ADDR * ContiguousAddress,
OUT gctSIZE_T * ContiguousSize
)
{
gceSTATUS status;
gcsHAL_INTERFACE iface;
gcmHEADER();
/* Call kernel HAL to query video memory. */
iface.command = gcvHAL_QUERY_VIDEO_MEMORY;
/* Call kernel service. */
gcmONERROR(gcoOS_DeviceControl(gcvNULL,
IOCTL_GCHAL_INTERFACE,
&iface, gcmSIZEOF(iface),
&iface, gcmSIZEOF(iface)));
if (InternalAddress != gcvNULL)
{
/* Verify arguments. */
gcmVERIFY_ARGUMENT(InternalSize != gcvNULL);
/* Save internal memory size. */
*InternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.internalPhysical);
*InternalSize = (gctSIZE_T) iface.u.QueryVideoMemory.internalSize;
}
if (ExternalAddress != gcvNULL)
{
/* Verify arguments. */
gcmVERIFY_ARGUMENT(ExternalSize != gcvNULL);
/* Save external memory size. */
*ExternalAddress = gcmINT2PTR(iface.u.QueryVideoMemory.externalPhysical);
*ExternalSize = (gctSIZE_T) iface.u.QueryVideoMemory.externalSize;
}
if (ContiguousAddress != gcvNULL)
{
/* Verify arguments. */
gcmVERIFY_ARGUMENT(ContiguousSize != gcvNULL);
/* Save contiguous memory size. */
*ContiguousAddress = gcmINT2PTR(iface.u.QueryVideoMemory.contiguousPhysical);
*ContiguousSize = (gctSIZE_T) iface.u.QueryVideoMemory.contiguousSize;
}
/* Success. */
gcmFOOTER_ARG("*InternalAddress=0x%08x *InternalSize=%lu "
"*ExternalAddress=0x%08x *ExternalSize=%lu "
"*ContiguousAddress=0x%08x *ContiguousSize=%lu",
gcmOPT_VALUE(InternalAddress), gcmOPT_VALUE(InternalSize),
gcmOPT_VALUE(ExternalAddress), gcmOPT_VALUE(ExternalSize),
gcmOPT_VALUE(ContiguousAddress),
gcmOPT_VALUE(ContiguousSize));
return gcvSTATUS_OK;
OnError:
/* Return the status. */
gcmFOOTER();
return status;
}
```
<Overlap Ratio: 1.0>

---

--- 131 --
Question ID: a9ab594c317af7799b1b7b18e4431352638fd2df_7
Original Code:
```
int alarm_range(gauge_t *g) {
  aldl_define_t *def = &aldl->def[g->data_a];
  aldl_data_t *data = &rec->data[g->data_a];
  switch(def->type) {
    case ALDL_FLOAT:
      if( ( def->alarm_low_enable == 1 && data->f < def->alarm_low.f ) ||
      ( def->alarm_high_enable == 1 && data->f > def->alarm_high.f) ) return 1;
      return 0;
      break;
    case ALDL_INT:
      if( ( def->alarm_low_enable == 1 && data->i < def->alarm_low.i ) ||
      ( def->alarm_high_enable == 1 && data->i > def->alarm_high.i) ) return 1;
      return 0;
    default:
      return 0;
  }
}
```


Overlapping Code:
```
auge_t *g) {
aldl_define_t *def = &aldl->def[g->data_a];
aldl_data_t *data = &rec->data[g->data_a];
switch(def->type) {
case ALDL_FLOAT:
if( ( def->alarm_low_enable == 1 && data->f < def->alarm_low.f ) ||
( def->alarm_high_enable == 1 && data->f > def->alarm_high.f) ) return 1;
return 0;
break;
case ALDL_INT:
if( ( def->alarm_low_enable == 1 && data->i < def->alarm_low.i ) ||
( def->alarm_high_enable == 1 && data->i > def->alarm_high.i) ) return 1;
return 0;
default:
re
```
<Overlap Ratio: 0.9442231075697212>

---

--- 132 --
Question ID: b35ab611bef5b96b7341c43ef17b0cddd14c5fab_2
Original Code:
```
bStatus_t GAPObserverRole_StartDiscovery( uint8 mode, uint8 activeScan, uint8 whiteList )
{
  gapDevDiscReq_t params;

  params.taskID = gapObserverRoleTaskId;
  params.mode = mode;
  params.activeScan = activeScan;
  params.whiteList = whiteList;

  return GAP_DeviceDiscoveryRequest( &params );
}
```


Overlapping Code:
```
verRole_StartDiscovery( uint8 mode, uint8 activeScan, uint8 whiteList )
{
gapDevDiscReq_t params;
params.taskID = gapObserverRoleTaskId;
params.mode = mode;
params.activeScan = activeScan;
params.whiteList = whiteList;
return GAP_DeviceDiscoveryReque
```
<Overlap Ratio: 0.8802816901408451>

---

--- 133 --
Question ID: b0b8496c96a437392f5a5a67531cd611e7eb6c7a_1
Original Code:
```
void say(unsigned level, const char *format, ...)
{
	va_list ap;

	if (level > verbose)
		return;

	va_start(ap, format);

	if (log_f) {
		fprintf(log_f, "%u: ", getpid());
		vfprintf(log_f, format, ap);
		fprintf(log_f, "\n");
	} else {
		fprintf(stderr, "%u: ", getpid());
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
	}

	va_end(ap);
}
```


Overlapping Code:
```
void say(unsigned level, const char *format, ...)
{
va_list ap;
if (level > verbose)
return;
va_start(ap, format);
if (log_f) {
fprintf(log_f, "%u: ", getpid());
vfprintf(log_f, format, ap);
fprintf(log_f, "\n");
} else {
fprintf(stderr, "%u: ", getpid());
vfprintf(stderr, format, ap);
fprintf(stderr, "\n");
}

```
<Overlap Ratio: 0.96>

---

--- 134 --
Question ID: 1e775eb48e85e5a69dc89ff4a0bf97e1e6a73601_30
Original Code:
```
ofc_sema_typeval_t* ofc_sema_typeval_multiply(
	const ofc_sema_typeval_t* a,
	const ofc_sema_typeval_t* b)
{
	if (!a || !a->type
		|| !b || !b->type
		|| !ofc_sema_type_compatible(
			a->type, b->type))
		return NULL;

	ofc_sema_typeval_t tv;
	tv.type = a->type;

	tv.src = OFC_SPARSE_REF_EMPTY;
	ofc_sparse_ref_bridge(
		a->src, b->src, &tv.src);

	switch (a->type->type)
	{
		case OFC_SEMA_TYPE_REAL:
			tv.real = a->real * b->real;
			break;
		case OFC_SEMA_TYPE_COMPLEX:
			tv.complex.real = (a->complex.real * b->complex.real)
				- (a->complex.imaginary * b->complex.imaginary);
			tv.complex.imaginary = (a->complex.real * b->complex.imaginary)
				+ (b->complex.real * a->complex.imaginary);
			break;
		case OFC_SEMA_TYPE_INTEGER:
		case OFC_SEMA_TYPE_BYTE:
			tv.integer = a->integer * b->integer;
			if ((b->integer != 0)
				&& ((tv.integer / b->integer) != a->integer))
				return NULL;
			break;
		default:
			return NULL;
	}

	return ofc_sema_typeval__alloc(tv);
}
```


Overlapping Code:
```
val_t* ofc_sema_typeval_multiply(
const ofc_sema_typeval_t* a,
const ofc_sema_typeval_t* b)
{
if (!a || !a->type
|| !b || !b->type
|| !ofc_sema_type_compatible(
a->type, b->type))
return NULL;
ofc_sema_typeval_t tv;
tv.type = a->type;
tv.src = OFC_SPARSE_REF_EMPTY;
ofc_sparse_ref_bridge(
a->src, b->src, &tv.src);
switch (a->type->type)
{
case OFC_SEMA_TYPE_REAL:
tv.real = a->real * b->real;
break;
case OFC_SEMA_TYPE_COMPLEX:
tv.complex.real = (a->complex.real * b->complex.real)
- (a->complex.imaginary * b->complex.imaginary);
tv.complex.imaginary = (a->complex.real * b->complex.imaginary)
+ (b->complex.real * a->complex.imaginary);
break;
case OFC_SEMA_TYPE_INTEGER:
case OFC_SEMA_TYPE_BYTE:
tv.integer = a->integer * b->integer;
if ((b->integer != 0)
&& ((tv.integer / b->integer) != a->integer))
return NULL;
break;
default:
return NULL;
}
return ofc_sema_typeval__alloc(tv);
}
```
<Overlap Ratio: 0.9855555555555555>

---

--- 135 --
Question ID: 9a6f8b09de7717c3143d16d83c2a66fa4f94ff69_2
Original Code:
```
void SomaInsere(celula *lst){
	celula *p, *soma;
	
	soma = malloc(sizeof(celula));
	
	p = lst->seg;	
	
	oma->conteudo = (p->conteudo)+(p->seg->conteudo);
	soma->seg = NULL;	
	
	while (p->seg != NULL) p = p->seg;
	
	p->seg = soma;	
}
```


Overlapping Code:
```
celula *lst){
celula *p, *soma;

soma = malloc(sizeof(celula));

p = lst->seg; 

oma->conteudo = (p->conteudo)+(p->seg->conteudo);
soma->seg = NULL; 

while (p->seg != NULL) p = p->seg;

p->seg = soma
```
<Overlap Ratio: 0.9090909090909091>

---

--- 136 --
Question ID: 1453f9ba6130932cd273d6df7cff1a6ea4376609_5
Original Code:
```
uint16 USBUART_GetCount(void) 
    {
        uint16 bytesCount = 0u;

        if (USBUART_EP[USBUART_cdc_data_out_ep].apiEpState == USBUART_OUT_BUFFER_FULL)
        {
            bytesCount = USBUART_GetEPCount(USBUART_cdc_data_out_ep);
        }

        return(bytesCount);
    }
```


Overlapping Code:
```
void) 
{
uint16 bytesCount = 0u;
if (USBUART_EP[USBUART_cdc_data_out_ep].apiEpState == USBUART_OUT_BUFFER_FULL)
{
bytesCount = USBUART_GetEPCount(USBU
```
<Overlap Ratio: 0.684931506849315>

---

--- 137 --
Question ID: 0dbe29d7d88b67c5bbda8491daeec53f74477528_0
Original Code:
```
void e() { i(); j(); test++; }
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 138 --
Question ID: 89e3fb19dc4699becd4c89ca3db96b765fba5cc2_3
Original Code:
```
telospacket *read_telos_packet(int fd)

{
  int length;
  telospacket *packet;
  int i;
  
  const unsigned char *rawpkt;

  //make sure I'm the only one reading the serial port
  //pthread_mutex_lock(&sfreadmutex);

  rawpkt = read_sf_packet(fd, &length);
	dbg(TSRC,"read_sf_packet returned (rawpkt=%X, length=%i).\n",(int)rawpkt, length);
	if (rawpkt == NULL)
	{
		dbg(TSRC,"rawpkt is NULL\n");
		return NULL;
	}
       	printf("Got data...\n");
  for (i=0; i < length; i++)
    printf("%X ", rawpkt[i]);
  printf("\nGet done.\n");
  //pthread_mutex_unlock(&sfreadmutex);

  if (length < 10)
    {
    	dbg(TSRC,"too short.\n");
      free((void*)rawpkt);
      return NULL;
    }

  packet = malloc(sizeof(telospacket));
  
  //get header information
  packet->length = rawpkt[0];
  packet->dsn = rawpkt[3];
  packet->type = rawpkt[8];
  packet->group = rawpkt[9];
  packet->addr = rawpkt[6] | (rawpkt[7] << 8);
  packet->data = malloc(packet->length);
  if (!packet->data)
  {
  	printf("Out of memory!\n");
  	free(packet);
  }
  printf("addr=%X\n",packet->addr);
  memcpy(packet->data, rawpkt+10, packet->length);
  free((void*)rawpkt);
  
  return packet;
}
```


Overlapping Code:
```
ead_telos_packet(int fd)
{
int length;
telospacket *packet;
int i;

const unsigned char *rawpkt;
//make sure I'm the only one reading the serial port
//pthread_mutex_lock(&sfreadmutex);
rawpkt = read_sf_packet(fd, &length);
dbg(TSRC,"read_sf_packet returned (rawpkt=%X, length=%i).\n",(int)rawpkt, length);
if (rawpkt == NULL)
{
dbg(TSRC,"rawpkt is NULL\n");
return NULL;
}
printf("Got data...\n");
for (i=0; i < length; i++)
printf("%X ", rawpkt[i]);
printf("\nGet done.\n");
//pthread_mutex_unlock(&sfreadmutex);
if (length < 10)
{
dbg(TSRC,"too short.\n");
free((void*)rawpkt);
return NULL;
}
packet = malloc(sizeof(telospacket));

//get header information
packet->length = rawpkt[0];
packet->dsn = rawpkt[3];
packet->type = rawpkt[8];
packet->group = rawpkt[9];
packet->addr = rawpkt[6] | (rawpkt[7] << 8);
packet->data = malloc(packet->length);
if (!packet->data)
{
printf("Out of memory!\n");
free(packet);
}
printf("addr=%X\n",packet->addr);
memcpy(packet->data, rawpkt+10, packet->length);
fr
```
<Overlap Ratio: 0.9523809523809523>

---

--- 139 --
Question ID: 9e228f134a62c67a32f9bdfc05ded3999b8cd7e9_3
Original Code:
```
void rtgui_timer_destory(rtgui_timer_t *timer)
{
    RT_ASSERT(timer != RT_NULL);

    /* stop timer firstly */
    rtgui_timer_stop(timer);

    /* detach rt-thread timer */
    rt_timer_detach(&(timer->timer));

    rtgui_free(timer);
}
```


Overlapping Code:
```
estory(rtgui_timer_t *timer)
{
RT_ASSERT(timer != RT_NULL);
/* stop timer firstly */
rtgui_timer_stop(timer);
/* detach rt-thread timer */
rt_timer_de
```
<Overlap Ratio: 0.7109004739336493>

---

--- 140 --
Question ID: bf86dc3a808b0e0c868cc5db791a953433cd3d94_17
Original Code:
```
void editor_del_row(int at)
{
    if(at < 0 || at >= E.numrows) return;
    editor_free_row(&E.row[at]);
    memmove(&E.row[at], &E.row[at + 1], sizeof(erow) * (E.numrows - at - 1));
    for(int j = at; j < E.numrows - 1; j++) E.row[j].idx--;
    E.numrows--;
    E.dirty++;
}
```


Overlapping Code:
```
0 || at >= E.numrows) return;
editor_free_row(&E.row[at]);
memmove(&E.row[at], &E.row[at + 1], sizeof(erow) * (E.numrows - at - 1));
for(int j = at; j < E.numrows - 1; j++) E.row[j].idx--;
E.numrows--;
```
<Overlap Ratio: 0.7976190476190477>

---

--- 141 --
Question ID: 6fbff8c222b82d22c7ddfa7e8f992f33f8eb208f_19
Original Code:
```
static ngx_int_t
ngx_http_doorman_orig_uri_variable(ngx_http_request_t *r,
    ngx_http_variable_value_t *v, uintptr_t data)
{
    ngx_http_doorman_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_doorman_module);

    if (ctx) {
        v->len = ctx->orig_uri.len;
        v->valid = 1;
        v->no_cacheable = 0;
        v->not_found = 0;
        v->data = ctx->orig_uri.data;

    } else {
        v->not_found = 1;
    }

    return NGX_OK;
}
```


Overlapping Code:
```
ngx_int_t
ngx_http_doorman_orig_uri_variable(ngx_http_request_t *r,
ngx_http_variable_value_t *v, uintptr_t data)
{
ngx_http_doorman_ctx_t *ctx;
ctx = ngx_http_get_module_ctx(r, ngx_http_doorman_module);
if (ctx) {
v->len = ctx->orig_uri.len;
v->valid = 1;
v->no_cacheable = 0;
v->not_found = 0;
v->data = ctx->orig_uri.data;
} else {
v->not_found = 1;
}
return NGX_OK;
}
```
<Overlap Ratio: 0.9814814814814815>

---

--- 142 --
Question ID: 8e4218da0830de8205519bf8b62fb7e8728f62ee_0
Original Code:
```
class HUMBLE_EXPORT_API Mutex
{
  friend class MutexPrivate;
  MutexPrivate *d;

public:
  Mutex();
  ~Mutex();
  void lock();
  void unlock();
}
```


Overlapping Code:
```
 class MutexPrivate;
MutexPrivate *d;
public:
Mutex();
~Mutex();
void lock();
void unlock();

```
<Overlap Ratio: 0.7045454545454546>

---

--- 143 --
Question ID: fdb726a5a42aa226e6970736626f9c8bf36ae884_84
Original Code:
```
static int smb1351_determine_initial_state(struct smb1351_charger *chip)
{
	int rc;
	u8 reg = 0;

	/*
	 * It is okay to read the interrupt status here since
	 * interrupts aren't requested. Reading interrupt status
	 * clears the interrupt so be careful to read interrupt
	 * status only in interrupt handling code
	 */

	rc = smb1351_read_reg(chip, IRQ_B_REG, &reg);
	if (rc) {
		pr_err("Couldn't read IRQ_B rc = %d\n", rc);
		goto fail_init_status;
	}

	chip->battery_missing = (reg & IRQ_BATT_MISSING_BIT) ? true : false;

	rc = smb1351_read_reg(chip, IRQ_C_REG, &reg);
	if (rc) {
		pr_err("Couldn't read IRQ_C rc = %d\n", rc);
		goto fail_init_status;
	}
	chip->batt_full = (reg & IRQ_TERM_BIT) ? true : false;

	rc = smb1351_read_reg(chip, IRQ_A_REG, &reg);
	if (rc) {
		pr_err("Couldn't read irq A rc = %d\n", rc);
		return rc;
	}

	if (reg & IRQ_HOT_HARD_BIT)
		chip->batt_hot = true;
	if (reg & IRQ_COLD_HARD_BIT)
		chip->batt_cold = true;
	if (reg & IRQ_HOT_SOFT_BIT)
		chip->batt_warm = true;
	if (reg & IRQ_COLD_SOFT_BIT)
		chip->batt_cool = true;

	rc = smb1351_read_reg(chip, IRQ_E_REG, &reg);
	if (rc) {
		pr_err("Couldn't read IRQ_E rc = %d\n", rc);
		goto fail_init_status;
	}

	if (reg & IRQ_USBIN_UV_BIT) {
		smb1351_usbin_uv_handler(chip, 1);
	} else {
		smb1351_stay_awake(&chip->smb1351_ws, RERUN_APSD);
		schedule_delayed_work(&chip->rerun_apsd_work,
				msecs_to_jiffies(RERUN_APSD_DELAY_MS));
	}

	rc = smb1351_read_reg(chip, IRQ_G_REG, &reg);
	if (rc) {
		pr_err("Couldn't read IRQ_G rc = %d\n", rc);
		goto fail_init_status;
	}

	if (reg & IRQ_SOURCE_DET_BIT)
		smb1351_apsd_complete_handler(chip, 1);

	return 0;

fail_init_status:
	pr_err("Couldn't determine initial status\n");
	return rc;
}
```


Overlapping Code:
```
b1351_determine_initial_state(struct smb1351_charger *chip)
{
int rc;
u8 reg = 0;
/*
* It is okay to read the interrupt status here since
* interrupts aren't requested. Reading interrupt status
* clears the interrupt so be careful to read interrupt
* status only in interrupt handling code
*/
rc = smb1351_read_reg(chip, IRQ_B_REG, &reg);
if (rc) {
pr_err("Couldn't read IRQ_B rc = %d\n", rc);
goto fail_init_status;
}
chip->battery_missing = (reg & IRQ_BATT_MISSING_BIT) ? true : false;
rc = smb1351_read_reg(chip, IRQ_C_REG, &reg);
if (rc) {
pr_err("Couldn't read IRQ_C rc = %d\n", rc);
goto fail_init_status;
}
chip->batt_full = (reg & IRQ_TERM_BIT) ? true : false;
rc = smb1351_read_reg(chip, IRQ_A_REG, &reg);
if (rc) {
pr_err("Couldn't read irq A rc = %d\n", rc);
return rc;
}
if (reg & IRQ_HOT_HARD_BIT)
chip->batt_hot = true;
if (reg & IRQ_COLD_HARD_BIT)
chip->batt_cold = true;
if (reg & IRQ_HOT_SOFT_BIT)
chip->batt_warm = true;
if (reg & IRQ_COLD_SOFT_BIT)
chip->batt_cool = true;
rc = smb1351_read_reg(chip, IRQ_E_REG, &reg);
if (rc) {
pr_err("Couldn't read IRQ_E rc = %d\n", rc);
goto fail_init_status;
}
if (reg & IRQ_USBIN_UV_BIT) {
smb1351_usbin_uv_handler(chip, 1);
} else {
smb1351_stay_awake(&chip->smb1351_ws, RERUN_APSD);
schedule_delayed_work(&chip->rerun_apsd_work,
msecs_to_jiffies(RERUN_APSD_DELAY_MS));
}
rc = smb1351_read_reg(chip, IRQ_G_REG, &reg);
if (rc) {
pr_err("Couldn't read IRQ_G rc = %d\n", rc);
goto fail_init_status;
}
if (reg & IRQ_SOURCE_DET_BIT)
smb1351_apsd_complete_handler(chip, 1);
return 0;
fail_init_status:
pr_err("Couldn't determine initial status\n")
```
<Overlap Ratio: 0.9834050399508297>

---

--- 144 --
Question ID: 772201157cd6171a47992a5c8576424713b950b7_5
Original Code:
```
struct blk *
removr(struct blk *p, int n)
{
	int nn, neg;
	struct blk *q, *s, *r;
	fsfile(p);
	neg = sbackc(p);
	if (neg < 0)
		chsign(p);
	rewind(p);
	nn = (n + 1) / 2;
	q = salloc(nn);
	while (n > 1) {
		sputc(q, sgetc(p));
		n -= 2;
	}
	r = salloc(2);
	while (sfeof(p) == 0)
		sputc(r, sgetc(p));
	release(p);
	if (n == 1) {
		s = dcdiv(r, tenptr);
		release(r);
		rewind(rem);
		if (sfeof(rem) == 0)
			sputc(q, sgetc(rem));
		release(rem);
		if (neg < 0) {
			chsign(s);
			chsign(q);
			irem = q;
			return (s);
		}
		irem = q;
		return (s);
	}
	if (neg < 0) {
		chsign(r);
		chsign(q);
		irem = q;
		return (r);
	}
	irem = q;
	return (r);
}
```


Overlapping Code:
```
 *
removr(struct blk *p, int n)
{
int nn, neg;
struct blk *q, *s, *r;
fsfile(p);
neg = sbackc(p);
if (neg < 0)
chsign(p);
rewind(p);
nn = (n + 1) / 2;
q = salloc(nn);
while (n > 1) {
sputc(q, sgetc(p));
n -= 2;
}
r = salloc(2);
while (sfeof(p) == 0)
sputc(r, sgetc(p));
release(p);
if (n == 1) {
s = dcdiv(r, tenptr);
release(r);
rewind(rem);
if (sfeof(rem) == 0)
sputc(q, sgetc(rem));
release(rem);
if (neg < 0) {
chsign(s);
chsign(q);
irem = q;
return (s);
}
irem = q;
return (s);
}
if (neg < 0) {
chsign(r);
chsign(q);
irem = q;
return (r);
}
irem
```
<Overlap Ratio: 0.9499136442141624>

---

--- 145 --
Question ID: ca714eb9f2a1f790dd217a04e086da3c52b6a805_20
Original Code:
```
static int
mkworkdir(void)
{
	char b[32];
	char *d;

	cleanup();

	(void) strlcpy(b, "/tmp/symbols_testXXXXXX", sizeof (b));
	if ((d = mkdtemp(b)) == NULL) {
		perror("mkdtemp");
		return (-1);
	}
	dname = mystrdup(d);
	myasprintf(&cfile, "%s/compile_test.c", d);
	myasprintf(&ofile, "%s/compile_test.o", d);
	myasprintf(&lfile, "%s/compile_test.log", d);
	myasprintf(&efile, "%s/compile_test.exe", d);
	return (0);
}
```


Overlapping Code:
```
ir(void)
{
char b[32];
char *d;
cleanup();
(void) strlcpy(b, "/tmp/symbols_testXXXXXX", sizeof (b));
if ((d = mkdtemp(b)) == NULL) {
perror("mkdtemp");
return (-1);
}
dname = mystrdup(d);
myasprintf(&cfile, "%s/compile_test.c", d);
myasprintf(&ofile, "%s/compile_test.o", d);
myasprintf(&lfile, "%s/compile_test.log", d);
myasprintf(&efile, "%s/compi
```
<Overlap Ratio: 0.8771929824561403>

---

--- 146 --
Question ID: eb6fb4e121a8272cbc5bac085ccee6699d6687ae_12
Original Code:
```
static void Compute_Bridge_Path(Path *path1, Path *path2, Alignment *align, int comp,
                                int aovl, int bovl, Work_Data *work, Trace_Buffer *tbuf)
{ Path   *apath;
  int     ain, aout;
  int     bin, bout, boff;
  int     i, j, p;
  uint16 *trk;

  apath = align->path;

  if (bovl > aovl)
    { bin  = path2->bbpos;
      bout = path1->bepos;
      ain  = MapToTPBelow(path1,&bin,0,tbuf);
      aout = MapToTPAbove(path2,&bout,0,tbuf);
    }
  else
    { ain  = path2->abpos;
      aout = path1->aepos;
      bin  = MapToTPBelow(path1,&ain,1,tbuf);
      bout = MapToTPAbove(path2,&aout,1,tbuf);
    }

#ifdef TEST_BRIDGE
  printf("\n  Tangle [%5d..%5d] vs [%5d..%5d]  %4d\n",
      path1->abpos,path1->aepos,path2->abpos,path2->aepos,abs(aovl-bovl));
  printf("         [%5d..%5d] vs [%5d..%5d]  %4d vs %4d\n",
      path1->bbpos,path1->bepos,path2->bbpos,path2->bepos,aovl,bovl);
  printf("      (%d,%d) to (%d,%d)\n",ain,bin,aout,bout);
  fflush(stdout);
#endif

  apath->abpos = ain - 2*MR_tspace;
  apath->aepos = aout + 2*MR_tspace;
  apath->bbpos = MapToTPBelow(path1,&(apath->abpos),1,tbuf);
  apath->bepos = MapToTPAbove(path2,&(apath->aepos),1,tbuf);

  if (comp)
    { boff = MR_tspace - apath->aepos % MR_tspace;

      p = align->alen - apath->abpos;
      apath->abpos = align->alen - apath->aepos;
      apath->aepos = p;
      p = align->blen - apath->bbpos;
      apath->bbpos = align->blen - apath->bepos;
      apath->bepos = p;

      boff = boff - apath->abpos % MR_tspace;
      align->aseq  -= boff;
      apath->abpos += boff;
      apath->aepos += boff;
      align->alen  += boff;
    }

#ifdef TEST_BRIDGE
  printf("\n      (%d,%d) to (%d,%d)\n",apath->abpos,apath->bbpos,apath->aepos,apath->bepos);
  fflush(stdout);

  Compute_Alignment(align,work,DIFF_ALIGN,0);
  Print_Reference(stdout,align,work,8,100,10,0,6);
  fflush(stdout);
#endif

  Compute_Alignment(align,work,DIFF_TRACE,MR_tspace);

  trk = (uint16 *) apath->trace;
  if (comp)
    { j = apath->tlen-2;
      i = 0;
      while (i < j)
        { p = trk[i];
          trk[i] = trk[j];
          trk[j] = p;
          p = trk[i+1];
          trk[i+1] = trk[j+1];
          trk[j+1] = p;
          i += 2;
          j -= 2;
        }

      align->aseq  += boff;
      apath->abpos -= boff;
      apath->aepos -= boff;
      align->alen  -= boff;

      p = align->alen - apath->abpos;
      apath->abpos = align->alen - apath->aepos;
      apath->aepos = p;
      p = align->blen - apath->bbpos;
      apath->bbpos = align->blen - apath->bepos;
      apath->bepos = p;
    }

#ifdef TEST_BRIDGE
  { int err;

    bin  = apath->bbpos;
    bout = apath->bepos;
    err  = apath->diffs;

    p = 2*(ain / MR_tspace - apath->abpos / MR_tspace);
    for (i = 0; i < p; i += 2)
      { bin += trk[i+1];
        err -= trk[i];
      }

    p = 2*(apath->aepos / MR_tspace - aout / MR_tspace);
    for (i = align->path->tlen, p = i-p; i > p; i -= 2)
      { bout -= trk[i-1];
        err  -= trk[i-2];
      }

    printf("      (%d,%d) to (%d,%d)\n",ain,bin,aout,bout);
    printf("  Box %d vs %d -> %d %d%%\n",aout-ain,bout-bin,err,
                                         (200*err)/((aout-ain)+(bout-bin)));
    fflush(stdout);
  }
#endif

  if (tbuf->top + apath->tlen >= tbuf->max)
    { tbuf->max = 1.2*(tbuf->top+apath->tlen) + TRACE_CHUNK;
      tbuf->trace = (uint16 *) Realloc(tbuf->trace,sizeof(uint16)*tbuf->max,"Allocating paths");
      if (tbuf->trace == NULL)
        Clean_Exit(1);
    }
  trk = tbuf->trace + tbuf->top;
  memcpy(trk,apath->trace,apath->tlen*sizeof(uint16));
  apath->trace = (void *) (tbuf->top);
  tbuf->top += apath->tlen;
}
```


Overlapping Code:
```
id Compute_Bridge_Path(Path *path1, Path *path2, Alignment *align, int comp,
int aovl, int bovl, Work_Data *work, Trace_Buffer *tbuf)
{ Path *apath;
int ain, aout;
int bin, bout, boff;
int i, j, p;
uint16 *trk;
apath = align->path;
if (bovl > aovl)
{ bin = path2->bbpos;
bout = path1->bepos;
ain = MapToTPBelow(path1,&bin,0,tbuf);
aout = MapToTPAbove(path2,&bout,0,tbuf);
}
else
{ ain = path2->abpos;
aout = path1->aepos;
bin = MapToTPBelow(path1,&ain,1,tbuf);
bout = MapToTPAbove(path2,&aout,1,tbuf);
}
#ifdef TEST_BRIDGE
printf("\n Tangle [%5d..%5d] vs [%5d..%5d] %4d\n",
path1->abpos,path1->aepos,path2->abpos,path2->aepos,abs(aovl-bovl));
printf(" [%5d..%5d] vs [%5d..%5d] %4d vs %4d\n",
path1->bbpos,path1->bepos,path2->bbpos,path2->bepos,aovl,bovl);
printf(" (%d,%d) to (%d,%d)\n",ain,bin,aout,bout);
fflush(stdout);
#endif
apath->abpos = ain - 2*MR_tspace;
apath->aepos = aout + 2*MR_tspace;
apath->bbpos = MapToTPBelow(path1,&(apath->abpos),1,tbuf);
apath->bepos = MapToTPAbove(path2,&(apath->aepos),1,tbuf);
if (comp)
{ boff = MR_tspace - apath->aepos % MR_tspace;
p = align->alen - apath->abpos;
apath->abpos = align->alen - apath->aepos;
apath->aepos = p;
p = align->blen - apath->bbpos;
apath->bbpos = align->blen - apath->bepos;
apath->bepos = p;
boff = boff - apath->abpos % MR_tspace;
align->aseq -= boff;
apath->abpos += boff;
apath->aepos += boff;
align->alen += boff;
}
#ifdef TEST_BRIDGE
printf("\n (%d,%d) to (%d,%d)\n",apath->abpos,apath->bbpos,apath->aepos,apath->bepos);
fflush(stdout);
Compute_Alignment(align,work,DIFF_ALIGN,0);
Print_Reference(stdout,align,work,8,100,10,0,6);
fflush(stdout);
#endif
Compute_Alignment(align,work,DIFF_TRACE,MR_tspace);
trk = (uint16 *) apath->trace;
if (comp)
{ j = apath->tlen-2;
i = 0;
while (i < j)
{ p = trk[i];
trk[i] = trk[j];
trk[j] = p;
p = trk[i+1];
trk[i+1] = trk[j+1];
trk[j+1] = p;
i += 2;
j -= 2;
}
align->aseq += boff;
apath->abpos -= boff;
apath->aepos -= boff;
align->alen -= boff;
p = align->alen - apath->abpos;
apath->abpos = align->alen - apath->aepos;
apath->aepos = p;
p = align->b
```
<Overlap Ratio: 0.9942140790742526>

---

--- 147 --
Question ID: 6622a24ae44729d3d95b6032eec5f63f6f2460db_0
Original Code:
```
int main(int argc, char *argv[])
{
    int i, j, k;
    static double a[SIZE][SIZE], b[SIZE][SIZE];
    double t1, t2, t, ts, tst;
    double temp;
    int myrank, mysize, errs = 0;
    MPI_Status status;
    MPI_Aint sizeofreal;

    MPI_Datatype col, xpose;

    MTest_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
    MPI_Comm_size(MPI_COMM_WORLD, &mysize);
    if (mysize != 2) {
        fprintf(stderr, "This test must be run with 2 processes\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    MPI_Type_extent(MPI_DOUBLE, &sizeofreal);

    MPI_Type_vector(SIZE, 1, SIZE, MPI_DOUBLE, &col);
    MPI_Type_hvector(SIZE, 1, sizeofreal, col, &xpose);
    MPI_Type_commit(&xpose);

    /* Preset the arrays so that they're in memory */
    for (i = 0; i < SIZE; i++)
        for (j = 0; j < SIZE; j++) {
            a[i][j] = 0;
            b[i][j] = 0;
        }
    a[SIZE - 1][0] = 1;

    /* Time the transpose example */
    MPI_Barrier(MPI_COMM_WORLD);
    t1 = MPI_Wtime();
    for (i = 0; i < ITER; i++) {
        if (myrank == 0)
            MPI_Send(&a[0][0], SIZE * SIZE, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD);
        else
            MPI_Recv(&b[0][0], 1, xpose, 0, 0, MPI_COMM_WORLD, &status);
    }
    t2 = MPI_Wtime();
    t = (t2 - t1) / ITER;

    /* Time sending the same amount of data, but without the transpose */
    MPI_Barrier(MPI_COMM_WORLD);
    t1 = MPI_Wtime();
    for (i = 0; i < ITER; i++) {
        if (myrank == 0) {
            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);
        } else {
            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);
        }
    }
    t2 = MPI_Wtime();
    ts = (t2 - t1) / ITER;

    /* Time sending the same amount of data, with the transpose done
     * as a separate step */
    MPI_Barrier(MPI_COMM_WORLD);
    t1 = MPI_Wtime();
    for (k = 0; k < ITER; k++) {
        if (myrank == 0) {
            MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);
        } else {
            MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);
            for (i = 0; i < SIZE; i++)
                for (j = i; j < SIZE; j++) {
                    temp = b[j][i];
                    b[j][i] = b[i][j];
                    b[i][j] = temp;
                }
        }
    }
    t2 = MPI_Wtime();
    tst = (t2 - t1) / ITER;

    /* Print out the results */
    if (myrank == 1) {
        /* if t and tst are too different, then there is a performance
         * problem in the handling of the datatypes */

        if (t > 2 * tst) {
            errs++;
            fprintf(stderr,
                    "Transpose time with datatypes is more than twice time without datatypes\n");
            fprintf(stderr, "%f\t%f\t%f\n", t, ts, tst);
        }
    }

    MPI_Type_free(&col);
    MPI_Type_free(&xpose);

    MTest_Finalize(errs);
    return MTestReturnValue(errs);
}
```


Overlapping Code:
```
 argc, char *argv[])
{
int i, j, k;
static double a[SIZE][SIZE], b[SIZE][SIZE];
double t1, t2, t, ts, tst;
double temp;
int myrank, mysize, errs = 0;
MPI_Status status;
MPI_Aint sizeofreal;
MPI_Datatype col, xpose;
MTest_Init(&argc, &argv);
MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
MPI_Comm_size(MPI_COMM_WORLD, &mysize);
if (mysize != 2) {
fprintf(stderr, "This test must be run with 2 processes\n");
MPI_Abort(MPI_COMM_WORLD, 1);
}
MPI_Type_extent(MPI_DOUBLE, &sizeofreal);
MPI_Type_vector(SIZE, 1, SIZE, MPI_DOUBLE, &col);
MPI_Type_hvector(SIZE, 1, sizeofreal, col, &xpose);
MPI_Type_commit(&xpose);
/* Preset the arrays so that they're in memory */
for (i = 0; i < SIZE; i++)
for (j = 0; j < SIZE; j++) {
a[i][j] = 0;
b[i][j] = 0;
}
a[SIZE - 1][0] = 1;
/* Time the transpose example */
MPI_Barrier(MPI_COMM_WORLD);
t1 = MPI_Wtime();
for (i = 0; i < ITER; i++) {
if (myrank == 0)
MPI_Send(&a[0][0], SIZE * SIZE, MPI_DOUBLE, 1, 0, MPI_COMM_WORLD);
else
MPI_Recv(&b[0][0], 1, xpose, 0, 0, MPI_COMM_WORLD, &status);
}
t2 = MPI_Wtime();
t = (t2 - t1) / ITER;
/* Time sending the same amount of data, but without the transpose */
MPI_Barrier(MPI_COMM_WORLD);
t1 = MPI_Wtime();
for (i = 0; i < ITER; i++) {
if (myrank == 0) {
MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);
} else {
MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);
}
}
t2 = MPI_Wtime();
ts = (t2 - t1) / ITER;
/* Time sending the same amount of data, with the transpose done
* as a separate step */
MPI_Barrier(MPI_COMM_WORLD);
t1 = MPI_Wtime();
for (k = 0; k < ITER; k++) {
if (myrank == 0) {
MPI_Send(&a[0][0], sizeof(a), MPI_BYTE, 1, 0, MPI_COMM_WORLD);
} else {
MPI_Recv(&b[0][0], sizeof(b), MPI_BYTE, 0, 0, MPI_COMM_WORLD, &status);
for (i = 0; i < SIZE; i++)
for (j = i; j < SIZE; j++) {
temp = b[j][i];
b[j][i] = b[i][j];
b[i][j] = temp;
}
}
}
t2 = MPI_Wtime();
tst = (t2 - t1) / ITER;
/* Print out the results */
if (myrank == 1) {
/* if t and tst are too different, then 
```
<Overlap Ratio: 0.9860627177700348>

---

--- 148 --
Question ID: 5af82e808c4bf7ee73cf5fd248f405ee969a7b67_8
Original Code:
```
void ulver_hub_wait(ulver_env *env, ulver_coro *coro) {
	ulver_thread *ut = ulver_current_thread(env);
	// add the current coro as a a waiting one
	ut->current_coro->waiting_for = coro;
	ulver_coro_switch(env, ut->hub);
}
```


Overlapping Code:
```
_hub_wait(ulver_env *env, ulver_coro *coro) {
ulver_thread *ut = ulver_current_thread(env);
// add the current coro as a a waiting one
ut->current_coro->waiting_for = coro;
ulver_coro_switch(env, ut->
```
<Overlap Ratio: 0.9216589861751152>

---

--- 149 --
Question ID: 5fe5ea81fc8f6133d33ecd5340974464e314b90a_118
Original Code:
```
int
strwaitmark(vnode_t *vp)
{
	struct stdata *stp = vp->v_stream;
	queue_t *rq = _RD(stp->sd_wrq);
	int mark;

	mutex_enter(&stp->sd_lock);
	while (rq->q_first == NULL &&
	    !(stp->sd_flag & (STRATMARK|STRNOTATMARK|STREOF))) {
		stp->sd_flag |= RSLEEP;

		/* Wait for 100 milliseconds for any state change. */
		if (str_cv_wait(&rq->q_wait, &stp->sd_lock, 100, 1) == -1) {
			mutex_exit(&stp->sd_lock);
			return (-1);
		}
	}
	if (stp->sd_flag & STRATMARK)
		mark = 1;
	else if (rq->q_first != NULL && (rq->q_first->b_flag & MSGMARK))
		mark = 1;
	else
		mark = 0;

	mutex_exit(&stp->sd_lock);
	return (mark);
}
```


Overlapping Code:
```
)
{
struct stdata *stp = vp->v_stream;
queue_t *rq = _RD(stp->sd_wrq);
int mark;
mutex_enter(&stp->sd_lock);
while (rq->q_first == NULL &&
!(stp->sd_flag & (STRATMARK|STRNOTATMARK|STREOF))) {
stp->sd_flag |= RSLEEP;
/* Wait for 100 milliseconds for any state change. */
if (str_cv_wait(&rq->q_wait, &stp->sd_lock, 100, 1) == -1) {
mutex_exit(&stp->sd_lock);
return (-1);
}
}
if (stp->sd_flag & STRATMARK)
mark = 1;
else if (rq->q_first != NULL && (rq->q_first->b_flag & MSGMARK))
mark = 1;
else
mark 
```
<Overlap Ratio: 0.8695652173913043>

---

--- 150 --
Question ID: 8329f30483c494b9a9c846bfc92fdce9e6a6eacb_0
Original Code:
```
class FileSystem {
public:
    static class IFileWrite * OpenWriteFile(const char * fileName, bool append, class IInstanceLog * log);
    static class IFileRead * OpenReadFile(const char * fileName, class IInstanceLog * log);
    static class IDirectory * OpenDirectory(const char * directoryPath, class IInstanceLog * log);
    static class IElfBinary * OpenElfBinary(const char * bin, class IInstanceLog * log);
    static bool ReadWholeFile(const char * filename, char * readBuffer, size_t size, class IInstanceLog * log);
    static bool WriteWholeFile(const char * filename, const char * writeBuffer, size_t size, class IInstanceLog * log);
    static bool ScanFile(class IInstanceLog * log, const char * filename, const char * format, ...);
    static bool FileExists(const char * filename, class IInstanceLog * log);
    static time_t GetLastWriteTime(const char * filename, class IInstanceLog * log);
    static off_t GetFileSize(const char * filename, class IInstanceLog * log);
    static off_t GetFileBlockSize(const char * filename, class IInstanceLog * log);
    static bool Rename(const char * oldName, const char * newName, class IInstanceLog * log);
    static bool RemoveFile(const char * filename, class IInstanceLog * log);
    static bool CreateDirectory(const char * absolutePath, int mode, class IInstanceLog * log);
    static bool RemoveDirectory(const char * directoryPath, class IInstanceLog * log);
    static bool ChangeOwner(const char * path, const char * newOwner, const char * newGroup, class IInstanceLog * log);
    static bool ChangeMode(const char * path, int mode, class IInstanceLog * log);
    static ulong64 GetFileSystemTotalSize(const char * path, class IInstanceLog * log);
    static ulong64 GetFileSystemUsedSpace(const char * path, class IInstanceLog * log);
    static bool CheckSystemUser(const char * user, const char * group, class IInstanceLog * log);
    static char * GetFileSystemUser(const char * filepath, class IInstanceLog * log);
}
```


Overlapping Code:
```
ss FileSystem {
public:
static class IFileWrite * OpenWriteFile(const char * fileName, bool append, class IInstanceLog * log);
static class IFileRead * OpenReadFile(const char * fileName, class IInstanceLog * log);
static class IDirectory * OpenDirectory(const char * directoryPath, class IInstanceLog * log);
static class IElfBinary * OpenElfBinary(const char * bin, class IInstanceLog * log);
static bool ReadWholeFile(const char * filename, char * readBuffer, size_t size, class IInstanceLog * log);
static bool WriteWholeFile(const char * filename, const char * writeBuffer, size_t size, class IInstanceLog * log);
static bool ScanFile(class IInstanceLog * log, const char * filename, const char * format, ...);
static bool FileExists(const char * filename, class IInstanceLog * log);
static time_t GetLastWriteTime(const char * filename, class IInstanceLog * log);
static off_t GetFileSize(const char * filename, class IInstanceLog * log);
static off_t GetFileBlockSize(const char * filename, class IInstanceLog * log);
static bool Rename(const char * oldName, const char * newName, class IInstanceLog * log);
static bool RemoveFile(const char * filename, class IInstanceLog * log);
static bool CreateDirectory(const char * absolutePath, int mode, class IInstanceLog * log);
static bool RemoveDirectory(const char * directoryPath, class IInstanceLog * log);
static bool ChangeOwner(const char * path, const char * newOwner, const char * newGroup, class IInstanceLog * log);
static bool ChangeMode(const char * path, int mode, class IInstanceLog * log);
static ulong64 GetFileSystemTotalSize(const char * path, class IInstanceLog * log);
static ulong64 GetFileSystemUsedSpace(const char * path, class IInstanceLog * log);
static bool CheckSystemUser(const char * user, const char * group, class IInstanceLog * log);
static char * GetFileSystemUser(const char * filepath, class IInstanceLog * log)
```
<Overlap Ratio: 0.9968520461699895>

---

--- 151 --
Question ID: 2a58ad6e602cf646275d11ac2a455c1f48131e9e_10
Original Code:
```
int osdp_compute_mac(struct osdp_pd *p, int is_cmd, const uint8_t *data, int len)
{
	int pad_len;
	uint8_t buf[OSDP_PACKET_BUF_SIZE] = { 0 };
	uint8_t iv[16];

	memcpy(buf, data, len);
	pad_len = (len % 16 == 0) ? len : get_pad_len(len);
	if (len % 16 != 0)
		buf[len] = 0x80; /* end marker */

	/**
	 * MAC for data blocks B[1] .. B[N] (post padding) is computed as:
	 * IV1 = R_MAC (or) C_MAC  -- depending on is_cmd
	 * IV2 = B[N-1] after -- AES-CBC ( IV1, B[1] to B[N-1], SMAC-1 )
	 * MAC = AES-ECB ( IV2, B[N], SMAC-2 )
	 */

	memcpy(iv, is_cmd ? p->sc.r_mac : p->sc.c_mac, 16);
	if (pad_len > 16) {
		/* N-1 blocks -- encrypted with SMAC-1 */
		osdp_encrypt(p->sc.s_mac1, iv, buf, pad_len - 16);
		/* N-1 th block is the IV the N th block */
		memcpy(iv, buf + pad_len - 32, 16);
	}
	/* N-th Block encrypted with SMAC-2 == MAC */
	osdp_encrypt(p->sc.s_mac2, iv, buf + pad_len - 16, 16);
	memcpy(is_cmd ? p->sc.c_mac : p->sc.r_mac, buf + pad_len - 16, 16);

#if 0
    LOG_D(TAG "MAC Diagnostics is_cmd: %d", is_cmd);
    osdp_dump("S-MAC1", p->sc.s_mac1, 16);
    osdp_dump("S-MAC2", p->sc.s_mac2, 16);
    osdp_dump("IV", iv, 16);
    osdp_dump("R-MAC", p->sc.r_mac, 16);
    osdp_dump("C-MAC", p->sc.c_mac, 16);
#endif

	return 0;
}
```


Overlapping Code:
```
compute_mac(struct osdp_pd *p, int is_cmd, const uint8_t *data, int len)
{
int pad_len;
uint8_t buf[OSDP_PACKET_BUF_SIZE] = { 0 };
uint8_t iv[16];
memcpy(buf, data, len);
pad_len = (len % 16 == 0) ? len : get_pad_len(len);
if (len % 16 != 0)
buf[len] = 0x80; /* end marker */
/**
* MAC for data blocks B[1] .. B[N] (post padding) is computed as:
* IV1 = R_MAC (or) C_MAC -- depending on is_cmd
* IV2 = B[N-1] after -- AES-CBC ( IV1, B[1] to B[N-1], SMAC-1 )
* MAC = AES-ECB ( IV2, B[N], SMAC-2 )
*/
memcpy(iv, is_cmd ? p->sc.r_mac : p->sc.c_mac, 16);
if (pad_len > 16) {
/* N-1 blocks -- encrypted with SMAC-1 */
osdp_encrypt(p->sc.s_mac1, iv, buf, pad_len - 16);
/* N-1 th block is the IV the N th block */
memcpy(iv, buf + pad_len - 32, 16);
}
/* N-th Block encrypted with SMAC-2 == MAC */
osdp_encrypt(p->sc.s_mac2, iv, buf + pad_len - 16, 16);
memcpy(is_cmd ? p->sc.c_mac : p->sc.r_mac, buf + pad_len - 16, 16);
#if 0
LOG_D(TAG "MAC Diagnostics is_cmd: %d", is_cmd);
osdp_dump("S-MAC1", p->sc.s_mac1, 16);
osdp_dump("S-MAC2", p->sc.s_mac2, 16);
osdp_dump("IV", iv, 16);
osdp_dump("R-MAC", p->sc.r_mac, 16);
osdp_dump("C-MAC", p->sc.c_m
```
<Overlap Ratio: 0.9693617021276596>

---

--- 152 --
Question ID: 19299e377e35a371d414fbd0db1727c9ee477621_23
Original Code:
```
const char * __thiscall IVRSystem_020_GetEventTypeNameFromEnum(void *_this, EVREventType eType)
{
    push_ptr_parameter(_this);
    push_uint32_parameter(eType);
    return 0;
}
```


Overlapping Code:
```
_020_GetEventTypeNameFromEnum(void *_this, EVREventType eType)
{
push_ptr_parameter(_this);
push_uint32_parameter(eType);
return 0
```
<Overlap Ratio: 0.7831325301204819>

---

--- 153 --
Question ID: 846a9997156ea49969e721be538ae2c1b501cc70_0
Original Code:
```
int main(int argc, char* argv[])
{
  GMainLoop* gst_main_loop;
  GThread* main_loop_thread;
  struct event_base* base = NULL;
  struct evhttp* httpSvr = NULL;
  int res = 0;

#ifdef _WIN32
  {
    /* If running on Windows need to initialise sockets. */
    WORD wVersionRequested;
    WSADATA wsaData;
    wVersionRequested = MAKEWORD(2, 2);
    WSAStartup(wVersionRequested, &wsaData);
  }
#endif

  /* Initialise GStreamer. */
  gst_init (&argc, &argv);

  gst_main_loop = g_main_loop_new(NULL, FALSE);
  main_loop_thread = g_thread_new("main_loop", (GThreadFunc)g_main_loop_run, gst_main_loop);
  if (main_loop_thread == NULL) {
    fprintf(stderr, "Couldn't create a main loop thread.\n");
    return -1;
  }

  /* Initialise libevent HTTP server. */
  base = event_base_new();
  if (!base) {
    fprintf(stderr, "Couldn't create an event_base: exiting.\n");
    return -1;
  }

  httpSvr = evhttp_new(base);
  if (!httpSvr) {
    fprintf(stderr, "couldn't create evhttp. Exiting.\n");
    return -1;
  }

  res = evhttp_bind_socket(httpSvr, HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);
  if (res != 0) {
    fprintf(stderr, "Failed to start HTTP server on %s:%d.\n", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);
    return res;
  }

  evhttp_set_allowed_methods(httpSvr,
    EVHTTP_REQ_GET |
    EVHTTP_REQ_POST |
    EVHTTP_REQ_OPTIONS);

  printf("Waiting for SDP offer on http://%s:%d%s...\n", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT, HTTP_OFFER_URL);

  res = evhttp_set_cb(httpSvr, HTTP_OFFER_URL, on_http_request_cb, NULL);

  event_base_dispatch(base);

  g_main_loop_unref (gst_main_loop);

  evhttp_free(httpSvr);

#ifdef _WIN32
  WSACleanup();
#endif

  return 0;
}
```


Overlapping Code:
```
* gst_main_loop;
GThread* main_loop_thread;
struct event_base* base = NULL;
struct evhttp* httpSvr = NULL;
int res = 0;
#ifdef _WIN32
{
/* If running on Windows need to initialise sockets. */
WORD wVersionRequested;
WSADATA wsaData;
wVersionRequested = MAKEWORD(2, 2);
WSAStartup(wVersionRequested, &wsaData);
}
#endif
/* Initialise GStreamer. */
gst_init (&argc, &argv);
gst_main_loop = g_main_loop_new(NULL, FALSE);
main_loop_thread = g_thread_new("main_loop", (GThreadFunc)g_main_loop_run, gst_main_loop);
if (main_loop_thread == NULL) {
fprintf(stderr, "Couldn't create a main loop thread.\n");
return -1;
}
/* Initialise libevent HTTP server. */
base = event_base_new();
if (!base) {
fprintf(stderr, "Couldn't create an event_base: exiting.\n");
return -1;
}
httpSvr = evhttp_new(base);
if (!httpSvr) {
fprintf(stderr, "couldn't create evhttp. Exiting.\n");
return -1;
}
res = evhttp_bind_socket(httpSvr, HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);
if (res != 0) {
fprintf(stderr, "Failed to start HTTP server on %s:%d.\n", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT);
return res;
}
evhttp_set_allowed_methods(httpSvr,
EVHTTP_REQ_GET |
EVHTTP_REQ_POST |
EVHTTP_REQ_OPTIONS);
printf("Waiting for SDP offer on http://%s:%d%s...\n", HTTP_SERVER_ADDRESS, HTTP_SERVER_PORT, HTTP_OFFER_URL);
res = evhttp_set_cb(httpSvr, HTTP_OFFER_URL, on_http_request_cb, NULL);
event_base_dispatch(base);
g_main_loop_unref (gst_main_loop);
evhttp_free(httpSvr);
#ifdef _WIN3
```
<Overlap Ratio: 0.9489528795811518>

---

--- 154 --
Question ID: d180416590501365fda07cc955d1e4e94b497501_12
Original Code:
```
static void thread_bsp_init(void)
{
    uint32_t error_code = bsp_init(BSP_INIT_LEDS | BSP_INIT_BUTTONS, bsp_event_handler);
    APP_ERROR_CHECK(error_code);

    error_code = bsp_thread_init(thread_ot_instance_get());
    APP_ERROR_CHECK(error_code);
}
```


Overlapping Code:
```
tic void thread_bsp_init(void)
{
uint32_t error_code = bsp_init(BSP_INIT_LEDS | BSP_INIT_BUTTONS, bsp_event_handler);
APP_ERROR_CHECK(error_code);
error_code = bsp_thread_init(thread_ot_instance_get());
APP_ERROR_CHECK(error_code);

```
<Overlap Ratio: 0.9830508474576272>

---

--- 155 --
Question ID: c820162cac14ed07a0a0937dbf1f5dcdd7851559_9
Original Code:
```
static int sigar_swap_fs_get(sigar_t *sigar, sigar_swap_t *swap) /* <= 10.3 */
{
    DIR *dirp;
    struct dirent *ent;
    char swapfile[SSTRLEN(VM_DIR) + SSTRLEN("/") + SSTRLEN(SWAPFILE) + 12];
    struct stat swapstat;
    struct statfs vmfs;
    sigar_uint64_t val, bsize;

    swap->used = swap->total = swap->free = 0;

    if (!(dirp = opendir(VM_DIR))) {
         return errno;
     }
 
    /* looking for "swapfile0", "swapfile1", etc. */
    while ((ent = readdir(dirp))) {
        char *ptr = swapfile;

        if ((ent->d_namlen < SSTRLEN(SWAPFILE)+1) || /* n/a, see comment above */
            (ent->d_namlen > SSTRLEN(SWAPFILE)+11)) /* ensure no overflow */
        {
            continue;
        }

        if (!strnEQ(ent->d_name, SWAPFILE, SSTRLEN(SWAPFILE))) {
            continue;
        }
        
        /* sprintf(swapfile, "%s/%s", VM_DIR, ent->d_name) */

        memcpy(ptr, VM_DIR, SSTRLEN(VM_DIR));
        ptr += SSTRLEN(VM_DIR);

        *ptr++ = '/';

        memcpy(ptr, ent->d_name, ent->d_namlen+1);

        if (stat(swapfile, &swapstat) < 0) {
            continue;
        }

        swap->used += swapstat.st_size;
    }

    closedir(dirp);

    if (statfs(VM_DIR, &vmfs) < 0) {
        return errno;
    }

    bsize = vmfs.f_bsize / 512;
    val = vmfs.f_bfree;
    swap->total = SIGAR_FS_BLOCKS_TO_BYTES(val, bsize) + swap->used;

    swap->free = swap->total - swap->used;

    return SIGAR_OK;
}
```


Overlapping Code:
```
 int sigar_swap_fs_get(sigar_t *sigar, sigar_swap_t *swap) /* <= 10.3 */
{
DIR *dirp;
struct dirent *ent;
char swapfile[SSTRLEN(VM_DIR) + SSTRLEN("/") + SSTRLEN(SWAPFILE) + 12];
struct stat swapstat;
struct statfs vmfs;
sigar_uint64_t val, bsize;
swap->used = swap->total = swap->free = 0;
if (!(dirp = opendir(VM_DIR))) {
return errno;
}

/* looking for "swapfile0", "swapfile1", etc. */
while ((ent = readdir(dirp))) {
char *ptr = swapfile;
if ((ent->d_namlen < SSTRLEN(SWAPFILE)+1) || /* n/a, see comment above */
(ent->d_namlen > SSTRLEN(SWAPFILE)+11)) /* ensure no overflow */
{
continue;
}
if (!strnEQ(ent->d_name, SWAPFILE, SSTRLEN(SWAPFILE))) {
continue;
}

/* sprintf(swapfile, "%s/%s", VM_DIR, ent->d_name) */
memcpy(ptr, VM_DIR, SSTRLEN(VM_DIR));
ptr += SSTRLEN(VM_DIR);
*ptr++ = '/';
memcpy(ptr, ent->d_name, ent->d_namlen+1);
if (stat(swapfile, &swapstat) < 0) {
continue;
}
swap->used += swapstat.st_size;
}
closedir(dirp);
if (statfs(VM_DIR, &vmfs) < 0) {
return errno;
}
bsize = vmfs.f_bsize / 512;
val = vmfs.f_bfree;
swap->total = SIGAR_FS_BLOCKS_TO_BYTES(val, bsize) + swap->used;
swap->free = swap->total - swap->used;
return SIGAR_OK;
```
<Overlap Ratio: 0.9931212381771282>

---

--- 156 --
Question ID: 860554cbed4d6a3757abdcf5301e10822dfb2da8_0
Original Code:
```
class MPv4
  :
  public MPv3
{
  public:
  ///
  /// Constructor
  ///
  MPv4(
      const int,  ///< grid dimensions
      const int,  ///< Coordinate System flag
      const int,  ///< Total number of variables in state vector
      const int,  ///< Number of tracer variables in state vector.
      const std::string *, ///< List of what the tracer variables mean.
      struct which_physics *, ///< extra physics stuff.
      struct rad_sources *,    ///< radiation sources.
      const double  ///< EOS Gamma
      );

  ///
  /// Destructor
  ///
  ~MPv4();

  ///
  /// This takes a copy of the primitive vector and advances it in
  /// time over the step requested, and at the end copies the updated
  /// vector into the destination vector.  For fully local
  /// microphysics but WITH radiative transfer, where the column
  /// densities for diffuse and direct radiation are included as
  /// parameters.  The input list of column densities is ordered by
  /// the number of sources in each category in the vector of
  /// integers.
  ///
  /// Integers refer to:
  /// - Number of diffuse ionising sources (at infinity), 
  /// - Number of diffuse UV sources (at infinity),
  /// - Number of ionising point sources,
  /// - Number of UV point sources.
  ///
  /// Returned data is the time-averaged column density
  /// <<\delta\rho\times\delta x>>
  ///
  virtual int TimeUpdateMP_RTnew(
          const pion_flt *, ///< Primitive Vector to be updated.
          const int,      ///< Number of UV heating sources.
          const std::vector<struct rt_source_data> &,
          ///< list of UV-heating column densities and source properties.
          const int,      ///< number of ionising radiation sources.
          const std::vector<struct rt_source_data> &,
          ///< list of ionising src column densities and source properties.
          pion_flt *,       ///< Destination Vector for updated values
                         ///< (can be same as first Vector.
          const double,   ///< Time Step to advance by.
          const double,   ///< EOS gamma.
          const int, ///< Switch for what type of integration to use.
                    ///< (0=adaptive RK5, 1=adaptive Euler,2=onestep o4-RK)
          double *    ///< any returned data (final temperature?).
          );

  ///
  /// This returns the minimum timescale of the times flagged in the
  /// arguments.  (photoionisation time is not implemented).
  ///
  double timescales(
          const pion_flt *, ///< Current cell.
          const double,   ///< EOS gamma.
          const bool, ///< set to 'true' if including cooling time.
          const bool, ///< set to 'true' if including recombination time.
          const bool  ///< set to 'true' if including photo-ionsation time.
          );

  ///
  /// This returns the minimum timescale of all microphysical 
  /// processes, including reaction times for each species and the
  /// total heating/cooling time for the gas.  It requires the
  /// radiation field as an input, so it has substantially greater
  /// capability than the other timescales function.
  ///
  double timescales_RT(
          const pion_flt *, ///< Current cell.
          const int,      ///< Number of UV heating sources.
          const std::vector<struct rt_source_data> &,
          ///< list of UV-heating column densities and source properties.
          const int,      ///< number of ionising radiation sources.
          const std::vector<struct rt_source_data> &,
          ///< list of ionising src column densities and source properties.
          const double   ///< EOS gamma.
          );

  protected:
  ///
  /// convert state vector from grid cell into local microphysics
  /// vector.
  ///
  virtual int convert_prim2local(
          const pion_flt *, ///< primitive vector from grid cell (length nv_prim)
          double *        ///< local vector [x,E](n+1).
          );

  ///
  /// Convert int(exp(-dtau)dt) into time-averaged value of
  /// rho*(1-x)*ds
  ///
  double get_timeaveraged_rhodx(
            const double, ///< this is int(exp(-dtau)dt)
            const double  ///< this is dt
            );
          
  ///
  /// Set the size of local vectors, and index them with integers.
  ///
  virtual void setup_local_vectors();

  int lv_dtau; ///< index of dtau variable in local vector.

  //---------------------------------------------------------------------------
  //-------------- FUNCTIONS DERIVED FROM BASE CLASS FOLLOW -------------------
  //---------------------------------------------------------------------------
  public:
  ///
  /// calculate dy/dt for the vector of y-values.
  ///
  virtual int ydot(
          double,         ///< current time (probably not needed for rate equations)
          const N_Vector, ///< current Y-value
          N_Vector,       ///< vector for Y-dot values
          const double *  ///< extra user-data vector, P, for evaluating ydot(y,t,p)
          );

  ///
  /// Get the number of extra parameters and the number of equations.
  ///
  virtual void get_problem_size(int *, ///< number of equations
                        int *  ///< number of parameters in user_data vector.
                        );
  protected:
  ///
  /// set the relative and absolute error tolerances
  ///
  virtual void get_error_tolerances(
          double *, ///< relative error tolerance (single value)
          double []  ///< absolute error tolerance (array)
          );

  //---------------------------------------------------------------------------
  //-------------- END OF FUNCTIONS DERIVED FROM BASE CLASS -------------------
  //---------------------------------------------------------------------------
}
```


Overlapping Code:
```
v4
:
public MPv3
{
public:
///
/// Constructor
///
MPv4(
const int, ///< grid dimensions
const int, ///< Coordinate System flag
const int, ///< Total number of variables in state vector
const int, ///< Number of tracer variables in state vector.
const std::string *, ///< List of what the tracer variables mean.
struct which_physics *, ///< extra physics stuff.
struct rad_sources *, ///< radiation sources.
const double ///< EOS Gamma
);
///
/// Destructor
///
~MPv4();
///
/// This takes a copy of the primitive vector and advances it in
/// time over the step requested, and at the end copies the updated
/// vector into the destination vector. For fully local
/// microphysics but WITH radiative transfer, where the column
/// densities for diffuse and direct radiation are included as
/// parameters. The input list of column densities is ordered by
/// the number of sources in each category in the vector of
/// integers.
///
/// Integers refer to:
/// - Number of diffuse ionising sources (at infinity), 
/// - Number of diffuse UV sources (at infinity),
/// - Number of ionising point sources,
/// - Number of UV point sources.
///
/// Returned data is the time-averaged column density
/// <<\delta\rho\times\delta x>>
///
virtual int TimeUpdateMP_RTnew(
const pion_flt *, ///< Primitive Vector to be updated.
const int, ///< Number of UV heating sources.
const std::vector<struct rt_source_data> &,
///< list of UV-heating column densities and source properties.
const int, ///< number of ionising radiation sources.
const std::vector<struct rt_source_data> &,
///< list of ionising src column densities and source properties.
pion_flt *, ///< Destination Vector for updated values
///< (can be same as first Vector.
const double, ///< Time Step to advance by.
const double, ///< EOS gamma.
const int, ///< Switch for what type of integration to use.
///< (0=adaptive RK5, 1=adaptive Euler,2=onestep o4-RK)
double * ///< any returned data (final temperature?).
);
///
/// This returns the minimum timescale of the times flagged in the
/// arguments. (photoionisation time is not implemented
```
<Overlap Ratio: 0.9762900976290098>

---

--- 157 --
Question ID: 0aedd3ee13dbdbfec9fb8a5477992c48dee8226d_1
Original Code:
```
ISR(TIMER2_OVF_vect)
{
  ADCSRA = ADCSRA |  _BV(ADSC);
  BZR(value);
  itoa(value, word, 10);
 
}
```


Overlapping Code:
```
ADCSRA = ADCSRA | _BV(ADSC);
BZR(value);
itoa(valu
```
<Overlap Ratio: 0.5617977528089888>

---

--- 158 --
Question ID: 0dbada8eca2501902288ba2d93834ef3c7b6980e_55
Original Code:
```
static void file_no_access_to_file(void)
{
	int fd;
	/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


	mkdir(WORKDIR"/embedlog-no-write", 0755);
	fd = open(WORKDIR"/embedlog-no-write/log", O_CREAT, 0444);
	close(fd);

	if (getuid() == 0)
	{
		mt_fok(el_option(EL_FPATH, WORKDIR"/embedlog-no-write/log"));
		mt_fok(el_puts(s5));
		mt_fok(file_check(WORKDIR"/embedlog-no-write/log", s5));
	}
	else
	{
		mt_ferr(el_option(EL_FPATH, WORKDIR"/embedlog-no-write/log"), EACCES);
		mt_ferr(el_puts("whatever"), EACCES);
	}
	unlink(WORKDIR"/embedlog-no-write/log");
	rmdir(WORKDIR"/embedlog-no-write");
}
```


Overlapping Code:
```
s_to_file(void)
{
int fd;
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
mkdir(WORKDIR"/embedlog-no-write", 0755);
fd = open(WORKDIR"/embedlog-no-write/log", O_CREAT, 0444);
close(fd);
if (getuid() == 0)
{
mt_fok(el_option(EL_FPATH, WORKDIR"/embedlog-no-write/log"));
mt_fok(el_puts(s5));
mt_fok(file_check(WORKDIR"/embedlog-no-write/log", s5));
}
else
{
mt_ferr(el_option(EL_FPATH, WORKDIR"/embedlog-no-write/log"), EACCES);
mt_ferr(el_puts("whatever"), EACCES);
}
unlink(WORKDIR"/embedlog-no-write/log");
rmdir(WORKDIR"/embe
```
<Overlap Ratio: 0.9277310924369748>

---

--- 159 --
Question ID: c8c1b2f368b137f3d044336d70d94f2b892a21a6_5
Original Code:
```
TEST_FUNCTION(srw_lock_create_succeeds)
{
    ///arrange
    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));
    STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));
    STRICT_EXPECTED_CALL(timer_create_new())
        .SetReturn((TIMER_HANDLE)my_malloc(2));
    STRICT_EXPECTED_CALL(mocked_InitializeSRWLock(IGNORED_ARG));

    ///act
    SRW_LOCK_HANDLE bsdlLock = srw_lock_create(true, "test_lock");

    ///assert
    ASSERT_IS_NOT_NULL(bsdlLock);
    ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());

    ///clean
    srw_lock_destroy(bsdlLock);
}
```


Overlapping Code:
```
T_FUNCTION(srw_lock_create_succeeds)
{
///arrange
STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));
STRICT_EXPECTED_CALL(malloc(IGNORED_ARG));
STRICT_EXPECTED_CALL(timer_create_new())
.SetReturn((TIMER_HANDLE)my_malloc(2));
STRICT_EXPECTED_CALL(mocked_InitializeSRWLock(IGNORED_ARG));
///act
SRW_LOCK_HANDLE bsdlLock = srw_lock_create(true, "test_lock");
///assert
ASSERT_IS_NOT_NULL(bsdlLock);
ASSERT_ARE_EQUAL(char_ptr, umock_c_get_expected_calls(), umock_c_get_actual_calls());
///clean
srw_lock_destroy(bs
```
<Overlap Ratio: 0.974757281553398>

---

--- 160 --
Question ID: 0a0f477797deecbc0e28c5869961486a9818ad0f_8
Original Code:
```
static INT64 calculate_op(YMF271Chip *chip, int slotnum, INT64 inp)
{
	YMF271Slot *slot = &chip->slots[slotnum];
	INT64 env, slot_output, slot_input = 0;

	update_envelope(slot);
	update_lfo(chip, slot);
	env = calculate_slot_volume(chip, slot);

	if (inp == OP_INPUT_FEEDBACK)
	{
		// from own feedback
		slot_input = (slot->feedback_modulation0 + slot->feedback_modulation1) / 2;
		slot->feedback_modulation0 = slot->feedback_modulation1;
	}
	else if (inp != OP_INPUT_NONE)
	{
		// from previous slot output
		slot_input = ((inp << (SIN_BITS-2)) * modulation_level[slot->feedback]);
	}

	slot_output = chip->lut_waves[slot->waveform][((slot->stepptr + slot_input) >> 16) & SIN_MASK];
	slot_output = (slot_output * env) >> 16;
	slot->stepptr += slot->step;

	return slot_output;
}
```


Overlapping Code:
```
YMF271Chip *chip, int slotnum, INT64 inp)
{
YMF271Slot *slot = &chip->slots[slotnum];
INT64 env, slot_output, slot_input = 0;
update_envelope(slot);
update_lfo(chip, slot);
env = calculate_slot_volume(chip, slot);
if (inp == OP_INPUT_FEEDBACK)
{
// from own feedback
slot_input = (slot->feedback_modulation0 + slot->feedback_modulation1) / 2;
slot->feedback_modulation0 = slot->feedback_modulation1;
}
else if (inp != OP_INPUT_NONE)
{
// from previous slot output
slot_input = ((inp << (SIN_BITS-2)) * modulation_level[slot->feedback]);
}
slot_output = chip->lut_waves[slot->waveform][((slot->stepptr + slot_input) >> 16) & SIN_MASK];
slot_output = (slot_output * env) >> 16;
slot->stepptr += slot->ste
```
<Overlap Ratio: 0.9335106382978723>

---

--- 161 --
Question ID: 92673de26eb836af89af7e4a526b41def3cfd284_46
Original Code:
```
static void
ste_map_io(STE10_100 * ste)
{
	uint32_t base = ste->bar0;
	MapProc *mapproc = PCI_RegisterIOH;
	/* IO-Space enabled ? */
	if (!(ste->command & 1)) {
		fprintf(stderr, "STE: iospace not enabled %d\n", __LINE__);
	}
	base = base & ~0x7f;
	ste_map(ste, mapproc, base);
}
```


Overlapping Code:
```
io(STE10_100 * ste)
{
uint32_t base = ste->bar0;
MapProc *mapproc = PCI_RegisterIOH;
/* IO-Space enabled ? */
if (!(ste->command & 1)) {
fprintf(stderr, "STE: iospace not enabled %d\n", __LINE__);
}
base = base & ~0x7f;
ste_map(ste, mapproc, base);
}
```
<Overlap Ratio: 0.9259259259259259>

---

--- 162 --
Question ID: 246a509f4e6895bc783916efd27d913363f9ccf3_7
Original Code:
```
int
afs_tp_create(struct afs_thread_pool ** pool_out,
	      struct afs_work_queue * queue)
{
    int ret = 0;
    struct afs_thread_pool * pool;

    ret = _afs_tp_alloc(pool_out);
    if (ret) {
	goto error;
    }
    pool = *pool_out;

    opr_mutex_init(&pool->lock);
    opr_cv_init(&pool->shutdown_cv);
    queue_Init(&pool->thread_list);
    pool->work_queue = queue;
    pool->entry = &_afs_tp_worker_default;
    pool->rock = NULL;
    pool->nthreads = 0;
    pool->max_threads = 4;
    pool->state = AFS_TP_STATE_INIT;

 error:
    return ret;
}
```


Overlapping Code:
```
l_out,
struct afs_work_queue * queue)
{
int ret = 0;
struct afs_thread_pool * pool;
ret = _afs_tp_alloc(pool_out);
if (ret) {
goto error;
}
pool = *pool_out;
opr_mutex_init(&pool->lock);
opr_cv_init(&pool->shutdown_cv);
queue_Init(&pool->thread_list);
pool->work_queue = queue;
pool->entry = &_afs_tp_worker_default;
pool->rock = NULL;
pool->nthreads = 0;
pool->max_threads = 4;
pool->state = AFS_TP_
```
<Overlap Ratio: 0.8350730688935282>

---

--- 163 --
Question ID: d18844dfed35e8806c7ae0fc0edb034dcb56d5e0_290
Original Code:
```
static inline result_t markElementAsNotACKed_TinyDWFQ(TinyDWFQPtr queue, TOS_MsgPtr msg)
{
  int8_t ind;
#line 700
  int8_t prevIndex;
  int8_t nextHead;

#line 702
  ind = queue->head[PENDING_TINYDWFQ];
  prevIndex = ind;

  while (ind != -1) 
    {
      if (queue->element[ind].obj == msg) 
        {

          nextHead = queue->element[ind].next;


          queue->element[ind].status = NOT_ACKED_TINYDWFQ;
          queue->element[ind].next = -1;
          queue->numOfElements_pending--;


          if (queue->head[NOT_ACKED_TINYDWFQ] == -1) 
            {

              queue->head[NOT_ACKED_TINYDWFQ] = queue->tail[NOT_ACKED_TINYDWFQ] = ind;
            }
          else 
            {

              queue->element[queue->tail[NOT_ACKED_TINYDWFQ]].next = ind;
              queue->tail[NOT_ACKED_TINYDWFQ] = ind;
            }
          queue->numOfElements_notAcked++;


          if (ind == queue->head[PENDING_TINYDWFQ]) 
            {

              if (nextHead == -1) 
                {
                  queue->head[PENDING_TINYDWFQ] = queue->tail[PENDING_TINYDWFQ] = -1;
                }
              else 
                {
                  queue->head[PENDING_TINYDWFQ] = nextHead;
                }
            }
          else {
#line 744
            if (ind == queue->tail[PENDING_TINYDWFQ]) 
              {

                queue->tail[PENDING_TINYDWFQ] = prevIndex;
                queue->element[prevIndex].next = -1;
              }
            else 
              {

                queue->element[prevIndex].next = nextHead;
              }
            }
#line 755
          return SUCCESS;
        }
      else 
        {
          prevIndex = ind;
          ind = queue->element[ind].next;
        }
    }
  return FAIL;
}
```


Overlapping Code:
```
sNotACKed_TinyDWFQ(TinyDWFQPtr queue, TOS_MsgPtr msg)
{
int8_t ind;
#line 700
int8_t prevIndex;
int8_t nextHead;
#line 702
ind = queue->head[PENDING_TINYDWFQ];
prevIndex = ind;
while (ind != -1) 
{
if (queue->element[ind].obj == msg) 
{
nextHead = queue->element[ind].next;
queue->element[ind].status = NOT_ACKED_TINYDWFQ;
queue->element[ind].next = -1;
queue->numOfElements_pending--;
if (queue->head[NOT_ACKED_TINYDWFQ] == -1) 
{
queue->head[NOT_ACKED_TINYDWFQ] = queue->tail[NOT_ACKED_TINYDWFQ] = ind;
}
else 
{
queue->element[queue->tail[NOT_ACKED_TINYDWFQ]].next = ind;
queue->tail[NOT_ACKED_TINYDWFQ] = ind;
}
queue->numOfElements_notAcked++;
if (ind == queue->head[PENDING_TINYDWFQ]) 
{
if (nextHead == -1) 
{
queue->head[PENDING_TINYDWFQ] = queue->tail[PENDING_TINYDWFQ] = -1;
}
else 
{
queue->head[PENDING_TINYDWFQ] = nextHead;
}
}
else {
#line 744
if (ind == queue->tail[PENDING_TINYDWFQ]) 
{
queue->tail[PENDING_TINYDWFQ] = prevIndex;
queue->element[prevIndex].next = -1;
}
else 
{
queue->element[prevIndex].next = nextHead;
}
}
#line 755
return SUCCESS;
}
else 
{
prevIndex = ind;
ind = queue->ele
```
<Overlap Ratio: 0.9414261460101867>

---

--- 164 --
Question ID: e9915549aeb073eb8ffe03325381ea200ced67f1_8
Original Code:
```
static mrb_value
mrb_sdl2_input_mouse_set_cursor(mrb_state *mrb, mrb_value self)
{
  mrb_sdl2_input_mouse_cursor_data_t *data;
  mrb_value cursor;
  mrb_get_args(mrb, "o", &cursor);
  data =
    (mrb_sdl2_input_mouse_cursor_data_t*)mrb_data_get_ptr(mrb, cursor, &mrb_sdl2_input_mouse_cursor_data_type);
  SDL_SetCursor(data->cursor);
  data->is_associated = true;
  return self;
}
```


Overlapping Code:
```
ursor(mrb_state *mrb, mrb_value self)
{
mrb_sdl2_input_mouse_cursor_data_t *data;
mrb_value cursor;
mrb_get_args(mrb, "o", &cursor);
data =
(mrb_sdl2_input_mouse_cursor_data_t*)mrb_data_get_ptr(mrb, cursor, &mrb_sdl2_input_mouse_cursor_data_type);
SDL_SetCursor(data->cursor);
data->is_associated = t
```
<Overlap Ratio: 0.8287292817679558>

---

--- 165 --
Question ID: 8a55e0f4498482267fbd2cd6f81922a5877c6ec7_10
Original Code:
```
int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,"testkeyspace",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }

    loaded_event_log = RedisModule_CreateDict(ctx);
    module_event_log = RedisModule_CreateDict(ctx);

    int keySpaceAll = RedisModule_GetKeyspaceNotificationFlagsAll();

    if (!(keySpaceAll & REDISMODULE_NOTIFY_LOADED)) {
        // REDISMODULE_NOTIFY_LOADED event are not supported we can not start
        return REDISMODULE_ERR;
    }

    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_LOADED, KeySpace_NotificationLoaded) != REDISMODULE_OK){
        return REDISMODULE_ERR;
    }

    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_GENERIC, KeySpace_NotificationGeneric) != REDISMODULE_OK){
        return REDISMODULE_ERR;
    }

    if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_MODULE, KeySpace_NotificationModule) != REDISMODULE_OK){
        return REDISMODULE_ERR;
    }

    if (RedisModule_CreateCommand(ctx,"keyspace.notify", cmdNotify,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }

    if (RedisModule_CreateCommand(ctx,"keyspace.is_module_key_notified", cmdIsModuleKeyNotified,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }

    if (RedisModule_CreateCommand(ctx,"keyspace.is_key_loaded", cmdIsKeyLoaded,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }

    if (RedisModule_CreateCommand(ctx,"keyspace.del_key_copy", cmdDelKeyCopy,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx,"keyspace.incr_case1", cmdIncrCase1,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx,"keyspace.incr_case2", cmdIncrCase2,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }
    
    if (RedisModule_CreateCommand(ctx,"keyspace.incr_case3", cmdIncrCase3,"",0,0,0) == REDISMODULE_ERR){
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}
```


Overlapping Code:
```
int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
REDISMODULE_NOT_USED(argv);
REDISMODULE_NOT_USED(argc);
if (RedisModule_Init(ctx,"testkeyspace",1,REDISMODULE_APIVER_1) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}
loaded_event_log = RedisModule_CreateDict(ctx);
module_event_log = RedisModule_CreateDict(ctx);
int keySpaceAll = RedisModule_GetKeyspaceNotificationFlagsAll();
if (!(keySpaceAll & REDISMODULE_NOTIFY_LOADED)) {
// REDISMODULE_NOTIFY_LOADED event are not supported we can not start
return REDISMODULE_ERR;
}
if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_LOADED, KeySpace_NotificationLoaded) != REDISMODULE_OK){
return REDISMODULE_ERR;
}
if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_GENERIC, KeySpace_NotificationGeneric) != REDISMODULE_OK){
return REDISMODULE_ERR;
}
if(RedisModule_SubscribeToKeyspaceEvents(ctx, REDISMODULE_NOTIFY_MODULE, KeySpace_NotificationModule) != REDISMODULE_OK){
return REDISMODULE_ERR;
}
if (RedisModule_CreateCommand(ctx,"keyspace.notify", cmdNotify,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}
if (RedisModule_CreateCommand(ctx,"keyspace.is_module_key_notified", cmdIsModuleKeyNotified,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}
if (RedisModule_CreateCommand(ctx,"keyspace.is_key_loaded", cmdIsKeyLoaded,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}
if (RedisModule_CreateCommand(ctx,"keyspace.del_key_copy", cmdDelKeyCopy,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}

if (RedisModule_CreateCommand(ctx,"keyspace.incr_case1", cmdIncrCase1,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}

if (RedisModule_CreateCommand(ctx,"keyspace.incr_case2", cmdIncrCase2,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}

if (RedisModule_CreateCommand(ctx,"keyspace.incr_case3", cmdIncrCase3,"",0,0,0) == REDISMODULE_ERR){
return REDISMODULE_ERR;
}
return REDISMODULE_OK;
}
```
<Overlap Ratio: 1.0>

---

--- 166 --
Question ID: 049fa6835b75b16387f74e2d16cd26cd5eac5a82_12
Original Code:
```
static void analyze_pdu(mate_config* mc, mate_pdu* pdu) {
	/* TODO:
	return a g_boolean to tell we've destroyed the pdu when the pdu is unnassigned
	destroy the unassigned pdu
	*/
	mate_cfg_gop* cfg = NULL;
	mate_gop* gop = NULL;
	gchar* gop_key;
	gchar* orig_gop_key = NULL;
	AVPL* candidate_start = NULL;
	AVPL* candidate_stop = NULL;
	AVPL* is_start = NULL;
	AVPL* is_stop = NULL;
	AVPL* gopkey_match = NULL;
	LoAL* gog_keys = NULL;
	AVPL* curr_gogkey = NULL;
	void* cookie = NULL;
	AVPL* gogkey_match = NULL;
	gchar* gogkey_str = NULL;

	dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: %s",pdu->cfg->name);

	if (! (cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gops_by_pduname,pdu->cfg->name)) )
		return;

	if ((gopkey_match = new_avpl_pairs_match("gop_key_match", pdu->avpl, cfg->key, TRUE, TRUE))) {
		gop_key = avpl_to_str(gopkey_match);

		g_hash_table_lookup_extended(cfg->gop_index,(gconstpointer)gop_key,(gpointer *)&orig_gop_key,(gpointer *)&gop);

		if ( gop ) {
			g_free(gop_key);

			/* is the gop dead ? */
			if ( ! gop->released &&
				 ( ( gop->cfg->lifetime > 0.0 && gop->time_to_die >= rd->now) ||
				   ( gop->cfg->idle_timeout > 0.0 && gop->time_to_timeout >= rd->now) ) ) {
				dbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: expiring released gop");
				gop->released = TRUE;

				if (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;
			}

			/* TODO: is the gop expired? */

			gop_key = orig_gop_key;

			dbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got gop: %s",gop_key);

			if (( candidate_start = cfg->start )) {

				dbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got candidate start");

				if (( is_start = new_avpl_pairs_match("", pdu->avpl, candidate_start, TRUE, FALSE) )) {
					delete_avpl(is_start,FALSE);
					if ( gop->released ) {
						dbg_print (dbg_gop,3,dbg_facility,"analyze_pdu: start on released gop, let's create a new gop");

						g_hash_table_remove(cfg->gop_index,gop_key);
						gop->gop_key = NULL;
						gop = new_gop(cfg,pdu,gop_key);
						g_hash_table_insert(cfg->gop_index,gop_key,gop);
					} else {
						dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: duplicate start on gop");
					}
				}
			}

			pdu->gop = gop;

			if (gop->last_pdu) gop->last_pdu->next = pdu;
			gop->last_pdu = pdu;
			pdu->next = NULL;
			pdu->time_in_gop = rd->now - gop->start_time;

			if (gop->released) pdu->after_release = TRUE;

		} else {

			dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: no gop already");

			if ( ! cfg->start ) {
				/* there is no GopStart, we'll check for matching GogKeys
				if we have one we'll create the Gop */

				apply_extras(pdu->avpl,gopkey_match,cfg->extra);

				gog_keys = (LoAL *)g_hash_table_lookup(mc->gogs_by_gopname,cfg->name);

				if (gog_keys) {

					while (( curr_gogkey = get_next_avpl(gog_keys,&cookie) )) {
						if (( gogkey_match = new_avpl_pairs_match(cfg->name, gopkey_match, curr_gogkey, TRUE, FALSE) )) {
							gogkey_str = avpl_to_str(gogkey_match);

							if (g_hash_table_lookup(cfg->gog_index,gogkey_str)) {
								gop = new_gop(cfg,pdu,gop_key);
								g_hash_table_insert(cfg->gop_index,gop_key,gop);
								delete_avpl(gogkey_match,FALSE);
								g_free(gogkey_str);
								break;
							} else {
								delete_avpl(gogkey_match,FALSE);
								g_free(gogkey_str);
							}
						}
					}

					if ( ! gop ) {
						g_free(gop_key);
						delete_avpl(gopkey_match,TRUE);
						return;
					}

				} else {
					g_free(gop_key);
					delete_avpl(gopkey_match,TRUE);
					return;
				}

			} else {
				candidate_start = cfg->start;

				if (( is_start = new_avpl_pairs_match("", pdu->avpl, candidate_start, TRUE, FALSE) )) {
					delete_avpl(is_start,FALSE);
					gop = new_gop(cfg,pdu,gop_key);
				} else {
					g_free(gop_key);
					return;
				}

				pdu->gop = gop;
			}
		}

		if (gop->last_pdu) gop->last_pdu->next = pdu;
		gop->last_pdu = pdu;
		pdu->next = NULL;

		pdu->time_in_gop = rd->now - gop->start_time;

		gop->num_of_pdus++;
		gop->time_to_timeout = cfg->idle_timeout > 0.0 ? cfg->idle_timeout + rd->now : (float) -1.0 ;

		dbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: merge with key");

		merge_avpl(gop->avpl,gopkey_match,TRUE);
		delete_avpl(gopkey_match,TRUE);

		dbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: apply extras");

		apply_extras(pdu->avpl,gop->avpl,gop->cfg->extra);

		gop->last_time = pdu->rel_time;

		if ( ! gop->released) {
			candidate_stop = cfg->stop;

			if (candidate_stop) {
				is_stop = new_avpl_pairs_match("", pdu->avpl, candidate_stop, TRUE, FALSE);
			} else {
				is_stop = new_avpl("");
			}

			if(is_stop) {
				dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: is a `stop");
				delete_avpl(is_stop,FALSE);

				if (! gop->released) {
					gop->released = TRUE;
					gop->release_time = pdu->rel_time;
					if (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;
				}

				pdu->is_stop = TRUE;

			}
		}

		if (gop->last_n != gop->avpl->len) apply_transforms(gop->cfg->transforms,gop->avpl);

		gop->last_n = gop->avpl->len;

		if (gop->gog) {
			reanalyze_gop(mc, gop);
		} else {
			analyze_gop(mc, gop);
		}

	} else {
		dbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: no match for this pdu");

		pdu->gop = NULL;
	}
}
```


Overlapping Code:
```
, mate_pdu* pdu) {
/* TODO:
return a g_boolean to tell we've destroyed the pdu when the pdu is unnassigned
destroy the unassigned pdu
*/
mate_cfg_gop* cfg = NULL;
mate_gop* gop = NULL;
gchar* gop_key;
gchar* orig_gop_key = NULL;
AVPL* candidate_start = NULL;
AVPL* candidate_stop = NULL;
AVPL* is_start = NULL;
AVPL* is_stop = NULL;
AVPL* gopkey_match = NULL;
LoAL* gog_keys = NULL;
AVPL* curr_gogkey = NULL;
void* cookie = NULL;
AVPL* gogkey_match = NULL;
gchar* gogkey_str = NULL;
dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: %s",pdu->cfg->name);
if (! (cfg = (mate_cfg_gop *)g_hash_table_lookup(mc->gops_by_pduname,pdu->cfg->name)) )
return;
if ((gopkey_match = new_avpl_pairs_match("gop_key_match", pdu->avpl, cfg->key, TRUE, TRUE))) {
gop_key = avpl_to_str(gopkey_match);
g_hash_table_lookup_extended(cfg->gop_index,(gconstpointer)gop_key,(gpointer *)&orig_gop_key,(gpointer *)&gop);
if ( gop ) {
g_free(gop_key);
/* is the gop dead ? */
if ( ! gop->released &&
( ( gop->cfg->lifetime > 0.0 && gop->time_to_die >= rd->now) ||
( gop->cfg->idle_timeout > 0.0 && gop->time_to_timeout >= rd->now) ) ) {
dbg_print (dbg_gop,4,dbg_facility,"analyze_pdu: expiring released gop");
gop->released = TRUE;
if (gop->gog && gop->cfg->start) gop->gog->num_of_released_gops++;
}
/* TODO: is the gop expired? */
gop_key = orig_gop_key;
dbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got gop: %s",gop_key);
if (( candidate_start = cfg->start )) {
dbg_print (dbg_gop,2,dbg_facility,"analyze_pdu: got candidate start");
if (( is_start = new_avpl_pairs_match("", pdu->avpl, candidate_start, TRUE, FALSE) )) {
delete_avpl(is_start,FALSE);
if ( gop->released ) {
dbg_print (dbg_gop,3,dbg_facility,"analyze_pdu: start on released gop, let's create a new gop");
g_hash_table_remove(cfg->gop_index,gop_key);
gop->gop_key = NULL;
gop = new_gop(cfg,pdu,gop_key);
g_hash_table_insert(cfg->gop_index,gop_key,gop);
} else {
dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: duplicate start on gop");
}
}
}
pdu->gop = gop;
if (gop->last_pdu) gop->last_pdu->next = pdu;
gop->last_pdu = pdu;
pdu->next = NULL;
pdu->time_in_gop = rd->now - gop->start_time;
if (gop->released) pdu->after_release = TRUE;
} else {
dbg_print (dbg_gop,1,dbg_facility,"analyze_pdu: no gop already");

```
<Overlap Ratio: 0.9761388286334056>

---

--- 167 --
Question ID: 7402a314f694052a5c54aae3ba803936daa06ec8_1
Original Code:
```
void boardInit(void) {

#if USE_MSP430_USART0
  P3SEL |= (1 << 4) | (1 << 5);
#endif

#if USE_MSP430_USART1
  P3SEL |= (1 << 6) | (1 << 7);
#endif

  /*
   * Timer 0 setup, uses SMCLK as source.
   */
  TACCR0 = SMCLK / 4 / CH_FREQUENCY - 1;/* Counter limit.               */
  TACTL = TACLR;                        /* Clean start.                 */
  TACTL = TASSEL_2 | ID_2 | MC_1;       /* Src=SMCLK, ID=4, cmp=TACCR0. */
  TACCTL0 = CCIE;                       /* Interrupt on compare.        */
}
```


Overlapping Code:
```
SP430_USART0
P3SEL |= (1 << 4) | (1 << 5);
#endif
#if USE_MSP430_USART1
P3SEL |= (1 << 6) | (1 << 7);
#endif
/*
* Timer 0 setup, uses SMCLK as source.
*/
TACCR0 = SMCLK / 4 / CH_FREQUENCY - 1;/* Counter limit. */
TACTL = TACLR; /* Clean start. */
TACTL = TASSEL_2 | ID_2 | MC_1; /* Src=SMCLK, ID=4, cmp=TACCR0. */
TACCTL0 = CCIE; /* Interrupt on comp
```
<Overlap Ratio: 0.8951406649616368>

---

--- 168 --
Question ID: 433eb0fe363f91ce5c0b50c03786b3d58af62d2b_17
Original Code:
```
static int nvgcolor_b_index_xl(lua_State *L)
{
    NVGcolor *self = R_CPPCAST(NVGcolor *, XL_checkutype(L, 1, "NVGcolor"));
    float RETVAL;
    RETVAL = self->b;
    XL_pushfloat(L, RETVAL);
    return 1;
}
```


Overlapping Code:
```
or_b_index_xl(lua_State *L)
{
NVGcolor *self = R_CPPCAST(NVGcolor *, XL_checkutype(L, 1, "NVGcolor"));
float RETVAL;
RETVAL = self->b;
XL_pushfloat(L,
```
<Overlap Ratio: 0.7978723404255319>

---

--- 169 --
Question ID: 606e798607482e516846828c471b96eba840b47a_27
Original Code:
```
int
_gnutls_server_select_cert(gnutls_session_t session,
			   gnutls_pk_algorithm_t * pk_algos,
			   size_t pk_algos_size)
{
	unsigned i, j;
	int idx, ret;
	gnutls_certificate_credentials_t cred;
	char server_name[MAX_CN];

	cred = (gnutls_certificate_credentials_t)
	    _gnutls_get_cred(session, GNUTLS_CRD_CERTIFICATE, NULL);
	if (cred == NULL) {
		gnutls_assert();
		return GNUTLS_E_INSUFFICIENT_CREDENTIALS;
	}

	/* If the callback which retrieves certificate has been set,
	 * use it and leave.
	 */
	if (cred->server_get_cert_callback || cred->get_cert_callback
	    || cred->get_cert_callback2) {
		ret = call_get_cert_callback(session, NULL, 0, NULL, 0);
		if (ret < 0)
			return gnutls_assert_val(ret);
		return ret;
	}

	/* Otherwise... */

	get_server_name(session, (unsigned char *) server_name,
			sizeof(server_name));

	idx = -1;		/* default is use no certificate */

	/* find certificates that match the requested server_name
	 */

	if (server_name[0] != 0) {
		for (i = 0; i < cred->ncerts; i++) {
			if (cred->certs[i].names != NULL
			    && _gnutls_str_array_match(cred->certs[i].
						       names,
						       server_name) != 0) {
				/* if requested algorithms are also compatible select it */
				gnutls_pk_algorithm pk =
				    gnutls_pubkey_get_pk_algorithm(cred->
								   certs
								   [i].
								   cert_list
								   [0].
								   pubkey,
								   NULL);

				_gnutls_handshake_log
				    ("HSK[%p]: Requested server name: '%s', ctype: %s (%d)",
				     session, server_name,
				     gnutls_certificate_type_get_name
				     (session->security_parameters.
				      cert_type),
				     session->security_parameters.
				     cert_type);

				if (session->security_parameters.
				    cert_type ==
				    cred->certs[i].cert_list[0].type) {
					for (j = 0; j < pk_algos_size; j++)
						if (pk_algos[j] == pk) {
							idx = i;
							goto finished;
						}
				}
			}
		}
	}

	for (j = 0; j < pk_algos_size; j++) {
		_gnutls_handshake_log
		    ("HSK[%p]: Requested PK algorithm: %s (%d) -- ctype: %s (%d)\n",
		     session, gnutls_pk_get_name(pk_algos[j]), pk_algos[j],
		     gnutls_certificate_type_get_name(session->
						      security_parameters.cert_type),
		     session->security_parameters.cert_type);

		for (i = 0; i < cred->ncerts; i++) {
			gnutls_pk_algorithm pk =
			    gnutls_pubkey_get_pk_algorithm(cred->certs[i].
							   cert_list[0].
							   pubkey,
							   NULL);
			/* find one compatible certificate
			 */
			_gnutls_handshake_log
			    ("HSK[%p]: certificate[%d] PK algorithm: %s (%d) - ctype: %s (%d)\n",
			     session, i, gnutls_pk_get_name(pk), pk,
			     gnutls_certificate_type_get_name(cred->
							      certs[i].
							      cert_list[0].
							      type),
			     cred->certs[i].cert_list[0].type);

			if (pk_algos[j] == pk) {
				/* if cert type matches
				 */
	  /* *INDENT-OFF* */
	  if (session->security_parameters.cert_type == cred->certs[i].cert_list[0].type)
	    {
	      idx = i;
	      goto finished;
	    }
	  /* *INDENT-ON* */
			}
		}
	}

	/* store the certificate pointer for future use, in the handshake.
	 * (This will allow not calling this callback again.)
	 */
      finished:
	if (idx >= 0) {
		_gnutls_selected_certs_set(session,
					   &cred->certs[idx].cert_list[0],
					   cred->certs[idx].
					   cert_list_length,
					   cred->pkey[idx], 0);
	} else {
		gnutls_assert();
		/* Certificate does not support REQUESTED_ALGO.  */
		return GNUTLS_E_INSUFFICIENT_CREDENTIALS;
	}

	return 0;
}
```


Overlapping Code:
```
elect_cert(gnutls_session_t session,
gnutls_pk_algorithm_t * pk_algos,
size_t pk_algos_size)
{
unsigned i, j;
int idx, ret;
gnutls_certificate_credentials_t cred;
char server_name[MAX_CN];
cred = (gnutls_certificate_credentials_t)
_gnutls_get_cred(session, GNUTLS_CRD_CERTIFICATE, NULL);
if (cred == NULL) {
gnutls_assert();
return GNUTLS_E_INSUFFICIENT_CREDENTIALS;
}
/* If the callback which retrieves certificate has been set,
* use it and leave.
*/
if (cred->server_get_cert_callback || cred->get_cert_callback
|| cred->get_cert_callback2) {
ret = call_get_cert_callback(session, NULL, 0, NULL, 0);
if (ret < 0)
return gnutls_assert_val(ret);
return ret;
}
/* Otherwise... */
get_server_name(session, (unsigned char *) server_name,
sizeof(server_name));
idx = -1; /* default is use no certificate */
/* find certificates that match the requested server_name
*/
if (server_name[0] != 0) {
for (i = 0; i < cred->ncerts; i++) {
if (cred->certs[i].names != NULL
&& _gnutls_str_array_match(cred->certs[i].
names,
server_name) != 0) {
/* if requested algorithms are also compatible select it */
gnutls_pk_algorithm pk =
gnutls_pubkey_get_pk_algorithm(cred->
certs
[i].
cert_list
[0].
pubkey,
NULL);
_gnutls_handshake_log
("HSK[%p]: Requested server name: '%s', ctype: %s (%d)",
session, server_name,
gnutls_certificate_type_get_name
(session->security_parameters.
cert_type),
session->security_parameters.
cert_type);
if (session->security_parameters.
cert_type ==
cred->certs[i].cert_list[0].type) {
for (j = 0; j < pk_algos_size; j++)
if (pk_algos[j] == pk) {
idx = i;
goto finished;
}
}
}
}
}
for (j = 0; j < pk_algos_size; j++) {
_gnutls_handshake_log
("HSK[%p]: Requested PK algorithm: %s (%d) -- ctype: %s (%d)\n",
session, gnutls_pk_get_name(pk_algos[j]), pk_algos[j],
gnutls_certificate_type_get_name(session->
security_parameters.cert_type),
session->security_parameters.cert_type);
for (i = 0; i < cred->ncerts; i++) {
gnutls_pk_algorithm pk =
gnutls_pubkey_get_pk_algorithm(cred->certs[i].
cert_list[0].
pubkey,
NULL);
/* find one compatible
```
<Overlap Ratio: 0.9832134292565947>

---

--- 170 --
Question ID: 835fd7175d4d02cac7f00248a8719677cfd853de_0
Original Code:
```
bool_t MidiInitializeCallbacks(midi_callbacks_t *callbacks) {
  if (callbacks == NULL) return false;
  memset(callbacks, 0, sizeof(midi_callbacks_t));
  callbacks->next_event_id = 1;
  callbacks->rx.next_rx_event_id = 1;
  callbacks->rx.next_sys_ex_rx_event_id = 1;
  callbacks->tx.next_tx_event_id = 1;
  return true;
}
```


Overlapping Code:
```
ool_t MidiInitializeCallbacks(midi_callbacks_t *callbacks) {
if (callbacks == NULL) return false;
memset(callbacks, 0, sizeof(midi_callbacks_t));
callbacks->next_event_id = 1;
callbacks->rx.next_rx_event_id = 1;
callbacks->rx.next_sys_ex_rx_event_id = 1;
callbacks->tx.next_tx_event_id = 1;
return tr
```
<Overlap Ratio: 0.9803921568627451>

---

--- 171 --
Question ID: 0be6a9ece117b200e2c43850300c41fe1a236867_20
Original Code:
```
DPIX *
dpixCopy(DPIX  *dpixd,   /* can be null */
         DPIX  *dpixs)
{
l_int32     w, h, bytes;
l_float64  *datas, *datad;

    PROCNAME("dpixCopy");

    if (!dpixs)
        return (DPIX *)ERROR_PTR("dpixs not defined", procName, NULL);
    if (dpixs == dpixd)
        return dpixd;

        /* Total bytes in image data */
    dpixGetDimensions(dpixs, &w, &h);
    bytes = 8 * w * h;

        /* If we're making a new dpix ... */
    if (!dpixd) {
        if ((dpixd = dpixCreateTemplate(dpixs)) == NULL)
            return (DPIX *)ERROR_PTR("dpixd not made", procName, NULL);
        datas = dpixGetData(dpixs);
        datad = dpixGetData(dpixd);
        memcpy((char *)datad, (char *)datas, bytes);
        return dpixd;
    }

        /* Reallocate image data if sizes are different */
    dpixResizeImageData(dpixd, dpixs);

        /* Copy data */
    dpixCopyResolution(dpixd, dpixs);
    datas = dpixGetData(dpixs);
    datad = dpixGetData(dpixd);
    memcpy((char*)datad, (char*)datas, bytes);
    return dpixd;
}
```


Overlapping Code:
```
an be null */
DPIX *dpixs)
{
l_int32 w, h, bytes;
l_float64 *datas, *datad;
PROCNAME("dpixCopy");
if (!dpixs)
return (DPIX *)ERROR_PTR("dpixs not defined", procName, NULL);
if (dpixs == dpixd)
return dpixd;
/* Total bytes in image data */
dpixGetDimensions(dpixs, &w, &h);
bytes = 8 * w * h;
/* If we're making a new dpix ... */
if (!dpixd) {
if ((dpixd = dpixCreateTemplate(dpixs)) == NULL)
return (DPIX *)ERROR_PTR("dpixd not made", procName, NULL);
datas = dpixGetData(dpixs);
datad = dpixGetData(dpixd);
memcpy((char *)datad, (char *)datas, bytes);
return dpixd;
}
/* Reallocate image data if sizes are different */
dpixResizeImageData(dpixd, dpixs);
/* Copy data */
dpixCopyResolution(dpixd, dpixs);
datas = dpixGetData(dpixs);
datad = dpixGetData(dpixd);
memcpy((char*)datad, (char*)datas, bytes);
retu
```
<Overlap Ratio: 0.9483568075117371>

---

--- 172 --
Question ID: 70cee756a0b2747d8f02d52c4c8ceca0bdb4ad10_0
Original Code:
```
void CWE369_Divide_by_Zero__int_fscanf_divide_68_bad()
{
    int data;
    /* Initialize data */
    data = -1;
    /* POTENTIAL FLAW: Read data from the console using fscanf() */
    fscanf(stdin, "%d", &data);
    CWE369_Divide_by_Zero__int_fscanf_divide_68_badData = data;
    CWE369_Divide_by_Zero__int_fscanf_divide_68b_badSink();
}
```


Overlapping Code:
```
ivide_68_bad()
{
int data;
/* Initialize data */
data = -1;
/* POTENTIAL FLAW: Read data from the console using fscanf() */
fscanf(stdin, "%d", &data);
CWE369_Divide_by_Zero__int_fscanf_divide_68_badData = data;
CWE369_Divide_by_Zero__int_fscanf_divi
```
<Overlap Ratio: 0.8090614886731392>

---

--- 173 --
Question ID: ed6731e844c44a158035858eafa2c3674aaa22c1_0
Original Code:
```
int ngram_version(unsigned long *version) {
	assert(version);
	unsigned long options = 0;
	options |= DEBUGGING << 0;
	*version = (options << 24) | NGRAM_VERSION;
	return NGRAM_VERSION == 0 ? -1 : 0;
}
```


Overlapping Code:
```
n) {
assert(version);
unsigned long options = 0;
options |= DEBUGGING << 0;
*version = (options << 24) | NGRAM_VERSION;
return NGRAM_VERSION == 0 ? -1
```
<Overlap Ratio: 0.7653061224489796>

---

--- 174 --
Question ID: 1b384311726897bff5ba3e1014a53a536eccc210_6
Original Code:
```
static int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)
{
	struct virtio_scsi *vscsi = shost_priv(sh);
	struct virtio_scsi_cmd *cmd;
	int ret;

	dev_dbg(&sc->device->sdev_gendev,
		"cmd %p CDB: %#02x\n", sc, sc->cmnd[0]);

	ret = SCSI_MLQUEUE_HOST_BUSY;
	cmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);
	if (!cmd)
		goto out;

	memset(cmd, 0, sizeof(*cmd));
	cmd->sc = sc;
	cmd->req.cmd = (struct virtio_scsi_cmd_req){
		.lun[0] = 1,
		.lun[1] = sc->device->id,
		.lun[2] = (sc->device->lun >> 8) | 0x40,
		.lun[3] = sc->device->lun & 0xff,
		.tag = (unsigned long)sc,
		.task_attr = VIRTIO_SCSI_S_SIMPLE,
		.prio = 0,
		.crn = 0,
	};

	BUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);
	memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);

	if (virtscsi_kick_cmd(vscsi, vscsi->req_vq, cmd,
			      sizeof cmd->req.cmd, sizeof cmd->resp.cmd,
			      GFP_ATOMIC) >= 0)
		ret = 0;

out:
	return ret;
}
```


Overlapping Code:
```
t virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)
{
struct virtio_scsi *vscsi = shost_priv(sh);
struct virtio_scsi_cmd *cmd;
int ret;
dev_dbg(&sc->device->sdev_gendev,
"cmd %p CDB: %#02x\n", sc, sc->cmnd[0]);
ret = SCSI_MLQUEUE_HOST_BUSY;
cmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);
if (!cmd)
goto out;
memset(cmd, 0, sizeof(*cmd));
cmd->sc = sc;
cmd->req.cmd = (struct virtio_scsi_cmd_req){
.lun[0] = 1,
.lun[1] = sc->device->id,
.lun[2] = (sc->device->lun >> 8) | 0x40,
.lun[3] = sc->device->lun & 0xff,
.tag = (unsigned long)sc,
.task_attr = VIRTIO_SCSI_S_SIMPLE,
.prio = 0,
.crn = 0,
};
BUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);
memcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);
if (virtscsi_kick_cmd(vscsi, vscsi->req_vq, cmd,
sizeof cmd->req.cmd, sizeof cmd->resp.cmd,
GFP_ATOMI
```
<Overlap Ratio: 0.947429906542056>

---

--- 175 --
Question ID: 88163fe024c005148eeec1a180d0617fd9ccad74_3
Original Code:
```
void led_writeDisplay(_ADAFRUIT_LED* ptr){
  i2c_start();
  send_i2c_byte(ptr->i2c_addr);
	send_i2c_byte(0x00); // Start at address 0
	uint8_t i;
  for (i=0; i<8; i++) {
    send_i2c_byte(ptr->displaybuffer[i] & 0xFF);
    send_i2c_byte(ptr->displaybuffer[i] >> 8);
  }
  reset_i2c_bus();
}
```


Overlapping Code:
```
* ptr){
i2c_start();
send_i2c_byte(ptr->i2c_addr);
send_i2c_byte(0x00); // Start at address 0
uint8_t i;
for (i=0; i<8; i++) {
send_i2c_byte(ptr->displaybuffer[i] & 0xFF);
send_i2c_byte(ptr->displaybu
```
<Overlap Ratio: 0.7407407407407407>

---

--- 176 --
Question ID: bd729b1f769b73a339bb3c5f92094e4ffb487a51_3
Original Code:
```
void
client_send_environ(void)
{
	struct msg_environ_data	data;
	char		      **var;

	for (var = environ; *var != NULL; var++) {
		if (strlcpy(data.var, *var, sizeof data.var) >= sizeof data.var)
			continue;
		client_write_server(MSG_ENVIRON, &data, sizeof data);
	}
}
```


Overlapping Code:
```
)
{
struct msg_environ_data data;
char **var;
for (var = environ; *var != NULL; var++) {
if (strlcpy(data.var, *var, sizeof data.var) >= sizeof data.var)
continue;
client_write_server(MSG_ENVIRON, &da
```
<Overlap Ratio: 0.8>

---

--- 177 --
Question ID: 26868d8ed1fe25af757fa7a8d009b7e4a914b726_4
Original Code:
```
void
ccsip_process_call_info_header (sipMessage_t *request_p, ccsipCCB_t *ccb)
{
    char       *call_info_hdrs[MAX_CALL_INFO_HEADERS];
    uint16_t    num_call_info_headers;
    int         i = 0;

    if (!ccb) {
        return;
    }

    if (ccb->in_call_info) {
        ccsip_free_call_info_header(ccb->in_call_info);
        ccb->in_call_info = NULL;
    }

    if (!request_p) {
        return;
    }

    memset(call_info_hdrs, 0, MAX_CALL_INFO_HEADERS * sizeof(char *));

    num_call_info_headers = sippmh_get_num_particular_headers(request_p,
                                                              SIP_HEADER_CALL_INFO,
                                                              SIP_HEADER_CALL_INFO,
                                                              call_info_hdrs,
                                                              MAX_CALL_INFO_HEADERS);
    
    if (num_call_info_headers > 0) {
        ccb->in_call_info = (cc_call_info_t *)
            cpr_calloc(1, sizeof(cc_call_info_t));
        if (ccb->in_call_info) {

            ccb->in_call_info->data.call_info_feat_data.feature_flag = 0;

            // Parse each Call-Info header
            for (i = 0; i < MAX_CALL_INFO_HEADERS; i++) {
                if (call_info_hdrs[i]) {                    
                    ccsip_decode_call_info_hdr(call_info_hdrs[i], ccb->in_call_info);
                }
            }
            
        } else {
            ccb->in_call_info = NULL;
        }
    }
    
}
```


Overlapping Code:
```
sipMessage_t *request_p, ccsipCCB_t *ccb)
{
char *call_info_hdrs[MAX_CALL_INFO_HEADERS];
uint16_t num_call_info_headers;
int i = 0;
if (!ccb) {
return;
}
if (ccb->in_call_info) {
ccsip_free_call_info_header(ccb->in_call_info);
ccb->in_call_info = NULL;
}
if (!request_p) {
return;
}
memset(call_info_hdrs, 0, MAX_CALL_INFO_HEADERS * sizeof(char *));
num_call_info_headers = sippmh_get_num_particular_headers(request_p,
SIP_HEADER_CALL_INFO,
SIP_HEADER_CALL_INFO,
call_info_hdrs,
MAX_CALL_INFO_HEADERS);

if (num_call_info_headers > 0) {
ccb->in_call_info = (cc_call_info_t *)
cpr_calloc(1, sizeof(cc_call_info_t));
if (ccb->in_call_info) {
ccb->in_call_info->data.call_info_feat_data.feature_flag = 0;
// Parse each Call-Info header
for (i = 0; i < MAX_CALL_INFO_HEADERS; i++) {
if (call_info_hdrs[i]) { 
ccsip_decode_call_info_hdr(call_info_hdrs[i], ccb->in_call_info);
}
}

} else {
ccb->in_call_in
```
<Overlap Ratio: 0.9433962264150944>

---

--- 178 --
Question ID: 82718bb33022a8c2ef28484e2f6d0dd2f522d593_11
Original Code:
```
bool ws_file_copy_step4(EV_P, void *cb_data, char *str_path) {
	SDEBUG("ws_file_copy_step4");
	struct sock_ev_client_request *client_request = cb_data;
	struct sock_ev_client_file *client_file = (struct sock_ev_client_file *)(client_request->vod_request_data);
	bool bol_ret = true;
	char *str_response = NULL;
	size_t int_response_len = 0;
	SDEFINE_VAR_ALL(str_new_path, str_new_path_to, str_result_path);
	if (*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) == '/') {
		*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) = '\0';
	}
	if (*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) == '/') {
		*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) = '\0';
	}
	size_t int_new_path_len = 0;
	size_t int_new_path_to_len = 0;
	if (*str_path == '/') {
		SFINISH_SNCAT(
			str_new_path, &int_new_path_len,
			client_file->str_partial_path, strlen(client_file->str_partial_path),
			str_path, strlen(str_path)
		);
		SFINISH_SNCAT(
			str_new_path_to, &int_new_path_to_len,
			client_file->str_partial_path_to, strlen(client_file->str_partial_path),
			str_path, strlen(str_path)
		);
	} else {
		SFINISH_SNCAT(
			str_new_path, &int_new_path_len,
			client_file->str_partial_path, strlen(client_file->str_partial_path),
			"/", (size_t)1,
			str_path, strlen(str_path)
		);
		SFINISH_SNCAT(
			str_new_path_to, &int_new_path_to_len,
			client_file->str_partial_path_to, strlen(client_file->str_partial_path),
			"/", (size_t)1,
			str_path, strlen(str_path)
		);
	}

	str_result_path = canonical(client_file->str_canonical_start, str_new_path, "read_file");
	if (str_result_path != NULL) {
		SFINISH_CHECK(
			canonical_copy(client_file->str_canonical_start, str_new_path, client_file->str_canonical_start_to, str_new_path_to),
			"canonical_copy failed");
		SFREE(str_result_path);
	} else {
		str_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, "read_dir");
		if (str_result_path == NULL) {
			str_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, "create_dir");
			SFINISH_CHECK(str_result_path != NULL, "canonical failed");
		}
	}
finish:
	if (bol_error_state) {
		bol_error_state = false;
		client_request->int_response_id = (ssize_t)DArray_end(client_request->arr_response) + 1;
		char str_temp[101] = {0};
		snprintf(str_temp, 100, "%zd", client_request->int_response_id);
		if (errno != 0) {
			SFREE(str_response);
			SFINISH_SNCAT(
				str_response, &int_response_len,
				"messageid = ", (size_t)12,
				client_request->str_message_id, strlen(client_request->str_message_id),
				"\012responsenumber = ", (size_t)18,
				str_temp, strlen(str_temp),
				"\012FATAL\012", (size_t)7,
				"Failed to delete file ", (size_t)18,
				client_file->str_path, strlen(client_file->str_path),
				": ", (size_t)2,
				strerror(errno), strlen(strerror(errno))
			);
		} else {
			char *_str_response = str_response;
			SFINISH_SNCAT(
				str_response, &int_response_len,
				"messageid = ", (size_t)12,
				client_request->str_message_id, strlen(client_request->str_message_id),
				"\012responsenumber = ", (size_t)18,
				str_temp, strlen(str_temp),
				"\012", (size_t)1,
				_str_response, strlen(_str_response)
			);
			SFREE(_str_response);
		}

		WS_sendFrame(EV_A, client_request->parent, true, 0x01, str_response, int_response_len);
		DArray_push(client_request->arr_response, str_response);

		// This is handled in step5
		// ws_file_free(client_file);

		// client_request_free(client_request);
		// client_request_free takes care of this
		// SFREE(client_file);
		bol_ret = false;
	}
	SFREE_ALL();
	return bol_ret;
}
```


Overlapping Code:
```
y_step4(EV_P, void *cb_data, char *str_path) {
SDEBUG("ws_file_copy_step4");
struct sock_ev_client_request *client_request = cb_data;
struct sock_ev_client_file *client_file = (struct sock_ev_client_file *)(client_request->vod_request_data);
bool bol_ret = true;
char *str_response = NULL;
size_t int_response_len = 0;
SDEFINE_VAR_ALL(str_new_path, str_new_path_to, str_result_path);
if (*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) == '/') {
*(client_file->str_partial_path + strlen(client_file->str_partial_path) - 1) = '\0';
}
if (*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) == '/') {
*(client_file->str_partial_path_to + strlen(client_file->str_partial_path_to) - 1) = '\0';
}
size_t int_new_path_len = 0;
size_t int_new_path_to_len = 0;
if (*str_path == '/') {
SFINISH_SNCAT(
str_new_path, &int_new_path_len,
client_file->str_partial_path, strlen(client_file->str_partial_path),
str_path, strlen(str_path)
);
SFINISH_SNCAT(
str_new_path_to, &int_new_path_to_len,
client_file->str_partial_path_to, strlen(client_file->str_partial_path),
str_path, strlen(str_path)
);
} else {
SFINISH_SNCAT(
str_new_path, &int_new_path_len,
client_file->str_partial_path, strlen(client_file->str_partial_path),
"/", (size_t)1,
str_path, strlen(str_path)
);
SFINISH_SNCAT(
str_new_path_to, &int_new_path_to_len,
client_file->str_partial_path_to, strlen(client_file->str_partial_path),
"/", (size_t)1,
str_path, strlen(str_path)
);
}
str_result_path = canonical(client_file->str_canonical_start, str_new_path, "read_file");
if (str_result_path != NULL) {
SFINISH_CHECK(
canonical_copy(client_file->str_canonical_start, str_new_path, client_file->str_canonical_start_to, str_new_path_to),
"canonical_copy failed");
SFREE(str_result_path);
} else {
str_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, "read_dir");
if (str_result_path == NULL) {
str_result_path = canonical(client_file->str_canonical_start_to, str_new_path_to, "create_dir");
SFINISH_CHECK(str_result_path != NULL, "canonical failed");
}
}
finish:
if (bol_error_state) {
bol_error_state = false;
client_request->int_response_id = (ssize_t)DArray_end(client_request->arr_response) + 1;
char str_temp[101] = {0};
snprintf(str_temp, 100, "%zd", client_request->int_response_id);
if (errno != 0) {
SFREE(str_response);
```
<Overlap Ratio: 0.9932773109243698>

---

--- 179 --
Question ID: d052ec556de1c6318f14a8426762d62c653c74a8_0
Original Code:
```
namespace edk {

struct FormatInfo {
  PixelFmt edk_fmt;
  cncodecPixelFormat cncodec_fmt;
  unsigned int plane_num;
  std::string fmt_str;
  bool supported;

  static const FormatInfo* GetFormatInfo(PixelFmt fmt);
  unsigned int GetPlaneSize(unsigned int pitch, unsigned int height, unsigned int plane) const;
};

cncodecType CodecTypeCast(CodecType type);
cncodecColorSpace ColorStdCast(ColorStd color_std);

}
```


Overlapping Code:
```
nfo {
PixelFmt edk_fmt;
cncodecPixelFormat cncodec_fmt;
unsigned int plane_num;
std::string fmt_str;
bool supported;
static const FormatInfo* GetFormatInfo(PixelFmt fmt);
unsigned int GetPlaneSize(unsigned int pitch, unsigned int height, unsigned int plane) const;
};
cncodecType CodecTypeCast(CodecType type);
cncodecColorSpace ColorStdCast(ColorStd
```
<Overlap Ratio: 0.8883248730964467>

---

--- 180 --
Question ID: 553d6803860fb5fdbcbc0abe87443fdf8d99feaa_48
Original Code:
```
gboolean dvb_reader_get_current_pmt_packets(DVBReader *reader, guint8 **buffer, gsize *length)
{
    FLOG("\n");
    g_return_val_if_fail(reader != NULL, FALSE);

    if (reader->pmt_packet_count == 0)
        return FALSE;

    if (buffer) {
        *buffer = g_malloc(reader->pmt_packet_count * TS_SIZE);
        memcpy(*buffer, reader->pmt_data, reader->pmt_packet_count * TS_SIZE);
    }
    if (length)
        *length = (gsize)(reader->pmt_packet_count * TS_SIZE);

    return TRUE;
}
```


Overlapping Code:
```
b_reader_get_current_pmt_packets(DVBReader *reader, guint8 **buffer, gsize *length)
{
FLOG("\n");
g_return_val_if_fail(reader != NULL, FALSE);
if (reader->pmt_packet_count == 0)
return FALSE;
if (buffer) {
*buffer = g_malloc(reader->pmt_packet_count * TS_SIZE);
memcpy(*buffer, reader->pmt_data, reader->pmt_packet_count * TS_SIZE);
}
if (length)
*length = (gsize)(reader->pmt_packet_count * TS_SIZE)
```
<Overlap Ratio: 0.936768149882904>

---

--- 181 --
Question ID: d096a5a633bf3ef308e895ca5b269fb1fa97e6c5_29
Original Code:
```
static void
reply_cb (GDBusConnection *connection,
          GAsyncResult    *res,
          gpointer         user_data)
{
  GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);
  GVariant *value;
  GError *error;

  error = NULL;
  value = g_dbus_connection_call_finish (connection,
                                         res,
                                         &error);
  if (error != NULL)
    {
      g_simple_async_result_set_from_error (simple,
                                            error);
      g_error_free (error);
    }
  else
    {
      g_simple_async_result_set_op_res_gpointer (simple,
                                                 value,
                                                 (GDestroyNotify) g_variant_unref);
    }

  /* no need to complete in idle since the method GDBusConnection already does */
  g_simple_async_result_complete (simple);
  g_object_unref (simple);
}
```


Overlapping Code:
```
 (GDBusConnection *connection,
GAsyncResult *res,
gpointer user_data)
{
GSimpleAsyncResult *simple = G_SIMPLE_ASYNC_RESULT (user_data);
GVariant *value;
GError *error;
error = NULL;
value = g_dbus_connection_call_finish (connection,
res,
&error);
if (error != NULL)
{
g_simple_async_result_set_from_error (simple,
error);
g_error_free (error);
}
else
{
g_simple_async_result_set_op_res_gpointer (simple,
value,
(GDestroyNotify) g_variant_unref);
}
/* no need to complete in idle since the method GDBusConnection already does */
g_simple_async_result_complete (simple);
g_object_unref (simple);
```
<Overlap Ratio: 0.9642276422764228>

---

--- 182 --
Question ID: 353832cbf0c59e54fd3655367b48d677dcc31d25_2
Original Code:
```
int do_valid_stuff()
{
   printf("The serial number is valid!\n");
   // do serial-restricted, valid stuff here.
   exit( 0 );
}
```


Overlapping Code:
```
intf("The serial number is valid!\n");
// do seria
```
<Overlap Ratio: 0.42016806722689076>

---

--- 183 --
Question ID: f45c8ec2ff22307c3b69a00f19604a60eb2a73a3_0
Original Code:
```
ZEPHIR_INIT_FUNCS(zim_event_event_method_entry) {
	PHP_ME(Zim_Event_Event, fire, arginfo_zim_event_event_fire, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Zim_Event_Event, listen, arginfo_zim_event_event_listen, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_ME(Zim_Event_Event, on, arginfo_zim_event_event_on, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
	PHP_FE_END
};
```


Overlapping Code:
```
_FUNCS(zim_event_event_method_entry) {
PHP_ME(Zim_Event_Event, fire, arginfo_zim_event_event_fire, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
PHP_ME(Zim_Event_Event, listen, arginfo_zim_event_event_listen, ZEND_ACC_PUBLIC|ZEND_ACC_STATIC)
PHP_ME(Zim_Event_Event, on, arginfo_zim_event_event_on, ZEND_ACC_PUBLIC
```
<Overlap Ratio: 0.8771929824561403>

---

--- 184 --
Question ID: a68b16a35cf02eb4ee240a3ead00bca09e5bc778_19
Original Code:
```
bool fdi_serial_wire_debug_read_data(
    fdi_serial_wire_t *serial_wire,
    uint32_t address,
    uint8_t *data,
    uint32_t length,
    fdi_serial_wire_debug_error_t *error
) {
    uint32_t offset = 0;
    while (length > 0) {
        uint32_t sublength = (tar_increment_bits + 1) - (address & tar_increment_bits);
        if (length < sublength) {
            sublength = length;
        }
        
        if (!fdi_serial_wire_debug_read_memory_transfer(serial_wire, address, data, sublength, error)) {
            return false;
        }
        
        address += sublength;
        data += sublength;
        length -= sublength;
        offset += sublength;
    }
    return true;
}
```


Overlapping Code:
```
ata(
fdi_serial_wire_t *serial_wire,
uint32_t address,
uint8_t *data,
uint32_t length,
fdi_serial_wire_debug_error_t *error
) {
uint32_t offset = 0;
while (length > 0) {
uint32_t sublength = (tar_increment_bits + 1) - (address & tar_increment_bits);
if (length < sublength) {
sublength = length;
}

if (!fdi_serial_wire_debug_read_memory_transfer(serial_wire, address, data, sublength, error)) {
return false;
}

address += sublength;
data += sublength;
length -= sublength;
offset += sublength;
}
return true;

```
<Overlap Ratio: 0.9376146788990826>

---

--- 185 --
Question ID: 07d4fb9c283439fa2b0ee9d68d806c373e2ae06c_11
Original Code:
```
static  void  NetUDP_TxPktValidate (NET_BUF_HDR       *p_buf_hdr,
                                    NET_UDP_PORT_NBR   src_port,
                                    NET_UDP_PORT_NBR   dest_port,
                                    NET_UDP_FLAGS      flags_udp,
                                    NET_ERR           *p_err)
{
    CPU_INT16U     ix;
    CPU_INT16U     len;
    NET_UDP_FLAGS  flag_mask;


                                                                /* -------------- VALIDATE NET BUF TYPE --------------- */
    switch (p_buf_hdr->Type) {
        case NET_BUF_TYPE_TX_LARGE:
        case NET_BUF_TYPE_TX_SMALL:
             break;


        case NET_BUF_TYPE_NONE:
        case NET_BUF_TYPE_BUF:
        case NET_BUF_TYPE_RX_LARGE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);
            *p_err = NET_BUF_ERR_INVALID_TYPE;
             return;
    }


                                                                /* ----------------- VALIDATE PROTOCOL ---------------- */
    switch (p_buf_hdr->ProtocolHdrType) {
        case NET_PROTOCOL_TYPE_APP:
        case NET_PROTOCOL_TYPE_SOCK:
        case NET_PROTOCOL_TYPE_UDP_V4:
        case NET_PROTOCOL_TYPE_UDP_V6:
             ix  = (CPU_INT16U)p_buf_hdr->DataIx;
             len = (CPU_INT16U)p_buf_hdr->DataLen;
             break;


        case NET_PROTOCOL_TYPE_NONE:
        default:
             NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidProtocolCtr);
            *p_err = NET_ERR_INVALID_PROTOCOL;
             return;
    }

    if (ix == NET_BUF_IX_NONE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);
       *p_err = NET_BUF_ERR_INVALID_IX;
        return;
    }

    if (ix <  NET_UDP_HDR_SIZE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);
       *p_err = NET_BUF_ERR_INVALID_IX;
        return;
    }



                                                                /* -------------- VALIDATE TOT DATA LEN --------------- */
    if (len != p_buf_hdr->TotLen) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrDataLenCtr);
       *p_err = NET_UDP_ERR_INVALID_LEN_DATA;
        return;
    }



                                                                /* ---------------- VALIDATE UDP PORTS ---------------- */
    if (src_port  == NET_UDP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortSrcCtr);
       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;
        return;
    }

    if (dest_port == NET_UDP_PORT_NBR_RESERVED) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortDestCtr);
       *p_err = NET_UDP_ERR_INVALID_PORT_NBR;
        return;
    }



                                                                /* ---------------- VALIDATE UDP FLAGS ---------------- */
    flag_mask = NET_UDP_FLAG_NONE           |
                NET_UDP_FLAG_TX_CHK_SUM_DIS |
                NET_UDP_FLAG_TX_BLOCK;                          /* See Note #2b1.                                       */
                                                                /* If any invalid flags req'd, rtn err (see Note #2a).  */
    if ((flags_udp & (NET_UDP_FLAGS)~flag_mask) != NET_UDP_FLAG_NONE) {
        NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrFlagsCtr);
       *p_err = NET_UDP_ERR_INVALID_FLAG;
        return;
    }


   *p_err = NET_UDP_ERR_NONE;
}
```


Overlapping Code:
```
ET_BUF_HDR *p_buf_hdr,
NET_UDP_PORT_NBR src_port,
NET_UDP_PORT_NBR dest_port,
NET_UDP_FLAGS flags_udp,
NET_ERR *p_err)
{
CPU_INT16U ix;
CPU_INT16U len;
NET_UDP_FLAGS flag_mask;
/* -------------- VALIDATE NET BUF TYPE --------------- */
switch (p_buf_hdr->Type) {
case NET_BUF_TYPE_TX_LARGE:
case NET_BUF_TYPE_TX_SMALL:
break;
case NET_BUF_TYPE_NONE:
case NET_BUF_TYPE_BUF:
case NET_BUF_TYPE_RX_LARGE:
default:
NET_CTR_ERR_INC(Net_ErrCtrs.Buf.InvTypeCtr);
*p_err = NET_BUF_ERR_INVALID_TYPE;
return;
}
/* ----------------- VALIDATE PROTOCOL ---------------- */
switch (p_buf_hdr->ProtocolHdrType) {
case NET_PROTOCOL_TYPE_APP:
case NET_PROTOCOL_TYPE_SOCK:
case NET_PROTOCOL_TYPE_UDP_V4:
case NET_PROTOCOL_TYPE_UDP_V6:
ix = (CPU_INT16U)p_buf_hdr->DataIx;
len = (CPU_INT16U)p_buf_hdr->DataLen;
break;
case NET_PROTOCOL_TYPE_NONE:
default:
NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidProtocolCtr);
*p_err = NET_ERR_INVALID_PROTOCOL;
return;
}
if (ix == NET_BUF_IX_NONE) {
NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);
*p_err = NET_BUF_ERR_INVALID_IX;
return;
}
if (ix < NET_UDP_HDR_SIZE) {
NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxInvalidBufIxCtr);
*p_err = NET_BUF_ERR_INVALID_IX;
return;
}
/* -------------- VALIDATE TOT DATA LEN --------------- */
if (len != p_buf_hdr->TotLen) {
NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrDataLenCtr);
*p_err = NET_UDP_ERR_INVALID_LEN_DATA;
return;
}
/* ---------------- VALIDATE UDP PORTS ---------------- */
if (src_port == NET_UDP_PORT_NBR_RESERVED) {
NET_CTR_ERR_INC(Net_ErrCtrs.UDP.TxHdrPortSrcCtr);
*p_err = NET_UDP_ERR_INVALID_PORT_NBR;
return;
}
if (dest_port == NET_UDP_P
```
<Overlap Ratio: 0.967391304347826>

---

--- 186 --
Question ID: 2c417fc23c9d02e8f87fc74f4a56acbc0759c65d_24
Original Code:
```
static void _HandlePID(int x, int y, int Pressed) {
  static int IsInHandlePID = 0;
  unsigned   ReleaseCapture;

  ReleaseCapture = 1;
  if (IsInHandlePID++ == 0) {
    _CalcBoardDimensions();
    x -= _BoardX0;
    y -= _BoardY0;
    if ((x >= 0) && (y >= 0)) {
      x /= _CellSize;
      y /= _CellSize;
      if ((x < 8) && (y < 8)) {
        if (_IsValidMove(&_Board, x, y)) {
          if (Pressed == 0) {
            _ReleaseCapture();
            _MakeMove(&_Board, x, y);
            _NextPlayer();
          } else {
            _SetCapture();
          }
          ReleaseCapture = 0;
        }   
      }
    }
    if (ReleaseCapture) {
      _ReleaseCapture();
    }
  }
  IsInHandlePID--;
}
```


Overlapping Code:
```
void _HandlePID(int x, int y, int Pressed) {
static int IsInHandlePID = 0;
unsigned ReleaseCapture;
ReleaseCapture = 1;
if (IsInHandlePID++ == 0) {
_CalcBoardDimensions();
x -= _BoardX0;
y -= _BoardY0;
if ((x >= 0) && (y >= 0)) {
x /= _CellSize;
y /= _CellSize;
if ((x < 8) && (y < 8)) {
if (_IsValidMove(&_Board, x, y)) {
if (Pressed == 0) {
_ReleaseCapture();
_MakeMove(&_Board, x, y);
_NextPlayer();
} else {
_SetCapture();
}
ReleaseCapture = 0;
} 
}
}
if (ReleaseCapture) {
_ReleaseCapture();
}
}
```
<Overlap Ratio: 0.9505703422053232>

---

--- 187 --
Question ID: ca3b010c95c61a0a5d68e14dba7c22c32bfacead_94
Original Code:
```
int sde_rotator_session_validate(struct sde_rot_mgr *mgr,
	struct sde_rot_file_private *private,
	struct sde_rotation_config *config)
{
	int ret;

	if (!mgr || !private || !config) {
		SDEROT_ERR("null parameters\n");
		return -EINVAL;
	}

	SDEROT_DBG(
		"validate session id=%u in{%u,%u}f:%x out{%u,%u}f:%x fps:%d\n",
		config->session_id, config->input.width, config->input.height,
		config->input.format, config->output.width,
		config->output.height, config->output.format,
		config->frame_rate);

	ret = sde_rotator_verify_config_all(mgr, config);
	if (ret) {
		SDEROT_WARN("rotator verify format failed %d\n", ret);
		return ret;
	}

	if (config->output.sbuf && mgr->sbuf_ctx != private && mgr->sbuf_ctx) {
		SDEROT_WARN("too many sbuf sessions\n");
		return -EBUSY;
	}

	return 0;
}
```


Overlapping Code:
```
int sde_rotator_session_validate(struct sde_rot_mgr *mgr,
struct sde_rot_file_private *private,
struct sde_rotation_config *config)
{
int ret;
if (!mgr || !private || !config) {
SDEROT_ERR("null parameters\n");
return -EINVAL;
}
SDEROT_DBG(
"validate session id=%u in{%u,%u}f:%x out{%u,%u}f:%x fps:%d\n",
config->session_id, config->input.width, config->input.height,
config->input.format, config->output.width,
config->output.height, config->output.format,
config->frame_rate);
ret = sde_rotator_verify_config_all(mgr, config);
if (ret) {
SDEROT_WARN("rotator verify format failed %d\n", ret);
return ret;
}
if (config->output.sbuf && mgr->sbuf_ctx != private && mgr->sbuf_ctx) {
SDEROT_WARN("too many sbuf sessions\n");
return -EBUSY;
}
return 0;
}
```
<Overlap Ratio: 1.0>

---

--- 188 --
Question ID: ca0bef59efc0d8550110692cfc5866b8368bf34e_29
Original Code:
```
int
rt2560_tx_data(struct rt2560_softc *sc, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rt2560_tx_ring *txq = &sc->txq;
	struct rt2560_tx_desc *desc;
	struct rt2560_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct mbuf *m1;
	uint16_t dur;
	uint32_t flags = 0;
	int pktlen, rate, needcts = 0, needrts = 0, error;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

	/* compute actual packet length (including CRC and crypto overhead) */
	pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	if (rate == 0)
		rate = 2;	/* XXX should not happen */
	rate &= IEEE80211_RATE_VAL;

	/*
	 * Packet Bursting: backoff after ppb=8 frames to give other STAs a
	 * chance to contend for the wireless medium.
	 */
	if (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))
		flags |= RT2560_TX_IFS_SIFS;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (pktlen > ic->ic_rtsthreshold) {
			needrts = 1;	/* RTS/CTS based on frame length */
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    RAL_RATE_IS_OFDM(rate)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				needcts = 1;	/* CTS-to-self */
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				needrts = 1;	/* RTS/CTS */
		}
	}
	if (needrts || needcts) {
		struct mbuf *mprot;
		int protrate, ackrate;

		protrate = 2;	/* XXX */
		ackrate  = rt2560_ack_rate(ic, rate);

		dur = rt2560_txtime(pktlen, rate, ic->ic_flags) +
		      rt2560_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +
		      2 * RAL_SIFS;
		if (needrts) {
			dur += rt2560_txtime(RAL_CTS_SIZE, rt2560_ack_rate(ic,
			    protrate), ic->ic_flags) + RAL_SIFS;
			mprot = ieee80211_get_rts(ic, wh, dur);
		} else {
			mprot = ieee80211_get_cts_to_self(ic, dur);
		}
		if (mprot == NULL) {
			printf("%s: could not allocate protection frame\n",
			    sc->sc_dev.dv_xname);
			m_freem(m0);
			return ENOBUFS;
		}

		desc = &txq->desc[txq->cur_encrypt];
		data = &txq->data[txq->cur_encrypt];

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, mprot,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(mprot);
			m_freem(m0);
			return error;
		}

		data->m = mprot;
		/* avoid multiple free() of the same node for each fragment */
		data->ni = ieee80211_ref_node(ni);

		/* XXX may want to pass the protection frame to BPF */

		rt2560_setup_tx_desc(sc, desc,
		    (needrts ? RT2560_TX_NEED_ACK : 0) | RT2560_TX_MORE_FRAG,
		    mprot->m_pkthdr.len, protrate, 1,
		    data->map->dm_segs->ds_addr);

		bus_dmamap_sync(sc->sc_dmat, data->map, 0,
		    data->map->dm_mapsize, BUS_DMASYNC_PREWRITE);
		bus_dmamap_sync(sc->sc_dmat, txq->map,
		    txq->cur_encrypt * RT2560_TX_DESC_SIZE,
		    RT2560_TX_DESC_SIZE, BUS_DMASYNC_PREWRITE);

		txq->queued++;
		if (++txq->cur_encrypt >= txq->count)
			txq->cur_encrypt = 0;

		flags |= RT2560_TX_LONG_RETRY | RT2560_TX_IFS_SIFS;
	}

	data = &txq->data[txq->cur_encrypt];
	desc = &txq->desc[txq->cur_encrypt];

	error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
	    BUS_DMA_NOWAIT);
	if (error != 0 && error != EFBIG) {
		printf("%s: can't map mbuf (error %d)\n",
		    sc->sc_dev.dv_xname, error);
		m_freem(m0);
		return error;
	}
	if (error != 0) {
		/* too many fragments, linearize */
		MGETHDR(m1, M_DONTWAIT, MT_DATA);
		if (m1 == NULL) {
			m_freem(m0);
			return ENOBUFS;
		}
		if (m0->m_pkthdr.len > MHLEN) {
			MCLGET(m1, M_DONTWAIT);
			if (!(m1->m_flags & M_EXT)) {
				m_freem(m0);
				m_freem(m1);
				return ENOBUFS;
			}
		}
		m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m1, caddr_t));
		m1->m_pkthdr.len = m1->m_len = m0->m_pkthdr.len;
		m_freem(m0);
		m0 = m1;

		error = bus_dmamap_load_mbuf(sc->sc_dmat, data->map, m0,
		    BUS_DMA_NOWAIT);
		if (error != 0) {
			printf("%s: can't map mbuf (error %d)\n",
			    sc->sc_dev.dv_xname, error);
			m_freem(m0);
			return error;
		}

		/* packet header have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rt2560_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	data->m = m0;
	data->ni = ni;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2560_TX_NEED_ACK;

		dur = rt2560_txtime(RAL_ACK_SIZE, rt2560_ack_rate(ic, rate),
		    ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}

	rt2560_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate, 1,
	    data->map->dm_segs->ds_addr);

	bus_dmamap_sync(sc->sc_dmat, data->map, 0, data->map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	bus_dmamap_sync(sc->sc_dmat, txq->map,
	    txq->cur_encrypt * RT2560_TX_DESC_SIZE, RT2560_TX_DESC_SIZE,
	    BUS_DMASYNC_PREWRITE);

	DPRINTFN(10, ("sending frame len=%u idx=%u rate=%u\n",
	    m0->m_pkthdr.len, txq->cur_encrypt, rate));

	/* kick encrypt */
	txq->queued++;
	if (++txq->cur_encrypt >= txq->count)
		txq->cur_encrypt = 0;
	RAL_WRITE(sc, RT2560_SECCSR1, RT2560_KICK_ENCRYPT);

	return 0;
}
```


Overlapping Code:
```
struct rt2560_softc *sc, struct mbuf *m0,
struct ieee80211_node *ni)
{
struct ieee80211com *ic = &sc->sc_ic;
struct rt2560_tx_ring *txq = &sc->txq;
struct rt2560_tx_desc *desc;
struct rt2560_tx_data *data;
struct ieee80211_frame *wh;
struct ieee80211_key *k;
struct mbuf *m1;
uint16_t dur;
uint32_t flags = 0;
int pktlen, rate, needcts = 0, needrts = 0, error;
wh = mtod(m0, struct ieee80211_frame *);
if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
k = ieee80211_get_txkey(ic, wh, ni);
if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
return ENOBUFS;
/* packet header may have moved, reset our local pointer */
wh = mtod(m0, struct ieee80211_frame *);
}
/* compute actual packet length (including CRC and crypto overhead) */
pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;
/* pickup a rate */
if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
IEEE80211_FC0_TYPE_MGT)) {
/* mgmt/multicast frames are sent at the lowest avail. rate */
rate = ni->ni_rates.rs_rates[0];
} else if (ic->ic_fixed_rate != -1) {
rate = ic->ic_sup_rates[ic->ic_curmode].
rs_rates[ic->ic_fixed_rate];
} else
rate = ni->ni_rates.rs_rates[ni->ni_txrate];
if (rate == 0)
rate = 2; /* XXX should not happen */
rate &= IEEE80211_RATE_VAL;
/*
* Packet Bursting: backoff after ppb=8 frames to give other STAs a
* chance to contend for the wireless medium.
*/
if (ic->ic_opmode == IEEE80211_M_STA && (ni->ni_txseq & 7))
flags |= RT2560_TX_IFS_SIFS;
/* check if RTS/CTS or CTS-to-self protection must be used */
if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
/* multicast frames are not sent at OFDM rates in 802.11b/g */
if (pktlen > ic->ic_rtsthreshold) {
needrts = 1; /* RTS/CTS based on frame length */
} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
RAL_RATE_IS_OFDM(rate)) {
if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
needcts = 1; /* CTS-to-self */
else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
needrts = 1; /* RTS/CTS */
}
}
if (needrts || needcts) {
struct mbuf *mprot;
int protrate, ackrate;
protrate = 2; /* XXX */
ackrate = rt2560_ack_rate(ic, rate);
dur = rt2560_txtime(pktlen, rate, ic->ic_flags) +
rt2560_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +
2 * RAL_SIFS;
if (needrts) {
dur += rt2560_txtime(RAL_CTS_SIZE, rt2560_ack_rate(ic,
protrate), ic->ic_flags) + RAL_SIFS;
mprot = ieee80211_g
```
<Overlap Ratio: 0.9884566053869175>

---

--- 189 --
Question ID: b35b57d86535d462fcab365db72e15bc95cd3108_15
Original Code:
```
static int
find_best_ufunc_inner_loop(PyUFuncObject *self,
                        PyArrayObject **op,
                        NPY_CASTING input_casting,
                        NPY_CASTING output_casting,
                        npy_intp buffersize,
                        int any_object,
                        PyArray_Descr **out_dtype,
                        PyUFuncGenericFunction *out_innerloop,
                        void **out_innerloopdata,
                        int *out_trivial_loop_ok)
{
    npy_intp i, j, nin = self->nin, niter = nin + self->nout;
    int types[NPY_MAXARGS];
    char *ufunc_name;
    int no_castable_output, all_inputs_scalar;

    /* For making a better error message on coercion error */
    char err_dst_typecode = '-', err_src_typecode = '-';

    ufunc_name = self->name ? self->name : "(unknown)";

    /* Check whether all the inputs are scalar */
    all_inputs_scalar = 1;
    for(i = 0; i < nin; ++i) {
        if (PyArray_NDIM(op[i]) > 0) {
            all_inputs_scalar = 0;
        }
    }

    /* If the ufunc has userloops, search for them. */
    if (self->userloops) {
        switch (find_ufunc_matching_userloop(self, op,
                                input_casting, output_casting,
                                buffersize, any_object, all_inputs_scalar,
                                out_dtype, out_innerloop, out_innerloopdata,
                                out_trivial_loop_ok,
                                &no_castable_output, &err_src_typecode,
                                &err_dst_typecode)) {
            /* Error */
            case -1:
                return -1;
            /* A loop was found */
            case 1:
                return 0;
        }
    }

    /*
     * Determine the UFunc loop.  This could in general be *much* faster,
     * and a better way to implement it might be for the ufunc to
     * provide a function which gives back the result type and inner
     * loop function.
     *
     * A default fast mechanism could be provided for functions which
     * follow the most typical pattern, when all functions have signatures
     * "xx...x -> x" for some built-in data type x, as follows.
     *  - Use PyArray_ResultType to get the output type
     *  - Look up the inner loop in a table based on the output type_num
     *
     * The method for finding the loop in the previous code did not
     * appear consistent (as noted by some asymmetry in the generated
     * coercion tables for np.add).
     */
    no_castable_output = 0;
    for (i = 0; i < self->ntypes; ++i) {
        char *orig_types = self->types + i*self->nargs;

        /* Copy the types into an int array for matching */
        for (j = 0; j < niter; ++j) {
            types[j] = orig_types[j];
        }

        NPY_UF_DBG_PRINT1("Trying function loop %d\n", (int)i);
        switch (ufunc_loop_matches(self, op,
                    input_casting, output_casting,
                    any_object, all_inputs_scalar,
                    types,
                    &no_castable_output, &err_src_typecode,
                    &err_dst_typecode)) {
            /* Error */
            case -1:
                return -1;
            /* Found a match */
            case 1:
                set_ufunc_loop_data_types(self, op, out_dtype, types,
                                    buffersize, out_trivial_loop_ok);

                /* Save the inner loop and its data */
                *out_innerloop = self->functions[i];
                *out_innerloopdata = self->data[i];

                NPY_UF_DBG_PRINT("Returning inner loop successfully\n");

                return 0;
        }

    }

    /* If no function was found, throw an error */
    NPY_UF_DBG_PRINT("No loop was found\n");
    if (no_castable_output) {
        PyErr_Format(PyExc_TypeError,
                "ufunc '%s' output (typecode '%c') could not be coerced to "
                "provided output parameter (typecode '%c') according "
                "to the casting rule '%s'",
                ufunc_name, err_src_typecode, err_dst_typecode,
                _casting_to_string(output_casting));
    }
    else {
        /*
         * TODO: We should try again if the casting rule is same_kind
         *       or unsafe, and look for a function more liberally.
         */
        PyErr_Format(PyExc_TypeError,
                "ufunc '%s' not supported for the input types, and the "
                "inputs could not be safely coerced to any supported "
                "types according to the casting rule '%s'",
                ufunc_name,
                _casting_to_string(input_casting));
    }

    return -1;
}
```


Overlapping Code:
```

find_best_ufunc_inner_loop(PyUFuncObject *self,
PyArrayObject **op,
NPY_CASTING input_casting,
NPY_CASTING output_casting,
npy_intp buffersize,
int any_object,
PyArray_Descr **out_dtype,
PyUFuncGenericFunction *out_innerloop,
void **out_innerloopdata,
int *out_trivial_loop_ok)
{
npy_intp i, j, nin = self->nin, niter = nin + self->nout;
int types[NPY_MAXARGS];
char *ufunc_name;
int no_castable_output, all_inputs_scalar;
/* For making a better error message on coercion error */
char err_dst_typecode = '-', err_src_typecode = '-';
ufunc_name = self->name ? self->name : "(unknown)";
/* Check whether all the inputs are scalar */
all_inputs_scalar = 1;
for(i = 0; i < nin; ++i) {
if (PyArray_NDIM(op[i]) > 0) {
all_inputs_scalar = 0;
}
}
/* If the ufunc has userloops, search for them. */
if (self->userloops) {
switch (find_ufunc_matching_userloop(self, op,
input_casting, output_casting,
buffersize, any_object, all_inputs_scalar,
out_dtype, out_innerloop, out_innerloopdata,
out_trivial_loop_ok,
&no_castable_output, &err_src_typecode,
&err_dst_typecode)) {
/* Error */
case -1:
return -1;
/* A loop was found */
case 1:
return 0;
}
}
/*
* Determine the UFunc loop. This could in general be *much* faster,
* and a better way to implement it might be for the ufunc to
* provide a function which gives back the result type and inner
* loop function.
*
* A default fast mechanism could be provided for functions which
* follow the most typical pattern, when all functions have signatures
* "xx...x -> x" for some built-in data type x, as follows.
* - Use PyArray_ResultType to get the output type
* - Look up the inner loop in a table based on the output type_num
*
* The method for finding the loop in the previous code did not
* appear consistent (as noted by some asymmetry in the generated
* c
```
<Overlap Ratio: 0.9846827133479212>

---

--- 190 --
Question ID: c2d628e9a4094db995344334367caffa54f08065_2
Original Code:
```
void
cpu_init(struct cpu_info *ci)
{
	/* configure the CPU if needed */
	if (ci->cpu_setup != NULL)
		(*ci->cpu_setup)(ci);

	/*
	 * We do this here after identifycpu() because errata may affect
	 * what we do.
	 */
	patinit(ci);
 
	/*
	 * Enable ring 0 write protection (486 or above, but 386
	 * no longer supported).
	 */
	lcr0(rcr0() | CR0_WP);

	if (cpu_feature & CPUID_PGE)
		lcr4(rcr4() | CR4_PGE);	/* enable global TLB caching */

#ifdef MULTIPROCESSOR
	ci->ci_flags |= CPUF_RUNNING;
	tlbflushg();
#endif

	/*
	 * If we have FXSAVE/FXRESTOR, use them.
	 */
	if (cpu_feature & CPUID_FXSR) {
		lcr4(rcr4() | CR4_OSFXSR);

		/*
		 * If we have SSE/SSE2, enable XMM exceptions.
		 */
		if (cpu_feature & (CPUID_SSE|CPUID_SSE2))
			lcr4(rcr4() | CR4_OSXMMEXCPT);
	}
}
```


Overlapping Code:
```
*ci)
{
/* configure the CPU if needed */
if (ci->cpu_setup != NULL)
(*ci->cpu_setup)(ci);
/*
* We do this here after identifycpu() because errata may affect
* what we do.
*/
patinit(ci);

/*
* Enable ring 0 write protection (486 or above, but 386
* no longer supported).
*/
lcr0(rcr0() | CR0_WP);
if (cpu_feature & CPUID_PGE)
lcr4(rcr4() | CR4_PGE); /* enable global TLB caching */
#ifdef MULTIPROCESSOR
ci->ci_flags |= CPUF_RUNNING;
tlbflushg();
#endif
/*
* If we have FXSAVE/FXRESTOR, use them.
*/
if (cpu_feature & CPUID_FXSR) {
lcr4(rcr4() | CR4_OSFXSR);
/*
* If we have SSE/SSE2, enable XMM exceptions.
*/
if (cpu_feature & (CPUID_SSE|CPUID_SSE2))
lcr4(rcr4() | CR4_
```
<Overlap Ratio: 0.9358437935843794>

---

--- 191 --
Question ID: 4baa91bfad50003be92af1d4d21931c0431a0e67_7
Original Code:
```
inline static  void SimMainP$Scheduler$init(void){
#line 46
  SimSchedulerBasicP$Scheduler$init();
#line 46
}
```


Overlapping Code:
```
oid SimMainP$Scheduler$init(void){
#line 46
SimSchedulerBasicP$Scheduler$init();
#
```
<Overlap Ratio: 0.7735849056603774>

---

--- 192 --
Question ID: ae183afad22e01dc270c365b1bd15a34251edf45_67
Original Code:
```
static void test_pack_MCI_SOUND_PARMSW(void)
{
    /* MCI_SOUND_PARMSW (pack 1) */
    TEST_TYPE_SIZE   (MCI_SOUND_PARMSW, 16)
    TEST_TYPE_ALIGN  (MCI_SOUND_PARMSW, 1)
    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, dwCallback, 8)
    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, dwCallback, 1)
    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, dwCallback, 0)
    TEST_FIELD_SIZE  (MCI_SOUND_PARMSW, lpstrSoundName, 8)
    TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, lpstrSoundName, 1)
    TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, lpstrSoundName, 8)
}
```


Overlapping Code:
```
 void test_pack_MCI_SOUND_PARMSW(void)
{
/* MCI_SOUND_PARMSW (pack 1) */
TEST_TYPE_SIZE (MCI_SOUND_PARMSW, 16)
TEST_TYPE_ALIGN (MCI_SOUND_PARMSW, 1)
TEST_FIELD_SIZE (MCI_SOUND_PARMSW, dwCallback, 8)
TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, dwCallback, 1)
TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, dwCallback, 0)
TEST_FIELD_SIZE (MCI_SOUND_PARMSW, lpstrSoundName, 8)
TEST_FIELD_ALIGN (MCI_SOUND_PARMSW, lpstrSoundName, 1)
TEST_FIELD_OFFSET(MCI_SOUND_PARMSW, lpst
```
<Overlap Ratio: 0.9533898305084746>

---

--- 193 --
Question ID: 18c7861b99ce2a814defa8f9e1dbe008e35e4438_76
Original Code:
```
U32  GH_HDMI_get_AUNIT_NCTS_CTRL(void)
{
    U32 value = (*(volatile U32 *)REG_HDMI_AUNIT_NCTS_CTRL);

    #if GH_HDMI_ENABLE_DEBUG_PRINT
    GH_HDMI_DEBUG_PRINT_FUNCTION( "value = RDREG(0x%08x); \\\\ [GH_HDMI_get_AUNIT_NCTS_CTRL] --> 0x%08x\n",
                        REG_HDMI_AUNIT_NCTS_CTRL,value);
    #endif
    return value;
}
```


Overlapping Code:
```
U32 GH_HDMI_get_AUNIT_NCTS_CTRL(void)
{
U32 value = (*(volatile U32 *)REG_HDMI_AUNIT_NCTS_CTRL);
#if GH_HDMI_ENABLE_DEBUG_PRINT
GH_HDMI_DEBUG_PRINT_FUNCTION( "value = RDREG(0x%08x); \\\\ [GH_HDMI_get_AUNIT_NCTS_CTRL] --> 0x%08x\n",
REG_HDMI_AUNIT_NCTS_CTRL,value);
#endif
retu
```
<Overlap Ratio: 0.9616724738675958>

---

--- 194 --
Question ID: 0b67a18e6bef9a7a056cf7196e7026d3bad949c9_0
Original Code:
```
static ssize_t
usdf_cq_readerr(struct fid_cq *fcq, struct fi_cq_err_entry *entry,
	        uint64_t flags)
{
	struct usdf_cq *cq;
	uint32_t api_version;

	USDF_TRACE_SYS(CQ, "\n");

	cq = container_of(fcq, struct usdf_cq, cq_fid);
	api_version = cq->cq_domain->dom_fabric->fab_attr.fabric->api_version;

	// The return values are analogous to sockets cq_readerr
	if (cq->cq_comp.uc_status == 0) {
		return -FI_EAGAIN;
	}

	entry->op_context = cq->cq_comp.uc_context;
	entry->flags = 0;
	switch (cq->cq_comp.uc_status) {
	case USD_COMPSTAT_SUCCESS:
		entry->prov_errno = FI_SUCCESS;
		break;
	case USD_COMPSTAT_ERROR_CRC:
		entry->prov_errno = FI_ECRC;
		break;
	case USD_COMPSTAT_ERROR_TRUNC:
		entry->prov_errno = FI_ETRUNC;
		break;
	case USD_COMPSTAT_ERROR_TIMEOUT:
		entry->prov_errno = FI_ETIMEDOUT;
		break;
	case USD_COMPSTAT_ERROR_INTERNAL:
	default:
		entry->prov_errno = FI_EOTHER;
		break;
	}
	entry->err = entry->prov_errno;

	cq->cq_comp.uc_status = 0;

	/* We don't have err_data to give back to the user. */
	if (FI_VERSION_GE(api_version, FI_VERSION(1, 5)))
		entry->err_data_size = 0;

	return 1;
}
```


Overlapping Code:
```
e_t
usdf_cq_readerr(struct fid_cq *fcq, struct fi_cq_err_entry *entry,
uint64_t flags)
{
struct usdf_cq *cq;
uint32_t api_version;
USDF_TRACE_SYS(CQ, "\n");
cq = container_of(fcq, struct usdf_cq, cq_fid);
api_version = cq->cq_domain->dom_fabric->fab_attr.fabric->api_version;
// The return values are analogous to sockets cq_readerr
if (cq->cq_comp.uc_status == 0) {
return -FI_EAGAIN;
}
entry->op_context = cq->cq_comp.uc_context;
entry->flags = 0;
switch (cq->cq_comp.uc_status) {
case USD_COMPSTAT_SUCCESS:
entry->prov_errno = FI_SUCCESS;
break;
case USD_COMPSTAT_ERROR_CRC:
entry->prov_errno = FI_ECRC;
break;
case USD_COMPSTAT_ERROR_TRUNC:
entry->prov_errno = FI_ETRUNC;
break;
case USD_COMPSTAT_ERROR_TIMEOUT:
entry->prov_errno = FI_ETIMEDOUT;
break;
case USD_COMPSTAT_ERROR_INTERNAL:
default:
entry->prov_errno = FI_EOTHER;
break;
}
entry->err = entry->prov_errno;
cq->cq_comp.uc_status = 0;
/* We don't have err_data to give back to the user. */
if (FI_VERSION_GE(api_version, FI_VERSION(1, 5)))
entry->err_data_size =
```
<Overlap Ratio: 0.9752851711026616>

---

--- 195 --
Question ID: 02700f9126e88f62b7a28b5f3f1d4479869dd80c_63
Original Code:
```
enum _ecore_status_t ecore_mcp_halt(struct ecore_hwfn *p_hwfn,
				    struct ecore_ptt *p_ptt)
{
	u32 resp = 0, param = 0, cpu_state, cnt = 0;
	enum _ecore_status_t rc;

	rc = ecore_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_MCP_HALT, 0, &resp,
			   &param);
	if (rc != ECORE_SUCCESS) {
		DP_ERR(p_hwfn, "MCP response failure, aborting\n");
		return rc;
	}

	do {
		OSAL_MSLEEP(ECORE_MCP_HALT_SLEEP_MS);
		cpu_state = ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_STATE);
		if (cpu_state & MCP_REG_CPU_STATE_SOFT_HALTED)
			break;
	} while (++cnt < ECORE_MCP_HALT_MAX_RETRIES);

	if (cnt == ECORE_MCP_HALT_MAX_RETRIES) {
		DP_NOTICE(p_hwfn, false,
			  "Failed to halt the MCP [CPU_MODE = 0x%08x, CPU_STATE = 0x%08x]\n",
			  ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_MODE), cpu_state);
		return ECORE_BUSY;
	}

	return ECORE_SUCCESS;
}
```


Overlapping Code:
```
_status_t ecore_mcp_halt(struct ecore_hwfn *p_hwfn,
struct ecore_ptt *p_ptt)
{
u32 resp = 0, param = 0, cpu_state, cnt = 0;
enum _ecore_status_t rc;
rc = ecore_mcp_cmd(p_hwfn, p_ptt, DRV_MSG_CODE_MCP_HALT, 0, &resp,
&param);
if (rc != ECORE_SUCCESS) {
DP_ERR(p_hwfn, "MCP response failure, aborting\n");
return rc;
}
do {
OSAL_MSLEEP(ECORE_MCP_HALT_SLEEP_MS);
cpu_state = ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_STATE);
if (cpu_state & MCP_REG_CPU_STATE_SOFT_HALTED)
break;
} while (++cnt < ECORE_MCP_HALT_MAX_RETRIES);
if (cnt == ECORE_MCP_HALT_MAX_RETRIES) {
DP_NOTICE(p_hwfn, false,
"Failed to halt the MCP [CPU_MODE = 0x%08x, CPU_STATE = 0x%08x]\n",
ecore_rd(p_hwfn, p_ptt, MCP_REG_CPU_MODE), cpu_state);
return ECORE_BUSY;
}
retu
```
<Overlap Ratio: 0.9605263157894737>

---

--- 196 --
Question ID: 7f5fff73d92c5d81135221c170cbf61a2bc05dba_35
Original Code:
```
bool transliteration_table_save(char *filename) {
    if (trans_table == NULL || filename == NULL) {
        return false;
    }

    FILE *f;

    if ((f = fopen(filename, "wb")) != NULL) {
        bool ret = transliteration_table_write(f);
        fclose(f);
        return ret;
    } else {
        return false;
    }

}
```


Overlapping Code:
```
lename) {
if (trans_table == NULL || filename == NULL) {
return false;
}
FILE *f;
if ((f = fopen(filename, "wb")) != NULL) {
bool ret = transliteration_table_write(f);
fclose(f);
return ret;
} else {

```
<Overlap Ratio: 0.7782101167315175>

---

--- 197 --
Question ID: 15ab61fd350fb903bfa34ef84f18b70d56ef131c_111
Original Code:
```
static int _cffi_const_SQLITE_FUNCTION(unsigned long long *o)
{
  int n = (SQLITE_FUNCTION) <= 0;
  *o = (unsigned long long)((SQLITE_FUNCTION) | 0);  /* check that SQLITE_FUNCTION is an integer */
  return n;
}
```


Overlapping Code:
```
UNCTION(unsigned long long *o)
{
int n = (SQLITE_FUNCTION) <= 0;
*o = (unsigned long long)((SQLITE_FUNCTION) | 0); /* check that SQLITE_FUNCTION is an
```
<Overlap Ratio: 0.7352941176470589>

---

--- 198 --
Question ID: 64122e3416f02540821ac7f7f582d714ee34a660_33
Original Code:
```
int
smb_ctx_readrc(struct smb_ctx *ctx)
{
	char pwbuf[NSS_BUFLEN_PASSWD];
	struct passwd pw;
	char *sname = NULL;
	int sname_max;
	int err = 0;

	/*
	 * If the user name is not specified some other way,
	 * use the current user name.  Also save the homedir.
	 * NB: ct_home=NULL is allowed, and we don't want to
	 * bail out with an error for a missing ct_home.
	 */
	if (getpwuid_r(getuid(), &pw, pwbuf, sizeof (pwbuf)) != NULL) {
		if (ctx->ct_user[0] == 0)
			(void) smb_ctx_setuser(ctx, pw.pw_name, B_FALSE);
		if (ctx->ct_home == NULL)
			ctx->ct_home = strdup(pw.pw_dir);
	}

	if ((err = smb_open_rcfile(ctx->ct_home)) != 0) {
		DPRINT("smb_open_rcfile, err=%d", err);
		/* ignore any error here */
		return (0);
	}

	sname_max = 3 * SMBIOC_MAX_NAME + 4;
	sname = malloc(sname_max);
	if (sname == NULL) {
		err = ENOMEM;
		goto done;
	}

	/*
	 * default parameters (level=0)
	 */
	smb_ctx_readrcsection(ctx, "default", 0);
	nb_ctx_readrcsection(smb_rc, ctx->ct_nb, "default", 0);

	/*
	 * If we don't have a server name, we can't read any of the
	 * [server...] sections.
	 */
	if (ctx->ct_fullserver == NULL)
		goto done;
	/*
	 * SERVER parameters.
	 */
	smb_ctx_readrcsection(ctx, ctx->ct_fullserver, 1);

	/*
	 * If we don't have a user name, we can't read any of the
	 * [server:user...] sections.
	 */
	if (ctx->ct_user[0] == 0)
		goto done;
	/*
	 * SERVER:USER parameters
	 */
	snprintf(sname, sname_max, "%s:%s",
	    ctx->ct_fullserver,
	    ctx->ct_user);
	smb_ctx_readrcsection(ctx, sname, 2);


	/*
	 * If we don't have a share name, we can't read any of the
	 * [server:user:share] sections.
	 */
	if (ctx->ct_origshare == NULL)
		goto done;
	/*
	 * SERVER:USER:SHARE parameters
	 */
	snprintf(sname, sname_max, "%s:%s:%s",
	    ctx->ct_fullserver,
	    ctx->ct_user,
	    ctx->ct_origshare);
	smb_ctx_readrcsection(ctx, sname, 3);

done:
	if (sname)
		free(sname);
	smb_close_rcfile();
	if (smb_debug)
		dump_ctx("after smb_ctx_readrc", ctx);
	if (err)
		DPRINT("err=%d\n", err);

	return (err);
}
```


Overlapping Code:
```
buf[NSS_BUFLEN_PASSWD];
struct passwd pw;
char *sname = NULL;
int sname_max;
int err = 0;
/*
* If the user name is not specified some other way,
* use the current user name. Also save the homedir.
* NB: ct_home=NULL is allowed, and we don't want to
* bail out with an error for a missing ct_home.
*/
if (getpwuid_r(getuid(), &pw, pwbuf, sizeof (pwbuf)) != NULL) {
if (ctx->ct_user[0] == 0)
(void) smb_ctx_setuser(ctx, pw.pw_name, B_FALSE);
if (ctx->ct_home == NULL)
ctx->ct_home = strdup(pw.pw_dir);
}
if ((err = smb_open_rcfile(ctx->ct_home)) != 0) {
DPRINT("smb_open_rcfile, err=%d", err);
/* ignore any error here */
return (0);
}
sname_max = 3 * SMBIOC_MAX_NAME + 4;
sname = malloc(sname_max);
if (sname == NULL) {
err = ENOMEM;
goto done;
}
/*
* default parameters (level=0)
*/
smb_ctx_readrcsection(ctx, "default", 0);
nb_ctx_readrcsection(smb_rc, ctx->ct_nb, "default", 0);
/*
* If we don't have a server name, we can't read any of the
* [server...] sections.
*/
if (ctx->ct_fullserver == NULL)
goto done;
/*
* SERVER parameters.
*/
smb_ctx_readrcsection(ctx, ctx->ct_fullserver, 1);
/*
* If we don't have a user name, we can't read any of the
* [server:user...] sections.
*/
if (ctx->ct_user[0] == 0)
goto done;
/*
* SERVER:USER parameters
*/
snprintf(sname, sname_max, "%s:%s",
ctx->ct_fullserver,
ctx->ct_user);
smb_ctx_readrcsection(ctx, sname, 2);
/*
* If we don't have a share name, we can't read any of the
* [server:user:share] sections.
*/
if (ctx->ct_origshare == NULL)
goto done;
/*
* SERVER:USER:SHARE parameters
*/
snprintf(sname, sname_max, "%s:%s:%s",
ctx->ct_fullserver,
ctx->ct_user,
ctx->ct_origshare);
smb_ctx_readrcsection(ctx, sname, 3);
done:
if (sname)
free(sname);
smb_close_rcfile();
if (smb_debug)
dump_ctx("after smb_ctx_readrc", ctx);
if (err)
DPRINT("err=%d\n", er
```
<Overlap Ratio: 0.9635974304068522>

---

--- 199 --
Question ID: a70b20a77f88e8054c469268472b75a76335cf80_0
Original Code:
```
interface TLTimelineSessionOperation : NSOperation {

	id<TLTimelineDataSourceProvider> _provider;
	NSArray* _operations;
	double _providerTimeout;
	double _operationTimeout;
	/*^block*/id _sessionCompletionBlock;
	NSOperationQueue* _operationQueue;
	NSError* _sessionError;

}
```


Overlapping Code:
```
face TLTimelineSessionOperation : NSOperation {
id<TLTimelineDataSourceProvider> _provider;
NSArray* _operations;
double _providerTimeout;
double _operationTimeout;
/*^block*/id _sessionCompletionBlock;
NSOperationQueue* _operationQueue;
NSError* _se
```
<Overlap Ratio: 0.9328358208955224>

---

--- 200 --
Question ID: 139ee5b227db92fe081f4338bd04a690fb7c8b81_0
Original Code:
```
int _net_release_client_context(net_client_cont_t *client) {
  memset(&client->server_addr, 0, sizeof(client->server_addr));

  /* TODO(valery): Implement safe free function */
  free(client);

  return NET_OK;
}
```


Overlapping Code:
```
ent_context(net_client_cont_t *client) {
memset(&client->server_addr, 0, sizeof(client->server_addr));
/* TODO(valery): Implement safe free function *
```
<Overlap Ratio: 0.7425742574257426>

---

--- 201 --
Question ID: 9f6320a228cb740f3f352ccd1590f12489da5b11_129
Original Code:
```
void glshim_glTexEnvi(GLenum target, GLenum pname, GLint param) {
    LOAD_GLES(glTexEnvi);
#ifndef direct_glTexEnvi
    PUSH_IF_COMPILING(glTexEnvi)
#endif
    gles_glTexEnvi(target, pname, param);
}
```


Overlapping Code:
```
_glTexEnvi(GLenum target, GLenum pname, GLint param) {
LOAD_GLES(glTexEnvi);
#ifndef direct_glTexEnvi
PUSH_IF_COMPILING(glTexEnvi)
#endif
gles_glTexEnvi(target, pn
```
<Overlap Ratio: 0.8670212765957447>

---

--- 202 --
Question ID: 2daaad6e91ef2a92c7711d68cfef8c2f6967e0b0_1
Original Code:
```
static int
copy_devinfo(const char *path, const char *connection, uint_t flags,
    hp_node_t *rootp)
{
	hp_node_t	hp_root = NULL;
	di_node_t	di_root;
	int		rv;

	/* Get libdevinfo snapshot */
	if ((di_root = di_init(path, DINFOSUBTREE | DINFOHP)) == DI_NODE_NIL)
		return (errno);

	/* Do initial search pass, if required */
	if (strcmp(path, "/") == 0) {
		flags |= HPINFOSEARCH;
		(void) di_walk_node(di_root, DI_WALK_CLDFIRST, NULL, search_cb);
	}

	/*
	 * If a connection is specified, just copy immediate hotplug info.
	 * Else, copy the device tree normally.
	 */
	if (connection != NULL)
		rv = copy_hotplug(NULL, di_root, connection, flags, &hp_root);
	else
		rv = copy_devices(NULL, di_root, flags, &hp_root);

	/* Destroy devinfo snapshot */
	di_fini(di_root);

	*rootp = (rv == 0) ? hp_root : NULL;
	return (rv);
}
```


Overlapping Code:
```
r *path, const char *connection, uint_t flags,
hp_node_t *rootp)
{
hp_node_t hp_root = NULL;
di_node_t di_root;
int rv;
/* Get libdevinfo snapshot */
if ((di_root = di_init(path, DINFOSUBTREE | DINFOHP)) == DI_NODE_NIL)
return (errno);
/* Do initial search pass, if required */
if (strcmp(path, "/") == 0) {
flags |= HPINFOSEARCH;
(void) di_walk_node(di_root, DI_WALK_CLDFIRST, NULL, search_cb);
}
/*
* If a connection is specified, just copy immediate hotplug info.
* Else, copy the device tree normally.
*/
if (connection != NULL)
rv = copy_hotplug(NULL, di_root, connection, flags, &hp_root);
else
rv = copy_devices(NULL, di_root, flags, &hp_root);
/* Destroy devinfo snapshot */
di_fini(di_root);
*rootp = (r
```
<Overlap Ratio: 0.9070063694267516>

---

--- 203 --
Question ID: 03d9791b678332d11c108dadafa46306fde45b1f_4
Original Code:
```
int proc_comm(pid_t pid, char **name)
{
	int r;
	char *p;

	assert(pid >= 1);
	assert(name);

	if (asprintf(&p, "/proc/%u/comm", pid) < 0)
		return -ENOMEM;

	r = read_one_line_file(p, name);
	free(p);

	if (r < 0)
		return r;

	return 0;
}
```


Overlapping Code:
```
_t pid, char **name)
{
int r;
char *p;
assert(pid >= 1);
assert(name);
if (asprintf(&p, "/proc/%u/comm", pid) < 0)
return -ENOMEM;
r = read_one_line_file(p, name);
free(p);
if (r < 0)
return r;
return
```
<Overlap Ratio: 0.9009009009009009>

---

--- 204 --
Question ID: c04bf3627e694b5ac32712705e98beb67c612181_49
Original Code:
```
static Iter *
_copyIter(Iter *from)
{
    Iter *newnode = makeNode(Iter);

    Node_Copy(from, newnode, iterexpr);
    newnode->itertype = from->itertype;
    
    return newnode;
}
```


Overlapping Code:
```
Iter(Iter *from)
{
Iter *newnode = makeNode(Iter);
Node_Copy(from, newnode, iterexpr);
newnode->itertype = from->itertype;

```
<Overlap Ratio: 0.76875>

---

--- 205 --
Question ID: ca0cb2647eab8d12c149994b57d68d323f7f92c6_8
Original Code:
```
int
_ReadChunkArray(int st[],
		int endp[],
		int bsize,
		int fp,
		char *destfp,
		ArrayType *array,
		int isDestLO,
		bool *isNull)
{
    int i,j,jj;
    int n, temp, words_read;
    int chunk_span[MAXDIM], chunk_off[MAXDIM]; 
    int chunk_st[MAXDIM], chunk_end[MAXDIM];
    int block_seek;
    
    int  bptr, *C, csize, *dim, *lb;
    int range_st[MAXDIM], range_end[MAXDIM], 
    range[MAXDIM], array_span[MAXDIM];
    int PA[MAXDIM], PCHUNK[MAXDIM], PC[MAXDIM];
    int  to_read;
    int cdist[MAXDIM], adist[MAXDIM]; 
    int dist[MAXDIM], temp_seek;
    
    int srcOff;        /* Needed since LO don't understand SEEK_CUR*/
    char *baseDestFp = (char *)destfp;
    
    CHUNK_INFO *A = (CHUNK_INFO *) ARR_DATA_PTR(array);
    n = ARR_NDIM(array); 
    dim = ARR_DIMS(array);
    lb = ARR_LBOUND(array); 
    C = A->C;
    
    csize = C[n-1];
    PC[n-1] = 1;
    temp = dim[n - 1]/C[n-1];
    for (i = n-2; i >= 0; i--){
        PC[i] = PC[i+1] * temp;
        temp = dim[i] / C[i];
        csize *= C[i];
    }
    
    for (i = 0; i < n; st[i] -= lb[i], endp[i] -= lb[i], i++)
	;
    mda_get_prod(n, C, PCHUNK);
    mda_get_range(n, array_span, st, endp);
    mda_get_prod(n, array_span, PA);
    
    array2chunk_coord(n, C, st, chunk_st);
    array2chunk_coord(n, C, endp, chunk_end);
    mda_get_range(n, chunk_span, chunk_st, chunk_end);
    mda_get_offset_values(n, dist, PC, chunk_span);
    
    for (i = 0; i < n; i++) {
        range_st[i] = st[i];
        range_end[i] = min(chunk_st[i]*C[i]+C[i]-1, endp[i]);
    }
    
    for (i = j = 0; i < n; i++)
        j+= chunk_st[i]*PC[i];
    temp_seek = srcOff = j * csize * bsize;
    if (lo_lseek(fp, srcOff, SEEK_SET) < 0) RETURN_NULL;
    
    jj = n-1;
    for (i = 0; i < n; chunk_off[i++] = 0)
	;
    words_read = 0; temp_seek = 0;
    do {
        /* Write chunk (chunk_st) to output buffer */
        mda_get_range(n, array_span,  range_st, range_end);
        mda_get_offset_values(n, adist, PA, array_span);
        mda_get_offset_values(n, cdist, PCHUNK, array_span);
        for (i=0; i < n; range[i] = range_st[i]-st[i], i++);
        bptr = tuple2linear(n, range, PA);
        for (i = 0; i < n; range[i++] = 0);
        j = n-1; bptr *= bsize;
        if (isDestLO) { 
            if (lo_lseek(destfp, bptr, SEEK_SET) < 0)
		RETURN_NULL;
        }
        else 
            destfp = baseDestFp + bptr; 
        for(i = 0, block_seek = 0; i < n; i++)
            block_seek += (range_st[i]-(chunk_st[i] + chunk_off[i])
			   *C[i])*PCHUNK[i];
        if (dist[jj] + block_seek + temp_seek) {
            temp = (dist[jj]*csize+block_seek+temp_seek)*bsize;
            srcOff += temp;
            if (lo_lseek(fp, srcOff, SEEK_SET) < 0)
		RETURN_NULL;
        }
        for (i = n-1, to_read = bsize; i >= 0; 
	     to_read *= min(C[i], array_span[i]), i--)
            if (cdist[i] || adist[i])
		break;
        do {
            if (cdist[j]) {
                srcOff += (cdist[j]*bsize);
                if (lo_lseek(fp, srcOff, SEEK_SET) < 0)
		    RETURN_NULL;
            }
            block_seek += cdist[j];
            bptr += adist[j]*bsize;
            if (isDestLO) { 
                if (lo_lseek(destfp, bptr, SEEK_SET) < 0)
		    RETURN_NULL;
            }
            else 
                destfp = baseDestFp + bptr;
            temp = _LOtransfer ((char**)&destfp, to_read, 1, (char**)&fp, 1, isDestLO);
            if (temp < to_read)
		RETURN_NULL;
            srcOff += to_read;
            words_read+=to_read;
            bptr += to_read;
            block_seek += (to_read/bsize);
            /* 
             * compute next tuple in range[]
             */
            {
                int x;
                if (!(i+1)) 
                    j = -1;
                else {
                    range[i] = (range[i]+1)%array_span[i];
                    for (x = i; x*(!range[x]); x--) 
                        range[x-1] = (range[x-1]+1)%array_span[x-1];
                    if (x) 
                        j = x; 
                    else { 
                        if (range[0]) 
                            j = 0; 
                        else 
                            j = -1;
                    }
                }
            }
	    /* 
	     * end of compute next tuple -- 
	     * j is set to -1 if tuple generation is over
	     */
        } while (j != -1);    
	
	block_seek = csize - block_seek;    
        temp_seek = block_seek;
        jj = next_tuple(n, chunk_off, chunk_span);
        if (jj == -1)
	    break;
        range_st[jj] = (chunk_st[jj]+chunk_off[jj])*C[jj];
        range_end[jj] = min(range_st[jj] + C[jj]-1, endp[jj]);
        
        for (i = jj+1; i < n; i++) {
	    range_st[i] = st[i];
	    range_end[i] = min((chunk_st[i]+chunk_off[i])*C[i]+C[i]-1, endp[i]);
        }
    } while (jj != -1);
    return(words_read);
}
```


Overlapping Code:
```
st[],
int endp[],
int bsize,
int fp,
char *destfp,
ArrayType *array,
int isDestLO,
bool *isNull)
{
int i,j,jj;
int n, temp, words_read;
int chunk_span[MAXDIM], chunk_off[MAXDIM]; 
int chunk_st[MAXDIM], chunk_end[MAXDIM];
int block_seek;

int bptr, *C, csize, *dim, *lb;
int range_st[MAXDIM], range_end[MAXDIM], 
range[MAXDIM], array_span[MAXDIM];
int PA[MAXDIM], PCHUNK[MAXDIM], PC[MAXDIM];
int to_read;
int cdist[MAXDIM], adist[MAXDIM]; 
int dist[MAXDIM], temp_seek;

int srcOff; /* Needed since LO don't understand SEEK_CUR*/
char *baseDestFp = (char *)destfp;

CHUNK_INFO *A = (CHUNK_INFO *) ARR_DATA_PTR(array);
n = ARR_NDIM(array); 
dim = ARR_DIMS(array);
lb = ARR_LBOUND(array); 
C = A->C;

csize = C[n-1];
PC[n-1] = 1;
temp = dim[n - 1]/C[n-1];
for (i = n-2; i >= 0; i--){
PC[i] = PC[i+1] * temp;
temp = dim[i] / C[i];
csize *= C[i];
}

for (i = 0; i < n; st[i] -= lb[i], endp[i] -= lb[i], i++)
;
mda_get_prod(n, C, PCHUNK);
mda_get_range(n, array_span, st, endp);
mda_get_prod(n, array_span, PA);

array2chunk_coord(n, C, st, chunk_st);
array2chunk_coord(n, C, endp, chunk_end);
mda_get_range(n, chunk_span, chunk_st, chunk_end);
mda_get_offset_values(n, dist, PC, chunk_span);

for (i = 0; i < n; i++) {
range_st[i] = st[i];
range_end[i] = min(chunk_st[i]*C[i]+C[i]-1, endp[i]);
}

for (i = j = 0; i < n; i++)
j+= chunk_st[i]*PC[i];
temp_seek = srcOff = j * csize * bsize;
if (lo_lseek(fp, srcOff, SEEK_SET) < 0) RETURN_NULL;

jj = n-1;
for (i = 0; i < n; chunk_off[i++] = 0)
;
words_read = 0; temp_seek = 0;
do {
/* Write chunk (chunk_st) to output buffer */
mda_get_range(n, array_span, range_st, range_end);
mda_get_offset_values(n, adist, PA, array_span);
mda_get_offset_values(n, cdist, PCHUNK, array_span);
for (i=0; i < n; range[i] = range_st[i]-st[i], i++);
bptr = tuple2linear(n, range, PA);
for (i = 0; i < n; range[i++] = 0);
j = n-1; bptr *= bsize;
if (isDestLO) { 
if (lo_lseek(destfp, bptr, SEEK_SET) < 0)
RETURN_NULL;
}
else 
destfp = baseDestFp + bptr; 
for(i = 0, block_seek = 0; i < n; i++)
block_seek += (range_st[i]-(chun
```
<Overlap Ratio: 0.9803921568627451>

---

--- 206 --
Question ID: a5f67cec5bd6d3a03b125c19138c9fae9824ea25_1
Original Code:
```
int func_3(int iParam0, int iParam1, int iParam2, int iParam3, int iParam4, int iParam5, int iParam6, int iParam7, int iParam8, int iParam9, int iParam10, int iParam11)
{
	struct<15> Var0;
	int iVar1;
	
	if (func_7(0))
	{
		return 0;
	}
	if (iParam5 < 0)
	{
		return 0;
	}
	if (iParam6 < 0)
	{
		return 0;
	}
	if (iParam8 == 76)
	{
		return 0;
	}
	if (iParam9 == 235)
	{
		return 0;
	}
	if (iParam3 < 3)
	{
		if (unk_0xCE990E643CD9D0E5(iParam2, iParam3))
		{
			return 0;
		}
	}
	if (iParam4 < 3)
	{
		if (iParam4 != iParam3)
		{
			return 0;
		}
	}
	if (iParam2 < 1 || iParam2 > 7)
	{
		return 0;
	}
	if (Global_111858.f_7684.f_136 < 9)
	{
		Var0 = iParam0;
		if (Global_111858.f_7684.f_911 == Var0)
		{
			Global_111858.f_7684.f_911 = -1;
		}
		Var0.f_3 = func_6(iParam1);
		Var0.f_1 = iParam11;
		Var0.f_2 = iParam2;
		Var0.f_4 = (unk_0x578C4EF320340AF7() + iParam5);
		Var0.f_5 = iParam6;
		Var0.f_6 = iParam3;
		Var0.f_14 = iParam4;
		Var0.f_10 = iParam7;
		Var0.f_11 = -1;
		Var0.f_7 = iParam8;
		Var0.f_8 = iParam9;
		Var0.f_9 = iParam10;
		unk_0xD2459066EA58CE43(&(Var0.f_1), 1);
		unk_0xD2459066EA58CE43(&(Var0.f_1), 0);
		if (iParam7 != -1)
		{
			unk_0xBE20AB8238688965(&(Var0.f_1), 11);
		}
		else if (iParam1 == 0)
		{
			unk_0xBE20AB8238688965(&(Var0.f_1), 10);
		}
		Global_111858.f_7684[Global_111858.f_7684.f_136 /*15*/] = { Var0 };
		Global_111858.f_7684.f_136++;
		iVar1 = 0;
		while (iVar1 < 3)
		{
			if (unk_0xCE990E643CD9D0E5(iParam2, iVar1))
			{
				func_4(iVar1);
			}
			iVar1++;
		}
		return 1;
	}
	return 0;
}
```


Overlapping Code:
```
 func_3(int iParam0, int iParam1, int iParam2, int iParam3, int iParam4, int iParam5, int iParam6, int iParam7, int iParam8, int iParam9, int iParam10, int iParam11)
{
struct<15> Var0;
int iVar1;

if (func_7(0))
{
return 0;
}
if (iParam5 < 0)
{
return 0;
}
if (iParam6 < 0)
{
return 0;
}
if (iParam8 == 76)
{
return 0;
}
if (iParam9 == 235)
{
return 0;
}
if (iParam3 < 3)
{
if (unk_0xCE990E643CD9D0E5(iParam2, iParam3))
{
return 0;
}
}
if (iParam4 < 3)
{
if (iParam4 != iParam3)
{
return 0;
}
}
if (iParam2 < 1 || iParam2 > 7)
{
return 0;
}
if (Global_111858.f_7684.f_136 < 9)
{
Var0 = iParam0;
if (Global_111858.f_7684.f_911 == Var0)
{
Global_111858.f_7684.f_911 = -1;
}
Var0.f_3 = func_6(iParam1);
Var0.f_1 = iParam11;
Var0.f_2 = iParam2;
Var0.f_4 = (unk_0x578C4EF320340AF7() + iParam5);
Var0.f_5 = iParam6;
Var0.f_6 = iParam3;
Var0.f_14 = iParam4;
Var0.f_10 = iParam7;
Var0.f_11 = -1;
Var0.f_7 = iParam8;
Var0.f_8 = iParam9;
Var0.f_9 = iParam10;
unk_0xD2459066EA58CE43(&(Var0.f_1), 1);
unk_0xD2459066EA58CE43(&(Var0.f_1), 0);
if (iParam7 != -1)
{
unk_0xBE20AB8238688965(&(Var0.f_1), 11);
}
else if (iParam1 == 0)
{
unk_0xBE20AB8238688965(&(Var0.f_1), 10);
}
Global_111858.f_7684[Global_111858.f_7684.f_136 /*15*/] = { Var0 };
Global_111858.f_7684.f_136++;
iVar1 = 0;
while (iVar1 < 3)
{
if (unk_0xCE990E643CD9D0E5(iParam2, iVar1))
{
func_4(iVar1);
}
iVar1++;
}
ret
```
<Overlap Ratio: 0.983453237410072>

---

--- 207 --
Question ID: a62d76091e7fa70e179a59014447065a19d6a777_20
Original Code:
```
const PNL_ATTR
NlAttrFind__(const PNL_ATTR attrs, UINT32 size, UINT16 type)
{
    PNL_ATTR iter = NULL;
    PNL_ATTR ret = NULL;
    UINT32 left;

    NL_ATTR_FOR_EACH (iter, left, attrs, size) {
        if (NlAttrType(iter) == type) {
            ret = iter;
            goto done;
        }
    }

done:
    return ret;
}
```


Overlapping Code:
```
R attrs, UINT32 size, UINT16 type)
{
PNL_ATTR iter = NULL;
PNL_ATTR ret = NULL;
UINT32 left;
NL_ATTR_FOR_EACH (iter, left, attrs, size) {
if (NlAttrType(iter) == type) {
ret = iter;
goto done;
}
}
don
```
<Overlap Ratio: 0.7782101167315175>

---

--- 208 --
Question ID: a1902895944147d9aa9f47a9a2ded59919142e1e_3
Original Code:
```
int cpu_poll_metrics(monikor_t *mon, struct timeval *clock) {
  float values[NB_CPU_METRICS];
  int n;

  n = cpu_fetch_metrics(values, NB_CPU_METRICS);
  for (int i = 0; i < n; i++) {
    monikor_metric_push(mon, monikor_metric_float(
      metric_names[i], clock, values[i], MONIKOR_METRIC_TIMEDELTA
    ));
  }
  if (!cpu_fetch_loadavg(mon, clock))
    n++;
  return n;
}
```


Overlapping Code:
```
n, struct timeval *clock) {
float values[NB_CPU_METRICS];
int n;
n = cpu_fetch_metrics(values, NB_CPU_METRICS);
for (int i = 0; i < n; i++) {
monikor_metric_push(mon, monikor_metric_float(
metric_names[i], clock, values[i], MONIKOR_METRIC_TIMEDELTA
));
}
if (!cpu_fetch_loadavg(mon, clock))
n++;
retu
```
<Overlap Ratio: 0.8797653958944281>

---

--- 209 --
Question ID: 3daeadd187616412f608eec0b547f1c4e188c7c0_89
Original Code:
```
void render_text_rgba(
    Attrib *attrib, int justify, float x, float y, float n, char *text,
    const float *background, const float *text_color)
{
    float matrix[16];
    set_matrix_2d(matrix, g->width, g->height);
    glUseProgram(attrib->program);
    glUniformMatrix4fv(attrib->matrix, 1, GL_FALSE, matrix);
    glUniform1i(attrib->sampler, 3);
    glUniform1i(attrib->extra1, 0);
    glUniform4fv(attrib->extra5, 1, background);
    glUniform4fv(attrib->extra6, 1, text_color);
    int length = strlen(text);
    x -= n * justify * (length - 1) / 2;
    GLuint buffer = gen_text_buffer(x, y, n, text);
    draw_text(attrib, buffer, length);
    del_buffer(buffer);
}
```


Overlapping Code:
```
ba(
Attrib *attrib, int justify, float x, float y, float n, char *text,
const float *background, const float *text_color)
{
float matrix[16];
set_matrix_2d(matrix, g->width, g->height);
glUseProgram(attrib->program);
glUniformMatrix4fv(attrib->matrix, 1, GL_FALSE, matrix);
glUniform1i(attrib->sampler, 3);
glUniform1i(attrib->extra1, 0);
glUniform4fv(attrib->extra5, 1, background);
glUniform4fv(attrib->extra6, 1, text_color);
int length = strlen(text);
x -= n * justify * (length - 1) / 2;
GLuint buffer = gen_text_buffer(x, y, n, text);
draw_text(attrib, buffer, length);
del_buffer(buffer);
```
<Overlap Ratio: 0.9659090909090909>

---

--- 210 --
Question ID: 96a63e497adeb1256fd034555b09a9cdb6c2b967_6
Original Code:
```
int arm_arch_state(struct target *target)
{
	struct arm *arm = target_to_arm(target);

	if (arm->common_magic != ARM_COMMON_MAGIC) {
		LOG_ERROR("BUG: called for a non-ARM target");
		return ERROR_FAIL;
	}

	/* avoid filling log waiting for fileio reply */
	if (target->semihosting && target->semihosting->hit_fileio)
		return ERROR_OK;

	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
		"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s%s",
		arm_state_strings[arm->core_state],
		debug_reason_name(target),
		arm_mode_name(arm->core_mode),
		buf_get_u32(arm->cpsr->value, 0, 32),
		buf_get_u32(arm->pc->value, 0, 32),
		(target->semihosting && target->semihosting->is_active) ? ", semihosting" : "",
		(target->semihosting && target->semihosting->is_fileio) ? " fileio" : "");

	return ERROR_OK;
}
```


Overlapping Code:
```
truct target *target)
{
struct arm *arm = target_to_arm(target);
if (arm->common_magic != ARM_COMMON_MAGIC) {
LOG_ERROR("BUG: called for a non-ARM target");
return ERROR_FAIL;
}
/* avoid filling log waiting for fileio reply */
if (target->semihosting && target->semihosting->hit_fileio)
return ERROR_OK;
LOG_USER("target halted in %s state due to %s, current mode: %s\n"
"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s%s",
arm_state_strings[arm->core_state],
debug_reason_name(target),
arm_mode_name(arm->core_mode),
buf_get_u32(arm->cpsr->value, 0, 32),
buf_get_u32(arm->pc->value, 0, 32),
(target->semihosting && target->semihosting->is_active) ? ", semihosting" : "",
(target->semihosting && target->semihosting->is
```
<Overlap Ratio: 0.9157088122605364>

---

--- 211 --
Question ID: 44c97561e598773860860a9c850bfd8c071e08aa_139
Original Code:
```
void func_219()
{
	Global_21058 = Global_21057;
	Global_21052 = Global_21053;
	Global_21099 = { Global_21087 };
	Global_21105 = { Global_21093 };
	Global_21060 = Global_21059;
	Global_21129 = { Global_21111 };
	Global_21135 = { Global_21117 };
	Global_21141 = { Global_21123 };
	Global_21147 = { Global_21153 };
	Global_6866 = Global_6867;
	Global_6868 = Global_6869;
	Global_21016 = Global_21017;
	Global_21018 = Global_21019;
	Global_21020 = { Global_21036 };
	Global_21009 = Global_21010;
	Global_22021 = 0;
	Global_21054 = 0;
	Global_21055 = 0;
	unk_0xD2459066EA58CE43(&Global_7552, 16);
}
```


Overlapping Code:
```
()
{
Global_21058 = Global_21057;
Global_21052 = Global_21053;
Global_21099 = { Global_21087 };
Global_21105 = { Global_21093 };
Global_21060 = Global_21059;
Global_21129 = { Global_21111 };
Global_21135 = { Global_21117 };
Global_21141 = { Global_21123 };
Global_21147 = { Global_21153 };
Global_6866 = Global_6867;
Global_6868 = Global_6869;
Global_21016 = Global_21017;
Global_21018 = Global_21019;
Global_21020 = { Global_21036 };
Global_21009 = Global_21010;
Global_22021 = 0;
Global_21054 = 0;
Global_21055 = 0;
unk_0xD2459066EA58CE43(&Global_7552, 16);
}
```
<Overlap Ratio: 0.9773519163763066>

---

--- 212 --
Question ID: 6cdff29f95bf754c7c2c6891171e584b7cdfaea7_10
Original Code:
```
int git_attr_cache__push_file(
	git_repository *repo,
	const char *base,
	const char *filename,
	git_attr_file_source source,
	git_attr_file_parser parse,
	void* parsedata,
	git_vector *stack)
{
	int error = 0;
	git_buf path = GIT_BUF_INIT;
	const char *workdir = git_repository_workdir(repo);
	const char *relfile, *content = NULL;
	git_attr_cache *cache = git_repository_attr_cache(repo);
	git_attr_file *file = NULL;
	git_blob *blob = NULL;
	git_futils_filestamp stamp;

	assert(filename && stack);

	/* join base and path as needed */
	if (base != NULL && git_path_root(filename) < 0) {
		if (git_buf_joinpath(&path, base, filename) < 0)
			return -1;
		filename = path.ptr;
	}

	relfile = filename;
	if (workdir && git__prefixcmp(relfile, workdir) == 0)
		relfile += strlen(workdir);

	/* check cache */
	if (load_attr_from_cache(&file, cache, source, relfile) < 0)
		return -1;

	/* if not in cache, load data, parse, and cache */

	if (source == GIT_ATTR_FILE_FROM_FILE) {
		git_futils_filestamp_set(
			&stamp, file ? &file->cache_data.stamp : NULL);

		error = load_attr_file(&content, &stamp, filename);
	} else {
		error = load_attr_blob_from_index(&content, &blob,
			repo, file ? &file->cache_data.oid : NULL, relfile);
	}

	if (error) {
		/* not finding a file is not an error for this function */
		if (error == GIT_ENOTFOUND) {
			giterr_clear();
			error = 0;
		}
		goto finish;
	}

	/* if we got here, we have to parse and/or reparse the file */
	if (file)
		git_attr_file__clear_rules(file);
	else {
		error = git_attr_file__new(&file, source, relfile, &cache->pool);
		if (error < 0)
			goto finish;
	}

	if (parse && (error = parse(repo, parsedata, content, file)) < 0)
		goto finish;

	git_strmap_insert(cache->files, file->key, file, error); //-V595
	if (error > 0)
		error = 0;

	/* remember "cache buster" file signature */
	if (blob)
		git_oid_cpy(&file->cache_data.oid, git_object_id((git_object *)blob));
	else
		git_futils_filestamp_set(&file->cache_data.stamp, &stamp);

finish:
	/* push file onto vector if we found one*/
	if (!error && file != NULL)
		error = git_vector_insert(stack, file);

	if (error != 0)
		git_attr_file__free(file);

	if (blob)
		git_blob_free(blob);
	else
		git__free((void *)content);

	git_buf_free(&path);

	return error;
}
```


Overlapping Code:
```
nt git_attr_cache__push_file(
git_repository *repo,
const char *base,
const char *filename,
git_attr_file_source source,
git_attr_file_parser parse,
void* parsedata,
git_vector *stack)
{
int error = 0;
git_buf path = GIT_BUF_INIT;
const char *workdir = git_repository_workdir(repo);
const char *relfile, *content = NULL;
git_attr_cache *cache = git_repository_attr_cache(repo);
git_attr_file *file = NULL;
git_blob *blob = NULL;
git_futils_filestamp stamp;
assert(filename && stack);
/* join base and path as needed */
if (base != NULL && git_path_root(filename) < 0) {
if (git_buf_joinpath(&path, base, filename) < 0)
return -1;
filename = path.ptr;
}
relfile = filename;
if (workdir && git__prefixcmp(relfile, workdir) == 0)
relfile += strlen(workdir);
/* check cache */
if (load_attr_from_cache(&file, cache, source, relfile) < 0)
return -1;
/* if not in cache, load data, parse, and cache */
if (source == GIT_ATTR_FILE_FROM_FILE) {
git_futils_filestamp_set(
&stamp, file ? &file->cache_data.stamp : NULL);
error = load_attr_file(&content, &stamp, filename);
} else {
error = load_attr_blob_from_index(&content, &blob,
repo, file ? &file->cache_data.oid : NULL, relfile);
}
if (error) {
/* not finding a file is not an error for this function */
if (error == GIT_ENOTFOUND) {
giterr_clear();
error = 0;
}
goto finish;
}
/* if we got here, we have to parse and/or reparse the file */
if (file)
git_attr_file__clear_rules(file);
else {
error = git_attr_file__new(&file, source, relfile, &cache->pool);
if (error < 0)
goto finish;
}
if (parse && (error = parse(repo, parsedata, content, file)) < 0)
goto finish;
git_strmap_insert(cache->files, file->key, file, error); //-V595
if (error > 0)
error = 0;
/* remember "cache buster" file signature */
if (blob)
git_oid_cpy(&file->cache_data.oid, git_object_id((git_object *)blob));
else
git_futils_filestamp_set(&file->cache_data.stamp, &stamp);
finish:
/* push file onto vector if we found one*/
if (!error && file != NULL)
error = git_vector_insert(stack, file);
if (error != 0)
git_attr_file__free(file);
if (blob)
git_blob_free(blob);
else
git__free((void *)content);
git_buf_free(&p
```
<Overlap Ratio: 0.989800649049606>

---

--- 213 --
Question ID: b4b2014f5d3d6acab384365c8f29d4b18614062b_32
Original Code:
```
static void MP4_FreeBox_avcC( MP4_Box_t *p_box )
{
    MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;
    int i;

    if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );

    if( p_avcC->sps )
    {
        for( i = 0; i < p_avcC->i_sps; i++ )
            FREENULL( p_avcC->sps[i] );
    }
    if( p_avcC->pps )
    {
        for( i = 0; i < p_avcC->i_pps; i++ )
            FREENULL( p_avcC->pps[i] );
    }
    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );
    if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );
    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );
    if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );
}
```


Overlapping Code:
```
id MP4_FreeBox_avcC( MP4_Box_t *p_box )
{
MP4_Box_data_avcC_t *p_avcC = p_box->data.p_avcC;
int i;
if( p_avcC->i_avcC > 0 ) FREENULL( p_avcC->p_avcC );
if( p_avcC->sps )
{
for( i = 0; i < p_avcC->i_sps; i++ )
FREENULL( p_avcC->sps[i] );
}
if( p_avcC->pps )
{
for( i = 0; i < p_avcC->i_pps; i++ )
FREENULL( p_avcC->pps[i] );
}
if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->sps );
if( p_avcC->i_sps > 0 ) FREENULL( p_avcC->i_sps_length );
if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->pps );
if( p_avcC->i_pps > 0 ) FREENULL( p_avcC->i_pps_length );

```
<Overlap Ratio: 0.9818181818181818>

---

--- 214 --
Question ID: 0e1efd2dce71fa3a9ab70f9ba3c998af4f7dd1bb_4
Original Code:
```
static int
clnt_compose_rpcmsg(CLIENT *h, rpcproc_t procnum,
    rdma_buf_t *rpcmsg, XDR *xdrs,
    xdrproc_t xdr_args, caddr_t argsp)
{
	cku_private_t *p = htop(h);

	if (h->cl_auth->ah_cred.oa_flavor != RPCSEC_GSS) {
		/*
		 * Copy in the preserialized RPC header
		 * information.
		 */
		bcopy(p->cku_rpchdr, rpcmsg->addr, CKU_HDRSIZE);

		/*
		 * transaction id is the 1st thing in the output
		 * buffer.
		 */
		/* LINTED pointer alignment */
		(*(uint32_t *)(rpcmsg->addr)) = p->cku_xid;

		/* Skip the preserialized stuff. */
		XDR_SETPOS(xdrs, CKU_HDRSIZE);

		/* Serialize dynamic stuff into the output buffer. */
		if ((!XDR_PUTINT32(xdrs, (int32_t *)&procnum)) ||
		    (!AUTH_MARSHALL(h->cl_auth, xdrs, p->cku_cred)) ||
		    (!(*xdr_args)(xdrs, argsp))) {
			DTRACE_PROBE(krpc__e__clntrdma__rpcmsg__dynargs);
			return (CLNT_RDMA_FAIL);
		}
		p->cku_outsz = XDR_GETPOS(xdrs);
	} else {
		uint32_t *uproc = (uint32_t *)&p->cku_rpchdr[CKU_HDRSIZE];
		IXDR_PUT_U_INT32(uproc, procnum);
		(*(uint32_t *)(&p->cku_rpchdr[0])) = p->cku_xid;
		XDR_SETPOS(xdrs, 0);

		/* Serialize the procedure number and the arguments. */
		if (!AUTH_WRAP(h->cl_auth, (caddr_t)p->cku_rpchdr,
		    CKU_HDRSIZE+4, xdrs, xdr_args, argsp)) {
			if (rpcmsg->addr != xdrs->x_base) {
				rpcmsg->addr = xdrs->x_base;
				rpcmsg->len = xdr_getbufsize(xdrs);
			}
			DTRACE_PROBE(krpc__e__clntrdma__rpcmsg__procnum);
			return (CLNT_RDMA_FAIL);
		}
		/*
		 * If we had to allocate a new buffer while encoding
		 * then update the addr and len.
		 */
		if (rpcmsg->addr != xdrs->x_base) {
			rpcmsg->addr = xdrs->x_base;
			rpcmsg->len = xdr_getbufsize(xdrs);
		}

		p->cku_outsz = XDR_GETPOS(xdrs);
		DTRACE_PROBE1(krpc__i__compose__size__sec, int, p->cku_outsz)
	}

	return (CLNT_RDMA_SUCCESS);
}
```


Overlapping Code:
```
ompose_rpcmsg(CLIENT *h, rpcproc_t procnum,
rdma_buf_t *rpcmsg, XDR *xdrs,
xdrproc_t xdr_args, caddr_t argsp)
{
cku_private_t *p = htop(h);
if (h->cl_auth->ah_cred.oa_flavor != RPCSEC_GSS) {
/*
* Copy in the preserialized RPC header
* information.
*/
bcopy(p->cku_rpchdr, rpcmsg->addr, CKU_HDRSIZE);
/*
* transaction id is the 1st thing in the output
* buffer.
*/
/* LINTED pointer alignment */
(*(uint32_t *)(rpcmsg->addr)) = p->cku_xid;
/* Skip the preserialized stuff. */
XDR_SETPOS(xdrs, CKU_HDRSIZE);
/* Serialize dynamic stuff into the output buffer. */
if ((!XDR_PUTINT32(xdrs, (int32_t *)&procnum)) ||
(!AUTH_MARSHALL(h->cl_auth, xdrs, p->cku_cred)) ||
(!(*xdr_args)(xdrs, argsp))) {
DTRACE_PROBE(krpc__e__clntrdma__rpcmsg__dynargs);
return (CLNT_RDMA_FAIL);
}
p->cku_outsz = XDR_GETPOS(xdrs);
} else {
uint32_t *uproc = (uint32_t *)&p->cku_rpchdr[CKU_HDRSIZE];
IXDR_PUT_U_INT32(uproc, procnum);
(*(uint32_t *)(&p->cku_rpchdr[0])) = p->cku_xid;
XDR_SETPOS(xdrs, 0);
/* Serialize the procedure number and the arguments. */
if (!AUTH_WRAP(h->cl_auth, (caddr_t)p->cku_rpchdr,
CKU_HDRSIZE+4, xdrs, xdr_args, argsp)) {
if (rpcmsg->addr != xdrs->x_base) {
rpcmsg->addr = xdrs->x_base;
rpcmsg->len = xdr_getbufsize(xdrs);
}
DTRACE_PROBE(krpc__e__clntrdma__rpcmsg__procnum);
return (CLNT_RDMA_FAIL);
}
/*
* If we had to allocate a new buffer while encoding
* then update the addr and len.
*/
if (rpcmsg->addr != xdrs->x_base) {
rpcmsg->addr = xdrs->x_base;
rpcmsg->len = xdr_getbufsize(xdrs);
}
p->cku_outsz = XDR_GETPOS(xdrs);
DTRACE_PROBE1(krpc__i__compose__size__sec, int, p->cku_outsz)
}
return (
```
<Overlap Ratio: 0.9768009768009768>

---

--- 215 --
Question ID: de8e63173b8be0eb53741e5165506cb64d0ac1fa_2
Original Code:
```
static char *
unq(const char *str)
{
	const char *s;
	char *unq_str, *d;
	int escaped;

	unq_str = malloc(strlen(str) + 1);
	if (unq_str == NULL)
		return NULL;

	escaped = 0;
	d = unq_str;
	for (s = str; *s != '\0'; s++) {
		switch (*s) {
		case '\\':
			if (escaped)
				*d++ = *s;
			escaped = !escaped;
			break;
		default:
			*d++ = *s;
			escaped = 0;
		}
	}
	*d = '\0';

	return unq_str;
}
```


Overlapping Code:
```
r *
unq(const char *str)
{
const char *s;
char *unq_str, *d;
int escaped;
unq_str = malloc(strlen(str) + 1);
if (unq_str == NULL)
return NULL;
escaped = 0;
d = unq_str;
for (s = str; *s != '\0'; s++) {
switch (*s) {
case '\\':
if (escaped)
*d++ = *s;
escaped = !escaped;
break;
default:
*d++ = *s;
es
```
<Overlap Ratio: 0.8498583569405099>

---

--- 216 --
Question ID: 83c55a2c40f95b48e2134253691cb77cb6debfd3_0
Original Code:
```
class AlignmentController
{
  private:
    // Comms
    ros::NodeHandle nh;
    ros::Subscriber alignment_cmd_sub, object_sub, depth_sub, task_info_sub;
    ros::Publisher x_pub, y_pub, depth_pub, status_pub;
    ros::Timer timer;

    // IIR Filter variables for error_dot
    double PID_IIR_LPF_bandwidth, dt_iir, alpha, imu_filter_rate;

    double max_zero_detect_duration;

    control_toolbox::Pid x_pid, y_pid, z_pid;
    double cmd_heave;
    std_msgs::Float64 cmd_force_x, cmd_force_y;
    riptide_msgs::DepthCommand depth_cmd;

    riptide_msgs::ControlStatusLinear status_msg;
    double current_depth;
    double MAX_X_ERROR, MAX_Y_ERROR, MAX_Z_ERROR, MAX_BBOX_SURGE_ERROR, MAX_BBOX_DEPTH_ERROR;
    
    int alignment_plane, bbox_control, obj_bbox_dim, target_bbox_dim;

    geometry_msgs::Vector3 error, error_dot, last_error_dot, last_error;
    geometry_msgs::Vector3 obj_pos, target_pos;
    double dt;

    ros::Time sample_start;
    ros::Duration sample_duration;

    // Reset and active variables
    //bool pid_alignment_reset, pid_alignment_active;
    //bool pid_surge_reset, pid_sway_reset, pid_heave_reset;
    bool pid_surge_active, pid_sway_active, pid_heave_active, pid_alignment_active;

    void InitMsgs();
    void UpdateError();
    double Constrain(double current, double max);
    double SmoothErrorIIR(double input, double prev);
    void ResetSurge();
    void ResetSway();
    void ResetHeave();

  public:
    AlignmentController();
    template <typename T>
    void LoadParam(string param, T &var);
    void ObjectCB(const riptide_msgs::Object::ConstPtr &obj_msg);
    void DisableControllerTimer(const ros::TimerEvent& event);
    void CommandCB(const riptide_msgs::AlignmentCommand::ConstPtr &cmd);
    void DepthCB(const riptide_msgs::Depth::ConstPtr &depth_msg);
    void TaskInfoCB(const riptide_msgs::TaskInfo::ConstPtr& task_msg);
    //void ResetCB(const riptide_msgs::ResetControls::ConstPtr &reset_msg);
 }
```


Overlapping Code:
```
ignmentController
{
private:
// Comms
ros::NodeHandle nh;
ros::Subscriber alignment_cmd_sub, object_sub, depth_sub, task_info_sub;
ros::Publisher x_pub, y_pub, depth_pub, status_pub;
ros::Timer timer;
// IIR Filter variables for error_dot
double PID_IIR_LPF_bandwidth, dt_iir, alpha, imu_filter_rate;
double max_zero_detect_duration;
control_toolbox::Pid x_pid, y_pid, z_pid;
double cmd_heave;
std_msgs::Float64 cmd_force_x, cmd_force_y;
riptide_msgs::DepthCommand depth_cmd;
riptide_msgs::ControlStatusLinear status_msg;
double current_depth;
double MAX_X_ERROR, MAX_Y_ERROR, MAX_Z_ERROR, MAX_BBOX_SURGE_ERROR, MAX_BBOX_DEPTH_ERROR;

int alignment_plane, bbox_control, obj_bbox_dim, target_bbox_dim;
geometry_msgs::Vector3 error, error_dot, last_error_dot, last_error;
geometry_msgs::Vector3 obj_pos, target_pos;
double dt;
ros::Time sample_start;
ros::Duration sample_duration;
// Reset and active variables
//bool pid_alignment_reset, pid_alignment_active;
//bool pid_surge_reset, pid_sway_reset, pid_heave_reset;
bool pid_surge_active, pid_sway_active, pid_heave_active, pid_alignment_active;
void InitMsgs();
void UpdateError();
double Constrain(double current, double max);
double SmoothErrorIIR(double input, double prev);
void ResetSurge();
void ResetSway();
void ResetHeave();
public:
AlignmentController();
template <typename T>
void LoadParam(string param, T &var);
void ObjectCB(const riptide_msgs::Object::ConstPtr &obj_msg);
void DisableControllerTimer(const ros::TimerEvent& event);
void CommandCB(const riptide_msgs::AlignmentCommand::ConstPtr &cmd);
void DepthCB(const riptide_msgs::Depth::ConstPtr &depth_msg);
void TaskInfoCB(const riptide_msgs::TaskInfo::ConstPtr& task_msg);
//void ResetCB(const riptide_msgs::ResetControls::Cons
```
<Overlap Ratio: 0.9848058525604952>

---

--- 217 --
Question ID: a9b0bed4243ebff3273db5c2abe804fd10fb9344_8
Original Code:
```
TkTextIndex *
TkTextMakeCharIndex(
    TkTextBTree tree,		/* Tree that lineIndex and charIndex refer
				 * to. */
    TkText *textPtr,
    int lineIndex,		/* Index of desired line (0 means first line
				 * of text). */
    int charIndex,		/* Index of desired character. */
    TkTextIndex *indexPtr)	/* Structure to fill in. */
{
    register TkTextSegment *segPtr;
    char *p, *start, *end;
    int index, offset;
    Tcl_UniChar ch;

    indexPtr->tree = tree;
    if (lineIndex < 0) {
	lineIndex = 0;
	charIndex = 0;
    }
    if (charIndex < 0) {
	charIndex = 0;
    }
    indexPtr->linePtr = TkBTreeFindLine(tree, textPtr, lineIndex);
    if (indexPtr->linePtr == NULL) {
	indexPtr->linePtr = TkBTreeFindLine(tree, textPtr,
		TkBTreeNumLines(tree, textPtr));
	charIndex = 0;
    }

    /*
     * Verify that the index is within the range of the line. If not, just use
     * the index of the last character in the line.
     */

    index = 0;
    for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) {
	if (segPtr == NULL) {
	    /*
	     * Use the index of the last character in the line. Since the last
	     * character on the line is guaranteed to be a '\n', we can back
	     * up a constant sizeof(char) bytes.
	     */

	    indexPtr->byteIndex = index - sizeof(char);
	    break;
	}
	if (segPtr->typePtr == &tkTextCharType) {
	    /*
	     * Turn character offset into a byte offset.
	     */

	    start = segPtr->body.chars;
	    end = start + segPtr->size;
	    for (p = start; p < end; p += offset) {
		if (charIndex == 0) {
		    indexPtr->byteIndex = index;
		    return indexPtr;
		}
		charIndex--;
		offset = Tcl_UtfToUniChar(p, &ch);
		index += offset;
	    }
	} else {
	    if (charIndex < segPtr->size) {
		indexPtr->byteIndex = index;
		break;
	    }
	    charIndex -= segPtr->size;
	    index += segPtr->size;
	}
    }
    return indexPtr;
}
```


Overlapping Code:
```

TkTextMakeCharIndex(
TkTextBTree tree, /* Tree that lineIndex and charIndex refer
* to. */
TkText *textPtr,
int lineIndex, /* Index of desired line (0 means first line
* of text). */
int charIndex, /* Index of desired character. */
TkTextIndex *indexPtr) /* Structure to fill in. */
{
register TkTextSegment *segPtr;
char *p, *start, *end;
int index, offset;
Tcl_UniChar ch;
indexPtr->tree = tree;
if (lineIndex < 0) {
lineIndex = 0;
charIndex = 0;
}
if (charIndex < 0) {
charIndex = 0;
}
indexPtr->linePtr = TkBTreeFindLine(tree, textPtr, lineIndex);
if (indexPtr->linePtr == NULL) {
indexPtr->linePtr = TkBTreeFindLine(tree, textPtr,
TkBTreeNumLines(tree, textPtr));
charIndex = 0;
}
/*
* Verify that the index is within the range of the line. If not, just use
* the index of the last character in the line.
*/
index = 0;
for (segPtr = indexPtr->linePtr->segPtr; ; segPtr = segPtr->nextPtr) {
if (segPtr == NULL) {
/*
* Use the index of the last character in the line. Since the last
* character on the line is guaranteed to be a '\n', we can back
* up a constant sizeof(char) bytes.
*/
indexPtr->byteIndex = index - sizeof(char);
break;
}
if (segPtr->typePtr == &tkTextCharType) {
/*
* Turn character offset into a byte offset.
*/
start = segPtr->body.chars;
end = start + segPtr->size;
for (p = start; p < end; p += offset) {
if (charIndex == 0) {
indexPtr->byteIndex = index;
return indexPtr;
}
charIndex--;
offset = Tcl_UtfToUniChar(p, &ch);
index += offset;
}
} else {
if (charIndex < segPtr->size) {
indexPtr->byteIndex = index;
break;
}
charIndex -= segPtr->size;
index += segPtr->size;
}
}
return i
```
<Overlap Ratio: 0.9859068627450981>

---

--- 218 --
Question ID: 8af5f540b7b889c6c73cfadf0ae662cca9dbe72a_1
Original Code:
```
void
dobootopts(int argc, char **argv)
{
	static char filenamebuf[1 + 32];
	char *SystemPartition = NULL;
	char *cp;
	int i;

	for (i = 1; i < argc; i++) {
		cp = argv[i];
		if (cp == NULL)
			continue;
		if (strncmp(cp, "OSLoadOptions=", 14) == 0) {
			if (strcmp(&cp[14], "auto") == 0)
				bootauto = AUTO_YES;
			else if (strcmp(&cp[14], "single") == 0)
				bootauto = AUTO_NO;
			else if (strcmp(&cp[14], "mini") == 0)
				bootauto = AUTO_MINI;
			else if (strcmp(&cp[14], "debug") == 0)
				bootauto = AUTO_DEBUG;
		} else if (strncmp(cp, "OSLoadPartition=", 16) == 0)
			OSLoadPartition = &cp[16];
		else if (strncmp(cp, "OSLoadFilename=", 15) == 0)
			OSLoadFilename = &cp[15];
		else if (strncmp(cp, "SystemPartition=", 16) == 0)
			SystemPartition = &cp[16];
	}

	/* If "OSLoadOptions=" is missing, see if any arg was given. */
	if (bootauto == AUTO_NONE && *argv[1] == '/')
		OSLoadFilename = argv[1];

	if (bootauto == AUTO_MINI) {
		static char loadpart[64];
		char *p;

		strlcpy(loadpart, argv[0], sizeof loadpart);
		if ((p = strstr(loadpart, "partition(8)")) != NULL) {
			p += strlen("partition(");
		} else if (strncmp(loadpart, "dksc(", 5) == 0) {
			p = strstr(loadpart, ",8)");
			if (p != NULL)
				p++;
		} else
			p = NULL;

		if (p != NULL) {
			p[0] = '0';
			p[2] = '\0';
			snprintf(filenamebuf, sizeof filenamebuf,
			    "/bsd.rd.IP%d", IP);
			OSLoadPartition = loadpart;
			OSLoadFilename = filenamebuf;
		}
	}
}
```


Overlapping Code:
```
ootopts(int argc, char **argv)
{
static char filenamebuf[1 + 32];
char *SystemPartition = NULL;
char *cp;
int i;
for (i = 1; i < argc; i++) {
cp = argv[i];
if (cp == NULL)
continue;
if (strncmp(cp, "OSLoadOptions=", 14) == 0) {
if (strcmp(&cp[14], "auto") == 0)
bootauto = AUTO_YES;
else if (strcmp(&cp[14], "single") == 0)
bootauto = AUTO_NO;
else if (strcmp(&cp[14], "mini") == 0)
bootauto = AUTO_MINI;
else if (strcmp(&cp[14], "debug") == 0)
bootauto = AUTO_DEBUG;
} else if (strncmp(cp, "OSLoadPartition=", 16) == 0)
OSLoadPartition = &cp[16];
else if (strncmp(cp, "OSLoadFilename=", 15) == 0)
OSLoadFilename = &cp[15];
else if (strncmp(cp, "SystemPartition=", 16) == 0)
SystemPartition = &cp[16];
}
/* If "OSLoadOptions=" is missing, see if any arg was given. */
if (bootauto == AUTO_NONE && *argv[1] == '/')
OSLoadFilename = argv[1];
if (bootauto == AUTO_MINI) {
static char loadpart[64];
char *p;
strlcpy(loadpart, argv[0], sizeof loadpart);
if ((p = strstr(loadpart, "partition(8)")) != NULL) {
p += strlen("partition(");
} else if (strncmp(loadpart, "dksc(", 5) == 0) {
p = strstr(loadpart, ",8)");
if (p != NULL)
p++;
} else
p = NULL;
if (p != NULL) {
p[0] = '0';
p[2] = '\0';
snprintf(filenamebuf, sizeof filenamebuf,
"/bsd.rd.IP%d", IP);
OSLoadPartition = loadpart;
OSLoadFilename = filen
```
<Overlap Ratio: 0.9841029523088569>

---

--- 219 --
Question ID: 2efed89f567820318e35204fa1f44ec3e47dd7aa_0
Original Code:
```
int main (int argc, char * argv[]) {
  // crete folders to write results
  system("mkdir -p vtu");
  system("mkdir -p plic");
  system("mkdir -p dump");
  maxruntime (&argc, argv);
  if (argc > 1)
    LEVEL = atoi (argv[1]);
  if (argc > 2)
    Bo = atof(argv[2]);
  if (argc > 3)
    Ga = atof(argv[3]);
  size (WIDTH);
  origin (0, 0);
  init_grid (128);
  rho1 = 1.0;
  rho2 = 1.0/RHOR;
  mu1 = 1.0/Ga;
  mu2 = 1.0/(MUR*Ga);
  f.sigma = 1.0/Bo;
  TOLERANCE = 1e-4;
  run();
}
```


Overlapping Code:
```
crete folders to write results
system("mkdir -p vtu");
system("mkdir -p plic");
system("mkdir -p dump");
maxruntime (&argc, argv);
if (argc > 1)
LEVEL = atoi (argv[1]);
if (argc > 2)
Bo = atof(argv[2]);
if (argc > 3)
Ga = atof(argv[3]);
size (WIDTH);
origin (0, 0);
init_grid (128);
rho1 = 1.0;
rho2 = 1.0/RHOR;
mu1 = 1.0/Ga;
mu2 = 1.0/(MUR*Ga);
f.si
```
<Overlap Ratio: 0.813953488372093>

---

--- 220 --
Question ID: 686625adca35c81992e99d82250575eecf84231d_1
Original Code:
```
unsigned int call_pkm_modify_code(unsigned long arg)
{
        unsigned long *func;
        static unsigned long oldfunc;

        func = (unsigned long*)tts_debug_func_mod;
        if(!func)
                return TTS_TC_RET_FAILURE;
        if(arg)
        {
                oldfunc = *func;
                *func = 'r';
        }
        else
        {
                *func =  oldfunc;
        }
        return TTS_TC_RET_SUCCESS;
}
```


Overlapping Code:
```
long arg)
{
unsigned long *func;
static unsigned long oldfunc;
func = (unsigned long*)tts_debug_func_mod;
if(!func)
return TTS_TC_RET_FAILURE;
if(arg)
{
oldfunc = *func;
*func = 'r';
}
else
{
*func = 
```
<Overlap Ratio: 0.7092198581560284>

---

--- 221 --
Question ID: 5ff962d8102a9885a12d17cfeab042bcd9261277_10
Original Code:
```
static int
ptls_compare_separator_line (const char *line, const char *begin_or_end,
			     const char *label)
{
  int ret = strncmp (line, "-----", 5);
  size_t text_index = 5;

  if (ret == 0)
    {
      size_t begin_or_end_length = strlen (begin_or_end);
      ret = strncmp (line + text_index, begin_or_end, begin_or_end_length);
      text_index += begin_or_end_length;
    }

  if (ret == 0)
    {
      ret = line[text_index] - ' ';
      text_index++;
    }

  if (ret == 0)
    {
      size_t label_length = strlen (label);
      ret = strncmp (line + text_index, label, label_length);
      text_index += label_length;
    }

  if (ret == 0)
    {
      ret = strncmp (line + text_index, "-----", 5);
    }

  return ret;
}
```


Overlapping Code:
```

ptls_compare_separator_line (const char *line, const char *begin_or_end,
const char *label)
{
int ret = strncmp (line, "-----", 5);
size_t text_index = 5;
if (ret == 0)
{
size_t begin_or_end_length = strlen (begin_or_end);
ret = strncmp (line + text_index, begin_or_end, begin_or_end_length);
text_index += begin_or_end_length;
}
if (ret == 0)
{
ret = line[text_index] - ' ';
text_index++;
}
if (ret == 0)
{
size_t label_length = strlen (label);
ret = strncmp (line + text_index, label, label_length);
text_index += label_length;
}
if (ret == 0)
{
ret = strncmp (line + text_index, "-----", 5);
}
re
```
<Overlap Ratio: 0.966183574879227>

---

--- 222 --
Question ID: af180933a506439d17acb94dd473146fe3bf1291_4
Original Code:
```
int main(int argc, const char * const argv[])
{
  (void)argc;
  (void)argv;

  /* Initialize the application.
     You do not need to do this more than one time. */
  SteadyState_3D_SOR_Solver_CoreC_initialize();

  /* Invoke the entry-point functions.
     You can call entry-point functions multiple times. */
  main_SteadyState_3D_SOR_Solver_CoreC();

  /* Terminate the application.
     You do not need to do this more than one time. */
  SteadyState_3D_SOR_Solver_CoreC_terminate();
  return 0;
}
```


Overlapping Code:
```
nt main(int argc, const char * const argv[])
{
(void)argc;
(void)argv;
/* Initialize the application.
You do not need to do this more than one time. */
SteadyState_3D_SOR_Solver_CoreC_initialize();
/* Invoke the entry-point functions.
You can call entry-point functions multiple times. */
main_SteadyState_3D_SOR_Solver_CoreC();
/* Terminate the application.
You do not need to do this more than one time. */
SteadyState_3D_SOR_Solver_Cor
```
<Overlap Ratio: 0.9399141630901288>

---

--- 223 --
Question ID: 460bbe92403eda219d18134267efdbc3386dea91_4
Original Code:
```
void display_line( uint8_t line, const char *label, double num, const char *unit, uint8_t ser_line, bool ok ) {
    char msg[21];
    snprintf(msg, sizeof(msg), " %-4s%6d.%02d %-2s ", label, (int)num, (int)(num * 100) % 100, unit);
    if( ser_line == 1 ) printf("%s", msg);
    LCD_ShowString(8, line * 16, (uint8_t *)msg, ok ? BLACK : RED);
}
```


Overlapping Code:
```
uint8_t line, const char *label, double num, const char *unit, uint8_t ser_line, bool ok ) {
char msg[21];
snprintf(msg, sizeof(msg), " %-4s%6d.%02d %-2s ", label, (int)num, (int)(num * 100) % 100, unit);
if( ser_line == 1 ) printf("%s", msg);
LCD_ShowString(8, line * 16, (uint8_t *)msg, ok ? BLACK 
```
<Overlap Ratio: 0.9146341463414634>

---

--- 224 --
Question ID: bb1455ac0191268374ae88fad1fbc9a872bbc5df_12
Original Code:
```
int ipl2_main(int argc, char *argv[])
{
  int ret;

  UNUSED(ret); /* Not used in all configurations */

  _info("start: %s\n", CONFIG_CURRENT_REVISION);
  _info("imgsig: %u\n", IMG_SIGNATURE);

#ifdef CONFIG_CHARGER
  /* NOTE:
   * chg_disable() must be done before CMIC_FWAKE L->H.
   * Please refer to PDFW15IS-2494 for more information
   */

  chg_disable();
#endif

  lc823450_mtd_initialize(0);

#ifdef CONFIG_ADC
  ret = check_forceusbboot();
#endif

#ifdef CONFIG_USBMSC
  if (ret)
    {
      msc_enable(0);
    }

  ret = check_diskformat();

  if (ret)
    {
      msc_enable(1);
    }

  memset(copybuf, 0, sizeof(copybuf));
  get_config(1, copybuf);

  /* for "reboot usb" */

  if (!strncmp("usb", copybuf, 3))
    {
      /* remove boot flag for next boot */

      memset(copybuf, 0, sizeof(copybuf));
      set_config(1, copybuf);
      msc_enable(1);
    }
#endif

#ifdef CONFIG_LASTKMSG
  check_lastkmsg();
#endif /* CONFIG_LASTKMSG */

  if (!strncmp("recovery", copybuf, 8))
    {
      /* check recovery kernel update */

      mount(CONFIG_MTD_CP_DEVPATH, "/mnt/sd0", "evfat", 0, NULL);
      nxsig_usleep(10000);

      /* recovery kernel install from UPG.img */

      install_recovery("/mnt/sd0/UPG.IMG");
      load_kernel("recovery", CONFIG_MTD_RECOVERY_DEVPATH);

    }
  else
    {
      load_kernel("nuttx", CONFIG_MTD_KERNEL_DEVPATH);
    }

  /* not reached */

  return -1;
}
```


Overlapping Code:
```
nt argc, char *argv[])
{
int ret;
UNUSED(ret); /* Not used in all configurations */
_info("start: %s\n", CONFIG_CURRENT_REVISION);
_info("imgsig: %u\n", IMG_SIGNATURE);
#ifdef CONFIG_CHARGER
/* NOTE:
* chg_disable() must be done before CMIC_FWAKE L->H.
* Please refer to PDFW15IS-2494 for more information
*/
chg_disable();
#endif
lc823450_mtd_initialize(0);
#ifdef CONFIG_ADC
ret = check_forceusbboot();
#endif
#ifdef CONFIG_USBMSC
if (ret)
{
msc_enable(0);
}
ret = check_diskformat();
if (ret)
{
msc_enable(1);
}
memset(copybuf, 0, sizeof(copybuf));
get_config(1, copybuf);
/* for "reboot usb" */
if (!strncmp("usb", copybuf, 3))
{
/* remove boot flag for next boot */
memset(copybuf, 0, sizeof(copybuf));
set_config(1, copybuf);
msc_enable(1);
}
#endif
#ifdef CONFIG_LASTKMSG
check_lastkmsg();
#endif /* CONFIG_LASTKMSG */
if (!strncmp("recovery", copybuf, 8))
{
/* check recovery kernel update */
mount(CONFIG_MTD_CP_DEVPATH, "/mnt/sd0", "evfat", 0, NULL);
nxsig_usleep(10000);
/* recovery kernel install from UPG.img */
install_recovery("/mnt/sd0/UPG.IMG");
load_kernel("recovery", CONFIG_MTD_RECOVERY_DEVPATH);
}
else
{
load_kernel("nuttx", CONFIG_MTD_KERNEL_DEVPATH);
}
/* not reached */
retur
```
<Overlap Ratio: 0.9819967266775778>

---

--- 225 --
Question ID: fcdb7bc8e4eeabc2f3b0e336c064bfce634c6e30_104
Original Code:
```
static TCGv rotate32_x(TCGv reg, TCGv shift, int left)
{
    TCGv_i64 t0, shift64;
    TCGv X, lo, hi, zero;

    shift64 = tcg_temp_new_i64();
    tcg_gen_extu_i32_i64(shift64, shift);

    t0 = tcg_temp_new_i64();

    X = tcg_temp_new();
    lo = tcg_temp_new();
    hi = tcg_temp_new();

    if (left) {
        /* create [reg:X:..] */

        tcg_gen_shli_i32(lo, QREG_CC_X, 31);
        tcg_gen_concat_i32_i64(t0, lo, reg);

        /* rotate */

        tcg_gen_rotl_i64(t0, t0, shift64);
        tcg_temp_free_i64(shift64);

        /* result is [reg:..:reg:X] */

        tcg_gen_extr_i64_i32(lo, hi, t0);
        tcg_gen_andi_i32(X, lo, 1);

        tcg_gen_shri_i32(lo, lo, 1);
    } else {
        /* create [..:X:reg] */

        tcg_gen_concat_i32_i64(t0, reg, QREG_CC_X);

        tcg_gen_rotr_i64(t0, t0, shift64);
        tcg_temp_free_i64(shift64);

        /* result is value: [X:reg:..:reg] */

        tcg_gen_extr_i64_i32(lo, hi, t0);

        /* extract X */

        tcg_gen_shri_i32(X, hi, 31);

        /* extract result */

        tcg_gen_shli_i32(hi, hi, 1);
    }
    tcg_temp_free_i64(t0);
    tcg_gen_or_i32(lo, lo, hi);
    tcg_temp_free(hi);

    /* if shift == 0, register and X are not affected */

    zero = tcg_const_i32(0);
    tcg_gen_movcond_i32(TCG_COND_EQ, X, shift, zero, QREG_CC_X, X);
    tcg_gen_movcond_i32(TCG_COND_EQ, reg, shift, zero, reg, lo);
    tcg_temp_free(zero);
    tcg_temp_free(lo);

    return X;
}
```


Overlapping Code:
```
t, int left)
{
TCGv_i64 t0, shift64;
TCGv X, lo, hi, zero;
shift64 = tcg_temp_new_i64();
tcg_gen_extu_i32_i64(shift64, shift);
t0 = tcg_temp_new_i64();
X = tcg_temp_new();
lo = tcg_temp_new();
hi = tcg_temp_new();
if (left) {
/* create [reg:X:..] */
tcg_gen_shli_i32(lo, QREG_CC_X, 31);
tcg_gen_concat_i32_i64(t0, lo, reg);
/* rotate */
tcg_gen_rotl_i64(t0, t0, shift64);
tcg_temp_free_i64(shift64);
/* result is [reg:..:reg:X] */
tcg_gen_extr_i64_i32(lo, hi, t0);
tcg_gen_andi_i32(X, lo, 1);
tcg_gen_shri_i32(lo, lo, 1);
} else {
/* create [..:X:reg] */
tcg_gen_concat_i32_i64(t0, reg, QREG_CC_X);
tcg_gen_rotr_i64(t0, t0, shift64);
tcg_temp_free_i64(shift64);
/* result is value: [X:reg:..:reg] */
tcg_gen_extr_i64_i32(lo, hi, t0);
/* extract X */
tcg_gen_shri_i32(X, hi, 31);
/* extract result */
tcg_gen_shli_i32(hi, hi, 1);
}
tcg_temp_free_i64(t0);
tcg_gen_or_i32(lo, lo, hi);
tcg_temp_free(hi);
/* if shift == 0, register and X are not affected */
zero = tcg_const_i32(0);
tcg_gen_movcond_i32(TCG_COND_EQ, X, shift, zero, QREG_CC_X, X);
tcg_gen_movcond_i32(TCG_COND_EQ, reg, shift, zero, reg, lo);
tcg_temp_free(zero);
tcg_temp_free(lo);
return
```
<Overlap Ratio: 0.960735171261487>

---

--- 226 --
Question ID: f5bc73ac391a05eb2f91b68d898b111d3a423233_1
Original Code:
```
int main(const int argc, const char* const argv[])
{
    if (argc != 3)
    {
        fprintf(stderr, "Usage:   %s <iface-name> <node-id>\n", argv[0]);
        fprintf(stderr, "Example: %s vcan0 42\n", argv[0]);
        return 1;
    }

    // Initialize the node with a static node-ID as specified in the command-line arguments.
    CanardInstance canard = canardInit(&canardAllocate, &canardFree);
    canard.mtu_bytes      = CANARD_MTU_CAN_CLASSIC;  // Do not use CAN FD to enhance compatibility.
    canard.node_id        = (CanardNodeID) atoi(argv[2]);

    // Initialize a SocketCAN socket. Do not use CAN FD to enhance compatibility.
    const SocketCANFD sock = socketcanOpen(argv[1], false);
    if (sock < 0)
    {
        fprintf(stderr, "Could not initialize the SocketCAN interface: errno %d %s\n", -sock, strerror(-sock));
        return 1;
    }

    CanardRxSubscription heartbeat_subscription;
    (void) canardRxSubscribe(&canard,   // Subscribe to messages uavcan.node.Heartbeat.
                         CanardTransferKindMessage,
                         HeartbeatSubjectID,  // The fixed Subject-ID of the Heartbeat message type (see DSDL definition).
                         7,      // The maximum payload size (max DSDL object size) from the DSDL definition.
                         CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,
                         &heartbeat_subscription);

    // // Configure the library to listen for register access service requests.
    // CanardRxSubscription srv_register_access;
    // (void) canardRxSubscribe(&canard,
    //                          CanardTransferKindRequest,
    //                          RegisterAccessServiceID,
    //                          1024U,  // Larger buffers are OK.
    //                          CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,
    //                          &srv_register_access);

    // The main loop: publish messages and process service requests.
    const time_t boot_ts     = time(NULL);
    time_t       next_1hz_at = boot_ts;
    while (true)
    {
        if (next_1hz_at < time(NULL))
        {
            next_1hz_at++;
            //* publishMeasurement(&canard);
            publishHeartbeat(&canard, time(NULL) - boot_ts);
        }

        // Transmit pending frames.
        const CanardFrame* txf = canardTxPeek(&canard);
        while (txf != NULL)
        {
            (void) socketcanPush(sock, txf, 0);  // Error handling not implemented
            canardTxPop(&canard);
            free((void*) txf);
            txf = canardTxPeek(&canard);
        }

        // Process received frames, if any.
        CanardFrame rxf;
        uint8_t     buffer[64];
        while (socketcanPop(sock, &rxf, sizeof(buffer), buffer, 1000) > 0)  // Error handling not implemented
        {
            CanardTransfer transfer;
            if (canardRxAccept(&canard, &rxf, 0, &transfer))
            {
                if ((transfer.transfer_kind == CanardTransferKindMessage) &&
                    (transfer.port_id == HeartbeatSubjectID))
                {
                    //handleRegisterAccess(&canard, &transfer);
                    handleHeartbeat();
                }
                free((void*) transfer.payload);
            }
        }
    }
}
```


Overlapping Code:
```
int main(const int argc, const char* const argv[])
{
if (argc != 3)
{
fprintf(stderr, "Usage: %s <iface-name> <node-id>\n", argv[0]);
fprintf(stderr, "Example: %s vcan0 42\n", argv[0]);
return 1;
}
// Initialize the node with a static node-ID as specified in the command-line arguments.
CanardInstance canard = canardInit(&canardAllocate, &canardFree);
canard.mtu_bytes = CANARD_MTU_CAN_CLASSIC; // Do not use CAN FD to enhance compatibility.
canard.node_id = (CanardNodeID) atoi(argv[2]);
// Initialize a SocketCAN socket. Do not use CAN FD to enhance compatibility.
const SocketCANFD sock = socketcanOpen(argv[1], false);
if (sock < 0)
{
fprintf(stderr, "Could not initialize the SocketCAN interface: errno %d %s\n", -sock, strerror(-sock));
return 1;
}
CanardRxSubscription heartbeat_subscription;
(void) canardRxSubscribe(&canard, // Subscribe to messages uavcan.node.Heartbeat.
CanardTransferKindMessage,
HeartbeatSubjectID, // The fixed Subject-ID of the Heartbeat message type (see DSDL definition).
7, // The maximum payload size (max DSDL object size) from the DSDL definition.
CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,
&heartbeat_subscription);
// // Configure the library to listen for register access service requests.
// CanardRxSubscription srv_register_access;
// (void) canardRxSubscribe(&canard,
// CanardTransferKindRequest,
// RegisterAccessServiceID,
// 1024U, // Larger buffers are OK.
// CANARD_DEFAULT_TRANSFER_ID_TIMEOUT_USEC,
// &srv_register_access);
// The main loop: publish messages and process service requests.
const time_t boot_ts = time(NULL);
time_t next_1hz_at = boot_ts;
while (true)
{
if (next_1hz_at < time(NULL))
{
next_1hz_at++;
//* publishMeasurement(&canard);
publishHeartbeat(&canard, time(NULL) - boot_ts);
}
// Transmit pending frames.
const CanardFrame* txf = canardTxPeek(&canard);
while (txf != NULL)
{
(void) socketcanPush(sock, txf, 0); // Error handling not implemented
canardTxPop(&ca
```
<Overlap Ratio: 0.9969088098918083>

---

--- 227 --
Question ID: 280de5037ca96adac96b488cc9abfc6238ce6428_2
Original Code:
```
CC_INLINE void cccfb_one_shot(const struct ccmode_cfb *mode,
                              size_t key_len, const void *key, const void *iv,
                              size_t nbytes, const void *in, void *out)
{
	cccfb_ctx_decl(mode->size, ctx);
	mode->init(mode, ctx, key_len, key, iv);
	mode->cfb(ctx, nbytes, in, out);
	cccfb_ctx_clear(mode->size, ctx);
}
```


Overlapping Code:
```
hot(const struct ccmode_cfb *mode,
size_t key_len, const void *key, const void *iv,
size_t nbytes, const void *in, void *out)
{
cccfb_ctx_decl(mode->size, ctx);
mode->init(mode, ctx, key_len, key, iv);
mode->cfb(ctx, nbytes, in, out);
cccfb_ctx_clear(mode->size, ctx)
```
<Overlap Ratio: 0.902027027027027>

---

--- 228 --
Question ID: dc3398105fa77730a8dbc123f8186620788c4fd9_6
Original Code:
```
ssize_t flextcp_connection_tx_alloc2(struct flextcp_connection *conn, size_t len,
    void **buf_1, size_t *len_1, void **buf_2)
{
  uint32_t avail, head;

  /* if outgoing connection has already been closed, abort */
  if ((conn->flags & CONN_FLAG_TXEOS) == CONN_FLAG_TXEOS)
    return -1;

  /* truncate if necessary */
  avail = conn_tx_allocbytes(conn);
  if (avail < len) {
    len = avail;
  }

  /* calculate alloc head */
  head = conn->txb_head + conn->txb_allocated;
  if (head >= conn->txb_len) {
    head -= conn->txb_len;
  }

  *buf_1 = conn->txb_base + head;

  /* short alloc if we wrap around */
  if (head + len > conn->txb_len) {
    *len_1 = conn->txb_len - head;
    *buf_2 = conn->txb_base;
  } else {
    *len_1 = len;
    *buf_2 = NULL;
  }

  /* bump head alloc counter */
  conn->txb_allocated += len;
  return len;
}
```


Overlapping Code:
```
xtcp_connection_tx_alloc2(struct flextcp_connection *conn, size_t len,
void **buf_1, size_t *len_1, void **buf_2)
{
uint32_t avail, head;
/* if outgoing connection has already been closed, abort */
if ((conn->flags & CONN_FLAG_TXEOS) == CONN_FLAG_TXEOS)
return -1;
/* truncate if necessary */
avail = conn_tx_allocbytes(conn);
if (avail < len) {
len = avail;
}
/* calculate alloc head */
head = conn->txb_head + conn->txb_allocated;
if (head >= conn->txb_len) {
head -= conn->txb_len;
}
*buf_1 = conn->txb_base + head;
/* short alloc if we wrap around */
if (head + len > conn->txb_len) {
*len_1 = conn->txb_len - head;
*buf_2 = conn->txb_base;
} else {
*len_1 = len;
*buf_2 = NULL;
}
/* bump head alloc counter */
conn->txb_allocated += len;
return len;
}
```
<Overlap Ratio: 0.9856584093872229>

---

--- 229 --
Question ID: b9e0a264652214a4043b49fcfba34f5fa8fa151d_0
Original Code:
```
int main() {
    float alturas = 0, altmaior = 0, altmenor;

    printf("informe sua altura em metros: \n");
    scanf("%f", &alturas);
    altmaior = alturas;
    altmenor = alturas;

    for(int i = 0; i < 14; i++) {
        printf("informe sua altura em metros: \n");
        scanf("%f", &alturas);
 
        if (alturas > altmaior) {
            altmaior = alturas;
        } else if (alturas < altmenor) {
            altmenor = alturas;
        }

    }

    printf("\nmaior altura: %.2f", altmaior);
    printf("\nmenor altura: %.2f", altmenor);

    return 0;
}
```


Overlapping Code:
```
lturas = 0, altmaior = 0, altmenor;
printf("informe sua altura em metros: \n");
scanf("%f", &alturas);
altmaior = alturas;
altmenor = alturas;
for(int i = 0; i < 14; i++) {
printf("informe sua altura em metros: \n");
scanf("%f", &alturas);

if (alturas > altmaior) {
altmaior = alturas;
} else if (alturas < altmenor) {
altmenor = alturas;
}
}
printf("\nmaior altura: %.2f", altmaior);
printf("\nmeno
```
<Overlap Ratio: 0.8714596949891068>

---

--- 230 --
Question ID: da14ea94c309af0d426d4281d083461816ca329b_35
Original Code:
```
static int
smb_set_proto_prop(sa_property_t prop)
{
	int ret = SA_OK;
	char *name;
	char *value;
	int index = -1;
	struct smb_proto_option_defs *opt;

	name = sa_get_property_attr(prop, "type");
	value = sa_get_property_attr(prop, "value");
	if (name != NULL && value != NULL) {
		index = findprotoopt(name);
		if (index >= 0) {
			/* should test for valid value */
			ret = smb_validate_proto_prop(index, name, value);
			if (ret == SA_OK) {
				opt = &smb_proto_options[index];

				/* Save to SMF */
				if (smb_config_set(opt->smb_index,
				    value) != 0) {
					ret = SA_BAD_VALUE;
					goto out;
				}
				/*
				 * Specialized refresh mechanisms can
				 * be flagged in the proto_options and
				 * processed here.
				 */
				if (opt->refresh & SMB_REFRESH_REFRESH)
					(void) smf_refresh_instance(
					    SMBD_DEFAULT_INSTANCE_FMRI);
				else if (opt->refresh & SMB_REFRESH_RESTART)
					(void) smf_restart_instance(
					    SMBD_DEFAULT_INSTANCE_FMRI);
			}
		}
	}

out:
	if (name != NULL)
		sa_free_attr_string(name);
	if (value != NULL)
		sa_free_attr_string(value);

	return (ret);
}
```


Overlapping Code:
```
_set_proto_prop(sa_property_t prop)
{
int ret = SA_OK;
char *name;
char *value;
int index = -1;
struct smb_proto_option_defs *opt;
name = sa_get_property_attr(prop, "type");
value = sa_get_property_attr(prop, "value");
if (name != NULL && value != NULL) {
index = findprotoopt(name);
if (index >= 0) {
/* should test for valid value */
ret = smb_validate_proto_prop(index, name, value);
if (ret == SA_OK) {
opt = &smb_proto_options[index];
/* Save to SMF */
if (smb_config_set(opt->smb_index,
value) != 0) {
ret = SA_BAD_VALUE;
goto out;
}
/*
* Specialized refresh mechanisms can
* be flagged in the proto_options and
* processed here.
*/
if (opt->refresh & SMB_REFRESH_REFRESH)
(void) smf_refresh_instance(
SMBD_DEFAULT_INSTANCE_FMRI);
else if (opt->refresh & SMB_REFRESH_RESTART)
(void) smf_restart_instance(
SMBD_DEFAULT_INSTANCE_FMRI);
}
}
}
out:
if (name != NULL)
sa_free_attr_string(name);
if (value != NULL)
sa_free_attr_string(value);
return 
```
<Overlap Ratio: 0.977366255144033>

---

--- 231 --
Question ID: eb55c2933692a1c28ed44679a2e7842474f0a34c_1
Original Code:
```
void cgetsizes_(MPI_Fint * ptrSize, MPI_Fint * intSize, MPI_Fint * aintSize)
{
    *ptrSize = (MPI_Fint) sizeof(void *);
    *intSize = (MPI_Fint) sizeof(MPI_Fint);
    *aintSize = (MPI_Fint) sizeof(MPI_Aint);
}
```


Overlapping Code:
```
id cgetsizes_(MPI_Fint * ptrSize, MPI_Fint * intSize, MPI_Fint * aintSize)
{
*ptrSize = (MPI_Fint) sizeof(void *);
*intSize = (MPI_Fint) sizeof(MPI_Fi
```
<Overlap Ratio: 0.7537688442211056>

---

--- 232 --
Question ID: 758d5111d4535b0cc34463ebad46877214b39809_1
Original Code:
```
static unsigned
hwloc__look_synthetic(struct hwloc_topology *topology,
		      struct hwloc_synthetic_backend_data_s *data,
		      int level, unsigned first_cpu,
		      hwloc_bitmap_t parent_cpuset)
{
  hwloc_obj_t obj;
  unsigned i;
  struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];
  hwloc_obj_type_t type = curlevel->type;

  /* pre-hooks */
  switch (type) {
    case HWLOC_OBJ_GROUP:
      break;
    case HWLOC_OBJ_SYSTEM:
    case HWLOC_OBJ_BRIDGE:
    case HWLOC_OBJ_PCI_DEVICE:
    case HWLOC_OBJ_OS_DEVICE:
      /* Shouldn't happen.  */
      abort();
      break;
    case HWLOC_OBJ_MACHINE:
      break;
    case HWLOC_OBJ_NODE:
      break;
    case HWLOC_OBJ_SOCKET:
      break;
    case HWLOC_OBJ_CACHE:
      break;
    case HWLOC_OBJ_CORE:
      break;
    case HWLOC_OBJ_PU:
      break;
    case HWLOC_OBJ_MISC:
    case HWLOC_OBJ_TYPE_MAX:
      /* Should never happen */
      assert(0);
      break;
  }

  obj = hwloc_alloc_setup_object(type, curlevel->next_os_index++);
  obj->cpuset = hwloc_bitmap_alloc();

  if (!curlevel->arity) {
    hwloc_bitmap_set(obj->cpuset, first_cpu++);
  } else {
    for (i = 0; i < curlevel->arity; i++)
      first_cpu = hwloc__look_synthetic(topology, data, level + 1, first_cpu, obj->cpuset);
  }

  if (type == HWLOC_OBJ_NODE) {
    obj->nodeset = hwloc_bitmap_alloc();
    hwloc_bitmap_set(obj->nodeset, obj->os_index);
  }

  hwloc_bitmap_or(parent_cpuset, parent_cpuset, obj->cpuset);

  /* post-hooks */
  switch (type) {
    case HWLOC_OBJ_GROUP:
      obj->attr->group.depth = curlevel->depth;
      break;
    case HWLOC_OBJ_SYSTEM:
    case HWLOC_OBJ_BRIDGE:
    case HWLOC_OBJ_PCI_DEVICE:
    case HWLOC_OBJ_OS_DEVICE:
      abort();
      break;
    case HWLOC_OBJ_MACHINE:
      break;
    case HWLOC_OBJ_NODE:
      /* 1GB in memory nodes, 256k 4k-pages.  */
      obj->memory.local_memory = 1024*1024*1024;
      obj->memory.page_types_len = 1;
      obj->memory.page_types = malloc(sizeof(*obj->memory.page_types));
      memset(obj->memory.page_types, 0, sizeof(*obj->memory.page_types));
      obj->memory.page_types[0].size = 4096;
      obj->memory.page_types[0].count = 256*1024;
      break;
    case HWLOC_OBJ_SOCKET:
      break;
    case HWLOC_OBJ_CACHE:
      obj->attr->cache.depth = curlevel->depth;
      obj->attr->cache.linesize = 64;
      obj->attr->cache.type = curlevel->cachetype;
      if (obj->attr->cache.depth == 1) {
	/* 32Kb in L1d */
	obj->attr->cache.size = 32*1024;
      } else {
	/* *4 at each level, starting from 1MB for L2, unified */
	obj->attr->cache.size = 256*1024 << (2*obj->attr->cache.depth);
      }
      break;
    case HWLOC_OBJ_CORE:
      break;
    case HWLOC_OBJ_PU:
      break;
    case HWLOC_OBJ_MISC:
    case HWLOC_OBJ_TYPE_MAX:
      /* Should never happen */
      assert(0);
      break;
  }

  hwloc_insert_object_by_cpuset(topology, obj);

  return first_cpu;
}
```


Overlapping Code:
```
c unsigned
hwloc__look_synthetic(struct hwloc_topology *topology,
struct hwloc_synthetic_backend_data_s *data,
int level, unsigned first_cpu,
hwloc_bitmap_t parent_cpuset)
{
hwloc_obj_t obj;
unsigned i;
struct hwloc_synthetic_level_data_s *curlevel = &data->level[level];
hwloc_obj_type_t type = curlevel->type;
/* pre-hooks */
switch (type) {
case HWLOC_OBJ_GROUP:
break;
case HWLOC_OBJ_SYSTEM:
case HWLOC_OBJ_BRIDGE:
case HWLOC_OBJ_PCI_DEVICE:
case HWLOC_OBJ_OS_DEVICE:
/* Shouldn't happen. */
abort();
break;
case HWLOC_OBJ_MACHINE:
break;
case HWLOC_OBJ_NODE:
break;
case HWLOC_OBJ_SOCKET:
break;
case HWLOC_OBJ_CACHE:
break;
case HWLOC_OBJ_CORE:
break;
case HWLOC_OBJ_PU:
break;
case HWLOC_OBJ_MISC:
case HWLOC_OBJ_TYPE_MAX:
/* Should never happen */
assert(0);
break;
}
obj = hwloc_alloc_setup_object(type, curlevel->next_os_index++);
obj->cpuset = hwloc_bitmap_alloc();
if (!curlevel->arity) {
hwloc_bitmap_set(obj->cpuset, first_cpu++);
} else {
for (i = 0; i < curlevel->arity; i++)
first_cpu = hwloc__look_synthetic(topology, data, level + 1, first_cpu, obj->cpuset);
}
if (type == HWLOC_OBJ_NODE) {
obj->nodeset = hwloc_bitmap_alloc();
hwloc_bitmap_set(obj->nodeset, obj->os_index);
}
hwloc_bitmap_or(parent_cpuset, parent_cpuset, obj->cpuset);
/* post-hooks */
switch (type) {
case HWLOC_OBJ_GROUP:
obj->attr->group.depth = curlevel->depth;
break;
case HWLOC_OBJ_SYSTEM:
case HWLOC_OBJ_BRIDGE:
case HWLOC_OBJ_PCI_DEVICE:
case HWLOC_OBJ_OS_DEVICE:
abort();
break;
case HWLOC_OBJ_MACHINE:
break;
case HWLOC_OBJ_NODE:
/* 1GB in memory nodes, 256k 4k-pages. */
obj->memory.local_memory = 1024*1024*1024;
obj->memory.page_types_len = 1;
obj->memory.page_types = malloc(sizeof(*obj->memory.page_types));
memset(obj->memory.page_types, 0, sizeof(*obj->memory.page_types));
obj->memory.page_types[0].size = 4096;
obj->memory.page_types[0].count = 256*1024;
break;
case HWLOC_OBJ_SOCKET:
break;
case HWLOC_OBJ_CACHE:
obj->attr->cache.depth = curlevel->depth;
obj->attr->cache.linesize = 64;
obj->attr->cache.type = curlevel->cachetype;
if (obj->attr->cache.depth == 1) {
/* 32Kb in L1d */
obj->attr->cache.size
```
<Overlap Ratio: 0.9924847346171912>

---

--- 233 --
Question ID: 666f437624b2d3c9cf6e20be2d5f3dfe3ec1aa44_9
Original Code:
```
int
kr4_change(struct ktable *kt, struct kroute_full *kl)
{
	struct kroute_node	*kr;
	int			 action = RTM_ADD;
	u_int16_t		 labelid;

	if ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,
	    RTP_BGP)) != NULL)
		action = RTM_CHANGE;

	/* nexthop within 127/8 -> ignore silently */
	if ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==
	    htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
		return (0);

	labelid = rtlabel_name2id(kl->label);

	/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */
	if (kl->flags & (F_BLACKHOLE|F_REJECT))
		kl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);

	if (action == RTM_ADD) {
		if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
			log_warn("kr_change");
			return (-1);
		}
		kr->r.prefix.s_addr = kl->prefix.v4.s_addr;
		kr->r.prefixlen = kl->prefixlen;
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		kr->r.flags = kl->flags | F_BGPD_INSERTED;
		kr->r.priority = RTP_BGP;
		kr->r.labelid = labelid;

		if (kroute_insert(kt, kr) == -1)
			free(kr);
	} else {
		kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
		rtlabel_unref(kr->r.labelid);
		kr->r.labelid = labelid;
		if (kl->flags & F_BLACKHOLE)
			kr->r.flags |= F_BLACKHOLE;
		else
			kr->r.flags &= ~F_BLACKHOLE;
		if (kl->flags & F_REJECT)
			kr->r.flags |= F_REJECT;
		else
			kr->r.flags &= ~F_REJECT;
	}

	if (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)
		return (-1);

	return (0);
}
```


Overlapping Code:
```
uct ktable *kt, struct kroute_full *kl)
{
struct kroute_node *kr;
int action = RTM_ADD;
u_int16_t labelid;
if ((kr = kroute_find(kt, kl->prefix.v4.s_addr, kl->prefixlen,
RTP_BGP)) != NULL)
action = RTM_CHANGE;
/* nexthop within 127/8 -> ignore silently */
if ((kl->nexthop.v4.s_addr & htonl(IN_CLASSA_NET)) ==
htonl(INADDR_LOOPBACK & IN_CLASSA_NET))
return (0);
labelid = rtlabel_name2id(kl->label);
/* for blackhole and reject routes nexthop needs to be 127.0.0.1 */
if (kl->flags & (F_BLACKHOLE|F_REJECT))
kl->nexthop.v4.s_addr = htonl(INADDR_LOOPBACK);
if (action == RTM_ADD) {
if ((kr = calloc(1, sizeof(struct kroute_node))) == NULL) {
log_warn("kr_change");
return (-1);
}
kr->r.prefix.s_addr = kl->prefix.v4.s_addr;
kr->r.prefixlen = kl->prefixlen;
kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
kr->r.flags = kl->flags | F_BGPD_INSERTED;
kr->r.priority = RTP_BGP;
kr->r.labelid = labelid;
if (kroute_insert(kt, kr) == -1)
free(kr);
} else {
kr->r.nexthop.s_addr = kl->nexthop.v4.s_addr;
rtlabel_unref(kr->r.labelid);
kr->r.labelid = labelid;
if (kl->flags & F_BLACKHOLE)
kr->r.flags |= F_BLACKHOLE;
else
kr->r.flags &= ~F_BLACKHOLE;
if (kl->flags & F_REJECT)
kr->r.flags |= F_REJECT;
else
kr->r.flags &= ~F_REJECT;
}
if (send_rtmsg(kr_state.fd, action, kt, &kr->r) == -1)
return (-1);
return (
```
<Overlap Ratio: 0.982615268329554>

---

--- 234 --
Question ID: ee72d55a9939b25def927ed0ead36a854248dff4_13
Original Code:
```
static inline void axp_read_adc(struct axp_charger *charger,
  struct axp_adc_res *adc)
{
	uint8_t tmp[8];
	adc->vac_res = 0;
	adc->iac_res = 0;
	adc->vusb_res = 0;
	adc->iusb_res = 0;
	
	axp_reads(charger->master,AXP22_VBATH_RES,6,tmp);
	adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
	adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
	adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
	axp_reads(charger->master,AXP22_OCVBATH_RES,2,tmp);
	adc->ocvbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
	axp_reads(charger->master,AXP22_VTS_RES,2,tmp);
	adc->ts_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
}
```


Overlapping Code:
```
 inline void axp_read_adc(struct axp_charger *charger,
struct axp_adc_res *adc)
{
uint8_t tmp[8];
adc->vac_res = 0;
adc->iac_res = 0;
adc->vusb_res = 0;
adc->iusb_res = 0;

axp_reads(charger->master,AXP22_VBATH_RES,6,tmp);
adc->vbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
adc->ichar_res = ((uint16_t) tmp[2] << 8 )| tmp[3];
adc->idischar_res = ((uint16_t) tmp[4] << 8 )| tmp[5];
axp_reads(charger->master,AXP22_OCVBATH_RES,2,tmp);
adc->ocvbat_res = ((uint16_t) tmp[0] << 8 )| tmp[1];
axp_reads(charger->master,AXP22_VTS_RES,2,tmp);
adc->ts
```
<Overlap Ratio: 0.9169491525423729>

---

--- 235 --
Question ID: cfc3d9f99406532a575bacff98edcc8060d2f49b_39
Original Code:
```
static int
ikev2_delete_tunnel_interface (vnet_main_t * vnm, ikev2_sa_t * sa,
			       ikev2_child_sa_t * child)
{
  ikev2_del_ipsec_tunnel_args_t a;

  clib_memset (&a, 0, sizeof (a));

  if (sa->is_initiator)
    {
      ip_address_to_46 (&sa->iaddr, &a.local_ip);
      ip_address_to_46 (&sa->raddr, &a.remote_ip);
    }
  else
    {
      ip_address_to_46 (&sa->raddr, &a.local_ip);
      ip_address_to_46 (&sa->iaddr, &a.remote_ip);
    }

  a.remote_sa_id = child->remote_sa_id;
  a.local_sa_id = child->local_sa_id;
  a.sw_if_index = (sa->is_tun_itf_set ? sa->tun_itf : ~0);

  vl_api_rpc_call_main_thread (ikev2_del_tunnel_from_main, (u8 *) & a,
			       sizeof (a));
  return 0;
}
```


Overlapping Code:
```
_delete_tunnel_interface (vnet_main_t * vnm, ikev2_sa_t * sa,
ikev2_child_sa_t * child)
{
ikev2_del_ipsec_tunnel_args_t a;
clib_memset (&a, 0, sizeof (a));
if (sa->is_initiator)
{
ip_address_to_46 (&sa->iaddr, &a.local_ip);
ip_address_to_46 (&sa->raddr, &a.remote_ip);
}
else
{
ip_address_to_46 (&sa->raddr, &a.local_ip);
ip_address_to_46 (&sa->iaddr, &a.remote_ip);
}
a.remote_sa_id = child->remote_sa_id;
a.local_sa_id = child->local_sa_id;
a.sw_if_index = (sa->is_tun_itf_set ? sa->tun_itf : ~0);
vl_api_rpc_call_main_thread (ikev2_del_tunnel_from
```
<Overlap Ratio: 0.90311986863711>

---

--- 236 --
Question ID: 343bc427b588bcc183b60d0def641cac76d52848_0
Original Code:
```
int main() 
   {     
   	//Variables
      int numGames = 36;
      int date[numGames][1];
      int AUscore[numGames][9];
      int oppScore[numGames][9];
      char oppName[NAMELEN], oppConf[4];
      int i, j, k, score1, score2;
      int secWin=0, secLoss=0, numWin=0, numLoss=0;
      char result;
      char year[4], college[10], sport[10];
      
   
      /*-----------------------------------------------------------
                        Open File
      -----------------------------------------------------------*/
   
      FILE *dataFile;
      dataFile = fopen(FILENAME, "r");//opens data file for reading
   
      if(dataFile == NULL)printf("error opening file \n");//makes sure data file exists
      else{
         fscanf(dataFile, "%s %s %s", year, college, sport);
         printf("		%s %s %s \n", year, college, sport);//prints the header
         printHeaders();   	//calls printHeader funcion
      	
         for(i=0;i<numGames;i++){//start for loops
         	//scans data file------------------------------------------------
            fscanf(dataFile, "%d %d %s %s", &date[i][0], &date[i][1],
               		oppConf, oppName);
            fscanf(dataFile, "%d %d %d %d %d %d %d %d %d %d",
               		&oppScore[i][0],&oppScore[i][1],&oppScore[i][2],&oppScore[i][3],
               		&oppScore[i][4],&oppScore[i][5],&oppScore[i][6],&oppScore[i][7],
               		&oppScore[i][8],&oppScore[i][9]);
            fscanf(dataFile, "%d %d %d %d %d %d %d %d %d %d",
               		&AUscore[i][0],&AUscore[i][1],&AUscore[i][2],&AUscore[i][3],
               		&AUscore[i][4],&AUscore[i][5],&AUscore[i][6],&AUscore[i][7],
               		&AUscore[i][8],&AUscore[i][9]);
         	//----------------------------------------------------------------
            score1 = 0;
            score2 = 0;
            for(j=0;j<10;j++){//calculates auburn and opponent scores and determines win/loss
               score1 += oppScore[i][j];
               score2 += AUscore[i][j];
            }
            if(score2<score1){
               result='L';
               numLoss+=1;
            }
            else if(score2>score1){
               result='W';
               numWin+=1;
            }
            else result='T';
         	
         
            printf("%02d/%02d	%19s		%02d-%02d 	%c \n", date[i][0], date[i][1],
               		oppName, score1, score2, result);//prints data
         }
         printf("Auburn Season Record: %02d-%02d \n", numWin, numLoss);      
      }
      return 0;
   }
```


Overlapping Code:
```
riables
int numGames = 36;
int date[numGames][1];
int AUscore[numGames][9];
int oppScore[numGames][9];
char oppName[NAMELEN], oppConf[4];
int i, j, k, score1, score2;
int secWin=0, secLoss=0, numWin=0, numLoss=0;
char result;
char year[4], college[10], sport[10];


/*-----------------------------------------------------------
Open File
-----------------------------------------------------------*/

FILE *dataFile;
dataFile = fopen(FILENAME, "r");//opens data file for reading

if(dataFile == NULL)printf("error opening file \n");//makes sure data file exists
else{
fscanf(dataFile, "%s %s %s", year, college, sport);
printf(" %s %s %s \n", year, college, sport);//prints the header
printHeaders(); //calls printHeader funcion

for(i=0;i<numGames;i++){//start for loops
//scans data file------------------------------------------------
fscanf(dataFile, "%d %d %s %s", &date[i][0], &date[i][1],
oppConf, oppName);
fscanf(dataFile, "%d %d %d %d %d %d %d %d %d %d",
&oppScore[i][0],&oppScore[i][1],&oppScore[i][2],&oppScore[i][3],
&oppScore[i][4],&oppScore[i][5],&oppScore[i][6],&oppScore[i][7],
&oppScore[i][8],&oppScore[i][9]);
fscanf(dataFile, "%d %d %d %d %d %d %d %d %d %d",
&AUscore[i][0],&AUscore[i][1],&AUscore[i][2],&AUscore[i][3],
&AUscore[i][4],&AUscore[i][5],&AUscore[i][6],&AUscore[i][7],
&AUscore[i][8],&AUscore[i][9]);
//----------------------------------------------------------------
score1 = 0;
score2 = 0;
for(j=0;j<10;j++){//calculates auburn and opponent scores and determines win/loss
score1 += oppScore[i][j];
score2 += AUscore[i][j];
}
if(score2<score1){
result='L';
numLoss+=1;
}
else if(score2>score1){
result='W';
numWin+=1;
}
else result='T';


printf("%02d/%02d %19s %02d-%02d %c \n", date[i][0], date[i][1],
oppName, score1, score2, result);//prints data
}
printf("Auburn
```
<Overlap Ratio: 0.96411355115158>

---

--- 237 --
Question ID: a7d23e95b9fb766067571c4bfbddd0a6d429ca85_8
Original Code:
```
comcryptReturn deComcryptData(
	comcryptObj 			cobj,
	unsigned char 			*cipherText,
	unsigned 				cipherTextLen,
	unsigned char 			*plainText,
	unsigned	 			*plainTextLen,	// IN/OUT
	comcryptEos 			endOfStream) 	// CCE_END_OF_STREAM, etc.

{
	comcryptPriv	*cpriv = (comcryptPriv *)cobj;
    unsigned char 	*outorigin = plainText;
	unsigned		ptextLen = *plainTextLen;
	unsigned		thisPtext;				// per block
	unsigned		blockSize;
	dcbReturn		drtn;
	unsigned 		ctextUsed;

	/*
	 * Snag version from ciphertext, or as much as we can get
	 */
	while((cpriv->versionBytes < VERSION_BYTES) && cipherTextLen) {
		cpriv->version <<= 8;
		cpriv->version |= *cipherText;
		cpriv->versionBytes++;
		cipherText++;
		cipherTextLen--;
	}

	/*
	 * Then skip over the remainder of the header (currently spares)
	 */
	if((cpriv->spareBytes < SPARE_BYTES) && cipherTextLen) {
		unsigned toSkip = SPARE_BYTES - cpriv->spareBytes;

		if(toSkip > cipherTextLen) {
			toSkip = cipherTextLen;
		}
		cpriv->spareBytes += toSkip;
		cipherText += toSkip;
		cipherTextLen -= toSkip;
	}

	if(cipherTextLen == 0) {
		*plainTextLen = 0;
		return CCR_SUCCESS;
	}

    if(cpriv->version != VERSION_3_Dec_97) {
    	ddprintf(("Incompatible version.\n"));
		return CCR_BAD_CIPHERTEXT;
    }

	while(cipherTextLen != 0) {

		/*
		 * Main loop. First deal with possible existing partial block.
		 */
		if(cpriv->cbuf.codeBufLength != 0) {
			unsigned toCopy =
				cpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength;
			unsigned origBufSize = cpriv->cbuf.codeBufLength;

			if(toCopy > cipherTextLen) {
				toCopy = cipherTextLen;
			}
			memmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,
				cipherText, toCopy);
			cpriv->cbuf.codeBufLength += toCopy;

			thisPtext = ptextLen;
			drtn = deComcryptBlock(cpriv,
				&cpriv->cbuf,
				cpriv->cbuf.codeBuf,
				cpriv->cbuf.codeBufLength,
				plainText,
				&thisPtext,
				endOfStream,
				&blockSize);
			switch(drtn) {
				case DCB_SHORT:
					/*
					 * Incomplete block in codeBuf
					 */
					if(endOfStream == CCE_END_OF_STREAM) {
						/*
						 * Caller thinks this is the end, but we need more
						 */
						ddprintf(("deComcryptData(): CCE_END_OF_STREAM, "
							"not end of block\n"));
						return CCR_BAD_CIPHERTEXT;
					}
					cipherTextLen -= toCopy;
					if(cipherTextLen != 0) {
						/*
						 * i.e., codeBuf overflow - could be s/w error? Do
						 * we need a bigger buffer?
						 */
						ddprintf(("deComcryptData: full codeBuf, incomplete "
							"block\n"));
						return CCR_BAD_CIPHERTEXT;
					}
					else {
						/*
						 * OK, stash it and try again
						 */
						scprintf(("====incomplete codeBuf, codeBufLength %d, "
							"cipherTextLen %d\n",
							cpriv->cbuf.codeBufLength, toCopy));
						break;		// out of main loop (after this switch)
					}

				case DCB_OUTBUFFER_TOO_SMALL:
					ddprintf(("codeBuf decomcrypt error short buf\n"));
					return CCR_OUTBUFFER_TOO_SMALL;
					
				case DCB_PARSE_ERROR:
				default:
					ddprintf(("codeBuf decomcrypt error (%d)\n", drtn));
					return CCR_BAD_CIPHERTEXT;

				case DCB_SUCCESS:
					/*
					 * ctextUsed is how much of caller's ciphertext we used
					 * in this buffered block
					 */
					ctextUsed = blockSize - origBufSize;
					scprintf(("====decrypted block in codeBuf, blockSize %d, "
						"ctextUsed %d, thisPtext %d\n",
						blockSize, ctextUsed, thisPtext));
					cipherText    += ctextUsed;
					cipherTextLen -= ctextUsed;
					plainText     += thisPtext;
					ptextLen      -= thisPtext;
					cpriv->cbuf.codeBufLength = 0;
					break;
			}

			/*
			 * We might have used up all of caller's cipherText processing
			 * codeBuf...
			 */
			if(cipherTextLen == 0) {
				break;				// out of main loop
			}

		}	/* buffered ciphertext in codeBuf */

		/*
		 * Snarf ciphertext, one block at a time.
		 */

		thisPtext = ptextLen;
		drtn = deComcryptBlock(cpriv,
			&cpriv->cbuf,
			cipherText,
			cipherTextLen,
			plainText,
			&thisPtext,
			endOfStream,
			&blockSize);
		switch(drtn) {
			case DCB_SHORT:
				/*
				 * Incomplete block
				 */
				if(endOfStream == CCE_END_OF_STREAM) {
					ddprintf(("deComcryptData(): CCE_END_OF_STREAM, not end of "
						"block (2)\n"));
					return CCR_BAD_CIPHERTEXT;
				}
				if(cipherTextLen >
				       (cpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength)) {
					ddprintf(("deComcryptData(): codeBuf overflow!\n"));
					return CCR_BAD_CIPHERTEXT;
				}
				memmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,
					cipherText, cipherTextLen);
				cpriv->cbuf.codeBufLength += cipherTextLen;
				cipherTextLen = 0;
				scprintf(("====Incomplete block, cipherTextLen %d "
					"codeBufLength %d\n", cipherTextLen,
					cpriv->cbuf.codeBufLength));
				break;		// actually out of main loop

		    case DCB_PARSE_ERROR:
			case DCB_OUTBUFFER_TOO_SMALL:
			default:
				return CCR_BAD_CIPHERTEXT;

			case DCB_SUCCESS:
				if(ptextLen < thisPtext) {
					/*
					 * Software error
					 */
					ddprintf(("deComcryptData: undetected ptext "
						"overflow (2)\n"));
					return CCR_BAD_CIPHERTEXT;
				}
				plainText     += thisPtext;
				ptextLen      -= thisPtext;
				cipherText    += blockSize;
				cipherTextLen -= blockSize;
				scprintf(("====decrypted one block, blockSize %d "
					"thisPtext %d\n", blockSize, thisPtext));
				break;
		}
	}	/* main loop */

	*plainTextLen = (unsigned)(plainText - outorigin);
	return CCR_SUCCESS;
}
```


Overlapping Code:
```
tReturn deComcryptData(
comcryptObj cobj,
unsigned char *cipherText,
unsigned cipherTextLen,
unsigned char *plainText,
unsigned *plainTextLen, // IN/OUT
comcryptEos endOfStream) // CCE_END_OF_STREAM, etc.
{
comcryptPriv *cpriv = (comcryptPriv *)cobj;
unsigned char *outorigin = plainText;
unsigned ptextLen = *plainTextLen;
unsigned thisPtext; // per block
unsigned blockSize;
dcbReturn drtn;
unsigned ctextUsed;
/*
* Snag version from ciphertext, or as much as we can get
*/
while((cpriv->versionBytes < VERSION_BYTES) && cipherTextLen) {
cpriv->version <<= 8;
cpriv->version |= *cipherText;
cpriv->versionBytes++;
cipherText++;
cipherTextLen--;
}
/*
* Then skip over the remainder of the header (currently spares)
*/
if((cpriv->spareBytes < SPARE_BYTES) && cipherTextLen) {
unsigned toSkip = SPARE_BYTES - cpriv->spareBytes;
if(toSkip > cipherTextLen) {
toSkip = cipherTextLen;
}
cpriv->spareBytes += toSkip;
cipherText += toSkip;
cipherTextLen -= toSkip;
}
if(cipherTextLen == 0) {
*plainTextLen = 0;
return CCR_SUCCESS;
}
if(cpriv->version != VERSION_3_Dec_97) {
ddprintf(("Incompatible version.\n"));
return CCR_BAD_CIPHERTEXT;
}
while(cipherTextLen != 0) {
/*
* Main loop. First deal with possible existing partial block.
*/
if(cpriv->cbuf.codeBufLength != 0) {
unsigned toCopy =
cpriv->cbuf.codeBufSize - cpriv->cbuf.codeBufLength;
unsigned origBufSize = cpriv->cbuf.codeBufLength;
if(toCopy > cipherTextLen) {
toCopy = cipherTextLen;
}
memmove(cpriv->cbuf.codeBuf + cpriv->cbuf.codeBufLength,
cipherText, toCopy);
cpriv->cbuf.codeBufLength += toCopy;
thisPtext = ptextLen;
drtn = deComcryptBlock(cpriv,
&cpriv->cbuf,
cpriv->cbuf.codeBuf,
cpriv->cbuf.codeBufLength,
plainText,
&thisPtext,
endOfStream,
&blockSize);
switch(drtn) {
case DCB_SHORT:
/*
* Incomplete block in codeBuf
*/
if(endOfStream == CCE_END_OF_STREAM) {
/*
* Caller thinks this is the end, but we need more
*/
ddprintf(("deComcryptData(): CCE_END_OF_STREAM, "
"not end of block\n"));
return CCR_BAD_CIPHERTEXT;
}
cipherTextLen -= toCopy;
if(cipherTextLen != 0) {
/*
* i.e., codeBuf overflow - could be s/w error? Do
* we need a bigger buffer?
*/
ddprintf(("deComcrypt
```
<Overlap Ratio: 0.9803113553113553>

---

--- 238 --
Question ID: 00369752948b63109d26daceef125f2106a6a0a1_1
Original Code:
```
char *
url_decode(char *str, int max, const char *stopchars, int unsafe, int *is_utf8) {
	char *ptr = str;
	int len = strlen(str);
	char *end = str + (max >= 0 ? max : len);
	int trailing = 0;
	int minuch = 0, uch = 0;

	if (is_utf8)
		*is_utf8 = 1;

	while (*ptr && ptr < end && (!stopchars || !strchr(stopchars, *ptr))) {
		if (*ptr == '%' && isxdigit(*(ptr + 1)) && isxdigit(*(ptr + 2))) {
			int a = *(unsigned char*)(ptr + 1);
			int b = *(unsigned char*)(ptr + 2);

			if (a <= '9')
				a -= '0';
			else if (a <= 'F')
				a -= 'A' - 10;
			else
				a -= 'a' - 10;
			if (b <= '9')
				b -= '0';
			else if (b <= 'F')
				b -= 'A' - 10;
			else
				b -= 'a' - 10;
			*ptr = a * 16 + b;
			if (!unsafe) {
				if (*ptr == '\t')
					*ptr = ' ';
				else if (*(unsigned char*)ptr < ' ') /* Extra safety check. */
					*ptr = '?';
			}
			memmove(ptr + 1, ptr + 3, str + len - (ptr + 3) + 1);
			end -= 2;
			len -= 2;
		} else if (*ptr == '+') {
			*ptr = ' ';
		}
		if (is_utf8 && *is_utf8) {
			if ((*ptr & 0x80) == 0) {
				if (trailing > 0)
					*is_utf8 = 0;
			} else if ((*ptr & 0xC0) == 0x80) {
				uch = uch << 6 | (*ptr & 0x3F);
				if (--trailing < 0)
					*is_utf8 = 0;
				else if (trailing == 0 && uch < minuch)
					*is_utf8 = 0;
			} else if (trailing > 0) {
				*is_utf8 = 0;
			} else if ((*ptr & 0xE0) == 0xC0) {
				trailing = 1;
				minuch = 0x80;
				uch = *ptr & 0x1F;
			} else if ((*ptr & 0xF0) == 0xE0) {
				trailing = 2;
				minuch = 0x800;
				uch = *ptr & 0x1F;
			} else if ((*ptr & 0xF8) == 0xF0) {
				trailing = 3;
				minuch = 0x10000;
				uch = *ptr & 0x1F;
			} else {
				*is_utf8 = 0;
			}
		}
		ptr++;
	}
	if (is_utf8 && trailing > 0)
		*is_utf8 = 0;
	return ptr;
}
```


Overlapping Code:
```
int max, const char *stopchars, int unsafe, int *is_utf8) {
char *ptr = str;
int len = strlen(str);
char *end = str + (max >= 0 ? max : len);
int trailing = 0;
int minuch = 0, uch = 0;
if (is_utf8)
*is_utf8 = 1;
while (*ptr && ptr < end && (!stopchars || !strchr(stopchars, *ptr))) {
if (*ptr == '%' && isxdigit(*(ptr + 1)) && isxdigit(*(ptr + 2))) {
int a = *(unsigned char*)(ptr + 1);
int b = *(unsigned char*)(ptr + 2);
if (a <= '9')
a -= '0';
else if (a <= 'F')
a -= 'A' - 10;
else
a -= 'a' - 10;
if (b <= '9')
b -= '0';
else if (b <= 'F')
b -= 'A' - 10;
else
b -= 'a' - 10;
*ptr = a * 16 + b;
if (!unsafe) {
if (*ptr == '\t')
*ptr = ' ';
else if (*(unsigned char*)ptr < ' ') /* Extra safety check. */
*ptr = '?';
}
memmove(ptr + 1, ptr + 3, str + len - (ptr + 3) + 1);
end -= 2;
len -= 2;
} else if (*ptr == '+') {
*ptr = ' ';
}
if (is_utf8 && *is_utf8) {
if ((*ptr & 0x80) == 0) {
if (trailing > 0)
*is_utf8 = 0;
} else if ((*ptr & 0xC0) == 0x80) {
uch = uch << 6 | (*ptr & 0x3F);
if (--trailing < 0)
*is_utf8 = 0;
else if (trailing == 0 && uch < minuch)
*is_utf8 = 0;
} else if (trailing > 0) {
*is_utf8 = 0;
} else if ((*ptr & 0xE0) == 0xC0) {
trailing = 1;
minuch = 0x80;
uch = *ptr & 0x1F;
} else if ((*ptr & 0xF0) == 0xE0) {
trailing = 2;
minuch = 0x800;
uch = *ptr & 0x1F;
} else if ((*ptr & 0xF8) == 0xF0) {
trailing = 3;
minuch = 0x10000;
uch = *ptr & 0x1F;
} else {
*is_utf8 = 0;
}
}
ptr++;
}
if (is_utf8 && trailing > 0)
*is_utf8 = 0;
r
```
<Overlap Ratio: 0.9725385130609511>

---

--- 239 --
Question ID: d63fb502ae1c98a24619f5720717602367a2559e_3
Original Code:
```
__attribute__((noinline, section(".printf_lite")))
#endif
static void output_utf8_string_as_utf8(const char* s, PrintfParams* printfParams)
{
	if ( !s ) return;
//#if PRINTF_LITE_STRING_WIDTH_SPECIFIER_SUPPORT == 1
//  size_t len = lengt
//#endif
	if ( printfParams->precision_specifier >= 0 ) {
    while ( *s && printfParams->precision_specifier-- ) print_utf8_char(*s++, printfParams);
  }
	else
  {
    while ( *s ) print_utf8_char(*s++, printfParams);
  }
}
```


Overlapping Code:
```
ction(".printf_lite")))
#endif
static void output_utf8_string_as_utf8(const char* s, PrintfParams* printfParams)
{
if ( !s ) return;
//#if PRINTF_LITE_STRING_WIDTH_SPECIFIER_SUPPORT == 1
// size_t len = lengt
//#endif
if ( printfParams->precision_specifier >= 0 ) {
while ( *s && printfParams->precision_specifier-- ) print_utf8_char(*s++, printfParams);
}
else
{
while ( *s ) print_utf8_char(*s++, p
```
<Overlap Ratio: 0.9009009009009009>

---

--- 240 --
Question ID: b2f805c40ddbf09f4f7419f63459b02e2d4289c5_78
Original Code:
```
JNICALL Java_com_gams_api_gevm_TerminateClear(JNIEnv *env, jobject obj)
{
   jfieldID fid;
   u64_t pgev;
   jclass cls = (*env)->GetObjectClass(env, obj);
   fid = (*env)->GetFieldID(env, cls, "gevPtr", "J");
   if (fid == NULL) return ;
   pgev.i = (*env)->GetLongField(env, obj, fid);
   gevTerminateClear((gevHandle_t)pgev.p);
}
```


Overlapping Code:
```
Java_com_gams_api_gevm_TerminateClear(JNIEnv *env, jobject obj)
{
jfieldID fid;
u64_t pgev;
jclass cls = (*env)->GetObjectClass(env, obj);
fid = (*env)->GetFieldID(env, cls, "gevPtr", "J");
if (fid == NULL) return ;
pgev.i = (*env)->GetLongField(env, obj, fid);
gevT
```
<Overlap Ratio: 0.8553054662379421>

---

--- 241 --
Question ID: 7f497e2a2ff47035706db774f54a963cff35afae_1
Original Code:
```
static void insert(WrenVM* vm)
{
  wrenSetSlotNewMap(vm, 0);
  
  wrenEnsureSlots(vm, 3);

  // Insert String
  wrenSetSlotString(vm, 1, "England");
  wrenSetSlotString(vm, 2, "London");
  wrenSetMapValue(vm, 0, 1, 2);

  // Insert Double
  wrenSetSlotDouble(vm, 1, 1.0);
  wrenSetSlotDouble(vm, 2, 42.0);
  wrenSetMapValue(vm, 0, 1, 2);

  // Insert Boolean
  wrenSetSlotBool(vm, 1, false);
  wrenSetSlotBool(vm, 2, true);
  wrenSetMapValue(vm, 0, 1, 2);

  // Insert Null
  wrenSetSlotNull(vm, 1);
  wrenSetSlotNull(vm, 2);
  wrenSetMapValue(vm, 0, 1, 2);

  // Insert List
  wrenSetSlotString(vm, 1, "Empty");
  wrenSetSlotNewList(vm, 2);
  wrenSetMapValue(vm, 0, 1, 2);
}
```


Overlapping Code:
```
SlotNewMap(vm, 0);

wrenEnsureSlots(vm, 3);
// Insert String
wrenSetSlotString(vm, 1, "England");
wrenSetSlotString(vm, 2, "London");
wrenSetMapValue(vm, 0, 1, 2);
// Insert Double
wrenSetSlotDouble(vm, 1, 1.0);
wrenSetSlotDouble(vm, 2, 42.0);
wrenSetMapValue(vm, 0, 1, 2);
// Insert Boolean
wrenSetSlotBool(vm, 1, false);
wrenSetSlotBool(vm, 2, true);
wrenSetMapValue(vm, 0, 1, 2);
// Insert Null
wrenSetSlotNull(vm, 1);
wrenSetSlotNull(vm, 2);
wrenSetMapValue(vm, 0, 1, 2);
// Insert List
wrenSetSlotString(vm, 1, "Empty");
wrenSetSlotNewList(vm, 2
```
<Overlap Ratio: 0.8814102564102564>

---

--- 242 --
Question ID: 32901f0a423a48495156542c305b873a4ed53a48_2
Original Code:
```
void printText(int x, int y, int col, int backcol, int fill, char *format, ...)
{
	int x1, y1, i;
	u32 data;
	u16 *line16 = NULL;
	u32 *line32 = NULL;
	u8 *font;
	u8 ch = 0;
	char buf[128] = {""};
	int pitch = vscreen->width*bpp/8;
	va_list arglist;
		va_start(arglist, format);
		vsprintf(buf, format, arglist);
		va_end(arglist);

	for(i=0; i<sizeof(buf); i++)
	{
		ch = buf[i];
		// mapping
		if (ch<0x20) ch = 0;
		else if (ch<0x80) { ch -= 0x20; }
		else if (ch<0xa0) {	ch = 0;	}
		else ch -= 0x40;
		font = (u8 *)&hankaku_font10[ch*10];
		// draw
		if (bpp == 16) line16 = (u16*)(vscreen->data + x*2 + y * pitch);
		else           line32 = (u32*)(vscreen->data + x*4 + y * pitch);

		for (y1=0; y1<10; y1++)
		{
			data = *font++;
			for (x1=0; x1<5; x1++)
			{
				if (data & 1)
				{
					if (bpp == 16) *line16 = col;
				    else           *line32 = col;
				}
				else if (fill)
				{
					if (bpp == 16) *line16 = backcol;
					else           *line32 = backcol;
				}

				if (bpp == 16) line16++;
				else           line32++;

				data = data >> 1;
			}
			if (bpp == 16) line16 += pitch/2-5;
			else           line32 += pitch/4-5;
		}
		x+=5;
	}
}
```


Overlapping Code:
```
x, int y, int col, int backcol, int fill, char *format, ...)
{
int x1, y1, i;
u32 data;
u16 *line16 = NULL;
u32 *line32 = NULL;
u8 *font;
u8 ch = 0;
char buf[128] = {""};
int pitch = vscreen->width*bpp/8;
va_list arglist;
va_start(arglist, format);
vsprintf(buf, format, arglist);
va_end(arglist);
for(i=0; i<sizeof(buf); i++)
{
ch = buf[i];
// mapping
if (ch<0x20) ch = 0;
else if (ch<0x80) { ch -= 0x20; }
else if (ch<0xa0) { ch = 0; }
else ch -= 0x40;
font = (u8 *)&hankaku_font10[ch*10];
// draw
if (bpp == 16) line16 = (u16*)(vscreen->data + x*2 + y * pitch);
else line32 = (u32*)(vscreen->data + x*4 + y * pitch);
for (y1=0; y1<10; y1++)
{
data = *font++;
for (x1=0; x1<5; x1++)
{
if (data & 1)
{
if (bpp == 16) *line16 = col;
else *line32 = col;
}
else if (fill)
{
if (bpp == 16) *line16 = backcol;
else *line32 = backcol;
}
if (bpp == 16) line16++;
else line32++;
data = data >> 1;
}
if (bpp == 16) line16 += pitch/2-5;
else line32 += pitch/4
```
<Overlap Ratio: 0.9654471544715447>

---

--- 243 --
Question ID: 64d1fd4f5e87a11389b6af0ce3aa7f36cc0292d0_49
Original Code:
```
static IRAtom* scalarShift ( MCEnv*  mce,
                             IRType  ty,
                             IROp    original_op,
                             IRAtom* qaa, IRAtom* qbb, 
                             IRAtom* aa,  IRAtom* bb )
{
   tl_assert(isShadowAtom(mce,qaa));
   tl_assert(isShadowAtom(mce,qbb));
   tl_assert(isOriginalAtom(mce,aa));
   tl_assert(isOriginalAtom(mce,bb));
   tl_assert(sameKindedAtoms(qaa,aa));
   tl_assert(sameKindedAtoms(qbb,bb));
   return 
      assignNew(
         'V', mce, ty,
         mkUifU( mce, ty,
                 assignNew('V', mce, ty, binop(original_op, qaa, bb)),
                 mkPCastTo(mce, ty, qbb)
         )
   );
}
```


Overlapping Code:
```
ic IRAtom* scalarShift ( MCEnv* mce,
IRType ty,
IROp original_op,
IRAtom* qaa, IRAtom* qbb, 
IRAtom* aa, IRAtom* bb )
{
tl_assert(isShadowAtom(mce,qaa));
tl_assert(isShadowAtom(mce,qbb));
tl_assert(isOriginalAtom(mce,aa));
tl_assert(isOriginalAtom(mce,bb));
tl_assert(sameKindedAtoms(qaa,aa));
tl_assert(sameKindedAtoms(qbb,bb));
return 
assignNew(
'V', mce, ty,
mkUifU( mce, ty,
assignNew('V', mce, ty, binop(original_op, qaa, bb)),
mkPCastTo(mce, t
```
<Overlap Ratio: 0.9615384615384616>

---

--- 244 --
Question ID: 9a86d84be1c9dbf9ce396b6cbead3ec86654727c_12
Original Code:
```
static bool enter_wizard_mode(void)
{
    /* Ask first time - unless resurrecting a dead character */
    if (!(p_ptr->noscore & 0x0008) && !p_ptr->is_dead)
    {
        /* Explanation */
        msg_print("You can only enter wizard mode from within debug mode.");

        return (FALSE);
    }

    /* Mark savefile */
    p_ptr->noscore |= 0x0002;

    /* Success */
    return (TRUE);
}
```


Overlapping Code:
```
)
{
/* Ask first time - unless resurrecting a dead character */
if (!(p_ptr->noscore & 0x0008) && !p_ptr->is_dead)
{
/* Explanation */
msg_print("You can only enter wizard mode from within debug mode.");
return (FALSE);
}
/* Mark savefile */
p_ptr->noscore |= 0x0002;
/* Su
```
<Overlap Ratio: 0.822289156626506>

---

--- 245 --
Question ID: 239ad18e913a08e3f4fd80633f4e02102294ebc9_1
Original Code:
```
static ERL_NIF_TERM
nifile_dir_alloc(ErlNifEnv* env, DIR* dp)
{
    nifile_dir_t* res;
    ERL_NIF_TERM ret;

    res = enif_alloc_resource(DIR_RES, sizeof(nifile_dir_t));
    if(res == NULL) {
        return enif_make_badarg(env);
    }

    ret = enif_make_resource(env, res);
    enif_release_resource(res);

    res->dp = dp;
    res->closed = 0;

    return enif_make_tuple2(env, ATOM_OK, ret);
}
```


Overlapping Code:
```
ERL_NIF_TERM
nifile_dir_alloc(ErlNifEnv* env, DIR* dp)
{
nifile_dir_t* res;
ERL_NIF_TERM ret;
res = enif_alloc_resource(DIR_RES, sizeof(nifile_dir_t));
if(res == NULL) {
return enif_make_badarg(env);
}
ret = enif_make_resource(env, res);
enif_release_resource(res);
res->dp = dp;
res->closed = 0;
return enif_make_tuple2(env, ATOM_OK,
```
<Overlap Ratio: 0.9570200573065902>

---

--- 246 --
Question ID: 837d3cb4a8053195e0a2c840183a1938eac444e4_0
Original Code:
```
static char *get_timestamp(char *buf, int len, time_t cur_time)
{
    struct tm tm_time;

    localtime_r(&cur_time, &tm_time);

    snprintf(buf, len, "%d-%d-%d %d:%d:%d",
             1900 + tm_time.tm_year, 1 + tm_time.tm_mon,
             tm_time.tm_mday, tm_time.tm_hour,
             tm_time.tm_min, tm_time.tm_sec);
    return buf;
}
```


Overlapping Code:
```
tic char *get_timestamp(char *buf, int len, time_t cur_time)
{
struct tm tm_time;
localtime_r(&cur_time, &tm_time);
snprintf(buf, len, "%d-%d-%d %d:%d:%d",
1900 + tm_time.tm_year, 1 + tm_time.tm_mon,
tm_time.tm_mday, tm_time.tm_hour,
tm_time.tm_min, tm_time.tm_sec)
```
<Overlap Ratio: 0.9363957597173145>

---

--- 247 --
Question ID: 0c39d2babffaf5506c0e82b034edaf4d3d75908b_5
Original Code:
```
unsigned char crc8 (char *str, size_t len) {
	char div = 0b10001100; // Rotated poly
	unsigned char crc = 0;

	size_t i;
	for (i = 0; i < len; i++) {
		unsigned char byte = str[i];

		int j;
		for (j = 0; j < 8; j++) {

			// Shift CRC
			char crc_carry = crc & 1;
			crc >>= 1;

			// Shift Byte
			char byte_carry = byte & 1;
			byte >>= 1;

			// If crc_carry XOR byte_carry we make crc XOR div
			if (crc_carry ^ byte_carry)
				crc ^= div;
		}

	}

	return crc;
}
```


Overlapping Code:
```
ze_t len) {
char div = 0b10001100; // Rotated poly
unsigned char crc = 0;
size_t i;
for (i = 0; i < len; i++) {
unsigned char byte = str[i];
int j;
for (j = 0; j < 8; j++) {
// Shift CRC
char crc_carry = crc & 1;
crc >>= 1;
// Shift Byte
char byte_carry = byte & 1;
byte >>= 1;
// If crc_carry XOR byte_carry we make crc XOR div
if (crc_carry ^ byte_carry)
crc ^=
```
<Overlap Ratio: 0.8663484486873508>

---

--- 248 --
Question ID: 2aa84529daa413c2344df0004d8d515385a80494_84
Original Code:
```
int func_162(int iParam0)
{
	int iVar0;
	
	iVar0 = (iParam0 - Local_388[0 /*8*/]);
	if (iVar0 >= 0 && iVar0 < Local_388)
	{
		if (Local_388[iVar0 /*8*/] == iParam0)
		{
			if (!Local_388[iVar0 /*8*/].f_2)
			{
				return 1;
			}
		}
		else if (Local_388[iVar0 /*8*/] != 0)
		{
		}
	}
	else
	{
		return 1;
	}
	return 0;
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 249 --
Question ID: d6c816db65cc0685dfa02a5dddf42c1d2954ed7d_31
Original Code:
```
static int pt_blk_proceed_to_exec_mode(struct pt_block_decoder *decoder,
				       struct pt_block *block,
				       const struct pt_event *ev)
{
	int status;

	if (!decoder || !ev)
		return -pte_internal;

	/* Apply the event immediately if we don't have an IP. */
	if (ev->ip_suppressed)
		return 1;

	status = pt_blk_proceed_to_ip_with_trace(decoder, block,
						 ev->variant.exec_mode.ip);
	if (status < 0)
		return status;

	/* We may have reached the IP. */
	return (decoder->ip == ev->variant.exec_mode.ip ? 1 : 0);
}
```


Overlapping Code:
```
t_blk_proceed_to_exec_mode(struct pt_block_decoder *decoder,
struct pt_block *block,
const struct pt_event *ev)
{
int status;
if (!decoder || !ev)
return -pte_internal;
/* Apply the event immediately if we don't have an IP. */
if (ev->ip_suppressed)
return 1;
status = pt_blk_proceed_to_ip_with_trace(decoder, block,
ev->variant.exec_mode.ip);
if (status < 0)
return status;
/* We may have reached the IP. */
return (decoder->ip == ev->variant.exec_m
```
<Overlap Ratio: 0.9375>

---

--- 250 --
Question ID: bd4c0e28cc54a0d726aef7db2bf7bba1e4101444_5
Original Code:
```
class NumberParserTest : public IntlTest {
  public:
    void testBasic();
    void testLocaleFi();
    void testSeriesMatcher();
    void testCombinedCurrencyMatcher();
    void testAffixPatternMatcher();
    void testGroupingDisabled();
    void testCaseFolding();
    void test20360_BidiOverflow();
    void testInfiniteRecursion();

    void runIndexedTest(int32_t index, UBool exec, const char *&name, char *par = 0);
}
```


Overlapping Code:
```
ass NumberParserTest : public IntlTest {
public:
void testBasic();
void testLocaleFi();
void testSeriesMatcher();
void testCombinedCurrencyMatcher();
void testAffixPatternMatcher();
void testGroupingDisabled();
void testCaseFolding();
void test20360_BidiOverflow();
void testInfiniteRecursion();
void runIndexedTest(int32_t index, UBool exec, const char *&name, char *par = 
```
<Overlap Ratio: 0.9816272965879265>

---

--- 251 --
Question ID: b4ad7da439415ff02c885c05a4892f4e0a3817c2_0
Original Code:
```
void read_all(int* input_fds, int count) {
    //  ,        ""           -  
    //      :       .
    //    .
    log_printf("Nonblock realisation start\n");
    for (int i = 0; i < count; ++i) {
        fcntl(input_fds[i], F_SETFL, fcntl(input_fds[i], F_GETFL) | O_NONBLOCK); //    
    }
    bool all_closed = false;
    while (!all_closed) {
        all_closed = true;
        for (int i = 0; i < count; ++i) { //     
            if (input_fds[i] == -1) {
                continue;
            }
            all_closed = false;
            char buf[100];
            int read_bytes = 0;
            //       ,    
            while ((read_bytes = read(input_fds[i], buf, sizeof(buf))) > 0) {
                buf[read_bytes] = '\0';
                log_printf("Read from %d subprocess: %s", i, buf);
            }
            if (read_bytes == 0) { //    
                close(input_fds[i]);
                input_fds[i] = -1;
            } else {
                conditional_handle_error(errno != EAGAIN, "strange error"); //    (+ ,   )
            }
        }
    }
    log_printf("Nonblock realisation finish\n");
}
```


Overlapping Code:
```
d read_all(int* input_fds, int count) {
//  ,        ""           -  
//      :       .
//    .
log_printf("Nonblock realisation start\n");
for (int i = 0; i < count; ++i) {
fcntl(input_fds[i], F_SETFL, fcntl(input_fds[i], F_GETFL) | O_NONBLOCK); //    
}
bool all_closed = false;
while (!all_closed) {
all_closed = true;
for (int i = 0; i < count; ++i) { //     
if (input_fds[i] == -1) {
continue;
}
all_closed = false;
char buf[100];
int read_bytes = 0;
//       ,    
while ((read_bytes = read(input_fds[i], buf, sizeof(buf))) > 0) {
buf[read_bytes] = '\0';
log_printf("Read from %d subprocess: %s", i, buf);
}
if (read_bytes == 0) { //    
close(input_fds[i]);
input_fds[i] = -1;
} else {
conditional_handle_error(errno != EAGAIN, "strange error"); //    (+ ,   )
}
}
}
log_printf("Nonblock realisation finish
```
<Overlap Ratio: 0.9919093851132686>

---

--- 252 --
Question ID: 9ed20a286e3b1f61ff31c766fd661db123ed0677_8
Original Code:
```
void keyboard_destroy_notify(struct wl_listener *listener, void *data) {
	struct sample_keyboard *keyboard = wl_container_of(listener, keyboard, destroy);
	wl_list_remove(&keyboard->destroy.link);
	wl_list_remove(&keyboard->key.link);
	free(keyboard);
}
```


Overlapping Code:
```
eyboard_destroy_notify(struct wl_listener *listener, void *data) {
struct sample_keyboard *keyboard = wl_container_of(listener, keyboard, destroy);
wl_list_remove(&keyboard->destroy.link);
wl_list_remove(&keyboard->key.link);
free(keyboard);
```
<Overlap Ratio: 0.9678714859437751>

---

--- 253 --
Question ID: 859b313cc12dfef3c76e74bf45abca23ec8cdf29_1
Original Code:
```
static void CALLBACK vertexCallback(GLvoid *vertex)
{
    GLdouble *ptr;
    ptr = (GLdouble *) vertex;
    glVertex3dv((GLdouble *) ptr);

}
```


Overlapping Code:
```
*vertex)
{
GLdouble *ptr;
ptr = (GLdouble *) verte
```
<Overlap Ratio: 0.390625>

---

--- 254 --
Question ID: b9ca93b7c8eb05ec4998809e45317f426e69eb4b_4
Original Code:
```
cbuffer InternalPerMaterialCB : register(b12)
{
    MaterialData gMaterial;
    MaterialData gTemporalMaterial;
    float gTemporalLODThreshold;
    bool gEnableTemporalNormalMaps;
    bool gDebugTemporalMaterial;
}
```


Overlapping Code:
```
ialCB : register(b12)
{
MaterialData gMaterial;
MaterialData gTemporalMaterial;
float gTemporalLODThreshold;
bool gEnableTemporalNormalMaps;
bool gDeb
```
<Overlap Ratio: 0.7692307692307693>

---

--- 255 --
Question ID: 7ff099f728f281015b97759ac593b329cc5b64ec_9
Original Code:
```
static void call_process_timeout(void *user_ctx, const belle_sip_timeout_event_t *event) {
	SalOp* op=(SalOp*)user_ctx;

	if (op->state==SalOpStateTerminated) return;

	if (!op->dialog)  {
		/*call terminated very early*/
		sal_error_info_set(&op->error_info,SalReasonRequestTimeout,408,"Request timeout",NULL);
		op->base.root->callbacks.call_failure(op);
		op->state = SalOpStateTerminating;
		call_set_released(op);
	} else {
		/*dialog will terminated shortly, nothing to do*/
	}
}
```


Overlapping Code:
```
s_timeout(void *user_ctx, const belle_sip_timeout_event_t *event) {
SalOp* op=(SalOp*)user_ctx;
if (op->state==SalOpStateTerminated) return;
if (!op->dialog) {
/*call terminated very early*/
sal_error_info_set(&op->error_info,SalReasonRequestTimeout,408,"Request timeout",NULL);
op->base.root->callbacks.call_failure(op);
op->state = SalOpStateTerminating;
call_set_released(op);
} else {
/*dialog will terminated shortly, n
```
<Overlap Ratio: 0.9118279569892473>

---

--- 256 --
Question ID: c80166036ca4a5f4835df09a291bfb814ca3395b_0
Original Code:
```
bool Input_is_firing(Input* input) {
  bool res;
  if (input->fire && input->count >= 10) {
    input->count = 0;
    res = true;
  } else {
    input->count++;
    res = false;
  }

  return res;
}
```


Overlapping Code:
```
l Input_is_firing(Input* input) {
bool res;
if (input->fire && input->count >= 10) {
input->count = 0;
res = true;
} else {
input->count++;
res = fals
```
<Overlap Ratio: 0.8771929824561403>

---

--- 257 --
Question ID: aaa16267ae708db7b48234ffed3233b49850824c_3
Original Code:
```
static int32_t
import_int32(struct import_stream *is) {
	if (is->size < 4) {
		luaL_error(is->alloc->L, "Invalid import stream (%d)",is->current_id);
	}
	uint8_t b[4];
	b[0] = (uint8_t)*(is->stream);
	b[1] = (uint8_t)*(is->stream+1);
	b[2] = (uint8_t)*(is->stream+2);
	b[3] = (uint8_t)*(is->stream+3);
	is->stream += 4;
	is->size -= 4;

	return (int32_t)(b[0] | (uint32_t)b[1]<<8 | (uint32_t)b[2]<<16 | (uint32_t)b[3]<<24);
}
```


Overlapping Code:
```
_int32(struct import_stream *is) {
if (is->size < 4) {
luaL_error(is->alloc->L, "Invalid import stream (%d)",is->current_id);
}
uint8_t b[4];
b[0] = (uint8_t)*(is->stream);
b[1] = (uint8_t)*(is->stream+1);
b[2] = (uint8_t)*(is->stream+2);
b[3] = (uint8_t)*(is->stream+3);
is->stream += 4;
is->size -= 4;
return (int32_t)(b[0] | (uint32_t)b[1]<<8 | (uint32_t)b[2]<<16 | (uint32_t)b[3]<<24);
```
<Overlap Ratio: 0.9441747572815534>

---

--- 258 --
Question ID: 664ab3d9944e9680c85ec4185224d31e1d2f8447_3
Original Code:
```
void
thread_rele(kthread_t *t)
{
	kproject_t *kpj;

	thread_lock(t);

	ASSERT(t == curthread || t->t_state == TS_FREE || t->t_procp == &p0);
	kpj = ttoproj(t);
	t->t_proj = proj0p;

	thread_unlock(t);

	if (kpj != proj0p) {
		project_rele(kpj);
		(void) project_hold(proj0p);
	}
}
```


Overlapping Code:
```
ad_rele(kthread_t *t)
{
kproject_t *kpj;
thread_lock(t);
ASSERT(t == curthread || t->t_state == TS_FREE || t->t_procp == &p0);
kpj = ttoproj(t);
t->t_proj = proj0p;
thread_unlock(t);
if (kpj != proj0p) {
project_rele(kpj);
(void) project_hold(proj0p)
```
<Overlap Ratio: 0.946969696969697>

---

--- 259 --
Question ID: 5850b41508fd68eac17ec0a66dab6627912fa136_2
Original Code:
```
deBool qpXmlWriter_startDocument (qpXmlWriter* writer)
{
	DE_ASSERT(writer && !writer->xmlIsWriting);
	writer->xmlIsWriting			= DE_TRUE;
	writer->xmlElementDepth			= 0;
	writer->xmlPrevIsStartElement	= DE_FALSE;
	fprintf(writer->outputFile, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
	return DE_TRUE;
}
```


Overlapping Code:
```
ter* writer)
{
DE_ASSERT(writer && !writer->xmlIsWriting);
writer->xmlIsWriting = DE_TRUE;
writer->xmlElementDepth = 0;
writer->xmlPrevIsStartElement = DE_FALSE;
fprintf(writer->outputFile, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
return DE_T
```
<Overlap Ratio: 0.8389261744966443>

---

--- 260 --
Question ID: 5724301122cb54e4eae26eaf08a8671f977aabb9_0
Original Code:
```
int fatorPrimo (int n) {
  int i = 3, j = 0;
  int maior = 0;
  int fator = 0;
  int aux = n;

  while (j < n) {
    if (aux % 2 == 0) {
      aux -= aux / 2;
      fator = 2;
    } else if (aux % i == 0) {
      aux -= aux / i;
      fator = i;
    } else {
      i++;
    }

    if (fator > maior) { maior = fator; };
    
    j++;
  }

  return maior;
}
```


Overlapping Code:
```
= 3, j = 0;
int maior = 0;
int fator = 0;
int aux = n;
while (j < n) {
if (aux % 2 == 0) {
aux -= aux / 2;
fator = 2;
} else if (aux % i == 0) {
aux -= aux / i;
fator = i;
} else {
i++;
}
if (fator > maior) { maior = fator; };

j++;
}
return maior;
}
```
<Overlap Ratio: 0.8896797153024911>

---

--- 261 --
Question ID: eeb9ff89363502562ee900b382830e7a4f5bb3b3_0
Original Code:
```
static ssize_t afs_file_write(struct file *file, const char *buf, size_t size, loff_t *off)
{
	afs_vnode_t *vnode;

	vnode = AFS_FS_I(file->f_dentry->d_inode);
	if (vnode->flags & AFS_VNODE_DELETED)
		return -ESTALE;

	return -EIO;
}
```


Overlapping Code:
```
file_write(struct file *file, const char *buf, size_t size, loff_t *off)
{
afs_vnode_t *vnode;
vnode = AFS_FS_I(file->f_dentry->d_inode);
if (vnode->flags & AFS_VNODE_DELETED)
return -ESTALE;
return -EIO;

```
<Overlap Ratio: 0.9111111111111111>

---

--- 262 --
Question ID: 4e0226aa37ae496e3bd8fa8850b38037fe2a3804_57
Original Code:
```
ssize_t echo_mini_isp_debug_rx_fps_info(const char *cmd_buf)
{
	size_t errcode = ERR_SUCCESS;
	int ret;
	u8 param[2];
	char cmd_name[20];

	misp_info("%s S", __func__);
	ret = sscanf(cmd_buf, "%19s %hhu %hhu", cmd_name, &param[0], &param[1]);
	if (ret != 3) {
		errcode = -EINVAL;
		return errcode;
	}

	if (param[0] == 0) {
		misp_info("rx_fps_info initial!");
		errcode = mini_isp_debug_mipi_rx_fps_start(param[1]);
	} else if (param[0] == 1) {
		misp_info("rx_fps_info exit!");
		mini_isp_debug_mipi_rx_fps_stop();
	}

	misp_info("%s E", __func__);
	return errcode;
}
```


Overlapping Code:
```
const char *cmd_buf)
{
size_t errcode = ERR_SUCCESS;
int ret;
u8 param[2];
char cmd_name[20];
misp_info("%s S", __func__);
ret = sscanf(cmd_buf, "%19s %hhu %hhu", cmd_name, &param[0], &param[1]);
if (ret != 3) {
errcode = -EINVAL;
return errcode;
}
if (param[0] == 0) {
misp_info("rx_fps_info initial!");
errcode = mini_isp_debug_mipi_rx_fps_start(param[1]);
} else if (param[0] == 1) {
misp_info("rx_fps_info exit!");
mini_isp_debug_mipi_rx_fps_stop();
}
misp_info("%s E", __func__);
return errcode;
```
<Overlap Ratio: 0.922509225092251>

---

--- 263 --
Question ID: 472fb8f44988ea74a4be6b12bbb4191b7ce2d28e_344
Original Code:
```
static int tolua_MathLuaAPI_Plane_new02(lua_State* tolua_S)
{
 tolua_Error tolua_err;
 if (
 !tolua_isusertable(tolua_S,1,"Plane",0,&tolua_err) ||
 (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Vector3",0,&tolua_err)) ||
 (tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Vector3",0,&tolua_err)) ||
 (tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Vector3",0,&tolua_err)) ||
 !tolua_isnoobj(tolua_S,5,&tolua_err)
 )
 goto tolua_lerror;
 else
 {
  const Vector3* v0 = ((const Vector3*)  tolua_tousertype(tolua_S,2,0));
  const Vector3* v1 = ((const Vector3*)  tolua_tousertype(tolua_S,3,0));
  const Vector3* v2 = ((const Vector3*)  tolua_tousertype(tolua_S,4,0));
 {
  Plane* tolua_ret = (Plane*)  Mtolua_new((Plane)(*v0,*v1,*v2));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,"Plane");
 }
 }
 return 1;
tolua_lerror:
 return tolua_MathLuaAPI_Plane_new01(tolua_S);
}
```


Overlapping Code:
```
e_new02(lua_State* tolua_S)
{
tolua_Error tolua_err;
if (
!tolua_isusertable(tolua_S,1,"Plane",0,&tolua_err) ||
(tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const Vector3",0,&tolua_err)) ||
(tolua_isvaluenil(tolua_S,3,&tolua_err) || !tolua_isusertype(tolua_S,3,"const Vector3",0,&tolua_err)) ||
(tolua_isvaluenil(tolua_S,4,&tolua_err) || !tolua_isusertype(tolua_S,4,"const Vector3",0,&tolua_err)) ||
!tolua_isnoobj(tolua_S,5,&tolua_err)
)
goto tolua_lerror;
else
{
const Vector3* v0 = ((const Vector3*) tolua_tousertype(tolua_S,2,0));
const Vector3* v1 = ((const Vector3*) tolua_tousertype(tolua_S,3,0));
const Vector3* v2 = ((const Vector3*) tolua_tousertype(tolua_S,4,0));
{
Plane* tolua_ret = (Plane*) Mtolua_new((Plane)(*v0,*v1,*v2));
tolua_pushusertype(tolua_S,(void*)tolua_ret,"Plane");
}
}
return 1;
tolua_lerror:
return tolua_MathLuaAPI_
```
<Overlap Ratio: 0.9406688241639698>

---

--- 264 --
Question ID: 35762ddd01ef86d2437846d5c8ca1a2414c3ab6f_268
Original Code:
```
SYX_FUNC_PRIMITIVE(Gtk_g_value_take_object)
{
  GValue *arg1 = (GValue *) 0 ;
  gpointer arg2 = (gpointer) 0 ;
  SyxOop result_oop;
  
  SWIG_FIRST_SELF(arg1, GValue *, es->message_receiver)
  SWIG_FIRST_SELF(arg2, gpointer, es->message_arguments[0])
  g_value_take_object(arg1,arg2);
  SWIG_APPEND_VALUE (es->message_receiver);
  SYX_PRIM_RETURN (result_oop);
}
```


Overlapping Code:
```
g_value_take_object)
{
GValue *arg1 = (GValue *) 0 ;
gpointer arg2 = (gpointer) 0 ;
SyxOop result_oop;

SWIG_FIRST_SELF(arg1, GValue *, es->message_receiver)
SWIG_FIRST_SELF(arg2, gpointer, es->message_arguments[0])
g_value_take_object(arg1,arg2);
SWIG_APPEND_VALUE (es->message_receiver);
SYX_PRIM_RETURN (result_oop);
}
```
<Overlap Ratio: 0.9331395348837209>

---

--- 265 --
Question ID: d5b4bbe878551602dda1d80746b70529175cb6ca_153
Original Code:
```
int kf7_get_subrec(
   struct fcb *f, 
   level0_pntr *p,      // IN - the original pointer from get_ptr
   int offset,                 // IN - offset of data to get within the rec 
   int bytes_to_read,          // IN - how many bytes of the rec to get
   unsigned char *rec,         // IN-OUT - where to put the bytes from the rec
   int *bytes_actually_read,   // OUT - how many bytes were actually transferred
   int max_lc)                 // IN - max bytes to transfer
{size_t size; FILE *file;

  if ( check_fcb(f) ) {
    *bytes_actually_read = bytes_to_read;
    if ( *bytes_actually_read>max_lc ) {
      f->error_code = longrec_err; *bytes_actually_read = max_lc;
    }
    if ( p->lc<=f->data_in_index_lc ) {
      if ( (unsigned)offset+bytes_to_read>=f->data_in_index_lc ) {
        f->error_code = longrec_err; *bytes_actually_read = f->data_in_index_lc - offset - 1;
      }
      memcpy(rec,(unsigned char *)(&p->data_rec)+offset,(size_t) *bytes_actually_read);
    }
    else {
      file = file_index(f,p->segment);
      if ( f->error_code!=no_err ) return(f->error_code);
      if ( fseeko(file,(FILE_OFFSET)p->sc+offset,0)!=0 ) {
        f->error_code = seek_err; return(f->error_code);
      }
      size = fread(rec,(size_t) 1,(size_t) *bytes_actually_read,file);
      if ( size!=(size_t)*bytes_actually_read ) f->error_code = read_err;
    }
  }
  return(f->error_code);
}
```


Overlapping Code:
```
int kf7_get_subrec(
struct fcb *f, 
level0_pntr *p, // IN - the original pointer from get_ptr
int offset, // IN - offset of data to get within the rec 
int bytes_to_read, // IN - how many bytes of the rec to get
unsigned char *rec, // IN-OUT - where to put the bytes from the rec
int *bytes_actually_read, // OUT - how many bytes were actually transferred
int max_lc) // IN - max bytes to transfer
{size_t size; FILE *file;
if ( check_fcb(f) ) {
*bytes_actually_read = bytes_to_read;
if ( *bytes_actually_read>max_lc ) {
f->error_code = longrec_err; *bytes_actually_read = max_lc;
}
if ( p->lc<=f->data_in_index_lc ) {
if ( (unsigned)offset+bytes_to_read>=f->data_in_index_lc ) {
f->error_code = longrec_err; *bytes_actually_read = f->data_in_index_lc - offset - 1;
}
memcpy(rec,(unsigned char *)(&p->data_rec)+offset,(size_t) *bytes_actually_read);
}
else {
file = file_index(f,p->segment);
if ( f->error_code!=no_err ) return(f->error_code);
if ( fseeko(file,(FILE_OFFSET)p->sc+offset,0)!=0 ) {
f->error_code = seek_err; return(f->error_code);
}
size = fread(rec,(size_t) 1,(size_t) *bytes_actually_read,file);
if ( size!=(size_t)*bytes_actually_read ) f->error_code = read_err;
}
}
return(f->error
```
<Overlap Ratio: 0.9925558312655087>

---

--- 266 --
Question ID: 30480f7d6b71d9ce9c0c7cca3186590550a7bfea_75
Original Code:
```
static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,
			  u8 *data, int data_len)
{
	struct get_set_mib m;
	m.type = type;
	m.size = data_len;
	m.index = index;

	if (data_len > MIB_MAX_DATA_BYTES)
		printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);

	atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
	atmel_copy_to_host(priv->dev, data,
			   atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), data_len);
}
```


Overlapping Code:
```
 void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,
u8 *data, int data_len)
{
struct get_set_mib m;
m.type = type;
m.size = data_len;
m.index = index;
if (data_len > MIB_MAX_DATA_BYTES)
printk(KERN_ALERT "%s: MIB buffer too small.\n", priv->dev->name);
atmel_send_command_wait(priv, CMD_Get_MIB_Vars, &m, MIB_HEADER_SIZE + data_len);
atmel_copy_to_host(priv->dev, data,
atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET + MIB_HEADER_SIZE), da
```
<Overlap Ratio: 0.9656652360515021>

---

--- 267 --
Question ID: 349717e826ff54c6ca00b37383ef9728c57acef9_4
Original Code:
```
static void SearchBySubject(libraryDB lib, strings subject)
{
	int i, j;
	int mathchFlag = 0;
	strings tmp;

	subject = ConvertToLowerCase(subject);
	for (i = 0; i < lib->nbook + 1; i++) {
		for (j = 0; lib->book[i]->subjectheading[j] != NULL; j++) {
			tmp = lib->book[i]->subjectheading[j];
			tmp = ConvertToLowerCase(tmp);
			if (StringsEqual(tmp, subject)) {
				mathchFlag = 1;
				printf("Books:\n");
				printf("Title: %s\n", lib->book[i]->title);
				printf("First Author: %s\n", lib->book[i]->authors[0]);
				printf("ISBN: %s\n", lib->book[i]->ISBN);
			}
		}
		printf("\n");
	}
	if (mathchFlag == 0) {
		printf("Sorry, No match items.\n");
	}
}
```


Overlapping Code:
```
void SearchBySubject(libraryDB lib, strings subject)
{
int i, j;
int mathchFlag = 0;
strings tmp;
subject = ConvertToLowerCase(subject);
for (i = 0; i < lib->nbook + 1; i++) {
for (j = 0; lib->book[i]->subjectheading[j] != NULL; j++) {
tmp = lib->book[i]->subjectheading[j];
tmp = ConvertToLowerCase(tmp);
if (StringsEqual(tmp, subject)) {
mathchFlag = 1;
printf("Books:\n");
printf("Title: %s\n", lib->book[i]->title);
printf("First Author: %s\n", lib->book[i]->authors[0]);
printf("ISBN: %s\n", lib->book[i]->ISBN);
}
}
printf("\n");
}
if (mathchFlag == 0) {
printf("Sorry, No match items.\n");
}
}
```
<Overlap Ratio: 0.9884678747940692>

---

--- 268 --
Question ID: 04ce6bf890e68854ff25af435d8af9c8742827ff_44
Original Code:
```
GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
{
    GuestMemoryBlockList *head, **link;
    Error *local_err = NULL;
    struct dirent *de;
    DIR *dp;

    head = NULL;
    link = &head;

    dp = opendir("/sys/devices/system/memory/");
    if (!dp) {
        /* it's ok if this happens to be a system that doesn't expose
         * memory blocks via sysfs, but otherwise we should report
         * an error
         */
        if (errno != ENOENT) {
            error_setg_errno(errp, errno, "Can't open directory"
                             "\"/sys/devices/system/memory/\"\n");
        }
        return NULL;
    }

    /* Note: the phys_index of memory block may be discontinuous,
     * this is because a memblk is the unit of the Sparse Memory design, which
     * allows discontinuous memory ranges (ex. NUMA), so here we should
     * traverse the memory block directory.
     */
    while ((de = readdir(dp)) != NULL) {
        GuestMemoryBlock *mem_blk;
        GuestMemoryBlockList *entry;

        if ((strncmp(de->d_name, "memory", 6) != 0) ||
            !(de->d_type & DT_DIR)) {
            continue;
        }

        mem_blk = g_malloc0(sizeof *mem_blk);
        /* The d_name is "memoryXXX",  phys_index is block id, same as XXX */
        mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);
        mem_blk->has_can_offline = true; /* lolspeak ftw */
        transfer_memory_block(mem_blk, true, NULL, &local_err);

        entry = g_malloc0(sizeof *entry);
        entry->value = mem_blk;

        *link = entry;
        link = &entry->next;
    }

    closedir(dp);
    if (local_err == NULL) {
        /* there's no guest with zero memory blocks */
        if (head == NULL) {
            error_setg(errp, "guest reported zero memory blocks!");
        }
        return head;
    }

    qapi_free_GuestMemoryBlockList(head);
    error_propagate(errp, local_err);
    return NULL;
}
```


Overlapping Code:
```
tMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
{
GuestMemoryBlockList *head, **link;
Error *local_err = NULL;
struct dirent *de;
DIR *dp;
head = NULL;
link = &head;
dp = opendir("/sys/devices/system/memory/");
if (!dp) {
/* it's ok if this happens to be a system that doesn't expose
* memory blocks via sysfs, but otherwise we should report
* an error
*/
if (errno != ENOENT) {
error_setg_errno(errp, errno, "Can't open directory"
"\"/sys/devices/system/memory/\"\n");
}
return NULL;
}
/* Note: the phys_index of memory block may be discontinuous,
* this is because a memblk is the unit of the Sparse Memory design, which
* allows discontinuous memory ranges (ex. NUMA), so here we should
* traverse the memory block directory.
*/
while ((de = readdir(dp)) != NULL) {
GuestMemoryBlock *mem_blk;
GuestMemoryBlockList *entry;
if ((strncmp(de->d_name, "memory", 6) != 0) ||
!(de->d_type & DT_DIR)) {
continue;
}
mem_blk = g_malloc0(sizeof *mem_blk);
/* The d_name is "memoryXXX", phys_index is block id, same as XXX */
mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);
mem_blk->has_can_offline = true; /* lolspeak ftw */
transfer_memory_block(mem_blk, true, NULL, &local_err);
entry = g_malloc0(sizeof *entry);
entry->value = mem_blk;
*link = entry;
link = &entry->next;
}
closedir(dp);
if (local_err == NULL) {
/* there's no guest with zero memory blocks */
if (head == NULL) {
error_setg(errp, "guest reported zero memory blocks!");
}
return head;
}
qapi_free_GuestMemoryBlockList(head);
error_propagate(errp, local
```
<Overlap Ratio: 0.9839640795381654>

---

--- 269 --
Question ID: aaf0de2dc4f840dc4c8c310c02b14d1cbc3c8bfc_0
Original Code:
```
static char		*do_if_ok(t_byte len, int n)
{
	char	sign;
	char	*res;

	while (n / power_ten(len) / 10 != 0)
		len++;
	sign = n < 0 ? -1 : 1;
	len = len + (sign == -1 ? 1 : 0) + 1;
	res = (char*)malloc(sizeof(char) * (len + 1));
	if (res == 0)
		return (0);
	res[len] = '\0';
	while (n != 0)
	{
		res[len - 1] = n % 10 * (sign == -1 ? -1 : 1) + '0';
		n = n / 10;
		len--;
	}
	res[0] = sign == -1 ? '-' : res[0];
	return (res);
}
```


Overlapping Code:
```
 int n)
{
char sign;
char *res;
while (n / power_ten(len) / 10 != 0)
len++;
sign = n < 0 ? -1 : 1;
len = len + (sign == -1 ? 1 : 0) + 1;
res = (char*)malloc(sizeof(char) * (len + 1));
if (res == 0)
return (0);
res[len] = '\0';
while (n != 0)
{
res[len - 1] = n % 10 * (sign == -1 ? -1 : 1) + '0';
n = n / 10;
len--;
}
res[0] = sign == -1 ? '-' : res[
```
<Overlap Ratio: 0.8706467661691543>

---

--- 270 --
Question ID: e7d2d626f920c604b9fc332ac5afc949a1b0fc12_5
Original Code:
```
BOOL xmlfsm_next_sibling(XmlNodeTraverser *data) {
	data->node.data = data->buffer.data;
	if (xmlfsm_skip_node(&data->buffer, 0) == XMLPARSE_SUCCESS) {
		data->node.end = data->buffer.data;
		data->node_start = data->node.data;
		xmlfsm_node_name(&data->node, &data->node_name);
		return TRUE;
	}
	return FALSE;
}
```


Overlapping Code:
```
 xmlfsm_next_sibling(XmlNodeTraverser *data) {
data->node.data = data->buffer.data;
if (xmlfsm_skip_node(&data->buffer, 0) == XMLPARSE_SUCCESS) {
data->node.end = data->buffer.data;
data->node_start = data->node.data;
xmlfsm_node_name(&data->node, &d
```
<Overlap Ratio: 0.8305647840531561>

---

--- 271 --
Question ID: 1d71bfe7f5b4a1b7dce1b0e2e989c53e5ea799cd_0
Original Code:
```
void mMult(Mat4 *m1, Mat4 m2) {
	int c, r, k;
	Mat4 m3;
	for(r = 0; r < 4; r ++) {
		for(c = 0; c < 4; c ++) {
			float sum = 0;
			for(k = 0; k < 4; k ++) {
				sum += m1->at[r][k] * m2.at[k][c];
			}
			m3.at[r][c] = sum;
		}
	}
	for(c = 0; c < 16; c ++) m1->values[c] = m3.values[c];
}
```


Overlapping Code:
```
m2) {
int c, r, k;
Mat4 m3;
for(r = 0; r < 4; r ++) {
for(c = 0; c < 4; c ++) {
float sum = 0;
for(k = 0; k < 4; k ++) {
sum += m1->at[r][k] * m2.at[k][c];
}
m3.at[r][c] = sum;
}
}
for(c = 0; c < 16; 
```
<Overlap Ratio: 0.7604562737642585>

---

--- 272 --
Question ID: 55017723786741a9a1ad1507250dc56d6e0d81ae_4
Original Code:
```
void
set_nacm_write_dflt(test_nacm_cfg_t *nacm_config, const char *action)
{
    struct lyd_node *node = NULL;

    node = lyd_new_path(nacm_config->root, nacm_config->ly_ctx, "/ietf-netconf-acm:nacm/write-default",
            (void *)action, 0, LYD_PATH_OPT_UPDATE);
    assert_non_null(node);

    if (NULL == nacm_config->root) {
        nacm_config->root = node;
    }
}
```


Overlapping Code:
```
m_write_dflt(test_nacm_cfg_t *nacm_config, const char *action)
{
struct lyd_node *node = NULL;
node = lyd_new_path(nacm_config->root, nacm_config->ly_ctx, "/ietf-netconf-acm:nacm/write-default",
(void *)action, 0, LYD_PATH_OPT_UPDATE);
assert_non_null(node);
if (NULL == nacm_config->root) {
nacm_config->root = node;
}
```
<Overlap Ratio: 0.9579579579579579>

---

--- 273 --
Question ID: 803bb58fe6266250b26f2b835bd1d643a7bb3d58_8
Original Code:
```
static CONST gattServiceCBs_t *gattServApp_FindServiceCBs( uint16 handle )
{
  serviceCBsList_t *pLoop = serviceCBsList;

  while ( pLoop != NULL )
  {
    if ( pLoop->serviceInfo.handle == handle )
    {
      return ( pLoop->serviceInfo.pCBs );
    }

    // Try next service
    pLoop = pLoop->next;
  }

  return ( (gattServiceCBs_t *)NULL );
}
```


Overlapping Code:
```
attServApp_FindServiceCBs( uint16 handle )
{
serviceCBsList_t *pLoop = serviceCBsList;
while ( pLoop != NULL )
{
if ( pLoop->serviceInfo.handle == handle )
{
return ( pLoop->serviceInfo.pCBs );
}
// Try next service
pLoop = pLoop->next;
}
return ( (g
```
<Overlap Ratio: 0.8090614886731392>

---

--- 274 --
Question ID: efc3a9a0a6ec20999862748f064948346cd9b2cd_3
Original Code:
```
END_TEST

START_TEST(test_bst_remove){
    bst_t *t;
    bst_initialize(&t,int_constructor,int_destructor,int_comparator);
    int i;
    for(i=0;i<N;i++){
        bst_insert(t,&v[i]);
    }
    for(i=0;i<N;i++){
        ck_assert(bst_find(t,&v[i]));
        bst_remove(t,&v[i]);
    }
    ck_assert(t->root==NULL);
    bst_delete(&t);
}
```


Overlapping Code:
```
_TEST
START_TEST(test_bst_remove){
bst_t *t;
bst_initialize(&t,int_constructor,int_destructor,int_comparator);
int i;
for(i=0;i<N;i++){
bst_insert(t,&v[i]);
}
for(i=0;i<N;i++){
ck_assert(bst_find(t,&v[i]));
bst_remove(t,&v[i]);
}
ck_assert(t->root==N
```
<Overlap Ratio: 0.9057971014492754>

---

--- 275 --
Question ID: f01ca4334d91ec12f1dee3990b3b7e2fa93bb0fc_28
Original Code:
```
static void abov_tk_dual_detection_mode(struct abov_tk_info *info, int mode)
{
	u8 cmd;
	int ret;

	if (info->fw_ver < ABOV_DUAL_DETECTION_CMD_FW_VER) {
		info->dual_mode = false;
		return;
	}

	dev_info(&info->client->dev,
			"%s: %s\n", __func__, mode ? "on" : "off");

	if (mode)
		cmd = CMD_DUAL_DETECT;
	else
		cmd = CMD_SINGLE_DETECT;

	ret = abov_tk_i2c_write(info->client, ABOV_DUAL_DETECT, &cmd, 1);
	if (ret < 0)
		dev_err(&info->client->dev,
			"%s %d : fail %d\n", __func__, __LINE__, ret);

	info->dual_mode = !!mode;
}
```


Overlapping Code:
```
void abov_tk_dual_detection_mode(struct abov_tk_info *info, int mode)
{
u8 cmd;
int ret;
if (info->fw_ver < ABOV_DUAL_DETECTION_CMD_FW_VER) {
info->dual_mode = false;
return;
}
dev_info(&info->client->dev,
"%s: %s\n", __func__, mode ? "on" : "off");
if (mode)
cmd = CMD_DUAL_DETECT;
else
cmd = CMD_SINGLE_DETECT;
ret = abov_tk_i2c_write(info->client, ABOV_DUAL_DETECT, &cmd, 1);
if (ret < 0)
dev_err(&info->client->dev,
"%s %d : fail %d\n", __func__,
```
<Overlap Ratio: 0.8982035928143712>

---

--- 276 --
Question ID: 72925533a1a57536b5810870d4c1b15df2e06401_46
Original Code:
```
static const char *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
    const char *portstr;
    int port;

    if (err != NULL) {
        return err;
    }

    portstr = ap_strchr_c(arg, ':');
    if (portstr) {
        cmd->server->server_hostname = apr_pstrndup(cmd->pool, arg,
                                                    portstr - arg);
        portstr++;
        port = atoi(portstr);
        if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
            return apr_pstrcat(cmd->temp_pool, "The port number \"", arg,
                          "\" is outside the appropriate range "
                          "(i.e., 1..65535).", NULL);
        }
    }
    else {
        cmd->server->server_hostname = apr_pstrdup(cmd->pool, arg);
        port = 0;
    }

    cmd->server->port = port;
    return NULL;
}
```


Overlapping Code:
```
ar *server_hostname_port(cmd_parms *cmd, void *dummy, const char *arg)
{
const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
const char *portstr;
int port;
if (err != NULL) {
return err;
}
portstr = ap_strchr_c(arg, ':');
if (portstr) {
cmd->server->server_hostname = apr_pstrndup(cmd->pool, arg,
portstr - arg);
portstr++;
port = atoi(portstr);
if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
return apr_pstrcat(cmd->temp_pool, "The port number \"", arg,
"\" is outside the appropriate range "
"(i.e., 1..65535).", NULL);
}
}
else {
cmd->server->server_hostname = apr_pstrdup(cmd->pool, arg);
port = 0;
}
cmd->server->port = port;
retu
```
<Overlap Ratio: 0.9640287769784173>

---

--- 277 --
Question ID: ecc7955975e4d983d2a95680e3c3f2608dc5a855_3
Original Code:
```
int
gsfSeek(int handle, int option)
{
    /* JSB 04/05/00 replaced ">=" with ">" */
    if ((handle < 1) || (handle > GSF_MAX_OPEN_FILES))
    {
        gsfError = GSF_BAD_FILE_HANDLE;
        return (-1);
    }

    switch (option)
    {
        case GSF_REWIND:
            /* If the last operation was a write then we need to fflush */
            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)
            {
                if (fflush (gsfFileTable[handle - 1].fp))
                {
                    gsfError = GSF_FLUSH_ERROR;
                    return(-1);
                }
            }
            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;

            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_SET))
            {
                gsfError = GSF_FILE_SEEK_ERROR;
                return (-1);
            }
            break;

        case GSF_END_OF_FILE:
            /* If the last operation was a write then we need to fflush */
            if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)
            {
                if (fflush (gsfFileTable[handle - 1].fp))
                {
                    gsfError = GSF_FLUSH_ERROR;
                    return(-1);
                }
            }
            gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;

            if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_END))
            {
                gsfError = GSF_FILE_SEEK_ERROR;
                return (-1);
            }
            break;

        case GSF_PREVIOUS_RECORD:
            if (fseek(gsfFileTable[handle - 1].fp, gsfFileTable[handle - 1].previous_record, SEEK_SET))
            {
                gsfError = GSF_FILE_SEEK_ERROR;
                return (-1);
            }
            break;

        default:
            gsfError = GSF_BAD_SEEK_OPTION;
            return (-1);
    }

    return (0);
}
```


Overlapping Code:
```
 JSB 04/05/00 replaced ">=" with ">" */
if ((handle < 1) || (handle > GSF_MAX_OPEN_FILES))
{
gsfError = GSF_BAD_FILE_HANDLE;
return (-1);
}
switch (option)
{
case GSF_REWIND:
/* If the last operation was a write then we need to fflush */
if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)
{
if (fflush (gsfFileTable[handle - 1].fp))
{
gsfError = GSF_FLUSH_ERROR;
return(-1);
}
}
gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;
if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_SET))
{
gsfError = GSF_FILE_SEEK_ERROR;
return (-1);
}
break;
case GSF_END_OF_FILE:
/* If the last operation was a write then we need to fflush */
if (gsfFileTable[handle - 1].read_write_flag == LAST_OP_WRITE)
{
if (fflush (gsfFileTable[handle - 1].fp))
{
gsfError = GSF_FLUSH_ERROR;
return(-1);
}
}
gsfFileTable[handle - 1].read_write_flag = LAST_OP_FLUSH;
if (fseek(gsfFileTable[handle - 1].fp, 0, SEEK_END))
{
gsfError = GSF_FILE_SEEK_ERROR;
return (-1);
}
break;
case GSF_PREVIOUS_RECORD:
if (fseek(gsfFileTable[handle - 1].fp, gsfFileTable[handle - 1].previous_record, SEEK_SET))
{
gsfError = GSF_FILE_SEEK_ERROR;
return (-1);
}
break;
default:
gsfError = GSF_BAD_SEEK_OPTION;
return (-1);
}
return (0);
```
<Overlap Ratio: 0.9662921348314607>

---

--- 278 --
Question ID: 2c2a9d429c607e1077f8414ff8a27391fdfabc8c_6
Original Code:
```
cell
pfopen(char *name, int len, int mode, cell *up)
{
    char cstrbuf[512];
    char *s;
    s = expand_name(altocstr(name, len, cstrbuf, 512));

    if (!strncmp("popen:", s, 6))
        return (cell)popen(s+6, popen_modes[mode&3]);

    return( (cell)fopen(s, open_modes[mode&3]) );
}
```


Overlapping Code:
```
char *name, int len, int mode, cell *up)
{
char cstrbuf[512];
char *s;
s = expand_name(altocstr(name, len, cstrbuf, 512));
if (!strncmp("popen:", s, 6))
return (cell)popen(s+6, popen_modes[mode&3]);
return( (cel
```
<Overlap Ratio: 0.8178294573643411>

---

--- 279 --
Question ID: 8853d120c4eb86a20d7ff2c7513f815b12ccd8f3_3
Original Code:
```
int
set_current_field(FORM *f, FIELD *c)
{
	if (!f || !c || c->form != f)
		return (E_BAD_ARGUMENT);

	if (!Opt(c, O_ACTIVE) || !Opt(c, O_VISIBLE))
		return (E_REQUEST_DENIED);

	if (!Status(f, POSTED)) {
		C(f) = c;
		P(f) = c->page;
		return (E_OK);
	}
	if (Status(f, DRIVER))
		return (E_BAD_STATE);

	if (c != C(f)) {
		if (_validate(f)) {
			int v;

			term_field(f);

			if (c -> page != P(f)) {	/* page change */
				term_form(f);
				v = _set_form_page(f, c->page, c);
				init_form(f);
			} else
				v = _set_current_field(f, c);

			init_field(f);
			(void) _update_current(f);
			return (v);
		} else
			return (E_INVALID_FIELD);
	}
	return (E_OK);
}
```


Overlapping Code:
```
 *f, FIELD *c)
{
if (!f || !c || c->form != f)
return (E_BAD_ARGUMENT);
if (!Opt(c, O_ACTIVE) || !Opt(c, O_VISIBLE))
return (E_REQUEST_DENIED);
if (!Status(f, POSTED)) {
C(f) = c;
P(f) = c->page;
return (E_OK);
}
if (Status(f, DRIVER))
return (E_BAD_STATE);
if (c != C(f)) {
if (_validate(f)) {
int v;
term_field(f);
if (c -> page != P(f)) { /* page change */
term_form(f);
v = _set_form_page(f, c->page, c);
init_form(f);
} else
v = _set_current_field(f, c);
init_field(f);
(void) _update_current(f);
return (v);
} else
return (E_INVALID_FIELD);
}
r
```
<Overlap Ratio: 0.9306260575296108>

---

--- 280 --
Question ID: 5a276702dbc498ba5bf11da339a456e1942d54ad_2
Original Code:
```
static const char *contact_id_message(const char *id_who, const char *id_whom, int i) { //  whom
    int rc = 0;
    char zSql[]="SELECT * FROM messages";
    int count = 0;
    int krugi = -1;

    do {
            sqlite3_prepare(db, zSql, -1, &stmt, 0);
            while(SQLITE_ROW == sqlite3_step(stmt)) {


                //printf("%s\n", sqlite3_column_text(stmt,0));

                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_who) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_whom) == 0 ))
                    krugi++;

                if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_whom) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_who) == 0 ))
                    krugi++;

                    if(krugi == i) {
                        const char *res = mx_strnew(255);
                        res = (const char*)sqlite3_column_text(stmt,1);
                        rc = sqlite3_finalize(stmt);
                        return res;
                    }
            }
                rc = sqlite3_finalize(stmt);
                }
    while(rc == SQLITE_SCHEMA); {}
    return "-1";
}
```


Overlapping Code:
```
ge(const char *id_who, const char *id_whom, int i) { //  whom
int rc = 0;
char zSql[]="SELECT * FROM messages";
int count = 0;
int krugi = -1;
do {
sqlite3_prepare(db, zSql, -1, &stmt, 0);
while(SQLITE_ROW == sqlite3_step(stmt)) {
//printf("%s\n", sqlite3_column_text(stmt,0));
if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_who) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_whom) == 0 ))
krugi++;
if ((strcmp((const char*)sqlite3_column_text(stmt,1), id_whom) == 0 ) && (strcmp((const char*)sqlite3_column_text(stmt,2), id_who) == 0 ))
krugi++;
if(krugi == i) {
const char *res = mx_strnew(255);
res = (const char*)sqlite3_column_text(stmt,1);
rc = sqlite3_finalize(stmt);
return res;
}
}
rc = sqlite3_finalize(stmt);
}
while(rc == SQLITE_SCHEMA); {}
return "-1";
```
<Overlap Ratio: 0.955952380952381>

---

--- 281 --
Question ID: 492f3e3af7a5a5c034bd94e8dde92e7215c49d4e_4
Original Code:
```
void qspExecLocByName(QSP_CHAR *name, QSP_BOOL isChangeDesc)
{
	int locInd = qspLocIndex(name);
	if (locInd < 0)
	{
		qspSetError(QSP_ERR_LOCNOTFOUND);
		return;
	}
	qspExecLocByIndex(locInd, isChangeDesc, QSP_FALSE);
}
```


Overlapping Code:
```
cByName(QSP_CHAR *name, QSP_BOOL isChangeDesc)
{
int locInd = qspLocIndex(name);
if (locInd < 0)
{
qspSetError(QSP_ERR_LOCNOTFOUND);
return;
}
qspExec
```
<Overlap Ratio: 0.7142857142857143>

---

--- 282 --
Question ID: 436edbc9e8797ccd98315375d7ed9d4ce3602f83_20
Original Code:
```
int handle_packet_anonymous(net_connection_t *net_connection, uint32_t packet_id, void *message_object)
{
  assert(net_connection != NULL);
  assert(message_object != NULL);
  switch (packet_id)
  {
    case PKT_TYPE_CONNECT_REQ:
      {
        connection_req_t *message = (connection_req_t*)message_object;
        net_connection->host_port = message->host_port;
        net_connection->anonymous = 0;

        struct mg_connection *connection = net_connection->connection;
        assert(connection != NULL);

        uint32_t remote_ip = ntohl(*(uint32_t*)&connection->sa.sin.sin_addr);
        uint64_t peer_id = concatenate(remote_ip, message->host_port);
        if (has_peer(peer_id))
        {
          LOG_DEBUG("Cannot add an already existant peer with id: %u!", peer_id);
          return 1;
        }

        if (g_protocol_force_version_check)
        {
          if (memcmp(message->version_number, APPLICATION_VERSION, strlen(APPLICATION_VERSION)) != 0)
          {
            LOG_DEBUG("Failed to verify version number: [%s] expected: [%s], for peer with id: [%" PRIu64 "]!\n", message->version_number, APPLICATION_VERSION, peer_id);
            return 1;
          }

          if (memcmp(message->version_name, APPLICATION_RELEASE_NAME, strlen(APPLICATION_RELEASE_NAME)) != 0)
          {
            LOG_DEBUG("Failed to verify version name: [%s] expected: [%s], for peer with id: [%" PRIu64 "]!\n", message->version_name, APPLICATION_RELEASE_NAME, peer_id);
            return 1;
          }
        }

        // check to see if the peer is connected to the right network,
        // that's appropriate to what mode they are running in...
        if (message->use_testnet != parameters_get_use_testnet())
        {
          return 1;
        }

        peer_t *peer = init_peer(peer_id, net_connection);
        assert(add_peer(peer) == 0);

        if (handle_packet_sendto(net_connection, PKT_TYPE_CONNECT_RESP))
        {
          free_peer(peer);
          return 1;
        }

        return 0;
      }
      break;
    case PKT_TYPE_CONNECT_RESP:
      {
        connection_resp_t *message = (connection_resp_t*)message_object;
        net_connection->anonymous = 0;
        return 0;
      }
      break;
    default:
      assert(close_net_connection(net_connection) == 0);
      return 1;
  }

  return 1;
}
```


Overlapping Code:
```
_connection_t *net_connection, uint32_t packet_id, void *message_object)
{
assert(net_connection != NULL);
assert(message_object != NULL);
switch (packet_id)
{
case PKT_TYPE_CONNECT_REQ:
{
connection_req_t *message = (connection_req_t*)message_object;
net_connection->host_port = message->host_port;
net_connection->anonymous = 0;
struct mg_connection *connection = net_connection->connection;
assert(connection != NULL);
uint32_t remote_ip = ntohl(*(uint32_t*)&connection->sa.sin.sin_addr);
uint64_t peer_id = concatenate(remote_ip, message->host_port);
if (has_peer(peer_id))
{
LOG_DEBUG("Cannot add an already existant peer with id: %u!", peer_id);
return 1;
}
if (g_protocol_force_version_check)
{
if (memcmp(message->version_number, APPLICATION_VERSION, strlen(APPLICATION_VERSION)) != 0)
{
LOG_DEBUG("Failed to verify version number: [%s] expected: [%s], for peer with id: [%" PRIu64 "]!\n", message->version_number, APPLICATION_VERSION, peer_id);
return 1;
}
if (memcmp(message->version_name, APPLICATION_RELEASE_NAME, strlen(APPLICATION_RELEASE_NAME)) != 0)
{
LOG_DEBUG("Failed to verify version name: [%s] expected: [%s], for peer with id: [%" PRIu64 "]!\n", message->version_name, APPLICATION_RELEASE_NAME, peer_id);
return 1;
}
}
// check to see if the peer is connected to the right network,
// that's appropriate to what mode they are running in...
if (message->use_testnet != parameters_get_use_testnet())
{
return 1;
}
peer_t *peer = init_peer(peer_id, net_connection);
assert(add_peer(peer) == 0);
if (handle_packet_sendto(net_connection, PKT_TYPE_CONNECT_RESP))
{
free_peer(peer);
return 1;
}
return 0;
}
break;
case PKT_TYPE_CONNECT_RESP:
{
connection_resp_t *message = (connection_resp_t*)message_object;
net_connection->anonymous = 0;
return 0;
}
break;
default:
assert(close_net_connection(net_connection) == 0);
return 1;
}
return 1;

```
<Overlap Ratio: 0.9830508474576272>

---

--- 283 --
Question ID: 3c731aecc4f63f114738f93c1048785c129aec24_30
Original Code:
```
static GEN
ellisograph_dummy(GEN E, long n, GEN jt, GEN jtt, GEN s0, long flag)
{
  GEN c4 = ell_get_c4(E), c6 = ell_get_c6(E), c6c4 = gdiv(c6, c4);
  GEN jtp = gmul(c6c4, gdivgs(gmul(jt, jtt), -n));
  GEN iso = ellisog_by_jt(c4, c6, jt, jtp, gmul(s0, c6c4), n, flag);
  GEN v = mkvec2(iso, cgetg(1, t_VEC));
  return mkvec2(ellisograph_a4a6(E, flag), mkvec(v));
}
```


Overlapping Code:
```
lisograph_dummy(GEN E, long n, GEN jt, GEN jtt, GEN s0, long flag)
{
GEN c4 = ell_get_c4(E), c6 = ell_get_c6(E), c6c4 = gdiv(c6, c4);
GEN jtp = gmul(c6c4, gdivgs(gmul(jt, jtt), -n));
GEN iso = ellisog_by_jt(c4, c6, jt, jtp, gmul(s0, c6c4), n, flag);
GEN v = mkvec2(iso, cgetg(1, t_VEC));
return mkvec
```
<Overlap Ratio: 0.847457627118644>

---

--- 284 --
Question ID: add02c52453fa9c1158910b1557ff752c3f3e452_0
Original Code:
```
inline static int
next_utf8(const char *str, int len, uint32_t *cp)
{
        unsigned char b0 = (str++)[0];
        int nbytes;

        if (!len)
                return -1;

        if (!b0)
                return -1;
        else if (b0 < 0x80) { // ASCII
                *cp = b0; return 1;
        }
        else if (b0 < 0xc0) // C1 or continuation
                return -1;
        else if (b0 < 0xe0) {
                nbytes = 2; *cp = b0 & 0x1f;
        }
        else if (b0 < 0xf0) {
                nbytes = 3; *cp = b0 & 0x0f;
        }
        else if (b0 < 0xf8) {
                nbytes = 4; *cp = b0 & 0x07;
        }
        else
                return -1;

        if (len < nbytes)
                return -1;

        for (int i = 1; i < nbytes; i++) {
                b0 = (str++)[0];
                if (!b0)
                        return -1;

                *cp <<= 6;
                *cp |= b0 & 0x3f;
        }

        return nbytes;
}
```


Overlapping Code:
```
ine static int
next_utf8(const char *str, int len, uint32_t *cp)
{
unsigned char b0 = (str++)[0];
int nbytes;
if (!len)
return -1;
if (!b0)
return -1;
else if (b0 < 0x80) { // ASCII
*cp = b0; return 1;
}
else if (b0 < 0xc0) // C1 or continuation
return -1;
else if (b0 < 0xe0) {
nbytes = 2; *cp = b0 & 0x1f;
}
else if (b0 < 0xf0) {
nbytes = 3; *cp = b0 & 0x0f;
}
else if (b0 < 0xf8) {
nbytes = 4; *cp = b0 & 0x07;
}
else
return -1;
if (len < nbytes)
return -1;
for (int i = 1; i < nbytes; i++) {
b0 = (str++)[0];
if (!b0)
return -1;
*cp <<= 6;
*cp |= b0 & 0x3f
```
<Overlap Ratio: 0.9605488850771869>

---

--- 285 --
Question ID: f77092683f5350a554bd7cd3c21246e8fd7ce0fb_10
Original Code:
```
VS_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)
{
	if (!zimg_check_api_version(ZIMG_API_VERSION))
		return;

	configFunc("the.weather.channel", "z", "batman", VAPOURSYNTH_API_VERSION, 1, plugin);
	
	registerFunc("Colorspace", "clip:clip;"
	                           "matrix_in:int;"
	                           "transfer_in:int;"
	                           "primaries_in:int;"
	                           "matrix_out:int:opt;"
	                           "transfer_out:int:opt;"
	                           "primaries_out:int:opt", vs_colorspace_create, 0, plugin);
	registerFunc("Depth", "clip:clip;"
	                      "dither:data:opt;"
	                      "format:int:opt;"
	                      "sample:int:opt;"
	                      "depth:int:opt;"
	                      "fullrange_in:int:opt;"
	                      "fullrange_out:int:opt", vs_depth_create, 0, plugin);
	registerFunc("Resize", "clip:clip;"
	                       "width:int;"
	                       "height:int;"
	                       "filter:data:opt;"
	                       "filter_param_a:float:opt;"
	                       "filter_param_b:float:opt;"
	                       "shift_w:float:opt;"
	                       "shift_h:float:opt;"
	                       "subwidth:float:opt;"
	                       "subheight:float:opt;"
	                       "filter_uv:data:opt;"
	                       "filter_param_a_uv:float:opt;"
	                       "filter_param_b_uv:float:opt;"
	                       "subsample_w:int:opt;"
	                       "subsample_h:int:opt;"
	                       "chroma_loc_in:data:opt;"
	                       "chroma_loc_out:data:opt;", vs_resize_create, 0, plugin);

	zimg_set_cpu(ZIMG_CPU_AUTO);
}
```


Overlapping Code:
```
_EXTERNAL_API(void) VapourSynthPluginInit(VSConfigPlugin configFunc, VSRegisterFunction registerFunc, VSPlugin *plugin)
{
if (!zimg_check_api_version(ZIMG_API_VERSION))
return;
configFunc("the.weather.channel", "z", "batman", VAPOURSYNTH_API_VERSION, 1, plugin);

registerFunc("Colorspace", "clip:clip;"
"matrix_in:int;"
"transfer_in:int;"
"primaries_in:int;"
"matrix_out:int:opt;"
"transfer_out:int:opt;"
"primaries_out:int:opt", vs_colorspace_create, 0, plugin);
registerFunc("Depth", "clip:clip;"
"dither:data:opt;"
"format:int:opt;"
"sample:int:opt;"
"depth:int:opt;"
"fullrange_in:int:opt;"
"fullrange_out:int:opt", vs_depth_create, 0, plugin);
registerFunc("Resize", "clip:clip;"
"width:int;"
"height:int;"
"filter:data:opt;"
"filter_param_a:float:opt;"
"filter_param_b:float:opt;"
"shift_w:float:opt;"
"shift_h:float:opt;"
"subwidth:float:opt;"
"subheight:float:opt;"
"filter_uv:data:opt;"
"filter_param_a_uv:float:opt;"
"filter_param_b_uv:float:opt;"
"subsample_w:int:opt;"
"subsample_h:int:opt;"
"chroma_loc_in:data:opt;"
"chroma_loc_out:data:opt;", vs_resize_create, 0, plugin);
zim
```
<Overlap Ratio: 0.9741302408563782>

---

--- 286 --
Question ID: 62c00d81b6da971b239ae5d4ad6d9ecbe85340a7_2
Original Code:
```
JNICALL
Java_com_pingan_apicrypt_ApiCrypt_encrypt(JNIEnv *env, jclass type, jstring enc_) {
    const char *enc = (*env)->GetStringUTFChars(env, enc_, 0);

    if (enc == NULL || strlen(enc) <= 0) {
        return NULL;
    }

    unsigned char *pBuffer = NULL;

    //
    //simpleEnc(enc, returnValue);

    //DES
    des_encipher((const unsigned char *) enc, &pBuffer);

    //AES
//    aes128_cbc_encrypt(enc, NULL, &pBuffer);

    (*env)->ReleaseStringUTFChars(env, enc_, enc);

    jstring ret = (*env)->NewStringUTF(env, (char *)pBuffer);

    free(pBuffer);
    return ret;
}
```


Overlapping Code:
```
_ApiCrypt_encrypt(JNIEnv *env, jclass type, jstring enc_) {
const char *enc = (*env)->GetStringUTFChars(env, enc_, 0);
if (enc == NULL || strlen(enc) <= 0) {
return NULL;
}
unsigned char *pBuffer = NULL;
//
//simpleEnc(enc, returnValue);
//DES
des_encipher((const unsigned char *) enc, &pBuffer);
//AES
// aes128_cbc_encrypt(enc, NULL, &pBuffer);
(*env)->ReleaseStringUTFChars(env, enc_, enc);
jstring ret = (*env)->NewStringUTF(env, (char 
```
<Overlap Ratio: 0.8620689655172413>

---

--- 287 --
Question ID: 6f702bb5f19442f13217e61b8e8bb28422903f98_3
Original Code:
```
void reply_remove_tcb(tcb_t *tcb)
{
    assert(thread_state_get_tsType(tcb->tcbState) == ThreadState_BlockedOnReply);
    reply_t *reply = REPLY_PTR(thread_state_get_replyObject(tcb->tcbState));
    word_t next_ptr = call_stack_get_callStackPtr(reply->replyNext);
    word_t prev_ptr = call_stack_get_callStackPtr(reply->replyPrev);

    if (next_ptr) {
        if (call_stack_get_isHead(reply->replyNext)) {
            SC_PTR(next_ptr)->scReply = NULL;
        } else {
            REPLY_PTR(next_ptr)->replyPrev = call_stack_new(0, false);
        }
    }

    if (prev_ptr) {
        REPLY_PTR(prev_ptr)->replyNext = call_stack_new(0, false);
    }

    reply->replyPrev = call_stack_new(0, false);
    reply->replyNext = call_stack_new(0, false);
    reply_unlink(reply);
}
```


Overlapping Code:
```
ly_remove_tcb(tcb_t *tcb)
{
assert(thread_state_get_tsType(tcb->tcbState) == ThreadState_BlockedOnReply);
reply_t *reply = REPLY_PTR(thread_state_get_replyObject(tcb->tcbState));
word_t next_ptr = call_stack_get_callStackPtr(reply->replyNext);
word_t prev_ptr = call_stack_get_callStackPtr(reply->replyPrev);
if (next_ptr) {
if (call_stack_get_isHead(reply->replyNext)) {
SC_PTR(next_ptr)->scReply = NULL;
} else {
REPLY_PTR(next_ptr)->replyPrev = call_stack_new(0, false);
}
}
if (prev_ptr) {
REPLY_PTR(prev_ptr)->replyNext = call_stack_new(0, false);
}
reply->replyPrev = call_stack_new(0, false);
reply->replyNext = call_stack_new(0, false);
reply
```
<Overlap Ratio: 0.9629629629629629>

---

--- 288 --
Question ID: de0c78883542bbe2959cf4d6d60b47acbac3c287_1
Original Code:
```
static void *
hammer(
  void *targs
    )
{
  int status = 0;
  task_info_t *tinfo = (task_info_t *)targs;
  float *X = NULL; // for re-sort timing comparison
  uint8_t *g = NULL; // for re-sort timing comparison

  uint64_t *Y    = NULL;
  uint64_t *tmpY = NULL;
  uint64_t *isp_tmpY = NULL;

  uint32_t *yval = NULL;
  uint8_t  *goal = NULL;
  uint32_t *from = NULL;
  
  uint32_t *pre_yval = NULL;
  uint8_t  *pre_goal = NULL;
  uint32_t *pre_from = NULL;
  
  uint32_t *post_yval = NULL;
  uint8_t  *post_goal = NULL;
  uint32_t *post_from = NULL;
  
  uint32_t *to   = NULL;
  uint32_t *isp_to   = NULL;

  uint32_t *to_split = NULL;

  uint32_t n = tinfo->n;
  uint32_t lb = 0; 
  uint32_t ub = n;

  //-----------------------------------------
  Y    = malloc(n * sizeof(uint64_t));
  tmpY = malloc(n * sizeof(uint64_t));
  isp_tmpY = malloc(n * sizeof(uint64_t));

  yval = malloc(n * sizeof(uint32_t));
  from = malloc(n * sizeof(uint32_t));
  goal = malloc(n * sizeof(uint8_t));

  pre_yval = malloc(n * sizeof(uint32_t));
  pre_from = malloc(n * sizeof(uint32_t));
  pre_goal = malloc(n * sizeof(uint8_t));

  post_yval = malloc(n * sizeof(uint32_t));
  post_from = malloc(n * sizeof(uint32_t));
  post_goal = malloc(n * sizeof(uint8_t));

  to   = malloc(n * sizeof(uint32_t));
  isp_to   = malloc(n * sizeof(uint32_t));

  to_split   = malloc(n * sizeof(uint32_t));
  // Initialization
  for ( uint32_t i = 0; i < n; i++ ) { yval[i] = i+1; }
  for ( uint32_t i = 0; i < n; i++ ) { from[i] = (n-1) - i; }
  for ( uint32_t i = 0; i < n; i++ ) { goal[i] = i % 2 ; } 
  for ( uint32_t i = 0; i < n; i++ ) { 
    Y[i] = x_mk_comp_val(from[i], goal[i], yval[i]); 
  }
  for ( uint32_t i = 0; i < n; i++ ) { tmpY[i] = 0; }
  // We decree that half the points go left, and other half go right
  uint32_t lidx = 0;
  uint32_t ridx = n / 2;
  uint32_t split_yidx = n / 2;
  uint32_t p1 = 0, p2 = n - 1;
  for ( uint32_t i = 0; i < n; ) { 
    to_split[i++] = p1++;
    to_split[i++] = p2--;
  }
  //-----------------------------------------
  if ( tinfo->what_work_to_do == REORDER ) { 
    tinfo->t_start = get_time_usec();
    reorder(Y, tmpY, to, to_split, lb, ub, split_yidx, &lidx, &ridx);
    tinfo->t_stop = get_time_usec();
  }
  //--- run ISP version
  lidx = 0;
  ridx = n / 2;
  if ( tinfo->what_work_to_do == REORDER_ISP ) { 
    tinfo->t_start = get_time_usec();
    reorder_isp(Y, isp_tmpY, isp_to, to_split, lb, ub, split_yidx, 
        &lidx, &ridx, &status);
    cBYE(status);
    tinfo->t_stop = get_time_usec();
  }
BYE:
  // Free stuff so that we have space for re-sort test 
  free(Y);
  free(tmpY);
  free(isp_tmpY);

  free(yval);
  free(goal);
  free(from);
  
  free(pre_yval);
  free(pre_goal);
  free(pre_from);
  
  free(post_yval);
  free(post_goal);
  free(post_from);
  
  free(to);
  free(isp_to);

  free(to_split);
  //-------------------------------
  return NULL;
}
```


Overlapping Code:
```
ic void *
hammer(
void *targs
)
{
int status = 0;
task_info_t *tinfo = (task_info_t *)targs;
float *X = NULL; // for re-sort timing comparison
uint8_t *g = NULL; // for re-sort timing comparison
uint64_t *Y = NULL;
uint64_t *tmpY = NULL;
uint64_t *isp_tmpY = NULL;
uint32_t *yval = NULL;
uint8_t *goal = NULL;
uint32_t *from = NULL;

uint32_t *pre_yval = NULL;
uint8_t *pre_goal = NULL;
uint32_t *pre_from = NULL;

uint32_t *post_yval = NULL;
uint8_t *post_goal = NULL;
uint32_t *post_from = NULL;

uint32_t *to = NULL;
uint32_t *isp_to = NULL;
uint32_t *to_split = NULL;
uint32_t n = tinfo->n;
uint32_t lb = 0; 
uint32_t ub = n;
//-----------------------------------------
Y = malloc(n * sizeof(uint64_t));
tmpY = malloc(n * sizeof(uint64_t));
isp_tmpY = malloc(n * sizeof(uint64_t));
yval = malloc(n * sizeof(uint32_t));
from = malloc(n * sizeof(uint32_t));
goal = malloc(n * sizeof(uint8_t));
pre_yval = malloc(n * sizeof(uint32_t));
pre_from = malloc(n * sizeof(uint32_t));
pre_goal = malloc(n * sizeof(uint8_t));
post_yval = malloc(n * sizeof(uint32_t));
post_from = malloc(n * sizeof(uint32_t));
post_goal = malloc(n * sizeof(uint8_t));
to = malloc(n * sizeof(uint32_t));
isp_to = malloc(n * sizeof(uint32_t));
to_split = malloc(n * sizeof(uint32_t));
// Initialization
for ( uint32_t i = 0; i < n; i++ ) { yval[i] = i+1; }
for ( uint32_t i = 0; i < n; i++ ) { from[i] = (n-1) - i; }
for ( uint32_t i = 0; i < n; i++ ) { goal[i] = i % 2 ; } 
for ( uint32_t i = 0; i < n; i++ ) { 
Y[i] = x_mk_comp_val(from[i], goal[i], yval[i]); 
}
for ( uint32_t i = 0; i < n; i++ ) { tmpY[i] = 0; }
// We decree that half the points go left, and other half go right
uint32_t lidx = 0;
uint32_t ridx = n / 2;
uint32_t split_yidx = n / 2;
uint32_t p1 = 0, p2 = n - 1;
for ( uint32_t i = 0; i < n; ) { 
to_split[i++] = p1++;
to_split[i++] = p2--;
}
//-----------------------------------------
if ( tinfo->what_work_to_do == REORDER ) { 
tinfo->t_start = get_time_usec();
reorder(Y, tmpY, to, to_split, lb, ub, split_yidx, &lidx, &ridx);
tinfo->t_stop = get_time_usec();
}
//--- run ISP version
lidx = 0;
ridx = n / 2;
if ( tinfo->what_work_to_do == REORDER_ISP ) { 
tinfo->t_start = get_time_usec();
reorder_isp(Y, isp_tmpY, isp_to, to_split, lb, ub, split_yidx, 
&lidx, &ridx, &status);
cBYE
```
<Overlap Ratio: 0.9943305713039686>

---

--- 289 --
Question ID: ea86865f6e3ef71aaa2a43dbecdab961c99806c3_1
Original Code:
```
void W25QXX_Write(uint32_t Addr, uint8_t* pData, uint32_t BytesToWrite)
{
	uint8_t Offset = Addr % PAGE_SIZE;

	if (Offset != 0)
	{
		uint8_t PageRemainBytes = PAGE_SIZE - Offset;

		if (BytesToWrite <= PageRemainBytes)
		{
			W25QXX_PageWrite(Addr, pData, BytesToWrite);
			return;
		}

		W25QXX_PageWrite(Addr, pData, PageRemainBytes);
		Addr += PageRemainBytes;
		pData += PageRemainBytes;
		BytesToWrite -= PageRemainBytes;
	}

	uint8_t PageCount = BytesToWrite / PAGE_SIZE;
	uint8_t SingleCount = BytesToWrite % PAGE_SIZE;

	while (PageCount--)
	{
		W25QXX_PageWrite(Addr, pData, PAGE_SIZE);
		Addr += PAGE_SIZE;
		pData += PAGE_SIZE;
	}
	W25QXX_PageWrite(Addr, pData, SingleCount);

}
```


Overlapping Code:
```
nt32_t Addr, uint8_t* pData, uint32_t BytesToWrite)
{
uint8_t Offset = Addr % PAGE_SIZE;
if (Offset != 0)
{
uint8_t PageRemainBytes = PAGE_SIZE - Offset;
if (BytesToWrite <= PageRemainBytes)
{
W25QXX_PageWrite(Addr, pData, BytesToWrite);
return;
}
W25QXX_PageWrite(Addr, pData, PageRemainBytes);
Addr += PageRemainBytes;
pData += PageRemainBytes;
BytesToWrite -= PageRemainBytes;
}
uint8_t PageCount = BytesToWrite / PAGE_SIZE;
uint8_t SingleCount = BytesToWrite % PAGE_SIZE;
while (PageCount--)
{
W25QXX_PageWrite(Addr, pData, PAGE_SIZE);
Addr += PAGE_SIZE;
pData += PAGE_SIZE;
}
W25QXX_PageWrite(Ad
```
<Overlap Ratio: 0.9287925696594427>

---

--- 290 --
Question ID: 2a3c548f4a80635eaf6c36d347a7502e36c89bc3_7
Original Code:
```
TI_STATUS report_GetReportSeverityTable(TI_HANDLE hReport, TI_UINT8 *pSeverities)
{
    TI_UINT8 index;

	if( (NULL == hReport) || (NULL == pSeverities))
	{

		return TI_NOK;
	}


    os_memoryCopy (((TReport *)hReport)->hOs, 
                   (void *)pSeverities, 
                   (void *)(((TReport *)hReport)->aSeverityTable), 
                   sizeof(((TReport *)hReport)->aSeverityTable));

    for (index = 0; index < sizeof(((TReport *)hReport)->aSeverityTable); index++)
    {
        pSeverities[index] += '0';
    }

    return TI_OK;
}
```


Overlapping Code:
```
S report_GetReportSeverityTable(TI_HANDLE hReport, TI_UINT8 *pSeverities)
{
TI_UINT8 index;
if( (NULL == hReport) || (NULL == pSeverities))
{
return TI_NOK;
}
os_memoryCopy (((TReport *)hReport)->hOs, 
(void *)pSeverities, 
(void *)(((TReport *)hReport)->aSeverityTable), 
sizeof(((TReport *)hReport)->aSeverityTable));
for (index = 0; index < sizeof(((TReport *)hReport)->aSeverityTable); index++)
{
pSeverities[inde
```
<Overlap Ratio: 0.9205298013245033>

---

--- 291 --
Question ID: ce40be96d3ac9462427bd0e9d83dc301b3922933_30
Original Code:
```
int
__db_slice_remove(dbenv, txn, name, subdb, flags)
	DB_ENV *dbenv;
	DB_TXN *txn;
	const char *name;
	const char *subdb;
	u_int32_t flags;
{
	DB_ENV *slice;
	DB_TXN *sl_txn;
	ENV *env;
	int i, ret, t_ret;
	u_int32_t metaflags;

	/* Slices do not handle sub-databases. */
	if (subdb != NULL)
		return (0);

	env = dbenv->env;
	/* This function is a nop if the db is not sliced. */
	if ((ret = __db_get_metaflags(env, name, &metaflags)) != 0)
		return (ret);
	if (!FLD_ISSET(metaflags, DBMETA_SLICED))
		return (0);
	/* Return an error if removing a sliced db from a non-sliced env. */
	if (!SLICES_ON(env))
		return (__env_not_sliced(env));

	for (i = -1; (slice = __slice_iterate(dbenv, &i)) != NULL; ) {
		if ((t_ret =
		    __txn_slice_begin(txn, &sl_txn, (db_slice_t)i)) != 0 ||
		    (t_ret = __env_dbremove_pp(slice,
		    sl_txn, name, subdb, flags)) != 0) {
			/*
			 * Until cross slice DDL operations are atomic, any
			 * missing files do not return an error code.
			 */
			if (t_ret == ENOENT)
				continue;
			__db_err(env, t_ret, "dbremove #%d %s", i, name);
			/*
			 * Suppress missing files in slice directories;
			 * cross-slice DDL isn't atomic.
			 */
			if (ret == 0)
				ret = USR_ERR(env, DB_SLICE_CORRUPT);
		}
	}
	return (ret);
}
```


Overlapping Code:
```
b_slice_remove(dbenv, txn, name, subdb, flags)
DB_ENV *dbenv;
DB_TXN *txn;
const char *name;
const char *subdb;
u_int32_t flags;
{
DB_ENV *slice;
DB_TXN *sl_txn;
ENV *env;
int i, ret, t_ret;
u_int32_t metaflags;
/* Slices do not handle sub-databases. */
if (subdb != NULL)
return (0);
env = dbenv->env;
/* This function is a nop if the db is not sliced. */
if ((ret = __db_get_metaflags(env, name, &metaflags)) != 0)
return (ret);
if (!FLD_ISSET(metaflags, DBMETA_SLICED))
return (0);
/* Return an error if removing a sliced db from a non-sliced env. */
if (!SLICES_ON(env))
return (__env_not_sliced(env));
for (i = -1; (slice = __slice_iterate(dbenv, &i)) != NULL; ) {
if ((t_ret =
__txn_slice_begin(txn, &sl_txn, (db_slice_t)i)) != 0 ||
(t_ret = __env_dbremove_pp(slice,
sl_txn, name, subdb, flags)) != 0) {
/*
* Until cross slice DDL operations are atomic, any
* missing files do not return an error code.
*/
if (t_ret == ENOENT)
continue;
__db_err(env, t_ret, "dbremove #%d %s", i, name);
/*
* Suppress missing files in slice directories;
* cross-slice DDL isn't atomic.
*/
if (ret == 0)
ret = USR_ERR(env, DB_SLICE_CORRUPT);
}
}
return 
```
<Overlap Ratio: 0.9870242214532872>

---

--- 292 --
Question ID: baa9662e27034b19bb56d464d05b6f7db6418121_64
Original Code:
```
st_s* bcore_btree_vd_s_status( bcore_btree_vd_s* o )
{
    uz_t blocks = 0;
    uz_t nodes = 0;
    uz_t deleted_nodes = 0;
    if( o->chain_beg )
    {
        bcore_btree_node_vd_s* chain_beg = o->chain_beg;
        while( chain_beg )
        {
            chain_beg = *( bcore_btree_node_vd_s** )( chain_beg + o->block_size );
            blocks++;
        }
        nodes = blocks * o->block_size - ( o->chain_end - o->chain_ins );
    }
    if( o->del_chain )
    {
        bcore_btree_node_vd_s* del_chain = o->del_chain;
        while( del_chain )
        {
            del_chain = del_chain->parent;
            deleted_nodes++;
        }
    }

    st_s* string = st_s_create();
    uz_t used_nodes = nodes - deleted_nodes;
    st_s_pushf( string, "keys ........... %lu\n", bcore_btree_node_vd_s_keys( o->root ) );
    st_s_pushf( string, "nodes .......... %lu\n", used_nodes );
    st_s_pushf( string, "keys/nodes ..... %5.4f\n", used_nodes > 0 ? ( double )( bcore_btree_node_vd_s_keys( o->root ) ) / used_nodes : 0 );
    st_s_pushf( string, "depth .......... %lu\n", bcore_btree_node_vd_s_depth( o->root ) );
    st_s_pushf( string, "block size ..... %lu\n", o->block_size );
    st_s_pushf( string, "blocks ......... %lu\n", blocks );
    st_s_pushf( string, "deleted nodes .. %lu\n", deleted_nodes );
    return string;
}
```


Overlapping Code:
```
s_status( bcore_btree_vd_s* o )
{
uz_t blocks = 0;
uz_t nodes = 0;
uz_t deleted_nodes = 0;
if( o->chain_beg )
{
bcore_btree_node_vd_s* chain_beg = o->chain_beg;
while( chain_beg )
{
chain_beg = *( bcore_btree_node_vd_s** )( chain_beg + o->block_size );
blocks++;
}
nodes = blocks * o->block_size - ( o->chain_end - o->chain_ins );
}
if( o->del_chain )
{
bcore_btree_node_vd_s* del_chain = o->del_chain;
while( del_chain )
{
del_chain = del_chain->parent;
deleted_nodes++;
}
}
st_s* string = st_s_create();
uz_t used_nodes = nodes - deleted_nodes;
st_s_pushf( string, "keys ........... %lu\n", bcore_btree_node_vd_s_keys( o->root ) );
st_s_pushf( string, "nodes .......... %lu\n", used_nodes );
st_s_pushf( string, "keys/nodes ..... %5.4f\n", used_nodes > 0 ? ( double )( bcore_btree_node_vd_s_keys( o->root ) ) / used_nodes : 0 );
st_s_pushf( string, "depth .......... %lu\n", bcore_btree_node_vd_s_depth( o->root ) );
st_s_pushf( string, "block size ..... %lu\n", o->block_size );
st_s_pushf( string, "blocks ......... %lu\n", blocks );
st_s_pushf( string, "deleted nodes .. %lu\n", deleted_nodes );
return str
```
<Overlap Ratio: 0.976274165202109>

---

--- 293 --
Question ID: 3bff718f60c51ae860968f165cb183a7af3b5967_0
Original Code:
```
void sparse_exponential(int n, int nnz, int *ia, int *ja, double *a, double t, double *initialArray, double *res){ 
	int i;
	int m = n-1; 
	double w[n];
	int ideg = 6;
	double tol = 1;
	int iflag = 0;
	int lwsp = n*(m+1)+n+pow((m+2.),2)+4*pow((m+2.),2)+ideg+1;
	double  wsp[lwsp];
	int liwsp = m+2;
	int iwsp[liwsp];
	double t1 = t;
	double anorm = 0;
	int itrace = 0;

	for(i=0;i<=n*n;i++)res[i]=0.0;	
	wrapalldmexpv_(&n,&m,&t1,initialArray,w,&tol,&anorm,wsp,&lwsp,iwsp,&liwsp,
			&itrace,&iflag,ia,ja,a,&nnz,res);

}
```


Overlapping Code:
```
arse_exponential(int n, int nnz, int *ia, int *ja, double *a, double t, double *initialArray, double *res){ 
int i;
int m = n-1; 
double w[n];
int ideg = 6;
double tol = 1;
int iflag = 0;
int lwsp = n*(m+1)+n+pow((m+2.),2)+4*pow((m+2.),2)+ideg+1;
double wsp[lwsp];
int liwsp = m+2;
int iwsp[liwsp];
double t1 = t;
double anorm = 0;
int itrace = 0;
for(i=0;i<=n*n;i++)res[i]=0.0; 
wrapalldmexpv_(&n,&m,&t1,initialArray,w,&tol,&anorm,wsp,&lwsp,iwsp,&liwsp,
&itrace,&iflag
```
<Overlap Ratio: 0.9436619718309859>

---

--- 294 --
Question ID: 0691037f99f3a0b0b113d3b94a5460915fe60990_6
Original Code:
```
int aes_128_eax_encrypt(const u8 *key, const u8 *nonce, size_t nonce_len,
			const u8 *hdr, size_t hdr_len,
			u8 *data, size_t data_len, u8 *tag)
{
	u8 *buf;
	size_t buf_len;
	u8 nonce_mac[BLOCK_SIZE], hdr_mac[BLOCK_SIZE], data_mac[BLOCK_SIZE];
	int i;

	if (nonce_len > data_len)
		buf_len = nonce_len;
	else
		buf_len = data_len;
	if (hdr_len > buf_len)
		buf_len = hdr_len;
	buf_len += 16;

	buf = os_malloc(buf_len);
	if (buf == NULL)
		return -1;

	os_memset(buf, 0, 15);

	buf[15] = 0;
	os_memcpy(buf + 16, nonce, nonce_len);
	omac1_aes_128(key, buf, 16 + nonce_len, nonce_mac);

	buf[15] = 1;
	os_memcpy(buf + 16, hdr, hdr_len);
	omac1_aes_128(key, buf, 16 + hdr_len, hdr_mac);

	aes_128_ctr_encrypt(key, nonce_mac, data, data_len);
	buf[15] = 2;
	os_memcpy(buf + 16, data, data_len);
	omac1_aes_128(key, buf, 16 + data_len, data_mac);

	os_free(buf);

	for (i = 0; i < BLOCK_SIZE; i++)
		tag[i] = nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i];

	return 0;
}
```


Overlapping Code:
```
nt aes_128_eax_encrypt(const u8 *key, const u8 *nonce, size_t nonce_len,
const u8 *hdr, size_t hdr_len,
u8 *data, size_t data_len, u8 *tag)
{
u8 *buf;
size_t buf_len;
u8 nonce_mac[BLOCK_SIZE], hdr_mac[BLOCK_SIZE], data_mac[BLOCK_SIZE];
int i;
if (nonce_len > data_len)
buf_len = nonce_len;
else
buf_len = data_len;
if (hdr_len > buf_len)
buf_len = hdr_len;
buf_len += 16;
buf = os_malloc(buf_len);
if (buf == NULL)
return -1;
os_memset(buf, 0, 15);
buf[15] = 0;
os_memcpy(buf + 16, nonce, nonce_len);
omac1_aes_128(key, buf, 16 + nonce_len, nonce_mac);
buf[15] = 1;
os_memcpy(buf + 16, hdr, hdr_len);
omac1_aes_128(key, buf, 16 + hdr_len, hdr_mac);
aes_128_ctr_encrypt(key, nonce_mac, data, data_len);
buf[15] = 2;
os_memcpy(buf + 16, data, data_len);
omac1_aes_128(key, buf, 16 + data_len, data_mac);
os_free(buf);
for (i = 0; i < BLOCK_SIZE; i++)
tag[i] = nonce_mac[i] ^ data_mac[i] ^ hdr_mac[i];
return 0;

```
<Overlap Ratio: 0.9978046103183315>

---

--- 295 --
Question ID: 1be6b2888eb92b1bca047129249042ae95e96982_0
Original Code:
```
class RotateGizmo: public GraphicsSurface
{
	public: enum
	{
		DEGREES,
		RADIANS
	};
	public: enum
	{
		NO_SELECT,
		X_AXIS,
		Y_AXIS,
		Z_AXIS
	};
	private: GraphicsSurface* sphere;
	private: int32 segments;
	private: float step;

	private: Quaternion qX;
	private: Quaternion qY;
	private: Quaternion qZ;

	private: Vector3 xAxis;
	private: Vector3 yAxis;
	private: Vector3 zAxis;
	
    private: float scale;
    private: bool startRotation;

    private: RGBA zColor, yColor, xColor, selectColor;
    private: int32 selected;

    private: Vector3 intersectedPoint;
    private: Vector3 point1, point2;
	private: MagicList<GraphicsSurface> selectedList;
	
	private: MagicPointer<GraphicsSurface> targetObject;
	private: TexturingSurface* gizmo;
    private: Texture2D* texture;
	private: Vector3 previousCursorPosition;
	private: Vector3 startCursorPosition;

	private: TexturingSurface* clenchedHandCursor;
	private: TexturingSurface* unclenchedHandCursor;
	private: TexturingSurface* arrowCursor;
	public: RotateGizmo(void);
	public: virtual ~RotateGizmo(void);
	public: void SetHome(void);
	public: GraphicsSurface* GetTargetObject(void)const;
	public: void Reset(void);
	public: TexturingSurface* GetGizmoSprite(void)const;
	public: void Init(TexturingSurface* _arrowCursor, TexturingSurface* _unclenchedHandCursor, TexturingSurface* _clenchedHandCursor);
	public: void SetSelectedList(MagicList<GraphicsSurface>& _list);
	public: MagicList<GraphicsSurface>& GetSelectedList(void);
	public: void ClearSelectedList(void);
	public: virtual void Draw(void);
	public: virtual void SetPosition(Vector3 _position);
	public: Mouse::Event* MouseEventFilter(Mouse::Event* _event);
	public: void CheckSelect(void);
}
```


Overlapping Code:
```
lass RotateGizmo: public GraphicsSurface
{
public: enum
{
DEGREES,
RADIANS
};
public: enum
{
NO_SELECT,
X_AXIS,
Y_AXIS,
Z_AXIS
};
private: GraphicsSurface* sphere;
private: int32 segments;
private: float step;
private: Quaternion qX;
private: Quaternion qY;
private: Quaternion qZ;
private: Vector3 xAxis;
private: Vector3 yAxis;
private: Vector3 zAxis;

private: float scale;
private: bool startRotation;
private: RGBA zColor, yColor, xColor, selectColor;
private: int32 selected;
private: Vector3 intersectedPoint;
private: Vector3 point1, point2;
private: MagicList<GraphicsSurface> selectedList;

private: MagicPointer<GraphicsSurface> targetObject;
private: TexturingSurface* gizmo;
private: Texture2D* texture;
private: Vector3 previousCursorPosition;
private: Vector3 startCursorPosition;
private: TexturingSurface* clenchedHandCursor;
private: TexturingSurface* unclenchedHandCursor;
private: TexturingSurface* arrowCursor;
public: RotateGizmo(void);
public: virtual ~RotateGizmo(void);
public: void SetHome(void);
public: GraphicsSurface* GetTargetObject(void)const;
public: void Reset(void);
public: TexturingSurface* GetGizmoSprite(void)const;
public: void Init(TexturingSurface* _arrowCursor, TexturingSurface* _unclenchedHandCursor, TexturingSurface* _clenchedHandCursor);
public: void SetSelectedList(MagicList<GraphicsSurface>& _list);
public: MagicList<GraphicsSurface>& GetSelectedList(void);
public: void ClearSelectedList(void);
public: virtual void Draw(void);
public: virtual void SetPosition(Vector3 _position);
public: Mouse::Event* MouseEventFilter(Mouse::Event* _event);
publ
```
<Overlap Ratio: 0.9815950920245399>

---

--- 296 --
Question ID: 3d655fdf421f753a23ce769a9b3047113cd0bcf9_1
Original Code:
```
static void naos_mqtt_status_handler(esp_mqtt_status_t status) {
  // acquire mutex
  NAOS_LOCK(naos_mqtt_mutex);

  // set status
  naos_mqtt_status.connected = status == ESP_MQTT_STATUS_CONNECTED;

  // release mutex
  NAOS_UNLOCK(naos_mqtt_mutex);
}
```


Overlapping Code:
```
qtt_status_t status) {
// acquire mutex
NAOS_LOCK(naos_mqtt_mutex);
// set status
naos_mqtt_status.connected = status == ESP_MQTT_STATUS_CONNECTED;
//
```
<Overlap Ratio: 0.6302521008403361>

---

--- 297 --
Question ID: c0c5b0ec81499b0675815ba39ec70c55e6b8d865_2
Original Code:
```
void _mcu_button_handle_input_event(mc_node *button_node, mci_input_event *input_event)
{
  // printf("_mcu_button_handle_input_event\n");
  mcu_button *button = (mcu_button *)button_node->data;

  if (!button->enabled)
    return;

  if (input_event->type == INPUT_EVENT_MOUSE_PRESS) {
    // printf("_mcu_button_handle_input_event-1\n");
    if (button->left_click && (mc_mouse_button_code)input_event->button_code == MOUSE_BUTTON_LEFT) {
      // printf("_mcu_button_handle_input_event-2\n");
      // Fire left-click
      // TODO fptr casting
      // TODO int this delegate for error handling
      void (*left_click)(mci_input_event *, mcu_button *) =
          (void (*)(mci_input_event *, mcu_button *))button->left_click;
      // TODO -- MCcall(below) - have to make handle input event int
      left_click(input_event, button);
    }
  }

  input_event->handled = true;
}
```


Overlapping Code:
```
le_input_event(mc_node *button_node, mci_input_event *input_event)
{
// printf("_mcu_button_handle_input_event\n");
mcu_button *button = (mcu_button *)button_node->data;
if (!button->enabled)
return;
if (input_event->type == INPUT_EVENT_MOUSE_PRESS) {
// printf("_mcu_button_handle_input_event-1\n");
if (button->left_click && (mc_mouse_button_code)input_event->button_code == MOUSE_BUTTON_LEFT) {
// printf("_mcu_button_handle_input_event-2\n");
// Fire left-click
// TODO fptr casting
// TODO int this delegate for error handling
void (*left_click)(mci_input_event *, mcu_button *) =
(void (*)(mci_input_event *, mcu_button *))button->left_click;
// TODO -- MCcall(below) - have to make handle input event int
left_click(input_event, button);
}
}
i
```
<Overlap Ratio: 0.9375>

---

--- 298 --
Question ID: be9da64e3158f3f5a7082eccfa76ea74cd058f6b_6
Original Code:
```
int pop_front(Dequeue* self) {
	if (empty(self)) {
		return -1;
	}

	int result = *(self->base);

	for (int i = 0; i < self->self_size - 1; ++i) {
		*(self->base + i) = *(self->base + i + 1);
	}

	reserve(self, self->self_size - 1);

	return result;
}
```


Overlapping Code:
```
lf) {
if (empty(self)) {
return -1;
}
int result = *(self->base);
for (int i = 0; i < self->self_size - 1; ++i) {
*(self->base + i) = *(self->base + i + 1);
}
reserve(self, self->self_size - 1);
retur
```
<Overlap Ratio: 0.847457627118644>

---

--- 299 --
Question ID: ba1422b5691df2ffc6e3e08a01ac0ef02590806c_0
Original Code:
```
class Font
{
private:
	unique_ptr<SpriteFont> sprite;
public:
	static Font * Default;

	Font(unique_ptr<SpriteFont> sprite);
	void Draw(SpriteBatch * spriteBatch, wstring text, int fontSize, Vector2 position, XMVECTORF32 color);
	Vector2 Measure(wstring text);
	void Reset();
}
```


Overlapping Code:
```
tr<SpriteFont> sprite;
public:
static Font * Default;
Font(unique_ptr<SpriteFont> sprite);
void Draw(SpriteBatch * spriteBatch, wstring text, int fontSize, Vector2 position, XMVECTORF32 color);
Vector
```
<Overlap Ratio: 0.7407407407407407>

---

--- 300 --
Question ID: be2448e0d39e2cdd69c2faa702277499cd3e8bed_18
Original Code:
```
static char *get_address(uint8_t *publickey, char *address, size_t len)
{
    unsigned char redeem_script[35];
    uint32_t md32[32];
    unsigned char md20[20];
    unsigned char program_hash[21];
    unsigned char bin_idstring[25];
    size_t expected_len;

    assert(publickey);
    assert(address);
    assert(len > 0);

    redeem_script[0] = 33;
    memcpy(redeem_script + 1, publickey, 33);
    redeem_script[34] = PADDING_STANDARD;
    BRHash160(md20, redeem_script, sizeof(redeem_script));

    program_hash[0] = PADDING_IDENTITY;
    memcpy(program_hash + 1, md20, sizeof(md20));

    BRSHA256_2(md32, program_hash, sizeof(program_hash));

    memcpy(bin_idstring, program_hash, sizeof(program_hash));
    memcpy(bin_idstring + sizeof(program_hash), md32, 4);

    expected_len = BRBase58Encode(NULL, 0, bin_idstring, sizeof(bin_idstring));
    if (len < expected_len)
        return NULL;

    BRBase58Encode(address, len, bin_idstring, sizeof(bin_idstring));
    return address;
}
```


Overlapping Code:
```
ss(uint8_t *publickey, char *address, size_t len)
{
unsigned char redeem_script[35];
uint32_t md32[32];
unsigned char md20[20];
unsigned char program_hash[21];
unsigned char bin_idstring[25];
size_t expected_len;
assert(publickey);
assert(address);
assert(len > 0);
redeem_script[0] = 33;
memcpy(redeem_script + 1, publickey, 33);
redeem_script[34] = PADDING_STANDARD;
BRHash160(md20, redeem_script, sizeof(redeem_script));
program_hash[0] = PADDING_IDENTITY;
memcpy(program_hash + 1, md20, sizeof(md20));
BRSHA256_2(md32, program_hash, sizeof(program_hash));
memcpy(bin_idstring, program_hash, sizeof(program_hash));
memcpy(bin_idstring + sizeof(program_hash), md32, 4);
expected_len = BRBase58Encode(NULL, 0, bin_idstring, sizeof(bin_idstring));
if (len < expected_len)
return NULL;
BRBase58Encode(address, len, bin_idstring, sizeof(bin_idstring));
retu
```
<Overlap Ratio: 0.9606741573033708>

---

--- 301 --
Question ID: ad38a7d41636e419e85e754edfae632003db1ef4_0
Original Code:
```
int main() {
    char sz[] = "This is a nice day";

    FILE* f = fopen("ex1.txt", "w+");
    if (f == NULL) {
        perror("failed to open");
        return 1;
    }

    ftruncate(fileno(f), sizeof(sz) - 1);

    size_t pagesize = sysconf(_SC_PAGE_SIZE);

    void* maddr = mmap(NULL, pagesize, PROT_WRITE | PROT_READ, MAP_SHARED, fileno(f), 0);
    if (!maddr) {
        perror("failed to mmap");
        return 1;
    }

    memcpy(maddr, sz, sizeof(sz) - 1);

    munmap(maddr, pagesize);
    fclose(f);

    return 0;
}
```


Overlapping Code:
```
z[] = "This is a nice day";
FILE* f = fopen("ex1.txt", "w+");
if (f == NULL) {
perror("failed to open");
return 1;
}
ftruncate(fileno(f), sizeof(sz) - 1);
size_t pagesize = sysconf(_SC_PAGE_SIZE);
void* maddr = mmap(NULL, pagesize, PROT_WRITE | PROT_READ, MAP_SHARED, fileno(f), 0);
if (!maddr) {
perror("failed to mmap");
return 1;
}
memcpy(maddr, sz, sizeof(sz) - 1);
munmap(maddr, pagesize);
fclos
```
<Overlap Ratio: 0.9174311926605505>

---

--- 302 --
Question ID: d52a78d640c255f15294af993f8d568d2b840211_11
Original Code:
```
int oggflac_id(unsigned char *buf,int len)
{
  (void)buf;
  (void)len;
  return 0;
}
```


Overlapping Code:
```
r *buf,int len)
{
(void)buf;
(void)len;
return 0;

```
<Overlap Ratio: 0.6410256410256411>

---

--- 303 --
Question ID: 9e0fb3202a8f8c3995951f5767348bf8dde56507_6
Original Code:
```
static double
get_next_S(double t, int n, double *stateptr)
{
	double		S;

	/* The magic constant here is T from Vitter's paper */
	if (t <= (22.0 * n))
	{
		/* Process records using Algorithm X until t is large enough */
		double		V,
					quot;

		V = random_fract();		/* Generate V */
		S = 0;
		t += 1;
		/* Note: "num" in Vitter's code is always equal to t - n */
		quot = (t - (double) n) / t;
		/* Find min S satisfying (4.1) */
		while (quot > V)
		{
			S += 1;
			t += 1;
			quot *= (t - (double) n) / t;
		}
	}
	else
	{
		/* Now apply Algorithm Z */
		double		W = *stateptr;
		double		term = t - (double) n + 1;

		for (;;)
		{
			double		numer,
						numer_lim,
						denom;
			double		U,
						X,
						lhs,
						rhs,
						y,
						tmp;

			/* Generate U and X */
			U = random_fract();
			X = t * (W - 1.0);
			S = floor(X);		/* S is tentatively set to floor(X) */
			/* Test if U <= h(S)/cg(X) in the manner of (6.3) */
			tmp = (t + 1) / term;
			lhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);
			rhs = (((t + X) / (term + S)) * term) / t;
			if (lhs <= rhs)
			{
				W = rhs / lhs;
				break;
			}
			/* Test if U <= f(S)/cg(X) */
			y = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);
			if ((double) n < S)
			{
				denom = t;
				numer_lim = term + S;
			}
			else
			{
				denom = t - (double) n + S;
				numer_lim = t + 1;
			}
			for (numer = t + S; numer >= numer_lim; numer -= 1)
			{
				y *= numer / denom;
				denom -= 1;
			}
			W = exp(-log(random_fract()) / n);	/* Generate W in advance */
			if (exp(log(y) / n) <= (t + X) / t)
				break;
		}
		*stateptr = W;
	}
	return S;
}
```


Overlapping Code:
```
tic double
get_next_S(double t, int n, double *stateptr)
{
double S;
/* The magic constant here is T from Vitter's paper */
if (t <= (22.0 * n))
{
/* Process records using Algorithm X until t is large enough */
double V,
quot;
V = random_fract(); /* Generate V */
S = 0;
t += 1;
/* Note: "num" in Vitter's code is always equal to t - n */
quot = (t - (double) n) / t;
/* Find min S satisfying (4.1) */
while (quot > V)
{
S += 1;
t += 1;
quot *= (t - (double) n) / t;
}
}
else
{
/* Now apply Algorithm Z */
double W = *stateptr;
double term = t - (double) n + 1;
for (;;)
{
double numer,
numer_lim,
denom;
double U,
X,
lhs,
rhs,
y,
tmp;
/* Generate U and X */
U = random_fract();
X = t * (W - 1.0);
S = floor(X); /* S is tentatively set to floor(X) */
/* Test if U <= h(S)/cg(X) in the manner of (6.3) */
tmp = (t + 1) / term;
lhs = exp(log(((U * tmp * tmp) * (term + S)) / (t + X)) / n);
rhs = (((t + X) / (term + S)) * term) / t;
if (lhs <= rhs)
{
W = rhs / lhs;
break;
}
/* Test if U <= f(S)/cg(X) */
y = (((U * (t + 1)) / term) * (t + S + 1)) / (t + X);
if ((double) n < S)
{
denom = t;
numer_lim = term + S;
}
else
{
denom = t - (double) n + S;
numer_lim = t + 1;
}
for (numer = t + S; numer >= numer_lim; numer -= 1)
{
y *= numer / denom;
denom -= 1;
}
W = exp(-log(random_fract()) / n); /* Generate W in advance */
if (exp(log(y) / n) <= (t + X) / t)
break;
}
*sta
```
<Overlap Ratio: 0.98067287043665>

---

--- 304 --
Question ID: 6f9314e685984e3426506069d34fd880694698b6_24
Original Code:
```
u8
PHY_GetTxPowerIndex_8188E(
	IN	PADAPTER		pAdapter,
	IN	u8				RFPath,
	IN	u8				Rate,	
	IN	CHANNEL_WIDTH	BandWidth,	
	IN	u8				Channel
	)
{
	PHAL_DATA_TYPE pHalData = GET_HAL_DATA(pAdapter);
	u8 base_index = 0;
	s8 by_rate_diff = 0, txPower = 0, limit = 0, track_diff = 0, extra_bias = 0;
	u8 txNum = phy_GetCurrentTxNum_8188E(pAdapter, Rate);
	BOOLEAN bIn24G = _FALSE;

	base_index = PHY_GetTxPowerIndexBase(pAdapter,RFPath, Rate, BandWidth, Channel, &bIn24G);

	by_rate_diff = PHY_GetTxPowerByRate(pAdapter, BAND_ON_2_4G, RFPath, txNum, Rate);
	limit = PHY_GetTxPowerLimit(pAdapter, pAdapter->registrypriv.RegPwrTblSel, (u8)(!bIn24G), pHalData->CurrentChannelBW, RFPath, Rate, pHalData->CurrentChannel);
	by_rate_diff = by_rate_diff > limit ? limit : by_rate_diff;

	track_diff = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);

	extra_bias = tx_power_extra_bias(RFPath, Rate, BandWidth, Channel);

	txPower = base_index + by_rate_diff + track_diff + extra_bias;

	if(txPower > MAX_POWER_INDEX)
		txPower = MAX_POWER_INDEX;

	if (0)
	DBG_871X("RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\n"
		, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);

	return (u8)txPower;	
}
```


Overlapping Code:
```
xPowerIndex_8188E(
IN PADAPTER pAdapter,
IN u8 RFPath,
IN u8 Rate, 
IN CHANNEL_WIDTH BandWidth, 
IN u8 Channel
)
{
PHAL_DATA_TYPE pHalData = GET_HAL_DATA(pAdapter);
u8 base_index = 0;
s8 by_rate_diff = 0, txPower = 0, limit = 0, track_diff = 0, extra_bias = 0;
u8 txNum = phy_GetCurrentTxNum_8188E(pAdapter, Rate);
BOOLEAN bIn24G = _FALSE;
base_index = PHY_GetTxPowerIndexBase(pAdapter,RFPath, Rate, BandWidth, Channel, &bIn24G);
by_rate_diff = PHY_GetTxPowerByRate(pAdapter, BAND_ON_2_4G, RFPath, txNum, Rate);
limit = PHY_GetTxPowerLimit(pAdapter, pAdapter->registrypriv.RegPwrTblSel, (u8)(!bIn24G), pHalData->CurrentChannelBW, RFPath, Rate, pHalData->CurrentChannel);
by_rate_diff = by_rate_diff > limit ? limit : by_rate_diff;
track_diff = PHY_GetTxPowerTrackingOffset(pAdapter, RFPath, Rate);
extra_bias = tx_power_extra_bias(RFPath, Rate, BandWidth, Channel);
txPower = base_index + by_rate_diff + track_diff + extra_bias;
if(txPower > MAX_POWER_INDEX)
txPower = MAX_POWER_INDEX;
if (0)
DBG_871X("RF-%c ch%d TxPwrIdx = %d(0x%X) [%2u %2d %2d %2d]\n"
, ((RFPath==0)?'A':'B'), Channel, txPower, txPower, base_index, by_rate_diff, track_diff, extra_bias);
return (u8)txPowe
```
<Overlap Ratio: 0.9865659109991604>

---

--- 305 --
Question ID: 0880d4e5f91c81d53d175ed8a7f74577d11d9936_8
Original Code:
```
static void end_frame(AVFilterLink *link)
{
    CropContext *crop = link->dst->priv;

    crop->var_values[VAR_N] += 1.0;
    avfilter_unref_buffer(link->cur_buf);
    avfilter_end_frame(link->dst->outputs[0]);
}
```


Overlapping Code:
```
_frame(AVFilterLink *link)
{
CropContext *crop = link->dst->priv;
crop->var_values[VAR_N] += 1.0;
avfilter_unref_buffer(link->cur_buf);
avfilter_end_f
```
<Overlap Ratio: 0.7692307692307693>

---

--- 306 --
Question ID: d06e5ec57792bc339dd38e05fcd492492bbd38db_0
Original Code:
```
namespace device {

struct CtapGetAssertionRequest;
struct CtapGetAssertionOptions;
struct CtapMakeCredentialRequest;
struct EnumerateRPsResponse;
class FidoDevice;
class FidoTask;

// Adaptor class from a |FidoDevice| to the |FidoAuthenticator| interface.
// Responsible for translating WebAuthn-level requests into serializations that
// can be passed to the device for transport.
class COMPONENT_EXPORT(DEVICE_FIDO) FidoDeviceAuthenticator
    : public FidoAuthenticator {
 public:
  explicit FidoDeviceAuthenticator(std::unique_ptr<FidoDevice> device);
  ~FidoDeviceAuthenticator() override;

  // FidoAuthenticator:
  void InitializeAuthenticator(base::OnceClosure callback) override;
  void ExcludeAppIdCredentialsBeforeMakeCredential(
      CtapMakeCredentialRequest request,
      base::OnceCallback<void(CtapDeviceResponseCode, absl::optional<bool>)>)
      override;
  void MakeCredential(CtapMakeCredentialRequest request,
                      MakeCredentialCallback callback) override;
  void GetAssertion(CtapGetAssertionRequest request,
                    CtapGetAssertionOptions options,
                    GetAssertionCallback callback) override;
  void GetNextAssertion(GetAssertionCallback callback) override;
  void GetTouch(base::OnceClosure callback) override;
  void GetPinRetries(GetRetriesCallback callback) override;
  void GetPINToken(std::string pin,
                   std::vector<pin::Permissions> permissions,
                   absl::optional<std::string> rp_id,
                   GetTokenCallback callback) override;
  void GetUvRetries(GetRetriesCallback callback) override;
  bool CanGetUvToken() override;
  void GetUvToken(std::vector<pin::Permissions> permissions,
                  absl::optional<std::string> rp_id,
                  GetTokenCallback callback) override;
  uint32_t CurrentMinPINLength() override;
  uint32_t NewMinPINLength() override;
  bool ForcePINChange() override;
  void SetPIN(const std::string& pin, SetPINCallback callback) override;
  void ChangePIN(const std::string& old_pin,
                 const std::string& new_pin,
                 SetPINCallback callback) override;
  PINUVDisposition PINUVDispositionForMakeCredential(
      const CtapMakeCredentialRequest& request,
      const FidoRequestHandlerBase::Observer* observer) override;

  // WillNeedPINToGetAssertion returns whether a PIN prompt will be needed to
  // serve the given request on this authenticator.
  PINUVDisposition PINUVDispositionForGetAssertion(
      const CtapGetAssertionRequest& request,
      const FidoRequestHandlerBase::Observer* observer) override;

  void GetCredentialsMetadata(const pin::TokenResponse& pin_token,
                              GetCredentialsMetadataCallback callback) override;
  void EnumerateCredentials(const pin::TokenResponse& pin_token,
                            EnumerateCredentialsCallback callback) override;
  void DeleteCredential(const pin::TokenResponse& pin_token,
                        const PublicKeyCredentialDescriptor& credential_id,
                        DeleteCredentialCallback callback) override;

  void GetModality(BioEnrollmentCallback callback) override;
  void GetSensorInfo(BioEnrollmentCallback callback) override;
  void BioEnrollFingerprint(const pin::TokenResponse&,
                            absl::optional<std::vector<uint8_t>> template_id,
                            BioEnrollmentCallback) override;
  void BioEnrollCancel(BioEnrollmentCallback) override;
  void BioEnrollEnumerate(const pin::TokenResponse&,
                          BioEnrollmentCallback) override;
  void BioEnrollRename(const pin::TokenResponse&,
                       std::vector<uint8_t> template_id,
                       std::string name,
                       BioEnrollmentCallback) override;
  void BioEnrollDelete(const pin::TokenResponse&,
                       std::vector<uint8_t> template_id,
                       BioEnrollmentCallback) override;
  void WriteLargeBlob(
      const std::vector<uint8_t>& large_blob,
      const LargeBlobKey& large_blob_key,
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      base::OnceCallback<void(CtapDeviceResponseCode)> callback) override;
  void ReadLargeBlob(const std::vector<LargeBlobKey>& large_blob_keys,
                     absl::optional<pin::TokenResponse> pin_uv_auth_token,
                     LargeBlobReadCallback callback) override;

  absl::optional<base::span<const int32_t>> GetAlgorithms() override;
  bool DiscoverableCredentialStorageFull() const override;

  void Reset(ResetCallback callback) override;
  void Cancel() override;
  std::string GetId() const override;
  std::string GetDisplayName() const override;
  ProtocolVersion SupportedProtocol() const override;
  bool SupportsHMACSecretExtension() const override;
  bool SupportsEnterpriseAttestation() const override;
  bool SupportsCredBlobOfSize(size_t num_bytes) const override;
  const absl::optional<AuthenticatorSupportedOptions>& Options() const override;
  absl::optional<FidoTransportProtocol> AuthenticatorTransport() const override;
  bool IsInPairingMode() const override;
  bool IsPaired() const override;
  bool RequiresBlePairingPin() const override;
#if defined(OS_WIN)
  bool IsWinNativeApiAuthenticator() const override;
#endif  // defined(OS_WIN)
#if defined(OS_MAC)
  bool IsTouchIdAuthenticator() const override;
#endif  // defined(OS_MAC)
#if BUILDFLAG(IS_CHROMEOS_ASH)
  bool IsChromeOSAuthenticator() const override;
#endif  // BUILDFLAG(IS_CHROMEOS_ASH)
  base::WeakPtr<FidoAuthenticator> GetWeakPtr() override;

  FidoDevice* device() { return device_.get(); }
  void SetTaskForTesting(std::unique_ptr<FidoTask> task);

 protected:
  void OnCtapMakeCredentialResponseReceived(
      MakeCredentialCallback callback,
      absl::optional<std::vector<uint8_t>> response_data);
  void OnCtapGetAssertionResponseReceived(
      GetAssertionCallback callback,
      absl::optional<std::vector<uint8_t>> response_data);

 private:
  using GetEphemeralKeyCallback =
      base::OnceCallback<void(CtapDeviceResponseCode,
                              absl::optional<pin::KeyAgreementResponse>)>;
  void InitializeAuthenticatorDone(base::OnceClosure callback);
  void GetEphemeralKey(GetEphemeralKeyCallback callback);
  void DoGetAssertion(CtapGetAssertionRequest request,
                      CtapGetAssertionOptions options,
                      GetAssertionCallback callback);
  void OnHaveEphemeralKeyForGetAssertion(
      CtapGetAssertionRequest request,
      CtapGetAssertionOptions options,
      GetAssertionCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<pin::KeyAgreementResponse> key);
  void OnHaveEphemeralKeyForGetPINToken(
      std::string pin,
      std::vector<pin::Permissions> permissions,
      absl::optional<std::string> rp_id,
      GetTokenCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<pin::KeyAgreementResponse> key);
  void OnHaveEphemeralKeyForSetPIN(
      std::string pin,
      SetPINCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<pin::KeyAgreementResponse> key);
  void OnHaveEphemeralKeyForChangePIN(
      std::string old_pin,
      std::string new_pin,
      SetPINCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<pin::KeyAgreementResponse> key);
  void OnHaveEphemeralKeyForUvToken(
      absl::optional<std::string> rp_id,
      std::vector<pin::Permissions> permissions,
      GetTokenCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<pin::KeyAgreementResponse> key);

  void FetchLargeBlobArray(
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      LargeBlobArrayReader large_blob_array_reader,
      base::OnceCallback<void(CtapDeviceResponseCode,
                              absl::optional<LargeBlobArrayReader>)> callback);
  void WriteLargeBlobArray(
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      LargeBlobArrayWriter large_blob_array_writer,
      base::OnceCallback<void(CtapDeviceResponseCode)> callback);
  void OnReadLargeBlobFragment(
      const size_t bytes_requested,
      LargeBlobArrayReader large_blob_array_reader,
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      base::OnceCallback<void(CtapDeviceResponseCode,
                              absl::optional<LargeBlobArrayReader>)> callback,
      CtapDeviceResponseCode status,
      absl::optional<LargeBlobsResponse> response);
  void OnWriteLargeBlobFragment(
      LargeBlobArrayWriter large_blob_array_writer,
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      base::OnceCallback<void(CtapDeviceResponseCode)> callback,
      CtapDeviceResponseCode status,
      absl::optional<LargeBlobsResponse> response);
  void OnHaveLargeBlobArrayForWrite(
      const std::vector<uint8_t>& large_blob,
      const LargeBlobKey& large_blob_key,
      absl::optional<pin::TokenResponse> pin_uv_auth_token,
      base::OnceCallback<void(CtapDeviceResponseCode)> callback,
      CtapDeviceResponseCode status,
      absl::optional<LargeBlobArrayReader> large_blob_array_reader);
  void OnHaveLargeBlobArrayForRead(
      const std::vector<LargeBlobKey>& large_blob_keys,
      LargeBlobReadCallback callback,
      CtapDeviceResponseCode status,
      absl::optional<LargeBlobArrayReader> large_blob_array_reader);

  template <typename... Args>
  void TaskClearProxy(base::OnceCallback<void(Args...)> callback, Args... args);
  template <typename... Args>
  void OperationClearProxy(base::OnceCallback<void(Args...)> callback,
                           Args... args);
  template <typename Task, typename Response, typename... RequestArgs>
  void RunTask(RequestArgs&&... request_args,
               base::OnceCallback<void(CtapDeviceResponseCode,
                                       absl::optional<Response>)> callback);
  template <typename Request, typename Response>
  void RunOperation(Request request,
                    base::OnceCallback<void(CtapDeviceResponseCode,
                                            absl::optional<Response>)> callback,
                    base::OnceCallback<absl::optional<Response>(
                        const absl::optional<cbor::Value>&)> parser,
                    bool (*string_fixup_predicate)(
                        const std::vector<const cbor::Value*>&) = nullptr);

  struct EnumerateCredentialsState;
  void OnEnumerateRPsDone(EnumerateCredentialsState state,
                          CtapDeviceResponseCode status,
                          absl::optional<EnumerateRPsResponse> response);
  void OnEnumerateCredentialsDone(
      EnumerateCredentialsState state,
      CtapDeviceResponseCode status,
      absl::optional<EnumerateCredentialsResponse> response);

  size_t max_large_blob_fragment_length();

  const std::unique_ptr<FidoDevice> device_;
  absl::optional<AuthenticatorSupportedOptions> options_;
  std::unique_ptr<FidoTask> task_;
  std::unique_ptr<GenericDeviceOperation> operation_;

  // The highest advertised PINUVAuthProtocol version that the authenticator
  // supports. This is guaranteed to be non-null after authenticator
  // initialization if |options_| indicates that PIN is supported.
  absl::optional<PINUVAuthProtocol> chosen_pin_uv_auth_protocol_;

  base::WeakPtrFactory<FidoDeviceAuthenticator> weak_factory_{this};

  DISALLOW_COPY_AND_ASSIGN(FidoDeviceAuthenticator);
};

}
```


Overlapping Code:
```
ce {
struct CtapGetAssertionRequest;
struct CtapGetAssertionOptions;
struct CtapMakeCredentialRequest;
struct EnumerateRPsResponse;
class FidoDevice;
class FidoTask;
// Adaptor class from a |FidoDevice| to the |FidoAuthenticator| interface.
// Responsible for translating WebAuthn-level requests into serializations that
// can be passed to the device for transport.
class COMPONENT_EXPORT(DEVICE_FIDO) FidoDeviceAuthenticator
: public FidoAuthenticator {
public:
explicit FidoDeviceAuthenticator(std::unique_ptr<FidoDevice> device);
~FidoDeviceAuthenticator() override;
// FidoAuthenticator:
void InitializeAuthenticator(base::OnceClosure callback) override;
void ExcludeAppIdCredentialsBeforeMakeCredential(
CtapMakeCredentialRequest request,
base::OnceCallback<void(CtapDeviceResponseCode, absl::optional<bool>)>)
override;
void MakeCredential(CtapMakeCredentialRequest request,
MakeCredentialCallback callback) override;
void GetAssertion(CtapGetAssertionRequest request,
CtapGetAssertionOptions options,
GetAssertionCallback callback) override;
void GetNextAssertion(GetAssertionCallback callback) override;
void GetTouch(base::OnceClosure callback) override;
void GetPinRetries(GetRetriesCallback callback) override;
void GetPINToken(std::string pin,
std::vector<pin::Permissions> permissions,
absl::optional<std::string> rp_id,
GetTokenCallback callback) override;
void GetUvRetries(GetRetriesCallback callback) override;
bool CanGetUvToken() override;
void GetUvToken(std::vector<pin::Permissions> permissions,
absl::optional<std::string> rp_id,
GetTokenCallback callback) override;
uint32_t CurrentMinPINLength() override;
uint32_t NewMinPINLength() override;
bool ForcePINChange() override;
void SetPIN(const std::string& pin, SetPINCallback callback) override;
void ChangePIN(const std::string& old_pin,
const std::string& new_pin,
SetPINCallback callback) override;
PINUVDisposition PINUVDispositionForMakeCredential(
const CtapMakeCredentialRequest& request,
const FidoRequestHandlerBase::Observer* observer) override;
// WillNeedPINToGetAssertion returns whether a PIN prompt will be needed to
// serve the given request on this authenticator.
PINUVDisposition PINUVDispositionForGetAss
```
<Overlap Ratio: 0.9905447996398019>

---

--- 307 --
Question ID: e4c7d7200b5781b1ac1b6c7451720aea4dcd40a8_3
Original Code:
```
int stlink_flashloader_start(stlink_t *sl, flash_loader_t *fl) {
  // disable DMA
  set_dma_state(sl, fl, 0);

  // wait for ongoing op to finish
  wait_flash_busy(sl);
  // Clear errors
  clear_flash_error(sl);

  if ((sl->flash_type == STM32_FLASH_TYPE_F2_F4) ||
      (sl->flash_type == STM32_FLASH_TYPE_F7) ||
      (sl->flash_type == STM32_FLASH_TYPE_L4_L4P)) {
    ILOG("Starting Flash write for F2/F4/F7/L4\n");

    // Flash loader initialisation
    if (stlink_flash_loader_init(sl, fl) == -1) {
      ELOG("stlink_flash_loader_init() == -1\n");
      return (-1);
    }

    unlock_flash_if(sl); // first unlock the cr

    int voltage;
    if (sl->version.stlink_v == 1) {
      WLOG("STLINK V1 cannot read voltage, use default voltage 3.2V\n");
      voltage = 3200;
    } else {
      voltage = stlink_target_voltage(sl);
    }

    if (voltage == -1) {
      ELOG("Failed to read Target voltage\n");
      return (-1);
    }

    if (sl->flash_type == STM32_FLASH_TYPE_L4_L4P) {
      // L4 does not have a byte-write mode
      if (voltage < 1710) {
        ELOG("Target voltage (%d mV) too low for flash writes!\n", voltage);
        return (-1);
      }
    } else {
      if (voltage > 2700) {
        ILOG("enabling 32-bit flash writes\n");
        write_flash_cr_psiz(sl, 2, BANK_1);
      } else {
        ILOG("Target voltage (%d mV) too low for 32-bit flash, "
             "using 8-bit flash writes\n",
             voltage);
        write_flash_cr_psiz(sl, 0, BANK_1);
      }
    }

    // set programming mode
    set_flash_cr_pg(sl, BANK_1);
  } else if (sl->flash_type == STM32_FLASH_TYPE_WB_WL ||
             sl->flash_type == STM32_FLASH_TYPE_G0 ||
             sl->flash_type == STM32_FLASH_TYPE_G4) {
    ILOG("Starting Flash write for WB/G0/G4\n");

    unlock_flash_if(sl);         // unlock flash if necessary
    set_flash_cr_pg(sl, BANK_1); // set PG 'allow programming' bit
  } else if (sl->flash_type == STM32_FLASH_TYPE_L0_L1) {
    ILOG("Starting Flash write for L0\n");

    uint32_t val;
    uint32_t flash_regs_base = get_stm32l0_flash_base(sl);

    // disable pecr protection
    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,
                         FLASH_L0_PEKEY1);
    stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,
                         FLASH_L0_PEKEY2);

    // check pecr.pelock is cleared
    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);
    if (val & (1 << 0)) {
      ELOG("pecr.pelock not clear\n");
      return (-1);
    }

    // unlock program memory
    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,
                         FLASH_L0_PRGKEY1);
    stlink_write_debug32(sl, flash_regs_base + FLASH_PRGKEYR_OFF,
                         FLASH_L0_PRGKEY2);

    // check pecr.prglock is cleared
    stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);
    if (val & (1 << 1)) {
      ELOG("pecr.prglock not clear\n");
      return (-1);
    }

    /* Flash loader initialisation */
    if (stlink_flash_loader_init(sl, fl) == -1) {
      // L0/L1 have fallback to soft write
      WLOG("stlink_flash_loader_init() == -1\n");
    }
  } else if ((sl->flash_type == STM32_FLASH_TYPE_F0_F1_F3) ||
             (sl->flash_type == STM32_FLASH_TYPE_F1_XL)) {
    ILOG("Starting Flash write for VL/F0/F3/F1_XL\n");

    // flash loader initialisation
    if (stlink_flash_loader_init(sl, fl) == -1) {
      ELOG("stlink_flash_loader_init() == -1\n");
      return (-1);
    }

    // unlock flash
    unlock_flash_if(sl);

    // set programming mode
    set_flash_cr_pg(sl, BANK_1);
    if (sl->flash_type == STM32_FLASH_TYPE_F1_XL) {
      set_flash_cr_pg(sl, BANK_2);
    }
  } else if (sl->flash_type == STM32_FLASH_TYPE_H7) {
    ILOG("Starting Flash write for H7\n");

    unlock_flash_if(sl);         // unlock the cr
    set_flash_cr_pg(sl, BANK_1); // set programming mode
    if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {
      set_flash_cr_pg(sl, BANK_2);
    }
    if (sl->chip_id != STM32_CHIPID_H7Ax) {
      // set parallelism
      write_flash_cr_psiz(sl, 3 /*64it*/, BANK_1);
      if (sl->chip_flags & CHIP_F_HAS_DUAL_BANK) {
        write_flash_cr_psiz(sl, 3 /*64bit*/, BANK_2);
      }
    }
  } else {
    ELOG("unknown coreid, not sure how to write: %x\n", sl->core_id);
    return (-1);
  }

  return (0);
}
```


Overlapping Code:
```
stlink_t *sl, flash_loader_t *fl) {
// disable DMA
set_dma_state(sl, fl, 0);
// wait for ongoing op to finish
wait_flash_busy(sl);
// Clear errors
clear_flash_error(sl);
if ((sl->flash_type == STM32_FLASH_TYPE_F2_F4) ||
(sl->flash_type == STM32_FLASH_TYPE_F7) ||
(sl->flash_type == STM32_FLASH_TYPE_L4_L4P)) {
ILOG("Starting Flash write for F2/F4/F7/L4\n");
// Flash loader initialisation
if (stlink_flash_loader_init(sl, fl) == -1) {
ELOG("stlink_flash_loader_init() == -1\n");
return (-1);
}
unlock_flash_if(sl); // first unlock the cr
int voltage;
if (sl->version.stlink_v == 1) {
WLOG("STLINK V1 cannot read voltage, use default voltage 3.2V\n");
voltage = 3200;
} else {
voltage = stlink_target_voltage(sl);
}
if (voltage == -1) {
ELOG("Failed to read Target voltage\n");
return (-1);
}
if (sl->flash_type == STM32_FLASH_TYPE_L4_L4P) {
// L4 does not have a byte-write mode
if (voltage < 1710) {
ELOG("Target voltage (%d mV) too low for flash writes!\n", voltage);
return (-1);
}
} else {
if (voltage > 2700) {
ILOG("enabling 32-bit flash writes\n");
write_flash_cr_psiz(sl, 2, BANK_1);
} else {
ILOG("Target voltage (%d mV) too low for 32-bit flash, "
"using 8-bit flash writes\n",
voltage);
write_flash_cr_psiz(sl, 0, BANK_1);
}
}
// set programming mode
set_flash_cr_pg(sl, BANK_1);
} else if (sl->flash_type == STM32_FLASH_TYPE_WB_WL ||
sl->flash_type == STM32_FLASH_TYPE_G0 ||
sl->flash_type == STM32_FLASH_TYPE_G4) {
ILOG("Starting Flash write for WB/G0/G4\n");
unlock_flash_if(sl); // unlock flash if necessary
set_flash_cr_pg(sl, BANK_1); // set PG 'allow programming' bit
} else if (sl->flash_type == STM32_FLASH_TYPE_L0_L1) {
ILOG("Starting Flash write for L0\n");
uint32_t val;
uint32_t flash_regs_base = get_stm32l0_flash_base(sl);
// disable pecr protection
stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,
FLASH_L0_PEKEY1);
stlink_write_debug32(sl, flash_regs_base + FLASH_PEKEYR_OFF,
FLASH_L0_PEKEY2);
// check pecr.pelock is cleared
stlink_read_debug32(sl, flash_regs_base + FLASH_PECR_OFF, &val);
if (val & (1 << 0))
```
<Overlap Ratio: 0.9747979077508322>

---

--- 308 --
Question ID: a97f5987d227a45f513330e865b644e31b80f769_7
Original Code:
```
int PMI2_Finalize(void)
{
    int pmi2_errno = PMI2_SUCCESS;
    int rc;
    const char *errmsg;
    PMI2_Command cmd = { 0 };

    if (PMI2_initialized > SINGLETON_INIT_BUT_NO_PM) {
        pmi2_errno = PMIi_WriteSimpleCommandStr(PMI2_fd, &cmd, FINALIZE_CMD, NULL);
        if (pmi2_errno)
            PMI2U_ERR_POP(pmi2_errno);
        pmi2_errno = PMIi_ReadCommandExp(PMI2_fd, &cmd, FINALIZERESP_CMD, &rc, &errmsg);
        if (pmi2_errno)
            PMI2U_ERR_POP(pmi2_errno);
        PMI2U_ERR_CHKANDJUMP1(rc, pmi2_errno, PMI2_ERR_OTHER, "**pmi2_finalize",
                              "**pmi2_finalize %s", errmsg ? errmsg : "unknown");
        PMI2U_Free(cmd.command);
        freepairs(cmd.pairs, cmd.nPairs);

        shutdown(PMI2_fd, SHUT_RDWR);
        close(PMI2_fd);
    }

  fn_exit:
    return pmi2_errno;
  fn_fail:

    goto fn_exit;
}
```


Overlapping Code:
```
lize(void)
{
int pmi2_errno = PMI2_SUCCESS;
int rc;
const char *errmsg;
PMI2_Command cmd = { 0 };
if (PMI2_initialized > SINGLETON_INIT_BUT_NO_PM) {
pmi2_errno = PMIi_WriteSimpleCommandStr(PMI2_fd, &cmd, FINALIZE_CMD, NULL);
if (pmi2_errno)
PMI2U_ERR_POP(pmi2_errno);
pmi2_errno = PMIi_ReadCommandExp(PMI2_fd, &cmd, FINALIZERESP_CMD, &rc, &errmsg);
if (pmi2_errno)
PMI2U_ERR_POP(pmi2_errno);
PMI2U_ERR_CHKANDJUMP1(rc, pmi2_errno, PMI2_ERR_OTHER, "**pmi2_finalize",
"**pmi2_finalize %s", errmsg ? errmsg : "unknown");
PMI2U_Free(cmd.command);
freepairs(cmd.pairs, cmd.nPairs);
shutdown(PMI2_fd, SHUT_RDWR);
close(PMI2_fd);
}
fn_exit:
return pmi2_errno;
fn_fail:
goto fn_exit;
```
<Overlap Ratio: 0.9782293178519593>

---

--- 309 --
Question ID: 02207e092773898d9877205d10919c290864086b_1
Original Code:
```
static ngx_int_t ngx_http_redirectionio_create_ctx_handler(ngx_http_request_t *r) {
    ngx_http_redirectionio_ctx_t    *ctx;
    ngx_http_redirectionio_conf_t   *conf;
    ngx_pool_cleanup_t              *cln;

    // Disallow in sub request
    if (r != r->main) {
        return NGX_DECLINED;
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_redirectionio_module);

    if (conf->enable == NGX_HTTP_REDIRECTIONIO_OFF) {
        return NGX_DECLINED;
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_redirectionio_module);

    if (ctx == NULL) {
        ctx = (ngx_http_redirectionio_ctx_t *) ngx_pcalloc(r->pool, sizeof(ngx_http_redirectionio_ctx_t));

        if (ctx == NULL) {
            return NGX_DECLINED;
        }

        ctx->resource = NULL;
        ctx->matched_action_status = API_NOT_CALLED;
        ctx->request = NULL;
        ctx->action = NULL;
        ctx->response_headers = NULL;
        ctx->body_filter = NULL;
        ctx->action_string = NULL;
        ctx->action_string_len = 0;
        ctx->action_string_readed = 0;
        ctx->connection_error = 0;
        ctx->wait_for_connection = 0;
        ctx->last_buffer_sent = 0;
        ctx->read_handler = ngx_http_redirectionio_read_dummy_handler;
        ctx->project_key.len = 0;
        ctx->scheme.len = 0;
        ctx->host.len = 0;

        if (ngx_http_complex_value(r, conf->project_key, &ctx->project_key) != NGX_OK) {
            return NGX_DECLINED;
        }

        if (conf->scheme != NULL && ngx_http_complex_value(r, conf->scheme, &ctx->scheme) != NGX_OK) {
            return NGX_DECLINED;
        }

        if (conf->host != NULL && ngx_http_complex_value(r, conf->host, &ctx->host) != NGX_OK) {
            return NGX_DECLINED;
        }

        cln = ngx_pool_cleanup_add(r->pool, 0);

        if (cln == NULL) {
            return NGX_DECLINED;
        }

        cln->data = ctx;
        cln->handler = ngx_http_redirectionio_context_cleanup;

        ngx_http_set_ctx(r, ctx, ngx_http_redirectionio_module);

        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "http redirectionio init context");

        redirectionio_log_init_with_callback(ngx_http_redirectionio_log_callback, r->connection->log);
    }

    return NGX_DECLINED;
}
```


Overlapping Code:
```
rectionio_create_ctx_handler(ngx_http_request_t *r) {
ngx_http_redirectionio_ctx_t *ctx;
ngx_http_redirectionio_conf_t *conf;
ngx_pool_cleanup_t *cln;
// Disallow in sub request
if (r != r->main) {
return NGX_DECLINED;
}
conf = ngx_http_get_module_loc_conf(r, ngx_http_redirectionio_module);
if (conf->enable == NGX_HTTP_REDIRECTIONIO_OFF) {
return NGX_DECLINED;
}
ctx = ngx_http_get_module_ctx(r, ngx_http_redirectionio_module);
if (ctx == NULL) {
ctx = (ngx_http_redirectionio_ctx_t *) ngx_pcalloc(r->pool, sizeof(ngx_http_redirectionio_ctx_t));
if (ctx == NULL) {
return NGX_DECLINED;
}
ctx->resource = NULL;
ctx->matched_action_status = API_NOT_CALLED;
ctx->request = NULL;
ctx->action = NULL;
ctx->response_headers = NULL;
ctx->body_filter = NULL;
ctx->action_string = NULL;
ctx->action_string_len = 0;
ctx->action_string_readed = 0;
ctx->connection_error = 0;
ctx->wait_for_connection = 0;
ctx->last_buffer_sent = 0;
ctx->read_handler = ngx_http_redirectionio_read_dummy_handler;
ctx->project_key.len = 0;
ctx->scheme.len = 0;
ctx->host.len = 0;
if (ngx_http_complex_value(r, conf->project_key, &ctx->project_key) != NGX_OK) {
return NGX_DECLINED;
}
if (conf->scheme != NULL && ngx_http_complex_value(r, conf->scheme, &ctx->scheme) != NGX_OK) {
return NGX_DECLINED;
}
if (conf->host != NULL && ngx_http_complex_value(r, conf->host, &ctx->host) != NGX_OK) {
return NGX_DECLINED;
}
cln = ngx_pool_cleanup_add(r->pool, 0);
if (cln == NULL) {
return NGX_DECLINED;
}
cln->data = ctx;
cln->handler = ngx_http_redirectionio_context_cleanup;
ngx_http_set_ctx(r, ctx, ngx_http_redirectionio_module);
ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "http redirectionio init context");
redirectionio_log_init_with_callback(ngx_http_redirectionio_log_callback, r-
```
<Overlap Ratio: 0.9603260869565218>

---

--- 310 --
Question ID: 0309fd79ec3c0b5bbfbd2a599824a0d119a48388_0
Original Code:
```
int
m88k_dmx_print(u_int t, u_int d, u_int a, u_int no)
{
	static const u_int addr_mod[16] = {
		0, 3, 2, 2, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0
	};
	static const char *mode[16]  = {
		"?", ".b", ".b", ".h", ".b", "?", "?", "?",
		".b", "?", "?" , "?" , ".h" , "?", "?", ""
	};
	static const u_int mask[16] = {
		0, 0xff, 0xff00, 0xffff,
		0xff0000, 0, 0, 0,
		0xff000000, 0, 0, 0,
		0xffff0000, 0, 0, 0xffffffff
	};
	static const u_int shift[16] = {
		0,  0, 8, 0, 16, 0, 0, 0,
		24, 0, 0, 0, 16, 0, 0, 0
	};
	int reg = DMT_DREGBITS(t);

	if (ISSET(t, DMT_LOCKBAR)) {
		db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
		    DMT_ENBITS(t) == 0x0f ? "" : ".bu",
		    ISSET(t, DMT_DAS) ? "" : ".usr", reg,
		    ((t >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);
		return 1;
	} else if (DMT_ENBITS(t) == 0xf) {
		/* full or double word */
		if (ISSET(t, DMT_WRITE)) {
			if (ISSET(t, DMT_DOUB1) && no == 2)
				db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", a);
			else
				db_printf("st%s (0x%x) -> mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", d, a);
		} else {
			/* load */
			if (ISSET(t, DMT_DOUB1) && no == 2)
				db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a, reg+1, a+4);
			else
				db_printf("ld%s r%d <- mem(0x%x)",
				    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
		}
	} else {
		/* fractional word - check if load or store */
		a += addr_mod[DMT_ENBITS(t)];
		if (ISSET(t, DMT_WRITE))
			db_printf("st%s%s (0x%x) -> mem(0x%x)",
			    mode[DMT_ENBITS(t)],
			    ISSET(t, DMT_DAS) ? "" : ".usr",
			    (d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)],
			    a);
		else
			db_printf("ld%s%s%s r%d <- mem(0x%x)",
			    mode[DMT_ENBITS(t)],
			    ISSET(t, DMT_SIGNED) ? "" : "u",
			    ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
	}
	return (0);
}
```


Overlapping Code:
```
8k_dmx_print(u_int t, u_int d, u_int a, u_int no)
{
static const u_int addr_mod[16] = {
0, 3, 2, 2, 1, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0
};
static const char *mode[16] = {
"?", ".b", ".b", ".h", ".b", "?", "?", "?",
".b", "?", "?" , "?" , ".h" , "?", "?", ""
};
static const u_int mask[16] = {
0, 0xff, 0xff00, 0xffff,
0xff0000, 0, 0, 0,
0xff000000, 0, 0, 0,
0xffff0000, 0, 0, 0xffffffff
};
static const u_int shift[16] = {
0, 0, 8, 0, 16, 0, 0, 0,
24, 0, 0, 0, 16, 0, 0, 0
};
int reg = DMT_DREGBITS(t);
if (ISSET(t, DMT_LOCKBAR)) {
db_printf("xmem%s%s r%d(0x%x) <-> mem(0x%x),",
DMT_ENBITS(t) == 0x0f ? "" : ".bu",
ISSET(t, DMT_DAS) ? "" : ".usr", reg,
((t >> 2 & 0xf) == 0xf) ? d : (d & 0xff), a);
return 1;
} else if (DMT_ENBITS(t) == 0xf) {
/* full or double word */
if (ISSET(t, DMT_WRITE)) {
if (ISSET(t, DMT_DOUB1) && no == 2)
db_printf("st.d%s -> mem(0x%x) (** restart sxip **)",
ISSET(t, DMT_DAS) ? "" : ".usr", a);
else
db_printf("st%s (0x%x) -> mem(0x%x)",
ISSET(t, DMT_DAS) ? "" : ".usr", d, a);
} else {
/* load */
if (ISSET(t, DMT_DOUB1) && no == 2)
db_printf("ld.d%s r%d <- mem(0x%x), r%d <- mem(0x%x)",
ISSET(t, DMT_DAS) ? "" : ".usr", reg, a, reg+1, a+4);
else
db_printf("ld%s r%d <- mem(0x%x)",
ISSET(t, DMT_DAS) ? "" : ".usr", reg, a);
}
} else {
/* fractional word - check if load or store */
a += addr_mod[DMT_ENBITS(t)];
if (ISSET(t, DMT_WRITE))
db_printf("st%s%s (0x%x) -> mem(0x%x)",
mode[DMT_ENBITS(t)],
ISSET(t, DMT_DAS) ? "" : ".usr",
(d & mask[DMT_ENBITS(t)]) >> shift[DMT_ENBITS(t)],
a);
else
db_printf("ld%s%s%s r%d <- mem(0x%x)",
mode[DMT_ENBITS(t)],
ISSET(t, DMT_SIGNED) ? "" : "u",
ISSET(t, DMT_DAS) ? "" : ".usr", reg,
```
<Overlap Ratio: 0.9844868735083532>

---

--- 311 --
Question ID: baa35db61c142aea924b784e3dc1fdcd090aaa66_9
Original Code:
```
static int set_joy_b_x_axis_name(const char *val,void *param)
{
    util_string_set(&joy_b.axis[HID_X_AXIS].name, val);
    if (joy_done_init) {
        setup_axis_mapping(&joy_b);
    }
    return 0;
}
```


Overlapping Code:
```
ame(const char *val,void *param)
{
util_string_set(&joy_b.axis[HID_X_AXIS].name, val);
if (joy_done_init) {
setup_axis_mapping(&joy_b);
}
```
<Overlap Ratio: 0.7696629213483146>

---

--- 312 --
Question ID: ec9f8cf3d018e645732e3f302665c09b0e3c6bee_110
Original Code:
```
int func_203(int iParam0)
{
	int iVar0;
	
	if (iParam0 == -1)
	{
		iParam0 = func_186();
	}
	if (iParam0 == -1)
	{
		return 0;
	}
	iVar0 = func_205(&(Global_110945[iParam0 /*10*/].f_9), 1, 4, 0, 0);
	if (!iVar0 == 1)
	{
		return 0;
	}
	func_204(iParam0);
	return 1;
}
```


Overlapping Code:
```
203(int iParam0)
{
int iVar0;

if (iParam0 == -1)
{
iParam0 = func_186();
}
if (iParam0 == -1)
{
return 0;
}
iVar0 = func_205(&(Global_110945[iParam0 /*10*/].f_9), 1, 4, 0, 0);
if (!iVar0 == 1)
{
return
```
<Overlap Ratio: 0.8178137651821862>

---

--- 313 --
Question ID: b7b6b3c26b1c6961c31259308732347697676b71_17
Original Code:
```
ssize_t
send (int fd, const void *buf, size_t n, int flags)
{
  ssize_t size;
  const char *func_str;
  u32 sid = ldp_sid_from_fd (fd);

  if ((errno = -ldp_init ()))
    return -1;

  if (sid != INVALID_SESSION_ID)
    {

      func_str = "vppcom_session_sendto";

      if (LDP_DEBUG > 2)
	clib_warning ("LDP<%d>: fd %d (0x%x): calling %s(): sid %u (0x%x), "
		      "buf %p, n %u, flags 0x%x",
		      getpid (), fd, fd, func_str, sid, sid, buf, n, flags);

      size = vppcom_session_sendto (sid, (void *) buf, n, flags, NULL);
      if (size < VPPCOM_OK)
	{
	  errno = -size;
	  size = -1;
	}
    }
  else
    {
      func_str = "libc_send";

      if (LDP_DEBUG > 2)
	clib_warning ("LDP<%d>: fd %d (0x%x): calling %s(): "
		      "buf %p, n %u, flags 0x%x",
		      getpid (), fd, fd, func_str, buf, n, flags);

      size = libc_send (fd, buf, n, flags);
    }

  if (LDP_DEBUG > 2)
    {
      if (size < 0)
	{
	  int errno_val = errno;
	  perror (func_str);
	  clib_warning ("LDP<%d>: ERROR: fd %d (0x%x): %s() failed! "
			"rv %d, errno = %d", getpid (), fd, fd,
			func_str, size, errno_val);
	  errno = errno_val;
	}
      else
	clib_warning ("LDP<%d>: fd %d (0x%x): returning %d (0x%x)",
		      getpid (), fd, fd, size, size);
    }
  return size;
}
```


Overlapping Code:
```
id *buf, size_t n, int flags)
{
ssize_t size;
const char *func_str;
u32 sid = ldp_sid_from_fd (fd);
if ((errno = -ldp_init ()))
return -1;
if (sid != INVALID_SESSION_ID)
{
func_str = "vppcom_session_sendto";
if (LDP_DEBUG > 2)
clib_warning ("LDP<%d>: fd %d (0x%x): calling %s(): sid %u (0x%x), "
"buf %p, n %u, flags 0x%x",
getpid (), fd, fd, func_str, sid, sid, buf, n, flags);
size = vppcom_session_sendto (sid, (void *) buf, n, flags, NULL);
if (size < VPPCOM_OK)
{
errno = -size;
size = -1;
}
}
else
{
func_str = "libc_send";
if (LDP_DEBUG > 2)
clib_warning ("LDP<%d>: fd %d (0x%x): calling %s(): "
"buf %p, n %u, flags 0x%x",
getpid (), fd, fd, func_str, buf, n, flags);
size = libc_send (fd, buf, n, flags);
}
if (LDP_DEBUG > 2)
{
if (size < 0)
{
int errno_val = errno;
perror (func_str);
clib_warning ("LDP<%d>: ERROR: fd %d (0x%x): %s() failed! "
"rv %d, errno = %d", getpid (), fd, fd,
func_str, size, errno_val);
errno = errno_val;
}
else
clib_warning ("LDP<%d>: fd %d (0x%x): returning %d (0x%x)",
getpid (), fd, fd, size, size);
}
return size;
}
```
<Overlap Ratio: 0.9724011039558418>

---

--- 314 --
Question ID: 6722eeed6406260589589bfff536811d23577508_0
Original Code:
```
class ProgramActions : public QObject
{
    Q_OBJECT
public:
    explicit ProgramActions(QObject* parent = nullptr);
    ~ProgramActions();
    bool authorization(QMap<QString, QLineEdit*>* lineEdits);
    bool registration(QMap<QString, QLineEdit*>* lineEdits);
    void clearFields(QMap<QString, QLineEdit*>* lineEdits);
    void checkAnswers(QMap<QString, QLineEdit*>* lineEdits, QMap<QString, QLabel*>* labels);
    void clearTaskList(QMap<QString, QLabel*>* labels);
    void setTasks(QMap<QString, QLabel*>* labels);
    void setResult(QMap<QString, QLabel*>* results, QMap<QString, QLabel*>* labels);
    void clearAnswers();

private:
    bool validator(QMap<QString, QLineEdit*>* lineEdits);
    QString getTasks();
    QMap<QString, QString> getFields(QMap<QString, QLineEdit*>* lineEdits);
    void setAnswer(QString task, int answer);

    ProgramModel* myDatabase;
    QMap<QString, int> answers;
    QMap<QString, bool> myResult;
}
```


Overlapping Code:
```
gramActions : public QObject
{
Q_OBJECT
public:
explicit ProgramActions(QObject* parent = nullptr);
~ProgramActions();
bool authorization(QMap<QString, QLineEdit*>* lineEdits);
bool registration(QMap<QString, QLineEdit*>* lineEdits);
void clearFields(QMap<QString, QLineEdit*>* lineEdits);
void checkAnswers(QMap<QString, QLineEdit*>* lineEdits, QMap<QString, QLabel*>* labels);
void clearTaskList(QMap<QString, QLabel*>* labels);
void setTasks(QMap<QString, QLabel*>* labels);
void setResult(QMap<QString, QLabel*>* results, QMap<QString, QLabel*>* labels);
void clearAnswers();
private:
bool validator(QMap<QString, QLineEdit*>* lineEdits);
QString getTasks();
QMap<QString, QString> getFields(QMap<QString, QLineEdit*>* lineEdits);
void setAnswer(QString task, int answer);
ProgramModel* myDatabase;
QMap<QString, int> answers;
QMap<QString, bool>
```
<Overlap Ratio: 0.9758897818599311>

---

--- 315 --
Question ID: 02be4bbfa4a3e3d1ea5e4f4bea0b02314529a934_19
Original Code:
```
int bn_quotient_remainder_quot_wanted(x,y,z,zmax)
     Bignum *x, *y, *z, *zmax;
{
  BOOL sx = BignumPos(x);
  BOOL sy = BignumPos(y);
  int value;
  
  if (!sx) bn_negate(x);
  if (!sy) bn_negate(y);
  value = bn_div_mod_quot_wanted(x,y,z,zmax);
  if (!sx) bn_negate(x);
  if (!sy) bn_negate(y);
  if (!value) {
    if (sx^sy)
      bn_negate(z);
    bn_canonize(z);
  }
  return value;
}
```


Overlapping Code:
```
quotient_remainder_quot_wanted(x,y,z,zmax)
Bignum *x, *y, *z, *zmax;
{
BOOL sx = BignumPos(x);
BOOL sy = BignumPos(y);
int value;

if (!sx) bn_negate(x);
if (!sy) bn_negate(y);
value = bn_div_mod_quot_wanted(x,y,z,zmax);
if (!sx) bn_negate(x);
if (!sy) bn_negate(y);
if (!value) {
if (sx^sy)
bn_negat
```
<Overlap Ratio: 0.8670520231213873>

---

--- 316 --
Question ID: da05cec1904a0fdc75ac90ff014b6544ee4eb41f_13
Original Code:
```
void light_ctl_work_handler(struct k_work *work)
{
    struct bt_mesh_light_ctl_srv *srv =
        CONTAINER_OF(work, struct bt_mesh_light_ctl_srv, transition.timer.work);
    struct bt_mesh_msg_ctx *ctx = NULL;
    bt_mesh_light_server_state_change_t change = {0};

    if (srv == NULL || srv->state == NULL ||
            srv->transition.timer.work._reserved == NULL) {
        BT_ERR("%s, Invalid parameter", __func__);
        return;
    }

    bt_mesh_light_server_lock();

    ctx = (struct bt_mesh_msg_ctx *)srv->transition.timer.work._reserved;

    if (srv->transition.just_started) {
        srv->transition.just_started = false;
        if (srv->transition.counter == 0U) {
            change.ctl_set.lightness = srv->state->lightness;
            change.ctl_set.temperature = srv->state->temperature;
            change.ctl_set.delta_uv = srv->state->delta_uv;
            bt_mesh_lighting_server_cb_evt_to_btc(
                BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));
            bt_mesh_atomic_clear_bit(srv->transition.flag, BLE_MESH_TRANS_TIMER_START);
        } else {
            transition_timer_start(&srv->transition);
        }

        bt_mesh_light_server_unlock();
        return;
    }

    if (srv->transition.counter != 0U) {
        srv->transition.counter--;
        srv->state->lightness -= srv->tt_delta_lightness;
        srv->state->temperature -= srv->tt_delta_temperature;
        srv->state->delta_uv -= srv->tt_delta_delta_uv;
    }

    if (srv->transition.counter == 0U) {
        transition_timer_stop(&srv->transition);
        srv->state->lightness = srv->state->target_lightness;
        srv->state->temperature = srv->state->target_temperature;
        srv->state->delta_uv = srv->state->target_delta_uv;
    }

    change.ctl_set.lightness = srv->state->lightness;
    change.ctl_set.temperature = srv->state->temperature;
    change.ctl_set.delta_uv = srv->state->delta_uv;
    bt_mesh_lighting_server_cb_evt_to_btc(
        BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));

    light_ctl_publish(srv->model, BLE_MESH_MODEL_OP_LIGHT_CTL_STATUS);

    bt_mesh_light_server_unlock();
    return;
}
```


Overlapping Code:
```
id light_ctl_work_handler(struct k_work *work)
{
struct bt_mesh_light_ctl_srv *srv =
CONTAINER_OF(work, struct bt_mesh_light_ctl_srv, transition.timer.work);
struct bt_mesh_msg_ctx *ctx = NULL;
bt_mesh_light_server_state_change_t change = {0};
if (srv == NULL || srv->state == NULL ||
srv->transition.timer.work._reserved == NULL) {
BT_ERR("%s, Invalid parameter", __func__);
return;
}
bt_mesh_light_server_lock();
ctx = (struct bt_mesh_msg_ctx *)srv->transition.timer.work._reserved;
if (srv->transition.just_started) {
srv->transition.just_started = false;
if (srv->transition.counter == 0U) {
change.ctl_set.lightness = srv->state->lightness;
change.ctl_set.temperature = srv->state->temperature;
change.ctl_set.delta_uv = srv->state->delta_uv;
bt_mesh_lighting_server_cb_evt_to_btc(
BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));
bt_mesh_atomic_clear_bit(srv->transition.flag, BLE_MESH_TRANS_TIMER_START);
} else {
transition_timer_start(&srv->transition);
}
bt_mesh_light_server_unlock();
return;
}
if (srv->transition.counter != 0U) {
srv->transition.counter--;
srv->state->lightness -= srv->tt_delta_lightness;
srv->state->temperature -= srv->tt_delta_temperature;
srv->state->delta_uv -= srv->tt_delta_delta_uv;
}
if (srv->transition.counter == 0U) {
transition_timer_stop(&srv->transition);
srv->state->lightness = srv->state->target_lightness;
srv->state->temperature = srv->state->target_temperature;
srv->state->delta_uv = srv->state->target_delta_uv;
}
change.ctl_set.lightness = srv->state->lightness;
change.ctl_set.temperature = srv->state->temperature;
change.ctl_set.delta_uv = srv->state->delta_uv;
bt_mesh_lighting_server_cb_evt_to_btc(
BTC_BLE_MESH_EVT_LIGHTING_SERVER_STATE_CHANGE, srv->model, ctx, (const u8_t *)&change, sizeof(change));
light_ctl_publish(srv->model, BLE_MESH_MODEL_OP_LIGHT_CTL_STATUS);
bt_mesh_light_s
```
<Overlap Ratio: 0.9859885832900882>

---

--- 317 --
Question ID: 6558ef2767245d284afe4f62fd73ebc226238328_2
Original Code:
```
void obs_ntr_connection_create(struct ntr_data *owner_data)
{
	struct ntr_connection_data *temp_connection_data = bzalloc(sizeof(struct ntr_connection_data));

	for (int screen_index = 0; screen_index < SCREEN_COUNT; screen_index++)
	{
		temp_connection_data->uncompressed_buffer[screen_index] = bzalloc(SCREEN_WIDTH[screen_index] * SCREEN_HEIGHT[screen_index] * 4);

		pthread_mutex_init_value(&temp_connection_data->buffer_mutex[screen_index]);
		pthread_mutex_init(&temp_connection_data->buffer_mutex[screen_index], NULL);
	}

	shared_connection_data = temp_connection_data;

	shared_connection_data->net_thread_exited = false;
	shared_connection_data->net_thread_started = true;
	pthread_create(&shared_connection_data->net_thread, NULL, obs_ntr_net_thread_run, shared_connection_data);
}
```


Overlapping Code:
```
eate(struct ntr_data *owner_data)
{
struct ntr_connection_data *temp_connection_data = bzalloc(sizeof(struct ntr_connection_data));
for (int screen_index = 0; screen_index < SCREEN_COUNT; screen_index++)
{
temp_connection_data->uncompressed_buffer[screen_index] = bzalloc(SCREEN_WIDTH[screen_index] * SCREEN_HEIGHT[screen_index] * 4);
pthread_mutex_init_value(&temp_connection_data->buffer_mutex[screen_index]);
pthread_mutex_init(&temp_connection_data->buffer_mutex[screen_index], NULL);
}
shared_connection_data = temp_connection_data;
shared_connection_data->net_thread_exited = false;
shared_connection_data->net_thread_started = true;
pthread_create(&shared_connection_data->net_thread, NULL, ob
```
<Overlap Ratio: 0.9043927648578811>

---

--- 318 --
Question ID: 5cf119a86d37cab0de968edd113b43caf0d6a264_8
Original Code:
```
static void surface_state_move(struct wlr_surface_state *state,
		struct wlr_surface_state *next) {
	surface_state_copy(state, next);

	if (next->committed & WLR_SURFACE_STATE_BUFFER) {
		surface_state_set_buffer(state, next->buffer_resource);
		surface_state_reset_buffer(next);
		next->dx = next->dy = 0;
	}
	if (next->committed & WLR_SURFACE_STATE_SURFACE_DAMAGE) {
		pixman_region32_clear(&next->surface_damage);
	}
	if (next->committed & WLR_SURFACE_STATE_BUFFER_DAMAGE) {
		pixman_region32_clear(&next->buffer_damage);
	}
	if (next->committed & WLR_SURFACE_STATE_FRAME_CALLBACK_LIST) {
		wl_list_insert_list(&state->frame_callback_list,
			&next->frame_callback_list);
		wl_list_init(&next->frame_callback_list);
	}

	next->committed = 0;
}
```


Overlapping Code:
```
urface_state_move(struct wlr_surface_state *state,
struct wlr_surface_state *next) {
surface_state_copy(state, next);
if (next->committed & WLR_SURFACE_STATE_BUFFER) {
surface_state_set_buffer(state, next->buffer_resource);
surface_state_reset_buffer(next);
next->dx = next->dy = 0;
}
if (next->committed & WLR_SURFACE_STATE_SURFACE_DAMAGE) {
pixman_region32_clear(&next->surface_damage);
}
if (next->committed & WLR_SURFACE_STATE_BUFFER_DAMAGE) {
pixman_region32_clear(&next->buffer_damage);
}
if (next->committed & WLR_SURFACE_STATE_FRAME_CALLBACK_LIST) {
wl_list_insert_list(&state->frame_callback_list,
&next->frame_callback_list);
wl_list_init(&next->frame_callback_list);
}
next->committed = 0;
```
<Overlap Ratio: 0.9790209790209791>

---

--- 319 --
Question ID: 9e9e48b7c876ca573c178dd4fdbdde09cfe16e77_0
Original Code:
```
void machine_hw_spi_init_internal(
    machine_hw_spi_obj_t    *self,
    int8_t                  host,
    int32_t                 baudrate,
    int8_t                  polarity,
    int8_t                  phase,
    int8_t                  firstbit,
    int8_t                  sck,
    int8_t                  mosi,
    int8_t                  miso,
    int8_t                  cs,
    int8_t                  duplex,
	uint8_t					queue_size,
	uint8_t					new) {


    esp_err_t ret;

    self->state = MACHINE_HW_SPI_STATE_DEINIT;

	if ((baudrate <= 0) || (baudrate > 80000000)) {
        mp_raise_ValueError("SPI baudrate must be >0 & <=80000000");
	}

	// Host initialization
	if ((host != HSPI_HOST) && (host != VSPI_HOST)) {
		mp_raise_ValueError("SPI host must be either HSPI(1) or VSPI(2)");
	}
	if ((SPIbus_configs[VSPI_HOST] == NULL) && (host == VSPI_HOST)) {
		mp_raise_ValueError("SPI host must be HSPI(1), VSPI(2) used by SPIRAM");
	}

    int used_spi = spi_host_used_by_sdspi();
    if ((used_spi != 0) && (used_spi == host)) {
        // change spi host
        if (host == VSPI_HOST) {
    		mp_raise_ValueError("SPI host must be HSPI(1), VSPI(2) used by SDCard driver");
        }
        else {
    		mp_raise_ValueError("SPI host must be VSPI(2), HSPI(1) used by SDCard driver");
        }
    }

    self->spi.spihost = host;
    self->spi.buscfg = SPIbus_configs[self->spi.spihost];

    // Init pins
    if (cs >= 0) {
		gpio_pad_select_gpio(cs);
		gpio_set_direction(cs, GPIO_MODE_OUTPUT);
		gpio_set_level(cs, 1);
    }
    gpio_pad_select_gpio(miso);
    gpio_pad_select_gpio(mosi);
    gpio_pad_select_gpio(sck);
    gpio_set_direction(miso, GPIO_MODE_INPUT);
    gpio_set_pull_mode(miso, GPIO_PULLUP_ONLY);
    gpio_set_direction(mosi, GPIO_MODE_OUTPUT);
    gpio_set_direction(sck, GPIO_MODE_OUTPUT);

    // Set configuration
    self->polarity = polarity & 1;
    self->phase = phase & 1;
    self->firstbit = firstbit & 1;
    self->duplex = duplex & 1;

    self->spi.dma_channel = 1;
    self->spi.curr_clock = baudrate;
    self->spi.handle = NULL;
    self->spi.dc = -1;
    self->spi.selected = 0;
    self->spi.cs = cs;

    self->spi.buscfg->miso_io_num = miso;
    self->spi.buscfg->mosi_io_num = mosi;
    self->spi.buscfg->sclk_io_num = sck;
    self->spi.buscfg->quadwp_io_num = -1;
    self->spi.buscfg->quadhd_io_num = -1;
    //self->spi.buscfg->max_transfer_sz = 6*1024;

    self->spi.devcfg.clock_speed_hz = self->spi.curr_clock;
    self->spi.devcfg.duty_cycle_pos = 128;
    self->spi.devcfg.mode = self->phase | (self->polarity << 1);
    self->spi.devcfg.spics_io_num = -1;
    self->spi.devcfg.queue_size = queue_size;
    self->spi.devcfg.flags = ((self->firstbit == MICROPY_PY_MACHINE_SPI_LSB) ? SPI_DEVICE_TXBIT_LSBFIRST | SPI_DEVICE_RXBIT_LSBFIRST : 0);
    if (!self->duplex) self->spi.devcfg.flags |= SPI_DEVICE_HALFDUPLEX;
    self->spi.devcfg.pre_cb = NULL;

	// ==== Initialize the SPI bus and attach the device ====
	ret = add_extspi_device(&self->spi);
	if (ret == ESP_OK) {
		ret = spi_device_select(&self->spi, 1);
		if (ret != ESP_OK) {
	        machine_hw_spi_deinit_internal(self);
            mp_raise_msg(&mp_type_OSError, "Error selecting device");
		}
		ret = spi_device_deselect(&self->spi);
		if (ret != ESP_OK) {
	        machine_hw_spi_deinit_internal(self);
            mp_raise_msg(&mp_type_OSError, "Error deselecting device");
		}
	    self->state = MACHINE_HW_SPI_STATE_INIT;
	    return;
	}

	switch (ret) {
        case ESP_ERR_INVALID_ARG:
            mp_raise_msg(&mp_type_OSError, "invalid configuration");
            return;
        case ESP_ERR_INVALID_STATE:
            mp_raise_msg(&mp_type_OSError, "invalid state");
            return;
        case ESP_ERR_NO_MEM:
            mp_raise_msg(&mp_type_OSError, "out of memory");
            return;
        case ESP_ERR_NOT_FOUND:
            mp_raise_msg(&mp_type_OSError, "no free slots");
            return;
        default:
        {
        	char err[40];
        	sprintf(err, "error initializing spi (%d)", ret);
			mp_raise_msg(&mp_type_OSError, err);
			return;
        }
    }
}
```


Overlapping Code:
```
machine_hw_spi_init_internal(
machine_hw_spi_obj_t *self,
int8_t host,
int32_t baudrate,
int8_t polarity,
int8_t phase,
int8_t firstbit,
int8_t sck,
int8_t mosi,
int8_t miso,
int8_t cs,
int8_t duplex,
uint8_t queue_size,
uint8_t new) {
esp_err_t ret;
self->state = MACHINE_HW_SPI_STATE_DEINIT;
if ((baudrate <= 0) || (baudrate > 80000000)) {
mp_raise_ValueError("SPI baudrate must be >0 & <=80000000");
}
// Host initialization
if ((host != HSPI_HOST) && (host != VSPI_HOST)) {
mp_raise_ValueError("SPI host must be either HSPI(1) or VSPI(2)");
}
if ((SPIbus_configs[VSPI_HOST] == NULL) && (host == VSPI_HOST)) {
mp_raise_ValueError("SPI host must be HSPI(1), VSPI(2) used by SPIRAM");
}
int used_spi = spi_host_used_by_sdspi();
if ((used_spi != 0) && (used_spi == host)) {
// change spi host
if (host == VSPI_HOST) {
mp_raise_ValueError("SPI host must be HSPI(1), VSPI(2) used by SDCard driver");
}
else {
mp_raise_ValueError("SPI host must be VSPI(2), HSPI(1) used by SDCard driver");
}
}
self->spi.spihost = host;
self->spi.buscfg = SPIbus_configs[self->spi.spihost];
// Init pins
if (cs >= 0) {
gpio_pad_select_gpio(cs);
gpio_set_direction(cs, GPIO_MODE_OUTPUT);
gpio_set_level(cs, 1);
}
gpio_pad_select_gpio(miso);
gpio_pad_select_gpio(mosi);
gpio_pad_select_gpio(sck);
gpio_set_direction(miso, GPIO_MODE_INPUT);
gpio_set_pull_mode(miso, GPIO_PULLUP_ONLY);
gpio_set_direction(mosi, GPIO_MODE_OUTPUT);
gpio_set_direction(sck, GPIO_MODE_OUTPUT);
// Set configuration
self->polarity = polarity & 1;
self->phase = phase & 1;
self->firstbit = firstbit & 1;
self->duplex = duplex & 1;
self->spi.dma_channel = 1;
self->spi.curr_clock = baudrate;
self->spi.handle = NULL;
self->spi.dc = -1;
self->spi.selected = 0;
self->spi.cs = cs;
self->spi.buscfg->miso_io_num = miso;
self->spi.buscfg->mosi_io_num = mosi;
self->spi.buscfg->sclk_io_num = sck;
self->spi.buscfg->quadwp_io_num = -1;
self->spi.buscfg->quadhd_io_num = -1;
//self->spi.
```
<Overlap Ratio: 0.9807106598984772>

---

--- 320 --
Question ID: 7751b83ec61c2d3c2ca184bc0ccc392af21db12d_8
Original Code:
```
int lcd_print_char(char ch, FILE *f) {
    // wait for control
    // note: we want to wrap the whole printf in the lcd_lock as well, so
    // the text isn't interleaved... however we acquire here to yield while
    // waiting
    acquire(&lcd_lock);

    if (lcdClearFlag) {
        lcd_clear();
        lcdClearFlag = 0;
    }
    if (lcdPos==0x20)
        lcdPos = 0;
    if (ch=='\n')
        lcdClearFlag = 1;
    else {
        if (lcdPos == 0x10)
            lcdPosActual = 0xFF;
        if (lcdContents[lcdPos] != ch) {
            lcdContents[lcdPos] = ch;
            if (lcdPosActual != lcdPos)
                lcd_set_pos(lcdPos);
            lcd_write(LCD_DATA, ch);
            lcdPosActual++;
        }
        lcdPos++;
    }

    // give up control
    release(&lcd_lock);
    return ch;
}
```


Overlapping Code:
```
 for control
// note: we want to wrap the whole printf in the lcd_lock as well, so
// the text isn't interleaved... however we acquire here to yield while
// waiting
acquire(&lcd_lock);
if (lcdClearFlag) {
lcd_clear();
lcdClearFlag = 0;
}
if (lcdPos==0x20)
lcdPos = 0;
if (ch=='\n')
lcdClearFlag = 1;
else {
if (lcdPos == 0x10)
lcdPosActual = 0xFF;
if (lcdContents[lcdPos] != ch) {
lcdContents[lcdPos] = ch;
if (lcdPosActual != lcdPos)
lcd_set_pos(lcdPos);
lcd_write(LCD_DATA, ch);
lcdPosActual++;
}
lcdPos++;
}
// give up control
release(&lcd_lock);
```
<Overlap Ratio: 0.90311986863711>

---

--- 321 --
Question ID: a856370464d6371d871f55debd45b217cd3e791f_3
Original Code:
```
gulong dbhandler_get_num_calls(void)
{
    int rc;
    rc = sqlite3_step(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);
    if (rc != SQLITE_DONE && rc != SQLITE_ROW) {
        log_log("dbhandler_get_num_calls: rc = %d\n", rc);
        sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);
        return 0;
    }

    gulong count = (gulong)sqlite3_column_int(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS], 0);
    sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);

    log_log("dbhandler_get_num_calls: count: %lu\n", count);
    return count;
}
```


Overlapping Code:
```
 rc;
rc = sqlite3_step(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);
if (rc != SQLITE_DONE && rc != SQLITE_ROW) {
log_log("dbhandler_get_num_calls: rc = %d\n", rc);
sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);
return 0;
}
gulong count = (gulong)sqlite3_column_int(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS], 0);
sqlite3_reset(dbhandler_stmts[DBHANDLER_STMT_GET_NUM_CALLS]);
log_log("dbhandler_get_num_calls: count: %lu\n", count
```
<Overlap Ratio: 0.8823529411764706>

---

--- 322 --
Question ID: a057c60f1b5e5a9be5ac58bc4942fcc36b693dd6_5
Original Code:
```
void
rstp_set_bridge_address(struct rstp *rstp, rstp_identifier bridge_address)
    OVS_EXCLUDED(rstp_mutex)
{
    ovs_mutex_lock(&rstp_mutex);
    rstp_set_bridge_address__(rstp, bridge_address);
    ovs_mutex_unlock(&rstp_mutex);
}
```


Overlapping Code:
```
ridge_address(struct rstp *rstp, rstp_identifier bridge_address)
OVS_EXCLUDED(rstp_mutex)
{
ovs_mutex_lock(&rstp_mutex);
rstp_set_bridge_address__(rstp, bridge_address);
ovs_mutex_unlock(&rstp_mutex);
```
<Overlap Ratio: 0.9216589861751152>

---

--- 323 --
Question ID: 7066b83cc134de1593a07a85c535e734ada513c4_1
Original Code:
```
bagError bagGetNumSurfaceCorrectors  (bagHandle hnd_opt, u32 *num)
{
    hid_t          typenow;
    hsize_t        adims[] = {0,0};
    bagError       err;
    int            inx;
    
    *num = 0;

    if (hnd_opt == NULL)
        return BAG_INVALID_BAG_HANDLE;

    /*! Access the "z" member of the datatype */
    inx = H5Tget_member_index (hnd_opt->opt_datatype_id[Surface_Correction], "z");
    typenow = H5Tget_member_type (hnd_opt->opt_datatype_id[Surface_Correction], inx );

    if (typenow < 0)
        return BAG_HDF_TYPE_NOT_FOUND;

    /*! Now dimension of the "z" array is obtained */
    err = H5Tget_array_dims( typenow, adims, NULL );
    if (err > 0)
    {
        *num  = (u32)adims[1];
        return BAG_SUCCESS;
    }
    else
    {
        *num = 0;
        return BAG_HDF_TYPE_NOT_FOUND;
    }
}
```


Overlapping Code:
```
bagGetNumSurfaceCorrectors (bagHandle hnd_opt, u32 *num)
{
hid_t typenow;
hsize_t adims[] = {0,0};
bagError err;
int inx;

*num = 0;
if (hnd_opt == NULL)
return BAG_INVALID_BAG_HANDLE;
/*! Access the "z" member of the datatype */
inx = H5Tget_member_index (hnd_opt->opt_datatype_id[Surface_Correction], "z");
typenow = H5Tget_member_type (hnd_opt->opt_datatype_id[Surface_Correction], inx );
if (typenow < 0)
return BAG_HDF_TYPE_NOT_FOUND;
/*! Now dimension of the "z" array is obtained */
err = H5Tget_array_dims( typenow, adims, NULL );
if (err > 0)
{
*num = (u32)adims[1];
return BAG_SUCCESS;
}
else
{
*num = 0;
return B
```
<Overlap Ratio: 0.9468085106382979>

---

--- 324 --
Question ID: fe3921dfd614577bc599079480c73d03e74a86b0_4
Original Code:
```
void sck_smallwrite(char* data, unsigned int len){
    sck->mode = 1;
    sck->outlen = len;
    memcpy(sck->buffer, data, len);
    sck->cmd1 = 4;
    while(sck->cmd1 == 4);
}
```


Overlapping Code:
```
 unsigned int len){
sck->mode = 1;
sck->outlen = len;
memcpy(sck->buffer, data, len);
sck->cmd1 = 4;
```
<Overlap Ratio: 0.6410256410256411>

---

--- 325 --
Question ID: 41edb30e6795a34c57af305da49e106a2fc93cc6_4
Original Code:
```
krb5_error_code
krb5_ldap_get_password_policy (context, name, policy, cnt)
    krb5_context                context;
    char                        *name;
    osa_policy_ent_t            *policy;
    int                         *cnt;
{
    krb5_error_code             st = 0;
    char                        *policy_dn = NULL;

    /* Clear the global error string */
    krb5_clear_error_message(context);

    /* validate the input parameters */
    if (name == NULL) {
	st = EINVAL;
	goto cleanup;
    }

    st = krb5_ldap_name_to_policydn(context, name, &policy_dn);
    if (st != 0)
	goto cleanup;

    st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn, policy, cnt);

cleanup:
    if (policy_dn != NULL)
	free (policy_dn);
    return st;
}
```


Overlapping Code:
```
sword_policy (context, name, policy, cnt)
krb5_context context;
char *name;
osa_policy_ent_t *policy;
int *cnt;
{
krb5_error_code st = 0;
char *policy_dn = NULL;
/* Clear the global error string */
krb5_clear_error_message(context);
/* validate the input parameters */
if (name == NULL) {
st = EINVAL;
goto cleanup;
}
st = krb5_ldap_name_to_policydn(context, name, &policy_dn);
if (st != 0)
goto cleanup;
st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn, policy, cnt);
cleanup:
if (policy_dn != NULL)
free (policy_dn);
return st;
}
```
<Overlap Ratio: 0.9433962264150944>

---

--- 326 --
Question ID: c81d8902091655434b9d2fba6e783cdf02485b77_4
Original Code:
```
static napi_value nsql_statement_close(napi_env env, napi_callback_info ctx) {
  struct nsql_statement *self;
  napi_value nself;
  napi_status r;
  int sqlr;

  r = napi_get_cb_info(env, ctx, NULL, NULL, &nself, NULL);

  if (r != napi_ok) {
    nsql_report_error(env, r);

    goto end;
  }

  r = napi_unwrap(env, nself, (void **)&self);

  if (r != napi_ok) {
    nsql_report_error(env, r);

    goto end;
  }

  assert(self != NULL);

  sqlr = sqlite3_finalize(self->stmt);

  if (sqlr != SQLITE_OK) {
    r = nsql_throw_sqlite_error(env, sqlr, NULL);
  }

  self->db = NULL;
  self->stmt = NULL;

  nsql_dprintf("%s\n", __func__);

end:
  return nsql_return(env, r, NULL);
}
```


Overlapping Code:
```
ue nsql_statement_close(napi_env env, napi_callback_info ctx) {
struct nsql_statement *self;
napi_value nself;
napi_status r;
int sqlr;
r = napi_get_cb_info(env, ctx, NULL, NULL, &nself, NULL);
if (r != napi_ok) {
nsql_report_error(env, r);
goto end;
}
r = napi_unwrap(env, nself, (void **)&self);
if (r != napi_ok) {
nsql_report_error(env, r);
goto end;
}
assert(self != NULL);
sqlr = sqlite3_finalize(self->stmt);
if (sqlr != SQLITE_OK) {
r = nsql_throw_sqlite_error(env, sqlr, NULL);
}
self->db = NULL;
self->stmt = NULL;
nsql_dprintf("%s\n", __func__);
end:
return nsql_return(en
```
<Overlap Ratio: 0.9526143790849673>

---

--- 327 --
Question ID: e696364a8a2ecfff01742fe9c0bb993055ef21de_5
Original Code:
```
inline NanoString unary_dtype_infer(NanoString op, NanoString x) {
    if (op.is_bool()) return ns_bool;
    int dsize_ = x.dsize_();
    if (op.is_float()) {
        if (op.is_white() && !(amp_reg & amp_keep_white))
            return (dsize_ == 3) ? ns_float64 : ns_float32;
        return float_dtype(dsize_);
    }
    if (op.is_int()) return int_dtype(dsize_);
    return x;
}
```


Overlapping Code:
```
g unary_dtype_infer(NanoString op, NanoString x) {
if (op.is_bool()) return ns_bool;
int dsize_ = x.dsize_();
if (op.is_float()) {
if (op.is_white() && !(amp_reg & amp_keep_white))
return (dsize_ == 3) ? ns_float64 : ns_float32;
return float_dtype(dsize_);
}
if (op.is_int()) return int_dtype(dsize_)
```
<Overlap Ratio: 0.9118541033434651>

---

--- 328 --
Question ID: f803941e2dc304be0ba564d90b587fc4b63f0eea_0
Original Code:
```
int save_uncompressed(uint8_t port, uint8_t unit){
	vmu_pkg_t pkg;
	uint8 *pkg_out, *data;
	int pkg_size;
	FILE *fp;
	char savename[32];
	maple_device_t *vmu;
	int rv = 0, blocks_freed = 0;
	file_t f;

	//Invalid controller/port
	if(port < 0 || port > 3 || unit < 1 || unit > 2){
		return -2;
	}

	// Make sure there's a VMU in port a1.
		//Change this later to check all slots or the requested slots
	if(!(vmu = maple_enum_dev(port, unit))){
		return -100;
	}

	if(!vmu->valid || !(vmu->info.functions & MAPLE_FUNC_MEMCARD)){
		return -100;
	}

	//Only 20 chara allowed at max (21 if you include '\0')
	sprintf(savename, "/vmu/%c%d/", port + 97, unit);	//port gets converted to a, b, c or d. unit is unit
	strcat(savename, "UNCOMPRESS.s");

	int filesize = sizeof(SaveFile_t);
	data = (uint8_t *) malloc(filesize);
	if(data == NULL){
		free(data);
		return -1;
	}
	memcpy(data, &save, sizeof(SaveFile_t));	//Last param is number of bytes, not bits

	sprintf(pkg.desc_long, "Uncompressed save file!");
	strcpy(pkg.desc_short, "Uncompressed");
	strcpy(pkg.app_id, "Proto_uncomp_save");
	pkg.icon_cnt = 1;
	pkg.icon_anim_speed = 0;
	memcpy(pkg.icon_pal, palette, 32);
	pkg.icon_data = icon;
	pkg.eyecatch_type = VMUPKG_EC_NONE;
	pkg.data_len = sizeof(SaveFile_t);	//Double check this, but I think its right
	pkg.data = data;

	vmu_pkg_build(&pkg, &pkg_out, &pkg_size);

	// See if a file exists with that name, since we'll overwrite it.
	f = fs_open(savename, O_RDONLY);
	if(f != FILEHND_INVALID){
		blocks_freed = fs_total(f) >> 9;
		fs_close(f);
	}

	// Make sure there's enough free space on the VMU.
	if(vmufs_free_blocks(vmu) + blocks_freed < (pkg_size >> 9)){
		free(pkg_out);
		free(data);
		return pkg_size >> 9;
	}

	if(!(fp = fopen(savename, "wb"))){
		free(pkg_out);
		free(data);
		return -1;
	}

	if(fwrite(pkg_out, 1, pkg_size, fp) != (size_t)pkg_size){
		rv = -1;
	}

	fclose(fp);

	free(pkg_out);
	free(data);

	return rv;
}
```


Overlapping Code:
```
ssed(uint8_t port, uint8_t unit){
vmu_pkg_t pkg;
uint8 *pkg_out, *data;
int pkg_size;
FILE *fp;
char savename[32];
maple_device_t *vmu;
int rv = 0, blocks_freed = 0;
file_t f;
//Invalid controller/port
if(port < 0 || port > 3 || unit < 1 || unit > 2){
return -2;
}
// Make sure there's a VMU in port a1.
//Change this later to check all slots or the requested slots
if(!(vmu = maple_enum_dev(port, unit))){
return -100;
}
if(!vmu->valid || !(vmu->info.functions & MAPLE_FUNC_MEMCARD)){
return -100;
}
//Only 20 chara allowed at max (21 if you include '\0')
sprintf(savename, "/vmu/%c%d/", port + 97, unit); //port gets converted to a, b, c or d. unit is unit
strcat(savename, "UNCOMPRESS.s");
int filesize = sizeof(SaveFile_t);
data = (uint8_t *) malloc(filesize);
if(data == NULL){
free(data);
return -1;
}
memcpy(data, &save, sizeof(SaveFile_t)); //Last param is number of bytes, not bits
sprintf(pkg.desc_long, "Uncompressed save file!");
strcpy(pkg.desc_short, "Uncompressed");
strcpy(pkg.app_id, "Proto_uncomp_save");
pkg.icon_cnt = 1;
pkg.icon_anim_speed = 0;
memcpy(pkg.icon_pal, palette, 32);
pkg.icon_data = icon;
pkg.eyecatch_type = VMUPKG_EC_NONE;
pkg.data_len = sizeof(SaveFile_t); //Double check this, but I think its right
pkg.data = data;
vmu_pkg_build(&pkg, &pkg_out, &pkg_size);
// See if a file exists with that name, since we'll overwrite it.
f = fs_open(savename, O_RDONLY);
if(f != FILEHND_INVALID){
blocks_freed = fs_total(f) >> 9;
fs_close(f);
}
// Make sure there's enough free space on the VMU.
if(vmufs_free_blocks(vmu) + blocks_freed < (pkg_size >> 9)){
free(pkg_out);
free(data);
return pkg_size >> 9;
}
if(!(fp = fopen(savename, "wb"))){
free(pkg_out);
free(data);
return -1;
}
if(fwrite(pkg_out, 1, pkg_size, fp) != (size_t)pkg_size){
rv = -1;
}
fclose(fp);
free(pkg_out);
```
<Overlap Ratio: 0.9772234273318872>

---

--- 329 --
Question ID: d4e01ea9f3b5c359b0ee8f9990fa34248011dc48_216
Original Code:
```
static inline HI_VOID isp_dpc_line_thresh_2_u32_write(S_ISPBE_REGS_TYPE *pstBeReg, HI_U32 uIspDpcLineThr2G, HI_U32 uIspDpcLineThr2Rb)
{
    U_ISP_DPC_LINE_THRESH_2 o_isp_dpc_line_thresh_2;
    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_g = uIspDpcLineThr2G;
    o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_rb = uIspDpcLineThr2Rb;
    pstBeReg->ISP_DPC_LINE_THRESH_2.u32 = o_isp_dpc_line_thresh_2.u32;
}
```


Overlapping Code:
```
tic inline HI_VOID isp_dpc_line_thresh_2_u32_write(S_ISPBE_REGS_TYPE *pstBeReg, HI_U32 uIspDpcLineThr2G, HI_U32 uIspDpcLineThr2Rb)
{
U_ISP_DPC_LINE_THRESH_2 o_isp_dpc_line_thresh_2;
o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_g = uIspDpcLineThr2G;
o_isp_dpc_line_thresh_2.bits.isp_dpc_line_thr2_rb = uIspDpcLineThr2Rb;
pstBeReg->ISP_DPC_LINE_THRES
```
<Overlap Ratio: 0.8905852417302799>

---

--- 330 --
Question ID: 78be8eadb2ff6f612a9ff5762519c0d8ec2aa1e4_16
Original Code:
```
static void cleanUp(LV2UI_Handle handle)
{
    NovachordUi* ui = (NovachordUi*) handle;
    freeResources(&ui->resources);
    sendUiDisable(ui);
    gtk_widget_destroy(ui->drawingArea);
    free(ui);
}
```


Overlapping Code:
```
Handle handle)
{
NovachordUi* ui = (NovachordUi*) handle;
freeResources(&ui->resources);
sendUiDisable(ui);
gtk_widget_destroy(ui->drawingArea);
free(
```
<Overlap Ratio: 0.8241758241758241>

---

--- 331 --
Question ID: 6cac1996d9610dcbf05bad3532573643a1f2559b_5
Original Code:
```
void tm1637_clear(void)
{
  uint8_t i;

  tm1637_selectpos(0);
  for(i=0;i<6;i++) { tm1637_write(0x00); }
  tm1637_stop();

  tm1637_setbright(hellig);

}
```


Overlapping Code:
```
637_selectpos(0);
for(i=0;i<6;i++) { tm1637_write(0x00); }
tm1637_stop();
tm1637_setbright(hellig);

```
<Overlap Ratio: 0.7092198581560284>

---

--- 332 --
Question ID: 17caec855283f21680b49a0dac914639d23f0b63_0
Original Code:
```
int getport(char *str)
{
  char *bad;
  int port;
  if(!*str) return -1;
  if(str[0] == '-')
  {
    if(str[1] != 0) return -1;
    return 0;
  }
  port = (int)strtol(str,&bad,10);
  if(*bad) return -1;
  return port;
}
```


Overlapping Code:
```
)
{
char *bad;
int port;
if(!*str) return -1;
if(str[0] == '-')
{
if(str[1] != 0) return -1;
return 0;
}
port = (int)strtol(str,&bad,10);
if(*bad) ret
```
<Overlap Ratio: 0.7772020725388601>

---

--- 333 --
Question ID: aa4e3ccb3cc548b9c2b7d044f3a28200c755ee22_43
Original Code:
```
void gl_getfragdataindex( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {

	if (NULL == glGetFragDataIndex) mogl_glunsupported("glGetFragDataIndex");
	plhs[0]=mxCreateDoubleMatrix(1,1,mxREAL);
	*mxGetPr(plhs[0])=(double)glGetFragDataIndex((GLuint)mxGetScalar(prhs[0]),
		(const GLchar*)mxGetData(prhs[1]));

}
```


Overlapping Code:
```
etfragdataindex( int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[] ) {
if (NULL == glGetFragDataIndex) mogl_glunsupported("glGetFragDataIndex");
plhs[0]=mxCreateDoubleMatrix(1,1,mxREAL);
*mxGetPr(plhs[0])=(double)glGetFragDataIndex((GLuint)mxGetScalar(prhs[0]),
(const GLchar*)mxGetData(prhs[1]))
```
<Overlap Ratio: 0.9621451104100947>

---

--- 334 --
Question ID: c0193a01d202c83bd69faaf43e9e146db5aa8a49_32
Original Code:
```
const char*
rt_band_get_ext_path(rt_band band) {

    assert(NULL != band);


    if (!band->offline) {
        RASTER_DEBUG(3, "rt_band_get_ext_path: Band is not offline");
        return 0;
    }
    return band->data.offline.path;
}
```


Overlapping Code:
```
_path(rt_band band) {
assert(NULL != band);
if (!band->offline) {
RASTER_DEBUG(3, "rt_band_get_ext_path: Band is not offline");
return 0;
}
return ban
```
<Overlap Ratio: 0.75>

---

--- 335 --
Question ID: 04faca3221deae50eff4f90baadba00709ed95aa_11
Original Code:
```
static void get_passphrase(char *passphrase, int len)
{
	char *p;
	struct termios current_settings;

	assert(len > 0);
	disable_echo(&current_settings);
	p = fgets(passphrase, len, stdin);
	tcsetattr(0, TCSANOW, &current_settings);
	printf("\n");
	if (!p) {
		printf("Aborting.\n");
		exit(1);
	}
	p = strrchr(passphrase, '\n');
	if (!p)
		p = passphrase + len - 1;
	*p = '\0';
}
```


Overlapping Code:
```
 void get_passphrase(char *passphrase, int len)
{
char *p;
struct termios current_settings;
assert(len > 0);
disable_echo(&current_settings);
p = fgets(passphrase, len, stdin);
tcsetattr(0, TCSANOW, &current_settings);
printf("\n");
if (!p) {
printf("Aborting.\n");
exit(1);
}
p = strrchr(passphrase, '\n');
if (!p)
p = passphrase + len - 1;
*p = '\0';
}
```
<Overlap Ratio: 0.9833333333333333>

---

--- 336 --
Question ID: cfb794766fead2823f0e5d3ba36259d97b9b952a_24
Original Code:
```
static int sdhci_pci_select_drive_strength(struct sdhci_host *host,
					   struct mmc_card *card,
					   unsigned int max_dtr, int host_drv,
					   int card_drv, int *drv_type)
{
	struct sdhci_pci_slot *slot = sdhci_priv(host);

	if (!slot->select_drive_strength)
		return 0;

	return slot->select_drive_strength(host, card, max_dtr, host_drv,
					   card_drv, drv_type);
}
```


Overlapping Code:
```
int sdhci_pci_select_drive_strength(struct sdhci_host *host,
struct mmc_card *card,
unsigned int max_dtr, int host_drv,
int card_drv, int *drv_type)
{
struct sdhci_pci_slot *slot = sdhci_priv(host);
if (!slot->select_drive_strength)
return 0;
return slot->select_drive_strength(host, card, max_dtr, ho
```
<Overlap Ratio: 0.8905325443786982>

---

--- 337 --
Question ID: 5c420184fc59a9c3f0664bd58fd5bfdc641d8563_5
Original Code:
```
void SLL()
{
 int ch=0;
 first=NULL;
 last=NULL;
 clrscr();
 while(ch!=9)
{
 printf("enter your choice 1) insertion at beginning 2) insertion in middle 3) insertion at end 4) deletion at beginning 5) deletion in middle 6)deletion at end 7) display 8)search 9) exit\n");
 scanf("%d",&ch);
 if(ch==1)
 {
  insert_beg();
  count++;
 }
 else if(ch==2)
 {
   insert_mid();
   count++;
 }
 else if(ch==3)
 {
  insert_end();
  count++;
 }
 else if(ch==4)
 {
  del_beg();
  count--;
 }
 else if(ch==5)
 {
  del_mid();
  count--;
 }
 else if(ch==6)
 {
  del_end();
  count--;
 }
 else if(ch==7)
 {
  display();
 }
 else if(ch==9)
 {
  printf("exit\n");
 }
 else if(ch==8)
 {
   search();
 }
 else
 {
  printf("error\n");
  }
  }
  getch();
  }
```


Overlapping Code:
```
st=NULL;
clrscr();
while(ch!=9)
{
printf("enter your choice 1) insertion at beginning 2) insertion in middle 3) insertion at end 4) deletion at beginning 5) deletion in middle 6)deletion at end 7) display 8)search 9) exit\n");
scanf("%d",&ch);
if(ch==1)
{
insert_beg();
count++;
}
else if(ch==2)
{
insert_mid();
count++;
}
else if(ch==3)
{
insert_end();
count++;
}
else if(ch==4)
{
del_beg();
count--;
}
else if(ch==5)
{
del_mid();
count--;
}
else if(ch==6)
{
del_end();
count--;
}
else if(ch==7)
{
display();
}
else if(ch==9)
{
printf("exit\n");
}
else if(ch==8)
{
search();
}
else
{
printf("error\n
```
<Overlap Ratio: 0.916030534351145>

---

--- 338 --
Question ID: 1ff1444f6140da6f1965e64f2120a5fb7158f730_1
Original Code:
```
int ssp_write_alt(unsigned int spi_bus, unsigned int spi_csn,
                  unsigned int addr1, unsigned int addr1bytenum,
                  unsigned int addr2, unsigned int addr2bytenum,
                  unsigned int data, unsigned int databytenum)
{
    struct spi_master   *master = hi_master[spi_bus];
    struct spi_device   *spi = hi_spi[spi_bus][spi_csn];
    struct spi_transfer *t;
    struct spi_message  *m;
    unsigned char       *buf;
    int                 status = 0;
    unsigned long       flags;
    int                 buf_idx = 0;
    int idx = g_spi_msg.msg_idx;

    g_spi_msg.msg_idx++;
    if (g_spi_msg.msg_idx > SPI_MSG_NUM - 1) {
        g_spi_msg.msg_idx = 0;
    }

    buf = g_spi_msg.spi_msg_array[idx].buf;
    t   = &g_spi_msg.spi_msg_array[idx].t;
    m   = &g_spi_msg.spi_msg_array[idx].m;

    /* check spi_message is or no finish */
    spin_lock_irqsave(&master->queue_lock, flags);
    if (m->state != NULL) {
        spin_unlock_irqrestore(&master->queue_lock, flags);
        dev_err(&spi->dev, "%s, %s, %d line: spi_message no finish!\n", __FILE__, __func__, __LINE__);
        return -EFAULT;
    }
    spin_unlock_irqrestore(&master->queue_lock, flags);

    spi->mode = SPI_MODE_3 | SPI_LSB_FIRST;

    memset(buf, 0, sizeof(g_spi_msg.spi_msg_array[idx].buf));

    buf[buf_idx++] = addr1;

    if (addr2bytenum == 2) {
        buf[buf_idx++] = addr2 >> 8;
    }
    buf[buf_idx++] = addr2;

    if (databytenum == 2) {
        buf[buf_idx++] = data >> 8;
    }
    buf[buf_idx++] = data;
    t->tx_buf    = buf;
    t->rx_buf    = buf;
    t->len       = buf_idx;
    t->cs_change = 1;
    t->speed_hz  = 2000000;
    t->bits_per_word = 8;

    spi_message_init(m);
    spi_message_add_tail(t, m);
    m->state = m;
    status = spi_async(spi, m);
    if (status) {
        dev_err(&spi->dev, "%s: spi_async() error!\n", __func__);
        status = -EFAULT;
    }

    return status;
}
```


Overlapping Code:
```
t(unsigned int spi_bus, unsigned int spi_csn,
unsigned int addr1, unsigned int addr1bytenum,
unsigned int addr2, unsigned int addr2bytenum,
unsigned int data, unsigned int databytenum)
{
struct spi_master *master = hi_master[spi_bus];
struct spi_device *spi = hi_spi[spi_bus][spi_csn];
struct spi_transfer *t;
struct spi_message *m;
unsigned char *buf;
int status = 0;
unsigned long flags;
int buf_idx = 0;
int idx = g_spi_msg.msg_idx;
g_spi_msg.msg_idx++;
if (g_spi_msg.msg_idx > SPI_MSG_NUM - 1) {
g_spi_msg.msg_idx = 0;
}
buf = g_spi_msg.spi_msg_array[idx].buf;
t = &g_spi_msg.spi_msg_array[idx].t;
m = &g_spi_msg.spi_msg_array[idx].m;
/* check spi_message is or no finish */
spin_lock_irqsave(&master->queue_lock, flags);
if (m->state != NULL) {
spin_unlock_irqrestore(&master->queue_lock, flags);
dev_err(&spi->dev, "%s, %s, %d line: spi_message no finish!\n", __FILE__, __func__, __LINE__);
return -EFAULT;
}
spin_unlock_irqrestore(&master->queue_lock, flags);
spi->mode = SPI_MODE_3 | SPI_LSB_FIRST;
memset(buf, 0, sizeof(g_spi_msg.spi_msg_array[idx].buf));
buf[buf_idx++] = addr1;
if (addr2bytenum == 2) {
buf[buf_idx++] = addr2 >> 8;
}
buf[buf_idx++] = addr2;
if (databytenum == 2) {
buf[buf_idx++] = data >> 8;
}
buf[buf_idx++] = data;
t->tx_buf = buf;
t->rx_buf = buf;
t->len = buf_idx;
t->cs_change = 1;
t->speed_hz = 2000000;
t->bits_per_word = 8;
spi_message_init(m);
spi_message_add_tail(t, m);
m->state = m;
status = spi_async(spi, m);
if (status) {
dev_err(&spi->dev, "%s: spi_async() error!\n", __func__);
status = -EFAULT;
}
return
```
<Overlap Ratio: 0.983502538071066>

---

--- 339 --
Question ID: 34c13a14e3fccfcddb037c0a96cc0b03cbdb9ca4_43
Original Code:
```
void smIPT_nS3(SmInitialPseudoTest* const me)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_smIPT_nS3_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_smIPT_nS3);
  cmock_call_instance = (CMOCK_smIPT_nS3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_nS3_CallInstance);
  Mock.smIPT_nS3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_nS3_CallInstance);
  if (Mock.smIPT_nS3_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_me)
  {
    UNITY_SET_DETAILS(CMockString_smIPT_nS3,CMockString_me);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_me, me, cmock_line, CMockStringMismatch);
  }
  if (Mock.smIPT_nS3_CallbackFunctionPointer != NULL)
  {
    Mock.smIPT_nS3_CallbackFunctionPointer(me, Mock.smIPT_nS3_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}
```


Overlapping Code:
```
(SmInitialPseudoTest* const me)
{
UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
CMOCK_smIPT_nS3_CALL_INSTANCE* cmock_call_instance;
UNITY_SET_DETAIL(CMockString_smIPT_nS3);
cmock_call_instance = (CMOCK_smIPT_nS3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.smIPT_nS3_CallInstance);
Mock.smIPT_nS3_CallInstance = CMock_Guts_MemNext(Mock.smIPT_nS3_CallInstance);
if (Mock.smIPT_nS3_IgnoreBool)
{
UNITY_CLR_DETAILS();
return;
}
UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
cmock_line = cmock_call_instance->LineNumber;
if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
if (!cmock_call_instance->IgnoreArg_me)
{
UNITY_SET_DETAILS(CMockString_smIPT_nS3,CMockString_me);
UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_me, me, cmock_line, CMockStringMismatch);
}
if (Mock.smIPT_nS3_CallbackFunctionPointer != NULL)
{
Mock.smIPT_nS3_CallbackFunctionPointer(me, Mock.smIPT_nS3_CallbackCalls++);
}
UNITY_CLR_DETAILS();

```
<Overlap Ratio: 0.9868536371603857>

---

--- 340 --
Question ID: d5c902c108d548676b53137409719298fd6956bc_2
Original Code:
```
static inline void printFrameStringBuffer(LOG_OUPUT_TYPE outputType)
{
	char** pBuffer = getPointerToPrintBuffer();
	const char* printBuffer = getPrintBuffer();
	u64 bytesToWrite = (*pBuffer) - printBuffer;
	switch (outputType)
	{
		case (LOG_STDOUT):
		{
			u64 bytesWritten = fwrite(printBuffer, 1, bytesToWrite, stdout);
			assert(bytesWritten == bytesToWrite);
		} break;
		default:
			break;
	}

}
```


Overlapping Code:
```
line void printFrameStringBuffer(LOG_OUPUT_TYPE outputType)
{
char** pBuffer = getPointerToPrintBuffer();
const char* printBuffer = getPrintBuffer();
u64 bytesToWrite = (*pBuffer) - printBuffer;
switch (outputType)
{
case (LOG_STDOUT):
{
u64 bytesWritten = fwrite(printBuffer, 1, bytesToWrite, stdout);
assert(bytesWritten == bytesToWrite);
} break;

```
<Overlap Ratio: 0.9259259259259259>

---

--- 341 --
Question ID: 6d971bad31f6eeb8ae105a649d8e8b947080a663_0
Original Code:
```
class opaque_sampler
{
public:
    opaque_sampler(int width, int sampled_width, unsigned int sample_size, bool filter, const pixel_format& format);
    virtual ~opaque_sampler();

    virtual bool sample(const unsigned char* pixels, int offset, unsigned char* out);
    void finish(unsigned char* out);

protected:
    unsigned int* m_red;
    unsigned int* m_green;
    unsigned int* m_blue;
    unsigned int m_sample_size;
    unsigned int m_shift_count_2;
    unsigned int m_shift_count;
    int m_width;
    int m_sampled_width;
    int m_remainder;
    int m_rows;
    bool m_filter;
    pixel_composer m_composer;

    virtual int get_bytes_per_pixel();
    virtual void emit_square(unsigned char* out);
    virtual void emit(unsigned char* out);

    static unsigned int get_shift_count(unsigned int n);
}
```


Overlapping Code:
```
e_sampler(int width, int sampled_width, unsigned int sample_size, bool filter, const pixel_format& format);
virtual ~opaque_sampler();
virtual bool sample(const unsigned char* pixels, int offset, unsigned char* out);
void finish(unsigned char* out);
protected:
unsigned int* m_red;
unsigned int* m_green;
unsigned int* m_blue;
unsigned int m_sample_size;
unsigned int m_shift_count_2;
unsigned int m_shift_count;
int m_width;
int m_sampled_width;
int m_remainder;
int m_rows;
bool m_filter;
pixel_composer m_composer;
virtual int get_bytes_per_pixel();
virtual void emit_square(unsigned char* out);
virtual void emit(unsigned char* out);
static unsign
```
<Overlap Ratio: 0.8942307692307693>

---

--- 342 --
Question ID: 0d902b985e1acb35b80e407ea269674d2f3a39ba_1
Original Code:
```
NPY_NO_EXPORT int
PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len)
{
    int i;
    npy_ucs4 chr;
    Py_UNICODE ch;
    int numchars=0;

    for (i = 0; (i < ucs2len) && (numchars < ucs4len); i++) {
        ch = *ucs2++;
        if (ch >= 0xd800 && ch <= 0xdfff) {
            /* surrogate pair */
            chr = ((npy_ucs4)(ch-0xd800)) << 10;
            chr += *ucs2++ + 0x2400;  /* -0xdc00 + 0x10000 */
            i++;
        }
        else {
            chr = (npy_ucs4) ch;
        }
        *ucs4++ = chr;
        numchars++;
    }
    return numchars;
}
```


Overlapping Code:
```
EXPORT int
PyUCS2Buffer_AsUCS4(Py_UNICODE *ucs2, npy_ucs4 *ucs4, int ucs2len, int ucs4len)
{
int i;
npy_ucs4 chr;
Py_UNICODE ch;
int numchars=0;
for (i = 0; (i < ucs2len) && (numchars < ucs4len); i++) {
ch = *ucs2++;
if (ch >= 0xd800 && ch <= 0xdfff) {
/* surrogate pair */
chr = ((npy_ucs4)(ch-0xd800)) << 10;
chr += *ucs2++ + 0x2400; /* -0xdc00 + 0x10000 */
i++;
}
else {
chr = (npy_ucs4) ch;
}
*ucs4++ = chr;
numchars++;
}
return numchars
```
<Overlap Ratio: 0.9778270509977827>

---

--- 343 --
Question ID: f76ef9aaab6fe7569bd725330a8fee48e52f9b3c_7
Original Code:
```
inline LcsHashTable::LcsHashTable()
{
    hashBlock = NULL;
    hashTableSize = 0;
    nextValueNode = 0;
}
```


Overlapping Code:
```
nline LcsHashTable::LcsHashTable()
{
hashBlock = N
```
<Overlap Ratio: 0.5263157894736842>

---

--- 344 --
Question ID: 39f96c03cf090362567dd9fe0be705a363ffcda9_2
Original Code:
```
mrb_value
pg_new_result(mrb_state *mrb, PGresult *result, mrb_value mrb_pgconn)
{
  mrb_value val;
  mrb_value type_map;

  val = mrb_obj_value(Data_Wrap_Struct(mrb, mrb_cPGresult(mrb), &mrb_pgresult_type, result));
  mrb_iv_set(mrb, val, mrb_intern_lit(mrb, "@connection"), mrb_pgconn);

  type_map = mrb_iv_get(mrb, mrb_pgconn, mrb_intern_lit(mrb, "@type_map_for_results"));
  
  if(!mrb_nil_p(type_map)) {
    mrb_iv_set(mrb, val, mrb_intern_lit(mrb, "type_map"), type_map);
  }

  return val;
}
```


Overlapping Code:
```
result(mrb_state *mrb, PGresult *result, mrb_value mrb_pgconn)
{
mrb_value val;
mrb_value type_map;
val = mrb_obj_value(Data_Wrap_Struct(mrb, mrb_cPGresult(mrb), &mrb_pgresult_type, result));
mrb_iv_set(mrb, val, mrb_intern_lit(mrb, "@connection"), mrb_pgconn);
type_map = mrb_iv_get(mrb, mrb_pgconn, mrb_intern_lit(mrb, "@type_map_for_results"));

if(!mrb_nil_p(type_map)) {
mrb_iv_set(mrb, val, mrb_intern_lit(mrb, "type_map"), type_map);
}
return 
```
<Overlap Ratio: 0.9513742071881607>

---

--- 345 --
Question ID: e366ef108c520ac5cd17a7a661b5483b297c6b10_10
Original Code:
```
int pthread_get_nproc(int * number)
{
    if(number == NULL)
    {
        return EFAULT;
    }

    /* get number of processors online */
    if(((*number) = (int)sysconf(_SC_NPROC_ONLN)) == -1)
    {
        return ENOTSUP;
    }

    return 0;
}
```


Overlapping Code:
```
thread_get_nproc(int * number)
{
if(number == NULL)
{
return EFAULT;
}
/* get number of processors online */
if(((*number) = (int)sysconf(_SC_NPROC_ONLN)) == -
```
<Overlap Ratio: 0.803030303030303>

---

--- 346 --
Question ID: d0638d5ffe89f4615f46c4511532ee67da6635c9_5
Original Code:
```
void cb_dots_subkeys()
{
    int len;
    int ret;
    int type;
    size_t off = 0;
    char *out_buf;
    size_t out_size;
    char *json;
    char *fmt;
    char *fmt_out;
    flb_sds_t str;
    msgpack_unpacked result;
    msgpack_object map;
    struct flb_record_accessor *ra;

    /* Sample JSON message */
    json =
        "{\"key1\": \"something\", \"kubernetes\": {\"annotations\": "
        "{\"fluentbit.io/tag\": \"thetag\"}}}";

    /* Convert to msgpack */
    len = strlen(json);
    ret = flb_pack_json(json, len, &out_buf, &out_size, &type);
    TEST_CHECK(ret == 0);
    if (ret == -1) {
        exit(EXIT_FAILURE);
    }

    /* Formatter */
    fmt = flb_sds_create("$kubernetes['annotations']['fluentbit.io/tag']");
    fmt_out = "thetag";

    ra = flb_ra_create(fmt, FLB_FALSE);
    TEST_CHECK(ra != NULL);
    if (!ra) {
        exit(EXIT_FAILURE);
    }

    /* Unpack msgpack object */
    msgpack_unpacked_init(&result);
    msgpack_unpack_next(&result, out_buf, out_size, &off);
    map = result.data;

    /* Do translation */
    str = flb_ra_translate(ra, NULL, -1, map, NULL);
    TEST_CHECK(str != NULL);
    if (!str) {
        exit(EXIT_FAILURE);
    }

    TEST_CHECK(flb_sds_len(str) == strlen(fmt_out));
    TEST_CHECK(memcmp(str, fmt_out, strlen(fmt_out)) == 0);
    printf("== input ==\n%s\n== output ==\n%s\n", str, fmt_out);

    flb_sds_destroy(str);
    flb_sds_destroy(fmt);
    flb_ra_destroy(ra);
    flb_free(out_buf);
    msgpack_unpacked_destroy(&result);
}
```


Overlapping Code:
```
d cb_dots_subkeys()
{
int len;
int ret;
int type;
size_t off = 0;
char *out_buf;
size_t out_size;
char *json;
char *fmt;
char *fmt_out;
flb_sds_t str;
msgpack_unpacked result;
msgpack_object map;
struct flb_record_accessor *ra;
/* Sample JSON message */
json =
"{\"key1\": \"something\", \"kubernetes\": {\"annotations\": "
"{\"fluentbit.io/tag\": \"thetag\"}}}";
/* Convert to msgpack */
len = strlen(json);
ret = flb_pack_json(json, len, &out_buf, &out_size, &type);
TEST_CHECK(ret == 0);
if (ret == -1) {
exit(EXIT_FAILURE);
}
/* Formatter */
fmt = flb_sds_create("$kubernetes['annotations']['fluentbit.io/tag']");
fmt_out = "thetag";
ra = flb_ra_create(fmt, FLB_FALSE);
TEST_CHECK(ra != NULL);
if (!ra) {
exit(EXIT_FAILURE);
}
/* Unpack msgpack object */
msgpack_unpacked_init(&result);
msgpack_unpack_next(&result, out_buf, out_size, &off);
map = result.data;
/* Do translation */
str = flb_ra_translate(ra, NULL, -1, map, NULL);
TEST_CHECK(str != NULL);
if (!str) {
exit(EXIT_FAILURE);
}
TEST_CHECK(flb_sds_len(str) == strlen(fmt_out));
TEST_CHECK(memcmp(str, fmt_out, strlen(fmt_out)) == 0);
printf("== input ==\n%s\n== output ==\n%s\n", str, fmt_out);
flb_sds_destroy(str);
flb_sds_destroy(fmt);
flb_ra_destroy(ra);
flb_free(out_buf);
msgpack_unpacked_destroy(&result);
}
```
<Overlap Ratio: 0.9976599063962559>

---

--- 347 --
Question ID: 9633a2b7ffc2c3c138560354970f78e8d120f975_0
Original Code:
```
void mx_set_profile_img(GtkButton *button, gpointer data) {
    t_s_glade *gui = (t_s_glade *)data;
    char *group_img = mx_open_file_chooser(GTK_WINDOW(gui->w_profile));
    char *login = (char *)gtk_entry_get_text(GTK_ENTRY(gui->e_l_login));
    mx_rep_img(gui->i_avatar, group_img, 225, 225);

    GList *head = gtk_container_get_children(GTK_CONTAINER(gui->l_chats));
    GList *node = head;

    while (node) {
        GtkWidget *grid = gtk_bin_get_child(GTK_BIN(node->data));
        GtkWidget *label = gtk_grid_get_child_at(GTK_GRID(grid), 1, 0);
        GtkWidget *img = gtk_grid_get_child_at(GTK_GRID(grid), 0, 0);
        if (!mx_strcmp(login, gtk_label_get_text(GTK_LABEL(label))))
            mx_rep_img(img, group_img, 48, 48);

        node = g_list_next(node);
    }
    g_list_free(head);
    (void)button;
}
```


Overlapping Code:
```
tton *button, gpointer data) {
t_s_glade *gui = (t_s_glade *)data;
char *group_img = mx_open_file_chooser(GTK_WINDOW(gui->w_profile));
char *login = (char *)gtk_entry_get_text(GTK_ENTRY(gui->e_l_login));
mx_rep_img(gui->i_avatar, group_img, 225, 225);
GList *head = gtk_container_get_children(GTK_CONTAINER(gui->l_chats));
GList *node = head;
while (node) {
GtkWidget *grid = gtk_bin_get_child(GTK_BIN(node->data));
GtkWidget *label = gtk_grid_get_child_at(GTK_GRID(grid), 1, 0);
GtkWidget *img = gtk_grid_get_child_at(GTK_GRID(grid), 0, 0);
if (!mx_strcmp(login, gtk_label_get_text(GTK_LABEL(label))))
mx_rep_img(img, group_img, 48, 48);
node = g_list_next(node);
}
g_list_free(head);
(void)button;
}
```
<Overlap Ratio: 0.9602739726027397>

---

--- 348 --
Question ID: 329623028032166a25cf378bfd8440be7cba61e4_8
Original Code:
```
static void HAL_ResetPinMakeOutput(void)
{
	struct port_config pin_conf;
	port_get_config_defaults(&pin_conf);
	pin_conf.direction = PORT_PIN_DIR_OUTPUT;
	port_pin_set_config(SX_RF_RESET_PIN,&pin_conf);
}
```


Overlapping Code:
```
atic void HAL_ResetPinMakeOutput(void)
{
struct port_config pin_conf;
port_get_config_defaults(&pin_conf);
pin_conf.direction = PORT_PIN_DIR_OUTPUT;
port_pin_set_config(
```
<Overlap Ratio: 0.845>

---

--- 349 --
Question ID: ac4060e16e102410c0c11f982f759614dae2bad8_0
Original Code:
```
int main(void)
{
    int rows = 3;
    int cols = 5;
    double array[rows][cols];
    input_array(rows, cols, array);
    show_result(rows, cols, array);
    return 0;
}
```


Overlapping Code:
```
int main(void)
{
int rows = 3;
int cols = 5;
double array[rows][cols];
input_array(rows, cols, array
```
<Overlap Ratio: 0.684931506849315>

---

--- 350 --
Question ID: c674f940b145340f9658d2e66412181c50e47bd5_104
Original Code:
```
struct tevent_req *rpccli_spoolss_GetPrinterData_send(TALLOC_CTX *mem_ctx,
						      struct tevent_context *ev,
						      struct rpc_pipe_client *cli,
						      struct policy_handle *_handle /* [in] [ref] */,
						      const char *_value_name /* [in] [charset(UTF16)] */,
						      enum winreg_Type *_type /* [out] [ref] */,
						      uint8_t *_data /* [out] [ref,size_is(offered)] */,
						      uint32_t _offered /* [in]  */,
						      uint32_t *_needed /* [out] [ref] */)
{
	struct tevent_req *req;
	struct rpccli_spoolss_GetPrinterData_state *state;
	struct tevent_req *subreq;

	req = tevent_req_create(mem_ctx, &state,
				struct rpccli_spoolss_GetPrinterData_state);
	if (req == NULL) {
		return NULL;
	}
	state->out_mem_ctx = NULL;
	state->dispatch_recv = cli->dispatch_recv;

	/* In parameters */
	state->orig.in.handle = _handle;
	state->orig.in.value_name = _value_name;
	state->orig.in.offered = _offered;

	/* Out parameters */
	state->orig.out.type = _type;
	state->orig.out.data = _data;
	state->orig.out.needed = _needed;

	/* Result */
	ZERO_STRUCT(state->orig.out.result);

	state->out_mem_ctx = talloc_named_const(state, 0,
			     "rpccli_spoolss_GetPrinterData_out_memory");
	if (tevent_req_nomem(state->out_mem_ctx, req)) {
		return tevent_req_post(req, ev);
	}

	/* make a temporary copy, that we pass to the dispatch function */
	state->tmp = state->orig;

	subreq = cli->dispatch_send(state, ev, cli,
				    &ndr_table_spoolss,
				    NDR_SPOOLSS_GETPRINTERDATA,
				    &state->tmp);
	if (tevent_req_nomem(subreq, req)) {
		return tevent_req_post(req, ev);
	}
	tevent_req_set_callback(subreq, rpccli_spoolss_GetPrinterData_done, req);
	return req;
}
```


Overlapping Code:
```
tevent_req *rpccli_spoolss_GetPrinterData_send(TALLOC_CTX *mem_ctx,
struct tevent_context *ev,
struct rpc_pipe_client *cli,
struct policy_handle *_handle /* [in] [ref] */,
const char *_value_name /* [in] [charset(UTF16)] */,
enum winreg_Type *_type /* [out] [ref] */,
uint8_t *_data /* [out] [ref,size_is(offered)] */,
uint32_t _offered /* [in] */,
uint32_t *_needed /* [out] [ref] */)
{
struct tevent_req *req;
struct rpccli_spoolss_GetPrinterData_state *state;
struct tevent_req *subreq;
req = tevent_req_create(mem_ctx, &state,
struct rpccli_spoolss_GetPrinterData_state);
if (req == NULL) {
return NULL;
}
state->out_mem_ctx = NULL;
state->dispatch_recv = cli->dispatch_recv;
/* In parameters */
state->orig.in.handle = _handle;
state->orig.in.value_name = _value_name;
state->orig.in.offered = _offered;
/* Out parameters */
state->orig.out.type = _type;
state->orig.out.data = _data;
state->orig.out.needed = _needed;
/* Result */
ZERO_STRUCT(state->orig.out.result);
state->out_mem_ctx = talloc_named_const(state, 0,
"rpccli_spoolss_GetPrinterData_out_memory");
if (tevent_req_nomem(state->out_mem_ctx, req)) {
return tevent_req_post(req, ev);
}
/* make a temporary copy, that we pass to the dispatch function */
state->tmp = state->orig;
subreq = cli->dispatch_send(state, ev, cli,
&ndr_table_spoolss,
NDR_SPOOLSS_GETPRINTERDATA,
&state->tmp);
if (tevent_req_nomem(subreq, req)) {
return tevent_req_post(req, ev);
}
tevent_req_set_callback(subreq, rpccli_spoolss_GetPrinterData_done, req);
return 
```
<Overlap Ratio: 0.9914361001317523>

---

--- 351 --
Question ID: 645132a892107512a1ff76b5ecae273b937b4f66_21
Original Code:
```
static char **handle_switch_O(char *arg, char **next)
{
	int level = 1;
	if (arg[1] >= '0' && arg[1] <= '9')
		level = arg[1] - '0';
	optimize = level;
	optimize_size = arg[1] == 's';
	return next;
}
```


Overlapping Code:
```
har *arg, char **next)
{
int level = 1;
if (arg[1] >= '0' && arg[1] <= '9')
level = arg[1] - '0';
optimize = level;
optimize_size = arg[1] == 's';
ret
```
<Overlap Ratio: 0.78125>

---

--- 352 --
Question ID: a0af2da5782a1d7ad7a0247973864e7515dc145b_2
Original Code:
```
static int
ipmp_readgroupinfo_lists(ipmp_state_t *statep, ipmp_groupinfo_t *grinfop,
    const struct timeval *endtp)
{
	int retval;
	ipmp_iflist_t *iflistp;
	ipmp_addrlist_t *adlistp;

	retval = ipmp_readinfo(statep, IPMP_IFLIST, (void **)&iflistp, endtp);
	if (retval != IPMP_SUCCESS)
		return (retval);

	retval = ipmp_readinfo(statep, IPMP_ADDRLIST, (void **)&adlistp, endtp);
	if (retval != IPMP_SUCCESS) {
		ipmp_freeiflist(iflistp);
		return (retval);
	}

	grinfop->gr_iflistp = iflistp;
	grinfop->gr_adlistp = adlistp;
	return (IPMP_SUCCESS);
}
```


Overlapping Code:
```
p_readgroupinfo_lists(ipmp_state_t *statep, ipmp_groupinfo_t *grinfop,
const struct timeval *endtp)
{
int retval;
ipmp_iflist_t *iflistp;
ipmp_addrlist_t *adlistp;
retval = ipmp_readinfo(statep, IPMP_IFLIST, (void **)&iflistp, endtp);
if (retval != IPMP_SUCCESS)
return (retval);
retval = ipmp_readinfo(statep, IPMP_ADDRLIST, (void **)&adlistp, endtp);
if (retval != IPMP_SUCCESS) {
ipmp_freeiflist(iflistp);
return (retval);
}
grinfop->gr_iflistp = iflistp;
grinfop->gr_adlistp = adlistp;
return (IP
```
<Overlap Ratio: 0.946969696969697>

---

--- 353 --
Question ID: 25a9a2a4d717279f5802c7e15a70c48192810d46_90
Original Code:
```
static real_T c10_get_BOREDOM_THRESHOLD
  (SFc10_ARP_02_RPSsmile_GloveAtomicRachelImitateSmileInstanceStruct
   *chartInstance, uint32_T c10_b)
{
  ssReadFromDataStoreElement(chartInstance->S, 0, NULL, c10_b);
  if (chartInstance->c10_BOREDOM_THRESHOLD_address == 0) {
    sf_mex_error_message("Invalid access to Data Store Memory data \'BOREDOM_THRESHOLD\' (#519) in the initialization routine of the chart.\n");
  }

  return *chartInstance->c10_BOREDOM_THRESHOLD_address;
}
```


Overlapping Code:
```
_BOREDOM_THRESHOLD
(SFc10_ARP_02_RPSsmile_GloveAtomicRachelImitateSmileInstanceStruct
*chartInstance, uint32_T c10_b)
{
ssReadFromDataStoreElement(chartInstance->S, 0, NULL, c10_b);
if (chartInstance->c10_BOREDOM_THRESHOLD_address == 0) {
sf_mex_error_message("Invalid access to Data Store Memory data \'BOREDOM_THRESHOLD\' (#519) in the initialization routine of the chart.\n");
}
return *chartInstance->c10_
```
<Overlap Ratio: 0.8930131004366813>

---

--- 354 --
Question ID: 798496353e8c6aa824a4582355dfbbe36424d9aa_4
Original Code:
```
static ssize_t store_ideapad_cam(struct device *dev,
				 struct device_attribute *attr,
				 const char *buf, size_t count)
{
	int ret, state;

	if (!count)
		return 0;
	if (sscanf(buf, "%i", &state) != 1)
		return -EINVAL;
	ret = ideapad_dev_set_state(IDEAPAD_DEV_CAMERA, !!state);
	if (ret < 0)
		return ret;
	return count;
}
```


Overlapping Code:
```
static ssize_t store_ideapad_cam(struct device *dev,
struct device_attribute *attr,
const char *buf, size_t count)
{
int ret, state;
if (!count)
return 0;
if (sscanf(buf, "%i", &state) != 1)
return -EINVAL;
ret = ideapad_dev_set_state(IDEAPAD_DEV_CAMERA, !!state);
if (ret < 0)
return ret;
ret
```
<Overlap Ratio: 0.9606557377049181>

---

--- 355 --
Question ID: 5a2c83295014c04d8d2147568fa86efe1cfa94bd_10
Original Code:
```
int
ibtl_cm_is_multi_sm(ib_guid_t hca_guid)
{
	ibtl_hca_devinfo_t	*hdevp;	/* HCA Dev Info */
	uint_t			multi_sm;

	mutex_enter(&ibtl_clnt_list_mutex);
	hdevp = ibtl_get_hcadevinfo(hca_guid);
	if (hdevp == NULL) {
		IBTF_DPRINTF_L2(ibtf_cm, "ibtl_cm_is_multi_sm: NO HCA (%llX) "
		    "availble", hca_guid);
		mutex_exit(&ibtl_clnt_list_mutex);
		return (-1);
	}
	multi_sm = hdevp->hd_multism;
	mutex_exit(&ibtl_clnt_list_mutex);

	IBTF_DPRINTF_L3(ibtf_cm, "ibtl_cm_is_multi_sm(%llX): %d", hca_guid,
	    multi_sm);

	return (multi_sm);
}
```


Overlapping Code:
```
l_cm_is_multi_sm(ib_guid_t hca_guid)
{
ibtl_hca_devinfo_t *hdevp; /* HCA Dev Info */
uint_t multi_sm;
mutex_enter(&ibtl_clnt_list_mutex);
hdevp = ibtl_get_hcadevinfo(hca_guid);
if (hdevp == NULL) {
IBTF_DPRINTF_L2(ibtf_cm, "ibtl_cm_is_multi_sm: NO HCA (%llX) "
"availble", hca_guid);
mutex_exit(&ibtl_clnt_list_mutex);
return (-1);
}
multi_sm = hdevp->hd_multism;
mutex_exit(&ibtl_clnt_list_mutex);
IBTF_DPRINTF_L3(ibtf_cm, "ibtl_cm_is_multi_sm(%llX)
```
<Overlap Ratio: 0.8910891089108911>

---

--- 356 --
Question ID: 54551954d929c6c244701120d5a73ccb730787f0_1
Original Code:
```
static void *listener(void *arg)
{
	struct listener *me = (struct listener *)arg;
	int numOutBufs = 0;
	int nErr = 0;
	adsp_listener_invoke_ctx ctx = 0;
	struct invoke_bufs *bufs = 0;
	boolean bNeedMore;
	int result = -1;
	adsp_listener_remote_handle handle;
	uint32 sc, ii, inBufsAllocated = 0;
	const char *eheap = getenv("ADSP_LISTENER_HEAP_ID");
	int heapid = eheap == 0 ? -1 : atoi(eheap);
	const char *eflags = getenv("ADSP_LISTENER_HEAP_FLAGS");
	uint32 flags = eflags == 0 ? 0 : atoi(eflags);
	eventfd_t event = 0xff;

	VERIFY_EPRINTF("listener using ion heap: %d\n", heapid);

	VERIFY(0 != (bufs = rpcmem_realloc(heapid, flags, 0, 0, sizeof(*bufs))));
	memset(bufs, 0, sizeof(*bufs));

	do
	{
invoke:
		bNeedMore = FALSE;
		sc = 0xffffffff;
		if (result != 0)
		{
			numOutBufs = 0;
		}
		nErr = __QAIC_HEADER(adsp_listener_next_invoke)(
		           ctx, result, bufs->outbufs, numOutBufs, &ctx,
		           &handle, &sc, bufs->inbufs, inBufsAllocated,
		           bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS);
		if (nErr)
		{
			VERIFY_EPRINTF("listener protocol failure %d\n", nErr);
			VERIFY(0 == (nErr = __QAIC_HEADER(adsp_listener_next_invoke)(
			                        ctx, nErr, 0, 0, &ctx,
			                        &handle, &sc, bufs->inbufs, inBufsAllocated,
			                        bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS)));
		}

		if (MAX_BUFS < REMOTE_SCALARS_INBUFS(sc) || MAX_BUFS < REMOTE_SCALARS_OUTBUFS(sc))
		{
			result = - 8;
			goto invoke;
		}
		for (ii = 0; ii < REMOTE_SCALARS_INBUFS(sc); ++ii)
		{
			if (bufs->inbufs[ii].dataLen < bufs->inbufLenReqs[ii])
			{
				if (0 != bufs->inbufLenReqs[ii])
				{
					bufs->inbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->inbufs[ii].data,  bufs->inbufs[ii].dataLen, bufs->inbufLenReqs[ii]);
					if (0 == bufs->inbufs[ii].data)
					{
						bufs->inbufs[ii].dataLen = 0;
						result = -8;
						goto invoke;
					}
				}
				bufs->inbufs[ii].dataLen = bufs->inbufLenReqs[ii];
				inBufsAllocated = STD_MAX(inBufsAllocated, ii + 1);
				bNeedMore = TRUE;
			}
			bufs->args[ii].buf.pv = bufs->inbufs[ii].data;
			bufs->args[ii].buf.nLen = bufs->inbufLenReqs[ii];
		}
		for (ii = 0; ii < REMOTE_SCALARS_OUTBUFS(sc); ++ii)
		{
			if (bufs->outbufs[ii].dataLen < bufs->outbufLenReqs[ii])
			{
				if (0 !=  bufs->outbufLenReqs[ii])
				{
					bufs->outbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->outbufs[ii].data, bufs->outbufs[ii].dataLen, bufs->outbufLenReqs[ii]);
					if (0 == bufs->outbufs[ii].data)
					{
						result = -8;
						goto invoke;
					}
				}
				bufs->outbufs[ii].dataLen = bufs->outbufLenReqs[ii];
			}
			bufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.pv = bufs->outbufs[ii].data;
			bufs->args[ii + REMOTE_SCALARS_INBUFS(sc)].buf.nLen = bufs->outbufLenReqs[ii];
		}
		numOutBufs = REMOTE_SCALARS_OUTBUFS(sc);
		if (bNeedMore)
		{
			assert(inBufsAllocated >= REMOTE_SCALARS_INBUFS(sc));
			if (0 != (result = __QAIC_HEADER(adsp_listener_invoke_get_in_bufs)(ctx, bufs->inbufs,
			                   REMOTE_SCALARS_INBUFS(sc))))
			{
				VERIFY_EPRINTF("adsp_listener_invoke_get_in_bufs failed  %d\n", result);
				goto invoke;
			}
		}

		result = mod_table_handle_invoke(&me->mt, handle, sc, bufs->args);
	}
	while (1);
bail:
	for (ii = 0; ii < MAX_BUFS && bufs; ++ii)
	{
		RPC_FREEIF(heapid, bufs->outbufs[ii].data);
		RPC_FREEIF(heapid, bufs->inbufs[ii].data);
	}
	RPC_FREEIF(heapid, bufs);
	if (nErr)
	{
		VERIFY_EPRINTF("listener thread exiting with code %d\n", nErr);
		if (0 != adsp_current_process_exit())
		{
			VERIFY_EPRINTF("listener thread failed to cleanly shutdown.  This is ok durring process exit.\n");
		}
	}
	eventfd_write(me->eventfd, event);
	return (void *)(uintptr_t)nErr;
}
```


Overlapping Code:
```
id *arg)
{
struct listener *me = (struct listener *)arg;
int numOutBufs = 0;
int nErr = 0;
adsp_listener_invoke_ctx ctx = 0;
struct invoke_bufs *bufs = 0;
boolean bNeedMore;
int result = -1;
adsp_listener_remote_handle handle;
uint32 sc, ii, inBufsAllocated = 0;
const char *eheap = getenv("ADSP_LISTENER_HEAP_ID");
int heapid = eheap == 0 ? -1 : atoi(eheap);
const char *eflags = getenv("ADSP_LISTENER_HEAP_FLAGS");
uint32 flags = eflags == 0 ? 0 : atoi(eflags);
eventfd_t event = 0xff;
VERIFY_EPRINTF("listener using ion heap: %d\n", heapid);
VERIFY(0 != (bufs = rpcmem_realloc(heapid, flags, 0, 0, sizeof(*bufs))));
memset(bufs, 0, sizeof(*bufs));
do
{
invoke:
bNeedMore = FALSE;
sc = 0xffffffff;
if (result != 0)
{
numOutBufs = 0;
}
nErr = __QAIC_HEADER(adsp_listener_next_invoke)(
ctx, result, bufs->outbufs, numOutBufs, &ctx,
&handle, &sc, bufs->inbufs, inBufsAllocated,
bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS);
if (nErr)
{
VERIFY_EPRINTF("listener protocol failure %d\n", nErr);
VERIFY(0 == (nErr = __QAIC_HEADER(adsp_listener_next_invoke)(
ctx, nErr, 0, 0, &ctx,
&handle, &sc, bufs->inbufs, inBufsAllocated,
bufs->inbufLenReqs, MAX_BUFS, bufs->outbufLenReqs, MAX_BUFS)));
}
if (MAX_BUFS < REMOTE_SCALARS_INBUFS(sc) || MAX_BUFS < REMOTE_SCALARS_OUTBUFS(sc))
{
result = - 8;
goto invoke;
}
for (ii = 0; ii < REMOTE_SCALARS_INBUFS(sc); ++ii)
{
if (bufs->inbufs[ii].dataLen < bufs->inbufLenReqs[ii])
{
if (0 != bufs->inbufLenReqs[ii])
{
bufs->inbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->inbufs[ii].data, bufs->inbufs[ii].dataLen, bufs->inbufLenReqs[ii]);
if (0 == bufs->inbufs[ii].data)
{
bufs->inbufs[ii].dataLen = 0;
result = -8;
goto invoke;
}
}
bufs->inbufs[ii].dataLen = bufs->inbufLenReqs[ii];
inBufsAllocated = STD_MAX(inBufsAllocated, ii + 1);
bNeedMore = TRUE;
}
bufs->args[ii].buf.pv = bufs->inbufs[ii].data;
bufs->args[ii].buf.nLen = bufs->inbufLenReqs[ii];
}
for (ii = 0; ii < REMOTE_SCALARS_OUTBUFS(sc); ++ii)
{
if (bufs->outbufs[ii].dataLen < bufs->outbufLenReqs[ii])
{
if (0 != bufs->outbufLenReqs[ii])
{
bufs->outbufs[ii].data = rpcmem_realloc(heapid, flags, bufs->outbufs[ii].data, bufs->outbufs[ii
```
<Overlap Ratio: 0.9732910819375283>

---

--- 357 --
Question ID: 4a7e249f84404ba049c38add27a511ae501f8ec2_3
Original Code:
```
static usbdifStatus_t
UsbdVendorDataIn(usbdifClassDef_t *prc, uint8_t epnum)
{
  usbdVendorHandle_t        *pVendor;

  pVendor = (usbdVendorHandle_t*) prc->pClassData;

  if(pVendor != USBDIF_NULL) {
    pVendor->TxState = 0;
    return USBDIF_STATUS_SUCCESS;
  } else {
    return USBDIF_STATUS_UNKNOWN;
  }
}
```


Overlapping Code:
```
bdifClassDef_t *prc, uint8_t epnum)
{
usbdVendorHandle_t *pVendor;
pVendor = (usbdVendorHandle_t*) prc->pClassData;
if(pVendor != USBDIF_NULL) {
pVendor->TxState = 0;
return USBDIF_STATUS_SUCCESS;
} else {
return USBDIF_STATUS_UN
```
<Overlap Ratio: 0.8178571428571428>

---

--- 358 --
Question ID: 76562a7da975b1d201e3dd3cd8daf02cea150537_1
Original Code:
```
void  CPU_BitBandSet (CPU_ADDR    addr,
                      CPU_INT08U  bit_nbr)
{
    CPU_ADDR  bit_word_off;
    CPU_ADDR  bit_word_addr;


    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 1;

    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 1;
    }
}
```


Overlapping Code:
```
 CPU_BitBandSet (CPU_ADDR addr,
CPU_INT08U bit_nbr)
{
CPU_ADDR bit_word_off;
CPU_ADDR bit_word_addr;
if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
(addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
bit_word_off = ((addr - CPU_BIT_BAND_SRAM_REG_LO ) * 32) + (bit_nbr * 4);
bit_word_addr = CPU_BIT_BAND_SRAM_BASE + bit_word_off;
*(volatile CPU_INT32U *)(bit_word_addr) = 1;
} else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
(addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
bit_word_off = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;
*(volatile CPU_INT32U *)(bit_word_addr) 
```
<Overlap Ratio: 0.9809523809523809>

---

--- 359 --
Question ID: 0b6b9e9a49462f32af57621e2af7632665f51db1_2
Original Code:
```
int main()
{
	printf("%s\n", "Please, enter base and power -- a and b");
	long long base = 0;
	int power = 0;
	scanf("%lld %i", &base, &power);
	if (power < 0)
	{
		printf("Power should be positive");
		return 0;
	}
	if (base == 0 && power == 0)
	{
		printf("0 power 0 is undefined");
		return 0;
	}

	printf("Linear running time:\n");
	if (testLinear() == 0)
	{
		printf("  Tests failed\n");
	}
	else
	{
		printf("  Tests succeed\n  a power b = %lld\n", exponentiation(base, power));
	}

	printf("\nO(log b) running time:\n");
	if (testLogarifmic() == 0)
	{
		printf("  Tests failed\n");
		return 0;
	}
	else
	{
		printf("  Tests succeed\n  a power b = %lld\n", exponentiationLogn(base, power));
	}

	return 0;
}
```


Overlapping Code:
```
ase and power -- a and b");
long long base = 0;
int power = 0;
scanf("%lld %i", &base, &power);
if (power < 0)
{
printf("Power should be positive");
return 0;
}
if (base == 0 && power == 0)
{
printf("0 power 0 is undefined");
return 0;
}
printf("Linear running time:\n");
if (testLinear() == 0)
{
printf(" Tests failed\n");
}
else
{
printf(" Tests succeed\n a power b = %lld\n", exponentiation(base, power));
}
printf("\nO(log b) running time:\n");
if (testLogarifmic() == 0)
{
printf(" Tests failed\n");
return 0;
}
else
{
printf(" Tests succeed\n a power b = %lld\n", exponentiationLogn(base, power
```
<Overlap Ratio: 0.9077155824508321>

---

--- 360 --
Question ID: 8632eb3a321ccd453d4e1114713f4edf2ae3a5ee_23
Original Code:
```
static void
SV_RunCmd (usercmd_t *ucmd, qboolean inside)
{
	edict_t    *ent;
	int         i, n;
	int         oldmsec;

	if (!inside && sv_timekick->ivalue) {
		double	time_since;
		int		time_allowed;

		if (host_client->msec_last_check == -1)
			goto SV_RunCmd__clear;

		host_client->msecs += ucmd->msec;
		time_since = svs.realtime - host_client->msec_last_check;
		if (time_since >= sv_timekick_interval->ivalue) {
			time_allowed = time_since * (1000 + sv_timekick_allowed->ivalue);
			if (host_client->msecs > time_allowed) {
				host_client->msec_over++;
				SV_BroadcastPrintf(PRINT_HIGH, "Temporal anomaly:\n"
						"%f in %f for %s (%d/%d)\n", host_client->msecs,
						time_since, host_client->name, host_client->msec_over,
						sv_timekick->ivalue);
				if (host_client->msec_over >= sv_timekick->ivalue) {
					SV_BroadcastPrintf(PRINT_HIGH,
							"Kicked %s for time sync errors. (%d times)\n",
							host_client->name, host_client->msec_over);
					SV_DropClient (host_client);
					return;
				}
			}
		}
SV_RunCmd__clear:
		host_client->msecs = 0;
		host_client->msec_last_check = svs.realtime;
	}
		
	cmd = *ucmd;

	// chop up very long commands
	if (cmd.msec > 50) {
		oldmsec = ucmd->msec;
		cmd.msec = oldmsec / 2;
		SV_RunCmd (&cmd, true);
		cmd.msec = oldmsec / 2;
		cmd.impulse = 0;
		SV_RunCmd (&cmd, true);
		return;
	}

	if (!sv_player->v.fixangle)
		VectorCopy (ucmd->angles, sv_player->v.v_angle);

	sv_player->v.button0 = ucmd->buttons & 1;
	sv_player->v.button2 = (ucmd->buttons & 2) >> 1;
	sv_player->v.button1 = (ucmd->buttons & 4) >> 2;
	if (ucmd->impulse)
		sv_player->v.impulse = ucmd->impulse;

//
// angles
// show 1/3 the pitch angle and all the roll angle  
	if (sv_player->v.health > 0) {
		if (!sv_player->v.fixangle) {
			sv_player->v.angles[PITCH] = -sv_player->v.v_angle[PITCH] / 3;
			sv_player->v.angles[YAW] = sv_player->v.v_angle[YAW];
		}
		sv_player->v.angles[ROLL] =
			V_CalcRoll (sv_player->v.angles, sv_player->v.velocity) * 4;
	}

	host.frametime = ucmd->msec * 0.001;
	if (host.frametime > 0.1)
		host.frametime = 0.1;

	if (!host_client->spectator) {
		pr_global_struct->frametime = host.frametime;

		pr_global_struct->time = sv.time;
		pr_global_struct->self = EDICT_TO_PROG (sv_player);
		PR_ExecuteProgram (pr_global_struct->PlayerPreThink);

		SV_RunThink (sv_player);
	}

	for (i = 0; i < 3; i++)
		pmove.origin[i] =
			sv_player->v.origin[i] + (sv_player->v.mins[i] - player_mins[i]);
	VectorCopy (sv_player->v.velocity, pmove.velocity);
	VectorCopy (sv_player->v.v_angle, pmove.angles);

	pmove.spectator = host_client->spectator;
	pmove.waterjumptime = sv_player->v.teleport_time;
	pmove.numphysent = 1;
	pmove.physents[0].model = sv.worldmodel;
	pmove.physents[0].id = -1;
	pmove.cmd = *ucmd;
	pmove.dead = sv_player->v.health <= 0;
	pmove.oldbuttons = host_client->oldbuttons;
	pmove.player_id = -1;

	movevars.entgravity = host_client->entgravity;
	movevars.maxspeed = host_client->maxspeed;

	for (i = 0; i < 3; i++) {
		pmove_mins[i] = pmove.origin[i] - 256;
		pmove_maxs[i] = pmove.origin[i] + 256;
	}
	AddLinksToPmove (sv_areanodes);
	PlayerMove ();

	host_client->oldbuttons = pmove.oldbuttons;
	sv_player->v.teleport_time = pmove.waterjumptime;
	sv_player->v.waterlevel = pmove.waterlevel;
	sv_player->v.watertype = pmove.watertype;
	if (pmove.groundent) {
		sv_player->v.flags = (int) sv_player->v.flags | FL_ONGROUND;
		sv_player->v.groundentity =
			EDICT_TO_PROG (EDICT_NUM (pmove.groundent->info));
	} else
		sv_player->v.flags = (int) sv_player->v.flags & ~FL_ONGROUND;
	for (i = 0; i < 3; i++)
		sv_player->v.origin[i] =
			pmove.origin[i] - (sv_player->v.mins[i] - player_mins[i]);

	VectorCopy (pmove.velocity, sv_player->v.velocity);

	VectorCopy (pmove.angles, sv_player->v.v_angle);

	if (!host_client->spectator) {
		// link into place and touch triggers
		SV_LinkEdict (sv_player, true);

		// touch other objects
		for (i = 0; i < pmove.numtouch; i++) {
			n = pmove.touch[i]->info;
			ent = EDICT_NUM (n);
			if (!ent->v.touch || (playertouch[n / 8] & (1 << (n % 8))))
				continue;
			pr_global_struct->self = EDICT_TO_PROG (ent);
			pr_global_struct->other = EDICT_TO_PROG (sv_player);
			PR_ExecuteProgram (ent->v.touch);
			playertouch[n / 8] |= 1 << (n % 8);
		}
	}
}
```


Overlapping Code:
```
d (usercmd_t *ucmd, qboolean inside)
{
edict_t *ent;
int i, n;
int oldmsec;
if (!inside && sv_timekick->ivalue) {
double time_since;
int time_allowed;
if (host_client->msec_last_check == -1)
goto SV_RunCmd__clear;
host_client->msecs += ucmd->msec;
time_since = svs.realtime - host_client->msec_last_check;
if (time_since >= sv_timekick_interval->ivalue) {
time_allowed = time_since * (1000 + sv_timekick_allowed->ivalue);
if (host_client->msecs > time_allowed) {
host_client->msec_over++;
SV_BroadcastPrintf(PRINT_HIGH, "Temporal anomaly:\n"
"%f in %f for %s (%d/%d)\n", host_client->msecs,
time_since, host_client->name, host_client->msec_over,
sv_timekick->ivalue);
if (host_client->msec_over >= sv_timekick->ivalue) {
SV_BroadcastPrintf(PRINT_HIGH,
"Kicked %s for time sync errors. (%d times)\n",
host_client->name, host_client->msec_over);
SV_DropClient (host_client);
return;
}
}
}
SV_RunCmd__clear:
host_client->msecs = 0;
host_client->msec_last_check = svs.realtime;
}

cmd = *ucmd;
// chop up very long commands
if (cmd.msec > 50) {
oldmsec = ucmd->msec;
cmd.msec = oldmsec / 2;
SV_RunCmd (&cmd, true);
cmd.msec = oldmsec / 2;
cmd.impulse = 0;
SV_RunCmd (&cmd, true);
return;
}
if (!sv_player->v.fixangle)
VectorCopy (ucmd->angles, sv_player->v.v_angle);
sv_player->v.button0 = ucmd->buttons & 1;
sv_player->v.button2 = (ucmd->buttons & 2) >> 1;
sv_player->v.button1 = (ucmd->buttons & 4) >> 2;
if (ucmd->impulse)
sv_player->v.impulse = ucmd->impulse;
//
// angles
// show 1/3 the pitch angle and all the roll angle 
if (sv_player->v.health > 0) {
if (!sv_player->v.fixangle) {
sv_player->v.angles[PITCH] = -sv_player->v.v_angle[PITCH] / 3;
sv_player->v.angles[YAW] = sv_player->v.v_angle[YAW];
}
sv_player->v.angles[ROLL] =
V_CalcRoll (sv_player->v.angles, sv_player->v.velocity) * 4;
}
host.frametime = ucmd->msec * 0.001;
if (host.frametime > 0.1)
host.frametime = 0.1;
if (!host_client->spectator) {
pr_global_struct->frametime = host.frametime;
pr_global_struct->time = sv.time;
pr_global_struct->self = EDICT_TO_PROG (sv_player);
PR_ExecuteProgram (pr_global_struct->PlayerPreThink);
SV_RunThink (sv_player);
}
for (i = 0; i < 3; i++)
pmove.origin[i] =
sv_player->v.origin[i] + (sv_player->v.mins[i] - player_mins[i]);
VectorCopy (sv_player->v.velocity, pmo
```
<Overlap Ratio: 0.9878207916485429>

---

--- 361 --
Question ID: 6847d16db44004f0f8a5d1d2650bfe12079da031_35
Original Code:
```
int altmdm_pm_deregistercb(uint32_t type)
{
  altmdm_pm_cbfunc_t *lcallback = NULL;

  if (!g_is_initdone)
    {
      return -EPERM;
    }

  if (type == MODEM_PM_CB_TYPE_ERROR)
    {
      lcallback = &g_pm_errcallback;
    }
  else
    {
      lcallback = &g_pm_callback;
    }
  if (*lcallback == NULL)
    {
      return -EPERM;
    }

  *lcallback = NULL;

  return 0;
}
```


Overlapping Code:
```
t32_t type)
{
altmdm_pm_cbfunc_t *lcallback = NULL;
if (!g_is_initdone)
{
return -EPERM;
}
if (type == MODEM_PM_CB_TYPE_ERROR)
{
lcallback = &g_pm_errcallback;
}
else
{
lcallback = &g_pm_callback;
}
if (*lcallback == NULL)
{
return -EPERM;
}
*lcallback = N
```
<Overlap Ratio: 0.847682119205298>

---

--- 362 --
Question ID: cf5f4b9bc4c411a40ba0ed680a4b06a55f935d4c_6
Original Code:
```
const char *AVSC_CC avisynth_c_plugin_init( AVS_ScriptEnvironment* env )
{
    /* load the avs library */
    if( ffms_load_avs_lib( env ) )
        return "Failure";
    ffms_avs_lib.avs_add_function( env, "FFIndex", "[source]s[cachefile]s[indexmask]i[dumpmask]i[audiofile]s[errorhandling]i[overwrite]b[utf8]b", create_FFIndex, 0 );
    ffms_avs_lib.avs_add_function( env, "FFVideoSource", "[source]s[track]i[cache]b[cachefile]s[fpsnum]i[fpsden]i[threads]i[timecodes]s[seekmode]i[rffmode]i[width]i[height]i[resizer]s[colorspace]s[utf8]b[varprefix]s", create_FFVideoSource, 0 );
    ffms_avs_lib.avs_add_function( env, "FFAudioSource", "[source]s[track]i[cache]b[cachefile]s[adjustdelay]i[utf8]b[varprefix]s", create_FFAudioSource, 0 );
    ffms_avs_lib.avs_add_function( env, "FFGetLogLevel", "", create_FFGetLogLevel, 0 );
    ffms_avs_lib.avs_add_function( env, "FFSetLogLevel", "i", create_FFSetLogLevel, 0 );
    ffms_avs_lib.avs_add_function( env, "FFGetVersion", "", create_FFGetVersion, 0 );

    /* tell avs to call our cleanup method when it closes */
    ffms_avs_lib.avs_at_exit( env, ffms_free_avs_lib, 0 );
    return "FFmpegSource - The Second Coming V2.0 Final";
}
```


Overlapping Code:
```
init( AVS_ScriptEnvironment* env )
{
/* load the avs library */
if( ffms_load_avs_lib( env ) )
return "Failure";
ffms_avs_lib.avs_add_function( env, "FFIndex", "[source]s[cachefile]s[indexmask]i[dumpmask]i[audiofile]s[errorhandling]i[overwrite]b[utf8]b", create_FFIndex, 0 );
ffms_avs_lib.avs_add_function( env, "FFVideoSource", "[source]s[track]i[cache]b[cachefile]s[fpsnum]i[fpsden]i[threads]i[timecodes]s[seekmode]i[rffmode]i[width]i[height]i[resizer]s[colorspace]s[utf8]b[varprefix]s", create_FFVideoSource, 0 );
ffms_avs_lib.avs_add_function( env, "FFAudioSource", "[source]s[track]i[cache]b[cachefile]s[adjustdelay]i[utf8]b[varprefix]s", create_FFAudioSource, 0 );
ffms_avs_lib.avs_add_function( env, "FFGetLogLevel", "", create_FFGetLogLevel, 0 );
ffms_avs_lib.avs_add_function( env, "FFSetLogLevel", "i", create_FFSetLogLevel, 0 );
ffms_avs_lib.avs_add_function( env, "FFGetVersion", "", create_FFGetVersion, 0 );
/* tell avs to call our cleanup method when it closes */
ffms_avs_lib.avs_at_exit( env, ffms_free_avs_lib, 0 );
return "FFmpegSource - The Second Coming V2.0 Final"
```
<Overlap Ratio: 0.963620230700976>

---

--- 363 --
Question ID: 1314e52a7e38705cd25d76479500654f245ac0bc_0
Original Code:
```
void insert(node** h, int key)
{
	node* temp = malloc(sizeof(node));
	temp->data = key;
	if(*h)
	{
		temp->next = *h;
		temp = *h;
	}
	else
	{
		temp->next = NULL;
		*h = temp;
	}
}
```


Overlapping Code:
```
key)
{
node* temp = malloc(sizeof(node));
temp->data = key;
if(*h)
{
temp->next = *h;
temp = *h;
}
e
```
<Overlap Ratio: 0.6060606060606061>

---

--- 364 --
Question ID: 236125b624a1c7e091fece738ff2d18761d0668a_4
Original Code:
```
static int max326_setup(struct uart_dev_s *dev)
{
#ifndef CONFIG_SUPPRESS_UART_CONFIG
  struct max326_dev_s *priv = (struct max326_dev_s *)dev->priv;

  /* Configure the UART as an RS-232 UART */

  max326_uart_configure(priv->uartbase, &priv->config);
#endif

  /* Make sure that all interrupts are disabled */

  max326_int_disableall(priv, NULL);
  return OK;
}
```


Overlapping Code:
```
setup(struct uart_dev_s *dev)
{
#ifndef CONFIG_SUPPRESS_UART_CONFIG
struct max326_dev_s *priv = (struct max326_dev_s *)dev->priv;
/* Configure the UART as an RS-232 UART */
max326_uart_configure(priv->uartbase, &priv->config);
#endif
/* Make sure that all interrupts are disabled */
max326_int_disableall(priv, NULL);
r
```
<Overlap Ratio: 0.9166666666666666>

---

--- 365 --
Question ID: 1afa236a1eea7b8a1e4ddb8fb79703eb1ce05c24_87
Original Code:
```
void
ibcm_process_lap_msg(ibcm_hca_info_t *hcap, uint8_t *input_madp,
    ibcm_mad_addr_t *cm_mad_addr)
{
	ibcm_status_t		state_lookup_status;
	ibcm_lap_msg_t		*lap_msg = (ibcm_lap_msg_t *)
	    (&input_madp[IBCM_MAD_HDR_SIZE]);
	ibcm_apr_msg_t		*apr_msg;
	ibcm_state_data_t	*statep = NULL;

	IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg:");

	rw_enter(&hcap->hca_state_rwlock, RW_READER);

	state_lookup_status = ibcm_lookup_msg(IBCM_INCOMING_LAP,
	    b2h32(lap_msg->lap_remote_comm_id), 0, 0, hcap, &statep);

	rw_exit(&hcap->hca_state_rwlock);

	IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg: lookup status %x"
	    " com id %x", state_lookup_status,
	    b2h32(lap_msg->lap_remote_comm_id));

	if (state_lookup_status != IBCM_LOOKUP_EXISTS) {
		/* Post a REJ message ? - but spec doesn't state so */
		return;
	}

	/* There is an existing state structure entry with active comid */

	ibcm_insert_trace(statep, IBCM_TRACE_INCOMING_LAP);

	mutex_enter(&statep->state_mutex);

	if ((statep->state == IBCM_STATE_ESTABLISHED) &&
	    (statep->ap_state == IBCM_AP_STATE_IDLE) &&
	    (statep->mode == IBCM_PASSIVE_MODE)) {
		if ((statep->lapr_msg) &&
		    (IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID ==
		    ((ib_mad_hdr_t *)(input_madp))->TransactionID))
			ibcm_post_stored_apr_mad(statep, input_madp);
		else {
			ibcm_status_t	clnt_response;

			statep->ap_state = IBCM_AP_STATE_LAP_RCVD;
			statep->clnt_proceed = IBCM_BLOCK;
			mutex_exit(&statep->state_mutex);

			if (statep->lapr_msg == NULL) {
				if (ibcm_alloc_out_msg(
				    statep->stored_reply_addr.ibmf_hdl,
				    &statep->lapr_msg, MAD_METHOD_SEND) !=
				    IBT_SUCCESS) {

					mutex_enter(&statep->state_mutex);
					statep->clnt_proceed = IBCM_FAIL;
					cv_broadcast(&statep->block_client_cv);
					IBCM_REF_CNT_DECR(statep);
					mutex_exit(&statep->state_mutex);
					return;
				}
			}
			apr_msg = (ibcm_apr_msg_t *)
			    IBCM_OUT_MSGP(statep->lapr_msg);
			IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID =
			    ((ib_mad_hdr_t *)(input_madp))->TransactionID;
			clnt_response =
			    ibcm_cep_state_lap(statep, lap_msg, apr_msg);
			IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg:"
			    " statep 0x%p  apr status %d", statep,
			    apr_msg->apr_ap_status);

			if (clnt_response == IBCM_DEFER) {
				IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg: "
				    "client returned DEFER response");
				return;
			}

			/* fail any blocked cm proceed api calls - client bug */
			mutex_enter(&statep->state_mutex);
			statep->clnt_proceed = IBCM_FAIL;
			cv_broadcast(&statep->block_client_cv);
			mutex_exit(&statep->state_mutex);

			ibcm_post_apr_mad(statep);
			return;
		}
	}	/* drop the LAP MAD in any other state */

	IBCM_REF_CNT_DECR(statep); /* decrement the ref count */
	mutex_exit(&statep->state_mutex);
}
```


Overlapping Code:
```
msg(ibcm_hca_info_t *hcap, uint8_t *input_madp,
ibcm_mad_addr_t *cm_mad_addr)
{
ibcm_status_t state_lookup_status;
ibcm_lap_msg_t *lap_msg = (ibcm_lap_msg_t *)
(&input_madp[IBCM_MAD_HDR_SIZE]);
ibcm_apr_msg_t *apr_msg;
ibcm_state_data_t *statep = NULL;
IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg:");
rw_enter(&hcap->hca_state_rwlock, RW_READER);
state_lookup_status = ibcm_lookup_msg(IBCM_INCOMING_LAP,
b2h32(lap_msg->lap_remote_comm_id), 0, 0, hcap, &statep);
rw_exit(&hcap->hca_state_rwlock);
IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg: lookup status %x"
" com id %x", state_lookup_status,
b2h32(lap_msg->lap_remote_comm_id));
if (state_lookup_status != IBCM_LOOKUP_EXISTS) {
/* Post a REJ message ? - but spec doesn't state so */
return;
}
/* There is an existing state structure entry with active comid */
ibcm_insert_trace(statep, IBCM_TRACE_INCOMING_LAP);
mutex_enter(&statep->state_mutex);
if ((statep->state == IBCM_STATE_ESTABLISHED) &&
(statep->ap_state == IBCM_AP_STATE_IDLE) &&
(statep->mode == IBCM_PASSIVE_MODE)) {
if ((statep->lapr_msg) &&
(IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID ==
((ib_mad_hdr_t *)(input_madp))->TransactionID))
ibcm_post_stored_apr_mad(statep, input_madp);
else {
ibcm_status_t clnt_response;
statep->ap_state = IBCM_AP_STATE_LAP_RCVD;
statep->clnt_proceed = IBCM_BLOCK;
mutex_exit(&statep->state_mutex);
if (statep->lapr_msg == NULL) {
if (ibcm_alloc_out_msg(
statep->stored_reply_addr.ibmf_hdl,
&statep->lapr_msg, MAD_METHOD_SEND) !=
IBT_SUCCESS) {
mutex_enter(&statep->state_mutex);
statep->clnt_proceed = IBCM_FAIL;
cv_broadcast(&statep->block_client_cv);
IBCM_REF_CNT_DECR(statep);
mutex_exit(&statep->state_mutex);
return;
}
}
apr_msg = (ibcm_apr_msg_t *)
IBCM_OUT_MSGP(statep->lapr_msg);
IBCM_OUT_HDRP(statep->lapr_msg)->TransactionID =
((ib_mad_hdr_t *)(input_madp))->TransactionID;
clnt_response =
ibcm_cep_state_lap(statep, lap_msg, apr_msg);
IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg:"
" statep 0x%p apr status %d", statep,
apr_msg->apr_ap_status);
if (clnt_response == IBCM_DEFER) {
IBTF_DPRINTF_L4(cmlog, "ibcm_process_lap_msg: "
"client returned DEFER response");
return;
}
/* fail any blocked cm proceed api calls - client bug */
mutex_enter(&statep->state_m
```
<Overlap Ratio: 0.9875610839626833>

---

--- 366 --
Question ID: e9cd65c84b2a5a0f3e939f57f074537106c3f23d_3
Original Code:
```
int KSI_PKISignature_serialize(const KSI_PKISignature *sig, unsigned char **raw, size_t *raw_len) {
	int res = KSI_UNKNOWN_ERROR;
	unsigned char *tmp = NULL;

	if (sig == NULL || raw == NULL || raw_len == NULL){
		res = KSI_INVALID_ARGUMENT;
		goto cleanup;
	}
	KSI_ERR_clearErrors(sig->ctx);


	tmp = KSI_malloc(sig->pkcs7.cbData);
	if (tmp == NULL) {
		KSI_pushError(sig->ctx, res = KSI_OUT_OF_MEMORY, NULL);
		goto cleanup;
	}

	memcpy(tmp, sig->pkcs7.pbData, sig->pkcs7.cbData);

	*raw = tmp;
	*raw_len = (size_t)sig->pkcs7.cbData;

	tmp = NULL;

	res = KSI_OK;

cleanup:

	KSI_free(tmp);

	return res;
}
```


Overlapping Code:
```
int KSI_PKISignature_serialize(const KSI_PKISignature *sig, unsigned char **raw, size_t *raw_len) {
int res = KSI_UNKNOWN_ERROR;
unsigned char *tmp = NULL;
if (sig == NULL || raw == NULL || raw_len == NULL){
res = KSI_INVALID_ARGUMENT;
goto cleanup;
}
KSI_ERR_clearErrors(sig->ctx);
tmp = KSI_malloc(sig->pkcs7.cbData);
if (tmp == NULL) {
KSI_pushError(sig->ctx, res = KSI_OUT_OF_MEMORY, NULL);
goto cleanup;
}
memcpy(tmp, sig->pkcs7.pbData, sig->pkcs7.cbData);
*raw = tmp;
*raw_len = (size_t)sig->pkcs7.cbData;
tmp = NULL;
res = KSI_OK;
cleanup:
KSI_free(tmp);
return res
```
<Overlap Ratio: 0.9947826086956522>

---

--- 367 --
Question ID: 1a486e8f11ed27d88ebf574331e4638dcd586187_25
Original Code:
```
GH_INLINE U32  GH_VO_MIXER_get_OSD_START(void)
{
    GH_VO_MIXER_OSD_START_REAL_S real;
    GH_VO_MIXER_OSD_START_S dummy;
     dummy.all =  0;
     real.all = (*(volatile U32 *)REG_VO_MIXER_OSD_START_REAL);

    dummy.bitc.vertical = real.bitc.vertical;
    dummy.bitc.horizontal = real.bitc.horizontal;
    return dummy.all;
}
```


Overlapping Code:
```
 U32 GH_VO_MIXER_get_OSD_START(void)
{
GH_VO_MIXER_OSD_START_REAL_S real;
GH_VO_MIXER_OSD_START_S dummy;
dummy.all = 0;
real.all = (*(volatile U32 *)REG_VO_MIXER_OSD_START_REAL);
dummy.bitc.vertical = real.bitc.vertical;
dummy.bitc.horizontal = real.bitc.horizontal;
return dummy.all;
}
```
<Overlap Ratio: 0.9694915254237289>

---

--- 368 --
Question ID: d5f41eb3047e9cee55c2b94892456057ccb9f8ac_8
Original Code:
```
static sst26vf016b_error_t sst26vf016b_wakeup(void) {
	LOG_DBG("wakeup");
	u8_t buffer_tx[] = {sst26vf016b_op_RDPD};
	u8_t buffer_rx[1];
	struct spi_buf tx_buf [] = {
		{
		.buf = buffer_tx,
		.len = sizeof(buffer_tx)/sizeof(u8_t)
		}
	};
	const struct spi_buf_set tx = {
		.buffers = tx_buf,
		.count = sizeof(tx_buf)/sizeof(struct spi_buf)
	};
	const struct spi_buf rx_buf []= {
		{
		.buf = NULL,
		.len = 4,
		},
		{
		.buf = buffer_rx,
		.len = sizeof(buffer_rx),
		}
	};
	const struct spi_buf_set rx = {
		.buffers = rx_buf,
		.count = sizeof(rx_buf)/sizeof(struct spi_buf)
	};

	if (spi_transceive(sst26vf016b.spiDev, &sst26vf016b.spi_conf, &tx, &rx)) {
		return sst26vf016b_error_SPI;
	}

	if (SST26VF016B_JEDEC_DeviceID != buffer_rx[0]) {
		LOG_ERR("wrong device id! current DeviceID=0x%X vs DeviceID=0x%X",
				buffer_rx[0],
				SST26VF016B_JEDEC_DeviceID
			);
		return sst26vf016b_error_wakeup_wrongid;
	}
	k_sleep(K_MSEC(10)); // 10 msec till the device has left deep sleep
	return sst26vf016b_error_none;
}
```


Overlapping Code:
```
atic sst26vf016b_error_t sst26vf016b_wakeup(void) {
LOG_DBG("wakeup");
u8_t buffer_tx[] = {sst26vf016b_op_RDPD};
u8_t buffer_rx[1];
struct spi_buf tx_buf [] = {
{
.buf = buffer_tx,
.len = sizeof(buffer_tx)/sizeof(u8_t)
}
};
const struct spi_buf_set tx = {
.buffers = tx_buf,
.count = sizeof(tx_buf)/sizeof(struct spi_buf)
};
const struct spi_buf rx_buf []= {
{
.buf = NULL,
.len = 4,
},
{
.buf = buffer_rx,
.len = sizeof(buffer_rx),
}
};
const struct spi_buf_set rx = {
.buffers = rx_buf,
.count = sizeof(rx_buf)/sizeof(struct spi_buf)
};
if (spi_transceive(sst26vf016b.spiDev, &sst26vf016b.spi_conf, &tx, &rx)) {
return sst26vf016b_error_SPI;
}
if (SST26VF016B_JEDEC_DeviceID != buffer_rx[0]) {
LOG_ERR("wrong device id! current DeviceID=0x%X vs DeviceID=0x%X",
buffer_rx[0],
SST26VF016B_JEDEC_DeviceID
);
return sst26vf016b_error_wakeup_wrongid;
}
k_sleep(K_MSEC(10)); // 10 msec till the device has left deep sleep
return sst26vf016b_error_none;
}
```
<Overlap Ratio: 0.9978991596638656>

---

--- 369 --
Question ID: 4f60c2b6ba88c78f3c6cb4c96573c75d87f70b3f_1
Original Code:
```
static int Integrity_POST(kmod_info_t* pkmod, void* d, int verbose)
{
	int result = -1; // Set to zero for sucesses until it all works
	size_t sha256DigestBufferLength = 32;

	if (NULL == d)
	{
		if (verbose)
		{
			kprintf("The AppleTEXTHash_t pointer was NOT passed to the Integrity_POST function\n");
		}
		return result;
	}

	AppleTEXTHash_t* pHashData = (AppleTEXTHash_t*)d;
	
	if (pHashData->ath_version != 1 || pHashData->ath_length != (int)sha256DigestBufferLength)
	{
		if (verbose)
		{
			kprintf("The AppleTEXTHash_t pointer passed to Integrity_POST function, is invalid\n");
		}
		return result;
	}
	
	if (NULL == pHashData->ath_hash)
	{
		if (verbose)
		{
			kprintf("The AppleTEXTHash_t pointer passed to Integrity_POST function,has a null HASH pointer\n");
		}
		return result;
	}
	
	unsigned long plist_hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;
	unsigned char plist_hash_output_buffer[plist_hash_output_buffer_size];
	char* pPlistHexBuf = (char*)bytesToHexString(pHashData->ath_hash, pHashData->ath_length, plist_hash_output_buffer, plist_hash_output_buffer_size);
	
	if (verbose)
	{
		kprintf("Plist hmac value is    %s\n", pPlistHexBuf);
	}
	
	// Now calcuate the HMAC
    struct mach_header* pmach_header = (struct mach_header*)pkmod->address;
    
	struct load_command* pLoadCommand = NULL;

	uint32_t num_load_commands = 0;
	if (pmach_header->magic == MH_MAGIC_64)
	{
		struct mach_header_64* pmach64_header = (struct mach_header_64*)pmach_header;
		num_load_commands = pmach64_header->ncmds;		
		pLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header_64));
	}
	else if (pmach_header->magic == MH_MAGIC)
	{
		num_load_commands = pmach_header->ncmds;
		pLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header));
	}

	if (NULL == pLoadCommand)
	{
		if (verbose)
		{
			kprintf("pLoadCommand is NULL!\n");
		}
		return result;
	}
	
	const struct ccdigest_info* di = ccsha256_di();
    unsigned char hmac_key = 0;
    cchmac_ctx_decl(di->state_size, di->block_size, ctx);
    cchmac_init(di, ctx, 1, &hmac_key);
	int hashCreated = 0;
    unsigned long iCnt;
    unsigned long jCnt;
	
	struct segment_command* pSniffPtr = (struct segment_command*)pLoadCommand;
    
	
	// Loop through the Segments to find the __TEXT, __text segment
	for (iCnt = 0; iCnt < num_load_commands; iCnt++)
    {
        // The struct segment_command and the struct segment_command_64  have the same
        // first three fields so sniff the name by casting to a struct segment_command 

        if (strncmp("__TEXT", pSniffPtr->segname, strlen("__TEXT")))
        {
            // These are not the droids we are looking for
			// MOve the SniffPtr to the next segment;
            if (LC_SEGMENT_64 == pSniffPtr->cmd)
            {
                struct segment_command_64* pSegmentPtr = (struct segment_command_64*)pSniffPtr;
                pSniffPtr = (struct segment_command*)(((unsigned char *)pSegmentPtr) + pSegmentPtr->cmdsize);
            }
            else if (LC_SEGMENT == pSniffPtr->cmd)
            {
                pSniffPtr = (struct segment_command*)(((unsigned char *)pSniffPtr) + pSniffPtr->cmdsize);
            }
			
			// Go back to the top of the loop and look again
            continue; 
        }
        
		// Bingo! We found the __TEXT segment!
		// Deal with a 64 bit segment
        if (LC_SEGMENT_64 == pLoadCommand->cmd)
        {
            struct segment_command_64* pSegmentPtr = NULL;

            // This is a 64 bit load segment command
            pSegmentPtr = (struct segment_command_64*)pSniffPtr;
            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;
            struct section_64* pSectionPtr = (struct section_64*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command_64));
            int texttextsectionprocessed = 0;

            // Need to find the __text __TEXT section
            for (jCnt = 0; jCnt < numSections; jCnt++)
            {
                if ( !strcmp(pSectionPtr->sectname, "__text") && !strcmp(pSectionPtr->segname, "__TEXT"))
                {
                    // Found it
                    unsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);

                    cchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);	
					hashCreated = 1;

                    texttextsectionprocessed = 1;
                    break;
                }
                else
                {
                    // Move to the next section record
                    pSectionPtr++;
                }
            }
            if (texttextsectionprocessed)
            {
                // The text text section was found and processed
                break;
            }
        }
		else if (LC_SEGMENT == pLoadCommand->cmd) // Deal with a 32 bit segment
		{
			struct segment_command* pSegmentPtr = NULL;

            // This is a 32 bit load segment command
            pSegmentPtr = (struct segment_command*)pLoadCommand;
            unsigned int numSections = (unsigned int)pSegmentPtr->nsects;
            struct section* pSectionPtr = (struct section*)(((unsigned char*)pSegmentPtr) + sizeof(struct segment_command));
			int texttextsectionprocessed = 0;

            // Need to find the __text __TEXT section
            for (jCnt = 0; jCnt < numSections; jCnt++)
			{
				if ( !strcmp(pSectionPtr->sectname, "__text") && !strcmp(pSectionPtr->segname, "__TEXT"))
				{
					// Found it
					unsigned char* pSectionData = (unsigned char*)(((unsigned char*)pmach_header) + pSectionPtr->offset);

					cchmac_update(di, ctx, (unsigned long)pSectionPtr->size, pSectionData);	
					hashCreated = 1;

					texttextsectionprocessed = 1;
                    break;
				}
				else
                {
                    // Move to the next section record
                    pSectionPtr++;
                }
			}
			if (texttextsectionprocessed)
			{
				// The text text section was found and processed
				// Time to bail on the loop
				break;
			}
		}
    }
	
	unsigned long hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;
	unsigned char hash_output_buffer[hash_output_buffer_size];
	unsigned char hmac_buffer[sha256DigestBufferLength];
    memset(hmac_buffer, 0, sha256DigestBufferLength);
		
	// Check to see if the hash was created 
	if (hashCreated) 
	{
		// finalize the HMAC
        
		cchmac_final(di, ctx, hmac_buffer);
	    char* pHexBuf = (char*)bytesToHexString(hmac_buffer, sha256DigestBufferLength, hash_output_buffer, hash_output_buffer_size);
		if (verbose)
		{
	    	kprintf("Computed hmac value is %s\n", pHexBuf);
		}
        
	}  
	else
	{
		if (verbose)
		{
			kprintf("Integrity_POST: WARNING! could not create the hash!\n");
		}
		return -1;
	}
	
#ifdef FORCE_FAIL
    // futz with the generated hmac
	hash_output_buffer[0] = 0;	// This will always work because it is the charter representation of the 
								// hash that is being checked.
#endif 
	result = memcmp(hash_output_buffer, plist_hash_output_buffer, hash_output_buffer_size);
	
	return result;
}
```


Overlapping Code:
```
od_info_t* pkmod, void* d, int verbose)
{
int result = -1; // Set to zero for sucesses until it all works
size_t sha256DigestBufferLength = 32;
if (NULL == d)
{
if (verbose)
{
kprintf("The AppleTEXTHash_t pointer was NOT passed to the Integrity_POST function\n");
}
return result;
}
AppleTEXTHash_t* pHashData = (AppleTEXTHash_t*)d;

if (pHashData->ath_version != 1 || pHashData->ath_length != (int)sha256DigestBufferLength)
{
if (verbose)
{
kprintf("The AppleTEXTHash_t pointer passed to Integrity_POST function, is invalid\n");
}
return result;
}

if (NULL == pHashData->ath_hash)
{
if (verbose)
{
kprintf("The AppleTEXTHash_t pointer passed to Integrity_POST function,has a null HASH pointer\n");
}
return result;
}

unsigned long plist_hash_output_buffer_size = (sha256DigestBufferLength * 2) + 1;
unsigned char plist_hash_output_buffer[plist_hash_output_buffer_size];
char* pPlistHexBuf = (char*)bytesToHexString(pHashData->ath_hash, pHashData->ath_length, plist_hash_output_buffer, plist_hash_output_buffer_size);

if (verbose)
{
kprintf("Plist hmac value is %s\n", pPlistHexBuf);
}

// Now calcuate the HMAC
struct mach_header* pmach_header = (struct mach_header*)pkmod->address;

struct load_command* pLoadCommand = NULL;
uint32_t num_load_commands = 0;
if (pmach_header->magic == MH_MAGIC_64)
{
struct mach_header_64* pmach64_header = (struct mach_header_64*)pmach_header;
num_load_commands = pmach64_header->ncmds; 
pLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header_64));
}
else if (pmach_header->magic == MH_MAGIC)
{
num_load_commands = pmach_header->ncmds;
pLoadCommand = (struct load_command*)(((unsigned char*)pmach_header) + sizeof(struct mach_header));
}
if (NULL == pLoadCommand)
{
if (verbose)
{
kprintf("pLoadCommand is NULL!\n");
}
return result;
}

const struct ccdigest_info* di = ccsha256_di();
unsigned char hmac_key = 0;
cchmac_ctx_decl(di->state_size, di->block_size, ctx);
cchmac_init(di, ctx, 1, &hmac_key);
int hashCreated = 0;
unsigned long iCnt;
unsigned long jCnt;

struct segment_command* pSniffPtr = (struct segment_command*)pLoadCommand;


// Loop through the Segments to find the __TEXT, __text segment
for (iCnt = 0; iCnt < num_load_commands; iCnt++)
{
// The struct segment_command and the struct segment_command_64 h
```
<Overlap Ratio: 0.9829205807002562>

---

--- 370 --
Question ID: 16bc57965f6d32e92fcb8cff212392fe30d48ae2_19
Original Code:
```
const char* get_issuer_alias(CERT_PROPS_HANDLE handle)
{
    const char* result;
    if (handle == NULL)
    {
        LogError("Invalid parameter encounterered");
        result = NULL;
    }
    else
    {
        result = handle->issuer_alias;
    }
    return result;
}
```


Overlapping Code:
```
const char* get_issuer_alias(CERT_PROPS_HANDLE handle)
{
const char* result;
if (handle == NULL)
{
LogError("Invalid parameter encounterered");
result = NULL;
}
else
{
result = handle->issuer_alias;
}
```
<Overlap Ratio: 0.9216589861751152>

---

--- 371 --
Question ID: f1cce97ba7bec7069dbdffee1e58f76c678402ed_4
Original Code:
```
static int
sysmatch(p)
char *p;
{
	char *arg;

	while (p && *p) {
		p = nextarg(p, &arg);
	    	if (EQUALS(arg, Rmtname)) 
			return(SUCCESS);
	}
	return FAIL;
}
```


Overlapping Code:
```
p;
{
char *arg;
while (p && *p) {
p = nextarg(p, &arg);
if (EQUALS(arg, Rmtname)) 
return(SUCCESS);

```
<Overlap Ratio: 0.6896551724137931>

---

--- 372 --
Question ID: cff5d039c2bae3d82b84d5a70f90bfa77c126e38_4
Original Code:
```
void set_agnostic_pmods(const int& itv)
	{
		/* these pattern mods operate on all columns, only need basic meta
		 * interval data, and do not need any more advanced pattern
		 * sequencing. Just set only one hand's values and we'll copy them
		 * over (or figure out how not to need to) later */

		PatternMods::set_agnostic(_s._pmod, _s(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_js._pmod, _js(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_hs._pmod, _hs(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_cj._pmod, _cj(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_cjd._pmod, _cjd(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_hsd._pmod, _hsd(_mitvi), itv, _calc);
		PatternMods::set_agnostic(_fj._pmod, _fj(), itv, _calc);
		PatternMods::set_agnostic(_tt._pmod, _tt(), itv, _calc);
		PatternMods::set_agnostic(_tt2._pmod, _tt2(), itv, _calc);
	}
```


Overlapping Code:
```
 itv)
{
/* these pattern mods operate on all columns, only need basic meta
* interval data, and do not need any more advanced pattern
* sequencing. Just set only one hand's values and we'll copy them
* over (or figure out how not to need to) later */
PatternMods::set_agnostic(_s._pmod, _s(_mitvi), itv, _calc);
PatternMods::set_agnostic(_js._pmod, _js(_mitvi), itv, _calc);
PatternMods::set_agnostic(_hs._pmod, _hs(_mitvi), itv, _calc);
PatternMods::set_agnostic(_cj._pmod, _cj(_mitvi), itv, _calc);
PatternMods::set_agnostic(_cjd._pmod, _cjd(_mitvi), itv, _calc);
PatternMods::set_agnostic(_hsd._pmod, _hsd(_mitvi), itv, _calc);
PatternMods::set_agnostic(_fj._pmod, _fj(), itv, _calc);
PatternMods::set_agnostic(_tt._pmod, _tt(), itv, _calc);
PatternMods::set_agnostic(_tt2._pmod, _tt2(), itv, _cal
```
<Overlap Ratio: 0.9535160905840286>

---

--- 373 --
Question ID: 7bf34352bb5c6764bc70d119481a9983d62ee43a_2
Original Code:
```
static inline uint32_t adc_read_u32(analogin_t *obj)
{
    uint32_t value;
#if ANALOGIN_MEDIAN_FILTER
    uint32_t v1 = adc_read(obj);
    uint32_t v2 = adc_read(obj);
    uint32_t v3 = adc_read(obj);
    order(&v1, &v2);
    order(&v2, &v3);
    order(&v1, &v2);
    value = v2;
#else
    value = adc_read(obj);
#endif
    return value;
}
```


Overlapping Code:
```
t adc_read_u32(analogin_t *obj)
{
uint32_t value;
#if ANALOGIN_MEDIAN_FILTER
uint32_t v1 = adc_read(obj);
uint32_t v2 = adc_read(obj);
uint32_t v3 = adc_read(obj);
order(&v1, &v2);
order(&v2, &v3);
order(&v1, &v2);
value = v2;
#else
value = adc_read(obj);
#endif
return valu
```
<Overlap Ratio: 0.9163879598662207>

---

--- 374 --
Question ID: e8d58d7f389ea158f8c4605cefab8555c81e4f58_5
Original Code:
```
class Signature {
 public:
  char* encryption_alg_;
  int size_serialized_;
  byte* serialized_statement_;
  int size_signature_;
  byte* signature_;
  char* signer_name_;

  Signature();
  ~Signature();

  bool Serialize(crypto_signature& sig);
  bool Deserialize(crypto_signature& sig);
  void PrintSignature();
}
```


Overlapping Code:
```
on_alg_;
int size_serialized_;
byte* serialized_statement_;
int size_signature_;
byte* signature_;
char* signer_name_;
Signature();
~Signature();
bool Serialize(crypto_signature& sig);
bool Deserialize(crypto_signature& sig);
void PrintSignature();
}
```
<Overlap Ratio: 0.8620689655172413>

---

--- 375 --
Question ID: ae6341b5ebef30e9514e7133f5cd0893c138aa51_20
Original Code:
```
void lcdPrintfResize(int x, int y, uint16_t color,  float ratio, const char *fmt, ...)
{
  va_list arg;
  va_start (arg, fmt);
  int32_t len;
  char print_buffer[256];
  int Size_Char;
  int i;
  int x_Pre = x;
  int y_Pre = y;
  PHAN_FONT_OBJ FontBuf;
  uint8_t font_width;
  resize_image_t r_src, r_dst;
  uint16_t pixel;

  r_src.x = 0;
  r_src.y = 0;
  r_src.w = 0;
  r_src.h = 16;
  r_src.stride = LCD_WIDTH;
  r_src.p_data = lcd_buffer;


  x = 0;
  y = 0;

  len = vsnprintf(print_buffer, 255, fmt, arg);
  va_end (arg);

  for( i=0; i<len; i+=Size_Char )
  {
    PHan_FontLoad( &print_buffer[i], &FontBuf );


    disHanFontBuffer(x, y, &FontBuf, 0xFF);

    Size_Char = FontBuf.Size_Char;
    if (Size_Char >= 2)
    {
      font_width = 16;
      x += 2*8;
    }
    else
    {
      font_width = 8;
      x += 1*8;
    }

    r_src.w += font_width;

    if ((x+font_width) > HW_LCD_WIDTH)
    {
      x  = x_Pre;
      y += 16;
      r_src.h += 16;
    }

    if( FontBuf.Code_Type == PHAN_END_CODE ) break;
  }

  r_dst.x = 0;
  r_dst.y = r_src.y + r_src.h;
  r_dst.w = r_src.w * ratio;
  r_dst.h = r_src.h * ratio;
  r_dst.stride = LCD_WIDTH;
  r_dst.p_data = lcd_buffer;

  if (lcd_resize_mode == LCD_RESIZE_BILINEAR)
  {
    resizeImageFastGray(&r_src, &r_dst);
  }
  else
  {
    resizeImageNearest(&r_src, &r_dst);
  }

  for (int i_y=0; i_y<r_dst.h; i_y++)
  {
    for (int i_x=0; i_x<r_dst.w; i_x++)
    {
      pixel = lcd_buffer[(i_y+r_dst.y)*LCD_WIDTH + i_x];
      if (pixel > 0)
      {
        lcdDrawPixelMix(x_Pre+i_x, y_Pre+i_y, color, pixel);
      }
    }
  }
}
```


Overlapping Code:
```
lor, float ratio, const char *fmt, ...)
{
va_list arg;
va_start (arg, fmt);
int32_t len;
char print_buffer[256];
int Size_Char;
int i;
int x_Pre = x;
int y_Pre = y;
PHAN_FONT_OBJ FontBuf;
uint8_t font_width;
resize_image_t r_src, r_dst;
uint16_t pixel;
r_src.x = 0;
r_src.y = 0;
r_src.w = 0;
r_src.h = 16;
r_src.stride = LCD_WIDTH;
r_src.p_data = lcd_buffer;
x = 0;
y = 0;
len = vsnprintf(print_buffer, 255, fmt, arg);
va_end (arg);
for( i=0; i<len; i+=Size_Char )
{
PHan_FontLoad( &print_buffer[i], &FontBuf );
disHanFontBuffer(x, y, &FontBuf, 0xFF);
Size_Char = FontBuf.Size_Char;
if (Size_Char >= 2)
{
font_width = 16;
x += 2*8;
}
else
{
font_width = 8;
x += 1*8;
}
r_src.w += font_width;
if ((x+font_width) > HW_LCD_WIDTH)
{
x = x_Pre;
y += 16;
r_src.h += 16;
}
if( FontBuf.Code_Type == PHAN_END_CODE ) break;
}
r_dst.x = 0;
r_dst.y = r_src.y + r_src.h;
r_dst.w = r_src.w * ratio;
r_dst.h = r_src.h * ratio;
r_dst.stride = LCD_WIDTH;
r_dst.p_data = lcd_buffer;
if (lcd_resize_mode == LCD_RESIZE_BILINEAR)
{
resizeImageFastGray(&r_src, &r_dst);
}
else
{
resizeImageNearest(&r_src, &r_dst);
}
for (int i_y=0; i_y<r_dst.h; i_y++)
{
for (int i_x=0; i_x<r_dst.w; i_x++)
{
pixel = lcd_buffer[(i_y+r_dst.y)*LCD_WIDTH + i_x];
if (pixel > 0)
{
lcdDrawPixe
```
<Overlap Ratio: 0.929368029739777>

---

--- 376 --
Question ID: b13f6dccf8fb6cd663ccee7b0f3e7a0ec85ec1d0_86
Original Code:
```
static HRESULT WINAPI ITypeLib2_fnQueryInterface(ITypeLib2 *iface, REFIID riid, void **ppv)
{
    ITypeLibImpl *This = impl_from_ITypeLib2(iface);

    TRACE("(%p)->(IID: %s)\n",This,debugstr_guid(riid));

    if(IsEqualIID(riid, &IID_IUnknown) ||
       IsEqualIID(riid,&IID_ITypeLib)||
       IsEqualIID(riid,&IID_ITypeLib2))
    {
        *ppv = &This->ITypeLib2_iface;
    }
    else if(IsEqualIID(riid, &IID_ICreateTypeLib) ||
             IsEqualIID(riid, &IID_ICreateTypeLib2))
    {
        *ppv = &This->ICreateTypeLib2_iface;
    }
    else
    {
        *ppv = NULL;
        TRACE("-- Interface: E_NOINTERFACE\n");
        return E_NOINTERFACE;
    }

    IUnknown_AddRef((IUnknown*)*ppv);
    return S_OK;
}
```


Overlapping Code:
```
peLib2_fnQueryInterface(ITypeLib2 *iface, REFIID riid, void **ppv)
{
ITypeLibImpl *This = impl_from_ITypeLib2(iface);
TRACE("(%p)->(IID: %s)\n",This,debugstr_guid(riid));
if(IsEqualIID(riid, &IID_IUnknown) ||
IsEqualIID(riid,&IID_ITypeLib)||
IsEqualIID(riid,&IID_ITypeLib2))
{
*ppv = &This->ITypeLib2_iface;
}
else if(IsEqualIID(riid, &IID_ICreateTypeLib) ||
IsEqualIID(riid, &IID_ICreateTypeLib2))
{
*ppv = &This->ICreateTypeLib2_iface;
}
else
{
*ppv = NULL;
TRACE("-- Interface: E_NOINTERFACE\n");
return E_NOINTERFACE;
}
IUnknown_AddRef((IUnknown*)*ppv);
return S_OK;
}
```
<Overlap Ratio: 0.9581239530988275>

---

--- 377 --
Question ID: 534e9bc98fce94c2c863f6522da0354eecf878a9_4
Original Code:
```
const char *sdl_ui_menu_toggle_helper(int activated, const char *resource_name)
{
    int value, r;

    if (activated) {
        r = resources_toggle(resource_name, &value);
        if (r < 0) {
            r = resources_get_int(resource_name, &value);
        }
    } else {
        r = resources_get_int(resource_name, &value);
    }

    if (r < 0) {
        return sdl_menu_text_unknown;
    } else {
        return value ? sdl_menu_text_tick : NULL;
    }
}
```


Overlapping Code:
```
ui_menu_toggle_helper(int activated, const char *resource_name)
{
int value, r;
if (activated) {
r = resources_toggle(resource_name, &value);
if (r < 0) {
r = resources_get_int(resource_name, &value);
}
} else {
r = resources_get_int(resource_name, &value);
}
if (r < 0) {
return sdl_menu_text_unknown;
} else {
return value ? sdl_menu_text_tick : NULL;
```
<Overlap Ratio: 0.9463806970509383>

---

--- 378 --
Question ID: a9e51600222c7bfebfcb289cbeeed390bc6dcc64_14
Original Code:
```
void SG_file_spec__add_patterns__array(
	SG_context*                pCtx,
	SG_file_spec*              pThis,
	SG_file_spec__pattern_type eType,
	const char* const*         ppPatterns,
	SG_uint32                  uCount,
	SG_uint32                  uFlags
	)
{
	SG_uint32 uIndex = 0u;

	SG_NULLARGCHECK(pThis);
	SG_ERR_CHECK(  _validate_pattern_type(pCtx, eType)  );
	SG_ARGCHECK(ppPatterns != NULL || uCount == 0u, ppPatterns);

	for (uIndex = 0u; uIndex < uCount; ++uIndex)
	{
		SG_ARGCHECK(ppPatterns[uIndex] != NULL, ppPatterns);
	}

	for (uIndex = 0u; uIndex < uCount; ++uIndex)
	{
		SG_file_spec__add_pattern__sz(pCtx, pThis, eType, ppPatterns[uIndex], uFlags);
	}

fail:
	return;
}
```


Overlapping Code:
```
ext* pCtx,
SG_file_spec* pThis,
SG_file_spec__pattern_type eType,
const char* const* ppPatterns,
SG_uint32 uCount,
SG_uint32 uFlags
)
{
SG_uint32 uIndex = 0u;
SG_NULLARGCHECK(pThis);
SG_ERR_CHECK( _validate_pattern_type(pCtx, eType) );
SG_ARGCHECK(ppPatterns != NULL || uCount == 0u, ppPatterns);
for (uIndex = 0u; uIndex < uCount; ++uIndex)
{
SG_ARGCHECK(ppPatterns[uIndex] != NULL, ppPatterns);
}
for (uIndex = 0u; uIndex < uCount; ++uIndex)
{
SG_file_spec__add_pattern__sz(pCtx, pThis, eType, ppPa
```
<Overlap Ratio: 0.8488964346349746>

---

--- 379 --
Question ID: 1259874e0b2f36d122e8b0ff1faae4afc7472e91_7
Original Code:
```
void expr_cleanup(ExprsPtr exprs) {
    struct Experiment *expr = exprs->exprs[0];
    unsigned i = 0;
    for (i = 0; i < expr->nport_modules; ++i) {
        struct ExpPortModules *pm = expr->port_modules[i];
        unsigned j = 0;
        for (j = 0; j < pm->nconfigs; ++j) {
            struct ExpModuleConfig *cfg = pm->configs[j];

            if (cfg->module) module_delete_get(cfg->name)(cfg->module);
        }
    }
}
```


Overlapping Code:
```
expr_cleanup(ExprsPtr exprs) {
struct Experiment *expr = exprs->exprs[0];
unsigned i = 0;
for (i = 0; i < expr->nport_modules; ++i) {
struct ExpPortModules *pm = expr->port_modules[i];
unsigned j = 0;
for (j = 0; j < pm->nconfigs; ++j) {
struct ExpModuleConfig *cfg = pm->configs[j];
if (cfg->module)
```
<Overlap Ratio: 0.847457627118644>

---

--- 380 --
Question ID: d6107820335031b869e333596a4c0c62f6c4a7d0_0
Original Code:
```
void *DumbTest(void *vp)
{
   cpuset_t mycpuset;
   CPU_ZERO(&mycpuset);         /* no manpage, so guess works like linux */
   CPU_SET(bindID, &mycpuset);
   assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,
                              sizeof(mycpuset), &mycpuset));
   pthread_exit(vp);
}
```


Overlapping Code:
```
DumbTest(void *vp)
{
cpuset_t mycpuset;
CPU_ZERO(&mycpuset); /* no manpage, so guess works like linux */
CPU_SET(bindID, &mycpuset);
assert(!cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_TID, -1,
sizeof(mycpuset), &mycp
```
<Overlap Ratio: 0.8690476190476191>

---

--- 381 --
Question ID: 71b650cb0062a6fad39c57d82a8a89ef5e3e5a5c_1
Original Code:
```
void vetor_apaga(vetor* vec)
{
	int i;

	if(vec == NULL)
        return;

	/* liberta memoria de cada string */
	for (i = 0; i < vec->tamanho; i++)
	{
		free(vec->elementos[i].str);
	}

	/* liberta memoria dos apontares para as strings */
	free(vec->elementos);

	/* liberta memoria da estrutura vetor */
	free(vec);
}
```


Overlapping Code:
```
d vetor_apaga(vetor* vec)
{
int i;
if(vec == NULL)
return;
/* liberta memoria de cada string */
for (i = 0; i < vec->tamanho; i++)
{
free(vec->elementos[i].str);
}
/* liberta memoria dos apontares para as strings */
free(vec->elementos);
/* liberta memoria da estrutura vetor */
free(vec
```
<Overlap Ratio: 0.9761904761904762>

---

--- 382 --
Question ID: fca777dfe95182d7d0778254b346b2a2fbe253ae_12
Original Code:
```
errval_t vfs_dir_read_next(void *st, vfs_handle_t handle, char **retname, struct fs_fileinfo *info) {
    
    errval_t err;
    
    // VFS mount state with root directories and mount linked list
    struct vfs_mount *mt = st;
    
    // VFS handle to store the FS specific handle and the type
    struct vfs_handle *h = handle;
    
    switch (h->type) {
        case RAMFS:
            err = ramfs_dir_read_next(mt->ram_mount, h->handle, retname, info);
            break;
        case FATFS:
            err = fs_rpc_readdir(mt->fat_mount, h->handle, retname, info);
            break;
        case MBTFS:
            err = mbtfs_dir_read_next(mt->mbt_mount, h->handle, retname, info);
            break;
        default:
            err = SYS_ERR_OK;
            debug_printf("vfs read dir unsuccessful\n");
            break;
    }
    
    return err;
    
}
```


Overlapping Code:
```
ext(void *st, vfs_handle_t handle, char **retname, struct fs_fileinfo *info) {

errval_t err;

// VFS mount state with root directories and mount linked list
struct vfs_mount *mt = st;

// VFS handle to store the FS specific handle and the type
struct vfs_handle *h = handle;

switch (h->type) {
case RAMFS:
err = ramfs_dir_read_next(mt->ram_mount, h->handle, retname, info);
break;
case FATFS:
err = fs_rpc_readdir(mt->fat_mount, h->handle, retname, info);
break;
case MBTFS:
err = mbtfs_dir_read_next(mt->mbt_mount, h->handle, retname, info);
break;
default:
err = SYS_ERR_OK;
debug_printf("vfs read dir unsuccessful\n
```
<Overlap Ratio: 0.9239940387481371>

---

--- 383 --
Question ID: aa27ed54898b470e130bf006df03d402ef7e0076_0
Original Code:
```
void init_devices(DWORD devnum)
{
	devices = (device *)malloc(devnum * sizeof(device));
	
	if(devices == NULL) {
		printf("cannot allocate memory for devices...\n");
		exit(1);
	}
	
	current_devices = 0;
}
```


Overlapping Code:
```
 = (device *)malloc(devnum * sizeof(device));

if(devices == NULL) {
printf("cannot allocate memory for devices...\n");
exit(1);
}

current_devices = 
```
<Overlap Ratio: 0.7692307692307693>

---

