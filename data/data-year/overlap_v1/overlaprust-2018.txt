--- 0 --
Question ID: caae2b7a6aa584af89eaa322d7e3011277b83992_3
Original Code:
```
extern "C" fn read_data_safe(ptr: *mut Pixel, len: usize) {
    println!("Reading safely from instance {:?}", *INSTANCE);

    let data: Vec<Pixel> = INSTANCE.rx
        .iter()
        .take(len)
        .collect();

    let ptr = data.as_ptr();

}
```


Overlapping Code:
```
en: usize) {
println!("Reading safely from instance {:?}", *INSTANCE);
let data: Vec<Pixel> = INSTANCE.rx
.iter()
.take(len)
.collect();
let ptr = data.as
```
<Overlap Ratio: 0.7333333333333333>

---

--- 1 --
Question ID: 1a4b0fbeaf4cc15e38e56c6224e190fb3a4a79bc_0
Original Code:
```
fn main() {
    if pkg_config::find_library("ao").is_ok() {
        return;
    }
    let source = PathBuf::from(&get!("CARGO_MANIFEST_DIR")).join("source");
    let output = PathBuf::from(&get!("OUT_DIR"));
    let build = output.join("build");
    ok!(fs::create_dir_all(&build));
    run!(cmd!(source.join("configure")).current_dir(&build)
                                       .arg(&format!("--prefix={}", output.display())));
    run!(cmd!("make").current_dir(&build).arg("install"));
    println!("cargo:rustc-link-lib=dylib=ao");
    println!("cargo:rustc-link-search={}", output.join("lib").display());
}
```


Overlapping Code:
```
_library("ao").is_ok() {
return;
}
let source = PathBuf::from(&get!("CARGO_MANIFEST_DIR")).join("source");
let output = PathBuf::from(&get!("OUT_DIR"));
let build = output.join("build");
ok!(fs::create_dir_all(&build));
run!(cmd!(source.join("configure")).current_dir(&build)
.arg(&format!("--prefix={}", output.display())));
run!(cmd!("make").current_dir(&build).arg("install"));
println!("cargo:rustc-link-lib=dylib=ao");
println!("cargo:rustc-link-search={}", output.join("lib
```
<Overlap Ratio: 0.9106463878326996>

---

--- 2 --
Question ID: 8fe71bc79ab690e4d10c32b6e8d596c010446e03_12
Original Code:
```
fn test_parse_deref() {
        logger_init();
        let sess = ParseSess::new();
        let mut conv_map = unwrap_presult!(parse_types_conv_map(
            &sess,
            "deref_code",
            r#"
#[allow(dead_code)]
#[swig_code = "let {to_var}: {to_var_type} = {from_var}.swig_deref();"]
trait SwigDeref {
    type Target: ?Sized;
    fn swig_deref(&self) -> &Self::Target;
}

impl SwigDeref for String {
    type Target = str;
    fn swig_deref(&self) -> &str {
        &self
    }
}
"#,
            HashMap::new(),
            64
        ));
        let (_, code) = unwrap_presult!(conv_map.convert_rust_types(
            &sess,
            &rust_type_from_str("String"),
            &rust_type_from_str("&str"),
            "a0",
            "jlong",
            DUMMY_SP
        ));
        assert_eq!("    let a0: &str = a0.swig_deref();\n".to_string(), code);
    }
```


Overlapping Code:
```
t_parse_deref() {
logger_init();
let sess = ParseSess::new();
let mut conv_map = unwrap_presult!(parse_types_conv_map(
&sess,
"deref_code",
r#"
#[allow(dead_code)]
#[swig_code = "let {to_var}: {to_var_type} = {from_var}.swig_deref();"]
trait SwigDeref {
type Target: ?Sized;
fn swig_deref(&self) -> &Self::Target;
}
impl SwigDeref for String {
type Target = str;
fn swig_deref(&self) -> &str {
&self
}
}
"#,
HashMap::new(),
64
));
let (_, code) = unwrap_presult!(conv_map.convert_rust_types(
&sess,
&rust_type_from_str("String"),
&rust_type_from_str("&str"),
"a0",
"jlong",
DUMMY_SP
));
assert_eq!(" let a0: &str = a0.swig_deref();\n".to_string(), co
```
<Overlap Ratio: 0.9818731117824774>

---

--- 3 --
Question ID: 3dcb4abc314f4804e5cb7dd717e5662dc3d48f57_5
Original Code:
```
fn delete_user() {
    let client = Graph::new("ACCESS_TOKEN");

    let response = client.v1().user(USER_ID).delete_user().send().unwrap();

    println!("{:#?}", response);
}
```


Overlapping Code:
```
delete_user() {
let client = Graph::new("ACCESS_TOKEN");
let response = client.v1().user(USER_ID).delete_user().send().unwrap();
println!("{:#?}", res
```
<Overlap Ratio: 0.9259259259259259>

---

--- 4 --
Question ID: f4200d5b69463191ec55095c12534810cdc02eea_22
Original Code:
```
pub async fn get_block_operations(
    _req: Request<Body>,
    params: Params,
    _: Query,
    env: Arc<RpcServiceEnvironment>,
) -> ServiceResult {
    let chain_id = parse_chain_id(required_param!(params, "chain_id")?, &env)?;
    let block_hash =
        parse_block_hash_or_fail!(&chain_id, required_param!(params, "block_id")?, &env);

    result_to_json_response(
        base_services::get_block_operations_metadata(chain_id, &block_hash, &env).await,
        env.log(),
    )
}
```


Overlapping Code:
```
eq: Request<Body>,
params: Params,
_: Query,
env: Arc<RpcServiceEnvironment>,
) -> ServiceResult {
let chain_id = parse_chain_id(required_param!(params, "chain_id")?, &env)?;
let block_hash =
parse_block_hash_or_fail!(&chain_id, required_param!(params, "block_id")?, &env);
result_to_json_response(
base_services::get_block_operations_metadata(chain_id, &block_hash, &env).await,
env.log(),
)
}
```
<Overlap Ratio: 0.91415313225058>

---

--- 5 --
Question ID: 99ec1b268c51c3421dd383fb23681b4c110262f0_167
Original Code:
```
fn make_pocket_enum_declaration(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R, arg3 : Self::R, arg4 : Self::R, arg5 : Self::R) -> (State, Self::R) {
        let s = State::next(s, &[&arg0, &arg1, &arg2, &arg3, &arg4, &arg5]);
        let r = Self::R::make_pocket_enum_declaration(&s, arg0, arg1, arg2, arg3, arg4, arg5);
        (s, r)
    }
```


Overlapping Code:
```
 make_pocket_enum_declaration(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R, arg3 : Self::R, arg4 : Self::R, arg5 : Self::R) -> (State, Self::R) {
let s = State::next(s, &[&arg0, &arg1, &arg2, &arg3, &arg4, &arg5]);
let r = Self::R::make_pocket_enum_declaration(&s, arg0, arg1, arg2, arg3, arg4, arg5);
(s, 
```
<Overlap Ratio: 0.9814814814814815>

---

--- 6 --
Question ID: dd8027092ca620bcfab27b101d95d4ca23b197f8_0
Original Code:
```
fn test_some_floats_f32() {
    check_value(&Float::from(0.758f32).into());
    check_value(&Float::from(std::f32::MAX).into());
    check_value(&Float::from(std::f32::MIN).into());
    check_value(&Float::from(std::f32::INFINITY).into());
    check_value(&Float::from(0f32).into());

    // special check for NaN
    serialize_de_serialize(&Float::from(std::f32::NAN).into(), |result| match result {
        Value::Float(float) => {
            let v_float: f32 = f32::try_from(float).unwrap();
            assert!(v_float.is_nan());
        }
        _ => panic!("Expected a float!"),
    });
}
```


Overlapping Code:
```
n test_some_floats_f32() {
check_value(&Float::from(0.758f32).into());
check_value(&Float::from(std::f32::MAX).into());
check_value(&Float::from(std::f32::MIN).into());
check_value(&Float::from(std::f32::INFINITY).into());
check_value(&Float::from(0f32).into());
// special check for NaN
serialize_de_serialize(&Float::from(std::f32::NAN).into(), |result| match result {
Value::Float(float) => {
let v_float: f32 = f32::try_from(float).unwrap();
assert!(v_float.is_nan());
}
_ => panic!("Expected a f
```
<Overlap Ratio: 0.970873786407767>

---

--- 7 --
Question ID: 40d2f61e590f789ef9bffeb853ea99e094d762c9_0
Original Code:
```
pub unsafe extern "C" fn okclient(mut ip: *mut u8) -> i32 {
    let mut _currentBlock;
    let mut st: stat;
    let mut i: i32;
    filename[0usize] = b'i';
    filename[1usize] = b'p';
    filename[2usize] = b'/';
    filename[3u32.wrapping_add(ip4::fmt(filename.as_mut_ptr().offset(3isize), ip as (*const u8))) as
            (usize)] = 0u8;
    'loop1: loop {
        if stat(filename.as_mut_ptr() as (*const u8), &mut st as (*mut stat)) == 0i32 {
            _currentBlock = 5;
            break;
        }
        i = string::rchr(filename.as_mut_ptr() as (*const u8), b'.' as (i32)) as (i32);
        if filename[i as (usize)] == 0 {
            _currentBlock = 4;
            break;
        }
        filename[i as (usize)] = 0u8;
    }
    if _currentBlock == 4 { 0i32 } else { 1i32 }
}
```


Overlapping Code:
```
tern "C" fn okclient(mut ip: *mut u8) -> i32 {
let mut _currentBlock;
let mut st: stat;
let mut i: i32;
filename[0usize] = b'i';
filename[1usize] = b'p';
filename[2usize] = b'/';
filename[3u32.wrapping_add(ip4::fmt(filename.as_mut_ptr().offset(3isize), ip as (*const u8))) as
(usize)] = 0u8;
'loop1: loop {
if stat(filename.as_mut_ptr() as (*const u8), &mut st as (*mut stat)) == 0i32 {
_currentBlock = 5;
break;
}
i = string::rchr(filename.as_mut_ptr() as (*const u8), b'.' as (i32)) as (i32);
if filename[i as (usize)] == 0 {
_currentBlock = 4;
break;
}
filename[i as (usize)] = 0u8;
}
if _currentB
```
<Overlap Ratio: 0.9273570324574961>

---

--- 8 --
Question ID: 763c7e6f78b7655590063808dc25ddfc9db84990_1
Original Code:
```
fn test_regexp() {
        let db = SqliteConnection::open_in_memory().unwrap();
        db.create_scalar_function("regexp", 2, true, Some(regexp)).unwrap();
        let result = db.query_row("SELECT regexp('l.s[aeiouy]', 'lisa')",
                                           &[],
                                           |r| r.get::<bool>(0));

        assert_eq!(true, result.unwrap());
    }
```


Overlapping Code:
```
t_regexp() {
let db = SqliteConnection::open_in_memory().unwrap();
db.create_scalar_function("regexp", 2, true, Some(regexp)).unwrap();
let result = db.query_row("SELECT regexp('l.s[aeiouy]', 'lisa')",
&[],
|r| r.get::<bool>(0));
assert_eq!(true, res
```
<Overlap Ratio: 0.9191176470588235>

---

--- 9 --
Question ID: 8ba64be453af66291a90197773b7ec8d6ae86ce4_0
Original Code:
```
fn main() {
    println!("Starting Queue");
    let mut head = Node {
        name: "head".to_string(),
        next: None,
    };

    loop {
        let mut input = String::new();
        println!("Next action please");
        stdin().read_line(&mut input);

        let cloned = input.clone();
        let items = cloned.split(' ');
        let mut cmds: Vec<&str> = items.collect();
        let command = cmds[0].trim_end();

        match command {
            command if command == "push" => {
                let name = cmds[1].trim_end().to_string();
                head.push(name);
            }
            command if command == "pop" => match head.clone().pop() {
                None => head.next = None,
                Some(ref mut node) => head.next = Some(Box::new(node.clone())),
            },
            command if command == "print" => {
                head.print(0);
            }
            command if command == "count" => {
                head.count(0);
            }
            command if command == "quit" => {
                println!("Good Bye");
                break;
            }
            _ => println!("Invalid command"),
        }
    }
    drop(head);
}
```


Overlapping Code:
```
ead = Node {
name: "head".to_string(),
next: None,
};
loop {
let mut input = String::new();
println!("Next action please");
stdin().read_line(&mut input);
let cloned = input.clone();
let items = cloned.split(' ');
let mut cmds: Vec<&str> = items.collect();
let command = cmds[0].trim_end();
match command {
command if command == "push" => {
let name = cmds[1].trim_end().to_string();
head.push(name);
}
command if command == "pop" => match head.clone().pop() {
None => head.next = None,
Some(ref mut node) => head.next = Some(Box::new(node.clone())),
},
command if command == "print" => {
head.print(0);
}
command if command == "count" => {
head.count(0);
}
command if command == "quit" => {
println!("Good Bye");
break;
}
_ => println!("Invalid comm
```
<Overlap Ratio: 0.9113001215066828>

---

--- 10 --
Question ID: 81a9fdea48ce9dcc5294dfa4ab94ca9cf80eada2_0
Original Code:
```
fn get_mock_update_to_latest_ledger(
    req: &UpdateToLatestLedgerRequest,
) -> UpdateToLatestLedgerResponse {
    let mut resp = UpdateToLatestLedgerResponse::new();
    for request_item in req.get_requested_items().iter() {
        resp.mut_response_items()
            .push(get_mock_response_item(request_item).unwrap());
    }
    let mut ledger_info = types::proto::ledger_info::LedgerInfo::new();
    ledger_info.set_transaction_accumulator_hash(HashValue::zero().to_vec());
    ledger_info.set_consensus_data_hash(HashValue::zero().to_vec());
    ledger_info.set_consensus_block_id(HashValue::zero().to_vec());
    ledger_info.set_version(7);
    let mut ledger_info_with_sigs = ProtoLedgerInfoWithSignatures::new();
    ledger_info_with_sigs.set_ledger_info(ledger_info);
    resp.set_ledger_info_with_sigs(ledger_info_with_sigs);
    resp
}
```


Overlapping Code:
```
_to_latest_ledger(
req: &UpdateToLatestLedgerRequest,
) -> UpdateToLatestLedgerResponse {
let mut resp = UpdateToLatestLedgerResponse::new();
for request_item in req.get_requested_items().iter() {
resp.mut_response_items()
.push(get_mock_response_item(request_item).unwrap());
}
let mut ledger_info = types::proto::ledger_info::LedgerInfo::new();
ledger_info.set_transaction_accumulator_hash(HashValue::zero().to_vec());
ledger_info.set_consensus_data_hash(HashValue::zero().to_vec());
ledger_info.set_consensus_block_id(HashValue::zero().to_vec());
ledger_info.set_version(7);
let mut ledger_info_with_sigs = ProtoLedgerInfoWithSignatures::new();
ledger_info_with_sigs.set_ledger_info(ledger_info);
resp.set_ledger_info_with_sigs(ledger_info_with_si
```
<Overlap Ratio: 0.962772785622593>

---

--- 11 --
Question ID: a50ac8eaf12cd8bc570c3cd645e26d649f1a20f1_1
Original Code:
```
fn test_links() {
        let mut i = 3usize;
        while i < 512 {
            dbg!(i, format!("{:032b}", i));
            i = next_fwd(i);
        }

        let mut i = 7usize;
        while i > 0 {
            dbg!(i, format!("{:032b}", i));
            i = next_bwd(i);
        }
    }
```


Overlapping Code:
```
;
while i < 512 {
dbg!(i, format!("{:032b}", i));
i = next_fwd(i);
}
let mut i = 7usize;
while i > 0 {
dbg!(i, format!("{:032b}", i));
i = next_bwd(i)
```
<Overlap Ratio: 0.7853403141361257>

---

--- 12 --
Question ID: 7bcafbc527a27944c206358ec81bf88cc10d2e1e_14
Original Code:
```
fn create_coordinate_subarrays_3d<F: BFloat, const N_POINTS: usize>(
    crosses_periodic_bound: &In3D<bool>,
    coords: &CoordRefs3<F>,
    extents: &Vec3<F>,
    start_indices: &Idx3<isize>,
) -> ([F; N_POINTS], [F; N_POINTS], [F; N_POINTS]) {
    let x_coord_subarray = if crosses_periodic_bound[X] {
        create_coordinate_subarray_for_periodic::<_, N_POINTS>(
            coords[X],
            extents[X],
            start_indices[X],
        )
    } else {
        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[X], start_indices[X])
    };
    let y_coord_subarray = if crosses_periodic_bound[Y] {
        create_coordinate_subarray_for_periodic::<_, N_POINTS>(
            coords[Y],
            extents[Y],
            start_indices[Y],
        )
    } else {
        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Y], start_indices[Y])
    };
    let z_coord_subarray = if crosses_periodic_bound[Z] {
        create_coordinate_subarray_for_periodic::<_, N_POINTS>(
            coords[Z],
            extents[Z],
            start_indices[Z],
        )
    } else {
        create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Z], start_indices[Z])
    };
    (x_coord_subarray, y_coord_subarray, z_coord_subarray)
}
```


Overlapping Code:
```
ate_subarrays_3d<F: BFloat, const N_POINTS: usize>(
crosses_periodic_bound: &In3D<bool>,
coords: &CoordRefs3<F>,
extents: &Vec3<F>,
start_indices: &Idx3<isize>,
) -> ([F; N_POINTS], [F; N_POINTS], [F; N_POINTS]) {
let x_coord_subarray = if crosses_periodic_bound[X] {
create_coordinate_subarray_for_periodic::<_, N_POINTS>(
coords[X],
extents[X],
start_indices[X],
)
} else {
create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[X], start_indices[X])
};
let y_coord_subarray = if crosses_periodic_bound[Y] {
create_coordinate_subarray_for_periodic::<_, N_POINTS>(
coords[Y],
extents[Y],
start_indices[Y],
)
} else {
create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Y], start_indices[Y])
};
let z_coord_subarray = if crosses_periodic_bound[Z] {
create_coordinate_subarray_for_periodic::<_, N_POINTS>(
coords[Z],
extents[Z],
start_indices[Z],
)
} else {
create_coordinate_subarray_for_interior::<_, N_POINTS>(coords[Z], start_indices[Z])
};
(x_coord_subarray, y_coord_subarray, z_coord_subarray)
```
<Overlap Ratio: 0.9816247582205029>

---

--- 13 --
Question ID: 0666d72748aed0aa7b92794f5c4831a43dcbd431_3
Original Code:
```
pub fn keygen() -> [u8; KEY] {
    let mut k = [0u8; KEY];
    crypto_random(&mut k);
    k
}
```


Overlapping Code:
```

```
<Overlap Ratio: 0.0>

---

--- 14 --
Question ID: 5e6c54232d0ab5769881565b62e2e5745ca9b290_2
Original Code:
```
pub fn runner() {
    let mut console = ConsoleHandle::init_default();
    console.clear();

    println!("Setting up sterr file hooks.");
    console.update();
    let mut error_file = match redirect_stderr("nx_fatdrive_sterr.txt") {
        Ok(fl) => fl,
        Err(e) => {
            println!("Error setting stderr output: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };
    console.update();
    
    
    multprint!(console,error_file,"Setting up HID context.");
    let mut hid_ctx = HidContext::new();
    let controller = hid_ctx.get_controller(HidControllerID::CONTROLLER_P1_AUTO);

    multprint!(console,error_file,"Setting up usb:hs context");
    let mut usbhs_ctx = match UsbHsContext::initialize() {
        Ok(ctx) => ctx, 
        Err(e) => {
            multprint!(console, error_file, "Failed setting up usb:hs context: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    let filter : InterfaceFilter = InterfaceFilter::new()
        .with_interface_class(8)
        .with_interface_subclass(6)
        .with_interface_protocol(80);
    
    multprint!(console, error_file, "Waiting for usb event.");
    let evt = match InterfaceAvailableEvent::create(true, 0, filter) {
        Ok(ev) => ev, 
        Err(e) => {
            multprint!(console, error_file, "Failed building iface available event: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;

        }
    };
    if let Err(e) = evt.wait(u64::max_value()) {
        multprint!(console, error_file, "Failed waiting for event: {:?}", e);
        let delay_start = Instant::now();
        while delay_start.elapsed() < Duration::from_secs(5) {
            console.update();
        }
        return;
    }
    multprint!(console,error_file,"Looking for usb devices.");

    let mut interfaces = match usbhs_ctx.query_available_interfaces(filter, 3) {
        Ok(ifaces) => ifaces, 
        Err(e) => {
            multprint!(console, error_file, "Failed querying available interfaces: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    multprint!(console, error_file, "Got interfaces: {:?}", interfaces);

    let mut iface = match interfaces.pop() {
        Some(iface) => iface, 
        None => {
            multprint!(console, error_file, "Failed finding any matching interfaces.");
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    multprint!(console, error_file, "\nSuccess! Using iface: {:?}", iface);

    console.update();

    let (read_ep, write_ep) = match UsbClient::retrieve_iface_endpoints(&iface) {
        Ok(p) => p,
        Err(e) => {
            multprint!(console, error_file, "Failed getting eps: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    let mut session = match usbhs_ctx.acquire_interface(&iface) {
        Ok(s) => s,
        Err(e) => {
            multprint!(console, error_file, "Failed acquiring iface: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };
    let client = match UsbClient::new(session, read_ep, write_ep) {
        Ok(c) => c, 
        Err(e) => {
            multprint!(console, error_file, "Got error on usbclient::new of {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;

        }
    };
    
    multprint!(console,error_file,"Making SCSI wrapper object.");
    console.update();

    let mut scsi_wrapper = match scsi::scsi::ScsiBlockDevice::new(client, VecNewtype::new(), VecNewtype::new(), VecNewtype::new()) {
        Ok(c) => c,
        Err(e) => {
            multprint!(console, error_file, "Failed creating SCSI wrapper object: {:?}", e);

            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    multprint!(console,error_file,"SCSI device found with block size {}.", scsi_wrapper.block_size());
    multprint!(console,error_file,"Trying to get MBR.");
    console.update();

    let mut mbr_buff = VecNewtype::with_fake_capacity(512.max(scsi_wrapper.block_size() as usize));
    let mut mbr_read_count = 0;
    while mbr_buff.inner.len() < 512 {
        multprint!(console, error_file, "MBR Parse pre-status {}: {}/512.", mbr_read_count, mbr_buff.inner.len());
        let _bt = match scsi_wrapper.read(mbr_buff.inner.len() as u32, &mut mbr_buff) {
            Ok(bt) => {
                multprint!(console, error_file, "Got {} bytes on read {}.", mbr_buff.inner.len(), bt);
                multprint!(console, error_file, "Ended with bytes: {:X?}", mbr_buff.inner);
                bt
            }, 
            Err(e) => {
                multprint!(console, error_file, "Failed reading MBR on read number {} after already getting {} bytes: {:?}.", mbr_read_count, mbr_buff.inner.len(), e);
                multprint!(console, error_file, "Ended with bytes: {:X?}", mbr_buff.inner);

                let delay_start = Instant::now();
                while delay_start.elapsed() < Duration::from_secs(5) {
                    console.update();
                }
                return;
            }
        };
        mbr_read_count += 1;
    }

    multprint!(console,error_file,"Parsing MBR.");
    console.update();

    let mbr_entry = match mbr_nostd::MasterBootRecord::from_bytes(&mut mbr_buff.inner) {
        Ok(mbr) => mbr, 
        Err(e) => {
            multprint!(console, error_file, "Failed parsing mbr: {:?}", e);

            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };


    multprint!(console,error_file,"Partitions:");
    for ent in mbr_entry.partition_table_entries() {
        multprint!(console,error_file,"    {:?}", ent);
    }


    let first_ent : &PartitionTableEntry = &mbr_entry.partition_table_entries()[0];
    let raw_offset : usize = (first_ent.logical_block_address * scsi_wrapper.block_size()) as usize; 
    multprint!(console, error_file, "Creating FATFS wrapper starting at offset block {}, raw {}.", first_ent.logical_block_address, raw_offset);

    let mut partition = OffsetScsiDevice::new(scsi_wrapper, raw_offset);
    let mut fs : fatfs::FileSystem<OffsetScsiDevice> = match fatfs::FileSystem::new(partition, fatfs::FsOptions::new()) {
        Ok(fs) => fs, 
        Err(e) => {
            multprint!(console, error_file, "Error mounting FAT32 file system: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    multprint!(console, error_file, "Scanning filesystem.");
    let mut root_dir = fs.root_dir();
    let all_dirs = root_dir.iter().filter_map(|ent_res| {
        match ent_res {
            Ok(ent) => {
                multprint!(console, error_file, "FAT: Found itm. Short name: {}, long name: {}, attr: {:?}", ent.short_file_name(), ent.file_name(), ent.attributes());
                Some(ent)
            },
            Err(e) => {
                multprint!(console, error_file, "Error reading dirent: {:?}", e);
                None
            }
        }

    }).collect::<Vec<_>>();

    multprint!(console, error_file, "Getting handle to test_folder directory.");
    let subdir_opt = all_dirs.iter().find_map(|fl| {
        if fl.is_dir() && fl.file_name() == "test_folder".to_owned() {
            multprint!(console, error_file,"FAT: Using existing subdir: Short name: {}, long name: {}, attr: {:?}", fl.short_file_name(), fl.file_name(), fl.attributes());
            Some(fl.to_dir())
        }
        else {
            None
        }
    });

    let mut subdir_res = subdir_opt.ok_or("Could not find existing subdir.").or_else(|_| {
        root_dir.create_dir("test_folder")
    });
    let mut subdir = match subdir_res {
        Ok(s) => s, 
        Err(e) => {
            multprint!(console, error_file, "Error getting handle to test_folder: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };


    let now = Instant::now();
    let fl_name = format!("{:?}.txt", now).replace(" ", "s").replace(":", "o").replace("{", "q").replace("}", "p");
    multprint!(console, error_file, "Creating test file {} in the folder.", fl_name);
    let mut fl = match subdir.create_file(&fl_name) {
        Ok(f) => f, 
        Err(e) => {
            multprint!(console, error_file, "Error creating test file: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    multprint!(console, error_file,"Now writing to file.");
    if let Err(e) = fl.write_fmt(format_args!("Hello world at time {:?}", now)) {
        multprint!(console, error_file, "Error writing to test file: {:?}", e);
        let delay_start = Instant::now();
        while delay_start.elapsed() < Duration::from_secs(5) {
            console.update();
        }
        return;
    }

    let next_dir_name = format!("{:?}_next_dir", now).replace(" ", "s").replace(":", "o").replace("{", "q").replace("}", "p");
    multprint!(console, error_file, "Now trying directory {}.", next_dir_name);
    let mut next_dir = match root_dir.create_dir(&next_dir_name) {
        Ok(s) => s, 
        Err(e) => {
            multprint!(console, error_file, "Error getting handle to next_dir: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };
    let mut outfile = match next_dir.create_file("for_seuth.txt") {
        Ok(f) => f, 
        Err(e) => {
            multprint!(console, error_file, "Error creating for_seuth.txt: {:?}", e);
            let delay_start = Instant::now();
            while delay_start.elapsed() < Duration::from_secs(5) {
                console.update();
            }
            return;
        }
    };

    if let Err(e) = outfile.write("To be or not to be and all that jazz!.".to_owned().into_bytes().as_slice()) {
        multprint!(console, error_file, "Error writing to for_seuth.txt: {:?}", e);
        let delay_start = Instant::now();
        while delay_start.elapsed() < Duration::from_secs(5) {
            console.update();
        }
        return;

    }

    multprint!(console, error_file, "Done.");

    loop {
        hid_ctx.scan_input();
        if controller.keys_down_raw() & HidControllerKeys::KEY_PLUS.0 as u64 != 0 {
            break;
        }
    }
}
```


Overlapping Code:
```
 runner() {
let mut console = ConsoleHandle::init_default();
console.clear();
println!("Setting up sterr file hooks.");
console.update();
let mut error_file = match redirect_stderr("nx_fatdrive_sterr.txt") {
Ok(fl) => fl,
Err(e) => {
println!("Error setting stderr output: {:?}", e);
let delay_start = Instant::now();
while delay_start.elapsed() < Duration::from_secs(5) {
console.update();
}
return;
}
};
console.update();


multprint!(console,error_file,"Setting up HID context.");
let mut hid_ctx = HidContext::new();
let controller = hid_ctx.get_controller(HidControllerID::CONTROLLER_P1_AUTO);
multprint!(console,error_file,"Setting up usb:hs context");
let mut usbhs_ctx = match UsbHsContext::initialize() {
Ok(ctx) => ctx, 
Err(e) => {
multprint!(console, error_file, "Failed setting up usb:hs context: {:?}", e);
let delay_start = Instant::now();
while delay_start.elapsed() < Duration::from_secs(5) {
console.update();
}
return;
}
};
let filter : InterfaceFilter = InterfaceFilter::new()
.with_interface_class(8)
.with_interface_subclass(6)
.with_interface_protocol(80);

multprint!(console, error_file, "Waiting for usb event.");
let evt = match InterfaceAvailableEvent::create(true, 0, filter) {
Ok(ev) => ev, 
Err(e) => {
multprint!(console, error_file, "Failed building iface available event: {:?}", e);
let delay_start = Instant::now();
while delay_start.elapsed() < Duration::from_secs(5) {
console.update();
}
return;
}
};
if let Err(e) = evt.wait(u64::max_value()) {
multprint!(console, error_file, "Failed waiting for event: {:?}", e);
let delay_start = Instant::now();
while delay_start.elapsed() < Duration::from_secs(5) {
console.update();
}
return;
}
multprint!(console,error_file,"Looking for usb devices.");
let mut interfaces = match usbhs_ctx.query_available_interfaces(filter, 3) {
Ok(ifaces) => ifaces, 
Err(e) => {
multprint!(console, error_file, "Failed querying available interfaces: {:?}", e);
let delay_start = Instan
```
<Overlap Ratio: 0.9898477157360406>

---

--- 15 --
Question ID: 6284d1836ef46c50637504ab98bc58c982d91ef0_12
Original Code:
```
pub fn read_ss() -> u16 {
    let ret: u16;
    unsafe {
        asm!(
            "mov %ss, $0"
            : "=r"(ret)
            :
            :
            );
    }
    ret
}
```


Overlapping Code:
```
safe {
asm!(
"mov %ss, $0"
: "=r"(ret)
:
:
);
}
re
```
<Overlap Ratio: 0.5263157894736842>

---

--- 16 --
Question ID: e20fb5cff0b8d96462bc1af6489b1709a0e61066_6
Original Code:
```
fn for_in() {
        let mut out = Cursor::new(Vec::new());
        let mut rt = Runtime::new(Program::empty(), &mut out).unwrap();
        let stmt = get_stmt(
            r#"{
            a[0] = 5;
            a[1] = 10;
            a[2] = 15;
            a[3] = 20;
            for (i in a) {
                a[i] *= 2;
            }
        }"#,
        );
        eval_stmt(&stmt, &mut rt).unwrap();
        assert_eq!(
            rt.vars.get("a", Some("0")).unwrap(),
            Value::from(10.0),
            "{:?}",
            stmt
        );
        assert_eq!(
            rt.vars.get("a", Some("1")).unwrap(),
            Value::from(20.0),
            "{:?}",
            stmt
        );
        assert_eq!(
            rt.vars.get("a", Some("2")).unwrap(),
            Value::from(30.0),
            "{:?}",
            stmt
        );
        assert_eq!(
            rt.vars.get("a", Some("3")).unwrap(),
            Value::from(40.0),
            "{:?}",
            stmt
        );
    }
```


Overlapping Code:
```
{
let mut out = Cursor::new(Vec::new());
let mut rt = Runtime::new(Program::empty(), &mut out).unwrap();
let stmt = get_stmt(
r#"{
a[0] = 5;
a[1] = 10;
a[2] = 15;
a[3] = 20;
for (i in a) {
a[i] *= 2;
}
}"#,
);
eval_stmt(&stmt, &mut rt).unwrap();
assert_eq!(
rt.vars.get("a", Some("0")).unwrap(),
Value::from(10.0),
"{:?}",
stmt
);
assert_eq!(
rt.vars.get("a", Some("1")).unwrap(),
Value::from(20.0),
"{:?}",
stmt
);
assert_eq!(
rt.vars.get("a", Some("2")).unwrap(),
Value::from(30.0),
"{:?}",
stmt
);
assert_eq!(
rt.vars.get("a", Some("3")).unwrap(),
```
<Overlap Ratio: 0.9181969949916527>

---

--- 17 --
Question ID: 3a4b0708fe96dfc325bf1d4d3549e1c2eb5bca86_1
Original Code:
```
fn test_insert_batch_error() {
        let db = MemoryDB::open();

        let data = b"test".to_vec();

        match db.insert_batch(None, vec![data], vec![]) {
            Err(DatabaseError::InvalidData) => (), // pass
            _ => panic!("should return error DatabaseError::InvalidData"),
        }
    }
```


Overlapping Code:
```
) {
let db = MemoryDB::open();
let data = b"test".to_vec();
match db.insert_batch(None, vec![data], vec![]) {
Err(DatabaseError::InvalidData) => (), // pass
_ => panic!("should return error DatabaseError::Invali
```
<Overlap Ratio: 0.844>

---

--- 18 --
Question ID: f66bb2399630427c8a60fab70536952f6fd70fe8_1
Original Code:
```
fn main() {
    env_logger::init();
    let server = Server::http("127.0.0.1:1337").unwrap();
    let _guard = server.handle(echo);
    println!("Listening on http://127.0.0.1:1337");
}
```


Overlapping Code:
```
init();
let server = Server::http("127.0.0.1:1337").unwrap();
let _guard = server.handle(echo);
prin
```
<Overlap Ratio: 0.591715976331361>

---

--- 19 --
Question ID: 3e6bd45234983a3e9b2e01a3c4914abacbeade6a_13
Original Code:
```
pub fn _68(c: &mut Context, b: &mut Bus) {
    // Increment S
    c.step(b);
    c.s = c.s.wrapping_add(1);

    // Pull register from stack
    c.step(b);
    c.a = b.read(0x100 + c.s as u16);

    c.p.set(cpu::ZERO, c.a == 0);
    c.p.set(cpu::SIGN, c.a & 0x80 != 0);
}
```


Overlapping Code:
```
: &mut Context, b: &mut Bus) {
// Increment S
c.step(b);
c.s = c.s.wrapping_add(1);
// Pull register from stack
c.step(b);
c.a = b.read(0x100 + c.s as u16);
c.p.set(cpu::ZERO, c.a == 0);
c.p.set(cpu::SIGN, c.a & 0x8
```
<Overlap Ratio: 0.9071729957805907>

---

--- 20 --
Question ID: fe6c8a7fe7303b729df325b6ab28632a5fc594ad_3
Original Code:
```
pub fn task2( map: &Vec<String> ) -> usize {
    let n : i32 = 128;
    let mut on : HashMap<Point, i32> = HashMap::new();
    let no_group = -1;
    for y in 0 .. n {
        let r : Vec<bool> = map.get(y as usize ).unwrap().chars()
            .flat_map( |c| hex_to_bin(c) ).collect();
        assert_eq!( n as usize, r.len() );
        for x in 0 .. n {
            let is_set = r.get(x as usize).unwrap();
            if *is_set { on.insert((x, y), no_group); }
        }
    }
    let max_gr = on.len() as i32;
    for cur_gr in 0 .. max_gr {
        let oe = on.clone().into_iter().find( |e| e.1 == no_group);
        if oe.is_none() { break; }
        // this is a new group
        let p0 = oe.unwrap().0;
        on.insert(p0, cur_gr );
        let mut s : HashSet<Point> = HashSet::new();
        s.insert(p0);
        while !s.is_empty() {
            let mut s1 : HashSet<Point> = HashSet::new();
            for p in s  {
                let close_points : Vec<Point> = on.clone().into_iter()
                    .filter( |e| e.1 == no_group && close(&e.0, &p ) )
                    .map( |e| e.0 ).collect();
                s1.extend( close_points );
            }
            for p in &s1 { on.insert(*p, cur_gr ); }
            s = s1;
        }
    }

    let set : HashSet<i32> = on.into_iter().map( |e| e.1 ).collect();
    assert!( !set.contains( &no_group) );
    set.len()
}
```


Overlapping Code:
```
<String> ) -> usize {
let n : i32 = 128;
let mut on : HashMap<Point, i32> = HashMap::new();
let no_group = -1;
for y in 0 .. n {
let r : Vec<bool> = map.get(y as usize ).unwrap().chars()
.flat_map( |c| hex_to_bin(c) ).collect();
assert_eq!( n as usize, r.len() );
for x in 0 .. n {
let is_set = r.get(x as usize).unwrap();
if *is_set { on.insert((x, y), no_group); }
}
}
let max_gr = on.len() as i32;
for cur_gr in 0 .. max_gr {
let oe = on.clone().into_iter().find( |e| e.1 == no_group);
if oe.is_none() { break; }
// this is a new group
let p0 = oe.unwrap().0;
on.insert(p0, cur_gr );
let mut s : HashSet<Point> = HashSet::new();
s.insert(p0);
while !s.is_empty() {
let mut s1 : HashSet<Point> = HashSet::new();
for p in s {
let close_points : Vec<Point> = on.clone().into_iter()
.filter( |e| e.1 == no_group && close(&e.0, &p ) )
.map( |e| e.0 ).collect();
s1.extend( close_points );
}
for p in &s1 { on.insert(*p, cur_gr ); }
s = s1;
}
}
let set : HashSet<i32> = on.into_iter().map( |e| e.1 ).collect();
assert!( !set.contains( &no_group) );
set.
```
<Overlap Ratio: 0.9722222222222222>

---

--- 21 --
Question ID: 9aacdbe51d873bcdceab2a7cc16e8a62fda74071_2
Original Code:
```
fn slice_x1000(b: &mut Bencher) {
    let buf = HeapRb::<u64>::new(RB_SIZE);
    let (mut prod, mut cons) = buf.split();
    prod.push_slice(&[1; 12]);
    let mut data = [1; 1000];
    b.iter(|| {
        prod.push_slice(&data);
        cons.pop_slice(&mut data);
    });
    black_box(data);
}
```


Overlapping Code:
```
&mut Bencher) {
let buf = HeapRb::<u64>::new(RB_SIZE);
let (mut prod, mut cons) = buf.split();
prod.push_slice(&[1; 12]);
let mut data = [1; 1000];
b.iter(|| {
prod.push_slice(&data);
cons.pop_slice(&mut data);
});
black_box(data);
```
<Overlap Ratio: 0.9203187250996016>

---

--- 22 --
Question ID: b3de16a792060052320e753a449a25b234163faa_83
Original Code:
```
fn test_is_shifted_mask() {
        assert_eq!(true, is_shifted_mask(8));
        assert_eq!(true, is_shifted_mask(6));
        assert_eq!(true, is_shifted_mask(7));
        assert_eq!(true, is_shifted_mask(3));
        assert_eq!(true, is_shifted_mask(1));
        assert_eq!(true, is_shifted_mask(!0));

        assert_eq!(false, is_shifted_mask(0));
        assert_eq!(false, is_shifted_mask(9));
        assert_eq!(false, is_shifted_mask(1 << 63 | 1));
    }
```


Overlapping Code:
```
n test_is_shifted_mask() {
assert_eq!(true, is_shifted_mask(8));
assert_eq!(true, is_shifted_mask(6));
assert_eq!(true, is_shifted_mask(7));
assert_eq!(true, is_shifted_mask(3));
assert_eq!(true, is_shifted_mask(1));
assert_eq!(true, is_shifted_mask(!0));
assert_eq!(false, is_shifted_mask(0));
assert_eq!(false, is_shifted_mask(9));
assert_eq!(false
```
<Overlap Ratio: 0.9090909090909091>

---

--- 23 --
Question ID: eaa111470141c108d7893ca634be26134ec228b4_0
Original Code:
```
fn bind_client<C: ClientState, T: AsyncRead + AsyncWrite>(
    io: T,
) -> (
    impl Sink<SinkItem = C::Send, SinkError = ()>,
    impl Stream<Item = C::Receive, Error = Error>,
) {
    let (raw_sender, raw_receiver) = bind_transport(io);
    let sender = raw_sender
        .with(|msg| serialize_message(&msg))
        .sink_map_err(|_| ());
    let receiver = raw_receiver.and_then(parse_message::<C::Receive>);
    (sender, receiver)
}
```


Overlapping Code:
```
State, T: AsyncRead + AsyncWrite>(
io: T,
) -> (
impl Sink<SinkItem = C::Send, SinkError = ()>,
impl Stream<Item = C::Receive, Error = Error>,
) {
let (raw_sender, raw_receiver) = bind_transport(io);
let sender = raw_sender
.with(|msg| serialize_message(&msg))
.sink_map_err(|_| ());
let receiver = raw_receiver.and_then(parse_message::<C::Receive>);
```
<Overlap Ratio: 0.8860759493670886>

---

--- 24 --
Question ID: 9cb5ffda8007df05fff157d52a348a054b4035c7_6
Original Code:
```
fn test_health_watch_multiple() {
    let (_server, service, client) = setup();

    // Watch should fetch service status immediately.
    let mut statuses0 = vec![watch(&client, "")];
    assert_next(ServingStatus::ServiceUnknown, &mut statuses0[0]);

    service.set_serving_status("", ServingStatus::Serving);
    statuses0.push(watch(&client, ""));
    for s in &mut statuses0 {
        assert_next(ServingStatus::Serving, s);
    }

    service.set_serving_status("", ServingStatus::NotServing);
    statuses0.push(watch(&client, ""));
    for s in &mut statuses0 {
        assert_next(ServingStatus::NotServing, s);
    }

    // Multiple watchers for multiple service should work correctly.
    let mut statuses1 = vec![watch(&client, TEST_SERVICE)];
    assert_next(ServingStatus::ServiceUnknown, &mut statuses1[0]);
    service.set_serving_status(TEST_SERVICE, ServingStatus::NotServing);
    service.set_serving_status("", ServingStatus::Serving);
    for s in &mut statuses0 {
        assert_next(ServingStatus::Serving, s);
    }
    for s in &mut statuses1 {
        assert_next(ServingStatus::NotServing, s);
    }
}
```


Overlapping Code:
```
h_watch_multiple() {
let (_server, service, client) = setup();
// Watch should fetch service status immediately.
let mut statuses0 = vec![watch(&client, "")];
assert_next(ServingStatus::ServiceUnknown, &mut statuses0[0]);
service.set_serving_status("", ServingStatus::Serving);
statuses0.push(watch(&client, ""));
for s in &mut statuses0 {
assert_next(ServingStatus::Serving, s);
}
service.set_serving_status("", ServingStatus::NotServing);
statuses0.push(watch(&client, ""));
for s in &mut statuses0 {
assert_next(ServingStatus::NotServing, s);
}
// Multiple watchers for multiple service should work correctly.
let mut statuses1 = vec![watch(&client, TEST_SERVICE)];
assert_next(ServingStatus::ServiceUnknown, &mut statuses1[0]);
service.set_serving_status(TEST_SERVICE, ServingStatus::NotServing);
service.set_serving_status("", ServingStatus::Serving);
for s in &mut statuses0 {
assert_next(ServingStatus::Serving, s);
}
for s in &mut statuses1 {
```
<Overlap Ratio: 0.9405940594059405>

---

--- 25 --
Question ID: 4a1d151e963f3e9b73fe97636c1f3ce2c5443df7_11
Original Code:
```
fn it_correctly_detects_no_intersection_for_parallel_lines() {
            let l1 = WireSegment::new(Point::new(0, 0), Point::new(1, 1));
            let l2 = WireSegment::new(Point::new(0, 1), Point::new(1, 2));
            assert_eq!(None, l1.intersection(&l2))
        }
```


Overlapping Code:
```
or_parallel_lines() {
let l1 = WireSegment::new(Point::new(0, 0), Point::new(1, 1));
let l2 = WireSegment::new(Point::new(0, 1), Point::new(1, 2));
as
```
<Overlap Ratio: 0.6550218340611353>

---

--- 26 --
Question ID: ae40e35935b9c79c3de52a08d8bab950d2c150bd_2
Original Code:
```
fn import_donorbox(ledger: &mut Ledger, data: &PathBuf) {
    let stripe = ledger
        .get_account("Stripe")
        .expect("Account for Stripe not found");

    let paypal = ledger
        .get_account("PayPal")
        .expect("Account for PayPal not found");

    let known_donations: Vec<DonationID> = stripe
        .transactions
        .iter()
        .chain(&paypal.transactions)
        .filter_map(|x| match &x.meta {
            TransactionMetadata::Income {
                kind: IncomeKind::Donation(x),
                ..
            } => Some(x),
            _ => None,
        })
        .map(Clone::clone)
        .collect();

    let mut donations_stripe: Vec<Transaction> = Vec::new();
    let mut donations_paypal: Vec<Transaction> = Vec::new();

    let mut reader = csv::Reader::from_path(data).expect("Could not read the CSV file");

    let records = reader.deserialize();
    for (i, x) in records.enumerate() {
        let x: DonorBoxRow =
            x.unwrap_or_else(|e| panic!("Could not deserialize entry on entry {}!\n{}", i, e));
        let mut amount = currency::Currency::from_str(&x.amount)
            .unwrap_or_else(|e| panic!("Could not parse transaction amount on entry {}!\n{}", i, e));
        let mut fee = currency::Currency::from_str(&x.fee)
            .unwrap_or_else(|e| panic!("Could not parse fee on entry {}!\n{}", i, e));
        let date = chrono::Utc
            .datetime_from_str(&x.date.trim_end_matches(" UTC"), "%Y-%m-%d %H:%M:%S")
            .unwrap_or_else(|e| panic!("Could not parse transaction date on entry {}!\n{}", i, e));

        amount.set_symbol('$');
        fee.set_symbol('$');

        let mut hasher = crypto::sha2::Sha256::new();
        hasher.input_str("DonorBox");
        hasher.input_str(&x.name);
        hasher.input_str(&x.date);
        hasher.input_str(&x.amount);
        hasher.input_str(&x.receipt);

        let mut hash = vec![0; 32];
        hasher.result(&mut hash);

        if !known_donations.contains(&hash) {
            let meta = TransactionMetadata::Income {
                kind: IncomeKind::Donation(hash),
                from: x.name.to_owned(),
            };

            match x.processor.as_ref() {
                "stripe" => {
                    donations_stripe.push(Transaction {
                        amount,
                        date,
                        meta,
                        description: "Donation made through the DonorBox platform".to_owned(),
                        fees: vec![Fee {
                            amount: fee,
                            towards: "DonorBox Processing".to_owned(),
                        }],
                    });
                }
                "paypal" | "paypal_express" => {
                    donations_paypal.push(Transaction {
                        amount,
                        date,
                        meta,
                        description: "Donation made through the DonorBox platform".to_owned(),
                        fees: vec![Fee {
                            amount: fee,
                            towards: "DonorBox Processing".to_owned(),
                        }],
                    });
                }
                mtd => println!("WARNING: Unknown donation method `{}` for donation from `{}` on {} (entry {}).", mtd, x.name, x.date, i),
            }
        } else {
            println!(
                "WARNING: Donation from `{}` on {} (entry {}) is already in the ledger.",
                x.name, x.date, i
            );
        }
    }

    donations_stripe.sort_by(|x, y| x.date.cmp(&y.date));
    ledger
        .get_account_mut("Stripe")
        .expect("Account for Stripe not found")
        .transactions
        .append(&mut donations_stripe);

    donations_paypal.sort_by(|x, y| x.date.cmp(&y.date));
    ledger
        .get_account_mut("PayPal")
        .expect("Account for PayPal not found")
        .transactions
        .append(&mut donations_paypal);
}
```


Overlapping Code:
```
ox(ledger: &mut Ledger, data: &PathBuf) {
let stripe = ledger
.get_account("Stripe")
.expect("Account for Stripe not found");
let paypal = ledger
.get_account("PayPal")
.expect("Account for PayPal not found");
let known_donations: Vec<DonationID> = stripe
.transactions
.iter()
.chain(&paypal.transactions)
.filter_map(|x| match &x.meta {
TransactionMetadata::Income {
kind: IncomeKind::Donation(x),
..
} => Some(x),
_ => None,
})
.map(Clone::clone)
.collect();
let mut donations_stripe: Vec<Transaction> = Vec::new();
let mut donations_paypal: Vec<Transaction> = Vec::new();
let mut reader = csv::Reader::from_path(data).expect("Could not read the CSV file");
let records = reader.deserialize();
for (i, x) in records.enumerate() {
let x: DonorBoxRow =
x.unwrap_or_else(|e| panic!("Could not deserialize entry on entry {}!\n{}", i, e));
let mut amount = currency::Currency::from_str(&x.amount)
.unwrap_or_else(|e| panic!("Could not parse transaction amount on entry {}!\n{}", i, e));
let mut fee = currency::Currency::from_str(&x.fee)
.unwrap_or_else(|e| panic!("Could not parse fee on entry {}!\n{}", i, e));
let date = chrono::Utc
.datetime_from_str(&x.date.trim_end_matches(" UTC"), "%Y-%m-%d %H:%M:%S")
.unwrap_or_else(|e| panic!("Could not parse transaction date on entry {}!\n{}", i, e));
amount.set_symbol('$');
fee.set_symbol('$');
let mut hasher = crypto::sha2::Sha256::new();
hasher.input_str("DonorBox");
hasher.input_str(&x.name);
hasher.input_str(&x.date);
hasher.input_str(&x.amount);
hasher.input_str(&x.receipt);
let mut hash = vec![0; 32];
hasher.result(&mut hash);
if !known_donations.contains(&hash) {
let meta = TransactionMetadata::Income {
kind: IncomeKind::Donation(hash),
from: x.name.to_owned(),
};
match x.processor.as_ref() {
"stripe" => {
donations_stripe.push(Transaction {
amount,
date,
meta,
description: "Donation made throu
```
<Overlap Ratio: 0.9722513089005236>

---

--- 27 --
Question ID: 28be31fdab926ee2f934b2f9d1a00757e8b486b4_5
Original Code:
```
fn tear(
    input: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,
    rng: &mut rand_xoshiro::Xoshiro256StarStar,
    max_times: u32,
    max_thickness: u32,
    max_amount: u32,
    range: u32,
) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {
    println!("Tear FX");

    let mut output = input.clone();
    let (width, height) = input.dimensions();
    let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };

    let shift_times = (rng.gen::<f64>() * max_times as f64).floor() as u64;
    for _ in 0..shift_times {
        let begin_y = rng.gen_range(0, range) + range_begin;
        let thickness = rng.gen_range(0, max_thickness);
        let amount = rng.gen_range(0, max_amount);
        let direction = rng.gen_range(0, 2);

        if direction == 0 { // ->
            for x in 0..amount { // 端をミラーリング
                let max_y = cmp::min(height, begin_y + thickness);
                for y in begin_y..max_y {
                    output.put_pixel(x, y, *input.get_pixel(amount - x, y));
                }
            }
            for x in amount..width {
                let max_y = cmp::min(height, begin_y + thickness);
                for y in begin_y..max_y {
                    output.put_pixel(x, y, *input.get_pixel(x - amount, y));
                }
            }
        } else { // <-
            for x in (width - amount)..width { // 端をミラーリング
                let max_y = cmp::min(height, begin_y + thickness);
                for y in begin_y..max_y {
                    output.put_pixel(x, y, *input.get_pixel(width - (x - (width - amount)) - 1, y));
                }
            }
            for x in 0..(width - amount) {
                let max_y = cmp::min(height, begin_y + thickness);
                for y in begin_y..max_y {
                    output.put_pixel(x, y, *input.get_pixel(x + amount, y));
                }
            }
        }
    }

    output
}
```


Overlapping Code:
```
ut: image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>>,
rng: &mut rand_xoshiro::Xoshiro256StarStar,
max_times: u32,
max_thickness: u32,
max_amount: u32,
range: u32,
) -> image::ImageBuffer<image::Rgba<u8>, std::vec::Vec<u8>> {
println!("Tear FX");
let mut output = input.clone();
let (width, height) = input.dimensions();
let range_begin = if height - range == 0 { 0 } else { rng.gen_range(0, height - range) };
let shift_times = (rng.gen::<f64>() * max_times as f64).floor() as u64;
for _ in 0..shift_times {
let begin_y = rng.gen_range(0, range) + range_begin;
let thickness = rng.gen_range(0, max_thickness);
let amount = rng.gen_range(0, max_amount);
let direction = rng.gen_range(0, 2);
if direction == 0 { // ->
for x in 0..amount { // 端をミラーリング
let max_y = cmp::min(height, begin_y + thickness);
for y in begin_y..max_y {
output.put_pixel(x, y, *input.get_pixel(amount - x, y));
}
}
for x in amount..width {
let max_y = cmp::min(height, begin_y + thickness);
for y in begin_y..max_y {
output.put_pixel(x, y, *input.get_pixel(x - amount, y));
}
}
} else { // <-
for x in (width - amount)..width { // 端をミラーリング
let max_y = cmp::min(height, begin_y + thickness);
for y in begin_y..max_y {
output.put_pixel(x, y, *input.get_pixel(width - (x - (width - amount)) - 1, y));
}
}
for x in 0..(width - amount) {
let max_y = cmp::min(height, begin_y + thickness);
for y in begin_y..max_y {
output.put_pixel(x, y, *input.get_pixel(x + a
```
<Overlap Ratio: 0.9728445349626612>

---

--- 28 --
Question ID: 97e8ae8f274d578a2fd82dbffc5c7a07a411b24f_0
Original Code:
```
fn test_boundary_to_difficulty() {
        let h1 = h256!("0x1000");
        let h2: U256 = target_to_difficulty(&h1);

        assert_eq!(target_to_difficulty(&h2.into()), u256!("4096"));
    }
```


Overlapping Code:
```
st_boundary_to_difficulty() {
let h1 = h256!("0x1000");
let h2: U256 = target_to_difficulty(&h1);
assert_eq!(tar
```
<Overlap Ratio: 0.6787878787878788>

---

--- 29 --
Question ID: cd63239b14314163ea6512af3f272a927623a2b7_8
Original Code:
```
fn test_string() {
    assert_eq!(parse_sexpr("\"\""), Ok(Elem::String("".to_string())));
    assert_eq!(parse_sexpr("\"foo\""), Ok(Elem::String("foo".to_string())));
    assert_eq!(parse_sexpr("\"A quote: \\\"\""),
      Ok(Elem::String("A quote: \"".to_string())));
    assert_eq!(parse_sexpr("\"C:\\\\Windows\""),
      Ok(Elem::String("C:\\Windows".to_string())));
    assert_eq!(parse_sexpr("\"\\r\\n\\t\\e\""), 
      Ok(Elem::String("\r\n\t\u{1b}".to_string())));
  }
```


Overlapping Code:
```
ring() {
assert_eq!(parse_sexpr("\"\""), Ok(Elem::String("".to_string())));
assert_eq!(parse_sexpr("\"foo\""), Ok(Elem::String("foo".to_string())));
assert_eq!(parse_sexpr("\"A quote: \\\"\""),
Ok(Elem::String("A quote: \"".to_string())));
assert_eq!(parse_sexpr("\"C:\\\\Windows\""),
Ok(Elem::String("C:\\Windows".to_string())));
assert_eq!(parse_sexpr("\"\\r\\n\\t\\e\""), 
Ok(Elem::String("\r\n\t\
```
<Overlap Ratio: 0.9216589861751152>

---

--- 30 --
Question ID: 6412366c01d9d1fcc0f260d34b639412ea8704fc_0
Original Code:
```
pub async fn set_phone_number(req: String) -> HttpResponse {
    let clean_string = clean_quotes(&req);
    trace!("Got number {:?}", clean_string);
    let phone_number: PhoneNumber = match clean_string.parse() {
        Ok(p) => p,
        Err(e) => {
            info!("Failed to parse phonenumber with {:?}", e);
            return HttpResponse::BadRequest().finish();
        }
    };

    let mut rita_client = settings::get_rita_client();

    // merge the new value into the existing struct, for the various possibilities
    let res = match option_convert(rita_client.exit_client.contact_info.clone()) {
        Some(ContactType::Phone {
            number: _,
            sequence_number,
        }) => Some(ContactType::Phone {
            number: phone_number,
            sequence_number: Some(add_to_sequence(sequence_number)),
        }),
        Some(ContactType::Email {
            email,
            sequence_number,
        }) => Some(ContactType::Both {
            number: phone_number,
            email,
            sequence_number: Some(add_to_sequence(sequence_number)),
        }),
        Some(ContactType::Both {
            number: _number,
            email,
            sequence_number,
        }) => Some(ContactType::Both {
            number: phone_number,
            email,
            sequence_number: Some(add_to_sequence(sequence_number)),
        }),
        Some(ContactType::Bad {
            invalid_number: _,
            invalid_email: _,
            sequence_number,
        }) => Some(ContactType::Phone {
            number: phone_number,
            sequence_number: Some(add_to_sequence(sequence_number)),
        }),
        None => Some(ContactType::Phone {
            number: phone_number,
            sequence_number: Some(0),
        }),
    };
    rita_client.exit_client.contact_info = option_convert(res);

    settings::set_rita_client(rita_client);

    // save immediately
    if let Err(_e) = settings::write_config() {
        return HttpResponse::InternalServerError().finish();
    }

    HttpResponse::Ok().finish()
}
```


Overlapping Code:
```
ync fn set_phone_number(req: String) -> HttpResponse {
let clean_string = clean_quotes(&req);
trace!("Got number {:?}", clean_string);
let phone_number: PhoneNumber = match clean_string.parse() {
Ok(p) => p,
Err(e) => {
info!("Failed to parse phonenumber with {:?}", e);
return HttpResponse::BadRequest().finish();
}
};
let mut rita_client = settings::get_rita_client();
// merge the new value into the existing struct, for the various possibilities
let res = match option_convert(rita_client.exit_client.contact_info.clone()) {
Some(ContactType::Phone {
number: _,
sequence_number,
}) => Some(ContactType::Phone {
number: phone_number,
sequence_number: Some(add_to_sequence(sequence_number)),
}),
Some(ContactType::Email {
email,
sequence_number,
}) => Some(ContactType::Both {
number: phone_number,
email,
sequence_number: Some(add_to_sequence(sequence_number)),
}),
Some(ContactType::Both {
number: _number,
email,
sequence_number,
}) => Some(ContactType::Both {
number: phone_number,
email,
sequence_number: Some(add_to_sequence(sequence_number)),
}),
Some(ContactType::Bad {
invalid_number: _,
invalid_email: _,
sequence_number,
}) => Some(ContactType::Phone {
number: phone_number,
sequence_number: Some(add_to_sequence(sequence_number)),
}),
None => Some(ContactType::Phone {
number: phone_number,
sequence_number: Some(0),
}),
};
rita_client.exit_client.contact_info = option_convert(res);
settings::set_rita_client(rita_client);
// save immediately
if let Err(_e) = settings::write_config() {
return HttpResponse::InternalServerError().finish();
}
HttpResponse::Ok
```
<Overlap Ratio: 0.9880653266331658>

---

--- 31 --
Question ID: 57a011a843d4347ef4ad4b0efc200225090cdd5e_5
Original Code:
```
fn test_fft2() -> Result<()> {
        let input = parse_signal("80871224585914546619083218645595")?;
        assert_eq!([2, 4, 1, 7, 6, 1, 7, 6], apply_fft(100, &input)[0..8]);
        Ok(())
    }
```


Overlapping Code:
```
_fft2() -> Result<()> {
let input = parse_signal("80871224585914546619083218645595")?;
assert_eq!([2, 4, 1, 7, 6, 1, 7, 6], apply_fft(100, &input)[0..
```
<Overlap Ratio: 0.8823529411764706>

---

--- 32 --
Question ID: ad84a70282b8c08846b32a8b2fca20191e7dbc30_8
Original Code:
```
fn tuple_without_element() {
            let mut heap = RegionHeap::default();
            let lhs = heap.tuple_from_slice(&[]).unwrap();
            let rhs = heap.tuple_from_slice(&[]).unwrap();

            assert_eq!(lhs, lhs);
            assert_eq!(lhs, rhs);
            assert_eq!(rhs, lhs);
        }
```


Overlapping Code:
```
{
let mut heap = RegionHeap::default();
let lhs = heap.tuple_from_slice(&[]).unwrap();
let rhs = heap.tuple_from_slice(&[]).unwrap();
assert_eq!(lhs, lhs);
assert_eq!(lhs, rhs);
assert_eq!(rhs, lhs);

```
<Overlap Ratio: 0.8771929824561403>

---

--- 33 --
Question ID: 183e5b808be51086657173d38d4150c4720d81d0_12
Original Code:
```
fn test_div() {
        let one: ModInt = ModInt::from_value_modulus(
            BigInt::from(23),
            BigInt::from(11),
        );

        let two: ModInt = ModInt::from_value_modulus(
            BigInt::from(2),
            BigInt::from(0),
        );

        let div = one / two;
        assert_eq!(BigInt::from(6), div.value);
        assert_eq!(BigInt::from(11), div.modulus);


        let one2: ModInt = ModInt::from_value_modulus(
            BigInt::from(23),
            BigInt::from(11),
        );
        let two2: ModInt = ModInt::from_value_modulus(
            BigInt::from(2),
            BigInt::from(0),
        );

        let zero: ModInt = one2 - ModInt::one();
        let zero_res: ModInt = zero / two2;
        assert_eq!(BigInt::from(0), zero_res.value);
        assert_eq!(BigInt::from(11), zero_res.modulus);
    }
```


Overlapping Code:
```
div() {
let one: ModInt = ModInt::from_value_modulus(
BigInt::from(23),
BigInt::from(11),
);
let two: ModInt = ModInt::from_value_modulus(
BigInt::from(2),
BigInt::from(0),
);
let div = one / two;
assert_eq!(BigInt::from(6), div.value);
assert_eq!(BigInt::from(11), div.modulus);
let one2: ModInt = ModInt::from_value_modulus(
BigInt::from(23),
BigInt::from(11),
);
let two2: ModInt = ModInt::from_value_modulus(
BigInt::from(2),
BigInt::from(0),
);
let zero: ModInt = one2 - ModInt::one();
let zero_res: ModInt = zero / two2;
assert_eq!(BigInt::from(0), zero_res.value);
assert_eq!(BigInt::from(11),
```
<Overlap Ratio: 0.9538950715421304>

---

--- 34 --
Question ID: e24c2a009f438fb0d893e36b3e90c9d67639c771_15
Original Code:
```
pub unsafe fn mailmime_set_epilogue_text(
    mut build_info: *mut mailmime,
    mut data_str: *mut libc::c_char,
    mut length: size_t,
) -> libc::c_int {
    let mut data: *mut mailmime_data = 0 as *mut mailmime_data;
    data = mailmime_data_new(
        MAILMIME_DATA_TEXT as libc::c_int,
        MAILMIME_MECHANISM_8BIT as libc::c_int,
        0i32,
        data_str,
        length,
        0 as *mut libc::c_char,
    );
    if data.is_null() {
        return MAILIMF_ERROR_MEMORY as libc::c_int;
    }
    (*build_info).mm_data.mm_multipart.mm_epilogue = data;
    return MAILIMF_NO_ERROR as libc::c_int;
}
```


Overlapping Code:
```
mailmime_set_epilogue_text(
mut build_info: *mut mailmime,
mut data_str: *mut libc::c_char,
mut length: size_t,
) -> libc::c_int {
let mut data: *mut mailmime_data = 0 as *mut mailmime_data;
data = mailmime_data_new(
MAILMIME_DATA_TEXT as libc::c_int,
MAILMIME_MECHANISM_8BIT as libc::c_int,
0i32,
data_str,
length,
0 as *mut libc::c_char,
);
if data.is_null() {
return MAILIMF_ERROR_MEMORY as libc::c_int;
}
(*build_info).mm_data.mm_multipart.mm_epilogue = data;
return MAILIMF_NO_ERROR as libc::c_i
```
<Overlap Ratio: 0.9633911368015414>

---

--- 35 --
Question ID: 5a62b9a46fc40ca7c1d02d99ad7085dd94fff29c_12
Original Code:
```
fn moves_sprites() {
    let mut tia = Tia::new();
    tia.write(registers::COLUBK, 0x00).unwrap();
    tia.write(registers::COLUP0, 0x02).unwrap();
    tia.write(registers::COLUP1, 0x04).unwrap();
    tia.write(registers::COLUPF, 0x06).unwrap();
    tia.write(registers::GRP0, 0b1100_0011).unwrap();
    tia.write(registers::GRP1, 0b1100_0011).unwrap();
    tia.write(registers::ENAM0, flags::ENAXX_ENABLE).unwrap();
    tia.write(registers::ENAM1, flags::ENAXX_ENABLE).unwrap();
    tia.write(registers::ENABL, flags::ENAXX_ENABLE).unwrap();
    tia.write(registers::HMP0, 3 << 4).unwrap();
    tia.write(registers::HMP1, (-5i8 << 4) as u8).unwrap();
    tia.write(registers::HMM0, (-6i8 << 4) as u8).unwrap();
    tia.write(registers::HMM1, 4 << 4 as u8).unwrap();
    tia.write(registers::HMBL, (-1i8 << 4) as u8).unwrap();

    let p0_delay = 32 * 3;
    let p1_delay = 6 * 3;
    let m0_delay = 9 * 3;
    let m1_delay = 2 * 3;
    let ball_delay = 3 * 3;
    wait_ticks(&mut tia, p0_delay);
    tia.write(registers::RESP0, 0).unwrap();
    wait_ticks(&mut tia, p1_delay);
    tia.write(registers::RESP1, 0).unwrap();
    wait_ticks(&mut tia, m0_delay);
    tia.write(registers::RESM0, 0).unwrap();
    wait_ticks(&mut tia, m1_delay);
    tia.write(registers::RESM1, 0).unwrap();
    wait_ticks(&mut tia, ball_delay);
    tia.write(registers::RESBL, 0).unwrap();
    wait_ticks(
        &mut tia,
        TOTAL_WIDTH - p0_delay - p1_delay - m0_delay - m1_delay - ball_delay,
    );

    // Pretend we're doing an STA: wait for 2 CPU cycles, write to register
    // on the 3rd one.
    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);
    tia.write(registers::HMOVE, 0).unwrap();
    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));

    assert_eq!(
        encode_video_outputs(scanline),
        "................||||||||||||||||....................................\
         ........000000000000000000000000220000220000000000000000004400004400000000000000\
         04000200000000060000000000000000000000000000000000000000000000000000000000000000",
    );

    // Do the same once again, and then clear the movement registers before
    // HMOVE on the 3rd line. The 3rd line should look exactly as the 2nd
    // one.
    let mut scanline = scan_video(&mut tia, 2 * 3 + 1);
    tia.write(registers::HMOVE, 0).unwrap();
    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));
    tia.write(registers::HMCLR, 0).unwrap();
    scanline.append(&mut scan_video(&mut tia, 2 * 3 + 1));
    tia.write(registers::HMOVE, 0).unwrap();
    scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));

    assert_eq!(
        encode_video_outputs(scanline),
        "................||||||||||||||||....................................\
         ........000000000000000000000220000220000000000000000000000000044000044000000400\
         00000000000200006000000000000000000000000000000000000000000000000000000000000000\
         ................||||||||||||||||....................................\
         ........000000000000000000000220000220000000000000000000000000044000044000000400\
         00000000000200006000000000000000000000000000000000000000000000000000000000000000",
    );

    // Test RESMPx: make sure the missiles move along with players and stop
    // following them once they are freed.
    tia.write(registers::RESMP0, flags::RESMPX_RESET).unwrap();
    assert_eq!(
        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),
        "................||||||||||||||||....................................\
         00000000000000000000000000000220000220000000000000000000000000044000044000000400\
         00000000000000006000000000000000000000000000000000000000000000000000000000000000",
    );

    tia.write(registers::RESMP1, flags::RESMPX_RESET).unwrap();
    assert_eq!(
        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),
        "................||||||||||||||||....................................\
         00000000000000000000000000000220000220000000000000000000000000044000044000000000\
         00000000000000006000000000000000000000000000000000000000000000000000000000000000",
    );

    tia.write(registers::RESMP0, 0).unwrap();
    assert_eq!(
        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),
        "................||||||||||||||||....................................\
         00000000000000000000000000000220020220000000000000000000000000044000044000000000\
         00000000000000006000000000000000000000000000000000000000000000000000000000000000",
    );
    tia.write(registers::RESMP1, 0).unwrap();
    assert_eq!(
        encode_video_outputs(scan_video(&mut tia, TOTAL_WIDTH)),
        "................||||||||||||||||....................................\
         00000000000000000000000000000220020220000000000000000000000000044004044000000000\
         00000000000000006000000000000000000000000000000000000000000000000000000000000000",
    );
}
```


Overlapping Code:
```
fn moves_sprites() {
let mut tia = Tia::new();
tia.write(registers::COLUBK, 0x00).unwrap();
tia.write(registers::COLUP0, 0x02).unwrap();
tia.write(registers::COLUP1, 0x04).unwrap();
tia.write(registers::COLUPF, 0x06).unwrap();
tia.write(registers::GRP0, 0b1100_0011).unwrap();
tia.write(registers::GRP1, 0b1100_0011).unwrap();
tia.write(registers::ENAM0, flags::ENAXX_ENABLE).unwrap();
tia.write(registers::ENAM1, flags::ENAXX_ENABLE).unwrap();
tia.write(registers::ENABL, flags::ENAXX_ENABLE).unwrap();
tia.write(registers::HMP0, 3 << 4).unwrap();
tia.write(registers::HMP1, (-5i8 << 4) as u8).unwrap();
tia.write(registers::HMM0, (-6i8 << 4) as u8).unwrap();
tia.write(registers::HMM1, 4 << 4 as u8).unwrap();
tia.write(registers::HMBL, (-1i8 << 4) as u8).unwrap();
let p0_delay = 32 * 3;
let p1_delay = 6 * 3;
let m0_delay = 9 * 3;
let m1_delay = 2 * 3;
let ball_delay = 3 * 3;
wait_ticks(&mut tia, p0_delay);
tia.write(registers::RESP0, 0).unwrap();
wait_ticks(&mut tia, p1_delay);
tia.write(registers::RESP1, 0).unwrap();
wait_ticks(&mut tia, m0_delay);
tia.write(registers::RESM0, 0).unwrap();
wait_ticks(&mut tia, m1_delay);
tia.write(registers::RESM1, 0).unwrap();
wait_ticks(&mut tia, ball_delay);
tia.write(registers::RESBL, 0).unwrap();
wait_ticks(
&mut tia,
TOTAL_WIDTH - p0_delay - p1_delay - m0_delay - m1_delay - ball_delay,
);
// Pretend we're doing an STA: wait for 2 CPU cycles, write to register
// on the 3rd one.
let mut scanline = scan_video(&mut tia, 2 * 3 + 1);
tia.write(registers::HMOVE, 0).unwrap();
scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));
assert_eq!(
encode_video_outputs(scanline),
"................||||||||||||||||....................................\
........000000000000000000000000220000220000000000000000004400004400000000000000\
04000200000000060000000000000000000000000000000000000000000000000000000000000000",
);
// Do the same once again, and then clear the movement registers before
// HMOVE on the 3rd line. The 3rd line should look exactly as the 2nd
// one.
let mut scanline = scan_video(&mut tia, 2 * 3 + 1);
tia.write(registers::HMOVE, 0).unwrap();
scanline.append(&mut scan_video(&mut tia, TOTAL_WIDTH - (2 * 3 + 1)));
tia.write(registers::HMCLR, 0).unwrap();
scanline.appen
```
<Overlap Ratio: 0.9973404255319149>

---

--- 36 --
Question ID: 6c8088375c4b0548fc7d84f0b41a77827e137224_1
Original Code:
```
pub fn set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {
    // FIXME: #11906: Omitting frame pointers breaks retrieving the value of a
    // parameter.
    if cx.sess().must_not_eliminate_frame_pointers() {
        llvm::AddFunctionAttrStringValue(
            llfn, llvm::AttributePlace::Function,
            cstr("no-frame-pointer-elim\0"), cstr("true\0"));
    }
}
```


Overlapping Code:
```
set_frame_pointer_elimination(cx: &CodegenCx, llfn: ValueRef) {
// FIXME: #11906: Omitting frame pointers breaks retrieving the value of a
// parameter.
if cx.sess().must_not_eliminate_frame_pointers() {
llvm::AddFunctionAttrStringValue(
llfn, llvm::AttributePlace::Function,
cstr("no-frame-pointer-elim\0"), cstr("true\
```
<Overlap Ratio: 0.9523809523809523>

---

--- 37 --
Question ID: ce0bf3a6d09ddbb303c5b95108ef08990609a305_1
Original Code:
```
fn should_add_entry() {
    let tmp_dir = TempDir::new("emerald").unwrap();
    let a = AddressbookStorage::new(tmp_dir.into_path());
    let act = a.list();
    assert_eq!(act.len(), 0);

    let json = serde_json::from_str::<Value>(
        "{\"address\":\"0x000000000031eaedbc2b611aa528f22343eb52db\", \"name\":\"elaine\", \
         \"description\":\"drug money\"}",
    ).unwrap();
    a.add(&json).ok();
    let act = a.list();
    assert_eq!(act.len(), 1);
}
```


Overlapping Code:
```
_add_entry() {
let tmp_dir = TempDir::new("emerald").unwrap();
let a = AddressbookStorage::new(tmp_dir.into_path());
let act = a.list();
assert_eq!(act.len(), 0);
let json = serde_json::from_str::<Value>(
"{\"address\":\"0x000000000031eaedbc2b611aa528f22343eb52db\", \"name\":\"elaine\", \
\"description\":\"drug money\"}",
).unwrap();
a.add(&json).ok();
let act = a.list();
assert_eq!(act.len(), 1)
```
<Overlap Ratio: 0.9708029197080292>

---

--- 38 --
Question ID: 3047fd74874230e1c025c791fdfd2f52903a61cc_1
Original Code:
```
pub fn lba_to_cls(
    disk_lba: u64,
    head_count: u64,
    sector_count: u64,
) -> (u8, u8, u8)
{
    let mut sector_number = (disk_lba % sector_count) + 1;;
    let tmp = disk_lba / sector_count;
    let mut head_number = tmp % head_count;
    let mut cylinder_number = tmp / head_count;

    if cylinder_number > 0x400 {
        cylinder_number = 0x3FF;
        head_number = head_count;
        sector_number = sector_count;
    }

    sector_number |= (cylinder_number & 0x300) >> 2;
    cylinder_number &= 0xFF;

    (head_number as u8, sector_number as u8, cylinder_number as u8)
}
```


Overlapping Code:
```
_count: u64,
sector_count: u64,
) -> (u8, u8, u8)
{
let mut sector_number = (disk_lba % sector_count) + 1;;
let tmp = disk_lba / sector_count;
let mut head_number = tmp % head_count;
let mut cylinder_number = tmp / head_count;
if cylinder_number > 0x400 {
cylinder_number = 0x3FF;
head_number = head_count;
sector_number = sector_count;
}
sector_number |= (cylinder_number & 0x300) >> 2;
cylinder_number &= 0xFF;
(head_number as u8, sector_number as 
```
<Overlap Ratio: 0.872093023255814>

---

--- 39 --
Question ID: 41225c3fa3efc98a8ed4e49f32ad466e86bed2df_3
Original Code:
```
fn sync(route: &api::Route, list: &List) -> Result<(), Error> {
    let before = route
        .actions
        .iter()
        .map(|action| extract(action, "forward(\"", "\")"))
        .collect::<HashSet<_>>();
    let after = list.members.iter().map(|s| &s[..]).collect::<HashSet<_>>();
    if before == after {
        return Ok(())
    }

    let mut form = Form::new();
    for member in list.members.iter() {
        form.part("action").contents(format!("forward(\"{}\")", member).as_bytes()).add()?;
    }
    put::<Empty>(&format!("/routes/{}", route.id), form)?;

    Ok(())
}
```


Overlapping Code:
```
e: &api::Route, list: &List) -> Result<(), Error> {
let before = route
.actions
.iter()
.map(|action| extract(action, "forward(\"", "\")"))
.collect::<HashSet<_>>();
let after = list.members.iter().map(|s| &s[..]).collect::<HashSet<_>>();
if before == after {
return Ok(())
}
let mut form = Form::new();
for member in list.members.iter() {
form.part("action").contents(format!("forward(\"{}\")", member).as_bytes()).add()?;
}
put::<Empty>(&format!("/
```
<Overlap Ratio: 0.8982035928143712>

---

--- 40 --
Question ID: ab5293ee458ad84b43eb8071de56c5dbee8e5e61_4
Original Code:
```
fn insert_two_items_and_get_list_entries() {
        let mut table = InvertibleBloomLookupTable::<DefaultHasher>::new(256, 8).unwrap();
        assert!(table.insert(4, 6).is_ok());
        assert!(table.insert(5, 7).is_ok());
        let results = table.list_entries().ok().unwrap();
        assert_eq!(results.key_pairs.len(), 2);
        for output in results.key_pairs {
            if output.key_sum == 4 {
                assert_eq!(output.value_sum, 6);
            } else if output.key_sum == 5 {
                assert_eq!(output.value_sum, 7);
            }
        }
    }
```


Overlapping Code:
```
ntries() {
let mut table = InvertibleBloomLookupTable::<DefaultHasher>::new(256, 8).unwrap();
assert!(table.insert(4, 6).is_ok());
assert!(table.insert(5, 7).is_ok());
let results = table.list_entries().ok().unwrap();
assert_eq!(results.key_pairs.len(), 2);
for output in results.key_pairs {
if output.key_sum == 4 {
assert_eq!(output.value_sum, 6);
} else if output.key_sum == 5 {
assert_eq!(output.value_sum, 7);

```
<Overlap Ratio: 0.9140969162995595>

---

--- 41 --
Question ID: 1d74d2e8c42f9bc517d8ccbf2408f9c1e687350f_0
Original Code:
```
pub fn longest_common_prefix(strs: Vec<String>) -> String {
    let mut common = String::new();
    if strs.len() == 0 {
        return common;
    } else if strs.len() == 1 {
        return strs[0].clone();
    }

    let mut k: usize = 0;
    loop {
        let cur_ch: char;
        match strs[0].chars().nth(k) {
            None => {
                return common;
            }
            Some(ch) => {
                cur_ch = ch;
            }
        };

        for i in 1..strs.len() {
            match strs[i].chars().nth(k) {
                Some(ch) if cur_ch == ch => {}
                _ => return common,
            }
        }

        common.push(cur_ch);
        k += 1;
    }
}
```


Overlapping Code:
```
ub fn longest_common_prefix(strs: Vec<String>) -> String {
let mut common = String::new();
if strs.len() == 0 {
return common;
} else if strs.len() == 1 {
return strs[0].clone();
}
let mut k: usize = 0;
loop {
let cur_ch: char;
match strs[0].chars().nth(k) {
None => {
return common;
}
Some(ch) => {
cur_ch = ch;
}
};
for i in 1..strs.len() {
match strs[i].chars().nth(k) {
Some(ch) if cur_ch == ch => {}
_ => return common,
}
}
common.pu
```
<Overlap Ratio: 0.948051948051948>

---

--- 42 --
Question ID: e6acd81b8f398cb45de21fb4e0325b8f492db280_1
Original Code:
```
fn get_one() {
    consul_put("tower-consul/test-key", "test-value");

    let mut rt = Runtime::new().unwrap();

    let response = rt.block_on(future::lazy(|| {
        let mut client = client(hyper);
        client.get("tower-consul/test-key")
    }));

    let mut values = response.unwrap();
    let value = values.pop().unwrap();
    assert_eq!(value.key, "tower-consul/test-key");

    consul_del("tower-consul/test-key");
}
```


Overlapping Code:
```
ey", "test-value");
let mut rt = Runtime::new().unwrap();
let response = rt.block_on(future::lazy(|| {
let mut client = client(hyper);
client.get("tower-consul/test-key")
}));
let mut values = response.unwrap();
let value = values.pop().unwrap();
assert_eq!(value.key, "tower-consul/test-key");
consu
```
<Overlap Ratio: 0.7915567282321899>

---

--- 43 --
Question ID: 419b76ee1e8daaf42ad8810717a2a1539029d563_0
Original Code:
```
pub fn to_absolute_path(path: &Path) -> io::Result<PathBuf> {
    // IDEA: Provide a flag --real-path for canonicalization of file path?
    //       Match real paths and/or output real paths? (affect --include and --exclude?)
    //       Logical: resolve '..' components before symlinks (Windows)
    //       Physical: resolve symlinks as encountered (Unix)
    // NOTE: A path like /root/../compo is considered an absolute path, seriously.
    //       An absolute path is not always a real path (with symlinks fully resolved).
    if path.is_absolute() {
        Ok(path.to_path_buf())
    } else {
        if *HAS_PWD {
            let path = path.strip_prefix(".").unwrap_or(path);

            Ok((*PWD).join(path))
        } else {
            Err(io::Error::new(
                io::ErrorKind::Other,
                "could not resolve relative path into absolute path",
            ))
        }
    }
}
```


Overlapping Code:
```
 fn to_absolute_path(path: &Path) -> io::Result<PathBuf> {
// IDEA: Provide a flag --real-path for canonicalization of file path?
// Match real paths and/or output real paths? (affect --include and --exclude?)
// Logical: resolve '..' components before symlinks (Windows)
// Physical: resolve symlinks as encountered (Unix)
// NOTE: A path like /root/../compo is considered an absolute path, seriously.
// An absolute path is not always a real path (with symlinks fully resolved).
if path.is_absolute() {
Ok(path.to_path_buf())
} else {
if *HAS_PWD {
let path = path.strip_prefix(".").unwrap_or(path);
Ok((*PWD).join(path))
} else {
Err(io::Error::new(
io::ErrorKind::Other,
"could not resolve relati
```
<Overlap Ratio: 0.9459459459459459>

---

--- 44 --
Question ID: d025ee16b7b0876b786f6337c60abdfc0ac61309_0
Original Code:
```
pub fn send(config: &ServerSettings, message: &String) -> SendResult {
    let mut socket = Socket::new(Protocol::Req).unwrap();
    let mut endpoint = socket.connect(&config.url[..]).unwrap();
    let mut reply = String::new();

    debug!("send.socket.write_all: {}", message);

    socket.write_all(message.as_bytes())
        .map_err(|err| { error!("send.socket.write_all: {}", err); err })
        .and_then(|_| {
            socket.read_to_string(&mut reply)
                .map_err(|err| { error!("send.socket.read_to_string: {}", err); err })
        })
        .map_err(|err| {
            let _ = endpoint.shutdown()
                .map_err(|err| error!("send.endpoint.shutdown: {}", err) );
            err
        })?;

    debug!("send.reply: {}", reply);

    let _ = endpoint.shutdown()
        .map_err(|err| error!("send.endpoint.shutdown: {}", err) );
    return Ok(reply);
}
```


Overlapping Code:
```
 message: &String) -> SendResult {
let mut socket = Socket::new(Protocol::Req).unwrap();
let mut endpoint = socket.connect(&config.url[..]).unwrap();
let mut reply = String::new();
debug!("send.socket.write_all: {}", message);
socket.write_all(message.as_bytes())
.map_err(|err| { error!("send.socket.write_all: {}", err); err })
.and_then(|_| {
socket.read_to_string(&mut reply)
.map_err(|err| { error!("send.socket.read_to_string: {}", err); err })
})
.map_err(|err| {
let _ = endpoint.shutdown()
.map_err(|err| error!("send.endpoint.shutdown: {}", err) );
err
})?;
debug!("send.reply: {}", reply);
let _ = endpoint.shutdown()
.map_err(|err| error!("send.endpoint.shutdown: {}", err) );
return Ok(r
```
<Overlap Ratio: 0.9408602150537635>

---

--- 45 --
Question ID: 159f6eeae51553bfec2097e8b9fa0cb56f76db0e_1
Original Code:
```
fn coords_can_be_subtracted() {
        let left = Coord::new(30, 40);
        let right = Coord::new(10, 20);

        assert_eq!(left - right, Coord::new(20, 20));
    }
```


Overlapping Code:
```
an_be_subtracted() {
let left = Coord::new(30, 40);
let right = Coord::new(10, 20);
assert_eq!(left - right, Coord::new
```
<Overlap Ratio: 0.8380281690140845>

---

--- 46 --
Question ID: f9d636c2729fa87c771437d2527eaa8d7c4f40cf_6
Original Code:
```
fn polygon_with_point_on_interior_ring() {
        let poly = holy_polygon();
        let p = poly.interiors()[0].0[3];
        let should_be = Closest::Intersection(p.into());

        let got = poly.closest_point(&p.into());

        assert_eq!(got, should_be);
    }
```


Overlapping Code:
```
_point_on_interior_ring() {
let poly = holy_polygon();
let p = poly.interiors()[0].0[3];
let should_be = Closest::Intersection(p.into());
let got = poly.closest_point(&p.into());
assert_eq!(got, shoul
```
<Overlap Ratio: 0.8968609865470852>

---

--- 47 --
Question ID: 81db081b951c3b37e1dcc178b4dfa17e5e178be5_3
Original Code:
```
fn clean_release() {
    let p = project()
        .file(
            "Cargo.toml",
            r#"
            [package]
            name = "foo"
            version = "0.0.1"
            authors = []

            [dependencies]
            a = { path = "a" }
        "#,
        )
        .file("src/main.rs", "fn main() {}")
        .file("a/Cargo.toml", &basic_manifest("a", "0.0.1"))
        .file("a/src/lib.rs", "")
        .build();

    p.cargo("build --release").run();

    p.cargo("clean -p foo").run();
    p.cargo("build --release").with_stdout("").run();

    p.cargo("clean -p foo --release").run();
    p.cargo("build --release")
        .with_stderr(
            "\
[COMPILING] foo v0.0.1 ([..])
[FINISHED] release [optimized] target(s) in [..]
",
        )
        .run();

    p.cargo("build").run();

    p.cargo("clean").arg("--release").run();
    assert!(p.build_dir().is_dir());
    assert!(p.build_dir().join("debug").is_dir());
    assert!(!p.build_dir().join("release").is_dir());
}
```


Overlapping Code:
```
e() {
let p = project()
.file(
"Cargo.toml",
r#"
[package]
name = "foo"
version = "0.0.1"
authors = []
[dependencies]
a = { path = "a" }
"#,
)
.file("src/main.rs", "fn main() {}")
.file("a/Cargo.toml", &basic_manifest("a", "0.0.1"))
.file("a/src/lib.rs", "")
.build();
p.cargo("build --release").run();
p.cargo("clean -p foo").run();
p.cargo("build --release").with_stdout("").run();
p.cargo("clean -p foo --release").run();
p.cargo("build --release")
.with_stderr(
"\
[COMPILING] foo v0.0.1 ([..])
[FINISHED] release [optimized] target(s) in [..]
",
)
.run();
p.cargo("build").run();
p.cargo("clean").arg("--release").run();
assert!(p.build_dir().is_dir());
assert!(p.build_dir().join("debug").is_dir());
assert!(!p.build_dir().join("release").is_dir());
}
```
<Overlap Ratio: 0.9805699481865285>

---

--- 48 --
Question ID: 9b4bb4dc17494c29ed047aad5e066b77167628b6_4
Original Code:
```
pub fn end_of_word(buffer: &Buffer, mut point: Point) -> Point {
    // TODO: remove this once the iterator returns char instances.
    let mut iter = decode_utf16(buffer.iter_starting_at_point(point)).map(|c| c.unwrap());
    let skip_alphanumeric = iter.next().map_or(false, |c| c.is_alphanumeric());
    point = right(buffer, point);
    for character in iter {
        if skip_alphanumeric == character.is_alphanumeric() {
            point = right(buffer, point);
        } else {
            break;
        }
    }
    point
}
```


Overlapping Code:
```
ffer: &Buffer, mut point: Point) -> Point {
// TODO: remove this once the iterator returns char instances.
let mut iter = decode_utf16(buffer.iter_starting_at_point(point)).map(|c| c.unwrap());
let skip_alphanumeric = iter.next().map_or(false, |c| c.is_alphanumeric());
point = right(buffer, point);
for character in iter {
if skip_alphanumeric == character.is_alphanumeric() {
point = right(buffer, 
```
<Overlap Ratio: 0.8771929824561403>

---

--- 49 --
Question ID: 203f7b00ab1186a5ef888404f0c41f06f9eeb3d6_14
Original Code:
```
unsafe extern "C" fn xdg_popup_configure(mut data: *mut libc::c_void,
                                         mut xdg_popup: *mut xdg_popup,
                                         mut x: int32_t, mut y: int32_t,
                                         mut width_0: int32_t,
                                         mut height_0: int32_t) {
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Popup configured %dx%d@%d,%d\x00" as *const u8 as
                 *const libc::c_char,
             b"../examples/layer-shell.c\x00" as *const u8 as
                 *const libc::c_char, 181i32, width_0, height_0, x, y);
    popup_width = width_0 as uint32_t;
    popup_height = height_0 as uint32_t;
    if !popup_egl_window.is_null() {
        wl_egl_window_resize(popup_egl_window, width_0, height_0, 0i32, 0i32);
    };
}
```


Overlapping Code:
```
e(mut data: *mut libc::c_void,
mut xdg_popup: *mut xdg_popup,
mut x: int32_t, mut y: int32_t,
mut width_0: int32_t,
mut height_0: int32_t) {
_wlr_log(WLR_DEBUG,
b"[%s:%d] Popup configured %dx%d@%d,%d\x00" as *const u8 as
*const libc::c_char,
b"../examples/layer-shell.c\x00" as *const u8 as
*const libc::c_char, 181i32, width_0, height_0, x, y);
popup_width = width_0 as uint32_t;
popup_height = height_0 as uint32_t;
if !popup_egl_window.is_null() {
wl_egl_window_resize(popup_egl_window, width_0, h
```
<Overlap Ratio: 0.8849557522123894>

---

--- 50 --
Question ID: 8ad2e3b0199c65a92c5747a6718f0d5d37cd4526_1
Original Code:
```
fn load_libraries(ids: &UniqueIdGenerator, lib: &Path) -> Result<im::HashMap<String, Module>> {
    tracing::info!("Reading precompiled module metadata files");
    let mut manifests = im::HashMap::new();
    for lib in fs::read_dir(lib)?.filter_map(Result::ok) {
        let path = lib.path().join("build");
        if !path.is_dir() {
            continue;
        }
        for module in fs::gleam_modules_metadata_paths(path)? {
            let reader = fs::buffered_reader(module)?;
            let module = metadata::ModuleDecoder::new(ids.clone()).read(reader)?;
            let _ = manifests.insert(module.name.join("/"), module);
        }
    }
    Ok(manifests)
}
```


Overlapping Code:
```
load_libraries(ids: &UniqueIdGenerator, lib: &Path) -> Result<im::HashMap<String, Module>> {
tracing::info!("Reading precompiled module metadata files");
let mut manifests = im::HashMap::new();
for lib in fs::read_dir(lib)?.filter_map(Result::ok) {
let path = lib.path().join("build");
if !path.is_dir() {
continue;
}
for module in fs::gleam_modules_metadata_paths(path)? {
let reader = fs::buffered_reader(module)?;
let module = metadata::ModuleDecoder::new(ids.clone()).read(reader)?;
let _ = manifests.insert(module.name.join("/"), module);
}
}
Ok
```
<Overlap Ratio: 0.9717314487632509>

---

--- 51 --
Question ID: 8a352e4719ceb70abd5709261c76807c8aee0b69_20
Original Code:
```
fn test_matrix_sub_move_ref() {
        let (m, n) = (2, 4);
        let a = Matrix::from_vec(vec![40.0, 90.0, 50.0, 100.0, 50.0, 120.0, 60.0, 130.0], m, n);
        let b = Matrix::from_vec(vec![38.0, 83.0, 44.0, 98.0, 50.0, 113.0, 56.0, 128.0], m, n);

        let out = a - &b;

        let out_data = out.data();
        assert_eq!(*out_data.values(), vec![2.0, 7.0, 6.0, 2.0, 0.0, 7.0, 4.0, 2.0]);
    }
```


Overlapping Code:
```
ref() {
let (m, n) = (2, 4);
let a = Matrix::from_vec(vec![40.0, 90.0, 50.0, 100.0, 50.0, 120.0, 60.0, 130.0], m, n);
let b = Matrix::from_vec(vec![38.0, 83.0, 44.0, 98.0, 50.0, 113.0, 56.0, 128.0], m, n);
let out = a - &b;
let out_data = out.data();
assert_eq!(*out_data.values(), vec![2.0, 7.0, 6.0, 2.0, 0.0, 7.0, 4.0, 2.
```
<Overlap Ratio: 0.9152542372881356>

---

--- 52 --
Question ID: 470b6e8f11f1eb1b64b8a5753f071a6be0cc57b7_2
Original Code:
```
pub unsafe fn list_node_at(l: *const list, mut index: libc::c_uint) -> *mut node {
    /* if there's no data in the list, fail */
    if (*l).list.is_null() {
        return 0 as *mut node;
    } else {
        let mut current: *mut node = (*l).list;
        while index > 0i32 as libc::c_uint {
            if (*current).next.is_null() {
                return 0 as *mut node;
            } else {
                current = (*current).next;
                index = index.wrapping_sub(1)
            }
        }
        return current;
    };
}
```


Overlapping Code:
```
list, mut index: libc::c_uint) -> *mut node {
/* if there's no data in the list, fail */
if (*l).list.is_null() {
return 0 as *mut node;
} else {
let mut current: *mut node = (*l).list;
while index > 0i32 as libc::c_uint {
if (*current).next.is_null() {
return 0 as *mut node;
} else {
current = (*current).next;
index = index.wrapping_sub(1)
}
}
ret
```
<Overlap Ratio: 0.8663366336633663>

---

--- 53 --
Question ID: c385df2d912b71e555df414919d72c181b8dfd50_12
Original Code:
```
unsafe extern "C" fn frame_handle_copy_with_damage(mut wl_client:
                                                       *mut wl_client,
                                                   mut frame_resource:
                                                       *mut wl_resource,
                                                   mut buffer_resource:
                                                       *mut wl_resource) {
    let mut frame: *mut wlr_screencopy_frame_v1 =
        frame_from_resource(frame_resource);
    if frame.is_null() { return }
    (*frame).with_damage = 1i32 != 0;
    frame_handle_copy(wl_client, frame_resource, buffer_resource);
}
```


Overlapping Code:
```
_copy_with_damage(mut wl_client:
*mut wl_client,
mut frame_resource:
*mut wl_resource,
mut buffer_resource:
*mut wl_resource) {
let mut frame: *mut wlr_screencopy_frame_v1 =
frame_from_resource(frame_resource);
if frame.is_null() { return }
(*frame).with_damage = 1i32 != 0;
frame_handle_copy(wl_client, frame_resource, buf
```
<Overlap Ratio: 0.8682795698924731>

---

--- 54 --
Question ID: 42a292c6fe6822a497a65fcea755d5270bfc7dbc_17
Original Code:
```
fn multiword_to_multiword_synonyms() {
        let mut store = TempDatabase::from_iter(vec![
            ("NY", &[doc_char_index(0, 0, 0)][..]),
            ("subway", &[doc_char_index(0, 1, 1)][..]),
            ("NYC", &[doc_char_index(1, 0, 0)][..]),
            ("blue", &[doc_char_index(1, 1, 1)][..]),
            ("subway", &[doc_char_index(1, 2, 2)][..]),
            ("broken", &[doc_char_index(1, 3, 3)][..]),
            ("new", &[doc_char_index(2, 0, 0)][..]),
            ("york", &[doc_char_index(2, 1, 1)][..]),
            ("underground", &[doc_char_index(2, 2, 2)][..]),
            ("train", &[doc_char_index(2, 3, 3)][..]),
            ("broken", &[doc_char_index(2, 4, 4)][..]),
        ]);

        store.add_synonym(
            "new york",
            SetBuf::from_dirty(vec!["NYC", "NY", "new york city"]),
        );
        store.add_synonym(
            "new york city",
            SetBuf::from_dirty(vec!["NYC", "NY", "new york"]),
        );
        store.add_synonym("underground train", SetBuf::from_dirty(vec!["subway"]));

        let env = &store.database.env;
        let reader = env.read_txn().unwrap();

        let builder = store.query_builder();
        let results = builder
            .query(&reader, "new york underground train broken", 0..20)
            .unwrap();
        let mut iter = results.into_iter();

        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {
            let mut matches = matches.into_iter();
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // city
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken
            assert_matches!(matches.next(), None);
        });
        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {
            let mut iter = matches.into_iter();
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NYC = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NYC = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NYC = city
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true,  .. })); // subway = underground
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true,  .. })); // subway = train
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true,  .. })); // broken
            assert_matches!(iter.next(), None);
        });
        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {
            let mut iter = matches.into_iter();
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train
            assert_matches!(iter.next(), None);
        });
        assert_matches!(iter.next(), None);

        let builder = store.query_builder();
        let results = builder
            .query(&reader, "new york city underground train broken", 0..20)
            .unwrap();
        let mut iter = results.into_iter();

        assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {
            let mut matches = matches.into_iter();
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // new
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // york
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: false, .. })); // city
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // underground
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // train
            assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true,  .. })); // broken
            assert_matches!(matches.next(), None);
        });
        assert_matches!(iter.next(), Some(Document { id: DocumentId(1), matches, .. }) => {
            let mut iter = matches.into_iter();
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // NYC = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // NYC = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true, .. })); // NYC = city
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 4, is_exact: true, .. })); // subway = underground
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 5, is_exact: true, .. })); // subway = train
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 5, word_index: 6, is_exact: true, .. })); // broken
            assert_matches!(iter.next(), None);
        });
        assert_matches!(iter.next(), Some(Document { id: DocumentId(0), matches, .. }) => {
            let mut iter = matches.into_iter();
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true,  .. })); // NY = new
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true,  .. })); // NY = york
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true,  .. })); // NY = city
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true,  .. })); // subway = underground
            assert_matches!(iter.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true,  .. })); // subway = train
            assert_matches!(iter.next(), None);
        });
        assert_matches!(iter.next(), None);
    }
```


Overlapping Code:
```
iword_to_multiword_synonyms() {
let mut store = TempDatabase::from_iter(vec![
("NY", &[doc_char_index(0, 0, 0)][..]),
("subway", &[doc_char_index(0, 1, 1)][..]),
("NYC", &[doc_char_index(1, 0, 0)][..]),
("blue", &[doc_char_index(1, 1, 1)][..]),
("subway", &[doc_char_index(1, 2, 2)][..]),
("broken", &[doc_char_index(1, 3, 3)][..]),
("new", &[doc_char_index(2, 0, 0)][..]),
("york", &[doc_char_index(2, 1, 1)][..]),
("underground", &[doc_char_index(2, 2, 2)][..]),
("train", &[doc_char_index(2, 3, 3)][..]),
("broken", &[doc_char_index(2, 4, 4)][..]),
]);
store.add_synonym(
"new york",
SetBuf::from_dirty(vec!["NYC", "NY", "new york city"]),
);
store.add_synonym(
"new york city",
SetBuf::from_dirty(vec!["NYC", "NY", "new york"]),
);
store.add_synonym("underground train", SetBuf::from_dirty(vec!["subway"]));
let env = &store.database.env;
let reader = env.read_txn().unwrap();
let builder = store.query_builder();
let results = builder
.query(&reader, "new york underground train broken", 0..20)
.unwrap();
let mut iter = results.into_iter();
assert_matches!(iter.next(), Some(Document { id: DocumentId(2), matches, .. }) => {
let mut matches = matches.into_iter();
assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: false, .. })); // new
assert_matches!(matches.next(), Some(TmpMatch { query_index: 0, word_index: 0, is_exact: true, .. })); // new
assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: false, .. })); // york
assert_matches!(matches.next(), Some(TmpMatch { query_index: 1, word_index: 1, is_exact: true, .. })); // york
assert_matches!(matches.next(), Some(TmpMatch { query_index: 2, word_index: 2, is_exact: true, .. })); // city
assert_matches!(matches.next(), Some(TmpMatch { query_index: 3, word_index: 3, is_exact: true, .. })); // underground
assert_matches!(matches.next(), Some(TmpMatch { query_index: 4, word_index: 4, is_exact: true, .. })); // train
assert_matches!(matches.next(), Some(TmpMatch { query_index: 5, word_index: 5, is_exact: true, .. })); // b
```
<Overlap Ratio: 0.994693680656054>

---

--- 55 --
Question ID: 299aaaf5554c5d755825149a0e5f45c45387e24f_16
Original Code:
```
fn test_align_baseline_multiline_column() {
	let mut root = Node::new();

	style!(root,
		AlignItems(Align::Baseline),
		FlexWrap(Wrap::Wrap),
		Width(100 pt),
		Height(100 pt)
	);

	let mut root_child_0 = Node::new();

	style!(root_child_0,
		Width(50 pt),
		Height(50 pt)
	);

	let mut root_child_1 = Node::new();

	style!(root_child_1,
		Width(30 pt),
		Height(50 pt)
	);

	let mut root_child_1_child_0 = Node::new();

	style!(root_child_1_child_0,
		Width(20 pt),
		Height(20 pt)
	);

	let mut root_child_2 = Node::new();

	style!(root_child_2,
		Width(40 pt),
		Height(70 pt)
	);

	let mut root_child_2_child_0 = Node::new();

	style!(root_child_2_child_0,
		Width(10 pt),
		Height(10 pt)
	);

	let mut root_child_3 = Node::new();

	style!(root_child_3,
		Width(50 pt),
		Height(20 pt)
	);

	root.insert_child(&mut root_child_0, 0);
	root.insert_child(&mut root_child_1, 1);
	root.insert_child(&mut root_child_2, 2);
	root.insert_child(&mut root_child_3, 3);

	root_child_1.insert_child(&mut root_child_1_child_0, 0);
	root_child_2.insert_child(&mut root_child_2_child_0, 0);
	root.calculate_layout(Undefined, Undefined, Direction::LTR);

	let root_layout = root.get_layout();
	let child_0_layout = root_child_0.get_layout();
	let child_1_layout = root_child_1.get_layout();
	let child_1_child_0_layout = root_child_1_child_0.get_layout();
	let child_2_layout = root_child_2.get_layout();
	let child_2_child_0_layout = root_child_2_child_0.get_layout();
	let child_3_layout = root_child_3.get_layout();

	assert_eq!(0.0, root_layout.left());
	assert_eq!(0.0, root_layout.top());
	assert_eq!(100.0, root_layout.width());
	assert_eq!(100.0, root_layout.height());

	assert_eq!(0.0, child_0_layout.left());
	assert_eq!(0.0, child_0_layout.top());
	assert_eq!(50.0, child_0_layout.width());
	assert_eq!(50.0, child_0_layout.height());

	assert_eq!(0.0, child_1_layout.left());
	assert_eq!(50.0, child_1_layout.top());
	assert_eq!(30.0, child_1_layout.width());
	assert_eq!(50.0, child_1_layout.height());

	assert_eq!(0.0, child_1_child_0_layout.left());
	assert_eq!(0.0, child_1_child_0_layout.top());
	assert_eq!(20.0, child_1_child_0_layout.width());
	assert_eq!(20.0, child_1_child_0_layout.height());

	assert_eq!(50.0, child_2_layout.left());
	assert_eq!(0.0, child_2_layout.top());
	assert_eq!(40.0, child_2_layout.width());
	assert_eq!(70.0, child_2_layout.height());

	assert_eq!(0.0, child_2_child_0_layout.left());
	assert_eq!(0.0, child_2_child_0_layout.top());
	assert_eq!(10.0, child_2_child_0_layout.width());
	assert_eq!(10.0, child_2_child_0_layout.height());

	assert_eq!(50.0, child_3_layout.left());
	assert_eq!(70.0, child_3_layout.top());
	assert_eq!(50.0, child_3_layout.width());
	assert_eq!(20.0, child_3_layout.height());

	root.calculate_layout(Undefined, Undefined, Direction::RTL);

	let root_layout = root.get_layout();
	let child_0_layout = root_child_0.get_layout();
	let child_1_layout = root_child_1.get_layout();
	let child_1_child_0_layout = root_child_1_child_0.get_layout();
	let child_2_layout = root_child_2.get_layout();
	let child_2_child_0_layout = root_child_2_child_0.get_layout();
	let child_3_layout = root_child_3.get_layout();

	assert_eq!(0.0, root_layout.left());
	assert_eq!(0.0, root_layout.top());
	assert_eq!(100.0, root_layout.width());
	assert_eq!(100.0, root_layout.height());

	assert_eq!(50.0, child_0_layout.left());
	assert_eq!(0.0, child_0_layout.top());
	assert_eq!(50.0, child_0_layout.width());
	assert_eq!(50.0, child_0_layout.height());

	assert_eq!(70.0, child_1_layout.left());
	assert_eq!(50.0, child_1_layout.top());
	assert_eq!(30.0, child_1_layout.width());
	assert_eq!(50.0, child_1_layout.height());

	assert_eq!(10.0, child_1_child_0_layout.left());
	assert_eq!(0.0, child_1_child_0_layout.top());
	assert_eq!(20.0, child_1_child_0_layout.width());
	assert_eq!(20.0, child_1_child_0_layout.height());

	assert_eq!(10.0, child_2_layout.left());
	assert_eq!(0.0, child_2_layout.top());
	assert_eq!(40.0, child_2_layout.width());
	assert_eq!(70.0, child_2_layout.height());

	assert_eq!(30.0, child_2_child_0_layout.left());
	assert_eq!(0.0, child_2_child_0_layout.top());
	assert_eq!(10.0, child_2_child_0_layout.width());
	assert_eq!(10.0, child_2_child_0_layout.height());

	assert_eq!(0.0, child_3_layout.left());
	assert_eq!(70.0, child_3_layout.top());
	assert_eq!(50.0, child_3_layout.width());
	assert_eq!(20.0, child_3_layout.height());
}
```


Overlapping Code:
```
fn test_align_baseline_multiline_column() {
let mut root = Node::new();
style!(root,
AlignItems(Align::Baseline),
FlexWrap(Wrap::Wrap),
Width(100 pt),
Height(100 pt)
);
let mut root_child_0 = Node::new();
style!(root_child_0,
Width(50 pt),
Height(50 pt)
);
let mut root_child_1 = Node::new();
style!(root_child_1,
Width(30 pt),
Height(50 pt)
);
let mut root_child_1_child_0 = Node::new();
style!(root_child_1_child_0,
Width(20 pt),
Height(20 pt)
);
let mut root_child_2 = Node::new();
style!(root_child_2,
Width(40 pt),
Height(70 pt)
);
let mut root_child_2_child_0 = Node::new();
style!(root_child_2_child_0,
Width(10 pt),
Height(10 pt)
);
let mut root_child_3 = Node::new();
style!(root_child_3,
Width(50 pt),
Height(20 pt)
);
root.insert_child(&mut root_child_0, 0);
root.insert_child(&mut root_child_1, 1);
root.insert_child(&mut root_child_2, 2);
root.insert_child(&mut root_child_3, 3);
root_child_1.insert_child(&mut root_child_1_child_0, 0);
root_child_2.insert_child(&mut root_child_2_child_0, 0);
root.calculate_layout(Undefined, Undefined, Direction::LTR);
let root_layout = root.get_layout();
let child_0_layout = root_child_0.get_layout();
let child_1_layout = root_child_1.get_layout();
let child_1_child_0_layout = root_child_1_child_0.get_layout();
let child_2_layout = root_child_2.get_layout();
let child_2_child_0_layout = root_child_2_child_0.get_layout();
let child_3_layout = root_child_3.get_layout();
assert_eq!(0.0, root_layout.left());
assert_eq!(0.0, root_layout.top());
assert_eq!(100.0, root_layout.width());
assert_eq!(100.0, root_layout.height());
assert_eq!(0.0, child_0_layout.left());
assert_eq!(0.0, child_0_layout.top());
assert_eq!(50.0, child_0_layout.width());
assert_eq!(50.0, child_0_layout.height());
assert_eq!(0.0, child_1_layout.left());
assert_eq!(50.0, child_1_layout.top());
assert_eq!(30.0, child_1_layout.width());
assert_eq!(50.0, child_1_layout.height());
assert_eq!(0.0, child_1_child_0_layout.left());
assert_eq!(0.0, child_1_child_0_layout.top());
assert_eq!(20.0, child_1_child_0_layout.width());
assert_eq!(20.0, child_1_child_0_layout.height());
assert_eq!(50.0, child_2_layout.left());
assert_eq!(0.0, child_2_layout.top());
assert_eq!(40.0, child_2_layout.width());
assert_eq!(70.0, child_2_layout.height());
assert_eq!(0.0, child_2_child_0_layout.left());
assert_eq!(0.0, child_2_child_0_layout.top());
assert_eq
```
<Overlap Ratio: 0.9941348973607038>

---

--- 56 --
Question ID: eef249cf3016daced42d7e087b6e3db5dc2eb890_3
Original Code:
```
fn test_lookup_index_not_exists_array() {
        let _ = env_logger::builder().is_test(true).try_init();

        let sample = array![array!["test"]];

        let found = lookup::<_, _, DefaultTokenizer>(&sample, "[1]");

        assert!(found.is_err());

        assert_eq!(found, Err(Error::IndexNotExist(1)),);
    }
```


Overlapping Code:
```
ray() {
let _ = env_logger::builder().is_test(true).try_init();
let sample = array![array!["test"]];
let found = lookup::<_, _, DefaultTokenizer>(&sample, "[1]");
assert!(found.is_err());
assert_eq!(f
```
<Overlap Ratio: 0.7326007326007326>

---

--- 57 --
Question ID: 2f0568a61430a64d4bc63607fb7e8905f9750296_0
Original Code:
```
pub fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {
    // Load config
    let config = Config::load()?;
    let user_name = config.user.name;
    let user_email = match config.user.email {
        Some(email) => email,
        None => String::new(),
    };

    // Return an error in case of an empty configuration
    match &user_name {
        Some(name) if name != &String::new() => (),
        _ => return Err(Box::new(ConfigError::MissingAuthor(user_email))),
    }

    // Create tree object
    let repo_path = utils::find_repo()?;
    let index = Index::load(&repo_path);
    let tree = Tree::from(&index);

    // Save tree
    tree.save(&repo_path);

    // Get head commit (parent)
    let mut parent = vec![];
    if let Some(commit) = refs::get_head(&repo_path) {
        parent.push(commit);
    }

    // Nothing to commit
    if (parent.is_empty() && tree.entries.is_empty())
        || (!parent.is_empty() && tree.hash() == parent[0].hash())
    {
        return Err(Box::new(NothingToCommit {}));
    }

    // Create commit object
    let message = String::from(args.value_of("msg").unwrap());
    let commit = Commit::create(&tree, parent, user_name.unwrap(), user_email, message);

    // Save commit object
    commit.save(&repo_path);

    // Update HEAD
    refs::update(
        &repo_path,
        &String::from("HEAD"),
        &commit.hash().to_string(),
        true,
    )
    .expect("fatal: error while updating HEAD ref");

    Ok(())
}
```


Overlapping Code:
```
pub fn run(args: &ArgMatches) -> Result<(), Box<dyn Error>> {
// Load config
let config = Config::load()?;
let user_name = config.user.name;
let user_email = match config.user.email {
Some(email) => email,
None => String::new(),
};
// Return an error in case of an empty configuration
match &user_name {
Some(name) if name != &String::new() => (),
_ => return Err(Box::new(ConfigError::MissingAuthor(user_email))),
}
// Create tree object
let repo_path = utils::find_repo()?;
let index = Index::load(&repo_path);
let tree = Tree::from(&index);
// Save tree
tree.save(&repo_path);
// Get head commit (parent)
let mut parent = vec![];
if let Some(commit) = refs::get_head(&repo_path) {
parent.push(commit);
}
// Nothing to commit
if (parent.is_empty() && tree.entries.is_empty())
|| (!parent.is_empty() && tree.hash() == parent[0].hash())
{
return Err(Box::new(NothingToCommit {}));
}
// Create commit object
let message = String::from(args.value_of("msg").unwrap());
let commit = Commit::create(&tree, parent, user_name.unwrap(), user_email, message);
// Save commit object
commit.save(&repo_path);
// Update HEAD
refs::update(
&repo_path,
&String::from("HEAD"),
&commit.hash().to_string(),
true,
)
.expect("fatal: error while updating HEAD 
```
<Overlap Ratio: 0.9880478087649402>

---

--- 58 --
Question ID: 1d7205e2c4cf31cc23d270feb49066850ba1639e_0
Original Code:
```
fn crypto_encrypt_decypt_success() {
    // arrange
    let crypto = Crypto::new().unwrap();

    let client_id = b"module1";
    let plaintext = b"plaintext";
    let iv = b"initialization vector";

    match crypto.create_key() {
        Ok(_result) => assert!(true),
        Err(_) => panic!("Create master key function returned error"),
    };

    //act
    let ciphertext = match crypto.encrypt(client_id, plaintext, iv) {
        //assert
        Ok(result) => result,
        Err(_) => panic!("Encrypt function returned error"),
    };
    assert_ne!(ciphertext.as_ref().len(), 0);

    //act
    let plaintext_result = match crypto.decrypt(client_id, ciphertext.as_ref(), iv) {
        //assert
        Ok(result) => result,
        Err(_) => panic!("Decrypt function returned error"),
    };
    assert_eq!(
        plaintext,
        plaintext_result.as_ref(),
        "Failure plaintext after decrypt did not match {:?} and {:?}",
        plaintext,
        plaintext_result.as_ref()
    );

    let bad_client_id = b"module2";
    match crypto.decrypt(bad_client_id, ciphertext.as_ref(), iv) {
        //assert
        Ok(_result) => panic!("Decrypt function returned unexpected success"),
        Err(_) => (),
    };

    let bad_iv = b"inconsistent_iv";
    match crypto.decrypt(client_id, ciphertext.as_ref(), bad_iv) {
        //assert
        Ok(_result) => panic!("Decrypt function returned unexpected success"),
        Err(_) => (),
    };

    // cleanup
    match crypto.destroy_key() {
        Ok(_result) => assert!(true),
        Err(_) => panic!("Destroy master key function returned error"),
    };
}
```


Overlapping Code:
```
 crypto_encrypt_decypt_success() {
// arrange
let crypto = Crypto::new().unwrap();
let client_id = b"module1";
let plaintext = b"plaintext";
let iv = b"initialization vector";
match crypto.create_key() {
Ok(_result) => assert!(true),
Err(_) => panic!("Create master key function returned error"),
};
//act
let ciphertext = match crypto.encrypt(client_id, plaintext, iv) {
//assert
Ok(result) => result,
Err(_) => panic!("Encrypt function returned error"),
};
assert_ne!(ciphertext.as_ref().len(), 0);
//act
let plaintext_result = match crypto.decrypt(client_id, ciphertext.as_ref(), iv) {
//assert
Ok(result) => result,
Err(_) => panic!("Decrypt function returned error"),
};
assert_eq!(
plaintext,
plaintext_result.as_ref(),
"Failure plaintext after decrypt did not match {:?} and {:?}",
plaintext,
plaintext_result.as_ref()
);
let bad_client_id = b"module2";
match crypto.decrypt(bad_client_id, ciphertext.as_ref(), iv) {
//assert
Ok(_result) => panic!("Decrypt function returned unexpected success"),
Err(_) => (),
};
let bad_iv = b"inconsistent_iv";
match crypto.decrypt(client_id, ciphertext.as_ref(), bad_iv) {
//assert
Ok(_result) => panic!("Decrypt function returned unexpected success"),
Err(_) => (),
};
// cleanup
match crypto.destroy_key() {
Ok(_result) => assert!(true),
Err(_) => panic!("Destroy master key function returned error"),
};
```
<Overlap Ratio: 0.9970457902511078>

---

--- 59 --
Question ID: 429e3dd3fff57432aa820a7f0c39f4fccdc9df52_0
Original Code:
```
fn find_chapter(rc: &mut RenderContext, target: Target) -> Result<Option<StringMap>, RenderError> {
    debug!("Get data from context");

    let chapters = rc.evaluate_absolute("chapters", true).and_then(|c| {
        serde_json::value::from_value::<Vec<StringMap>>(c.clone())
            .map_err(|_| RenderError::new("Could not decode the JSON data"))
    })?;

    let base_path = rc.evaluate_absolute("path", true)?
        .as_str()
        .ok_or_else(|| RenderError::new("Type error for `path`, string expected"))?
        .replace("\"", "");

    let mut previous: Option<StringMap> = None;

    debug!("Search for chapter");

    for item in chapters {
        match item.get("path") {
            Some(path) if !path.is_empty() => {
                if let Some(previous) = previous {
                    if let Some(item) = target.find(&base_path, &path, &item, &previous)? {
                        return Ok(Some(item));
                    }
                }

                previous = Some(item.clone());
            }
            _ => continue,
        }
    }

    Ok(None)
}
```


Overlapping Code:
```
get: Target) -> Result<Option<StringMap>, RenderError> {
debug!("Get data from context");
let chapters = rc.evaluate_absolute("chapters", true).and_then(|c| {
serde_json::value::from_value::<Vec<StringMap>>(c.clone())
.map_err(|_| RenderError::new("Could not decode the JSON data"))
})?;
let base_path = rc.evaluate_absolute("path", true)?
.as_str()
.ok_or_else(|| RenderError::new("Type error for `path`, string expected"))?
.replace("\"", "");
let mut previous: Option<StringMap> = None;
debug!("Search for chapter");
for item in chapters {
match item.get("path") {
Some(path) if !path.is_empty() => {
if let Some(previous) = previous {
if let Some(item) = target.find(&base_path, &path, &item, &previous)? {
return Ok(Some(item));
}
}
previous = Some(item.clone());
}
_ => continue,
}
}
Ok(None)
}
```
<Overlap Ratio: 0.9489916963226572>

---

--- 60 --
Question ID: 5c830e32a8a58663d500f834aa864852764f4773_0
Original Code:
```
fn convert_duration_to_string() {
        assert_eq!(duration_to_string(Duration::milliseconds(1002)), "0:0:1.2");
        assert_eq!(
            duration_to_string(Duration::milliseconds(65125)),
            "0:1:5.125"
        );
        assert_eq!(
            duration_to_string(Duration::milliseconds(6065125)),
            "1:41:5.125"
        );
        assert_eq!(duration_to_string(Duration::seconds(128)), "0:2:8.0");
    }
```


Overlapping Code:
```
convert_duration_to_string() {
assert_eq!(duration_to_string(Duration::milliseconds(1002)), "0:0:1.2");
assert_eq!(
duration_to_string(Duration::milliseconds(65125)),
"0:1:5.125"
);
assert_eq!(
duration_to_string(Duration::milliseconds(6065125)),
"1:41:5.125"
);
assert_eq!(duration_to_string(Duratio
```
<Overlap Ratio: 0.8982035928143712>

---

--- 61 --
Question ID: 8adbe438799bd65136cc48972950cd5e0682d8cb_0
Original Code:
```
pub extern "C" fn say_something(some_string: *const u8, some_len: usize) -> sgx_status_t {
    let person_slice = unsafe { slice::from_raw_parts(some_string, some_len) };

    let the_one: person::Person = person::Person::decode(person_slice).unwrap();
    println!("name: {}, id: 0x{:08X}, email at: {}",
        the_one.name,
        the_one.id,
        the_one.email);
    println!("{:?}", the_one);

    let ts = Timestamp { seconds: 0x1234, nanos: 0x5678 };
    println!("well known types ts = {:?}", ts);

    sgx_status_t::SGX_SUCCESS
}
```


Overlapping Code:
```
pub extern "C" fn say_something(some_string: *const u8, some_len: usize) -> sgx_status_t {
let person_slice = unsafe { slice::from_raw_parts(some_string, some_len) };
let the_one: person::Person = person::Person::decode(person_slice).unwrap();
println!("name: {}, id: 0x{:08X}, email at: {}",
the_one.name,
the_one.id,
the_one.email);
println!("{:?}", the_one);
let ts = Timestamp { seconds: 0x1234, nanos: 0x5678 };
println!("well known types ts = {:?}"
```
<Overlap Ratio: 0.930327868852459>

---

--- 62 --
Question ID: 42b615fb9dd49aedd97eda953019ec7cea74fcaf_4
Original Code:
```
fn returns_no_objects_when_empty() {
        let world = box WorldMock::new();
        let simulation = SimulationImpl::new(
            world,
            box world_interactor_factory_fn,
            box instant_wrapper_factory_fn,
        );
        let objects = simulation.objects();
        assert!(objects.is_empty())
    }
```


Overlapping Code:
```
ns_no_objects_when_empty() {
let world = box WorldMock::new();
let simulation = SimulationImpl::new(
world,
box world_interactor_factory_fn,
box instant_wrapper_factory_fn,
);
let objects = simulation
```
<Overlap Ratio: 0.8032128514056225>

---

--- 63 --
Question ID: 0dca4d208f861c5e801ff9730ecd5939ebe89970_1
Original Code:
```
fn json_ser_simple(b: &mut Bencher) {
    let value = value();
    let mut vec = Vec::with_capacity(512);
    b.iter(|| {
        let _ = serde_json::to_writer(&mut vec, &value).unwrap();
        vec.clear();
    });
}
```


Overlapping Code:
```
simple(b: &mut Bencher) {
let value = value();
let mut vec = Vec::with_capacity(512);
b.iter(|| {
let _ = serde_json::to_writer(&mut vec, &value).unwrap();
vec.clear();
})
```
<Overlap Ratio: 0.9193548387096774>

---

--- 64 --
Question ID: 8651fa15c5ba0e6ed940a1ff083ebee8c3933ded_0
Original Code:
```
pub fn derive_actor( input: TokenStream ) -> TokenStream
{
	let input = parse_macro_input!( input as DeriveInput );
	let name  = input.ident;

	let ( impl_generics, ty_generics, where_clause ) = input.generics.split_for_impl();

	// The generated impl.
	//
	let expanded = quote!
	{
		impl #impl_generics thespis::Actor for #name #ty_generics #where_clause
		{}
	};

	TokenStream::from( expanded )
}
```


Overlapping Code:
```
-> TokenStream
{
let input = parse_macro_input!( input as DeriveInput );
let name = input.ident;
let ( impl_generics, ty_generics, where_clause ) = input.generics.split_for_impl();
// The generated impl.
//
let expanded = quote!
{
impl #impl_generics thespis::Actor for #name #ty_generics #where_clause
{}
}
```
<Overlap Ratio: 0.8036649214659686>

---

--- 65 --
Question ID: 03e02fe4f4effa796beac6e1a84112d19c5bf2eb_3
Original Code:
```
fn cg() -> Result<(), io::Error> {
    let pids: &Path = Path::new("/sys/fs/cgroup/pids");
    match fs::create_dir(pids.join("myuser")) {
        _ => (),
    };

    fs::write(pids.join("myuser/pids.max"), b"20").unwrap();
    fs::write(pids.join("myuser/notify_on_release"), b"1").unwrap();
    fs::write(
        pids.join("myuser/cgroup.procs"),
        format!("{}", nix::unistd::getpid().as_raw()),
    )
    .unwrap();

    Ok(())
}
```


Overlapping Code:
```
 cg() -> Result<(), io::Error> {
let pids: &Path = Path::new("/sys/fs/cgroup/pids");
match fs::create_dir(pids.join("myuser")) {
_ => (),
};
fs::write(pids.join("myuser/pids.max"), b"20").unwrap();
fs::write(pids.join("myuser/notify_on_release"), b"1").unwrap();
fs::write(
pids.join("myuser/cgroup.procs"),
format!("{}", nix::unistd::getpid().as_raw
```
<Overlap Ratio: 0.9259259259259259>

---

--- 66 --
Question ID: dab278eed03fd4d3bf6464ee142402771532d99d_7
Original Code:
```
fn check_export_rsa_public_possible() -> Result<()> {
    // Exporting a public key is always permitted
    let mut client = TestClient::new();
    let key_name = auto_test_keyname!();
    if !client.is_operation_supported(Opcode::PsaExportPublicKey) {
        return Ok(());
    }
    let mut usage_flags: UsageFlags = Default::default();
    let _ = usage_flags.set_sign_hash();
    let key_attributes = Attributes {
        lifetime: Lifetime::Persistent,
        key_type: Type::RsaKeyPair,
        bits: 1024,
        policy: Policy {
            usage_flags,
            permitted_algorithms: Algorithm::AsymmetricSignature(
                AsymmetricSignature::RsaPkcs1v15Sign {
                    hash_alg: Hash::Sha256.into(),
                },
            ),
        },
    };

    client.generate_key(key_name.clone(), key_attributes)?;

    let _public_key = client.export_public_key(key_name)?;

    Ok(())
}
```


Overlapping Code:
```
Result<()> {
// Exporting a public key is always permitted
let mut client = TestClient::new();
let key_name = auto_test_keyname!();
if !client.is_operation_supported(Opcode::PsaExportPublicKey) {
return Ok(());
}
let mut usage_flags: UsageFlags = Default::default();
let _ = usage_flags.set_sign_hash();
let key_attributes = Attributes {
lifetime: Lifetime::Persistent,
key_type: Type::RsaKeyPair,
bits: 1024,
policy: Policy {
usage_flags,
permitted_algorithms: Algorithm::AsymmetricSignature(
AsymmetricSignature::RsaPkcs1v15Sign {
hash_alg: Hash::Sha256.into(),
},
),
},
};
client.generate_key(key_name.clone(), key_attributes)?;
let _public_key = client.export_public_key(key_nam
```
<Overlap Ratio: 0.9266304347826086>

---

--- 67 --
Question ID: 8d5fbe44f15a13bf82e8b3d2c7dd5a9f213e3057_7
Original Code:
```
fn get_nugetpkg_version<P: AsRef<Path>>(nuget_path: P) -> String {
    let version_path = {
        let mut version_path = nuget_path.as_ref().to_owned();
        version_path.push("VERSION");
        version_path
    };
    let mut version_file = File::open(version_path)
                                .expect("Failed to open VERSION file");

    let mut version_string = String::new();
    version_file.read_to_string(&mut version_string).unwrap();

    version_string
}
```


Overlapping Code:
```
get_path: P) -> String {
let version_path = {
let mut version_path = nuget_path.as_ref().to_owned();
version_path.push("VERSION");
version_path
};
let mut version_file = File::open(version_path)
.expect("Failed to open VERSION file");
let mut version_string = String::new();
version_file.read_to_string(&mut version_string).unwrap();
version_string
}
```
<Overlap Ratio: 0.8928571428571429>

---

--- 68 --
Question ID: 34214f6c591acc69b39dc0fa34b94a0a45b7d374_16
Original Code:
```
fn kill_timeout_but_kill_not_set() {
        let args = vec![
            String::from("g-cli"),
            String::from("--kill-timeout"),
            String::from("5000"),
            String::from("test.vi"),
            String::from("--"),
            String::from("test1"),
        ];

        let config = Configuration::from_arg_array(args);
        assert_eq!(None, config.kill);
    }
```


Overlapping Code:
```
ut_but_kill_not_set() {
let args = vec![
String::from("g-cli"),
String::from("--kill-timeout"),
String::from("5000"),
String::from("test.vi"),
String::from("--"),
String::from("test1"),
];
let config = Configuration::from_arg_array(args);
assert_eq!(None, config.kill);

```
<Overlap Ratio: 0.9507042253521126>

---

--- 69 --
Question ID: f25a31a02a812d218db611088e5f74d52eeb1e1c_4
Original Code:
```
pub fn list_transactions(
    conn: r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>,
) -> Result<Vec<Transaction>> {
    let mut stmt = conn.prepare("SELECT id, date, name from Transactions ORDER BY date DESC")?;

    let transactions = stmt
        .query_map(NO_PARAMS, |row| {
            Ok(Transaction {
                id: row.get(0).unwrap(),
                date: row.get(1).unwrap(),
                name: row.get(2).unwrap(),
            })
        })
        .and_then(|mapped_rows| {
            Ok(mapped_rows
                .map(|row| row.unwrap())
                .collect::<Vec<Transaction>>())
        })?;

    Ok(transactions)
}
```


Overlapping Code:
```
(
conn: r2d2::PooledConnection<r2d2_sqlite::SqliteConnectionManager>,
) -> Result<Vec<Transaction>> {
let mut stmt = conn.prepare("SELECT id, date, name from Transactions ORDER BY date DESC")?;
let transactions = stmt
.query_map(NO_PARAMS, |row| {
Ok(Transaction {
id: row.get(0).unwrap(),
date: row.get(1).unwrap(),
name: row.get(2).unwrap(),
})
})
.and_then(|mapped_rows| {
Ok(mapped_rows
.map(|row| row.unwrap())
.collect::<Vec<Transaction>>())
})?;
Ok(transaction
```
<Overlap Ratio: 0.9434343434343434>

---

--- 70 --
Question ID: a96f2f01ce9ebf99caf325adfa022f5e02585d21_0
Original Code:
```
fn bytes_and_ints() {
        let mut c = Composer::new(ComposeMode::Unlimited, false);
        c.compose_bytes(b"foo").unwrap();
        c.compose_u8(0x07).unwrap();
        c.compose_u16(0x1234).unwrap();
        c.compose_u32(0xdeadbeef).unwrap();
        assert_eq!(c.finish(),
                   b"foo\x07\x12\x34\xde\xad\xbe\xef");
    }
```


Overlapping Code:
```
ytes_and_ints() {
let mut c = Composer::new(ComposeMode::Unlimited, false);
c.compose_bytes(b"foo").unwrap();
c.compose_u8(0x07).unwrap();
c.compose_u16(0x1234).unwrap();
c.compose_u32(0xdeadbeef).unwrap();
assert_eq!(c.finish(),
b"foo\x07\x12\x34\xd
```
<Overlap Ratio: 0.9191176470588235>

---

--- 71 --
Question ID: 2eaf2c14dfb2018537ae64b44361084e80ffd3ca_0
Original Code:
```
fn rpc_find_where_spent(client: &mut Client, outpoint: &OutPoint) -> Result<Transaction, jsonrpc::Error> {
    let request = client
        .build_request("getbestblockhash".to_string(), vec![]);

    let mut block_hash = String::from("");

    client.send_request(&request).and_then(|res| {
        block_hash = String::from(res.result.unwrap().string().unwrap());

        Ok(())
    });

    let mut tx: Option<Transaction> = None;

    while tx.is_none() {
        let request = client
            .build_request("getblock".to_string(), vec![Json::from_serialize(block_hash.to_string()).unwrap(), Json::from_serialize(0).unwrap()]);

        client.send_request(&request).and_then(|res| {
            let block: Result<Block, bitcoin::network::serialize::Error> = bitcoin::network::serialize::deserialize(&mut hex_to_bytes(String::from(res.result.unwrap().string().unwrap())));
            let block = block.unwrap();

            for this_tx in &block.txdata {
                for vin in &this_tx.input {
                    if vin.previous_output == *outpoint {
                        tx = Some(this_tx.clone());

                        break;
                    }
                }

                if tx.is_some() {
                    break;
                }
            }

            block_hash = block.header.prev_blockhash.to_string();

            Ok(())
        });
    }

    Ok(tx.unwrap())
}
```


Overlapping Code:
```
ind_where_spent(client: &mut Client, outpoint: &OutPoint) -> Result<Transaction, jsonrpc::Error> {
let request = client
.build_request("getbestblockhash".to_string(), vec![]);
let mut block_hash = String::from("");
client.send_request(&request).and_then(|res| {
block_hash = String::from(res.result.unwrap().string().unwrap());
Ok(())
});
let mut tx: Option<Transaction> = None;
while tx.is_none() {
let request = client
.build_request("getblock".to_string(), vec![Json::from_serialize(block_hash.to_string()).unwrap(), Json::from_serialize(0).unwrap()]);
client.send_request(&request).and_then(|res| {
let block: Result<Block, bitcoin::network::serialize::Error> = bitcoin::network::serialize::deserialize(&mut hex_to_bytes(String::from(res.result.unwrap().string().unwrap())));
let block = block.unwrap();
for this_tx in &block.txdata {
for vin in &this_tx.input {
if vin.previous_output == *outpoint {
tx = Some(this_tx.clone());
break;
}
}
if tx.is_some() {
break;
}
}
block_hash = block.header.prev_blockhash.to_string();
Ok(())
});
}
Ok(tx.unwr
```
<Overlap Ratio: 0.9859154929577465>

---

--- 72 --
Question ID: 55fd51ac5eb0db8c567c311373a2941b8af58c04_7
Original Code:
```
pub fn cross_word<T>(first: T, second: T, bit_index: u8) -> (T, T) 
    where T: PrimInt + FromPrimitive + ToPrimitive {
    let bit_mask = T::from_u32(2_u32.pow(bit_index.to_u32().unwrap()) - 1).unwrap();

    let first_result  = (first  & !bit_mask) | (second & bit_mask);
    let second_result = (second & !bit_mask) | (first  & bit_mask);

    (first_result, second_result)
}
```


Overlapping Code:
```
bit_index: u8) -> (T, T) 
where T: PrimInt + FromPrimitive + ToPrimitive {
let bit_mask = T::from_u32(2_u32.pow(bit_index.to_u32().unwrap()) - 1).unwrap();
let first_result = (first & !bit_mask) | (second & bit_mask);
let second_result = (second & !bit_mask) | (first & bit_mask);
(first_result, seco
```
<Overlap Ratio: 0.847457627118644>

---

--- 73 --
Question ID: a28196ca355d1ed4bddbae5254b02a442b8003f0_0
Original Code:
```
pub fn daily_temperatures(t: Vec<i32>) -> Vec<i32> {
    let mut stack: Vec<usize> = vec![];
    let mut res = vec![];
    res.resize(t.len(), 0);

    let mut count = 0;
    for i in 0..t.len() {
        while !stack.is_empty() && t[stack[stack.len() - 1]] < t[i] {
            let cur = stack.pop().unwrap();
            let days = count - cur;
            res[cur] = days as i32;
        }
        stack.push(count);
        count += 1;
    }
    res
}
```


Overlapping Code:
```
pub fn daily_temperatures(t: Vec<i32>) -> Vec<i32> {
let mut stack: Vec<usize> = vec![];
let mut res = vec![];
res.resize(t.len(), 0);
let mut count = 0;
for i in 0..t.len() {
while !stack.is_empty() && t[stack[stack.len() - 1]] < t[i] {
let cur = stack.pop().unwrap();
let days = count - cur;
res[cur] = days as i32;
}
stack.pus
```
<Overlap Ratio: 0.9189944134078212>

---

--- 74 --
Question ID: 5331daaaa8930389c7c3e413b08b8033ddef4674_0
Original Code:
```
pub fn parse_opts() -> Result<CliStatus, Error> {
    let opt = Opt::from_args();
    log::debug!("Cli opts are: {:?}", opt);

    match opt.cmd {
        Command::Generate => {
            generate_empty_config().context("Failed to generate config")?;
            log::info!("config.yml generated");
            Ok(CliStatus::Exit)
        }
        Command::Run {
            config,
            twil_sid,
            twil_token,
            twil_from,
        } => {
            if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {
                bail!("TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from");
            }
            let twil_sid = twil_sid.unwrap();
            let twil_token = twil_token.unwrap();
            let twil_from = twil_from.unwrap();

            let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)
                .context("Failed to get config")?;

            Ok(CliStatus::Continue(app_config))
        }
    }
}
```


Overlapping Code:
```
ts() -> Result<CliStatus, Error> {
let opt = Opt::from_args();
log::debug!("Cli opts are: {:?}", opt);
match opt.cmd {
Command::Generate => {
generate_empty_config().context("Failed to generate config")?;
log::info!("config.yml generated");
Ok(CliStatus::Exit)
}
Command::Run {
config,
twil_sid,
twil_token,
twil_from,
} => {
if twil_sid.is_none() || twil_token.is_none() || twil_from.is_none() {
bail!("TWIL_ACCOUNT_SID, TWIL_AUTH_TOKEN & TWIL_FROM env variables must be set, or passed via --twil-sid, --twil-token & --twil-from");
}
let twil_sid = twil_sid.unwrap();
let twil_token = twil_token.unwrap();
let twil_from = twil_from.unwrap();
let app_config = AppConfig::new(config, twil_sid, twil_token, twil_from)
.context("Failed to get config")?;
```
<Overlap Ratio: 0.929368029739777>

---

--- 75 --
Question ID: 75df2846d4cbf5d8886a55eb69ef935f8b37a1d1_2
Original Code:
```
pub fn wif_compressed(priv_key: &SecretKey) -> WIFCompressed {
    let decoded = base16::decode(priv_key.to_string().as_bytes()).unwrap();
    let mut wc = Vec::with_capacity(decoded.len()+1);
    wc.extend_from_slice(&decoded);
    wc.push(constants::BITCOIN_WIF_COMPRESSED_SUFFIX);
    encode_base58_check(constants::BITCOIN_PRIVATE_KEY_WIF_VERSION_PREFIX, &wc)
}
```


Overlapping Code:
```
FCompressed {
let decoded = base16::decode(priv_key.to_string().as_bytes()).unwrap();
let mut wc = Vec::with_capacity(decoded.len()+1);
wc.extend_from_slice(&decoded);
wc.push(constants::BITCOIN_WIF_COMPRESSED_SUFFIX);
encode_base58_check(constants::BITCOIN_PRIVATE_KEY_WIF_VERSIO
```
<Overlap Ratio: 0.8115942028985508>

---

--- 76 --
Question ID: a94f445f7cafef35db84cf97b3855cc7ca506211_6
Original Code:
```
pub fn next_input(player: &PlayerState, bot: &mut BotState) -> rlbot::ControllerState {
    if let Some(ref plan) = bot.plan {
        // we need to take into account the inputs previously sent that will be processed
        // prior to finding where we are. instead of passing the current player, apply
        // LAG_FRAMES inputs that are not yet applied
        let player = player.lag_compensated_player(&bot.controller_history, LAG_FRAMES);
        let index = closest_plan_index(&player, &plan);

        // we need to look one past closest index to see the controller to reach next position
        if index < plan.len() - 1 {
            let current_heading = player.rotation.to_rotation_matrix() * Vector3::new(-1.0, 0.0, 0.0);
            let (closest_player, _, _) = &plan[index];
            let (_next_player, controller, _) = &plan[index + 1];
            //println!("index: {}, controller.steer: {:?}", index, controller.steer);

            // FIXME we should account for differences in the tick and interpolate between the two
            // closest indices to get the real closet delta/distance
            let closest_delta = player.position - closest_player.position;
            let closest_distance = closest_delta.norm();
            let clockwise_90_rotation = Rotation3::from_euler_angles(0.0, 0.0, PI / 2.0);
            let relative_right = clockwise_90_rotation * current_heading;

            if closest_distance == 0.0 {
                bot.turn_errors.push_back(0.0);
            } else {
                // NOTE positive for right, negative for left
                let projection = na::Matrix::dot(&Unit::new_normalize(closest_delta).into_inner(), &relative_right);
                //println!("projection: {}, distance: {}", projection, closest_distance);
                let error = projection * closest_distance;
                bot.turn_errors.push_back(error);
            }

            if bot.turn_errors.len() > 1000 {
                // keep last 100
                bot.turn_errors = bot.turn_errors.split_off(900);
            }

            //println!("controller: {:?}", controller);
            let mut input = controller.into();
            //println!("input before: {:?}", input);
            pd_adjust(&mut input, &bot.turn_errors);
            //println!("input after: {:?}", input);

            return input;
        }
    }

    // fallback
    let mut input = rlbot::ControllerState::default();
    input.throttle = 1.0;
    if player.position.z > 150.0 && (player.position.z as i32 % 2) == 0 {
        input.jump = true;
    }
    input
}
```


Overlapping Code:
```
e, bot: &mut BotState) -> rlbot::ControllerState {
if let Some(ref plan) = bot.plan {
// we need to take into account the inputs previously sent that will be processed
// prior to finding where we are. instead of passing the current player, apply
// LAG_FRAMES inputs that are not yet applied
let player = player.lag_compensated_player(&bot.controller_history, LAG_FRAMES);
let index = closest_plan_index(&player, &plan);
// we need to look one past closest index to see the controller to reach next position
if index < plan.len() - 1 {
let current_heading = player.rotation.to_rotation_matrix() * Vector3::new(-1.0, 0.0, 0.0);
let (closest_player, _, _) = &plan[index];
let (_next_player, controller, _) = &plan[index + 1];
//println!("index: {}, controller.steer: {:?}", index, controller.steer);
// FIXME we should account for differences in the tick and interpolate between the two
// closest indices to get the real closet delta/distance
let closest_delta = player.position - closest_player.position;
let closest_distance = closest_delta.norm();
let clockwise_90_rotation = Rotation3::from_euler_angles(0.0, 0.0, PI / 2.0);
let relative_right = clockwise_90_rotation * current_heading;
if closest_distance == 0.0 {
bot.turn_errors.push_back(0.0);
} else {
// NOTE positive for right, negative for left
let projection = na::Matrix::dot(&Unit::new_normalize(closest_delta).into_inner(), &relative_right);
//println!("projection: {}, distance: {}", projection, closest_distance);
let error = projection * closest_distance;
bot.turn_errors.push_back(error);
}
if bot.turn_errors.len() > 1000 {
// keep last 100
bot.turn_errors = bot.turn_errors.split_off(900);
}
//println!("controller: {:?}", controller);
let mut input = controller.into();
//println!("input before: {:?}", input);
pd_adjust(&mut input, &bot.turn_errors);
//println!("input after: {:?}", input);
return input;
}
}
// fallback
let mut input = rlbot::ControllerState::default();
inpu
```
<Overlap Ratio: 0.9634387351778656>

---

--- 77 --
Question ID: d9abf304aa292dad0efdb6ed6c7088f9d9f6a173_0
Original Code:
```
fn create(
    name: &str,
    config: &types::SubscriptionCreateConfig,
    reg: &SharedRegistry,
    cfg: &Config,
) -> Option<HttpResponse> {
    let ack_deadline = config
        .ack_deadline
        .map(|ack_deadline| Duration::seconds(i64::from(ack_deadline)))
        .unwrap_or(cfg.default_ack_deadline);
    let ttl = config
        .ttl
        .map(|ttl| Duration::seconds(i64::from(ttl)))
        .unwrap_or(cfg.default_subscription_ttl);
    let subscribe = reg.create_subscription(
        &name,
        &config.topic,
        ack_deadline,
        ttl,
        config.historical.unwrap_or(false),
    );
    subscribe.map(|(created, subscription)| {
        let mut response = if created {
            HttpResponse::Created()
        } else {
            HttpResponse::Conflict()
        };
        response.json(subscription)
    })
}
```


Overlapping Code:
```
n create(
name: &str,
config: &types::SubscriptionCreateConfig,
reg: &SharedRegistry,
cfg: &Config,
) -> Option<HttpResponse> {
let ack_deadline = config
.ack_deadline
.map(|ack_deadline| Duration::seconds(i64::from(ack_deadline)))
.unwrap_or(cfg.default_ack_deadline);
let ttl = config
.ttl
.map(|ttl| Duration::seconds(i64::from(ttl)))
.unwrap_or(cfg.default_subscription_ttl);
let subscribe = reg.create_subscription(
&name,
&config.topic,
ack_deadline,
ttl,
config.historical.unwrap_or(false),
);
subscribe.map(|(created, subscription)| {
let mut response = if created {
HttpResponse::Created()
} else {
HttpResponse::Conflict()
};
response.json(
```
<Overlap Ratio: 0.9715994020926756>

---

--- 78 --
Question ID: cd2364b37d17ebebef7c057656e96f18c3f124f2_0
Original Code:
```
pub fn platform() -> String {
	let env = Target::env();
	let env_dash = if env.is_empty() { "" } else { "-" };
	format!("{}-{}{}{}", Target::arch(), Target::os(), env_dash, env)
}
```


Overlapping Code:
```
et env = Target::env();
let env_dash = if env.is_empty() { "" } else { "-" };
format!("{}-{}{}{}", T
```
<Overlap Ratio: 0.5681818181818182>

---

--- 79 --
Question ID: de2771d85d0cf9d825f9f0e2a9a64fd516f14db0_4
Original Code:
```
fn block_results() {
        let response =
            endpoint::block_results::Response::from_string(&read_json_fixture("block_results"))
                .unwrap();
        assert_eq!(response.height.value(), 1814);

        let validator_updates = response.validator_updates;
        let deliver_tx = response.txs_results.unwrap();
        let log_json = &deliver_tx[0].log.parse_json().unwrap();
        let log_json_value = &log_json.as_array().as_ref().unwrap()[0];

        assert_eq!(log_json_value["msg_index"].as_str().unwrap(), "0");
        assert_eq!(log_json_value["success"].as_bool().unwrap(), true);

        assert_eq!(deliver_tx[0].gas_wanted.value(), 200_000);
        assert_eq!(deliver_tx[0].gas_used.value(), 105_662);

        assert_eq!(validator_updates[0].power.value(), 1_233_243);
    }
```


Overlapping Code:
```
 block_results() {
let response =
endpoint::block_results::Response::from_string(&read_json_fixture("block_results"))
.unwrap();
assert_eq!(response.height.value(), 1814);
let validator_updates = response.validator_updates;
let deliver_tx = response.txs_results.unwrap();
let log_json = &deliver_tx[0].log.parse_json().unwrap();
let log_json_value = &log_json.as_array().as_ref().unwrap()[0];
assert_eq!(log_json_value["msg_index"].as_str().unwrap(), "0");
assert_eq!(log_json_value["success"].as_bool().unwrap(), true);
assert_eq!(deliver_tx[0].gas_wanted.value(), 200_000);
assert_eq!(deliver_tx[0].gas_used.value(), 105_662);
assert_eq!(validator_updates[0].power.value(), 1
```
<Overlap Ratio: 0.9797395079594791>

---

--- 80 --
Question ID: 8a18ef3dfa3e641a7a4affec16f2333c7cb41eaa_15
Original Code:
```
fn assign(
    context: &mut Context,
    result: &mut Block,
    sp!(loc, ta_): T::Assign,
    rvalue_ty: &H::SingleType,
) -> ReachableResult<(H::LValue, Block)> {
    use H::{LValue_ as L, UnannotatedExp_ as E};
    use T::Assign_ as A;
    let mut after = Block::new();
    let l_ = match ta_ {
        A::Ignore => L::Ignore,
        A::Var(v, st) => L::Var(
            context.remapped_local(v),
            Box::new(single_type(context, st)),
        ),
        A::Unpack(_m, s, tbs, tfields) => {
            let bs = base_types(context, tbs);

            let mut fields = vec![];
            for (decl_idx, f, bt, tfa) in assign_fields(context, &s, tfields) {
                assert!(fields.len() == decl_idx);
                let st = &H::SingleType_::base(bt);
                let (fa, mut fafter) = match assign(context, result, tfa, st) {
                    Unreachable { report, loc } => return Unreachable { report, loc },
                    Reachable(res) => res,
                };
                after.append(&mut fafter);
                fields.push((f, fa))
            }
            L::Unpack(s, bs, fields)
        }
        A::BorrowUnpack(mut_, _m, s, _tss, tfields) => {
            let tmp = context.new_temp(loc, rvalue_ty.clone());
            let copy_tmp = || {
                let copy_tmp_ = E::Copy {
                    from_user: false,
                    var: tmp.clone(),
                };
                H::exp(H::Type_::single(rvalue_ty.clone()), sp(loc, copy_tmp_))
            };
            let fields = assign_fields(context, &s, tfields).into_iter().enumerate();
            for (idx, (decl_idx, f, bt, tfa)) in fields {
                assert!(idx == decl_idx);
                let floc = tfa.loc;
                let borrow_ = E::Borrow(mut_, Box::new(copy_tmp()), f);
                let borrow = H::exp(H::Type_::base(bt), sp(floc, borrow_));
                match assign_command(context, &mut after, floc, sp(floc, vec![tfa]), borrow) {
                    Unreachable { report, loc } => return Unreachable { report, loc },
                    Reachable(()) => (),
                };
            }
            L::Var(tmp, Box::new(rvalue_ty.clone()))
        }
    };
    Reachable((sp(loc, l_), after))
}
```


Overlapping Code:
```
n assign(
context: &mut Context,
result: &mut Block,
sp!(loc, ta_): T::Assign,
rvalue_ty: &H::SingleType,
) -> ReachableResult<(H::LValue, Block)> {
use H::{LValue_ as L, UnannotatedExp_ as E};
use T::Assign_ as A;
let mut after = Block::new();
let l_ = match ta_ {
A::Ignore => L::Ignore,
A::Var(v, st) => L::Var(
context.remapped_local(v),
Box::new(single_type(context, st)),
),
A::Unpack(_m, s, tbs, tfields) => {
let bs = base_types(context, tbs);
let mut fields = vec![];
for (decl_idx, f, bt, tfa) in assign_fields(context, &s, tfields) {
assert!(fields.len() == decl_idx);
let st = &H::SingleType_::base(bt);
let (fa, mut fafter) = match assign(context, result, tfa, st) {
Unreachable { report, loc } => return Unreachable { report, loc },
Reachable(res) => res,
};
after.append(&mut fafter);
fields.push((f, fa))
}
L::Unpack(s, bs, fields)
}
A::BorrowUnpack(mut_, _m, s, _tss, tfields) => {
let tmp = context.new_temp(loc, rvalue_ty.clone());
let copy_tmp = || {
let copy_tmp_ = E::Copy {
from_user: false,
var: tmp.clone(),
};
H::exp(H::Type_::single(rvalue_ty.clone()), sp(loc, copy_tmp_))
};
let fields = assign_fields(context, &s, tfields).into_iter().enumerate();
for (idx, (decl_idx, f, bt, tfa)) in fields {
assert!(idx == decl_idx);
let floc = tfa.loc;
let borrow_ = E::Borrow(mut_, Box::new(copy_tmp()), f);
let borrow = H::exp(H::Type_::base(bt), sp(floc, borrow_));
match assign_command(context, &mut after, floc, sp(floc, vec![tfa]), borrow) {
Unreachable { report, loc } => return Unreachable { report, loc },
Reachable(()) => (),
};
}
L::Var(tmp, Box::new(rvalue_ty.clone()))
}
};
Reachable((sp(lo
```
<Overlap Ratio: 0.9890042761148442>

---

--- 81 --
Question ID: f703fe03c06d740e5e4f8540ea77fb01065cea1e_0
Original Code:
```
fn no_sensors() {
            let mut status = api::Status {
                sensors: None,
                ..api::Status::default()
            };
            assert_eq!(status.state, None);
            StateFromPeopleNowPresent.modify(&mut status);
            assert_eq!(status.sensors, None);
            assert_eq!(status.state, None);
        }
```


Overlapping Code:
```
 {
let mut status = api::Status {
sensors: None,
..api::Status::default()
};
assert_eq!(status.state, None);
StateFromPeopleNowPresent.modify(&mut status);
assert_eq!(status.sensors, None);
assert_eq!
```
<Overlap Ratio: 0.8403361344537815>

---

--- 82 --
Question ID: 8dccec5f395287c0afb837916967123e68a704f1_2
Original Code:
```
fn greet(_: &Request, res: Response<Fresh>, cap: Captures) {
    let mut r = res.start().unwrap();
    r.write_all(format!("Hello, {}", cap.at(1).unwrap()).as_bytes()).unwrap();
    r.end().unwrap();
}
```


Overlapping Code:
```
sh>, cap: Captures) {
let mut r = res.start().unwrap();
r.write_all(format!("Hello, {}", cap.at(1).unwrap()).as_bytes()).unwrap();
r.end().unwrap();
}
```
<Overlap Ratio: 0.7936507936507936>

---

--- 83 --
Question ID: d2f10e3d823b71a17fb7e7635542991e2937228f_2
Original Code:
```
fn test_has_permission_b_has_a() {
        let context = MockTransactionContext::default();
        let pc = PermissionChecker::new(&context);

        let builder = AgentBuilder::new();
        let agent = builder
            .with_org_id(ORG_ID.to_string())
            .with_public_key(PUBLIC_KEY.to_string())
            .with_active(true)
            .with_roles(vec![ROLE_A.to_string()])
            .build()
            .unwrap();
        let builder = AgentListBuilder::new();
        let agent_list = builder.with_agents(vec![agent.clone()]).build().unwrap();
        let agent_bytes = agent_list.into_bytes().unwrap();
        let agent_address = compute_agent_address(PUBLIC_KEY);
        context.set_state_entry(agent_address, agent_bytes).unwrap();

        let result = pc.has_permission(PUBLIC_KEY, ROLE_B, ORG_ID).unwrap();
        assert!(!result);
    }
```


Overlapping Code:
```
test_has_permission_b_has_a() {
let context = MockTransactionContext::default();
let pc = PermissionChecker::new(&context);
let builder = AgentBuilder::new();
let agent = builder
.with_org_id(ORG_ID.to_string())
.with_public_key(PUBLIC_KEY.to_string())
.with_active(true)
.with_roles(vec![ROLE_A.to_string()])
.build()
.unwrap();
let builder = AgentListBuilder::new();
let agent_list = builder.with_agents(vec![agent.clone()]).build().unwrap();
let agent_bytes = agent_list.into_bytes().unwrap();
let agent_address = compute_agent_address(PUBLIC_KEY);
context.set_state_entry(agent_address, agent_bytes).unwrap();
let result = pc.has_permission(PUBLIC_KEY, ROLE_B, ORG_ID).unwrap();
assert!(!result);
```
<Overlap Ratio: 0.9929078014184397>

---

--- 84 --
Question ID: 886a46a37b7cc405bae5161208a7c872eb3648c9_2
Original Code:
```
pub fn tests() {
    use crate::input::test_part_one;

    let example = "5764801\n17807724";
    test_part_one!(example => 14_897_079);
    let real_input = include_str!("day25_input.txt");
    test_part_one!(real_input => 18_862_163);
}
```


Overlapping Code:
```
() {
use crate::input::test_part_one;
let example = "5764801\n17807724";
test_part_one!(example => 14_897_079);
let real_input = include_str!("day25_input.txt");
test_part_one!(real_input => 18_862_16
```
<Overlap Ratio: 0.9216589861751152>

---

--- 85 --
Question ID: e9bdfb8b405be3498686f9dabb15f50e1ef6e656_21
Original Code:
```
fn test_move_c_e() {
        let mut cpu: CPU = CPU::new();

        cpu = cpu.set_c(Register { value: 0 });
        cpu = cpu.set_e(Register { value: 10 });

        cpu = execute_move(cpu, 0b010, 0b100);

        assert_eq!(cpu.pc.value, 0);
        assert_eq!(cpu.f.value, 0);
        assert_eq!(cpu.c.value, 10);
    }
```


Overlapping Code:
```
fn test_move_c_e() {
let mut cpu: CPU = CPU::new();
cpu = cpu.set_c(Register { value: 0 });
cpu = cpu.set_e(Register { value: 10 });
cpu = execute_move(cpu, 0b010, 0b100);
assert_eq!(cpu.pc.value, 0);
assert_eq!(cpu.f.value, 0);
assert_eq!(cpu.c.value, 1
```
<Overlap Ratio: 0.9806949806949807>

---

--- 86 --
Question ID: 887725c01c78a4d7a28c624bd2bc986b7a9779ce_0
Original Code:
```
fn fails_on_duplicate_http_incoming_auth() {
    let mut account = ACCOUNT_DETAILS_2.clone();
    account.http_incoming_token = Some("incoming_auth_token".to_string());
    let result = block_on(test_store().and_then(|(store, context)| {
        store.insert_account(account).then(move |result| {
            let _ = context;
            result
        })
    }));
    assert!(result.is_err());
}
```


Overlapping Code:
```
_http_incoming_auth() {
let mut account = ACCOUNT_DETAILS_2.clone();
account.http_incoming_token = Some("incoming_auth_token".to_string());
let result = block_on(test_store().and_then(|(store, context)| {
store.insert_account(account).then(move |result| {
let _ = context;
result
})
}));
assert!(result.is_err());
}
```
<Overlap Ratio: 0.9375>

---

--- 87 --
Question ID: e62d4bad820b2b50b02221c0ab525295304277f4_4
Original Code:
```
fn test_parse_float() {
    test_text_format_str_descriptor("float_singular: 98.5", TestTypes::descriptor_static());
    test_text_format_str_descriptor("float_singular: -99.5", TestTypes::descriptor_static());
    test_text_format_str_descriptor("float_singular: -99", TestTypes::descriptor_static());
    test_text_format_str_descriptor("double_singular: 98.5", TestTypes::descriptor_static());
    test_text_format_str_descriptor("double_singular: -99.5", TestTypes::descriptor_static());
    test_text_format_str_descriptor("double_singular: 99", TestTypes::descriptor_static());
}
```


Overlapping Code:
```
_float() {
test_text_format_str_descriptor("float_singular: 98.5", TestTypes::descriptor_static());
test_text_format_str_descriptor("float_singular: -99.5", TestTypes::descriptor_static());
test_text_format_str_descriptor("float_singular: -99", TestTypes::descriptor_static());
test_text_format_str_descriptor("double_singular: 98.5", TestTypes::descriptor_static());
test_text_format_str_descriptor("double_singular: -99.5", TestTypes::descriptor_static());
test_text_format_str_descriptor("double_singular: 99", TestTypes::
```
<Overlap Ratio: 0.9358288770053476>

---

--- 88 --
Question ID: b966e8b98bd995dd5d1a2e68088c7ca3c17c9057_0
Original Code:
```
fn bool_succeeds() {
    // word format
    assert_eq!(fm::<bool>(quote!(ignore)), true);

    // bool literal
    assert_eq!(fm::<bool>(quote!(ignore = true)), true);
    assert_eq!(fm::<bool>(quote!(ignore = false)), false);

    // string literals
    assert_eq!(fm::<bool>(quote!(ignore = "true")), true);
    assert_eq!(fm::<bool>(quote!(ignore = "false")), false);
  }
```


Overlapping Code:
```
l_succeeds() {
// word format
assert_eq!(fm::<bool>(quote!(ignore)), true);
// bool literal
assert_eq!(fm::<bool>(quote!(ignore = true)), true);
assert_eq!(fm::<bool>(quote!(ignore = false)), false);
// string literals
assert_eq!(fm::<bool>(quote!(ignore = "true")), true);
assert_eq!(fm::<bool>(quote!(ignore 
```
<Overlap Ratio: 0.9171597633136095>

---

--- 89 --
Question ID: 9cc9e61b1b2da25cbe78ae25641c848b7e3bd037_6
Original Code:
```
fn logout(client: &mut Client) -> Result<(), Error> {
    println!("Logging out...");

    let logout_res = match client.logout() {
        Ok(t) => t,
        Err(e) => {
            let msg = format!("Failed to run logout: {}", e);
            return Err(Error::Custom(msg));
        }
    };

    if logout_res.is_not_success() {
        let msg = format!("Failed to logout: {}", logout_res.data["message"]);
        return Err(Error::Custom(msg));
    }

    Ok(())
}
```


Overlapping Code:
```
ent: &mut Client) -> Result<(), Error> {
println!("Logging out...");
let logout_res = match client.logout() {
Ok(t) => t,
Err(e) => {
let msg = format!("Failed to run logout: {}", e);
return Err(Error::Custom(msg));
}
};
if logout_res.is_not_success() {
let msg = format!("Failed to logout: {}", logout_res.data["message"]);
return Err(Error::Custom(msg));
}
Ok(())
}
```
<Overlap Ratio: 0.9657894736842105>

---

--- 90 --
Question ID: b475cda86e32301d7feb341ce14e8004c9914740_0
Original Code:
```
fn init_logger(matches: &ArgMatches) {
    let pkg_name = str::replace(env!("CARGO_PKG_NAME"), "-", "_");
    let prog_name = str::replace(progname().as_str(), "-", "_");
    let log_lv = if matches.is_present("quiet") {
        "off".to_owned()
    } else {
        match matches.occurrences_of("verbose") {
            0 => "error".to_owned(),
            1 => format!("error,{}=warn,{}=warn", pkg_name, prog_name),
            2 => format!("error,{}=info,{}=info", pkg_name, prog_name),
            3 => format!("error,{}=debug,{}=debug", pkg_name, prog_name),
            4 => format!("error,{}=trace,{}=trace", pkg_name, prog_name),
            5 => format!("warn,{}=trace,{}=trace", pkg_name, prog_name),
            6 => format!("info,{}=trace,{}=trace", pkg_name, prog_name),
            7 => format!("debug,{}=trace,{}=trace", pkg_name, prog_name),
            _ => "trace".to_owned(),
        }
    };
    env::set_var(LOG_LEVEL_ENV, log_lv.as_str());
    pretty_env_logger::try_init_timed_custom_env(LOG_LEVEL_ENV).unwrap();
}
```


Overlapping Code:
```
_logger(matches: &ArgMatches) {
let pkg_name = str::replace(env!("CARGO_PKG_NAME"), "-", "_");
let prog_name = str::replace(progname().as_str(), "-", "_");
let log_lv = if matches.is_present("quiet") {
"off".to_owned()
} else {
match matches.occurrences_of("verbose") {
0 => "error".to_owned(),
1 => format!("error,{}=warn,{}=warn", pkg_name, prog_name),
2 => format!("error,{}=info,{}=info", pkg_name, prog_name),
3 => format!("error,{}=debug,{}=debug", pkg_name, prog_name),
4 => format!("error,{}=trace,{}=trace", pkg_name, prog_name),
5 => format!("warn,{}=trace,{}=trace", pkg_name, prog_name),
6 => format!("info,{}=trace,{}=trace", pkg_name, prog_name),
7 => format!("debug,{}=trace,{}=trace", pkg_name, prog_name),
_ => "trace".to_owned(),
}
};
env::set_var(LOG_LEVEL_ENV, log_lv.as_str());
pretty_env_logger::try_init_timed_custom_env(LOG_LE
```
<Overlap Ratio: 0.9692132269099202>

---

--- 91 --
Question ID: 927c269aa7f041cc059ea7bae05a9da3f8a70ad7_0
Original Code:
```
fn test_eval_int(){
        use std::fs;
        let unparsed_query = fs::read_to_string("tests/data/qfuflia.smt2").expect("cannot read file");
        let mut query = Query::new();
        query.parse_query(&unparsed_query).expect("cannot parse file");
        
        let unparsed_answer = fs::read_to_string("tests/data/qfuflia_result.smt2").expect("cannot read file");
        let s = query.parse_answer(&unparsed_answer).expect("cannot parse file");
        assert!(query.eval(&s).unwrap());
    }
```


Overlapping Code:
```
int(){
use std::fs;
let unparsed_query = fs::read_to_string("tests/data/qfuflia.smt2").expect("cannot read file");
let mut query = Query::new();
query.parse_query(&unparsed_query).expect("cannot parse file");

let unparsed_answer = fs::read_to_string("tests/data/qfuflia_result.smt2").expect("cannot read file");
let s = query.parse_answer(&unparsed_answer).expect("cannot parse file");
assert!(query.eval(&s).unwrap());
}
```
<Overlap Ratio: 0.9701149425287356>

---

--- 92 --
Question ID: f1d785e6ae0e8d707e6d028b013b1a892468d352_12
Original Code:
```
fn test_writer_bookmark_position_zero_two() {
    SETUP_WRITER!(
        "=== hello
=== world",
        reader,
        writer
    );

    assert_eq!(writer.index, 0);

    assert_eq!(writer.symbols["hello"], 0);
    assert_eq!(writer.symbols["world"], 0);
}
```


Overlapping Code:
```
 test_writer_bookmark_position_zero_two() {
SETUP_WRITER!(
"=== hello
=== world",
reader,
writer
);
assert_eq!(writer.index, 0);
assert_eq!(writer.symbols["hello"], 0);
assert_eq!(writer.symbols["worl
```
<Overlap Ratio: 0.9433962264150944>

---

--- 93 --
Question ID: c9b0c98eaee246e494403e5118411b99fae85574_6
Original Code:
```
fn run() -> std::result::Result<(), Box<dyn std::error::Error>> {
    let mut manager = dbus_bluez::BluezManager::new()?;
    let cmd_opts = CmdOpts::from_args();

    manager.start_discovery(Some(4000))?;

    match cmd_opts.cmd {
        cmd_opts::Command::Scan { duration_sec } => scan(&mut manager, &cmd_opts, duration_sec)?,
        cmd_opts::Command::Read { ref addr } => read(&mut manager, &cmd_opts, addr)?,
        cmd_opts::Command::Blink { ref addr } => blink(&mut manager, &cmd_opts, addr)?,
        cmd_opts::Command::History { ref addr, from, to, page, clear } => history(&mut manager, &cmd_opts, addr, from, to, page, clear)?,
        cmd_opts::Command::HistoryCount { ref addr } => history_count(&mut manager, &cmd_opts, addr)?,
        cmd_opts::Command::HistoryClear { ref addr } => clear_history(&mut manager, &cmd_opts, addr)?,
    }

    Ok(())
}
```


Overlapping Code:
```
n() -> std::result::Result<(), Box<dyn std::error::Error>> {
let mut manager = dbus_bluez::BluezManager::new()?;
let cmd_opts = CmdOpts::from_args();
manager.start_discovery(Some(4000))?;
match cmd_opts.cmd {
cmd_opts::Command::Scan { duration_sec } => scan(&mut manager, &cmd_opts, duration_sec)?,
cmd_opts::Command::Read { ref addr } => read(&mut manager, &cmd_opts, addr)?,
cmd_opts::Command::Blink { ref addr } => blink(&mut manager, &cmd_opts, addr)?,
cmd_opts::Command::History { ref addr, from, to, page, clear } => history(&mut manager, &cmd_opts, addr, from, to, page, clear)?,
cmd_opts::Command::HistoryCount { ref addr } => history_count(&mut manager, &cmd_opts, addr)?,
cmd_opts::Command::HistoryClear { ref addr } => clear_histo
```
<Overlap Ratio: 0.9356060606060606>

---

--- 94 --
Question ID: fe10072128c762a21040b34bde45feaa361b5dbc_4
Original Code:
```
fn unbalanced_at(graph: &Graph<Node, ()>, node: NodeIndex) -> Option<(NodeIndex, usize)> {
    let mut dfs = Dfs::new(&graph, node);
    while let Some(nx) = dfs.next(&graph) {
        let mut expected_weight = None;
        for neighbor in graph.neighbors_directed(nx, Outgoing) {
            let neighbor_weight = weight_for_node(&graph, neighbor);
            if expected_weight.is_none() {
                expected_weight = Some(neighbor_weight);
            }
            if neighbor_weight != expected_weight.unwrap() {
                return Some((neighbor, expected_weight.unwrap()));
            }
        }
    }
    None
}
```


Overlapping Code:
```
ph<Node, ()>, node: NodeIndex) -> Option<(NodeIndex, usize)> {
let mut dfs = Dfs::new(&graph, node);
while let Some(nx) = dfs.next(&graph) {
let mut expected_weight = None;
for neighbor in graph.neighbors_directed(nx, Outgoing) {
let neighbor_weight = weight_for_node(&graph, neighbor);
if expected_weight.is_none() {
expected_weight = Some(neighbor_weight);
}
if neighbor_weight != expected_weight.unwrap() {
return Some((neighbor, expected_weight.u
```
<Overlap Ratio: 0.8982035928143712>

---

--- 95 --
Question ID: 86b8655d7cb8d82dc2fe9d1d35390277ad99bcea_0
Original Code:
```
pub fn build_index(lang: &str, library: &Library) -> Result<String> {
    let language = match Language::from_code(lang) {
        Some(l) => l,
        None => {
            bail!("Tried to build search index for language {} which is not supported", lang);
        }
    };

    let mut index = Index::with_language(language, &["title", "body"]);

    for section in library.sections_values() {
        if section.lang == lang {
            add_section_to_index(&mut index, section, library);
        }
    }

    Ok(index.to_json())
}
```


Overlapping Code:
```
x(lang: &str, library: &Library) -> Result<String> {
let language = match Language::from_code(lang) {
Some(l) => l,
None => {
bail!("Tried to build search index for language {} which is not supported", lang);
}
};
let mut index = Index::with_language(language, &["title", "body"]);
for section in library.sections_values() {
if section.lang == lang {
add_section_to_index(&mut index, section, library
```
<Overlap Ratio: 0.898876404494382>

---

--- 96 --
Question ID: c0b306050718d996e99faa856f777674f1e0989c_3
Original Code:
```
fn is_processed_by_this_key_server_in_set_of_3() {
		// servers set is ordered && server range depends on index of this server
		let servers_set = MapKeyServerSet::new(false, vec![
			// secret: 0000000000000000000000000000000000000000000000000000000000000001
			("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8".parse().unwrap(),
				"127.0.0.1:8080".parse().unwrap()),
			// secret: 0000000000000000000000000000000000000000000000000000000000000002
			("c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee51ae168fea63dc339a3c58419466ceaeef7f632653266d0e1236431a950cfe52a".parse().unwrap(),
				"127.0.0.1:8080".parse().unwrap()),
			// secret: 0000000000000000000000000000000000000000000000000000000000000003
			("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672".parse().unwrap(),
				"127.0.0.1:8080".parse().unwrap()),
		].into_iter().collect());

		// 1st server: process hashes [0x0; 0x555...555]
		let key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(
			"0000000000000000000000000000000000000000000000000000000000000001".parse().unwrap()).unwrap());
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"0000000000000000000000000000000000000000000000000000000000000000".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"3000000000000000000000000000000000000000000000000000000000000000".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"5555555555555555555555555555555555555555555555555555555555555555".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"5555555555555555555555555555555555555555555555555555555555555556".parse().unwrap()), false);

		// 2nd server: process hashes from 0x555...556 to 0xaaa...aab
		let key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(
			"0000000000000000000000000000000000000000000000000000000000000002".parse().unwrap()).unwrap());
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"5555555555555555555555555555555555555555555555555555555555555555".parse().unwrap()), false);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"5555555555555555555555555555555555555555555555555555555555555556".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"7555555555555555555555555555555555555555555555555555555555555555".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac".parse().unwrap()), false);

		// 3rd server: process hashes from 0x800...000 to 0xbff...ff
		let key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(
			"0000000000000000000000000000000000000000000000000000000000000003".parse().unwrap()).unwrap());
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab".parse().unwrap()), false);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"daaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaac".parse().unwrap()), true);
		assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
			&"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".parse().unwrap()), true);
	}
```


Overlapping Code:
```
ed_by_this_key_server_in_set_of_3() {
// servers set is ordered && server range depends on index of this server
let servers_set = MapKeyServerSet::new(false, vec![
// secret: 0000000000000000000000000000000000000000000000000000000000000001
("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8".parse().unwrap(),
"127.0.0.1:8080".parse().unwrap()),
// secret: 0000000000000000000000000000000000000000000000000000000000000002
("c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee51ae168fea63dc339a3c58419466ceaeef7f632653266d0e1236431a950cfe52a".parse().unwrap(),
"127.0.0.1:8080".parse().unwrap()),
// secret: 0000000000000000000000000000000000000000000000000000000000000003
("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672".parse().unwrap(),
"127.0.0.1:8080".parse().unwrap()),
].into_iter().collect());
// 1st server: process hashes [0x0; 0x555...555]
let key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(
"0000000000000000000000000000000000000000000000000000000000000001".parse().unwrap()).unwrap());
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"0000000000000000000000000000000000000000000000000000000000000000".parse().unwrap()), true);
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"3000000000000000000000000000000000000000000000000000000000000000".parse().unwrap()), true);
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"5555555555555555555555555555555555555555555555555555555555555555".parse().unwrap()), true);
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"5555555555555555555555555555555555555555555555555555555555555556".parse().unwrap()), false);
// 2nd server: process hashes from 0x555...556 to 0xaaa...aab
let key_pair = PlainNodeKeyPair::new(KeyPair::from_secret(
"0000000000000000000000000000000000000000000000000000000000000002".parse().unwrap()).unwrap());
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"5555555555555555555555555555555555555555555555555555555555555555".parse().unwrap()), false);
assert_eq!(is_processed_by_this_key_server(&servers_set, key_pair.public(),
&"5555555555555555555555555555555555555555555555555555555555555556".par
```
<Overlap Ratio: 0.9913115432354158>

---

--- 97 --
Question ID: 7a5406638910b7fd1cbce133805b4516bb853406_3
Original Code:
```
fn test_initialize_vertices() {
        let left_image = [[1, 1].to_vec()].to_vec();
        let right_image = [[1, 0].to_vec()].to_vec();
        let max_disparity: usize = 2;
        let mut diffusion_graph = DiffusionGraph::initialize(left_image, right_image, max_disparity, 1.);
        diffusion_graph.potentials[0][0][2][0] = 0.6;
        diffusion_graph.potentials[0][1][0][0] = -13.7;
        diffusion_graph.potentials[0][1][0][1] = 80.;
        let vertices = vec![vec![vec![false; max_disparity]; 2]; 1];
        let edges = vec![vec![vec![vec![vec![false; max_disparity]; 4]; max_disparity]; 2]; 1];
        let mut crossing_out_graph = CrossingOutGraph::initialize(diffusion_graph, vertices, edges);
        crossing_out_graph.initialize_vertices(1.);
        assert!(crossing_out_graph.vertices[0][0][0]);
        assert!(!crossing_out_graph.vertices[0][1][0]);
        assert!(crossing_out_graph.vertices[0][1][1]);
    }
```


Overlapping Code:
```
initialize_vertices() {
let left_image = [[1, 1].to_vec()].to_vec();
let right_image = [[1, 0].to_vec()].to_vec();
let max_disparity: usize = 2;
let mut diffusion_graph = DiffusionGraph::initialize(left_image, right_image, max_disparity, 1.);
diffusion_graph.potentials[0][0][2][0] = 0.6;
diffusion_graph.potentials[0][1][0][0] = -13.7;
diffusion_graph.potentials[0][1][0][1] = 80.;
let vertices = vec![vec![vec![false; max_disparity]; 2]; 1];
let edges = vec![vec![vec![vec![vec![false; max_disparity]; 4]; max_disparity]; 2]; 1];
let mut crossing_out_graph = CrossingOutGraph::initialize(diffusion_graph, vertices, edges);
crossing_out_graph.initialize_vertices(1.);
assert!(crossing_out_graph.vertices[0][0][0]);
assert!(!crossing_out_graph.vertices[0][1][0]);
assert!(crossing_out_graph.vertices[
```
<Overlap Ratio: 0.975609756097561>

---

--- 98 --
Question ID: c67d45ae049dc180a1387fa31f6a877a9ddcce61_2
Original Code:
```
fn process_usage_update(current_hour: u64, msg: UpdateUsage, data: &mut UsageTracker) {
    // history contains a reference to whatever the correct storage array is
    let history = match msg.kind {
        UsageType::Client => &mut data.client_bandwidth,
        UsageType::Relay => &mut data.relay_bandwidth,
        UsageType::Exit => &mut data.exit_bandwidth,
    };
    // we grab the front entry from the VecDeque, if there is an entry one we check if it's
    // up to date, if it is we add to it, if it's not or there is no entry we create one.
    // note that price is only sampled once per hour.
    match history.front_mut() {
        None => history.push_front(UsageHour {
            index: current_hour,
            up: msg.up,
            down: msg.down,
            price: msg.price,
        }),
        Some(entry) => {
            if entry.index == current_hour {
                entry.up += msg.up;
                entry.down += msg.down;
            } else {
                history.push_front(UsageHour {
                    index: current_hour,
                    up: msg.up,
                    down: msg.down,
                    price: msg.price,
                })
            }
        }
    }
    while history.len() > MAX_USAGE_ENTRIES {
        let _discarded_entry = history.pop_back();
    }
}
```


Overlapping Code:
```
ocess_usage_update(current_hour: u64, msg: UpdateUsage, data: &mut UsageTracker) {
// history contains a reference to whatever the correct storage array is
let history = match msg.kind {
UsageType::Client => &mut data.client_bandwidth,
UsageType::Relay => &mut data.relay_bandwidth,
UsageType::Exit => &mut data.exit_bandwidth,
};
// we grab the front entry from the VecDeque, if there is an entry one we check if it's
// up to date, if it is we add to it, if it's not or there is no entry we create one.
// note that price is only sampled once per hour.
match history.front_mut() {
None => history.push_front(UsageHour {
index: current_hour,
up: msg.up,
down: msg.down,
price: msg.price,
}),
Some(entry) => {
if entry.index == current_hour {
entry.up += msg.up;
entry.down += msg.down;
} else {
history.push_front(UsageHour {
index: current_hour,
up: msg.up,
down: msg.down,
price: msg.price,
})
}
}
}
while history.len() > MAX_USAGE_ENTRIES {
let _discarded_entry =
```
<Overlap Ratio: 0.9708835341365462>

---

--- 99 --
Question ID: 862e1bcb28fb7e5e9044737f10b3949d9c2b6d3e_8
Original Code:
```
fn lockfile_locks_transitively() {
    let p = project("foo")
        .file("Cargo.toml", r#"
            [project]
            name = "foo"
            version = "0.0.1"
            authors = []

            [dependencies]
            bar = "*"
        "#)
        .file("src/main.rs", "fn main() {}")
        .build();

    Package::new("baz", "0.0.1").publish();
    Package::new("bar", "0.0.1").dep("baz", "*").publish();

    assert_that(p.cargo("build"),
                execs().with_status(0).with_stderr(&format!("\
[UPDATING] registry `[..]`
[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)
[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)
[COMPILING] baz v0.0.1
[COMPILING] bar v0.0.1
[COMPILING] foo v0.0.1 ({dir})
[FINISHED] dev [unoptimized + debuginfo] target(s) in [..] secs
",
   dir = p.url())));

    p.root().move_into_the_past();
    Package::new("baz", "0.0.2").publish();
    Package::new("bar", "0.0.2").dep("baz", "*").publish();

    assert_that(p.cargo("build"),
                execs().with_status(0).with_stdout(""));
}
```


Overlapping Code:
```
ile_locks_transitively() {
let p = project("foo")
.file("Cargo.toml", r#"
[project]
name = "foo"
version = "0.0.1"
authors = []
[dependencies]
bar = "*"
"#)
.file("src/main.rs", "fn main() {}")
.build();
Package::new("baz", "0.0.1").publish();
Package::new("bar", "0.0.1").dep("baz", "*").publish();
assert_that(p.cargo("build"),
execs().with_status(0).with_stderr(&format!("\
[UPDATING] registry `[..]`
[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)
[DOWNLOADING] [..] v0.0.1 (registry `file://[..]`)
[COMPILING] baz v0.0.1
[COMPILING] bar v0.0.1
[COMPILING] foo v0.0.1 ({dir})
[FINISHED] dev [unoptimized + debuginfo] target(s) in [..] secs
",
dir = p.url())));
p.root().move_into_the_past();
Package::new("baz", "0.0.2").publish();
Package::new("bar", "0.0.2").dep("baz", "*").publish();
assert_that(p.cargo("build"),
execs().with_status(0).with_stdout(""))
```
<Overlap Ratio: 0.9874285714285714>

---

--- 100 --
Question ID: e9ed937129783e1d58168f053869e06652922c05_4
Original Code:
```
pub fn init_send_tx<T: ?Sized, C, K>(
	w: &mut T,
	args: InitTxArgs,
	use_test_rng: bool,
) -> Result<Slate, Error>
where
	T: WalletBackend<C, K>,
	C: NodeClient,
	K: Keychain,
{
	let parent_key_id = match args.src_acct_name {
		Some(d) => {
			let pm = w.get_acct_path(d)?;
			match pm {
				Some(p) => p.path,
				None => w.parent_key_id(),
			}
		}
		None => w.parent_key_id(),
	};

	let message = match args.message {
		Some(mut m) => {
			m.truncate(USER_MESSAGE_MAX_LEN);
			Some(m)
		}
		None => None,
	};

	let mut slate = tx::new_tx_slate(&mut *w, args.amount, 2, use_test_rng)?;

	// if we just want to estimate, don't save a context, just send the results
	// back
	if let Some(true) = args.estimate_only {
		let (total, fee) = tx::estimate_send_tx(
			&mut *w,
			args.amount,
			args.minimum_confirmations,
			args.max_outputs as usize,
			args.num_change_outputs as usize,
			args.selection_strategy,
			&parent_key_id,
		)?;
		slate.amount = total;
		slate.fee = fee;
		return Ok(slate);
	}

	let context = tx::add_inputs_to_slate(
		&mut *w,
		&mut slate,
		args.minimum_confirmations,
		args.max_outputs as usize,
		args.num_change_outputs as usize,
		args.selection_strategy,
		&parent_key_id,
		0,
		message,
		true,
		use_test_rng,
	)?;

	// Save the aggsig context in our DB for when we
	// receive the transaction back
	{
		let mut batch = w.batch()?;
		batch.save_private_context(slate.id.as_bytes(), 0, &context)?;
		batch.commit()?;
	}
	if let Some(v) = args.target_slate_version {
		slate.version_info.orig_version = v;
	}
	Ok(slate)
}
```


Overlapping Code:
```
nit_send_tx<T: ?Sized, C, K>(
w: &mut T,
args: InitTxArgs,
use_test_rng: bool,
) -> Result<Slate, Error>
where
T: WalletBackend<C, K>,
C: NodeClient,
K: Keychain,
{
let parent_key_id = match args.src_acct_name {
Some(d) => {
let pm = w.get_acct_path(d)?;
match pm {
Some(p) => p.path,
None => w.parent_key_id(),
}
}
None => w.parent_key_id(),
};
let message = match args.message {
Some(mut m) => {
m.truncate(USER_MESSAGE_MAX_LEN);
Some(m)
}
None => None,
};
let mut slate = tx::new_tx_slate(&mut *w, args.amount, 2, use_test_rng)?;
// if we just want to estimate, don't save a context, just send the results
// back
if let Some(true) = args.estimate_only {
let (total, fee) = tx::estimate_send_tx(
&mut *w,
args.amount,
args.minimum_confirmations,
args.max_outputs as usize,
args.num_change_outputs as usize,
args.selection_strategy,
&parent_key_id,
)?;
slate.amount = total;
slate.fee = fee;
return Ok(slate);
}
let context = tx::add_inputs_to_slate(
&mut *w,
&mut slate,
args.minimum_confirmations,
args.max_outputs as usize,
args.num_change_outputs as usize,
args.selection_strategy,
&parent_key_id,
0,
message,
true,
use_test_rng,
)?;
// Save the aggsig context in our DB for when we
// receive the transaction back
{
let mut batch = w.batch()?;
batch.save_private_context(slate.id.as_bytes(), 0, &context)?;
batch.commit()?;
}
if let Some(v) = args.target_slate_version {
slate.version_info.orig_version = v;
}
Ok(slate)

```
<Overlap Ratio: 0.9937325905292479>

---

--- 101 --
Question ID: 5f1380e6c1debec737ab1239768457e2ae4edaea_3
Original Code:
```
async fn nexus_create_grpc(
    compose: &Arc<ComposeTest>,
    nr_children: usize,
) -> GrpcNexus {
    let children = get_children(compose.clone())
        .await
        .iter()
        .take(nr_children)
        .cloned();
    let mut hdls = compose.grpc_handles().await.unwrap();

    let nexus_hdl = &mut hdls.last_mut().unwrap();
    let nexus = nexus_hdl
        .mayastor
        .create_nexus(rpc::mayastor::CreateNexusRequest {
            uuid: uuid::Uuid::new_v4().to_string(),
            size: 10 * 1024 * 1024,
            children: children.collect::<Vec<_>>(),
        })
        .await
        .unwrap();
    GrpcNexus(compose.clone(), nexus.into_inner())
}
```


Overlapping Code:
```
us_create_grpc(
compose: &Arc<ComposeTest>,
nr_children: usize,
) -> GrpcNexus {
let children = get_children(compose.clone())
.await
.iter()
.take(nr_children)
.cloned();
let mut hdls = compose.grpc_handles().await.unwrap();
let nexus_hdl = &mut hdls.last_mut().unwrap();
let nexus = nexus_hdl
.mayastor
.create_nexus(rpc::mayastor::CreateNexusRequest {
uuid: uuid::Uuid::new_v4().to_string(),
size: 10 * 1024 * 1024,
children: children.collect::<Vec<_>>(),
})
.await
.unwrap();
GrpcNexus(compose.clo
```
<Overlap Ratio: 0.9276437847866419>

---

--- 102 --
Question ID: 9d7144822e067d0fd0a9ac28041188ee73d2dd65_1
Original Code:
```
fn notice_with_add_environment() {
        let notice = Notice::builder().add_environment("foo", "bar").build();
        let expected_json = r#"
        {
            "errors": [],
            "environment": {
                "foo": "bar"
            }
        }
        "#;
        assert_eq!(Value::from_str(expected_json).unwrap(), Value::from(notice));
    }
```


Overlapping Code:
```
 notice_with_add_environment() {
let notice = Notice::builder().add_environment("foo", "bar").build();
let expected_json = r#"
{
"errors": [],
"environment": {
"foo": "bar"
}
}
"#;
assert_eq!(Value::from_str(expected_json).unwrap(), Value::from(notice));

```
<Overlap Ratio: 0.9883720930232558>

---

--- 103 --
Question ID: 7810d7c3173239d6be3550ae2aa616701babc34b_0
Original Code:
```
async fn backpressure_basic()
{
	COUNTER.with( |c| c.store( 0, Ordering::SeqCst ) );

	let (server, client) = Endpoint::pair( 64, 64 );

	let peera = async move
	{
		// Create mailbox for our handler
		//
		let slow  = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( "spawn actor mailbox" );
		let slow2 = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( "spawn actor mailbox" );
		let after = Addr::builder().spawn_local( After, &AsyncStd ).expect( "spawn actor mailbox" );

		// Create a service map
		//
		let mut sm = bpsm::Services::new();

		// Register our handlers
		//
		sm.register_handler::<Add >( slow .clone_box() );
		sm.register_handler::<Add2>( slow2.clone_box() );
		sm.register_handler::<Show>( after.clone_box() );

		// create peer with stream/sink
		//
		let (mut peer, peer_mb, _peer_addr) = CborWF::create_peer
		(
			"server", server,
			1024, 1024,
			AsyncStd,
			Some(Arc::new( Semaphore::new(2) )),
			None

		).expect( "spawn peer" );


		// register service map with peer
		//
		peer.register_services( Arc::new( sm ) );

		let handle = AsyncStd.spawn_handle_local( peer_mb.start(peer) ).expect( "start mailbox of Peer" );
		handle.await;

		trace!( "end of peera" );
	};


	let peerb = async move
	{
		let (mut peera, _)  = peer_connect( client, AsyncStd, "peer_b_to_peera" ).await;

		// Call the service and receive the response
		//
		let mut addr  = bpsm::RemoteAddr::new( peera.clone() );
		let mut addr2 = addr.clone();
		let mut addr3 = addr.clone();

		let add1 = async move { addr .call( Add (1) ).await.expect( "call add1"  ) };
		let add2 = async move { addr2.call( Add2(1) ).await.expect( "call add2"  ) };
		let show = async move { addr3.call( Show    ).await.expect( "call check" ) };

		let add1_handle = AsyncStd.spawn_handle_local( add1 ).expect( "spawn add1"  );
		let add2_handle = AsyncStd.spawn_handle_local( add2 ).expect( "spawn add2"  );

		// We must make sure the adds are send before the show, but spawning is not deterministic.
		//
		Delay::new( Duration::from_millis(20) ).await;
		let show_handle = AsyncStd.spawn_handle_local( show ).expect( "spawn check" );

		add1_handle.await;
		add2_handle.await;

		// Add1 should be guaranteed to have finished and updated the counter to 1 before
		// show can run due to back pressure. As add2 has a longer timeout, it shouldn't have
		// run yet.
		//
		assert_eq!( show_handle.await, 1 );

		peera.send( CloseConnection{ remote: false, reason: "Program end.".to_string() } ).await.expect( "close connection to peera" );
	};


	// As far as I can tell, execution order is not defined, so hmm, there is no
	// guarantee that a is listening before b tries to connect, but it seems to work for now.
	//
	join( peera, peerb ).await;
}
```


Overlapping Code:
```
_basic()
{
COUNTER.with( |c| c.store( 0, Ordering::SeqCst ) );
let (server, client) = Endpoint::pair( 64, 64 );
let peera = async move
{
// Create mailbox for our handler
//
let slow = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( "spawn actor mailbox" );
let slow2 = Addr::builder().spawn_local( Slow , &AsyncStd ).expect( "spawn actor mailbox" );
let after = Addr::builder().spawn_local( After, &AsyncStd ).expect( "spawn actor mailbox" );
// Create a service map
//
let mut sm = bpsm::Services::new();
// Register our handlers
//
sm.register_handler::<Add >( slow .clone_box() );
sm.register_handler::<Add2>( slow2.clone_box() );
sm.register_handler::<Show>( after.clone_box() );
// create peer with stream/sink
//
let (mut peer, peer_mb, _peer_addr) = CborWF::create_peer
(
"server", server,
1024, 1024,
AsyncStd,
Some(Arc::new( Semaphore::new(2) )),
None
).expect( "spawn peer" );
// register service map with peer
//
peer.register_services( Arc::new( sm ) );
let handle = AsyncStd.spawn_handle_local( peer_mb.start(peer) ).expect( "start mailbox of Peer" );
handle.await;
trace!( "end of peera" );
};
let peerb = async move
{
let (mut peera, _) = peer_connect( client, AsyncStd, "peer_b_to_peera" ).await;
// Call the service and receive the response
//
let mut addr = bpsm::RemoteAddr::new( peera.clone() );
let mut addr2 = addr.clone();
let mut addr3 = addr.clone();
let add1 = async move { addr .call( Add (1) ).await.expect( "call add1" ) };
let add2 = async move { addr2.call( Add2(1) ).await.expect( "call add2" ) };
let show = async move { addr3.call( Show ).await.expect( "call check" ) };
let add1_handle = AsyncStd.spawn_handle_local( add1 ).expect( "spawn add1" );
let add2_handle = AsyncStd.spawn_handle_local( add2 ).expect( "spawn add2" );
// We must make sure the adds are send before the show, but spawning is not deterministic.
//
Delay::new( Duration::from_millis(20) ).await;
let show_handle = AsyncStd.spawn_handle_local( show ).expect( "spawn check" );
add1_handle.await;
add2_handle.await;
// Add1 should be guaranteed to have finished and updated the counter to 1 before
// show can run due to back pressure. As add2 has a longer timeout, it shouldn't have
// run yet.
//
assert_eq!( show_handle.await, 1 );
peera.send( CloseConnection{ remote: false, reason: "Program end.".to_string() } ).awa
```
<Overlap Ratio: 0.9910790144435004>

---

--- 104 --
Question ID: d0cc772e8eed7bca68870c18551d47f163eb1e24_7
Original Code:
```
fn test_invalid_url() {
        let request_params = RequestParams::default();
        let response = Response {
            apps: vec![App {
                update_check: Some(UpdateCheck::ok(vec!["invalid-url".to_string()])),
                ..App::default()
            }],
            ..Response::default()
        };
        assert_eq!(
            FuchsiaInstallPlan::try_create_from(&request_params, &response),
            Err(InstallPlanErrors::Failed)
        );
    }
```


Overlapping Code:
```
fn test_invalid_url() {
let request_params = RequestParams::default();
let response = Response {
apps: vec![App {
update_check: Some(UpdateCheck::ok(vec!["invalid-url".to_string()])),
..App::default()
}],
..Response::default()
};
assert_eq!(
FuchsiaInstallPlan::try_create_from(&request_params, &response),
Err(InstallPlanErrors::Failed)
);
```
<Overlap Ratio: 0.9941520467836257>

---

--- 105 --
Question ID: 76795363af213f8e4b2960b268e373b6e81cb00a_27
Original Code:
```
pub unsafe extern "C" fn xed_decoded_inst_set_mode(
    mut p: *mut xed_decoded_inst_t,
    mut mmode: xed_machine_mode_enum_t,
    mut stack_addr_width: xed_address_width_enum_t,
) {
    let mut dstate: xed_state_t = xed_state_t {
        mmode: XED_MACHINE_MODE_INVALID,
        stack_addr_width: XED_ADDRESS_WIDTH_INVALID,
    };
    dstate.mmode = mmode;
    dstate.stack_addr_width = stack_addr_width;
    xed_operand_values_set_mode(p, &mut dstate);
}
```


Overlapping Code:
```
n xed_decoded_inst_set_mode(
mut p: *mut xed_decoded_inst_t,
mut mmode: xed_machine_mode_enum_t,
mut stack_addr_width: xed_address_width_enum_t,
) {
let mut dstate: xed_state_t = xed_state_t {
mmode: XED_MACHINE_MODE_INVALID,
stack_addr_width: XED_ADDRESS_WIDTH_INVALID,
};
dstate.mmode = mmode;
dstate.stack_addr_width = stack_addr_width;
xed_operan
```
<Overlap Ratio: 0.8557457212713936>

---

--- 106 --
Question ID: e576b0a0a4abab1238ee2fe01221f68906adc664_7
Original Code:
```
fn test_version_to_string() {
    let valid_version = "1.10.1947-abcd-EFG+1A-bc-2";

    let version_a = Version::parse(valid_version).unwrap();
    let version_a_str = version_a.to_string();

    let version_b = Version::parse(&version_a_str).unwrap();
    assert_eq!(version_a, version_b);
}
```


Overlapping Code:
```
o_string() {
let valid_version = "1.10.1947-abcd-EFG+1A-bc-2";
let version_a = Version::parse(valid_version).unwrap();
let version_a_str = version_a.to_string();
let version_b = Version::parse(&version_a_str).unwrap();
assert_eq!(version_a, version_b
```
<Overlap Ratio: 0.922509225092251>

---

--- 107 --
Question ID: 79fe1bf2f4d04b57afd3610546532d7a6b279df5_0
Original Code:
```
fn main() {
  let mut argv = std::env::args();
  let argc = argv.len();
  if argc == 0 || argc > 2 {
    panic!("restart test binary expect either no arguments or `restart`.")
  }

  println!(
    "{}",
    tauri::api::process::current_binary(&Default::default())
      .expect("tauri::api::process::current_binary could not resolve")
      .display()
  );

  match argv.nth(1).as_deref() {
    Some("restart") => tauri::api::process::restart(&Default::default()),
    Some(invalid) => panic!("only argument `restart` is allowed, {} is invalid", invalid),
    None => {}
  };
}
```


Overlapping Code:
```
 {
let mut argv = std::env::args();
let argc = argv.len();
if argc == 0 || argc > 2 {
panic!("restart test binary expect either no arguments or `restart`.")
}
println!(
"{}",
tauri::api::process::current_binary(&Default::default())
.expect("tauri::api::process::current_binary could not resolve")
.display()
);
match argv.nth(1).as_deref() {
Some("restart") => tauri::api::process::restart(&Default::default()),
Some(invalid) => panic!("only argument `restart` is allowed, {} is invalid", invalid),
N
```
<Overlap Ratio: 0.9560229445506692>

---

--- 108 --
Question ID: 2b0c35ce77cefeb0c4ca7fe0d3381aac8a734270_3
Original Code:
```
fn start_lobby() {
    let mut client = common::setup();
    client.send(1, ".n 1");
    client.send(1, ".m");
    client.send(2, ".n 2");
    client.send(2, ".j 1");
    client.send(1, ".s");
    client.read_all();
    assert!(client
        .last(1)
        .contains("You are the THRUSTEE. Choose NOW.........."));
    assert!(client
        .last(2)
        .contains("You are a THRUSTER. waiting for a good THRUSTEE from 1; mmm baby!"));
}
```


Overlapping Code:
```
obby() {
let mut client = common::setup();
client.send(1, ".n 1");
client.send(1, ".m");
client.send(2, ".n 2");
client.send(2, ".j 1");
client.send(1, ".s");
client.read_all();
assert!(client
.last(1)
.contains("You are the THRUSTEE. Choose NOW.........."));
assert!(client
.last(2)
.contains("You are a THRUSTER. waiting for a good THRUSTEE from 1; mmm baby
```
<Overlap Ratio: 0.9547872340425532>

---

--- 109 --
Question ID: 8be196cd7b12228b079f482931760d8c91b265a9_2
Original Code:
```
pub fn update_handler(request: &mut Request) -> IronResult<Response> {
    // get param id
    let id = request.extensions.get::<Router>().unwrap().find("id").unwrap().to_owned();
    
    // get the body
    let body_option = itry!(request.get::<bodyparser::Raw>(), status::BadRequest);
    let raw_body = iexpect!(body_option, status::BadRequest);
    let todo_partial = itry!(serde_json::from_str(&raw_body), status::BadRequest);

    let mutex = request.get::<State<TodoItems>>().unwrap();
    let mut todo_items = mutex.write().unwrap();

    // find item (as mutable)
    let item_option = todo_items.iter_mut().find(|item| item.get_id() == id);
    let mut item = iexpect!(item_option, status::NotFound);

    item.update(todo_partial);

    Ok(Response::with((status::Ok, format!("{{\"id\": \"{}\"}}", item.get_id()))))
}
```


Overlapping Code:
```
te_handler(request: &mut Request) -> IronResult<Response> {
// get param id
let id = request.extensions.get::<Router>().unwrap().find("id").unwrap().to_owned();

// get the body
let body_option = itry!(request.get::<bodyparser::Raw>(), status::BadRequest);
let raw_body = iexpect!(body_option, status::BadRequest);
let todo_partial = itry!(serde_json::from_str(&raw_body), status::BadRequest);
let mutex = request.get::<State<TodoItems>>().unwrap();
let mut todo_items = mutex.write().unwrap();
// find item (as mutable)
let item_option = todo_items.iter_mut().find(|item| item.get_id() == id);
let mut item = iexpect!(item_option, status::NotFound);
item.update(todo_partial);
Ok(Response::with((status::Ok, format!("{{\"id\": \"{}\"}}", item.get_id
```
<Overlap Ratio: 0.9752925877763329>

---

--- 110 --
Question ID: 02354d15ae2988c17b5c379480cdf009abee280a_0
Original Code:
```
fn main() {
    let input = "太郎はカステラが好きだ。しかし牛乳も好きだ。";
    let sr = lightblue(input).unwrap();
    println!("{}", format_sr(&sr));
}
```


Overlapping Code:
```
;
let sr = lightblue(input).unwrap();
println!("{}
```
<Overlap Ratio: 0.42016806722689076>

---

--- 111 --
Question ID: f25a31a02a812d218db611088e5f74d52eeb1e1c_9
Original Code:
```
fn create_transaction_test() {
        let manager = SqliteConnectionManager::memory();
        let pool = r2d2::Pool::new(manager).unwrap();
        create_base(pool.get().unwrap());

        let id = create_transaction(pool.get().unwrap(), 1, 2, 50, "Super Payment");

        assert_eq!(id.unwrap(), 1);
    }
```


Overlapping Code:
```
transaction_test() {
let manager = SqliteConnectionManager::memory();
let pool = r2d2::Pool::new(manager).unwrap();
create_base(pool.get().unwrap());
let id = create_transaction(pool.get().unwrap(), 1, 2, 50, "Super Payment");
assert_eq!(id.unwrap(),
```
<Overlap Ratio: 0.9398496240601504>

---

--- 112 --
Question ID: 8abc642a1a9e173471919c37ded33ce7410c8640_5
Original Code:
```
fn add_team_as_non_member() {
    let (app, _) = TestApp::with_proxy().empty();
    let user = app.db_new_user(mock_user_on_only_one_team().gh_login);
    let token = user.db_new_token("arbitrary token name");

    app.db(|conn| {
        CrateBuilder::new("foo_team_non_member", user.as_model().id).expect_build(conn);
    });

    let json = token
        .add_named_owner(
            "foo_team_non_member",
            "github:crates-test-org:just-for-crates-2",
        )
        .bad_with_status(200);

    assert!(
        json.errors[0]
            .detail
            .contains("only members of a team can add it as an owner"),
        "{:?}",
        json.errors
    );
}
```


Overlapping Code:
```
non_member() {
let (app, _) = TestApp::with_proxy().empty();
let user = app.db_new_user(mock_user_on_only_one_team().gh_login);
let token = user.db_new_token("arbitrary token name");
app.db(|conn| {
CrateBuilder::new("foo_team_non_member", user.as_model().id).expect_build(conn);
});
let json = token
.add_named_owner(
"foo_team_non_member",
"github:crates-test-org:just-for-crates-2",
)
.bad_with_status(200);
assert!(
json.errors[0]
.detail
.contains("only members of a team can add it as an owner"
```
<Overlap Ratio: 0.922509225092251>

---

--- 113 --
Question ID: 4dc9d67aea24d51052b9f28b34b9f377263483ee_1
Original Code:
```
fn test_as_number() {
        // bytestring is a number
        let num = as_number::<u64>(vec![b'1', b'2']).unwrap();
        assert_eq!(num, 12);

        // bytestring is not a number
        let err = as_number::<u64>(vec![b' ', b'1', b'2']).unwrap_err();
        assert_eq!(err, TcpTransportError::NumberParseError);
    }
```


Overlapping Code:
```
r() {
// bytestring is a number
let num = as_number::<u64>(vec![b'1', b'2']).unwrap();
assert_eq!(num, 12);
// bytestring is not a number
let err = as_number::<u64>(vec![b' ', b'1', b'2']).unwrap_err();
assert_eq!(err, TcpTransportError::NumberParseE
```
<Overlap Ratio: 0.9124087591240876>

---

--- 114 --
Question ID: 76e0b99ebf5020cb073dd1bfcba07a6ba4d25e3d_1
Original Code:
```
fn test_check_answer_1() {
    let answer = "1 2 ABC 3.449999999993847";
    let expected = "1 2 ABC 3.45";
    assert!(check_answer(answer, expected).is_ok());
}
```


Overlapping Code:
```
{
let answer = "1 2 ABC 3.449999999993847";
let expected = "1 2 ABC 3.45";
assert!(check_answer(answ
```
<Overlap Ratio: 0.6666666666666666>

---

--- 115 --
Question ID: d71b9abfbd1798542832aeae848148e506f4dc81_13
Original Code:
```
fn should_be_able_to_get_correct_matrix_representation_of_connections() {
        let mut organism = NeuralNetwork::with_neurons(3);
        organism.add_connection(0, 1, 1.0);
        organism.add_connection(1, 2, 0.5);
        organism.add_connection(2, 1, 0.5);
        organism.add_connection(2, 2, 0.75);
        organism.add_connection(1, 0, 1.0);
        let nn = organism.make_network();
        assert_eq!(
            organism.get_weights(),
            vec![0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.5, 0.75]
        );
    }
```


Overlapping Code:
```
trix_representation_of_connections() {
let mut organism = NeuralNetwork::with_neurons(3);
organism.add_connection(0, 1, 1.0);
organism.add_connection(1, 2, 0.5);
organism.add_connection(2, 1, 0.5);
organism.add_connection(2, 2, 0.75);
organism.add_connection(1, 0, 1.0);
let nn = organism.make_network();
assert_eq!(
organism.get_weights(),
vec![0.0, 1.0, 0.0, 1.0, 0.0, 0.5, 0.0, 0.5, 0.75]

```
<Overlap Ratio: 0.9095127610208816>

---

--- 116 --
Question ID: e53601326c2b64b9489b460595926388bfcd2363_4
Original Code:
```
async fn handle_schedule_request(
    query: web::Query<DateBasedQuery>,
) -> Result<HttpResponse, KretaError> {
    let request_started = Instant::now();

    let lessons: Vec<Lesson> = get_schedule(
        query.token.clone(),
        query.url.clone(),
        query.from_date.clone(),
        query.to_date.clone(),
    )
    .await?;

    info!(
        "Schedule request done for {} in {}",
        &query.url,
        request_started.elapsed().as_millis()
    );

    Ok(HttpResponse::build(StatusCode::OK).json(lessons))
}
```


Overlapping Code:
```
hedule_request(
query: web::Query<DateBasedQuery>,
) -> Result<HttpResponse, KretaError> {
let request_started = Instant::now();
let lessons: Vec<Lesson> = get_schedule(
query.token.clone(),
query.url.clone(),
query.from_date.clone(),
query.to_date.clone(),
)
.await?;
info!(
"Schedule request done for {} in {}",
&query.url,
request_started.elapsed().as_millis()
);
Ok(HttpResponse::build(StatusCode::OK).json
```
<Overlap Ratio: 0.9318181818181818>

---

--- 117 --
Question ID: b5f1472236bf3f1eb6278d696524d731f5055f49_4
Original Code:
```
fn object_panics_on_internal_error() {
        let object_behavior = ObjectBehaviorMock::new();
        let expected_object = Object {
            id: 125,
            description: object_description(),
            behavior: &object_behavior,
        };

        let mut interactable = InteractableMock::<()>::new();
        interactable
            .expect_object(|arg| arg.partial_eq(expected_object.id))
            .returns(None);
        let world_interactor = WorldInteractorImpl::new(&interactable, expected_object.id);

        let _object = world_interactor.own_object();
    }
```


Overlapping Code:
```

let object_behavior = ObjectBehaviorMock::new();
let expected_object = Object {
id: 125,
description: object_description(),
behavior: &object_behavior,
};
let mut interactable = InteractableMock::<()>::new();
interactable
.expect_object(|arg| arg.partial_eq(expected_object.id))
.returns(None);
let world_interactor = WorldInteractorImpl::new(&interactable, expected_object.id);
let _object = world_
```
<Overlap Ratio: 0.8620689655172413>

---

--- 118 --
Question ID: 70cdb095b9259bb3ff13a654da91ffd54dae8fc6_6
Original Code:
```
fn input_port_b_direction() {
        let mut riot = Riot::new();

        // Reading from the bits set as output should return the register value
        // instead of port input.
        riot.set_port(Port::PB, 0b1100_1100);
        riot.write(registers::SWBCNT, 0b1111_0000).unwrap();
        riot.write(registers::SWCHB, 0b0101_0101).unwrap();
        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b0101_1100);

        // Data in the output register should be cached and return what we wrote
        // to bits previously set to act as inputs.
        riot.write(registers::SWBCNT, 0b0000_1111).unwrap();
        assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b1100_0101);
    }
```


Overlapping Code:
```
b_direction() {
let mut riot = Riot::new();
// Reading from the bits set as output should return the register value
// instead of port input.
riot.set_port(Port::PB, 0b1100_1100);
riot.write(registers::SWBCNT, 0b1111_0000).unwrap();
riot.write(registers::SWCHB, 0b0101_0101).unwrap();
assert_eq!(riot.read(registers::SWCHB).unwrap(), 0b0101_1100);
// Data in the output register should be cached and return what we wrote
// to bits previously set to act as inputs.
riot.write(registers::SWBCNT, 0b0000_1111).unwrap();
assert_eq!(riot.read(registers::
```
<Overlap Ratio: 0.9228187919463087>

---

--- 119 --
Question ID: da08379faa3c75f93b9a419410a34b98558e9ff4_5
Original Code:
```
fn zero_or_more_combinator() {
    let parser = zero_or_more(match_literal("ha"));
    assert_eq!(Ok(("", vec![(), (), ()])), parser.parse("hahaha"));
    assert_eq!(Ok(("ahah", vec![])), parser.parse("ahah"));
    assert_eq!(Ok(("", vec![])), parser.parse(""));
}
```


Overlapping Code:
```
ero_or_more_combinator() {
let parser = zero_or_more(match_literal("ha"));
assert_eq!(Ok(("", vec![(), (), ()])), parser.parse("hahaha"));
assert_eq!(Ok(("ahah", vec![])), parser.parse("ahah"));
assert_eq!(Ok(("", vec![])), parser.parse(""));

```
<Overlap Ratio: 0.9798387096774194>

---

--- 120 --
Question ID: 64bd06241455d09a190e768da6e96ebf6504eb3f_4
Original Code:
```
fn calculate_intersections(horizontals: Segments, verticals: Segments) -> Intersections {
    let mut intersections: Intersections = vec![];
    for h in horizontals.iter() {
        for v in verticals.iter() {
            let (x1, x2, xv) = (h.p1.x, h.p2.x, v.p1.x);
            let (y1, y2, yh) = (v.p1.y, v.p2.y, h.p1.y);

            if route(x1, x2).contains(&xv) && route(y1, y2).contains(&yh) {
                let h_steps = if x1 > xv { x1 - xv } else { xv - x1 };
                let v_steps = if y1 > yh { y1 - yh } else { yh - y1 };
                let steps = h_steps.abs() + v_steps.abs();

                let point = Point { x: xv, y: yh };
                let cost = h.last_steps + v.last_steps + steps;
                intersections.push(Intersection { point, cost })
            }
        }
    }
    intersections
}
```


Overlapping Code:
```
ls: Segments, verticals: Segments) -> Intersections {
let mut intersections: Intersections = vec![];
for h in horizontals.iter() {
for v in verticals.iter() {
let (x1, x2, xv) = (h.p1.x, h.p2.x, v.p1.x);
let (y1, y2, yh) = (v.p1.y, v.p2.y, h.p1.y);
if route(x1, x2).contains(&xv) && route(y1, y2).contains(&yh) {
let h_steps = if x1 > xv { x1 - xv } else { xv - x1 };
let v_steps = if y1 > yh { y1 - yh } else { yh - y1 };
let steps = h_steps.abs() + v_steps.abs();
let point = Point { x: xv, y: yh };
let cost = h.last_steps + v.last_steps + steps;
intersections.push(Intersection { point, cost })
}
```
<Overlap Ratio: 0.9146341463414634>

---

--- 121 --
Question ID: 045bda0b25736e784dac7151320cf5230548722d_0
Original Code:
```
fn can_apply_simple_change_tagged() {
        let initial_tree    = tree!("test", ("one", 1), ("two", 2), ("three", 3));
        let change_two      = TreeChange::new(&("two"), &("replaced", 4));
        let changed_tree    = change_two.apply(&initial_tree);

        assert!(changed_tree.get_child_ref_at("one").unwrap().get_value().to_int(0) == 1);
        assert!(changed_tree.get_child_ref_at("replaced").unwrap().get_value().to_int(0) == 4);
        assert!(!changed_tree.get_child_ref_at("replaced").unwrap().get_sibling_ref().is_none());
        assert!(changed_tree.get_child_ref_at("two").is_none());
        assert!(!changed_tree.get_child_ref_at("three").is_none());
    }
```


Overlapping Code:
```
fn can_apply_simple_change_tagged() {
let initial_tree = tree!("test", ("one", 1), ("two", 2), ("three", 3));
let change_two = TreeChange::new(&("two"), &("replaced", 4));
let changed_tree = change_two.apply(&initial_tree);
assert!(changed_tree.get_child_ref_at("one").unwrap().get_value().to_int(0) == 1);
assert!(changed_tree.get_child_ref_at("replaced").unwrap().get_value().to_int(0) == 4);
assert!(!changed_tree.get_child_ref_at("replaced").unwrap().get_sibling_ref().is_none());
assert!(changed_tree.get_child_ref_at("two").is_none());
assert!(!changed_tree.get_child_ref_at("three")
```
<Overlap Ratio: 0.9767827529021559>

---

--- 122 --
Question ID: 7fe5a54a817d02d76a3d99f537ed47c6580e866d_2
Original Code:
```
pub unsafe extern "C" fn wlr_log_init(mut verbosity: wlr_log_importance,
                                      mut callback: wlr_log_func_t) {
    if (verbosity as libc::c_uint) <
           WLR_LOG_IMPORTANCE_LAST as libc::c_int as libc::c_uint {
        log_importance = verbosity
    }
    if callback.is_some() { log_callback = callback }
    wl_log_set_handler_server(Some(log_wl as
                                       unsafe extern "C" fn(_:
                                                                *const libc::c_char,
                                                            _:
                                                                ::std::ffi::VaList)
                                           -> ()));
}
```


Overlapping Code:
```
C" fn wlr_log_init(mut verbosity: wlr_log_importance,
mut callback: wlr_log_func_t) {
if (verbosity as libc::c_uint) <
WLR_LOG_IMPORTANCE_LAST as libc::c_int as libc::c_uint {
log_importance = verbosity
}
if callback.is_some() { log_callback = callback }
wl_log_set_handler_server(Some(log_wl as
unsafe extern "C" fn(_:
*const libc::c_char,
_:
::std:
```
<Overlap Ratio: 0.8905852417302799>

---

--- 123 --
Question ID: 9b22243f15d784a38d414df180b98694caf0a46a_0
Original Code:
```
fn process_table(table: &Table) -> ProcessedTable {
    let mut processed_data = vec![];
    for row in &table.data {
        let mut out_row = vec![];
        for column in row {
            let cleaned = clean(&column.contents);
            out_row.push(ProcessedCell {
                contents: split_sublines(&cleaned),
                style: column.style,
            });
        }
        processed_data.push(out_row);
    }

    let mut processed_headers = vec![];
    for header in &table.headers {
        let cleaned = clean(&header.contents);
        processed_headers.push(ProcessedCell {
            contents: split_sublines(&cleaned),
            style: header.style,
        });
    }

    ProcessedTable {
        headers: processed_headers,
        data: processed_data,
        theme: table.theme.clone(),
    }
}
```


Overlapping Code:
```
ocess_table(table: &Table) -> ProcessedTable {
let mut processed_data = vec![];
for row in &table.data {
let mut out_row = vec![];
for column in row {
let cleaned = clean(&column.contents);
out_row.push(ProcessedCell {
contents: split_sublines(&cleaned),
style: column.style,
});
}
processed_data.push(out_row);
}
let mut processed_headers = vec![];
for header in &table.headers {
let cleaned = clean(&header.contents);
processed_headers.push(ProcessedCell {
contents: split_sublines(&cleaned),
style: header.style,
});
}
ProcessedTable {
headers: processed_headers,
data: processed_data,
theme: table.theme.clon
```
<Overlap Ratio: 0.9792>

---

--- 124 --
Question ID: 6c6b7709d25131232741c5b45dd3d3a10fea5786_9
Original Code:
```
fn parse_goodbye(msg: &[Value]) -> Result<rx::Goodbye, MessageParseError> {
    if msg.len() != 2 {
        warn!("Bad GOODBYE message length: {}", msg.len());
        return Err(MessageParseError::BadMessageLength);
    }

    let details = helpers::parse_details(&msg[0])?;
    let reason = helpers::parse_uri(&msg[1])?;

    let goodbye = rx::Goodbye { details, reason };
    trace!("Received GOODBYE message: {:?}", goodbye);
    Ok(goodbye)
}
```


Overlapping Code:
```
oodbye, MessageParseError> {
if msg.len() != 2 {
warn!("Bad GOODBYE message length: {}", msg.len());
return Err(MessageParseError::BadMessageLength);
}
let details = helpers::parse_details(&msg[0])?;
let reason = helpers::parse_uri(&msg[1])?;
let goodbye = rx::Goodbye { details, reason };
trace!("Received GOODBYE message: {:?}", goodbye);
Ok(goodby
```
<Overlap Ratio: 0.8728179551122195>

---

--- 125 --
Question ID: 8c5da4c29637725a8ea05ff3f2acc0fd5947f2d9_2
Original Code:
```
fn type_create_works() {
        TestUtils::cleanup_sovrin_home();

        let wallet_type = DefaultWalletType::new();
        wallet_type.create("wallet1", None, None).unwrap();

        TestUtils::cleanup_sovrin_home();
    }
```


Overlapping Code:
```
orks() {
TestUtils::cleanup_sovrin_home();
let wallet_type = DefaultWalletType::new();
wallet_type.create("wallet1", None, None).unwrap();
TestUtils::cleanup_sovrin_home();

```
<Overlap Ratio: 0.9105263157894737>

---

--- 126 --
Question ID: c93ee20d28973beebaff3bb0a6c9ea476289d1ad_4
Original Code:
```
fn apply_blur(pixels: &[Vec<u8>]) -> Vec<Vec<u8>> {
    let strength = 20; // Amount of blur
    let mut new_pixels = pixels.to_owned();
    for (y, row) in pixels.iter().enumerate() {
        for (x, v) in row.iter().enumerate() {
            // Each lit pixel will bleed some light to the surrounding pixels
            if *v == 255 {
                // Apply bleed to surrounding pixels
                let co_ords: Vec<(usize, usize)> = vec![
                    (y.saturating_sub(1), x),
                    (y+1,                 x),
                    (y,                   x.saturating_sub(1)),
                    (y,                   x+1),
                    (y.saturating_sub(1), x.saturating_sub(1)),
                    (y.saturating_sub(1), x+1),
                    (y+1,                 x.saturating_sub(1)),
                    (y+1,                 x+1),
                ];

                for (y, x) in co_ords {
                    if (x < pixels[0].len()) &&
                       (y < pixels.len()) {
                        new_pixels[y][x] = new_pixels[y][x].saturating_add(strength);
                    }
                }
            }
        }
    }
    new_pixels
}
```


Overlapping Code:
```
ec<u8>> {
let strength = 20; // Amount of blur
let mut new_pixels = pixels.to_owned();
for (y, row) in pixels.iter().enumerate() {
for (x, v) in row.iter().enumerate() {
// Each lit pixel will bleed some light to the surrounding pixels
if *v == 255 {
// Apply bleed to surrounding pixels
let co_ords: Vec<(usize, usize)> = vec![
(y.saturating_sub(1), x),
(y+1, x),
(y, x.saturating_sub(1)),
(y, x+1),
(y.saturating_sub(1), x.saturating_sub(1)),
(y.saturating_sub(1), x+1),
(y+1, x.saturating_sub(1)),
(y+1, x+1),
];
for (y, x) in co_ords {
if (x < pixels[0].len()) &&
(y < pixels.len()) {
new_pixels[y][x] = new_pixels[y][x].saturating_add(strength);
```
<Overlap Ratio: 0.9090909090909091>

---

--- 127 --
Question ID: 418f9db693d9749aefa93f03516fa7a93d9aed51_0
Original Code:
```
pub fn derive(item: syn::DeriveInput) -> Result<proc_macro2::TokenStream, Diagnostic> {
    let model = Model::from_item(&item)?;
    let tokens = MetaItem::all_with_name(&item.attrs, "belongs_to")
        .into_iter()
        .filter_map(
            |attr| match derive_belongs_to(&model, &item.generics, attr) {
                Ok(t) => Some(t),
                Err(e) => {
                    e.emit();
                    None
                }
            },
        );

    Ok(wrap_in_dummy_mod(
        model.dummy_mod_name("associations"),
        quote!(#(#tokens)*),
    ))
}
```


Overlapping Code:
```
derive(item: syn::DeriveInput) -> Result<proc_macro2::TokenStream, Diagnostic> {
let model = Model::from_item(&item)?;
let tokens = MetaItem::all_with_name(&item.attrs, "belongs_to")
.into_iter()
.filter_map(
|attr| match derive_belongs_to(&model, &item.generics, attr) {
Ok(t) => Some(t),
Err(e) => {
e.emit();
None
}
},
);
Ok(wrap_in_dummy_mod(
model.dummy_mod_name("associations"),
quote!(#(#tokens)*
```
<Overlap Ratio: 0.9664268585131894>

---

--- 128 --
Question ID: 78bee61259e517838765e26e9021310e19532ccc_0
Original Code:
```
pub fn parse_duration(s: &str) -> Option<Duration> {
    let mut digits = String::new();
    let mut unit = String::new();
    let mut reading_digits = true;
    for c in s.chars().filter(|c| !c.is_whitespace()) {
        if reading_digits {
            if c.is_digit(BASE_TEN) {
                digits.push(c);
            } else {
                reading_digits = false;
                unit.push(c)
            }
        } else {
            unit.push(c);
        }
    }

    if digits.is_empty() { return None; }

    let mk_duration: fn(i64) -> Duration = match &*unit {
        "ns" | "nanos" | "nano" | "nanoseconds" | "nanosecond" => Duration::nanoseconds,
        "us" | "micros" | "micro" | "microseconds" | "microsecond" => Duration::microseconds,
        "ms" | "millis" | "milli" | "milliseconds" | "millisecond" => Duration::milliseconds,
        "s" | "secs" | "sec" | "seconds" | "second" => Duration::seconds,
        "m" | "mins" | "min" | "minutes" | "minute" => Duration::minutes,
        "h" | "hours" | "hour" => Duration::hours,
        "d" | "days" | "day" => Duration::days,
        _ => return None
    };

    let n = digits.parse().unwrap();  // always correct
    Some(mk_duration(n))
}
```


Overlapping Code:
```
n(s: &str) -> Option<Duration> {
let mut digits = String::new();
let mut unit = String::new();
let mut reading_digits = true;
for c in s.chars().filter(|c| !c.is_whitespace()) {
if reading_digits {
if c.is_digit(BASE_TEN) {
digits.push(c);
} else {
reading_digits = false;
unit.push(c)
}
} else {
unit.push(c);
}
}
if digits.is_empty() { return None; }
let mk_duration: fn(i64) -> Duration = match &*unit {
"ns" | "nanos" | "nano" | "nanoseconds" | "nanosecond" => Duration::nanoseconds,
"us" | "micros" | "micro" | "microseconds" | "microsecond" => Duration::microseconds,
"ms" | "millis" | "milli" | "milliseconds" | "millisecond" => Duration::milliseconds,
"s" | "secs" | "sec" | "seconds" | "second" => Duration::seconds,
"m" | "mins" | "min" | "minutes" | "minute" => Duration::minutes,
"h" | "hours" | "hour" => Duration::hours,
"d" | "days" | "day" => Duration::days,
_ => return None
};
let n = digits.parse().unwrap(); // always correct
Some
```
<Overlap Ratio: 0.9615384615384616>

---

--- 129 --
Question ID: e4e9c39ce892196e7b4e05ec3c4238d0b15599e5_5
Original Code:
```
pub fn build_ssh_command_to_instance(
        instance_id: &str,
        ip_addr: &IpAddr,
        login_name: Option<&String>,
        ssh_opts: &[&str],
        remote_command_args: &[&str],
        timeout: Duration,
    ) -> Result<Command> {
        let mut ssh_opts: Vec<String> = ssh_opts.iter().map(|&s| s.to_string()).collect();
        if let Some(login_name) = login_name {
            ssh_opts.insert(0, "-l".to_owned());
            ssh_opts.insert(1, login_name.to_owned());
        };

        let mut remote_command_args: Vec<String> = remote_command_args.iter().map(|&s| s.to_string()).collect();

        let ssh_args = build_ssh_arguments(&ip_addr, &mut ssh_opts, &mut remote_command_args);

        let log_path = tempfile::NamedTempFile::new()
            .chain_err(|| ErrorKind::FailedToBuildSshCommand)?
            .path()
            .to_path_buf();
        let c = Command {
            id:      instance_id.to_owned(),
            cmd:     "ssh".to_owned(),
            args:    Some(ssh_args),
            cwd:     None,
            log:     log_path,
            timeout: Some(timeout),
        };
        Ok(c)
    }
```


Overlapping Code:
```
nce(
instance_id: &str,
ip_addr: &IpAddr,
login_name: Option<&String>,
ssh_opts: &[&str],
remote_command_args: &[&str],
timeout: Duration,
) -> Result<Command> {
let mut ssh_opts: Vec<String> = ssh_opts.iter().map(|&s| s.to_string()).collect();
if let Some(login_name) = login_name {
ssh_opts.insert(0, "-l".to_owned());
ssh_opts.insert(1, login_name.to_owned());
};
let mut remote_command_args: Vec<String> = remote_command_args.iter().map(|&s| s.to_string()).collect();
let ssh_args = build_ssh_arguments(&ip_addr, &mut ssh_opts, &mut remote_command_args);
let log_path = tempfile::NamedTempFile::new()
.chain_err(|| ErrorKind::FailedToBuildSshCommand)?
.path()
.to_path_buf();
let c = Command {
id: instance_id.to_owned(),
cmd: "ssh".to_owned(),
args: Some(ssh_args),
cwd: None,
log: log_path,
tim
```
<Overlap Ratio: 0.9259259259259259>

---

--- 130 --
Question ID: 53d4becce91a846b8e0d0f880bb3593ffb82e915_43
Original Code:
```
pub unsafe extern "C" fn wlr_surface_send_leave(mut surface: *mut wlr_surface,
                                                mut output: *mut wlr_output) {
    let mut client: *mut wl_client =
        wl_resource_get_client((*surface).resource);
    let mut resource: *mut wl_resource = 0 as *mut wl_resource;
    resource = 0 as *mut wl_resource;
    resource = wl_resource_from_link((*output).resources.next);
    while wl_resource_get_link(resource) !=
              &mut (*output).resources as *mut wl_list {
        if client == wl_resource_get_client(resource) {
            wl_surface_send_leave((*surface).resource, resource);
        }
        resource =
            wl_resource_from_link((*wl_resource_get_link(resource)).next)
    };
}
```


Overlapping Code:
```
_send_leave(mut surface: *mut wlr_surface,
mut output: *mut wlr_output) {
let mut client: *mut wl_client =
wl_resource_get_client((*surface).resource);
let mut resource: *mut wl_resource = 0 as *mut wl_resource;
resource = 0 as *mut wl_resource;
resource = wl_resource_from_link((*output).resources.next);
while wl_resource_get_link(resource) !=
&mut (*output).resources as *mut wl_list {
if client == wl_resource_get_client(resource) {
wl_surface_send_leave((*surface).resource, resource);
}
resource =
wl_resource_from_link((*wl_resource_get_link(resource)).next)
};
}
```
<Overlap Ratio: 0.9405940594059405>

---

--- 131 --
Question ID: be1d9f4b464389a8dd70f58b26b8dd892ece02e2_7
Original Code:
```
fn set_command() {
    assert_setting!("option1", "42", Set("option1".to_string(), Int(42)));
    assert_setting!("option1", "12.345", Set("option1".to_string(), Float(12.345)));
    assert_setting!("option1", "false", Set("option1".to_string(), Bool(false)));
    assert_setting!("option1", "true", Set("option1".to_string(), Bool(true)));
    assert_setting!("option1", "value", Set("option1".to_string(), Str("value".to_string())));
    assert_setting!("option1", "value with spaces", Set("option1".to_string(), Str("value with spaces".to_string())));
    assert_eq!(parse_string("set option1 = 42\nset option2 = 12.345"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
    assert_eq!(parse_string("set option1 = 42\nset option2 = 12.345\n"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
    assert_eq!(parse_string("set option1 = 42\n\nset option2 = 12.345\n"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
    assert_eq!(parse_string("  set    option1    =    42    "), vec![Set("option1".to_string(), Int(42))]);
}
```


Overlapping Code:
```
 {
assert_setting!("option1", "42", Set("option1".to_string(), Int(42)));
assert_setting!("option1", "12.345", Set("option1".to_string(), Float(12.345)));
assert_setting!("option1", "false", Set("option1".to_string(), Bool(false)));
assert_setting!("option1", "true", Set("option1".to_string(), Bool(true)));
assert_setting!("option1", "value", Set("option1".to_string(), Str("value".to_string())));
assert_setting!("option1", "value with spaces", Set("option1".to_string(), Str("value with spaces".to_string())));
assert_eq!(parse_string("set option1 = 42\nset option2 = 12.345"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
assert_eq!(parse_string("set option1 = 42\nset option2 = 12.345\n"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
assert_eq!(parse_string("set option1 = 42\n\nset option2 = 12.345\n"), vec![Set("option1".to_string(), Int(42)), Set("option2".to_string(), Float(12.345))]);
assert_eq!(parse_string(" set option1 = 42 "), vec![Set("option1".t
```
<Overlap Ratio: 0.9624197983501375>

---

--- 132 --
Question ID: 5652327da33a0f6fc607804ae111f4a5fc642430_3
Original Code:
```
fn test_example2() {
        // 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).
        let prog = vec![2, 3, 0, 3, 99];
        assert_eq!(eval(&prog, 3), 6);
    }
```


Overlapping Code:
```
ple2() {
// 2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).
let prog = vec![2, 3, 0, 3, 99];
assert_eq!(e
```
<Overlap Ratio: 0.7575757575757576>

---

--- 133 --
Question ID: aaa343b9c3f6dc86d8dafd26820f0757fa9a7f13_0
Original Code:
```
fn main() {
    let input = {
        let fname = std::env::args()
            .nth(1)
            .expect("Please give input as first argument!");
        std::fs::read_to_string(fname).unwrap()
    };

    // part one
    let module_fuel: i32 = input
        .lines()
        .map(|mass| mass.parse::<i32>().unwrap())
        .map(|mass| mass / 3 - 2)
        .sum();
    println!("Module fuel required: {}", module_fuel);

    // part one
    let total_fuel: i32 = input
        .lines()
        .map(|mass| mass.parse::<i32>().unwrap())
        .map(|mut mass| {
            let mut total = 0;
            loop {
                mass = mass / 3 - 2;
                if mass < 0 {
                    break;
                }
                total += mass;
            }
            total
        })
        .sum();
    println!("Total fuel required: {}", total_fuel);
}
```


Overlapping Code:
```
 {
let fname = std::env::args()
.nth(1)
.expect("Please give input as first argument!");
std::fs::read_to_string(fname).unwrap()
};
// part one
let module_fuel: i32 = input
.lines()
.map(|mass| mass.parse::<i32>().unwrap())
.map(|mass| mass / 3 - 2)
.sum();
println!("Module fuel required: {}", module_fuel);
// part one
let total_fuel: i32 = input
.lines()
.map(|mass| mass.parse::<i32>().unwrap())
.map(|mut mass| {
let mut total = 0;
loop {
mass = mass / 3 - 2;
if mass < 0 {
break;
}
total += mass;
}
total
})
.sum();
println!("Total fuel required: {}", total_fuel)
```
<Overlap Ratio: 0.9563025210084034>

---

--- 134 --
Question ID: d9449e8de10a9133e484394fe9859bc91333bdb7_0
Original Code:
```
fn stored_configuration_toml() {
        let original = create_test_configuration();
        let toml = toml::to_string(&original).unwrap();
        let deserialized: StoredConfiguration = toml::from_str(&toml).unwrap();
        assert_eq!(original, deserialized);
    }
```


Overlapping Code:
```
ored_configuration_toml() {
let original = create_test_configuration();
let toml = toml::to_string(&original).unwrap();
let deserialized: StoredConfiguration = toml::from_str(&toml).unwrap();
assert_eq!(original, deseriali
```
<Overlap Ratio: 0.9487179487179487>

---

--- 135 --
Question ID: 38db1695cf2cee41c36549f86781d18a9cf63ec0_7
Original Code:
```
fn test_with_fields() {
    let t = WithFieldsTemplate {
        names: (
            Name {
                first: "foo",
                last: "bar",
            },
            Name {
                first: "fOO",
                last: "bAR",
            },
        ),
    }; // instantiate your struct
    assert_eq!("Hello, foo bar and fOO bAR!", t.call().unwrap()); // then call it.
}
```


Overlapping Code:
```
() {
let t = WithFieldsTemplate {
names: (
Name {
first: "foo",
last: "bar",
},
Name {
first: "fOO",
last: "bAR",
},
),
}; // instantiate your struct
assert_eq!("Hello, foo bar and fOO bAR!", t.call().unwrap()); 
```
<Overlap Ratio: 0.8514056224899599>

---

--- 136 --
Question ID: 63ee7d95bc3e38ce182365b2cf49a9c3256cb4d0_0
Original Code:
```
pub fn create_rkf_stepper_subcommand(_parent_command_name: &'static str) -> Command<'static> {
    let command_name = "rkf_stepper";

    update_command_graph!(_parent_command_name, command_name);

    Command::new(command_name)
        .about("Use a Runge-Kutta-Fehlberg stepper")
        .long_about(
            "Use a Runge-Kutta-Fehlberg stepper.\n\
             The next position is computed with a Runge-Kutta scheme, and tbe resulting error\n\
             is estimated using an embedded lower-order step. The errors are used to adjust\n\
             the step length, and steps are re-attempted until the error is below a certain\n\
             tolerance.",
        )
        .arg(
            Arg::new("dense-step-length")
                .long("dense-step-length")
                .require_equals(true)
                .value_name("VALUE")
                .help("Step length to use for dense (uniform) output positions [Mm]\n")
                .takes_value(true)
                .default_value("0.01"),
        )
        .arg(
            Arg::new("max-step-attempts")
                .long("max-step-attempts")
                .require_equals(true)
                .value_name("NUMBER")
                .help("Maximum number of step attempts before terminating")
                .takes_value(true)
                .default_value("16"),
        )
        .arg(
            Arg::new("absolute-tolerance")
                .long("absolute-tolerance")
                .require_equals(true)
                .value_name("VALUE")
                .help("Absolute error tolerance for stepping")
                .takes_value(true)
                .default_value("1e-6"),
        )
        .arg(
            Arg::new("relative-tolerance")
                .long("relative-tolerance")
                .require_equals(true)
                .value_name("VALUE")
                .help("Relative error tolerance for stepping")
                .takes_value(true)
                .default_value("1e-6"),
        )
        .arg(
            Arg::new("safety-factor")
                .long("safety-factor")
                .require_equals(true)
                .value_name("VALUE")
                .help("Scaling factor for the error to reduce step length oscillations\n")
                .takes_value(true)
                .default_value("0.9"),
        )
        .arg(
            Arg::new("min-step-scale")
                .long("min-step-scale")
                .require_equals(true)
                .value_name("VALUE")
                .help("Smallest allowed scaling of the step size in one step")
                .takes_value(true)
                .default_value("0.2"),
        )
        .arg(
            Arg::new("max-step-scale")
                .long("max-step-scale")
                .require_equals(true)
                .value_name("VALUE")
                .help("Largest allowed scaling of the step size in one step")
                .takes_value(true)
                .default_value("10.0"),
        )
        .arg(
            Arg::new("initial-error")
                .long("initial-error")
                .require_equals(true)
                .value_name("VALUE")
                .help("Start value for stepping error")
                .takes_value(true)
                .default_value("1e-4"),
        )
        .arg(
            Arg::new("initial-step-length")
                .long("initial-step-length")
                .require_equals(true)
                .value_name("VALUE")
                .help("Initial step size")
                .takes_value(true)
                .default_value("1e-4"),
        )
        .arg(
            Arg::new("sudden-reversals-for-sink")
                .long("sudden-reversals-for-sink")
                .require_equals(true)
                .value_name("NUMBER")
                .help(
                    "Number of sudden direction reversals before the area is considered\n\
                     a sink",
                )
                .takes_value(true)
                .default_value("3"),
        )
        .arg(
            Arg::new("disable-pi-control")
                .long("disable-pi-control")
                .help(
                    "Disable Proportional Integral (PI) control used for stabilizing the stepping",
                ),
        )
        .arg(
            Arg::new("stepping-scheme")
                .long("stepping-scheme")
                .require_equals(true)
                .value_name("NAME")
                .help("Which Runge-Kutta-Fehlberg stepping scheme to use\n")
                .takes_value(true)
                .possible_values(&["rkf23", "rkf45"])
                .default_value("rkf45"),
        )
}
```


Overlapping Code:
```
er_subcommand(_parent_command_name: &'static str) -> Command<'static> {
let command_name = "rkf_stepper";
update_command_graph!(_parent_command_name, command_name);
Command::new(command_name)
.about("Use a Runge-Kutta-Fehlberg stepper")
.long_about(
"Use a Runge-Kutta-Fehlberg stepper.\n\
The next position is computed with a Runge-Kutta scheme, and tbe resulting error\n\
is estimated using an embedded lower-order step. The errors are used to adjust\n\
the step length, and steps are re-attempted until the error is below a certain\n\
tolerance.",
)
.arg(
Arg::new("dense-step-length")
.long("dense-step-length")
.require_equals(true)
.value_name("VALUE")
.help("Step length to use for dense (uniform) output positions [Mm]\n")
.takes_value(true)
.default_value("0.01"),
)
.arg(
Arg::new("max-step-attempts")
.long("max-step-attempts")
.require_equals(true)
.value_name("NUMBER")
.help("Maximum number of step attempts before terminating")
.takes_value(true)
.default_value("16"),
)
.arg(
Arg::new("absolute-tolerance")
.long("absolute-tolerance")
.require_equals(true)
.value_name("VALUE")
.help("Absolute error tolerance for stepping")
.takes_value(true)
.default_value("1e-6"),
)
.arg(
Arg::new("relative-tolerance")
.long("relative-tolerance")
.require_equals(true)
.value_name("VALUE")
.help("Relative error tolerance for stepping")
.takes_value(true)
.default_value("1e-6"),
)
.arg(
Arg::new("safety-factor")
.long("safety-factor")
.require_equals(true)
.value_name("VALUE")
.help("Scaling factor for the error to reduce step length oscillations\n")
.takes_value(true)
.default_value("0.9"),
)
.arg(
Arg::new("min-step-scale")
.long("min-ste
```
<Overlap Ratio: 0.9654768870684611>

---

--- 137 --
Question ID: 66865861197b2155e1c09f6108e6ff6943ea3ca2_1
Original Code:
```
pub fn generate_key()->[u8;32]{
    let mut rng = rand::thread_rng();
    let random:[u8;32] = rng.gen();
    let secret = key::SecretKey::from_slice(&random).unwrap();
    let mut return_slice:[u8;32] = [0;32];
    (0..32).for_each(|i|{
        return_slice[i] = secret[i];
    });
    return_slice
}
```


Overlapping Code:
```

let mut rng = rand::thread_rng();
let random:[u8;32] = rng.gen();
let secret = key::SecretKey::from_slice(&random).unwrap();
let mut return_slice:[u8;32] = [0;32];
(0..32).for_each(|i|{
return_slice[
```
<Overlap Ratio: 0.7547169811320755>

---

--- 138 --
Question ID: 70ebb8340de8eb4f2864aff55a425b894d26f778_6
Original Code:
```
fn cic() {
        init();

        let refe = b"GGATAACTCT";
        //           |||||
        let read = b"GGATATACTCT";

        let mut data: pcon::solid::Solid = pcon::solid::Solid::new(5);

        for kmer in cocktail::tokenizer::Tokenizer::new(refe, 5) {
            data.set(kmer, true);
        }

        let set: set::BoxKmerSet = Box::new(set::Pcon::new(data));

        let corrector = GapSize::new(&set, 2);

        assert_eq!(refe, corrector.correct(read).as_slice()); // test correction work
        assert_eq!(refe, corrector.correct(refe).as_slice()); // test not overcorrection
    }
```


Overlapping Code:
```
init();
let refe = b"GGATAACTCT";
// |||||
let read = b"GGATATACTCT";
let mut data: pcon::solid::Solid = pcon::solid::Solid::new(5);
for kmer in cocktail::tokenizer::Tokenizer::new(refe, 5) {
data.set(kmer, true);
}
let set: set::BoxKmerSet = Box::new(set::Pcon::new(data));
let corrector = GapSize::new(&set, 2);
assert_eq!(refe, corrector.correct(read).as_slice()); // test correction work
assert_eq!(refe, corrector.correct(refe).as_slice()); // test not overcorr
```
<Overlap Ratio: 0.9608247422680413>

---

--- 139 --
Question ID: 8fe71bc79ab690e4d10c32b6e8d596c010446e03_4
Original Code:
```
fn extract_trait_param_type<'a>(
    sess: &'a ParseSess,
    trait_ref: &ast::TraitRef,
) -> PResult<'a, ast::Ty> {
    assert_eq!(1, trait_ref.path.segments.len());
    let seg = &trait_ref.path.segments[0];
    let param = seg
        .parameters
        .as_ref()
        .ok_or_else(|| fatal_error(sess, trait_ref.path.span, "No type param"))?;
    match **param {
        ast::PathParameters::AngleBracketed(ref p) => {
            if p.types.len() != 1 {
                return Err(fatal_error(
                    sess,
                    trait_ref.path.span,
                    "Expect one type parameter",
                ));
            }
            let pty: &P<ast::Ty> = &p.types[0];
            Ok((**pty).clone())
        }
        _ => Err(fatal_error(
            sess,
            trait_ref.path.span,
            "Expect type params in <>",
        )),
    }
}
```


Overlapping Code:
```
 extract_trait_param_type<'a>(
sess: &'a ParseSess,
trait_ref: &ast::TraitRef,
) -> PResult<'a, ast::Ty> {
assert_eq!(1, trait_ref.path.segments.len());
let seg = &trait_ref.path.segments[0];
let param = seg
.parameters
.as_ref()
.ok_or_else(|| fatal_error(sess, trait_ref.path.span, "No type param"))?;
match **param {
ast::PathParameters::AngleBracketed(ref p) => {
if p.types.len() != 1 {
return Err(fatal_error(
sess,
trait_ref.path.span,
"Expect one type parameter",
));
}
let pty: &P<ast::Ty> = &p.types[0];
Ok((**pty).clone())
}
_ => Err(fatal_error(
sess,
trait_ref.path.span,
"Expect type pa
```
<Overlap Ratio: 0.9646302250803859>

---

--- 140 --
Question ID: ffef2c29479bce5ac9e6e0c155f6b7a23d555af7_0
Original Code:
```
fn hash( string: String ) -> String {
    let mut hasher = Sha1::new();
    hasher.update( string.as_bytes() );
    hasher.digest().to_string()
}
```


Overlapping Code:
```
ing: String ) -> String {
let mut hasher = Sha1::new();
hasher.update( string.as_bytes() );
hasher.digest().to_string()
```
<Overlap Ratio: 0.8947368421052632>

---

--- 141 --
Question ID: 56e24ff3f14534ce11dc14e4b54ec7e76665f8ee_1
Original Code:
```
pub fn save<T>(zipfilename: &str, filename: &str, data: &T) -> bool
where
    T: Serialize,
{
    let data: Vec<u8> = serialize(data).unwrap();
    let file = if let Ok(file) = File::create(path(zipfilename)) {
        file
    } else {
        return true;
    };
    let mut zip = zip::write::ZipWriter::new(file);
    let options = zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Deflated).unix_permissions(0o755);
    zip.start_file(filename, options).unwrap();
    zip.write_all(&data[..]).unwrap();

    zip.finish().unwrap();
    false
}
```


Overlapping Code:
```
pub fn save<T>(zipfilename: &str, filename: &str, data: &T) -> bool
where
T: Serialize,
{
let data: Vec<u8> = serialize(data).unwrap();
let file = if let Ok(file) = File::create(path(zipfilename)) {
file
} else {
return true;
};
let mut zip = zip::write::ZipWriter::new(file);
let options = zip::write::FileOptions::default().compression_method(zip::CompressionMethod::Deflated).unix_permissions(0o755);
zip.start_file(filename, options).unwrap();
zip.write_all(&data[..]).unwrap();
zip.finish().unwr
```
<Overlap Ratio: 0.9746588693957114>

---

--- 142 --
Question ID: 795715f1939b533a655add7d1fe557971f48d9a7_1
Original Code:
```
fn test_functional_process_file_green() {
        Command::cargo_bin("stevia")
            .unwrap()
            .arg("examples/example.ink")
            .assert()
            .success();

        // Check contents of output file
        let expected = "P;Hello there|P;I'm a VN written in the Ink format|P;Do you like it?|Q;Yes, I like it!;00120;No, I do not like it;00136|P;Thank you!|E;|P;Oh, I see|E;";
        let contents = read_to_string("example.stevia").expect("Cannot find .stevia file");

        assert_eq!(expected, contents);

        clean();
    }
```


Overlapping Code:
```
le_green() {
Command::cargo_bin("stevia")
.unwrap()
.arg("examples/example.ink")
.assert()
.success();
// Check contents of output file
let expected = "P;Hello there|P;I'm a VN written in the Ink format|P;Do you like it?|Q;Yes, I like it!;00120;No, I do not like it;00136|P;Thank you!|E;|P;Oh, I see|E;";
let contents = read_to_string("example.stevia").expect("Cannot find .stevia file");
assert_eq!(
```
<Overlap Ratio: 0.8695652173913043>

---

--- 143 --
Question ID: b8be3287b5d43ce8bc7ea21333e00d3b9139acee_7
Original Code:
```
pub fn task( data : &str, iter_count : i32 ) -> i32 {
    let map = create_map( data );
    let init = ".#./..#/###";
    let init_image = to_image( init );
    let mut image = init_image;
    for _ in 0 .. iter_count {
        let n = to_side( image.len() );
        let is_by_2 = n % 2 == 0;
        let is_by_3 = n % 3 == 0;
        let size = if is_by_2 { 2 } else if is_by_3 { 3 } else { panic!("not expacted") };
        let image2 : Image2 = split( &image, size );
        let new_image2 : Image2 = image2.iter()
            .map( |i| ( *i.0, transform(i.1, &map ) ) ).collect();
        image = unify( &new_image2 );
    }
    image.iter().filter( |i| *i.1 == '#' ).count() as i32
}
```


Overlapping Code:
```
( data : &str, iter_count : i32 ) -> i32 {
let map = create_map( data );
let init = ".#./..#/###";
let init_image = to_image( init );
let mut image = init_image;
for _ in 0 .. iter_count {
let n = to_side( image.len() );
let is_by_2 = n % 2 == 0;
let is_by_3 = n % 3 == 0;
let size = if is_by_2 { 2 } else if is_by_3 { 3 } else { panic!("not expacted") };
let image2 : Image2 = split( &image, size );
let new_image2 : Image2 = image2.iter()
.map( |i| ( *i.0, transform(i.1, &map ) ) ).collect();
image = unify( &new_image2 );
}
image.iter().filter( |
```
<Overlap Ratio: 0.9259259259259259>

---

--- 144 --
Question ID: 6b663401101c386b1b9edf492dc35440f49edf40_0
Original Code:
```
fn parse_rpc_attr(attr: &Attribute) -> Vec<(AttrKey, AttrValue)> {
    let meta = match attr.parse_meta() {
        Ok(m) => m,
        Err(_) => return Vec::new(),
    };

    if &format!("{}", meta.name()) != "rpc" {
        return Vec::new();
    }

    match meta {
        Meta::List(list) => list
            .nested
            .iter()
            .flat_map(|met| match met {
                NestedMeta::Meta(m) => parse_rpc_attr_meta(m),
                _ => Vec::new(),
            })
            .collect(),
        _ => Vec::new(),
    }
}
```


Overlapping Code:
```
r: &Attribute) -> Vec<(AttrKey, AttrValue)> {
let meta = match attr.parse_meta() {
Ok(m) => m,
Err(_) => return Vec::new(),
};
if &format!("{}", meta.name()) != "rpc" {
return Vec::new();
}
match meta {
Meta::List(list) => list
.nested
.iter()
.flat_map(|met| match met {
NestedMeta::Meta(m) => parse_rpc_attr_meta(m),
_ => Vec::new(),
})
.collect(),
```
<Overlap Ratio: 0.8928571428571429>

---

--- 145 --
Question ID: 141117cc909f026ccff6c9b0051d5dace3ad9055_17
Original Code:
```
fn alu2_bic(arm: &mut Arm7TDMI, op: ThumbOp) {
    let (rd_index, rd, rs) = decode_alu2_reg(arm, op);
    let result = rd & !rs;
    set_zn(arm, result);
    arm.regs[rd_index] = result;
}
```


Overlapping Code:
```
(arm: &mut Arm7TDMI, op: ThumbOp) {
let (rd_index, rd, rs) = decode_alu2_reg(arm, op);
let result = rd & !rs;
set_zn(arm, result);
arm.regs[rd_index] = result;
```
<Overlap Ratio: 0.9244186046511628>

---

--- 146 --
Question ID: f02f604bf7808c8de5c8ef9656a8dddda99a4198_14
Original Code:
```
fn shared_wtypesbase() {
    use winapi::shared::wtypesbase::*;
    assert_eq!(size_of::<COAUTHIDENTITY>(), 28);
    assert_eq!(align_of::<COAUTHIDENTITY>(), 4);
    assert_eq!(size_of::<COAUTHINFO>(), 28);
    assert_eq!(align_of::<COAUTHINFO>(), 4);
    assert_eq!(size_of::<BYTE_BLOB>(), 8);
    assert_eq!(align_of::<BYTE_BLOB>(), 4);
    assert_eq!(size_of::<WORD_BLOB>(), 8);
    assert_eq!(align_of::<WORD_BLOB>(), 4);
    assert_eq!(size_of::<WORD_BLOB>(), 8);
    assert_eq!(align_of::<WORD_BLOB>(), 4);
    assert_eq!(size_of::<FLAGGED_BYTE_BLOB>(), 12);
    assert_eq!(align_of::<FLAGGED_BYTE_BLOB>(), 4);
    assert_eq!(size_of::<FLAGGED_WORD_BLOB>(), 12);
    assert_eq!(align_of::<FLAGGED_WORD_BLOB>(), 4);
    assert_eq!(size_of::<BYTE_SIZEDARR>(), 8);
    assert_eq!(align_of::<BYTE_SIZEDARR>(), 4);
    assert_eq!(size_of::<WORD_SIZEDARR>(), 8);
    assert_eq!(align_of::<WORD_SIZEDARR>(), 4);
    assert_eq!(size_of::<DWORD_SIZEDARR>(), 8);
    assert_eq!(align_of::<DWORD_SIZEDARR>(), 4);
    assert_eq!(size_of::<HYPER_SIZEDARR>(), 8);
    assert_eq!(align_of::<HYPER_SIZEDARR>(), 4);
    assert_eq!(size_of::<BLOB>(), 8);
    assert_eq!(align_of::<BLOB>(), 4);
}
```


Overlapping Code:
```
se() {
use winapi::shared::wtypesbase::*;
assert_eq!(size_of::<COAUTHIDENTITY>(), 28);
assert_eq!(align_of::<COAUTHIDENTITY>(), 4);
assert_eq!(size_of::<COAUTHINFO>(), 28);
assert_eq!(align_of::<COAUTHINFO>(), 4);
assert_eq!(size_of::<BYTE_BLOB>(), 8);
assert_eq!(align_of::<BYTE_BLOB>(), 4);
assert_eq!(size_of::<WORD_BLOB>(), 8);
assert_eq!(align_of::<WORD_BLOB>(), 4);
assert_eq!(size_of::<WORD_BLOB>(), 8);
assert_eq!(align_of::<WORD_BLOB>(), 4);
assert_eq!(size_of::<FLAGGED_BYTE_BLOB>(), 12);
assert_eq!(align_of::<FLAGGED_BYTE_BLOB>(), 4);
assert_eq!(size_of::<FLAGGED_WORD_BLOB>(), 12);
assert_eq!(align_of::<FLAGGED_WORD_BLOB>(), 4);
assert_eq!(size_of::<BYTE_SIZEDARR>(), 8);
assert_eq!(align_of::<BYTE_SIZEDARR>(), 4);
assert_eq!(size_of::<WORD_SIZEDARR>(), 8);
assert_eq!(align_of::<WORD_SIZEDARR>(), 4);
assert_eq!(size_of::<DWORD_SIZEDARR>(), 8);
assert_eq!(align_of::<DWORD_SIZEDARR>(), 4);
assert_eq!(size_of::<HYPER_SIZEDARR>(), 8);
assert_eq!(align_of::<HYPER_SIZEDARR>(), 4);
assert_eq!(size_of::<BLOB>(), 8);
assert_eq!(align_of::<B
```
<Overlap Ratio: 0.971375807940905>

---

--- 147 --
Question ID: a4d9a79eb9bbafb3fe8f46e3f83c8a2712f51b1b_33
Original Code:
```
fn test_game_id() {
        assert_parsed!(
            Event::GameId {
                id: "CHN201604110".into()
            },
            game_id("id,CHN201604110")
        );
        assert!(game_id("asdlfk,3,5").is_err());
        assert!(game_id("id,3455").is_err());
    }
```


Overlapping Code:
```
st_game_id() {
assert_parsed!(
Event::GameId {
id: "CHN201604110".into()
},
game_id("id,CHN201604110")
);
assert!(game_id("asdlfk,3,5").is_err());
ass
```
<Overlap Ratio: 0.7853403141361257>

---

--- 148 --
Question ID: 793c4bcf09ef5b7b6fc9e715a78847c15658f9b5_28
Original Code:
```
fn relay_addr(
    json_cfg: &str,
) -> Result<String, Error> {
    let config = MobileWalletCfg::from_str(json_cfg)?;
    let wallet = get_wallet_instance(config.clone())?;
    Ok(grinrelay_address(
        wallet.clone(),
        config.grinrelay_config.clone().unwrap_or_default(),
    )?)
}
```


Overlapping Code:
```
: &str,
) -> Result<String, Error> {
let config = MobileWalletCfg::from_str(json_cfg)?;
let wallet = get_wallet_instance(config.clone())?;
Ok(grinrelay_address(
wallet.clone(),
config.grinrelay_config.clone().unwrap_or_default(),
```
<Overlap Ratio: 0.8875968992248062>

---

--- 149 --
Question ID: debb9911930aebf69268ceb52a490f921caa45cf_1
Original Code:
```
fn ansi_rgb_colors() {
        use super::ColorExt;
        assert_eq!(Color::Rgb(0x12, 0x89, 0xef).to_rgb(), (0x12, 0x89, 0xef));
        assert_eq!(Color::Rgb(0xff, 0xff, 0xff).to_rgb(), (0xff, 0xff, 0xff));
        assert_eq!(Color::Rgb(0, 0, 0).to_rgb(), (0, 0, 0));
    }
```


Overlapping Code:
```
s() {
use super::ColorExt;
assert_eq!(Color::Rgb(0x12, 0x89, 0xef).to_rgb(), (0x12, 0x89, 0xef));
assert_eq!(Color::Rgb(0xff, 0xff, 0xff).to_rgb(), (0xff, 0xff, 0xff));
assert_eq!(Color::Rgb(0, 0, 0).
```
<Overlap Ratio: 0.8333333333333334>

---

--- 150 --
Question ID: cf28a84a0251ce76297200a96cf7eb2b418bdb3b_0
Original Code:
```
fn as_unix_millis() {
        assert_eq!(Some(100),
                   (UNIX_EPOCH + Duration::from_millis(100)).as_unix_millis());
        assert_eq!(Some(-100),
                   (UNIX_EPOCH - Duration::from_millis(100)).as_unix_millis());
        assert_eq!(None,
                   (UNIX_EPOCH - Duration::from_secs(1 << 60)).as_unix_millis());
    }
```


Overlapping Code:
```
nix_millis() {
assert_eq!(Some(100),
(UNIX_EPOCH + Duration::from_millis(100)).as_unix_millis());
assert_eq!(Some(-100),
(UNIX_EPOCH - Duration::from_millis(100)).as_unix_millis());
assert_eq!(None,
(UNIX_EPOCH - Duration::from_secs(1 << 60)).as_unix
```
<Overlap Ratio: 0.9259259259259259>

---

--- 151 --
Question ID: 6a486030df4a2fcec1c8152076ec128bf46681ee_0
Original Code:
```
fn main() -> Result<(), Error> {
    // Lets get some logs out
    TermLogger::init(LevelFilter::Info, Config::default())?;

    let starstruck = StarstruckBuilder::new().init()?;
    starstruck.run()?;

    Ok(())
}
```


Overlapping Code:
```
 Error> {
// Lets get some logs out
TermLogger::init(LevelFilter::Info, Config::default())?;
let starstruck = StarstruckBuilder::new().init()?;
starst
```
<Overlap Ratio: 0.7731958762886598>

---

--- 152 --
Question ID: d680324d013bb719f96d055ca5c2fdd33a9ebae3_1
Original Code:
```
fn download(url: &str, dest_filename: &Path) -> Result<Interactions, failure::Error> {
    let data_dir = create_data_dir()?;
    let desired_filename = data_dir.join(dest_filename);

    if !desired_filename.exists() {
        let temp_filename = env::temp_dir().join(
            rand::thread_rng()
                .sample_iter(&rand::distributions::Alphanumeric)
                .take(10)
                .collect::<String>(),
        );

        let file = File::create(&temp_filename)?;
        let mut writer = BufWriter::new(file);

        let mut response = reqwest::get(url)?;
        response.copy_to(&mut writer)?;

        rename(temp_filename, &desired_filename)?;
    }

    let mut reader = csv::Reader::from_path(desired_filename)?;
    let interactions: Vec<Interaction> = reader.deserialize().collect::<Result<Vec<_>, _>>()?;

    Ok(Interactions::from(interactions))
}
```


Overlapping Code:
```
r, dest_filename: &Path) -> Result<Interactions, failure::Error> {
let data_dir = create_data_dir()?;
let desired_filename = data_dir.join(dest_filename);
if !desired_filename.exists() {
let temp_filename = env::temp_dir().join(
rand::thread_rng()
.sample_iter(&rand::distributions::Alphanumeric)
.take(10)
.collect::<String>(),
);
let file = File::create(&temp_filename)?;
let mut writer = BufWriter::new(file);
let mut response = reqwest::get(url)?;
response.copy_to(&mut writer)?;
rename(temp_filename, &desired_filename)?;
}
let mut reader = csv::Reader::from_path(desired_filename)?;
let interactions: Vec<Interaction> = reader.deserialize().collect::<Result<Vec<_>, _>>()?;
Ok(Interactions::fro
```
<Overlap Ratio: 0.948509485094851>

---

--- 153 --
Question ID: bf8e6ec5bd774f4b8dc104e6b26e1bc0825fc19d_4
Original Code:
```
pub fn purge_handled_balls_from_hash_tree(db: &Connection) -> Result<()> {
    let mut stmt = db.prepare_cached(
        "SELECT ball FROM hash_tree_balls \
         CROSS JOIN balls USING(ball)",
    )?;
    let balls = stmt.query_map(&[], |row| row.get::<_, String>(0))?;

    let mut stmt = db.prepare_cached("DELETE FROM hash_tree_balls WHERE ball=?")?;
    for ball in balls {
        stmt.execute(&[&ball?])?;
    }
    Ok(())
}
```


Overlapping Code:
```
ub fn purge_handled_balls_from_hash_tree(db: &Connection) -> Result<()> {
let mut stmt = db.prepare_cached(
"SELECT ball FROM hash_tree_balls \
CROSS JOIN balls USING(ball)",
)?;
let balls = stmt.query_map(&[], |row| row.get::<_, String>(0))?;
let mut stmt = db.prepare_cached("DELETE FROM hash_tree_balls WHERE ball=?")?;
for ball in balls {
stmt.ex
```
<Overlap Ratio: 0.9210526315789473>

---

--- 154 --
Question ID: 332f83b92e5efc550367fadde9ff23955e525dd6_3
Original Code:
```
fn test_generate_continuous() {
        let grad_desc = color::GradientDescriptor::new(vec![
            Lch::from_color(color::ColorType::new(0., 0., 0., 1.)),
            Lch::from_color(color::ColorType::new(0.5, 0.5, 0.5, 1.)),
            Lch::from_color(color::ColorType::new(1., 1., 1., 1.)),
        ]);

        let colors = grad_desc.generate(12, color::GradientGeneratorType::Continuous);
        assert_eq!(colors.len(), 12);

        assert_eq!(colors[0].chroma, 0.0);
        assert_eq!(colors[4].chroma, 0.0);
        assert_eq!(colors[8].chroma, 0.0);
    }
```


Overlapping Code:
```
d_desc = color::GradientDescriptor::new(vec![
Lch::from_color(color::ColorType::new(0., 0., 0., 1.)),
Lch::from_color(color::ColorType::new(0.5, 0.5, 0.5, 1.)),
Lch::from_color(color::ColorType::new(1., 1., 1., 1.)),
]);
let colors = grad_desc.generate(12, color::GradientGeneratorType::Continuous);
assert_eq!(colors.len(), 12);
assert_eq!(colors[0].chroma, 0.0);
assert_eq!(colors[4].chroma, 0.0);
assert_eq!(colors[8].chroma, 0.0);
```
<Overlap Ratio: 0.9136842105263158>

---

--- 155 --
Question ID: 07d3c69498cd95b7c29a43403d451c0281bec4fc_5
Original Code:
```
fn test_intersection_none() {
        let r1 = RectRange::from_ranges(4..7, 3..5).unwrap();
        let r2 = RectRange::from_ranges(7..9, 5..6).unwrap();
        assert!(r1.intersection(&r2).is_none());
    }
```


Overlapping Code:
```

let r1 = RectRange::from_ranges(4..7, 3..5).unwrap();
let r2 = RectRange::from_ranges(7..9, 5..6).unwrap();
asser
```
<Overlap Ratio: 0.6333333333333333>

---

--- 156 --
Question ID: 66aa4ba1a1fd6eb6aa8f48ca4e62531839e0478f_4
Original Code:
```
fn test_alloc_fil_second_hole() {
        let mut alloc = Allocator::new();
        let first = alloc.alloc(2, 4);
        let sec = alloc.alloc(3, 8);
        alloc.free(sec, 3 + 1);
        alloc.free(first, 2 + 1);
        println!("fail here \n\n{}\n{:?}\n\n", alloc.first_hole, alloc.heap);
        println!("first hole : {}", alloc.first_hole);
        // first is before the 3. link to 0
        assert_eq!(alloc.heap(), vec![3, 3, 0, 7, 4, 0, 0, 0, MAX_HEAP_SIZE]);
        alloc.alloc(3, 8);
        assert_eq!(alloc.heap(), vec![7, 3, 0, 8, 4, 0, 0, 0, MAX_HEAP_SIZE]);
    }
```


Overlapping Code:
```
_alloc_fil_second_hole() {
let mut alloc = Allocator::new();
let first = alloc.alloc(2, 4);
let sec = alloc.alloc(3, 8);
alloc.free(sec, 3 + 1);
alloc.free(first, 2 + 1);
println!("fail here \n\n{}\n{:?}\n\n", alloc.first_hole, alloc.heap);
println!("first hole : {}", alloc.first_hole);
// first is before the 3. link to 0
assert_eq!(alloc.heap(), vec![3, 3, 0, 7, 4, 0, 0, 0, MAX_HEAP_SIZE]);
alloc.alloc(3, 8);
assert_eq!(alloc.heap(), vec![7, 3, 
```
<Overlap Ratio: 0.9127789046653144>

---

--- 157 --
Question ID: ede8b8f9c2808f2f605471faa9ab0f2e263c0969_3
Original Code:
```
fn parse_use4() {
    let input = "use";
    let expected_output = IResult::Incomplete(Needed::Unknown);

    let result = parse_use(input);

    assert_eq!(result, expected_output);
}
```


Overlapping Code:
```

let input = "use";
let expected_output = IResult::Incomplete(Needed::Unknown);
let result = parse_use(input);
assert_eq!(result, expec
```
<Overlap Ratio: 0.8132530120481928>

---

--- 158 --
Question ID: 93f71f55ff58446c73eaee318546064439cbdfde_0
Original Code:
```
fn create_task() {
        let domain = "atcoder.jp".to_string();
        let path = "/contests/abc125/tasks".to_string();

        let result = atcoder::get_tasks(&domain, &path);
        let lang_ja = atcoder::Lang::Ja;

        let mut task_result = vec![];
        if let Some(tasks) = result {
            for task in tasks {
                task_result.push(Task::new(task.title, task.link, lang_ja));
            }
        } else {
            assert!(false);
        }

        let answer = vec![
            Task::new(
                "A: Biscuit Generator".to_string(),
                "https://atcoder.jp/contests/abc125/tasks/abc125_a".to_string(),
                atcoder::Lang::Ja,
            ),
            Task::new(
                "B: Resale".to_string(),
                "https://atcoder.jp/contests/abc125/tasks/abc125_b".to_string(),
                atcoder::Lang::Ja,
            ),
            Task::new(
                "C: GCD on Blackboard".to_string(),
                "https://atcoder.jp/contests/abc125/tasks/abc125_c".to_string(),
                atcoder::Lang::Ja,
            ),
            Task::new(
                "D: Flipping Signs".to_string(),
                "https://atcoder.jp/contests/abc125/tasks/abc125_d".to_string(),
                atcoder::Lang::Ja,
            ),
        ];
        assert_eq!(answer.len(), task_result.len());
        for i in 0..answer.len() {
            assert_eq!(answer[i], task_result[i]);
        }
    }
```


Overlapping Code:
```
"atcoder.jp".to_string();
let path = "/contests/abc125/tasks".to_string();
let result = atcoder::get_tasks(&domain, &path);
let lang_ja = atcoder::Lang::Ja;
let mut task_result = vec![];
if let Some(tasks) = result {
for task in tasks {
task_result.push(Task::new(task.title, task.link, lang_ja));
}
} else {
assert!(false);
}
let answer = vec![
Task::new(
"A: Biscuit Generator".to_string(),
"https://atcoder.jp/contests/abc125/tasks/abc125_a".to_string(),
atcoder::Lang::Ja,
),
Task::new(
"B: Resale".to_string(),
"https://atcoder.jp/contests/abc125/tasks/abc125_b".to_string(),
atcoder::Lang::Ja,
),
Task::new(
"C: GCD on Blackboard".to_string(),
"https://atcoder.jp/contests/abc125/tasks/abc125_c".to_string(),
atcoder::Lang::Ja,
),
Task::new(
"D: Flipping Signs".to_string(),
"https://atcoder.jp/contests/abc125/tasks/abc125_d".to_string(),
atcoder::Lang::Ja,
),
];
assert_eq!(answer.len(), task_result.len());
for i in 0..answer.len() {
assert_
```
<Overlap Ratio: 0.9341199606686332>

---

--- 159 --
Question ID: ce1a663d7060e0580e0bf6949cbd1522434a345d_12
Original Code:
```
fn draw_polar_line_bottom_left_to_top_right() {
        let actual = image_with_polar_line(5, 5, 3.0, 45, Luma([1]));
        let expected = gray_image!(
            0, 0, 0, 0, 1;
            0, 0, 0, 1, 0;
            0, 0, 1, 0, 0;
            0, 1, 0, 0, 0;
            1, 0, 0, 0, 0);
        assert_pixels_eq!(actual, expected);
    }
```


Overlapping Code:
```
line_bottom_left_to_top_right() {
let actual = image_with_polar_line(5, 5, 3.0, 45, Luma([1]));
let expected = gray_image!(
0, 0, 0, 0, 1;
0, 0, 0, 1, 0;
0, 0, 1, 0, 0;
0, 1, 0, 0, 0;
1, 0, 0, 0, 0);
assert_pixels_eq!(actual
```
<Overlap Ratio: 0.8888888888888888>

---

--- 160 --
Question ID: 361786427b43e63c96e1572d6ae73b7ec03b5555_4
Original Code:
```
fn menu_loop() {
    let mut keep_playing = true;
    while keep_playing {
        game_loop();
        keep_playing = play_again();
    }
    println!("Bye.");
}
```


Overlapping Code:
```
nu_loop() {
let mut keep_playing = true;
while keep_playing {
game_loop();
keep_playing = play_again
```
<Overlap Ratio: 0.7692307692307693>

---

--- 161 --
Question ID: 7e0adff604bbf844ea75c468311965832ab8a9aa_0
Original Code:
```
pub fn parse(args: &ArgMatches, config: SetupConfig) -> Result<DeleteNode, Error> {
    let tendermint_key = parse_tendermint_key(args)?;
    let eth = parse_ethereum_args(args, config)?;

    Ok(DeleteNode {
        tendermint_key,
        eth,
    })
}
```


Overlapping Code:
```
 fn parse(args: &ArgMatches, config: SetupConfig) -> Result<DeleteNode, Error> {
let tendermint_key = parse_tendermint_key(args)?;
let eth = parse_ethereum_args(args, config)?;
Ok(DeleteN
```
<Overlap Ratio: 0.8461538461538461>

---

--- 162 --
Question ID: f2372cd5c8d2fa1010f169daaea859147731d6f4_2
Original Code:
```
fn test_pool_serialize_toml() {
    let config_a = PoolConfig::default();

    let res = config_a.to_toml();
    assert!(res.is_ok());
    let toml = res.unwrap();

    let res = PoolConfig::from_toml(&toml);
    assert!(res.is_ok());
    let config_b = res.unwrap();

    assert_eq!(config_a, config_b)
}
```


Overlapping Code:
```
alize_toml() {
let config_a = PoolConfig::default();
let res = config_a.to_toml();
assert!(res.is_ok());
let toml = res.unwrap();
let res = PoolConfig::from_toml(&toml);
assert!(res.is_ok());
let config_b = res.unwrap();
assert_eq!(config_a, config_b
```
<Overlap Ratio: 0.9259259259259259>

---

--- 163 --
Question ID: ad88834532221493e9aed8fbbd37c0207d11156b_8
Original Code:
```
fn ind_mut() {
    let mut x = RwLockStorage::new();
    x.allocate_for::<usize>();
    x.insert(0usize).unwrap();
    x.insert(1usize).unwrap();
    {
        let y = x.get::<&mut [usize]>();
        ok!(y, 0, [0])[0] = 10;
    }
    {
        let y = x.get::<&mut [usize]>();
        ok!(y, 1, [1]);
    }
    {
        let y = x.get::<&mut [usize]>();
        let z = x.get::<&mut [usize]>();
        err!(z, ErrorDesc::BorrowedIncompatibly);
        ok!(y, 10, [0]);
    }
}
```


Overlapping Code:
```
fn ind_mut() {
let mut x = RwLockStorage::new();
x.allocate_for::<usize>();
x.insert(0usize).unwrap();
x.insert(1usize).unwrap();
{
let y = x.get::<&mut [usize]>();
ok!(y, 0, [0])[0] = 10;
}
{
let y = x.get::<&mut [usize]>();
ok!(y, 1, [1]);
}
{
let y = x.get::<&mut [usize]>();
let z = x.get::<&mut [usize]>();
err!(z, ErrorDesc::BorrowedIncompatibly);
```
<Overlap Ratio: 0.9438502673796791>

---

--- 164 --
Question ID: b0d399e938b989f7d14a3334b8ab01f8ea791fcb_8
Original Code:
```
fn find_stable_conflicting_units(
    db: &Connection,
    unit_prop: &graph::UnitProps,
) -> Result<Vec<String>> {
    // units come here sorted by original unit,
    //so the smallest original on the same MCI comes first and will become good,
    //all others will become final-bad
    let mut stmt = db.prepare_cached(
        "SELECT competitor_units.* \
        FROM unit_authors AS this_unit_authors \
        JOIN unit_authors AS competitor_unit_authors USING(address) \
        JOIN units AS competitor_units ON competitor_unit_authors.unit=competitor_units.unit \
        JOIN units AS this_unit ON this_unit_authors.unit=this_unit.unit \
        WHERE this_unit_authors.unit=? AND competitor_units.is_stable=1 AND +competitor_units.sequence='good' \
            -- if it were main_chain_index <= this_unit_limci, the competitor would've been included \
            AND (competitor_units.main_chain_index > this_unit.latest_included_mc_index) \
            AND (competitor_units.main_chain_index <= this_unit.main_chain_index)",
    )?;
    let rows = stmt.query_map(&[&unit_prop.unit], |row| graph::UnitProps {
        unit: row.get("unit"),
        level: row.get("level"),
        latest_included_mc_index: row.get("latest_included_mc_index"),
        main_chain_index: row.get("main_chain_index"),
        is_on_main_chain: row.get("is_on_main_chain"),
        is_free: row.get("is_free"),
    })?;

    let mut conflicting_units = Vec::new();
    for row in rows {
        let row = row?;
        if graph::compare_unit_props(db, &row, unit_prop)? == None {
            conflicting_units.push(row.unit);
        }
    }

    Ok(conflicting_units)
}
```


Overlapping Code:
```
Connection,
unit_prop: &graph::UnitProps,
) -> Result<Vec<String>> {
// units come here sorted by original unit,
//so the smallest original on the same MCI comes first and will become good,
//all others will become final-bad
let mut stmt = db.prepare_cached(
"SELECT competitor_units.* \
FROM unit_authors AS this_unit_authors \
JOIN unit_authors AS competitor_unit_authors USING(address) \
JOIN units AS competitor_units ON competitor_unit_authors.unit=competitor_units.unit \
JOIN units AS this_unit ON this_unit_authors.unit=this_unit.unit \
WHERE this_unit_authors.unit=? AND competitor_units.is_stable=1 AND +competitor_units.sequence='good' \
-- if it were main_chain_index <= this_unit_limci, the competitor would've been included \
AND (competitor_units.main_chain_index > this_unit.latest_included_mc_index) \
AND (competitor_units.main_chain_index <= this_unit.main_chain_index)",
)?;
let rows = stmt.query_map(&[&unit_prop.unit], |row| graph::UnitProps {
unit: row.get("unit"),
level: row.get("level"),
latest_included_mc_index: row.get("latest_included_mc_index"),
main_chain_index: row.get("main_chain_index"),
is_on_main_chain: row.get("is_on_main_chain"),
is_free: row.get("is_free"),
})?;
let mut conflicting_units = Vec::new();
for row in rows {
let row = row?;
if graph::compare_unit_props(db, &row, unit_prop)? == None {
conflicting_units.push(row.unit);
}
}
Ok(conflicting_units)

```
<Overlap Ratio: 0.9722222222222222>

---

--- 165 --
Question ID: 9ecff8a3f9b50a3fe4c595109bb5cffdf777d1f8_1
Original Code:
```
fn CalculateDeltaWeight1(number: i32, I2HWeight: [[f64;4];3], H2OWeight: [[f64;3];4], InputBias: [f64;4], HiddenBias: [f64;3], OutputBias: [f64;4], TeacherSignal: [f64;4]) -> [[f64;4];3] {
    let mut NeuralNetwork = NeuronAndWeight::new(number, I2HWeight, H2OWeight, InputBias, HiddenBias, OutputBias, TeacherSignal);
    let mut inputlayer = NeuralNetwork.inputlayer();
    let mut Hiddenlayer = NeuralNetwork.Hiddenlayer(inputlayer);
    let mut Outputlayer = NeuralNetwork.Outputlayer(Hiddenlayer);
    let mut DeltaWeight: [[f64;4];3] = [[0.0;4];3];
    for i in 0..3{
        for j in 0..4{
            DeltaWeight[i][j] = -0.19 * (Outputlayer[j] - TeacherSignal[j]) * Outputlayer[j] * (1.0 - Outputlayer[j]) * Hiddenlayer[i];
        }
    }
    DeltaWeight
}
```


Overlapping Code:
```
I2HWeight: [[f64;4];3], H2OWeight: [[f64;3];4], InputBias: [f64;4], HiddenBias: [f64;3], OutputBias: [f64;4], TeacherSignal: [f64;4]) -> [[f64;4];3] {
let mut NeuralNetwork = NeuronAndWeight::new(number, I2HWeight, H2OWeight, InputBias, HiddenBias, OutputBias, TeacherSignal);
let mut inputlayer = NeuralNetwork.inputlayer();
let mut Hiddenlayer = NeuralNetwork.Hiddenlayer(inputlayer);
let mut Outputlayer = NeuralNetwork.Outputlayer(Hiddenlayer);
let mut DeltaWeight: [[f64;4];3] = [[0.0;4];3];
for i in 0..3{
for j in 0..4{
DeltaWeight[i][j] = -0.19 * (Outputlayer[j] - TeacherSignal[j]) * Outputlayer[j] * (1.0 - Outputlayer[j]) * Hiddenlayer[i];
}
}
D
```
<Overlap Ratio: 0.9291784702549575>

---

--- 166 --
Question ID: 259330ac289cd54ba2486b224d81e30bf7572268_1
Original Code:
```
fn rename() -> Result<()> {
        let mut fs = MemoryFileSystem::default();
        fs.write("/a/b/hello.txt", "blue")?;
        assert!(fs.exists("/a/b/hello.txt"));

        fs.rename("/a/b/hello.txt", "/a/b2/hello.txt")?;
        assert!(!fs.exists("/a/b/hello.txt"));
        assert!(fs.exists("/a/b2/hello.txt"));

        fs.rename("/a/b2", "/a/b3")?;
        assert!(!fs.exists("/a/b/hello.txt"));
        assert!(!fs.exists("/a/b2/hello.txt"));
        assert!(fs.exists("/a/b3/hello.txt"));

        Ok(())
    }
```


Overlapping Code:
```
FileSystem::default();
fs.write("/a/b/hello.txt", "blue")?;
assert!(fs.exists("/a/b/hello.txt"));
fs.rename("/a/b/hello.txt", "/a/b2/hello.txt")?;
assert!(!fs.exists("/a/b/hello.txt"));
assert!(fs.exists("/a/b2/hello.txt"));
fs.rename("/a/b2", "/a/b3")?;
assert!(!fs.exists("/a/b/hello.txt"));
assert!(!fs.exists("/a/b2/hello.txt"));
assert!(fs.exist
```
<Overlap Ratio: 0.8177570093457944>

---

--- 167 --
Question ID: ef73092254983280efce6aedce3fd2de6b0c3b43_3
Original Code:
```
fn send_send() {
    let (send, _recv) = super::new();
    send.send(1u8).unwrap();
    assert_eq!(send.send(1u8).unwrap_err(), (1, Error::Full));
}
```


Overlapping Code:
```
send, _recv) = super::new();
send.send(1u8).unwrap();
assert_eq!(send.send(1u8).unwrap_err(), (1, Er
```
<Overlap Ratio: 0.7352941176470589>

---

--- 168 --
Question ID: 2a51ba000b3fd5f005f0dd637b2db64af7406eea_23
Original Code:
```
fn test_send_message() {
        init!("true");

        let msg = CString::new("MESSAGE").unwrap().into_raw();
        let msg_type = CString::new("TYPE").unwrap().into_raw();
        let msg_title = CString::new("TITLE").unwrap().into_raw();
        let connection_handle = ::connection::tests::build_test_connection();
        ::connection::set_state(connection_handle, VcxStateType::VcxStateAccepted).unwrap();
        let cb = return_types_u32::Return_U32_STR::new().unwrap();
        assert_eq!(vcx_connection_send_message(cb.command_handle, connection_handle, msg, msg_type, msg_title, Some(cb.get_callback())), error::SUCCESS.code_num);
        cb.receive(Some(Duration::from_secs(10))).unwrap();
    }
```


Overlapping Code:
```
_message() {
init!("true");
let msg = CString::new("MESSAGE").unwrap().into_raw();
let msg_type = CString::new("TYPE").unwrap().into_raw();
let msg_title = CString::new("TITLE").unwrap().into_raw();
let connection_handle = ::connection::tests::build_test_connection();
::connection::set_state(connection_handle, VcxStateType::VcxStateAccepted).unwrap();
let cb = return_types_u32::Return_U32_STR::new().unwrap();
assert_eq!(vcx_connection_send_message(cb.command_handle, connection_handle, msg, msg_type, msg_title, Some(cb.get_callback())), error::SUCCESS.code_num);
cb.receive(Some(Duration::from_secs(10))).unwrap();

```
<Overlap Ratio: 0.9794628751974723>

---

--- 169 --
Question ID: 4b1c925c4ddbff08468c073c2584476e28efd091_0
Original Code:
```
pub fn cli_command(arg: &[String]) -> Result<(), UnameError> {
    let mut buf: utsname = utsname {
        sysname: [0; 65],
        nodename: [0; 65],
        release: [0; 65],
        version: [0; 65],
        machine: [0; 65],
        domainname: [0; 65],
    };

    unsafe {
        uname(&mut buf as *mut libc::utsname);
    };

    let opts = Opts::parse_from(arg);

    if opts.kernel_name
        || opts.all
        || (!opts.nodename && !opts.kernel_release && !opts.kernel_version && !opts.machine)
    {
        print_c_char(&buf.sysname);
        print!(" ");
    }

    if opts.nodename || opts.all {
        print_c_char(&buf.nodename);
        print!(" ");
    }

    if opts.kernel_release || opts.all {
        print_c_char(&buf.release);
        print!(" ");
    }

    if opts.kernel_version || opts.all {
        print_c_char(&buf.version);
        print!(" ");
    }

    if opts.machine || opts.all {
        print_c_char(&buf.machine);
        print!(" ");
    }

    println!();

    Ok(())
}
```


Overlapping Code:
```
Result<(), UnameError> {
let mut buf: utsname = utsname {
sysname: [0; 65],
nodename: [0; 65],
release: [0; 65],
version: [0; 65],
machine: [0; 65],
domainname: [0; 65],
};
unsafe {
uname(&mut buf as *mut libc::utsname);
};
let opts = Opts::parse_from(arg);
if opts.kernel_name
|| opts.all
|| (!opts.nodename && !opts.kernel_release && !opts.kernel_version && !opts.machine)
{
print_c_char(&buf.sysname);
print!(" ");
}
if opts.nodename || opts.all {
print_c_char(&buf.nodename);
print!(" ");
}
if opts.kernel_release || opts.all {
print_c_char(&buf.release);
print!(" ");
}
if opts.kernel_version || opts.all {
print_c_char(&buf.version);
print!(" ");
}
if opts.machine || opts.all {
print_c_char(&b
```
<Overlap Ratio: 0.8905852417302799>

---

--- 170 --
Question ID: aca57c29143659cbac6350849918fd439a686969_1
Original Code:
```
async fn main() {
    env_logger::init();

    let opts = Opt::parse();

    let index_html_s = tokio::fs::read_to_string(opts.dir.join("index.html"))
        .await
        .expect("failed to read index.html");

    let handle_error = |e| async move {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("error occurred: {}", e),
        )
    };

    let app = Router::new()
        .route("/api/test", get(|| async move { "Hello World" }))
        // needed because https://github.com/tower-rs/tower-http/issues/262
        .route("/", get(render))
        .fallback(HandleError::new(
            ServeDir::new(opts.dir)
                .append_index_html_on_directories(false)
                .fallback(
                    render
                        .layer(Extension(index_html_s))
                        .into_service()
                        .map_err(|err| -> std::io::Error { match err {} }),
                ),
            handle_error,
        ));

    println!("You can view the website at: http://localhost:8080/");

    axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}
```


Overlapping Code:
```
fn main() {
env_logger::init();
let opts = Opt::parse();
let index_html_s = tokio::fs::read_to_string(opts.dir.join("index.html"))
.await
.expect("failed to read index.html");
let handle_error = |e| async move {
(
StatusCode::INTERNAL_SERVER_ERROR,
format!("error occurred: {}", e),
)
};
let app = Router::new()
.route("/api/test", get(|| async move { "Hello World" }))
// needed because https://github.com/tower-rs/tower-http/issues/262
.route("/", get(render))
.fallback(HandleError::new(
ServeDir::new(opts.dir)
.append_index_html_on_directories(false)
.fallback(
render
.layer(Extension(index_html_s))
.into_service()
.map_err(|err| -> std::io::Error { match err {} }),
),
handle_error,
));
println!("You can view the website at: http://localhost:8080/");
axum::Server::bind(&"0.0.0.0:8080".parse().unwrap())
.serve(app.into_make_service())
.await
.unwrap();
}
```
<Overlap Ratio: 0.993103448275862>

---

--- 171 --
Question ID: 3d9c204ab5e87806b487b1e18376ede4b321b8a6_9
Original Code:
```
pub fn find_or_create_venv(
    cfg_vers: &Version,
    pypackages_dir: &Path,
    pyflow_dir: &Path,
    dep_cache_path: &Path,
) -> (PathBuf, Version) {
    let venvs = find_venvs(pypackages_dir);
    // The version's explicitly specified; check if an environment for that version
    let compatible_venvs: Vec<&(u32, u32)> = venvs
        .iter()
        .filter(|(ma, mi)| cfg_vers.major == Some(*ma) && cfg_vers.minor == Some(*mi))
        .collect();

    let vers_path;
    let py_vers;
    match compatible_venvs.len() {
        0 => {
            let vers =
                py_versions::create_venv(cfg_vers, pypackages_dir, pyflow_dir, dep_cache_path);
            vers_path = pypackages_dir.join(vers.to_string_med());
            py_vers = Version::new_opt(vers.major, vers.minor, None); // Don't include patch.
        }
        1 => {
            vers_path = pypackages_dir.join(&format!(
                "{}.{}",
                compatible_venvs[0].0, compatible_venvs[0].1
            ));
            py_vers = Version::new_short(compatible_venvs[0].0, compatible_venvs[0].1);
        }
        _ => {
            abort(
                // todo: Handle this, eg by letting the user pick the one to use?
                "Multiple compatible Python environments found
                for this project.",
            )
        }
    }

    #[cfg(target_os = "windows")]
    {
        (vers_path, py_vers)
    }

    #[cfg(target_os = "linux")]
    {
        let vers_path = fs::canonicalize(vers_path);
        let vers_path = match vers_path {
            Ok(path) => path,
            Err(error) => {
                abort(&format!(
                    "Problem converting path to absolute path: {:?}",
                    error
                ));
                unreachable!()
            }
        };
        (vers_path, py_vers)
    }

    #[cfg(target_os = "macos")]
    {
        let vers_path = fs::canonicalize(vers_path);
        let vers_path = match vers_path {
            Ok(path) => path,
            Err(error) => abort(&format!(
                "Problem converting path to absolute path: {:?}",
                error
            )),
        };
        (vers_path, py_vers)
    }
}
```


Overlapping Code:
```
cfg_vers: &Version,
pypackages_dir: &Path,
pyflow_dir: &Path,
dep_cache_path: &Path,
) -> (PathBuf, Version) {
let venvs = find_venvs(pypackages_dir);
// The version's explicitly specified; check if an environment for that version
let compatible_venvs: Vec<&(u32, u32)> = venvs
.iter()
.filter(|(ma, mi)| cfg_vers.major == Some(*ma) && cfg_vers.minor == Some(*mi))
.collect();
let vers_path;
let py_vers;
match compatible_venvs.len() {
0 => {
let vers =
py_versions::create_venv(cfg_vers, pypackages_dir, pyflow_dir, dep_cache_path);
vers_path = pypackages_dir.join(vers.to_string_med());
py_vers = Version::new_opt(vers.major, vers.minor, None); // Don't include patch.
}
1 => {
vers_path = pypackages_dir.join(&format!(
"{}.{}",
compatible_venvs[0].0, compatible_venvs[0].1
));
py_vers = Version::new_short(compatible_venvs[0].0, compatible_venvs[0].1);
}
_ => {
abort(
// todo: Handle this, eg by letting the user pick the one to use?
"Multiple compatible Python environments found
for this project.",
)
}
}
#[cfg(target_os = "windows")]
{
(vers_path, py_vers)
}
#[cfg(target_os = "linux")]
{
let vers_path = fs::canonicalize(vers_path);
let vers_path = match vers_path {
Ok(path) => path,
Err(error) => {
abort(&format!(
"Problem converting path to absolute path: {:?}",
error
));
unreachable!()
}
};
(vers_path, py_vers)
}
#[cfg(target_os = "macos")]
{
let vers_path = fs::canonicalize(vers_path);
let vers_path = match vers_path {
Ok(path) => path,
Err(error) => abort(&format!(
"Problem converting path to absolute path: {:?}",
error
)),
};
(v
```
<Overlap Ratio: 0.96875>

---

--- 172 --
Question ID: a508c2f05e13c70043b704481f43934a1170337d_0
Original Code:
```
fn gcd(a: i64, b: i64) -> i64 {
    if a < b {
        return gcd(b, a);
    }
    if b == 0 {
        return a;
    }
    return gcd(a - b, b);
}
```


Overlapping Code:
```
cd(a: i64, b: i64) -> i64 {
if a < b {
return gcd(b, a);
}
if b == 0 {
return a;
}
return gcd(a - b, b
```
<Overlap Ratio: 0.9272727272727272>

---

--- 173 --
Question ID: 3784db95164066da6e55327253379eabe8e2a952_55
Original Code:
```
fn test_divsd_rr() {
        assert_emit!(0xf2, 0x0f, 0x5e, 0xc1; divsd_rr(XMM0, XMM1));
        assert_emit!(0xf2, 0x41, 0x0f, 0x5e, 0xdf; divsd_rr(XMM3, XMM15));
        assert_emit!(0xf2, 0x44, 0x0f, 0x5e, 0xc4; divsd_rr(XMM8, XMM4));
    }
```


Overlapping Code:
```
2, 0x0f, 0x5e, 0xc1; divsd_rr(XMM0, XMM1));
assert_emit!(0xf2, 0x41, 0x0f, 0x5e, 0xdf; divsd_rr(XMM3, XMM15));
assert_emit!(0xf2, 0x44, 0x0f, 0x5e, 0x
```
<Overlap Ratio: 0.6976744186046512>

---

--- 174 --
Question ID: f247a6157004da3df73791c1bd17952df4a42af9_1
Original Code:
```
fn test_case_insensitive() {
        let a = Ascii("foobar");
        let b = Ascii("FOOBAR");

        assert_eq!(a, b);
        assert_eq!(hash(&a), hash(&b));

        assert_eq!(a, "fooBar");
        assert_eq!("fooBar", a);
        assert_eq!(String::from("fooBar"), a);
        assert_eq!(a, String::from("fooBar"));
    }
```


Overlapping Code:
```
nsitive() {
let a = Ascii("foobar");
let b = Ascii("FOOBAR");
assert_eq!(a, b);
assert_eq!(hash(&a), hash(&b));
assert_eq!(a, "fooBar");
assert_eq!("fooBar", a);
assert_eq!(String::from("fooBar"), a);
assert_eq!(a, Strin
```
<Overlap Ratio: 0.8527131782945736>

---

--- 175 --
Question ID: 0b6b0c16e50b21486ecd92e41b394ca64915236c_0
Original Code:
```
fn encipher_small() {
    let rail_fence = RailFence::new(4);

    let ctext = rail_fence.encipher("DEFENDTHEEASTWALLOFTHECASTLE");
    assert_eq!(ctext.unwrap(), "DTTFSEDHSWOTATFNEAALHCLEELEE");
}
```


Overlapping Code:
```
ncipher_small() {
let rail_fence = RailFence::new(4);
let ctext = rail_fence.encipher("DEFENDTHEEASTWALLOFTHECASTLE");
assert_eq!(ctext.unwrap(), "DTT
```
<Overlap Ratio: 0.8152173913043478>

---

--- 176 --
Question ID: 07b2dcc89f88ebd13d2e9fb46dabe7784856e641_4
Original Code:
```
pub fn verify_client(
    client: &ExitClientIdentity,
    client_verified: bool,
    conn: &PgConnection,
) -> Result<(), RitaExitError> {
    use self::schema::clients::dsl::*;
    let ip = client.global.mesh_ip;
    let wg = client.global.wg_public_key;
    let key = client.global.eth_address;
    let filtered_list = clients
        .filter(mesh_ip.eq(ip.to_string()))
        .filter(wg_pubkey.eq(wg.to_string()))
        .filter(eth_address.eq(key.to_string().to_lowercase()));

    diesel::update(filtered_list)
        .set(verified.eq(client_verified))
        .execute(&*conn)?;

    Ok(())
}
```


Overlapping Code:
```
&ExitClientIdentity,
client_verified: bool,
conn: &PgConnection,
) -> Result<(), RitaExitError> {
use self::schema::clients::dsl::*;
let ip = client.global.mesh_ip;
let wg = client.global.wg_public_key;
let key = client.global.eth_address;
let filtered_list = clients
.filter(mesh_ip.eq(ip.to_string()))
.filter(wg_pubkey.eq(wg.to_string()))
.filter(eth_address.eq(key.to_string().to_lowercase()));
diesel::update(filtered_list)
.set(verified.eq(client_verified))
.execute(&*conn)?;
Ok(()
```
<Overlap Ratio: 0.9366602687140115>

---

--- 177 --
Question ID: 00d369fffd7cf57f1580aff9e033cd4f56302c88_5
Original Code:
```
pub unsafe extern "C" fn wlr_pointer_gestures_v1_send_swipe_end(mut gestures:
                                                                    *mut wlr_pointer_gestures_v1,
                                                                mut seat:
                                                                    *mut wlr_seat,
                                                                mut time_msec:
                                                                    uint32_t,
                                                                mut cancelled:
                                                                    bool) {
    let mut focus: *mut wlr_surface = (*seat).pointer_state.focused_surface;
    if focus.is_null() { return }
    let mut focus_client: *mut wl_client =
        wl_resource_get_client((*focus).resource);
    let mut serial: uint32_t =
        wlr_seat_client_next_serial((*seat).pointer_state.focused_client);
    let mut gesture: *mut wl_resource = 0 as *mut wl_resource;
    gesture = 0 as *mut wl_resource;
    gesture = wl_resource_from_link((*gestures).swipes.next);
    while wl_resource_get_link(gesture) !=
              &mut (*gestures).swipes as *mut wl_list {
        let mut gesture_seat: *mut wlr_seat =
            seat_from_pointer_resource(gesture);
        let mut gesture_client: *mut wl_client =
            wl_resource_get_client(gesture);
        if !(gesture_seat != seat || gesture_client != focus_client) {
            zwp_pointer_gesture_swipe_v1_send_end(gesture, serial, time_msec,
                                                  cancelled as int32_t);
        }
        gesture = wl_resource_from_link((*wl_resource_get_link(gesture)).next)
    };
}
```


Overlapping Code:
```
es_v1_send_swipe_end(mut gestures:
*mut wlr_pointer_gestures_v1,
mut seat:
*mut wlr_seat,
mut time_msec:
uint32_t,
mut cancelled:
bool) {
let mut focus: *mut wlr_surface = (*seat).pointer_state.focused_surface;
if focus.is_null() { return }
let mut focus_client: *mut wl_client =
wl_resource_get_client((*focus).resource);
let mut serial: uint32_t =
wlr_seat_client_next_serial((*seat).pointer_state.focused_client);
let mut gesture: *mut wl_resource = 0 as *mut wl_resource;
gesture = 0 as *mut wl_resource;
gesture = wl_resource_from_link((*gestures).swipes.next);
while wl_resource_get_link(gesture) !=
&mut (*gestures).swipes as *mut wl_list {
let mut gesture_seat: *mut wlr_seat =
seat_from_pointer_resource(gesture);
let mut gesture_client: *mut wl_client =
wl_resource_get_client(gesture);
if !(gesture_seat != seat || gesture_client != focus_client) {
zwp_pointer_gesture_swipe_v1_send_end(gesture, serial, time_msec,
cancelled as int32_t);
}
gesture = wl_resource_from_link((*wl_resource_get_link(gestur
```
<Overlap Ratio: 0.9466791393826005>

---

--- 178 --
Question ID: 9082b1af96e07a420786ee77cf1d8f83d61e92ba_0
Original Code:
```
fn handle_err<A: AsRef<str>>(o: io::Result<Output>, cmd: A) -> Output {
    let o = match o {
        Err(e) => {
            eprintln!("{}", cmd.as_ref());
            eprintln!("\tIO Error on exec:\n{:?}", e);
            ::std::process::exit(1);
        }
        Ok(o) => o,
    };
    if !o.status.success() {
        let stderr = String::from_utf8_lossy(o.stderr.as_slice());
        let stdout = String::from_utf8_lossy(o.stdout.as_slice());
        eprintln!("{}", cmd.as_ref());
        match o.status.code() {
            Option::Some(x) => eprintln!("\tExit Code: {:?}", x),
            _ => {}
        };
        eprintln!("\tStdErr:\n {}", stderr);
        eprintln!("\tStdOut:\n {}", stdout);
        ::std::process::exit(1);
    }
    o
}
```


Overlapping Code:
```
handle_err<A: AsRef<str>>(o: io::Result<Output>, cmd: A) -> Output {
let o = match o {
Err(e) => {
eprintln!("{}", cmd.as_ref());
eprintln!("\tIO Error on exec:\n{:?}", e);
::std::process::exit(1);
}
Ok(o) => o,
};
if !o.status.success() {
let stderr = String::from_utf8_lossy(o.stderr.as_slice());
let stdout = String::from_utf8_lossy(o.stdout.as_slice());
eprintln!("{}", cmd.as_ref());
match o.status.code() {
Option::Some(x) => eprintln!("\tExit Code: {:?}", x),
_ => {}
};
eprintln!("\tStdErr:\n {}", stderr);
eprintln!("\tStdOut:\n {}", stdout)
```
<Overlap Ratio: 0.9401709401709402>

---

--- 179 --
Question ID: fb2806f592d4ef9064be9b3733dc3d197c377900_1
Original Code:
```
fn slti_imm() {
    let program = vec![
        0x13, 0xa1, 0x10, 0x00, // slti sp, ra, 1
        0x93, 0xa1, 0xf0, 0xff, // slti gp, ra -1
        0x73, 0x00, 0x50, 0x10, // wfi
    ];

    let riscv = execute_program(program);

    assert_eq!(riscv.get_gpr(sp), 1);
    assert_eq!(riscv.get_gpr(gp), 0);
}
```


Overlapping Code:
```
 vec![
0x13, 0xa1, 0x10, 0x00, // slti sp, ra, 1
0x93, 0xa1, 0xf0, 0xff, // slti gp, ra -1
0x73, 0x00, 0x50, 0x10, // wfi
];
let riscv = execute_program(program);
assert_eq!(riscv.get_gpr(sp), 1);
ass
```
<Overlap Ratio: 0.7662835249042146>

---

--- 180 --
Question ID: 2a744d18cddede60664e7d18cf64ed3cb4a32db7_2
Original Code:
```
fn eval_pr(expression: &str) -> Result<bool> {
        let mut map = HashMap::new();
        map.insert(
            String::from("commits"),
            Value::List(vec![
                Expr::Value(Value::Dictionary(HashMap::new())),
                Expr::Value(Value::Dictionary(HashMap::new())),
            ]),
        );
        eval(expression, &Value::Dictionary(map))
    }
```


Overlapping Code:
```
_pr(expression: &str) -> Result<bool> {
let mut map = HashMap::new();
map.insert(
String::from("commits"),
Value::List(vec![
Expr::Value(Value::Dictionary(HashMap::new())),
Expr::Value(Value::Dictionary(HashMap::new())),
]),
);
eval(expression, &Valu
```
<Overlap Ratio: 0.8992805755395683>

---

--- 181 --
Question ID: 6ee7812d7118b6d191334106a34ef882bb9b8a7e_0
Original Code:
```
fn points((a, b): Segment) -> Vec<Point> {
    let mut xs: Vec<i64> = (a.x.min(b.x)..=a.x.max(b.x)).collect();
    if a.x > b.x {
        xs.reverse();
    }

    let mut ys: Vec<i64> = (a.y.min(b.y)..=a.y.max(b.y)).collect();
    if a.y > b.y {
        ys.reverse();
    }

    if xs.len() == 1 {
        xs.iter()
            .cycle()
            .zip(ys.iter())
            .map(|(&x, &y)| Point::new(x, y))
            .collect()
    } else {
        xs.iter()
            .zip(ys.iter().cycle())
            .map(|(&x, &y)| Point::new(x, y))
            .collect()
    }
}
```


Overlapping Code:
```
nt> {
let mut xs: Vec<i64> = (a.x.min(b.x)..=a.x.max(b.x)).collect();
if a.x > b.x {
xs.reverse();
}
let mut ys: Vec<i64> = (a.y.min(b.y)..=a.y.max(b.y)).collect();
if a.y > b.y {
ys.reverse();
}
if xs.len() == 1 {
xs.iter()
.cycle()
.zip(ys.iter())
.map(|(&x, &y)| Point::new(x, y))
.collect()
} else {
xs.iter()
.zip(ys.iter().cycle())
.map(|(&x, &
```
<Overlap Ratio: 0.8274231678486997>

---

--- 182 --
Question ID: e9c1ce20b302b0326aedf17d9dd8d687e7361261_3
Original Code:
```
unsafe fn mi_realloc_zero_aligned_at(mut p: *mut c_void, mut newsize: usize,
                                     mut alignment: usize, mut offset: usize,
                                     mut zero: bool) -> *mut c_void {
    if alignment > 0 {
        0
    } else {
        _mi_assert_fail("alignment > 0", "src/alloc-aligned.c", 90,
                        "mi_realloc_zero_aligned_at")
    }
    if alignment <= std::mem::size_of::<usize>() {
        return _mi_realloc_zero(p, newsize, zero != 0);
    }
    if p.is_null() {
        return mi_malloc_zero_aligned_at(newsize, alignment, offset,
                                         zero != 0);
    }
    let mut size = mi_usable_size(p);
    if newsize <= size && newsize >= (size - (size / 2)) &&
           (((p as usize) + offset) % alignment) == 0 {
        return p;
    } else {
        let mut newp = mi_malloc_aligned_at(newsize, alignment, offset);
        if !newp.is_null() {
            if zero != 0 != 0 && newsize > size {
                // also set last word in the previous allocation to zero to ensure any padding is zero-initialized
                let mut start =
                    if size >= std::mem::size_of::<isize>() {
                        size - std::mem::size_of::<isize>()
                    } else { 0 }; // only free if successful
                memset((newp as *mut u8).offset(start), 0,
                       newsize -
                           start); // use offset of previous allocation (p can be NULL)
            }
            memcpy(newp, p as *const c_void,
                   if newsize > size { size } else { newsize });
            mi_free(p);
        }
        return newp;
    };
}
```


Overlapping Code:
```
afe fn mi_realloc_zero_aligned_at(mut p: *mut c_void, mut newsize: usize,
mut alignment: usize, mut offset: usize,
mut zero: bool) -> *mut c_void {
if alignment > 0 {
0
} else {
_mi_assert_fail("alignment > 0", "src/alloc-aligned.c", 90,
"mi_realloc_zero_aligned_at")
}
if alignment <= std::mem::size_of::<usize>() {
return _mi_realloc_zero(p, newsize, zero != 0);
}
if p.is_null() {
return mi_malloc_zero_aligned_at(newsize, alignment, offset,
zero != 0);
}
let mut size = mi_usable_size(p);
if newsize <= size && newsize >= (size - (size / 2)) &&
(((p as usize) + offset) % alignment) == 0 {
return p;
} else {
let mut newp = mi_malloc_aligned_at(newsize, alignment, offset);
if !newp.is_null() {
if zero != 0 != 0 && newsize > size {
// also set last word in the previous allocation to zero to ensure any padding is zero-initialized
let mut start =
if size >= std::mem::size_of::<isize>() {
size - std::mem::size_of::<isize>()
} else { 0 }; // only free if successful
memset((newp as *mut u8).offset(start), 0,
newsize -
start); // use offset of previous allocation (p can be NULL)
}
memcpy(newp, p as *const c_void,
if newsize > size { size } else { newsize });
mi_free(p);
}
return newp;
```
<Overlap Ratio: 0.9933333333333333>

---

--- 183 --
Question ID: 35cb44c1572d5b6f29c6b4f71d50258804b87694_18
Original Code:
```
fn observables_csv(observables: &ObservablesOutput, project: &str) -> Result<()> {
    let filename = format!(
        "{}/observables_{}.csv",
        get_project_dir(project),
        observables.state
    );
    let mut buffer = csv::Writer::from_path(&filename)
        .chain_err(|| ErrorKind::CreateFile(filename.to_string()))?;
    buffer
        .serialize(observables)
        .chain_err(|| ErrorKind::Serialize)?;
    buffer.flush().chain_err(|| ErrorKind::Flush)?;
    Ok(())
}
```


Overlapping Code:
```
les: &ObservablesOutput, project: &str) -> Result<()> {
let filename = format!(
"{}/observables_{}.csv",
get_project_dir(project),
observables.state
);
let mut buffer = csv::Writer::from_path(&filename)
.chain_err(|| ErrorKind::CreateFile(filename.to_string()))?;
buffer
.serialize(observables)
.chain_err(|| ErrorKind::Serialize)?;
buffer.flush().chain_err(||
```
<Overlap Ratio: 0.8653846153846154>

---

--- 184 --
Question ID: 5e7e45fc371bccafaa17f418793da5254d860ceb_0
Original Code:
```
fn named_target() {
        let yaml = r#"
            targets:
                config_json:
                    type: fileset
                    format: json
                    location:
                        path: /somewhere
                        partition: 0
        "#;
        let mapping: Mapping = serde_yaml::from_str(yaml).unwrap();
        assert_eq!(mapping.target_count(), 1);

        let target = mapping.named_target("config_json").unwrap();
        assert_eq!(target.type_(), Type::FileSet);
        assert_eq!(target.format(), Format::Json);
        assert_eq!(target.location().path(), "/somewhere");
        assert_eq!(target.location().partition(), &Partition::Index(0));
    }
```


Overlapping Code:
```
s:
config_json:
type: fileset
format: json
location:
path: /somewhere
partition: 0
"#;
let mapping: Mapping = serde_yaml::from_str(yaml).unwrap();
assert_eq!(mapping.target_count(), 1);
let target = mapping.named_target("config_json").unwrap();
assert_eq!(target.type_(), Type::FileSet);
assert_eq!(target.format(), Format::Json);
assert_eq!(target.location().path(), "/somewhere");
assert_eq!(target
```
<Overlap Ratio: 0.8163265306122449>

---

--- 185 --
Question ID: 893e26f9cd6149860f4273adaa5bdb87a286db0a_0
Original Code:
```
fn router(logger: slog::Logger, cfg: config::Config, irc: Box<irc::IrcWriter + Send>) -> Router {
    let state = AppState {
        logger: Arc::new(logger),
        cfg: Arc::new(RwLock::new(cfg)),
        irc: Arc::new(Mutex::new(irc)),
    };

    let middleware = StateMiddleware::new(state);

    // create a middleware pipeline from our middleware
    let pipeline = single_middleware(middleware);

    // construct a basic chain from our pipeline
    let (chain, pipelines) = single_pipeline(pipeline);

    // build a router with the chain & pipeline
    build_router(chain, pipelines, |route| {
        route.post("/gitlab").to(handle_gitlab);
    })
}
```


Overlapping Code:
```
Logger, cfg: config::Config, irc: Box<irc::IrcWriter + Send>) -> Router {
let state = AppState {
logger: Arc::new(logger),
cfg: Arc::new(RwLock::new(cfg)),
irc: Arc::new(Mutex::new(irc)),
};
let middleware = StateMiddleware::new(state);
// create a middleware pipeline from our middleware
let pipeline = single_middleware(middleware);
// construct a basic chain from our pipeline
let (chain, pipelines) = single_pipeline(pipeline);
// build a router with the chain & pipeline
build_router(chain, pipelines, |route| {
route.post("/gitlab").to(handle_g
```
<Overlap Ratio: 0.9385665529010239>

---

--- 186 --
Question ID: 139212fac6270a44a498f6036ea8c3fbb049d001_5
Original Code:
```
fn test_lexer06() {
        let input = "t = {x = 3}";
        let tokens = &[
            (Identifier, 0, 1),
            (Assign, 2, 1),
            (LCurly, 4, 1),
            (Identifier, 5, 1),
            (Assign, 7, 1),
            (LiteralNumber, 9, 1),
            (RCurly, 10, 1),
        ];
        check_line(input, tokens);
    }
```


Overlapping Code:
```
et tokens = &[
(Identifier, 0, 1),
(Assign, 2, 1),
(LCurly, 4, 1),
(Identifier, 5, 1),
(Assign, 7, 1),
(LiteralNumber, 9, 1),
(RCurly, 10, 1),
];
chec
```
<Overlap Ratio: 0.6756756756756757>

---

--- 187 --
Question ID: 675110c1532e4d3c318357e731a5ac978e792779_0
Original Code:
```
fn main() {
    server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
        .keep_alive(75); // <- Set keep-alive to 75 seconds

    server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
        .keep_alive(server::KeepAlive::Tcp(75)); // <- Use `SO_KEEPALIVE` socket option.

    server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
        .keep_alive(None); // <- Disable keep-alive
}
```


Overlapping Code:
```
 main() {
server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
.keep_alive(75); // <- Set keep-alive to 75 seconds
server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
.keep_alive(server::KeepAlive::Tcp(75)); // <- Use `SO_KEEPALIVE` socket option.
server::new(|| App::new().resource("/", |r| r.f(|_| HttpResponse::Ok())))
.keep_alive(None); // <- Disabl
```
<Overlap Ratio: 0.9611650485436893>

---

--- 188 --
Question ID: 9f41e3f593abd4d21eb15c070a0fcbb464e65ab8_1
Original Code:
```
pub fn tests() {
    use crate::input::{test_part_one, test_part_two};

    let example_part_one = "class: 1-3 or 5-7
row: 6-11 or 33-44
seat: 13-40 or 45-50

your ticket:
7,1,14

nearby tickets:
7,3,47
40,4,50
55,2,20
38,6,12";
    test_part_one!(example_part_one => 71);

    let example_part_two = "class: 0-1 or 4-19
row: 0-5 or 8-19
seat: 0-13 or 16-19

your ticket:
11,12,13

nearby tickets:
3,9,18
15,1,5
5,14,9";
    test_part_two!(example_part_two => 1);

    let real_input = include_str!("day16_input.txt");
    test_part_one!(real_input => 29019);
    test_part_two!(real_input => 517_827_547_723);
}
```


Overlapping Code:
```
pub fn tests() {
use crate::input::{test_part_one, test_part_two};
let example_part_one = "class: 1-3 or 5-7
row: 6-11 or 33-44
seat: 13-40 or 45-50
your ticket:
7,1,14
nearby tickets:
7,3,47
40,4,50
55,2,20
38,6,12";
test_part_one!(example_part_one => 71);
let example_part_two = "class: 0-1 or 4-19
row: 0-5 or 8-19
seat: 0-13 or 16-19
your ticket:
11,12,13
nearby tickets:
3,9,18
15,1,5
5,14,9";
test_part_two!(example_part_two => 1);
let real_input = include_str!("day16_input.txt");
test_part_one!(real_input => 29019);
test_part_two!(real_input
```
<Overlap Ratio: 0.9598603839441536>

---

--- 189 --
Question ID: 8963703e3db3eddc9448e90979b0bb9fc667cf3a_5
Original Code:
```
fn parsing() {
        use super::ParseAmountError as E;
        let tpc = Denomination::TPC;
        let tap = Denomination::Tapyrus;
        let p = Amount::from_str_in;
        let sp = SignedAmount::from_str_in;

        assert_eq!(p("x", tpc), Err(E::InvalidCharacter('x')));
        assert_eq!(p("-", tpc), Err(E::InvalidFormat));
        assert_eq!(sp("-", tpc), Err(E::InvalidFormat));
        assert_eq!(p("-1.0x", tpc), Err(E::InvalidCharacter('x')));
        assert_eq!(p("0.0 ", tpc), Err(ParseAmountError::InvalidCharacter(' ')));
        assert_eq!(p("0.000.000", tpc), Err(E::InvalidFormat));
        let more_than_max = format!("1{}", Amount::max_value());
        assert_eq!(p(&more_than_max, tpc), Err(E::TooBig));
        assert_eq!(p("0.000000042", tpc), Err(E::TooPrecise));

        assert_eq!(p("1", tpc), Ok(Amount::from_tap(1_000_000_00)));
        assert_eq!(sp("-.5", tpc), Ok(SignedAmount::from_tap(-500_000_00)));
        assert_eq!(p("1.1", tpc), Ok(Amount::from_tap(1_100_000_00)));
        assert_eq!(p("100", tap), Ok(Amount::from_tap(100)));
        assert_eq!(p("55", tap), Ok(Amount::from_tap(55)));
        assert_eq!(p("5500000000000000000", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));
        // Should this even pass?
        assert_eq!(p("5500000000000000000.", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));
        assert_eq!(
            p("12345678901.12345678", tpc),
            Ok(Amount::from_tap(12_345_678_901__123_456_78))
        );

        // make sure tapyrus > i64::max_value() is checked.
        let amount = Amount::from_tap(i64::max_value() as u64);
        assert_eq!(Amount::from_str_in(&amount.to_string_in(tap), tap), Ok(amount));
        assert_eq!(Amount::from_str_in(&(amount+Amount(1)).to_string_in(tap), tap), Err(E::TooBig));

        assert_eq!(p("12.000", Denomination::MilliTapyrus), Err(E::TooPrecise));
        // exactly 50 chars.
        assert_eq!(p("100000000000000.0000000000000000000000000000000000", Denomination::TPC), Err(E::TooBig));
        // more than 50 chars.
        assert_eq!(p("100000000000000.00000000000000000000000000000000000", Denomination::TPC), Err(E::InputTooLarge));
    }
```


Overlapping Code:
```
parsing() {
use super::ParseAmountError as E;
let tpc = Denomination::TPC;
let tap = Denomination::Tapyrus;
let p = Amount::from_str_in;
let sp = SignedAmount::from_str_in;
assert_eq!(p("x", tpc), Err(E::InvalidCharacter('x')));
assert_eq!(p("-", tpc), Err(E::InvalidFormat));
assert_eq!(sp("-", tpc), Err(E::InvalidFormat));
assert_eq!(p("-1.0x", tpc), Err(E::InvalidCharacter('x')));
assert_eq!(p("0.0 ", tpc), Err(ParseAmountError::InvalidCharacter(' ')));
assert_eq!(p("0.000.000", tpc), Err(E::InvalidFormat));
let more_than_max = format!("1{}", Amount::max_value());
assert_eq!(p(&more_than_max, tpc), Err(E::TooBig));
assert_eq!(p("0.000000042", tpc), Err(E::TooPrecise));
assert_eq!(p("1", tpc), Ok(Amount::from_tap(1_000_000_00)));
assert_eq!(sp("-.5", tpc), Ok(SignedAmount::from_tap(-500_000_00)));
assert_eq!(p("1.1", tpc), Ok(Amount::from_tap(1_100_000_00)));
assert_eq!(p("100", tap), Ok(Amount::from_tap(100)));
assert_eq!(p("55", tap), Ok(Amount::from_tap(55)));
assert_eq!(p("5500000000000000000", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));
// Should this even pass?
assert_eq!(p("5500000000000000000.", tap), Ok(Amount::from_tap(5_500_000_000_000_000_000)));
assert_eq!(
p("12345678901.12345678", tpc),
Ok(Amount::from_tap(12_345_678_901__123_456_78))
);
// make sure tapyrus > i64::max_value() is checked.
let amount = Amount::from_tap(i64::max_value() as u64);
assert_eq!(Amount::from_str_in(&amount.to_string_in(tap), tap), Ok(amount));
assert_eq!(Amount::from_str_in(&(amount+Amount(1)).to_string_in(tap), tap), Err(E::TooBig));
assert_eq!(p("12.000", Denomination::MilliTapyrus), Err(E::TooPrecise));
// exactly 50 chars.
assert_eq!(p("100000000000000.0000000000000000000000000000000000", Denomination::TPC), Err(E::TooBig));
// more than 50 chars.
assert_eq!(p("100000000000000.00000000000000000000000000000000000", Deno
```
<Overlap Ratio: 0.9768542872172541>

---

--- 190 --
Question ID: a76a0e9010de0f7000b8fb8aad7bc8a5990bf20d_3
Original Code:
```
fn get() {
        let mut buf = new(String::from("123"));
        assert_eq!(buf.get().unwrap(), '1');
        assert_eq!(buf.get().unwrap(), '2');
        assert_eq!(buf.get().unwrap(), '3');
        assert_eq!(buf.get().is_none(), true);
    }
```


Overlapping Code:
```
123"));
assert_eq!(buf.get().unwrap(), '1');
assert_eq!(buf.get().unwrap(), '2');
assert_eq!(buf.get().unwrap(), '3');
assert_eq!(buf.get().is_none(),
```
<Overlap Ratio: 0.7425742574257426>

---

--- 191 --
Question ID: d87c9e045f315190d8c5e8bd4dc961076a207bc2_4
Original Code:
```
fn badly_signed_check_should_fail() {
		let ux = Ex::new_signed(
			vec![0u8; 0],
			TEST_ACCOUNT,
			TestSig(TEST_ACCOUNT, vec![0u8; 0]),
			TestExtra
		);
		assert!(ux.is_signed().unwrap_or(false));
		assert_eq!(<Ex as Checkable<TestContext>>::check(ux, &TestContext), Err(crate::BAD_SIGNATURE));
	}
```


Overlapping Code:
```
heck_should_fail() {
let ux = Ex::new_signed(
vec![0u8; 0],
TEST_ACCOUNT,
TestSig(TEST_ACCOUNT, vec![0u8; 0]),
TestExtra
);
assert!(ux.is_signed().unwrap_or(false));
assert_eq!(<Ex as Checkable<TestContext>>::check(ux, &TestContext), Err(crate::BAD_SIGNATUR
```
<Overlap Ratio: 0.9178571428571428>

---

--- 192 --
Question ID: 85cc2e349629b4073bf751e1399639ab4021dd52_2
Original Code:
```
fn write_export(content: &mut String, func: &parser::FuncDecl, package_info: &cargo::Info) {
    let func_body = match marshal::has_marshaled_ret_value(func) {
        true => export_marshaled_return(func, package_info),
        false => format!("\t\t{}\n\t\t{}\n\n", get_import_decl(func, package_info), get_func_signature(func))
    };

    //Boolean values are 1 byte size, so append this in order to marshal it correctly
    match func.ret {
        parser::ReturnType::Type(parser::Type::Boolean) => content.push_str("\t\t[return: MarshalAs(UnmanagedType.I1)]\n"),
        _=> ()
    }

    content.push_str(func_body.as_ref());
}
```


Overlapping Code:
```
ng, func: &parser::FuncDecl, package_info: &cargo::Info) {
let func_body = match marshal::has_marshaled_ret_value(func) {
true => export_marshaled_return(func, package_info),
false => format!("\t\t{}\n\t\t{}\n\n", get_import_decl(func, package_info), get_func_signature(func))
};
//Boolean values are 1 byte size, so append this in order to marshal it correctly
match func.ret {
parser::ReturnType::Type(parser::Type::Boolean) => content.push_str("\t\t[return: MarshalAs(UnmanagedType.I1)]\n"),
_=> ()
}
content.p
```
<Overlap Ratio: 0.8890814558058926>

---

--- 193 --
Question ID: c44da432c27616a0c513aa4feb48d085fcb4d125_2
Original Code:
```
fn read_known_repos_table() -> Result<Vec<(String, String)>, KRTError> {
    let mut file = File::open(known_repos_table_filepath())?;
    let mut buffer = String::new();
    file.read_to_string(&mut buffer)?;
    let mut v: Vec<(String, String)> = serde_json::from_str(&buffer)?;
    // Prune any repos that no longer exist.
    let mut pruned = vec![];
    for item in v.drain(..) {
        if is_repo_workdir(&item.1) {
            pruned.push(item);
        }
    }
    Ok(pruned)
}
```


Overlapping Code:
```
(String, String)>, KRTError> {
let mut file = File::open(known_repos_table_filepath())?;
let mut buffer = String::new();
file.read_to_string(&mut buffer)?;
let mut v: Vec<(String, String)> = serde_json::from_str(&buffer)?;
// Prune any repos that no longer exist.
let mut pruned = vec![];
for item in v.drain(..) {
if is_repo_workdir(&item.1) {
prune
```
<Overlap Ratio: 0.8293838862559242>

---

--- 194 --
Question ID: b683a9bc0cbf1f4c4272cab9f93c985ad6eb9290_2
Original Code:
```
unsafe extern "C" fn handle_cursor_motion(mut listener: *mut wl_listener,
                                          mut data: *mut libc::c_void) {
    let mut sample: *mut sample_state =
        (listener as *mut libc::c_char).offset(-168) as *mut sample_state;
    let mut event: *mut wlr_event_pointer_motion =
        data as *mut wlr_event_pointer_motion;
    wlr_cursor_move((*sample).cursor, (*event).device, (*event).delta_x,
                    (*event).delta_y);
}
```


Overlapping Code:
```
nsafe extern "C" fn handle_cursor_motion(mut listener: *mut wl_listener,
mut data: *mut libc::c_void) {
let mut sample: *mut sample_state =
(listener as *mut libc::c_char).offset(-168) as *mut sample_state;
let mut event: *mut wlr_event_pointer_motion =
data as *mut wlr_event_pointer_motion;
wlr_cursor_move((*sample).cursor, (*event).
```
<Overlap Ratio: 0.8772845953002611>

---

--- 195 --
Question ID: e3d4833798277cb9b8a9a72fafc2aee5e3bb035c_0
Original Code:
```
fn main() -> Result<()> {
    // appeneds "___\n" after every line
    let editor = linurgy::factory::appender("___\n", 1);

    // create a buffered reader over stdin
    let mut input = BufReader::new(stdin());

    // `edit_buffered` returns an io::Result
    // in a simple program like this, we can pass stdout directly
    editor.edit_buffered(&mut input, &mut stdout())?;

    Ok(())
}
```


Overlapping Code:
```
 main() -> Result<()> {
// appeneds "___\n" after every line
let editor = linurgy::factory::appender("___\n", 1);
// create a buffered reader over stdin
let mut input = BufReader::new(stdin());
// `edit_buffered` returns an io::Result
// in a simple program like this, we can pass stdout directly
editor.edit_buffered(&mut input, &mut stdout())?;
Ok(
```
<Overlap Ratio: 0.9803921568627451>

---

--- 196 --
Question ID: 77a16e6f9acfb714a3642fbd3355c499f2af936f_8
Original Code:
```
fn multiply_assign_vector_by_vector_component_wise() {
        let mut v1 = Vec3::new(1., 2., 3.);
        let v2 = Vec3::new(3., 2., 1.);
        v1 *= v2;
        assert_eq!(v1.x(), 3.);
        assert_eq!(v1.y(), 4.);
        assert_eq!(v1.z(), 3.);
    }
```


Overlapping Code:
```
nt_wise() {
let mut v1 = Vec3::new(1., 2., 3.);
let v2 = Vec3::new(3., 2., 1.);
v1 *= v2;
assert_eq!(v1.x(), 3.);
assert_eq!(v1.y(), 4.);
assert_eq!(v
```
<Overlap Ratio: 0.7281553398058253>

---

--- 197 --
Question ID: 42c6c97511da80cf4c4213e9d4274610ecc943ba_9
Original Code:
```
fn must_round_trip_field_stop() {
        let (mut i_prot, mut o_prot) = test_objects(true);

        assert!(o_prot.write_field_stop().is_ok());

        copy_write_buffer_to_read_buffer!(o_prot);

        let expected_ident = TFieldIdentifier {
            name: None,
            field_type: TType::Stop,
            id: Some(0),
        }; // we get id 0

        let received_ident = assert_success!(i_prot.read_field_begin());
        assert_eq!(&received_ident, &expected_ident);
    }
```


Overlapping Code:
```
nd_trip_field_stop() {
let (mut i_prot, mut o_prot) = test_objects(true);
assert!(o_prot.write_field_stop().is_ok());
copy_write_buffer_to_read_buffer!(o_prot);
let expected_ident = TFieldIdentifier {
name: None,
field_type: TType::Stop,
id: Some(0),
}; // we get id 0
let received_ident = assert_success!(i_prot.read_field_begin());
assert_eq!(&received_ident, &expected_ident)
```
<Overlap Ratio: 0.9642857142857143>

---

--- 198 --
Question ID: 44e7d0caefd8d4c874ec5bc5d9c66bae2b0ef5e4_1
Original Code:
```
pub fn get_sphere_uv(p: Vec3) -> (f32, f32) {
    let phi = p.z().atan2(p.x());
    let theta = p.y().asin();
    let u = 1.0 - (phi + PI) / (2.0 * PI);
    let v = (theta + PI / 2.0) / PI;
    (u, v)
}
```


Overlapping Code:
```
ere_uv(p: Vec3) -> (f32, f32) {
let phi = p.z().atan2(p.x());
let theta = p.y().asin();
let u = 1.0 - (phi + PI) / (2.0 * PI);
let v = (theta + PI / 2.0) / PI;
(u, v)
}
```
<Overlap Ratio: 0.9230769230769231>

---

--- 199 --
Question ID: 936467b7824d9d53a9506197ec628a29f8a8b998_0
Original Code:
```
fn main() {
    let input_file = match env::args().nth(1) {
        Some(input_file) => input_file,
        None => {
            println!("Please supply input file!");
            std::process::exit(1);
        }
    };

    let orbits: Vec<Orbit> = match FileReader::new().split_lines().read_from_file(input_file) {
        Ok(input) => input,
        Err(e) => {
            println!("Error reading input: {}", e);
            std::process::exit(1);
        }
    };

    let graph = Graph::construct_graph(&orbits);
    let number_of_orbits = graph.count_orbits();
    println!("Number of orbits: {}", number_of_orbits);

    let minimal_distance = graph.minimal_distance("YOU", "SAN");
    println!("Minimal distance: {}", minimal_distance - 2);
}
```


Overlapping Code:
```
in() {
let input_file = match env::args().nth(1) {
Some(input_file) => input_file,
None => {
println!("Please supply input file!");
std::process::exit(1);
}
};
let orbits: Vec<Orbit> = match FileReader::new().split_lines().read_from_file(input_file) {
Ok(input) => input,
Err(e) => {
println!("Error reading input: {}", e);
std::process::exit(1);
}
};
let graph = Graph::construct_graph(&orbits);
let number_of_orbits = graph.count_orbits();
println!("Number of orbits: {}", number_of_orbits);
let minimal_distance = graph.minimal_distance("YOU", "SAN");
println!("Minimal dista
```
<Overlap Ratio: 0.9367909238249594>

---

--- 200 --
Question ID: 3c49efe78c33a7ba0a4c81366ec0a1ce02b21082_0
Original Code:
```
pub fn get_doc(attrs: &[syn::Attribute], null_terminated: bool) -> syn::Lit {
    let mut doc = Vec::new();

    // TODO(althonos): set span on produced doc str literal
    // let mut span = None;

    for attr in attrs.iter() {
        if let Some(syn::Meta::NameValue(ref metanv)) = attr.interpret_meta() {
            if metanv.ident == "doc" {
                // span = Some(metanv.span());
                if let syn::Lit::Str(ref litstr) = metanv.lit {
                    let d = litstr.value();
                    doc.push(if d.starts_with(' ') {
                        d[1..d.len()].to_string()
                    } else {
                        d
                    });
                } else {
                    panic!("Invalid doc comment");
                }
            }
        }
    }

    let doc = doc.join("\n");

    // FIXME: add span
    syn::parse_str(&if null_terminated {
        format!("\"{}\0\"", doc)
    } else {
        format!("\"{}\"", doc)
    })
    .unwrap()
}
```


Overlapping Code:
```
b fn get_doc(attrs: &[syn::Attribute], null_terminated: bool) -> syn::Lit {
let mut doc = Vec::new();
// TODO(althonos): set span on produced doc str literal
// let mut span = None;
for attr in attrs.iter() {
if let Some(syn::Meta::NameValue(ref metanv)) = attr.interpret_meta() {
if metanv.ident == "doc" {
// span = Some(metanv.span());
if let syn::Lit::Str(ref litstr) = metanv.lit {
let d = litstr.value();
doc.push(if d.starts_with(' ') {
d[1..d.len()].to_string()
} else {
d
});
} else {
panic!("Invalid doc comment");
}
}
}
}
let doc = doc.join("\n");
// FIXME: add span
syn::parse_str(&if null_terminated {
format!("\"{}\0\"", doc)
} else {
f
```
<Overlap Ratio: 0.9447674418604651>

---

--- 201 --
Question ID: debf0e957e9532c37cfb48e0ca38a957ebc75263_0
Original Code:
```
fn is_range_empty(engine: &DB, cf: &str, start_key: &[u8], end_key: &[u8]) -> Result<bool> {
    let mut count: u32 = 0;
    engine.scan_cf(cf, start_key, end_key, false, |_, _| {
        count += 1;
        Ok(false)
    })?;

    Ok(count == 0)
}
```


Overlapping Code:
```
ge_empty(engine: &DB, cf: &str, start_key: &[u8], end_key: &[u8]) -> Result<bool> {
let mut count: u32 = 0;
engine.scan_cf(cf, start_key, end_key, false, |_, _| {
count += 1;
Ok(false)
})?;
Ok(count =
```
<Overlap Ratio: 0.9302325581395349>

---

--- 202 --
Question ID: 9636b48c2daa3c3b541943dd47a29eb3d35d6b32_0
Original Code:
```
fn main() {
    local_deprecated!(); //~ WARN use of deprecated item 'local_deprecated': local deprecation note
    deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': deprecation note
}
```


Overlapping Code:
```
~ WARN use of deprecated item 'local_deprecated': local deprecation note
deprecated_macro!(); //~ WARN use of deprecated item 'deprecated_macro': depr
```
<Overlap Ratio: 0.7537688442211056>

---

--- 203 --
Question ID: 2bb96d68f3d3067c15c34ee49864a6e598781ac0_0
Original Code:
```
fn main() -> Result<()> {
    let mut byte_array_test = Vec::new();
    for i in 0i32..1000 {
        let value = (i * i * 255 + i * 7) % 100;
        byte_array_test.push(value as i8)
    }
    let byte_array_test = byte_array_test.into_boxed_slice();
    let value = TestStruct {
        nested: Nested {
            egg: Food {
                name: "Eggbert",
                value: 0.5,
            },
            ham: Food {
                name: "Hampus",
                value: 0.75,
            },
        },
        byte_test: 127,
        short_test: 32767,
        int_test: 2147483647,
        long_test: 9223372036854775807,
        double_test: 0.49312871321823148,
        float_test: 0.49823147058486938,
        string_test: "HELLO WORLD THIS IS A TEST STRING!",
        list_long_test: [11, 12, 13, 14, 15],
        list_compound_test: vec![
            NestedCompound {
                created_on: 1264099775885,
                name: "Compound tag #0",
            },
            NestedCompound {
                created_on: 1264099775885,
                name: "Compound tag #1",
            },
        ],
        byte_array_test,
    };
    println!("{}", to_string_transcript(("Level", &value))?);
    Ok(())
}
```


Overlapping Code:
```
in() -> Result<()> {
let mut byte_array_test = Vec::new();
for i in 0i32..1000 {
let value = (i * i * 255 + i * 7) % 100;
byte_array_test.push(value as i8)
}
let byte_array_test = byte_array_test.into_boxed_slice();
let value = TestStruct {
nested: Nested {
egg: Food {
name: "Eggbert",
value: 0.5,
},
ham: Food {
name: "Hampus",
value: 0.75,
},
},
byte_test: 127,
short_test: 32767,
int_test: 2147483647,
long_test: 9223372036854775807,
double_test: 0.49312871321823148,
float_test: 0.49823147058486938,
string_test: "HELLO WORLD THIS IS A TEST STRING!",
list_long_test: [11, 12, 13, 14, 15],
list_compound_test: vec![
NestedCompound {
created_on: 1264099775885,
name: "Compound tag #0",
},
NestedCompound {
created_on: 1264099775885,
name: "Compound tag #1",
},
],
byte_array_test,
};
println!("{}", to_string_transcript(("L
```
<Overlap Ratio: 0.9627039627039627>

---

--- 204 --
Question ID: 3833dd49822bd951353a13d4bb69e52f525e1493_0
Original Code:
```
fn main() {
    let mut input = format!("");
    std::io::stdin().read_line(&mut input).expect("");
    //let n_arr: usize = input.trim().parse().expect("");
    input = format!("");
    std::io::stdin().read_line(&mut input).expect("");
    let mut arr: Vec<u64> = input
        .trim()
        .split_whitespace()
        .map(|x| x.parse().unwrap())
        .collect();
    let mut sorted: bool = false;
    let mut temp: u64;
    let mut step: u64 = 0;
    loop {
        sorted = true;
        for i in 0..arr.len() - 1 {
            if arr[i] > arr[i + 1] {
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
                step = step + 1;
                sorted = false;
            }
        }
        if sorted == true {
            break;
        }
    }
    println!(
        "Array is sorted in {} swaps.\nFirst Element: {}\nLast Element: {}",
        step,
        arr[0],
        arr[arr.len() - 1]
    );
}
```


Overlapping Code:
```
 {
let mut input = format!("");
std::io::stdin().read_line(&mut input).expect("");
//let n_arr: usize = input.trim().parse().expect("");
input = format!("");
std::io::stdin().read_line(&mut input).expect("");
let mut arr: Vec<u64> = input
.trim()
.split_whitespace()
.map(|x| x.parse().unwrap())
.collect();
let mut sorted: bool = false;
let mut temp: u64;
let mut step: u64 = 0;
loop {
sorted = true;
for i in 0..arr.len() - 1 {
if arr[i] > arr[i + 1] {
temp = arr[i + 1];
arr[i + 1] = arr[i];
arr[i] = temp;
step = step + 1;
sorted = false;
}
}
if sorted == true {
break;
}
}
println!(
"Array is sorted in {} swaps.\nFirst Element: {}\nLast Element: {}",
step,
arr[0],
```
<Overlap Ratio: 0.9530583214793741>

---

--- 205 --
Question ID: 565c1c80b8d9d0a78dea728266f693f25c27f2d0_0
Original Code:
```
fn main() {
    let mut file = read_file("input.txt");
    let l1 = file.nth(0).unwrap();
    let l1 = l1.split(',').map(|s| s.chars());
    let l2 = file.nth(0).unwrap();
    let l2 = l2.split(',').map(|s| s.chars());

    let mut l1_points_hash = HashSet::new();
    let mut x: i32 = 0;
    let mut y: i32 = 0;
    let mut l1_points = vec![(x, y)];
    for mut line in l1 {
        let dir = line.next().unwrap();
        let number = line.as_str().parse::<i32>().unwrap();
        for _ in 0..number {
            match dir {
                'R' => x += 1,
                'D' => y += 1,
                'U' => y -= 1,
                'L' => x -= 1,
                _ => panic!("invalid"),
            }
            l1_points.push((x, y));
            l1_points_hash.insert((x, y));
        }
    }

    let mut candidate_points = Vec::new();

    let mut min_dist = std::i32::MAX;
    x = 0;
    y = 0;
    let mut l2_points = vec![(x, y)];
    l2_points.push((x, y));
    for mut line in l2 {
        let dir = line.next().unwrap();
        let number = line.as_str().parse::<i32>().unwrap();
        for _ in 0..number {
            match dir {
                'R' => x += 1,
                'D' => y += 1,
                'U' => y -= 1,
                'L' => x -= 1,
                _ => panic!("invalid"),
            }
            l2_points.push((x, y));
            if l1_points_hash.contains(&(x, y)) {
                candidate_points.push((x, y)); // needed for part2
                if x.abs() + y.abs() < min_dist {
                    min_dist = x.abs() + y.abs();
                }
            }
        }
    }
    //answer to part1
    println!("distance:{}", min_dist);

    //Now compute steps for all candidate points
    let mut min_steps = std::usize::MAX;
    for (px, py) in candidate_points {
        let l1_steps = l1_points
            .iter()
            .take_while(|(x, y)| *x != px || *y != py)
            .count();
        let l2_steps = l2_points
            .iter()
            .take_while(|(x, y)| *x != px || *y != py)
            .count();
        let sum = l1_steps + l2_steps;
        if sum < min_steps {
            min_steps = sum;
        }
    }

    println!("steps:{}", min_steps);
}
```


Overlapping Code:
```

let mut file = read_file("input.txt");
let l1 = file.nth(0).unwrap();
let l1 = l1.split(',').map(|s| s.chars());
let l2 = file.nth(0).unwrap();
let l2 = l2.split(',').map(|s| s.chars());
let mut l1_points_hash = HashSet::new();
let mut x: i32 = 0;
let mut y: i32 = 0;
let mut l1_points = vec![(x, y)];
for mut line in l1 {
let dir = line.next().unwrap();
let number = line.as_str().parse::<i32>().unwrap();
for _ in 0..number {
match dir {
'R' => x += 1,
'D' => y += 1,
'U' => y -= 1,
'L' => x -= 1,
_ => panic!("invalid"),
}
l1_points.push((x, y));
l1_points_hash.insert((x, y));
}
}
let mut candidate_points = Vec::new();
let mut min_dist = std::i32::MAX;
x = 0;
y = 0;
let mut l2_points = vec![(x, y)];
l2_points.push((x, y));
for mut line in l2 {
let dir = line.next().unwrap();
let number = line.as_str().parse::<i32>().unwrap();
for _ in 0..number {
match dir {
'R' => x += 1,
'D' => y += 1,
'U' => y -= 1,
'L' => x -= 1,
_ => panic!("invalid"),
}
l2_points.push((x, y));
if l1_points_hash.contains(&(x, y)) {
candidate_points.push((x, y)); // needed for part2
if x.abs() + y.abs() < min_dist {
min_dist = x.abs() + y.abs();
}
}
}
}
//answer to part1
println!("distance:{}", min_dist);
//Now compute steps for all candidate points
let mut min_steps = std::usize::MAX;
for (px, py) in candidate_points {
let l1_steps = l1_points
.iter()
.take_while(|(x, y)| *x != px || *y != py)
.count();
let l2_steps = l2_points
.iter()
.take_while(|(x, y)| *x != px || *y != py)
.count();
let sum = l1_steps + l2_steps;
if sum < min_steps {
min_steps = sum;
```
<Overlap Ratio: 0.96875>

---

--- 206 --
Question ID: 2867a1f3feefae55b4fc230de6519892c66e499b_5
Original Code:
```
unsafe fn last_row(buf: &mut [u8], data: &[u8], x: usize, w: usize, h: usize) {
    debug_assert!(buf.len() == 3*w*h);
    debug_assert!(data.len() == w*h);
    debug_assert!(x < w);

    let y = h - 2;

    let g1 = get(data, x  , y-1, w);
    let g3 = get(data, x-1, y, w);
    let g5 = get(data, x+1, y, w);
    let g8 = get(data, x  , y+1, w);
    let g10 = get(data, x+2, y+1, w);

    set(buf, x, y, 1, w, (g1+g3+g5+g8)/4);
    set(buf, x+1, y, 1, w, g5);
    set(buf, x, y+1, 1, w, g8);
    set(buf, x+1, y+1, 1, w, (g5+g8+g10)/3);

    let r0 = get(data, x-1, y-1, w);
    let r2 = get(data, x+1, y-1, w);
    let r7 = get(data, x-1, y+1, w);
    let r9 = get(data, x+1, y+1, w);

    set(buf, x, y, 2, w, (r0+r2+r7+r9)/4);
    set(buf, x+1, y, 2, w, (r2+r9)/2);
    set(buf, x, y+1, 2, w, (r7+r9)/2);
    set(buf, x+1, y+1, 2, w, r9);

    let b4 = get(data, x  , y, w);
    let b6 = get(data, x+2, y, w);

    set(buf, x, y, 0, w, b4);
    set(buf, x+1, y, 0, w, (b4+b6)/2);
    set(buf, x, y+1, 0, w, b4);
    set(buf, x+1, y+1, 0, w, (b4+b6)/2);
}
```


Overlapping Code:
```
8], x: usize, w: usize, h: usize) {
debug_assert!(buf.len() == 3*w*h);
debug_assert!(data.len() == w*h);
debug_assert!(x < w);
let y = h - 2;
let g1 = get(data, x , y-1, w);
let g3 = get(data, x-1, y, w);
let g5 = get(data, x+1, y, w);
let g8 = get(data, x , y+1, w);
let g10 = get(data, x+2, y+1, w);
set(buf, x, y, 1, w, (g1+g3+g5+g8)/4);
set(buf, x+1, y, 1, w, g5);
set(buf, x, y+1, 1, w, g8);
set(buf, x+1, y+1, 1, w, (g5+g8+g10)/3);
let r0 = get(data, x-1, y-1, w);
let r2 = get(data, x+1, y-1, w);
let r7 = get(data, x-1, y+1, w);
let r9 = get(data, x+1, y+1, w);
set(buf, x, y, 2, w, (r0+r2+r7+r9)/4);
set(buf, x+1, y, 2, w, (r2+r9)/2);
set(buf, x, y+1, 2, w, (r7+r9)/2);
set(buf, x+1, y+1, 2, w, r9);
let b4 = get(data, x , y, w);
let b6 = get(data, x+2, y, w);
set(buf, x, y, 0, w, b4);
set(buf, x+1, y, 0, w, (b4+b6)/2);
set(buf, x, y+1, 0, w, b4);
set(buf, x+1, y+1, 
```
<Overlap Ratio: 0.9330499468650372>

---

--- 207 --
Question ID: eb9b23205a19504ec56baccd162346bee27f35ac_3
Original Code:
```
fn test_scope() {
        /*
        Scope (_SB.MBRD)
        {
            Name (_CRS, ResourceTemplate ()  // _CRS: Current Resource Settings
            {
                Memory32Fixed (ReadWrite,
                    0xE8000000,         // Address Base
                    0x10000000,         // Address Length
                    )
            })
        }
        */

        let mbrd_scope = [
            0x10, 0x21, 0x2E, 0x5F, 0x53, 0x42, 0x5F, 0x4D, 0x42, 0x52, 0x44, 0x08, 0x5F, 0x43,
            0x52, 0x53, 0x11, 0x11, 0x0A, 0x0E, 0x86, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE8,
            0x00, 0x00, 0x00, 0x10, 0x79, 0x00,
        ];

        assert_eq!(
            Scope::new(
                "_SB_.MBRD".into(),
                vec![&Name::new(
                    "_CRS".into(),
                    &ResourceTemplate::new(vec![&Memory32Fixed::new(
                        true,
                        0xE800_0000,
                        0x1000_0000
                    )])
                )]
            )
            .to_aml_bytes(),
            &mbrd_scope[..]
        );
    }
```


Overlapping Code:
```
_scope() {
/*
Scope (_SB.MBRD)
{
Name (_CRS, ResourceTemplate () // _CRS: Current Resource Settings
{
Memory32Fixed (ReadWrite,
0xE8000000, // Address Base
0x10000000, // Address Length
)
})
}
*/
let mbrd_scope = [
0x10, 0x21, 0x2E, 0x5F, 0x53, 0x42, 0x5F, 0x4D, 0x42, 0x52, 0x44, 0x08, 0x5F, 0x43,
0x52, 0x53, 0x11, 0x11, 0x0A, 0x0E, 0x86, 0x09, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE8,
0x00, 0x00, 0x00, 0x10, 0x79, 0x00,
];
assert_eq!(
Scope::new(
"_SB_.MBRD".into(),
vec![&Name::new(
"_CRS".into(),
&ResourceTemplate::new(vec![&Memory32Fixed::new(
true,
0xE800_0000,
0x1000_0000
)])
)]
)
.to_aml_bytes(),
&mbrd_scope
```
<Overlap Ratio: 0.9746434231378764>

---

--- 208 --
Question ID: e2f89e943d304541c8ccd8a980ecf9d1ce9c654c_4
Original Code:
```
fn update_velocities_1d(moons: &mut Vec<&mut Moon1D>) {
    let mut moons_clone: Vec<Moon1D> = vec![];

    for moon in moons.iter() {
        moons_clone.push(**moon.clone());
    }

    for moon_update in moons.iter_mut() {
        for moon in moons_clone.iter() {
            moon_update.update_velocity(*moon);
        }
    }
}
```


Overlapping Code:
```
ate_velocities_1d(moons: &mut Vec<&mut Moon1D>) {
let mut moons_clone: Vec<Moon1D> = vec![];
for moon in moons.iter() {
moons_clone.push(**moon.clone());
}
for moon_update in moons.iter_mut() {
for moon in moons_clone.iter() {
moon_update.update_velo
```
<Overlap Ratio: 0.9124087591240876>

---

--- 209 --
Question ID: de8d796c472d95c1d39dd823d9b1acfd1afb5b94_7
Original Code:
```
fn g_mpolygon_to_w_mpolygon(g_mpolygon: &geo_types::MultiPolygon<f64>) -> MultiPolygon {
    let &geo_types::MultiPolygon(ref g_polygons) = g_mpolygon;
    let w_polygons = g_polygons_to_w_polygons(g_polygons);
    MultiPolygon(w_polygons)
}
```


Overlapping Code:
```
polygon(g_mpolygon: &geo_types::MultiPolygon<f64>) -> MultiPolygon {
let &geo_types::MultiPolygon(ref g_polygons) = g_mpolygon;
let w_polygons = g_polygons_to_w_polygons(g_polygons);
MultiPolygon(w_polygons)
}
```
<Overlap Ratio: 0.9126637554585153>

---

--- 210 --
Question ID: c07c906f4e2d89e2c628ffb8b0d12fd5c80dc16d_7
Original Code:
```
fn clear(mut cx: FunctionContext) -> JsResult<JsUndefined> {
    let x = cx.argument::<JsNumber>(0)?.value();
    terminal().clear(map_js_clear_type(x as u16));
    Ok(cx.undefined())
}
```


Overlapping Code:
```
(mut cx: FunctionContext) -> JsResult<JsUndefined> {
let x = cx.argument::<JsNumber>(0)?.value();
terminal().clear(map_js_c
```
<Overlap Ratio: 0.7109826589595376>

---

--- 211 --
Question ID: 8494e71f88ab6613fb56f6f14e886aa65e4aefe3_2
Original Code:
```
pub extern "C" fn environment_set_decimal(env: *mut ASTEnvironment,
                                          name: *const c_char,
                                          value: f64) {
    let environment = unsafe { &mut *env };
    let key: String = unsafe { CStr::from_ptr(name).to_string_lossy().into_owned() };

    environment.set(key.as_str(), Lit::Decimal(value));
}
```


Overlapping Code:
```
ment_set_decimal(env: *mut ASTEnvironment,
name: *const c_char,
value: f64) {
let environment = unsafe { &mut *env };
let key: String = unsafe { CStr::from_ptr(name).to_string_lossy().into_owned() };
environment.set(key.as_str(), Lit::Decimal(value))
```
<Overlap Ratio: 0.8992805755395683>

---

--- 212 --
Question ID: 7a5c4c6f1fb8404074bc9ef350a73b801ae2d166_0
Original Code:
```
fn display(&self) -> String {
        let mut display = String::from("option name ")
            + self.option_name()
            + " type "
            + self.option_type();

        if let Some(part_dis) = self.partial_display() {
            display += " ";
            display += &part_dis;
        }
        display
    }
```


Overlapping Code:
```
fn display(&self) -> String {
let mut display = String::from("option name ")
+ self.option_name()
+ " type "
+ self.option_type();
if let Some(part_dis) = self.partial_display() {
display += " ";
disp
```
<Overlap Ratio: 0.8733624454148472>

---

--- 213 --
Question ID: 12d2341080374528fc5e5df648a6876f10f81621_0
Original Code:
```
pub fn check_config(spec: &Spec) -> Result<bool, Error> {
    let deploy_config = render_deploy_config(&spec)
        .map_err(|e| format_err!("{}", e))?;
    let ref filename = spec.config.vagga_config;
    let mut buf = String::with_capacity(1024);
    let mut f = match File::open(&filename) {
        Ok(f) => f,
        Err(ref e) if e.kind() == io::ErrorKind::NotFound => return Ok(false),
        Err(e) => bail!("Can't open file {:?}: {}", filename, e),
    };
    f.read_to_string(&mut buf)
        .map_err(|e| format_err!("Error reading {:?}: {}", filename, e))?;
    return Ok(deploy_config == buf);
}
```


Overlapping Code:
```
Spec) -> Result<bool, Error> {
let deploy_config = render_deploy_config(&spec)
.map_err(|e| format_err!("{}", e))?;
let ref filename = spec.config.vagga_config;
let mut buf = String::with_capacity(1024);
let mut f = match File::open(&filename) {
Ok(f) => f,
Err(ref e) if e.kind() == io::ErrorKind::NotFound => return Ok(false),
Err(e) => bail!("Can't open file {:?}: {}", filename, e),
};
f.read_to_string(&mut buf)
.map_err(|e| format_err!("Error reading {:?}: {}", filename, e))?;
return Ok(deploy
```
<Overlap Ratio: 0.9174311926605505>

---

--- 214 --
Question ID: 4ce4fa3770f043bf602d3076f9b8b92b67fad2ea_1
Original Code:
```
fn run_meal_server(listen_address: &str,
                   i_transport_factory: Box<TTransportFactory>,
                   i_protocol_factory: Box<TInputProtocolFactory>,
                   o_transport_factory: Box<TTransportFactory>,
                   o_protocol_factory: Box<TOutputProtocolFactory>)
                   -> thrift::Result<()> {
    let processor = MealServiceSyncProcessor::new(PartHandler {});
    let mut server = TSimpleServer::new(i_transport_factory,
                                        i_protocol_factory,
                                        o_transport_factory,
                                        o_protocol_factory,
                                        processor);

    server.listen(listen_address)
}
```


Overlapping Code:
```
r(listen_address: &str,
i_transport_factory: Box<TTransportFactory>,
i_protocol_factory: Box<TInputProtocolFactory>,
o_transport_factory: Box<TTransportFactory>,
o_protocol_factory: Box<TOutputProtocolFactory>)
-> thrift::Result<()> {
let processor = MealServiceSyncProcessor::new(PartHandler {});
let mut server = TSimpleServer::new(i_transport_factory,
i_protocol_factory,
o_transport_factory,
o_protocol_factory,
processor);
server.li
```
<Overlap Ratio: 0.9180672268907563>

---

--- 215 --
Question ID: 99ec1b268c51c3421dd383fb23681b4c110262f0_102
Original Code:
```
fn make_braced_expression(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {
        let s = State::next(s, &[&arg0, &arg1, &arg2]);
        let r = Self::R::make_braced_expression(&s, arg0, arg1, arg2);
        (s, r)
    }
```


Overlapping Code:
```
xpression(s: State, arg0 : Self::R, arg1 : Self::R, arg2 : Self::R) -> (State, Self::R) {
let s = State::next(s, &[&arg0, &arg1, &arg2]);
let r = Self::R::make_braced_exp
```
<Overlap Ratio: 0.7555555555555555>

---

--- 216 --
Question ID: c2cbdf536ea85ec0bf04276863059a2f52bd05c1_12
Original Code:
```
pub fn derive_enum_signingkey(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);

    let name = &ast.ident;
    let public_key_type = get_type_from_attrs(&ast.attrs, "PublicKeyType").unwrap();
    let signature_type = get_type_from_attrs(&ast.attrs, "SignatureType").unwrap();
    match ast.data {
        Data::Enum(ref variants) => {
            impl_enum_signingkey(name, public_key_type, signature_type, variants)
        }
        Data::Struct(_) | Data::Union(_) => {
            panic!("#[derive(PrivateKey)] is only defined for enums")
        }
    }
}
```


Overlapping Code:
```
 derive_enum_signingkey(input: TokenStream) -> TokenStream {
let ast = parse_macro_input!(input as DeriveInput);
let name = &ast.ident;
let public_key_type = get_type_from_attrs(&ast.attrs, "PublicKeyType").unwrap();
let signature_type = get_type_from_attrs(&ast.attrs, "SignatureType").unwrap();
match ast.data {
Data::Enum(ref variants) => {
impl_enum_signingkey(name, public_key_type, signature_type, variants)
}
Data::Struct(_) | Data::Union(_) => {
panic!("#[derive(PrivateKey)] is only defined for enum
```
<Overlap Ratio: 0.97131931166348>

---

--- 217 --
Question ID: 8375521a70210c4c52d2caa4043e490a84754f40_2
Original Code:
```
pub fn sync<F, B, E>(spec: FactoryChainSpec<F>, mut block_factory: B, mut extrinsic_factory: E) where
	F: ServiceFactory,
	F::FullService: Future<Item=(), Error=()>,
	F::LightService: Future<Item=(), Error=()>,
	B: FnMut(&SyncService<F::FullService>) -> BlockImportParams<F::Block>,
	E: FnMut(&SyncService<F::FullService>) -> FactoryExtrinsic<F>,
{
	const NUM_FULL_NODES: usize = 10;
	// FIXME: BABE light client support is currently not working.
	const NUM_LIGHT_NODES: usize = 0;
	const NUM_BLOCKS: usize = 512;
	let temp = TempDir::new("substrate-sync-test").expect("Error creating test dir");
	let mut network = TestNet::<F>::new(
		&temp,
		spec.clone(),
		NUM_FULL_NODES,
		NUM_LIGHT_NODES,
		vec![],
		30500,
	);
	info!("Checking block sync");
	let first_address = {
		let first_service = &network.full_nodes[0].1;
		let mut client = first_service.get().client();
		for i in 0 .. NUM_BLOCKS {
			if i % 128 == 0 {
				info!("Generating #{}", i);
			}
			let import_data = block_factory(&first_service);
			client.import_block(import_data, HashMap::new()).expect("Error importing test block");
		}
		network.full_nodes[0].2.clone()
	};

	info!("Running sync");
	for (_, service, _) in network.full_nodes.iter().skip(1) {
		service.get().network().add_reserved_peer(first_address.to_string()).expect("Error adding reserved peer");
	}
	for (_, service, _) in network.light_nodes.iter() {
		service.get().network().add_reserved_peer(first_address.to_string()).expect("Error adding reserved peer");
	}
	network.run_until_all_full(
		|_index, service|
			service.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),
		|_index, service|
			service.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),
	);

	info!("Checking extrinsic propagation");
	let first_service = network.full_nodes[0].1.clone();
	let best_block = BlockId::number(first_service.get().client().info().chain.best_number);
	let extrinsic = extrinsic_factory(&first_service);
	first_service.get().transaction_pool().submit_one(&best_block, extrinsic).unwrap();
	network.run_until_all_full(
		|_index, service| service.get().transaction_pool().ready().count() == 1,
		|_index, _service| true,
	);
}
```


Overlapping Code:
```
pec: FactoryChainSpec<F>, mut block_factory: B, mut extrinsic_factory: E) where
F: ServiceFactory,
F::FullService: Future<Item=(), Error=()>,
F::LightService: Future<Item=(), Error=()>,
B: FnMut(&SyncService<F::FullService>) -> BlockImportParams<F::Block>,
E: FnMut(&SyncService<F::FullService>) -> FactoryExtrinsic<F>,
{
const NUM_FULL_NODES: usize = 10;
// FIXME: BABE light client support is currently not working.
const NUM_LIGHT_NODES: usize = 0;
const NUM_BLOCKS: usize = 512;
let temp = TempDir::new("substrate-sync-test").expect("Error creating test dir");
let mut network = TestNet::<F>::new(
&temp,
spec.clone(),
NUM_FULL_NODES,
NUM_LIGHT_NODES,
vec![],
30500,
);
info!("Checking block sync");
let first_address = {
let first_service = &network.full_nodes[0].1;
let mut client = first_service.get().client();
for i in 0 .. NUM_BLOCKS {
if i % 128 == 0 {
info!("Generating #{}", i);
}
let import_data = block_factory(&first_service);
client.import_block(import_data, HashMap::new()).expect("Error importing test block");
}
network.full_nodes[0].2.clone()
};
info!("Running sync");
for (_, service, _) in network.full_nodes.iter().skip(1) {
service.get().network().add_reserved_peer(first_address.to_string()).expect("Error adding reserved peer");
}
for (_, service, _) in network.light_nodes.iter() {
service.get().network().add_reserved_peer(first_address.to_string()).expect("Error adding reserved peer");
}
network.run_until_all_full(
|_index, service|
service.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),
|_index, service|
service.get().client().info().chain.best_number == (NUM_BLOCKS as u32).into(),
);
info!("Checking extrinsic propagation");
let first_service = network.full_nodes[0].1.clone();
let best_block = BlockId::number(first_service.get().client().info().chain.best_number);
let extrinsic = extrinsic_factory(&first_service);
first_service.get().transaction_pool().submit_one(&best_block, extrinsic).unwrap();
network.run_until_all_full(
|_index, service| service.get().transaction_pool().ready().count() == 1,
|_index, _ser
```
<Overlap Ratio: 0.9820245979186376>

---

--- 218 --
Question ID: e9bad59d21144d285f826a09abafb38ed1827fee_0
Original Code:
```
pub fn run() {
    let mut client = serenity::client::Client::new(config::DISCORD_TOKEN, Handler::new()).expect("To create client");

    client.with_framework(
        serenity::framework::StandardFramework::new().configure(configure)
                                                     .help(&HELP)
                                                     .on_dispatch_error(on_dispatch_error)
                                                     .group(&GENERAL_GROUP)
                                                     .group(&ADMIN_GROUP)
    );

    match client.cache_and_http.http.get_current_user() {
        Ok(info) => {
            SELF_ID.store(info.id.0, Ordering::Release);
        },
        Err(error) => {
            rogu::error!("Discord unable to get current user info: {}", error);
        }
    }

    if config::DISCORD.with_read(|config| config.owner) == 0 {
        match client.cache_and_http.http.get_current_application_info() {
            Ok(info) => {
                rogu::info!("Discord setting new owner id={}", info.owner.id.0);
                config::DISCORD.with_write(|config| config.owner = info.owner.id.0);
            },
            Err(error) => {
                rogu::error!("Discord unable to get application information: {}", error);
                STATS.increment(stats::DiscordNoAppInfo);
            }
        };
    }

    HTTP.write().replace(client.cache_and_http.clone());

    while let Some((tweet_id, user_name, tweet_type)) = twitter::BUFFERED_TWEETS.dequeue() {
        twitter::redirect_tweet(&client.cache_and_http.http, tweet_id, user_name, tweet_type);
    }

    loop {
        rogu::info!("Discord: start");
        match client.start() {
            Ok(_) => {
                STATS.increment(stats::DiscordShutdown);
                break;
            }
            Err(error) => {
                STATS.increment(stats::DiscordFailure);
                rogu::warn!("Discord stopped with error: {}", error);
            }
        }
    }

    HTTP.write().take();
}
```


Overlapping Code:
```
= serenity::client::Client::new(config::DISCORD_TOKEN, Handler::new()).expect("To create client");
client.with_framework(
serenity::framework::StandardFramework::new().configure(configure)
.help(&HELP)
.on_dispatch_error(on_dispatch_error)
.group(&GENERAL_GROUP)
.group(&ADMIN_GROUP)
);
match client.cache_and_http.http.get_current_user() {
Ok(info) => {
SELF_ID.store(info.id.0, Ordering::Release);
},
Err(error) => {
rogu::error!("Discord unable to get current user info: {}", error);
}
}
if config::DISCORD.with_read(|config| config.owner) == 0 {
match client.cache_and_http.http.get_current_application_info() {
Ok(info) => {
rogu::info!("Discord setting new owner id={}", info.owner.id.0);
config::DISCORD.with_write(|config| config.owner = info.owner.id.0);
},
Err(error) => {
rogu::error!("Discord unable to get application information: {}", error);
STATS.increment(stats::DiscordNoAppInfo);
}
};
}
HTTP.write().replace(client.cache_and_http.clone());
while let Some((tweet_id, user_name, tweet_type)) = twitter::BUFFERED_TWEETS.dequeue() {
twitter::redirect_tweet(&client.cache_and_http.http, tweet_id, user_name, tweet_type);
}
loop {
rogu::info!("Discord: start");
match client.start() {
Ok(_) => {
STATS.increment(stats::DiscordShutdown);
break;
}
Err(error) => {
STATS.increment(stats::DiscordFailure);
rogu::warn!("Discord stopped with e
```
<Overlap Ratio: 0.9460406447091801>

---

--- 219 --
Question ID: 12e8f9733fe2a0d5c3b46246047def3f81a8f7cd_9
Original Code:
```
fn irr(
        leg_:Leg,
        npv_:Real,
        dayCounter_:Box<DayCounter>,
        compounding_:Compounding,
        frequency_:Frequency,
        includeSettlementDateFlows_:bool,
        settlementDate_:LocalDate, 
        npvDate_:LocalDate,
        accuracy:Real,
        maxIterations:usize,
        guess:Real)->Real {
        let mut solver = Solver1D::default();
        solver.setMaxEvaluations(maxIterations);
        return irr_(solver, leg_, npv_, dayCounter_,
                    compounding_, frequency_,
                    includeSettlementDateFlows_,
                    settlementDate_, npvDate_,
                    accuracy, guess);
}
```


Overlapping Code:
```
leg_:Leg,
npv_:Real,
dayCounter_:Box<DayCounter>,
compounding_:Compounding,
frequency_:Frequency,
includeSettlementDateFlows_:bool,
settlementDate_:LocalDate, 
npvDate_:LocalDate,
accuracy:Real,
maxIterations:usize,
guess:Real)->Real {
let mut solver = Solver1D::default();
solver.setMaxEvaluations(maxIterations);
return irr_(solver, leg_, npv_, dayCounter_,
compounding_, frequency_,
includeSettlementDateFlows_,
settlementDate_, np
```
<Overlap Ratio: 0.9253731343283582>

---

--- 220 --
Question ID: 0b458401e1b7d5cf9a66d03576d5655663a69e37_3
Original Code:
```
fn test_normalization() {
    assert_eq!(huifier::huify(""), "Хуй");
    assert_eq!(huifier::huify(" "), "Хуй");
    assert_eq!(huifier::huify("   "), "Хуй");
    assert_eq!(huifier::huify("  Вилка  "), "Хуилка");
    assert_eq!(huifier::huify("Й"), "Хуй");
    assert_eq!(huifier::huify("О"), "Хуё");
}
```


Overlapping Code:
```
t_normalization() {
assert_eq!(huifier::huify(""), "Хуй");
assert_eq!(huifier::huify(" "), "Хуй");
assert_eq!(huifier::huify(" "), "Хуй");
assert_eq!(huifier::huify(" Вилка "), "Хуилка");
assert_eq!(huifier::huify("Й"), "Хуй");
assert_eq!(huifier::hu
```
<Overlap Ratio: 0.9090909090909091>

---

--- 221 --
Question ID: 027b6a61e28dbcd833904451788b18bd7d052de7_0
Original Code:
```
pub fn open(req: OpenRequest) -> super::super::error::Result<()> {
    let mut hm = ::std::collections::HashMap::new();
    hm.insert("token".to_owned(), req.token);
    hm.insert("dialog".to_owned(), serde_json::to_string(&req.dialog)?);
    hm.insert("trigger_id".to_owned(), req.trigger_id);
    let response: OpenResponse = super::request("dialog.open", &hm)?;

    if !response.ok {
        return Err(From::from("Bad Slack Response"));
    }

    Ok(())
}
```


Overlapping Code:
```
open(req: OpenRequest) -> super::super::error::Result<()> {
let mut hm = ::std::collections::HashMap::new();
hm.insert("token".to_owned(), req.token);
hm.insert("dialog".to_owned(), serde_json::to_string(&req.dialog)?);
hm.insert("trigger_id".to_owned(), req.trigger_id);
let response: OpenResponse = super::request("dialog.open", &hm)?;
if !response.ok {
return Err(From::from("Bad Slack Response"))
```
<Overlap Ratio: 0.954653937947494>

---

--- 222 --
Question ID: 3b7a00a2c73c6dd3cba02828e4bdec4b19428f32_0
Original Code:
```
fn main() {
    // this signals overflow when checking is on
    let x = 1_i8 << 17;

    // ... but when checking is off, the fallback will truncate the
    // input to its lower three bits (= 1). Note that this is *not*
    // the behavior of the x86 processor for 8- and 16-bit types,
    // but it is necessary to avoid undefined behavior from LLVM.
    //
    // We check that here, by ensuring the result has only been
    // shifted by one place; if overflow checking is turned off, then
    // this assertion will pass (and the compiletest driver will
    // report that the test did not produce the error expected above).
    assert_eq!(x, 2_i8);
}
```


Overlapping Code:
```
 this signals overflow when checking is on
let x = 1_i8 << 17;
// ... but when checking is off, the fallback will truncate the
// input to its lower three bits (= 1). Note that this is *not*
// the behavior of the x86 processor for 8- and 16-bit types,
// but it is necessary to avoid undefined behavior from LLVM.
//
// We check that here, by ensuring the result has only been
// shifted by one place; if overflow checking is turned off, then
// this assertion will pass (and the compiletest driver will
// report that the test did not produce the error expected 
```
<Overlap Ratio: 0.9276315789473685>

---

--- 223 --
Question ID: 988c2c115995c18a31b43e2398f81c6df358924f_4
Original Code:
```
fn test_VSMT_4_Verif() {
        let width = 5;

        let mut db = InMemoryHashDb::<DBVal_4_ary>::new();

        #[cfg(feature = "bls381")]
        let (full_b, full_e, partial_rounds) = (4, 4, 56);

        #[cfg(feature = "bn254")]
        let (full_b, full_e, partial_rounds) = (4, 4, 56);

        #[cfg(feature = "secp256k1")]
        let (full_b, full_e, partial_rounds) = (4, 4, 56);

        #[cfg(feature = "ed25519")]
        let (full_b, full_e, partial_rounds) = (4, 4, 56);

        let total_rounds = full_b + partial_rounds + full_e;
        let hash_params = PoseidonParams::new(width, full_b, full_e, partial_rounds);
        let tree_depth = 12;
        let mut tree = VanillaSparseMerkleTree_4::new(&hash_params, tree_depth, &mut db);

        for i in 1..=10 {
            let s = FieldElement::from(i as u32);
            tree.update(&s, s.clone(), &mut db).unwrap();
        }

        // TODO: Use iterators. Generating so many generators at once is very slow. In practice, generators will be persisted.
        let G: G1Vector = get_generators("G", 8192).into();
        let H: G1Vector = get_generators("H", 8192).into();

        let g = G1::from_msg_hash("g".as_bytes());
        let h = G1::from_msg_hash("h".as_bytes());

        for i in vec![3u32, 4u32, 7u32, 8u32, 9u32] {
            let mut merkle_proof_vec = Vec::<ProofNode_4_ary>::new();
            let mut merkle_proof = Some(merkle_proof_vec);
            let k = FieldElement::from(i);
            assert_eq!(k, tree.get(&k, &mut merkle_proof, &db).unwrap());
            merkle_proof_vec = merkle_proof.unwrap();
            assert!(tree.verify_proof(&k, &k, &merkle_proof_vec, Some(&tree.root)));

            let mut rng = rand::thread_rng();

            let sbox_type = &SboxType::Quint;

            let label = b"4-aryMerkleTree";

            let (proof, commitments) = gen_proof_of_leaf_inclusion_4_ary_merkle_tree(
                k.clone(),
                k.clone(),
                None,
                merkle_proof_vec,
                &tree.root,
                tree.depth,
                &hash_params,
                sbox_type,
                Some(&mut rng),
                label,
                &g,
                &h,
                &G,
                &H,
            )
            .unwrap();

            verify_proof_of_leaf_inclusion_4_ary_merkle_tree(
                &tree.root,
                tree.depth,
                &hash_params,
                sbox_type,
                proof,
                commitments,
                label,
                &g,
                &h,
                &G,
                &H,
            )
            .unwrap();
        }
    }
```


Overlapping Code:
```
;
let mut db = InMemoryHashDb::<DBVal_4_ary>::new();
#[cfg(feature = "bls381")]
let (full_b, full_e, partial_rounds) = (4, 4, 56);
#[cfg(feature = "bn254")]
let (full_b, full_e, partial_rounds) = (4, 4, 56);
#[cfg(feature = "secp256k1")]
let (full_b, full_e, partial_rounds) = (4, 4, 56);
#[cfg(feature = "ed25519")]
let (full_b, full_e, partial_rounds) = (4, 4, 56);
let total_rounds = full_b + partial_rounds + full_e;
let hash_params = PoseidonParams::new(width, full_b, full_e, partial_rounds);
let tree_depth = 12;
let mut tree = VanillaSparseMerkleTree_4::new(&hash_params, tree_depth, &mut db);
for i in 1..=10 {
let s = FieldElement::from(i as u32);
tree.update(&s, s.clone(), &mut db).unwrap();
}
// TODO: Use iterators. Generating so many generators at once is very slow. In practice, generators will be persisted.
let G: G1Vector = get_generators("G", 8192).into();
let H: G1Vector = get_generators("H", 8192).into();
let g = G1::from_msg_hash("g".as_bytes());
let h = G1::from_msg_hash("h".as_bytes());
for i in vec![3u32, 4u32, 7u32, 8u32, 9u32] {
let mut merkle_proof_vec = Vec::<ProofNode_4_ary>::new();
let mut merkle_proof = Some(merkle_proof_vec);
let k = FieldElement::from(i);
assert_eq!(k, tree.get(&k, &mut merkle_proof, &db).unwrap());
merkle_proof_vec = merkle_proof.unwrap();
assert!(tree.verify_proof(&k, &k, &merkle_proof_vec, Some(&tree.root)));
let mut rng = rand::thread_rng();
let sbox_type = &SboxType::Quint;
let label = b"4-aryMerkleTree";
let (proof, commitments) = gen_proof_of_leaf_inclusion_4_ary_merkle_tree(
k.clone(),
k.clone(),
None,
merkle_proof_vec,
&tree.root,
tree.depth,
&hash_params,
sbox_type,
Some(&mut rng),
label,
&g,
&h,
&G,
&H,
)
.unwrap();
verify_proof_of_leaf_inclusion_4_ary_merkle_tree(
&tree
```
<Overlap Ratio: 0.9557618787547788>

---

--- 224 --
Question ID: 54ff55a37ac8e7a11044c07423baa1b703584212_1
Original Code:
```
fn fixed_height() {
        let (mut tree, root) = layout_tree! {
            (node(display = Block, size.height = Px(10.)))
        };

        tree.calculate(root, 0., 10.);
        assert_eq!(tree.debug(root), "Block(0.0, 10.0) []");

        tree.calculate(root, 10., 0.);
        assert_eq!(tree.debug(root), "Block(10.0, 10.0) []");
    }
```


Overlapping Code:
```
_height() {
let (mut tree, root) = layout_tree! {
(node(display = Block, size.height = Px(10.)))
};
tree.calculate(root, 0., 10.);
assert_eq!(tree.debug(root), "Block(0.0, 10.0) []");
tree.calculate(root, 10., 0.);
assert_eq!(tree.debug(root), "Block(10.0, 1
```
<Overlap Ratio: 0.9280575539568345>

---

--- 225 --
Question ID: 9bdad3ccd5e54814c4f1d59bdbd7e9c6bf5f107a_3
Original Code:
```
pub fn add_chunks(header: String, chunks: &[&[u8]]) -> Vec<u8> {
    let headlen = header.len();
    let rawlen = chunks.iter().fold(1, |sum, c| sum + c.len());
    let mut buf = Vec::with_capacity(5 + headlen + rawlen);
    buf.write_all(&[1]).unwrap(); // version
    buf.write_u32::<LittleEndian>(headlen as u32).unwrap();
    buf.write_all(header.as_bytes()).unwrap();
    buf.write_u8(chunks.len() as u8).unwrap();
    for chunk in chunks {
        buf.write_u32::<LittleEndian>(chunk.len() as u32).unwrap();
        buf.write_all(chunk).unwrap();
    }
    buf
}
```


Overlapping Code:
```
pub fn add_chunks(header: String, chunks: &[&[u8]]) -> Vec<u8> {
let headlen = header.len();
let rawlen = chunks.iter().fold(1, |sum, c| sum + c.len());
let mut buf = Vec::with_capacity(5 + headlen + rawlen);
buf.write_all(&[1]).unwrap(); // version
buf.write_u32::<LittleEndian>(headlen as u32).unwrap();
buf.write_all(header.as_bytes()).unwrap();
buf.write_u8(chunks.len() as u8).unwrap();
for chunk in chunks {
buf.write_u32::<LittleEndian>(chunk.len() as u32).unwrap();
buf.write_all(chunk).unwra
```
<Overlap Ratio: 0.9765625>

---

--- 226 --
Question ID: b194a5513f6755d1d1e9114a658dd899c1279134_80
Original Code:
```
fn swap_hl_op() {
        let mut mem: Memory = Memory::new();
        let addr = 1;
        mem.write_byte(addr, 0b10100101);
        let mut cpu: CPU = CPU::new(&mut mem);
        cpu.registers.write_16b(&Register16bits::HL, addr);

        swap_hl(&mut cpu);

        assert_eq!(mem.read_byte(addr), 0b01011010);
    }
```


Overlapping Code:
```
hl_op() {
let mut mem: Memory = Memory::new();
let addr = 1;
mem.write_byte(addr, 0b10100101);
let mut cpu: CPU = CPU::new(&mut mem);
cpu.registers.write_16b(&Register16bits::HL, addr);
swap_hl(&mut cpu);
assert_eq!(mem.read_byte
```
<Overlap Ratio: 0.8841698841698842>

---

--- 227 --
Question ID: 1ee58ef95cb3db42e6e38ac4c6c773b922bf072a_0
Original Code:
```
fn test_seek_maximum() {
        let mut sub_cursor = SubCursor::new().start(0).end(usize::max_value());

        sub_cursor.seek(SeekFrom::Current(1)).unwrap();

        let position = sub_cursor
            .seek(SeekFrom::Current(u64::max_value() as i64))
            .unwrap();

        assert_eq!(position, 0);

        sub_cursor.seek(SeekFrom::Current(2)).unwrap();

        let position = sub_cursor
            .seek(SeekFrom::Current(u64::max_value() as i64))
            .unwrap();

        assert_eq!(position, 1);

        let position = sub_cursor.seek(SeekFrom::Start(u64::max_value())).unwrap();
        assert_eq!(position, 0);
    }
```


Overlapping Code:
```
_seek_maximum() {
let mut sub_cursor = SubCursor::new().start(0).end(usize::max_value());
sub_cursor.seek(SeekFrom::Current(1)).unwrap();
let position = sub_cursor
.seek(SeekFrom::Current(u64::max_value() as i64))
.unwrap();
assert_eq!(position, 0);
sub_cursor.seek(SeekFrom::Current(2)).unwrap();
let position = sub_cursor
.seek(SeekFrom::Current(u64::max_value() as i64))
.unwrap();
assert_eq!(position, 1);
let position = sub_cursor.seek(SeekFrom::Start(u64::max_value())).unwrap();
assert_eq!(pos
```
<Overlap Ratio: 0.9633911368015414>

---

--- 228 --
Question ID: 0ec973067cd91f723406dbffdd0912d59865edc6_5
Original Code:
```
fn compare(a: &str, b: &str, operator: &CompOp) {
        // Get both versions
        let version_a: Version = a.parse().unwrap();
        let version_b: Version = b.parse().unwrap();

        // Compare them
        assert_eq!(version_a.compare_version(&version_b), operator.clone(),);

        // Compare them
        assert_eq!(version_a.compare_str(b), operator.clone(),);
    }
```


Overlapping Code:
```
b: &str, operator: &CompOp) {
// Get both versions
let version_a: Version = a.parse().unwrap();
let version_b: Version = b.parse().unwrap();
// Compare them
assert_eq!(version_a.compare_version(&version_b), operator.clone(),);
// Compare them
assert_eq!(version_a.com
```
<Overlap Ratio: 0.8317757009345794>

---

--- 229 --
Question ID: 89cbaf2d12ed958d64b971f50820c779d053f628_1
Original Code:
```
fn test_parse_duration() {
    assert_eq!(None, parse_duration(""));
    assert_eq!(None, parse_duration("X"));
    assert_eq!(None, parse_duration("S"));
    assert_eq!(Duration::from_millis(1), parse_duration("1").unwrap());
    assert_eq!(Duration::from_millis(100), parse_duration("100").unwrap());
    assert_eq!(Duration::from_millis(1000), parse_duration("1s").unwrap());
    assert_eq!(Duration::from_millis(2000), parse_duration("2S").unwrap());
    assert_eq!(Duration::from_millis(1500), parse_duration("1.5s").unwrap());
    assert_eq!(Duration::from_millis(60000), parse_duration("1m").unwrap());
    assert_eq!(Duration::from_millis(3600000), parse_duration("1h").unwrap());
    assert_eq!(Duration::from_millis(1800000), parse_duration("0.5h").unwrap());
    assert_eq!(Duration::from_millis(24 * 3600000), parse_duration("1d").unwrap());
}
```


Overlapping Code:
```
se_duration() {
assert_eq!(None, parse_duration(""));
assert_eq!(None, parse_duration("X"));
assert_eq!(None, parse_duration("S"));
assert_eq!(Duration::from_millis(1), parse_duration("1").unwrap());
assert_eq!(Duration::from_millis(100), parse_duration("100").unwrap());
assert_eq!(Duration::from_millis(1000), parse_duration("1s").unwrap());
assert_eq!(Duration::from_millis(2000), parse_duration("2S").unwrap());
assert_eq!(Duration::from_millis(1500), parse_duration("1.5s").unwrap());
assert_eq!(Duration::from_millis(60000), parse_duration("1m").unwrap());
assert_eq!(Duration::from_millis(3600000), parse_duration("1h").unwrap());
assert_eq!(Duration::from_millis(1800000), parse_duration("0.5h").unwrap());
assert_eq!(Duration::from_millis(24
```
<Overlap Ratio: 0.929368029739777>

---

--- 230 --
Question ID: 0fdf076499d7999f24b7275c91703c6682d5c793_0
Original Code:
```
fn main() {
    stdweb::initialize();

    assert!(
        !cluster::is_worker(),
        "This module should not be instantiated as a worker!"
    );

    cluster::setup_master(
        cluster::ClusterSettingsBuilder::new()
            .exec(node_rs::dirname().join("worker.js"))
            .build(),
    );

    println!("I'm the master!");

    let args: Vec<_> = std::env::args().collect();

    let num_procs = if args.len() >= 2 {
        args[1].parse().expect("First argument must be an integer.")
    } else {
        4
    };

    let workers: Vec<_> = (0..num_procs).map(|_| cluster::fork()).collect();

    let promises: Vec<_> = workers
        .iter()
        .cloned()
        .map(|worker| {
            Promise::new(move |resolve, _| {
                worker.on_exit(move |_, _| {
                    resolve.complete();
                });
            })
        })
        .collect();

    Promise::all(&promises).then(|_| {
        println!("Master exiting...");
        stdweb::Value::Undefined
    });

    stdweb::event_loop();
}
```


Overlapping Code:
```
ialize();
assert!(
!cluster::is_worker(),
"This module should not be instantiated as a worker!"
);
cluster::setup_master(
cluster::ClusterSettingsBuilder::new()
.exec(node_rs::dirname().join("worker.js"))
.build(),
);
println!("I'm the master!");
let args: Vec<_> = std::env::args().collect();
let num_procs = if args.len() >= 2 {
args[1].parse().expect("First argument must be an integer.")
} else {
4
};
let workers: Vec<_> = (0..num_procs).map(|_| cluster::fork()).collect();
let promises: Vec<_> = workers
.iter()
.cloned()
.map(|worker| {
Promise::new(move |resolve, _| {
worker.on_exit(move |_, _| {
resolve.complete();
});
})
})
.collect();
Promise::all(&promises).then(|_| {
println!("Master exiting...");
stdweb::Value::Undefined
});
stdweb:
```
<Overlap Ratio: 0.9493670886075949>

---

--- 231 --
Question ID: 53d4b0e15843bcbffd0d575e9f2fec82e4f3dd91_5
Original Code:
```
fn overflow_flag_hi_under() {
    let mut flags = StatusFlags::empty();
    flags.set_overflow(-129i16 as u16);

    assert!(flags.contains(StatusFlags::V_FLAG));
  }
```


Overlapping Code:
```
 overflow_flag_hi_under() {
let mut flags = StatusFlags::empty();
flags.set_overflow(-129i16 as u16)
```
<Overlap Ratio: 0.6622516556291391>

---

--- 232 --
Question ID: 3a7845b9ce83d59a7ac3a5d0a07ef9559b8e0d9f_1
Original Code:
```
pub fn is_lambda() -> bool {
    #[cfg(feature = "local")]
    {
        std::env::var_os("AWS_LAMBDA_RUNTIME_API").is_some()
    }

    #[cfg(not(feature = "local"))]
    {
        true
    }
}
```


Overlapping Code:
```
g(feature = "local")]
{
std::env::var_os("AWS_LAMBDA_RUNTIME_API").is_some()
}
#[cfg(not(feature = "
```
<Overlap Ratio: 0.6535947712418301>

---

--- 233 --
Question ID: 0a3ed13cc8ad6d16a88dd4fed5e2c3c927369b45_1
Original Code:
```
fn new_rect(lat1: i32, lon1: i32, lat2: i32, lon2: i32) -> Rectangle {
    let mut rect = Rectangle::default();
    rect.set_lo(new_point(lat1, lon1));
    rect.set_hi(new_point(lat2, lon2));
    rect
}
```


Overlapping Code:
```
fn new_rect(lat1: i32, lon1: i32, lat2: i32, lon2: i32) -> Rectangle {
let mut rect = Rectangle::default();
rect.set_lo(new_point(lat1, lon1));
rect.set_hi(new_point
```
<Overlap Ratio: 0.8870967741935484>

---

--- 234 --
Question ID: de600b9a9480f426db0c274e78354a485857ba74_0
Original Code:
```
fn parses_blogpost_package_oftd() {
    let src = r#"(authors
  "Nathan Ringo <remexre@gmail.com>")
(license "MIT")
(name foo)
(version "0.1.0")

(components
  (library)
  (binary
    (name "foo")
    (path "src/main.oft")))

(dependencies
  (combinargs
    (version "^0.2.1"))
  (grid
    (git "https://github.com/remexre/oftlisp-grid.git")
    (version "^0.1.0")))
"#;
    let data = PackageMetadata {
        authors: vec!["Nathan Ringo <remexre@gmail.com>".to_string()],
        components: ComponentsMetadata {
            library: Some(LibraryComponentMetadata),
            binaries: vec![BinaryComponentMetadata {
                name: "foo".to_string(),
                path: "src/main.oft".to_string(),
            }],
        },
        dependencies: vec![
            (
                "combinargs".into(),
                DependencyMetadata {
                    git: None,
                    version: "0.2.1".parse().unwrap(),
                },
            ),
            (
                "grid".into(),
                DependencyMetadata {
                    git: Some("https://github.com/remexre/oftlisp-grid.git".to_string()),
                    version: "0.1.0".parse().unwrap(),
                },
            ),
        ].into_iter()
            .collect(),
        license: Some("MIT".to_string()),
        name: "foo".into(),
        version: "0.1.0".parse().unwrap(),
    };

    let lits = parse_program(src).unwrap();
    assert_eq!(data.clone().to_literals(), lits);
    let meta = PackageMetadata::from_literals(lits).unwrap();
    assert_eq!(meta, data);
}
```


Overlapping Code:
```
IT")
(name foo)
(version "0.1.0")
(components
(library)
(binary
(name "foo")
(path "src/main.oft")))
(dependencies
(combinargs
(version "^0.2.1"))
(grid
(git "https://github.com/remexre/oftlisp-grid.git")
(version "^0.1.0")))
"#;
let data = PackageMeg()],
components: ComponentsMetadata {
library: Some(LibraryComponentMetadata),
binaries: vec![BinaryComponentMetadata {
name: "foo".to_string(),
path: "src/main.oft".to_string(),
}],
},
dependencies: vec![
(
"combinargs".into(),
DependencyMetadata {
git: None,
version: "0.2.1".parse().unwrap(),
},
),
(
"grid".into(),
DependencyMetadata {
git: Some("https://github.com/remexre/oftlisp-grid.git".to_string()),
version: "0.1.0".parse().unwrap(),
},
),
].into_iter()
.collect(),
license: Some("MIT".to_string()),
name: "foo".into(),
version: "0.1.0".parse().unwrap(),
};
let lits = parse_program(src).unwrap();
assert_eq!(data.clone().to_literals(), lits);
let meta = PackageMetadata::from_literals(li
```
<Overlap Ratio: 0.8189655172413793>

---

--- 235 --
Question ID: 8da5c467b3fa5aa2cbcfc9d5127dc5dc89fc64d9_0
Original Code:
```
fn empty_read() {
        let mut recv = RecvBuf::new(std::usize::MAX);
        assert_eq!(recv.len(), 0);

        let mut buf = [0; 32];

        assert_eq!(recv.pop(&mut buf), Err(Error::Done));
    }
```


Overlapping Code:
```
ad() {
let mut recv = RecvBuf::new(std::usize::MAX);
assert_eq!(recv.len(), 0);
let mut buf = [0; 32];
assert_eq!(recv.pop(&mut buf), Err(Error::Done));
}
```
<Overlap Ratio: 0.9333333333333333>

---

--- 236 --
Question ID: 22c5e8c32a3eb4f8b9d2b68f1e265dcc1e8369a3_3
Original Code:
```
fn update_maze(
    maze: &mut HashMap<String, Coordinates>,
    drone_coordinates: &Coordinates,
    current_direction: &Direction,
    kind: &CoordinatesKind,
) -> () {
    let coordinates = match current_direction {
        Direction::North => Coordinates::new(
            drone_coordinates.x,
            drone_coordinates.y + 1,
            Some(drone_coordinates.distance + 1),
            Some(kind.clone()),
        ),
        Direction::East => Coordinates::new(
            drone_coordinates.x + 1,
            drone_coordinates.y,
            Some(drone_coordinates.distance + 1),
            Some(kind.clone()),
        ),
        Direction::South => Coordinates::new(
            drone_coordinates.x,
            drone_coordinates.y - 1,
            Some(drone_coordinates.distance + 1),
            Some(kind.clone()),
        ),
        Direction::West => Coordinates::new(
            drone_coordinates.x - 1,
            drone_coordinates.y,
            Some(drone_coordinates.distance + 1),
            Some(kind.clone()),
        ),
    };

    let key = coordinates.to_maze_key();
    if !maze.contains_key(&key) {
        maze.insert(coordinates.to_maze_key(), coordinates.clone());
    } else {
        if maze.get(&key).unwrap().distance > coordinates.distance {
            maze.insert(coordinates.to_maze_key(), coordinates.clone());
        }
    }
}
```


Overlapping Code:
```
mut HashMap<String, Coordinates>,
drone_coordinates: &Coordinates,
current_direction: &Direction,
kind: &CoordinatesKind,
) -> () {
let coordinates = match current_direction {
Direction::North => Coordinates::new(
drone_coordinates.x,
drone_coordinates.y + 1,
Some(drone_coordinates.distance + 1),
Some(kind.clone()),
),
Direction::East => Coordinates::new(
drone_coordinates.x + 1,
drone_coordinates.y,
Some(drone_coordinates.distance + 1),
Some(kind.clone()),
),
Direction::South => Coordinates::new(
drone_coordinates.x,
drone_coordinates.y - 1,
Some(drone_coordinates.distance + 1),
Some(kind.clone()),
),
Direction::West => Coordinates::new(
drone_coordinates.x - 1,
drone_coordinates.y,
Some(drone_coordinates.distance + 1),
Some(kind.clone()),
),
};
let key = coordinates.to_maze_key();
if !maze.contains_key(&key) {
maze.insert(coordinates.to_maze_key(), coordinates.clone());
} else {
if maze.get(&key).unwrap().distance > coordinates.distance {
maze.insert(coordinates.to_maze_key(), coordi
```
<Overlap Ratio: 0.9578544061302682>

---

--- 237 --
Question ID: 56c98fa0761a4f26afa8494785b0973862ea2945_0
Original Code:
```
pub fn load_block_report(path: &str) -> Result<BlockReport> {
    println!("Reading BlockReport from blocks.json");
    let block_report = read_to_string(path).context("blocks report `blocks.json` not found")?;
    serde_json::from_str::<BlockReport>(&block_report).map_err(|err| err.into())
}
```


Overlapping Code:
```
Result<BlockReport> {
println!("Reading BlockReport from blocks.json");
let block_report = read_to_string(path).context("blocks report `blocks.json` not found")?;
serde_json::from_str::<BlockReport>(&
```
<Overlap Ratio: 0.7117437722419929>

---

--- 238 --
Question ID: e184291a10e1f81d117c0559f7b63aedca25f8b4_2
Original Code:
```
fn construct_cpu(filename: &str, classic_mode: bool, output_serial: bool, output_printer: bool) -> Option<Device> {
    let opt_c = match classic_mode {
        true => Device::new(filename),
        false => Device::new_cgb(filename),
    };
    let mut c = match opt_c
    {
        Ok(cpu) => { cpu },
        Err(message) => { warn(message); return None; },
    };

    if output_printer {
        c.attach_printer();
    }
    else {
        c.set_stdout(output_serial);
    }

    Some(c)
}
```


Overlapping Code:
```
construct_cpu(filename: &str, classic_mode: bool, output_serial: bool, output_printer: bool) -> Option<Device> {
let opt_c = match classic_mode {
true => Device::new(filename),
false => Device::new_cgb(filename),
};
let mut c = match opt_c
{
Ok(cpu) => { cpu },
Err(message) => { warn(message); return None; },
};
if output_printer {
c.attach_printer();
}
else {
c.set_stdout(output_serial);
}

```
<Overlap Ratio: 0.9704433497536946>

---

--- 239 --
Question ID: af54f0d6ab27c118a850cdea3b333c5b6e72654f_0
Original Code:
```
fn initialize_environment() -> OcamlEnvironment {
    let (task_tx, task_rx) = channel();
    let spawner = OcamlTaskSpawner { spawned_tasks: Arc::new(Mutex::new(task_tx)) };
    let executor = OcamlThreadExecutor { ready_tasks: task_rx };
    thread::spawn(move || {
        start_ocaml_runtime();
        executor.run()
    });

    OcamlEnvironment { spawner }
}
```


Overlapping Code:
```
nt() -> OcamlEnvironment {
let (task_tx, task_rx) = channel();
let spawner = OcamlTaskSpawner { spawned_tasks: Arc::new(Mutex::new(task_tx)) };
let executor = OcamlThreadExecutor { ready_tasks: task_rx };
thread::spawn(move || {
start_ocaml_runtime();
executor.run()
});
OcamlEnvironment { spawner }

```
<Overlap Ratio: 0.9259259259259259>

---

--- 240 --
Question ID: b13122209cbe9bea76769d10eb0941a034de074f_0
Original Code:
```
fn main() {
    let config = config::get_config();
    let input = fs::read_to_string(&config.target_file_path)
        .expect("unable to read file");

    let ron_ast = parser::parse_ron(&input);
    let ron_formatted = ron_ast.pretty_print(&config);

    if config.format_in_place {
        if config.with_backup {
            create_backup(&config.target_file_path);
        }

        fs::write(&config.target_file_path, ron_formatted)
            .expect("unable to overwrite target file");
    } else {
        println!("{}", ron_formatted);
    }
}
```


Overlapping Code:
```
fn main() {
let config = config::get_config();
let input = fs::read_to_string(&config.target_file_path)
.expect("unable to read file");
let ron_ast = parser::parse_ron(&input);
let ron_formatted = ron_ast.pretty_print(&config);
if config.format_in_place {
if config.with_backup {
create_backup(&config.target_file_path);
}
fs::write(&config.target_file_path, ron_formatted)
.expect("unable to overwrite target file");
} else {
println!("{}", ron_formatted);

```
<Overlap Ratio: 0.9934924078091106>

---

--- 241 --
Question ID: 5b184d4e24859fdd22ebd6aee1c206c05230a6f8_7
Original Code:
```
fn recv_close_gets_none_idle() {
    let (mut tx, mut rx) = mpsc::channel::<i32>(10);
    let mut task = MockTask::new();

    rx.close();

    task.enter(|| {
        let val = assert_ready!(rx.poll());
        assert!(val.is_none());
        assert!(tx.poll_ready().is_err());
    });
}
```


Overlapping Code:
```
e() {
let (mut tx, mut rx) = mpsc::channel::<i32>(10);
let mut task = MockTask::new();
rx.close();
task.enter(|| {
let val = assert_ready!(rx.poll());
assert!(val.is_no
```
<Overlap Ratio: 0.6942148760330579>

---

--- 242 --
Question ID: ec46d9919a51d054ee2df99349e9af08a5b0a658_1
Original Code:
```
pub fn convert(mkdoc: &str) -> String {
    let mut options = Options::empty();
    options.insert(Options::ENABLE_STRIKETHROUGH);
    options.insert(Options::ENABLE_FOOTNOTES);
    options.insert(Options::ENABLE_TASKLISTS);
    options.insert(Options::ENABLE_TABLES);
    let parser = Parser::new_ext(mkdoc, options);

    let mut htdoc = String::new();
    html::push_html(&mut htdoc, parser);
    htdoc
}
```


Overlapping Code:
```
c: &str) -> String {
let mut options = Options::empty();
options.insert(Options::ENABLE_STRIKETHROUGH);
options.insert(Options::ENABLE_FOOTNOTES);
options.insert(Options::ENABLE_TASKLISTS);
options.insert(Options::ENABLE_TABLES);
let parser = Parser::new_ext(mkdoc, options);
let mut htdoc = String::new();
html::push_html(&mut 
```
<Overlap Ratio: 0.8864864864864865>

---

--- 243 --
Question ID: 846dfa56e4e9ff121ac577ff5b11d279c4e15dcf_0
Original Code:
```
fn generate_rsa() {
        let mut pk =
            Pk::generate_rsa(&mut crate::test_support::rand::test_rng(), 2048, 0x10001).unwrap();
        let generated = pk.write_private_pem_string().unwrap();
        assert_eq!(0x10001, pk.rsa_public_exponent().unwrap());
        assert_eq!(generated, TEST_PEM[..TEST_PEM.len() - 1]);
    }
```


Overlapping Code:
```
generate_rsa(&mut crate::test_support::rand::test_rng(), 2048, 0x10001).unwrap();
let generated = pk.write_private_pem_string().unwrap();
assert_eq!(0x10001, pk.rsa_public_exponent().unwrap());
assert_eq!(generat
```
<Overlap Ratio: 0.7386759581881533>

---

--- 244 --
Question ID: ca916874d99d1804e8d632c564046b2689a8f57d_0
Original Code:
```
fn test_fn(dir_name: &str, fn_name: &str) -> Result<(), Error> {
    do catch {
        let facts_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("inputs")
            .join(dir_name)
            .join("nll-facts")
            .join(fn_name);
        println!("facts_dir = {:?}", facts_dir);
        let tables = &mut intern::InternerTables::new();
        let all_facts = tab_delim::load_tab_delimited_facts(tables, &facts_dir)?;
        let naive = Output::compute(&all_facts, Algorithm::Naive, false);
        let opt = Output::compute(&all_facts, Algorithm::DatafrogOpt, true);
        assert_eq!(naive.borrow_live_at, opt.borrow_live_at);
    }
```


Overlapping Code:
```
est_fn(dir_name: &str, fn_name: &str) -> Result<(), Error> {
do catch {
let facts_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
.join("inputs")
.join(dir_name)
.join("nll-facts")
.join(fn_name);
println!("facts_dir = {:?}", facts_dir);
let tables = &mut intern::InternerTables::new();
let all_facts = tab_delim::load_tab_delimited_facts(tables, &facts_dir)?;
let naive = Output::compute(&all_facts, Algorithm::Naive, false);
let opt = Output::compute(&all_facts, Algorithm::DatafrogOpt, true);
assert_eq!(naive.borrow_live_at, opt.borrow_live_at
```
<Overlap Ratio: 0.985480943738657>

---

--- 245 --
Question ID: 51cf295daa4895d161c50a095a69e7784e638f6f_5
Original Code:
```
unsafe extern "C" fn handle_device_removed(mut backend:
                                               *mut wlr_libinput_backend,
                                           mut libinput_dev:
                                               *mut libinput_device) {
    let mut wlr_devices: *mut wl_list =
        libinput_device_get_user_data(libinput_dev) as *mut wl_list;
    let mut vendor: libc::c_int =
        libinput_device_get_id_vendor(libinput_dev) as libc::c_int;
    let mut product: libc::c_int =
        libinput_device_get_id_product(libinput_dev) as libc::c_int;
    let mut name: *const libc::c_char =
        libinput_device_get_name(libinput_dev);
    _wlr_log(WLR_DEBUG,
             b"[%s:%d] Removing %s [%d:%d]\x00" as *const u8 as
                 *const libc::c_char,
             b"../backend/libinput/events.c\x00" as *const u8 as
                 *const libc::c_char, 208i32, name, vendor, product);
    if wlr_devices.is_null() { return }
    let mut dev: *mut wlr_input_device = 0 as *mut wlr_input_device;
    let mut tmp_dev: *mut wlr_input_device = 0 as *mut wlr_input_device;
    dev =
        ((*wlr_devices).next as *mut libc::c_char).offset(-88) as
            *mut wlr_input_device;
    tmp_dev =
        ((*dev).link.next as *mut libc::c_char).offset(-88) as
            *mut wlr_input_device;
    while &mut (*dev).link as *mut wl_list != wlr_devices {
        wlr_input_device_destroy(dev);
        dev = tmp_dev;
        tmp_dev =
            ((*dev).link.next as *mut libc::c_char).offset(-88) as
                *mut wlr_input_device
    }
    let mut i: size_t = 0i32 as size_t;
    while i < (*backend).wlr_device_lists.length {
        if *(*backend).wlr_device_lists.items.offset(i as isize) ==
               wlr_devices as *mut libc::c_void {
            wlr_list_del(&mut (*backend).wlr_device_lists, i);
            break ;
        } else { i = i.wrapping_add(1) }
    }
    free(wlr_devices as *mut libc::c_void);
}
```


Overlapping Code:
```
fe extern "C" fn handle_device_removed(mut backend:
*mut wlr_libinput_backend,
mut libinput_dev:
*mut libinput_device) {
let mut wlr_devices: *mut wl_list =
libinput_device_get_user_data(libinput_dev) as *mut wl_list;
let mut vendor: libc::c_int =
libinput_device_get_id_vendor(libinput_dev) as libc::c_int;
let mut product: libc::c_int =
libinput_device_get_id_product(libinput_dev) as libc::c_int;
let mut name: *const libc::c_char =
libinput_device_get_name(libinput_dev);
_wlr_log(WLR_DEBUG,
b"[%s:%d] Removing %s [%d:%d]\x00" as *const u8 as
*const libc::c_char,
b"../backend/libinput/events.c\x00" as *const u8 as
*const libc::c_char, 208i32, name, vendor, product);
if wlr_devices.is_null() { return }
let mut dev: *mut wlr_input_device = 0 as *mut wlr_input_device;
let mut tmp_dev: *mut wlr_input_device = 0 as *mut wlr_input_device;
dev =
((*wlr_devices).next as *mut libc::c_char).offset(-88) as
*mut wlr_input_device;
tmp_dev =
((*dev).link.next as *mut libc::c_char).offset(-88) as
*mut wlr_input_device;
while &mut (*dev).link as *mut wl_list != wlr_devices {
wlr_input_device_destroy(dev);
dev = tmp_dev;
tmp_dev =
((*dev).link.next as *mut libc::c_char).offset(-88) as
*mut wlr_input_device
}
let mut i: size_t = 0i32 as size_t;
while i < (*backend).wlr_device_lists.length {
if *(*backend).wlr_device_lists.items.offset(i as isize) ==
wlr_devices as *mut libc::c_void {
wlr_list_del(&mut (*backend).wlr_device_lists, i);
break ;
} else { i = i.wrapping_add(1) }
}
free(wlr_devices as
```
<Overlap Ratio: 0.9829619921363041>

---

--- 246 --
Question ID: e29a32837ca460e117c893629bd7c7ad0fa00d7a_26
Original Code:
```
fn test_body_can_move_out_of_passable_body(
        moving_body: PhysicalBody,
        expected_location_after_moving: Point,
    ) {
        let mut world = NphysicsWorld::with_timestep(DEFAULT_TIMESTEP);

        let moving_body_handle = world.add_body(moving_body.clone());

        let passable_body = passable_body();
        let passable_body_handle = world.add_body(passable_body.clone());

        let force = Force {
            torque: Torque::default(),
            linear: Vector { x: 40.0, y: 40.0 },
        };

        world.apply_force(moving_body_handle, force);
        world.step();

        assert_eq!(
            expected_location_after_moving,
            world.body(moving_body_handle).unwrap().location
        );

        assert_eq!(
            passable_body.location,
            world.body(passable_body_handle).unwrap().location
        );
    }
```


Overlapping Code:
```
_out_of_passable_body(
moving_body: PhysicalBody,
expected_location_after_moving: Point,
) {
let mut world = NphysicsWorld::with_timestep(DEFAULT_TIMESTEP);
let moving_body_handle = world.add_body(moving_body.clone());
let passable_body = passable_body();
let passable_body_handle = world.add_body(passable_body.clone());
let force = Force {
torque: Torque::default(),
linear: Vector { x: 40.0, y: 40.0 },
};
world.apply_force(moving_body_handle, force);
world.step();
assert_eq!(
expected_location_after_moving,
world.body(moving_body_handle).unwrap().location
);
assert_eq!(
passable_body.location,
world.body(passable_body_handle).unwrap().locatio
```
<Overlap Ratio: 0.9601181683899557>

---

--- 247 --
Question ID: b7ecef4eacbdb112e8837bf86f4b80e3b8e33182_3
Original Code:
```
fn ask_with_optional_default<F>(question: &str, default: Option<&str>, validator: F) -> String
    where
        F: Fn(String) -> Result<(), String>
{
    println!("{}{}", question, default.map(|start| format!(" [{}]", start)).unwrap_or(String::new()));
    let mut buffer = String::new();
    io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
    match default {
        None => {
            let mut validation_result = validator(buffer.trim().to_string());
            while buffer.trim().is_empty() || validation_result.is_err() {
                println!("{}", if buffer.trim().is_empty() { "Please provide an answer.".to_string() } else { validation_result.unwrap_err() });
                buffer.clear();
                io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
                validation_result = validator(buffer.trim().to_string());
            }
            buffer.trim().to_string()
        }
        Some(default_value) =>
            if buffer.trim().is_empty() {
                default_value.to_string()
            } else {
                let mut validation_result = validator(buffer.trim().to_string());
                while validation_result.is_err() {
                    println!("{}", validation_result.unwrap_err());
                    buffer.clear();
                    io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
                    validation_result = validator(buffer.trim().to_string());
                }
                buffer.trim().to_string()
            }
    }
}
```


Overlapping Code:
```
n: &str, default: Option<&str>, validator: F) -> String
where
F: Fn(String) -> Result<(), String>
{
println!("{}{}", question, default.map(|start| format!(" [{}]", start)).unwrap_or(String::new()));
let mut buffer = String::new();
io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
match default {
None => {
let mut validation_result = validator(buffer.trim().to_string());
while buffer.trim().is_empty() || validation_result.is_err() {
println!("{}", if buffer.trim().is_empty() { "Please provide an answer.".to_string() } else { validation_result.unwrap_err() });
buffer.clear();
io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
validation_result = validator(buffer.trim().to_string());
}
buffer.trim().to_string()
}
Some(default_value) =>
if buffer.trim().is_empty() {
default_value.to_string()
} else {
let mut validation_result = validator(buffer.trim().to_string());
while validation_result.is_err() {
println!("{}", validation_result.unwrap_err());
buffer.clear();
io::stdin().read_line(&mut buffer).expect("Could not read from stdin");
validation_result = validator(buffer.trim().to_string());
}
buffer.trim().t
```
<Overlap Ratio: 0.9548440065681445>

---

--- 248 --
Question ID: 89a4cdc445e3fa9af21cef3c43502fa26f8bcfe9_7
Original Code:
```
fn following_sibling_selects_in_document_order() {
        let package = Package::new();
        let doc = package.as_document();

        let root = doc.root();
        let child1 = doc.create_element("a");
        let child2 = doc.create_comment("b");
        let child3 = doc.create_processing_instruction("c", None);

        root.append_child(child1);
        root.append_child(child2);
        root.append_child(child3);

        let result = execute(FollowingSibling, child1);

        assert_eq!(result, ordered_nodes![child2, child3]);
    }
```


Overlapping Code:
```
owing_sibling_selects_in_document_order() {
let package = Package::new();
let doc = package.as_document();
let root = doc.root();
let child1 = doc.create_element("a");
let child2 = doc.create_comment("b");
let child3 = doc.create_processing_instruction("c", None);
root.append_child(child1);
root.append_child(child2);
root.append_child(child3);
let result = execute(FollowingSibling, child1);
assert
```
<Overlap Ratio: 0.8810572687224669>

---

--- 249 --
Question ID: bbf08393c0cea4fb3d6e0589ed2718bd1e720180_0
Original Code:
```
pub fn minimize1d<F>(mut begin: f64, mut end: f64, iterations: usize, function: F) -> f64
    where F: Fn(f64) -> f64
{
    let mut x1 = 0.0;
    let mut y1 = 0.0;
    let mut x2 = 0.0;
    let mut y2 = 0.0;
    let mut is1 = false;
    let mut is2 = false;
    let inverted_phi = 2.0 / (1.0 + 5.0f64.sqrt());
    (0..iterations)
        .for_each(|_| {
            if !is1 {
                x1 = end - (end  - begin) * inverted_phi;
                y1 = function(x1);
                is1 = true;
            }
            if !is2 {
                x2 = begin + (end - begin) * inverted_phi;
                y2 = function(x2);
                is2 = true;
            }
            if y1 < y2 {
                end = x2;
                x2 = x1;
                y2 = y1;
                is1 = false;
            } else {
                begin = x1;
                x1 = x2;
                y1 = y2;
                is2 = false;
            }
        });
    (begin + end) / 2.0
}
```


Overlapping Code:
```
begin: f64, mut end: f64, iterations: usize, function: F) -> f64
where F: Fn(f64) -> f64
{
let mut x1 = 0.0;
let mut y1 = 0.0;
let mut x2 = 0.0;
let mut y2 = 0.0;
let mut is1 = false;
let mut is2 = false;
let inverted_phi = 2.0 / (1.0 + 5.0f64.sqrt());
(0..iterations)
.for_each(|_| {
if !is1 {
x1 = end - (end - begin) * inverted_phi;
y1 = function(x1);
is1 = true;
}
if !is2 {
x2 = begin + (end - begin) * inverted_phi;
y2 = function(x2);
is2 = true;
}
if y1 < y2 {
end = x2;
x2 = x1;
y2 = y1;
is1 = false;
} else {
begin = x1;
x1 = x2;
y1 = y2;
is
```
<Overlap Ratio: 0.8972267536704731>

---

--- 250 --
Question ID: b8ef5fd1940b3ac7cf801c21a9bce0be53947648_1
Original Code:
```
fn get_value(cpu: cpu_state, v: value) -> u16 {
    alt v {
      value_reg(t)     { cpu.regs[t] }
      value_mem(t)     { cpu.mem[t] }
      value_sp         { cpu.sp }
```


Overlapping Code:
```
(cpu: cpu_state, v: value) -> u16 {
alt v {
value_reg(t) { cpu.regs[t] }
value_mem(t) { cpu.mem[t] }
```
<Overlap Ratio: 0.7575757575757576>

---

--- 251 --
Question ID: bbcf632bd6ec044f33f555480b48984dd326426e_50
Original Code:
```
fn Block(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::BlockStatement> {
    let brackets = is_token!(tokens, Token::LCurly)?;
    if let Ok((rest, statement)) = StatementList(brackets.0) {
        let brackets = is_token!(rest, Token::RCurly)?;
        return Ok((brackets.0, node::BlockStatement { body: statement }));
    }
    let brackets = is_token!(brackets.0, Token::RCurly)?;
    Ok((brackets.0, node::BlockStatement { body: vec![] }))
}
```


Overlapping Code:
```
(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::BlockStatement> {
let brackets = is_token!(tokens, Token::LCurly)?;
if let Ok((rest, statement)) = StatementList(brackets.0) {
let brackets = is_token!(rest, Token::RCurly)?;
return Ok((brackets.0, node::BlockStatement { body: statement }));
}
let brackets = is_token!(brackets.0, Token::RCurly)?;
Ok((brackets.0, node::BlockStatement { body: 
```
<Overlap Ratio: 0.9535962877030162>

---

--- 252 --
Question ID: f5319d4e9ef5c4e40c952921c46d11eeb9384e47_18
Original Code:
```
pub unsafe extern "C" fn namei(path: *const u8) -> *mut Inode {
    check_it("namei (1)");
    let mut name = [0u8; DIRSIZ];
    // cprintf("namei: namex start\n", &[]);
    let res = namex(path, 0, name.as_mut_ptr());
    // cprintf("namei:  namex end\n", &[]);
    res
}
```


Overlapping Code:
```
 *const u8) -> *mut Inode {
check_it("namei (1)");
let mut name = [0u8; DIRSIZ];
// cprintf("namei: namex start\n", &[]);
let res = namex(path, 0, name.as_mut_ptr());
// cprintf("namei: namex end\n", 
```
<Overlap Ratio: 0.8097165991902834>

---

--- 253 --
Question ID: 5176df6ed5a22dfbca02f1bf858b5f0bf670af30_6
Original Code:
```
fn from_points_many() {
        let points = vec![
            Point::new(0, 0),
            Point::new(5, 8),
            Point::new(2, 3),
            Point::new(8, 14),
        ];

        let poly = Polynomial::from_points(&points, 3).unwrap();
        let poly2 = Polynomial::builder()
            .with(Fraction::new(263, 180), 1)
            .with(Fraction::new(1, 72), 2)
            .with(Fraction::new(1, 360), 3)
            .build();

        assert_eq!(poly, poly2);
    }
```


Overlapping Code:
```
![
Point::new(0, 0),
Point::new(5, 8),
Point::new(2, 3),
Point::new(8, 14),
];
let poly = Polynomial::from_points(&points, 3).unwrap();
let poly2 = Polynomial::builder()
.with(Fraction::new(263, 180), 1)
.with(Fraction::new(1, 72), 2)
.with(Fraction::new(1, 360), 3)
.build();
assert_eq!(poly, poly2)
```
<Overlap Ratio: 0.8746355685131195>

---

--- 254 --
Question ID: 6284d1836ef46c50637504ab98bc58c982d91ef0_10
Original Code:
```
pub fn vmresume() -> Result<(), u32> {
    let ret: u32;
    unsafe {
        asm!(
            "xor %eax, %eax; \
             vmresume; \
             setc %ah; \
             setz %al;"
             : "={eax}"(ret)
             :
             :
            );
    }
    if ret == 0 { Ok(()) } else { Err(ret) }
}
```


Overlapping Code:
```
-> Result<(), u32> {
let ret: u32;
unsafe {
asm!(
"xor %eax, %eax; \
vmresume; \
setc %ah; \
setz %al;"
: "={eax}"(ret)
:
:
);
}
if ret == 0 { Ok(()) } else { E
```
<Overlap Ratio: 0.8465608465608465>

---

--- 255 --
Question ID: f8a18e866d4e60df133607ac744341aa1bf12e57_0
Original Code:
```
fn main() {
    let matches = App::new("TezEdge Protocol Runner")
        .version(env!("CARGO_PKG_VERSION"))
        .author("TezEdge and the project contributors")
        .about("Tezos Protocol Runner")
        .arg(
            Arg::with_name("socket-path")
                .short("c")
                .long("socket-path")
                .value_name("path")
                .help("Path to a command socket")
                .takes_value(true)
                .empty_values(false)
                .required(true),
        )
        .arg(
            Arg::with_name("endpoint")
                .long("endpoint")
                .value_name("STRING")
                .help("Name of the endpoint, which spawned runner")
                .takes_value(true)
                .empty_values(false)
                .required(true),
        )
        .arg(
            Arg::with_name("log-level")
                .long("log-level")
                .takes_value(true)
                .value_name("LEVEL")
                .possible_values(&["critical", "error", "warn", "info", "debug", "trace"])
                .help("Set log level"),
        )
        .get_matches();

    let cmd_socket_path = matches
        .value_of("socket-path")
        .expect("Missing socket-path value");
    let endpoint_name = matches
        .value_of("endpoint")
        .expect("Missing endpoint value")
        .to_string();
    let log_level = matches
        .value_of("log-level")
        .unwrap_or("info")
        .parse::<slog::Level>()
        .expect("Was expecting one value from slog::Level");

    let log = create_logger(log_level, endpoint_name);

    let shutdown_callback = |log: &Logger| {
        debug!(log, "Shutting down OCaml runtime");
        match std::panic::catch_unwind(|| {
            tezos_interop::shutdown();
        }) {
            Ok(_) => debug!(log, "OCaml runtime shutdown was successful"),
            Err(e) => {
                warn!(log, "Shutting down OCaml runtime failed (check running sub-process for this endpoint or `[protocol-runner] <defunct>`, and and terminate/kill manually)!"; "reason" => format!("{:?}", e))
            }
        }
    };

    {
        let log = log.clone();
        // do nothing and wait for parent process to send termination command
        // this is just fallback, if ProtocolController.shutdown will fail or if we need to kill sub-process manually
        ctrlc::set_handler(move || {
            shutdown_callback(&log);
            warn!(log, "Protocol runner was terminated/killed/ctrl-c - please, check running sub-processes for `[protocol-runner] <defunct>`, and terminate/kill manually!");
        }).expect("Error setting Ctrl-C handler");
    }

    #[cfg(dyncov)]
    dyncov::initialize_callbacks();

    match tezos_interop::start_ipc_loop(cmd_socket_path.into()) {
        Err(OCamlBlockPanic) => warn!(log, "Protocol runner loop exited with a panic"),
        Ok(Err(trace)) => warn!(log, "Protocol runner loop exited with error: {:?}", trace),
        Ok(Ok(code)) => info!(
            log,
            "Protocol runner exited with internal exit code = {}", code
        ),
    }

    shutdown_callback(&log);

    info!(log, "Protocol runner finished gracefully");
}
```


Overlapping Code:
```
dge Protocol Runner")
.version(env!("CARGO_PKG_VERSION"))
.author("TezEdge and the project contributors")
.about("Tezos Protocol Runner")
.arg(
Arg::with_name("socket-path")
.short("c")
.long("socket-path")
.value_name("path")
.help("Path to a command socket")
.takes_value(true)
.empty_values(false)
.required(true),
)
.arg(
Arg::with_name("endpoint")
.long("endpoint")
.value_name("STRING")
.help("Name of the endpoint, which spawned runner")
.takes_value(true)
.empty_values(false)
.required(true),
)
.arg(
Arg::with_name("log-level")
.long("log-level")
.takes_value(true)
.value_name("LEVEL")
.possible_values(&["critical", "error", "warn", "info", "debug", "trace"])
.help("Set log level"),
)
.get_matches();
let cmd_socket_path = matches
.value_of("socket-path")
.expect("Missing socket-path value");
let endpoint_name = matches
.value_of("endpoint")
.expect("Missing endpoint value")
.to_string();
let log_level = matches
.value_of("log-level")
.unwrap_or("info")
.parse::<slog::Level>()
.expect("Was expecting one value from slog::Level");
let log = create_logger(log_level, endpoint_name);
let shutdown_callback = |log: &Logger| {
debug!(log, "Shutting down OCaml runtime");
match std::panic::catch_unwind(|| {
tezos_interop::shutdown();
}) {
Ok(_) => debug!(log, "OCaml runtime shutdown was successful"),
Err(e) => {
warn!(log, "Shutting down OCaml runtime failed (check running sub-process for this endpoint or `[protocol-runner] <defunct>`, and and terminate/kill manually)!"; "reason" => format!("{:?}", e))
}
}
};
{
let log = log.clone();
// do nothing and wait for parent process to send termination command
// this is just fallback, if ProtocolController.shutdown will fail or if we need to kill sub-process manually
ctrlc::set_handler(move || {
shu
```
<Overlap Ratio: 0.9618528610354223>

---

--- 256 --
Question ID: eaa111470141c108d7893ca634be26134ec228b4_2
Original Code:
```
fn when_connected<T, S, R>(
    params: T::Params,
    sender: S,
    receiver: R,
    handle: &Handle,
    client_event_sender: mpsc::Sender<ClientEvent>,
) -> T
where
    T: ClientState + Clone + 'static,
    S: Sink<SinkItem = T::Send, SinkError = ()> + 'static,
    R: Stream<Item = T::Receive, Error = Error> + 'static,
{
    let (from_socket, to_socket) = mpsc::channel(20);
    let client = T::new(params, from_socket);
    let connect_event_f = client_event_sender
        .clone()
        .send(client.connected_event())
        .map(|_| ())
        .map_err(|_| ());
    handle.spawn(connect_event_f);

    let client_id = client.id();
    let recv_client = client.clone();
    let from_socket_stream = receiver
        .map(move |message| recv_client.on_receive(message))
        .map_err(move |err| error!("[{}] Recv error: {}", client_id, err));
    let socket_read_stream = client_event_sender
        .clone()
        .sink_map_err(|_| ())
        .send_all(from_socket_stream);
    let send_stream = sender.send_all(to_socket);
    let disconnect_message = client.disconnected_event();
    let connection = send_stream
        .map(|_| ())
        .select(socket_read_stream.map(|_| ()))
        .then(move |_| {
            client_event_sender
                .clone()
                .send(disconnect_message)
                .map(|_| ())
                .map_err(|_| ())
        });

    handle.spawn(connection);
    client
}
```


Overlapping Code:
```
arams,
sender: S,
receiver: R,
handle: &Handle,
client_event_sender: mpsc::Sender<ClientEvent>,
) -> T
where
T: ClientState + Clone + 'static,
S: Sink<SinkItem = T::Send, SinkError = ()> + 'static,
R: Stream<Item = T::Receive, Error = Error> + 'static,
{
let (from_socket, to_socket) = mpsc::channel(20);
let client = T::new(params, from_socket);
let connect_event_f = client_event_sender
.clone()
.send(client.connected_event())
.map(|_| ())
.map_err(|_| ());
handle.spawn(connect_event_f);
let client_id = client.id();
let recv_client = client.clone();
let from_socket_stream = receiver
.map(move |message| recv_client.on_receive(message))
.map_err(move |err| error!("[{}] Recv error: {}", client_id, err));
let socket_read_stream = client_event_sender
.clone()
.sink_map_err(|_| ())
.send_all(from_socket_stream);
let send_stream = sender.send_all(to_socket);
let disconnect_message = client.disconnected_event();
let connection = send_stream
.map(|_| ())
.select(socket_read_stream.map(|_| ()))
.then(move |_| {
client_event_sender
.clone()
.send(disconnect_message)
.map(|_| ())
.map_err(|_| ())
```
<Overlap Ratio: 0.9329940627650551>

---

--- 257 --
Question ID: 4bcd4416d1f71112f228d505492b8211eaceecfb_0
Original Code:
```
fn json_str_vec_to_yaml() {
        let input = serde_json::to_value(&vec!["foo"]);
        let output = serde_yaml::Value::Array(vec![serde_yaml::Value::String("foo".to_owned())]);
        assert_eq!(to_yaml(&input).unwrap(), output);
    }
```


Overlapping Code:
```
on_str_vec_to_yaml() {
let input = serde_json::to_value(&vec!["foo"]);
let output = serde_yaml::Value::Array(vec![serde_yaml::Value::String("foo".to_owned())]);
assert_eq!(to_yaml(&input).unwrap(), output);
}
```
<Overlap Ratio: 0.9765258215962441>

---

--- 258 --
Question ID: 4f1eff5ab7f706e1985fe1f023a02960c15d529c_0
Original Code:
```
fn p_one() -> i32 {
    let limit = 576723;
    let mut hits = 0;
    let mut password = 109165;
    while password < limit {
        let mut digits: Vec<u32> = split(password);
        make_inc(&mut digits);
        password = revert_to_number(&digits);
        if password > limit {
            break;
        }
        if has_double(&digits) {
            hits = hits + 1;
        }
        password = password + 1;
    }

    hits
}
```


Overlapping Code:
```
32 {
let limit = 576723;
let mut hits = 0;
let mutwhile password < limit {
let mut digits: Vec<u32> = split(password);
make_inc(&mut digits);
password = revert_to_number(&digits);
if password > limit {
break;
}
if has_double(&
```
<Overlap Ratio: 0.6996904024767802>

---

--- 259 --
Question ID: 186bc91dc8abcb946bf0553c183033ccbe3646a3_4
Original Code:
```
fn test_edge_inserted_without_adding_nodes_directed() {
    let mut net: Network<usize, f64> = Network::new(true);

    net.add_edge(0, 1, 10.0);

    check_network(net, 2, 1, vec![0, 1], vec![(0, 1, vec![&10.0])]);
}
```


Overlapping Code:
```
ng_nodes_directed() {
let mut net: Network<usize, f64> = Network::new(true);
net.add_edge(0, 1, 10.0);
check_network(net, 2, 1, vec![0, 1], vec![(0, 1, vec![&10.0])
```
<Overlap Ratio: 0.8078817733990148>

---

--- 260 --
Question ID: dfd72bab48f625510568aae031fef93488dae578_1
Original Code:
```
fn fibonacci_sync(mut cx: FunctionContext) -> JsResult<JsString> {
    let n = cx.argument::<JsNumber>(0)?.value() as usize;
    let big = compute(n);
    Ok(cx.string(big.to_str_radix(10)))
}
```


Overlapping Code:
```
(mut cx: FunctionContext) -> JsResult<JsString> {
let n = cx.argument::<JsNumber>(0)?.value() as usize;
let big = compute(n);
Ok(cx.string(big.to_str_ra
```
<Overlap Ratio: 0.8444444444444444>

---

--- 261 --
Question ID: 290052921f5b8d0d6ea234711eae018ccb14fae3_0
Original Code:
```
fn main() {
    let log_config = Config {
        filter: Some("info".to_owned()),
        ..Default::default()
    };
    let _logger_guard = ckb_logger::init(log_config).expect("init Logger");

    let binary = env::args()
        .nth(1)
        .unwrap_or_else(|| "../target/release/ckb".to_string());
    let start_port = env::args()
        .nth(2)
        .unwrap_or_else(|| "9000".to_string())
        .parse()
        .expect("invalid port number");
    let mut specs: HashMap<&str, Box<dyn Spec>> = HashMap::new();
    specs.insert("block_relay_basic", Box::new(BlockRelayBasic));
    specs.insert("block_sync_from_one", Box::new(BlockSyncFromOne));
    specs.insert("block_sync_forks", Box::new(BlockSyncForks));
    specs.insert(
        "block_sync_duplicated_and_reconnect",
        Box::new(BlockSyncDuplicatedAndReconnect),
    );
    specs.insert("block_sync_orphan_blocks", Box::new(BlockSyncOrphanBlocks));
    specs.insert("sync_timeout", Box::new(SyncTimeout));
    specs.insert("chain_fork_1", Box::new(ChainFork1));
    specs.insert("chain_fork_2", Box::new(ChainFork2));
    specs.insert("chain_fork_3", Box::new(ChainFork3));
    specs.insert("chain_fork_4", Box::new(ChainFork4));
    specs.insert("chain_fork_5", Box::new(ChainFork5));
    specs.insert("chain_fork_6", Box::new(ChainFork6));
    specs.insert("chain_fork_7", Box::new(ChainFork7));
    specs.insert("mining_basic", Box::new(MiningBasic));
    specs.insert("mining_bootstrap_cellbase", Box::new(BootstrapCellbase));
    specs.insert("mining_template_size_limit", Box::new(TemplateSizeLimit));
    specs.insert("pool_reconcile", Box::new(PoolReconcile));
    specs.insert("pool_resurrect", Box::new(PoolResurrect));
    specs.insert("transaction_relay_basic", Box::new(TransactionRelayBasic));
    // FIXME: There is a probability of failure on low resouce CI server
    // specs.insert(
    //     "transaction_relay_multiple",
    //     Box::new(TransactionRelayMultiple),
    // );
    specs.insert("discovery", Box::new(Discovery));
    // TODO enable this after p2p lib resolve close timeout issue
    // specs.insert("disconnect", Box::new(Disconnect));
    specs.insert("malformed_message", Box::new(MalformedMessage));
    specs.insert("depent_tx_in_same_block", Box::new(DepentTxInSameBlock));
    // TODO enable these after proposed/pending pool tip verfiry logic changing
    // specs.insert("cellbase_maturity", Box::new(CellbaseMaturity));
    specs.insert("valid_since", Box::new(ValidSince));
    specs.insert(
        "different_txs_with_same_input",
        Box::new(DifferentTxsWithSameInput),
    );
    specs.insert("compact_block_empty", Box::new(CompactBlockEmpty));
    specs.insert(
        "compact_block_empty_parent_unknown",
        Box::new(CompactBlockEmptyParentUnknown),
    );
    specs.insert("compact_block_prefilled", Box::new(CompactBlockPrefilled));
    specs.insert(
        "compact_block_missing_txs",
        Box::new(CompactBlockMissingTxs),
    );
    specs.insert(
        "compact_block_lose_get_block_transactions",
        Box::new(CompactBlockLoseGetBlockTransactions),
    );
    specs.insert(
        "compact_block_relay_parent_of_orphan_block",
        Box::new(CompactBlockRelayParentOfOrphanBlock),
    );
    specs.insert("invalid_locator_size", Box::new(InvalidLocatorSize));
    specs.insert("tx_pool_size_limit", Box::new(SizeLimit));
    specs.insert("tx_pool_cycles_limit", Box::new(CyclesLimit));
    specs.insert("alert_propagation", Box::new(AlertPropagation::default()));
    specs.insert("indexer_basic", Box::new(IndexerBasic));
    specs.insert("genesis_issued_cells", Box::new(GenesisIssuedCells));

    if let Some(spec_name) = env::args().nth(3) {
        if let Some(spec) = specs.get(spec_name.as_str()) {
            let net = spec.setup_net(&binary, start_port);
            spec.run(net);
        }
    } else {
        specs.iter().for_each(|(spec_name, spec)| {
            info!("Running {}", spec_name);
            let net = spec.setup_net(&binary, start_port);
            spec.run(net);
        })
    }
}
```


Overlapping Code:
```
g {
filter: Some("info".to_owned()),
..Default::default()
};
let _logger_guard = ckb_logger::init(log_config).expect("init Logger");
let binary = env::args()
.nth(1)
.unwrap_or_else(|| "../target/release/ckb".to_string());
let start_port = env::args()
.nth(2)
.unwrap_or_else(|| "9000".to_string())
.parse()
.expect("invalid port number");
let mut specs: HashMap<&str, Box<dyn Spec>> = HashMap::new();
specs.insert("block_relay_basic", Box::new(BlockRelayBasic));
specs.insert("block_sync_from_one", Box::new(BlockSyncFromOne));
specs.insert("block_sync_forks", Box::new(BlockSyncForks));
specs.insert(
"block_sync_duplicated_and_reconnect",
Box::new(BlockSyncDuplicatedAndReconnect),
);
specs.insert("block_sync_orphan_blocks", Box::new(BlockSyncOrphanBlocks));
specs.insert("sync_timeout", Box::new(SyncTimeout));
specs.insert("chain_fork_1", Box::new(ChainFork1));
specs.insert("chain_fork_2", Box::new(ChainFork2));
specs.insert("chain_fork_3", Box::new(ChainFork3));
specs.insert("chain_fork_4", Box::new(ChainFork4));
specs.insert("chain_fork_5", Box::new(ChainFork5));
specs.insert("chain_fork_6", Box::new(ChainFork6));
specs.insert("chain_fork_7", Box::new(ChainFork7));
specs.insert("mining_basic", Box::new(MiningBasic));
specs.insert("mining_bootstrap_cellbase", Box::new(BootstrapCellbase));
specs.insert("mining_template_size_limit", Box::new(TemplateSizeLimit));
specs.insert("pool_reconcile", Box::new(PoolReconcile));
specs.insert("pool_resurrect", Box::new(PoolResurrect));
specs.insert("transaction_relay_basic", Box::new(TransactionRelayBasic));
// FIXME: There is a probability of failure on low resouce CI server
// specs.insert(
// "transaction_relay_multiple",
// Box::new(TransactionRelayMultiple),
// );
specs.insert("discovery", Box::new(Discovery));
// TODO enable this after p2p lib resolve close timeout issue
// specs.insert("disconnect", Box::new(Disconnect));
specs.insert("malformed_message", Box::new(MalformedMessage));
specs.insert("depent_tx_in_same_block", Box::new(DepentTxInSameBlock));
// TODO enable these after proposed/pending pool tip verfiry logic changing
// specs.insert("cellbase_maturity", Box::new(CellbaseMaturity));
specs.insert("valid_since", Box::new(ValidSin
```
<Overlap Ratio: 0.9826974267968057>

---

--- 262 --
Question ID: a0c331818451a7bca9576b530cbe6507141ebff4_0
Original Code:
```
async fn test_repo() {
    let env = TestEnv::new();
    env.add_repository(
        RepositoryConfigBuilder::new(RepoUrl::new("example.com".to_string()).expect("valid url"))
            .build(),
    );

    let output = env.run_pkgctl(vec!["repo"]).await;

    assert_stdout(&output, "fuchsia-pkg://example.com\n");
    env.assert_only_repository_manager_called_with(vec![CapturedRepositoryManagerRequest::List]);
}
```


Overlapping Code:
```
 fn test_repo() {
let env = TestEnv::new();
env.add_repository(
RepositoryConfigBuilder::new(RepoUrl::new("example.com".to_string()).expect("valid url"))
.build(),
);
let output = env.run_pkgctl(vec!["repo"]).await;
assert_stdout(&output, "fuchsia-pkg://example.com\n");
env.assert_only_repository_manager_called_with(vec![CapturedRepositoryManagerRe
```
<Overlap Ratio: 0.9433962264150944>

---

--- 263 --
Question ID: 4b05c21a539d186db17926df1a3431106bdd680b_1
Original Code:
```
fn load_asset_to_vmo(path: &Path) -> Result<mem::Buffer, Error> {
    let file = File::open(path)?;
    let vmo = fdio::get_vmo_copy_from_file(&file)?;
    let size = file.metadata()?.len();
    Ok(mem::Buffer { vmo, size })
}
```


Overlapping Code:
```
 load_asset_to_vmo(path: &Path) -> Result<mem::Buffer, Error> {
let file = File::open(path)?;
let vmo = fdio::get_vmo_copy_from_file(&file)?;
let size = file.metadata()?.len();
Ok(mem::Buffer { vmo, s
```
<Overlap Ratio: 0.9523809523809523>

---

--- 264 --
Question ID: f648d923a7db5cc7b0d38b1fc342933334116d2d_0
Original Code:
```
pub fn get_row(mut row_index: i32) -> Vec<i32> {
    row_index += 1;
    if row_index == 1 {
        return vec![1];
    }
    let mut res = vec![1];
    let row_index = row_index as usize;
    for i in 1..row_index {
        for j in (1..=i).rev() {
            if j == i {
                res.push(1);
            } else {
                let sum = res[j - 1] + res[j];
                res[j] = sum;
            }
        }
    }

    res
}
```


Overlapping Code:
```
 i32) -> Vec<i32> {
row_index += 1;
if row_index == 1 {
return vec![1];
}
let mut res = vec![1];
let row_index = row_index as usize;
for i in 1..row_index {
for j in (1..=i).rev() {
if j == i {
res.push(1);
} else {
let sum = res[j - 1] + res[j];
res
```
<Overlap Ratio: 0.8305647840531561>

---

--- 265 --
Question ID: cf4f3c0e7f482173044e709d3b612eb2d50eea60_4
Original Code:
```
fn blockchain_will_not_add_block_with_unacceptable_proof_of_work() {
        let mut chain = BlockChain::new();
        let block = Block {
            block_num: 1,
            timestamp: util::millis_since_unix_epoch(),
            nonce: 0,
            data: String::from("hello"),
            prev_hash: chain.genesis_hash.clone(),
        };
        let hash = block.hash().unwrap();
        assert!(!is_acceptable_proof_of_work(&hash));
        let result = chain.add(block);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert_eq!(err, Error::UnacceptableProofOfWork { hash });
    }
```


Overlapping Code:
```
ill_not_add_block_with_unacceptable_proof_of_work() {
let mut chain = BlockChain::new();
let block = Block {
block_num: 1,
timestamp: util::millis_since_unix_epoch(),
nonce: 0,
data: String::from("hello"),
prev_hash: chain.genesis_hash.clone(),
};
let hash = block.hash().unwrap();
assert!(!is_acceptable_proof_of_work(&hash));
let result = chain.add(block);
assert!(result.is_err());
let err = result.unwrap_err();
assert_eq!(err, Error::Unacceptabl
```
<Overlap Ratio: 0.9183673469387755>

---

--- 266 --
Question ID: 2791ab82c02c885f427c58931d2c5ec2e77eb458_0
Original Code:
```
fn main() {
    let n: usize = {
        let mut line: String = String::new();
        std::io::stdin().read_line(&mut line).unwrap();
        line.trim().parse().unwrap()
    };
    let a: Vec<i64> = {
        let mut line: String = String::new();
        std::io::stdin().read_line(&mut line).unwrap();
        line.split_whitespace()
            .map(|x| x.parse().unwrap())
            .collect()
    };

    let ans = (0..n)
        .map(|i| if i < (n + 1) / 2 { a[n - 2 * i - 1] } else { a[2 * (i - (n + 1) / 2) + n % 2] })
        .map(|x| x.to_string())
        .collect::<Vec<_>>()
        .join(" ");

    println!("{}", ans);
}
```


Overlapping Code:
```
 usize = {
let mut line: String = String::new();
std::io::stdin().read_line(&mut line).unwrap();
line.trim().parse().unwrap()
};
let a: Vec<i64> = {
let mut line: String = String::new();
std::io::stdin().read_line(&mut line).unwrap();
line.split_whitespace()
.map(|x| x.parse().unwrap())
.collect()
};
let ans = (0..n)
.map(|i| if i < (n + 1) / 2 { a[n - 2 * i - 1] } else { a[2 * (i - (n + 1) / 2) + n % 2] })
.map(|x| x.to_string())
.collect::<Vec<_>>()
.join(" ");
println!("{}", ans);
}
```
<Overlap Ratio: 0.9645669291338582>

---

--- 267 --
Question ID: 561f2c3356a39fb03a420b702a2019bcb2193606_4
Original Code:
```
fn should_stay_idle_when_no_release() {
		let (update_policy, _) = update_policy();
		let (_client, updater, _, _, ..) = setup(update_policy);

		assert_eq!(updater.state.lock().status, UpdaterStatus::Idle);
		updater.poll();
		assert_eq!(updater.state.lock().status, UpdaterStatus::Idle);
	}
```


Overlapping Code:
```
lease() {
let (update_policy, _) = update_policy();
let (_client, updater, _, _, ..) = setup(update_policy);
assert_eq!(updater.state.lock().status, UpdaterStatus::Idle);
updater.poll();
assert_eq!(updater.state.lock().status, UpdaterStatus::Idle);
}
```
<Overlap Ratio: 0.8928571428571429>

---

--- 268 --
Question ID: ec17c73f381a5a41e8282bafdbacc2c32fc4504f_2
Original Code:
```
fn test_i8() {
    let test: i8 = 0x12;
    assert_eq!(to_vec::<BE,_>(&test).unwrap(), vec![0x12]);
    assert_eq!(to_vec::<LE,_>(&test).unwrap(), vec![0x12]);
  }
```


Overlapping Code:
```
_eq!(to_vec::<BE,_>(&test).unwrap(), vec![0x12]);
assert_eq!(to_vec::<LE,_>(&test).unwrap(), vec![0x
```
<Overlap Ratio: 0.6711409395973155>

---

--- 269 --
Question ID: c7b80c42c1baa657e4f99df074114b163190f538_0
Original Code:
```
fn main() {
    // Make sure codegen can emit all the intrinsics correctly
    ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();
    ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();
    ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();
    ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();
    ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();
    ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();
    ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();
    ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();
    ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();
    ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();
    ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();
    ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();
    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();
    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();
    ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();
    ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();
    ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();
    ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();
}
```


Overlapping Code:
```
ll the intrinsics correctly
ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed).ok();
ATOMIC.compare_exchange(0, 1, Acquire, Relaxed).ok();
ATOMIC.compare_exchange(0, 1, Release, Relaxed).ok();
ATOMIC.compare_exchange(0, 1, AcqRel, Relaxed).ok();
ATOMIC.compare_exchange(0, 1, SeqCst, Relaxed).ok();
ATOMIC.compare_exchange(0, 1, Acquire, Acquire).ok();
ATOMIC.compare_exchange(0, 1, AcqRel, Acquire).ok();
ATOMIC.compare_exchange(0, 1, SeqCst, Acquire).ok();
ATOMIC.compare_exchange(0, 1, SeqCst, SeqCst).ok();
ATOMIC.compare_exchange_weak(0, 1, Relaxed, Relaxed).ok();
ATOMIC.compare_exchange_weak(0, 1, Acquire, Relaxed).ok();
ATOMIC.compare_exchange_weak(0, 1, Release, Relaxed).ok();
ATOMIC.compare_exchange_weak(0, 1, AcqRel, Relaxed).ok();
ATOMIC.compare_exchange_weak(0, 1, SeqCst, Relaxed).ok();
ATOMIC.compare_exchange_weak(0, 1, Acquire, Acquire).ok();
ATOMIC.compare_exchange_weak(0, 1, AcqRel, Acquire).ok();
ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();
ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();

```
<Overlap Ratio: 0.9591457753017641>

---

--- 270 --
Question ID: 6993c1ac0af8494846cba5d4624959d71ea7584c_0
Original Code:
```
fn pollable_set_test() {
        let mut runtime = tokio::runtime::Builder::new()
            .basic_scheduler()
            .build()
            .unwrap();

        let set = PollableSet::<u32>::new();
        assert_eq!(0, set.items.read().len());
        assert_eq!(0, set.len());

        set.insert(6);
        assert_eq!(1, set.items.read().len());
        assert_eq!(1, set.len());

        set.insert(4);
        set.insert(8);
        assert_eq!(3, set.items.read().len());
        assert_eq!(3, set.len());

        set.insert(10);
        {
            let odd_query = poll_fn(|cx| -> Poll<bool> {
                match set.poll_take(cx, |x| x % 2 == 1) {
                    Poll::Ready(_) => Poll::Ready(true),
                    Poll::Pending => Poll::Ready(false),
                }
            });
            let even_query = poll_fn(|cx| -> Poll<bool> {
                match set.poll_take(cx, |x| x % 2 == 0) {
                    Poll::Ready(_) => Poll::Ready(true),
                    Poll::Pending => Poll::Ready(false),
                }
            });

            // Wait for all the queries to complete
            assert_eq!(runtime.block_on(odd_query), false);
            assert_eq!(runtime.block_on(even_query), true);
        }

        // 3 (before the queries are created), 10 is inserted, and the query consumes one value.
        assert_eq!(3, set.items.read().len());
        assert_eq!(3, set.len());
    }
```


Overlapping Code:
```
pollable_set_test() {
let mut runtime = tokio::runtime::Builder::new()
.basic_scheduler()
.build()
.unwrap();
let set = PollableSet::<u32>::new();
assert_eq!(0, set.items.read().len());
assert_eq!(0, set.len());
set.insert(6);
assert_eq!(1, set.items.read().len());
assert_eq!(1, set.len());
set.insert(4);
set.insert(8);
assert_eq!(3, set.items.read().len());
assert_eq!(3, set.len());
set.insert(10);
{
let odd_query = poll_fn(|cx| -> Poll<bool> {
match set.poll_take(cx, |x| x % 2 == 1) {
Poll::Ready(_) => Poll::Ready(true),
Poll::Pending => Poll::Ready(false),
}
});
let even_query = poll_fn(|cx| -> Poll<bool> {
match set.poll_take(cx, |x| x % 2 == 0) {
Poll::Ready(_) => Poll::Ready(true),
Poll::Pending => Poll::Ready(false),
}
});
// Wait for all the queries to complete
assert_eq!(runtime.block_on(odd_query), false);
assert_eq!(runtime.block_on(even_query), true);
}
// 3 (before the queries are created), 10 is inserted, and the query consumes one value.
assert_eq!(3, set.items.read().le
```
<Overlap Ratio: 0.9652509652509652>

---

--- 271 --
Question ID: 7ffb78845294a56637418f2b0eb1e09c6cf0b4b7_2
Original Code:
```
fn is_prime_number3(v: usize, prime_numbers: &[usize]) -> bool {
    if v < 10000 {
        let r = prime_numbers.binary_search(&v);
        return r.is_ok();
    }

    for n in prime_numbers {
        if v % n == 0 {
            return false;
        }
    }

    true
}
```


Overlapping Code:
```
is_prime_number3(v: usize, prime_numbers: &[usize]) -> bool {
if v < 10000 {
let r = prime_numbers.binary_search(&v);
return r.is_ok();
}
for n in prime_numbers {
if v % n == 0 {
return false;
}
}
tru
```
<Overlap Ratio: 0.970873786407767>

---

--- 272 --
Question ID: 4af374f4d857972acd76462687db970c5d638c05_2
Original Code:
```
async fn extract(intent: &ImportIntent, paths: &Paths) -> Result<(), ImportError> {
    let extract_new = extract::extract_gzip(paths.store_new(), paths.extract_new())
        .instrument(debug_span!("gzip::new"));

    if intent.has_old_dump() {
        let extract_old = extract::extract_gzip(paths.store_old(), paths.extract_old())
            .instrument(debug_span!("gzip::old"));

        info!("extracting old and new indexes");
        futures::try_join!(extract_old, extract_new)?;
    } else {
        info!("extracting new index");
        extract_new.await?;
    };

    Ok(())
}
```


Overlapping Code:
```
(intent: &ImportIntent, paths: &Paths) -> Result<(), ImportError> {
let extract_new = extract::extract_gzip(paths.store_new(), paths.extract_new())
.instrument(debug_span!("gzip::new"));
if intent.has_old_dump() {
let extract_old = extract::extract_gzip(paths.store_old(), paths.extract_old())
.instrument(debug_span!("gzip::old"));
info!("extracting old and new indexes");
futures::try_join!(extract_old, extract_new)?;
} else {
info!("extracting new index");
extract_new
```
<Overlap Ratio: 0.9291338582677166>

---

--- 273 --
Question ID: 531b10ba9ca02ffba834fe974f8d3154387ef543_0
Original Code:
```
fn main() {
    let s = [120, 0].into();
    println!("{}", s);
    // let four_k_bytes = 1024 * 4;
    // let f = File::open("aidans_theme-inst.wav").unwrap();
    // let mut buf: Vec<u8> = Vec::<u8>::with_capacity(four_k_bytes);

    // let mut i = 0;

    // for byte in f.bytes() {
    //     buf.push(byte.unwrap());
    //     i += 1;
    //     if i % four_k_bytes == 0 {
    //         println!("{}K bytes read", i / four_k_bytes);
    //     }
    // }

    // println!("Length: {}", buf.len());
    // let mut reader = BufReader::with_capacity(4, f);

    // loop {
    //     match reader.fill_buf() {
    //         Ok(_) => println!("{:?}", reader.buffer()),
    //         _ => break
    //     }
    // }
}
```


Overlapping Code:
```
 [120, 0].into();
println!("{}", s);
// let four_k_bytes = 1024 * 4;
// let f = File::open("aidans_theme-inst.wav").unwrap();
// let mut buf: Vec<u8> = Vec::<u8>::with_capacity(four_k_bytes);
// let mut i = 0;
// for byte in f.bytes() {
// buf.push(byte.unwrap());
// i += 1;
// if i % four_k_bytes == 0 {
// println!("{}K bytes read", i / four_k_bytes);
// }
// }
// println!("Length: {}", buf.len());
// let mut reader = BufReader::with_capacity(4, f);
// loop {
// match reader.fill_buf() {
// Ok(_) => println!("{:?}", reader.buffer()),
// _ => b
```
<Overlap Ratio: 0.9401709401709402>

---

--- 274 --
Question ID: b3e8a5a2959ca55a77af4546886f9d50848340df_0
Original Code:
```
fn main() {
    let mut display = DisplayBuilder::new().size(304, 128).scale(2).build();

    display.draw(
        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32).stroke(Some(1u8.into())),
    );

    display.draw(
        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)
            .translate(icoord!(16, 16))
            .stroke(Some(0u8.into()))
            .fill(Some(1u8.into())),
    );

    display.draw(
        Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)
            .translate(icoord!(CIRCLE_SIZE, CIRCLE_SIZE))
            .stroke(Some(0u8.into()))
            .fill(Some(0u8.into())),
    );

    display.draw(
        Rectangle::new(icoord!(0, 0), icoord!(64, 64))
            .translate(icoord!(96, 0))
            .stroke(Some(1u8.into())),
    );

    display.draw(
        &Rectangle::new(icoord!(0, 0), icoord!(64, 64))
            .translate(icoord!(96 + 16, 16))
            .stroke(Some(0u8.into()))
            .fill(Some(1u8.into())),
    );

    display.draw(
        Rectangle::new(icoord!(0, 0), icoord!(64, 64))
            .translate(icoord!(96 + 32, 32))
            .stroke(Some(0u8.into()))
            .fill(Some(0u8.into())),
    );

    display.draw(
        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
            .translate(icoord!(96 * 2, 0))
            .stroke(Some(1u8.into())),
    );

    display.draw(
        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
            .translate(icoord!(96 * 2 + 16, 16))
            .stroke(Some(0u8.into()))
            .fill(Some(1u8.into())),
    );

    display.draw(
        Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
            .translate(icoord!(96 * 2 + 32, 32))
            .stroke(Some(0u8.into()))
            .fill(Some(0u8.into())),
    );

    loop {
        let end = display.run_once();

        if end {
            break;
        }

        thread::sleep(Duration::from_millis(200));
    }
}
```


Overlapping Code:
```
n main() {
let mut display = DisplayBuilder::new().size(304, 128).scale(2).build();
display.draw(
Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32).stroke(Some(1u8.into())),
);
display.draw(
Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)
.translate(icoord!(16, 16))
.stroke(Some(0u8.into()))
.fill(Some(1u8.into())),
);
display.draw(
Circle::new(icoord!(CIRCLE_SIZE, CIRCLE_SIZE), CIRCLE_SIZE as u32)
.translate(icoord!(CIRCLE_SIZE, CIRCLE_SIZE))
.stroke(Some(0u8.into()))
.fill(Some(0u8.into())),
);
display.draw(
Rectangle::new(icoord!(0, 0), icoord!(64, 64))
.translate(icoord!(96, 0))
.stroke(Some(1u8.into())),
);
display.draw(
&Rectangle::new(icoord!(0, 0), icoord!(64, 64))
.translate(icoord!(96 + 16, 16))
.stroke(Some(0u8.into()))
.fill(Some(1u8.into())),
);
display.draw(
Rectangle::new(icoord!(0, 0), icoord!(64, 64))
.translate(icoord!(96 + 32, 32))
.stroke(Some(0u8.into()))
.fill(Some(0u8.into())),
);
display.draw(
Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
.translate(icoord!(96 * 2, 0))
.stroke(Some(1u8.into())),
);
display.draw(
Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
.translate(icoord!(96 * 2 + 16, 16))
.stroke(Some(0u8.into()))
.fill(Some(1u8.into())),
);
display.draw(
Triangle::new(icoord!(32, 0), icoord!(0, 64), icoord!(64, 64))
.translate(icoord!(96 * 2 + 32, 32))
.stroke(Some(0u8.into()))
.fill(Some(0u8.into())),
);
loop {
let end = display.run_once();
if end {
break;
}
thread::sleep(Duration::from_millis(200));
}
}
```
<Overlap Ratio: 0.999345977763244>

---

--- 275 --
Question ID: ba06ea081f0dc27f380ce611f4424033b44f9ce3_0
Original Code:
```
fn basic_pipeline() {
        let pipeline = pipeline! {
            i32
            => add2
            => div_by_3
            => mul_by_83
            ;-> f32
        };
        let result = pipeline.run(2);

        assert_eq!(result, ((2 + 2) as f64 / 3.0) as f32 * 83.0);
    }
```


Overlapping Code:
```
eline! {
i32
=> add2
=> div_by_3
=> mul_by_83
;-> f32
};
let result = pipeline.run(2);
assert_eq!(result, ((2 + 2) as f64 / 3.0) as f32 *
```
<Overlap Ratio: 0.7365591397849462>

---

--- 276 --
Question ID: 96186abbda429901a23f60fa088fec1ae6f38405_1
Original Code:
```
fn last_day_of_solar_month(timestamp: i64, longitude: f64) -> usize {
    // HACK: This rely on an undefined behavior when getting a timestamp for
    // day following the last day of the month.
    let format = String::from("%h:%y:%s:%d:%c:%b");
    for i in 88..100 {
        let a = get_formatted_date(&format!("%h:%y:%s:{:02}:50:00", i), timestamp, longitude);
        let t = get_timestamp(format.clone(), a.clone(), longitude);
        let b = get_formatted_date(&format, t, longitude);
        if a != b {
            return i - 1;
        }
    }
    unreachable!();
}
```


Overlapping Code:
```
solar_month(timestamp: i64, longitude: f64) -> usize {
// HACK: This rely on an undefined behavior when getting a timestamp for
// day following the last day of the month.
let format = String::from("%h:%y:%s:%d:%c:%b");
for i in 88..100 {
let a = get_formatted_date(&format!("%h:%y:%s:{:02}:50:00", i), timestamp, longitude);
let t = get_timestamp(format.clone(), a.clone(), longitude);
let b = get_formatted_date(&format, t, longitude);
if a != b {
return i
```
<Overlap Ratio: 0.916>

---

--- 277 --
Question ID: 73afd4d81a04d3d999cd95dbbd4bbb68b04e2778_1
Original Code:
```
pub fn test_deserialize_vehicle_status() {
        let msg_data = test_shared::get_vehicle_status();
        let encoded:Vec<u8> = msg_data.ser();
        let decoded = VehicleStatusData::deser(encoded.as_slice()).unwrap();
        assert_eq!(msg_data.onboard_control_sensors_health, decoded.onboard_control_sensors_health);
    }
```


Overlapping Code:
```
ze_vehicle_status() {
let msg_data = test_shared::get_vehicle_status();
let encoded:Vec<u8> = msg_data.ser();
let decoded = VehicleStatusData::deser(encoded.as_slice()).unwrap();
assert_eq!(msg_data.onboard_control_sensors_health, decoded.onboard_con
```
<Overlap Ratio: 0.8503401360544217>

---

--- 278 --
Question ID: 521446926353aa29f8e0c0f47a9ceb19d7a8585a_0
Original Code:
```
fn main() -> std::io::Result<()> {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        eprintln!("usage: {} filename", args[0]);
        return Result::Err(std::io::Error::new(std::io::ErrorKind::Other, ""))
    }

    let file = File::open(&args[1])?;
    let buf_reader = BufReader::new(file);
    let lines = buf_reader.lines().map(|l| l.unwrap());

    let mut freqs = HashMap::new();

    for l in lines {
        let words = l.split_whitespace();
        for w in words {
            let val = match freqs.get(&w.to_string()) {
                Some(c) => c+1,
                None => 1,
            };
            freqs.insert(w.to_string(), val);
        }
    }
    let mut counts: Vec<_> = freqs.iter().collect();
    counts.sort_by(|a, b| b.1.cmp(a.1)); // compare by count value
    for (w, c) in counts.iter().take(25) {
        println!("{}:{}", w, c);
    }
    Ok(())
}
```


Overlapping Code:
```
fn main() -> std::io::Result<()> {
let args: Vec<_> = env::args().collect();
if args.len() != 2 {
eprintln!("usage: {} filename", args[0]);
return Result::Err(std::io::Error::new(std::io::ErrorKind::Other, ""))
}
let file = File::open(&args[1])?;
let buf_reader = BufReader::new(file);
let lines = buf_reader.lines().map(|l| l.unwrap());
let mut freqs = HashMap::new();
for l in lines {
let words = l.split_whitespace();
for w in words {
let val = match freqs.get(&w.to_string()) {
Some(c) => c+1,
None => 1,
};
freqs.insert(w.to_string(), val);
}
}
let mut counts: Vec<_> = freqs.iter().collect();
counts.sort_by(|a, b| b.1.cmp(a.1)); // compare by count value
for (w, c) in counts.iter().take(25) 
```
<Overlap Ratio: 0.9497282608695652>

---

--- 279 --
Question ID: 4b08a39dbd37f75e9e839e81b665a09333063dda_3
Original Code:
```
fn assert_reverse_seek(engine: &Engine, key: &[u8], pair: (&[u8], &[u8])) {
        let snapshot = engine.snapshot(&Context::new()).unwrap();
        let mut iter = snapshot.iter(None, true, ScanMode::Mixed).unwrap();
        iter.reverse_seek(&make_key(key)).unwrap();
        assert_eq!((iter.key(), iter.value()),
                   (&*bytes::encode_bytes(pair.0), pair.1));
    }
```


Overlapping Code:
```
verse_seek(engine: &Engine, key: &[u8], pair: (&[u8], &[u8])) {
let snapshot = engine.snapshot(&Context::new()).unwrap();
let mut iter = snapshot.iter(None, true, ScanMode::Mixed).unwrap();
iter.reverse_seek(&make_key(key)).unwrap();
assert_eq!((iter.key(), iter.value()),
(&*bytes::encode_bytes(pair
```
<Overlap Ratio: 0.9146341463414634>

---

--- 280 --
Question ID: 026a03dfe1d252c9b6a778c7eca0317b6a75f042_0
Original Code:
```
pub fn report_errors(files: Files, errors: Errors) -> ! {
    assert!(!errors.is_empty());
    let mut codemap = CodeMap::new();
    let mut file_mapping = HashMap::new();
    let mut current_end = 1;
    for (fname, filemap) in files.into_iter() {
        file_mapping.insert(fname, current_end);
        let added_fmap = codemap.add_filemap(FileName::real(fname), filemap.src().to_string());
        current_end = added_fmap.span().end().to_usize() + 1;
    }
    render_errors(&codemap, file_mapping, errors);
    std::process::exit(1)
}
```


Overlapping Code:
```
files: Files, errors: Errors) -> ! {
assert!(!errors.is_empty());
let mut codemap = CodeMap::new();
let mut file_mapping = HashMap::new();
let mut current_end = 1;
for (fname, filemap) in files.into_iter() {
file_mapping.insert(fname, current_end);
let added_fmap = codemap.add_filemap(FileName::real(fname), filemap.src().to_string());
current_end = added_fmap.span().end().to_usize() + 1;
}
render_errors(&codemap, file_mapping, errors);
std::proce
```
<Overlap Ratio: 0.9297520661157025>

---

--- 281 --
Question ID: 3deac005077f7c70c346c676b2f9596a2b4440d9_34
Original Code:
```
fn join_is_inserted_positionally() {
        let joined_table = Table::from("User").left_join(
            "Post"
                .alias("p")
                .on(("p", "userId").equals(Column::from(("User", "id")))),
        );
        let q = Select::from_table(joined_table).and_from("Toto");
        let (sql, _) = Postgres::build(q).unwrap();

        assert_eq!("SELECT \"User\".*, \"Toto\".* FROM \"User\" LEFT JOIN \"Post\" AS \"p\" ON \"p\".\"userId\" = \"User\".\"id\", \"Toto\"", sql);
    }
```


Overlapping Code:
```
n join_is_inserted_positionally() {
let joined_table = Table::from("User").left_join(
"Post"
.alias("p")
.on(("p", "userId").equals(Column::from(("User", "id")))),
);
let q = Select::from_table(joined_table).and_from("Toto");
let (sql, _) = Postgres::build(q).unwrap();
assert_eq!("SELECT \"User\".*, \"Toto\".* FROM \"User\" LEFT JOIN \"Post\" AS \"p\" ON \"p\".\"userId\" = \"User\".\"id\", \"Toto\"", sql);
}
```
<Overlap Ratio: 0.9975728155339806>

---

--- 282 --
Question ID: 317cd575022f054f10b312acd977441a6c51fefc_6
Original Code:
```
fn dns_san_server() {
    const MODULE_ID: &str = "m1";
    const GENERATION_ID: &str = "g1";

    let (mut service, identity, home_dir, crypto) = init_test(MODULE_ID, GENERATION_ID);

    // start up a simple Echo server using this server cert
    let port = get_unused_tcp_port();
    println!("Test server listening on port {}", port);
    let server = run_echo_server(identity, port);
    let mut runtime = tokio::runtime::Runtime::new().unwrap();
    runtime.spawn(server);

    // run a test client that uses the module id for TLS domain name
    let client1 = run_echo_client(&mut service, port, MODULE_ID);
    runtime.block_on(client1).unwrap();

    // run a test client that uses the CN for TLS domain name
    // NOTE: Ideally, this should be a separate test, but there's some global
    // state in the HSM C library that does not get reset between multiple
    // tests in the same run and causes the test to fail.
    let client2 = run_echo_client(&mut service, port, COMMON_NAME);
    runtime.block_on(client2).unwrap();

    // cleanup
    crypto
        .destroy_certificate(IOTEDGED_CA_ALIAS.to_string())
        .unwrap();
    home_dir.close().unwrap();
}
```


Overlapping Code:
```
ODULE_ID: &str = "m1";
const GENERATION_ID: &str = "g1";
let (mut service, identity, home_dir, crypto) = init_test(MODULE_ID, GENERATION_ID);
// start up a simple Echo server using this server cert
let port = get_unused_tcp_port();
println!("Test server listening on port {}", port);
let server = run_echo_server(identity, port);
let mut runtime = tokio::runtime::Runtime::new().unwrap();
runtime.spawn(server);
// run a test client that uses the module id for TLS domain name
let client1 = run_echo_client(&mut service, port, MODULE_ID);
runtime.block_on(client1).unwrap();
// run a test client that uses the CN for TLS domain name
// NOTE: Ideally, this should be a separate test, but there's some global
// state in the HSM C library that does not get reset between multiple
// tests in the same run and causes the test to fail.
let client2 = run_echo_client(&mut service, port, COMMON_NAME);
runtime.block_on(client2).unwrap();
// cleanup
crypto
.destroy_certificate(IOTEDGED_CA_ALIAS.to_string())
.unwrap(
```
<Overlap Ratio: 0.9439252336448598>

---

--- 283 --
Question ID: d3498df38a6f786e322e2eae2e457e06ee9b7226_0
Original Code:
```
pub fn with_prof_context<T, F: FnOnce()->T>(s: &str, f: F) -> T {
    set_prof_context(s);
    let res = f();
    set_prof_context("");
    res
}
```


Overlapping Code:
```
n with_prof_context<T, F: FnOnce()->T>(s: &str, f: F) -> T {
set_prof_context(s);
let res = f();
set_prof_context("
```
<Overlap Ratio: 0.8914728682170543>

---

--- 284 --
Question ID: 7c101485aa99c1b7d903812912399e3647b750eb_0
Original Code:
```
fn test_map_lock() {
        let lock = Arc::new(MapLock::new());
        let g = lock.lock(vec!["test"]);
        let g1 = lock.try_lock(vec!["test", "test1"]);
        assert_eq!(g1.is_some(), false);
        drop(g);
        let g2 = lock.try_lock(vec!["test", "test1"]);
        assert_eq!(g2.is_some(), true);

        let lock_1 = lock.clone();
        let j = go!(move || {
            let _g = lock_1.lock(vec!["test"]);
            println!("comeback in coroutine");
        });

        drop(g2);
        j.join().unwrap();
    }
```


Overlapping Code:
```
lock = Arc::new(MapLock::new());
let g = lock.lock(vec!["test"]);
let g1 = lock.try_lock(vec!["test", "test1"]);
assert_eq!(g1.is_some(), false);
drop(g);
let g2 = lock.try_lock(vec!["test", "test1"]);
assert_eq!(g2.is_some(), true);
let lock_1 = lock.clone();
let j = go!(move || {
let _g = lock_1.lock(vec!["test"]);
println!("comeback in coroutine
```
<Overlap Ratio: 0.847457627118644>

---

--- 285 --
Question ID: 2ccc6dde5b7dd9bfb6866553d62b8e08904cd9c7_2
Original Code:
```
pub fn add_http_breakpoint(
    service: &ZapService,
    string: String,
    location: String,
    mtch: String,
    inverse: String,
    ignorecase: String,
) -> Result<Value, ZapApiError> {
    let mut params = HashMap::new();
    params.insert("string".to_string(), string);
    params.insert("location".to_string(), location);
    params.insert("match".to_string(), mtch);
    params.insert("inverse".to_string(), inverse);
    params.insert("ignorecase".to_string(), ignorecase);
    super::call(service, "break", "action", "addHttpBreakpoint", params)
}
```


Overlapping Code:
```
n add_http_breakpoint(
service: &ZapService,
string: String,
location: String,
mtch: String,
inverse: String,
ignorecase: String,
) -> Result<Value, ZapApiError> {
let mut params = HashMap::new();
params.insert("string".to_string(), string);
params.insert("location".to_string(), location);
params.insert("match".to_string(), mtch);
params.insert("inverse".to_string(), inverse);
params.insert("ignorecase".to_string(), ignorecase);
super::call(service, "break", "action", "addHttpBreakpoint", params
```
<Overlap Ratio: 0.984251968503937>

---

--- 286 --
Question ID: a57cd8f7631515b8061ff79db8646cf271ca5d59_3
Original Code:
```
fn connect(name_hash: NameHash, our_uid: UniqueId, listener: &Listener) {
        const SOCKET_TOKEN: Token = Token(0);
        let el = unwrap!(Poll::new());

        let (our_pk, our_sk) = gen_encrypt_keypair();
        let mut sock = unwrap!(TcpSock::connect(&listener.addr));
        unwrap!(sock.set_encrypt_ctx(EncryptContext::anonymous_encrypt(listener.pub_key)));
        let shared_key = our_sk.shared_secret(&listener.pub_key);
        unwrap!(sock.set_decrypt_ctx(DecryptContext::authenticated(shared_key.clone())));
        unwrap!(el.register(&sock, SOCKET_TOKEN, Ready::writable(), PollOpt::edge()));

        let message = Message::ConnectRequest(our_uid, name_hash, Default::default(), our_pk);

        let mut events = Events::with_capacity(16);
        'event_loop: loop {
            let _ = unwrap!(el.poll(&mut events, None));
            for ev in events.iter() {
                match ev.token() {
                    SOCKET_TOKEN => {
                        if ev.readiness().is_writable() {
                            let sent = unwrap!(sock.write(Some((message.clone(), 0))));
                            assert!(sent);
                            unwrap!(el.reregister(
                                &sock,
                                SOCKET_TOKEN,
                                Ready::readable(),
                                PollOpt::edge(),
                            ));
                        }
                        if ev.readiness().is_readable() {
                            let msg: Message<UniqueId> = unwrap!(unwrap!(sock.read()));
                            let their_uid = match msg {
                                Message::ConnectResponse(peer_uid, peer_hash) => {
                                    assert_eq!(peer_uid, listener.uid);
                                    assert_eq!(peer_hash, NAME_HASH);

                                    unwrap!(sock.set_encrypt_ctx(EncryptContext::authenticated(
                                        shared_key
                                    )));
                                    peer_uid
                                }
                                msg => panic!("Unexpected message: {:?}", msg),
                            };
                            if our_uid > their_uid {
                                let message = Message::ChooseConnection::<UniqueId>;
                                let sent = unwrap!(sock.write(Some((message, 0))));
                                assert!(sent);
                            }
                            break 'event_loop;
                        }
                    }
                    _ => panic!("Unexpected event"),
                }
            }
        }

        match unwrap!(listener.event_rx.recv(), "Could not read event channel") {
            Event::ConnectSuccess(id) => assert_eq!(id, our_uid),
            event => panic!("Unexpected event notification: {:?}", event),
        }
    }
```


Overlapping Code:
```
connect(name_hash: NameHash, our_uid: UniqueId, listener: &Listener) {
const SOCKET_TOKEN: Token = Token(0);
let el = unwrap!(Poll::new());
let (our_pk, our_sk) = gen_encrypt_keypair();
let mut sock = unwrap!(TcpSock::connect(&listener.addr));
unwrap!(sock.set_encrypt_ctx(EncryptContext::anonymous_encrypt(listener.pub_key)));
let shared_key = our_sk.shared_secret(&listener.pub_key);
unwrap!(sock.set_decrypt_ctx(DecryptContext::authenticated(shared_key.clone())));
unwrap!(el.register(&sock, SOCKET_TOKEN, Ready::writable(), PollOpt::edge()));
let message = Message::ConnectRequest(our_uid, name_hash, Default::default(), our_pk);
let mut events = Events::with_capacity(16);
'event_loop: loop {
let _ = unwrap!(el.poll(&mut events, None));
for ev in events.iter() {
match ev.token() {
SOCKET_TOKEN => {
if ev.readiness().is_writable() {
let sent = unwrap!(sock.write(Some((message.clone(), 0))));
assert!(sent);
unwrap!(el.reregister(
&sock,
SOCKET_TOKEN,
Ready::readable(),
PollOpt::edge(),
));
}
if ev.readiness().is_readable() {
let msg: Message<UniqueId> = unwrap!(unwrap!(sock.read()));
let their_uid = match msg {
Message::ConnectResponse(peer_uid, peer_hash) => {
assert_eq!(peer_uid, listener.uid);
assert_eq!(peer_hash, NAME_HASH);
unwrap!(sock.set_encrypt_ctx(EncryptContext::authenticated(
shared_key
)));
peer_uid
}
msg => panic!("Unexpected message: {:?}", msg),
};
if our_uid > their_uid {
let message = Message::ChooseConnection::<UniqueId>;
let sent = unwrap!(sock.write(Some((message, 0)
```
<Overlap Ratio: 0.9953764861294584>

---

--- 287 --
Question ID: 862f0f0cb9bd34f3b4ddb8afdc7dcc3abdec80c9_6
Original Code:
```
fn run_import_command<'a>(args: &ArgMatches<'a>) -> Result<(), CliError> {
    let ctx = create_context()?;
    let blockstore = open_blockstore(&ctx)?;

    let filepath = args
        .value_of("blockfile")
        .ok_or_else(|| CliError::ArgumentError("No file".into()))?;
    let mut file = File::open(filepath)
        .map_err(|err| CliError::EnvironmentError(format!("Failed to open file: {}", err)))?;
    let mut packed = Vec::new();
    file.read_to_end(&mut packed)
        .map_err(|err| CliError::EnvironmentError(format!("Failed to read file: {}", err)))?;

    let block: Block = protobuf::parse_from_bytes(&packed)
        .map_err(|err| CliError::ParseError(format!("{}", err)))?;
    let block_header: BlockHeader = protobuf::parse_from_bytes(&block.header)
        .map_err(|err| CliError::ParseError(format!("{}", err)))?;
    let block_id = block.header_signature.clone();

    // Ensure this block is an immediate child of the current chain head
    match blockstore.get_chain_head() {
        Ok(chain_head) => {
            if block_header.previous_block_id != chain_head {
                return Err(CliError::ArgumentError(format!(
                    "New block must be an immediate child of the current chain head: {}",
                    chain_head
                )));
            }
        }
        Err(DatabaseError::NotFoundError(_)) => (),
        Err(err) => {
            return Err(CliError::EnvironmentError(format!("{}", err)));
        }
    }

    blockstore.put(&block).map_err(|err| {
        CliError::ArgumentError(format!("Failed to put block into database: {}", err))
    })?;

    println!("Block {} added", block_id);
    Ok(())
}
```


Overlapping Code:
```
_command<'a>(args: &ArgMatches<'a>) -> Result<(), CliError> {
let ctx = create_context()?;
let blockstore = open_blockstore(&ctx)?;
let filepath = args
.value_of("blockfile")
.ok_or_else(|| CliError::ArgumentError("No file".into()))?;
let mut file = File::open(filepath)
.map_err(|err| CliError::EnvironmentError(format!("Failed to open file: {}", err)))?;
let mut packed = Vec::new();
file.read_to_end(&mut packed)
.map_err(|err| CliError::EnvironmentError(format!("Failed to read file: {}", err)))?;
let block: Block = protobuf::parse_from_bytes(&packed)
.map_err(|err| CliError::ParseError(format!("{}", err)))?;
let block_header: BlockHeader = protobuf::parse_from_bytes(&block.header)
.map_err(|err| CliError::ParseError(format!("{}", err)))?;
let block_id = block.header_signature.clone();
// Ensure this block is an immediate child of the current chain head
match blockstore.get_chain_head() {
Ok(chain_head) => {
if block_header.previous_block_id != chain_head {
return Err(CliError::ArgumentError(format!(
"New block must be an immediate child of the current chain head: {}",
chain_head
)));
}
}
Err(DatabaseError::NotFoundError(_)) => (),
Err(err) => {
return Err(CliError::EnvironmentError(format!("{}", err)));
}
}
blockstore.put(&block).map_err(|err| {
CliError::ArgumentError(format!("Failed to put block into database: {}", err))
})?;
println!("Blo
```
<Overlap Ratio: 0.9673527324343506>

---

--- 288 --
Question ID: 3f36e0b1faaea8f1d4fec66a2bea1c6bacda2743_5
Original Code:
```
fn valid_system_is_parsed() {
        let input = r##"config:
        step = 8
        angle = 45
        rules:
        axiom = A
        A => BA
        B => A
        "##;

        let (actual, _rem) = system().parse(input).expect("to parse a system");

        let expected = LSystem {
            render_config: RenderConfig { step: 8, angle: 45 },
            axiom: vec!['A'],
            rules: LSystemRules::from_rules(vec![Rule::new('A', vec!['B', 'A']), Rule::new('B', vec!['A'])])
        };
        assert_eq!(actual, expected);
    }
```


Overlapping Code:
```
nfig:
step = 8
angle = 45
rules:
axiom = A
A => BA
B => A
"##;
let (actual, _rem) = system().parse(input).expect("to parse a system");
let expected = LSystem {
render_config: RenderConfig { step: 8, angle: 45 },
axiom: vec!['A'],
rules: LSystemRules::from_rules(vec![Rule::new('A', vec!['B', 'A']), Rule::new('B', vec!['A'])])
};
assert_eq!(actual, e
```
<Overlap Ratio: 0.8557457212713936>

---

--- 289 --
Question ID: 2a33af9047576b2894497c5d67f427b2828214e5_0
Original Code:
```
unsafe extern "C" fn reload_trampoline<P>(this: *mut ffi::GResolver, f: glib_ffi::gpointer)
where P: IsA<Resolver> {
    callback_guard!();
    let f: &&(Fn(&P) + 'static) = transmute(f);
    f(&Resolver::from_glib_borrow(this).downcast_unchecked())
}
```


Overlapping Code:
```
rn "C" fn reload_trampoline<P>(this: *mut ffi::GResolver, f: glib_ffi::gpointer)
where P: IsA<Resolver> {
callback_guard!();
let f: &&(Fn(&P) + 'static) = transmute(f);
f(&Resolver::from_glib_borrow(this).downcast_unchecked())
}
```
<Overlap Ratio: 0.9539748953974896>

---

--- 290 --
Question ID: d6af236d4b20131e6524b3a278bba79785a70345_0
Original Code:
```
pub fn prepare_share_change_session_plan(cluster_nodes: &BTreeSet<NodeId>, threshold: usize, key_id: &ServerKeyId, key_version: H256, master: &NodeId, old_key_version_owners: &BTreeSet<NodeId>, new_nodes_set: &BTreeSet<NodeId>) -> Result<ShareChangeSessionPlan, Error> {
	// we can't do anything if there are no enought shares
	if old_key_version_owners.len() < threshold + 1 {
		warn!("cannot add shares to key {} with threshold {}: only {} shares owners are available",
			key_id, threshold, old_key_version_owners.len());
		return Ok(ShareChangeSessionPlan {
			key_version: key_version,
			version_holders: Default::default(),
			consensus_group: Default::default(),
			new_nodes_map: Default::default(),
		});
	}

	// warn if we're loosing the key
	if new_nodes_set.len() < threshold + 1 {
		warn!("losing key {} with threshold {}: only {} nodes left after servers set change session",
			key_id, threshold, new_nodes_set.len());
	}

	// make new nodes map, so that:
	// all non-isolated old nodes will have their id number preserved
	// all new nodes will have new id number
	let mut new_nodes_map = new_nodes_set.difference(&old_key_version_owners)
		.map(|n| math::generate_random_scalar().map(|id| (n.clone(), Some(id))))
		.collect::<Result<BTreeMap<_, _>, _>>()?;
	if !new_nodes_map.is_empty() {
		for old_node in old_key_version_owners.iter().filter(|n| cluster_nodes.contains(n)) {
			new_nodes_map.insert(old_node.clone(), None);
		}
	}

	// select consensus group if there are some nodes to add
	let consensus_group = if !new_nodes_map.is_empty() {
			::std::iter::once(master.clone())
				.chain(old_key_version_owners.iter()
					.filter(|n| *n != master && cluster_nodes.contains(*n))
					.take(threshold)
					.cloned())
				.collect()
		} else {
			BTreeSet::new()
		};

	Ok(ShareChangeSessionPlan {
		key_version: key_version,
		version_holders: old_key_version_owners.clone(),
		consensus_group: consensus_group,
		new_nodes_map: new_nodes_map,
	})
}
```


Overlapping Code:
```
pub fn prepare_share_change_session_plan(cluster_nodes: &BTreeSet<NodeId>, threshold: usize, key_id: &ServerKeyId, key_version: H256, master: &NodeId, old_key_version_owners: &BTreeSet<NodeId>, new_nodes_set: &BTreeSet<NodeId>) -> Result<ShareChangeSessionPlan, Error> {
// we can't do anything if there are no enought shares
if old_key_version_owners.len() < threshold + 1 {
warn!("cannot add shares to key {} with threshold {}: only {} shares owners are available",
key_id, threshold, old_key_version_owners.len());
return Ok(ShareChangeSessionPlan {
key_version: key_version,
version_holders: Default::default(),
consensus_group: Default::default(),
new_nodes_map: Default::default(),
});
}
// warn if we're loosing the key
if new_nodes_set.len() < threshold + 1 {
warn!("losing key {} with threshold {}: only {} nodes left after servers set change session",
key_id, threshold, new_nodes_set.len());
}
// make new nodes map, so that:
// all non-isolated old nodes will have their id number preserved
// all new nodes will have new id number
let mut new_nodes_map = new_nodes_set.difference(&old_key_version_owners)
.map(|n| math::generate_random_scalar().map(|id| (n.clone(), Some(id))))
.collect::<Result<BTreeMap<_, _>, _>>()?;
if !new_nodes_map.is_empty() {
for old_node in old_key_version_owners.iter().filter(|n| cluster_nodes.contains(n)) {
new_nodes_map.insert(old_node.clone(), None);
}
}
// select consensus group if there are some nodes to add
let consensus_group = if !new_nodes_map.is_empty() {
::std::iter::once(master.clone())
.chain(old_key_version_owners.iter()
.filter(|n| *n != master && cluster_nodes.contains(*n))
.take(threshold)
.cloned())
.collect()
} else {
BTreeSet::new()
};
Ok(ShareChangeSessionPlan {
key_version: key_version,
version_holders: old_key_version_owners.clone(),
consensus_group: consensus_group,
new_nodes_map: new_
```
<Overlap Ratio: 0.992>

---

--- 291 --
Question ID: 0bb0cd84432a73281ff4d9a3f145225979d07bcb_0
Original Code:
```
async fn newterm(item: web::Json<Term>) -> Result<HttpResponse> {
    let Term { word, lambda: _ } = item.into_inner();
    let lambda = match lightblue(&word) {
        Ok(lambda) => lambda,
        Err(error) => {
            let error_msg = format!("{:?}", error);
            return Ok(HttpResponse::InternalServerError().body(error_msg));
        }
    };
    let ret_term = Term { word, lambda };
    Ok(HttpResponse::Ok().json(ret_term))
}
```


Overlapping Code:
```
son<Term>) -> Result<HttpResponse> {
let Term { word, lambda: _ } = item.into_inner();
let lambda = match lightblue(&word) {
Ok(lambda) => lambda,
Err(error) => {
let error_msg = format!("{:?}", error);
return Ok(HttpResponse::InternalServerError().body(error_msg));
}
};
let ret_term = Term { word, 
```
<Overlap Ratio: 0.7936507936507936>

---

--- 292 --
Question ID: 0c77eac154be90b49ab4c1b601b57a7fd90e0ef1_0
Original Code:
```
fn main() {
    // initialize logger
    simple_logger::init().unwrap();

    // setup of main data structures
    let mut ecs_ = ecs::ECS::new();
    let mut render_conf = RenderConfig {
        scale: 100.0,
        window_xs: 1000,
        window_ys: 1000,
        focused_entity: None
    };

    info!("Creating window with {:?}", render_conf);
    
    // setup of opengl window
    let opengl  = OpenGL::V3_2;
	let mut window: Window = WindowSettings::new(
            "rustac",
            [render_conf.window_xs, render_conf.window_ys]
        )
        .graphics_api(opengl)
        .exit_on_esc(true)
        .build()
        .unwrap();


	let ref mut gl  = GlGraphics::new(opengl);
    let sprite_textures = sprite::setup_sprite_textures();
	
    // BEGIN test code

    use crate::builder::dungeon;

    dungeon::create_empty_room(&mut ecs_, 0.0, 0.0, 10, 8);
    dungeon::create_empty_room(&mut ecs_, 0.0, 8.0, 8, 10);
    dungeon::delete_dungeon_entities(&mut ecs_, 
                                     gamestate::dungeon::DungeonElement::Wall,
                                     LocationVec { x: 4.0, y: 7.0 });
    dungeon::delete_dungeon_entities(&mut ecs_, 
                                     gamestate::dungeon::DungeonElement::Wall,
                                     LocationVec { x: 4.0, y: 8.0 });
    dungeon::create_attack_dummy(&mut ecs_, 3.0, 4.0);

    
    // player
    let player = create_test_dummy_player(&mut ecs_);

    render_conf.focused_entity = Some(player);

    // END test code

	//Main loop

    let mut events = Events::new(EventSettings::new());
    events.set_ups(UPDATES_PER_SECOND);

    let mut button_buffer: Option<Button> = None;

    while let Some(e) = events.next(&mut window) {

        if e.press_args().is_some() || button_buffer.is_some() {
            debug!("{:?}", &button_buffer);
            if let Some(p) = e.press_args() {
                button_buffer = input::handle_input(&p, &mut ecs_);
            } else {
                button_buffer = input::handle_input(&button_buffer.unwrap(), &mut ecs_);
            }
        }

        if let Some(_) = e.update_args() {
            gamelogic::update_entity_positions(&mut ecs_);
        }

        if let Some(r) = e.render_args() {
            render_game(gl, &r, &mut ecs_, &sprite_textures, &render_conf);
        }

        gamelogic::check_and_perform_end_turn(&mut ecs_);
	}
}
```


Overlapping Code:
```
er::init().unwrap();
// setup of main data structures
let mut ecs_ = ecs::ECS::new();
let mut render_conf = RenderConfig {
scale: 100.0,
window_xs: 1000,
window_ys: 1000,
focused_entity: None
};
info!("Creating window with {:?}", render_conf);

// setup of opengl window
let opengl = OpenGL::V3_2;
let mut window: Window = WindowSettings::new(
"rustac",
[render_conf.window_xs, render_conf.window_ys]
)
.graphics_api(opengl)
.exit_on_esc(true)
.build()
.unwrap();
let ref mut gl = GlGraphics::new(opengl);
let sprite_textures = sprite::setup_sprite_textures();

// BEGIN test code
use crate::builder::dungeon;
dungeon::create_empty_room(&mut ecs_, 0.0, 0.0, 10, 8);
dungeon::create_empty_room(&mut ecs_, 0.0, 8.0, 8, 10);
dungeon::delete_dungeon_entities(&mut ecs_, 
gamestate::dungeon::DungeonElement::Wall,
LocationVec { x: 4.0, y: 7.0 });
dungeon::delete_dungeon_entities(&mut ecs_, 
gamestate::dungeon::DungeonElement::Wall,
LocationVec { x: 4.0, y: 8.0 });
dungeon::create_attack_dummy(&mut ecs_, 3.0, 4.0);

// player
let player = create_test_dummy_player(&mut ecs_);
render_conf.focused_entity = Some(player);
// END test code
//Main loop
let mut events = Events::new(EventSettings::new());
events.set_ups(UPDATES_PER_SECOND);
let mut button_buffer: Option<Button> = None;
while let Some(e) = events.next(&mut window) {
if e.press_args().is_some() || button_buffer.is_some() {
debug!("{:?}", &button_buffer);
if let Some(p) = e.press_args() {
button_buffer = input::handle_input(&p, &mut ecs_);
} else {
button_buffer = input::handle_input(&button_buffer.unwrap(), &mut ecs_);
}
}
if let Some(_) = e.update_args() {
gamelogic::update_entity_positions(&mut ecs_);
}
if let Some(r) = e.render_args() {
render_game(gl, &r, &mut ecs_, &sprite_textures, &render_conf);
}
gamelogic::check_and_perfor
```
<Overlap Ratio: 0.9625668449197861>

---

--- 293 --
Question ID: ea66f9b181d23da56328a4bd97b96f8629cf11c2_0
Original Code:
```
fn trim_input(user_input: &mut String) {
    // Something like trim (perhaps just use `trim`?)
    if let Some('\n') = user_input.chars().next_back() {
        user_input.pop();
    }
    if let Some('\r') = user_input.chars().next_back() {
        user_input.pop();
    }
}
```


Overlapping Code:
```
er_input: &mut String) {
// Something like trim (perhaps just use `trim`?)
if let Some('\n') = user_input.chars().next_back() {
user_input.pop();
}
if let Some('\r') = user_input.chars().next_back() {
user_input.pop();
}
```
<Overlap Ratio: 0.9243697478991597>

---

--- 294 --
Question ID: 0db53506213438afcfd9c2bded69626c73d1403b_2
Original Code:
```
fn test_dual_convergence() {
        let c1 = FnResidual::new(1e-4);
        let c2 = DeltaX::new(1e-9);
        let c = DualCriteria::new(&c1, &c2);

        // neither c1 nor c2
        let x_0 = -3.7;
        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 113456.987));

        // c1 but not c2
        assert_eq!(false, c.is_converged(x_0, x_0 + 5e-10, 113456.987));

        // c2 but not c1
        assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 0.00008));

        // both c1 and c2
        assert_eq!(true, c.is_converged(0.0, 1e-10, 0.00008));
    }
```


Overlapping Code:
```
ual::new(1e-4);
let c2 = DeltaX::new(1e-9);
let c = DualCriteria::new(&c1, &c2);
// neither c1 nor c2
let x_0 = -3.7;
assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 113456.987));
// c1 but not c2
assert_eq!(false, c.is_converged(x_0, x_0 + 5e-10, 113456.987));
// c2 but not c1
assert_eq!(false, c.is_converged(x_0, x_0 + 1.0, 0.00008));
// both c1 and c2
assert_eq!(true, c.is_converged(0.0, 1e-10
```
<Overlap Ratio: 0.8714596949891068>

---

--- 295 --
Question ID: af2a630995c0e2d564b4d37c8a10b3b0b3deee7d_1
Original Code:
```
fn main() {
    pretty_env_logger::init();

    let addr = "127.0.0.1:1337".parse().unwrap();

    hyper::rt::run(future::lazy(move || {
        // Share a `Client` with all `Service`s
        let client = Client::new();

        let new_service = move || {
            // Move a clone of `client` into the `service_fn`.
            let client = client.clone();
            service_fn(move |req| {
                response_examples(req, &client)
            })
        };

        let server = Server::bind(&addr)
            .serve(new_service)
            .map_err(|e| eprintln!("server error: {}", e));

        println!("Listening on http://{}", addr);

        server
    }));
}
```


Overlapping Code:
```
fn main() {
pretty_env_logger::init();
let addr = "127.0.0.1:1337".parse().unwrap();
hyper::rt::run(future::lazy(move || {
// Share a `Client` with all `Service`s
let client = Client::new();
let new_service = move || {
// Move a clone of `client` into the `service_fn`.
let client = client.clone();
service_fn(move |req| {
response_examples(req, &client)
})
};
let server = Server::bind(&addr)
.serve(new_service)
.map_err(|e| eprintln!("server error: {}", e));
println!("Listening on http://{}", addr);
server
}));

```
<Overlap Ratio: 0.9980657640232108>

---

--- 296 --
Question ID: c3a2f978e1a8a4945f39ed8c091edbe5857ef762_12
Original Code:
```
fn mubs_scc_2() {
    //      +----+
    //      v    |
    // a -> c -> d
    //      ^    ^
    //      |    |
    //      +--- b

    // "digraph { a -> c -> d; d -> c; b -> d; b -> c; }",
    let mut relation = TransitiveRelation::new();
    relation.add("a", "c");
    relation.add("c", "d");
    relation.add("d", "c");
    relation.add("b", "d");
    relation.add("b", "c");

    assert_eq!(relation.minimal_upper_bounds(&"a", &"b"), vec![&"c"]);
}
```


Overlapping Code:
```
ubs_scc_2() {
// +----+
// v |
// a -> c -> d
// ^ ^
// | |
// +--- b
// "digraph { a -> c -> d; d -> c; b -> d; b -> c; }",
let mut relation = TransitiveRelation::new();
relation.add("a", "c");
relation.add("c", "d");
relation.add("d", "c");
relation.add("b", "d");
relation.add("b", "c");
assert_eq!(relation.minimal_upper_bounds(&"a", &"b"), vec![&"c"]);
}
```
<Overlap Ratio: 0.9889807162534435>

---

--- 297 --
Question ID: 3d55062c5244f88dcd462a368f5ca932bdf94007_594
Original Code:
```
fn spec_test_595() {
    let original = r##"<made-up-scheme://foo,bar>
"##;
    let expected = r##"<p><a href="made-up-scheme://foo,bar">made-up-scheme://foo,bar</a></p>
"##;

    test_markdown_html(original, expected);
}
```


Overlapping Code:
```
 r##"<made-up-scheme://foo,bar>
"##;
let expected = r##"<p><a href="made-up-scheme://foo,bar">made-up-scheme://foo,bar</a></p>
"##;
test_markdown_html(original, expected);
}
```
<Overlap Ratio: 0.8317307692307693>

---

--- 298 --
Question ID: 635995e22d6a3512849e9d3b51640804889b1f65_0
Original Code:
```
fn write(fmt: DefaultFormat) -> String {
        let buf = fmt.buf.buf.clone();

        let record = Record::builder()
            .args(format_args!("log message"))
            .level(Level::Info)
            .file(Some("test.rs"))
            .line(Some(144))
            .module_path(Some("test::path"))
            .build();

        fmt.write(&record).expect("failed to write record");

        let buf = buf.borrow();
        String::from_utf8(buf.bytes().to_vec()).expect("failed to read record")
    }
```


Overlapping Code:
```
t buf = fmt.buf.buf.clone();
let record = Record::builder()
.args(format_args!("log message"))
.level(Level::Info)
.file(Some("test.rs"))
.line(Some(144))
.module_path(Some("test::path"))
.build();
fmt.write(&record).expect("failed to write record");
let buf = buf.borrow();
String::from_utf8(buf.byt
```
<Overlap Ratio: 0.7672634271099744>

---

--- 299 --
Question ID: e0e2dc5d343e738004eb2cfde6a1c8daa851ffd6_1
Original Code:
```
fn test_trace_estimator() {
        let n = 1000;
        let num_random_vecs = 40;
        let x = Array::random((n, n), StandardNormal).mapv(|e| e as i32 as f32);
        // want to estimate the trace of x.t().dot(&x)
        let true_trace = sum_of_squares(x.iter());
        println!("true trace: {}", true_trace);

        let rand_mat =
            generate_plus_minus_one_bernoulli_matrix(n, num_random_vecs);

        let trace_est =
            sum_of_squares(x.dot(&rand_mat).iter()) / num_random_vecs as f64;
        println!("trace_est: {}", trace_est);
    }
```


Overlapping Code:
```
stimator() {
let n = 1000;
let num_random_vecs = 40;
let x = Array::random((n, n), StandardNormal).mapv(|e| e as i32 as f32);
// want to estimate the trace of x.t().dot(&x)
let true_trace = sum_of_squares(x.iter());
println!("true trace: {}", true_trace);
let rand_mat =
generate_plus_minus_one_bernoulli_matrix(n, num_random_vecs);
let trace_est =
sum_of_squares(x.dot(&rand_mat).iter()) / num_random_vecs as f64;
println!("trace_est: {}", trace_est
```
<Overlap Ratio: 0.9594882729211087>

---

--- 300 --
Question ID: 4a7a44286a7c80c34cdd0cba4d7e276771cca4ee_0
Original Code:
```
pub fn read_pixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, pixel_type: GLenum) -> Vec<u8> {
    let colors = match format {
        RGB => 3,
        RGBA => 3,
        _ => panic!("unsupported format for read_pixels"),
    };
    let depth = match pixel_type {
        UNSIGNED_BYTE => 1,
        _ => panic!("unsupported pixel_type for read_pixels"),
    };

    let len = (width * height * colors * depth) as uint;
    let mut pixels: Vec<u8> = Vec::new();
    pixels.reserve(len);

    unsafe {
        // We don't want any alignment padding on pixel rows.
        glPixelStorei(PACK_ALIGNMENT, 1);
        glReadPixels(x, y, width, height, format, pixel_type, pixels.as_mut_ptr() as *mut c_void);
        pixels.set_len(len);
    }

    pixels
}
```


Overlapping Code:
```
ub fn read_pixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei, format: GLenum, pixel_type: GLenum) -> Vec<u8> {
let colors = match format {
RGB => 3,
RGBA => 3,
_ => panic!("unsupported format for read_pixels"),
};
let depth = match pixel_type {
UNSIGNED_BYTE => 1,
_ => panic!("unsupported pixel_type for read_pixels"),
};
let len = (width * height * colors * depth) as uint;
let mut pixels: Vec<u8> = Vec::new();
pixels.reserve(len);
unsafe {
// We don't want any alignment padding on pixel rows.
glPixelStorei(PACK_ALIGNMENT, 1);
glReadPixels(x, y, width, height, format, pixel_type, pixels.as_mut_ptr() as *mut c_void);
pixels.set_len(len
```
<Overlap Ratio: 0.9789156626506024>

---

--- 301 --
Question ID: 55fd51ac5eb0db8c567c311373a2941b8af58c04_2
Original Code:
```
fn test_cross_at_point() {
    let ind1 = Ind(vec!(0xF, 0xF, 0xF, 0xF, 0xF));
    let ind2 = Ind(vec!(0x0, 0x0, 0x0, 0x0, 0x0));
    let mut pair = [ind1, ind2];

    cross_at_point(&mut pair, 4, 10);
    assert!(pair[0] == Ind(vec!(0, 0, 3, 0xF, 0xF)));
    assert!(pair[1] == Ind(vec!(0xF, 0xF, 0xC, 0x0, 0x0)));
}
```


Overlapping Code:
```
(0xF, 0xF, 0xF, 0xF, 0xF));
let ind2 = Ind(vec!(0x0, 0x0, 0x0, 0x0, 0x0));
let mut pair = [ind1, ind2];
cross_at_point(&mut pair, 4, 10);
assert!(pair[0] == Ind(vec!(0, 0, 3, 0xF, 0xF)));
assert!(pair
```
<Overlap Ratio: 0.6872852233676976>

---

--- 302 --
Question ID: 18397dd69503cb1e223befe5d34e6f6cd15e3d53_2
Original Code:
```
pub fn stop(SomeUser: komodorpcutil::KomodoRPC) -> Result<String, reqwest::Error> {
    let method_name: String = String::from("stop");
    let method_body: String = String::from("[]");
    let data: String = String::from(komodorpcutil::generate_body(
        SomeUser.clone(),
        method_name,
        method_body,
    ));
    let result = komodorpcutil::request(SomeUser.clone(), data);
    return result;
}
```


Overlapping Code:
```
eUser: komodorpcutil::KomodoRPC) -> Result<String, reqwest::Error> {
let method_name: String = String::from("stop");
let method_body: String = String::from("[]");
let data: String = String::from(komodorpcutil::generate_body(
SomeUser.clone(),
method_name,
method_body,
));
let result = komodorpcutil::request(SomeUser.clone(), data);
return res
```
<Overlap Ratio: 0.9424657534246575>

---

--- 303 --
Question ID: 11855d90c160f0af20154f7cdd4a32325dd0b5e5_7
Original Code:
```
fn merkle_one_id_should_work() {
        let ids: Vec<Checksum256> = vec![[1u8; 32].into()];
        let result = merkle(ids);
        assert!(result.is_ok());
        let expect: Checksum256 = [1u8; 32].into();
        assert_eq!(result.unwrap(), expect);
    }
```


Overlapping Code:
```
one_id_should_work() {
let ids: Vec<Checksum256> = vec![[1u8; 32].into()];
let result = merkle(ids);
assert!(result.is_ok());
let expect: Checksum256 = [1u8; 32].into();
assert_eq!(result.unwrap(), ex
```
<Overlap Ratio: 0.9174311926605505>

---

--- 304 --
Question ID: e2f89e943d304541c8ccd8a980ecf9d1ce9c654c_2
Original Code:
```
fn find_cycle(moons: &Vec<Vec<Moon1D>>, axis_index: usize) -> usize {
    let mut cloned = moons.clone();
    let original: Vec<Moon1D> = cloned.iter().map(|m| m[axis_index]).collect();
    let mut moons: Vec<&mut Moon1D> = cloned.iter_mut().map(|m| &mut m[axis_index]).collect();

    let mut counter = 0;

    loop {
        update_velocities_1d(&mut moons);
        update_positions_1d(&mut moons);

        counter += 1;

        let mut done = true;
        for i in 0..original.len() {
            if moons[i] != &original[i] {
                done = false;
                break;
            }
        }

        if done {
            break;
        }
    }

    counter
}
```


Overlapping Code:
```
(moons: &Vec<Vec<Moon1D>>, axis_index: usize) -> usize {
let mut cloned = moons.clone();
let original: Vec<Moon1D> = cloned.iter().map(|m| m[axis_index]).collect();
let mut moons: Vec<&mut Moon1D> = cloned.iter_mut().map(|m| &mut m[axis_index]).collect();
let mut counter = 0;
loop {
update_velocities_1d(&mut moons);
update_positions_1d(&mut moons);
counter += 1;
let mut done = true;
for i in 0..original.len() {
if moons[i] != &original[i] {
done = false;
break;
}
}
if done {
break;
}
}
counter
}
```
<Overlap Ratio: 0.9746588693957114>

---

--- 305 --
Question ID: a8ddd4f503630a268882e3e17ed4c9b7f3befe9e_0
Original Code:
```
pub fn init() -> Result<(), SalmiakError> {
    // Disable UART0
    unsafe {
        UART0_CR.write_volatile(0x0);
    }

    // we want consistent divisor values and
    // therefore set the clock rate of the UART
    let res = MailboxPropertyBufferBuilder::new()
        .set_clock_rate(
            mailbox::clock::UART,
            4_000_000, // 4 MHz
            0,         // skip turbo
            None,
        )
        .submit();

    if !res {
        return Err(
            SalmiakErrorKind::InitSerialError("Failed to set serial clockrate".to_owned()).into(),
        );
    }

    unsafe {
        let mut ra = GPFSEL1.read_volatile();
        ra &= !((7 << 12) | (7 << 15)); //gpio14, gpio15
        ra |= (4 << 12) | (4 << 15); //alt0
        GPFSEL1.write_volatile(ra);

        // Disable pull up/down for all GPIO pins and delay for 150 cycles
        GPPUD.write_volatile(0x0);
        delay(150);

        // Disable pull up/down for pin 14,15 & delay for 150 cycles.
        GPPUDCLK0.write_volatile((1 << 14) | (1 << 15));
        delay(150);

        // Write 0 to GPPUDCLK0 to make it take effect.
        GPPUDCLK0.write_volatile(0x0);

        // Clear pending interrupts.
        UART0_ICR.write_volatile(0x7ff);

        // Set integer & fractional part of baud rate.
        // Divider = UART_CLOCK/(16 * Baud)
        // Fraction part register = (Fractional part * 64) + 0.5
        // UART_CLOCK = 3000000; Baud = 115200.

        UART0_IBRD.write_volatile(2);
        UART0_FBRD.write_volatile(0xb);

        // Enable FIFO & 8 bit data transmissio (1 stop bit, no parity).
        UART0_LCRH.write_volatile(0b11 << 5);

        // Enable UART0, receive & transfer part of UART.
        UART0_CR.write_volatile((1) | (1 << 8) | (1 << 9));
        Ok(())
    }
}
```


Overlapping Code:
```
or> {
// Disable UART0
unsafe {
UART0_CR.write_volatile(0x0);
}
// we want consistent divisor values and
// therefore set the clock rate of the UART
let res = MailboxPropertyBufferBuilder::new()
.set_clock_rate(
mailbox::clock::UART,
4_000_000, // 4 MHz
0, // skip turbo
None,
)
.submit();
if !res {
return Err(
SalmiakErrorKind::InitSerialError("Failed to set serial clockrate".to_owned()).into(),
);
}
unsafe {
let mut ra = GPFSEL1.read_volatile();
ra &= !((7 << 12) | (7 << 15)); //gpio14, gpio15
ra |= (4 << 12) | (4 << 15); //alt0
GPFSEL1.write_volatile(ra);
// Disable pull up/down for all GPIO pins and delay for 150 cycles
GPPUD.write_volatile(0x0);
delay(150);
// Disable pull up/down for pin 14,15 & delay for 150 cycles.
GPPUDCLK0.write_volatile((1 << 14) | (1 << 15));
delay(150);
// Write 0 to GPPUDCLK0 to make it take effect.
GPPUDCLK0.write_volatile(0x0);
// Clear pending interrupts.
UART0_ICR.write_volatile(0x7ff);
// Set integer & fractional part of baud rate.
// Divider = UART_CLOCK/(16 * Baud)
// Fraction part register = (Fractional part * 64) + 0.5
// UART_CLOCK = 3000000; Baud = 115200.
UART0_IBRD.write_volatile(2);
UART0_FBRD.write_volatile(0xb);
// Enable FIFO & 8 bit data transmissio (1 stop bit, no parity).
UART0_LCRH.write_volatile(0b11 << 5);
// Enable UART0, receive & transfer part of UART.
UART0_CR.write_volati
```
<Overlap Ratio: 0.9447165850244926>

---

--- 306 --
Question ID: 25af6178a4375d001ecc3aa9ac91731af7e88458_3
Original Code:
```
fn main() {
    // Generate initial random population
    println_err!("Generating initial population");
    let mut population = evolve::random_population::<Program>(POPULATION_SIZE);
    let mut rng = rand::StdRng::new().unwrap();
    let mut stdout = std::io::stdout();
    let mut keeper = OptimumKeeper::<Program>::new();

    loop {
        println_err!("[{}] Scoring", population.generation);
        population.score(|p| score_program(p, &mut rng));
        {
            let winner = population.winner();
            println_err!("[{}] Best score: {}", population.generation, winner.score.total_score());
            
            if keeper.improved(&winner.program, &winner.score, population.generation) {
                let random_score = score_single_run(&winner.program, &mut rng);

                let _ = serialize::writeln(&serialize::TraceOutput {
                    generation: population.generation,
                    program: &winner.program.simplify(),
                    score_card: &random_score
                }, &mut stdout);
            }
        }

        println_err!("[{}] Evolving", population.generation);
        population = population.evolve(TOURNAMENT_SIZE,
                                       REPRODUCE_WEIGHT, 
                                       MUTATE_WEIGHT, 
                                       CROSSOVER_WEIGHT,
                                       &mut rng);
    }
}
```


Overlapping Code:
```
ate initial random population
println_err!("Generating initial population");
let mut population = evolve::random_population::<Program>(POPULATION_SIZE);
let mut rng = rand::StdRng::new().unwrap();
let mut stdout = std::io::stdout();
let mut keeper = OptimumKeeper::<Program>::new();
loop {
println_err!("[{}] Scoring", population.generation);
population.score(|p| score_program(p, &mut rng));
{
let winner = population.winner();
println_err!("[{}] Best score: {}", population.generation, winner.score.total_score());

if keeper.improved(&winner.program, &winner.score, population.generation) {
let random_score = score_single_run(&winner.program, &mut rng);
let _ = serialize::writeln(&serialize::TraceOutput {
generation: population.generation,
program: &winner.program.simplify(),
score_card: &random_score
}, &mut stdout);
}
}
println_err!("[{}] Evolving", population.generation);
population = population.evolve(TOURNAMENT_SIZE,
REPRODUCE_WEIGHT, 
MUTATE_WEIGHT, 
CROSSOVER_WEIGHT,
&mut r
```
<Overlap Ratio: 0.97252208047105>

---

--- 307 --
Question ID: a10d4c508021a2a4a7f87ea06703e2856e0f8eee_25
Original Code:
```
fn ShiftExpression2(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::Expression> {
    let skipped = take!(tokens.clone(), 1)?;
    let tok = is_token!(skipped.0, Token::DoubleBigger)?;
    let or = ShiftExpression(skipped.1)?;
    let and = ShiftExpression(tok.0)?;
    Ok((
        and.0,
        node::Expression::BinaryExpression(node::BinaryExpression {
            operator: estree::BinaryOperator::MoreMore,
            left: box or.1,
            right: box and.1,
        }),
    ))
}
```


Overlapping Code:
```
(tokens: Input<InputWrapper>) -> IResult<Input<InputWrapper>, node::Expression> {
let skipped = take!(tokens.clone(), 1)?;
let tok = is_token!(skipped.0, Token::DoubleBigger)?;
let or = ShiftExpression(skipped.1)?;
let and = ShiftExpression(tok.0)?;
Ok((
and.0,
node::Expression::BinaryExpression(node::BinaryExpression {
operator: estree::BinaryOperator::MoreMore,
left: box or.1,
right: box and.1,
}
```
<Overlap Ratio: 0.9391100702576113>

---

--- 308 --
Question ID: c843c54f6a0f77e2fb96eb50cd973380d45b90c5_0
Original Code:
```
pub fn spiral_matrix(size: u32) -> Vec<Vec<u32>> {
    let size = size as usize;
    if size == 0 {
        return Vec::new();
    } else if size == 1 {
        return vec![vec![1; size]; size];
    }
    let mut spiral: Vec<Vec<u32>> = vec![vec![0; size]; size];

    let mut i = 0;
    let mut j = 0;
    let mut val = 1;
    let mut moving = State::MovingRight;

    while spiral[i][j] == 0 {
        spiral[i][j] = val;
        val += 1;
        match moving {
            State::MovingRight => {
                if j == size - 1 || spiral[i][j + 1] != 0 {
                    i += 1;
                    moving = State::MovieDown;
                } else {
                    j += 1;
                }
            }
            State::MovieDown => {
                if i == size - 1 || spiral[i + 1][j] != 0 {
                    j -= 1;
                    moving = State::MovingLeft;
                } else {
                    i += 1;
                }
            }
            State::MovingLeft => {
                println!("{:?}", (i, j));
                if j == 0 || spiral[i][j - 1] != 0 {
                    i -= 1;
                    moving = State::MovingUp
                } else {
                    j -= 1;
                }
            }
            State::MovingUp => {
                if i == 0 || spiral[i - 1][j] != 0 {
                    j += 1;
                    moving = State::MovingRight;
                } else {
                    i -= 1
                }
            }
        }
    }

    spiral
}
```


Overlapping Code:
```
pub fn spiral_matrix(size: u32) -> Vec<Vec<u32>> {
let size = size as usize;
if size == 0 {
return Vec::new();
} else if size == 1 {
return vec![vec![1; size]; size];
}
let mut spiral: Vec<Vec<u32>> = vec![vec![0; size]; size];
let mut i = 0;
let mut j = 0;
let mut val = 1;
let mut moving = State::MovingRight;
while spiral[i][j] == 0 {
spiral[i][j] = val;
val += 1;
match moving {
State::MovingRight => {
if j == size - 1 || spiral[i][j + 1] != 0 {
i += 1;
moving = State::MovieDown;
} else {
j += 1;
}
}
State::MovieDown => {
if i == size - 1 || spiral[i + 1][j] != 0 {
j -= 1;
moving = State::MovingLeft;
} else {
i += 1;
}
}
State::MovingLeft => {
println!("{:?}", (i, j));
if j == 0 || spiral[i][j - 1] != 0 {
i -= 1;
moving = State::MovingUp
} else {
j -= 1;
}
}
State::MovingUp => {
if i == 0 || spiral[i - 1][j] != 0 {
j += 1;
moving = State::MovingR
```
<Overlap Ratio: 0.9576365663322185>

---

--- 309 --
Question ID: 7c00465375714126de0fd6af657926f61181f564_7
Original Code:
```
fn test_parse_value_param() {
        let v: Value = json!({ "confirmations": 10 });

        let confirmations = v
            .get("confirmations")
            .and_then(|el| el.as_u64())
            .ok_or(HttpError::from(
                "confirmations absent or not a u64".to_string(),
            ))
            .unwrap();

        assert_eq!(10, confirmations);

        let err = v
            .get("notexist")
            .and_then(|el| el.as_u64())
            .ok_or(HttpError::from("notexist absent or not a u64".to_string()));

        assert!(err.is_err());
    }
```


Overlapping Code:
```
_value_param() {
let v: Value = json!({ "confirmations": 10 });
let confirmations = v
.get("confirmations")
.and_then(|el| el.as_u64())
.ok_or(HttpError::from(
"confirmations absent or not a u64".to_string(),
))
.unwrap();
assert_eq!(10, confirmations);
let err = v
.get("notexist")
.and_then(|el| el.as_u64())
.ok_or(HttpError::from("notexist absent or not a u64".to_string()));
assert!(err.is_err()
```
<Overlap Ratio: 0.9592326139088729>

---

--- 310 --
Question ID: e049f4062c0057693c0c90e18fb5d6b5ec44bb92_103
Original Code:
```
fn problem_2017_2_2() {
    #![allow(clippy::unwrap_used)]
    let input = read_to_string("src/year2017/day02_input.txt").unwrap();
    solve(2017, 2, 2, &input).unwrap();
}
```


Overlapping Code:
```
2_2() {
#![allow(clippy::unwrap_used)]
let input = read_to_string("src/year2017/day02_input.txt").unwrap();
solve(
```
<Overlap Ratio: 0.7080745341614907>

---

--- 311 --
Question ID: c54db15f30cff27fe0e28f1218b83293f87d063a_1
Original Code:
```
fn create_ac_client(conn_addr: &str) -> AdmissionControlClient {
    let env_builder = Arc::new(EnvBuilder::new().name_prefix("ac-grpc-").build());
    let ch = ChannelBuilder::new(env_builder).connect(&conn_addr);
    AdmissionControlClient::new(ch)
}
```


Overlapping Code:
```
nn_addr: &str) -> AdmissionControlClient {
let env_builder = Arc::new(EnvBuilder::new().name_prefix("ac-grpc-").build());
let ch = ChannelBuilder::new(env_builder).connect(&conn_addr);
AdmissionControlClient::new(ch)
}
```
<Overlap Ratio: 0.9083333333333333>

---

--- 312 --
Question ID: 13450344a708155aea510fca40876281dc394e86_4
Original Code:
```
pub fn secret_2_address(secret: &str) -> Address {
    let a = hex::decode(clean_0x(secret)).unwrap();
    let secret_key = secp256k1::SecretKey::parse_slice(a.as_slice()).unwrap();
    let public_key = secp256k1::PublicKey::from_secret_key(&secret_key);
    let serialized = public_key.serialize();
    let mut public = Public::default();
    public.copy_from_slice(&serialized[1..65]);
    public_2_address(&public)
}
```


Overlapping Code:
```
ress(secret: &str) -> Address {
let a = hex::decode(clean_0x(secret)).unwrap();
let secret_key = secp256k1::SecretKey::parse_slice(a.as_slice()).unwrap();
let public_key = secp256k1::PublicKey::from_secret_key(&secret_key);
let serialized = public_key.serialize();
let mut public = Public::default();
public.copy_from_slice(&serialized[1..65]);
public_2_address(&public)
}
```
<Overlap Ratio: 0.9514066496163683>

---

--- 313 --
Question ID: 889207f29fb47fe1b3a16b4c1b4abbccb6704f1d_4
Original Code:
```
fn finish_epoch(
    storage: &mut Storage,
    genesis_data: &GenesisData,
    epoch_writer_state: EpochWriterState,
    chain_state: &ChainState,
    is_epoch_with_ebb: bool,
) -> Result<()> {
    let epoch_id = epoch_writer_state.epoch_id;
    let (packhash, index) = pack::packwriter_finalize(&storage.config, epoch_writer_state.writer);
    let (lookup, tmpfile) = pack::create_index(&storage, &index);
    tmpfile.render_permanent(&storage.config.get_index_filepath(&packhash))?;
    storage.add_lookup(packhash, lookup);
    let epoch_time_elapsed = epoch_writer_state.write_start_time.elapsed().unwrap();

    if epoch_id > 0 {
        assert!(
            epoch_exists(&storage.config, epoch_id - 1)?,
            "Attempted finish_epoch() with non-existent previous epoch (ID {}, previous' ID {})",
            epoch_id,
            epoch_id - 1
        );
    }

    assert_eq!(chain_state.last_date.unwrap().get_epochid(), epoch_id);

    let epoch_flags = EpochFlags {
        is_ebb: is_epoch_with_ebb,
    };

    epoch::epoch_create(
        storage,
        &packhash,
        epoch_id,
        index,
        Some((chain_state, genesis_data)),
        &epoch_flags,
    );

    info!(
        "=> pack {} written for epoch {} in {}",
        hex::encode(&packhash[..]),
        epoch_id,
        duration_print(epoch_time_elapsed)
    );

    for hash in &epoch_writer_state.blobs_to_delete {
        debug!("removing blob {}", hash);
        blob::remove(&storage, &hash.clone().into());
    }

    let diff = storage
        .read_block(&types::header_to_blockhash(&chain_state.last_block))?
        .decode()?
        .header()
        .difficulty();

    // Drop this epoch from loose index
    storage.drop_loose_index_before(diff);

    Ok(())
}
```


Overlapping Code:
```
finish_epoch(
storage: &mut Storage,
genesis_data: &GenesisData,
epoch_writer_state: EpochWriterState,
chain_state: &ChainState,
is_epoch_with_ebb: bool,
) -> Result<()> {
let epoch_id = epoch_writer_state.epoch_id;
let (packhash, index) = pack::packwriter_finalize(&storage.config, epoch_writer_state.writer);
let (lookup, tmpfile) = pack::create_index(&storage, &index);
tmpfile.render_permanent(&storage.config.get_index_filepath(&packhash))?;
storage.add_lookup(packhash, lookup);
let epoch_time_elapsed = epoch_writer_state.write_start_time.elapsed().unwrap();
if epoch_id > 0 {
assert!(
epoch_exists(&storage.config, epoch_id - 1)?,
"Attempted finish_epoch() with non-existent previous epoch (ID {}, previous' ID {})",
epoch_id,
epoch_id - 1
);
}
assert_eq!(chain_state.last_date.unwrap().get_epochid(), epoch_id);
let epoch_flags = EpochFlags {
is_ebb: is_epoch_with_ebb,
};
epoch::epoch_create(
storage,
&packhash,
epoch_id,
index,
Some((chain_state, genesis_data)),
&epoch_flags,
);
info!(
"=> pack {} written for epoch {} in {}",
hex::encode(&packhash[..]),
epoch_id,
duration_print(epoch_time_elapsed)
);
for hash in &epoch_writer_state.blobs_to_delete {
debug!("removing blob {}", hash);
blob::remove(&storage, &hash.clone().into());
}
let diff = storage
.read_block(&types::header_to_blockhash(&chain_state.last_block))?
.decode()?
.header()
.difficulty();
// Drop this epoch from loose index
stor
```
<Overlap Ratio: 0.9684065934065934>

---

--- 314 --
Question ID: 8a90f06ca17e46ceee5442f95de6c867ec26f2f8_2
Original Code:
```
fn parse_baseframe( mut buf: & str, num_joints: Option< u64 > ) -> Result< ( & str, Vec< FrameJoint > ), & 'static str > {

    let mut baseframe : Vec< FrameJoint > = vec![];
    
    match md5anim_baseframe_opening( buf ) {
        nom::IResult::Done( i, o ) => {
            buf = i;
        },
        _ => {
            return Err( "baseframe opening token not found" )
        },
    }
    match num_joints {
        None => {
            return Err( "num joints not specified at point of baseframe parsing" )
        },
        _ => {},
    }
    
    let n = num_joints.unwrap();
    let mut count = 0;
    while count < n {
        match peek_and_consume_comments( buf ) {
            Some(x) => {
                buf = x;
                continue;
            },
            _ => {}
        }
        match md5anim_baseframe( buf ) {
            nom::IResult::Done( i, mut o ) => {
                buf = i;
                o._index = count as u64; //set index
                baseframe.push( o );
            },
            _ => {
                return Err("bounds parse unsuccessful")
            },
        }

        count += 1;
    }                

    match peek_and_consume_comments( buf ) {
        Some(x) => {
            buf = x;
        },
        _ => {}
    }

    match md5anim_baseframe_closing( buf ) {
        nom::IResult::Done( i, o ) => {
            buf = i;
        },
        _ => {},
    }

    match peek_and_consume_comments( buf ) {
        Some(x) => { buf = x; },
        _ => {},
    }

    Ok( ( buf, baseframe ) )
}
```


Overlapping Code:
```
e_baseframe( mut buf: & str, num_joints: Option< u64 > ) -> Result< ( & str, Vec< FrameJoint > ), & 'static str > {
let mut baseframe : Vec< FrameJoint > = vec![];

match md5anim_baseframe_opening( buf ) {
nom::IResult::Done( i, o ) => {
buf = i;
},
_ => {
return Err( "baseframe opening token not found" )
},
}
match num_joints {
None => {
return Err( "num joints not specified at point of baseframe parsing" )
},
_ => {},
}

let n = num_joints.unwrap();
let mut count = 0;
while count < n {
match peek_and_consume_comments( buf ) {
Some(x) => {
buf = x;
continue;
},
_ => {}
}
match md5anim_baseframe( buf ) {
nom::IResult::Done( i, mut o ) => {
buf = i;
o._index = count as u64; //set index
baseframe.push( o );
},
_ => {
return Err("bounds parse unsuccessful")
},
}
count += 1;
} 
match peek_and_consume_comments( buf ) {
Some(x) => {
buf = x;
},
_ => {}
}
match md5anim_baseframe_closing( buf ) {
nom::IResult::Done( i, o ) => {
buf = i;
},
_ => {},
}
match peek_and_consume_comments( buf ) {
Some(x) => { buf = x; },
_ => {},
}
Ok( ( buf, basef
```
<Overlap Ratio: 0.9840674789128397>

---

--- 315 --
Question ID: 18137537ca9c54fa3de54068d587a43481df8875_0
Original Code:
```
fn read_line() -> String {
    let mut return_ = format!("");
    std::io::stdin().read_line(&mut return_).ok();
    return_
}
```


Overlapping Code:
```
fn read_line() -> String {
let mut return_ = format!("");
std::io::stdin().read_line(&mut return_).ok();
return_
```
<Overlap Ratio: 0.9824561403508771>

---

--- 316 --
Question ID: 22153c435cc54c6faae68c0d8688a6746167fa41_0
Original Code:
```
pub fn load_summary<P: AsRef<Path>>(path: P) -> Result<Vec<PartialTxnLookup>, Box<Error>> {
    let mut res = Vec::new();
    let mut reader = Reader::from_path(path)?;
    for row in reader.records() {
        TxnSummary::from_row(&row?)?
            .partial_txns()
            .into_iter()
            .for_each(|partial_txn| res.push(partial_txn));
    }
    Ok(res)
}
```


Overlapping Code:
```
th>>(path: P) -> Result<Vec<PartialTxnLookup>, Box<Error>> {
let mut res = Vec::new();
let mut reader = Reader::from_path(path)?;
for row in reader.records() {
TxnSummary::from_row(&row?)?
.partial_txns()
.into_iter()
.for_each(|partial_txn| res.push
```
<Overlap Ratio: 0.8116883116883117>

---

--- 317 --
Question ID: ccfe9f2f805a78b7b457b0d541aeee39263e803c_56
Original Code:
```
fn wire_assign_01() {
        let mut b = "module test { wire a; a = a + 1'b1;}".as_bytes();
        let mut l = Lexer::new(&mut b);
        let mut p = Parser::new(&mut l);

        let wire = create_node!(ASTClass::Wire(vec![(
            create_node!(ASTClass::Identifire("a".to_string())),
            None,
        )]));

        let expr = create_node!(ASTClass::Expression(
            create_node!(ASTClass::Identifire("a".to_string())),
            create_node!(ASTClass::Operator(Operator::Plus)),
            create_node!(ASTClass::Number("1'b1".to_string())),
        ));
        let assign = create_node!(ASTClass::Assign(
            create_node!(ASTClass::Identifire("a".to_string())),
            expr,
        ));
        let components = vec![wire, assign];
        let module = create_node!(ASTClass::Module(
            create_node!(ASTClass::Identifire("test".to_string())),
            create_node!(ASTClass::Block(components))
        ));
        assert_eq!(p.next_ast(), module);
    }
```


Overlapping Code:
```
st { wire a; a = a + 1'b1;}".as_bytes();
let mut l = Lexer::new(&mut b);
let mut p = Parser::new(&mut l);
let wire = create_node!(ASTClass::Wire(vec![(
create_node!(ASTClass::Identifire("a".to_string())),
None,
)]));
let expr = create_node!(ASTClass::Expression(
create_node!(ASTClass::Identifire("a".to_string())),
create_node!(ASTClass::Operator(Operator::Plus)),
create_node!(ASTClass::Number("1'b1".to_string())),
));
let assign = create_node!(ASTClass::Assign(
create_node!(ASTClass::Identifire("a".to_string())),
expr,
));
let components = vec![wire, assign];
let module = create_node!(ASTClass::Module(
create_node!(ASTClass::Identifire("test".to_string())),
create_node!(ASTClass::Block(components))
));
assert_eq!(p.next_ast(), module);
}
```
<Overlap Ratio: 0.9443742098609356>

---

--- 318 --
Question ID: 3deac005077f7c70c346c676b2f9596a2b4440d9_2
Original Code:
```
fn test_single_row_insert() {
        let expected = expected_values("INSERT INTO \"users\" (\"foo\") VALUES ($1)", vec![10]);
        let query = Insert::single_into("users").value("foo", 10);
        let (sql, params) = Postgres::build(query).unwrap();

        assert_eq!(expected.0, sql);
        assert_eq!(expected.1, params);
    }
```


Overlapping Code:
```
fn test_single_row_insert() {
let expected = expected_values("INSERT INTO \"users\" (\"foo\") VALUES ($1)", vec![10]);
let query = Insert::single_into("users").value("foo", 10);
let (sql, params) = Postgres::build(query).unwrap();
assert_eq!(expected.0, sql);
assert_eq!(expected.1, params);
}
```
<Overlap Ratio: 1.0>

---

--- 319 --
Question ID: a68a9b4e66ec30f339f46729943cc9414da5a1f2_0
Original Code:
```
fn parse_instructions(input: &str) -> (Vec<Step>, BTreeMap<Step, Vec<Step>>) {
    let matcher = Regex::new("Step (.) must be finished before step (.) can begin.").unwrap();
    let mut instruction_map = BTreeMap::new();

    matcher.captures_iter(input).for_each(|capture| {
        let prerequisite = capture[1].chars().next().unwrap();
        let step = capture[2].chars().next().unwrap();

        let entry = instruction_map.entry(step).or_insert_with(Vec::new);

        entry.push(prerequisite);

        instruction_map.entry(prerequisite).or_insert_with(Vec::new);
    });

    let all_steps = instruction_map.keys().cloned().collect::<Vec<char>>();

    (all_steps, instruction_map)
}
```


Overlapping Code:
```
e_instructions(input: &str) -> (Vec<Step>, BTreeMap<Step, Vec<Step>>) {
let matcher = Regex::new("Step (.) must be finished before step (.) can begin.").unwrap();
let mut instruction_map = BTreeMap::new();
matcher.captures_iter(input).for_each(|capture| {
let prerequisite = capture[1].chars().next().unwrap();
let step = capture[2].chars().next().unwrap();
let entry = instruction_map.entry(step).or_insert_with(Vec::new);
entry.push(prerequisite);
instruction_map.entry(prerequisite).or_insert_with(Vec::new);
});
let all_steps = instruction_map.keys().cloned().collect::<Vec<char>>();
(all_steps, 
```
<Overlap Ratio: 0.96>

---

--- 320 --
Question ID: 3cbe789fd0fb7cd7d9ee871974f5002a9a73c56c_5
Original Code:
```
fn null_key() {
        let mut hm = BTreeMap::new();
        let lol: Option<i32> = None;
        hm.insert(lol, 1337);
        let tr = to_transit_json(hm);

        assert_eq!(json!(["^", "~_", 1337]), tr);
    }
```


Overlapping Code:
```
t mut hm = BTreeMap::new();
let lol: Option<i32> = None;
hm.insert(lol, 1337);
let tr = to_transit_json(hm);
assert_eq!(json!(["^", "~_", 1337]), tr);
```
<Overlap Ratio: 0.8823529411764706>

---

--- 321 --
Question ID: 2533ac14e5a017e1a719eccfdaa05e7c6ee94ede_6
Original Code:
```
fn append_vec_concurrent_get_append(bencher: &mut Bencher) {
    let path = get_append_vec_bench_path("bench_get_append");
    let vec = Arc::new(RwLock::new(AppendVec::<AtomicUsize>::new(
        &path, true, START_SIZE, INC_SIZE,
    )));
    let vec1 = vec.clone();
    let size = 1_000_000;
    let count = Arc::new(AtomicUsize::new(0));
    let count1 = count.clone();
    spawn(move || loop {
        let mut len = count.load(Ordering::Relaxed);
        {
            let rlock = vec1.read().unwrap();
            loop {
                if rlock.append(AtomicUsize::new(0)).is_none() {
                    break;
                }
                len = count.fetch_add(1, Ordering::Relaxed);
            }
            if len >= size {
                break;
            }
        }
        {
            let mut wlock = vec1.write().unwrap();
            if len >= size {
                break;
            }
            assert!(wlock.grow_file().is_ok());
        }
    });
    bencher.iter(|| {
        let rlock = vec.read().unwrap();
        let len = count1.load(Ordering::Relaxed);
        if len > 0 {
            let index = thread_rng().gen_range(0, len);
            rlock.get((index * std::mem::size_of::<AtomicUsize>()) as u64);
        }
    });
    std::fs::remove_file(path).unwrap();
}
```


Overlapping Code:
```
oncurrent_get_append(bencher: &mut Bencher) {
let path = get_append_vec_bench_path("bench_get_append");
let vec = Arc::new(RwLock::new(AppendVec::<AtomicUsize>::new(
&path, true, START_SIZE, INC_SIZE,
)));
let vec1 = vec.clone();
let size = 1_000_000;
let count = Arc::new(AtomicUsize::new(0));
let count1 = count.clone();
spawn(move || loop {
let mut len = count.load(Ordering::Relaxed);
{
let rlock = vec1.read().unwrap();
loop {
if rlock.append(AtomicUsize::new(0)).is_none() {
break;
}
len = count.fetch_add(1, Ordering::Relaxed);
}
if len >= size {
break;
}
}
{
let mut wlock = vec1.write().unwrap();
if len >= size {
break;
}
assert!(wlock.grow_file().is_ok());
}
});
bencher.iter(|| {
let rlock = vec.read().unwrap();
let len = count1.load(Ordering::Relaxed);
if len > 0 {
let index = thread_rng().gen_range(0, len);
rlock.get((index * std::mem::size_of::<AtomicUsize>()) as u64);
}
});
std::f
```
<Overlap Ratio: 0.9503695881731784>

---

--- 322 --
Question ID: a084fb80681ade4e35fc1fa32ee0cd38df7eaf71_5
Original Code:
```
fn it_should_know_if_input_is_less_than_8_in_immediate_mode() {
        let program: Vec<i32> = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];
        assert_eq!(run_program(&mut program.clone(), &mut vec![7]), 1);
        assert_eq!(run_program(&mut program.clone(), &mut vec![8]), 0);
    }
```


Overlapping Code:
```
 it_should_know_if_input_is_less_than_8_in_immediate_mode() {
let program: Vec<i32> = vec![3, 3, 1107, -1, 8, 3, 4, 3, 99];
assert_eq!(run_program(&mut program.clone(), &mut vec![7]), 1);
assert_eq!(run_program(&mut program.clone(), &mut vec![8]), 0)
```
<Overlap Ratio: 0.9803921568627451>

---

--- 323 --
Question ID: c3c329bb1e4cac9189079e337c9f390bdb7e218d_24
Original Code:
```
fn test_codec_datetime() -> Result<()> {
        let cases = vec![
            ("2010-10-10 10:11:11", 0),
            ("2017-01-01 00:00:00", 0),
            ("2004-01-01 00:00:00", UNSPECIFIED_FSP),
            ("2013-01-01 00:00:00.000000", MAX_FSP),
            ("2019-01-01 00:00:00.123456", MAX_FSP),
            ("2001-01-01 00:00:00.123456", MAX_FSP),
            ("2007-06-01 00:00:00.999999", MAX_FSP),
            // Invalid cases
            ("0000-00-00 00:00:00", 0),
            ("2007-00-01 00:00:00.999999", MAX_FSP),
            ("2017-01-00 00:00:00.999999", MAX_FSP),
            ("2027-00-00 00:00:00.999999", MAX_FSP),
            ("2027-04-31 00:00:00.999999", MAX_FSP),
        ];

        for (case, fsp) in cases {
            let mut ctx = EvalContext::from(TimeEnv {
                allow_invalid_date: true,
                ..TimeEnv::default()
            });
            let time = Time::parse_datetime(&mut ctx, case, fsp, false)?;

            let packed = time.to_packed_u64(&mut ctx)?;
            let reverted_datetime =
                Time::from_packed_u64(&mut ctx, packed, TimeType::DateTime, fsp)?;

            assert_eq!(time, reverted_datetime);
        }

        Ok(())
    }
```


Overlapping Code:
```
test_codec_datetime() -> Result<()> {
let cases = vec![
("2010-10-10 10:11:11", 0),
("2017-01-01 00:00:00", 0),
("2004-01-01 00:00:00", UNSPECIFIED_FSP),
("2013-01-01 00:00:00.000000", MAX_FSP),
("2019-01-01 00:00:00.123456", MAX_FSP),
("2001-01-01 00:00:00.123456", MAX_FSP),
("2007-06-01 00:00:00.999999", MAX_FSP),
// Invalid cases
("0000-00-00 00:00:00", 0),
("2007-00-01 00:00:00.999999", MAX_FSP),
("2017-01-00 00:00:00.999999", MAX_FSP),
("2027-00-00 00:00:00.999999", MAX_FSP),
("2027-04-31 00:00:00.999999", MAX_FSP),
];
for (case, fsp) in cases {
let mut ctx = EvalContext::from(TimeEnv {
allow_invalid_date: true,
..TimeEnv::default()
});
let time = Time::parse_datetime(&mut ctx, case, fsp, false)?;
let packed = time.to_packed_u64(&mut ctx)?;
let reverted_datetime =
Time::from_packed_u64(&mut ctx, packed, TimeType::DateTime, fsp)?;
ass
```
<Overlap Ratio: 0.947603121516165>

---

--- 324 --
Question ID: 48fdd719daff0a3ee010653b00f98ae7e12f3a36_18
Original Code:
```
pub fn permute_vector_into_buffer() {
    let x = vector![ 0, 1, 2, 3];
    let p = PermutationMatrix::from_array(vec![2, 1, 3, 0]).unwrap();
    let mut output = Vector::zeros(4);
    p.permute_vector_into_buffer(&x, &mut output);
    assert_vector_eq!(output, vector![ 3, 1, 0, 2]);
}
```


Overlapping Code:
```
te_vector_into_buffer() {
let x = vector![ 0, 1, 2, 3];
let p = PermutationMatrix::from_array(vec![2, 1, 3, 0]).unwrap();
let mut output = Vector::zeros(4);
p.permute_vector_into_buffer(&x, &mut output);
assert_vector_eq!(output, vector![ 3, 1, 0, 2]
```
<Overlap Ratio: 0.9398496240601504>

---

--- 325 --
Question ID: 103bb289955d9d19e1c77ea529c987c8fd24466b_7
Original Code:
```
fn _left(state: State) -> State {
    let (s1, s2, s3, s4) = state.coords;
    let coords = (
        Coord {
            x: s1.x - 1,
            y: s1.y,
        },
        Coord {
            x: s2.x - 1,
            y: s2.y,
        },
        Coord {
            x: s3.x - 1,
            y: s3.y,
        },
        Coord {
            x: s4.x - 1,
            y: s4.y,
        },
    );
    State {
        coords: coords,
        position: state.position,
    }
}
```


Overlapping Code:
```
te: State) -> State {
let (s1, s2, s3, s4) = state.coords;
let coords = (
Coord {
x: s1.x - 1,
y: s1.y,
},
Coord {
x: s2.x - 1,
y: s2.y,
},
Coord {
x: s3.x - 1,
y: s3.y,
},
Coord {
x: s4.x - 1,
y: s4.y,
},
);
State {
coords: coords,
position: state.position,
}

```
<Overlap Ratio: 0.9525547445255474>

---

--- 326 --
Question ID: e049f4062c0057693c0c90e18fb5d6b5ec44bb92_336
Original Code:
```
fn problem_2021_19_1() {
    #![allow(clippy::unwrap_used)]
    let input = read_to_string("src/year2021/day19_input.txt").unwrap();
    solve(2021, 19, 1, &input).unwrap();
}
```


Overlapping Code:
```
_1() {
#![allow(clippy::unwrap_used)]
let input = read_to_string("src/year2021/day19_input.txt").unwrap();
solve(2021, 19, 1
```
<Overlap Ratio: 0.7607361963190185>

---

--- 327 --
Question ID: 931992201a7c2a31e83fc3ca3ff95c22f30a61be_3
Original Code:
```
fn perlin_generate_permutation() -> NoiseData {
    let mut result: NoiseData = [0; 256];
    for i in 0..256 {
        result[i] = i;
    }
    permute(&mut result);
    result
}
```


Overlapping Code:
```
n perlin_generate_permutation() -> NoiseData {
let mut result: NoiseData = [0; 256];
for i in 0..256 {
result[i] = i;
}
permute(&mut result);
result
}
```
<Overlap Ratio: 0.9933774834437086>

---

--- 328 --
Question ID: 646397b3942e04431f6ddb56afcd819a544cc158_0
Original Code:
```
pub fn iter(x0: f64, y0: f64, maxi: Uint) -> Uint {
    let (mut x, mut y) = (x0, y0);

    for i in 1..maxi+1 {
        let (xx, yy) = (x*x, y*y);
        if xx+yy >= 4.0 {
            return i;
        }
        y = 2.0*x*y+y0;
        x = xx-yy+x0;
    }

    maxi
}
```


Overlapping Code:
```
4, y0: f64, maxi: Uint) -> Uint {
let (mut x, mut y) = (x0, y0);
for i in 1..maxi+1 {
let (xx, yy) = (x*x, y*y);
if xx+yy >= 4.0 {
return i;
}
y = 2.0
```
<Overlap Ratio: 0.7537688442211056>

---

--- 329 --
Question ID: 8575b68d0fa746beecb98c7add4a8f904d5f4f05_11
Original Code:
```
pub fn get_last_segid_stakes(
    SomeUser: komodorpcutil::KomodoRPC,
    depth: u32,
) -> Result<String, reqwest::Error> {
    let method_name: String = String::from("getlastsegidstakes");
    let method_body: String = String::from(format!("[{}]", depth));
    let data: String = String::from(komodorpcutil::generate_body(
        SomeUser.clone(),
        method_name,
        method_body,
    ));
    komodorpcutil::request(SomeUser.clone(), data)
}
```


Overlapping Code:
```
fn get_last_segid_stakes(
SomeUser: komodorpcutil::KomodoRPC,
depth: u32,
) -> Result<String, reqwest::Error> {
let method_name: String = String::from("getlastsegidstakes");
let method_body: String = String::from(format!("[{}]", depth));
let data: String = String::from(komodorpcutil::generate_body(
SomeUser.clone(),
method_name,
method_body,
));
komodorpcutil::request(SomeUser.clone(), dat
```
<Overlap Ratio: 0.98>

---

--- 330 --
Question ID: e9709670122c32fae206b2a80ebfa4321dfcdf7b_4
Original Code:
```
pub fn render_chars_entity_references_to_chars(
    text: &Vec<char>,
    entities: &Vec<&DecodedEntity>,
) -> Vec<char> {
    let mut my_entities: Vec<&DecodedEntity> = Vec::with_capacity(entities.len());
    for e in entities {
        my_entities.push(e);
    }
    my_entities.sort_unstable();

    let mut sb: Vec<char> = Vec::with_capacity(text.len() * 2);
    let mut pos = 0 as usize;
    my_entities.iter().for_each(|entity| {
        sb.extend_from_slice(&text[pos..entity.start]);
        sb.extend_from_slice(&entity.html);
        pos = entity.end;
    });
    sb.extend_from_slice(&text[pos..text.len()]);
    sb
}
```


Overlapping Code:
```
pub fn render_chars_entity_references_to_chars(
text: &Vec<char>,
entities: &Vec<&DecodedEntity>,
) -> Vec<char> {
let mut my_entities: Vec<&DecodedEntity> = Vec::with_capacity(entities.len());
for e in entities {
my_entities.push(e);
}
my_entities.sort_unstable();
let mut sb: Vec<char> = Vec::with_capacity(text.len() * 2);
let mut pos = 0 as usize;
my_entities.iter().for_each(|entity| {
sb.extend_from_slice(&text[pos..entity.start]);
sb.extend_from_slice(&entity.html);
pos = entity.end;
});
sb.extend_from_slice(&text[pos.
```
<Overlap Ratio: 0.9652650822669104>

---

--- 331 --
Question ID: 48f231d013221c6e8c0d645a2ded48f68932b7cc_2
Original Code:
```
fn parse_int(rem: &mut &str) -> u64 {
    let end = rem
        .char_indices()
        .skip_while(|&(_, c)| c.is_ascii_digit())
        .map(|(i, _)| i)
        .next()
        .unwrap_or(rem.len());

    let int = rem[..end].parse().unwrap();
    *rem = &rem[end..];
    int
}
```


Overlapping Code:
```
se_int(rem: &mut &str) -> u64 {
let end = rem
.char_indices()
.skip_while(|&(_, c)| c.is_ascii_digit())
.map(|(i, _)| i)
.next()
.unwrap_or(rem.len());
let int = rem[..end].parse().unwrap();
*rem = &r
```
<Overlap Ratio: 0.9009009009009009>

---

--- 332 --
Question ID: e62d4bad820b2b50b02221c0ab525295304277f4_7
Original Code:
```
fn test_message() {
    test_text_format_str_descriptor("test_message_singular {}", TestTypes::descriptor_static());

    test_text_format_str_descriptor(
        "test_message_singular { value: 10 }",
        TestTypes::descriptor_static(),
    );

    test_text_format_str_descriptor(
        "test_message_repeated { value: 10 } test_message_repeated { value: 20 }",
        TestTypes::descriptor_static(),
    );
}
```


Overlapping Code:
```
test_message() {
test_text_format_str_descriptor("test_message_singular {}", TestTypes::descriptor_static());
test_text_format_str_descriptor(
"test_message_singular { value: 10 }",
TestTypes::descriptor_static(),
);
test_text_format_str_descriptor(
"test_message_repeated { value: 10 } test_message_repeated { value: 20 }",
TestTypes::descriptor_sta
```
<Overlap Ratio: 0.9615384615384616>

---

--- 333 --
Question ID: a037fa45bf34d8df074e2ce5b0fe164373bceaed_0
Original Code:
```
fn should_list_attacks() {
    let client = ShieldClient::simple(Region::UsEast1);
    let request = ListAttacksRequest::default();

    let result = client.list_attacks(&request).sync().unwrap();
    println!("{:#?}", result);
}
```


Overlapping Code:
```
Client::simple(Region::UsEast1);
let request = ListAttacksRequest::default();
let result = client.list_attacks(&request).sync().unwrap();
println!("{:#?}", result);
}
```
<Overlap Ratio: 0.7830188679245284>

---

--- 334 --
Question ID: c124457118cb97768a98b181f70be07ad85e7dd9_6
Original Code:
```
unsafe fn shrink_in_place(&mut self,
                              ptr: NonNull<u8>,
                              layout: Layout,
                              new_size: usize) -> Result<(), CannotReallocInPlace> {
        let _ = ptr; // this default implementation doesn't care about the actual address.
        debug_assert!(new_size <= layout.size());
        let (l, _u) = self.usable_size(&layout);
        //                      layout.size() <= _u  [guaranteed by usable_size()]
        // new_layout.size() <= layout.size()        [required by this method]
        if l <= new_size {
            Ok(())
        } else {
            Err(CannotReallocInPlace)
        }
    }
```


Overlapping Code:
```
rink_in_place(&mut self,
ptr: NonNull<u8>,
layout: Layout,
new_size: usize) -> Result<(), CannotReallocInPlace> {
let _ = ptr; // this default implementation doesn't care about the actual address.
debug_assert!(new_size <= layout.size());
let (l, _u) = self.usable_size(&layout);
// layout.size() <= _u [guaranteed by usable_size()]
// new_layout.size() <= layout.size() [required by this method]
if l <= new_size {
Ok(())
} else {
Err(CannotReallocI
```
<Overlap Ratio: 0.9513742071881607>

---

--- 335 --
Question ID: 6b05a737ab80d77ea0ef4de1fc466367d251d8c4_3
Original Code:
```
fn make_moon(day: f64, earth_coords: &Array3d) -> PlanetPS {
    let solar_trait = Solarobj::Moon {
        attr: Some(SolarAttr {
            radius: 1.7381e6,
            mass: 0.07346e24,
        }),
    };

    let mut moon_body = PlanetPS {
        solartype: solar_trait,
        coords: SolarobjCoords::default(),
        velocity: Array3d::default(), // Zero until sim update
        n0: 125.1228,
        nc: -0.0529538083,
        i0: 5.1454,
        ic: 0.0,
        w0: 318.0634,
        wc: 0.1643573223,
        a0: 60.2666 / EARTH_RADII_PER_ASTRONOMICAL_UNIT,
        ac: 0.0,
        e0: 0.054900,
        ec: 0.0,
        m0: 115.3654,
        mc: 13.0649929509,
        mag_base: 0.23,
        mag_phase_factor: 0.026,
        mag_nonlinear_factor: 4.0e-9,
        mag_nonlinear_exponent: 4f64,
    };

    // Calculate the location of the moon and convert to heliocentric coords
    let initial_coords = moon_body.ecliptic_cartesian_coords(day) + earth_coords;
    moon_body.coords.ahead_coords = initial_coords;
    moon_body.coords.current_coords = initial_coords;
    moon_body.coords.behind_coords = initial_coords;

    moon_body
}
```


Overlapping Code:
```
arth_coords: &Array3d) -> PlanetPS {
let solar_trait = Solarobj::Moon {
attr: Some(SolarAttr {
radius: 1.7381e6,
mass: 0.07346e24,
}),
};
let mut moon_body = PlanetPS {
solartype: solar_trait,
coords: SolarobjCoords::default(),
velocity: Array3d::default(), // Zero until sim update
n0: 125.1228,
nc: -0.0529538083,
i0: 5.1454,
ic: 0.0,
w0: 318.0634,
wc: 0.1643573223,
a0: 60.2666 / EARTH_RADII_PER_ASTRONOMICAL_UNIT,
ac: 0.0,
e0: 0.054900,
ec: 0.0,
m0: 115.3654,
mc: 13.0649929509,
mag_base: 0.23,
mag_phase_factor: 0.026,
mag_nonlinear_factor: 4.0e-9,
mag_nonlinear_exponent: 4f64,
};
// Calculate the location of the moon and convert to heliocentric coords
let initial_coords = moon_body.ecliptic_cartesian_coords(day) + earth_coords;
moon_body.coords.ahead_coords = initial_coords;
moon_body.coords.current_coords = initial_coords;
moon_body.coor
```
<Overlap Ratio: 0.9239130434782609>

---

--- 336 --
Question ID: 54d6d8efd7e07029294e63de8142cc5e2bb9272d_7
Original Code:
```
fn test_i64() {
    let test: i64 = 0x12345678_90ABCDEF;
    assert_eq!(from_bytes::<BE, i64>(&[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]).unwrap(), test);
    assert_eq!(from_bytes::<LE, i64>(&[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]).unwrap(), test);
  }
```


Overlapping Code:
```
2345678_90ABCDEF;
assert_eq!(from_bytes::<BE, i64>(&[0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF]).unwrap(), test);
assert_eq!(from_bytes::<LE, i64>(&[0xEF, 0xCD, 0xAB, 0x90, 0x78, 0x56, 0x34, 0x12]).unwrap(), test
```
<Overlap Ratio: 0.84765625>

---

--- 337 --
Question ID: 8d7634bac46112fcb1e2733661b44d4394ca48ce_1
Original Code:
```
fn test_statsd_client_decr() {
    let client = new_nop_client("client.test");
    let expected = Counter::new("client.test", "counter.key", -1);
    assert_eq!(expected, client.decr("counter.key").unwrap());
}
```


Overlapping Code:
```
 test_statsd_client_decr() {
let client = new_nop_client("client.test");
let expected = Counter::new("client.test", "counter.key", -1);
assert_eq!(expected, client
```
<Overlap Ratio: 0.8232323232323232>

---

--- 338 --
Question ID: 77efe572845f43de1875230da2a8de1297689d34_0
Original Code:
```
fn test_thermal_parser() {
    let test_data = include_str!("../tests/chassis-thermal.json");
    let result: Thermal = serde_json::from_str(&test_data).unwrap();
    println!("result: {:#?}", result);
}
```


Overlapping Code:
```
parser() {
let test_data = include_str!("../tests/chassis-thermal.json");
let result: Thermal = serde_json::from_str(&test_data).unwrap();
println!("result: {:#?}", resul
```
<Overlap Ratio: 0.8900523560209425>

---

--- 339 --
Question ID: 29e13d4dd0da6fa3c93f41a5bf4533c7c4e334cd_0
Original Code:
```
fn eat_string(chars: &mut Peekable<Chars>) -> Option<String> {
    let mut s = String::with_capacity(15);

    while let Some(c) = chars.next() {
        match c {
            '"' => return Some(s.to_owned()),
            '\\' => match chars.next()? {
                '\\' => s.push('\\'),
                '/' => s.push('/'),
                '"' => s.push('"'),
                'n' => s.push('\n'),
                't' => s.push('\t'),
                'b' => s.push(8 as char),
                'f' => s.push(12 as char),
                'r' => s.push(13 as char),
                'u' => {
                    if let Ok(num) = u8::from_str_radix(&chars.take(4).collect::<String>(), 16) {
                        s.push(num as char);
                    }
                }
                _ => {}
            },
            _ => s.push(c),
        }
    }

    Some(s.to_owned())
}
```


Overlapping Code:
```
at_string(chars: &mut Peekable<Chars>) -> Option<String> {
let mut s = String::with_capacity(15);
while let Some(c) = chars.next() {
match c {
'"' => return Some(s.to_owned()),
'\\' => match chars.next()? {
'\\' => s.push('\\'),
'/' => s.push('/'),
'"' => s.push('"'),
'n' => s.push('\n'),
't' => s.push('\t'),
'b' => s.push(8 as char),
'f' => s.push(12 as char),
'r' => s.push(13 as char),
'u' => {
if let Ok(num) = u8::from_str_radix(&chars.take(4).collect::<String>(), 16) {
s.push(num as char);
}
}
_ => {}
},
_ => s.push(c),
}
}
Some(s.to_owned(
```
<Overlap Ratio: 0.985663082437276>

---

--- 340 --
Question ID: ffd517b59b213f7b78c006298fc3e011b14b4049_2
Original Code:
```
fn read_i16bit_wav_file_test() { // Test based on Hound's tests
        let wav_handler = WavHandler::new("testsamples/pcmwaveformat-16bit-44100Hz-mono.wav").unwrap();
        let file_data = vec![2i16, -3i16, 5i16, -7i16];
        let file_data_f32_conversion: Vec<f32> = file_data.iter()
                                                          .map(|x| (*x as f32) * (1f32 / (i16::MAX as f32 + 1f32)))
                                                          .collect();

        assert_eq!(file_data_f32_conversion, wav_handler.audio_data);
    }
```


Overlapping Code:
```
) { // Test based on Hound's tests
let wav_handler = WavHandler::new("testsamples/pcmwaveformat-16bit-44100Hz-mono.wav").unwrap();
let file_data = vec![2i16, -3i16, 5i16, -7i16];
let file_data_f32_conversion: Vec<f32> = file_data.iter()
.map(|x| (*x as f32) * (1f32 / (i16::MAX as f32 + 1f32)))
.collect();
assert_eq!(file_data_f32_conversion, wav_handler.audio_data
```
<Overlap Ratio: 0.9172932330827067>

---

--- 341 --
Question ID: a50fef61e9c80433c5337e43ef2b50fa0e7fad72_1
Original Code:
```
fn knights_in_corners() {
    let knights = Square::from_pos(Rank::A, File::First).as_bb()
        | Square::from_pos(Rank::H, File::Eighth).as_bb();
    let attacks = attack_targets(knights);
    assert_eq!(0x0020400000020400, attacks.0);
}
```


Overlapping Code:
```
{
let knights = Square::from_pos(Rank::A, File::First).as_bb()
| Square::from_pos(Rank::H, File::Eighth).as_bb();
let attacks = attack_targets(knights
```
<Overlap Ratio: 0.6787330316742082>

---

--- 342 --
Question ID: 7b88f28c36d15e7bf13ac1132acc18ea157450c6_0
Original Code:
```
pub fn parse(input_string: String) -> ParseTree {
    let mut tree = NonTerminal::SourceUnit.to_leaf();
    let current_ptr = &mut 0;
    let input = &mut input_string.chars().collect::<Vec<char>>();
    while *current_ptr < input.len() {
        match lex_4_25::peek_token(input, current_ptr) {
            lex_4_25::Token::Pragma => {
                tree.add_tree(parse_pragma_directive(input, current_ptr));
            }
            lex_4_25::Token::Import => {
                tree.add_tree(parse_import_directive(input, current_ptr));
            }
            lex_4_25::Token::Contract  |
            lex_4_25::Token::Library   |
            lex_4_25::Token::Interface => {
                tree.add_tree(parse_contract_definition(input, current_ptr));
            }
            lex_4_25::Token::EOF => {
                lex_4_25::next_token(input, current_ptr);
            }
            actual => {
                lex_4_25::next_token(input, current_ptr);
                tree.root = NonTerminal::SourceUnit.to_invalid_token_pair(actual);
            }
        }
    }
    tree
}
```


Overlapping Code:
```
tring: String) -> ParseTree {
let mut tree = NonTerminal::SourceUnit.to_leaf();
let current_ptr = &mut 0;
let input = &mut input_string.chars().collect::<Vec<char>>();
while *current_ptr < input.len() {
match lex_4_25::peek_token(input, current_ptr) {
lex_4_25::Token::Pragma => {
tree.add_tree(parse_pragma_directive(input, current_ptr));
}
lex_4_25::Token::Import => {
tree.add_tree(parse_import_directive(input, current_ptr));
}
lex_4_25::Token::Contract |
lex_4_25::Token::Library |
lex_4_25::Token::Interface => {
tree.add_tree(parse_contract_definition(input, current_ptr));
}
lex_4_25::Token::EOF => {
lex_4_25::next_token(input, current_ptr);
}
actual => {
lex_4_25::next_token(input, current_ptr);
tree.root = NonTerminal::SourceUnit.to_inva
```
<Overlap Ratio: 0.9305210918114144>

---

--- 343 --
Question ID: 814cbcc022d08652f6da9219c91e0c8da2a81337_0
Original Code:
```
fn binding_to_unimplemented_apis_doesnt_break_everything() {
    let array = Array::new();
    let res = array.standardized_method_this_js_runtime_doesnt_implement_yet();
    assert!(res.is_err());
}
```


Overlapping Code:
```
o_unimplemented_apis_doesnt_break_everything() {
let array = Array::new();
let res = array.standardized_method_this_js_runtime_doesnt_implement_yet();
```
<Overlap Ratio: 0.8021390374331551>

---

--- 344 --
Question ID: 0b18c2571246b24f06e847aab245d829fafa3049_0
Original Code:
```
pub fn update_registry_and_shuffling_data(
    state: &mut BeaconState,
    current_total_balance: u64,
    spec: &ChainSpec,
) -> Result<(), Error> {
    // First set previous shuffling data to current shuffling data.
    state.previous_shuffling_epoch = state.current_shuffling_epoch;
    state.previous_shuffling_start_shard = state.previous_shuffling_start_shard;
    state.previous_shuffling_seed = state.previous_shuffling_seed;

    let current_epoch = state.current_epoch(spec);
    let next_epoch = current_epoch + 1;

    // Check we should update, and if so, update.
    if should_update_validator_registry(state, spec)? {
        update_validator_registry(state, current_total_balance, spec)?;

        // If we update the registry, update the shuffling data and shards as well.
        state.current_shuffling_epoch = next_epoch;
        state.current_shuffling_start_shard = {
            let active_validators =
                state.get_cached_active_validator_indices(RelativeEpoch::Current, spec)?;
            let epoch_committee_count = spec.get_epoch_committee_count(active_validators.len());

            (state.current_shuffling_start_shard + epoch_committee_count) % spec.shard_count
        };
        state.current_shuffling_seed = state.generate_seed(state.current_shuffling_epoch, spec)?;
    } else {
        // If processing at least on crosslink keeps failing, the reshuffle every power of two, but
        // don't update the current_shuffling_start_shard.
        let epochs_since_last_update = current_epoch - state.validator_registry_update_epoch;

        if epochs_since_last_update > 1 && epochs_since_last_update.is_power_of_two() {
            state.current_shuffling_epoch = next_epoch;
            state.current_shuffling_seed =
                state.generate_seed(state.current_shuffling_epoch, spec)?;
        }
    }

    Ok(())
}
```


Overlapping Code:
```
a(
state: &mut BeaconState,
current_total_balance: u64,
spec: &ChainSpec,
) -> Result<(), Error> {
// First set previous shuffling data to current shuffling data.
state.previous_shuffling_epoch = state.current_shuffling_epoch;
state.previous_shuffling_start_shard = state.previous_shuffling_start_shard;
state.previous_shuffling_seed = state.previous_shuffling_seed;
let current_epoch = state.current_epoch(spec);
let next_epoch = current_epoch + 1;
// Check we should update, and if so, update.
if should_update_validator_registry(state, spec)? {
update_validator_registry(state, current_total_balance, spec)?;
// If we update the registry, update the shuffling data and shards as well.
state.current_shuffling_epoch = next_epoch;
state.current_shuffling_start_shard = {
let active_validators =
state.get_cached_active_validator_indices(RelativeEpoch::Current, spec)?;
let epoch_committee_count = spec.get_epoch_committee_count(active_validators.len());
(state.current_shuffling_start_shard + epoch_committee_count) % spec.shard_count
};
state.current_shuffling_seed = state.generate_seed(state.current_shuffling_epoch, spec)?;
} else {
// If processing at least on crosslink keeps failing, the reshuffle every power of two, but
// don't update the current_shuffling_start_shard.
let epochs_since_last_update = current_epoch - state.validator_registry_update_epoch;
if epochs_since_last_update > 1 && epochs_since_last_update.is_power_of_two() {
state.current_shuffling_epoch = next_epoch;
state.current_shuffling_seed =
state.generate_seed(state.cu
```
<Overlap Ratio: 0.9491733006736068>

---

--- 345 --
Question ID: f4f90cce53e601952a2eb4fb2def5e4d0d39868d_6
Original Code:
```
fn _prepare_block_nosum(
	kc: &ExtKeychain,
	prev: &BlockHeader,
	diff: u64,
	txs: Vec<&Transaction>,
) -> Block {
	let key_id = ExtKeychainPath::new(1, diff as u32, 0, 0, 0).to_identifier();

	let fees = txs.iter().map(|tx| tx.fee()).sum();
	let reward = libtx::reward::output(kc, &key_id, fees, false).unwrap();
	let mut b = match core::core::Block::new(
		prev,
		txs.into_iter().cloned().collect(),
		Difficulty::from_num(diff),
		reward,
	) {
		Err(e) => panic!("{:?}", e),
		Ok(b) => b,
	};
	b.header.timestamp = prev.timestamp + Duration::seconds(60);
	b.header.pow.total_difficulty = Difficulty::from_num(diff);
	b
}
```


Overlapping Code:
```
pare_block_nosum(
kc: &ExtKeychain,
prev: &BlockHeader,
diff: u64,
txs: Vec<&Transaction>,
) -> Block {
let key_id = ExtKeychainPath::new(1, diff as u32, 0, 0, 0).to_identifier();
let fees = txs.iter().map(|tx| tx.fee()).sum();
let reward = libtx::reward::output(kc, &key_id, fees, false).unwrap();
let mut b = match core::core::Block::new(
prev,
txs.into_iter().cloned().collect(),
Difficulty::from_num(diff),
reward,
) {
Err(e) => panic!("{:?}", e),
Ok(b) => b,
};
b.header.timestamp = prev.timestamp + Duration::seconds(60);
b.header.pow.total_dif
```
<Overlap Ratio: 0.919732441471572>

---

--- 346 --
Question ID: 1b03fdfd09f7603796726fd649568fd14e7f04af_1
Original Code:
```
fn openssl_bench(b: &mut Bencher) {
    use openssl::hash::{Hasher, MessageDigest};

    // Make buffer big enough to not fit in cache.
    let buf = vec![0; 1024 * 1024 * 16];

    b.iter(|| {
        let mut h = Hasher::new(MessageDigest::sha1()).unwrap();
        h.write_all(&buf).unwrap();
        h.finish().unwrap();
    })
}
```


Overlapping Code:
```
ch(b: &mut Bencher) {
use openssl::hash::{Hasher, MessageDigest};
// Make buffer big enough to not fit in cache.
let buf = vec![0; 1024 * 1024 * 16];
b.iter(|| {
let mut h = Hasher::new(MessageDigest::sha1()).unwrap();
h.write_all(&buf).unwrap();
h.f
```
<Overlap Ratio: 0.8741258741258742>

---

--- 347 --
Question ID: 871acf8c0c281eda48b914b078dfe4caf16b4b4c_1
Original Code:
```
pub fn do_write(fd: FileDesc, buf: &[u8]) -> Result<usize, Error> {
    let current_ref = process::get_current();
    let current_process = current_ref.lock().unwrap();
    let file_ref = current_process.get_files().get(fd)?;
    file_ref.write(buf)
}
```


Overlapping Code:
```
8]) -> Result<usize, Error> {
let current_ref = process::get_current();
let current_process = current_ref.lock().unwrap();
let file_ref = current_process.get_fil
```
<Overlap Ratio: 0.6851063829787234>

---

--- 348 --
Question ID: e9003be21e9cd0a74b416abdd5eb140f10fddf56_0
Original Code:
```
pub fn read<P: AsRef<Path>>(path: P, size_hint: Option<usize>) -> io::Result<(usize, usize, usize)> {
            let path = path.as_ref();
            let mut ffr = if let Some(size_hint) = size_hint {
                FastFile::read(path)
                    .expect("Failed to create FastFileReaderBuilder")
                    .with_size_hint(size_hint)
                    .open()
                    .expect("Failed to open path as FastFile")
            } else {
                FastFile::read(path)
                    .expect("Failed to create FastFileReaderBuilder")
                    .open()
                    .expect("Failed to open path as FastFile")
            };

            let mut bytes_read = 0usize;
            let mut sum = 0usize;
            let mut reads_count = 0usize;
            loop {
                let len = match ffr.read() {
                    Ok(buf) if buf.is_empty() => return Ok((bytes_read, sum, reads_count)),
                    Ok(buf) => {
                        sum += buf.iter().map(|x| usize::from(*x)).sum::<usize>();
                        buf.len()
                    }
                    Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
                    Err(e) => return Err(e),
                };
                reads_count += 1;
                bytes_read += len;
            }
        }
```


Overlapping Code:
```
pub fn read<P: AsRef<Path>>(path: P, size_hint: Option<usize>) -> io::Result<(usize, usize, usize)> {
let path = path.as_ref();
let mut ffr = if let Some(size_hint) = size_hint {
FastFile::read(path)
.expect("Failed to create FastFileReaderBuilder")
.with_size_hint(size_hint)
.open()
.expect("Failed to open path as FastFile")
} else {
FastFile::read(path)
.expect("Failed to create FastFileReaderBuilder")
.open()
.expect("Failed to open path as FastFile")
};
let mut bytes_read = 0usize;
let mut sum = 0usize;
let mut reads_count = 0usize;
loop {
let len = match ffr.read() {
Ok(buf) if buf.is_empty() => return Ok((bytes_read, sum, reads_count)),
Ok(buf) => {
sum += buf.iter().map(|x| usize::from(*x)).sum::<usize>();
buf.len()
}
Err(ref e) if e.kind() == io::ErrorKind::Interrupted => continue,
Err(e) => return Err(e),
};
reads_count += 1;
byt
```
<Overlap Ratio: 0.9781357882623706>

---

--- 349 --
Question ID: c5ea232e0ddefb1a144497f1ef8f8ffb237b24f3_1
Original Code:
```
fn test_new_by_line_empty_2() {
        let ingredient = Ingredient::new_by_line(";");
        assert_eq!(ingredient.name, "");
        assert_eq!(ingredient.group, Group::Other);
    }
```


Overlapping Code:
```
_by_line_empty_2() {
let ingredient = Ingredient::new_by_line(";");
assert_eq!(ingredient.name, "");
assert_eq!(ingredient.group, Gr
```
<Overlap Ratio: 0.8407643312101911>

---

--- 350 --
Question ID: 02d33f5dbee2c24643a69a08e136740bbaa188d6_6
Original Code:
```
fn fails_to_complete_initialization_if_not_waiting_for_it() {
		let ml = MessageLoop::new(2).init(0).unwrap();
		ml.0.take_and_process_message();
		assert_eq!(ml.session_at(0).on_complete_initialization(ml.0.node(1), &message::CompleteInitialization {
			session: Default::default(),
			session_nonce: 0,
			derived_point: math::generate_random_point().unwrap().into(),
		}), Err(Error::InvalidStateForRequest));
	}
```


Overlapping Code:
```
lete_initialization_if_not_waiting_for_it() {
let ml = MessageLoop::new(2).init(0).unwrap();
ml.0.take_and_process_message();
assert_eq!(ml.session_at(0).on_complete_initialization(ml.0.node(1), &message::CompleteInitialization {
session: Default::default(),
session_nonce: 0,
derived_point: math::generate_random_point().unwrap().into(),
}), Err(Error::InvalidStat
```
<Overlap Ratio: 0.9193954659949622>

---

--- 351 --
Question ID: 35ba411ab6ccdfa2e343b301a029ad3aa9c7fb1a_1
Original Code:
```
pub fn outgoing_metrics<A: Account + CcpRoutingAccount>(
    request: OutgoingRequest<A>,
    mut next: impl OutgoingService<A>,
) -> impl Future<Item = Fulfill, Error = Reject> {
    let labels = labels!(
        "from_asset_code" => request.from.asset_code().to_string(),
        "to_asset_code" => request.to.asset_code().to_string(),
        "from_routing_relation" => request.from.routing_relation().to_string(),
        "to_routing_relation" => request.to.routing_relation().to_string(),
    );

    // TODO replace these calls with the counter! macro if there's a way to easily pass in the already-created labels
    // right now if you pass the labels into one of the other macros, it gets a recursion limit error while expanding the macro
    recorder().increment_counter(
        Key::from_name_and_labels("requests.outgoing.prepare", labels.clone()),
        1,
    );
    let start_time = Instant::now();

    next.send_request(request).then(move |result| {
        if result.is_ok() {
            recorder().increment_counter(
                Key::from_name_and_labels("requests.outgoing.fulfill", labels.clone()),
                1,
            );
        } else {
            recorder().increment_counter(
                Key::from_name_and_labels("requests.outgoing.reject", labels.clone()),
                1,
            );
        }

        recorder().record_histogram(
            Key::from_name_and_labels("requests.outgoing.duration", labels.clone()),
            (Instant::now() - start_time).as_nanos() as u64,
        );
        result
    })
}
```


Overlapping Code:
```
: Account + CcpRoutingAccount>(
request: OutgoingRequest<A>,
mut next: impl OutgoingService<A>,
) -> impl Future<Item = Fulfill, Error = Reject> {
let labels = labels!(
"from_asset_code" => request.from.asset_code().to_string(),
"to_asset_code" => request.to.asset_code().to_string(),
"from_routing_relation" => request.from.routing_relation().to_string(),
"to_routing_relation" => request.to.routing_relation().to_string(),
);
// TODO replace these calls with the counter! macro if there's a way to easily pass in the already-created labels
// right now if you pass the labels into one of the other macros, it gets a recursion limit error while expanding the macro
recorder().increment_counter(
Key::from_name_and_labels("requests.outgoing.prepare", labels.clone()),
1,
);
let start_time = Instant::now();
next.send_request(request).then(move |result| {
if result.is_ok() {
recorder().increment_counter(
Key::from_name_and_labels("requests.outgoing.fulfill", labels.clone()),
1,
);
} else {
recorder().increment_counter(
Key::from_name_and_labels("requests.outgoing.reject", labels.clone()),
1,
);
}
recorder().record_histogram(
Key::from_name_and_labels("requests.outgoing.duration", labels.clone()),
(Instant::now() - start_time).as_nanos() as u64,
```
<Overlap Ratio: 0.9690162664601084>

---

--- 352 --
Question ID: ad25688b53172401da5ffc97264b14502ce12e6e_0
Original Code:
```
fn pregenerate_data<H: Hasher>(degree: usize) -> Pregenerated<H> {
    let mut rng = thread_rng();
    let data: Vec<u8> = (0..(degree + 1))
        .flat_map(|_| fr_into_bytes::<Bls12>(&rng.gen()))
        .collect();
    let parents: Vec<usize> = (0..degree).map(|pos| pos).collect();
    let replica_id: H::Domain = rng.gen();
    Pregenerated {
        data,
        parents,
        replica_id,
    }
}
```


Overlapping Code:
```
n pregenerate_data<H: Hasher>(degree: usize) -> Pregenerated<H> {
let mut rng = thread_rng();
let data: Vec<u8> = (0..(degree + 1))
.flat_map(|_| fr_into_bytes::<Bls12>(&rng.gen()))
.collect();
let parents: Vec<usize> = (0..degree).map(|pos| pos).collect();
let replica_id: H::Domain = rng.gen();
```
<Overlap Ratio: 0.8629737609329446>

---

--- 353 --
Question ID: 28a61e0ae694670963b9349442b4f33323959f7e_0
Original Code:
```
fn _null_chunk_slow<R>(mut rdr: R, max: Option<usize>) -> io::Result<Vec<u8>>
where
    R: io::Read,
{
    let mut buf = Vec::new();
    let mut count = 0;
    loop {
        if let Some(max) = max {
            if count > max {
                break Err(io::ErrorKind::UnexpectedEof.into());
            }
        }

        let byte = rdr.read_u8()?;
        if byte != 0x00 {
            buf.push(byte);
            count += 1;
        } else {
            break Ok(buf);
        }
    }
}
```


Overlapping Code:
```
ion<usize>) -> io::Result<Vec<u8>>
where
R: io::Read,
{
let mut buf = Vec::new();
let mut count = 0;
loop {
if let Some(max) = max {
if count > max {
break Err(io::ErrorKind::UnexpectedEof.into());
}
}
let byte = rdr.read_u8()?;
if byte != 0x00 {
buf.push(byte);
count += 1;
} else {
break Ok(buf);
}
```
<Overlap Ratio: 0.8645533141210374>

---

--- 354 --
Question ID: 41ccb31f1a0052a8d992fa5f0b9831a8fdbd346b_0
Original Code:
```
fn update(host: &mut HostApi, state: &mut State) -> ShouldQuit {
    state.set_host(host);
    state.update_and_render();
    ShouldQuit::No
}
```


Overlapping Code:
```
 -> ShouldQuit {
state.set_host(host);
state.updat
```
<Overlap Ratio: 0.38461538461538464>

---

--- 355 --
Question ID: 5c5a296736c56916cf1a8908600471af2952d7c2_0
Original Code:
```
pub fn save(new_todo: NewTodo) -> Todo {
    let mut todos = TODOS.write().unwrap();
    todos.counter += 1;
    let todo = Todo {
        id: todos.counter,
        title: new_todo.title,
        completed: new_todo.completed.unwrap_or(false),
        order: new_todo.order.unwrap_or(0),
    };

    todos.db.insert(todo.id, todo.clone());
    todo
}
```


Overlapping Code:
```
new_todo: NewTodo) -> Todo {
let mut todos = TODOS.write().unwrap();
todos.counter += 1;
let todo = Todo {
id: todos.counter,
title: new_todo.title,
completed: new_todo.completed.unwrap_or(false),
order: new_todo.order.unwrap_or(0),
};
todos.db.inser
```
<Overlap Ratio: 0.8503401360544217>

---

--- 356 --
Question ID: ff59c7ea7617a563fc51b5b5692cc80137be391a_89
Original Code:
```
fn test_function() {
        let s = to_chars("function");
        let cur = &mut 0;
        expect_next_token(&s, cur, Token::Function);
    }
```


Overlapping Code:
```
unction");
let cur = &mut 0;
expect_next_token(&s, cur, Token::
```
<Overlap Ratio: 0.5478260869565217>

---

--- 357 --
Question ID: 5cb84beea124480ed2fce88c87e31da1965ff14a_0
Original Code:
```
pub fn fetch(instr_mem: &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {
    alignment_check(pc)?;

    let instr = instr_mem.read_u32(pc as usize)?;
    let next_pc = pc + 4;
    Ok((instr, next_pc))
}
```


Overlapping Code:
```
 &dyn MemoryAccess, pc: u32) -> Result<(u32, u32), FetchError> {
alignment_check(pc)?;
let instr = instr_mem.read_u32(pc as usize)?;
let next_pc = pc 
```
<Overlap Ratio: 0.75>

---

--- 358 --
Question ID: e62053eb29d1ca24129f50b429669912dabb72ac_2
Original Code:
```
fn put_var_uint(&mut self, uint: u64) {
        let size = predict_var_uint_size(uint);
        self.put_var_octet_string_length(size);
        self.put_uint_be(uint, size);
    }
```


Overlapping Code:
```
ar_uint(&mut self, uint: u64) {
let size = predict_var_uint_size(uint);
self.put_var_octet_string_length(size);
self.put_uint_be(uin
```
<Overlap Ratio: 0.8741721854304636>

---

--- 359 --
Question ID: 918dbc84e6d0449f3662fd1404138c56c47f1969_0
Original Code:
```
fn main() {
    // Compute the totient of the first 25 natural integers
    println!("N\t phi(n)\t Prime");
    for n in 1..26 {
        let phi_n = phi(n);
        println!("{}\t {}\t {:?}", n, phi_n, phi_n == n - 1);
    }

    // Compute the number of prime numbers for various steps
    [1, 100, 1000, 10000, 100000]
        .windows(2)
        .scan(0, |acc, window| {
            let (lower, upper) = (window[0], window[1]);
            *acc += (lower..=upper).filter(is_prime).count();
            Some((upper, *acc))
        })
        .for_each(|x| println!("Until {}: {} prime numbers", x.0, x.1));
}
```


Overlapping Code:
```
totient of the first 25 natural integers
println!("N\t phi(n)\t Prime");
for n in 1..26 {
let phi_n = phi(n);
println!("{}\t {}\t {:?}", n, phi_n, phi_n == n - 1);
}
// Compute the number of prime numbers for various steps
[1, 100, 1000, 10000, 100000]
.windows(2)
.scan(0, |acc, window| {
let (lower, upper) = (window[0], window[1]);
*acc += (lower..=upper).filter(is_prime).count();
Some((upper, *acc))
})
.for_each(|x| println!("Until {}: {} prime
```
<Overlap Ratio: 0.8982035928143712>

---

--- 360 --
Question ID: 99567ce850ec5f85c9892be34b275a1bd667c349_1
Original Code:
```
fn test_inverse() {
        let perm1 = Permutation::new(0..9).unwrap();
        let mut perm2 = perm1.clone();
        perm2.invert();
        assert_eq!(perm1, perm2);

        let mut perm1 = Permutation::new(vec![3, 0, 1, 2, 4]).unwrap();
        let mut perm2 = perm1.clone();
        perm2.invert();
        perm1.compose_with(&perm2);
        assert!(perm1.is_identity());
    }
```


Overlapping Code:
```
et perm1 = Permutation::new(0..9).unwrap();
let mut perm2 = perm1.clone();
perm2.invert();
assert_eq!(perm1, perm2);
let mut perm1 = Permutation::new(vec![3, 0, 1, 2, 4]).unwrap();
let mut perm2 = perm1.clone();
perm2.invert();
perm1.compose_with(&pe
```
<Overlap Ratio: 0.8116883116883117>

---

--- 361 --
Question ID: 3fec523dcb6d96ef2d6f29f70124ebe3f1578bf2_0
Original Code:
```
pub fn light_block_import<B, E, Block: BlockT<Hash=H256>, RA, PRA>(
	client: Arc<Client<B, E, Block, RA>>,
	authority_set_provider: Arc<dyn AuthoritySetForFinalityChecker<Block>>,
	api: Arc<PRA>,
) -> Result<GrandpaLightBlockImport<B, E, Block, RA>, ClientError>
	where
		B: Backend<Block, Blake2Hasher> + 'static,
		E: CallExecutor<Block, Blake2Hasher> + 'static + Clone + Send + Sync,
		RA: Send + Sync,
		PRA: ProvideRuntimeApi,
		PRA::Api: GrandpaApi<Block>,
{
	let info = client.info();
	#[allow(deprecated)]
	let import_data = load_aux_import_data(info.chain.finalized_hash, &**client.backend(), api)?;
	Ok(GrandpaLightBlockImport {
		client,
		authority_set_provider,
		data: Arc::new(RwLock::new(import_data)),
	})
}
```


Overlapping Code:
```
t_block_import<B, E, Block: BlockT<Hash=H256>, RA, PRA>(
client: Arc<Client<B, E, Block, RA>>,
authority_set_provider: Arc<dyn AuthoritySetForFinalityChecker<Block>>,
api: Arc<PRA>,
) -> Result<GrandpaLightBlockImport<B, E, Block, RA>, ClientError>
where
B: Backend<Block, Blake2Hasher> + 'static,
E: CallExecutor<Block, Blake2Hasher> + 'static + Clone + Send + Sync,
RA: Send + Sync,
PRA: ProvideRuntimeApi,
PRA::Api: GrandpaApi<Block>,
{
let info = client.info();
#[allow(deprecated)]
let import_data = load_aux_import_data(info.chain.finalized_hash, &**client.backend(), api)?;
Ok(GrandpaLightBlockImport {
client,
authority_set_provider,
data: Arc::new(RwLock::new(im
```
<Overlap Ratio: 0.9599427753934192>

---

--- 362 --
Question ID: a6369dc4c983beb04ed254ef2f1ba5e7e983dc43_7
Original Code:
```
fn delegate_to_test(){
    let mut this=Foo{value:(3,5,8,13,21)};

    let fields=&[
        FieldInfo::not_renamed("0"),
        FieldInfo::not_renamed("1"),
        FieldInfo::not_renamed("2"),
        FieldInfo::not_renamed("3"),
        FieldInfo::not_renamed("4"),
    ];

    assert_eq!( this.fields_info(), &fields[..] );
    assert_eq!( get_fields_assoc_const(&this), &fields[..] );

    assert_eq!(
        this.fields(fp!(1,3,0,2,4)),
        (&5,&13,&3,&8,&21),
    );
    assert_eq!(
        this.fields_mut(fp!(1,3,0,2,4)),
        (&mut 5,&mut 13,&mut 3,&mut 8,&mut 21),
    );

    assert_eq!( this.clone().into_field(fp!(0)), 3 );
    assert_eq!( this.clone().into_field(fp!(1)), 5 );
    assert_eq!( this.clone().into_field(fp!(2)), 8 );
    assert_eq!( this.clone().into_field(fp!(3)), 13 );
    assert_eq!( this.clone().into_field(fp!(4)), 21 );
}
```


Overlapping Code:
```
(3,5,8,13,21)};
let fields=&[
FieldInfo::not_renamed("0"),
FieldInfo::not_renamed("1"),
FieldInfo::not_renamed("2"),
FieldInfo::not_renamed("3"),
FieldInfo::not_renamed("4"),
];
assert_eq!( this.fields_info(), &fields[..] );
assert_eq!( get_fields_assoc_const(&this), &fields[..] );
assert_eq!(
this.fields(fp!(1,3,0,2,4)),
(&5,&13,&3,&8,&21),
);
assert_eq!(
this.fields_mut(fp!(1,3,0,2,4)),
(&mut 5,&mut 13,&mut 3,&mut 8,&mut 21),
);
assert_eq!( this.clone().into_field(fp!(0)), 3 );
assert_eq!( this.clone().into_field(fp!(1)), 5 );
assert_eq!( this.clone().into_field(fp!(2)), 8 );
assert_eq!( this.clone().into_field(fp!(3)), 13 );
assert_eq!( th
```
<Overlap Ratio: 0.885558583106267>

---

--- 363 --
Question ID: 90bf85eca0ffa7db9371046e8587a54f62c4813c_1
Original Code:
```
pub fn get_random_peers(
    conn: &Connection,
    count: u32,
    expired_at_ms: u64,
) -> DBResult<Vec<PeerId>> {
    // random select peers that we have connect to recently.
    let mut stmt = conn.prepare(
        "SELECT peer_id FROM peer_info 
                                WHERE ban_time_secs < strftime('%s','now') 
                                AND last_connected_at_secs > :time 
                                ORDER BY RANDOM() LIMIT :count",
    )?;
    let rows = stmt.query_map_named(
        &[
            (":count", &count),
            (":time", &millis_to_secs(expired_at_ms)),
        ],
        |row| Ok(PeerId::from_bytes(row.get(0)?).expect("parse peer_id")),
    )?;
    rows.collect::<Result<Vec<_>, _>>().map_err(Into::into)
}
```


Overlapping Code:
```
peers(
conn: &Connection,
count: u32,
expired_at_ms: u64,
) -> DBResult<Vec<PeerId>> {
// random select peers that we have connect to recently.
let mut stmt = conn.prepare(
"SELECT peer_id FROM peer_info 
WHERE ban_time_secs < strftime('%s','now') 
AND last_connected_at_secs > :time 
ORDER BY RANDOM() LIMIT :count",
)?;
let rows = stmt.query_map_named(
&[
(":count", &count),
(":time", &millis_to_secs(expired_at_ms)),
],
|row| Ok(PeerId::from_bytes(row.get(0)?).expect("parse peer_id")),
)?;
rows.collect::<Result<Vec<_>, _>>().map_err(Into::into)
```
<Overlap Ratio: 0.9649122807017544>

---

--- 364 --
Question ID: 3b302192db72a36180e84949f0e32c0ba23d8d6a_2
Original Code:
```
fn fontgen_should_reject_padding_larger_than_slot_glyph_size() -> Result<(), Box<std::error::Error>> {
    let mut cmd = Command::cargo_bin("fontgen")?;
    cmd.arg("--input")
        .arg("assets/FreeMono.ttf")
        .arg("--output")
        .arg("FreeMono.bmfa")
        .arg("--padding")
        .arg("129")
        .arg("--slot-glyph-size")
        .arg("128");
    cmd.assert().failure();

    Ok(())
}
```


Overlapping Code:
```
ld_reject_padding_larger_than_slot_glyph_size() -> Result<(), Box<std::error::Error>> {
let mut cmd = Command::cargo_bin("fontgen")?;
cmd.arg("--input")
.arg("assets/FreeMono.ttf")
.arg("--output")
.arg("FreeMono.bmfa")
.arg("--padding")
.arg("129")
.arg("--slot-glyph-size")
.arg("128");
cmd.assert(
```
<Overlap Ratio: 0.8928571428571429>

---

--- 365 --
Question ID: 487997dd54a7c4c3dce18928fcf3135a4cfc70d7_0
Original Code:
```
fn test_run() {
    let man = ProcessManager::new();
    let inner = man.clone();
    let flag: Arc<RwLock<Option<Vec<u8>>>> = Default::default();
    let inner_flag = flag.clone();

    thread::spawn(move || {
        inner.run_process_with_intercept(
            "foo".to_string(),
            Command::new("echo").arg("hello"),
            move |ev: ProcessEvent, k: &dyn Fn(ProcessEvent) -> Result<()>| {
                println!("event: {}", ev);
                if let ProcessEvent::Output(_handle, bytes, len) = &ev {
                    if *len > 0 {
                        *inner_flag.write().unwrap() = Some({
                            let mut b = bytes.clone();
                            b.truncate(*len);
                            b
                        })
                    }
                };
                k(ev)
            },
        )
    });

    println!("running the directory");
    man.run_director().expect("run_director failed");

    let mv = flag.read().unwrap();
    let v = mv.as_ref().unwrap();
    assert_eq!(&v[..v.len()], "hello\n".as_bytes());
}
```


Overlapping Code:
```
ocessManager::new();
let inner = man.clone();
let flag: Arc<RwLock<Option<Vec<u8>>>> = Default::default();
let inner_flag = flag.clone();
thread::spawn(move || {
inner.run_process_with_intercept(
"foo".to_string(),
Command::new("echo").arg("hello"),
move |ev: ProcessEvent, k: &dyn Fn(ProcessEvent) -> Result<()>| {
println!("event: {}", ev);
if let ProcessEvent::Output(_handle, bytes, len) = &ev {
if *len > 0 {
*inner_flag.write().unwrap() = Some({
let mut b = bytes.clone();
b.truncate(*len);
b
})
}
};
k(ev)
},
)
});
println!("running the directory");
man.run_director().expect("run_director failed");
let mv = flag.read().unwrap();
let v = mv.as_ref().unwrap();
assert_eq!(&v[..v.len()], "hello\n".as_bytes()
```
<Overlap Ratio: 0.9571045576407506>

---

--- 366 --
Question ID: 3048cef1fe3ed92c2a75e92ef6cb649ff367ac1b_1
Original Code:
```
fn special_chars_test() {
        let (mut lex, mut buf) = make_lex_and_buf(
            r#"?x!+ // -| ]z]]"#
        );

        assert_oks!(for lex and buf ;
            Token::Character('?')
            Token::Character('x')
            Token::Character('!')
            Token::Character('+')
            Token::Whitespace(' ')
            Token::Character('/')
            Token::Character('/')
            Token::Whitespace(' ')
            Token::Character('-')
            Token::Character('|')
            Token::Whitespace(' ')
            Token::Character(']')
            Token::Character('z')
            Token::Chunk("]]")
        );
        assert_none!(for lex and buf);
    }
```


Overlapping Code:
```
al_chars_test() {
let (mut lex, mut buf) = make_lex_and_buf(
r#"?x!+ // -| ]z]]"#
);
assert_oks!(for lex and buf ;
Token::Character('?')
Token::Character('x')
Token::Character('!')
Token::Character('+')
Token::Whitespace(' ')
Token::Character('/')
Token::Character('/')
Token::Whitespace(' ')
Token::Character('-')
Token::Character('|')
Token::Whitespace(' ')
Token::Character(']')
Token::Character('z')
Token::Chunk("]]")
);
assert_none!(for lex and
```
<Overlap Ratio: 0.9656652360515021>

---

--- 367 --
Question ID: 6fb4663bd5897e58b347d5e9d64c66d596d2a8fc_7
Original Code:
```
fn process_overspecified_remap() {
        let mut mode_map = ModeMap::<u8, TestOp>::new();
        assert_eq!(
            InsertionResult::Create,
            mode_map.insert_remap(vec![1u8, 1u8, 1u8], vec![2u8])
        );

        let mut typeahead = Typeahead::<u8>::new();
        typeahead.push_back(1u8, RemapType::Remap);
        typeahead.push_back(1u8, RemapType::Remap);

        assert_eq!(Err(MapErr::NoMatch), mode_map.process(&mut typeahead));
        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());
        assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());
        assert_eq!(None, typeahead.pop_front());
    }
```


Overlapping Code:
```
cified_remap() {
let mut mode_map = ModeMap::<u8, TestOp>::new();
assert_eq!(
InsertionResult::Create,
mode_map.insert_remap(vec![1u8, 1u8, 1u8], vec![2u8])
);
let mut typeahead = Typeahead::<u8>::new();
typeahead.push_back(1u8, RemapType::Remap);
typeahead.push_back(1u8, RemapType::Remap);
assert_eq!(Err(MapErr::NoMatch), mode_map.process(&mut typeahead));
assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());
assert_eq!(Some((1u8, RemapType::Remap)), typeahead.pop_front());
assert_eq!(None, typeahead.pop_front());
```
<Overlap Ratio: 0.9637681159420289>

---

--- 368 --
Question ID: fca924f526160ff35a76982b32c8bef963bf7e64_6
Original Code:
```
fn it_resolves() {
        let c = setup(false);
        assert_eq!(
            c.node().resolve(0),
            Some(vec![(c.narrow_base_id().as_global(), 0)])
        );
        assert_eq!(c.node().resolve(1), None);
    }
```


Overlapping Code:
```
t c = setup(false);
assert_eq!(
c.node().resolve(0),
Some(vec![(c.narrow_base_id().as_global(), 0)])
);
assert_eq
```
<Overlap Ratio: 0.6848484848484848>

---

--- 369 --
Question ID: 44707d76fcae4b9d0b451a68e7256373916d4b9f_18
Original Code:
```
fn test_wrap_nodes_with_content_sizing_overflowing_margin() {
	let mut root = Node::new();
	root.set_width(StyleUnit::Point(500.0.into()));
	root.set_height(StyleUnit::Point(500.0.into()));

	let mut root_child0 = Node::new();
	root_child0.set_flex_direction(FlexDirection::Row);
	root_child0.set_flex_wrap(Wrap::Wrap);
	root_child0.set_width(StyleUnit::Point(85.0.into()));
	root.insert_child(&mut root_child0, 0);

	let mut root_child0_child0 = Node::new();
	root_child0.insert_child(&mut root_child0_child0, 0);

	let mut root_child0_child0_child0 = Node::new();
	root_child0_child0_child0.set_width(StyleUnit::Point(40.0.into()));
	root_child0_child0_child0.set_height(StyleUnit::Point(40.0.into()));
	root_child0_child0.insert_child(&mut root_child0_child0_child0, 0);

	let mut root_child0_child1 = Node::new();
	root_child0_child1.set_margin(Edge::Right, StyleUnit::Point(10.0.into()));
	root_child0.insert_child(&mut root_child0_child1, 1);

	let mut root_child0_child1_child0 = Node::new();
	root_child0_child1_child0.set_width(StyleUnit::Point(40.0.into()));
	root_child0_child1_child0.set_height(StyleUnit::Point(40.0.into()));
	root_child0_child1.insert_child(&mut root_child0_child1_child0, 0);
	root.calculate_layout(Undefined, Undefined, Direction::LTR);

	assert_eq!(0, root.get_layout_left() as i32);
	assert_eq!(0, root.get_layout_top() as i32);
	assert_eq!(500, root.get_layout_width() as i32);
	assert_eq!(500, root.get_layout_height() as i32);

	assert_eq!(0, root_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0.get_layout_top() as i32);
	assert_eq!(85, root_child0.get_layout_width() as i32);
	assert_eq!(80, root_child0.get_layout_height() as i32);

	assert_eq!(0, root_child0_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child0.get_layout_height() as i32);

	assert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);

	assert_eq!(0, root_child0_child1.get_layout_left() as i32);
	assert_eq!(40, root_child0_child1.get_layout_top() as i32);
	assert_eq!(40, root_child0_child1.get_layout_width() as i32);
	assert_eq!(40, root_child0_child1.get_layout_height() as i32);

	assert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);

	root.calculate_layout(Undefined, Undefined, Direction::RTL);

	assert_eq!(0, root.get_layout_left() as i32);
	assert_eq!(0, root.get_layout_top() as i32);
	assert_eq!(500, root.get_layout_width() as i32);
	assert_eq!(500, root.get_layout_height() as i32);

	assert_eq!(415, root_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0.get_layout_top() as i32);
	assert_eq!(85, root_child0.get_layout_width() as i32);
	assert_eq!(80, root_child0.get_layout_height() as i32);

	assert_eq!(45, root_child0_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child0.get_layout_height() as i32);

	assert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);

	assert_eq!(35, root_child0_child1.get_layout_left() as i32);
	assert_eq!(40, root_child0_child1.get_layout_top() as i32);
	assert_eq!(40, root_child0_child1.get_layout_width() as i32);
	assert_eq!(40, root_child0_child1.get_layout_height() as i32);

	assert_eq!(0, root_child0_child1_child0.get_layout_left() as i32);
	assert_eq!(0, root_child0_child1_child0.get_layout_top() as i32);
	assert_eq!(40, root_child0_child1_child0.get_layout_width() as i32);
	assert_eq!(40, root_child0_child1_child0.get_layout_height() as i32);
}
```


Overlapping Code:
```
n test_wrap_nodes_with_content_sizing_overflowing_margin() {
let mut root = Node::new();
root.set_width(StyleUnit::Point(500.0.into()));
root.set_height(StyleUnit::Point(500.0.into()));
let mut root_child0 = Node::new();
root_child0.set_flex_direction(FlexDirection::Row);
root_child0.set_flex_wrap(Wrap::Wrap);
root_child0.set_width(StyleUnit::Point(85.0.into()));
root.insert_child(&mut root_child0, 0);
let mut root_child0_child0 = Node::new();
root_child0.insert_child(&mut root_child0_child0, 0);
let mut root_child0_child0_child0 = Node::new();
root_child0_child0_child0.set_width(StyleUnit::Point(40.0.into()));
root_child0_child0_child0.set_height(StyleUnit::Point(40.0.into()));
root_child0_child0.insert_child(&mut root_child0_child0_child0, 0);
let mut root_child0_child1 = Node::new();
root_child0_child1.set_margin(Edge::Right, StyleUnit::Point(10.0.into()));
root_child0.insert_child(&mut root_child0_child1, 1);
let mut root_child0_child1_child0 = Node::new();
root_child0_child1_child0.set_width(StyleUnit::Point(40.0.into()));
root_child0_child1_child0.set_height(StyleUnit::Point(40.0.into()));
root_child0_child1.insert_child(&mut root_child0_child1_child0, 0);
root.calculate_layout(Undefined, Undefined, Direction::LTR);
assert_eq!(0, root.get_layout_left() as i32);
assert_eq!(0, root.get_layout_top() as i32);
assert_eq!(500, root.get_layout_width() as i32);
assert_eq!(500, root.get_layout_height() as i32);
assert_eq!(0, root_child0.get_layout_left() as i32);
assert_eq!(0, root_child0.get_layout_top() as i32);
assert_eq!(85, root_child0.get_layout_width() as i32);
assert_eq!(80, root_child0.get_layout_height() as i32);
assert_eq!(0, root_child0_child0.get_layout_left() as i32);
assert_eq!(0, root_child0_child0.get_layout_top() as i32);
assert_eq!(40, root_child0_child0.get_layout_width() as i32);
assert_eq!(40, root_child0_child0.get_layout_height() as i32);
assert_eq!(0, root_child0_child0_child0.get_layout_left() as i32);
assert_eq!(0, root_child0_child0_child0.get_layout_top() as i32);
assert_eq!(40, root_child0_child0_child0.get_layout_width() as i32);
assert_eq!(40, root_child0_child0_child0.get_layout_height() as i32);
assert_eq!(0, root_child0_child1.get_layout_left() as i32);
assert_eq!(40, root_child0_child1.get_layout_top() as i32);
assert_eq!(40, root_child0_child1.get_layout_width() as i32);
assert_eq!(40, root_child0_child1.get_layout_height() as i32);
assert_eq!(0, root_child0_child1_ch
```
<Overlap Ratio: 0.9995910020449897>

---

--- 370 --
Question ID: 72c9a7eba86ad12532b8101b9ba38d094b9dc8fa_2
Original Code:
```
fn escape<T: AsRef<CStr>>(s: T) -> String {
    let mut res = String::new();
    s.as_ref().to_bytes().iter().for_each(|c| match c {
        b'\n' => {
            res.push_str("\\n");
        }
        b'\t' => {
            res.push_str("\\t");
        }
        _ => {
            if *c >= 0x20 && *c < 0x7f {
                res.push(*c as char);
            } else {
                res.push_str(&format!("\\{:o}", c));
            }
        }
    });
    res
}
```


Overlapping Code:
```
n escape<T: AsRef<CStr>>(s: T) -> String {
let mut res = String::new();
s.as_ref().to_bytes().iter().for_each(|c| match c {
b'\n' => {
res.push_str("\\n");
}
b'\t' => {
res.push_str("\\t");
}
_ => {
if *c >= 0x20 && *c < 0x7f {
res.push(*c as char);
} else {
res.push_str(&format!("\\{:o}", c));
}
}

```
<Overlap Ratio: 0.967741935483871>

---

--- 371 --
Question ID: 592650d55ab075e7500b3d4a644155b35081988e_3
Original Code:
```
fn node_remove_next() {
    let mut node: Node<&str> = Node::new("one");
    node.insert_after(Box::new(Node::new("two")));
    node.remove_after();
}
```


Overlapping Code:
```
node: Node<&str> = Node::new("one");
node.insert_after(Box::new(Node::new("two")));
node.remove_after
```
<Overlap Ratio: 0.7318840579710145>

---

--- 372 --
Question ID: 99ddf068c2e6c5ae1bfed4b3eb160e784bc0d71b_30
Original Code:
```
pub unsafe fn mailimf_comments_new(mut cm_value: *mut libc::c_char) -> *mut mailimf_comments {
    let mut comments: *mut mailimf_comments = 0 as *mut mailimf_comments;
    comments =
        malloc(::std::mem::size_of::<mailimf_comments>() as libc::size_t) as *mut mailimf_comments;
    if comments.is_null() {
        return 0 as *mut mailimf_comments;
    }
    (*comments).cm_value = cm_value;
    return comments;
}
```


Overlapping Code:
```
_new(mut cm_value: *mut libc::c_char) -> *mut mailimf_comments {
let mut comments: *mut mailimf_comments = 0 as *mut mailimf_comments;
comments =
malloc(::std::mem::size_of::<mailimf_comments>() as libc::size_t) as *mut mailimf_comments;
if comments.is_null() {
return 0 as *mut mailimf_comments;
}
(*comments).cm_value = cm_value;
return comments;
}
```
<Overlap Ratio: 0.9210526315789473>

---

--- 373 --
Question ID: edeef41d0f27105f1329da21b4afdf0ce9350dfd_3
Original Code:
```
fn part1_summed_area(input: usize) -> String {
    const GRID_SIZE: usize = 300;
    const SQUARE_SIZE: usize = 3;

    let grid = SummedAreaFuelCellGrid::new(GRID_SIZE, input);
    let (_, (x, y)) = summed_area_calculate_best_square(&grid, SQUARE_SIZE);

    format!("Square of largest total power at: {},{}", x, y)
}
```


Overlapping Code:
```
ummed_area(input: usize) -> String {
const GRID_SIZE: usize = 300;
const SQUARE_SIZE: usize = 3;
let grid = SummedAreaFuelCellGrid::new(GRID_SIZE, input);
let (_, (x, y)) = summed_area_calculate_best_square(&grid, SQUARE_SIZE);
format!("Square of lar
```
<Overlap Ratio: 0.8445945945945946>

---

--- 374 --
Question ID: 866493b9c7622fe5e4d49ba91613c03dea0bbbf7_0
Original Code:
```
fn read_from_source<T: BufRead>(reader: &mut T) -> Result<Value, JpErr> {
    let mut contents = String::new();
    let size = reader.read_to_string(&mut contents)
        .map_err(|_| JpErr::FileReadError)?;

    if size == 0 {
        return Err(JpErr::EmptyFileError);
    }

    let json = from_str(&contents)
        .map_err(|_| JpErr::JsonParseError)?;

    Ok(json)
}
```


Overlapping Code:
```
: BufRead>(reader: &mut T) -> Result<Value, JpErr> {
let mut contents = String::new();
let size = reader.read_to_string(&mut contents)
.map_err(|_| JpErr::FileReadError)?;
if size == 0 {
return Err(JpErr::EmptyFileError);
}
let json = from_str(&contents)
.map_err(|_| JpErr::JsonParseError)?;
Ok(json
```
<Overlap Ratio: 0.9259259259259259>

---

--- 375 --
Question ID: c0a7bc562db7822e47b08f91970f60b2fccf1dd1_2
Original Code:
```
fn should_skip_char(input: char) -> bool {
    // Ignore obsolete control characters, and tab characters we can't render
    // properly anyways.  Also ignore newline characters since we don't
    // support multi-line text at the moment.
    input < '\u{20}'
    // Ignore delete character too
    || input == '\u{7F}'
    // Unicode reserves some characters for "private use".  Systems emit
    // these for no clear reason, so we're just going to ignore all of them.
    || (input >= '\u{E000}' && input <= '\u{F8FF}')
    || (input >= '\u{F0000}' && input <= '\u{FFFFF}')
    || (input >= '\u{100000}' && input <= '\u{10FFFF}')
}
```


Overlapping Code:
```
// Ignore obsolete control characters, and tab characters we can't render
// properly anyways. Also ignore newline characters since we don't
// support multi-line text at the moment.
input < '\u{20}'
// Ignore delete character too
|| input == '\u{7F}'
// Unicode reserves some characters for "private use". Systems emit
// these for no clear reason, so we're just going to ignore all of them.
|| (input >= '\u{E000}' && input <= '\u{F8FF}')
|| (input >= '\u{F0000}' && input <= '\u{FFFFF}')
|| (input
```
<Overlap Ratio: 0.8517887563884157>

---

--- 376 --
Question ID: a8d1fde9c77cd0725b89297c76fc56632d95b453_2
Original Code:
```
fn test_apply_without_bias() {
        let weights: Array2<f64> = array![[0.0, 1.0, 0.0], [1.0, 0.0, 1.0]];
        let input: Array2<f64> = array![[2.0, 5.0], [7.0, 1.0], [4.0, 3.0]];
        let expected_output: Array2<f64> =
            array![[5.0, 2.0, 5.0], [1.0, 7.0, 1.0], [3.0, 4.0, 3.0]];
        let layer: DenseLayer<NdArrayBackend<_>> =
            DenseLayer::new(String::from("layer_1"), weights, None);
        let output = layer.apply(input.try_into().unwrap());
        assert!(output.is_ok());
        let output: Array2<f64> = output.unwrap().try_into().unwrap();
        assert_eq!(output, expected_output);
    }
```


Overlapping Code:
```
 {
let weights: Array2<f64> = array![[0.0, 1.0, 0.0], [1.0, 0.0, 1.0]];
let input: Array2<f64> = array![[2.0, 5.0], [7.0, 1.0], [4.0, 3.0]];
let expected_output: Array2<f64> =
array![[5.0, 2.0, 5.0], [1.0, 7.0, 1.0], [3.0, 4.0, 3.0]];
let layer: DenseLayer<NdArrayBackend<_>> =
DenseLayer::new(String::from("layer_1"), weights, None);
let output = layer.apply(input.try_into().unwrap());
assert!(output.is_ok());
let output: Array2<f64> = output.unwrap().try_into().unwrap();
assert_eq!(output, expected_ou
```
<Overlap Ratio: 0.933579335793358>

---

--- 377 --
Question ID: bdf1312be213b2fabc38569406a808ee67757743_0
Original Code:
```
fn expect_env(key: &str) -> String {
    let value = env::var(key);
    if value.is_err() {
        eprintln!("{} environment variable is not defined.", key);
        eprintln!("Make sure you're running cargo via the `napi` wrapper script to assign correct environment variables and options.");
        std::process::exit(1);
    };
    value.unwrap()
}
```


Overlapping Code:
```
v(key: &str) -> String {
let value = env::var(key);
if value.is_err() {
eprintln!("{} environment variable is not defined.", key);
eprintln!("Make sure you're running cargo via the `napi` wrapper script to assign correct environment variables and options.");
std::process::exit(1);
};
value.unwrap()

```
<Overlap Ratio: 0.9584664536741214>

---

--- 378 --
Question ID: c45b0273ee0058edc6fcbfda651bb0552426749e_2
Original Code:
```
pub fn eql(
    interp: &Artichoke,
    regexp: Value,
    other: Value,
) -> Result<Value, Box<dyn RubyException>> {
    let regexp = unsafe { Regexp::try_from_ruby(interp, &regexp) }.map_err(|err| {
        let err: Box<dyn RubyException> = if let ArtichokeError::UninitializedValue("Regexp") = err
        {
            Box::new(TypeError::new(interp, "uninitialized Regexp"))
        } else {
            Box::new(Fatal::new(
                interp,
                "Unable to extract Rust Regexp from Ruby Regexp receiver",
            ))
        };
        err
    })?;
    let borrow = regexp.borrow();
    borrow.eql(interp, other)
}
```


Overlapping Code:
```

interp: &Artichoke,
regexp: Value,
other: Value,
) -> Result<Value, Box<dyn RubyException>> {
let regexp = unsafe { Regexp::try_from_ruby(interp, &regexp) }.map_err(|err| {
let err: Box<dyn RubyException> = if let ArtichokeError::UninitializedValue("Regexp") = err
{
Box::new(TypeError::new(interp, "uninitialized Regexp"))
} else {
Box::new(Fatal::new(
interp,
"Unable to extract Rust Regexp from Ruby Regexp receiver",
))
};
err
})?;
let borrow = regexp.borrow();
borrow.
```
<Overlap Ratio: 0.9386138613861386>

---

--- 379 --
Question ID: 299ec8d08f451f1a3aad65b243a34e49c04917f5_0
Original Code:
```
fn test_transaction() {
        let hex_tx = hex_bytes("0400008085202f8901e9f7b47c2a612e30a6e2cae39e1d4763901fedd076e9450c5df0f0d087d25\
                    e45010000006b483045022100a4553c79e56d119c50c73055d4e6d6a4f8faa2e257a6762c8f9e2758f208d774022\
                    0250257e51bbeb50ecd8e27b65d976b5108c3bf62ead19984a6377963bcdfd3de012103804a8e414c7c541d7a0720\
                    de5330e1fc51a696286b1523051286058ee9e724c3feffffff02650400000000000017a91466db59c466b84e64eda\
                    5db42cc48c5c8fc927cd4871148e111000000001976a914060277e4e1c2ab568d17ba769dcfc489a9c973a088ac09\
                    8b0400288b04000000000000000000000000").unwrap();
        let tx: Result<Transaction, _> = deserialize(&hex_tx);
        assert!(tx.is_ok());
        let realtx = tx.unwrap();
        // All these tests aren't really needed because if they fail, the hash check at the end
        // will also fail. But these will show you where the failure is so I'll leave them in.
        assert_eq!(realtx.header, TxHeader::FourthAndOverwintered);
        assert_eq!(realtx.version_group_id, 0x892F2085);
        assert_eq!(realtx.input.len(), 1);
        assert_eq!(realtx.output.len(), 2);
        assert_eq!(realtx.lock_time, 297737);
        assert_eq!(realtx.expiry_height, 297768);
        assert_eq!(realtx.join_split.len(), 0);
        assert_eq!(realtx.shielded_output.len(), 0);
        assert_eq!(realtx.shielded_spend.len(), 0);
        assert_eq!(realtx.binding_sig, None);
        assert_eq!(realtx.join_split_pubkey, None);
        assert_eq!(realtx.join_split_sig, None);
    }
```


Overlapping Code:
```
transaction() {
let hex_tx = hex_bytes("0400008085202f8901e9f7b47c2a612e30a6e2cae39e1d4763901fedd076e9450c5df0f0d087d25\
e45010000006b483045022100a4553c79e56d119c50c73055d4e6d6a4f8faa2e257a6762c8f9e2758f208d774022\
0250257e51bbeb50ecd8e27b65d976b5108c3bf62ead19984a6377963bcdfd3de012103804a8e414c7c541d7a0720\
de5330e1fc51a696286b1523051286058ee9e724c3feffffff02650400000000000017a91466db59c466b84e64eda\
5db42cc48c5c8fc927cd4871148e111000000001976a914060277e4e1c2ab568d17ba769dcfc489a9c973a088ac09\
8b0400288b04000000000000000000000000").unwrap();
let tx: Result<Transaction, _> = deserialize(&hex_tx);
assert!(tx.is_ok());
let realtx = tx.unwrap();
// All these tests aren't really needed because if they fail, the hash check at the end
// will also fail. But these will show you where the failure is so I'll leave them in.
assert_eq!(realtx.header, TxHeader::FourthAndOverwintered);
assert_eq!(realtx.version_group_id, 0x892F2085);
assert_eq!(realtx.input.len(), 1);
assert_eq!(realtx.output.len(), 2);
assert_eq!(realtx.lock_time, 297737);
assert_eq!(realtx.expiry_height, 297768);
assert_eq!(realtx.join_split.len(), 0);
assert_eq!(realtx.shielded_output.len(), 0);
assert_eq!(realtx.shielded_spend.len(), 0);
assert_eq!(realtx.binding_sig, None);
assert_eq!(realtx.join_split_pubkey, None);
ass
```
<Overlap Ratio: 0.9651076466221232>

---

--- 380 --
Question ID: 6d6ccdb6ad23839ab86b70aa322f7b95e988d44d_0
Original Code:
```
fn test_cvc4_qfuflia() {
        use std::fs;
        let unparsed_file = fs::read_to_string("tests/data/qfuflia.smt2").expect("cannot read file");
        let mut q = Query::new();
        q.parse_query(&unparsed_file).unwrap();

        let sol_cvc4 = q.check_cvc4().expect("could not parse");
        assert!(q.eval(&sol_cvc4).unwrap());
    }
```


Overlapping Code:
```
fs;
let unparsed_file = fs::read_to_string("tests/data/qfuflia.smt2").expect("cannot read file");
let mut q = Query::new();
q.parse_query(&unparsed_file).unwrap();
let sol_cvc4 = q.check_cvc4().expect("could not parse");
assert!(q.eval(&sol_cvc4).unwrap
```
<Overlap Ratio: 0.863481228668942>

---

--- 381 --
Question ID: ff59c7ea7617a563fc51b5b5692cc80137be391a_18
Original Code:
```
fn test_minus_equals() {
        let s = to_chars("-=");
        let cur = &mut 0;
        expect_next_token(&s, cur, Token::MinusEquals);
    }
```


Overlapping Code:
```
minus_equals() {
let s = to_chars("-=");
let cur = &mut 0;
expect_next_token(&s, cur, Token::MinusEq
```
<Overlap Ratio: 0.8620689655172413>

---

--- 382 --
Question ID: fdd9b3dd30fa3c3b947a0f31d64c585355c642a6_2
Original Code:
```
fn relu_with_threshold_test() {
        assert_eq!(relu_with_threshold(1.0, 2.0), 2.0);
        assert_eq!(relu_with_threshold(0.5, 2.0), 2.0);
        assert_eq!(relu_with_threshold(0.0, 2.0), 2.0);
        assert_eq!(relu_with_threshold(-10.0, 2.0), 2.0);
        assert_eq!(relu_with_threshold(10.0, 2.0), 10.0);
        assert_eq!(relu_with_threshold(1.9, 2.0), 2.0);
        assert_eq!(relu_with_threshold(2.1, 2.0), 2.1);
    }
```


Overlapping Code:
```
th_threshold_test() {
assert_eq!(relu_with_threshold(1.0, 2.0), 2.0);
assert_eq!(relu_with_threshold(0.5, 2.0), 2.0);
assert_eq!(relu_with_threshold(0.0, 2.0), 2.0);
assert_eq!(relu_with_threshold(-10.0, 2.0), 2.0);
assert_eq!(relu_with_threshold(10.0, 2.0), 10.0);
assert_eq!(relu_with_threshold(1.9, 2.0), 2.0);
assert_eq!(relu_with_threshold(2.1, 2.0),
```
<Overlap Ratio: 0.9517426273458445>

---

--- 383 --
Question ID: dec8765a6119b016dea6eacdbbcd90f8406a09d3_0
Original Code:
```
fn solve(players: usize, max_marble: usize) -> usize {
    let mut scores = vec![0usize; players];

    let mut circle = CircularList::with_capacity(max_marble + 1);
    circle.insert(0usize);

    for marble in 1..=max_marble {
        if marble % 23 == 0 {
            scores[marble % players] += circle.seek(-7).remove().unwrap() + marble;
        } else {
            circle.next().insert(marble);
        }
    }

    scores.into_iter().max().unwrap()
}
```


Overlapping Code:
```
 max_marble: usize) -> usize {
let mut scores = vec![0usize; players];
let mut circle = CircularList::with_capacity(max_marble + 1);
circle.insert(0usize);
for marble in 1..=max_marble {
if marble % 23 == 0 {
scores[marble % players] += circle.seek(-7).remove().unwrap() + marble;
} else {
circle.next().insert(marble);
}
}
scores.into_iter().max().u
```
<Overlap Ratio: 0.9138381201044387>

---

